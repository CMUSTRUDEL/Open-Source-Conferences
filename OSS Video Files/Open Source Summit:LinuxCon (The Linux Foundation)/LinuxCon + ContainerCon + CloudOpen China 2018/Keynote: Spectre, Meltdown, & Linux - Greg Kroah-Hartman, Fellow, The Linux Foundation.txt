Title: Keynote: Spectre, Meltdown, & Linux - Greg Kroah-Hartman, Fellow, The Linux Foundation
Publication date: 2018-07-21
Playlist: LinuxCon + ContainerCon + CloudOpen China 2018
Description: 
	Keynote: Spectre, Meltdown, & Linux - Greg Kroah-Hartman, Fellow, The Linux Foundation

This talk will give a brief overview of the recently announced Meltdown and Spectre security problems that were announced early in 2018.  It will cover how the Linux kernel security community addressed these problems, and how all Linux users can be sure they are protected from problems like these with the latest security fixes.
Captions: 
	00:00:03,240 --> 00:00:08,220
this week we've been talking about a lot

00:00:05,640 --> 00:00:11,400
of different technologies artificial

00:00:08,220 --> 00:00:13,740
intelligence a data cloud computing and

00:00:11,400 --> 00:00:17,250
you know everybody said when they

00:00:13,740 --> 00:00:21,840
introduced a new technology use this

00:00:17,250 --> 00:00:26,220
same phrase Hadoop is the Linux of big

00:00:21,840 --> 00:00:29,880
data or tensorflow is the Linux for

00:00:26,220 --> 00:00:32,700
machine learning or kubernetes is the

00:00:29,880 --> 00:00:35,880
Linux of the cloud but you know what all

00:00:32,700 --> 00:00:38,850
those things have in common they run on

00:00:35,880 --> 00:00:39,600
Linux it turns out Linux is very very

00:00:38,850 --> 00:00:42,090
important

00:00:39,600 --> 00:00:45,210
we have great Crowe Hartmann here today

00:00:42,090 --> 00:00:48,960
he is a fellow at the Linux Foundation

00:00:45,210 --> 00:00:51,240
he is a key kernel maintainer maintains

00:00:48,960 --> 00:00:54,150
the long term support kernel is a

00:00:51,240 --> 00:00:57,360
prolific developer and he's going to

00:00:54,150 --> 00:01:00,570
discuss an important issue today around

00:00:57,360 --> 00:01:02,940
cyber security and give a overview of

00:01:00,570 --> 00:01:05,460
the spectre and meltdown vulnerabilities

00:01:02,940 --> 00:01:07,110
and how they have been dealt with in the

00:01:05,460 --> 00:01:09,719
open source kernel community please

00:01:07,110 --> 00:01:14,219
welcome to the stage Greg Rowe Hardman

00:01:09,719 --> 00:01:19,079
hi I'm Greg I got to use my title and

00:01:14,219 --> 00:01:21,869
icons turns out every major security

00:01:19,079 --> 00:01:23,189
problem these days gets a little logo so

00:01:21,869 --> 00:01:25,920
of course spectra have this logo

00:01:23,189 --> 00:01:27,810
meltdown has a logo a Linux has a logo

00:01:25,920 --> 00:01:28,859
so I'm going to go over how this all

00:01:27,810 --> 00:01:32,429
came to be

00:01:28,859 --> 00:01:33,810
what it is at a very high level and I

00:01:32,429 --> 00:01:37,950
want to say at a very high level because

00:01:33,810 --> 00:01:41,420
this is a very very technical issue I'm

00:01:37,950 --> 00:01:44,520
going to be very general very vague

00:01:41,420 --> 00:01:47,009
there are full notes for all the

00:01:44,520 --> 00:01:49,829
resources behind this there was a really

00:01:47,009 --> 00:01:51,840
good talk yesterday in Chinese from a

00:01:49,829 --> 00:01:53,159
canonical developed kernel developer it

00:01:51,840 --> 00:01:56,999
also gave some good information about

00:01:53,159 --> 00:02:01,740
this see my notes see his presentation

00:01:56,999 --> 00:02:04,590
it's a good job so let's try and do this

00:02:01,740 --> 00:02:06,749
on a very high level so spectra was

00:02:04,590 --> 00:02:10,380
announced in January of this year and

00:02:06,749 --> 00:02:11,319
meltdown and it was a big deal because

00:02:10,380 --> 00:02:13,959
of a number

00:02:11,319 --> 00:02:16,870
things it was um this is really a

00:02:13,959 --> 00:02:19,569
hardware bug this is a bug or an issue

00:02:16,870 --> 00:02:21,760
in hardware and the goal of an operating

00:02:19,569 --> 00:02:24,189
system of a kernel is to make the bugs

00:02:21,760 --> 00:02:26,290
and hardware go away so you can't see

00:02:24,189 --> 00:02:29,109
them anymore we deal that out with that

00:02:26,290 --> 00:02:31,209
all the time on devices of the

00:02:29,109 --> 00:02:33,069
peripherals that's the job of a hardware

00:02:31,209 --> 00:02:35,620
of a kernel engineer we work around

00:02:33,069 --> 00:02:38,079
hardware problems this was unique and

00:02:35,620 --> 00:02:42,249
that the bug was in the cpu CPUs

00:02:38,079 --> 00:02:45,639
normally do not have bugs the bug is

00:02:42,249 --> 00:02:48,400
that valid code code that is written

00:02:45,639 --> 00:02:51,400
correctly proper and the current

00:02:48,400 --> 00:02:53,439
everything is good about it can trick

00:02:51,400 --> 00:02:56,680
the CPU into doing bad things

00:02:53,439 --> 00:02:59,980
so valid code that we write gets

00:02:56,680 --> 00:03:02,500
executed by a cpu to do bad things it's

00:02:59,980 --> 00:03:05,829
something it's a new type of security

00:03:02,500 --> 00:03:08,949
research Yan horn from Google found this

00:03:05,829 --> 00:03:11,379
last July it took six months for it to

00:03:08,949 --> 00:03:13,090
come out publicly to other researchers

00:03:11,379 --> 00:03:15,879
also found this at the same time because

00:03:13,090 --> 00:03:18,790
this is an active area of research and

00:03:15,879 --> 00:03:20,949
it exploits how CPUs work modern CPUs

00:03:18,790 --> 00:03:23,229
have to look into the future in order to

00:03:20,949 --> 00:03:25,540
go really fast they have to guess what

00:03:23,229 --> 00:03:27,669
is going on in order to make your work

00:03:25,540 --> 00:03:30,129
load quicker so they guess and if they

00:03:27,669 --> 00:03:32,259
guess wrong they can unwind time and go

00:03:30,129 --> 00:03:34,479
back and fix things up but it's in that

00:03:32,259 --> 00:03:36,489
guessing wrong thing that the CPU is

00:03:34,479 --> 00:03:40,209
actually are affecting parts of the

00:03:36,489 --> 00:03:42,280
system that we never realized there's

00:03:40,209 --> 00:03:44,139
many many different ways this is coming

00:03:42,280 --> 00:03:46,139
out many different variants they call

00:03:44,139 --> 00:03:49,180
them they'll go through a number of them

00:03:46,139 --> 00:03:50,259
they all fix the CPU to do different

00:03:49,180 --> 00:03:51,669
things and you can do it in different

00:03:50,259 --> 00:03:54,069
ways that's why there's different

00:03:51,669 --> 00:03:57,009
variants and they're gonna keep coming

00:03:54,069 --> 00:03:58,269
we know it's been publicly said that

00:03:57,009 --> 00:04:00,579
there's like going to be at least eight

00:03:58,269 --> 00:04:03,430
or nine of these it's going to be a lot

00:04:00,579 --> 00:04:05,259
more coming over time this is just an

00:04:03,430 --> 00:04:07,090
area of research that's gonna happen for

00:04:05,259 --> 00:04:09,039
a while it's going to take the CPU

00:04:07,090 --> 00:04:11,590
vendors a long time to fix this because

00:04:09,039 --> 00:04:13,810
their pipelines are very large for five

00:04:11,590 --> 00:04:15,930
years so it's gonna be around for a

00:04:13,810 --> 00:04:15,930
while

00:04:17,850 --> 00:04:23,460
so let's talk about the variance so the

00:04:20,370 --> 00:04:25,320
first three these are abbreviations I'm

00:04:23,460 --> 00:04:26,580
going to go into them very roughly the

00:04:25,320 --> 00:04:30,000
first three were announced back in

00:04:26,580 --> 00:04:32,310
January the first two I'll go through

00:04:30,000 --> 00:04:36,570
them are later three a and four were

00:04:32,310 --> 00:04:39,090
announced back in March number five was

00:04:36,570 --> 00:04:41,400
leaked a couple weeks ago and the full

00:04:39,090 --> 00:04:45,630
details will come out today actually on

00:04:41,400 --> 00:04:47,220
this one in today in the US time zone I

00:04:45,630 --> 00:04:50,700
felt I could talk more about it but I

00:04:47,220 --> 00:04:52,380
realized I was off so these are the

00:04:50,700 --> 00:04:53,820
numbers that we call them if you look on

00:04:52,380 --> 00:04:54,300
the look at PDF page it goes into the

00:04:53,820 --> 00:04:57,090
details

00:04:54,300 --> 00:04:59,550
these look at PDF table has a lot of

00:04:57,090 --> 00:05:02,040
blank entries this will continue to get

00:04:59,550 --> 00:05:04,020
more so let's talk about the first one

00:05:02,040 --> 00:05:05,100
I'm going to go into how this works a

00:05:04,020 --> 00:05:07,980
little bit to try and give you an idea

00:05:05,100 --> 00:05:11,250
of what is going on here and all these

00:05:07,980 --> 00:05:14,010
issues they just trick the CPU into

00:05:11,250 --> 00:05:15,870
reading memory and they trick the issue

00:05:14,010 --> 00:05:17,550
is that you can read memory that you

00:05:15,870 --> 00:05:18,780
don't normally have access to

00:05:17,550 --> 00:05:21,300
so you can read memory of other

00:05:18,780 --> 00:05:22,710
processes so you can go from one tab in

00:05:21,300 --> 00:05:24,750
a browser to read another tab in the

00:05:22,710 --> 00:05:26,430
browser's memory or you can jump to

00:05:24,750 --> 00:05:28,080
another programs number you can read on

00:05:26,430 --> 00:05:29,940
some of these some of them you can read

00:05:28,080 --> 00:05:31,770
another virtual machines memory and

00:05:29,940 --> 00:05:34,110
that's where the cloud people got really

00:05:31,770 --> 00:05:35,670
really nervous you can go and read like

00:05:34,110 --> 00:05:38,340
SSH keys from another virtual machine

00:05:35,670 --> 00:05:40,260
you can go read Bitcoin addresses from

00:05:38,340 --> 00:05:42,480
another our wallet numbers from another

00:05:40,260 --> 00:05:46,470
machine you can do bad things that way

00:05:42,480 --> 00:05:48,840
if you have CP across our machines where

00:05:46,470 --> 00:05:50,940
you're untrusted code that you know what

00:05:48,840 --> 00:05:52,500
it is and you don't have other virtual

00:05:50,940 --> 00:05:54,900
machines you don't have to worry about

00:05:52,500 --> 00:05:57,810
these issues but if you don't run in the

00:05:54,900 --> 00:05:59,670
cloud you have to worry about them we

00:05:57,810 --> 00:06:01,860
had to fix the core kernel for a number

00:05:59,670 --> 00:06:03,870
of these ones so variant one fix the

00:06:01,860 --> 00:06:06,030
core kernel and then we had to go

00:06:03,870 --> 00:06:07,920
through and fix all the drivers and I'll

00:06:06,030 --> 00:06:10,140
show you about this while there's a lot

00:06:07,920 --> 00:06:11,820
more work to be done here we're lucky in

00:06:10,140 --> 00:06:14,100
Linux we have access to all our driver

00:06:11,820 --> 00:06:16,260
code other operating systems are not so

00:06:14,100 --> 00:06:18,930
lucky so they've had to impose a much

00:06:16,260 --> 00:06:21,570
bigger hammer in the core to slow things

00:06:18,930 --> 00:06:24,060
down and make it go all of these will

00:06:21,570 --> 00:06:26,250
slow down your processes so people are

00:06:24,060 --> 00:06:27,860
sitting workload dive

00:06:26,250 --> 00:06:30,409
depending on your workload some

00:06:27,860 --> 00:06:31,759
not at all some very heavy do your own

00:06:30,409 --> 00:06:35,539
testing I'll talk about that more in a

00:06:31,759 --> 00:06:39,080
minute so let's show this so I get away

00:06:35,539 --> 00:06:42,169
with showing code Makena

00:06:39,080 --> 00:06:44,150
this is a normal valid function in the

00:06:42,169 --> 00:06:46,729
kernel what do we do is we take a user

00:06:44,150 --> 00:06:49,460
value from user space we check and see

00:06:46,729 --> 00:06:52,490
if it's the proper range and we read

00:06:49,460 --> 00:06:56,870
some values from it normal provably

00:06:52,490 --> 00:06:59,599
correct code so when a CPU sees this it

00:06:56,870 --> 00:07:01,129
checks the value of resist it learns

00:06:59,599 --> 00:07:03,529
over time so if you give this a

00:07:01,129 --> 00:07:05,449
perfectly valid range for a couple

00:07:03,529 --> 00:07:07,400
thousand times through this through this

00:07:05,449 --> 00:07:08,419
function it'll guess it says hey I know

00:07:07,400 --> 00:07:11,120
this is going to be good

00:07:08,419 --> 00:07:12,409
let's go read this value and we'll have

00:07:11,120 --> 00:07:14,629
it ready for when the code actually

00:07:12,409 --> 00:07:16,520
makes it to this point in time so it'll

00:07:14,629 --> 00:07:18,770
speculate it'll speculate that you're

00:07:16,520 --> 00:07:20,900
going to get it right but what happens

00:07:18,770 --> 00:07:22,159
if you send this make it right for a lot

00:07:20,900 --> 00:07:24,949
number of times and then you give it a

00:07:22,159 --> 00:07:27,199
really bad value what happens is this

00:07:24,949 --> 00:07:29,990
bad guy you you the CPU will actually go

00:07:27,199 --> 00:07:32,180
and read some really weird portion of

00:07:29,990 --> 00:07:35,449
memory that shouldn't and have it ready

00:07:32,180 --> 00:07:37,430
for you but you check it and it says I

00:07:35,449 --> 00:07:39,169
shouldn't be doing this it unwinds

00:07:37,430 --> 00:07:42,680
itself and away it goes

00:07:39,169 --> 00:07:44,539
but that addition additional work of

00:07:42,680 --> 00:07:47,379
going and reading some part of memory

00:07:44,539 --> 00:07:50,449
that I shouldn't have is observable and

00:07:47,379 --> 00:07:53,409
other probable other programs can see

00:07:50,449 --> 00:07:56,469
that happen and by seeing that happen

00:07:53,409 --> 00:07:59,000
you can determine what that memory was

00:07:56,469 --> 00:08:00,680
so you can do this in a very slow way

00:07:59,000 --> 00:08:04,009
you can read about two thousand bytes a

00:08:00,680 --> 00:08:06,560
second which isn't a lot but it's enough

00:08:04,009 --> 00:08:08,539
you can read the whole of a virtual

00:08:06,560 --> 00:08:10,430
machine of another virtual machines

00:08:08,539 --> 00:08:14,509
memory location dump it somewhere and

00:08:10,430 --> 00:08:16,819
then scan it for SSH keys so normally

00:08:14,509 --> 00:08:18,589
this is perfectly valid code and it's

00:08:16,819 --> 00:08:20,689
still fully valid code if you just do it

00:08:18,589 --> 00:08:26,319
like this but if you happen to do two of

00:08:20,689 --> 00:08:26,319
these in a row maybe

00:08:28,159 --> 00:08:32,959
so do two of these in a row so you load

00:08:31,369 --> 00:08:36,019
an array and then you do another load of

00:08:32,959 --> 00:08:38,449
array based on that value the CPU can go

00:08:36,019 --> 00:08:40,880
way off in the weeds and it'll come back

00:08:38,449 --> 00:08:42,740
and unwind and when it does way off on

00:08:40,880 --> 00:08:45,709
the reason comes back that is when bad

00:08:42,740 --> 00:08:48,290
things happen and these two accesses of

00:08:45,709 --> 00:08:49,699
a speculation in another speculation

00:08:48,290 --> 00:08:52,370
don't have to be right next to each

00:08:49,699 --> 00:08:55,759
other they can be large distances apart

00:08:52,370 --> 00:08:57,860
in your code CPUs look Ahead's are huge

00:08:55,759 --> 00:08:59,870
these days we thought we could get away

00:08:57,860 --> 00:09:03,560
all like 100 and some bytes difference

00:08:59,870 --> 00:09:06,439
no it's no known range of when these can

00:09:03,560 --> 00:09:07,790
be so that can be any point in time you

00:09:06,439 --> 00:09:09,410
do something based on one you're just a

00:09:07,790 --> 00:09:12,290
star you you jump again

00:09:09,410 --> 00:09:14,420
that is the magic happen so that's what

00:09:12,290 --> 00:09:17,149
Yann horn discovered if you verified it

00:09:14,420 --> 00:09:19,519
was Intel and it became a big big

00:09:17,149 --> 00:09:20,959
problem so how we sussed this how do we

00:09:19,519 --> 00:09:23,540
solve this because this is valid code

00:09:20,959 --> 00:09:26,689
this is good code that the CPU should be

00:09:23,540 --> 00:09:28,040
using so what we have to do is there's

00:09:26,689 --> 00:09:29,480
some core kernel changes but then we

00:09:28,040 --> 00:09:31,759
have to go back and touch every single

00:09:29,480 --> 00:09:33,819
driver every single time we make an

00:09:31,759 --> 00:09:36,769
access based on enough user space

00:09:33,819 --> 00:09:39,259
controllable pointer or value to recent

00:09:36,769 --> 00:09:41,959
memory we have to say stop you have to

00:09:39,259 --> 00:09:44,240
stop the CPU by saying we're gonna index

00:09:41,959 --> 00:09:46,069
this array and don't speculate beyond

00:09:44,240 --> 00:09:47,810
this point in time so we have to

00:09:46,069 --> 00:09:50,569
manually find these locations in the

00:09:47,810 --> 00:09:52,069
code and that's a hard thing to do we

00:09:50,569 --> 00:09:54,019
have 20 million lines of code in the

00:09:52,069 --> 00:09:55,910
kernel people started running some

00:09:54,019 --> 00:09:58,209
static analysis tools on this we have

00:09:55,910 --> 00:10:00,529
some good attempts to try and find these

00:09:58,209 --> 00:10:04,189
it's just actually really hard to

00:10:00,529 --> 00:10:05,810
determine where to put these we had one

00:10:04,189 --> 00:10:07,430
tool that did it we found a hundred

00:10:05,810 --> 00:10:09,649
different spots in the kernel turned out

00:10:07,430 --> 00:10:11,389
only five or valid people are working on

00:10:09,649 --> 00:10:12,709
making these tools better we have

00:10:11,389 --> 00:10:14,000
somebody the Linux Foundation who's

00:10:12,709 --> 00:10:15,949
funded by the core infrastructure

00:10:14,000 --> 00:10:17,810
initiative to go through the kernel and

00:10:15,949 --> 00:10:19,250
fix these bugs right now he's doing a

00:10:17,810 --> 00:10:21,889
great job but it's going to take a while

00:10:19,250 --> 00:10:23,680
so every place we have to say stop to

00:10:21,889 --> 00:10:30,199
the CPU so what does this look like

00:10:23,680 --> 00:10:32,630
let's see some more codes sorry yeah I

00:10:30,199 --> 00:10:34,490
get more C code so this function is a

00:10:32,630 --> 00:10:35,139
regulation of speculation it's a really

00:10:34,490 --> 00:10:36,970
we're just

00:10:35,139 --> 00:10:38,920
during a math returning what is the

00:10:36,970 --> 00:10:42,339
range that this value should be in

00:10:38,920 --> 00:10:43,959
reduce some magic GCC macros and reduce

00:10:42,339 --> 00:10:45,670
the mask ABM but then the interesting

00:10:43,959 --> 00:10:48,100
thing is this array index mast no

00:10:45,670 --> 00:10:49,600
speculation and that function is

00:10:48,100 --> 00:10:51,699
something that's specific to each

00:10:49,600 --> 00:10:54,069
different type of processor so this

00:10:51,699 --> 00:10:58,359
issue is actually there for all types of

00:10:54,069 --> 00:11:01,480
processors Intel AMD arm PowerPC s39 the

00:10:58,359 --> 00:11:04,149
MIPS everything that's the other unique

00:11:01,480 --> 00:11:06,669
thing about this bug if all prop modern

00:11:04,149 --> 00:11:10,239
processors have this problem so this is

00:11:06,669 --> 00:11:12,579
how it's fixed for x86 64 all we have to

00:11:10,239 --> 00:11:14,649
do is do these magic to assembly

00:11:12,579 --> 00:11:16,679
language instructions and the processor

00:11:14,649 --> 00:11:18,850
gets confused and stop speculating I

00:11:16,679 --> 00:11:21,100
took a long time trying to figure out

00:11:18,850 --> 00:11:22,449
why these two magic ones are there and

00:11:21,100 --> 00:11:22,839
what they do and I couldn't figure it

00:11:22,449 --> 00:11:24,639
out

00:11:22,839 --> 00:11:26,290
there's a really really good email

00:11:24,639 --> 00:11:28,089
thread I'm the Linux kernel mailing list

00:11:26,290 --> 00:11:30,189
between leanness and a number of other

00:11:28,089 --> 00:11:32,350
kernel developers figuring out how to do

00:11:30,189 --> 00:11:34,689
this when we fix this we happen to do it

00:11:32,350 --> 00:11:36,189
all in public so you can see how we did

00:11:34,689 --> 00:11:37,869
this you can see how we tuned these

00:11:36,189 --> 00:11:39,489
functions and you can see how we made

00:11:37,869 --> 00:11:40,869
things go faster which is really

00:11:39,489 --> 00:11:42,489
interesting from a development point of

00:11:40,869 --> 00:11:46,329
view we ended up with something very

00:11:42,489 --> 00:11:47,529
nice very simple and very fast compared

00:11:46,329 --> 00:11:49,689
to what other people would determine in

00:11:47,529 --> 00:11:51,569
the past so similar language in a

00:11:49,689 --> 00:11:54,129
keynote yay

00:11:51,569 --> 00:11:56,169
let's go back so every single function

00:11:54,129 --> 00:11:58,540
that we do this we have to add this

00:11:56,169 --> 00:12:00,970
array index no spec and when we do that

00:11:58,540 --> 00:12:02,679
the CPU stops it won't speculate beyond

00:12:00,970 --> 00:12:05,919
that point in time we read the value and

00:12:02,679 --> 00:12:09,369
go great but what this means is now the

00:12:05,919 --> 00:12:11,019
CPU is slower and we know this so every

00:12:09,369 --> 00:12:13,149
time you hit one of these functions the

00:12:11,019 --> 00:12:15,309
CPU cannot look ahead in the future so

00:12:13,149 --> 00:12:17,860
we will affect your workloads the

00:12:15,309 --> 00:12:19,869
interesting thing is newer kernels go

00:12:17,860 --> 00:12:21,309
faster than older kernels it's been

00:12:19,869 --> 00:12:24,249
proven we're do better we figure things

00:12:21,309 --> 00:12:28,360
out better older current some workloads

00:12:24,249 --> 00:12:31,329
this fix can affect you five to six

00:12:28,360 --> 00:12:34,059
percent maybe 10 percent but newer

00:12:31,329 --> 00:12:36,429
kernels are faster so Facebook published

00:12:34,059 --> 00:12:39,939
the numbers saying moving from a 4.9

00:12:36,429 --> 00:12:42,369
kernel to a 414 kernel gave us 6 percent

00:12:39,939 --> 00:12:44,049
or 5 percent increase in speed just by

00:12:42,369 --> 00:12:46,889
doing that but when we had to add these

00:12:44,049 --> 00:12:49,439
mitigations to it we lost 4

00:12:46,889 --> 00:12:51,059
the speed so they came out ahead so they

00:12:49,439 --> 00:12:55,100
said we're nearer Colonels were actually

00:12:51,059 --> 00:12:58,619
1% faster with the new with these fixes

00:12:55,100 --> 00:13:00,929
older Colonels got slow older Colonels

00:12:58,619 --> 00:13:02,639
slowed down some operating systems some

00:13:00,929 --> 00:13:05,819
Enterprise Colonels had to stay at older

00:13:02,639 --> 00:13:07,350
versions they got even slower and then

00:13:05,819 --> 00:13:10,049
they implemented things differently I'll

00:13:07,350 --> 00:13:12,199
go into that in a minute so when do we

00:13:10,049 --> 00:13:15,660
fix this it was in publicly announced

00:13:12,199 --> 00:13:17,100
January 2nd to 3rd we've been worried

00:13:15,660 --> 00:13:19,019
about it it's almost to known about this

00:13:17,100 --> 00:13:22,410
for a long time I kind of ruined our

00:13:19,019 --> 00:13:24,869
Christmas vacations actually the 6th we

00:13:22,410 --> 00:13:27,059
fixed in January arm we finally fixed it

00:13:24,869 --> 00:13:29,939
in February for just some kernel

00:13:27,059 --> 00:13:31,769
versions and I say fix so all these

00:13:29,939 --> 00:13:34,439
dates I will be talking about that's the

00:13:31,769 --> 00:13:37,109
first time this was fixed it was not the

00:13:34,439 --> 00:13:38,939
final fix we got better over time we

00:13:37,109 --> 00:13:41,189
found out better ways to do things we

00:13:38,939 --> 00:13:43,439
sped things up those original fixes were

00:13:41,189 --> 00:13:44,279
slow we've made them faster to see what

00:13:43,439 --> 00:13:46,980
do we have today

00:13:44,279 --> 00:13:49,559
and as proof of this the fixes are going

00:13:46,980 --> 00:13:51,149
to keep coming these fixes are not only

00:13:49,559 --> 00:13:52,439
needed for this processor for the

00:13:51,149 --> 00:13:55,079
operating system you have to fix your

00:13:52,439 --> 00:13:57,779
processor so processors have micro code

00:13:55,079 --> 00:14:00,149
or BIOS updates you have to take those

00:13:57,779 --> 00:14:01,589
BIOS updates that's the only way these

00:14:00,149 --> 00:14:03,929
are going to get fixed some of these

00:14:01,589 --> 00:14:05,939
variants can only be fixed by the bias

00:14:03,929 --> 00:14:07,619
some of these variants can only be fixed

00:14:05,939 --> 00:14:10,290
in the operating system you have to keep

00:14:07,619 --> 00:14:12,600
updating your microcode Intel and arm

00:14:10,290 --> 00:14:15,059
have constantly kept updating microcode

00:14:12,600 --> 00:14:16,199
to newer versions different arm vendors

00:14:15,059 --> 00:14:19,860
are implementing things in different

00:14:16,199 --> 00:14:21,509
ways Qualcomm is infamously doing fixing

00:14:19,860 --> 00:14:22,799
this in a different way than other SOC

00:14:21,509 --> 00:14:24,749
vendors so they have different micro

00:14:22,799 --> 00:14:26,759
code updates different kernel changes

00:14:24,749 --> 00:14:29,369
but keep updating because we get them

00:14:26,759 --> 00:14:33,509
better as proof of this we fixed it

00:14:29,369 --> 00:14:36,119
again in May and again in autumn we fix

00:14:33,509 --> 00:14:37,769
it in the 416 or 49 I realized when

00:14:36,119 --> 00:14:39,869
doing this talk we never went back and

00:14:37,769 --> 00:14:41,699
fixed those patches in the 414 kernel

00:14:39,869 --> 00:14:43,709
I'm gonna go talk to the arm developers

00:14:41,699 --> 00:14:46,350
and we didn't fix them in anything older

00:14:43,709 --> 00:14:49,139
than that you'll notice a lot of four

00:14:46,350 --> 00:14:51,959
four kernels they're not fixed in here I

00:14:49,139 --> 00:14:52,700
don't know if they ever will be fixed so

00:14:51,959 --> 00:14:54,920
if you're using the

00:14:52,700 --> 00:14:57,230
kernels moved to a newer one or use an

00:14:54,920 --> 00:14:58,850
enterprise Colonel Sousa is actually

00:14:57,230 --> 00:15:01,220
really good Sousa developers helped out

00:14:58,850 --> 00:15:03,140
a lot with this they have a 4/4 based

00:15:01,220 --> 00:15:04,490
kernel they fix these problems in there

00:15:03,140 --> 00:15:05,960
but they fix him in a way that we

00:15:04,490 --> 00:15:08,390
couldn't take them upstream which is

00:15:05,960 --> 00:15:09,440
fine but it just is a little little fork

00:15:08,390 --> 00:15:11,360
in the way things go

00:15:09,440 --> 00:15:13,760
Red Hat fixes them also in a different

00:15:11,360 --> 00:15:16,070
way as well and their patches didn't

00:15:13,760 --> 00:15:18,260
apply to upstream either but I will call

00:15:16,070 --> 00:15:19,880
out Sousa developers doing a really

00:15:18,260 --> 00:15:23,090
really good job in helping us they did a

00:15:19,880 --> 00:15:24,950
they went above and beyond so let's talk

00:15:23,090 --> 00:15:26,510
about variant number tubes variant

00:15:24,950 --> 00:15:29,270
number two is actually really weird and

00:15:26,510 --> 00:15:31,460
that it CPUs can figure out which way

00:15:29,270 --> 00:15:33,080
the code goes so you guess which way

00:15:31,460 --> 00:15:34,370
you're going to jump and if it gets it

00:15:33,080 --> 00:15:35,990
right your grates if it gets it wrong

00:15:34,370 --> 00:15:38,270
you have to unwind things well if you

00:15:35,990 --> 00:15:40,700
jump one way all the time and then you

00:15:38,270 --> 00:15:42,470
want to say do it again you can jump off

00:15:40,700 --> 00:15:44,750
into the weeds you can figure that out

00:15:42,470 --> 00:15:46,910
and again you can read the data from the

00:15:44,750 --> 00:15:47,750
kernel so you can do that or you can

00:15:46,910 --> 00:15:50,330
read it from another virtual machine

00:15:47,750 --> 00:15:52,520
you're gonna be use this this one we had

00:15:50,330 --> 00:15:54,110
to fix in the compiler way to fix in the

00:15:52,520 --> 00:15:57,890
kernel and we had to fix in the bias

00:15:54,110 --> 00:16:00,500
this one fixed all three places and Mike

00:15:57,890 --> 00:16:02,840
Linden from our Matt Linden from Google

00:16:00,500 --> 00:16:05,300
came up something called repto lean it's

00:16:02,840 --> 00:16:07,490
like a trampoline in a way it does is it

00:16:05,300 --> 00:16:10,040
protects functions pointers from being

00:16:07,490 --> 00:16:12,980
abused and they did that by a way of

00:16:10,040 --> 00:16:14,630
modifying the compiler so we can rebuild

00:16:12,980 --> 00:16:16,910
the whole kernel all the drivers do this

00:16:14,630 --> 00:16:18,800
you do that and everything gets fixed a

00:16:16,910 --> 00:16:20,600
little tiny performance decrease but it

00:16:18,800 --> 00:16:22,190
gets fixed he published a paper there's

00:16:20,600 --> 00:16:24,110
a link to it there it's a really

00:16:22,190 --> 00:16:26,300
interesting read I'm really happy that

00:16:24,110 --> 00:16:27,650
he did this work research published it

00:16:26,300 --> 00:16:29,870
at the same time that all this came out

00:16:27,650 --> 00:16:30,980
and gave it away to the public it's a

00:16:29,870 --> 00:16:32,930
really nice work a piece of work

00:16:30,980 --> 00:16:34,520
unfortunately other operating systems

00:16:32,930 --> 00:16:37,460
could not implement this because they

00:16:34,520 --> 00:16:38,870
can't rebuild the world Microsoft and

00:16:37,460 --> 00:16:40,580
well Apple didn't fix any of this

00:16:38,870 --> 00:16:42,560
Microsoft fix this in a different way

00:16:40,580 --> 00:16:44,450
because they couldn't rebuild all the

00:16:42,560 --> 00:16:45,650
drivers so they had to do some other fun

00:16:44,450 --> 00:16:47,120
things but they also modified their

00:16:45,650 --> 00:16:49,490
compiler they wrote a really interesting

00:16:47,120 --> 00:16:52,850
blog post about how they modified vigil

00:16:49,490 --> 00:16:54,830
C to affect fix these problems but again

00:16:52,850 --> 00:16:57,350
three things had to be fixed here again

00:16:54,830 --> 00:16:59,300
a very unique security issue that we had

00:16:57,350 --> 00:17:01,959
to cross different teams in order to

00:16:59,300 --> 00:17:04,459
talk together anymore

00:17:01,959 --> 00:17:07,490
let's talk about meltdown

00:17:04,459 --> 00:17:10,429
maybe oh we fix it here's the day three

00:17:07,490 --> 00:17:11,660
fixes that could March we finally got

00:17:10,429 --> 00:17:13,069
around to it it took us a while because

00:17:11,660 --> 00:17:15,679
we had to coordinate with the compiler

00:17:13,069 --> 00:17:17,299
people and then again we fixed it more

00:17:15,679 --> 00:17:19,220
and more in newer kernels we got better

00:17:17,299 --> 00:17:21,020
things set up so if you have an older

00:17:19,220 --> 00:17:24,679
kernel based on those days pick a newer

00:17:21,020 --> 00:17:27,110
one your computer will go faster so

00:17:24,679 --> 00:17:28,970
meltdown meltdown happened at the same

00:17:27,110 --> 00:17:32,240
time it's kind of related to standby

00:17:28,970 --> 00:17:33,830
some different people and it was we

00:17:32,240 --> 00:17:35,900
called Spectre variant number three and

00:17:33,830 --> 00:17:37,610
this one just lets you read what's in

00:17:35,900 --> 00:17:39,590
the kernel from user space can't really

00:17:37,610 --> 00:17:44,200
cross the virtual machine but it's still

00:17:39,590 --> 00:17:47,150
a bad thing many years ago some

00:17:44,200 --> 00:17:49,070
researchers in Austria published a paper

00:17:47,150 --> 00:17:51,530
called the kaiser paper and implemented

00:17:49,070 --> 00:17:52,640
it was to try and solve some problems

00:17:51,530 --> 00:17:54,380
where you could guess what the kernel

00:17:52,640 --> 00:17:55,910
addresses were and they proposed some

00:17:54,380 --> 00:17:58,429
patches to it it's called the kaiser

00:17:55,910 --> 00:17:59,929
patches that idea turned out you could

00:17:58,429 --> 00:18:02,600
solve it the same way you could solve

00:17:59,929 --> 00:18:04,070
meltdown the same way and what you have

00:18:02,600 --> 00:18:05,780
to do is every time you enter the kernel

00:18:04,070 --> 00:18:08,059
or every time you exit the kernel it'll

00:18:05,780 --> 00:18:09,409
slow things down by it chunks it moves

00:18:08,059 --> 00:18:12,440
the memory around in different ways so

00:18:09,409 --> 00:18:15,230
you physically can't see things this was

00:18:12,440 --> 00:18:17,929
a huge huge way to change the kernel

00:18:15,230 --> 00:18:20,750
this these changes are what made people

00:18:17,929 --> 00:18:25,340
realize something was coming we were

00:18:20,750 --> 00:18:27,620
doing this work and public one one news

00:18:25,340 --> 00:18:29,600
organization famously said all these

00:18:27,620 --> 00:18:31,250
changes are happening really lay the

00:18:29,600 --> 00:18:34,000
development cycle and leanness isn't

00:18:31,250 --> 00:18:36,350
yelling at anybody something's going on

00:18:34,000 --> 00:18:38,270
so they knew a hint that something big

00:18:36,350 --> 00:18:40,190
was happening it took us about 200

00:18:38,270 --> 00:18:43,250
different patches to implement this

00:18:40,190 --> 00:18:45,380
properly for upstream for older kernels

00:18:43,250 --> 00:18:47,240
we couldn't take those 250 patches we

00:18:45,380 --> 00:18:48,770
had to take the Kaiser patches and add

00:18:47,240 --> 00:18:52,790
it to the kernel the different all

00:18:48,770 --> 00:18:54,290
distributions did this in a way this one

00:18:52,790 --> 00:18:56,360
really really will slow down your

00:18:54,290 --> 00:18:59,630
machine this one really affects certain

00:18:56,360 --> 00:19:01,040
workloads different distributions and

00:18:59,630 --> 00:19:01,700
different kernel versions implemented

00:19:01,040 --> 00:19:03,890
this in different ways

00:19:01,700 --> 00:19:04,780
so much so that it's obvious in

00:19:03,890 --> 00:19:07,630
benchmark Marr

00:19:04,780 --> 00:19:09,670
per call off from t-mobile published a

00:19:07,630 --> 00:19:12,190
paper showing same kernel version

00:19:09,670 --> 00:19:14,590
different distributions different and

00:19:12,190 --> 00:19:15,760
the kernel or version how the speed

00:19:14,590 --> 00:19:17,470
affects different things

00:19:15,760 --> 00:19:19,930
luckily the kernel we released in the

00:19:17,470 --> 00:19:21,400
community was the fastest one of the

00:19:19,930 --> 00:19:22,780
under major enterprise distres was the

00:19:21,400 --> 00:19:24,550
slowest by far because they were trying

00:19:22,780 --> 00:19:26,170
to be very very safe so that our

00:19:24,550 --> 00:19:28,030
enterprise sisters are in the middle so

00:19:26,170 --> 00:19:30,030
it depends on what you're running is how

00:19:28,030 --> 00:19:32,440
fast or how bad this is going to be

00:19:30,030 --> 00:19:33,970
benchmark your workloads your workloads

00:19:32,440 --> 00:19:36,820
you can be very very specific to this

00:19:33,970 --> 00:19:38,290
ones this one really hurt a lot of

00:19:36,820 --> 00:19:41,110
people in the virtual machines space

00:19:38,290 --> 00:19:44,010
it's gonna make things slow we're sorry

00:19:41,110 --> 00:19:46,720
we don't know how to do good any better

00:19:44,010 --> 00:19:48,850
we fix this this one we had ready this

00:19:46,720 --> 00:19:51,190
one was ready to go by the time it came

00:19:48,850 --> 00:19:53,080
it was announced so January 2nd when it

00:19:51,190 --> 00:19:55,780
leaks at least about a week early we

00:19:53,080 --> 00:19:57,310
have fixes ready whom they went out they

00:19:55,780 --> 00:19:58,780
were fixed in a kernel version the other

00:19:57,310 --> 00:20:01,300
stable kernels got him a few days later

00:19:58,780 --> 00:20:04,720
because I have some review arm fix them

00:20:01,300 --> 00:20:09,150
much later the backcourt patches also

00:20:04,720 --> 00:20:12,700
they don't fix things the same way so

00:20:09,150 --> 00:20:15,700
Andy when the core kernel x86 people and

00:20:12,700 --> 00:20:18,340
I have said publicly that there are some

00:20:15,700 --> 00:20:20,440
holes in the old backwards we don't know

00:20:18,340 --> 00:20:22,840
if those holes are exploitable but there

00:20:20,440 --> 00:20:24,190
are holes we know where they are weak

00:20:22,840 --> 00:20:26,200
and we'll tell you where they are but we

00:20:24,190 --> 00:20:28,270
don't know if that's exploit or not to

00:20:26,200 --> 00:20:30,970
be absolutely sure you're safe from this

00:20:28,270 --> 00:20:32,800
use the latest tune-up are 4.14 kernel

00:20:30,970 --> 00:20:34,060
or newer so if you're really worried

00:20:32,800 --> 00:20:41,620
about this using your kernel and you'll

00:20:34,060 --> 00:20:43,330
be fine so various 3a came out out of

00:20:41,620 --> 00:20:45,370
March so now we start getting to

00:20:43,330 --> 00:20:47,110
research from other people who see this

00:20:45,370 --> 00:20:48,460
area and say what other parts of the

00:20:47,110 --> 00:20:50,770
kernel what other parts of the processor

00:20:48,460 --> 00:20:52,240
can be abused and this one you abuse the

00:20:50,770 --> 00:20:54,400
way the system registers are read in a

00:20:52,240 --> 00:20:55,750
processor you can read again put data

00:20:54,400 --> 00:20:58,840
from the kernel or another virtual

00:20:55,750 --> 00:21:00,490
machine but it's solved by the same way

00:20:58,840 --> 00:21:02,890
we solved number three so if you have

00:21:00,490 --> 00:21:05,680
meltdown secure uhm implement it for

00:21:02,890 --> 00:21:08,200
your system you're safe so nice part of

00:21:05,680 --> 00:21:10,870
research kind of interesting it was

00:21:08,200 --> 00:21:12,730
already solved so if you weren't patched

00:21:10,870 --> 00:21:13,590
for that one reason you didn't worry

00:21:12,730 --> 00:21:19,440
about it here

00:21:13,590 --> 00:21:23,970
another reason to worry about so some of

00:21:19,440 --> 00:21:25,230
four processors not only can jump to

00:21:23,970 --> 00:21:26,940
different places remember your different

00:21:25,230 --> 00:21:29,700
laces they can execute and read in other

00:21:26,940 --> 00:21:31,919
places and we're seeing the CCP use are

00:21:29,700 --> 00:21:33,090
very very odd black boxes they can do

00:21:31,919 --> 00:21:35,070
things that we don't really realize we

00:21:33,090 --> 00:21:37,020
can do so this one again you can read

00:21:35,070 --> 00:21:39,059
the kernel from its data in the kernel

00:21:37,020 --> 00:21:41,190
or from another virtual machine this one

00:21:39,059 --> 00:21:42,690
was a little bit easier to fix there's

00:21:41,190 --> 00:21:44,760
some minor code changes in the kernel

00:21:42,690 --> 00:21:48,510
and some major code changes in the

00:21:44,760 --> 00:21:49,950
microcode the kernels fix the microcode

00:21:48,510 --> 00:21:52,919
has not been released

00:21:49,950 --> 00:21:55,679
I will lean on Intel again publicly say

00:21:52,919 --> 00:21:58,320
we're ready we're ready for you

00:21:55,679 --> 00:21:59,309
the Intel has some beta microcode out

00:21:58,320 --> 00:22:02,220
there if you're really worried about

00:21:59,309 --> 00:22:03,020
this talk to them they should get it on

00:22:02,220 --> 00:22:06,210
it um

00:22:03,020 --> 00:22:08,520
they knew about this a plenty of time we

00:22:06,210 --> 00:22:10,950
fix this in x86 these days I do not

00:22:08,520 --> 00:22:13,320
think this is a problem in arm but I'm

00:22:10,950 --> 00:22:14,760
not sure it might be talk to your arm

00:22:13,320 --> 00:22:16,049
vendor if you're really worried arm

00:22:14,760 --> 00:22:19,169
hasn't really said anything about this

00:22:16,049 --> 00:22:25,470
again they only fixed it back to 49 414

00:22:19,169 --> 00:22:28,799
and 416 number five floating points now

00:22:25,470 --> 00:22:30,710
this one gets interesting in that we fix

00:22:28,799 --> 00:22:34,470
this problem in 2016

00:22:30,710 --> 00:22:35,820
accidentally if you take newer kernels

00:22:34,470 --> 00:22:37,409
again I said you go things you get

00:22:35,820 --> 00:22:38,940
things done faster and your kernels run

00:22:37,409 --> 00:22:41,279
faster we also have fixed problems that

00:22:38,940 --> 00:22:43,320
might cut because we didn't know about

00:22:41,279 --> 00:22:44,130
this thing as security issues we knew it

00:22:43,320 --> 00:22:47,669
was a bad idea

00:22:44,130 --> 00:22:52,529
CPUs actually ran slower so we ripped

00:22:47,669 --> 00:22:54,360
this code out way back and 4.6 2016 uses

00:22:52,529 --> 00:22:57,809
the way the floating-point registers can

00:22:54,360 --> 00:22:59,520
be restored the bsd developers have this

00:22:57,809 --> 00:23:01,559
code still in there colonel I think

00:22:59,520 --> 00:23:03,390
Microsoft had this code still in there

00:23:01,559 --> 00:23:06,360
colonel they ripped it out and replaced

00:23:03,390 --> 00:23:08,159
it since then the leaked a little bit

00:23:06,360 --> 00:23:09,390
early because the bsd developers kind of

00:23:08,159 --> 00:23:10,789
were poking around and found this

00:23:09,390 --> 00:23:14,250
problem and talked about it publicly

00:23:10,789 --> 00:23:16,169
last week or two weeks ago it kind of

00:23:14,250 --> 00:23:18,390
leaked the full details about this

00:23:16,169 --> 00:23:19,890
you're gonna be published today the Zen

00:23:18,390 --> 00:23:21,960
developers also published a really good

00:23:19,890 --> 00:23:22,790
report on it the researchers in Germany

00:23:21,960 --> 00:23:25,460
are going to publish

00:23:22,790 --> 00:23:27,470
port is a redacted report it'll come out

00:23:25,460 --> 00:23:31,450
today later today on how this works but

00:23:27,470 --> 00:23:35,390
again we fix this a long time ago so

00:23:31,450 --> 00:23:36,830
back in May 2016 and the 4.6 kernel it

00:23:35,390 --> 00:23:38,420
this type of fix with the major

00:23:36,830 --> 00:23:39,980
architecture change we never back ported

00:23:38,420 --> 00:23:41,870
it because it didn't look like it was a

00:23:39,980 --> 00:23:44,360
big issue but I did for the for for

00:23:41,870 --> 00:23:46,430
kernel so if you're using these kernels

00:23:44,360 --> 00:23:48,020
you're wonderful you're safe

00:23:46,430 --> 00:23:49,490
here's another reason if you're using a

00:23:48,020 --> 00:23:51,920
newer kernel you didn't even have to

00:23:49,490 --> 00:23:53,450
worry about this one always good if you

00:23:51,920 --> 00:23:54,800
were using a little kernel there's

00:23:53,450 --> 00:23:57,200
another really good reason why you

00:23:54,800 --> 00:24:01,090
should never use an old kernel we do fix

00:23:57,200 --> 00:24:04,070
things so why this is the big deal

00:24:01,090 --> 00:24:06,890
again these are CPU bugs these are

00:24:04,070 --> 00:24:09,650
taking code that we thought was correct

00:24:06,890 --> 00:24:12,140
that was formally approved and abuses

00:24:09,650 --> 00:24:14,090
the CPU in ways to make them incorrect

00:24:12,140 --> 00:24:17,270
that's a really radical change in

00:24:14,090 --> 00:24:19,280
people's mindset all operating systems

00:24:17,270 --> 00:24:21,680
were affected everybody was hit by this

00:24:19,280 --> 00:24:24,470
wasn't just Linux wasn't just Windows

00:24:21,680 --> 00:24:27,230
was it was OSX embedded people everybody

00:24:24,470 --> 00:24:29,810
got hit hypervisors the good thing about

00:24:27,230 --> 00:24:30,950
this is now all the kernel developers

00:24:29,810 --> 00:24:33,560
from the major operating systems are

00:24:30,950 --> 00:24:35,420
talking the Linux kernel developers in

00:24:33,560 --> 00:24:37,010
the Microsoft Windows kernel developers

00:24:35,420 --> 00:24:38,330
have a back channel we talk to each

00:24:37,010 --> 00:24:40,070
other now we found problems with each

00:24:38,330 --> 00:24:42,050
other's kernel at times we point things

00:24:40,070 --> 00:24:43,850
out so it's a nice side effect it's

00:24:42,050 --> 00:24:46,370
brought the community of parallel

00:24:43,850 --> 00:24:48,190
developers together in LA because we all

00:24:46,370 --> 00:24:50,990
are worried about how CPUs work

00:24:48,190 --> 00:24:52,490
performances is going to decrease that's

00:24:50,990 --> 00:24:54,530
a big deal for a lot of people a lot of

00:24:52,490 --> 00:24:56,420
cloud a lot of virtual machines

00:24:54,530 --> 00:24:58,520
benchmarks suddenly take a nosedive

00:24:56,420 --> 00:25:00,320
you can claw your way back and get a

00:24:58,520 --> 00:25:02,150
better newer versus the kernel or

00:25:00,320 --> 00:25:03,740
getting things better but it will affect

00:25:02,150 --> 00:25:06,980
performance there's nothing we can do

00:25:03,740 --> 00:25:08,810
about this this is totally new class of

00:25:06,980 --> 00:25:10,820
vulnerabilities these come out around

00:25:08,810 --> 00:25:12,500
every couple of years maybe every 10

00:25:10,820 --> 00:25:14,840
years this is a whole new class of

00:25:12,500 --> 00:25:16,670
research it's going to be worked on for

00:25:14,840 --> 00:25:18,200
a long time from now on we're going to

00:25:16,670 --> 00:25:19,850
be living with this for a very

00:25:18,200 --> 00:25:22,160
long time and we're gonna be fixing them

00:25:19,850 --> 00:25:24,050
for a very long time keep updating your

00:25:22,160 --> 00:25:25,640
kernels we are going to be keep finding

00:25:24,050 --> 00:25:29,230
these problems and we're gonna have to

00:25:25,640 --> 00:25:32,660
keep updating them and update your BIOS

00:25:29,230 --> 00:25:35,170
so when this first came out a lot of you

00:25:32,660 --> 00:25:37,610
saw the ramps from leanness in public I

00:25:35,170 --> 00:25:39,650
complained about this in public the way

00:25:37,610 --> 00:25:42,020
this was released was very very unique

00:25:39,650 --> 00:25:45,560
and it was treated as far as I am

00:25:42,020 --> 00:25:48,230
concerned very badly we were notified

00:25:45,560 --> 00:25:50,870
very very late in the game yon found

00:25:48,230 --> 00:25:52,460
this in July kernel developers some of

00:25:50,870 --> 00:25:54,890
us were notified about this in October

00:25:52,460 --> 00:25:58,520
it came out in December and in December

00:25:54,890 --> 00:26:01,340
early January the way they notified us

00:25:58,520 --> 00:26:02,930
is they notified the companies so a

00:26:01,340 --> 00:26:03,800
traditional company when they find a

00:26:02,930 --> 00:26:04,910
problem they're going to talk to other

00:26:03,800 --> 00:26:08,450
companies because we're used to doing

00:26:04,910 --> 00:26:10,580
with that it turns out the majority of

00:26:08,450 --> 00:26:13,310
the world does not run company based

00:26:10,580 --> 00:26:15,800
kernels the majority of the world runs

00:26:13,310 --> 00:26:19,670
kernel.org kernels or community based

00:26:15,800 --> 00:26:21,590
kernels Debian image one plot major

00:26:19,670 --> 00:26:24,650
major cloud provider in the top three

00:26:21,590 --> 00:26:29,120
told me less than ten percent of their

00:26:24,650 --> 00:26:31,820
work load is enterprise kernels over 90%

00:26:29,120 --> 00:26:33,650
is Debian or kernel.org kernels the

00:26:31,820 --> 00:26:36,050
world has changed in the past five years

00:26:33,650 --> 00:26:38,060
companies have not realized this when

00:26:36,050 --> 00:26:39,620
Intel founders was notified this problem

00:26:38,060 --> 00:26:41,270
they started dealing with the company so

00:26:39,620 --> 00:26:42,650
they dealt with Sousa individually they

00:26:41,270 --> 00:26:44,120
that was Red Hat individually they dealt

00:26:42,650 --> 00:26:45,800
with other companies individually and it

00:26:44,120 --> 00:26:47,600
didn't left the different groups work

00:26:45,800 --> 00:26:48,740
together because all the developers of

00:26:47,600 --> 00:26:50,390
those companies are actually part of the

00:26:48,740 --> 00:26:52,550
kernel community and so they work

00:26:50,390 --> 00:26:54,050
together and they and they work together

00:26:52,550 --> 00:26:56,030
they find up a display that for all

00:26:54,050 --> 00:26:58,550
things they solve them together we were

00:26:56,030 --> 00:27:00,460
not allowed to do that for this because

00:26:58,550 --> 00:27:02,870
of that you'll notice the enterprise

00:27:00,460 --> 00:27:03,920
distribution implementation are

00:27:02,870 --> 00:27:06,110
radically different

00:27:03,920 --> 00:27:07,670
Red Hat solution for this is radically

00:27:06,110 --> 00:27:09,230
different from Oracle solution from this

00:27:07,670 --> 00:27:11,540
radically different Canonical's

00:27:09,230 --> 00:27:12,920
radically different from Susan Susan's

00:27:11,540 --> 00:27:15,350
is actually close to the upstream kernel

00:27:12,920 --> 00:27:18,380
again those developers did a good job so

00:27:15,350 --> 00:27:21,290
that was a big big deal that made us

00:27:18,380 --> 00:27:22,660
really mad because the community and the

00:27:21,290 --> 00:27:24,590
kernel out our kernels were vulnerable

00:27:22,660 --> 00:27:26,600
really really late in the game

00:27:24,590 --> 00:27:27,990
the major cloud providers who base their

00:27:26,600 --> 00:27:30,000
systems on the kernel

00:27:27,990 --> 00:27:31,500
kernels were obsessed they were looting

00:27:30,000 --> 00:27:34,080
they were caught flat-footed and they

00:27:31,500 --> 00:27:36,000
were needed to change really fast intel

00:27:34,080 --> 00:27:37,920
realizes this they've worked with us on

00:27:36,000 --> 00:27:39,450
this and for the future ones that are

00:27:37,920 --> 00:27:41,309
coming out they've changed

00:27:39,450 --> 00:27:42,720
they now notify us they're allowing us

00:27:41,309 --> 00:27:45,630
to talk to get each other about this

00:27:42,720 --> 00:27:47,130
it's getting better it's not perfect we

00:27:45,630 --> 00:27:49,380
still have some minor complaints but it

00:27:47,130 --> 00:27:51,510
is getting better they have learned this

00:27:49,380 --> 00:27:53,190
is why you saw a lot of us really really

00:27:51,510 --> 00:27:54,690
grumpy really really upset in the

00:27:53,190 --> 00:27:57,510
beginning because we weren't allowed to

00:27:54,690 --> 00:27:59,070
work on this together so how do you keep

00:27:57,510 --> 00:28:01,679
up to date how do you keep a secure

00:27:59,070 --> 00:28:04,080
system do this take all the releases I

00:28:01,679 --> 00:28:06,330
make take all the security patches all

00:28:04,080 --> 00:28:07,770
the stable updates because and do not

00:28:06,330 --> 00:28:09,690
cherry pick your kernels don't say oh

00:28:07,770 --> 00:28:10,950
look this fix I'll take this fix from

00:28:09,690 --> 00:28:12,990
the stable this week's going to stable

00:28:10,950 --> 00:28:15,600
this friction stable because everybody

00:28:12,990 --> 00:28:17,520
gets it wrong I've audited almost

00:28:15,600 --> 00:28:18,990
everybody's major kernel these days and

00:28:17,520 --> 00:28:21,750
the people they're trying cherry-pick

00:28:18,990 --> 00:28:23,580
fixes myths miss things just take the

00:28:21,750 --> 00:28:24,690
whole thing the community supports the

00:28:23,580 --> 00:28:26,760
whole batch of patches together

00:28:24,690 --> 00:28:29,010
community will not support if you cherry

00:28:26,760 --> 00:28:31,080
pick different pitches pit fixes we know

00:28:29,010 --> 00:28:33,960
this whole thing works together take it

00:28:31,080 --> 00:28:35,850
there's no reason not to using git we

00:28:33,960 --> 00:28:37,950
can merge things easily just take the

00:28:35,850 --> 00:28:39,900
whole thing enable the hardening

00:28:37,950 --> 00:28:42,360
features in your kernel every new kernel

00:28:39,900 --> 00:28:44,490
release as the new security features new

00:28:42,360 --> 00:28:47,300
ways to protect yourself some of these

00:28:44,490 --> 00:28:50,010
spectra issues were not and did not

00:28:47,300 --> 00:28:52,260
affected by these hardening features but

00:28:50,010 --> 00:28:55,020
other security bugs are I've seen loads

00:28:52,260 --> 00:28:58,290
of very very famous brand new phones

00:28:55,020 --> 00:29:01,020
with new nuke versions of kernels not

00:28:58,290 --> 00:29:03,000
enabling seats are different security

00:29:01,020 --> 00:29:05,580
issues that cause no performance issues

00:29:03,000 --> 00:29:07,200
they just and so they're open to a whole

00:29:05,580 --> 00:29:08,610
possible inner abilities and enable

00:29:07,200 --> 00:29:11,610
those options they're there for a reason

00:29:08,610 --> 00:29:13,830
do that keep updating your nature kernel

00:29:11,610 --> 00:29:17,610
version if you can move from a 2.4 4.4

00:29:13,830 --> 00:29:19,950
to 4.6 I'm squared up 14 do it if your

00:29:17,610 --> 00:29:22,290
SOC keeps you in an older kernel version

00:29:19,950 --> 00:29:23,400
work with them and complain but move to

00:29:22,290 --> 00:29:25,679
new york kernel versions because they're

00:29:23,400 --> 00:29:27,330
faster and then we speed up things we

00:29:25,679 --> 00:29:28,860
make things work better we're not doing

00:29:27,330 --> 00:29:31,679
these releases just for the heck of it

00:29:28,860 --> 00:29:32,480
we make things better so use the newer

00:29:31,679 --> 00:29:34,669
kernel

00:29:32,480 --> 00:29:36,169
again Facebook's publicly said Neera

00:29:34,669 --> 00:29:38,150
kernel version no performance loss

00:29:36,169 --> 00:29:40,789
because they went to a newer kernel

00:29:38,150 --> 00:29:42,890
version and update your microcode your

00:29:40,789 --> 00:29:44,840
bias there are being released for a good

00:29:42,890 --> 00:29:45,620
reason they again accustomed a lot of

00:29:44,840 --> 00:29:47,539
money to do this

00:29:45,620 --> 00:29:50,360
take those updates they are fixing

00:29:47,539 --> 00:29:52,130
problems again variant for needs the

00:29:50,360 --> 00:29:53,990
microcode updates you're gonna have to

00:29:52,130 --> 00:29:57,140
update your micro code you're gonna have

00:29:53,990 --> 00:29:59,450
to update your bias do it so I don't

00:29:57,140 --> 00:30:01,159
mean to be all doom and gloom it's

00:29:59,450 --> 00:30:03,289
really easy just keep updating

00:30:01,159 --> 00:30:05,470
everything will be fine thank you very

00:30:03,289 --> 00:30:05,470

YouTube URL: https://www.youtube.com/watch?v=lQZzm9z8g_U


