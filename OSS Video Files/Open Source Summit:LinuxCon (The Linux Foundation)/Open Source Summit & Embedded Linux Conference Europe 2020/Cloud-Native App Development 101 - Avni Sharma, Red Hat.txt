Title: Cloud-Native App Development 101 - Avni Sharma, Red Hat
Publication date: 2020-10-29
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Cloud-Native App Development 101 - Avni Sharma, Red Hat
Captions: 
	00:00:05,279 --> 00:00:10,080
hello everyone

00:00:06,799 --> 00:00:10,400
i hope you all are doing great the topic

00:00:10,080 --> 00:00:13,040
for

00:00:10,400 --> 00:00:15,200
today's session is cloud native app

00:00:13,040 --> 00:00:18,000
development 101

00:00:15,200 --> 00:00:19,039
so this session is going to be uh for a

00:00:18,000 --> 00:00:22,080
beginner's level

00:00:19,039 --> 00:00:23,039
audience and it will just touch upon the

00:00:22,080 --> 00:00:26,000
basics

00:00:23,039 --> 00:00:26,640
on how we can pursue the app development

00:00:26,000 --> 00:00:29,840
journey

00:00:26,640 --> 00:00:30,320
in a cloud-native manner uh before we

00:00:29,840 --> 00:00:32,559
dive

00:00:30,320 --> 00:00:35,200
right into the talk i would like to

00:00:32,559 --> 00:00:37,600
introduce myself to the audience

00:00:35,200 --> 00:00:38,879
uh my name is avni sharma and i'm a

00:00:37,600 --> 00:00:41,360
software engineer at

00:00:38,879 --> 00:00:43,120
red hat i work in the openshift

00:00:41,360 --> 00:00:45,200
developer tools team

00:00:43,120 --> 00:00:47,200
and i'm really passionate about cloud

00:00:45,200 --> 00:00:50,000
native technologies

00:00:47,200 --> 00:00:50,800
uh so my twitter handle is 16 of

00:00:50,000 --> 00:00:53,920
nisharma

00:00:50,800 --> 00:00:57,039
and you all can connect me on twitter

00:00:53,920 --> 00:00:58,800
so let us now see what's the agenda of

00:00:57,039 --> 00:01:02,079
this stock

00:00:58,800 --> 00:01:05,600
we have uh basically four major

00:01:02,079 --> 00:01:08,159
components which would be taken forward

00:01:05,600 --> 00:01:09,520
uh the first one being discussing about

00:01:08,159 --> 00:01:12,240
cloud native

00:01:09,520 --> 00:01:14,000
so yeah since we are taking it from a

00:01:12,240 --> 00:01:16,240
very basic level i would

00:01:14,000 --> 00:01:17,600
first like to demystify what cloud

00:01:16,240 --> 00:01:20,960
native is

00:01:17,600 --> 00:01:22,479
why do we need it uh how to actually

00:01:20,960 --> 00:01:26,400
adopt cloud native

00:01:22,479 --> 00:01:28,799
um paradigm um the second one would be

00:01:26,400 --> 00:01:32,079
focusing on the key concepts

00:01:28,799 --> 00:01:34,479
or the characteristics of being a cloud

00:01:32,079 --> 00:01:37,360
native technology

00:01:34,479 --> 00:01:39,520
and out of those key concepts uh the one

00:01:37,360 --> 00:01:41,920
concept that i would like to stress upon

00:01:39,520 --> 00:01:44,079
and i would like to even demo further

00:01:41,920 --> 00:01:46,560
would be containerization

00:01:44,079 --> 00:01:47,840
so everything around a micro service

00:01:46,560 --> 00:01:50,960
architecture

00:01:47,840 --> 00:01:54,720
and how do we get an app

00:01:50,960 --> 00:01:57,920
in a containerized format and that would

00:01:54,720 --> 00:02:00,240
be demonstrated with the help of a small

00:01:57,920 --> 00:02:00,240
demo

00:02:01,439 --> 00:02:07,040
so as cloud is becoming so pervasive in

00:02:04,880 --> 00:02:08,800
the it feel and there's a lot of digital

00:02:07,040 --> 00:02:12,480
transformation going on

00:02:08,800 --> 00:02:13,200
we have adopted new way of building and

00:02:12,480 --> 00:02:18,720
deploying

00:02:13,200 --> 00:02:18,720
apps and that is typically cloud native

00:02:20,160 --> 00:02:24,879
so what is cloud native elaborating on

00:02:23,280 --> 00:02:28,080
what i just said

00:02:24,879 --> 00:02:29,760
um it is quite apparent that cloud

00:02:28,080 --> 00:02:34,160
native has two distinct

00:02:29,760 --> 00:02:37,680
words one is cloud and one is native

00:02:34,160 --> 00:02:40,560
so when i say cloud it means uh

00:02:37,680 --> 00:02:41,599
apps residing in the cloud instead of

00:02:40,560 --> 00:02:45,440
traditional

00:02:41,599 --> 00:02:47,920
data centers and when i say native

00:02:45,440 --> 00:02:49,120
it means apps designed to run on the

00:02:47,920 --> 00:02:52,239
cloud

00:02:49,120 --> 00:02:55,280
and it is designed in such a way

00:02:52,239 --> 00:02:56,640
that it utilizes the characteristics of

00:02:55,280 --> 00:02:59,840
the cloud that is

00:02:56,640 --> 00:03:01,200
elasticity and distributed system of the

00:02:59,840 --> 00:03:03,599
cloud

00:03:01,200 --> 00:03:05,440
so it's there it exists there but to

00:03:03,599 --> 00:03:07,200
leverage it and to use it to its full

00:03:05,440 --> 00:03:09,519
potential and advantage

00:03:07,200 --> 00:03:10,640
is basically cloud native and it is an

00:03:09,519 --> 00:03:14,000
approach

00:03:10,640 --> 00:03:16,319
to build and run applications

00:03:14,000 --> 00:03:17,680
it is a set of systemized techniques and

00:03:16,319 --> 00:03:20,159
methodologies

00:03:17,680 --> 00:03:20,159
that's it

00:03:20,879 --> 00:03:24,720
so there is a foundation which is known

00:03:23,200 --> 00:03:28,480
as cncf

00:03:24,720 --> 00:03:29,120
and if you go on cncf's github pages you

00:03:28,480 --> 00:03:31,519
will

00:03:29,120 --> 00:03:33,200
find a very crisp definition of cloud

00:03:31,519 --> 00:03:35,920
native which is

00:03:33,200 --> 00:03:37,280
cloud native technologies empower

00:03:35,920 --> 00:03:41,120
organizations

00:03:37,280 --> 00:03:43,760
to build and run scalable applications

00:03:41,120 --> 00:03:45,120
in modern dynamic environments which can

00:03:43,760 --> 00:03:48,159
be public private

00:03:45,120 --> 00:03:51,440
or hybrid clouds

00:03:48,159 --> 00:03:52,319
so whenever you uh listen about cloud

00:03:51,440 --> 00:03:54,239
native

00:03:52,319 --> 00:03:55,360
or you attend conferences about cloud

00:03:54,239 --> 00:03:58,000
native you will

00:03:55,360 --> 00:04:00,400
often hear about cncf so what is

00:03:58,000 --> 00:04:02,400
actually cncf

00:04:00,400 --> 00:04:03,439
stands for cloud native computing

00:04:02,400 --> 00:04:06,080
foundation

00:04:03,439 --> 00:04:09,040
and i also have pasted the link to their

00:04:06,080 --> 00:04:09,040
site over here

00:04:10,480 --> 00:04:15,040
the cncf is part of the non-profit linux

00:04:13,840 --> 00:04:18,400
foundation

00:04:15,040 --> 00:04:19,919
and it seeks to drive adoption of this

00:04:18,400 --> 00:04:22,479
cloud native paradigm

00:04:19,919 --> 00:04:23,840
that we're talking about and how does it

00:04:22,479 --> 00:04:27,360
do that it does that

00:04:23,840 --> 00:04:29,040
by fostering and sustaining an ecosystem

00:04:27,360 --> 00:04:31,520
of open source

00:04:29,040 --> 00:04:32,960
when the neutral projects so you might

00:04:31,520 --> 00:04:35,600
have heard of

00:04:32,960 --> 00:04:37,600
kubernetes and many such projects which

00:04:35,600 --> 00:04:41,040
come under cncf

00:04:37,600 --> 00:04:44,240
so all these projects help us in

00:04:41,040 --> 00:04:46,400
driving our cloud native methodology and

00:04:44,240 --> 00:04:49,680
to adopt cloud native

00:04:46,400 --> 00:04:51,120
in a very easy and friendly manner so i

00:04:49,680 --> 00:04:53,600
encourage you all to

00:04:51,120 --> 00:04:54,800
visit their site and the community is

00:04:53,600 --> 00:04:56,800
really friendly

00:04:54,800 --> 00:05:01,919
and you can also take a look at the

00:04:56,800 --> 00:05:01,919
projects that are housed under cncf

00:05:02,080 --> 00:05:05,600
so yeah this can be pretty overwhelming

00:05:04,240 --> 00:05:08,720
this is a landscape

00:05:05,600 --> 00:05:11,600
of all the projects that come under

00:05:08,720 --> 00:05:12,960
the cncf foundation and you can see

00:05:11,600 --> 00:05:16,160
here's the

00:05:12,960 --> 00:05:16,880
kubernetes you have so many xd called

00:05:16,160 --> 00:05:20,160
dns

00:05:16,880 --> 00:05:22,720
prometheus rook so there are

00:05:20,160 --> 00:05:24,560
many many many projects and as you can

00:05:22,720 --> 00:05:27,120
see the list is endless

00:05:24,560 --> 00:05:28,080
so uh i won't be going through all the

00:05:27,120 --> 00:05:31,759
projects

00:05:28,080 --> 00:05:34,320
i've pasted the link uh below the image

00:05:31,759 --> 00:05:38,960
and i encourage folks to visit the

00:05:34,320 --> 00:05:41,600
landscape page once

00:05:38,960 --> 00:05:42,720
so the uh key concepts that i would like

00:05:41,600 --> 00:05:46,160
to discuss in this

00:05:42,720 --> 00:05:48,479
talk are these four concepts

00:05:46,160 --> 00:05:50,800
i know there can be many concepts and

00:05:48,479 --> 00:05:53,840
the definition for cloud native can be

00:05:50,800 --> 00:05:54,320
as diverse as the community i feel these

00:05:53,840 --> 00:05:56,720
four

00:05:54,320 --> 00:05:58,000
uh really drive the cloud native

00:05:56,720 --> 00:06:00,960
methodology

00:05:58,000 --> 00:06:02,960
and the idea of cloud native so the

00:06:00,960 --> 00:06:06,160
first one is devops

00:06:02,960 --> 00:06:08,479
so devops is basically building testing

00:06:06,160 --> 00:06:09,520
and releasing software rapidly and

00:06:08,479 --> 00:06:12,080
consistently

00:06:09,520 --> 00:06:14,160
so devops is the whole journey of your

00:06:12,080 --> 00:06:17,520
application of your code

00:06:14,160 --> 00:06:20,800
from its development to operations hence

00:06:17,520 --> 00:06:22,479
devops so it's not only about building

00:06:20,800 --> 00:06:24,400
a running code but it's also about

00:06:22,479 --> 00:06:26,720
getting it into production how do you

00:06:24,400 --> 00:06:27,440
get it you test it you release that

00:06:26,720 --> 00:06:30,880
software

00:06:27,440 --> 00:06:34,160
everything comes under devops continuous

00:06:30,880 --> 00:06:37,919
delivery is faster and reliable delivery

00:06:34,160 --> 00:06:40,960
of products then i have

00:06:37,919 --> 00:06:45,039
uh containers which is basically

00:06:40,960 --> 00:06:48,400
isolation of apps and it is packaged app

00:06:45,039 --> 00:06:49,120
uh that means one unit of the container

00:06:48,400 --> 00:06:51,680
can have

00:06:49,120 --> 00:06:53,199
code and the runtime related to that

00:06:51,680 --> 00:06:56,319
code dependencies

00:06:53,199 --> 00:06:58,240
etc and how

00:06:56,319 --> 00:06:59,919
can we achieve a microservice

00:06:58,240 --> 00:07:03,440
architecture is actually

00:06:59,919 --> 00:07:05,919
through containers it's that is how we

00:07:03,440 --> 00:07:06,800
achieve my micro service architecture

00:07:05,919 --> 00:07:09,120
and when we say

00:07:06,800 --> 00:07:10,160
we want a micro service architecture it

00:07:09,120 --> 00:07:16,000
means we want

00:07:10,160 --> 00:07:20,639
loosely coupled apps

00:07:16,000 --> 00:07:23,039
so the benefits of cloud native app uh

00:07:20,639 --> 00:07:26,080
the first one i can tell is that a cloud

00:07:23,039 --> 00:07:27,840
native app is engineered specifically to

00:07:26,080 --> 00:07:28,639
run in the elastic and distributed

00:07:27,840 --> 00:07:30,880
nature

00:07:28,639 --> 00:07:32,000
required by the modern cloud computing

00:07:30,880 --> 00:07:34,160
platforms

00:07:32,000 --> 00:07:38,319
uh that we discussed uh in the

00:07:34,160 --> 00:07:41,280
definition of cloud native as well

00:07:38,319 --> 00:07:42,160
and since these apps are loosely coupled

00:07:41,280 --> 00:07:44,560
in

00:07:42,160 --> 00:07:45,680
the cloud environment so it's really

00:07:44,560 --> 00:07:48,000
easy to manage

00:07:45,680 --> 00:07:48,960
to scale them on demand we can scale

00:07:48,000 --> 00:07:52,400
them up or

00:07:48,960 --> 00:07:55,120
down and thereby we can influence the

00:07:52,400 --> 00:07:57,440
cost performance mix and keep up with

00:07:55,120 --> 00:07:59,919
the changing and growing demands

00:07:57,440 --> 00:08:01,440
so all these are benefits of cloud

00:07:59,919 --> 00:08:03,840
native app

00:08:01,440 --> 00:08:06,319
which wasn't really possible in your

00:08:03,840 --> 00:08:09,520
traditional way of dealing with

00:08:06,319 --> 00:08:09,520
applications on cloud

00:08:10,639 --> 00:08:14,720
so why to adopt cloud native i think i

00:08:12,960 --> 00:08:18,160
have pretty much summarized it

00:08:14,720 --> 00:08:19,759
uh in the previous slides when i said uh

00:08:18,160 --> 00:08:22,800
what is cloud native and what are the

00:08:19,759 --> 00:08:23,599
benefits so it pretty much summarized on

00:08:22,800 --> 00:08:26,400
why do we

00:08:23,599 --> 00:08:27,759
go ahead on adopting this paradigm or

00:08:26,400 --> 00:08:30,879
this approach

00:08:27,759 --> 00:08:33,200
uh but to summarize it ahead in a single

00:08:30,879 --> 00:08:34,080
slide i would like to say that cloud

00:08:33,200 --> 00:08:37,599
native will

00:08:34,080 --> 00:08:38,000
provide with these three as an umbrella

00:08:37,599 --> 00:08:41,120
of

00:08:38,000 --> 00:08:42,719
stuff which is speed agility and

00:08:41,120 --> 00:08:45,200
resilience

00:08:42,719 --> 00:08:46,160
so with speed you know the productivity

00:08:45,200 --> 00:08:49,279
increases

00:08:46,160 --> 00:08:52,320
as operations gets easy we know we can

00:08:49,279 --> 00:08:54,959
adopt agile methods we can have devops

00:08:52,320 --> 00:08:58,160
we can have continuous delivery patterns

00:08:54,959 --> 00:09:00,399
so it will influence the speed uh

00:08:58,160 --> 00:09:01,680
and the productivity will increase and

00:09:00,399 --> 00:09:05,040
operations will get

00:09:01,680 --> 00:09:05,920
easier agility we talked about loosely

00:09:05,040 --> 00:09:09,120
coupled apps

00:09:05,920 --> 00:09:09,600
containers and services which i would be

00:09:09,120 --> 00:09:12,720
telling

00:09:09,600 --> 00:09:15,760
um in more uh detail in

00:09:12,720 --> 00:09:18,399
coming slides but basically

00:09:15,760 --> 00:09:19,839
all these loosely coupled structures or

00:09:18,399 --> 00:09:22,959
loosely coupled apps

00:09:19,839 --> 00:09:24,640
loosely coupled services will provide us

00:09:22,959 --> 00:09:27,680
the flexibility to have

00:09:24,640 --> 00:09:30,959
our portability and as

00:09:27,680 --> 00:09:34,839
i mentioned we can uh scale on demand

00:09:30,959 --> 00:09:37,040
and it will actually help in ease of

00:09:34,839 --> 00:09:39,200
management resilience

00:09:37,040 --> 00:09:40,880
we can recover from failures we can

00:09:39,200 --> 00:09:45,360
minimize downtime

00:09:40,880 --> 00:09:45,360
and build a reliable systems

00:09:46,560 --> 00:09:50,240
so the third point that comes to our

00:09:49,200 --> 00:09:53,360
mind now is

00:09:50,240 --> 00:09:54,880
okay we know what is cloud native uh we

00:09:53,360 --> 00:09:57,600
know why do we need it

00:09:54,880 --> 00:09:58,800
um and hence we know the benefits but

00:09:57,600 --> 00:10:01,920
how do we go about

00:09:58,800 --> 00:10:04,320
adopting cloud native

00:10:01,920 --> 00:10:05,680
because it can be really challenging we

00:10:04,320 --> 00:10:07,760
know the benefits but

00:10:05,680 --> 00:10:09,200
it can be sometimes challenging to think

00:10:07,760 --> 00:10:12,079
about on how to adopt

00:10:09,200 --> 00:10:12,399
cloud native so i would just summarize

00:10:12,079 --> 00:10:16,000
it

00:10:12,399 --> 00:10:17,200
in three broad structures i'm not going

00:10:16,000 --> 00:10:20,320
again in

00:10:17,200 --> 00:10:21,680
my new details but the first two i will

00:10:20,320 --> 00:10:24,000
discuss um

00:10:21,680 --> 00:10:26,160
in the coming slide the first one is

00:10:24,000 --> 00:10:28,560
microservice architecture

00:10:26,160 --> 00:10:29,920
and uh hence we are relying on

00:10:28,560 --> 00:10:33,680
containers

00:10:29,920 --> 00:10:36,720
and we have to adopt agile methods

00:10:33,680 --> 00:10:40,560
agile methods is basically rapid and

00:10:36,720 --> 00:10:42,800
consistent releases of your um

00:10:40,560 --> 00:10:43,680
application the whole application life

00:10:42,800 --> 00:10:46,399
cycle

00:10:43,680 --> 00:10:47,279
and everything needs to be of an agile

00:10:46,399 --> 00:10:49,440
model

00:10:47,279 --> 00:10:51,440
which would be covered by devops and

00:10:49,440 --> 00:10:53,600
continuous delivery parts

00:10:51,440 --> 00:10:54,640
but my focus for this talk would be

00:10:53,600 --> 00:10:57,519
basically

00:10:54,640 --> 00:11:01,440
on building containers and a micro

00:10:57,519 --> 00:11:04,640
service architecture

00:11:01,440 --> 00:11:07,279
so whenever i talk about microservice

00:11:04,640 --> 00:11:08,959
architecture i always compare it with

00:11:07,279 --> 00:11:11,519
the traditional way of

00:11:08,959 --> 00:11:12,839
building and deploying apps which is

00:11:11,519 --> 00:11:15,839
through monolithic

00:11:12,839 --> 00:11:15,839
architecture

00:11:18,160 --> 00:11:22,959
so monolithic versus microservice

00:11:21,200 --> 00:11:25,440
architecture

00:11:22,959 --> 00:11:26,959
so on the left you can see a monolithic

00:11:25,440 --> 00:11:30,399
architecture which

00:11:26,959 --> 00:11:33,600
shows that our app is really

00:11:30,399 --> 00:11:34,800
in just one unit it is so tightly

00:11:33,600 --> 00:11:37,920
coupled

00:11:34,800 --> 00:11:40,399
such that one sector of it fails

00:11:37,920 --> 00:11:42,320
the whole app will collapse and that is

00:11:40,399 --> 00:11:44,160
something we don't want with

00:11:42,320 --> 00:11:46,160
if that happens our day as software

00:11:44,160 --> 00:11:48,560
developers is doomed

00:11:46,160 --> 00:11:50,240
whereas on the microservice architecture

00:11:48,560 --> 00:11:52,959
if you see

00:11:50,240 --> 00:11:54,720
uh everything has been loosely coupled

00:11:52,959 --> 00:11:57,279
it has been disintegrated

00:11:54,720 --> 00:11:58,639
and uh if one thing fails the whole

00:11:57,279 --> 00:12:01,279
system will not collapse

00:11:58,639 --> 00:12:02,000
and we have time to recover and

00:12:01,279 --> 00:12:04,399
similarly

00:12:02,000 --> 00:12:05,519
since it is loosely coupled we can have

00:12:04,399 --> 00:12:08,959
as many

00:12:05,519 --> 00:12:10,000
uh micro services we want uh depending

00:12:08,959 --> 00:12:12,959
upon the load

00:12:10,000 --> 00:12:14,160
and we can also get rid of some so uh on

00:12:12,959 --> 00:12:17,360
scale demand

00:12:14,160 --> 00:12:19,040
uh on demand scaling i'm sorry so

00:12:17,360 --> 00:12:20,800
all these can be taken care of in a

00:12:19,040 --> 00:12:23,920
microservice architecture

00:12:20,800 --> 00:12:25,440
so the loosely coupled um model of this

00:12:23,920 --> 00:12:28,480
architecture is something that

00:12:25,440 --> 00:12:29,600
uh cloud native is uh you know helping

00:12:28,480 --> 00:12:32,079
us to

00:12:29,600 --> 00:12:32,959
take forward and monolithic can be

00:12:32,079 --> 00:12:35,680
really um

00:12:32,959 --> 00:12:36,079
cumbersome there are cases when you want

00:12:35,680 --> 00:12:38,160
to

00:12:36,079 --> 00:12:39,920
use a monolithic architecture but i'm

00:12:38,160 --> 00:12:42,320
sure in production you would

00:12:39,920 --> 00:12:44,399
prefer micro services a monolithic

00:12:42,320 --> 00:12:47,360
architecture you can use for

00:12:44,399 --> 00:12:49,680
uh you know making a poc for your code

00:12:47,360 --> 00:12:50,639
or anything like that but definitely for

00:12:49,680 --> 00:12:53,279
production

00:12:50,639 --> 00:12:56,160
uh service architecture is the future

00:12:53,279 --> 00:12:56,160
and it is happening

00:12:56,240 --> 00:13:01,360
to elaborate in more on micro service

00:12:59,040 --> 00:13:04,000
architecture

00:13:01,360 --> 00:13:04,800
we can see over here for an example use

00:13:04,000 --> 00:13:07,920
case

00:13:04,800 --> 00:13:10,560
we have account service book service

00:13:07,920 --> 00:13:12,079
order service suppose we take order

00:13:10,560 --> 00:13:15,120
service over here

00:13:12,079 --> 00:13:17,360
so this is being used by my uh

00:13:15,120 --> 00:13:19,040
by request coming from my mobile app

00:13:17,360 --> 00:13:22,240
from browser

00:13:19,040 --> 00:13:25,680
so one functionality can be used uh

00:13:22,240 --> 00:13:27,920
with by being called from multiple apis

00:13:25,680 --> 00:13:29,519
and how microservices actually

00:13:27,920 --> 00:13:33,760
communicate with each other

00:13:29,519 --> 00:13:37,279
is like a basic uh rest atm

00:13:33,760 --> 00:13:40,079
and you also see that uh the business

00:13:37,279 --> 00:13:41,600
capabilities has been demarcated and has

00:13:40,079 --> 00:13:43,279
been isolated so

00:13:41,600 --> 00:13:45,279
account service will manage account

00:13:43,279 --> 00:13:46,000
service book service will manage book

00:13:45,279 --> 00:13:49,040
service

00:13:46,000 --> 00:13:51,279
nothing is clogged into one section

00:13:49,040 --> 00:13:52,639
everything every business logic can be

00:13:51,279 --> 00:13:56,320
one micro service

00:13:52,639 --> 00:13:59,120
so that is the flexibility that we want

00:13:56,320 --> 00:14:01,120
and since every business logic is

00:13:59,120 --> 00:14:03,040
independent of itself it's highly

00:14:01,120 --> 00:14:05,839
maintainable and testable

00:14:03,040 --> 00:14:07,519
and you don't need to depend on the

00:14:05,839 --> 00:14:09,600
service

00:14:07,519 --> 00:14:11,519
if you're making an x service you don't

00:14:09,600 --> 00:14:12,320
need to depend on the y service you just

00:14:11,519 --> 00:14:15,199
need to hit

00:14:12,320 --> 00:14:16,560
the api if you want to use the y service

00:14:15,199 --> 00:14:18,560
and that's that

00:14:16,560 --> 00:14:20,399
so this loosely coupled architecture is

00:14:18,560 --> 00:14:22,720
something that

00:14:20,399 --> 00:14:24,800
we want to take forward and understand

00:14:22,720 --> 00:14:28,000
more

00:14:24,800 --> 00:14:29,120
since it is all independent loosely

00:14:28,000 --> 00:14:32,880
coupled we can

00:14:29,120 --> 00:14:35,440
deploy it independently also

00:14:32,880 --> 00:14:36,240
so microservice is an architectural

00:14:35,440 --> 00:14:39,440
style

00:14:36,240 --> 00:14:45,040
to develop an application

00:14:39,440 --> 00:14:48,079
to a suite of small services

00:14:45,040 --> 00:14:50,240
so we can see the adoption timeline how

00:14:48,079 --> 00:14:52,720
it uh you know microservices came into

00:14:50,240 --> 00:14:54,639
picture and how it is being adopted

00:14:52,720 --> 00:14:55,839
so first we had mainframes which was

00:14:54,639 --> 00:14:58,399
centralized

00:14:55,839 --> 00:15:00,560
then we had in 90s we had the client

00:14:58,399 --> 00:15:02,880
server distributed model

00:15:00,560 --> 00:15:03,920
and then we had internet and internet

00:15:02,880 --> 00:15:07,199
really changed

00:15:03,920 --> 00:15:08,399
uh the game of all of this and then we

00:15:07,199 --> 00:15:11,680
had cloud

00:15:08,399 --> 00:15:12,560
and with cloud we have um infrastructure

00:15:11,680 --> 00:15:14,399
as a service

00:15:12,560 --> 00:15:15,600
platform as a service software as a

00:15:14,399 --> 00:15:18,880
service

00:15:15,600 --> 00:15:20,480
and after after we had this we we came

00:15:18,880 --> 00:15:22,880
up with cloud native and

00:15:20,480 --> 00:15:24,720
one of the one of the pillars of that

00:15:22,880 --> 00:15:27,839
would be microservices

00:15:24,720 --> 00:15:30,720
which is granular reusability and we are

00:15:27,839 --> 00:15:30,720
using it still

00:15:31,600 --> 00:15:37,120
so we read about uh microservice

00:15:34,639 --> 00:15:38,160
architecture having loosely coupled uh

00:15:37,120 --> 00:15:42,240
services

00:15:38,160 --> 00:15:45,279
the one app is then bifurcated into

00:15:42,240 --> 00:15:47,759
different services so

00:15:45,279 --> 00:15:48,880
uh containerization is how we can

00:15:47,759 --> 00:15:52,880
achieve that

00:15:48,880 --> 00:15:52,880
um architecture style

00:15:53,600 --> 00:15:59,120
so let us now see uh uh

00:15:57,040 --> 00:16:00,720
example of a virtual machine and

00:15:59,120 --> 00:16:02,800
containers

00:16:00,720 --> 00:16:04,320
so when i say everything can be loosely

00:16:02,800 --> 00:16:07,120
coupled many of you can

00:16:04,320 --> 00:16:08,320
uh come up uh you know with a virtual

00:16:07,120 --> 00:16:11,279
machine as an option

00:16:08,320 --> 00:16:12,079
well uh virtual machine can be really

00:16:11,279 --> 00:16:14,079
heavy

00:16:12,079 --> 00:16:15,279
and over here in this diagram on the

00:16:14,079 --> 00:16:18,560
left you can see

00:16:15,279 --> 00:16:19,199
a typical virtual machine virtualization

00:16:18,560 --> 00:16:22,480
uh

00:16:19,199 --> 00:16:25,920
diagram over here there is a hypervisor

00:16:22,480 --> 00:16:28,720
and on top of it we have three vms and

00:16:25,920 --> 00:16:30,800
so if we want three apps to be running

00:16:28,720 --> 00:16:34,079
we would be having three vms

00:16:30,800 --> 00:16:36,800
and that would be really heavy and

00:16:34,079 --> 00:16:38,160
each vm is having a guest operating

00:16:36,800 --> 00:16:40,160
system as well

00:16:38,160 --> 00:16:41,279
so for one app you're having one guest

00:16:40,160 --> 00:16:44,560
operating system

00:16:41,279 --> 00:16:48,079
out here in virtual machine whereas in

00:16:44,560 --> 00:16:49,680
containers if you see uh we don't have

00:16:48,079 --> 00:16:52,959
the guest os here

00:16:49,680 --> 00:16:55,360
we have the con container engine

00:16:52,959 --> 00:16:56,079
which would be uh you know something

00:16:55,360 --> 00:16:59,920
like docker

00:16:56,079 --> 00:17:04,480
podman or any anything like that but

00:16:59,920 --> 00:17:07,360
uh you don't it's pretty lightweight

00:17:04,480 --> 00:17:09,520
so containers is preferred more and all

00:17:07,360 --> 00:17:10,559
these containers would be on one linux

00:17:09,520 --> 00:17:14,880
kernel

00:17:10,559 --> 00:17:16,839
and so this is a really light weight

00:17:14,880 --> 00:17:18,079
and your containers will have your

00:17:16,839 --> 00:17:20,720
application

00:17:18,079 --> 00:17:23,600
code and related binaries libraries

00:17:20,720 --> 00:17:23,600
dependencies

00:17:25,679 --> 00:17:30,160
so how containers work with virtual

00:17:29,039 --> 00:17:32,880
machines we have

00:17:30,160 --> 00:17:33,919
a whole guest operating system spinning

00:17:32,880 --> 00:17:37,679
up

00:17:33,919 --> 00:17:40,640
but with containers you can

00:17:37,679 --> 00:17:41,840
uh it's preferred to say that containers

00:17:40,640 --> 00:17:45,120
are just linux

00:17:41,840 --> 00:17:45,520
processes so it is just a process and it

00:17:45,120 --> 00:17:48,080
use

00:17:45,520 --> 00:17:49,520
all the linux kernel capabilities like

00:17:48,080 --> 00:17:52,720
name spaces

00:17:49,520 --> 00:17:56,160
um c groups c com tech comp

00:17:52,720 --> 00:17:56,880
and many more so containers are

00:17:56,160 --> 00:18:01,760
basically

00:17:56,880 --> 00:18:04,720
a process

00:18:01,760 --> 00:18:05,440
so let us now look at the steps or which

00:18:04,720 --> 00:18:07,919
will help

00:18:05,440 --> 00:18:08,799
in building our container so the first

00:18:07,919 --> 00:18:11,840
thing is

00:18:08,799 --> 00:18:14,880
a container image so

00:18:11,840 --> 00:18:17,280
a container image is basically an

00:18:14,880 --> 00:18:19,120
immutable file which will consist of all

00:18:17,280 --> 00:18:21,760
the executable code

00:18:19,120 --> 00:18:24,080
and the required runtime environment

00:18:21,760 --> 00:18:26,880
libraries dependencies for that

00:18:24,080 --> 00:18:29,679
application which we need to run so that

00:18:26,880 --> 00:18:32,400
would be in the container image

00:18:29,679 --> 00:18:33,120
and it's an immutable file so you cannot

00:18:32,400 --> 00:18:35,360
change it

00:18:33,120 --> 00:18:36,640
you can make a new container image with

00:18:35,360 --> 00:18:42,320
the new version

00:18:36,640 --> 00:18:44,960
but you cannot change an existing one

00:18:42,320 --> 00:18:46,960
so you can think that image that i

00:18:44,960 --> 00:18:49,360
mentioned in the previous slide

00:18:46,960 --> 00:18:50,160
which we call container image is the

00:18:49,360 --> 00:18:53,679
recipe

00:18:50,160 --> 00:18:53,679
and container is the cake

00:18:54,080 --> 00:18:59,600
container would be the running instance

00:18:56,400 --> 00:18:59,600
of the container image

00:19:01,600 --> 00:19:04,720
and from where can you get a container

00:19:03,919 --> 00:19:07,760
image

00:19:04,720 --> 00:19:09,039
so container image is stored uh in a

00:19:07,760 --> 00:19:11,360
repository

00:19:09,039 --> 00:19:12,160
kind of place which is known as a

00:19:11,360 --> 00:19:15,200
container

00:19:12,160 --> 00:19:19,039
registry so like you store your

00:19:15,200 --> 00:19:21,200
code on github similarly you can store

00:19:19,039 --> 00:19:22,559
and push your container images to a

00:19:21,200 --> 00:19:25,840
container registry

00:19:22,559 --> 00:19:27,679
for example quay docker hub google

00:19:25,840 --> 00:19:29,679
container registry

00:19:27,679 --> 00:19:31,120
and these container registries can be

00:19:29,679 --> 00:19:35,200
public and private

00:19:31,120 --> 00:19:35,200
and wherever you want to configure them

00:19:35,520 --> 00:19:39,760
so now container run times you you want

00:19:38,240 --> 00:19:40,559
to manage the life cycle of your

00:19:39,760 --> 00:19:42,960
container that

00:19:40,559 --> 00:19:44,240
is you want to run a container delete

00:19:42,960 --> 00:19:46,400
the containers

00:19:44,240 --> 00:19:48,799
and build a container or push a

00:19:46,400 --> 00:19:51,200
container to a container registry

00:19:48,799 --> 00:19:52,799
so all these can be handled by your

00:19:51,200 --> 00:19:55,520
container runtimes

00:19:52,799 --> 00:19:56,720
and they will manage your container

00:19:55,520 --> 00:19:58,960
images

00:19:56,720 --> 00:20:01,120
and the examples for container runtimes

00:19:58,960 --> 00:20:04,480
is docker rkt

00:20:01,120 --> 00:20:07,840
pod man container day

00:20:04,480 --> 00:20:07,840
there are many more

00:20:08,880 --> 00:20:12,799
so for my demo i would be using podman

00:20:11,679 --> 00:20:15,760
but you can use

00:20:12,799 --> 00:20:17,520
almost all the commands as is like using

00:20:15,760 --> 00:20:20,559
docker and you can replace

00:20:17,520 --> 00:20:23,760
uh the docker command with one month

00:20:20,559 --> 00:20:25,919
so i have installed podman on my machine

00:20:23,760 --> 00:20:26,799
you all can use docker as well for the

00:20:25,919 --> 00:20:29,280
demo

00:20:26,799 --> 00:20:30,320
uh supportman as i discussed earlier is

00:20:29,280 --> 00:20:33,120
a tool designed

00:20:30,320 --> 00:20:33,520
to make it easier to create deploy and

00:20:33,120 --> 00:20:37,679
run

00:20:33,520 --> 00:20:37,679
your apps or using containers

00:20:38,320 --> 00:20:43,200
so we discussed about a container image

00:20:40,960 --> 00:20:45,360
a container which is a running instance

00:20:43,200 --> 00:20:48,880
of a container image

00:20:45,360 --> 00:20:51,840
but how do we make that image

00:20:48,880 --> 00:20:52,240
so how do we have that immutable file

00:20:51,840 --> 00:20:55,600
which

00:20:52,240 --> 00:20:58,799
will become a running instance of

00:20:55,600 --> 00:21:00,000
a container uh so for that we have

00:20:58,799 --> 00:21:02,400
docker file

00:21:00,000 --> 00:21:03,760
the docker file is basically a bunch of

00:21:02,400 --> 00:21:06,320
commands

00:21:03,760 --> 00:21:06,880
that a user could have called on command

00:21:06,320 --> 00:21:10,400
line

00:21:06,880 --> 00:21:10,400
to assemble an image

00:21:10,559 --> 00:21:15,120
this is a sample docker file and here we

00:21:13,200 --> 00:21:18,400
can see we are taking the

00:21:15,120 --> 00:21:20,559
base from ubuntu and we are copying

00:21:18,400 --> 00:21:22,080
the current directory the contents of

00:21:20,559 --> 00:21:26,480
the current directory

00:21:22,080 --> 00:21:30,000
in the container image in slash app path

00:21:26,480 --> 00:21:34,080
and we are running this make

00:21:30,000 --> 00:21:35,120
and whenever i want my container to run

00:21:34,080 --> 00:21:39,039
i want this

00:21:35,120 --> 00:21:41,520
app.py to run as well

00:21:39,039 --> 00:21:42,640
i would encourage the audience to go

00:21:41,520 --> 00:21:44,880
ahead

00:21:42,640 --> 00:21:46,400
look at a bunch of dockerfiles because i

00:21:44,880 --> 00:21:49,760
know at

00:21:46,400 --> 00:21:50,400
the very beginning it can uh not be

00:21:49,760 --> 00:21:53,600
really

00:21:50,400 --> 00:21:56,799
uh apparent so i would uh

00:21:53,600 --> 00:21:59,520
want people to go and read about

00:21:56,799 --> 00:22:01,120
how to make a docker file and to read

00:21:59,520 --> 00:22:03,200
about containers

00:22:01,120 --> 00:22:06,240
because that is uh really important for

00:22:03,200 --> 00:22:08,880
achieving microservice architecture

00:22:06,240 --> 00:22:09,760
so whatever i discussed in the previous

00:22:08,880 --> 00:22:13,120
slides

00:22:09,760 --> 00:22:14,799
of creating and running or pushing

00:22:13,120 --> 00:22:17,039
container images i would like to

00:22:14,799 --> 00:22:19,679
summarize it in a bunch of steps

00:22:17,039 --> 00:22:21,440
so the first one is to have a docker

00:22:19,679 --> 00:22:23,520
file with you

00:22:21,440 --> 00:22:24,559
so in the docker file you can have your

00:22:23,520 --> 00:22:27,760
commands

00:22:24,559 --> 00:22:29,520
and steps for creating uh your container

00:22:27,760 --> 00:22:31,760
image

00:22:29,520 --> 00:22:34,640
so dockerfile has all the steps now

00:22:31,760 --> 00:22:35,760
container image is the immutable file or

00:22:34,640 --> 00:22:39,600
the recipe

00:22:35,760 --> 00:22:42,720
with which we can make a container

00:22:39,600 --> 00:22:45,200
so now we once we have container

00:22:42,720 --> 00:22:45,840
it's the running instance of the image

00:22:45,200 --> 00:22:48,240
that's that

00:22:45,840 --> 00:22:50,720
our app would be running once we run the

00:22:48,240 --> 00:22:50,720
container

00:22:50,799 --> 00:22:54,720
if you want you can also push your

00:22:53,120 --> 00:22:57,200
container image

00:22:54,720 --> 00:22:57,840
to a container registry so that anybody

00:22:57,200 --> 00:23:01,200
can

00:22:57,840 --> 00:23:04,559
pull your image and use the same recipe

00:23:01,200 --> 00:23:04,559
to run their containers

00:23:06,640 --> 00:23:12,559
so it's demo time and i would be

00:23:10,320 --> 00:23:14,240
referring one of the examples that i

00:23:12,559 --> 00:23:18,720
have pushed

00:23:14,240 --> 00:23:22,320
on github so the audience can go to this

00:23:18,720 --> 00:23:24,720
link and follow the example

00:23:22,320 --> 00:23:24,720
with me

00:23:30,159 --> 00:23:38,320
so this is the demo that i would be

00:23:34,240 --> 00:23:40,799
demoing for today's talk

00:23:38,320 --> 00:23:41,360
over here i have mentioned from where

00:23:40,799 --> 00:23:44,480
you can

00:23:41,360 --> 00:23:45,200
uh install podman and it is a demonless

00:23:44,480 --> 00:23:47,440
container

00:23:45,200 --> 00:23:48,320
engine for developing managing and

00:23:47,440 --> 00:23:52,559
running

00:23:48,320 --> 00:23:54,960
oci containers on a linux system

00:23:52,559 --> 00:23:55,919
let us go ahead and start implementing

00:23:54,960 --> 00:23:58,799
examples

00:23:55,919 --> 00:23:59,760
and just see what a container is how to

00:23:58,799 --> 00:24:04,400
build one

00:23:59,760 --> 00:24:05,120
and how to get one running so i have

00:24:04,400 --> 00:24:08,559
podman

00:24:05,120 --> 00:24:09,919
installed so you can build the container

00:24:08,559 --> 00:24:12,559
image with podman

00:24:09,919 --> 00:24:13,520
with this command and what this command

00:24:12,559 --> 00:24:17,120
does

00:24:13,520 --> 00:24:20,000
is that it will build your

00:24:17,120 --> 00:24:21,919
image from a docker file so let's go

00:24:20,000 --> 00:24:24,480
ahead and see what the docker file

00:24:21,919 --> 00:24:24,480
contains

00:24:25,039 --> 00:24:28,640
so if i haven't mentioned any file name

00:24:27,760 --> 00:24:31,200
and i have just

00:24:28,640 --> 00:24:32,240
mentioned the current directory path it

00:24:31,200 --> 00:24:34,880
means that

00:24:32,240 --> 00:24:37,120
whichever file has the name dockerfile

00:24:34,880 --> 00:24:39,279
it will take that by default

00:24:37,120 --> 00:24:40,880
so you can see i have multiple docker

00:24:39,279 --> 00:24:43,440
files but

00:24:40,880 --> 00:24:44,240
to specify a particular file i will have

00:24:43,440 --> 00:24:47,360
to use

00:24:44,240 --> 00:24:49,360
a f flag but

00:24:47,360 --> 00:24:50,480
currently i'm going by the default

00:24:49,360 --> 00:24:52,400
docker file

00:24:50,480 --> 00:24:56,559
so here you can see that i have taken

00:24:52,400 --> 00:24:58,960
the base os as alpine latest

00:24:56,559 --> 00:25:01,279
and here are multiple configuration

00:24:58,960 --> 00:25:03,600
steps and configuring go

00:25:01,279 --> 00:25:07,520
and i'm including a curl command because

00:25:03,600 --> 00:25:10,320
i would be using it in my container

00:25:07,520 --> 00:25:12,080
here i'm making a directory and i'm

00:25:10,320 --> 00:25:12,720
running basically the commands that

00:25:12,080 --> 00:25:15,440
would have

00:25:12,720 --> 00:25:17,840
that i would have run on my terminal as

00:25:15,440 --> 00:25:20,799
a user

00:25:17,840 --> 00:25:21,440
and i have made a working directory over

00:25:20,799 --> 00:25:24,880
here

00:25:21,440 --> 00:25:28,000
i'm copying the current contents of my

00:25:24,880 --> 00:25:32,960
folder into this path and i will

00:25:28,000 --> 00:25:32,960
go build up the app

00:25:33,279 --> 00:25:36,799
so let me show the app that i'm going to

00:25:35,440 --> 00:25:39,520
build

00:25:36,799 --> 00:25:40,400
in my container this is a very basic go

00:25:39,520 --> 00:25:43,600
app

00:25:40,400 --> 00:25:46,799
and i would be doing a call

00:25:43,600 --> 00:25:48,000
on uh localhost to see whether i get

00:25:46,799 --> 00:25:51,120
hello world

00:25:48,000 --> 00:25:54,080
and this is the path for getting

00:25:51,120 --> 00:25:55,440
kubernetes as the output so this is the

00:25:54,080 --> 00:25:58,720
app that i'm going to build

00:25:55,440 --> 00:26:03,120
in my container and let's go ahead

00:25:58,720 --> 00:26:03,120
and run this command

00:26:07,279 --> 00:26:14,400
let me just name this as

00:26:10,880 --> 00:26:18,799
oss demo

00:26:14,400 --> 00:26:22,000
version one and username also i'm using

00:26:18,799 --> 00:26:24,000
query.io as my container registry

00:26:22,000 --> 00:26:26,559
you all can use any other container

00:26:24,000 --> 00:26:29,440
registry that you will want

00:26:26,559 --> 00:26:29,919
so i'm just writing my uh username over

00:26:29,440 --> 00:26:33,360
here

00:26:29,919 --> 00:26:37,679
which is 16 and i will build my

00:26:33,360 --> 00:26:41,360
um image

00:26:37,679 --> 00:26:43,840
which whose tag so uh hyphen t

00:26:41,360 --> 00:26:46,480
is basically known as the tag so this is

00:26:43,840 --> 00:26:50,240
the tag that my image will get created

00:26:46,480 --> 00:26:52,480
on the 16 oss demo and dot meaning

00:26:50,240 --> 00:26:54,159
take the docker file in from my current

00:26:52,480 --> 00:26:57,760
directory and i'll just

00:26:54,159 --> 00:26:58,240
hit enter so you'll see there are so

00:26:57,760 --> 00:27:01,679
many

00:26:58,240 --> 00:27:04,080
uh steps and for every step

00:27:01,679 --> 00:27:05,120
you will see different hashes so what is

00:27:04,080 --> 00:27:09,039
happening is that

00:27:05,120 --> 00:27:11,760
every line in your docker file

00:27:09,039 --> 00:27:12,640
is being saved as a layer and by every

00:27:11,760 --> 00:27:15,360
layer

00:27:12,640 --> 00:27:17,440
i mean that every layer gets a sha and

00:27:15,360 --> 00:27:19,919
that's basically a tar ball

00:27:17,440 --> 00:27:21,520
so your image is basically a tarball and

00:27:19,919 --> 00:27:24,320
you can literally

00:27:21,520 --> 00:27:25,120
untie it and you can check the contents

00:27:24,320 --> 00:27:28,880
in it

00:27:25,120 --> 00:27:35,840
so containers are processes so

00:27:28,880 --> 00:27:35,840
don't get afraid of them

00:28:02,799 --> 00:28:05,200
so my

00:28:05,919 --> 00:28:10,240
image is being built and it says step 11

00:28:09,120 --> 00:28:13,360
comment

00:28:10,240 --> 00:28:14,320
without io and this is the sha of my

00:28:13,360 --> 00:28:19,840
image

00:28:14,320 --> 00:28:23,200
so let me just check on my images

00:28:19,840 --> 00:28:24,320
oh i should have deleted the previous

00:28:23,200 --> 00:28:27,600
images

00:28:24,320 --> 00:28:28,399
anyway so you see that one image was

00:28:27,600 --> 00:28:33,120
created

00:28:28,399 --> 00:28:35,520
about 16 seconds ago and

00:28:33,120 --> 00:28:37,039
this is the tag that i gave to my image

00:28:35,520 --> 00:28:40,080
and tag is given by

00:28:37,039 --> 00:28:43,279
hyphen t uh flag

00:28:40,080 --> 00:28:44,000
and the image is square i o slash of ni

00:28:43,279 --> 00:28:47,360
16 which

00:28:44,000 --> 00:28:48,559
is my username and demo os is you can

00:28:47,360 --> 00:28:52,399
give any time

00:28:48,559 --> 00:28:52,399
uh this is what i prefer

00:28:53,679 --> 00:28:58,000
so now you see if you are a docker user

00:28:56,399 --> 00:29:01,039
or for those who would be

00:28:58,000 --> 00:29:03,279
using docker it requires sudo but

00:29:01,039 --> 00:29:05,600
here i didn't require it which is pretty

00:29:03,279 --> 00:29:05,600
cool

00:29:10,000 --> 00:29:16,080
so uh now let me just show you all

00:29:13,360 --> 00:29:16,480
the docker file and here you see that

00:29:16,080 --> 00:29:19,520
this

00:29:16,480 --> 00:29:22,240
entry point has been commented and uh

00:29:19,520 --> 00:29:23,840
i haven't given the entry point so now i

00:29:22,240 --> 00:29:27,120
have to manually go

00:29:23,840 --> 00:29:28,480
and i have to run the app from within

00:29:27,120 --> 00:29:31,200
the container

00:29:28,480 --> 00:29:32,799
uh so i should have given the entry

00:29:31,200 --> 00:29:36,640
point but it's okay

00:29:32,799 --> 00:29:41,840
i'll try to run the container now with

00:29:36,640 --> 00:29:41,840
this command

00:29:42,720 --> 00:29:48,799
okay let me just take the image

00:29:46,559 --> 00:29:55,840
i prefer taking the image out but you

00:29:48,799 --> 00:29:55,840
can take the name as well

00:29:57,440 --> 00:30:04,080
so i'm telling to run my container

00:30:01,520 --> 00:30:04,720
because now i have the image so i need

00:30:04,080 --> 00:30:08,000
to

00:30:04,720 --> 00:30:11,200
run my container

00:30:08,000 --> 00:30:14,240
which would be a product of that image

00:30:11,200 --> 00:30:18,240
so run it in an interactive it

00:30:14,240 --> 00:30:22,720
tell and remove it after it has been

00:30:18,240 --> 00:30:25,919
it has run and it is

00:30:22,720 --> 00:30:27,840
so the app is running as as you might

00:30:25,919 --> 00:30:29,760
have seen it's in this path

00:30:27,840 --> 00:30:32,000
and this path has been mentioned in the

00:30:29,760 --> 00:30:35,279
docker file so you can modify

00:30:32,000 --> 00:30:38,720
it as well and all the current

00:30:35,279 --> 00:30:40,159
all the files and everything from the

00:30:38,720 --> 00:30:43,200
current directory has

00:30:40,159 --> 00:30:44,320
been copied in this container so if you

00:30:43,200 --> 00:30:47,919
see

00:30:44,320 --> 00:30:47,919
everything is present over here

00:30:48,000 --> 00:30:51,120
so my container is there and you can

00:30:50,399 --> 00:30:54,000
also see

00:30:51,120 --> 00:30:55,200
that the container is running through

00:30:54,000 --> 00:30:56,880
this command

00:30:55,200 --> 00:30:58,640
and you see that this container is

00:30:56,880 --> 00:31:01,600
running so i

00:30:58,640 --> 00:31:03,200
i basically took the container image

00:31:01,600 --> 00:31:06,480
reference and i ran it

00:31:03,200 --> 00:31:08,320
for a container

00:31:06,480 --> 00:31:10,000
so now let us we have a running

00:31:08,320 --> 00:31:13,519
container we know it's ideal

00:31:10,000 --> 00:31:15,039
let us now ssh into it let us now go

00:31:13,519 --> 00:31:20,559
inside the container

00:31:15,039 --> 00:31:20,559
and run our app

00:31:24,720 --> 00:31:28,399
interactive container

00:31:29,279 --> 00:31:36,159
so here i am and

00:31:32,480 --> 00:31:38,960
i will run my app go run this is

00:31:36,159 --> 00:31:40,159
the go command to run it i had also

00:31:38,960 --> 00:31:42,880
configured the

00:31:40,159 --> 00:31:44,399
gopar the go root in my docker file so

00:31:42,880 --> 00:31:47,039
you can see how to configure

00:31:44,399 --> 00:31:49,440
go from the docker file that i have

00:31:47,039 --> 00:31:51,600
mentioned

00:31:49,440 --> 00:31:51,600
so

00:31:58,559 --> 00:32:03,840
my app is running and now you can

00:32:02,159 --> 00:32:14,799
actually

00:32:03,840 --> 00:32:17,600
call a local host

00:32:14,799 --> 00:32:18,960
and you see over here hello world has

00:32:17,600 --> 00:32:21,519
been prompted

00:32:18,960 --> 00:32:22,320
so my container was running and i tried

00:32:21,519 --> 00:32:25,360
to curl

00:32:22,320 --> 00:32:28,559
which uh and my app

00:32:25,360 --> 00:32:43,840
ran so it is pretty cool so

00:32:28,559 --> 00:32:43,840
let me try another end point

00:32:44,240 --> 00:32:49,360
so ahoy kubernetes okay cool this is

00:32:47,600 --> 00:32:50,720
really awesome that our container is

00:32:49,360 --> 00:32:53,360
running so this is case

00:32:50,720 --> 00:32:54,000
one when i did not mention the entry

00:32:53,360 --> 00:32:56,480
point

00:32:54,000 --> 00:32:59,279
and that is the reason why i had to go

00:32:56,480 --> 00:33:01,840
inside my container and manually

00:32:59,279 --> 00:33:02,960
run the application but if you want that

00:33:01,840 --> 00:33:05,519
the app starts

00:33:02,960 --> 00:33:06,159
running whenever i get my container

00:33:05,519 --> 00:33:08,640
running

00:33:06,159 --> 00:33:11,200
i can mention entry point in my docker

00:33:08,640 --> 00:33:14,320
file and that is what i would be doing

00:33:11,200 --> 00:33:18,240
in my case 2 so over here

00:33:14,320 --> 00:33:22,399
i would be building another image

00:33:18,240 --> 00:33:25,840
which is given over here the command

00:33:22,399 --> 00:33:26,320
and i would be using my custom docker

00:33:25,840 --> 00:33:29,600
file

00:33:26,320 --> 00:33:31,840
x dot expose

00:33:29,600 --> 00:33:32,720
so over here i would be mentioning the

00:33:31,840 --> 00:33:37,120
entry point

00:33:32,720 --> 00:33:40,559
as well as exposing a port number

00:33:37,120 --> 00:33:41,410
to let us just exit

00:33:40,559 --> 00:33:44,559
from here

00:33:41,410 --> 00:33:44,559
[Music]

00:33:46,559 --> 00:33:50,159
exit from my container

00:33:50,840 --> 00:33:53,840
okay

00:33:55,600 --> 00:33:58,399
let me now

00:33:59,279 --> 00:34:02,240
build a

00:34:02,559 --> 00:34:07,840
new container from

00:34:12,159 --> 00:34:21,839
oops sorry

00:34:26,800 --> 00:34:35,839
try it

00:34:37,359 --> 00:34:40,960
so this is my docker file and let me

00:34:40,320 --> 00:34:45,000
just

00:34:40,960 --> 00:34:47,520
go ahead and show you uh the

00:34:45,000 --> 00:34:51,040
dockerfile.expose

00:34:47,520 --> 00:34:53,040
so i'll just come to the exposed uh

00:34:51,040 --> 00:34:54,720
part of the docker file here i have

00:34:53,040 --> 00:34:57,839
mentioned the entry point so

00:34:54,720 --> 00:35:02,320
if you remember i was doing a go run

00:34:57,839 --> 00:35:02,720
first app i can now do it easily let us

00:35:02,320 --> 00:35:05,839
go

00:35:02,720 --> 00:35:05,839
and build it

00:35:11,040 --> 00:35:16,720
so now let's just go and see if my image

00:35:13,440 --> 00:35:20,400
was built

00:35:16,720 --> 00:35:23,359
okay i have it here try it uh

00:35:20,400 --> 00:35:24,480
with v1 version this is the tag this is

00:35:23,359 --> 00:35:26,880
the image id

00:35:24,480 --> 00:35:28,240
and it says it was built seven seconds

00:35:26,880 --> 00:35:31,520
ago

00:35:28,240 --> 00:35:35,359
so let me just have this

00:35:31,520 --> 00:35:35,359
image id over here

00:35:37,200 --> 00:35:45,599
and run podman

00:35:40,320 --> 00:35:45,599
run the container and hyphen p

00:35:48,960 --> 00:35:53,760
80 and image so what is happening over

00:35:51,359 --> 00:35:56,160
here with the command

00:35:53,760 --> 00:35:57,280
so what happens we are we also had the

00:35:56,160 --> 00:36:00,560
xpose

00:35:57,280 --> 00:36:00,880
command in our docker file typically see

00:36:00,560 --> 00:36:03,280
that

00:36:00,880 --> 00:36:04,400
expose will allow communication between

00:36:03,280 --> 00:36:06,720
containers

00:36:04,400 --> 00:36:07,920
and other other containers in the same

00:36:06,720 --> 00:36:10,160
network

00:36:07,920 --> 00:36:12,400
but it will not allow communication of

00:36:10,160 --> 00:36:15,520
containers in one network with uh

00:36:12,400 --> 00:36:18,720
your host machine so what do we do

00:36:15,520 --> 00:36:21,760
in that case so in order to permit

00:36:18,720 --> 00:36:23,760
that uh you need to publish the port

00:36:21,760 --> 00:36:25,760
which is done by hyphen p

00:36:23,760 --> 00:36:28,320
so what we are saying is that the

00:36:25,760 --> 00:36:29,599
container port which is 8080 needs to be

00:36:28,320 --> 00:36:32,800
published to my

00:36:29,599 --> 00:36:33,119
host machine port which is 8081 so it's

00:36:32,800 --> 00:36:35,680
like

00:36:33,119 --> 00:36:41,839
right to left container port to my host

00:36:35,680 --> 00:36:41,839
machine port

00:36:47,599 --> 00:36:54,320
okay so my app

00:36:50,880 --> 00:36:57,920
is running and if you see uh that it got

00:36:54,320 --> 00:37:00,560
created three seconds ago uh so now let

00:36:57,920 --> 00:37:01,119
us just call the command without you

00:37:00,560 --> 00:37:05,200
know

00:37:01,119 --> 00:37:05,200
sshing into the container

00:37:06,839 --> 00:37:12,640
so

00:37:09,440 --> 00:37:16,000
let me just curl into it

00:37:12,640 --> 00:37:18,400
and so yeah

00:37:16,000 --> 00:37:19,599
here you see that hello world was

00:37:18,400 --> 00:37:22,800
printed

00:37:19,599 --> 00:37:25,040
so basically i mentioned the entry point

00:37:22,800 --> 00:37:27,040
i published the port so that from my

00:37:25,040 --> 00:37:31,440
host machine i can access

00:37:27,040 --> 00:37:33,359
uh the apl and now i can see hello world

00:37:31,440 --> 00:37:37,440
so how cool is that

00:37:33,359 --> 00:37:40,880
this is really great

00:37:37,440 --> 00:37:44,480
okay cool so now the next case three

00:37:40,880 --> 00:37:45,760
is using kubernetes so imagine a

00:37:44,480 --> 00:37:48,000
scenario where

00:37:45,760 --> 00:37:49,920
you know you have many containers not

00:37:48,000 --> 00:37:53,119
one you're dealing with

00:37:49,920 --> 00:37:55,119
many containers and

00:37:53,119 --> 00:37:56,720
what would happen if several containers

00:37:55,119 --> 00:38:00,079
start dying

00:37:56,720 --> 00:38:01,680
uh how will you monitor it uh what if

00:38:00,079 --> 00:38:04,800
you need more replicas

00:38:01,680 --> 00:38:06,960
of one uh container and

00:38:04,800 --> 00:38:08,800
who would basically watch the current

00:38:06,960 --> 00:38:11,359
state of the containers

00:38:08,800 --> 00:38:12,560
and get it to the desired state this is

00:38:11,359 --> 00:38:15,119
not something which

00:38:12,560 --> 00:38:17,280
uh you know the podman or docker will

00:38:15,119 --> 00:38:20,320
provide it will provide your

00:38:17,280 --> 00:38:23,680
containers life cycle that is to build

00:38:20,320 --> 00:38:25,839
create run or push a container and

00:38:23,680 --> 00:38:27,040
a bit of network management between

00:38:25,839 --> 00:38:28,960
containers

00:38:27,040 --> 00:38:30,800
in the same network but what would

00:38:28,960 --> 00:38:32,880
happen in a case where

00:38:30,800 --> 00:38:34,640
you need to orchestrate or your

00:38:32,880 --> 00:38:37,440
containers and get

00:38:34,640 --> 00:38:39,440
multiple containers from a current state

00:38:37,440 --> 00:38:42,160
to a desired state

00:38:39,440 --> 00:38:44,000
so to orchestrate them and to bring them

00:38:42,160 --> 00:38:46,240
into harmony

00:38:44,000 --> 00:38:48,800
there are various orchestrators and the

00:38:46,240 --> 00:38:50,880
one which is very famous and uh has

00:38:48,800 --> 00:38:52,800
graduated from cncf

00:38:50,880 --> 00:38:54,079
um and you might have heard of it it's

00:38:52,800 --> 00:38:56,400
kubernetes

00:38:54,079 --> 00:38:58,079
so i haven't prepared a slide on it but

00:38:56,400 --> 00:39:02,079
i thought that i can just

00:38:58,079 --> 00:39:04,320
run through an example and uh due to

00:39:02,079 --> 00:39:05,520
the interest of time i wouldn't be

00:39:04,320 --> 00:39:08,720
explaining

00:39:05,520 --> 00:39:10,800
each uh manifest file or the artifact

00:39:08,720 --> 00:39:12,880
that has been used in kubernetes

00:39:10,800 --> 00:39:14,000
i will just show you how it works in a

00:39:12,880 --> 00:39:16,800
demo and

00:39:14,000 --> 00:39:18,079
i would encourage you all to go ahead

00:39:16,800 --> 00:39:21,680
and

00:39:18,079 --> 00:39:24,079
look this example files

00:39:21,680 --> 00:39:27,440
and go through it and if you have any

00:39:24,079 --> 00:39:30,560
questions you can open up an issue

00:39:27,440 --> 00:39:31,440
so yeah let me just check if my mini

00:39:30,560 --> 00:39:34,560
cube which is

00:39:31,440 --> 00:39:37,040
a single node cluster for kubernetes is

00:39:34,560 --> 00:39:39,200
running or not

00:39:37,040 --> 00:39:40,400
so i already have it running you can do

00:39:39,200 --> 00:39:43,920
a mini cube start

00:39:40,400 --> 00:39:47,280
to get it running so now i will first

00:39:43,920 --> 00:39:50,240
uh create a namespace

00:39:47,280 --> 00:39:51,920
so to create a name namespace we can use

00:39:50,240 --> 00:39:54,480
the kubernetes client which is

00:39:51,920 --> 00:39:57,839
cubecuttle

00:39:54,480 --> 00:40:01,920
and create a namespace

00:39:57,839 --> 00:40:06,319
which you can say always says demo

00:40:01,920 --> 00:40:10,880
so now my namespace has been created

00:40:06,319 --> 00:40:14,160
oh it says demo

00:40:10,880 --> 00:40:14,880
okay so my context uh has been modified

00:40:14,160 --> 00:40:17,680
to

00:40:14,880 --> 00:40:19,280
oss demo so now i am in that namespace

00:40:17,680 --> 00:40:22,640
and i will just

00:40:19,280 --> 00:40:25,839
apply my deployment yaml so

00:40:22,640 --> 00:40:28,960
a deployment yaml will get my um

00:40:25,839 --> 00:40:29,839
pods up and running and the smallest

00:40:28,960 --> 00:40:33,200
unit

00:40:29,839 --> 00:40:35,520
uh would be containers so a pod can have

00:40:33,200 --> 00:40:39,359
many containers but it is advised that

00:40:35,520 --> 00:40:42,480
one pod has only one container

00:40:39,359 --> 00:40:45,839
so now i have my deployments

00:40:42,480 --> 00:40:49,040
running i am using an alias for this big

00:40:45,839 --> 00:40:51,359
command and i have used an alias k

00:40:49,040 --> 00:40:53,359
if you see my demo server is running and

00:40:51,359 --> 00:40:55,440
it has been 18 seconds since it was

00:40:53,359 --> 00:40:58,800
launched

00:40:55,440 --> 00:41:00,400
so let me just show my deployment yaml

00:40:58,800 --> 00:41:04,160
here you can see

00:41:00,400 --> 00:41:07,119
uh that it is using containers

00:41:04,160 --> 00:41:08,960
in the spec and i just showed how to

00:41:07,119 --> 00:41:12,319
build a container

00:41:08,960 --> 00:41:15,040
from a docker file how to build an image

00:41:12,319 --> 00:41:17,119
and how to run a container and you can

00:41:15,040 --> 00:41:19,680
push the same as well

00:41:17,119 --> 00:41:21,440
and there is a command to push your uh

00:41:19,680 --> 00:41:23,760
image

00:41:21,440 --> 00:41:24,800
and once you push it so you can use

00:41:23,760 --> 00:41:28,079
fodman

00:41:24,800 --> 00:41:32,839
push command and your basically

00:41:28,079 --> 00:41:36,240
image name and you can push it to

00:41:32,839 --> 00:41:36,640
uh your registry and you can give the

00:41:36,240 --> 00:41:40,000
red

00:41:36,640 --> 00:41:41,119
the path here that's itself like query

00:41:40,000 --> 00:41:43,839
dot io and

00:41:41,119 --> 00:41:46,160
username and image name so what would

00:41:43,839 --> 00:41:46,960
happen is that it would go and populate

00:41:46,160 --> 00:41:49,760
here

00:41:46,960 --> 00:41:52,480
uh suppose my username was only16 and it

00:41:49,760 --> 00:41:57,359
was query registry to get populated here

00:41:52,480 --> 00:42:00,800
and you can check your images so

00:41:57,359 --> 00:42:03,440
yeah i would just show how to get

00:42:00,800 --> 00:42:05,440
the same example that i was trying on

00:42:03,440 --> 00:42:09,760
containers and how to get it

00:42:05,440 --> 00:42:13,599
on kubernetes so i have my deployment

00:42:09,760 --> 00:42:16,720
now what i will do is i will apply

00:42:13,599 --> 00:42:20,880
a service

00:42:16,720 --> 00:42:25,920
so my service is created which is

00:42:20,880 --> 00:42:30,000
demo server and the node port has been

00:42:25,920 --> 00:42:32,640
exposed so yeah so now i can do the

00:42:30,000 --> 00:42:33,359
same curl command my app is running and

00:42:32,640 --> 00:42:36,160
i have

00:42:33,359 --> 00:42:37,599
uh mentioned it in this image this image

00:42:36,160 --> 00:42:39,839
has been pushed

00:42:37,599 --> 00:42:41,119
and my deployment is basically pulling

00:42:39,839 --> 00:42:44,960
that image from

00:42:41,119 --> 00:42:45,599
a public repository so i can show you

00:42:44,960 --> 00:42:48,640
that this

00:42:45,599 --> 00:42:53,200
is pushed over here as

00:42:48,640 --> 00:42:53,200
demo this is my image demo

00:42:53,599 --> 00:42:59,839
you can see the tag is we once in fact

00:42:56,800 --> 00:42:59,839
given v1

00:43:01,119 --> 00:43:05,359
okay so now i will see my single node

00:43:04,560 --> 00:43:09,200
cluster

00:43:05,359 --> 00:43:09,200
ip which is this

00:43:09,760 --> 00:43:13,440
and then i can curl

00:43:18,720 --> 00:43:23,520
my note port would be this and this is

00:43:21,440 --> 00:43:24,880
not static there are ways to make it

00:43:23,520 --> 00:43:28,160
static

00:43:24,880 --> 00:43:28,880
but currently i am using port of type

00:43:28,160 --> 00:43:31,440
notebook

00:43:28,880 --> 00:43:34,000
for this example i'm not going into the

00:43:31,440 --> 00:43:34,960
depth of explaining the yaml but you all

00:43:34,000 --> 00:43:39,599
can go

00:43:34,960 --> 00:43:42,480
to this github repository and check the

00:43:39,599 --> 00:43:43,359
so you see now it is coming hello world

00:43:42,480 --> 00:43:47,599
so

00:43:43,359 --> 00:43:51,440
um the app is working perfectly fine

00:43:47,599 --> 00:43:54,880
if you want to try another endpoint

00:43:51,440 --> 00:43:55,920
it works as well so yeah that was that

00:43:54,880 --> 00:43:58,960
for the demo

00:43:55,920 --> 00:44:02,000
and thank you all

00:43:58,960 --> 00:44:05,599
for attending

00:44:02,000 --> 00:44:09,040
um the talk and thank you uh

00:44:05,599 --> 00:44:12,000
open source summit for having me here

00:44:09,040 --> 00:44:13,440
i'm open to questions and feedback and

00:44:12,000 --> 00:44:15,760
by the time

00:44:13,440 --> 00:44:16,560
i'm addressing questions i encourage

00:44:15,760 --> 00:44:19,839
folks to

00:44:16,560 --> 00:44:20,480
scan the qr and you can submit your

00:44:19,839 --> 00:44:23,680
questions

00:44:20,480 --> 00:44:26,560
and feedback

00:44:23,680 --> 00:44:27,040
on the link which is there in the queue

00:44:26,560 --> 00:44:30,000
so

00:44:27,040 --> 00:44:32,640
thank you all and have a good have a

00:44:30,000 --> 00:44:32,640
great day

00:44:34,839 --> 00:44:39,839
bye

00:44:37,760 --> 00:44:39,839

YouTube URL: https://www.youtube.com/watch?v=CWTVWP6ivHg


