Title: C++ for Real-Time Safety-Critical Linux Systems - Robin Rowe & Gabrielle Pantera, Venture Hollywood
Publication date: 2020-11-03
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	
Captions: 
	00:00:05,520 --> 00:00:08,240
hello

00:00:06,080 --> 00:00:09,679
and thank you for joining us for c plus

00:00:08,240 --> 00:00:12,320
plus for real time

00:00:09,679 --> 00:00:13,280
and safety critical systems i'm robin

00:00:12,320 --> 00:00:15,759
rowe and this

00:00:13,280 --> 00:00:16,800
is gabrielle pantera and we're going to

00:00:15,759 --> 00:00:20,240
talk to you today

00:00:16,800 --> 00:00:22,800
about how to make c plus code faster and

00:00:20,240 --> 00:00:31,840
more reliable

00:00:22,800 --> 00:00:31,840
let me switch over to my screen here

00:00:42,840 --> 00:00:47,360
um

00:00:44,719 --> 00:00:48,000
so here's a real-time safety critical

00:00:47,360 --> 00:00:51,600
system

00:00:48,000 --> 00:00:52,879
this is a tesla on autopilot so

00:00:51,600 --> 00:00:54,239
this is the kind of thing that we

00:00:52,879 --> 00:00:54,719
usually think of when we're talking

00:00:54,239 --> 00:00:57,920
about

00:00:54,719 --> 00:00:58,399
safety critical real-time systems but

00:00:57,920 --> 00:01:01,280
here's

00:00:58,399 --> 00:01:04,000
a system that is also an autopilot but

00:01:01,280 --> 00:01:07,520
this time we have an autonomous robot

00:01:04,000 --> 00:01:09,040
that is driving a conventional truck so

00:01:07,520 --> 00:01:10,720
we never quite know where software is

00:01:09,040 --> 00:01:13,760
going to end up so it's a good idea

00:01:10,720 --> 00:01:16,720
to use good software design principles

00:01:13,760 --> 00:01:16,720
in whatever we build

00:01:17,520 --> 00:01:21,680
bugs and uptime fewer lines of code

00:01:20,000 --> 00:01:25,040
equal fewer bugs

00:01:21,680 --> 00:01:25,759
bug clusters technical debt timing

00:01:25,040 --> 00:01:27,759
errors

00:01:25,759 --> 00:01:29,439
at google seventy percent of failures

00:01:27,759 --> 00:01:30,320
happen when releasing a new version of

00:01:29,439 --> 00:01:33,520
code

00:01:30,320 --> 00:01:36,079
to reach nine nine no

00:01:33,520 --> 00:01:37,759
to reach nine nines nine nine sorry it's

00:01:36,079 --> 00:01:39,360
confusing to see it written that way

00:01:37,759 --> 00:01:41,600
to reach nine nines you must bank

00:01:39,360 --> 00:01:43,920
reliability nine nines is

00:01:41,600 --> 00:01:44,640
one tenth the time of the blink of an

00:01:43,920 --> 00:01:46,880
eye

00:01:44,640 --> 00:01:47,680
so that's one tenth of a blink of an eye

00:01:46,880 --> 00:01:49,840
in a year

00:01:47,680 --> 00:01:51,360
of downtime so that's pretty much no

00:01:49,840 --> 00:01:54,000
downtime at all

00:01:51,360 --> 00:01:55,360
and you can see this chart on the right

00:01:54,000 --> 00:01:58,960
where we talk about

00:01:55,360 --> 00:02:02,479
the various uh number of nines

00:01:58,960 --> 00:02:02,479
nine nine is a lot

00:02:02,560 --> 00:02:06,880
safety critical standards so uh there's

00:02:05,200 --> 00:02:09,520
iso 9001 which

00:02:06,880 --> 00:02:10,000
many of us are familiar with that is how

00:02:09,520 --> 00:02:12,239
we get

00:02:10,000 --> 00:02:13,440
a repeatable qa process and make sure

00:02:12,239 --> 00:02:16,560
that we actually have

00:02:13,440 --> 00:02:19,920
a quality assurance process uh

00:02:16,560 --> 00:02:24,400
23 360 is the standard for

00:02:19,920 --> 00:02:27,560
linux uh 1345 is medical software

00:02:24,400 --> 00:02:30,560
178 for aviation software

00:02:27,560 --> 00:02:32,959
26262 for automotive software

00:02:30,560 --> 00:02:34,239
its atc for automotive traffic light

00:02:32,959 --> 00:02:34,800
software which i'll talk about some

00:02:34,239 --> 00:02:37,360
later

00:02:34,800 --> 00:02:39,280
and there's also miser c which gives

00:02:37,360 --> 00:02:40,080
some standard best practices for safety

00:02:39,280 --> 00:02:42,640
critical c

00:02:40,080 --> 00:02:43,360
systems but the one that i'm really

00:02:42,640 --> 00:02:47,040
excited about

00:02:43,360 --> 00:02:50,000
is iso 56007

00:02:47,040 --> 00:02:50,400
because i'm actually the chairman for

00:02:50,000 --> 00:02:52,319
that

00:02:50,400 --> 00:02:54,000
that is a future standard in idea

00:02:52,319 --> 00:02:56,560
management that is

00:02:54,000 --> 00:02:59,200
looking to extend 9001 into the

00:02:56,560 --> 00:03:02,000
innovation realm

00:02:59,200 --> 00:03:03,200
process types agile waterfall

00:03:02,000 --> 00:03:06,480
unstructured

00:03:03,200 --> 00:03:06,480
what process do we have

00:03:06,800 --> 00:03:09,840
so unstructured is the no process

00:03:08,879 --> 00:03:12,800
process

00:03:09,840 --> 00:03:14,879
we have no goals top-down directives

00:03:12,800 --> 00:03:17,760
just come out of thin air

00:03:14,879 --> 00:03:19,360
deadlines and milestones make no sense

00:03:17,760 --> 00:03:20,800
we don't learn anything from past

00:03:19,360 --> 00:03:23,360
mistakes

00:03:20,800 --> 00:03:25,519
we try to catch up there's a lot of

00:03:23,360 --> 00:03:28,560
personal baggage and team stress

00:03:25,519 --> 00:03:30,480
and people freaking out there's

00:03:28,560 --> 00:03:32,400
expectations of project failure voiced

00:03:30,480 --> 00:03:33,840
at our meetings the managers are

00:03:32,400 --> 00:03:35,200
consumed

00:03:33,840 --> 00:03:37,040
the team doesn't actually know what the

00:03:35,200 --> 00:03:39,040
managers are doing because they're off

00:03:37,040 --> 00:03:40,959
trying to fix something else and the

00:03:39,040 --> 00:03:41,840
budget is out of control with both binge

00:03:40,959 --> 00:03:45,040
spending

00:03:41,840 --> 00:03:48,239
and your logical cost cutting

00:03:45,040 --> 00:03:51,200
waterfall process indicators top-down

00:03:48,239 --> 00:03:51,920
requirement analysis preliminary design

00:03:51,200 --> 00:03:54,080
review

00:03:51,920 --> 00:03:55,920
lots of reviews lots of reviews yes

00:03:54,080 --> 00:03:58,480
critical design reviews too

00:03:55,920 --> 00:04:00,560
charge numbers which is bug tracking

00:03:58,480 --> 00:04:02,400
microsoft project

00:04:00,560 --> 00:04:03,920
daily team meetings to discuss what

00:04:02,400 --> 00:04:06,080
happened yesterday

00:04:03,920 --> 00:04:07,680
managers spend much of their time absent

00:04:06,080 --> 00:04:09,599
for planning meetings

00:04:07,680 --> 00:04:11,040
rigid plans that demand sticking to the

00:04:09,599 --> 00:04:13,120
plan no matter what

00:04:11,040 --> 00:04:15,040
and big bang finish deliverable

00:04:13,120 --> 00:04:16,639
deadlines tend to slip

00:04:15,040 --> 00:04:18,320
yeah and so charge numbers aren't

00:04:16,639 --> 00:04:21,280
exactly bug tracking it's

00:04:18,320 --> 00:04:24,240
more a matter of that you get charged uh

00:04:21,280 --> 00:04:24,240
for fixing bugs

00:04:24,880 --> 00:04:30,080
so here is robert overcracker he had a

00:04:28,080 --> 00:04:31,759
great waterfall plan he's literally

00:04:30,080 --> 00:04:35,040
jumping over the waterfall

00:04:31,759 --> 00:04:37,120
at niagara falls great plan except

00:04:35,040 --> 00:04:38,400
his parachute wasn't tested to operate

00:04:37,120 --> 00:04:41,280
when wet

00:04:38,400 --> 00:04:43,360
so this turned out very tragically

00:04:41,280 --> 00:04:45,120
because he didn't have a complete

00:04:43,360 --> 00:04:46,400
waterfall plan and this is why people

00:04:45,120 --> 00:04:49,759
like agile

00:04:46,400 --> 00:04:49,759
that plans can change

00:04:50,560 --> 00:04:54,000
agile manifesto for agile software

00:04:53,120 --> 00:04:56,000
development

00:04:54,000 --> 00:04:57,600
as you can see on the right there's all

00:04:56,000 --> 00:05:00,160
sorts of stuff going on

00:04:57,600 --> 00:05:02,800
um a lot of interaction working software

00:05:00,160 --> 00:05:05,759
over comprehensive documents

00:05:02,800 --> 00:05:07,120
um customer collaboration instead of

00:05:05,759 --> 00:05:09,360
just what's in the contract

00:05:07,120 --> 00:05:10,400
and responding to change over uh over

00:05:09,360 --> 00:05:14,320
following a plan

00:05:10,400 --> 00:05:14,320
so that means you're able to move and go

00:05:14,560 --> 00:05:20,560
agile process indicators user stories

00:05:17,680 --> 00:05:21,360
sprints and retrospectives release early

00:05:20,560 --> 00:05:24,400
and often

00:05:21,360 --> 00:05:26,320
that's key yep pair programming

00:05:24,400 --> 00:05:28,720
kanban boards meetings are

00:05:26,320 --> 00:05:31,120
forward-looking or retrospectives

00:05:28,720 --> 00:05:31,840
cloud-based project management jira and

00:05:31,120 --> 00:05:33,759
get

00:05:31,840 --> 00:05:34,960
using that and many other tools as well

00:05:33,759 --> 00:05:38,800
but those are the two that are

00:05:34,960 --> 00:05:40,320
most popular right why do we like c

00:05:38,800 --> 00:05:41,919
plus well i like it because i've taught

00:05:40,320 --> 00:05:43,360
it at two universities and used it for

00:05:41,919 --> 00:05:45,199
20 years but that's not

00:05:43,360 --> 00:05:47,520
the reason everyone else likes it the

00:05:45,199 --> 00:05:49,440
the reason that most people like it

00:05:47,520 --> 00:05:50,880
is that typically it's going to be 10

00:05:49,440 --> 00:05:53,520
times faster than

00:05:50,880 --> 00:05:55,039
other tools also there are 20 million c

00:05:53,520 --> 00:05:56,880
plus plus programmers out there so it's

00:05:55,039 --> 00:05:59,199
possible to staff a team

00:05:56,880 --> 00:06:00,479
and we really like that subject-oriented

00:05:59,199 --> 00:06:02,639
has constructors destructors

00:06:00,479 --> 00:06:05,039
encapsulation all that good stuff

00:06:02,639 --> 00:06:06,000
then uh for reliability it also has an

00:06:05,039 --> 00:06:08,240
extensive

00:06:06,000 --> 00:06:09,680
set of tools which is very important in

00:06:08,240 --> 00:06:11,360
doing safety critical and real-time

00:06:09,680 --> 00:06:15,199
systems

00:06:11,360 --> 00:06:16,800
and also c plus plus is the software if

00:06:15,199 --> 00:06:17,600
you're in motion picture visual effects

00:06:16,800 --> 00:06:20,880
as i am

00:06:17,600 --> 00:06:25,360
vr as i am or autonomous vehicles c

00:06:20,880 --> 00:06:30,160
plus is everywhere it's in everything

00:06:25,360 --> 00:06:33,199
oh windows windows mac os linux ios

00:06:30,160 --> 00:06:35,680
android embedded systems uh iot

00:06:33,199 --> 00:06:36,479
cloud aerospace ai and of course in

00:06:35,680 --> 00:06:37,940
databases

00:06:36,479 --> 00:06:39,680
smooth tasks gabriel

00:06:37,940 --> 00:06:41,600
[Laughter]

00:06:39,680 --> 00:06:42,800
sorry i wasn't paying attention i was

00:06:41,600 --> 00:06:44,800
off in the la la land

00:06:42,800 --> 00:06:46,639
object-oriented design the most

00:06:44,800 --> 00:06:48,319
important single aspect of software

00:06:46,639 --> 00:06:50,080
development is to be clear about what

00:06:48,319 --> 00:06:52,000
you're trying to build from bjornis

00:06:50,080 --> 00:06:54,400
truestrip

00:06:52,000 --> 00:06:55,840
software that snaps together like legos

00:06:54,400 --> 00:06:58,400
nouns are classes

00:06:55,840 --> 00:07:00,639
verbs are functions encapsulation hides

00:06:58,400 --> 00:07:03,919
data from code that shouldn't change

00:07:00,639 --> 00:07:04,400
c plus plus it as pardon me is as easy

00:07:03,919 --> 00:07:07,440
as

00:07:04,400 --> 00:07:08,479
pi polymorphism inheritance

00:07:07,440 --> 00:07:10,960
encapsulation

00:07:08,479 --> 00:07:12,560
elegant design simplicity is what's left

00:07:10,960 --> 00:07:14,720
after removing complexity

00:07:12,560 --> 00:07:16,000
yes and the reason the c plus is so

00:07:14,720 --> 00:07:18,960
complex is to remove

00:07:16,000 --> 00:07:21,120
complexity not to add it which some

00:07:18,960 --> 00:07:23,599
people do

00:07:21,120 --> 00:07:25,360
so embedded system design we want to

00:07:23,599 --> 00:07:27,120
think small and fast we do we don't have

00:07:25,360 --> 00:07:29,360
a lot of hardware here

00:07:27,120 --> 00:07:30,400
we want to avoid the heat because we may

00:07:29,360 --> 00:07:32,240
not have much heat

00:07:30,400 --> 00:07:33,440
and we don't know how long the heap will

00:07:32,240 --> 00:07:35,199
take because

00:07:33,440 --> 00:07:37,120
any time that we go out for memory on

00:07:35,199 --> 00:07:38,400
the heap we're doing a global lock

00:07:37,120 --> 00:07:39,680
we're pretty much stopping the world

00:07:38,400 --> 00:07:41,120
while we wait for that memory to be

00:07:39,680 --> 00:07:43,280
allocated

00:07:41,120 --> 00:07:44,879
we want to avoid termination because

00:07:43,280 --> 00:07:45,280
there may be no place to terminate to

00:07:44,879 --> 00:07:47,599
there's

00:07:45,280 --> 00:07:49,759
maybe no operating system and so

00:07:47,599 --> 00:07:51,759
therefore we don't like exceptions

00:07:49,759 --> 00:07:53,440
if rebooting is feasible we'll use a

00:07:51,759 --> 00:07:56,840
highlander that is

00:07:53,440 --> 00:07:58,560
an automatic restart to reload our

00:07:56,840 --> 00:08:01,360
program

00:07:58,560 --> 00:08:02,639
we want to avoid implicit initialization

00:08:01,360 --> 00:08:04,639
of static objects before

00:08:02,639 --> 00:08:06,160
main the reason for that being that we

00:08:04,639 --> 00:08:08,240
don't know in which order they will

00:08:06,160 --> 00:08:10,240
initialize because that's undefined

00:08:08,240 --> 00:08:11,520
by the programming language so we want

00:08:10,240 --> 00:08:14,319
to do our bring up

00:08:11,520 --> 00:08:14,639
explicitly in main where we initialize

00:08:14,319 --> 00:08:17,280
all

00:08:14,639 --> 00:08:19,039
of our uh objects that we're going to

00:08:17,280 --> 00:08:20,800
have in memory

00:08:19,039 --> 00:08:22,160
and i'll bring all of our files online

00:08:20,800 --> 00:08:24,240
bring our devices up

00:08:22,160 --> 00:08:26,240
all the stuff that we need to bring up

00:08:24,240 --> 00:08:27,759
uh we want to avoid success optimization

00:08:26,240 --> 00:08:29,360
so we're going to profile and test not

00:08:27,759 --> 00:08:30,000
just assume we know where the code is

00:08:29,360 --> 00:08:31,440
slow

00:08:30,000 --> 00:08:33,839
and we're going to avoid risky coding

00:08:31,440 --> 00:08:35,919
practices like using a lot of casts and

00:08:33,839 --> 00:08:37,120
other things like that and we're going

00:08:35,919 --> 00:08:39,599
to use c

00:08:37,120 --> 00:08:40,159
plus type safety and encapsulation and

00:08:39,599 --> 00:08:43,440
be

00:08:40,159 --> 00:08:45,839
const correct that is use make mark

00:08:43,440 --> 00:08:47,600
memory as being read only wherever we

00:08:45,839 --> 00:08:50,560
can

00:08:47,600 --> 00:08:51,680
safety critical c plus concepts

00:08:50,560 --> 00:08:54,320
encapsulation

00:08:51,680 --> 00:08:55,680
memory management thread management hard

00:08:54,320 --> 00:08:58,880
and soft real time

00:08:55,680 --> 00:09:00,640
static analysis single code base on

00:08:58,880 --> 00:09:04,000
linux windows mac

00:09:00,640 --> 00:09:07,360
embedded embedded pardon me embedded

00:09:04,000 --> 00:09:10,640
audit simulation playback

00:09:07,360 --> 00:09:13,200
sqa unit and regression yeah so that's

00:09:10,640 --> 00:09:15,360
uh software quality assurance and you

00:09:13,200 --> 00:09:16,320
know audit simulation playback sqa unit

00:09:15,360 --> 00:09:18,000
regression

00:09:16,320 --> 00:09:20,000
we're just doing everything we possibly

00:09:18,000 --> 00:09:22,160
can to test the software

00:09:20,000 --> 00:09:23,519
we're not assuming because it ran once

00:09:22,160 --> 00:09:25,920
that we're done

00:09:23,519 --> 00:09:27,760
and in in safety critical systems we may

00:09:25,920 --> 00:09:31,600
actually spend more time in tests

00:09:27,760 --> 00:09:31,600
than we did in the software development

00:09:32,480 --> 00:09:36,320
c plus plus type safety locks out

00:09:35,040 --> 00:09:38,320
incompatible code

00:09:36,320 --> 00:09:40,320
typical type errors will be found and

00:09:38,320 --> 00:09:42,320
compa at compile time

00:09:40,320 --> 00:09:44,560
a major way of static checking we can

00:09:42,320 --> 00:09:47,839
still cast when we must

00:09:44,560 --> 00:09:50,240
size a pointer unknowable

00:09:47,839 --> 00:09:51,600
you get the last one that's used in

00:09:50,240 --> 00:09:54,640
pointer type

00:09:51,600 --> 00:09:57,040
uh don't cast to

00:09:54,640 --> 00:09:58,000
an integer assuming that an integer and

00:09:57,040 --> 00:10:00,720
a pointer

00:09:58,000 --> 00:10:02,240
uh have the same size the reason that

00:10:00,720 --> 00:10:03,200
our that our size of pointer is

00:10:02,240 --> 00:10:05,040
unknowable

00:10:03,200 --> 00:10:07,120
is because of platform differences we

00:10:05,040 --> 00:10:09,040
may know what the size of a pointer is

00:10:07,120 --> 00:10:10,320
on our development system but it might

00:10:09,040 --> 00:10:12,800
be a different size

00:10:10,320 --> 00:10:13,680
on our actual target cross-compiled

00:10:12,800 --> 00:10:15,760
system

00:10:13,680 --> 00:10:16,880
so we just assume that we don't know the

00:10:15,760 --> 00:10:20,560
size of pointer

00:10:16,880 --> 00:10:23,120
and make sure that we use types that are

00:10:20,560 --> 00:10:23,120
compatible

00:10:24,000 --> 00:10:27,600
c plus plus encapsulation watertight

00:10:26,720 --> 00:10:29,920
compartments

00:10:27,600 --> 00:10:31,200
classes and objects private protected

00:10:29,920 --> 00:10:33,440
and public

00:10:31,200 --> 00:10:35,440
encapsulation is a form of data hiding

00:10:33,440 --> 00:10:36,320
encapsulation can ensure consistency of

00:10:35,440 --> 00:10:38,000
state

00:10:36,320 --> 00:10:39,360
don't use inheritance where you mean

00:10:38,000 --> 00:10:42,800
encapsulation

00:10:39,360 --> 00:10:45,120
const is also a form of encapsulation

00:10:42,800 --> 00:10:46,480
yeah so we've got a picture of the

00:10:45,120 --> 00:10:49,519
titanic here

00:10:46,480 --> 00:10:51,760
and this is an example of where

00:10:49,519 --> 00:10:53,120
compartments certainly help but they're

00:10:51,760 --> 00:10:55,120
not foolproof

00:10:53,120 --> 00:10:56,560
so yeah there's a lot of things that we

00:10:55,120 --> 00:10:58,240
can do but compartments

00:10:56,560 --> 00:11:01,839
uh will keep you afloat a lot longer

00:10:58,240 --> 00:11:01,839
than not having compartments

00:11:02,640 --> 00:11:06,160
c plus plus memory management so that

00:11:05,040 --> 00:11:08,560
can be the

00:11:06,160 --> 00:11:09,600
stack it can be static or the heap the

00:11:08,560 --> 00:11:11,920
stack memory

00:11:09,600 --> 00:11:13,519
is is automatic that's what just appears

00:11:11,920 --> 00:11:15,519
magically when you create a variable

00:11:13,519 --> 00:11:18,640
inside a function

00:11:15,519 --> 00:11:20,480
static memory is allocated

00:11:18,640 --> 00:11:22,079
when the program loads and exists

00:11:20,480 --> 00:11:22,800
throughout the time that the program is

00:11:22,079 --> 00:11:24,880
there

00:11:22,800 --> 00:11:27,680
and the heap is variable size memory

00:11:24,880 --> 00:11:31,440
that can vary in time and space

00:11:27,680 --> 00:11:34,240
but the heap is prone to problems

00:11:31,440 --> 00:11:35,920
including that we don't know how long

00:11:34,240 --> 00:11:36,640
allocating a piece of memory on the heat

00:11:35,920 --> 00:11:38,240
may take

00:11:36,640 --> 00:11:39,760
and that can be a real problem in a real

00:11:38,240 --> 00:11:41,920
time system

00:11:39,760 --> 00:11:42,800
so if we are using the heat we don't

00:11:41,920 --> 00:11:46,160
want to call

00:11:42,800 --> 00:11:48,640
a naked new call we want to use

00:11:46,160 --> 00:11:50,639
unique pointer from c plus plus from

00:11:48,640 --> 00:11:52,800
more recent c plus plus

00:11:50,639 --> 00:11:54,800
because it leaves no garbage to collect

00:11:52,800 --> 00:11:56,000
that pointer is encapsulating news so

00:11:54,800 --> 00:11:58,720
that when the unique pointer goes

00:11:56,000 --> 00:12:00,079
away it automatically self-destructs and

00:11:58,720 --> 00:12:02,399
then there's shared pointer this is

00:12:00,079 --> 00:12:05,360
really more for legacy code

00:12:02,399 --> 00:12:06,399
this is a usage account pointer so that

00:12:05,360 --> 00:12:09,040
you can go back

00:12:06,399 --> 00:12:10,240
and have a pointer destroy itself at the

00:12:09,040 --> 00:12:12,160
appropriate time

00:12:10,240 --> 00:12:14,079
magically but it's not as efficient as

00:12:12,160 --> 00:12:16,560
unique pointers so we use unique pointer

00:12:14,079 --> 00:12:19,519
in new code

00:12:16,560 --> 00:12:20,639
c plus plus concurrence pardon me c plus

00:12:19,519 --> 00:12:22,720
plus concurrency

00:12:20,639 --> 00:12:24,000
currency and currency we're lucky at the

00:12:22,720 --> 00:12:26,639
same time this is concurrency

00:12:24,000 --> 00:12:27,360
right here yes i know message queuing

00:12:26,639 --> 00:12:30,959
threads

00:12:27,360 --> 00:12:33,519
joiner detached mutex blocks

00:12:30,959 --> 00:12:34,639
condition variables lock free double

00:12:33,519 --> 00:12:38,639
buffering

00:12:34,639 --> 00:12:41,600
and volatile so

00:12:38,639 --> 00:12:42,880
in c code we would use volatile to use

00:12:41,600 --> 00:12:46,240
some sort of integer

00:12:42,880 --> 00:12:48,720
that uh works across different

00:12:46,240 --> 00:12:49,680
uh threads but in c plus plus we have

00:12:48,720 --> 00:12:53,120
atomic

00:12:49,680 --> 00:12:55,040
and the reason for this is that with

00:12:53,120 --> 00:12:57,040
multiple cores and that sort of thing we

00:12:55,040 --> 00:12:58,240
can't be quite sure that volatile does

00:12:57,040 --> 00:13:00,160
what we think it does

00:12:58,240 --> 00:13:02,480
across all those cores and that we're

00:13:00,160 --> 00:13:05,360
really getting the one and only volatile

00:13:02,480 --> 00:13:06,240
whereas atomic will make sure that that

00:13:05,360 --> 00:13:08,160
variable

00:13:06,240 --> 00:13:10,000
is actually synced across all the cores

00:13:08,160 --> 00:13:12,800
without locking it

00:13:10,000 --> 00:13:14,399
so with threads trying to detach with

00:13:12,800 --> 00:13:16,240
join that means we're going to wait

00:13:14,399 --> 00:13:17,680
until the thread finishes before we do

00:13:16,240 --> 00:13:18,880
something in general that's what we

00:13:17,680 --> 00:13:21,120
don't want

00:13:18,880 --> 00:13:22,959
because that's not concurrent so we're

00:13:21,120 --> 00:13:24,079
going to launch a thread and detach it

00:13:22,959 --> 00:13:25,839
and keep going

00:13:24,079 --> 00:13:28,000
and that's when things get complicated

00:13:25,839 --> 00:13:30,399
and we need all these fancy block

00:13:28,000 --> 00:13:31,600
systems now it is possible in many

00:13:30,399 --> 00:13:33,360
circumstances

00:13:31,600 --> 00:13:34,639
well maybe not many in a few

00:13:33,360 --> 00:13:37,519
circumstances

00:13:34,639 --> 00:13:39,199
uh to have lack free code where uh it

00:13:37,519 --> 00:13:40,880
has no locks at all but just by the

00:13:39,199 --> 00:13:44,240
cleverness of how we've coded it

00:13:40,880 --> 00:13:45,760
it can't collide that's not very common

00:13:44,240 --> 00:13:46,720
that people do that but it's lovely if

00:13:45,760 --> 00:13:48,639
we can so

00:13:46,720 --> 00:13:50,160
be on the lookout for that and then

00:13:48,639 --> 00:13:53,279
there's double buffering

00:13:50,160 --> 00:13:55,839
uh with this system uh we might have

00:13:53,279 --> 00:13:57,519
an odds an off-screen buffer that we

00:13:55,839 --> 00:13:59,440
paint all of our screen changes to

00:13:57,519 --> 00:14:00,720
so that we don't see the screen update

00:13:59,440 --> 00:14:02,959
we just flip the

00:14:00,720 --> 00:14:04,480
the buffers so that a fully painted

00:14:02,959 --> 00:14:06,240
screen appears that we don't see

00:14:04,480 --> 00:14:08,320
components on the screen being drawn

00:14:06,240 --> 00:14:10,800
one by one which would be visually

00:14:08,320 --> 00:14:10,800
annoying

00:14:11,120 --> 00:14:16,160
pointers okay avoid garbage by using

00:14:14,560 --> 00:14:18,639
unique pointers yeah we mentioned that

00:14:16,160 --> 00:14:20,800
keep going avoid wild pointers

00:14:18,639 --> 00:14:21,920
yeah so so point to no point here in the

00:14:20,800 --> 00:14:25,040
constructor

00:14:21,920 --> 00:14:25,920
um zero is still a valid thing to point

00:14:25,040 --> 00:14:28,079
to but

00:14:25,920 --> 00:14:28,959
we have no pointer now which is really

00:14:28,079 --> 00:14:30,399
just zero

00:14:28,959 --> 00:14:32,399
but it's a little clearer what the code

00:14:30,399 --> 00:14:34,160
is doing that we mean for this to be a

00:14:32,399 --> 00:14:36,079
pointer that we never call

00:14:34,160 --> 00:14:38,560
or that we'll at least check that it's

00:14:36,079 --> 00:14:40,720
not zero before we call it

00:14:38,560 --> 00:14:42,079
avoid dangling pointers yeah so we're

00:14:40,720 --> 00:14:43,120
going to point back to null pointer

00:14:42,079 --> 00:14:45,440
after we

00:14:43,120 --> 00:14:46,320
release the thing we only need to do

00:14:45,440 --> 00:14:48,320
this if

00:14:46,320 --> 00:14:49,440
if we're literally calling delete which

00:14:48,320 --> 00:14:51,279
we've already decided we're not going to

00:14:49,440 --> 00:14:53,120
do because we're calling unique pointer

00:14:51,279 --> 00:14:54,720
so this should not be necessary but

00:14:53,120 --> 00:14:55,279
sometimes it is because we've got legacy

00:14:54,720 --> 00:14:57,199
code

00:14:55,279 --> 00:14:58,639
so delete those dangling pointers

00:14:57,199 --> 00:15:01,120
because uh

00:14:58,639 --> 00:15:02,880
in many cases that will be where you

00:15:01,120 --> 00:15:05,279
discover memory errors

00:15:02,880 --> 00:15:06,160
hide pointers yes by making them private

00:15:05,279 --> 00:15:07,920
make them private

00:15:06,160 --> 00:15:09,920
so don't show your produce to everybody

00:15:07,920 --> 00:15:11,920
just only your closest friends

00:15:09,920 --> 00:15:14,160
where a pointer could never be null use

00:15:11,920 --> 00:15:16,079
references instead

00:15:14,160 --> 00:15:18,959
and then we want to avoid unintended

00:15:16,079 --> 00:15:21,199
unintended modifications by using const

00:15:18,959 --> 00:15:22,320
uh that's the same as as read-only for

00:15:21,199 --> 00:15:23,680
people that prefer english

00:15:22,320 --> 00:15:26,000
but it's not called that it's called

00:15:23,680 --> 00:15:28,639
const tracing a debugger all

00:15:26,000 --> 00:15:30,160
code you write that does pointer math

00:15:28,639 --> 00:15:30,880
yeah because every time i do pointer

00:15:30,160 --> 00:15:32,880
math

00:15:30,880 --> 00:15:34,000
i find some corner case or something

00:15:32,880 --> 00:15:35,360
that i screwed up

00:15:34,000 --> 00:15:37,120
and so i'm really glad that i've traced

00:15:35,360 --> 00:15:38,560
it through the debugger and said oh yeah

00:15:37,120 --> 00:15:41,279
what about that

00:15:38,560 --> 00:15:42,480
so trace all that uh pointer math and

00:15:41,279 --> 00:15:44,160
the debugger

00:15:42,480 --> 00:15:45,519
and any other code that we're highly

00:15:44,160 --> 00:15:47,199
suspicious of

00:15:45,519 --> 00:15:49,199
you know in theory we have unit tests

00:15:47,199 --> 00:15:51,839
and we'll also catch this stuff

00:15:49,199 --> 00:15:53,360
but that's not the same as a human as a

00:15:51,839 --> 00:15:55,279
human brain just looking at the thing

00:15:53,360 --> 00:15:57,920
and saying does this really do what i

00:15:55,279 --> 00:15:57,920
intended

00:15:58,480 --> 00:16:05,440
c plus casting we don't want any

00:16:01,680 --> 00:16:07,519
but sometimes so this is really more of

00:16:05,440 --> 00:16:11,519
a thing for legacy code

00:16:07,519 --> 00:16:11,519
we try not to cast a new code

00:16:11,759 --> 00:16:17,279
here's a c style cast it's just you know

00:16:14,480 --> 00:16:19,839
int in parentheses

00:16:17,279 --> 00:16:20,320
but constructor style casts are also

00:16:19,839 --> 00:16:23,120
legal

00:16:20,320 --> 00:16:23,440
and sometimes easier to write where you

00:16:23,120 --> 00:16:27,279
put

00:16:23,440 --> 00:16:29,040
the type on the outside then

00:16:27,279 --> 00:16:30,959
there's a const cast a static cast

00:16:29,040 --> 00:16:31,839
reinterpret cast so the one here that's

00:16:30,959 --> 00:16:35,199
really interesting

00:16:31,839 --> 00:16:36,399
is dynamic cast because where we need to

00:16:35,199 --> 00:16:37,759
do upcast

00:16:36,399 --> 00:16:40,079
which we really shouldn't do but

00:16:37,759 --> 00:16:41,759
sometimes we've got to uh this will tell

00:16:40,079 --> 00:16:42,160
us if we're upcasting to something that

00:16:41,759 --> 00:16:44,399
actually

00:16:42,160 --> 00:16:45,199
exists or we're out of our minds and

00:16:44,399 --> 00:16:47,199
casting off

00:16:45,199 --> 00:16:48,639
into memory that doesn't actually go

00:16:47,199 --> 00:16:51,680
where we think it belongs

00:16:48,639 --> 00:16:54,320
so if we've got a base class and we need

00:16:51,680 --> 00:16:56,480
to upcast it to the derived class

00:16:54,320 --> 00:16:57,680
and we're not sure that that pointer is

00:16:56,480 --> 00:17:01,279
actually the derived class

00:16:57,680 --> 00:17:03,680
this will keep us from catastrophe

00:17:01,279 --> 00:17:04,559
and then when it comes to doing integer

00:17:03,680 --> 00:17:07,280
casts

00:17:04,559 --> 00:17:08,880
uh we may want to declare but not define

00:17:07,280 --> 00:17:10,640
some function templates

00:17:08,880 --> 00:17:11,919
because that will make the compiler

00:17:10,640 --> 00:17:13,600
complain that it's not going to

00:17:11,919 --> 00:17:16,000
automatically implicitly

00:17:13,600 --> 00:17:16,720
not that we want that do those casts for

00:17:16,000 --> 00:17:19,360
us when

00:17:16,720 --> 00:17:19,360
we really shouldn't

00:17:19,919 --> 00:17:26,799
c plus exceptions don't

00:17:23,679 --> 00:17:28,160
signal in a t in a type safe way return

00:17:26,799 --> 00:17:30,160
false

00:17:28,160 --> 00:17:31,600
used to add simplistic error handling to

00:17:30,160 --> 00:17:33,600
legacy code

00:17:31,600 --> 00:17:35,679
c plus plus exceptions are termination

00:17:33,600 --> 00:17:37,200
based

00:17:35,679 --> 00:17:40,080
if the second throw happens before the

00:17:37,200 --> 00:17:40,080
first three is caught

00:17:40,400 --> 00:17:44,640
not good if we don't like newt because

00:17:43,039 --> 00:17:46,559
it can be slow and terminate

00:17:44,640 --> 00:17:49,200
terminate unexpectedly we don't like

00:17:46,559 --> 00:17:52,799
throw for the same reason

00:17:49,200 --> 00:17:54,799
yeah so in real time and safety critical

00:17:52,799 --> 00:17:55,280
embedded systems we we just stay away

00:17:54,799 --> 00:17:57,919
from

00:17:55,280 --> 00:17:59,520
exceptions exceptions are much better

00:17:57,919 --> 00:18:02,640
for for batch process

00:17:59,520 --> 00:18:04,799
types of things where if things go bad

00:18:02,640 --> 00:18:07,679
we want to terminate the program

00:18:04,799 --> 00:18:09,520
but in in this realm we pretty much

00:18:07,679 --> 00:18:11,520
never want to terminate a server

00:18:09,520 --> 00:18:12,559
or an embedded system so we don't want

00:18:11,520 --> 00:18:14,960
to take the chance

00:18:12,559 --> 00:18:16,000
that we do a throw somewhere and before

00:18:14,960 --> 00:18:17,919
we can catch it

00:18:16,000 --> 00:18:20,320
something else goes wrong and froze

00:18:17,919 --> 00:18:23,280
again and terminates our program

00:18:20,320 --> 00:18:23,280
to nowhere

00:18:23,360 --> 00:18:30,000
testing methods tracing unit stress

00:18:26,960 --> 00:18:32,640
regression monkey

00:18:30,000 --> 00:18:35,039
screen scraping keyboard mouse macros

00:18:32,640 --> 00:18:36,960
and catch library

00:18:35,039 --> 00:18:39,440
yeah and i should also mention c test

00:18:36,960 --> 00:18:40,559
here which comes with cmake is is also

00:18:39,440 --> 00:18:43,840
very nice for doing

00:18:40,559 --> 00:18:43,840
uh unit tests

00:18:44,080 --> 00:18:52,080
so c plus plus traps infinite loop

00:18:47,919 --> 00:18:57,840
recursion casts wild pointers

00:18:52,080 --> 00:18:57,840
seg fault division by zero

00:19:02,400 --> 00:19:06,120
yeah we already said don't do that right

00:19:04,160 --> 00:19:09,280
complexity and ops

00:19:06,120 --> 00:19:10,000
obfuscation obfuscation this is also a

00:19:09,280 --> 00:19:12,559
speech

00:19:10,000 --> 00:19:14,240
thing to learn new words uh cohesi

00:19:12,559 --> 00:19:16,720
cohesion

00:19:14,240 --> 00:19:17,500
spaghetti there's not a time limit here

00:19:16,720 --> 00:19:19,840
we're okay

00:19:17,500 --> 00:19:24,000
[Laughter]

00:19:19,840 --> 00:19:24,960
say it three times fast no okay so i

00:19:24,000 --> 00:19:26,960
want to do this one

00:19:24,960 --> 00:19:28,320
she wants to do this agile safety

00:19:26,960 --> 00:19:30,320
critical mindset

00:19:28,320 --> 00:19:32,480
how could you not select a guy who wears

00:19:30,320 --> 00:19:35,120
a women's hairband for sunglasses

00:19:32,480 --> 00:19:37,679
but seriously jody saves the enterprise

00:19:35,120 --> 00:19:40,320
from certain doom and countless episodes

00:19:37,679 --> 00:19:42,160
cheryl so did scotty but jordy did not

00:19:40,320 --> 00:19:44,559
whine about it like scotty

00:19:42,160 --> 00:19:46,240
captain i'm giving her all she's got she

00:19:44,559 --> 00:19:49,440
can't take much more

00:19:46,240 --> 00:19:52,160
now jody's got her all done

00:19:49,440 --> 00:19:54,240
whoop stuff johnny's got her as

00:19:52,160 --> 00:19:56,160
ridiculous as that visor journey sport

00:19:54,240 --> 00:19:57,360
had looked it enabled him to see things

00:19:56,160 --> 00:20:00,400
that other crew members

00:19:57,360 --> 00:20:02,320
couldn't the barber yeah so

00:20:00,400 --> 00:20:04,640
you know if you if you come from a realm

00:20:02,320 --> 00:20:06,080
of termination is okay

00:20:04,640 --> 00:20:08,080
and some of these other things we talked

00:20:06,080 --> 00:20:11,200
about you're gonna have to put on your

00:20:08,080 --> 00:20:13,120
levar burton visor uh from here on out

00:20:11,200 --> 00:20:14,880
so that you can see things in a new way

00:20:13,120 --> 00:20:16,720
and actually if you do watch it if you

00:20:14,880 --> 00:20:18,720
notice in our photo they did have a lot

00:20:16,720 --> 00:20:21,520
of scrum sessions

00:20:18,720 --> 00:20:23,440
yeah they're scrubbing here in the 23rd

00:20:21,520 --> 00:20:24,159
century they're they're charmingly retro

00:20:23,440 --> 00:20:27,200
they're still

00:20:24,159 --> 00:20:27,200
they're still doing a scrum

00:20:28,799 --> 00:20:31,919
okay so here are some real life c plus

00:20:30,720 --> 00:20:35,200
plus examples

00:20:31,919 --> 00:20:37,760
uh literally everything depends on c

00:20:35,200 --> 00:20:39,200
plus uh real-time systems safety

00:20:37,760 --> 00:20:40,880
critical systems embedded systems

00:20:39,200 --> 00:20:43,919
financial systems

00:20:40,880 --> 00:20:45,200
uh national critical infrastructure all

00:20:43,919 --> 00:20:48,559
of that stuff

00:20:45,200 --> 00:20:51,760
here's some systems he's touched

00:20:48,559 --> 00:20:54,559
so at gopro i worked on uh

00:20:51,760 --> 00:20:56,000
defining their iot api so that we could

00:20:54,559 --> 00:20:58,320
connect all the cameras in the world

00:20:56,000 --> 00:21:01,600
together

00:20:58,320 --> 00:21:04,720
barbie v logger this is a mattel

00:21:01,600 --> 00:21:06,000
animation series that i worked on the oh

00:21:04,720 --> 00:21:08,559
i designed the

00:21:06,000 --> 00:21:10,480
uh animation motion capture software

00:21:08,559 --> 00:21:12,640
that animates this in real time

00:21:10,480 --> 00:21:13,600
so this is done with actors on a sound

00:21:12,640 --> 00:21:15,919
stage

00:21:13,600 --> 00:21:16,799
and comes out as a cartoon on the

00:21:15,919 --> 00:21:18,720
monitors

00:21:16,799 --> 00:21:20,159
right they're in the suit and they can

00:21:18,720 --> 00:21:20,480
see it right there with them as they

00:21:20,159 --> 00:21:22,480
call

00:21:20,480 --> 00:21:24,240
the camera so wearing the white dot suit

00:21:22,480 --> 00:21:28,159
uh which is so flattering

00:21:24,240 --> 00:21:30,320
and uh it comes out as a cartoon

00:21:28,159 --> 00:21:31,200
what whoops i think i went past one

00:21:30,320 --> 00:21:33,760
there

00:21:31,200 --> 00:21:34,720
so here you can see some some dudes in

00:21:33,760 --> 00:21:38,080
the suit

00:21:34,720 --> 00:21:40,720
uh they're in this uh fake jeep in the

00:21:38,080 --> 00:21:41,360
in the studio and this is being used uh

00:21:40,720 --> 00:21:44,400
to do

00:21:41,360 --> 00:21:46,400
a a game trailer so the these actors are

00:21:44,400 --> 00:21:48,000
actually inserted physically

00:21:46,400 --> 00:21:50,000
into the game they're actually playing

00:21:48,000 --> 00:21:54,159
call of duty uh

00:21:50,000 --> 00:21:54,159
in the in in the physical world here

00:21:54,480 --> 00:21:59,679
then here's the genie set top box i got

00:21:56,799 --> 00:22:03,039
to work on the security and satellite

00:21:59,679 --> 00:22:04,720
channel expansion for that uh here's a

00:22:03,039 --> 00:22:06,960
casino gaming system

00:22:04,720 --> 00:22:08,480
this is a very high speed real-time

00:22:06,960 --> 00:22:11,280
server

00:22:08,480 --> 00:22:13,120
with with online gaming everything is

00:22:11,280 --> 00:22:14,159
about how many simultaneous players you

00:22:13,120 --> 00:22:18,640
can support

00:22:14,159 --> 00:22:18,640
so server efficiency is very important

00:22:18,960 --> 00:22:22,000
and then this is national critical

00:22:20,400 --> 00:22:26,880
instrument infrastructure

00:22:22,000 --> 00:22:29,120
and a real-time system this is the

00:22:26,880 --> 00:22:32,159
traffic control system for the country

00:22:29,120 --> 00:22:34,159
so that uh when you cross the street uh

00:22:32,159 --> 00:22:35,760
the light going the other way is not

00:22:34,159 --> 00:22:39,200
running and you get run over

00:22:35,760 --> 00:22:40,799
so uh the way that this system functions

00:22:39,200 --> 00:22:42,559
this is a linux system if you've seen

00:22:40,799 --> 00:22:44,159
those silver boxes

00:22:42,559 --> 00:22:45,679
next to the traffic light that's where

00:22:44,159 --> 00:22:48,880
this system lives

00:22:45,679 --> 00:22:50,159
and uh there's a single board linux

00:22:48,880 --> 00:22:51,440
computer in there that is running the

00:22:50,159 --> 00:22:53,280
traffic light

00:22:51,440 --> 00:22:55,919
and there's a second processor in there

00:22:53,280 --> 00:22:59,200
that's independent of that

00:22:55,919 --> 00:23:00,640
that is pinging that computer every one

00:22:59,200 --> 00:23:02,799
tenth of a second

00:23:00,640 --> 00:23:03,919
and if the computer if the linux

00:23:02,799 --> 00:23:07,360
computer responds

00:23:03,919 --> 00:23:09,280
saying that i haven't processed all the

00:23:07,360 --> 00:23:12,640
commands on my command stack

00:23:09,280 --> 00:23:14,799
in this time slice then the uh

00:23:12,640 --> 00:23:16,320
the traffic light will go into flash and

00:23:14,799 --> 00:23:17,919
it requires a trek roll that is it

00:23:16,320 --> 00:23:19,600
requires technicians to get into a

00:23:17,919 --> 00:23:20,640
vehicle and drive out to the light and

00:23:19,600 --> 00:23:22,559
reset it

00:23:20,640 --> 00:23:24,480
because we don't want that light to

00:23:22,559 --> 00:23:25,520
reset automatically if there's something

00:23:24,480 --> 00:23:28,640
wrong with it

00:23:25,520 --> 00:23:31,039
so every time of a second it's asking

00:23:28,640 --> 00:23:32,000
the the linux process is everything okay

00:23:31,039 --> 00:23:34,240
with you

00:23:32,000 --> 00:23:36,080
and if it says no or if it doesn't

00:23:34,240 --> 00:23:38,640
respond at all

00:23:36,080 --> 00:23:39,840
that other processor the watchdog timer

00:23:38,640 --> 00:23:41,840
will take over

00:23:39,840 --> 00:23:44,320
and and turn the light to be red in all

00:23:41,840 --> 00:23:44,320
directions

00:23:47,120 --> 00:23:52,320
this is uh the uss lincoln i got to uh

00:23:51,200 --> 00:23:53,760
to sail on this for

00:23:52,320 --> 00:23:56,400
a system that i built for national

00:23:53,760 --> 00:23:56,400
security

00:23:56,640 --> 00:24:00,080
and that's it i'm robin rowe and i'm

00:23:58,640 --> 00:24:03,200
gabrielle pantero

00:24:00,080 --> 00:24:15,760
and we are ready to take your amazing

00:24:03,200 --> 00:24:15,760

YouTube URL: https://www.youtube.com/watch?v=NptszbJ2GLI


