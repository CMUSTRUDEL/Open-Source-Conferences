Title: Accelerating Network Device Automation Using a Model-Driven SDK - Santiago Alvarez, Cisco
Publication date: 2020-11-17
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Accelerating Network Device Automation Using a Model-Driven SDK - Santiago Alvarez, Cisco
Captions: 
	00:00:06,640 --> 00:00:12,480
software automation is transforming

00:00:08,960 --> 00:00:15,839
numerous industries and in particular

00:00:12,480 --> 00:00:17,039
in networking we're seeing more and more

00:00:15,839 --> 00:00:20,880
adoption

00:00:17,039 --> 00:00:23,279
in the recent years what is driving

00:00:20,880 --> 00:00:25,039
this interest in programmability and

00:00:23,279 --> 00:00:28,080
network automation in general

00:00:25,039 --> 00:00:31,599
it has to do with the fact of

00:00:28,080 --> 00:00:34,800
growing demand from the network

00:00:31,599 --> 00:00:38,000
the more higher requirements in terms of

00:00:34,800 --> 00:00:38,000
speed and scale

00:00:38,239 --> 00:00:41,600
prices and a growing number of

00:00:40,000 --> 00:00:44,399
individuals trying to connect to the

00:00:41,600 --> 00:00:46,000
network and expectations of faster

00:00:44,399 --> 00:00:46,719
services for instance deployed in the

00:00:46,000 --> 00:00:49,120
network

00:00:46,719 --> 00:00:50,559
have led to a growing interest in

00:00:49,120 --> 00:00:52,800
software automation

00:00:50,559 --> 00:00:54,559
it's just not feasible to manage

00:00:52,800 --> 00:00:56,160
networks how they were managed in the

00:00:54,559 --> 00:00:59,280
past

00:00:56,160 --> 00:01:03,039
quite a fair amount of intervention by

00:00:59,280 --> 00:01:06,320
uh humans and software automation

00:01:03,039 --> 00:01:07,920
has become critical not just to keep up

00:01:06,320 --> 00:01:09,680
with speed and scale

00:01:07,920 --> 00:01:11,920
but also has become a tool for

00:01:09,680 --> 00:01:14,640
innovation quite a few uh

00:01:11,920 --> 00:01:16,400
operators see software automation as a

00:01:14,640 --> 00:01:19,680
way to differentiate their

00:01:16,400 --> 00:01:22,560
uh self services from those uh

00:01:19,680 --> 00:01:23,840
offered by the competition for instance

00:01:22,560 --> 00:01:26,400
ultimately

00:01:23,840 --> 00:01:28,159
the goal is to have a network operator

00:01:26,400 --> 00:01:31,759
that manages not just

00:01:28,159 --> 00:01:32,880
tens of devices but an individual that

00:01:31,759 --> 00:01:34,960
can manage

00:01:32,880 --> 00:01:37,119
thousands and tens of thousands of

00:01:34,960 --> 00:01:40,560
complex networking devices

00:01:37,119 --> 00:01:45,200
through the heavy use of

00:01:40,560 --> 00:01:49,759
network automation through software

00:01:45,200 --> 00:01:51,360
all right so how how was this automation

00:01:49,759 --> 00:01:53,439
done in the past or what kind of

00:01:51,360 --> 00:01:55,600
mechanisms were available in the past

00:01:53,439 --> 00:01:56,799
and this is kind of a view of what was

00:01:55,600 --> 00:01:58,960
common and popular

00:01:56,799 --> 00:02:00,880
let's say five years ago i would say

00:01:58,960 --> 00:02:02,240
less and less used these days but

00:02:00,880 --> 00:02:03,680
there's still a fair amount of networks

00:02:02,240 --> 00:02:06,320
that are using this uh

00:02:03,680 --> 00:02:08,560
this legacy manageability uh framework

00:02:06,320 --> 00:02:10,800
and in the past networking devices were

00:02:08,560 --> 00:02:13,280
managed through a combination of the

00:02:10,800 --> 00:02:16,959
command line interface

00:02:13,280 --> 00:02:17,680
syslog and snmp and this framework had

00:02:16,959 --> 00:02:20,959
multiple

00:02:17,680 --> 00:02:23,200
limitations um in general all these

00:02:20,959 --> 00:02:26,319
three components were completely siloed

00:02:23,200 --> 00:02:29,360
they shared little if anything at

00:02:26,319 --> 00:02:30,239
all in common uh there was very limited

00:02:29,360 --> 00:02:32,800
availability of

00:02:30,239 --> 00:02:34,480
structured data in particular cli and

00:02:32,800 --> 00:02:36,480
syslog did not use

00:02:34,480 --> 00:02:38,080
structured data the lack of structured

00:02:36,480 --> 00:02:41,280
data make data

00:02:38,080 --> 00:02:44,000
difficult to parse um error prone

00:02:41,280 --> 00:02:45,680
and very brittle any change that

00:02:44,000 --> 00:02:48,319
happened on the router it was very

00:02:45,680 --> 00:02:49,360
likely to also break the implementation

00:02:48,319 --> 00:02:52,400
of the automation

00:02:49,360 --> 00:02:56,000
uh software there was an overall

00:02:52,400 --> 00:02:58,720
lack of the use of uh schemas

00:02:56,000 --> 00:02:59,440
uh to define the data so it wasn't not

00:02:58,720 --> 00:03:01,760
always

00:02:59,440 --> 00:03:04,319
clear the what was the formal definition

00:03:01,760 --> 00:03:05,120
of the data what kind of types what was

00:03:04,319 --> 00:03:07,599
considered

00:03:05,120 --> 00:03:08,959
valid versus invalid data and that's

00:03:07,599 --> 00:03:11,680
that's where schemas

00:03:08,959 --> 00:03:12,000
become critical there was also limited

00:03:11,680 --> 00:03:14,720
uh

00:03:12,000 --> 00:03:16,239
standardization snmp had some cap

00:03:14,720 --> 00:03:19,280
basically was a standard

00:03:16,239 --> 00:03:22,959
base and mips were standards

00:03:19,280 --> 00:03:24,879
but when we looked at cli and syslog

00:03:22,959 --> 00:03:26,319
there was not a clear standardization of

00:03:24,879 --> 00:03:29,599
those interfaces and

00:03:26,319 --> 00:03:33,040
in overall there was limited uh tooling

00:03:29,599 --> 00:03:37,760
snmp even though

00:03:33,040 --> 00:03:37,760
he had standards and structure data

00:03:38,319 --> 00:03:42,799
didn't offer the capabilities to

00:03:40,640 --> 00:03:44,560
manipulate configuration the network

00:03:42,799 --> 00:03:46,560
i'm sorry the industry never adopted

00:03:44,560 --> 00:03:50,159
snmp as a protocol

00:03:46,560 --> 00:03:52,560
to manipulate or to manage configuration

00:03:50,159 --> 00:03:53,920
and even though it was heavily used for

00:03:52,560 --> 00:03:56,560
operational data

00:03:53,920 --> 00:03:58,319
its use quite often rely on polling

00:03:56,560 --> 00:03:59,599
which was a very inefficient way to

00:03:58,319 --> 00:04:02,720
retrieve data

00:03:59,599 --> 00:04:04,560
from the from the routers so

00:04:02,720 --> 00:04:06,400
the industry of it all is making an

00:04:04,560 --> 00:04:09,040
effort to move away from this

00:04:06,400 --> 00:04:11,280
legacy manageability framework and move

00:04:09,040 --> 00:04:12,000
to a model driven manageability

00:04:11,280 --> 00:04:14,799
framework

00:04:12,000 --> 00:04:15,920
in this framework all that can be

00:04:14,799 --> 00:04:18,959
configured

00:04:15,920 --> 00:04:22,079
and monitored on the device is defined

00:04:18,959 --> 00:04:22,560
using a data model these data models are

00:04:22,079 --> 00:04:25,120
going to be

00:04:22,560 --> 00:04:27,360
common regardless of the interface the

00:04:25,120 --> 00:04:30,400
programmatic interface that is used

00:04:27,360 --> 00:04:31,440
to interact uh with the device the data

00:04:30,400 --> 00:04:33,199
models are defined

00:04:31,440 --> 00:04:35,120
in the yan modeling language and i'm

00:04:33,199 --> 00:04:37,199
going to give some of the specifics for

00:04:35,120 --> 00:04:39,440
on on that language for those who are

00:04:37,199 --> 00:04:42,080
not familiar with it

00:04:39,440 --> 00:04:42,560
and you would interact programmatically

00:04:42,080 --> 00:04:44,880
using

00:04:42,560 --> 00:04:46,080
different interfaces the most uh common

00:04:44,880 --> 00:04:50,880
ones are netcomp

00:04:46,080 --> 00:04:54,479
and grpc all data now gets exchanged in

00:04:50,880 --> 00:04:57,120
uh structure format so it's machine

00:04:54,479 --> 00:04:58,639
readable whether it's xml json or google

00:04:57,120 --> 00:05:00,479
protocol buffers

00:04:58,639 --> 00:05:01,840
and what we want to focus on this

00:05:00,479 --> 00:05:05,199
presentation is how

00:05:01,840 --> 00:05:08,320
we can simplify the

00:05:05,199 --> 00:05:08,639
use of this new framework and what is

00:05:08,320 --> 00:05:11,440
the

00:05:08,639 --> 00:05:13,039
an sdk that can facilitate the use of

00:05:11,440 --> 00:05:15,840
these data models

00:05:13,039 --> 00:05:17,520
the use of net conf and grpc and be able

00:05:15,840 --> 00:05:20,320
to use multiple encodings

00:05:17,520 --> 00:05:21,600
um in in a simple fashion okay this

00:05:20,320 --> 00:05:24,400
framework is very rich

00:05:21,600 --> 00:05:26,080
it's flexible it's loosely coupled but

00:05:24,400 --> 00:05:27,919
there are a lot of moving pieces

00:05:26,080 --> 00:05:30,320
and it would be good to have a library

00:05:27,919 --> 00:05:31,680
or an sdk that make it as easy as

00:05:30,320 --> 00:05:35,600
possible we're going to see

00:05:31,680 --> 00:05:38,000
um what kind of sdk can be used

00:05:35,600 --> 00:05:39,759
but before we look at the details of the

00:05:38,000 --> 00:05:42,080
sdk

00:05:39,759 --> 00:05:43,520
let's take a quick look at yang as a

00:05:42,080 --> 00:05:46,080
modern language because

00:05:43,520 --> 00:05:46,639
again the entire new manageability

00:05:46,080 --> 00:05:48,720
framework

00:05:46,639 --> 00:05:50,720
is based on data models and yang is the

00:05:48,720 --> 00:05:52,080
language that is used to define these

00:05:50,720 --> 00:05:56,160
data models

00:05:52,080 --> 00:05:58,880
the data models are three structures

00:05:56,160 --> 00:05:59,280
three data three structures that define

00:05:58,880 --> 00:06:00,639
again

00:05:59,280 --> 00:06:02,639
everything that can be configured in the

00:06:00,639 --> 00:06:06,319
box everything that can be monitored

00:06:02,639 --> 00:06:09,919
these trees are built up based out of

00:06:06,319 --> 00:06:13,199
four basic components there are leaf

00:06:09,919 --> 00:06:15,680
nodes lift list containers and lists

00:06:13,199 --> 00:06:17,120
leaves is basically a terminated node on

00:06:15,680 --> 00:06:19,440
the tree that has

00:06:17,120 --> 00:06:21,360
some kind of type and value associated

00:06:19,440 --> 00:06:23,919
with it okay and also has a name

00:06:21,360 --> 00:06:24,800
associated with it the lift list

00:06:23,919 --> 00:06:28,400
represents

00:06:24,800 --> 00:06:30,400
uh data of the same type um that is

00:06:28,400 --> 00:06:31,600
uh multiple instances of data of the

00:06:30,400 --> 00:06:35,120
same type

00:06:31,600 --> 00:06:37,280
uh and um the

00:06:35,120 --> 00:06:38,720
the issues whenever you need to have

00:06:37,280 --> 00:06:42,400
these in a

00:06:38,720 --> 00:06:44,720
mathematical sense of a set so multiple

00:06:42,400 --> 00:06:45,759
pieces of data that have the same type

00:06:44,720 --> 00:06:49,039
and have to be

00:06:45,759 --> 00:06:52,160
uh unique okay uh so you gotta leave

00:06:49,039 --> 00:06:54,880
list containers are nodes that group

00:06:52,160 --> 00:06:57,440
other nodes in the data model and

00:06:54,880 --> 00:07:00,000
ultimately have lists that also groups

00:06:57,440 --> 00:07:00,800
data other nodes in the data model but

00:07:00,000 --> 00:07:02,560
it does

00:07:00,800 --> 00:07:03,840
that within the context of a key so you

00:07:02,560 --> 00:07:06,960
can think of it as a

00:07:03,840 --> 00:07:07,919
record in a database so again leave is a

00:07:06,960 --> 00:07:11,599
terminated node

00:07:07,919 --> 00:07:15,360
with a type and a value

00:07:11,599 --> 00:07:17,360
and a name left list multiple leaves so

00:07:15,360 --> 00:07:18,800
basically multiple values of the same

00:07:17,360 --> 00:07:21,680
type unique

00:07:18,800 --> 00:07:23,039
so it's a set in a mathematical sense

00:07:21,680 --> 00:07:25,360
container is going to group

00:07:23,039 --> 00:07:26,800
other nodes and you got lists that

00:07:25,360 --> 00:07:29,039
typically have a key

00:07:26,800 --> 00:07:31,120
and these four components are the legos

00:07:29,039 --> 00:07:34,240
that are used to build the overall

00:07:31,120 --> 00:07:37,520
uh tree structure all right

00:07:34,240 --> 00:07:40,560
so that is a very brief overview of yang

00:07:37,520 --> 00:07:42,479
we're gonna see later how the sdk kind

00:07:40,560 --> 00:07:44,240
of simplifies the use of yang so we

00:07:42,479 --> 00:07:45,919
don't need to worry too much about the

00:07:44,240 --> 00:07:47,280
the details of the modern language per

00:07:45,919 --> 00:07:50,560
se

00:07:47,280 --> 00:07:51,440
so if we use net comp as a protocol to

00:07:50,560 --> 00:07:54,160
interface

00:07:51,440 --> 00:07:55,360
with the device programmatically netconf

00:07:54,160 --> 00:07:58,560
is an rpc

00:07:55,360 --> 00:08:01,440
based protocol so basically you have a a

00:07:58,560 --> 00:08:03,759
remote procedure call a call or request

00:08:01,440 --> 00:08:06,160
sent in xml format to the router and the

00:08:03,759 --> 00:08:08,160
router is going to send a response

00:08:06,160 --> 00:08:10,639
all the messages and all the data

00:08:08,160 --> 00:08:13,039
embedded in the messages are encoded

00:08:10,639 --> 00:08:14,720
in xml and we see here a list of the

00:08:13,039 --> 00:08:16,000
rpcs that are available you got get

00:08:14,720 --> 00:08:18,240
config

00:08:16,000 --> 00:08:20,080
copy config etc they allow you to

00:08:18,240 --> 00:08:21,840
manipulate not only configuration but

00:08:20,080 --> 00:08:25,360
the operational data

00:08:21,840 --> 00:08:28,800
all data exchanged in xml these are pcs

00:08:25,360 --> 00:08:30,879
obviously i'm just listing listing here

00:08:28,800 --> 00:08:32,800
the name of the rpcs but the rpcs has

00:08:30,879 --> 00:08:34,479
multiple arguments that are available in

00:08:32,800 --> 00:08:36,240
each of the rpcs

00:08:34,479 --> 00:08:38,479
so if you want to interact with the

00:08:36,240 --> 00:08:40,719
devices you in theory you have to be

00:08:38,479 --> 00:08:42,080
familiar not only with the data models

00:08:40,719 --> 00:08:43,919
but you have to be familiar with all

00:08:42,080 --> 00:08:45,680
these rpcs and with the parameters of

00:08:43,919 --> 00:08:48,720
the rpcs

00:08:45,680 --> 00:08:51,040
the older programmatic interface

00:08:48,720 --> 00:08:52,320
that can be used to enter to interact

00:08:51,040 --> 00:08:55,040
with the data models

00:08:52,320 --> 00:08:56,160
is grpc and in particular the grpc

00:08:55,040 --> 00:08:59,200
network management

00:08:56,160 --> 00:09:00,959
interface and it's also an rpc based

00:08:59,200 --> 00:09:04,240
protocol

00:09:00,959 --> 00:09:06,240
and we have four main rpcs that allow us

00:09:04,240 --> 00:09:08,000
to interface with the device our

00:09:06,240 --> 00:09:10,000
capabilities rpcs

00:09:08,000 --> 00:09:11,200
uh to discover the capabilities of the

00:09:10,000 --> 00:09:14,160
device i

00:09:11,200 --> 00:09:16,240
get rpc that allows me to read uh

00:09:14,160 --> 00:09:17,360
configuration or operational data from

00:09:16,240 --> 00:09:19,839
the device

00:09:17,360 --> 00:09:21,600
a set rpc that allows me to write

00:09:19,839 --> 00:09:24,800
configuration on the device

00:09:21,600 --> 00:09:27,440
and a subscribe rpc that allows me to

00:09:24,800 --> 00:09:28,080
program the device to stream uh some

00:09:27,440 --> 00:09:30,880
data

00:09:28,080 --> 00:09:31,920
uh back to me so those are those are the

00:09:30,880 --> 00:09:35,040
um

00:09:31,920 --> 00:09:38,080
the four based uh uh the four

00:09:35,040 --> 00:09:39,200
uh base uh rpcs and as as it was the

00:09:38,080 --> 00:09:40,880
case on netcom

00:09:39,200 --> 00:09:42,399
each of these rpgs is a set of

00:09:40,880 --> 00:09:44,240
attributes and parameters that you need

00:09:42,399 --> 00:09:46,080
to specify to get different behaviors

00:09:44,240 --> 00:09:47,839
from their pc

00:09:46,080 --> 00:09:49,279
so if you wanted to take the advantages

00:09:47,839 --> 00:09:50,959
in principle if you wanted to take the

00:09:49,279 --> 00:09:54,080
advantages of this new framework

00:09:50,959 --> 00:09:55,680
you will have to understand uh yang or

00:09:54,080 --> 00:09:58,000
have a very good understanding of

00:09:55,680 --> 00:09:59,200
yang you will have to have a very good

00:09:58,000 --> 00:10:02,000
understanding of either

00:09:59,200 --> 00:10:02,880
net conf or gnmi to be able to use that

00:10:02,000 --> 00:10:05,360
framework

00:10:02,880 --> 00:10:06,240
so what we're trying to do with the sdk

00:10:05,360 --> 00:10:08,399
see how

00:10:06,240 --> 00:10:10,240
we simplify the use of these

00:10:08,399 --> 00:10:10,640
technologies to make sure that people

00:10:10,240 --> 00:10:13,839
drive

00:10:10,640 --> 00:10:15,680
automation as fast as possible

00:10:13,839 --> 00:10:17,680
so that's why we developed the yang

00:10:15,680 --> 00:10:18,000
development kit with the yan development

00:10:17,680 --> 00:10:22,000
kit

00:10:18,000 --> 00:10:25,360
you have an sdk sorry an sdk to develop

00:10:22,000 --> 00:10:25,920
automation applications for devices that

00:10:25,360 --> 00:10:29,040
support

00:10:25,920 --> 00:10:31,279
yang yang by you know by now has become

00:10:29,040 --> 00:10:34,320
pretty much a de facto

00:10:31,279 --> 00:10:37,279
modern language for networking devices

00:10:34,320 --> 00:10:38,160
so if you're trying to manage a a

00:10:37,279 --> 00:10:40,000
relatively

00:10:38,160 --> 00:10:41,920
new networking device you're going to

00:10:40,000 --> 00:10:42,880
find that all these new devices support

00:10:41,920 --> 00:10:46,079
yang as a modern

00:10:42,880 --> 00:10:48,800
language okay so this development kit

00:10:46,079 --> 00:10:49,519
uh this sdk is auto generated from the

00:10:48,800 --> 00:10:53,440
yang

00:10:49,519 --> 00:10:54,720
data models okay and it has two very

00:10:53,440 --> 00:10:57,040
important

00:10:54,720 --> 00:10:58,880
the first one it allows or it provides a

00:10:57,040 --> 00:11:00,720
lot of abstractions

00:10:58,880 --> 00:11:02,880
provide an abstraction for the data

00:11:00,720 --> 00:11:04,560
models for yang in particular so you're

00:11:02,880 --> 00:11:05,680
able to use the data models without

00:11:04,560 --> 00:11:08,720
having to worry about

00:11:05,680 --> 00:11:09,920
learning all the details of yang it

00:11:08,720 --> 00:11:12,720
provides

00:11:09,920 --> 00:11:13,680
abstraction for the management protocols

00:11:12,720 --> 00:11:16,320
so it gives you

00:11:13,680 --> 00:11:18,000
access direct access to netconf and gnmi

00:11:16,320 --> 00:11:20,720
and dressconf if you choose

00:11:18,000 --> 00:11:21,839
but it also can hide the details of

00:11:20,720 --> 00:11:26,000
netcom gnmi

00:11:21,839 --> 00:11:28,480
and rescon we're gonna see that

00:11:26,000 --> 00:11:30,320
i can write all my automation without

00:11:28,480 --> 00:11:32,399
having to worry about the underlying

00:11:30,320 --> 00:11:34,160
protocol i want to use

00:11:32,399 --> 00:11:35,680
and it also provides an abstraction for

00:11:34,160 --> 00:11:38,640
the data encoding

00:11:35,680 --> 00:11:40,480
um potentially using this sdk i'm going

00:11:38,640 --> 00:11:42,480
to build client applications for

00:11:40,480 --> 00:11:44,560
automation and all the data

00:11:42,480 --> 00:11:46,480
ultimately goes to the device in xml

00:11:44,560 --> 00:11:47,839
format or json or google protocol

00:11:46,480 --> 00:11:50,880
buffers

00:11:47,839 --> 00:11:52,399
and the sdk allows me just to manipulate

00:11:50,880 --> 00:11:54,079
objects in the native programming

00:11:52,399 --> 00:11:56,480
language of choice without having to

00:11:54,079 --> 00:11:58,560
worry with that data ultimately is

00:11:56,480 --> 00:12:00,639
how the data is encoded and decoded all

00:11:58,560 --> 00:12:03,839
that happens automatically

00:12:00,639 --> 00:12:06,240
in addition to these abstractions

00:12:03,839 --> 00:12:07,200
the sdk provides built-in data

00:12:06,240 --> 00:12:10,720
validation

00:12:07,200 --> 00:12:12,639
okay so uh as i mentioned before

00:12:10,720 --> 00:12:14,399
the data model defines everything that

00:12:12,639 --> 00:12:14,959
can be configured and monitored on the

00:12:14,399 --> 00:12:18,560
box

00:12:14,959 --> 00:12:20,079
in a tree format so it specifies all the

00:12:18,560 --> 00:12:23,279
nodes and it specifies

00:12:20,079 --> 00:12:25,440
what type uh the nodes has what name so

00:12:23,279 --> 00:12:27,760
if i deviate if i create an object and i

00:12:25,440 --> 00:12:31,200
deviate from the definition of the model

00:12:27,760 --> 00:12:32,639
uh the data um the script automatically

00:12:31,200 --> 00:12:34,160
all the software that is built with it

00:12:32,639 --> 00:12:35,040
whatever software is written with the

00:12:34,160 --> 00:12:36,320
sdk

00:12:35,040 --> 00:12:38,240
automatically it's gonna perform the

00:12:36,320 --> 00:12:40,959
validation and i have some

00:12:38,240 --> 00:12:42,480
a couple of examples where that

00:12:40,959 --> 00:12:43,279
automatic validation is going to be more

00:12:42,480 --> 00:12:46,079
obvious

00:12:43,279 --> 00:12:48,160
the sdk is available in multiple

00:12:46,079 --> 00:12:50,560
languages available in python

00:12:48,160 --> 00:12:52,160
go and simple splash and it's completely

00:12:50,560 --> 00:12:54,000
open source

00:12:52,160 --> 00:12:55,680
it's available on github and i have the

00:12:54,000 --> 00:12:57,519
pointers at the end of the presentation

00:12:55,680 --> 00:13:01,440
you can you can take a look at it

00:12:57,519 --> 00:13:03,040
the simplest way to get access to all

00:13:01,440 --> 00:13:06,639
the resources is just go to

00:13:03,040 --> 00:13:10,160
uh ydk.io okay

00:13:06,639 --> 00:13:10,959
so uh let's uh take a closer look at the

00:13:10,160 --> 00:13:13,600
structure

00:13:10,959 --> 00:13:15,200
of the sdk and the packaging uh that is

00:13:13,600 --> 00:13:18,639
used

00:13:15,200 --> 00:13:21,519
so you're gonna find in in general uh

00:13:18,639 --> 00:13:22,240
what we consider to be the core package

00:13:21,519 --> 00:13:25,519
shown here

00:13:22,240 --> 00:13:29,360
in the bottom part and the

00:13:25,519 --> 00:13:30,320
core package brings a collection of

00:13:29,360 --> 00:13:32,720
services

00:13:30,320 --> 00:13:34,480
that have implementations for the

00:13:32,720 --> 00:13:35,360
different protocols so implementations

00:13:34,480 --> 00:13:38,880
for gnmi

00:13:35,360 --> 00:13:41,600
implementations for um

00:13:38,880 --> 00:13:43,760
netcomp implementations for rescon but

00:13:41,600 --> 00:13:47,199
in addition perform solar functions

00:13:43,760 --> 00:13:48,000
that are functions on data models that

00:13:47,199 --> 00:13:49,360
are necessary

00:13:48,000 --> 00:13:52,000
related to protocols for instance

00:13:49,360 --> 00:13:54,639
there's a service to encode and decode

00:13:52,000 --> 00:13:56,720
in case i want to take for instance a

00:13:54,639 --> 00:13:59,680
json string and converted

00:13:56,720 --> 00:14:01,120
or validated with the model okay so

00:13:59,680 --> 00:14:04,480
services in general

00:14:01,120 --> 00:14:05,199
are it's an implementation of a protocol

00:14:04,480 --> 00:14:07,279
that's probably

00:14:05,199 --> 00:14:08,959
the simplest uh the simplest way to do

00:14:07,279 --> 00:14:12,399
it or an implementation of an

00:14:08,959 --> 00:14:15,199
abstraction of a protocol okay

00:14:12,399 --> 00:14:16,000
uh the services make use of providers so

00:14:15,199 --> 00:14:18,320
you can have an

00:14:16,000 --> 00:14:20,560
instance of a service that has different

00:14:18,320 --> 00:14:24,399
providers or different implementations

00:14:20,560 --> 00:14:26,720
an example of this is the crud service

00:14:24,399 --> 00:14:28,160
the crowd service stands for create read

00:14:26,720 --> 00:14:31,360
update and delete

00:14:28,160 --> 00:14:34,480
and allows me to manage a box

00:14:31,360 --> 00:14:37,600
a device a router a switch

00:14:34,480 --> 00:14:39,279
using create read uh update and delete

00:14:37,600 --> 00:14:40,720
operations

00:14:39,279 --> 00:14:43,519
and not have to worry about the

00:14:40,720 --> 00:14:45,680
underlying protocol i just specified a

00:14:43,519 --> 00:14:47,839
provider and that provider can either be

00:14:45,680 --> 00:14:51,600
a netcom session or a gnmi

00:14:47,839 --> 00:14:54,639
and the sdk automatically takes care of

00:14:51,600 --> 00:14:57,199
issuing the correct rpc calls to match

00:14:54,639 --> 00:15:01,680
the semantics of the cloud service okay

00:14:57,199 --> 00:15:05,920
at the lower level of the core um

00:15:01,680 --> 00:15:06,320
package you have the path api which is a

00:15:05,920 --> 00:15:09,839
low

00:15:06,320 --> 00:15:13,120
level api that allows you to make use of

00:15:09,839 --> 00:15:16,399
models um using

00:15:13,120 --> 00:15:18,240
path notation okay so

00:15:16,399 --> 00:15:20,000
services and providers make part of the

00:15:18,240 --> 00:15:20,720
core but what are the data models the

00:15:20,000 --> 00:15:23,519
data models

00:15:20,720 --> 00:15:24,160
actually are packaged as model bundles

00:15:23,519 --> 00:15:26,800
okay

00:15:24,160 --> 00:15:27,839
and in these model bundles you have a

00:15:26,800 --> 00:15:29,920
hierarchy of

00:15:27,839 --> 00:15:31,519
classes that completely mirror the

00:15:29,920 --> 00:15:34,800
structure of the data models

00:15:31,519 --> 00:15:38,800
okay and this is this uh packaging

00:15:34,800 --> 00:15:40,240
allows you to install different mod

00:15:38,800 --> 00:15:42,800
model bundles depending on the

00:15:40,240 --> 00:15:46,000
capabilities of the devices device

00:15:42,800 --> 00:15:47,839
may support different model families

00:15:46,000 --> 00:15:49,759
or different vendors have different

00:15:47,839 --> 00:15:50,399
model families so in this way you

00:15:49,759 --> 00:15:54,000
install

00:15:50,399 --> 00:15:54,800
the core package and those services are

00:15:54,000 --> 00:15:57,920
going to act

00:15:54,800 --> 00:15:59,759
on models that are part of the model

00:15:57,920 --> 00:16:01,040
bundles and you can decide what model

00:15:59,759 --> 00:16:03,120
bundles you can install

00:16:01,040 --> 00:16:04,639
okay and you have this structure

00:16:03,120 --> 00:16:08,560
basically in python

00:16:04,639 --> 00:16:10,959
in c plus plus and in the goal

00:16:08,560 --> 00:16:12,880
programming language so let's take a

00:16:10,959 --> 00:16:13,759
look at what's inside those model

00:16:12,880 --> 00:16:17,279
bundles

00:16:13,759 --> 00:16:19,839
the model bundles is basically uh

00:16:17,279 --> 00:16:21,519
classes that have been auto-generated

00:16:19,839 --> 00:16:23,920
nested classes that have been

00:16:21,519 --> 00:16:24,720
auto-generated from the yan models to

00:16:23,920 --> 00:16:27,199
match

00:16:24,720 --> 00:16:27,920
one by one the structure of the data

00:16:27,199 --> 00:16:30,079
model

00:16:27,920 --> 00:16:31,360
so that allows me to instantiate these

00:16:30,079 --> 00:16:34,320
objects

00:16:31,360 --> 00:16:34,720
and perform operations of these objects

00:16:34,320 --> 00:16:37,920
so

00:16:34,720 --> 00:16:41,040
services on these objects okay

00:16:37,920 --> 00:16:42,320
the lee or leave list lists and

00:16:41,040 --> 00:16:45,440
containers

00:16:42,320 --> 00:16:48,639
become classes and a leaf node becomes

00:16:45,440 --> 00:16:50,399
attribute of a class okay and again the

00:16:48,639 --> 00:16:51,199
structure of how these classes are

00:16:50,399 --> 00:16:53,440
nested is

00:16:51,199 --> 00:16:54,399
completely identical to how defining the

00:16:53,440 --> 00:16:56,959
data model

00:16:54,399 --> 00:16:59,519
so these model bundles allow me just to

00:16:56,959 --> 00:17:00,639
instantiate for instance the root of a

00:16:59,519 --> 00:17:05,039
model

00:17:00,639 --> 00:17:08,000
um and recursively uh the

00:17:05,039 --> 00:17:08,240
model is instantiated and i end up with

00:17:08,000 --> 00:17:10,720
an

00:17:08,240 --> 00:17:12,240
empty object that i can populate with

00:17:10,720 --> 00:17:13,760
the data that i'm interested in

00:17:12,240 --> 00:17:15,360
and for instance let's say the example

00:17:13,760 --> 00:17:16,640
that i'm trying to configure something

00:17:15,360 --> 00:17:18,959
on advice

00:17:16,640 --> 00:17:21,039
so i can instantiate on a configuration

00:17:18,959 --> 00:17:24,079
object

00:17:21,039 --> 00:17:25,439
and recursively the model is

00:17:24,079 --> 00:17:27,679
instantiated with

00:17:25,439 --> 00:17:29,200
empty data with no data and i can plug

00:17:27,679 --> 00:17:32,960
the data that i'm interested in

00:17:29,200 --> 00:17:36,240
and then i can invoke a service to

00:17:32,960 --> 00:17:37,679
uh send that object for instance to the

00:17:36,240 --> 00:17:39,280
to the right and i have a couple of

00:17:37,679 --> 00:17:42,400
examples and that make it more

00:17:39,280 --> 00:17:45,120
more obvious okay but the key point here

00:17:42,400 --> 00:17:46,720
is that these model bundles and this

00:17:45,120 --> 00:17:48,720
definition of classes

00:17:46,720 --> 00:17:50,720
allows me to just focus on what's

00:17:48,720 --> 00:17:53,440
important and understanding the

00:17:50,720 --> 00:17:55,840
structure of the data in the data model

00:17:53,440 --> 00:17:57,919
i can completely forget about the

00:17:55,840 --> 00:18:00,559
details of yang

00:17:57,919 --> 00:18:04,160
yang i mean i i'm talking here about the

00:18:00,559 --> 00:18:05,840
four key abstractions that yang has but

00:18:04,160 --> 00:18:07,919
if you read the formal specification of

00:18:05,840 --> 00:18:09,919
yang actually yam is a

00:18:07,919 --> 00:18:11,440
can be a very complex uh modeling

00:18:09,919 --> 00:18:15,039
language he has a notion of

00:18:11,440 --> 00:18:16,400
module sub modules subs augmentations

00:18:15,039 --> 00:18:18,960
deviations

00:18:16,400 --> 00:18:19,840
groupings there are diff all kinds of

00:18:18,960 --> 00:18:23,039
different

00:18:19,840 --> 00:18:25,679
aspects that are present on data models

00:18:23,039 --> 00:18:26,559
and with this sdk i can completely

00:18:25,679 --> 00:18:28,559
forget about

00:18:26,559 --> 00:18:30,880
learning those little details and i can

00:18:28,559 --> 00:18:32,480
focus on understanding the harder key of

00:18:30,880 --> 00:18:34,480
the data which is what matters at the

00:18:32,480 --> 00:18:35,440
end of the day to develop any automation

00:18:34,480 --> 00:18:38,480
on software

00:18:35,440 --> 00:18:39,360
okay let's take a look at the validation

00:18:38,480 --> 00:18:42,480
i mentioned before

00:18:39,360 --> 00:18:45,440
one of the key benefits of the sdk is

00:18:42,480 --> 00:18:46,640
is the validation of the data because

00:18:45,440 --> 00:18:49,760
the

00:18:46,640 --> 00:18:52,480
the sdk and these um model bundles are

00:18:49,760 --> 00:18:55,679
originated from the yam file

00:18:52,480 --> 00:18:56,160
the any software written with the sdk it

00:18:55,679 --> 00:18:58,960
gets

00:18:56,160 --> 00:19:00,880
automatic client-side validation

00:18:58,960 --> 00:19:03,840
validation that is very fast

00:19:00,880 --> 00:19:05,919
and gives you precise error reporting so

00:19:03,840 --> 00:19:08,000
if i create an object for

00:19:05,919 --> 00:19:09,200
configuring for instance the interfaces

00:19:08,000 --> 00:19:12,240
of a device

00:19:09,200 --> 00:19:14,240
i start plugging that data if i try to

00:19:12,240 --> 00:19:14,960
for instance send that configuration to

00:19:14,240 --> 00:19:16,960
the router

00:19:14,960 --> 00:19:18,640
invoking a service that allows me to do

00:19:16,960 --> 00:19:20,400
that

00:19:18,640 --> 00:19:22,000
there's a validation step that takes

00:19:20,400 --> 00:19:23,600
place there automatically and it will

00:19:22,000 --> 00:19:24,559
tell me if there's any error on my

00:19:23,600 --> 00:19:26,160
object

00:19:24,559 --> 00:19:28,640
what kind of configuration errors or

00:19:26,160 --> 00:19:32,400
what kind of errors in general

00:19:28,640 --> 00:19:34,880
i can i can have my data uh

00:19:32,400 --> 00:19:36,400
you for instance you can have an object

00:19:34,880 --> 00:19:40,240
that is operational data

00:19:36,400 --> 00:19:41,520
operation or an object that corresponds

00:19:40,240 --> 00:19:43,520
to a

00:19:41,520 --> 00:19:44,799
data model for operational data

00:19:43,520 --> 00:19:46,640
operational data

00:19:44,799 --> 00:19:49,440
cannot be written on a device can only

00:19:46,640 --> 00:19:52,640
be read so if you create that object

00:19:49,440 --> 00:19:54,240
and you invoke a service to write that

00:19:52,640 --> 00:19:55,520
information on the router you will get

00:19:54,240 --> 00:19:57,919
an exception saying

00:19:55,520 --> 00:19:58,640
you cannot write that information on the

00:19:57,919 --> 00:20:00,080
router so that's

00:19:58,640 --> 00:20:01,840
for instance a simple level of

00:20:00,080 --> 00:20:03,039
validation that happens automatically

00:20:01,840 --> 00:20:06,000
for you

00:20:03,039 --> 00:20:07,919
there's also type validation so if the

00:20:06,000 --> 00:20:09,200
data model indicates that a particular

00:20:07,919 --> 00:20:12,400
node is a string

00:20:09,200 --> 00:20:12,400
integer or etc

00:20:12,559 --> 00:20:18,000
if you use um a different data type

00:20:16,320 --> 00:20:19,600
when you execute you get an exception it

00:20:18,000 --> 00:20:21,200
will indicate that you have a mismatch

00:20:19,600 --> 00:20:22,880
in the data type that is expected

00:20:21,200 --> 00:20:26,320
according to the data model

00:20:22,880 --> 00:20:29,200
the data model can also define

00:20:26,320 --> 00:20:31,120
uh some constraints on the values so

00:20:29,200 --> 00:20:33,520
even though a node is an integer there

00:20:31,120 --> 00:20:34,640
may be a valid range that is accepted

00:20:33,520 --> 00:20:36,400
for that integer

00:20:34,640 --> 00:20:38,480
or if it's a string there may be a

00:20:36,400 --> 00:20:39,280
regular expression that is associated

00:20:38,480 --> 00:20:42,080
according to

00:20:39,280 --> 00:20:44,080
the data model with that node so the

00:20:42,080 --> 00:20:46,720
value gets validated if

00:20:44,080 --> 00:20:48,159
the value does not match the constraints

00:20:46,720 --> 00:20:48,400
defined in the data model you will get

00:20:48,159 --> 00:20:52,240
an

00:20:48,400 --> 00:20:52,240
exception there's also

00:20:52,400 --> 00:20:57,280
semantic validation that takes place

00:20:55,520 --> 00:20:59,360
let's take the example of configuring

00:20:57,280 --> 00:21:02,000
the interfaces

00:20:59,360 --> 00:21:04,240
of the device the interface is typically

00:21:02,000 --> 00:21:07,360
are defined using a list

00:21:04,240 --> 00:21:11,679
and the key is the name of the

00:21:07,360 --> 00:21:14,400
interface so each interface has a unique

00:21:11,679 --> 00:21:16,640
name if you create an object for

00:21:14,400 --> 00:21:17,520
configured interfaces and you create two

00:21:16,640 --> 00:21:19,840
interfaces

00:21:17,520 --> 00:21:21,039
in that object and you give it the same

00:21:19,840 --> 00:21:22,720
key name

00:21:21,039 --> 00:21:24,320
when you're trying to send that object

00:21:22,720 --> 00:21:26,240
to the to the router

00:21:24,320 --> 00:21:27,520
your script will automatically throw an

00:21:26,240 --> 00:21:28,840
exception and you're saying and it's

00:21:27,520 --> 00:21:29,840
going to indicate that you have a

00:21:28,840 --> 00:21:33,280
duplicate uh

00:21:29,840 --> 00:21:36,400
key name okay allowing you to you know

00:21:33,280 --> 00:21:38,240
fix the the bug immediately it also

00:21:36,400 --> 00:21:40,559
takes care of deviations

00:21:38,240 --> 00:21:42,240
what are deviation deviations is a term

00:21:40,559 --> 00:21:45,280
uh that exists in yang

00:21:42,240 --> 00:21:48,880
it allows a device

00:21:45,280 --> 00:21:49,280
to um indicate exception so even though

00:21:48,880 --> 00:21:51,840
a

00:21:49,280 --> 00:21:52,720
device may support a data model maybe it

00:21:51,840 --> 00:21:54,320
doesn't support

00:21:52,720 --> 00:21:56,080
a hundred percent of the data model

00:21:54,320 --> 00:21:58,799
maybe it supports

00:21:56,080 --> 00:22:00,320
uh 90 of the data model so when the

00:21:58,799 --> 00:22:02,880
connection is established

00:22:00,320 --> 00:22:04,240
between the client and the router the

00:22:02,880 --> 00:22:06,880
writer can indicate what

00:22:04,240 --> 00:22:07,919
what are the exceptions that it has in

00:22:06,880 --> 00:22:11,280
coverage

00:22:07,919 --> 00:22:13,120
okay and if you create an object and you

00:22:11,280 --> 00:22:14,559
assign a value that you're trying to

00:22:13,120 --> 00:22:16,240
send to the router and the router

00:22:14,559 --> 00:22:17,520
already indicated with a deviation that

00:22:16,240 --> 00:22:20,000
it doesn't support that

00:22:17,520 --> 00:22:20,880
you would get an exception indicating uh

00:22:20,000 --> 00:22:23,840
or

00:22:20,880 --> 00:22:25,520
giving making you aware that the device

00:22:23,840 --> 00:22:26,159
is declaring that it doesn't support

00:22:25,520 --> 00:22:28,400
that

00:22:26,159 --> 00:22:29,360
data and you're trying to send that data

00:22:28,400 --> 00:22:32,000
to the device

00:22:29,360 --> 00:22:34,000
so all these validations again thousands

00:22:32,000 --> 00:22:35,600
and thousands of of complex code that

00:22:34,000 --> 00:22:37,840
you will have to write otherwise

00:22:35,600 --> 00:22:39,360
happens automatically for you just

00:22:37,840 --> 00:22:42,400
because of the fact

00:22:39,360 --> 00:22:45,679
that the sdks auto-generated from the

00:22:42,400 --> 00:22:48,400
yank files let's take a look at a very

00:22:45,679 --> 00:22:50,480
simple example in python

00:22:48,400 --> 00:22:52,840
this is an example that you can probably

00:22:50,480 --> 00:22:55,600
run it without any change

00:22:52,840 --> 00:22:59,520
whatsoever and what it does

00:22:55,600 --> 00:23:03,039
it uh changes the hostname

00:22:59,520 --> 00:23:05,919
of the router okay and

00:23:03,039 --> 00:23:06,640
it does that using a data model the

00:23:05,919 --> 00:23:09,200
system

00:23:06,640 --> 00:23:10,320
data model as defined by the uh open

00:23:09,200 --> 00:23:12,320
config

00:23:10,320 --> 00:23:14,240
group so let's take a look at what are

00:23:12,320 --> 00:23:17,280
the packages that get imported

00:23:14,240 --> 00:23:18,159
we see here uh that we're making use of

00:23:17,280 --> 00:23:20,840
the crop

00:23:18,159 --> 00:23:22,720
service i mentioned before the cloud

00:23:20,840 --> 00:23:25,600
service uh it's a create

00:23:22,720 --> 00:23:26,880
read update and delete uh service that

00:23:25,600 --> 00:23:28,640
abstracts away

00:23:26,880 --> 00:23:31,360
uh the protocol that we're gonna use to

00:23:28,640 --> 00:23:34,480
talk to a device

00:23:31,360 --> 00:23:36,880
uh we're also importing the netcomp

00:23:34,480 --> 00:23:37,919
service provider so this is indicating

00:23:36,880 --> 00:23:39,760
that even though

00:23:37,919 --> 00:23:42,240
all my code is going to be written in

00:23:39,760 --> 00:23:44,400
terms of crud operations

00:23:42,240 --> 00:23:46,000
ultimately i want to connect to the box

00:23:44,400 --> 00:23:49,919
using netcon

00:23:46,000 --> 00:23:54,000
and i import the openconfig system uh

00:23:49,919 --> 00:23:56,559
data model okay so um

00:23:54,000 --> 00:23:58,320
let's see here we instantiate the

00:23:56,559 --> 00:23:59,520
provider that's the first step that we

00:23:58,320 --> 00:24:01,520
take on the script

00:23:59,520 --> 00:24:02,880
after importing the modules we

00:24:01,520 --> 00:24:06,559
instantiate a

00:24:02,880 --> 00:24:08,320
a net con session we provide the address

00:24:06,559 --> 00:24:09,760
and the credentials to connect to the

00:24:08,320 --> 00:24:13,760
device

00:24:09,760 --> 00:24:17,120
then we instantiate a cloud service

00:24:13,760 --> 00:24:18,400
all right and we get into the data

00:24:17,120 --> 00:24:21,440
manipulation now

00:24:18,400 --> 00:24:25,840
we create the system

00:24:21,440 --> 00:24:25,840
object using the open config system

00:24:26,880 --> 00:24:33,840
model okay and i'm gonna end up with an

00:24:30,320 --> 00:24:35,840
empty empty representation of the

00:24:33,840 --> 00:24:37,360
of the model and then i'm going to go

00:24:35,840 --> 00:24:39,919
under system

00:24:37,360 --> 00:24:41,760
that config that hostname and i indicate

00:24:39,919 --> 00:24:44,480
the hostname that i want

00:24:41,760 --> 00:24:46,640
this path is exactly the path the

00:24:44,480 --> 00:24:50,080
hierarchy defined in the data model

00:24:46,640 --> 00:24:52,000
system config hostname okay system in

00:24:50,080 --> 00:24:53,679
young notation for those of you who may

00:24:52,000 --> 00:24:56,640
be interested in that

00:24:53,679 --> 00:24:58,640
uh system is a container in young terms

00:24:56,640 --> 00:24:59,120
and config is also a container in young

00:24:58,640 --> 00:25:03,120
terms

00:24:59,120 --> 00:25:05,440
okay and hostname is uh is a leaf

00:25:03,120 --> 00:25:07,039
so system gets translated into a class

00:25:05,440 --> 00:25:09,919
that is nested

00:25:07,039 --> 00:25:11,120
that has a another class nested inside a

00:25:09,919 --> 00:25:13,360
config

00:25:11,120 --> 00:25:15,279
and hostname is the attribute of the

00:25:13,360 --> 00:25:18,640
config class and we're setting that

00:25:15,279 --> 00:25:19,279
to to europe okay then once we have the

00:25:18,640 --> 00:25:22,400
data

00:25:19,279 --> 00:25:24,720
ready uh we call

00:25:22,400 --> 00:25:26,320
the create operation of the cloud

00:25:24,720 --> 00:25:28,880
service

00:25:26,320 --> 00:25:30,400
invoking uh or making use of the

00:25:28,880 --> 00:25:32,480
provider that we

00:25:30,400 --> 00:25:34,720
that we defined before the netcom

00:25:32,480 --> 00:25:37,520
session and passing the system

00:25:34,720 --> 00:25:38,720
object okay that has the data that i

00:25:37,520 --> 00:25:42,320
want to send

00:25:38,720 --> 00:25:45,520
so there are um a number of steps

00:25:42,320 --> 00:25:48,159
that happen at this point

00:25:45,520 --> 00:25:49,679
the first thing is that the script will

00:25:48,159 --> 00:25:52,480
validate the data

00:25:49,679 --> 00:25:53,520
has to make a an assessment of whether

00:25:52,480 --> 00:25:56,880
system config

00:25:53,520 --> 00:26:00,559
hostname assigning a string

00:25:56,880 --> 00:26:03,039
to that uh attribute is valid or not

00:26:00,559 --> 00:26:04,799
uh in this case hostname is is in the

00:26:03,039 --> 00:26:05,679
data model is defined as a string so

00:26:04,799 --> 00:26:10,559
this is valid

00:26:05,679 --> 00:26:12,480
okay uh then

00:26:10,559 --> 00:26:14,400
because the provider is not conf and all

00:26:12,480 --> 00:26:15,520
the communications and netconf are done

00:26:14,400 --> 00:26:18,240
with xml

00:26:15,520 --> 00:26:20,240
that system object will be converted to

00:26:18,240 --> 00:26:23,919
an xml string

00:26:20,240 --> 00:26:26,960
okay then because we're trying to

00:26:23,919 --> 00:26:29,679
perform the create operation

00:26:26,960 --> 00:26:31,360
the crea and with the with the netcom

00:26:29,679 --> 00:26:33,600
provider

00:26:31,360 --> 00:26:34,640
uh the create operation is going to be

00:26:33,600 --> 00:26:39,039
converted to an

00:26:34,640 --> 00:26:42,159
edit config rpc in netconf

00:26:39,039 --> 00:26:44,080
okay and that system data that was

00:26:42,159 --> 00:26:45,520
already converted to xml is going to be

00:26:44,080 --> 00:26:48,960
inserted into that

00:26:45,520 --> 00:26:49,919
rpc the rpc will be sent the edit config

00:26:48,960 --> 00:26:52,159
rpc

00:26:49,919 --> 00:26:54,880
we will wait or the script will wait for

00:26:52,159 --> 00:26:57,520
the okay to come back

00:26:54,880 --> 00:26:59,520
uh at that point it will decide whether

00:26:57,520 --> 00:27:03,360
the device that is talking to

00:26:59,520 --> 00:27:06,320
requires a commit or not in in net conf

00:27:03,360 --> 00:27:08,960
some devices require a commit to make

00:27:06,320 --> 00:27:11,760
changes effective some other ones do not

00:27:08,960 --> 00:27:13,919
the script automatically discovers that

00:27:11,760 --> 00:27:16,080
based on the capabilities that are

00:27:13,919 --> 00:27:17,840
exchanged when this provider was

00:27:16,080 --> 00:27:19,200
instantiated when this session was

00:27:17,840 --> 00:27:22,799
instantiated

00:27:19,200 --> 00:27:24,880
the writer would have indicated whether

00:27:22,799 --> 00:27:27,440
they needed a commit or not

00:27:24,880 --> 00:27:28,080
so if the writer needed a commit this

00:27:27,440 --> 00:27:30,080
create

00:27:28,080 --> 00:27:32,399
also will take care of sending the

00:27:30,080 --> 00:27:32,960
commit and waiting for an okay to come

00:27:32,399 --> 00:27:36,559
back

00:27:32,960 --> 00:27:38,799
okay so if you look at this script

00:27:36,559 --> 00:27:40,399
this script is making use of netcomp is

00:27:38,799 --> 00:27:43,840
using uh

00:27:40,399 --> 00:27:46,480
heavy use of xml it's using uh having

00:27:43,840 --> 00:27:48,000
making use of yang and not only this

00:27:46,480 --> 00:27:50,000
code i have to worry about

00:27:48,000 --> 00:27:52,080
the specifics of yang i didn't have to

00:27:50,000 --> 00:27:53,520
worry about the specifics of netcomp

00:27:52,080 --> 00:27:55,919
i didn't have to worry about the

00:27:53,520 --> 00:27:56,880
specifics of xml i just need to

00:27:55,919 --> 00:27:59,200
understand

00:27:56,880 --> 00:28:00,640
the structure of the data model the data

00:27:59,200 --> 00:28:03,279
that i want

00:28:00,640 --> 00:28:05,360
i want to create my object then i invoke

00:28:03,279 --> 00:28:05,919
the operation that i want on that object

00:28:05,360 --> 00:28:09,120
so this

00:28:05,919 --> 00:28:10,000
dramatically simplifies uh simplifies

00:28:09,120 --> 00:28:12,880
writing the code

00:28:10,000 --> 00:28:13,919
plus we get all the data validation um

00:28:12,880 --> 00:28:18,480
that i mentioned

00:28:13,919 --> 00:28:20,640
uh before so how can you get started

00:28:18,480 --> 00:28:21,520
from flavor of ydk which is the one that

00:28:20,640 --> 00:28:24,240
is most uh

00:28:21,520 --> 00:28:24,960
popular uh the first option that you

00:28:24,240 --> 00:28:28,880
have available

00:28:24,960 --> 00:28:31,919
is to install it on your system you can

00:28:28,880 --> 00:28:34,159
install it on mac os

00:28:31,919 --> 00:28:35,919
or you can also install it on linux if

00:28:34,159 --> 00:28:36,880
you want to install it on linux we have

00:28:35,919 --> 00:28:40,320
installations

00:28:36,880 --> 00:28:43,440
available for uh ubuntu and we also have

00:28:40,320 --> 00:28:44,000
installations available for centers you

00:28:43,440 --> 00:28:47,360
can install

00:28:44,000 --> 00:28:49,279
it from the python package index is also

00:28:47,360 --> 00:28:51,279
old software is also available on github

00:28:49,279 --> 00:28:54,559
so you can install

00:28:51,279 --> 00:28:56,840
from source using github

00:28:54,559 --> 00:28:58,640
but the recommender would actually use

00:28:56,840 --> 00:29:00,480
pipe

00:28:58,640 --> 00:29:02,640
we have a repository widely kit by

00:29:00,480 --> 00:29:04,000
sample that has a lot of examples so i

00:29:02,640 --> 00:29:05,600
would recommend if you install it on

00:29:04,000 --> 00:29:07,600
your system it's always good just to

00:29:05,600 --> 00:29:08,559
clone that repo to get a lot of examples

00:29:07,600 --> 00:29:12,640
and get familiar

00:29:08,559 --> 00:29:14,080
um get familiar with how ydk works

00:29:12,640 --> 00:29:15,919
if you don't want to install it in your

00:29:14,080 --> 00:29:18,960
system

00:29:15,919 --> 00:29:20,320
you can use a virtual environment we

00:29:18,960 --> 00:29:22,720
have two flavors of them

00:29:20,320 --> 00:29:24,240
one based on virtual machines another

00:29:22,720 --> 00:29:26,080
one based on containers

00:29:24,240 --> 00:29:28,159
so our virtual machines you can use

00:29:26,080 --> 00:29:30,640
vagrant with virtualbox

00:29:28,159 --> 00:29:32,240
okay so if you have those on your system

00:29:30,640 --> 00:29:35,039
if you go to the ydk

00:29:32,240 --> 00:29:37,360
pi samples repository you will find the

00:29:35,039 --> 00:29:41,200
vagrant file that is needed

00:29:37,360 --> 00:29:44,240
to initiate a virtual machine

00:29:41,200 --> 00:29:48,880
with this approach you have an

00:29:44,240 --> 00:29:51,760
ubuntu ubuntu virtual machine that has

00:29:48,880 --> 00:29:52,480
ydk pre-installed if you don't want to

00:29:51,760 --> 00:29:54,799
use

00:29:52,480 --> 00:29:56,559
virtual machine you can use a container

00:29:54,799 --> 00:29:58,880
uh you can use docker

00:29:56,559 --> 00:30:00,240
and you go to docker hub you look for

00:29:58,880 --> 00:30:01,840
the ydk

00:30:00,240 --> 00:30:04,320
docker containers and you can get

00:30:01,840 --> 00:30:08,320
started uh with that approach

00:30:04,320 --> 00:30:11,200
the last one is a hosted uh

00:30:08,320 --> 00:30:12,480
or a cloud-based uh alternative that you

00:30:11,200 --> 00:30:14,279
also have available

00:30:12,480 --> 00:30:16,399
if you have access to the

00:30:14,279 --> 00:30:19,120
cloud.cisco.com for that you need to

00:30:16,399 --> 00:30:22,960
have a cisco.com user id but those

00:30:19,120 --> 00:30:25,279
those should be um uh uh

00:30:22,960 --> 00:30:26,880
pretty much available uh for any user

00:30:25,279 --> 00:30:29,600
with registration

00:30:26,880 --> 00:30:31,200
you can um make use of the yan

00:30:29,600 --> 00:30:32,880
development kit sandbox that is

00:30:31,200 --> 00:30:36,559
available in the catalog

00:30:32,880 --> 00:30:40,799
and that will give you an ubuntu

00:30:36,559 --> 00:30:43,919
box and two c square us xr devices

00:30:40,799 --> 00:30:46,960
so you can use those devices to

00:30:43,919 --> 00:30:50,799
configure or read data programmatically

00:30:46,960 --> 00:30:52,480
uh using ydk from the ubuntu

00:30:50,799 --> 00:30:54,399
machine so those are the three options

00:30:52,480 --> 00:30:56,240
that you have again you can install it

00:30:54,399 --> 00:30:59,360
on your system natively

00:30:56,240 --> 00:31:01,039
you can use either a virtual machine or

00:30:59,360 --> 00:31:02,880
a docker container install a virtual

00:31:01,039 --> 00:31:06,080
machine or docker container

00:31:02,880 --> 00:31:10,320
or you can use a hosted setup

00:31:06,080 --> 00:31:13,919
on the cloud that's cisco.com

00:31:10,320 --> 00:31:16,640
all right so now it's uh demo time

00:31:13,919 --> 00:31:18,080
let's see it in action some of the code

00:31:16,640 --> 00:31:21,360
that i showed before i

00:31:18,080 --> 00:31:21,840
actually did um some changes to make it

00:31:21,360 --> 00:31:24,799
more

00:31:21,840 --> 00:31:26,960
more complete so i modified that script

00:31:24,799 --> 00:31:31,039
that i showed a few slides

00:31:26,960 --> 00:31:33,600
before so uh instead of

00:31:31,039 --> 00:31:35,039
having a host name hard coded that are

00:31:33,600 --> 00:31:35,919
gonna that is gonna be written on the

00:31:35,039 --> 00:31:37,600
box the

00:31:35,919 --> 00:31:39,519
it's gonna take it as an argument the

00:31:37,600 --> 00:31:41,919
script takes it as an argument

00:31:39,519 --> 00:31:43,360
and also has the option to either read

00:31:41,919 --> 00:31:46,480
the host name or write

00:31:43,360 --> 00:31:47,039
the host name okay and you can talk to

00:31:46,480 --> 00:31:50,240
the box

00:31:47,039 --> 00:31:51,919
using either netconf or gnmi the example

00:31:50,240 --> 00:31:54,159
that i had before was

00:31:51,919 --> 00:31:56,000
always writing the hostname the hostname

00:31:54,159 --> 00:31:58,960
was hardcoded and it was also

00:31:56,000 --> 00:32:00,720
always using netcom so with this uh

00:31:58,960 --> 00:32:03,039
script

00:32:00,720 --> 00:32:04,480
i can choose whether i want to read read

00:32:03,039 --> 00:32:07,600
whether i want to write

00:32:04,480 --> 00:32:10,159
the host name um and i can choose

00:32:07,600 --> 00:32:13,200
whether when i use netcom for gnmr

00:32:10,159 --> 00:32:15,840
it is vendor neutral because it uses the

00:32:13,200 --> 00:32:17,120
config system data model is protocol

00:32:15,840 --> 00:32:20,799
neutral

00:32:17,120 --> 00:32:23,679
excuse me because um it uses the

00:32:20,799 --> 00:32:24,799
crud uh service as an abstraction of the

00:32:23,679 --> 00:32:26,720
protocol

00:32:24,799 --> 00:32:29,200
and it's also encoding neutral i don't i

00:32:26,720 --> 00:32:31,840
don't need to worry in my script to

00:32:29,200 --> 00:32:34,080
deal with the details of xml json google

00:32:31,840 --> 00:32:37,279
protocol buffers all that happens um

00:32:34,080 --> 00:32:41,120
automatically so let's take a

00:32:37,279 --> 00:32:43,919
look at that let's go to the box

00:32:41,120 --> 00:32:47,760
okay so first of all let's take a look

00:32:43,919 --> 00:32:47,760
at what i have installed here

00:32:51,440 --> 00:32:56,159
all right so so we we're going to be

00:32:54,000 --> 00:32:57,679
using version 8.5

00:32:56,159 --> 00:32:59,440
and we're going to be using open config

00:32:57,679 --> 00:33:02,320
data models so we have this

00:32:59,440 --> 00:33:03,360
bundle um bundle this is the model

00:33:02,320 --> 00:33:05,760
bundle for

00:33:03,360 --> 00:33:07,840
open config and this is the core package

00:33:05,760 --> 00:33:10,640
that we're going to be using okay

00:33:07,840 --> 00:33:12,799
so the name of the script is host

00:33:10,640 --> 00:33:17,360
hostname so let's try to

00:33:12,799 --> 00:33:18,880
as i mentioned before the script

00:33:17,360 --> 00:33:21,120
takes some arguments from the command

00:33:18,880 --> 00:33:24,399
line so the first thing

00:33:21,120 --> 00:33:26,159
is it takes us an argument the device

00:33:24,399 --> 00:33:27,519
that you want to talk to the device

00:33:26,159 --> 00:33:29,760
where you want to read the

00:33:27,519 --> 00:33:30,960
host link from or the device you want to

00:33:29,760 --> 00:33:34,640
write the host name to

00:33:30,960 --> 00:33:37,679
okay uh you specify the device

00:33:34,640 --> 00:33:40,880
and shows us as a url okay

00:33:37,679 --> 00:33:44,799
by default if no other argument is

00:33:40,880 --> 00:33:46,480
specified uh the script is gonna read

00:33:44,799 --> 00:33:48,480
the hostname and it's gonna read it

00:33:46,480 --> 00:33:51,200
using netconf

00:33:48,480 --> 00:33:52,399
if you wanna write the hostname you need

00:33:51,200 --> 00:33:55,440
to provide the

00:33:52,399 --> 00:33:57,600
right argument

00:33:55,440 --> 00:33:59,679
and if you want to change the protocol

00:33:57,600 --> 00:34:03,120
you need to specify the gnmi

00:33:59,679 --> 00:34:06,159
option okay in addition to these two uh

00:34:03,120 --> 00:34:08,560
arguments uh we have a verbose option

00:34:06,159 --> 00:34:10,159
to see the logs to see the details of

00:34:08,560 --> 00:34:14,240
what's uh what's going on

00:34:10,159 --> 00:34:17,280
okay so let's run it first uh just

00:34:14,240 --> 00:34:19,280
reading on the current hostname of the

00:34:17,280 --> 00:34:20,159
device and this is a device that i had

00:34:19,280 --> 00:34:23,679
available

00:34:20,159 --> 00:34:25,280
at the moment so um

00:34:23,679 --> 00:34:26,960
i'm just going to specify the device so

00:34:25,280 --> 00:34:28,720
again by default it's going to use

00:34:26,960 --> 00:34:32,240
netconf and by default it's just going

00:34:28,720 --> 00:34:34,000
to read the hostname

00:34:32,240 --> 00:34:35,359
okay so it comes back and it tells me

00:34:34,000 --> 00:34:38,480
the host name is uh

00:34:35,359 --> 00:34:41,599
asbr asbr one okay

00:34:38,480 --> 00:34:43,679
so before we go into more

00:34:41,599 --> 00:34:44,960
uh detail before we try to execute it

00:34:43,679 --> 00:34:46,960
with different arguments what i'm gonna

00:34:44,960 --> 00:34:48,000
do is just take a quick look and add

00:34:46,960 --> 00:34:49,119
script

00:34:48,000 --> 00:34:51,679
and you're going to see a lot of

00:34:49,119 --> 00:34:55,200
commonality to uh commonality

00:34:51,679 --> 00:34:58,720
with the example that i that i um

00:34:55,200 --> 00:35:00,720
that i provided a few slides ago okay

00:34:58,720 --> 00:35:03,119
so this is kind of the bulk of the of

00:35:00,720 --> 00:35:07,040
the script

00:35:03,119 --> 00:35:10,400
um let me maybe go to the

00:35:07,040 --> 00:35:14,320
to the beginning these are just common

00:35:10,400 --> 00:35:17,520
comments okay so key things that uh

00:35:14,320 --> 00:35:20,800
that we're doing uh here uh

00:35:17,520 --> 00:35:22,960
we're importing the cloud service we're

00:35:20,800 --> 00:35:26,560
importing the gmi provider

00:35:22,960 --> 00:35:30,079
and we're importing the uh netcomp uh

00:35:26,560 --> 00:35:32,720
provider okay so

00:35:30,079 --> 00:35:35,200
let's take a look at uh some of the

00:35:32,720 --> 00:35:35,200
logic

00:35:35,599 --> 00:35:41,680
so if the user specified uh

00:35:38,880 --> 00:35:43,680
the gnmi option we're gonna make use of

00:35:41,680 --> 00:35:46,800
the gnmi provider so we're going to

00:35:43,680 --> 00:35:48,079
instantiate a gmi provider and store it

00:35:46,800 --> 00:35:50,800
in provider

00:35:48,079 --> 00:35:51,839
otherwise by default we use the netcom

00:35:50,800 --> 00:35:55,280
provider okay

00:35:51,839 --> 00:35:58,160
so this is all the logic i need

00:35:55,280 --> 00:35:58,960
for the rest of the script to function

00:35:58,160 --> 00:36:02,320
for both

00:35:58,960 --> 00:36:05,599
gnmi and netcon okay

00:36:02,320 --> 00:36:06,480
so after we decide what is the provider

00:36:05,599 --> 00:36:10,079
that we want

00:36:06,480 --> 00:36:11,520
we instantiate uh the cloud service

00:36:10,079 --> 00:36:13,599
that again is going to give me that

00:36:11,520 --> 00:36:18,240
abstraction on top of the protocol

00:36:13,599 --> 00:36:20,720
okay after i create the cloud service

00:36:18,240 --> 00:36:21,920
i'm going to check whether the users

00:36:20,720 --> 00:36:23,760
specify the right

00:36:21,920 --> 00:36:26,000
argument meaning that they want to write

00:36:23,760 --> 00:36:28,640
a new host name on the router

00:36:26,000 --> 00:36:30,079
if they wanted to write a new host name

00:36:28,640 --> 00:36:33,839
on the router

00:36:30,079 --> 00:36:36,960
i create the object from the

00:36:33,839 --> 00:36:40,400
system data model and i go

00:36:36,960 --> 00:36:44,800
under system com hostname and i assign

00:36:40,400 --> 00:36:48,079
the value specified by the user okay

00:36:44,800 --> 00:36:48,800
after i populate the data i call the

00:36:48,079 --> 00:36:52,320
create

00:36:48,800 --> 00:36:54,560
operation with my provider at this point

00:36:52,320 --> 00:36:56,560
i don't care if that provider is gnmi or

00:36:54,560 --> 00:37:00,240
netcom the logic is the same

00:36:56,560 --> 00:37:03,440
and i pass my system object okay

00:37:00,240 --> 00:37:06,480
um this create

00:37:03,440 --> 00:37:09,359
is gonna implement the first of all it's

00:37:06,480 --> 00:37:11,839
gonna trigger the validation

00:37:09,359 --> 00:37:14,079
and it's going to create the right rpc

00:37:11,839 --> 00:37:17,359
depending on the provider

00:37:14,079 --> 00:37:19,440
and it's going to trigger the the proper

00:37:17,359 --> 00:37:21,119
encoding of the data again depending

00:37:19,440 --> 00:37:24,640
depending on the provider

00:37:21,119 --> 00:37:25,200
the provider is xml this is going to

00:37:24,640 --> 00:37:29,440
create an

00:37:25,200 --> 00:37:31,520
edit config xmlrpc

00:37:29,440 --> 00:37:33,119
and it's going to convert the system to

00:37:31,520 --> 00:37:35,839
xml

00:37:33,119 --> 00:37:36,800
if the provider is gnmi this create

00:37:35,839 --> 00:37:40,000
operation

00:37:36,800 --> 00:37:43,119
is going to create as a gnmi set

00:37:40,000 --> 00:37:46,320
rpc and it's going to convert

00:37:43,119 --> 00:37:48,000
the system object to json to adjacent

00:37:46,320 --> 00:37:50,720
string and all that is going to happen

00:37:48,000 --> 00:37:52,880
automatically nothing in this code

00:37:50,720 --> 00:37:55,119
uh has to in this code i don't have to

00:37:52,880 --> 00:37:57,119
worry about converting data

00:37:55,119 --> 00:37:58,960
to json or manipulating json i don't

00:37:57,119 --> 00:38:00,000
need to worry about protocol buffers i

00:37:58,960 --> 00:38:03,440
don't need to worry about

00:38:00,000 --> 00:38:05,680
xml i don't need to worry about the

00:38:03,440 --> 00:38:06,640
excuse me the details of how these rpcs

00:38:05,680 --> 00:38:08,640
are are

00:38:06,640 --> 00:38:10,320
are formatted or structured all that is

00:38:08,640 --> 00:38:12,240
handled automatically i don't need to

00:38:10,320 --> 00:38:13,920
worry about the validation of the data

00:38:12,240 --> 00:38:17,839
either

00:38:13,920 --> 00:38:21,040
okay if the user did not specify

00:38:17,839 --> 00:38:21,599
the right argument meaning we want to

00:38:21,040 --> 00:38:24,160
just

00:38:21,599 --> 00:38:25,359
read the host name so what we do we

00:38:24,160 --> 00:38:28,800
instantiate

00:38:25,359 --> 00:38:32,880
the data model and we invoke

00:38:28,800 --> 00:38:36,560
the read operation with the provider

00:38:32,880 --> 00:38:40,079
okay again uh the

00:38:36,560 --> 00:38:44,160
crowd read is gonna be translated to

00:38:40,079 --> 00:38:47,280
uh net conf

00:38:44,160 --> 00:38:48,400
get rpc if the provider is set to

00:38:47,280 --> 00:38:51,520
netconf

00:38:48,400 --> 00:38:55,119
or to a gnmi get

00:38:51,520 --> 00:38:57,599
rpc if the provider is gnmi

00:38:55,119 --> 00:38:59,119
and the data is going to be stored in

00:38:57,599 --> 00:39:03,280
this object

00:38:59,119 --> 00:39:05,280
and that that includes

00:39:03,280 --> 00:39:07,359
the validation of the data and also

00:39:05,280 --> 00:39:08,560
converting the data from xml to the

00:39:07,359 --> 00:39:10,560
python object or

00:39:08,560 --> 00:39:11,839
json to the python object depending on

00:39:10,560 --> 00:39:15,839
the type of provider

00:39:11,839 --> 00:39:18,240
all that happens automatically and

00:39:15,839 --> 00:39:20,800
after the data is read we're basically

00:39:18,240 --> 00:39:22,320
invoking this path in the model to print

00:39:20,800 --> 00:39:25,440
uh the host name

00:39:22,320 --> 00:39:27,839
uh that the router has okay so again

00:39:25,440 --> 00:39:29,040
this is the right operation this is the

00:39:27,839 --> 00:39:32,160
read operation

00:39:29,040 --> 00:39:35,440
and here um before this

00:39:32,160 --> 00:39:36,560
i decide whether the provider is going

00:39:35,440 --> 00:39:38,640
to be gnmi

00:39:36,560 --> 00:39:40,240
or netcom based on the argument passed

00:39:38,640 --> 00:39:43,760
by the user okay

00:39:40,240 --> 00:39:45,680
so let's go back again we run this um

00:39:43,760 --> 00:39:47,440
version of the script which was

00:39:45,680 --> 00:39:50,240
basically the default behavior

00:39:47,440 --> 00:39:54,000
to read the hostname using netconf but

00:39:50,240 --> 00:39:57,200
this time let's do it with a variation

00:39:54,000 --> 00:39:57,839
we're gonna pass the verbose flag so we

00:39:57,200 --> 00:40:01,440
can see

00:39:57,839 --> 00:40:05,359
what's happening in the background okay

00:40:01,440 --> 00:40:07,040
so we see all the logging okay so we see

00:40:05,359 --> 00:40:09,359
that

00:40:07,040 --> 00:40:11,680
the read operation of the cloud service

00:40:09,359 --> 00:40:14,880
got translated to a get

00:40:11,680 --> 00:40:17,119
rpc and we see here the reply that came

00:40:14,880 --> 00:40:19,680
back from the router

00:40:17,119 --> 00:40:20,960
with the data and we see all the data

00:40:19,680 --> 00:40:22,960
that was read back

00:40:20,960 --> 00:40:25,200
okay and this data in xml is being

00:40:22,960 --> 00:40:26,000
converted to the xml object we see here

00:40:25,200 --> 00:40:29,200
the host

00:40:26,000 --> 00:40:31,599
the hostname data coming back okay all

00:40:29,200 --> 00:40:35,119
this is validated and automatically

00:40:31,599 --> 00:40:37,920
uh converted to the uh

00:40:35,119 --> 00:40:39,440
to the python object and this is the the

00:40:37,920 --> 00:40:41,599
output of this

00:40:39,440 --> 00:40:43,280
other string uh sorry and they have to

00:40:41,599 --> 00:40:46,560
know the output of the script

00:40:43,280 --> 00:40:50,560
okay so

00:40:46,560 --> 00:40:54,000
let's now provide the right um

00:40:50,560 --> 00:40:55,200
argument so let's not just read in this

00:40:54,000 --> 00:40:58,800
case we're gonna we wanna

00:40:55,200 --> 00:41:01,760
define a new um

00:40:58,800 --> 00:41:03,359
and let's let's call it let's say we

00:41:01,760 --> 00:41:05,440
wanna rename the hostname

00:41:03,359 --> 00:41:07,359
uh we're gonna change it to europe from

00:41:05,440 --> 00:41:10,640
asbr one to something that is more

00:41:07,359 --> 00:41:14,480
meaningful so let's specify it as europe

00:41:10,640 --> 00:41:17,839
i still have the um verbose flag

00:41:14,480 --> 00:41:20,240
so we're going to see how uh the script

00:41:17,839 --> 00:41:23,599
now instead of doing the uh

00:41:20,240 --> 00:41:26,640
read crud read it's gonna do

00:41:23,599 --> 00:41:28,240
crud create and how that gets converted

00:41:26,640 --> 00:41:32,240
to a completely different

00:41:28,240 --> 00:41:32,240
uh net conf rpc

00:41:33,280 --> 00:41:39,440
okay so let's take a look at this

00:41:36,400 --> 00:41:41,040
okay so here we called it with the with

00:41:39,440 --> 00:41:44,000
the hostname

00:41:41,040 --> 00:41:45,040
and we see that now it's an edit config

00:41:44,000 --> 00:41:48,480
before

00:41:45,040 --> 00:41:52,240
it was a get rpc and here

00:41:48,480 --> 00:41:52,240
we have our object

00:41:52,560 --> 00:41:57,119
here we have our object converted to an

00:41:54,960 --> 00:42:01,680
xml string

00:41:57,119 --> 00:42:03,839
embedded in an edit config rpc okay

00:42:01,680 --> 00:42:05,359
this object was validated the fact that

00:42:03,839 --> 00:42:07,200
we made it this far it means that the

00:42:05,359 --> 00:42:08,480
object was validated successfully there

00:42:07,200 --> 00:42:12,960
was no errors

00:42:08,480 --> 00:42:14,720
okay here's the rpc sent to the router

00:42:12,960 --> 00:42:16,800
the writer took that data and is

00:42:14,720 --> 00:42:19,119
replying that the data is okay

00:42:16,800 --> 00:42:20,960
but the change is still not effective in

00:42:19,119 --> 00:42:22,640
this particular device this device

00:42:20,960 --> 00:42:25,440
requires a commit

00:42:22,640 --> 00:42:26,800
so here's the script uh sending a second

00:42:25,440 --> 00:42:29,200
rpc with a commit

00:42:26,800 --> 00:42:30,880
message asking the right to make the

00:42:29,200 --> 00:42:34,000
change effective

00:42:30,880 --> 00:42:34,480
and then we get the okay uh from the

00:42:34,000 --> 00:42:38,560
rudder

00:42:34,480 --> 00:42:42,640
okay so if we invoke

00:42:38,560 --> 00:42:42,640
um if we invoke

00:42:42,720 --> 00:42:47,680
let's say let's remove the right

00:42:46,480 --> 00:42:50,720
operation

00:42:47,680 --> 00:42:53,920
and let's now invoke it with the gmi

00:42:50,720 --> 00:42:53,920
let's see what happens

00:42:54,079 --> 00:43:00,480
we've read the hostname

00:42:57,119 --> 00:43:03,280
and now we've read it with gmi okay

00:43:00,480 --> 00:43:04,319
and we got europe so we effectively uh

00:43:03,280 --> 00:43:07,839
modified

00:43:04,319 --> 00:43:09,839
uh the host name and now we write it

00:43:07,839 --> 00:43:13,520
with gmi so let's verify

00:43:09,839 --> 00:43:17,040
let's see what

00:43:13,520 --> 00:43:20,079
how the messages look in the background

00:43:17,040 --> 00:43:23,119
okay so now we're reading

00:43:20,079 --> 00:43:26,319
with gnmi and we see

00:43:23,119 --> 00:43:29,359
that um the

00:43:26,319 --> 00:43:32,560
uh crud cree uh crud uh

00:43:29,359 --> 00:43:36,640
read got converted to a get

00:43:32,560 --> 00:43:40,240
uh gnmi request we see the encoding here

00:43:36,640 --> 00:43:42,319
i uses uh protocol protobuf encoding for

00:43:40,240 --> 00:43:45,200
the messages so this is the decoded

00:43:42,319 --> 00:43:46,800
protobuf message and we see here the

00:43:45,200 --> 00:43:48,319
response that comes back the

00:43:46,800 --> 00:43:51,119
notification

00:43:48,319 --> 00:43:52,880
with all the data the json data the data

00:43:51,119 --> 00:43:57,440
of the data model encoded

00:43:52,880 --> 00:44:02,160
in json so gdm is a little bit different

00:43:57,440 --> 00:44:02,880
in in net conf the rpc is xml and the

00:44:02,160 --> 00:44:07,040
data

00:44:02,880 --> 00:44:10,240
is xml also in the case of gnmi the rpc

00:44:07,040 --> 00:44:14,160
is protobuf and the data

00:44:10,240 --> 00:44:14,880
it's um json okay and we see here that

00:44:14,160 --> 00:44:17,680
the router

00:44:14,880 --> 00:44:19,760
effectively was changed to europe the

00:44:17,680 --> 00:44:24,000
host name and we can see it here in the

00:44:19,760 --> 00:44:27,040
in the embedded tool okay

00:44:24,000 --> 00:44:29,680
the last thing i wanted to show is it's

00:44:27,040 --> 00:44:30,640
it's kind of force uh it's a little bit

00:44:29,680 --> 00:44:32,720
of a hack

00:44:30,640 --> 00:44:34,839
with how the script is written but i

00:44:32,720 --> 00:44:37,520
wanted to show

00:44:34,839 --> 00:44:40,640
um the validation i want to force

00:44:37,520 --> 00:44:45,680
an error okay a validation error

00:44:40,640 --> 00:44:48,720
so let's say i have a bug in my script

00:44:45,680 --> 00:44:51,599
so instead of uh passing the arg

00:44:48,720 --> 00:44:54,400
right or the right argument provided by

00:44:51,599 --> 00:44:59,040
the user i made a mistake

00:44:54,400 --> 00:45:02,160
and i'm setting the oops

00:44:59,040 --> 00:45:05,119
i'm setting the hostname to a hundred

00:45:02,160 --> 00:45:05,920
even though the data model is a string

00:45:05,119 --> 00:45:07,920
so

00:45:05,920 --> 00:45:10,480
giving it an integer value should be

00:45:07,920 --> 00:45:15,359
invalid okay

00:45:10,480 --> 00:45:15,359
so let's say i'm executing my script

00:45:15,599 --> 00:45:19,920
okay so we're gonna execute it and let's

00:45:18,160 --> 00:45:23,760
say we wanna

00:45:19,920 --> 00:45:26,800
take the router back to asbr one

00:45:23,760 --> 00:45:28,880
okay uh and i ask for

00:45:26,800 --> 00:45:30,319
giv show me all the rpcs all the

00:45:28,880 --> 00:45:31,119
messages right that's what we do with

00:45:30,319 --> 00:45:33,359
the verbose

00:45:31,119 --> 00:45:35,839
to the same router okay let's see what

00:45:33,359 --> 00:45:35,839
happens

00:45:37,119 --> 00:45:41,520
we see here there's no rpc we don't see

00:45:39,280 --> 00:45:43,920
any xml messages sent to the router what

00:45:41,520 --> 00:45:47,119
we see is an exception

00:45:43,920 --> 00:45:50,800
that tells me that there's a model error

00:45:47,119 --> 00:45:54,400
invalid value 100 for hostname

00:45:50,800 --> 00:45:58,319
got integer and expected string

00:45:54,400 --> 00:45:59,680
so we see here the automatic validation

00:45:58,319 --> 00:46:02,720
kicked in

00:45:59,680 --> 00:46:05,359
and it validated the data locally

00:46:02,720 --> 00:46:06,960
without sending anything to the router

00:46:05,359 --> 00:46:10,160
okay

00:46:06,960 --> 00:46:10,160
if we go back

00:46:11,359 --> 00:46:16,720
remove that line let's go back

00:46:21,920 --> 00:46:26,480
and we run it again now we see the

00:46:25,280 --> 00:46:28,800
messages

00:46:26,480 --> 00:46:29,599
and now we see that we're sending the

00:46:28,800 --> 00:46:31,520
new

00:46:29,599 --> 00:46:33,200
name or we're sending the host name back

00:46:31,520 --> 00:46:35,839
to asbr one

00:46:33,200 --> 00:46:36,400
and we see that we get the okay uh back

00:46:35,839 --> 00:46:39,760
from

00:46:36,400 --> 00:46:39,760
from the right okay

00:46:39,839 --> 00:46:46,160
all right so let's go back uh uh

00:46:43,040 --> 00:46:48,240
really quick um uh

00:46:46,160 --> 00:46:49,280
after the demo and let's review some of

00:46:48,240 --> 00:46:52,480
the resources

00:46:49,280 --> 00:46:54,640
uh that are available so um

00:46:52,480 --> 00:46:56,240
all the resources that i'm listed this

00:46:54,640 --> 00:46:57,280
uh listing here pretty much are

00:46:56,240 --> 00:47:00,079
accessible

00:46:57,280 --> 00:47:02,160
from ydk.io so if you have one url that

00:47:00,079 --> 00:47:05,359
you want to remember probably ydk

00:47:02,160 --> 00:47:09,200
that i always prefer uh url

00:47:05,359 --> 00:47:11,200
if you're looking for uh samples

00:47:09,200 --> 00:47:12,800
you can go to ydk pi samples that i

00:47:11,200 --> 00:47:16,400
mentioned before on github

00:47:12,800 --> 00:47:20,079
there are over 700 examples um

00:47:16,400 --> 00:47:22,079
for some boxes uh on dcloud.cisco.com i

00:47:20,079 --> 00:47:25,839
mentioned already that you have

00:47:22,079 --> 00:47:29,440
a pre-installed ubuntu machine um

00:47:25,839 --> 00:47:32,720
with all of ydk plus two cisco ios xr

00:47:29,440 --> 00:47:33,920
routers um that you can make use of the

00:47:32,720 --> 00:47:37,040
vagrant box

00:47:33,920 --> 00:47:38,640
uh that is on the ydk pi samples repo to

00:47:37,040 --> 00:47:42,160
get a virtual machine

00:47:38,640 --> 00:47:44,559
and there's also the um docker i forgot

00:47:42,160 --> 00:47:47,760
to enumerate here sorry about that the

00:47:44,559 --> 00:47:48,720
docker hub um containers so those are

00:47:47,760 --> 00:47:51,760
additional

00:47:48,720 --> 00:47:55,200
that you can use

00:47:51,760 --> 00:47:55,520
for support i would encourage you to go

00:47:55,200 --> 00:47:58,640
to

00:47:55,520 --> 00:48:00,640
the community the ydk community um

00:47:58,640 --> 00:48:01,760
there's a number of users that you're

00:48:00,640 --> 00:48:04,079
gonna

00:48:01,760 --> 00:48:04,960
uh they're gonna find there plus all the

00:48:04,079 --> 00:48:08,319
contributors

00:48:04,960 --> 00:48:11,920
also joined the support

00:48:08,319 --> 00:48:13,599
community okay for documentation

00:48:11,920 --> 00:48:15,599
uh these are the urls where you can find

00:48:13,599 --> 00:48:18,160
the python the go and the c

00:48:15,599 --> 00:48:20,319
plus documentation this is the list of

00:48:18,160 --> 00:48:23,839
repositories source repositories

00:48:20,319 --> 00:48:28,160
uh that you can uh that you can check

00:48:23,839 --> 00:48:29,920
um for python for go and for c plus plus

00:48:28,160 --> 00:48:31,520
you can obviously as i mentioned before

00:48:29,920 --> 00:48:33,119
you can stop from source but in the case

00:48:31,520 --> 00:48:35,520
of python

00:48:33,119 --> 00:48:36,319
edit it just to make use of the python

00:48:35,520 --> 00:48:38,960
package

00:48:36,319 --> 00:48:40,079
index here are some additional

00:48:38,960 --> 00:48:42,640
recordings

00:48:40,079 --> 00:48:43,440
um there's actually some demos that i've

00:48:42,640 --> 00:48:45,280
done some

00:48:43,440 --> 00:48:47,359
longer demos that i've done in the past

00:48:45,280 --> 00:48:49,280
that are also available on youtube so

00:48:47,359 --> 00:48:52,000
here's some additional material

00:48:49,280 --> 00:48:52,960
related to ydk you might find uh useful

00:48:52,000 --> 00:48:54,800
to you

00:48:52,960 --> 00:48:56,559
you can go and take a take a look at

00:48:54,800 --> 00:48:59,119
that

00:48:56,559 --> 00:49:00,160
and we have arrived at a destination

00:48:59,119 --> 00:49:02,559
really quick uh

00:49:00,160 --> 00:49:03,760
summary we talked at the very beginning

00:49:02,559 --> 00:49:05,599
and we saw how

00:49:03,760 --> 00:49:08,079
uh software automation is becoming

00:49:05,599 --> 00:49:08,400
critical uh for networks today to keep

00:49:08,079 --> 00:49:11,920
up

00:49:08,400 --> 00:49:15,200
with the speed and scale that is needed

00:49:11,920 --> 00:49:17,359
um we saw how

00:49:15,200 --> 00:49:19,359
networks are evolving to have a model

00:49:17,359 --> 00:49:21,359
driven programmability framework instead

00:49:19,359 --> 00:49:24,559
of the old legacy

00:49:21,359 --> 00:49:28,079
manageability framework that relied on

00:49:24,559 --> 00:49:30,640
cli syslog and snmp and

00:49:28,079 --> 00:49:31,119
we saw the details of how ydk provides

00:49:30,640 --> 00:49:33,760
an

00:49:31,119 --> 00:49:35,440
sdk to dramatically simplify the

00:49:33,760 --> 00:49:37,440
development of automation

00:49:35,440 --> 00:49:38,880
applications as long as the device

00:49:37,440 --> 00:49:42,240
supports

00:49:38,880 --> 00:49:45,119
yang data models the sdk provides

00:49:42,240 --> 00:49:46,640
strong abstractions for yang and its

00:49:45,119 --> 00:49:48,160
data models

00:49:46,640 --> 00:49:50,000
abstractions for the protocol and

00:49:48,160 --> 00:49:50,880
abstractions for the encoding and

00:49:50,000 --> 00:49:54,160
decoding

00:49:50,880 --> 00:49:57,359
uh functions needed to manipulate data

00:49:54,160 --> 00:50:00,000
you have built-in data validation

00:49:57,359 --> 00:50:02,000
and multi-language support uh packages

00:50:00,000 --> 00:50:03,520
in python go and see plus plus and it's

00:50:02,000 --> 00:50:06,240
completely open source

00:50:03,520 --> 00:50:07,920
and we do welcome uh contributions from

00:50:06,240 --> 00:50:08,960
other people so please get engaged in

00:50:07,920 --> 00:50:11,839
the community and

00:50:08,960 --> 00:50:12,640
if you have any suggestions issues or

00:50:11,839 --> 00:50:16,000
github

00:50:12,640 --> 00:50:18,079
welcome or or contributions also

00:50:16,000 --> 00:50:19,119
more than welcome everybody has

00:50:18,079 --> 00:50:21,280
questions again

00:50:19,119 --> 00:50:22,240
go to the community or you can reach me

00:50:21,280 --> 00:50:25,520
directly

00:50:22,240 --> 00:50:29,040
at uh one one one pontus

00:50:25,520 --> 00:50:31,920
on both twitter and github

00:50:29,040 --> 00:50:32,240
so thanks thanks for joining today and i

00:50:31,920 --> 00:50:34,880
hope

00:50:32,240 --> 00:50:36,480
this information was useful and hope to

00:50:34,880 --> 00:50:38,240
hear from you

00:50:36,480 --> 00:50:41,839
directly or through the community thank

00:50:38,240 --> 00:50:41,839

YouTube URL: https://www.youtube.com/watch?v=H6VlQA00I6k


