Title: Advanced Systemd for the Embedded Use-Case - Jeremy Rosen, Smile
Publication date: 2020-10-29
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Advanced Systemd for the Embedded Use-Case - Jeremy Rosen, Smile
Captions: 
	00:00:09,040 --> 00:00:12,639
hello everybody

00:00:10,320 --> 00:00:14,080
welcome to this session on advanced

00:00:12,639 --> 00:00:17,600
systemd for the

00:00:14,080 --> 00:00:18,960
embedded use case i've decided to do

00:00:17,600 --> 00:00:21,520
this presentation after

00:00:18,960 --> 00:00:22,800
discussing with various people at elc

00:00:21,520 --> 00:00:26,000
last year's about

00:00:22,800 --> 00:00:26,960
a systemd for the embedded use case and

00:00:26,000 --> 00:00:29,679
realizing that

00:00:26,960 --> 00:00:30,800
most of the people i know and who are

00:00:29,679 --> 00:00:34,079
more or less working

00:00:30,800 --> 00:00:38,879
in the embedded world don't

00:00:34,079 --> 00:00:43,040
know systemd enough to really use it

00:00:38,879 --> 00:00:46,640
at its best i mean systemd is a very

00:00:43,040 --> 00:00:48,879
advanced tool with lots of features and

00:00:46,640 --> 00:00:50,719
you pay a cost for this feat so for

00:00:48,879 --> 00:00:52,640
these features and it's really a shame

00:00:50,719 --> 00:00:55,120
not to use them because they really

00:00:52,640 --> 00:00:56,640
are useful in the embedded use case and

00:00:55,120 --> 00:00:59,760
will greatly

00:00:56,640 --> 00:01:00,399
simplify writing our code and in

00:00:59,760 --> 00:01:02,800
particular

00:01:00,399 --> 00:01:05,119
all the dedicated code that can't be

00:01:02,800 --> 00:01:08,080
reused between projects

00:01:05,119 --> 00:01:10,400
so just a little word about what i'm

00:01:08,080 --> 00:01:13,439
going to say in general

00:01:10,400 --> 00:01:15,600
because of obviously time constraints

00:01:13,439 --> 00:01:16,479
uh i will not this will not be a

00:01:15,600 --> 00:01:18,320
tutorial

00:01:16,479 --> 00:01:20,400
this will be more like a feature list i

00:01:18,320 --> 00:01:23,680
will just say all the things that

00:01:20,400 --> 00:01:24,880
systemd can do for you and uh if you

00:01:23,680 --> 00:01:27,280
really want to know

00:01:24,880 --> 00:01:29,200
how to do it we can have a talk after

00:01:27,280 --> 00:01:33,360
that or just go to the man pages

00:01:29,200 --> 00:01:36,400
cindy has a very good man pages um

00:01:33,360 --> 00:01:38,880
i'm from the embedded world but the

00:01:36,400 --> 00:01:40,479
embedded industrial world not mobile

00:01:38,880 --> 00:01:42,560
phones not um

00:01:40,479 --> 00:01:44,320
iot while i do a little bit of iot but

00:01:42,560 --> 00:01:47,280
that won't be the subject of this

00:01:44,320 --> 00:01:49,280
talk so that's a limit on the point of

00:01:47,280 --> 00:01:50,720
view i have and the kind of problem i

00:01:49,280 --> 00:01:52,799
solve

00:01:50,720 --> 00:01:54,079
and another thing to know is that i'm

00:01:52,799 --> 00:01:57,119
someone that knows

00:01:54,079 --> 00:01:57,920
systemd really well and actually i teach

00:01:57,119 --> 00:02:02,000
systemd

00:01:57,920 --> 00:02:04,159
uh professionally uh but i'm also

00:02:02,000 --> 00:02:06,159
an expert on projects on embedded

00:02:04,159 --> 00:02:08,640
projects that are using systemd

00:02:06,159 --> 00:02:11,039
so when i will say that the feature is

00:02:08,640 --> 00:02:14,000
easy to use it usually means that i

00:02:11,039 --> 00:02:14,720
end up explaining that feature to people

00:02:14,000 --> 00:02:16,640
and

00:02:14,720 --> 00:02:17,760
people get it right away and use it

00:02:16,640 --> 00:02:19,680
correctly and i

00:02:17,760 --> 00:02:22,000
never hear from them again when i say a

00:02:19,680 --> 00:02:25,120
feature is a bit harder to use

00:02:22,000 --> 00:02:27,040
it usually means that when i explain the

00:02:25,120 --> 00:02:27,280
thing people have a little a problem and

00:02:27,040 --> 00:02:29,440
i

00:02:27,280 --> 00:02:30,400
need to do a little intervention to get

00:02:29,440 --> 00:02:32,560
things working

00:02:30,400 --> 00:02:34,080
so some stuff are useful but a bit

00:02:32,560 --> 00:02:37,760
harder to use and some

00:02:34,080 --> 00:02:38,560
stuff are really easy i wanted to do

00:02:37,760 --> 00:02:41,599
some

00:02:38,560 --> 00:02:44,800
metrics and measures i've done a little

00:02:41,599 --> 00:02:47,599
through this presentation very few um

00:02:44,800 --> 00:02:49,440
just you see my system around there it's

00:02:47,599 --> 00:02:50,400
pretty simple it's a minimal build route

00:02:49,440 --> 00:02:53,120
with

00:02:50,400 --> 00:02:54,560
basically nothing in it no useful soft

00:02:53,120 --> 00:02:57,440
software started

00:02:54,560 --> 00:02:58,159
um i went from using system five to

00:02:57,440 --> 00:03:01,840
system d

00:02:58,159 --> 00:03:04,959
and the image grew from nine megs to 17

00:03:01,840 --> 00:03:06,239
meg so that's a back of the envelope

00:03:04,959 --> 00:03:09,599
metric of how much

00:03:06,239 --> 00:03:11,920
space systemd costs i wanted to measure

00:03:09,599 --> 00:03:13,680
boot times but it turned out not to be

00:03:11,920 --> 00:03:14,400
really significant because most of the

00:03:13,680 --> 00:03:16,879
boot time on

00:03:14,400 --> 00:03:18,959
such a simple system was dhcp and

00:03:16,879 --> 00:03:19,360
network time synchronization and nothing

00:03:18,959 --> 00:03:22,720
really

00:03:19,360 --> 00:03:26,239
relevant so there we go so

00:03:22,720 --> 00:03:28,799
um this talks will be in three short

00:03:26,239 --> 00:03:31,360
well three parts uh first part about

00:03:28,799 --> 00:03:33,519
what i call headline features which is

00:03:31,360 --> 00:03:35,599
things you probably know systemd can do

00:03:33,519 --> 00:03:36,480
for you but we'll go a little bit deeper

00:03:35,599 --> 00:03:39,120
into it to

00:03:36,480 --> 00:03:40,000
show how good it is for the embedded use

00:03:39,120 --> 00:03:42,799
case

00:03:40,000 --> 00:03:44,319
hidden gems are features that well

00:03:42,799 --> 00:03:47,599
unless you really know systemd

00:03:44,319 --> 00:03:50,239
you probably don't know and which can

00:03:47,599 --> 00:03:51,599
really really save you time and then

00:03:50,239 --> 00:03:53,519
i'll go around to

00:03:51,599 --> 00:03:54,959
discuss some features of systemd which

00:03:53,519 --> 00:03:57,599
are pretty useful

00:03:54,959 --> 00:03:58,640
but usually not for us not for the

00:03:57,599 --> 00:04:01,040
embedded people

00:03:58,640 --> 00:04:02,400
so i'll give a quick word about why they

00:04:01,040 --> 00:04:05,360
are here and why i

00:04:02,400 --> 00:04:09,760
usually disable disable them and if

00:04:05,360 --> 00:04:09,760
relevant why sometimes i use them anyway

00:04:09,920 --> 00:04:13,360
so the first thing is probably i think

00:04:12,799 --> 00:04:15,599
the most

00:04:13,360 --> 00:04:18,320
important thing with systemd is that

00:04:15,599 --> 00:04:21,519
when you start a daemon with systemd

00:04:18,320 --> 00:04:23,759
you have a very very uh fine

00:04:21,519 --> 00:04:26,639
grained and very easy to set up

00:04:23,759 --> 00:04:29,440
environment for your demon so

00:04:26,639 --> 00:04:30,000
when you start a process under a linux

00:04:29,440 --> 00:04:32,720
system

00:04:30,000 --> 00:04:34,080
there are all sorts of stuff you can set

00:04:32,720 --> 00:04:36,320
up for the process

00:04:34,080 --> 00:04:37,919
there are the ones everybody know about

00:04:36,320 --> 00:04:42,080
like environment

00:04:37,919 --> 00:04:44,960
variables what user what group to use

00:04:42,080 --> 00:04:45,680
uh some people will set up some uh

00:04:44,960 --> 00:04:47,040
limits with

00:04:45,680 --> 00:04:48,800
our limit and that sort of tools and

00:04:47,040 --> 00:04:50,880
that sort of stuff but there is

00:04:48,800 --> 00:04:52,720
actually way more you can set up and

00:04:50,880 --> 00:04:53,919
most of those of these things are

00:04:52,720 --> 00:04:57,280
considered

00:04:53,919 --> 00:05:00,160
advanced by most users hard to set up

00:04:57,280 --> 00:05:00,960
and usually are not set up at all with

00:05:00,160 --> 00:05:03,840
systemd

00:05:00,960 --> 00:05:04,400
those things are easy to do and that's

00:05:03,840 --> 00:05:07,600
the main

00:05:04,400 --> 00:05:09,360
point i mean if you want let's start by

00:05:07,600 --> 00:05:10,639
is the standard file descriptors if you

00:05:09,360 --> 00:05:12,960
have a system 5

00:05:10,639 --> 00:05:14,560
in its script where does the standard

00:05:12,960 --> 00:05:16,960
out and the standard error of your

00:05:14,560 --> 00:05:19,520
daemon go

00:05:16,960 --> 00:05:20,639
nobody knows if you're lucky it will go

00:05:19,520 --> 00:05:23,039
to devno

00:05:20,639 --> 00:05:24,000
most of the time it will go to whatever

00:05:23,039 --> 00:05:27,600
standard output

00:05:24,000 --> 00:05:30,080
is configured which will be the console

00:05:27,600 --> 00:05:31,440
some people some startup scripts are

00:05:30,080 --> 00:05:34,560
redirected to

00:05:31,440 --> 00:05:36,320
files which is not good either with

00:05:34,560 --> 00:05:39,600
systemd you just

00:05:36,320 --> 00:05:41,600
have one parameter which allows you to

00:05:39,600 --> 00:05:43,919
uh set up the most standard cases for

00:05:41,600 --> 00:05:48,160
this the standard file descriptors like

00:05:43,919 --> 00:05:50,880
put it in it to syslog uh putting it to

00:05:48,160 --> 00:05:52,880
the journal which is a default uh

00:05:50,880 --> 00:05:55,520
sending it to devnl

00:05:52,880 --> 00:05:57,360
for the input you can give a character

00:05:55,520 --> 00:05:59,440
string or some binary datas which will

00:05:57,360 --> 00:06:02,160
be fed to your program and so on and so

00:05:59,440 --> 00:06:04,319
forth so it's really easy to set up

00:06:02,160 --> 00:06:05,520
uh there are some more advanced things

00:06:04,319 --> 00:06:08,240
that most people

00:06:05,520 --> 00:06:10,000
don't know how to set up but systemd can

00:06:08,240 --> 00:06:12,560
set them up for you

00:06:10,000 --> 00:06:14,639
again easily so that would be stuff like

00:06:12,560 --> 00:06:17,199
linux capabilities so you can run your

00:06:14,639 --> 00:06:19,759
program as root with limited power

00:06:17,199 --> 00:06:21,120
syscall filtering which can forbid your

00:06:19,759 --> 00:06:24,160
daemon from doing some

00:06:21,120 --> 00:06:26,160
system calls um

00:06:24,160 --> 00:06:28,479
there is all sorts of setups with regard

00:06:26,160 --> 00:06:29,919
to what i call file system masking which

00:06:28,479 --> 00:06:32,880
is the

00:06:29,919 --> 00:06:33,520
allowing your daemon to only access some

00:06:32,880 --> 00:06:35,520
parts

00:06:33,520 --> 00:06:37,039
of the file system and that's not unix

00:06:35,520 --> 00:06:40,080
permissions that's actually

00:06:37,039 --> 00:06:42,319
using bind mounts and

00:06:40,080 --> 00:06:44,080
mount namespace spaces to limit what

00:06:42,319 --> 00:06:46,080
your uh demon can do

00:06:44,080 --> 00:06:47,520
and all sorts of advanced features like

00:06:46,080 --> 00:06:49,599
forbidding a daemon to

00:06:47,520 --> 00:06:51,680
load kernel modules through various

00:06:49,599 --> 00:06:54,960
layers of securities and stuff like that

00:06:51,680 --> 00:06:56,800
so all these things are

00:06:54,960 --> 00:06:58,639
are things that are easy to set up with

00:06:56,800 --> 00:07:01,199
systemd and can be checked

00:06:58,639 --> 00:07:01,680
globally with systemd systemd has a very

00:07:01,199 --> 00:07:04,479
good

00:07:01,680 --> 00:07:06,400
security analysis tool which will take

00:07:04,479 --> 00:07:08,000
all the daemons on your well all the

00:07:06,400 --> 00:07:10,960
services to use the correct term

00:07:08,000 --> 00:07:12,080
on your system and we'll check for with

00:07:10,960 --> 00:07:15,120
every one of them

00:07:12,080 --> 00:07:17,680
uh what security feature are enabled and

00:07:15,120 --> 00:07:20,479
what security feature are disabled so

00:07:17,680 --> 00:07:21,360
doing an audit is easy and something you

00:07:20,479 --> 00:07:23,280
can do and that's

00:07:21,360 --> 00:07:25,680
the main point you can really control

00:07:23,280 --> 00:07:28,720
you can really

00:07:25,680 --> 00:07:31,120
do a jail for your daemon and you can

00:07:28,720 --> 00:07:32,160
do it easily through very very simple

00:07:31,120 --> 00:07:34,639
configuration

00:07:32,160 --> 00:07:35,360
some of this stuff is really tricky to

00:07:34,639 --> 00:07:38,240
do

00:07:35,360 --> 00:07:40,240
so we're talking a little bit about

00:07:38,240 --> 00:07:43,680
security so this is not a security talk

00:07:40,240 --> 00:07:46,879
but it's important to understand

00:07:43,680 --> 00:07:50,639
where uh systemd fits in

00:07:46,879 --> 00:07:53,120
the security model so

00:07:50,639 --> 00:07:55,360
when you're securing a daemon you have

00:07:53,120 --> 00:07:57,840
two

00:07:55,360 --> 00:08:00,080
layers of security and both of which are

00:07:57,840 --> 00:08:02,400
very important but totally different so

00:08:00,080 --> 00:08:03,360
the first layer is your daemon itself

00:08:02,400 --> 00:08:07,599
the daemon

00:08:03,360 --> 00:08:10,080
must validate its input it must

00:08:07,599 --> 00:08:12,080
work correctly and in general nobody

00:08:10,080 --> 00:08:15,360
should be able to use it to do

00:08:12,080 --> 00:08:18,240
things that it is allowed to do but

00:08:15,360 --> 00:08:19,840
should not do an example would be a

00:08:18,240 --> 00:08:23,039
database a database

00:08:19,840 --> 00:08:24,080
is allowed to erase all data but it

00:08:23,039 --> 00:08:26,879
shouldn't do it

00:08:24,080 --> 00:08:27,360
so that's writing a correct application

00:08:26,879 --> 00:08:29,919
that's

00:08:27,360 --> 00:08:30,800
not where system d acts in terms of

00:08:29,919 --> 00:08:33,279
security

00:08:30,800 --> 00:08:35,039
system d uh acts at the second layer

00:08:33,279 --> 00:08:37,120
it's more the idea that

00:08:35,039 --> 00:08:38,560
your daemon has been corrupted there is

00:08:37,120 --> 00:08:41,519
a malevolence somewhere

00:08:38,560 --> 00:08:42,479
that two complete control of it systemd

00:08:41,519 --> 00:08:45,600
is here

00:08:42,479 --> 00:08:47,040
to make sure that it cannot do more than

00:08:45,600 --> 00:08:50,560
what the daemon is

00:08:47,040 --> 00:08:53,279
theoretically uh allowed to do

00:08:50,560 --> 00:08:54,320
so how does it do it it configures the

00:08:53,279 --> 00:08:57,680
kernel

00:08:54,320 --> 00:08:59,839
it does not do any security check itself

00:08:57,680 --> 00:09:00,880
it just configure all the security

00:08:59,839 --> 00:09:04,480
mechanism

00:09:00,880 --> 00:09:07,040
of the kernel and those mechanisms

00:09:04,480 --> 00:09:08,320
are extremely powerful but most of them

00:09:07,040 --> 00:09:12,000
are hard

00:09:08,320 --> 00:09:15,040
to uh to set up i mean if anybody has

00:09:12,000 --> 00:09:16,240
read the man page for namespaces or for

00:09:15,040 --> 00:09:19,600
capabilities

00:09:16,240 --> 00:09:21,040
those are extremely hard to understand

00:09:19,600 --> 00:09:22,720
i mean take some time once you've

00:09:21,040 --> 00:09:24,720
wrapped your head around it you can

00:09:22,720 --> 00:09:25,839
figure out how it's going on but it's

00:09:24,720 --> 00:09:27,920
really really hard

00:09:25,839 --> 00:09:29,760
with systemd using those mechanism is

00:09:27,920 --> 00:09:32,480
really easy

00:09:29,760 --> 00:09:34,240
some very high level constraints are

00:09:32,480 --> 00:09:36,240
trivial to do you want your demon

00:09:34,240 --> 00:09:38,160
to have a really only view on the whole

00:09:36,240 --> 00:09:38,560
file system you just tell systemd to do

00:09:38,160 --> 00:09:41,760
so

00:09:38,560 --> 00:09:42,560
so and it will be done uh you want your

00:09:41,760 --> 00:09:45,200
demon to

00:09:42,560 --> 00:09:45,600
uh be run with the no new privilege flag

00:09:45,200 --> 00:09:48,800
it's

00:09:45,600 --> 00:09:52,320
one line and systemd systemd is

00:09:48,800 --> 00:09:54,720
helping with security not because it's a

00:09:52,320 --> 00:09:56,560
foolproof very well coded well i think

00:09:54,720 --> 00:09:57,200
it is but that's not the main point the

00:09:56,560 --> 00:10:00,160
main point

00:09:57,200 --> 00:10:00,640
is all those security features are

00:10:00,160 --> 00:10:04,079
really

00:10:00,640 --> 00:10:07,279
easy to set up and that's a huge

00:10:04,079 --> 00:10:10,959
gain so

00:10:07,279 --> 00:10:14,480
that was your daemon you configure it

00:10:10,959 --> 00:10:17,680
you start it and you control everything

00:10:14,480 --> 00:10:20,399
uh in its environment so you can uh

00:10:17,680 --> 00:10:21,839
secure it and jail it and have it well

00:10:20,399 --> 00:10:25,279
controlled

00:10:21,839 --> 00:10:26,399
now the other aspect where systemd is

00:10:25,279 --> 00:10:29,120
really important it's

00:10:26,399 --> 00:10:31,360
is all the synchronization things and

00:10:29,120 --> 00:10:32,959
starting the demons in the right order

00:10:31,360 --> 00:10:34,480
and having a startup logic and

00:10:32,959 --> 00:10:36,800
restarting demons

00:10:34,480 --> 00:10:38,800
this part is a bit tricky that's a part

00:10:36,800 --> 00:10:41,920
where i usually have to come back and

00:10:38,800 --> 00:10:45,120
give a few tips after the fact but

00:10:41,920 --> 00:10:48,079
overall once you get it working when you

00:10:45,120 --> 00:10:50,079
once you've understand the actual logic

00:10:48,079 --> 00:10:52,560
it's extremely powerful

00:10:50,079 --> 00:10:53,600
when you have bugs bugs tend to be easy

00:10:52,560 --> 00:10:57,120
to reproduce

00:10:53,600 --> 00:11:00,000
and so easy to debug and when you have

00:10:57,120 --> 00:11:01,040
uh complex use cases for restarting

00:11:00,000 --> 00:11:05,519
daemons

00:11:01,040 --> 00:11:05,519
that's where systemd really shines

00:11:06,399 --> 00:11:10,480
it's when when you're in an embedded

00:11:09,040 --> 00:11:13,680
system your system

00:11:10,480 --> 00:11:16,720
needs to take care of itself there is

00:11:13,680 --> 00:11:19,440
no admin there is no uh

00:11:16,720 --> 00:11:20,880
crashed instances that are replaced by

00:11:19,440 --> 00:11:23,440
other instances

00:11:20,880 --> 00:11:25,440
your your system is on its own it has to

00:11:23,440 --> 00:11:27,040
detect when things go wrong it has to

00:11:25,440 --> 00:11:29,120
deal with things going wrong

00:11:27,040 --> 00:11:30,480
on its own and that's where systemd

00:11:29,120 --> 00:11:33,120
really helps you because

00:11:30,480 --> 00:11:34,079
this whole logic of robustness of not

00:11:33,120 --> 00:11:37,519
crashing or

00:11:34,079 --> 00:11:40,640
or or of restarting automatically

00:11:37,519 --> 00:11:42,720
when thing crashes this whole logic you

00:11:40,640 --> 00:11:43,839
don't have to write it you don't have to

00:11:42,720 --> 00:11:46,079
write a single

00:11:43,839 --> 00:11:47,200
line of code in your demon well you have

00:11:46,079 --> 00:11:49,200
to write

00:11:47,200 --> 00:11:50,480
one line the one to tell the watchdog

00:11:49,200 --> 00:11:53,680
you're still alive

00:11:50,480 --> 00:11:54,560
so everything else systemd can do for

00:11:53,680 --> 00:11:57,600
you

00:11:54,560 --> 00:12:00,720
first it has a very robust startup logic

00:11:57,600 --> 00:12:03,279
it's a logic that has been uh

00:12:00,720 --> 00:12:05,440
written to deal with all the various

00:12:03,279 --> 00:12:07,920
logics that the

00:12:05,440 --> 00:12:10,160
unix demons have had throughout time

00:12:07,920 --> 00:12:13,760
stuff like privileged dropping

00:12:10,160 --> 00:12:17,200
uh like uh demons that fork or

00:12:13,760 --> 00:12:19,600
not don't fork all that sort of stuff is

00:12:17,200 --> 00:12:21,600
something systemd is used to deal with

00:12:19,600 --> 00:12:23,360
and everything is protected with time

00:12:21,600 --> 00:12:24,079
out so you will never have a daemon

00:12:23,360 --> 00:12:26,560
which will be

00:12:24,079 --> 00:12:28,160
completely stuck because systemd is

00:12:26,560 --> 00:12:30,800
watching it

00:12:28,160 --> 00:12:31,680
it has some great system for readiness

00:12:30,800 --> 00:12:34,079
detection so

00:12:31,680 --> 00:12:36,079
what is readiness detection the idea is

00:12:34,079 --> 00:12:38,160
when you start your daemon

00:12:36,079 --> 00:12:39,120
the moment you start the process is not

00:12:38,160 --> 00:12:42,560
the moment when

00:12:39,120 --> 00:12:46,480
the demon is ready to work

00:12:42,560 --> 00:12:49,120
it needs some time to prepare so

00:12:46,480 --> 00:12:50,320
you want your demon's dependency to

00:12:49,120 --> 00:12:53,519
start

00:12:50,320 --> 00:12:57,440
a bit later okay so systemd

00:12:53,519 --> 00:13:00,720
has various ways to uh

00:12:57,440 --> 00:13:02,959
to detect readiness but the most

00:13:00,720 --> 00:13:04,959
useful one especially when you write

00:13:02,959 --> 00:13:06,160
your own demon so you know you will be

00:13:04,959 --> 00:13:09,279
using systemd

00:13:06,160 --> 00:13:12,560
is to just tell systemd so you have

00:13:09,279 --> 00:13:14,000
one call in the systemd api one function

00:13:12,560 --> 00:13:16,240
you call it and that will

00:13:14,000 --> 00:13:17,120
tell systemd you're ready and systemd

00:13:16,240 --> 00:13:20,399
will synchronize

00:13:17,120 --> 00:13:23,200
any dependencies on that signal so it's

00:13:20,399 --> 00:13:26,079
one line of c code or whatever binding

00:13:23,200 --> 00:13:28,560
you like to use in your native language

00:13:26,079 --> 00:13:30,959
to get it working it's pretty easy you

00:13:28,560 --> 00:13:33,680
can easily ask systemd to run

00:13:30,959 --> 00:13:35,200
scripts before your daemon and since the

00:13:33,680 --> 00:13:37,680
pre-start scripts are

00:13:35,200 --> 00:13:39,680
part of the service you are guaranteed

00:13:37,680 --> 00:13:40,880
that they will always be run correctly

00:13:39,680 --> 00:13:43,600
you can also have

00:13:40,880 --> 00:13:45,360
post start demons so those scripts post

00:13:43,600 --> 00:13:48,000
start scripts

00:13:45,360 --> 00:13:48,959
those are scripts that will be run by

00:13:48,000 --> 00:13:51,519
systemd

00:13:48,959 --> 00:13:53,920
after your demon has said it is ready

00:13:51,519 --> 00:13:54,639
but before dependencies are started so

00:13:53,920 --> 00:13:56,399
that's

00:13:54,639 --> 00:13:57,839
really handy when you have some cleanups

00:13:56,399 --> 00:13:59,519
and boy you i

00:13:57,839 --> 00:14:01,760
i don't know about you but in the

00:13:59,519 --> 00:14:02,160
embedded world we have some very badly

00:14:01,760 --> 00:14:05,040
written

00:14:02,160 --> 00:14:07,360
demons so having this sort of tools is

00:14:05,040 --> 00:14:12,800
really awesome

00:14:07,360 --> 00:14:16,000
um watchdogs systemd provides you with a

00:14:12,800 --> 00:14:19,920
software watchdog so systemd itself

00:14:16,000 --> 00:14:22,639
will uh feed the hardware watchdog

00:14:19,920 --> 00:14:24,320
so uh if the kernel crashes the hardware

00:14:22,639 --> 00:14:27,360
watchdog will not be fed

00:14:24,320 --> 00:14:28,560
if systemd crashes the hardware watchdog

00:14:27,360 --> 00:14:31,760
will not be fed

00:14:28,560 --> 00:14:33,760
and then systemd itself provide

00:14:31,760 --> 00:14:35,440
uh software watchdogs for any

00:14:33,760 --> 00:14:38,560
application that needs it so

00:14:35,440 --> 00:14:40,800
if your daemon is um

00:14:38,560 --> 00:14:42,639
is coded for systemd you have one line

00:14:40,800 --> 00:14:45,279
of code you have to add

00:14:42,639 --> 00:14:47,279
in your main loop and that's it and your

00:14:45,279 --> 00:14:49,199
watchdog will be working and systemd

00:14:47,279 --> 00:14:51,920
will monitor your application

00:14:49,199 --> 00:14:53,440
and if your application does not uh feed

00:14:51,920 --> 00:14:56,560
its watchdog in time

00:14:53,440 --> 00:14:59,760
systemd will stop it and restart it

00:14:56,560 --> 00:15:01,440
in a very well defined way again with

00:14:59,760 --> 00:15:03,839
all the timing out you want if you

00:15:01,440 --> 00:15:06,000
wanted to restart

00:15:03,839 --> 00:15:07,120
the whole machine you can do that too

00:15:06,000 --> 00:15:12,880
and

00:15:07,120 --> 00:15:17,040
the whole logic is here and ready to go

00:15:12,880 --> 00:15:20,320
you can uh configure a restart

00:15:17,040 --> 00:15:22,720
very precisely including uh

00:15:20,320 --> 00:15:23,920
grace periods if you need and burst

00:15:22,720 --> 00:15:26,480
protection so

00:15:23,920 --> 00:15:28,160
uh restarts uh so grace period is

00:15:26,480 --> 00:15:31,519
basically you tell systemd

00:15:28,160 --> 00:15:34,399
i want my demon to uh wait

00:15:31,519 --> 00:15:36,399
a couple of seconds before being

00:15:34,399 --> 00:15:37,600
restarted and systemd will guarantee you

00:15:36,399 --> 00:15:40,240
you have that couple of

00:15:37,600 --> 00:15:42,000
seconds that's pretty good when you have

00:15:40,240 --> 00:15:42,880
some hardwares that need some time to

00:15:42,000 --> 00:15:44,880
restart

00:15:42,880 --> 00:15:46,800
but you cannot detect it and burst

00:15:44,880 --> 00:15:48,959
protection is basically the idea of

00:15:46,800 --> 00:15:52,399
saying to systemd i want this demon to

00:15:48,959 --> 00:15:53,440
be restarted as soon as possible but if

00:15:52,399 --> 00:15:56,560
it restarts

00:15:53,440 --> 00:16:00,560
more than 10 times in a 5-minute window

00:15:56,560 --> 00:16:02,959
just kill it so the whole thing

00:16:00,560 --> 00:16:05,600
is a little tricky to understand as i

00:16:02,959 --> 00:16:07,920
said you have to understand the whole

00:16:05,600 --> 00:16:09,519
mechanism but once you get it going you

00:16:07,920 --> 00:16:12,399
have a very

00:16:09,519 --> 00:16:13,040
well-defined dependency system ordering

00:16:12,399 --> 00:16:16,399
system

00:16:13,040 --> 00:16:19,360
you can have a very uh precise control

00:16:16,399 --> 00:16:21,360
of how when and in what order your

00:16:19,360 --> 00:16:25,040
various demons are started

00:16:21,360 --> 00:16:28,720
and again it's really good

00:16:25,040 --> 00:16:29,440
to uh not just having a faster boot

00:16:28,720 --> 00:16:33,040
we'll just

00:16:29,440 --> 00:16:36,399
discuss boot time a little bit later

00:16:33,040 --> 00:16:39,680
but really unlike uh system five

00:16:36,399 --> 00:16:43,360
you have a real understanding on

00:16:39,680 --> 00:16:43,759
on what's going on and it's really easy

00:16:43,360 --> 00:16:47,360
to

00:16:43,759 --> 00:16:47,759
get it bulletproof as in your system

00:16:47,360 --> 00:16:51,199
will

00:16:47,759 --> 00:16:53,759
never be stuck i mean it might reboot it

00:16:51,199 --> 00:16:55,519
might restart demons but

00:16:53,759 --> 00:16:57,600
you have someone who's actually

00:16:55,519 --> 00:17:00,320
monitoring everything making things

00:16:57,600 --> 00:17:01,519
just work as a as a need and has very

00:17:00,320 --> 00:17:05,280
precise instructions

00:17:01,519 --> 00:17:06,079
what to do in every case so not only is

00:17:05,280 --> 00:17:08,160
your demon

00:17:06,079 --> 00:17:10,000
really easier to write because you don't

00:17:08,160 --> 00:17:11,760
need to do the cleanup yourself you

00:17:10,000 --> 00:17:13,919
don't need to drop privileges

00:17:11,760 --> 00:17:15,520
yourself you don't even need to fork

00:17:13,919 --> 00:17:18,079
yourself anymore

00:17:15,520 --> 00:17:20,240
but the whole thing is configurable

00:17:18,079 --> 00:17:21,760
rebel by the sysadmin if you need to

00:17:20,240 --> 00:17:27,199
tweak it

00:17:21,760 --> 00:17:27,199
and it's overall working really well

00:17:27,280 --> 00:17:32,000
so even if his systemd is first and

00:17:30,880 --> 00:17:34,880
foremost a system

00:17:32,000 --> 00:17:36,480
to monitor your demons it's in charge of

00:17:34,880 --> 00:17:39,679
boots so

00:17:36,480 --> 00:17:41,280
in that regard systemd has a few not

00:17:39,679 --> 00:17:42,080
well known features that are really

00:17:41,280 --> 00:17:44,799
great for us

00:17:42,080 --> 00:17:46,720
embedded people so the first one and

00:17:44,799 --> 00:17:49,440
probably one and the most important one

00:17:46,720 --> 00:17:50,160
is boot blessing so that's a rather new

00:17:49,440 --> 00:17:51,840
feature

00:17:50,160 --> 00:17:53,440
but basically there is a point in

00:17:51,840 --> 00:17:57,039
systemd where

00:17:53,440 --> 00:18:00,160
uh we decide if a boot is successful

00:17:57,039 --> 00:18:02,400
or not and what's really great is that

00:18:00,160 --> 00:18:05,120
this is a neutral point which is in this

00:18:02,400 --> 00:18:07,440
independent of hardware indeed

00:18:05,120 --> 00:18:10,480
independent of the distro you're using

00:18:07,440 --> 00:18:11,360
and then independent of the of the over

00:18:10,480 --> 00:18:14,240
the air

00:18:11,360 --> 00:18:14,559
upgrade system you're using so you can

00:18:14,240 --> 00:18:17,440
add

00:18:14,559 --> 00:18:18,240
any test you you want before that point

00:18:17,440 --> 00:18:21,280
which will

00:18:18,240 --> 00:18:23,280
uh influence boot blessing

00:18:21,280 --> 00:18:25,440
in the neutral ways that can be reused

00:18:23,280 --> 00:18:27,200
from product to product without anything

00:18:25,440 --> 00:18:29,120
specific to any hardware

00:18:27,200 --> 00:18:30,960
and on the other hand you can also add

00:18:29,120 --> 00:18:34,000
script after that points that are

00:18:30,960 --> 00:18:36,000
specific to your bootloader your um

00:18:34,000 --> 00:18:38,240
over the air system and it will take

00:18:36,000 --> 00:18:40,320
into account any script

00:18:38,240 --> 00:18:41,679
that comes before the boot blessing

00:18:40,320 --> 00:18:44,080
which are again

00:18:41,679 --> 00:18:45,360
neutral so it's it's very good because

00:18:44,080 --> 00:18:48,080
you can do those

00:18:45,360 --> 00:18:49,200
tricky but blessing things in a neutral

00:18:48,080 --> 00:18:52,240
way

00:18:49,200 --> 00:18:55,200
um so when system d

00:18:52,240 --> 00:18:57,200
boot it has a boot target so without

00:18:55,200 --> 00:18:59,440
going very far into detail it's

00:18:57,200 --> 00:19:02,880
basically the same thing as a run level

00:18:59,440 --> 00:19:04,960
okay um systemd has those uh

00:19:02,880 --> 00:19:06,559
boot targets and you can have multiple

00:19:04,960 --> 00:19:08,880
boot targets and that's really

00:19:06,559 --> 00:19:09,600
handy because in the embedded world it's

00:19:08,880 --> 00:19:12,880
very common

00:19:09,600 --> 00:19:15,360
that we want to boot in different ways

00:19:12,880 --> 00:19:17,360
depending on various criteria the most

00:19:15,360 --> 00:19:19,760
common being

00:19:17,360 --> 00:19:21,360
projection boot versus development

00:19:19,760 --> 00:19:24,559
versus factory test

00:19:21,360 --> 00:19:26,880
and so on and so forth not only

00:19:24,559 --> 00:19:27,919
can you have multiple boots but systemd

00:19:26,880 --> 00:19:30,400
has this

00:19:27,919 --> 00:19:31,360
control called system control isolate

00:19:30,400 --> 00:19:35,200
which allow

00:19:31,360 --> 00:19:39,039
you to switch mode on a live system

00:19:35,200 --> 00:19:42,080
including uh stuff like black listing

00:19:39,039 --> 00:19:45,520
blacklisting some services uh

00:19:42,080 --> 00:19:47,679
to avoid them um being uh

00:19:45,520 --> 00:19:49,280
being killed when you change uh mode if

00:19:47,679 --> 00:19:50,400
you have i don't know a watchdog or

00:19:49,280 --> 00:19:52,480
something like that

00:19:50,400 --> 00:19:53,840
so the whole thing is pretty handy and

00:19:52,480 --> 00:19:55,679
pretty um

00:19:53,840 --> 00:19:57,120
versatile so you can use it in any way

00:19:55,679 --> 00:19:59,600
you want uh

00:19:57,120 --> 00:20:01,840
one of the very good thing uh with

00:19:59,600 --> 00:20:04,400
systemday is you have some very precise

00:20:01,840 --> 00:20:07,039
boot time analysis tool

00:20:04,400 --> 00:20:08,159
which know how system you start things

00:20:07,039 --> 00:20:11,200
and will take

00:20:08,159 --> 00:20:13,440
uh parallel startups into account and

00:20:11,200 --> 00:20:17,440
tell you really what you're

00:20:13,440 --> 00:20:19,440
looking for so um reducing boot time

00:20:17,440 --> 00:20:20,480
is a very very common problem in the

00:20:19,440 --> 00:20:23,760
embedded world

00:20:20,480 --> 00:20:25,679
and we usually do a lot of guessing in

00:20:23,760 --> 00:20:27,679
this area

00:20:25,679 --> 00:20:29,360
with systemd no more guessing you have a

00:20:27,679 --> 00:20:31,280
real tool which will tell you what

00:20:29,360 --> 00:20:33,679
demons you've been waiting for

00:20:31,280 --> 00:20:36,000
and what demons have been long to start

00:20:33,679 --> 00:20:37,679
but you have not actually been waiting

00:20:36,000 --> 00:20:39,280
for them so you're perfectly fine and

00:20:37,679 --> 00:20:40,880
you don't need to optimize those

00:20:39,280 --> 00:20:42,320
and usually the first time you use those

00:20:40,880 --> 00:20:43,600
tools you have some surprise because

00:20:42,320 --> 00:20:46,799
time is not spent when

00:20:43,600 --> 00:20:47,600
where you think it is last thing i

00:20:46,799 --> 00:20:50,240
really like is

00:20:47,600 --> 00:20:51,919
generators so generators are small

00:20:50,240 --> 00:20:54,960
binaries runnables

00:20:51,919 --> 00:20:58,159
that systemd will execute

00:20:54,960 --> 00:21:01,520
very early in the boot process and their

00:20:58,159 --> 00:21:02,640
job is to generate new configuration

00:21:01,520 --> 00:21:05,840
files for system

00:21:02,640 --> 00:21:07,360
new units so that's pretty handy for us

00:21:05,840 --> 00:21:09,600
in the embedded world because

00:21:07,360 --> 00:21:11,679
a very common thing we're asked to do is

00:21:09,600 --> 00:21:12,960
to have one hardware and multiple

00:21:11,679 --> 00:21:15,919
products

00:21:12,960 --> 00:21:17,200
and to detect on what product we are and

00:21:15,919 --> 00:21:19,840
boot differently

00:21:17,200 --> 00:21:21,520
or multiple hardware with one image

00:21:19,840 --> 00:21:24,559
because they have the same cpu and we

00:21:21,520 --> 00:21:26,799
need to detect what image we're on and

00:21:24,559 --> 00:21:28,480
boot differently so we usually do that

00:21:26,799 --> 00:21:31,679
using cpu ids

00:21:28,480 --> 00:21:32,000
or some hardwired gpios who tell us what

00:21:31,679 --> 00:21:34,799
we

00:21:32,000 --> 00:21:36,400
are uh generators are typically well

00:21:34,799 --> 00:21:39,600
i've used them a couple of

00:21:36,400 --> 00:21:42,880
times to read gpio

00:21:39,600 --> 00:21:43,440
and decide what services needed to be

00:21:42,880 --> 00:21:46,960
started

00:21:43,440 --> 00:21:49,200
are to choose a boot target okay

00:21:46,960 --> 00:21:50,960
once i had also a customer that wanted

00:21:49,200 --> 00:21:51,520
everything to be configured with a

00:21:50,960 --> 00:21:54,000
single

00:21:51,520 --> 00:21:55,840
xml file and that included starting

00:21:54,000 --> 00:21:58,080
multiple services in different ways so i

00:21:55,840 --> 00:22:01,679
had to write an xml parser that would

00:21:58,080 --> 00:22:05,120
generate a systemd configuration file so

00:22:01,679 --> 00:22:07,120
writing uh dealing with a xml was hard

00:22:05,120 --> 00:22:12,400
but actually getting systemd to do what

00:22:07,120 --> 00:22:15,440
i wanted was easy small

00:22:12,400 --> 00:22:18,240
um side comment

00:22:15,440 --> 00:22:20,799
about systemd and why it boots faster so

00:22:18,240 --> 00:22:21,520
i was not able to get relevant boot

00:22:20,799 --> 00:22:23,200
times but

00:22:21,520 --> 00:22:24,799
most people agree nowadays that

00:22:23,200 --> 00:22:28,159
assistanty actually

00:22:24,799 --> 00:22:31,280
gain you boot time but

00:22:28,159 --> 00:22:33,120
the question of why is rarely

00:22:31,280 --> 00:22:34,559
answered or at least not answered

00:22:33,120 --> 00:22:36,880
correctly so

00:22:34,559 --> 00:22:38,559
the first reason is parallelization so

00:22:36,880 --> 00:22:42,159
that's a well-known reason

00:22:38,559 --> 00:22:43,360
systemd starts uh old demons that can be

00:22:42,159 --> 00:22:45,640
started in parallel

00:22:43,360 --> 00:22:47,200
it all those demons will be started

00:22:45,640 --> 00:22:49,360
simultaneously

00:22:47,200 --> 00:22:50,640
so that's really good at saturating both

00:22:49,360 --> 00:22:54,000
cpu and

00:22:50,640 --> 00:22:57,280
disks uh to the point that uh systemd

00:22:54,000 --> 00:22:59,679
used to have read ahead to preload uh

00:22:57,280 --> 00:23:00,799
pages in memory and they've dropped this

00:22:59,679 --> 00:23:04,960
because the

00:23:00,799 --> 00:23:05,919
disk the io bus was saturated anyway so

00:23:04,960 --> 00:23:09,360
you didn't

00:23:05,919 --> 00:23:12,640
gain any time by doing that um

00:23:09,360 --> 00:23:15,520
so that's the first and most well-known

00:23:12,640 --> 00:23:16,240
boot boot time optimization in systemd

00:23:15,520 --> 00:23:18,240
second one

00:23:16,240 --> 00:23:19,440
is socket-based dependencies which

00:23:18,240 --> 00:23:21,520
basically means that

00:23:19,440 --> 00:23:22,960
if you have a daemon that writes in a

00:23:21,520 --> 00:23:25,360
socket the socket

00:23:22,960 --> 00:23:27,200
needs to be created before the demon uh

00:23:25,360 --> 00:23:30,240
can be started

00:23:27,200 --> 00:23:31,280
however if another demon reads that

00:23:30,240 --> 00:23:33,840
socket it does

00:23:31,280 --> 00:23:34,799
the reader does not need to be started

00:23:33,840 --> 00:23:37,360
right away

00:23:34,799 --> 00:23:39,120
and systemd deals with that that that

00:23:37,360 --> 00:23:39,520
means systemd can create the socket for

00:23:39,120 --> 00:23:42,080
you

00:23:39,520 --> 00:23:43,279
and start both the writer and the reader

00:23:42,080 --> 00:23:45,840
at the same time

00:23:43,279 --> 00:23:47,039
and use the socket as a sort of cache

00:23:45,840 --> 00:23:49,360
between the two to allow

00:23:47,039 --> 00:23:51,360
allows those to start in parallel that's

00:23:49,360 --> 00:23:54,080
particularly useful

00:23:51,360 --> 00:23:55,039
with syslog and or journal d because

00:23:54,080 --> 00:23:57,520
those uh

00:23:55,039 --> 00:24:00,320
do not block all demons that need to

00:23:57,520 --> 00:24:03,440
write to the syslog

00:24:00,320 --> 00:24:07,200
systemd has a very

00:24:03,440 --> 00:24:09,120
robust uh on demand the

00:24:07,200 --> 00:24:11,360
uh startup system which means that

00:24:09,120 --> 00:24:13,840
demons will be started only

00:24:11,360 --> 00:24:15,520
when they are needed and that includes

00:24:13,840 --> 00:24:18,000
not starting demons

00:24:15,520 --> 00:24:19,600
that are irrelevant for your particular

00:24:18,000 --> 00:24:22,559
hardware so

00:24:19,600 --> 00:24:24,480
i don't know if you remember booting on

00:24:22,559 --> 00:24:26,960
all the ubuntu like uh

00:24:24,480 --> 00:24:29,039
five to ten years ago but you would have

00:24:26,960 --> 00:24:30,960
cups be started you would have sane be

00:24:29,039 --> 00:24:32,000
started and they would be started even

00:24:30,960 --> 00:24:35,440
if you did not have

00:24:32,000 --> 00:24:37,120
printer or a scanner those days i don't

00:24:35,440 --> 00:24:37,919
know if anybody noticed but those days

00:24:37,120 --> 00:24:41,840
are gone

00:24:37,919 --> 00:24:44,159
even on uh rich desktop distributions

00:24:41,840 --> 00:24:46,000
a scene is not started anymore why

00:24:44,159 --> 00:24:47,760
because systemd waits to see if there is

00:24:46,000 --> 00:24:48,480
a scanner before deciding to start the

00:24:47,760 --> 00:24:51,600
demon

00:24:48,480 --> 00:24:53,840
so as a consequence you have much less

00:24:51,600 --> 00:24:57,520
demons that are started at boot because

00:24:53,840 --> 00:25:01,039
useless demons are not started

00:24:57,520 --> 00:25:03,440
and last um

00:25:01,039 --> 00:25:04,720
when you're starting uh when your init

00:25:03,440 --> 00:25:07,679
system is based on

00:25:04,720 --> 00:25:08,400
shell scripts you start a lot of shells

00:25:07,679 --> 00:25:10,880
you

00:25:08,400 --> 00:25:13,039
start a lot of sub shells and you start

00:25:10,880 --> 00:25:14,159
a lot of commands i mean whenever you

00:25:13,039 --> 00:25:17,360
want to change

00:25:14,159 --> 00:25:20,720
permission on a fl on a file or uh

00:25:17,360 --> 00:25:23,760
when you want to change user you have to

00:25:20,720 --> 00:25:26,880
launch a command and it

00:25:23,760 --> 00:25:30,240
starting a process on linux is well

00:25:26,880 --> 00:25:32,880
fast but it still has a cost and systemd

00:25:30,240 --> 00:25:33,679
does all this setup for your daemon the

00:25:32,880 --> 00:25:36,320
environment

00:25:33,679 --> 00:25:38,080
i've mentioned in my first slide it does

00:25:36,320 --> 00:25:40,880
all this

00:25:38,080 --> 00:25:42,880
by calling directly the system calls and

00:25:40,880 --> 00:25:45,440
not by starting processes that are

00:25:42,880 --> 00:25:47,679
just started to start a system call and

00:25:45,440 --> 00:25:50,960
the number of processes started

00:25:47,679 --> 00:25:52,960
is significantly less on systemd on my

00:25:50,960 --> 00:25:55,679
minimal system with

00:25:52,960 --> 00:25:57,120
nothing on it that just started a shell

00:25:55,679 --> 00:25:59,600
i had

00:25:57,120 --> 00:26:01,919
the pid of the first shell after startup

00:25:59,600 --> 00:26:05,760
which was 72 with systemd

00:26:01,919 --> 00:26:08,960
and 155 with a system 5 in its script

00:26:05,760 --> 00:26:09,440
and again nothing was started it was

00:26:08,960 --> 00:26:12,960
just

00:26:09,440 --> 00:26:16,159
starting though shell so

00:26:12,960 --> 00:26:19,520
that's why i i think that

00:26:16,159 --> 00:26:22,840
systemd will

00:26:19,520 --> 00:26:26,080
is faster at startup so those

00:26:22,840 --> 00:26:29,520
are uh mainline

00:26:26,080 --> 00:26:32,799
features of systemd but features that

00:26:29,520 --> 00:26:34,320
are really um useful for us in the

00:26:32,799 --> 00:26:35,120
embedded world and i would say

00:26:34,320 --> 00:26:37,520
especially

00:26:35,120 --> 00:26:39,520
for us in the embedded world i'm going

00:26:37,520 --> 00:26:41,919
now to move on to some features that

00:26:39,520 --> 00:26:43,039
most people probably have not heard of

00:26:41,919 --> 00:26:46,400
but are still

00:26:43,039 --> 00:26:49,039
really useful for us

00:26:46,400 --> 00:26:50,640
so the first one is the one everybody

00:26:49,039 --> 00:26:54,799
loves to hate it's journal d

00:26:50,640 --> 00:26:56,720
so logs uh

00:26:54,799 --> 00:26:58,159
let's just put it that way in the

00:26:56,720 --> 00:27:01,760
embedded world

00:26:58,159 --> 00:27:02,400
we don't really like logs they clutter

00:27:01,760 --> 00:27:05,679
our file

00:27:02,400 --> 00:27:06,720
our file systems they eat our flash

00:27:05,679 --> 00:27:10,080
drives

00:27:06,720 --> 00:27:13,200
and on an embedded system that will

00:27:10,080 --> 00:27:16,559
end up under the sea or in a car

00:27:13,200 --> 00:27:19,279
or uh on a plane nobody will

00:27:16,559 --> 00:27:21,360
ever read the logs because we don't have

00:27:19,279 --> 00:27:22,640
any system means we don't have any log

00:27:21,360 --> 00:27:26,399
centralization

00:27:22,640 --> 00:27:28,159
and so most of the time logs are a real

00:27:26,399 --> 00:27:31,760
problem

00:27:28,159 --> 00:27:34,080
journal b helps a lot with logs

00:27:31,760 --> 00:27:35,520
so the first thing which makes journal

00:27:34,080 --> 00:27:39,679
the awesome is that

00:27:35,520 --> 00:27:42,159
it's exhaustive i mean every kind

00:27:39,679 --> 00:27:43,279
well except for uh applications that

00:27:42,159 --> 00:27:46,399
write directly

00:27:43,279 --> 00:27:49,679
in their own log files everything

00:27:46,399 --> 00:27:52,320
else end up in the journal so every d

00:27:49,679 --> 00:27:54,240
and every demon started by system d

00:27:52,320 --> 00:27:55,200
unless you configure them differently

00:27:54,240 --> 00:27:57,279
explicitly

00:27:55,200 --> 00:27:59,520
will have its standard out and standard

00:27:57,279 --> 00:28:01,679
errors into the journal

00:27:59,520 --> 00:28:03,120
everything that goes through syslog will

00:28:01,679 --> 00:28:05,360
end up in the journal

00:28:03,120 --> 00:28:07,039
any kernel message so what you usually

00:28:05,360 --> 00:28:10,320
get with the message

00:28:07,039 --> 00:28:11,440
will end up in the journal audit end up

00:28:10,320 --> 00:28:15,279
in the journal

00:28:11,440 --> 00:28:17,679
and if you use containers i

00:28:15,279 --> 00:28:19,279
well never use containers in embedded

00:28:17,679 --> 00:28:22,159
systems but you never know

00:28:19,279 --> 00:28:23,520
if you use containers all your container

00:28:22,159 --> 00:28:25,760
messages can end up

00:28:23,520 --> 00:28:27,120
in the same journal the journal of the

00:28:25,760 --> 00:28:28,880
host

00:28:27,120 --> 00:28:30,159
which means that you have them

00:28:28,880 --> 00:28:33,279
centralized

00:28:30,159 --> 00:28:34,640
for free the thing

00:28:33,279 --> 00:28:36,399
the next thing with the journal which

00:28:34,640 --> 00:28:38,080
makes it really awesome is that it

00:28:36,399 --> 00:28:40,240
collects metadata so

00:28:38,080 --> 00:28:41,520
if you use traditional syslog you only

00:28:40,240 --> 00:28:44,640
get um

00:28:41,520 --> 00:28:47,520
one line of text per message and

00:28:44,640 --> 00:28:49,120
that line of text may contain timestamps

00:28:47,520 --> 00:28:51,039
it may contain pid

00:28:49,120 --> 00:28:53,200
sometimes it doesn't sometimes it

00:28:51,039 --> 00:28:55,760
doesn't even contain the name of the

00:28:53,200 --> 00:28:58,880
person that generated the log

00:28:55,760 --> 00:29:01,919
with systemd well with journal the

00:28:58,880 --> 00:29:04,799
journal will collect every possible

00:29:01,919 --> 00:29:05,120
metadata it knows about and some of them

00:29:04,799 --> 00:29:07,520
are

00:29:05,120 --> 00:29:08,399
really great the first one which is

00:29:07,520 --> 00:29:11,600
really awesome

00:29:08,399 --> 00:29:12,000
is reliable timestamps so journal d will

00:29:11,600 --> 00:29:14,240
uh

00:29:12,000 --> 00:29:15,919
collect its own timestamps when it gets

00:29:14,240 --> 00:29:19,279
a message and will thus

00:29:15,919 --> 00:29:22,240
keep all message from all demons in

00:29:19,279 --> 00:29:23,679
one consistent order which is the real

00:29:22,240 --> 00:29:25,919
order

00:29:23,679 --> 00:29:28,159
that's pretty awesome and as a reminder

00:29:25,919 --> 00:29:31,120
i said earlier that journally collects

00:29:28,159 --> 00:29:33,520
a message from all containers which

00:29:31,120 --> 00:29:36,000
means that all your containers

00:29:33,520 --> 00:29:37,039
are in the same journal with reliable

00:29:36,000 --> 00:29:39,440
timestamps so

00:29:37,039 --> 00:29:42,000
everything is perfectly ordered between

00:29:39,440 --> 00:29:44,799
containers

00:29:42,000 --> 00:29:47,200
it stores a boot id which is every

00:29:44,799 --> 00:29:49,360
message so the boot id is basically a

00:29:47,200 --> 00:29:50,559
random string that is generated at boot

00:29:49,360 --> 00:29:53,120
and that is used to

00:29:50,559 --> 00:29:55,279
uniquely and identify the boot of your

00:29:53,120 --> 00:29:57,440
machine so which means that you can

00:29:55,279 --> 00:29:58,640
just get all the message from a

00:29:57,440 --> 00:30:01,440
particular boot

00:29:58,640 --> 00:30:02,480
easily you also get all process

00:30:01,440 --> 00:30:04,399
information so

00:30:02,480 --> 00:30:05,760
pid of your process command line of your

00:30:04,399 --> 00:30:08,080
print process

00:30:05,760 --> 00:30:10,080
uids that launch your process what

00:30:08,080 --> 00:30:11,760
capabilities your process had at the

00:30:10,080 --> 00:30:15,200
time and so forth and so on there's all

00:30:11,760 --> 00:30:18,559
sorts of stuff it's pretty useful

00:30:15,200 --> 00:30:21,200
uh the next thing that's really cool for

00:30:18,559 --> 00:30:21,600
us in the embedded world is that journal

00:30:21,200 --> 00:30:24,159
d

00:30:21,600 --> 00:30:25,679
is not just here to collect logs and

00:30:24,159 --> 00:30:28,559
write them down in files

00:30:25,679 --> 00:30:29,679
it actually has a complete api which

00:30:28,559 --> 00:30:32,720
allows you

00:30:29,679 --> 00:30:35,919
to control it so

00:30:32,720 --> 00:30:37,840
one thing we commonly have to do in

00:30:35,919 --> 00:30:40,240
embedded systems which have

00:30:37,840 --> 00:30:40,960
a user interface so one with a screen or

00:30:40,240 --> 00:30:43,440
something like

00:30:40,960 --> 00:30:45,200
like that is have some sort of debug

00:30:43,440 --> 00:30:48,320
menu where you can scroll

00:30:45,200 --> 00:30:50,399
and view the logs

00:30:48,320 --> 00:30:51,760
with journal d you have an api which

00:30:50,399 --> 00:30:55,360
allows you to

00:30:51,760 --> 00:30:57,919
uh to search the logs to uh see

00:30:55,360 --> 00:30:59,200
the logs continuously you have a poll

00:30:57,919 --> 00:31:01,120
aware mechanism

00:30:59,200 --> 00:31:03,200
this pull aware mechanism you can give

00:31:01,120 --> 00:31:04,640
it filters so you will only be woken

00:31:03,200 --> 00:31:09,919
when

00:31:04,640 --> 00:31:11,840
a given type of message arrives you can

00:31:09,919 --> 00:31:13,120
find where you were last time when you

00:31:11,840 --> 00:31:17,279
restart so which me

00:31:13,120 --> 00:31:21,039
which means that your log vis visually

00:31:17,279 --> 00:31:24,320
log visualization tool can catch up

00:31:21,039 --> 00:31:26,720
if it crashes so your log tool

00:31:24,320 --> 00:31:28,480
is monitored by systemd it crashes it

00:31:26,720 --> 00:31:29,039
restarts it's reconnecting to the

00:31:28,480 --> 00:31:31,600
journal

00:31:29,039 --> 00:31:32,880
it will get all the message it missed

00:31:31,600 --> 00:31:35,760
while it was down

00:31:32,880 --> 00:31:36,799
and that's for free it's easy to do this

00:31:35,760 --> 00:31:39,840
is an area where i

00:31:36,799 --> 00:31:42,559
just told someone you have this api

00:31:39,840 --> 00:31:44,559
go look into it and then the application

00:31:42,559 --> 00:31:47,760
was working

00:31:44,559 --> 00:31:49,279
you can store any extra data you want in

00:31:47,760 --> 00:31:51,919
the journal when you're stock

00:31:49,279 --> 00:31:52,880
storing a message not just one line of

00:31:51,919 --> 00:31:55,919
text

00:31:52,880 --> 00:31:59,039
including binary data

00:31:55,919 --> 00:32:00,480
so uh the system the people use this

00:31:59,039 --> 00:32:02,320
feature the fact that you can store

00:32:00,480 --> 00:32:05,200
binary data with messages

00:32:02,320 --> 00:32:05,840
to store coordinates inside the journal

00:32:05,200 --> 00:32:08,159
i'm

00:32:05,840 --> 00:32:08,960
personally not convinced it's a great

00:32:08,159 --> 00:32:11,600
idea but

00:32:08,960 --> 00:32:13,360
it can be done what is great is that you

00:32:11,600 --> 00:32:15,919
can store

00:32:13,360 --> 00:32:16,559
any binary data in the journal and i

00:32:15,919 --> 00:32:20,480
usually

00:32:16,559 --> 00:32:23,679
use it to store faulty bus frames

00:32:20,480 --> 00:32:25,760
i when you debug a system and when you

00:32:23,679 --> 00:32:28,880
debug a system

00:32:25,760 --> 00:32:30,000
in a real environment commonly you uh

00:32:28,880 --> 00:32:32,399
you're not here

00:32:30,000 --> 00:32:33,360
you just give your system to a mechanic

00:32:32,399 --> 00:32:35,440
the mechanic will

00:32:33,360 --> 00:32:37,360
put it in the car the car will go and

00:32:35,440 --> 00:32:37,760
run around the circuit for hours and

00:32:37,360 --> 00:32:39,279
then

00:32:37,760 --> 00:32:41,600
it comes back and you have to see what

00:32:39,279 --> 00:32:42,640
has been going on so with this kind of

00:32:41,600 --> 00:32:47,039
tool you can just

00:32:42,640 --> 00:32:48,960
store any faulty frame you find inside

00:32:47,039 --> 00:32:50,320
the journal and get it with all the

00:32:48,960 --> 00:32:52,720
traces again

00:32:50,320 --> 00:32:54,320
with timestamps that allow you to see

00:32:52,720 --> 00:32:55,039
all the message your application has

00:32:54,320 --> 00:32:59,440
produced

00:32:55,039 --> 00:32:59,440
before and after detecting the problem

00:32:59,679 --> 00:33:05,600
uh journal d has um

00:33:02,720 --> 00:33:06,960
a network protocol um option so it's

00:33:05,600 --> 00:33:08,840
optional you don't have to

00:33:06,960 --> 00:33:11,279
compile it in but if you do it's pretty

00:33:08,840 --> 00:33:14,720
awesome a traditional

00:33:11,279 --> 00:33:17,440
syslog is a

00:33:14,720 --> 00:33:18,320
traditional syslog protocol is just put

00:33:17,440 --> 00:33:21,600
the message

00:33:18,320 --> 00:33:23,120
in a udp packet and sends a packet so

00:33:21,600 --> 00:33:24,720
you have no intake well you have

00:33:23,120 --> 00:33:27,360
integrity because it's tcp

00:33:24,720 --> 00:33:28,960
because it's ib but you don't have a

00:33:27,360 --> 00:33:30,640
guarantee that the message will arrive

00:33:28,960 --> 00:33:33,360
you have no guarantee of the order and

00:33:30,640 --> 00:33:35,760
you have no time stamps to um

00:33:33,360 --> 00:33:37,679
to correct the order so usually it's

00:33:35,760 --> 00:33:38,559
used in a data center where the network

00:33:37,679 --> 00:33:40,080
is reliable

00:33:38,559 --> 00:33:42,159
but you could never use that sort of

00:33:40,080 --> 00:33:45,200
protocol over the internet

00:33:42,159 --> 00:33:46,799
uh journal d comes with its own uh web

00:33:45,200 --> 00:33:50,159
client slash web server

00:33:46,799 --> 00:33:53,679
which allows you to easily uh

00:33:50,159 --> 00:33:57,600
fetch or push the logs um

00:33:53,679 --> 00:34:00,000
around an http a s based stack so it's

00:33:57,600 --> 00:34:01,919
really easy to put in place it's all

00:34:00,000 --> 00:34:03,919
it's it has already been done

00:34:01,919 --> 00:34:05,840
for you you can use certificates to

00:34:03,919 --> 00:34:07,600
guarantee that only allowed people can

00:34:05,840 --> 00:34:11,760
get into the log

00:34:07,600 --> 00:34:15,119
and it even integrates a very simple

00:34:11,760 --> 00:34:17,679
very light web page which allows you to

00:34:15,119 --> 00:34:19,280
browse your logs directly on your

00:34:17,679 --> 00:34:22,960
machine so if you need

00:34:19,280 --> 00:34:24,720
a one-off uh log visualization tool

00:34:22,960 --> 00:34:26,879
uh something simple you have zero

00:34:24,720 --> 00:34:29,520
development to do you just use a

00:34:26,879 --> 00:34:30,320
system days integrated web server and

00:34:29,520 --> 00:34:31,599
you get a lot

00:34:30,320 --> 00:34:33,839
if you don't want it you just don't

00:34:31,599 --> 00:34:36,639
compile it

00:34:33,839 --> 00:34:37,359
last in the in the embedded world we

00:34:36,639 --> 00:34:40,399
tend to

00:34:37,359 --> 00:34:42,879
um to have uh

00:34:40,399 --> 00:34:44,480
file rotation issues so we have some

00:34:42,879 --> 00:34:47,359
very complex logic

00:34:44,480 --> 00:34:48,000
about how many files we are allowed to

00:34:47,359 --> 00:34:50,399
keep how

00:34:48,000 --> 00:34:51,599
what size they have they must have how

00:34:50,399 --> 00:34:54,960
old they can be

00:34:51,599 --> 00:34:58,079
um journal d has a very very

00:34:54,960 --> 00:34:59,920
uh complete uh

00:34:58,079 --> 00:35:02,079
file rotation configuration and will

00:34:59,920 --> 00:35:03,680
basically uh

00:35:02,079 --> 00:35:05,280
deal with anything you can throw at it

00:35:03,680 --> 00:35:08,000
so

00:35:05,280 --> 00:35:09,200
just go for it uh that's a solved

00:35:08,000 --> 00:35:12,240
problem for me so

00:35:09,200 --> 00:35:14,880
journal d as far as i'm concerned has

00:35:12,240 --> 00:35:16,720
solved all the log problems i have when

00:35:14,880 --> 00:35:19,280
doing embedded systems

00:35:16,720 --> 00:35:21,520
and in particular all the things linked

00:35:19,280 --> 00:35:24,880
to having an api which makes things

00:35:21,520 --> 00:35:24,880
way way way simpler

00:35:25,200 --> 00:35:28,560
something i love about systemd is that

00:35:27,440 --> 00:35:31,119
you have complete d

00:35:28,560 --> 00:35:32,720
bus piloting so everything systemd can

00:35:31,119 --> 00:35:34,800
do you can command it

00:35:32,720 --> 00:35:36,000
through d bus so that means that you you

00:35:34,800 --> 00:35:39,119
can monitor

00:35:36,000 --> 00:35:41,280
uh your system through dbus

00:35:39,119 --> 00:35:43,359
and systemd will send you with the bus

00:35:41,280 --> 00:35:45,520
signal when uh you need to change state

00:35:43,359 --> 00:35:47,760
so you can monitor units and have

00:35:45,520 --> 00:35:49,119
your nice little green red lights on

00:35:47,760 --> 00:35:51,440
your ui

00:35:49,119 --> 00:35:53,119
simply by monitoring systemd and looking

00:35:51,440 --> 00:35:56,079
at um

00:35:53,119 --> 00:35:58,000
at unit states uh and the monitoring

00:35:56,079 --> 00:35:58,480
application can itself be monitored by

00:35:58,000 --> 00:36:01,920
systems

00:35:58,480 --> 00:36:03,040
which is pretty awesome uh you want to

00:36:01,920 --> 00:36:05,359
have uh

00:36:03,040 --> 00:36:06,240
to restart a service with a button on

00:36:05,359 --> 00:36:08,079
your ui

00:36:06,240 --> 00:36:09,359
while the button just send a debuss

00:36:08,079 --> 00:36:11,920
message to systemd

00:36:09,359 --> 00:36:14,000
and systemd is very good at restarting

00:36:11,920 --> 00:36:17,440
services so it's pretty trivial

00:36:14,000 --> 00:36:20,240
to do uh any property uh

00:36:17,440 --> 00:36:22,320
is available through the bus and those

00:36:20,240 --> 00:36:24,480
that can be dynamically changed you can

00:36:22,320 --> 00:36:26,480
change them through the bus

00:36:24,480 --> 00:36:29,040
and that includes all control group

00:36:26,480 --> 00:36:30,720
settings so i didn't go into control

00:36:29,040 --> 00:36:32,400
group earlier but basically it allows

00:36:30,720 --> 00:36:35,680
you to control how much

00:36:32,400 --> 00:36:37,280
cpu how much memory a given service has

00:36:35,680 --> 00:36:40,720
available so you can change that

00:36:37,280 --> 00:36:43,359
dynamically through systemd and

00:36:40,720 --> 00:36:44,160
uh you can then pilot all this through

00:36:43,359 --> 00:36:46,800
dbus

00:36:44,160 --> 00:36:48,160
so when you need to interact well with

00:36:46,800 --> 00:36:51,599
the system in general

00:36:48,160 --> 00:36:55,440
uh you do it through dbus i mean

00:36:51,599 --> 00:36:58,880
all major um

00:36:55,440 --> 00:37:01,599
system daemons uh

00:36:58,880 --> 00:37:02,079
uh nowadays have a dbs api and so does

00:37:01,599 --> 00:37:03,839
system

00:37:02,079 --> 00:37:05,440
but systemd is pretty interesting

00:37:03,839 --> 00:37:07,839
because it controls the system

00:37:05,440 --> 00:37:08,560
so you can restart reboot through a

00:37:07,839 --> 00:37:11,359
debus

00:37:08,560 --> 00:37:11,839
api restart any uh demons through a

00:37:11,359 --> 00:37:13,839
debuff

00:37:11,839 --> 00:37:14,960
api change how the demands work through

00:37:13,839 --> 00:37:19,359
a device api

00:37:14,960 --> 00:37:21,280
it's really easy and again

00:37:19,359 --> 00:37:22,880
some things that people learn very fast

00:37:21,280 --> 00:37:25,119
you have to understand systemd to do

00:37:22,880 --> 00:37:27,440
deepest piloting but once you do it

00:37:25,119 --> 00:37:31,599
it's extremely complete and it solves

00:37:27,440 --> 00:37:31,599
all sorts of real life problems

00:37:32,079 --> 00:37:37,599
in the embed the world we

00:37:35,440 --> 00:37:39,440
have all sorts of problem with file

00:37:37,599 --> 00:37:42,960
system and partition management

00:37:39,440 --> 00:37:44,400
uh so to give you a few uh usually we

00:37:42,960 --> 00:37:46,880
are asked to do a

00:37:44,400 --> 00:37:47,760
file system uh well uh system images

00:37:46,880 --> 00:37:52,160
that are as

00:37:47,760 --> 00:37:55,680
small as possible because of

00:37:52,160 --> 00:37:59,200
flashing time in factory uh and usually

00:37:55,680 --> 00:38:02,720
we want uh to uh partition

00:37:59,200 --> 00:38:06,079
and create our data partitions

00:38:02,720 --> 00:38:09,599
on first boot we also usually have

00:38:06,079 --> 00:38:11,599
a b type uh update upgrade systems

00:38:09,599 --> 00:38:13,920
which means that the whole data is

00:38:11,599 --> 00:38:15,760
copied twice on bus which takes a lot of

00:38:13,920 --> 00:38:17,760
time in factory so we want

00:38:15,760 --> 00:38:19,440
the system to create its second

00:38:17,760 --> 00:38:22,000
partition on first boot so there are

00:38:19,440 --> 00:38:22,880
all sorts of cases and system d provides

00:38:22,000 --> 00:38:26,240
some great

00:38:22,880 --> 00:38:29,839
tools to help us with that problem so

00:38:26,240 --> 00:38:33,760
the first one is uh systemd

00:38:29,839 --> 00:38:36,880
can detect what partition goes where

00:38:33,760 --> 00:38:40,640
and mount them correctly based on a

00:38:36,880 --> 00:38:41,119
gpt header so gpt is a replacement for

00:38:40,640 --> 00:38:44,240
the

00:38:41,119 --> 00:38:46,880
all the bios partition tables

00:38:44,240 --> 00:38:49,359
and you can encode in there with what

00:38:46,880 --> 00:38:52,960
each partition is for and systemd will

00:38:49,359 --> 00:38:54,480
detect this automatically uh the latest

00:38:52,960 --> 00:38:57,680
version of systemd have

00:38:54,480 --> 00:39:00,560
uh a new daemon called part d and part d

00:38:57,680 --> 00:39:01,200
will look at a couple of configuration

00:39:00,560 --> 00:39:04,000
file

00:39:01,200 --> 00:39:05,280
and if it finds that some partitions are

00:39:04,000 --> 00:39:07,839
missing

00:39:05,280 --> 00:39:08,400
it can create them and it can create

00:39:07,839 --> 00:39:11,760
them

00:39:08,400 --> 00:39:14,000
dynamically with constraints like just

00:39:11,760 --> 00:39:15,920
take all space available so it's pretty

00:39:14,000 --> 00:39:18,560
easy to have partition created that will

00:39:15,920 --> 00:39:20,000
take whatever disk space we have and

00:39:18,560 --> 00:39:20,880
that's pretty important because in the

00:39:20,000 --> 00:39:22,640
embedded world

00:39:20,880 --> 00:39:24,240
usually you have new version of the

00:39:22,640 --> 00:39:28,400
product which is

00:39:24,240 --> 00:39:31,760
only within which the only difference is

00:39:28,400 --> 00:39:34,800
the the size of the disk so having

00:39:31,760 --> 00:39:38,079
a system that can grow it's inside its

00:39:34,800 --> 00:39:40,240
its disk is pretty awesome systemd

00:39:38,079 --> 00:39:41,680
can detect when a partition is not

00:39:40,240 --> 00:39:44,800
formatted and formatted

00:39:41,680 --> 00:39:48,079
automatically and it can also detect

00:39:44,800 --> 00:39:50,320
when a partition is empty and it can

00:39:48,079 --> 00:39:51,200
populate it automatically so that's

00:39:50,320 --> 00:39:54,320
pretty awesome

00:39:51,200 --> 00:39:56,640
again either for our a b use case

00:39:54,320 --> 00:39:58,800
or more commonly in the embedded system

00:39:56,640 --> 00:39:59,760
when you have a data partition but you

00:39:58,800 --> 00:40:02,160
need to have stuff

00:39:59,760 --> 00:40:04,160
in the data partition you just leave

00:40:02,160 --> 00:40:05,200
your hard disk empty and with a properly

00:40:04,160 --> 00:40:07,920
configured system the

00:40:05,200 --> 00:40:09,520
systemd will create the data partition

00:40:07,920 --> 00:40:12,720
format the data partition

00:40:09,520 --> 00:40:15,599
initialize the data partition for you so

00:40:12,720 --> 00:40:16,400
this really solves uh a problem because

00:40:15,599 --> 00:40:18,880
fstab

00:40:16,400 --> 00:40:19,599
is complicated to handle especially in

00:40:18,880 --> 00:40:22,960
yocto

00:40:19,599 --> 00:40:27,920
where we hate to have to write files

00:40:22,960 --> 00:40:30,319
fstab is one file you can't do drop-its

00:40:27,920 --> 00:40:31,839
uh portable services are also pretty

00:40:30,319 --> 00:40:32,640
awesome so i'll try to be a bit faster

00:40:31,839 --> 00:40:35,520
on those ones

00:40:32,640 --> 00:40:35,920
portable service basically allows you to

00:40:35,520 --> 00:40:38,240
have

00:40:35,920 --> 00:40:39,599
binaries all its libraries all its

00:40:38,240 --> 00:40:43,359
configuration files

00:40:39,599 --> 00:40:43,839
in one single uh file system image so it

00:40:43,359 --> 00:40:47,119
allows

00:40:43,839 --> 00:40:50,319
allows you to have packages in one

00:40:47,119 --> 00:40:53,119
file uh without having the risk

00:40:50,319 --> 00:40:54,720
of having a normal package system like

00:40:53,119 --> 00:40:56,960
debian has

00:40:54,720 --> 00:40:58,319
which breaks systems to make it sim

00:40:56,960 --> 00:41:00,960
simply so you can have

00:40:58,319 --> 00:41:02,480
all these images and services in one

00:41:00,960 --> 00:41:05,599
single file

00:41:02,480 --> 00:41:06,000
and this way you you can easily remove

00:41:05,599 --> 00:41:08,079
them

00:41:06,000 --> 00:41:09,280
if you need to do a factory reset so

00:41:08,079 --> 00:41:12,800
portable services

00:41:09,280 --> 00:41:14,800
allows us to have a cheap poor man's

00:41:12,800 --> 00:41:16,800
packaging system without paying the

00:41:14,800 --> 00:41:20,480
price and having the danger

00:41:16,800 --> 00:41:22,560
of a full blown packaging system

00:41:20,480 --> 00:41:23,760
that's for my favorite features in

00:41:22,560 --> 00:41:27,359
systemd so

00:41:23,760 --> 00:41:29,440
one quick slide on the features i do not

00:41:27,359 --> 00:41:31,280
use an embedded system so the first one

00:41:29,440 --> 00:41:32,319
i would like to mention is network d so

00:41:31,280 --> 00:41:35,200
network d

00:41:32,319 --> 00:41:36,480
is a network configuration tool so it

00:41:35,200 --> 00:41:39,440
serves the same purpose

00:41:36,480 --> 00:41:40,480
as a network manager or con man except

00:41:39,440 --> 00:41:43,920
that network d

00:41:40,480 --> 00:41:48,240
is really uh around the use case

00:41:43,920 --> 00:41:49,839
of um having interfaces appearing and

00:41:48,240 --> 00:41:51,680
disappearing dynamically

00:41:49,839 --> 00:41:53,040
which is typically what happens with

00:41:51,680 --> 00:41:55,119
containers that

00:41:53,040 --> 00:41:56,160
are started and stopped so we usually

00:41:55,119 --> 00:41:57,839
don't use

00:41:56,160 --> 00:41:59,280
containers that much in the embedded

00:41:57,839 --> 00:42:01,520
world so network d

00:41:59,280 --> 00:42:03,920
is really not practical for our complex

00:42:01,520 --> 00:42:07,440
use cases and i usually use some similar

00:42:03,920 --> 00:42:10,800
like con map i usually

00:42:07,440 --> 00:42:13,599
disable login d home d because and

00:42:10,800 --> 00:42:15,599
per user system d sessions because those

00:42:13,599 --> 00:42:16,400
are all things that are linked to human

00:42:15,599 --> 00:42:20,240
users

00:42:16,400 --> 00:42:22,880
and we use dedicated

00:42:20,240 --> 00:42:24,560
uids for security purposes in the

00:42:22,880 --> 00:42:28,560
embedded world to separate

00:42:24,560 --> 00:42:29,119
security domains but we generally do not

00:42:28,560 --> 00:42:32,160
have

00:42:29,119 --> 00:42:33,520
human users that need a shell or things

00:42:32,160 --> 00:42:36,960
like that so

00:42:33,520 --> 00:42:38,800
i disable those features and spawn again

00:42:36,960 --> 00:42:40,079
very little use for containers in the

00:42:38,800 --> 00:42:42,079
embedded world so

00:42:40,079 --> 00:42:43,440
nspawn is not really useful for that

00:42:42,079 --> 00:42:45,599
systemd boot

00:42:43,440 --> 00:42:48,079
is a very good tool but it's only for

00:42:45,599 --> 00:42:50,079
efi systems and in the embedded world we

00:42:48,079 --> 00:42:51,920
usually don't have efi systems we have

00:42:50,079 --> 00:42:52,960
u-boot-based systems so it's not that

00:42:51,920 --> 00:42:57,040
useful

00:42:52,960 --> 00:42:59,119
and systemd in the init ram disk

00:42:57,040 --> 00:43:01,040
because we are in a trend disc when we

00:42:59,119 --> 00:43:05,280
have them are usually pretty trivial

00:43:01,040 --> 00:43:08,560
and are simpler to write in shell

00:43:05,280 --> 00:43:10,880
so this is why i think systemd is really

00:43:08,560 --> 00:43:14,000
great in the embedded world it makes

00:43:10,880 --> 00:43:15,599
easy it makes it's way easier to write a

00:43:14,000 --> 00:43:18,000
daemon because

00:43:15,599 --> 00:43:18,640
a daemon is just a normal application no

00:43:18,000 --> 00:43:21,440
forking

00:43:18,640 --> 00:43:23,040
no uh complex configuration of your

00:43:21,440 --> 00:43:26,319
system systemd can do um

00:43:23,040 --> 00:43:28,640
everything for you uh systemd uh

00:43:26,319 --> 00:43:29,359
allows you to monitor and to secure your

00:43:28,640 --> 00:43:31,760
daemon

00:43:29,359 --> 00:43:33,040
easily and systemd allows you to

00:43:31,760 --> 00:43:35,040
interact with the system

00:43:33,040 --> 00:43:36,160
easily being changing the network

00:43:35,040 --> 00:43:38,720
configuration

00:43:36,160 --> 00:43:40,160
readings the logs writing tools into the

00:43:38,720 --> 00:43:43,200
logs debugging all those

00:43:40,160 --> 00:43:44,800
things you have great tools if you take

00:43:43,200 --> 00:43:47,920
the time to learning so

00:43:44,800 --> 00:43:48,800
so that would be my general advice with

00:43:47,920 --> 00:43:52,000
systemd

00:43:48,800 --> 00:43:54,400
is take the time to learn it's

00:43:52,000 --> 00:43:56,960
really worth it to have one person in

00:43:54,400 --> 00:44:00,319
your team that really understands

00:43:56,960 --> 00:44:02,480
and masters systemd he will write

00:44:00,319 --> 00:44:04,480
all the services you need and it will

00:44:02,480 --> 00:44:07,440
really really simplify

00:44:04,480 --> 00:44:07,920
your main application and that's the big

00:44:07,440 --> 00:44:10,880
gain

00:44:07,920 --> 00:44:11,280
things are simple securing is simple

00:44:10,880 --> 00:44:13,839
it's

00:44:11,280 --> 00:44:15,359
robust and robust is really the number

00:44:13,839 --> 00:44:23,839
one thing we want in

00:44:15,359 --> 00:44:23,839
embedded systems thank you very much

00:44:24,560 --> 00:44:26,640

YouTube URL: https://www.youtube.com/watch?v=7rXAhljmd9A


