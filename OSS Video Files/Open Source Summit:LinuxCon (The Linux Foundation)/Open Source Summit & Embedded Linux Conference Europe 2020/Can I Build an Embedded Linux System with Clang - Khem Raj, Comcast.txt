Title: Can I Build an Embedded Linux System with Clang - Khem Raj, Comcast
Publication date: 2020-11-03
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Can I Build an Embedded Linux System with Clang - Khem Raj, Comcast
Captions: 
	00:00:07,440 --> 00:00:12,080
hello greetings everyone

00:00:10,000 --> 00:00:14,240
in this session we are going to learn

00:00:12,080 --> 00:00:16,560
about

00:00:14,240 --> 00:00:19,840
building an embedded linux using the

00:00:16,560 --> 00:00:23,439
clang compiler and tools

00:00:19,840 --> 00:00:27,279
we've been seeing clang as a option

00:00:23,439 --> 00:00:30,320
being developed for as a compiler

00:00:27,279 --> 00:00:32,559
over past several years and this is

00:00:30,320 --> 00:00:35,520
specifically i'm going to cover

00:00:32,559 --> 00:00:36,000
what's going on with respect to clang in

00:00:35,520 --> 00:00:38,960
the

00:00:36,000 --> 00:00:40,399
linux community in general and there are

00:00:38,960 --> 00:00:43,520
several talks

00:00:40,399 --> 00:00:46,320
including myself who've presented on

00:00:43,520 --> 00:00:49,200
clang in various aspects

00:00:46,320 --> 00:00:50,079
this will be specifically building a

00:00:49,200 --> 00:00:53,120
full system

00:00:50,079 --> 00:00:59,840
and trying to use clang

00:00:53,120 --> 00:00:59,840
as system compiler um

00:01:01,280 --> 00:01:06,479
so this is rough agenda so first we'll

00:01:04,000 --> 00:01:08,960
go through

00:01:06,479 --> 00:01:09,760
what clang based tool chain looks like

00:01:08,960 --> 00:01:13,040
and then

00:01:09,760 --> 00:01:14,799
we'll cover the kernel status the kernel

00:01:13,040 --> 00:01:18,000
compiling status

00:01:14,799 --> 00:01:18,960
and then we'll go for building a

00:01:18,000 --> 00:01:21,840
platform and

00:01:18,960 --> 00:01:23,520
i'm going to use uh yocto project to

00:01:21,840 --> 00:01:25,680
build the platform

00:01:23,520 --> 00:01:26,720
there are other platform builders out

00:01:25,680 --> 00:01:28,880
there i'll

00:01:26,720 --> 00:01:30,240
briefly mention them and if you want to

00:01:28,880 --> 00:01:32,880
use those

00:01:30,240 --> 00:01:33,680
you're welcome to try those as well and

00:01:32,880 --> 00:01:35,920
then i'll

00:01:33,680 --> 00:01:38,560
go over what are different options that

00:01:35,920 --> 00:01:40,560
are available for runtimes

00:01:38,560 --> 00:01:41,680
and what options we can choose within

00:01:40,560 --> 00:01:44,799
your framework

00:01:41,680 --> 00:01:47,600
and what works what doesn't yet and then

00:01:44,799 --> 00:01:49,200
we'll also go over some of the common

00:01:47,600 --> 00:01:51,840
errors that

00:01:49,200 --> 00:01:53,439
you could see that you need to address

00:01:51,840 --> 00:01:56,479
for various packages

00:01:53,439 --> 00:01:58,399
i'll also cover through some of this

00:01:56,479 --> 00:01:59,600
from debian's perspective because i

00:01:58,399 --> 00:02:01,520
think

00:01:59,600 --> 00:02:03,680
that's one of the largest archives that

00:02:01,520 --> 00:02:06,000
has been

00:02:03,680 --> 00:02:07,439
recompiled or an effort is there to

00:02:06,000 --> 00:02:10,080
recompile

00:02:07,439 --> 00:02:10,080
that with

00:02:10,560 --> 00:02:14,080
clang as a compiler

00:02:16,879 --> 00:02:24,480
so building a platform

00:02:20,800 --> 00:02:26,560
based upon clang you know there are

00:02:24,480 --> 00:02:29,840
three things that you will see in

00:02:26,560 --> 00:02:33,680
addition to clang runtime

00:02:29,840 --> 00:02:36,800
which is basically a compiler runtime

00:02:33,680 --> 00:02:40,480
similar to the gcc and and

00:02:36,800 --> 00:02:44,480
provides the initial initialization code

00:02:40,480 --> 00:02:44,480
and it also has some

00:02:44,640 --> 00:02:48,800
compiler built-ins that are generally

00:02:46,640 --> 00:02:51,840
provided as a library but then support

00:02:48,800 --> 00:02:54,560
for sanitizers and profiling

00:02:51,840 --> 00:02:54,959
lip c plus plus is in a is an effort for

00:02:54,560 --> 00:02:58,400
uh

00:02:54,959 --> 00:02:58,800
running um standard c plus plus runtime

00:02:58,400 --> 00:03:01,680
so

00:02:58,800 --> 00:03:03,120
in new tool chain speak you can think it

00:03:01,680 --> 00:03:05,760
like a lip standard

00:03:03,120 --> 00:03:07,120
c plus plus library and then there's a

00:03:05,760 --> 00:03:09,760
low level implementation

00:03:07,120 --> 00:03:11,519
for avi which is called lip c plus plus

00:03:09,760 --> 00:03:13,280
abi

00:03:11,519 --> 00:03:15,680
and then there is unwinder library as

00:03:13,280 --> 00:03:19,519
well that is available which is called

00:03:15,680 --> 00:03:21,760
the live unwind and we'll cover them as

00:03:19,519 --> 00:03:26,319
well so if you look at the tools map

00:03:21,760 --> 00:03:29,120
in general between say a gcc

00:03:26,319 --> 00:03:30,400
a compiler tool chain and a clang slash

00:03:29,120 --> 00:03:32,239
llvm

00:03:30,400 --> 00:03:33,519
then this is roughly how you can map

00:03:32,239 --> 00:03:36,879
them uh

00:03:33,519 --> 00:03:39,040
there is a cc plus plus compiler and

00:03:36,879 --> 00:03:40,959
which is basically clang or clang plus

00:03:39,040 --> 00:03:44,159
plus

00:03:40,959 --> 00:03:48,080
and the assembler called cc1s

00:03:44,159 --> 00:03:52,400
this is internal assembler which

00:03:48,080 --> 00:03:55,120
is used by clang by default

00:03:52,400 --> 00:03:56,560
and there are options to not use it but

00:03:55,120 --> 00:03:57,519
that will be the default if you don't

00:03:56,560 --> 00:04:01,920
make

00:03:57,519 --> 00:04:06,400
any any specific effort to disable it

00:04:01,920 --> 00:04:12,000
linker there is lld which is

00:04:06,400 --> 00:04:16,880
the llvm linker it's relatively new

00:04:12,000 --> 00:04:19,359
it could be used as an option however

00:04:16,880 --> 00:04:21,919
clang can work very well with the bfd

00:04:19,359 --> 00:04:25,280
linker or gold linker

00:04:21,919 --> 00:04:29,360
there are no issues there and

00:04:25,280 --> 00:04:29,360
debugger there's a lldb which is

00:04:29,520 --> 00:04:35,120
your front-end for debugging and native

00:04:32,000 --> 00:04:37,840
debugging but there is also lldb server

00:04:35,120 --> 00:04:39,120
which is uh for cross debugging system

00:04:37,840 --> 00:04:42,320
so you could

00:04:39,120 --> 00:04:45,520
install lldb on the target and then run

00:04:42,320 --> 00:04:47,600
lldb on the host similar to geb and gdb

00:04:45,520 --> 00:04:49,440
server setup

00:04:47,600 --> 00:04:51,280
in terms of compiler runtime and the

00:04:49,440 --> 00:04:55,199
compiler rt project

00:04:51,280 --> 00:04:57,120
that is providing the c runtime as i was

00:04:55,199 --> 00:05:00,880
discussing earlier

00:04:57,120 --> 00:05:03,039
uh which is uh implementing some of the

00:05:00,880 --> 00:05:04,400
functionality that lib gcc provides you

00:05:03,039 --> 00:05:07,120
and then unwinder

00:05:04,400 --> 00:05:08,840
there's a lib unwind which is a separate

00:05:07,120 --> 00:05:12,320
library

00:05:08,840 --> 00:05:12,720
um implements the unwinding routines

00:05:12,320 --> 00:05:16,560
that

00:05:12,720 --> 00:05:20,960
generally will find in uh leave gcc

00:05:16,560 --> 00:05:23,120
as well in terms of c plus plus runtime

00:05:20,960 --> 00:05:25,520
we got leap c plus plus and leap c plus

00:05:23,120 --> 00:05:27,120
plus avi we talked about that

00:05:25,520 --> 00:05:28,800
and then it can work with several

00:05:27,120 --> 00:05:32,400
standard c libraries

00:05:28,800 --> 00:05:36,720
um glibc muscle

00:05:32,400 --> 00:05:39,840
um there is also a llvm lipsy which is

00:05:36,720 --> 00:05:39,840
relatively new project

00:05:40,000 --> 00:05:44,000
which is also offering as an option

00:05:42,000 --> 00:05:47,360
currently it is in a nation state so i'm

00:05:44,000 --> 00:05:47,360
not going to cover that as much

00:05:48,400 --> 00:05:52,479
from linux platform point of view g

00:05:51,120 --> 00:05:54,880
libsyn muscle is

00:05:52,479 --> 00:05:56,479
currently more important and more

00:05:54,880 --> 00:05:58,560
interesting

00:05:56,479 --> 00:06:01,759
and then there are also bin bin noodles

00:05:58,560 --> 00:06:04,880
equivalent for archivers and and

00:06:01,759 --> 00:06:08,160
symbol dumping and and

00:06:04,880 --> 00:06:08,960
and other utilities so you will find the

00:06:08,160 --> 00:06:12,080
llvm

00:06:08,960 --> 00:06:15,199
dash equivalent of all those

00:06:12,080 --> 00:06:15,199
utilities as well

00:06:15,840 --> 00:06:18,960
so this is roughly the map that you see

00:06:18,319 --> 00:06:22,639
here

00:06:18,960 --> 00:06:25,039
and then additionally when you see

00:06:22,639 --> 00:06:26,400
these are like standard tools but then

00:06:25,039 --> 00:06:29,199
you can also see that

00:06:26,400 --> 00:06:30,560
there are additional tools um that are

00:06:29,199 --> 00:06:35,840
very useful

00:06:30,560 --> 00:06:35,840
and clank tidy is a linter tool

00:06:36,000 --> 00:06:39,840
and clank dock generates documentation

00:06:38,160 --> 00:06:43,440
similar to doxygen

00:06:39,840 --> 00:06:44,880
and clang d is actually a tool that you

00:06:43,440 --> 00:06:48,000
can use for adding

00:06:44,880 --> 00:06:51,040
cc plus features to editors

00:06:48,000 --> 00:06:52,240
like vs code and bim and others so

00:06:51,040 --> 00:06:56,960
[Music]

00:06:52,240 --> 00:07:00,160
it can offer a good editing experience

00:06:56,960 --> 00:07:03,599
it exposes all the all the

00:07:00,160 --> 00:07:05,199
language features through clandy

00:07:03,599 --> 00:07:08,000
scan build which we'll cover a little

00:07:05,199 --> 00:07:08,720
bit in later uh is the static analyzer

00:07:08,000 --> 00:07:11,520
so

00:07:08,720 --> 00:07:13,840
it's very handy you could use it to do

00:07:11,520 --> 00:07:16,720
some static analysis as well

00:07:13,840 --> 00:07:17,120
and all that's all this is bundled with

00:07:16,720 --> 00:07:20,639
the

00:07:17,120 --> 00:07:22,080
uh clang tool suite so we'll

00:07:20,639 --> 00:07:24,400
run through these tools a little bit

00:07:22,080 --> 00:07:24,400
later

00:07:25,919 --> 00:07:31,919
clang advertises itself as a gcc

00:07:29,680 --> 00:07:33,840
4.2.1 so it's a very important

00:07:31,919 --> 00:07:38,240
distinction so when

00:07:33,840 --> 00:07:38,240
we are compiling software we will see

00:07:39,520 --> 00:07:43,280
these internal compiler defines being

00:07:41,840 --> 00:07:46,879
used

00:07:43,280 --> 00:07:49,440
in several places to find out

00:07:46,879 --> 00:07:50,319
what features are supported by given

00:07:49,440 --> 00:07:52,400
compiler so

00:07:50,319 --> 00:07:54,160
there is conditional code that might be

00:07:52,400 --> 00:07:55,840
checking for

00:07:54,160 --> 00:07:58,080
underscore underscore new c underscore

00:07:55,840 --> 00:08:01,759
underscore or you know the minor

00:07:58,080 --> 00:08:04,080
version and um and then deciding

00:08:01,759 --> 00:08:05,280
to go one way or another like you know

00:08:04,080 --> 00:08:08,720
supporting

00:08:05,280 --> 00:08:09,759
uh c99 in lining or some things like

00:08:08,720 --> 00:08:13,520
that so

00:08:09,759 --> 00:08:14,080
um be aware that if code is doing this

00:08:13,520 --> 00:08:17,039
then

00:08:14,080 --> 00:08:18,479
um they would be fooled by client

00:08:17,039 --> 00:08:21,759
compiler

00:08:18,479 --> 00:08:24,720
while it might have those features but

00:08:21,759 --> 00:08:26,560
you know your auto detection tools or

00:08:24,720 --> 00:08:27,759
other scripts may not be able to detect

00:08:26,560 --> 00:08:31,840
that

00:08:27,759 --> 00:08:33,360
um clang also exposes some of its own

00:08:31,840 --> 00:08:36,080
internal defines

00:08:33,360 --> 00:08:37,519
um primarily underscored for clang

00:08:36,080 --> 00:08:41,440
underscore underscore

00:08:37,519 --> 00:08:44,560
and that is one um

00:08:41,440 --> 00:08:44,959
define you could use to make sure that

00:08:44,560 --> 00:08:47,040
you know

00:08:44,959 --> 00:08:48,880
you are using a clan compiler or not and

00:08:47,040 --> 00:08:49,440
then there is also clang major clan

00:08:48,880 --> 00:08:53,200
minor

00:08:49,440 --> 00:08:56,480
which is similar to new c minor and

00:08:53,200 --> 00:08:56,480
lucy variables

00:08:56,800 --> 00:09:01,279
to find out which version of clan you're

00:08:58,640 --> 00:09:03,519
running so

00:09:01,279 --> 00:09:05,120
and similarly i talked about clang

00:09:03,519 --> 00:09:08,480
assembler which is a

00:09:05,120 --> 00:09:10,160
internal assembler for example it's it's

00:09:08,480 --> 00:09:11,120
limited in several cents and it's

00:09:10,160 --> 00:09:14,880
different

00:09:11,120 --> 00:09:17,680
from a new assembler talking of arm

00:09:14,880 --> 00:09:18,399
it only supports unified syntax so if

00:09:17,680 --> 00:09:22,720
you have

00:09:18,399 --> 00:09:26,720
um you know some uh in line assembly

00:09:22,720 --> 00:09:28,080
or assembly mixed code you pass through

00:09:26,720 --> 00:09:31,760
clang it may not

00:09:28,080 --> 00:09:33,200
accept it uh it is a single pass

00:09:31,760 --> 00:09:34,800
assembler

00:09:33,200 --> 00:09:36,880
what that means is you know if you are

00:09:34,800 --> 00:09:38,880
doing some simple calculations based on

00:09:36,880 --> 00:09:41,760
distance that is very common in

00:09:38,880 --> 00:09:43,200
in assembly files it may not be able to

00:09:41,760 --> 00:09:46,320
handle that

00:09:43,200 --> 00:09:48,880
and so

00:09:46,320 --> 00:09:50,800
usually what i've seen is when you have

00:09:48,880 --> 00:09:54,080
files that are written

00:09:50,800 --> 00:09:55,120
in pure assembly or oriented toward

00:09:54,080 --> 00:09:56,320
assembly

00:09:55,120 --> 00:09:58,880
you might find these kind of

00:09:56,320 --> 00:10:01,200
incompatibilities they are addressable

00:09:58,880 --> 00:10:02,000
but they might show up as errors at the

00:10:01,200 --> 00:10:04,240
very

00:10:02,000 --> 00:10:05,519
onset when you're putting a software to

00:10:04,240 --> 00:10:08,800
it so

00:10:05,519 --> 00:10:11,920
um but the good news is that clan can

00:10:08,800 --> 00:10:15,120
uh work with say new assembler so

00:10:11,920 --> 00:10:17,839
you can ask it uh with disable uh

00:10:15,120 --> 00:10:20,480
disable actually internal assembler with

00:10:17,839 --> 00:10:22,959
half no integrated ais option once you

00:10:20,480 --> 00:10:26,640
pass it on it will expect you to provide

00:10:22,959 --> 00:10:27,279
a genuine assembler during the assembly

00:10:26,640 --> 00:10:29,519
step

00:10:27,279 --> 00:10:31,279
and if you build the tool chain

00:10:29,519 --> 00:10:34,720
correctly

00:10:31,279 --> 00:10:34,720
it will automatically find it

00:10:35,680 --> 00:10:41,680
um so now i'm moving on to a little bit

00:10:38,959 --> 00:10:42,720
on the kernel side so there was an

00:10:41,680 --> 00:10:44,880
effort for

00:10:42,720 --> 00:10:46,000
llbm linux that was started a few years

00:10:44,880 --> 00:10:49,360
ago

00:10:46,000 --> 00:10:51,200
and and then now um there are several

00:10:49,360 --> 00:10:52,959
community members who are interested in

00:10:51,200 --> 00:10:55,040
in making sure that linux kernel can

00:10:52,959 --> 00:10:58,320
compile with clang

00:10:55,040 --> 00:11:01,519
and there is this landing page now

00:10:58,320 --> 00:11:05,440
called clang built linux

00:11:01,519 --> 00:11:09,279
and so what this is it is basically

00:11:05,440 --> 00:11:11,839
making sure that um it is

00:11:09,279 --> 00:11:12,880
running a continuous integration job

00:11:11,839 --> 00:11:16,000
that is building

00:11:12,880 --> 00:11:17,360
various configurations of the kernel

00:11:16,000 --> 00:11:20,000
using clan compiler

00:11:17,360 --> 00:11:22,320
and other clang tools so there are

00:11:20,000 --> 00:11:22,880
options that are introduced in kernel to

00:11:22,320 --> 00:11:26,240
build

00:11:22,880 --> 00:11:29,600
and just with clang tools

00:11:26,240 --> 00:11:32,959
and it exercises all those

00:11:29,600 --> 00:11:35,120
options and and reports back on

00:11:32,959 --> 00:11:36,480
the build status it uses travis to do

00:11:35,120 --> 00:11:38,399
that

00:11:36,480 --> 00:11:40,160
so if you are interested in following

00:11:38,399 --> 00:11:40,720
what all different combinations it is

00:11:40,160 --> 00:11:42,640
checking

00:11:40,720 --> 00:11:44,880
please go to this link that i provided

00:11:42,640 --> 00:11:44,880
here

00:11:45,360 --> 00:11:50,320
there is the issue issues tracker that's

00:11:48,240 --> 00:11:53,680
using github issues so

00:11:50,320 --> 00:11:56,560
if you are interested in this effort

00:11:53,680 --> 00:11:57,920
use it on file issues over there if you

00:11:56,560 --> 00:12:01,680
find an issue in your

00:11:57,920 --> 00:12:01,680
own bills or whatever

00:12:02,240 --> 00:12:08,160
if you are preparing patches to

00:12:05,760 --> 00:12:10,399
you know fix some things in linux kernel

00:12:08,160 --> 00:12:12,959
with clang

00:12:10,399 --> 00:12:14,079
submit those patches upstream into lkml

00:12:12,959 --> 00:12:17,040
directly so

00:12:14,079 --> 00:12:17,600
um github issues is to track those you

00:12:17,040 --> 00:12:20,160
know what

00:12:17,600 --> 00:12:21,760
what all issues are pending but if you

00:12:20,160 --> 00:12:25,200
have patches then

00:12:21,760 --> 00:12:26,160
you know it's a it's a fork of uh lenses

00:12:25,200 --> 00:12:28,240
tree but

00:12:26,160 --> 00:12:29,440
uh it doesn't mean they may accept the

00:12:28,240 --> 00:12:32,800
pull request as a

00:12:29,440 --> 00:12:34,639
you know placeholder for a patch

00:12:32,800 --> 00:12:35,839
but if you want it to be included

00:12:34,639 --> 00:12:37,760
upstream then

00:12:35,839 --> 00:12:39,440
directly go to lcml and submit those

00:12:37,760 --> 00:12:40,800
patches over there

00:12:39,440 --> 00:12:43,120
you could take the help from the

00:12:40,800 --> 00:12:45,040
community if you want to make sure that

00:12:43,120 --> 00:12:47,920
your patch is in good shape to be

00:12:45,040 --> 00:12:47,920
submitted upstream

00:12:49,360 --> 00:12:54,480
so clang build linux is a snapshot i've

00:12:52,399 --> 00:12:56,720
given here there's a wiki you know you

00:12:54,480 --> 00:12:59,920
can learn about how to compile

00:12:56,720 --> 00:13:01,600
the kernel using clang and

00:12:59,920 --> 00:13:04,720
what all repos it does there's a mailing

00:13:01,600 --> 00:13:06,240
list and there's irc as well

00:13:04,720 --> 00:13:07,839
more importantly there is actually a

00:13:06,240 --> 00:13:11,200
bi-weekly um

00:13:07,839 --> 00:13:13,360
meeting that is held online

00:13:11,200 --> 00:13:15,200
and you know a lot of these issues get

00:13:13,360 --> 00:13:17,360
discussed over there and status gets

00:13:15,200 --> 00:13:19,519
discussed so if you are interested to

00:13:17,360 --> 00:13:22,240
become active you know you could you're

00:13:19,519 --> 00:13:26,079
very welcome to join that

00:13:22,240 --> 00:13:30,240
right now uh arm art 64

00:13:26,079 --> 00:13:34,800
and x86 x86 64. those are primarily

00:13:30,240 --> 00:13:38,240
um tier one targets i would say and that

00:13:34,800 --> 00:13:41,360
can compile with clang and they are

00:13:38,240 --> 00:13:43,680
fairly in good shape where you know they

00:13:41,360 --> 00:13:45,279
can boot and and all the features are

00:13:43,680 --> 00:13:48,320
working fine

00:13:45,279 --> 00:13:50,560
um then

00:13:48,320 --> 00:13:51,600
there is a list actually a big list that

00:13:50,560 --> 00:13:55,120
you can find there

00:13:51,600 --> 00:13:56,880
and um you can see that limited test

00:13:55,120 --> 00:13:59,680
configurations are available for

00:13:56,880 --> 00:14:00,959
power pc and mips and this five is in

00:13:59,680 --> 00:14:03,920
progress um

00:14:00,959 --> 00:14:04,639
and there is a lot of interest in there

00:14:03,920 --> 00:14:07,040
and if you

00:14:04,639 --> 00:14:08,399
have other architectures you know that

00:14:07,040 --> 00:14:11,120
are supported by

00:14:08,399 --> 00:14:13,120
clang but and and linux as well but

00:14:11,120 --> 00:14:16,800
there doesn't exist a build

00:14:13,120 --> 00:14:20,160
for those in here contribute

00:14:16,800 --> 00:14:23,040
so this is a good effort to getting

00:14:20,160 --> 00:14:23,920
kernel compiled with clan there are

00:14:23,040 --> 00:14:27,279
several talks

00:14:23,920 --> 00:14:30,320
that has been done there in

00:14:27,279 --> 00:14:33,440
various conferences so

00:14:30,320 --> 00:14:36,480
feel free to search for those especially

00:14:33,440 --> 00:14:39,440
recently there was a talk on llvm meet

00:14:36,480 --> 00:14:40,399
there was also a talk on there was

00:14:39,440 --> 00:14:44,079
actually a

00:14:40,399 --> 00:14:47,839
a mini conference at plumbers where

00:14:44,079 --> 00:14:47,839
this was discussed in detail as well

00:14:48,800 --> 00:14:53,920
so um now i'll move on to building the

00:14:52,480 --> 00:14:57,279
platform

00:14:53,920 --> 00:14:59,519
and there are actually

00:14:57,279 --> 00:15:01,120
a few options that are out there in

00:14:59,519 --> 00:15:01,600
terms of infrastructures that you could

00:15:01,120 --> 00:15:04,720
use

00:15:01,600 --> 00:15:07,440
and gen 2 has a clang overlay

00:15:04,720 --> 00:15:08,959
which is also you know in a way used by

00:15:07,440 --> 00:15:12,000
chrome os

00:15:08,959 --> 00:15:15,440
and debian is actually building

00:15:12,000 --> 00:15:17,680
uh clang based packages and archives

00:15:15,440 --> 00:15:18,880
and majaya is another one which is

00:15:17,680 --> 00:15:21,600
actually

00:15:18,880 --> 00:15:25,120
ahead of all where it is using clang as

00:15:21,600 --> 00:15:28,639
its default system compiler already for

00:15:25,120 --> 00:15:30,320
its targets and um

00:15:28,639 --> 00:15:32,639
you could also use the octoproject and

00:15:30,320 --> 00:15:35,839
as i said that's what i'm going to

00:15:32,639 --> 00:15:37,680
use throughout this presentation

00:15:35,839 --> 00:15:39,680
and you'd also use some of your own if

00:15:37,680 --> 00:15:40,240
you want because there are clang based

00:15:39,680 --> 00:15:42,720
tool

00:15:40,240 --> 00:15:44,720
chains that are available uh clang is

00:15:42,720 --> 00:15:45,920
inherently across compiler so there is

00:15:44,720 --> 00:15:49,600
no big deal

00:15:45,920 --> 00:15:50,959
in creating a cross compiler using clang

00:15:49,600 --> 00:15:53,120
[Music]

00:15:50,959 --> 00:15:54,000
and you could set up your own if you if

00:15:53,120 --> 00:15:56,320
you want to build

00:15:54,000 --> 00:15:59,600
something your own or you might have

00:15:56,320 --> 00:15:59,600
your internal build systems

00:16:00,200 --> 00:16:06,160
[Music]

00:16:03,519 --> 00:16:09,040
in the octo project there is a separate

00:16:06,160 --> 00:16:11,120
layer for clang it's called mata clang

00:16:09,040 --> 00:16:13,519
and i maintain it

00:16:11,120 --> 00:16:14,320
what it does is it provides the overlay

00:16:13,519 --> 00:16:17,279
um

00:16:14,320 --> 00:16:18,240
for adding all the crank tool chain

00:16:17,279 --> 00:16:22,000
related

00:16:18,240 --> 00:16:24,000
packages through yocto recipes

00:16:22,000 --> 00:16:25,199
in addition it also provides additional

00:16:24,000 --> 00:16:28,240
tools that we

00:16:25,199 --> 00:16:30,000
discussed a little while earlier for

00:16:28,240 --> 00:16:32,240
example the debugger

00:16:30,000 --> 00:16:33,839
the lld linker and other runtime

00:16:32,240 --> 00:16:36,880
libraries

00:16:33,839 --> 00:16:39,920
there is also some packages

00:16:36,880 --> 00:16:40,800
that you will find in there that are

00:16:39,920 --> 00:16:42,560
made available

00:16:40,800 --> 00:16:45,040
those are the tools that are written

00:16:42,560 --> 00:16:47,360
based using plan

00:16:45,040 --> 00:16:49,120
and so you will find those recipes over

00:16:47,360 --> 00:16:51,920
there but primary purpose

00:16:49,120 --> 00:16:54,240
of this layer is to provide a tool chain

00:16:51,920 --> 00:16:57,600
um

00:16:54,240 --> 00:17:00,639
for your project so

00:16:57,600 --> 00:17:02,320
you can build your project using it

00:17:00,639 --> 00:17:05,199
which means it will be the internal

00:17:02,320 --> 00:17:07,360
tool chain and you could also make it as

00:17:05,199 --> 00:17:10,640
part of your

00:17:07,360 --> 00:17:11,839
sdks or extensible sdks you know that

00:17:10,640 --> 00:17:16,799
you can build out of your

00:17:11,839 --> 00:17:16,799
project and we'll go over that later

00:17:17,439 --> 00:17:24,640
setup is very simple um you just clone

00:17:20,880 --> 00:17:27,760
the um pocky reference disk pro

00:17:24,640 --> 00:17:30,799
and then you clone um

00:17:27,760 --> 00:17:34,080
clang layer and you add it to the

00:17:30,799 --> 00:17:36,240
to the layer mix into your project so

00:17:34,080 --> 00:17:38,480
it doesn't depend on any other layer

00:17:36,240 --> 00:17:41,840
besides the core layer

00:17:38,480 --> 00:17:43,280
so you could just clone the you know the

00:17:41,840 --> 00:17:45,919
pocky depot and

00:17:43,280 --> 00:17:46,799
include it and that's all you need in

00:17:45,919 --> 00:17:50,720
terms of

00:17:46,799 --> 00:17:53,360
setup um however

00:17:50,720 --> 00:17:54,480
it's an inert layer which means that

00:17:53,360 --> 00:17:56,160
when it gets added

00:17:54,480 --> 00:17:58,160
it shouldn't be impacting if you're not

00:17:56,160 --> 00:18:01,200
using it so

00:17:58,160 --> 00:18:02,720
as a result your default compiler is

00:18:01,200 --> 00:18:04,880
still gcc

00:18:02,720 --> 00:18:07,039
um even if it is added in the previous

00:18:04,880 --> 00:18:09,600
steps so in order for it

00:18:07,039 --> 00:18:10,400
for you to make it active you would want

00:18:09,600 --> 00:18:12,880
to add

00:18:10,400 --> 00:18:15,360
something like toolchain equals clang

00:18:12,880 --> 00:18:17,840
into your local configuration metadata

00:18:15,360 --> 00:18:19,200
once you set that up what it instructs

00:18:17,840 --> 00:18:22,000
the system is that

00:18:19,200 --> 00:18:24,160
from here on uh use clang as the default

00:18:22,000 --> 00:18:26,960
compiler

00:18:24,160 --> 00:18:28,080
and as you can see there are two options

00:18:26,960 --> 00:18:31,120
for this you could also

00:18:28,080 --> 00:18:32,400
set tool chain equal to gcc so in some

00:18:31,120 --> 00:18:34,240
cases we'll go on

00:18:32,400 --> 00:18:35,520
later where some packages are not

00:18:34,240 --> 00:18:38,160
compatible with clang

00:18:35,520 --> 00:18:38,960
you would just use tool chain equals gcc

00:18:38,160 --> 00:18:41,840
and

00:18:38,960 --> 00:18:44,480
this setting will not be effective for

00:18:41,840 --> 00:18:47,600
that particular package

00:18:44,480 --> 00:18:50,559
and the another variable of interest

00:18:47,600 --> 00:18:51,679
is runtime equals llvm when you select

00:18:50,559 --> 00:18:54,320
that

00:18:51,679 --> 00:18:55,440
you are basically asking defaulting to

00:18:54,320 --> 00:18:58,720
compiler rt

00:18:55,440 --> 00:19:00,640
to provide you the c runtime and libc

00:18:58,720 --> 00:19:03,919
plus plus

00:19:00,640 --> 00:19:07,200
to provide the c plus plus runtime and

00:19:03,919 --> 00:19:10,320
llvm unwind to provide you the unwinding

00:19:07,200 --> 00:19:13,919
runtime so this tries to provide all the

00:19:10,320 --> 00:19:16,080
cc plus runtime from llvm project

00:19:13,919 --> 00:19:17,200
that's not the default though default is

00:19:16,080 --> 00:19:19,760
to use the

00:19:17,200 --> 00:19:21,280
new runtime so runtime equals new is the

00:19:19,760 --> 00:19:24,960
default

00:19:21,280 --> 00:19:27,360
um and we'll talk about

00:19:24,960 --> 00:19:29,360
you know various combinations and the

00:19:27,360 --> 00:19:32,480
issues they might have

00:19:29,360 --> 00:19:36,240
why these options are chosen as to

00:19:32,480 --> 00:19:36,240
remain as canoe to begin with

00:19:36,320 --> 00:19:41,280
building an image is easy um like if you

00:19:39,280 --> 00:19:44,000
work with your project you will just

00:19:41,280 --> 00:19:44,400
build an image that you're building and

00:19:44,000 --> 00:19:47,280
um

00:19:44,400 --> 00:19:48,640
if you build a cover image shadow it is

00:19:47,280 --> 00:19:52,880
going to build this

00:19:48,640 --> 00:19:55,919
image using clan which means

00:19:52,880 --> 00:19:59,280
all the packages that you build

00:19:55,919 --> 00:20:01,360
for target will be built using clan

00:19:59,280 --> 00:20:03,120
the native packages there are certain

00:20:01,360 --> 00:20:05,120
packages it will build for your build

00:20:03,120 --> 00:20:07,120
host they will not be built using clang

00:20:05,120 --> 00:20:10,720
they will still be built using

00:20:07,120 --> 00:20:14,799
a gcc on your on your host

00:20:10,720 --> 00:20:18,240
or your host gcc so to speak

00:20:14,799 --> 00:20:21,919
and so clang will be effective to build

00:20:18,240 --> 00:20:24,720
only the target packages so that's a a

00:20:21,919 --> 00:20:25,600
distinction that you should be aware of

00:20:24,720 --> 00:20:27,679
um

00:20:25,600 --> 00:20:29,039
and then you can run the image by

00:20:27,679 --> 00:20:31,280
default it will build for

00:20:29,039 --> 00:20:32,960
a kimi machine you can just run it and

00:20:31,280 --> 00:20:37,600
run kimi and it should

00:20:32,960 --> 00:20:40,159
boot and you could also build sdk

00:20:37,600 --> 00:20:43,039
and these are standard steps to build an

00:20:40,159 --> 00:20:45,679
sdk once you build the sdk

00:20:43,039 --> 00:20:46,559
there's a variable called clang sdk if

00:20:45,679 --> 00:20:48,880
you set that

00:20:46,559 --> 00:20:51,280
in your local.com then it will also

00:20:48,880 --> 00:20:53,280
insert clang into your sdks

00:20:51,280 --> 00:20:54,720
as a alternative tool chain so you'll

00:20:53,280 --> 00:20:57,520
basically have both

00:20:54,720 --> 00:21:00,320
gcc and clan compilers available as part

00:20:57,520 --> 00:21:00,320
of the sdk

00:21:01,440 --> 00:21:09,600
um there are a few exceptions

00:21:06,480 --> 00:21:10,960
actually and this list has been reducing

00:21:09,600 --> 00:21:14,799
with every release of

00:21:10,960 --> 00:21:16,000
clang and other software so which means

00:21:14,799 --> 00:21:18,960
that patches are flowing

00:21:16,000 --> 00:21:22,000
upstream and they're getting fixed to

00:21:18,960 --> 00:21:25,679
build with clang which is a good news

00:21:22,000 --> 00:21:28,480
in some cases there are just tweaks

00:21:25,679 --> 00:21:31,120
to flags because some package might be

00:21:28,480 --> 00:21:33,520
using a warning variable which is not

00:21:31,120 --> 00:21:37,200
available in clang

00:21:33,520 --> 00:21:38,799
or vice versa so we are basically

00:21:37,200 --> 00:21:40,960
tweaking those flags

00:21:38,799 --> 00:21:41,919
it still is using clang to compile that

00:21:40,960 --> 00:21:44,400
but

00:21:41,919 --> 00:21:47,039
you know removing those options from the

00:21:44,400 --> 00:21:47,039
from the build

00:21:47,679 --> 00:21:51,440
but some of them outright override the

00:21:50,320 --> 00:21:53,280
compiler

00:21:51,440 --> 00:21:55,760
and they would be setting the tool chain

00:21:53,280 --> 00:21:58,960
variable we discussed to gcc

00:21:55,760 --> 00:22:02,559
explicitly for that particular variable

00:21:58,960 --> 00:22:04,240
for that given recipe so

00:22:02,559 --> 00:22:05,919
to look into a little bit more detail

00:22:04,240 --> 00:22:09,440
what which one of those are

00:22:05,919 --> 00:22:10,799
g lipsy if you are building a glib c

00:22:09,440 --> 00:22:14,320
based system

00:22:10,799 --> 00:22:16,400
um glibc can't be built yet with the

00:22:14,320 --> 00:22:17,919
clang there has been some efforts in the

00:22:16,400 --> 00:22:20,080
past

00:22:17,919 --> 00:22:21,760
but i think we haven't gotten to a point

00:22:20,080 --> 00:22:22,480
where we can get a fully functional

00:22:21,760 --> 00:22:24,880
glibc

00:22:22,480 --> 00:22:26,400
working with confinement compiled with

00:22:24,880 --> 00:22:29,600
clang

00:22:26,400 --> 00:22:32,799
um muscle

00:22:29,600 --> 00:22:36,240
however uh is another option in

00:22:32,799 --> 00:22:39,520
in yakto and that does compile with the

00:22:36,240 --> 00:22:41,679
clank so if you are choosing or you're

00:22:39,520 --> 00:22:44,720
already based on on a muscle system

00:22:41,679 --> 00:22:47,200
you are in good luck here

00:22:44,720 --> 00:22:47,760
once you start using a clang it should

00:22:47,200 --> 00:22:50,480
build

00:22:47,760 --> 00:22:50,480
muscle fine

00:22:51,039 --> 00:22:56,400
gcc runtime as i mentioned

00:22:54,320 --> 00:22:58,080
that's the default we use today so these

00:22:56,400 --> 00:23:00,400
are things like libgcc

00:22:58,080 --> 00:23:03,039
and lib standard c plus plus and you

00:23:00,400 --> 00:23:06,640
know other language runtimes

00:23:03,039 --> 00:23:09,120
that gcc provides and they still need

00:23:06,640 --> 00:23:11,039
gcc to build

00:23:09,120 --> 00:23:12,320
and so you'll see like if you have

00:23:11,039 --> 00:23:14,480
compiler runtime

00:23:12,320 --> 00:23:17,919
recipes in there they're still

00:23:14,480 --> 00:23:17,919
hard-coded to use gcc

00:23:18,320 --> 00:23:22,559
we are still using gcc to compile u-boot

00:23:21,919 --> 00:23:25,760
although

00:23:22,559 --> 00:23:27,679
some configs do work and there is

00:23:25,760 --> 00:23:31,679
actually a detailed list here

00:23:27,679 --> 00:23:34,320
how to enable client to build you boot

00:23:31,679 --> 00:23:35,120
we haven't enabled it in default by

00:23:34,320 --> 00:23:38,799
defaulting

00:23:35,120 --> 00:23:41,440
in mata clang the reason is because um

00:23:38,799 --> 00:23:44,159
u-boot is used for many many different

00:23:41,440 --> 00:23:47,279
machines and all of them may not be

00:23:44,159 --> 00:23:47,679
available maybe one of these days i

00:23:47,279 --> 00:23:49,520
would

00:23:47,679 --> 00:23:51,200
enable it for a particular machine and

00:23:49,520 --> 00:23:53,120
see how it goes

00:23:51,200 --> 00:23:55,520
alfie rules is another package that is

00:23:53,120 --> 00:23:59,200
used by a lot of tools

00:23:55,520 --> 00:24:01,440
to poke at the you know objects and then

00:23:59,200 --> 00:24:05,200
binaries

00:24:01,440 --> 00:24:05,200
and it doesn't work with um

00:24:05,279 --> 00:24:10,640
with clang yet um so

00:24:08,799 --> 00:24:12,400
you know there are few others but very

00:24:10,640 --> 00:24:15,279
handful of those packages where

00:24:12,400 --> 00:24:16,159
you really really would need you know

00:24:15,279 --> 00:24:19,679
clang is not

00:24:16,159 --> 00:24:21,919
building them at all grub again

00:24:19,679 --> 00:24:24,000
same like eboot we have same story here

00:24:21,919 --> 00:24:27,840
it does work i've

00:24:24,000 --> 00:24:31,360
actually compiled the latest master

00:24:27,840 --> 00:24:34,640
with latest clank 10

00:24:31,360 --> 00:24:38,159
it compiled fine i just had to disable

00:24:34,640 --> 00:24:40,720
w error because client finds new

00:24:38,159 --> 00:24:44,000
warnings and treats them as errors and

00:24:40,720 --> 00:24:46,480
once you disable that it will fine

00:24:44,000 --> 00:24:47,760
python 3 is another key package that we

00:24:46,480 --> 00:24:50,960
are building with

00:24:47,760 --> 00:24:54,720
gcc the reason there is that

00:24:50,960 --> 00:24:57,360
we cross compiled python and

00:24:54,720 --> 00:24:58,559
we actually enable profile guided

00:24:57,360 --> 00:25:00,320
optimizations for

00:24:58,559 --> 00:25:02,400
building it because you know python is

00:25:00,320 --> 00:25:06,000
very core to us so we want

00:25:02,400 --> 00:25:09,440
most optimized python on the system

00:25:06,000 --> 00:25:11,600
and so for that we run those uh pgo

00:25:09,440 --> 00:25:15,520
workloads in key mu

00:25:11,600 --> 00:25:16,080
and for when those workloads are built

00:25:15,520 --> 00:25:19,520
using

00:25:16,080 --> 00:25:22,640
clang uh qme crashes and

00:25:19,520 --> 00:25:24,960
we haven't yet debugged y but i think

00:25:22,640 --> 00:25:25,840
there is something there to fix once we

00:25:24,960 --> 00:25:28,880
fix that

00:25:25,840 --> 00:25:31,120
we should be able to build python 3

00:25:28,880 --> 00:25:32,470
with clang it builds fine if you don't

00:25:31,120 --> 00:25:33,760
if you

00:25:32,470 --> 00:25:38,400
[Music]

00:25:33,760 --> 00:25:38,400
disable pgo to build it

00:25:38,720 --> 00:25:43,360
then you would see in that particular

00:25:40,240 --> 00:25:45,440
file i mentioned non-clangable.conf

00:25:43,360 --> 00:25:48,080
there are many packages that are just

00:25:45,440 --> 00:25:52,159
disabling the integrated assembler

00:25:48,080 --> 00:25:54,640
by passing the no integrated as flag

00:25:52,159 --> 00:25:56,320
and that is for obviously the reasons i

00:25:54,640 --> 00:25:59,840
mentioned earlier where it is using

00:25:56,320 --> 00:25:59,840
inline assembly which is not

00:26:00,400 --> 00:26:06,320
which is probably not understood by the

00:26:03,120 --> 00:26:06,320
internal assembler yet

00:26:06,720 --> 00:26:12,240
and in many cases your c code might have

00:26:10,799 --> 00:26:17,200
in line assembly

00:26:12,240 --> 00:26:17,200
you know that is not understood um

00:26:17,440 --> 00:26:21,840
by by clang itself so because you know

00:26:19,760 --> 00:26:24,159
the inline assembly

00:26:21,840 --> 00:26:26,880
it tries to match to whatever gcc does

00:26:24,159 --> 00:26:29,120
but in many cases

00:26:26,880 --> 00:26:30,559
the code that is written using inline

00:26:29,120 --> 00:26:32,559
assembly

00:26:30,559 --> 00:26:34,480
takes advantage of some a lot of

00:26:32,559 --> 00:26:35,679
undocumented features then you know it

00:26:34,480 --> 00:26:39,679
might not be available

00:26:35,679 --> 00:26:44,000
in clan

00:26:39,679 --> 00:26:47,120
um seat on time so the

00:26:44,000 --> 00:26:48,960
this is actually you know your crt begin

00:26:47,120 --> 00:26:50,840
and crtn so if you

00:26:48,960 --> 00:26:52,000
dump when you link a particular

00:26:50,840 --> 00:26:54,480
executables

00:26:52,000 --> 00:26:56,240
these are your startup and and routines

00:26:54,480 --> 00:26:59,919
that gets linked in

00:26:56,240 --> 00:27:02,159
uh into the system into the application

00:26:59,919 --> 00:27:02,159
and

00:27:03,039 --> 00:27:10,080
these are currently used um

00:27:06,080 --> 00:27:12,880
from lib gcc package there is

00:27:10,080 --> 00:27:13,679
crt begin and crt end that are provided

00:27:12,880 --> 00:27:16,960
by

00:27:13,679 --> 00:27:20,159
compiler rt and we

00:27:16,960 --> 00:27:22,080
currently do not use them this is

00:27:20,159 --> 00:27:23,279
one of the to-do's we would like to use

00:27:22,080 --> 00:27:24,920
them

00:27:23,279 --> 00:27:26,720
in future

00:27:24,920 --> 00:27:28,799
[Music]

00:27:26,720 --> 00:27:30,399
so right now if you see when we build

00:27:28,799 --> 00:27:35,840
compiler rt

00:27:30,399 --> 00:27:35,840
then crt feature is disabled by default

00:27:35,919 --> 00:27:39,279
but if you enable it then you will start

00:27:38,399 --> 00:27:43,919
getting

00:27:39,279 --> 00:27:47,039
this crt bikini and crt and objects

00:27:43,919 --> 00:27:50,000
compiled and made part of compiler rt

00:27:47,039 --> 00:27:51,360
as well but it would also require a

00:27:50,000 --> 00:27:54,399
little bit of

00:27:51,360 --> 00:27:56,159
hand holding because um in some cases we

00:27:54,399 --> 00:27:58,799
might want to include both

00:27:56,159 --> 00:28:00,640
crts like you know compiler rt and

00:27:58,799 --> 00:28:03,440
libgcc

00:28:00,640 --> 00:28:04,880
into the system where built-ins are

00:28:03,440 --> 00:28:07,520
provided by

00:28:04,880 --> 00:28:09,840
compiler archi but the unwinding is

00:28:07,520 --> 00:28:10,880
provided by leap gcc and so on so forth

00:28:09,840 --> 00:28:12,720
so i think there

00:28:10,880 --> 00:28:14,000
has to be some careful crafting that we

00:28:12,720 --> 00:28:16,480
have to do

00:28:14,000 --> 00:28:17,120
but this is certainly something of

00:28:16,480 --> 00:28:20,559
interest

00:28:17,120 --> 00:28:23,760
in future um

00:28:20,559 --> 00:28:24,480
as i mentioned uh gnu runtime is the

00:28:23,760 --> 00:28:28,080
default

00:28:24,480 --> 00:28:31,120
it works well this is basically clang

00:28:28,080 --> 00:28:32,799
relying upon lib gcc and then

00:28:31,120 --> 00:28:35,360
lipstick plus plus to provide those

00:28:32,799 --> 00:28:35,360
runtimes

00:28:35,440 --> 00:28:38,880
uh mixing both may not work uh really

00:28:38,320 --> 00:28:41,919
well

00:28:38,880 --> 00:28:43,840
we haven't tried that um file clang

00:28:41,919 --> 00:28:44,799
works fine with leap c plus plus and lip

00:28:43,840 --> 00:28:47,679
strip plus plus

00:28:44,799 --> 00:28:49,200
other way around is a less tested

00:28:47,679 --> 00:28:51,760
combination

00:28:49,200 --> 00:28:54,559
so that's where mixing both may be a

00:28:51,760 --> 00:28:54,559
little troublesome

00:28:54,880 --> 00:28:58,799
the other option is to use llvm runtime

00:28:57,440 --> 00:29:02,640
which means your system

00:28:58,799 --> 00:29:04,559
has libsy plus plus as default um

00:29:02,640 --> 00:29:06,399
there is one issue we have in there

00:29:04,559 --> 00:29:09,520
where if a package

00:29:06,399 --> 00:29:12,320
doesn't build with it then we have to

00:29:09,520 --> 00:29:14,640
include both of both the runtimes

00:29:12,320 --> 00:29:14,640
and

00:29:15,440 --> 00:29:20,000
if there are two packages say one a

00:29:18,320 --> 00:29:22,159
built with libsy plus plus another one

00:29:20,000 --> 00:29:24,159
built with lipstick plus plus

00:29:22,159 --> 00:29:26,559
and then there is third package which

00:29:24,159 --> 00:29:29,200
depends on both of them

00:29:26,559 --> 00:29:31,760
then which headers to use right so there

00:29:29,200 --> 00:29:35,360
are little complex situations there

00:29:31,760 --> 00:29:35,840
um we do provide it although you know

00:29:35,360 --> 00:29:38,640
that

00:29:35,840 --> 00:29:40,080
some applications might might link with

00:29:38,640 --> 00:29:42,320
it but at system level

00:29:40,080 --> 00:29:43,520
i still see that you know the lipstick

00:29:42,320 --> 00:29:46,720
plus plus is still

00:29:43,520 --> 00:29:49,760
uh used as default um

00:29:46,720 --> 00:29:50,559
we have actually tried using lip c plus

00:29:49,760 --> 00:29:53,120
plus as well

00:29:50,559 --> 00:29:54,720
we can get system working with that to a

00:29:53,120 --> 00:29:56,320
certain extent but then

00:29:54,720 --> 00:29:58,399
many of the packages you know you might

00:29:56,320 --> 00:30:01,039
find this build issues that you might

00:29:58,399 --> 00:30:01,039
have to address

00:30:02,480 --> 00:30:07,760
the llvm linker

00:30:05,840 --> 00:30:10,720
it is built as part of the compiler tool

00:30:07,760 --> 00:30:13,840
chain when you use mericlang

00:30:10,720 --> 00:30:16,880
but it is inert by default so you could

00:30:13,840 --> 00:30:18,480
enable it by fu's ld flag which is

00:30:16,880 --> 00:30:22,000
similar to what you have in gcc

00:30:18,480 --> 00:30:25,200
so you can say f use ald equals lld

00:30:22,000 --> 00:30:27,360
and you can enable it per package

00:30:25,200 --> 00:30:28,480
means per recipe or you can enable it

00:30:27,360 --> 00:30:31,360
globally

00:30:28,480 --> 00:30:32,320
and uh to make it easy to enable a

00:30:31,360 --> 00:30:34,080
global level

00:30:32,320 --> 00:30:37,120
if there is a distro feature you could

00:30:34,080 --> 00:30:40,470
add lds lld and that would basically

00:30:37,120 --> 00:30:42,240
switch your system link or to use lld

00:30:40,470 --> 00:30:46,480
[Music]

00:30:42,240 --> 00:30:49,600
this works well for x86 64.

00:30:46,480 --> 00:30:51,120
i haven't tried for other architectures

00:30:49,600 --> 00:30:54,240
here

00:30:51,120 --> 00:30:56,480
and similarly there are the minerals

00:30:54,240 --> 00:31:01,120
versions that are available

00:30:56,480 --> 00:31:04,640
the archiver and the symbol

00:31:01,120 --> 00:31:07,519
readers and

00:31:04,640 --> 00:31:09,200
they are actually used when you set tool

00:31:07,519 --> 00:31:12,720
chain equals to client

00:31:09,200 --> 00:31:16,080
so they're already switched by

00:31:12,720 --> 00:31:19,600
the clang system to use

00:31:16,080 --> 00:31:21,519
um there is a lto use case as well that

00:31:19,600 --> 00:31:23,760
is available so there is a

00:31:21,519 --> 00:31:25,120
class available in recipes you can

00:31:23,760 --> 00:31:28,720
inherit lto

00:31:25,120 --> 00:31:32,799
there are two options that it

00:31:28,720 --> 00:31:35,840
exposes thin lto and full lto um

00:31:32,799 --> 00:31:36,640
so thin lto is a faster variant so you

00:31:35,840 --> 00:31:38,559
know

00:31:36,640 --> 00:31:40,399
and full lto will take a lot longer to

00:31:38,559 --> 00:31:42,480
compile might

00:31:40,399 --> 00:31:44,000
need more resources but then it might

00:31:42,480 --> 00:31:47,120
end up with a better

00:31:44,000 --> 00:31:48,480
code in the end more size reductions and

00:31:47,120 --> 00:31:52,320
so on

00:31:48,480 --> 00:31:54,399
thin lto is fast and it might give you

00:31:52,320 --> 00:31:55,919
a good results as well so based on what

00:31:54,399 --> 00:31:57,440
you need you can choose whichever you

00:31:55,919 --> 00:31:59,840
want

00:31:57,440 --> 00:32:01,519
one option that one issue that you will

00:31:59,840 --> 00:32:03,360
generally find is if you enable

00:32:01,519 --> 00:32:06,960
optimization for size

00:32:03,360 --> 00:32:09,200
um somehow client doesn't like that and

00:32:06,960 --> 00:32:11,360
you know enabling lto along with

00:32:09,200 --> 00:32:14,640
optimizations or size

00:32:11,360 --> 00:32:15,519
doesn't yet work there are bugs already

00:32:14,640 --> 00:32:19,360
open in

00:32:15,519 --> 00:32:19,360
llb and bugzilla to address that

00:32:20,080 --> 00:32:23,600
so i talked about additional tools and

00:32:22,240 --> 00:32:26,880
you would see that

00:32:23,600 --> 00:32:27,519
we have these static analyzers and that

00:32:26,880 --> 00:32:30,640
is

00:32:27,519 --> 00:32:33,360
made available and in

00:32:30,640 --> 00:32:34,640
mericlang you have actually option to

00:32:33,360 --> 00:32:37,360
enable it

00:32:34,640 --> 00:32:39,360
so you would similarly inherit scan

00:32:37,360 --> 00:32:41,440
build

00:32:39,360 --> 00:32:43,120
and you can set whether you want to scan

00:32:41,440 --> 00:32:44,480
every package or you want to scan a

00:32:43,120 --> 00:32:47,360
particular package in

00:32:44,480 --> 00:32:49,200
this case i've said scan build and curl

00:32:47,360 --> 00:32:52,080
equals one which means

00:32:49,200 --> 00:32:52,720
it will only enable the static analyzer

00:32:52,080 --> 00:32:55,919
for

00:32:52,720 --> 00:32:57,760
the curl package

00:32:55,919 --> 00:33:00,000
and if you want to disable it you can

00:32:57,760 --> 00:33:01,760
disable it by you know emptying out that

00:33:00,000 --> 00:33:05,120
variable for that particular

00:33:01,760 --> 00:33:06,640
package so um once it has run through

00:33:05,120 --> 00:33:09,200
you can see

00:33:06,640 --> 00:33:10,000
the the results with a task or with the

00:33:09,200 --> 00:33:13,039
xc scan

00:33:10,000 --> 00:33:16,960
view and give it a recipe name what it

00:33:13,039 --> 00:33:16,960
will give you is it will give you a link

00:33:17,039 --> 00:33:22,159
that you can set and you can open that

00:33:19,600 --> 00:33:23,919
in a browser and as given you a snapshot

00:33:22,159 --> 00:33:27,200
here

00:33:23,919 --> 00:33:28,799
for a open ssl scan that i ran and you

00:33:27,200 --> 00:33:31,760
can see that it reported

00:33:28,799 --> 00:33:33,600
some issues so it's a good tool it's

00:33:31,760 --> 00:33:37,360
kind of integrated into the

00:33:33,600 --> 00:33:40,399
meta client as well if you're interested

00:33:37,360 --> 00:33:40,399
you could give it a shot

00:33:42,240 --> 00:33:46,480
extensible sdk as i said earlier

00:33:45,279 --> 00:33:49,600
you know you could install the

00:33:46,480 --> 00:33:49,600
extensible sdk

00:33:49,840 --> 00:33:55,840
you can build it as we covered earlier

00:33:53,440 --> 00:33:57,440
once you install it and make sure that

00:33:55,840 --> 00:34:00,320
clang sdk

00:33:57,440 --> 00:34:02,240
one word equals one is set and then you

00:34:00,320 --> 00:34:04,640
install it once you install

00:34:02,240 --> 00:34:06,320
you will have the clang tools as part of

00:34:04,640 --> 00:34:08,240
the sdk as well

00:34:06,320 --> 00:34:09,679
and as you can see i've given you some

00:34:08,240 --> 00:34:12,800
snapshots here and

00:34:09,679 --> 00:34:13,679
and commands how to install it as well

00:34:12,800 --> 00:34:16,800
as

00:34:13,679 --> 00:34:19,440
uh how to set it up for using

00:34:16,800 --> 00:34:20,240
there are some variables in the

00:34:19,440 --> 00:34:23,359
environment

00:34:20,240 --> 00:34:24,960
that are made available like clang cc

00:34:23,359 --> 00:34:28,480
clanks

00:34:24,960 --> 00:34:30,639
cxx and clank cpp which basically are

00:34:28,480 --> 00:34:33,440
the c compiler c plus compiler and

00:34:30,639 --> 00:34:36,480
preprocessor

00:34:33,440 --> 00:34:38,320
which point to clang by default your

00:34:36,480 --> 00:34:40,560
compiler will still be gcc

00:34:38,320 --> 00:34:42,800
in the sdk so if you are building your

00:34:40,560 --> 00:34:45,040
application and you want to use clang

00:34:42,800 --> 00:34:46,399
um you know you might want to set cc

00:34:45,040 --> 00:34:49,599
equals client cc

00:34:46,399 --> 00:34:52,800
and that will enable it

00:34:49,599 --> 00:34:53,679
clank tidy exe is also made available so

00:34:52,800 --> 00:34:55,839
if you are

00:34:53,679 --> 00:34:58,640
running linters on your source code you

00:34:55,839 --> 00:35:01,680
can use that as well in sdk so

00:34:58,640 --> 00:35:04,079
at this point of time we make it as a

00:35:01,680 --> 00:35:04,880
secondary tool chain but you know in

00:35:04,079 --> 00:35:08,160
future you might

00:35:04,880 --> 00:35:10,079
have you know use clang as a default

00:35:08,160 --> 00:35:12,800
tool chain as well

00:35:10,079 --> 00:35:14,320
but right now we don't do that although

00:35:12,800 --> 00:35:16,400
there are

00:35:14,320 --> 00:35:19,520
tweaks in the system where you can make

00:35:16,400 --> 00:35:19,520
it if you want to do that

00:35:20,720 --> 00:35:28,400
all right so moving on debian

00:35:24,400 --> 00:35:31,599
actually has a pretty

00:35:28,400 --> 00:35:33,040
decent size archives that are now

00:35:31,599 --> 00:35:35,200
buildable with um

00:35:33,040 --> 00:35:37,119
clang so as you can see this is the

00:35:35,200 --> 00:35:40,960
graph i took from

00:35:37,119 --> 00:35:44,960
the clank.debian.net and

00:35:40,960 --> 00:35:48,800
it tracks the progress from

00:35:44,960 --> 00:35:51,680
llvm 2.9 release onwards up until 10

00:35:48,800 --> 00:35:52,640
flank 10. uh recently clan 11 has been

00:35:51,680 --> 00:35:54,880
released but

00:35:52,640 --> 00:35:56,800
you know there is no data for that yet

00:35:54,880 --> 00:35:58,560
but as you can see you know the

00:35:56,800 --> 00:36:00,400
there's a gradual reduction in number of

00:35:58,560 --> 00:36:03,680
failures from 15

00:36:00,400 --> 00:36:07,440
to below you know five percent now um

00:36:03,680 --> 00:36:10,800
and there are around 31 000

00:36:07,440 --> 00:36:13,839
packages that are tried

00:36:10,800 --> 00:36:17,040
and you can see that just a little over

00:36:13,839 --> 00:36:19,280
1000 packages are failing

00:36:17,040 --> 00:36:20,800
to build so there's a good progress in

00:36:19,280 --> 00:36:22,720
there and

00:36:20,800 --> 00:36:24,640
so i'll go over some of the common

00:36:22,720 --> 00:36:27,359
errors that

00:36:24,640 --> 00:36:28,240
are encountered um and that might

00:36:27,359 --> 00:36:29,920
account towards

00:36:28,240 --> 00:36:33,520
you know this thousand dollar packages

00:36:29,920 --> 00:36:36,240
as well so this i make failure

00:36:33,520 --> 00:36:37,760
is actually accounting for uh probably

00:36:36,240 --> 00:36:40,960
uh i don't know how many but

00:36:37,760 --> 00:36:44,640
uh hundreds of these build failures

00:36:40,960 --> 00:36:47,440
i think so um what it is

00:36:44,640 --> 00:36:50,000
internally is that it's expecting a

00:36:47,440 --> 00:36:52,640
traditional

00:36:50,000 --> 00:36:54,480
preprocessor and the preprocessor that

00:36:52,640 --> 00:36:57,920
you have with clang

00:36:54,480 --> 00:36:58,880
is not implementing the traditional you

00:36:57,920 --> 00:37:01,280
know cpp

00:36:58,880 --> 00:37:02,560
syntax so that is actually the crux of

00:37:01,280 --> 00:37:04,800
the problem

00:37:02,560 --> 00:37:06,880
even though there is a traditional cpp

00:37:04,800 --> 00:37:08,800
option but i think

00:37:06,880 --> 00:37:10,160
that doesn't implement whatever i make

00:37:08,800 --> 00:37:13,520
is expecting

00:37:10,160 --> 00:37:16,000
in there so i think there is a defect

00:37:13,520 --> 00:37:19,839
already there and there are workarounds

00:37:16,000 --> 00:37:19,839
um to to address that

00:37:20,079 --> 00:37:23,839
so this is another common error that

00:37:21,760 --> 00:37:25,920
you'll see is that c

00:37:23,839 --> 00:37:27,760
plus plus 11 requires a space between

00:37:25,920 --> 00:37:28,560
literal and identifier so this is a

00:37:27,760 --> 00:37:31,599
warning

00:37:28,560 --> 00:37:33,440
that clang will emit but for whatever

00:37:31,599 --> 00:37:36,800
reason gcc didn't

00:37:33,440 --> 00:37:39,760
and um you could basically disable

00:37:36,800 --> 00:37:41,200
this on command or you can address in

00:37:39,760 --> 00:37:43,599
source code in many cases

00:37:41,200 --> 00:37:45,040
i've seen patches where people have

00:37:43,599 --> 00:37:47,359
addressed it

00:37:45,040 --> 00:37:48,160
and in some cases the warning is

00:37:47,359 --> 00:37:50,720
disabled

00:37:48,160 --> 00:37:52,400
so this could be addressed as well so

00:37:50,720 --> 00:37:55,359
this is also a large set of errors that

00:37:52,400 --> 00:38:00,320
you would see in debian

00:37:55,359 --> 00:38:04,000
and linking with lto fails so i think um

00:38:00,320 --> 00:38:07,440
this is um because of the

00:38:04,000 --> 00:38:07,760
way the cold plug-in is being invoked by

00:38:07,440 --> 00:38:11,920
the

00:38:07,760 --> 00:38:15,200
compiler driver and

00:38:11,920 --> 00:38:16,960
it doesn't find the compiler driver

00:38:15,200 --> 00:38:20,160
actually is not able to find

00:38:16,960 --> 00:38:23,280
the gold plugin

00:38:20,160 --> 00:38:26,400
and the error actually on the top is

00:38:23,280 --> 00:38:30,160
is not indicative of what's going on but

00:38:26,400 --> 00:38:33,440
it's basically if you pass

00:38:30,160 --> 00:38:34,400
absolute path to the plug-in then this

00:38:33,440 --> 00:38:37,760
starts to work

00:38:34,400 --> 00:38:40,000
and um in in yokto i think

00:38:37,760 --> 00:38:42,320
this is already this issue doesn't

00:38:40,000 --> 00:38:46,079
happen

00:38:42,320 --> 00:38:48,320
um so i think this is an

00:38:46,079 --> 00:38:50,320
old problem i'm not sure that we have

00:38:48,320 --> 00:38:52,480
this issue with newer gccs but

00:38:50,320 --> 00:38:54,160
uh depends upon like if you have an old

00:38:52,480 --> 00:38:56,640
version of gcc

00:38:54,160 --> 00:38:58,000
clang always followed the c99 inline

00:38:56,640 --> 00:39:01,680
behavior

00:38:58,000 --> 00:39:05,040
and older versions of gcc

00:39:01,680 --> 00:39:06,079
might default to new 89 so which means

00:39:05,040 --> 00:39:09,599
that

00:39:06,079 --> 00:39:13,040
you know the the um

00:39:09,599 --> 00:39:16,480
the behavior is a little different where

00:39:13,040 --> 00:39:20,000
and the external lines were might work

00:39:16,480 --> 00:39:21,760
differently in 89 model and it might

00:39:20,000 --> 00:39:24,800
cause linking errors

00:39:21,760 --> 00:39:28,560
uh in c99 so what i've seen is that

00:39:24,800 --> 00:39:29,599
recently gc10 and clang behave very

00:39:28,560 --> 00:39:33,040
similar

00:39:29,599 --> 00:39:36,079
by default right so i think these issues

00:39:33,040 --> 00:39:39,440
probably are addressed

00:39:36,079 --> 00:39:43,760
uh one issue that we see in there is

00:39:39,440 --> 00:39:46,880
with respect to percent n printf format

00:39:43,760 --> 00:39:49,040
and clang actually

00:39:46,880 --> 00:39:50,310
errors out and it says that you know in

00:39:49,040 --> 00:39:53,200
star

00:39:50,310 --> 00:39:55,839
[Music]

00:39:53,200 --> 00:39:56,800
is expected which is right and but it

00:39:55,839 --> 00:40:00,320
doesn't

00:39:56,800 --> 00:40:01,200
find it and gcc doesn't um warn about

00:40:00,320 --> 00:40:03,599
this

00:40:01,200 --> 00:40:06,000
and this issue is seen in some packages

00:40:03,599 --> 00:40:06,000
as well

00:40:09,440 --> 00:40:15,760
so um in summary as you can see

00:40:12,880 --> 00:40:16,400
uh clang can be used as a default system

00:40:15,760 --> 00:40:20,720
compiler

00:40:16,400 --> 00:40:24,720
um we've been using it for um for

00:40:20,720 --> 00:40:28,960
for our machines and x86

00:40:24,720 --> 00:40:32,400
64 x86 machines as well as ar 64.

00:40:28,960 --> 00:40:35,839
and i've done runs of

00:40:32,400 --> 00:40:40,079
yocto builds for power pc as well as

00:40:35,839 --> 00:40:44,160
mips and it goes through so today we can

00:40:40,079 --> 00:40:46,240
if you include metaclang for example

00:40:44,160 --> 00:40:47,920
in in yocto then you can do the world

00:40:46,240 --> 00:40:50,240
builds

00:40:47,920 --> 00:40:50,960
except you know the issues i talked

00:40:50,240 --> 00:40:53,119
about

00:40:50,960 --> 00:40:54,640
most of the packages they do compile

00:40:53,119 --> 00:40:57,839
with

00:40:54,640 --> 00:41:01,680
this with clang these days and

00:40:57,839 --> 00:41:04,839
with the newer releases it's going um

00:41:01,680 --> 00:41:06,079
it's getting better so some of the

00:41:04,839 --> 00:41:08,319
things

00:41:06,079 --> 00:41:10,880
some work to do we still need to get

00:41:08,319 --> 00:41:14,000
glibc compiling with this and the

00:41:10,880 --> 00:41:17,200
new runtime or maybe make llvm runtime

00:41:14,000 --> 00:41:20,000
as default and enable you know

00:41:17,200 --> 00:41:23,280
clang-based builds for um

00:41:20,000 --> 00:41:26,160
u-boot as well as um

00:41:23,280 --> 00:41:26,560
grub and other boot loaders once we have

00:41:26,160 --> 00:41:28,079
that

00:41:26,560 --> 00:41:30,240
enabled you know we'll have like

00:41:28,079 --> 00:41:32,640
end-to-end uh perhaps we will be able to

00:41:30,240 --> 00:41:34,560
build using clang so

00:41:32,640 --> 00:41:36,480
that's all i had today so thanks

00:41:34,560 --> 00:41:38,319
everyone and now we can take some

00:41:36,480 --> 00:41:49,599
questions

00:41:38,319 --> 00:41:51,680
thank you

00:41:49,599 --> 00:41:51,680

YouTube URL: https://www.youtube.com/watch?v=B80AFIZ22gQ


