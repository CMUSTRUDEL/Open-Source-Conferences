Title: A New Futex2() System Call - André Almeida, Collabora
Publication date: 2020-11-13
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	A New Futex2() System Call - André Almeida, Collabora
Captions: 
	00:00:05,790 --> 00:00:14,000
[Music]

00:00:13,200 --> 00:00:16,240
hello everyone

00:00:14,000 --> 00:00:18,320
my name is andrea meden i am a current

00:00:16,240 --> 00:00:19,359
engineer at the open source consultancy

00:00:18,320 --> 00:00:21,600
collaborate

00:00:19,359 --> 00:00:23,279
and i'm here today to talk about full

00:00:21,600 --> 00:00:27,920
texture a new full text

00:00:23,279 --> 00:00:30,880
cisco so today i will cover

00:00:27,920 --> 00:00:31,599
first of all what is futex and how it

00:00:30,880 --> 00:00:34,320
works

00:00:31,599 --> 00:00:35,760
internally on the kernel side some

00:00:34,320 --> 00:00:38,480
limitations that were

00:00:35,760 --> 00:00:39,360
found and how we want to fix these

00:00:38,480 --> 00:00:43,680
limitations

00:00:39,360 --> 00:00:47,600
with the news is called the futex2

00:00:43,680 --> 00:00:50,160
so futex means fast use remote taxes

00:00:47,600 --> 00:00:51,199
and is a syscall to provide the user

00:00:50,160 --> 00:00:53,920
space

00:00:51,199 --> 00:00:55,039
means to create several synchronization

00:00:53,920 --> 00:00:59,199
mechanisms

00:00:55,039 --> 00:01:02,879
like taxes conditional variables

00:00:59,199 --> 00:01:05,439
barriers and the same force and

00:01:02,879 --> 00:01:06,000
the semantics on the kernel side is very

00:01:05,439 --> 00:01:07,760
simple

00:01:06,000 --> 00:01:09,040
all the logic should be implemented on

00:01:07,760 --> 00:01:13,520
the user space

00:01:09,040 --> 00:01:16,080
so for the mutex case for instance

00:01:13,520 --> 00:01:16,560
if you didn't find the value that you

00:01:16,080 --> 00:01:20,560
were

00:01:16,560 --> 00:01:23,920
expecting like log free

00:01:20,560 --> 00:01:26,479
you just sleep and wait and

00:01:23,920 --> 00:01:27,439
on the other side if you are releasing

00:01:26,479 --> 00:01:30,720
the lock

00:01:27,439 --> 00:01:33,600
you do a full text wake so you

00:01:30,720 --> 00:01:35,759
wake uh some waders someone that is

00:01:33,600 --> 00:01:38,960
waiting for the lock

00:01:35,759 --> 00:01:41,920
is aiming to be very very fast so

00:01:38,960 --> 00:01:42,720
no cisco is needed on the uncontained

00:01:41,920 --> 00:01:44,560
case

00:01:42,720 --> 00:01:45,840
and this is very important nowadays for

00:01:44,560 --> 00:01:49,200
some platforms

00:01:45,840 --> 00:01:51,680
since um uh after

00:01:49,200 --> 00:01:52,320
a lot of harder bug mitigations doing

00:01:51,680 --> 00:01:55,840
cisco

00:01:52,320 --> 00:01:55,840
is very expensive

00:01:55,920 --> 00:02:02,079
and here we can find we can see an

00:01:58,960 --> 00:02:06,079
example of how to implement a very basic

00:02:02,079 --> 00:02:08,560
multex using full text so on the locks

00:02:06,079 --> 00:02:09,520
the first thing we do we create an

00:02:08,560 --> 00:02:13,120
integer

00:02:09,520 --> 00:02:16,480
of 32 bits that will hold a value

00:02:13,120 --> 00:02:17,440
and this value will set the state of the

00:02:16,480 --> 00:02:21,280
lock

00:02:17,440 --> 00:02:24,239
so we initialize it it with log 3

00:02:21,280 --> 00:02:24,640
and then on the lock side let it do is

00:02:24,239 --> 00:02:27,040
we

00:02:24,640 --> 00:02:28,080
try to do a compare exchange operation

00:02:27,040 --> 00:02:30,800
atomically

00:02:28,080 --> 00:02:31,360
so we want to replace the lock free

00:02:30,800 --> 00:02:34,000
value

00:02:31,360 --> 00:02:34,879
with the lock taken value we've managed

00:02:34,000 --> 00:02:37,519
to do that

00:02:34,879 --> 00:02:40,000
that means that the lock was free and

00:02:37,519 --> 00:02:42,000
this thread was able to take it

00:02:40,000 --> 00:02:43,920
so we don't need to call full text we

00:02:42,000 --> 00:02:46,720
just

00:02:43,920 --> 00:02:47,360
continue the execution of the code

00:02:46,720 --> 00:02:50,400
however

00:02:47,360 --> 00:02:52,480
we failed this compare exchange that

00:02:50,400 --> 00:02:55,280
means that the lock was taken

00:02:52,480 --> 00:02:56,959
so now we are calling we need to call

00:02:55,280 --> 00:02:58,560
full text

00:02:56,959 --> 00:03:00,080
the full text is called so the first

00:02:58,560 --> 00:03:03,200
argument is

00:03:00,080 --> 00:03:04,319
the address of our value because this is

00:03:03,200 --> 00:03:06,800
how we identify

00:03:04,319 --> 00:03:08,319
full text objects inside the kernel by

00:03:06,800 --> 00:03:10,640
this address

00:03:08,319 --> 00:03:13,519
so using the address you can uniquely

00:03:10,640 --> 00:03:15,360
identify any full text for any process

00:03:13,519 --> 00:03:16,879
the first argument is the operation that

00:03:15,360 --> 00:03:20,080
you want to do

00:03:16,879 --> 00:03:22,400
in this case is full text weight

00:03:20,080 --> 00:03:23,599
and because you want to sleep while

00:03:22,400 --> 00:03:25,440
waiting

00:03:23,599 --> 00:03:27,120
so and the third argument is the

00:03:25,440 --> 00:03:30,480
expected value here

00:03:27,120 --> 00:03:33,840
is lock taken so what that does mean

00:03:30,480 --> 00:03:36,959
for instance if the value has changed uh

00:03:33,840 --> 00:03:37,920
between you tries to do the compare

00:03:36,959 --> 00:03:41,040
exchange

00:03:37,920 --> 00:03:43,840
and when you issue this cisco

00:03:41,040 --> 00:03:44,480
so uh since this can happen and we don't

00:03:43,840 --> 00:03:48,239
want to

00:03:44,480 --> 00:03:50,959
sleep when the lock is free the kernel

00:03:48,239 --> 00:03:51,840
checks if before sleeping the current

00:03:50,959 --> 00:03:53,840
checks

00:03:51,840 --> 00:03:55,920
if you are sleeping on the right

00:03:53,840 --> 00:03:58,959
condition if you are sleeping

00:03:55,920 --> 00:03:59,360
on the case where lock is the value is

00:03:58,959 --> 00:04:03,519
lock

00:03:59,360 --> 00:04:05,439
taken so this is for the lock side

00:04:03,519 --> 00:04:07,680
on the unlock side the first thing you

00:04:05,439 --> 00:04:11,439
do is you automatically set

00:04:07,680 --> 00:04:14,560
the value as log free and then

00:04:11,439 --> 00:04:16,639
you call full text again but this time

00:04:14,560 --> 00:04:18,320
with the full text wake operation you

00:04:16,639 --> 00:04:21,359
can see that you are using

00:04:18,320 --> 00:04:22,960
the same address because this is how

00:04:21,359 --> 00:04:25,280
identifiable text

00:04:22,960 --> 00:04:26,080
and now the third argument is not

00:04:25,280 --> 00:04:29,520
anymore

00:04:26,080 --> 00:04:33,440
the expected value but now it's

00:04:29,520 --> 00:04:37,360
the number of waiters that want to wake

00:04:33,440 --> 00:04:40,560
on the mutex example uh the

00:04:37,360 --> 00:04:43,280
only only value that makes sense is one

00:04:40,560 --> 00:04:44,240
since if you wake more than one they

00:04:43,280 --> 00:04:47,600
will just

00:04:44,240 --> 00:04:48,639
fight for the lock and i'll get the lock

00:04:47,600 --> 00:04:52,320
will continue and

00:04:48,639 --> 00:04:55,600
you who didn't get the lock uh you

00:04:52,320 --> 00:04:56,240
sleep again so this will wait uh just

00:04:55,600 --> 00:04:59,600
wait

00:04:56,240 --> 00:05:02,560
waste some processor time

00:04:59,600 --> 00:05:03,520
but for other operations like you for

00:05:02,560 --> 00:05:07,360
inflammation

00:05:03,520 --> 00:05:08,560
a barrier you can use the max number of

00:05:07,360 --> 00:05:10,639
threads in your system

00:05:08,560 --> 00:05:12,560
because you want to wake everyone at the

00:05:10,639 --> 00:05:15,199
same time

00:05:12,560 --> 00:05:17,039
and also this example can be optimized

00:05:15,199 --> 00:05:19,520
it should just

00:05:17,039 --> 00:05:20,320
call full text awake if you know there

00:05:19,520 --> 00:05:22,880
is someone

00:05:20,320 --> 00:05:24,160
really waiting for it so i was

00:05:22,880 --> 00:05:26,400
simplifying

00:05:24,160 --> 00:05:27,520
the interface this is the complete

00:05:26,400 --> 00:05:29,440
interface

00:05:27,520 --> 00:05:31,360
and as you can see it's a multiplexed

00:05:29,440 --> 00:05:32,160
one that means that all operations

00:05:31,360 --> 00:05:34,639
happens

00:05:32,160 --> 00:05:35,840
in the same cisco the first argument is

00:05:34,639 --> 00:05:37,759
the user address

00:05:35,840 --> 00:05:39,680
and the address of the integer that

00:05:37,759 --> 00:05:42,240
holds the value

00:05:39,680 --> 00:05:42,880
that holds the state and the second

00:05:42,240 --> 00:05:45,039
argument

00:05:42,880 --> 00:05:46,240
is the operational code and you can also

00:05:45,039 --> 00:05:48,240
add some flags here

00:05:46,240 --> 00:05:49,520
if you want to change the behavior uh

00:05:48,240 --> 00:05:52,720
for instance uh

00:05:49,520 --> 00:05:55,039
if you are doing us a multi-trade

00:05:52,720 --> 00:05:58,960
application

00:05:55,039 --> 00:06:01,919
where you share the memory space

00:05:58,960 --> 00:06:02,560
you can use the flag photos for text

00:06:01,919 --> 00:06:06,560
private

00:06:02,560 --> 00:06:09,360
to do some access optimizations however

00:06:06,560 --> 00:06:10,639
if you are creating a multi-process

00:06:09,360 --> 00:06:12,720
application

00:06:10,639 --> 00:06:14,720
uh you can do that because you probably

00:06:12,720 --> 00:06:17,919
need to create a shared memory

00:06:14,720 --> 00:06:21,440
variable so

00:06:17,919 --> 00:06:22,800
the value on the wage case is the

00:06:21,440 --> 00:06:25,600
expected value

00:06:22,800 --> 00:06:27,520
but on the weak case is the number of

00:06:25,600 --> 00:06:30,240
threads you want to wake

00:06:27,520 --> 00:06:31,280
and the timeout operation is for if you

00:06:30,240 --> 00:06:33,280
don't want to

00:06:31,280 --> 00:06:34,880
wait forever you can add a timeout for

00:06:33,280 --> 00:06:38,000
the footage switch

00:06:34,880 --> 00:06:40,319
and there is also the user address 2

00:06:38,000 --> 00:06:42,319
and of all three arguments that i'm not

00:06:40,319 --> 00:06:44,479
covering here because

00:06:42,319 --> 00:06:46,960
there are four other more complex

00:06:44,479 --> 00:06:50,400
operations

00:06:46,960 --> 00:06:53,520
um so footage is from 2002

00:06:50,400 --> 00:06:55,599
it was created by russia russell when he

00:06:53,520 --> 00:06:58,240
was working at ibm

00:06:55,599 --> 00:07:01,360
but for a long time um it had been

00:06:58,240 --> 00:07:04,400
maintained by thomas

00:07:01,360 --> 00:07:06,639
also glibc doesn't expose a nice wrapper

00:07:04,400 --> 00:07:07,440
for some reasons the first reason is

00:07:06,639 --> 00:07:10,240
that

00:07:07,440 --> 00:07:12,319
is not easy to create a nice wrapper

00:07:10,240 --> 00:07:15,120
that checks the semantics

00:07:12,319 --> 00:07:18,319
and the types of the arguments when you

00:07:15,120 --> 00:07:21,360
are working with a multiplexed interface

00:07:18,319 --> 00:07:22,720
and also because photex wasn't really

00:07:21,360 --> 00:07:25,759
made to be used

00:07:22,720 --> 00:07:29,360
by a lot of developers

00:07:25,759 --> 00:07:33,039
futex was meant to be used only by

00:07:29,360 --> 00:07:33,840
those developers of core parts of the

00:07:33,039 --> 00:07:38,160
user space

00:07:33,840 --> 00:07:41,199
like c libraries but also you can use

00:07:38,160 --> 00:07:43,039
we found users of the foot text for

00:07:41,199 --> 00:07:45,520
instance

00:07:43,039 --> 00:07:46,800
if you have a corner case uh that you

00:07:45,520 --> 00:07:48,800
want to implement

00:07:46,800 --> 00:07:50,080
that is not covered by the bitrate

00:07:48,800 --> 00:07:52,479
implementation

00:07:50,080 --> 00:07:53,280
or for instance if you are doing some

00:07:52,479 --> 00:07:56,960
level

00:07:53,280 --> 00:08:00,000
compatibility like you are creating some

00:07:56,960 --> 00:08:03,759
emulation tools so if you want to

00:08:00,000 --> 00:08:07,599
use full text you you need to use

00:08:03,759 --> 00:08:10,400
the cisco function of gdbc

00:08:07,599 --> 00:08:13,039
and use and then use the number of this

00:08:10,400 --> 00:08:16,160
is called full text

00:08:13,039 --> 00:08:18,479
so now i want to talk about how the full

00:08:16,160 --> 00:08:20,639
text works on the kernel side

00:08:18,479 --> 00:08:22,319
so for the weight and the first thing

00:08:20,639 --> 00:08:25,520
you do is to check

00:08:22,319 --> 00:08:29,199
if the value on the user space address

00:08:25,520 --> 00:08:31,520
match what the user is expecting

00:08:29,199 --> 00:08:33,519
so if it's not true you just return

00:08:31,520 --> 00:08:36,719
immediately with a neighbor

00:08:33,519 --> 00:08:39,360
however if it is true you will sleep

00:08:36,719 --> 00:08:40,959
before doing that you register yourself

00:08:39,360 --> 00:08:43,760
on the wait table

00:08:40,959 --> 00:08:45,200
so the waker thread will know where to

00:08:43,760 --> 00:08:47,519
find you

00:08:45,200 --> 00:08:48,480
and then you are right to sleep and then

00:08:47,519 --> 00:08:51,760
you eventually

00:08:48,480 --> 00:08:53,839
you will wake this can be for of uh

00:08:51,760 --> 00:08:55,360
some reasons for instance it could be

00:08:53,839 --> 00:08:57,680
just as produced awake

00:08:55,360 --> 00:08:58,720
because the tasks scatter put you to do

00:08:57,680 --> 00:09:00,720
some work

00:08:58,720 --> 00:09:02,000
but you don't have any work to do so you

00:09:00,720 --> 00:09:04,160
just sleep again

00:09:02,000 --> 00:09:05,120
it could be a time out in this case you

00:09:04,160 --> 00:09:07,920
need to wake

00:09:05,120 --> 00:09:09,440
remove yourself from the table and exit

00:09:07,920 --> 00:09:12,800
it could be also

00:09:09,440 --> 00:09:15,360
um because you this thread got a signal

00:09:12,800 --> 00:09:16,399
so it could be for instance a cq or sick

00:09:15,360 --> 00:09:19,600
apart

00:09:16,399 --> 00:09:21,519
and then you need to exit the trend

00:09:19,600 --> 00:09:23,120
so you remove yourself on the table and

00:09:21,519 --> 00:09:27,360
get back to your space

00:09:23,120 --> 00:09:31,120
but it could be the normal case what is

00:09:27,360 --> 00:09:34,399
the way someone did the full text wake

00:09:31,120 --> 00:09:34,880
and now your you are awake and need to

00:09:34,399 --> 00:09:38,240
go through

00:09:34,880 --> 00:09:40,160
the space on the other side uh the full

00:09:38,240 --> 00:09:43,440
text wake

00:09:40,160 --> 00:09:44,240
for it's very simple you just go to the

00:09:43,440 --> 00:09:47,120
full text

00:09:44,240 --> 00:09:47,600
do to the wait table and for each full

00:09:47,120 --> 00:09:49,920
text

00:09:47,600 --> 00:09:51,040
that is in the same address that's you

00:09:49,920 --> 00:09:54,640
you just wait

00:09:51,040 --> 00:09:58,240
until you match the number of weeks

00:09:54,640 --> 00:10:01,440
that the user space has asked you to do

00:09:58,240 --> 00:10:04,560
now this is a simple timeline

00:10:01,440 --> 00:10:05,040
of how full text works on the top you

00:10:04,560 --> 00:10:08,000
have

00:10:05,040 --> 00:10:10,720
a thread that in this case is mutex so

00:10:08,000 --> 00:10:14,160
in the top you have a thread that

00:10:10,720 --> 00:10:15,279
doesn't have the lock so it will do a

00:10:14,160 --> 00:10:17,120
full text weight

00:10:15,279 --> 00:10:18,959
and then you go to the kernel and the

00:10:17,120 --> 00:10:21,760
kernel will scatter the thread

00:10:18,959 --> 00:10:22,720
so basically put it to sleep in the

00:10:21,760 --> 00:10:25,440
meanwhile

00:10:22,720 --> 00:10:26,640
the thread on the bottom that has a lock

00:10:25,440 --> 00:10:29,440
just release it

00:10:26,640 --> 00:10:31,839
so it will call full text wake and go to

00:10:29,440 --> 00:10:34,880
the kernel the kernel will find out

00:10:31,839 --> 00:10:38,480
which stretch wake and we will issue a

00:10:34,880 --> 00:10:41,120
wake up operation and then

00:10:38,480 --> 00:10:42,000
both try to just exit from the kernel

00:10:41,120 --> 00:10:45,120
and continue

00:10:42,000 --> 00:10:48,399
the work and now

00:10:45,120 --> 00:10:50,560
let's see how the hash table works

00:10:48,399 --> 00:10:52,399
so in the full text current for the

00:10:50,560 --> 00:10:52,880
exploitation you have a global hash

00:10:52,399 --> 00:10:56,880
table

00:10:52,880 --> 00:11:00,000
with a lot of hash buckets and then

00:10:56,880 --> 00:11:01,920
when you ask for weight

00:11:00,000 --> 00:11:03,760
the hash function will assign you a

00:11:01,920 --> 00:11:06,880
bucket and you will

00:11:03,760 --> 00:11:10,240
add your own awaiting leasing there

00:11:06,880 --> 00:11:12,480
and but for the same address all

00:11:10,240 --> 00:11:13,519
threads will get on the same bucket so

00:11:12,480 --> 00:11:16,800
this make the

00:11:13,519 --> 00:11:19,839
waker life easier however

00:11:16,800 --> 00:11:21,360
you can also have hash conflicts so in

00:11:19,839 --> 00:11:23,920
this case

00:11:21,360 --> 00:11:26,000
different address will be on the same

00:11:23,920 --> 00:11:28,000
bucket

00:11:26,000 --> 00:11:29,360
so now let's have a look on some

00:11:28,000 --> 00:11:32,160
problems that

00:11:29,360 --> 00:11:33,120
the current interface has so the first

00:11:32,160 --> 00:11:36,320
thing

00:11:33,120 --> 00:11:38,240
to notice is that we didn't got

00:11:36,320 --> 00:11:41,200
we didn't get any new feature on the

00:11:38,240 --> 00:11:44,800
food decks since 2008

00:11:41,200 --> 00:11:47,120
uh this is because the code is very hard

00:11:44,800 --> 00:11:47,920
to modify and it's very tricky to

00:11:47,120 --> 00:11:51,120
maintain

00:11:47,920 --> 00:11:54,720
this was set by the maintainers itself

00:11:51,120 --> 00:11:58,320
and and footage is very important

00:11:54,720 --> 00:12:01,519
for all sort of systems and it's

00:11:58,320 --> 00:12:04,320
important to provide safe multithreading

00:12:01,519 --> 00:12:05,120
and safe locking so if there's a bug on

00:12:04,320 --> 00:12:07,360
full text

00:12:05,120 --> 00:12:08,480
this will give problems for a lot of

00:12:07,360 --> 00:12:10,480
people

00:12:08,480 --> 00:12:12,079
also the current code has some legacy

00:12:10,480 --> 00:12:15,200
features that

00:12:12,079 --> 00:12:16,639
no one use anymore and it's kind of

00:12:15,200 --> 00:12:19,040
tricky to modify

00:12:16,639 --> 00:12:22,480
the code through the new feature without

00:12:19,040 --> 00:12:22,480
breaking old features

00:12:22,560 --> 00:12:27,040
and beside that we also have the problem

00:12:25,279 --> 00:12:30,240
of pneuma awareness

00:12:27,040 --> 00:12:32,320
so on the sinkholes single socket case

00:12:30,240 --> 00:12:33,360
there is no problem on having a global

00:12:32,320 --> 00:12:35,440
hash table

00:12:33,360 --> 00:12:36,560
because um this hash table will be

00:12:35,440 --> 00:12:40,240
somewhere in the memory

00:12:36,560 --> 00:12:43,279
and the cpu can easily access it however

00:12:40,240 --> 00:12:44,639
on the numa architecture we will have a

00:12:43,279 --> 00:12:47,760
lot of sockets

00:12:44,639 --> 00:12:50,720
and the global hash table need to be

00:12:47,760 --> 00:12:52,160
on some nodes and for every node that

00:12:50,720 --> 00:12:54,959
doesn't have the table

00:12:52,160 --> 00:12:56,560
it would be it will be very costly to

00:12:54,959 --> 00:12:59,600
get the information

00:12:56,560 --> 00:13:03,120
uh for the table since the

00:12:59,600 --> 00:13:05,279
memory access is no uniform

00:13:03,120 --> 00:13:07,120
so another problem that we have on the

00:13:05,279 --> 00:13:09,519
current interface

00:13:07,120 --> 00:13:10,399
is the lack of determinism for real time

00:13:09,519 --> 00:13:13,440
users

00:13:10,399 --> 00:13:16,000
so as i showed before um we can have

00:13:13,440 --> 00:13:18,240
hash collisions on the table and it's

00:13:16,000 --> 00:13:20,000
not easy or not possible for the user

00:13:18,240 --> 00:13:22,240
space to know how many

00:13:20,000 --> 00:13:24,399
how many full taxes are on the same

00:13:22,240 --> 00:13:27,600
bucket that we are operating

00:13:24,399 --> 00:13:30,079
so that means that it's very hard

00:13:27,600 --> 00:13:31,120
to predict how many times how much time

00:13:30,079 --> 00:13:36,160
a full text

00:13:31,120 --> 00:13:39,040
operation will take the fact that

00:13:36,160 --> 00:13:41,199
the user space needs to provide and 32

00:13:39,040 --> 00:13:43,920
bits

00:13:41,199 --> 00:13:44,720
user address is a hard requirement you

00:13:43,920 --> 00:13:49,360
can use

00:13:44,720 --> 00:13:52,560
other other size of integer so

00:13:49,360 --> 00:13:55,839
maybe we could have 80 or

00:13:52,560 --> 00:13:59,040
16 bits integers

00:13:55,839 --> 00:14:01,199
it could help embedded systems that

00:13:59,040 --> 00:14:02,639
maybe doesn't have so much memory and

00:14:01,199 --> 00:14:06,000
also for the mutex

00:14:02,639 --> 00:14:09,279
case you will probably use for

00:14:06,000 --> 00:14:10,320
like three values so 80 bits is enough

00:14:09,279 --> 00:14:12,639
for that

00:14:10,320 --> 00:14:13,760
so maybe you can fit more things on your

00:14:12,639 --> 00:14:17,199
cache

00:14:13,760 --> 00:14:17,760
and also 64 bit for texas could be

00:14:17,199 --> 00:14:22,079
useful

00:14:17,760 --> 00:14:26,320
if you want to to wait on a pointer

00:14:22,079 --> 00:14:27,199
so here is a list of a lot of attempted

00:14:26,320 --> 00:14:31,120
features that

00:14:27,199 --> 00:14:34,160
we got on these ears that wasn't

00:14:31,120 --> 00:14:36,959
merged so the first one is adaptive

00:14:34,160 --> 00:14:38,000
spinning for texas we got two takes one

00:14:36,959 --> 00:14:42,399
in 2010

00:14:38,000 --> 00:14:46,079
another one in 2016. so the idea here

00:14:42,399 --> 00:14:46,639
is for um if you if the kernel knows

00:14:46,079 --> 00:14:49,680
that

00:14:46,639 --> 00:14:51,120
the lock owner is running uh maybe it's

00:14:49,680 --> 00:14:54,560
not worth choosing

00:14:51,120 --> 00:14:59,440
to the waiter to sleep maybe it

00:14:54,560 --> 00:15:01,920
is worth to just spinning so you can

00:14:59,440 --> 00:15:03,680
avoid the overhead of sleeping and the

00:15:01,920 --> 00:15:06,720
contact switch

00:15:03,680 --> 00:15:10,880
and the second feature uh

00:15:06,720 --> 00:15:13,440
2016 as well is the attached voltages

00:15:10,880 --> 00:15:14,160
and the hash table per process and this

00:15:13,440 --> 00:15:17,920
was made

00:15:14,160 --> 00:15:21,040
to try to solve the numa problem

00:15:17,920 --> 00:15:23,360
because um here

00:15:21,040 --> 00:15:24,240
each process will have its own table

00:15:23,360 --> 00:15:27,199
that means that

00:15:24,240 --> 00:15:28,399
when you create a new process on the

00:15:27,199 --> 00:15:30,560
creation

00:15:28,399 --> 00:15:32,880
the kernel will allocate some memory for

00:15:30,560 --> 00:15:36,639
the hash table

00:15:32,880 --> 00:15:39,360
so since the process data

00:15:36,639 --> 00:15:41,199
is attached to the node where the

00:15:39,360 --> 00:15:43,759
process is running

00:15:41,199 --> 00:15:46,560
you will solve this locality memory

00:15:43,759 --> 00:15:49,600
memory locality problem

00:15:46,560 --> 00:15:52,639
and also last year we got

00:15:49,600 --> 00:15:55,920
variable sites for texas so

00:15:52,639 --> 00:15:57,839
this was um attempt to implement

00:15:55,920 --> 00:15:59,120
uh to fix that issue that i just talked

00:15:57,839 --> 00:16:01,600
about of the

00:15:59,120 --> 00:16:04,320
fixed sizes so this would allow

00:16:01,600 --> 00:16:07,199
different sizes of the um for footage

00:16:04,320 --> 00:16:09,759
and we also got way too multiple

00:16:07,199 --> 00:16:13,759
footages that i will explain later

00:16:09,759 --> 00:16:17,120
and the futex swap that is uh

00:16:13,759 --> 00:16:17,920
we we got dispatch this year it was

00:16:17,120 --> 00:16:21,519
aimed for

00:16:17,920 --> 00:16:25,680
some consumer producer

00:16:21,519 --> 00:16:28,399
specific loads

00:16:25,680 --> 00:16:31,600
so the futex which multiple was

00:16:28,399 --> 00:16:35,199
developed by collaborative and valve

00:16:31,600 --> 00:16:37,839
and is the semantics is to wait

00:16:35,199 --> 00:16:40,480
on a lot of full text at the same time

00:16:37,839 --> 00:16:43,199
and on the first

00:16:40,480 --> 00:16:43,920
waiter on the first full text that issue

00:16:43,199 --> 00:16:47,920
on week

00:16:43,920 --> 00:16:50,639
you will wake so

00:16:47,920 --> 00:16:52,880
this operation can be found on other

00:16:50,639 --> 00:16:57,519
operation systems as well

00:16:52,880 --> 00:17:01,279
and for us is very useful for

00:16:57,519 --> 00:17:04,319
creating the emulation layer between

00:17:01,279 --> 00:17:06,720
windows and linux because

00:17:04,319 --> 00:17:07,520
the first thing that vault did was to

00:17:06,720 --> 00:17:10,640
use

00:17:07,520 --> 00:17:11,760
the eventfd interface to simulate this

00:17:10,640 --> 00:17:14,880
behavior

00:17:11,760 --> 00:17:17,679
but unfortunately eventfd didn't

00:17:14,880 --> 00:17:18,480
doesn't scale so so well with a lot of

00:17:17,679 --> 00:17:21,760
waiters

00:17:18,480 --> 00:17:24,559
and also uh some games called calls

00:17:21,760 --> 00:17:24,880
file descriptor distortion since they

00:17:24,559 --> 00:17:28,240
could

00:17:24,880 --> 00:17:32,240
create a lot of um lock

00:17:28,240 --> 00:17:34,720
objects so the full text interface

00:17:32,240 --> 00:17:36,160
seemed natural to implement this and

00:17:34,720 --> 00:17:37,520
this is what was done

00:17:36,160 --> 00:17:40,480
using full text to implement this

00:17:37,520 --> 00:17:42,640
semantics and we got some nice results

00:17:40,480 --> 00:17:43,520
for instance on the temporary running

00:17:42,640 --> 00:17:46,400
over bottom

00:17:43,520 --> 00:17:47,360
that is a compatibility layer that that

00:17:46,400 --> 00:17:50,400
allows you to run

00:17:47,360 --> 00:17:52,400
windows games on linux we got four

00:17:50,400 --> 00:17:55,440
percent less cpu utilization

00:17:52,400 --> 00:17:56,480
and 80 less calls through spin locks on

00:17:55,440 --> 00:17:58,960
the kernel

00:17:56,480 --> 00:18:01,039
so that means that we could allow the

00:17:58,960 --> 00:18:04,640
kernel to do some proper work

00:18:01,039 --> 00:18:06,320
instead of just spinning

00:18:04,640 --> 00:18:08,080
so after talking about all those

00:18:06,320 --> 00:18:11,600
limitations and

00:18:08,080 --> 00:18:15,280
about all those features that weren't

00:18:11,600 --> 00:18:18,160
able to be merged on the old interface

00:18:15,280 --> 00:18:18,640
this is the solution that was proposed

00:18:18,160 --> 00:18:20,640
by

00:18:18,640 --> 00:18:22,000
thomas peter and florio on the main

00:18:20,640 --> 00:18:25,440
release to create

00:18:22,000 --> 00:18:28,559
a new api from scratch

00:18:25,440 --> 00:18:29,039
so the first thing uh that you notice

00:18:28,559 --> 00:18:31,120
here

00:18:29,039 --> 00:18:32,640
is that um the interface is not

00:18:31,120 --> 00:18:36,000
multiplex anymore

00:18:32,640 --> 00:18:36,320
and this um basically will make the life

00:18:36,000 --> 00:18:39,039
of

00:18:36,320 --> 00:18:39,840
kernel developers and gpc developers

00:18:39,039 --> 00:18:41,760
easier

00:18:39,840 --> 00:18:43,200
and if you want to know more about the

00:18:41,760 --> 00:18:45,440
benefits of not

00:18:43,200 --> 00:18:47,120
creating a multiplex at cisco i

00:18:45,440 --> 00:18:50,160
recommend you to check

00:18:47,120 --> 00:18:50,640
the 2020 link slumber conference there's

00:18:50,160 --> 00:18:53,200
a talk

00:18:50,640 --> 00:18:55,120
by christian and alexa where they talk

00:18:53,200 --> 00:18:58,480
about extensible ciscos

00:18:55,120 --> 00:19:01,760
and why multiplexing assist call leaders

00:18:58,480 --> 00:19:04,080
to some headaches on the past

00:19:01,760 --> 00:19:04,880
so we also on this interface we have

00:19:04,080 --> 00:19:06,720
flags for

00:19:04,880 --> 00:19:08,480
numa if you want to do a new mobile

00:19:06,720 --> 00:19:11,039
operation for the size

00:19:08,480 --> 00:19:12,880
because on the new interface you can

00:19:11,039 --> 00:19:15,679
choose the size of footage

00:19:12,880 --> 00:19:16,960
so for instance you can use an 80 bit

00:19:15,679 --> 00:19:20,320
full text

00:19:16,960 --> 00:19:22,080
and then uh use tell to the kernel using

00:19:20,320 --> 00:19:25,520
a full text size 8

00:19:22,080 --> 00:19:27,840
that you the size of your full text

00:19:25,520 --> 00:19:30,080
you can also use shared to touch the

00:19:27,840 --> 00:19:32,960
kernel that is a shared footage

00:19:30,080 --> 00:19:35,039
and a flag for clock id to specify if

00:19:32,960 --> 00:19:39,039
you want to operate on monotonic

00:19:35,039 --> 00:19:42,400
or real time clock

00:19:39,039 --> 00:19:45,520
and here is this interface for

00:19:42,400 --> 00:19:46,720
wake and weight uh you can see that they

00:19:45,520 --> 00:19:49,120
are very similar

00:19:46,720 --> 00:19:50,480
to what we had before uh the way you

00:19:49,120 --> 00:19:53,679
have the address

00:19:50,480 --> 00:19:55,679
the number of uh wakers that

00:19:53,679 --> 00:19:56,799
number of weeks that you want to perform

00:19:55,679 --> 00:19:59,039
the flags

00:19:56,799 --> 00:20:00,880
on the wait side again the address the

00:19:59,039 --> 00:20:04,400
expected value

00:20:00,880 --> 00:20:04,400
flags and the timeout

00:20:04,880 --> 00:20:09,520
and here is the interface for the weight

00:20:08,480 --> 00:20:11,039
of multiple

00:20:09,520 --> 00:20:13,679
uh it's called the weight to v because

00:20:11,039 --> 00:20:15,600
this uh vectorized weight

00:20:13,679 --> 00:20:17,120
so the first argument will be a pointer

00:20:15,600 --> 00:20:20,480
to an android

00:20:17,120 --> 00:20:21,200
array of waiters so each waiter will

00:20:20,480 --> 00:20:24,240
have this

00:20:21,200 --> 00:20:25,840
the address the expected value again and

00:20:24,240 --> 00:20:28,159
the flags because

00:20:25,840 --> 00:20:29,360
you can have different sizes on this

00:20:28,159 --> 00:20:31,600
array

00:20:29,360 --> 00:20:32,559
so and then you have the number of

00:20:31,600 --> 00:20:35,520
waiters

00:20:32,559 --> 00:20:36,159
the flags and the timeouts and i didn't

00:20:35,520 --> 00:20:38,400
cover the

00:20:36,159 --> 00:20:39,919
compare cue operation here because it's

00:20:38,400 --> 00:20:43,679
kind of different

00:20:39,919 --> 00:20:46,880
semantics but basically it's about uh

00:20:43,679 --> 00:20:47,760
he killing waiters from one address to

00:20:46,880 --> 00:20:50,640
another one

00:20:47,760 --> 00:20:52,559
the important thing here is that this

00:20:50,640 --> 00:20:55,200
this interface already has

00:20:52,559 --> 00:20:56,720
six arguments that is the limit of cisco

00:20:55,200 --> 00:21:00,240
for some architectures

00:20:56,720 --> 00:21:03,919
so we can't add uh more arguments

00:21:00,240 --> 00:21:06,320
to this interface so

00:21:03,919 --> 00:21:07,600
now i want to explain how we are solving

00:21:06,320 --> 00:21:11,280
the numerators

00:21:07,600 --> 00:21:12,370
the normal awareness problem so for the

00:21:11,280 --> 00:21:14,320
new malware's

00:21:12,370 --> 00:21:17,440
[Music]

00:21:14,320 --> 00:21:20,559
call the user address will just point to

00:21:17,440 --> 00:21:21,440
an integer like before but for a normal

00:21:20,559 --> 00:21:24,640
operation

00:21:21,440 --> 00:21:27,280
the user address will point to um

00:21:24,640 --> 00:21:28,480
structure and as before this address

00:21:27,280 --> 00:21:33,039
will be used to

00:21:28,480 --> 00:21:35,520
identify uniquely identify a full text

00:21:33,039 --> 00:21:37,679
so these structs will have two fields

00:21:35,520 --> 00:21:40,880
the first one is the expected value

00:21:37,679 --> 00:21:41,840
and the second one is a hint on the luma

00:21:40,880 --> 00:21:45,600
flag

00:21:41,840 --> 00:21:49,039
semantics the end keep can be either

00:21:45,600 --> 00:21:51,120
minus one where that means that you want

00:21:49,039 --> 00:21:53,840
to operate on the current node

00:21:51,120 --> 00:21:54,880
where you are running but you can also

00:21:53,840 --> 00:21:57,200
ex

00:21:54,880 --> 00:21:58,640
specify from zero to the max of normal

00:21:57,200 --> 00:22:00,640
nodes

00:21:58,640 --> 00:22:02,960
the number of the node where you want to

00:22:00,640 --> 00:22:05,120
rate because

00:22:02,960 --> 00:22:06,159
maybe you want to share a full text with

00:22:05,120 --> 00:22:09,200
another node

00:22:06,159 --> 00:22:11,120
or maybe you are migrated so this is how

00:22:09,200 --> 00:22:13,039
we specify on which node you want to

00:22:11,120 --> 00:22:16,320
operate

00:22:13,039 --> 00:22:19,280
and also though all those values members

00:22:16,320 --> 00:22:22,480
will be naturally align it

00:22:19,280 --> 00:22:25,520
so before we used to have a

00:22:22,480 --> 00:22:28,559
single global table but now we will have

00:22:25,520 --> 00:22:31,039
local hash tables one for each socket

00:22:28,559 --> 00:22:32,799
so this will solve the problem of memory

00:22:31,039 --> 00:22:37,600
locality for

00:22:32,799 --> 00:22:37,600
numa pneuma architectures

00:22:38,320 --> 00:22:41,840
so this is the interface that was

00:22:40,720 --> 00:22:43,440
proposed

00:22:41,840 --> 00:22:44,960
on the mailing list and also on the

00:22:43,440 --> 00:22:46,640
linux conference

00:22:44,960 --> 00:22:48,960
and this is the interface that i'm

00:22:46,640 --> 00:22:49,440
implementing so what i have done right

00:22:48,960 --> 00:22:52,640
now

00:22:49,440 --> 00:22:55,760
is the weight and weight and also the

00:22:52,640 --> 00:22:59,039
weight the vectorized weight and the

00:22:55,760 --> 00:23:01,120
timeout is also working

00:22:59,039 --> 00:23:02,240
what i'm what i need what i'm working

00:23:01,120 --> 00:23:05,520
right now

00:23:02,240 --> 00:23:08,480
um is to implement the shared for texas

00:23:05,520 --> 00:23:09,520
and what i have quite kind of done but i

00:23:08,480 --> 00:23:12,080
need more testing

00:23:09,520 --> 00:23:14,080
using one where and the variable size

00:23:12,080 --> 00:23:16,799
and for the future i need to do

00:23:14,080 --> 00:23:18,880
the comprehensive operation um i will

00:23:16,799 --> 00:23:21,679
send the patch soon as i have

00:23:18,880 --> 00:23:22,799
a lot of feature together because this

00:23:21,679 --> 00:23:25,840
will

00:23:22,799 --> 00:23:26,880
uh help us to identify if the

00:23:25,840 --> 00:23:29,200
architecture

00:23:26,880 --> 00:23:30,240
is working instead of sending in small

00:23:29,200 --> 00:23:32,640
pads

00:23:30,240 --> 00:23:34,400
so if you want to see the pets watch

00:23:32,640 --> 00:23:38,000
closely the real-time

00:23:34,400 --> 00:23:41,679
mailing is because as proposed by

00:23:38,000 --> 00:23:44,559
steven on the linux plumbers um

00:23:41,679 --> 00:23:45,120
the real time will be a nice place to

00:23:44,559 --> 00:23:48,480
test in

00:23:45,120 --> 00:23:51,279
and play with the new interface

00:23:48,480 --> 00:23:51,679
so thanks everyone for listening to me

00:23:51,279 --> 00:23:54,159
and

00:23:51,679 --> 00:23:56,080
if you want to get in touch just send me

00:23:54,159 --> 00:24:05,840
an email and we can talk about

00:23:56,080 --> 00:24:05,840
taxes thank you

00:24:09,760 --> 00:24:11,840

YouTube URL: https://www.youtube.com/watch?v=GmqW7GHPxJ0


