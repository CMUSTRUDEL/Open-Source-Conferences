Title: Boot-Time Optimization for the Real World - Michael Olbrich, Pengutronix e.K.
Publication date: 2020-11-03
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Boot-Time Optimization for the Real World - Michael Olbrich, Pengutronix e.K.
Captions: 
	00:00:05,190 --> 00:00:13,380
[Music]

00:00:15,440 --> 00:00:18,240
okay hello

00:00:16,080 --> 00:00:19,199
everybody my name is michael and i'm

00:00:18,240 --> 00:00:21,119
talking about

00:00:19,199 --> 00:00:22,560
boot time optimization for the real

00:00:21,119 --> 00:00:24,800
world

00:00:22,560 --> 00:00:25,920
so perhaps um first a few words about

00:00:24,800 --> 00:00:29,199
myself

00:00:25,920 --> 00:00:30,800
um i'm been working for pangotronics now

00:00:29,199 --> 00:00:33,680
for over a decade

00:00:30,800 --> 00:00:34,880
and doing mostly linux embedded linux

00:00:33,680 --> 00:00:37,360
consulting and

00:00:34,880 --> 00:00:39,280
development these kind of things and

00:00:37,360 --> 00:00:41,360
this also includes

00:00:39,280 --> 00:00:44,079
quite a few boot time optimization

00:00:41,360 --> 00:00:47,600
projects over the years

00:00:44,079 --> 00:00:50,239
so let's get started first

00:00:47,600 --> 00:00:51,199
my motivation motivation for this talk

00:00:50,239 --> 00:00:54,079
in general

00:00:51,199 --> 00:00:55,440
i was at the elc last year and there

00:00:54,079 --> 00:00:57,520
were two talks about boot time

00:00:55,440 --> 00:01:00,879
optimization actually that year

00:00:57,520 --> 00:01:01,280
and one of them was uh we need to talk

00:01:00,879 --> 00:01:04,080
about

00:01:01,280 --> 00:01:05,760
uh systemd wutum optimization for the

00:01:04,080 --> 00:01:08,640
new init daemon

00:01:05,760 --> 00:01:10,080
this is was basically uh introductory

00:01:08,640 --> 00:01:12,560
for

00:01:10,080 --> 00:01:13,520
introductory presentation mostly for

00:01:12,560 --> 00:01:17,040
beginners so

00:01:13,520 --> 00:01:20,479
i wasn't exactly the

00:01:17,040 --> 00:01:22,640
target audience but it was a nice start

00:01:20,479 --> 00:01:24,960
and the other one was some time boot

00:01:22,640 --> 00:01:27,040
time reduction techniques

00:01:24,960 --> 00:01:29,360
and this was actually quite interesting

00:01:27,040 --> 00:01:32,400
had a few nice techniques and

00:01:29,360 --> 00:01:34,479
a rather impressive result

00:01:32,400 --> 00:01:35,680
but at the end of the talk i was

00:01:34,479 --> 00:01:39,040
shooting i think

00:01:35,680 --> 00:01:41,040
thinking well this is not actually

00:01:39,040 --> 00:01:44,159
something that i can use

00:01:41,040 --> 00:01:48,159
this way in my project because

00:01:44,159 --> 00:01:49,520
um there were many compromises made many

00:01:48,159 --> 00:01:54,880
choices

00:01:49,520 --> 00:01:58,799
to reduce the boot time but in

00:01:54,880 --> 00:02:02,079
many cases at the cost of other

00:01:58,799 --> 00:02:05,280
let's say secondary functionality

00:02:02,079 --> 00:02:07,280
and this is

00:02:05,280 --> 00:02:08,800
it's often the case for me at least

00:02:07,280 --> 00:02:11,120
that's that boot time

00:02:08,800 --> 00:02:13,360
is important but there are many other

00:02:11,120 --> 00:02:16,720
topics that are even more important

00:02:13,360 --> 00:02:19,040
or at least as important so focusing

00:02:16,720 --> 00:02:19,760
only on boot time was a bit limited for

00:02:19,040 --> 00:02:22,959
me

00:02:19,760 --> 00:02:26,400
so i want to talk about a bit about more

00:02:22,959 --> 00:02:28,160
the the overall situation there when

00:02:26,400 --> 00:02:31,440
optimizing and looking at

00:02:28,160 --> 00:02:34,800
ways to not just optimize

00:02:31,440 --> 00:02:37,840
optimize optimize for boot time but

00:02:34,800 --> 00:02:40,319
thinking well i can do this but maybe i

00:02:37,840 --> 00:02:41,440
shouldn't because i sacrifice this

00:02:40,319 --> 00:02:44,560
feature or

00:02:41,440 --> 00:02:48,319
how can i improve the boot time

00:02:44,560 --> 00:02:52,239
but um without sacrificing um

00:02:48,319 --> 00:02:52,239
other features in my system

00:02:52,319 --> 00:02:59,280
okay so before we start

00:02:55,920 --> 00:03:02,840
with the actual um topics i want to

00:02:59,280 --> 00:03:04,000
think a bit about why do we do boot term

00:03:02,840 --> 00:03:07,680
optimizations

00:03:04,000 --> 00:03:10,080
because this usually brings us to

00:03:07,680 --> 00:03:12,720
what are we optimizing for what are the

00:03:10,080 --> 00:03:17,599
actual requirements

00:03:12,720 --> 00:03:21,040
we have to boot russia so

00:03:17,599 --> 00:03:22,800
the first part is that when we do

00:03:21,040 --> 00:03:24,959
optimizations there are

00:03:22,800 --> 00:03:26,000
what i call heart requirements this

00:03:24,959 --> 00:03:30,840
basically means

00:03:26,000 --> 00:03:34,959
that um there are situations where

00:03:30,840 --> 00:03:36,480
um there is a from a specification

00:03:34,959 --> 00:03:39,360
or things like that from hardware

00:03:36,480 --> 00:03:43,200
requirements it says okay

00:03:39,360 --> 00:03:46,319
when a device is powered on then

00:03:43,200 --> 00:03:49,599
after half a second or one second

00:03:46,319 --> 00:03:51,280
the device must respond to an outside

00:03:49,599 --> 00:03:54,640
request or must send

00:03:51,280 --> 00:03:56,720
some message this is typically

00:03:54,640 --> 00:03:58,400
um in the automotive industry there's

00:03:56,720 --> 00:04:01,120
there are cases like that

00:03:58,400 --> 00:04:02,159
where um i'll get to that later a bit in

00:04:01,120 --> 00:04:04,319
an example

00:04:02,159 --> 00:04:05,439
um but this these are heart requirements

00:04:04,319 --> 00:04:08,720
so

00:04:05,439 --> 00:04:11,120
this means we must hit the deadline

00:04:08,720 --> 00:04:12,080
there is no flexibility there and then

00:04:11,120 --> 00:04:15,680
there are the

00:04:12,080 --> 00:04:18,079
what i call soft requirements where

00:04:15,680 --> 00:04:20,479
it's mostly about user experience so you

00:04:18,079 --> 00:04:23,360
switch on the device

00:04:20,479 --> 00:04:24,880
and if you start thinking maybe

00:04:23,360 --> 00:04:27,440
switching on didn't work

00:04:24,880 --> 00:04:28,639
because there is no reaction to your

00:04:27,440 --> 00:04:31,120
action

00:04:28,639 --> 00:04:32,320
then there is some optimization to be

00:04:31,120 --> 00:04:36,160
done here

00:04:32,320 --> 00:04:39,680
or if later on this is usually

00:04:36,160 --> 00:04:42,160
a bit longer time available there

00:04:39,680 --> 00:04:43,120
that you switch the device on and then

00:04:42,160 --> 00:04:45,120
you're getting

00:04:43,120 --> 00:04:46,880
annoyed because it takes too long to

00:04:45,120 --> 00:04:49,840
start before you can actually use the

00:04:46,880 --> 00:04:50,960
device these are the kind of more

00:04:49,840 --> 00:04:53,520
flexible

00:04:50,960 --> 00:04:55,280
requirements because there is no fixed

00:04:53,520 --> 00:04:56,080
deadline that says okay after 500

00:04:55,280 --> 00:04:57,759
milliseconds

00:04:56,080 --> 00:04:59,199
we have to show something on the screen

00:04:57,759 --> 00:05:03,600
or things like that but

00:04:59,199 --> 00:05:07,039
more a there is a reaction to what i do

00:05:03,600 --> 00:05:11,199
and we have more flexibility

00:05:07,039 --> 00:05:13,520
to to solve the issue

00:05:11,199 --> 00:05:14,880
when it comes to maybe let's do

00:05:13,520 --> 00:05:16,960
something specific

00:05:14,880 --> 00:05:18,240
show something on the screen or whatever

00:05:16,960 --> 00:05:22,240
to um

00:05:18,240 --> 00:05:25,280
keep the to keep the user um entertained

00:05:22,240 --> 00:05:29,120
for example okay

00:05:25,280 --> 00:05:32,320
so whenever you do optimizations

00:05:29,120 --> 00:05:35,360
when we get started here it's important

00:05:32,320 --> 00:05:36,880
to choose a target what you want to

00:05:35,360 --> 00:05:38,479
optimize because

00:05:36,880 --> 00:05:40,639
that's what you need to measure so you

00:05:38,479 --> 00:05:43,360
need to decide there's no

00:05:40,639 --> 00:05:45,039
i want to boot in five seconds because

00:05:43,360 --> 00:05:47,199
what does it mean to boot in five

00:05:45,039 --> 00:05:50,960
seconds there is no

00:05:47,199 --> 00:05:54,240
if you don't specify what has to happen

00:05:50,960 --> 00:05:58,080
before the five seconds are over so

00:05:54,240 --> 00:06:00,479
the first step is always pick

00:05:58,080 --> 00:06:01,520
what is optimized what are we optimizing

00:06:00,479 --> 00:06:03,840
for

00:06:01,520 --> 00:06:04,800
so this can be especially for example

00:06:03,840 --> 00:06:06,560
for the um

00:06:04,800 --> 00:06:08,240
for hard requirement they can this can

00:06:06,560 --> 00:06:11,440
be that we have to

00:06:08,240 --> 00:06:14,319
send a can message after

00:06:11,440 --> 00:06:16,240
500 milliseconds or after a second this

00:06:14,319 --> 00:06:20,240
can be one requirement or

00:06:16,240 --> 00:06:22,319
um i talked a bit about reaction um

00:06:20,240 --> 00:06:23,680
to power on so we want to show something

00:06:22,319 --> 00:06:28,080
on the screen

00:06:23,680 --> 00:06:31,360
anything just to show the user

00:06:28,080 --> 00:06:32,479
powering on the device actually did

00:06:31,360 --> 00:06:34,800
something switched

00:06:32,479 --> 00:06:36,720
pressing a button actually caused

00:06:34,800 --> 00:06:38,880
something to happen

00:06:36,720 --> 00:06:41,120
and then there might be another if we're

00:06:38,880 --> 00:06:45,360
going further along in the timeline

00:06:41,120 --> 00:06:47,280
there may be the the point where um

00:06:45,360 --> 00:06:50,560
the first user interaction is possible

00:06:47,280 --> 00:06:50,560
so for example

00:06:51,039 --> 00:06:56,160
we can log in if there is a login screen

00:06:56,240 --> 00:07:00,000
or things like that or i have the first

00:06:59,199 --> 00:07:02,800
view

00:07:00,000 --> 00:07:03,759
that shows me initial information and

00:07:02,800 --> 00:07:06,560
then there is

00:07:03,759 --> 00:07:06,960
usually it can be later in many cases

00:07:06,560 --> 00:07:09,199
that

00:07:06,960 --> 00:07:11,199
the full interaction is possible so the

00:07:09,199 --> 00:07:16,880
device is fully working

00:07:11,199 --> 00:07:20,479
and all features are accessible

00:07:16,880 --> 00:07:23,360
okay so and what i started with

00:07:20,479 --> 00:07:24,240
was i want to not just look at boot

00:07:23,360 --> 00:07:27,520
times but

00:07:24,240 --> 00:07:30,240
also at what is

00:07:27,520 --> 00:07:30,960
what are other requirements that i have

00:07:30,240 --> 00:07:34,160
other

00:07:30,960 --> 00:07:38,240
things in the system usually it's not

00:07:34,160 --> 00:07:40,000
directly features for the device

00:07:38,240 --> 00:07:41,360
the primary features but more things

00:07:40,000 --> 00:07:42,960
like well

00:07:41,360 --> 00:07:45,199
we still need to debug the device in the

00:07:42,960 --> 00:07:46,080
field because this is a complex

00:07:45,199 --> 00:07:50,319
machinery

00:07:46,080 --> 00:07:53,919
and bugs are often not reproducible

00:07:50,319 --> 00:07:56,560
in the lab so we want to be able to

00:07:53,919 --> 00:07:58,160
do minimal debugging in the field that's

00:07:56,560 --> 00:08:00,479
also something um

00:07:58,160 --> 00:08:02,960
what might be interesting or necessary

00:08:00,479 --> 00:08:06,400
or let's talk about robustness

00:08:02,960 --> 00:08:08,800
um maybe if an application crashes

00:08:06,400 --> 00:08:09,599
once it should be restarted and here

00:08:08,800 --> 00:08:11,840
that's why i'm

00:08:09,599 --> 00:08:13,360
wrote it at the site i'm only talking

00:08:11,840 --> 00:08:15,759
about systems with

00:08:13,360 --> 00:08:16,400
that are starting with systemd because

00:08:15,759 --> 00:08:18,319
systemd

00:08:16,400 --> 00:08:20,800
provides me with a lot of features just

00:08:18,319 --> 00:08:22,800
for that monitoring if the application

00:08:20,800 --> 00:08:26,240
is actually still working properly

00:08:22,800 --> 00:08:29,199
restarting it um when uh

00:08:26,240 --> 00:08:31,280
when it crashes things like that or

00:08:29,199 --> 00:08:33,680
let's talk about the next topic security

00:08:31,280 --> 00:08:36,080
that's always important and often

00:08:33,680 --> 00:08:38,640
conflicts with uh

00:08:36,080 --> 00:08:39,360
with uh boot time optimization because

00:08:38,640 --> 00:08:42,399
um it

00:08:39,360 --> 00:08:45,279
can slow things down is and and

00:08:42,399 --> 00:08:47,440
systemd provides me with features that i

00:08:45,279 --> 00:08:49,519
can easily enable to

00:08:47,440 --> 00:08:50,800
isolate individual applications these

00:08:49,519 --> 00:08:52,080
kind of things

00:08:50,800 --> 00:08:54,000
and then there is development and

00:08:52,080 --> 00:08:58,800
testing in many

00:08:54,000 --> 00:09:00,560
cases there are recommendations to

00:08:58,800 --> 00:09:02,160
disable all kinds of things for good

00:09:00,560 --> 00:09:04,560
time optimization

00:09:02,160 --> 00:09:05,760
but at the end device is no longer

00:09:04,560 --> 00:09:08,640
debuggable

00:09:05,760 --> 00:09:10,399
so what happens is that the developers

00:09:08,640 --> 00:09:12,800
use a different setup

00:09:10,399 --> 00:09:14,880
than the final release because they can

00:09:12,800 --> 00:09:17,600
no longer debug the final release

00:09:14,880 --> 00:09:18,560
and at that point the testing with the

00:09:17,600 --> 00:09:20,839
final release

00:09:18,560 --> 00:09:21,839
is reduced because the developers no

00:09:20,839 --> 00:09:24,959
longer or

00:09:21,839 --> 00:09:26,399
let test less with the final version and

00:09:24,959 --> 00:09:29,120
this means

00:09:26,399 --> 00:09:30,560
we have to do more testing if we have a

00:09:29,120 --> 00:09:33,519
different setup for

00:09:30,560 --> 00:09:34,399
development as we have for release this

00:09:33,519 --> 00:09:37,360
is something to take

00:09:34,399 --> 00:09:38,480
to take into account um because that's

00:09:37,360 --> 00:09:40,160
always a money

00:09:38,480 --> 00:09:43,360
question as well because we have to

00:09:40,160 --> 00:09:47,279
spend more time on extra testing

00:09:43,360 --> 00:09:50,640
to keep up with the quality here

00:09:47,279 --> 00:09:54,160
and then there is maintenance if we

00:09:50,640 --> 00:09:56,800
add a lot of ugly hacks to boot faster

00:09:54,160 --> 00:09:59,200
and then we need to do a system update

00:09:56,800 --> 00:10:01,600
then we have to port all those hacks

00:09:59,200 --> 00:10:03,200
this is can be a lot of effort because

00:10:01,600 --> 00:10:04,079
we spend a lot of time in the first

00:10:03,200 --> 00:10:05,440
iteration

00:10:04,079 --> 00:10:07,920
to the boot to do the boot time

00:10:05,440 --> 00:10:09,839
optimization and then

00:10:07,920 --> 00:10:10,959
we have to do it again basically because

00:10:09,839 --> 00:10:12,560
it was just hacks

00:10:10,959 --> 00:10:14,959
that were piled on top of the old

00:10:12,560 --> 00:10:14,959
version

00:10:15,040 --> 00:10:20,720
so what are we looking at well

00:10:18,079 --> 00:10:21,440
there's just the typical thing that's

00:10:20,720 --> 00:10:25,040
disable

00:10:21,440 --> 00:10:27,519
everything well most things i'm not

00:10:25,040 --> 00:10:28,079
looking at that today because well there

00:10:27,519 --> 00:10:30,079
are a lot of

00:10:28,079 --> 00:10:32,480
um presentations out there that do that

00:10:30,079 --> 00:10:35,200
for us

00:10:32,480 --> 00:10:37,040
so what can we do we can delay things so

00:10:35,200 --> 00:10:38,079
instead of just disabling all the

00:10:37,040 --> 00:10:42,000
features

00:10:38,079 --> 00:10:46,720
let's look at ways to

00:10:42,000 --> 00:10:49,839
do it later after our initial target for

00:10:46,720 --> 00:10:52,959
um optimization is reached or

00:10:49,839 --> 00:10:55,519
well my most um the thing what i

00:10:52,959 --> 00:10:57,680
prefer most in most cases is to actually

00:10:55,519 --> 00:10:58,720
optimize the code look at things and say

00:10:57,680 --> 00:11:01,440
hey this is slow

00:10:58,720 --> 00:11:03,600
and instead of disabling thinking well

00:11:01,440 --> 00:11:05,839
why is this slow at startup

00:11:03,600 --> 00:11:06,640
can we improve here and still keep the

00:11:05,839 --> 00:11:09,279
feature

00:11:06,640 --> 00:11:12,800
it may not give us as much much

00:11:09,279 --> 00:11:16,480
optimization as disabling the feature

00:11:12,800 --> 00:11:18,640
but it will probably give us something

00:11:16,480 --> 00:11:20,399
and the best part about this is it's not

00:11:18,640 --> 00:11:22,800
just for one project

00:11:20,399 --> 00:11:24,079
it's something we if it's contributed

00:11:22,800 --> 00:11:26,560
upstream especially

00:11:24,079 --> 00:11:27,200
it's something that we can and others

00:11:26,560 --> 00:11:30,320
can

00:11:27,200 --> 00:11:31,200
profit from when the next project comes

00:11:30,320 --> 00:11:34,240
around

00:11:31,200 --> 00:11:34,800
and it is cheating i mean especially in

00:11:34,240 --> 00:11:38,560
the

00:11:34,800 --> 00:11:42,079
um case for

00:11:38,560 --> 00:11:45,279
the with the user interaction

00:11:42,079 --> 00:11:48,880
presenting the use something to the user

00:11:45,279 --> 00:11:50,560
often distracts them from realizing that

00:11:48,880 --> 00:11:53,519
the device is actually not finished

00:11:50,560 --> 00:11:56,880
booting for example i have this old

00:11:53,519 --> 00:12:00,079
phone if i switch it on

00:11:56,880 --> 00:12:02,959
i get the screen to to enter my pin

00:12:00,079 --> 00:12:03,600
and then i'm in this regular menu and i

00:12:02,959 --> 00:12:06,320
can

00:12:03,600 --> 00:12:07,200
call a number but what i cannot do for

00:12:06,320 --> 00:12:10,399
quite some time

00:12:07,200 --> 00:12:12,959
actually is open

00:12:10,399 --> 00:12:15,519
via dress book and actually i didn't

00:12:12,959 --> 00:12:18,880
notice that for over a year

00:12:15,519 --> 00:12:21,279
since um after i got this the phone to

00:12:18,880 --> 00:12:22,399
just to realize that that was happening

00:12:21,279 --> 00:12:24,480
and i think

00:12:22,399 --> 00:12:25,600
that's the actual the most important

00:12:24,480 --> 00:12:29,120
point because

00:12:25,600 --> 00:12:30,160
we can put something in somewhere and

00:12:29,120 --> 00:12:32,240
leave things out

00:12:30,160 --> 00:12:34,079
and delay them because they're not

00:12:32,240 --> 00:12:37,360
actually needed

00:12:34,079 --> 00:12:39,839
to get these let's say soft requirements

00:12:37,360 --> 00:12:39,839
resolved

00:12:40,240 --> 00:12:44,000
let's get to some real things the serial

00:12:42,639 --> 00:12:46,560
console

00:12:44,000 --> 00:12:48,560
this is something where most people when

00:12:46,560 --> 00:12:51,680
they start with

00:12:48,560 --> 00:12:55,360
with boot time optimization say

00:12:51,680 --> 00:12:57,600
that set it quiet the background here is

00:12:55,360 --> 00:12:59,839
of course

00:12:57,600 --> 00:13:01,519
output on the serial console especially

00:12:59,839 --> 00:13:04,839
from the kernel is very slow

00:13:01,519 --> 00:13:07,839
so it can easily add a few hundred

00:13:04,839 --> 00:13:09,600
milliseconds and user space is not quite

00:13:07,839 --> 00:13:12,079
as bad but it's still there

00:13:09,600 --> 00:13:13,120
so but why i'm proposing is not don't

00:13:12,079 --> 00:13:15,519
use quiet

00:13:13,120 --> 00:13:17,279
because quiet disables all errors as

00:13:15,519 --> 00:13:20,079
well that is lock level

00:13:17,279 --> 00:13:20,880
equals five this means we only show

00:13:20,079 --> 00:13:24,320
warnings

00:13:20,880 --> 00:13:26,480
and worse and quite frankly

00:13:24,320 --> 00:13:28,959
in the final product there should be no

00:13:26,480 --> 00:13:32,160
warnings so we have no output

00:13:28,959 --> 00:13:34,079
until an error occurs and

00:13:32,160 --> 00:13:36,240
so this is a setting we can keep during

00:13:34,079 --> 00:13:39,360
development because

00:13:36,240 --> 00:13:41,360
the error is still visible when

00:13:39,360 --> 00:13:42,720
something happens during development

00:13:41,360 --> 00:13:45,279
and the same thing we can do for the

00:13:42,720 --> 00:13:48,320
users-based startup the consistency

00:13:45,279 --> 00:13:49,440
has options for that as well systemd log

00:13:48,320 --> 00:13:52,399
level warning

00:13:49,440 --> 00:13:54,720
same thing only print warnings or higher

00:13:52,399 --> 00:13:58,399
and then there's the systemd show status

00:13:54,720 --> 00:14:00,560
if we set it to auto it will not print

00:13:58,399 --> 00:14:02,480
the typical systemd messages you know

00:14:00,560 --> 00:14:05,600
the ones with the green okay

00:14:02,480 --> 00:14:08,480
that comes scrolling by at the beginning

00:14:05,600 --> 00:14:09,519
they're not visible unless an error

00:14:08,480 --> 00:14:12,240
occurs

00:14:09,519 --> 00:14:13,040
and in that at that moment systemd

00:14:12,240 --> 00:14:15,040
switches

00:14:13,040 --> 00:14:16,800
together mode and prints all the

00:14:15,040 --> 00:14:18,000
following messages that come at that

00:14:16,800 --> 00:14:20,959
point

00:14:18,000 --> 00:14:21,600
so again if no error occurs we have no

00:14:20,959 --> 00:14:23,519
output

00:14:21,600 --> 00:14:24,880
so basically you have the same effect as

00:14:23,519 --> 00:14:26,959
quiet

00:14:24,880 --> 00:14:28,480
but only in the good case only in when

00:14:26,959 --> 00:14:31,680
there is no error

00:14:28,480 --> 00:14:33,279
and that means we can keep this active

00:14:31,680 --> 00:14:36,720
during development so we don't have a

00:14:33,279 --> 00:14:36,720
different setup for development

00:14:37,360 --> 00:14:44,000
well and then when we're in user space

00:14:40,720 --> 00:14:45,680
there's udev you'd have coldplug

00:14:44,000 --> 00:14:47,440
basically for those who don't know what

00:14:45,680 --> 00:14:49,920
it means is

00:14:47,440 --> 00:14:52,000
it looks at all the devices in the

00:14:49,920 --> 00:14:54,480
system that already there

00:14:52,000 --> 00:14:55,199
and basically announces to the user

00:14:54,480 --> 00:14:58,399
space

00:14:55,199 --> 00:15:02,880
this device is available for use

00:14:58,399 --> 00:15:06,160
so this is necessary in general because

00:15:02,880 --> 00:15:08,399
well we don't know if a hardware

00:15:06,160 --> 00:15:09,680
is actually accessible right from the

00:15:08,399 --> 00:15:12,560
beginning let's

00:15:09,680 --> 00:15:14,160
for example usb devices take some time

00:15:12,560 --> 00:15:16,560
to be initialized

00:15:14,160 --> 00:15:18,880
which means that if you try to access

00:15:16,560 --> 00:15:21,360
for example a usb stick a usb master

00:15:18,880 --> 00:15:22,720
device too early it's not actually there

00:15:21,360 --> 00:15:25,360
yet

00:15:22,720 --> 00:15:26,639
so udef handles that for you but the

00:15:25,360 --> 00:15:29,279
problem is

00:15:26,639 --> 00:15:31,120
this takes a long time iterating over

00:15:29,279 --> 00:15:33,519
all existing devices in the in the

00:15:31,120 --> 00:15:33,519
system

00:15:33,680 --> 00:15:37,519
doing stuff with them enumerating data

00:15:36,480 --> 00:15:40,399
about them

00:15:37,519 --> 00:15:43,759
about them it takes time so in general

00:15:40,399 --> 00:15:47,279
we want to avoid dependencies like that

00:15:43,759 --> 00:15:51,839
which is sometimes a bit tricky

00:15:47,279 --> 00:15:53,040
because well let's take an example

00:15:51,839 --> 00:15:54,959
the root file system is mounted

00:15:53,040 --> 00:15:57,440
read-only

00:15:54,959 --> 00:15:58,480
for robustness so we need a data

00:15:57,440 --> 00:16:01,120
partition

00:15:58,480 --> 00:16:02,880
to save our configuration for example

00:16:01,120 --> 00:16:05,040
the error data

00:16:02,880 --> 00:16:05,920
this is another device it needs to be

00:16:05,040 --> 00:16:09,519
mounted

00:16:05,920 --> 00:16:13,040
it has in general a dependency on

00:16:09,519 --> 00:16:13,360
well youth well what can we do to avoid

00:16:13,040 --> 00:16:16,639
that

00:16:13,360 --> 00:16:19,040
well there is the first version is use

00:16:16,639 --> 00:16:22,480
auto modes auto mounts means

00:16:19,040 --> 00:16:25,839
um the file system is

00:16:22,480 --> 00:16:28,639
mounted automatically in the background

00:16:25,839 --> 00:16:29,360
either already starting to do that or

00:16:28,639 --> 00:16:32,160
triggered

00:16:29,360 --> 00:16:33,839
by an access to actual file on the file

00:16:32,160 --> 00:16:37,519
system

00:16:33,839 --> 00:16:41,519
which means we can start the application

00:16:37,519 --> 00:16:44,079
right at the beginning and as soon

00:16:41,519 --> 00:16:46,160
as the application tries to access a

00:16:44,079 --> 00:16:48,839
file on the file system

00:16:46,160 --> 00:16:50,079
this will block until the file system is

00:16:48,839 --> 00:16:53,279
mounted

00:16:50,079 --> 00:16:55,839
so we can do the application start up

00:16:53,279 --> 00:16:59,040
and the udif code plug and mounting of

00:16:55,839 --> 00:16:59,040
the file system in parallel

00:16:59,680 --> 00:17:02,560
saves this boot time

00:17:03,440 --> 00:17:09,839
the other version is to track systemy

00:17:06,559 --> 00:17:13,360
um this has a few requirements

00:17:09,839 --> 00:17:14,720
in general let's say we have a emmc

00:17:13,360 --> 00:17:15,679
and there is a partition for the root

00:17:14,720 --> 00:17:17,600
file system and there's a patient

00:17:15,679 --> 00:17:20,160
decision for the data

00:17:17,600 --> 00:17:21,280
and they're on the same device which

00:17:20,160 --> 00:17:23,439
means we know

00:17:21,280 --> 00:17:24,640
that if the root file system is mounted

00:17:23,439 --> 00:17:27,439
then the data partition

00:17:24,640 --> 00:17:28,240
is always available so in this specific

00:17:27,439 --> 00:17:31,039
case

00:17:28,240 --> 00:17:31,679
we do not need to wait for the device to

00:17:31,039 --> 00:17:33,280
appear

00:17:31,679 --> 00:17:34,799
because it's guaranteed to be there

00:17:33,280 --> 00:17:39,440
already

00:17:34,799 --> 00:17:43,280
and while systemd in general tries

00:17:39,440 --> 00:17:47,679
to do the generic thing

00:17:43,280 --> 00:17:51,039
so it will always add the dependency but

00:17:47,679 --> 00:17:53,919
well if we fake

00:17:51,039 --> 00:17:55,520
a retrieve we we trick systemd into

00:17:53,919 --> 00:17:58,640
believing that there is no

00:17:55,520 --> 00:18:01,360
actual device behind the file system

00:17:58,640 --> 00:18:03,360
for example um there are some file

00:18:01,360 --> 00:18:06,160
systems that don't have a device

00:18:03,360 --> 00:18:07,840
like bind mounts for example mounts um

00:18:06,160 --> 00:18:08,720
where we don't need a specific device

00:18:07,840 --> 00:18:11,760
but just the

00:18:08,720 --> 00:18:13,200
source directory there or there are

00:18:11,760 --> 00:18:14,799
other things as well

00:18:13,200 --> 00:18:16,640
and if systemd doesn't know that there

00:18:14,799 --> 00:18:18,160
is a device it will not add a dependency

00:18:16,640 --> 00:18:19,120
for the device and you have two ways to

00:18:18,160 --> 00:18:22,559
trick that

00:18:19,120 --> 00:18:25,679
one is write a manual

00:18:22,559 --> 00:18:28,799
system d mount unit and

00:18:25,679 --> 00:18:34,000
write what equals see your id

00:18:28,799 --> 00:18:36,799
equals file system uid in there

00:18:34,000 --> 00:18:37,760
it's not a path anymore not of a device

00:18:36,799 --> 00:18:39,840
in the file system

00:18:37,760 --> 00:18:41,280
in the device file system anymore and

00:18:39,840 --> 00:18:43,280
now systemd doesn't know

00:18:41,280 --> 00:18:45,039
that there's device behind it so that

00:18:43,280 --> 00:18:47,760
will not add a dependency

00:18:45,039 --> 00:18:48,640
the other way is we actually use the

00:18:47,760 --> 00:18:52,000
symlink

00:18:48,640 --> 00:18:52,000
outside of slash def

00:18:52,240 --> 00:18:56,400
and use that as the device also just

00:18:55,520 --> 00:18:58,960
simply will check

00:18:56,400 --> 00:19:00,960
is my source for mounting a device and

00:18:58,960 --> 00:19:03,200
if yes i'll add a dependency

00:19:00,960 --> 00:19:04,160
if it's outside slash f system d thinks

00:19:03,200 --> 00:19:07,360
it's not a device

00:19:04,160 --> 00:19:08,720
that will not add a dependency the trick

00:19:07,360 --> 00:19:11,520
thing is

00:19:08,720 --> 00:19:12,400
we need to do things like fs check

00:19:11,520 --> 00:19:14,080
manually so

00:19:12,400 --> 00:19:16,240
systemd doesn't know it's a device so it

00:19:14,080 --> 00:19:18,559
will not add a file system check for it

00:19:16,240 --> 00:19:22,799
so we do need to do that manual

00:19:18,559 --> 00:19:25,440
so let's look

00:19:22,799 --> 00:19:26,400
at a small example to get a feeling for

00:19:25,440 --> 00:19:29,120
how that works

00:19:26,400 --> 00:19:29,919
what it helps i had it did a small

00:19:29,120 --> 00:19:33,520
example

00:19:29,919 --> 00:19:35,520
it's a a small qt qml application

00:19:33,520 --> 00:19:37,520
it does some basic setup and then reads

00:19:35,520 --> 00:19:40,320
the files from the file system basically

00:19:37,520 --> 00:19:42,240
faking i'm reading my configuration and

00:19:40,320 --> 00:19:43,600
then it loads the qml basically loads

00:19:42,240 --> 00:19:45,280
the ui

00:19:43,600 --> 00:19:47,840
um shows the window and says hey yeah

00:19:45,280 --> 00:19:50,360
now i'm ready

00:19:47,840 --> 00:19:52,480
well let's compare it i've done this on

00:19:50,360 --> 00:19:57,440
stm32 mp1

00:19:52,480 --> 00:20:00,720
this is a rather slow cpu

00:19:57,440 --> 00:20:00,720
i use this because it

00:20:00,799 --> 00:20:04,320
gives me relatively large numbers to

00:20:03,120 --> 00:20:07,679
work with so i'm

00:20:04,320 --> 00:20:11,039
i can show the effect quite quite nicely

00:20:07,679 --> 00:20:14,000
um it's a dual core cortex

00:20:11,039 --> 00:20:15,120
a7 800 megabytes so really not nothing

00:20:14,000 --> 00:20:18,320
very fast

00:20:15,120 --> 00:20:21,200
and i've used the emmc as mass storage

00:20:18,320 --> 00:20:21,679
so in the beginning it was basically

00:20:21,200 --> 00:20:23,840
with

00:20:21,679 --> 00:20:25,200
very little other boot time

00:20:23,840 --> 00:20:26,880
optimizations

00:20:25,200 --> 00:20:29,360
we're starting at eight seconds from

00:20:26,880 --> 00:20:32,559
kernel startup

00:20:29,360 --> 00:20:34,720
um so then

00:20:32,559 --> 00:20:35,679
i tried and this gave me the eight

00:20:34,720 --> 00:20:38,880
seconds

00:20:35,679 --> 00:20:42,240
that's my baseline so

00:20:38,880 --> 00:20:44,960
with the auto mount i got

00:20:42,240 --> 00:20:47,760
seven point four seconds with the fake

00:20:44,960 --> 00:20:51,760
device i tricked systemd

00:20:47,760 --> 00:20:54,880
that's 6.7 seconds and i can of course

00:20:51,760 --> 00:20:58,320
mix the two right i can do a fake mount

00:20:54,880 --> 00:21:00,240
the fake device and still

00:20:58,320 --> 00:21:03,520
doing for example the fs check in

00:21:00,240 --> 00:21:06,960
parallel to the application startup

00:21:03,520 --> 00:21:08,880
by using automotive but in this case

00:21:06,960 --> 00:21:11,360
the same was time was actually the same

00:21:08,880 --> 00:21:14,799
because probably on the dual core device

00:21:11,360 --> 00:21:18,320
um it didn't actually help anything from

00:21:14,799 --> 00:21:19,600
because it wasn't i don't know i didn't

00:21:18,320 --> 00:21:22,400
look into details but

00:21:19,600 --> 00:21:24,559
but conceptually probably um the

00:21:22,400 --> 00:21:26,960
scheduling overhead there

00:21:24,559 --> 00:21:28,240
was worse than what i was gaining things

00:21:26,960 --> 00:21:30,400
like that

00:21:28,240 --> 00:21:32,080
and it really depends on the use case

00:21:30,400 --> 00:21:35,679
for example if the application is

00:21:32,080 --> 00:21:36,960
is loading um the file later

00:21:35,679 --> 00:21:39,039
reading data later doing more

00:21:36,960 --> 00:21:41,280
initialization at the beginning

00:21:39,039 --> 00:21:42,400
um this can have an impact or if there

00:21:41,280 --> 00:21:44,799
are more than two cores

00:21:42,400 --> 00:21:46,000
um the code plug is faster with more

00:21:44,799 --> 00:21:49,440
calls because it

00:21:46,000 --> 00:21:53,840
it scales it paralyzes quite well in

00:21:49,440 --> 00:21:55,919
in in many cases so

00:21:53,840 --> 00:21:57,679
the code block is faster with more cores

00:21:55,919 --> 00:21:58,799
while an application startup typically

00:21:57,679 --> 00:22:01,520
is single threaded

00:21:58,799 --> 00:22:02,480
so there's just one chord used for that

00:22:01,520 --> 00:22:05,440
so

00:22:02,480 --> 00:22:06,240
it really depends on on on the use case

00:22:05,440 --> 00:22:09,039
if

00:22:06,240 --> 00:22:10,799
one or the other or both of the

00:22:09,039 --> 00:22:13,919
techniques help here

00:22:10,799 --> 00:22:16,159
um auto mount has to

00:22:13,919 --> 00:22:17,039
make this is easier well there's not a

00:22:16,159 --> 00:22:20,000
lot to do

00:22:17,039 --> 00:22:21,440
but simply saying in the comment

00:22:20,000 --> 00:22:23,919
basically

00:22:21,440 --> 00:22:25,280
in the fast tab and that's it while

00:22:23,919 --> 00:22:26,799
folder for the other case we

00:22:25,280 --> 00:22:28,320
just need to add assembling or we need

00:22:26,799 --> 00:22:30,480
to write a full

00:22:28,320 --> 00:22:33,760
unit file and we need to handle the fs

00:22:30,480 --> 00:22:37,280
check manual these kind of things

00:22:33,760 --> 00:22:40,559
okay what's next so

00:22:37,280 --> 00:22:43,760
call plug is used

00:22:40,559 --> 00:22:45,039
for more than just saying there's a

00:22:43,760 --> 00:22:47,679
device it also

00:22:45,039 --> 00:22:48,799
does some initialization for example it

00:22:47,679 --> 00:22:52,000
can do

00:22:48,799 --> 00:22:54,640
um changing the

00:22:52,000 --> 00:22:56,880
can change the the ownership which when

00:22:54,640 --> 00:22:57,679
we look at security is important that

00:22:56,880 --> 00:23:00,000
for example

00:22:57,679 --> 00:23:02,159
the device is actually accessible by the

00:23:00,000 --> 00:23:05,280
application

00:23:02,159 --> 00:23:07,440
um and so

00:23:05,280 --> 00:23:09,600
if you want to do that the application

00:23:07,440 --> 00:23:12,720
does not it's not running as root which

00:23:09,600 --> 00:23:13,280
it hopefully doesn't and then we need to

00:23:12,720 --> 00:23:16,320
wait

00:23:13,280 --> 00:23:17,200
for udev to change the ownership and the

00:23:16,320 --> 00:23:19,280
group

00:23:17,200 --> 00:23:20,840
of device phone we could do this

00:23:19,280 --> 00:23:24,720
manually of course

00:23:20,840 --> 00:23:26,640
but then we're adding extra stuff

00:23:24,720 --> 00:23:28,400
or in there need to implement things

00:23:26,640 --> 00:23:29,840
ourselves so it's something that i'd

00:23:28,400 --> 00:23:32,640
like to avoid and

00:23:29,840 --> 00:23:33,760
of course changing the ownership chip is

00:23:32,640 --> 00:23:35,919
only

00:23:33,760 --> 00:23:36,880
a very small part something something

00:23:35,919 --> 00:23:38,960
simple there are

00:23:36,880 --> 00:23:40,400
more complex things that you can do with

00:23:38,960 --> 00:23:43,360
udef

00:23:40,400 --> 00:23:44,000
so and what you can do here is split the

00:23:43,360 --> 00:23:47,279
udiv

00:23:44,000 --> 00:23:48,159
you'd have this code plug is this udif

00:23:47,279 --> 00:23:51,200
admin

00:23:48,159 --> 00:23:51,919
trigger which enumerates the existing

00:23:51,200 --> 00:23:55,440
devices

00:23:51,919 --> 00:23:58,240
and what you can do here is say well

00:23:55,440 --> 00:23:58,720
i don't want to trigger all devices but

00:23:58,240 --> 00:24:02,159
maybe

00:23:58,720 --> 00:24:05,520
in my case it's for example only the drm

00:24:02,159 --> 00:24:08,559
devices the graphics devices

00:24:05,520 --> 00:24:09,039
so we're reducing the load for the cold

00:24:08,559 --> 00:24:11,600
plug

00:24:09,039 --> 00:24:12,799
to make it run faster because we don't

00:24:11,600 --> 00:24:15,039
have a lot

00:24:12,799 --> 00:24:15,039
of

00:24:16,799 --> 00:24:24,000
ways to actually order

00:24:21,279 --> 00:24:26,080
which device comes first so if we reduce

00:24:24,000 --> 00:24:29,120
the amount of devices to only those that

00:24:26,080 --> 00:24:32,159
we actually need at boot time

00:24:29,120 --> 00:24:34,799
we can make this part faster

00:24:32,159 --> 00:24:36,080
and then when the application is done

00:24:34,799 --> 00:24:38,960
starting

00:24:36,080 --> 00:24:40,240
we can do the other half all other

00:24:38,960 --> 00:24:42,159
devices

00:24:40,240 --> 00:24:44,000
and we did still do the code block it's

00:24:42,159 --> 00:24:46,640
we still have a full setup of our

00:24:44,000 --> 00:24:47,360
of our system but we've just split it in

00:24:46,640 --> 00:24:50,159
parts

00:24:47,360 --> 00:24:51,039
and one is run when we need it during

00:24:50,159 --> 00:24:52,720
the hot path

00:24:51,039 --> 00:24:54,240
and the rest is run after the

00:24:52,720 --> 00:24:55,520
application it doesn't really matter

00:24:54,240 --> 00:24:59,440
when it's running here

00:24:55,520 --> 00:24:59,440
so this gives us a way to

00:24:59,520 --> 00:25:05,039
yeah um delay a lot of device

00:25:02,799 --> 00:25:08,000
initializations

00:25:05,039 --> 00:25:08,960
it can actually be used if you don't do

00:25:08,000 --> 00:25:10,559
the udef

00:25:08,960 --> 00:25:12,240
it's not written that down here but if

00:25:10,559 --> 00:25:15,279
you don't do the udef

00:25:12,240 --> 00:25:18,720
for a certain group of devices

00:25:15,279 --> 00:25:20,960
this may mean for example

00:25:18,720 --> 00:25:22,240
that um they're not loading the modules

00:25:20,960 --> 00:25:25,279
for it

00:25:22,240 --> 00:25:27,360
possibly um

00:25:25,279 --> 00:25:29,520
i'm not sure if that's right maybe not

00:25:27,360 --> 00:25:31,039
but you're not initializing the devices

00:25:29,520 --> 00:25:35,120
for the user space you can

00:25:31,039 --> 00:25:37,600
um you can delay things

00:25:35,120 --> 00:25:38,320
until they're actually needed maybe not

00:25:37,600 --> 00:25:42,080
at all

00:25:38,320 --> 00:25:46,640
or maybe only for development

00:25:42,080 --> 00:25:46,640
or for maintenance these kind of things

00:25:48,159 --> 00:25:53,120
okay so let's say well we don't need any

00:25:52,159 --> 00:25:56,000
devices here

00:25:53,120 --> 00:25:56,320
or only devices that are already there

00:25:56,000 --> 00:25:59,279
and

00:25:56,320 --> 00:26:00,480
waiting for the initial setup with

00:25:59,279 --> 00:26:03,919
systemd

00:26:00,480 --> 00:26:05,440
is too slow before we actually want to

00:26:03,919 --> 00:26:08,559
show something on the screen

00:26:05,440 --> 00:26:08,559
then we can do a bootslash

00:26:09,679 --> 00:26:13,120
with an application with very simple

00:26:11,440 --> 00:26:16,000
application

00:26:13,120 --> 00:26:18,080
it runs as pit1 so we're executing it

00:26:16,000 --> 00:26:21,200
instead of systemd

00:26:18,080 --> 00:26:24,799
and well it just

00:26:21,200 --> 00:26:28,960
shows a static image on the screen

00:26:24,799 --> 00:26:31,679
and then it forks and one application

00:26:28,960 --> 00:26:33,760
just the the child just stays there in

00:26:31,679 --> 00:26:37,840
the background because if you use crm

00:26:33,760 --> 00:26:40,960
and the application exits well then

00:26:37,840 --> 00:26:42,159
device is closed the content is lost the

00:26:40,960 --> 00:26:43,679
display goes up and

00:26:42,159 --> 00:26:45,679
goes off again so we don't want to do

00:26:43,679 --> 00:26:48,480
that so it stays around

00:26:45,679 --> 00:26:50,400
but it does release the drm master this

00:26:48,480 --> 00:26:51,360
basically means if another application

00:26:50,400 --> 00:26:54,000
comes later

00:26:51,360 --> 00:26:55,200
and opens the drm device as well it is

00:26:54,000 --> 00:26:57,679
actually allowed to

00:26:55,200 --> 00:26:59,360
do that and to provide new content for

00:26:57,679 --> 00:27:01,360
the screen

00:26:59,360 --> 00:27:03,440
then at that point we can kill the

00:27:01,360 --> 00:27:05,840
application

00:27:03,440 --> 00:27:07,279
because another new application has

00:27:05,840 --> 00:27:10,240
taken over the screen

00:27:07,279 --> 00:27:12,640
so and the pit 1 after forking the child

00:27:10,240 --> 00:27:16,159
will simply execute system d

00:27:12,640 --> 00:27:18,840
this is a relatively easy way to provide

00:27:16,159 --> 00:27:20,000
something on the screen and we can get

00:27:18,840 --> 00:27:22,080
usually

00:27:20,000 --> 00:27:23,200
order of magnitude about one second

00:27:22,080 --> 00:27:25,840
after power on this

00:27:23,200 --> 00:27:27,039
is manageable in many cases it depends

00:27:25,840 --> 00:27:29,120
really on the hardware

00:27:27,039 --> 00:27:30,640
but that's about the order of magnitude

00:27:29,120 --> 00:27:31,360
what you can reach with that maybe a bit

00:27:30,640 --> 00:27:34,399
faster maybe

00:27:31,360 --> 00:27:36,320
slower and in many cases

00:27:34,399 --> 00:27:38,559
i've often done boot time optimization

00:27:36,320 --> 00:27:41,600
and say okay here and we do this and

00:27:38,559 --> 00:27:43,279
we have ideas and well whenever we put

00:27:41,600 --> 00:27:44,399
your boot screen to get something on the

00:27:43,279 --> 00:27:46,159
screen and then we can

00:27:44,399 --> 00:27:47,679
optimize the rest but we have a bit more

00:27:46,159 --> 00:27:50,000
and then say hey butchwin

00:27:47,679 --> 00:27:50,960
well something on the screen after one

00:27:50,000 --> 00:27:52,799
second ready

00:27:50,960 --> 00:27:54,080
great we're done we don't need anything

00:27:52,799 --> 00:27:55,840
more because

00:27:54,080 --> 00:27:57,520
in many cases that's actually the

00:27:55,840 --> 00:27:58,080
biggest concern is your power on the

00:27:57,520 --> 00:28:00,399
device

00:27:58,080 --> 00:28:03,279
and the device has nothing and their

00:28:00,399 --> 00:28:06,880
boot screen really helps

00:28:03,279 --> 00:28:08,480
right um but sometimes it doesn't

00:28:06,880 --> 00:28:10,000
because we actually need to do something

00:28:08,480 --> 00:28:13,360
early

00:28:10,000 --> 00:28:14,799
and but now it gets complicated i try to

00:28:13,360 --> 00:28:18,399
avoid this because

00:28:14,799 --> 00:28:20,559
writing applications to run barely

00:28:18,399 --> 00:28:22,240
requires a lot more attention to the

00:28:20,559 --> 00:28:23,840
details you need to know what's

00:28:22,240 --> 00:28:25,840
available what's not there's no

00:28:23,840 --> 00:28:27,679
temporary file system available at that

00:28:25,840 --> 00:28:29,279
point you may need to mount some file

00:28:27,679 --> 00:28:32,640
system the procfs or

00:28:29,279 --> 00:28:33,679
sysfs or things like that explicitly

00:28:32,640 --> 00:28:35,120
manually

00:28:33,679 --> 00:28:37,520
because they're not available at that

00:28:35,120 --> 00:28:38,559
point so this makes things a lot more

00:28:37,520 --> 00:28:41,360
complex

00:28:38,559 --> 00:28:41,840
and i'd like to avoid that um to to

00:28:41,360 --> 00:28:43,840
allow

00:28:41,840 --> 00:28:45,039
application developers just to write

00:28:43,840 --> 00:28:48,000
their normal applications

00:28:45,039 --> 00:28:49,600
but sometimes it's necessary and then we

00:28:48,000 --> 00:28:51,120
don't have a bootsplash application but

00:28:49,600 --> 00:28:52,720
a regular application that's actually

00:28:51,120 --> 00:28:54,640
doing more than just dump something on

00:28:52,720 --> 00:28:58,399
the screen and then wait

00:28:54,640 --> 00:29:00,159
and again with fork hit one

00:28:58,399 --> 00:29:02,320
start system d and the other one runs in

00:29:00,159 --> 00:29:05,440
parallel the problem with that

00:29:02,320 --> 00:29:08,640
is that when we do that we cannot

00:29:05,440 --> 00:29:10,320
um we can no longer use a lot of the

00:29:08,640 --> 00:29:12,000
features from systemd because

00:29:10,320 --> 00:29:13,360
this application runs out of this

00:29:12,000 --> 00:29:14,960
outside of

00:29:13,360 --> 00:29:16,799
scope of systemd where the system

00:29:14,960 --> 00:29:20,799
detracts the applications

00:29:16,799 --> 00:29:21,760
so no research no resource limits all

00:29:20,799 --> 00:29:25,279
these kind of things

00:29:21,760 --> 00:29:29,360
are not limited we can

00:29:25,279 --> 00:29:32,720
improve things a bit harder i mean

00:29:29,360 --> 00:29:35,919
for services and things like that

00:29:32,720 --> 00:29:38,559
systemd uses c groups and moving

00:29:35,919 --> 00:29:39,840
applications or processes from one c

00:29:38,559 --> 00:29:42,399
group to another

00:29:39,840 --> 00:29:43,200
is possible you need to correct uh

00:29:42,399 --> 00:29:46,159
permissions

00:29:43,200 --> 00:29:47,679
so we need to take care of that but in

00:29:46,159 --> 00:29:49,760
general you can import

00:29:47,679 --> 00:29:50,799
this running application into a service

00:29:49,760 --> 00:29:54,240
later on

00:29:50,799 --> 00:29:57,760
that's possible however

00:29:54,240 --> 00:30:00,000
it only it's only part of deal right

00:29:57,760 --> 00:30:02,159
we can now track if the application

00:30:00,000 --> 00:30:05,919
exits and if we do things right with

00:30:02,159 --> 00:30:08,240
telling systemd this is the new new um

00:30:05,919 --> 00:30:09,360
actual the pit of this app if they're

00:30:08,240 --> 00:30:11,200
still running already running

00:30:09,360 --> 00:30:12,880
application is actually the main pit so

00:30:11,200 --> 00:30:17,039
this is the main process we can

00:30:12,880 --> 00:30:18,480
track yes this service

00:30:17,039 --> 00:30:20,880
has failed because the application

00:30:18,480 --> 00:30:22,320
exited we can do that

00:30:20,880 --> 00:30:24,559
and we can actually do things like

00:30:22,320 --> 00:30:27,520
watchdog because this um

00:30:24,559 --> 00:30:28,720
sd notify socket that's used to do this

00:30:27,520 --> 00:30:32,159
watchdog pinging

00:30:28,720 --> 00:30:33,919
to systemd um

00:30:32,159 --> 00:30:36,559
we can pass that socket to another

00:30:33,919 --> 00:30:38,480
application but it requires work

00:30:36,559 --> 00:30:40,559
and it's only half the deal because

00:30:38,480 --> 00:30:44,320
things like

00:30:40,559 --> 00:30:44,320
resource limits

00:30:44,640 --> 00:30:49,520
other restricted access the security

00:30:47,440 --> 00:30:52,080
features basically they're not available

00:30:49,520 --> 00:30:54,159
because the setup for that happens

00:30:52,080 --> 00:30:55,360
before the apps application is forked by

00:30:54,159 --> 00:30:58,240
system

00:30:55,360 --> 00:30:59,039
before it exit so system defaults sets

00:30:58,240 --> 00:31:01,279
up the

00:30:59,039 --> 00:31:03,200
the limits and then execs the actual

00:31:01,279 --> 00:31:04,080
process that's not possible when we

00:31:03,200 --> 00:31:07,200
import the

00:31:04,080 --> 00:31:08,399
process what we can also do instead of

00:31:07,200 --> 00:31:10,559
importing we can

00:31:08,399 --> 00:31:12,080
restart it basically but that means

00:31:10,559 --> 00:31:13,919
while there's a running application a

00:31:12,080 --> 00:31:14,960
new one starts and we need to transfer

00:31:13,919 --> 00:31:18,480
the state

00:31:14,960 --> 00:31:21,360
from one application to the other

00:31:18,480 --> 00:31:21,760
it's possible but it's all a lot of work

00:31:21,360 --> 00:31:24,559
so

00:31:21,760 --> 00:31:25,679
i try to avoid that when possible but

00:31:24,559 --> 00:31:28,240
it's

00:31:25,679 --> 00:31:29,360
a way to get the best of both worlds i

00:31:28,240 --> 00:31:31,600
know there are

00:31:29,360 --> 00:31:34,000
proponents that say well if you really

00:31:31,600 --> 00:31:36,399
want to boot fast you need to run it

00:31:34,000 --> 00:31:37,120
your application as pit 1 well here's a

00:31:36,399 --> 00:31:40,640
way to

00:31:37,120 --> 00:31:44,000
mix that with with some work to

00:31:40,640 --> 00:31:46,640
get most or almost all features from

00:31:44,000 --> 00:31:49,360
systemds while all the

00:31:46,640 --> 00:31:51,039
additional stuff we have and if you do

00:31:49,360 --> 00:31:54,799
it right you can actually

00:31:51,039 --> 00:31:56,240
um test both ways basically you can

00:31:54,799 --> 00:31:57,440
restart the application normal as a

00:31:56,240 --> 00:31:59,600
service and you can do

00:31:57,440 --> 00:32:00,480
the importing and these kind of things

00:31:59,600 --> 00:32:03,600
there are ways

00:32:00,480 --> 00:32:04,399
to test that a bit but um it gives you a

00:32:03,600 --> 00:32:08,480
lot more

00:32:04,399 --> 00:32:12,559
features and mixing uh basically

00:32:08,480 --> 00:32:16,159
the two ways and still have fast booting

00:32:12,559 --> 00:32:18,880
and all the features and actually

00:32:16,159 --> 00:32:20,240
if you put a lot of work in it for both

00:32:18,880 --> 00:32:23,200
of the cases both the

00:32:20,240 --> 00:32:26,480
splash and the application you can do

00:32:23,200 --> 00:32:28,480
that in it already and in remfs

00:32:26,480 --> 00:32:29,679
it saves a little more time possibly

00:32:28,480 --> 00:32:30,960
because you don't need to mount the root

00:32:29,679 --> 00:32:32,559
file system

00:32:30,960 --> 00:32:35,039
it really depends on your device if you

00:32:32,559 --> 00:32:36,960
have a root file system that where the

00:32:35,039 --> 00:32:38,960
device is detected very fast

00:32:36,960 --> 00:32:40,480
and mounting is very fast then you don't

00:32:38,960 --> 00:32:42,320
save a lot but if

00:32:40,480 --> 00:32:43,760
mounting the root file system takes a

00:32:42,320 --> 00:32:47,200
lot of time

00:32:43,760 --> 00:32:49,679
comparatively then init rd can be used

00:32:47,200 --> 00:32:50,399
to start the application but it this

00:32:49,679 --> 00:32:53,200
means

00:32:50,399 --> 00:32:54,880
even more work you don't just have to

00:32:53,200 --> 00:32:56,960
exact systemd

00:32:54,880 --> 00:33:00,559
and do more things later on but you'll

00:32:56,960 --> 00:33:02,960
have to first mount the root file system

00:33:00,559 --> 00:33:04,799
to the change root kind of things and

00:33:02,960 --> 00:33:08,080
then x axis

00:33:04,799 --> 00:33:10,159
fork and existing key so there are ways

00:33:08,080 --> 00:33:14,720
to mix all these kind of features

00:33:10,159 --> 00:33:14,720
but every step is a bit more work

00:33:15,440 --> 00:33:22,799
right debugging um

00:33:18,880 --> 00:33:22,799
this is actually interesting because

00:33:23,279 --> 00:33:27,679
at some point some a while ago a

00:33:25,760 --> 00:33:29,039
colleague came away and want to debug

00:33:27,679 --> 00:33:31,600
here's an issue and

00:33:29,039 --> 00:33:32,080
what should i do and another colleague

00:33:31,600 --> 00:33:35,200
says

00:33:32,080 --> 00:33:36,840
hey use um function tracer to

00:33:35,200 --> 00:33:38,880
to see what's actually happening in the

00:33:36,840 --> 00:33:41,200
kernel as i hear

00:33:38,880 --> 00:33:43,120
function tracing there's nothing here

00:33:41,200 --> 00:33:44,399
this this file and debug fs where i

00:33:43,120 --> 00:33:45,279
should write something in there it's not

00:33:44,399 --> 00:33:47,919
there

00:33:45,279 --> 00:33:49,519
once realized well yeah it wasn't there

00:33:47,919 --> 00:33:52,880
because

00:33:49,519 --> 00:33:55,760
the kernel was boot time optimized

00:33:52,880 --> 00:33:57,200
and the tracing was disabled in this

00:33:55,760 --> 00:34:02,240
specific case

00:33:57,200 --> 00:34:05,600
um enabling the tracing infrastructure

00:34:02,240 --> 00:34:07,200
this was not a lot of work i mean

00:34:05,600 --> 00:34:09,919
that's just sports on our development

00:34:07,200 --> 00:34:12,159
tasks but if we're talking about i i

00:34:09,919 --> 00:34:14,720
talked a bit at the beginning about

00:34:12,159 --> 00:34:16,480
debugging in field then that's a whole

00:34:14,720 --> 00:34:20,240
different cable again

00:34:16,480 --> 00:34:23,280
so i'd like to keep debugging features

00:34:20,240 --> 00:34:26,639
but the tracing is at this point well

00:34:23,280 --> 00:34:28,320
these are the numbers from the same

00:34:26,639 --> 00:34:30,639
example from the same hardware i had

00:34:28,320 --> 00:34:33,040
before for the other example so

00:34:30,639 --> 00:34:34,320
out of the eight seconds originally for

00:34:33,040 --> 00:34:38,159
good

00:34:34,320 --> 00:34:40,720
1.4 seconds were from kernel start until

00:34:38,159 --> 00:34:42,320
root file system is mounted and out of

00:34:40,720 --> 00:34:45,599
that 1.4 seconds

00:34:42,320 --> 00:34:48,639
0.9 seconds so two thirds basically

00:34:45,599 --> 00:34:50,800
were just some initialization

00:34:48,639 --> 00:34:52,320
for chord tracing it's not just function

00:34:50,800 --> 00:34:54,399
tracers but there are other traces but

00:34:52,320 --> 00:34:57,200
basically that's some

00:34:54,399 --> 00:34:58,480
core tracing infrastructure that is

00:34:57,200 --> 00:34:59,520
needed by multiple features in the

00:34:58,480 --> 00:35:01,280
kernel and that's

00:34:59,520 --> 00:35:03,040
enabled by multiple features if you if

00:35:01,280 --> 00:35:07,119
you switch them on in chrome config

00:35:03,040 --> 00:35:10,880
so well 0.9 seconds is a lot

00:35:07,119 --> 00:35:13,280
so well should we disable it

00:35:10,880 --> 00:35:14,839
probably right now it's the only way if

00:35:13,280 --> 00:35:17,760
you really need that

00:35:14,839 --> 00:35:19,280
but i did spend a little time of looking

00:35:17,760 --> 00:35:20,640
what's actually going on there and i

00:35:19,280 --> 00:35:23,920
noticed

00:35:20,640 --> 00:35:25,040
in the end so i'm not really a kernel

00:35:23,920 --> 00:35:27,520
developer

00:35:25,040 --> 00:35:28,960
i know my way around it a bit and i've

00:35:27,520 --> 00:35:31,119
done a bit of kernel

00:35:28,960 --> 00:35:32,400
development but mostly i'm a user space

00:35:31,119 --> 00:35:34,880
guy

00:35:32,400 --> 00:35:36,240
but from what it looks like to me there

00:35:34,880 --> 00:35:38,720
is some function

00:35:36,240 --> 00:35:40,320
that's called initially for the kernel

00:35:38,720 --> 00:35:41,920
basically all the code that's already

00:35:40,320 --> 00:35:44,480
there

00:35:41,920 --> 00:35:46,880
and later on the same function is called

00:35:44,480 --> 00:35:49,599
for each module that is loaded

00:35:46,880 --> 00:35:50,480
to me that sounds like it's probably

00:35:49,599 --> 00:35:53,280
something

00:35:50,480 --> 00:35:55,680
we can delay as well for the kernel part

00:35:53,280 --> 00:35:58,000
we don't need to do it immediately

00:35:55,680 --> 00:36:00,000
because we're doing later stuff later

00:35:58,000 --> 00:36:02,480
for the modules as well so

00:36:00,000 --> 00:36:03,839
it's probably something maybe something

00:36:02,480 --> 00:36:07,119
we can delay

00:36:03,839 --> 00:36:07,839
until we actually do some kind of

00:36:07,119 --> 00:36:11,040
tracing

00:36:07,839 --> 00:36:12,000
now i know we can do enable tracing via

00:36:11,040 --> 00:36:13,680
the kernel command line

00:36:12,000 --> 00:36:15,599
so in that case it has to be started

00:36:13,680 --> 00:36:17,680
immediately but in the

00:36:15,599 --> 00:36:19,119
production system on the real hardware

00:36:17,680 --> 00:36:21,119
in the field

00:36:19,119 --> 00:36:24,320
we don't enable tracing on the kernel

00:36:21,119 --> 00:36:27,440
command line so my hope is

00:36:24,320 --> 00:36:28,400
we can actually remove those 900

00:36:27,440 --> 00:36:31,200
milliseconds or

00:36:28,400 --> 00:36:33,440
a lot of those 900 milliseconds and do

00:36:31,200 --> 00:36:36,640
that sometime later

00:36:33,440 --> 00:36:38,720
i've not done that yet or rather i have

00:36:36,640 --> 00:36:40,160
not had the chance to ask a colleague to

00:36:38,720 --> 00:36:40,880
do it for me because those are the

00:36:40,160 --> 00:36:43,200
kernel hackers

00:36:40,880 --> 00:36:44,240
because while i was preparing a

00:36:43,200 --> 00:36:45,760
presentation

00:36:44,240 --> 00:36:48,000
for conference and this is not a

00:36:45,760 --> 00:36:51,040
customer project we have

00:36:48,000 --> 00:36:52,880
a bit more of a budget to spend to

00:36:51,040 --> 00:36:54,800
do something with development but my

00:36:52,880 --> 00:36:58,560
hope is here

00:36:54,800 --> 00:36:59,920
to actually eventually get rid of those

00:36:58,560 --> 00:37:01,680
900 milliseconds

00:36:59,920 --> 00:37:02,960
in this hardware it's faster and under

00:37:01,680 --> 00:37:06,480
hardware

00:37:02,960 --> 00:37:08,480
to be able to keep the tracing

00:37:06,480 --> 00:37:11,920
infrastructure enabled

00:37:08,480 --> 00:37:14,240
without the penalty the big penalty well

00:37:11,920 --> 00:37:15,040
yeah let's see patch opportunities maybe

00:37:14,240 --> 00:37:17,680
someone else

00:37:15,040 --> 00:37:19,680
finds some time to look at that now that

00:37:17,680 --> 00:37:22,720
i've pointed it out and

00:37:19,680 --> 00:37:24,720
we'll get that fixed and then

00:37:22,720 --> 00:37:26,400
next two kernel works maybe let's see

00:37:24,720 --> 00:37:28,079
maybe the next time i get a boot time

00:37:26,400 --> 00:37:29,680
optimization project on my desk i can

00:37:28,079 --> 00:37:32,960
say hey here i know there's

00:37:29,680 --> 00:37:36,480
some optimization possibilities

00:37:32,960 --> 00:37:38,960
and we'll get someone to do it

00:37:36,480 --> 00:37:40,800
and then another interesting topic is

00:37:38,960 --> 00:37:44,079
security

00:37:40,800 --> 00:37:45,760
i mean for me

00:37:44,079 --> 00:37:47,680
my perspective for boot time

00:37:45,760 --> 00:37:49,280
optimization is usually i provide a

00:37:47,680 --> 00:37:51,680
platform right

00:37:49,280 --> 00:37:53,200
private linux kernel the basic user

00:37:51,680 --> 00:37:56,720
space libraries let's see

00:37:53,200 --> 00:37:58,640
a systemd and customers

00:37:56,720 --> 00:38:00,079
they're writing the actual applications

00:37:58,640 --> 00:38:03,359
that does the real things

00:38:00,079 --> 00:38:05,119
the important things so when i do boot

00:38:03,359 --> 00:38:06,800
time optimizations one of the biggest

00:38:05,119 --> 00:38:08,640
problems i have is

00:38:06,800 --> 00:38:10,560
that there is one application in many

00:38:08,640 --> 00:38:14,160
cases there's one application

00:38:10,560 --> 00:38:16,240
there's a black box for me basically

00:38:14,160 --> 00:38:17,680
and when i ask the customer often

00:38:16,240 --> 00:38:20,160
doesn't actually know

00:38:17,680 --> 00:38:23,280
what the requirements actually are so

00:38:20,160 --> 00:38:25,680
which devices are used

00:38:23,280 --> 00:38:27,359
what other dependencies in my system do

00:38:25,680 --> 00:38:28,160
i have which file systems will be

00:38:27,359 --> 00:38:30,720
accessed

00:38:28,160 --> 00:38:34,400
so it's one big black box for me and

00:38:30,720 --> 00:38:35,760
makes it really hard to optimize because

00:38:34,400 --> 00:38:37,599
exactly the kind of things that are

00:38:35,760 --> 00:38:39,520
proposed to move things later

00:38:37,599 --> 00:38:41,520
i can only do that if i know they're not

00:38:39,520 --> 00:38:43,599
used that i know they're not needed

00:38:41,520 --> 00:38:45,440
to start this application and that's

00:38:43,599 --> 00:38:49,359
versus where security comes in

00:38:45,440 --> 00:38:50,800
because with real good security concept

00:38:49,359 --> 00:38:52,960
you split your application there's not

00:38:50,800 --> 00:38:57,119
one single monolithic application but

00:38:52,960 --> 00:38:59,599
you do multiple processes to make

00:38:57,119 --> 00:39:01,040
uh privileged separation possible so you

00:38:59,599 --> 00:39:04,720
have one

00:39:01,040 --> 00:39:06,720
process that is only for the ui

00:39:04,720 --> 00:39:09,119
maybe and then maybe a control process

00:39:06,720 --> 00:39:11,599
in the back and another process that has

00:39:09,119 --> 00:39:12,839
communication to the outside these kind

00:39:11,599 --> 00:39:16,720
of things

00:39:12,839 --> 00:39:21,599
and the interfaces are clearly defined

00:39:16,720 --> 00:39:21,599
because if it's not specified

00:39:21,680 --> 00:39:24,880
it's not allowed to access something so

00:39:24,000 --> 00:39:28,000
if there is

00:39:24,880 --> 00:39:29,839
some hardware that can be accessed

00:39:28,000 --> 00:39:31,359
it will get a permission denied because

00:39:29,839 --> 00:39:32,480
we didn't specify that it's allowed to

00:39:31,359 --> 00:39:36,160
access this hardware

00:39:32,480 --> 00:39:36,960
so we have split and split into multi

00:39:36,160 --> 00:39:38,640
applications

00:39:36,960 --> 00:39:40,800
we have clear definitions on what's

00:39:38,640 --> 00:39:41,599
actually needed and it helps actually a

00:39:40,800 --> 00:39:44,640
lot

00:39:41,599 --> 00:39:46,480
to do but time optimizations because all

00:39:44,640 --> 00:39:50,000
this information i can use

00:39:46,480 --> 00:39:51,119
to do my ordering and that's something i

00:39:50,000 --> 00:39:52,400
can communicate

00:39:51,119 --> 00:39:54,240
where i can communicate with the

00:39:52,400 --> 00:39:56,400
customer because in many cases where we

00:39:54,240 --> 00:39:57,599
don't know what we need and what we use

00:39:56,400 --> 00:39:59,520
but hey

00:39:57,599 --> 00:40:01,280
does it matter the application is

00:39:59,520 --> 00:40:01,760
running it started we've already done

00:40:01,280 --> 00:40:03,280
this

00:40:01,760 --> 00:40:05,119
working on this project for half a year

00:40:03,280 --> 00:40:06,800
and it was no problem why don't you do

00:40:05,119 --> 00:40:09,200
your boot time optimizations and

00:40:06,800 --> 00:40:10,240
let us work on an application so and

00:40:09,200 --> 00:40:13,680
with

00:40:10,240 --> 00:40:15,760
security there is

00:40:13,680 --> 00:40:17,760
all this information available because

00:40:15,760 --> 00:40:19,760
someone needs to say okay here

00:40:17,760 --> 00:40:23,119
access to this hardware is allowed which

00:40:19,760 --> 00:40:26,319
means this hardware is needed

00:40:23,119 --> 00:40:27,520
so there is opportunities here but there

00:40:26,319 --> 00:40:30,640
are of of course

00:40:27,520 --> 00:40:34,560
um also downsides i mean

00:40:30,640 --> 00:40:36,880
security has a penalty always

00:40:34,560 --> 00:40:39,599
there is always some overhead when you

00:40:36,880 --> 00:40:41,520
enable some feature

00:40:39,599 --> 00:40:42,720
i mean we've seen that with all the

00:40:41,520 --> 00:40:44,800
hardware

00:40:42,720 --> 00:40:47,040
vulnerabilities how much overhead

00:40:44,800 --> 00:40:51,200
security in these cases can be

00:40:47,040 --> 00:40:53,200
and if you enable features like setcomp

00:40:51,200 --> 00:40:56,400
which system provides which basically

00:40:53,200 --> 00:40:58,480
means that for aston system call you do

00:40:56,400 --> 00:41:00,319
we track if it's allowed to be called

00:40:58,480 --> 00:41:02,560
that check costs

00:41:00,319 --> 00:41:03,520
so and it slows down startup time as

00:41:02,560 --> 00:41:06,560
well so

00:41:03,520 --> 00:41:09,599
um there is an overhead but also

00:41:06,560 --> 00:41:11,839
opportunities because we can mix the

00:41:09,599 --> 00:41:15,359
effort to do boot time optimization with

00:41:11,839 --> 00:41:15,359
the effort to do security

00:41:17,359 --> 00:41:20,800
and one last thing i want to talk about

00:41:19,839 --> 00:41:23,440
it's hardware

00:41:20,800 --> 00:41:24,960
i mean in general you say premature

00:41:23,440 --> 00:41:27,920
optimization

00:41:24,960 --> 00:41:29,040
and these kind of things right well i'm

00:41:27,920 --> 00:41:31,359
saying

00:41:29,040 --> 00:41:33,040
if you want to boot fast you better

00:41:31,359 --> 00:41:34,640
think about that when you design your

00:41:33,040 --> 00:41:37,920
hardware

00:41:34,640 --> 00:41:41,040
because the wrongly designed hardware

00:41:37,920 --> 00:41:43,359
is always a problem because that's not

00:41:41,040 --> 00:41:46,960
something you can fix in software

00:41:43,359 --> 00:41:50,480
most important thing is use fast

00:41:46,960 --> 00:41:53,839
mass storage really really important

00:41:50,480 --> 00:41:55,200
because at the end of the day

00:41:53,839 --> 00:41:58,560
you're loading a lot of code you're

00:41:55,200 --> 00:42:02,560
loading a lot of data from the device

00:41:58,560 --> 00:42:05,280
if the device runs twice as fast

00:42:02,560 --> 00:42:06,880
takes half the time of course you can

00:42:05,280 --> 00:42:10,000
try to load less

00:42:06,880 --> 00:42:10,560
but still if it's faster to load it's

00:42:10,000 --> 00:42:14,800
still

00:42:10,560 --> 00:42:17,440
faster to run and then there is usb

00:42:14,800 --> 00:42:18,400
usb from the specification has certain

00:42:17,440 --> 00:42:21,200
timeouts

00:42:18,400 --> 00:42:22,000
so it takes some time before a device is

00:42:21,200 --> 00:42:24,960
available

00:42:22,000 --> 00:42:26,400
if we need that device at good time

00:42:24,960 --> 00:42:28,400
that's not something we can

00:42:26,400 --> 00:42:30,640
reduce right we can rid off the talent

00:42:28,400 --> 00:42:33,200
there's actually a good example from

00:42:30,640 --> 00:42:34,319
the one good time optimization task talk

00:42:33,200 --> 00:42:36,800
from last time

00:42:34,319 --> 00:42:37,920
last year because it basically was a usb

00:42:36,800 --> 00:42:40,640
camera

00:42:37,920 --> 00:42:41,520
and the content was sent to the screen

00:42:40,640 --> 00:42:43,920
and i think

00:42:41,520 --> 00:42:45,040
at the end of at the end of all

00:42:43,920 --> 00:42:48,480
optimizations

00:42:45,040 --> 00:42:50,400
half the time was spent on

00:42:48,480 --> 00:42:52,880
waiting for the usb camera to be

00:42:50,400 --> 00:42:52,880
available

00:42:53,359 --> 00:42:57,200
and i mean that's frustrating right

00:42:55,839 --> 00:42:58,960
you're doing all these kind of

00:42:57,200 --> 00:43:01,040
this kind of good work to get the

00:42:58,960 --> 00:43:04,640
software for us and then you have this

00:43:01,040 --> 00:43:06,960
hardware limitation that

00:43:04,640 --> 00:43:08,640
basically says here's my heart limit

00:43:06,960 --> 00:43:10,640
doesn't get better

00:43:08,640 --> 00:43:12,400
and there are other ways for example

00:43:10,640 --> 00:43:14,480
with as there are

00:43:12,400 --> 00:43:15,440
on system on chips camera interfaces

00:43:14,480 --> 00:43:17,680
where you can

00:43:15,440 --> 00:43:19,680
use a camera that's actually fast to

00:43:17,680 --> 00:43:21,119
start

00:43:19,680 --> 00:43:23,520
and all these kind of things so think

00:43:21,119 --> 00:43:24,880
about what you want to do when you

00:43:23,520 --> 00:43:27,440
design your hardware

00:43:24,880 --> 00:43:28,079
when you say i want i need to boot fast

00:43:27,440 --> 00:43:31,280
i need

00:43:28,079 --> 00:43:34,400
to boot within a certain limit

00:43:31,280 --> 00:43:35,359
then i need to think about it with my

00:43:34,400 --> 00:43:37,920
operator

00:43:35,359 --> 00:43:40,800
fpgas is another issue here if you load

00:43:37,920 --> 00:43:44,800
an fpga bit stream sometimes you go

00:43:40,800 --> 00:43:46,480
over a very slow interface

00:43:44,800 --> 00:43:47,839
and if you take a half a second or a

00:43:46,480 --> 00:43:48,960
second to load the bit stream from the

00:43:47,839 --> 00:43:50,720
bootloader

00:43:48,960 --> 00:43:54,000
that's a second that you cannot optimize

00:43:50,720 --> 00:43:56,000
away if your design is that way

00:43:54,000 --> 00:43:57,359
so think about these kind of things when

00:43:56,000 --> 00:43:59,440
designing your hardware

00:43:57,359 --> 00:44:02,400
you cannot do everything perfectly again

00:43:59,440 --> 00:44:02,400
right but

00:44:02,800 --> 00:44:09,520
you can avoid the biggest issues

00:44:06,839 --> 00:44:23,839
well that's it from my side

00:44:09,520 --> 00:44:23,839
so i'm up for questions now

00:44:26,800 --> 00:44:28,880

YouTube URL: https://www.youtube.com/watch?v=sJjd0vdqtos


