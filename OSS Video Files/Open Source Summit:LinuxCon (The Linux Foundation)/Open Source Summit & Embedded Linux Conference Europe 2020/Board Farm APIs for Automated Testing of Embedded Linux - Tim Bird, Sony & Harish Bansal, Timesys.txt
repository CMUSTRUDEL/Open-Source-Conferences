Title: Board Farm APIs for Automated Testing of Embedded Linux - Tim Bird, Sony & Harish Bansal, Timesys
Publication date: 2020-11-13
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Board Farm APIs for Automated Testing of Embedded Linux - Tim Bird, Sony & Harish Bansal, Timesys
Captions: 
	00:00:06,240 --> 00:00:09,519
hello everyone

00:00:07,440 --> 00:00:10,719
welcome to our session here at embedded

00:00:09,519 --> 00:00:12,719
linux conference

00:00:10,719 --> 00:00:14,320
my name is tim bird i'm a principal

00:00:12,719 --> 00:00:16,640
software engineer for

00:00:14,320 --> 00:00:17,600
sony electronics i'm here with harish

00:00:16,640 --> 00:00:19,760
bansal

00:00:17,600 --> 00:00:21,119
who's a technical engineer with time sys

00:00:19,760 --> 00:00:24,720
and we are here to talk

00:00:21,119 --> 00:00:26,720
to you about embedded board farm apis

00:00:24,720 --> 00:00:29,519
so we want to talk about something we

00:00:26,720 --> 00:00:31,519
think will be really beneficial for

00:00:29,519 --> 00:00:33,520
automated testing and the improvement of

00:00:31,519 --> 00:00:36,640
the testing ecosystem

00:00:33,520 --> 00:00:40,160
so um next slide

00:00:36,640 --> 00:00:41,920
harish so the i always

00:00:40,160 --> 00:00:43,200
like to put the abstract in but we're

00:00:41,920 --> 00:00:44,640
going to skip over that

00:00:43,200 --> 00:00:46,320
that's for people who look at the slides

00:00:44,640 --> 00:00:47,280
afterwards and maybe don't have access

00:00:46,320 --> 00:00:49,680
to the video

00:00:47,280 --> 00:00:51,360
our agenda today is i'm going to talk

00:00:49,680 --> 00:00:55,199
about kind of the problem statement

00:00:51,360 --> 00:00:56,559
why are we talking about board farm apis

00:00:55,199 --> 00:00:58,239
and then we'll give a little bit of an

00:00:56,559 --> 00:01:00,960
introduction to

00:00:58,239 --> 00:01:03,600
embedded board farm cloud which is a

00:01:00,960 --> 00:01:05,119
development solution by time sys

00:01:03,600 --> 00:01:07,600
and then we'll talk about some actual

00:01:05,119 --> 00:01:10,640
use cases for the rest api

00:01:07,600 --> 00:01:12,400
give some details about the api and then

00:01:10,640 --> 00:01:15,280
wrap it up by talking about issues

00:01:12,400 --> 00:01:17,920
encountered and what's next so getting

00:01:15,280 --> 00:01:19,920
started with the problem statement

00:01:17,920 --> 00:01:21,360
so there are lots of tests that are

00:01:19,920 --> 00:01:23,520
available um

00:01:21,360 --> 00:01:26,000
but the basic problem is that there's no

00:01:23,520 --> 00:01:29,119
standardized way of running tests

00:01:26,000 --> 00:01:30,479
uh specifically on physical devices so

00:01:29,119 --> 00:01:31,920
there are lots of different test

00:01:30,479 --> 00:01:35,200
frameworks

00:01:31,920 --> 00:01:38,000
and there are lots of

00:01:35,200 --> 00:01:38,400
there are board farm frameworks there

00:01:38,000 --> 00:01:40,079
are

00:01:38,400 --> 00:01:41,439
certainly tools available to manage

00:01:40,079 --> 00:01:43,600
board farms

00:01:41,439 --> 00:01:45,040
and uh to manage the hardware that's it

00:01:43,600 --> 00:01:46,960
that's in a farm but there's no

00:01:45,040 --> 00:01:50,880
standardized way to access

00:01:46,960 --> 00:01:51,680
uh those that that software that

00:01:50,880 --> 00:01:53,439
framework

00:01:51,680 --> 00:01:55,119
so that different test frameworks and

00:01:53,439 --> 00:01:58,079
different tests can run

00:01:55,119 --> 00:01:58,880
in a lab independent way the real big

00:01:58,079 --> 00:02:01,520
issue here

00:01:58,880 --> 00:02:02,880
is that every farm implements test

00:02:01,520 --> 00:02:05,920
infrastructure differently

00:02:02,880 --> 00:02:07,680
so for instance you know harish is going

00:02:05,920 --> 00:02:09,360
to present some information about the

00:02:07,680 --> 00:02:11,120
time sysboard farm

00:02:09,360 --> 00:02:13,120
and the hardware that they've got in

00:02:11,120 --> 00:02:15,680
their lab uh which is what we used to

00:02:13,120 --> 00:02:17,440
run our prototype on i've got a board

00:02:15,680 --> 00:02:20,080
farm sitting here right next to me

00:02:17,440 --> 00:02:21,840
uh it's off camera but it's if you've

00:02:20,080 --> 00:02:22,480
ever run a board farm you know that it's

00:02:21,840 --> 00:02:24,319
uh

00:02:22,480 --> 00:02:25,840
it's got a tangled mess of wires i've

00:02:24,319 --> 00:02:26,560
got all kinds of custom hardware in

00:02:25,840 --> 00:02:28,640
there

00:02:26,560 --> 00:02:30,400
uh i've got some off-the-shelf pieces

00:02:28,640 --> 00:02:32,480
for doing power control

00:02:30,400 --> 00:02:33,760
and i've got a i've got a custom board

00:02:32,480 --> 00:02:36,640
for doing power measurement

00:02:33,760 --> 00:02:38,400
and and so the tests that are written in

00:02:36,640 --> 00:02:40,319
my lab that control that hardware are

00:02:38,400 --> 00:02:44,480
not going to run in someone else's lab

00:02:40,319 --> 00:02:46,959
and vice versa so um qa departments

00:02:44,480 --> 00:02:48,879
for companies will write tests that will

00:02:46,959 --> 00:02:50,800
work in their lab with their particular

00:02:48,879 --> 00:02:52,720
infrastructure but it doesn't work in

00:02:50,800 --> 00:02:54,000
someone else's lab and so we can't share

00:02:52,720 --> 00:02:56,160
tests with each other

00:02:54,000 --> 00:02:57,440
and uh in since we're dealing with open

00:02:56,160 --> 00:02:58,159
source software it seems like a real

00:02:57,440 --> 00:03:00,400
shame

00:02:58,159 --> 00:03:02,159
that we can't can't reuse each other's

00:03:00,400 --> 00:03:04,239
work so our solution

00:03:02,159 --> 00:03:06,720
is we want to create a standard method

00:03:04,239 --> 00:03:09,599
for accessing board farm

00:03:06,720 --> 00:03:11,360
and we think that what that will allow

00:03:09,599 --> 00:03:13,120
is for three big benefits

00:03:11,360 --> 00:03:15,040
one of the first benefits is once you

00:03:13,120 --> 00:03:18,239
have that abstraction layer

00:03:15,040 --> 00:03:19,360
you'll be able to allow the test

00:03:18,239 --> 00:03:21,840
infrastructure

00:03:19,360 --> 00:03:22,720
the technologies to evolve separately

00:03:21,840 --> 00:03:25,599
from the interface

00:03:22,720 --> 00:03:26,959
so for instance i've got a certain type

00:03:25,599 --> 00:03:30,239
of power measurement

00:03:26,959 --> 00:03:31,519
board in my farm but if other labs have

00:03:30,239 --> 00:03:33,280
different power measurement boards they

00:03:31,519 --> 00:03:35,680
can evolve separately

00:03:33,280 --> 00:03:37,519
and introduce new features or or handle

00:03:35,680 --> 00:03:39,519
things in a different way

00:03:37,519 --> 00:03:41,840
so the tests are not tied to a

00:03:39,519 --> 00:03:45,120
particular implementation

00:03:41,840 --> 00:03:45,680
or expression in hardware the the big

00:03:45,120 --> 00:03:47,360
benefit

00:03:45,680 --> 00:03:48,720
is that tests can be written to work in

00:03:47,360 --> 00:03:50,640
more than one lab and that

00:03:48,720 --> 00:03:52,879
that allows us to create an ecosystem of

00:03:50,640 --> 00:03:53,760
tests rather than just have tests that

00:03:52,879 --> 00:03:55,840
are

00:03:53,760 --> 00:03:57,280
that are written by by one company or

00:03:55,840 --> 00:03:58,799
one individual

00:03:57,280 --> 00:04:00,400
the other thing that it allows is for

00:03:58,799 --> 00:04:02,879
test frameworks that can work

00:04:00,400 --> 00:04:04,159
uh also with more than one lab and we're

00:04:02,879 --> 00:04:05,040
actually going to demonstrate that

00:04:04,159 --> 00:04:06,959
working

00:04:05,040 --> 00:04:08,720
today so the types of tests we're

00:04:06,959 --> 00:04:09,360
talking about are not just pure software

00:04:08,720 --> 00:04:11,360
tests

00:04:09,360 --> 00:04:13,120
we're really talking about hardware

00:04:11,360 --> 00:04:14,319
software integration tests or end-to-end

00:04:13,120 --> 00:04:16,239
tests

00:04:14,319 --> 00:04:18,400
so if you look at for instance if you

00:04:16,239 --> 00:04:20,799
were to do gpio testing or serial

00:04:18,400 --> 00:04:21,919
serial port testing on a board you could

00:04:20,799 --> 00:04:24,639
accomplish that

00:04:21,919 --> 00:04:26,639
by uh putting the serial port in

00:04:24,639 --> 00:04:28,479
loopback mode and testing both endpoints

00:04:26,639 --> 00:04:32,160
on the same device but that's

00:04:28,479 --> 00:04:34,639
that's not really how uh the

00:04:32,160 --> 00:04:36,160
hardware is going to be tested uh or

00:04:34,639 --> 00:04:38,160
going to be used in the field if you

00:04:36,160 --> 00:04:39,600
have a product that has gpio

00:04:38,160 --> 00:04:41,280
you want to test it all the way through

00:04:39,600 --> 00:04:44,160
the hardware

00:04:41,280 --> 00:04:45,120
and out to an external device so that

00:04:44,160 --> 00:04:47,680
you can

00:04:45,120 --> 00:04:48,240
capture things like not just device

00:04:47,680 --> 00:04:50,560
driver

00:04:48,240 --> 00:04:52,080
errors but things like mechanical

00:04:50,560 --> 00:04:54,400
failures or

00:04:52,080 --> 00:04:55,280
electrical failures that are part of

00:04:54,400 --> 00:04:56,720
that product

00:04:55,280 --> 00:04:58,960
and that's very common to want to do

00:04:56,720 --> 00:05:00,880
that so for all of these

00:04:58,960 --> 00:05:02,320
types of hardware kind of integrated

00:05:00,880 --> 00:05:03,759
hardware software tests

00:05:02,320 --> 00:05:05,120
you actually end up having to control

00:05:03,759 --> 00:05:06,639
two endpoints you have to control an

00:05:05,120 --> 00:05:08,479
endpoint on the device

00:05:06,639 --> 00:05:10,400
and then you have to control an endpoint

00:05:08,479 --> 00:05:13,360
that is off the device

00:05:10,400 --> 00:05:14,160
and so i use the acronym uh dut here

00:05:13,360 --> 00:05:16,800
which is that

00:05:14,160 --> 00:05:17,520
i'll say a lot which is the device under

00:05:16,800 --> 00:05:19,680
test

00:05:17,520 --> 00:05:21,199
so if you look at another example of

00:05:19,680 --> 00:05:22,080
maybe a hardware software integration

00:05:21,199 --> 00:05:25,680
test

00:05:22,080 --> 00:05:27,840
you have audio playback which

00:05:25,680 --> 00:05:29,280
or video playback again you need to

00:05:27,840 --> 00:05:30,880
control two endpoints you have an

00:05:29,280 --> 00:05:33,680
endpoint on the board

00:05:30,880 --> 00:05:35,120
that is actually generating the audio or

00:05:33,680 --> 00:05:36,479
managing it in some way

00:05:35,120 --> 00:05:38,240
and then you have an endpoint off the

00:05:36,479 --> 00:05:39,840
board which is a capture device

00:05:38,240 --> 00:05:41,759
to make sure that you're you're not

00:05:39,840 --> 00:05:45,280
getting any drop outs or

00:05:41,759 --> 00:05:46,639
uh or time delays or uh that the quality

00:05:45,280 --> 00:05:48,880
is what you're expecting

00:05:46,639 --> 00:05:50,320
um and so again you're controlling two

00:05:48,880 --> 00:05:51,520
end points the same with power

00:05:50,320 --> 00:05:52,160
measurement if you're doing power

00:05:51,520 --> 00:05:54,320
measurement

00:05:52,160 --> 00:05:56,080
off the board you're going to control

00:05:54,320 --> 00:05:56,960
two end points one is on the board where

00:05:56,080 --> 00:06:00,880
you're

00:05:56,960 --> 00:06:02,560
actually managing the workload profile

00:06:00,880 --> 00:06:04,000
that you're trying to test or the

00:06:02,560 --> 00:06:06,240
application and then

00:06:04,000 --> 00:06:07,199
off the device you're talking to some

00:06:06,240 --> 00:06:10,160
kind of board

00:06:07,199 --> 00:06:11,039
or measurement device that actually is

00:06:10,160 --> 00:06:13,360
taking power

00:06:11,039 --> 00:06:14,720
readings and you want to analyze those

00:06:13,360 --> 00:06:16,639
after the test to see what happened in

00:06:14,720 --> 00:06:18,639
terms of maxes or total power used or

00:06:16,639 --> 00:06:19,840
something

00:06:18,639 --> 00:06:22,560
and then another test that you can

00:06:19,840 --> 00:06:23,039
imagine is uh oh we do it sony is the

00:06:22,560 --> 00:06:24,960
usb

00:06:23,039 --> 00:06:26,479
connect and disconnect testing to make

00:06:24,960 --> 00:06:29,440
sure that we have a robust

00:06:26,479 --> 00:06:30,800
uh error handling uh and that's both

00:06:29,440 --> 00:06:33,520
kind of at the electrical level

00:06:30,800 --> 00:06:35,120
and for the stack the driver level again

00:06:33,520 --> 00:06:35,759
you need to control two end points one

00:06:35,120 --> 00:06:39,120
on the board

00:06:35,759 --> 00:06:40,479
and one off the board and so you will

00:06:39,120 --> 00:06:43,600
usually have hardware that

00:06:40,479 --> 00:06:46,960
disconnects and reconnects the bus but

00:06:43,600 --> 00:06:48,000
those are not the only hardware hardware

00:06:46,960 --> 00:06:51,280
software is not the only

00:06:48,000 --> 00:06:52,960
type of testing that can benefit from

00:06:51,280 --> 00:06:54,560
what i call the multi-device

00:06:52,960 --> 00:06:57,680
orchestration so if you look at

00:06:54,560 --> 00:06:59,680
something uh like netperf

00:06:57,680 --> 00:07:02,000
where you need to manage two endpoints

00:06:59,680 --> 00:07:05,440
so you have a client

00:07:02,000 --> 00:07:06,880
on the board itself that is going to be

00:07:05,440 --> 00:07:08,560
generating network traffic

00:07:06,880 --> 00:07:10,000
and you have a server that's going to be

00:07:08,560 --> 00:07:12,240
receiving traffic or measuring the

00:07:10,000 --> 00:07:15,199
performance of the traffic

00:07:12,240 --> 00:07:17,440
you you may want to well at a minimum

00:07:15,199 --> 00:07:19,039
you need to discover the server address

00:07:17,440 --> 00:07:21,520
and that's going to be specific to the

00:07:19,039 --> 00:07:24,240
lab so you need to

00:07:21,520 --> 00:07:26,479
the test itself needs to know what the

00:07:24,240 --> 00:07:30,000
address of the net server is

00:07:26,479 --> 00:07:31,599
but you also there also may be

00:07:30,000 --> 00:07:33,919
configurations where you want to make

00:07:31,599 --> 00:07:38,400
that net server

00:07:33,919 --> 00:07:42,160
specific uh to a particular set of nodes

00:07:38,400 --> 00:07:45,039
so that you can reduce the amount of

00:07:42,160 --> 00:07:46,240
traffic collisions and make the test

00:07:45,039 --> 00:07:48,639
results more consistent

00:07:46,240 --> 00:07:49,520
so you may need the lab management

00:07:48,639 --> 00:07:52,160
software

00:07:49,520 --> 00:07:53,599
to actually reserve the netperf server

00:07:52,160 --> 00:07:55,759
for a period of time

00:07:53,599 --> 00:07:58,080
um and release it instead of just having

00:07:55,759 --> 00:08:00,160
it generally available

00:07:58,080 --> 00:08:01,280
that introduces inconsistencies in the

00:08:00,160 --> 00:08:02,639
test data

00:08:01,280 --> 00:08:04,800
another type of multi-device

00:08:02,639 --> 00:08:06,240
orchestration that is common

00:08:04,800 --> 00:08:07,840
that we don't actually think of as

00:08:06,240 --> 00:08:09,280
multi-device orchestration because i've

00:08:07,840 --> 00:08:11,759
been doing it so long

00:08:09,280 --> 00:08:13,759
is a boot test in this case you may need

00:08:11,759 --> 00:08:15,599
to manage several different devices

00:08:13,759 --> 00:08:17,599
um well you always have to manage

00:08:15,599 --> 00:08:20,080
several devices the classic

00:08:17,599 --> 00:08:21,520
boot test is uh you know you need to

00:08:20,080 --> 00:08:23,199
install a kernel of the root fs

00:08:21,520 --> 00:08:23,759
somewhere and that that requires access

00:08:23,199 --> 00:08:26,800
to a

00:08:23,759 --> 00:08:28,240
storage controller in the case of sd

00:08:26,800 --> 00:08:30,240
card based boards you may

00:08:28,240 --> 00:08:31,599
want an sd muxer that you're

00:08:30,240 --> 00:08:33,200
communicating with to actually

00:08:31,599 --> 00:08:35,519
accomplish that

00:08:33,200 --> 00:08:37,279
uh and then you have a serial controller

00:08:35,519 --> 00:08:38,240
that's actually capturing the serial

00:08:37,279 --> 00:08:40,080
line

00:08:38,240 --> 00:08:41,440
where you're getting the console output

00:08:40,080 --> 00:08:43,200
and then you have a power controller to

00:08:41,440 --> 00:08:45,920
control the power to the board so

00:08:43,200 --> 00:08:47,200
uh historically we haven't thought of

00:08:45,920 --> 00:08:50,160
tests in that

00:08:47,200 --> 00:08:51,360
way um as you know controlling multiple

00:08:50,160 --> 00:08:52,560
endpoints but that's really what's going

00:08:51,360 --> 00:08:54,640
on under the hood

00:08:52,560 --> 00:08:57,200
so our concept today that we want to

00:08:54,640 --> 00:09:00,399
introduce you is um

00:08:57,200 --> 00:09:02,480
uh this rest api and the rest api will

00:09:00,399 --> 00:09:04,800
will create an abstraction layer that

00:09:02,480 --> 00:09:07,839
any taste test framework can talk to

00:09:04,800 --> 00:09:10,959
and a test can talk to you to

00:09:07,839 --> 00:09:11,519
communicate with hardware and resources

00:09:10,959 --> 00:09:14,480
or

00:09:11,519 --> 00:09:15,519
or features that are inside a lab for a

00:09:14,480 --> 00:09:17,519
particular test

00:09:15,519 --> 00:09:19,839
and do it in a way that it doesn't

00:09:17,519 --> 00:09:21,600
matter which farm you're talking to

00:09:19,839 --> 00:09:23,200
the same operations can be performed the

00:09:21,600 --> 00:09:26,160
same data can be gathered

00:09:23,200 --> 00:09:28,480
and so the test can be farm neutral

00:09:26,160 --> 00:09:31,519
drilling down a little bit deeper

00:09:28,480 --> 00:09:36,399
into the the diagram here

00:09:31,519 --> 00:09:38,880
um next slide yeah so we have uh

00:09:36,399 --> 00:09:40,080
if you look at what the api is actually

00:09:38,880 --> 00:09:42,320
controlling

00:09:40,080 --> 00:09:44,000
uh you have some operations or some

00:09:42,320 --> 00:09:45,760
actions that are controlling the board

00:09:44,000 --> 00:09:48,320
in the lab

00:09:45,760 --> 00:09:48,880
and but you also have operations that

00:09:48,320 --> 00:09:50,560
control

00:09:48,880 --> 00:09:52,399
those other endpoints that i was talking

00:09:50,560 --> 00:09:53,200
about so you might have a power

00:09:52,399 --> 00:09:55,360
controller

00:09:53,200 --> 00:09:58,800
uh you might have a audio video capture

00:09:55,360 --> 00:10:00,240
device or a gpio endpoint

00:09:58,800 --> 00:10:02,079
and those are all things that the rest

00:10:00,240 --> 00:10:04,480
api can manage for you

00:10:02,079 --> 00:10:05,200
in a lab independent fashion and so the

00:10:04,480 --> 00:10:06,720
frameworks

00:10:05,200 --> 00:10:08,399
can access them in a lab independent

00:10:06,720 --> 00:10:09,760
fashion but also the test itself that is

00:10:08,399 --> 00:10:12,720
actually running on the board

00:10:09,760 --> 00:10:13,760
can also communicate communicate with or

00:10:12,720 --> 00:10:16,160
control

00:10:13,760 --> 00:10:18,480
uh those other resources so that's the

00:10:16,160 --> 00:10:21,360
overall concept

00:10:18,480 --> 00:10:23,040
and our rest api really consists of kind

00:10:21,360 --> 00:10:25,120
of three parts

00:10:23,040 --> 00:10:26,800
that i think are important first you

00:10:25,120 --> 00:10:28,480
know you have the rest api itself

00:10:26,800 --> 00:10:30,560
a command line interface and environment

00:10:28,480 --> 00:10:33,680
variables so the rest api

00:10:30,560 --> 00:10:36,800
is actually a very kind of traditional

00:10:33,680 --> 00:10:40,240
web api it's based on attps

00:10:36,800 --> 00:10:41,120
with uris that include actions and

00:10:40,240 --> 00:10:43,600
objects

00:10:41,120 --> 00:10:45,279
and json is passed back and forth

00:10:43,600 --> 00:10:47,040
between the client and server

00:10:45,279 --> 00:10:49,040
we actually did this as an extension to

00:10:47,040 --> 00:10:50,640
the lava rest api so it should be pretty

00:10:49,040 --> 00:10:52,640
familiar

00:10:50,640 --> 00:10:54,160
and if you and a lot of frameworks

00:10:52,640 --> 00:10:57,040
already have plumbing

00:10:54,160 --> 00:10:59,040
to deal with that lava rest api already

00:10:57,040 --> 00:11:01,600
it's a very simple api

00:10:59,040 --> 00:11:03,519
in terms of the amount of dependencies

00:11:01,600 --> 00:11:04,560
it has on external programs so you can

00:11:03,519 --> 00:11:06,000
actually

00:11:04,560 --> 00:11:08,240
accomplish everything you need to with

00:11:06,000 --> 00:11:12,320
this api using just curl

00:11:08,240 --> 00:11:13,519
and jq jq is a linux command line tool

00:11:12,320 --> 00:11:16,560
for

00:11:13,519 --> 00:11:18,959
extracting data individual elements from

00:11:16,560 --> 00:11:20,800
json data

00:11:18,959 --> 00:11:22,079
so that's the actual api that's the kind

00:11:20,800 --> 00:11:23,839
of the most important thing

00:11:22,079 --> 00:11:25,200
but we also provide a command line tool

00:11:23,839 --> 00:11:26,839
so that you have

00:11:25,200 --> 00:11:28,720
it has the same operations as the rest

00:11:26,839 --> 00:11:30,959
api and uh

00:11:28,720 --> 00:11:32,560
it is suitable for automated use you can

00:11:30,959 --> 00:11:34,240
if you test framework

00:11:32,560 --> 00:11:35,920
does things more with the command line

00:11:34,240 --> 00:11:37,040
and shell scripting

00:11:35,920 --> 00:11:38,640
it's a little bit easier to use with

00:11:37,040 --> 00:11:39,839
that but it's also much easier for

00:11:38,640 --> 00:11:42,880
humans to use

00:11:39,839 --> 00:11:44,000
instead of crafting these long urls that

00:11:42,880 --> 00:11:46,720
have

00:11:44,000 --> 00:11:48,160
a very specific syntax you can you can

00:11:46,720 --> 00:11:50,800
use a command line

00:11:48,160 --> 00:11:52,160
tool it's a little bit more comfortable

00:11:50,800 --> 00:11:55,600
and then the final aspect

00:11:52,160 --> 00:11:57,360
of the api is that there are some things

00:11:55,600 --> 00:11:58,240
that need to be communicated to the test

00:11:57,360 --> 00:12:01,600
program

00:11:58,240 --> 00:12:04,959
uh before it even has access to the

00:12:01,600 --> 00:12:07,440
uh api itself so for one example the the

00:12:04,959 --> 00:12:09,360
address of the server where the that is

00:12:07,440 --> 00:12:11,760
managing the lab so

00:12:09,360 --> 00:12:12,800
some of those environment variables are

00:12:11,760 --> 00:12:14,000
some of those

00:12:12,800 --> 00:12:16,480
some of that data is passed as

00:12:14,000 --> 00:12:17,760
environment variables or it can be put

00:12:16,480 --> 00:12:19,920
in a file called

00:12:17,760 --> 00:12:21,040
etsy test config so those are the

00:12:19,920 --> 00:12:22,959
elements of the api

00:12:21,040 --> 00:12:24,800
and now i'll turn the time over to

00:12:22,959 --> 00:12:26,480
harish to talk a little bit about the

00:12:24,800 --> 00:12:28,959
hardware that we used for the prototype

00:12:26,480 --> 00:12:31,360
implementation

00:12:28,959 --> 00:12:33,839
uh thank you tim hello everyone uh my

00:12:31,360 --> 00:12:36,240
name is harish pencil and i work for

00:12:33,839 --> 00:12:38,560
embedded dot form team at timeses so let

00:12:36,240 --> 00:12:41,519
me give you a brief introduction to

00:12:38,560 --> 00:12:43,519
of time system edit port from cloud this

00:12:41,519 --> 00:12:45,760
is the high level diagram of uh

00:12:43,519 --> 00:12:47,600
embedded board form cloud using this

00:12:45,760 --> 00:12:49,360
solution engineers who are sitting

00:12:47,600 --> 00:12:51,600
anywhere across the world

00:12:49,360 --> 00:12:53,839
but they are connected to this cloud

00:12:51,600 --> 00:12:55,600
they could access any remote port or

00:12:53,839 --> 00:12:57,440
embedded device and use it for their

00:12:55,600 --> 00:13:00,000
development and testing

00:12:57,440 --> 00:13:00,720
these ports at their physical locations

00:13:00,000 --> 00:13:02,320
in lab

00:13:00,720 --> 00:13:04,959
they are connected to a specialized

00:13:02,320 --> 00:13:07,200
hardware called zombies

00:13:04,959 --> 00:13:08,800
uh these zombies with board these could

00:13:07,200 --> 00:13:10,800
be distributed across different

00:13:08,800 --> 00:13:11,760
geographical locations different

00:13:10,800 --> 00:13:13,680
countries

00:13:11,760 --> 00:13:14,800
different buildings or different flows

00:13:13,680 --> 00:13:17,519
of diff

00:13:14,800 --> 00:13:19,600
of a same building and all these zombies

00:13:17,519 --> 00:13:21,680
with boats they communicate with us

00:13:19,600 --> 00:13:23,200
uh centralized server which we call

00:13:21,680 --> 00:13:26,000
embedded port form master

00:13:23,200 --> 00:13:29,440
ebf monster and engineers connect to

00:13:26,000 --> 00:13:32,839
this epf master to access the remote uh

00:13:29,440 --> 00:13:35,200
port and embedded volt form cloud

00:13:32,839 --> 00:13:37,519
features

00:13:35,200 --> 00:13:39,360
this embedded port from cloud master

00:13:37,519 --> 00:13:41,360
it's a linux machine which controls all

00:13:39,360 --> 00:13:44,160
the zombies which are on the cloud

00:13:41,360 --> 00:13:46,320
and the devices connected to it uh it

00:13:44,160 --> 00:13:48,639
runs the web application inside a docker

00:13:46,320 --> 00:13:51,600
container which provides centralized

00:13:48,639 --> 00:13:52,560
port management user management zombie

00:13:51,600 --> 00:13:55,279
management

00:13:52,560 --> 00:13:57,040
image and file transfer management it

00:13:55,279 --> 00:13:59,360
has also integrated

00:13:57,040 --> 00:14:00,959
lava test framework so on any of the

00:13:59,360 --> 00:14:01,440
device which is connected to any of the

00:14:00,959 --> 00:14:03,680
zombie

00:14:01,440 --> 00:14:05,839
you could use it for running automated

00:14:03,680 --> 00:14:09,199
test

00:14:05,839 --> 00:14:12,560
on the right is the picture of actual

00:14:09,199 --> 00:14:16,000
uh zombie hardware uh

00:14:12,560 --> 00:14:19,199
it's divided into two parts uh one uh

00:14:16,000 --> 00:14:20,959
on the left is a zombie section uh for

00:14:19,199 --> 00:14:23,680
embedded board form feature and on the

00:14:20,959 --> 00:14:27,040
right is a app or a test server uh

00:14:23,680 --> 00:14:30,320
uh uh part which is used for testing

00:14:27,040 --> 00:14:34,320
and uh streaming

00:14:30,320 --> 00:14:37,360
the box on on the left the uh the

00:14:34,320 --> 00:14:40,399
part under uh red box uh this is a

00:14:37,360 --> 00:14:42,000
zombie part uh here uh devices serial

00:14:40,399 --> 00:14:45,199
ports are connected at the top

00:14:42,000 --> 00:14:48,720
and it has ethernet ports for uh

00:14:45,199 --> 00:14:51,680
bringing the devices onto the network

00:14:48,720 --> 00:14:52,160
uh on the right uh one under blue box is

00:14:51,680 --> 00:14:55,440
the app

00:14:52,160 --> 00:14:56,079
or test server uh section it it runs

00:14:55,440 --> 00:14:59,040
linux

00:14:56,079 --> 00:14:59,760
and this code act as a additional lab

00:14:59,040 --> 00:15:03,040
machine for

00:14:59,760 --> 00:15:03,839
running uh tests like iperf or netperf

00:15:03,040 --> 00:15:06,959
which require

00:15:03,839 --> 00:15:08,000
additional uh end point in the lab

00:15:06,959 --> 00:15:09,760
infrastructure

00:15:08,000 --> 00:15:12,399
uh there are ports where you could

00:15:09,760 --> 00:15:14,800
connect peripherals like

00:15:12,399 --> 00:15:16,000
jtag for debugging your hardware or

00:15:14,800 --> 00:15:19,600
connect a webcam

00:15:16,000 --> 00:15:22,720
to see live images of of your

00:15:19,600 --> 00:15:25,199
board embedded board or duty on the

00:15:22,720 --> 00:15:27,279
bottom left is another lap controller

00:15:25,199 --> 00:15:28,720
this is called input output controller

00:15:27,279 --> 00:15:31,120
iocx

00:15:28,720 --> 00:15:33,600
uh it's an optional uh hardware which

00:15:31,120 --> 00:15:36,240
sits between a zombie and device

00:15:33,600 --> 00:15:38,399
uh so each zombie could connect up to

00:15:36,240 --> 00:15:40,160
four devices and with each device one

00:15:38,399 --> 00:15:44,560
iocx is connected

00:15:40,160 --> 00:15:46,560
uh on top of iocx there is a mounted uh

00:15:44,560 --> 00:15:47,839
power relay switch through this you

00:15:46,560 --> 00:15:51,040
could control uh

00:15:47,839 --> 00:15:52,079
one foot control ports power uh then it

00:15:51,040 --> 00:15:54,480
has usb

00:15:52,079 --> 00:15:56,079
and ethernet hot plugs uh these hot

00:15:54,480 --> 00:15:59,279
plugs are like switches

00:15:56,079 --> 00:16:00,959
so many a time one needs to uh

00:15:59,279 --> 00:16:03,360
on demand connect or disconnect

00:16:00,959 --> 00:16:04,160
peripherals from from the duties or

00:16:03,360 --> 00:16:06,720
boards

00:16:04,160 --> 00:16:08,639
so uh those actual uh peripherals are

00:16:06,720 --> 00:16:09,920
connected on these hot plugs and then

00:16:08,639 --> 00:16:12,160
using a

00:16:09,920 --> 00:16:13,279
web ui of embedded board form or rest

00:16:12,160 --> 00:16:15,360
api you could on

00:16:13,279 --> 00:16:18,079
one put on demand connect those to the

00:16:15,360 --> 00:16:21,120
device site or remove it

00:16:18,079 --> 00:16:24,000
for ports which boots out of

00:16:21,120 --> 00:16:25,120
sd card or use sd card as one of the

00:16:24,000 --> 00:16:28,399
boot media there is

00:16:25,120 --> 00:16:30,560
st max built in so this uh notch with

00:16:28,399 --> 00:16:33,120
the ribbon cable it goes into

00:16:30,560 --> 00:16:34,000
the sd card slot of the embedded device

00:16:33,120 --> 00:16:36,560
or board

00:16:34,000 --> 00:16:37,680
and the actual sd card is connected at

00:16:36,560 --> 00:16:40,320
the back

00:16:37,680 --> 00:16:41,680
of this ioc x1 which is highlighted with

00:16:40,320 --> 00:16:44,079
the red box

00:16:41,680 --> 00:16:45,920
and then uh remotely you could switch

00:16:44,079 --> 00:16:49,040
the sd card to the device side

00:16:45,920 --> 00:16:50,720
or switch it to the zombie side so once

00:16:49,040 --> 00:16:53,360
it switched to the zombie side you could

00:16:50,720 --> 00:16:54,079
manage the sd card content format the sd

00:16:53,360 --> 00:16:56,320
card

00:16:54,079 --> 00:16:58,560
create different partition upload or

00:16:56,320 --> 00:17:02,079
download files from the sd card or

00:16:58,560 --> 00:17:05,520
flash a new uh device image

00:17:02,079 --> 00:17:07,520
to the sd card uh then it has a i square

00:17:05,520 --> 00:17:11,039
c and gpio connector which i'm going to

00:17:07,520 --> 00:17:13,839
talk about in later slides

00:17:11,039 --> 00:17:15,600
this is a device dashboard of the web

00:17:13,839 --> 00:17:18,319
user interface uh

00:17:15,600 --> 00:17:20,400
here you could see all the devices uh or

00:17:18,319 --> 00:17:23,039
boards which are connected across the

00:17:20,400 --> 00:17:24,240
uh embedded code form uh which board is

00:17:23,039 --> 00:17:27,520
connected to which

00:17:24,240 --> 00:17:29,600
uh zombie what's the uh

00:17:27,520 --> 00:17:32,080
board or device status who is currently

00:17:29,600 --> 00:17:33,919
using it and if any

00:17:32,080 --> 00:17:36,880
device is free you could assign the

00:17:33,919 --> 00:17:39,919
device to yourself and start using it

00:17:36,880 --> 00:17:41,440
once you uh assign this device to your

00:17:39,919 --> 00:17:42,480
cell you get access to the device

00:17:41,440 --> 00:17:45,679
console

00:17:42,480 --> 00:17:47,919
uh you get access to device serial

00:17:45,679 --> 00:17:50,320
console if the device supports

00:17:47,919 --> 00:17:51,600
is running a ssl server you could access

00:17:50,320 --> 00:17:54,080
ssh console and

00:17:51,600 --> 00:17:56,559
if it's a android device you could even

00:17:54,080 --> 00:17:59,360
access its adb console

00:17:56,559 --> 00:18:00,880
uh if device is in hand state or it's

00:17:59,360 --> 00:18:03,600
powered off

00:18:00,880 --> 00:18:05,039
then we could uh one could use this

00:18:03,600 --> 00:18:08,240
power commands

00:18:05,039 --> 00:18:10,320
power control off or on reboot uh the

00:18:08,240 --> 00:18:13,919
commands which you see it depends on

00:18:10,320 --> 00:18:14,960
which power remote control power switch

00:18:13,919 --> 00:18:17,760
are you using

00:18:14,960 --> 00:18:19,520
uh the one at the top it's not necessary

00:18:17,760 --> 00:18:22,960
uh that you could you should use

00:18:19,520 --> 00:18:24,799
the one which is at the top of iocx uh

00:18:22,960 --> 00:18:26,320
with uh time support form you could

00:18:24,799 --> 00:18:28,559
connect any

00:18:26,320 --> 00:18:29,600
remote control power switch whether it's

00:18:28,559 --> 00:18:33,039
ip control

00:18:29,600 --> 00:18:35,120
snmp control or relay control and uh the

00:18:33,039 --> 00:18:37,120
commands which that power switch

00:18:35,120 --> 00:18:38,320
supports those show up here so the

00:18:37,120 --> 00:18:41,440
commands could be like

00:18:38,320 --> 00:18:43,760
off with delay uh on with delay a plus b

00:18:41,440 --> 00:18:45,679
plus whatever that power supply uh power

00:18:43,760 --> 00:18:48,720
remote power switch supports

00:18:45,679 --> 00:18:50,080
uh you could turn on streaming you could

00:18:48,720 --> 00:18:52,880
see video streaming or

00:18:50,080 --> 00:18:53,679
audio and audio streaming uh one could

00:18:52,880 --> 00:18:56,240
do

00:18:53,679 --> 00:18:58,640
sd card or network boot image management

00:18:56,240 --> 00:18:58,640
from it

00:18:59,280 --> 00:19:04,960
on uh the device uh page

00:19:02,400 --> 00:19:06,400
at the top there is a menu or we call it

00:19:04,960 --> 00:19:09,679
iocx menu

00:19:06,400 --> 00:19:11,679
uh so here html device screen shows

00:19:09,679 --> 00:19:12,880
the sd card which is actually physically

00:19:11,679 --> 00:19:16,080
connected at the back

00:19:12,880 --> 00:19:19,840
back of iocx it's on the device side

00:19:16,080 --> 00:19:22,320
uh sd card uh if it's red that means

00:19:19,840 --> 00:19:24,720
the sd card is connected on the zombie

00:19:22,320 --> 00:19:27,760
side and it's ready for uh

00:19:24,720 --> 00:19:31,679
for you to manage the sd card content

00:19:27,760 --> 00:19:33,120
uh on the right of this sdmux are hot

00:19:31,679 --> 00:19:36,240
plug

00:19:33,120 --> 00:19:40,160
buttons red means off means disconnected

00:19:36,240 --> 00:19:42,720
greens means they are connected back

00:19:40,160 --> 00:19:43,679
so tim is going to discuss in detail

00:19:42,720 --> 00:19:47,280
gpio

00:19:43,679 --> 00:19:50,559
uh test so let me uh describe

00:19:47,280 --> 00:19:51,120
uh gpio setup in times the in the board

00:19:50,559 --> 00:19:55,039
form

00:19:51,120 --> 00:19:58,559
so at the left bottom is iocx uh

00:19:55,039 --> 00:19:59,520
this uh iocx has eight gpo gpio lines

00:19:58,559 --> 00:20:02,720
which could be

00:19:59,520 --> 00:20:06,080
connected to uh the duty or device

00:20:02,720 --> 00:20:08,960
and so out of these eight

00:20:06,080 --> 00:20:11,120
the six pairs of line ground comes out

00:20:08,960 --> 00:20:14,240
of this gpio connector

00:20:11,120 --> 00:20:14,880
and two lines comes out of this i square

00:20:14,240 --> 00:20:17,280
c

00:20:14,880 --> 00:20:18,400
connector and all these gpio lines could

00:20:17,280 --> 00:20:22,720
be controlled

00:20:18,400 --> 00:20:25,520
using uh rest apis

00:20:22,720 --> 00:20:26,720
so let me go ahead and now describe a

00:20:25,520 --> 00:20:30,080
prototype use case

00:20:26,720 --> 00:20:31,200
uh keeping in mind the gpio hardware

00:20:30,080 --> 00:20:34,960
capabilities in the

00:20:31,200 --> 00:20:35,840
embedded board farm cloud we designed a

00:20:34,960 --> 00:20:39,440
test

00:20:35,840 --> 00:20:42,080
to test gpio on the board

00:20:39,440 --> 00:20:42,880
and we're using the rest api and what

00:20:42,080 --> 00:20:45,280
we're going to show

00:20:42,880 --> 00:20:46,799
in our prototype use case is a couple of

00:20:45,280 --> 00:20:49,840
different things

00:20:46,799 --> 00:20:53,360
we're using from both the

00:20:49,840 --> 00:20:54,159
time sys web ui you can access features

00:20:53,360 --> 00:20:56,080
on the board

00:20:54,159 --> 00:20:58,559
and perform the test and you can

00:20:56,080 --> 00:21:01,760
actually run it as a lava job

00:20:58,559 --> 00:21:04,960
and you can use fuego to

00:21:01,760 --> 00:21:07,440
also initiate that same job

00:21:04,960 --> 00:21:09,039
and perform the test one of the things

00:21:07,440 --> 00:21:11,600
that we didn't quite finish

00:21:09,039 --> 00:21:13,440
but that is pretty close is also running

00:21:11,600 --> 00:21:14,480
that test in the sony embedded board

00:21:13,440 --> 00:21:15,840
farm

00:21:14,480 --> 00:21:18,400
we're pretty confident that it would

00:21:15,840 --> 00:21:19,840
work but uh time says did a better job

00:21:18,400 --> 00:21:20,880
of finishing up their implementation

00:21:19,840 --> 00:21:24,159
than i did

00:21:20,880 --> 00:21:28,640
uh so but um looking at how

00:21:24,159 --> 00:21:31,120
uh the test is actually gonna run uh

00:21:28,640 --> 00:21:32,080
so uh we're gonna show you a couple of

00:21:31,120 --> 00:21:35,280
different things

00:21:32,080 --> 00:21:35,919
uh in a video coming up uh so you can

00:21:35,280 --> 00:21:38,720
run the

00:21:35,919 --> 00:21:40,400
run these tests or use the api uh in

00:21:38,720 --> 00:21:42,240
several different ways so you can do

00:21:40,400 --> 00:21:43,360
manual execution so if you want to get

00:21:42,240 --> 00:21:45,360
onto the board

00:21:43,360 --> 00:21:47,440
and actually issue the gpio commands

00:21:45,360 --> 00:21:49,280
yourself or

00:21:47,440 --> 00:21:50,880
access the lab resource yourself you can

00:21:49,280 --> 00:21:53,600
do that manually

00:21:50,880 --> 00:21:54,720
through the command line tool or through

00:21:53,600 --> 00:21:56,960
the console

00:21:54,720 --> 00:21:58,559
that's available you can run a test

00:21:56,960 --> 00:22:00,000
script which

00:21:58,559 --> 00:22:02,320
basically does those same types of

00:22:00,000 --> 00:22:04,480
commands except using

00:22:02,320 --> 00:22:06,799
the rest api directly from the script

00:22:04,480 --> 00:22:08,559
and that's uh you'll see

00:22:06,799 --> 00:22:10,320
and you can run that test manually or

00:22:08,559 --> 00:22:11,760
the next the next phase is to put it

00:22:10,320 --> 00:22:14,960
under test automation

00:22:11,760 --> 00:22:18,240
so uh we will show you um

00:22:14,960 --> 00:22:19,360
a test running from a lava job and then

00:22:18,240 --> 00:22:22,559
from

00:22:19,360 --> 00:22:24,640
fuego and and that

00:22:22,559 --> 00:22:26,000
that puts the test encapsulated in kind

00:22:24,640 --> 00:22:29,120
of the larger test framework

00:22:26,000 --> 00:22:32,400
that does things like uh

00:22:29,120 --> 00:22:33,760
schedules the job and presents the

00:22:32,400 --> 00:22:36,720
results at the end

00:22:33,760 --> 00:22:38,320
so um with that let's uh let's go ahead

00:22:36,720 --> 00:22:41,520
and look at

00:22:38,320 --> 00:22:44,240
what we did so uh

00:22:41,520 --> 00:22:46,080
so uh here uh in this video we are

00:22:44,240 --> 00:22:49,039
showing three different ways of

00:22:46,080 --> 00:22:50,480
running our gpio test script uh this is

00:22:49,039 --> 00:22:53,679
first example of

00:22:50,480 --> 00:22:54,880
running the test script using uh web

00:22:53,679 --> 00:22:57,120
console

00:22:54,880 --> 00:22:58,159
so we logged in into port form cloud's

00:22:57,120 --> 00:22:59,760
web interface

00:22:58,159 --> 00:23:01,679
on the device dashboard we are searching

00:22:59,760 --> 00:23:05,520
for our device

00:23:01,679 --> 00:23:08,720
uh we are located the device now we are

00:23:05,520 --> 00:23:09,760
going to the console page so device

00:23:08,720 --> 00:23:13,200
console page

00:23:09,760 --> 00:23:14,400
here we are straight into the directory

00:23:13,200 --> 00:23:16,799
which had the test

00:23:14,400 --> 00:23:17,919
executed the test and we could see test

00:23:16,799 --> 00:23:21,200
ran

00:23:17,919 --> 00:23:23,520
and it printed out the test result

00:23:21,200 --> 00:23:25,679
this is a second example of running the

00:23:23,520 --> 00:23:28,240
same test through a command line tool

00:23:25,679 --> 00:23:29,520
so ebf is the name of the tool my

00:23:28,240 --> 00:23:31,520
devices command list

00:23:29,520 --> 00:23:33,760
give list of all the devices which are

00:23:31,520 --> 00:23:36,480
currently assigned to this user

00:23:33,760 --> 00:23:37,280
uh this this next command we are going

00:23:36,480 --> 00:23:40,400
to

00:23:37,280 --> 00:23:43,840
run execute some command on on the board

00:23:40,400 --> 00:23:45,039
so this epf tool uh uh you could install

00:23:43,840 --> 00:23:47,520
it on your machine

00:23:45,039 --> 00:23:48,559
and uh once installed you could access

00:23:47,520 --> 00:23:51,760
any remote port

00:23:48,559 --> 00:23:55,200
so this video was prepared by uh my

00:23:51,760 --> 00:23:58,559
uh fellow engineer ankit gupta so he

00:23:55,200 --> 00:24:00,799
installed this ebf tool on his system

00:23:58,559 --> 00:24:01,679
so from his system uh which is

00:24:00,799 --> 00:24:04,159
physically in

00:24:01,679 --> 00:24:05,120
delhi he's running command on this

00:24:04,159 --> 00:24:07,520
raspberry pi

00:24:05,120 --> 00:24:08,240
board which is connected to a zombie in

00:24:07,520 --> 00:24:11,679
pittsburgh

00:24:08,240 --> 00:24:14,159
in uh us in our us office

00:24:11,679 --> 00:24:15,440
so if we need first run ls minus al

00:24:14,159 --> 00:24:18,559
command to see

00:24:15,440 --> 00:24:22,320
whether the test script exists now

00:24:18,559 --> 00:24:26,960
uh he is running the actual test

00:24:22,320 --> 00:24:32,159
script using ssh run command

00:24:26,960 --> 00:24:35,120
on this respi-4 gpio board

00:24:32,159 --> 00:24:35,520
executing on the server on on the board

00:24:35,120 --> 00:24:38,720
and

00:24:35,520 --> 00:24:40,320
it fetched uh the test script output and

00:24:38,720 --> 00:24:43,600
we could see directly on our

00:24:40,320 --> 00:24:44,559
on on the local machine this is the

00:24:43,600 --> 00:24:47,919
third example

00:24:44,559 --> 00:24:49,679
this should be interesting so so far we

00:24:47,919 --> 00:24:52,320
showed you manual way so now we are

00:24:49,679 --> 00:24:55,679
going to run the same gpio test uh

00:24:52,320 --> 00:24:56,159
through uh test framework lava for this

00:24:55,679 --> 00:24:59,200
we

00:24:56,159 --> 00:25:02,400
curated a lava test job

00:24:59,200 --> 00:25:05,840
uh curated uh we are going to

00:25:02,400 --> 00:25:07,679
submit that manual test job yaml so here

00:25:05,840 --> 00:25:10,240
we copied it

00:25:07,679 --> 00:25:11,600
this is uh the gpio test we are going to

00:25:10,240 --> 00:25:13,760
run

00:25:11,600 --> 00:25:16,720
we want to run it on a raspberry pi 4

00:25:13,760 --> 00:25:20,960
device type

00:25:16,720 --> 00:25:24,480
summit lava job and it assigned

00:25:20,960 --> 00:25:28,000
respite for gpio device for the test

00:25:24,480 --> 00:25:31,679
job it's running

00:25:28,000 --> 00:25:34,320
you could see test job locks coming on

00:25:31,679 --> 00:25:34,320
the screen

00:25:37,760 --> 00:25:42,159
close to come it's done we could see

00:25:40,880 --> 00:25:45,120
same uh

00:25:42,159 --> 00:25:47,440
test uh script output uh in the desktop

00:25:45,120 --> 00:25:47,440
log

00:25:49,120 --> 00:25:57,840
and if we go to lava result

00:25:53,360 --> 00:25:57,840
we see gpio test passed

00:25:58,240 --> 00:26:05,200
okay so now for this next section

00:26:01,279 --> 00:26:08,080
uh this was from the jenkins interface

00:26:05,200 --> 00:26:09,520
so fuego uses jenkins as its user

00:26:08,080 --> 00:26:10,000
interface and we can see that i've

00:26:09,520 --> 00:26:13,520
defined

00:26:10,000 --> 00:26:14,559
some tests uh that are part of the fuego

00:26:13,520 --> 00:26:17,600
infrastructure

00:26:14,559 --> 00:26:20,320
i'm going to do a jenkins build which is

00:26:17,600 --> 00:26:23,360
the same thing as a test execution

00:26:20,320 --> 00:26:24,240
and so i'm using the same the same rest

00:26:23,360 --> 00:26:26,080
api

00:26:24,240 --> 00:26:27,760
uh to perform some operations with the

00:26:26,080 --> 00:26:30,480
board uh fuego

00:26:27,760 --> 00:26:32,080
does the test in a series of phases uh

00:26:30,480 --> 00:26:33,600
the pre-test phase is where we check

00:26:32,080 --> 00:26:36,880
connectivity and do some

00:26:33,600 --> 00:26:38,799
some basic uh board sanity checks uh

00:26:36,880 --> 00:26:42,000
then we're actually going to

00:26:38,799 --> 00:26:43,760
deploy the test to the board and execute

00:26:42,000 --> 00:26:45,840
it and we'll get some

00:26:43,760 --> 00:26:47,200
results back i think it's important to

00:26:45,840 --> 00:26:50,240
note that

00:26:47,200 --> 00:26:54,000
i do not have ssh access between

00:26:50,240 --> 00:26:54,480
my lab and the zombie i'm using the rest

00:26:54,000 --> 00:26:56,720
api

00:26:54,480 --> 00:26:58,400
so this is uh there's ssh between the

00:26:56,720 --> 00:27:00,000
zombie and the board

00:26:58,400 --> 00:27:01,679
but these are all operations that are

00:27:00,000 --> 00:27:03,360
going purely through the rest api so

00:27:01,679 --> 00:27:06,240
there's no direct connection between

00:27:03,360 --> 00:27:07,200
between the labs and you don't have to

00:27:06,240 --> 00:27:11,039
open up holes

00:27:07,200 --> 00:27:13,279
in your uh in your network

00:27:11,039 --> 00:27:15,120
in order to let stuff through anyway

00:27:13,279 --> 00:27:18,159
this is showing that the test passed

00:27:15,120 --> 00:27:21,679
uh everything worked great and so

00:27:18,159 --> 00:27:23,760
that's it uh we're we're so

00:27:21,679 --> 00:27:25,279
it was a short demo but uh we're pretty

00:27:23,760 --> 00:27:26,799
excited there was a lot of uh

00:27:25,279 --> 00:27:28,559
there's been a lot of work uh over the

00:27:26,799 --> 00:27:29,440
last couple months to to get that all

00:27:28,559 --> 00:27:32,960
working

00:27:29,440 --> 00:27:36,159
and uh so uh we think that this

00:27:32,960 --> 00:27:39,279
heralds the the dawn of a new age of uh

00:27:36,159 --> 00:27:40,720
remote testing uh for automated uh for

00:27:39,279 --> 00:27:43,440
embedded linux

00:27:40,720 --> 00:27:44,880
so uh now i'll let uh harish i think

00:27:43,440 --> 00:27:47,200
he's gonna talk a little bit more about

00:27:44,880 --> 00:27:49,919
the api details

00:27:47,200 --> 00:27:51,600
thank you uh so let's get uh under the

00:27:49,919 --> 00:27:55,919
hood and see how it's working

00:27:51,600 --> 00:27:59,039
uh here is the actual uh gpio rest api

00:27:55,919 --> 00:28:02,159
so it consists of uh gpio command

00:27:59,039 --> 00:28:04,080
gpio pin pattern and gpio pin data in

00:28:02,159 --> 00:28:06,000
the uri itself

00:28:04,080 --> 00:28:07,120
uh currently it supports eight different

00:28:06,000 --> 00:28:10,880
gpio commands

00:28:07,120 --> 00:28:12,240
uh four for bit mode uh read write get

00:28:10,880 --> 00:28:15,279
mode and set mode

00:28:12,240 --> 00:28:16,000
and four commands for mask read mask

00:28:15,279 --> 00:28:19,919
right mask

00:28:16,000 --> 00:28:20,480
at mode mask and set note mask gpio pin

00:28:19,919 --> 00:28:23,840
pattern

00:28:20,480 --> 00:28:24,399
uh it's lab dependent uh so in our case

00:28:23,840 --> 00:28:27,440
our

00:28:24,399 --> 00:28:30,640
this iocx controller uh

00:28:27,440 --> 00:28:32,320
has eight gpio line so lap pin numbers

00:28:30,640 --> 00:28:34,480
varies from one to eight

00:28:32,320 --> 00:28:36,799
and pattern mask varies from one to two

00:28:34,480 --> 00:28:40,320
fifty five

00:28:36,799 --> 00:28:43,440
in decimal uh gpio pin data again it's a

00:28:40,320 --> 00:28:47,679
lab dependent uh this api

00:28:43,440 --> 00:28:51,120
it returns output in json a json object

00:28:47,679 --> 00:28:53,200
uh result uh with value success and

00:28:51,120 --> 00:28:54,559
uh data value would depend on what

00:28:53,200 --> 00:28:58,240
command you run uh

00:28:54,559 --> 00:29:01,360
your gpio command you run uh in case the

00:28:58,240 --> 00:29:02,080
command fails on the server it returns a

00:29:01,360 --> 00:29:05,360
result as

00:29:02,080 --> 00:29:09,279
fail and why it failed or that

00:29:05,360 --> 00:29:09,279
failure reason comes under message

00:29:10,480 --> 00:29:13,679
this is the section of actual gpio test

00:29:13,120 --> 00:29:17,840
script

00:29:13,679 --> 00:29:21,840
uh here it uh

00:29:17,840 --> 00:29:24,720
uh gpio device uh

00:29:21,840 --> 00:29:26,000
gpio pin 20 was connected uh to lab

00:29:24,720 --> 00:29:29,600
controllers pin number

00:29:26,000 --> 00:29:31,919
six it sets the pin high on the device

00:29:29,600 --> 00:29:32,640
and then uh using the rest api it

00:29:31,919 --> 00:29:37,120
fetches the

00:29:32,640 --> 00:29:39,120
uh value of lap controller gpio pen

00:29:37,120 --> 00:29:40,240
then it does a match between the two if

00:29:39,120 --> 00:29:43,120
the value matches

00:29:40,240 --> 00:29:44,640
test case passed it equals okay four

00:29:43,120 --> 00:29:46,559
with this description

00:29:44,640 --> 00:29:47,679
in case there is a no match test case

00:29:46,559 --> 00:29:54,159
fails and it

00:29:47,679 --> 00:29:56,159
equals not okay with this description

00:29:54,159 --> 00:29:57,440
embedded board from cl uh command line

00:29:56,159 --> 00:30:00,559
tool epf tool

00:29:57,440 --> 00:30:04,480
uh which uh we showed in the demo

00:30:00,559 --> 00:30:06,799
it's implemented using the rest api uh

00:30:04,480 --> 00:30:08,480
it could be used for automation or

00:30:06,799 --> 00:30:12,080
interactive manual use

00:30:08,480 --> 00:30:15,919
and all the eps cli commands they are

00:30:12,080 --> 00:30:19,039
uh purely using the rest api so in

00:30:15,919 --> 00:30:20,559
in this i have listed some of the

00:30:19,039 --> 00:30:23,279
commands and you could see how these

00:30:20,559 --> 00:30:27,200
commands are directly mapped

00:30:23,279 --> 00:30:27,200
with the rest apis

00:30:28,640 --> 00:30:33,200
okay so now i think i'd like to go to a

00:30:30,960 --> 00:30:36,000
wrap up and tell you a little bit about

00:30:33,200 --> 00:30:37,440
some of the issues we encountered and

00:30:36,000 --> 00:30:39,679
some of the next steps

00:30:37,440 --> 00:30:41,200
so a couple of things that i think are

00:30:39,679 --> 00:30:44,000
we encountered that were interesting

00:30:41,200 --> 00:30:45,440
uh in terms of creating this api i think

00:30:44,000 --> 00:30:47,600
it's important to note

00:30:45,440 --> 00:30:49,039
uh the kind of different parts of the

00:30:47,600 --> 00:30:52,240
test framework and the test

00:30:49,039 --> 00:30:55,600
uh use different parts of the api

00:30:52,240 --> 00:30:57,919
and so that's that's uh

00:30:55,600 --> 00:30:59,279
useful information because it helps you

00:30:57,919 --> 00:31:01,919
understand uh

00:30:59,279 --> 00:31:02,640
what parts of the api kind of are are

00:31:01,919 --> 00:31:04,960
needed by

00:31:02,640 --> 00:31:07,039
by different sections of the overall ci

00:31:04,960 --> 00:31:07,679
loop so for instance the test framework

00:31:07,039 --> 00:31:11,600
is going to do

00:31:07,679 --> 00:31:14,399
use actions like run upload and download

00:31:11,600 --> 00:31:15,440
but the in in our case the gpio test

00:31:14,399 --> 00:31:17,120
itself used

00:31:15,440 --> 00:31:18,480
uh things that were dedicated that were

00:31:17,120 --> 00:31:20,559
kind of targeted at a particular

00:31:18,480 --> 00:31:22,320
resource in the lab hardware resource

00:31:20,559 --> 00:31:24,960
things to do set direction read and

00:31:22,320 --> 00:31:26,559
write different frameworks put control

00:31:24,960 --> 00:31:28,000
of operations in different places so

00:31:26,559 --> 00:31:29,600
it's important to kind of separate them

00:31:28,000 --> 00:31:31,679
out and understand

00:31:29,600 --> 00:31:33,039
which parts of the api are being used by

00:31:31,679 --> 00:31:35,279
which parts of

00:31:33,039 --> 00:31:36,320
the different test frameworks one of the

00:31:35,279 --> 00:31:38,640
things we did

00:31:36,320 --> 00:31:41,120
determined that is that we need to

00:31:38,640 --> 00:31:44,000
extend the api a little bit

00:31:41,120 --> 00:31:44,880
there's predefined data that is lab

00:31:44,000 --> 00:31:48,080
independent

00:31:44,880 --> 00:31:49,519
that you can kind of uh put on put into

00:31:48,080 --> 00:31:51,200
the test without having to worry about

00:31:49,519 --> 00:31:55,279
it but there's also discovered data so

00:31:51,200 --> 00:31:57,279
in our example we have a gpio

00:31:55,279 --> 00:31:58,880
endpoint on the board and a gpio

00:31:57,279 --> 00:32:02,159
endpoint in the lab

00:31:58,880 --> 00:32:03,919
and you really need to discover

00:32:02,159 --> 00:32:05,679
the mapping between those two so we

00:32:03,919 --> 00:32:06,960
don't actually in the api right there

00:32:05,679 --> 00:32:10,159
the the demo we had

00:32:06,960 --> 00:32:11,760
today we hard coded those but those are

00:32:10,159 --> 00:32:14,000
going to be different

00:32:11,760 --> 00:32:14,880
per lab because of it depends on the

00:32:14,000 --> 00:32:16,399
wiring that

00:32:14,880 --> 00:32:18,880
that you've done as you've set up the

00:32:16,399 --> 00:32:20,480
hardware in your lab so

00:32:18,880 --> 00:32:22,640
we're learning the types of things that

00:32:20,480 --> 00:32:23,840
we're going to have to do to extend the

00:32:22,640 --> 00:32:26,320
api to cover

00:32:23,840 --> 00:32:27,519
use cases and make the test truly lab

00:32:26,320 --> 00:32:29,679
independent

00:32:27,519 --> 00:32:31,679
uh the other thing that we discovered is

00:32:29,679 --> 00:32:34,399
just impedance mismatch between

00:32:31,679 --> 00:32:35,840
the expectations of uh different test

00:32:34,399 --> 00:32:38,960
frameworks so

00:32:35,840 --> 00:32:40,799
as an example uh the way that the test

00:32:38,960 --> 00:32:43,360
operates in the

00:32:40,799 --> 00:32:45,600
um in the time syslab uh they only

00:32:43,360 --> 00:32:48,159
needed a single file to be copied over

00:32:45,600 --> 00:32:49,840
uh fuego a lot of fuego tests use a

00:32:48,159 --> 00:32:51,919
recursive file copy

00:32:49,840 --> 00:32:53,120
uh currently the rest api only supports

00:32:51,919 --> 00:32:54,640
that single file

00:32:53,120 --> 00:32:56,399
and we're able to work around around

00:32:54,640 --> 00:32:58,159
that but

00:32:56,399 --> 00:32:59,840
we want to look and see what are the

00:32:58,159 --> 00:33:02,799
actual requirements from

00:32:59,840 --> 00:33:03,600
the different test frameworks and how

00:33:02,799 --> 00:33:06,399
they operate

00:33:03,600 --> 00:33:07,279
and continue to refine the api and then

00:33:06,399 --> 00:33:08,960
the last thing

00:33:07,279 --> 00:33:11,120
is you need to integrate all of this

00:33:08,960 --> 00:33:13,120
with your larger ci loop so there are

00:33:11,120 --> 00:33:16,640
actions that you perform on your boards

00:33:13,120 --> 00:33:18,480
provisioning the board and getting stuff

00:33:16,640 --> 00:33:19,440
set up that you also need to take into

00:33:18,480 --> 00:33:21,360
account

00:33:19,440 --> 00:33:23,039
so what's next so we've demonstrated the

00:33:21,360 --> 00:33:24,640
basic concept and we're pretty excited

00:33:23,039 --> 00:33:27,600
about it uh

00:33:24,640 --> 00:33:29,279
but uh we need to we need to go to the

00:33:27,600 --> 00:33:30,399
next step create apis for other lab

00:33:29,279 --> 00:33:33,760
resource types

00:33:30,399 --> 00:33:37,440
so we're pretty sure that it's um

00:33:33,760 --> 00:33:39,760
it's not an endless uh task ahead of us

00:33:37,440 --> 00:33:41,440
there's a lot of resources we did a

00:33:39,760 --> 00:33:42,960
simple end-to-end task where we're just

00:33:41,440 --> 00:33:44,399
controlling two endpoints with

00:33:42,960 --> 00:33:46,640
basically ones or zeros in some

00:33:44,399 --> 00:33:48,480
directions

00:33:46,640 --> 00:33:50,000
for other types of lab equipment you're

00:33:48,480 --> 00:33:52,000
going to need different apis

00:33:50,000 --> 00:33:53,200
but we think that a lot of the types of

00:33:52,000 --> 00:33:54,080
things you're going to be doing with the

00:33:53,200 --> 00:33:57,120
lab equipment

00:33:54,080 --> 00:33:58,640
is going to be generalizable you're

00:33:57,120 --> 00:34:00,320
going to be able to generalize it to

00:33:58,640 --> 00:34:01,760
just a couple of simple commands so for

00:34:00,320 --> 00:34:03,360
instance for power management audio

00:34:01,760 --> 00:34:04,880
capture and video capture

00:34:03,360 --> 00:34:06,799
you're going to need a verb for start

00:34:04,880 --> 00:34:10,480
capture and capture and then

00:34:06,799 --> 00:34:12,159
get that log now the actual not so

00:34:10,480 --> 00:34:13,839
obviously audio capture and power

00:34:12,159 --> 00:34:14,800
measurement return different types of

00:34:13,839 --> 00:34:16,639
logs

00:34:14,800 --> 00:34:18,480
but we don't think that the api has to

00:34:16,639 --> 00:34:21,200
actually deal

00:34:18,480 --> 00:34:22,720
with the specifics of the lat of the

00:34:21,200 --> 00:34:25,520
kind of the log type

00:34:22,720 --> 00:34:25,919
uh but we we may decide differently so

00:34:25,520 --> 00:34:28,480
we

00:34:25,919 --> 00:34:30,240
uh we may decide to include some

00:34:28,480 --> 00:34:31,679
resource specific type actions to

00:34:30,240 --> 00:34:33,359
support so for instance in power

00:34:31,679 --> 00:34:34,159
management instead of just returning git

00:34:33,359 --> 00:34:36,320
log

00:34:34,159 --> 00:34:37,919
and having the framework or the test

00:34:36,320 --> 00:34:40,639
analyze the log

00:34:37,919 --> 00:34:41,760
we may introduce a verb like get max

00:34:40,639 --> 00:34:43,760
power

00:34:41,760 --> 00:34:45,200
where the driver for your power

00:34:43,760 --> 00:34:47,200
measurement device can

00:34:45,200 --> 00:34:48,879
analyze the log for you and return a

00:34:47,200 --> 00:34:50,079
single number that that has meaning for

00:34:48,879 --> 00:34:52,159
the test

00:34:50,079 --> 00:34:53,760
but overall we need to run a bunch of

00:34:52,159 --> 00:34:57,200
different tests and see what issues crop

00:34:53,760 --> 00:34:58,000
up um the important thing and the reason

00:34:57,200 --> 00:34:59,440
we're here today

00:34:58,000 --> 00:35:01,359
is we want to convince other labs and

00:34:59,440 --> 00:35:03,119
frameworks to adopt this api that's how

00:35:01,359 --> 00:35:04,560
we're going to

00:35:03,119 --> 00:35:06,079
get to a place where we can have an

00:35:04,560 --> 00:35:07,440
ecosystem of tests that we're all

00:35:06,079 --> 00:35:09,359
sharing with each other

00:35:07,440 --> 00:35:11,040
and so we'd like to profit from that

00:35:09,359 --> 00:35:12,640
ecosystem start sharing tests the same

00:35:11,040 --> 00:35:14,400
way that we're sharing

00:35:12,640 --> 00:35:16,560
open source code we'd like to be able to

00:35:14,400 --> 00:35:18,800
share open source uh

00:35:16,560 --> 00:35:20,400
testing artifacts uh the tests

00:35:18,800 --> 00:35:22,160
themselves the results

00:35:20,400 --> 00:35:23,760
and all that and we think that uh this

00:35:22,160 --> 00:35:26,400
is a a way to start

00:35:23,760 --> 00:35:26,880
with all of this type of stuff uh you

00:35:26,400 --> 00:35:28,400
have a

00:35:26,880 --> 00:35:30,560
chicken and egg problem someone's gotta

00:35:28,400 --> 00:35:32,720
go first no you that's fine raise you

00:35:30,560 --> 00:35:35,839
can go to the next slide

00:35:32,720 --> 00:35:37,440
so we know that uh

00:35:35,839 --> 00:35:38,960
people are not going to write tests

00:35:37,440 --> 00:35:41,200
until the the

00:35:38,960 --> 00:35:42,000
labs have this in their farms and people

00:35:41,200 --> 00:35:43,760
are not going to want to

00:35:42,000 --> 00:35:45,040
put this in their farms until people

00:35:43,760 --> 00:35:46,480
have written tests but

00:35:45,040 --> 00:35:48,320
someone's got to take a first step and

00:35:46,480 --> 00:35:52,160
we feel like we we've got

00:35:48,320 --> 00:35:54,560
a good start on this uh there there are

00:35:52,160 --> 00:35:55,440
schema definitions and other materials

00:35:54,560 --> 00:35:59,280
related to

00:35:55,440 --> 00:36:02,079
this project uh that uh are going

00:35:59,280 --> 00:36:03,599
into this repository here then github

00:36:02,079 --> 00:36:05,680
and we are very excited

00:36:03,599 --> 00:36:07,520
uh to have people give us feedback if

00:36:05,680 --> 00:36:10,079
you want to join the lab

00:36:07,520 --> 00:36:11,040
uh join join this effort um please

00:36:10,079 --> 00:36:14,640
communicate with

00:36:11,040 --> 00:36:16,480
any of us and we would love to get

00:36:14,640 --> 00:36:18,720
additional labs especially of different

00:36:16,480 --> 00:36:21,280
types of hardware

00:36:18,720 --> 00:36:22,320
involved and try to do some testing to

00:36:21,280 --> 00:36:23,680
make sure that we're covering

00:36:22,320 --> 00:36:25,680
everybody's use cases

00:36:23,680 --> 00:36:28,320
and with that i will thank you for your

00:36:25,680 --> 00:36:41,839
time and we'll move on to some comments

00:36:28,320 --> 00:36:41,839
so any any questions or comments

00:36:44,240 --> 00:36:46,320

YouTube URL: https://www.youtube.com/watch?v=ePYHuWyb0uk


