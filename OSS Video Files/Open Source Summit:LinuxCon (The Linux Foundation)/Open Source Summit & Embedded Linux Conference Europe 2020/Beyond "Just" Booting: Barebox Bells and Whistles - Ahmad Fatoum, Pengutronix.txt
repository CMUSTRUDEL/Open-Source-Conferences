Title: Beyond "Just" Booting: Barebox Bells and Whistles - Ahmad Fatoum, Pengutronix
Publication date: 2020-11-03
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Beyond "Just" Booting: Barebox Bells and Whistles - Ahmad Fatoum, Pengutronix
Captions: 
	00:00:04,260 --> 00:00:12,449
[Music]

00:00:15,440 --> 00:00:19,199
hello and welcome to my talk

00:00:17,119 --> 00:00:20,720
about the bearbox bootloader and some of

00:00:19,199 --> 00:00:21,520
its nifty features that i would like to

00:00:20,720 --> 00:00:23,519
share with you

00:00:21,520 --> 00:00:25,359
my name is ahmad fattun i am an embedded

00:00:23,519 --> 00:00:27,519
linux developer with pingotronix

00:00:25,359 --> 00:00:29,039
a german linux consulting company where

00:00:27,519 --> 00:00:32,240
i have been using bearbox

00:00:29,039 --> 00:00:32,240
for the last two years

00:00:33,200 --> 00:00:37,360
as for the structure of my talk i will

00:00:35,840 --> 00:00:38,239
start with an obligatory what's a

00:00:37,360 --> 00:00:39,680
bootloader

00:00:38,239 --> 00:00:42,000
then we will talk a bit about the

00:00:39,680 --> 00:00:42,800
complexities that arise how bearbox came

00:00:42,000 --> 00:00:44,719
to be

00:00:42,800 --> 00:00:46,320
then we will look at how to port bear

00:00:44,719 --> 00:00:48,559
box to a new board

00:00:46,320 --> 00:00:49,520
how to customize spare box for a simple

00:00:48,559 --> 00:00:52,239
booting

00:00:49,520 --> 00:00:53,520
mode then how to do it for redundant

00:00:52,239 --> 00:00:56,399
boot

00:00:53,520 --> 00:00:57,280
then we will look at using bear box for

00:00:56,399 --> 00:00:59,760
bring up

00:00:57,280 --> 00:01:01,440
and along the way we will discuss these

00:00:59,760 --> 00:01:01,920
abstractions that have evolved in bear

00:01:01,440 --> 00:01:06,159
box

00:01:01,920 --> 00:01:06,159
to keep the complexity of it all at bay

00:01:07,439 --> 00:01:13,040
so to start off what's a bootloader so

00:01:10,159 --> 00:01:15,520
on a modern soc you have some

00:01:13,040 --> 00:01:17,920
sort of boot rom that's masked into the

00:01:15,520 --> 00:01:20,320
ship this does the bare minimum needed

00:01:17,920 --> 00:01:21,360
low level initialization to to load our

00:01:20,320 --> 00:01:24,799
bootloader

00:01:21,360 --> 00:01:26,720
into an on-chip sram and from there on

00:01:24,799 --> 00:01:28,000
our bootloader has to do all the other

00:01:26,720 --> 00:01:30,720
initialization

00:01:28,000 --> 00:01:32,880
that bootrom didn't know how to do it

00:01:30,720 --> 00:01:34,640
needs to set up the sdram controller

00:01:32,880 --> 00:01:36,960
it needs to configure the clocks and the

00:01:34,640 --> 00:01:37,759
plls and then it needs to access the

00:01:36,960 --> 00:01:39,680
boot medium

00:01:37,759 --> 00:01:41,119
to fetch the kernel and any other

00:01:39,680 --> 00:01:44,159
binaries that might need

00:01:41,119 --> 00:01:46,560
for example an init rd or a device tree

00:01:44,159 --> 00:01:47,759
and at the end it will start the kernel

00:01:46,560 --> 00:01:52,159
with these parameters

00:01:47,759 --> 00:01:55,680
and images but we have come to expect

00:01:52,159 --> 00:01:57,520
more of the bootloader so there might be

00:01:55,680 --> 00:01:59,360
other firmware besides the main

00:01:57,520 --> 00:02:00,240
processors that need firmware loaded for

00:01:59,360 --> 00:02:02,000
so

00:02:00,240 --> 00:02:03,759
there might be a secure monitor binary

00:02:02,000 --> 00:02:06,799
that we need to load

00:02:03,759 --> 00:02:08,720
the boot process should also be fast

00:02:06,799 --> 00:02:10,239
so we need to use the caches which on

00:02:08,720 --> 00:02:12,560
some architecture

00:02:10,239 --> 00:02:14,400
means that we need to have a driver for

00:02:12,560 --> 00:02:16,160
the memory management unit

00:02:14,400 --> 00:02:17,520
and fetching the kernel from the boot

00:02:16,160 --> 00:02:19,360
medium isn't

00:02:17,520 --> 00:02:21,200
always the same we might have different

00:02:19,360 --> 00:02:24,000
boot media and we need

00:02:21,200 --> 00:02:25,760
to try them in order we might have

00:02:24,000 --> 00:02:26,480
multiple partitions on the same boot

00:02:25,760 --> 00:02:28,640
medium

00:02:26,480 --> 00:02:30,879
so we need to have some decision making

00:02:28,640 --> 00:02:32,959
to decide which partition to use

00:02:30,879 --> 00:02:35,120
we might need to enable a bootsplash

00:02:32,959 --> 00:02:37,760
because the boot process takes a bit

00:02:35,120 --> 00:02:39,599
longer than anticipated

00:02:37,760 --> 00:02:41,840
we might need to kick off a crowd

00:02:39,599 --> 00:02:43,440
processor or even communicate with it

00:02:41,840 --> 00:02:44,879
out of the bootloader because it has

00:02:43,440 --> 00:02:47,120
access to some peripherals

00:02:44,879 --> 00:02:48,720
that we don't for example some clocks or

00:02:47,120 --> 00:02:50,640
reset lines

00:02:48,720 --> 00:02:52,640
and when we have the kernel image we

00:02:50,640 --> 00:02:55,040
might not be able to put it directly

00:02:52,640 --> 00:02:55,680
we may need to check a cryptographic

00:02:55,040 --> 00:02:58,400
signature

00:02:55,680 --> 00:02:59,920
to be sure that it's it's a kernel image

00:02:58,400 --> 00:03:01,920
that needs to be booted

00:02:59,920 --> 00:03:03,680
there might be device 3 fix ups that we

00:03:01,920 --> 00:03:06,400
need to do on the device 3 binary for

00:03:03,680 --> 00:03:08,319
example we can have the same board once

00:03:06,400 --> 00:03:10,080
with a display and once without

00:03:08,319 --> 00:03:12,400
and the bootloader needs to detect which

00:03:10,080 --> 00:03:13,920
kind of board it is and then it will fix

00:03:12,400 --> 00:03:15,120
up the device tree to either have a

00:03:13,920 --> 00:03:16,959
display or not

00:03:15,120 --> 00:03:19,599
then we might need to enable a watchdog

00:03:16,959 --> 00:03:21,920
so we can monitor the boot process

00:03:19,599 --> 00:03:23,760
and then at the end we can do which is

00:03:21,920 --> 00:03:24,319
what the bootloader is ultimately made

00:03:23,760 --> 00:03:27,599
for

00:03:24,319 --> 00:03:31,040
to start the kernel but

00:03:27,599 --> 00:03:33,519
this gets complex real fast but we want

00:03:31,040 --> 00:03:35,360
to maintain a scalable and maintainable

00:03:33,519 --> 00:03:38,159
code base so we would

00:03:35,360 --> 00:03:39,360
prefer to have some abstraction to keep

00:03:38,159 --> 00:03:42,560
the complexity

00:03:39,360 --> 00:03:43,840
lower arguably useful abstractions are

00:03:42,560 --> 00:03:46,959
driver model

00:03:43,840 --> 00:03:50,239
so an sd card controller

00:03:46,959 --> 00:03:52,000
a host controller they do basically all

00:03:50,239 --> 00:03:52,720
the same things they interact with some

00:03:52,000 --> 00:03:55,040
hardware

00:03:52,720 --> 00:03:57,200
and then they allow you to set io

00:03:55,040 --> 00:03:59,519
settings and they allow you to send mmc

00:03:57,200 --> 00:04:02,879
commands over the mmc protocol

00:03:59,519 --> 00:04:05,280
so it would be nice that all mmc

00:04:02,879 --> 00:04:06,480
host drivers implement this same

00:04:05,280 --> 00:04:09,120
interface

00:04:06,480 --> 00:04:10,560
and then you can handle them all the

00:04:09,120 --> 00:04:14,159
same from the same

00:04:10,560 --> 00:04:16,239
mmc core and you could have for example

00:04:14,159 --> 00:04:19,280
this mmc core provide you

00:04:16,239 --> 00:04:21,040
block device operations so at the end

00:04:19,280 --> 00:04:22,240
someone using this will just interact

00:04:21,040 --> 00:04:25,199
with reads right

00:04:22,240 --> 00:04:26,400
of blocks and doesn't have to worry

00:04:25,199 --> 00:04:30,639
about the specifics

00:04:26,400 --> 00:04:33,840
that it is an sd card for example

00:04:30,639 --> 00:04:35,520
typed tightly connected to that is

00:04:33,840 --> 00:04:36,800
having some separate hardware

00:04:35,520 --> 00:04:39,440
description

00:04:36,800 --> 00:04:41,520
so a device specific language like

00:04:39,440 --> 00:04:44,240
device 3 is uniquely positioned

00:04:41,520 --> 00:04:45,919
to represent these complex hardware

00:04:44,240 --> 00:04:46,400
setups that we have nowadays where you

00:04:45,919 --> 00:04:48,880
have

00:04:46,400 --> 00:04:49,520
soc families that share some ip cores

00:04:48,880 --> 00:04:51,520
and share

00:04:49,520 --> 00:04:53,759
and don't share some others where you

00:04:51,520 --> 00:04:54,080
have system on modules that can be fit

00:04:53,759 --> 00:04:56,320
on

00:04:54,080 --> 00:04:57,919
different baseboards so you would

00:04:56,320 --> 00:04:59,600
appreciate having some sort of code

00:04:57,919 --> 00:05:01,520
reuse or inheritance

00:04:59,600 --> 00:05:02,800
which can be done nicely with device

00:05:01,520 --> 00:05:04,720
tree

00:05:02,800 --> 00:05:06,000
there are some other abstractions like a

00:05:04,720 --> 00:05:08,720
virtual fight system

00:05:06,000 --> 00:05:10,240
so you would appreciate having the

00:05:08,720 --> 00:05:13,120
ability to just

00:05:10,240 --> 00:05:15,039
mount a file system at allocation and

00:05:13,120 --> 00:05:16,240
then you can interact with it like any

00:05:15,039 --> 00:05:18,639
other file system

00:05:16,240 --> 00:05:20,960
and you don't have to keep track for

00:05:18,639 --> 00:05:22,639
okay i have this partition on the mmc

00:05:20,960 --> 00:05:25,280
and that has an x4

00:05:22,639 --> 00:05:27,680
on it so i need to use the read and

00:05:25,280 --> 00:05:29,440
write operations that are meant for x4

00:05:27,680 --> 00:05:31,280
you can just use a generic read and

00:05:29,440 --> 00:05:33,440
write

00:05:31,280 --> 00:05:35,280
having a block layer so you can do

00:05:33,440 --> 00:05:36,240
caching of blocks having character

00:05:35,280 --> 00:05:38,400
devices

00:05:36,240 --> 00:05:39,759
so you can abstract away the differences

00:05:38,400 --> 00:05:42,320
between let's say

00:05:39,759 --> 00:05:43,120
a registry map that's just memory mapped

00:05:42,320 --> 00:05:45,520
io

00:05:43,120 --> 00:05:47,840
or a registry map that's connected over

00:05:45,520 --> 00:05:49,919
spi

00:05:47,840 --> 00:05:52,000
and you will want to interact with these

00:05:49,919 --> 00:05:53,520
character devices and with the drivers

00:05:52,000 --> 00:05:55,440
interactively so you need to have a

00:05:53,520 --> 00:05:56,319
shell prompt and you need to be able to

00:05:55,440 --> 00:05:59,360
write scripts

00:05:56,319 --> 00:05:59,840
for your shell and you would like to

00:05:59,360 --> 00:06:02,240
have

00:05:59,840 --> 00:06:03,280
the ability to persist these scripts

00:06:02,240 --> 00:06:06,319
that you have

00:06:03,280 --> 00:06:08,080
written and all this is for

00:06:06,319 --> 00:06:09,520
having the ability to introspect your

00:06:08,080 --> 00:06:12,479
system so you can do

00:06:09,520 --> 00:06:14,960
rape rapid debugging and rapid debugging

00:06:12,479 --> 00:06:14,960
cycles

00:06:15,280 --> 00:06:18,880
you might be inclined to think that this

00:06:17,520 --> 00:06:21,520
is basically what

00:06:18,880 --> 00:06:23,520
linux is already capable of doing which

00:06:21,520 --> 00:06:25,199
is right you could compile linux with a

00:06:23,520 --> 00:06:26,080
built-in inner trim fs with a built-in

00:06:25,199 --> 00:06:27,600
device tree

00:06:26,080 --> 00:06:29,280
and that would check all these above

00:06:27,600 --> 00:06:31,120
boxes but the

00:06:29,280 --> 00:06:33,120
boot process is very much size

00:06:31,120 --> 00:06:34,319
constrained because you need at first to

00:06:33,120 --> 00:06:37,360
fit into an sram

00:06:34,319 --> 00:06:40,080
and then you chain loads your

00:06:37,360 --> 00:06:41,199
second stage which also should be small

00:06:40,080 --> 00:06:44,080
so you don't spend

00:06:41,199 --> 00:06:45,199
too much time in it and linux would

00:06:44,080 --> 00:06:47,919
still need to be

00:06:45,199 --> 00:06:49,039
extended to support stuff like sdram

00:06:47,919 --> 00:06:51,759
initialization

00:06:49,039 --> 00:06:53,199
and so on and clock setup in this low

00:06:51,759 --> 00:06:55,840
level clock setup

00:06:53,199 --> 00:06:58,319
and here comes the idea that why

00:06:55,840 --> 00:07:00,720
shouldn't we take an existing bootloader

00:06:58,319 --> 00:07:03,039
and extend it with this useful part of

00:07:00,720 --> 00:07:06,400
linux for boots strapping

00:07:03,039 --> 00:07:07,039
and that's basically how bearbox came to

00:07:06,400 --> 00:07:09,759
be

00:07:07,039 --> 00:07:12,080
so it started as a yubit fork called

00:07:09,759 --> 00:07:15,120
ubud version 2 in 2007

00:07:12,080 --> 00:07:16,000
it was renamed to bearbox in 2009 it's

00:07:15,120 --> 00:07:19,440
licensed under

00:07:16,000 --> 00:07:20,479
the gpo2 and it has a monthly release

00:07:19,440 --> 00:07:22,720
cycle

00:07:20,479 --> 00:07:23,919
and now it supports a couple of

00:07:22,720 --> 00:07:27,599
architectures r

00:07:23,919 --> 00:07:29,599
mips x86 evi risc-5

00:07:27,599 --> 00:07:31,360
and its main selling points back then

00:07:29,599 --> 00:07:35,440
where a linux like driver

00:07:31,360 --> 00:07:37,280
api so you have a driver model inspired

00:07:35,440 --> 00:07:38,080
by linux and you have drivers that

00:07:37,280 --> 00:07:40,960
implement

00:07:38,080 --> 00:07:42,800
the same api or an api that's very

00:07:40,960 --> 00:07:44,560
similar to the one used within linux so

00:07:42,800 --> 00:07:48,240
this makes porting easier

00:07:44,560 --> 00:07:49,360
the coding style is set of which linux

00:07:48,240 --> 00:07:51,039
adheres to

00:07:49,360 --> 00:07:53,280
it doesn't use header files for

00:07:51,039 --> 00:07:56,160
configuration instead it uses a kernel

00:07:53,280 --> 00:07:58,319
config system and it uses cabled for

00:07:56,160 --> 00:08:01,199
building the kernel

00:07:58,319 --> 00:08:02,800
and for the user api it has a posix-like

00:08:01,199 --> 00:08:04,879
file descriptor based api

00:08:02,800 --> 00:08:07,199
so you can just open a file in the

00:08:04,879 --> 00:08:10,240
virtual file system read and write

00:08:07,199 --> 00:08:12,160
to it and from it and it can also be

00:08:10,240 --> 00:08:13,759
accessed over a unix-like interactive

00:08:12,160 --> 00:08:15,919
shell where you have your usual

00:08:13,759 --> 00:08:19,520
utilities

00:08:15,919 --> 00:08:22,879
so that's basically what

00:08:19,520 --> 00:08:24,080
bearbox was made for and over the years

00:08:22,879 --> 00:08:26,960
there have been some

00:08:24,080 --> 00:08:27,680
more features that are more about

00:08:26,960 --> 00:08:32,159
booting

00:08:27,680 --> 00:08:35,200
which we will look like during this talk

00:08:32,159 --> 00:08:36,240
so let's see how we can port bearbox to

00:08:35,200 --> 00:08:38,320
your board

00:08:36,240 --> 00:08:39,919
so you can split a traditional booting

00:08:38,320 --> 00:08:40,719
process into a first and the second

00:08:39,919 --> 00:08:42,839
stage

00:08:40,719 --> 00:08:44,800
the first stage does this low level

00:08:42,839 --> 00:08:46,959
initialization

00:08:44,800 --> 00:08:48,720
that's needed to load the second stage

00:08:46,959 --> 00:08:49,680
that would be on your personal computer

00:08:48,720 --> 00:08:51,839
as a bias

00:08:49,680 --> 00:08:54,000
and the second stage is what runs from

00:08:51,839 --> 00:08:56,320
the sdram which can a bit bigger than

00:08:54,000 --> 00:09:00,240
the limited sram or flash you have

00:08:56,320 --> 00:09:02,880
and this one loads the kernel sets and

00:09:00,240 --> 00:09:03,839
which is our operating system which we

00:09:02,880 --> 00:09:06,080
should load

00:09:03,839 --> 00:09:08,720
and bailbox can be used as boss so on

00:09:06,080 --> 00:09:11,920
some socs it can use the second stage

00:09:08,720 --> 00:09:12,320
on some others it can be used as first

00:09:11,920 --> 00:09:15,519
stage

00:09:12,320 --> 00:09:17,920
as well we will look in this talk

00:09:15,519 --> 00:09:18,959
how to use bearbox as a second stage for

00:09:17,920 --> 00:09:21,519
your board

00:09:18,959 --> 00:09:22,640
so if you have worked with a linux

00:09:21,519 --> 00:09:24,240
multi-platform kernel

00:09:22,640 --> 00:09:26,080
you might think the same as me that's a

00:09:24,240 --> 00:09:27,600
pretty great thing that you can have

00:09:26,080 --> 00:09:31,040
just this one generic

00:09:27,600 --> 00:09:33,279
image and use it on dozens of different

00:09:31,040 --> 00:09:35,279
socs on hundreds of different boards

00:09:33,279 --> 00:09:37,040
this all works because you have a

00:09:35,279 --> 00:09:38,800
separate device tree description

00:09:37,040 --> 00:09:40,480
and this device tree describes the

00:09:38,800 --> 00:09:42,959
actual hardware you have on your board

00:09:40,480 --> 00:09:45,200
and then you start the kernel which is a

00:09:42,959 --> 00:09:47,519
multi-platform arm kernel for example

00:09:45,200 --> 00:09:48,560
and then when it has done the low-level

00:09:47,519 --> 00:09:51,040
initialization

00:09:48,560 --> 00:09:52,560
it uses a device street to discover what

00:09:51,040 --> 00:09:55,360
kind of devices are there

00:09:52,560 --> 00:09:55,680
so you can have multiple devices drivers

00:09:55,360 --> 00:09:57,519
but

00:09:55,680 --> 00:09:58,720
only the drivers for the devices that

00:09:57,519 --> 00:10:02,240
are actually there are

00:09:58,720 --> 00:10:03,680
activated and for the second stage boot

00:10:02,240 --> 00:10:07,440
loader we would like to have

00:10:03,680 --> 00:10:09,600
some similar setup we can't

00:10:07,440 --> 00:10:12,000
depend on another bootloader to pass as

00:10:09,600 --> 00:10:14,160
a device tree usually as the kernel does

00:10:12,000 --> 00:10:15,360
so what we do is that we define a new

00:10:14,160 --> 00:10:17,279
preboot loader

00:10:15,360 --> 00:10:18,399
and this preboot loader passes us a

00:10:17,279 --> 00:10:22,480
device tree

00:10:18,399 --> 00:10:24,320
and preboot loader we will call pbl in

00:10:22,480 --> 00:10:27,279
this talk

00:10:24,320 --> 00:10:28,399
and normal box binary we will call

00:10:27,279 --> 00:10:30,079
bearbox proper

00:10:28,399 --> 00:10:31,440
so how that looks like we see to the

00:10:30,079 --> 00:10:33,760
right we have

00:10:31,440 --> 00:10:34,640
three examples once we have bearbox

00:10:33,760 --> 00:10:38,399
prefixed

00:10:34,640 --> 00:10:40,079
with a preboot loader and a device tree

00:10:38,399 --> 00:10:41,440
and the preboot loader passes the device

00:10:40,079 --> 00:10:43,279
three to bare box

00:10:41,440 --> 00:10:44,880
another time we have two device trees

00:10:43,279 --> 00:10:47,200
and bear box can decide

00:10:44,880 --> 00:10:48,480
which device tree to use in the pbl and

00:10:47,200 --> 00:10:51,360
pass that

00:10:48,480 --> 00:10:52,800
and in the middle we see another example

00:10:51,360 --> 00:10:53,760
where we have just one device three but

00:10:52,800 --> 00:10:55,760
some firmware

00:10:53,760 --> 00:10:59,120
which we need to early load so that's

00:10:55,760 --> 00:11:01,360
something we can also use a pbl for

00:10:59,120 --> 00:11:02,240
one short slide about the first stage

00:11:01,360 --> 00:11:04,720
bootloader

00:11:02,240 --> 00:11:05,279
how would that look like with image

00:11:04,720 --> 00:11:08,240
format

00:11:05,279 --> 00:11:09,920
just we have just shown so the best way

00:11:08,240 --> 00:11:11,839
would be to do the clock setup and

00:11:09,920 --> 00:11:14,399
there's dram in the pbl

00:11:11,839 --> 00:11:15,920
we see that on the imx so the pbl runs

00:11:14,399 --> 00:11:16,880
it will see that it's not running from

00:11:15,920 --> 00:11:21,200
sdram

00:11:16,880 --> 00:11:23,920
so it loads so it does a low level setup

00:11:21,200 --> 00:11:25,360
and then it shall load spare box again

00:11:23,920 --> 00:11:28,560
with the same pbl

00:11:25,360 --> 00:11:32,800
but this time it loads a full image not

00:11:28,560 --> 00:11:36,000
a small image that's only the fsbl part

00:11:32,800 --> 00:11:36,640
into our sdram and then bearbox is run

00:11:36,000 --> 00:11:39,279
again

00:11:36,640 --> 00:11:40,399
and it will see okay now i am running

00:11:39,279 --> 00:11:43,519
from the sdram

00:11:40,399 --> 00:11:44,480
so now let's do the normal boot up where

00:11:43,519 --> 00:11:46,640
i

00:11:44,480 --> 00:11:49,120
extract bear box to the end of the sdram

00:11:46,640 --> 00:11:50,880
and branch to it

00:11:49,120 --> 00:11:52,240
this is very nice for development

00:11:50,880 --> 00:11:52,959
because you have good compile time

00:11:52,240 --> 00:11:55,279
coverage

00:11:52,959 --> 00:11:56,560
you can just build for example imx

00:11:55,279 --> 00:11:59,279
version 7 devconfig

00:11:56,560 --> 00:12:00,800
and it builds images for over 100 bots

00:11:59,279 --> 00:12:02,800
at once

00:12:00,800 --> 00:12:04,399
and it's nice for integration too so you

00:12:02,800 --> 00:12:05,920
will probably not use a devconfig for

00:12:04,399 --> 00:12:09,200
your bot but you might have

00:12:05,920 --> 00:12:12,079
a few different ime exports

00:12:09,200 --> 00:12:12,639
so you can use the same config for all

00:12:12,079 --> 00:12:16,560
of them

00:12:12,639 --> 00:12:19,760
the same be a recipe in your bsp

00:12:16,560 --> 00:12:22,399
and that will generate you more than one

00:12:19,760 --> 00:12:22,959
image one image for each of your bots

00:12:22,399 --> 00:12:25,360
and an

00:12:22,959 --> 00:12:26,720
alternative that might be easier is to

00:12:25,360 --> 00:12:29,680
build bear box twice

00:12:26,720 --> 00:12:30,959
and then overrides a first stage

00:12:29,680 --> 00:12:33,440
bootloader in it

00:12:30,959 --> 00:12:34,399
so that it just chain loads the ssbl you

00:12:33,440 --> 00:12:36,639
can do that but

00:12:34,399 --> 00:12:38,800
this comes at the cost that the fsbl is

00:12:36,639 --> 00:12:40,959
no longer multi-image capable

00:12:38,800 --> 00:12:42,639
so multi-image is set what you see to

00:12:40,959 --> 00:12:45,839
the right that you have

00:12:42,639 --> 00:12:47,600
just bearbox separately and each time

00:12:45,839 --> 00:12:48,399
for each board it's prefixed with a bot

00:12:47,600 --> 00:12:52,000
specific

00:12:48,399 --> 00:12:52,800
pre-boot loader now that we have talked

00:12:52,000 --> 00:12:55,120
about this

00:12:52,800 --> 00:12:56,160
let's look how you can make this work on

00:12:55,120 --> 00:12:59,120
your board

00:12:56,160 --> 00:12:59,839
so we will assume you are using device

00:12:59,120 --> 00:13:01,440
tree

00:12:59,839 --> 00:13:02,959
and further it would be nice if you are

00:13:01,440 --> 00:13:04,399
a good citizen and have already

00:13:02,959 --> 00:13:05,279
upstreamed your device tree into the

00:13:04,399 --> 00:13:07,360
kernel

00:13:05,279 --> 00:13:08,560
if that's the case you just need to wait

00:13:07,360 --> 00:13:11,120
a bit and

00:13:08,560 --> 00:13:11,920
bearbox will import all linux device

00:13:11,120 --> 00:13:14,880
trees

00:13:11,920 --> 00:13:15,760
into slash dts this is done on a regular

00:13:14,880 --> 00:13:18,399
mana

00:13:15,760 --> 00:13:21,200
and as soon as that happened you can

00:13:18,399 --> 00:13:23,279
define a bearbox tts we see that here

00:13:21,200 --> 00:13:25,120
what the bearbox dts is doing is it's

00:13:23,279 --> 00:13:27,920
including the upstream device tree

00:13:25,120 --> 00:13:28,800
then it's including a soc device tree

00:13:27,920 --> 00:13:31,440
that's

00:13:28,800 --> 00:13:32,000
specific to barebox then it's that's all

00:13:31,440 --> 00:13:35,040
you need

00:13:32,000 --> 00:13:37,040
you can also add some extra notes

00:13:35,040 --> 00:13:39,199
here we add a note for having and

00:13:37,040 --> 00:13:41,440
persistent environment on the emmc in a

00:13:39,199 --> 00:13:43,760
partition called bearbox environment

00:13:41,440 --> 00:13:45,760
and at the time of writing the upstream

00:13:43,760 --> 00:13:46,560
device 3 didn't have a reset gpios

00:13:45,760 --> 00:13:49,600
property

00:13:46,560 --> 00:13:52,399
so this is fixed up in the barebox

00:13:49,600 --> 00:13:52,399
device tree

00:13:52,959 --> 00:13:56,240
now we need to pass this device tree to

00:13:55,360 --> 00:13:58,639
bearbox

00:13:56,240 --> 00:14:00,240
proper so you need to have a

00:13:58,639 --> 00:14:02,320
prebootloader entry point

00:14:00,240 --> 00:14:04,240
we see here how that looks like you do

00:14:02,320 --> 00:14:04,639
some low level initialization this may

00:14:04,240 --> 00:14:08,399
set

00:14:04,639 --> 00:14:10,720
up the stack or the caches if needed

00:14:08,399 --> 00:14:13,279
then we print some symbol to make

00:14:10,720 --> 00:14:16,079
debugging easier in future so you can

00:14:13,279 --> 00:14:16,800
see if the pre-bootloader entry has been

00:14:16,079 --> 00:14:18,480
entered

00:14:16,800 --> 00:14:20,480
which is the very first code in bear

00:14:18,480 --> 00:14:20,959
work so this is always a nice debugging

00:14:20,480 --> 00:14:22,959
aid

00:14:20,959 --> 00:14:25,040
if something doesn't work turn on low

00:14:22,959 --> 00:14:26,079
level debugging and see if anything is

00:14:25,040 --> 00:14:28,320
printed

00:14:26,079 --> 00:14:30,399
and then we pass the device tree and the

00:14:28,320 --> 00:14:33,839
memory base and size address

00:14:30,399 --> 00:14:37,120
to the pair box entry point

00:14:33,839 --> 00:14:39,839
and we don't see an explicit

00:14:37,120 --> 00:14:40,800
base and size here because we have a

00:14:39,839 --> 00:14:43,120
macro

00:14:40,800 --> 00:14:44,320
that passes the correct base address for

00:14:43,120 --> 00:14:46,720
the soc family

00:14:44,320 --> 00:14:47,519
and that asks our sdram controller about

00:14:46,720 --> 00:14:50,800
the size

00:14:47,519 --> 00:14:52,720
so we need not specify this here so we

00:14:50,800 --> 00:14:56,800
have no duplication

00:14:52,720 --> 00:14:59,519
after that we need to add about driver

00:14:56,800 --> 00:15:01,360
or we don't need to it's optional so as

00:14:59,519 --> 00:15:02,560
soon as you have called the bear box

00:15:01,360 --> 00:15:04,959
entry function

00:15:02,560 --> 00:15:06,880
this will link in bear box proper but

00:15:04,959 --> 00:15:08,000
you this bear box proper is not bot

00:15:06,880 --> 00:15:10,160
specific in any way

00:15:08,000 --> 00:15:11,600
but you might want to have a bot driver

00:15:10,160 --> 00:15:12,639
that matches against your boards

00:15:11,600 --> 00:15:14,560
compatible

00:15:12,639 --> 00:15:15,839
to do stuff like handling hardware

00:15:14,560 --> 00:15:18,240
quirks or

00:15:15,839 --> 00:15:19,360
registering device 3 fix-ups or even

00:15:18,240 --> 00:15:21,040
modify the

00:15:19,360 --> 00:15:22,560
live unflattened device trees that's

00:15:21,040 --> 00:15:25,040
within bearbox

00:15:22,560 --> 00:15:26,320
we see an example here so we have a

00:15:25,040 --> 00:15:28,399
system on module

00:15:26,320 --> 00:15:31,279
and we match against the compatible of

00:15:28,399 --> 00:15:32,959
it and then we change the model name

00:15:31,279 --> 00:15:34,880
the model name usually comes from device

00:15:32,959 --> 00:15:36,240
tree it's a bit too long for the slide

00:15:34,880 --> 00:15:37,920
so it's made shorter here

00:15:36,240 --> 00:15:40,160
and then we register a bearbox update

00:15:37,920 --> 00:15:42,079
handler that way bearbox knows how to

00:15:40,160 --> 00:15:45,199
update itself

00:15:42,079 --> 00:15:46,800
and that looks just like any other bot

00:15:45,199 --> 00:15:49,440
driver you can have multiple

00:15:46,800 --> 00:15:51,519
and they are chosen according with the

00:15:49,440 --> 00:15:54,720
divide to the acquired device trees it's

00:15:51,519 --> 00:15:56,959
passed to bearbox

00:15:54,720 --> 00:15:58,320
then you need to tell k-config and

00:15:56,959 --> 00:16:00,720
cabled about

00:15:58,320 --> 00:16:03,040
device g the pre-boot loader and maybe

00:16:00,720 --> 00:16:04,800
our bar driver if we had at one

00:16:03,040 --> 00:16:06,320
how that looks like we see here low

00:16:04,800 --> 00:16:08,320
level.c was the name

00:16:06,320 --> 00:16:09,600
of the low-level code that's a preboot

00:16:08,320 --> 00:16:11,839
loader

00:16:09,600 --> 00:16:12,959
it's compiled to low level.o so we add

00:16:11,839 --> 00:16:16,399
that to the

00:16:12,959 --> 00:16:18,720
low level y variables same goes for

00:16:16,399 --> 00:16:21,040
the boards driver we add that to opt

00:16:18,720 --> 00:16:22,720
which are the objects for the normal

00:16:21,040 --> 00:16:25,680
pair box then we have a k

00:16:22,720 --> 00:16:27,600
config menu entry so you can select it

00:16:25,680 --> 00:16:29,600
in the menu config

00:16:27,600 --> 00:16:30,959
and then we tell bearbox to descend in

00:16:29,600 --> 00:16:33,279
the site directory

00:16:30,959 --> 00:16:35,040
and to build the device tree by default

00:16:33,279 --> 00:16:37,759
everything is linked until by box

00:16:35,040 --> 00:16:38,720
and at least time stuff is discarded

00:16:37,759 --> 00:16:40,480
that's not needed

00:16:38,720 --> 00:16:42,079
so there is no problem in having

00:16:40,480 --> 00:16:44,240
multiple device trees built

00:16:42,079 --> 00:16:47,360
we can just pick and choose what we

00:16:44,240 --> 00:16:47,360
actually want to use

00:16:47,440 --> 00:16:54,720
and now that we have done this we have a

00:16:51,360 --> 00:16:56,959
need for an image to contain all of this

00:16:54,720 --> 00:16:59,600
and that's how it looks like it looks a

00:16:56,959 --> 00:17:02,320
little a bit like boilerplate and

00:16:59,600 --> 00:17:04,000
indeed it is you are best served by

00:17:02,320 --> 00:17:04,959
checking what other boards are doing for

00:17:04,000 --> 00:17:08,640
your sscs

00:17:04,959 --> 00:17:11,199
and just copying that but to explain

00:17:08,640 --> 00:17:13,280
succinctly what we are doing here we are

00:17:11,199 --> 00:17:14,160
adding a new entry point to the list of

00:17:13,280 --> 00:17:16,000
pbls

00:17:14,160 --> 00:17:17,360
then we give the new image a name and we

00:17:16,000 --> 00:17:19,760
give it a format to use

00:17:17,360 --> 00:17:20,799
the format here is a dot stm32 there is

00:17:19,760 --> 00:17:23,679
a rule above

00:17:20,799 --> 00:17:24,319
that's called external tool that will

00:17:23,679 --> 00:17:26,959
format

00:17:24,319 --> 00:17:28,160
our bear box binary by prefixing it with

00:17:26,959 --> 00:17:31,200
a header

00:17:28,160 --> 00:17:33,200
and that's what the fsbl is expecting of

00:17:31,200 --> 00:17:33,840
us and now that you have done all of

00:17:33,200 --> 00:17:36,160
this

00:17:33,840 --> 00:17:37,840
you can restart the bear box build

00:17:36,160 --> 00:17:40,080
process by typing make

00:17:37,840 --> 00:17:41,760
with the appropriate variables set

00:17:40,080 --> 00:17:43,360
barebox will prompt you for the new

00:17:41,760 --> 00:17:45,360
board which you can accept

00:17:43,360 --> 00:17:47,520
then it will build a new barebox proper

00:17:45,360 --> 00:17:49,120
because you have changed barebox itself

00:17:47,520 --> 00:17:51,120
by adding a bot driver

00:17:49,120 --> 00:17:53,360
and then it will take that barebox

00:17:51,120 --> 00:17:54,080
proper and link it once with every

00:17:53,360 --> 00:17:57,520
enabled

00:17:54,080 --> 00:18:01,200
board and that resulting image

00:17:57,520 --> 00:18:04,160
you can put on your boot medium and have

00:18:01,200 --> 00:18:04,559
fsbl run it and when you do that you

00:18:04,160 --> 00:18:07,679
should

00:18:04,559 --> 00:18:11,200
see something like that so you have

00:18:07,679 --> 00:18:12,799
uh here a bear box bootlock you will see

00:18:11,200 --> 00:18:14,720
that it by default fails

00:18:12,799 --> 00:18:16,160
because it will try to network boot if

00:18:14,720 --> 00:18:19,440
nothing is else is

00:18:16,160 --> 00:18:22,559
configured uh it will try here to boot

00:18:19,440 --> 00:18:24,400
a username which is none dash linux

00:18:22,559 --> 00:18:26,720
hostname of the device which comes from

00:18:24,400 --> 00:18:28,480
the device tree and understandably this

00:18:26,720 --> 00:18:31,520
is not available over tftp

00:18:28,480 --> 00:18:34,000
yet so it will just fail and tell us

00:18:31,520 --> 00:18:36,559
that nothing bootable has been found

00:18:34,000 --> 00:18:38,240
which brings us to the next part how can

00:18:36,559 --> 00:18:41,039
i customize bearbox

00:18:38,240 --> 00:18:41,600
so for example the username is not none

00:18:41,039 --> 00:18:45,679
but

00:18:41,600 --> 00:18:47,039
my initials this is done in barebox via

00:18:45,679 --> 00:18:49,760
the environment

00:18:47,039 --> 00:18:50,640
we have already seen k config which can

00:18:49,760 --> 00:18:52,640
be used

00:18:50,640 --> 00:18:55,200
for configuration but the problem with

00:18:52,640 --> 00:18:56,880
cave config is that it's global in scope

00:18:55,200 --> 00:18:58,799
and you can't do bot specific

00:18:56,880 --> 00:19:01,120
configuration in it

00:18:58,799 --> 00:19:02,640
because that would break multi-image so

00:19:01,120 --> 00:19:05,039
if you have your 100 bots

00:19:02,640 --> 00:19:05,679
they surely don't all boot from the same

00:19:05,039 --> 00:19:08,880
mmc

00:19:05,679 --> 00:19:11,039
for example so you can just put this

00:19:08,880 --> 00:19:12,160
into the k config and the solution in

00:19:11,039 --> 00:19:13,120
barebox for that is a built-in

00:19:12,160 --> 00:19:14,880
environment

00:19:13,120 --> 00:19:16,640
you have a default environment we see

00:19:14,880 --> 00:19:17,440
that to the right so the default

00:19:16,640 --> 00:19:20,559
environment

00:19:17,440 --> 00:19:22,640
is a directory structure indeed every

00:19:20,559 --> 00:19:24,080
environment is that can contain boot

00:19:22,640 --> 00:19:26,640
scripts or

00:19:24,080 --> 00:19:28,320
binaries that can be loaded some data

00:19:26,640 --> 00:19:28,799
some init scripts that are automatically

00:19:28,320 --> 00:19:31,360
loaded

00:19:28,799 --> 00:19:32,559
and some default non-volatile variables

00:19:31,360 --> 00:19:35,520
which we see

00:19:32,559 --> 00:19:37,280
at the very end since there is a feature

00:19:35,520 --> 00:19:39,200
specific environment that's overlaid on

00:19:37,280 --> 00:19:40,160
top for example if you have device

00:19:39,200 --> 00:19:43,039
firmware upgrade

00:19:40,160 --> 00:19:44,240
enabled it can add you some scripts that

00:19:43,039 --> 00:19:46,880
are specific to that

00:19:44,240 --> 00:19:48,000
usb feature you can have board specific

00:19:46,880 --> 00:19:51,440
environment

00:19:48,000 --> 00:19:52,880
so each board can in the make file for

00:19:51,440 --> 00:19:56,080
in support directory

00:19:52,880 --> 00:19:57,520
can say bbn and add a new directory

00:19:56,080 --> 00:20:00,799
that's overlay that can

00:19:57,520 --> 00:20:02,720
then be overlaid on top and you can have

00:20:00,799 --> 00:20:06,080
an external environment which you will

00:20:02,720 --> 00:20:07,760
usually use if you have a bsp

00:20:06,080 --> 00:20:09,760
and you are using the same environment

00:20:07,760 --> 00:20:11,360
for different boards so bailbox can be

00:20:09,760 --> 00:20:14,720
just told in the k config

00:20:11,360 --> 00:20:15,760
use this directory for an environment

00:20:14,720 --> 00:20:19,280
that's overlaid

00:20:15,760 --> 00:20:21,360
at the very end and

00:20:19,280 --> 00:20:22,480
this environment is built in it's built

00:20:21,360 --> 00:20:25,120
into bearbox

00:20:22,480 --> 00:20:26,400
and at runtime barebox will mount it

00:20:25,120 --> 00:20:28,880
under slash n

00:20:26,400 --> 00:20:30,320
and from there on bot code and init

00:20:28,880 --> 00:20:33,120
scripts can read write it

00:20:30,320 --> 00:20:33,520
but that's just at runtime persistence

00:20:33,120 --> 00:20:36,720
is

00:20:33,520 --> 00:20:38,480
done separately how that look like

00:20:36,720 --> 00:20:40,559
we can see here we have these two

00:20:38,480 --> 00:20:42,799
variables autoboot and user

00:20:40,559 --> 00:20:44,640
and we set autoboot to abort so it

00:20:42,799 --> 00:20:46,880
doesn't continue booting

00:20:44,640 --> 00:20:48,000
because we are debugging and we set user

00:20:46,880 --> 00:20:49,919
to my initials

00:20:48,000 --> 00:20:51,600
biobox will tell you and the variables

00:20:49,919 --> 00:20:53,520
are modified and that

00:20:51,600 --> 00:20:55,760
they will on shutdown be saved

00:20:53,520 --> 00:20:57,280
automatically how that looks like we can

00:20:55,760 --> 00:21:00,000
do a recursive listing

00:20:57,280 --> 00:21:01,120
of the slash f directory and we will see

00:21:00,000 --> 00:21:03,280
at the very end

00:21:01,120 --> 00:21:04,880
that we now have an autoboot and a user

00:21:03,280 --> 00:21:07,919
file and these will have

00:21:04,880 --> 00:21:10,960
our new values so

00:21:07,919 --> 00:21:12,080
a variable like user that's called a

00:21:10,960 --> 00:21:13,919
magic variable

00:21:12,080 --> 00:21:16,000
they are so called because they are

00:21:13,919 --> 00:21:19,120
evaluated at different places in

00:21:16,000 --> 00:21:21,039
the bare box execution flow you can list

00:21:19,120 --> 00:21:23,600
them with a magic var command

00:21:21,039 --> 00:21:25,919
we see that below so for example there

00:21:23,600 --> 00:21:28,080
is opt arc if you do option parsing on

00:21:25,919 --> 00:21:30,240
in the shell which it will have option

00:21:28,080 --> 00:21:32,720
argument there is boot source which

00:21:30,240 --> 00:21:34,480
tells you uh where bailbot came from

00:21:32,720 --> 00:21:37,919
from example from an mmc

00:21:34,480 --> 00:21:39,679
or from usb and there are also some

00:21:37,919 --> 00:21:40,640
nifty stuff like boot and provide

00:21:39,679 --> 00:21:43,039
machine id

00:21:40,640 --> 00:21:44,000
which will have barebox fix up the

00:21:43,039 --> 00:21:46,000
global machine id

00:21:44,000 --> 00:21:47,120
which for example comes from your soc

00:21:46,000 --> 00:21:48,880
serial

00:21:47,120 --> 00:21:51,440
into the kernel command line so systemd

00:21:48,880 --> 00:21:53,360
can use it most of these magic variables

00:21:51,440 --> 00:21:55,120
we see here are global variables

00:21:53,360 --> 00:21:56,799
and these global variables will be

00:21:55,120 --> 00:21:59,039
initialized at startup

00:21:56,799 --> 00:22:00,320
from the corresponding non-volatile and

00:21:59,039 --> 00:22:03,520
v variables

00:22:00,320 --> 00:22:06,640
so if i set global user it will be just

00:22:03,520 --> 00:22:08,080
active for runtime if i set nvuser this

00:22:06,640 --> 00:22:10,559
will be saved to the

00:22:08,080 --> 00:22:11,440
non-valid non-volatile environment

00:22:10,559 --> 00:22:14,159
directory

00:22:11,440 --> 00:22:14,799
and on the next startup barebox will

00:22:14,159 --> 00:22:17,679
load

00:22:14,799 --> 00:22:18,480
the environment and check ok i have an

00:22:17,679 --> 00:22:20,960
nvuser

00:22:18,480 --> 00:22:23,600
so it will initialize global user with

00:22:20,960 --> 00:22:23,600
that value

00:22:23,679 --> 00:22:27,200
these global variables or global

00:22:25,520 --> 00:22:29,039
parameters are so called

00:22:27,200 --> 00:22:30,640
because they are associated with an

00:22:29,039 --> 00:22:33,679
abstract

00:22:30,640 --> 00:22:34,640
global device you have many more devices

00:22:33,679 --> 00:22:37,679
in bailbox

00:22:34,640 --> 00:22:42,480
and every device driver can associate

00:22:37,679 --> 00:22:44,640
these device parameters with the devices

00:22:42,480 --> 00:22:46,480
yeah and that's the way you do runtime

00:22:44,640 --> 00:22:49,440
configuration in barebox

00:22:46,480 --> 00:22:50,559
so how that looks like we can see to the

00:22:49,440 --> 00:22:53,120
left

00:22:50,559 --> 00:22:54,320
below we have a device it's called temp

00:22:53,120 --> 00:22:57,600
reboot mode

00:22:54,320 --> 00:22:59,280
this device driver the driver for this

00:22:57,600 --> 00:23:01,520
device is syscon reboot mode which was

00:22:59,280 --> 00:23:04,240
basically just ported over from linux

00:23:01,520 --> 00:23:04,720
it does parsing of device three nodes

00:23:04,240 --> 00:23:08,240
that we

00:23:04,720 --> 00:23:10,159
see here this device 3 node has

00:23:08,240 --> 00:23:12,240
some modes for example normal loader

00:23:10,159 --> 00:23:14,880
fastboot and each has a value

00:23:12,240 --> 00:23:16,159
and if you set this reboot mode it

00:23:14,880 --> 00:23:19,840
writes that value

00:23:16,159 --> 00:23:22,880
at the identified offset in register

00:23:19,840 --> 00:23:25,440
and that way the operating system

00:23:22,880 --> 00:23:26,880
can return some value to the bootloader

00:23:25,440 --> 00:23:30,559
so it customizes the

00:23:26,880 --> 00:23:34,159
next boot the driver is as i said just

00:23:30,559 --> 00:23:36,480
put it from linux and it adds some

00:23:34,159 --> 00:23:38,400
airbox-specific stuff like this death at

00:23:36,480 --> 00:23:40,400
palm enums that we see to the right

00:23:38,400 --> 00:23:42,640
this registers a parameter of type

00:23:40,400 --> 00:23:44,400
enumeration with the name next

00:23:42,640 --> 00:23:46,080
that should call our callback whenever

00:23:44,400 --> 00:23:46,799
it's set and it has these possible

00:23:46,080 --> 00:23:49,200
values

00:23:46,799 --> 00:23:51,200
we see that in the def info input so

00:23:49,200 --> 00:23:53,520
next has current value of normal

00:23:51,200 --> 00:23:56,000
it has a type enumeration and it has

00:23:53,520 --> 00:23:57,760
these possible values

00:23:56,000 --> 00:23:59,520
and then as soon as we have registered

00:23:57,760 --> 00:24:00,400
this parameter we can interact with it

00:23:59,520 --> 00:24:02,799
from the shell

00:24:00,400 --> 00:24:03,520
so we can echo it which we are doing

00:24:02,799 --> 00:24:05,520
here

00:24:03,520 --> 00:24:06,960
and we see okay the previous value was

00:24:05,520 --> 00:24:09,279
normal we can set it

00:24:06,960 --> 00:24:10,240
which we'll call our callback and then

00:24:09,279 --> 00:24:12,320
we can do a reset

00:24:10,240 --> 00:24:14,000
on the next reset bar box should see

00:24:12,320 --> 00:24:19,840
okay i am

00:24:14,000 --> 00:24:19,840
now having the reboot mode of fastboot

00:24:20,159 --> 00:24:23,360
let's see how we can tie that all

00:24:21,440 --> 00:24:26,000
together you can

00:24:23,360 --> 00:24:28,080
so far have seen that we can do that on

00:24:26,000 --> 00:24:31,120
the shell we can on the shell

00:24:28,080 --> 00:24:33,520
set variables read the value out of them

00:24:31,120 --> 00:24:35,279
but often you will want to write scripts

00:24:33,520 --> 00:24:36,720
you can do that with hush which is a

00:24:35,279 --> 00:24:39,840
default shell in bear box

00:24:36,720 --> 00:24:42,080
you can add hush scripts to slash m bin

00:24:39,840 --> 00:24:44,640
and from there on they are in the path

00:24:42,080 --> 00:24:46,559
so you can just tap complete to get them

00:24:44,640 --> 00:24:48,559
and they can interact with the variables

00:24:46,559 --> 00:24:50,080
that we have seen there are also some

00:24:48,559 --> 00:24:53,600
core shell utilities like

00:24:50,080 --> 00:24:57,360
cad echo memory display memory rights

00:24:53,600 --> 00:24:58,640
so you can modify the variables and also

00:24:57,360 --> 00:25:00,400
the character devices that we

00:24:58,640 --> 00:25:02,640
see to the right so you have different

00:25:00,400 --> 00:25:04,799
character devices for example for eproms

00:25:02,640 --> 00:25:06,559
or headwear and the hardware random

00:25:04,799 --> 00:25:10,159
number generators

00:25:06,559 --> 00:25:11,919
that you can interact with and you can

00:25:10,159 --> 00:25:13,840
have init scripts that are run

00:25:11,919 --> 00:25:14,880
automatically for example slash and

00:25:13,840 --> 00:25:17,279
slash init

00:25:14,880 --> 00:25:18,080
everything run in the directory will be

00:25:17,279 --> 00:25:20,159
automatic

00:25:18,080 --> 00:25:21,600
everything located in that directory

00:25:20,159 --> 00:25:24,559
will be run automatically

00:25:21,600 --> 00:25:26,159
we have seen that reboot mode before how

00:25:24,559 --> 00:25:28,640
that works is that

00:25:26,159 --> 00:25:30,240
it will source slash and slash b mode

00:25:28,640 --> 00:25:32,559
global reboot mode pref

00:25:30,240 --> 00:25:33,360
which is what is written in that

00:25:32,559 --> 00:25:36,480
register

00:25:33,360 --> 00:25:37,760
on startup so that way we can define a

00:25:36,480 --> 00:25:41,520
fastboot boot mode

00:25:37,760 --> 00:25:45,039
if we would like and at the end we can

00:25:41,520 --> 00:25:46,240
also have boot scripts which customize

00:25:45,039 --> 00:25:48,480
how bailbox should boot

00:25:46,240 --> 00:25:49,679
we see here an example bootscript it's

00:25:48,480 --> 00:25:53,760
called mmc

00:25:49,679 --> 00:25:56,559
it's opened in bearbox code editor and

00:25:53,760 --> 00:25:58,480
we see what it's doing it's that it's

00:25:56,559 --> 00:26:00,559
checking if and reboot default is set

00:25:58,480 --> 00:26:03,120
if so there has been an override so just

00:26:00,559 --> 00:26:05,279
exit and then it checks if the boots

00:26:03,120 --> 00:26:06,880
is from mmc then it says screw will both

00:26:05,279 --> 00:26:09,760
default to be mmc

00:26:06,880 --> 00:26:11,120
with bootsource instance.concatenated so

00:26:09,760 --> 00:26:13,120
what this is basically doing

00:26:11,120 --> 00:26:14,720
is that it says if i am coming from an

00:26:13,120 --> 00:26:17,520
sd card

00:26:14,720 --> 00:26:19,200
boot try to boot the root partition on

00:26:17,520 --> 00:26:19,679
that sd card so partition that's called

00:26:19,200 --> 00:26:22,000
boot

00:26:19,679 --> 00:26:23,200
and if i come from another sd card or

00:26:22,000 --> 00:26:26,320
from my mmc

00:26:23,200 --> 00:26:28,400
use set one root partition instead

00:26:26,320 --> 00:26:29,600
so these are just a few lines of code

00:26:28,400 --> 00:26:33,279
which you can do

00:26:29,600 --> 00:26:36,480
a bit more complex setup easily with

00:26:33,279 --> 00:26:36,960
so let's see how we can use that all for

00:26:36,480 --> 00:26:39,039
boot

00:26:36,960 --> 00:26:40,559
so bearbox has boot command which is the

00:26:39,039 --> 00:26:43,919
default entry point

00:26:40,559 --> 00:26:46,799
for booting and as you see it has

00:26:43,919 --> 00:26:48,240
a big help text because it's a very

00:26:46,799 --> 00:26:51,039
versatile tool

00:26:48,240 --> 00:26:52,400
so instead of using a boot script like

00:26:51,039 --> 00:26:55,440
we have just seen before

00:26:52,400 --> 00:26:55,840
let's take a step back and ask ourselves

00:26:55,440 --> 00:26:58,080
what

00:26:55,840 --> 00:26:59,840
is it what we want from the booting

00:26:58,080 --> 00:27:03,440
process how should it look like

00:26:59,840 --> 00:27:07,120
and then we can see how we can use boot

00:27:03,440 --> 00:27:09,279
best so

00:27:07,120 --> 00:27:11,200
if you have a root fs partition and that

00:27:09,279 --> 00:27:11,919
root fs partition has a slash boots

00:27:11,200 --> 00:27:14,159
directory

00:27:11,919 --> 00:27:16,559
and that slash boot directory also

00:27:14,159 --> 00:27:19,840
already has a kernel a device tree

00:27:16,559 --> 00:27:21,039
init rd device 3 overlays boot arguments

00:27:19,840 --> 00:27:24,240
it has all these stuff

00:27:21,039 --> 00:27:26,880
in a single place you shouldn't need

00:27:24,240 --> 00:27:28,080
any bootloader configuration now because

00:27:26,880 --> 00:27:30,320
it's all there

00:27:28,080 --> 00:27:32,080
at most what you need is a file that

00:27:30,320 --> 00:27:34,080
describes which kernel to choose which

00:27:32,080 --> 00:27:36,000
device three which boot arguments

00:27:34,080 --> 00:27:37,200
and that file you can place on the boot

00:27:36,000 --> 00:27:39,200
partition itself

00:27:37,200 --> 00:27:41,039
and then the bootloader doesn't need any

00:27:39,200 --> 00:27:42,720
extra info it should detect everything

00:27:41,039 --> 00:27:44,080
else as soon as it knows which partition

00:27:42,720 --> 00:27:47,039
is it it is

00:27:44,080 --> 00:27:48,080
so memory layout you don't need to tell

00:27:47,039 --> 00:27:49,919
the bootloader

00:27:48,080 --> 00:27:51,919
where should the kernel be located or

00:27:49,919 --> 00:27:54,799
where should the device tree be located

00:27:51,919 --> 00:27:57,919
you just need these image buffers to be

00:27:54,799 --> 00:27:59,360
correctly aligned to be non-overlapping

00:27:57,919 --> 00:28:01,120
and the bootloader can already

00:27:59,360 --> 00:28:02,240
dynamically determine that so no need to

00:28:01,120 --> 00:28:03,600
hard code it

00:28:02,240 --> 00:28:05,360
you shouldn't need to tell the

00:28:03,600 --> 00:28:05,760
bootloader what kind of file system it

00:28:05,360 --> 00:28:08,399
is

00:28:05,760 --> 00:28:09,120
it can just check some magic signature

00:28:08,399 --> 00:28:11,760
and just

00:28:09,120 --> 00:28:12,480
mount it on the fly on first access so

00:28:11,760 --> 00:28:14,720
you don't need

00:28:12,480 --> 00:28:16,320
to do this manual step in front same

00:28:14,720 --> 00:28:19,200
goes for the image format

00:28:16,320 --> 00:28:20,720
so you could also check the magic

00:28:19,200 --> 00:28:22,159
signature of the image and call the

00:28:20,720 --> 00:28:23,679
appropriate handler

00:28:22,159 --> 00:28:25,440
and you don't want to repeat yourself

00:28:23,679 --> 00:28:26,559
your bootloader already has broad

00:28:25,440 --> 00:28:29,200
specific

00:28:26,559 --> 00:28:29,679
information for example it needs to know

00:28:29,200 --> 00:28:31,840
which

00:28:29,679 --> 00:28:33,360
root partition to use so it could

00:28:31,840 --> 00:28:36,720
generate a root

00:28:33,360 --> 00:28:38,559
root equals argument for the kernel

00:28:36,720 --> 00:28:40,559
and it knows which console to use for

00:28:38,559 --> 00:28:43,360
output so it can pass along

00:28:40,559 --> 00:28:44,080
that exact same console to the kernel so

00:28:43,360 --> 00:28:46,799
you don't want

00:28:44,080 --> 00:28:47,919
to write this again and you still need

00:28:46,799 --> 00:28:51,679
the ability to

00:28:47,919 --> 00:28:55,039
exactly specify these if needed

00:28:51,679 --> 00:28:56,399
as for the first point bearbox uses the

00:28:55,039 --> 00:28:58,760
bootloader specification

00:28:56,399 --> 00:29:00,080
which you can read the full text of on

00:28:58,760 --> 00:29:03,200
systemd.io

00:29:00,080 --> 00:29:03,840
we see here an example at a well-known

00:29:03,200 --> 00:29:05,840
location

00:29:03,840 --> 00:29:07,120
slash loader slash entries we have a

00:29:05,840 --> 00:29:08,880
couple of files

00:29:07,120 --> 00:29:10,559
and these boot spec files they have a

00:29:08,880 --> 00:29:13,440
title for using a menu

00:29:10,559 --> 00:29:14,320
they have options that are to be passed

00:29:13,440 --> 00:29:17,120
to the kernel

00:29:14,320 --> 00:29:18,399
they identify a linux binary a device

00:29:17,120 --> 00:29:21,200
tree binary

00:29:18,399 --> 00:29:22,240
and that's all the information you need

00:29:21,200 --> 00:29:25,520
so you can just

00:29:22,240 --> 00:29:28,320
tell bearbox to boot this partition

00:29:25,520 --> 00:29:28,799
barebox will mount it it will look at

00:29:28,320 --> 00:29:31,600
that

00:29:28,799 --> 00:29:33,840
directory and then it will iterate over

00:29:31,600 --> 00:29:35,679
the files there we have one file

00:29:33,840 --> 00:29:37,120
that references a device tree with a

00:29:35,679 --> 00:29:37,919
compatible that doesn't match the

00:29:37,120 --> 00:29:40,960
compatible

00:29:37,919 --> 00:29:41,679
that the box device tree has so this is

00:29:40,960 --> 00:29:43,679
ignored

00:29:41,679 --> 00:29:45,679
then it finds the correct device tree it

00:29:43,679 --> 00:29:48,799
will say that it will attempt to boot it

00:29:45,679 --> 00:29:50,799
it will fix up a root option

00:29:48,799 --> 00:29:51,840
for the kernel to use it will load this

00:29:50,799 --> 00:29:54,159
into memory

00:29:51,840 --> 00:29:55,360
and it shows you the command line at the

00:29:54,159 --> 00:29:58,320
end it will abort

00:29:55,360 --> 00:29:59,039
because here we have minus d for dry run

00:29:58,320 --> 00:30:02,159
and

00:29:59,039 --> 00:30:04,720
we see here that this root

00:30:02,159 --> 00:30:06,720
argument was never never explicitly

00:30:04,720 --> 00:30:08,720
stated in the example that we have shown

00:30:06,720 --> 00:30:10,480
this is because linux appendroot which

00:30:08,720 --> 00:30:12,240
is written in the bootspec

00:30:10,480 --> 00:30:14,640
is a bearbox extension for appending the

00:30:12,240 --> 00:30:16,799
correct route automatically

00:30:14,640 --> 00:30:18,159
this allows us to have a boot specs at

00:30:16,799 --> 00:30:21,200
storage agnostic

00:30:18,159 --> 00:30:22,960
so you could just extract what's in this

00:30:21,200 --> 00:30:24,880
partition to a network share makes this

00:30:22,960 --> 00:30:26,880
available over network file system

00:30:24,880 --> 00:30:28,799
point bearbox edit and you can boot it

00:30:26,880 --> 00:30:31,840
all the same warebox would

00:30:28,799 --> 00:30:34,880
fix up the correct route equals nfs and

00:30:31,840 --> 00:30:36,960
ip addresses and so on and

00:30:34,880 --> 00:30:38,720
that means that you just need one

00:30:36,960 --> 00:30:40,000
configuration in bear box for such a

00:30:38,720 --> 00:30:43,520
simple booting scenario

00:30:40,000 --> 00:30:46,559
which is where to get the

00:30:43,520 --> 00:30:47,120
this partition from and we see that at

00:30:46,559 --> 00:30:51,360
the

00:30:47,120 --> 00:30:53,919
very bottom we have mmc dot

00:30:51,360 --> 00:30:55,039
which is our fifth partition we start

00:30:53,919 --> 00:30:57,120
counting from zero

00:30:55,039 --> 00:30:58,399
and we just need to put this into boot

00:30:57,120 --> 00:31:00,480
default and

00:30:58,399 --> 00:31:01,760
then we are good to go bearbox will do

00:31:00,480 --> 00:31:03,760
everything we have seen here

00:31:01,760 --> 00:31:04,880
because it starts boot by default after

00:31:03,760 --> 00:31:07,760
the countdown

00:31:04,880 --> 00:31:08,640
and then it will just mount check the

00:31:07,760 --> 00:31:11,039
boot specs

00:31:08,640 --> 00:31:12,000
and then in the end puts the kernel with

00:31:11,039 --> 00:31:16,000
the specified

00:31:12,000 --> 00:31:18,159
parameters this is a very simplified

00:31:16,000 --> 00:31:21,440
boot we want in this talk to go a bit

00:31:18,159 --> 00:31:24,080
beyond just booting so let's look

00:31:21,440 --> 00:31:26,399
about a more complex booting scenarios

00:31:24,080 --> 00:31:28,559
having two root fs partitions

00:31:26,399 --> 00:31:30,240
why would you like to have two root fs

00:31:28,559 --> 00:31:33,760
partitions so we can

00:31:30,240 --> 00:31:37,440
run one boot partition and then

00:31:33,760 --> 00:31:38,399
on and on updates other partition while

00:31:37,440 --> 00:31:41,039
we are running

00:31:38,399 --> 00:31:42,399
then we can reset and before that tells

00:31:41,039 --> 00:31:43,519
the bootloader to try the other

00:31:42,399 --> 00:31:45,440
partition next time

00:31:43,519 --> 00:31:47,519
then we can boot into the next system

00:31:45,440 --> 00:31:49,039
and if that boot process fails for

00:31:47,519 --> 00:31:50,080
whatever reason we need to have a

00:31:49,039 --> 00:31:54,320
fallback

00:31:50,080 --> 00:31:57,200
so a b partitions are uniquely uh

00:31:54,320 --> 00:31:58,320
are very suitable for that and how that

00:31:57,200 --> 00:32:01,519
looks like in bear box

00:31:58,320 --> 00:32:03,519
it's we see to the left with buchuser so

00:32:01,519 --> 00:32:05,760
boo chooser can define different boot

00:32:03,519 --> 00:32:08,080
targets these two boot targets can have

00:32:05,760 --> 00:32:10,720
attempts how many times they are retried

00:32:08,080 --> 00:32:11,760
and there is automatic fallback between

00:32:10,720 --> 00:32:13,760
between them

00:32:11,760 --> 00:32:16,080
for all of this to work we will need to

00:32:13,760 --> 00:32:19,360
detect this update failure

00:32:16,080 --> 00:32:21,679
so it can revert back to the other

00:32:19,360 --> 00:32:22,559
partition and the user space needs an

00:32:21,679 --> 00:32:24,559
ability after

00:32:22,559 --> 00:32:26,720
update to say well let's try the neo

00:32:24,559 --> 00:32:28,559
partition and for that we need mutable

00:32:26,720 --> 00:32:30,640
variable storage

00:32:28,559 --> 00:32:32,559
we have the environment which could be

00:32:30,640 --> 00:32:34,399
used for that which we are already using

00:32:32,559 --> 00:32:35,679
for that during development for saving

00:32:34,399 --> 00:32:39,120
say

00:32:35,679 --> 00:32:40,880
nv variables but it's inadequate for

00:32:39,120 --> 00:32:43,039
use in production because it lacks

00:32:40,880 --> 00:32:44,480
redundancy it's not atomic

00:32:43,039 --> 00:32:47,760
and we would appreciate some other

00:32:44,480 --> 00:32:49,360
things like authorization by hmac where

00:32:47,760 --> 00:32:51,120
leveling access control

00:32:49,360 --> 00:32:52,640
so the bear box solution for that is

00:32:51,120 --> 00:32:54,559
bearbox state

00:32:52,640 --> 00:32:57,279
which is described in the device tree

00:32:54,559 --> 00:33:00,640
like the reboot mode we have seen before

00:32:57,279 --> 00:33:03,200
this has a back end

00:33:00,640 --> 00:33:05,120
this back end can be any device bearbox

00:33:03,200 --> 00:33:08,880
knows how to write to

00:33:05,120 --> 00:33:10,960
and it defines some set of variables

00:33:08,880 --> 00:33:12,799
that boot chooser can then use which can

00:33:10,960 --> 00:33:15,440
also be used for some other stuff

00:33:12,799 --> 00:33:16,240
we will uh we have a baroque state

00:33:15,440 --> 00:33:18,080
utility

00:33:16,240 --> 00:33:20,159
that allows you to access it from within

00:33:18,080 --> 00:33:23,120
the operating system so bearbox

00:33:20,159 --> 00:33:24,080
fixes up this device tree snippet into

00:33:23,120 --> 00:33:26,559
the kernels

00:33:24,080 --> 00:33:27,440
and from there on we have this bearbox

00:33:26,559 --> 00:33:29,519
state utility

00:33:27,440 --> 00:33:31,600
that can pass the device tree pass to

00:33:29,519 --> 00:33:32,880
the kernel and use udef to find the

00:33:31,600 --> 00:33:34,080
correct linux device

00:33:32,880 --> 00:33:35,919
and that's all the configurations that

00:33:34,080 --> 00:33:38,960
you need then you can

00:33:35,919 --> 00:33:42,559
just start bearbox state and

00:33:38,960 --> 00:33:44,159
you can use it to get or set variables

00:33:42,559 --> 00:33:46,000
the belvox state implementation

00:33:44,159 --> 00:33:47,360
maintains three copies for redundancy

00:33:46,000 --> 00:33:49,600
and atomicity

00:33:47,360 --> 00:33:51,919
and the crc32 for corruption detection

00:33:49,600 --> 00:33:53,919
and it says optional support for hmac

00:33:51,919 --> 00:33:56,240
where leveling by cyclically

00:33:53,919 --> 00:33:57,120
writing and it's strictly for variable

00:33:56,240 --> 00:34:00,159
storage

00:33:57,120 --> 00:34:01,840
so you don't need a mutual mutable bear

00:34:00,159 --> 00:34:03,519
box environment in the field

00:34:01,840 --> 00:34:05,360
you can leave the bear box environment

00:34:03,519 --> 00:34:08,560
built in indeed you should do that

00:34:05,360 --> 00:34:11,440
and you should just use bailbox state

00:34:08,560 --> 00:34:12,159
for the uh variables that you need to

00:34:11,440 --> 00:34:14,320
share with

00:34:12,159 --> 00:34:15,520
the user space so that way user space

00:34:14,320 --> 00:34:18,960
can't

00:34:15,520 --> 00:34:21,440
change your boot scripts for example

00:34:18,960 --> 00:34:22,000
and by mistake and it works great with

00:34:21,440 --> 00:34:24,320
rauk

00:34:22,000 --> 00:34:25,280
so there has been a talk about rauk last

00:34:24,320 --> 00:34:28,000
year

00:34:25,280 --> 00:34:29,520
uh here at the elc i have linked another

00:34:28,000 --> 00:34:33,200
talk here as well so

00:34:29,520 --> 00:34:34,960
this talk talks about using bearbox

00:34:33,200 --> 00:34:36,320
shooter with rauk specifically so if

00:34:34,960 --> 00:34:39,839
that's interesting to you

00:34:36,320 --> 00:34:41,919
you might want to check that out so

00:34:39,839 --> 00:34:44,000
how does that all look like in the end

00:34:41,919 --> 00:34:44,800
to boot a system with bear box boot

00:34:44,000 --> 00:34:47,359
chooser

00:34:44,800 --> 00:34:48,079
it's basically just configuration in the

00:34:47,359 --> 00:34:50,159
non-volatile

00:34:48,079 --> 00:34:51,359
environment that you will put for

00:34:50,159 --> 00:34:54,079
example in your bsp

00:34:51,359 --> 00:34:56,159
so it's compiled into bear box it has

00:34:54,079 --> 00:34:57,920
some stuff like auto boots timeout

00:34:56,159 --> 00:34:59,839
which is set to zero here you can still

00:34:57,920 --> 00:35:03,040
about bear box but this

00:34:59,839 --> 00:35:05,200
doesn't do a countdown it has a boot

00:35:03,040 --> 00:35:07,760
default which is boot chooser it

00:35:05,200 --> 00:35:09,760
sets up the watchdog and then boot user

00:35:07,760 --> 00:35:11,040
is configured to have this number of

00:35:09,760 --> 00:35:12,960
default attempts

00:35:11,040 --> 00:35:14,880
what when to reset attempts for example

00:35:12,960 --> 00:35:18,000
on a power on then it says

00:35:14,880 --> 00:35:20,480
which boot targets we have and how to

00:35:18,000 --> 00:35:23,200
boot each target

00:35:20,480 --> 00:35:24,320
and everything else the whole logic it's

00:35:23,200 --> 00:35:26,560
already contained in

00:35:24,320 --> 00:35:27,760
blue box boot chooser you don't need to

00:35:26,560 --> 00:35:30,560
write any

00:35:27,760 --> 00:35:33,119
scripts on your own bluetooth i can just

00:35:30,560 --> 00:35:36,000
take care of it

00:35:33,119 --> 00:35:37,119
that's the normal case sometimes you

00:35:36,000 --> 00:35:40,560
need the ability

00:35:37,119 --> 00:35:41,680
to do it another way and for that you

00:35:40,560 --> 00:35:44,000
can call boot m

00:35:41,680 --> 00:35:46,240
directly so boot collects these boot

00:35:44,000 --> 00:35:48,720
entries or runs these boot scripts

00:35:46,240 --> 00:35:49,680
or passes these boot specs and then it

00:35:48,720 --> 00:35:52,160
passes it in the

00:35:49,680 --> 00:35:54,079
end to boot m which is for booting

00:35:52,160 --> 00:35:55,359
images and you can just write your own

00:35:54,079 --> 00:35:59,040
boot scripts

00:35:55,359 --> 00:36:01,040
and specify these variables that bootm

00:35:59,040 --> 00:36:04,560
is using or called bootm yourself

00:36:01,040 --> 00:36:07,040
we see here an example bootm is used to

00:36:04,560 --> 00:36:08,000
put a file over tftp slash mount slash

00:36:07,040 --> 00:36:11,040
tftp

00:36:08,000 --> 00:36:13,520
and then you have that file name

00:36:11,040 --> 00:36:14,400
how that works is that slash mount slash

00:36:13,520 --> 00:36:17,440
tftp

00:36:14,400 --> 00:36:19,599
is an automount so whenever it's for

00:36:17,440 --> 00:36:20,800
exists the first time this command that

00:36:19,599 --> 00:36:24,400
we see here is run

00:36:20,800 --> 00:36:26,960
if up all is done so all interfaces are

00:36:24,400 --> 00:36:27,599
set up then it mounts the tftp file

00:36:26,960 --> 00:36:30,880
system

00:36:27,599 --> 00:36:33,520
at that location and this means

00:36:30,880 --> 00:36:35,520
that you can just handle this file like

00:36:33,520 --> 00:36:38,480
any other file you can copy it

00:36:35,520 --> 00:36:40,000
you can flash it on some device or you

00:36:38,480 --> 00:36:43,200
can use boot m on it which

00:36:40,000 --> 00:36:45,599
are we doing here so that's all you need

00:36:43,200 --> 00:36:47,440
to chain load bear box over the network

00:36:45,599 --> 00:36:50,160
for example

00:36:47,440 --> 00:36:51,599
this is sometimes a bit more is needed

00:36:50,160 --> 00:36:53,440
for example because you don't have an

00:36:51,599 --> 00:36:55,119
image that's just executable but it has

00:36:53,440 --> 00:36:58,079
some formats that needs to be parsed

00:36:55,119 --> 00:37:00,000
for example a u image fit image and elf

00:36:58,079 --> 00:37:01,359
and these can also be generically

00:37:00,000 --> 00:37:03,839
handled in bear box

00:37:01,359 --> 00:37:05,520
by defining a new boot m handler we see

00:37:03,839 --> 00:37:07,119
that here for this bear box image the

00:37:05,520 --> 00:37:10,320
bear box image we talked at

00:37:07,119 --> 00:37:11,920
start that it has an stm32 header and we

00:37:10,320 --> 00:37:13,200
need to skip that header to reach the

00:37:11,920 --> 00:37:16,079
executable code

00:37:13,200 --> 00:37:17,040
and that's what bearbox stm32 image

00:37:16,079 --> 00:37:19,680
handler is doing

00:37:17,040 --> 00:37:21,599
so it matches against a file type we

00:37:19,680 --> 00:37:24,400
have a file type function in barebox

00:37:21,599 --> 00:37:24,800
that checks the magic and returns a file

00:37:24,400 --> 00:37:27,359
type

00:37:24,800 --> 00:37:27,920
like the file command under linux and

00:37:27,359 --> 00:37:31,119
then

00:37:27,920 --> 00:37:31,920
associates that file type with a bootm

00:37:31,119 --> 00:37:34,160
callback

00:37:31,920 --> 00:37:35,920
that will then get a buffer and do all

00:37:34,160 --> 00:37:38,240
the necessary things so you can boot

00:37:35,920 --> 00:37:38,240
that

00:37:38,800 --> 00:37:42,160
this concludes the parts that i wanted

00:37:40,800 --> 00:37:45,760
to talk in about

00:37:42,160 --> 00:37:48,079
putting now comes a short part about

00:37:45,760 --> 00:37:50,000
bring up we have assumed so far that

00:37:48,079 --> 00:37:52,880
there are already drivers

00:37:50,000 --> 00:37:53,200
for the functionality you need and that

00:37:52,880 --> 00:37:54,720
say

00:37:53,200 --> 00:37:56,560
implement the bindings that you are

00:37:54,720 --> 00:37:58,000
using in the device tree this is not

00:37:56,560 --> 00:38:00,400
always the case

00:37:58,000 --> 00:38:01,440
uh sometimes you need to report drivers

00:38:00,400 --> 00:38:03,920
to bear box

00:38:01,440 --> 00:38:04,480
most subsystem apis were imported from

00:38:03,920 --> 00:38:07,280
linux

00:38:04,480 --> 00:38:10,160
and are occasionally kept up to date so

00:38:07,280 --> 00:38:12,960
often drivers are fairly easy to port

00:38:10,160 --> 00:38:14,320
you just need to adjust them a bit to

00:38:12,960 --> 00:38:16,320
you copy them and then

00:38:14,320 --> 00:38:17,680
you fix the compiling errors till it

00:38:16,320 --> 00:38:19,920
works then you test it

00:38:17,680 --> 00:38:21,760
this is sometimes possible for example

00:38:19,920 --> 00:38:23,839
by the remote reboot mode driver

00:38:21,760 --> 00:38:25,359
because it's mostly generic code it was

00:38:23,839 --> 00:38:27,359
very easy to port

00:38:25,359 --> 00:38:29,359
but sometimes you have more involved

00:38:27,359 --> 00:38:31,760
devices

00:38:29,359 --> 00:38:33,599
and the kernel uses interrupts for those

00:38:31,760 --> 00:38:35,440
spare box doesn't do interrupts

00:38:33,599 --> 00:38:38,000
so it can be easier to port from another

00:38:35,440 --> 00:38:41,359
bootloader that differs in api

00:38:38,000 --> 00:38:43,440
but it already has already interacts

00:38:41,359 --> 00:38:46,400
with the hardware in the way you want

00:38:43,440 --> 00:38:48,079
if you do that you will need to give

00:38:46,400 --> 00:38:49,599
special attention to some multi-image

00:38:48,079 --> 00:38:51,280
game compatibilities that you don't have

00:38:49,599 --> 00:38:54,160
when you port kernel code

00:38:51,280 --> 00:38:55,119
for example if devs in the code

00:38:54,160 --> 00:38:58,320
depending on an

00:38:55,119 --> 00:38:59,520
soc type are a big no-no because they

00:38:58,320 --> 00:39:02,400
break multi-image

00:38:59,520 --> 00:39:04,800
same goes for attribute weak which can

00:39:02,400 --> 00:39:07,200
be defined for some socs and for some

00:39:04,800 --> 00:39:08,320
soc is different you will want both of

00:39:07,200 --> 00:39:10,800
them there so

00:39:08,320 --> 00:39:11,599
it needs to be done generically clashing

00:39:10,800 --> 00:39:13,599
defines

00:39:11,599 --> 00:39:15,280
or as we talked before configuration

00:39:13,599 --> 00:39:17,200
that's globally hardcoded for example in

00:39:15,280 --> 00:39:19,839
a k config or in a make file

00:39:17,200 --> 00:39:21,599
this should all be uh configurable at

00:39:19,839 --> 00:39:24,640
runtime

00:39:21,599 --> 00:39:26,960
for example by having a

00:39:24,640 --> 00:39:28,000
p handle in the device tree to a node

00:39:26,960 --> 00:39:30,480
that you can use

00:39:28,000 --> 00:39:31,920
or by checking what's the compatible of

00:39:30,480 --> 00:39:35,359
the device tree

00:39:31,920 --> 00:39:38,560
node and choosing one or the other

00:39:35,359 --> 00:39:42,000
callback and if all fails you can

00:39:38,560 --> 00:39:43,440
try to roll your own and

00:39:42,000 --> 00:39:45,920
if you need it in the kernel you can pot

00:39:43,440 --> 00:39:45,920
it later

00:39:46,320 --> 00:39:51,520
when you have your driver ready

00:39:49,359 --> 00:39:52,400
you will usually get the shell access

00:39:51,520 --> 00:39:54,560
out of the box

00:39:52,400 --> 00:39:56,000
because the driver cores that you are

00:39:54,560 --> 00:39:59,119
programming against

00:39:56,000 --> 00:40:00,480
already do have character devices that

00:39:59,119 --> 00:40:02,960
say allocate for

00:40:00,480 --> 00:40:05,440
io memory eproms block device partitions

00:40:02,960 --> 00:40:07,119
otps net consoles reg maps fis

00:40:05,440 --> 00:40:09,040
so you just need to implement the same

00:40:07,119 --> 00:40:10,160
api that's the driver is already

00:40:09,040 --> 00:40:12,240
implementing

00:40:10,160 --> 00:40:13,520
under linux to have it integrate with

00:40:12,240 --> 00:40:15,440
barebox

00:40:13,520 --> 00:40:17,520
you also have commands for device stream

00:40:15,440 --> 00:40:19,359
manipulation here is a nice example

00:40:17,520 --> 00:40:20,560
imagine you have a board in your remote

00:40:19,359 --> 00:40:24,400
lab and

00:40:20,560 --> 00:40:28,000
lever got broken for the for the sd card

00:40:24,400 --> 00:40:29,680
you can just run this snippet

00:40:28,000 --> 00:40:31,520
and it will create a new init script and

00:40:29,680 --> 00:40:35,839
persist it and that

00:40:31,520 --> 00:40:39,040
says for the multimedia

00:40:35,839 --> 00:40:40,720
multimedia cards zero with that's an

00:40:39,040 --> 00:40:43,040
alias so it looks upset alias in the

00:40:40,720 --> 00:40:45,119
device tree and says for mmc zero

00:40:43,040 --> 00:40:46,240
set a neo property as a fix up that's

00:40:45,119 --> 00:40:48,480
broken cd

00:40:46,240 --> 00:40:50,480
what this line is doing is that every

00:40:48,480 --> 00:40:51,359
time you boot a kernel with this inner

00:40:50,480 --> 00:40:53,839
script active

00:40:51,359 --> 00:40:55,520
it will fix up a broken cd property into

00:40:53,839 --> 00:40:57,359
the identified

00:40:55,520 --> 00:40:58,720
device tree node and then the kernel

00:40:57,359 --> 00:41:01,280
won't just wait

00:40:58,720 --> 00:41:02,800
for an interrupt that will never come

00:41:01,280 --> 00:41:04,880
because your

00:41:02,800 --> 00:41:07,119
card detect lever on the sd card is

00:41:04,880 --> 00:41:08,800
broken there are also useful defaults

00:41:07,119 --> 00:41:09,520
for netboot as we have seen before that

00:41:08,800 --> 00:41:11,440
factor in

00:41:09,520 --> 00:41:14,079
your username and the hostname of the

00:41:11,440 --> 00:41:14,880
board and that's very nice if you share

00:41:14,079 --> 00:41:17,040
the same

00:41:14,880 --> 00:41:18,880
board between different developers

00:41:17,040 --> 00:41:21,119
usually all you need to do

00:41:18,880 --> 00:41:22,720
for net booting and unconfigured bot is

00:41:21,119 --> 00:41:24,400
just setting your username

00:41:22,720 --> 00:41:26,400
and if you have the file at the correct

00:41:24,400 --> 00:41:28,400
location you can just boot

00:41:26,400 --> 00:41:31,280
you don't need to do any further

00:41:28,400 --> 00:41:33,359
modification to your bootloader

00:41:31,280 --> 00:41:34,720
if you are doing a bring up and you

00:41:33,359 --> 00:41:36,880
don't have yet network

00:41:34,720 --> 00:41:38,880
because network for example hasn't been

00:41:36,880 --> 00:41:42,000
ported yet to barebox the driver for it

00:41:38,880 --> 00:41:43,680
you can also do it over serial red fs

00:41:42,000 --> 00:41:44,240
allows reliable communication over

00:41:43,680 --> 00:41:47,040
serial

00:41:44,240 --> 00:41:49,680
there is an rfc for that and bearbox

00:41:47,040 --> 00:41:51,520
implements it as a file system

00:41:49,680 --> 00:41:53,280
and it allows you to mount host

00:41:51,520 --> 00:41:56,480
directories over

00:41:53,280 --> 00:41:58,560
serial so you can use that for net

00:41:56,480 --> 00:42:00,640
booting

00:41:58,560 --> 00:42:02,000
there are many more commands we don't

00:42:00,640 --> 00:42:05,200
have enough time to talk

00:42:02,000 --> 00:42:07,119
about all commands so there is

00:42:05,200 --> 00:42:09,440
some image to the left to the left which

00:42:07,119 --> 00:42:11,119
i hope is some sort of raw check image

00:42:09,440 --> 00:42:12,640
which you will look at and see the

00:42:11,119 --> 00:42:14,160
commands that you most desire

00:42:12,640 --> 00:42:16,319
if that doesn't work for you you can run

00:42:14,160 --> 00:42:18,319
the help command that will show you

00:42:16,319 --> 00:42:20,000
which commands are in bear box and call

00:42:18,319 --> 00:42:21,119
help with an argument to see what the

00:42:20,000 --> 00:42:22,960
commands are doing

00:42:21,119 --> 00:42:25,280
this help text is also mechanically

00:42:22,960 --> 00:42:28,319
extracted into sphinx stocks that you

00:42:25,280 --> 00:42:31,359
can review online

00:42:28,319 --> 00:42:32,160
if you don't find the command you are

00:42:31,359 --> 00:42:35,119
looking for

00:42:32,160 --> 00:42:36,000
it might be not there yet bearbox has a

00:42:35,119 --> 00:42:38,400
nice api

00:42:36,000 --> 00:42:40,240
for defining your own commands which is

00:42:38,400 --> 00:42:42,400
basically a bosex-like

00:42:40,240 --> 00:42:44,240
programming environment which means you

00:42:42,400 --> 00:42:45,920
have device files you can open them you

00:42:44,240 --> 00:42:46,800
get file descriptors out of them you can

00:42:45,920 --> 00:42:49,200
read and write

00:42:46,800 --> 00:42:50,880
to them which makes users-based code for

00:42:49,200 --> 00:42:54,480
example out of busybox

00:42:50,880 --> 00:42:56,560
easier to port you also have a kernel

00:42:54,480 --> 00:42:58,079
api available so you can control gpios

00:42:56,560 --> 00:43:00,560
handle sbi transfers

00:42:58,079 --> 00:43:02,480
you have dedicated commands for each of

00:43:00,560 --> 00:43:06,240
them but for example if you have

00:43:02,480 --> 00:43:08,160
a protocol that does sbi and uses gpio

00:43:06,240 --> 00:43:09,920
for flow control and you would like

00:43:08,160 --> 00:43:11,440
to interact with it for debugging you

00:43:09,920 --> 00:43:14,240
could just do that

00:43:11,440 --> 00:43:15,280
normally we see an example here that's a

00:43:14,240 --> 00:43:18,079
true command

00:43:15,280 --> 00:43:20,240
which doesn't do much it has an alias so

00:43:18,079 --> 00:43:23,359
it can be invoked by two different names

00:43:20,240 --> 00:43:25,359
it has an empty completion you can have

00:43:23,359 --> 00:43:26,800
completion for file names for device

00:43:25,359 --> 00:43:29,359
tree nodes for device

00:43:26,800 --> 00:43:31,040
for device names but true needs nothing

00:43:29,359 --> 00:43:32,560
offset so it defines it as an empty

00:43:31,040 --> 00:43:34,319
completion

00:43:32,560 --> 00:43:36,480
and it doesn't do much does so

00:43:34,319 --> 00:43:38,240
successfully there are many more

00:43:36,480 --> 00:43:41,839
examples in the barebox commands

00:43:38,240 --> 00:43:41,839
directory that you can check out

00:43:42,079 --> 00:43:47,440
this concludes my talk this is

00:43:45,200 --> 00:43:49,200
the last slide where i will talk a bit

00:43:47,440 --> 00:43:50,000
about recent developments in the last

00:43:49,200 --> 00:43:52,319
two years

00:43:50,000 --> 00:43:54,000
so bearbox has gained some architecture

00:43:52,319 --> 00:43:58,240
support for example for the imx

00:43:54,000 --> 00:43:59,520
8mm queue and plus the arm 64 layerscape

00:43:58,240 --> 00:44:03,200
is also supported both

00:43:59,520 --> 00:44:05,119
are socs from nxp risk 5 support initial

00:44:03,200 --> 00:44:08,160
support for that was merged upstream

00:44:05,119 --> 00:44:09,520
the stm32mp1 which we have looked at a

00:44:08,160 --> 00:44:11,680
bit here in the talk

00:44:09,520 --> 00:44:12,560
has also made it into bear box the calri

00:44:11,680 --> 00:44:16,000
mppa

00:44:12,560 --> 00:44:19,040
was merged and a bit late to the party

00:44:16,000 --> 00:44:20,640
bear box now has raspberry pi 3 support

00:44:19,040 --> 00:44:22,240
we don't yet have raspberry pi for

00:44:20,640 --> 00:44:24,160
support if that's something

00:44:22,240 --> 00:44:25,520
that interests you and you would like to

00:44:24,160 --> 00:44:27,839
learn more about bearbox

00:44:25,520 --> 00:44:28,800
that could be something you could try to

00:44:27,839 --> 00:44:30,960
get

00:44:28,800 --> 00:44:32,640
acquainted with sparebox we also now

00:44:30,960 --> 00:44:35,359
have the ability to root

00:44:32,640 --> 00:44:36,079
to read ubud variables the ubit

00:44:35,359 --> 00:44:38,319
environment

00:44:36,079 --> 00:44:39,920
this was last possible 10 years ago now

00:44:38,319 --> 00:44:40,880
there is a proper bare box driver for

00:44:39,920 --> 00:44:43,599
that that can

00:44:40,880 --> 00:44:44,800
that allows you to mount the environment

00:44:43,599 --> 00:44:48,319
as a file system

00:44:44,800 --> 00:44:50,960
and interact with it we

00:44:48,319 --> 00:44:52,880
can now load opti and also do early

00:44:50,960 --> 00:44:55,920
loading of opti for example

00:44:52,880 --> 00:44:57,280
if you need to load opti out of the ppl

00:44:55,920 --> 00:45:00,400
to reduce your attack surface

00:44:57,280 --> 00:45:02,079
this can now be done on some systems uh

00:45:00,400 --> 00:45:04,079
the kernel address sanitizer and address

00:45:02,079 --> 00:45:07,359
sanitizers are now supported

00:45:04,079 --> 00:45:09,280
so gcc and clang support in

00:45:07,359 --> 00:45:12,480
compile time instrumentation of your

00:45:09,280 --> 00:45:15,440
code to catch memory safety issues

00:45:12,480 --> 00:45:15,920
and this expects your code to cooperate

00:45:15,440 --> 00:45:18,319
with it

00:45:15,920 --> 00:45:20,640
in that it's the allocator poisons

00:45:18,319 --> 00:45:22,240
memory that is freed and unpoisons

00:45:20,640 --> 00:45:24,720
memory when it allocates it

00:45:22,240 --> 00:45:25,440
so you can detect stuff like use after

00:45:24,720 --> 00:45:28,480
freeze

00:45:25,440 --> 00:45:30,160
this is now possible on arm32 arm 64. it

00:45:28,480 --> 00:45:31,680
was possible on sandbox before that

00:45:30,160 --> 00:45:33,760
because there is already

00:45:31,680 --> 00:45:34,960
leap address sanitizer this can be

00:45:33,760 --> 00:45:36,800
readily used

00:45:34,960 --> 00:45:39,119
undefined behavior sanitizer is now also

00:45:36,800 --> 00:45:41,200
supported and you can compile large

00:45:39,119 --> 00:45:43,599
parts of barebox under sandbox

00:45:41,200 --> 00:45:46,720
for compile testing and for running a

00:45:43,599 --> 00:45:49,520
static analysis of our barebox

00:45:46,720 --> 00:45:51,040
device 3 overlays are supported dprobe

00:45:49,520 --> 00:45:53,200
is not yet in barebox

00:45:51,040 --> 00:45:54,960
but it's doing its final labs on the

00:45:53,200 --> 00:45:56,640
mailing list so it might very well be by

00:45:54,960 --> 00:45:58,640
the time you see this talk

00:45:56,640 --> 00:46:01,040
it's a feature i'm very excited about

00:45:58,640 --> 00:46:01,760
because it allows us to get rid of this

00:46:01,040 --> 00:46:04,400
init call

00:46:01,760 --> 00:46:05,359
shuffling and e-probe defer that we have

00:46:04,400 --> 00:46:08,240
in bear box

00:46:05,359 --> 00:46:09,040
so a kernel driver if that can't get a

00:46:08,240 --> 00:46:11,920
resource

00:46:09,040 --> 00:46:13,599
returns eproptifier and then it's

00:46:11,920 --> 00:46:16,079
retried at a later time

00:46:13,599 --> 00:46:17,040
what dprobe does is that it recursively

00:46:16,079 --> 00:46:19,760
on demand

00:46:17,040 --> 00:46:20,800
will probe the devices that offer the

00:46:19,760 --> 00:46:23,920
resources that you

00:46:20,800 --> 00:46:26,880
are needing work queues and slices

00:46:23,920 --> 00:46:28,400
also made their way into bear box so so

00:46:26,880 --> 00:46:31,200
far you could have polars

00:46:28,400 --> 00:46:31,760
these polars can for example flash a

00:46:31,200 --> 00:46:35,200
heartbeat

00:46:31,760 --> 00:46:38,079
led or feed a watchdog and they are cold

00:46:35,200 --> 00:46:41,040
whenever you do a delay in bear box

00:46:38,079 --> 00:46:41,599
this works nicely for this simple stuff

00:46:41,040 --> 00:46:43,920
but

00:46:41,599 --> 00:46:44,720
for example if you need to pull for utp

00:46:43,920 --> 00:46:47,520
packets

00:46:44,720 --> 00:46:49,680
you can't reliably do that in apollo

00:46:47,520 --> 00:46:52,720
because if your device

00:46:49,680 --> 00:46:55,119
driver for the network interface for the

00:46:52,720 --> 00:46:57,680
network chip does itself use a delay you

00:46:55,119 --> 00:47:00,480
have a nasty recursion going on

00:46:57,680 --> 00:47:01,280
so what happens with slices is that you

00:47:00,480 --> 00:47:04,160
can say

00:47:01,280 --> 00:47:04,960
i would like to have the network slices

00:47:04,160 --> 00:47:07,920
network slice

00:47:04,960 --> 00:47:09,680
in the network stack and then if apollo

00:47:07,920 --> 00:47:11,520
needs a network slice it will

00:47:09,680 --> 00:47:13,440
try to claim it and if it can't it will

00:47:11,520 --> 00:47:15,440
just return and will be treated right at

00:47:13,440 --> 00:47:16,480
a later time at which it can do stuff

00:47:15,440 --> 00:47:20,079
over the network

00:47:16,480 --> 00:47:23,760
work cues are a

00:47:20,079 --> 00:47:25,200
way to schedule work items that are run

00:47:23,760 --> 00:47:26,720
in the context of the chain

00:47:25,200 --> 00:47:28,480
and in the context of the shell you can

00:47:26,720 --> 00:47:31,280
basically do everything

00:47:28,480 --> 00:47:32,400
and everything is currently that bearbox

00:47:31,280 --> 00:47:34,480
answers icmp

00:47:32,400 --> 00:47:37,040
echo requests so now you can quite

00:47:34,480 --> 00:47:39,440
quickly reply to pings in bellworks

00:47:37,040 --> 00:47:40,319
and fastboot over udp is now also

00:47:39,440 --> 00:47:43,440
supported

00:47:40,319 --> 00:47:45,359
via this workq mechanism

00:47:43,440 --> 00:47:47,200
so if that all got you interested you

00:47:45,359 --> 00:47:49,760
can check the bailbox project home

00:47:47,200 --> 00:47:51,599
at bearbox.org we are doing the

00:47:49,760 --> 00:47:52,720
collaboration of a mailing list hosted

00:47:51,599 --> 00:47:55,119
by infrared

00:47:52,720 --> 00:47:56,160
so if you have patches or questions you

00:47:55,119 --> 00:47:58,000
can ask there

00:47:56,160 --> 00:47:59,359
a public service announcement if reddit

00:47:58,000 --> 00:48:01,920
had an outage

00:47:59,359 --> 00:48:04,319
so if you were subscribed or

00:48:01,920 --> 00:48:06,400
unsubscribed this might have been reset

00:48:04,319 --> 00:48:08,079
so you might want to check that out we

00:48:06,400 --> 00:48:10,400
are also an irc

00:48:08,079 --> 00:48:12,960
if you prefer that and if you don't have

00:48:10,400 --> 00:48:13,280
a raspberry pi 4 handy you can compile

00:48:12,960 --> 00:48:16,480
for

00:48:13,280 --> 00:48:17,440
sandbox and run airbox under linux and

00:48:16,480 --> 00:48:21,200
play around with it

00:48:17,440 --> 00:48:35,839
a bit so thank you for listening

00:48:21,200 --> 00:48:35,839
and do you have any questions

00:48:38,079 --> 00:48:40,160

YouTube URL: https://www.youtube.com/watch?v=fru1n54s2W4


