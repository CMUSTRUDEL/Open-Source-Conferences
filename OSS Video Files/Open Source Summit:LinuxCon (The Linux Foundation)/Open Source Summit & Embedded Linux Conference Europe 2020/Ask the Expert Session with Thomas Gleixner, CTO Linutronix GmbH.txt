Title: Ask the Expert Session with Thomas Gleixner, CTO Linutronix GmbH
Publication date: 2020-11-17
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	Ask the Expert Session with Thomas Gleixner, CTO Linutronix GmbH
Captions: 
	00:00:15,280 --> 00:00:18,560
hello

00:00:16,160 --> 00:00:31,840
good afternoon good evening good morning

00:00:18,560 --> 00:00:31,840
wherever you are

00:00:38,399 --> 00:00:41,840
that's a good question will

00:00:41,920 --> 00:00:50,399
so i don't know i just

00:00:46,160 --> 00:00:53,680
it's just being me so i guess

00:00:50,399 --> 00:00:58,399
i always try to do what i thought

00:00:53,680 --> 00:01:00,960
is the right way to do it and

00:00:58,399 --> 00:01:01,680
it allowed me to build up a small

00:01:00,960 --> 00:01:04,879
company

00:01:01,680 --> 00:01:08,720
and have my living

00:01:04,879 --> 00:01:13,439
but avoiding the tech giants yes it's uh

00:01:08,720 --> 00:01:15,520
it was always on my my plan to do so so

00:01:13,439 --> 00:01:16,720
in the early days during university i

00:01:15,520 --> 00:01:18,799
had a

00:01:16,720 --> 00:01:21,040
an internship at a large tech company

00:01:18,799 --> 00:01:23,759
and this

00:01:21,040 --> 00:01:27,840
was so bad experience that i decided to

00:01:23,759 --> 00:01:27,840
never go there

00:01:39,200 --> 00:01:43,200
predictions for the colonel oh i don't

00:01:41,600 --> 00:01:46,880
know

00:01:43,200 --> 00:01:50,640
this is hard i mean it's we're going

00:01:46,880 --> 00:01:51,200
to go to its more accelerators to its

00:01:50,640 --> 00:01:54,320
more

00:01:51,200 --> 00:01:57,920
virtualization to its more performance

00:01:54,320 --> 00:02:01,119
and whatever it's but the

00:01:57,920 --> 00:02:04,240
the use cases are getting brought up

00:02:01,119 --> 00:02:04,960
so it's it's not only the the enterprise

00:02:04,240 --> 00:02:08,319
stuff

00:02:04,960 --> 00:02:09,200
getting more attention it's uh all over

00:02:08,319 --> 00:02:12,319
the place and

00:02:09,200 --> 00:02:16,720
there's a lot of overlap in

00:02:12,319 --> 00:02:17,520
the in the application space so people

00:02:16,720 --> 00:02:20,840
have to

00:02:17,520 --> 00:02:23,840
to work closer together to solve these

00:02:20,840 --> 00:02:23,840
problems

00:02:48,840 --> 00:02:51,840
oh

00:02:58,080 --> 00:03:01,920
i said the big tickets big bits of the

00:03:00,800 --> 00:03:05,040
rt patch set

00:03:01,920 --> 00:03:08,560
oh it's so print k is still

00:03:05,040 --> 00:03:11,519
outstanding um

00:03:08,560 --> 00:03:12,879
so the first portion of it just went

00:03:11,519 --> 00:03:17,440
into

00:03:12,879 --> 00:03:22,560
uh or c1 510 rc1

00:03:17,440 --> 00:03:22,560
that's the uh

00:03:22,879 --> 00:03:27,360
the ring my favorite which took a while

00:03:26,319 --> 00:03:30,959
because it

00:03:27,360 --> 00:03:33,760
affects tooling

00:03:30,959 --> 00:03:35,920
like crash car analysis and and stuff

00:03:33,760 --> 00:03:37,760
like that and they packed it

00:03:35,920 --> 00:03:40,319
with some other changes they wanted to

00:03:37,760 --> 00:03:43,440
do for the full afford

00:03:40,319 --> 00:03:46,480
so what's outstanding is

00:03:43,440 --> 00:03:48,879
yes to most of the locking core stuff

00:03:46,480 --> 00:03:50,319
but that's pretty pretty self-contained

00:03:48,879 --> 00:03:53,360
so

00:03:50,319 --> 00:03:56,879
aside of peter hating it

00:03:53,360 --> 00:04:00,000
it should be not that contentious

00:03:56,879 --> 00:04:03,599
so migrate disabled stuff is is is

00:04:00,000 --> 00:04:08,239
on the way i think and then our

00:04:03,599 --> 00:04:10,799
that's the big ports i have a patch that

00:04:08,239 --> 00:04:15,840
i'm polishing now for for the soft irq

00:04:10,799 --> 00:04:15,840
handling on rt but that's not

00:04:17,840 --> 00:04:29,840
not too bad

00:04:34,479 --> 00:04:39,040
oh exciting linux kernel features

00:04:37,520 --> 00:04:42,000
hardware features i don't know

00:04:39,040 --> 00:04:42,800
i mean there's a lot of exiling hardware

00:04:42,000 --> 00:04:46,479
features

00:04:42,800 --> 00:04:49,919
or not so exciting hardware features

00:04:46,479 --> 00:04:54,400
on the horizon people are trying to make

00:04:49,919 --> 00:04:56,880
to make it work so i don't see anything

00:04:54,400 --> 00:04:58,880
really outstanding it's just building on

00:04:56,880 --> 00:05:02,160
on top of what we have right now

00:04:58,880 --> 00:05:04,000
so it's i think yes it's

00:05:02,160 --> 00:05:06,240
it's the accelerator stuff it's the

00:05:04,000 --> 00:05:08,160
multi multi multi multi device stuff

00:05:06,240 --> 00:05:09,199
which you can hand into containers and

00:05:08,160 --> 00:05:11,840
vms and what

00:05:09,199 --> 00:05:11,840
whatever but it's

00:05:12,320 --> 00:05:19,680
so it's not nothing revolutionary

00:05:16,800 --> 00:05:20,400
i don't think there's anything which

00:05:19,680 --> 00:05:25,840
will

00:05:20,400 --> 00:05:25,840
just turn the kernel around

00:05:26,039 --> 00:05:33,919
revolutionary in the near future

00:05:29,759 --> 00:05:37,360
maybe the rust proposal was fun

00:05:33,919 --> 00:05:40,160
it might it might make sense at least on

00:05:37,360 --> 00:05:40,160
the driver side

00:05:43,600 --> 00:05:47,520
who will shape linux in the in the

00:05:45,759 --> 00:05:53,840
future

00:05:47,520 --> 00:05:53,840
interesting question

00:05:54,080 --> 00:05:58,000
i think there's still room for

00:05:56,000 --> 00:06:01,440
individuals

00:05:58,000 --> 00:06:04,560
you just have to have the time

00:06:01,440 --> 00:06:08,400
to do so so i consider myself

00:06:04,560 --> 00:06:10,400
as an individual computer contributor

00:06:08,400 --> 00:06:12,560
i mean i'm backed by a company but not

00:06:10,400 --> 00:06:13,919
by a big corporate like google or

00:06:12,560 --> 00:06:16,080
microsoft

00:06:13,919 --> 00:06:18,560
so there is room but but you have to

00:06:16,080 --> 00:06:23,199
have broad shoulders to

00:06:18,560 --> 00:06:26,880
to fight against those tech giants

00:06:23,199 --> 00:06:30,400
but at the very end i think even if

00:06:26,880 --> 00:06:34,000
a lot of the attack giants will

00:06:30,400 --> 00:06:37,120
contribute most or

00:06:34,000 --> 00:06:38,720
a big chunk of the of the kernel then

00:06:37,120 --> 00:06:41,280
they still have to agree with

00:06:38,720 --> 00:06:43,360
with each other so so the collaborative

00:06:41,280 --> 00:06:49,840
model and the consensus model will not

00:06:43,360 --> 00:06:49,840
go away

00:06:54,720 --> 00:07:00,800
iron is asking how did it go with the rt

00:06:58,400 --> 00:07:03,199
priority inheritance project

00:07:00,800 --> 00:07:04,720
what project are you talking about now

00:07:03,199 --> 00:07:08,960
it has

00:07:04,720 --> 00:07:12,960
i think you you are referring to the

00:07:08,960 --> 00:07:14,479
to the rework where people are trying to

00:07:12,960 --> 00:07:17,440
do

00:07:14,479 --> 00:07:18,000
to go away from priority inheritance and

00:07:17,440 --> 00:07:20,960
walk

00:07:18,000 --> 00:07:22,240
towards proxy execution in order to make

00:07:20,960 --> 00:07:26,240
deadline

00:07:22,240 --> 00:07:26,240
uh work

00:07:27,360 --> 00:07:31,440
so there's still that's still work in

00:07:29,759 --> 00:07:44,319
progress mostly by the

00:07:31,440 --> 00:07:47,440
folks at pisa university and some others

00:07:44,319 --> 00:07:50,879
uh michael

00:07:47,440 --> 00:07:53,919
so there is

00:07:50,879 --> 00:07:56,840
no requirement that the

00:07:53,919 --> 00:07:58,000
mainline drivers migrate to threaded i

00:07:56,840 --> 00:07:59,919
accuse

00:07:58,000 --> 00:08:02,560
so we've just forced threat i mean you

00:07:59,919 --> 00:08:05,840
can force threat them in mainline today

00:08:02,560 --> 00:08:07,440
so they don't care mostly so we just

00:08:05,840 --> 00:08:09,840
found a few

00:08:07,440 --> 00:08:11,759
uh things in the networking code where

00:08:09,840 --> 00:08:12,240
people make assumptions that this can't

00:08:11,759 --> 00:08:17,520
happen

00:08:12,240 --> 00:08:20,720
but it happens so but that's

00:08:17,520 --> 00:08:23,759
that's rather um

00:08:20,720 --> 00:08:27,520
small and minor issues so

00:08:23,759 --> 00:08:30,560
and it's not not an rt problem at all

00:08:27,520 --> 00:08:32,800
so once you you issue full thread

00:08:30,560 --> 00:08:34,640
full threading on the kernel command

00:08:32,800 --> 00:08:41,839
line you run into the same problems

00:08:34,640 --> 00:08:41,839
without rt

00:08:44,560 --> 00:08:49,519
there's a question whether there's more

00:08:47,279 --> 00:08:53,120
whether we see more usage of linux in

00:08:49,519 --> 00:08:54,000
automotive industry with preemptor t

00:08:53,120 --> 00:08:57,519
merged in the main

00:08:54,000 --> 00:09:00,560
line i i don't think it's really

00:08:57,519 --> 00:09:01,360
depending on it being being merged or

00:09:00,560 --> 00:09:04,560
not

00:09:01,360 --> 00:09:04,560
it's going to be

00:09:05,279 --> 00:09:10,800
they they are using it anyway so

00:09:08,880 --> 00:09:14,560
and of course it makes it easier for

00:09:10,800 --> 00:09:14,560
them if it's mainline and if it's

00:09:16,480 --> 00:09:20,399
going the normal route instead of having

00:09:18,720 --> 00:09:22,560
an extra patch set

00:09:20,399 --> 00:09:24,160
and having an extra stable tree and

00:09:22,560 --> 00:09:26,720
things like that so it makes

00:09:24,160 --> 00:09:27,760
stuff easier but it's not going to be

00:09:26,720 --> 00:09:31,680
more

00:09:27,760 --> 00:09:34,640
more usage i mean they there are

00:09:31,680 --> 00:09:34,640
tons of options

00:09:35,600 --> 00:09:37,839
not

00:09:42,160 --> 00:09:47,360
still thomas is asking what the issues

00:09:44,399 --> 00:09:51,839
with tasklets or

00:09:47,360 --> 00:09:51,839
tasklets or

00:09:52,160 --> 00:09:55,990
interesting it's a

00:09:55,519 --> 00:09:58,640
so the

00:09:55,990 --> 00:10:00,399
[Music]

00:09:58,640 --> 00:10:02,880
it's mostly the implementation which

00:10:00,399 --> 00:10:06,000
sucks so it's a it's a way to

00:10:02,880 --> 00:10:08,720
to defer arbitrary callbacks

00:10:06,000 --> 00:10:11,440
into software eq context and it's

00:10:08,720 --> 00:10:15,040
semantically ill-defined

00:10:11,440 --> 00:10:18,000
so interestingly a lot of these

00:10:15,040 --> 00:10:18,640
of the tasks let's use this shouldn't be

00:10:18,000 --> 00:10:21,680
there at

00:10:18,640 --> 00:10:24,160
all so it's it's just

00:10:21,680 --> 00:10:26,240
doing arbitrary stuff which could be

00:10:24,160 --> 00:10:27,200
done in a threaded interrupt handler as

00:10:26,240 --> 00:10:30,399
well so

00:10:27,200 --> 00:10:30,880
but it needs to be individually looked

00:10:30,399 --> 00:10:34,399
at

00:10:30,880 --> 00:10:37,839
per um

00:10:34,399 --> 00:10:41,600
per use case and it's not you cannot

00:10:37,839 --> 00:10:47,839
do a wholesale replacement that's

00:10:41,600 --> 00:10:47,839
that that will take quite some time

00:10:52,480 --> 00:10:59,839
um yes i think that linux will

00:10:56,160 --> 00:11:03,200
can see disruption by smaller os's

00:10:59,839 --> 00:11:07,040
the bottom up but this is

00:11:03,200 --> 00:11:10,880
not not a surprise

00:11:07,040 --> 00:11:12,320
linux has grown out of the oh we run on

00:11:10,880 --> 00:11:15,279
everything

00:11:12,320 --> 00:11:17,440
from the smallest microcontroller to to

00:11:15,279 --> 00:11:20,560
the largest super thing

00:11:17,440 --> 00:11:23,600
so the small

00:11:20,560 --> 00:11:26,000
smaller os is like saphir and others

00:11:23,600 --> 00:11:27,360
eat up from the bottom where linux

00:11:26,000 --> 00:11:31,519
doesn't fit

00:11:27,360 --> 00:11:31,519
and can't fit anymore

00:11:38,800 --> 00:11:44,560
so that's a good question so yes linux

00:11:42,000 --> 00:11:45,920
per se is not a real-time operating

00:11:44,560 --> 00:11:48,959
system

00:11:45,920 --> 00:11:53,040
but we have patches which

00:11:48,959 --> 00:11:56,240
when and they are gradually merged which

00:11:53,040 --> 00:12:00,480
turn it into a real-time

00:11:56,240 --> 00:12:03,519
system but it's

00:12:00,480 --> 00:12:03,920
it's hard to claim it's it's really in

00:12:03,519 --> 00:12:07,920
the

00:12:03,920 --> 00:12:10,000
in the tradition of uh

00:12:07,920 --> 00:12:12,000
real-time operating systems which were

00:12:10,000 --> 00:12:16,560
designed from ground up to

00:12:12,000 --> 00:12:19,120
to support the real time it's

00:12:16,560 --> 00:12:19,760
it's close but it's not mathematically

00:12:19,120 --> 00:12:22,160
provable

00:12:19,760 --> 00:12:22,160
so it's

00:12:22,800 --> 00:12:28,720
it's the best effort but with

00:12:25,920 --> 00:12:31,120
quite some success and it's the most

00:12:28,720 --> 00:12:33,680
scalable

00:12:31,120 --> 00:12:33,680
um

00:12:35,920 --> 00:12:39,519
real-time system on the planet which

00:12:38,639 --> 00:12:42,639
runs on logs

00:12:39,519 --> 00:12:42,639
on launch machines

00:12:47,200 --> 00:12:56,560
i haven't looked deeply into

00:12:52,560 --> 00:12:56,560
into evl

00:12:57,279 --> 00:12:59,519
so

00:13:01,360 --> 00:13:09,040
i can't even even tell about

00:13:04,720 --> 00:13:12,800
it what it what it actually does

00:13:09,040 --> 00:13:16,079
so i have to to really

00:13:12,800 --> 00:13:18,639
um defer that question

00:13:16,079 --> 00:13:22,240
to to a different point in time where i

00:13:18,639 --> 00:13:22,240
actually had time to look at it

00:13:29,600 --> 00:13:33,680
no i haven't written much rust but i

00:13:32,480 --> 00:13:38,160
like the concept of

00:13:33,680 --> 00:13:40,639
rust so it's

00:13:38,160 --> 00:13:40,639
i mean it

00:13:41,279 --> 00:13:47,600
it rust would help to avoid

00:13:45,600 --> 00:13:50,320
quite some of the problems c brings

00:13:47,600 --> 00:13:53,680
along especially with people who

00:13:50,320 --> 00:13:54,639
are not aware of all the nasty

00:13:53,680 --> 00:13:58,000
shortcomings of

00:13:54,639 --> 00:14:01,199
c so it's it's mostly

00:13:58,000 --> 00:14:05,519
something to make it's

00:14:01,199 --> 00:14:05,519
harder for driver writers to screw up

00:14:14,959 --> 00:14:20,959
ah cindy in kernel space an interesting

00:14:18,320 --> 00:14:23,600
question without

00:14:20,959 --> 00:14:23,600
begin end

00:14:24,240 --> 00:14:26,880
i don't know

00:14:28,079 --> 00:14:32,639
it's hard to tell because

00:14:33,600 --> 00:14:38,880
the the main problem for that is

00:14:36,959 --> 00:14:41,199
that if you want to do that in all

00:14:38,880 --> 00:14:44,160
contexts including interrupts or

00:14:41,199 --> 00:14:49,600
software cues or whatever

00:14:44,160 --> 00:14:49,600
then you have to push to save and push

00:14:50,800 --> 00:14:58,880
the the the cmd state or whatever

00:14:55,360 --> 00:15:01,440
xav state onto the stack

00:14:58,880 --> 00:15:02,399
at every interrupt entry and that's

00:15:01,440 --> 00:15:06,240
going to be

00:15:02,399 --> 00:15:09,440
not cheap so that

00:15:06,240 --> 00:15:10,240
needs a lot more thought than just okay

00:15:09,440 --> 00:15:14,720
let

00:15:10,240 --> 00:15:19,199
gcc or to auto vectorize code

00:15:14,720 --> 00:15:20,880
it's not that trivial because the

00:15:19,199 --> 00:15:22,560
you carefully have to weigh the

00:15:20,880 --> 00:15:25,600
performance impact of

00:15:22,560 --> 00:15:28,320
saving the register state on

00:15:25,600 --> 00:15:30,480
exception entry or interrupt entry

00:15:28,320 --> 00:15:33,920
versus what you gain

00:15:30,480 --> 00:15:37,680
in the code itself and it's

00:15:33,920 --> 00:15:40,000
i i think that you have to

00:15:37,680 --> 00:15:41,839
to try and figure out whether this

00:15:40,000 --> 00:15:44,320
actually works

00:15:41,839 --> 00:15:45,600
i mean technically it works it's it's

00:15:44,320 --> 00:15:50,079
not the problem

00:15:45,600 --> 00:15:54,959
but you have to carefully weigh

00:15:50,079 --> 00:15:57,519
whether that's something

00:15:54,959 --> 00:15:58,720
which actually brings a performance

00:15:57,519 --> 00:16:00,800
benefit

00:15:58,720 --> 00:16:09,839
versus the overhead of saving and

00:16:00,800 --> 00:16:09,839
restoring the register banks

00:16:10,800 --> 00:16:14,560
trisha yes my main project is to buy a

00:16:13,600 --> 00:16:17,759
goat farmer

00:16:14,560 --> 00:16:19,839
unfortunately i don't have enough time

00:16:17,759 --> 00:16:23,120
to follow through on that there's

00:16:19,839 --> 00:16:26,560
way too much cruel stuff keeping me busy

00:16:23,120 --> 00:16:29,519
so but someday i might just

00:16:26,560 --> 00:16:36,560
throw the colonel stuff aside and go for

00:16:29,519 --> 00:16:40,240
the goat form

00:16:36,560 --> 00:16:44,079
um our team kvm vms

00:16:40,240 --> 00:16:51,839
i think there's still uh work being done

00:16:44,079 --> 00:16:51,839
red hat i think this is a lot

00:17:02,839 --> 00:17:05,839
uh

00:17:07,600 --> 00:17:12,799
um christian no i don't know about the

00:17:10,799 --> 00:17:15,600
page log fairness stuff i haven't

00:17:12,799 --> 00:17:15,600
followed that

00:17:16,839 --> 00:17:19,839
so

00:17:22,720 --> 00:17:26,480
odp decay

00:17:27,120 --> 00:17:30,799
i mean dpdk and raw sockets you can't

00:17:29,840 --> 00:17:33,679
compare that

00:17:30,799 --> 00:17:36,000
i think what you really want to look at

00:17:33,679 --> 00:17:36,000
is

00:17:36,080 --> 00:17:45,039
the question whether you can use xtp

00:17:40,559 --> 00:17:45,039
bruce's dptk which is

00:17:45,600 --> 00:17:51,440
still leveraging

00:17:48,720 --> 00:17:52,559
the the drivers in the cooler and the

00:17:51,440 --> 00:17:55,440
whole

00:17:52,559 --> 00:17:57,360
uh kernel facilities with all the the

00:17:55,440 --> 00:18:00,720
good things

00:17:57,360 --> 00:18:02,640
but has avoids the the overhead of

00:18:00,720 --> 00:18:04,880
of crossing this is called boundaries

00:18:02,640 --> 00:18:08,240
and things like that

00:18:04,880 --> 00:18:12,160
so yeah there's there's an

00:18:08,240 --> 00:18:15,120
advantage in in using dptk but the dptk

00:18:12,160 --> 00:18:15,919
based on xdp is what i would suggest you

00:18:15,120 --> 00:18:19,679
look into

00:18:15,919 --> 00:18:21,760
not or at a dptk

00:18:19,679 --> 00:18:22,720
re-implementing a complete driver in

00:18:21,760 --> 00:18:29,840
user space

00:18:22,720 --> 00:18:29,840
that's a total mess

00:18:32,240 --> 00:18:38,320
so robert

00:18:35,520 --> 00:18:40,000
yes worst case response time for for

00:18:38,320 --> 00:18:42,960
generic linux kernel yes

00:18:40,000 --> 00:18:43,679
it's five maybe 500 milliseconds

00:18:42,960 --> 00:18:46,960
whatever

00:18:43,679 --> 00:18:48,559
it i don't have numbers recent numbers

00:18:46,960 --> 00:18:52,880
but it used to be in that

00:18:48,559 --> 00:18:56,000
area but with the preempt rt purchases

00:18:52,880 --> 00:18:56,000
it's definitely

00:18:57,600 --> 00:19:01,200
milliseconds if if it's if that happens

00:19:00,720 --> 00:19:04,000
that's

00:19:01,200 --> 00:19:04,000
simply a bug

00:19:05,840 --> 00:19:14,400
i mean we can't prove it mathematically

00:19:10,799 --> 00:19:17,360
but um we would see it

00:19:14,400 --> 00:19:17,919
in the in the massive testing which is

00:19:17,360 --> 00:19:21,600
is

00:19:17,919 --> 00:19:24,160
is done out there um

00:19:21,600 --> 00:19:26,720
the only way i can think about it is you

00:19:24,160 --> 00:19:26,720
use some

00:19:29,679 --> 00:19:34,400
some weird out of tree driver or

00:19:33,280 --> 00:19:38,240
something like that

00:19:34,400 --> 00:19:40,559
or some really badly maintained driver

00:19:38,240 --> 00:19:41,919
but you should see the problem already

00:19:40,559 --> 00:19:44,799
in testing with the

00:19:41,919 --> 00:19:46,400
with the proper debug options so that

00:19:44,799 --> 00:19:49,840
would tell you that driver

00:19:46,400 --> 00:19:53,200
is doing something wrong

00:19:49,840 --> 00:19:57,360
so but in the general case yes

00:19:53,200 --> 00:20:00,160
i mean it's hard to prove but

00:19:57,360 --> 00:20:00,160
i don't think so

00:20:04,080 --> 00:20:10,799
abel uh kernel tinification yes that's

00:20:09,120 --> 00:20:12,880
that's an effort which is going on

00:20:10,799 --> 00:20:16,080
forever but it's hard

00:20:12,880 --> 00:20:16,080
for them to catch up

00:20:18,840 --> 00:20:22,320
um

00:20:20,159 --> 00:20:24,480
and i i can't tell what the minimal

00:20:22,320 --> 00:20:28,080
requirements for a platform is that

00:20:24,480 --> 00:20:31,600
right now so i i lost track of

00:20:28,080 --> 00:20:37,039
of that but it's definitely

00:20:31,600 --> 00:20:37,039
not the the the tiny micro coalesc

00:20:38,640 --> 00:20:43,520
microcontroller thing which has a very

00:20:41,600 --> 00:20:45,039
very limited amount of ram and things

00:20:43,520 --> 00:20:48,799
like that

00:20:45,039 --> 00:20:51,440
so there are invest

00:20:48,799 --> 00:20:52,799
investigations out there from other

00:20:51,440 --> 00:20:55,440
people

00:20:52,799 --> 00:20:56,240
who say what uh what the minimal

00:20:55,440 --> 00:21:02,799
requirement

00:20:56,240 --> 00:21:06,480
is but i don't know

00:21:02,799 --> 00:21:07,760
uh drew one microsecond on the modern

00:21:06,480 --> 00:21:10,480
intel amd server

00:21:07,760 --> 00:21:10,480
you're kidding

00:21:12,159 --> 00:21:20,799
one microsecond is is way

00:21:16,159 --> 00:21:24,320
less than the hardware induced latencies

00:21:20,799 --> 00:21:27,840
can be and that's something the kernel

00:21:24,320 --> 00:21:32,159
has no control over

00:21:27,840 --> 00:21:36,000
so if you look at things like

00:21:32,159 --> 00:21:39,200
dma bus contention

00:21:36,000 --> 00:21:42,000
or whatever it's extremely hard to

00:21:39,200 --> 00:21:44,960
guarantee a one microsecond on

00:21:42,000 --> 00:21:48,159
on such a unsuch a machine because they

00:21:44,960 --> 00:21:51,919
are not built for that

00:21:48,159 --> 00:21:55,520
as a case guarantee that's just

00:21:51,919 --> 00:21:55,520
i i think it's an illusion

00:21:55,679 --> 00:22:01,679
but so if you really need

00:21:58,880 --> 00:22:02,480
need to to handle that you you should

00:22:01,679 --> 00:22:05,600
have

00:22:02,480 --> 00:22:08,720
something which is less complex

00:22:05,600 --> 00:22:12,159
and there are a lot of approaches out

00:22:08,720 --> 00:22:15,840
there in industry where you

00:22:12,159 --> 00:22:15,840
just use things like

00:22:19,039 --> 00:22:26,000
fpgas or or some

00:22:22,880 --> 00:22:29,120
site controller which does the real

00:22:26,000 --> 00:22:32,559
real real hard to

00:22:29,120 --> 00:22:36,559
hard to achieve one microsecond

00:22:32,559 --> 00:22:39,520
thing and then you offload

00:22:36,559 --> 00:22:41,760
this part of the real-time computation

00:22:39,520 --> 00:22:44,799
to that

00:22:41,760 --> 00:22:47,919
accelerator or whatever you name it

00:22:44,799 --> 00:22:50,960
i think that's more realistically than

00:22:47,919 --> 00:22:54,559
trying to say oh yeah we can do the

00:22:50,960 --> 00:22:55,039
one microsecond on a modern amd server

00:22:54,559 --> 00:22:58,720
or

00:22:55,039 --> 00:22:58,720
intel server i think it doesn't make

00:23:06,840 --> 00:23:09,840
sense

00:23:10,400 --> 00:23:19,039
so pankai yes it's hard for

00:23:14,000 --> 00:23:19,039
into individual computer contributors to

00:23:19,440 --> 00:23:25,360
to watch what in

00:23:22,640 --> 00:23:26,400
multiple subsystems is going on if you

00:23:25,360 --> 00:23:29,039
want to contribute

00:23:26,400 --> 00:23:30,960
something which overlaps these

00:23:29,039 --> 00:23:34,320
subsystems so it's hard

00:23:30,960 --> 00:23:35,280
even for for single subsystems depending

00:23:34,320 --> 00:23:39,600
on their

00:23:35,280 --> 00:23:39,600
activity level it can be hard to follow

00:23:41,679 --> 00:23:50,000
it's it heavily depends on

00:23:46,480 --> 00:23:54,240
how you organize yourself and how much

00:23:50,000 --> 00:23:57,520
time you can you can spend to actually

00:23:54,240 --> 00:24:05,840
follow what's going on it's there's no

00:23:57,520 --> 00:24:05,840
general rule for that

00:24:12,640 --> 00:24:19,440
um versus the

00:24:16,799 --> 00:24:21,360
the patch series which is thrown over

00:24:19,440 --> 00:24:24,240
the fence every six months and then

00:24:21,360 --> 00:24:24,240
people disappear

00:24:25,039 --> 00:24:29,120
yes i mean if there's really value in

00:24:27,360 --> 00:24:33,440
the patch that i mean if there's

00:24:29,120 --> 00:24:35,840
there's um

00:24:33,440 --> 00:24:37,120
well you if there are fixes you really

00:24:35,840 --> 00:24:40,000
should

00:24:37,120 --> 00:24:40,799
uh pull them out and and just polish

00:24:40,000 --> 00:24:44,400
them up and

00:24:40,799 --> 00:24:47,600
and apply them um if it's something

00:24:44,400 --> 00:24:50,799
which is

00:24:47,600 --> 00:24:54,559
actually making it easier

00:24:50,799 --> 00:24:54,559
for um

00:24:56,960 --> 00:25:03,600
for your subsystem to to be maintained

00:25:00,640 --> 00:25:05,039
or gives you a better coat structure or

00:25:03,600 --> 00:25:07,600
whatever then

00:25:05,039 --> 00:25:08,960
it's smooth as a maintainer to actually

00:25:07,600 --> 00:25:12,080
go there and and

00:25:08,960 --> 00:25:15,520
and do the dirty laundry

00:25:12,080 --> 00:25:17,600
so look at it and

00:25:15,520 --> 00:25:20,159
there's again no general answer it

00:25:17,600 --> 00:25:22,720
depends on the quality of the patches or

00:25:20,159 --> 00:25:24,480
on the quality of the approach i mean if

00:25:22,720 --> 00:25:29,840
the approach is good why would you

00:25:24,480 --> 00:25:29,840
throw it away

00:25:40,840 --> 00:25:43,840
oh

00:25:54,840 --> 00:25:57,840
okay

00:26:22,840 --> 00:26:25,840
so

00:28:14,840 --> 00:28:17,840
oh

00:28:42,840 --> 00:28:45,840

YouTube URL: https://www.youtube.com/watch?v=OABEFSQERXM


