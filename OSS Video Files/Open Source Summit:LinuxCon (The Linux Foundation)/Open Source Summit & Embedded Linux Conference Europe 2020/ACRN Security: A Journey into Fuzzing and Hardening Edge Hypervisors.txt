Title: ACRN Security: A Journey into Fuzzing and Hardening Edge Hypervisors
Publication date: 2020-11-10
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	ACRN Security: A Journey into Fuzzing and Hardening Edge Hypervisors - Mostafa Elsaid & Steffen Schulz, Intel
Captions: 
	00:00:07,040 --> 00:00:10,559
so

00:00:08,080 --> 00:00:12,799
welcome everybody i'm mustafa saeed a

00:00:10,559 --> 00:00:13,840
security engineer at intel internet of

00:00:12,799 --> 00:00:16,080
things group

00:00:13,840 --> 00:00:17,359
and i'm joined today with stefan schulz

00:00:16,080 --> 00:00:20,160
a security researcher

00:00:17,359 --> 00:00:22,160
at intellabs and today we're presenting

00:00:20,160 --> 00:00:24,160
our topic a journey into fuzzing and

00:00:22,160 --> 00:00:26,240
hardening edge hypervisors

00:00:24,160 --> 00:00:27,840
so to give a bit of perspective what's

00:00:26,240 --> 00:00:30,720
the intention of this talk so

00:00:27,840 --> 00:00:31,519
the acom security team really focuses on

00:00:30,720 --> 00:00:33,200
the

00:00:31,519 --> 00:00:34,880
security validation and offensive

00:00:33,200 --> 00:00:37,360
security validation to make sure that

00:00:34,880 --> 00:00:40,239
the product comes out in the best shape

00:00:37,360 --> 00:00:42,000
and the idea today is to walk through

00:00:40,239 --> 00:00:43,760
some of our experiments and

00:00:42,000 --> 00:00:46,239
efforts and activities that is related

00:00:43,760 --> 00:00:46,960
to negative security testing or known as

00:00:46,239 --> 00:00:48,719
fuzzing

00:00:46,960 --> 00:00:50,480
in order to conduct a comprehensive

00:00:48,719 --> 00:00:53,280
fuzzing campaign for different security

00:00:50,480 --> 00:00:55,600
components in the acron software stack

00:00:53,280 --> 00:00:57,120
so the agenda for today will be as

00:00:55,600 --> 00:00:59,359
follows so first we will start with

00:00:57,120 --> 00:01:01,359
introducing acron and what are edge

00:00:59,359 --> 00:01:04,400
hypervisors and highlight some of the

00:01:01,359 --> 00:01:06,640
use cases related to edge and iot

00:01:04,400 --> 00:01:08,479
late and then we go into fuzzing for

00:01:06,640 --> 00:01:09,200
product assurance and how does fuzzing

00:01:08,479 --> 00:01:12,240
fit into

00:01:09,200 --> 00:01:13,280
the product security validation later we

00:01:12,240 --> 00:01:16,159
start talking about

00:01:13,280 --> 00:01:17,439
fuzzing road trip and walk through some

00:01:16,159 --> 00:01:20,080
of the

00:01:17,439 --> 00:01:21,840
tools and the techniques that we

00:01:20,080 --> 00:01:24,159
followed in order to fuzz

00:01:21,840 --> 00:01:25,040
acron and any components related to

00:01:24,159 --> 00:01:26,960
acron

00:01:25,040 --> 00:01:28,640
and finally we'll summarize some of the

00:01:26,960 --> 00:01:30,000
lessons learned and what are the future

00:01:28,640 --> 00:01:33,200
steps

00:01:30,000 --> 00:01:33,200
for this kind of activity

00:01:33,680 --> 00:01:36,720
so to start

00:01:36,799 --> 00:01:41,200
hypervisors for the edge so first of all

00:01:39,759 --> 00:01:43,040
what is the edge

00:01:41,200 --> 00:01:45,119
we add the edge we can see the edge now

00:01:43,040 --> 00:01:47,360
in almost every single industry it can

00:01:45,119 --> 00:01:49,600
be in transportation it can be in smart

00:01:47,360 --> 00:01:51,520
factories things like industry 4.0 it

00:01:49,600 --> 00:01:54,000
can be in smart cities

00:01:51,520 --> 00:01:56,000
it even touches on some of the the the

00:01:54,000 --> 00:01:58,320
the industry that we're not used to like

00:01:56,000 --> 00:02:00,719
using uh like in retail in financial

00:01:58,320 --> 00:02:02,719
services in hospitality and so on

00:02:00,719 --> 00:02:04,479
and the role of virtualization in such

00:02:02,719 --> 00:02:07,119
industries is to provide a solution

00:02:04,479 --> 00:02:08,720
for for different use cases in order to

00:02:07,119 --> 00:02:11,599
have operation efficiency

00:02:08,720 --> 00:02:13,360
and a way in order to manage different

00:02:11,599 --> 00:02:15,200
workloads or what we call heterogeneous

00:02:13,360 --> 00:02:16,560
workload and consolidate them in in a

00:02:15,200 --> 00:02:19,200
safe way

00:02:16,560 --> 00:02:20,720
so the question is why don't we just you

00:02:19,200 --> 00:02:23,120
why don't we just use the cloud

00:02:20,720 --> 00:02:25,040
what's the problem with that so on the

00:02:23,120 --> 00:02:27,360
edge we face a different

00:02:25,040 --> 00:02:29,280
set of problems and those problems are

00:02:27,360 --> 00:02:30,800
mostly related to bottlenecks in the

00:02:29,280 --> 00:02:33,040
transportation bandwidth

00:02:30,800 --> 00:02:35,120
thing related to storage cost and the

00:02:33,040 --> 00:02:35,840
limited amount of data that we can move

00:02:35,120 --> 00:02:38,239
from

00:02:35,840 --> 00:02:39,280
those devices on the edge back to the

00:02:38,239 --> 00:02:41,040
cloud

00:02:39,280 --> 00:02:42,640
even the nature of those applications

00:02:41,040 --> 00:02:44,560
running on the cloud is a bit different

00:02:42,640 --> 00:02:46,480
so we have real-time application

00:02:44,560 --> 00:02:48,720
closed-loop application that require

00:02:46,480 --> 00:02:50,720
high responsiveness low latency

00:02:48,720 --> 00:02:52,560
and in sometimes local authority and

00:02:50,720 --> 00:02:56,160
time driven decisions

00:02:52,560 --> 00:02:59,599
and for that we have acron

00:02:56,160 --> 00:03:01,599
so acron is a flexible open source

00:02:59,599 --> 00:03:02,720
lightweight hypervisor that is intended

00:03:01,599 --> 00:03:04,720
to come and

00:03:02,720 --> 00:03:07,360
and support many of the used cases

00:03:04,720 --> 00:03:09,920
related to the edge and the iot

00:03:07,360 --> 00:03:11,519
so from architecture perspective acorn

00:03:09,920 --> 00:03:13,920
is a type 1 hypervisor

00:03:11,519 --> 00:03:15,519
that is running directly on top of the

00:03:13,920 --> 00:03:16,720
hardware resources it's a bare metal

00:03:15,519 --> 00:03:18,319
hypervisor

00:03:16,720 --> 00:03:20,319
and on top of that we have different

00:03:18,319 --> 00:03:22,480
sets and types of vms

00:03:20,319 --> 00:03:24,640
we have mainly three types of vms we

00:03:22,480 --> 00:03:27,040
have a service vm

00:03:24,640 --> 00:03:29,200
we have user vms and we have what's

00:03:27,040 --> 00:03:31,440
called pre-launch vms

00:03:29,200 --> 00:03:33,840
so the service vm is kind of like the

00:03:31,440 --> 00:03:35,200
control vm that has the native drivers

00:03:33,840 --> 00:03:36,239
that communicate with the hardware

00:03:35,200 --> 00:03:38,239
resources

00:03:36,239 --> 00:03:40,400
in addition it possesses the device

00:03:38,239 --> 00:03:41,360
model or some kind of emulation back end

00:03:40,400 --> 00:03:44,480
that would assist

00:03:41,360 --> 00:03:46,640
the user vms as we can see

00:03:44,480 --> 00:03:48,640
like windows or real-time vms in order

00:03:46,640 --> 00:03:52,480
to do device sharing or configure some

00:03:48,640 --> 00:03:52,480
of the devices directly to those vms

00:03:52,640 --> 00:03:58,080
regarding the pre-launch vm it's as as

00:03:55,519 --> 00:04:00,080
the name describes a pre-launch vm

00:03:58,080 --> 00:04:02,000
is not controlled by the service vm but

00:04:00,080 --> 00:04:04,080
it boots in a separate boot path

00:04:02,000 --> 00:04:05,760
and we can run things like safety

00:04:04,080 --> 00:04:09,360
critical application

00:04:05,760 --> 00:04:11,599
things like zephyr and and so on

00:04:09,360 --> 00:04:13,200
the goal of acron is really to to to

00:04:11,599 --> 00:04:14,640
average the gap between data center

00:04:13,200 --> 00:04:17,359
hypervisors and our partitioning

00:04:14,640 --> 00:04:19,759
hypervisors and it does that in two ways

00:04:17,359 --> 00:04:21,519
first it tries to tackle the key

00:04:19,759 --> 00:04:23,440
challenges that we face on the edge

00:04:21,519 --> 00:04:25,360
things like workloads with mixed

00:04:23,440 --> 00:04:27,280
criticality real-time versus

00:04:25,360 --> 00:04:28,720
non-real-time workloads

00:04:27,280 --> 00:04:30,800
having safety and non-safety

00:04:28,720 --> 00:04:32,560
applications and so on

00:04:30,800 --> 00:04:34,240
even for the real-time application some

00:04:32,560 --> 00:04:35,440
of them has real-time requirements some

00:04:34,240 --> 00:04:37,040
of them have

00:04:35,440 --> 00:04:39,280
some of them have hard requirements some

00:04:37,040 --> 00:04:41,840
of them have soft real-time requirements

00:04:39,280 --> 00:04:42,400
and so on so these applications have a

00:04:41,840 --> 00:04:45,759
very

00:04:42,400 --> 00:04:47,840
diverse nature in addition acrom focuses

00:04:45,759 --> 00:04:48,160
also on functional safety and certifying

00:04:47,840 --> 00:04:50,560
the

00:04:48,160 --> 00:04:51,520
hypervisor components things like for

00:04:50,560 --> 00:04:54,320
automotive or

00:04:51,520 --> 00:04:54,320
industrial use

00:04:55,040 --> 00:04:59,440
that sounds good so the second part is

00:04:57,520 --> 00:05:00,400
being very flexible and very highly

00:04:59,440 --> 00:05:02,800
configurable so

00:05:00,400 --> 00:05:04,560
as we can see now acron can work for a

00:05:02,800 --> 00:05:07,280
different set of use cases

00:05:04,560 --> 00:05:07,680
take for example the automotive sector

00:05:07,280 --> 00:05:10,560
so

00:05:07,680 --> 00:05:11,840
for in vehicle in infotainment we would

00:05:10,560 --> 00:05:14,080
require things like

00:05:11,840 --> 00:05:15,919
hardware resource sharing you can think

00:05:14,080 --> 00:05:16,960
of running your instrument cluster in

00:05:15,919 --> 00:05:19,759
the service vm

00:05:16,960 --> 00:05:21,280
and using other vms to run rear

00:05:19,759 --> 00:05:23,600
entertainment application things like

00:05:21,280 --> 00:05:25,440
virtual offices and so on

00:05:23,600 --> 00:05:27,120
and here the bottom neck would be that

00:05:25,440 --> 00:05:28,960
vms are trying to access and share

00:05:27,120 --> 00:05:32,240
different hardware resources like audio

00:05:28,960 --> 00:05:34,000
video storage and so on and so forth

00:05:32,240 --> 00:05:36,560
moving to another segment things like

00:05:34,000 --> 00:05:38,960
the industrial domain where we will have

00:05:36,560 --> 00:05:39,840
different type of vms that needs to run

00:05:38,960 --> 00:05:43,280
for example

00:05:39,840 --> 00:05:43,919
we will have hmi or or some kind of oss

00:05:43,280 --> 00:05:45,680
that

00:05:43,919 --> 00:05:48,160
presents some dashboards for for the

00:05:45,680 --> 00:05:51,199
user to monitor things that is happening

00:05:48,160 --> 00:05:53,199
it can also be real-time vms that we can

00:05:51,199 --> 00:05:54,880
dedicate some hardware resources to

00:05:53,199 --> 00:05:55,919
those vm and those vm would be

00:05:54,880 --> 00:05:57,759
responsible for

00:05:55,919 --> 00:06:00,560
controlling robotic arms or even

00:05:57,759 --> 00:06:03,360
connected to plc devices and so on

00:06:00,560 --> 00:06:05,520
in in more more advanced cases we have

00:06:03,360 --> 00:06:07,600
things like safety critical application

00:06:05,520 --> 00:06:10,000
that can run in in the as a pre-launch

00:06:07,600 --> 00:06:12,400
vm and those

00:06:10,000 --> 00:06:14,240
have the task to monitor the system

00:06:12,400 --> 00:06:16,960
health or any application that

00:06:14,240 --> 00:06:18,960
have high availability requirements and

00:06:16,960 --> 00:06:21,199
so on

00:06:18,960 --> 00:06:23,280
finally if we do not really care about

00:06:21,199 --> 00:06:26,160
resource sharing and we just need to run

00:06:23,280 --> 00:06:27,039
a couple of vms directly on top of of

00:06:26,160 --> 00:06:28,880
acron then

00:06:27,039 --> 00:06:30,160
the logical partition would allow us to

00:06:28,880 --> 00:06:32,160
do that and

00:06:30,160 --> 00:06:33,680
in this case we won't have a device

00:06:32,160 --> 00:06:35,600
model and we don't have a

00:06:33,680 --> 00:06:38,639
service vm in the traditional sense but

00:06:35,600 --> 00:06:40,560
just safety vm and user vm that

00:06:38,639 --> 00:06:42,240
is partitioned in a way and segregated

00:06:40,560 --> 00:06:43,680
in a way to run seamlessly on top of

00:06:42,240 --> 00:06:45,680
acron

00:06:43,680 --> 00:06:47,360
so this was an introduction about acron

00:06:45,680 --> 00:06:50,319
different use cases and so on

00:06:47,360 --> 00:06:51,840
now when we jump into fuzzing and

00:06:50,319 --> 00:06:53,360
understanding what is fuzzing and how

00:06:51,840 --> 00:06:55,840
does this relate to acron so

00:06:53,360 --> 00:06:55,840
stefan

00:06:56,720 --> 00:07:00,960
thank you mustafa so um in the next part

00:07:00,560 --> 00:07:02,880
let's

00:07:00,960 --> 00:07:06,560
let's talk about fuzzing for security

00:07:02,880 --> 00:07:06,560
validation what does it actually mean

00:07:11,680 --> 00:07:15,039
so as you just heard there's there are a

00:07:14,400 --> 00:07:17,120
lot of

00:07:15,039 --> 00:07:18,080
there's a lot of requirements for acorn

00:07:17,120 --> 00:07:20,960
to meet uh

00:07:18,080 --> 00:07:22,639
functional safety to meet uh security in

00:07:20,960 --> 00:07:25,759
various use cases

00:07:22,639 --> 00:07:27,680
uh for security critical products uh

00:07:25,759 --> 00:07:29,680
intel has a so-called security

00:07:27,680 --> 00:07:31,520
development lifecycle that makes sure

00:07:29,680 --> 00:07:33,599
that all of our products adhere to the

00:07:31,520 --> 00:07:36,160
current best practices

00:07:33,599 --> 00:07:39,759
um and and kind of are systematically

00:07:36,160 --> 00:07:42,639
designed and evaluated and implemented

00:07:39,759 --> 00:07:44,160
in particular you may be uh of course

00:07:42,639 --> 00:07:46,319
aware that you should do

00:07:44,160 --> 00:07:48,800
security architecture you understand the

00:07:46,319 --> 00:07:51,199
usages the assets the goals

00:07:48,800 --> 00:07:52,160
um and then you would select the various

00:07:51,199 --> 00:07:55,120
technologies

00:07:52,160 --> 00:07:55,520
like you design the actual interfaces

00:07:55,120 --> 00:07:57,840
you

00:07:55,520 --> 00:08:00,000
implement mechanisms like secure boot

00:07:57,840 --> 00:08:03,199
and access control

00:08:00,000 --> 00:08:05,199
or you decide for particular mechanisms

00:08:03,199 --> 00:08:06,720
um then there's a big implementation

00:08:05,199 --> 00:08:08,800
phase

00:08:06,720 --> 00:08:10,160
but then there's of course a question

00:08:08,800 --> 00:08:11,919
has the implementation

00:08:10,160 --> 00:08:14,160
been correct has it been according to

00:08:11,919 --> 00:08:16,000
the uh detailed design has it been

00:08:14,160 --> 00:08:18,319
according to the architecture

00:08:16,000 --> 00:08:19,840
do the mechanisms that i have uh

00:08:18,319 --> 00:08:22,720
specified actually meet

00:08:19,840 --> 00:08:25,199
the security goals so there's always a

00:08:22,720 --> 00:08:27,680
so-called security validation phase

00:08:25,199 --> 00:08:28,479
where there's a separate team that will

00:08:27,680 --> 00:08:32,000
perform

00:08:28,479 --> 00:08:34,479
software review static analysis

00:08:32,000 --> 00:08:36,640
vulnerability scanning all the

00:08:34,479 --> 00:08:38,560
dependencies of the software

00:08:36,640 --> 00:08:39,760
such as libraries crypto libraries and

00:08:38,560 --> 00:08:43,360
so on are

00:08:39,760 --> 00:08:46,000
analyzed and we have teams for example

00:08:43,360 --> 00:08:47,600
so-called red teams for penetration

00:08:46,000 --> 00:08:49,920
testing that basically

00:08:47,600 --> 00:08:51,519
take a fresh look at the system and see

00:08:49,920 --> 00:08:54,080
if everything so far

00:08:51,519 --> 00:08:56,720
it has been designed according to best

00:08:54,080 --> 00:08:58,720
practice and standards

00:08:56,720 --> 00:09:00,240
and of course then at some point the

00:08:58,720 --> 00:09:00,959
when the product has been ready for

00:09:00,240 --> 00:09:04,160
shipment

00:09:00,959 --> 00:09:07,120
um the cycle may repeat as

00:09:04,160 --> 00:09:09,200
new threats new vulnerabilities turn up

00:09:07,120 --> 00:09:11,279
new use cases there might be a second

00:09:09,200 --> 00:09:14,080
generation of the product so the this

00:09:11,279 --> 00:09:15,440
whole thing is a circle and will iterate

00:09:14,080 --> 00:09:17,519
over time

00:09:15,440 --> 00:09:18,720
and on the other hand of course for each

00:09:17,519 --> 00:09:20,399
of these steps

00:09:18,720 --> 00:09:22,240
we're always trying to meet the best

00:09:20,399 --> 00:09:23,040
practice and to improve our state of

00:09:22,240 --> 00:09:25,360
arts

00:09:23,040 --> 00:09:26,240
and one item in particular here is

00:09:25,360 --> 00:09:29,360
fuzzing

00:09:26,240 --> 00:09:31,760
fuzzing has been getting

00:09:29,360 --> 00:09:34,240
a lot of traction in academia as well as

00:09:31,760 --> 00:09:35,839
industry is becoming state of art for

00:09:34,240 --> 00:09:37,600
software validation

00:09:35,839 --> 00:09:39,680
in particular security validation of

00:09:37,600 --> 00:09:42,240
software um

00:09:39,680 --> 00:09:43,760
and of course as you will see it can be

00:09:42,240 --> 00:09:45,440
quite difficult actually to apply

00:09:43,760 --> 00:09:46,959
fuzzing when it comes to low-level

00:09:45,440 --> 00:09:50,160
software firmware

00:09:46,959 --> 00:09:52,800
or even things like microcode

00:09:50,160 --> 00:09:54,399
um and and this talk is this is what

00:09:52,800 --> 00:09:56,080
this talk is basically about

00:09:54,399 --> 00:09:57,440
uh looking at the different tools and

00:09:56,080 --> 00:09:59,680
trying to understand

00:09:57,440 --> 00:10:01,600
how they fit to acorn and what we are

00:09:59,680 --> 00:10:04,079
doing in this space to improve on the

00:10:01,600 --> 00:10:05,680
state of wars

00:10:04,079 --> 00:10:07,839
so how does fuzzing what is actually

00:10:05,680 --> 00:10:10,560
fuzzing and how does it work

00:10:07,839 --> 00:10:12,079
fundamentally when you are testing a

00:10:10,560 --> 00:10:14,880
particular

00:10:12,079 --> 00:10:16,000
product or a subsystem of a product you

00:10:14,880 --> 00:10:18,079
would call it a test

00:10:16,000 --> 00:10:20,399
target on the right hand side that might

00:10:18,079 --> 00:10:21,440
be software or firmware or just a

00:10:20,399 --> 00:10:23,200
library and an

00:10:21,440 --> 00:10:24,720
interface that is part of a bigger

00:10:23,200 --> 00:10:26,720
product um

00:10:24,720 --> 00:10:29,360
and in general we can say that this

00:10:26,720 --> 00:10:29,680
piece of software will execute in some

00:10:29,360 --> 00:10:32,720
way

00:10:29,680 --> 00:10:34,800
on an execution platform um

00:10:32,720 --> 00:10:37,040
that might be a linux platform it might

00:10:34,800 --> 00:10:38,880
also be a system-on-chip where firmware

00:10:37,040 --> 00:10:41,680
is executing

00:10:38,880 --> 00:10:43,120
or an emulator and then we have test

00:10:41,680 --> 00:10:46,640
drivers

00:10:43,120 --> 00:10:49,200
which has the task of actually executing

00:10:46,640 --> 00:10:50,320
the target so or exercising the target

00:10:49,200 --> 00:10:53,120
so the particular

00:10:50,320 --> 00:10:55,279
api calls uh to actually launch them

00:10:53,120 --> 00:10:57,920
based on some input

00:10:55,279 --> 00:10:59,839
that is provided externally now in the

00:10:57,920 --> 00:11:02,880
case of fuzzing

00:10:59,839 --> 00:11:05,839
this input tends to be randomized

00:11:02,880 --> 00:11:07,200
and is usually based on a corpus that we

00:11:05,839 --> 00:11:10,320
provide in the beginning

00:11:07,200 --> 00:11:11,279
for example if you're testing a jpeg

00:11:10,320 --> 00:11:14,480
library

00:11:11,279 --> 00:11:17,680
your seed corpus of inputs

00:11:14,480 --> 00:11:18,079
would basically uh be a list of or a set

00:11:17,680 --> 00:11:21,040
of

00:11:18,079 --> 00:11:22,079
jpeg files or you would try to have all

00:11:21,040 --> 00:11:24,640
kinds of different

00:11:22,079 --> 00:11:25,680
jpeg types maybe black and white

00:11:24,640 --> 00:11:28,320
different sizes

00:11:25,680 --> 00:11:30,000
different encodings and so on and then

00:11:28,320 --> 00:11:32,079
you might implement certain

00:11:30,000 --> 00:11:33,440
randomization mechanisms in the further

00:11:32,079 --> 00:11:35,519
to

00:11:33,440 --> 00:11:37,519
to damage these pictures to randomize

00:11:35,519 --> 00:11:38,959
them to recombine them and feed them to

00:11:37,519 --> 00:11:42,160
your test drivers that then

00:11:38,959 --> 00:11:44,079
exercise the target at the end of this

00:11:42,160 --> 00:11:45,920
if you have bugs in your target you will

00:11:44,079 --> 00:11:47,839
get crashes and these

00:11:45,920 --> 00:11:49,279
are of course the things we want out of

00:11:47,839 --> 00:11:51,120
the testing

00:11:49,279 --> 00:11:53,680
we want to fix them we want to analyze

00:11:51,120 --> 00:11:56,000
them and

00:11:53,680 --> 00:11:57,680
achieve a bug free product in the end in

00:11:56,000 --> 00:12:00,160
this way

00:11:57,680 --> 00:12:01,920
without any sort of feedback loop just

00:12:00,160 --> 00:12:02,639
doing it like this this is called blind

00:12:01,920 --> 00:12:05,920
fuzzing

00:12:02,639 --> 00:12:09,200
um it should be kind of

00:12:05,920 --> 00:12:10,480
intuitive that with blind fuzzing you do

00:12:09,200 --> 00:12:14,079
not have a good chance

00:12:10,480 --> 00:12:14,079
to reach really

00:12:14,160 --> 00:12:18,399
inputs that are far away from your

00:12:15,920 --> 00:12:21,040
original input corpus

00:12:18,399 --> 00:12:21,600
unless you define a very good test

00:12:21,040 --> 00:12:23,839
driver

00:12:21,600 --> 00:12:25,440
that implements some of the formatting

00:12:23,839 --> 00:12:26,959
that your target expects some of the

00:12:25,440 --> 00:12:27,920
input formats so called structured

00:12:26,959 --> 00:12:30,720
fuzzing

00:12:27,920 --> 00:12:32,000
or grammar-based fuzzing mutators in the

00:12:30,720 --> 00:12:35,519
further itself

00:12:32,000 --> 00:12:36,000
um the random binary mutation of the

00:12:35,519 --> 00:12:39,440
seats

00:12:36,000 --> 00:12:42,000
will not will usually be discarded

00:12:39,440 --> 00:12:43,519
lead to invalid input early on and not

00:12:42,000 --> 00:12:47,360
reach very deep

00:12:43,519 --> 00:12:49,279
code in your target so there has been

00:12:47,360 --> 00:12:51,680
an extension which made fuzzing much

00:12:49,279 --> 00:12:53,600
more popular and effective recently

00:12:51,680 --> 00:12:57,120
which is the so-called feedback fuzzing

00:12:53,600 --> 00:12:57,120
or coverage guided fuzzing

00:12:57,680 --> 00:13:01,360
in this case the platform actually

00:13:00,639 --> 00:13:03,600
observes

00:13:01,360 --> 00:13:04,720
what is going on or maybe the software

00:13:03,600 --> 00:13:07,680
target has been

00:13:04,720 --> 00:13:09,040
instrumented to record what it's doing

00:13:07,680 --> 00:13:10,720
to record the coverage

00:13:09,040 --> 00:13:12,399
for example that is achieved by a

00:13:10,720 --> 00:13:15,279
particular input

00:13:12,399 --> 00:13:15,760
and that coverage is returned to the

00:13:15,279 --> 00:13:19,120
fuzzer

00:13:15,760 --> 00:13:20,560
as a kind of feedback and the father may

00:13:19,120 --> 00:13:22,800
use that to say

00:13:20,560 --> 00:13:24,639
oh this input has actually triggered

00:13:22,800 --> 00:13:26,880
some new interesting branch

00:13:24,639 --> 00:13:27,760
in my target so i'm not going to throw

00:13:26,880 --> 00:13:30,560
it away and

00:13:27,760 --> 00:13:32,560
and take a new seat input and randomize

00:13:30,560 --> 00:13:35,040
it i'm going to keep that input

00:13:32,560 --> 00:13:37,120
because none of the seeds that currently

00:13:35,040 --> 00:13:40,160
exist that i know of actually reach

00:13:37,120 --> 00:13:43,040
this this particular branch so

00:13:40,160 --> 00:13:44,240
doing this many million times the fuzzer

00:13:43,040 --> 00:13:47,920
will

00:13:44,240 --> 00:13:50,480
iteratively build up a corpus of inputs

00:13:47,920 --> 00:13:53,040
randomize them splice them against each

00:13:50,480 --> 00:13:56,880
other and find more interesting inputs

00:13:53,040 --> 00:13:58,880
that solve a lot of the typical branches

00:13:56,880 --> 00:14:02,320
and conditions and corner cases

00:13:58,880 --> 00:14:04,560
in our typical software products

00:14:02,320 --> 00:14:06,399
um and doing this of course you will get

00:14:04,560 --> 00:14:09,600
a much better coverage

00:14:06,399 --> 00:14:12,000
out of the overall fastest

00:14:09,600 --> 00:14:13,199
um that in turn of course leads to more

00:14:12,000 --> 00:14:14,880
interesting

00:14:13,199 --> 00:14:16,639
corner cases that are being covered and

00:14:14,880 --> 00:14:18,160
therefore also potential crashes that

00:14:16,639 --> 00:14:20,079
might turn up

00:14:18,160 --> 00:14:22,079
and that's of course what we want right

00:14:20,079 --> 00:14:24,560
we want to find these crashes and bugs

00:14:22,079 --> 00:14:28,399
before the software is being ready for

00:14:24,560 --> 00:14:28,399
shipping and before this deployed and

00:14:28,839 --> 00:14:33,279
products

00:14:30,160 --> 00:14:34,880
um finally um for those of you who have

00:14:33,279 --> 00:14:36,320
already heard about fuzzing there's of

00:14:34,880 --> 00:14:38,079
course lots of other aspects

00:14:36,320 --> 00:14:40,480
which are not so much in the focus of

00:14:38,079 --> 00:14:42,880
this talk um

00:14:40,480 --> 00:14:44,240
once you have this system in place there

00:14:42,880 --> 00:14:46,639
is of course a lot of

00:14:44,240 --> 00:14:47,440
additional aspects such as the overall

00:14:46,639 --> 00:14:51,120
automation

00:14:47,440 --> 00:14:54,320
and integration of your buzzing campaign

00:14:51,120 --> 00:14:55,920
um the triage of the

00:14:54,320 --> 00:14:58,160
the crashes that you find you need to

00:14:55,920 --> 00:15:00,320
sort them out you need to find out uh

00:14:58,160 --> 00:15:02,240
you need to diagnose what is going on

00:15:00,320 --> 00:15:04,079
and if you imagine if you get thousands

00:15:02,240 --> 00:15:05,040
of crashes out of such a campaign you

00:15:04,079 --> 00:15:07,279
actually need to sort

00:15:05,040 --> 00:15:09,120
you need to start automating this

00:15:07,279 --> 00:15:10,399
process and sorting out which treasures

00:15:09,120 --> 00:15:11,360
are relevant which are the same

00:15:10,399 --> 00:15:13,760
treasures and

00:15:11,360 --> 00:15:15,600
and who should fix them so there's a lot

00:15:13,760 --> 00:15:18,560
of work in all of these areas

00:15:15,600 --> 00:15:22,880
um and many of them are also subject of

00:15:18,560 --> 00:15:22,880
extensive research in academia right now

00:15:23,839 --> 00:15:26,959
but let's get back to fuzzing for

00:15:25,839 --> 00:15:29,600
software validation

00:15:26,959 --> 00:15:31,519
if we are as uh basically if we are

00:15:29,600 --> 00:15:34,160
looking for product assurance

00:15:31,519 --> 00:15:35,199
um we have slightly different goals than

00:15:34,160 --> 00:15:37,680
maybe you have heard

00:15:35,199 --> 00:15:39,600
from from uh fuzzing that is that is

00:15:37,680 --> 00:15:42,560
used elsewhere in the community

00:15:39,600 --> 00:15:43,519
our goal is not to run a further once

00:15:42,560 --> 00:15:46,480
find the bug

00:15:43,519 --> 00:15:47,040
and report it or get the bug bounty for

00:15:46,480 --> 00:15:50,000
it

00:15:47,040 --> 00:15:50,560
but our goal in is actually increasing

00:15:50,000 --> 00:15:52,000
the

00:15:50,560 --> 00:15:54,079
software validation increasing the

00:15:52,000 --> 00:15:57,759
assurance that you achieve

00:15:54,079 --> 00:16:01,519
when deploying acorn as a security

00:15:57,759 --> 00:16:04,160
product in iot so what counts

00:16:01,519 --> 00:16:05,360
in this case is actually much more the

00:16:04,160 --> 00:16:07,920
overall

00:16:05,360 --> 00:16:09,360
usability of the tool the long-term

00:16:07,920 --> 00:16:12,800
return of investment

00:16:09,360 --> 00:16:15,040
so given that you have this setup

00:16:12,800 --> 00:16:16,880
how easy is it to automate it how easy

00:16:15,040 --> 00:16:19,440
is it to integrate with

00:16:16,880 --> 00:16:21,040
existing validation packets how good is

00:16:19,440 --> 00:16:24,320
the overall performance

00:16:21,040 --> 00:16:27,440
can is it easy to debug to automate

00:16:24,320 --> 00:16:28,880
and in particular the the developers or

00:16:27,440 --> 00:16:31,040
the software validators who are in

00:16:28,880 --> 00:16:33,519
charge of the products

00:16:31,040 --> 00:16:35,279
is it easy or manageable for them to

00:16:33,519 --> 00:16:37,839
actually

00:16:35,279 --> 00:16:40,320
understand the solution and extend the

00:16:37,839 --> 00:16:42,720
solution for example writing further

00:16:40,320 --> 00:16:44,000
test drivers that exercise more of the

00:16:42,720 --> 00:16:46,480
code

00:16:44,000 --> 00:16:48,079
so these are all very important aspects

00:16:46,480 --> 00:16:49,360
for product assurance which are not

00:16:48,079 --> 00:16:51,759
necessarily

00:16:49,360 --> 00:16:55,920
the highest priority when you do fuzzing

00:16:51,759 --> 00:16:55,920
for bug bounty or penetration testing

00:16:56,720 --> 00:17:02,399
and with that i give back to mustafar

00:16:59,680 --> 00:17:04,880
who has looked at various tools

00:17:02,399 --> 00:17:06,799
to see what is the most effective and

00:17:04,880 --> 00:17:08,880
state of our tools for furthering a

00:17:06,799 --> 00:17:12,400
hypervisor

00:17:08,880 --> 00:17:14,640
thanks stefan so as stefan mentioned

00:17:12,400 --> 00:17:15,600
there are different goals that we have

00:17:14,640 --> 00:17:17,520
when we try to

00:17:15,600 --> 00:17:19,600
when we when we decide to integrate

00:17:17,520 --> 00:17:21,919
fuzzing into our acron offensive

00:17:19,600 --> 00:17:23,600
security validation cycles and so on to

00:17:21,919 --> 00:17:24,640
make the product much more secure and

00:17:23,600 --> 00:17:27,039
robust

00:17:24,640 --> 00:17:28,640
so the first thing we asked ourselves

00:17:27,039 --> 00:17:30,960
before even starting to

00:17:28,640 --> 00:17:32,080
pick tools and and choose what to start

00:17:30,960 --> 00:17:34,880
with the first question

00:17:32,080 --> 00:17:36,400
was we took a deeper look into the

00:17:34,880 --> 00:17:39,200
security architecture

00:17:36,400 --> 00:17:40,320
and we try to identify what are the most

00:17:39,200 --> 00:17:42,080
critical

00:17:40,320 --> 00:17:44,240
software components that we should look

00:17:42,080 --> 00:17:47,039
into basically we have

00:17:44,240 --> 00:17:49,039
three main component as part of our tcb

00:17:47,039 --> 00:17:49,760
or the trusted computing base and that

00:17:49,039 --> 00:17:51,600
is the

00:17:49,760 --> 00:17:53,039
hypervisor which runs directly on your

00:17:51,600 --> 00:17:54,559
hardware resources

00:17:53,039 --> 00:17:58,000
another kernel module which is called

00:17:54,559 --> 00:18:00,640
vhm which is the verta io and hypervisor

00:17:58,000 --> 00:18:02,480
service module and finally the device

00:18:00,640 --> 00:18:04,400
model in user space

00:18:02,480 --> 00:18:05,760
all these these three components

00:18:04,400 --> 00:18:06,799
communicate with each other so the

00:18:05,760 --> 00:18:10,000
device model is

00:18:06,799 --> 00:18:12,160
is nothing but something similar to that

00:18:10,000 --> 00:18:13,039
kimono-like application which has two

00:18:12,160 --> 00:18:16,720
main tasks

00:18:13,039 --> 00:18:19,760
first is to create or configure new

00:18:16,720 --> 00:18:21,919
guest vms and store those guest vms and

00:18:19,760 --> 00:18:24,960
the second task is to

00:18:21,919 --> 00:18:27,039
have an emulation back end or

00:18:24,960 --> 00:18:29,679
provide some of the emulation services

00:18:27,039 --> 00:18:30,160
for those guest vms in order to utilize

00:18:29,679 --> 00:18:33,440
and do

00:18:30,160 --> 00:18:35,120
resource sharing for the vhm it's

00:18:33,440 --> 00:18:37,039
it's a middle layer between the device

00:18:35,120 --> 00:18:38,720
model and the hypervisor that

00:18:37,039 --> 00:18:40,320
supports the device model in making

00:18:38,720 --> 00:18:42,799
communication with the hypervisor

00:18:40,320 --> 00:18:44,960
through down calls and also support the

00:18:42,799 --> 00:18:46,400
hypervisor to notify the device model

00:18:44,960 --> 00:18:49,440
with some of the requests through

00:18:46,400 --> 00:18:50,799
up calls of course there are other

00:18:49,440 --> 00:18:53,039
components which is

00:18:50,799 --> 00:18:55,280
not part of our tcp however they are

00:18:53,039 --> 00:18:57,679
very critical to the overall

00:18:55,280 --> 00:18:59,200
system operation things like the vert i

00:18:57,679 --> 00:19:02,000
o front end drivers which

00:18:59,200 --> 00:19:04,080
is how the user vm try to achieve power

00:19:02,000 --> 00:19:05,600
virtualization how they

00:19:04,080 --> 00:19:07,120
actually achieve sharing of hardware

00:19:05,600 --> 00:19:08,799
resources how they communicate to the

00:19:07,120 --> 00:19:10,480
device model back-end

00:19:08,799 --> 00:19:12,559
there are also the divided emulated

00:19:10,480 --> 00:19:14,160
device drivers that

00:19:12,559 --> 00:19:16,080
some of the devices are directly

00:19:14,160 --> 00:19:17,200
emulated using trap and emulate and

00:19:16,080 --> 00:19:18,880
those are memory region in the

00:19:17,200 --> 00:19:20,960
hypervisor that are

00:19:18,880 --> 00:19:22,559
tracked by the hypervisor in a way in

00:19:20,960 --> 00:19:25,120
order to see if there are any requests

00:19:22,559 --> 00:19:27,039
or operation happening on them

00:19:25,120 --> 00:19:30,480
finally we have the pass-through drivers

00:19:27,039 --> 00:19:30,480
and the pass-through drivers are

00:19:30,720 --> 00:19:34,480
some of the devices that for example

00:19:32,720 --> 00:19:36,240
acron hypervisor have that

00:19:34,480 --> 00:19:38,240
the possibility to dedicate some of the

00:19:36,240 --> 00:19:40,320
pci devices to to the vms

00:19:38,240 --> 00:19:42,160
you can think of a real-time vm where we

00:19:40,320 --> 00:19:44,080
want to assign a device directly to this

00:19:42,160 --> 00:19:45,039
vm and be directly under the control of

00:19:44,080 --> 00:19:46,880
this vm

00:19:45,039 --> 00:19:48,480
in this case we assign this device to

00:19:46,880 --> 00:19:48,960
the vm and then we use the passthrough

00:19:48,480 --> 00:19:51,360
driver

00:19:48,960 --> 00:19:52,240
in order to make those vms directly

00:19:51,360 --> 00:19:55,520
communicate with

00:19:52,240 --> 00:19:59,520
with those devices so

00:19:55,520 --> 00:20:01,919
that looks great so even going one

00:19:59,520 --> 00:20:03,600
step deeper and trying to see from each

00:20:01,919 --> 00:20:05,600
component perspective so from the

00:20:03,600 --> 00:20:07,440
hypervisor perspective this

00:20:05,600 --> 00:20:09,840
the hypervisor run in a in a more

00:20:07,440 --> 00:20:12,000
privileged mood called vmx root mode

00:20:09,840 --> 00:20:13,760
where any software that runs on top of

00:20:12,000 --> 00:20:16,559
it either in the service vm or in the

00:20:13,760 --> 00:20:18,720
guest vm is considered untrusted

00:20:16,559 --> 00:20:20,720
from the vhm perspective the hypervisor

00:20:18,720 --> 00:20:21,039
is the only trusted component but any

00:20:20,720 --> 00:20:22,720
other

00:20:21,039 --> 00:20:26,240
software that is running in the service

00:20:22,720 --> 00:20:29,520
vm user space or even in the user vms

00:20:26,240 --> 00:20:30,640
is considered untrusted finally going to

00:20:29,520 --> 00:20:32,720
the device model

00:20:30,640 --> 00:20:34,080
where it runs in the service vm user

00:20:32,720 --> 00:20:36,720
space it

00:20:34,080 --> 00:20:38,000
it considers the vhm and the hypervisor

00:20:36,720 --> 00:20:40,559
as trusted components

00:20:38,000 --> 00:20:43,120
but anything outside those uh components

00:20:40,559 --> 00:20:45,360
is untrusted so any kind of data or code

00:20:43,120 --> 00:20:48,720
that is coming from the user vms or

00:20:45,360 --> 00:20:51,840
and so on so that is that

00:20:48,720 --> 00:20:54,400
the security architecture for acron

00:20:51,840 --> 00:20:56,000
looking to this security architecture

00:20:54,400 --> 00:20:58,159
from a different perspective so if we

00:20:56,000 --> 00:21:00,000
focus on the interfaces and how these

00:20:58,159 --> 00:21:01,679
components communicate with each other

00:21:00,000 --> 00:21:04,000
from security perspective we find that

00:21:01,679 --> 00:21:05,919
we have different set of interfaces

00:21:04,000 --> 00:21:07,200
first we have an interface between the

00:21:05,919 --> 00:21:10,880
service vm

00:21:07,200 --> 00:21:14,640
uh vhm kernel module and the hypervisor

00:21:10,880 --> 00:21:16,640
and they communicate through hyper calls

00:21:14,640 --> 00:21:17,760
the second interface is how the user

00:21:16,640 --> 00:21:19,679
space application

00:21:17,760 --> 00:21:21,440
in specific the device model or any

00:21:19,679 --> 00:21:23,280
other user space application that might

00:21:21,440 --> 00:21:25,280
communicate with the vhm

00:21:23,280 --> 00:21:27,760
through our second interface which is

00:21:25,280 --> 00:21:29,520
normal syscalls or traditional os way to

00:21:27,760 --> 00:21:30,480
communicate between user space and

00:21:29,520 --> 00:21:32,960
kernel

00:21:30,480 --> 00:21:35,120
through ioctals and and generally system

00:21:32,960 --> 00:21:37,520
calls

00:21:35,120 --> 00:21:39,360
the third interface is the device model

00:21:37,520 --> 00:21:42,559
as we mentioned one task for the device

00:21:39,360 --> 00:21:45,120
model is to configure new

00:21:42,559 --> 00:21:46,080
vms and configure new guests for that we

00:21:45,120 --> 00:21:48,000
have

00:21:46,080 --> 00:21:49,679
a command line interface that allow us

00:21:48,000 --> 00:21:51,600
to pass some of the configuration and

00:21:49,679 --> 00:21:53,760
the parameters that we want to pass to

00:21:51,600 --> 00:21:55,600
the device model to create those vms

00:21:53,760 --> 00:21:58,080
so there is a command line interface a

00:21:55,600 --> 00:22:01,120
standard stdio interface

00:21:58,080 --> 00:22:04,000
where device model accepts some input

00:22:01,120 --> 00:22:04,000
through the command line

00:22:04,480 --> 00:22:09,039
from user vm perspective so we have the

00:22:06,799 --> 00:22:11,039
vert io front end driver that exists in

00:22:09,039 --> 00:22:12,960
the user vms that communicate with the

00:22:11,039 --> 00:22:13,280
device model or the vert are you back

00:22:12,960 --> 00:22:16,320
and

00:22:13,280 --> 00:22:17,919
drivers and that is happening through

00:22:16,320 --> 00:22:19,760
vert io devices so in para

00:22:17,919 --> 00:22:22,159
virtualization those

00:22:19,760 --> 00:22:23,919
iot devices are nothing but pci devices

00:22:22,159 --> 00:22:26,640
that is

00:22:23,919 --> 00:22:27,760
contain some of the mmio region and and

00:22:26,640 --> 00:22:30,159
have pi

00:22:27,760 --> 00:22:32,159
so pio and mmi lesion in order to

00:22:30,159 --> 00:22:33,039
emulate those devices so some regions

00:22:32,159 --> 00:22:35,360
are used

00:22:33,039 --> 00:22:36,640
for emulated for emulated devices we

00:22:35,360 --> 00:22:38,880
also use mmi

00:22:36,640 --> 00:22:40,080
dma in order to access some of these

00:22:38,880 --> 00:22:43,120
devices which is not

00:22:40,080 --> 00:22:45,200
para virtualized but rather really

00:22:43,120 --> 00:22:47,600
emulated

00:22:45,200 --> 00:22:48,240
and ah so and and and we have passed

00:22:47,600 --> 00:22:50,880
through so

00:22:48,240 --> 00:22:52,320
pass-through is also using pio in order

00:22:50,880 --> 00:22:53,120
to communicate with those hardware

00:22:52,320 --> 00:22:55,280
resources so

00:22:53,120 --> 00:22:57,600
the last three interfaces so four five

00:22:55,280 --> 00:23:00,159
and six focuses more on the

00:22:57,600 --> 00:23:02,960
memory regions that is trapped and

00:23:00,159 --> 00:23:05,120
emulated or handled by the hypervisor in

00:23:02,960 --> 00:23:06,240
a way in order to be serviced either in

00:23:05,120 --> 00:23:09,520
the hypervisor

00:23:06,240 --> 00:23:12,400
or by the service vm

00:23:09,520 --> 00:23:13,280
so those are all the security interfaces

00:23:12,400 --> 00:23:15,919
that we have so

00:23:13,280 --> 00:23:18,080
the question now what tools fit better

00:23:15,919 --> 00:23:21,679
to those components or what tools would

00:23:18,080 --> 00:23:23,760
work better to target those interfaces

00:23:21,679 --> 00:23:24,720
so the first tool that we picked was the

00:23:23,760 --> 00:23:27,600
syscaller

00:23:24,720 --> 00:23:29,760
and syscolar is a coverage guided

00:23:27,600 --> 00:23:31,679
structure aware kernel fuzzer

00:23:29,760 --> 00:23:33,600
it is very well established with

00:23:31,679 --> 00:23:37,120
tremendous linux support

00:23:33,600 --> 00:23:38,880
and we use says caller in in in

00:23:37,120 --> 00:23:40,799
targeting two interfaces

00:23:38,880 --> 00:23:43,360
one which is the traditional usage model

00:23:40,799 --> 00:23:46,320
for for for syscaller which is the

00:23:43,360 --> 00:23:47,520
kernel module so here is the vhm and

00:23:46,320 --> 00:23:50,240
another

00:23:47,520 --> 00:23:52,400
approach that we tried is also extending

00:23:50,240 --> 00:23:54,320
syscolar in a way that we can target

00:23:52,400 --> 00:23:58,080
the hyper code so the interface between

00:23:54,320 --> 00:23:58,080
the vhm and the hypervisor

00:23:59,360 --> 00:24:05,679
so what is the vhm so

00:24:03,679 --> 00:24:07,520
let's take a deeper look into the vhm

00:24:05,679 --> 00:24:08,400
and hypervisor how did we actually

00:24:07,520 --> 00:24:10,880
target

00:24:08,400 --> 00:24:11,679
those um the code base in both

00:24:10,880 --> 00:24:14,000
components

00:24:11,679 --> 00:24:15,039
so the vhm as we mentioned is a middle

00:24:14,000 --> 00:24:18,799
layer with with some

00:24:15,039 --> 00:24:20,720
services tasks or some modules or some

00:24:18,799 --> 00:24:22,400
handlers that would allow

00:24:20,720 --> 00:24:24,799
user space device model to talk to the

00:24:22,400 --> 00:24:28,000
hypervisor those kind of

00:24:24,799 --> 00:24:30,080
handles do diverse tasks

00:24:28,000 --> 00:24:31,600
things like vm management to create

00:24:30,080 --> 00:24:33,760
starts of vms

00:24:31,600 --> 00:24:35,440
it can also work with interrupts and

00:24:33,760 --> 00:24:37,840
handling interrupts

00:24:35,440 --> 00:24:39,919
it can even go further to handle the i o

00:24:37,840 --> 00:24:41,679
requests and try to mention it

00:24:39,919 --> 00:24:43,919
either from the hypervisor to the device

00:24:41,679 --> 00:24:46,240
model and so on

00:24:43,919 --> 00:24:48,400
so picking the vm management so we have

00:24:46,240 --> 00:24:50,640
api like hyper code create vm

00:24:48,400 --> 00:24:52,880
as you see in this api we have two

00:24:50,640 --> 00:24:53,840
parameters or payloads that is being

00:24:52,880 --> 00:24:56,400
passed as pos

00:24:53,840 --> 00:24:57,360
as part of the hypervisor those two

00:24:56,400 --> 00:24:59,520
parameters

00:24:57,360 --> 00:25:03,760
is a potential candidate that can be

00:24:59,520 --> 00:25:06,240
fuzzed what if we inject some malformed

00:25:03,760 --> 00:25:07,039
pieces of data or malford kind of data

00:25:06,240 --> 00:25:08,480
structures

00:25:07,039 --> 00:25:11,440
into those parameters how would the

00:25:08,480 --> 00:25:12,960
hypervisor behave

00:25:11,440 --> 00:25:15,520
another kind of services that is

00:25:12,960 --> 00:25:17,760
happening at run time so if a service vm

00:25:15,520 --> 00:25:20,159
is or if a guest vm is running

00:25:17,760 --> 00:25:22,159
this guest vm has to send kind of

00:25:20,159 --> 00:25:25,520
request to the to the service vm

00:25:22,159 --> 00:25:26,880
so these requests usually require things

00:25:25,520 --> 00:25:29,279
like notifying the

00:25:26,880 --> 00:25:30,720
the the vhm and knowing that those

00:25:29,279 --> 00:25:31,840
certification has been handled and

00:25:30,720 --> 00:25:33,760
finished and so on

00:25:31,840 --> 00:25:35,600
so as you see as well it has some

00:25:33,760 --> 00:25:38,799
payloads or some parameters that

00:25:35,600 --> 00:25:40,320
is potential candidates to be fuzzed so

00:25:38,799 --> 00:25:42,640
the goal here is

00:25:40,320 --> 00:25:44,320
first to fuzz the ioctans going from the

00:25:42,640 --> 00:25:47,360
device model down to the

00:25:44,320 --> 00:25:50,880
vhm module and then later to propagate

00:25:47,360 --> 00:25:53,760
some of the fuzz input from the vhm

00:25:50,880 --> 00:25:55,279
down to the hypervisor so how did we do

00:25:53,760 --> 00:25:58,080
that

00:25:55,279 --> 00:25:58,880
so says caller so how does this caller

00:25:58,080 --> 00:26:01,520
actually work

00:25:58,880 --> 00:26:02,080
so says caller can operate in what's

00:26:01,520 --> 00:26:04,320
called

00:26:02,080 --> 00:26:05,520
remote mode or isolated mode where we

00:26:04,320 --> 00:26:07,279
can have some of these

00:26:05,520 --> 00:26:09,600
color component run in a separate

00:26:07,279 --> 00:26:10,080
machine and then it start fuzzing the

00:26:09,600 --> 00:26:12,240
target

00:26:10,080 --> 00:26:13,520
machine which is totally remote or

00:26:12,240 --> 00:26:15,679
isolated

00:26:13,520 --> 00:26:17,120
this caller contain different components

00:26:15,679 --> 00:26:19,840
some of them run on the host

00:26:17,120 --> 00:26:20,799
things like the sys manager which is

00:26:19,840 --> 00:26:23,760
responsible for

00:26:20,799 --> 00:26:24,720
starting and managing those vms that we

00:26:23,760 --> 00:26:26,799
want to uh

00:26:24,720 --> 00:26:28,960
test or that contains the software that

00:26:26,799 --> 00:26:31,039
we want to test

00:26:28,960 --> 00:26:33,120
it's also responsible for copying some

00:26:31,039 --> 00:26:35,600
of the other components things like the

00:26:33,120 --> 00:26:36,480
says father and sis fuzzer is a process

00:26:35,600 --> 00:26:38,640
that

00:26:36,480 --> 00:26:39,600
is running on the unstable vm or the

00:26:38,640 --> 00:26:41,919
target vm

00:26:39,600 --> 00:26:43,760
and it is response responsible for

00:26:41,919 --> 00:26:46,320
things like input mutation

00:26:43,760 --> 00:26:47,440
uh input generation minimization and so

00:26:46,320 --> 00:26:49,520
on

00:26:47,440 --> 00:26:51,679
so some of the input is generated by cis

00:26:49,520 --> 00:26:53,760
fuzzer is propagated to what's called

00:26:51,679 --> 00:26:54,240
the sys executor that takes a single

00:26:53,760 --> 00:26:57,760
input

00:26:54,240 --> 00:27:00,400
and creates some kind of

00:26:57,760 --> 00:27:02,080
calls or or fuzzing programs that can be

00:27:00,400 --> 00:27:04,480
propagated to the target

00:27:02,080 --> 00:27:06,320
in our case we implemented a test proxy

00:27:04,480 --> 00:27:08,480
that lives inside the device model

00:27:06,320 --> 00:27:10,320
and takes those input and then propagate

00:27:08,480 --> 00:27:13,520
them to the vhm first

00:27:10,320 --> 00:27:15,679
and later to the hypervisor so the idea

00:27:13,520 --> 00:27:19,600
here as we've seen in in the last slide

00:27:15,679 --> 00:27:20,559
those apis like for creating vm or

00:27:19,600 --> 00:27:22,960
notifying the

00:27:20,559 --> 00:27:23,760
the uh the end or the finish of io

00:27:22,960 --> 00:27:26,720
request

00:27:23,760 --> 00:27:28,799
can be fuzzed first in the vhm layer so

00:27:26,720 --> 00:27:31,120
we would see if any issues or any

00:27:28,799 --> 00:27:32,880
crashes or missing validation is

00:27:31,120 --> 00:27:35,039
happening in the vhm layer

00:27:32,880 --> 00:27:36,799
and the good thing is that we success

00:27:35,039 --> 00:27:38,399
caller instrument the kernel or

00:27:36,799 --> 00:27:40,640
it gives the possibility to instrument

00:27:38,399 --> 00:27:42,799
the kernel and with this we would get

00:27:40,640 --> 00:27:44,799
coverage information from the vhm module

00:27:42,799 --> 00:27:46,320
so we really know what kind of execution

00:27:44,799 --> 00:27:48,080
paths have we experienced

00:27:46,320 --> 00:27:51,520
and so on which would allow us to

00:27:48,080 --> 00:27:51,520
reproduce any issues that happen

00:27:51,600 --> 00:27:56,399
sorry so later those kind of

00:27:54,880 --> 00:27:58,240
of coverage information would be

00:27:56,399 --> 00:28:00,480
propagated back to the sys manager and

00:27:58,240 --> 00:28:03,039
it keeps a little database that knows

00:28:00,480 --> 00:28:04,559
or that that manages some of the corpus

00:28:03,039 --> 00:28:07,919
that created those crashes

00:28:04,559 --> 00:28:10,320
in the vhm the second part is

00:28:07,919 --> 00:28:11,520
what the extension that we made is to

00:28:10,320 --> 00:28:13,840
take those fuzz input

00:28:11,520 --> 00:28:15,360
and even propagate them one layer down

00:28:13,840 --> 00:28:17,200
to the hypervisor so

00:28:15,360 --> 00:28:20,320
we take the fuzz input from this

00:28:17,200 --> 00:28:21,840
executor try to fuzz the vhm

00:28:20,320 --> 00:28:23,520
if something happened we would know

00:28:21,840 --> 00:28:24,880
because we get coverage information if

00:28:23,520 --> 00:28:27,120
not we can propagate it to the

00:28:24,880 --> 00:28:29,600
hypervisor so it would allow us to fuzz

00:28:27,120 --> 00:28:30,880
all the hypercoals that is happening

00:28:29,600 --> 00:28:34,480
between the vhm

00:28:30,880 --> 00:28:37,760
and the hypervisor so in general

00:28:34,480 --> 00:28:39,720
cisco is a very stable tool it's

00:28:37,760 --> 00:28:40,880
it's it's it has a lot of these

00:28:39,720 --> 00:28:43,760
disadvantages

00:28:40,880 --> 00:28:46,240
being well supported by the community

00:28:43,760 --> 00:28:48,000
it's easy to use so it provides some

00:28:46,240 --> 00:28:49,679
declarative description for those

00:28:48,000 --> 00:28:51,120
structure that we want to fuzz using a

00:28:49,679 --> 00:28:53,039
language called syslang

00:28:51,120 --> 00:28:54,240
it allows us to do fault injection

00:28:53,039 --> 00:28:56,720
sanitization

00:28:54,240 --> 00:28:57,760
and even automation using components

00:28:56,720 --> 00:29:00,559
like syspot

00:28:57,760 --> 00:29:01,840
and a possibility to reproduce those

00:29:00,559 --> 00:29:04,000
thing and minimize those

00:29:01,840 --> 00:29:05,760
uh fuzz inputs using things like system

00:29:04,000 --> 00:29:08,480
pro

00:29:05,760 --> 00:29:08,880
the bad side for or the the downside for

00:29:08,480 --> 00:29:10,640
using

00:29:08,880 --> 00:29:12,240
this assist caller with fuzzing the

00:29:10,640 --> 00:29:14,240
hypervisor is that we do

00:29:12,240 --> 00:29:15,440
blind fuzzing for the hypervisor in the

00:29:14,240 --> 00:29:17,840
sense that we do not get

00:29:15,440 --> 00:29:19,120
fuzzing uh so coverage information from

00:29:17,840 --> 00:29:22,159
the hypervisor

00:29:19,120 --> 00:29:23,679
and in case we need to do that since a

00:29:22,159 --> 00:29:25,360
hypervisor is not a user space

00:29:23,679 --> 00:29:26,000
application it can it cannot use the

00:29:25,360 --> 00:29:27,600
compiler

00:29:26,000 --> 00:29:29,840
libraries in order to get coverage

00:29:27,600 --> 00:29:32,159
information we need to put some of the

00:29:29,840 --> 00:29:34,320
coverage libraries into the hypervisor

00:29:32,159 --> 00:29:35,360
source code things like gcov and so on

00:29:34,320 --> 00:29:36,720
in order to get

00:29:35,360 --> 00:29:38,880
row coverage information from the

00:29:36,720 --> 00:29:42,559
hypervisor so

00:29:38,880 --> 00:29:43,120
this was says caller the next component

00:29:42,559 --> 00:29:45,279
is the

00:29:43,120 --> 00:29:47,840
device model command line and here we

00:29:45,279 --> 00:29:50,080
want to fuzz this user space application

00:29:47,840 --> 00:29:52,000
and lip fuzzer is a very good candidate

00:29:50,080 --> 00:29:52,799
to do such tasks so it's a coverage

00:29:52,000 --> 00:29:56,000
guided

00:29:52,799 --> 00:29:56,880
fuzzer that is working as an in-process

00:29:56,000 --> 00:29:59,520
fuzzer

00:29:56,880 --> 00:30:01,760
and we have we used lib fuzzer in order

00:29:59,520 --> 00:30:04,399
to target the command line parameters so

00:30:01,760 --> 00:30:06,399
can we fuzz those command line

00:30:04,399 --> 00:30:08,960
configuration and see if that would

00:30:06,399 --> 00:30:11,200
impact the device model

00:30:08,960 --> 00:30:12,799
so how we did that before we're talking

00:30:11,200 --> 00:30:14,080
about how we did that so the device

00:30:12,799 --> 00:30:16,720
model from inside

00:30:14,080 --> 00:30:17,679
as we mentioned has three main

00:30:16,720 --> 00:30:20,799
components

00:30:17,679 --> 00:30:22,720
first it configures vms or pass those

00:30:20,799 --> 00:30:25,520
parameters to configure the vms

00:30:22,720 --> 00:30:26,480
and the second thing is to provide those

00:30:25,520 --> 00:30:28,799
emulation

00:30:26,480 --> 00:30:30,720
back ends for legacy devices or for vert

00:30:28,799 --> 00:30:33,600
io devices

00:30:30,720 --> 00:30:35,679
starting with the vm configuration so

00:30:33,600 --> 00:30:38,880
how we implemented

00:30:35,679 --> 00:30:41,120
lib fuzzer is first you instrument

00:30:38,880 --> 00:30:43,600
the device model binary so the device

00:30:41,120 --> 00:30:45,600
model is just a command line utility you

00:30:43,600 --> 00:30:48,799
can pass some of the

00:30:45,600 --> 00:30:51,200
arguments to configure for example the

00:30:48,799 --> 00:30:53,120
graphics uh some some of the for example

00:30:51,200 --> 00:30:55,679
the graphics configuration things like

00:30:53,120 --> 00:30:56,320
uh fence registers uh graphics hidden

00:30:55,679 --> 00:30:58,799
memory

00:30:56,320 --> 00:31:00,799
memory aperture and it allow you to

00:30:58,799 --> 00:31:04,000
assign some of the devices as you see

00:31:00,799 --> 00:31:06,480
in the minus s command so we we would

00:31:04,000 --> 00:31:07,519
give some of the vert io devices and and

00:31:06,480 --> 00:31:09,919
enable them for

00:31:07,519 --> 00:31:12,000
for a user vm it also allow you to

00:31:09,919 --> 00:31:12,799
configure memory sizes for the user vm

00:31:12,000 --> 00:31:15,840
so that's how

00:31:12,799 --> 00:31:18,320
a device model work we took

00:31:15,840 --> 00:31:18,960
those configuration and we inject them

00:31:18,320 --> 00:31:21,440
to the

00:31:18,960 --> 00:31:24,480
lip fuzzer entry function which is

00:31:21,440 --> 00:31:27,600
called llbm fuzzer test1 input

00:31:24,480 --> 00:31:29,360
and this function in our implementation

00:31:27,600 --> 00:31:32,320
does nothing but taking this

00:31:29,360 --> 00:31:33,919
configuration dm file try to transform

00:31:32,320 --> 00:31:35,840
it into a data structure

00:31:33,919 --> 00:31:37,600
and then inject one of the fuzzing input

00:31:35,840 --> 00:31:40,640
to one entry of this

00:31:37,600 --> 00:31:40,640
configuration file

00:31:41,679 --> 00:31:46,000
then we call the main function or the

00:31:44,159 --> 00:31:48,080
main function inside the device model

00:31:46,000 --> 00:31:50,159
that that's that organic starting point

00:31:48,080 --> 00:31:53,279
for the device model and then

00:31:50,159 --> 00:31:55,279
the fuzz input would be propagated to

00:31:53,279 --> 00:31:57,120
the parser or the part of the device

00:31:55,279 --> 00:31:59,679
model that is responsible to take those

00:31:57,120 --> 00:32:01,519
input and try to cut them into

00:31:59,679 --> 00:32:03,600
smaller parts and propagate them to the

00:32:01,519 --> 00:32:06,960
main function

00:32:03,600 --> 00:32:07,760
in case we have a crash then this

00:32:06,960 --> 00:32:10,640
function would

00:32:07,760 --> 00:32:12,000
retain return back to the llvm fuzzer

00:32:10,640 --> 00:32:13,679
one input function

00:32:12,000 --> 00:32:15,679
if not then it would continue to

00:32:13,679 --> 00:32:16,720
propagate those input to the other main

00:32:15,679 --> 00:32:18,720
functions things like

00:32:16,720 --> 00:32:20,880
creating vms or like loading the

00:32:18,720 --> 00:32:22,640
software or doing all the

00:32:20,880 --> 00:32:24,880
core parts of the device model to

00:32:22,640 --> 00:32:28,240
configure a vm

00:32:24,880 --> 00:32:30,240
if this kind of operation works or fails

00:32:28,240 --> 00:32:31,840
at the end we would know because we

00:32:30,240 --> 00:32:35,039
would get feedback from

00:32:31,840 --> 00:32:36,640
such uh binary or from the device model

00:32:35,039 --> 00:32:39,760
to this function and then we would be

00:32:36,640 --> 00:32:41,679
able to mutate the input and

00:32:39,760 --> 00:32:44,559
tackle new parts of the device model

00:32:41,679 --> 00:32:46,799
code so the first part of of the

00:32:44,559 --> 00:32:48,559
function as you see is initializing

00:32:46,799 --> 00:32:50,880
those

00:32:48,559 --> 00:32:52,799
configuration based on fuzz input and

00:32:50,880 --> 00:32:55,679
the second part is executing

00:32:52,799 --> 00:32:56,559
the main function based on default input

00:32:55,679 --> 00:32:58,640
so

00:32:56,559 --> 00:33:00,399
live fuzzer has a lot of advantages

00:32:58,640 --> 00:33:02,159
being very fast

00:33:00,399 --> 00:33:04,960
it's a standard tool it's a state of our

00:33:02,159 --> 00:33:06,559
tool it's very easy to set up and

00:33:04,960 --> 00:33:08,559
it gives us also the possibility to

00:33:06,559 --> 00:33:09,200
enable different sanitizers things like

00:33:08,559 --> 00:33:12,640
msan

00:33:09,200 --> 00:33:14,880
apps absent json and so on

00:33:12,640 --> 00:33:16,640
one of the or some of the disadvantage

00:33:14,880 --> 00:33:20,159
that we faced is that

00:33:16,640 --> 00:33:22,559
we could not really fuzz the back end

00:33:20,159 --> 00:33:25,440
emulation part of the device model using

00:33:22,559 --> 00:33:26,880
lip fuzzer because

00:33:25,440 --> 00:33:28,720
there is a lot of validation that

00:33:26,880 --> 00:33:29,679
happens in other software layer things

00:33:28,720 --> 00:33:32,080
like the vhm

00:33:29,679 --> 00:33:33,440
or the hypervisor before we reach the

00:33:32,080 --> 00:33:35,840
device model

00:33:33,440 --> 00:33:38,000
and for that configuringly fuzzer to

00:33:35,840 --> 00:33:39,840
target the emulation back and would

00:33:38,000 --> 00:33:42,080
result in some kind of false positive

00:33:39,840 --> 00:33:46,240
which is not the best

00:33:42,080 --> 00:33:48,399
approach also with lyft fuzzer we might

00:33:46,240 --> 00:33:50,399
have to do a lot of code refactoring to

00:33:48,399 --> 00:33:50,880
remove any kind of exit statement we

00:33:50,399 --> 00:33:52,799
need to

00:33:50,880 --> 00:33:54,399
do safe returns to the single entry

00:33:52,799 --> 00:33:55,760
function which is the llm fuzzer test

00:33:54,399 --> 00:33:57,679
one endpoint

00:33:55,760 --> 00:33:59,600
so this was lip fuzzer and our

00:33:57,679 --> 00:34:02,240
experience with the fuzzer

00:33:59,600 --> 00:34:02,799
the last component which targets the

00:34:02,240 --> 00:34:04,640
three

00:34:02,799 --> 00:34:06,640
remaining interface in the guest which

00:34:04,640 --> 00:34:09,359
is the mmi

00:34:06,640 --> 00:34:11,200
port io kind of interfaces which is

00:34:09,359 --> 00:34:14,399
considered very critical because

00:34:11,200 --> 00:34:17,440
a gas vm is not trusted in the

00:34:14,399 --> 00:34:20,079
acron software stack and

00:34:17,440 --> 00:34:21,760
for that we used hypercube or it's a

00:34:20,079 --> 00:34:24,960
research kind of os

00:34:21,760 --> 00:34:26,159
uh that do fuzzing in a different way

00:34:24,960 --> 00:34:28,480
other than cisco

00:34:26,159 --> 00:34:29,919
and and lip fuzzer and all these tools

00:34:28,480 --> 00:34:32,240
so

00:34:29,919 --> 00:34:33,359
hypercube os is a multi-dimensional

00:34:32,240 --> 00:34:36,879
fuzzer that

00:34:33,359 --> 00:34:38,879
is targeting more the low-level software

00:34:36,879 --> 00:34:40,000
it compo it's consists of two main

00:34:38,879 --> 00:34:42,000
components so

00:34:40,000 --> 00:34:44,399
one component that enumerates different

00:34:42,000 --> 00:34:45,040
interfaces so enumerate the assigned pci

00:34:44,399 --> 00:34:48,560
devices

00:34:45,040 --> 00:34:50,399
it enumerates things like the local apec

00:34:48,560 --> 00:34:52,000
input input output apic and all these

00:34:50,399 --> 00:34:54,000
low level stuff

00:34:52,000 --> 00:34:56,000
and also it contain a fuzz engine that

00:34:54,000 --> 00:34:58,240
after we enumerate those interfaces

00:34:56,000 --> 00:34:59,359
we would be able to inject malicious or

00:34:58,240 --> 00:35:02,720
malformed

00:34:59,359 --> 00:35:04,400
data into those interfaces

00:35:02,720 --> 00:35:06,400
from integration perspective it's very

00:35:04,400 --> 00:35:06,960
easy so hypercube lifts as a normal

00:35:06,400 --> 00:35:10,079
guest

00:35:06,960 --> 00:35:12,400
so it runs in any of the acron scenario

00:35:10,079 --> 00:35:13,520
either in industrial or ivi it's nothing

00:35:12,400 --> 00:35:17,359
but triggering

00:35:13,520 --> 00:35:18,800
a normal vm using the device model and

00:35:17,359 --> 00:35:21,119
it lives on top of acron

00:35:18,800 --> 00:35:23,520
to experience those different interfaces

00:35:21,119 --> 00:35:26,240
as we can see here

00:35:23,520 --> 00:35:27,760
and from organization perspective the

00:35:26,240 --> 00:35:30,480
hypercube os

00:35:27,760 --> 00:35:31,119
starts at the beginning by the device

00:35:30,480 --> 00:35:34,560
model

00:35:31,119 --> 00:35:36,320
so as we start normal guests if we want

00:35:34,560 --> 00:35:38,800
to start hypercube we have to define

00:35:36,320 --> 00:35:39,520
what kind of devices we want to test and

00:35:38,800 --> 00:35:41,920
here

00:35:39,520 --> 00:35:43,040
we define some of the vert io devices

00:35:41,920 --> 00:35:45,200
that we think

00:35:43,040 --> 00:35:46,480
if we assign it to this guest and then

00:35:45,200 --> 00:35:48,560
run hypercube

00:35:46,480 --> 00:35:49,760
it would be able to fuzz them or inject

00:35:48,560 --> 00:35:52,560
bad input to those

00:35:49,760 --> 00:35:54,560
uh devices or the memory mapped region

00:35:52,560 --> 00:35:57,520
related to those devices

00:35:54,560 --> 00:35:58,720
so after hyper the hypercube boots it do

00:35:57,520 --> 00:36:00,400
some initialization

00:35:58,720 --> 00:36:02,240
things like uh setting the global

00:36:00,400 --> 00:36:02,960
descriptor table the interrupt table and

00:36:02,240 --> 00:36:04,720
so on

00:36:02,960 --> 00:36:06,960
and then it starts to register different

00:36:04,720 --> 00:36:10,839
regions first let's start with the

00:36:06,960 --> 00:36:13,760
pc the mmio and port io

00:36:10,839 --> 00:36:14,640
region it then goes to the pci devices

00:36:13,760 --> 00:36:18,000
and if you see here

00:36:14,640 --> 00:36:21,599
those are the pci devices that we have

00:36:18,000 --> 00:36:24,160
assigned initially by the device model

00:36:21,599 --> 00:36:25,520
it then tries to enumerate or register

00:36:24,160 --> 00:36:29,359
some of the

00:36:25,520 --> 00:36:32,960
other reasons like apec and local apec

00:36:29,359 --> 00:36:35,680
it creates a fuzzer and then it uses

00:36:32,960 --> 00:36:37,920
an an integrated kind of soyuz random

00:36:35,680 --> 00:36:39,359
number generator in order to have a seat

00:36:37,920 --> 00:36:41,839
and then we use the seat to start

00:36:39,359 --> 00:36:41,839
fuzzing

00:36:42,079 --> 00:36:45,440
this was experienced our experience so

00:36:43,839 --> 00:36:45,920
far with different fuzzing tools and so

00:36:45,440 --> 00:36:48,960
on

00:36:45,920 --> 00:36:49,920
so stefan maybe a bit about our future

00:36:48,960 --> 00:36:55,839
work and

00:36:49,920 --> 00:36:55,839
what's ahead

00:36:59,200 --> 00:37:01,839
one second

00:37:03,920 --> 00:37:11,040
okay thank you mustafa

00:37:07,599 --> 00:37:13,839
um so as you've heard uh hypercube

00:37:11,040 --> 00:37:14,720
is quite easy to get started with and

00:37:13,839 --> 00:37:16,960
it's actually

00:37:14,720 --> 00:37:17,839
a really nice tool to test the low-level

00:37:16,960 --> 00:37:21,119
interfaces

00:37:17,839 --> 00:37:24,160
of uh for for the

00:37:21,119 --> 00:37:25,760
the low-level vm interfaces of acorn um

00:37:24,160 --> 00:37:28,079
but the problem is that it is actually

00:37:25,760 --> 00:37:30,880
just a blind father and we want to have

00:37:28,079 --> 00:37:31,920
a coverage feedback and uh coverage

00:37:30,880 --> 00:37:35,040
guided furthering

00:37:31,920 --> 00:37:37,280
uh using something like hyperkey

00:37:35,040 --> 00:37:38,079
and the way forward that we are uh

00:37:37,280 --> 00:37:41,200
looking into

00:37:38,079 --> 00:37:44,560
uh for this direction is basically uh

00:37:41,200 --> 00:37:47,040
kernel fuzzing using kfl um

00:37:44,560 --> 00:37:48,960
kfl is another research prototype also

00:37:47,040 --> 00:37:52,400
from rural university for home the same

00:37:48,960 --> 00:37:55,839
people who also developed hypercube

00:37:52,400 --> 00:37:56,800
and the idea of kafl is actually to

00:37:55,839 --> 00:38:00,000
launch the target

00:37:56,800 --> 00:38:01,119
inside the virtual machine using qmo and

00:38:00,000 --> 00:38:04,079
kvm

00:38:01,119 --> 00:38:05,280
modified versions of them and you would

00:38:04,079 --> 00:38:07,760
basically again

00:38:05,280 --> 00:38:09,920
you have a test driver that stimulates

00:38:07,760 --> 00:38:10,400
the target operating system inside the

00:38:09,920 --> 00:38:13,119
vm

00:38:10,400 --> 00:38:14,160
it receives its input from uh by a

00:38:13,119 --> 00:38:16,400
shared memory from

00:38:14,160 --> 00:38:17,520
qmo and from the actual serving front

00:38:16,400 --> 00:38:20,880
end

00:38:17,520 --> 00:38:24,480
and then using intel pt processor trace

00:38:20,880 --> 00:38:28,240
we can get feedback for each execution

00:38:24,480 --> 00:38:30,720
that is being uh decoded by qmo

00:38:28,240 --> 00:38:33,119
and returned back to the kfl server the

00:38:30,720 --> 00:38:36,560
advantage of this is that it is

00:38:33,119 --> 00:38:38,240
nicely scalable it uses a well-known

00:38:36,560 --> 00:38:40,000
interface which is the virtual machine

00:38:38,240 --> 00:38:43,119
interface for

00:38:40,000 --> 00:38:44,240
executing and scaling vms in the vm

00:38:43,119 --> 00:38:46,160
backend

00:38:44,240 --> 00:38:47,359
and in the latest version which is

00:38:46,160 --> 00:38:49,599
called mix

00:38:47,359 --> 00:38:51,599
we also have advanced features such as

00:38:49,599 --> 00:38:53,920
very fast snapshotting

00:38:51,599 --> 00:38:56,400
solving of multiple interfaces as well

00:38:53,920 --> 00:38:56,960
as a notion of grammar or structured

00:38:56,400 --> 00:39:00,560
fuzzing

00:38:56,960 --> 00:39:02,480
of the vm targets so in this case

00:39:00,560 --> 00:39:03,920
acorn woodburn is a nested hypervisor

00:39:02,480 --> 00:39:07,040
inside kvm

00:39:03,920 --> 00:39:09,359
and we expect to achieve this way the

00:39:07,040 --> 00:39:14,000
the feedback also for the hypercube

00:39:09,359 --> 00:39:16,880
fuzzing case

00:39:14,000 --> 00:39:18,000
so to summarize um we have seen that

00:39:16,880 --> 00:39:20,000
there is a range of

00:39:18,000 --> 00:39:21,200
targets that we need to pursue for

00:39:20,000 --> 00:39:24,000
syscolar

00:39:21,200 --> 00:39:26,160
for acorns sorry they are actually quite

00:39:24,000 --> 00:39:28,160
different in nature the device model and

00:39:26,160 --> 00:39:30,640
user space the hypervisor itself

00:39:28,160 --> 00:39:31,760
and there's a kernel module the vhm and

00:39:30,640 --> 00:39:34,480
they all interact

00:39:31,760 --> 00:39:36,160
in interesting ways and produce a number

00:39:34,480 --> 00:39:39,680
of security boundaries that have

00:39:36,160 --> 00:39:41,760
have to have a good security testing

00:39:39,680 --> 00:39:43,440
this caller has been very promising on

00:39:41,760 --> 00:39:45,280
the kernel side and hyper calls

00:39:43,440 --> 00:39:47,599
validation site

00:39:45,280 --> 00:39:48,320
while hypercube has proven to be very

00:39:47,599 --> 00:39:51,280
effective

00:39:48,320 --> 00:39:51,920
and scalable on the guest vm sites to

00:39:51,280 --> 00:39:54,240
validate

00:39:51,920 --> 00:39:56,880
from the perspective of the guest vm and

00:39:54,240 --> 00:40:00,000
moving forward we are uh very interested

00:39:56,880 --> 00:40:00,800
to uh run this experiment using kfl and

00:40:00,000 --> 00:40:03,599
mix

00:40:00,800 --> 00:40:04,800
using hypercube as a as a guess in a

00:40:03,599 --> 00:40:08,160
nested acorn

00:40:04,800 --> 00:40:08,880
setup uh lip fuzzer is very interesting

00:40:08,160 --> 00:40:10,400
to first

00:40:08,880 --> 00:40:12,160
the command line interface and

00:40:10,400 --> 00:40:13,119
configurations that are possible with

00:40:12,160 --> 00:40:14,960
acorn

00:40:13,119 --> 00:40:16,160
um but in general it has been a little

00:40:14,960 --> 00:40:18,079
bit difficult to get it

00:40:16,160 --> 00:40:20,240
working for the device model for the

00:40:18,079 --> 00:40:25,839
emulation of devices which

00:40:20,240 --> 00:40:25,839
is in user space on the service os

00:40:26,319 --> 00:40:30,240
right so overall i think we've seen that

00:40:28,720 --> 00:40:32,560
there's a lot to be done

00:40:30,240 --> 00:40:35,359
for improving furthering even for

00:40:32,560 --> 00:40:39,040
low-level software there's no tools that

00:40:35,359 --> 00:40:41,040
cover all our bases um but of course

00:40:39,040 --> 00:40:42,960
we're working on it we like to also

00:40:41,040 --> 00:40:45,040
collaborate with academia

00:40:42,960 --> 00:40:46,400
and other projects in this space and

00:40:45,040 --> 00:40:48,000
extend them and

00:40:46,400 --> 00:40:50,079
since this is an open source project we

00:40:48,000 --> 00:40:52,560
also of course plan to upstream

00:40:50,079 --> 00:40:55,040
integrate and automate all of these

00:40:52,560 --> 00:40:55,040
tools

00:40:55,520 --> 00:40:59,359
um so with that i thank you all for

00:40:58,720 --> 00:41:01,280
listening

00:40:59,359 --> 00:41:02,400
and we're interested to hear your

00:41:01,280 --> 00:41:07,839
questions and comments

00:41:02,400 --> 00:41:07,839
thank you thanks

00:41:21,280 --> 00:41:23,359

YouTube URL: https://www.youtube.com/watch?v=1-2Vgsk-NPM


