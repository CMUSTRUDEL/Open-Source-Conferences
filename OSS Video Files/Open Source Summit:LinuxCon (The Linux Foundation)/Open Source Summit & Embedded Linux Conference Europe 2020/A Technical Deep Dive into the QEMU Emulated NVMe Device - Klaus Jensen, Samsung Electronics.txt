Title: A Technical Deep Dive into the QEMU Emulated NVMe Device - Klaus Jensen, Samsung Electronics
Publication date: 2020-11-13
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	A Technical Deep Dive into the QEMU Emulated NVMe Device - Klaus Jensen, Samsung Electronics
Captions: 
	00:00:08,000 --> 00:00:11,040
hello everyone

00:00:08,880 --> 00:00:12,719
and welcome to my talk which is a

00:00:11,040 --> 00:00:15,519
technical deep dive into the

00:00:12,719 --> 00:00:16,640
qemo emulated nvme device my name is

00:00:15,519 --> 00:00:18,480
klaus and i'm

00:00:16,640 --> 00:00:20,320
a software engineer with samsung

00:00:18,480 --> 00:00:22,960
electronics and i'm also

00:00:20,320 --> 00:00:25,039
a co-maintainer of the qemu emulator

00:00:22,960 --> 00:00:27,119
nvme device

00:00:25,039 --> 00:00:30,160
so we will begin with a low-level

00:00:27,119 --> 00:00:33,680
introduction to pci express attached

00:00:30,160 --> 00:00:34,960
nvme controllers and we will then

00:00:33,680 --> 00:00:38,399
proceed with

00:00:34,960 --> 00:00:40,239
a overview of the nvme controller device

00:00:38,399 --> 00:00:42,640
architecture in pureemo

00:00:40,239 --> 00:00:45,120
and we will look at the core event loop

00:00:42,640 --> 00:00:47,200
and io processing

00:00:45,120 --> 00:00:48,160
we will then continue to look at a

00:00:47,200 --> 00:00:52,079
implementation

00:00:48,160 --> 00:00:53,360
of a recently ratified nvme technical

00:00:52,079 --> 00:00:56,480
proposal called the

00:00:53,360 --> 00:00:59,359
strong name spaces command set and we

00:00:56,480 --> 00:01:01,520
will then look at an implementation of

00:00:59,359 --> 00:01:03,359
a custom vendor-specific command and see

00:01:01,520 --> 00:01:07,520
how that can be

00:01:03,359 --> 00:01:09,680
extended into the qdmo device

00:01:07,520 --> 00:01:12,479
we will also have a couple of live

00:01:09,680 --> 00:01:16,400
demonstrations just to show

00:01:12,479 --> 00:01:19,439
on screen how this stuff actually works

00:01:16,400 --> 00:01:21,840
so nvm express or nvme is

00:01:19,439 --> 00:01:24,960
a scalable interface for pci express

00:01:21,840 --> 00:01:27,680
based ssds and fabric connected devices

00:01:24,960 --> 00:01:29,600
it is characterized by having a single

00:01:27,680 --> 00:01:31,119
memory mapped i o register right in the

00:01:29,600 --> 00:01:34,320
command submission path

00:01:31,119 --> 00:01:35,040
thus making it highly efficient it is

00:01:34,320 --> 00:01:37,920
also

00:01:35,040 --> 00:01:40,000
from the ground designed for massively

00:01:37,920 --> 00:01:42,960
parallel io and it does so through

00:01:40,000 --> 00:01:44,079
host controlled analog free i o cues as

00:01:42,960 --> 00:01:47,040
we

00:01:44,079 --> 00:01:47,759
as we shall see in a second it also

00:01:47,040 --> 00:01:50,079
consists

00:01:47,759 --> 00:01:51,360
of a number of streamlined and very

00:01:50,079 --> 00:01:54,799
efficient command sets

00:01:51,360 --> 00:01:55,840
this the the admin command set that we

00:01:54,799 --> 00:01:59,200
shall go through

00:01:55,840 --> 00:02:00,719
as well as the standard nvm

00:01:59,200 --> 00:02:02,719
command set from the space based

00:02:00,719 --> 00:02:03,520
specification and then we shall look at

00:02:02,719 --> 00:02:06,640
the new

00:02:03,520 --> 00:02:11,120
zoned command set so

00:02:06,640 --> 00:02:13,599
cues are very central to nvme

00:02:11,120 --> 00:02:15,120
and eq is basically a circular buffer

00:02:13,599 --> 00:02:18,160
with a fixed slot size

00:02:15,120 --> 00:02:21,200
and defined by two pointers

00:02:18,160 --> 00:02:22,080
queues are used in pairs so they always

00:02:21,200 --> 00:02:25,520
come in a pair

00:02:22,080 --> 00:02:26,400
with a submission queue and a completion

00:02:25,520 --> 00:02:28,160
queue

00:02:26,400 --> 00:02:31,440
the important thing here is that there

00:02:28,160 --> 00:02:34,560
is always only one entity writing

00:02:31,440 --> 00:02:36,879
to a aq so the

00:02:34,560 --> 00:02:38,400
submission queue is used by the host for

00:02:36,879 --> 00:02:40,879
submitting commands which is

00:02:38,400 --> 00:02:41,599
means that there's only the host writing

00:02:40,879 --> 00:02:45,120
to this

00:02:41,599 --> 00:02:46,640
submission queue and the controller will

00:02:45,120 --> 00:02:49,760
then pick up

00:02:46,640 --> 00:02:52,560
commands from the submission queue

00:02:49,760 --> 00:02:54,400
similarly the host another controller

00:02:52,560 --> 00:02:56,239
will post its completions of these

00:02:54,400 --> 00:02:58,400
commands to the completion queues

00:02:56,239 --> 00:03:00,480
and the host will be reading from from

00:02:58,400 --> 00:03:03,360
that queue

00:03:00,480 --> 00:03:04,480
and as i mentioned previously these are

00:03:03,360 --> 00:03:06,560
always used in pairs

00:03:04,480 --> 00:03:08,400
so there is one completion queue that is

00:03:06,560 --> 00:03:11,760
associated with a submission queue

00:03:08,400 --> 00:03:13,840
and vice versa now

00:03:11,760 --> 00:03:16,239
the two pointers the tail and hit

00:03:13,840 --> 00:03:16,640
pointers are used in such a way that the

00:03:16,239 --> 00:03:20,080
tail

00:03:16,640 --> 00:03:23,519
always point to uh to the next

00:03:20,080 --> 00:03:24,480
empty location of slot in in the queue

00:03:23,519 --> 00:03:26,799
that can be used

00:03:24,480 --> 00:03:28,239
for new commands and it is advanced

00:03:26,799 --> 00:03:31,280
whenever you

00:03:28,239 --> 00:03:33,120
entry to the queue that is in other

00:03:31,280 --> 00:03:33,680
words there is a completion cue tail

00:03:33,120 --> 00:03:36,319
pointer

00:03:33,680 --> 00:03:38,400
and a submission q tail pointer there's

00:03:36,319 --> 00:03:40,319
also a completion q hit pointer and a

00:03:38,400 --> 00:03:43,040
completion q tail pointer

00:03:40,319 --> 00:03:44,159
and these are used uh whenever something

00:03:43,040 --> 00:03:47,680
are consumed

00:03:44,159 --> 00:03:48,799
from from the queue then the head is

00:03:47,680 --> 00:03:50,959
advanced

00:03:48,799 --> 00:03:53,439
the queues are typically allocated in

00:03:50,959 --> 00:03:54,159
host memory but they can be allocated on

00:03:53,439 --> 00:03:57,920
the device

00:03:54,159 --> 00:04:00,480
in some cases so the admin command set

00:03:57,920 --> 00:04:02,400
is used exclusively with the admin q

00:04:00,480 --> 00:04:04,000
pair and it's important to understand

00:04:02,400 --> 00:04:06,239
that there is only a

00:04:04,000 --> 00:04:07,360
single admin q pair and the admin cue

00:04:06,239 --> 00:04:10,799
pair is a

00:04:07,360 --> 00:04:11,439
static q pair that is uh is always

00:04:10,799 --> 00:04:14,159
available

00:04:11,439 --> 00:04:16,320
from the device whenever the device is

00:04:14,159 --> 00:04:19,440
bootstrapped and started by the host

00:04:16,320 --> 00:04:21,600
the admin cue pair will be there

00:04:19,440 --> 00:04:22,720
this is because the admin cube pair is

00:04:21,600 --> 00:04:25,199
among other things

00:04:22,720 --> 00:04:26,560
used for the creation and deletion of

00:04:25,199 --> 00:04:29,759
the other kinds of pair

00:04:26,560 --> 00:04:32,080
the ioq paths that are associated

00:04:29,759 --> 00:04:34,400
with not the admin command set but the

00:04:32,080 --> 00:04:36,800
various io command sets

00:04:34,400 --> 00:04:38,160
the app in qpa is also used to post the

00:04:36,800 --> 00:04:40,720
identify command

00:04:38,160 --> 00:04:42,639
which is used by the host to get various

00:04:40,720 --> 00:04:44,880
information about the controller or

00:04:42,639 --> 00:04:46,800
some of the namespaces that are attached

00:04:44,880 --> 00:04:49,840
to it

00:04:46,800 --> 00:04:53,360
the getlog page command is used to

00:04:49,840 --> 00:04:55,440
get various dynamic information from the

00:04:53,360 --> 00:04:58,479
controller this could be

00:04:55,440 --> 00:04:59,360
error logs or information about the

00:04:58,479 --> 00:05:02,400
firmware

00:04:59,360 --> 00:05:04,320
currently loaded it could be information

00:05:02,400 --> 00:05:07,440
about the temperature of the device

00:05:04,320 --> 00:05:09,280
stuff like that there's also a number of

00:05:07,440 --> 00:05:11,600
controller and links based runtime

00:05:09,280 --> 00:05:12,400
parameters and these can be changed and

00:05:11,600 --> 00:05:15,919
queried

00:05:12,400 --> 00:05:19,039
with the get and step features commands

00:05:15,919 --> 00:05:21,600
so the nvm command set is the i o

00:05:19,039 --> 00:05:23,600
v i o command set that is specified in

00:05:21,600 --> 00:05:25,680
the base specification

00:05:23,600 --> 00:05:26,880
and it is an example of an i o command

00:05:25,680 --> 00:05:30,000
set so

00:05:26,880 --> 00:05:31,120
the i o command the basic i o commands

00:05:30,000 --> 00:05:33,680
for this command set

00:05:31,120 --> 00:05:36,080
is the flush write and read and they are

00:05:33,680 --> 00:05:38,080
the only mandatory commands

00:05:36,080 --> 00:05:40,160
there is also a number of optional and

00:05:38,080 --> 00:05:41,199
specialized commands such as the write

00:05:40,160 --> 00:05:44,639
serials

00:05:41,199 --> 00:05:48,000
which is used uh for the controller to

00:05:44,639 --> 00:05:50,320
efficiently zero out a long range of

00:05:48,000 --> 00:05:51,680
blocks on the device without actually

00:05:50,320 --> 00:05:54,800
requiring the host

00:05:51,680 --> 00:05:57,360
to transfer a huge buffer just filled

00:05:54,800 --> 00:05:59,759
with cirrus

00:05:57,360 --> 00:06:01,039
so these commands that are submitted to

00:05:59,759 --> 00:06:02,560
the submission queue

00:06:01,039 --> 00:06:05,039
comes in the forms of what they call a

00:06:02,560 --> 00:06:06,639
submission queue entry and it is 64

00:06:05,039 --> 00:06:10,479
bytes

00:06:06,639 --> 00:06:11,039
and the this command uh these 64 bytes

00:06:10,479 --> 00:06:14,000
includes

00:06:11,039 --> 00:06:15,199
an 8-bit upcode uniquely identifying the

00:06:14,000 --> 00:06:18,000
command

00:06:15,199 --> 00:06:20,240
it also includes a command identifier in

00:06:18,000 --> 00:06:24,880
16 bits which is something that is

00:06:20,240 --> 00:06:28,880
assigned by the um by the host

00:06:24,880 --> 00:06:32,160
the the the host will also in the case

00:06:28,880 --> 00:06:35,120
of io commands um

00:06:32,160 --> 00:06:35,520
use or set up a namespace identifier

00:06:35,120 --> 00:06:38,800
which

00:06:35,520 --> 00:06:40,319
actually points to the namespace that

00:06:38,800 --> 00:06:43,360
the io operation is

00:06:40,319 --> 00:06:46,160
operating on typically only the data

00:06:43,360 --> 00:06:49,759
pointer is used and the data pointer is

00:06:46,160 --> 00:06:52,880
typically two 64 byte

00:06:49,759 --> 00:06:55,520
64-bit addresses pointing into the

00:06:52,880 --> 00:06:55,919
interhost memory typically in the form

00:06:55,520 --> 00:06:59,120
of a

00:06:55,919 --> 00:07:02,639
list that means that the prp list is

00:06:59,120 --> 00:07:06,000
a very simple data structure where

00:07:02,639 --> 00:07:09,280
we point to a 4k page

00:07:06,000 --> 00:07:12,960
in the operating system host memory that

00:07:09,280 --> 00:07:13,840
includes another list of 64 byte 64-bit

00:07:12,960 --> 00:07:16,080
addresses

00:07:13,840 --> 00:07:17,599
pointing to various locations in memory

00:07:16,080 --> 00:07:19,680
where the data to be read

00:07:17,599 --> 00:07:21,360
or where the data should be written

00:07:19,680 --> 00:07:24,000
written

00:07:21,360 --> 00:07:27,520
is defined there's also the possibility

00:07:24,000 --> 00:07:30,319
of using a 16 byte the

00:07:27,520 --> 00:07:31,199
stl descriptor of scattergatherness

00:07:30,319 --> 00:07:33,520
descriptor

00:07:31,199 --> 00:07:34,960
and the scattergala list is an extremely

00:07:33,520 --> 00:07:39,199
flexible and

00:07:34,960 --> 00:07:41,680
very fine-grained way of describing

00:07:39,199 --> 00:07:43,199
memory that is scattered all over the

00:07:41,680 --> 00:07:46,479
host memory

00:07:43,199 --> 00:07:49,759
the final six d words or

00:07:46,479 --> 00:07:52,400
32-bit keywords are used for

00:07:49,759 --> 00:07:54,800
in in commands in various ways depending

00:07:52,400 --> 00:07:56,800
on the command

00:07:54,800 --> 00:07:58,000
so whenever these commands have been

00:07:56,800 --> 00:08:00,400
submitted to

00:07:58,000 --> 00:08:01,360
the device they go into the submission

00:08:00,400 --> 00:08:05,120
queue

00:08:01,360 --> 00:08:07,199
and for the host to actually notify the

00:08:05,120 --> 00:08:09,280
controller that something has been

00:08:07,199 --> 00:08:10,960
has been submitted it will ring a

00:08:09,280 --> 00:08:13,280
doorbell as we say

00:08:10,960 --> 00:08:14,879
and adobe is just a ride-only memory

00:08:13,280 --> 00:08:18,080
mapped ir register

00:08:14,879 --> 00:08:21,360
and the the um the host

00:08:18,080 --> 00:08:21,919
will write the submission q tail doll

00:08:21,360 --> 00:08:24,879
build

00:08:21,919 --> 00:08:26,080
what this means is that it will write a

00:08:24,879 --> 00:08:28,000
the new value

00:08:26,080 --> 00:08:29,280
of the submission queue tail pointer

00:08:28,000 --> 00:08:32,719
that is the new value

00:08:29,280 --> 00:08:35,200
after it has added a number of

00:08:32,719 --> 00:08:36,719
of commands to the queue what what is

00:08:35,200 --> 00:08:39,760
important here to know is that the

00:08:36,719 --> 00:08:42,800
the host can if it wants to

00:08:39,760 --> 00:08:43,599
submit any number of commands that as as

00:08:42,800 --> 00:08:47,040
many commands

00:08:43,599 --> 00:08:50,080
as their room for and um

00:08:47,040 --> 00:08:51,600
and and then update the submission queue

00:08:50,080 --> 00:08:54,800
table pointer once

00:08:51,600 --> 00:08:57,040
um so we don't have to need to have a

00:08:54,800 --> 00:08:59,360
doorbell right or memory mapped irish to

00:08:57,040 --> 00:09:02,399
write for each

00:08:59,360 --> 00:09:02,959
for each command instead we can batch it

00:09:02,399 --> 00:09:06,560
up

00:09:02,959 --> 00:09:06,959
which is more efficient similarly when

00:09:06,560 --> 00:09:11,279
the

00:09:06,959 --> 00:09:14,000
controller has has read the commands

00:09:11,279 --> 00:09:15,760
and processed and executed the commands

00:09:14,000 --> 00:09:17,760
it will post a completion queue enter

00:09:15,760 --> 00:09:19,760
these are smaller 16 bytes and doesn't

00:09:17,760 --> 00:09:22,959
contain that much information

00:09:19,760 --> 00:09:25,279
but they do contain the command

00:09:22,959 --> 00:09:28,560
identifier which the host can use

00:09:25,279 --> 00:09:29,279
to match up this completion queue entry

00:09:28,560 --> 00:09:32,240
with the

00:09:29,279 --> 00:09:34,800
command that it actually posted so the

00:09:32,240 --> 00:09:38,480
submission queue

00:09:34,800 --> 00:09:41,839
head pointer uh field is a way

00:09:38,480 --> 00:09:44,399
for the um for the host to

00:09:41,839 --> 00:09:46,240
uh for the co for the controller to

00:09:44,399 --> 00:09:47,839
inform the host about new value of the

00:09:46,240 --> 00:09:51,519
mission vision queue head pointer

00:09:47,839 --> 00:09:54,399
that is a way to inform the host about

00:09:51,519 --> 00:09:56,480
how many commands that the the

00:09:54,399 --> 00:09:58,640
controller has actually executed

00:09:56,480 --> 00:10:00,240
and that these commands or these slots

00:09:58,640 --> 00:10:04,160
in the queue are now ready for

00:10:00,240 --> 00:10:05,519
for reuse the phase tag is also special

00:10:04,160 --> 00:10:07,839
this is used

00:10:05,519 --> 00:10:09,200
uh for the for the host to be able to

00:10:07,839 --> 00:10:13,519
actually pull

00:10:09,200 --> 00:10:17,920
uh the um hold the completion queue

00:10:13,519 --> 00:10:20,480
for new entries so

00:10:17,920 --> 00:10:21,120
similarly to how the controller needed

00:10:20,480 --> 00:10:24,720
to be

00:10:21,120 --> 00:10:26,480
uh to be aware of new commands the

00:10:24,720 --> 00:10:28,800
controller also need to tell the host

00:10:26,480 --> 00:10:31,519
about new completions

00:10:28,800 --> 00:10:32,880
and it does so by typically generating

00:10:31,519 --> 00:10:36,160
an interrupt

00:10:32,880 --> 00:10:39,120
but the but the

00:10:36,160 --> 00:10:39,600
hosts may also rely on just calling and

00:10:39,120 --> 00:10:43,279
reading

00:10:39,600 --> 00:10:45,440
from the completion cue in memory

00:10:43,279 --> 00:10:46,560
and just reading until this phase tag is

00:10:45,440 --> 00:10:48,640
actually changed

00:10:46,560 --> 00:10:50,079
when the face tag is changed from one to

00:10:48,640 --> 00:10:52,399
zero or zero to one

00:10:50,079 --> 00:10:54,480
then we know that it is a new entry and

00:10:52,399 --> 00:10:56,399
we can read the completion queue entry

00:10:54,480 --> 00:10:58,480
and we will continue reading completion

00:10:56,399 --> 00:11:00,800
queue entries until

00:10:58,480 --> 00:11:02,320
the face tag is inverted and then we

00:11:00,800 --> 00:11:05,040
know that we

00:11:02,320 --> 00:11:06,320
that that this is an old entry this

00:11:05,040 --> 00:11:07,839
means that the host

00:11:06,320 --> 00:11:09,680
or the controller does not need to

00:11:07,839 --> 00:11:12,160
inform us how many

00:11:09,680 --> 00:11:12,800
new commands or completions have been

00:11:12,160 --> 00:11:15,200
posted

00:11:12,800 --> 00:11:17,600
just that there are new completions

00:11:15,200 --> 00:11:17,600
posted

00:11:18,320 --> 00:11:23,360
and finally when the host has read the

00:11:22,000 --> 00:11:26,320
completion

00:11:23,360 --> 00:11:26,720
entries it has to notify the controller

00:11:26,320 --> 00:11:28,800
that

00:11:26,720 --> 00:11:30,640
there is now room in the completion

00:11:28,800 --> 00:11:32,240
queue and that the completion queue

00:11:30,640 --> 00:11:34,720
entries have been consumed

00:11:32,240 --> 00:11:36,560
and it does so by updating the

00:11:34,720 --> 00:11:37,680
completion queue hit pointer and writing

00:11:36,560 --> 00:11:42,000
it to the

00:11:37,680 --> 00:11:45,360
completion queue head down

00:11:42,000 --> 00:11:48,480
so to actually configure the device the

00:11:45,360 --> 00:11:52,000
uh the host does this through a number

00:11:48,480 --> 00:11:56,000
of read-only memory mapped i o registers

00:11:52,000 --> 00:11:58,880
these uh read-only registers tells the

00:11:56,000 --> 00:12:00,560
host about controller capabilities such

00:11:58,880 --> 00:12:03,839
as

00:12:00,560 --> 00:12:04,800
the knob of cues supported those various

00:12:03,839 --> 00:12:07,760
different

00:12:04,800 --> 00:12:08,240
different registers these con some of

00:12:07,760 --> 00:12:10,240
these

00:12:08,240 --> 00:12:11,519
registers are writable and these are

00:12:10,240 --> 00:12:13,040
used

00:12:11,519 --> 00:12:16,639
for the controller to actually be

00:12:13,040 --> 00:12:19,600
configured one of the things that the

00:12:16,639 --> 00:12:21,279
uh that the that the host has to

00:12:19,600 --> 00:12:22,639
configure before the controller can

00:12:21,279 --> 00:12:24,880
actually be enabled

00:12:22,639 --> 00:12:25,680
is the location of the admin completion

00:12:24,880 --> 00:12:28,959
queue

00:12:25,680 --> 00:12:32,800
admin completion and submission queue

00:12:28,959 --> 00:12:36,079
so the registers which are located

00:12:32,800 --> 00:12:37,680
in a well-defined memory location called

00:12:36,079 --> 00:12:40,800
the pci

00:12:37,680 --> 00:12:40,800
base address register

00:12:41,200 --> 00:12:46,959
for instance the capabilities that i

00:12:43,279 --> 00:12:50,160
discussed which is a read-only register

00:12:46,959 --> 00:12:53,600
but most importantly

00:12:50,160 --> 00:12:55,600
these controller registers are the

00:12:53,600 --> 00:12:57,839
admin submission queue based address and

00:12:55,600 --> 00:12:59,440
the admin completion cubase address this

00:12:57,839 --> 00:13:02,000
is something that the host

00:12:59,440 --> 00:13:03,440
needs to bootstrap in the device before

00:13:02,000 --> 00:13:05,600
enabling device

00:13:03,440 --> 00:13:07,279
enabling link device is also done by

00:13:05,600 --> 00:13:09,040
writing a certain value to the

00:13:07,279 --> 00:13:10,240
controller configuration right or

00:13:09,040 --> 00:13:12,160
register

00:13:10,240 --> 00:13:14,240
and we can also see here that the dot

00:13:12,160 --> 00:13:15,360
bills for this various submission and

00:13:14,240 --> 00:13:18,560
completion cues

00:13:15,360 --> 00:13:21,839
are located in well-known addresses

00:13:18,560 --> 00:13:24,800
in relative to the start of the

00:13:21,839 --> 00:13:24,800
of the bar zero

00:13:27,440 --> 00:13:32,320
so qemo is an open source generic

00:13:30,560 --> 00:13:35,680
emulator and virtualizer

00:13:32,320 --> 00:13:39,199
what this means is that it is not just a

00:13:35,680 --> 00:13:41,279
uh x86 pci based um

00:13:39,199 --> 00:13:43,839
a virtual machine that is that is

00:13:41,279 --> 00:13:47,839
booting up and presenting to the user no

00:13:43,839 --> 00:13:50,959
your email can emulate and

00:13:47,839 --> 00:13:56,800
describe a bunch of various

00:13:50,959 --> 00:13:58,720
architectures such as x86 mips spark arm

00:13:56,800 --> 00:14:00,880
and as well as a bunch of various

00:13:58,720 --> 00:14:03,360
storage controllers that's

00:14:00,880 --> 00:14:04,320
such as a completely standard ide

00:14:03,360 --> 00:14:07,360
scarcity

00:14:04,320 --> 00:14:09,360
the para virtualized virtio but also the

00:14:07,360 --> 00:14:11,519
nvme storage controller which is the

00:14:09,360 --> 00:14:14,639
specific storage controller that we are

00:14:11,519 --> 00:14:18,399
interested in now the

00:14:14,639 --> 00:14:20,000
a basic pci express attached nvme solid

00:14:18,399 --> 00:14:21,680
state device

00:14:20,000 --> 00:14:23,519
the architecture of that looks something

00:14:21,680 --> 00:14:26,399
like this you

00:14:23,519 --> 00:14:27,360
have a pci express controller you have

00:14:26,399 --> 00:14:29,760
some

00:14:27,360 --> 00:14:30,720
some memory on the device you of course

00:14:29,760 --> 00:14:33,120
have the

00:14:30,720 --> 00:14:34,480
all of your nand flash packages that

00:14:33,120 --> 00:14:36,639
actually hold your data

00:14:34,480 --> 00:14:37,600
as well as typically a dedicated

00:14:36,639 --> 00:14:40,880
controller

00:14:37,600 --> 00:14:42,560
to handle this and then you have the nbm

00:14:40,880 --> 00:14:46,000
express controller which holds the

00:14:42,560 --> 00:14:49,440
nvm express logic now the

00:14:46,000 --> 00:14:51,440
pci express controller and the

00:14:49,440 --> 00:14:53,279
memory available for the controller is

00:14:51,440 --> 00:14:56,720
something that is already implemented by

00:14:53,279 --> 00:14:59,839
other parts of qemo that we just utilize

00:14:56,720 --> 00:15:02,880
and the uh the

00:14:59,839 --> 00:15:04,880
the whole part of actually managing

00:15:02,880 --> 00:15:06,720
all the intricacies and various

00:15:04,880 --> 00:15:08,800
characteristics of media such as

00:15:06,720 --> 00:15:10,240
nand is completely defined a way we do

00:15:08,800 --> 00:15:13,839
not worry about that

00:15:10,240 --> 00:15:17,760
and we are just um relying

00:15:13,839 --> 00:15:21,120
on a the block layer provided by qemo

00:15:17,760 --> 00:15:23,760
so the logic that the qrimo nvme device

00:15:21,120 --> 00:15:26,720
is actually implementing is the pure nvm

00:15:23,760 --> 00:15:29,519
express specification logic

00:15:26,720 --> 00:15:30,399
so in other words this is a pure nvme

00:15:29,519 --> 00:15:32,399
controller

00:15:30,399 --> 00:15:33,759
with a little bit of pci express

00:15:32,399 --> 00:15:36,800
specification logic

00:15:33,759 --> 00:15:38,480
there is no flash translation layer or

00:15:36,800 --> 00:15:40,560
no nand management

00:15:38,480 --> 00:15:41,600
and because we simply assume the

00:15:40,560 --> 00:15:44,959
presence of

00:15:41,600 --> 00:15:45,839
a flash translation layer and what this

00:15:44,959 --> 00:15:48,639
means is that we

00:15:45,839 --> 00:15:49,360
are directly using the logically

00:15:48,639 --> 00:15:52,480
addressable

00:15:49,360 --> 00:15:53,519
and linear addressable uh qemo block

00:15:52,480 --> 00:15:57,120
layer

00:15:53,519 --> 00:15:59,680
instead of trying to emulate nand flash

00:15:57,120 --> 00:16:01,839
the point of the controller is to

00:15:59,680 --> 00:16:07,120
implement the nvme specification

00:16:01,839 --> 00:16:10,320
not to simulate nand flash

00:16:07,120 --> 00:16:13,519
so the basic controller architecture

00:16:10,320 --> 00:16:15,759
is that the device actually

00:16:13,519 --> 00:16:16,800
consists of two different qe mode

00:16:15,759 --> 00:16:20,839
devices

00:16:16,800 --> 00:16:23,839
the controller device is the core device

00:16:20,839 --> 00:16:26,320
um that implements

00:16:23,839 --> 00:16:29,199
a core controller logic such as setting

00:16:26,320 --> 00:16:32,079
up the pci express

00:16:29,199 --> 00:16:33,360
endpoints processing the i o commands

00:16:32,079 --> 00:16:37,440
stuff like that

00:16:33,360 --> 00:16:40,639
the other parts or the other

00:16:37,440 --> 00:16:43,759
the other devices are the nvme

00:16:40,639 --> 00:16:45,440
ns devices or the namespace devices the

00:16:43,759 --> 00:16:48,880
namespace devices

00:16:45,440 --> 00:16:52,079
are holding the reference to the

00:16:48,880 --> 00:16:53,759
actual underlying qemo block driver

00:16:52,079 --> 00:16:56,240
this could be a file this could be a

00:16:53,759 --> 00:16:59,759
network file could be your memory

00:16:56,240 --> 00:17:03,279
but typically it's it's just a raw

00:16:59,759 --> 00:17:05,199
a raw file on the underlying file system

00:17:03,279 --> 00:17:07,120
the namespace device has various

00:17:05,199 --> 00:17:08,799
attributes such as the size of each

00:17:07,120 --> 00:17:12,160
logical block is it 4k

00:17:08,799 --> 00:17:15,679
or is it 512 bytes what is

00:17:12,160 --> 00:17:19,120
the command set that this namespace

00:17:15,679 --> 00:17:20,959
uses is a standard nvm

00:17:19,120 --> 00:17:22,400
command set or is it one of the zone

00:17:20,959 --> 00:17:23,439
command set that we're going to look at

00:17:22,400 --> 00:17:25,600
in a second

00:17:23,439 --> 00:17:26,640
so these devices take care of namespace

00:17:25,600 --> 00:17:29,760
initialization

00:17:26,640 --> 00:17:31,440
and also certain parts persistent

00:17:29,760 --> 00:17:34,640
management such as

00:17:31,440 --> 00:17:36,640
managing various state that is required

00:17:34,640 --> 00:17:39,280
for some of the command sets such as the

00:17:36,640 --> 00:17:39,280
strong commands

00:17:39,360 --> 00:17:47,200
so the the nvme device is basically

00:17:43,360 --> 00:17:47,919
a an extension to an abstract qemo pci

00:17:47,200 --> 00:17:52,160
device

00:17:47,919 --> 00:17:55,840
model so the nvme device begins

00:17:52,160 --> 00:17:59,280
when booting up by initializing a parent

00:17:55,840 --> 00:18:02,400
pci device it does so by setting up a

00:17:59,280 --> 00:18:03,679
pci ids vendor and device ids it

00:18:02,400 --> 00:18:06,960
initializes the

00:18:03,679 --> 00:18:09,840
base address registers and it sets up

00:18:06,960 --> 00:18:11,440
the message signal to interrupt and

00:18:09,840 --> 00:18:14,799
other pci express based

00:18:11,440 --> 00:18:18,880
stuff it also sets up a number of

00:18:14,799 --> 00:18:22,480
internal controller states such as these

00:18:18,880 --> 00:18:25,440
read-only and writable memory

00:18:22,480 --> 00:18:28,000
map i registered that we saw earlier as

00:18:25,440 --> 00:18:31,280
well as initialize the namespaces that

00:18:28,000 --> 00:18:33,760
are attached to the controller

00:18:31,280 --> 00:18:34,799
and when all this is enabled it will

00:18:33,760 --> 00:18:37,679
basically wait

00:18:34,799 --> 00:18:38,000
for the host to configure the controller

00:18:37,679 --> 00:18:40,840
and

00:18:38,000 --> 00:18:43,039
enable it before it begins processing i

00:18:40,840 --> 00:18:45,600
o

00:18:43,039 --> 00:18:46,880
now qremo is essentially a single

00:18:45,600 --> 00:18:50,240
threaded

00:18:46,880 --> 00:18:54,240
application which means that

00:18:50,240 --> 00:18:56,400
while the the guest code that actually

00:18:54,240 --> 00:18:57,120
runs on the virtual cpus runs in

00:18:56,400 --> 00:19:00,080
dedicated

00:18:57,120 --> 00:19:01,760
threads the device emulation cure by

00:19:00,080 --> 00:19:04,880
default runs on the main

00:19:01,760 --> 00:19:07,039
qmo thread this means that if a device

00:19:04,880 --> 00:19:09,200
in qemo does something that shouldn't do

00:19:07,039 --> 00:19:11,840
like simply blocking at certain points

00:19:09,200 --> 00:19:14,960
it will block the entire qemo

00:19:11,840 --> 00:19:16,000
interpreter so device code must yield

00:19:14,960 --> 00:19:20,240
appropriately and

00:19:16,000 --> 00:19:23,360
not do any two time consuming

00:19:20,240 --> 00:19:24,559
jobs this means that device code is

00:19:23,360 --> 00:19:27,840
typically designed

00:19:24,559 --> 00:19:29,039
as being run is in response to various

00:19:27,840 --> 00:19:32,160
callbacks when the

00:19:29,039 --> 00:19:34,000
i o is completed it works with expired

00:19:32,160 --> 00:19:35,840
timers and something called bottom

00:19:34,000 --> 00:19:38,880
halves which is basically

00:19:35,840 --> 00:19:40,320
timers that expire immediately and used

00:19:38,880 --> 00:19:43,919
for the sole purpose of

00:19:40,320 --> 00:19:45,919
deferring some work for other

00:19:43,919 --> 00:19:47,520
work to be done and then come back to

00:19:45,919 --> 00:19:52,000
this when we have time for to

00:19:47,520 --> 00:19:54,799
do it so let's look at the

00:19:52,000 --> 00:19:56,720
basic asynchronous command process in

00:19:54,799 --> 00:19:58,960
qmo and how this works

00:19:56,720 --> 00:19:59,760
now everything as we as we saw earlier

00:19:58,960 --> 00:20:01,440
everything happened

00:19:59,760 --> 00:20:03,120
if everything begins with the memory

00:20:01,440 --> 00:20:06,000
mapped i write

00:20:03,120 --> 00:20:06,400
so at this point we assume that the host

00:20:06,000 --> 00:20:08,320
has

00:20:06,400 --> 00:20:09,440
written some commands into the i o

00:20:08,320 --> 00:20:12,559
submission

00:20:09,440 --> 00:20:14,400
queue and when the i o

00:20:12,559 --> 00:20:15,840
right to the memory map register comes

00:20:14,400 --> 00:20:19,120
in we just begin

00:20:15,840 --> 00:20:22,080
by looking at whether it is below

00:20:19,120 --> 00:20:23,840
the 4k mark that means that it is a

00:20:22,080 --> 00:20:24,400
register that we are trying to write to

00:20:23,840 --> 00:20:26,720
and we will

00:20:24,400 --> 00:20:28,320
have some routine preview in the device

00:20:26,720 --> 00:20:30,559
that takes care of that

00:20:28,320 --> 00:20:33,039
otherwise we know that this is actually

00:20:30,559 --> 00:20:36,080
a right to one of the cross

00:20:33,039 --> 00:20:38,000
one of the doll bills so

00:20:36,080 --> 00:20:39,360
we will assume that is a right to one of

00:20:38,000 --> 00:20:42,480
the dole bills and

00:20:39,360 --> 00:20:43,520
by looking at the final bit uh the first

00:20:42,480 --> 00:20:45,440
bit the

00:20:43,520 --> 00:20:46,720
least significant bit we know whether

00:20:45,440 --> 00:20:49,520
this is an

00:20:46,720 --> 00:20:51,760
update to a completion q head pointer or

00:20:49,520 --> 00:20:53,280
if it's an update to a submission q tail

00:20:51,760 --> 00:20:55,280
pointer that means that we have new

00:20:53,280 --> 00:20:58,799
commands to process

00:20:55,280 --> 00:21:00,480
so assuming that it's a update to the

00:20:58,799 --> 00:21:03,679
submission queue tail pointer we will

00:21:00,480 --> 00:21:07,039
schedule the submission queue processing

00:21:03,679 --> 00:21:10,400
and what we mean by so scheduling here

00:21:07,039 --> 00:21:11,520
is that we won't begin processing this

00:21:10,400 --> 00:21:13,360
immediately

00:21:11,520 --> 00:21:15,120
we will schedule a thread it will

00:21:13,360 --> 00:21:17,679
schedule callback to run

00:21:15,120 --> 00:21:19,120
at some point in the future basically as

00:21:17,679 --> 00:21:21,840
soon as possible

00:21:19,120 --> 00:21:23,280
and but then we will yield after doing

00:21:21,840 --> 00:21:26,000
this memory management

00:21:23,280 --> 00:21:28,240
after handling the memory mapped io

00:21:26,000 --> 00:21:31,039
right

00:21:28,240 --> 00:21:31,600
at some point we are allowed to run

00:21:31,039 --> 00:21:34,159
again

00:21:31,600 --> 00:21:35,200
and we will then go through the queued

00:21:34,159 --> 00:21:37,760
up

00:21:35,200 --> 00:21:39,919
submission queue entries so we will read

00:21:37,760 --> 00:21:42,799
them from host memory using direct

00:21:39,919 --> 00:21:43,360
memory access then we will increment the

00:21:42,799 --> 00:21:45,679
internal

00:21:43,360 --> 00:21:48,720
submission queue hit pointer and then we

00:21:45,679 --> 00:21:50,559
will execute the command

00:21:48,720 --> 00:21:52,799
so the first thing we do here is that we

00:21:50,559 --> 00:21:55,039
look at the submission queue identifier

00:21:52,799 --> 00:21:57,120
if it's 0 we know that this is an admin

00:21:55,039 --> 00:21:58,720
command if it's non-zero then it is an

00:21:57,120 --> 00:22:00,640
io command

00:21:58,720 --> 00:22:02,240
the admin command typically does not

00:22:00,640 --> 00:22:03,200
block because they do not need to

00:22:02,240 --> 00:22:06,480
perform any

00:22:03,200 --> 00:22:07,919
really time consuming jobs like actually

00:22:06,480 --> 00:22:11,440
doing io

00:22:07,919 --> 00:22:12,960
so typically the admin command will just

00:22:11,440 --> 00:22:16,640
be executed

00:22:12,960 --> 00:22:19,200
immediately inside our current contacts

00:22:16,640 --> 00:22:21,840
and this will result in a completion

00:22:19,200 --> 00:22:25,360
queue entry being enqueued

00:22:21,840 --> 00:22:28,240
or set up for for being posted now again

00:22:25,360 --> 00:22:30,000
we do not post immediately instead we

00:22:28,240 --> 00:22:32,159
schedule

00:22:30,000 --> 00:22:34,320
the completion queue entry to be posted

00:22:32,159 --> 00:22:37,280
at the earliest convenience

00:22:34,320 --> 00:22:39,520
the point here again is to allow a bunch

00:22:37,280 --> 00:22:40,000
of commands to be executed at the same

00:22:39,520 --> 00:22:43,600
time

00:22:40,000 --> 00:22:45,200
and only post and write to memory in one

00:22:43,600 --> 00:22:48,400
go instead of writing

00:22:45,200 --> 00:22:48,799
instead of doing this in a bunch of

00:22:48,400 --> 00:22:52,880
small

00:22:48,799 --> 00:22:54,640
updates if it is an i o command

00:22:52,880 --> 00:22:56,159
typically the device will end up

00:22:54,640 --> 00:22:59,360
yielding that is it will

00:22:56,159 --> 00:23:02,480
issue some kind of synchronous io

00:22:59,360 --> 00:23:06,000
and then it will just wait

00:23:02,480 --> 00:23:06,799
at some point the i o command or the

00:23:06,000 --> 00:23:09,679
actual

00:23:06,799 --> 00:23:10,640
read or the write that the io command

00:23:09,679 --> 00:23:13,440
was supposed to

00:23:10,640 --> 00:23:15,200
to do will complete and we will end up

00:23:13,440 --> 00:23:15,760
at the same point as the admin command

00:23:15,200 --> 00:23:17,760
that is

00:23:15,760 --> 00:23:20,159
scheduling accommodation queue entry

00:23:17,760 --> 00:23:20,159
posting

00:23:20,559 --> 00:23:24,400
at some point the uh this scheduling is

00:23:23,760 --> 00:23:27,120
run

00:23:24,400 --> 00:23:28,799
and we will go through the all of the

00:23:27,120 --> 00:23:29,200
completion queue entries that are queued

00:23:28,799 --> 00:23:32,880
up

00:23:29,200 --> 00:23:37,039
we will write them to uh to host memory

00:23:32,880 --> 00:23:38,720
and then we will raise the interrupt

00:23:37,039 --> 00:23:40,320
the point here as we can see is that we

00:23:38,720 --> 00:23:43,520
have now batched up

00:23:40,320 --> 00:23:46,480
the uh the the interrupt

00:23:43,520 --> 00:23:48,000
so instead of just doing a single a an

00:23:46,480 --> 00:23:50,799
interrupt for each of the completion

00:23:48,000 --> 00:23:52,559
cube we do a single completion a single

00:23:50,799 --> 00:23:53,919
interrupt for all of the completions

00:23:52,559 --> 00:23:58,400
that we have

00:23:53,919 --> 00:23:58,400
processed in this batch

00:23:58,480 --> 00:24:04,880
so let's actually look at

00:24:01,520 --> 00:24:07,520
how this works in practice

00:24:04,880 --> 00:24:09,200
so in this demonstration i want to show

00:24:07,520 --> 00:24:11,039
just what actually happens when the

00:24:09,200 --> 00:24:13,840
device first boots up

00:24:11,039 --> 00:24:15,120
now up here i'm using a small tool that

00:24:13,840 --> 00:24:18,720
i hope will be

00:24:15,120 --> 00:24:20,320
open source by the time of this the q a

00:24:18,720 --> 00:24:22,240
associated with this talk

00:24:20,320 --> 00:24:23,919
uh but what this tool basically does is

00:24:22,240 --> 00:24:27,520
just wrapping humor

00:24:23,919 --> 00:24:30,240
and generating a communal invocation

00:24:27,520 --> 00:24:31,279
which includes a bunch of stuff and it

00:24:30,240 --> 00:24:34,799
does so

00:24:31,279 --> 00:24:37,840
from a simple configuration file

00:24:34,799 --> 00:24:39,679
uh written in bash instead of writing

00:24:37,840 --> 00:24:41,440
and remembering all the stuff in qemo

00:24:39,679 --> 00:24:44,240
you write this

00:24:41,440 --> 00:24:45,840
the small configuration file now booting

00:24:44,240 --> 00:24:48,400
up

00:24:45,840 --> 00:24:49,679
booting up the device we get a bunch of

00:24:48,400 --> 00:24:52,000
stuff in the pci

00:24:49,679 --> 00:24:53,360
in in the lock trace and what we see

00:24:52,000 --> 00:24:55,760
here is that there are two

00:24:53,360 --> 00:24:56,880
uh namespaces with namespace id1 and

00:24:55,760 --> 00:24:58,960
lumspj

00:24:56,880 --> 00:25:00,559
d2 which are registered on the

00:24:58,960 --> 00:25:04,000
controller device

00:25:00,559 --> 00:25:04,480
we also see that the host operating

00:25:04,000 --> 00:25:06,559
system

00:25:04,480 --> 00:25:07,520
or the host at least is going in and

00:25:06,559 --> 00:25:09,520
actually reading some of the

00:25:07,520 --> 00:25:09,840
capabilities we remember those were the

00:25:09,520 --> 00:25:13,039
low

00:25:09,840 --> 00:25:15,039
numbered registers on the device

00:25:13,039 --> 00:25:16,799
so reading some capabilities figuring

00:25:15,039 --> 00:25:19,039
out stuff about the controller

00:25:16,799 --> 00:25:20,320
and then one of the important things

00:25:19,039 --> 00:25:21,919
that we talked about is that

00:25:20,320 --> 00:25:23,679
it's going in here and it's actually

00:25:21,919 --> 00:25:25,600
writing the address of the admin

00:25:23,679 --> 00:25:27,840
submission queue

00:25:25,600 --> 00:25:30,000
both the submission queue as well as the

00:25:27,840 --> 00:25:32,640
completion queue

00:25:30,000 --> 00:25:34,400
when those addresses are bootstrapped

00:25:32,640 --> 00:25:35,919
we're actually ready to enable the

00:25:34,400 --> 00:25:37,039
device and that is what the host is

00:25:35,919 --> 00:25:39,360
doing right here

00:25:37,039 --> 00:25:41,840
it is writing to the controller

00:25:39,360 --> 00:25:45,200
configuration

00:25:41,840 --> 00:25:48,000
and that last bit here is what

00:25:45,200 --> 00:25:48,559
is actually enabling the device and we

00:25:48,000 --> 00:25:50,159
see that

00:25:48,559 --> 00:25:52,559
exactly from the trace we see that the

00:25:50,159 --> 00:25:53,919
start is exist the controller enable bit

00:25:52,559 --> 00:25:56,000
has been succeeded

00:25:53,919 --> 00:25:57,840
at this point the controller is ready to

00:25:56,000 --> 00:26:00,080
actually receive commands

00:25:57,840 --> 00:26:00,960
and we see here that it is actually

00:26:00,080 --> 00:26:04,400
receiving a

00:26:00,960 --> 00:26:07,919
identify command so

00:26:04,400 --> 00:26:11,039
if we if we log into the coast

00:26:07,919 --> 00:26:12,559
and try to do some some some io

00:26:11,039 --> 00:26:14,880
then what we're going to do here is

00:26:12,559 --> 00:26:15,360
issue a very basic i o we're going to

00:26:14,880 --> 00:26:18,559
issue

00:26:15,360 --> 00:26:20,559
an i o to the first lba in

00:26:18,559 --> 00:26:21,919
on the main space we're going to be

00:26:20,559 --> 00:26:25,360
issuing a

00:26:21,919 --> 00:26:27,120
a four the four lbas we're going to

00:26:25,360 --> 00:26:30,240
write that's 16 bytes

00:26:27,120 --> 00:26:34,000
16 kilobytes because each lba is

00:26:30,240 --> 00:26:37,679
4 gigabytes by doing so we see here that

00:26:34,000 --> 00:26:39,760
the uh that the host will

00:26:37,679 --> 00:26:40,720
ring the doorbell to notify the hoof

00:26:39,760 --> 00:26:42,960
that we have

00:26:40,720 --> 00:26:42,960
new

00:26:44,080 --> 00:26:47,840
new commands in the queue the command

00:26:46,799 --> 00:26:51,200
will be parsed as

00:26:47,840 --> 00:26:54,880
an i o command because it's an ios

00:26:51,200 --> 00:26:57,520
ioq is specifically a write command

00:26:54,880 --> 00:26:58,880
the right command specifically is now

00:26:57,520 --> 00:27:02,640
parsed

00:26:58,880 --> 00:27:05,360
to go against the name space named one

00:27:02,640 --> 00:27:06,880
four lbas 16 kilobytes against the first

00:27:05,360 --> 00:27:10,240
lba

00:27:06,880 --> 00:27:11,520
the data associated with this is located

00:27:10,240 --> 00:27:15,120
in a prp

00:27:11,520 --> 00:27:18,960
so we see here that we have 16 bytes

00:27:15,120 --> 00:27:21,919
kilobytes of stuff encoded into prps

00:27:18,960 --> 00:27:22,320
and we know that the first prp is the

00:27:21,919 --> 00:27:25,600
first

00:27:22,320 --> 00:27:26,159
page the first 4k of this data the other

00:27:25,600 --> 00:27:29,600
plp

00:27:26,159 --> 00:27:30,480
the prp 2 is instead appointed to a page

00:27:29,600 --> 00:27:33,279
that contains

00:27:30,480 --> 00:27:35,200
more prp addresses so what we see the

00:27:33,279 --> 00:27:37,039
device now doing is actually

00:27:35,200 --> 00:27:39,279
mapping the first address in the first

00:27:37,039 --> 00:27:42,240
pip then

00:27:39,279 --> 00:27:43,279
following this pointer reading the data

00:27:42,240 --> 00:27:46,159
here and nabbing

00:27:43,279 --> 00:27:47,360
each of the addresses located in that

00:27:46,159 --> 00:27:50,080
memory location

00:27:47,360 --> 00:27:51,840
we see that's what happened here having

00:27:50,080 --> 00:27:52,559
all four means that we have now mapped

00:27:51,840 --> 00:27:55,360
the data

00:27:52,559 --> 00:27:56,720
in all four memory locations and we

00:27:55,360 --> 00:27:59,120
actually issued the

00:27:56,720 --> 00:28:00,720
asynchronous i o and at some point that

00:27:59,120 --> 00:28:04,240
i o completes

00:28:00,720 --> 00:28:07,760
um and we include the winqueue the

00:28:04,240 --> 00:28:08,559
completion with a successful return

00:28:07,760 --> 00:28:11,760
status

00:28:08,559 --> 00:28:14,640
and we raise an interrupt

00:28:11,760 --> 00:28:16,880
and finally when the host has actually

00:28:14,640 --> 00:28:20,000
read this the host will write back

00:28:16,880 --> 00:28:20,640
to the completion queue doorbell and say

00:28:20,000 --> 00:28:23,760
okay

00:28:20,640 --> 00:28:26,960
thank you i actually read the

00:28:23,760 --> 00:28:31,840
red the completion and it is now

00:28:26,960 --> 00:28:31,840
free for you as a controller to reuse

00:28:32,880 --> 00:28:37,679
okay so let's now look at the sound

00:28:36,080 --> 00:28:41,279
namespace command set or

00:28:37,679 --> 00:28:44,159
and the nvme sound namespaces

00:28:41,279 --> 00:28:46,240
so a sound namespace is basically just a

00:28:44,159 --> 00:28:48,640
normal namespace that is divided into

00:28:46,240 --> 00:28:51,520
contiguous non-overlapping logical block

00:28:48,640 --> 00:28:54,640
address ranges that we call zones

00:28:51,520 --> 00:28:58,080
now while we still have the entire

00:28:54,640 --> 00:29:00,159
lba space from 0 to n minus 1 in being

00:28:58,080 --> 00:29:02,799
the capacity of the namespace

00:29:00,159 --> 00:29:04,799
each of the zones has a certain capacity

00:29:02,799 --> 00:29:06,960
and a certain size

00:29:04,799 --> 00:29:09,360
this means that in the same address

00:29:06,960 --> 00:29:11,840
range we now get a number of zones from

00:29:09,360 --> 00:29:13,360
one two three and so forth up to the

00:29:11,840 --> 00:29:16,240
maximum number of zones

00:29:13,360 --> 00:29:17,600
that can fit into this namespace the

00:29:16,240 --> 00:29:20,720
zones are defined with

00:29:17,600 --> 00:29:23,840
a number of properties including

00:29:20,720 --> 00:29:26,080
its state these are the

00:29:23,840 --> 00:29:27,039
an empty state which means that the zone

00:29:26,080 --> 00:29:30,960
has not

00:29:27,039 --> 00:29:34,080
had anything written to it yet it is a

00:29:30,960 --> 00:29:35,600
number of open open state

00:29:34,080 --> 00:29:37,440
which is means that it's basically

00:29:35,600 --> 00:29:39,120
partially written it's also something

00:29:37,440 --> 00:29:41,600
called closed which is

00:29:39,120 --> 00:29:42,960
actually also a partially written state

00:29:41,600 --> 00:29:45,200
and there is

00:29:42,960 --> 00:29:46,640
the full state which means that you

00:29:45,200 --> 00:29:50,159
cannot write anything

00:29:46,640 --> 00:29:51,840
to the to the zone anymore and then

00:29:50,159 --> 00:29:54,080
there are a couple of error states the

00:29:51,840 --> 00:29:55,919
read-only state and the offline state

00:29:54,080 --> 00:29:58,720
which means that something has happened

00:29:55,919 --> 00:30:00,880
to to the zone

00:29:58,720 --> 00:30:01,840
another important parameter is the zone

00:30:00,880 --> 00:30:04,880
right pointer

00:30:01,840 --> 00:30:07,039
and the right pointer is point to the

00:30:04,880 --> 00:30:09,360
location at which the next right

00:30:07,039 --> 00:30:11,360
must begin and whenever a write

00:30:09,360 --> 00:30:11,919
completes the songwrite pointer is

00:30:11,360 --> 00:30:14,159
advanced

00:30:11,919 --> 00:30:16,559
and points to the next free location in

00:30:14,159 --> 00:30:19,840
the zone and

00:30:16,559 --> 00:30:20,880
any attempt to write to start a right

00:30:19,840 --> 00:30:22,799
has something

00:30:20,880 --> 00:30:25,360
not pointing and not at the right point

00:30:22,799 --> 00:30:27,520
will result in an error

00:30:25,360 --> 00:30:28,640
there's also because of this right

00:30:27,520 --> 00:30:31,279
pointer there is

00:30:28,640 --> 00:30:31,679
a one zone one right rule that basically

00:30:31,279 --> 00:30:34,480
says

00:30:31,679 --> 00:30:35,919
that you should not submit multiple

00:30:34,480 --> 00:30:38,960
commands

00:30:35,919 --> 00:30:40,080
against one zone at the same time you

00:30:38,960 --> 00:30:42,399
have to submit

00:30:40,080 --> 00:30:44,640
one right against the zone at the zone

00:30:42,399 --> 00:30:46,080
right pointer wait for that to complete

00:30:44,640 --> 00:30:48,799
when you know it's completed you can

00:30:46,080 --> 00:30:52,559
write to the next position

00:30:48,799 --> 00:30:54,480
with the updates uh some right now

00:30:52,559 --> 00:30:56,000
so there is a way to solve this it's

00:30:54,480 --> 00:30:58,640
called zone appending

00:30:56,000 --> 00:30:59,120
but it is uh and we shall look at that

00:30:58,640 --> 00:31:02,960
in

00:30:59,120 --> 00:31:04,000
a second so one of the things that comes

00:31:02,960 --> 00:31:07,519
with the territory

00:31:04,000 --> 00:31:09,440
of using some name spaces is a certain

00:31:07,519 --> 00:31:10,559
amount of explicit zone resource

00:31:09,440 --> 00:31:13,519
management

00:31:10,559 --> 00:31:14,480
that means that the host is now

00:31:13,519 --> 00:31:18,240
responsible

00:31:14,480 --> 00:31:20,480
for a number of the tasks that the

00:31:18,240 --> 00:31:21,279
sunstake device usually used to do for

00:31:20,480 --> 00:31:24,240
you

00:31:21,279 --> 00:31:25,120
what this means is that the host gains a

00:31:24,240 --> 00:31:28,559
certain amount

00:31:25,120 --> 00:31:32,000
of control over how resources

00:31:28,559 --> 00:31:35,279
are used on the device

00:31:32,000 --> 00:31:38,240
so and this is the the reason for for

00:31:35,279 --> 00:31:38,799
all of these states so basically a full

00:31:38,240 --> 00:31:40,880
state

00:31:38,799 --> 00:31:42,399
means that the control a full and open

00:31:40,880 --> 00:31:44,240
state basically means that

00:31:42,399 --> 00:31:45,440
that the zone is not really using any

00:31:44,240 --> 00:31:46,960
resources

00:31:45,440 --> 00:31:48,880
but as soon as you start writing

00:31:46,960 --> 00:31:49,440
something to the device and it moves

00:31:48,880 --> 00:31:52,640
into an

00:31:49,440 --> 00:31:54,399
opened or closed state it will take up a

00:31:52,640 --> 00:31:55,120
certain amount of resources on the

00:31:54,399 --> 00:31:58,559
device

00:31:55,120 --> 00:32:02,159
the device must keep

00:31:58,559 --> 00:32:03,679
the current um value of the right point

00:32:02,159 --> 00:32:06,720
of somewhere in minimary

00:32:03,679 --> 00:32:07,440
uh with the open zones there's typically

00:32:06,720 --> 00:32:09,519
a

00:32:07,440 --> 00:32:10,720
right buffer involved so there's a bunch

00:32:09,519 --> 00:32:13,600
of memory that

00:32:10,720 --> 00:32:14,000
that needs to be managed here now the

00:32:13,600 --> 00:32:17,039
open

00:32:14,000 --> 00:32:17,039
state is actually

00:32:18,480 --> 00:32:23,519
it's actually two different states so

00:32:20,960 --> 00:32:26,320
it's an explicitly open state and an

00:32:23,519 --> 00:32:28,000
implicitly open state the implicitly

00:32:26,320 --> 00:32:30,399
open state is something that the

00:32:28,000 --> 00:32:32,399
controller is a little bit more in

00:32:30,399 --> 00:32:35,760
involved in that that means that the

00:32:32,399 --> 00:32:38,320
controller is allowed to move

00:32:35,760 --> 00:32:40,640
to move the the zone out of the implicit

00:32:38,320 --> 00:32:42,320
theorem statement into the closed state

00:32:40,640 --> 00:32:45,519
but this is not something that is

00:32:42,320 --> 00:32:46,559
allowed if the host has explicitly

00:32:45,519 --> 00:32:48,240
opened the zone

00:32:46,559 --> 00:32:49,760
and moved it into the explicitly open

00:32:48,240 --> 00:32:52,559
state it is

00:32:49,760 --> 00:32:54,000
at that point the host's responsibility

00:32:52,559 --> 00:32:56,320
to make sure that there are enough

00:32:54,000 --> 00:32:59,360
resources on the device

00:32:56,320 --> 00:33:01,840
for all zones to be in the

00:32:59,360 --> 00:33:03,360
in the in the states that the host

00:33:01,840 --> 00:33:06,480
wanted them to

00:33:03,360 --> 00:33:08,240
if any of these resources are violated

00:33:06,480 --> 00:33:10,880
this will also give an error when you're

00:33:08,240 --> 00:33:14,000
trying to write to a certain zone and

00:33:10,880 --> 00:33:15,919
and resources are not available

00:33:14,000 --> 00:33:17,200
so as you can maybe see there are a

00:33:15,919 --> 00:33:20,720
bunch of

00:33:17,200 --> 00:33:22,480
complexities involved so there is this

00:33:20,720 --> 00:33:25,039
explicit zone management that you

00:33:22,480 --> 00:33:29,120
certainly have to do that you didn't you

00:33:25,039 --> 00:33:30,960
used to do um you now have to there's a

00:33:29,120 --> 00:33:33,600
new command used to actually get

00:33:30,960 --> 00:33:36,080
information about all the zones in the

00:33:33,600 --> 00:33:38,000
in the name space and you have to

00:33:36,080 --> 00:33:39,679
manually reset these zones whenever

00:33:38,000 --> 00:33:41,360
you've written something to them yet

00:33:39,679 --> 00:33:43,440
that you don't want to use anymore or

00:33:41,360 --> 00:33:46,399
you want to overwrite the song you have

00:33:43,440 --> 00:33:48,240
to manage the number of resources

00:33:46,399 --> 00:33:49,679
you do this through the zone management

00:33:48,240 --> 00:33:54,159
send command

00:33:49,679 --> 00:33:56,320
um if you want to do a higher q depth

00:33:54,159 --> 00:33:58,399
right to a single zone you have to use

00:33:56,320 --> 00:34:00,799
something called zona pending

00:33:58,399 --> 00:34:03,440
which solves the one zone one right rule

00:34:00,799 --> 00:34:04,559
but at the cost that you don't actually

00:34:03,440 --> 00:34:07,600
know where your data

00:34:04,559 --> 00:34:09,520
is being written to instead of writing

00:34:07,600 --> 00:34:12,079
to a certain point in the zone you

00:34:09,520 --> 00:34:13,119
are just saying i want this data to go

00:34:12,079 --> 00:34:16,320
to this zone

00:34:13,119 --> 00:34:17,760
and when when the write has completed

00:34:16,320 --> 00:34:19,839
the controller will inform

00:34:17,760 --> 00:34:22,399
you in the completion queue entry of

00:34:19,839 --> 00:34:24,800
where did the data actually ended up

00:34:22,399 --> 00:34:26,720
so as you can see there are a number of

00:34:24,800 --> 00:34:29,760
complexities

00:34:26,720 --> 00:34:32,159
and this is where a

00:34:29,760 --> 00:34:34,000
a device model such as the nvme

00:34:32,159 --> 00:34:37,040
controller in qemu that implements

00:34:34,000 --> 00:34:37,440
this becomes extremely useful this means

00:34:37,040 --> 00:34:40,560
that

00:34:37,440 --> 00:34:42,639
using this device you can start

00:34:40,560 --> 00:34:45,440
developing applications to use these

00:34:42,639 --> 00:34:47,919
extremely efficient drives

00:34:45,440 --> 00:34:49,280
and i will leave it to the marketing

00:34:47,919 --> 00:34:52,480
people to actually

00:34:49,280 --> 00:34:53,200
uh sell these drives but let me just say

00:34:52,480 --> 00:34:57,200
that

00:34:53,200 --> 00:35:01,040
uh there are a number of

00:34:57,200 --> 00:35:05,200
of efficiencies by using showing

00:35:01,040 --> 00:35:07,520
some devices they are

00:35:05,200 --> 00:35:08,560
way more efficient but of course it

00:35:07,520 --> 00:35:12,240
comes at the cost

00:35:08,560 --> 00:35:14,079
of this slightly higher complexity

00:35:12,240 --> 00:35:15,760
so using this device you can actually

00:35:14,079 --> 00:35:19,119
start developing

00:35:15,760 --> 00:35:21,359
applications for it and to set up a

00:35:19,119 --> 00:35:22,720
zoned namespace device intuimo what you

00:35:21,359 --> 00:35:25,920
do is that you

00:35:22,720 --> 00:35:28,640
on the nvme namespace device you add

00:35:25,920 --> 00:35:29,920
that it should put it should use the i o

00:35:28,640 --> 00:35:33,040
command set

00:35:29,920 --> 00:35:36,400
with the identifier 2 which is the

00:35:33,040 --> 00:35:39,200
the identifier allocated in

00:35:36,400 --> 00:35:40,800
nvme to the zone namespace and you

00:35:39,200 --> 00:35:44,160
provide the capacity

00:35:40,800 --> 00:35:44,960
of each zone what you get here is that

00:35:44,160 --> 00:35:47,760
you get full

00:35:44,960 --> 00:35:48,320
mandatory and most optional support for

00:35:47,760 --> 00:35:51,839
everything

00:35:48,320 --> 00:35:53,839
in the uh rectified technical proposal

00:35:51,839 --> 00:35:55,119
that is you get the zone management send

00:35:53,839 --> 00:35:57,839
receive commands

00:35:55,119 --> 00:35:59,760
you get non-sequential that is higher

00:35:57,839 --> 00:36:01,920
qdf1

00:35:59,760 --> 00:36:03,599
sona pen command you get tracking

00:36:01,920 --> 00:36:06,400
management and enforcement

00:36:03,599 --> 00:36:07,440
of of some resources even though they

00:36:06,400 --> 00:36:11,920
don't mean that much

00:36:07,440 --> 00:36:13,520
to the actual device the qemo device

00:36:11,920 --> 00:36:15,359
but you can at least emulate it and you

00:36:13,520 --> 00:36:18,720
can see how a real device would

00:36:15,359 --> 00:36:21,680
put what would behave and you get a lot

00:36:18,720 --> 00:36:25,599
of trace events that can be used for

00:36:21,680 --> 00:36:27,839
debugging and protocol inspection

00:36:25,599 --> 00:36:29,920
so fundamentally this requires the

00:36:27,839 --> 00:36:31,839
implementation of two core features

00:36:29,920 --> 00:36:33,599
it requires the implementation of the

00:36:31,839 --> 00:36:35,520
zone resource management state machine

00:36:33,599 --> 00:36:36,320
which is basically just a big switch

00:36:35,520 --> 00:36:39,760
statement

00:36:36,320 --> 00:36:41,839
this is what needs to handle

00:36:39,760 --> 00:36:44,560
to validate the zone transition between

00:36:41,839 --> 00:36:47,760
states and it needs to track various

00:36:44,560 --> 00:36:50,160
show resource usage the other big part

00:36:47,760 --> 00:36:50,960
is handling these zone write pointer

00:36:50,160 --> 00:36:53,440
updates

00:36:50,960 --> 00:36:55,280
that is advancing the right point of

00:36:53,440 --> 00:36:58,240
whenever a right completes

00:36:55,280 --> 00:36:59,680
it is making sure that the right point

00:36:58,240 --> 00:37:01,680
is not violated

00:36:59,680 --> 00:37:03,440
when a new right comes in stuff like

00:37:01,680 --> 00:37:05,839
that

00:37:03,440 --> 00:37:07,599
so it is a relatively modest chain set

00:37:05,839 --> 00:37:09,839
and

00:37:07,599 --> 00:37:11,920
where we are actually using while while

00:37:09,839 --> 00:37:14,720
there is about 1500

00:37:11,920 --> 00:37:17,119
lines of code inserted into the code the

00:37:14,720 --> 00:37:17,440
vast majority of this goes to basically

00:37:17,119 --> 00:37:21,200
the

00:37:17,440 --> 00:37:22,640
is the state machine

00:37:21,200 --> 00:37:25,280
just implementing a couple of the

00:37:22,640 --> 00:37:28,240
commands um

00:37:25,280 --> 00:37:28,800
which is just accounting commands and

00:37:28,240 --> 00:37:32,240
the

00:37:28,800 --> 00:37:33,680
um the 250 lines of specification and

00:37:32,240 --> 00:37:37,200
internal data structures

00:37:33,680 --> 00:37:39,200
so all in all there is just about 350

00:37:37,200 --> 00:37:41,119
lines of code that's actually hooking

00:37:39,200 --> 00:37:44,400
into the actual i o path

00:37:41,119 --> 00:37:48,880
in the device and this is mostly

00:37:44,400 --> 00:37:51,119
basically handling the right pointer

00:37:48,880 --> 00:37:52,560
you can get this headset from from the

00:37:51,119 --> 00:37:55,839
links i have here

00:37:52,560 --> 00:37:58,320
on the slides so

00:37:55,839 --> 00:37:59,520
uh let's briefly look at how these uh

00:37:58,320 --> 00:38:02,720
write pointer updates

00:37:59,520 --> 00:38:05,760
is actually managed in in the device so

00:38:02,720 --> 00:38:08,000
a very obvious and maybe naive way of

00:38:05,760 --> 00:38:09,119
of of handling the right point of dates

00:38:08,000 --> 00:38:12,400
would just be to

00:38:09,119 --> 00:38:12,960
update it by the number of blocks

00:38:12,400 --> 00:38:16,240
written

00:38:12,960 --> 00:38:16,960
when the write is complete now the

00:38:16,240 --> 00:38:20,800
problem here

00:38:16,960 --> 00:38:24,160
is that if we were to verify the rights

00:38:20,800 --> 00:38:26,079
then we would certainly allow multiple

00:38:24,160 --> 00:38:30,079
rights to go

00:38:26,079 --> 00:38:32,160
and be written at the same location

00:38:30,079 --> 00:38:33,599
in the zone which is not allowed by the

00:38:32,160 --> 00:38:35,040
specification

00:38:33,599 --> 00:38:36,880
the point here is that this is not

00:38:35,040 --> 00:38:39,920
allowed by actual nand

00:38:36,880 --> 00:38:41,200
so so so so this is why i would not be

00:38:39,920 --> 00:38:44,240
allowed here

00:38:41,200 --> 00:38:46,400
now uh

00:38:44,240 --> 00:38:47,280
we also have the problem that we would

00:38:46,400 --> 00:38:50,640
not know

00:38:47,280 --> 00:38:52,240
what the next next value of the right

00:38:50,640 --> 00:38:54,640
pointer would be so we cannot really

00:38:52,240 --> 00:38:58,240
efficiently support zone bet

00:38:54,640 --> 00:39:00,400
now the obvious solution here is to use

00:38:58,240 --> 00:39:02,320
a staging right pointer what we mean

00:39:00,400 --> 00:39:03,920
here is that we use a right pointer so

00:39:02,320 --> 00:39:05,040
now we have two red pointers we have a

00:39:03,920 --> 00:39:08,079
right pointer that is

00:39:05,040 --> 00:39:08,560
the authoritative right pointer that is

00:39:08,079 --> 00:39:11,599
tied

00:39:08,560 --> 00:39:12,720
to the actual zone and then we have an

00:39:11,599 --> 00:39:14,960
internal

00:39:12,720 --> 00:39:16,960
in-memory staging right pointer that we

00:39:14,960 --> 00:39:17,839
advance immediately when the right comes

00:39:16,960 --> 00:39:20,720
in

00:39:17,839 --> 00:39:22,000
and having that right point means that

00:39:20,720 --> 00:39:25,040
now we know

00:39:22,000 --> 00:39:26,720
that we have something in flight and

00:39:25,040 --> 00:39:29,119
that the right point of all these

00:39:26,720 --> 00:39:30,800
succeed then the right pointer is at

00:39:29,119 --> 00:39:32,640
this location or it's going to

00:39:30,800 --> 00:39:34,640
going to be at this location at some

00:39:32,640 --> 00:39:37,760
point this means that as

00:39:34,640 --> 00:39:39,280
right comes in it is trivial to

00:39:37,760 --> 00:39:41,599
determine if we have a right point of

00:39:39,280 --> 00:39:42,880
violation and it's also trivial to

00:39:41,599 --> 00:39:45,200
support the sona pen

00:39:42,880 --> 00:39:46,880
because we can now just use the staging

00:39:45,200 --> 00:39:48,640
right pointer as the location of the

00:39:46,880 --> 00:39:51,680
next writing

00:39:48,640 --> 00:39:53,440
so we will update the authoritative zone

00:39:51,680 --> 00:39:56,480
right pointer the actual so right

00:39:53,440 --> 00:39:59,680
pointer whenever the ei was complete

00:39:56,480 --> 00:40:02,800
and while this

00:39:59,680 --> 00:40:07,119
actually allows a higher

00:40:02,800 --> 00:40:11,839
normal regular rights to be issued

00:40:07,119 --> 00:40:11,839
in order to the device and actually

00:40:12,960 --> 00:40:19,520
actually being completed and processed

00:40:16,319 --> 00:40:19,760
without without any big issues this is

00:40:19,520 --> 00:40:22,079
an

00:40:19,760 --> 00:40:22,800
implementation detail of qemo because

00:40:22,079 --> 00:40:25,359
the

00:40:22,800 --> 00:40:26,240
commands in the commission queue are

00:40:25,359 --> 00:40:29,839
handled in

00:40:26,240 --> 00:40:33,040
uh in order or sequentially but this is

00:40:29,839 --> 00:40:36,079
this is a this is a

00:40:33,040 --> 00:40:39,680
implementation detail of qremo so

00:40:36,079 --> 00:40:41,839
qmo allows this to be cached

00:40:39,680 --> 00:40:43,119
and actually reply to the user as an

00:40:41,839 --> 00:40:44,480
error that

00:40:43,119 --> 00:40:46,160
oh you're doing something that you

00:40:44,480 --> 00:40:47,920
should not do

00:40:46,160 --> 00:40:49,599
and this is another example where our

00:40:47,920 --> 00:40:52,000
qemo device can

00:40:49,599 --> 00:40:53,359
can help in developing this because this

00:40:52,000 --> 00:40:57,440
is the subtle bug

00:40:53,359 --> 00:41:01,520
that you could end up doing

00:40:57,440 --> 00:41:04,560
unknowingly in your application but a

00:41:01,520 --> 00:41:06,000
real device would not actually tell you

00:41:04,560 --> 00:41:06,480
that you do something wrong they will

00:41:06,000 --> 00:41:08,720
just

00:41:06,480 --> 00:41:11,760
suddenly start spewing out errors and

00:41:08,720 --> 00:41:14,720
saying what what are you doing

00:41:11,760 --> 00:41:16,800
so let's look at a flowchart like the

00:41:14,720 --> 00:41:17,359
one we did for the basic i o command

00:41:16,800 --> 00:41:19,200
processing

00:41:17,359 --> 00:41:21,680
and look at how zone i o processing

00:41:19,200 --> 00:41:23,599
hooks in so basically on the i o path

00:41:21,680 --> 00:41:23,839
what we do is that we say if it's this

00:41:23,599 --> 00:41:26,319
is

00:41:23,839 --> 00:41:27,040
zoned namespace then please check the

00:41:26,319 --> 00:41:31,760
zone

00:41:27,040 --> 00:41:34,480
the zone at least has to be not offline

00:41:31,760 --> 00:41:36,000
so if it is a read it's very easy

00:41:34,480 --> 00:41:37,920
because there are no differences

00:41:36,000 --> 00:41:39,920
we can just use the completely

00:41:37,920 --> 00:41:41,920
conventional read path that

00:41:39,920 --> 00:41:43,920
we already have implemented in qemo

00:41:41,920 --> 00:41:47,040
there's no right pointers we have to

00:41:43,920 --> 00:41:48,720
uh to to take care of

00:41:47,040 --> 00:41:51,040
the only thing that's important here is

00:41:48,720 --> 00:41:54,480
that the device or the zone is not in

00:41:51,040 --> 00:41:55,920
the offline state if it is a right we

00:41:54,480 --> 00:42:00,079
will transition it

00:41:55,920 --> 00:42:03,520
autonomously to the implicitly opened

00:42:00,079 --> 00:42:04,400
zone state which will mean that we will

00:42:03,520 --> 00:42:07,200
go

00:42:04,400 --> 00:42:08,480
over and call the results management

00:42:07,200 --> 00:42:10,400
state machine

00:42:08,480 --> 00:42:12,000
now the zone resource management state

00:42:10,400 --> 00:42:15,760
machine might require

00:42:12,000 --> 00:42:17,920
to close another zone or

00:42:15,760 --> 00:42:19,040
maybe even transition another zone

00:42:17,920 --> 00:42:22,319
through the full state

00:42:19,040 --> 00:42:25,040
to actually relinquish some some

00:42:22,319 --> 00:42:27,680
some resources to be used by this uh

00:42:25,040 --> 00:42:30,640
transition to the implicitly open state

00:42:27,680 --> 00:42:31,119
and that might cause a change to the

00:42:30,640 --> 00:42:34,720
zoned

00:42:31,119 --> 00:42:38,560
change change servlist log page

00:42:34,720 --> 00:42:40,640
which will further issue what's called

00:42:38,560 --> 00:42:42,160
a asynchronous event notification

00:42:40,640 --> 00:42:43,920
something we shall look a little bit

00:42:42,160 --> 00:42:46,079
more detail in the final part of this

00:42:43,920 --> 00:42:48,319
presentation

00:42:46,079 --> 00:42:49,920
so if everything goes well we will be

00:42:48,319 --> 00:42:51,200
advancing the staging right pointer and

00:42:49,920 --> 00:42:53,760
we will issue the

00:42:51,200 --> 00:42:56,480
asynchronous i o and then we will yield

00:42:53,760 --> 00:42:58,560
and wait for the ir to complete

00:42:56,480 --> 00:43:00,640
at some point the i o completes and we

00:42:58,560 --> 00:43:02,960
advance the actual right pointer

00:43:00,640 --> 00:43:04,000
if this causes the zone to move into a

00:43:02,960 --> 00:43:06,400
full state that is

00:43:04,000 --> 00:43:08,160
writing the last lpa in the zone we

00:43:06,400 --> 00:43:09,920
again go to the zone resource management

00:43:08,160 --> 00:43:11,839
state machine and transition the zone

00:43:09,920 --> 00:43:15,280
tool

00:43:11,839 --> 00:43:16,640
finally we just enqueue the completion

00:43:15,280 --> 00:43:20,560
queue entry as we do

00:43:16,640 --> 00:43:20,560
in the normal i o pad

00:43:21,440 --> 00:43:25,040
so for the final part of this

00:43:22,800 --> 00:43:27,200
presentation let's now look at how we

00:43:25,040 --> 00:43:29,599
can add a custom

00:43:27,200 --> 00:43:30,880
nvme command in this case what we're

00:43:29,599 --> 00:43:34,240
going to try to implement

00:43:30,880 --> 00:43:36,160
is a asynchronous event notification

00:43:34,240 --> 00:43:39,200
trigger command

00:43:36,160 --> 00:43:40,079
now nvme includes a mechanism for the

00:43:39,200 --> 00:43:43,359
controller to

00:43:40,079 --> 00:43:46,800
out of band notify the host software

00:43:43,359 --> 00:43:48,000
of certain events that happen on the

00:43:46,800 --> 00:43:51,839
controller

00:43:48,000 --> 00:43:53,839
and the way this works is not unlike

00:43:51,839 --> 00:43:56,079
what you would call long calling if you

00:43:53,839 --> 00:43:59,119
ever did some kind of web development

00:43:56,079 --> 00:44:02,160
basically the host submits

00:43:59,119 --> 00:44:03,119
a request the asynchronous event request

00:44:02,160 --> 00:44:06,079
command

00:44:03,119 --> 00:44:08,400
this is an admin command and then it

00:44:06,079 --> 00:44:11,440
just waits

00:44:08,400 --> 00:44:12,319
the command does not have a timeout and

00:44:11,440 --> 00:44:15,839
it will not

00:44:12,319 --> 00:44:19,040
reply or complete immediately instead

00:44:15,839 --> 00:44:22,720
when at some point in event occurs

00:44:19,040 --> 00:44:26,640
the controller will complete the command

00:44:22,720 --> 00:44:29,760
and the command completion cue

00:44:26,640 --> 00:44:32,079
entry will include information about

00:44:29,760 --> 00:44:33,119
the event as we can see below here you

00:44:32,079 --> 00:44:37,119
see that

00:44:33,119 --> 00:44:40,640
it includes in the d word zero of the

00:44:37,119 --> 00:44:44,400
completion queue entry

00:44:40,640 --> 00:44:46,800
we get the type of the event we get some

00:44:44,400 --> 00:44:47,680
particular information about the event

00:44:46,800 --> 00:44:50,800
and we get

00:44:47,680 --> 00:44:52,240
a lock page identifier the point here is

00:44:50,800 --> 00:44:54,800
that all events are tied

00:44:52,240 --> 00:44:56,000
to a log page so whenever an event

00:44:54,800 --> 00:44:58,319
happens

00:44:56,000 --> 00:44:59,119
the way for the host to sort of

00:44:58,319 --> 00:45:03,680
acknowledge

00:44:59,119 --> 00:45:06,160
that it actually saw the event and

00:45:03,680 --> 00:45:08,000
chosen how to respond to the event is by

00:45:06,160 --> 00:45:09,760
reading that blog page for additional

00:45:08,000 --> 00:45:13,440
information about the event

00:45:09,760 --> 00:45:16,160
and um and then the controller

00:45:13,440 --> 00:45:18,000
knows that the host has acknowledged and

00:45:16,160 --> 00:45:20,480
is at least now informed about this

00:45:18,000 --> 00:45:22,960
event that could be critical it could be

00:45:20,480 --> 00:45:25,359
a transient but it could be a lot of

00:45:22,960 --> 00:45:27,440
different stuff

00:45:25,359 --> 00:45:29,599
so the events are grouped into types

00:45:27,440 --> 00:45:30,480
there are the error types which is

00:45:29,599 --> 00:45:32,640
general

00:45:30,480 --> 00:45:34,880
a general error that is not associated

00:45:32,640 --> 00:45:37,040
with any specific command

00:45:34,880 --> 00:45:38,400
then there are smart health information

00:45:37,040 --> 00:45:41,200
sort of like hey

00:45:38,400 --> 00:45:42,640
the temperature is too big too high on

00:45:41,200 --> 00:45:46,000
this device

00:45:42,640 --> 00:45:49,920
please turn up the cooling

00:45:46,000 --> 00:45:51,680
uh various notices that oh something

00:45:49,920 --> 00:45:53,440
changed here you might want to know

00:45:51,680 --> 00:45:55,680
about that

00:45:53,440 --> 00:45:57,200
but not really critical then there are

00:45:55,680 --> 00:45:59,280
some command specific

00:45:57,200 --> 00:46:01,520
events that can be defined by the

00:45:59,280 --> 00:46:04,400
various i o command sets as we saw

00:46:01,520 --> 00:46:05,200
earlier actually this is one of the uh

00:46:04,400 --> 00:46:08,319
commands

00:46:05,200 --> 00:46:11,839
that the zone command set has this uh

00:46:08,319 --> 00:46:15,680
particular event that is that oh

00:46:11,839 --> 00:46:18,400
some other command or whatever in

00:46:15,680 --> 00:46:18,880
the zone name space certainly caused the

00:46:18,400 --> 00:46:21,359
state

00:46:18,880 --> 00:46:22,880
of this zone to change and that's

00:46:21,359 --> 00:46:24,400
something that the host would like to

00:46:22,880 --> 00:46:27,119
know about

00:46:24,400 --> 00:46:28,640
instead of just constantly looking at

00:46:27,119 --> 00:46:30,640
all the zones

00:46:28,640 --> 00:46:31,760
the the controller is now able to

00:46:30,640 --> 00:46:34,000
actually tell the

00:46:31,760 --> 00:46:35,599
device or tell the host that oh this

00:46:34,000 --> 00:46:39,119
song this particular song

00:46:35,599 --> 00:46:40,800
changed the stick now there's also some

00:46:39,119 --> 00:46:43,119
vendor-specific stuff of course

00:46:40,800 --> 00:46:45,440
that that anyone can choose to implement

00:46:43,119 --> 00:46:47,680
the way to see fit

00:46:45,440 --> 00:46:50,319
so the basic information is included in

00:46:47,680 --> 00:46:53,520
the cqe as we saw

00:46:50,319 --> 00:46:56,319
and but if you want more information

00:46:53,520 --> 00:46:57,520
about the error you have to go to this

00:46:56,319 --> 00:47:00,560
log page

00:46:57,520 --> 00:47:04,160
that is in the identifier so

00:47:00,560 --> 00:47:06,160
the let's build a identif

00:47:04,160 --> 00:47:10,480
a synchronous event notification trigger

00:47:06,160 --> 00:47:13,040
command now the point is that this

00:47:10,480 --> 00:47:15,200
the the the asynchronous event

00:47:13,040 --> 00:47:16,480
notification mechanism is very difficult

00:47:15,200 --> 00:47:20,400
to test

00:47:16,480 --> 00:47:21,839
uh spdk includes a test case for this

00:47:20,400 --> 00:47:25,359
and what it does basically

00:47:21,839 --> 00:47:29,599
is going in and forcing the device

00:47:25,359 --> 00:47:31,839
to uh to basically raise an event

00:47:29,599 --> 00:47:34,319
because of a temperature going too high

00:47:31,839 --> 00:47:36,800
because you can control the threshold

00:47:34,319 --> 00:47:39,040
and what we do instead here now is

00:47:36,800 --> 00:47:40,800
trying inquirymoon to produce a command

00:47:39,040 --> 00:47:44,800
that will

00:47:40,800 --> 00:47:47,680
include from the host include the type

00:47:44,800 --> 00:47:49,440
the information and the log page that

00:47:47,680 --> 00:47:50,160
should be included in the event

00:47:49,440 --> 00:47:53,200
generated

00:47:50,160 --> 00:47:56,319
so upon receiving a command like this

00:47:53,200 --> 00:47:59,520
the uh qmo device should

00:47:56,319 --> 00:48:01,839
enqueue a asynchronous event uh

00:47:59,520 --> 00:48:03,359
notification if there are any

00:48:01,839 --> 00:48:06,880
outstanding

00:48:03,359 --> 00:48:06,880
asynchronous event requests

00:48:07,920 --> 00:48:12,319
so here we have the actual code required

00:48:10,720 --> 00:48:14,880
to implement this

00:48:12,319 --> 00:48:15,599
new command so what we see here is that

00:48:14,880 --> 00:48:18,800
we have

00:48:15,599 --> 00:48:21,599
enabled or added a new

00:48:18,800 --> 00:48:22,720
a new up code for this vendor-specific

00:48:21,599 --> 00:48:25,520
command

00:48:22,720 --> 00:48:26,480
uh it is in the range of the values

00:48:25,520 --> 00:48:28,720
reserved for

00:48:26,480 --> 00:48:30,160
vendor-specific commands and we have

00:48:28,720 --> 00:48:32,839
chosen the

00:48:30,160 --> 00:48:34,640
the first one available the actual

00:48:32,839 --> 00:48:36,559
command

00:48:34,640 --> 00:48:38,559
is pretty simple and it will just

00:48:36,559 --> 00:48:41,040
extract uh the keyword

00:48:38,559 --> 00:48:42,720
that we have chosen to to hold the

00:48:41,040 --> 00:48:46,960
information about the event

00:48:42,720 --> 00:48:49,280
it will extract the event type the info

00:48:46,960 --> 00:48:50,640
log page and it will verify that the log

00:48:49,280 --> 00:48:53,760
page is valid

00:48:50,640 --> 00:48:56,480
and then it will eq an event with

00:48:53,760 --> 00:48:57,920
these information this information if we

00:48:56,480 --> 00:48:58,800
go down here we can also see that

00:48:57,920 --> 00:49:00,800
because this is an

00:48:58,800 --> 00:49:02,079
admin command we are hooking into the

00:49:00,800 --> 00:49:05,359
nvme admin command

00:49:02,079 --> 00:49:10,400
function and we're just gonna match

00:49:05,359 --> 00:49:13,599
on the up code and issue that command

00:49:10,400 --> 00:49:16,800
so let's see uh back here in our remove

00:49:13,599 --> 00:49:17,359
how this this actually works so what we

00:49:16,800 --> 00:49:20,559
have here

00:49:17,359 --> 00:49:22,160
is a qmo with support for this command

00:49:20,559 --> 00:49:24,160
so the first thing we're going to do is

00:49:22,160 --> 00:49:26,160
be using the nvme tool

00:49:24,160 --> 00:49:27,280
and with the admin passthrough command

00:49:26,160 --> 00:49:30,000
and passing

00:49:27,280 --> 00:49:31,440
the asynchronous event request command

00:49:30,000 --> 00:49:33,040
it doesn't have any other parameters

00:49:31,440 --> 00:49:34,720
than the actual upgrade

00:49:33,040 --> 00:49:36,160
we see in the trace that we're not

00:49:34,720 --> 00:49:37,599
waiting here

00:49:36,160 --> 00:49:39,680
so the next thing we're going to do now

00:49:37,599 --> 00:49:41,200
is generate an event force the

00:49:39,680 --> 00:49:42,720
controller to generate an event we're

00:49:41,200 --> 00:49:45,119
using this new command we're going to

00:49:42,720 --> 00:49:47,599
use the admin passthrough command again

00:49:45,119 --> 00:49:49,200
and we're going to put the with our new

00:49:47,599 --> 00:49:51,119
up code that we have defined

00:49:49,200 --> 00:49:53,280
and then we're going to put the

00:49:51,119 --> 00:49:56,319
information about in d word 10

00:49:53,280 --> 00:50:00,960
that will we

00:49:56,319 --> 00:50:03,440
are generating a smart typed

00:50:00,960 --> 00:50:04,319
event it's about temperature doesn't

00:50:03,440 --> 00:50:06,880
really matter

00:50:04,319 --> 00:50:08,480
and we want you to read the smart

00:50:06,880 --> 00:50:11,599
information

00:50:08,480 --> 00:50:13,760
log page to clear the actual event now

00:50:11,599 --> 00:50:15,440
generating this command we now see that

00:50:13,760 --> 00:50:18,000
the

00:50:15,440 --> 00:50:19,440
actual aer completed immediately and we

00:50:18,000 --> 00:50:22,319
see in the trace here that

00:50:19,440 --> 00:50:23,040
the trigger came in this caused the

00:50:22,319 --> 00:50:25,599
event to be

00:50:23,040 --> 00:50:26,559
queued the aers that are currently

00:50:25,599 --> 00:50:30,160
queued up will be

00:50:26,559 --> 00:50:31,119
processed and the completion q entry for

00:50:30,160 --> 00:50:35,040
that aer

00:50:31,119 --> 00:50:39,040
is posted now

00:50:35,040 --> 00:50:42,480
interestingly if we now hook up another

00:50:39,040 --> 00:50:43,359
aer and we try to generate a new event

00:50:42,480 --> 00:50:46,000
we see that the

00:50:43,359 --> 00:50:46,720
event is actually enqueued it is

00:50:46,000 --> 00:50:48,720
generated

00:50:46,720 --> 00:50:50,880
but it is currently matched what this

00:50:48,720 --> 00:50:52,720
means is that because the host has not

00:50:50,880 --> 00:50:54,400
yet written they read the log page

00:50:52,720 --> 00:50:56,319
we're not going to be generating any

00:50:54,400 --> 00:50:57,599
more events of this type until the log

00:50:56,319 --> 00:51:01,359
page has been written

00:50:57,599 --> 00:51:02,800
has been read so this event is basically

00:51:01,359 --> 00:51:06,800
ignored

00:51:02,800 --> 00:51:09,839
so we can read the smart log

00:51:06,800 --> 00:51:12,880
to clear this event doing that

00:51:09,839 --> 00:51:16,720
we can now again generate the event

00:51:12,880 --> 00:51:19,599
and the admin aer should complete

00:51:16,720 --> 00:51:19,599
and so it does

00:51:19,839 --> 00:51:23,599
so that actually concludes my talk and

00:51:22,640 --> 00:51:27,040
thank you very much

00:51:23,599 --> 00:51:29,680
for attending if you got to this point

00:51:27,040 --> 00:51:31,520
uh please reach out if you have any

00:51:29,680 --> 00:51:32,319
questions or feedbacks but i hope that

00:51:31,520 --> 00:51:36,319
this

00:51:32,319 --> 00:51:39,359
talk uh maybe demystified the

00:51:36,319 --> 00:51:42,720
mvv device for you and

00:51:39,359 --> 00:51:44,960
maybe encouraged you to actually try and

00:51:42,720 --> 00:51:45,760
and work with this yourself we would be

00:51:44,960 --> 00:51:49,359
very happy

00:51:45,760 --> 00:51:51,520
to accept contributions as always

00:51:49,359 --> 00:51:53,599
the patches and the stuff that i've been

00:51:51,520 --> 00:51:55,839
using in this

00:51:53,599 --> 00:51:56,880
presentation are available at the git

00:51:55,839 --> 00:51:59,200
repository

00:51:56,880 --> 00:52:00,480
in the bottom of this slide and if you

00:51:59,200 --> 00:52:01,680
have any kind of questions that we

00:52:00,480 --> 00:52:04,960
cannot handle here

00:52:01,680 --> 00:52:07,359
at the q a right after this talk

00:52:04,960 --> 00:52:08,160
please email me at the address also on

00:52:07,359 --> 00:52:18,319
this

00:52:08,160 --> 00:52:18,319

YouTube URL: https://www.youtube.com/watch?v=7w7d8GV5_B0


