Title: A New Mount API - Christian Brauner, Canonical
Publication date: 2020-11-13
Playlist: Open Source Summit & Embedded Linux Conference Europe 2020
Description: 
	A New Mount API - Christian Brauner, Canonical
Captions: 
	00:00:09,280 --> 00:00:12,400
hello everyone

00:00:12,559 --> 00:00:17,119
welcome to this session my name is

00:00:15,679 --> 00:00:21,039
christian baroner

00:00:17,119 --> 00:00:24,880
i work at canonical um

00:00:21,039 --> 00:00:28,080
and uh i'm a maintainer of the lexi lexi

00:00:24,880 --> 00:00:30,000
lexifest and related project um together

00:00:28,080 --> 00:00:30,880
with stefan with the project leaders for

00:00:30,000 --> 00:00:33,680
both of them

00:00:30,880 --> 00:00:34,719
for all of these projects um but i also

00:00:33,680 --> 00:00:37,280
work a lot on the

00:00:34,719 --> 00:00:38,879
uh on the upstream kernel and maintain

00:00:37,280 --> 00:00:42,239
various pieces

00:00:38,879 --> 00:00:42,840
in there and um i have a pretty solid

00:00:42,239 --> 00:00:46,320
focus

00:00:42,840 --> 00:00:48,160
on containers and

00:00:46,320 --> 00:00:50,399
specifically unprivileged containers

00:00:48,160 --> 00:00:54,399
both in in the kernel and

00:00:50,399 --> 00:00:57,520
in user space but also

00:00:54,399 --> 00:00:58,320
on the vfs and process management in the

00:00:57,520 --> 00:01:01,840
recent

00:00:58,320 --> 00:01:02,559
in the recent years and today i want to

00:01:01,840 --> 00:01:04,640
talk about

00:01:02,559 --> 00:01:06,320
the new mount api that has made it into

00:01:04,640 --> 00:01:09,280
the kernel over the last

00:01:06,320 --> 00:01:09,920
two years which i found to be pretty

00:01:09,280 --> 00:01:13,600
exciting

00:01:09,920 --> 00:01:15,920
and that has the potential to make

00:01:13,600 --> 00:01:18,159
a lot of the stuff that we have to do in

00:01:15,920 --> 00:01:20,400
user space with containers

00:01:18,159 --> 00:01:21,360
uh currently in a clunky way because of

00:01:20,400 --> 00:01:24,880
the new old

00:01:21,360 --> 00:01:26,560
mount api um in a much in a much simpler

00:01:24,880 --> 00:01:30,000
way and also

00:01:26,560 --> 00:01:32,720
has great potential for extensibility to

00:01:30,000 --> 00:01:33,280
implement newer features uh in the

00:01:32,720 --> 00:01:36,960
future

00:01:33,280 --> 00:01:38,640
but today i'm um so the plan i have is

00:01:36,960 --> 00:01:41,920
roughly

00:01:38,640 --> 00:01:44,799
um i want to go through

00:01:41,920 --> 00:01:45,439
uh i want to introduce the concept of a

00:01:44,799 --> 00:01:47,360
mount well

00:01:45,439 --> 00:01:48,880
basically in a in a in a rough sense

00:01:47,360 --> 00:01:51,040
introduce the concept of a mount and

00:01:48,880 --> 00:01:53,759
what different aspects this has

00:01:51,040 --> 00:01:54,720
uh this involves um and then i want to

00:01:53,759 --> 00:01:57,759
go over the old

00:01:54,720 --> 00:02:00,479
mount api

00:01:57,759 --> 00:02:02,799
and possibly and also mention a few of

00:02:00,479 --> 00:02:05,920
its limitations

00:02:02,799 --> 00:02:08,800
and then introduce the new mount api

00:02:05,920 --> 00:02:11,120
step by step by taking a look at the

00:02:08,800 --> 00:02:14,239
various syscalls involved

00:02:11,120 --> 00:02:16,400
but i also want to be quite um i hope to

00:02:14,239 --> 00:02:18,080
be quite demo heavy real i need to see

00:02:16,400 --> 00:02:20,879
how we'll do on time

00:02:18,080 --> 00:02:22,319
i i'm not a fan of re-recording the same

00:02:20,879 --> 00:02:25,680
talk over and

00:02:22,319 --> 00:02:27,840
over and over again so we'll see what we

00:02:25,680 --> 00:02:31,280
do on time you get the real

00:02:27,840 --> 00:02:31,280
real life experience here

00:02:32,000 --> 00:02:39,840
so if switches to the new slide

00:02:36,560 --> 00:02:43,599
um mounting

00:02:39,840 --> 00:02:45,599
uh so mounting comes in different

00:02:43,599 --> 00:02:48,239
flavors in linux kernel

00:02:45,599 --> 00:02:50,080
um the just the thing that most people

00:02:48,239 --> 00:02:51,280
associate with mounts is mounting a

00:02:50,080 --> 00:02:54,239
proper file system

00:02:51,280 --> 00:02:55,040
like an external hard disk or a usb

00:02:54,239 --> 00:02:57,360
stick

00:02:55,040 --> 00:02:58,400
and that usually involves the creation

00:02:57,360 --> 00:03:00,319
of what the kernel

00:02:58,400 --> 00:03:02,480
calls a super block which is a

00:03:00,319 --> 00:03:05,840
representation for this new

00:03:02,480 --> 00:03:08,640
file system object

00:03:05,840 --> 00:03:09,440
but the linux kernel also allows you to

00:03:08,640 --> 00:03:12,480
create

00:03:09,440 --> 00:03:14,159
what we call bind mounts that means for

00:03:12,480 --> 00:03:15,920
example you can take an existing

00:03:14,159 --> 00:03:19,280
directory

00:03:15,920 --> 00:03:20,879
located on your file system or a file

00:03:19,280 --> 00:03:23,200
and make it available at a different

00:03:20,879 --> 00:03:25,280
location you can also

00:03:23,200 --> 00:03:26,799
bind mount an already existing mount

00:03:25,280 --> 00:03:28,799
point um

00:03:26,799 --> 00:03:30,959
somewhere else so this is quite quite

00:03:28,799 --> 00:03:32,959
flexible

00:03:30,959 --> 00:03:34,000
and bind mounts are very important for

00:03:32,959 --> 00:03:35,920
containers

00:03:34,000 --> 00:03:37,920
because we need to like for example when

00:03:35,920 --> 00:03:39,840
we share devices between the host and

00:03:37,920 --> 00:03:41,200
the container that are necessary for the

00:03:39,840 --> 00:03:43,280
container to work

00:03:41,200 --> 00:03:45,920
we usually find mount death null and

00:03:43,280 --> 00:03:46,959
dev0 into the container from the host

00:03:45,920 --> 00:03:50,319
staff so we

00:03:46,959 --> 00:03:52,319
bind mount um bind mount single files

00:03:50,319 --> 00:03:55,760
actually into the container

00:03:52,319 --> 00:03:57,599
and um bind mounts and

00:03:55,760 --> 00:03:59,439
the super block can have different

00:03:57,599 --> 00:04:01,519
properties exciting so

00:03:59,439 --> 00:04:03,200
a bind mount for example can be made

00:04:01,519 --> 00:04:05,360
read only

00:04:03,200 --> 00:04:07,360
while the super block is actually read

00:04:05,360 --> 00:04:08,319
right but the other way it doesn't work

00:04:07,360 --> 00:04:10,560
so

00:04:08,319 --> 00:04:11,840
if the super block is read only it will

00:04:10,560 --> 00:04:14,640
turn all

00:04:11,840 --> 00:04:16,320
bind mounts of the same super block read

00:04:14,640 --> 00:04:17,680
only

00:04:16,320 --> 00:04:19,680
because super block properties

00:04:17,680 --> 00:04:23,120
essentially if they are over

00:04:19,680 --> 00:04:24,960
writable um can't be if if

00:04:23,120 --> 00:04:26,320
the super block sets a specific property

00:04:24,960 --> 00:04:28,479
such as read only

00:04:26,320 --> 00:04:31,120
that can also be set for bind mount and

00:04:28,479 --> 00:04:34,720
usually the more restrictive property

00:04:31,120 --> 00:04:37,280
uh of the super block will uh override

00:04:34,720 --> 00:04:39,040
all of the bind mount properties which

00:04:37,280 --> 00:04:40,639
which is the same choice if you make a

00:04:39,040 --> 00:04:42,400
super block which represents

00:04:40,639 --> 00:04:44,479
exactly like a representation of the

00:04:42,400 --> 00:04:47,520
hard disk or usb device

00:04:44,479 --> 00:04:49,440
um for your for your operating system

00:04:47,520 --> 00:04:50,960
and you turn that read only you don't

00:04:49,440 --> 00:04:52,400
want it you basically want to

00:04:50,960 --> 00:04:54,320
turn all of the mounts where this is

00:04:52,400 --> 00:04:55,600
visible read only so this is quite

00:04:54,320 --> 00:04:59,280
consistent

00:04:55,600 --> 00:05:01,759
um and internally mounting is usually

00:04:59,280 --> 00:05:03,360
centered around a a struct that is

00:05:01,759 --> 00:05:05,360
called a vfs mount

00:05:03,360 --> 00:05:06,400
and that holds all of the necessary

00:05:05,360 --> 00:05:09,600
information

00:05:06,400 --> 00:05:11,759
associated with a mount including

00:05:09,600 --> 00:05:13,280
um various mount options such as mount

00:05:11,759 --> 00:05:17,039
flags read only

00:05:13,280 --> 00:05:21,520
no sued and and so on

00:05:17,039 --> 00:05:25,280
um yeah there's also amount name spaces

00:05:21,520 --> 00:05:27,360
which basically regulate what kind of

00:05:25,280 --> 00:05:29,039
uh you get your own private mound table

00:05:27,360 --> 00:05:30,960
this is what usually people associate

00:05:29,039 --> 00:05:31,680
with mountain name spaces so that mounts

00:05:30,960 --> 00:05:34,000
and human

00:05:31,680 --> 00:05:34,960
mounts in one mount namespace don't

00:05:34,000 --> 00:05:38,400
propagate

00:05:34,960 --> 00:05:40,000
so show up in another amount namespace

00:05:38,400 --> 00:05:42,000
and this is quite important for the

00:05:40,000 --> 00:05:43,919
container use case because obviously a

00:05:42,000 --> 00:05:45,840
container if you run

00:05:43,919 --> 00:05:48,240
another in a system in your container it

00:05:45,840 --> 00:05:51,280
might mount or unmount various files or

00:05:48,240 --> 00:05:53,280
various file systems temperfest or

00:05:51,280 --> 00:05:55,520
slash temp and you don't want it to

00:05:53,280 --> 00:05:57,039
affect the host

00:05:55,520 --> 00:05:58,720
this is what mountain name spaces are

00:05:57,039 --> 00:06:00,080
for and then you also have mount

00:05:58,720 --> 00:06:03,680
propagation which we'll

00:06:00,080 --> 00:06:06,160
not go into in any great detail

00:06:03,680 --> 00:06:08,400
today um and both of these things

00:06:06,160 --> 00:06:10,560
introduce quite a bit of complexity

00:06:08,400 --> 00:06:11,840
in into the kernel especially mount

00:06:10,560 --> 00:06:13,759
propagation

00:06:11,840 --> 00:06:15,840
um which is basically you can think of a

00:06:13,759 --> 00:06:17,280
bunch of tunnels between different mount

00:06:15,840 --> 00:06:20,479
name spaces this is all

00:06:17,280 --> 00:06:20,960
almost always how i envision it but this

00:06:20,479 --> 00:06:23,759
is

00:06:20,960 --> 00:06:25,680
out of scope in the sense of time for

00:06:23,759 --> 00:06:27,120
this for this talk but you can ask

00:06:25,680 --> 00:06:30,400
questions of course

00:06:27,120 --> 00:06:33,440
um after this session um

00:06:30,400 --> 00:06:36,000
so the old mount api

00:06:33,440 --> 00:06:37,280
well as you can see or as most people

00:06:36,000 --> 00:06:40,240
will probably know

00:06:37,280 --> 00:06:41,600
um the old mount api is a based on a

00:06:40,240 --> 00:06:44,080
single syscall i'm

00:06:41,600 --> 00:06:45,199
now ignoring the u-mount uh syscalls

00:06:44,080 --> 00:06:48,639
that exist to actually

00:06:45,199 --> 00:06:52,240
unmount an already uh file system

00:06:48,639 --> 00:06:54,960
um but it's it's not relevant

00:06:52,240 --> 00:06:56,479
we're just concerned with creating new

00:06:54,960 --> 00:07:00,800
mounts here

00:06:56,479 --> 00:07:03,360
for this talk um single syscall

00:07:00,800 --> 00:07:04,560
and it's used for a variety of

00:07:03,360 --> 00:07:07,520
operations so

00:07:04,560 --> 00:07:08,160
if you for example you can create a new

00:07:07,520 --> 00:07:10,240
super

00:07:08,160 --> 00:07:11,440
block trying to mount it for example a

00:07:10,240 --> 00:07:14,720
real disk device

00:07:11,440 --> 00:07:17,680
or a usb stick like i mentioned before

00:07:14,720 --> 00:07:19,919
um but it also can be used to create a

00:07:17,680 --> 00:07:22,400
bind mount of a directory file or

00:07:19,919 --> 00:07:25,840
another existing mount

00:07:22,400 --> 00:07:28,880
it can be used to remount a super block

00:07:25,840 --> 00:07:31,599
or so a whole file system or

00:07:28,880 --> 00:07:32,080
um amounts of changed amount options of

00:07:31,599 --> 00:07:35,360
the

00:07:32,080 --> 00:07:36,000
of a mount point um so this makes the

00:07:35,360 --> 00:07:39,120
mounts

00:07:36,000 --> 00:07:42,160
cisco the old mount syscall like

00:07:39,120 --> 00:07:43,520
it's actually just a multiplexer because

00:07:42,160 --> 00:07:45,919
they usually aren't a great idea

00:07:43,520 --> 00:07:47,680
multiplexes because it means that

00:07:45,919 --> 00:07:49,520
the syscall overloads different

00:07:47,680 --> 00:07:52,080
operations that would be

00:07:49,520 --> 00:07:53,840
better should better be represented in

00:07:52,080 --> 00:07:56,639
separate syscalls

00:07:53,840 --> 00:07:58,000
um but it is what it is and the the

00:07:56,639 --> 00:07:59,520
mount cisco has been around

00:07:58,000 --> 00:08:01,599
for a long time and people have lived

00:07:59,520 --> 00:08:03,199
with this for a long time but obviously

00:08:01,599 --> 00:08:05,520
this doesn't mean we can come up with

00:08:03,199 --> 00:08:06,639
something better in in the future if

00:08:05,520 --> 00:08:09,919
should we

00:08:06,639 --> 00:08:13,120
should we need to redesign the mount api

00:08:09,919 --> 00:08:16,000
and actually there were reasons for that

00:08:13,120 --> 00:08:16,800
um so the api can be quite a bit

00:08:16,000 --> 00:08:18,879
difficult

00:08:16,800 --> 00:08:20,080
to use it's full of quirks and legacy

00:08:18,879 --> 00:08:23,759
behavior that's just

00:08:20,080 --> 00:08:27,280
how what happens uh over time um

00:08:23,759 --> 00:08:30,479
one thing i want to point out as a quirk

00:08:27,280 --> 00:08:31,280
is making a read-only amount of an

00:08:30,479 --> 00:08:33,680
existing

00:08:31,280 --> 00:08:36,640
existing file system existing a bind

00:08:33,680 --> 00:08:39,519
mount so a directory or so on

00:08:36,640 --> 00:08:40,000
is quite cumbersome you cannot do it uh

00:08:39,519 --> 00:08:42,399
in one

00:08:40,000 --> 00:08:44,320
step so if you see right here i'm not

00:08:42,399 --> 00:08:45,920
sure if you can see my mouse but we're

00:08:44,320 --> 00:08:48,320
on the first dash

00:08:45,920 --> 00:08:50,080
um create a new file system for an

00:08:48,320 --> 00:08:52,480
export file system that is not a problem

00:08:50,080 --> 00:08:55,680
okay we got this here you create a new

00:08:52,480 --> 00:08:57,519
x4 mount for dev sda at the location

00:08:55,680 --> 00:08:59,760
mount with

00:08:57,519 --> 00:09:01,200
the no suite flag but below here we

00:08:59,760 --> 00:09:04,480
create a new bind mount right

00:09:01,200 --> 00:09:07,120
uh for if we mount slash temp to

00:09:04,480 --> 00:09:08,480
a slash mount to slash 10 um and create

00:09:07,120 --> 00:09:10,640
a bind mount

00:09:08,480 --> 00:09:12,320
if we were to specify emma's read only

00:09:10,640 --> 00:09:13,440
and we wanted let's assume we wanted to

00:09:12,320 --> 00:09:16,720
make this read only

00:09:13,440 --> 00:09:18,800
it it's no of no use to specify ms bind

00:09:16,720 --> 00:09:20,240
in conjunction with ms read only you

00:09:18,800 --> 00:09:23,680
would still end up with

00:09:20,240 --> 00:09:26,880
a read write mount point which is super

00:09:23,680 --> 00:09:29,120
uh unintuitive right so um

00:09:26,880 --> 00:09:30,800
and actually to make sure that the mount

00:09:29,120 --> 00:09:34,640
is read only

00:09:30,800 --> 00:09:36,560
um you then need to make sure

00:09:34,640 --> 00:09:39,360
you then need to remount you need to

00:09:36,560 --> 00:09:41,120
specify ms mind ms reed mount ms3 only

00:09:39,360 --> 00:09:43,920
on the same mount point and then you end

00:09:41,120 --> 00:09:46,160
up with a read only bind mount

00:09:43,920 --> 00:09:47,120
there is a weirder quirk where you when

00:09:46,160 --> 00:09:50,240
you specify

00:09:47,120 --> 00:09:50,959
ms bind with together with ms rec which

00:09:50,240 --> 00:09:54,640
means

00:09:50,959 --> 00:09:55,600
um make me a a recursive mind mount

00:09:54,640 --> 00:09:57,519
copying the whole

00:09:55,600 --> 00:10:00,320
mount tree at the location that i

00:09:57,519 --> 00:10:02,640
specified and you specify the ms read

00:10:00,320 --> 00:10:04,000
only flag for that only the uppermost

00:10:02,640 --> 00:10:07,760
mount will be turned read

00:10:04,000 --> 00:10:10,240
only all of the other all of the other

00:10:07,760 --> 00:10:11,440
amounts will not be turned uh read only

00:10:10,240 --> 00:10:14,560
so in

00:10:11,440 --> 00:10:16,240
in my example what i actually did um

00:10:14,560 --> 00:10:18,000
right here and i'm sorry for that dish

00:10:16,240 --> 00:10:21,360
the first example should have read ms

00:10:18,000 --> 00:10:23,040
bind ms rec um so

00:10:21,360 --> 00:10:24,880
the fact that you only turn the

00:10:23,040 --> 00:10:27,120
uppermost mount of your mount tree that

00:10:24,880 --> 00:10:30,720
you cloned read only and not the whole

00:10:27,120 --> 00:10:33,839
every mount under that under the mount

00:10:30,720 --> 00:10:34,959
is quite a problem and has led to cves

00:10:33,839 --> 00:10:37,200
in user space

00:10:34,959 --> 00:10:38,560
but there is no nice way to fix this

00:10:37,200 --> 00:10:42,000
because

00:10:38,560 --> 00:10:45,040
changing that behavior would break um

00:10:42,000 --> 00:10:46,079
user space so the only option to fix

00:10:45,040 --> 00:10:48,480
this would be to introduce

00:10:46,079 --> 00:10:50,160
a new flag for example ms recreate only

00:10:48,480 --> 00:10:51,760
but then you end up with a flag that

00:10:50,160 --> 00:10:53,519
combines two different

00:10:51,760 --> 00:10:55,120
semantical things right it combines

00:10:53,519 --> 00:10:57,760
making read only with

00:10:55,120 --> 00:10:58,959
the recursive property and it's just

00:10:57,760 --> 00:11:00,640
weird so

00:10:58,959 --> 00:11:02,240
for example this is one obvious

00:11:00,640 --> 00:11:04,560
limitation of the

00:11:02,240 --> 00:11:06,079
old mount api and then you're also

00:11:04,560 --> 00:11:07,360
getting into the territory where you're

00:11:06,079 --> 00:11:10,640
slowly running out of

00:11:07,360 --> 00:11:12,720
flags i think um

00:11:10,640 --> 00:11:14,800
also the api as you might have noticed

00:11:12,720 --> 00:11:18,079
based on the arguments is purely

00:11:14,800 --> 00:11:18,880
path-based so source and target need to

00:11:18,079 --> 00:11:20,480
be

00:11:18,880 --> 00:11:22,000
absolute well they don't need to have

00:11:20,480 --> 00:11:25,760
absolute paths but

00:11:22,000 --> 00:11:27,360
um they they need to be path-based

00:11:25,760 --> 00:11:29,839
it's not file descriptor based which is

00:11:27,360 --> 00:11:31,760
problematic if you want to do delegated

00:11:29,839 --> 00:11:33,680
mounting or

00:11:31,760 --> 00:11:36,079
for example share a file descriptor with

00:11:33,680 --> 00:11:38,399
another task that all that won't work

00:11:36,079 --> 00:11:39,519
and in the new mount api that will

00:11:38,399 --> 00:11:41,279
actually work

00:11:39,519 --> 00:11:43,040
so you see there is a lot of room for

00:11:41,279 --> 00:11:45,680
improvement but as i said the

00:11:43,040 --> 00:11:47,120
mount syscall has served us well for a

00:11:45,680 --> 00:11:49,120
long time no reason

00:11:47,120 --> 00:11:50,240
to force everyone to use the new mount

00:11:49,120 --> 00:11:52,320
api but

00:11:50,240 --> 00:11:53,839
um maybe i can convince some people that

00:11:52,320 --> 00:11:57,760
it's actually worth it

00:11:53,839 --> 00:11:59,839
uh so let's switch to the new mount api

00:11:57,760 --> 00:12:02,160
well the obvious cool thing is that it's

00:11:59,839 --> 00:12:04,320
uh instead of being path-based

00:12:02,160 --> 00:12:06,639
uh something i just critiqued seconds

00:12:04,320 --> 00:12:09,040
earlier the new mount api is

00:12:06,639 --> 00:12:11,839
file descriptor based in fact you can

00:12:09,040 --> 00:12:13,360
use the new mount api without using any

00:12:11,839 --> 00:12:17,200
paths at all which is

00:12:13,360 --> 00:12:19,600
obviously always excellent for security

00:12:17,200 --> 00:12:21,519
um and instead of having a single

00:12:19,600 --> 00:12:22,320
syscall to do all of the things at the

00:12:21,519 --> 00:12:24,880
same time

00:12:22,320 --> 00:12:26,639
the new mount api splits a split into

00:12:24,880 --> 00:12:29,279
multiple sys calls

00:12:26,639 --> 00:12:29,680
and so it splits super clock creation

00:12:29,279 --> 00:12:32,480
and

00:12:29,680 --> 00:12:34,079
a superfluo and modification from bind

00:12:32,480 --> 00:12:36,720
mount creation

00:12:34,079 --> 00:12:38,000
and and making a mount visible in the

00:12:36,720 --> 00:12:39,920
file system is also

00:12:38,000 --> 00:12:42,000
a separate operation which is great

00:12:39,920 --> 00:12:45,440
because now you can have what is called

00:12:42,000 --> 00:12:46,079
anonymous or detached mounts and since

00:12:45,440 --> 00:12:48,079
it's

00:12:46,079 --> 00:12:50,079
fd based this means it's possible to

00:12:48,079 --> 00:12:51,120
create a detached mount of a directory

00:12:50,079 --> 00:12:54,160
for example

00:12:51,120 --> 00:12:57,680
uh or an existing uh yeah of a

00:12:54,160 --> 00:12:58,560
of a directory um and then uh not really

00:12:57,680 --> 00:12:59,920
mount this

00:12:58,560 --> 00:13:01,680
file system so there is no

00:12:59,920 --> 00:13:02,560
representation for this mount that you

00:13:01,680 --> 00:13:04,839
just created

00:13:02,560 --> 00:13:06,000
in the file system it's not reachable by

00:13:04,839 --> 00:13:08,880
traversing

00:13:06,000 --> 00:13:10,399
via the terminal for example that's not

00:13:08,880 --> 00:13:12,160
possible

00:13:10,399 --> 00:13:14,720
so you can have private mounts per

00:13:12,160 --> 00:13:17,680
process and the process can still

00:13:14,720 --> 00:13:19,920
use dfd to traverse the new file system

00:13:17,680 --> 00:13:21,120
to mount and open and create files and

00:13:19,920 --> 00:13:24,160
so on

00:13:21,120 --> 00:13:25,279
so that's a nice property that the new

00:13:24,160 --> 00:13:28,560
amount api

00:13:25,279 --> 00:13:30,399
supports um

00:13:28,560 --> 00:13:32,560
so let's look at the individual the

00:13:30,399 --> 00:13:35,760
individual syscalls that

00:13:32,560 --> 00:13:38,399
comprise this new mount api um

00:13:35,760 --> 00:13:40,720
there will likely be another system call

00:13:38,399 --> 00:13:44,160
in the future

00:13:40,720 --> 00:13:47,279
um because it's not fully

00:13:44,160 --> 00:13:49,199
it's not fully complete to some extent

00:13:47,279 --> 00:13:51,680
so this fs open syscall creates a new

00:13:49,199 --> 00:13:52,720
file system context and the file system

00:13:51,680 --> 00:13:55,199
context is

00:13:52,720 --> 00:13:57,120
basically just in kernel state if you

00:13:55,199 --> 00:13:59,920
want to think of it like this

00:13:57,120 --> 00:14:00,720
um and this file system context can then

00:13:59,920 --> 00:14:03,360
be used

00:14:00,720 --> 00:14:05,760
uh later on oops later on to be

00:14:03,360 --> 00:14:10,320
configured

00:14:05,760 --> 00:14:10,320
with an additional

00:14:11,120 --> 00:14:14,959
with additional syscalls um we can

00:14:14,399 --> 00:14:18,160
actually

00:14:14,959 --> 00:14:19,760
um let's see uh

00:14:18,160 --> 00:14:21,279
let's look a bit at source code while

00:14:19,760 --> 00:14:23,680
we're doing this this is actually

00:14:21,279 --> 00:14:24,800
something i want to do so i'm stopped to

00:14:23,680 --> 00:14:27,360
share this now

00:14:24,800 --> 00:14:28,560
and i'm going to present and share

00:14:27,360 --> 00:14:30,800
another window with you

00:14:28,560 --> 00:14:32,480
where we are in the terminal and i hope

00:14:30,800 --> 00:14:36,880
i made this big enough

00:14:32,480 --> 00:14:36,880
so um

00:14:37,760 --> 00:14:43,360
let's look at fs fs open

00:14:41,120 --> 00:14:44,800
this is where the fs opens this call for

00:14:43,360 --> 00:14:47,600
example lives

00:14:44,800 --> 00:14:49,360
um so this is where you create a new

00:14:47,600 --> 00:14:50,079
file system context in the kernel we

00:14:49,360 --> 00:14:53,199
won't get into

00:14:50,079 --> 00:14:54,320
into too many details um and you need to

00:14:53,199 --> 00:14:58,560
be

00:14:54,320 --> 00:15:00,320
inescapable with the uh with respect to

00:14:58,560 --> 00:15:02,720
the owning user namespace of

00:15:00,320 --> 00:15:04,480
uh your current uh mount namespace that

00:15:02,720 --> 00:15:05,600
means you need to have the capsis admin

00:15:04,480 --> 00:15:08,560
capability

00:15:05,600 --> 00:15:10,639
in the amount namespace um in the

00:15:08,560 --> 00:15:14,079
username space of the mod namespace

00:15:10,639 --> 00:15:16,320
um this is a restriction it supports the

00:15:14,079 --> 00:15:16,880
episode called exec plug which turns a

00:15:16,320 --> 00:15:19,279
file

00:15:16,880 --> 00:15:20,079
which turns the file descriptor it

00:15:19,279 --> 00:15:23,120
returns

00:15:20,079 --> 00:15:27,279
in close on exec which is always a

00:15:23,120 --> 00:15:29,680
great advice to use that by default

00:15:27,279 --> 00:15:31,680
um and it returns a file descriptor for

00:15:29,680 --> 00:15:33,199
the file system context it just created

00:15:31,680 --> 00:15:35,040
so let's say you wanted to create an

00:15:33,199 --> 00:15:36,639
export file system you would call fs

00:15:35,040 --> 00:15:41,600
open for example

00:15:36,639 --> 00:15:44,000
um x4 and then fs open

00:15:41,600 --> 00:15:45,199
closex this would be a system called to

00:15:44,000 --> 00:15:47,199
create a new file system

00:15:45,199 --> 00:15:48,639
context that file system context just

00:15:47,199 --> 00:15:51,680
has no

00:15:48,639 --> 00:15:53,360
meaning so it's not a mount you can't do

00:15:51,680 --> 00:15:54,560
anything with this it's basically just a

00:15:53,360 --> 00:15:57,839
representation for

00:15:54,560 --> 00:16:01,519
in kernel state for the in kernel fs um

00:15:57,839 --> 00:16:03,519
context right um

00:16:01,519 --> 00:16:05,199
so this is what this uh what this system

00:16:03,519 --> 00:16:08,079
called uh this essentially

00:16:05,199 --> 00:16:08,480
is all about it gives you a handle on in

00:16:08,079 --> 00:16:12,000
a

00:16:08,480 --> 00:16:12,000
in kernel state

00:16:12,160 --> 00:16:19,360
let's switch back to the presentation

00:16:16,000 --> 00:16:22,639
and whoops

00:16:19,360 --> 00:16:27,040
here so

00:16:22,639 --> 00:16:30,240
um this

00:16:27,040 --> 00:16:31,199
uh um this app is open context uh is an

00:16:30,240 --> 00:16:32,880
anonymous file

00:16:31,199 --> 00:16:34,560
anonymous inode file descriptor most

00:16:32,880 --> 00:16:36,000
file descriptors in the mount api that

00:16:34,560 --> 00:16:38,000
do not represent actual

00:16:36,000 --> 00:16:40,399
file system objects so files or

00:16:38,000 --> 00:16:43,199
directories in the file system

00:16:40,399 --> 00:16:44,880
um and anonymous i know it's basically

00:16:43,199 --> 00:16:46,560
are a bunch of file descriptors that all

00:16:44,880 --> 00:16:48,399
share the same inode

00:16:46,560 --> 00:16:50,320
because they don't need a full i know

00:16:48,399 --> 00:16:52,639
they just represent

00:16:50,320 --> 00:16:55,040
think of it as representing some form of

00:16:52,639 --> 00:16:56,959
internal state or an internal object in

00:16:55,040 --> 00:17:00,000
our case it's a context

00:16:56,959 --> 00:17:01,759
um that that is kept track of so the

00:17:00,000 --> 00:17:03,199
kernel now is a context for an export

00:17:01,759 --> 00:17:05,439
file system

00:17:03,199 --> 00:17:07,280
and is waiting for you to do something

00:17:05,439 --> 00:17:10,640
with it essentially

00:17:07,280 --> 00:17:13,520
um closely related to the fs open

00:17:10,640 --> 00:17:14,319
system call is the fs pick system call

00:17:13,520 --> 00:17:17,439
um

00:17:14,319 --> 00:17:19,360
which lets you create

00:17:17,439 --> 00:17:20,880
a file descriptor for an already

00:17:19,360 --> 00:17:24,559
existing super block

00:17:20,880 --> 00:17:28,400
so this must be um this must be

00:17:24,559 --> 00:17:28,960
a uh yeah an fs context that has that

00:17:28,400 --> 00:17:30,880
already

00:17:28,960 --> 00:17:32,640
existed essentially it gives you a new

00:17:30,880 --> 00:17:34,400
fd for it um

00:17:32,640 --> 00:17:36,080
it follows the opennet pattern of

00:17:34,400 --> 00:17:37,760
opening a path so meaning you have a

00:17:36,080 --> 00:17:38,160
directory file descriptor this is the

00:17:37,760 --> 00:17:42,080
first

00:17:38,160 --> 00:17:44,559
argument or um a path argument and

00:17:42,080 --> 00:17:46,080
they can be they interpret interpreted

00:17:44,559 --> 00:17:48,240
in relation to each other so if the file

00:17:46,080 --> 00:17:50,880
descriptor refers to a directory and you

00:17:48,240 --> 00:17:52,080
specify a non-absolute path then this

00:17:50,880 --> 00:17:53,919
path will be resolved

00:17:52,080 --> 00:17:55,280
relative to the directory that the file

00:17:53,919 --> 00:17:56,880
descriptor specifies

00:17:55,280 --> 00:17:58,880
if it's an absolute path the file

00:17:56,880 --> 00:18:02,320
descriptor that is ignored

00:17:58,880 --> 00:18:06,960
and if the special at fdcvd

00:18:02,320 --> 00:18:09,600
cwd um value is passed for a

00:18:06,960 --> 00:18:12,080
directory file descriptor then the path

00:18:09,600 --> 00:18:14,960
is taken to be relative to the current

00:18:12,080 --> 00:18:15,440
working directory of the calling process

00:18:14,960 --> 00:18:18,640
and

00:18:15,440 --> 00:18:20,240
fsp also supports a range of flags so

00:18:18,640 --> 00:18:21,760
it also allows you to make the file

00:18:20,240 --> 00:18:24,880
descriptor read own uh

00:18:21,760 --> 00:18:27,919
the file descriptor close on exec um

00:18:24,880 --> 00:18:28,960
it allows you to specify that you don't

00:18:27,919 --> 00:18:32,480
want

00:18:28,960 --> 00:18:34,000
you don't want uh trading symlinks to be

00:18:32,480 --> 00:18:36,880
followed

00:18:34,000 --> 00:18:38,640
and no automotive allows you to specify

00:18:36,880 --> 00:18:40,240
that you don't want to trigger auto

00:18:38,640 --> 00:18:41,919
mounts during path lookup because

00:18:40,240 --> 00:18:43,840
usually the default is if you look up

00:18:41,919 --> 00:18:47,280
paths then auto amounts will be

00:18:43,840 --> 00:18:48,640
will be triggered and fs pick empty path

00:18:47,280 --> 00:18:51,360
specifies that

00:18:48,640 --> 00:18:53,360
the operation for this uh to create a

00:18:51,360 --> 00:18:55,039
new context for an exist at this context

00:18:53,360 --> 00:18:58,240
for an existing super block

00:18:55,039 --> 00:18:59,520
uh will be performed directly on the

00:18:58,240 --> 00:19:01,679
directory file descriptor so the

00:18:59,520 --> 00:19:04,880
directory file descriptor must

00:19:01,679 --> 00:19:07,840
refer to uh the mount root of a

00:19:04,880 --> 00:19:08,799
file system so the root mount of a file

00:19:07,840 --> 00:19:10,720
system

00:19:08,799 --> 00:19:12,160
and both file descriptors give you an fs

00:19:10,720 --> 00:19:15,200
context file descriptor

00:19:12,160 --> 00:19:19,520
uh for uh in kernel state

00:19:15,200 --> 00:19:20,720
uh back and okay now you have this fd

00:19:19,520 --> 00:19:24,799
that's great

00:19:20,720 --> 00:19:28,400
um this file descriptor can now be used

00:19:24,799 --> 00:19:32,160
to configure the

00:19:28,400 --> 00:19:34,799
fs context that it refers to so

00:19:32,160 --> 00:19:36,160
fs config allows you to configure set

00:19:34,799 --> 00:19:39,200
file system

00:19:36,160 --> 00:19:40,000
very specific file system uh file system

00:19:39,200 --> 00:19:42,160
options

00:19:40,000 --> 00:19:44,480
and you see you have the fsfd argument

00:19:42,160 --> 00:19:47,360
which takes the file descriptor that

00:19:44,480 --> 00:19:47,840
the fs open and fspx system calls give

00:19:47,360 --> 00:19:49,840
you

00:19:47,840 --> 00:19:51,200
and the unsigned in command so the

00:19:49,840 --> 00:19:53,280
second argument

00:19:51,200 --> 00:19:54,720
takes a bunch of the flags you see here

00:19:53,280 --> 00:19:57,679
on the screen

00:19:54,720 --> 00:19:58,480
and then based on this on the flag uh

00:19:57,679 --> 00:20:01,440
you're under

00:19:58,480 --> 00:20:02,320
sorry on the command you're passing uh

00:20:01,440 --> 00:20:05,679
the key

00:20:02,320 --> 00:20:08,320
value and aux arguments are

00:20:05,679 --> 00:20:09,200
are used and which ones i use depends on

00:20:08,320 --> 00:20:11,440
the command so

00:20:09,200 --> 00:20:12,320
for example if you want to set a flag on

00:20:11,440 --> 00:20:15,679
the fx

00:20:12,320 --> 00:20:18,400
fs context object in the kernel

00:20:15,679 --> 00:20:20,480
um then you pass the value through the

00:20:18,400 --> 00:20:22,559
key argument

00:20:20,480 --> 00:20:24,080
so you specify f is config set flag in

00:20:22,559 --> 00:20:26,080
the command argument and then

00:20:24,080 --> 00:20:27,360
specify the argument the actual value

00:20:26,080 --> 00:20:28,640
that you want to pass in the key

00:20:27,360 --> 00:20:30,720
argument

00:20:28,640 --> 00:20:33,039
you can set a string pyramid parameter

00:20:30,720 --> 00:20:36,159
so for example the source of a mount

00:20:33,039 --> 00:20:39,760
via the fs config set um

00:20:36,159 --> 00:20:41,919
set string argument um and

00:20:39,760 --> 00:20:44,320
so the for example if you want to set

00:20:41,919 --> 00:20:46,000
the source then you specify source in

00:20:44,320 --> 00:20:46,720
the key argument and you then you

00:20:46,000 --> 00:20:49,039
specify

00:20:46,720 --> 00:20:50,000
the path in the value argument the

00:20:49,039 --> 00:20:52,559
binary

00:20:50,000 --> 00:20:53,840
command lets you set binary arguments

00:20:52,559 --> 00:20:57,039
through the aux

00:20:53,840 --> 00:21:00,240
argument and dfsconfig setpath

00:20:57,039 --> 00:21:02,400
argument and dfsconfig setpath

00:21:00,240 --> 00:21:03,600
empty arguments uh basically what you

00:21:02,400 --> 00:21:05,679
would expect from

00:21:03,600 --> 00:21:07,600
so give you open at semantics even with

00:21:05,679 --> 00:21:10,320
this is called so if you

00:21:07,600 --> 00:21:11,679
specify path then you can pass a df df

00:21:10,320 --> 00:21:12,640
file descriptor through the house

00:21:11,679 --> 00:21:14,960
argument

00:21:12,640 --> 00:21:15,760
um and the value argument will be

00:21:14,960 --> 00:21:19,919
interpreted

00:21:15,760 --> 00:21:23,600
as a path or the key argument

00:21:19,919 --> 00:21:26,799
um and if you specify a

00:21:23,600 --> 00:21:29,440
empty set fdmt path

00:21:26,799 --> 00:21:30,480
empty then the aux argument will be used

00:21:29,440 --> 00:21:32,000
to be directly

00:21:30,480 --> 00:21:34,480
the path will be directly looked at

00:21:32,000 --> 00:21:36,799
based on the aux argument

00:21:34,480 --> 00:21:37,600
um and the last ones are the more for

00:21:36,799 --> 00:21:39,120
our uh

00:21:37,600 --> 00:21:40,960
talk today are the really interesting

00:21:39,120 --> 00:21:44,320
ones namely fs

00:21:40,960 --> 00:21:48,320
config command create and fps config

00:21:44,320 --> 00:21:48,799
configure reconfigure fs config command

00:21:48,320 --> 00:21:52,400
create

00:21:48,799 --> 00:21:55,760
finishes finalizes the creation of a fs

00:21:52,400 --> 00:21:57,440
fs context so after this you cannot

00:21:55,760 --> 00:21:59,520
reconfigure you cannot configure it

00:21:57,440 --> 00:22:02,000
anymore with the fsconfig system call

00:21:59,520 --> 00:22:05,760
and the super block is actually created

00:22:02,000 --> 00:22:07,520
um in the kernel and this requires the

00:22:05,760 --> 00:22:09,200
caller ida to be capsis admin in the

00:22:07,520 --> 00:22:11,039
current username space if the file

00:22:09,200 --> 00:22:12,400
system is mountable inside of username

00:22:11,039 --> 00:22:14,880
spaces for example

00:22:12,400 --> 00:22:16,880
proc or to be captures admin in the

00:22:14,880 --> 00:22:20,080
initial username space if it is not

00:22:16,880 --> 00:22:23,919
mountable inside user namespaces

00:22:20,080 --> 00:22:24,559
and the fsconfig command reconfigure

00:22:23,919 --> 00:22:27,159
argument

00:22:24,559 --> 00:22:28,640
actually reconfigures uh finalizes the

00:22:27,159 --> 00:22:30,880
reconfiguration

00:22:28,640 --> 00:22:32,720
of uh of a super block so a file

00:22:30,880 --> 00:22:33,679
descriptor context that you've gotten

00:22:32,720 --> 00:22:36,480
via the

00:22:33,679 --> 00:22:37,360
fs pick system call we talked about uh

00:22:36,480 --> 00:22:40,400
we talked about

00:22:37,360 --> 00:22:43,919
um before so this is fs open

00:22:40,400 --> 00:22:46,320
fs config and fsp are concerned with

00:22:43,919 --> 00:22:49,200
uh creating super blocks for file

00:22:46,320 --> 00:22:51,840
systems essentially

00:22:49,200 --> 00:22:53,520
and finally fs mount system call this is

00:22:51,840 --> 00:22:54,080
what we have been waiting for because

00:22:53,520 --> 00:22:57,280
this is the

00:22:54,080 --> 00:22:59,600
point where we turn an

00:22:57,280 --> 00:23:02,400
fs context file descriptor into an

00:22:59,600 --> 00:23:05,200
actual mount so in order to get here

00:23:02,400 --> 00:23:06,159
we need to have called fsmount or

00:23:05,200 --> 00:23:09,360
fsmount

00:23:06,159 --> 00:23:11,200
and fsconfig and we must have called fs

00:23:09,360 --> 00:23:13,120
config command create these are the

00:23:11,200 --> 00:23:17,039
three steps you will see this later on

00:23:13,120 --> 00:23:18,720
in the demo um and

00:23:17,039 --> 00:23:20,480
because then you have basically said i'm

00:23:18,720 --> 00:23:22,080
done configuring this file system

00:23:20,480 --> 00:23:25,520
context i now am ready

00:23:22,080 --> 00:23:26,960
to turn this into a usable into a usable

00:23:25,520 --> 00:23:28,880
mount file descriptor

00:23:26,960 --> 00:23:30,559
so you pass in the fs context file

00:23:28,880 --> 00:23:32,240
descriptor you received and then you can

00:23:30,559 --> 00:23:34,559
specify in the flags argument

00:23:32,240 --> 00:23:36,480
fs mount exec again so that the file

00:23:34,559 --> 00:23:38,960
descriptor that you get from fs mount

00:23:36,480 --> 00:23:42,080
will be close on exact by default

00:23:38,960 --> 00:23:42,400
and then in the ms flex argument you can

00:23:42,080 --> 00:23:44,480
set

00:23:42,400 --> 00:23:46,000
properties on the mount that you are now

00:23:44,480 --> 00:23:47,840
creating so for example you can turn the

00:23:46,000 --> 00:23:49,039
mount read only as you see here mount

00:23:47,840 --> 00:23:51,919
adder read only

00:23:49,039 --> 00:23:54,320
no c suits or no set uid binaries on

00:23:51,919 --> 00:23:56,400
this mount no devices on this mount

00:23:54,320 --> 00:23:58,320
uh no execution of binaries on this

00:23:56,400 --> 00:24:01,600
mount and then you can also set

00:23:58,320 --> 00:24:02,480
um what time options what access time

00:24:01,600 --> 00:24:04,799
options

00:24:02,480 --> 00:24:06,400
you want and then fs mount gives you a

00:24:04,799 --> 00:24:09,600
file descriptor back

00:24:06,400 --> 00:24:10,640
and let's take the time to quickly look

00:24:09,600 --> 00:24:12,400
at the system call

00:24:10,640 --> 00:24:15,120
in the source code as well the other

00:24:12,400 --> 00:24:18,240
ones are interesting as well but

00:24:15,120 --> 00:24:19,760
this would take way too much time if you

00:24:18,240 --> 00:24:23,200
were to do this

00:24:19,760 --> 00:24:23,200
so you should have hopefully

00:24:23,360 --> 00:24:30,480
um have seen this give me a second and

00:24:26,559 --> 00:24:32,400
fs mount uh we need to switch to a file

00:24:30,480 --> 00:24:36,640
called namespace.c

00:24:32,400 --> 00:24:39,200
dismount oops

00:24:36,640 --> 00:24:39,200
sorry

00:24:44,159 --> 00:24:48,240
there we are so this is the syscall fs

00:24:47,039 --> 00:24:50,880
mount syscall

00:24:48,240 --> 00:24:51,919
it's the same uh restriction may mount

00:24:50,880 --> 00:24:55,200
uh what it does

00:24:51,919 --> 00:24:57,760
it checks that you are the uh

00:24:55,200 --> 00:24:59,360
capsus admin in the username space of

00:24:57,760 --> 00:25:00,080
your current account namespace that's

00:24:59,360 --> 00:25:01,760
all it does

00:25:00,080 --> 00:25:03,279
then it checks that all of the flags are

00:25:01,760 --> 00:25:05,360
valid and so on

00:25:03,279 --> 00:25:06,559
and only valid flags are passed and here

00:25:05,360 --> 00:25:08,960
you see

00:25:06,559 --> 00:25:11,360
um here the magic essentially happens it

00:25:08,960 --> 00:25:14,240
takes this fs context file descriptor

00:25:11,360 --> 00:25:16,080
and it verifies that it's actually an fs

00:25:14,240 --> 00:25:16,559
context file descriptor you see it right

00:25:16,080 --> 00:25:19,520
here

00:25:16,559 --> 00:25:22,559
this is fs context uh fobs so it

00:25:19,520 --> 00:25:25,919
verifies that the file operations that

00:25:22,559 --> 00:25:28,000
belong to this file are actually of fs

00:25:25,919 --> 00:25:30,480
contact of the fs context type

00:25:28,000 --> 00:25:32,400
so any other file descriptors will be

00:25:30,480 --> 00:25:35,200
rejected

00:25:32,400 --> 00:25:36,080
and then it will verify that you're on

00:25:35,200 --> 00:25:39,919
the correct phase

00:25:36,080 --> 00:25:42,720
so that essentially you

00:25:39,919 --> 00:25:44,340
that you have finished the fs config dfs

00:25:42,720 --> 00:25:45,679
config call

00:25:44,340 --> 00:25:48,720
[Music]

00:25:45,679 --> 00:25:52,240
and then

00:25:48,720 --> 00:25:56,080
it creates a new mount vfs

00:25:52,240 --> 00:25:58,559
it creates a new mount and uh

00:25:56,080 --> 00:25:59,600
it allocates a new amount namespace see

00:25:58,559 --> 00:26:02,720
it right here

00:25:59,600 --> 00:26:05,919
sets this all up it opens

00:26:02,720 --> 00:26:09,279
the path

00:26:05,919 --> 00:26:10,799
for this new mount and then it allocates

00:26:09,279 --> 00:26:13,360
in your file descriptor

00:26:10,799 --> 00:26:14,640
and it returns it to you so this whole

00:26:13,360 --> 00:26:18,240
system call actually

00:26:14,640 --> 00:26:20,320
turns the fsfd of fs context by

00:26:18,240 --> 00:26:22,400
descriptor into an actual amount so from

00:26:20,320 --> 00:26:24,000
this point on

00:26:22,400 --> 00:26:25,760
uh you can do something with this you

00:26:24,000 --> 00:26:26,559
can open files and so on with this so

00:26:25,760 --> 00:26:28,880
this is

00:26:26,559 --> 00:26:32,240
uh and this is a point to stress let me

00:26:28,880 --> 00:26:36,880
switch back to the slides real quick

00:26:32,240 --> 00:26:36,880
up and there we go

00:26:37,440 --> 00:26:40,799
uh this is important to notice after

00:26:40,159 --> 00:26:43,520
this

00:26:40,799 --> 00:26:44,080
system call returns your file descriptor

00:26:43,520 --> 00:26:46,880
um

00:26:44,080 --> 00:26:47,679
you can interact with the file system

00:26:46,880 --> 00:26:50,000
that you just

00:26:47,679 --> 00:26:51,840
mounted so you can open files in there

00:26:50,000 --> 00:26:53,440
by passing this to the open ad system

00:26:51,840 --> 00:26:56,080
call and then passing

00:26:53,440 --> 00:26:57,600
paths alongside it you can create new

00:26:56,080 --> 00:26:59,520
files in there you can actually operate

00:26:57,600 --> 00:27:01,919
on this thing without it having any

00:26:59,520 --> 00:27:04,480
representation in the file system

00:27:01,919 --> 00:27:06,880
um which is great something which you

00:27:04,480 --> 00:27:08,400
could easily do with the old mount api

00:27:06,880 --> 00:27:09,200
with the old mount api you would have to

00:27:08,400 --> 00:27:11,200
mount it

00:27:09,200 --> 00:27:12,880
get a file descriptor for it and then

00:27:11,200 --> 00:27:14,240
unmount it

00:27:12,880 --> 00:27:15,840
and then you get sort of the similar

00:27:14,240 --> 00:27:17,679
thing but you still have to have it

00:27:15,840 --> 00:27:19,200
visible at some point in the file system

00:27:17,679 --> 00:27:20,399
with the old mount api with the new

00:27:19,200 --> 00:27:22,159
mount api

00:27:20,399 --> 00:27:23,679
if you called fs mount there is no

00:27:22,159 --> 00:27:28,720
representation of the thing

00:27:23,679 --> 00:27:28,720
actually in in the file system yet

00:27:28,799 --> 00:27:32,320
a very cool system call which i want to

00:27:31,279 --> 00:27:35,120
go to and

00:27:32,320 --> 00:27:36,880
go touch on briefly is the opentree

00:27:35,120 --> 00:27:38,880
system call which is

00:27:36,880 --> 00:27:39,919
the system call with which you create

00:27:38,880 --> 00:27:42,159
actual

00:27:39,919 --> 00:27:43,279
bind mount something which i said was

00:27:42,159 --> 00:27:46,080
muddled together with

00:27:43,279 --> 00:27:49,120
creating a new super block for a file

00:27:46,080 --> 00:27:52,880
system in the old mount api

00:27:49,120 --> 00:27:55,600
it's the same thing as with fs pick

00:27:52,880 --> 00:27:57,360
you can pass a file descriptor argument

00:27:55,600 --> 00:27:57,919
that can refer to a directory and then

00:27:57,360 --> 00:28:00,960
you can

00:27:57,919 --> 00:28:02,559
also pass a path alongside it if it's a

00:28:00,960 --> 00:28:04,159
relative path it will be resolved

00:28:02,559 --> 00:28:05,440
relative to the dear file descriptor

00:28:04,159 --> 00:28:08,960
that you passed in

00:28:05,440 --> 00:28:12,559
um and if you specify for example

00:28:08,960 --> 00:28:14,080
if you specify um

00:28:12,559 --> 00:28:16,000
at empty path then you can operate

00:28:14,080 --> 00:28:18,799
directly on the directory

00:28:16,000 --> 00:28:20,640
under directory file descriptor um it

00:28:18,799 --> 00:28:22,480
takes a couple of flags open tree chloe

00:28:20,640 --> 00:28:24,159
exec which obviously just turns the file

00:28:22,480 --> 00:28:24,799
descriptor that is returned from open

00:28:24,159 --> 00:28:28,320
tree

00:28:24,799 --> 00:28:30,399
into a close on exact file descriptor

00:28:28,320 --> 00:28:33,760
if you don't specify opentree clone you

00:28:30,399 --> 00:28:36,960
get a file descriptor for an existing

00:28:33,760 --> 00:28:38,080
for an existing uh and it's it it is an

00:28:36,960 --> 00:28:41,440
existing mount

00:28:38,080 --> 00:28:44,960
then it not no copy is created

00:28:41,440 --> 00:28:46,000
but you uh get a file descriptor for

00:28:44,960 --> 00:28:48,399
this mount

00:28:46,000 --> 00:28:49,200
um and you can reconfigure it so this is

00:28:48,399 --> 00:28:52,640
basically

00:28:49,200 --> 00:28:55,279
remounting a file system and open

00:28:52,640 --> 00:28:56,880
remounting a bind mount sorry and open

00:28:55,279 --> 00:29:00,799
tree clone this is really cool

00:28:56,880 --> 00:29:04,240
open tree clone clones amount and

00:29:00,799 --> 00:29:06,000
creates you a new detached mount and the

00:29:04,240 --> 00:29:07,760
directory that you're specifying or the

00:29:06,000 --> 00:29:08,799
file that you're specifying doesn't need

00:29:07,760 --> 00:29:11,279
to be a mount

00:29:08,799 --> 00:29:12,640
in itself so it basically turns a

00:29:11,279 --> 00:29:14,960
directory or files

00:29:12,640 --> 00:29:16,080
into mouse this is what open3d does

00:29:14,960 --> 00:29:18,080
which is amazing

00:29:16,080 --> 00:29:20,080
and at recursive if you specify

00:29:18,080 --> 00:29:22,559
alongside it with opentree clone

00:29:20,080 --> 00:29:23,679
um it copies the whole mount tree so

00:29:22,559 --> 00:29:26,480
every mount

00:29:23,679 --> 00:29:27,200
under a given directory file descriptor

00:29:26,480 --> 00:29:29,120
will be

00:29:27,200 --> 00:29:31,679
referred to by this file descriptor that

00:29:29,120 --> 00:29:33,840
open tree uh

00:29:31,679 --> 00:29:35,600
gives back to you so this is uh this is

00:29:33,840 --> 00:29:36,640
really great this is how you create mind

00:29:35,600 --> 00:29:39,200
modes now

00:29:36,640 --> 00:29:41,120
um and detached bind mounts the same

00:29:39,200 --> 00:29:41,520
principle as with the fs mount system

00:29:41,120 --> 00:29:45,200
call

00:29:41,520 --> 00:29:47,039
so if you um

00:29:45,200 --> 00:29:49,600
it isn't attached to the file system

00:29:47,039 --> 00:29:53,200
right so for example if you do open tree

00:29:49,600 --> 00:29:55,360
uh on a on an existing

00:29:53,200 --> 00:29:57,039
directory with opentree clone at

00:29:55,360 --> 00:29:59,200
recursive and then somebody

00:29:57,039 --> 00:30:00,240
unmounts the file system you have your

00:29:59,200 --> 00:30:02,720
own private mount

00:30:00,240 --> 00:30:06,159
you can change uh you can change things

00:30:02,720 --> 00:30:09,520
on it you can create flags you can

00:30:06,159 --> 00:30:11,039
create new files and so on um which is

00:30:09,520 --> 00:30:12,720
pretty amazing sorry you can't change

00:30:11,039 --> 00:30:13,360
flags this is something i'm working on

00:30:12,720 --> 00:30:16,320
but

00:30:13,360 --> 00:30:16,880
um you can create files and traverse

00:30:16,320 --> 00:30:19,520
through

00:30:16,880 --> 00:30:20,159
the amount that you just created i'm

00:30:19,520 --> 00:30:22,399
making

00:30:20,159 --> 00:30:24,640
heavy use of this in lexi and lexi

00:30:22,399 --> 00:30:26,640
already pretty good

00:30:24,640 --> 00:30:28,399
and last but not least it looks scary it

00:30:26,640 --> 00:30:28,799
looks complicated but it's actually not

00:30:28,399 --> 00:30:30,880
that

00:30:28,799 --> 00:30:32,960
complicated is the move mount system

00:30:30,880 --> 00:30:36,960
call this is the system call

00:30:32,960 --> 00:30:42,000
that takes either a file descriptor

00:30:36,960 --> 00:30:46,320
referring to referring to an fs context

00:30:42,000 --> 00:30:47,760
or to a file descriptor gotten from open

00:30:46,320 --> 00:30:49,679
tree

00:30:47,760 --> 00:30:52,159
and attaches it to the file system so it

00:30:49,679 --> 00:30:54,240
makes it visible in the file system

00:30:52,159 --> 00:30:56,399
and you have a variety of options that

00:30:54,240 --> 00:30:58,720
you can specify so from dfd

00:30:56,399 --> 00:31:00,240
from path it's the same principle as

00:30:58,720 --> 00:31:02,559
with fsp

00:31:00,240 --> 00:31:03,600
this is the source directory and into

00:31:02,559 --> 00:31:06,960
2dfd

00:31:03,600 --> 00:31:07,760
and uh two path and this is the target

00:31:06,960 --> 00:31:10,399
directory

00:31:07,760 --> 00:31:10,880
and the resolve rules are exactly the

00:31:10,399 --> 00:31:13,200
same

00:31:10,880 --> 00:31:14,000
uh it's just that the source and target

00:31:13,200 --> 00:31:17,360
both

00:31:14,000 --> 00:31:19,840
can be passed can be passed in this

00:31:17,360 --> 00:31:21,120
style and you have a bunch of ms ms

00:31:19,840 --> 00:31:24,960
flags that regulate

00:31:21,120 --> 00:31:26,640
how uh how dfd these both directory file

00:31:24,960 --> 00:31:27,519
descriptors and these both paths are

00:31:26,640 --> 00:31:31,039
supposed to be

00:31:27,519 --> 00:31:33,600
interpreted um so if

00:31:31,039 --> 00:31:35,039
they're supposed to uh follow siblings

00:31:33,600 --> 00:31:38,080
if they're supposed to follow

00:31:35,039 --> 00:31:40,799
autumn trigger auto mounts if uh you

00:31:38,080 --> 00:31:42,480
uh if the it's supposed to be operated

00:31:40,799 --> 00:31:42,960
directly on the file descriptor itself

00:31:42,480 --> 00:31:45,360
without

00:31:42,960 --> 00:31:46,000
actually resolving the path this is the

00:31:45,360 --> 00:31:48,799
empty path

00:31:46,000 --> 00:31:51,039
argument um and this is duplicated

00:31:48,799 --> 00:31:53,679
obviously so f siblings applies to

00:31:51,039 --> 00:31:54,880
from dfd and t sibling surprise to do

00:31:53,679 --> 00:31:57,600
dfd

00:31:54,880 --> 00:31:58,320
um yeah so this is uh pretty pretty

00:31:57,600 --> 00:32:00,240
great

00:31:58,320 --> 00:32:01,760
um so this lets you do a variety of

00:32:00,240 --> 00:32:04,000
things you can move mounts from one

00:32:01,760 --> 00:32:07,519
place to another you can attach

00:32:04,000 --> 00:32:09,120
fs context file descriptors um

00:32:07,519 --> 00:32:12,159
attach mount file descriptors gotten

00:32:09,120 --> 00:32:13,919
from fsmount and open3

00:32:12,159 --> 00:32:15,440
that have no representation in the file

00:32:13,919 --> 00:32:18,640
system yet um

00:32:15,440 --> 00:32:21,760
to specific paths uh in the file system

00:32:18,640 --> 00:32:25,440
uh so that's pretty great um

00:32:21,760 --> 00:32:28,720
and uh this is basically it

00:32:25,440 --> 00:32:30,480
um i try to be a bit faster here because

00:32:28,720 --> 00:32:32,399
i actually want to have sufficient time

00:32:30,480 --> 00:32:34,159
to do some demos of how this works

00:32:32,399 --> 00:32:35,519
because it's pretty theoretical and what

00:32:34,159 --> 00:32:38,720
you really want is

00:32:35,519 --> 00:32:42,960
to program with this stuff so

00:32:38,720 --> 00:32:45,679
i'm going to set up the demos and

00:32:42,960 --> 00:32:47,279
then i'll be right back and we'll

00:32:45,679 --> 00:32:50,720
continue

00:32:47,279 --> 00:32:56,720
uh that's at least what i suggest so

00:32:50,720 --> 00:33:00,640
see you in a little bit

00:32:56,720 --> 00:33:03,200
so let's do some demos

00:33:00,640 --> 00:33:04,000
um first of all i need to stop

00:33:03,200 --> 00:33:05,400
presenting

00:33:04,000 --> 00:33:08,320
here then

00:33:05,400 --> 00:33:13,120
[Music]

00:33:08,320 --> 00:33:16,240
share my terminal with you

00:33:13,120 --> 00:33:17,840
this one um

00:33:16,240 --> 00:33:20,320
hopefully this is large enough for

00:33:17,840 --> 00:33:24,720
everyone to see

00:33:20,320 --> 00:33:28,720
um seem to sell out quite a bit

00:33:24,720 --> 00:33:30,960
zoomed in quite a bit so um

00:33:28,720 --> 00:33:33,760
you can probably so first of all i need

00:33:30,960 --> 00:33:33,760
to go into

00:33:35,279 --> 00:33:42,640
demo parts

00:33:38,399 --> 00:33:44,799
i wanted to do

00:33:42,640 --> 00:33:44,799
and

00:33:47,440 --> 00:33:51,039
on real quick this is probably the first

00:33:49,519 --> 00:33:54,000
thing that

00:33:51,039 --> 00:33:54,720
we want to do let's just wipe this and

00:33:54,000 --> 00:33:58,480
then

00:33:54,720 --> 00:34:02,559
start from scratch um so i prepared

00:33:58,480 --> 00:34:04,480
a little header missing just calls that

00:34:02,559 --> 00:34:07,679
defines all of the missing syscalls and

00:34:04,480 --> 00:34:09,440
cisco numbers

00:34:07,679 --> 00:34:11,200
and they're mostly the same on all

00:34:09,440 --> 00:34:13,520
architectures for new syscalls

00:34:11,200 --> 00:34:14,919
apart from a few odd ones such as alpha

00:34:13,520 --> 00:34:18,879
mips and

00:34:14,919 --> 00:34:20,079
ia64 but i've taken care to define all

00:34:18,879 --> 00:34:22,320
of the syscalls we care about

00:34:20,079 --> 00:34:23,440
open tree move mount episode and fs

00:34:22,320 --> 00:34:27,200
config

00:34:23,440 --> 00:34:28,639
fs mount fs pic the mount attributes

00:34:27,200 --> 00:34:32,000
that we can specify with m

00:34:28,639 --> 00:34:33,520
fs mount um and the various flags for

00:34:32,000 --> 00:34:35,119
the individual sister call and then

00:34:33,520 --> 00:34:38,399
simple wrappers for all of the system

00:34:35,119 --> 00:34:41,599
calls themselves fs open fs mount

00:34:38,399 --> 00:34:44,480
um fs config move mount

00:34:41,599 --> 00:34:46,079
fs pick and open tree and also a little

00:34:44,480 --> 00:34:47,919
helper just to basically

00:34:46,079 --> 00:34:51,119
that we can easily exit with an error

00:34:47,919 --> 00:34:51,119
message when um

00:34:51,280 --> 00:34:54,720
when an unrecoverable error should

00:34:53,440 --> 00:34:56,000
happen so this is pretty

00:34:54,720 --> 00:34:57,680
that's pretty straightforward pretty

00:34:56,000 --> 00:34:59,599
simple using c for this because it's

00:34:57,680 --> 00:35:02,960
close to the operating system and

00:34:59,599 --> 00:35:05,760
um fairly easy to read so

00:35:02,960 --> 00:35:07,680
uh first of all what you want to do the

00:35:05,760 --> 00:35:09,359
first example you want to mount a real

00:35:07,680 --> 00:35:11,280
file system is pretty straightforward

00:35:09,359 --> 00:35:15,040
but what you would usually do is

00:35:11,280 --> 00:35:18,160
um mount

00:35:15,040 --> 00:35:21,280
um in this case this is uh dev

00:35:18,160 --> 00:35:25,119
loop 10 i think and then slash

00:35:21,280 --> 00:35:25,119
mount um

00:35:25,280 --> 00:35:34,400
and ms read only

00:35:31,480 --> 00:35:38,160
zero i think this

00:35:34,400 --> 00:35:39,599
should cover it but this is x4

00:35:38,160 --> 00:35:41,520
this is the mountain's call that we

00:35:39,599 --> 00:35:45,119
essentially want to translate so

00:35:41,520 --> 00:35:48,160
um we have a real file system that

00:35:45,119 --> 00:35:50,960
uh i set

00:35:48,160 --> 00:35:50,960
up already

00:35:51,280 --> 00:35:57,119
not x4 but x4 on dev loop 10

00:35:54,560 --> 00:35:58,560
um so i launched it on a loop device and

00:35:57,119 --> 00:36:00,079
what you want to do is we want to mount

00:35:58,560 --> 00:36:02,880
this so usually what you would do is

00:36:00,079 --> 00:36:02,880
internet mount

00:36:04,079 --> 00:36:12,720
should small zero

00:36:08,160 --> 00:36:16,400
and i i don't know

00:36:12,720 --> 00:36:19,280
failed to mount x4

00:36:16,400 --> 00:36:19,280
file system

00:36:19,760 --> 00:36:27,839
and i prepared my header correctly

00:36:32,880 --> 00:36:38,480
so standard bounces call

00:36:36,160 --> 00:36:38,480
i do

00:36:39,280 --> 00:36:44,320
uh then i see we'll have mounted a file

00:36:41,359 --> 00:36:47,040
system of x4 at slash mount

00:36:44,320 --> 00:36:49,119
um i can you mount this and now we want

00:36:47,040 --> 00:36:53,359
to translate this into the new mount api

00:36:49,119 --> 00:36:56,480
so this thing then

00:36:53,359 --> 00:37:00,079
becomes first we want to create an fs

00:36:56,480 --> 00:37:00,079
context like i mentioned before

00:37:00,720 --> 00:37:07,680
explore make the file descriptor close

00:37:04,880 --> 00:37:12,880
on exact

00:37:07,680 --> 00:37:12,880
now we want to die

00:37:14,079 --> 00:37:24,240
failed to create next for

00:37:18,320 --> 00:37:24,240
context and then we need to do

00:37:26,079 --> 00:37:29,440
uh configure the context actually that

00:37:28,240 --> 00:37:33,119
we just created

00:37:29,440 --> 00:37:36,400
um by setting the source so

00:37:33,119 --> 00:37:36,960
source and the source in this case is as

00:37:36,400 --> 00:37:40,800
i

00:37:36,960 --> 00:37:44,960
pointed out before is loop 10 and

00:37:40,800 --> 00:37:48,240
no flags and if we get

00:37:44,960 --> 00:37:50,720
an unexpected return value we just do

00:37:48,240 --> 00:37:52,079
diano and for this case let's be a bit

00:37:50,720 --> 00:37:55,119
simpler to go quicker

00:37:52,079 --> 00:37:57,920
let's just we fail that f is config

00:37:55,119 --> 00:38:00,000
now let's say we are finished uh

00:37:57,920 --> 00:38:01,520
configuring our file system context now

00:38:00,000 --> 00:38:03,200
we want to finalize it and actually

00:38:01,520 --> 00:38:06,320
create a mount to do this

00:38:03,200 --> 00:38:10,480
well to create a super block um

00:38:06,320 --> 00:38:14,000
to do this we call fs command create

00:38:10,480 --> 00:38:18,400
this becomes now this becomes

00:38:14,000 --> 00:38:20,960
now um

00:38:18,400 --> 00:38:21,760
let's say call this create and let's

00:38:20,960 --> 00:38:25,280
call this

00:38:21,760 --> 00:38:25,280
uh set source

00:38:25,520 --> 00:38:33,680
and then we finally create

00:38:32,079 --> 00:38:35,680
actual sorry now we're creating the

00:38:33,680 --> 00:38:36,000
actual super blocker causing the kernel

00:38:35,680 --> 00:38:41,200
to

00:38:36,000 --> 00:38:42,960
uh allocate a super block um only

00:38:41,200 --> 00:38:44,240
i'm telling you nonsense this conflict

00:38:42,960 --> 00:38:44,560
is where we create the super block we're

00:38:44,240 --> 00:38:48,079
now

00:38:44,560 --> 00:38:52,160
actually creating a mount um

00:38:48,079 --> 00:38:55,920
fd smaller zero we can say diarno

00:38:52,160 --> 00:38:59,920
with a with fs mount

00:38:55,920 --> 00:39:00,720
and now finally we have a detached mount

00:38:59,920 --> 00:39:02,079
right now

00:39:00,720 --> 00:39:03,839
uh we still haven't just anywhere

00:39:02,079 --> 00:39:04,720
visible in the file system so if we were

00:39:03,839 --> 00:39:07,839
to compile this

00:39:04,720 --> 00:39:10,880
and then do sudo uh

00:39:07,839 --> 00:39:12,640
fs and then would do find mount

00:39:10,880 --> 00:39:14,800
and you would see it's not mounted

00:39:12,640 --> 00:39:16,480
anything is not mounted anywhere so

00:39:14,800 --> 00:39:18,240
we're missing a large crucial step and

00:39:16,480 --> 00:39:22,320
this is red move mount

00:39:18,240 --> 00:39:25,200
in this case amount fd

00:39:22,320 --> 00:39:25,920
and we're passing in an invalid value

00:39:25,200 --> 00:39:28,000
because we're not

00:39:25,920 --> 00:39:29,680
mounting based off file descriptor in

00:39:28,000 --> 00:39:30,320
this case so we're not moving based on

00:39:29,680 --> 00:39:32,480
my

00:39:30,320 --> 00:39:34,079
file descriptor i want to move to slash

00:39:32,480 --> 00:39:37,200
mount and

00:39:34,079 --> 00:39:40,560
we want to specify that for the source

00:39:37,200 --> 00:39:41,200
we're moving mount uh we're moving empty

00:39:40,560 --> 00:39:42,720
path so

00:39:41,200 --> 00:39:44,320
we are operating directly on the mount

00:39:42,720 --> 00:39:47,520
of the file descriptor

00:39:44,320 --> 00:39:50,880
then smaller zero and we say

00:39:47,520 --> 00:39:54,240
erno and we fail with

00:39:50,880 --> 00:39:58,720
move mount now

00:39:54,240 --> 00:39:58,720
to compile and let's run and

00:40:01,359 --> 00:40:09,520
we'll see cool we just created

00:40:06,480 --> 00:40:10,000
nx format so this is what it would look

00:40:09,520 --> 00:40:13,680
like to

00:40:10,000 --> 00:40:15,520
create um to mount the file system in

00:40:13,680 --> 00:40:17,040
the new mount api usually i mean this is

00:40:15,520 --> 00:40:19,119
a lot more syscalls but it's

00:40:17,040 --> 00:40:20,960
it's cleaner it's clearer and also

00:40:19,119 --> 00:40:22,079
usually you configure a lot more stuff

00:40:20,960 --> 00:40:24,640
when you set up a

00:40:22,079 --> 00:40:26,079
super block um and if if you if you

00:40:24,640 --> 00:40:28,000
don't want to be fussed with all of that

00:40:26,079 --> 00:40:29,599
i mean you can still use the old uh

00:40:28,000 --> 00:40:31,359
mount system call but this is sort of

00:40:29,599 --> 00:40:34,800
the future and i think it's actually

00:40:31,359 --> 00:40:37,599
uh quite nice but let's say you

00:40:34,800 --> 00:40:38,960
want to create a bind mount so let's

00:40:37,599 --> 00:40:42,560
create something that we call

00:40:38,960 --> 00:40:45,760
slash bind mod actually let's go

00:40:42,560 --> 00:40:49,599
uh bind mount recursive

00:40:45,760 --> 00:40:50,000
in this case let's call it just like

00:40:49,599 --> 00:40:53,920
that

00:40:50,000 --> 00:40:58,000
so and then being lazy

00:40:53,920 --> 00:41:02,160
and copying the header and copying

00:40:58,000 --> 00:41:08,640
the bottom and let's say

00:41:02,160 --> 00:41:08,640
so what we want to do and first of all

00:41:09,839 --> 00:41:12,160
all right

00:41:12,960 --> 00:41:17,280
variables we need and we say because

00:41:15,520 --> 00:41:19,200
we're operating i'm going to operate on

00:41:17,280 --> 00:41:21,040
my current budapest i'm going to create

00:41:19,200 --> 00:41:24,880
a new mount namespace

00:41:21,040 --> 00:41:27,760
and this mount namespace will make sure

00:41:24,880 --> 00:41:29,119
that i'm not going to alter the my

00:41:27,760 --> 00:41:31,200
current mod name table and

00:41:29,119 --> 00:41:33,520
basically crash my computer this

00:41:31,200 --> 00:41:34,560
requires us to include sket voltage by

00:41:33,520 --> 00:41:38,079
the way

00:41:34,560 --> 00:41:41,760
um and now we do

00:41:38,079 --> 00:41:43,119
red mount uh let's use the old mount api

00:41:41,760 --> 00:41:46,240
for that again

00:41:43,119 --> 00:41:49,040
um let's see ms rec

00:41:46,240 --> 00:41:51,200
ms private to mount my turn my router

00:41:49,040 --> 00:41:51,760
bus into a non-shared private mount so

00:41:51,200 --> 00:41:54,400
that

00:41:51,760 --> 00:41:55,200
nothing propagates out into and out of

00:41:54,400 --> 00:41:58,079
my

00:41:55,200 --> 00:42:00,400
mount namespace say we're dying right

00:41:58,079 --> 00:42:03,839
here with mount

00:42:00,400 --> 00:42:03,839
and then let's do

00:42:03,920 --> 00:42:07,440
so now we're calling

00:42:07,599 --> 00:42:16,319
open tree which i've introduced before

00:42:10,800 --> 00:42:18,560
and was we say uh oops

00:42:16,319 --> 00:42:20,079
minus ebat f because we're not operating

00:42:18,560 --> 00:42:22,319
based on a file descriptor here

00:42:20,079 --> 00:42:24,160
and we're opening our root directory and

00:42:22,319 --> 00:42:27,040
we're specifying open

00:42:24,160 --> 00:42:27,920
tree hello exec make the file descriptor

00:42:27,040 --> 00:42:31,440
close on exec

00:42:27,920 --> 00:42:33,119
open tree clone

00:42:31,440 --> 00:42:36,640
because we want to create a new detached

00:42:33,119 --> 00:42:39,280
mount and at

00:42:36,640 --> 00:42:41,040
recursive because we want to copy every

00:42:39,280 --> 00:42:44,400
mount of our mount tree

00:42:41,040 --> 00:42:48,640
and also at empty path

00:42:44,400 --> 00:42:52,240
um actually that's nonsense

00:42:48,640 --> 00:42:54,480
don't need that empty path um okay

00:42:52,240 --> 00:42:56,319
and now we say if the amount of t we get

00:42:54,480 --> 00:42:59,839
back is smaller zero we can say

00:42:56,319 --> 00:42:59,839
die erno

00:43:02,000 --> 00:43:06,400
open tree in this case

00:43:06,480 --> 00:43:09,680
and i should learn how to type okay and

00:43:09,200 --> 00:43:13,200
now

00:43:09,680 --> 00:43:14,240
finally again we move this mount into

00:43:13,200 --> 00:43:17,520
place

00:43:14,240 --> 00:43:18,880
say amount of d again minus e beta f

00:43:17,520 --> 00:43:20,960
not operating based on the file

00:43:18,880 --> 00:43:25,040
descriptor in this case and then

00:43:20,960 --> 00:43:29,040
move mount f empty path

00:43:25,040 --> 00:43:30,800
to specify that

00:43:29,040 --> 00:43:33,040
we are operating directly on the mount

00:43:30,800 --> 00:43:37,520
file descriptor right here

00:43:33,040 --> 00:43:39,680
for this source and we can say again

00:43:37,520 --> 00:43:41,280
and what we would expect to happen is

00:43:39,680 --> 00:43:43,760
that we recursively mount

00:43:41,280 --> 00:43:45,280
all of our complete root of s to a

00:43:43,760 --> 00:43:47,280
location on mount

00:43:45,280 --> 00:43:48,960
actually there is one step missing

00:43:47,280 --> 00:43:52,480
because mount namespace says

00:43:48,960 --> 00:43:56,480
um what is he complaining about

00:43:52,480 --> 00:43:56,480
what it is complaining about mount

00:43:56,640 --> 00:44:00,480
and mount

00:44:00,560 --> 00:44:04,240
ah okay well that makes sense

00:44:06,160 --> 00:44:10,319
okay because we've created a new amount

00:44:08,560 --> 00:44:12,400
name space and amount name spaces only

00:44:10,319 --> 00:44:13,680
exist as long as the either blind mods

00:44:12,400 --> 00:44:17,119
are referenced by

00:44:13,680 --> 00:44:21,760
the process um that has created it

00:44:17,119 --> 00:44:26,560
um we're going to do run a new

00:44:21,760 --> 00:44:26,560
and i'm going to say char star

00:44:26,960 --> 00:44:30,560
and then you can see so we want to see

00:44:28,720 --> 00:44:33,760
our whole budapest

00:44:30,560 --> 00:44:38,000
appear in slash mount

00:44:33,760 --> 00:44:40,000
c and then let's do sudo

00:44:38,000 --> 00:44:42,240
spike mount if i'm going away because i

00:44:40,000 --> 00:44:46,960
 misprogrammed something

00:44:42,240 --> 00:44:51,599
um great talk thank you for being here

00:44:46,960 --> 00:44:54,400
um okay and now let's see

00:44:51,599 --> 00:44:55,200
oh yes everything the whole root of s is

00:44:54,400 --> 00:44:58,480
appears

00:44:55,200 --> 00:45:01,760
under um slash m t again

00:44:58,480 --> 00:45:02,480
so we just created we created a blank

00:45:01,760 --> 00:45:05,599
mount

00:45:02,480 --> 00:45:08,400
we can log out the context the

00:45:05,599 --> 00:45:10,160
uh bank mode is automatically destroyed

00:45:08,400 --> 00:45:12,640
and as you can see

00:45:10,160 --> 00:45:15,440
um these are two examples of how the new

00:45:12,640 --> 00:45:16,800
amount api worked

00:45:15,440 --> 00:45:18,319
should be it's it's fairly

00:45:16,800 --> 00:45:19,119
straightforward once you have gotten

00:45:18,319 --> 00:45:22,160
used to it

00:45:19,119 --> 00:45:23,520
to not like tie this all into one single

00:45:22,160 --> 00:45:26,640
syscall but rather

00:45:23,520 --> 00:45:27,520
stretch this over um over multiple

00:45:26,640 --> 00:45:30,079
syscalls

00:45:27,520 --> 00:45:31,040
but it is really way nicer you create a

00:45:30,079 --> 00:45:32,880
mount

00:45:31,040 --> 00:45:34,720
and the creation of the mount is

00:45:32,880 --> 00:45:36,960
independent of

00:45:34,720 --> 00:45:39,119
the appearance within the file system

00:45:36,960 --> 00:45:39,680
and the move mount system call is where

00:45:39,119 --> 00:45:41,200
um

00:45:39,680 --> 00:45:43,440
where you actually attach a mount into

00:45:41,200 --> 00:45:48,000
the file system which is just such a

00:45:43,440 --> 00:45:50,240
great great tool but in any case i hope

00:45:48,000 --> 00:45:52,160
you learned something and you saw how

00:45:50,240 --> 00:45:54,960
the new mount api is not just structured

00:45:52,160 --> 00:45:57,200
but also how it can be used in programs

00:45:54,960 --> 00:45:58,640
um i'm probably going to make the demos

00:45:57,200 --> 00:45:59,520
available somewhere probably on my

00:45:58,640 --> 00:46:04,480
homepage

00:45:59,520 --> 00:46:04,480
after after i've given this talk and

00:46:04,720 --> 00:46:11,920
it's basically um that's basically it

00:46:08,480 --> 00:46:15,200
we're we're almost out of we're almost

00:46:11,920 --> 00:46:16,960
out of time and

00:46:15,200 --> 00:46:18,800
there should be instructions on how you

00:46:16,960 --> 00:46:22,400
can ask me

00:46:18,800 --> 00:46:26,839
questions and i'm excited

00:46:22,400 --> 00:46:29,839
i'm excited for that so see you

00:46:26,839 --> 00:46:29,839

YouTube URL: https://www.youtube.com/watch?v=gMWKFPnmJSc


