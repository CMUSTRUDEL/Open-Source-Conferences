Title: A Few Effective gcc clang Optimizations for Embedded Systems - Khem Raj, Comcast
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	A Few Effective gcc/clang Optimizations for Embedded Systems - Khem Raj, Comcast

Compilers toolchains are at the core of the building the Embedded Linux Systems, it affects the full system from bootloaders, kernels to applications and platform software, compilers are software too, therefore knowing about how this can help to achieve code size, performance optimization is quite powerful insight to have for programming the systems. There are optimizations which are effective in embedded systems, provided by compilers via command line, but there is another class of coding practices, that can help the compiler to generate best code for a given algorithms, modern compilers are quite good at optimizing general code, however this can be made more effective by knowing these practices and help the compiler to compile to generate better code. Knowing the compiler can add that extra edge to programming techniques which can result is effective code. Clang and gcc are primary compilers for linux systems, so knowing the options to generate smaller, better code is the goal.
Captions: 
	00:00:02,330 --> 00:00:09,300
okay let's get started

00:00:04,950 --> 00:00:12,860
thanks everyone for coming and so today

00:00:09,300 --> 00:00:16,529
actually I'm going to talk about some

00:00:12,860 --> 00:00:20,960
system optimization techniques or you

00:00:16,529 --> 00:00:25,740
know best practices that you could use

00:00:20,960 --> 00:00:28,230
especially at very Linux or also you can

00:00:25,740 --> 00:00:32,669
extend that to other embedded systems

00:00:28,230 --> 00:00:34,890
that you might be working on primarily

00:00:32,669 --> 00:00:37,170
I'm gonna cover GCC and clang to a

00:00:34,890 --> 00:00:40,950
certain extent some in clang some in GCC

00:00:37,170 --> 00:00:44,340
but mostly it is around system and you

00:00:40,950 --> 00:00:48,719
know that could benefit you and I think

00:00:44,340 --> 00:00:50,640
end of the talk you might have a good

00:00:48,719 --> 00:00:53,730
idea of how you could interact with the

00:00:50,640 --> 00:00:54,410
compiler to get maximum out of it for

00:00:53,730 --> 00:00:59,640
you

00:00:54,410 --> 00:01:04,280
so agenda as I said is just the tools

00:00:59,640 --> 00:01:06,990
and some compiler optimization switches

00:01:04,280 --> 00:01:09,630
data types you can do log with how you

00:01:06,990 --> 00:01:14,070
arrange your data help the compiler that

00:01:09,630 --> 00:01:17,340
way variables and functions so you could

00:01:14,070 --> 00:01:19,290
do a lot of stuff with how you deal with

00:01:17,340 --> 00:01:22,650
variables or how you define your

00:01:19,290 --> 00:01:25,979
functions and so we'll talk about that

00:01:22,650 --> 00:01:29,009
and then a series of like optimization

00:01:25,979 --> 00:01:31,110
tips that I'll share and then in summary

00:01:29,009 --> 00:01:35,689
will just summarize what we talked about

00:01:31,110 --> 00:01:39,290
maybe some you know again some takeaways

00:01:35,689 --> 00:01:42,540
so feel free to ask questions you know

00:01:39,290 --> 00:01:44,930
start discussions if you have some ideas

00:01:42,540 --> 00:01:48,689
I share what I have and you might have

00:01:44,930 --> 00:01:51,119
you know further effective tips and I

00:01:48,689 --> 00:01:55,619
think it would be great to share if you

00:01:51,119 --> 00:01:57,689
have some of those so please please

00:01:55,619 --> 00:02:00,119
share and ask questions during to talk

00:01:57,689 --> 00:02:02,540
otherwise we'll also talk towards the

00:02:00,119 --> 00:02:02,540
end of it

00:02:03,469 --> 00:02:11,910
so tools know your compiler tool change

00:02:08,399 --> 00:02:13,360
so you know in in Linux generally we

00:02:11,910 --> 00:02:17,110
deal with GCC and

00:02:13,360 --> 00:02:21,850
you know as developers we we assume that

00:02:17,110 --> 00:02:25,360
our compiler is GCC but it's important

00:02:21,850 --> 00:02:27,700
to know what their compiler is so in

00:02:25,360 --> 00:02:30,820
open source we have GCC base tool chains

00:02:27,700 --> 00:02:32,440
we have clang base tool chains and there

00:02:30,820 --> 00:02:34,600
are vendor base tool chains so if you

00:02:32,440 --> 00:02:36,820
are doing something that is embedded you

00:02:34,600 --> 00:02:40,810
know if there are certain vendors

00:02:36,820 --> 00:02:44,550
well-known in to provide you know

00:02:40,810 --> 00:02:46,900
proprietary compiler tool chains and so

00:02:44,550 --> 00:02:52,060
should take a look at that when you work

00:02:46,900 --> 00:02:54,370
on an embedded systems project and each

00:02:52,060 --> 00:02:57,520
one of those compilers they have

00:02:54,370 --> 00:03:01,750
different things to offer and they would

00:02:57,520 --> 00:03:05,160
document a lot of this in their manuals

00:03:01,750 --> 00:03:07,510
so in many cases they would offer

00:03:05,160 --> 00:03:10,540
additional compiler specific

00:03:07,510 --> 00:03:13,630
optimizations or constructs that might

00:03:10,540 --> 00:03:16,240
be beneficial for you so go through

00:03:13,630 --> 00:03:19,450
those very very important and you will

00:03:16,240 --> 00:03:26,260
know why as we go through this talk as

00:03:19,450 --> 00:03:28,239
well the other thing that is to

00:03:26,260 --> 00:03:31,030
understand the memory layout of your

00:03:28,239 --> 00:03:33,660
systems when you are working on a

00:03:31,030 --> 00:03:36,220
desktop right now you have a pretty much

00:03:33,660 --> 00:03:40,239
virtual memory map and you really don't

00:03:36,220 --> 00:03:42,100
worry about that too much but when you

00:03:40,239 --> 00:03:45,220
are doing embedded systems your

00:03:42,100 --> 00:03:47,170
applications might be distributed across

00:03:45,220 --> 00:03:50,709
different kind of memory types you know

00:03:47,170 --> 00:03:53,140
you might have different like NAND flash

00:03:50,709 --> 00:03:58,290
you know different kind of memory

00:03:53,140 --> 00:04:01,450
technologies that will be in play and

00:03:58,290 --> 00:04:03,780
data would be put in some area right

00:04:01,450 --> 00:04:09,690
read-only data will be somewhere and

00:04:03,780 --> 00:04:12,130
knowing all that is very important and

00:04:09,690 --> 00:04:14,110
how you would see is that you know you

00:04:12,130 --> 00:04:17,410
can see the moon the memory map there

00:04:14,110 --> 00:04:21,640
are linker scripts that basically define

00:04:17,410 --> 00:04:24,520
the memory map and you would basically

00:04:21,640 --> 00:04:26,240
look through those and see how the

00:04:24,520 --> 00:04:28,580
memory is laid out

00:04:26,240 --> 00:04:30,860
and that way you know you you will

00:04:28,580 --> 00:04:32,690
understand when you're doing you know

00:04:30,860 --> 00:04:36,259
your data partitioning and data access

00:04:32,690 --> 00:04:41,090
you can write efficient access methods

00:04:36,259 --> 00:04:43,220
for those kind of data if you do not

00:04:41,090 --> 00:04:44,870
have specific linker scripts that you

00:04:43,220 --> 00:04:47,539
use that means it's using a default

00:04:44,870 --> 00:04:50,479
linker script that is provided by a tool

00:04:47,539 --> 00:04:52,880
chain and but it still is using one so

00:04:50,479 --> 00:04:56,360
you could still dump it and look at what

00:04:52,880 --> 00:04:58,160
it is trying to do commonly it is used

00:04:56,360 --> 00:05:01,610
across all applications so it will do

00:04:58,160 --> 00:05:03,610
the same things but it's good to even

00:05:01,610 --> 00:05:07,160
take a look at that if you're interested

00:05:03,610 --> 00:05:10,070
the other thing to look at that same

00:05:07,160 --> 00:05:13,130
thing is you generate map files so if

00:05:10,070 --> 00:05:16,250
you generate map files it will dump you

00:05:13,130 --> 00:05:18,380
know the your code data and BSS actions

00:05:16,250 --> 00:05:21,320
and which symbols are aware at what

00:05:18,380 --> 00:05:23,599
addresses and all that map also gives

00:05:21,320 --> 00:05:27,919
you a good view of what the total memory

00:05:23,599 --> 00:05:30,650
map looks like then there are these

00:05:27,919 --> 00:05:33,680
tools I'm pretty sure you know been

00:05:30,650 --> 00:05:38,560
using them if not they are very

00:05:33,680 --> 00:05:41,599
effective in in achieving all this

00:05:38,560 --> 00:05:45,229
inspection of your binaries and objects

00:05:41,599 --> 00:05:47,659
and I've listed few of those here they

00:05:45,229 --> 00:05:50,449
are primarily from the noodles package

00:05:47,659 --> 00:05:54,409
and object dumper you know this is

00:05:50,449 --> 00:05:57,259
basically taking an elf file you know

00:05:54,409 --> 00:06:00,949
that's your output file or in fact not

00:05:57,259 --> 00:06:06,169
only elf but other kind of formats but

00:06:00,949 --> 00:06:09,050
in Linux we use primarily elf so you can

00:06:06,169 --> 00:06:12,169
disassemble also right so if you want to

00:06:09,050 --> 00:06:16,580
take a look at what compiler did for you

00:06:12,169 --> 00:06:18,979
you could disassemble your code and see

00:06:16,580 --> 00:06:22,039
what's the corresponding code that was

00:06:18,979 --> 00:06:26,360
generated by a compiler for the you know

00:06:22,039 --> 00:06:28,520
this source code that you had and it's

00:06:26,360 --> 00:06:32,469
very educational if you take a look at

00:06:28,520 --> 00:06:35,719
that and it's also very sometimes

00:06:32,469 --> 00:06:38,210
unexpected where you expected a certain

00:06:35,719 --> 00:06:39,700
you know piece of code to generate a

00:06:38,210 --> 00:06:41,680
different kind of

00:06:39,700 --> 00:06:45,790
but you know you see something different

00:06:41,680 --> 00:06:47,950
there so size is another utility if you

00:06:45,790 --> 00:06:50,680
are interested in size measurements you

00:06:47,950 --> 00:06:54,730
know you can actually use this little T

00:06:50,680 --> 00:06:56,710
to even manage size of your application

00:06:54,730 --> 00:06:59,140
you could put it into your CI systems

00:06:56,710 --> 00:07:01,860
and always measure the size whenever

00:06:59,140 --> 00:07:05,430
there is a change that is being added

00:07:01,860 --> 00:07:08,140
Rodolphe is again displaying the content

00:07:05,430 --> 00:07:10,840
if you want to look at your allocations

00:07:08,140 --> 00:07:14,530
you know other pieces what different

00:07:10,840 --> 00:07:19,230
sections are there you could basically

00:07:14,530 --> 00:07:19,230
use read of for symbol dumping as well

00:07:19,380 --> 00:07:26,050
we nm is another it's a symbol Lister it

00:07:24,130 --> 00:07:29,860
will basically show you what all symbols

00:07:26,050 --> 00:07:32,320
are there at what address they are strip

00:07:29,860 --> 00:07:35,200
is actually another utility basically

00:07:32,320 --> 00:07:37,990
for you to strip away any debugging info

00:07:35,200 --> 00:07:41,020
symbols from Ally when you ship the code

00:07:37,990 --> 00:07:45,370
on the target you don't want to spend

00:07:41,020 --> 00:07:47,970
you know your precious Flash size for

00:07:45,370 --> 00:07:51,700
you know debug info or symbol info

00:07:47,970 --> 00:07:54,880
unless you need it so look at various

00:07:51,700 --> 00:07:57,400
options it has to offer you and there

00:07:54,880 --> 00:07:59,230
are more tools there so its I've given

00:07:57,400 --> 00:08:02,500
you a few of those in here but if you

00:07:59,230 --> 00:08:05,980
look in the suite of tools you get from

00:08:02,500 --> 00:08:12,520
bindles is quite quite quite more than

00:08:05,980 --> 00:08:15,310
that what we have here so besides that I

00:08:12,520 --> 00:08:17,620
think you know there are additional

00:08:15,310 --> 00:08:20,860
tools you will have from debugging for

00:08:17,620 --> 00:08:26,200
debugging purposes and we'll talk about

00:08:20,860 --> 00:08:32,890
those as well so this is for

00:08:26,200 --> 00:08:35,470
optimization levels and O's 0 is just a

00:08:32,890 --> 00:08:37,840
translation so you get one to one

00:08:35,470 --> 00:08:39,460
translation and you can see what

00:08:37,840 --> 00:08:41,440
compiler is doing without any

00:08:39,460 --> 00:08:44,080
optimization it's just translating your

00:08:41,440 --> 00:08:45,090
code from higher level language down

00:08:44,080 --> 00:08:49,680
into

00:08:45,090 --> 00:08:53,190
you know assembly oh one or oh it does

00:08:49,680 --> 00:08:56,640
somewhere some optimizations makes your

00:08:53,190 --> 00:09:01,830
code not regress for debugging not

00:08:56,640 --> 00:09:04,730
regress for you know basically speed

00:09:01,830 --> 00:09:08,310
improves a bit your debugging is nice

00:09:04,730 --> 00:09:10,890
and Oh two is moderate level of

00:09:08,310 --> 00:09:14,070
optimization levels so this is most

00:09:10,890 --> 00:09:16,260
commonly used in any projects so always

00:09:14,070 --> 00:09:18,000
look out for what's being used right in

00:09:16,260 --> 00:09:19,350
any project that you are doing

00:09:18,000 --> 00:09:21,740
especially if you're doing embedded

00:09:19,350 --> 00:09:24,890
Linux you might be using certain

00:09:21,740 --> 00:09:27,630
packages and they may have their own

00:09:24,890 --> 00:09:30,660
optimization levels and some of them for

00:09:27,630 --> 00:09:32,790
example you know media-centric packages

00:09:30,660 --> 00:09:35,670
they tend to use more aggressive

00:09:32,790 --> 00:09:38,390
optimizations and it's it's always good

00:09:35,670 --> 00:09:38,390
to know what they're doing

00:09:38,510 --> 00:09:49,470
OS is for size and og is actually

00:09:46,380 --> 00:09:52,890
recently added it's for better debug

00:09:49,470 --> 00:09:54,720
ability what it does is so if you let

00:09:52,890 --> 00:09:56,880
look at those they these are high level

00:09:54,720 --> 00:09:59,940
optimizations which basically transfer

00:09:56,880 --> 00:10:02,310
into smaller optimization passes in the

00:09:59,940 --> 00:10:04,710
compiler so it's actually collection of

00:10:02,310 --> 00:10:07,980
those optimization that is represented

00:10:04,710 --> 00:10:09,810
as OH - or oh one and you can actually

00:10:07,980 --> 00:10:13,680
look through the documentation I have a

00:10:09,810 --> 00:10:15,000
link in subsequent slides where you will

00:10:13,680 --> 00:10:16,830
see the collection of hundred

00:10:15,000 --> 00:10:22,589
optimizations that the compiler will

00:10:16,830 --> 00:10:25,710
apply as result of these so what do you

00:10:22,589 --> 00:10:30,110
see is it's basically a subset that is

00:10:25,710 --> 00:10:30,110
curated subsets that it'll apply for you

00:10:30,530 --> 00:10:38,250
ozzie it's also relatively new and it's

00:10:34,709 --> 00:10:40,339
actually OS with further more aggressive

00:10:38,250 --> 00:10:44,880
size optimizations what that means is

00:10:40,339 --> 00:10:46,830
you will suffer some performance you are

00:10:44,880 --> 00:10:49,110
telling the compiler that you know I

00:10:46,830 --> 00:10:52,370
care for sighs a lot more than anything

00:10:49,110 --> 00:10:56,390
else and so I'm fine if you

00:10:52,370 --> 00:11:01,940
you know if code is not optimized for

00:10:56,390 --> 00:11:04,370
performance Oh tree is similar like Ozzy

00:11:01,940 --> 00:11:08,960
but it is more on this performance side

00:11:04,370 --> 00:11:11,660
so if you want more performance and you

00:11:08,960 --> 00:11:13,070
can use all three but all three has a

00:11:11,660 --> 00:11:15,740
little bit of you have to be cautious

00:11:13,070 --> 00:11:18,370
because it will be very aggressive and

00:11:15,740 --> 00:11:22,250
it might break certain assumptions and

00:11:18,370 --> 00:11:26,930
certain standards that are recommended

00:11:22,250 --> 00:11:28,430
so when you use all three you my

00:11:26,930 --> 00:11:30,110
recommendation my recommendation is

00:11:28,430 --> 00:11:34,700
generally have your code working well

00:11:30,110 --> 00:11:37,610
with o2 before you bomb 203 and and go

00:11:34,700 --> 00:11:42,290
from there and there is another one

00:11:37,610 --> 00:11:49,790
called all fast this is primarily like

00:11:42,290 --> 00:11:53,960
all three it's on clang as well so so

00:11:49,790 --> 00:11:56,260
this is a link it's a very handy link go

00:11:53,960 --> 00:11:59,210
there and look at what these all

00:11:56,260 --> 00:12:01,250
optimisation passes are and how they are

00:11:59,210 --> 00:12:04,060
clubbed together to form this one of

00:12:01,250 --> 00:12:07,280
these meta optimization options I

00:12:04,060 --> 00:12:11,440
couldn't find one for clang but there

00:12:07,280 --> 00:12:15,620
are ways they document each options so

00:12:11,440 --> 00:12:17,960
there is a way to dump the optimizations

00:12:15,620 --> 00:12:21,290
that are applied to a certain level I

00:12:17,960 --> 00:12:26,150
did not include it here but it's similar

00:12:21,290 --> 00:12:27,710
to what GCC have so other options that

00:12:26,150 --> 00:12:32,240
you might find interesting is from

00:12:27,710 --> 00:12:35,150
security point of view and for some it

00:12:32,240 --> 00:12:37,940
may matter for some it may not but be

00:12:35,150 --> 00:12:40,280
aware that these options will you will

00:12:37,940 --> 00:12:42,320
pay some penalty with code so if you

00:12:40,280 --> 00:12:44,990
enable these options they might add

00:12:42,320 --> 00:12:47,270
extra checks into the code which

00:12:44,990 --> 00:12:50,270
basically will improve your security but

00:12:47,270 --> 00:12:53,120
it will slow down your code so stack

00:12:50,270 --> 00:12:56,500
protector you know this is a age-old

00:12:53,120 --> 00:13:00,589
optimizations or a feature in compiler

00:12:56,500 --> 00:13:04,790
so it has various levels and so you

00:13:00,589 --> 00:13:05,870
could basically enable any of those most

00:13:04,790 --> 00:13:11,630
commonly used

00:13:05,870 --> 00:13:15,529
the stack protector strong and they

00:13:11,630 --> 00:13:18,589
there are more like function level stack

00:13:15,529 --> 00:13:20,960
protection or things you could do that

00:13:18,589 --> 00:13:24,010
can basically have you are juggling here

00:13:20,960 --> 00:13:27,740
with performance and security you want

00:13:24,010 --> 00:13:30,500
there's a defined 45 sources so what it

00:13:27,740 --> 00:13:33,050
does is it links a code to additional

00:13:30,500 --> 00:13:36,200
like check function so you have name

00:13:33,050 --> 00:13:40,070
copy it will basically use the prototype

00:13:36,200 --> 00:13:42,020
for mem copy underscore chk function so

00:13:40,070 --> 00:13:44,630
these functions have additional checks

00:13:42,020 --> 00:13:48,130
so it will validate you know your

00:13:44,630 --> 00:13:52,460
arguments and stuff so you get more

00:13:48,130 --> 00:13:54,440
warnings tearing build and so you know

00:13:52,460 --> 00:13:56,630
you can basically fortify your sources a

00:13:54,440 --> 00:13:59,060
bit more and there are certain options

00:13:56,630 --> 00:14:00,950
that are there for checking formats

00:13:59,060 --> 00:14:04,100
right so you don't have like string

00:14:00,950 --> 00:14:05,900
overflows so these are very handy

00:14:04,100 --> 00:14:08,630
options if you are doing security

00:14:05,900 --> 00:14:13,310
related work or you want just to you

00:14:08,630 --> 00:14:15,589
know do a bit of fortification of your

00:14:13,310 --> 00:14:17,060
source code and then all these warnings

00:14:15,589 --> 00:14:20,060
you can turn them into error so

00:14:17,060 --> 00:14:21,770
somebody's adding code later on then you

00:14:20,060 --> 00:14:26,720
know that you know that your code will

00:14:21,770 --> 00:14:30,200
fail so very handy options so it is a

00:14:26,720 --> 00:14:36,950
question for everyone that's compiler

00:14:30,200 --> 00:14:39,320
support Oh for any guesses it does but

00:14:36,950 --> 00:14:41,720
all for essentially is or three in fact

00:14:39,320 --> 00:14:45,950
you can specify Oh 99 or you can specify

00:14:41,720 --> 00:14:49,640
all 3000 doesn't matter so be aware that

00:14:45,950 --> 00:14:52,190
you know there is this number is not to

00:14:49,640 --> 00:14:54,230
be raised infinitely and you kind of

00:14:52,190 --> 00:14:56,959
force compiler to compile better and

00:14:54,230 --> 00:15:00,470
better and better why I brought this up

00:14:56,959 --> 00:15:03,440
is because in the end compiler is also a

00:15:00,470 --> 00:15:06,380
software right so it can do certain

00:15:03,440 --> 00:15:08,990
things but it's not something that you

00:15:06,380 --> 00:15:16,670
know has infinite amount of power that

00:15:08,990 --> 00:15:17,050
you can kind of extract max out of it so

00:15:16,670 --> 00:15:22,030
they

00:15:17,050 --> 00:15:24,640
types so you know we use integers we use

00:15:22,030 --> 00:15:27,520
floats and all the basic types and

00:15:24,640 --> 00:15:28,420
complex types but it's important

00:15:27,520 --> 00:15:30,070
actually

00:15:28,420 --> 00:15:32,950
especially in embedded space to know

00:15:30,070 --> 00:15:35,200
your processor world size so the

00:15:32,950 --> 00:15:37,290
processor world size is you know your

00:15:35,200 --> 00:15:40,270
integer length that your processor can

00:15:37,290 --> 00:15:42,550
can process right so it could be a

00:15:40,270 --> 00:15:47,890
16-bit processor it could be a 32-bit

00:15:42,550 --> 00:15:54,010
64-bit and the standard C type may not

00:15:47,890 --> 00:15:58,150
map onto it want one right so always try

00:15:54,010 --> 00:16:03,490
to use that can be mapped onto the word

00:15:58,150 --> 00:16:06,510
size of your of your processor there is

00:16:03,490 --> 00:16:10,110
a reason for that is that when you do

00:16:06,510 --> 00:16:13,090
use types which are smaller or bigger

00:16:10,110 --> 00:16:15,630
there is a extra penalty that compiler

00:16:13,090 --> 00:16:18,040
has to do conversions like

00:16:15,630 --> 00:16:20,020
sign-extension zero extensions all those

00:16:18,040 --> 00:16:28,450
things will come into play as you

00:16:20,020 --> 00:16:31,600
operate on that data so it's basically

00:16:28,450 --> 00:16:36,540
there are certain defines write that I

00:16:31,600 --> 00:16:39,880
will cover next but you might see

00:16:36,540 --> 00:16:41,350
certain different processor types in

00:16:39,880 --> 00:16:43,810
behaving differently on different data

00:16:41,350 --> 00:16:46,810
types right so if you have a risk-based

00:16:43,810 --> 00:16:49,570
processor or six based processor and the

00:16:46,810 --> 00:16:51,640
characteristics might be different so it

00:16:49,570 --> 00:16:59,050
again goes back to know your processor

00:16:51,640 --> 00:17:02,590
architecture argument so delegate to

00:16:59,050 --> 00:17:05,140
compiler as much as you can right I know

00:17:02,590 --> 00:17:06,700
that people have defined their own type

00:17:05,140 --> 00:17:09,070
systems right when you write a big

00:17:06,700 --> 00:17:11,650
software you have this one file called

00:17:09,070 --> 00:17:15,209
type storage right and you define your

00:17:11,650 --> 00:17:18,900
own type system whatever you like

00:17:15,209 --> 00:17:22,440
that was fine in the past but I think

00:17:18,900 --> 00:17:25,930
c99 and newer you know it has tried to

00:17:22,440 --> 00:17:29,340
abstract those bits and provide those

00:17:25,930 --> 00:17:32,670
facilities to to the user

00:17:29,340 --> 00:17:36,480
and you'll have these fixed-width types

00:17:32,670 --> 00:17:39,540
you UNT and you will have the minimum

00:17:36,480 --> 00:17:41,250
built for you in lease T and for fastest

00:17:39,540 --> 00:17:43,470
basically you'll have you in thirsty

00:17:41,250 --> 00:17:44,970
right if you use this then you really

00:17:43,470 --> 00:17:46,970
don't have to worry about the underlying

00:17:44,970 --> 00:17:49,140
processor architecture as much right

00:17:46,970 --> 00:17:53,400
because the compiler will do the right

00:17:49,140 --> 00:17:55,830
conversion for you and then there is of

00:17:53,400 --> 00:18:00,710
course the portable datatypes using T

00:17:55,830 --> 00:18:04,970
and you know their sizes now 8 16 32 64

00:18:00,710 --> 00:18:08,580
likewise so that gives you a good

00:18:04,970 --> 00:18:11,340
abstraction based on the width of data

00:18:08,580 --> 00:18:12,630
that you would like to do so highly

00:18:11,340 --> 00:18:16,440
recommended

00:18:12,630 --> 00:18:18,680
both GCC and clang will thank you for

00:18:16,440 --> 00:18:18,680
doing that

00:18:19,490 --> 00:18:26,160
variables and functions so I'll talk

00:18:22,710 --> 00:18:28,530
about Const a little bit when you

00:18:26,160 --> 00:18:29,730
qualify you know your functions or data

00:18:28,530 --> 00:18:32,910
types

00:18:29,730 --> 00:18:35,640
it's a additional help that compiler has

00:18:32,910 --> 00:18:42,120
you are basically annotating your code

00:18:35,640 --> 00:18:44,730
you know by using these keywords which

00:18:42,120 --> 00:18:48,600
basically tells compiler that it's a

00:18:44,730 --> 00:18:50,280
data that's not going to change it can

00:18:48,600 --> 00:18:53,280
be more aggressive with these

00:18:50,280 --> 00:18:56,310
optimizations and then there is

00:18:53,280 --> 00:18:58,770
immutable there is documentation so you

00:18:56,310 --> 00:19:00,690
are basically stating it out to whoever

00:18:58,770 --> 00:19:03,270
is reading your code what this is

00:19:00,690 --> 00:19:07,620
supposed to do which is that you don't

00:19:03,270 --> 00:19:10,650
want it to be changed whenever this is

00:19:07,620 --> 00:19:12,510
going to be used elsewhere compiler will

00:19:10,650 --> 00:19:14,130
be able to give you better Diagnostics

00:19:12,510 --> 00:19:18,000
about you know you doing a conversion

00:19:14,130 --> 00:19:20,160
between writing to a Const or and or

00:19:18,000 --> 00:19:24,840
doing a conversion between like constant

00:19:20,160 --> 00:19:27,420
on console or

00:19:24,840 --> 00:19:29,310
opportunity therefore compiler to

00:19:27,420 --> 00:19:33,090
optimize as well if your data type

00:19:29,310 --> 00:19:35,130
remains consistent so I highly recommend

00:19:33,090 --> 00:19:37,410
to you know think about when you define

00:19:35,130 --> 00:19:41,160
your data set to see what all data could

00:19:37,410 --> 00:19:43,110
be constant and ideally all data could

00:19:41,160 --> 00:19:46,049
be concentrate so that would be best but

00:19:43,110 --> 00:19:48,150
so as you think more about it probably

00:19:46,049 --> 00:19:50,250
it will be better for your program and

00:19:48,150 --> 00:19:54,330
also you will extract a lot of

00:19:50,250 --> 00:20:01,160
information from the compiler our

00:19:54,330 --> 00:20:04,920
optimizations function parameters so no

00:20:01,160 --> 00:20:09,150
the ABI right especially the calling

00:20:04,920 --> 00:20:11,340
convention it depends on every processor

00:20:09,150 --> 00:20:15,419
architecture so they have different

00:20:11,340 --> 00:20:19,559
register sets therefore you know you

00:20:15,419 --> 00:20:21,870
will have different ways that compiler

00:20:19,559 --> 00:20:25,470
will pass your parameters to your

00:20:21,870 --> 00:20:29,940
function so I'm taking an example here

00:20:25,470 --> 00:20:33,990
for arm so when you have arm functions

00:20:29,940 --> 00:20:36,419
in arm for parameters are passed in

00:20:33,990 --> 00:20:39,720
registers right if you have more than

00:20:36,419 --> 00:20:48,570
four parameters they will be passed in

00:20:39,720 --> 00:20:50,460
on stack right so now it's also

00:20:48,570 --> 00:20:52,590
important that you have like four words

00:20:50,460 --> 00:20:55,500
like 32 with words that you can pass

00:20:52,590 --> 00:20:57,179
right now if you if it got in long long

00:20:55,500 --> 00:21:00,419
or something that you want to pass right

00:20:57,179 --> 00:21:01,799
in between so make sure the parameters

00:21:00,419 --> 00:21:04,590
are organized such that there is no

00:21:01,799 --> 00:21:09,870
padding right what will happen is if you

00:21:04,590 --> 00:21:12,299
take a parameter which is say 8 bit 8

00:21:09,870 --> 00:21:15,780
byte long and there is another one which

00:21:12,299 --> 00:21:18,510
is 4 byte long and you place them say

00:21:15,780 --> 00:21:20,250
you place the 8 byte after the 4 byte

00:21:18,510 --> 00:21:22,380
guess what's going to happen one

00:21:20,250 --> 00:21:25,590
register is going to be empty because

00:21:22,380 --> 00:21:28,590
it's going to align it so the resistors

00:21:25,590 --> 00:21:31,320
will be passed in the you know register

00:21:28,590 --> 00:21:33,450
3 & 4 1 & 2 will pass your first

00:21:31,320 --> 00:21:35,460
parameter and basically register 2 will

00:21:33,450 --> 00:21:38,040
be empty your third parameter will go on

00:21:35,460 --> 00:21:41,280
to stack but if you do a little bit of

00:21:38,040 --> 00:21:43,650
trick where you pass you pass the first

00:21:41,280 --> 00:21:45,510
long long and it goes into first two

00:21:43,650 --> 00:21:47,490
parameters and then pass the third one

00:21:45,510 --> 00:21:49,169
which is long that will go into the

00:21:47,490 --> 00:21:51,240
third register so forth register is

00:21:49,169 --> 00:21:55,170
still available so your fourth parameter

00:21:51,240 --> 00:21:57,210
will pass onto the register as well

00:21:55,170 --> 00:21:59,040
so alignment keeping keep an eye on

00:21:57,210 --> 00:22:02,240
alignment all the time when you do the

00:21:59,040 --> 00:22:05,040
function parameter passing right

00:22:02,240 --> 00:22:06,960
floating point has its API is to and

00:22:05,040 --> 00:22:12,080
especially an arm for example there are

00:22:06,960 --> 00:22:19,110
three floating point abs that you have

00:22:12,080 --> 00:22:21,750
so so soft we @p soft and hard so how

00:22:19,110 --> 00:22:23,670
you transfer your floating point

00:22:21,750 --> 00:22:27,120
registers through function parameters

00:22:23,670 --> 00:22:30,060
that's what it is about so when you have

00:22:27,120 --> 00:22:32,250
you know vector floating point units on

00:22:30,060 --> 00:22:34,560
your system you want to take advantage

00:22:32,250 --> 00:22:38,010
of those so it's important to understand

00:22:34,560 --> 00:22:40,470
that what all your chip has and then

00:22:38,010 --> 00:22:44,430
enable the right floating point API for

00:22:40,470 --> 00:22:46,830
you in many cases you may not be able to

00:22:44,430 --> 00:22:50,010
do the parameter passing in floating

00:22:46,830 --> 00:22:52,800
point registers but you still might have

00:22:50,010 --> 00:22:55,770
a neon or some of those sim D vector

00:22:52,800 --> 00:22:58,730
floating point units so you could tell

00:22:55,770 --> 00:23:01,760
it that yes once the data is transferred

00:22:58,730 --> 00:23:06,480
you could invoke a vector floating point

00:23:01,760 --> 00:23:08,870
but I cannot pass parameters in floating

00:23:06,480 --> 00:23:12,000
point registers so you still get some

00:23:08,870 --> 00:23:16,500
performance boost especially when you

00:23:12,000 --> 00:23:19,050
are doing loops and loop unrolling but

00:23:16,500 --> 00:23:22,890
you won't get the parameter passing will

00:23:19,050 --> 00:23:25,830
still happen through stack then you do

00:23:22,890 --> 00:23:27,780
the hard floating then it'll get both

00:23:25,830 --> 00:23:29,790
right so you'll have the processing also

00:23:27,780 --> 00:23:31,470
happening as well as the parameters will

00:23:29,790 --> 00:23:34,290
also pass through floating point

00:23:31,470 --> 00:23:36,600
registers so there will be no copier

00:23:34,290 --> 00:23:39,360
from general-purpose registers in to

00:23:36,600 --> 00:23:41,090
floating point you know vector unit back

00:23:39,360 --> 00:23:43,950
and forth that won't happen

00:23:41,090 --> 00:23:47,220
software P is actually you don't have

00:23:43,950 --> 00:23:49,830
very soft or soft FP is basically you

00:23:47,220 --> 00:23:54,450
don't have any unit all floating point

00:23:49,830 --> 00:23:56,310
should be emulated in software so it's

00:23:54,450 --> 00:23:57,780
important to know that if you work on

00:23:56,310 --> 00:23:59,550
different architectures they will have

00:23:57,780 --> 00:24:02,670
different different considerations so

00:23:59,550 --> 00:24:06,260
always refer to your T RMS for the

00:24:02,670 --> 00:24:06,260
hardware to find that out

00:24:08,129 --> 00:24:14,820
avoid Global's and static data in loops

00:24:11,759 --> 00:24:17,039
the reason is this is global data it

00:24:14,820 --> 00:24:19,019
will not be cached so they have to

00:24:17,039 --> 00:24:20,970
basically every time you I trade over

00:24:19,019 --> 00:24:25,889
the loop it has to go and write it down

00:24:20,970 --> 00:24:28,169
to wherever it is so so we aware of that

00:24:25,889 --> 00:24:30,690
fact that if you are accessing global

00:24:28,169 --> 00:24:32,609
data or even static data and you're

00:24:30,690 --> 00:24:38,759
looping over it and that loop will be

00:24:32,609 --> 00:24:41,940
slower use volt so when really needed

00:24:38,759 --> 00:24:44,899
the reason is that by doing this you are

00:24:41,940 --> 00:24:48,379
telling the compiler I know that this

00:24:44,899 --> 00:24:51,599
may not be seeing this code may not be

00:24:48,379 --> 00:24:54,769
rearranged or optimized in the way so I

00:24:51,599 --> 00:24:56,639
want the sequence to be as such so

00:24:54,769 --> 00:24:58,440
usually you know while accessing

00:24:56,639 --> 00:25:02,909
hardware registers and stuff like that

00:24:58,440 --> 00:25:05,759
you you would do that but don't use it

00:25:02,909 --> 00:25:07,950
to kind of you know get compiler out of

00:25:05,759 --> 00:25:10,619
your way because you want to do

00:25:07,950 --> 00:25:13,080
something and compiler is aggressive and

00:25:10,619 --> 00:25:14,700
it's optimizing it away and you put in

00:25:13,080 --> 00:25:17,220
bullet tile in there and suddenly you

00:25:14,700 --> 00:25:19,769
see it's working again the reason is you

00:25:17,220 --> 00:25:22,169
kind of you know trampled on compiler

00:25:19,769 --> 00:25:25,859
rather didn't fix the problem in the

00:25:22,169 --> 00:25:29,460
right way so be aware of what volatile

00:25:25,859 --> 00:25:34,950
is for right and similarly like if you

00:25:29,460 --> 00:25:37,679
have function calls in loops check that

00:25:34,950 --> 00:25:40,320
if this function is in line if it is in

00:25:37,679 --> 00:25:43,799
line it's fine if it is not in line then

00:25:40,320 --> 00:25:46,200
you're incurring a function call a

00:25:43,799 --> 00:25:49,440
function call in a loop would mean that

00:25:46,200 --> 00:25:53,609
it has to you know victor all the cash

00:25:49,440 --> 00:25:56,580
it has done and and all the you know the

00:25:53,609 --> 00:26:01,259
nice things about cash cash usage they

00:25:56,580 --> 00:26:03,299
will go out of the picture so make sure

00:26:01,259 --> 00:26:05,429
that you know the loops are having

00:26:03,299 --> 00:26:11,309
smaller functions which could be inlined

00:26:05,429 --> 00:26:15,679
otherwise avoid any function at all the

00:26:11,309 --> 00:26:20,039
other thing is actually attributes so

00:26:15,679 --> 00:26:21,659
there are bunch of attributes in there

00:26:20,039 --> 00:26:21,960
and you know we could go or therefore

00:26:21,659 --> 00:26:23,909
all the

00:26:21,960 --> 00:26:26,669
long array you know we could explain

00:26:23,909 --> 00:26:28,950
each one of them but I think I've just

00:26:26,669 --> 00:26:31,409
given you a pointer here read through

00:26:28,950 --> 00:26:35,010
those attributes are very very helpful

00:26:31,409 --> 00:26:37,620
to express what you want to do with data

00:26:35,010 --> 00:26:39,480
right so you want an alignment there is

00:26:37,620 --> 00:26:41,490
an attribute for that so you can define

00:26:39,480 --> 00:26:45,809
your data at a certain alignment

00:26:41,490 --> 00:26:48,419
boundary there are type you want to

00:26:45,809 --> 00:26:51,809
check types you want to do various

00:26:48,419 --> 00:26:54,870
things with your data representation you

00:26:51,809 --> 00:26:57,659
want to let compiler know whether you

00:26:54,870 --> 00:26:58,980
know a particular variable is used so

00:26:57,659 --> 00:27:01,279
don't optimize it away

00:26:58,980 --> 00:27:03,809
you can add that attribute to it right

00:27:01,279 --> 00:27:06,960
so you can help compiler by doing those

00:27:03,809 --> 00:27:10,799
things but also get your your program

00:27:06,960 --> 00:27:16,529
behave correctly while using higher

00:27:10,799 --> 00:27:18,649
level of optimizations GCC also has

00:27:16,529 --> 00:27:21,419
function and variable attributes

00:27:18,649 --> 00:27:23,880
compiler attributes between GCC and

00:27:21,419 --> 00:27:26,340
clang are pretty much similar but you

00:27:23,880 --> 00:27:29,070
might find few differences clang has few

00:27:26,340 --> 00:27:32,429
additional ones GCC has few different

00:27:29,070 --> 00:27:36,840
ones overall you have a very big common

00:27:32,429 --> 00:27:41,700
set amongst those but there are certain

00:27:36,840 --> 00:27:44,000
differences so when you use this what do

00:27:41,700 --> 00:27:46,260
you lose you lose portability great so

00:27:44,000 --> 00:27:50,039
make sure that when you use these

00:27:46,260 --> 00:27:51,899
variables you conditional eyes them with

00:27:50,039 --> 00:27:55,080
the compiler defines so if you're using

00:27:51,899 --> 00:27:56,610
clang use this if not use something

00:27:55,080 --> 00:28:02,990
different if you are worried about

00:27:56,610 --> 00:28:06,899
portability that is important okay so

00:28:02,990 --> 00:28:11,190
some optimization tips create baselines

00:28:06,899 --> 00:28:13,649
right so many times we go for

00:28:11,190 --> 00:28:17,730
optimizations and we are excited about

00:28:13,649 --> 00:28:19,440
it and we don't set a target for

00:28:17,730 --> 00:28:22,679
ourselves and we don't have a starting

00:28:19,440 --> 00:28:24,630
point but we just say well it was slower

00:28:22,679 --> 00:28:28,649
now it is faster it doesn't work that

00:28:24,630 --> 00:28:30,750
way because when you go for

00:28:28,649 --> 00:28:32,549
optimizations always there is a

00:28:30,750 --> 00:28:34,409
low-hanging fruits and you will

00:28:32,549 --> 00:28:35,460
certainly improve it and then it gets

00:28:34,409 --> 00:28:38,490
tougher and tougher

00:28:35,460 --> 00:28:40,620
right so you have to like stop at

00:28:38,490 --> 00:28:43,110
certain point of time so that's why it

00:28:40,620 --> 00:28:44,820
is important to set your baseline and

00:28:43,110 --> 00:28:50,700
then set your target and then march

00:28:44,820 --> 00:28:54,890
towards it find very good measurement

00:28:50,700 --> 00:28:58,830
tools right so measure as much as you do

00:28:54,890 --> 00:29:02,040
like to do optimize optimizations need

00:28:58,830 --> 00:29:03,420
lot of measurements right so find good

00:29:02,040 --> 00:29:07,970
measurement tools you know there are

00:29:03,420 --> 00:29:10,110
good tools out there you know profilers

00:29:07,970 --> 00:29:12,900
debuggers that can give you a lot of

00:29:10,110 --> 00:29:14,460
information tracers right that can give

00:29:12,900 --> 00:29:19,250
you a lot of information about the

00:29:14,460 --> 00:29:23,430
nature of your code and put them to your

00:29:19,250 --> 00:29:26,760
use and you can also augment your

00:29:23,430 --> 00:29:28,500
compilation with other tools for example

00:29:26,760 --> 00:29:30,240
if you know there is additional tools

00:29:28,500 --> 00:29:32,100
that gives you information about and

00:29:30,240 --> 00:29:37,040
that could be a proprietary tool or

00:29:32,100 --> 00:29:39,210
something go for it that's fine and an

00:29:37,040 --> 00:29:41,160
experiment right so whenever you have

00:29:39,210 --> 00:29:43,170
this set in place now you can make

00:29:41,160 --> 00:29:46,140
changes and do measurements right and

00:29:43,170 --> 00:29:48,990
and look into the the code if I do it

00:29:46,140 --> 00:29:51,540
this way what is compiler doing so this

00:29:48,990 --> 00:29:54,390
basically gives you a good set or good

00:29:51,540 --> 00:29:56,670
way to lead into and not go haywire by

00:29:54,390 --> 00:29:59,130
thinking that oh I think now it is

00:29:56,670 --> 00:30:02,610
running faster because I changed the

00:29:59,130 --> 00:30:05,910
data structures right but this will give

00:30:02,610 --> 00:30:09,080
you that framework to dig deeper and see

00:30:05,910 --> 00:30:09,080
what the effect is

00:30:10,070 --> 00:30:15,330
consider portability right so porting is

00:30:13,710 --> 00:30:17,340
important if you are you know

00:30:15,330 --> 00:30:21,780
envisioning that your software will run

00:30:17,340 --> 00:30:25,140
on different platforms and it always

00:30:21,780 --> 00:30:27,780
will you may not start that way but and

00:30:25,140 --> 00:30:29,250
generally it will be you know running on

00:30:27,780 --> 00:30:32,880
maybe you'll have a different product

00:30:29,250 --> 00:30:39,450
line where you want to reuse so it helps

00:30:32,880 --> 00:30:41,970
a lot with code reuse and follow like

00:30:39,450 --> 00:30:45,030
standards right and compiler does have

00:30:41,970 --> 00:30:49,470
options to enforce standards in your

00:30:45,030 --> 00:30:53,040
code for example you know c99

00:30:49,470 --> 00:30:57,330
there is Agnew 99 which is c99 with GCC

00:30:53,040 --> 00:30:59,250
extensions but if you want to work

00:30:57,330 --> 00:31:02,460
across compilers right you want to use

00:30:59,250 --> 00:31:06,270
clang and others just use C 99 right for

00:31:02,460 --> 00:31:08,520
best results it's easy to give up

00:31:06,270 --> 00:31:11,100
portability right so in many cases you

00:31:08,520 --> 00:31:14,370
are doing you are under stress to

00:31:11,100 --> 00:31:16,530
deliver the product and you wouldn't

00:31:14,370 --> 00:31:20,580
bite you don't have that much of time to

00:31:16,530 --> 00:31:24,360
do it in a very portable way but it does

00:31:20,580 --> 00:31:26,970
come back to you eventually so you know

00:31:24,360 --> 00:31:28,710
you could basically see what there are

00:31:26,970 --> 00:31:31,799
in compilers that could be done in

00:31:28,710 --> 00:31:34,440
portable way right so for example

00:31:31,799 --> 00:31:37,500
pragmas are very helpful so you can have

00:31:34,440 --> 00:31:39,720
compiler specific pragmas so if you say

00:31:37,500 --> 00:31:44,360
pragma GCC optimized under all groups

00:31:39,720 --> 00:31:49,140
i've given an example here when you use

00:31:44,360 --> 00:31:51,720
clang this is effectively no op so what

00:31:49,140 --> 00:31:55,320
you could do is you could do a if-else

00:31:51,720 --> 00:31:57,570
loop if GCC do this house clang do this

00:31:55,320 --> 00:32:01,860
and in the final else you could error

00:31:57,570 --> 00:32:03,750
out so if you say now are working on the

00:32:01,860 --> 00:32:06,150
third compiler your code will not

00:32:03,750 --> 00:32:08,610
compile then you know that I have to do

00:32:06,150 --> 00:32:10,830
something about this pragma that you

00:32:08,610 --> 00:32:12,720
know is functioning on other compilers

00:32:10,830 --> 00:32:15,540
so there are different ways different

00:32:12,720 --> 00:32:21,780
you know ways you can manage some

00:32:15,540 --> 00:32:27,540
portable code there okay so which one is

00:32:21,780 --> 00:32:30,510
better what do you think so this is a

00:32:27,540 --> 00:32:37,429
ternary operator and this is a false

00:32:30,510 --> 00:32:41,490
statement correct so they are same right

00:32:37,429 --> 00:32:43,140
so many times you would say that well on

00:32:41,490 --> 00:32:45,630
some architectures it may not be same

00:32:43,140 --> 00:32:50,070
some compilers remain the same but the

00:32:45,630 --> 00:32:53,309
point remains is that when you have the

00:32:50,070 --> 00:32:57,000
code don't assume that a smaller code

00:32:53,309 --> 00:33:00,210
will generate smaller code so the

00:32:57,000 --> 00:33:01,590
ternary operator here is basically going

00:33:00,210 --> 00:33:01,970
to generate the exact same amount of

00:33:01,590 --> 00:33:04,940
code

00:33:01,970 --> 00:33:10,399
that the if/else on generate in some

00:33:04,940 --> 00:33:12,710
cases it will generate worse code so

00:33:10,399 --> 00:33:19,840
always measure look at what's being

00:33:12,710 --> 00:33:24,159
generated out from from the code so it's

00:33:19,840 --> 00:33:28,669
important from that aspect anyway so

00:33:24,159 --> 00:33:30,440
moving on optimizing for stack stack

00:33:28,669 --> 00:33:33,110
size very important know it what the

00:33:30,440 --> 00:33:34,669
stack size is right so default

00:33:33,110 --> 00:33:36,649
applications are assigned a certain

00:33:34,669 --> 00:33:38,509
stack limits but if you are doing

00:33:36,649 --> 00:33:41,059
embedded systems you define your stacks

00:33:38,509 --> 00:33:43,789
and so know what the stacks are and

00:33:41,059 --> 00:33:47,929
usually they are small in embedded

00:33:43,789 --> 00:33:50,720
systems so you have to help the system

00:33:47,929 --> 00:33:54,710
to be able to operate at that limit so

00:33:50,720 --> 00:33:57,919
for example large arrays write any local

00:33:54,710 --> 00:34:00,289
variables a lot of function calls and

00:33:57,919 --> 00:34:04,340
they all end up eating up a lot of space

00:34:00,289 --> 00:34:06,200
on your stack recursive functions right

00:34:04,340 --> 00:34:10,700
so they will end up eating a lot of

00:34:06,200 --> 00:34:12,859
stack so so be aware of that whenever

00:34:10,700 --> 00:34:16,280
you do these kind of constructs there

00:34:12,859 --> 00:34:18,829
gonna be some pressure on your stack so

00:34:16,280 --> 00:34:21,290
there are some tricks for example in GCC

00:34:18,829 --> 00:34:23,629
as well as in Incline for example you

00:34:21,290 --> 00:34:28,040
could apply the what I call and call

00:34:23,629 --> 00:34:30,020
optimization so what that means is if

00:34:28,040 --> 00:34:33,169
you have a function and you call another

00:34:30,020 --> 00:34:36,020
function in there right and it has no

00:34:33,169 --> 00:34:37,879
dependencies which means that you are

00:34:36,020 --> 00:34:41,419
not post-processing the output of that

00:34:37,879 --> 00:34:46,609
function when it returns then what

00:34:41,419 --> 00:34:49,280
compiler can do as it is in this code it

00:34:46,609 --> 00:34:51,349
would go going to foo go into bar and

00:34:49,280 --> 00:34:54,230
straight away return from bar back to

00:34:51,349 --> 00:34:57,710
the color of foo what that means is you

00:34:54,230 --> 00:35:01,250
are avoiding some of stacks and that it

00:34:57,710 --> 00:35:03,470
will otherwise end up using for bar so

00:35:01,250 --> 00:35:05,540
there are these kind of cool

00:35:03,470 --> 00:35:08,990
optimizations that you can help compiler

00:35:05,540 --> 00:35:11,240
with with by writing the code such that

00:35:08,990 --> 00:35:15,760
you know it's it could be classified

00:35:11,240 --> 00:35:15,760
into n call optimizations for example

00:35:17,370 --> 00:35:26,950
so if else right so most of our code is

00:35:22,710 --> 00:35:31,240
there if I'll spread everywhere so put

00:35:26,950 --> 00:35:33,940
most likely code that you have in you

00:35:31,240 --> 00:35:37,960
know heart path so if you have like a

00:35:33,940 --> 00:35:39,970
failsafe they'll sit right make sure

00:35:37,960 --> 00:35:41,980
that the most likely code is on the top

00:35:39,970 --> 00:35:44,860
right so you are avoiding few checks

00:35:41,980 --> 00:35:46,750
down there and it's only in the rare

00:35:44,860 --> 00:35:50,470
conditions that it'll have to do those

00:35:46,750 --> 00:35:52,690
most number of checks so how do you get

00:35:50,470 --> 00:35:55,300
that information right so you have to do

00:35:52,690 --> 00:35:59,140
some profiling how your application is

00:35:55,300 --> 00:36:02,500
behaving collect some profile guided

00:35:59,140 --> 00:36:05,820
optimization data and that will showcase

00:36:02,500 --> 00:36:11,950
that yes this is your heart path and

00:36:05,820 --> 00:36:14,470
rearrange your code that way so

00:36:11,950 --> 00:36:17,020
compilers optimize switch cases really

00:36:14,470 --> 00:36:21,010
well so if you have like simple

00:36:17,020 --> 00:36:24,130
conditions try to convert that into

00:36:21,010 --> 00:36:26,730
switch cases compilers do that too by

00:36:24,130 --> 00:36:29,530
the way when you write a simple

00:36:26,730 --> 00:36:32,440
conditions internally it will translate

00:36:29,530 --> 00:36:34,800
that into a switch case if it can but if

00:36:32,440 --> 00:36:37,210
you do that yourself you know the code

00:36:34,800 --> 00:36:42,760
compiler doesn't have to do the work for

00:36:37,210 --> 00:36:44,800
you and remember that compiler is it has

00:36:42,760 --> 00:36:47,080
to be very pessimistic and very

00:36:44,800 --> 00:36:49,120
conservative so if it thinks that it

00:36:47,080 --> 00:36:53,680
can't do the right thing it will drop

00:36:49,120 --> 00:36:56,320
that optimization right it'll move on so

00:36:53,680 --> 00:37:00,670
any hints you give basically arms

00:36:56,320 --> 00:37:04,510
compiler to optimize your code better so

00:37:00,670 --> 00:37:08,410
I the tail call and the tail called

00:37:04,510 --> 00:37:10,420
recursion elimination right so that

00:37:08,410 --> 00:37:14,170
those kind of things will help you to

00:37:10,420 --> 00:37:19,600
avoid as I discussed a bit earlier to

00:37:14,170 --> 00:37:23,110
generate better code so tale called

00:37:19,600 --> 00:37:26,500
recursion is interesting right so for

00:37:23,110 --> 00:37:28,390
example is a factorial function what

00:37:26,500 --> 00:37:31,059
you're doing in the first case

00:37:28,390 --> 00:37:32,799
is you're processing the output right so

00:37:31,059 --> 00:37:35,890
you're calling factorial and you're

00:37:32,799 --> 00:37:38,230
multiplying it with X so it will

00:37:35,890 --> 00:37:40,619
basically go it will not be able to do

00:37:38,230 --> 00:37:43,839
the tail called recursion optimizations

00:37:40,619 --> 00:37:45,789
but what you do in the second case is

00:37:43,839 --> 00:37:48,460
you are basically returning the same

00:37:45,789 --> 00:37:51,880
function you are not manipulating the

00:37:48,460 --> 00:37:53,529
return value so as a result it will be

00:37:51,880 --> 00:37:54,940
able to apply the tail called recursion

00:37:53,529 --> 00:37:59,230
function to this you know the

00:37:54,940 --> 00:38:01,359
optimization we talked about and so this

00:37:59,230 --> 00:38:03,460
code will be much much faster than what

00:38:01,359 --> 00:38:06,490
you would do in the code block right so

00:38:03,460 --> 00:38:12,640
these are simple transformations that

00:38:06,490 --> 00:38:15,430
can help the compiler so in summary help

00:38:12,640 --> 00:38:22,029
the compiler and it will help you write

00:38:15,430 --> 00:38:27,490
so the reason is compiler as I said has

00:38:22,029 --> 00:38:30,400
to be very conservative and it cannot if

00:38:27,490 --> 00:38:33,069
it finds out that there is optimization

00:38:30,400 --> 00:38:35,440
it cannot apply it will not write and

00:38:33,069 --> 00:38:38,349
also remember that it has certain amount

00:38:35,440 --> 00:38:40,329
of time so it cannot compile forever

00:38:38,349 --> 00:38:43,240
otherwise you will complain about slow

00:38:40,329 --> 00:38:46,630
compilation right so it is under the

00:38:43,240 --> 00:38:49,089
conditions that it is operating under if

00:38:46,630 --> 00:38:53,069
an optimization turns out to be very

00:38:49,089 --> 00:38:53,069
expensive it's going to drop that

00:38:53,789 --> 00:39:00,400
do-while is better than for loops

00:38:57,000 --> 00:39:03,099
because the termination of the loop test

00:39:00,400 --> 00:39:04,750
is not used so if you look into like

00:39:03,099 --> 00:39:07,359
Linux kernel code or you know in

00:39:04,750 --> 00:39:09,640
generally in any other well-established

00:39:07,359 --> 00:39:12,309
code bases you will see that they use a

00:39:09,640 --> 00:39:15,339
lot of do vowels in fact their macros to

00:39:12,309 --> 00:39:18,759
basically write those loops using do

00:39:15,339 --> 00:39:24,009
vials they don't even let you decide on

00:39:18,759 --> 00:39:27,640
that and we talked about the pragmas

00:39:24,009 --> 00:39:30,210
you know the function attributes so

00:39:27,640 --> 00:39:32,740
annotate your code in many cases

00:39:30,210 --> 00:39:37,569
compiler may not be able to detect that

00:39:32,740 --> 00:39:39,819
this code can be vectorized right and if

00:39:37,569 --> 00:39:41,750
you tell it that you know this

00:39:39,819 --> 00:39:45,140
particular piece of code is

00:39:41,750 --> 00:39:48,290
risible with a pragma that's a hint and

00:39:45,140 --> 00:39:51,080
compiler will basically try harder on

00:39:48,290 --> 00:39:53,320
that particular piece of code or you

00:39:51,080 --> 00:39:59,480
know subsection you know function so

00:39:53,320 --> 00:40:01,910
annotate your code and using t6 when

00:39:59,480 --> 00:40:05,450
possible right so compiler does provide

00:40:01,910 --> 00:40:09,410
a lot of intrinsic and there is there

00:40:05,450 --> 00:40:14,570
documented well documented go for it you

00:40:09,410 --> 00:40:16,340
know have them use as much as you can

00:40:14,570 --> 00:40:19,150
instead of writing your own functions

00:40:16,340 --> 00:40:22,390
basically to do you know the normal

00:40:19,150 --> 00:40:26,590
manipulations they do provide more

00:40:22,390 --> 00:40:26,590
optimized versions of those for you

00:40:26,740 --> 00:40:34,430
avoid release and debug modes right

00:40:30,310 --> 00:40:35,720
many times this is very common where you

00:40:34,430 --> 00:40:37,610
know you use different optimization

00:40:35,720 --> 00:40:39,260
level when you are developing and then

00:40:37,610 --> 00:40:41,450
you use a different optimization level

00:40:39,260 --> 00:40:44,030
when you're releasing your code it's not

00:40:41,450 --> 00:40:47,960
a good idea if you want to debug the

00:40:44,030 --> 00:40:50,390
same code that is in the field so choose

00:40:47,960 --> 00:40:54,260
a good option set that you can debug and

00:40:50,390 --> 00:40:55,790
you can deploy but you know having these

00:40:54,260 --> 00:40:59,960
two different streams will basically

00:40:55,790 --> 00:41:02,690
give you a lot of trouble and we talked

00:40:59,960 --> 00:41:04,760
about know your system right processor

00:41:02,690 --> 00:41:08,860
architecture what kind of bus built it

00:41:04,760 --> 00:41:11,510
has DRAM right how big RAM you have

00:41:08,860 --> 00:41:14,510
flash what kind of flash you have you

00:41:11,510 --> 00:41:19,340
know your clock speeds this will help

00:41:14,510 --> 00:41:23,120
you to again design your your system

00:41:19,340 --> 00:41:25,550
well profile before optimizing right so

00:41:23,120 --> 00:41:27,800
many times you look at ok my program is

00:41:25,550 --> 00:41:30,940
running slow I think I know where it is

00:41:27,800 --> 00:41:34,190
slow most of the time you are wrong

00:41:30,940 --> 00:41:37,850
profile it before you optimize very very

00:41:34,190 --> 00:41:40,040
important profile it use like you know G

00:41:37,850 --> 00:41:43,460
Pro for some other providers out there

00:41:40,040 --> 00:41:46,930
and find your top ten right and then go

00:41:43,460 --> 00:41:53,930
with it because most of the time loads

00:41:46,930 --> 00:41:56,510
you know it depends on those two that

00:41:53,930 --> 00:41:58,400
two tools right we talked about that use

00:41:56,510 --> 00:41:59,180
tools as much as possible delegate to

00:41:58,400 --> 00:42:05,090
the compiler

00:41:59,180 --> 00:42:10,250
don't try to or stop it and inline

00:42:05,090 --> 00:42:12,170
assembly is is nice but it's quite it

00:42:10,250 --> 00:42:14,030
can be problematic when you have

00:42:12,170 --> 00:42:16,550
different compilers port abilities is

00:42:14,030 --> 00:42:20,920
always an option that you want to

00:42:16,550 --> 00:42:24,890
consider so use it's you know with

00:42:20,920 --> 00:42:27,590
judiciously I would say so I think with

00:42:24,890 --> 00:42:30,650
that that's pretty much I had thank you

00:42:27,590 --> 00:42:32,660
very much any questions any comments we

00:42:30,650 --> 00:42:36,430
still have a few minutes a couple of

00:42:32,660 --> 00:42:36,430
minutes yes

00:42:56,190 --> 00:43:02,380
yes so what a good question question is

00:42:59,350 --> 00:43:04,120
that you know when we optimize for

00:43:02,380 --> 00:43:06,750
different compilers portability and

00:43:04,120 --> 00:43:09,070
optimization optimizations are always

00:43:06,750 --> 00:43:13,270
two different ends of the game and

00:43:09,070 --> 00:43:15,670
that's very true so what you could do is

00:43:13,270 --> 00:43:19,030
you know that you could you do have

00:43:15,670 --> 00:43:21,340
compiler defines right so you can use

00:43:19,030 --> 00:43:23,530
the compiler defines to do compiler

00:43:21,340 --> 00:43:25,840
specific pieces that optimizes your code

00:43:23,530 --> 00:43:30,040
but doesn't affect the portability of

00:43:25,840 --> 00:43:34,450
your code so so that's a compromise that

00:43:30,040 --> 00:43:36,430
you can have between those and there are

00:43:34,450 --> 00:43:38,260
ways that we talked about initially

00:43:36,430 --> 00:43:40,030
where you know I didn't mention whether

00:43:38,260 --> 00:43:42,970
one compiler will do better than others

00:43:40,030 --> 00:43:45,150
so those are common constructs that will

00:43:42,970 --> 00:43:47,530
help you across all kind of compilers

00:43:45,150 --> 00:43:49,600
but then there are certain pieces that

00:43:47,530 --> 00:43:52,120
will give you the extra buck for your

00:43:49,600 --> 00:43:55,150
money but at the cost of up you know

00:43:52,120 --> 00:43:57,130
portability so but there are still some

00:43:55,150 --> 00:44:01,030
ways for you to manage that even though

00:43:57,130 --> 00:44:05,160
you are to added additional code okay

00:44:01,030 --> 00:44:05,160
any further question yeah

00:44:30,160 --> 00:44:35,839
yeah yes yes so I think you could run

00:44:33,619 --> 00:44:38,570
you can compile for all our files

00:44:35,839 --> 00:44:52,010
basically there is like bitbake - case

00:44:38,570 --> 00:44:53,930
which right in there similar yeah that's

00:44:52,010 --> 00:44:56,349
in the make file so you can set it in

00:44:53,930 --> 00:44:59,210
the make files it's not a compiler

00:44:56,349 --> 00:45:02,660
option to say because compiler only sees

00:44:59,210 --> 00:45:05,540
one file so it will error on that or it

00:45:02,660 --> 00:45:07,849
will be compiled successfully but if

00:45:05,540 --> 00:45:09,980
you're compiling is sick yeah if you're

00:45:07,849 --> 00:45:11,780
compiling a sequence of files then you

00:45:09,980 --> 00:45:14,990
have to tell your make system to say

00:45:11,780 --> 00:45:20,180
keep going yes so there are switches for

00:45:14,990 --> 00:45:21,400
me and others have to yeah okay thank

00:45:20,180 --> 00:45:26,769
you very much

00:45:21,400 --> 00:45:26,769

YouTube URL: https://www.youtube.com/watch?v=ITW4eYGA-i4


