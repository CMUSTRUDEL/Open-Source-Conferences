Title: Monsters, Ghosts, and Bugs: How to Choose a Kernel - Laura Abbott, Red Hat
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	Monsters, Ghosts, and Bugs: How to Choose a Kernel - Laura Abbott, Red Hat

Most users and developers donâ€™t think too closely about what kernel is running, yet the kernel is a vital piece of software. There are many choices of what kernel to run, from a well-tested enterprise kernel to forward-looking community distributions to running your own compiled version. Each of these options has a use case and the choice of the kernel can have a big impact on your system. So how do you choose? The focus of this talk is the many ways a kernel can be maintained and what it means for consumers of that kernel. Emphasis will be given to the trade-offs of features vs. security vs. ease of management and mistakes you can make when maintaining a kernel.
Captions: 
	00:00:00,030 --> 00:00:04,350
okay this apparently starts now I

00:00:01,439 --> 00:00:05,879
thought it started at 35 but I'll go

00:00:04,350 --> 00:00:08,730
ahead and get started welcome everyone

00:00:05,879 --> 00:00:10,920
this is monsters ghosts in bugs so quick

00:00:08,730 --> 00:00:12,019
poll the room who here has built their

00:00:10,920 --> 00:00:14,370
own Colonel before

00:00:12,019 --> 00:00:18,210
who here has crashed their own colonel

00:00:14,370 --> 00:00:20,279
before okay excellent okay for a

00:00:18,210 --> 00:00:23,580
slightly more getting us into the mood

00:00:20,279 --> 00:00:26,039
of this talk think of a system you have

00:00:23,580 --> 00:00:29,490
any system maybe your laptop maybe a

00:00:26,039 --> 00:00:32,250
machine and ask yourself what kernel is

00:00:29,490 --> 00:00:34,730
running on your system do you know what

00:00:32,250 --> 00:00:37,649
kernel is running on your system and

00:00:34,730 --> 00:00:39,600
then ask yourself if you know why are

00:00:37,649 --> 00:00:42,149
you running that kernel did you make a

00:00:39,600 --> 00:00:44,190
deliberate choice to run that kernel or

00:00:42,149 --> 00:00:46,980
because perhaps you couldn't choose what

00:00:44,190 --> 00:00:48,920
kernel you are or did you just kind of

00:00:46,980 --> 00:00:52,590
use it because it came with your system

00:00:48,920 --> 00:00:54,539
and I titled this talk monsters go some

00:00:52,590 --> 00:00:57,690
bugs because okay it was pretty catchy

00:00:54,539 --> 00:00:59,699
but the idea behind this talk is to get

00:00:57,690 --> 00:01:01,739
you thinking about how different kernels

00:00:59,699 --> 00:01:04,409
are maintains and what impact that could

00:01:01,739 --> 00:01:07,380
have for you and what drives how these

00:01:04,409 --> 00:01:09,390
kernels are maintained kernels are

00:01:07,380 --> 00:01:11,880
always going to have bugs obviously like

00:01:09,390 --> 00:01:13,260
all software and ultimately your game

00:01:11,880 --> 00:01:14,930
you need to have a plan about how to

00:01:13,260 --> 00:01:16,950
deal those as a consumer of kernels

00:01:14,930 --> 00:01:20,040
sometimes you're gonna get spooky ghost

00:01:16,950 --> 00:01:21,330
like Specter in meltdown and you'll need

00:01:20,040 --> 00:01:23,250
to do is deal with those in a different

00:01:21,330 --> 00:01:25,560
way and then I'm also going to spend

00:01:23,250 --> 00:01:28,229
some time talking about monster kernels

00:01:25,560 --> 00:01:29,939
that sometimes get a bad reputation but

00:01:28,229 --> 00:01:33,930
do also have some good reasons for

00:01:29,939 --> 00:01:35,460
existing the first thing I'm gonna talk

00:01:33,930 --> 00:01:37,890
about is how the upstream kernel

00:01:35,460 --> 00:01:40,640
community releases a kernel simply

00:01:37,890 --> 00:01:43,829
because it turns out that how the

00:01:40,640 --> 00:01:45,899
upstream kernel releases a kernel has an

00:01:43,829 --> 00:01:47,970
impact on how distributions may choose

00:01:45,899 --> 00:01:49,619
to release their own kernel you've

00:01:47,970 --> 00:01:51,200
probably seen this in other talks if

00:01:49,619 --> 00:01:53,840
you've seen Greg talk about it before

00:01:51,200 --> 00:01:56,009
but this is my take on the entire thing

00:01:53,840 --> 00:01:58,439
if you've ever seen a report from the

00:01:56,009 --> 00:02:00,540
Linux Foundation or lwn the usual line

00:01:58,439 --> 00:02:03,420
is wow there are so many people working

00:02:00,540 --> 00:02:05,130
on the kernel every version and this is

00:02:03,420 --> 00:02:08,610
true there are lots of new contributors

00:02:05,130 --> 00:02:10,170
and B patches each time when the kernel

00:02:08,610 --> 00:02:12,170
is always released on a fairly regular

00:02:10,170 --> 00:02:13,970
schedule

00:02:12,170 --> 00:02:16,430
this is the extent of my graphic skills

00:02:13,970 --> 00:02:18,319
this is a rough diagram representing the

00:02:16,430 --> 00:02:21,050
kernel cycle that's happening right now

00:02:18,319 --> 00:02:23,690
all the way in the left you have the 5.2

00:02:21,050 --> 00:02:26,360
kernel which came out early July and all

00:02:23,690 --> 00:02:28,040
the way on the right is 5.3 and each of

00:02:26,360 --> 00:02:31,430
these blocks represents a week of time

00:02:28,040 --> 00:02:33,410
we're somewhere around rc5 right about

00:02:31,430 --> 00:02:36,800
now and if all goes according to plan

00:02:33,410 --> 00:02:38,900
5.3 will be released after rc7 somewhere

00:02:36,800 --> 00:02:41,239
around the middle of September how do we

00:02:38,900 --> 00:02:43,250
know this is a schedule mostly because

00:02:41,239 --> 00:02:44,750
this is what limit has happened the

00:02:43,250 --> 00:02:46,269
previous kernels and there's no reason

00:02:44,750 --> 00:02:49,400
to believe this is going to change

00:02:46,269 --> 00:02:51,200
ultimately linear store Torvald still

00:02:49,400 --> 00:02:54,860
set the release schedule and this is the

00:02:51,200 --> 00:02:56,390
schedule he's chosen to pick and the

00:02:54,860 --> 00:02:58,100
schedule is so predictable you can

00:02:56,390 --> 00:03:00,049
probably guess when the next kernels are

00:02:58,100 --> 00:03:03,260
going to be released this is a website

00:03:00,049 --> 00:03:04,700
that someone's put together that is a

00:03:03,260 --> 00:03:06,769
little bit tongue-in-cheek with the name

00:03:04,700 --> 00:03:08,569
but it's really handy because it shows

00:03:06,769 --> 00:03:10,819
you when the past Chrome's release and

00:03:08,569 --> 00:03:14,030
also gives an estimate about when future

00:03:10,819 --> 00:03:15,440
kernels are going to be released but I

00:03:14,030 --> 00:03:17,480
always say rough idea when using

00:03:15,440 --> 00:03:20,180
schedule like this because things can

00:03:17,480 --> 00:03:22,880
change the diagram I gave only had 7

00:03:20,180 --> 00:03:24,709
release candidates these days we also

00:03:22,880 --> 00:03:27,019
seem to be getting a lot of more kernels

00:03:24,709 --> 00:03:28,489
but heaven 8 release candidates and then

00:03:27,019 --> 00:03:29,540
around the time specter and meltdown

00:03:28,489 --> 00:03:31,579
happened we ended up with a ninth

00:03:29,540 --> 00:03:33,140
release candidate if you're trying to

00:03:31,579 --> 00:03:34,989
play in kernel releases down to the day

00:03:33,140 --> 00:03:37,519
you're probably going to have a bad time

00:03:34,989 --> 00:03:39,320
the kernel community isn't interested in

00:03:37,519 --> 00:03:41,900
guaranteeing releases at a particular

00:03:39,320 --> 00:03:45,410
date but the releases do happen on a

00:03:41,900 --> 00:03:47,239
remarkably cyclic basis ok so the first

00:03:45,410 --> 00:03:49,820
part of the kernel release cycle is the

00:03:47,239 --> 00:03:51,560
merge window after one kernel is

00:03:49,820 --> 00:03:54,320
released the merge window for the next

00:03:51,560 --> 00:03:55,880
kernel opens up as the name implies this

00:03:54,320 --> 00:03:57,859
is when everything is getting get merged

00:03:55,880 --> 00:04:01,310
together this time period usually lasts

00:03:57,859 --> 00:04:03,319
about two weeks this is a busy time for

00:04:01,310 --> 00:04:05,030
kernel maintain errs kernel maintainers

00:04:03,319 --> 00:04:07,400
are going to be doing preparation of

00:04:05,030 --> 00:04:09,049
agat tree to be pulled by Linus and

00:04:07,400 --> 00:04:11,720
maybe also accepting pull requests

00:04:09,049 --> 00:04:13,670
themselves but many maintainer x' don't

00:04:11,720 --> 00:04:15,380
actually submit to lineage directly

00:04:13,670 --> 00:04:17,690
their pull requests will end up in his

00:04:15,380 --> 00:04:19,250
tree indirectly through someone else but

00:04:17,690 --> 00:04:20,330
all the trees will eventually make it to

00:04:19,250 --> 00:04:22,310
witnesses branch

00:04:20,330 --> 00:04:23,780
even if indirectly but this is an

00:04:22,310 --> 00:04:24,750
important point for two reasons

00:04:23,780 --> 00:04:26,400
one that occur

00:04:24,750 --> 00:04:29,300
hatch is not considered fully accepted

00:04:26,400 --> 00:04:32,010
until it's actually a ministry and to

00:04:29,300 --> 00:04:35,120
that all kernel releases are also

00:04:32,010 --> 00:04:37,740
happening off of witnesses master branch

00:04:35,120 --> 00:04:39,000
during this merge window a lot of

00:04:37,740 --> 00:04:41,250
maintained errs will not actually be

00:04:39,000 --> 00:04:43,080
reviewing patches if you try and email

00:04:41,250 --> 00:04:45,030
Gregg k-8 to pet this time for example

00:04:43,080 --> 00:04:46,980
he'll has an autoresponder that says

00:04:45,030 --> 00:04:48,840
please contact me after the merge window

00:04:46,980 --> 00:04:52,860
simply because it's too much volume

00:04:48,840 --> 00:04:55,550
otherwise before a feature lands in

00:04:52,860 --> 00:04:57,510
ministry it's usually expected that

00:04:55,550 --> 00:05:00,150
developers have done some degree of

00:04:57,510 --> 00:05:01,800
testing sometimes more than others but

00:05:00,150 --> 00:05:03,360
once it gets pulled into the limb assist

00:05:01,800 --> 00:05:05,400
tree it's gonna get testing from a much

00:05:03,360 --> 00:05:07,380
wider audience simply because it's got a

00:05:05,400 --> 00:05:09,270
whole new set of hardware and new people

00:05:07,380 --> 00:05:11,190
to test on and you're gonna find that

00:05:09,270 --> 00:05:12,900
the merge window is where most of the

00:05:11,190 --> 00:05:14,370
bugs are going to occur and introduced

00:05:12,900 --> 00:05:16,830
simply because this is where most

00:05:14,370 --> 00:05:19,020
commits are coming in the kernel is

00:05:16,830 --> 00:05:20,850
still mostly usable at this point and

00:05:19,020 --> 00:05:22,650
it's still very important to continue to

00:05:20,850 --> 00:05:24,390
be testing and using it this time simply

00:05:22,650 --> 00:05:28,320
to continue to try and find in possibly

00:05:24,390 --> 00:05:30,840
fix bugs eventually all good things come

00:05:28,320 --> 00:05:33,330
to an end and after two weeks the merge

00:05:30,840 --> 00:05:36,270
widow closes and lettuce releases rc1

00:05:33,330 --> 00:05:38,130
off this master branch but if news is at

00:05:36,270 --> 00:05:40,020
this point things usually start slowing

00:05:38,130 --> 00:05:42,660
down a lot new features are going to

00:05:40,020 --> 00:05:45,240
stop coming in except when maybe a

00:05:42,660 --> 00:05:47,729
feature does try and come in sometimes

00:05:45,240 --> 00:05:49,890
features can come in after rc1 but in

00:05:47,729 --> 00:05:51,990
general the bigger the feature the more

00:05:49,890 --> 00:05:53,570
unhappy Lennis is going to be and the

00:05:51,990 --> 00:05:55,919
more likely is to reject a pull request

00:05:53,570 --> 00:05:57,360
there's a schedule to the kernel and the

00:05:55,919 --> 00:05:59,640
schedule is that new features need to

00:05:57,360 --> 00:06:01,200
come in during the merge window but in

00:05:59,640 --> 00:06:03,660
general by this time most the new

00:06:01,200 --> 00:06:04,470
features are in because it's time to

00:06:03,660 --> 00:06:06,510
continue testing

00:06:04,470 --> 00:06:08,520
I mentioned that bugs are often

00:06:06,510 --> 00:06:10,710
introduced and perhaps fixed during the

00:06:08,520 --> 00:06:13,770
merge window these may be the simpler

00:06:10,710 --> 00:06:15,660
bugs because other bugs may have gone

00:06:13,770 --> 00:06:17,250
unsolved or just a notice simply because

00:06:15,660 --> 00:06:19,710
they hadn't gotten enough testing and

00:06:17,250 --> 00:06:22,530
this is the point of the RC cycle is to

00:06:19,710 --> 00:06:24,300
try and find and fix bugs if you see

00:06:22,530 --> 00:06:25,890
patches that are being sent now they are

00:06:24,300 --> 00:06:30,270
oftentimes patches for the current

00:06:25,890 --> 00:06:32,760
kernel but the Garcias especially later

00:06:30,270 --> 00:06:34,190
in the RCT cycle this is also the time

00:06:32,760 --> 00:06:36,090
to start looking towards the next kernel

00:06:34,190 --> 00:06:37,440
maintainer x' will start to do more

00:06:36,090 --> 00:06:39,480
patch review at

00:06:37,440 --> 00:06:41,130
the marriage window but for Petrus that

00:06:39,480 --> 00:06:43,320
are sent now unless they're fixing new

00:06:41,130 --> 00:06:45,480
or major regressions patches will be

00:06:43,320 --> 00:06:47,310
queued up for the next colonel so for

00:06:45,480 --> 00:06:51,690
example a patch that sent now will be

00:06:47,310 --> 00:06:53,940
queued up for 5.4 it's I've mentioned

00:06:51,690 --> 00:06:55,560
several times that Linux will often

00:06:53,940 --> 00:06:57,270
reject polar requests and maintainer x'

00:06:55,560 --> 00:06:59,220
will reject patches for the current

00:06:57,270 --> 00:07:01,440
window if you try and send them at the

00:06:59,220 --> 00:07:03,750
wrong time and this is because trying to

00:07:01,440 --> 00:07:05,580
get a maintainer to take patches off

00:07:03,750 --> 00:07:07,800
cycle it doesn't end well for anyone

00:07:05,580 --> 00:07:09,120
simply because if you try and get a

00:07:07,800 --> 00:07:12,210
maintainer to take something that's not

00:07:09,120 --> 00:07:13,680
ready it's going to introduce possible

00:07:12,210 --> 00:07:16,110
stability regressions across the entire

00:07:13,680 --> 00:07:18,420
kernel grain gave a talk a few years ago

00:07:16,110 --> 00:07:20,160
called I don't want your code kind of a

00:07:18,420 --> 00:07:21,900
Hersh team but in it he tells a good

00:07:20,160 --> 00:07:23,610
story about a time that he tried to take

00:07:21,900 --> 00:07:25,860
a patch before it was ready and the

00:07:23,610 --> 00:07:27,240
consequences the calls so there's a good

00:07:25,860 --> 00:07:28,620
reason for maintainer x' being pretty

00:07:27,240 --> 00:07:32,460
stick as strict about when they take

00:07:28,620 --> 00:07:34,650
patches eventually a week passes in

00:07:32,460 --> 00:07:37,920
another are see happens the procedure

00:07:34,650 --> 00:07:39,180
for HRC is the same for each week but

00:07:37,920 --> 00:07:41,130
the expectation is that the number of

00:07:39,180 --> 00:07:42,690
patch is going into each RC should be

00:07:41,130 --> 00:07:45,390
getting smaller since only bug fixes

00:07:42,690 --> 00:07:47,490
should be coming in sometimes it goes

00:07:45,390 --> 00:07:49,560
faster than others sometimes our C's get

00:07:47,490 --> 00:07:52,020
bigger which nobody likes but time

00:07:49,560 --> 00:07:53,610
passes and eventually when it's decides

00:07:52,020 --> 00:07:56,010
the kernel is stable enough and declares

00:07:53,610 --> 00:08:00,060
a release and everyone is super excited

00:07:56,010 --> 00:08:01,919
once again okay so a brand new kernel

00:08:00,060 --> 00:08:03,240
has come out this means it's immediately

00:08:01,919 --> 00:08:07,500
time to go and start putting it on all

00:08:03,240 --> 00:08:09,240
your systems right maybe not just

00:08:07,500 --> 00:08:12,060
because a major kernel has been released

00:08:09,240 --> 00:08:13,320
doesn't mean it's bug free after kernel

00:08:12,060 --> 00:08:15,120
has been released its going to get bug

00:08:13,320 --> 00:08:16,770
fixes for a period of time typically

00:08:15,120 --> 00:08:19,380
until shortly after the next kernel

00:08:16,770 --> 00:08:20,820
version is released so 5.3 is going to

00:08:19,380 --> 00:08:23,310
be released in the middle of September

00:08:20,820 --> 00:08:28,169
and it's gonna get stable updates 5.3

00:08:23,310 --> 00:08:30,120
dot 15.3 duck to 5.3 dot 3 and but they

00:08:28,169 --> 00:08:32,490
won't continue indefinitely they'll

00:08:30,120 --> 00:08:33,120
eventually stop about the time 5.4 is

00:08:32,490 --> 00:08:38,339
released

00:08:33,120 --> 00:08:40,589
I mentioned stable updates as receiving

00:08:38,339 --> 00:08:42,150
bug fixes I mean when I'm using the

00:08:40,589 --> 00:08:44,039
phrase stable update I'm using a very

00:08:42,150 --> 00:08:46,380
particular turn here that's defined for

00:08:44,039 --> 00:08:49,380
the kernel the bug fixes that are going

00:08:46,380 --> 00:08:50,640
to stable updates are a very specific

00:08:49,380 --> 00:08:53,040
set of bug fixes

00:08:50,640 --> 00:08:55,890
they are typically small self-contained

00:08:53,040 --> 00:08:57,329
fixes that are less than 100 lines the

00:08:55,890 --> 00:08:58,829
issues that are fixed must be really

00:08:57,329 --> 00:09:01,320
issues that bothers someone no

00:08:58,829 --> 00:09:03,329
theoretical race conditions and the fix

00:09:01,320 --> 00:09:05,160
must be a ministry all of these

00:09:03,329 --> 00:09:07,589
requirements are designed to hopefully

00:09:05,160 --> 00:09:10,740
improve the stability of the stable

00:09:07,589 --> 00:09:12,570
fixes because not all the fixes are

00:09:10,740 --> 00:09:15,240
actions that are proposed out there are

00:09:12,570 --> 00:09:16,950
actually appropriate for stable the way

00:09:15,240 --> 00:09:19,680
patches end up getting into stable is

00:09:16,950 --> 00:09:21,630
that the patch is tagged with CC stable

00:09:19,680 --> 00:09:23,190
in the commit message sometimes the

00:09:21,630 --> 00:09:25,890
submitter will add this sometimes the

00:09:23,190 --> 00:09:27,779
maintainer will add this but if a patch

00:09:25,890 --> 00:09:30,899
doesn't get added at commit time it's

00:09:27,779 --> 00:09:33,240
okay if you find that a patch is missing

00:09:30,899 --> 00:09:34,769
you can email commit hash juice the

00:09:33,240 --> 00:09:37,320
stable mailing list and it will be

00:09:34,769 --> 00:09:39,390
picked up and when I say you here I mean

00:09:37,320 --> 00:09:41,579
anyone any kernel contributor can do

00:09:39,390 --> 00:09:43,079
this if you found a patch and perhaps

00:09:41,579 --> 00:09:44,790
done a bisect and you notice that it's

00:09:43,079 --> 00:09:46,589
in Len is's tree but not in stables you

00:09:44,790 --> 00:09:50,399
can email the stable maintainer and

00:09:46,589 --> 00:09:53,279
they'll pick it up and then this is a

00:09:50,399 --> 00:09:54,750
page that gives a short description of

00:09:53,279 --> 00:10:00,060
the entire stable process if you want to

00:09:54,750 --> 00:10:05,070
know the entire details okay so this is

00:10:00,060 --> 00:10:06,839
a screenshot I took of kernel.org if you

00:10:05,070 --> 00:10:09,680
notice there were multiple versions here

00:10:06,839 --> 00:10:12,000
that are marked long-term stable or LTS

00:10:09,680 --> 00:10:14,070
these are stable versions that some

00:10:12,000 --> 00:10:17,420
kernel developer often Gregg has decided

00:10:14,070 --> 00:10:17,420
to maintain for a period of time

00:10:17,519 --> 00:10:22,050
Gregg usually picks one kernel version a

00:10:19,529 --> 00:10:23,850
year to be the LTS version sometimes he

00:10:22,050 --> 00:10:25,320
nests it beforehand sometimes he doesn't

00:10:23,850 --> 00:10:27,149
want to because he's found in the past

00:10:25,320 --> 00:10:29,279
but if he announces a particular version

00:10:27,149 --> 00:10:30,420
is going to be an LTS version people try

00:10:29,279 --> 00:10:32,490
and get patches in before they're

00:10:30,420 --> 00:10:34,529
actually ready and again causes more

00:10:32,490 --> 00:10:36,620
stability problems but usually without

00:10:34,529 --> 00:10:40,410
fail once a year you'll get a new LTS

00:10:36,620 --> 00:10:42,329
and I actually had to update this slide

00:10:40,410 --> 00:10:44,610
right as I was working on these because

00:10:42,329 --> 00:10:46,920
Gregg announced that 5.4 is going to be

00:10:44,610 --> 00:10:49,170
the next LTS version so as you can see

00:10:46,920 --> 00:10:51,449
here that there's Gregg maintains a lot

00:10:49,170 --> 00:10:54,449
of the stable versions been Hutchings is

00:10:51,449 --> 00:10:56,790
a maintainer for Debian great person and

00:10:54,449 --> 00:11:00,779
he also maintains the 3.16 stable

00:10:56,790 --> 00:11:02,899
versions but all these stable trees are

00:11:00,779 --> 00:11:04,730
not actually created equal the

00:11:02,899 --> 00:11:07,040
these are intended to be used is is that

00:11:04,730 --> 00:11:08,959
you take the most recent LTS use it for

00:11:07,040 --> 00:11:11,540
one year and then update to the next

00:11:08,959 --> 00:11:13,399
unless you have other reasons older LTS

00:11:11,540 --> 00:11:15,290
releases are typically designed for

00:11:13,399 --> 00:11:18,259
perhaps hardware enablement or other

00:11:15,290 --> 00:11:19,999
very specific use cases which where you

00:11:18,259 --> 00:11:22,279
can't update full logistical reasons and

00:11:19,999 --> 00:11:24,139
in general what you're going to find is

00:11:22,279 --> 00:11:26,389
is that the older LTS releases are

00:11:24,139 --> 00:11:27,920
getting bug fixes but they're also going

00:11:26,389 --> 00:11:29,839
to trail off after a point so they're

00:11:27,920 --> 00:11:34,129
going to be getting just a core set of

00:11:29,839 --> 00:11:36,589
bug fixes okay so that's the story of

00:11:34,129 --> 00:11:38,329
upstream and stables but obviously

00:11:36,589 --> 00:11:40,519
people need to consume these trees in

00:11:38,329 --> 00:11:43,279
some form and the question is is that

00:11:40,519 --> 00:11:46,910
then your distribution what kernel is

00:11:43,279 --> 00:11:48,230
your distribution actually running I did

00:11:46,910 --> 00:11:50,720
some looking line to see exactly what

00:11:48,230 --> 00:11:52,189
various distributions were running this

00:11:50,720 --> 00:11:55,160
is where you can find information about

00:11:52,189 --> 00:11:58,519
the Ubuntu kernels and it's kind of hard

00:11:55,160 --> 00:12:00,199
to capture in one slide but the from the

00:11:58,519 --> 00:12:02,389
from the very detailed schedule they

00:12:00,199 --> 00:12:04,420
have they are using a mixture of LTS

00:12:02,389 --> 00:12:08,870
kernels and their own kernel versions

00:12:04,420 --> 00:12:10,399
and this is a screenshot of arch and if

00:12:08,870 --> 00:12:11,660
you look here is that they're running

00:12:10,399 --> 00:12:14,209
things that are fairly close to the

00:12:11,660 --> 00:12:16,540
stable mainline kernels updating on a

00:12:14,209 --> 00:12:19,309
regular cadence with the monthly stuff

00:12:16,540 --> 00:12:20,629
okay and then when I say distributions

00:12:19,309 --> 00:12:22,339
it's also important to think of

00:12:20,629 --> 00:12:24,800
distributions as things like Android

00:12:22,339 --> 00:12:26,449
which also runs runs at kernel and this

00:12:24,800 --> 00:12:28,939
is a screenshot from Wikipedia showing

00:12:26,449 --> 00:12:32,059
the kernel versions that were used all

00:12:28,939 --> 00:12:33,860
across the time with some of these

00:12:32,059 --> 00:12:35,569
slightly older versions up there and

00:12:33,860 --> 00:12:37,490
I'll talk more about Android in a bit

00:12:35,569 --> 00:12:40,480
and their during and figuring out the

00:12:37,490 --> 00:12:42,980
best way to maintain a kernel and so

00:12:40,480 --> 00:12:44,329
naturally the question is okay we have a

00:12:42,980 --> 00:12:46,309
bunch of distributions they're all

00:12:44,329 --> 00:12:48,350
running things differently why are they

00:12:46,309 --> 00:12:50,329
running these things these kernels the

00:12:48,350 --> 00:12:51,620
way they are and it kind of ends up

00:12:50,329 --> 00:12:53,899
running it on for a trade-off of

00:12:51,620 --> 00:12:55,910
stability versus features if you're

00:12:53,899 --> 00:12:57,559
going to run in a single LTS version for

00:12:55,910 --> 00:12:59,660
the lifespan of the release it's

00:12:57,559 --> 00:13:01,100
probably going to be fairly stable but

00:12:59,660 --> 00:13:04,009
you aren't going to see a whole lot of

00:13:01,100 --> 00:13:05,600
new work since the only commits that are

00:13:04,009 --> 00:13:10,040
going into stable updates are supposed

00:13:05,600 --> 00:13:12,769
to be bug fixes not new features okay

00:13:10,040 --> 00:13:14,600
I am I one of my full-time jobs is

00:13:12,769 --> 00:13:15,510
Fedora kernel maintainer so I'm going to

00:13:14,600 --> 00:13:18,540
talk about

00:13:15,510 --> 00:13:21,120
the Fedora kernel maintains is

00:13:18,540 --> 00:13:22,980
maintained just as an example about why

00:13:21,120 --> 00:13:25,680
a distribution would choose to run

00:13:22,980 --> 00:13:27,720
things in a particular way and the

00:13:25,680 --> 00:13:29,360
Fedora kernel model is to rebase to new

00:13:27,720 --> 00:13:31,500
kernels as soon as they're released

00:13:29,360 --> 00:13:33,090
similar to the arch model so you get a

00:13:31,500 --> 00:13:35,550
release schedule that looks like that

00:13:33,090 --> 00:13:38,460
and this ends up being the easiest for

00:13:35,550 --> 00:13:40,110
the Fedora workflow and also well

00:13:38,460 --> 00:13:43,470
aligned but the foot world philosophy to

00:13:40,110 --> 00:13:44,880
be a leading edge distribution with each

00:13:43,470 --> 00:13:47,600
new kernel version you're going to be

00:13:44,880 --> 00:13:49,790
getting a lot of new things new features

00:13:47,600 --> 00:13:52,170
ok

00:13:49,790 --> 00:13:54,090
everyone's I need to drop some buzzwords

00:13:52,170 --> 00:13:56,130
here cuz they're mandatory containers

00:13:54,090 --> 00:13:59,070
each new kernel version you're going to

00:13:56,130 --> 00:14:00,630
be beginning new new extensions to

00:13:59,070 --> 00:14:05,330
containers to help them run more

00:14:00,630 --> 00:14:09,330
securely and hopefully be better running

00:14:05,330 --> 00:14:11,520
another favorite buzzword EBP f-e BPF is

00:14:09,330 --> 00:14:13,800
a feature that's been extended over the

00:14:11,520 --> 00:14:15,120
years to be able to do new tracing each

00:14:13,800 --> 00:14:17,340
kernel version there's more ways to

00:14:15,120 --> 00:14:19,650
trace you're gonna get new hardware with

00:14:17,340 --> 00:14:20,940
each each release I can go on and on

00:14:19,650 --> 00:14:21,990
about the different things but the point

00:14:20,940 --> 00:14:25,620
is is that you're really getting the

00:14:21,990 --> 00:14:28,470
latest with each new kernel version but

00:14:25,620 --> 00:14:30,480
this also comes at a cost all these new

00:14:28,470 --> 00:14:33,060
features I mentioned sometimes don't

00:14:30,480 --> 00:14:36,690
work or even worse things that used to

00:14:33,060 --> 00:14:39,240
work stopped working a real life story

00:14:36,690 --> 00:14:40,830
from last December there were there

00:14:39,240 --> 00:14:43,920
turns out there was a major regression

00:14:40,830 --> 00:14:46,140
in the block layer that was people

00:14:43,920 --> 00:14:47,610
reporting it as ext4 file system

00:14:46,140 --> 00:14:48,930
correction and there was a lot of

00:14:47,610 --> 00:14:50,820
back-and-forth in terms of trying to

00:14:48,930 --> 00:14:53,400
figure out what the bug was and

00:14:50,820 --> 00:14:54,750
eventually we did a veg the maintainer

00:14:53,400 --> 00:14:56,910
did eventually find the commit that

00:14:54,750 --> 00:14:58,860
fixed the problem but of course this was

00:14:56,910 --> 00:15:00,030
very frustrating for the users who are

00:14:58,860 --> 00:15:01,560
trying to have to narrow down the

00:15:00,030 --> 00:15:02,670
problem and figure out when their file

00:15:01,560 --> 00:15:05,790
systems were to get stopped getting

00:15:02,670 --> 00:15:07,890
corrupted most issues you see aren't

00:15:05,790 --> 00:15:09,990
going to be that dramatic but this is

00:15:07,890 --> 00:15:12,480
kind of the point about updating kernels

00:15:09,990 --> 00:15:15,060
is is that how much risk do you want to

00:15:12,480 --> 00:15:17,250
put on the users in terms of giving them

00:15:15,060 --> 00:15:20,580
new features but perhaps have them

00:15:17,250 --> 00:15:22,320
potentially heaven have an issue for

00:15:20,580 --> 00:15:24,300
something project like Fedora

00:15:22,320 --> 00:15:25,920
or users expect that they may

00:15:24,300 --> 00:15:27,670
occasionally see a bug hopefully not

00:15:25,920 --> 00:15:29,140
file system corruption but

00:15:27,670 --> 00:15:33,690
but some bugs and they'll have to work

00:15:29,140 --> 00:15:33,690
with us to report bugs to get them fixed

00:15:33,990 --> 00:15:38,380
so again this means that if you say

00:15:36,550 --> 00:15:40,570
choose to run an LTS kernel and not

00:15:38,380 --> 00:15:43,240
update to a full new version you're not

00:15:40,570 --> 00:15:45,460
gonna see news graphics drivers or

00:15:43,240 --> 00:15:46,990
container features but hopefully you're

00:15:45,460 --> 00:15:49,870
not gonna see a file system corruption

00:15:46,990 --> 00:15:52,000
either and again if your goal is

00:15:49,870 --> 00:15:54,670
deployment on a known set of hardware

00:15:52,000 --> 00:15:57,420
and you're not really touching it a

00:15:54,670 --> 00:16:01,210
whole lot this is probably what you need

00:15:57,420 --> 00:16:03,850
okay it's been some time talking about

00:16:01,210 --> 00:16:05,830
the upstream LTS kernels but it turns

00:16:03,850 --> 00:16:08,200
out there are a lot of distributions out

00:16:05,830 --> 00:16:10,300
there that aren't gonna use the LTS

00:16:08,200 --> 00:16:12,490
kernels and tend to do something that

00:16:10,300 --> 00:16:16,480
kind of looks like an LTS kernel but

00:16:12,490 --> 00:16:18,430
Falls a different schedule hey I am a

00:16:16,480 --> 00:16:21,490
Bloggie obligated to talk about my

00:16:18,430 --> 00:16:23,380
employer here red hat a lot of people

00:16:21,490 --> 00:16:27,100
sometimes like to talk about this is how

00:16:23,380 --> 00:16:29,460
Red Hat maintains the enterprise kernels

00:16:27,100 --> 00:16:32,170
for the Red Hat Enterprise Linux and

00:16:29,460 --> 00:16:34,930
they've kind of given them this nickname

00:16:32,170 --> 00:16:36,790
of Franken kernels and because

00:16:34,930 --> 00:16:39,070
especially from the upstream community

00:16:36,790 --> 00:16:42,760
perspective they really do look pretty

00:16:39,070 --> 00:16:45,550
scary these kernels tend to pick up

00:16:42,760 --> 00:16:47,830
individual patches and backport specific

00:16:45,550 --> 00:16:50,500
features rather than say taking staple

00:16:47,830 --> 00:16:53,110
updates and the reason they gets a bad

00:16:50,500 --> 00:16:55,300
rep and gets these bad reputations is

00:16:53,110 --> 00:16:56,980
because from the upstream perspective

00:16:55,300 --> 00:17:00,940
you don't know exactly what's in these

00:16:56,980 --> 00:17:02,620
the kernel version maybe say 4.4 but you

00:17:00,940 --> 00:17:06,420
have no idea what's in them there may be

00:17:02,620 --> 00:17:08,740
some bug fixes but not others yeah

00:17:06,420 --> 00:17:11,380
sometime last year red had announced

00:17:08,740 --> 00:17:13,690
that EB PF was going to be back ported

00:17:11,380 --> 00:17:15,430
into its kernel which brought a lot of

00:17:13,690 --> 00:17:17,950
chuckles and as an example of a feature

00:17:15,430 --> 00:17:22,030
being brought in to a very older kernel

00:17:17,950 --> 00:17:23,470
and another big objection to these

00:17:22,030 --> 00:17:25,870
concur NAL's is the argument is that

00:17:23,470 --> 00:17:28,630
there's a security risk and the argument

00:17:25,870 --> 00:17:30,730
goes by not taking all known fixes you

00:17:28,630 --> 00:17:35,080
potentially have a security hole since

00:17:30,730 --> 00:17:37,000
all issues may be security issues and I

00:17:35,080 --> 00:17:39,250
can't really dispute that if you don't

00:17:37,000 --> 00:17:40,200
have a particular patch or bug you have

00:17:39,250 --> 00:17:43,260
an issue

00:17:40,200 --> 00:17:45,600
but I'm flipping this around to get that

00:17:43,260 --> 00:17:47,070
the suggestion I got from some people

00:17:45,600 --> 00:17:49,889
was to not call these Franklin kernels

00:17:47,070 --> 00:17:51,539
but well curated kernels the point here

00:17:49,889 --> 00:17:53,279
is is that these kernels are maintained

00:17:51,539 --> 00:17:55,529
because there are enough people look at

00:17:53,279 --> 00:17:57,090
it looking at them that they can usually

00:17:55,529 --> 00:17:58,889
figure out if something should or

00:17:57,090 --> 00:18:00,899
shouldn't be included and if it turns

00:17:58,889 --> 00:18:04,710
out maybe something was missed they can

00:18:00,899 --> 00:18:07,110
add it fairly quickly and this

00:18:04,710 --> 00:18:11,130
philosophy is is that it's better to

00:18:07,110 --> 00:18:12,690
only take fixes that are known from a

00:18:11,130 --> 00:18:15,870
known specific set of commits versus

00:18:12,690 --> 00:18:19,500
taking everything simply because that's

00:18:15,870 --> 00:18:21,269
one possible way to reduce risk it also

00:18:19,500 --> 00:18:23,639
turns out these kernels may offer other

00:18:21,269 --> 00:18:26,309
guarantees for say binary compatibility

00:18:23,639 --> 00:18:28,200
and taking stable updates that have

00:18:26,309 --> 00:18:29,940
other commits that haven't been

00:18:28,200 --> 00:18:33,090
validated can help possibly make that

00:18:29,940 --> 00:18:34,710
harder so when you want run one of these

00:18:33,090 --> 00:18:36,330
enterprise kernels you should know

00:18:34,710 --> 00:18:38,700
exactly what you're getting because the

00:18:36,330 --> 00:18:43,139
people have selected exactly what goes

00:18:38,700 --> 00:18:46,169
into them and part of the idea of what

00:18:43,139 --> 00:18:48,570
taking certain fixes is that sometimes

00:18:46,169 --> 00:18:51,539
regressions fix it slip into the stable

00:18:48,570 --> 00:18:53,789
trees there's a famous quote out there

00:18:51,539 --> 00:18:56,610
called related to Lin is's law which is

00:18:53,789 --> 00:18:58,350
that given enough eyes all bugs are

00:18:56,610 --> 00:19:00,330
shallow and this is what the kernel

00:18:58,350 --> 00:19:02,399
community is focused on for many years

00:19:00,330 --> 00:19:06,179
the focus has always been on code review

00:19:02,399 --> 00:19:08,700
to try and find these bugs before they

00:19:06,179 --> 00:19:11,429
get committed but I think the stable

00:19:08,700 --> 00:19:14,309
trees are a good example of where we've

00:19:11,429 --> 00:19:17,820
seen the limits of this process patches

00:19:14,309 --> 00:19:19,320
for the stable trees get CC to the

00:19:17,820 --> 00:19:21,240
mailing list as I explained before and

00:19:19,320 --> 00:19:23,700
the cache is presumed to be accepted

00:19:21,240 --> 00:19:25,529
unless someone objects and then one of

00:19:23,700 --> 00:19:27,419
the issues we've seen is that developers

00:19:25,529 --> 00:19:29,580
don't notice that they're supposed to

00:19:27,419 --> 00:19:31,080
that they don't want the patch included

00:19:29,580 --> 00:19:32,460
or that there are dependencies hasn't

00:19:31,080 --> 00:19:36,149
been missing and that there have been

00:19:32,460 --> 00:19:38,669
problems in the past with this obviously

00:19:36,149 --> 00:19:39,990
nobody wants regressions and I don't

00:19:38,669 --> 00:19:42,630
want anyone to think that this doesn't

00:19:39,990 --> 00:19:44,909
mean the stable trees aren't usable they

00:19:42,630 --> 00:19:47,190
are a fantastic resource and everyone

00:19:44,909 --> 00:19:49,500
does a great job of working on them but

00:19:47,190 --> 00:19:51,600
it goes back to figuring out how exactly

00:19:49,500 --> 00:19:53,350
you're maintaining these and the stable

00:19:51,600 --> 00:19:54,789
community has had to figure out

00:19:53,350 --> 00:19:56,470
what are good ways to be able to

00:19:54,789 --> 00:19:59,440
maintain these trees to get the fixes

00:19:56,470 --> 00:20:01,750
while also reducing regressions and the

00:19:59,440 --> 00:20:04,179
stable trees are I'm not gonna say a

00:20:01,750 --> 00:20:05,950
newer model but if we go back to our big

00:20:04,179 --> 00:20:07,899
scary monster of an enterprise Colonel

00:20:05,950 --> 00:20:09,700
the people working on that have just

00:20:07,899 --> 00:20:11,740
decided that for their particular

00:20:09,700 --> 00:20:14,110
purposes it's easier just to pick up

00:20:11,740 --> 00:20:18,279
individual fixes than to try and say

00:20:14,110 --> 00:20:20,559
guess what's in the stable tree excuse

00:20:18,279 --> 00:20:22,179
me and this does come down to needs the

00:20:20,559 --> 00:20:24,250
people trying to ship one of these

00:20:22,179 --> 00:20:26,649
kernels have needs that don't quite

00:20:24,250 --> 00:20:34,480
match with the upstream LTS kernels so

00:20:26,649 --> 00:20:37,929
they do their own thing I want to talk

00:20:34,480 --> 00:20:40,269
about embedded and Android as a lesson

00:20:37,929 --> 00:20:43,990
learned in dealing with kernels and

00:20:40,269 --> 00:20:46,659
shipping features the emitted Linux had

00:20:43,990 --> 00:20:49,120
kind of reputation for many years of

00:20:46,659 --> 00:20:50,590
shipping very out-of-date kernels with

00:20:49,120 --> 00:20:52,809
patches that had never been reviewed

00:20:50,590 --> 00:20:55,360
upstream and the reasons they did this

00:20:52,809 --> 00:20:57,009
weren't always because they say which

00:20:55,360 --> 00:20:58,870
making the deliberate choice about this

00:20:57,009 --> 00:21:01,169
is how we want to deliver but maybe they

00:20:58,870 --> 00:21:03,549
didn't see a better way to do this and

00:21:01,169 --> 00:21:06,549
part of this had to do with is what the

00:21:03,549 --> 00:21:09,460
embedded system was trying to do for

00:21:06,549 --> 00:21:11,529
shipping a product I just presented the

00:21:09,460 --> 00:21:12,909
timeline about how the kernel is

00:21:11,529 --> 00:21:14,710
released and when patches are going to

00:21:12,909 --> 00:21:17,620
be sent if you think about it from the

00:21:14,710 --> 00:21:19,090
other perspective this means that if you

00:21:17,620 --> 00:21:21,549
want to get things included you need to

00:21:19,090 --> 00:21:23,679
be thinking backwards so let's say you

00:21:21,549 --> 00:21:25,330
want to release a product on date X if

00:21:23,679 --> 00:21:27,909
you go back to the handy dandy chart I

00:21:25,330 --> 00:21:30,250
showed about when kernels are going to

00:21:27,909 --> 00:21:31,929
be released that means a kernel is

00:21:30,250 --> 00:21:33,639
something on date X is probably going to

00:21:31,929 --> 00:21:36,070
have a kernel Y which means you need to

00:21:33,639 --> 00:21:39,460
be thinking about submitting at kernel y

00:21:36,070 --> 00:21:43,389
-1 or Y - to crumble development takes

00:21:39,460 --> 00:21:44,679
time again I talked about how maintain

00:21:43,389 --> 00:21:46,779
ORS don't want to take things off cycle

00:21:44,679 --> 00:21:50,379
because it turns out it will potentially

00:21:46,779 --> 00:21:52,929
cause regressions but if you're a

00:21:50,379 --> 00:21:55,120
company who needs to ship a product you

00:21:52,929 --> 00:21:56,440
can't always work with this you can't

00:21:55,120 --> 00:21:58,210
really go and say sorry we're not

00:21:56,440 --> 00:22:00,129
meeting our holiday deadlines this year

00:21:58,210 --> 00:22:02,860
because somebody didn't like our changes

00:22:00,129 --> 00:22:04,470
to the DNA layer so ultimately this

00:22:02,860 --> 00:22:06,510
means that if you're a company

00:22:04,470 --> 00:22:07,740
who needs to ship something you're just

00:22:06,510 --> 00:22:11,100
going to put your Pat whatever you have

00:22:07,740 --> 00:22:12,870
and ship it out and that was what a lot

00:22:11,100 --> 00:22:15,300
of the embedded world looked like for

00:22:12,870 --> 00:22:18,450
many years some out of tree patches on

00:22:15,300 --> 00:22:20,460
top of a very old kernel obviously in

00:22:18,450 --> 00:22:22,410
many respects it was successful because

00:22:20,460 --> 00:22:24,300
products were getting out but it wasn't

00:22:22,410 --> 00:22:29,220
the best thing to work about work with

00:22:24,300 --> 00:22:32,390
as an engineer or as a consumer and this

00:22:29,220 --> 00:22:35,250
is what Android did in the early days

00:22:32,390 --> 00:22:36,900
the first versions of Android shipped a

00:22:35,250 --> 00:22:39,540
bunch of features which had never built

00:22:36,900 --> 00:22:41,370
really been reviewed upstream Google

00:22:39,540 --> 00:22:44,670
wakelock controversy if you ever want to

00:22:41,370 --> 00:22:46,620
see a very long thread about maintained

00:22:44,670 --> 00:22:47,700
errs trying to figure out what they want

00:22:46,620 --> 00:22:51,300
to do with some of these Android

00:22:47,700 --> 00:22:52,920
features and what Android chose to do in

00:22:51,300 --> 00:22:55,260
terms of shipping a lot of had few code

00:22:52,920 --> 00:22:56,910
was success but it wasn't very

00:22:55,260 --> 00:22:59,430
sustainable from a kernel manias point

00:22:56,910 --> 00:23:03,570
of view but fast forward to today and

00:22:59,430 --> 00:23:05,730
things look better for ant for Android

00:23:03,570 --> 00:23:07,470
even if that a high-level Android is

00:23:05,730 --> 00:23:10,230
still doing the same thing of shipping a

00:23:07,470 --> 00:23:11,550
kernel out of tree patches but it turns

00:23:10,230 --> 00:23:14,190
out this is a secret of all

00:23:11,550 --> 00:23:16,590
distributions most distributions are

00:23:14,190 --> 00:23:18,660
shipped are maybe shipping a few out of

00:23:16,590 --> 00:23:20,280
tree patches minor tweaks to be able to

00:23:18,660 --> 00:23:23,400
do what they want even ones that are

00:23:20,280 --> 00:23:25,290
tracking LTS but what strands for the

00:23:23,400 --> 00:23:27,030
Android community is that they are much

00:23:25,290 --> 00:23:28,650
better at engaging with the upstream

00:23:27,030 --> 00:23:30,260
community they think about their

00:23:28,650 --> 00:23:32,370
features and they try and propose them

00:23:30,260 --> 00:23:34,620
not every feature they want is

00:23:32,370 --> 00:23:37,350
necessarily accepted but they continue

00:23:34,620 --> 00:23:38,220
to work with the communities and try and

00:23:37,350 --> 00:23:42,480
find solutions

00:23:38,220 --> 00:23:44,520
I mentioned Android here as a also a

00:23:42,480 --> 00:23:46,530
heavy consumer of the LTS trees they've

00:23:44,520 --> 00:23:48,270
learned to use that as the basis for

00:23:46,530 --> 00:23:49,770
their trees so they can benefit from

00:23:48,270 --> 00:23:52,590
pulling the stable updates that come

00:23:49,770 --> 00:23:54,600
from upstream and internally they're

00:23:52,590 --> 00:23:56,280
doing all their testing on the LTS trees

00:23:54,600 --> 00:23:58,290
and the reporting that back to the

00:23:56,280 --> 00:24:00,230
upstream community so everybody is

00:23:58,290 --> 00:24:04,140
benefiting from their increased testing

00:24:00,230 --> 00:24:06,660
and I mentioned Android as a success but

00:24:04,140 --> 00:24:08,880
really today the embedded picture looks

00:24:06,660 --> 00:24:09,900
much better and embedded distributors

00:24:08,880 --> 00:24:11,310
have gotten better about working with

00:24:09,900 --> 00:24:13,590
the community and there are a lot of

00:24:11,310 --> 00:24:15,600
board support packages that are in fact

00:24:13,590 --> 00:24:17,140
running the mainline tree and this is

00:24:15,600 --> 00:24:18,700
thanks to a lot of hardware

00:24:17,140 --> 00:24:20,740
and education by kernel developers

00:24:18,700 --> 00:24:24,010
explaining companies how exactly to

00:24:20,740 --> 00:24:25,420
contribute to the community and this is

00:24:24,010 --> 00:24:27,580
really a key point to a successful

00:24:25,420 --> 00:24:29,680
kernel strategy how are you engaging

00:24:27,580 --> 00:24:32,230
with the community maybe the community

00:24:29,680 --> 00:24:33,580
doesn't want your patch but you're

00:24:32,230 --> 00:24:37,810
ultimately need to figure out how to

00:24:33,580 --> 00:24:40,720
handle that and this kind of leads to

00:24:37,810 --> 00:24:42,490
the next topic people sometimes seem to

00:24:40,720 --> 00:24:44,740
want to run their own kernels off of

00:24:42,490 --> 00:24:46,690
kernel.org instead of running whatever

00:24:44,740 --> 00:24:50,080
the distribution provides and this is

00:24:46,690 --> 00:24:51,520
certainly something you can do and when

00:24:50,080 --> 00:24:54,040
I talk about this I never want to

00:24:51,520 --> 00:24:55,870
discourage anyone from doing things for

00:24:54,040 --> 00:24:57,700
the sake of learning the best way to

00:24:55,870 --> 00:25:00,550
learn about the kernel I think is to try

00:24:57,700 --> 00:25:02,260
something and break it you'll get a good

00:25:00,550 --> 00:25:04,150
chance to learn about what's hard where

00:25:02,260 --> 00:25:06,190
you have if you try and compile your own

00:25:04,150 --> 00:25:08,980
kernel and then say miss something or

00:25:06,190 --> 00:25:12,090
try and apply new patches you can learn

00:25:08,980 --> 00:25:14,110
about how things work by testing patches

00:25:12,090 --> 00:25:16,600
if you want to try and run your own

00:25:14,110 --> 00:25:19,540
raspberry pi cluster on your own go for

00:25:16,600 --> 00:25:21,850
it but if we're thinking about projects

00:25:19,540 --> 00:25:24,520
or deployments and say that have real

00:25:21,850 --> 00:25:28,840
users you really don't want to be

00:25:24,520 --> 00:25:30,730
running your own kernel and I don't say

00:25:28,840 --> 00:25:32,650
this to try and keep myself in a job as

00:25:30,730 --> 00:25:34,390
a kernel maintainer being a kernel

00:25:32,650 --> 00:25:35,920
maintainer is not always the glamorous

00:25:34,390 --> 00:25:39,280
life that everyone thinks it is it's

00:25:35,920 --> 00:25:40,900
oftentimes pretty tedious but a big part

00:25:39,280 --> 00:25:42,490
of what kernel maintainers are doing is

00:25:40,900 --> 00:25:45,280
thinking not about just what today's

00:25:42,490 --> 00:25:46,870
kernel is but tomorrow's kernel okay

00:25:45,280 --> 00:25:48,160
let's say you found this amazing patch

00:25:46,870 --> 00:25:50,680
that out there that improves your

00:25:48,160 --> 00:25:52,360
workload by a thousand percent but it's

00:25:50,680 --> 00:25:54,460
not going to be accepted upstream for

00:25:52,360 --> 00:25:56,290
any reason you can think of so you

00:25:54,460 --> 00:25:58,450
decide you're going to keep running your

00:25:56,290 --> 00:26:00,840
own kernel with this patch set you build

00:25:58,450 --> 00:26:03,640
your test you deploy you're done right

00:26:00,840 --> 00:26:04,990
this is your periodic reminder that when

00:26:03,640 --> 00:26:07,030
you deploy your kernel you are not done

00:26:04,990 --> 00:26:08,560
please make sure you are giving kernel

00:26:07,030 --> 00:26:10,900
updates you are getting updates

00:26:08,560 --> 00:26:12,190
especially for security fixes so if

00:26:10,900 --> 00:26:15,640
you're running your own kernel you were

00:26:12,190 --> 00:26:17,740
responsible for getting updates and this

00:26:15,640 --> 00:26:19,510
is the piece of advice that is given out

00:26:17,740 --> 00:26:21,460
there if you decide you want to maintain

00:26:19,510 --> 00:26:23,080
your own kernel please make sure you

00:26:21,460 --> 00:26:25,440
track one of the LTS branches from

00:26:23,080 --> 00:26:27,400
chrome org and just take those updates I

00:26:25,440 --> 00:26:29,710
spent a lot of time talking about why

00:26:27,400 --> 00:26:30,070
the enterprise kernels may choose to not

00:26:29,710 --> 00:26:32,380
use an

00:26:30,070 --> 00:26:34,600
LTS bakes and pick and choose individual

00:26:32,380 --> 00:26:36,490
patches but this really only works

00:26:34,600 --> 00:26:38,170
because they hire enough kernel

00:26:36,490 --> 00:26:40,360
engineers who have enough experience to

00:26:38,170 --> 00:26:42,790
know exactly what they can and cannot

00:26:40,360 --> 00:26:44,620
picks you do not want to be trying to

00:26:42,790 --> 00:26:48,700
maintain one of these kernels on your

00:26:44,620 --> 00:26:51,640
own or even as a small team member it is

00:26:48,700 --> 00:26:54,070
an interesting case of this as well I

00:26:51,640 --> 00:26:56,290
used to work on Android phones and at

00:26:54,070 --> 00:26:58,540
the time the kernels we use didn't track

00:26:56,290 --> 00:26:59,980
stable updates this meant we were

00:26:58,540 --> 00:27:01,720
regularly hitting bugs that had been

00:26:59,980 --> 00:27:03,040
fixed upstream and then we were

00:27:01,720 --> 00:27:05,830
scrambling to bring the patches in

00:27:03,040 --> 00:27:07,660
usually at inconvenient times and really

00:27:05,830 --> 00:27:10,180
you will forever be playing catch-up if

00:27:07,660 --> 00:27:11,470
you're already running in LCS and tried

00:27:10,180 --> 00:27:13,840
to figure out what fixes you need to

00:27:11,470 --> 00:27:15,490
bring in upstream is doing a lot of work

00:27:13,840 --> 00:27:18,060
to try and maintain the stable trees

00:27:15,490 --> 00:27:21,460
upstream please take advantage of that

00:27:18,060 --> 00:27:23,080
and even if you but even if you decide

00:27:21,460 --> 00:27:25,240
to keep using LTS like everyone

00:27:23,080 --> 00:27:26,500
recommends there's a good chance you're

00:27:25,240 --> 00:27:28,720
still going to have to do some work to

00:27:26,500 --> 00:27:29,980
maintain your out of tree pets simply

00:27:28,720 --> 00:27:32,410
because you're eventually gonna run into

00:27:29,980 --> 00:27:34,600
merge conflicts and merge conflicts are

00:27:32,410 --> 00:27:37,090
why colonel maintainer x' will never be

00:27:34,600 --> 00:27:38,350
fully out of a job there are certainly

00:27:37,090 --> 00:27:41,050
some tools out there to help maintain

00:27:38,350 --> 00:27:43,030
your auto free pap sets but ultimately

00:27:41,050 --> 00:27:45,730
it's usually going to be humans you need

00:27:43,030 --> 00:27:48,340
to figure out how the code works api's

00:27:45,730 --> 00:27:50,410
get changed and removes structures get

00:27:48,340 --> 00:27:51,730
added and removed and things get moved

00:27:50,410 --> 00:27:54,130
around and you need to know the code

00:27:51,730 --> 00:27:57,550
pretty well in order to try and do

00:27:54,130 --> 00:28:00,490
backports correctly another story for my

00:27:57,550 --> 00:28:01,990
android days I did a merge incorrectly

00:28:00,490 --> 00:28:03,970
when I was working helping to work on a

00:28:01,990 --> 00:28:05,920
kernel update and this introduced a

00:28:03,970 --> 00:28:08,290
subtle memory accounting bug that went

00:28:05,920 --> 00:28:10,060
unnoticed for months until there were

00:28:08,290 --> 00:28:11,860
fine enough reports of negative numbers

00:28:10,060 --> 00:28:14,950
of pages that I could help narrow down

00:28:11,860 --> 00:28:17,020
the problem and if I had to go back and

00:28:14,950 --> 00:28:18,220
give myself some advice then I really

00:28:17,020 --> 00:28:19,990
would have tried to get more people

00:28:18,220 --> 00:28:21,850
reviewing the back port I was doing to

00:28:19,990 --> 00:28:24,520
help maybe try and catch catch the bug

00:28:21,850 --> 00:28:26,110
and again the reason why a lot of these

00:28:24,520 --> 00:28:27,790
enterprise kernels actually work for

00:28:26,110 --> 00:28:30,570
doing back ports is because they have

00:28:27,790 --> 00:28:32,920
enough people looking and reviewing the

00:28:30,570 --> 00:28:34,570
patches and who know the code well

00:28:32,920 --> 00:28:37,810
enough to know exactly why these

00:28:34,570 --> 00:28:40,450
problems occur and again I never want to

00:28:37,810 --> 00:28:42,520
discourage anyone from doing this work

00:28:40,450 --> 00:28:43,840
from learning because it turns out you

00:28:42,520 --> 00:28:45,669
can learn a lot from trying to do

00:28:43,840 --> 00:28:48,070
backports but if you're thinking about

00:28:45,669 --> 00:28:49,360
kernels that are running on production

00:28:48,070 --> 00:28:52,779
systems you really want to set yourself

00:28:49,360 --> 00:28:54,700
up for success then we have our favorite

00:28:52,779 --> 00:28:56,620
bugs expose last year Spectre in

00:28:54,700 --> 00:28:59,049
meltdown the ghost from the time of this

00:28:56,620 --> 00:29:00,880
talk I think there's been enough talk

00:28:59,049 --> 00:29:02,289
explained by people like Greg about how

00:29:00,880 --> 00:29:04,990
the disclosure of this was handled

00:29:02,289 --> 00:29:08,860
pretty terribly and we've certainly

00:29:04,990 --> 00:29:11,230
learned since then about how later

00:29:08,860 --> 00:29:12,400
variants were handled but we're never

00:29:11,230 --> 00:29:15,340
going to be completely done with

00:29:12,400 --> 00:29:16,720
security and we'd like to believe

00:29:15,340 --> 00:29:20,110
everything is going to be handled

00:29:16,720 --> 00:29:22,000
perfectly next time but I'm pessimistic

00:29:20,110 --> 00:29:23,440
here so if you're running your own

00:29:22,000 --> 00:29:25,779
kernel and maintaining your own out of

00:29:23,440 --> 00:29:28,240
street patch set what are your plans for

00:29:25,779 --> 00:29:30,760
when you wake up and read the headline

00:29:28,240 --> 00:29:33,100
about the latest zero-day or issue you

00:29:30,760 --> 00:29:35,230
are the one responsible for applying the

00:29:33,100 --> 00:29:38,110
patent the security fix your tree and

00:29:35,230 --> 00:29:41,049
getting it out if if you have a back

00:29:38,110 --> 00:29:42,789
port and it's a doesn't the back and the

00:29:41,049 --> 00:29:44,350
security fix doesn't apply to your tree

00:29:42,789 --> 00:29:45,669
you're the one who's going to be

00:29:44,350 --> 00:29:47,890
responsible for trying to resolve that

00:29:45,669 --> 00:29:50,710
merge conflict and how confident are you

00:29:47,890 --> 00:29:52,419
that you have actually fixed the fix the

00:29:50,710 --> 00:29:54,520
bug and not accidentally be introduced

00:29:52,419 --> 00:29:56,200
in this is a real problem people have

00:29:54,520 --> 00:29:57,760
done in the past that major

00:29:56,200 --> 00:29:59,740
distributions have tried to applied

00:29:57,760 --> 00:30:01,419
security fixes done someone correctly

00:29:59,740 --> 00:30:04,029
such that the security fixed bug was

00:30:01,419 --> 00:30:06,640
still there it's pretty in it's not only

00:30:04,029 --> 00:30:10,510
pretty embarrassing it's not a good

00:30:06,640 --> 00:30:13,059
experience for anyone so circling back

00:30:10,510 --> 00:30:14,169
again I make it some like if I'm trying

00:30:13,059 --> 00:30:16,539
to make it sound like distributions

00:30:14,169 --> 00:30:19,210
always get it right they don't that's a

00:30:16,539 --> 00:30:22,390
good example they get oh they may get a

00:30:19,210 --> 00:30:23,799
lot of bugs but the point here is is

00:30:22,390 --> 00:30:26,559
that distributions are already making

00:30:23,799 --> 00:30:29,070
these mistakes so try and take advantage

00:30:26,559 --> 00:30:31,390
of these mistakes before making your own

00:30:29,070 --> 00:30:33,880
ok so wrapping things up here the

00:30:31,390 --> 00:30:36,279
question of what kernel you pick ends up

00:30:33,880 --> 00:30:38,590
coming down to what your focus if you

00:30:36,279 --> 00:30:40,840
don't care about the newest features it

00:30:38,590 --> 00:30:43,210
might make sense to run a kernel that

00:30:40,840 --> 00:30:45,850
just gets bug versus fixes say on an LPS

00:30:43,210 --> 00:30:48,159
kernel if you have particular stability

00:30:45,850 --> 00:30:50,520
requirements binary requirements maybe

00:30:48,159 --> 00:30:52,600
you want to run an enterprise kernel

00:30:50,520 --> 00:30:54,309
maybe you want to try and run your own

00:30:52,600 --> 00:30:55,830
kernel but you really might want to

00:30:54,309 --> 00:30:57,990
think twice about it and have

00:30:55,830 --> 00:30:59,549
good plan for dealing with things but

00:30:57,990 --> 00:31:01,440
more than anything I think I use the

00:30:59,549 --> 00:31:03,269
word think a lot think about exactly

00:31:01,440 --> 00:31:06,630
what you want for a kernel and try and

00:31:03,269 --> 00:31:07,769
make your life easier okay thank you I

00:31:06,630 --> 00:31:17,840
think we have a few minutes for

00:31:07,769 --> 00:31:17,840
questions here yes

00:31:26,669 --> 00:31:30,759
yes that's a that's a good point is the

00:31:29,289 --> 00:31:32,799
joke about Franken kernels is because

00:31:30,759 --> 00:31:35,469
they're stitched together and that is a

00:31:32,799 --> 00:31:38,619
good metaphor about why they're what why

00:31:35,469 --> 00:31:40,479
they're God together okay well if there

00:31:38,619 --> 00:31:42,519
are no more questions I'll be hanging

00:31:40,479 --> 00:31:43,749
out at the Red Hat booth after this so

00:31:42,519 --> 00:31:45,129
you're welcome to come by and ask me

00:31:43,749 --> 00:31:46,160
more questions there so thank you very

00:31:45,129 --> 00:31:51,660
much

00:31:46,160 --> 00:31:51,660

YouTube URL: https://www.youtube.com/watch?v=0IpXEzo1Z3I


