Title: Connect IoT with RSocket - Andy Shi, Alibaba
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	Connect IoT with RSocket - Andy Shi, Alibaba

RSocket is an open-source reactive networking protocol that is designed to handle the challenges of communication between complex networks of IoT and cloud services. Based on the Reactive Streams specification, RSocket is able to handle typical request-response traffic as well as bi-directional streaming data â€“ even in the face of unreliable connections.RSocket is transport-agnostic, so it can be used with a variety of standard transports (like TCP, HTTP/2 and WebSocket) both within the data center and over the internet.In this talk, I will introduce the concept of RScoket. And demonstrate with broker deployment model, how RSocket makes the IoT connection easier and more secure. In particular, I'll discuss how RSocket simplifies service discovery and bi-directional communication.
Captions: 
	00:00:00,680 --> 00:00:08,970
alright let's get started well thank you

00:00:04,890 --> 00:00:10,769
for sticking around if I were not giving

00:00:08,970 --> 00:00:14,009
a speech right now probably I would have

00:00:10,769 --> 00:00:17,670
wondered of myself and I grab some lunch

00:00:14,009 --> 00:00:21,330
so thank you for that so today we're

00:00:17,670 --> 00:00:23,880
gonna talk about our socket so first

00:00:21,330 --> 00:00:27,449
introducing myself my name is Andy XI

00:00:23,880 --> 00:00:29,580
I'm from Alibaba cloud we have an office

00:00:27,449 --> 00:00:32,640
in Northern California it's an

00:00:29,580 --> 00:00:34,559
engineering office so I'm a engineering

00:00:32,640 --> 00:00:36,930
working there also I'm the developer

00:00:34,559 --> 00:00:43,559
advocate for certain open source

00:00:36,930 --> 00:00:46,920
projects about ten months ago we were

00:00:43,559 --> 00:00:50,399
introduced to this fantastic technology

00:00:46,920 --> 00:00:52,969
called our socket and over the course I

00:00:50,399 --> 00:00:55,160
learned that it's great for connecting

00:00:52,969 --> 00:00:58,530
devices it's great for connecting

00:00:55,160 --> 00:01:00,719
applications micro-services anything

00:00:58,530 --> 00:01:04,619
that doesn't involve a human being

00:01:00,719 --> 00:01:07,010
it's grateful so today I'm gonna share

00:01:04,619 --> 00:01:10,380
that technology with you and hopefully

00:01:07,010 --> 00:01:15,740
you can spread the words and I can get

00:01:10,380 --> 00:01:15,740
some feedback now let's first talk about

00:01:17,750 --> 00:01:25,409
oops okay let's first talk about the

00:01:22,380 --> 00:01:27,720
definition of our socket now there's a

00:01:25,409 --> 00:01:29,220
long definition and there are some

00:01:27,720 --> 00:01:33,060
features we're going to talk about that

00:01:29,220 --> 00:01:36,119
later but for now let's simply remember

00:01:33,060 --> 00:01:40,860
that it is an application protocol okay

00:01:36,119 --> 00:01:43,500
so what it means is it's not it's not

00:01:40,860 --> 00:01:45,799
dealing with signals like Wi-Fi signals

00:01:43,500 --> 00:01:49,320
it's not doing and FC and other things

00:01:45,799 --> 00:01:53,280
it's an application level protocol and

00:01:49,320 --> 00:01:55,860
it gives developers the freedom that

00:01:53,280 --> 00:01:58,439
they don't have to worry about signals

00:01:55,860 --> 00:02:01,290
they don't have to worry about services

00:01:58,439 --> 00:02:04,170
sorry IPS and ports right so they're

00:02:01,290 --> 00:02:06,899
addressing services devices so that's

00:02:04,170 --> 00:02:12,540
what our socket is but then I was

00:02:06,899 --> 00:02:13,860
thinking how do I introduce a protocol

00:02:12,540 --> 00:02:17,610
in 30 minutes

00:02:13,860 --> 00:02:25,080
it's Mission Possible so I was thinking

00:02:17,610 --> 00:02:27,030
of doing a demo but for some reason this

00:02:25,080 --> 00:02:33,450
demo cannot be set up here

00:02:27,030 --> 00:02:37,260
let's check oh it can so I tried this

00:02:33,450 --> 00:02:39,660
demo upstairs in my room and works so

00:02:37,260 --> 00:02:43,230
that's hopeful that this kind of working

00:02:39,660 --> 00:02:49,950
out here as well so here's a simple demo

00:02:43,230 --> 00:02:53,489
setup I have a Raspberry Pi device that

00:02:49,950 --> 00:02:58,470
has a camera attached to that and it's

00:02:53,489 --> 00:03:01,680
rendering a service card camera it's

00:02:58,470 --> 00:03:04,680
taking a snapshot and it's going to send

00:03:01,680 --> 00:03:08,340
the picture over so the Raspberry Pi is

00:03:04,680 --> 00:03:11,670
connected to an our socket broker it's a

00:03:08,340 --> 00:03:15,360
broker okay that broker sits in public

00:03:11,670 --> 00:03:18,959
cloud our own Alibaba cloud and they're

00:03:15,360 --> 00:03:23,310
talking in our socket I have another

00:03:18,959 --> 00:03:26,130
device conveniently my laptop that's

00:03:23,310 --> 00:03:30,810
going to consume this service it's also

00:03:26,130 --> 00:03:34,530
connected to the broker and also going

00:03:30,810 --> 00:03:42,810
to the crowd and it's gonna request that

00:03:34,530 --> 00:03:45,920
picture so let's do that all right

00:03:42,810 --> 00:03:45,920
hopefully there works

00:03:57,390 --> 00:04:05,890
how long does it take

00:04:00,380 --> 00:04:05,890
okay now let's see

00:04:12,220 --> 00:04:20,989
can we see nope

00:04:17,500 --> 00:04:32,200
so I'm wondering how do I do this let me

00:04:20,989 --> 00:04:32,200
exit this first and it's

00:04:32,820 --> 00:04:39,390
and we're able to see a blurred picture

00:04:36,840 --> 00:04:41,820
with no good Lighting's but you get the

00:04:39,390 --> 00:04:42,740
idea right you get the idea that's how

00:04:41,820 --> 00:04:48,780
it works

00:04:42,740 --> 00:04:51,600
okay now seeing this very unimpressive

00:04:48,780 --> 00:04:54,540
and boring demo you probably are

00:04:51,600 --> 00:04:56,550
wondering what are we doing here right

00:04:54,540 --> 00:04:58,850
why are we doing this because there are

00:04:56,550 --> 00:05:03,840
multiple ways to achieve the same thing

00:04:58,850 --> 00:05:06,720
so bear with me this demo as boring as

00:05:03,840 --> 00:05:10,770
it is it's there's some foundations for

00:05:06,720 --> 00:05:12,600
the talks talking points later now first

00:05:10,770 --> 00:05:15,810
thing we need to clarify is why do we

00:05:12,600 --> 00:05:19,770
need a broker right I have my device

00:05:15,810 --> 00:05:24,210
here I have my laptop there and our

00:05:19,770 --> 00:05:26,550
socket can easily make that point to

00:05:24,210 --> 00:05:28,980
point connection work so why bother

00:05:26,550 --> 00:05:32,130
going all the way around well because we

00:05:28,980 --> 00:05:34,500
are thinking of the real use case

00:05:32,130 --> 00:05:38,850
through the real world use case where

00:05:34,500 --> 00:05:41,850
it's not just two devices so it's

00:05:38,850 --> 00:05:44,960
multiple devices talking to each other

00:05:41,850 --> 00:05:48,120
and we need to figure out a way to

00:05:44,960 --> 00:05:50,670
connect them and putting a broker in

00:05:48,120 --> 00:05:54,240
between simplifies that and that's a

00:05:50,670 --> 00:06:00,000
proven topology many other technologies

00:05:54,240 --> 00:06:02,160
you use the same deployment model but I

00:06:00,000 --> 00:06:05,940
need to clarify though that our socket

00:06:02,160 --> 00:06:10,850
is not a message bus it's not a message

00:06:05,940 --> 00:06:15,420
queue it's not doing the pub/sub style

00:06:10,850 --> 00:06:18,150
trafficking so for a broker for an hour

00:06:15,420 --> 00:06:23,220
socket brokers it has to solve problems

00:06:18,150 --> 00:06:27,120
like service registry service discovery

00:06:23,220 --> 00:06:30,450
and load balancing right and of course

00:06:27,120 --> 00:06:33,930
load balancing is not within the

00:06:30,450 --> 00:06:35,340
boundary of the econ protocol itself so

00:06:33,930 --> 00:06:39,110
we're not going to talk about it but

00:06:35,340 --> 00:06:44,220
still we need to discover how we can do

00:06:39,110 --> 00:06:46,680
discovery and registry so any

00:06:44,220 --> 00:06:50,090
suggestions on how we do that

00:06:46,680 --> 00:06:55,880
good packages that we normally use for

00:06:50,090 --> 00:06:59,729
service registry and discovery anyone

00:06:55,880 --> 00:07:01,320
heard of any good packages there a

00:06:59,729 --> 00:07:02,750
couple of them right that so they are

00:07:01,320 --> 00:07:06,389
used

00:07:02,750 --> 00:07:10,139
yes service mesh thank you a service

00:07:06,389 --> 00:07:12,120
mesh is a technology that helps you to

00:07:10,139 --> 00:07:16,530
connect the services similar to what

00:07:12,120 --> 00:07:19,710
we're doing here but in particular when

00:07:16,530 --> 00:07:22,289
you are talking about registry and

00:07:19,710 --> 00:07:25,710
discovery you probably need a third

00:07:22,289 --> 00:07:29,130
party tool to help you write there are

00:07:25,710 --> 00:07:33,840
like console and others are very famous

00:07:29,130 --> 00:07:37,740
ones but guess what our socket doesn't

00:07:33,840 --> 00:07:47,900
need any of those our socket does not

00:07:37,740 --> 00:07:52,790
need a third party tool okay

00:07:47,900 --> 00:07:56,590
so here's the code in my code in the

00:07:52,790 --> 00:08:00,860
broker this is a part where it returns

00:07:56,590 --> 00:08:04,160
to a connection so it's going to return

00:08:00,860 --> 00:08:06,020
the handler and I taken out all the

00:08:04,160 --> 00:08:08,090
other logics but looking at the two

00:08:06,020 --> 00:08:11,330
things it registers and subscribes to

00:08:08,090 --> 00:08:14,300
two events on success and non terminate

00:08:11,330 --> 00:08:17,300
so when you are connecting it's

00:08:14,300 --> 00:08:21,080
successful there is a event getting

00:08:17,300 --> 00:08:23,750
triggered and then you can do sales you

00:08:21,080 --> 00:08:26,800
can do things and what do you do you put

00:08:23,750 --> 00:08:30,890
the metadata of the service somewhere as

00:08:26,800 --> 00:08:33,350
a registry right and I'm terminating

00:08:30,890 --> 00:08:35,330
what do you do the same thing you take

00:08:33,350 --> 00:08:39,740
out that metadata and say this service

00:08:35,330 --> 00:08:42,310
is no longer available so by this simple

00:08:39,740 --> 00:08:46,870
piece of code you can achieve a

00:08:42,310 --> 00:08:50,870
complicated third-party tool that can do

00:08:46,870 --> 00:08:54,650
and how is that possible right how is

00:08:50,870 --> 00:08:57,410
that enabled by our socket so our socket

00:08:54,650 --> 00:09:02,840
has this feature is called connection

00:08:57,410 --> 00:09:06,170
oriented connection oriented so what

00:09:02,840 --> 00:09:08,420
does it mean so basically our socket

00:09:06,170 --> 00:09:11,930
when you connect to it it's going to

00:09:08,420 --> 00:09:14,180
establish a long connection it's going

00:09:11,930 --> 00:09:17,050
to establish a long connection and it's

00:09:14,180 --> 00:09:20,630
it's going to establish sessions and

00:09:17,050 --> 00:09:22,190
then there's a thing called setup frame

00:09:20,630 --> 00:09:26,150
we're going to talk about that later but

00:09:22,190 --> 00:09:28,820
stead of frame is first when you are

00:09:26,150 --> 00:09:31,250
first connecting to the broker you're

00:09:28,820 --> 00:09:33,230
going to give out the meta data of what

00:09:31,250 --> 00:09:35,000
your device is about you're gonna give

00:09:33,230 --> 00:09:39,380
out the service name or whatever that's

00:09:35,000 --> 00:09:41,930
agreed upon and your broker can then

00:09:39,380 --> 00:09:45,020
view the registry on top of it and then

00:09:41,930 --> 00:09:48,860
you can later serve it right and also

00:09:45,020 --> 00:09:53,300
when you have multiple instances of the

00:09:48,860 --> 00:09:56,060
same service or device you can build

00:09:53,300 --> 00:09:58,340
algorithms of load balancing you can

00:09:56,060 --> 00:10:01,730
build fancy algorithms of load balancing

00:09:58,340 --> 00:10:05,139
with it and of course

00:10:01,730 --> 00:10:09,439
we have this events that's going to be

00:10:05,139 --> 00:10:13,429
subscribed by by the broker or by the

00:10:09,439 --> 00:10:15,379
connection so it knows one to you when

00:10:13,429 --> 00:10:17,749
the connection is available when it's

00:10:15,379 --> 00:10:21,499
not so we don't need all the other tools

00:10:17,749 --> 00:10:25,459
and that's a nice part of our socket it

00:10:21,499 --> 00:10:28,279
simplifies a lot of things so the

00:10:25,459 --> 00:10:30,739
benefit of connection-oriented is that

00:10:28,279 --> 00:10:33,470
obviously we just talked about no suit

00:10:30,739 --> 00:10:35,179
party registry also we don't need search

00:10:33,470 --> 00:10:38,179
party house check because we already

00:10:35,179 --> 00:10:42,259
know when the connection is up and or

00:10:38,179 --> 00:10:45,619
done right and a good part and I think

00:10:42,259 --> 00:10:48,649
it's really useful for IOT devices is it

00:10:45,619 --> 00:10:52,339
has session resumption session

00:10:48,649 --> 00:10:56,299
resumption what that means is it it's

00:10:52,339 --> 00:11:00,739
beyond connection resumption so let's

00:10:56,299 --> 00:11:03,980
say my device got disconnected when you

00:11:00,739 --> 00:11:07,189
plug it back it's gonna resume the

00:11:03,980 --> 00:11:10,249
connection that's normal but let's say

00:11:07,189 --> 00:11:14,749
this device was transmitting 10 frames

00:11:10,249 --> 00:11:17,029
to my laptop and number 5 it stopped

00:11:14,749 --> 00:11:17,480
right in the middle of number five it

00:11:17,029 --> 00:11:20,509
stopped

00:11:17,480 --> 00:11:23,299
so what resumption gives that is gonna

00:11:20,509 --> 00:11:25,369
it's going to resume transmitting from

00:11:23,299 --> 00:11:28,850
frame five because it was not complete

00:11:25,369 --> 00:11:30,619
so that's what session resumption does

00:11:28,850 --> 00:11:33,499
and it's really powerful and useful

00:11:30,619 --> 00:11:39,379
especially for IOT devices but for other

00:11:33,499 --> 00:11:41,689
services as well so this is one of one

00:11:39,379 --> 00:11:46,369
feature that I think that's interesting

00:11:41,689 --> 00:11:50,239
coming out of this demo another another

00:11:46,369 --> 00:11:55,100
feature we're gonna talk about is how we

00:11:50,239 --> 00:11:58,579
connect to the broker okay

00:11:55,100 --> 00:12:02,439
so this is a code on both of the devices

00:11:58,579 --> 00:12:07,879
from both the Raspberry Pi and my laptop

00:12:02,439 --> 00:12:12,169
it connects to the public IP of the

00:12:07,879 --> 00:12:14,600
broker now the second line is the set

00:12:12,169 --> 00:12:15,170
set a payload setup frame we just talked

00:12:14,600 --> 00:12:19,640
about

00:12:15,170 --> 00:12:23,600
it contains metadata of your device and

00:12:19,640 --> 00:12:26,779
your service right so it's just one time

00:12:23,600 --> 00:12:29,470
and the third line that's the

00:12:26,779 --> 00:12:33,019
interesting part so it's going to be

00:12:29,470 --> 00:12:38,959
connecting to the broker now here's the

00:12:33,019 --> 00:12:42,350
thing this Raspberry Pi is offering a

00:12:38,959 --> 00:12:45,910
service now normally when you are

00:12:42,350 --> 00:12:49,570
rendering a service how do you do that

00:12:45,910 --> 00:12:50,870
you open the port and you listen to it

00:12:49,570 --> 00:12:52,880
right

00:12:50,870 --> 00:12:58,579
you open the port and you listen to it

00:12:52,880 --> 00:13:02,390
now in this case we're not doing that we

00:12:58,579 --> 00:13:05,450
connect to the broker and then when

00:13:02,390 --> 00:13:09,320
there is even without a broker let's say

00:13:05,450 --> 00:13:14,329
these two are connected together the Mac

00:13:09,320 --> 00:13:17,209
can just request to the Raspberry Pi ask

00:13:14,329 --> 00:13:21,760
for that service okay so that's a

00:13:17,209 --> 00:13:26,269
powerful feature of our socket because

00:13:21,760 --> 00:13:28,579
let's think about it for a minute one do

00:13:26,269 --> 00:13:29,570
we have the distinction between a client

00:13:28,579 --> 00:13:32,329
and the server

00:13:29,570 --> 00:13:37,850
meaning that communication has to be

00:13:32,329 --> 00:13:39,550
initiated from the client right TCP does

00:13:37,850 --> 00:13:42,500
not have that distinction

00:13:39,550 --> 00:13:45,529
TCP doesn't have it right you have to

00:13:42,500 --> 00:13:47,209
open the port yes but so the one that

00:13:45,529 --> 00:13:51,410
opens the port can initiate the

00:13:47,209 --> 00:13:55,459
communication right who does that client

00:13:51,410 --> 00:13:58,640
and server HTTP does and HTTP is

00:13:55,459 --> 00:14:02,329
designed for human beings sitting behind

00:13:58,640 --> 00:14:06,199
the browser and requesting service from

00:14:02,329 --> 00:14:09,199
a server so it is designed to protect

00:14:06,199 --> 00:14:12,890
the consumers that a server doesn't push

00:14:09,199 --> 00:14:18,970
unnecessary stuff to the browser that's

00:14:12,890 --> 00:14:23,110
why it has this distinction but but that

00:14:18,970 --> 00:14:26,089
model of communication does not apply to

00:14:23,110 --> 00:14:29,390
applications communication it doesn't

00:14:26,089 --> 00:14:31,670
apply to IOT communications right

00:14:29,390 --> 00:14:34,070
why do we have to in the last talk I

00:14:31,670 --> 00:14:38,660
don't know if you guys were here but the

00:14:34,070 --> 00:14:41,660
in the last hop the one before me the

00:14:38,660 --> 00:14:43,490
professor was talking about how every

00:14:41,660 --> 00:14:45,890
time you restart you need to figure out

00:14:43,490 --> 00:14:48,140
the IP I guess that's painful because

00:14:45,890 --> 00:14:50,660
you need to figure out the IP address

00:14:48,140 --> 00:14:53,060
and you need to give out a port so that

00:14:50,660 --> 00:14:57,140
you can listen to you can listen to

00:14:53,060 --> 00:14:59,330
their port and establish a service right

00:14:57,140 --> 00:15:04,330
so this feature what we're talking about

00:14:59,330 --> 00:15:04,330
is called bi-directional communication

00:15:04,480 --> 00:15:10,280
so bi-directional communication gives us

00:15:07,550 --> 00:15:14,030
certain benefits of course for IOT

00:15:10,280 --> 00:15:17,380
devices it's huge that security when you

00:15:14,030 --> 00:15:19,880
listen to a port there will be attacks

00:15:17,380 --> 00:15:23,180
and when you don't listen to important

00:15:19,880 --> 00:15:26,120
you don't have that attack and IP

00:15:23,180 --> 00:15:28,390
management right it's hard for IOT

00:15:26,120 --> 00:15:32,420
devices it's even hard for edge devices

00:15:28,390 --> 00:15:35,240
I I was working on something a couple

00:15:32,420 --> 00:15:38,960
weeks ago that we need to come up with a

00:15:35,240 --> 00:15:41,090
list of IP address so each time that the

00:15:38,960 --> 00:15:43,370
edge device the server starts it's gonna

00:15:41,090 --> 00:15:48,830
have the same static IP address which is

00:15:43,370 --> 00:15:51,710
against designs of many things but above

00:15:48,830 --> 00:15:53,660
all it's great for connection management

00:15:51,710 --> 00:15:55,430
so you don't have to worry about

00:15:53,660 --> 00:15:58,190
upstream connection downstream

00:15:55,430 --> 00:16:03,920
connection it's one connection so that's

00:15:58,190 --> 00:16:06,910
the power of our socket so we we've gone

00:16:03,920 --> 00:16:10,630
through two major features of our socket

00:16:06,910 --> 00:16:14,060
connection oriented and bi-directional

00:16:10,630 --> 00:16:20,780
communications so what else is available

00:16:14,060 --> 00:16:23,720
right so that's the four points on the

00:16:20,780 --> 00:16:26,060
first slide so let's talk about the

00:16:23,720 --> 00:16:30,200
features that's available for our socket

00:16:26,060 --> 00:16:31,970
our socket is a binary protocol it's not

00:16:30,200 --> 00:16:35,030
a text based protocol so it's more

00:16:31,970 --> 00:16:37,960
efficient and it's message based

00:16:35,030 --> 00:16:42,050
protocol so what that means is it has

00:16:37,960 --> 00:16:43,020
message informations embedded in the

00:16:42,050 --> 00:16:46,140
same

00:16:43,020 --> 00:16:48,779
type of payload as your other payload

00:16:46,140 --> 00:16:51,839
for example we just talked about setup

00:16:48,779 --> 00:16:54,440
frame right we're gonna talk about all

00:16:51,839 --> 00:16:57,450
the events right how does it check for

00:16:54,440 --> 00:16:59,880
the lightness so there's a keepalive

00:16:57,450 --> 00:17:02,850
frame and there are other frames all

00:16:59,880 --> 00:17:07,069
those commands are in the same format as

00:17:02,850 --> 00:17:09,870
the others all appear as the same frame

00:17:07,069 --> 00:17:12,329
format so that's a message based

00:17:09,870 --> 00:17:14,970
protocol and we just talked about back

00:17:12,329 --> 00:17:17,370
bi-directional and connection oriented

00:17:14,970 --> 00:17:20,579
so these three things bi-directional

00:17:17,370 --> 00:17:23,850
multiplex and connection oriented makes

00:17:20,579 --> 00:17:27,780
it really powerful now of course we it's

00:17:23,850 --> 00:17:30,570
hard for me to that all the multiplex I

00:17:27,780 --> 00:17:33,950
don't I cannot think of a simple demo

00:17:30,570 --> 00:17:38,460
that can do that but all these three

00:17:33,950 --> 00:17:40,950
make that really powerful and of course

00:17:38,460 --> 00:17:43,470
there's another point of the for

00:17:40,950 --> 00:17:48,059
interaction models with that we have not

00:17:43,470 --> 00:17:50,880
talked about and here they are so the

00:17:48,059 --> 00:17:54,120
founders or the creators of this

00:17:50,880 --> 00:17:56,370
protocol they were thinking of the

00:17:54,120 --> 00:17:59,490
patterns of communications between

00:17:56,370 --> 00:18:02,760
applications between IOT devices and

00:17:59,490 --> 00:18:05,250
they came up with different patterns for

00:18:02,760 --> 00:18:09,420
different models one is our familiar

00:18:05,250 --> 00:18:11,760
request response that's we are we all

00:18:09,420 --> 00:18:15,540
know what it is the second one is

00:18:11,760 --> 00:18:17,580
fire-and-forget fire-and-forget is when

00:18:15,540 --> 00:18:22,490
you send something over you don't care

00:18:17,580 --> 00:18:25,380
about the returns outs right for example

00:18:22,490 --> 00:18:27,870
if you're writing something to the logs

00:18:25,380 --> 00:18:31,740
you don't really care if it's received

00:18:27,870 --> 00:18:33,960
or not so that's one use case and also I

00:18:31,740 --> 00:18:37,320
think for people who are familiar with

00:18:33,960 --> 00:18:40,470
mqtt there's also that feature and the

00:18:37,320 --> 00:18:42,600
third part is request stream your quest

00:18:40,470 --> 00:18:45,480
stream is when you send a request you

00:18:42,600 --> 00:18:48,450
get a stream of responses not just one

00:18:45,480 --> 00:18:51,919
you have plenty and the last one is a

00:18:48,450 --> 00:18:56,370
channel that's a bidirectional streams

00:18:51,919 --> 00:18:57,570
so the thing to remember is

00:18:56,370 --> 00:19:00,559
even though there are four different

00:18:57,570 --> 00:19:03,720
types of interactions you only need one

00:19:00,559 --> 00:19:06,090
connection it's that long connection you

00:19:03,720 --> 00:19:09,000
established as a beginning that's gonna

00:19:06,090 --> 00:19:11,309
serve all of them okay you can have them

00:19:09,000 --> 00:19:13,409
together you can have one by one doesn't

00:19:11,309 --> 00:19:15,360
matter but that's the connection is

00:19:13,409 --> 00:19:18,419
gonna stay there and if it is

00:19:15,360 --> 00:19:21,870
disconnected it's gonna resume okay so

00:19:18,419 --> 00:19:23,580
one connection multiplexed so that's how

00:19:21,870 --> 00:19:26,159
multiplex works right so you have

00:19:23,580 --> 00:19:32,880
different types of streams it's going to

00:19:26,159 --> 00:19:36,080
be using the same socket so we've talked

00:19:32,880 --> 00:19:41,850
about the major features of our socket

00:19:36,080 --> 00:19:47,130
right and now let's drill down a little

00:19:41,850 --> 00:19:49,409
bit more and that is what's the design

00:19:47,130 --> 00:19:53,039
principles behind it right other than

00:19:49,409 --> 00:19:55,820
making it convenient and adaptive to you

00:19:53,039 --> 00:20:00,059
all the application communication models

00:19:55,820 --> 00:20:02,730
what's the design principles behind it

00:20:00,059 --> 00:20:06,179
and that's a tough topic I would say but

00:20:02,730 --> 00:20:12,059
let's start with the name we knows what

00:20:06,179 --> 00:20:17,850
socket is what does our stand for our

00:20:12,059 --> 00:20:20,730
stands for reactive reactive streams I

00:20:17,850 --> 00:20:23,309
I'm not sure if we all have heard of it

00:20:20,730 --> 00:20:25,740
but it's a programming model that's been

00:20:23,309 --> 00:20:28,860
around for some time now I'm not gonna

00:20:25,740 --> 00:20:30,870
go too deep into that because that's

00:20:28,860 --> 00:20:36,360
gonna stir a lot of debates and whatnot

00:20:30,870 --> 00:20:38,610
but the two major design principles and

00:20:36,360 --> 00:20:41,820
I think it's the design principles for

00:20:38,610 --> 00:20:45,179
all the distributed environment or

00:20:41,820 --> 00:20:49,610
architecture is it it focuses on

00:20:45,179 --> 00:20:55,230
asynchronous and non-blocking i/o

00:20:49,610 --> 00:20:57,299
asynchronous and non-blocking i/o I mean

00:20:55,230 --> 00:20:59,340
it's not hard to figure that out because

00:20:57,299 --> 00:21:01,679
you have things that you don't have

00:20:59,340 --> 00:21:03,870
control over so the best way to deal

00:21:01,679 --> 00:21:08,400
with it and make sure you're resilient

00:21:03,870 --> 00:21:11,610
and high performance is to

00:21:08,400 --> 00:21:14,220
get around it right so you kick the ones

00:21:11,610 --> 00:21:16,980
that's blocked out and you make sure the

00:21:14,220 --> 00:21:21,059
one that's not blocked can get in so

00:21:16,980 --> 00:21:22,919
that's how you do it now there are

00:21:21,059 --> 00:21:24,900
different ways to increment a

00:21:22,919 --> 00:21:28,740
synchronous in non-blocking i/o right

00:21:24,900 --> 00:21:30,299
it's not just reactive that's the only

00:21:28,740 --> 00:21:34,350
one there are different ways to do it

00:21:30,299 --> 00:21:38,070
but what makes reactive stream stand out

00:21:34,350 --> 00:21:43,260
is the concept called back pressure so

00:21:38,070 --> 00:21:44,940
what is back pressure let's go back to

00:21:43,260 --> 00:21:48,390
asynchronous in-home blocking for a

00:21:44,940 --> 00:21:50,429
minute how do you implement that how do

00:21:48,390 --> 00:21:54,659
you implement asynchronous and

00:21:50,429 --> 00:21:56,909
non-blocking i/o you need to query your

00:21:54,659 --> 00:21:59,340
your operating system right to know

00:21:56,909 --> 00:22:02,700
which process is a blocked which ones

00:21:59,340 --> 00:22:05,669
are ready right you need to do that now

00:22:02,700 --> 00:22:09,750
the problem is what about the devices

00:22:05,669 --> 00:22:12,510
that's not in your control right what

00:22:09,750 --> 00:22:15,299
about the other devices other services

00:22:12,510 --> 00:22:18,090
that you cannot preserve operating

00:22:15,299 --> 00:22:20,640
system you cannot do that right you

00:22:18,090 --> 00:22:25,200
cannot submit you cannot subscribe to an

00:22:20,640 --> 00:22:27,450
event say hey my the operating system on

00:22:25,200 --> 00:22:29,760
the PI tell me when this thread is ready

00:22:27,450 --> 00:22:34,740
you cannot do that so you need a

00:22:29,760 --> 00:22:36,270
measurement to know when it's ready so

00:22:34,740 --> 00:22:39,659
that's what back pressure is back

00:22:36,270 --> 00:22:41,760
pressure is the consumer telling the

00:22:39,659 --> 00:22:44,429
producer I am ready

00:22:41,760 --> 00:22:47,250
give me a couple of frames that's what

00:22:44,429 --> 00:22:51,090
it does nothing else it's a very simple

00:22:47,250 --> 00:22:53,870
yet it is very genius design because

00:22:51,090 --> 00:22:57,059
what are the other alternatives right

00:22:53,870 --> 00:22:59,340
either you do long pooling are you ready

00:22:57,059 --> 00:23:03,690
are you ready are you ready think about

00:22:59,340 --> 00:23:06,000
that in fact if no or you do the other

00:23:03,690 --> 00:23:07,380
way the consumer is saying I'm busy I'm

00:23:06,000 --> 00:23:10,710
busy I'm busy

00:23:07,380 --> 00:23:12,210
does it work of course not because when

00:23:10,710 --> 00:23:14,399
you're busy probably you're already

00:23:12,210 --> 00:23:18,390
blocked how do you send out that signal

00:23:14,399 --> 00:23:22,260
right so this is a genius way of design

00:23:18,390 --> 00:23:27,410
and I love this picture

00:23:22,260 --> 00:23:30,059
these two pictures of how and describes

00:23:27,410 --> 00:23:32,250
back pressure so when you don't have

00:23:30,059 --> 00:23:35,820
much back pressure when you have a surge

00:23:32,250 --> 00:23:38,850
of traffic that's what's gonna happen to

00:23:35,820 --> 00:23:40,860
the man and then when you have that

00:23:38,850 --> 00:23:42,960
pressure even though she's drinking from

00:23:40,860 --> 00:23:45,510
a bottle imagine that's a house and

00:23:42,960 --> 00:23:47,730
she's saying give me like two tablespoon

00:23:45,510 --> 00:23:51,960
right that's what it does that's what

00:23:47,730 --> 00:23:55,169
bad pressure does now back pressure are

00:23:51,960 --> 00:23:57,570
suck sorry reactive streams had has been

00:23:55,169 --> 00:24:01,320
around for a while this concept has been

00:23:57,570 --> 00:24:02,270
around so what does our circuit do to

00:24:01,320 --> 00:24:05,160
make a difference

00:24:02,270 --> 00:24:08,520
right so it turns out that back pressure

00:24:05,160 --> 00:24:12,630
and when its original originally

00:24:08,520 --> 00:24:17,000
developed it's it's not enforced on

00:24:12,630 --> 00:24:21,960
network so what our socket guarantees is

00:24:17,000 --> 00:24:24,210
end to end back pressure so what does I

00:24:21,960 --> 00:24:27,030
mean let's say you have more than two

00:24:24,210 --> 00:24:29,730
devices like five devices one of them is

00:24:27,030 --> 00:24:31,980
low you need to inform the other four

00:24:29,730 --> 00:24:35,040
right whether they are in parallel or

00:24:31,980 --> 00:24:38,130
they are in the chain you need to let

00:24:35,040 --> 00:24:40,919
the others know if you are relying on

00:24:38,130 --> 00:24:44,850
TCP to deliver that breath back pressure

00:24:40,919 --> 00:24:47,840
is hop two hop right it's how to hop TCP

00:24:44,850 --> 00:24:50,520
has a sliding window but it's at

00:24:47,840 --> 00:24:52,770
transport layer it doesn't know your

00:24:50,520 --> 00:24:56,549
application status it cannot create

00:24:52,770 --> 00:25:02,250
backwards so it can only do how to hop

00:24:56,549 --> 00:25:06,210
and our socket can do it su message

00:25:02,250 --> 00:25:09,270
based protocol that information that

00:25:06,210 --> 00:25:14,669
back pressure information is encrypted

00:25:09,270 --> 00:25:18,450
in in the request frame and it goes

00:25:14,669 --> 00:25:23,150
around the house system so it enables

00:25:18,450 --> 00:25:27,960
end-to-end flow control or back pressure

00:25:23,150 --> 00:25:30,450
so that is and that's how much I'm going

00:25:27,960 --> 00:25:32,730
to talk about reactive in general

00:25:30,450 --> 00:25:36,180
because I know it's it's a broad topic

00:25:32,730 --> 00:25:38,610
but that's the principle behind

00:25:36,180 --> 00:25:41,220
our socket is to ensure your

00:25:38,610 --> 00:25:47,600
asynchronous and non-blocking i/o goes

00:25:41,220 --> 00:25:52,830
all over the system and to end all right

00:25:47,600 --> 00:25:55,770
so next topic and that that's a little

00:25:52,830 --> 00:25:59,160
bit more controversial is comparisons

00:25:55,770 --> 00:26:04,350
with other technologies and the first

00:25:59,160 --> 00:26:09,660
one is what I always get asked the

00:26:04,350 --> 00:26:14,310
difference from G RPC kiss a G RPC is

00:26:09,660 --> 00:26:17,820
very popular as well so what G RPC has

00:26:14,310 --> 00:26:21,480
it has two parts it has an RPC part it

00:26:17,820 --> 00:26:25,110
has a protocol part right what our

00:26:21,480 --> 00:26:29,630
socket is is it is a protocol so it is

00:26:25,110 --> 00:26:32,820
not an RPC layer actually it works with

00:26:29,630 --> 00:26:35,670
protobuf so if you have generating your

00:26:32,820 --> 00:26:38,250
profiles of cool you can you can just

00:26:35,670 --> 00:26:43,560
put it over you don't have to regenerate

00:26:38,250 --> 00:26:47,040
them and it supports other encoding

00:26:43,560 --> 00:26:53,120
mechanisms as well so now let's talk

00:26:47,040 --> 00:26:57,390
about our socket bit versus HTTP which

00:26:53,120 --> 00:27:00,450
is a little bit controversial so over

00:26:57,390 --> 00:27:03,270
the years we've seen HTTP 2 and now

00:27:00,450 --> 00:27:06,480
there's HTTP suey and there's a lot of

00:27:03,270 --> 00:27:08,990
great features in vision there's a lot

00:27:06,480 --> 00:27:12,150
of great improvements that has been done

00:27:08,990 --> 00:27:14,820
we've seen like server push we've seen

00:27:12,150 --> 00:27:17,970
multiplex we've seen the HTTP 2 is are

00:27:14,820 --> 00:27:21,960
also binary protocol so we've seen a lot

00:27:17,970 --> 00:27:26,460
of these things going on right and HTTP

00:27:21,960 --> 00:27:29,520
3 is more ambitious and you can see that

00:27:26,460 --> 00:27:31,890
they are they're doing something that we

00:27:29,520 --> 00:27:34,380
are circuit has already implemented and

00:27:31,890 --> 00:27:37,440
so that's a great thing and and we like

00:27:34,380 --> 00:27:40,460
it because it not only validates our

00:27:37,440 --> 00:27:43,560
sockets idea but there also means that

00:27:40,460 --> 00:27:46,800
the communication model has shifted from

00:27:43,560 --> 00:27:49,500
the original human browser to web server

00:27:46,800 --> 00:27:52,260
to application

00:27:49,500 --> 00:27:59,600
application communications so that's a

00:27:52,260 --> 00:28:03,450
great thing but but here's the thing

00:27:59,600 --> 00:28:06,660
HTTP is a popular protocol it has to

00:28:03,450 --> 00:28:08,670
make everyone happy right it has to make

00:28:06,660 --> 00:28:13,050
everyone happy which means it's really

00:28:08,670 --> 00:28:17,160
hard to become truly reactive now let's

00:28:13,050 --> 00:28:20,400
take one example let's see you

00:28:17,160 --> 00:28:23,370
there's say oh there's a flash they

00:28:20,400 --> 00:28:26,970
online and you want to buy something and

00:28:23,370 --> 00:28:30,360
it's only like one minute so you put

00:28:26,970 --> 00:28:35,250
this thing on the shopping cart you wait

00:28:30,360 --> 00:28:37,410
for the time to come and if this whole

00:28:35,250 --> 00:28:40,500
system was implemented in our socket

00:28:37,410 --> 00:28:43,680
what's gonna happen so you're gonna wait

00:28:40,500 --> 00:28:46,860
kiss that checkout button will not

00:28:43,680 --> 00:28:50,760
appear until the web server gives it a

00:28:46,860 --> 00:28:53,070
green light right so that's not the user

00:28:50,760 --> 00:28:54,870
experience you you want that's not the

00:28:53,070 --> 00:28:57,440
user experience the sellers will want

00:28:54,870 --> 00:29:01,320
what do you want is you keep clicking

00:28:57,440 --> 00:29:05,190
keep trying and only like 10% of them

00:29:01,320 --> 00:29:09,540
get the flash sale deal that's what they

00:29:05,190 --> 00:29:13,080
want right so in other words our socket

00:29:09,540 --> 00:29:17,100
kills the fun right it kills all the

00:29:13,080 --> 00:29:21,960
enthusiasm when there's human involved

00:29:17,100 --> 00:29:26,330
and HTTP though has to support that so

00:29:21,960 --> 00:29:30,860
HTTP can not be truly reactive it cannot

00:29:26,330 --> 00:29:33,600
truly embrace that high-performance

00:29:30,860 --> 00:29:36,540
asynchronous non-blocking i/o it has to

00:29:33,600 --> 00:29:39,240
do so imagine that user experience what

00:29:36,540 --> 00:29:41,190
it does to the system load right it

00:29:39,240 --> 00:29:43,640
creates a lot of junked connections

00:29:41,190 --> 00:29:47,430
that's disconnected it's it's a mess but

00:29:43,640 --> 00:29:50,160
that's where it is right now so our

00:29:47,430 --> 00:29:52,800
socket is not trying to please everyone

00:29:50,160 --> 00:29:55,740
it's only designed for certain use cases

00:29:52,800 --> 00:30:00,930
and we try to make those use cases work

00:29:55,740 --> 00:30:03,000
better HTTP is well established it has

00:30:00,930 --> 00:30:06,050
to support everyone so

00:30:03,000 --> 00:30:08,670
that's the difference now another

00:30:06,050 --> 00:30:13,830
comparison we always have to do is

00:30:08,670 --> 00:30:15,810
against message queues especially in

00:30:13,830 --> 00:30:20,040
other talks and people always ask for

00:30:15,810 --> 00:30:24,360
Kafka because I think I was mentioning

00:30:20,040 --> 00:30:28,710
the brokerage model deployment model and

00:30:24,360 --> 00:30:32,220
also also because I mentioned it's a

00:30:28,710 --> 00:30:35,010
message based protocol but let's take a

00:30:32,220 --> 00:30:37,350
look and what happens when you have a

00:30:35,010 --> 00:30:41,160
surge of traffic and there's an

00:30:37,350 --> 00:30:43,320
imbalance between the the consumer and

00:30:41,160 --> 00:30:47,640
producer right so the left would be your

00:30:43,320 --> 00:30:52,260
mqtt that's anticipated it's expected

00:30:47,640 --> 00:30:56,520
the middle one would be our socket right

00:30:52,260 --> 00:30:58,350
so that's what we have explained so the

00:30:56,520 --> 00:31:02,160
right one is a little bit interesting

00:30:58,350 --> 00:31:04,230
this is Kafka so what Kafka does is it's

00:31:02,160 --> 00:31:06,840
going to cache all the data and then

00:31:04,230 --> 00:31:10,770
it's going to still use the same rate

00:31:06,840 --> 00:31:13,860
the rate that the consumer can accept to

00:31:10,770 --> 00:31:18,480
send the traffic over so think about

00:31:13,860 --> 00:31:21,120
that I mean I work for for a cloud

00:31:18,480 --> 00:31:24,660
vendor and I love customers to buy

00:31:21,120 --> 00:31:28,620
storage and and memory based cache I

00:31:24,660 --> 00:31:31,440
love that but this solution wouldn't

00:31:28,620 --> 00:31:33,180
scale right eventually you're gonna run

00:31:31,440 --> 00:31:36,000
out of your storage or memory or

00:31:33,180 --> 00:31:39,150
whatever right so right now if you use

00:31:36,000 --> 00:31:42,030
Kafka to connect you guys devices

00:31:39,150 --> 00:31:44,580
there's already limitations and because

00:31:42,030 --> 00:31:48,000
of the partition it does it cannot

00:31:44,580 --> 00:31:49,920
accept too many topics so there's a

00:31:48,000 --> 00:31:51,330
limitation on the topics and then

00:31:49,920 --> 00:31:54,840
there's a limitation on the device

00:31:51,330 --> 00:32:00,750
numbers so that's where we are today in

00:31:54,840 --> 00:32:05,870
terms of in terms of comparison with

00:32:00,750 --> 00:32:08,480
MQTT and Kafka but by by no means are we

00:32:05,870 --> 00:32:12,630
diminishing their their existence or are

00:32:08,480 --> 00:32:15,740
trying to make them look bad in fact

00:32:12,630 --> 00:32:18,290
we're working so we're working

00:32:15,740 --> 00:32:22,190
couple of projects one is adapters or

00:32:18,290 --> 00:32:26,720
gateways to MQTT one is the gateways to

00:32:22,190 --> 00:32:30,190
Kafka so as long as our devices can can

00:32:26,720 --> 00:32:32,300
be reactive we can have a better

00:32:30,190 --> 00:32:34,640
performance we can have a better

00:32:32,300 --> 00:32:40,429
architecture and it's going to benefit

00:32:34,640 --> 00:32:42,920
everyone so that's pretty much the

00:32:40,429 --> 00:32:45,650
content that I would like to share in

00:32:42,920 --> 00:32:47,300
terms of our socket itself it's the open

00:32:45,650 --> 00:32:51,740
source project

00:32:47,300 --> 00:32:54,200
it starts from a spec right so the so

00:32:51,740 --> 00:32:59,020
the founders actually saw this ooh they

00:32:54,200 --> 00:33:01,580
were thinking of different use cases for

00:32:59,020 --> 00:33:04,429
communication models and they wrote it

00:33:01,580 --> 00:33:06,860
down so there's a protocol our socket

00:33:04,429 --> 00:33:10,100
protocols back and there's a routing

00:33:06,860 --> 00:33:14,110
spec which is for broker and you can

00:33:10,100 --> 00:33:17,600
check out the website and welcome to

00:33:14,110 --> 00:33:21,200
join us to join us as commanderies

00:33:17,600 --> 00:33:25,490
contributors right now it has different

00:33:21,200 --> 00:33:29,179
SDKs there's Java there's c+ person

00:33:25,490 --> 00:33:31,850
there's JavaScript and dotnet and

00:33:29,179 --> 00:33:34,700
there's a goal and and we're working on

00:33:31,850 --> 00:33:37,700
rust so there are different languages

00:33:34,700 --> 00:33:39,500
that support it and the exciting thing

00:33:37,700 --> 00:33:42,620
is we're becoming a member of linux

00:33:39,500 --> 00:33:44,450
foundation we're gonna have sub

00:33:42,620 --> 00:33:48,230
foundation under linux foundation and

00:33:44,450 --> 00:33:52,040
that announcement would be next Tuesday

00:33:48,230 --> 00:33:56,030
also so you might get that notification

00:33:52,040 --> 00:33:58,150
if you subscribe to that and yeah during

00:33:56,030 --> 00:34:02,330
the conference we might have some

00:33:58,150 --> 00:34:04,580
release press releases I'm not sure to

00:34:02,330 --> 00:34:07,730
get but hopefully that's going to be

00:34:04,580 --> 00:34:10,970
enough information to get you guys the

00:34:07,730 --> 00:34:14,540
motivation to try it out all right so

00:34:10,970 --> 00:34:19,909
that's what I have for today

00:34:14,540 --> 00:34:22,570
any questions comments feedbacks yes

00:34:19,909 --> 00:34:22,570
please go ahead

00:34:29,940 --> 00:34:34,419
exactly

00:34:32,040 --> 00:34:37,149
fantastic thank you so you're thinking

00:34:34,419 --> 00:34:39,610
ahead so the question was how do you

00:34:37,149 --> 00:34:41,889
scale the brokers so it can connect

00:34:39,610 --> 00:34:44,080
multiple thousands or millions of

00:34:41,889 --> 00:34:46,120
devices so there are couple things one

00:34:44,080 --> 00:34:48,220
is remember that one device has only one

00:34:46,120 --> 00:34:52,690
connection and the connection is pretty

00:34:48,220 --> 00:34:58,210
small so we've tried very conservatively

00:34:52,690 --> 00:35:03,220
one box can can easily support more than

00:34:58,210 --> 00:35:07,750
10,000 devices so that's a that's a cou

00:35:03,220 --> 00:35:10,900
fact another thing is so you have when

00:35:07,750 --> 00:35:12,550
you have a cluster of brokers you have

00:35:10,900 --> 00:35:16,480
you need to have a mechanism to

00:35:12,550 --> 00:35:19,710
synchronize them and that's that's

00:35:16,480 --> 00:35:24,150
something that has to be done either at

00:35:19,710 --> 00:35:27,970
commercial level or you have to somewhat

00:35:24,150 --> 00:35:30,730
customize it like right now we have a

00:35:27,970 --> 00:35:34,440
basic broker that's going to be open

00:35:30,730 --> 00:35:36,610
source there are commercial grade

00:35:34,440 --> 00:35:41,200
custer's of brokers that's available

00:35:36,610 --> 00:35:44,430
down by a start-up so that actually you

00:35:41,200 --> 00:35:49,180
can you can basically have a cluster of

00:35:44,430 --> 00:35:53,020
couple hundred if not more so what it

00:35:49,180 --> 00:35:55,950
does is it opens another port to each

00:35:53,020 --> 00:35:59,050
other and then they are basically

00:35:55,950 --> 00:36:02,230
exchanging information using UDP but

00:35:59,050 --> 00:36:05,290
it's still on our socket so they they're

00:36:02,230 --> 00:36:08,200
exchanging information in the same

00:36:05,290 --> 00:36:09,970
asynchronous and non-blocking way so

00:36:08,200 --> 00:36:13,090
that it doesn't block too much of their

00:36:09,970 --> 00:36:15,100
their performances so they have I think

00:36:13,090 --> 00:36:17,530
they have benchmarked a couple hundred

00:36:15,100 --> 00:36:23,520
brokers in a cluster and that's that's

00:36:17,530 --> 00:36:23,520
fine other questions yes

00:36:58,010 --> 00:37:02,930
I'm not sure about how small the devices

00:37:01,130 --> 00:37:05,690
you are talking about but so the

00:37:02,930 --> 00:37:09,140
question is that they'd only run on like

00:37:05,690 --> 00:37:12,920
Linux enabled devices or it can be small

00:37:09,140 --> 00:37:16,099
so it really depends on your device so

00:37:12,920 --> 00:37:19,910
right now we have SDKs right returning

00:37:16,099 --> 00:37:22,700
those languages so you your device has

00:37:19,910 --> 00:37:25,760
somehow to be able to compile and run

00:37:22,700 --> 00:37:27,680
those code right you have to be able to

00:37:25,760 --> 00:37:31,520
run those code that's generated the

00:37:27,680 --> 00:37:33,319
binary that's generated you can you can

00:37:31,520 --> 00:37:35,869
compile somewhere else and then load it

00:37:33,319 --> 00:37:40,339
I don't know if that's gonna make things

00:37:35,869 --> 00:37:44,240
easier but as a protocol itself our

00:37:40,339 --> 00:37:46,970
socket is not just for IO T's like I

00:37:44,240 --> 00:37:49,970
said that's good for micro services it's

00:37:46,970 --> 00:37:53,960
good for on any distributed environment

00:37:49,970 --> 00:37:59,710
is good for devices as well but it's not

00:37:53,960 --> 00:38:03,230
limited to devices as long as it can be

00:37:59,710 --> 00:38:05,839
accepted on the device right so before

00:38:03,230 --> 00:38:09,220
coming here I was trying to set up the

00:38:05,839 --> 00:38:11,839
demo on one of those surveys

00:38:09,220 --> 00:38:14,809
surveillance cameras so that we can have

00:38:11,839 --> 00:38:17,029
a stream of videos but then I realized

00:38:14,809 --> 00:38:19,460
that I cannot program on those science

00:38:17,029 --> 00:38:22,190
and it's already pre-programmed so if

00:38:19,460 --> 00:38:25,880
the device manufactures supporters then

00:38:22,190 --> 00:38:30,160
we we definitely can have a better use

00:38:25,880 --> 00:38:30,160
case on those devices yeah

00:38:30,309 --> 00:38:40,100
any other questions nope

00:38:35,799 --> 00:38:43,150
alrighty thank you very much and

00:38:40,100 --> 00:38:43,150

YouTube URL: https://www.youtube.com/watch?v=OTUawzdqWNY


