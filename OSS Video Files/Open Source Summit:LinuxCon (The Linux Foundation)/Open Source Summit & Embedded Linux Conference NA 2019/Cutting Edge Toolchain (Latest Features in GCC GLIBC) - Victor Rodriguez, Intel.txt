Title: Cutting Edge Toolchain (Latest Features in GCC GLIBC) - Victor Rodriguez, Intel
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	Cutting Edge Toolchain (Latest Features in GCC/GLIBC) - Victor Rodriguez, Intel

Toolchain technology is a day to day tool used by Linux developers. The core system of this technology is released every year (GLIBC twice a year). However, what new technology is being implemented on these releases? How can we as Linux developers can take advantage of these new features? This presentation aims to show an introduction to the major features released in GCC 8/9 and Glibc 2.29. Recent compilers came with new features and performance optimizations including various improvements in the diagnostics, Inter-procedural optimization improvements, Link-time optimization improvements and even fcf-protection for security attacks. At the same time, the glibc came with changes such as getcpu wrapper function has been added, which returns the currently used CPU and NUMA node. Having a better understanding of the toolchains allows showcasing the best of CPU architecture technology, from low-level kernel features to complex applications which span the entire operating system
Captions: 
	00:00:00,030 --> 00:00:08,280
hello I want to stir this presentation

00:00:02,419 --> 00:00:11,280
here well thanks I want to start this

00:00:08,280 --> 00:00:15,780
presentation with a simple question do

00:00:11,280 --> 00:00:18,420
you know that in a Linux system only the

00:00:15,780 --> 00:00:21,270
kernel and the browser has much more

00:00:18,420 --> 00:00:23,730
lines of codes that the compiler that

00:00:21,270 --> 00:00:26,160
was built that was used to build those

00:00:23,730 --> 00:00:28,680
tools how many lines of code so you

00:00:26,160 --> 00:00:35,010
think that a compiler usually has in

00:00:28,680 --> 00:00:37,530
this case GCC compiler I was in the

00:00:35,010 --> 00:00:40,890
other presentation and it was a nice

00:00:37,530 --> 00:00:43,649
graph about we have almost 25 more than

00:00:40,890 --> 00:00:51,059
25 million lines of code today in the

00:00:43,649 --> 00:00:53,579
kernel so any guess for GCC compiler GCC

00:00:51,059 --> 00:00:58,800
compilers around 50 millions lines of

00:00:53,579 --> 00:01:01,260
code laws and I ran a simple test for a

00:00:58,800 --> 00:01:03,840
gait analysis of the repository I clone

00:01:01,260 --> 00:01:06,600
it straightforward git clone do the

00:01:03,840 --> 00:01:09,140
analysis and this was a nice big nice

00:01:06,600 --> 00:01:14,310
graph with matplotlib that was generated

00:01:09,140 --> 00:01:16,590
sorry giving Ginny blood and it came to

00:01:14,310 --> 00:01:19,590
me the reason of why starting this

00:01:16,590 --> 00:01:22,140
presentation with this graph a week ago

00:01:19,590 --> 00:01:24,540
I was reading this article how much does

00:01:22,140 --> 00:01:26,520
a compiler cost and it's a nice blog

00:01:24,540 --> 00:01:28,950
talking about the importance of a

00:01:26,520 --> 00:01:31,140
compilers in today's world how much a

00:01:28,950 --> 00:01:33,420
compiler can affect our lives and how

00:01:31,140 --> 00:01:35,490
much a compiler can trust sent to the

00:01:33,420 --> 00:01:37,970
performance security and functionality

00:01:35,490 --> 00:01:41,100
of the software that we build every day

00:01:37,970 --> 00:01:44,189
the tool that I use with get stats on

00:01:41,100 --> 00:01:46,140
their graph we can see that every year

00:01:44,189 --> 00:01:51,119
the lines of code yes there was a

00:01:46,140 --> 00:01:54,570
cleanup yes at some point yes there is

00:01:51,119 --> 00:01:56,250
always a bat in a graph I know that but

00:01:54,570 --> 00:01:59,640
the numbers of lines have coded we have

00:01:56,250 --> 00:02:02,520
seen in the last I don't know four or

00:01:59,640 --> 00:02:05,790
five years has been amazing in terms of

00:02:02,520 --> 00:02:08,039
how much in cream increment on lines of

00:02:05,790 --> 00:02:09,959
code commits a new feature are

00:02:08,039 --> 00:02:12,709
implemented for the for our compilers

00:02:09,959 --> 00:02:12,709
every year

00:02:15,590 --> 00:02:21,990
I'm not gonna show all the patches that

00:02:19,800 --> 00:02:24,870
are outside I'm just gonna try to show

00:02:21,990 --> 00:02:27,960
you some of the useful tools that the

00:02:24,870 --> 00:02:31,530
compiler and the being--you deals or

00:02:27,960 --> 00:02:34,770
Jesus or gilepsy already have by now in

00:02:31,530 --> 00:02:37,140
the last two three years and this is a

00:02:34,770 --> 00:02:41,040
story that I want to connect with you in

00:02:37,140 --> 00:02:44,460
terms of my personal story before being

00:02:41,040 --> 00:02:46,530
a compiler developer and linker

00:02:44,460 --> 00:02:49,410
developer where it's the two communities

00:02:46,530 --> 00:02:51,780
that I work more I used to work in a

00:02:49,410 --> 00:02:54,660
hardware store with my parents and it

00:02:51,780 --> 00:02:56,460
was nice that every carpenter or every

00:02:54,660 --> 00:02:59,400
hardware you came to me and say hey I

00:02:56,460 --> 00:03:00,720
need a tool for this kind of activity so

00:02:59,400 --> 00:03:02,340
I needed to look in the catalog and

00:03:00,720 --> 00:03:05,490
search for the best tool that fulfills

00:03:02,340 --> 00:03:08,760
the needs for that person little is the

00:03:05,490 --> 00:03:10,740
same of what we have here I was looking

00:03:08,760 --> 00:03:13,560
for a definition of a sort of a tool

00:03:10,740 --> 00:03:15,600
change the tool change is a bunch of

00:03:13,560 --> 00:03:18,000
tools that we give to the software

00:03:15,600 --> 00:03:20,610
developers so they can build much more

00:03:18,000 --> 00:03:23,580
complex system and launch it to our

00:03:20,610 --> 00:03:25,500
world in different ways we have scenes

00:03:23,580 --> 00:03:28,830
in today keynotes held in US exchange in

00:03:25,500 --> 00:03:33,180
the world in terms of graphics data

00:03:28,830 --> 00:03:36,600
analytics big data and more things so

00:03:33,180 --> 00:03:39,510
what is a tool change today we know GCC

00:03:36,600 --> 00:03:41,910
we know gilepsy but there are much more

00:03:39,510 --> 00:03:44,280
stuffs we have we need to have a

00:03:41,910 --> 00:03:45,959
debugger without a debugger it's almost

00:03:44,280 --> 00:03:48,740
impossible to think that we can go and

00:03:45,959 --> 00:03:51,000
develop right we need to have a linker

00:03:48,740 --> 00:03:52,770
once the process is running on our

00:03:51,000 --> 00:03:54,380
operating system we need to link the

00:03:52,770 --> 00:03:58,110
libraries that we're going to be using

00:03:54,380 --> 00:04:00,050
the assembly or disassembly okay in this

00:03:58,110 --> 00:04:06,750
case is a gene you guess that we have

00:04:00,050 --> 00:04:10,050
the binary util is gnu binutils emulator

00:04:06,750 --> 00:04:12,810
libraries the standard c library that

00:04:10,050 --> 00:04:15,239
whether we like it or not it's there and

00:04:12,810 --> 00:04:17,880
yes there are much more options and we

00:04:15,239 --> 00:04:20,730
love G Lib C because it's always there

00:04:17,880 --> 00:04:24,090
for us otherwise we will be having to

00:04:20,730 --> 00:04:24,720
develop the name sine and cosine by

00:04:24,090 --> 00:04:27,300
ourselves

00:04:24,720 --> 00:04:30,660
every time that we need it right

00:04:27,300 --> 00:04:34,650
and of course yes the the complainer is

00:04:30,660 --> 00:04:36,599
the first one that we use mostly so what

00:04:34,650 --> 00:04:40,259
have we built with these tools

00:04:36,599 --> 00:04:42,509
almost the world we have built operating

00:04:40,259 --> 00:04:44,819
system kernel image processing libraries

00:04:42,509 --> 00:04:48,840
web server side scripting language PHP

00:04:44,819 --> 00:04:51,930
is Bill with GCC by definition right we

00:04:48,840 --> 00:04:54,599
build OpenCV we build a kernel we build

00:04:51,930 --> 00:04:58,440
you you name it there are many projects

00:04:54,599 --> 00:05:02,389
that are de facto compiler right now and

00:04:58,440 --> 00:05:07,139
yes I have very good friends in Incline

00:05:02,389 --> 00:05:10,740
salon and LBM yes and I as Greg said one

00:05:07,139 --> 00:05:12,509
day we love the fact that there are much

00:05:10,740 --> 00:05:15,690
more people trying to develop another

00:05:12,509 --> 00:05:17,729
tool chips it force us to be better as a

00:05:15,690 --> 00:05:19,949
community and also give us the

00:05:17,729 --> 00:05:21,719
capability to have much more options we

00:05:19,949 --> 00:05:25,139
love the idea we are friends the two

00:05:21,719 --> 00:05:26,699
communities so the first tool that I

00:05:25,139 --> 00:05:28,940
want to talk to you it's about security

00:05:26,699 --> 00:05:31,770
in the morning REM was talking about

00:05:28,940 --> 00:05:33,930
security is a factor there is no way

00:05:31,770 --> 00:05:36,900
that we can argue with customers to say

00:05:33,930 --> 00:05:38,699
well I can give you good density or good

00:05:36,900 --> 00:05:41,490
performance but security is gonna be

00:05:38,699 --> 00:05:46,770
like no way nobody wants to be attacked

00:05:41,490 --> 00:05:48,900
today by anything first of the tools

00:05:46,770 --> 00:05:51,509
that I want to present to you is FC

00:05:48,900 --> 00:05:53,310
protection there are many kinds of

00:05:51,509 --> 00:05:54,659
security vulnerabilities we have since

00:05:53,310 --> 00:05:56,310
if you dribble the melodies in terms of

00:05:54,659 --> 00:05:58,979
hardware I will not talk about those

00:05:56,310 --> 00:06:01,590
kind of things I will need an entire lot

00:05:58,979 --> 00:06:03,690
of speech for that okay but the kind of

00:06:01,590 --> 00:06:05,969
attacks that if I will talk to you it's

00:06:03,690 --> 00:06:08,539
about the return oriented programming

00:06:05,969 --> 00:06:11,009
and clamp call Jam oriented programming

00:06:08,539 --> 00:06:15,719
those are very horrible kind of

00:06:11,009 --> 00:06:20,250
vulnerabilities well GCC eight helps to

00:06:15,719 --> 00:06:23,340
fix those kind of things this is a very

00:06:20,250 --> 00:06:25,169
simple arrow P attack okay

00:06:23,340 --> 00:06:27,449
for those that have never seen an arrow

00:06:25,169 --> 00:06:29,460
P attacks voila this is a picture of an

00:06:27,449 --> 00:06:32,729
arrow pre attack we will have a simple

00:06:29,460 --> 00:06:34,319
main with a simple functioning echo and

00:06:32,729 --> 00:06:36,029
there is a secret function yes I know

00:06:34,319 --> 00:06:38,370
it's very simple it's just for academic

00:06:36,029 --> 00:06:40,150
purpose nobody does this nobody call the

00:06:38,370 --> 00:06:43,450
function secret function

00:06:40,150 --> 00:06:44,860
the object them will be very easy to

00:06:43,450 --> 00:06:47,380
attack that functions like come on

00:06:44,860 --> 00:06:50,380
attack me but it's just for academic

00:06:47,380 --> 00:06:55,450
purpose so we will have in a scan of a

00:06:50,380 --> 00:06:57,160
buffer whose size is 20 yes good but

00:06:55,450 --> 00:06:58,930
with the scan which is by the way when

00:06:57,160 --> 00:07:01,240
you compile is the compiler by itself

00:06:58,930 --> 00:07:03,220
say please don't use this thing I mean

00:07:01,240 --> 00:07:07,420
there are better things to read from the

00:07:03,220 --> 00:07:10,150
user space at a scan this is a call

00:07:07,420 --> 00:07:12,820
security of an entire hole in security

00:07:10,150 --> 00:07:14,230
right and we will see why for some of

00:07:12,820 --> 00:07:18,580
the audiences that have never seen an

00:07:14,230 --> 00:07:21,790
arrow P attack so if I run this pretty

00:07:18,580 --> 00:07:24,160
beautiful simple to line to execute I

00:07:21,790 --> 00:07:25,690
use Python just for today for I don't

00:07:24,160 --> 00:07:27,670
want to type too many times the same

00:07:25,690 --> 00:07:33,310
character but what am I going to do it's

00:07:27,670 --> 00:07:36,940
print a 32 times the 32 Kames out

00:07:33,310 --> 00:07:41,680
because 28 plus 4 is the 32 bits that

00:07:36,940 --> 00:07:44,920
are necessary to put my specific address

00:07:41,680 --> 00:07:47,620
where I want to go into the space of

00:07:44,920 --> 00:07:49,810
memory that I want to overlap and

00:07:47,620 --> 00:07:51,580
rewrite instead of the current return

00:07:49,810 --> 00:07:53,740
address that I used to have that is the

00:07:51,580 --> 00:07:55,840
quarter of the return oriented

00:07:53,740 --> 00:07:57,370
programming the base of that is the

00:07:55,840 --> 00:08:00,730
buffer overflow so what I'm going to do

00:07:57,370 --> 00:08:03,400
it's pass that string plus at the end

00:08:00,730 --> 00:08:05,470
another address which in this case is

00:08:03,400 --> 00:08:07,660
the address of secret function how do I

00:08:05,470 --> 00:08:09,790
know because with a simple object Dom it

00:08:07,660 --> 00:08:12,010
was pretty easy to me to say oh secret

00:08:09,790 --> 00:08:13,810
function so I need to go there so hint

00:08:12,010 --> 00:08:16,720
number 1 never put your function secret

00:08:13,810 --> 00:08:19,540
function and I pass that to my both

00:08:16,720 --> 00:08:22,120
binary so yeah it's gonna be very easy

00:08:19,540 --> 00:08:24,340
if you execute that into your Linux

00:08:22,120 --> 00:08:27,490
system the only thing that I had to do

00:08:24,340 --> 00:08:29,530
with compile with - M 32 in M 64 is way

00:08:27,490 --> 00:08:31,150
much more complicated it's possible to

00:08:29,530 --> 00:08:33,030
do the same thing but for academic

00:08:31,150 --> 00:08:35,560
purpose it's way much more complicated

00:08:33,030 --> 00:08:36,790
on the slides that I will upload at the

00:08:35,560 --> 00:08:38,500
end of the presentation there is the

00:08:36,790 --> 00:08:41,950
link of the source code that you can use

00:08:38,500 --> 00:08:46,120
and follow the same approach so yeah it

00:08:41,950 --> 00:08:48,760
put the 32 32 bytes enter in this in

00:08:46,120 --> 00:08:51,430
this bunch of a's and at the end the

00:08:48,760 --> 00:08:53,860
address that I want to pass and it will

00:08:51,430 --> 00:08:55,329
print as we saw in the previous code

00:08:53,860 --> 00:08:57,220
congratulation you have entered to the

00:08:55,329 --> 00:08:59,110
secret function nobody calls that

00:08:57,220 --> 00:09:01,540
function yet I'm able to do that

00:08:59,110 --> 00:09:03,519
um I said well that is not an error of P

00:09:01,540 --> 00:09:06,550
attack yes I know but it's just the

00:09:03,519 --> 00:09:08,829
basic to understand how does it work we

00:09:06,550 --> 00:09:10,899
can pass instead of a simple address of

00:09:08,829 --> 00:09:13,990
a function that I want to execute I can

00:09:10,899 --> 00:09:16,480
put much more execution things that I

00:09:13,990 --> 00:09:20,320
want that CPU to do for example in this

00:09:16,480 --> 00:09:23,410
case I'm passing to a en X the value of

00:09:20,320 --> 00:09:24,640
10 and then returning the point here of

00:09:23,410 --> 00:09:28,209
an arrow P attack it's

00:09:24,640 --> 00:09:30,370
I can I can overwrite instead of going

00:09:28,209 --> 00:09:33,820
to the current flow that I used to have

00:09:30,370 --> 00:09:36,040
to wherever I want to go and there are

00:09:33,820 --> 00:09:38,140
good friends over there that put shell

00:09:36,040 --> 00:09:40,149
code database for history cases so if

00:09:38,140 --> 00:09:45,190
you go to that web page you will have

00:09:40,149 --> 00:09:47,050
been bash or shell or you name it there

00:09:45,190 --> 00:09:50,920
are many kind of examples that you can

00:09:47,050 --> 00:09:52,600
use and instead of passing the address

00:09:50,920 --> 00:09:55,269
of another function that you want to

00:09:52,600 --> 00:09:57,370
call you can actually point to an

00:09:55,269 --> 00:10:00,430
external binary that you want to execute

00:09:57,370 --> 00:10:03,130
and you can get rid privileged access to

00:10:00,430 --> 00:10:06,130
your system you can do many harmful

00:10:03,130 --> 00:10:09,070
things with this kind of attacks these

00:10:06,130 --> 00:10:11,589
are called gadgets well

00:10:09,070 --> 00:10:14,500
Hajis EC introduced a new option for

00:10:11,589 --> 00:10:19,990
these FC protection full branch return

00:10:14,500 --> 00:10:21,699
and none these kind of technology it's

00:10:19,990 --> 00:10:24,279
based on something that we call control

00:10:21,699 --> 00:10:27,430
flow and force technology for a shorter

00:10:24,279 --> 00:10:28,959
name set technology which the good thing

00:10:27,430 --> 00:10:31,420
is that I think that will be available

00:10:28,959 --> 00:10:33,660
by this year in terms of CPU

00:10:31,420 --> 00:10:36,310
architecture and there are two kinds of

00:10:33,660 --> 00:10:38,079
approaches for set technology one we

00:10:36,310 --> 00:10:42,820
will see is a new instruction and the

00:10:38,079 --> 00:10:45,699
other one is a shadow stack how does it

00:10:42,820 --> 00:10:48,490
work this kind of thing the FC

00:10:45,699 --> 00:10:53,920
protection checks for a Bali target

00:10:48,490 --> 00:10:56,680
address and these will try to have an

00:10:53,920 --> 00:10:59,370
instrumentation inside your code and do

00:10:56,680 --> 00:11:02,170
two kind of things in this case it's

00:10:59,370 --> 00:11:03,970
preventing from diverge from the current

00:11:02,170 --> 00:11:07,270
return that you're trying to access

00:11:03,970 --> 00:11:08,000
which detects that it's malicious to the

00:11:07,270 --> 00:11:10,510
actual the

00:11:08,000 --> 00:11:13,070
you supposed to be going in that point

00:11:10,510 --> 00:11:16,130
so I like this picture

00:11:13,070 --> 00:11:18,710
imagine that you we have a single stack

00:11:16,130 --> 00:11:20,930
pointer and program counter so the

00:11:18,710 --> 00:11:24,320
program counters goes into the wreath

00:11:20,930 --> 00:11:26,990
world the scan it has a stack pointer

00:11:24,320 --> 00:11:29,510
plus 20 and we have enough 20 spaces and

00:11:26,990 --> 00:11:30,020
we started to write hello world at this

00:11:29,510 --> 00:11:33,350
point

00:11:30,020 --> 00:11:35,600
and suddenly we put instead of the eight

00:11:33,350 --> 00:11:38,750
eight hundred four or eight thousand

00:11:35,600 --> 00:11:41,870
four to eight thousand one so the stack

00:11:38,750 --> 00:11:43,910
pointer will go into here the red which

00:11:41,870 --> 00:11:46,400
is the next program counter where it

00:11:43,910 --> 00:11:49,610
will go check the address of here and

00:11:46,400 --> 00:11:52,010
will go straight forward to a a thousand

00:11:49,610 --> 00:11:54,050
one that is a picture of how does the

00:11:52,010 --> 00:11:56,780
return harm could happen into your

00:11:54,050 --> 00:11:58,820
binary what this technology is trying to

00:11:56,780 --> 00:12:00,890
do its preventing the flow control to do

00:11:58,820 --> 00:12:03,020
and expect the target the text that hey

00:12:00,890 --> 00:12:05,510
wait a minute you're supposed to go to a

00:12:03,020 --> 00:12:08,300
thousand four and now you're going to a

00:12:05,510 --> 00:12:11,480
thousand one how does it work in terms

00:12:08,300 --> 00:12:13,010
well first of all let's check what are

00:12:11,480 --> 00:12:16,490
the full options that we have full

00:12:13,010 --> 00:12:18,680
branch with Karen on the Bali branch

00:12:16,490 --> 00:12:22,760
tells a compiler to implement checking

00:12:18,680 --> 00:12:25,550
on the branch branch indirect branch

00:12:22,760 --> 00:12:28,880
instructions for example call or jumps

00:12:25,550 --> 00:12:32,540
instructions the value return implements

00:12:28,880 --> 00:12:35,390
checking from a function and the value

00:12:32,540 --> 00:12:38,210
full it's going to be both of them on

00:12:35,390 --> 00:12:41,240
the function and on the branch by

00:12:38,210 --> 00:12:43,550
definition the value none will turn off

00:12:41,240 --> 00:12:44,780
this kind of implementation mmm it's put

00:12:43,550 --> 00:12:49,060
it just in case somebody wants to

00:12:44,780 --> 00:12:52,970
disable for debugging the control flow

00:12:49,060 --> 00:12:54,890
technology the set technology it will

00:12:52,970 --> 00:12:57,500
have two things the shadow is stack an

00:12:54,890 --> 00:13:00,320
indirect branch prediction indirect

00:12:57,500 --> 00:13:03,560
branch tracking or ivt the shadow stack

00:13:00,320 --> 00:13:05,660
will work in this in the next way we

00:13:03,560 --> 00:13:06,350
will have on a stack that will have a

00:13:05,660 --> 00:13:09,230
return

00:13:06,350 --> 00:13:10,820
read address and that read address is

00:13:09,230 --> 00:13:13,700
going to make for example in the stack a

00:13:10,820 --> 00:13:15,230
call to another function or another jump

00:13:13,700 --> 00:13:17,780
or another branch or another whatever

00:13:15,230 --> 00:13:21,230
you prefer at the end of the execution

00:13:17,780 --> 00:13:23,900
we will have to return address

00:13:21,230 --> 00:13:25,550
one in the new shadow a stack and one in

00:13:23,900 --> 00:13:27,350
the another stack that was supposed to

00:13:25,550 --> 00:13:29,450
have in the original place we are

00:13:27,350 --> 00:13:31,430
creating a different kind of a stack

00:13:29,450 --> 00:13:33,980
which is called the shadow stack to

00:13:31,430 --> 00:13:36,260
compare the two return address if in

00:13:33,980 --> 00:13:39,110
this case the vulnerability of a rope

00:13:36,260 --> 00:13:41,120
happens it will detect comparing and

00:13:39,110 --> 00:13:43,220
saying wait a minute you're supposed to

00:13:41,120 --> 00:13:44,750
come back to these red address not

00:13:43,220 --> 00:13:48,160
you're out telling me that you're coming

00:13:44,750 --> 00:13:51,500
to a different one by having two stacks

00:13:48,160 --> 00:13:54,050
we'll be able to detect if something in

00:13:51,500 --> 00:13:55,910
the execution in the second stack after

00:13:54,050 --> 00:13:58,400
the coal job or whatever a branch you

00:13:55,910 --> 00:14:00,680
preferred to jump was doing some

00:13:58,400 --> 00:14:03,500
malicious code by buffer will flow arrow

00:14:00,680 --> 00:14:05,660
P attack or something else so we will

00:14:03,500 --> 00:14:08,270
have to stack sand we will save the to

00:14:05,660 --> 00:14:10,250
address in two places to say okay if

00:14:08,270 --> 00:14:12,050
there is a difference something needs to

00:14:10,250 --> 00:14:14,720
screw something is completely wrong and

00:14:12,050 --> 00:14:17,390
I will export execution of this of this

00:14:14,720 --> 00:14:20,870
point the other thing is the indirect

00:14:17,390 --> 00:14:22,300
branch tracking it literally adds a new

00:14:20,870 --> 00:14:25,700
instruction at the end of the branch

00:14:22,300 --> 00:14:28,940
okay to check that the return code it's

00:14:25,700 --> 00:14:30,980
actually go where it's supposed to go

00:14:28,940 --> 00:14:32,570
and you might be wondering wait a minute

00:14:30,980 --> 00:14:34,820
what happened with might has world

00:14:32,570 --> 00:14:36,680
Westmere or any other hard word that

00:14:34,820 --> 00:14:38,900
it's not with this instruction doesn't

00:14:36,680 --> 00:14:41,600
matter if you execute this thing now it

00:14:38,900 --> 00:14:44,000
will give you an odd operation okay it's

00:14:41,600 --> 00:14:45,620
not harmful just that we will need to

00:14:44,000 --> 00:14:47,600
wait for a real hard word to have that a

00:14:45,620 --> 00:14:49,400
specific instruction but to be honest

00:14:47,600 --> 00:14:51,700
with the shadow a stack is good enough

00:14:49,400 --> 00:14:51,700
for now

00:14:54,790 --> 00:14:59,390
yeah more information about these last

00:14:57,530 --> 00:15:02,780
year and this is what we are trying to

00:14:59,390 --> 00:15:04,520
do in in the tool change community last

00:15:02,780 --> 00:15:06,770
year we joined to the Linux plumber's

00:15:04,520 --> 00:15:09,350
for the very first time and it was a

00:15:06,770 --> 00:15:11,450
moment that my friend hu Lu do a

00:15:09,350 --> 00:15:14,300
presentation about this set technology

00:15:11,450 --> 00:15:16,490
and into the Linux plumbers this year

00:15:14,300 --> 00:15:18,290
there will be another micro conference

00:15:16,490 --> 00:15:20,150
for tool change so that we can

00:15:18,290 --> 00:15:21,760
collaborate even more the two

00:15:20,150 --> 00:15:27,200
communities

00:15:21,760 --> 00:15:30,080
let's count for performance flop

00:15:27,200 --> 00:15:32,510
interchange well I like this of this

00:15:30,080 --> 00:15:34,610
this flag especially the folk

00:15:32,510 --> 00:15:37,550
interchange it's

00:15:34,610 --> 00:15:40,640
the optimization for the nested for that

00:15:37,550 --> 00:15:42,260
we have it's by default enabled with -

00:15:40,640 --> 00:15:44,649
oh tree and you might be a little at

00:15:42,260 --> 00:15:46,730
mean with the point

00:15:44,649 --> 00:15:50,329
Victor you rain embedded Linux

00:15:46,730 --> 00:15:52,550
conference we barely use - OH - but we

00:15:50,329 --> 00:15:55,459
mostly use - OS because we want to do

00:15:52,550 --> 00:15:57,860
our binary small instead of faster it

00:15:55,459 --> 00:16:01,490
was and correct me if I'm wrong that was

00:15:57,860 --> 00:16:04,370
true 10 years ago today embedded it's

00:16:01,490 --> 00:16:08,899
not only about size but also about a

00:16:04,370 --> 00:16:12,680
speed so let's take the first example

00:16:08,899 --> 00:16:15,410
imagine that you have to force one of

00:16:12,680 --> 00:16:17,540
the in this case Y is going to 100 an X

00:16:15,410 --> 00:16:18,980
is going to 1,000 increasingly

00:16:17,540 --> 00:16:21,279
increasingly increasingly increasing

00:16:18,980 --> 00:16:24,560
increasing going forward for forward and

00:16:21,279 --> 00:16:27,860
we will talk about doing a

00:16:24,560 --> 00:16:30,200
multiplication of X by Y and assign it

00:16:27,860 --> 00:16:35,950
to the value that we have in this case

00:16:30,200 --> 00:16:38,870
again what we want in software is this

00:16:35,950 --> 00:16:40,220
what they actually hardware it's going

00:16:38,870 --> 00:16:42,800
to be a little bit different and we need

00:16:40,220 --> 00:16:45,740
to be aware of how does a loop stick you

00:16:42,800 --> 00:16:47,779
might be wondering well if I do these

00:16:45,740 --> 00:16:52,940
one side or the other it shouldn't

00:16:47,779 --> 00:16:56,000
affect to me actually it does we have a

00:16:52,940 --> 00:16:58,670
CPU and we have a cache memory and the

00:16:56,000 --> 00:17:01,760
main memory suppose that we have to go

00:16:58,670 --> 00:17:06,650
to the main memory for the real data to

00:17:01,760 --> 00:17:07,790
the cache memory as a beginning what

00:17:06,650 --> 00:17:11,059
we're going to be reading with this

00:17:07,790 --> 00:17:16,370
approach is going to be kate 0 0 1 0 2 0

00:17:11,059 --> 00:17:18,770
& 3 0 we read the memory by little bunch

00:17:16,370 --> 00:17:21,709
of data instead of a lot of like a line

00:17:18,770 --> 00:17:24,049
so we will have first the cpu it's gonna

00:17:21,709 --> 00:17:27,290
have in cash these first lines from the

00:17:24,049 --> 00:17:32,230
Parana main memory and ok it's nice I

00:17:27,290 --> 00:17:35,270
have K 0 wait a minute now I need K 1.0

00:17:32,230 --> 00:17:37,220
so it's not in my cache line I have to

00:17:35,270 --> 00:17:39,530
go for another cache line so I have to

00:17:37,220 --> 00:17:43,160
go to the main memory bring it back a

00:17:39,530 --> 00:17:46,460
different one and discard is one I spent

00:17:43,160 --> 00:17:47,539
CPU time going to the main memory bring

00:17:46,460 --> 00:17:49,989
it up them to the

00:17:47,539 --> 00:17:56,899
cash and not using just for one single

00:17:49,989 --> 00:17:59,149
you need memory facts when the processor

00:17:56,899 --> 00:18:00,950
access to an array element for the first

00:17:59,149 --> 00:18:03,109
time it retrieves an entire cache line

00:18:00,950 --> 00:18:06,679
of data from the main memory to the

00:18:03,109 --> 00:18:10,970
cache from the memory to the cache if

00:18:06,679 --> 00:18:12,229
the rest of the data is not used sorry

00:18:10,970 --> 00:18:14,090
if the rest of the data will be used

00:18:12,229 --> 00:18:16,789
soon this is a major performing bust

00:18:14,090 --> 00:18:18,739
okay so the most amount of memory that

00:18:16,789 --> 00:18:20,479
we use from in the cache that was

00:18:18,739 --> 00:18:22,609
bringing it from the main memory the

00:18:20,479 --> 00:18:25,340
best is for us because we spend time

00:18:22,609 --> 00:18:27,289
power and anything going to the main

00:18:25,340 --> 00:18:29,090
memory and bring it into the cache so

00:18:27,289 --> 00:18:32,749
it's better that we use that amount of

00:18:29,090 --> 00:18:35,809
data if on the other hand we only use

00:18:32,749 --> 00:18:37,460
very few in I'm like in my example only

00:18:35,809 --> 00:18:42,080
one of the elements from the line that I

00:18:37,460 --> 00:18:44,269
used to have it's a performance lost so

00:18:42,080 --> 00:18:47,659
when we apply the F loop interchange

00:18:44,269 --> 00:18:51,889
flock the code is transform it and now

00:18:47,659 --> 00:18:55,129
we have X 1000 here and Y to the 1 to

00:18:51,889 --> 00:18:59,629
the 100 so the approach is different now

00:18:55,129 --> 00:19:02,809
it's going to be K 0 k 0 1 k 0 to k 0 3

00:18:59,629 --> 00:19:07,070
and there it goes to the K 1 to the K

00:19:02,809 --> 00:19:09,409
almost 1,000 so what happened in

00:19:07,070 --> 00:19:12,950
hardware is that now I am able to access

00:19:09,409 --> 00:19:16,159
to K 0 0 K 0 1 K 0 to K C or a tree

00:19:12,950 --> 00:19:18,889
which is in the same cache line that I

00:19:16,159 --> 00:19:21,889
have over here so I don't have to this

00:19:18,889 --> 00:19:25,119
car of this cache line go back to the

00:19:21,889 --> 00:19:28,159
main memory and come back to cache - I

00:19:25,119 --> 00:19:30,799
can use much more of my memory that I

00:19:28,159 --> 00:19:32,529
have in my cache instead of going that

00:19:30,799 --> 00:19:35,570
many times to the main memory

00:19:32,529 --> 00:19:37,700
ok so highly recommended to use this

00:19:35,570 --> 00:19:40,519
evolute interchange it's one of the main

00:19:37,700 --> 00:19:43,489
reason wide also with - o tree in GCC

00:19:40,519 --> 00:19:45,710
give a very good performance not

00:19:43,489 --> 00:19:47,389
everything it's about vectorization also

00:19:45,710 --> 00:19:53,109
about the way that how do we access the

00:19:47,389 --> 00:19:56,379
memory cares god hoisting optimizations

00:19:53,109 --> 00:19:59,480
partial redundancy elimination PR in

00:19:56,379 --> 00:20:01,549
this lock I see like it's going to check

00:19:59,480 --> 00:20:05,779
my code and tell me where did

00:20:01,549 --> 00:20:06,860
I was very dumped didn't realize that

00:20:05,779 --> 00:20:10,369
couldn't be better

00:20:06,860 --> 00:20:13,909
I joke with my students I forgot to

00:20:10,369 --> 00:20:17,419
mention I give compilers basics on

00:20:13,909 --> 00:20:18,950
University hometown and I joke sometimes

00:20:17,419 --> 00:20:20,090
the compilers are a little bit more

00:20:18,950 --> 00:20:21,320
smart than me

00:20:20,090 --> 00:20:24,529
I mean smart you mean sometimes

00:20:21,320 --> 00:20:27,830
sometimes this is the this is one of the

00:20:24,529 --> 00:20:30,919
cases eliminates unnecessary codes that

00:20:27,830 --> 00:20:32,450
it's not being executed let's take this

00:20:30,919 --> 00:20:34,519
very simple example and I did it

00:20:32,450 --> 00:20:36,919
yesterday for just academic purpose

00:20:34,519 --> 00:20:40,429
don't judge me I know that I suck coding

00:20:36,919 --> 00:20:44,629
so let's go we have a test function in a

00:20:40,429 --> 00:20:47,539
b c and g we defined D&E as any integers

00:20:44,629 --> 00:20:50,419
we check if a anything different than

00:20:47,539 --> 00:20:53,269
zero we go into this path or this branch

00:20:50,419 --> 00:20:57,049
else we here we go to another branch in

00:20:53,269 --> 00:21:00,649
this case and d it's gonna be B minus C

00:20:57,049 --> 00:21:03,080
it's gonna be B multiplied by C I can

00:21:00,649 --> 00:21:05,480
see that I if I calculate one time I can

00:21:03,080 --> 00:21:08,239
reuse in the other case plus gene and

00:21:05,480 --> 00:21:10,340
the end the return is going to be the

00:21:08,239 --> 00:21:13,759
value that I have even for D that will

00:21:10,340 --> 00:21:15,950
diverge according to a plus E which will

00:21:13,759 --> 00:21:17,690
be only accessible in the case of the

00:21:15,950 --> 00:21:19,609
else if I go in through this one it's

00:21:17,690 --> 00:21:22,580
gonna be zero

00:21:19,609 --> 00:21:25,759
if I define it here before or anything

00:21:22,580 --> 00:21:29,059
else and I'm gonna pass one two three

00:21:25,759 --> 00:21:31,820
four not because it's important for the

00:21:29,059 --> 00:21:33,850
code because it was very easy for me put

00:21:31,820 --> 00:21:37,369
it there when I was coding yesterday

00:21:33,850 --> 00:21:39,950
well F code hosting it's on - OH -

00:21:37,369 --> 00:21:41,629
optimization level remember for

00:21:39,950 --> 00:21:43,460
compilers I forgot to mention the

00:21:41,629 --> 00:21:43,909
optimization is a bunch is it like an

00:21:43,460 --> 00:21:46,970
onion

00:21:43,909 --> 00:21:49,309
we have layers so OSI row it's no

00:21:46,970 --> 00:21:50,749
optimization oh one is just the very

00:21:49,309 --> 00:21:53,539
beginning of optimization

00:21:50,749 --> 00:21:55,730
Oh two will be a one plus something else

00:21:53,539 --> 00:21:57,919
Oh tree will be a one or two plus

00:21:55,730 --> 00:21:59,749
something else and that's that's the

00:21:57,919 --> 00:22:02,119
limit we don't add all four there was a

00:21:59,749 --> 00:22:03,529
discussion in the gnu compiler list and

00:22:02,119 --> 00:22:05,779
say do we need a no forum but they say

00:22:03,529 --> 00:22:07,190
no no no Oh tree is good enough right we

00:22:05,779 --> 00:22:08,629
don't want to have that more layer it's

00:22:07,190 --> 00:22:11,460
not a cake

00:22:08,629 --> 00:22:14,970
also these flag gets in its import

00:22:11,460 --> 00:22:17,580
to mention that it's in in - Oh s okay

00:22:14,970 --> 00:22:20,159
so it's also possible to use these for

00:22:17,580 --> 00:22:22,500
doing a small OS s stands for small

00:22:20,159 --> 00:22:24,990
binaries that we want to generate so

00:22:22,500 --> 00:22:29,460
these are the object dumps of the same

00:22:24,990 --> 00:22:33,419
test function executed in my Linux

00:22:29,460 --> 00:22:36,960
system and let's go straight forward in

00:22:33,419 --> 00:22:38,850
this case with GCC hosting - oh one

00:22:36,960 --> 00:22:42,690
which will avoid the use of that a

00:22:38,850 --> 00:22:45,659
specific flock I'm doing in this case

00:22:42,690 --> 00:22:47,669
two times the multiplication doing a

00:22:45,659 --> 00:22:49,710
comparison and then doing the addition

00:22:47,669 --> 00:22:52,770
okay I'm sorry the comparison is here

00:22:49,710 --> 00:22:54,480
and then doing the addition of this case

00:22:52,770 --> 00:22:57,720
at the addition that we see at the end

00:22:54,480 --> 00:23:01,039
of the plus e in this case with hoisting

00:22:57,720 --> 00:23:03,750
- OH - we are just doing one single

00:23:01,039 --> 00:23:07,409
multiplication and the addition over

00:23:03,750 --> 00:23:09,570
here we are reducing the amount of times

00:23:07,409 --> 00:23:11,490
that we are doing the multiplication by

00:23:09,570 --> 00:23:15,059
definition and doing way much more or

00:23:11,490 --> 00:23:17,309
less comparison okay so hosting is going

00:23:15,059 --> 00:23:18,960
to transform first of all yes it

00:23:17,309 --> 00:23:21,450
transformed the code that I'm going to

00:23:18,960 --> 00:23:23,850
pass through the CPU and it also

00:23:21,450 --> 00:23:25,559
eliminates redundancy in terms of how

00:23:23,850 --> 00:23:27,919
many instruction the CPU needs to

00:23:25,559 --> 00:23:32,820
generate the compiler is the last

00:23:27,919 --> 00:23:35,100
defense against bad code to the actual

00:23:32,820 --> 00:23:37,049
CPU CPU are not very smart they will

00:23:35,100 --> 00:23:39,779
only execute in every time that a

00:23:37,049 --> 00:23:42,630
scheduler deploy a process all the code

00:23:39,779 --> 00:23:44,340
that we want so it's a responsibility of

00:23:42,630 --> 00:23:49,679
the compiler to provide the best code to

00:23:44,340 --> 00:23:51,659
the CPU this is another one and this is

00:23:49,679 --> 00:23:54,210
not for the compiler this is for the DG

00:23:51,659 --> 00:23:56,610
Lipsy I was joking before about whether

00:23:54,210 --> 00:23:59,070
we like it or not gilepsy gillip see

00:23:56,610 --> 00:24:02,429
it's one of the heroes that we have in

00:23:59,070 --> 00:24:04,860
our back supporting us every day it has

00:24:02,429 --> 00:24:08,220
all the sine cosine mathematical things

00:24:04,860 --> 00:24:13,309
piles all the things that we will not be

00:24:08,220 --> 00:24:15,990
willing to do every day it's there right

00:24:13,309 --> 00:24:18,480
one of the optimization that happened in

00:24:15,990 --> 00:24:20,100
the last gee ellipse e sin it was

00:24:18,480 --> 00:24:20,580
introducing in November December of last

00:24:20,100 --> 00:24:22,649
year

00:24:20,580 --> 00:24:25,080
it's the optimization for sine and

00:24:22,649 --> 00:24:27,180
cosine

00:24:25,080 --> 00:24:29,070
I'm not a mathematical the guy so I

00:24:27,180 --> 00:24:30,690
don't know who needs sine and cosine at

00:24:29,070 --> 00:24:35,010
the same time but there is a function

00:24:30,690 --> 00:24:37,080
for that yeah trust me I didn't wanted

00:24:35,010 --> 00:24:39,210
to ask him in the community he said they

00:24:37,080 --> 00:24:41,100
will throw me potatoes but yes there are

00:24:39,210 --> 00:24:42,660
somebody outside in the industry that

00:24:41,100 --> 00:24:45,510
needs sine and cosine at the same time

00:24:42,660 --> 00:24:48,660
and what it's happening right now it's

00:24:45,510 --> 00:24:53,010
instead of doing the approach by

00:24:48,660 --> 00:24:55,740
difficult assembly instructions and you

00:24:53,010 --> 00:24:58,200
can see the patches I put the links in

00:24:55,740 --> 00:25:00,870
the presentation the elimination that

00:24:58,200 --> 00:25:02,340
Rachel did for sine and cosine before

00:25:00,870 --> 00:25:05,310
this optimization - after his

00:25:02,340 --> 00:25:07,740
optimization it's huge it's huge

00:25:05,310 --> 00:25:11,100
right and he's not using vectorization

00:25:07,740 --> 00:25:13,350
or yes he's doing function fuse

00:25:11,100 --> 00:25:14,700
multiplication addition but the reason

00:25:13,350 --> 00:25:17,400
why he's doing phase multiplication

00:25:14,700 --> 00:25:20,700
addition is because he's using the

00:25:17,400 --> 00:25:23,910
Taylor approximation so now sine and

00:25:20,700 --> 00:25:25,850
cosine from jilly c220 2.29

00:25:23,910 --> 00:25:29,160
he's going to use taylor approximation

00:25:25,850 --> 00:25:31,770
for going into them to know exactly the

00:25:29,160 --> 00:25:33,690
value that I'm asking for I pass through

00:25:31,770 --> 00:25:37,050
the sine and cosine function the angle

00:25:33,690 --> 00:25:38,760
that I want to or the radiant variable

00:25:37,050 --> 00:25:39,390
that I want to calculate for sine and

00:25:38,760 --> 00:25:42,120
cosine

00:25:39,390 --> 00:25:44,250
he needs to need to returns to me the

00:25:42,120 --> 00:25:46,530
value of sine and cosine that's the only

00:25:44,250 --> 00:25:48,540
job that has to do well and now instead

00:25:46,530 --> 00:25:50,750
of doing with heavy mathematical things

00:25:48,540 --> 00:25:53,360
it's gonna go with Taylor approximation

00:25:50,750 --> 00:25:58,410
which is to be completely honest

00:25:53,360 --> 00:26:01,830
divisions multiplications nothing that

00:25:58,410 --> 00:26:03,990
complicated okay and there are good

00:26:01,830 --> 00:26:07,200
papers outside that proofs that actually

00:26:03,990 --> 00:26:08,880
this is a very close to what we used to

00:26:07,200 --> 00:26:11,820
have remember

00:26:08,880 --> 00:26:14,130
Tyler approximation or polynomial P

00:26:11,820 --> 00:26:17,760
algorithm proximation it's I'm gonna try

00:26:14,130 --> 00:26:20,670
to be as close as possible to a function

00:26:17,760 --> 00:26:25,280
which in this case is sine of X using

00:26:20,670 --> 00:26:27,240
this kind of polynomial approach the

00:26:25,280 --> 00:26:30,210
larger the depth at the polynomial

00:26:27,240 --> 00:26:33,810
begins the closer that it goes to the

00:26:30,210 --> 00:26:35,910
sine of this in this case there are some

00:26:33,810 --> 00:26:38,680
advantages of having this kind of

00:26:35,910 --> 00:26:40,960
improvement for the pole

00:26:38,680 --> 00:26:43,870
method the memory requires necessary

00:26:40,960 --> 00:26:46,320
implements it's quite a small so the

00:26:43,870 --> 00:26:49,960
amount of memory reduced by these

00:26:46,320 --> 00:26:51,700
improvement the the the numbers for for

00:26:49,960 --> 00:26:53,410
the performance improvement on the patch

00:26:51,700 --> 00:26:55,630
but the goes around for example in terms

00:26:53,410 --> 00:26:57,850
of performance of execution from twenty

00:26:55,630 --> 00:26:59,830
to forty percent in the micro benchmark

00:26:57,850 --> 00:27:01,210
that was rented because yes we have to

00:26:59,830 --> 00:27:02,920
prove that it has a performance

00:27:01,210 --> 00:27:05,550
improvement when we accept the patch so

00:27:02,920 --> 00:27:08,830
hu Lu who is the guide send this patch

00:27:05,550 --> 00:27:10,390
put it on the committee how many the

00:27:08,830 --> 00:27:13,900
amount of performance that was gained

00:27:10,390 --> 00:27:15,880
because of these only a requirement

00:27:13,900 --> 00:27:18,610
application addition is destruction of

00:27:15,880 --> 00:27:24,100
floating points numbers which is not

00:27:18,610 --> 00:27:25,990
very much CPU cycles it's part of a I

00:27:24,100 --> 00:27:27,820
put the on the presentation will be the

00:27:25,990 --> 00:27:30,580
link of where is the library that is

00:27:27,820 --> 00:27:32,620
doing this thing but yeah before going

00:27:30,580 --> 00:27:34,060
to developer experience this is one of

00:27:32,620 --> 00:27:37,420
the core things that we don't see every

00:27:34,060 --> 00:27:39,280
day but it's there for us right so the

00:27:37,420 --> 00:27:41,140
first call of action is shrine year

00:27:39,280 --> 00:27:43,330
operating system or in your deployment

00:27:41,140 --> 00:27:45,220
to use the latest technology that we as

00:27:43,330 --> 00:27:48,130
a tool change community deploy for you

00:27:45,220 --> 00:27:51,240
there is a very hard work for doing that

00:27:48,130 --> 00:27:57,550
and in that you can use it

00:27:51,240 --> 00:28:00,520
the pelipper experience I definitely

00:27:57,550 --> 00:28:02,910
like this one it's the my favorite in

00:28:00,520 --> 00:28:08,040
all the presentation had somebody

00:28:02,910 --> 00:28:10,870
realized that since the latest GCC they

00:28:08,040 --> 00:28:15,070
they find that a you don't know winnaman

00:28:10,870 --> 00:28:19,660
how to spell color so I'm going to show

00:28:15,070 --> 00:28:21,940
you that it's color not Colo GCC the

00:28:19,660 --> 00:28:24,510
text that an amount of job that has to

00:28:21,940 --> 00:28:26,860
happen in the back end of GCC it's huge

00:28:24,510 --> 00:28:33,450
just for us to let us know that we're

00:28:26,860 --> 00:28:38,770
spelling wrong sorry

00:28:33,450 --> 00:28:40,210
yeah yes in this case yes I stole a

00:28:38,770 --> 00:28:43,480
decoration for a live one

00:28:40,210 --> 00:28:45,730
so the smarter fig skins it's included

00:28:43,480 --> 00:28:49,000
by definition in all the juicy I mean

00:28:45,730 --> 00:28:50,530
only I don't know any distribution right

00:28:49,000 --> 00:28:51,820
now that remove these flocks couldn't

00:28:50,530 --> 00:28:53,800
compile it when when providing the

00:28:51,820 --> 00:28:56,650
compiler if it's providing for example

00:28:53,800 --> 00:28:58,150
fedora it's using this one and I think

00:28:56,650 --> 00:29:00,750
that our Punto it's also enabled in the

00:28:58,150 --> 00:29:00,750
latest version

00:29:00,850 --> 00:29:05,110
well even and you might be saying well

00:29:03,190 --> 00:29:07,120
that case it's very simple I mean it's

00:29:05,110 --> 00:29:10,770
it's a simple typo and things like that

00:29:07,120 --> 00:29:15,390
no it goes way much more in typos and

00:29:10,770 --> 00:29:18,550
for a small project for a simple few

00:29:15,390 --> 00:29:20,020
thousand of lines of codes more no more

00:29:18,550 --> 00:29:22,510
than 100 it's fine

00:29:20,020 --> 00:29:24,400
but what happened when our how many

00:29:22,510 --> 00:29:28,720
lines of code usually a production

00:29:24,400 --> 00:29:31,480
system based on C has more than 100 more

00:29:28,720 --> 00:29:36,180
than 200 increasing the lines of code in

00:29:31,480 --> 00:29:38,770
C it's very simple very simple right you

00:29:36,180 --> 00:29:42,690
blink one day you wake up the next

00:29:38,770 --> 00:29:48,520
weekend boom 200 lines of codes right

00:29:42,690 --> 00:29:52,600
well F diagnostic generation patch make

00:29:48,520 --> 00:29:56,550
the patch for you so even if you have a

00:29:52,600 --> 00:29:59,320
huge warning errors whatever you want

00:29:56,550 --> 00:30:03,940
run the clock and it will generate the

00:29:59,320 --> 00:30:06,160
patch for you so you can get am the file

00:30:03,940 --> 00:30:10,090
and fix all the things that we have

00:30:06,160 --> 00:30:12,670
wrong in your code ok so yes come back

00:30:10,090 --> 00:30:15,820
to the form that we use to have can I

00:30:12,670 --> 00:30:18,250
just literally hit randomly something

00:30:15,820 --> 00:30:19,510
and the compiler will fix it for me yes

00:30:18,250 --> 00:30:22,150
we arrived to the point in the future

00:30:19,510 --> 00:30:23,560
when the compiler can fix it for you you

00:30:22,150 --> 00:30:24,730
just need to apply the patch the next

00:30:23,560 --> 00:30:26,890
steps that we're talking in the

00:30:24,730 --> 00:30:30,870
communities should that should we put a

00:30:26,890 --> 00:30:30,870
flag that say apply the patch for me or

00:30:33,510 --> 00:30:40,300
now at the agnostic it's another one

00:30:36,550 --> 00:30:42,160
form with we pad format we're it

00:30:40,300 --> 00:30:45,510
possible to select a different kind of

00:30:42,160 --> 00:30:45,510
format that we want to print

00:30:45,650 --> 00:30:51,360
format its text or JSON and the reason

00:30:49,110 --> 00:30:54,990
why we added JSON as a format example

00:30:51,360 --> 00:30:58,050
for our case is because it's easy for

00:30:54,990 --> 00:31:02,460
later to post process right

00:30:58,050 --> 00:31:04,530
imagine this developer system into your

00:31:02,460 --> 00:31:07,290
team's or for your personal experience

00:31:04,530 --> 00:31:09,930
where you have warnings and instead of

00:31:07,290 --> 00:31:13,170
going one by one you can create an

00:31:09,930 --> 00:31:18,440
algorithm that select them or cluster

00:31:13,170 --> 00:31:21,929
them or give you up goes into dashboard

00:31:18,440 --> 00:31:24,480
anything you want the old days where I

00:31:21,929 --> 00:31:28,050
sit in my computer develop the code and

00:31:24,480 --> 00:31:31,020
magically after Fairs comes to my mind

00:31:28,050 --> 00:31:33,150
and happen the magic is not longer what

00:31:31,020 --> 00:31:35,520
we do every day it's a continuous

00:31:33,150 --> 00:31:38,250
integration continuous deployment system

00:31:35,520 --> 00:31:41,130
that we have to deliver to customers in

00:31:38,250 --> 00:31:44,550
less than a month how many months do we

00:31:41,130 --> 00:31:46,800
have for deploying an IOT system around

00:31:44,550 --> 00:31:49,320
three things like that means really fast

00:31:46,800 --> 00:31:53,010
amount of time then we need to spend for

00:31:49,320 --> 00:31:54,660
deploying so if we say Jesus the

00:31:53,010 --> 00:31:57,330
agnostic dot see in this case if this

00:31:54,660 --> 00:31:59,550
see example has some mistake and we ran

00:31:57,330 --> 00:32:02,820
F diagnostic format JSON it will

00:31:59,550 --> 00:32:05,550
generate the the the JSON format in a

00:32:02,820 --> 00:32:08,820
different approach than just in the text

00:32:05,550 --> 00:32:10,559
if I pass that through a JSON reader for

00:32:08,820 --> 00:32:12,120
me it's way much more easy to culture to

00:32:10,559 --> 00:32:14,190
read and for another tool to

00:32:12,120 --> 00:32:18,960
classification and things like that

00:32:14,190 --> 00:32:22,440
oh and maybe the last one I don't know

00:32:18,960 --> 00:32:29,190
how much time do we have but the last

00:32:22,440 --> 00:32:33,360
one is f3 switch conversion we have a

00:32:29,190 --> 00:32:37,020
simple foo function with switches 2 3 4

00:32:33,360 --> 00:32:42,000
5 6 and they variable how it's going to

00:32:37,020 --> 00:32:45,809
be later a sided to 205 305 or 0.55 as a

00:32:42,000 --> 00:32:49,160
human we can easily see that a wait a

00:32:45,809 --> 00:32:52,310
minute it's to multiply by 100 and not 5

00:32:49,160 --> 00:32:56,340
well now the compiler can detect that

00:32:52,310 --> 00:32:59,250
this is Ana snip of the code of the test

00:32:56,340 --> 00:33:03,929
case that was added to the compiler

00:32:59,250 --> 00:33:06,809
GCC night and now it transformed that

00:33:03,929 --> 00:33:10,140
into this linear function 100 multiplied

00:33:06,809 --> 00:33:12,330
over how plus PI for this example if I

00:33:10,140 --> 00:33:14,789
change instead of five it will the to

00:33:12,330 --> 00:33:16,380
eight it would take eight okay so it's

00:33:14,789 --> 00:33:18,990
not hard coded it's it's just for this

00:33:16,380 --> 00:33:20,280
example and these are they object um

00:33:18,990 --> 00:33:21,960
because I'm in the beginning when I

00:33:20,280 --> 00:33:23,309
realize that and in the milanese I

00:33:21,960 --> 00:33:25,980
didn't believe it they say I have to

00:33:23,309 --> 00:33:27,659
test it by myself it's too pretty cool

00:33:25,980 --> 00:33:29,549
to be to be to be real

00:33:27,659 --> 00:33:32,490
so yes the full function this is the

00:33:29,549 --> 00:33:34,260
function without using that one that

00:33:32,490 --> 00:33:38,340
flag in this case the f3 switch

00:33:34,260 --> 00:33:42,210
conversion it's a lot of jumps

00:33:38,340 --> 00:33:46,500
commitments jumps additions and this is

00:33:42,210 --> 00:33:49,100
if I ask this flag if I add this flag I

00:33:46,500 --> 00:33:52,230
will do a multiplication and addition

00:33:49,100 --> 00:33:55,169
here you will see them they I move and

00:33:52,230 --> 00:34:06,960
the I and the app exactly as I described

00:33:55,169 --> 00:34:10,139
it here yeah that's a great question the

00:34:06,960 --> 00:34:13,109
part of generic in this term it's it has

00:34:10,139 --> 00:34:16,730
to have at least this kind of approach

00:34:13,109 --> 00:34:19,470
we have to have an element that will be

00:34:16,730 --> 00:34:22,169
an element that will try to take a

00:34:19,470 --> 00:34:24,179
variable plus here could be an addition

00:34:22,169 --> 00:34:26,550
multiplication division and things like

00:34:24,179 --> 00:34:27,330
that it tries to be as much generic as

00:34:26,550 --> 00:34:30,389
possible

00:34:27,330 --> 00:34:32,550
remember this is the in the tree of the

00:34:30,389 --> 00:34:34,889
compiler we have the lexical analyzer

00:34:32,550 --> 00:34:38,000
the syntax analyzer the Lexi the

00:34:34,889 --> 00:34:40,349
semantic analyzer then we generate

00:34:38,000 --> 00:34:42,330
intermediate code and then comes the

00:34:40,349 --> 00:34:45,000
victimization this is the part when the

00:34:42,330 --> 00:34:47,639
compiler sits and say what can I do in

00:34:45,000 --> 00:34:50,099
this terms so it's as generic as we try

00:34:47,639 --> 00:34:54,690
to do it it's not perfect but we're

00:34:50,099 --> 00:34:56,520
trying to improve it so yeah as you can

00:34:54,690 --> 00:34:58,410
see it's pre magic in terms of hey I

00:34:56,520 --> 00:35:00,330
used to have this bunch of instruction

00:34:58,410 --> 00:35:02,849
that was going to be passed to the CPU

00:35:00,330 --> 00:35:05,130
and now I have an I'm all and that and

00:35:02,849 --> 00:35:07,200
the text the logic that I maybe didn't

00:35:05,130 --> 00:35:09,390
realize myself because if I would be

00:35:07,200 --> 00:35:13,040
able to realize myself I will not call

00:35:09,390 --> 00:35:18,200
this switch in the first place

00:35:13,040 --> 00:35:20,560
okay and there are more okay there are

00:35:18,200 --> 00:35:23,870
much more things that we can do with the

00:35:20,560 --> 00:35:26,150
latest technology for example ethanol

00:35:23,870 --> 00:35:29,750
the agnostic show line numbers pretty

00:35:26,150 --> 00:35:31,700
easy for the buggy a warning for

00:35:29,750 --> 00:35:33,380
allocation large and Dan and you put an

00:35:31,700 --> 00:35:35,600
equal here and you can pass the number

00:35:33,380 --> 00:35:37,700
so imagine that for your embedded

00:35:35,600 --> 00:35:41,030
application you want to check if I have

00:35:37,700 --> 00:35:43,430
an allocation more than a specific lines

00:35:41,030 --> 00:35:46,730
of specific amount of bytes I will be

00:35:43,430 --> 00:35:51,410
able to do to detect those ones with W a

00:35:46,730 --> 00:35:55,670
local larger than equal to 1024 or to

00:35:51,410 --> 00:35:58,400
2048 things like that okay there is also

00:35:55,670 --> 00:36:04,400
a previous system new system calls in G

00:35:58,400 --> 00:36:08,120
live in G live see 229 get CPU get CPU

00:36:04,400 --> 00:36:11,780
will print me the CPU and the Numa node

00:36:08,120 --> 00:36:14,180
where my application is standing so I'm

00:36:11,780 --> 00:36:16,250
pretty sure that for embedded and also

00:36:14,180 --> 00:36:17,960
for servers that it's pretty useful if

00:36:16,250 --> 00:36:20,480
I'm able to know where am i standing

00:36:17,960 --> 00:36:23,450
remember this is a rapper that used to

00:36:20,480 --> 00:36:27,110
be in the kernel yes now it's a system

00:36:23,450 --> 00:36:29,810
called ok view Google search for get CPU

00:36:27,110 --> 00:36:32,570
yes it will find out that it has been in

00:36:29,810 --> 00:36:37,700
man Linux page and years ago in kernel

00:36:32,570 --> 00:36:39,710
space now we have a pretty an amazing

00:36:37,700 --> 00:36:48,200
system call that we can use in user

00:36:39,710 --> 00:36:50,750
space ok I want to close this part with

00:36:48,200 --> 00:36:53,230
this picture taking advantage that we

00:36:50,750 --> 00:36:58,760
are in San Diego and there is a nice

00:36:53,230 --> 00:37:04,250
front water close to us with nice boats

00:36:58,760 --> 00:37:07,480
I like boats by the way GCC gilepsy

00:37:04,250 --> 00:37:11,810
binutils and all the tool change team

00:37:07,480 --> 00:37:14,780
together we want to say that we are

00:37:11,810 --> 00:37:16,550
happy to produce more tools for you so

00:37:14,780 --> 00:37:19,760
that you can propel the software

00:37:16,550 --> 00:37:22,610
development that you do every day and of

00:37:19,760 --> 00:37:24,170
course the LLVM and Ceylon community

00:37:22,610 --> 00:37:26,390
it's more than happy to develop those

00:37:24,170 --> 00:37:26,900
kind of tools so that you can create way

00:37:26,390 --> 00:37:31,010
much more

00:37:26,900 --> 00:37:33,880
things use the latest version fine box

00:37:31,010 --> 00:37:35,900
in our approaches for optimization

00:37:33,880 --> 00:37:37,579
complain to us and say hey could you

00:37:35,900 --> 00:37:39,950
please do it this more generally yes I

00:37:37,579 --> 00:37:41,779
can try to do much more generic or have

00:37:39,950 --> 00:37:44,119
you think about this warning today in

00:37:41,779 --> 00:37:46,880
the morning somebody call me and say we

00:37:44,119 --> 00:37:49,279
we are friends since many years ago and

00:37:46,880 --> 00:37:52,160
we say is there any way that we can make

00:37:49,279 --> 00:37:54,230
much more in C to get the the profiling

00:37:52,160 --> 00:37:57,289
information from the kernel on boot time

00:37:54,230 --> 00:38:00,470
from the debugger and I was like hmm I

00:37:57,289 --> 00:38:02,299
don't know could be a nice plugin but I

00:38:00,470 --> 00:38:04,579
haven't thought about it so when I came

00:38:02,299 --> 00:38:08,119
back I might talk with some of my

00:38:04,579 --> 00:38:11,089
friends and the clean or aged Lu about

00:38:08,119 --> 00:38:13,339
that kind of logging we are here to

00:38:11,089 --> 00:38:16,099
communicate to you that we can listen

00:38:13,339 --> 00:38:21,770
your needs base it on your daily jobs

00:38:16,099 --> 00:38:25,309
that you have example of that operating

00:38:21,770 --> 00:38:27,380
system that I'm part of the this part of

00:38:25,309 --> 00:38:29,750
the community it's a clean Linux

00:38:27,380 --> 00:38:31,490
operating system project we have much

00:38:29,750 --> 00:38:36,859
more information on these web pages

00:38:31,490 --> 00:38:39,349
about GCC 7g c c8 all these examples are

00:38:36,859 --> 00:38:43,089
over there in code and with much more

00:38:39,349 --> 00:38:47,480
details and there will be at GCC night

00:38:43,089 --> 00:38:49,400
GFC 32:29 to change block also over

00:38:47,480 --> 00:38:51,380
there in that webpage so all the codes

00:38:49,400 --> 00:38:53,690
all the comments all the things that i

00:38:51,380 --> 00:38:56,690
present and there are a summary of these

00:38:53,690 --> 00:38:58,670
three blocks that will be public the

00:38:56,690 --> 00:39:03,289
last one will be public in a few weeks

00:38:58,670 --> 00:39:07,849
maybe two weeks that's a backup that's

00:39:03,289 --> 00:39:10,510
supposed to be say thank you yeah that's

00:39:07,849 --> 00:39:10,510
about thank you

00:39:12,690 --> 00:39:16,880
I don't know how much time we have do we

00:39:15,810 --> 00:39:27,330
have time for questions

00:39:16,880 --> 00:39:28,320
yes King you know let me pass the

00:39:27,330 --> 00:39:41,040
microphone because I have problems

00:39:28,320 --> 00:40:00,960
hearing sorry yeah thank you

00:39:41,040 --> 00:40:03,720
oh yeah that's a good question so what

00:40:00,960 --> 00:40:09,090
hoisting try to for example detect these

00:40:03,720 --> 00:40:12,210
kind of uses of multiplication and

00:40:09,090 --> 00:40:15,780
assign to a variable and it split into

00:40:12,210 --> 00:40:21,180
maybe two or more but using less amount

00:40:15,780 --> 00:40:22,620
of horrible in yeah less amount of reuse

00:40:21,180 --> 00:40:25,470
as much variable for example in this

00:40:22,620 --> 00:40:28,770
case we'll say B multiplied by C will be

00:40:25,470 --> 00:40:32,910
assigned to D and replace these one by

00:40:28,770 --> 00:40:35,850
thee in the case detecting that one it's

00:40:32,910 --> 00:40:38,790
always going to be in in one in that

00:40:35,850 --> 00:40:41,430
case detect that one is going to be not

00:40:38,790 --> 00:40:43,740
passing by a common line interface and

00:40:41,430 --> 00:40:46,560
and the other and go straight forward

00:40:43,740 --> 00:40:49,200
that is the approach for that one for

00:40:46,560 --> 00:40:54,180
the other one I haven't tested much the

00:40:49,200 --> 00:40:57,800
the the other kind of of reducing of

00:40:54,180 --> 00:40:57,800
code that you mentioned so

00:41:31,590 --> 00:41:37,150
okay yeah we'll need to do that

00:41:35,650 --> 00:41:40,960
experiments because I didn't test that

00:41:37,150 --> 00:41:42,460
hoisting in that approach weena for were

00:41:40,960 --> 00:41:44,410
taken out of for a loop

00:41:42,460 --> 00:41:47,410
I realized that it reduce the amount of

00:41:44,410 --> 00:41:48,970
code in my case or change it but I was

00:41:47,410 --> 00:41:59,880
not aware of that thank you I will

00:41:48,970 --> 00:41:59,880
investigate about it yep yes

00:42:24,859 --> 00:42:49,529
yep yeah can you going to pass you the

00:42:43,920 --> 00:42:53,369
microphone it's way much better so when

00:42:49,529 --> 00:42:56,699
you when you have an architecture which

00:42:53,369 --> 00:42:59,099
uses a register for return address like

00:42:56,699 --> 00:43:04,440
arm so you have a lower register to keep

00:42:59,099 --> 00:43:06,569
returned rest yeah GF protection does it

00:43:04,440 --> 00:43:10,049
take into account scenarios or

00:43:06,569 --> 00:43:12,829
architectures which used register to

00:43:10,049 --> 00:43:12,829
hold return address

00:43:37,200 --> 00:43:44,560
right and in that case that return dress

00:43:41,890 --> 00:43:46,000
ultimately goes on the stag if there's a

00:43:44,560 --> 00:43:48,450
nested function call so if a function

00:43:46,000 --> 00:43:48,450
calls

00:44:09,720 --> 00:44:17,490
Thanks any other question

00:44:45,240 --> 00:44:57,000
yeah yeah this it's

00:45:14,930 --> 00:45:23,520
yeah the set technology is the first

00:45:21,089 --> 00:45:26,670
step on that to having the the ivt

00:45:23,520 --> 00:45:28,980
instruction to detect this kind of

00:45:26,670 --> 00:45:31,260
errors for for security beloved is the

00:45:28,980 --> 00:45:34,170
first of one of the first approaches the

00:45:31,260 --> 00:45:38,280
set technology will be enabled for Seon

00:45:34,170 --> 00:45:41,180
and other ones at the end I think don't

00:45:38,280 --> 00:45:41,180
take me bye bye

00:45:58,730 --> 00:46:05,980
well but for that case the problem is

00:46:01,190 --> 00:46:05,980
how long do you go how deeply you go

00:46:08,950 --> 00:46:15,349
yeah because in the very simple example

00:46:13,490 --> 00:46:18,260
that we have over here with the hello

00:46:15,349 --> 00:46:52,790
world yes we say a stack pointer minus

00:46:18,260 --> 00:46:55,600
20 but how do we know that if now thank

00:46:52,790 --> 00:46:59,489
you so much for your time we appreciate

00:46:55,600 --> 00:46:59,489

YouTube URL: https://www.youtube.com/watch?v=QXwxBM4sbYM


