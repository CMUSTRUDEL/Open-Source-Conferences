Title: A Million Ways to Provision Embedded Linux Images - Drew Moseley, Mender.io
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	A Million Ways to Provision Embedded Linux Images - Drew Moseley, Mender.io

Embedded Linux is increasingly common due to the explosion of the Internet of Things (IoT). There are countless off-the-shelf hardware platforms capable of running Embedded Linux, each with their own way to generate and provision images to device storage media.OpenEmbedded is a popular build system for Embedded Linux and is supported by a wide variety of board manufacturers. This build system will be used to discuss different mechanisms for initial provisioning of a variety of hardware platforms and demonstrate the most widely used mechanisms for getting a new image onto the board.
Captions: 
	00:00:00,000 --> 00:00:06,480
all right I guess we can get started so

00:00:03,389 --> 00:00:07,589
I'm here today to talk about a million

00:00:06,480 --> 00:00:10,230
different ways to provision your

00:00:07,589 --> 00:00:11,730
embedded Linux devices hopefully that's

00:00:10,230 --> 00:00:14,190
what you guys are here to hear about you

00:00:11,730 --> 00:00:16,080
know if not no shame feel free to head

00:00:14,190 --> 00:00:18,750
out I know we're bumping right up

00:00:16,080 --> 00:00:22,020
against lunch so you know I don't want

00:00:18,750 --> 00:00:24,869
to get in your way on that but just a

00:00:22,020 --> 00:00:27,510
brief overview the desserts here kind of

00:00:24,869 --> 00:00:30,029
kind of to kickstart our attention to

00:00:27,510 --> 00:00:32,099
lunch the idea being that you know there

00:00:30,029 --> 00:00:33,270
are a lot of choices out there when

00:00:32,099 --> 00:00:36,480
you're bringing up your embedded Linux

00:00:33,270 --> 00:00:39,000
devices I you know obviously a million's

00:00:36,480 --> 00:00:41,219
a bit bit of hyperbole in this situation

00:00:39,000 --> 00:00:43,079
but sometimes it doesn't really feel

00:00:41,219 --> 00:00:45,000
like it if you've ever worked with a

00:00:43,079 --> 00:00:46,170
wide variety of boards you'll realize

00:00:45,000 --> 00:00:49,469
that there's lots of different ways to

00:00:46,170 --> 00:00:50,850
get things on there so I'll talk a

00:00:49,469 --> 00:00:52,559
little bit about the anatomy of an

00:00:50,850 --> 00:00:55,140
embedded Linux system so we can kind of

00:00:52,559 --> 00:00:57,230
understand what what pieces we have

00:00:55,140 --> 00:00:59,879
where they need to get installed and why

00:00:57,230 --> 00:01:01,800
and then discuss the storage and

00:00:59,879 --> 00:01:04,170
provisioning of each of those individual

00:01:01,800 --> 00:01:06,390
components the obviously the bootloader

00:01:04,170 --> 00:01:08,700
kernel device trees if necessary and

00:01:06,390 --> 00:01:11,250
then the root filesystem and then map

00:01:08,700 --> 00:01:12,930
that to some very specific devices with

00:01:11,250 --> 00:01:15,180
command lines and that kind of thing to

00:01:12,930 --> 00:01:17,040
show exactly how for specific devices

00:01:15,180 --> 00:01:18,810
the the initial images are getting

00:01:17,040 --> 00:01:21,090
loaded with the goal of presenting an

00:01:18,810 --> 00:01:23,310
overview of just about all the different

00:01:21,090 --> 00:01:25,350
mechanisms you're gonna encounter as you

00:01:23,310 --> 00:01:28,860
work through you know a heterogeneous

00:01:25,350 --> 00:01:30,180
fleet of devices and before I go any

00:01:28,860 --> 00:01:33,900
further on that I did want to

00:01:30,180 --> 00:01:36,659
specifically define provisioning in this

00:01:33,900 --> 00:01:37,979
case and what I'm referring to when I

00:01:36,659 --> 00:01:41,189
talk about provisioning is getting the

00:01:37,979 --> 00:01:42,659
initial bit of code on the device and I

00:01:41,189 --> 00:01:44,579
know it's one of those very overloaded

00:01:42,659 --> 00:01:47,009
terms that is used in a lot of different

00:01:44,579 --> 00:01:49,950
ways depending on the exact conversation

00:01:47,009 --> 00:01:51,659
but for purposes of this talk the idea

00:01:49,950 --> 00:01:53,130
is how do you get that initial bit of

00:01:51,659 --> 00:01:56,149
code onto the device once you pull the

00:01:53,130 --> 00:01:56,149
device out of the shipping box

00:01:57,869 --> 00:02:02,759
so just a real briefly just a bit about

00:02:00,960 --> 00:02:04,759
me my name is drew Mosley I've been in

00:02:02,759 --> 00:02:07,079
the embedded Linux and Yocto space for

00:02:04,759 --> 00:02:08,759
10-12 years now something like that and

00:02:07,079 --> 00:02:11,220
even longer than that in general

00:02:08,759 --> 00:02:13,140
embedded my current role is project lead

00:02:11,220 --> 00:02:16,049
and solutions architect for the meander

00:02:13,140 --> 00:02:18,510
IO over-the-air update client-server

00:02:16,049 --> 00:02:20,069
system we actually have some t-shirts

00:02:18,510 --> 00:02:22,140
here if you want to grab a t-shirt on

00:02:20,069 --> 00:02:24,030
your way out feel free we figured we

00:02:22,140 --> 00:02:25,500
bring some down here and because we

00:02:24,030 --> 00:02:28,080
really don't want to take them home so

00:02:25,500 --> 00:02:32,489
if you want t-shirts we got at least a

00:02:28,080 --> 00:02:34,980
you know 10 or 15 of them back there so

00:02:32,489 --> 00:02:36,360
what are some of the challenges as

00:02:34,980 --> 00:02:37,410
embedded Linux developers that you're

00:02:36,360 --> 00:02:40,110
going to face when you're bringing these

00:02:37,410 --> 00:02:41,280
boards up the first one that you're

00:02:40,110 --> 00:02:43,290
going to find out is that there is not

00:02:41,280 --> 00:02:45,420
one way to do this every board has its

00:02:43,290 --> 00:02:47,129
own little idiosyncrasies every piece of

00:02:45,420 --> 00:02:49,500
media that you're writing to you have to

00:02:47,129 --> 00:02:50,910
know it yet another command line with

00:02:49,500 --> 00:02:52,890
some cryptic Flags that may mean

00:02:50,910 --> 00:02:54,239
something to somebody but generally

00:02:52,890 --> 00:02:55,110
speaking when you first get the board

00:02:54,239 --> 00:02:59,489
they probably don't mean anything

00:02:55,110 --> 00:03:01,349
specific to you at the time the another

00:02:59,489 --> 00:03:03,209
challenge is that generally speaking the

00:03:01,349 --> 00:03:04,319
mechanisms to get the images installed

00:03:03,209 --> 00:03:05,970
under your board they're gonna vary

00:03:04,319 --> 00:03:08,069
quite a bit depending on where you are

00:03:05,970 --> 00:03:09,870
in the development cycle early in the

00:03:08,069 --> 00:03:12,359
development you might cheat a little bit

00:03:09,870 --> 00:03:15,510
and use NFS and TFTP and a few other

00:03:12,359 --> 00:03:18,420
things and as you get as you move closer

00:03:15,510 --> 00:03:19,739
to production and dealing with CI CD

00:03:18,420 --> 00:03:21,780
pipelines things are going to be quite a

00:03:19,739 --> 00:03:23,220
bit different and then when you go into

00:03:21,780 --> 00:03:25,530
manufacturing I've got a whole slide on

00:03:23,220 --> 00:03:26,880
that later just some some considerations

00:03:25,530 --> 00:03:28,560
for when you go actually into the

00:03:26,880 --> 00:03:30,480
manufacturing environment you want to

00:03:28,560 --> 00:03:31,889
make it as simple as possible for your

00:03:30,480 --> 00:03:33,540
manufacturing team to be able to get

00:03:31,889 --> 00:03:38,639
these in the initial program loads going

00:03:33,540 --> 00:03:40,970
into these devices and additionally they

00:03:38,639 --> 00:03:43,290
may vary widely between boards

00:03:40,970 --> 00:03:44,970
manufacturers between different boards

00:03:43,290 --> 00:03:46,799
by the same manufacturer depending on

00:03:44,970 --> 00:03:48,840
you know what the storage media is and

00:03:46,799 --> 00:03:50,010
exactly who designed the board you know

00:03:48,840 --> 00:03:54,269
whether they had a good weekend or not

00:03:50,010 --> 00:03:55,980
before they did the final layout and the

00:03:54,269 --> 00:03:58,200
one biggest thing probably most relevant

00:03:55,980 --> 00:04:00,720
to all of us is these the initial

00:03:58,200 --> 00:04:02,880
provisioning if it's slow and tedious it

00:04:00,720 --> 00:04:04,530
can lead to some long development cycles

00:04:02,880 --> 00:04:05,819
especially when you're updating kernels

00:04:04,530 --> 00:04:07,230
and adding new device drivers and you've

00:04:05,819 --> 00:04:08,640
got to really go back to the very lowest

00:04:07,230 --> 00:04:10,769
level and get everything redeployed from

00:04:08,640 --> 00:04:12,470
the very beginning of the of the system

00:04:10,769 --> 00:04:15,209
bring up

00:04:12,470 --> 00:04:17,430
so this slides probably review for most

00:04:15,209 --> 00:04:18,870
folks in here but just briefly you know

00:04:17,430 --> 00:04:20,820
kind of kind of the ten thousand foot

00:04:18,870 --> 00:04:22,350
view the anatomy of the system at the

00:04:20,820 --> 00:04:24,330
very lowest level there's generally a

00:04:22,350 --> 00:04:27,120
bootloader this is the code that is

00:04:24,330 --> 00:04:29,699
responsible for bringing up everything

00:04:27,120 --> 00:04:32,550
from the very very beginning the initial

00:04:29,699 --> 00:04:34,350
fetch of the reset vector and

00:04:32,550 --> 00:04:36,630
initializing whatever hardware is needed

00:04:34,350 --> 00:04:38,370
generally speaking at a minimum it's

00:04:36,630 --> 00:04:40,169
gonna cool initialize the interrupt

00:04:38,370 --> 00:04:41,910
controller make sure there are no

00:04:40,169 --> 00:04:44,370
pending interrupts it's gonna set up our

00:04:41,910 --> 00:04:45,539
rails it's gonna initialize RAM so that

00:04:44,370 --> 00:04:47,070
it can load a kernel and that kind of

00:04:45,539 --> 00:04:48,600
thing depending on what functionality

00:04:47,070 --> 00:04:50,070
you need there may be more into the

00:04:48,600 --> 00:04:51,990
bootloader there may be Diagnostics

00:04:50,070 --> 00:04:53,370
things like that but from the Linux

00:04:51,990 --> 00:04:54,990
perspective as long as it gets the

00:04:53,370 --> 00:04:56,760
system up far enough that it can

00:04:54,990 --> 00:04:59,130
actually load a kernel into RAM that's

00:04:56,760 --> 00:05:01,020
the the bare minimum from there

00:04:59,130 --> 00:05:02,910
obviously we have the Linux kernel core

00:05:01,020 --> 00:05:04,590
operating system functionality process

00:05:02,910 --> 00:05:06,090
control device management that kind of

00:05:04,590 --> 00:05:07,229
thing fairly straightforward I think

00:05:06,090 --> 00:05:09,030
like I say probably everybody

00:05:07,229 --> 00:05:10,800
understands this some architectures

00:05:09,030 --> 00:05:13,169
require device tree which is a

00:05:10,800 --> 00:05:15,000
description of the hardware that's

00:05:13,169 --> 00:05:17,910
separate from the kernel itself and

00:05:15,000 --> 00:05:19,680
finally the the root filesystem which is

00:05:17,910 --> 00:05:21,240
everything else all the files all the

00:05:19,680 --> 00:05:26,220
data for whatever your particular

00:05:21,240 --> 00:05:29,280
application is so so looking at the

00:05:26,220 --> 00:05:31,020
storage overview specifically for the

00:05:29,280 --> 00:05:33,090
bootloader different options for storing

00:05:31,020 --> 00:05:34,889
the bootloader so you see the the five

00:05:33,090 --> 00:05:38,280
that are listed here are the most common

00:05:34,889 --> 00:05:40,080
at least that I've come across and and I

00:05:38,280 --> 00:05:41,370
won't read them all out but you see that

00:05:40,080 --> 00:05:43,349
there's quite a few there quite a few

00:05:41,370 --> 00:05:47,039
different options with some boards

00:05:43,349 --> 00:05:49,310
describing which ones use them the

00:05:47,039 --> 00:05:53,820
kernel and device tree

00:05:49,310 --> 00:05:55,050
can be very similar you know some

00:05:53,820 --> 00:05:56,699
systems actually put the kernel in a

00:05:55,050 --> 00:05:57,870
separate partition some systems put it

00:05:56,699 --> 00:06:00,840
as a file in the root filesystem

00:05:57,870 --> 00:06:03,270
partition you know form ender

00:06:00,840 --> 00:06:04,410
specifically one of our one of the first

00:06:03,270 --> 00:06:06,930
things we do when we're integrating

00:06:04,410 --> 00:06:08,430
vendor is move that kernel if it is in a

00:06:06,930 --> 00:06:10,949
separate partition or is loaded some

00:06:08,430 --> 00:06:12,960
into some other mechanism we we change

00:06:10,949 --> 00:06:14,280
that so that it's actually a file in the

00:06:12,960 --> 00:06:15,539
root filesystem which gives us the

00:06:14,280 --> 00:06:17,460
ability to update the kernel

00:06:15,539 --> 00:06:22,169
over-the-air as just part of our

00:06:17,460 --> 00:06:23,010
standard filesystem update and obviously

00:06:22,169 --> 00:06:24,990
the root filesystem

00:06:23,010 --> 00:06:26,610
quite a few quite a few options

00:06:24,990 --> 00:06:30,480
there you got things like emmc an SD

00:06:26,610 --> 00:06:33,060
card Ron and flash using ubi and things

00:06:30,480 --> 00:06:35,970
like that and then your typical USB

00:06:33,060 --> 00:06:37,530
drives to SATA SSD and then you know

00:06:35,970 --> 00:06:39,720
most most systems most boards can

00:06:37,530 --> 00:06:44,990
actually use root filesystem over NFS as

00:06:39,720 --> 00:06:49,080
well so first thing I did I wanted to

00:06:44,990 --> 00:06:51,690
get get a set up using Yocto plus the

00:06:49,080 --> 00:06:54,240
built in qiyam ki-moon machines just to

00:06:51,690 --> 00:06:56,730
kind of illustrate a few things the set

00:06:54,240 --> 00:06:58,080
of instructions here basically I pulled

00:06:56,730 --> 00:06:59,460
these all directly from that first link

00:06:58,080 --> 00:07:03,750
on the bottom directly out of the octo

00:06:59,460 --> 00:07:05,100
project documentation the set of the S

00:07:03,750 --> 00:07:06,690
state mirrors you see they're going into

00:07:05,100 --> 00:07:08,520
local vac option means that this whole

00:07:06,690 --> 00:07:13,020
build from scratch took about nine

00:07:08,520 --> 00:07:16,200
minutes on my abun 218 or a bunch of

00:07:13,020 --> 00:07:17,370
sixteen system you can give the the

00:07:16,200 --> 00:07:20,610
bottom link the bitly link that's

00:07:17,370 --> 00:07:22,080
actually a github gist link to this

00:07:20,610 --> 00:07:24,180
exact script so if you want to pull this

00:07:22,080 --> 00:07:27,030
down it's there you can actually get

00:07:24,180 --> 00:07:30,060
that get this set up and running in

00:07:27,030 --> 00:07:31,770
fairly short order like I say this was

00:07:30,060 --> 00:07:35,430
done on my abun to sixteen so I make no

00:07:31,770 --> 00:07:38,610
promises on any other target OS but the

00:07:35,430 --> 00:07:42,180
idea was setting this up was just to

00:07:38,610 --> 00:07:44,670
demonstrate a few things to once you

00:07:42,180 --> 00:07:48,270
have this build there's a script within

00:07:44,670 --> 00:07:50,190
the octo the octo repository that gets

00:07:48,270 --> 00:07:51,690
checked out called run chemo and this

00:07:50,190 --> 00:07:53,850
has a lot of interesting options in it

00:07:51,690 --> 00:07:56,430
the very first line you see there we're

00:07:53,850 --> 00:07:58,080
just invoking it run Kaimuki move x86 in

00:07:56,430 --> 00:08:00,030
my case I just used no graphic because I

00:07:58,080 --> 00:08:02,670
just wanted the the text to show up in

00:08:00,030 --> 00:08:06,240
the bash shell that I was in this

00:08:02,670 --> 00:08:08,430
basically uses the the key move block

00:08:06,240 --> 00:08:09,930
device and and mounts the the device

00:08:08,430 --> 00:08:10,970
directly out of your Yocto build so you

00:08:09,930 --> 00:08:13,050
don't have to do anything more than

00:08:10,970 --> 00:08:15,930
finish your Galco build and run the

00:08:13,050 --> 00:08:18,990
command the next seven shows you kind of

00:08:15,930 --> 00:08:21,840
had to do a FS based setup with with

00:08:18,990 --> 00:08:22,890
this system just with one caveat I

00:08:21,840 --> 00:08:25,140
couldn't get it to work this time

00:08:22,890 --> 00:08:26,460
and didn't have didn't spend a whole lot

00:08:25,140 --> 00:08:29,250
of time troubleshooting it I know I've

00:08:26,460 --> 00:08:31,530
done this in the past so you know you

00:08:29,250 --> 00:08:33,720
have to install the RPC bind and

00:08:31,530 --> 00:08:35,070
configure that but then basically the

00:08:33,720 --> 00:08:37,200
run chemos script takes care of

00:08:35,070 --> 00:08:38,729
extracting the archive creating the

00:08:37,200 --> 00:08:41,310
exports file entry and do

00:08:38,729 --> 00:08:43,440
all the the NFS side set up so that then

00:08:41,310 --> 00:08:45,690
when the ki mu system launches you're

00:08:43,440 --> 00:08:48,180
actually running over your with your

00:08:45,690 --> 00:08:49,709
root filesystem over NFS and you know

00:08:48,180 --> 00:08:51,149
the nice thing here is of course there's

00:08:49,709 --> 00:08:52,560
a lot of complexity going in there and

00:08:51,149 --> 00:08:55,260
the run key mu script really kind of

00:08:52,560 --> 00:08:57,620
hides all that from you it's not the

00:08:55,260 --> 00:08:59,850
same as running on real hardware

00:08:57,620 --> 00:09:02,360
generally speaking ki mu does not load a

00:08:59,850 --> 00:09:06,300
bootloader it loads the kernel directly

00:09:02,360 --> 00:09:08,730
again there's not normally a DT B and

00:09:06,300 --> 00:09:10,980
the kernel is directly in this case it's

00:09:08,730 --> 00:09:12,300
not loaded out of a flash device or

00:09:10,980 --> 00:09:14,579
something it's just loaded directly as a

00:09:12,300 --> 00:09:16,769
file off of your build system but if you

00:09:14,579 --> 00:09:17,850
are working on some components of your

00:09:16,769 --> 00:09:19,860
design that aren't Hardware specific

00:09:17,850 --> 00:09:22,199
this is a great way to get in and get a

00:09:19,860 --> 00:09:24,240
system up and running I know that this

00:09:22,199 --> 00:09:25,589
system will generally speaking run all

00:09:24,240 --> 00:09:27,510
the graphical user interfaces I know

00:09:25,589 --> 00:09:29,579
I've seen the Sato and the XOR GUI I

00:09:27,510 --> 00:09:30,779
assume it probably also does Wayland and

00:09:29,579 --> 00:09:32,370
things like that so you can actually

00:09:30,779 --> 00:09:34,470
make quite a bit of progress in your

00:09:32,370 --> 00:09:39,389
system to design with just this

00:09:34,470 --> 00:09:42,209
mechanism of deploying the image all

00:09:39,389 --> 00:09:44,100
right so now we get cut into the meat so

00:09:42,209 --> 00:09:45,630
this is the the first provisioning model

00:09:44,100 --> 00:09:49,319
that most folks come across and that's

00:09:45,630 --> 00:09:51,720
just writing everything to an SD card in

00:09:49,319 --> 00:09:53,790
some format in this case my example is

00:09:51,720 --> 00:09:56,639
the Raspberry Pi 3 you kind of see the

00:09:53,790 --> 00:09:58,769
image over here on the side of the way

00:09:56,639 --> 00:10:01,230
the board of the way the SD card is laid

00:09:58,769 --> 00:10:03,990
out you have two partitions one is a fat

00:10:01,230 --> 00:10:06,360
partition and they it contains things

00:10:03,990 --> 00:10:08,790
like the device tree binary the kernel

00:10:06,360 --> 00:10:10,860
seven dot image is the actual kernel

00:10:08,790 --> 00:10:12,540
image that gets loaded by from by the

00:10:10,860 --> 00:10:15,899
proprietary bootloader

00:10:12,540 --> 00:10:18,540
that's on board the Raspberry Pi 3 in

00:10:15,899 --> 00:10:20,459
the case of something like raspbian or

00:10:18,540 --> 00:10:21,990
out-of-the-box configurations kernel

00:10:20,459 --> 00:10:24,209
seven dot image is generally Linux

00:10:21,990 --> 00:10:26,100
kernel but you get with Yocto you can

00:10:24,209 --> 00:10:27,959
actually tell it to build with you boot

00:10:26,100 --> 00:10:29,250
so in that case that kernel file that

00:10:27,959 --> 00:10:31,889
kernel seven dot image will be a you

00:10:29,250 --> 00:10:33,750
boot image which then uses standard new

00:10:31,889 --> 00:10:37,440
boot commands to load a kernel binary

00:10:33,750 --> 00:10:39,060
which could come off the the partition I

00:10:37,440 --> 00:10:42,209
guess that should be partitioned -

00:10:39,060 --> 00:10:45,899
that's ext4 up there so and that's just

00:10:42,209 --> 00:10:47,189
a standard root filesystem so in this

00:10:45,899 --> 00:10:49,079
case this image file is generated

00:10:47,189 --> 00:10:51,550
directly by the Yocto build system so

00:10:49,079 --> 00:10:53,769
you actually get a binary image

00:10:51,550 --> 00:10:57,029
has the multiple partitions in it you

00:10:53,769 --> 00:11:00,820
use the DD command that I'm showing here

00:10:57,029 --> 00:11:03,160
and just write that and low-level to the

00:11:00,820 --> 00:11:04,510
SD card in your host build system once

00:11:03,160 --> 00:11:06,339
that write completes you pull the SD

00:11:04,510 --> 00:11:07,600
card out put it in the the Raspberry Pi

00:11:06,339 --> 00:11:10,540
and you power it on and everything

00:11:07,600 --> 00:11:12,160
everything goes from there so I suspect

00:11:10,540 --> 00:11:15,130
probably everybody in here has done this

00:11:12,160 --> 00:11:16,000
but this this mechanism of initial

00:11:15,130 --> 00:11:17,230
provisioning this is pretty

00:11:16,000 --> 00:11:19,810
straightforward like I say the Raspberry

00:11:17,230 --> 00:11:22,089
Pi you know they're they're everywhere

00:11:19,810 --> 00:11:25,720
so you know this is the one that you

00:11:22,089 --> 00:11:28,209
will definitely see so the next one is

00:11:25,720 --> 00:11:32,160
uh in the case of emmc so this is

00:11:28,209 --> 00:11:34,690
basically it's effectively the same

00:11:32,160 --> 00:11:36,130
media format as SD MMC except it's

00:11:34,690 --> 00:11:38,440
soldered directly to the board so

00:11:36,130 --> 00:11:40,390
there's no mechanism to take that that

00:11:38,440 --> 00:11:42,640
piece of storage media and put it into

00:11:40,390 --> 00:11:45,250
your host PC so it adds a little bit of

00:11:42,640 --> 00:11:49,209
complexity this was done on a technic C

00:11:45,250 --> 00:11:51,970
and P Co PI imx7 base board again the

00:11:49,209 --> 00:11:54,850
the the image map that you see there the

00:11:51,970 --> 00:11:56,829
the u-boot binary is actually stored in

00:11:54,850 --> 00:11:58,390
inter partitioned space as now it's not

00:11:56,829 --> 00:12:02,620
actually a file on a partition it's just

00:11:58,390 --> 00:12:04,290
in raw raw emmc flash space as long as

00:12:02,620 --> 00:12:06,370
well as the u-boot environment

00:12:04,290 --> 00:12:08,110
additionally you'll find the fat

00:12:06,370 --> 00:12:10,329
partition which is where the kernel and

00:12:08,110 --> 00:12:12,850
device tree are out of the box loaded

00:12:10,329 --> 00:12:14,649
from and similarly you have the ext4

00:12:12,850 --> 00:12:16,600
partition so it's a little bit more

00:12:14,649 --> 00:12:18,970
complicated than the previous one but

00:12:16,600 --> 00:12:21,250
the the complication it gets a little e

00:12:18,970 --> 00:12:22,570
even a little bit more complicated when

00:12:21,250 --> 00:12:23,860
trying to figure out how do you get this

00:12:22,570 --> 00:12:26,529
into the board since you don't have

00:12:23,860 --> 00:12:28,959
access to that from your build system so

00:12:26,529 --> 00:12:30,910
the image file in this case is also

00:12:28,959 --> 00:12:32,890
generated directly by Yocto so basically

00:12:30,910 --> 00:12:35,410
you get a bag of bits that contains the

00:12:32,890 --> 00:12:39,570
entire the entire image that I'm showing

00:12:35,410 --> 00:12:42,550
here there's once you have that then you

00:12:39,570 --> 00:12:45,060
run the two IMX usb commands you see

00:12:42,550 --> 00:12:47,680
here one to load the SPL the you boot

00:12:45,060 --> 00:12:49,720
the you boot SPL and then one to load

00:12:47,680 --> 00:12:52,149
the full you boot image and basically

00:12:49,720 --> 00:12:54,430
what that does is with the Technic CN

00:12:52,149 --> 00:12:57,160
board connected over USB to your host

00:12:54,430 --> 00:12:58,750
machine that look that mission the

00:12:57,160 --> 00:13:01,630
Technic CN board will come up in gadget

00:12:58,750 --> 00:13:03,010
mode the the two IMX usb commands are

00:13:01,630 --> 00:13:05,290
basically poking those

00:13:03,010 --> 00:13:06,760
binary images into the RAM of the device

00:13:05,290 --> 00:13:08,500
and then launching it so you'll actually

00:13:06,760 --> 00:13:11,350
be running you boot in that case out of

00:13:08,500 --> 00:13:15,070
RAM while the device is connected to

00:13:11,350 --> 00:13:17,589
your PC once that that Ram base you boot

00:13:15,070 --> 00:13:18,820
starts up you will you will then run the

00:13:17,589 --> 00:13:22,480
two commands you see at the bottom the

00:13:18,820 --> 00:13:24,519
USB start and the UMS zero MMC zero and

00:13:22,480 --> 00:13:27,880
and what that does is that sets us be up

00:13:24,519 --> 00:13:28,690
in mass storage mode so it's I guess USB

00:13:27,880 --> 00:13:31,420
device

00:13:28,690 --> 00:13:32,709
0 and then MMC device 0 so depending on

00:13:31,420 --> 00:13:34,510
the board those numbers may change

00:13:32,709 --> 00:13:36,430
depending on you know what devices you

00:13:34,510 --> 00:13:38,860
have on the board but but effectively

00:13:36,430 --> 00:13:41,170
that from the perspective of your PC now

00:13:38,860 --> 00:13:44,380
you've just got another USB disconnected

00:13:41,170 --> 00:13:45,940
and then you use the the DD command from

00:13:44,380 --> 00:13:48,040
your host PC where you've done your

00:13:45,940 --> 00:13:51,070
builds and then you just have to make

00:13:48,040 --> 00:13:54,690
sure that you get the right device note

00:13:51,070 --> 00:13:57,610
for this particular for the particular

00:13:54,690 --> 00:14:01,029
board that wherever it got mapped to in

00:13:57,610 --> 00:14:02,199
your device space obviously I've got

00:14:01,029 --> 00:14:03,850
another error in this slide where it

00:14:02,199 --> 00:14:05,829
says an ARP is the image this is would

00:14:03,850 --> 00:14:08,170
actually probably be a wick file since

00:14:05,829 --> 00:14:10,959
it's the the Technic C and and not the R

00:14:08,170 --> 00:14:12,699
pipe so a little bit more complicated

00:14:10,959 --> 00:14:15,070
than the previous but generally speaking

00:14:12,699 --> 00:14:17,470
EMC MMC is a little bit faster a little

00:14:15,070 --> 00:14:18,850
bit more reliable and we're definitely

00:14:17,470 --> 00:14:21,070
starting to see a lot more boards come

00:14:18,850 --> 00:14:25,449
out with the MMC and not even providing

00:14:21,070 --> 00:14:27,910
the ability to boot out of SD card so

00:14:25,449 --> 00:14:30,029
and this next one adds even one more

00:14:27,910 --> 00:14:33,250
layer of complexity this is the copy lab

00:14:30,029 --> 00:14:34,779
IOT gateway machine based on the imx7

00:14:33,250 --> 00:14:37,510
so in this case we actually have to

00:14:34,779 --> 00:14:39,579
physically separate devices emmc is very

00:14:37,510 --> 00:14:42,010
similar to what we saw previously except

00:14:39,579 --> 00:14:43,990
the bootloader is no longer in the MMC

00:14:42,010 --> 00:14:46,089
there's actually a separate SPI flash

00:14:43,990 --> 00:14:47,380
device that is considered the boot

00:14:46,089 --> 00:14:49,390
device of the system and that's where

00:14:47,380 --> 00:14:51,250
you're you're you boot image goes so

00:14:49,390 --> 00:14:54,819
other than that pretty much everything

00:14:51,250 --> 00:14:57,100
else is the same and generally speaking

00:14:54,819 --> 00:14:59,290
when you have a board like this there's

00:14:57,100 --> 00:15:00,060
going to be some mechanism in the

00:14:59,290 --> 00:15:02,560
bootloader

00:15:00,060 --> 00:15:04,449
or rather the bootloader will come up

00:15:02,560 --> 00:15:06,399
and from there you can determine whether

00:15:04,449 --> 00:15:07,899
you're going to use a MMC or SD if you

00:15:06,399 --> 00:15:09,339
have those as options the boot loaders

00:15:07,899 --> 00:15:10,510
especially if you're using you boot you

00:15:09,339 --> 00:15:12,760
can just say load for this device

00:15:10,510 --> 00:15:14,079
instead of this device but you will also

00:15:12,760 --> 00:15:16,089
generally find that there's going to be

00:15:14,079 --> 00:15:19,089
a jumper selection or some means

00:15:16,089 --> 00:15:20,970
in hardware of selecting whether you're

00:15:19,089 --> 00:15:23,529
going to boot out of this spi flash or

00:15:20,970 --> 00:15:26,410
if the board provides it some kind of

00:15:23,529 --> 00:15:28,329
fallback mechanism in the in the case of

00:15:26,410 --> 00:15:30,759
this particular board there's a jumper

00:15:28,329 --> 00:15:31,870
on board that if you if you connect the

00:15:30,759 --> 00:15:33,519
jumper then you're actually booting

00:15:31,870 --> 00:15:36,879
fully off of the SD card just like we

00:15:33,519 --> 00:15:39,399
did with the Raspberry Pi so so that so

00:15:36,879 --> 00:15:41,709
so basically the way this is gonna work

00:15:39,399 --> 00:15:44,889
then you're actually going to take the

00:15:41,709 --> 00:15:47,980
image and deploy it to a USB key or to a

00:15:44,889 --> 00:15:50,290
an SD card select the jumper setting to

00:15:47,980 --> 00:15:52,540
boot off of that device alright so now

00:15:50,290 --> 00:15:54,459
you're booted into a Linux system on the

00:15:52,540 --> 00:15:58,180
target device and you're actually going

00:15:54,459 --> 00:16:00,699
to use the flash erase command and the

00:15:58,180 --> 00:16:02,730
DD command you see there to write the

00:16:00,699 --> 00:16:05,620
new you boot image into the SPI flash

00:16:02,730 --> 00:16:08,110
and then the DD command writing to the

00:16:05,620 --> 00:16:11,379
dev MMC device to write the root file

00:16:08,110 --> 00:16:14,740
system into the emmc device on or the

00:16:11,379 --> 00:16:15,550
MMC chip on the board so it's it's you

00:16:14,740 --> 00:16:18,939
know we're getting a little more

00:16:15,550 --> 00:16:20,439
complicated you know a lot of times the

00:16:18,939 --> 00:16:22,179
nice thing about this kind of layout is

00:16:20,439 --> 00:16:24,879
you could some boards actually provide

00:16:22,179 --> 00:16:27,069
Hardware redundancy for that bootloader

00:16:24,879 --> 00:16:28,809
so that if you did need to do for

00:16:27,069 --> 00:16:30,100
instance an over-the-air update of the

00:16:28,809 --> 00:16:31,389
bootloader you could do it in a robust

00:16:30,100 --> 00:16:33,100
fashion because now you have a fallback

00:16:31,389 --> 00:16:34,360
version of you boot whereas if you've

00:16:33,100 --> 00:16:35,889
only got the one and you try to update

00:16:34,360 --> 00:16:42,490
it over the air you could end up with a

00:16:35,889 --> 00:16:45,009
brick very fairly easily and moving on

00:16:42,490 --> 00:16:47,350
we moved to the to the wrong man

00:16:45,009 --> 00:16:50,949
scenario so this one was done with a tor

00:16:47,350 --> 00:16:52,179
Dex colibri imx7 image is a little bit

00:16:50,949 --> 00:16:54,540
more complicated now we're actually

00:16:52,179 --> 00:16:57,249
using ubi volumes instead of partitions

00:16:54,540 --> 00:16:58,959
conceptually it's very similar in this

00:16:57,249 --> 00:17:02,139
case we actually do have the redundant

00:16:58,959 --> 00:17:04,059
you boot partitions or you volumes in

00:17:02,139 --> 00:17:06,789
this case the you boot environment is

00:17:04,059 --> 00:17:08,709
also a ubi volume and then inside

00:17:06,789 --> 00:17:10,929
another ubi volume we actually have the

00:17:08,709 --> 00:17:14,470
ubi ifs filesystem containing the

00:17:10,929 --> 00:17:16,630
standard root filesystem so in this case

00:17:14,470 --> 00:17:19,390
Yatta will generate images for each of

00:17:16,630 --> 00:17:21,309
these components and then you copy those

00:17:19,390 --> 00:17:24,309
individual images to the SD card this

00:17:21,309 --> 00:17:26,500
this setup does not generally create a

00:17:24,309 --> 00:17:27,730
single binary that like we had done in

00:17:26,500 --> 00:17:29,140
previous you're actually gonna have

00:17:27,730 --> 00:17:31,410
multiple binaries that get

00:17:29,140 --> 00:17:34,330
BTR SD card which are then deployed

00:17:31,410 --> 00:17:36,310
using the mechanisms detailed here so

00:17:34,330 --> 00:17:38,500
the first command the IMX USB USB

00:17:36,310 --> 00:17:41,860
command similar to the previous slide

00:17:38,500 --> 00:17:44,110
that will load the nand based version

00:17:41,860 --> 00:17:45,520
into ram the nand based version of you

00:17:44,110 --> 00:17:48,010
boot into the ram of the device and then

00:17:45,520 --> 00:17:50,230
you'll be running you boot from ram on

00:17:48,010 --> 00:17:51,790
that device and then you can use the the

00:17:50,230 --> 00:17:55,510
you boot commands you see here the nand

00:17:51,790 --> 00:17:57,700
erase and the load and the nand right to

00:17:55,510 --> 00:18:00,790
actually write the new you boot into the

00:17:57,700 --> 00:18:02,650
ubi volume so you basically have taken

00:18:00,790 --> 00:18:04,810
that you boot image copied it to an SD

00:18:02,650 --> 00:18:07,330
card or USB key then you load it into

00:18:04,810 --> 00:18:09,070
ram using you boot standard you boot

00:18:07,330 --> 00:18:10,690
commands from the command line and then

00:18:09,070 --> 00:18:12,580
you just write it into the flash and

00:18:10,690 --> 00:18:15,100
similar for the root filesystem

00:18:12,580 --> 00:18:17,860
you know so it's very similar to the

00:18:15,100 --> 00:18:19,630
previous one but you generally requires

00:18:17,860 --> 00:18:21,430
a few more steps a few more places where

00:18:19,630 --> 00:18:23,560
you can type something wrong so just

00:18:21,430 --> 00:18:25,420
kind of keep that in mind when you when

00:18:23,560 --> 00:18:28,000
you're working with these systems they

00:18:25,420 --> 00:18:32,770
they can be can be a little bit a little

00:18:28,000 --> 00:18:35,500
bit tricky and one more that I see

00:18:32,770 --> 00:18:38,260
coming up more and more often is using

00:18:35,500 --> 00:18:41,140
the Android tools on your desktop system

00:18:38,260 --> 00:18:43,600
to actually write the the the partitions

00:18:41,140 --> 00:18:45,100
on the device so in this case and this

00:18:43,600 --> 00:18:45,970
was quite a while ago that I worked with

00:18:45,100 --> 00:18:48,190
this board so I haven't actually

00:18:45,970 --> 00:18:51,580
verified that these the this exact set

00:18:48,190 --> 00:18:53,320
of commands is functional with the

00:18:51,580 --> 00:18:55,480
current version of yakou but something

00:18:53,320 --> 00:18:57,070
very similar to this should work these

00:18:55,480 --> 00:19:00,190
were specifically pulled directly from

00:18:57,070 --> 00:19:02,460
the 96 board's documentation with the

00:19:00,190 --> 00:19:04,210
link you see at the bottom of the screen

00:19:02,460 --> 00:19:05,980
generally speaking there's some

00:19:04,210 --> 00:19:07,540
mechanism to force the board to boot

00:19:05,980 --> 00:19:10,060
into fastboot mode whether it's a switch

00:19:07,540 --> 00:19:12,270
a jumper you know it's gonna vary widely

00:19:10,060 --> 00:19:14,470
depending on what the actual board does

00:19:12,270 --> 00:19:15,970
but in this case you are gonna be

00:19:14,470 --> 00:19:18,790
loading the images directly to the board

00:19:15,970 --> 00:19:22,480
from your host system over a USB gadget

00:19:18,790 --> 00:19:24,580
link so and if you look there are

00:19:22,480 --> 00:19:26,320
actually the the fastboot command here

00:19:24,580 --> 00:19:28,930
fastboot flash and then the next

00:19:26,320 --> 00:19:30,880
parameter is the name of the partition

00:19:28,930 --> 00:19:32,290
that you're gonna be writing to some of

00:19:30,880 --> 00:19:34,180
these boards have you know ten or twelve

00:19:32,290 --> 00:19:36,130
partitions because I guess the Android

00:19:34,180 --> 00:19:38,080
for some reason needs that many for

00:19:36,130 --> 00:19:39,730
different things but generally speaking

00:19:38,080 --> 00:19:42,340
if you're obviously if you're writing

00:19:39,730 --> 00:19:43,810
just a general embedded Linux system

00:19:42,340 --> 00:19:47,560
generally speaking the boot in the root

00:19:43,810 --> 00:19:49,180
if Esther the only things you need and

00:19:47,560 --> 00:19:50,460
just a couple of other provisioning

00:19:49,180 --> 00:19:53,740
tools I wanted to mention briefly

00:19:50,460 --> 00:19:55,690
because they probably will come up you

00:19:53,740 --> 00:19:58,420
know live installers are a fairly common

00:19:55,690 --> 00:20:00,550
thing the toradex easy installer you

00:19:58,420 --> 00:20:02,590
know whatever USB whatever a bun to disk

00:20:00,550 --> 00:20:04,060
you have a lot of systems you can

00:20:02,590 --> 00:20:06,340
actually use those and boot off of that

00:20:04,060 --> 00:20:08,380
and then use the actual live installer

00:20:06,340 --> 00:20:09,850
some some of them like the Troy Dex easy

00:20:08,380 --> 00:20:12,070
installer can actually pull images

00:20:09,850 --> 00:20:13,180
directly off the net internet so you

00:20:12,070 --> 00:20:15,640
don't even have to have the image

00:20:13,180 --> 00:20:18,610
downloaded locally it reaches out and

00:20:15,640 --> 00:20:20,380
grabs a JSON file of some kind with a

00:20:18,610 --> 00:20:22,600
directory of what images are available

00:20:20,380 --> 00:20:24,100
and it already has everything built into

00:20:22,600 --> 00:20:28,810
the easy installer to know how to deploy

00:20:24,100 --> 00:20:30,180
it for for your particular board some

00:20:28,810 --> 00:20:33,250
imaging tools that you may come across

00:20:30,180 --> 00:20:35,460
this is for things like the Raspberry Pi

00:20:33,250 --> 00:20:39,190
where you're writing the actual SD card

00:20:35,460 --> 00:20:40,720
you know on instead of using DD you know

00:20:39,190 --> 00:20:42,460
those things like buena etcher and the

00:20:40,720 --> 00:20:44,440
win32diskimager those are basically just

00:20:42,460 --> 00:20:46,930
gooeys on top of those kind of things

00:20:44,440 --> 00:20:48,010
they make it a little less likely that

00:20:46,930 --> 00:20:50,140
you're going to overwrite the wrong

00:20:48,010 --> 00:20:51,490
device node because they're pretty smart

00:20:50,140 --> 00:20:53,230
about figuring out which device nodes

00:20:51,490 --> 00:20:55,390
are mounted which ones are not and which

00:20:53,230 --> 00:20:57,580
ones actually are SD cards so that gives

00:20:55,390 --> 00:21:01,600
you a little bit more a little bit more

00:20:57,580 --> 00:21:03,610
safety and finally some other protocols

00:21:01,600 --> 00:21:05,980
I mentioned briefly at the very top of

00:21:03,610 --> 00:21:07,690
using TFTP NFS I was hoping to have a

00:21:05,980 --> 00:21:10,270
slide showing an easy three-step

00:21:07,690 --> 00:21:12,670
mechanism to do that but I think that's

00:21:10,270 --> 00:21:14,260
probably a talk in and of itself because

00:21:12,670 --> 00:21:16,630
there's so many mechanisms to actually

00:21:14,260 --> 00:21:18,190
set up NFS and so many things you know

00:21:16,630 --> 00:21:20,020
it's very dependent on your exact

00:21:18,190 --> 00:21:22,750
network setup I actually have a Synology

00:21:20,020 --> 00:21:24,550
Nass at home with NFS built in so all I

00:21:22,750 --> 00:21:26,740
had to do is go into the some Synology

00:21:24,550 --> 00:21:29,200
nasco we turn it on and then it uses

00:21:26,740 --> 00:21:31,120
pixie boot so you know files of a known

00:21:29,200 --> 00:21:33,670
format tell it where to find everything

00:21:31,120 --> 00:21:35,500
so for me it's just generally speaking a

00:21:33,670 --> 00:21:37,180
one or two line thing to get the system

00:21:35,500 --> 00:21:39,190
up and running if you're starting from

00:21:37,180 --> 00:21:41,650
scratch it's generally gonna be a lot

00:21:39,190 --> 00:21:43,000
more than that and then there's some

00:21:41,650 --> 00:21:45,400
other other protocols you might come

00:21:43,000 --> 00:21:46,690
across I mentioned the IM x USB tool but

00:21:45,400 --> 00:21:50,590
there's others Rockchip has their own

00:21:46,690 --> 00:21:53,290
mechanism which is very similar as does

00:21:50,590 --> 00:21:54,970
nvidia they they all basically use the

00:21:53,290 --> 00:21:58,360
mechanism of assuming the device

00:21:54,970 --> 00:21:59,860
can be a gadget mode some kind of gadget

00:21:58,360 --> 00:22:02,830
mode connection to the device where it's

00:21:59,860 --> 00:22:05,200
able to then go and and sometimes poke

00:22:02,830 --> 00:22:06,909
the images directly in into the flash

00:22:05,200 --> 00:22:09,250
the device or sometimes simply run you

00:22:06,909 --> 00:22:14,470
boot on the flash of the device like we

00:22:09,250 --> 00:22:18,610
like I mentioned earlier and a few other

00:22:14,470 --> 00:22:20,770
considerations so in your product

00:22:18,610 --> 00:22:22,419
development cycles some of the things

00:22:20,770 --> 00:22:24,340
you might want to think about you know

00:22:22,419 --> 00:22:25,570
and how they play together with device

00:22:24,340 --> 00:22:28,030
provisioning how are you going to

00:22:25,570 --> 00:22:29,080
integrate this with the CI CD system you

00:22:28,030 --> 00:22:31,960
know you have your jenkins builds

00:22:29,080 --> 00:22:33,820
running nightly builds how easy is it to

00:22:31,960 --> 00:22:35,740
actually get the builds installed on to

00:22:33,820 --> 00:22:37,570
a set of devices if you're you know

00:22:35,740 --> 00:22:39,480
going back and doing all this low-level

00:22:37,570 --> 00:22:41,890
stuff you know with the IM x USB tool

00:22:39,480 --> 00:22:44,200
you might be writing a lot of scripting

00:22:41,890 --> 00:22:47,590
around it if you're using something you

00:22:44,200 --> 00:22:50,080
know some kind of field OT a system you

00:22:47,590 --> 00:22:52,419
know you could actually use that instead

00:22:50,080 --> 00:22:53,740
just have some basic system installed

00:22:52,419 --> 00:22:55,870
than your nightly build just comes in as

00:22:53,740 --> 00:22:59,409
an OTA update that's a possibility as

00:22:55,870 --> 00:23:01,450
well and another another consideration

00:22:59,409 --> 00:23:03,580
is system developers vs. application

00:23:01,450 --> 00:23:05,080
developers it's not unique to you know

00:23:03,580 --> 00:23:07,360
device provisioning it's fairly common

00:23:05,080 --> 00:23:08,620
in the embedded Linux spaces you know

00:23:07,360 --> 00:23:09,700
your system developers are the guys that

00:23:08,620 --> 00:23:11,740
are worried about all this kind of stuff

00:23:09,700 --> 00:23:13,990
the app developers you know they'll be

00:23:11,740 --> 00:23:15,460
writing their stuff in node J S or QT

00:23:13,990 --> 00:23:17,559
and that kind of thing so they they

00:23:15,460 --> 00:23:19,179
generally speak generally speaking

00:23:17,559 --> 00:23:20,620
aren't going to be provisioning a board

00:23:19,179 --> 00:23:22,539
from scratch they'll probably be getting

00:23:20,620 --> 00:23:24,190
a board with a nightly build already

00:23:22,539 --> 00:23:25,690
pre-installed so you know there might be

00:23:24,190 --> 00:23:27,039
some other considerations that play into

00:23:25,690 --> 00:23:30,250
exactly how you want to handle the

00:23:27,039 --> 00:23:31,539
provisioning in the system and where it

00:23:30,250 --> 00:23:34,960
gets really complicated is when you

00:23:31,539 --> 00:23:37,690
start talking a heterogeneous fleet of

00:23:34,960 --> 00:23:39,760
devices you know we talked about five or

00:23:37,690 --> 00:23:42,159
six different devices here and they're

00:23:39,760 --> 00:23:43,570
all different mechanisms if you have one

00:23:42,159 --> 00:23:45,429
double one device that you're deploying

00:23:43,570 --> 00:23:46,690
to for your entire application then you

00:23:45,429 --> 00:23:48,520
only have one mechanism to worry about

00:23:46,690 --> 00:23:50,380
but it obviously things get more

00:23:48,520 --> 00:23:53,919
complicated the more the more targets

00:23:50,380 --> 00:23:56,289
you're deploying to and and finally a

00:23:53,919 --> 00:23:57,850
couple things about manufacturing you

00:23:56,289 --> 00:23:59,230
need to make sure when you're ready to

00:23:57,850 --> 00:24:00,850
hand this thing off to manufacturing

00:23:59,230 --> 00:24:02,710
that it's as few steps as possible in

00:24:00,850 --> 00:24:04,570
the manufacturing line it's as quick as

00:24:02,710 --> 00:24:06,549
possible and it's as bulletproof as

00:24:04,570 --> 00:24:07,870
possible generally speaking it needs to

00:24:06,549 --> 00:24:08,830
be an unattended installation because

00:24:07,870 --> 00:24:10,120
it's autumn and if action

00:24:08,830 --> 00:24:12,460
they don't want to have to somebody

00:24:10,120 --> 00:24:14,500
poppin SD cards in and out connecting

00:24:12,460 --> 00:24:16,299
cables the manufacturing folks hate that

00:24:14,500 --> 00:24:18,340
so you want to avoid that at all costs

00:24:16,299 --> 00:24:20,559
one thing that comes up a lot in

00:24:18,340 --> 00:24:22,690
discussions I have with folks is okay so

00:24:20,559 --> 00:24:24,700
I'm starting with one binary they can

00:24:22,690 --> 00:24:26,950
install on all my boards but each board

00:24:24,700 --> 00:24:29,169
will have some per board data associated

00:24:26,950 --> 00:24:30,940
with it whether that's a serial number

00:24:29,169 --> 00:24:33,039
you know SSL certificates that are

00:24:30,940 --> 00:24:35,320
unique to the device whatever so you

00:24:33,039 --> 00:24:37,179
will also need some mechanism to deploy

00:24:35,320 --> 00:24:39,760
that per board data and you know keep

00:24:37,179 --> 00:24:40,809
track of which board has which you know

00:24:39,760 --> 00:24:43,059
you're gonna have to have some mechanism

00:24:40,809 --> 00:24:44,470
for doing that a lot of times you can

00:24:43,059 --> 00:24:45,820
actually do it as just post install

00:24:44,470 --> 00:24:47,740
steps when the board boots up for the

00:24:45,820 --> 00:24:50,080
first time it generates the certificates

00:24:47,740 --> 00:24:52,809
or if you want to inject that

00:24:50,080 --> 00:24:54,639
certificate so that you can then take it

00:24:52,809 --> 00:24:56,500
and use that certificate to pre

00:24:54,639 --> 00:24:58,210
authenticate the device with some kind

00:24:56,500 --> 00:25:00,340
of device management infrastructure a

00:24:58,210 --> 00:25:02,380
lot more things you might need to be

00:25:00,340 --> 00:25:06,130
thinking about in terms of the per board

00:25:02,380 --> 00:25:07,899
data and and finally you know the the

00:25:06,130 --> 00:25:09,970
burnin test versus production image is

00:25:07,899 --> 00:25:11,289
you know generally speaking the first

00:25:09,970 --> 00:25:12,760
image that goes in and manufacturing

00:25:11,289 --> 00:25:14,260
it's probably not the image that's gonna

00:25:12,760 --> 00:25:16,480
go out you know in this trick wrap

00:25:14,260 --> 00:25:18,880
package that to go out the door you're

00:25:16,480 --> 00:25:20,110
probably gonna have multiple images you

00:25:18,880 --> 00:25:22,690
know you'll have a burnin test that runs

00:25:20,110 --> 00:25:24,100
for a while might be a smaller image and

00:25:22,690 --> 00:25:25,480
you know might go quicker but then when

00:25:24,100 --> 00:25:27,250
you get to the final production image

00:25:25,480 --> 00:25:28,659
that's gonna have all your application

00:25:27,250 --> 00:25:29,799
code and that's really where you start

00:25:28,659 --> 00:25:34,630
worrying about things like per board

00:25:29,799 --> 00:25:36,519
data and that kind of thing and with

00:25:34,630 --> 00:25:39,039
that I think that's the end of my slides

00:25:36,519 --> 00:25:41,529
and because I promised somebody I would

00:25:39,039 --> 00:25:43,120
do this I'm gonna end with a joke this

00:25:41,529 --> 00:25:44,679
joke made my day when I heard it a few

00:25:43,120 --> 00:25:45,909
weeks ago and every time I tell it it

00:25:44,679 --> 00:25:47,830
makes me very happy and then we can move

00:25:45,909 --> 00:25:51,870
into questions so how did the cyber

00:25:47,830 --> 00:25:54,870
cyber criminal get away nobody

00:25:51,870 --> 00:25:54,870
ransomware

00:25:54,900 --> 00:26:00,270
come on that's my favorite joke of late

00:25:58,410 --> 00:26:05,670
okay so I think we've got a microphone

00:26:00,270 --> 00:26:08,390
somewhere does any is this one work

00:26:05,670 --> 00:26:08,390
let's see

00:26:13,940 --> 00:26:19,200
well hello all right well I'll just try

00:26:17,850 --> 00:26:21,330
to repeat the question then cuz I'm not

00:26:19,200 --> 00:26:26,640
sure how this is working anybody get

00:26:21,330 --> 00:26:28,230
questions yes okay so the question was

00:26:26,640 --> 00:26:31,440
do I have any examples of secure boot a

00:26:28,230 --> 00:26:33,150
trusted boot the answer is no and that's

00:26:31,440 --> 00:26:34,290
that's probably thank you for bring that

00:26:33,150 --> 00:26:36,179
up that's probably a good point to

00:26:34,290 --> 00:26:37,650
mention secure boot adds a whole nother

00:26:36,179 --> 00:26:39,000
good layer of complexity here because

00:26:37,650 --> 00:26:41,010
you've got all sorts of certificates and

00:26:39,000 --> 00:26:43,740
things you have to deal with you know

00:26:41,010 --> 00:26:45,510
but my focus here was really more on the

00:26:43,740 --> 00:26:46,679
early stages the development cycle where

00:26:45,510 --> 00:26:48,570
you're you know bringing out the board

00:26:46,679 --> 00:26:50,370
for the first time but definitely secure

00:26:48,570 --> 00:26:52,770
boot is gonna have to come in ideally

00:26:50,370 --> 00:26:54,450
fairly early but you know obviously

00:26:52,770 --> 00:27:00,650
that's not a first day for you know

00:26:54,450 --> 00:27:00,650
first day bring up consideration yes

00:27:14,600 --> 00:27:25,760
where was it yeah so for this one

00:27:23,610 --> 00:27:29,010
there's actually a jumper on the board

00:27:25,760 --> 00:27:30,540
so the well all the jumper does on this

00:27:29,010 --> 00:27:32,850
particular board is selects whether it's

00:27:30,540 --> 00:27:50,580
gonna load the bootloader out of spy

00:27:32,850 --> 00:27:52,890
flash let's see I think I honestly I

00:27:50,580 --> 00:27:55,050
don't remember but I think by default if

00:27:52,890 --> 00:27:58,110
there's not a bootable image in the MC

00:27:55,050 --> 00:27:59,730
that's the default presumably again

00:27:58,110 --> 00:28:01,320
there's a switch or a jumper or

00:27:59,730 --> 00:28:05,610
something I I don't recall off the top

00:28:01,320 --> 00:28:07,530
my head for that specific correct

00:28:05,610 --> 00:28:09,780
correct and there and there may be

00:28:07,530 --> 00:28:12,900
examples where it is something like that

00:28:09,780 --> 00:28:14,610
um s command is similar because that's

00:28:12,900 --> 00:28:16,920
what's actually you know going be asleep

00:28:14,610 --> 00:28:18,900
one level higher in the USB stack but

00:28:16,920 --> 00:28:28,440
that's what putting you into USB to mass

00:28:18,900 --> 00:28:30,750
storage mode yes why is the boot

00:28:28,440 --> 00:28:31,920
partition always fat that's a good

00:28:30,750 --> 00:28:34,950
question

00:28:31,920 --> 00:28:36,240
my guess is because you know things like

00:28:34,950 --> 00:28:37,440
raspberry pie there's a lot of people

00:28:36,240 --> 00:28:39,870
running Windows that want to be able to

00:28:37,440 --> 00:28:43,140
deploy to them and they need to be able

00:28:39,870 --> 00:28:45,090
to edit the files in there you know in

00:28:43,140 --> 00:28:46,890
this case in fact in a lot of these

00:28:45,090 --> 00:28:49,860
cases it doesn't need to be it's just

00:28:46,890 --> 00:28:51,450
you know like I say for form ender the

00:28:49,860 --> 00:28:52,440
first thing like on this board we would

00:28:51,450 --> 00:28:53,700
probably get rid of that partition

00:28:52,440 --> 00:28:54,840
completely because the only things that

00:28:53,700 --> 00:28:56,280
are in there are the kernel and device

00:28:54,840 --> 00:28:57,600
tree we'd move them into the root

00:28:56,280 --> 00:28:59,640
filesystem and you boots perfectly

00:28:57,600 --> 00:29:02,480
capable of reading that root filesystem

00:28:59,640 --> 00:29:02,480
yes

00:29:11,320 --> 00:29:15,470
yeah so that's a that's another good

00:29:13,610 --> 00:29:16,820
point you know up and you know I know

00:29:15,470 --> 00:29:18,890
there were some boot loaders at least

00:29:16,820 --> 00:29:20,540
put me in a way back in the day that

00:29:18,890 --> 00:29:22,760
didn't know how to read ext4 so you

00:29:20,540 --> 00:29:24,020
would have to to use fat but I think

00:29:22,760 --> 00:29:28,130
anything you're using these days is

00:29:24,020 --> 00:29:33,830
gonna go to understand ext4 so I may be

00:29:28,130 --> 00:29:35,780
wrong and I'm sure there's fair enough

00:29:33,830 --> 00:29:37,340
fair enough yes so so on raspberry pi

00:29:35,780 --> 00:29:38,810
specifically yeah it's because their

00:29:37,340 --> 00:30:08,140
proprietary bootloader only knows fat

00:29:38,810 --> 00:30:10,490
yes right right right okay yeah so so

00:30:08,140 --> 00:30:12,020
basically there are some hardware

00:30:10,490 --> 00:30:14,450
restrictions where that that that's

00:30:12,020 --> 00:30:18,280
effectively required because of you know

00:30:14,450 --> 00:30:18,280
memory remapping and things like that

00:30:18,970 --> 00:30:22,720
all right anybody else

00:30:22,990 --> 00:30:26,240
all right well everybody have a lot nice

00:30:25,070 --> 00:30:27,500
lunch and don't forget if you want a

00:30:26,240 --> 00:30:29,650
t-shirt feel free to grab it on the way

00:30:27,500 --> 00:30:29,650
out

00:30:31,360 --> 00:30:33,420

YouTube URL: https://www.youtube.com/watch?v=jnmIv0_fF20


