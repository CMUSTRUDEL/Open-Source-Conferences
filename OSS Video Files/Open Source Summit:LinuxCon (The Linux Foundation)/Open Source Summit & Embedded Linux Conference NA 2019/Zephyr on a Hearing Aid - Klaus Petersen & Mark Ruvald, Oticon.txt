Title: Zephyr on a Hearing Aid - Klaus Petersen & Mark Ruvald, Oticon
Publication date: 2019-09-16
Playlist: Open Source Summit & Embedded Linux Conference NA 2019
Description: 
	Zephyr on a Hearing Aid - Klaus Petersen & Mark Ruvald, Oticon

The adventure of porting Zephyr to a hearing aid, a life-changing device that uses almost no power, almost no space and will be produced in millions.This is the story of molding Zephyr into a project that also supports the most exotic development environments, like those found in the making of an FDA approved medical device like a hearing aid sold to millions of users.The challenges, to name a few;- Zephyr as a modular component- Porting Zephyr to a custom processor- Making Zephyr (bluetooth stack) endianess portable- Supporting a fully proprietary toolchain- Improving and generalizing tracing infrastructure&nbsp;- Making it run with a lemon as a battery
Captions: 
	00:00:00,290 --> 00:00:08,160
all right I think we can start welcome

00:00:04,680 --> 00:00:10,889
I'm Klaus and this is Mark and we work

00:00:08,160 --> 00:00:13,139
at a company called Otakon the company

00:00:10,889 --> 00:00:21,029
located in Copenhagen Denmark and we

00:00:13,139 --> 00:00:23,160
design hearing aids I think most of you

00:00:21,029 --> 00:00:25,769
are familiar with the safier project if

00:00:23,160 --> 00:00:28,140
you're not here's a super short version

00:00:25,769 --> 00:00:30,269
severe is a real-time operating system

00:00:28,140 --> 00:00:32,820
optimized for resource constrained

00:00:30,269 --> 00:00:35,130
devices now saying something like a

00:00:32,820 --> 00:00:37,230
hearing aid which I'm holding here it's

00:00:35,130 --> 00:00:41,670
a resource resource constrained device

00:00:37,230 --> 00:00:42,719
is almost an understatement I think most

00:00:41,670 --> 00:00:44,040
people are familiar with hearing aids

00:00:42,719 --> 00:00:46,469
they know somebody who has a hearing aid

00:00:44,040 --> 00:00:47,969
and just from looking at you can see

00:00:46,469 --> 00:00:51,780
that physically obviously it's

00:00:47,969 --> 00:00:53,910
constrained it's one of the only devices

00:00:51,780 --> 00:00:56,100
that I know of where the size of the

00:00:53,910 --> 00:00:58,980
chip inside actually dictates the size

00:00:56,100 --> 00:01:00,989
of the product so if you were to make

00:00:58,980 --> 00:01:04,430
the chip just a little wider you'd also

00:01:00,989 --> 00:01:07,320
be making the hearing aid a bit wider

00:01:04,430 --> 00:01:10,530
now due to all these constraints it's

00:01:07,320 --> 00:01:12,150
also computationally constrained I know

00:01:10,530 --> 00:01:15,450
a lot of the other platforms and thus if

00:01:12,150 --> 00:01:17,159
your project they have many megahertz

00:01:15,450 --> 00:01:19,860
processors running cortex something

00:01:17,159 --> 00:01:21,270
something we have a much smaller but I'd

00:01:19,860 --> 00:01:24,020
still say that for the size of the

00:01:21,270 --> 00:01:29,189
hearing aid it's still quite capable

00:01:24,020 --> 00:01:30,600
obviously - again - due to the size the

00:01:29,189 --> 00:01:33,060
battery that you can fit in here is

00:01:30,600 --> 00:01:35,610
quite small so battery life is of course

00:01:33,060 --> 00:01:38,970
almost everything when you're designing

00:01:35,610 --> 00:01:40,860
a hearing aid now when we saw the Savior

00:01:38,970 --> 00:01:42,720
project with its focus on on the

00:01:40,860 --> 00:01:44,850
resource constrained devices we thought

00:01:42,720 --> 00:01:48,659
that was a great fit and we were happy

00:01:44,850 --> 00:01:51,329
to join that effort another thing that's

00:01:48,659 --> 00:01:53,009
quite interesting about something as

00:01:51,329 --> 00:01:55,280
little and small and but still very

00:01:53,009 --> 00:01:58,200
complex and pretty expensive is that

00:01:55,280 --> 00:02:01,530
despite all that it's still a commercial

00:01:58,200 --> 00:02:04,350
product and it is sold in volume it's

00:02:01,530 --> 00:02:08,789
sold in millions that makes it an

00:02:04,350 --> 00:02:10,819
interesting product which gets us to why

00:02:08,789 --> 00:02:14,930
this talk

00:02:10,819 --> 00:02:16,939
we think that with all this custom stuff

00:02:14,930 --> 00:02:19,549
all this special stuff that is inside

00:02:16,939 --> 00:02:22,099
the hearing aid here it makes it pretty

00:02:19,549 --> 00:02:24,500
complex and you could say that if you

00:02:22,099 --> 00:02:27,049
have an open-source project that you can

00:02:24,500 --> 00:02:29,049
make run on a hearing aid well then you

00:02:27,049 --> 00:02:31,909
can pretty much run it anywhere

00:02:29,049 --> 00:02:33,709
this talk will not be about how we port

00:02:31,909 --> 00:02:36,260
it safe here to our specific

00:02:33,709 --> 00:02:38,480
architecture there's already been talks

00:02:36,260 --> 00:02:40,909
on that I think there was one last year

00:02:38,480 --> 00:02:43,220
called enabling safety on your hardware

00:02:40,909 --> 00:02:45,829
you can go look in the ELC archive if

00:02:43,220 --> 00:02:48,409
you want to see that they'll document

00:02:45,829 --> 00:02:50,209
all the stuff where you write all the

00:02:48,409 --> 00:02:52,099
assembly code for the task switching the

00:02:50,209 --> 00:02:54,680
timers and all that this talk is not

00:02:52,099 --> 00:02:57,620
about that in summary you can say that

00:02:54,680 --> 00:02:59,180
it was quite uneventful it the API was

00:02:57,620 --> 00:03:02,569
good the hooks were there the

00:02:59,180 --> 00:03:07,040
documentation was good not much to talk

00:03:02,569 --> 00:03:08,659
about what this talk is about is the

00:03:07,040 --> 00:03:11,090
challenges the other the more general

00:03:08,659 --> 00:03:13,519
challenges we faced when pouring severe

00:03:11,090 --> 00:03:15,609
to something as specialized as a hearing

00:03:13,519 --> 00:03:15,609
aid

00:03:17,770 --> 00:03:22,600
now a hearing aid a lot of people they

00:03:21,460 --> 00:03:24,580
when they think of a hearing aid they

00:03:22,600 --> 00:03:26,170
think just of a glorified amplifier they

00:03:24,580 --> 00:03:28,660
think it's something that just takes the

00:03:26,170 --> 00:03:30,310
sound from the environment amplifies it

00:03:28,660 --> 00:03:33,130
into the human ear canal and that's

00:03:30,310 --> 00:03:35,500
pretty much it it might have used to be

00:03:33,130 --> 00:03:37,180
like that it's a long time ago modern

00:03:35,500 --> 00:03:40,870
hearing aids are a lot more advanced

00:03:37,180 --> 00:03:43,360
than that a modern hearing aid will

00:03:40,870 --> 00:03:47,320
analyze the sound environment many times

00:03:43,360 --> 00:03:49,510
a second and do a lot of heavy digital

00:03:47,320 --> 00:03:50,680
signal processing it's something that is

00:03:49,510 --> 00:03:53,320
going on constantly

00:03:50,680 --> 00:03:56,470
so it's an always-on process always

00:03:53,320 --> 00:03:59,410
draining the battery battery life like I

00:03:56,470 --> 00:04:02,530
say is key a modern hearing aid will

00:03:59,410 --> 00:04:05,530
also include something as a wireless 2.4

00:04:02,530 --> 00:04:07,780
gigahertz Bluetooth Low Energy enables

00:04:05,530 --> 00:04:10,390
you to make connections to your iPhone

00:04:07,780 --> 00:04:12,820
it even does audio streaming directly

00:04:10,390 --> 00:04:15,130
from the phone to the ear also it

00:04:12,820 --> 00:04:17,620
actually enables communication with TV

00:04:15,130 --> 00:04:21,010
so you can stream TV audio directly into

00:04:17,620 --> 00:04:23,410
your hearing aid it also has actually a

00:04:21,010 --> 00:04:26,340
magnetic link data link between each ear

00:04:23,410 --> 00:04:28,420
so that it can sync up stuff like volume

00:04:26,340 --> 00:04:31,240
program selection stuff again

00:04:28,420 --> 00:04:33,750
and it does that with the battery of the

00:04:31,240 --> 00:04:36,550
size of an Altoids mint a tiny battery

00:04:33,750 --> 00:04:42,940
and it has to have a battery life of

00:04:36,550 --> 00:04:45,460
multiple days now how do we do that if

00:04:42,940 --> 00:04:47,440
you pop the hood of a hearing aid you'll

00:04:45,460 --> 00:04:50,200
find that there's three custom Asics

00:04:47,440 --> 00:04:52,000
inside there's a DSP digital signal

00:04:50,200 --> 00:04:56,260
processor the RF the one that enables us

00:04:52,000 --> 00:04:59,020
to communicate with the iPhone the TVs

00:04:56,260 --> 00:04:59,800
and there's an analogue front end and on

00:04:59,020 --> 00:05:03,340
these chips

00:04:59,800 --> 00:05:05,950
there's many quote system so I think

00:05:03,340 --> 00:05:08,490
we're actually up to 11 course on the

00:05:05,950 --> 00:05:11,350
this current generation of hearing aids

00:05:08,490 --> 00:05:13,870
all optimized for their specific

00:05:11,350 --> 00:05:17,470
purposes some will be analyzing sound

00:05:13,870 --> 00:05:20,890
some will do power management all very

00:05:17,470 --> 00:05:22,270
power efficient these course and all the

00:05:20,890 --> 00:05:24,730
peripherals they're communicating using

00:05:22,270 --> 00:05:26,169
and network on chip if you are not

00:05:24,730 --> 00:05:27,940
familiar with a network on chip and then

00:05:26,169 --> 00:05:29,979
work on chip is as opposed to a bus

00:05:27,940 --> 00:05:31,270
based based system it's a routed network

00:05:29,979 --> 00:05:36,160
on the chip

00:05:31,270 --> 00:05:39,250
just like your Ethernet this enables

00:05:36,160 --> 00:05:41,110
first of all its lower power it helps

00:05:39,250 --> 00:05:44,740
with routing congestion it helps with

00:05:41,110 --> 00:05:46,150
timing closure also under the hood of a

00:05:44,740 --> 00:05:47,800
hearing aid there's of course a

00:05:46,150 --> 00:05:52,270
bluetooth basement that's what enables

00:05:47,800 --> 00:05:54,810
our 2.4 gigahertz communication and yeah

00:05:52,270 --> 00:05:59,740
like I said a lot of custom processes

00:05:54,810 --> 00:06:02,319
and the custom process is where the

00:05:59,740 --> 00:06:04,090
first real challenge comes in because

00:06:02,319 --> 00:06:05,979
obviously a custom processor will be

00:06:04,090 --> 00:06:07,770
having a very specialized tool chain

00:06:05,979 --> 00:06:14,919
also

00:06:07,770 --> 00:06:18,099
so Savior when we joined it was favoring

00:06:14,919 --> 00:06:21,030
canoe like tool chains we needed to have

00:06:18,099 --> 00:06:23,199
our special tool chain also be supported

00:06:21,030 --> 00:06:24,580
so it might sound like we're trying to

00:06:23,199 --> 00:06:25,630
push something specialized into an

00:06:24,580 --> 00:06:27,759
open-source project

00:06:25,630 --> 00:06:28,840
that wouldn't be very nice but what we

00:06:27,759 --> 00:06:32,289
were actually doing were we're

00:06:28,840 --> 00:06:33,639
abstracting the tool chain I think

00:06:32,289 --> 00:06:36,250
that's very important for project like

00:06:33,639 --> 00:06:38,500
staff here that is focusing on the edge

00:06:36,250 --> 00:06:40,150
of the network so we've moved away from

00:06:38,500 --> 00:06:43,659
the general computing where you have all

00:06:40,150 --> 00:06:45,490
the normal processes all the new like

00:06:43,659 --> 00:06:47,500
tools and out to the edge where you'll

00:06:45,490 --> 00:06:52,780
find something like a hearing aid with

00:06:47,500 --> 00:06:55,300
very specialized tool chain yeah so so

00:06:52,780 --> 00:06:59,860
as Klaus mentioned sefar was limited by

00:06:55,300 --> 00:07:01,990
new assumptions both in C code and in C

00:06:59,860 --> 00:07:07,990
make several uses the C make those

00:07:01,990 --> 00:07:11,169
system so you would find things in the

00:07:07,990 --> 00:07:14,740
root C make file that was basically a

00:07:11,169 --> 00:07:16,780
mixed bag of flags that the tool chain

00:07:14,740 --> 00:07:20,020
had to support so you would find like

00:07:16,780 --> 00:07:23,830
things like hard-coded verbatim - G and

00:07:20,020 --> 00:07:26,139
warning all and imacros and freestanding

00:07:23,830 --> 00:07:29,229
and these are flags that our tool chain

00:07:26,139 --> 00:07:33,099
doesn't support of course it can

00:07:29,229 --> 00:07:35,349
implement similar things but they're

00:07:33,099 --> 00:07:38,560
written in a slightly different tune

00:07:35,349 --> 00:07:41,650
tactical weight but the intent is the

00:07:38,560 --> 00:07:43,990
same and of course we want to adhere to

00:07:41,650 --> 00:07:45,150
that intent so maybe that's what we

00:07:43,990 --> 00:07:48,720
should make

00:07:45,150 --> 00:07:52,170
the silver simec build system do that's

00:07:48,720 --> 00:07:54,630
what we have been doing so we have

00:07:52,170 --> 00:07:59,190
abstracted all of these hard-coded flags

00:07:54,630 --> 00:08:00,660
into basically a tool chain API so a

00:07:59,190 --> 00:08:04,800
torsion can implement these and you will

00:08:00,660 --> 00:08:07,710
port new GCC and the new LD and the

00:08:04,800 --> 00:08:09,780
linker and the bin utilities into these

00:08:07,710 --> 00:08:13,110
macros and provide the same kind of

00:08:09,780 --> 00:08:15,780
interface and we would simply do the

00:08:13,110 --> 00:08:19,890
same so it wouldn't be special no it

00:08:15,780 --> 00:08:22,200
would just be abstracted so we have them

00:08:19,890 --> 00:08:25,320
by intent and we have them categorized

00:08:22,200 --> 00:08:28,950
so we have the CC for the compiler and

00:08:25,320 --> 00:08:34,860
LD for the linker and bin tools for the

00:08:28,950 --> 00:08:39,180
bin utilities yeah and that's been quite

00:08:34,860 --> 00:08:42,540
a long pathway underway it's been slow

00:08:39,180 --> 00:08:44,390
moving but its nearing completion so

00:08:42,540 --> 00:08:46,620
there are still some rough edges and

00:08:44,390 --> 00:08:53,180
especially user space and memory

00:08:46,620 --> 00:08:57,150
separation in suffers bit yeah long and

00:08:53,180 --> 00:08:59,820
hard coded in the SIMEX system in

00:08:57,150 --> 00:09:04,650
suffers use of the ce mec system and you

00:08:59,820 --> 00:09:08,910
can still find remnants like - l and EXT

00:09:04,650 --> 00:09:12,420
modules and yeah you could use a general

00:09:08,910 --> 00:09:16,410
cleanup of the semi final stuff that may

00:09:12,420 --> 00:09:18,300
happen yep all right another challenge

00:09:16,410 --> 00:09:20,940
when you have a specialized system like

00:09:18,300 --> 00:09:23,940
a hearing aid is that most of the code

00:09:20,940 --> 00:09:25,920
that you'll be writing is proprietary so

00:09:23,940 --> 00:09:29,730
you have a system where even something

00:09:25,920 --> 00:09:33,090
as simple as timers or the SPI or ice

00:09:29,730 --> 00:09:35,670
Percy driver will be specifically aimed

00:09:33,090 --> 00:09:38,970
at our version of that particular core

00:09:35,670 --> 00:09:42,360
with fixes for our silicon bugs and

00:09:38,970 --> 00:09:46,680
stuff like that so all these drivers

00:09:42,360 --> 00:09:49,010
that are proprietary become a problem in

00:09:46,680 --> 00:09:51,270
a safe way project will see why later

00:09:49,010 --> 00:09:53,250
there can be multiple reasons why you

00:09:51,270 --> 00:09:55,830
would want to have proprietary code of

00:09:53,250 --> 00:09:57,390
course ideally you'd try to upstream as

00:09:55,830 --> 00:09:59,720
much as possible

00:09:57,390 --> 00:10:02,459
and first of all it could be that it's

00:09:59,720 --> 00:10:04,680
secret of course but it could also be

00:10:02,459 --> 00:10:06,600
that it's just of no use to anyone else

00:10:04,680 --> 00:10:08,610
it could be that it's third party

00:10:06,600 --> 00:10:11,310
licensed or that you are keeping it in a

00:10:08,610 --> 00:10:12,839
separate version control system that you

00:10:11,310 --> 00:10:19,380
don't want to share with the the

00:10:12,839 --> 00:10:23,370
circuitry so the problem was that safe

00:10:19,380 --> 00:10:25,589
here when we joined only supported to

00:10:23,370 --> 00:10:29,209
keep code in the tree so if you were

00:10:25,589 --> 00:10:32,910
writing a proprietary driver you would

00:10:29,209 --> 00:10:35,430
you have a giant diff up to the upstream

00:10:32,910 --> 00:10:37,070
if you want to follow the upstream as

00:10:35,430 --> 00:10:39,959
much as possible then you would need to

00:10:37,070 --> 00:10:41,760
to always look at this diff so there are

00:10:39,959 --> 00:10:44,910
some common solutions of course you

00:10:41,760 --> 00:10:47,329
could just use your git ignore but then

00:10:44,910 --> 00:10:50,010
again that's also a version controlled

00:10:47,329 --> 00:10:51,360
file and you would have to maintain your

00:10:50,010 --> 00:10:54,990
own branch and it doesn't really scale

00:10:51,360 --> 00:10:57,899
well if there's a lot of files scattered

00:10:54,990 --> 00:10:59,670
across the system and we thought maybe

00:10:57,899 --> 00:11:01,260
we could use something like symlinks but

00:10:59,670 --> 00:11:02,910
then again that's never really the

00:11:01,260 --> 00:11:05,209
solution it's always a bit of a hassle

00:11:02,910 --> 00:11:07,410
it's a recipe for disaster

00:11:05,209 --> 00:11:09,570
build systems should they follow should

00:11:07,410 --> 00:11:12,089
they not all these problems that come

00:11:09,570 --> 00:11:14,430
along we also thought about taking our

00:11:12,089 --> 00:11:15,930
proprietary driver code and copying it

00:11:14,430 --> 00:11:19,740
in during the build but that's really

00:11:15,930 --> 00:11:21,449
also just asking for trouble all kinds

00:11:19,740 --> 00:11:24,570
of race conditions when do you clean up

00:11:21,449 --> 00:11:26,490
when do you not the elegant way I think

00:11:24,570 --> 00:11:29,310
would be to have some kind of overlay

00:11:26,490 --> 00:11:31,680
where you could overlay the safier file

00:11:29,310 --> 00:11:35,010
tree with your own version and then

00:11:31,680 --> 00:11:38,790
halves if you pick the overlay but but

00:11:35,010 --> 00:11:40,140
the build system as it was as it is now

00:11:38,790 --> 00:11:42,630
doesn't really have the infrastructure

00:11:40,140 --> 00:11:44,790
it would be a major change so the

00:11:42,630 --> 00:11:47,640
solution we came up with was adding some

00:11:44,790 --> 00:11:52,410
Kline command line options you can see

00:11:47,640 --> 00:11:54,449
them here where we can now say well if

00:11:52,410 --> 00:11:56,550
you have a variety of codes you have a

00:11:54,449 --> 00:11:58,230
lot of these commercial products you can

00:11:56,550 --> 00:11:59,579
just specify that your architecture

00:11:58,230 --> 00:12:01,890
instead of taking it from the safe route

00:11:59,579 --> 00:12:04,019
tree you'll be taking it from somewhere

00:12:01,890 --> 00:12:06,270
else some other place on your file

00:12:04,019 --> 00:12:09,510
system same goes for the board the tool

00:12:06,270 --> 00:12:11,290
chain the SOC we're also working on

00:12:09,510 --> 00:12:18,300
doing that for drivers and for

00:12:11,290 --> 00:12:22,240
subsystems yep so that was basically

00:12:18,300 --> 00:12:27,190
building so see make and locating source

00:12:22,240 --> 00:12:30,450
code a few changes was also needed to to

00:12:27,190 --> 00:12:32,380
the Zephyr Bluetooth link layer stack

00:12:30,450 --> 00:12:33,970
fortunately the Zephyr was already out

00:12:32,380 --> 00:12:37,510
of the box pretty much Indiana's

00:12:33,970 --> 00:12:40,870
portable however not bluetooth link

00:12:37,510 --> 00:12:44,140
layer so we still had to find the end

00:12:40,870 --> 00:12:46,510
eNOS issues and correct those and we

00:12:44,140 --> 00:12:50,170
have done that before it's not a new

00:12:46,510 --> 00:12:51,730
thing for us and we were big endian so

00:12:50,170 --> 00:12:53,880
but this time around we have actually

00:12:51,730 --> 00:12:57,070
come up with a clever generic

00:12:53,880 --> 00:12:59,680
semi-automated way of doing that that is

00:12:57,070 --> 00:13:03,940
not safer specific so other projects

00:12:59,680 --> 00:13:07,680
could could use this so end in s bugs

00:13:03,940 --> 00:13:10,090
right it's the byte order interpretation

00:13:07,680 --> 00:13:12,340
that's kind of a subtle thing so you

00:13:10,090 --> 00:13:14,740
need to be very careful when you read

00:13:12,340 --> 00:13:18,310
the code you need to follow the data

00:13:14,740 --> 00:13:21,580
flow you need to track the flow of it

00:13:18,310 --> 00:13:24,850
and with special glasses on can it be

00:13:21,580 --> 00:13:27,400
interpreted in a different way is it

00:13:24,850 --> 00:13:32,110
cost to an array of HUMINT

00:13:27,400 --> 00:13:36,310
16 at some point and you well that takes

00:13:32,110 --> 00:13:40,510
time so you need to review and when you

00:13:36,310 --> 00:13:42,370
have found your sources hopefully

00:13:40,510 --> 00:13:44,280
they're kind of following the same

00:13:42,370 --> 00:13:47,230
pattern and you may easily fix them

00:13:44,280 --> 00:13:49,000
however since the world is like the fact

00:13:47,230 --> 00:13:51,030
too little endian they're likely to

00:13:49,000 --> 00:13:54,060
reappear for you if you're a big onion

00:13:51,030 --> 00:13:57,940
so we want something that is like

00:13:54,060 --> 00:13:59,500
suitable for a regression test so yeah

00:13:57,940 --> 00:14:04,750
we had to do a bit of work in the

00:13:59,500 --> 00:14:08,920
controller and but um how do we find

00:14:04,750 --> 00:14:11,590
them because we don't want to invest a

00:14:08,920 --> 00:14:15,820
lot of time in just reading through

00:14:11,590 --> 00:14:18,370
ever-changing code so static analysis we

00:14:15,820 --> 00:14:20,080
have tried that and doesn't really work

00:14:18,370 --> 00:14:22,030
well if you know about any static

00:14:20,080 --> 00:14:25,480
analysis tool that can do that then

00:14:22,030 --> 00:14:26,950
come talk with us after the talk and so

00:14:25,480 --> 00:14:28,660
the traditional way of simply been

00:14:26,950 --> 00:14:33,910
reviewing this kind of empirical

00:14:28,660 --> 00:14:37,210
discovery but how do we do a better or

00:14:33,910 --> 00:14:40,300
quicker empirical discovery process

00:14:37,210 --> 00:14:43,530
could we accelerate that somehow and it

00:14:40,300 --> 00:14:46,210
turns out that we can so for us for

00:14:43,530 --> 00:14:49,660
Otakon one of our contributions is this

00:14:46,210 --> 00:14:55,600
babel sim project which is safer

00:14:49,660 --> 00:14:58,240
agnostic but largely built for Zephyr it

00:14:55,600 --> 00:15:00,700
is a physical layer simulator so you can

00:14:58,240 --> 00:15:02,590
simulate Bluetooth traffic using that or

00:15:00,700 --> 00:15:05,050
any kind of traffic but specifically we

00:15:02,590 --> 00:15:07,750
use it for Bluetooth any kind of radio

00:15:05,050 --> 00:15:09,880
traffic and the neat thing is that it's

00:15:07,750 --> 00:15:12,700
reproducible it's very fast it's phat

00:15:09,880 --> 00:15:16,120
super real super real-time so you can

00:15:12,700 --> 00:15:19,530
like run orders of magnitude faster than

00:15:16,120 --> 00:15:22,150
real time that's good for debugging and

00:15:19,530 --> 00:15:24,970
doing it quickly and running it in

00:15:22,150 --> 00:15:27,310
regression it's also deterministic and

00:15:24,970 --> 00:15:29,080
reproducible so you don't have to worry

00:15:27,310 --> 00:15:30,360
about stochastic wireless behavior you

00:15:29,080 --> 00:15:32,860
don't have to take all your boats

00:15:30,360 --> 00:15:35,070
basically run them for hours you can

00:15:32,860 --> 00:15:39,760
actually run all your tests in minutes

00:15:35,070 --> 00:15:43,380
which is a neat thing and so could we

00:15:39,760 --> 00:15:46,480
take that and then let's say in an ideal

00:15:43,380 --> 00:15:49,390
Dreamland world could you take your

00:15:46,480 --> 00:15:53,620
Bluetooth test case set up your topology

00:15:49,390 --> 00:15:57,220
could you run that in a big-endian

00:15:53,620 --> 00:15:58,840
target and a little endian target of

00:15:57,220 --> 00:16:02,410
some test case that produces some logs

00:15:58,840 --> 00:16:05,290
and maybe that set of logs you can diff

00:16:02,410 --> 00:16:09,400
and you could detect if you had engine s

00:16:05,290 --> 00:16:12,880
issues and it turns out that we can

00:16:09,400 --> 00:16:15,940
because Babel sim and another logical

00:16:12,880 --> 00:16:20,590
contribution native POSIX architecture

00:16:15,940 --> 00:16:23,440
in zephyr allows us to build tempura say

00:16:20,590 --> 00:16:26,620
Linux binary just a userland binary and

00:16:23,440 --> 00:16:30,440
let it connect up to Babel sir there's

00:16:26,620 --> 00:16:32,990
an NRI 52 Babel sim target board

00:16:30,440 --> 00:16:36,560
in Suffern so you can take the

00:16:32,990 --> 00:16:39,380
constellation of any kind of topology

00:16:36,560 --> 00:16:41,330
Bluetooth test case you can run it and

00:16:39,380 --> 00:16:44,450
they're all Linux user land processes

00:16:41,330 --> 00:16:47,540
and since they're just Linux processes

00:16:44,450 --> 00:16:50,690
you can capitalize on all the wealth of

00:16:47,540 --> 00:16:52,220
open-source tools so you have gdb you

00:16:50,690 --> 00:16:56,150
have coccynelle you have darker

00:16:52,220 --> 00:17:03,770
background and queuing but you you can

00:16:56,150 --> 00:17:06,319
see because we we had some we have we

00:17:03,770 --> 00:17:08,300
use our our instead it's the reversible

00:17:06,319 --> 00:17:15,439
debugger do you do nothing against GV

00:17:08,300 --> 00:17:16,699
gdb is fine but RR is even better so so

00:17:15,439 --> 00:17:21,140
but you can see that we have highlighted

00:17:16,699 --> 00:17:24,530
qmo and continent and so we will we will

00:17:21,140 --> 00:17:27,589
explain by QAM we don't mean the board

00:17:24,530 --> 00:17:30,430
simulation so it's not a full board we

00:17:27,589 --> 00:17:33,110
use the in this context here we use the

00:17:30,430 --> 00:17:35,660
user mode emulation so you take you can

00:17:33,110 --> 00:17:38,000
run a foreign binary under the same

00:17:35,660 --> 00:17:41,570
kernel QA mode user mode will intercept

00:17:38,000 --> 00:17:43,940
the system calls and issue them on your

00:17:41,570 --> 00:17:47,420
behalf so you can run you can take a mix

00:17:43,940 --> 00:17:50,060
binary and run it on x86 under the same

00:17:47,420 --> 00:17:52,400
kernel it will appear the same and that

00:17:50,060 --> 00:17:54,890
goes for entire userland so you can

00:17:52,400 --> 00:17:58,100
actually install let's say debian as we

00:17:54,890 --> 00:18:00,680
will see if completely foreign and

00:17:58,100 --> 00:18:04,010
that's what we're gonna do so we're

00:18:00,680 --> 00:18:07,760
going to compile babel sim and suffer

00:18:04,010 --> 00:18:10,670
for native POSIX for MIPS little and big

00:18:07,760 --> 00:18:14,240
under the exact same software versions

00:18:10,670 --> 00:18:16,910
and just run it twice and that will give

00:18:14,240 --> 00:18:19,550
us err logs times 2000 and then we can

00:18:16,910 --> 00:18:22,880
give those logs but that will basically

00:18:19,550 --> 00:18:25,070
just branch out very early and we will

00:18:22,880 --> 00:18:28,550
just see yeah there's at least one and

00:18:25,070 --> 00:18:30,560
eNOS error but not tell us where so

00:18:28,550 --> 00:18:35,060
that's where the location comes into

00:18:30,560 --> 00:18:37,370
play and if we instrument so the code

00:18:35,060 --> 00:18:38,600
that we suspect to have some engine has

00:18:37,370 --> 00:18:41,840
errors

00:18:38,600 --> 00:18:44,960
in our case the controller we may write

00:18:41,840 --> 00:18:48,529
a semantic patch with coccynelle to

00:18:44,960 --> 00:18:51,139
inject some source level tracing into

00:18:48,529 --> 00:18:56,240
that code and simply do another run and

00:18:51,139 --> 00:18:59,720
then we get more very verbose logs and a

00:18:56,240 --> 00:19:02,559
much earlier branch output so to

00:18:59,720 --> 00:19:06,679
facilitate that and we have contributed

00:19:02,559 --> 00:19:09,230
another small project deviant foreign

00:19:06,679 --> 00:19:11,029
you may find it down there and it

00:19:09,230 --> 00:19:13,700
basically just provides a for each

00:19:11,029 --> 00:19:16,519
architecture thing and the payload is

00:19:13,700 --> 00:19:20,230
whatever Linux executable script or

00:19:16,519 --> 00:19:24,350
whatever you may your hot the Tsar is so

00:19:20,230 --> 00:19:26,299
it's just to facilitate the setup and

00:19:24,350 --> 00:19:29,299
making it so it's it's a docker image

00:19:26,299 --> 00:19:34,700
and it comes pre baked with with these

00:19:29,299 --> 00:19:40,750
two debian foreign environments so it's

00:19:34,700 --> 00:19:43,669
a mips little-endian and big-endian and

00:19:40,750 --> 00:19:47,269
within them what you want to run is of

00:19:43,669 --> 00:19:49,039
course two instances of sefar so in our

00:19:47,269 --> 00:19:50,779
case is the basic connection test so

00:19:49,039 --> 00:19:53,240
there's a peripheral and a central and

00:19:50,779 --> 00:19:56,419
you want to connect those up to babel

00:19:53,240 --> 00:19:58,909
sim so the air scheduler and that will

00:19:56,419 --> 00:20:01,970
produce this set of traces a set of logs

00:19:58,909 --> 00:20:10,000
and so you take these two sets of logs

00:20:01,970 --> 00:20:10,000
and we will dip those logs since

00:20:10,040 --> 00:20:17,390
okay so before the demo let's look at

00:20:15,050 --> 00:20:20,630
how we inject these traces

00:20:17,390 --> 00:20:22,300
so normally coccynelle is not used for

00:20:20,630 --> 00:20:25,630
this kind of thing it's more like what

00:20:22,300 --> 00:20:28,010
meant for retroactive you have

00:20:25,630 --> 00:20:30,290
identified some bug and now you need to

00:20:28,010 --> 00:20:33,500
patch that in across a million lines of

00:20:30,290 --> 00:20:35,990
linux kernel source code but here we

00:20:33,500 --> 00:20:37,880
actually use coccynelle in a slightly

00:20:35,990 --> 00:20:41,720
different way as an active debugging

00:20:37,880 --> 00:20:45,740
tool to instrument code so one thing is

00:20:41,720 --> 00:20:49,280
just basic control for and these are

00:20:45,740 --> 00:20:52,640
written up in unified as like kind of

00:20:49,280 --> 00:20:54,560
unified if you have an optional name and

00:20:52,640 --> 00:20:57,800
the qualifiers that you want to match

00:20:54,560 --> 00:21:03,590
for so a type and identifier so this is

00:20:57,800 --> 00:21:06,560
like a sea specific sed grep and

00:21:03,590 --> 00:21:08,360
replacement thing just knowledgeable

00:21:06,560 --> 00:21:11,660
about sea and the abstract syntax tree

00:21:08,360 --> 00:21:13,840
of the sea so you want to match for

00:21:11,660 --> 00:21:17,270
every function you want to match every

00:21:13,840 --> 00:21:20,000
expression in every function and when

00:21:17,270 --> 00:21:23,780
you encounter that you want to put in a

00:21:20,000 --> 00:21:27,760
trace statement just before that so this

00:21:23,780 --> 00:21:31,400
my trace will then be some kind of macro

00:21:27,760 --> 00:21:35,120
and for us we put that in a globally

00:21:31,400 --> 00:21:37,820
included POSIX teeth for sefar so it's

00:21:35,120 --> 00:21:40,040
always defined and we just define it to

00:21:37,820 --> 00:21:42,410
some printf function print kay function

00:21:40,040 --> 00:21:46,790
that stringify is the argument and just

00:21:42,410 --> 00:21:48,710
print it out yeah so that gives us

00:21:46,790 --> 00:21:50,780
control flow but for endianness we

00:21:48,710 --> 00:21:53,750
actually want to have differences in

00:21:50,780 --> 00:21:56,870
these logs for data for the actual

00:21:53,750 --> 00:22:00,860
values so then we also do the same for

00:21:56,870 --> 00:22:04,970
scalar quantities so for any kind of U

00:22:00,860 --> 00:22:07,550
and 8 16 32 64 any kind of scalar value

00:22:04,970 --> 00:22:11,110
except you know pointers and arrays and

00:22:07,550 --> 00:22:14,149
none are structures we we trace those up

00:22:11,110 --> 00:22:18,679
so again every function

00:22:14,149 --> 00:22:24,469
we have any variable X that is updated

00:22:18,679 --> 00:22:28,759
it's assigned something and then we

00:22:24,469 --> 00:22:30,829
trace out the new value of this X and we

00:22:28,759 --> 00:22:35,569
do something similar for initialization

00:22:30,829 --> 00:22:39,739
in return okay so when we have all of

00:22:35,569 --> 00:22:43,399
those patches written up we also want to

00:22:39,739 --> 00:22:46,369
include a remove traces in the very top

00:22:43,399 --> 00:22:48,949
because if we apply the same semantic

00:22:46,369 --> 00:22:53,029
patch multiple times then it's also

00:22:48,949 --> 00:22:54,859
gonna trace the trace statements which

00:22:53,029 --> 00:22:57,169
is not so nice so we want to first

00:22:54,859 --> 00:23:00,559
remove the peel those out again

00:22:57,169 --> 00:23:02,899
so that allows us to reapply it multiple

00:23:00,559 --> 00:23:05,539
times and that is the definition of

00:23:02,899 --> 00:23:11,739
idempotence so that's a bit makes a bit

00:23:05,539 --> 00:23:14,659
more easy or a bit easier to work with

00:23:11,739 --> 00:23:16,579
then as another convenience is just a

00:23:14,659 --> 00:23:18,279
small batch function called instrument

00:23:16,579 --> 00:23:21,049
we were going to see that in a moment

00:23:18,279 --> 00:23:25,039
and it just takes the path to a file

00:23:21,049 --> 00:23:30,079
that you have a suspect and it will

00:23:25,039 --> 00:23:32,029
produce a temporary file and to the

00:23:30,079 --> 00:23:35,719
original file you will apply the

00:23:32,029 --> 00:23:38,299
semantics patch and we are gonna review

00:23:35,719 --> 00:23:41,869
the difference so then you actually get

00:23:38,299 --> 00:23:44,089
the option of selectively including or

00:23:41,869 --> 00:23:46,729
just merging all the instrumented traces

00:23:44,089 --> 00:23:49,099
over maybe you know there is a false

00:23:46,729 --> 00:23:51,979
positive that you don't want then you

00:23:49,099 --> 00:23:57,559
have to at least the option to meld or

00:23:51,979 --> 00:23:57,799
any kind of idiots on to to do that all

00:23:57,559 --> 00:23:59,779
right

00:23:57,799 --> 00:24:03,289
demo time so this is unfortunately

00:23:59,779 --> 00:24:05,959
recorded because otherwise the build

00:24:03,289 --> 00:24:10,159
times is about 30 seconds each every

00:24:05,959 --> 00:24:16,699
time so that's a bit too much yep so we

00:24:10,159 --> 00:24:20,199
are first of all in a workspace here so

00:24:16,699 --> 00:24:23,360
this is a fully furnished pre-baked

00:24:20,199 --> 00:24:28,070
deviant foreign talker image

00:24:23,360 --> 00:24:29,899
this is actually the host but we already

00:24:28,070 --> 00:24:31,610
have a separate workspace and this

00:24:29,899 --> 00:24:34,669
workspace has been mapped through in

00:24:31,610 --> 00:24:36,950
darker and in the secured change route

00:24:34,669 --> 00:24:40,549
all the way through so this is fully

00:24:36,950 --> 00:24:43,580
visible for everybody the workspace so

00:24:40,549 --> 00:24:47,600
it's the same source and we are using

00:24:43,580 --> 00:24:50,149
here a old sefar something something

00:24:47,600 --> 00:24:52,669
from 2nd of January that actually

00:24:50,149 --> 00:24:55,940
contains these antenna spoke still and

00:24:52,669 --> 00:24:57,980
then we have a few hacks on top just to

00:24:55,940 --> 00:25:00,340
make sure that it actually native POSIX

00:24:57,980 --> 00:25:10,749
can compile on this kind of specialized

00:25:00,340 --> 00:25:16,190
meters and so we enter into the docker

00:25:10,749 --> 00:25:21,799
and we will we get the for each command

00:25:16,190 --> 00:25:23,840
and it's simply a secure route for each

00:25:21,799 --> 00:25:26,749
of them and we have the fetching in the

00:25:23,840 --> 00:25:29,659
building and running faces pretty

00:25:26,749 --> 00:25:34,070
standard and then we will proceed to

00:25:29,659 --> 00:25:40,869
fetch and build now so we first fetch

00:25:34,070 --> 00:25:40,869
and build now build this is build

00:25:41,280 --> 00:25:46,950
and it's building twice right so it's

00:25:43,500 --> 00:25:50,910
building for MIPS and MIPS big and

00:25:46,950 --> 00:25:54,960
little india and it's building to suffer

00:25:50,910 --> 00:25:58,020
the peripheral and the central and then

00:25:54,960 --> 00:26:02,460
we're running babel sim twice and we get

00:25:58,020 --> 00:26:06,230
this as you can see the two sets of logs

00:26:02,460 --> 00:26:10,320
so you have mips as big endian and

00:26:06,230 --> 00:26:14,430
little endian Mitsu and these are the

00:26:10,320 --> 00:26:16,170
the participating device or processes so

00:26:14,430 --> 00:26:22,140
there's the central and peripheral and

00:26:16,170 --> 00:26:25,520
the babel sim schedule itself and then

00:26:22,140 --> 00:26:29,190
we will look at we will pick for the

00:26:25,520 --> 00:26:32,760
peripheral we will just inspect the diff

00:26:29,190 --> 00:26:35,250
and there is a diff but it's quite short

00:26:32,760 --> 00:26:38,180
and it was just in the like host thing

00:26:35,250 --> 00:26:43,520
here so nothing not much to see but

00:26:38,180 --> 00:26:49,470
let's instrument with coccynelle patch

00:26:43,520 --> 00:26:52,500
so we instrument the controller and then

00:26:49,470 --> 00:26:57,900
meld pops up and we can see what the

00:26:52,500 --> 00:27:00,030
patch did and then we we get to see that

00:26:57,900 --> 00:27:06,110
yeah there are some you 1/8 and we just

00:27:00,030 --> 00:27:06,110
merge all over save build again

00:27:09,020 --> 00:27:20,240
and run again and in the run here we run

00:27:17,510 --> 00:27:23,330
then you get to see we have a lot of

00:27:20,240 --> 00:27:28,790
output but this is captured in the log

00:27:23,330 --> 00:27:31,150
files and we have data values right so

00:27:28,790 --> 00:27:36,080
this is interesting so then we get to

00:27:31,150 --> 00:27:40,010
look at diff and what lo and behold you

00:27:36,080 --> 00:27:43,640
we actually get to see like 65,536

00:27:40,010 --> 00:27:45,830
becomes a one headline

00:27:43,640 --> 00:27:48,679
I don't know twelve thousand something

00:27:45,830 --> 00:27:52,010
in control that's e enroll disable

00:27:48,679 --> 00:27:54,940
function so there might be an Indian s

00:27:52,010 --> 00:27:58,850
issue there that you want to look at and

00:27:54,940 --> 00:28:02,929
you can look at other things so you want

00:27:58,850 --> 00:28:06,260
to fix that first and redo rinse and

00:28:02,929 --> 00:28:08,600
repeat and you may not trust the further

00:28:06,260 --> 00:28:11,390
down you go that could just be

00:28:08,600 --> 00:28:14,090
derivative effects but you can be pretty

00:28:11,390 --> 00:28:16,720
sure that the first DIF will be a source

00:28:14,090 --> 00:28:16,720
of vengeance

00:28:21,380 --> 00:28:26,590
yeah you can see all the places here yep

00:28:26,780 --> 00:28:33,110
all right so this is by no means the

00:28:30,230 --> 00:28:36,190
only things that also put Oregon has

00:28:33,110 --> 00:28:39,610
contributed just to summarize we have

00:28:36,190 --> 00:28:44,770
done a lot of portability pipe cleaning

00:28:39,610 --> 00:28:48,380
so c99 stuff the tool chain abstraction

00:28:44,770 --> 00:28:51,980
the art of tree bluetooth a lot of stuff

00:28:48,380 --> 00:28:54,890
on bluetooth so we have split the link

00:28:51,980 --> 00:28:57,680
layer so you can have a common pot an

00:28:54,890 --> 00:29:00,680
upper and a lower link layer so you can

00:28:57,680 --> 00:29:03,440
actually port east more easily to custom

00:29:00,680 --> 00:29:06,440
radios or other radios so there's a

00:29:03,440 --> 00:29:10,130
common and and/or pots all these

00:29:06,440 --> 00:29:13,400
endianness issues how we serialize the

00:29:10,130 --> 00:29:16,130
Bluetooth settings vendor extensions

00:29:13,400 --> 00:29:20,180
because we need proprietary protocols to

00:29:16,130 --> 00:29:24,920
be possible we need to support audio as

00:29:20,180 --> 00:29:27,200
well and then there is the native POSIX

00:29:24,920 --> 00:29:32,900
which is the port of sefar

00:29:27,200 --> 00:29:36,610
and to POSIX threads so yeah it becomes

00:29:32,900 --> 00:29:39,800
a linux executable and then you add in

00:29:36,610 --> 00:29:43,010
for instance some transaction level

00:29:39,800 --> 00:29:48,200
models of well-known harbour example the

00:29:43,010 --> 00:29:54,170
NRF 52 and then you can run that within

00:29:48,200 --> 00:29:57,950
a person as a complete test case just

00:29:54,170 --> 00:30:00,470
exclusively on on Deano's then we have

00:29:57,950 --> 00:30:04,130
tracing we have a comment race format

00:30:00,470 --> 00:30:06,590
back-end in Suffern and we're gonna work

00:30:04,130 --> 00:30:10,400
and extend on that in the future tracing

00:30:06,590 --> 00:30:13,460
is very important to us we want to have

00:30:10,400 --> 00:30:15,380
it more graphical and we also want to

00:30:13,460 --> 00:30:19,490
investigate the kernel shot to when it's

00:30:15,380 --> 00:30:21,560
actually released yeah more bluetooth

00:30:19,490 --> 00:30:25,150
more optimization we are hearing aid

00:30:21,560 --> 00:30:28,010
after all we need to be efficient and

00:30:25,150 --> 00:30:31,940
the toolchain abstraction is close to

00:30:28,010 --> 00:30:34,690
completion there are still these minor

00:30:31,940 --> 00:30:34,690
things left

00:30:34,820 --> 00:30:39,980
we want to improve this graphical

00:30:37,710 --> 00:30:44,340
presentation such that anybody not just

00:30:39,980 --> 00:30:48,299
people with an armed real-time tracing

00:30:44,340 --> 00:30:50,640
framework in Sega RTT can actually do

00:30:48,299 --> 00:30:52,530
graphical debugging and visualizing of

00:30:50,640 --> 00:30:57,830
all the kernel context switches and

00:30:52,530 --> 00:31:00,570
locking and stuff like that and yeah and

00:30:57,830 --> 00:31:04,890
then also suffer as a component having

00:31:00,570 --> 00:31:07,770
several more not as an owner of the

00:31:04,890 --> 00:31:10,110
entire platform that may have been kind

00:31:07,770 --> 00:31:13,230
of the assumption of separate until now

00:31:10,110 --> 00:31:19,410
at least for us and then more modularity

00:31:13,230 --> 00:31:23,630
in-house then yeah links in case you

00:31:19,410 --> 00:31:23,630
want to dig in to some of the stuff here

00:31:27,450 --> 00:31:32,269
I think we have three minutes for

00:31:29,789 --> 00:31:32,269
questioning

00:31:37,880 --> 00:31:42,830
but the difference is there are many

00:31:40,280 --> 00:31:44,360
differences so first of all the most

00:31:42,830 --> 00:31:47,179
visible thing from the build system is

00:31:44,360 --> 00:31:49,940
of course the flags right so of course

00:31:47,179 --> 00:31:53,210
we need to provide flags that work and

00:31:49,940 --> 00:32:00,500
and our compiler uses very different

00:31:53,210 --> 00:32:02,510
flags GCC is I mean this is he who works

00:32:00,500 --> 00:32:05,510
in our compiler works there I mean you

00:32:02,510 --> 00:32:09,410
would have to dig into so the difference

00:32:05,510 --> 00:32:11,600
is that ours is has a clang front-end

00:32:09,410 --> 00:32:15,260
and then there's a custom like middle

00:32:11,600 --> 00:32:17,480
and back-end but it is clang in the

00:32:15,260 --> 00:32:19,820
front-end but with different just for

00:32:17,480 --> 00:32:23,740
the past or not for the command-line

00:32:19,820 --> 00:32:23,740
switches in case

00:32:48,250 --> 00:32:57,650
a I we I know about doctor I but this is

00:32:54,820 --> 00:33:00,819
a hearing aid it doesn't run Linux right

00:32:57,650 --> 00:33:00,819
[Music]

00:33:07,110 --> 00:33:15,640
there's a part of your tool that could

00:33:09,429 --> 00:33:19,080
be okay and also the compiler is is very

00:33:15,640 --> 00:33:19,080
special it has to be our model

00:33:26,909 --> 00:33:32,269
the battery life of can you repeat that

00:33:36,200 --> 00:33:41,970
the battery life of a hearing of our

00:33:39,899 --> 00:33:44,909
hearing it it's I think it's about sixty

00:33:41,970 --> 00:33:46,559
hours right now yeah couple of days yet

00:33:44,909 --> 00:33:49,799
so a couple of days of use I think the

00:33:46,559 --> 00:33:51,570
battery is a hundred and sixty mm I mean

00:33:49,799 --> 00:33:52,889
of course everything is relative so it

00:33:51,570 --> 00:33:54,840
depends on what you're doing if your

00:33:52,889 --> 00:34:02,279
wireless streaming audio all the time

00:33:54,840 --> 00:34:05,759
then it's a bit less yeah yeah but but I

00:34:02,279 --> 00:34:10,250
mean it's meant for kind of a week right

00:34:05,759 --> 00:34:10,250
it's kind of it that's the range

00:34:15,000 --> 00:34:19,289
it's definitely been thought about but I

00:34:16,649 --> 00:34:22,139
don't think it's feasible at this point

00:34:19,289 --> 00:34:22,980
I think it's you just don't get enough

00:34:22,139 --> 00:34:39,599
out of it

00:34:22,980 --> 00:34:41,819
energy has bone anchored yes so we we

00:34:39,599 --> 00:34:43,530
support that and we have that we also

00:34:41,819 --> 00:34:47,220
have cochlear implants where it's

00:34:43,530 --> 00:34:49,349
actually like embedded inside and these

00:34:47,220 --> 00:34:51,149
typically run out of cadence that is

00:34:49,349 --> 00:34:59,089
like delayed because of medical

00:34:51,149 --> 00:34:59,089
certification more strictness but yeah

00:35:08,980 --> 00:35:17,710
we're under FDA so it's I can't remember

00:35:14,289 --> 00:35:19,509
class something yeah yeah there are

00:35:17,710 --> 00:35:22,839
they're strict things I mean all the

00:35:19,509 --> 00:35:26,410
source code that we have we need to

00:35:22,839 --> 00:35:27,009
document prove that everything has been

00:35:26,410 --> 00:35:30,880
reviewed

00:35:27,009 --> 00:35:32,739
so yeah that's labor-intensive and there

00:35:30,880 --> 00:35:36,249
are risk assessment and stuff like that

00:35:32,739 --> 00:35:38,559
also we need to guarantee or at least

00:35:36,249 --> 00:35:43,980
document that it cannot be possible to

00:35:38,559 --> 00:35:43,980
blow a person's ear drum

00:35:50,030 --> 00:35:55,650
all right thank you

00:35:53,330 --> 00:35:55,650

YouTube URL: https://www.youtube.com/watch?v=BGzJp1ybpHo


