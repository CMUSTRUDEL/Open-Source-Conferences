Title: Keynote: Preventing IT Firefighting with Better Infrastructure Security - Greg Marsden
Publication date: 2018-09-04
Playlist: Open Source Summit NA 2018 - Vancouver
Description: 
	Keynote: Preventing IT Firefighting with Better Infrastructure Security - Greg Marsden, Vice President, Linux Development, Oracle

The evolution of Linux and the open source model has delivered the proven performance, stability and reliability required in today’s enterprise/cloud-scale deployments. We continue to deploy in smaller independent on-prem environments, where there’s potential for security vulnerabilities to flare up. But more importantly, those CVEs that create brush fires on the on-prem prairies become towering infernos in the cloud. Case in point: Spectre and Meltdown. We’ve gone from isolated systems to large multi-tenancy environments that increase security risks. How do we build a more secure, less vulnerable infrastructure for every environment?

In his keynote, Greg will elaborate on security and how a very different OS deployment model can help developers react fast and keep their fire lines secure. 

About Greg Marsden
Greg Marsden is Vice President of Linux development at Oracle, where he encourages open source contributions that improve Linux for Oracle's Cloud services, engineered systems and software. He also oversees OS security.  Oracle's Linux kernel team has contributed more than 400,000 lines of code to the Linux kernel and includes the maintainers of Linux SCSI, XFS and hugetlbfs subsystems. Greg joined Oracle in 2000.  He is a founding member of Oracle’s Linux team. Greg holds a degree in Computer Science from Stanford University.
Captions: 
	00:00:00,030 --> 00:00:04,140
hello everybody and welcome my name is

00:00:02,129 --> 00:00:05,549
Greg Mars and I'm responsible for Linux

00:00:04,140 --> 00:00:07,950
kernel development at Oracle

00:00:05,549 --> 00:00:10,320
we provide OS and kernel services for

00:00:07,950 --> 00:00:11,700
Oracle cloud infrastructure upstream

00:00:10,320 --> 00:00:13,500
Linux feature development upstream

00:00:11,700 --> 00:00:15,630
kernel packaging and K splice free

00:00:13,500 --> 00:00:17,460
bootless patching a large part of that

00:00:15,630 --> 00:00:20,010
role has always been security but never

00:00:17,460 --> 00:00:21,570
more prominently than this year in this

00:00:20,010 --> 00:00:23,820
talk I'm going to talk a little bit

00:00:21,570 --> 00:00:25,650
about various approaches to OS security

00:00:23,820 --> 00:00:27,300
from a design and process perspective

00:00:25,650 --> 00:00:29,519
and some of the lessons that have come

00:00:27,300 --> 00:00:31,890
out of these experiences as more

00:00:29,519 --> 00:00:33,870
services start to rely on containers for

00:00:31,890 --> 00:00:36,780
isolation what are the ways to protect

00:00:33,870 --> 00:00:38,280
yourself and your data for those of you

00:00:36,780 --> 00:00:40,140
listening who were involved in this past

00:00:38,280 --> 00:00:42,780
year of security vulnerabilities that

00:00:40,140 --> 00:00:44,100
was an amazing accomplishment to get the

00:00:42,780 --> 00:00:46,350
patch is done and shipped for each

00:00:44,100 --> 00:00:48,210
vulnerability on time thank you so much

00:00:46,350 --> 00:00:49,920
for sticking with that I can't tell you

00:00:48,210 --> 00:00:51,719
how many times we thought we had a

00:00:49,920 --> 00:00:54,000
kernel ready to ship only to hear the

00:00:51,719 --> 00:00:56,699
dreaded phase stop the Brailled we need

00:00:54,000 --> 00:00:59,399
one more patch in there as for the user

00:00:56,699 --> 00:01:01,980
community security isn't new it's just

00:00:59,399 --> 00:01:03,930
finally in the budget take this time to

00:01:01,980 --> 00:01:06,030
get good security policies put in place

00:01:03,930 --> 00:01:08,729
ones that really guarantee that your

00:01:06,030 --> 00:01:10,920
systems will stay up to date the other

00:01:08,729 --> 00:01:13,170
day I got a call from a friend we have a

00:01:10,920 --> 00:01:16,500
winner he said for our system with the

00:01:13,170 --> 00:01:18,840
longest uptime 2258 days without a

00:01:16,500 --> 00:01:22,650
reboot on your kernel we found it in a

00:01:18,840 --> 00:01:25,080
closet 2200 days that's more than six

00:01:22,650 --> 00:01:26,220
years without a reboot I'm still not

00:01:25,080 --> 00:01:28,740
sure whether to be proud of that

00:01:26,220 --> 00:01:30,509
accomplishment or not I mean I still

00:01:28,740 --> 00:01:33,240
feel a little glimmer of joy at a 200

00:01:30,509 --> 00:01:34,710
day uptime or 300 day uptime but on the

00:01:33,240 --> 00:01:36,240
other hand it's now tempered a little

00:01:34,710 --> 00:01:38,610
bit by the knowledge of security

00:01:36,240 --> 00:01:40,259
exploits vulnerabilities and sympathy

00:01:38,610 --> 00:01:42,090
for whatever poor soul is going to have

00:01:40,259 --> 00:01:46,110
to someday upgrade that application to

00:01:42,090 --> 00:01:48,149
use system D if there was if there was

00:01:46,110 --> 00:01:49,950
one benefit to our year of security it

00:01:48,149 --> 00:01:51,720
was routed out routing out boxes like

00:01:49,950 --> 00:01:54,180
this one an artifact of a simpler time

00:01:51,720 --> 00:01:56,219
just try starting a server on any large

00:01:54,180 --> 00:01:58,860
cloud providers public IP block these

00:01:56,219 --> 00:02:00,750
days watch your log files even without a

00:01:58,860 --> 00:02:03,360
host name assigned attacks are going to

00:02:00,750 --> 00:02:06,180
start to roll in security probes SSH

00:02:03,360 --> 00:02:08,129
login attempts Apache post requests it's

00:02:06,180 --> 00:02:11,430
not academic research security breaches

00:02:08,129 --> 00:02:13,170
are up one way to handle that legacy OS

00:02:11,430 --> 00:02:14,700
problem is through containers

00:02:13,170 --> 00:02:16,740
containers are really popular right now

00:02:14,700 --> 00:02:19,319
and for good reason strict container

00:02:16,740 --> 00:02:21,510
usage provides process isolation creates

00:02:19,319 --> 00:02:23,910
a natural sandbox environment should an

00:02:21,510 --> 00:02:26,010
attacker be successful after all they're

00:02:23,910 --> 00:02:27,900
still stuck in that container and this

00:02:26,010 --> 00:02:30,000
makes for pretty decent security to an

00:02:27,900 --> 00:02:32,160
extent containers do share a lot with

00:02:30,000 --> 00:02:34,440
the host OS and share a lot with each

00:02:32,160 --> 00:02:36,420
other it's one kernel running around

00:02:34,440 --> 00:02:37,709
underneath all the containers and a

00:02:36,420 --> 00:02:39,780
vulnerability that affects that

00:02:37,709 --> 00:02:40,980
container is a vulnerability in a kernel

00:02:39,780 --> 00:02:43,560
that's going to affect every container

00:02:40,980 --> 00:02:45,540
running on that system meanwhile each

00:02:43,560 --> 00:02:47,519
container has its own user space runtime

00:02:45,540 --> 00:02:50,519
stack with their own sets of security

00:02:47,519 --> 00:02:51,989
updates containers will still be updated

00:02:50,519 --> 00:02:53,850
if the on disk version of the library is

00:02:51,989 --> 00:02:56,370
updated but only if the container is

00:02:53,850 --> 00:02:57,660
actively restarted until it restarts it

00:02:56,370 --> 00:03:00,120
has the old version of all of those

00:02:57,660 --> 00:03:01,650
libraries applications which are written

00:03:00,120 --> 00:03:03,930
to live in containers using a micro

00:03:01,650 --> 00:03:05,880
service architecture those would

00:03:03,930 --> 00:03:07,860
actually be updated because they're easy

00:03:05,880 --> 00:03:11,040
to update but if it's going to be a

00:03:07,860 --> 00:03:12,239
legacy type application those real-world

00:03:11,040 --> 00:03:13,340
container workloads are going to have

00:03:12,239 --> 00:03:15,360
the same uptime and availability

00:03:13,340 --> 00:03:17,340
requirements as a classic data center

00:03:15,360 --> 00:03:18,930
service which means that despite the

00:03:17,340 --> 00:03:20,760
advantage of deployment and packaging

00:03:18,930 --> 00:03:22,260
container security isn't really that

00:03:20,760 --> 00:03:24,870
much better than the old model of

00:03:22,260 --> 00:03:26,840
application development containers also

00:03:24,870 --> 00:03:29,670
provide a perfect jumping off point for

00:03:26,840 --> 00:03:31,590
side-channel attacks running on shared

00:03:29,670 --> 00:03:33,140
processor resources and sharing kernel

00:03:31,590 --> 00:03:35,340
and system services between each other

00:03:33,140 --> 00:03:37,530
side channel attacks work against

00:03:35,340 --> 00:03:39,480
processes running on hyper threads and C

00:03:37,530 --> 00:03:41,670
groups and namespaces don't necessarily

00:03:39,480 --> 00:03:43,489
give native protection against sharing

00:03:41,670 --> 00:03:46,530
processor resources with potentially

00:03:43,489 --> 00:03:48,420
antagonistic workloads we are really

00:03:46,530 --> 00:03:50,670
excited about the provost the promise of

00:03:48,420 --> 00:03:52,440
the Cata containers project rather than

00:03:50,670 --> 00:03:54,359
running as processes and namespaces

00:03:52,440 --> 00:03:55,799
cotta containers take advantage of

00:03:54,359 --> 00:03:57,930
hardware virtualization for process

00:03:55,799 --> 00:03:59,850
isolation and using a stripped-down

00:03:57,930 --> 00:04:02,609
kernel that boots in seconds these

00:03:59,850 --> 00:04:04,049
special containers use those hardware

00:04:02,609 --> 00:04:05,670
virtualization features to defend

00:04:04,049 --> 00:04:07,799
against cross contamination with other

00:04:05,670 --> 00:04:09,660
containers and will be able to take

00:04:07,799 --> 00:04:13,470
advantage of kvms defenses against

00:04:09,660 --> 00:04:14,730
side-channel attacks that problem of one

00:04:13,470 --> 00:04:16,979
vulnerability showing up in every

00:04:14,730 --> 00:04:19,320
container is only magnified in the cloud

00:04:16,979 --> 00:04:21,330
world where containers share one kernel

00:04:19,320 --> 00:04:22,919
across the computer clouds end up

00:04:21,330 --> 00:04:25,110
sharing a hypervisor across the entire

00:04:22,919 --> 00:04:27,000
fleet clouds still have plenty of

00:04:25,110 --> 00:04:28,710
software diversity at the guest layer

00:04:27,000 --> 00:04:30,230
but they enforce much stricter controls

00:04:28,710 --> 00:04:33,180
of the service and hypervisor layers

00:04:30,230 --> 00:04:34,680
clouds have managed to standardize to

00:04:33,180 --> 00:04:37,020
some extent the hypervisor and

00:04:34,680 --> 00:04:39,210
virtualization environments to provide

00:04:37,020 --> 00:04:41,160
an enforced consistency across that

00:04:39,210 --> 00:04:43,260
whole environment an ideal cloud would

00:04:41,160 --> 00:04:45,720
have just one OS platform running all of

00:04:43,260 --> 00:04:47,700
its services just 1 hypervisor version

00:04:45,720 --> 00:04:49,590
that's running in those services that's

00:04:47,700 --> 00:04:51,420
always kept fully up-to-date fully

00:04:49,590 --> 00:04:52,200
patched and can be patched for security

00:04:51,420 --> 00:04:54,570
at a moment's notice

00:04:52,200 --> 00:04:56,160
because when security vulnerabilities

00:04:54,570 --> 00:04:58,500
are fixed they need to be fixed

00:04:56,160 --> 00:05:00,930
everywhere because having a homogeneous

00:04:58,500 --> 00:05:02,700
environment means a faster response time

00:05:00,930 --> 00:05:04,830
and it means that a vulnerability that

00:05:02,700 --> 00:05:06,840
can be patched there will be patched on

00:05:04,830 --> 00:05:08,730
all the systems instantly there's a

00:05:06,840 --> 00:05:12,540
saying for this put all your eggs in one

00:05:08,730 --> 00:05:14,730
basket and watch that basket for our

00:05:12,540 --> 00:05:17,460
cloud that means relying on reboot

00:05:14,730 --> 00:05:18,540
--less live patching live patching is

00:05:17,460 --> 00:05:20,850
now fairly commonplace

00:05:18,540 --> 00:05:22,740
that used to be magic in the case Pleiss

00:05:20,850 --> 00:05:24,030
team worked very hard to convince this

00:05:22,740 --> 00:05:25,650
admins that they really could patch

00:05:24,030 --> 00:05:28,169
their kernels in real time without

00:05:25,650 --> 00:05:29,790
requiring reboots here's why you want to

00:05:28,169 --> 00:05:32,160
think about live patching solutions for

00:05:29,790 --> 00:05:34,260
your production workloads cloud service

00:05:32,160 --> 00:05:35,430
providers often can get early

00:05:34,260 --> 00:05:37,830
disclosures for security vulnerabilities

00:05:35,430 --> 00:05:39,750
but end-user is really only found out

00:05:37,830 --> 00:05:41,880
when those public disclosures come out

00:05:39,750 --> 00:05:44,010
so live patching is really the next best

00:05:41,880 --> 00:05:46,140
thing having a system that can actually

00:05:44,010 --> 00:05:49,229
respond and pivot to attacks in real

00:05:46,140 --> 00:05:51,030
time towards a self-healing OS and the

00:05:49,229 --> 00:05:52,740
abilities of live patching have scaled

00:05:51,030 --> 00:05:55,800
farther than we ever could have imagined

00:05:52,740 --> 00:05:58,050
for the latest variant of spectre we

00:05:55,800 --> 00:06:00,120
were actually the l1 terminal fault one

00:05:58,050 --> 00:06:02,250
we were actually able to apply in real

00:06:00,120 --> 00:06:04,050
time a patch that ran more than 2,000

00:06:02,250 --> 00:06:07,080
lines of kernel code across 50 kernel

00:06:04,050 --> 00:06:09,000
files in real time without rebooting now

00:06:07,080 --> 00:06:12,180
that's how you keep a fleet secure and

00:06:09,000 --> 00:06:14,130
why his patching been in the news well

00:06:12,180 --> 00:06:15,690
the latest raft of security

00:06:14,130 --> 00:06:17,610
vulnerabilities come from a new class of

00:06:15,690 --> 00:06:20,400
exploit known as speculative execution

00:06:17,610 --> 00:06:22,080
side-channel attacks like other side

00:06:20,400 --> 00:06:24,240
channel attacks they take advantage of

00:06:22,080 --> 00:06:26,640
external measurable characteristics of

00:06:24,240 --> 00:06:29,220
the processor like power consumption or

00:06:26,640 --> 00:06:30,930
temperature and in this case it's timing

00:06:29,220 --> 00:06:32,880
the loads and stores precisely in the

00:06:30,930 --> 00:06:35,340
speculative execution pipeline and

00:06:32,880 --> 00:06:37,560
timing those results it's not directly

00:06:35,340 --> 00:06:39,570
reading data but the latest optimized

00:06:37,560 --> 00:06:40,650
proof of concepts have refined this to a

00:06:39,570 --> 00:06:43,800
data exfiltration

00:06:40,650 --> 00:06:45,300
tool what slows that attack down is that

00:06:43,800 --> 00:06:46,830
each bit of data requires sometimes

00:06:45,300 --> 00:06:48,900
hundreds or thousands of attempts and

00:06:46,830 --> 00:06:50,400
comparisons and the good news is that we

00:06:48,900 --> 00:06:52,800
don't actually know of many real-world

00:06:50,400 --> 00:06:54,479
exploits of this yet probably because

00:06:52,800 --> 00:06:56,580
it's easier just to send out some spear

00:06:54,479 --> 00:06:58,710
phishing emails but as people get

00:06:56,580 --> 00:06:59,940
smarter about their soft security we

00:06:58,710 --> 00:07:02,100
need to start thinking about some of

00:06:59,940 --> 00:07:03,330
these back channel attacks as well the

00:07:02,100 --> 00:07:04,620
bad news is that many of these

00:07:03,330 --> 00:07:06,479
speculation based attacks are

00:07:04,620 --> 00:07:09,120
indistinguishable from correct processor

00:07:06,479 --> 00:07:11,430
operation and can be mitigated but not

00:07:09,120 --> 00:07:12,870
detected there's been a lot of

00:07:11,430 --> 00:07:15,090
discussion about the vulnerability

00:07:12,870 --> 00:07:17,460
disclosures that came out even just a

00:07:15,090 --> 00:07:19,110
moment ago despite the very late notice

00:07:17,460 --> 00:07:20,940
I think all the OS vendors were able to

00:07:19,110 --> 00:07:23,370
scramble and have those vulnerabilities

00:07:20,940 --> 00:07:25,410
patch at the same time it was not a fun

00:07:23,370 --> 00:07:27,389
exercise you know there's an inherent

00:07:25,410 --> 00:07:29,490
conflict to keeping embargoed security

00:07:27,389 --> 00:07:32,160
ability security vulnerabilities private

00:07:29,490 --> 00:07:33,660
in an open source community but it's

00:07:32,160 --> 00:07:35,610
done it's going to do more harm than

00:07:33,660 --> 00:07:37,169
good if those security vulnerabilities

00:07:35,610 --> 00:07:39,570
are exposed before they can be patched

00:07:37,169 --> 00:07:41,509
therefore sometimes it is necessary to

00:07:39,570 --> 00:07:43,800
have secrets even in an open community

00:07:41,509 --> 00:07:46,620
those vulnerabilities don't stay secret

00:07:43,800 --> 00:07:48,090
forever they do get published even the

00:07:46,620 --> 00:07:50,940
vulnerability code sometimes becomes

00:07:48,090 --> 00:07:52,650
open responsible disclosure gives the

00:07:50,940 --> 00:07:54,479
vendors a chance to fix the bugs and

00:07:52,650 --> 00:07:56,430
gives Linux developers a chance to fix

00:07:54,479 --> 00:07:58,260
those bugs and I want to thank some of

00:07:56,430 --> 00:07:59,699
the researchers at tu Graz and many of

00:07:58,260 --> 00:08:01,620
the other ones who have ensured the

00:07:59,699 --> 00:08:03,139
bluemix community had the chance to

00:08:01,620 --> 00:08:05,909
patch those vulnerabilities in advance

00:08:03,139 --> 00:08:07,470
Intel also has significantly improved

00:08:05,909 --> 00:08:09,000
their cross vendor collaboration and

00:08:07,470 --> 00:08:10,530
helped to build a mechanism for

00:08:09,000 --> 00:08:14,729
responding to these types of issues

00:08:10,530 --> 00:08:16,409
across the entire Linux ecosystem even

00:08:14,729 --> 00:08:18,870
when everything goes right security is a

00:08:16,409 --> 00:08:20,220
race against time or attackers and time

00:08:18,870 --> 00:08:22,979
and again patches have come out at the

00:08:20,220 --> 00:08:25,289
literal last possible minute so what's

00:08:22,979 --> 00:08:27,000
next for security we've already talked

00:08:25,289 --> 00:08:28,979
about the promise of cada containers and

00:08:27,000 --> 00:08:30,599
the magic of live patching in the

00:08:28,979 --> 00:08:32,250
side-channel ground work focuses on

00:08:30,599 --> 00:08:34,260
restricting available secrets within the

00:08:32,250 --> 00:08:36,240
kernel with proposals including looking

00:08:34,260 --> 00:08:38,400
at removing page table entries entirely

00:08:36,240 --> 00:08:40,740
from the host OS while it's running in a

00:08:38,400 --> 00:08:42,510
potentially untrusted context and only

00:08:40,740 --> 00:08:44,730
replacing that entry when it's flushed

00:08:42,510 --> 00:08:46,440
those secrets out we also need to focus

00:08:44,730 --> 00:08:48,330
on traditional security and traditional

00:08:46,440 --> 00:08:50,640
attacks because where else is this

00:08:48,330 --> 00:08:52,200
innovation progressing we're looking at

00:08:50,640 --> 00:08:53,300
developing run time patches for deal

00:08:52,200 --> 00:08:54,920
emcee

00:08:53,300 --> 00:08:56,510
already exists to some extent with case

00:08:54,920 --> 00:08:57,680
place but I think there's a lot more

00:08:56,510 --> 00:08:59,240
room to make that efficient and

00:08:57,680 --> 00:09:01,790
effective across thousands of active

00:08:59,240 --> 00:09:03,110
containers using set comp to prevent

00:09:01,790 --> 00:09:06,110
containers from touching unpermitted

00:09:03,110 --> 00:09:07,700
system calls combined with SELinux we

00:09:06,110 --> 00:09:09,110
can provide a very good traditional

00:09:07,700 --> 00:09:11,209
security isolation model for

00:09:09,110 --> 00:09:12,920
containerized workloads at the penalty

00:09:11,209 --> 00:09:14,480
and there is a bit of a performance

00:09:12,920 --> 00:09:16,910
penalty but we're working very hard to

00:09:14,480 --> 00:09:18,589
remove that so how do we prevent the

00:09:16,910 --> 00:09:21,140
inevitable firefighting that comes when

00:09:18,589 --> 00:09:22,880
security vulnerabilities are revealed by

00:09:21,140 --> 00:09:25,430
ensuring their infrastructure is in a

00:09:22,880 --> 00:09:27,350
state to be patched quickly security

00:09:25,430 --> 00:09:29,390
comes at every layer in the stack from

00:09:27,350 --> 00:09:30,920
hardware to virtualization os/2

00:09:29,390 --> 00:09:33,440
container and of course at the

00:09:30,920 --> 00:09:35,839
application layer to the most important

00:09:33,440 --> 00:09:38,480
thing we as developers can do is to make

00:09:35,839 --> 00:09:40,339
sure security is easy after all if

00:09:38,480 --> 00:09:42,470
applying security fixes is difficult or

00:09:40,339 --> 00:09:44,120
impacts end-users then most companies

00:09:42,470 --> 00:09:46,459
will delay weeks or months or longer

00:09:44,120 --> 00:09:48,890
before the scheduled critical downtime

00:09:46,459 --> 00:09:51,110
to patch the OS don't let that be your

00:09:48,890 --> 00:09:53,000
company insist on a regular maintenance

00:09:51,110 --> 00:09:55,010
cycle and applications that are designed

00:09:53,000 --> 00:09:56,990
with patching in mind because when a

00:09:55,010 --> 00:09:58,940
security issue is revealed it can turn

00:09:56,990 --> 00:10:01,220
into a week or a weekend long patching

00:09:58,940 --> 00:10:02,720
nightmare a combination of preparedness

00:10:01,220 --> 00:10:04,660
and rapid response can make the

00:10:02,720 --> 00:10:07,370
difference between security and outage

00:10:04,660 --> 00:10:08,720
there is a secure so that is the silver

00:10:07,370 --> 00:10:10,640
lining to this year of security

00:10:08,720 --> 00:10:11,959
vulnerabilities and it is that people

00:10:10,640 --> 00:10:15,470
are finally starting to take security

00:10:11,959 --> 00:10:17,510
seriously we are finding those machines

00:10:15,470 --> 00:10:19,130
that have those 2,000 day up times and

00:10:17,510 --> 00:10:21,410
scheduling them for maintenance and

00:10:19,130 --> 00:10:23,000
modernization we as an industry or

00:10:21,410 --> 00:10:25,459
building a robust infrastructure that

00:10:23,000 --> 00:10:27,079
can be patched quickly and safely and I

00:10:25,459 --> 00:10:29,420
don't know the next time that I hear

00:10:27,079 --> 00:10:31,880
someone say hey I've got just one more

00:10:29,420 --> 00:10:34,670
patch we'll be able to pull it in no

00:10:31,880 --> 00:10:36,270
problem I hope all of you will - thank

00:10:34,670 --> 00:10:42,059
you very much

00:10:36,270 --> 00:10:42,059

YouTube URL: https://www.youtube.com/watch?v=VBv8g2oSsDo


