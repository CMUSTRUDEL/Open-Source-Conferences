Title: DjangoCon US 2015 - I never Meta model I didn't like... by Russell Keith-Magee
Publication date: 2017-11-03
Playlist: DjangoCon US 2015
Description: 
	I never Meta model I didn't like: The Django 1.8 Meta Interface


This talk will explain the new Meta API, and look at Daniel Pyrathon's django-mailer as an example of using Meta in the real world.

Talk outline: What is meta programming - Reflection in Python - What this means in Django History of Django's Meta The new Meta API - Daniel's GSoC project - API walkthrough So why bother? - How Forms use meta - How Admin uses meta - django-mailer: GMail in contrib.admin * Other options? - A teaser of other places where this could be used.
Captions: 
	00:00:15,619 --> 00:00:21,390
well good afternoon Cleveland as I said

00:00:19,680 --> 00:00:23,789
my name is Russell Keith McGee my day

00:00:21,390 --> 00:00:24,210
job is as CTO and co-founder of trades

00:00:23,789 --> 00:00:25,320
club

00:00:24,210 --> 00:00:26,640
we're an Australian software as a

00:00:25,320 --> 00:00:28,130
service for trades people plumbers

00:00:26,640 --> 00:00:30,960
electricians carpenters people like that

00:00:28,130 --> 00:00:32,820
but the reason I'm here today is Django

00:00:30,960 --> 00:00:35,280
I've been a core team member for the

00:00:32,820 --> 00:00:37,410
last 10 years president of the DSF since

00:00:35,280 --> 00:00:40,110
2011 I've served on the Technical Review

00:00:37,410 --> 00:00:42,719
Board for the 1.7 1.8 releases and I'm

00:00:40,110 --> 00:00:43,860
also on the security team but one of the

00:00:42,719 --> 00:00:46,020
other roles that I've assumed over the

00:00:43,860 --> 00:00:47,879
years is as a mentor in the google

00:00:46,020 --> 00:00:49,410
Summer of Code for those who aren't

00:00:47,879 --> 00:00:51,390
familiar with the program Google Summer

00:00:49,410 --> 00:00:53,670
of Code is effectively an internship for

00:00:51,390 --> 00:00:55,770
college students open source projects

00:00:53,670 --> 00:00:58,620
apply to have students the students then

00:00:55,770 --> 00:01:01,020
apply to be a mentor in that particular

00:00:58,620 --> 00:01:03,090
project Google very kindly picks up the

00:01:01,020 --> 00:01:05,220
tab of paying them a stipend in exchange

00:01:03,090 --> 00:01:05,850
for 12 weeks of contribution to an open

00:01:05,220 --> 00:01:07,979
source project

00:01:05,850 --> 00:01:09,930
the only catch it needs to be open

00:01:07,979 --> 00:01:12,900
source and it needs to be done as solo

00:01:09,930 --> 00:01:16,110
work mentored by an expert from that

00:01:12,900 --> 00:01:17,220
project now this year this this year is

00:01:16,110 --> 00:01:19,170
actually one of the first years in

00:01:17,220 --> 00:01:20,759
about6 that I haven't Adak been actively

00:01:19,170 --> 00:01:22,380
mentoring a student but over the years

00:01:20,759 --> 00:01:23,939
the google Summer of Code has resulted

00:01:22,380 --> 00:01:25,650
in a number of very large features that

00:01:23,939 --> 00:01:27,479
have been added to Django the fact we've

00:01:25,650 --> 00:01:29,460
got multiple database support the ORM

00:01:27,479 --> 00:01:32,790
aggregation API is the systems check

00:01:29,460 --> 00:01:36,270
framework in 1.7 and in 1.8 a formalized

00:01:32,790 --> 00:01:38,759
metamodel ok so what is a meta model and

00:01:36,270 --> 00:01:40,259
what is meta programming well in short

00:01:38,759 --> 00:01:42,390
meta programming is when you're writing

00:01:40,259 --> 00:01:44,820
code that can reason about the code that

00:01:42,390 --> 00:01:46,079
is running it's especially useful when

00:01:44,820 --> 00:01:48,149
you're writing generic frameworks

00:01:46,079 --> 00:01:50,130
because instead of encoding specific

00:01:48,149 --> 00:01:53,939
situations you're encoding how to

00:01:50,130 --> 00:01:55,979
respond to a generic situation an easy

00:01:53,939 --> 00:01:58,740
warm up example meta programming can be

00:01:55,979 --> 00:02:00,270
found inside Python itself let's say

00:01:58,740 --> 00:02:01,740
we're going to do some graphics ok so

00:02:00,270 --> 00:02:03,810
we're going to need a point class to

00:02:01,740 --> 00:02:05,640
represent the points on our graphics

00:02:03,810 --> 00:02:07,920
graphics cans of canvas we're going to

00:02:05,640 --> 00:02:09,360
be both 2d and 3d representation so

00:02:07,920 --> 00:02:10,590
we're going to use some sub classing ok

00:02:09,360 --> 00:02:12,030
nothing too challenging here we've got

00:02:10,590 --> 00:02:14,480
some initialization methods we take some

00:02:12,030 --> 00:02:17,010
arguments we instantiate them some

00:02:14,480 --> 00:02:18,390
we want to be able to output those

00:02:17,010 --> 00:02:20,069
points in some way so you're right so

00:02:18,390 --> 00:02:21,270
now I put methods your right output

00:02:20,069 --> 00:02:22,470
point for a two-dimensional point an

00:02:21,270 --> 00:02:24,300
output point for a three-dimensional

00:02:22,470 --> 00:02:26,400
point okay nothing too challenging there

00:02:24,300 --> 00:02:29,400
and when you run them you get exactly

00:02:26,400 --> 00:02:31,170
what you'd expect but what you really

00:02:29,400 --> 00:02:33,270
want is rather than having a separate

00:02:31,170 --> 00:02:34,830
method for each type of point you really

00:02:33,270 --> 00:02:36,660
want to have a single method that will

00:02:34,830 --> 00:02:39,690
take an object a point of any type and

00:02:36,660 --> 00:02:40,800
output it appropriately and that's easy

00:02:39,690 --> 00:02:42,720
enough to write as well you know if

00:02:40,800 --> 00:02:44,100
you're coming from a language like C++

00:02:42,720 --> 00:02:45,989
that doesn't have meta programming tools

00:02:44,100 --> 00:02:47,160
or Java which has meta programming tools

00:02:45,989 --> 00:02:49,410
that doesn't encourage you to use them

00:02:47,160 --> 00:02:51,060
that much you might be inclined to do

00:02:49,410 --> 00:02:52,800
something like this you do a class check

00:02:51,060 --> 00:02:54,630
okay we've got one method called output

00:02:52,800 --> 00:02:55,739
point we're going to print the things

00:02:54,630 --> 00:02:57,989
that we know are common the x and the y

00:02:55,739 --> 00:03:00,030
coordinate and then if this point that

00:02:57,989 --> 00:03:01,739
we've been given is an instance of a 3d

00:03:00,030 --> 00:03:03,840
point then print the Zed coordinate as

00:03:01,739 --> 00:03:06,209
well okay and that does work there's

00:03:03,840 --> 00:03:07,739
nothing wrong with that but a more

00:03:06,209 --> 00:03:10,290
pythonic approach is to use

00:03:07,739 --> 00:03:12,239
metaprogramming what you do is you can

00:03:10,290 --> 00:03:14,160
every you can check for a class if you

00:03:12,239 --> 00:03:16,050
check for a class that you're only

00:03:14,160 --> 00:03:18,269
checking for 3d points that will work

00:03:16,050 --> 00:03:21,060
but if you check for properties of the

00:03:18,269 --> 00:03:23,000
instance you can adapt to any type as

00:03:21,060 --> 00:03:25,920
long as it has the right attributes and

00:03:23,000 --> 00:03:28,530
so python provides a tool provides a

00:03:25,920 --> 00:03:30,209
built-in method called Hazara that is

00:03:28,530 --> 00:03:31,950
what you're checking is rather than

00:03:30,209 --> 00:03:34,260
saying is this object of this class

00:03:31,950 --> 00:03:38,579
you're saying if this object has the

00:03:34,260 --> 00:03:40,260
attribute Z then print it the worth is

00:03:38,579 --> 00:03:41,880
even more attributes we're going to

00:03:40,260 --> 00:03:44,670
start modeling Doctor Who now so we need

00:03:41,880 --> 00:03:46,440
to include time into our XYZ coordinate

00:03:44,670 --> 00:03:49,290
so that means we've got to do another

00:03:46,440 --> 00:03:51,239
has a tragic right well no because again

00:03:49,290 --> 00:03:53,610
we can use metaprogramming here every

00:03:51,239 --> 00:03:55,019
Python object has a special attribute

00:03:53,610 --> 00:03:57,810
named dunder dict

00:03:55,019 --> 00:04:01,320
that contains all the attributes of that

00:03:57,810 --> 00:04:03,329
instance so second line there it says

00:04:01,320 --> 00:04:05,489
Peter object that's all the attributes

00:04:03,329 --> 00:04:07,860
of that instance we sort those and we

00:04:05,489 --> 00:04:09,959
iterate over them for each of them we're

00:04:07,860 --> 00:04:12,420
going to print out that attribute the

00:04:09,959 --> 00:04:16,769
name of the attribute and get the value

00:04:12,420 --> 00:04:17,669
of that attribute off the object P now

00:04:16,769 --> 00:04:19,650
the thing that's interesting is that

00:04:17,669 --> 00:04:23,580
that definition will work with any

00:04:19,650 --> 00:04:25,800
object not just points you can point any

00:04:23,580 --> 00:04:27,630
Python object at that method and it work

00:04:25,800 --> 00:04:29,730
as long as the the attribute can be out

00:04:27,630 --> 00:04:32,720
what is a string that will successfully

00:04:29,730 --> 00:04:35,250
output a representation of that object

00:04:32,720 --> 00:04:36,600
now that is admittedly a very much

00:04:35,250 --> 00:04:37,530
contrived example you probably wouldn't

00:04:36,600 --> 00:04:40,080
actually build it that way you'd

00:04:37,530 --> 00:04:41,460
actually use the the wrapper method or

00:04:40,080 --> 00:04:43,710
string method on the actual class itself

00:04:41,460 --> 00:04:45,600
but it's enough to demonstrate the point

00:04:43,710 --> 00:04:47,340
by leveraging metaprogramming you can do

00:04:45,600 --> 00:04:49,410
some very powerful things with very

00:04:47,340 --> 00:04:53,190
little code and in pison at least it's

00:04:49,410 --> 00:04:54,720
fairly easy to understand code ok so

00:04:53,190 --> 00:04:56,460
what does this metaprogramming mean when

00:04:54,720 --> 00:04:57,780
we move to January well it means being

00:04:56,460 --> 00:05:00,000
able to do some the same sort of thing

00:04:57,780 --> 00:05:02,940
we just did with Python objects but do

00:05:00,000 --> 00:05:04,620
it with data base models one obvious

00:05:02,940 --> 00:05:07,080
place this is really useful is model

00:05:04,620 --> 00:05:08,880
forms I have a Django model it has a

00:05:07,080 --> 00:05:11,760
bunch of fields I want to be able to

00:05:08,880 --> 00:05:14,580
display a form to edit an instance of

00:05:11,760 --> 00:05:16,380
that model now I could define a form

00:05:14,580 --> 00:05:17,790
instance for each of my models and then

00:05:16,380 --> 00:05:20,400
add the fields that I want to edit for

00:05:17,790 --> 00:05:22,050
those on those models or I can use

00:05:20,400 --> 00:05:24,270
better programming using metaprogramming

00:05:22,050 --> 00:05:26,670
I can iterate over all the fields on the

00:05:24,270 --> 00:05:27,960
model and for each of those fields added

00:05:26,670 --> 00:05:30,750
up input that's appropriate for that

00:05:27,960 --> 00:05:33,690
form where's that particularly helpful

00:05:30,750 --> 00:05:35,940
in Django admin Django admin allows you

00:05:33,690 --> 00:05:38,130
to just register a model and you get an

00:05:35,940 --> 00:05:40,530
entire admin interface for that model

00:05:38,130 --> 00:05:41,940
automatically how is that possible

00:05:40,530 --> 00:05:43,800
because Django admin uses

00:05:41,940 --> 00:05:45,600
metaprogramming to introspect the models

00:05:43,800 --> 00:05:49,020
that form up a Django project and then

00:05:45,600 --> 00:05:50,910
generate forms for those objects now of

00:05:49,020 --> 00:05:52,470
course you can get a much better much

00:05:50,910 --> 00:05:54,060
more customized interface if you spend a

00:05:52,470 --> 00:05:55,860
whole bunch of time considering figuring

00:05:54,060 --> 00:05:57,570
your admin views but as a first pass

00:05:55,860 --> 00:05:59,130
administration interface the

00:05:57,570 --> 00:06:02,450
metaprogramming approach lets you hit

00:05:59,130 --> 00:06:05,040
some very big runs very very easily

00:06:02,450 --> 00:06:06,480
jangers admin also requires you to

00:06:05,040 --> 00:06:07,890
register all the models you want to

00:06:06,480 --> 00:06:09,390
display on the admin now strictly you

00:06:07,890 --> 00:06:11,490
could even avoid this step if you wanted

00:06:09,390 --> 00:06:12,840
to Django's app cache is a form of meta

00:06:11,490 --> 00:06:14,700
programming which allows you to

00:06:12,840 --> 00:06:16,680
introspect the applications that exist

00:06:14,700 --> 00:06:18,570
in a project and then the models that

00:06:16,680 --> 00:06:20,340
make up that app so if you were so

00:06:18,570 --> 00:06:22,260
inclined it would be possible to write a

00:06:20,340 --> 00:06:26,250
completely zero configuration admin

00:06:22,260 --> 00:06:27,780
application for Django now although the

00:06:26,250 --> 00:06:29,280
meta API was just one of the banner

00:06:27,780 --> 00:06:30,930
features for 1.8 that doesn't mean it's

00:06:29,280 --> 00:06:32,880
a new feature it's just a new stable

00:06:30,930 --> 00:06:34,530
feature Django is how to matter API

00:06:32,880 --> 00:06:35,940
since the very beginning there were some

00:06:34,530 --> 00:06:38,250
very big changes in the early years but

00:06:35,940 --> 00:06:41,249
by the time Django 1.0 was released the

00:06:38,250 --> 00:06:43,739
API had pretty much settled down what

00:06:41,249 --> 00:06:46,619
APA look like well if you had a model

00:06:43,739 --> 00:06:48,149
called my model it had an attribute

00:06:46,619 --> 00:06:49,649
called underscore meta and that object

00:06:48,149 --> 00:06:51,209
had a bunch of methods on it for

00:06:49,649 --> 00:06:53,309
introspecting the fields on that model

00:06:51,209 --> 00:06:55,109
and there was get filled and get filled

00:06:53,309 --> 00:06:56,639
by name and get fields with model and

00:06:55,109 --> 00:06:58,259
get concrete fields with model and get

00:06:56,639 --> 00:07:00,749
all related many too many objects with

00:06:58,259 --> 00:07:02,309
model looking at that API you can

00:07:00,749 --> 00:07:05,729
probably see why we weren't too keen on

00:07:02,309 --> 00:07:07,979
making it stable it worked but it wasn't

00:07:05,729 --> 00:07:10,199
pretty now what you can't see from just

00:07:07,979 --> 00:07:12,119
that description are the warts some of

00:07:10,199 --> 00:07:15,360
those methods include fields from the

00:07:12,119 --> 00:07:19,529
parent some don't can you tell which

00:07:15,360 --> 00:07:22,259
ones as a result the mentor API was an

00:07:19,529 --> 00:07:25,439
unofficially stable API it was an API

00:07:22,259 --> 00:07:27,839
that firmly wasn't stable and officially

00:07:25,439 --> 00:07:29,129
we reserve the right to change it but in

00:07:27,839 --> 00:07:30,929
practice we knew that enough people

00:07:29,129 --> 00:07:31,979
would be relying on it that we didn't we

00:07:30,929 --> 00:07:34,199
wouldn't change it unless there was a

00:07:31,979 --> 00:07:36,239
really good reason and the best good

00:07:34,199 --> 00:07:37,379
reason there is to formalize it so that

00:07:36,239 --> 00:07:40,949
were actually publishing it and making

00:07:37,379 --> 00:07:41,969
an official stable API last year as part

00:07:40,949 --> 00:07:43,799
of the google Summer of Code

00:07:41,969 --> 00:07:45,269
Daniel Python took the job of clearing

00:07:43,799 --> 00:07:46,860
out all that craft that it had

00:07:45,269 --> 00:07:48,749
accumulated in the API so that we could

00:07:46,860 --> 00:07:51,179
formally document and publish Django's

00:07:48,749 --> 00:07:53,579
matter API this is Daniel graduating

00:07:51,179 --> 00:07:55,529
from University last year as you can

00:07:53,579 --> 00:07:59,129
tell he's a very serious very somber

00:07:55,529 --> 00:08:00,749
quietly spoken individual but what was

00:07:59,129 --> 00:08:02,939
the result of Daniels work well a new

00:08:00,749 --> 00:08:05,969
stable method API and it looks a little

00:08:02,939 --> 00:08:07,860
something like this the meta object is

00:08:05,969 --> 00:08:10,709
unchanged you still say here's my model

00:08:07,860 --> 00:08:12,749
my model dot underscore meta but now

00:08:10,709 --> 00:08:14,519
there's just two methods on there get

00:08:12,749 --> 00:08:17,159
field to return a field with a specific

00:08:14,519 --> 00:08:18,539
name and get fields to return a list

00:08:17,159 --> 00:08:20,399
although the fields on that note are on

00:08:18,539 --> 00:08:22,139
that model you can optionally include

00:08:20,399 --> 00:08:23,309
the fields from parent models and hidden

00:08:22,139 --> 00:08:24,209
fields if you're trying to learn

00:08:23,309 --> 00:08:28,439
something a little bit about your

00:08:24,209 --> 00:08:29,759
inheritance tree so the the parent

00:08:28,439 --> 00:08:31,739
fields are the ones coming from your set

00:08:29,759 --> 00:08:33,059
your super classes and hidden fields are

00:08:31,739 --> 00:08:34,620
fields that back another fields

00:08:33,059 --> 00:08:36,779
functionality for example the the

00:08:34,620 --> 00:08:38,339
underscore ID field on a foreign key or

00:08:36,779 --> 00:08:40,019
fields that have been explicitly hidden

00:08:38,339 --> 00:08:43,740
like a foreign key with a related name

00:08:40,019 --> 00:08:45,600
starting with + what you get on top of

00:08:43,740 --> 00:08:47,879
those two calls is our foremost of

00:08:45,600 --> 00:08:49,949
course is either 1 or 0 too many field

00:08:47,879 --> 00:08:51,420
objects which have attributes that then

00:08:49,949 --> 00:08:52,920
tell you the properties of that field so

00:08:51,420 --> 00:08:54,040
is it in the relationship with another

00:08:52,920 --> 00:08:55,300
model

00:08:54,040 --> 00:08:57,519
what is the cardinality of that

00:08:55,300 --> 00:08:59,290
relationship what are what is the other

00:08:57,519 --> 00:09:00,850
model that is related to was it

00:08:59,290 --> 00:09:03,009
automatically generated or is it

00:09:00,850 --> 00:09:04,480
explicitly defined in a model file does

00:09:03,009 --> 00:09:07,470
it have a direct manifestation as a

00:09:04,480 --> 00:09:09,639
database column so is it concrete

00:09:07,470 --> 00:09:11,079
internally this made a whole bunch of

00:09:09,639 --> 00:09:12,550
code chains that we could replace get

00:09:11,079 --> 00:09:15,040
all related many too many objects with

00:09:12,550 --> 00:09:16,569
model with a much much simplified call

00:09:15,040 --> 00:09:17,589
and that much simplified calls

00:09:16,569 --> 00:09:19,839
effectively just delete this

00:09:17,589 --> 00:09:21,100
comprehension over all fields filtering

00:09:19,839 --> 00:09:22,329
out the ones that don't have to fill

00:09:21,100 --> 00:09:25,329
properties we want all the ones that do

00:09:22,329 --> 00:09:26,470
have the fill properties we want it also

00:09:25,329 --> 00:09:29,350
met we gain some new functionality

00:09:26,470 --> 00:09:31,449
previously generic keys weren't

00:09:29,350 --> 00:09:32,829
represented in the metamodel they

00:09:31,449 --> 00:09:34,269
couldn't be because they were in

00:09:32,829 --> 00:09:36,069
contraband we'd have to make a special

00:09:34,269 --> 00:09:39,160
case of that particular class to get

00:09:36,069 --> 00:09:40,810
them into cause meta representation now

00:09:39,160 --> 00:09:43,000
we've removed the need for that special

00:09:40,810 --> 00:09:44,829
case any third party field including

00:09:43,000 --> 00:09:47,399
contra including things in contrib like

00:09:44,829 --> 00:09:50,769
all the geo to GIS fields and all the

00:09:47,399 --> 00:09:52,389
generic key fields any third party field

00:09:50,769 --> 00:09:54,250
can get the same capabilities as a core

00:09:52,389 --> 00:09:57,639
Jango field and be included in that

00:09:54,250 --> 00:10:00,310
netted metadata representation okay so

00:09:57,639 --> 00:10:01,990
why is this a useful thing well to be

00:10:00,310 --> 00:10:04,470
completely honest for most day to day

00:10:01,990 --> 00:10:07,600
build a blog use cases it probably isn't

00:10:04,470 --> 00:10:09,250
but it is extremely useful when you

00:10:07,600 --> 00:10:10,449
start looking at larger projects in

00:10:09,250 --> 00:10:12,540
particular anything that starts

00:10:10,449 --> 00:10:15,160
approaching framework level stuff a

00:10:12,540 --> 00:10:17,560
stable meta API means you can now write

00:10:15,160 --> 00:10:20,139
functions that take a model rather than

00:10:17,560 --> 00:10:21,519
a model instance as an argument this

00:10:20,139 --> 00:10:23,709
means you can write tools that produce

00:10:21,519 --> 00:10:25,540
high level functionality that respond to

00:10:23,709 --> 00:10:27,459
the characteristics of a model and

00:10:25,540 --> 00:10:30,519
generate functionality based on those

00:10:27,459 --> 00:10:32,290
characteristics so here's a practical

00:10:30,519 --> 00:10:34,510
example where a meta API can be very

00:10:32,290 --> 00:10:36,040
very helpful my commercial day-to-day

00:10:34,510 --> 00:10:38,380
Django application allows tradespeople

00:10:36,040 --> 00:10:40,600
plumbers electricians to keep track of

00:10:38,380 --> 00:10:42,189
the work that they have to complete part

00:10:40,600 --> 00:10:45,339
of that means keeping track of customers

00:10:42,189 --> 00:10:46,750
so I've got a customer model users can

00:10:45,339 --> 00:10:48,459
create new customers and if you raise a

00:10:46,750 --> 00:10:50,380
piece of work it's linked to that

00:10:48,459 --> 00:10:51,939
customer when you issue an invoice it's

00:10:50,380 --> 00:10:53,980
linked to the customer when you record a

00:10:51,939 --> 00:10:55,269
payment it's linked to the customer so

00:10:53,980 --> 00:10:56,709
if you only want to see the full history

00:10:55,269 --> 00:10:58,569
of a customer with you or with your

00:10:56,709 --> 00:11:00,160
company you can easily retrieve all the

00:10:58,569 --> 00:11:01,589
work all the invoices all the payments

00:11:00,160 --> 00:11:04,089
that relate to that customer

00:11:01,589 --> 00:11:06,639
however this data is being entered by

00:11:04,089 --> 00:11:07,570
humans so sometimes you end up with two

00:11:06,639 --> 00:11:10,330
records for mr.

00:11:07,570 --> 00:11:13,210
Smith what you need is a way to be out

00:11:10,330 --> 00:11:14,590
of merge two records together now this

00:11:13,210 --> 00:11:15,970
is easy enough to do all you need to do

00:11:14,590 --> 00:11:17,200
is nominate which is the record you're

00:11:15,970 --> 00:11:19,450
going to retain and which is going to be

00:11:17,200 --> 00:11:20,860
the be deleted and then you update all

00:11:19,450 --> 00:11:22,990
the foreign key and many of many

00:11:20,860 --> 00:11:24,190
references to the duplicate instance to

00:11:22,990 --> 00:11:26,890
point at the original instance instead

00:11:24,190 --> 00:11:28,180
hey that's easy so what does this look

00:11:26,890 --> 00:11:30,160
like okay well we've got some models

00:11:28,180 --> 00:11:32,050
we've got a customer model with a name

00:11:30,160 --> 00:11:33,880
field and a bunch of other data we have

00:11:32,050 --> 00:11:36,160
a work order model that has a reference

00:11:33,880 --> 00:11:37,300
a foreign key to the work order and the

00:11:36,160 --> 00:11:39,760
order ID and a bunch of other

00:11:37,300 --> 00:11:41,380
interesting details we also have an

00:11:39,760 --> 00:11:45,250
invoice and a payment model both also

00:11:41,380 --> 00:11:47,860
owned by that pilot by that customer and

00:11:45,250 --> 00:11:49,390
so we can easily define a merge

00:11:47,860 --> 00:11:51,550
operation for those customers an

00:11:49,390 --> 00:11:52,900
existing customer has could have work

00:11:51,550 --> 00:11:55,390
orders it could have invoices it could

00:11:52,900 --> 00:11:58,270
have payments so given a duplicate

00:11:55,390 --> 00:11:59,920
customer we need to find all those

00:11:58,270 --> 00:12:01,480
related objects up take the foreign key

00:11:59,920 --> 00:12:03,880
references and then delete the duplicate

00:12:01,480 --> 00:12:06,880
magic so now you can merge customers do

00:12:03,880 --> 00:12:08,170
you have content okay so time goes by

00:12:06,880 --> 00:12:09,580
and you decide to add some new

00:12:08,170 --> 00:12:12,490
functionality of your system say the

00:12:09,580 --> 00:12:13,930
ability to raise quotes so you define a

00:12:12,490 --> 00:12:15,760
quarter bottle and some views you roll

00:12:13,930 --> 00:12:17,980
out that code and then someone merges a

00:12:15,760 --> 00:12:21,420
customer record and all the quotes

00:12:17,980 --> 00:12:25,510
related to the debt instance disappear

00:12:21,420 --> 00:12:28,540
what happened well the merge mechanism

00:12:25,510 --> 00:12:29,770
doesn't account for quotes you updated

00:12:28,540 --> 00:12:31,150
all the work orders you updated all the

00:12:29,770 --> 00:12:33,370
invoices and payments but the quotes

00:12:31,150 --> 00:12:36,010
weren't update it so when you deleted

00:12:33,370 --> 00:12:38,590
the duplicate customer there were still

00:12:36,010 --> 00:12:40,270
quotes related to that customer so all

00:12:38,590 --> 00:12:44,740
the duplicate customers quotes were also

00:12:40,270 --> 00:12:46,660
deleted oops so how do you fix that

00:12:44,740 --> 00:12:48,190
well the first obvious solution is to

00:12:46,660 --> 00:12:49,600
update your motor mechanism add the

00:12:48,190 --> 00:12:51,790
extra line you need for quotes and that

00:12:49,600 --> 00:12:53,320
will work fine until you then add the

00:12:51,790 --> 00:12:54,190
appointments model to keep track of the

00:12:53,320 --> 00:12:55,900
each appointment you have with your

00:12:54,190 --> 00:12:57,850
customer and so on and so on what you

00:12:55,900 --> 00:13:01,720
really need is something that will adapt

00:12:57,850 --> 00:13:02,320
to any new model as you add it and how

00:13:01,720 --> 00:13:04,330
do you do that

00:13:02,320 --> 00:13:06,280
you met a program rather than encoding

00:13:04,330 --> 00:13:08,710
the models that need to be updated you

00:13:06,280 --> 00:13:11,260
use the metamodel to discover all the

00:13:08,710 --> 00:13:13,240
related models and then update them that

00:13:11,260 --> 00:13:14,470
way when a new model comes along with a

00:13:13,240 --> 00:13:16,120
foreign key to customer it will

00:13:14,470 --> 00:13:18,400
automatically be included in that mode

00:13:16,120 --> 00:13:20,200
merging operation so what we do here we

00:13:18,400 --> 00:13:21,640
iterate through over all the fields if

00:13:20,200 --> 00:13:23,080
the field is a one two

00:13:21,640 --> 00:13:25,090
many so it means it's on the remote end

00:13:23,080 --> 00:13:26,830
of a matter of a foreign key relation

00:13:25,090 --> 00:13:30,130
and it's auto-created so it's the far

00:13:26,830 --> 00:13:33,040
side the the under set side get the

00:13:30,130 --> 00:13:34,210
accessor name get the attribute the so

00:13:33,040 --> 00:13:36,520
get the attribute of that object

00:13:34,210 --> 00:13:39,660
update the attribute to the customer to

00:13:36,520 --> 00:13:41,500
be the original and off you go

00:13:39,660 --> 00:13:43,360
interesting way though this doesn't

00:13:41,500 --> 00:13:44,620
depend on customer you can actually make

00:13:43,360 --> 00:13:45,760
it a completely arbitrary merge

00:13:44,620 --> 00:13:47,740
operation with just one change

00:13:45,760 --> 00:13:49,030
abstracting out the explicit reference

00:13:47,740 --> 00:13:50,560
to customer if you notice it's just at

00:13:49,030 --> 00:13:52,660
the end their customer equals original

00:13:50,560 --> 00:13:54,520
replace that with a metaprogramming

00:13:52,660 --> 00:13:57,220
lookup of the name of the field you're

00:13:54,520 --> 00:13:59,380
being related through all of a sudden

00:13:57,220 --> 00:14:02,080
you've got a completely generic merging

00:13:59,380 --> 00:14:04,990
two models into one that will work on

00:14:02,080 --> 00:14:06,430
any django model now came here here this

00:14:04,990 --> 00:14:07,930
is only working with foreign keys you

00:14:06,430 --> 00:14:09,040
also need to reproduce this logic for

00:14:07,930 --> 00:14:11,230
many in amenities and one too many x'

00:14:09,040 --> 00:14:13,890
and so on but the principle is much the

00:14:11,230 --> 00:14:16,270
same for those those types of fields

00:14:13,890 --> 00:14:17,830
alright so that's that's a simple

00:14:16,270 --> 00:14:19,690
practical example of some where you

00:14:17,830 --> 00:14:21,400
might use meta in your own code but the

00:14:19,690 --> 00:14:22,720
real killer app for the meta API the

00:14:21,400 --> 00:14:23,650
reason that I got interested in the

00:14:22,720 --> 00:14:25,810
project in the first place

00:14:23,650 --> 00:14:28,870
is the potential for exposing new data

00:14:25,810 --> 00:14:30,430
stores into Django for almost as long as

00:14:28,870 --> 00:14:32,770
Django has existed people have been

00:14:30,430 --> 00:14:34,870
asking the question how can I use X with

00:14:32,770 --> 00:14:36,940
Django where X is some non-relational

00:14:34,870 --> 00:14:38,410
data store MongoDB Google App Engine

00:14:36,940 --> 00:14:39,670
react Cassandra cache to be whatever

00:14:38,410 --> 00:14:42,910
this year's favorite flavor happens to

00:14:39,670 --> 00:14:44,650
be at one time the Django core team

00:14:42,910 --> 00:14:46,510
harbored the dream that the om was

00:14:44,650 --> 00:14:48,610
completely data store agnostic it was an

00:14:46,510 --> 00:14:50,830
object relational model which is why you

00:14:48,610 --> 00:14:53,710
don't do joins you have a filter you

00:14:50,830 --> 00:14:55,420
don't group by you aggregate now that

00:14:53,710 --> 00:14:57,310
dream didn't quite pan out the year

00:14:55,420 --> 00:14:58,690
after Alex gainer did the multi database

00:14:57,310 --> 00:15:00,280
project for the google Summer of Code he

00:14:58,690 --> 00:15:02,590
did a second project looking at building

00:15:00,280 --> 00:15:05,470
a non relational back end for Django's

00:15:02,590 --> 00:15:07,690
database API and it did work but there

00:15:05,470 --> 00:15:09,940
are a bunch of problems so the idea of a

00:15:07,690 --> 00:15:12,400
database back-end for no sequel was kind

00:15:09,940 --> 00:15:15,490
of shelved but the question didn't go

00:15:12,400 --> 00:15:17,050
away so okay what's the actual use case

00:15:15,490 --> 00:15:18,850
here well many parts of Django don't

00:15:17,050 --> 00:15:20,920
care what data store you're actually

00:15:18,850 --> 00:15:23,080
using views URL routing the caching

00:15:20,920 --> 00:15:24,910
layer just go ahead use use MongoDB use

00:15:23,080 --> 00:15:26,560
whatever as long as you're just

00:15:24,910 --> 00:15:28,210
accessing data you might as well use the

00:15:26,560 --> 00:15:30,280
native API provided by your data store

00:15:28,210 --> 00:15:32,380
there's no reason to force the square

00:15:30,280 --> 00:15:34,760
peg of MongoDB into the round hole of a

00:15:32,380 --> 00:15:36,560
query set but there

00:15:34,760 --> 00:15:38,570
big pieces of Django that are dependent

00:15:36,560 --> 00:15:40,790
upon the data store mobile forms and the

00:15:38,570 --> 00:15:42,920
admin so I put it to you that the

00:15:40,790 --> 00:15:45,590
question can I use MongoDB with Django

00:15:42,920 --> 00:15:48,350
really means can I get a Django form for

00:15:45,590 --> 00:15:50,750
my MongoDB model and can I query another

00:15:48,350 --> 00:15:53,270
to my MongoDB data in Django admin and

00:15:50,750 --> 00:15:54,410
if that's the bar you want to set it's a

00:15:53,270 --> 00:15:57,350
whole lot easier and a lot more

00:15:54,410 --> 00:15:58,880
plausible to clear that bar first

00:15:57,350 --> 00:16:00,650
question can I get a Django form from a

00:15:58,880 --> 00:16:02,630
MongoDB model is right in the sweet spot

00:16:00,650 --> 00:16:04,550
of Django as meta API I have an object

00:16:02,630 --> 00:16:06,080
what attributes does that object have

00:16:04,550 --> 00:16:07,250
what is an appropriate form

00:16:06,080 --> 00:16:08,810
representation for each of those

00:16:07,250 --> 00:16:10,190
attributes these are questions that

00:16:08,810 --> 00:16:12,110
aren't dependent upon having a

00:16:10,190 --> 00:16:14,480
relational data store they can be asked

00:16:12,110 --> 00:16:16,720
of any model even a basic Python object

00:16:14,480 --> 00:16:19,190
could answer those questions for you

00:16:16,720 --> 00:16:21,110
the second question can I query and edit

00:16:19,190 --> 00:16:22,580
my MongoDB data and gangers admin only

00:16:21,110 --> 00:16:24,230
requires a little bit more information

00:16:22,580 --> 00:16:26,540
than that you need to be able to know

00:16:24,230 --> 00:16:27,710
what models exist in a data store and

00:16:26,540 --> 00:16:28,910
you need to know how they're organized

00:16:27,710 --> 00:16:31,730
you need to be able to do some basic

00:16:28,910 --> 00:16:34,190
crud operations on it these query

00:16:31,730 --> 00:16:37,220
primitives are a much smaller API than

00:16:34,190 --> 00:16:38,870
the entire ORM now okay for the sake of

00:16:37,220 --> 00:16:41,150
historical consistency let's call those

00:16:38,870 --> 00:16:43,580
operations filter and get and save if

00:16:41,150 --> 00:16:45,620
you can provide a duck that quacks the

00:16:43,580 --> 00:16:47,090
right way janko's form as admin form

00:16:45,620 --> 00:16:49,550
forms an admin don't actually care that

00:16:47,090 --> 00:16:51,380
it's not actually a Django model under

00:16:49,550 --> 00:16:54,830
the hood it just needs to adhere to that

00:16:51,380 --> 00:16:56,090
basic API contract okay so you won't be

00:16:54,830 --> 00:16:58,190
able to take your arbitrary Django

00:16:56,090 --> 00:17:00,080
application from pie-pie and push it on

00:16:58,190 --> 00:17:01,580
to an arbitrary Ganga a data store but

00:17:00,080 --> 00:17:03,710
let's be honest that was folly and it

00:17:01,580 --> 00:17:05,510
was never going to work in practice but

00:17:03,710 --> 00:17:07,339
what you will be able to do is get the

00:17:05,510 --> 00:17:10,480
benefits of much of Django's tooling

00:17:07,339 --> 00:17:12,709
while using a non relational data store

00:17:10,480 --> 00:17:14,900
the best part of all is just because

00:17:12,709 --> 00:17:16,670
it's public supported API now you can do

00:17:14,900 --> 00:17:19,040
all these experiments without actually

00:17:16,670 --> 00:17:20,650
making modifications to call to prove

00:17:19,040 --> 00:17:23,089
the point let's look at a case study

00:17:20,650 --> 00:17:24,890
django mola is a proof of concept that

00:17:23,089 --> 00:17:26,720
Daniel put together during his Summer of

00:17:24,890 --> 00:17:29,180
Code to demonstrate that the meta API

00:17:26,720 --> 00:17:31,910
actually worked what does it do it uses

00:17:29,180 --> 00:17:36,410
Google's Gmail REST API to expose your

00:17:31,910 --> 00:17:38,500
Gmail mailbox in Django admin now as a

00:17:36,410 --> 00:17:40,240
quick yes

00:17:38,500 --> 00:17:41,800
as a quick aside it's not the same

00:17:40,240 --> 00:17:43,600
Django Melo that James Talbott released

00:17:41,800 --> 00:17:46,780
as part of pin ax mainly things as hard

00:17:43,600 --> 00:17:49,180
y'all the code is available on on

00:17:46,780 --> 00:17:50,860
Daniels github repository the other

00:17:49,180 --> 00:17:52,210
caveat is that this example does depend

00:17:50,860 --> 00:17:54,130
on a couple of small changes to Django

00:17:52,210 --> 00:17:56,350
itself things that we are impacts that

00:17:54,130 --> 00:17:57,970
we're looking at getting into core it

00:17:56,350 --> 00:17:59,890
essentially breaking the last of the

00:17:57,970 --> 00:18:02,140
hard coded exceptions in Django that say

00:17:59,890 --> 00:18:04,450
this is a model so you can't just use

00:18:02,140 --> 00:18:05,800
this out of the box but it shows what

00:18:04,450 --> 00:18:08,440
can be done with relatively little

00:18:05,800 --> 00:18:11,440
effort how well it's about five hundred

00:18:08,440 --> 00:18:13,120
lines of code now I haven't got a time

00:18:11,440 --> 00:18:14,800
to tear down five hundred lines of code

00:18:13,120 --> 00:18:17,200
in the remaining ten minutes I've got

00:18:14,800 --> 00:18:18,880
here but I can give you a whirlwind tour

00:18:17,200 --> 00:18:20,620
of what you need to do now the following

00:18:18,880 --> 00:18:22,120
code is heavily edited for clarity it

00:18:20,620 --> 00:18:23,470
will not even begin to work as as

00:18:22,120 --> 00:18:24,940
described but it will sort of give you a

00:18:23,470 --> 00:18:28,030
flavor of where where we're headed

00:18:24,940 --> 00:18:29,680
okay so we start with the manager you

00:18:28,030 --> 00:18:31,150
say you want authors the objects that

00:18:29,680 --> 00:18:32,830
all objects is a manager

00:18:31,150 --> 00:18:34,870
we need a generic one that will point

00:18:32,830 --> 00:18:36,870
out Gmail and store your Gmail

00:18:34,870 --> 00:18:39,820
credentials when you get there okay

00:18:36,870 --> 00:18:41,440
then we subclass that base manager to

00:18:39,820 --> 00:18:43,180
provide a mechanism for issuing queries

00:18:41,440 --> 00:18:44,980
on specific object types we need one to

00:18:43,180 --> 00:18:46,300
look at message threads and we need to

00:18:44,980 --> 00:18:47,530
look at specific message messages

00:18:46,300 --> 00:18:49,900
because they're going to hit on

00:18:47,530 --> 00:18:53,500
different API entry points in the Gmail

00:18:49,900 --> 00:18:55,210
API okay they're gonna return query sets

00:18:53,500 --> 00:18:57,040
what about those query sets again we

00:18:55,210 --> 00:18:58,780
have a base class advise query that sort

00:18:57,040 --> 00:19:00,940
of abstracts the idea of calling a REST

00:18:58,780 --> 00:19:02,530
API and a base query set to generate

00:19:00,940 --> 00:19:05,010
those queries now you'll notice here

00:19:02,530 --> 00:19:06,970
that query set is a subclass of list

00:19:05,010 --> 00:19:09,280
because all it's really doing is

00:19:06,970 --> 00:19:10,540
representing a list of results you could

00:19:09,280 --> 00:19:12,370
use your own container if it's useful

00:19:10,540 --> 00:19:14,400
but you can just use Django so just use

00:19:12,370 --> 00:19:17,500
a base part and list if you need to and

00:19:14,400 --> 00:19:18,430
again we subclass that base class for

00:19:17,500 --> 00:19:21,460
specific datatypes

00:19:18,430 --> 00:19:23,440
get thread by ID is the actual ap Gmail

00:19:21,460 --> 00:19:25,870
API call there so when you call get on a

00:19:23,440 --> 00:19:29,080
thread query set you're invoking get

00:19:25,870 --> 00:19:30,460
thread by ID and we do a similar thing

00:19:29,080 --> 00:19:32,830
for message query set but when we do

00:19:30,460 --> 00:19:34,540
filter is a method that returns a client

00:19:32,830 --> 00:19:36,310
version of itself so you can start to

00:19:34,540 --> 00:19:37,810
chain those filter operations and every

00:19:36,310 --> 00:19:39,580
time you clone it every time you filter

00:19:37,810 --> 00:19:42,520
you modify it to add additional query

00:19:39,580 --> 00:19:44,830
parameters next we've got the metamodel

00:19:42,520 --> 00:19:46,090
here we subclass Django's own options

00:19:44,830 --> 00:19:48,010
model the class that implements

00:19:46,090 --> 00:19:49,420
underscore meta because that gives us a

00:19:48,010 --> 00:19:51,250
bunch of functionality for free and all

00:19:49,420 --> 00:19:55,690
we really need to implement is get free

00:19:51,250 --> 00:19:57,010
get fields and the rest all works now we

00:19:55,690 --> 00:20:00,520
pull it all together we define a base

00:19:57,010 --> 00:20:02,500
gmail model that retains state and we

00:20:00,520 --> 00:20:03,820
define a Python meta class that will

00:20:02,500 --> 00:20:06,850
control the process of object

00:20:03,820 --> 00:20:08,800
construction then we subclass set a meta

00:20:06,850 --> 00:20:11,230
class for each of our models and a

00:20:08,800 --> 00:20:13,630
default manager and we're done now you

00:20:11,230 --> 00:20:15,220
can say threaded objects get and message

00:20:13,630 --> 00:20:17,320
to objects dot filter and risk to

00:20:15,220 --> 00:20:19,030
retrieve data from your Gmail instance

00:20:17,320 --> 00:20:21,820
assuming you've got your credential set

00:20:19,030 --> 00:20:23,050
up correctly in your settings file or

00:20:21,820 --> 00:20:24,580
what's left then is to register those

00:20:23,050 --> 00:20:26,740
models in the admin you have a message

00:20:24,580 --> 00:20:28,270
in line look works on messages you have

00:20:26,740 --> 00:20:29,860
a thread admin it uses a bunch of in

00:20:28,270 --> 00:20:31,930
lines and displays the number of

00:20:29,860 --> 00:20:33,970
messages in each thread register that

00:20:31,930 --> 00:20:35,440
with the admin do exactly the same

00:20:33,970 --> 00:20:40,210
registration process as you would for

00:20:35,440 --> 00:20:41,830
any other Django model and you don't so

00:20:40,210 --> 00:20:43,270
that's a lot to absorb in a short amount

00:20:41,830 --> 00:20:44,860
of time and it might it is the same

00:20:43,270 --> 00:20:46,330
probably a little overwhelming keep in

00:20:44,860 --> 00:20:47,920
mind the whole thing is 500 lines of

00:20:46,330 --> 00:20:50,350
code and I'm rushing through it to kind

00:20:47,920 --> 00:20:53,560
of show what is actually possible but it

00:20:50,350 --> 00:20:54,850
is just 500 lines of code and what

00:20:53,560 --> 00:20:56,590
you'll get what you end up with is

00:20:54,850 --> 00:20:58,540
reproducing a limited version of the API

00:20:56,590 --> 00:21:00,730
that should be familiar to as Django

00:20:58,540 --> 00:21:05,490
users models managers query sets queries

00:21:00,730 --> 00:21:08,850
and so on so here's a call to action

00:21:05,490 --> 00:21:11,200
who's coming to the Sprint's show hands

00:21:08,850 --> 00:21:13,930
hey we got a goodly number alright who's

00:21:11,200 --> 00:21:15,640
looking for something to work on yeah a

00:21:13,930 --> 00:21:18,970
goodly number of those all right have

00:21:15,640 --> 00:21:21,700
all about the project for you how about

00:21:18,970 --> 00:21:24,190
one of these have you got expertise in a

00:21:21,700 --> 00:21:25,090
non-relational data store MongoDB Google

00:21:24,190 --> 00:21:27,190
App Engine

00:21:25,090 --> 00:21:28,990
Cassandra RIA couchdb or anything else

00:21:27,190 --> 00:21:30,910
that happens to be out there why not

00:21:28,990 --> 00:21:32,080
build a Django method up for that Jake

00:21:30,910 --> 00:21:33,460
for that data store you'll be able to

00:21:32,080 --> 00:21:34,930
see your data store in Django admin

00:21:33,460 --> 00:21:37,420
generate forms for that object off

00:21:34,930 --> 00:21:39,280
you're running what about no traditional

00:21:37,420 --> 00:21:41,230
data stores you can wrap an LDAP store

00:21:39,280 --> 00:21:42,430
you could wrap your local email INBOX

00:21:41,230 --> 00:21:44,410
your filesystem

00:21:42,430 --> 00:21:45,790
even a pool of AWS resources for the

00:21:44,410 --> 00:21:47,200
Django meter duck and browsers

00:21:45,790 --> 00:21:51,010
even potentially do some light

00:21:47,200 --> 00:21:54,850
management of your AWS resources in in

00:21:51,010 --> 00:21:56,710
Django admin ok what if you don't like

00:21:54,850 --> 00:21:58,450
Django zarab well why not replace it

00:21:56,710 --> 00:22:00,370
there's no reason you couldn't make a

00:21:58,450 --> 00:22:02,800
Django meta duck interface for sequel

00:22:00,370 --> 00:22:05,559
using sequel alchemy so you'd go to take

00:22:02,800 --> 00:22:08,799
a sequel alchemy model as a Django Reis

00:22:05,559 --> 00:22:11,590
expose it into into Django's admin for

00:22:08,799 --> 00:22:13,299
most of your business logic your you're

00:22:11,590 --> 00:22:14,650
using the sequel alchemy API because

00:22:13,299 --> 00:22:16,000
that's the one you prefer but for

00:22:14,650 --> 00:22:17,500
convenience and prototyping you can just

00:22:16,000 --> 00:22:21,309
drop that model into Django's admin or

00:22:17,500 --> 00:22:22,630
into a Django form now if you do choose

00:22:21,309 --> 00:22:24,370
to take on one of those projects you are

00:22:22,630 --> 00:22:26,350
going to hit some rough edges so I will

00:22:24,370 --> 00:22:27,580
warn you as I said Django's Daniels

00:22:26,350 --> 00:22:28,900
Django and Mahler depends on a couple

00:22:27,580 --> 00:22:30,549
patches that haven't been merged into

00:22:28,900 --> 00:22:31,900
trunk I can't guarantee that we've

00:22:30,549 --> 00:22:33,280
identified every single one of the

00:22:31,900 --> 00:22:35,410
places informs an admin that you might

00:22:33,280 --> 00:22:36,429
trip up there's a couple of places where

00:22:35,410 --> 00:22:37,600
we probably have made implicit

00:22:36,429 --> 00:22:38,980
assumptions about the fact that a

00:22:37,600 --> 00:22:41,530
relational database underpins this

00:22:38,980 --> 00:22:43,179
application but if you do find a bug

00:22:41,530 --> 00:22:45,490
that's a bug where I'm studying fixing

00:22:43,179 --> 00:22:47,320
and the more people we have contributing

00:22:45,490 --> 00:22:48,730
these Django meta ducks the more

00:22:47,320 --> 00:22:50,559
confidence we'll have that we've broken

00:22:48,730 --> 00:22:53,740
the rme dependency in model forms and

00:22:50,559 --> 00:22:55,000
admin so I hope I've sparked your

00:22:53,740 --> 00:22:56,470
interest about the possibilities of the

00:22:55,000 --> 00:22:57,730
matter interface we probably haven't got

00:22:56,470 --> 00:22:58,990
time for a couple of questions or you

00:22:57,730 --> 00:23:02,460
can grab me over the next couple days or

00:22:58,990 --> 00:23:02,460
online thank you very much

00:23:07,100 --> 00:23:16,840
I can hear crickets

00:23:21,850 --> 00:23:28,789
yet I come how's the documentation for

00:23:26,630 --> 00:23:31,220
this I'm more pretty good on the basis

00:23:28,789 --> 00:23:32,539
that there's not much the document so is

00:23:31,220 --> 00:23:33,799
there's literally two methods in a

00:23:32,539 --> 00:23:36,440
budget attributes there is actually even

00:23:33,799 --> 00:23:38,269
some really good documentation for so so

00:23:36,440 --> 00:23:40,759
you were using the wrong API that wasn't

00:23:38,269 --> 00:23:43,129
formal well okay that here's how you

00:23:40,759 --> 00:23:44,389
transform one to the other so yeah there

00:23:43,129 --> 00:23:46,309
is documentation error is pretty solid

00:23:44,389 --> 00:23:50,299
the documentation of how do you write

00:23:46,309 --> 00:23:51,529
the Django meta duck know but like I

00:23:50,299 --> 00:23:54,289
said the only thing you need to be doing

00:23:51,529 --> 00:23:55,850
is essentially appearing to be a meta

00:23:54,289 --> 00:23:56,990
model so if you implement get feel to

00:23:55,850 --> 00:24:00,740
get fields and a couple others you

00:23:56,990 --> 00:24:03,139
basically there so do you think there is

00:24:00,740 --> 00:24:04,850
room in the meta abstraction for some

00:24:03,139 --> 00:24:06,860
theories that wouldn't make sense some

00:24:04,850 --> 00:24:08,389
relational database they do in things

00:24:06,860 --> 00:24:10,009
like what other stores they're

00:24:08,389 --> 00:24:11,179
like extending the abstraction to be a

00:24:10,009 --> 00:24:12,950
little bit more flexible around the edge

00:24:11,179 --> 00:24:15,470
I presume you're talking about things

00:24:12,950 --> 00:24:17,029
like documents as I think of my stats

00:24:15,470 --> 00:24:19,190
yeah absolutely I think that's sort of

00:24:17,029 --> 00:24:21,110
where that is it a one to one is it a

00:24:19,190 --> 00:24:24,080
one to many is it a many to many is it a

00:24:21,110 --> 00:24:25,490
a blob inside meaningful whatever that I

00:24:24,080 --> 00:24:27,139
don't know what that abstraction is but

00:24:25,490 --> 00:24:30,529
yeah I think that there's no reason that

00:24:27,139 --> 00:24:32,149
we can't have that flag in Django even

00:24:30,529 --> 00:24:33,830
if Django itself doesn't use it but also

00:24:32,149 --> 00:24:36,289
on top of that you can you could you

00:24:33,830 --> 00:24:39,049
could set up in such a way if you've got

00:24:36,289 --> 00:24:40,789
your MongoDB data type that needs to be

00:24:39,049 --> 00:24:42,799
able to filter on a particular flag that

00:24:40,789 --> 00:24:44,269
flag is not going to be on for any other

00:24:42,799 --> 00:24:46,909
data type so you only need to have it in

00:24:44,269 --> 00:24:50,330
your data store you can say get out row

00:24:46,909 --> 00:24:51,679
defaulting to false and any model that

00:24:50,330 --> 00:24:56,299
doesn't have it will will show that up

00:24:51,679 --> 00:24:59,659
anyway so okay I don't think this is a

00:24:56,299 --> 00:25:03,769
new problem that I'm bound to ask you to

00:24:59,659 --> 00:25:05,360
what you've just described but I'm just

00:25:03,769 --> 00:25:07,159
looking at the the Django documentation

00:25:05,360 --> 00:25:09,769
and there's his page on model meta

00:25:07,159 --> 00:25:12,259
options and then this this other page on

00:25:09,769 --> 00:25:14,480
the model underscore meta API which is

00:25:12,259 --> 00:25:16,159
talking about the class options and I'm

00:25:14,480 --> 00:25:17,990
really confused what the relationship is

00:25:16,159 --> 00:25:19,300
between these two things and is there a

00:25:17,990 --> 00:25:21,370
possible naming

00:25:19,300 --> 00:25:22,870
yeah I guess some of that is a little

00:25:21,370 --> 00:25:25,540
historical than that the name of the

00:25:22,870 --> 00:25:27,940
class options is never surfaced to the

00:25:25,540 --> 00:25:29,440
end-user it's an internal name and

00:25:27,940 --> 00:25:30,610
underscore measure is the only one that

00:25:29,440 --> 00:25:31,570
is there if there's something that we

00:25:30,610 --> 00:25:33,360
need to clean up it's probably the

00:25:31,570 --> 00:25:34,990
documentation referring to options

00:25:33,360 --> 00:25:40,120
because it isn't something you should

00:25:34,990 --> 00:25:43,450
ever really be instantiating so yeah but

00:25:40,120 --> 00:25:45,880
there's also options under the model

00:25:43,450 --> 00:25:48,670
mitr options which talks about options

00:25:45,880 --> 00:25:52,780
dot abstract oh okay I see what you're

00:25:48,670 --> 00:25:54,250
going conflicts or potential maiden

00:25:52,780 --> 00:25:57,090
conflicts for people who are not

00:25:54,250 --> 00:26:05,710
intimately familiar with how all this is

00:25:57,090 --> 00:26:07,150
yeah working underneath yes I agree if

00:26:05,710 --> 00:26:09,640
we maybe there's some suggestions about

00:26:07,150 --> 00:26:11,320
which one could be part or take out of

00:26:09,640 --> 00:26:14,140
the documentation yeah no it isn't the

00:26:11,320 --> 00:26:15,940
word options obviously I can't think of

00:26:14,140 --> 00:26:17,620
anywhere that's actually surfaced as

00:26:15,940 --> 00:26:20,320
public API it's something that is used

00:26:17,620 --> 00:26:22,090
because that's the name of the class not

00:26:20,320 --> 00:26:23,740
because it's actually a name you need to

00:26:22,090 --> 00:26:25,060
use so it's a candidate to be deleted

00:26:23,740 --> 00:26:31,540
anywhere it's being used effectively

00:26:25,060 --> 00:26:33,220
sorry all right well I think that's

00:26:31,540 --> 00:26:35,520
that's pretty much time as well so thank

00:26:33,220 --> 00:26:35,520

YouTube URL: https://www.youtube.com/watch?v=VgM0qmpHDiE


