Title: DjangoCon US 2015 - PostgreSQL in Django 1.8 by Christophe Pettus
Publication date: 2017-11-03
Playlist: DjangoCon US 2015
Description: 
	PostgreSQL in Django 1.8

Among the topics are:

A survey of the new Django 1.8 PostgreSQL features.
Using migrations with PostgreSQL in interesting ways.
Real-life applications of the new field types.
Basic model design for good performance on PostgreSQL.
Captions: 
	00:00:15,890 --> 00:00:21,390
okay I going to punch right on in

00:00:19,260 --> 00:00:25,050
because we have so much stuff to talk

00:00:21,390 --> 00:00:27,090
about specifically let's we're going to

00:00:25,050 --> 00:00:30,119
plunge right in on Jango 17 introduce

00:00:27,090 --> 00:00:32,160
native migrations and jang geun 18

00:00:30,119 --> 00:00:33,750
introduced Django country postgres and

00:00:32,160 --> 00:00:35,040
there's some in it there's so much cool

00:00:33,750 --> 00:00:37,980
stuff in here and so little time so

00:00:35,040 --> 00:00:39,300
let's plan forward the first two are the

00:00:37,980 --> 00:00:41,070
one who says most of what I'm going to

00:00:39,300 --> 00:00:43,829
talk about in Django contributors was

00:00:41,070 --> 00:00:45,510
done by marked Hamlin in believe he's a

00:00:43,829 --> 00:00:47,129
Kickstarter IndieGoGo i figured i think

00:00:45,510 --> 00:00:49,649
its kickstarter project for it who

00:00:47,129 --> 00:00:52,379
deserves endless praise for these

00:00:49,649 --> 00:00:53,640
wonderful new features so first i'm

00:00:52,379 --> 00:00:56,070
going to talk about migrations and

00:00:53,640 --> 00:00:57,539
everyone's who said wait my visions are

00:00:56,070 --> 00:00:59,730
postgres specific why are you talking

00:00:57,539 --> 00:01:01,410
about migrations and the reason is that

00:00:59,730 --> 00:01:03,359
a lot some of the stuff we're going to

00:01:01,410 --> 00:01:06,119
talk about their an enabler for other

00:01:03,359 --> 00:01:07,799
things and jungermann seven migrations

00:01:06,119 --> 00:01:09,720
are just amazing so if you haven't used

00:01:07,799 --> 00:01:11,970
them just you know go to your laptop I

00:01:09,720 --> 00:01:14,900
won't be offended install move to using

00:01:11,970 --> 00:01:18,330
migrations and thanks Andrew for those

00:01:14,900 --> 00:01:20,520
so a quick review of for anyone who

00:01:18,330 --> 00:01:22,250
hasn't used the 17 migrations or have

00:01:20,520 --> 00:01:24,119
been treating it like a black box

00:01:22,250 --> 00:01:27,570
migrations are built around this notion

00:01:24,119 --> 00:01:29,549
of operations each operation in a

00:01:27,570 --> 00:01:30,930
migration use the database backward

00:01:29,549 --> 00:01:33,780
forward through its schema migration

00:01:30,930 --> 00:01:36,060
timeline so it adds a field adds a table

00:01:33,780 --> 00:01:38,790
that corresponds to a model but adds

00:01:36,060 --> 00:01:41,009
does something like that there are lots

00:01:38,790 --> 00:01:43,860
of individual operations but there are

00:01:41,009 --> 00:01:46,820
two super interesting ones for our point

00:01:43,860 --> 00:01:50,640
of view which are running one sequel and

00:01:46,820 --> 00:01:52,560
create extension these are operations

00:01:50,640 --> 00:01:55,079
that are built into come with the Django

00:01:52,560 --> 00:01:58,229
framework or framework now and you can

00:01:55,079 --> 00:02:00,659
use them in your own migrations run

00:01:58,229 --> 00:02:03,060
sequel probably you can guess what it

00:02:00,659 --> 00:02:04,469
does it applies Ross equal directly to

00:02:03,060 --> 00:02:05,549
the database now everyone's saying oh

00:02:04,469 --> 00:02:06,930
god is one of those database guys

00:02:05,549 --> 00:02:08,780
talking about Ross eco I'm going to

00:02:06,930 --> 00:02:10,789
launch again but really

00:02:08,780 --> 00:02:14,209
work with me here it's it's very very

00:02:10,789 --> 00:02:17,200
handy um specifically it's very useful

00:02:14,209 --> 00:02:20,690
for things you can't do directly in

00:02:17,200 --> 00:02:22,190
using the models yet like creating

00:02:20,690 --> 00:02:24,890
indexes for some new types we're going

00:02:22,190 --> 00:02:26,870
to talk about there's also a create

00:02:24,890 --> 00:02:28,340
extension operation which runs a create

00:02:26,870 --> 00:02:30,050
extension command you can sucker serve

00:02:28,340 --> 00:02:34,880
pattern is forming in this naming

00:02:30,050 --> 00:02:36,200
convention or specifically the extension

00:02:34,880 --> 00:02:40,850
mechanism in Postgres which was

00:02:36,200 --> 00:02:43,280
introduced in 91 something like that is

00:02:40,850 --> 00:02:46,010
it's a little bit like pip for post

00:02:43,280 --> 00:02:47,739
words is it allows you to add extent

00:02:46,010 --> 00:02:51,140
packaged extensions into your database

00:02:47,739 --> 00:02:53,060
previously you had to drop a dot s 0

00:02:51,140 --> 00:02:55,269
file here and run the sequel here and do

00:02:53,060 --> 00:02:56,959
all this stuff and it was just horrible

00:02:55,269 --> 00:03:00,290
specifically we're going to talk about

00:02:56,959 --> 00:03:02,000
this extension H store which is a which

00:03:00,290 --> 00:03:03,950
needs to be added to your database

00:03:02,000 --> 00:03:06,860
before you use it doesn't come with the

00:03:03,950 --> 00:03:08,269
core postgres installation a lot of this

00:03:06,860 --> 00:03:11,989
will make more sense later at the moment

00:03:08,269 --> 00:03:13,549
I'm just teasing you um one thing to

00:03:11,989 --> 00:03:14,900
notice about H stores if you have it

00:03:13,549 --> 00:03:16,340
adds a query to every can't i'm you

00:03:14,900 --> 00:03:20,000
connect to the database but we'll talk

00:03:16,340 --> 00:03:21,530
about that also so that's our that's all

00:03:20,000 --> 00:03:24,620
you need to know about the new extension

00:03:21,530 --> 00:03:26,510
facility let's talk about 18 18 adds

00:03:24,620 --> 00:03:31,600
some new field types which are array

00:03:26,510 --> 00:03:34,160
fields range fields an 8 NH store field

00:03:31,600 --> 00:03:38,000
19 is going to add some more cool stuff

00:03:34,160 --> 00:03:41,450
but this is what we get in 18 so in a

00:03:38,000 --> 00:03:43,519
ray field in Postgres since pretty much

00:03:41,450 --> 00:03:45,739
the dawn of time arrays our first class

00:03:43,519 --> 00:03:50,209
types you can have a single column that

00:03:45,739 --> 00:03:52,100
is an array um now database you know old

00:03:50,209 --> 00:03:53,390
school database people like their heads

00:03:52,100 --> 00:03:54,739
explode at this point because this is

00:03:53,390 --> 00:03:56,390
denormalization and this is horrible

00:03:54,739 --> 00:03:59,030
forget those people they're old and in

00:03:56,390 --> 00:04:03,350
the way um these this is a really really

00:03:59,030 --> 00:04:06,019
cool feature an array field is now a

00:04:03,350 --> 00:04:08,359
field that you can import from Django

00:04:06,019 --> 00:04:10,700
contribs crest and it lets you use those

00:04:08,359 --> 00:04:12,380
directly before there were tons of field

00:04:10,700 --> 00:04:13,760
of things you could find on django

00:04:12,380 --> 00:04:16,250
snippets and things like that that would

00:04:13,760 --> 00:04:19,340
let you do it but now it's fresh out of

00:04:16,250 --> 00:04:20,870
the box and these map into python arrays

00:04:19,340 --> 00:04:22,470
why i said array here is because i

00:04:20,870 --> 00:04:26,280
molded in the way what I mean

00:04:22,470 --> 00:04:28,140
course is a list one thing to remember

00:04:26,280 --> 00:04:30,870
is the postgres arrays are of

00:04:28,140 --> 00:04:33,720
homogeneous type unlike Python lists

00:04:30,870 --> 00:04:37,080
which are not so you get you pick a type

00:04:33,720 --> 00:04:40,740
int string something and that's what you

00:04:37,080 --> 00:04:42,300
get in a postgres array Python will let

00:04:40,740 --> 00:04:45,360
you put of course anything you want in a

00:04:42,300 --> 00:04:50,190
list but don't do that if this is what

00:04:45,360 --> 00:04:52,080
you're trying to model so the other

00:04:50,190 --> 00:04:54,390
thing is the Python multi-dimensional

00:04:52,080 --> 00:04:56,880
arrays are rectangular remember Fortran

00:04:54,390 --> 00:04:58,980
just like that is it the great that

00:04:56,880 --> 00:05:02,670
we're honoring our ancestors in this way

00:04:58,980 --> 00:05:04,500
um so the traditional multi-dimensional

00:05:02,670 --> 00:05:06,780
arrays there you say I'm going to create

00:05:04,500 --> 00:05:08,850
a three-dimensional way with dimensions

00:05:06,780 --> 00:05:11,190
of 5 7 and 10 and the whole thing is

00:05:08,850 --> 00:05:13,020
appears it is populated for you they can

00:05:11,190 --> 00:05:14,280
be not individual entries can be null if

00:05:13,020 --> 00:05:16,470
you need to represent a hole in the

00:05:14,280 --> 00:05:18,090
array but it's not like it's not like a

00:05:16,470 --> 00:05:19,890
list of lists structures where each

00:05:18,090 --> 00:05:25,200
individual element could be any size you

00:05:19,890 --> 00:05:27,419
want so once you've got it as the dog

00:05:25,200 --> 00:05:29,850
chasing the car said now that you cut it

00:05:27,419 --> 00:05:32,160
what are you going to do with it you

00:05:29,850 --> 00:05:36,060
have a refill queries the basic one is

00:05:32,160 --> 00:05:37,890
contains the contains matches if the

00:05:36,060 --> 00:05:40,350
array field on the left contains all the

00:05:37,890 --> 00:05:46,500
all of the entries of the list on the

00:05:40,350 --> 00:05:51,060
right so ABC contains a B but it does

00:05:46,500 --> 00:05:53,070
not contain ad order is not important in

00:05:51,060 --> 00:05:55,979
a contains query so you can continue

00:05:53,070 --> 00:05:58,830
they can appear at a thing you're in any

00:05:55,979 --> 00:06:00,990
order you want you can also have

00:05:58,830 --> 00:06:02,970
contained by which is effectively the

00:06:00,990 --> 00:06:05,340
reverse matches if the list on the right

00:06:02,970 --> 00:06:09,870
contains all the entries of the field on

00:06:05,340 --> 00:06:11,310
the left so this this is not contained

00:06:09,870 --> 00:06:16,700
by that and that is not contained by

00:06:11,310 --> 00:06:19,140
that but that is contained by that we

00:06:16,700 --> 00:06:22,190
order is not important here either ok

00:06:19,140 --> 00:06:25,680
that's easy and then you have overlaps

00:06:22,190 --> 00:06:28,770
so which is the any version of this so

00:06:25,680 --> 00:06:33,330
this overlaps this but that does not

00:06:28,770 --> 00:06:34,979
overlap that and those and those return

00:06:33,330 --> 00:06:36,870
a boolean then you also have the

00:06:34,979 --> 00:06:39,330
predicate underscore underscore lens

00:06:36,870 --> 00:06:40,770
which returns length which returns the

00:06:39,330 --> 00:06:43,500
length of the field on the left as an

00:06:40,770 --> 00:06:44,760
integer so this is kind of approximate

00:06:43,500 --> 00:06:47,070
syntax you wouldn't actually write this

00:06:44,760 --> 00:06:49,290
in your Python but you get the idea that

00:06:47,070 --> 00:06:52,350
if it's storing this value you apply

00:06:49,290 --> 00:06:55,140
length to it you get to now something to

00:06:52,350 --> 00:06:57,180
remember about this is the unless you've

00:06:55,140 --> 00:06:59,070
created a particular expression index

00:06:57,180 --> 00:07:00,660
which we'll talk about in a bit this is

00:06:59,070 --> 00:07:03,530
going to do a full table scan it will

00:07:00,660 --> 00:07:06,600
pick up every single row in the database

00:07:03,530 --> 00:07:10,200
that for that table rattle it to

00:07:06,600 --> 00:07:12,780
calculate the length and filter it so

00:07:10,200 --> 00:07:19,100
you probably don't want to do that on a

00:07:12,780 --> 00:07:21,920
big table you can also apply

00:07:19,100 --> 00:07:24,690
transformations to it such as an index

00:07:21,920 --> 00:07:26,790
this takes a light for example this

00:07:24,690 --> 00:07:30,630
filters on everything whose first

00:07:26,790 --> 00:07:35,940
element underscore underscore zero is is

00:07:30,630 --> 00:07:40,140
the string a if there's no array 0 entry

00:07:35,940 --> 00:07:44,340
0 for example the the the the raid is of

00:07:40,140 --> 00:07:47,310
length is of length 0 it dumb it doesn't

00:07:44,340 --> 00:07:50,580
match it simply returns false there's no

00:07:47,310 --> 00:07:52,170
error so if you put five million there

00:07:50,580 --> 00:07:53,490
and there's no 5 million link to raise

00:07:52,170 --> 00:07:57,570
you'll just get back false for

00:07:53,490 --> 00:08:00,180
everything one thing is directly you

00:07:57,570 --> 00:08:02,930
can't specify this programmatically you

00:08:00,180 --> 00:08:05,130
built in as if you build in a zero there

00:08:02,930 --> 00:08:07,050
unless you're going to you can do string

00:08:05,130 --> 00:08:10,230
substitution and use quarks to do that

00:08:07,050 --> 00:08:12,810
of course you can also slice the array

00:08:10,230 --> 00:08:17,570
which is pretty cool you can say okay

00:08:12,810 --> 00:08:22,700
anything whose entries 021 are that or

00:08:17,570 --> 00:08:27,060
probably more usefully 022 contains a

00:08:22,700 --> 00:08:28,530
you can also index array fields um so

00:08:27,060 --> 00:08:31,940
you can just say DB index equals true

00:08:28,530 --> 00:08:34,650
and you're done right wrong sorry this

00:08:31,940 --> 00:08:37,580
it creates a b-tree index on the array

00:08:34,650 --> 00:08:40,710
which is pretty useless for an array um

00:08:37,580 --> 00:08:42,630
so this is one of the downsides right

00:08:40,710 --> 00:08:44,160
now of using these is you have to if you

00:08:42,630 --> 00:08:46,500
want indexing on them and you almost

00:08:44,160 --> 00:08:48,030
certainly do want indexing you have to

00:08:46,500 --> 00:08:48,900
do some special magic so let's talk

00:08:48,030 --> 00:08:50,310
about that

00:08:48,900 --> 00:08:54,030
but first let's talk about how post

00:08:50,310 --> 00:08:55,950
Chris does indexing this Chris supports

00:08:54,030 --> 00:08:57,690
different kinds of index which most

00:08:55,950 --> 00:09:00,240
people who are just using the Django arm

00:08:57,690 --> 00:09:01,950
never see because you only get one kind

00:09:00,240 --> 00:09:04,950
out of posts out of it which is unless

00:09:01,950 --> 00:09:08,100
you're using geo Django which is a

00:09:04,950 --> 00:09:11,160
b-tree index betray indexes are great

00:09:08,100 --> 00:09:12,780
they're really they are new the the

00:09:11,160 --> 00:09:14,880
optimal solution to a particular problem

00:09:12,780 --> 00:09:17,070
which is they're very fast they're

00:09:14,880 --> 00:09:19,890
compact and they provide total ordering

00:09:17,070 --> 00:09:21,540
so you can work a b-tree index up one

00:09:19,890 --> 00:09:22,950
side and down the other you can use it

00:09:21,540 --> 00:09:25,830
to accelerate query it's like greater

00:09:22,950 --> 00:09:28,380
than less than or equal it's be tree

00:09:25,830 --> 00:09:32,190
indexes are great but they're not

00:09:28,380 --> 00:09:33,990
perfect um specifically a b-tree index

00:09:32,190 --> 00:09:36,030
requires a totally ordered type like

00:09:33,990 --> 00:09:37,320
integers every integer is greater than

00:09:36,030 --> 00:09:39,750
less than or equal to another integer

00:09:37,320 --> 00:09:41,610
that those operations apply to any two

00:09:39,750 --> 00:09:44,190
integers strings are totally ordered

00:09:41,610 --> 00:09:45,270
floats are totally ordered points are

00:09:44,190 --> 00:09:47,130
raised in H stores and things like that

00:09:45,270 --> 00:09:48,810
are not totally ordered what does it

00:09:47,130 --> 00:09:50,100
mean for one array to be greater than or

00:09:48,810 --> 00:09:52,170
less than another way you can make up

00:09:50,100 --> 00:09:53,760
something you can say well we're going

00:09:52,170 --> 00:09:56,400
to compare the elements in order and

00:09:53,760 --> 00:09:58,200
then you know all that but most people

00:09:56,400 --> 00:10:00,320
don't use arrays that way that's not a

00:09:58,200 --> 00:10:03,120
very interesting way of using an array

00:10:00,320 --> 00:10:05,190
but they do you do do on a raise or

00:10:03,120 --> 00:10:07,020
things like inclusion like the contains

00:10:05,190 --> 00:10:08,310
operation what you want to do is say

00:10:07,020 --> 00:10:10,140
does this I want to find all the

00:10:08,310 --> 00:10:12,450
instances of this of an array that

00:10:10,140 --> 00:10:16,320
contained this particular element no

00:10:12,450 --> 00:10:18,990
matter where they are in the array so

00:10:16,320 --> 00:10:20,640
postgres has you covered it has two

00:10:18,990 --> 00:10:25,650
different types of indexes which are

00:10:20,640 --> 00:10:27,870
just engine indexes um for those for

00:10:25,650 --> 00:10:31,410
those studying a lot along home if you

00:10:27,870 --> 00:10:32,790
just saw it stands for generalized index

00:10:31,410 --> 00:10:36,180
storage technique engine stands for

00:10:32,790 --> 00:10:40,350
generalized inverted index so now you

00:10:36,180 --> 00:10:41,820
know um gin indexes are generally used

00:10:40,350 --> 00:10:45,780
for types that contain keys and values

00:10:41,820 --> 00:10:48,450
um arrays in that cases they just

00:10:45,780 --> 00:10:50,340
contain values not keys each stores in

00:10:48,450 --> 00:10:53,150
JSON are good examples of things that

00:10:50,340 --> 00:10:55,530
are key value pairs or just value lists

00:10:53,150 --> 00:10:58,590
gin indexes are generally used for that

00:10:55,530 --> 00:11:00,810
kind of data structure juice indexes are

00:10:58,590 --> 00:11:02,730
generally used for types of partition of

00:11:00,810 --> 00:11:05,730
mathematical space so like a point or

00:11:02,730 --> 00:11:07,050
range or rectangle is an example of

00:11:05,730 --> 00:11:10,199
something that would be indexed using

00:11:07,050 --> 00:11:12,600
just um if you want talk to me in the

00:11:10,199 --> 00:11:16,290
whole night despite the details on this

00:11:12,600 --> 00:11:17,399
for the moment just roll with it and the

00:11:16,290 --> 00:11:18,870
good part is once they've created they

00:11:17,399 --> 00:11:20,639
just work you don't have to do anything

00:11:18,870 --> 00:11:22,320
magic to them once you have them they're

00:11:20,639 --> 00:11:23,940
updated and maintained and managed and

00:11:22,320 --> 00:11:26,070
dumped and restored and everything all

00:11:23,940 --> 00:11:30,300
the good stuff happens to them in

00:11:26,070 --> 00:11:33,029
Postgres so really support gin indexes

00:11:30,300 --> 00:11:34,980
generalize in verden indexes the nice

00:11:33,029 --> 00:11:36,899
part is these accelerate contains

00:11:34,980 --> 00:11:38,699
contained by and overlaps you get you

00:11:36,899 --> 00:11:41,180
get the unit will use the index as

00:11:38,699 --> 00:11:43,949
appropriate to make these guys go faster

00:11:41,180 --> 00:11:48,570
it doesn't help length or slice

00:11:43,949 --> 00:11:50,880
operations though so be aware of that so

00:11:48,570 --> 00:11:52,949
what this looks like at the sequel level

00:11:50,880 --> 00:11:56,040
is you create an index on app underscore

00:11:52,949 --> 00:11:57,810
model using Djinn field that using Djinn

00:11:56,040 --> 00:12:00,990
is the part that indicates that what you

00:11:57,810 --> 00:12:03,000
want is a Djinn type index one thing to

00:12:00,990 --> 00:12:04,290
notice gins can be large especially if

00:12:03,000 --> 00:12:05,550
there's a lot of data if there's a lot

00:12:04,290 --> 00:12:07,500
of data in the underlying table and

00:12:05,550 --> 00:12:09,600
they're not free to update just don't

00:12:07,500 --> 00:12:11,970
you know run around creating them just

00:12:09,600 --> 00:12:13,139
cuz create them if you are going to be

00:12:11,970 --> 00:12:17,579
doing the operations that will be

00:12:13,139 --> 00:12:19,819
accelerated by them specifically if it's

00:12:17,579 --> 00:12:22,980
a small table don't create a gini index

00:12:19,819 --> 00:12:24,540
you know you're throwing it unless it

00:12:22,980 --> 00:12:29,490
elicits a pedagogical exercise for

00:12:24,540 --> 00:12:31,170
yourself for some um if let's say you

00:12:29,490 --> 00:12:32,850
want to index length for example very

00:12:31,170 --> 00:12:35,100
common query is give me all the arrays

00:12:32,850 --> 00:12:37,649
that where the length is greater than 7

00:12:35,100 --> 00:12:39,089
i'm having a hard time coming up with an

00:12:37,649 --> 00:12:42,569
example of why you'd want to do this but

00:12:39,089 --> 00:12:45,300
the world is wide so people do this what

00:12:42,569 --> 00:12:47,579
you can do is create an expression index

00:12:45,300 --> 00:12:49,920
array underscore length is post chris's

00:12:47,579 --> 00:12:52,230
array length operation with the field

00:12:49,920 --> 00:12:53,850
you have to tell it which dimension you

00:12:52,230 --> 00:12:56,190
want the array the length of remember

00:12:53,850 --> 00:12:58,800
multi-dimensional arrays so dimension

00:12:56,190 --> 00:13:01,319
one and and dimension numbers are one

00:12:58,800 --> 00:13:05,579
based why yes post chris was invented in

00:13:01,319 --> 00:13:08,790
the early 90s why do you ask you can

00:13:05,579 --> 00:13:10,740
also index slice operations like that so

00:13:08,790 --> 00:13:12,750
if you're going to be doing a constant

00:13:10,740 --> 00:13:14,700
queries on does this slice equal that

00:13:12,750 --> 00:13:16,380
slice you can do those the

00:13:14,700 --> 00:13:18,120
firenze indicate this as an expression

00:13:16,380 --> 00:13:20,130
index so it's actually going to

00:13:18,120 --> 00:13:22,290
calculate this expression for each entry

00:13:20,130 --> 00:13:24,450
in the table and stuff it into an index

00:13:22,290 --> 00:13:26,310
for you postgis is smart enough that

00:13:24,450 --> 00:13:28,530
when you do the query and it sees a

00:13:26,310 --> 00:13:30,150
matching expression it'll use the index

00:13:28,530 --> 00:13:33,420
instead of running the query expression

00:13:30,150 --> 00:13:35,250
again so that's pretty cool those course

00:13:33,420 --> 00:13:38,310
and also post chris arrays are one based

00:13:35,250 --> 00:13:41,520
as well what can I say seemed like the

00:13:38,310 --> 00:13:43,620
thing to do with the time okay so now we

00:13:41,520 --> 00:13:44,880
have all this good this machinery for

00:13:43,620 --> 00:13:47,250
doing a rain fields but why would you

00:13:44,880 --> 00:13:48,870
ever want to use an array field well

00:13:47,250 --> 00:13:50,730
first one is the underlying data really

00:13:48,870 --> 00:13:52,830
is an array you want to store an array

00:13:50,730 --> 00:13:56,160
you're getting things like for example

00:13:52,830 --> 00:13:58,380
you know you a very common situation is

00:13:56,160 --> 00:14:00,180
your recording raw sensor input from a

00:13:58,380 --> 00:14:02,490
sensor and the sensor is hand saying

00:14:00,180 --> 00:14:05,430
okay at this time stamp I recorded 23

00:14:02,490 --> 00:14:07,440
samples here they are and you want to

00:14:05,430 --> 00:14:09,240
just dump this into a field you could d

00:14:07,440 --> 00:14:11,310
normalize you can normalize it sorry not

00:14:09,240 --> 00:14:13,440
D normalizing it and create two tables

00:14:11,310 --> 00:14:14,760
one for the base sensor and one for each

00:14:13,440 --> 00:14:17,030
of those but wow that's a lot of

00:14:14,760 --> 00:14:20,100
overhead so just stuff it in a ray field

00:14:17,030 --> 00:14:21,690
one of the best uses for an array is

00:14:20,100 --> 00:14:27,360
this a replacement for a mini too many

00:14:21,690 --> 00:14:29,520
table um one of the things that so for

00:14:27,360 --> 00:14:31,230
example the classic social networking

00:14:29,520 --> 00:14:35,160
problem you have things and you have

00:14:31,230 --> 00:14:37,350
people and people like things now in

00:14:35,160 --> 00:14:38,550
your basic relational database model the

00:14:37,350 --> 00:14:40,140
way you'd build this is you'd build an

00:14:38,550 --> 00:14:41,760
intermediate table that has a

00:14:40,140 --> 00:14:43,770
many-to-many table between people and

00:14:41,760 --> 00:14:45,300
things and every time someone likes a

00:14:43,770 --> 00:14:47,190
thing you insert an entry into this

00:14:45,300 --> 00:14:49,490
many-to-many table and then you have 1

00:14:47,190 --> 00:14:54,950
billion people and 12 billion things and

00:14:49,490 --> 00:14:59,450
that's kinda you know 85 petabyte

00:14:54,950 --> 00:15:03,570
many-to-many table ha okay probably not

00:14:59,450 --> 00:15:05,130
so what you can also do is in the people

00:15:03,570 --> 00:15:07,800
filled store an array of everything they

00:15:05,130 --> 00:15:09,090
like and in the end in the thing fields

00:15:07,800 --> 00:15:12,210
sort an array of everything that

00:15:09,090 --> 00:15:14,100
everyone who likes this thing there's

00:15:12,210 --> 00:15:16,890
these the the entries in array can be

00:15:14,100 --> 00:15:18,630
key fields so these could be integers

00:15:16,890 --> 00:15:21,300
that index to a part two to the other

00:15:18,630 --> 00:15:24,819
side much more compact and efficient to

00:15:21,300 --> 00:15:26,709
query and then you index each field

00:15:24,819 --> 00:15:28,149
I'm not sure I would build Facebook this

00:15:26,709 --> 00:15:31,720
way but if you have a smaller system

00:15:28,149 --> 00:15:33,459
this could work very well um you can

00:15:31,720 --> 00:15:34,899
also use this is for Dee normalizing the

00:15:33,459 --> 00:15:36,609
results of an expensive query for

00:15:34,899 --> 00:15:39,639
example you're doing that you're caching

00:15:36,609 --> 00:15:41,829
the results of a query you might keep

00:15:39,639 --> 00:15:44,350
the many-to-many field for some other

00:15:41,829 --> 00:15:45,519
reason but but I have an optimization

00:15:44,350 --> 00:15:47,979
where you're storing it as your Mo's

00:15:45,519 --> 00:15:50,289
denormalization de normalizations like

00:15:47,979 --> 00:15:52,619
this are generally need to be approached

00:15:50,289 --> 00:15:55,660
with caution I won't say never do them

00:15:52,619 --> 00:15:57,069
but because you do have to worry about

00:15:55,660 --> 00:15:59,709
maintaining them make sure you the data

00:15:57,069 --> 00:16:03,910
stays up to date things like that but it

00:15:59,709 --> 00:16:05,709
can be very useful ok and now we have h

00:16:03,910 --> 00:16:10,660
store fields who's already used H sort

00:16:05,709 --> 00:16:14,439
in Postgres ok so each store is a semi

00:16:10,660 --> 00:16:16,959
built-in hash store data type it's like

00:16:14,439 --> 00:16:18,879
a dict a Python that can only

00:16:16,959 --> 00:16:21,759
take strings as keys as values and

00:16:18,879 --> 00:16:26,109
values so it's a single level it has to

00:16:21,759 --> 00:16:27,669
be a string on each side pre the JSON

00:16:26,109 --> 00:16:29,769
type in Postgres this was the only way

00:16:27,669 --> 00:16:32,229
of storing unstructured data associative

00:16:29,769 --> 00:16:35,350
data like this it's not super powerful

00:16:32,229 --> 00:16:37,569
and you notice the semi in semi built in

00:16:35,350 --> 00:16:39,339
and we'll talk about what that means so

00:16:37,569 --> 00:16:40,600
first of all how do you get each sort of

00:16:39,339 --> 00:16:42,309
work because if you log into your

00:16:40,600 --> 00:16:44,019
average price chris database and and try

00:16:42,309 --> 00:16:46,509
and create an H column you know create

00:16:44,019 --> 00:16:47,769
table blah blah blah x each store and it

00:16:46,509 --> 00:16:49,569
throws an error saying I have no idea

00:16:47,769 --> 00:16:52,389
what that the each store type is because

00:16:49,569 --> 00:16:53,859
it's not actually built into postgres it

00:16:52,389 --> 00:16:55,269
has to be installed before in a

00:16:53,859 --> 00:16:57,970
particular database before you can use

00:16:55,269 --> 00:17:00,850
it it's not part of core on the good

00:16:57,970 --> 00:17:02,409
part is congenial kinship postgres comes

00:17:00,850 --> 00:17:05,289
with an H store extension that will

00:17:02,409 --> 00:17:06,850
install it for you so you create a

00:17:05,289 --> 00:17:08,799
custom migration that we use in them to

00:17:06,850 --> 00:17:11,470
create an empty migration add the H

00:17:08,799 --> 00:17:13,870
store extension to operation to it and

00:17:11,470 --> 00:17:17,169
it'll apply it and you're done so that's

00:17:13,870 --> 00:17:18,669
good there's this one weirdness which

00:17:17,169 --> 00:17:20,230
only really matters if you're really

00:17:18,669 --> 00:17:21,549
pushing the performance of your database

00:17:20,230 --> 00:17:23,259
and for some reason you're not using

00:17:21,549 --> 00:17:27,129
connection pooling which you should be

00:17:23,259 --> 00:17:28,500
um the problem is that it has to do

00:17:27,129 --> 00:17:31,389
every time you connect to the database

00:17:28,500 --> 00:17:32,710
psycho PG to which everybody is

00:17:31,389 --> 00:17:36,039
basically using if you're using Python

00:17:32,710 --> 00:17:37,179
um has to connect to the get the object

00:17:36,039 --> 00:17:38,040
identifier for the east shore type

00:17:37,179 --> 00:17:41,520
because it could be differ

00:17:38,040 --> 00:17:44,160
in every database so this adds one query

00:17:41,520 --> 00:17:45,510
to the connection it's usually not a big

00:17:44,160 --> 00:17:47,160
deal especially because Django has this

00:17:45,510 --> 00:17:48,360
thing about asking all sorts of

00:17:47,160 --> 00:17:49,470
questions for the database on every

00:17:48,360 --> 00:17:51,210
connection like what's your time zone

00:17:49,470 --> 00:17:53,010
and things like that so no more what so

00:17:51,210 --> 00:17:55,500
what's one more query among friends but

00:17:53,010 --> 00:17:57,420
you do have to be aware that's what's

00:17:55,500 --> 00:18:01,170
going on if you see this query fly by

00:17:57,420 --> 00:18:03,030
now you know what's going on so um H

00:18:01,170 --> 00:18:06,030
star types are represented python is a

00:18:03,030 --> 00:18:08,760
dict the keys of values must be strings

00:18:06,030 --> 00:18:11,910
non integers not lists not hat not

00:18:08,760 --> 00:18:13,440
anything else um they're translated to

00:18:11,910 --> 00:18:15,780
and from the database encoding so if

00:18:13,440 --> 00:18:18,030
your databases in something besides

00:18:15,780 --> 00:18:21,030
utf-8 they'll be translated to the right

00:18:18,030 --> 00:18:24,120
encoding on inside a Python please say

00:18:21,030 --> 00:18:27,210
your databases in utf-8 because it's

00:18:24,120 --> 00:18:29,460
horrible if it's not really don't do

00:18:27,210 --> 00:18:33,630
that so but it makes database dba's cry

00:18:29,460 --> 00:18:36,260
um but if in the off chance it's not in

00:18:33,630 --> 00:18:38,700
utf-8 it'll do the translation for you

00:18:36,260 --> 00:18:40,830
each source supports contains and

00:18:38,700 --> 00:18:44,580
contains by both the key and the value

00:18:40,830 --> 00:18:46,170
have to match into this and you have has

00:18:44,580 --> 00:18:49,890
Kate which matches fields containing a

00:18:46,170 --> 00:18:53,100
particular key so that's cool and you

00:18:49,890 --> 00:18:57,270
have it has keys which takes a list so

00:18:53,100 --> 00:19:00,480
that's pretty useful um and then there's

00:18:57,270 --> 00:19:02,190
a keys which returns the list which

00:19:00,480 --> 00:19:05,970
matches the list of the keys in the

00:19:02,190 --> 00:19:10,380
field so you can say give me the give me

00:19:05,970 --> 00:19:13,440
all the fields who's there about ro rose

00:19:10,380 --> 00:19:16,730
whose field has keys which contain

00:19:13,440 --> 00:19:18,720
either A or B so that's prequel and

00:19:16,730 --> 00:19:20,400
values this the same for the values of

00:19:18,720 --> 00:19:25,380
the HR field so you can query on values

00:19:20,400 --> 00:19:29,400
as well each story fields support gin

00:19:25,380 --> 00:19:33,270
indexes so exact same syntax at model to

00:19:29,400 --> 00:19:37,440
loop and accelerates contains has key

00:19:33,270 --> 00:19:39,000
has keys but not contains x sorry just

00:19:37,440 --> 00:19:42,660
the wage in the just the way the gin

00:19:39,000 --> 00:19:45,060
index is built for an H store so why

00:19:42,660 --> 00:19:46,710
would you use an HR field so it's great

00:19:45,060 --> 00:19:48,840
for storing very rare attributes um

00:19:46,710 --> 00:19:51,059
Andrew actually touched on this at his

00:19:48,840 --> 00:19:53,460
talk is great talked earlier

00:19:51,059 --> 00:19:56,399
database anti-patterns what which is

00:19:53,460 --> 00:19:57,929
you're right a CMS or some other system

00:19:56,399 --> 00:19:58,950
even an inventory control system or

00:19:57,929 --> 00:20:00,779
something like that you send to the

00:19:58,950 --> 00:20:03,059
customer and you send it to a bunch of

00:20:00,779 --> 00:20:04,019
customers and you don't want you want

00:20:03,059 --> 00:20:05,999
the customer to be able to add

00:20:04,019 --> 00:20:07,470
attributes to items for example an

00:20:05,999 --> 00:20:09,330
inventory control system you might want

00:20:07,470 --> 00:20:12,149
to be able to tell people ok for the

00:20:09,330 --> 00:20:14,970
item they want to be able to add ISBN if

00:20:12,149 --> 00:20:17,820
it's a book or color if it's a thing

00:20:14,970 --> 00:20:19,590
that comes in colors or sizes but not

00:20:17,820 --> 00:20:20,850
every item is going to have that and you

00:20:19,590 --> 00:20:22,529
don't know when you ship your product

00:20:20,850 --> 00:20:24,059
out to the customer which attributes

00:20:22,529 --> 00:20:26,190
they're going to want well you could

00:20:24,059 --> 00:20:27,990
create fields in individual fields of

00:20:26,190 --> 00:20:29,639
the database but that's first kind of

00:20:27,990 --> 00:20:31,470
hard in Django and second of all that

00:20:29,639 --> 00:20:33,749
way madness lies from of migrations and

00:20:31,470 --> 00:20:35,519
implementation point of view well but

00:20:33,749 --> 00:20:37,919
what you can do is create a single H

00:20:35,519 --> 00:20:39,690
store field and put use it as the place

00:20:37,919 --> 00:20:43,049
to store all of these random attributes

00:20:39,690 --> 00:20:44,279
um generally my rule of thumb is if

00:20:43,049 --> 00:20:45,869
they're going to be fields that are no

00:20:44,279 --> 00:20:49,769
ninety-five percent of the time consider

00:20:45,869 --> 00:20:51,960
an HR field instead and remember but one

00:20:49,769 --> 00:20:54,419
thing to remember in this in this use is

00:20:51,960 --> 00:20:56,999
that nut fields take zero space in

00:20:54,419 --> 00:21:00,210
postgresql they don't actually take any

00:20:56,999 --> 00:21:02,100
room on disk so you're not costing any

00:21:00,210 --> 00:21:05,429
space by creating null fields with zero

00:21:02,100 --> 00:21:06,720
use so and another use for these is if

00:21:05,429 --> 00:21:10,980
you have a Fiat attribute that's

00:21:06,720 --> 00:21:12,330
populated very very very rarely that

00:21:10,980 --> 00:21:15,169
it's not worth creating a whole field

00:21:12,330 --> 00:21:17,279
for this is another solution to that and

00:21:15,169 --> 00:21:22,710
user-defined attributes which we just

00:21:17,279 --> 00:21:24,090
talked about that being said if you're

00:21:22,710 --> 00:21:26,580
doing greenfield development right now

00:21:24,090 --> 00:21:28,860
you probably want to use JSON instead

00:21:26,580 --> 00:21:32,389
especially once 1.9 comes out and we

00:21:28,860 --> 00:21:34,559
have first-class JSON support in Django

00:21:32,389 --> 00:21:37,289
but if you have to do something right

00:21:34,559 --> 00:21:38,850
now there's no JSON type in 18 so use

00:21:37,289 --> 00:21:41,700
JSON if you H door if you need it right

00:21:38,850 --> 00:21:45,360
away or you're trying to plug into an

00:21:41,700 --> 00:21:47,460
existing database which has aged or now

00:21:45,360 --> 00:21:50,759
in increasing order of coolness we now

00:21:47,460 --> 00:21:54,570
come to range fields postgresql now has

00:21:50,759 --> 00:21:58,259
native range types resep span range of a

00:21:54,570 --> 00:22:00,629
sum of a scalar type so for example 1

00:21:58,259 --> 00:22:04,620
comma 8 as in full range includes all of

00:22:00,629 --> 00:22:07,200
those that this is an inclusive range so

00:22:04,620 --> 00:22:09,420
it includes those guys you can also

00:22:07,200 --> 00:22:12,420
write them as exclusive balance so for

00:22:09,420 --> 00:22:16,200
example 1 comma 8 it goes from one to

00:22:12,420 --> 00:22:19,770
seven but doesn't include eight so far

00:22:16,200 --> 00:22:21,420
so good and that's the default notice

00:22:19,770 --> 00:22:23,940
that this is the postgresql syntax

00:22:21,420 --> 00:22:25,500
obviously you can't write this in Python

00:22:23,940 --> 00:22:28,320
and have it be syntactically legal that

00:22:25,500 --> 00:22:29,970
would be awfully cool wouldn't but their

00:22:28,320 --> 00:22:31,920
language is to let you do that anyway

00:22:29,970 --> 00:22:33,990
but this is in prob so the fill and the

00:22:31,920 --> 00:22:35,670
default is this open on one and clothes

00:22:33,990 --> 00:22:40,260
that are closed on one side open on the

00:22:35,670 --> 00:22:42,240
other range if you omit abound it means

00:22:40,260 --> 00:22:44,910
all values greater than or less than for

00:22:42,240 --> 00:22:47,010
some types particularly dates how also

00:22:44,910 --> 00:22:49,410
have a special infinity value I guess

00:22:47,010 --> 00:22:53,670
there's a special end of days value and

00:22:49,410 --> 00:22:55,050
types I don't know it's um so if you see

00:22:53,670 --> 00:23:00,150
one of those coming out of a query you

00:22:55,050 --> 00:23:01,679
might one second PG to the the database

00:23:00,150 --> 00:23:03,150
adapter that pretty much there's no

00:23:01,679 --> 00:23:04,800
reason not to use and if you're using

00:23:03,150 --> 00:23:08,570
Django you have to work hard not to use

00:23:04,800 --> 00:23:10,980
it includes a Python range base type

00:23:08,570 --> 00:23:12,870
that handles all the various boundary

00:23:10,980 --> 00:23:14,970
cases and the Infinity special cases and

00:23:12,870 --> 00:23:17,640
that's what the the range fields in

00:23:14,970 --> 00:23:20,160
Django are built on top of out of the

00:23:17,640 --> 00:23:21,720
box 18 supports integer range and big

00:23:20,160 --> 00:23:26,160
integer range so 32-bit and 64-bit

00:23:21,720 --> 00:23:31,170
integers a float range day time range

00:23:26,160 --> 00:23:33,210
and a date range I am pleased to say the

00:23:31,170 --> 00:23:35,580
date-time range is time-stamped eat with

00:23:33,210 --> 00:23:37,050
time zone in Postgres because if you're

00:23:35,580 --> 00:23:40,140
using timestamp without time

00:23:37,050 --> 00:23:43,350
time-stamped easy you're probably making

00:23:40,140 --> 00:23:44,820
a very bad mistake so everybody go and

00:23:43,350 --> 00:23:47,420
make sure that you're using timestamp

00:23:44,820 --> 00:23:52,110
not time-stamped easy not timestamp and

00:23:47,420 --> 00:23:53,160
date range so contains contain by an

00:23:52,110 --> 00:23:55,350
overlap kind of work the way you'd

00:23:53,160 --> 00:23:57,960
expect to run comparing two ranges

00:23:55,350 --> 00:23:59,640
there's also a fully less than fully

00:23:57,960 --> 00:24:00,660
greater than which is true of both the

00:23:59,640 --> 00:24:01,920
upper bounds and lower bounds of the

00:24:00,660 --> 00:24:03,720
field are greater than or less than the

00:24:01,920 --> 00:24:05,580
comparison value so if the whole range

00:24:03,720 --> 00:24:10,620
is to one side are the whole ranges to

00:24:05,580 --> 00:24:12,660
the other and adjacent to is you is true

00:24:10,620 --> 00:24:14,730
if two ranges exactly bump up against

00:24:12,660 --> 00:24:17,220
each other there's no space between them

00:24:14,730 --> 00:24:17,840
there are no values this is a place

00:24:17,220 --> 00:24:19,850
where the

00:24:17,840 --> 00:24:22,100
parenthesis the open bound is useful

00:24:19,850 --> 00:24:23,659
because you can man on a closed bound

00:24:22,100 --> 00:24:25,400
there's no way of doing this with a

00:24:23,659 --> 00:24:28,520
continuous type there's no way of

00:24:25,400 --> 00:24:31,429
writing to float ranges to float ranges

00:24:28,520 --> 00:24:32,270
that are closed that exactly bump up

00:24:31,429 --> 00:24:33,980
against each other because there's

00:24:32,270 --> 00:24:35,779
always another float that you can shove

00:24:33,980 --> 00:24:39,380
into there so this is why an open range

00:24:35,779 --> 00:24:41,750
is important there's also not less than

00:24:39,380 --> 00:24:43,520
as the fields contained does not contain

00:24:41,750 --> 00:24:45,289
any points less than comparison value

00:24:43,520 --> 00:24:51,289
and not greater than which works the

00:24:45,289 --> 00:24:55,640
other way around range fields use gist

00:24:51,289 --> 00:24:57,049
on the indexes which you could probably

00:24:55,640 --> 00:25:00,110
have guessed this in text but here it is

00:24:57,049 --> 00:25:02,480
at model using gist field note that the

00:25:00,110 --> 00:25:04,700
r you will have to for now you have to

00:25:02,480 --> 00:25:06,529
drop this into a run sequel migration

00:25:04,700 --> 00:25:08,600
you there's no way of saying this just

00:25:06,529 --> 00:25:12,080
at the Django model level that's okay

00:25:08,600 --> 00:25:13,970
that's what the run sequels for all the

00:25:12,080 --> 00:25:16,880
comparison operators that we that we

00:25:13,970 --> 00:25:19,520
just described are accelerated by the

00:25:16,880 --> 00:25:23,480
gist um by having a gist index on a

00:25:19,520 --> 00:25:26,480
range so why don't you use this well

00:25:23,480 --> 00:25:28,309
here's a problem what say you you're

00:25:26,480 --> 00:25:29,720
running a hotel and your rule is don't

00:25:28,309 --> 00:25:31,340
allow two bookings for a room to be

00:25:29,720 --> 00:25:34,399
inserted in the database for the same

00:25:31,340 --> 00:25:36,409
room for the dates overlap okay and you

00:25:34,399 --> 00:25:39,529
want to do so how do you solve this

00:25:36,409 --> 00:25:40,970
problem there's actually no way of

00:25:39,529 --> 00:25:42,529
solving this with traditional unique

00:25:40,970 --> 00:25:45,320
constraints because there's nothing

00:25:42,529 --> 00:25:48,649
that's necessarily unique you could say

00:25:45,320 --> 00:25:50,559
room 102 for monday through friday and

00:25:48,649 --> 00:25:53,330
room 102 for tuesday through saturday

00:25:50,559 --> 00:25:56,090
there's nothing you those two taken

00:25:53,330 --> 00:25:57,950
together are not unique but they are

00:25:56,090 --> 00:25:59,330
still that's not valid to have both in

00:25:57,950 --> 00:26:01,159
the database at the same time you double

00:25:59,330 --> 00:26:04,370
booked the room scratch scratch scratch

00:26:01,159 --> 00:26:06,620
so how do we solve this problem postgres

00:26:04,370 --> 00:26:08,120
to the rescue we have a facility in post

00:26:06,620 --> 00:26:09,919
what's called an exclusion constraint

00:26:08,120 --> 00:26:12,830
which is a relatively new feature I

00:26:09,919 --> 00:26:16,929
think 12 in Postgres but it will allow

00:26:12,830 --> 00:26:19,580
you to do not have this situation arise

00:26:16,929 --> 00:26:21,350
it's a generalization of the idea of a

00:26:19,580 --> 00:26:22,370
unique constraint let's stop for a

00:26:21,350 --> 00:26:25,039
moment think about what unique means

00:26:22,370 --> 00:26:26,510
unique you can say unique says well no

00:26:25,039 --> 00:26:28,490
two values can be the same for this

00:26:26,510 --> 00:26:30,650
column when you insert them okay that's

00:26:28,490 --> 00:26:34,190
fine but you can also say

00:26:30,650 --> 00:26:36,760
don't allow any two values who both

00:26:34,190 --> 00:26:39,800
which pass the Equality operator in

00:26:36,760 --> 00:26:40,760
there now we've said it the same thing

00:26:39,800 --> 00:26:43,250
but we've said in a slightly different

00:26:40,760 --> 00:26:44,870
way we've said don't allow two things

00:26:43,250 --> 00:26:47,660
that where this particular operator

00:26:44,870 --> 00:26:51,950
equality are in the database the same

00:26:47,660 --> 00:26:53,870
time so we could say one thing for the

00:26:51,950 --> 00:26:56,930
operator is inequality but the operator

00:26:53,870 --> 00:26:58,850
is some other operator so we could say

00:26:56,930 --> 00:27:00,500
don't allow two things in the database

00:26:58,850 --> 00:27:03,650
at the same time where the overlaps

00:27:00,500 --> 00:27:07,580
operator matches them hmm well that's

00:27:03,650 --> 00:27:09,410
interesting because now and then we say

00:27:07,580 --> 00:27:11,630
well okay and let's let you add them

00:27:09,410 --> 00:27:13,670
together so we'll say these two fields

00:27:11,630 --> 00:27:15,560
can't pass this operator and these two

00:27:13,670 --> 00:27:18,320
fields can't pass this operator and and

00:27:15,560 --> 00:27:20,960
and so generalize the idea of unique to

00:27:18,320 --> 00:27:24,860
let you use any operators in combination

00:27:20,960 --> 00:27:27,520
with and and I think an example will be

00:27:24,860 --> 00:27:30,620
very important here we'll keep the faces

00:27:27,520 --> 00:27:34,730
so there's a catch do you have to have a

00:27:30,620 --> 00:27:37,150
single index for this whole shebang and

00:27:34,730 --> 00:27:40,730
since range types required just index

00:27:37,150 --> 00:27:41,990
the index has to be at just index but

00:27:40,730 --> 00:27:43,700
the problem is we talked about this

00:27:41,990 --> 00:27:45,890
example where we were using room and

00:27:43,700 --> 00:27:47,660
rooms just an integer or string you know

00:27:45,890 --> 00:27:49,400
well however the hotel wants to

00:27:47,660 --> 00:27:50,960
represent them this is a scalar value

00:27:49,400 --> 00:27:54,170
and scalar values don't have just type

00:27:50,960 --> 00:27:55,820
or don't have just indexing oh oh we

00:27:54,170 --> 00:27:57,200
just blew it why was there's grow I was

00:27:55,820 --> 00:27:58,640
going to you show you this great example

00:27:57,200 --> 00:28:00,820
of how to solve this problem in Postgres

00:27:58,640 --> 00:28:02,930
and now I can't well of course you can

00:28:00,820 --> 00:28:05,660
because there's a module club b-tree

00:28:02,930 --> 00:28:08,240
gist which lets you create these indexes

00:28:05,660 --> 00:28:10,330
on mostly simple scalar types it's a

00:28:08,240 --> 00:28:12,500
post miss extension it's part of

00:28:10,330 --> 00:28:14,120
contributor database but it ships with

00:28:12,500 --> 00:28:15,680
postgres which means you can use the

00:28:14,120 --> 00:28:18,650
create extension migration to get it

00:28:15,680 --> 00:28:21,230
into your database so let's talk about

00:28:18,650 --> 00:28:22,490
how we'd actually use this so you know

00:28:21,230 --> 00:28:24,020
import the model is important the

00:28:22,490 --> 00:28:25,400
daytime field and here's a booking and

00:28:24,020 --> 00:28:27,500
here's the room and here's the range and

00:28:25,400 --> 00:28:29,780
okay this was probably a foreign key to

00:28:27,500 --> 00:28:32,330
a room but you know you get it that's

00:28:29,780 --> 00:28:35,000
easy and then we say okay what does it

00:28:32,330 --> 00:28:37,670
look what's it look like well there's

00:28:35,000 --> 00:28:39,740
the integer that Jane created for us in

00:28:37,670 --> 00:28:43,480
the room and the deranged and we're all

00:28:39,740 --> 00:28:46,930
set okay so far so good now

00:28:43,480 --> 00:28:49,750
this extension beat regist and we add

00:28:46,930 --> 00:28:50,920
this exclusion constraint now notice

00:28:49,750 --> 00:28:54,490
what we're doing here is we're saying

00:28:50,920 --> 00:28:57,910
add this index where the room is equal

00:28:54,490 --> 00:28:59,770
and the date is with at and and and end

00:28:57,910 --> 00:29:02,410
is the postgres version of the of the

00:28:59,770 --> 00:29:04,120
overlaps operator so when you do an

00:29:02,410 --> 00:29:06,840
overlaps query in Django what you're

00:29:04,120 --> 00:29:09,610
going to get is this double ampersand

00:29:06,840 --> 00:29:11,860
okay now let's try adding some rooms

00:29:09,610 --> 00:29:15,520
with all of this say we're going to add

00:29:11,860 --> 00:29:18,430
a room and save that worked at a room

00:29:15,520 --> 00:29:22,450
and save so because it's the same room

00:29:18,430 --> 00:29:25,510
but entirely different range at a room

00:29:22,450 --> 00:29:28,150
save so far so good because same way

00:29:25,510 --> 00:29:31,890
same time range but different room okay

00:29:28,150 --> 00:29:37,210
room due to do one two three save Oh

00:29:31,890 --> 00:29:41,740
notice however this overlaps that bank

00:29:37,210 --> 00:29:44,170
oh look it didn't let me do that pretty

00:29:41,740 --> 00:29:45,670
cool and notice this means the

00:29:44,170 --> 00:29:48,130
constraint is being enforced at the

00:29:45,670 --> 00:29:51,910
database level sure you could write code

00:29:48,130 --> 00:29:54,040
in Python that would do the query and if

00:29:51,910 --> 00:29:56,620
a return under an overlapping range say

00:29:54,040 --> 00:29:58,000
no there's exception but that but the

00:29:56,620 --> 00:30:00,190
nice part about doing in the database is

00:29:58,000 --> 00:30:05,080
if you're doing bulk imports if you have

00:30:00,190 --> 00:30:08,710
other kinds of queries you you can this

00:30:05,080 --> 00:30:10,720
means the database itself enforces it so

00:30:08,710 --> 00:30:12,790
you should use ranges ratios represent

00:30:10,720 --> 00:30:15,310
ranges I hope you get a lot of value out

00:30:12,790 --> 00:30:17,980
of this slide um you probably figure

00:30:15,310 --> 00:30:19,180
that one out it's no natural and you get

00:30:17,980 --> 00:30:21,520
better operations than the traditional

00:30:19,180 --> 00:30:24,160
high-low pair of stuff in the database

00:30:21,520 --> 00:30:26,410
and you get more database integrity more

00:30:24,160 --> 00:30:29,260
interesting operators available now

00:30:26,410 --> 00:30:31,330
coming soon we have JSON fields they're

00:30:29,260 --> 00:30:34,240
not in 18 but I think they've almost

00:30:31,330 --> 00:30:35,860
sure they've landed 419 these are fields

00:30:34,240 --> 00:30:37,690
to support arbitrary JSON structures

00:30:35,860 --> 00:30:39,280
there's still a little bit of a work in

00:30:37,690 --> 00:30:41,730
progress both on the Django side and on

00:30:39,280 --> 00:30:45,010
the JSON side on the PostScript side

00:30:41,730 --> 00:30:49,540
post chris has to json types JSON and

00:30:45,010 --> 00:30:51,220
JSON be sorry about that um JSON stores

00:30:49,540 --> 00:30:53,020
the raw text the JSON blob white space

00:30:51,220 --> 00:30:54,410
and all it is literally the text it is

00:30:53,020 --> 00:30:57,710
it in fact a rapper

00:30:54,410 --> 00:31:00,560
noun post Chris's text type JSON B is a

00:30:57,710 --> 00:31:03,170
compacts indexable representation it's a

00:31:00,560 --> 00:31:07,850
lot like it's it's similar to be sawn

00:31:03,170 --> 00:31:10,700
but it's a lot better um so why use JSON

00:31:07,850 --> 00:31:11,870
instead of JSON be it's faster to insert

00:31:10,700 --> 00:31:13,430
since it doesn't have to process the

00:31:11,870 --> 00:31:16,670
data just shoves the raw text in the

00:31:13,430 --> 00:31:18,560
database and JSON allows for two highly

00:31:16,670 --> 00:31:20,150
dubious features that people use in JSON

00:31:18,560 --> 00:31:21,860
which are duplicate object keys of the

00:31:20,150 --> 00:31:24,290
same level and stable object key order

00:31:21,860 --> 00:31:25,640
these are not allowed by there's nothing

00:31:24,290 --> 00:31:27,110
in the JSON spec that says that these

00:31:25,640 --> 00:31:29,360
will these features are available in

00:31:27,110 --> 00:31:33,140
JSON but people still use them bad

00:31:29,360 --> 00:31:34,790
people they should feel bad um and it's

00:31:33,140 --> 00:31:36,590
also this is ok if you're just logging

00:31:34,790 --> 00:31:38,570
JSON like you have a log table that's

00:31:36,590 --> 00:31:40,130
accumulating API calls or something like

00:31:38,570 --> 00:31:41,480
that well you don't really need to

00:31:40,130 --> 00:31:46,010
process the stuff you just want to have

00:31:41,480 --> 00:31:47,690
it somewhere so JSON be pretty much

00:31:46,010 --> 00:31:49,910
every other application you want JSON be

00:31:47,690 --> 00:31:53,210
it's it can be indexing useful ways

00:31:49,910 --> 00:31:55,430
unlike JSON um the first coming JSON

00:31:53,210 --> 00:31:57,020
field and Django uses JSON be as its

00:31:55,430 --> 00:32:02,510
underlying representation so just roll

00:31:57,020 --> 00:32:04,400
with it json be has gin indexing json

00:32:02,510 --> 00:32:06,020
json the only kind of indexing is

00:32:04,400 --> 00:32:07,250
available for JSON or be tree indexes

00:32:06,020 --> 00:32:10,730
the treat them like strings which is

00:32:07,250 --> 00:32:16,700
pretty much useless you get these

00:32:10,730 --> 00:32:18,110
operators which and the query the quake

00:32:16,700 --> 00:32:20,030
has to be against the top level of the

00:32:18,110 --> 00:32:22,340
object in the index to be useful so you

00:32:20,030 --> 00:32:24,260
can't index you can't do a query if you

00:32:22,340 --> 00:32:25,940
have a nested JSON structure you can't

00:32:24,260 --> 00:32:28,420
query for a key that's way down in the

00:32:25,940 --> 00:32:31,850
structure it has to be at the top level

00:32:28,420 --> 00:32:33,590
that's being worked on you can query

00:32:31,850 --> 00:32:36,470
nested objects but only in paths that

00:32:33,590 --> 00:32:38,870
are rooted to the top level so why would

00:32:36,470 --> 00:32:41,870
you use JSON support in general you're

00:32:38,870 --> 00:32:43,310
logging JSON data you want audit tables

00:32:41,870 --> 00:32:46,040
that work across multiple schemas this

00:32:43,310 --> 00:32:47,720
is a very common problem in a database

00:32:46,040 --> 00:32:49,760
in relational databases where you want a

00:32:47,720 --> 00:32:52,190
single audit table that handles all the

00:32:49,760 --> 00:32:53,660
other tables rather than having one all

00:32:52,190 --> 00:32:57,530
that table for every other table which

00:32:53,660 --> 00:32:59,630
is that way madness lies in some nice

00:32:57,530 --> 00:33:01,600
way of pickling Python object so you

00:32:59,630 --> 00:33:04,220
could so that other tools can read them

00:33:01,600 --> 00:33:07,149
the standard libraries that pickle

00:33:04,220 --> 00:33:08,589
Python objects into JSON kind

00:33:07,149 --> 00:33:12,700
a lot of cruft into them for my taste

00:33:08,589 --> 00:33:13,809
but it's work they work and for the

00:33:12,700 --> 00:33:15,639
other things that you used to use h

00:33:13,809 --> 00:33:19,899
store for like user defined objects

00:33:15,639 --> 00:33:22,659
where fields things like that oh the UM

00:33:19,899 --> 00:33:24,159
the new fields go on the new fields have

00:33:22,659 --> 00:33:27,129
admin widgets that go with them that are

00:33:24,159 --> 00:33:28,059
really very cool um each store in JSON

00:33:27,129 --> 00:33:29,080
widgets are really only good for

00:33:28,059 --> 00:33:31,509
debugging because you know you basically

00:33:29,080 --> 00:33:33,969
get the raw text spat out to you in but

00:33:31,509 --> 00:33:38,409
you know why are you using the admin for

00:33:33,969 --> 00:33:39,609
this mmm and the UH neck sent filter

00:33:38,409 --> 00:33:42,429
which I'm out of time for so just read

00:33:39,609 --> 00:33:45,029
about in documentation um and thank you

00:33:42,429 --> 00:33:45,029
questions

00:33:54,050 --> 00:34:01,020
if in Postgres the arrays are one index

00:33:57,960 --> 00:34:03,780
the example you gave in a queryset

00:34:01,020 --> 00:34:07,050
filter was zero index is Django

00:34:03,780 --> 00:34:09,090
converting the yeah it's all it's Python

00:34:07,050 --> 00:34:10,410
style indexing with in Django because

00:34:09,090 --> 00:34:14,490
otherwise you would probably go insane

00:34:10,410 --> 00:34:22,650
yeah so but it does the zero to one

00:34:14,490 --> 00:34:26,730
conversion for you okay cool quick

00:34:22,650 --> 00:34:29,370
question about expression indexes um our

00:34:26,730 --> 00:34:31,590
expression indexes b-tree indexes or can

00:34:29,370 --> 00:34:34,140
they can you can have beat region in

00:34:31,590 --> 00:34:36,570
just indexes yes it's a little bit of an

00:34:34,140 --> 00:34:39,720
advanced class but for example you you I

00:34:36,570 --> 00:34:42,110
can definitely see things like if the

00:34:39,720 --> 00:34:46,410
output of the operation like a slice is

00:34:42,110 --> 00:34:48,570
um is generous a Jenner just indexable

00:34:46,410 --> 00:34:51,060
type then by all means you can have a

00:34:48,570 --> 00:34:53,419
generous expression index and putt

00:34:51,060 --> 00:34:58,320
post-course does the right thing Gee uh

00:34:53,419 --> 00:35:07,080
um uh the various geo extensions do this

00:34:58,320 --> 00:35:08,490
a lot for cool stuff so so I'm used to

00:35:07,080 --> 00:35:10,440
having to be a super easy to create

00:35:08,490 --> 00:35:11,580
extensions is there any hope to not need

00:35:10,440 --> 00:35:15,210
that requirement when I'm putting in

00:35:11,580 --> 00:35:17,640
migrations um nope okay yeah sadly well

00:35:15,210 --> 00:35:19,350
see assembly because because you could

00:35:17,640 --> 00:35:20,940
really seriously screw up your database

00:35:19,350 --> 00:35:22,950
with it with a bad create extension

00:35:20,940 --> 00:35:24,960
superuser access is going to be required

00:35:22,950 --> 00:35:28,170
which is really annoying if your example

00:35:24,960 --> 00:35:29,430
on RDS where you don't have superuser so

00:35:28,170 --> 00:35:31,290
in the case of that you don't use the

00:35:29,430 --> 00:35:33,270
create extension situation you write

00:35:31,290 --> 00:35:38,400
many angry letters to Amazon asking for

00:35:33,270 --> 00:35:40,890
that extension on the next release sorry

00:35:38,400 --> 00:35:42,690
one more question of course do you have

00:35:40,890 --> 00:35:48,180
any tips on migrating my sequel to

00:35:42,690 --> 00:35:51,570
postgres hi Russ um there's it's not

00:35:48,180 --> 00:35:53,310
that I can deliver in a small thing like

00:35:51,570 --> 00:35:55,110
this I will say that you actually the

00:35:53,310 --> 00:35:56,940
database layer is usually only about

00:35:55,110 --> 00:35:59,040
twenty-five percent of the pay of the

00:35:56,940 --> 00:36:02,430
nightmare the rest of the nightmare is

00:35:59,040 --> 00:36:02,970
the at the application level it's not so

00:36:02,430 --> 00:36:06,270
if you

00:36:02,970 --> 00:36:08,790
been really ruthless about your about

00:36:06,270 --> 00:36:10,170
your database agnosticism in Django you

00:36:08,790 --> 00:36:12,540
probably can get away with it without

00:36:10,170 --> 00:36:14,790
too much hassle and there are tools that

00:36:12,540 --> 00:36:16,410
will probably do it for there but a

00:36:14,790 --> 00:36:18,360
surprising number of my sequel

00:36:16,410 --> 00:36:21,780
applications rely on things like the

00:36:18,360 --> 00:36:24,630
return primary key on query on query

00:36:21,780 --> 00:36:27,920
form for null thing that my sequel does

00:36:24,630 --> 00:36:30,180
and you know DB and things like that so

00:36:27,920 --> 00:36:31,890
most of the time you spend most of the

00:36:30,180 --> 00:36:33,750
time looking for my sequel isms in the

00:36:31,890 --> 00:36:35,100
code actually rather the database those

00:36:33,750 --> 00:36:36,780
tools out there that actually do that

00:36:35,100 --> 00:36:42,150
will do the dump and load conversion for

00:36:36,780 --> 00:36:45,420
you hi are there are there any

00:36:42,150 --> 00:36:48,870
performance improvements moving from a

00:36:45,420 --> 00:36:52,830
many-to-many table to an array is

00:36:48,870 --> 00:36:54,330
potentially huge because the when you

00:36:52,830 --> 00:36:57,120
think about how the many-to-many query

00:36:54,330 --> 00:36:59,340
works it has to potentially suck up a

00:36:57,120 --> 00:37:01,530
whole huge ton of rows and go through

00:36:59,340 --> 00:37:03,570
these enormous indexes indexes are fast

00:37:01,530 --> 00:37:07,110
but they're not infinitely fast and so

00:37:03,570 --> 00:37:09,990
um if you now there's there are upper

00:37:07,110 --> 00:37:11,250
bounds I mean 1 billion row item indexes

00:37:09,990 --> 00:37:14,310
are not going to be any more fun than a

00:37:11,250 --> 00:37:15,630
billion Road table but potentially you

00:37:14,310 --> 00:37:17,400
could this could be a huge win

00:37:15,630 --> 00:37:18,600
especially if you're using a gin index

00:37:17,400 --> 00:37:21,510
because the wage index works very

00:37:18,600 --> 00:37:23,460
quickly is it indexes so if for example

00:37:21,510 --> 00:37:25,560
if you had key of for the Gini index

00:37:23,460 --> 00:37:28,740
record everything that has a 4 in it and

00:37:25,560 --> 00:37:30,930
can go pull those rows potentially much

00:37:28,740 --> 00:37:34,730
faster than running through a

00:37:30,930 --> 00:37:38,150
many-to-many table Thanks and smaller

00:37:34,730 --> 00:37:41,670
you mentioned that the new fields only

00:37:38,150 --> 00:37:43,290
will only work with JSON be what do you

00:37:41,670 --> 00:37:46,560
recommend in order if you want to use

00:37:43,290 --> 00:37:53,490
the plane JSON for those sort of dirty

00:37:46,560 --> 00:37:55,740
um evaluate your life choices um it's

00:37:53,490 --> 00:37:57,180
unfortunately the g the bill json type

00:37:55,740 --> 00:37:59,250
does not have a lot of that good stuff

00:37:57,180 --> 00:38:03,210
in it you can get some of it by writing

00:37:59,250 --> 00:38:05,100
if if you absolutely must you can get it

00:38:03,210 --> 00:38:07,830
you can write expression fields that

00:38:05,100 --> 00:38:09,420
extract the stuff out of the extract

00:38:07,830 --> 00:38:13,050
those fields out of the JSON type and

00:38:09,420 --> 00:38:14,700
index them as be tree things at some

00:38:13,050 --> 00:38:16,829
point though you're probably better off

00:38:14,700 --> 00:38:19,799
doing the JSON be unless you absolutely

00:38:16,829 --> 00:38:21,839
must have those two miss features sure

00:38:19,799 --> 00:38:23,339
well if querying isn't necessarily a

00:38:21,839 --> 00:38:27,390
goal and you just want to get access to

00:38:23,339 --> 00:38:28,950
it you like subtext or subclass like the

00:38:27,390 --> 00:38:32,249
unfilled and then make it at least

00:38:28,950 --> 00:38:35,279
accessible sort of did you do your own

00:38:32,249 --> 00:38:37,079
well in theory you could alter you

00:38:35,279 --> 00:38:39,959
create it and then alter the type back

00:38:37,079 --> 00:38:43,259
to JSON and probably everything will

00:38:39,959 --> 00:38:44,910
work just fine at that point I haven't

00:38:43,259 --> 00:38:47,339
tried it but it's it would certainly be

00:38:44,910 --> 00:38:48,690
worth a go you the other thing of course

00:38:47,339 --> 00:38:51,269
is if you want the performance

00:38:48,690 --> 00:38:53,249
enhancement the the these the small but

00:38:51,269 --> 00:38:55,170
not zero performance enhancement for on

00:38:53,249 --> 00:38:59,700
inserts that JSON has over JSON be

00:38:55,170 --> 00:39:01,709
absolutely yeah you're booking example

00:38:59,700 --> 00:39:03,329
it's really nifty I'm wondering a couple

00:39:01,709 --> 00:39:06,269
other things so it would be possible to

00:39:03,329 --> 00:39:09,180
create multiple conditions using the

00:39:06,269 --> 00:39:12,539
b-tree just extension if so how would

00:39:09,180 --> 00:39:15,719
you recommend acceptable handling um you

00:39:12,539 --> 00:39:18,599
could wait as in more than one predicate

00:39:15,719 --> 00:39:20,549
on the way uh not quite sure the

00:39:18,599 --> 00:39:22,729
question sorry so let's say that in

00:39:20,549 --> 00:39:26,309
addition to the date ranges you also

00:39:22,729 --> 00:39:30,660
didn't want certain types of rooms to be

00:39:26,309 --> 00:39:32,969
booked on yeah I mean yeah it could be

00:39:30,660 --> 00:39:35,309
essentially accident the only reason in

00:39:32,969 --> 00:39:37,769
that case I had to use the the b-tree

00:39:35,309 --> 00:39:39,989
just hack is because I because one of

00:39:37,769 --> 00:39:42,209
the thing one of the fields only has

00:39:39,989 --> 00:39:44,519
just indexing and the whole thing has to

00:39:42,209 --> 00:39:45,989
be thus it has to be at gist index but

00:39:44,519 --> 00:39:47,609
all the indexes that are that are

00:39:45,989 --> 00:39:49,109
apparent up here in the exclusion

00:39:47,609 --> 00:39:52,049
constraint have to be on the same type

00:39:49,109 --> 00:39:55,829
so that's why I had to force the int

00:39:52,049 --> 00:39:58,499
thus the string that was the room into

00:39:55,829 --> 00:40:00,569
it it for example every everything is a

00:39:58,499 --> 00:40:02,400
you can write exclusion constraints as

00:40:00,569 --> 00:40:04,829
any combination of bullying predicates

00:40:02,400 --> 00:40:06,959
sanded together okay so effectively

00:40:04,829 --> 00:40:08,549
there's no reason to have a situation

00:40:06,959 --> 00:40:10,799
where you could have multiple kinds of

00:40:08,549 --> 00:40:13,229
integrity errors that you'd have to you

00:40:10,799 --> 00:40:15,029
really get one it'll if you had you can

00:40:13,229 --> 00:40:16,680
have 12 different exclusion constraints

00:40:15,029 --> 00:40:18,420
on the same table there's absolutely no

00:40:16,680 --> 00:40:20,430
limit to how many you can have except

00:40:18,420 --> 00:40:21,959
that of course has to check them all on

00:40:20,430 --> 00:40:25,619
every insert which could be a little bit

00:40:21,959 --> 00:40:27,329
annoying so you only get one out it

00:40:25,619 --> 00:40:28,619
won't tell you oh by the way these 12

00:40:27,329 --> 00:40:30,540
different exclusion constraints are

00:40:28,619 --> 00:40:32,190
failed you'll it'll hit one and

00:40:30,540 --> 00:40:33,840
then stop the insert and you'll get that

00:40:32,190 --> 00:40:36,630
one in the jewelry when it comes to

00:40:33,840 --> 00:40:38,160
giving feedback to a user when there are

00:40:36,630 --> 00:40:39,690
certain kinds of integrity errors how

00:40:38,160 --> 00:40:42,030
would you recommend handling that that's

00:40:39,690 --> 00:40:46,050
that is a little more complicated in

00:40:42,030 --> 00:40:48,780
that case you may need to um I i would i

00:40:46,050 --> 00:40:50,340
would actually do both both query the

00:40:48,780 --> 00:40:52,680
database in advance to get the right

00:40:50,340 --> 00:40:54,780
kind of error back to the user but still

00:40:52,680 --> 00:40:56,250
have the constraint in case you need you

00:40:54,780 --> 00:40:58,740
have other applications that don't run

00:40:56,250 --> 00:41:00,270
through the same UI that are try to

00:40:58,740 --> 00:41:02,550
insert data you try and bulk load it

00:41:00,270 --> 00:41:04,530
from someplace else and you're using the

00:41:02,550 --> 00:41:06,330
copy command or something like that that

00:41:04,530 --> 00:41:07,980
way you know because you'll inevitably

00:41:06,330 --> 00:41:09,570
what will happen is like take the room

00:41:07,980 --> 00:41:11,700
example you know your hotels running

00:41:09,570 --> 00:41:13,830
fine and then hotels.com so comes in and

00:41:11,700 --> 00:41:17,640
says we'd love to send you reservations

00:41:13,830 --> 00:41:20,130
but we have this API and you know so

00:41:17,640 --> 00:41:21,690
that kind of thing I I'm sure room

00:41:20,130 --> 00:41:23,010
reservation systems are a tiny bit more

00:41:21,690 --> 00:41:29,220
complex than that example but you get

00:41:23,010 --> 00:41:32,010
the idea so do you have any insight into

00:41:29,220 --> 00:41:35,250
what might be coming in 19 and beyond

00:41:32,010 --> 00:41:37,680
with regards to postgres um well in um

00:41:35,250 --> 00:41:38,900
at this point 19 is pretty well locked

00:41:37,680 --> 00:41:41,430
down so you just read the release notes

00:41:38,900 --> 00:41:43,440
you know I I'm not a contributor to that

00:41:41,430 --> 00:41:44,910
stuff directly so that that would be the

00:41:43,440 --> 00:41:50,430
best thing I was a certain of your

00:41:44,910 --> 00:41:52,680
involvement oh yeah thanks for the great

00:41:50,430 --> 00:41:55,350
talk um how do you feel about the

00:41:52,680 --> 00:41:57,360
funding model of the contributions to

00:41:55,350 --> 00:41:58,380
django for the postgres stuff and are

00:41:57,360 --> 00:42:00,650
there any other things that you'd like

00:41:58,380 --> 00:42:05,010
to see funded in this in the way um

00:42:00,650 --> 00:42:06,390
that's probably probably a longer quest

00:42:05,010 --> 00:42:08,880
a bigger question that i can answer

00:42:06,390 --> 00:42:11,190
right here it is interesting to me that

00:42:08,880 --> 00:42:12,900
that i have very strong opinions that

00:42:11,190 --> 00:42:14,580
the companies that use open source

00:42:12,900 --> 00:42:19,470
should give a little more back than they

00:42:14,580 --> 00:42:21,720
do the there are certainly features i

00:42:19,470 --> 00:42:24,720
would love to see like being able to

00:42:21,720 --> 00:42:28,590
push different foreign key foreign key

00:42:24,720 --> 00:42:30,810
cascading models specify those from from

00:42:28,590 --> 00:42:33,690
the model level for example if you want

00:42:30,810 --> 00:42:35,250
to have something other than delete be

00:42:33,690 --> 00:42:36,960
able to specify that and have that

00:42:35,250 --> 00:42:40,560
implemented by the database rather than

00:42:36,960 --> 00:42:41,790
Django implementing it but yeah getting

00:42:40,560 --> 00:42:44,509
getting money for these kinds of

00:42:41,790 --> 00:42:47,130
extensions is an issue

00:42:44,509 --> 00:42:51,180
Kickstarter is great but it does tend to

00:42:47,130 --> 00:42:52,859
be a popularity contest and it locks out

00:42:51,180 --> 00:42:54,930
a lot of developers who wouldn't

00:42:52,859 --> 00:42:56,999
otherwise have you know who are

00:42:54,930 --> 00:42:58,319
brilliant programmers but have it worked

00:42:56,999 --> 00:43:03,660
as hard too but don't have the high

00:42:58,319 --> 00:43:04,950
profile and that's a shame I think so

00:43:03,660 --> 00:43:12,029
tell your employer to write big checks

00:43:04,950 --> 00:43:13,259
is my answer great and if you need

00:43:12,029 --> 00:43:18,380
anything done with your dough squares

00:43:13,259 --> 00:43:18,380

YouTube URL: https://www.youtube.com/watch?v=hiPWZai946k


