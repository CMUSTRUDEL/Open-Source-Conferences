Title: DjangoCon US 2015 - Beyond the basics with Elasticsearch by Honza Kral
Publication date: 2017-11-03
Playlist: DjangoCon US 2015
Description: 
	Beyond the basics with Elasticsearch

Elasticsearch has many use cases, some of them fairly obvious and widely used, like plain searching through documents or analytics. In this talk I would like to go through some of the more advanced scenarios we have seen in the wild. Some examples of what we will cover:

Trend detection - how you can use the aggregation framework to go beyond simple "counting" and make use of the full-text properties of Elasticsearch.
Percolator - percolator is reversed search and many people use it as such to drive alerts or "stored search" functionality for their website, let's look at how we can use it to detect languages, geo locations or drive live search.
If we end up with some time to spare we can explore some other ideas about how we can utilize the features of a search engine to drive non-trivial data analysis.
Captions: 
	00:00:15,500 --> 00:00:21,300
so hello and welcome thank you for

00:00:18,300 --> 00:00:23,130
having me here and the talk is beyond

00:00:21,300 --> 00:00:24,900
the basics with Asik search and it is

00:00:23,130 --> 00:00:27,420
essentially about all the use cases

00:00:24,900 --> 00:00:29,429
where you can use elastic search but

00:00:27,420 --> 00:00:32,309
might not be immediately obvious that

00:00:29,429 --> 00:00:34,079
that is something that you can do so

00:00:32,309 --> 00:00:37,410
we'll work through several of those and

00:00:34,079 --> 00:00:41,010
see how and why it is it is suited for

00:00:37,410 --> 00:00:42,930
for that particular scenario but before

00:00:41,010 --> 00:00:45,690
we go beyond the basics we need to talk

00:00:42,930 --> 00:00:48,719
about what are we going beyond so what

00:00:45,690 --> 00:00:51,270
is what is the base functionality of

00:00:48,719 --> 00:00:52,920
elastic search and how does how comes

00:00:51,270 --> 00:00:55,379
that we can do all these other things

00:00:52,920 --> 00:00:59,070
like where is it coming from well it's

00:00:55,379 --> 00:01:01,140
all coming from Search Search especially

00:00:59,070 --> 00:01:03,989
full-text search is the primary function

00:01:01,140 --> 00:01:06,750
of elastic search and search is not a

00:01:03,989 --> 00:01:11,369
new problem it's been around for awhile

00:01:06,750 --> 00:01:14,909
and it hasn't actually changed much the

00:01:11,369 --> 00:01:17,549
first essentially index over a book over

00:01:14,909 --> 00:01:20,220
some text has been created in 1230 and

00:01:17,549 --> 00:01:22,680
we still use the same data structures to

00:01:20,220 --> 00:01:24,600
this same day of course there's been

00:01:22,680 --> 00:01:27,080
plenty of improvements but the

00:01:24,600 --> 00:01:30,840
underlying infrastructure that the

00:01:27,080 --> 00:01:32,460
inverted index remains the same it is

00:01:30,840 --> 00:01:34,770
the index that you're familiar with if

00:01:32,460 --> 00:01:37,920
you've ever read any book which I hope

00:01:34,770 --> 00:01:40,259
that you have sincerely and this is how

00:01:37,920 --> 00:01:43,320
it looks you have the list of

00:01:40,259 --> 00:01:46,560
interesting words and then for each of

00:01:43,320 --> 00:01:48,180
these words you have a list in in the

00:01:46,560 --> 00:01:50,909
case of a book you would have a list of

00:01:48,180 --> 00:01:53,430
pages for us you would have a list of

00:01:50,909 --> 00:01:57,630
documents that actually contain this

00:01:53,430 --> 00:02:01,469
word and notice several things first of

00:01:57,630 --> 00:02:03,299
all the words are sorted of course it

00:02:01,469 --> 00:02:04,979
makes sense because you need to be able

00:02:03,299 --> 00:02:07,020
to find the word that you're looking for

00:02:04,979 --> 00:02:10,410
so you can go to the page that actually

00:02:07,020 --> 00:02:13,380
contains it and also the pages or the

00:02:10,410 --> 00:02:15,870
documents are sorted as well

00:02:13,380 --> 00:02:19,620
and this is not this is not accidental

00:02:15,870 --> 00:02:23,640
this is very important for us and we'll

00:02:19,620 --> 00:02:26,580
we'll see how and also when we're

00:02:23,640 --> 00:02:30,300
talking about a search using a computer

00:02:26,580 --> 00:02:33,030
there are other things involved in this

00:02:30,300 --> 00:02:36,060
data structure notably some statistics

00:02:33,030 --> 00:02:39,650
for example how many times is this word

00:02:36,060 --> 00:02:43,130
contained in this in this document or

00:02:39,650 --> 00:02:45,270
how what is the length of the list etc

00:02:43,130 --> 00:02:48,120
things that will be very important later

00:02:45,270 --> 00:02:50,520
on so when we have a data structure like

00:02:48,120 --> 00:02:52,530
this how does the search work well it's

00:02:50,520 --> 00:02:54,720
super simple if we're looking for a

00:02:52,530 --> 00:02:58,230
document that mentions both python and

00:02:54,720 --> 00:03:00,810
django we locate these two words and we

00:02:58,230 --> 00:03:03,960
get bagged the lists and now we just

00:03:00,810 --> 00:03:06,630
walk the lists and we merge them

00:03:03,960 --> 00:03:10,410
together so whenever we find a document

00:03:06,630 --> 00:03:14,040
that is present in both lists that is

00:03:10,410 --> 00:03:16,110
our result if we wanted to do something

00:03:14,040 --> 00:03:20,910
like a free search that we're looking

00:03:16,110 --> 00:03:24,480
only where python is immediately

00:03:20,910 --> 00:03:27,270
followed by the word word web all we

00:03:24,480 --> 00:03:29,100
have to do is add another information

00:03:27,270 --> 00:03:32,100
into the inverted index we just need

00:03:29,100 --> 00:03:34,890
offsets what is the position of this

00:03:32,100 --> 00:03:37,140
word in the document and then when we

00:03:34,890 --> 00:03:41,340
are going through the merging process we

00:03:37,140 --> 00:03:44,700
just say we care not only that the

00:03:41,340 --> 00:03:47,610
document is in both lists but the offset

00:03:44,700 --> 00:03:51,120
must be immediately following each other

00:03:47,610 --> 00:03:53,610
so Python would be on the position n and

00:03:51,120 --> 00:03:56,250
what would be on the position n plus 1

00:03:53,610 --> 00:03:59,130
so you can see that actually doing a

00:03:56,250 --> 00:04:00,750
first search is not any more expensive

00:03:59,130 --> 00:04:03,270
than doing a regular search you're like

00:04:00,750 --> 00:04:05,910
you're just adding one more comparison

00:04:03,270 --> 00:04:09,330
in numerical comparison at that so it is

00:04:05,910 --> 00:04:12,510
fairly efficient what else you can you

00:04:09,330 --> 00:04:15,030
can sort of imagine here is I can get

00:04:12,510 --> 00:04:17,270
the list of documents from anywhere it

00:04:15,030 --> 00:04:20,730
doesn't have to come from the same index

00:04:17,270 --> 00:04:22,680
so I have multiple indices I can have

00:04:20,730 --> 00:04:25,410
index on every single field in my

00:04:22,680 --> 00:04:26,670
document and I can use them all if I

00:04:25,410 --> 00:04:29,490
have one condition

00:04:26,670 --> 00:04:33,480
title one condition on the category and

00:04:29,490 --> 00:04:35,400
one on the body I will just carry those

00:04:33,480 --> 00:04:37,830
three inverted indices to get these

00:04:35,400 --> 00:04:40,980
posting lists is what they're called and

00:04:37,830 --> 00:04:42,750
merged merge them together so we don't

00:04:40,980 --> 00:04:44,820
have the limitation of many other data

00:04:42,750 --> 00:04:47,690
stores that we limit the number of

00:04:44,820 --> 00:04:51,660
indices you can use per query /

00:04:47,690 --> 00:04:53,970
collection and that will that is also

00:04:51,660 --> 00:04:57,590
something that we benefit greatly from

00:04:53,970 --> 00:05:01,500
is it's this this data structure and

00:04:57,590 --> 00:05:03,330
finally the last thing that you do when

00:05:01,500 --> 00:05:07,320
you when you do this merging when you

00:05:03,330 --> 00:05:09,720
find your match you quantify how good a

00:05:07,320 --> 00:05:13,290
match it is that is the primary

00:05:09,720 --> 00:05:17,070
difference between a search engine and

00:05:13,290 --> 00:05:20,760
and a database we not only tell you

00:05:17,070 --> 00:05:23,820
which documents matches your query but

00:05:20,760 --> 00:05:26,910
also how well does it match is it a good

00:05:23,820 --> 00:05:30,050
match or is it just me and we know that

00:05:26,910 --> 00:05:33,660
because we we have the information about

00:05:30,050 --> 00:05:36,180
the statistics so this is called

00:05:33,660 --> 00:05:42,420
relevancy we tell you how relevant the

00:05:36,180 --> 00:05:45,540
document is to your query so how is

00:05:42,420 --> 00:05:48,240
relevancy relevancy computed at the base

00:05:45,540 --> 00:05:54,330
of it there are two there are two

00:05:48,240 --> 00:05:58,350
numbers numbers that we go TF and IDF TF

00:05:54,330 --> 00:06:00,720
is term frequency it is just the number

00:05:58,350 --> 00:06:04,170
of occurrences of that word in the given

00:06:00,720 --> 00:06:07,350
document or in the given field so if I'm

00:06:04,170 --> 00:06:10,410
looking for Jengo in a document so how

00:06:07,350 --> 00:06:12,750
many times does this document contain

00:06:10,410 --> 00:06:16,260
the word Django is it there only once is

00:06:12,750 --> 00:06:18,060
there three times and obviously the

00:06:16,260 --> 00:06:22,560
higher the number the better the

00:06:18,060 --> 00:06:26,550
relevancy IDF is inverse document

00:06:22,560 --> 00:06:31,080
frequency which is just a fancy word of

00:06:26,550 --> 00:06:34,350
saying how common or rare this word is

00:06:31,080 --> 00:06:35,790
in your entire data set is this a word

00:06:34,350 --> 00:06:38,910
that is contained in every single

00:06:35,790 --> 00:06:40,000
document that you have or is this a way

00:06:38,910 --> 00:06:43,210
that is only

00:06:40,000 --> 00:06:47,260
a present in one percent of your

00:06:43,210 --> 00:06:48,970
documents and we can we can get this

00:06:47,260 --> 00:06:51,340
information right away from from the

00:06:48,970 --> 00:06:54,280
inverted index because that essentially

00:06:51,340 --> 00:06:57,160
the length of the list attached to the

00:06:54,280 --> 00:06:59,740
field compared to the number of

00:06:57,160 --> 00:07:01,990
documents that we have overall fairly

00:06:59,740 --> 00:07:04,300
easy to calculate and there's actually

00:07:01,990 --> 00:07:07,480
the exact formula if you if you're so

00:07:04,300 --> 00:07:10,690
inclined and this number has has the

00:07:07,480 --> 00:07:14,650
opposite effect the the more common the

00:07:10,690 --> 00:07:18,400
word is the less relevant this document

00:07:14,650 --> 00:07:21,900
is for for the result because if we find

00:07:18,400 --> 00:07:24,220
a word that is in every single document

00:07:21,900 --> 00:07:25,540
yeah who cares it's have in every single

00:07:24,220 --> 00:07:30,160
document of course we're going to find

00:07:25,540 --> 00:07:32,680
it that doesn't mean anything so this is

00:07:30,160 --> 00:07:35,350
sort of the base formula for anything

00:07:32,680 --> 00:07:38,500
that has to do with relevancy and it

00:07:35,350 --> 00:07:40,810
works very well for text now we've seen

00:07:38,500 --> 00:07:42,700
the library that does the indexing and

00:07:40,810 --> 00:07:45,910
the heavy lifting for a sixer ch add

00:07:42,700 --> 00:07:50,290
some some more stuff on top of it you

00:07:45,910 --> 00:07:53,500
can see the exact formula there and you

00:07:50,290 --> 00:07:57,070
can see in the middle that that's the

00:07:53,500 --> 00:07:59,250
tf-idf the big big summer what it adds

00:07:57,070 --> 00:08:01,680
on top of it is it takes into account

00:07:59,250 --> 00:08:05,290
for example the length of the field

00:08:01,680 --> 00:08:08,410
because if we find the word Jengo in the

00:08:05,290 --> 00:08:10,750
title versus in the body that also gives

00:08:08,410 --> 00:08:12,880
us different information right if we

00:08:10,750 --> 00:08:15,550
have a short field and we still find it

00:08:12,880 --> 00:08:19,000
there it's more relevant that it if we

00:08:15,550 --> 00:08:21,340
have a full text of the book and we find

00:08:19,000 --> 00:08:25,540
it there as well those are different

00:08:21,340 --> 00:08:28,360
different types of informations so it

00:08:25,540 --> 00:08:31,479
improves on the basic on the basic

00:08:28,360 --> 00:08:34,450
tf-idf formula but it's still it's still

00:08:31,479 --> 00:08:36,900
only relying on the statistics that had

00:08:34,450 --> 00:08:38,860
learned about your data set and

00:08:36,900 --> 00:08:41,589
sometimes you want to go a little

00:08:38,860 --> 00:08:45,520
further sometimes you have other

00:08:41,589 --> 00:08:47,890
information about your data so let's say

00:08:45,520 --> 00:08:49,930
imagine that you you have a QA QA

00:08:47,890 --> 00:08:53,050
website where people ask questions and

00:08:49,930 --> 00:08:53,779
and give that give answers let's call it

00:08:53,050 --> 00:08:57,980
like

00:08:53,779 --> 00:09:00,110
overflow I don't know and you you have

00:08:57,980 --> 00:09:02,509
the users raid to the questions and the

00:09:00,110 --> 00:09:05,389
answers this is a good question this is

00:09:02,509 --> 00:09:07,459
a good answer and that is an information

00:09:05,389 --> 00:09:12,249
that is that you want to take into

00:09:07,459 --> 00:09:14,809
account but you don't want to sort by it

00:09:12,249 --> 00:09:19,129
because that would completely destroy

00:09:14,809 --> 00:09:22,939
your relevancy so if you had one very

00:09:19,129 --> 00:09:25,699
high quality question that has many many

00:09:22,939 --> 00:09:27,290
words it will always be on top no matter

00:09:25,699 --> 00:09:30,110
what the what the people would search

00:09:27,290 --> 00:09:32,120
for that's not what you want you're

00:09:30,110 --> 00:09:35,059
going to take the relevancy and you want

00:09:32,120 --> 00:09:37,459
to take the popularity and combine those

00:09:35,059 --> 00:09:43,309
those numbers together to get something

00:09:37,459 --> 00:09:46,639
that you can then sort by so another use

00:09:43,309 --> 00:09:49,069
case would be I'm looking for a hotel or

00:09:46,639 --> 00:09:51,319
I'm looking for a conference for an

00:09:49,069 --> 00:09:54,319
event and I want it to be in this

00:09:51,319 --> 00:09:56,149
location I'm not strictly limited to

00:09:54,319 --> 00:10:00,410
that location but I would prefer it to

00:09:56,149 --> 00:10:03,079
be there or around this time so again we

00:10:00,410 --> 00:10:06,680
can take the numerical indicator the

00:10:03,079 --> 00:10:09,670
distance from our ideal and use that to

00:10:06,680 --> 00:10:12,889
and feed that into into the relevancy

00:10:09,670 --> 00:10:15,949
mechanism so this is the theory behind

00:10:12,889 --> 00:10:18,800
it and this is this is the practice this

00:10:15,949 --> 00:10:20,389
is how it actually looks this is a this

00:10:18,800 --> 00:10:22,009
is a fairly simple query in

00:10:20,389 --> 00:10:24,170
elasticsearch when we're looking for a

00:10:22,009 --> 00:10:26,899
hotel we're looking for a hotel that's

00:10:24,170 --> 00:10:29,629
called the grand hotel and we have

00:10:26,899 --> 00:10:32,689
several other criteria we would prefer

00:10:29,629 --> 00:10:34,610
to have a balcony we are not limiting

00:10:32,689 --> 00:10:38,480
ourselves to just hotels with balconies

00:10:34,610 --> 00:10:41,139
but if it does like we we want to add 2

00:10:38,480 --> 00:10:44,949
2 the score so we want to bump it up

00:10:41,139 --> 00:10:47,449
also we want it to be in central London

00:10:44,949 --> 00:10:50,240
and we want it to be within one

00:10:47,449 --> 00:10:54,230
kilometer of center of London well not

00:10:50,240 --> 00:10:58,550
centered Greenwich just you can identify

00:10:54,230 --> 00:11:00,290
by the 0 in the coordinates and we want

00:10:58,550 --> 00:11:03,980
it to be there we don't want to limit

00:11:00,290 --> 00:11:06,019
ourselves to two hotels that might be so

00:11:03,980 --> 00:11:07,080
good that they would get to the top even

00:11:06,019 --> 00:11:09,720
without fulfilling

00:11:07,080 --> 00:11:12,690
criteria so we say that we want to use

00:11:09,720 --> 00:11:15,390
the sort of the the Glaus function to

00:11:12,690 --> 00:11:19,110
calculate the score it's one of the one

00:11:15,390 --> 00:11:21,570
of the a sorry it's one of the shapes on

00:11:19,110 --> 00:11:24,600
on the image on the right that actually

00:11:21,570 --> 00:11:27,860
determines how fast the score drops once

00:11:24,600 --> 00:11:30,180
you get outside of your ideal zone and

00:11:27,860 --> 00:11:33,210
we also want to take into account the

00:11:30,180 --> 00:11:35,430
popularity of the hotel and then we want

00:11:33,210 --> 00:11:36,690
to add some random numbers so random

00:11:35,430 --> 00:11:39,990
numbers are always good they make

00:11:36,690 --> 00:11:41,490
everything so much better now in this

00:11:39,990 --> 00:11:43,380
case at the random numbers are there

00:11:41,490 --> 00:11:46,380
sort of two to shuffle the results a

00:11:43,380 --> 00:11:49,830
little bit around so that people have

00:11:46,380 --> 00:11:51,600
chance to discover new things because we

00:11:49,830 --> 00:11:53,040
actually took this from from a from a

00:11:51,600 --> 00:11:56,220
customer from a real example how their

00:11:53,040 --> 00:11:57,420
how they're doing it and they do have

00:11:56,220 --> 00:12:00,540
this random score there because

00:11:57,420 --> 00:12:03,360
otherwise they would have some some

00:12:00,540 --> 00:12:05,040
hotels or some some results that would

00:12:03,360 --> 00:12:07,710
never be hit because they would always

00:12:05,040 --> 00:12:11,040
be just just behind just behind the fold

00:12:07,710 --> 00:12:14,550
and also people would perceive the

00:12:11,040 --> 00:12:16,710
results of stale but if you if you if

00:12:14,550 --> 00:12:18,150
you shuffle it around a little bit they

00:12:16,710 --> 00:12:20,370
will always find something new and

00:12:18,150 --> 00:12:25,050
they'll always be excited and hopefully

00:12:20,370 --> 00:12:27,870
come back to your website so this is one

00:12:25,050 --> 00:12:30,570
of the ways how we use the statistics

00:12:27,870 --> 00:12:33,060
that the TF IDF and all the things that

00:12:30,570 --> 00:12:35,790
we know about your data this is the most

00:12:33,060 --> 00:12:38,250
straightforward way we use it to

00:12:35,790 --> 00:12:41,070
calculate relevancy and we allow you to

00:12:38,250 --> 00:12:44,490
hook into that process yourself if you

00:12:41,070 --> 00:12:46,650
are so inclined you can just remove all

00:12:44,490 --> 00:12:49,290
of this and just say hey instead of all

00:12:46,650 --> 00:12:52,380
these different criteria I just want to

00:12:49,290 --> 00:12:53,850
use a script and give it an expression

00:12:52,380 --> 00:12:59,690
in your favorite programming language

00:12:53,850 --> 00:13:02,370
whatever that is even even Python so and

00:12:59,690 --> 00:13:04,380
do do all these calculations yourself

00:13:02,370 --> 00:13:07,260
these are essentially just pre build

00:13:04,380 --> 00:13:09,060
scripts that we have we have built so

00:13:07,260 --> 00:13:10,740
that you can you can use it and you

00:13:09,060 --> 00:13:13,290
don't have to expose the scripting

00:13:10,740 --> 00:13:17,680
functionality because obviously that can

00:13:13,290 --> 00:13:19,440
have some that kind of some issues so

00:13:17,680 --> 00:13:23,020
this was this was the first use case

00:13:19,440 --> 00:13:26,279
sort of how to get more out of the out

00:13:23,020 --> 00:13:28,660
of the relevancy that we already have

00:13:26,279 --> 00:13:32,110
another interesting use case we have

00:13:28,660 --> 00:13:34,510
revolves around reversed search or how

00:13:32,110 --> 00:13:36,430
we call it the percolator and it is

00:13:34,510 --> 00:13:39,940
exactly what what it sounds like it is

00:13:36,430 --> 00:13:41,560
reverse search a normal world you index

00:13:39,940 --> 00:13:45,100
your documents and then you run your

00:13:41,560 --> 00:13:47,459
queries with percolator you index your

00:13:45,100 --> 00:13:53,470
queries and then you run your document

00:13:47,459 --> 00:13:57,670
so what is what is well this is useful

00:13:53,470 --> 00:13:58,930
for is for example alerting if you have

00:13:57,670 --> 00:14:02,110
something like stored search

00:13:58,930 --> 00:14:03,970
functionality on your website you have

00:14:02,110 --> 00:14:05,740
you have classifieds or something like

00:14:03,970 --> 00:14:09,610
that and you allow the users to search

00:14:05,740 --> 00:14:12,070
and then nothing shows up but the user

00:14:09,610 --> 00:14:14,470
wants to say hey I'm interested in this

00:14:12,070 --> 00:14:17,589
search like save it and whenever there

00:14:14,470 --> 00:14:19,959
is a new a new item new document that

00:14:17,589 --> 00:14:23,290
matches that search just just send me an

00:14:19,959 --> 00:14:25,029
email and I'll come back normally that's

00:14:23,290 --> 00:14:27,610
if that's a fairly hard problem with

00:14:25,029 --> 00:14:29,650
percolator it comes out of the box you

00:14:27,610 --> 00:14:31,900
index the query that there that they're

00:14:29,650 --> 00:14:34,029
running including all the bells and

00:14:31,900 --> 00:14:36,760
whistles that that elastic search allows

00:14:34,029 --> 00:14:39,279
you to do and then when a new document

00:14:36,760 --> 00:14:42,490
comes in you just ask for it to be

00:14:39,279 --> 00:14:43,570
percolated and you will get back all the

00:14:42,490 --> 00:14:46,510
different queries that people have

00:14:43,570 --> 00:14:49,589
registered that they want to be alerted

00:14:46,510 --> 00:14:52,540
on some people even use it to power

00:14:49,589 --> 00:14:54,279
something like live search if you've

00:14:52,540 --> 00:14:56,020
ever been on any website you're

00:14:54,279 --> 00:14:59,290
searching and suddenly there is a pop-up

00:14:56,020 --> 00:15:01,500
hey in the time that you're been looking

00:14:59,290 --> 00:15:03,810
at these results are ten new ones that

00:15:01,500 --> 00:15:06,610
again can be powered by the percolator

00:15:03,810 --> 00:15:08,910
when you do a search and at the same

00:15:06,610 --> 00:15:11,529
time you register the percolation and

00:15:08,910 --> 00:15:14,529
every single new document that comes in

00:15:11,529 --> 00:15:17,140
gets percolated as well and you will

00:15:14,529 --> 00:15:19,870
know which browser you need to push this

00:15:17,140 --> 00:15:24,130
document into who is who is actually

00:15:19,870 --> 00:15:25,329
looking at the results right now so

00:15:24,130 --> 00:15:27,759
those are the

00:15:25,329 --> 00:15:29,799
fairly obvious use cases I'll talk about

00:15:27,759 --> 00:15:33,220
my favorite one for percolated and that

00:15:29,799 --> 00:15:35,649
is classification because there is a

00:15:33,220 --> 00:15:38,410
bunch of stuff that's super easy to to

00:15:35,649 --> 00:15:41,230
search for but not that easy to do it

00:15:38,410 --> 00:15:44,470
the other way around for example

00:15:41,230 --> 00:15:46,829
geolocation it is fairly easy to

00:15:44,470 --> 00:15:51,399
construct a query that will look for

00:15:46,829 --> 00:15:53,379
events in in Austin you just have to

00:15:51,399 --> 00:15:55,179
have the shape of Austin somewhere you

00:15:53,379 --> 00:15:57,369
either pass it into the query but that's

00:15:55,179 --> 00:16:00,040
not optimal so typically you have an

00:15:57,369 --> 00:16:02,649
index somewhere in elasticsearch in my

00:16:00,040 --> 00:16:05,049
case I have an index called shapes where

00:16:02,649 --> 00:16:07,779
I have cities and i also have Austin

00:16:05,049 --> 00:16:09,759
there so I say hey I am interesting in

00:16:07,779 --> 00:16:12,939
anything that falls within the city of

00:16:09,759 --> 00:16:15,489
austin and that is a very simple query

00:16:12,939 --> 00:16:18,610
to run but what if i want to do the

00:16:15,489 --> 00:16:22,269
opposite I have a geo point I have a set

00:16:18,610 --> 00:16:25,410
of coordinates and I want to know where

00:16:22,269 --> 00:16:30,220
they are what city what's the address

00:16:25,410 --> 00:16:32,499
that's not that trivial unless you have

00:16:30,220 --> 00:16:34,720
something like this where you have a

00:16:32,499 --> 00:16:36,429
bunch of queries indexed in your elastic

00:16:34,720 --> 00:16:40,059
search and then you just show it a

00:16:36,429 --> 00:16:42,399
document with the with a giro point and

00:16:40,059 --> 00:16:44,619
it will tell you yeah these these

00:16:42,399 --> 00:16:46,619
queries matched the one representing

00:16:44,619 --> 00:16:49,059
North America the one representing

00:16:46,619 --> 00:16:52,480
United States the one representing Texas

00:16:49,059 --> 00:16:54,309
the one representing Austin maybe even

00:16:52,480 --> 00:16:55,449
the one representing a city block or

00:16:54,309 --> 00:16:58,360
something so you can really pinpoint

00:16:55,449 --> 00:17:00,339
down the exact address at that point in

00:16:58,360 --> 00:17:02,860
just a matter of how good data you have

00:17:00,339 --> 00:17:05,860
and how much CPU you want to burn on

00:17:02,860 --> 00:17:10,589
this but it gives you sort of the

00:17:05,860 --> 00:17:13,329
non-obvious reconstruction of the data

00:17:10,589 --> 00:17:16,750
another interesting one is language

00:17:13,329 --> 00:17:18,939
classification this operates on an

00:17:16,750 --> 00:17:20,589
assumption that every language and I've

00:17:18,939 --> 00:17:25,510
chosen polish because English would be

00:17:20,589 --> 00:17:28,750
way too way too weird every language has

00:17:25,510 --> 00:17:31,960
a few words that don't exist in any

00:17:28,750 --> 00:17:33,760
other language so the assumption is I

00:17:31,960 --> 00:17:36,399
can run a query that looks for these

00:17:33,760 --> 00:17:38,290
words in this case I'm I give it a list

00:17:36,399 --> 00:17:40,690
of words and I'm saying I want

00:17:38,290 --> 00:17:44,800
if at least four of those are in the

00:17:40,690 --> 00:17:46,150
document like I consider it a match so

00:17:44,800 --> 00:17:49,300
in this case I'm looking for documents

00:17:46,150 --> 00:17:51,310
that are written in Polish because

00:17:49,300 --> 00:17:54,630
nobody else no other language in the

00:17:51,310 --> 00:17:58,510
world would ever write a word like this

00:17:54,630 --> 00:18:01,390
so it's a fairly fairly good indicator

00:17:58,510 --> 00:18:02,710
so again very easy to write the query

00:18:01,390 --> 00:18:07,740
and once we have the query you can

00:18:02,710 --> 00:18:13,000
reverse the process and actually ask for

00:18:07,740 --> 00:18:15,520
ask for which queries matched so if I

00:18:13,000 --> 00:18:17,470
then have a document for an event so i

00:18:15,520 --> 00:18:19,240
have a jenga con us with some polish

00:18:17,470 --> 00:18:23,430
description because otherwise my demo

00:18:19,240 --> 00:18:36,520
would fall apart this is what I could

00:18:23,430 --> 00:18:40,120
hmm sorry about that this is what I get

00:18:36,520 --> 00:18:42,160
back I get back the identifier of all

00:18:40,120 --> 00:18:44,860
the queries that actually matched so I

00:18:42,160 --> 00:18:47,880
know that this is an event that is in

00:18:44,860 --> 00:18:51,550
the city of austin it is in polish and

00:18:47,880 --> 00:18:55,180
it is it it deals with the topic of

00:18:51,550 --> 00:18:56,530
Python please don't try to look where

00:18:55,180 --> 00:19:01,750
the coordinates are there are no where

00:18:56,530 --> 00:19:04,540
near Austin but so this is how you can

00:19:01,750 --> 00:19:06,790
use a percolator for classification you

00:19:04,540 --> 00:19:08,860
typically do this before you index your

00:19:06,790 --> 00:19:10,360
document you have your document you're

00:19:08,860 --> 00:19:12,490
about to index it so you run the

00:19:10,360 --> 00:19:14,380
percolation you get all the dynamic

00:19:12,490 --> 00:19:17,860
classifiers you get all the topics and

00:19:14,380 --> 00:19:19,840
all the language and the geolocation you

00:19:17,860 --> 00:19:22,000
put you add it to the document and then

00:19:19,840 --> 00:19:23,800
you index it so then when you're looking

00:19:22,000 --> 00:19:28,030
for something in the city of austin it's

00:19:23,800 --> 00:19:30,220
a super simple exact look up which will

00:19:28,030 --> 00:19:34,260
obviously be much faster than running

00:19:30,220 --> 00:19:37,570
the geo look up every single time and

00:19:34,260 --> 00:19:39,280
you can take the percolators a little

00:19:37,570 --> 00:19:41,440
bit further you can attach metadata to

00:19:39,280 --> 00:19:44,230
the percolation queries for example who

00:19:41,440 --> 00:19:46,510
requested this dis percolation is it a

00:19:44,230 --> 00:19:50,620
user that paid me or is it a user who

00:19:46,510 --> 00:19:52,330
can wait and and other either criteria

00:19:50,620 --> 00:19:56,179
like that

00:19:52,330 --> 00:19:57,919
you can also not run all the percolation

00:19:56,179 --> 00:20:01,820
every single time you can then use this

00:19:57,919 --> 00:20:05,210
metadata to filter those etc etc you can

00:20:01,820 --> 00:20:07,610
also use it to to highlight so if you

00:20:05,210 --> 00:20:09,710
want to highlight some passages but it

00:20:07,610 --> 00:20:11,270
that's that can be a fairly hard problem

00:20:09,710 --> 00:20:15,279
but it's a problem that search engines

00:20:11,270 --> 00:20:18,049
are really good at so you can ask ask

00:20:15,279 --> 00:20:21,260
elasticsearch to actually highlight some

00:20:18,049 --> 00:20:25,460
some passages for you and then index

00:20:21,260 --> 00:20:28,130
index they already highlighted text so

00:20:25,460 --> 00:20:29,870
this has been this has been a our

00:20:28,130 --> 00:20:34,520
journey into into the depth of the

00:20:29,870 --> 00:20:37,240
percolator and then there is one last

00:20:34,520 --> 00:20:41,149
big thing that I want to talk about and

00:20:37,240 --> 00:20:43,970
that's aggregations now many different

00:20:41,149 --> 00:20:46,250
many different databases have

00:20:43,970 --> 00:20:49,190
aggregations how come a search engine

00:20:46,250 --> 00:20:52,220
has 12 well it all started with

00:20:49,190 --> 00:20:53,990
something like this this is an interface

00:20:52,220 --> 00:20:56,360
you might be familiar with and it's

00:20:53,990 --> 00:20:58,909
called a faceted search or faceted

00:20:56,360 --> 00:21:01,159
navigation you type something in you get

00:20:58,909 --> 00:21:04,490
the results that you get the 10 blue

00:21:01,159 --> 00:21:07,429
links but you also get on the left side

00:21:04,490 --> 00:21:10,940
the overview the overview of what

00:21:07,429 --> 00:21:12,620
actually matched your query so in this

00:21:10,940 --> 00:21:15,320
case I'm looking for Django so I

00:21:12,620 --> 00:21:18,830
immediately can see that Django is

00:21:15,320 --> 00:21:20,450
mostly connected with Python and I can

00:21:18,830 --> 00:21:22,610
see how many repositories and how many

00:21:20,450 --> 00:21:25,149
users have actually matched my query and

00:21:22,610 --> 00:21:29,720
that is the huge difference between

00:21:25,149 --> 00:21:31,640
facets and and search search is great

00:21:29,720 --> 00:21:35,299
when you know what you're looking for if

00:21:31,640 --> 00:21:37,970
you know how to spell Django or how how

00:21:35,299 --> 00:21:41,390
it sounds or something like that the

00:21:37,970 --> 00:21:43,159
facets are great for exploration because

00:21:41,390 --> 00:21:46,490
you don't need to know you you look and

00:21:43,159 --> 00:21:48,460
you see it is one thing to do with with

00:21:46,490 --> 00:21:51,980
code the other thing is to do it with

00:21:48,460 --> 00:21:54,440
hotels or books or if if you've ever

00:21:51,980 --> 00:21:56,390
shopped on a website like Amazon like

00:21:54,440 --> 00:21:58,190
going see the categories you can see the

00:21:56,390 --> 00:22:00,740
brands you can see the price

00:21:58,190 --> 00:22:02,330
distribution and you can see it you

00:22:00,740 --> 00:22:05,020
don't have to read all the results to

00:22:02,330 --> 00:22:05,020
get that information

00:22:05,120 --> 00:22:10,070
so we have we have taken it one step

00:22:06,680 --> 00:22:12,650
further with elastic surge and we we

00:22:10,070 --> 00:22:17,110
power some analytics based on based on

00:22:12,650 --> 00:22:19,460
this stuff and we visualize it because

00:22:17,110 --> 00:22:21,770
humans are essentially pattern

00:22:19,460 --> 00:22:23,870
recognizing machines you're very good at

00:22:21,770 --> 00:22:26,960
recognizing patterns you can probably

00:22:23,870 --> 00:22:29,780
support several weird things about this

00:22:26,960 --> 00:22:32,630
picture like the gap in the in the

00:22:29,780 --> 00:22:34,880
timeline or the fact that the two Lance

00:22:32,630 --> 00:22:37,280
pie charts are completely different and

00:22:34,880 --> 00:22:39,620
you can see that immediately if you

00:22:37,280 --> 00:22:42,290
wanted a computer to see that you would

00:22:39,620 --> 00:22:45,740
have to tell it what to look for or have

00:22:42,290 --> 00:22:48,320
something very very sophisticated but

00:22:45,740 --> 00:22:51,710
any human can support this immediately

00:22:48,320 --> 00:22:54,200
so that is why why facets and

00:22:51,710 --> 00:22:57,559
aggregations become so important and why

00:22:54,200 --> 00:22:58,760
we continue to develop but this is

00:22:57,559 --> 00:23:02,960
boring stuff I don't want to talk about

00:22:58,760 --> 00:23:05,420
this this is just counting stuff any

00:23:02,960 --> 00:23:08,570
database can do that we can do better

00:23:05,420 --> 00:23:11,470
than that we're a search engine we

00:23:08,570 --> 00:23:13,850
understand your data and we can use it

00:23:11,470 --> 00:23:17,210
so let's see how we would actually use

00:23:13,850 --> 00:23:20,300
elastic surge and aggregations to do

00:23:17,210 --> 00:23:23,660
something like recommendations let's say

00:23:20,300 --> 00:23:25,700
that I have the music website and I have

00:23:23,660 --> 00:23:28,520
different users and then they like

00:23:25,700 --> 00:23:31,220
different artists so I have a document

00:23:28,520 --> 00:23:34,040
per user and there is a list in that

00:23:31,220 --> 00:23:38,780
document in that Jason that has all the

00:23:34,040 --> 00:23:40,520
old artists that the users alike so one

00:23:38,780 --> 00:23:43,250
sort of naive way how to do

00:23:40,520 --> 00:23:46,309
recommendations it's just ask for the

00:23:43,250 --> 00:23:48,910
aggregation just add give me look for

00:23:46,309 --> 00:23:52,670
people who like the same thing I do and

00:23:48,910 --> 00:23:55,520
then give me the top 10 popular artists

00:23:52,670 --> 00:23:59,600
in that group that I I've not been

00:23:55,520 --> 00:24:03,440
exposed to yet it's that's easy to write

00:23:59,600 --> 00:24:06,770
easy to run not as useful because

00:24:03,440 --> 00:24:08,720
popular doesn't mean relevant just

00:24:06,770 --> 00:24:11,390
because everybody listens to one

00:24:08,720 --> 00:24:15,049
direction doesn't mean it's relevant to

00:24:11,390 --> 00:24:17,409
my to my group so

00:24:15,049 --> 00:24:21,590
what can we do instead we need to find

00:24:17,409 --> 00:24:27,080
we need to identify the artists that are

00:24:21,590 --> 00:24:28,879
more relevant to my group to do to the

00:24:27,080 --> 00:24:31,100
group of people that like the same

00:24:28,879 --> 00:24:34,450
things that I do compared to the

00:24:31,100 --> 00:24:37,759
background so the code it looks looks

00:24:34,450 --> 00:24:40,429
remarkably different we replace the word

00:24:37,759 --> 00:24:46,100
terms with the word significant terms

00:24:40,429 --> 00:24:47,509
and that's all there is because now we

00:24:46,100 --> 00:24:50,659
are essentially telling elasticsearch

00:24:47,509 --> 00:24:52,789
hey we have we have this group we have

00:24:50,659 --> 00:24:57,049
defined it based on based on the results

00:24:52,789 --> 00:24:59,509
of the search and now give me the stuff

00:24:57,049 --> 00:25:02,749
that is more relevant for this group

00:24:59,509 --> 00:25:04,669
compared to all the others and we can do

00:25:02,749 --> 00:25:06,649
this we are the search guys we

00:25:04,669 --> 00:25:10,460
understand the data we have all the

00:25:06,649 --> 00:25:11,869
statistics we have all the numbers you

00:25:10,460 --> 00:25:13,669
can even see that the graphical

00:25:11,869 --> 00:25:18,109
representation of what's happening on

00:25:13,669 --> 00:25:22,249
the right side normally when you select

00:25:18,109 --> 00:25:23,749
sort of a random a random selection you

00:25:22,249 --> 00:25:25,879
would expect that there would be the

00:25:23,749 --> 00:25:28,580
same distribution of people who like

00:25:25,879 --> 00:25:30,919
something in that group compared to the

00:25:28,580 --> 00:25:33,739
general populace so you would expect all

00:25:30,919 --> 00:25:37,429
the data to be laid out on on the

00:25:33,739 --> 00:25:39,679
diagonal what this did what using the

00:25:37,429 --> 00:25:43,309
significant terms did it selected all

00:25:39,679 --> 00:25:45,739
the old values that are pretty much on

00:25:43,309 --> 00:25:49,220
the vertical which means that are much

00:25:45,739 --> 00:25:52,100
more liked in my group than they are in

00:25:49,220 --> 00:25:55,940
the general populace which is exactly

00:25:52,100 --> 00:25:59,299
what I was asking for I was asking for

00:25:55,940 --> 00:26:04,460
recommendation based on the people who

00:25:59,299 --> 00:26:08,539
are similar to me give me what I'm more

00:26:04,460 --> 00:26:10,460
likely to like using using the data

00:26:08,539 --> 00:26:13,970
using still using just the dumb

00:26:10,460 --> 00:26:16,639
statistics about the distribution of the

00:26:13,970 --> 00:26:20,419
individual values throughout the data

00:26:16,639 --> 00:26:22,190
set so no learning was involved this is

00:26:20,419 --> 00:26:24,019
actually a fairly simple aggregation

00:26:22,190 --> 00:26:26,929
that you can that you can run you can

00:26:24,019 --> 00:26:28,669
see the code is not that expensive not

00:26:26,929 --> 00:26:32,450
that expensive to write

00:26:28,669 --> 00:26:35,600
it's not that involved but this still

00:26:32,450 --> 00:26:37,879
has some problems this is an aggregation

00:26:35,600 --> 00:26:39,919
we've had for a while we've noticed that

00:26:37,879 --> 00:26:44,559
there are some cases where it doesn't

00:26:39,919 --> 00:26:49,369
work as well as we would like it to and

00:26:44,559 --> 00:26:51,710
that the one problem is the the terms

00:26:49,369 --> 00:26:54,559
that everybody likes the term that

00:26:51,710 --> 00:26:56,419
everybody has so one direction is my

00:26:54,559 --> 00:26:59,119
go-to example of this because you know

00:26:56,419 --> 00:27:03,799
everybody likes them especially around

00:26:59,119 --> 00:27:06,859
Django cons and so what do ye what do i

00:27:03,799 --> 00:27:09,980
do there how do I make sure that I don't

00:27:06,859 --> 00:27:12,080
suffer from from the bias that every

00:27:09,980 --> 00:27:15,169
single document i have actually likes

00:27:12,080 --> 00:27:16,879
this well a lot of it is already

00:27:15,169 --> 00:27:20,269
filtered out by the significant terms

00:27:16,879 --> 00:27:24,679
but i can actually do much better i can

00:27:20,269 --> 00:27:27,859
also ask for a sample of the of the

00:27:24,679 --> 00:27:31,429
document so i will not do this analysis

00:27:27,859 --> 00:27:34,369
on all the users that have something in

00:27:31,429 --> 00:27:38,320
something in common with me but only

00:27:34,369 --> 00:27:41,480
those that are the most relevant so I

00:27:38,320 --> 00:27:45,249
included relevancy right now at least

00:27:41,480 --> 00:27:48,619
twice in a in my query that I'm running

00:27:45,249 --> 00:27:52,639
first of all I'm looking for users that

00:27:48,619 --> 00:27:54,649
are most similar to me and most similar

00:27:52,639 --> 00:27:59,119
means they have the highest relevancy to

00:27:54,649 --> 00:28:03,039
to my query because let's repeat the the

00:27:59,119 --> 00:28:06,200
relevancy is based on tf-idf norms etc

00:28:03,039 --> 00:28:08,480
so what does this translate to TF team

00:28:06,200 --> 00:28:12,859
term frequency it immediately translates

00:28:08,480 --> 00:28:16,309
to people who likes more things who have

00:28:12,859 --> 00:28:18,590
more things in common with me i D F

00:28:16,309 --> 00:28:23,090
inverse document frequency it means that

00:28:18,590 --> 00:28:25,639
people who prefer the the rarer choices

00:28:23,090 --> 00:28:30,109
that I have I preferred the people who

00:28:25,639 --> 00:28:32,720
have like the same thing with me that

00:28:30,109 --> 00:28:34,909
are rare I will ignore the one

00:28:32,720 --> 00:28:37,700
direction's because that doesn't bring

00:28:34,909 --> 00:28:40,580
me anything but I will actually hang on

00:28:37,700 --> 00:28:42,310
to to the weird groups that nobody else

00:28:40,580 --> 00:28:47,150
in the world knows about

00:28:42,310 --> 00:28:48,740
and then uh norms this stuff that

00:28:47,150 --> 00:28:50,540
leucine ads on top of it when it takes

00:28:48,740 --> 00:28:53,230
into account the length of the field I

00:28:50,540 --> 00:28:56,210
will prefer people with shorter lists

00:28:53,230 --> 00:29:00,050
that means that people who like pretty

00:28:56,210 --> 00:29:02,630
much exactly what I like so not people

00:29:00,050 --> 00:29:06,080
who like everything in the world because

00:29:02,630 --> 00:29:10,610
that will not be relevant not be that

00:29:06,080 --> 00:29:12,500
relevant so i can use directly the tools

00:29:10,610 --> 00:29:16,130
that we've build in the beginning of the

00:29:12,500 --> 00:29:20,120
talk for text matching and i can use the

00:29:16,130 --> 00:29:22,330
same numbers the same formulas to get

00:29:20,120 --> 00:29:27,890
the people who are most similar to me

00:29:22,330 --> 00:29:30,170
and then I say and take like five top

00:29:27,890 --> 00:29:32,450
five hundred of those like uh never

00:29:30,170 --> 00:29:34,520
shard because alex hirsch is distributed

00:29:32,450 --> 00:29:37,450
so everything happens on a shard level

00:29:34,520 --> 00:29:40,060
and and then run the significant terms

00:29:37,450 --> 00:29:43,610
tell me what is specific for that group

00:29:40,060 --> 00:29:46,360
so we've refined the selection not

00:29:43,610 --> 00:29:49,850
anybody who has anything to do with me

00:29:46,360 --> 00:29:52,400
but the most relevant people the most

00:29:49,850 --> 00:29:55,130
similar people and then give me what is

00:29:52,400 --> 00:29:59,330
specific for that group so this is the

00:29:55,130 --> 00:30:02,030
sampler aggregation it is currently

00:29:59,330 --> 00:30:04,790
currently in the newest releases of

00:30:02,030 --> 00:30:08,600
elastic search being ready to release

00:30:04,790 --> 00:30:11,090
and these two together allow me to drop

00:30:08,600 --> 00:30:12,740
to do the recommendations and have it be

00:30:11,090 --> 00:30:14,510
more relevant and also have it be faster

00:30:12,740 --> 00:30:17,450
because we are actually looking at the

00:30:14,510 --> 00:30:19,010
subset of the data we have just used all

00:30:17,450 --> 00:30:21,130
the information that we have about the

00:30:19,010 --> 00:30:25,550
data to identify the most relevant part

00:30:21,130 --> 00:30:31,640
so we don't lose any precision quite on

00:30:25,550 --> 00:30:34,310
the contrary so sort of to to generalize

00:30:31,640 --> 00:30:39,290
what we've done here is in a connected

00:30:34,310 --> 00:30:41,240
graph when we have people and artists

00:30:39,290 --> 00:30:44,780
and they like each other we have

00:30:41,240 --> 00:30:48,590
identified the connections that are

00:30:44,780 --> 00:30:52,430
meaningful not the ones that are most

00:30:48,590 --> 00:30:55,399
popular or most common or we've managed

00:30:52,430 --> 00:30:56,839
to hopefully circumvent

00:30:55,399 --> 00:30:58,759
sort of the super nodes the super

00:30:56,839 --> 00:31:02,719
connected nodes that are that are the

00:30:58,759 --> 00:31:05,469
hubs of any of the any of the graphs and

00:31:02,719 --> 00:31:09,679
we can use this and go further with it

00:31:05,469 --> 00:31:13,399
we can actually use this in in a graph

00:31:09,679 --> 00:31:15,710
algorithm so imagine that you have an

00:31:13,399 --> 00:31:18,589
algorithm that's used to calculate the

00:31:15,710 --> 00:31:22,039
shortest path so you want to go from

00:31:18,589 --> 00:31:24,739
point A to point B or in our case let's

00:31:22,039 --> 00:31:27,799
model it on on Wikipedia you want to go

00:31:24,739 --> 00:31:29,589
from a page a two-page be and you want

00:31:27,799 --> 00:31:33,679
to see what are what are the connections

00:31:29,589 --> 00:31:37,249
how do you get from one point to another

00:31:33,679 --> 00:31:39,919
and still only take into account the

00:31:37,249 --> 00:31:44,059
relevant connections because if you just

00:31:39,919 --> 00:31:46,339
use an naive graph algorithm you will

00:31:44,059 --> 00:31:48,919
you will fall victim to to the super

00:31:46,339 --> 00:31:51,919
nodes like you will you will see that

00:31:48,919 --> 00:31:54,529
hey beetles have concerted in the USA

00:31:51,919 --> 00:31:56,389
and so has pretty much every other band

00:31:54,529 --> 00:31:59,929
so there's an immediate connection there

00:31:56,389 --> 00:32:01,279
and that is not relevant at all and I

00:31:59,929 --> 00:32:04,639
don't mean to insult your country but

00:32:01,279 --> 00:32:07,849
that's just not relevant connection so

00:32:04,639 --> 00:32:10,099
when you when you use this approach to

00:32:07,849 --> 00:32:13,039
identify only those connections that are

00:32:10,099 --> 00:32:15,919
relevant that are not just an accidents

00:32:13,039 --> 00:32:20,359
based on statistics that everybody has

00:32:15,919 --> 00:32:22,690
that connection then you can get much

00:32:20,359 --> 00:32:29,440
more interesting information out of this

00:32:22,690 --> 00:32:34,509
so you can actually use this to to find

00:32:29,440 --> 00:32:37,999
meaningful connections after all

00:32:34,509 --> 00:32:40,759
aggregation and relevancy that is how we

00:32:37,999 --> 00:32:43,339
look in the world I by said and I said

00:32:40,759 --> 00:32:47,509
earlier that we are a pattern

00:32:43,339 --> 00:32:49,279
recognizing machines we look at we look

00:32:47,509 --> 00:32:52,129
at things and we immediately make

00:32:49,279 --> 00:32:54,619
assumptions like hey this room is not as

00:32:52,129 --> 00:32:56,539
full as it was in last doc yeah that

00:32:54,619 --> 00:32:59,649
makes sense like elasticsearch is not as

00:32:56,539 --> 00:33:02,109
relevant as postgres I I get it I i do

00:32:59,649 --> 00:33:04,820
and i can see that immediately and

00:33:02,109 --> 00:33:06,409
because i have the context because i can

00:33:04,820 --> 00:33:09,140
because i can see I don't have to count

00:33:06,409 --> 00:33:10,910
all the chairs to know that

00:33:09,140 --> 00:33:14,360
that's that is the aggregation part and

00:33:10,910 --> 00:33:16,460
the relevancy part is if I ask you what

00:33:14,360 --> 00:33:21,290
is the most popular website the website

00:33:16,460 --> 00:33:22,940
that you visit most often many people

00:33:21,290 --> 00:33:24,170
when I have actually asked this at

00:33:22,940 --> 00:33:26,960
conferences they'll tell me something

00:33:24,170 --> 00:33:30,940
like github or stack overflow or

00:33:26,960 --> 00:33:33,020
something and that is actually not true

00:33:30,940 --> 00:33:34,940
they probably spend more time on

00:33:33,020 --> 00:33:36,920
Facebook or Google or something like

00:33:34,940 --> 00:33:39,500
that and it's not that they're ashamed

00:33:36,920 --> 00:33:41,210
even though they might be too it's they

00:33:39,500 --> 00:33:43,280
immediately recognize that that is not a

00:33:41,210 --> 00:33:46,400
relevant answer that's not interesting

00:33:43,280 --> 00:33:47,690
everybody goes to google like I'm not

00:33:46,400 --> 00:33:50,210
interested in that information

00:33:47,690 --> 00:33:52,430
whatsoever I know that you know that

00:33:50,210 --> 00:33:54,770
let's skip to the interesting part get

00:33:52,430 --> 00:33:58,190
up that is more relevant to our group

00:33:54,770 --> 00:34:01,220
then to the general public if I ask on

00:33:58,190 --> 00:34:02,630
the street what github is like hopefully

00:34:01,220 --> 00:34:06,080
i won't get punched but i don't know

00:34:02,630 --> 00:34:09,800
that but that i will definitely not get

00:34:06,080 --> 00:34:13,610
the correct answer so we do the exact

00:34:09,800 --> 00:34:16,429
same thing that is what what is special

00:34:13,610 --> 00:34:19,669
about humans compared to compared to

00:34:16,429 --> 00:34:24,080
computers so I have a I have a question

00:34:19,669 --> 00:34:27,679
for you if I do an aggregation poor time

00:34:24,080 --> 00:34:31,100
period and then I asked for significant

00:34:27,679 --> 00:34:34,210
terms on the tags or anything what do

00:34:31,100 --> 00:34:40,760
what do I get back how do we call that

00:34:34,210 --> 00:34:43,970
anybody's willing to guess we get the

00:34:40,760 --> 00:34:45,890
trending information what's trending not

00:34:43,970 --> 00:34:48,470
what is the most popular for that given

00:34:45,890 --> 00:34:50,030
time period but what is more specific

00:34:48,470 --> 00:34:52,429
for the time period compared to any

00:34:50,030 --> 00:34:54,590
others so if we only filter the last

00:34:52,429 --> 00:34:56,960
five minutes and we ask for significant

00:34:54,590 --> 00:34:59,840
terms we get what is currently trending

00:34:56,960 --> 00:35:03,950
what are people talking more often right

00:34:59,840 --> 00:35:08,420
now then in general than any any other

00:35:03,950 --> 00:35:11,270
time so something that might appear as

00:35:08,420 --> 00:35:13,490
as sophisticated algorithm we can

00:35:11,270 --> 00:35:18,020
replicate it with two lines with the

00:35:13,490 --> 00:35:21,290
single query to elasticsearch so this

00:35:18,020 --> 00:35:22,850
will this will this is a nice nice sort

00:35:21,290 --> 00:35:24,710
of shortcut if you just want to

00:35:22,850 --> 00:35:27,320
throw something out there and you don't

00:35:24,710 --> 00:35:28,880
want to spend spend billions trying to

00:35:27,320 --> 00:35:33,920
come up with your own algorithm like

00:35:28,880 --> 00:35:36,140
this is exactly what it is so I so

00:35:33,920 --> 00:35:38,870
there's only one other pitfall that I'll

00:35:36,140 --> 00:35:42,680
warn you about if you try to play with

00:35:38,870 --> 00:35:45,500
this the way aggregations work in

00:35:42,680 --> 00:35:49,010
elastic search is we take all the

00:35:45,500 --> 00:35:52,580
possible combinations that might come up

00:35:49,010 --> 00:35:56,840
and we create a bucket for them a

00:35:52,580 --> 00:35:59,540
placeholder and that can blow up very

00:35:56,840 --> 00:36:02,660
fast for example if you if you if you

00:35:59,540 --> 00:36:05,990
have a data set from IMDb and you're

00:36:02,660 --> 00:36:09,440
looking for all four actors who acted

00:36:05,990 --> 00:36:11,930
together most often if you just run this

00:36:09,440 --> 00:36:16,640
naively it will work and the query is

00:36:11,930 --> 00:36:19,130
super simple but the query will also

00:36:16,640 --> 00:36:23,240
blow up your memory like crazy because

00:36:19,130 --> 00:36:26,750
it will essentially do do Cartesian

00:36:23,240 --> 00:36:29,120
product of actors versus actors so it

00:36:26,750 --> 00:36:31,130
will be a huge essentially table a huge

00:36:29,120 --> 00:36:35,630
data structure that we need to then fill

00:36:31,130 --> 00:36:37,940
out what we can do however is we could

00:36:35,630 --> 00:36:41,870
limit one of the dimensions before we

00:36:37,940 --> 00:36:44,410
get into it so by default we will try to

00:36:41,870 --> 00:36:48,020
do everything in one pass over the data

00:36:44,410 --> 00:36:51,530
because it's the most effective way and

00:36:48,020 --> 00:36:53,090
because we we are distributed

00:36:51,530 --> 00:36:55,790
distributor database so we need that

00:36:53,090 --> 00:36:57,830
sort of for us to function but in this

00:36:55,790 --> 00:36:59,600
case if you really insist if you know

00:36:57,830 --> 00:37:03,890
that this will blow up your memory or

00:36:59,600 --> 00:37:08,120
because you've tried or because because

00:37:03,890 --> 00:37:11,990
you you can count what you can do is you

00:37:08,120 --> 00:37:15,740
can say do it do it another way do a

00:37:11,990 --> 00:37:19,520
breadth-first search so first identify

00:37:15,740 --> 00:37:24,310
the top 10 actors and then only find the

00:37:19,520 --> 00:37:27,910
co-actors of those 10 so just simply

00:37:24,310 --> 00:37:30,500
identify like what is the what is the

00:37:27,910 --> 00:37:33,170
dimension that you can limit most

00:37:30,500 --> 00:37:35,270
effectively and do that and then then

00:37:33,170 --> 00:37:36,980
you'll be fine then you can actually ask

00:37:35,270 --> 00:37:40,609
for all the information in the world

00:37:36,980 --> 00:37:44,090
and we will give you a tiny tiny tiny

00:37:40,609 --> 00:37:46,550
little sliver of that so remember

00:37:44,090 --> 00:37:49,090
information is power we have the

00:37:46,550 --> 00:37:52,280
information we have information about

00:37:49,090 --> 00:37:55,190
your data and we can we can use them

00:37:52,280 --> 00:37:58,580
that is the one leg up that we as a

00:37:55,190 --> 00:38:00,320
search engine have over that the more

00:37:58,580 --> 00:38:03,400
traditional data source were limited to

00:38:00,320 --> 00:38:08,119
to the boring kind of stuff filtering

00:38:03,400 --> 00:38:11,390
counting stuff it can be useful but it's

00:38:08,119 --> 00:38:14,240
not exciting if you want exciting use

00:38:11,390 --> 00:38:22,670
elastic search thank you very much if

00:38:14,240 --> 00:38:24,440
you have any questions so we have five

00:38:22,670 --> 00:38:26,500
minutes for questions if anyone has any

00:38:24,440 --> 00:38:26,500
questions

00:38:33,530 --> 00:38:41,180
oh yeah great presentation question

00:38:39,050 --> 00:38:42,530
about language detection have you tried

00:38:41,180 --> 00:38:44,660
to use language section within

00:38:42,530 --> 00:38:48,380
elasticsearch in a production

00:38:44,660 --> 00:38:50,150
environment no so what what I typically

00:38:48,380 --> 00:38:53,930
recommend when people deal with multiple

00:38:50,150 --> 00:38:56,420
languages is just use everything at the

00:38:53,930 --> 00:38:59,180
same time the problem with language

00:38:56,420 --> 00:39:00,940
detection typically is that even if you

00:38:59,180 --> 00:39:03,080
can detect the language of the source

00:39:00,940 --> 00:39:04,340
you will have enough information to go

00:39:03,080 --> 00:39:06,170
on there and you can do it you can

00:39:04,340 --> 00:39:08,300
identify the language of the document

00:39:06,170 --> 00:39:10,610
it's very hard to identify the language

00:39:08,300 --> 00:39:13,010
of the query because if somebody just

00:39:10,610 --> 00:39:15,020
types in two words it's very hard to say

00:39:13,010 --> 00:39:17,660
what language they are so what I

00:39:15,020 --> 00:39:18,620
typically recommend people is if you

00:39:17,660 --> 00:39:21,380
know that you're going to be dealing

00:39:18,620 --> 00:39:24,620
with these five languages analyze

00:39:21,380 --> 00:39:27,350
everything five ways analyze it as

00:39:24,620 --> 00:39:30,620
English as as check as German as

00:39:27,350 --> 00:39:33,200
Japanese and then do the same for the

00:39:30,620 --> 00:39:36,020
query when a query comes in cry all of

00:39:33,200 --> 00:39:37,850
these fields at once and asik search has

00:39:36,020 --> 00:39:40,010
tools to allow you that you can specify

00:39:37,850 --> 00:39:42,350
that I have this one field but I want to

00:39:40,010 --> 00:39:44,180
analyze multiple ways and then i have

00:39:42,350 --> 00:39:47,230
this query and i want to run it against

00:39:44,180 --> 00:39:49,190
all these differently analyzed fields so

00:39:47,230 --> 00:39:51,500
it's what I call the shotgun approach

00:39:49,190 --> 00:39:53,690
just throw everything in there and see

00:39:51,500 --> 00:39:56,090
what sticks because of how the relevancy

00:39:53,690 --> 00:39:57,790
works and how different relevance ease

00:39:56,090 --> 00:40:01,160
from different queries are combined

00:39:57,790 --> 00:40:02,630
without trying so hard to actually think

00:40:01,160 --> 00:40:05,000
about the problem you will actually get

00:40:02,630 --> 00:40:09,890
the most relevant results so make sense

00:40:05,000 --> 00:40:12,980
I may have missed it but is the victor

00:40:09,890 --> 00:40:14,690
space models still a common way of

00:40:12,980 --> 00:40:16,010
combining information from different

00:40:14,690 --> 00:40:19,310
query terms or are there more

00:40:16,010 --> 00:40:22,220
sophisticated it's still it's still the

00:40:19,310 --> 00:40:24,620
same same thing if I talk about TF TF

00:40:22,220 --> 00:40:26,750
IDF and everything but that's only to

00:40:24,620 --> 00:40:29,150
give weight to the individual parts of

00:40:26,750 --> 00:40:30,820
the vector but overall it's still it's

00:40:29,150 --> 00:40:34,520
still essentially we're talking about

00:40:30,820 --> 00:40:36,740
vector matrix and vector distance by

00:40:34,520 --> 00:40:42,160
default essentially what what i showed

00:40:36,740 --> 00:40:45,080
the the formula that's actually cosine a

00:40:42,160 --> 00:40:46,700
metric pretty much like there are some

00:40:45,080 --> 00:40:47,300
modifications and stuff but yes it's

00:40:46,700 --> 00:40:49,070
still

00:40:47,300 --> 00:40:51,760
based on based on that thank you very

00:40:49,070 --> 00:40:51,760

YouTube URL: https://www.youtube.com/watch?v=RAJiFK1bHO0


