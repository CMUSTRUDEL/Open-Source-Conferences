Title: DjangoCon US 2015 - Intro to Mocking: Why Unit Testing Doesn't Have To Be So Hard by Daniel Davis
Publication date: 2017-11-03
Playlist: DjangoCon US 2015
Description: 
	Intro to Mocking: Why Unit Testing Doesn't Have To Be So Hard by Daniel Davis

Many developers want to write better code, but simply don't know how to write units tests for:

Code that calls other code (i.e. code with dependencies)
Methods that have no return value
Code that throws exceptions
Mocking provides a valuable tool for solving these problems. In this talk, we'll discuss the scenarios in which Mocking is useful, the strategies for addressing each of the cases above and write simple, clean unit tests using the built-in Mock library.

Help us caption & translate this video!

http://amara.org/v/HH6d/
Captions: 
	00:00:15,650 --> 00:00:21,090
all right dinner mocking why you missing

00:00:19,260 --> 00:00:23,910
doesn't have to be so hard I am Daniel

00:00:21,090 --> 00:00:25,109
Davis a little bit about me I have Anna

00:00:23,910 --> 00:00:28,500
software developer for about eight years

00:00:25,109 --> 00:00:31,320
now I am a senior consultant at Excel a

00:00:28,500 --> 00:00:33,690
consulting in Washington DC and fun fact

00:00:31,320 --> 00:00:35,160
about myself I recently well not

00:00:33,690 --> 00:00:37,050
recently in December I ran the

00:00:35,160 --> 00:00:39,210
gingerbread jingle all the way 5k

00:00:37,050 --> 00:00:40,950
dresses a giant gingerbread man if you

00:00:39,210 --> 00:00:44,040
want to see what that looks like this is

00:00:40,950 --> 00:00:45,899
a candid picture of that it was awesome

00:00:44,040 --> 00:00:47,670
I have some recommendations on things

00:00:45,899 --> 00:00:51,570
you should not wear when running a race

00:00:47,670 --> 00:00:53,460
felt is one of them so all right

00:00:51,570 --> 00:00:55,440
let's do a quick survey who here in the

00:00:53,460 --> 00:00:56,760
room has ever been frustrated by an

00:00:55,440 --> 00:00:59,579
experience writing a unit test show

00:00:56,760 --> 00:01:00,719
pants yeah everybody in this room here

00:00:59,579 --> 00:01:02,760
myself included

00:01:00,719 --> 00:01:05,700
thank you all for raising your hands I

00:01:02,760 --> 00:01:07,140
think I came to this with the same sort

00:01:05,700 --> 00:01:09,180
of problem you guys have had I sort of

00:01:07,140 --> 00:01:11,369
struggled to write unit tests for so

00:01:09,180 --> 00:01:13,170
many years it was very very frustrating

00:01:11,369 --> 00:01:15,450
and hard until I finally learned about

00:01:13,170 --> 00:01:17,460
mocking and sort of that made the lights

00:01:15,450 --> 00:01:19,110
you know the light bulb go off in my

00:01:17,460 --> 00:01:21,840
head everything sort of clicked I think

00:01:19,110 --> 00:01:24,960
I have a rendering of that that was sort

00:01:21,840 --> 00:01:26,729
of how it felt for me but my point is

00:01:24,960 --> 00:01:29,670
this I think a lot of us here in the

00:01:26,729 --> 00:01:31,560
room are in the same boat we all kind of

00:01:29,670 --> 00:01:33,090
want to write better and unit tests and

00:01:31,560 --> 00:01:34,409
you know I've talked with a lot of

00:01:33,090 --> 00:01:35,579
people here and they say I really wish

00:01:34,409 --> 00:01:37,560
somebody would sit down and write a

00:01:35,579 --> 00:01:39,810
presentation on this stuff and like just

00:01:37,560 --> 00:01:41,579
tell me what I need to know so I wrote

00:01:39,810 --> 00:01:42,810
this with that in mind and if that

00:01:41,579 --> 00:01:46,290
happens to be you in your particular

00:01:42,810 --> 00:01:49,040
situation hopefully this helps you so

00:01:46,290 --> 00:01:51,090
let's talk about unit tests all right

00:01:49,040 --> 00:01:52,710
hopefully you've seen this at some point

00:01:51,090 --> 00:01:54,960
in time if not this is martin fowler's

00:01:52,710 --> 00:01:56,520
pyramid of testing the idea is that he

00:01:54,960 --> 00:01:58,500
tries to quantify how much of our

00:01:56,520 --> 00:02:00,180
testing should be unit tests versus

00:01:58,500 --> 00:02:02,070
integration tests versus like UI or

00:02:00,180 --> 00:02:04,469
manual testing that sort of thing

00:02:02,070 --> 00:02:06,240
obviously the significant majority of it

00:02:04,469 --> 00:02:08,099
is unit testing which is kind of ironic

00:02:06,240 --> 00:02:09,509
because many of us are really bad at

00:02:08,099 --> 00:02:11,670
unit testing and we don't write lots of

00:02:09,509 --> 00:02:12,810
unit tests like we should when I ask

00:02:11,670 --> 00:02:14,040
people about this stuff

00:02:12,810 --> 00:02:15,870
I get all kind

00:02:14,040 --> 00:02:18,120
of stories about why they shouldn't for

00:02:15,870 --> 00:02:19,590
example they tell me like well you know

00:02:18,120 --> 00:02:21,719
it's really good when the problems are

00:02:19,590 --> 00:02:23,219
easy but I run this problem when you

00:02:21,719 --> 00:02:24,629
know I find these other things at the

00:02:23,219 --> 00:02:25,920
test and then I have to write tests for

00:02:24,629 --> 00:02:27,810
my tests and the code gets really

00:02:25,920 --> 00:02:29,430
complicated I call this the rabbit hole

00:02:27,810 --> 00:02:30,989
of testing here's kind of like going

00:02:29,430 --> 00:02:34,349
down different layers and it becomes

00:02:30,989 --> 00:02:36,209
really really hard and so you know

00:02:34,349 --> 00:02:37,680
mocking could help us with that no no

00:02:36,209 --> 00:02:39,540
worries another thing I hear is that

00:02:37,680 --> 00:02:41,760
people tell me I spend too much time

00:02:39,540 --> 00:02:43,349
writing these tests right I write lots

00:02:41,760 --> 00:02:45,180
and lots of code and then I have to

00:02:43,349 --> 00:02:46,439
write more tests for my code and then I

00:02:45,180 --> 00:02:48,540
have to write tests for my tests and

00:02:46,439 --> 00:02:51,000
just it's a big problem mocking can help

00:02:48,540 --> 00:02:53,430
us solve that lastly I hear people tell

00:02:51,000 --> 00:02:55,439
me that we can't really write tests for

00:02:53,430 --> 00:02:57,510
some things just there's just so much

00:02:55,439 --> 00:02:59,459
stuff you can't unit tests this is sort

00:02:57,510 --> 00:03:01,530
of a half-truth right I admit that there

00:02:59,459 --> 00:03:04,200
are things that we cannot cover simply

00:03:01,530 --> 00:03:06,510
by using unit tests but I think we way

00:03:04,200 --> 00:03:08,700
over estimate what that portion is it's

00:03:06,510 --> 00:03:10,319
actually a very very well-known and

00:03:08,700 --> 00:03:11,939
small fraction of things that we cannot

00:03:10,319 --> 00:03:14,609
test you know testing is an incredibly

00:03:11,939 --> 00:03:17,489
powerful tool mocking helps us make that

00:03:14,609 --> 00:03:19,829
more valuable and more it helps us fill

00:03:17,489 --> 00:03:22,799
that space so mocking makes you know

00:03:19,829 --> 00:03:24,959
testing easier so what are mocks exactly

00:03:22,799 --> 00:03:27,750
what what is that mocks foam this sort

00:03:24,959 --> 00:03:30,030
of strange subclass of a thing called a

00:03:27,750 --> 00:03:31,769
test double in testing the idea is we

00:03:30,030 --> 00:03:34,260
typically have like test stubs or tests

00:03:31,769 --> 00:03:36,419
pies or mock objects that sort of thing

00:03:34,260 --> 00:03:38,430
you'll hear me sort of use these I'll

00:03:36,419 --> 00:03:40,680
call these things mocks interchangeably

00:03:38,430 --> 00:03:42,720
but understand that maybe in an academic

00:03:40,680 --> 00:03:44,430
setting this might be a more important

00:03:42,720 --> 00:03:46,079
distinction for the purposes of this

00:03:44,430 --> 00:03:48,329
presentation though I'm just gonna call

00:03:46,079 --> 00:03:50,909
it a mock so one of those things

00:03:48,329 --> 00:03:52,379
specifically well you have a test stub

00:03:50,909 --> 00:03:54,510
and the idea is that it provides a

00:03:52,379 --> 00:03:56,340
canned response to a method call maybe a

00:03:54,510 --> 00:03:58,979
spy which is a real object that behaves

00:03:56,340 --> 00:04:00,150
like a real object until a certain

00:03:58,979 --> 00:04:02,040
condition is met then it does something

00:04:00,150 --> 00:04:03,959
else and you have a mock which helps us

00:04:02,040 --> 00:04:06,859
to verify that something was called or

00:04:03,959 --> 00:04:09,180
you know verify a behavior right so

00:04:06,859 --> 00:04:10,680
here's the thing does anybody in the

00:04:09,180 --> 00:04:12,810
room feel like after I've given that

00:04:10,680 --> 00:04:14,069
explanation that they understand mocking

00:04:12,810 --> 00:04:17,070
significantly better and they're ready

00:04:14,069 --> 00:04:19,289
to go test no of course not like for me

00:04:17,070 --> 00:04:21,329
I think what helps when we talk about

00:04:19,289 --> 00:04:23,219
mocking is understanding the types of

00:04:21,329 --> 00:04:25,380
problems that mocking helps us to solve

00:04:23,219 --> 00:04:27,030
ok so let's talk about the things that

00:04:25,380 --> 00:04:29,590
machs helped us solve

00:04:27,030 --> 00:04:32,740
first problem what happens if you have a

00:04:29,590 --> 00:04:34,469
dependency right so here I have a sample

00:04:32,740 --> 00:04:36,699
method foo everyone's favorite and

00:04:34,469 --> 00:04:39,370
depending upon the value you get back

00:04:36,699 --> 00:04:41,860
from method bar is gonna impact how the

00:04:39,370 --> 00:04:43,779
method foo behaves so this is a

00:04:41,860 --> 00:04:46,029
dependency we could write this down as

00:04:43,779 --> 00:04:48,189
rule of X you know it's going to depend

00:04:46,029 --> 00:04:50,740
on bar right

00:04:48,189 --> 00:04:52,719
the problem is is that in order to

00:04:50,740 --> 00:04:54,789
understand how foo works

00:04:52,719 --> 00:04:56,680
I need to also understand how bar works

00:04:54,789 --> 00:04:58,210
and that creates a big problem if I

00:04:56,680 --> 00:05:00,969
could eliminate that dependency if I

00:04:58,210 --> 00:05:04,599
could figure out a way of making gaining

00:05:00,969 --> 00:05:06,279
certainty with bar then I could you know

00:05:04,599 --> 00:05:09,460
test that more effectively so mocking

00:05:06,279 --> 00:05:10,810
helps us with this second problem what

00:05:09,460 --> 00:05:13,479
if I have a method has no return value

00:05:10,810 --> 00:05:15,370
so I have this method here foo and

00:05:13,479 --> 00:05:16,659
depending up on the value of X it's how

00:05:15,370 --> 00:05:18,819
they're going to call bar or it's going

00:05:16,659 --> 00:05:20,469
to call something else but how do I know

00:05:18,819 --> 00:05:22,240
if bar is called now sure we could write

00:05:20,469 --> 00:05:24,279
a unit test for this and that unit test

00:05:22,240 --> 00:05:26,080
could say well depending upon the side

00:05:24,279 --> 00:05:27,789
effects that bar has you know we could

00:05:26,080 --> 00:05:29,770
sort of introspect it or figure it out

00:05:27,789 --> 00:05:30,879
somehow right this is a really bad way

00:05:29,770 --> 00:05:33,729
to write tests it's really really

00:05:30,879 --> 00:05:35,529
cumbersome and painful right if I had

00:05:33,729 --> 00:05:37,419
some we're just saying did bar get

00:05:35,529 --> 00:05:39,189
called I have much greater certainty and

00:05:37,419 --> 00:05:42,819
know better so mocking helps us with

00:05:39,189 --> 00:05:44,649
that lastly if I have a situation where

00:05:42,819 --> 00:05:47,319
I want to generate an error or an

00:05:44,649 --> 00:05:49,210
exception right but that exception is

00:05:47,319 --> 00:05:51,699
really hard to generate so not talking

00:05:49,210 --> 00:05:53,740
about like a type error or file not

00:05:51,699 --> 00:05:55,960
found right so in this case maybe

00:05:53,740 --> 00:05:57,159
something that that would be very

00:05:55,960 --> 00:05:59,860
difficult to in are like a memory error

00:05:57,159 --> 00:06:01,300
if I could technically generate this

00:05:59,860 --> 00:06:02,589
somehow like by adding load to the

00:06:01,300 --> 00:06:04,419
server whatnot that's just it's not a

00:06:02,589 --> 00:06:06,129
good way to test it's very hard if I

00:06:04,419 --> 00:06:07,810
could just reliably call that make

00:06:06,129 --> 00:06:09,669
testing a lot easier so that's what

00:06:07,810 --> 00:06:11,740
mocking helps us solve a couple of

00:06:09,669 --> 00:06:13,839
things let's say you're happening to use

00:06:11,740 --> 00:06:15,550
a popular web framework that insists

00:06:13,839 --> 00:06:17,319
that you have you know database calls

00:06:15,550 --> 00:06:19,750
for all of your methods and spins up a

00:06:17,319 --> 00:06:21,009
test database like Django does if you

00:06:19,750 --> 00:06:22,810
didn't have to have that test database

00:06:21,009 --> 00:06:24,310
your test to be a lot faster in some

00:06:22,810 --> 00:06:24,789
cases mocking a model makes a lot of

00:06:24,310 --> 00:06:26,800
sense

00:06:24,789 --> 00:06:29,199
so this can be very helpful there it

00:06:26,800 --> 00:06:30,729
also helps us to reduce complexity so if

00:06:29,199 --> 00:06:32,169
I'm writing simple tests it's really

00:06:30,729 --> 00:06:33,939
easy to understand what those tests do

00:06:32,169 --> 00:06:36,399
and it's really easy to write them

00:06:33,939 --> 00:06:38,019
because it's quick and simple so mocking

00:06:36,399 --> 00:06:39,969
helps with that one other thing that I

00:06:38,019 --> 00:06:40,960
want to point out is that we don't think

00:06:39,969 --> 00:06:43,120
about this but

00:06:40,960 --> 00:06:45,070
if you have people who are working with

00:06:43,120 --> 00:06:46,900
you or collaborating and somebody hasn't

00:06:45,070 --> 00:06:48,370
written their method yet if you can mock

00:06:46,900 --> 00:06:50,259
those methods that haven't been written

00:06:48,370 --> 00:06:52,600
yet you can write unit tests for them

00:06:50,259 --> 00:06:54,520
this is way better than if you had to

00:06:52,600 --> 00:06:55,780
wait for all of those things to be done

00:06:54,520 --> 00:06:57,370
you could just you know you'd have to

00:06:55,780 --> 00:06:58,690
wait for all the components we finished

00:06:57,370 --> 00:06:59,860
before you could start testing it so

00:06:58,690 --> 00:07:01,840
this makes you more productive and

00:06:59,860 --> 00:07:03,039
efficient you can test things earlier

00:07:01,840 --> 00:07:06,460
and that's better

00:07:03,039 --> 00:07:09,090
so great you're sold you want to use

00:07:06,460 --> 00:07:11,410
mocking how do I actually do this

00:07:09,090 --> 00:07:14,080
fortunately for us in Python we have

00:07:11,410 --> 00:07:16,240
lots of options the one we're going to

00:07:14,080 --> 00:07:19,060
focus on here is the mock or the magic

00:07:16,240 --> 00:07:21,910
mock library it's very popular it's

00:07:19,060 --> 00:07:23,740
extremely powerful and good news for

00:07:21,910 --> 00:07:25,479
everybody if you're using Python 3 it's

00:07:23,740 --> 00:07:27,759
included in as part of the standard

00:07:25,479 --> 00:07:29,020
library so that's awesome there are some

00:07:27,759 --> 00:07:31,479
other options I want to toss out there

00:07:29,020 --> 00:07:34,449
in fairness so if you are familiar with

00:07:31,479 --> 00:07:36,070
Ruby's flex Mach there's flex Mach if

00:07:34,449 --> 00:07:39,280
you ever used ez mock in Java

00:07:36,070 --> 00:07:41,500
there's mocks mocker there's dingus

00:07:39,280 --> 00:07:44,139
which has an incredible name for a

00:07:41,500 --> 00:07:44,800
framework fudge if you've ever used

00:07:44,139 --> 00:07:47,349
mockito

00:07:44,800 --> 00:07:48,970
coming from like the Java space or if

00:07:47,349 --> 00:07:52,449
you're a big fan of doc tests there is

00:07:48,970 --> 00:07:53,889
mini mock okay but for the purposes of

00:07:52,449 --> 00:07:56,680
this I'm gonna focus on doing this with

00:07:53,889 --> 00:07:58,570
mock just know that any of the examples

00:07:56,680 --> 00:08:00,810
I do here we could probably do those in

00:07:58,570 --> 00:08:03,190
those other frameworks as well all right

00:08:00,810 --> 00:08:04,900
so let's do a sample problem like let's

00:08:03,190 --> 00:08:06,880
let's actually put this into code and do

00:08:04,900 --> 00:08:08,349
something with it it really helps to

00:08:06,880 --> 00:08:10,240
think about those types of problems so

00:08:08,349 --> 00:08:12,280
let's create a little problem space for

00:08:10,240 --> 00:08:13,840
ourselves a real-world situation let's

00:08:12,280 --> 00:08:15,970
say we wanted to build a tinder

00:08:13,840 --> 00:08:17,830
competitor okay that's a great example

00:08:15,970 --> 00:08:19,539
lap write tinder is the popular dating

00:08:17,830 --> 00:08:21,039
app where you get a random picture of

00:08:19,539 --> 00:08:22,630
somebody and you either swipe to the

00:08:21,039 --> 00:08:24,909
right or the left in to indicate your

00:08:22,630 --> 00:08:26,110
preference but we want something to

00:08:24,909 --> 00:08:28,509
appear to the software development

00:08:26,110 --> 00:08:29,860
community of course right so like you've

00:08:28,509 --> 00:08:31,509
got Tinder's already taken you got

00:08:29,860 --> 00:08:32,890
Grindr let's let's think of maybe I

00:08:31,509 --> 00:08:35,520
don't know like let's call it docker

00:08:32,890 --> 00:08:35,520
okay

00:08:35,909 --> 00:08:43,419
so the the docker dating app is what

00:08:41,919 --> 00:08:45,209
we're gonna use because I think this is

00:08:43,419 --> 00:08:49,779
a great idea

00:08:45,209 --> 00:08:52,209
so not me not my only devops show cure

00:08:49,779 --> 00:08:53,709
so okay so let's say you're building

00:08:52,209 --> 00:08:55,149
your doctor dating app and we're gonna

00:08:53,709 --> 00:08:57,760
create a method for this right where we

00:08:55,149 --> 00:08:59,410
get to a random user the idea is that I

00:08:57,760 --> 00:09:01,240
want to be able to grab a random user

00:08:59,410 --> 00:09:03,550
from the database and show that to them

00:09:01,240 --> 00:09:05,410
the show that's of the the current user

00:09:03,550 --> 00:09:07,000
the only criteria here is that I can't

00:09:05,410 --> 00:09:08,680
see the same person and it can't be

00:09:07,000 --> 00:09:11,380
someone that I've already I've already

00:09:08,680 --> 00:09:13,510
swiped on okay so very simple

00:09:11,380 --> 00:09:15,070
we could write a simple implementation

00:09:13,510 --> 00:09:18,310
for that so something like this

00:09:15,070 --> 00:09:20,440
so get next person is going to call the

00:09:18,310 --> 00:09:21,940
method get random person and then we

00:09:20,440 --> 00:09:23,769
just go through a loop and says if if

00:09:21,940 --> 00:09:26,339
we've already seen that person just keep

00:09:23,769 --> 00:09:28,810
grabbing random people until you get

00:09:26,339 --> 00:09:31,870
somebody you haven't seen then return

00:09:28,810 --> 00:09:34,089
that person fair enough okay now those

00:09:31,870 --> 00:09:35,230
of you who are astute pythonista x' will

00:09:34,089 --> 00:09:36,790
probably notice something interesting

00:09:35,230 --> 00:09:38,230
about this there's a bug in this code

00:09:36,790 --> 00:09:40,089
that of course we found when testing

00:09:38,230 --> 00:09:42,310
which is of course surely no one could

00:09:40,089 --> 00:09:43,930
have seen everyone in the database right

00:09:42,310 --> 00:09:45,519
so if you have seen everyone the

00:09:43,930 --> 00:09:46,990
database then it gets into an infinite

00:09:45,519 --> 00:09:48,579
loop we're going to ignore that for now

00:09:46,990 --> 00:09:50,890
because it makes the problem more

00:09:48,579 --> 00:09:52,870
complicated and like makes the example

00:09:50,890 --> 00:09:55,570
less pretty so let's assume that our

00:09:52,870 --> 00:09:58,390
database is sufficiently large to do

00:09:55,570 --> 00:10:00,550
that so let's represent the relationship

00:09:58,390 --> 00:10:02,350
here so get next person is going to call

00:10:00,550 --> 00:10:03,970
get random person so we could write a

00:10:02,350 --> 00:10:07,449
unit test for this right very simple

00:10:03,970 --> 00:10:09,760
very easy so here's my unit test and if

00:10:07,449 --> 00:10:11,649
there's a general set up right we have

00:10:09,760 --> 00:10:13,839
an arrangement that our preconditions we

00:10:11,649 --> 00:10:15,550
just say that's a dictionary of people

00:10:13,839 --> 00:10:19,240
that I've seen it's empty and then

00:10:15,550 --> 00:10:20,949
expected person that I want is Katy my

00:10:19,240 --> 00:10:22,810
action is gonna be to call get next

00:10:20,949 --> 00:10:24,640
person I store the result of that and

00:10:22,810 --> 00:10:26,800
then I just compare the expected result

00:10:24,640 --> 00:10:28,720
to the actual result very simple and

00:10:26,800 --> 00:10:30,790
good news this totally works

00:10:28,720 --> 00:10:33,670
it works it's great that's so simple

00:10:30,790 --> 00:10:36,220
right except it also doesn't work and

00:10:33,670 --> 00:10:38,019
sometimes it fails and that's not cool

00:10:36,220 --> 00:10:41,740
because like 60% of the time works every

00:10:38,019 --> 00:10:45,459
time so what's going on here like this

00:10:41,740 --> 00:10:47,170
is a problem so what happens is that get

00:10:45,459 --> 00:10:48,340
random person obviously picks a random

00:10:47,170 --> 00:10:50,440
person out

00:10:48,340 --> 00:10:52,779
so that means that there's no way for us

00:10:50,440 --> 00:10:54,130
to really have any certainty to it even

00:10:52,779 --> 00:10:56,020
if I knew the implementation of get

00:10:54,130 --> 00:10:58,270
random person I could not writing in a

00:10:56,020 --> 00:10:59,470
test for this without mocking but what

00:10:58,270 --> 00:11:01,120
if there was some way we could fix the

00:10:59,470 --> 00:11:04,029
value of get random person what if we

00:11:01,120 --> 00:11:05,260
can make that certain so how do we do

00:11:04,029 --> 00:11:06,240
that easy

00:11:05,260 --> 00:11:09,790
we're gonna mark all the dependencies

00:11:06,240 --> 00:11:12,700
yes that's what we're gonna do here's

00:11:09,790 --> 00:11:14,320
how we do that there's a very simple

00:11:12,700 --> 00:11:17,230
method here there's a very simple

00:11:14,320 --> 00:11:19,000
decorator here called patch and the idea

00:11:17,230 --> 00:11:21,430
is that inside of patch we're going to

00:11:19,000 --> 00:11:23,080
pass in especially the module dot

00:11:21,430 --> 00:11:25,360
attribute so in this case my module is

00:11:23,080 --> 00:11:28,660
application and then the unbound method

00:11:25,360 --> 00:11:29,980
is get random person right when I put

00:11:28,660 --> 00:11:32,770
that decorator on there it's gonna pass

00:11:29,980 --> 00:11:36,250
an argument into my test method called

00:11:32,770 --> 00:11:38,589
mock get random person and then all I'm

00:11:36,250 --> 00:11:41,200
really gonna do here is there we go

00:11:38,589 --> 00:11:43,240
all I'm gonna do is call this thing

00:11:41,200 --> 00:11:44,950
called return value on it I'm gonna set

00:11:43,240 --> 00:11:47,290
the value of that to be a fixed value in

00:11:44,950 --> 00:11:49,240
this case Katie so what this does is

00:11:47,290 --> 00:11:50,920
that whenever that random person method

00:11:49,240 --> 00:11:52,720
gets called it's actually gonna call the

00:11:50,920 --> 00:11:55,180
mock method instead and it's going to

00:11:52,720 --> 00:11:56,920
return back that fixed value and that's

00:11:55,180 --> 00:11:58,480
it then we have certainty in our method

00:11:56,920 --> 00:12:01,180
now we know how to get that value back

00:11:58,480 --> 00:12:03,640
in good news it works every single time

00:12:01,180 --> 00:12:05,050
every single time it works you can call

00:12:03,640 --> 00:12:06,640
it over and over again even though

00:12:05,050 --> 00:12:08,350
that's a random method we fixed the

00:12:06,640 --> 00:12:11,410
value of it you can test it reliably

00:12:08,350 --> 00:12:12,970
that's great so let's take a little bit

00:12:11,410 --> 00:12:14,770
further let's do some variations on this

00:12:12,970 --> 00:12:17,380
right we we rarely work with unbound

00:12:14,770 --> 00:12:19,300
methods what about a class you know so I

00:12:17,380 --> 00:12:20,890
have a class again I just restructured

00:12:19,300 --> 00:12:22,870
this so that that method is inside of a

00:12:20,890 --> 00:12:25,450
class called application how do you mock

00:12:22,870 --> 00:12:27,100
that same idea here we're going to have

00:12:25,450 --> 00:12:29,500
this thing it's now gonna be patched dot

00:12:27,100 --> 00:12:31,600
object instead of just patch and you

00:12:29,500 --> 00:12:33,490
pass it in the class name and then the

00:12:31,600 --> 00:12:35,740
method that you want to mock everything

00:12:33,490 --> 00:12:38,500
else about this is exactly the same as

00:12:35,740 --> 00:12:40,360
the previous example so it's very easy

00:12:38,500 --> 00:12:42,490
if you're using you know a class or if

00:12:40,360 --> 00:12:44,230
you're not using a class but what if

00:12:42,490 --> 00:12:46,150
you're like I'm really kind of new to

00:12:44,230 --> 00:12:47,650
Python and I'm scared by decorators I

00:12:46,150 --> 00:12:49,959
don't really like decorators they're

00:12:47,650 --> 00:12:51,070
kind of magical and weird so yeah we

00:12:49,959 --> 00:12:52,180
don't have to have a decorator we can

00:12:51,070 --> 00:12:54,940
get rid of that so here's another

00:12:52,180 --> 00:12:56,500
example all we're doing here is we're

00:12:54,940 --> 00:12:58,750
just going to make a direct assignment

00:12:56,500 --> 00:13:00,700
this is awesome because python allows

00:12:58,750 --> 00:13:01,580
this so you can literally just override

00:13:00,700 --> 00:13:03,980
that method

00:13:01,580 --> 00:13:05,750
with call sue a new object you basically

00:13:03,980 --> 00:13:08,390
setting that method to be a mock and

00:13:05,750 --> 00:13:09,920
then we just set the return value so

00:13:08,390 --> 00:13:12,050
that's kind of the idea here with this

00:13:09,920 --> 00:13:13,730
but what if you're like okay you know

00:13:12,050 --> 00:13:16,040
I'm actually a bigger fan of context

00:13:13,730 --> 00:13:18,290
managers I really love context managers

00:13:16,040 --> 00:13:20,660
well good news context managers too you

00:13:18,290 --> 00:13:23,660
can use you with statement that's that's

00:13:20,660 --> 00:13:26,269
great all right so that's the general

00:13:23,660 --> 00:13:28,100
idea behind sort of mocking for a

00:13:26,269 --> 00:13:31,490
dependency but what happens if I want to

00:13:28,100 --> 00:13:33,589
call this thing multiple times so here's

00:13:31,490 --> 00:13:35,390
our here's our sample code but what if I

00:13:33,589 --> 00:13:38,390
like test the while loop inside of this

00:13:35,390 --> 00:13:41,180
so the while loop I'm gonna get that you

00:13:38,390 --> 00:13:43,459
know a new person each time so I read a

00:13:41,180 --> 00:13:45,170
unit test for it but the problem is is

00:13:43,459 --> 00:13:47,540
that when I set that return value I

00:13:45,170 --> 00:13:48,890
don't really know who I should set the

00:13:47,540 --> 00:13:51,200
return by you to it's actually gonna

00:13:48,890 --> 00:13:53,300
enter into into an infinite loop if I do

00:13:51,200 --> 00:13:54,019
this where it's gonna be you know over

00:13:53,300 --> 00:13:55,130
and over and over again

00:13:54,019 --> 00:13:57,170
I'm just gonna keep returning the same

00:13:55,130 --> 00:13:59,899
value now that same values and the list

00:13:57,170 --> 00:14:03,140
of people I've seen just keeps going so

00:13:59,899 --> 00:14:05,269
how do we fix that so there's a method

00:14:03,140 --> 00:14:06,649
called side-effect and the idea here is

00:14:05,269 --> 00:14:08,810
we just make a slight change to our

00:14:06,649 --> 00:14:11,060
method call this thing here called

00:14:08,810 --> 00:14:14,060
side-effects and it will take in an

00:14:11,060 --> 00:14:15,529
iterable or a list so if I pass in a

00:14:14,060 --> 00:14:17,990
list of the return values that I want

00:14:15,529 --> 00:14:19,880
each time that method gets called it

00:14:17,990 --> 00:14:22,370
will just return back you know the next

00:14:19,880 --> 00:14:24,800
the next thing in the list so first it

00:14:22,370 --> 00:14:26,899
will return Matt Mary then Sara then

00:14:24,800 --> 00:14:28,700
Katie so if I'm testing that and I met

00:14:26,899 --> 00:14:32,270
that gets called multiple times turns

00:14:28,700 --> 00:14:34,570
back those values okay so that's really

00:14:32,270 --> 00:14:37,130
all there is to like dependency

00:14:34,570 --> 00:14:38,899
dependency management here it's really

00:14:37,130 --> 00:14:41,510
not particularly complex

00:14:38,899 --> 00:14:42,560
well let's recap so we can use mocking

00:14:41,510 --> 00:14:44,540
and passionate to sort of bring

00:14:42,560 --> 00:14:46,610
certainty to all of our dependent

00:14:44,540 --> 00:14:48,170
methods we can eliminate those

00:14:46,610 --> 00:14:49,670
dependencies in the code even if that

00:14:48,170 --> 00:14:51,709
even if those dependencies are

00:14:49,670 --> 00:14:54,680
unfinished notice that I didn't point

00:14:51,709 --> 00:14:56,810
out how a get random person was was

00:14:54,680 --> 00:14:59,630
implemented it didn't matter that code

00:14:56,810 --> 00:15:01,600
could not even work but I was able to

00:14:59,630 --> 00:15:04,160
still you write you in a test for this

00:15:01,600 --> 00:15:05,990
also lots of different ways to do it

00:15:04,160 --> 00:15:07,699
pick your favorite show hands in the

00:15:05,990 --> 00:15:10,640
room who likes doing it without the

00:15:07,699 --> 00:15:12,860
decorators anyone see a couple of hands

00:15:10,640 --> 00:15:14,720
yeah I took a group of folks I find

00:15:12,860 --> 00:15:15,230
they're always like a handful of people

00:15:14,720 --> 00:15:16,490
who are alike

00:15:15,230 --> 00:15:19,190
this makes more sense to me this is

00:15:16,490 --> 00:15:20,750
better and it's it's great there's in

00:15:19,190 --> 00:15:22,760
some cases it makes more sense to do it

00:15:20,750 --> 00:15:24,680
in that style in some cases it makes

00:15:22,760 --> 00:15:27,340
sense to use the decorator it's up to

00:15:24,680 --> 00:15:29,660
your personal preference all right

00:15:27,340 --> 00:15:31,460
second thing marks help us with mocking

00:15:29,660 --> 00:15:33,520
to verify behavior okay

00:15:31,460 --> 00:15:36,200
so let's set up a problem space for us

00:15:33,520 --> 00:15:38,390
again let's keep on with our with our

00:15:36,200 --> 00:15:42,080
doctor dating app but let's talk about

00:15:38,390 --> 00:15:45,500
the matching system here so when a user

00:15:42,080 --> 00:15:47,810
swipes to the right if the other user

00:15:45,500 --> 00:15:48,980
has indicated that they like them the

00:15:47,810 --> 00:15:51,170
one want to do is want to send both of

00:15:48,980 --> 00:15:52,370
them a message you know send both of

00:15:51,170 --> 00:15:55,400
them a message saying you're a match

00:15:52,370 --> 00:15:57,050
okay if the other user has indicated

00:15:55,400 --> 00:15:58,880
they dislike them then we want to sort

00:15:57,050 --> 00:16:00,020
of let them down gently let them know

00:15:58,880 --> 00:16:02,300
there's there's other fish in the sea

00:16:00,020 --> 00:16:04,520
there's other you know opportunities and

00:16:02,300 --> 00:16:06,530
if they haven't evaluated you yet then

00:16:04,520 --> 00:16:08,390
what we want to do is send the give that

00:16:06,530 --> 00:16:10,520
time message so that's just kind of the

00:16:08,390 --> 00:16:13,940
general setup here for how we react to

00:16:10,520 --> 00:16:16,130
someone doing the action of swiping so a

00:16:13,940 --> 00:16:17,900
simple implementation for this very easy

00:16:16,130 --> 00:16:20,480
we could just you know have an evaluate

00:16:17,900 --> 00:16:22,340
method takes in two people if person one

00:16:20,480 --> 00:16:24,590
is in person twos likes then we send

00:16:22,340 --> 00:16:26,420
both people an email if person one is in

00:16:24,590 --> 00:16:29,720
person twos dislikes then we call they

00:16:26,420 --> 00:16:31,630
let let down gently method and if person

00:16:29,720 --> 00:16:33,800
one is not in your likes or dislikes

00:16:31,630 --> 00:16:36,590
then we're going to call the give a time

00:16:33,800 --> 00:16:38,900
method simple enough but there's sort of

00:16:36,590 --> 00:16:40,460
a problem with this how do I test this

00:16:38,900 --> 00:16:42,170
it has no return values how do I know

00:16:40,460 --> 00:16:44,000
that this is functioning properly we all

00:16:42,170 --> 00:16:46,900
agree this has logic in it and it needs

00:16:44,000 --> 00:16:49,040
to be tested but how would I do that so

00:16:46,900 --> 00:16:51,110
let's focus in on the middle section

00:16:49,040 --> 00:16:54,470
here and let's try and write a unit test

00:16:51,110 --> 00:16:58,190
for it we can do behavior verification

00:16:54,470 --> 00:17:00,710
with mocking and it's very simple it's

00:16:58,190 --> 00:17:02,540
very it's basically the exact same we're

00:17:00,710 --> 00:17:03,650
just going to tweak it slightly we have

00:17:02,540 --> 00:17:05,480
that patch decorator

00:17:03,650 --> 00:17:07,340
so again application dot let down gently

00:17:05,480 --> 00:17:09,980
it's going to give us a mock of the let

00:17:07,340 --> 00:17:11,540
down gently method in my arrangement

00:17:09,980 --> 00:17:13,520
here I just have person one is named

00:17:11,540 --> 00:17:15,650
bill and person two is just a dictionary

00:17:13,520 --> 00:17:17,660
of you know the people they like and

00:17:15,650 --> 00:17:20,840
that the other person has liked or

00:17:17,660 --> 00:17:22,790
disliked I call my action to evaluate it

00:17:20,840 --> 00:17:24,920
the only thing that's different here is

00:17:22,790 --> 00:17:27,080
in my assertion I'm going to call this

00:17:24,920 --> 00:17:28,670
method called call count what's cool

00:17:27,080 --> 00:17:29,070
with mocks is that they actually will

00:17:28,670 --> 00:17:30,180
recur

00:17:29,070 --> 00:17:32,250
every time that they have been called

00:17:30,180 --> 00:17:34,920
and will allow me to verify and say how

00:17:32,250 --> 00:17:37,380
many times were you called and you can

00:17:34,920 --> 00:17:38,430
use that to verify the behavior so if it

00:17:37,380 --> 00:17:39,780
was called one time we know it's

00:17:38,430 --> 00:17:41,370
functioning correctly it should have

00:17:39,780 --> 00:17:45,060
been called given the situation I've

00:17:41,370 --> 00:17:46,590
created here so that's nice but you

00:17:45,060 --> 00:17:47,910
might say well a more robust way of

00:17:46,590 --> 00:17:49,380
doing this would be like what about

00:17:47,910 --> 00:17:51,270
checking the parameters instead of just

00:17:49,380 --> 00:17:51,870
how many times it was called right that

00:17:51,270 --> 00:17:54,690
makes sense

00:17:51,870 --> 00:17:57,120
so we can do that too same exact setup

00:17:54,690 --> 00:17:59,010
here only difference is we're gonna call

00:17:57,120 --> 00:18:00,840
this method called assert called once

00:17:59,010 --> 00:18:03,720
with which is quite a mouthful to say

00:18:00,840 --> 00:18:05,850
but all it's doing is it's checking two

00:18:03,720 --> 00:18:07,560
things it was called one time and it's

00:18:05,850 --> 00:18:09,060
checking that it was called with the

00:18:07,560 --> 00:18:11,250
appropriate parameters in this case

00:18:09,060 --> 00:18:13,260
person 1 so this will allow us to verify

00:18:11,250 --> 00:18:16,770
that that method was called with exactly

00:18:13,260 --> 00:18:18,600
what we expected now one variation of

00:18:16,770 --> 00:18:20,160
this is you might say well that's nice

00:18:18,600 --> 00:18:21,390
but shouldn't we also check the other

00:18:20,160 --> 00:18:23,970
methods to make sure that they're not

00:18:21,390 --> 00:18:26,130
being called so for the for example

00:18:23,970 --> 00:18:28,190
those things right we might have a bug

00:18:26,130 --> 00:18:31,560
in our code somewhere that says you know

00:18:28,190 --> 00:18:33,330
maybe we're calling everything or

00:18:31,560 --> 00:18:36,330
whatnot so how could we check against

00:18:33,330 --> 00:18:39,200
that so that's great that's a good idea

00:18:36,330 --> 00:18:42,450
the only problem is we're gonna run into

00:18:39,200 --> 00:18:44,400
having to mock multiple things right so

00:18:42,450 --> 00:18:46,740
can we even do that well of course in

00:18:44,400 --> 00:18:48,360
Python we have the ability to stack

00:18:46,740 --> 00:18:50,970
decorators so if you need to patch

00:18:48,360 --> 00:18:52,650
multiple methods you can do that just

00:18:50,970 --> 00:18:55,140
stack them one on top of the other and

00:18:52,650 --> 00:18:57,030
it works great one thing I do want to

00:18:55,140 --> 00:18:59,460
point out about this though is that if

00:18:57,030 --> 00:19:01,320
you stack the decorators because of how

00:18:59,460 --> 00:19:03,270
Python evaluates those you have to be

00:19:01,320 --> 00:19:06,030
very careful about how the order in

00:19:03,270 --> 00:19:08,070
which your arguments come in so for

00:19:06,030 --> 00:19:10,320
example the the mock give it time is the

00:19:08,070 --> 00:19:12,660
first the first parameter as opposed to

00:19:10,320 --> 00:19:14,580
the third because python evaluates them

00:19:12,660 --> 00:19:16,800
from the bottom up as opposed to top

00:19:14,580 --> 00:19:19,290
down so people find this can find this

00:19:16,800 --> 00:19:20,760
kind of counterintuitive but just

00:19:19,290 --> 00:19:22,500
something to keep in mind so you don't

00:19:20,760 --> 00:19:25,920
end up getting those mixed up and

00:19:22,500 --> 00:19:28,290
calling the wrong box everything else

00:19:25,920 --> 00:19:30,660
with this is pretty much the same we

00:19:28,290 --> 00:19:33,030
basically have we basically going to

00:19:30,660 --> 00:19:34,560
look at the call counts and make sure

00:19:33,030 --> 00:19:37,080
that it's set at zero for those other

00:19:34,560 --> 00:19:40,020
methods and verify our arguments with

00:19:37,080 --> 00:19:42,300
the one we meant to call so if you're

00:19:40,020 --> 00:19:42,870
concerned about possibly mixing up the

00:19:42,300 --> 00:19:45,840
ordering

00:19:42,870 --> 00:19:47,610
on those those decorators you can try

00:19:45,840 --> 00:19:48,750
using patched at multiple which gives a

00:19:47,610 --> 00:19:50,880
little bit more of our rigor and

00:19:48,750 --> 00:19:53,340
structure to it it'll make it a little

00:19:50,880 --> 00:19:54,720
easier to kind of fill this out and then

00:19:53,340 --> 00:19:56,670
it comes in the order that you sort of

00:19:54,720 --> 00:19:58,050
expect so with just another variation of

00:19:56,670 --> 00:20:00,000
how you can do this just another thing

00:19:58,050 --> 00:20:01,730
you can try that's if that makes sense

00:20:00,000 --> 00:20:03,600
to you if that's what you'd like to do

00:20:01,730 --> 00:20:08,730
everything else pretty much stays the

00:20:03,600 --> 00:20:10,020
same okay all right so what about

00:20:08,730 --> 00:20:11,580
testing things that have been called

00:20:10,020 --> 00:20:13,650
multiple times we talked about verifying

00:20:11,580 --> 00:20:15,240
the behavior of being called once but

00:20:13,650 --> 00:20:16,890
what happens if we have a case like here

00:20:15,240 --> 00:20:19,320
at the top where we call send email

00:20:16,890 --> 00:20:20,790
twice we can't really evaluate you know

00:20:19,320 --> 00:20:22,470
the parameter of the parameters being

00:20:20,790 --> 00:20:25,500
passed in which which call are we

00:20:22,470 --> 00:20:28,920
talking about so let's take a look at

00:20:25,500 --> 00:20:31,470
how how to fix that problem so in this

00:20:28,920 --> 00:20:33,150
case we're going to do we're going to

00:20:31,470 --> 00:20:35,610
have a thing called we're going to call

00:20:33,150 --> 00:20:37,380
a method called call args list and

00:20:35,610 --> 00:20:39,780
that's going to basically record every

00:20:37,380 --> 00:20:41,610
single time that the method was called

00:20:39,780 --> 00:20:43,350
and the parameters that were in that it

00:20:41,610 --> 00:20:45,090
returns back a list of call arguments

00:20:43,350 --> 00:20:47,550
the idea is that I can assert that

00:20:45,090 --> 00:20:51,210
against it's like a little wrapper so

00:20:47,550 --> 00:20:55,140
the call call is just a wrapper around

00:20:51,210 --> 00:20:57,740
the parameters of your of your method so

00:20:55,140 --> 00:21:00,900
we can evaluate that against you know

00:20:57,740 --> 00:21:02,850
against person 1 and person 2 so if we

00:21:00,900 --> 00:21:04,620
call it twice say the first call we're

00:21:02,850 --> 00:21:07,620
looking for person 1 the second call I'm

00:21:04,620 --> 00:21:08,250
looking for person - okay everyone with

00:21:07,620 --> 00:21:12,480
me so far

00:21:08,250 --> 00:21:13,830
shaking hands okay cool all right

00:21:12,480 --> 00:21:15,210
almost done I know this is the end of

00:21:13,830 --> 00:21:16,800
the day for you guys if you need to take

00:21:15,210 --> 00:21:20,010
a brief kitten break

00:21:16,800 --> 00:21:22,020
I've got kitten for you if you guys are

00:21:20,010 --> 00:21:24,300
maybe not cat fans maybe your dog people

00:21:22,020 --> 00:21:29,400
I have some delightful corgis to make

00:21:24,300 --> 00:21:31,440
you happy okay so we talked about three

00:21:29,400 --> 00:21:32,130
things that mocking helps us to solve

00:21:31,440 --> 00:21:34,890
right

00:21:32,130 --> 00:21:37,320
mocking helps us to solve mocking up

00:21:34,890 --> 00:21:40,260
solve dependencies mocking helps us to

00:21:37,320 --> 00:21:43,020
solve to verify behavior and mocking

00:21:40,260 --> 00:21:45,660
losses helps us to evaluate exceptions

00:21:43,020 --> 00:21:48,660
being thrown so let's set up a problem

00:21:45,660 --> 00:21:49,920
right let's say in our awesome doctor

00:21:48,660 --> 00:21:51,420
dating app that we wanted to have a

00:21:49,920 --> 00:21:53,550
payment system because of course adding

00:21:51,420 --> 00:21:55,100
a premium feature totally works every

00:21:53,550 --> 00:21:56,900
time it's great

00:21:55,100 --> 00:21:58,580
I'm in this case I'm just gonna use

00:21:56,900 --> 00:22:00,470
stripe because it was convenient and

00:21:58,580 --> 00:22:05,120
easy but you can imagine doing any other

00:22:00,470 --> 00:22:08,179
number of services so I've created a

00:22:05,120 --> 00:22:10,160
simple submit payment method the idea

00:22:08,179 --> 00:22:11,600
here is it takes in a stripe token I've

00:22:10,160 --> 00:22:13,190
literally just copied and pasted this

00:22:11,600 --> 00:22:16,450
from their from their tutorial more or

00:22:13,190 --> 00:22:18,919
less I have an API key that I set and

00:22:16,450 --> 00:22:21,919
then I create a sample charge in this

00:22:18,919 --> 00:22:23,720
case it's gonna be $10 you can imagine

00:22:21,919 --> 00:22:25,039
this being in like your Django View code

00:22:23,720 --> 00:22:26,450
or maybe in one of your forums or

00:22:25,039 --> 00:22:28,730
something of that nature so even though

00:22:26,450 --> 00:22:30,830
I'm not necessarily pointing out you

00:22:28,730 --> 00:22:32,270
know Django specific stuff I'm just sort

00:22:30,830 --> 00:22:34,220
of pulling these things out to keep the

00:22:32,270 --> 00:22:35,539
examples clean but this is very easily

00:22:34,220 --> 00:22:39,169
something that could be in your view

00:22:35,539 --> 00:22:40,549
code in the case of this the charge

00:22:39,169 --> 00:22:43,669
going through will just return back the

00:22:40,549 --> 00:22:45,289
charge and if it's ends up failing

00:22:43,669 --> 00:22:47,840
though like so let's say the card gets

00:22:45,289 --> 00:22:49,700
declined well then you have it will

00:22:47,840 --> 00:22:51,500
generate a card error and we want to

00:22:49,700 --> 00:22:54,110
catch that and maybe in this case we'll

00:22:51,500 --> 00:22:55,820
we'll just you know pull out the body of

00:22:54,110 --> 00:22:56,990
the error and we'll pass it back to the

00:22:55,820 --> 00:22:58,250
users some some sort of default

00:22:56,990 --> 00:23:00,320
implementation here it doesn't have to

00:22:58,250 --> 00:23:02,240
be particularly fancy but that's kind of

00:23:00,320 --> 00:23:03,799
our setup here so they wanted to write a

00:23:02,240 --> 00:23:05,990
test for this how would I go about doing

00:23:03,799 --> 00:23:07,730
this if I go to stripes documentation

00:23:05,990 --> 00:23:09,500
they have this really weird thing where

00:23:07,730 --> 00:23:12,110
they suggest putting in different card

00:23:09,500 --> 00:23:14,090
numbers the idea is that I have

00:23:12,110 --> 00:23:15,980
different card numbers return different

00:23:14,090 --> 00:23:17,840
values or different types of errors or

00:23:15,980 --> 00:23:20,510
different things when it's in test mode

00:23:17,840 --> 00:23:25,250
and so if I pass in you know two for two

00:23:20,510 --> 00:23:27,890
for two for two for $10 a payment

00:23:25,250 --> 00:23:28,669
declined you no exception that sort of

00:23:27,890 --> 00:23:31,580
thing so that's sort of their

00:23:28,669 --> 00:23:34,789
recommended way of testing this that's

00:23:31,580 --> 00:23:37,010
sort of ridiculous you know it's sort of

00:23:34,789 --> 00:23:39,350
crazy that that's how we would have to

00:23:37,010 --> 00:23:41,030
test this thing it's crazy because it

00:23:39,350 --> 00:23:43,580
requires to make an external call to our

00:23:41,030 --> 00:23:44,840
API when right our unit tests so that

00:23:43,580 --> 00:23:46,490
could be problematic what happens if

00:23:44,840 --> 00:23:48,559
that API is down what happens if that

00:23:46,490 --> 00:23:51,230
API doesn't work or what happens if we

00:23:48,559 --> 00:23:53,000
you know are just running into all kinds

00:23:51,230 --> 00:23:54,260
of connectivity problems it's gonna make

00:23:53,000 --> 00:23:58,039
our tests fail intermittently and it's

00:23:54,260 --> 00:23:59,179
not not good it's also super unclear to

00:23:58,039 --> 00:24:00,919
people who are maintaining this what

00:23:59,179 --> 00:24:02,840
those numbers mean without them actually

00:24:00,919 --> 00:24:04,159
looking at the documentation so imagine

00:24:02,840 --> 00:24:05,659
six months down the road you're looking

00:24:04,159 --> 00:24:07,230
at these unit tests or someone else is

00:24:05,659 --> 00:24:08,250
looking at these unit tests

00:24:07,230 --> 00:24:09,620
see those card numbers and they're like

00:24:08,250 --> 00:24:11,820
what does that mean what does that do

00:24:09,620 --> 00:24:13,650
you know doesn't make any sense to them

00:24:11,820 --> 00:24:15,179
they have to go to the website and plug

00:24:13,650 --> 00:24:15,780
those numbers in so you want to make

00:24:15,179 --> 00:24:18,900
sure that our code is really

00:24:15,780 --> 00:24:20,210
maintainable and that's not gonna work

00:24:18,900 --> 00:24:22,470
for us

00:24:20,210 --> 00:24:23,910
also we run the problem of the stripe

00:24:22,470 --> 00:24:26,100
token this is the one that's the big of

00:24:23,910 --> 00:24:27,480
frustration for me it's not just a

00:24:26,100 --> 00:24:29,400
dictionary of credit-card fields it's

00:24:27,480 --> 00:24:31,110
actually an encrypted token so if I were

00:24:29,400 --> 00:24:32,700
to pass this thing in I have to actually

00:24:31,110 --> 00:24:34,620
reverse engineer and kind of figure out

00:24:32,700 --> 00:24:36,690
what that value should be as some sort

00:24:34,620 --> 00:24:38,610
of like encrypted hash so I have to

00:24:36,690 --> 00:24:40,020
generate it and I so talk about

00:24:38,610 --> 00:24:42,000
something that's like unmaintainable

00:24:40,020 --> 00:24:43,260
unreadable it's a little token of some

00:24:42,000 --> 00:24:46,049
kind but I don't know what that thing is

00:24:43,260 --> 00:24:47,760
so that's no good so clearly there's got

00:24:46,049 --> 00:24:49,350
to be a better way to do this right we

00:24:47,760 --> 00:24:50,549
all know better now everybody here in

00:24:49,350 --> 00:24:53,610
the room knows there's a better way to

00:24:50,549 --> 00:24:57,299
do this right we tried mocking it sure

00:24:53,610 --> 00:24:59,130
you know our same idea here we're using

00:24:57,299 --> 00:25:01,320
pretty much the same general pattern

00:24:59,130 --> 00:25:03,780
we're going to call that patch decorator

00:25:01,320 --> 00:25:06,809
and we're gonna actually patch the the

00:25:03,780 --> 00:25:09,809
stripe charge create method I'm gonna

00:25:06,809 --> 00:25:11,340
set up a sample card error and the idea

00:25:09,809 --> 00:25:12,660
here is I'll just pass in whatever I

00:25:11,340 --> 00:25:14,640
wants you know kind of set it up however

00:25:12,660 --> 00:25:16,650
I'd like to with whatever error messages

00:25:14,640 --> 00:25:18,690
I want to put it in and then I'm going

00:25:16,650 --> 00:25:19,650
to call our good friend side-effect now

00:25:18,690 --> 00:25:21,330
you guys might remember this from

00:25:19,650 --> 00:25:23,340
earlier in the presentation I said that

00:25:21,330 --> 00:25:24,530
side-effect takes in a list but it

00:25:23,340 --> 00:25:26,549
actually kind of does double duty

00:25:24,530 --> 00:25:28,590
side-effect can take in an iterative

00:25:26,549 --> 00:25:31,140
object but it can also take in an error

00:25:28,590 --> 00:25:32,880
or an exception so in this case if you

00:25:31,140 --> 00:25:34,559
give it an error what it will do is

00:25:32,880 --> 00:25:36,870
whenever that method gets called it will

00:25:34,559 --> 00:25:39,450
raise that exception so it raises up and

00:25:36,870 --> 00:25:41,190
then we can catch it so that's really

00:25:39,450 --> 00:25:43,110
nice because then you know I can call I

00:25:41,190 --> 00:25:44,549
method and verify that it actually has

00:25:43,110 --> 00:25:47,309
the correct behavior I just pass it that

00:25:44,549 --> 00:25:49,110
card error and that's it so it's very

00:25:47,309 --> 00:25:51,120
simple very easy way for us to generate

00:25:49,110 --> 00:25:56,309
exceptions in our in our code and test

00:25:51,120 --> 00:25:57,929
all those branches so let's let's talk

00:25:56,309 --> 00:26:00,299
about some of the takeaways here right

00:25:57,929 --> 00:26:01,860
something easy just wrap this up for us

00:26:00,299 --> 00:26:03,990
if there's nothing that you guys I

00:26:01,860 --> 00:26:06,809
remember from this presentation it's

00:26:03,990 --> 00:26:09,059
that mocking makes it solves three very

00:26:06,809 --> 00:26:11,850
specific cases for us we eliminate

00:26:09,059 --> 00:26:13,919
dependencies we verify behavior for

00:26:11,850 --> 00:26:16,620
things that have no return value and we

00:26:13,919 --> 00:26:18,900
can generate errors on the fly if we

00:26:16,620 --> 00:26:20,730
want the only thing that's kind of

00:26:18,900 --> 00:26:22,860
holding us back is

00:26:20,730 --> 00:26:24,900
in practice with this you know lots of

00:26:22,860 --> 00:26:27,390
examples hopefully you guys can make

00:26:24,900 --> 00:26:28,020
good use of that if you want to try it

00:26:27,390 --> 00:26:31,740
out on your own

00:26:28,020 --> 00:26:33,419
you've got the read the docs very very

00:26:31,740 --> 00:26:35,190
good documentation there are lots of

00:26:33,419 --> 00:26:38,130
lots of information I pulled most of the

00:26:35,190 --> 00:26:40,110
things from that if you're using Python

00:26:38,130 --> 00:26:41,880
- you can just pip install it for using

00:26:40,110 --> 00:26:44,280
Python 3 it's already built in so it's

00:26:41,880 --> 00:26:45,960
already there which is great the way I

00:26:44,280 --> 00:26:48,059
learned was basically creating a bunch

00:26:45,960 --> 00:26:49,830
of simple test classes and trying it out

00:26:48,059 --> 00:26:52,020
and writing unit tests around it just to

00:26:49,830 --> 00:26:53,429
get practice so let's go out and write

00:26:52,020 --> 00:27:04,169
some tests yay

00:26:53,429 --> 00:27:22,169
do it alright questions went up to the

00:27:04,169 --> 00:27:24,179
mic especially because we're dealing

00:27:22,169 --> 00:27:25,470
frameworks like Django I mean it's

00:27:24,179 --> 00:27:28,860
obviously not alone and I know that

00:27:25,470 --> 00:27:30,870
there's levels to magic if I can go but

00:27:28,860 --> 00:27:34,020
there's still a lot of magic yeah and so

00:27:30,870 --> 00:27:38,429
whatever it is do because I'm dealing

00:27:34,020 --> 00:27:40,260
with yes I said which is great for

00:27:38,429 --> 00:27:42,360
practice but like we're talking about

00:27:40,260 --> 00:27:43,800
all right well you know there may be

00:27:42,360 --> 00:27:49,140
this

00:27:43,800 --> 00:27:54,300
you'll type that is part model and so

00:27:49,140 --> 00:27:59,640
it's just I know what's a good source

00:27:54,300 --> 00:28:03,060
for looking for examples for mocks that

00:27:59,640 --> 00:28:04,860
would really kind of neat to be a bit in

00:28:03,060 --> 00:28:06,270
perspective to do the right thing

00:28:04,860 --> 00:28:09,090
because I mean like you have a situation

00:28:06,270 --> 00:28:12,090
where a model field for instance you

00:28:09,090 --> 00:28:14,850
know the general universe is can't be

00:28:12,090 --> 00:28:19,200
empty or you can't write to the models

00:28:14,850 --> 00:28:22,110
you actually do some tests on so sure so

00:28:19,200 --> 00:28:23,670
I actually I thought I spent a lot of

00:28:22,110 --> 00:28:26,070
time thinking about this sort of problem

00:28:23,670 --> 00:28:28,170
this is a great question to to sort of I

00:28:26,070 --> 00:28:30,210
work with a lot of more junior

00:28:28,170 --> 00:28:32,160
developers and they say like well at

00:28:30,210 --> 00:28:34,920
what point in time is it like in Django

00:28:32,160 --> 00:28:37,200
land or like in sort of generic custom

00:28:34,920 --> 00:28:38,370
code land you know and I asked them you

00:28:37,200 --> 00:28:39,240
know what thing are you trying to test

00:28:38,370 --> 00:28:40,950
or you're trying to test the integration

00:28:39,240 --> 00:28:43,320
of how Django fits together or are you

00:28:40,950 --> 00:28:46,290
trying to test some custom logic that

00:28:43,320 --> 00:28:48,060
you wrote in some cases it makes sense

00:28:46,290 --> 00:28:49,650
to use like Django's test Runner and

00:28:48,060 --> 00:28:52,470
sometimes it makes sense to use Django

00:28:49,650 --> 00:28:55,080
is clients in other cases it doesn't for

00:28:52,470 --> 00:28:57,090
like mocking out models that have

00:28:55,080 --> 00:28:59,610
particular fields you can put in like a

00:28:57,090 --> 00:29:01,470
you can give it a spec when you create

00:28:59,610 --> 00:29:04,050
sure when you create your mock and that

00:29:01,470 --> 00:29:05,880
at least helps somewhat but in other

00:29:04,050 --> 00:29:07,620
cases it almost makes more sense to just

00:29:05,880 --> 00:29:09,360
use like Django's test run or just test

00:29:07,620 --> 00:29:11,220
client and grab data from a fixture so

00:29:09,360 --> 00:29:12,990
it's sort of like they're like oh no

00:29:11,220 --> 00:29:14,880
you're saying you said only these mocks

00:29:12,990 --> 00:29:16,950
ever you know it's like well be

00:29:14,880 --> 00:29:18,390
pragmatic right if I'm trying to test

00:29:16,950 --> 00:29:19,650
something that I'm getting out of a

00:29:18,390 --> 00:29:21,360
database and it has a complex

00:29:19,650 --> 00:29:23,580
relationship that I want to test and

00:29:21,360 --> 00:29:26,040
they want to make good use of that's not

00:29:23,580 --> 00:29:28,890
this sort of a logic per se it's custom

00:29:26,040 --> 00:29:31,770
but we should be using we could be using

00:29:28,890 --> 00:29:33,360
the stuff that Django has built in that

00:29:31,770 --> 00:29:35,370
it makes sense there you know and it's

00:29:33,360 --> 00:29:37,620
sort of a it's more of a murky area you

00:29:35,370 --> 00:29:39,180
know it's not a good clear and hard rule

00:29:37,620 --> 00:29:41,160
unlike you need to just use this

00:29:39,180 --> 00:29:43,590
particular thing or you only do it in

00:29:41,160 --> 00:29:46,470
this case it's sort of if it makes sense

00:29:43,590 --> 00:29:49,020
and it's pragmatic do it that way if it

00:29:46,470 --> 00:29:51,840
causes you a lot of pain and effort then

00:29:49,020 --> 00:29:54,179
you know don't do it does that makes it

00:29:51,840 --> 00:29:55,980
does that answer your question

00:29:54,179 --> 00:29:59,220
so much has been through those scenarios

00:29:55,980 --> 00:30:03,570
where I really feel like it's my lack of

00:29:59,220 --> 00:30:06,179
knowledge black alive how to do it

00:30:03,570 --> 00:30:11,330
because you know throw those cases where

00:30:06,179 --> 00:30:11,330
no I really I would like that to appear

00:30:24,409 --> 00:30:39,869
right but I feel like the hybrid

00:30:35,330 --> 00:30:41,190
integration right exactly so it's

00:30:39,869 --> 00:30:42,869
because it's making calls to the

00:30:41,190 --> 00:30:44,700
database because it's making calls to

00:30:42,869 --> 00:30:46,529
bits and pieces of Django like I'm

00:30:44,700 --> 00:30:48,269
driving a setting or whatever like you

00:30:46,529 --> 00:30:49,860
know it's something that isn't really

00:30:48,269 --> 00:30:52,889
gonna test it's more of an integration

00:30:49,860 --> 00:30:54,600
test and at the end of the day like it's

00:30:52,889 --> 00:30:56,399
not it's not the end of the world like

00:30:54,600 --> 00:30:58,830
it's good to have integration tests and

00:30:56,399 --> 00:31:00,330
it's perfectly okay to do that you know

00:30:58,830 --> 00:31:01,889
it's I mean you're writing tests that's

00:31:00,330 --> 00:31:05,759
good no matter what you know you're

00:31:01,889 --> 00:31:07,499
making your code better but it I feel

00:31:05,759 --> 00:31:09,570
for you I I have the same problem and I

00:31:07,499 --> 00:31:12,539
don't really have like a great solution

00:31:09,570 --> 00:31:14,999
for it you know I know I know next next

00:31:12,539 --> 00:31:16,440
year we will work on this but it's a

00:31:14,999 --> 00:31:20,909
great question something I've been

00:31:16,440 --> 00:31:22,970
thinking a lot about one question I

00:31:20,909 --> 00:31:25,889
would ask is I've spent a lot of time

00:31:22,970 --> 00:31:29,850
recently dealing with a lot of soap

00:31:25,889 --> 00:31:32,340
api's or very heavy external reliance on

00:31:29,850 --> 00:31:34,230
services that aren't always documented

00:31:32,340 --> 00:31:37,919
for how they're gonna behave in certain

00:31:34,230 --> 00:31:40,049
instances do you have any kind of tips

00:31:37,919 --> 00:31:42,690
or pointers on how to use mocking in

00:31:40,049 --> 00:31:44,700
order to make some of that stuff easier

00:31:42,690 --> 00:31:45,749
who this is and this kind of gets it

00:31:44,700 --> 00:31:48,809
like one of the things that's kind of

00:31:45,749 --> 00:31:52,019
tricky with mocking too is that with a

00:31:48,809 --> 00:31:54,210
mock one of the downsides of using a

00:31:52,019 --> 00:31:56,309
mock is that it will just allow you to

00:31:54,210 --> 00:31:57,539
call whatever on it it just it will say

00:31:56,309 --> 00:31:59,100
like oh that method even if it

00:31:57,539 --> 00:32:01,289
technically should exist or should not

00:31:59,100 --> 00:32:02,490
exist it'll say like oh that's fine

00:32:01,289 --> 00:32:04,019
you called it I mean I don't know if

00:32:02,490 --> 00:32:05,999
it's there or not but because it's a

00:32:04,019 --> 00:32:07,860
dynamic language when working with

00:32:05,999 --> 00:32:10,309
something more it's it's a little

00:32:07,860 --> 00:32:12,960
or like unknown or it's a little bit

00:32:10,309 --> 00:32:16,770
confusing of where you know what things

00:32:12,960 --> 00:32:20,250
should be the best the best advice I

00:32:16,770 --> 00:32:22,980
guess I can offer on that is if it's

00:32:20,250 --> 00:32:25,260
uncertain then make it something that's

00:32:22,980 --> 00:32:26,520
explicit in your test so if the idea is

00:32:25,260 --> 00:32:28,350
like I don't actually know if these

00:32:26,520 --> 00:32:31,020
fields are there so I find this lot

00:32:28,350 --> 00:32:32,309
wanting integrate with an API I'll do

00:32:31,020 --> 00:32:33,750
great with other people who have written

00:32:32,309 --> 00:32:35,100
an API and it's like well it kind of

00:32:33,750 --> 00:32:37,650
works this way but they don't have

00:32:35,100 --> 00:32:38,910
really strong documentation and I want

00:32:37,650 --> 00:32:40,290
my stuff to be bulletproof and what

00:32:38,910 --> 00:32:42,510
might have to be very very you know

00:32:40,290 --> 00:32:45,809
concrete and well-defined what you want

00:32:42,510 --> 00:32:47,730
is your test to fail if that method or

00:32:45,809 --> 00:32:50,429
that thing doesn't exist there right so

00:32:47,730 --> 00:32:51,870
hey this this method doesn't you know I

00:32:50,429 --> 00:32:53,340
was expecting that this thing would be

00:32:51,870 --> 00:32:55,650
there I was expecting that this method

00:32:53,340 --> 00:32:57,450
would be available but it wasn't and

00:32:55,650 --> 00:32:59,520
then that forces a discussion between

00:32:57,450 --> 00:33:02,190
you and either the people who maintain

00:32:59,520 --> 00:33:03,480
the API or it raises a red flag for you

00:33:02,190 --> 00:33:05,160
and you go oh crap this thing was

00:33:03,480 --> 00:33:06,510
supposed to be there it you know is an

00:33:05,160 --> 00:33:09,929
assumption that I had made that it would

00:33:06,510 --> 00:33:11,490
be there but I'm you know and I know

00:33:09,929 --> 00:33:13,440
I'll have to rewrite some things to make

00:33:11,490 --> 00:33:13,830
sure that I accommodate that does that

00:33:13,440 --> 00:33:30,330
make sense

00:33:13,830 --> 00:33:33,660
cool other questions go for it exactly

00:33:30,330 --> 00:33:36,000
so yes thank you so much the crate

00:33:33,660 --> 00:33:37,830
aspect will allow you to like it'll

00:33:36,000 --> 00:33:39,150
figure out what the methods are supposed

00:33:37,830 --> 00:33:40,380
to be on there and then if you try and

00:33:39,150 --> 00:33:43,020
call one that doesn't belong to that

00:33:40,380 --> 00:33:45,270
class then it will it will raise an

00:33:43,020 --> 00:33:46,429
exception instead so yes excellent point

00:33:45,270 --> 00:33:50,960
thank you

00:33:46,429 --> 00:33:50,960
anyone else yeah

00:33:55,419 --> 00:34:01,549
I tend to to be honest I tend to write

00:33:59,299 --> 00:34:03,230
my code and then I read the tests but

00:34:01,549 --> 00:34:06,049
this is sort of I was talking about this

00:34:03,230 --> 00:34:07,460
with the with a junior developer and he

00:34:06,049 --> 00:34:09,589
was trying to learn try to learn Django

00:34:07,460 --> 00:34:12,950
trying to learn Python and the challenge

00:34:09,589 --> 00:34:14,780
he kept running into was he would he

00:34:12,950 --> 00:34:17,000
would try and write a test first but he

00:34:14,780 --> 00:34:18,919
didn't really understand or know what

00:34:17,000 --> 00:34:20,419
the expected results should be so

00:34:18,919 --> 00:34:21,530
because he didn't really know or

00:34:20,419 --> 00:34:23,810
understand what the expected result

00:34:21,530 --> 00:34:25,429
should be it was hard for him to write a

00:34:23,810 --> 00:34:27,320
test because he spent more time sort of

00:34:25,429 --> 00:34:28,909
noodling around and figuring it and and

00:34:27,320 --> 00:34:31,190
what I wanted him to do was more

00:34:28,909 --> 00:34:33,409
experimentation and sort of what happens

00:34:31,190 --> 00:34:34,879
when you call this what does this do and

00:34:33,409 --> 00:34:36,829
then verify your assumptions with

00:34:34,879 --> 00:34:38,599
testing I like that approach and I think

00:34:36,829 --> 00:34:42,040
that that makes a lot more sense and

00:34:38,599 --> 00:34:43,579
less less topsy-turvy you know it's it's

00:34:42,040 --> 00:34:46,240
easier for me

00:34:43,579 --> 00:34:49,099
cognitively to think about that like but

00:34:46,240 --> 00:34:51,530
in the TDD vein I would say work on a

00:34:49,099 --> 00:34:53,270
small section of code stop and write

00:34:51,530 --> 00:34:55,849
tests for it to verify that that thing

00:34:53,270 --> 00:34:58,069
works and then move on versus sort of

00:34:55,849 --> 00:34:59,930
writing the tests first you know and

00:34:58,069 --> 00:35:02,930
then trying to write your code so it's

00:34:59,930 --> 00:35:05,720
sort of it's not exactly TDD I'm not I'm

00:35:02,930 --> 00:35:07,310
not an evangelist for us but if you were

00:35:05,720 --> 00:35:09,680
writing tests in any capacity I think

00:35:07,310 --> 00:35:11,869
you're at least doing something better

00:35:09,680 --> 00:35:17,510
for yourself you're your quantifiably

00:35:11,869 --> 00:35:20,060
making your code high-quality so I I

00:35:17,510 --> 00:35:21,530
think we're sort of getting close to to

00:35:20,060 --> 00:35:23,240
this question with with your last answer

00:35:21,530 --> 00:35:25,430
but what are the challenges with this

00:35:23,240 --> 00:35:28,550
kind of approach is that it makes it

00:35:25,430 --> 00:35:30,050
it's very like you have to know about

00:35:28,550 --> 00:35:32,359
the implementation in order to know what

00:35:30,050 --> 00:35:33,770
to mock right so you end up having kind

00:35:32,359 --> 00:35:35,810
of brittle tests that are associated

00:35:33,770 --> 00:35:37,040
with the implementation way more than

00:35:35,810 --> 00:35:39,079
you might like do you have any

00:35:37,040 --> 00:35:40,760
strategies that you might recommend for

00:35:39,079 --> 00:35:42,770
avoiding that kind of problem you say

00:35:40,760 --> 00:35:45,319
like brittle can you clarify well I mean

00:35:42,770 --> 00:35:47,270
like you know that that get random

00:35:45,319 --> 00:35:48,800
person is being called by that funnel

00:35:47,270 --> 00:35:50,480
right so you have to know exactly what

00:35:48,800 --> 00:35:53,329
to mock inside the implementation of

00:35:50,480 --> 00:35:58,000
testing I know like I've thought about

00:35:53,329 --> 00:36:02,510
this a good bit on it seems to me like

00:35:58,000 --> 00:36:04,010
when I when I write tests some of it at

00:36:02,510 --> 00:36:06,440
the end of the day I have to know how

00:36:04,010 --> 00:36:08,030
method functions somewhat you know the

00:36:06,440 --> 00:36:10,190
the actual details of how it gets

00:36:08,030 --> 00:36:12,650
implemented can shift but when I write a

00:36:10,190 --> 00:36:14,480
test I'm sort of like saying setting in

00:36:12,650 --> 00:36:16,640
stone what I want this to be and how I

00:36:14,480 --> 00:36:17,900
want it to behave so it's sort of a with

00:36:16,640 --> 00:36:19,490
that point where the rubber meets the

00:36:17,900 --> 00:36:23,030
road so I don't think it's necessarily

00:36:19,490 --> 00:36:25,250
brittleness it's sort of like okay I am

00:36:23,030 --> 00:36:26,390
writing down in code exactly what I

00:36:25,250 --> 00:36:28,550
think this method should do it exactly

00:36:26,390 --> 00:36:30,020
how I think it should behave you know if

00:36:28,550 --> 00:36:31,340
I think it should call this method it's

00:36:30,020 --> 00:36:33,260
gonna call this method and when somebody

00:36:31,340 --> 00:36:34,880
changes it to not call that method

00:36:33,260 --> 00:36:37,430
because they refactored it that test

00:36:34,880 --> 00:36:39,020
will fail and that's good that forces

00:36:37,430 --> 00:36:40,670
that like oh shoot I changed something

00:36:39,020 --> 00:36:42,440
you know was this a valid test is this

00:36:40,670 --> 00:36:44,390
still a valid test that we need to go

00:36:42,440 --> 00:36:46,070
through so it's not necessarily you know

00:36:44,390 --> 00:36:48,740
obviously we're trying to capture some

00:36:46,070 --> 00:36:50,750
of the logic of it you know so in the

00:36:48,740 --> 00:36:53,030
examples it's you know I know these

00:36:50,750 --> 00:36:55,340
methods are being called but they fill

00:36:53,030 --> 00:36:56,840
in the logic of my decision tree you

00:36:55,340 --> 00:36:58,220
know the things that I'm trying to test

00:36:56,840 --> 00:37:00,680
and the logic that I'm trying to put in

00:36:58,220 --> 00:37:05,090
so it's sort of a it's a grey area of

00:37:00,680 --> 00:37:06,830
sorts you know I guess in regards to

00:37:05,090 --> 00:37:09,140
some of the brittle problems something

00:37:06,830 --> 00:37:11,990
that I've depends on the problem but a

00:37:09,140 --> 00:37:13,610
lot of times I'll have a fixture and my

00:37:11,990 --> 00:37:15,740
mock will load a fixture that I've

00:37:13,610 --> 00:37:17,800
generated and I'll use a make file to

00:37:15,740 --> 00:37:20,810
document how I generated that fixture

00:37:17,800 --> 00:37:23,870
but my question for you is do you have

00:37:20,810 --> 00:37:25,910
any experience with mocking daytime I've

00:37:23,870 --> 00:37:30,770
gotten it to work a few times I always

00:37:25,910 --> 00:37:32,480
get it to work if you if you just use

00:37:30,770 --> 00:37:35,720
mock on daytime it won't work because

00:37:32,480 --> 00:37:37,520
it's a sea thing right but uh there's a

00:37:35,720 --> 00:37:38,990
library that helps I've always managed

00:37:37,520 --> 00:37:40,460
to get to work without resorting to

00:37:38,990 --> 00:37:41,930
installing another library just

00:37:40,460 --> 00:37:43,550
wondering what your personal experiences

00:37:41,930 --> 00:37:45,140
no actually I haven't I haven't worked

00:37:43,550 --> 00:37:47,270
with that surprisingly so thank

00:37:45,140 --> 00:37:49,460
thankfully I have not been involved in

00:37:47,270 --> 00:37:51,950
like time zones and that sort of stuff

00:37:49,460 --> 00:37:55,960
so I unfortunately don't have any wisdom

00:37:51,950 --> 00:37:55,960
there for you but best of luck

00:37:56,550 --> 00:38:02,640
I feel I feel your pain you know Oh

00:38:02,940 --> 00:38:05,940
arrow

00:38:12,180 --> 00:38:18,600
cool out to check that out so arrow for

00:38:14,770 --> 00:38:18,600

YouTube URL: https://www.youtube.com/watch?v=DqwtbRExNa0


