Title: DjangoCon 2019 - Static Typing in Python by Dustin Ingram
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - Static Typing in Python by Dustin Ingram

In this talk, we'll discuss the advantages and disadvantages to a static type system, as well as recent efforts to introduce static typing to Python via optional "type hints" and various tools to aid in adding types to Python code.

This talk was presented at: https://2019.djangocon.us/talks/static-typing-in-python/

LINKS:
Follow Dustin Ingram ğŸ‘‡
On Twitter: https://twitter.com/di_codes
Official homepage: https://di.codes

Follow DjangCon US ğŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ğŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:12,679
[Music]

00:00:14,469 --> 00:00:19,730
thanks everyone so hey I'm Dustin quick

00:00:17,960 --> 00:00:21,380
and true about me so I'm gonna developer

00:00:19,730 --> 00:00:22,480
advocate at Google that means I

00:00:21,380 --> 00:00:24,260
represent the Python community

00:00:22,480 --> 00:00:26,930
internally at Google when we build

00:00:24,260 --> 00:00:28,670
products for Python Easter's I'm also

00:00:26,930 --> 00:00:30,590
the chair for PI Texas by the way it's

00:00:28,670 --> 00:00:33,320
going to be in Austin this year or next

00:00:30,590 --> 00:00:35,180
year sorry May 16 17 so you should come

00:00:33,320 --> 00:00:38,290
to Austin come hang out go to PI Texas I

00:00:35,180 --> 00:00:40,370
also work on the Python package index

00:00:38,290 --> 00:00:43,250
pretty cool Python infrastructure that

00:00:40,370 --> 00:00:44,330
I'm sure you all use I'm not actually

00:00:43,250 --> 00:00:46,790
gonna talk about any of those things

00:00:44,330 --> 00:00:48,620
today so we're gonna talk about static

00:00:46,790 --> 00:00:51,949
typing quick pop quiz so everyone in the

00:00:48,620 --> 00:00:53,839
room is Python dynamically typed or is

00:00:51,949 --> 00:00:57,019
it statically typed so who thinks it's

00:00:53,839 --> 00:00:58,309
dynamically typed and who things that

00:00:57,019 --> 00:01:00,019
like alright this talks about static

00:00:58,309 --> 00:01:02,839
typing a Python it's probably statically

00:01:00,019 --> 00:01:04,330
typed maybe how about who thinks this is

00:01:02,839 --> 00:01:08,510
a trick question

00:01:04,330 --> 00:01:10,490
okay it's kind of a trick question the

00:01:08,510 --> 00:01:13,670
answer is that Python is dynamically

00:01:10,490 --> 00:01:16,579
typed but can optionally be a statically

00:01:13,670 --> 00:01:17,899
typed as you want it to be so the answer

00:01:16,579 --> 00:01:19,579
to that might not actually make a lot of

00:01:17,899 --> 00:01:22,369
sense if you're not super familiar with

00:01:19,579 --> 00:01:23,539
typing and type systems so that's okay

00:01:22,369 --> 00:01:24,740
that means that you're in the right talk

00:01:23,539 --> 00:01:26,630
if that doesn't make sense to you and

00:01:24,740 --> 00:01:28,159
we're gonna explain that and the steps

00:01:26,630 --> 00:01:29,329
to understand answer that question are

00:01:28,159 --> 00:01:32,740
basically this we're gonna talk about

00:01:29,329 --> 00:01:35,359
types in Python type systems in general

00:01:32,740 --> 00:01:37,219
dynamic typing in Python and then static

00:01:35,359 --> 00:01:38,539
typing in Python and then once we sort

00:01:37,219 --> 00:01:40,820
of understand what static typing in

00:01:38,539 --> 00:01:42,530
Python means we'll talk about how to use

00:01:40,820 --> 00:01:45,320
static typing when you should use it and

00:01:42,530 --> 00:01:47,270
when you shouldn't use it so let's talk

00:01:45,320 --> 00:01:50,119
about types and specifically let's talk

00:01:47,270 --> 00:01:52,009
about type when I say type I mean the

00:01:50,119 --> 00:01:55,880
type built-in in your Python interpreter

00:01:52,009 --> 00:01:57,619
so in your Python repple you could type

00:01:55,880 --> 00:01:59,929
something like this type 42 and this

00:01:57,619 --> 00:02:02,390
will tell you that 42 is an int it's an

00:01:59,929 --> 00:02:05,450
integer you can also type other things

00:02:02,390 --> 00:02:08,210
so the type of 42.0 is a float type of

00:02:05,450 --> 00:02:09,860
fluid string type of that is list and

00:02:08,210 --> 00:02:12,200
you might say okay I recognize these

00:02:09,860 --> 00:02:14,330
things that are coming out of the type

00:02:12,200 --> 00:02:16,280
function these are like the built-ins

00:02:14,330 --> 00:02:19,220
that I can use to change one type to

00:02:16,280 --> 00:02:21,890
another right so you can take integer

00:02:19,220 --> 00:02:23,330
like a here and you can sometimes we

00:02:21,890 --> 00:02:26,240
call this casting cast it to a

00:02:23,330 --> 00:02:29,000
float cast it to a string cast it to a

00:02:26,240 --> 00:02:30,500
really ugly list so who's seen a really

00:02:29,000 --> 00:02:31,850
ugly list like this before where a

00:02:30,500 --> 00:02:33,140
string is getting turned into a list

00:02:31,850 --> 00:02:35,420
right okay have you seen that before

00:02:33,140 --> 00:02:36,980
that's a type error you've had a type

00:02:35,420 --> 00:02:38,810
error in your code and something that

00:02:36,980 --> 00:02:42,530
was expecting a list got a string

00:02:38,810 --> 00:02:44,330
instead so it would also something like

00:02:42,530 --> 00:02:46,700
these are the only types available to us

00:02:44,330 --> 00:02:48,950
but that's not entirely true so these

00:02:46,700 --> 00:02:51,710
are just basically some mappers to

00:02:48,950 --> 00:02:54,380
classes that exist so interior is just a

00:02:51,710 --> 00:02:57,230
class so I can say the type of 42 is an

00:02:54,380 --> 00:02:59,000
int I get a class of int from int and is

00:02:57,230 --> 00:03:00,560
instance 42 int is the same thing as

00:02:59,000 --> 00:03:02,570
doing class matching if something is an

00:03:00,560 --> 00:03:05,060
instance of another class so there are

00:03:02,570 --> 00:03:07,310
more types than just in string float

00:03:05,060 --> 00:03:10,370
right so there's none type we've all

00:03:07,310 --> 00:03:12,320
seen none type before but you can only

00:03:10,370 --> 00:03:15,050
get it by calling type on none there's

00:03:12,320 --> 00:03:17,540
also a function type so when we define a

00:03:15,050 --> 00:03:20,600
function we don't say like function blah

00:03:17,540 --> 00:03:21,980
blah we say def function name etc and

00:03:20,600 --> 00:03:24,770
there's like an ellipses type there's

00:03:21,980 --> 00:03:26,690
lots of types and in fact if you are in

00:03:24,770 --> 00:03:30,050
your Python wrap one you import types

00:03:26,690 --> 00:03:31,880
you get this whole list of all sorts of

00:03:30,050 --> 00:03:34,130
types of things that you could have in

00:03:31,880 --> 00:03:36,230
your Python code and so these all live

00:03:34,130 --> 00:03:38,870
in the types module and they actually

00:03:36,230 --> 00:03:41,269
can be used to instantiate a new thing

00:03:38,870 --> 00:03:42,590
like whatever this is you can call open

00:03:41,269 --> 00:03:44,510
closed parentheses on it with some

00:03:42,590 --> 00:03:46,519
arguments and create a new like a new

00:03:44,510 --> 00:03:48,260
function type but there's a reason we

00:03:46,519 --> 00:03:51,890
don't do this it looks really messy and

00:03:48,260 --> 00:03:53,780
there's like a lot of code to it so when

00:03:51,890 --> 00:03:56,900
we say python is a dynamically typed

00:03:53,780 --> 00:03:58,940
language what it means is that variables

00:03:56,900 --> 00:04:01,670
can be any type at all and they can

00:03:58,940 --> 00:04:03,860
change so for example if I imported

00:04:01,670 --> 00:04:05,330
random and I called random choice on

00:04:03,860 --> 00:04:07,160
this list of things that are an integer

00:04:05,330 --> 00:04:09,320
or a float in a string and I call type

00:04:07,160 --> 00:04:12,890
of the result of that what's the result

00:04:09,320 --> 00:04:14,540
like what type is a gonna be it could be

00:04:12,890 --> 00:04:15,980
any of these right it could be a string

00:04:14,540 --> 00:04:17,060
and int or float and it depends on the

00:04:15,980 --> 00:04:18,830
outcome from random

00:04:17,060 --> 00:04:20,419
so it doesn't matter what I'm putting in

00:04:18,830 --> 00:04:23,630
that variable it can contain any of

00:04:20,419 --> 00:04:25,370
these types dynamic typing also means

00:04:23,630 --> 00:04:27,740
that the arguments and the return types

00:04:25,370 --> 00:04:29,870
of functions can also be any type right

00:04:27,740 --> 00:04:32,870
so the same is true for the arguments

00:04:29,870 --> 00:04:34,340
and the return values of any function so

00:04:32,870 --> 00:04:37,220
if I create a function like this frog

00:04:34,340 --> 00:04:40,400
negate takes two three parameters ABC

00:04:37,220 --> 00:04:42,770
return is a plus B plus C so in Python

00:04:40,400 --> 00:04:44,810
when we write a function like this how

00:04:42,770 --> 00:04:46,520
do we know that we're getting the type

00:04:44,810 --> 00:04:48,260
that we're expecting out of it right so

00:04:46,520 --> 00:04:49,850
if you saw this function and you had no

00:04:48,260 --> 00:04:52,310
idea what frog Nicki meant because it's

00:04:49,850 --> 00:04:53,720
a made-up word what would you expect the

00:04:52,310 --> 00:04:56,300
arguments to be here and what would you

00:04:53,720 --> 00:04:58,400
expect a return type to be so you might

00:04:56,300 --> 00:05:00,380
say like it might make sense for these

00:04:58,400 --> 00:05:02,090
to be integers right so I define the

00:05:00,380 --> 00:05:03,740
function I can call from the gate 1 2 3

00:05:02,090 --> 00:05:05,840
and I get 6 the sum of all these

00:05:03,740 --> 00:05:07,550
integers but also like a call from

00:05:05,840 --> 00:05:09,050
Nikita with strings I can call from

00:05:07,550 --> 00:05:10,160
Nikita with 3 strings and it would

00:05:09,050 --> 00:05:12,290
concatenate those strings

00:05:10,160 --> 00:05:14,020
it's totally valid and it only works the

00:05:12,290 --> 00:05:16,370
function can return integers or strings

00:05:14,020 --> 00:05:18,560
however what I can't do is I can't mix

00:05:16,370 --> 00:05:20,930
these types now because I can't actually

00:05:18,560 --> 00:05:22,400
use the plus operator on a mixture of

00:05:20,930 --> 00:05:24,440
strings and integers so that blows up

00:05:22,400 --> 00:05:26,360
and that creates a type error so it'd be

00:05:24,440 --> 00:05:27,770
great if we could say what this function

00:05:26,360 --> 00:05:30,190
actually is expecting for all these

00:05:27,770 --> 00:05:34,010
arguments on what is expecting to return

00:05:30,190 --> 00:05:36,950
so one thing we could do is write a

00:05:34,010 --> 00:05:38,990
really long and nice doc string doc

00:05:36,950 --> 00:05:40,610
string that lists all the arguments and

00:05:38,990 --> 00:05:43,550
the return types and what they aren't

00:05:40,610 --> 00:05:45,740
and comments who does this does anyone

00:05:43,550 --> 00:05:48,410
do this does your employer pay you

00:05:45,740 --> 00:05:51,170
enough to do this this takes a lot of

00:05:48,410 --> 00:05:52,880
work right it's a long comment and you

00:05:51,170 --> 00:05:54,560
know you gotta write it all out

00:05:52,880 --> 00:05:55,940
it also doesn't actually change the

00:05:54,560 --> 00:05:57,950
evaluation of the function area you can

00:05:55,940 --> 00:05:59,930
still call this with with strings and

00:05:57,950 --> 00:06:01,640
it's still gonna return the string and

00:05:59,930 --> 00:06:05,210
it's just a little handy guide there for

00:06:01,640 --> 00:06:07,190
the developer we could do this so we

00:06:05,210 --> 00:06:09,770
could write a function we get assert on

00:06:07,190 --> 00:06:11,180
every single argument that we get do our

00:06:09,770 --> 00:06:13,220
business logic or whatever we need to do

00:06:11,180 --> 00:06:17,390
and then assert on the return type and

00:06:13,220 --> 00:06:18,620
then actually return it I was I said in

00:06:17,390 --> 00:06:20,660
a previous talk one time I showed this

00:06:18,620 --> 00:06:21,620
example I said yeah nobody does this and

00:06:20,660 --> 00:06:24,440
then someone came up afterwards and

00:06:21,620 --> 00:06:26,360
they're like well actually we do did you

00:06:24,440 --> 00:06:28,100
do this and so the reason you don't

00:06:26,360 --> 00:06:29,360
wanna do this is because each assertion

00:06:28,100 --> 00:06:31,220
well I mean while this works

00:06:29,360 --> 00:06:32,419
each assertion adds just a little bit of

00:06:31,220 --> 00:06:33,980
overhead to your function call right

00:06:32,419 --> 00:06:36,890
because that happens at runtime each

00:06:33,980 --> 00:06:38,750
assertion so you know while it's modest

00:06:36,890 --> 00:06:39,800
there's a small performance problem

00:06:38,750 --> 00:06:41,240
there and also you know it's a little

00:06:39,800 --> 00:06:43,430
bit messy looking to have all those

00:06:41,240 --> 00:06:45,860
asserts all together so we don't really

00:06:43,430 --> 00:06:48,500
do that what do we do instead in Python

00:06:45,860 --> 00:06:50,230
we do something called duck typing so

00:06:48,500 --> 00:06:52,090
instead we

00:06:50,230 --> 00:06:53,590
duck shaking is if it walks like a duck

00:06:52,090 --> 00:06:55,690
and it quacks like a duck it's probably

00:06:53,590 --> 00:06:57,400
a duck so we sort of absorb the way that

00:06:55,690 --> 00:06:59,290
we interact with functions and variables

00:06:57,400 --> 00:07:01,390
and we can sort of infer what the types

00:06:59,290 --> 00:07:04,810
are from that so for example in these

00:07:01,390 --> 00:07:06,760
examples right I'm setting food to list

00:07:04,810 --> 00:07:08,560
comprehension calling f of X on X and

00:07:06,760 --> 00:07:10,810
bar bar is probably some iterable it's

00:07:08,560 --> 00:07:13,300
something like a list or a string and

00:07:10,810 --> 00:07:15,430
the second line foo is bar greater than

00:07:13,300 --> 00:07:16,720
zero so bar is probably an inch or

00:07:15,430 --> 00:07:18,760
something I can compare to an integer

00:07:16,720 --> 00:07:21,040
and foo is going to end up being like a

00:07:18,760 --> 00:07:22,330
boolean and in the last one bar is

00:07:21,040 --> 00:07:24,340
something I can call and close

00:07:22,330 --> 00:07:25,810
parenthesis on but it means it could be

00:07:24,340 --> 00:07:27,160
a function or it could be a list so I

00:07:25,810 --> 00:07:30,100
could still actually kind of ambiguous

00:07:27,160 --> 00:07:32,320
what this is and usually if it was if it

00:07:30,100 --> 00:07:33,490
was a class that was calling or sorry it

00:07:32,320 --> 00:07:34,540
could be a function over our class if it

00:07:33,490 --> 00:07:36,430
was a class barb

00:07:34,540 --> 00:07:39,010
we'd probably capitalize it but you know

00:07:36,430 --> 00:07:43,420
not always it's not required so it could

00:07:39,010 --> 00:07:45,460
be anything so static typing means that

00:07:43,420 --> 00:07:46,840
these variables and the return types and

00:07:45,460 --> 00:07:48,610
arguments to function are not going to

00:07:46,840 --> 00:07:49,690
change they're defined what the type is

00:07:48,610 --> 00:07:51,490
going to be and it's not going to change

00:07:49,690 --> 00:07:54,100
and so there are actually a lot of

00:07:51,490 --> 00:07:55,870
statically typed languages so I want to

00:07:54,100 --> 00:07:57,310
show you some examples of that same

00:07:55,870 --> 00:07:59,740
function f R Abenaki function in

00:07:57,310 --> 00:08:02,470
multiple languages so does anyone know

00:07:59,740 --> 00:08:06,280
which language is this I heard it yeah

00:08:02,470 --> 00:08:07,990
see let's see how about this one Java

00:08:06,280 --> 00:08:11,770
yeah that's a dead giveaway with like

00:08:07,990 --> 00:08:14,650
public static you know anyone know what

00:08:11,770 --> 00:08:16,000
this one is yeah every time I do this

00:08:14,650 --> 00:08:17,370
talk and the Russell comes listens like

00:08:16,000 --> 00:08:19,480
yeah that's rust I know rust

00:08:17,370 --> 00:08:21,340
yeah that's rust because it rust

00:08:19,480 --> 00:08:23,110
actually has really fine grain that's an

00:08:21,340 --> 00:08:25,420
unsigned 8-bit integer for the argument

00:08:23,110 --> 00:08:26,890
types there so you can say exactly what

00:08:25,420 --> 00:08:32,110
type of integer it is not just an

00:08:26,890 --> 00:08:33,760
integer how about this one I heard

00:08:32,110 --> 00:08:36,220
JavaScript but it's actually typescript

00:08:33,760 --> 00:08:37,060
it's typed of JavaScript the way the way

00:08:36,220 --> 00:08:39,130
you would know is that JavaScript

00:08:37,060 --> 00:08:41,020
actually has only one number type it's

00:08:39,130 --> 00:08:43,330
number like in the floats and integers

00:08:41,020 --> 00:08:44,830
everything is a number okay so you can

00:08:43,330 --> 00:08:47,290
sort of put languages into columns right

00:08:44,830 --> 00:08:49,540
dynamic languages are like Python Ruby

00:08:47,290 --> 00:08:52,510
closure and JavaScript static are like

00:08:49,540 --> 00:08:53,620
see rust and typescript and actually you

00:08:52,510 --> 00:08:54,880
have to put you know like a little

00:08:53,620 --> 00:08:56,980
asterisk next to python and we're going

00:08:54,880 --> 00:08:59,080
to talk about why because you can do

00:08:56,980 --> 00:09:01,000
some static typing things in python and

00:08:59,080 --> 00:09:03,509
also technically ruby is going to also

00:09:01,000 --> 00:09:05,609
get the same thing that python

00:09:03,509 --> 00:09:08,789
but not until end of next year so we'll

00:09:05,609 --> 00:09:11,639
ignore that so like I earlier said

00:09:08,789 --> 00:09:13,499
Python is dynamically typed but can

00:09:11,639 --> 00:09:16,939
optionally be a statically typed as you

00:09:13,499 --> 00:09:18,959
wanted to be so the story of that

00:09:16,939 --> 00:09:20,489
becoming true that wasn't always true

00:09:18,959 --> 00:09:22,349
right there was a point in time when

00:09:20,489 --> 00:09:24,899
Python was a purely a dynamically typed

00:09:22,349 --> 00:09:26,729
language and the story of Python

00:09:24,899 --> 00:09:28,379
becoming a language you could optionally

00:09:26,729 --> 00:09:31,379
stack the typed is also kind of the

00:09:28,379 --> 00:09:33,119
story of the evolution of code at

00:09:31,379 --> 00:09:37,709
Dropbox does anyone work at Dropbox you

00:09:33,119 --> 00:09:39,119
know so so Dropbox is large tech company

00:09:37,709 --> 00:09:41,129
and they're a Python shop also and they

00:09:39,119 --> 00:09:43,079
have millions of lines of Python code

00:09:41,129 --> 00:09:45,689
and basically at a certain point in

00:09:43,079 --> 00:09:47,609
their evolution as a company they

00:09:45,689 --> 00:09:49,919
realize that the fact that their Python

00:09:47,609 --> 00:09:52,109
code was lacking any kind of type system

00:09:49,919 --> 00:09:54,029
and type annotation it was actually

00:09:52,109 --> 00:09:55,679
slowing him down like was causing their

00:09:54,029 --> 00:09:56,609
developers to be less productive when

00:09:55,679 --> 00:09:58,679
they were looking at code because

00:09:56,609 --> 00:10:00,959
there's so much of it so intertangled

00:09:58,679 --> 00:10:02,759
there's so many different like areas of

00:10:00,959 --> 00:10:04,409
the code base and so they actually wrote

00:10:02,759 --> 00:10:05,879
a blog post you can go and find it on

00:10:04,409 --> 00:10:08,039
their blog it's super good and talks

00:10:05,879 --> 00:10:11,099
about sort of a little bit about the

00:10:08,039 --> 00:10:12,089
history of static typing at Dropbox but

00:10:11,099 --> 00:10:13,349
I'm gonna actually talk about the

00:10:12,089 --> 00:10:15,239
history of snacked editing Python which

00:10:13,349 --> 00:10:17,219
steps back a little bit from the start

00:10:15,239 --> 00:10:21,209
of it at Dropbox and so the start of it

00:10:17,219 --> 00:10:23,759
in Python starts here at pep 3107 this

00:10:21,209 --> 00:10:26,639
is the functions annotations pet we got

00:10:23,759 --> 00:10:27,929
this in 2006 and only in Python 3 and

00:10:26,639 --> 00:10:29,699
what this allowed us to do is take a

00:10:27,929 --> 00:10:32,059
function like this which is the same one

00:10:29,699 --> 00:10:35,039
I showed before and then we can add

00:10:32,059 --> 00:10:38,279
annotations any metadata that we want to

00:10:35,039 --> 00:10:39,449
the arguments and to the return type so

00:10:38,279 --> 00:10:41,849
these are types this is just like

00:10:39,449 --> 00:10:43,289
literally any Python code you want you

00:10:41,849 --> 00:10:45,569
could put in the annotation for this

00:10:43,289 --> 00:10:47,249
function and this has zero effect on the

00:10:45,569 --> 00:10:50,849
execution of the function what it does

00:10:47,249 --> 00:10:53,339
instead was it gives you this annotation

00:10:50,849 --> 00:10:55,559
stunned or annotations attribute and

00:10:53,339 --> 00:10:56,969
what it would do is evaluate the value

00:10:55,559 --> 00:10:58,799
of all those annotations would execute

00:10:56,969 --> 00:11:01,139
the annotations and so here it would say

00:10:58,799 --> 00:11:03,269
like ok a has this annotation a string

00:11:01,139 --> 00:11:07,499
of X B I've added five and six so now

00:11:03,269 --> 00:11:09,989
it's 11 C N and the return annotation so

00:11:07,499 --> 00:11:12,539
this is interesting and in the pet they

00:11:09,989 --> 00:11:14,939
sort of outlined some uses for these

00:11:12,539 --> 00:11:16,420
annotations right so all the uses kind

00:11:14,939 --> 00:11:18,100
of basically boil down to

00:11:16,420 --> 00:11:19,930
you can do interesting typing things

00:11:18,100 --> 00:11:21,250
with it and then also like maybe or you

00:11:19,930 --> 00:11:23,470
could use it for documentation but you

00:11:21,250 --> 00:11:25,660
probably use it for types but it didn't

00:11:23,470 --> 00:11:27,370
really specify a way to use it for types

00:11:25,660 --> 00:11:30,490
but we could imagine doing something

00:11:27,370 --> 00:11:32,500
like this with it where in the

00:11:30,490 --> 00:11:34,089
annotation we just write put the type

00:11:32,500 --> 00:11:35,980
there right we say a is an NP isn't in

00:11:34,089 --> 00:11:38,410
see isn't in returns an int and so when

00:11:35,980 --> 00:11:41,170
I look at the annotations I see what all

00:11:38,410 --> 00:11:42,579
of those are supposed to be however just

00:11:41,170 --> 00:11:44,079
because like an antique function again

00:11:42,579 --> 00:11:46,089
doesn't mean I can actually evaluate

00:11:44,079 --> 00:11:47,529
whether that function is being used

00:11:46,089 --> 00:11:49,870
correctly elsewhere like Python is not

00:11:47,529 --> 00:11:51,550
gonna look at these annotations and at

00:11:49,870 --> 00:11:53,290
runtime and figure out if they're right

00:11:51,550 --> 00:11:55,300
or wrong it's being called correctly so

00:11:53,290 --> 00:11:57,010
it only gives us a way to annotate this

00:11:55,300 --> 00:11:58,720
function and actually only functions - I

00:11:57,010 --> 00:12:02,290
can't annotate the variables with this

00:11:58,720 --> 00:12:03,610
it's only for functions so a little bit

00:12:02,290 --> 00:12:05,620
around the same time

00:12:03,610 --> 00:12:07,720
eucalyptus Lo is working on his PhD

00:12:05,620 --> 00:12:10,000
thesis at University of Cambridge and

00:12:07,720 --> 00:12:11,680
his PhD thesis was about this is about

00:12:10,000 --> 00:12:13,570
the unification of a statically typed

00:12:11,680 --> 00:12:15,100
and the dynamically typed language

00:12:13,570 --> 00:12:17,889
basically how could you have a language

00:12:15,100 --> 00:12:20,199
that had both and the goal was to be

00:12:17,889 --> 00:12:21,760
able to use the same language for

00:12:20,199 --> 00:12:23,620
everything from a tiny script where you

00:12:21,760 --> 00:12:26,110
don't really care about typing that much

00:12:23,620 --> 00:12:28,600
to like a sprawling multi-line codebase

00:12:26,110 --> 00:12:30,970
where like Dropbox you start to actually

00:12:28,600 --> 00:12:32,860
care about typing and he had this idea

00:12:30,970 --> 00:12:34,360
of gradual growth where you could go

00:12:32,860 --> 00:12:36,880
from something that was untyped and

00:12:34,360 --> 00:12:38,170
slowly add type annotations optionally

00:12:36,880 --> 00:12:39,579
where you needed it until you had

00:12:38,170 --> 00:12:43,390
something that was fully statically

00:12:39,579 --> 00:12:46,149
typed so he published a paper his thesis

00:12:43,390 --> 00:12:47,709
in 2011 and in and he concluded this he

00:12:46,149 --> 00:12:49,449
said that adding a static type system to

00:12:47,709 --> 00:12:51,250
a dynamically typed language could be a

00:12:49,449 --> 00:12:53,410
totally invasive change requires

00:12:51,250 --> 00:12:55,360
coordinated modification of like

00:12:53,410 --> 00:12:56,529
everything basically the program that

00:12:55,360 --> 00:13:00,010
runs behind the virtual machines all the

00:12:56,529 --> 00:13:01,839
tools everything you also said that you

00:13:00,010 --> 00:13:03,880
could optionally do an optional an

00:13:01,839 --> 00:13:05,199
optional pluggable type system that

00:13:03,880 --> 00:13:07,120
doesn't actually affect the runtime of

00:13:05,199 --> 00:13:09,790
the program and is basically a layer on

00:13:07,120 --> 00:13:11,680
top of the the program and wouldn't

00:13:09,790 --> 00:13:14,019
require this modification of all the

00:13:11,680 --> 00:13:16,510
existing tool sets so this sounds really

00:13:14,019 --> 00:13:19,209
great without having to change Python it

00:13:16,510 --> 00:13:22,870
would be awesome so in 2013 he gave a

00:13:19,209 --> 00:13:25,329
talk at PyCon us and he introduced

00:13:22,870 --> 00:13:27,970
something called my PI so if you are

00:13:25,329 --> 00:13:29,390
familiar with my PI you this is probably

00:13:27,970 --> 00:13:31,220
not what you're familiar

00:13:29,390 --> 00:13:33,110
when he introduced it at the time this

00:13:31,220 --> 00:13:35,510
is what my pie was my pie is an

00:13:33,110 --> 00:13:36,770
experimental variant of Python that

00:13:35,510 --> 00:13:39,010
supports writing programs that

00:13:36,770 --> 00:13:42,860
seamlessly mix dynamic and Static typing

00:13:39,010 --> 00:13:45,080
so this was not what you think it was my

00:13:42,860 --> 00:13:46,490
pie now my pie you think of now as a

00:13:45,080 --> 00:13:48,800
static type checker at the time it was

00:13:46,490 --> 00:13:51,440
actually a variant of Python itself it

00:13:48,800 --> 00:13:53,180
was its own language and so in his

00:13:51,440 --> 00:13:54,710
research he actually he didn't even use

00:13:53,180 --> 00:13:56,990
Python as an example he made up a

00:13:54,710 --> 00:13:58,970
language sort of as a toy language to

00:13:56,990 --> 00:14:00,980
show that this was actually possible so

00:13:58,970 --> 00:14:02,930
my PI the language actually looked like

00:14:00,980 --> 00:14:05,930
this and it kind of looks like Python it

00:14:02,930 --> 00:14:07,460
was definitely inspired from Python but

00:14:05,930 --> 00:14:09,350
it had some extra stuff to allow him to

00:14:07,460 --> 00:14:12,290
do variable annotations and better

00:14:09,350 --> 00:14:14,360
function annotations because at the time

00:14:12,290 --> 00:14:17,150
all we had was function notations so he

00:14:14,360 --> 00:14:18,800
gave this presentation at PyCon and he

00:14:17,150 --> 00:14:20,690
said he gave the presentation and he

00:14:18,800 --> 00:14:22,910
talked to Gyo about Anki I was like yeah

00:14:20,690 --> 00:14:24,410
just ditch this dish the variable

00:14:22,910 --> 00:14:27,530
variant language like let's just do this

00:14:24,410 --> 00:14:29,270
in Python proper and so he said okay so

00:14:27,530 --> 00:14:31,790
he did just convince him to drop the

00:14:29,270 --> 00:14:33,680
custom syntax and stick to just Python

00:14:31,790 --> 00:14:35,510
free where we have function annotations

00:14:33,680 --> 00:14:39,770
and we can do some other stuff as well

00:14:35,510 --> 00:14:41,540
so in 2014 we got at 43 and this was

00:14:39,770 --> 00:14:43,910
Guiteau writing down basically his

00:14:41,540 --> 00:14:47,060
theory of type hints like how typing

00:14:43,910 --> 00:14:50,120
should work in Python so there were some

00:14:47,060 --> 00:14:52,610
big ideas here one was sort of drew from

00:14:50,120 --> 00:14:54,710
us Yuka's paper one was optional typing

00:14:52,610 --> 00:14:56,510
adding annotations to their runtime

00:14:54,710 --> 00:14:58,820
shouldn't affect the actual runtime of

00:14:56,510 --> 00:15:01,520
your program so like I said before an

00:14:58,820 --> 00:15:03,620
unattended run exactly the same as an

00:15:01,520 --> 00:15:06,140
annotated function I think this sort of

00:15:03,620 --> 00:15:08,480
stills from lessons that we learned in

00:15:06,140 --> 00:15:09,770
the Python two to three migration right

00:15:08,480 --> 00:15:12,140
we don't want to introduce this huge

00:15:09,770 --> 00:15:15,050
breaking change across Python versions

00:15:12,140 --> 00:15:16,190
we want it to be sort of like gradual

00:15:15,050 --> 00:15:18,410
and available if you want it but not

00:15:16,190 --> 00:15:20,840
going to get in your way the other was

00:15:18,410 --> 00:15:23,120
gradual typing so let's not try to do

00:15:20,840 --> 00:15:24,620
this all at once right typing a giant

00:15:23,120 --> 00:15:25,910
code base is going to be impossible to

00:15:24,620 --> 00:15:28,940
do all at once you should be able to do

00:15:25,910 --> 00:15:30,170
little pieces at a time he also

00:15:28,940 --> 00:15:31,670
introduced the idea of variable

00:15:30,170 --> 00:15:33,110
annotation so this was building on the

00:15:31,670 --> 00:15:35,480
idea of function annotation so that we

00:15:33,110 --> 00:15:36,500
could annotate variables as well and so

00:15:35,480 --> 00:15:38,720
that would mean that we could have a

00:15:36,500 --> 00:15:40,430
function like this and we could add a

00:15:38,720 --> 00:15:42,890
little comments as the type of this

00:15:40,430 --> 00:15:45,080
variable I've just defined is and

00:15:42,890 --> 00:15:47,750
this also meant that we could do type

00:15:45,080 --> 00:15:49,220
hinting in Python too so the syntax for

00:15:47,750 --> 00:15:49,520
function annotations only came to Python

00:15:49,220 --> 00:15:52,430
00:15:49,520 --> 00:15:53,870
but because even those on like a super

00:15:52,430 --> 00:15:55,910
old version I thought and still deserve

00:15:53,870 --> 00:15:57,710
to be able to do to the static typing we

00:15:55,910 --> 00:15:59,930
were able to take these type of type

00:15:57,710 --> 00:16:01,760
comment annotations and backport them to

00:15:59,930 --> 00:16:04,280
Python 2 and sort of get the same

00:16:01,760 --> 00:16:05,660
behavior so in Python 3 we can actually

00:16:04,280 --> 00:16:07,700
put them in line with the function

00:16:05,660 --> 00:16:09,320
annotations in Python 2 we can just

00:16:07,700 --> 00:16:11,960
write a comment underneath of the

00:16:09,320 --> 00:16:14,480
function declaration and have the type

00:16:11,960 --> 00:16:16,820
annotation there you also introduce some

00:16:14,480 --> 00:16:18,050
ideas for special type constructs so

00:16:16,820 --> 00:16:19,730
these are building blocks that we

00:16:18,050 --> 00:16:21,740
actually need to do typing that aren't

00:16:19,730 --> 00:16:23,720
already available in Python so these are

00:16:21,740 --> 00:16:26,990
things like any-any is a type that

00:16:23,720 --> 00:16:29,870
matches literally anything Union would

00:16:26,990 --> 00:16:32,150
be this thing can be a type of one type

00:16:29,870 --> 00:16:34,220
or another type optional means that it's

00:16:32,150 --> 00:16:36,770
an alias for union of some type and none

00:16:34,220 --> 00:16:38,930
a tuple would be a tuple type with

00:16:36,770 --> 00:16:41,060
specific types inside of it callable

00:16:38,930 --> 00:16:43,430
similar so this means that we could

00:16:41,060 --> 00:16:45,350
define a function like this where ramnik

00:16:43,430 --> 00:16:47,870
eight takes an integer an integer but

00:16:45,350 --> 00:16:50,510
the last argument could be a float or it

00:16:47,870 --> 00:16:52,340
could be an integer and the same thing

00:16:50,510 --> 00:16:53,750
with for the return type right so this

00:16:52,340 --> 00:16:55,700
would allow us to statically type this

00:16:53,750 --> 00:16:58,640
function and actually say exactly what

00:16:55,700 --> 00:17:00,320
those those arguments would be it also

00:16:58,640 --> 00:17:02,960
defines some container types so these

00:17:00,320 --> 00:17:05,300
would be like a list or a set and this

00:17:02,960 --> 00:17:07,040
allows us to sort of say like ok I'm

00:17:05,300 --> 00:17:09,079
initializing this list and it can only

00:17:07,040 --> 00:17:11,630
contain integers or I'm initializing

00:17:09,079 --> 00:17:14,510
this dictionary and the key is a string

00:17:11,630 --> 00:17:15,860
and the value is an integer and so that

00:17:14,510 --> 00:17:17,240
would cause the type checker to either

00:17:15,860 --> 00:17:19,880
pass or fail and in the various

00:17:17,240 --> 00:17:21,680
situations they also define some generic

00:17:19,880 --> 00:17:23,540
types for when a class or function

00:17:21,680 --> 00:17:25,069
behaves in a generic manner so that'd be

00:17:23,540 --> 00:17:26,390
like an iterable right if I just want to

00:17:25,069 --> 00:17:28,339
say like this function takes anything

00:17:26,390 --> 00:17:31,010
that I can iterate on like a string or a

00:17:28,339 --> 00:17:34,400
list or whatever I just call it an

00:17:31,010 --> 00:17:35,900
interval its generic across all types it

00:17:34,400 --> 00:17:37,940
also defines the relationship between

00:17:35,900 --> 00:17:40,330
type subtypes and classes so like I said

00:17:37,940 --> 00:17:43,370
before a type is basically just a class

00:17:40,330 --> 00:17:44,750
so like one just before we just get a

00:17:43,370 --> 00:17:46,670
class out of it that means that I can

00:17:44,750 --> 00:17:50,360
define a class as well and that just

00:17:46,670 --> 00:17:52,400
becomes a type so when I instantiate a

00:17:50,360 --> 00:17:55,710
foo here I just get the type which is

00:17:52,400 --> 00:17:58,590
the class I use to instantiate it

00:17:55,710 --> 00:18:02,700
so for INT like inches both a class and

00:17:58,590 --> 00:18:04,980
a type here I can create this another

00:18:02,700 --> 00:18:07,680
class like user ID this is still a

00:18:04,980 --> 00:18:09,360
custom class but also still a type and

00:18:07,680 --> 00:18:11,520
then it's important to note that things

00:18:09,360 --> 00:18:13,920
like those special type constructs are

00:18:11,520 --> 00:18:15,600
are not also classes that we can stand

00:18:13,920 --> 00:18:17,370
she ate it right you can initialize a

00:18:15,600 --> 00:18:20,880
union of a string and an integer it

00:18:17,370 --> 00:18:22,770
doesn't really make a lot of sense and

00:18:20,880 --> 00:18:24,390
we can define type aliases so this is

00:18:22,770 --> 00:18:26,100
nice if we want to just definitely

00:18:24,390 --> 00:18:27,840
pretend like we're JavaScript and have a

00:18:26,100 --> 00:18:31,170
number type that just is every single

00:18:27,840 --> 00:18:33,990
number available to us and then after he

00:18:31,170 --> 00:18:36,630
did Pet 43 he did pet 484 so this is

00:18:33,990 --> 00:18:38,700
type int and this basically standardizes

00:18:36,630 --> 00:18:41,250
everything in pet 483 and it basically

00:18:38,700 --> 00:18:43,380
standardizes on what my PI's behavior

00:18:41,250 --> 00:18:47,040
and at this point my PI is kind of like

00:18:43,380 --> 00:18:48,930
just the type checker and so pet 484 is

00:18:47,040 --> 00:18:51,930
how to build a type checker for Python

00:18:48,930 --> 00:18:54,660
and this was all released in Python 35

00:18:51,930 --> 00:18:56,490
in 2015 so I had Pet 44 support had a

00:18:54,660 --> 00:18:58,530
typing module that we could import from

00:18:56,490 --> 00:19:01,520
get those special type constructs and

00:18:58,530 --> 00:19:03,960
then we kept going so in pet 526 we got

00:19:01,520 --> 00:19:06,420
syntax for variable variable annotations

00:19:03,960 --> 00:19:08,100
so using the comments in Python 3 felt

00:19:06,420 --> 00:19:10,230
kind of janky and it also had some

00:19:08,100 --> 00:19:12,180
problems so like I said before you can

00:19:10,230 --> 00:19:14,640
initialize an empty list and set the

00:19:12,180 --> 00:19:15,660
type on that list there's it was kind of

00:19:14,640 --> 00:19:16,920
messy when we tried to instantiate

00:19:15,660 --> 00:19:18,780
something that we didn't want to set to

00:19:16,920 --> 00:19:20,300
a value yet we kind of had to give it an

00:19:18,780 --> 00:19:23,730
initial value if we wanted to type it

00:19:20,300 --> 00:19:24,780
and so the variable annotations let us

00:19:23,730 --> 00:19:27,180
do things like this we put the

00:19:24,780 --> 00:19:28,800
annotation in line if it didn't have an

00:19:27,180 --> 00:19:30,240
initialization value we could just set

00:19:28,800 --> 00:19:31,650
the annotation and then just not

00:19:30,240 --> 00:19:33,570
initializing the variable at that point

00:19:31,650 --> 00:19:35,160
and the same is true for like class

00:19:33,570 --> 00:19:36,570
variables we had like the ability to

00:19:35,160 --> 00:19:39,270
instantiate class variables and things

00:19:36,570 --> 00:19:41,460
that was available in Python 3 6 and

00:19:39,270 --> 00:19:43,200
this almost had everything we needed to

00:19:41,460 --> 00:19:46,890
do static typing in Python

00:19:43,200 --> 00:19:48,480
except we needed a type checker so this

00:19:46,890 --> 00:19:50,310
is the last piece of the puzzle and at

00:19:48,480 --> 00:19:52,560
this point we kind of also we have myapi

00:19:50,310 --> 00:19:53,700
but there are also other static type

00:19:52,560 --> 00:19:56,130
checkers available as well

00:19:53,700 --> 00:19:58,380
so there are two types static versus

00:19:56,130 --> 00:20:01,230
dynamic so static type checker is going

00:19:58,380 --> 00:20:02,880
to run while your code is at rest it's

00:20:01,230 --> 00:20:05,160
going to actually run across your static

00:20:02,880 --> 00:20:07,800
code base and infer all the types from

00:20:05,160 --> 00:20:08,280
just from code a dynamic type checker is

00:20:07,800 --> 00:20:10,290
going to

00:20:08,280 --> 00:20:11,730
sit with your code at runtime and infer

00:20:10,290 --> 00:20:14,100
types kind of like those asserts that we

00:20:11,730 --> 00:20:15,450
were doing before so most of the type

00:20:14,100 --> 00:20:19,350
checkers I'm going to talk about our are

00:20:15,450 --> 00:20:21,060
static so by this point my PI had become

00:20:19,350 --> 00:20:22,950
like it's no longer a variant it's a

00:20:21,060 --> 00:20:25,470
tool that's the type checker here that's

00:20:22,950 --> 00:20:28,170
released on pi PI and you could run out

00:20:25,470 --> 00:20:30,630
like this you could pip install my PI to

00:20:28,170 --> 00:20:32,490
find some file that has some bad typing

00:20:30,630 --> 00:20:34,920
in it and I could run my pile on that

00:20:32,490 --> 00:20:36,570
file and it will say okay you said that

00:20:34,920 --> 00:20:38,460
three arguments are integers but you're

00:20:36,570 --> 00:20:40,970
calling them with strings this is a type

00:20:38,460 --> 00:20:43,500
error and I'm gonna give you a warning

00:20:40,970 --> 00:20:45,210
so there's lots of static type checkers

00:20:43,500 --> 00:20:48,090
like I said they all support and

00:20:45,210 --> 00:20:49,530
implement pet 484 so there's my PI

00:20:48,090 --> 00:20:51,680
that's mostly you supported by Dropbox

00:20:49,530 --> 00:20:53,730
at this point PI type is from Google

00:20:51,680 --> 00:20:55,200
hires from Facebook PI right from

00:20:53,730 --> 00:20:57,030
Microsoft high charm actually has its

00:20:55,200 --> 00:20:58,710
own built-in sag type checker which is

00:20:57,030 --> 00:21:00,360
kind of cool but also like you can

00:20:58,710 --> 00:21:02,490
integrate your editor whatever your

00:21:00,360 --> 00:21:03,900
editor is with all of these other type

00:21:02,490 --> 00:21:05,280
checkers as well and then there's a

00:21:03,900 --> 00:21:07,380
bunch of dynamic ones but again they

00:21:05,280 --> 00:21:09,210
have some overhead at runtime so they're

00:21:07,380 --> 00:21:11,490
not you know generally preferred I think

00:21:09,210 --> 00:21:13,260
so disclaimer I work at Google so I will

00:21:11,490 --> 00:21:15,510
talk about PI type just a little bit too

00:21:13,260 --> 00:21:17,490
it's also available on pi PI and the

00:21:15,510 --> 00:21:18,690
inevitable question between when you're

00:21:17,490 --> 00:21:20,550
looking at all these type checkers is

00:21:18,690 --> 00:21:22,500
like what is the difference between them

00:21:20,550 --> 00:21:25,050
and since they all implement this this

00:21:22,500 --> 00:21:27,030
path is standard like what what's the

00:21:25,050 --> 00:21:29,190
actual difference here so the difference

00:21:27,030 --> 00:21:30,630
between my PI and PI type there's

00:21:29,190 --> 00:21:32,820
basically two things I'm going to point

00:21:30,630 --> 00:21:34,770
out one is what I'll call cross function

00:21:32,820 --> 00:21:36,330
inference and the other is runtime

00:21:34,770 --> 00:21:38,220
lenience so they basically have two

00:21:36,330 --> 00:21:42,120
different philosophies about when they

00:21:38,220 --> 00:21:44,190
should raise errors so cross function

00:21:42,120 --> 00:21:46,590
inference means that if I define a

00:21:44,190 --> 00:21:48,420
function and I one function returns a

00:21:46,590 --> 00:21:49,770
string and the other tries to take the

00:21:48,420 --> 00:21:51,660
output from that function and do

00:21:49,770 --> 00:21:55,650
something that would be a type error at

00:21:51,660 --> 00:21:58,020
runtime if I run this example it's gonna

00:21:55,650 --> 00:22:00,000
raise a tight there and if every with my

00:21:58,020 --> 00:22:00,960
PI nothing happens because my mind

00:22:00,000 --> 00:22:03,540
doesn't actually have the ability to

00:22:00,960 --> 00:22:04,710
infer across functions that I that one

00:22:03,540 --> 00:22:06,000
function is gonna return the string and

00:22:04,710 --> 00:22:08,100
the other function is trying to use that

00:22:06,000 --> 00:22:09,960
as a string if I run it with PI tight

00:22:08,100 --> 00:22:11,250
high type though it will raise an error

00:22:09,960 --> 00:22:12,560
it will say this is going to produce an

00:22:11,250 --> 00:22:15,960
error when you try to run this function

00:22:12,560 --> 00:22:18,810
you probably want to fix it the kind of

00:22:15,960 --> 00:22:21,030
the opposite is that my my PI is going

00:22:18,810 --> 00:22:22,170
to be really strict when you define its

00:22:21,030 --> 00:22:23,490
types

00:22:22,170 --> 00:22:25,110
and the pie type is gonna say if this

00:22:23,490 --> 00:22:27,210
doesn't actually produce a runtime error

00:22:25,110 --> 00:22:28,980
I'm not gonna raise a problem so here I

00:22:27,210 --> 00:22:32,130
have a function that's supposed to

00:22:28,980 --> 00:22:33,809
return a list of strings but in in the

00:22:32,130 --> 00:22:37,590
function I'm appending an integer to it

00:22:33,809 --> 00:22:39,330
and I'm returning that my PI is gonna

00:22:37,590 --> 00:22:40,770
look at this and say this list is

00:22:39,330 --> 00:22:42,900
supposed to only contain strings and

00:22:40,770 --> 00:22:44,760
you're putting an Internet so when I run

00:22:42,900 --> 00:22:47,520
this like it works totally fine my PI

00:22:44,760 --> 00:22:48,740
our PI type is gonna say yeah no problem

00:22:47,520 --> 00:22:51,390
that's not gonna create a runtime error

00:22:48,740 --> 00:22:53,490
but my PI is gonna raise an error and

00:22:51,390 --> 00:22:54,690
say you tried to do something to this

00:22:53,490 --> 00:22:57,510
list and I thought that it was gonna

00:22:54,690 --> 00:23:00,710
have a different type all right so why

00:22:57,510 --> 00:23:03,330
why and when should we use static typing

00:23:00,710 --> 00:23:05,730
so first I'll say when you shouldn't use

00:23:03,330 --> 00:23:07,919
static typing basically never there's

00:23:05,730 --> 00:23:08,910
not really a point in time when snacks I

00:23:07,919 --> 00:23:10,590
think it's gonna hurt you

00:23:08,910 --> 00:23:13,140
again it's like optional and it doesn't

00:23:10,590 --> 00:23:15,179
affect the runtime of your program the

00:23:13,140 --> 00:23:17,580
one time that maybe you shouldn't choose

00:23:15,179 --> 00:23:20,700
to use static typing is to replace your

00:23:17,580 --> 00:23:23,010
unit tests so there is sort of a school

00:23:20,700 --> 00:23:24,120
of thought here that that sometimes you

00:23:23,010 --> 00:23:25,320
write unit tests and they kind of just

00:23:24,120 --> 00:23:26,549
look like you're doing type checking

00:23:25,320 --> 00:23:29,280
right you're making assertions on the

00:23:26,549 --> 00:23:30,570
way you're calling the function and and

00:23:29,280 --> 00:23:32,309
then that's kind of true because you

00:23:30,570 --> 00:23:34,260
know tests are some ways kind of like a

00:23:32,309 --> 00:23:36,150
bad type system but in reality like

00:23:34,260 --> 00:23:37,980
don't replace your unit tests with

00:23:36,150 --> 00:23:40,890
static typing you probably should just

00:23:37,980 --> 00:23:43,620
do both here so when should you use

00:23:40,890 --> 00:23:45,630
static typing basically use it liberally

00:23:43,620 --> 00:23:47,760
use it as much as possible it's good for

00:23:45,630 --> 00:23:49,830
you so you should use static typing when

00:23:47,760 --> 00:23:52,380
you're millions lines of scale so I'm

00:23:49,830 --> 00:23:54,230
not sure anyone's code base is currently

00:23:52,380 --> 00:23:57,390
millions lines of scale right now here

00:23:54,230 --> 00:23:59,460
but basically you know Dropbox found

00:23:57,390 --> 00:24:01,679
that when you're at that scale and that

00:23:59,460 --> 00:24:03,780
Python it's actually a liability that

00:24:01,679 --> 00:24:05,640
Python is not sadly typed the the

00:24:03,780 --> 00:24:07,260
overhead to understand that much Python

00:24:05,640 --> 00:24:09,720
code that doesn't have type annotations

00:24:07,260 --> 00:24:12,360
is so high that it actually affects

00:24:09,720 --> 00:24:13,860
productivity so that's why companies

00:24:12,360 --> 00:24:15,570
like Google and Facebook and Microsoft

00:24:13,860 --> 00:24:17,100
and Dropbox have all invested in these

00:24:15,570 --> 00:24:18,840
type checkers and have started stack the

00:24:17,100 --> 00:24:21,059
typing their code because it actually is

00:24:18,840 --> 00:24:23,370
worth doing for them because they have

00:24:21,059 --> 00:24:25,890
90 lines code so basically like there's

00:24:23,370 --> 00:24:28,140
this graph you can imagine where as your

00:24:25,890 --> 00:24:30,900
lines of code go up your desire to add

00:24:28,140 --> 00:24:32,730
type annotations increases and but your

00:24:30,900 --> 00:24:33,849
ability to added the ease of adding it

00:24:32,730 --> 00:24:35,979
goes

00:24:33,849 --> 00:24:38,679
so you know you're all probably here

00:24:35,979 --> 00:24:40,149
maybe you should migrate and ad side

00:24:38,679 --> 00:24:41,769
typing probably about here in the graph

00:24:40,149 --> 00:24:43,119
that's one it's easiest this is when

00:24:41,769 --> 00:24:45,820
you're probably gonna do it

00:24:43,119 --> 00:24:48,460
but that's okay you'll still be able to

00:24:45,820 --> 00:24:50,169
do it anyway you should also use that

00:24:48,460 --> 00:24:52,960
typing just like when your code is

00:24:50,169 --> 00:24:54,729
confusing so let's be honest everyone

00:24:52,960 --> 00:24:58,479
has written some confusing code at this

00:24:54,729 --> 00:25:00,220
point it has been said that annotations

00:24:58,479 --> 00:25:01,960
are basically like machine verified

00:25:00,220 --> 00:25:03,549
documentation right it's something that

00:25:01,960 --> 00:25:06,460
your developers can look at and

00:25:03,549 --> 00:25:09,460
understand what types are available to

00:25:06,460 --> 00:25:11,200
them in their function but also you can

00:25:09,460 --> 00:25:12,460
run a type checker on it and verify that

00:25:11,200 --> 00:25:14,200
that's actually the way it's being used

00:25:12,460 --> 00:25:15,970
so if you feel like you need to document

00:25:14,200 --> 00:25:18,220
the input and output types of your

00:25:15,970 --> 00:25:20,229
function or your your class or whatever

00:25:18,220 --> 00:25:23,679
that is a good indicator that you should

00:25:20,229 --> 00:25:24,999
probably just add some static typing you

00:25:23,679 --> 00:25:26,470
should use static typing when your code

00:25:24,999 --> 00:25:27,940
is for public consumption so like if

00:25:26,470 --> 00:25:30,129
it's a module you're going to put on pi

00:25:27,940 --> 00:25:32,889
PI adding type annotations help

00:25:30,129 --> 00:25:36,669
developers know how to use your API also

00:25:32,889 --> 00:25:39,009
helps your IDs figure out how to do auto

00:25:36,669 --> 00:25:40,629
completion and things like that and then

00:25:39,009 --> 00:25:42,369
also if your users are doing static

00:25:40,629 --> 00:25:44,679
typing in their code and they want to

00:25:42,369 --> 00:25:46,119
use your library they're gonna love it

00:25:44,679 --> 00:25:49,649
because the static typing is going to be

00:25:46,119 --> 00:25:51,639
available to them as well for your code

00:25:49,649 --> 00:25:55,149
you should use static typing before

00:25:51,639 --> 00:25:56,799
migrating or refactoring so you know add

00:25:55,149 --> 00:25:58,210
some static typing in a place where

00:25:56,799 --> 00:26:00,669
you're about to do some refactoring and

00:25:58,210 --> 00:26:01,749
then go make your changes and then run

00:26:00,669 --> 00:26:03,309
your type checker and make sure that

00:26:01,749 --> 00:26:04,840
you're still calling everything in a way

00:26:03,309 --> 00:26:06,220
that's consistent with the types of you

00:26:04,840 --> 00:26:09,309
would set up before you did that

00:26:06,220 --> 00:26:11,649
migration you could do static typing

00:26:09,309 --> 00:26:14,019
just to experiment with static typing to

00:26:11,649 --> 00:26:16,149
write like I said it doesn't hurt you

00:26:14,019 --> 00:26:19,269
can try it out now if you have a modern

00:26:16,149 --> 00:26:21,659
version of Python yeah it's it's totally

00:26:19,269 --> 00:26:24,609
valid so just experiment with it and

00:26:21,659 --> 00:26:25,779
finally you can use static typing if

00:26:24,609 --> 00:26:27,609
you're just cold

00:26:25,779 --> 00:26:30,249
Gary Bernhardt says static types are a

00:26:27,609 --> 00:26:32,259
warm blanket that I have missed so much

00:26:30,249 --> 00:26:34,239
and by the way Gary's background on

00:26:32,259 --> 00:26:37,450
Twitter is like the best thing right now

00:26:34,239 --> 00:26:39,970
here lies Gary stung by type errors all

00:26:37,450 --> 00:26:42,070
right so to wrap up how do you static

00:26:39,970 --> 00:26:44,979
typing in Python in just five easy steps

00:26:42,070 --> 00:26:46,540
so first you you could this is optional

00:26:44,979 --> 00:26:48,580
but you could migrate to Python

00:26:46,540 --> 00:26:51,190
modern version of Python you can do type

00:26:48,580 --> 00:26:52,780
annotations type comments in any Python

00:26:51,190 --> 00:26:55,600
version you can still do in Python too

00:26:52,780 --> 00:26:57,400
but in Python 3.6 are above you'll get

00:26:55,600 --> 00:26:58,929
variable annotations function

00:26:57,400 --> 00:27:00,700
annotations and everything else as well

00:26:58,929 --> 00:27:03,220
and you should probably be migrating

00:27:00,700 --> 00:27:04,809
anyway let's be honest you can install

00:27:03,220 --> 00:27:06,580
type checker locally I don't care which

00:27:04,809 --> 00:27:07,870
one you can install multiple ones if

00:27:06,580 --> 00:27:10,210
you're interested in trying out multiple

00:27:07,870 --> 00:27:11,559
ones yeah installed locally and

00:27:10,210 --> 00:27:12,970
integrated into your editor right you

00:27:11,559 --> 00:27:14,440
can actually make it so that the type

00:27:12,970 --> 00:27:16,809
checker will run whenever you open

00:27:14,440 --> 00:27:19,030
python file in your code and just check

00:27:16,809 --> 00:27:20,350
out that file and if you as soon as you

00:27:19,030 --> 00:27:22,090
start adding type annotations that will

00:27:20,350 --> 00:27:24,790
start telling you if you're using them

00:27:22,090 --> 00:27:26,080
correctly or not and then you can start

00:27:24,790 --> 00:27:28,059
optionally type in your code base right

00:27:26,080 --> 00:27:30,070
start with maybe like your most

00:27:28,059 --> 00:27:31,540
confusing and hairiest files you can

00:27:30,070 --> 00:27:33,400
start with the easiest things to type

00:27:31,540 --> 00:27:35,380
check as well remember you don't have to

00:27:33,400 --> 00:27:38,080
do it all at once so you can just start

00:27:35,380 --> 00:27:40,929
in some place do a gradual pick the

00:27:38,080 --> 00:27:42,700
critical areas and start there and then

00:27:40,929 --> 00:27:46,000
once you get to the point where you have

00:27:42,700 --> 00:27:47,320
some some type checking in your code you

00:27:46,000 --> 00:27:49,990
can run type checker when you lint your

00:27:47,320 --> 00:27:52,059
program and finally convince all your

00:27:49,990 --> 00:27:53,650
co-workers to join you in static typing

00:27:52,059 --> 00:27:55,330
if you need help convincing them to join

00:27:53,650 --> 00:28:01,210
you you can show them this talk on

00:27:55,330 --> 00:28:03,130
youtube so thanks everyone thank you

00:28:01,210 --> 00:28:04,630
testing destined for your talk you're an

00:28:03,130 --> 00:28:08,160
excellent speaker I wish I could travel

00:28:04,630 --> 00:28:10,150
the country to listen to you talk I

00:28:08,160 --> 00:28:12,400
accidentally found static typing the

00:28:10,150 --> 00:28:14,620
other day I imported well I found out

00:28:12,400 --> 00:28:18,970
that I had to import the class in order

00:28:14,620 --> 00:28:21,850
to statically type a function and then I

00:28:18,970 --> 00:28:24,790
got a recursive import error and I

00:28:21,850 --> 00:28:26,500
realized that when I start to import all

00:28:24,790 --> 00:28:29,200
of the types across all of the

00:28:26,500 --> 00:28:30,850
application to statically type all of

00:28:29,200 --> 00:28:33,520
the functions I was probably going to

00:28:30,850 --> 00:28:35,110
get a lot of I think they're called

00:28:33,520 --> 00:28:37,270
recursive import Arizona's wonder if you

00:28:35,110 --> 00:28:41,500
have any thoughts on on that sort of

00:28:37,270 --> 00:28:43,450
import and recursion yeah yes so the

00:28:41,500 --> 00:28:45,280
issue is that you have some custom types

00:28:43,450 --> 00:28:47,049
and classes and stuff to find you have

00:28:45,280 --> 00:28:50,260
it in your code and you need to import

00:28:47,049 --> 00:28:51,460
it to define the types in some function

00:28:50,260 --> 00:28:53,980
but it hasn't actually like you're doing

00:28:51,460 --> 00:28:55,299
a recursive important so the one thing I

00:28:53,980 --> 00:28:58,900
will say about when you start to add

00:28:55,299 --> 00:29:00,090
static typing to your application it

00:28:58,900 --> 00:29:01,590
does sort of in two key

00:29:00,090 --> 00:29:04,020
to you which parts of your codebase are

00:29:01,590 --> 00:29:06,510
not very well written not saying that

00:29:04,020 --> 00:29:08,309
you've written bad code but it will like

00:29:06,510 --> 00:29:10,289
when you sit down to annotate a function

00:29:08,309 --> 00:29:12,960
and you're like man this is really hard

00:29:10,289 --> 00:29:14,549
to add the typing like I don't confuse

00:29:12,960 --> 00:29:16,440
dand like my pie is really complaining

00:29:14,549 --> 00:29:17,940
about I can't get it right it probably

00:29:16,440 --> 00:29:19,770
means that that function is not well

00:29:17,940 --> 00:29:21,750
written like the arguments are ambiguous

00:29:19,770 --> 00:29:25,860
or it's receiving more than the or

00:29:21,750 --> 00:29:28,080
not specific to circular imports so what

00:29:25,860 --> 00:29:29,669
you can do in my pie and we're in all

00:29:28,080 --> 00:29:31,730
the type checkers you can use strings

00:29:29,669 --> 00:29:34,559
instead of the actual classes themselves

00:29:31,730 --> 00:29:36,059
so yeah if you have circulate circular

00:29:34,559 --> 00:29:37,799
imports like that you don't actually

00:29:36,059 --> 00:29:39,529
need to import them to define the type

00:29:37,799 --> 00:29:42,809
for them you can use a string instead

00:29:39,529 --> 00:29:43,830
and it also sort of and a lot of it

00:29:42,809 --> 00:29:46,590
depends on the leg your code base is

00:29:43,830 --> 00:29:50,820
structured but yeah that's a great

00:29:46,590 --> 00:29:52,980
question any more questions yes if you

00:29:50,820 --> 00:29:56,100
can make a really brief funny because we

00:29:52,980 --> 00:29:59,610
want to go for lunch you guys can always

00:29:56,100 --> 00:30:01,679
talk to him in the hallway yes thank you

00:29:59,610 --> 00:30:04,529
very much just Dustin for your great

00:30:01,679 --> 00:30:08,610
talk I'm a big fan of the static typing

00:30:04,529 --> 00:30:11,580
in Python how do you feel about Django

00:30:08,610 --> 00:30:13,710
and personally when I've used the

00:30:11,580 --> 00:30:16,830
Taipings I I've used a plug-in called my

00:30:13,710 --> 00:30:21,510
PI django to bring in the types yeah and

00:30:16,830 --> 00:30:23,940
I'm not aware of any motion but I'd like

00:30:21,510 --> 00:30:25,590
to see the types in the Django codebase

00:30:23,940 --> 00:30:29,220
would you agree and is there an

00:30:25,590 --> 00:30:33,659
initiative to get that move in so I can

00:30:29,220 --> 00:30:35,159
I'm not like really I can't say this too

00:30:33,659 --> 00:30:37,799
loudly but I'm actually really a Gengo

00:30:35,159 --> 00:30:39,059
developer by thunder

00:30:37,799 --> 00:30:40,890
I do know a little bit about what's act

00:30:39,059 --> 00:30:43,020
I think looks like in Django so I think

00:30:40,890 --> 00:30:44,789
there is some ideas maybe about adding

00:30:43,020 --> 00:30:46,409
static types to Django Kobus itself but

00:30:44,789 --> 00:30:51,029
the nice thing that I didn't mention is

00:30:46,409 --> 00:30:52,649
that so Python the folks that work on my

00:30:51,029 --> 00:30:54,539
PI also shipped this project called type

00:30:52,649 --> 00:30:55,980
shed and that's the type annotations for

00:30:54,539 --> 00:30:57,840
everything across the standard library

00:30:55,980 --> 00:31:00,149
basically you can add type annotations

00:30:57,840 --> 00:31:02,820
external to any third-party package or

00:31:00,149 --> 00:31:03,539
library so there is a project I am

00:31:02,820 --> 00:31:05,610
forgetting what it's called it's

00:31:03,539 --> 00:31:07,200
basically like Django type annotations a

00:31:05,610 --> 00:31:10,350
third party project that has type

00:31:07,200 --> 00:31:11,549
annotations for a significant portion of

00:31:10,350 --> 00:31:13,240
the Django codebase for a specific

00:31:11,549 --> 00:31:15,850
version of Django

00:31:13,240 --> 00:31:18,450
so that is something that you could use

00:31:15,850 --> 00:31:20,890
to get these type annotations for Django

00:31:18,450 --> 00:31:23,080
from what I have heard there's some

00:31:20,890 --> 00:31:25,960
magic happening inside of Django that

00:31:23,080 --> 00:31:27,340
causes it to be difficult to do type

00:31:25,960 --> 00:31:30,550
annotations basically the way that

00:31:27,340 --> 00:31:32,080
models and things are defined so my

00:31:30,550 --> 00:31:33,730
understanding and this is like a very

00:31:32,080 --> 00:31:35,740
high level understanding is that it is

00:31:33,730 --> 00:31:37,450
sometimes challenging to add type

00:31:35,740 --> 00:31:39,220
annotations to some parts of your Django

00:31:37,450 --> 00:31:42,130
application but generally I mean you can

00:31:39,220 --> 00:31:43,750
use it in non jangly parts of it as well

00:31:42,130 --> 00:31:45,460
right like it you don't have to exactly

00:31:43,750 --> 00:31:47,559
take everything in your code base in

00:31:45,460 --> 00:31:48,850
order to use to get the benefits cool

00:31:47,559 --> 00:31:51,490
thank you very much thank you

00:31:48,850 --> 00:31:55,410
thanks for question all right let's give

00:31:51,490 --> 00:31:55,410
another round of applause to mr. Bester

00:31:55,760 --> 00:32:09,029

YouTube URL: https://www.youtube.com/watch?v=5pluSWgTa6I


