Title: DjangoCon 2019 - Postgres Index types and where to find them by Louise Grandjonc
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - Postgres Index types and where to find them by Louise Grandjonc

For a long time I only used the default btree to index data. As I was working on an app for crocodiles to find their dentist, I started looking into the other index types postgres offers to improve SQL performance. If you want to know all about btree, gin, gistâ€¦ how, when and why use them, join me!

This talk was presented at: https://2019.djangocon.us/talks/postgres-index-types-and-where-to-find/

LINKS:
Follow Louise Grandjonc ğŸ‘‡
On Twitter: https://twitter.com/louisemeta
On GitHub: https://github.com/louiseGrandjonc
Official homepage: http://louisemeta.com

Follow DjangCon US ğŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ğŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:12,679
[Music]

00:00:14,380 --> 00:00:21,770
hello oh yes it works okay um so hi

00:00:19,880 --> 00:00:23,390
I'm really happy to be here at dango con

00:00:21,770 --> 00:00:25,580
it's really exciting it's my first

00:00:23,390 --> 00:00:29,300
django con I was in Django con Europe a

00:00:25,580 --> 00:00:31,220
couple years ago so I'm going to today

00:00:29,300 --> 00:00:34,160
talk about Paz breasts index types and

00:00:31,220 --> 00:00:37,040
even if my title contains something

00:00:34,160 --> 00:00:39,320
referring to a very bad movie I'm mostly

00:00:37,040 --> 00:00:42,470
going to be talking about crocodiles and

00:00:39,320 --> 00:00:44,870
not Harry Potter references so just

00:00:42,470 --> 00:00:46,670
about me I'm a software engineer at

00:00:44,870 --> 00:00:48,589
situs data that got acquired by

00:00:46,670 --> 00:00:51,920
Microsoft a few months ago so I'm now

00:00:48,589 --> 00:00:54,400
Microsoft software engineer I before

00:00:51,920 --> 00:00:59,059
that I've been a Python developer for

00:00:54,400 --> 00:01:03,619
years and I also really love databases

00:00:59,059 --> 00:01:06,440
as weird as that sounds I kind of tend

00:01:03,619 --> 00:01:08,540
to be more specialized in Postgres I did

00:01:06,440 --> 00:01:11,570
co-found Postgres women about a year ago

00:01:08,540 --> 00:01:13,369
we you know realized that they were not

00:01:11,570 --> 00:01:16,159
that many women and we kind of wanted to

00:01:13,369 --> 00:01:18,829
prove that we exists and now we're

00:01:16,159 --> 00:01:22,070
trying to work a little bit more on you

00:01:18,829 --> 00:01:23,299
know different diversities because you

00:01:22,070 --> 00:01:26,479
know white women are not really

00:01:23,299 --> 00:01:28,880
diversity if you want to follow me on

00:01:26,479 --> 00:01:31,750
twitter i'm louise mehta and i have a

00:01:28,880 --> 00:01:36,020
blog and i'm mentioning this blog

00:01:31,750 --> 00:01:38,570
because mostly I did write a very long

00:01:36,020 --> 00:01:41,509
series of article that take the content

00:01:38,570 --> 00:01:43,850
of this talk I wrote the first version

00:01:41,509 --> 00:01:47,210
of this talk about a year and a half ago

00:01:43,850 --> 00:01:49,939
and what I did to prepare for that talk

00:01:47,210 --> 00:01:52,609
was read the entire source code for you

00:01:49,939 --> 00:01:55,640
know indexes in Postgres and that was a

00:01:52,609 --> 00:01:57,979
very painful thing and it was because

00:01:55,640 --> 00:02:01,069
there was no good content on that

00:01:57,979 --> 00:02:06,079
specific thing so I ended up writing

00:02:01,069 --> 00:02:08,929
what I needed so today we're gonna talk

00:02:06,079 --> 00:02:10,850
about indexes so first I'm gonna give

00:02:08,929 --> 00:02:14,390
you kind of a reminder for those who are

00:02:10,850 --> 00:02:17,750
new to databases and Postgres and Django

00:02:14,390 --> 00:02:19,159
and everything so what are they for and

00:02:17,750 --> 00:02:20,569
then we'll go through kind of the

00:02:19,159 --> 00:02:23,930
options that you have when you create

00:02:20,569 --> 00:02:24,650
indexes and then we'll go through four

00:02:23,930 --> 00:02:26,540
different types

00:02:24,650 --> 00:02:31,640
Phoenix's and how they are internally

00:02:26,540 --> 00:02:34,010
implemented in Postgres and I kind of on

00:02:31,640 --> 00:02:37,730
purpose decided to not talk about two

00:02:34,010 --> 00:02:39,409
types which are SPG's and hash because

00:02:37,730 --> 00:02:44,030
I've never met someone who actually

00:02:39,409 --> 00:02:46,220
needs that so yeah so I was talking

00:02:44,030 --> 00:02:49,000
about crocodiles so here is the example

00:02:46,220 --> 00:02:52,430
and when you use to this talk you have

00:02:49,000 --> 00:02:54,250
crocodiles it's a table that contains

00:02:52,430 --> 00:02:56,900
you know email first-name lastname

00:02:54,250 --> 00:02:58,909
number of teeth they're important and

00:02:56,900 --> 00:03:01,790
the last checkup and they can take

00:02:58,909 --> 00:03:06,079
appointment because they need dentist

00:03:01,790 --> 00:03:08,510
appointment and the birds are you know

00:03:06,079 --> 00:03:11,180
the doctors this is like a really

00:03:08,510 --> 00:03:13,609
realistic example because in nature the

00:03:11,180 --> 00:03:16,400
crocodiles you know get their teeth

00:03:13,609 --> 00:03:21,349
clean by birds eating the food so that's

00:03:16,400 --> 00:03:25,370
really everything I say is true so what

00:03:21,349 --> 00:03:27,079
are indexes for the first thing I'm

00:03:25,370 --> 00:03:28,519
going to talk about is constraints I

00:03:27,079 --> 00:03:29,949
know that's not necessarily the first

00:03:28,519 --> 00:03:32,930
thing you think about when you think

00:03:29,949 --> 00:03:35,150
indexes but constraints are very

00:03:32,930 --> 00:03:38,739
important so when you create a primary

00:03:35,150 --> 00:03:41,359
key or a unique constraint or an exclude

00:03:38,739 --> 00:03:44,269
constraint it will be transformed in the

00:03:41,359 --> 00:03:46,430
database into an index so that you can

00:03:44,269 --> 00:03:48,709
see like if you will connect to your P

00:03:46,430 --> 00:03:51,739
SQL and you look at your table you will

00:03:48,709 --> 00:03:54,049
see indexes appearing that our note as

00:03:51,739 --> 00:03:56,329
primary key or unique constraints here

00:03:54,049 --> 00:03:58,190
here I have a weird exclude that

00:03:56,329 --> 00:04:01,129
prevents the crocodile to take to skip

00:03:58,190 --> 00:04:03,349
two appointments at the same time we

00:04:01,129 --> 00:04:06,079
also use them for optimizing queries

00:04:03,349 --> 00:04:09,889
that's basically often the main reason

00:04:06,079 --> 00:04:12,229
we create index so why are they helping

00:04:09,889 --> 00:04:15,979
yet is that in an index you're going to

00:04:12,229 --> 00:04:18,130
have the value of the road of the column

00:04:15,979 --> 00:04:20,750
that you're indexing and a pointer and

00:04:18,130 --> 00:04:23,330
instead of reading the entire table it's

00:04:20,750 --> 00:04:26,210
going to go to the index and search for

00:04:23,330 --> 00:04:29,000
the value that you're looking for if

00:04:26,210 --> 00:04:32,389
that's not clear kind of think about it

00:04:29,000 --> 00:04:34,219
as an encyclopedia if you want to read

00:04:32,389 --> 00:04:36,380
about crocodiles and I'm gonna Rea read

00:04:34,219 --> 00:04:38,029
the entire and completely from A to Z

00:04:36,380 --> 00:04:38,510
you're just going to go to the index

00:04:38,029 --> 00:04:43,070
look for

00:04:38,510 --> 00:04:47,900
crocodiles and go back to the pages so

00:04:43,070 --> 00:04:49,460
creating indexes to create an index here

00:04:47,900 --> 00:04:51,470
I have this query I've won the

00:04:49,460 --> 00:04:53,780
crocodiles that have 10 teeth and I want

00:04:51,470 --> 00:04:57,170
to optimize that query it takes about 30

00:04:53,780 --> 00:05:00,080
milliseconds to execute so what I do in

00:04:57,170 --> 00:05:02,480
Django it's really easy in my model I

00:05:00,080 --> 00:05:05,780
just add in the field DB index equal

00:05:02,480 --> 00:05:08,300
true and it's going to create the index

00:05:05,780 --> 00:05:11,620
in the database you can also use raw SQL

00:05:08,300 --> 00:05:14,870
I do that a lot so not no judgment here

00:05:11,620 --> 00:05:18,080
you can do create index and then give an

00:05:14,870 --> 00:05:20,330
index name this is optional on the table

00:05:18,080 --> 00:05:22,070
and the column that you're doing and so

00:05:20,330 --> 00:05:24,590
here it pretty helps I mean 6

00:05:22,070 --> 00:05:28,630
milliseconds instead of 31 it's pretty

00:05:24,590 --> 00:05:32,720
good you can also create unique indexes

00:05:28,630 --> 00:05:34,520
for that again in the field I can here I

00:05:32,720 --> 00:05:37,010
have emails and I want my emails to be

00:05:34,520 --> 00:05:39,230
unique which kind of makes sense so you

00:05:37,010 --> 00:05:41,930
can just have a unique equal true here

00:05:39,230 --> 00:05:44,540
and rise clearly transforms and to

00:05:41,930 --> 00:05:47,420
create unique index on again you could

00:05:44,540 --> 00:05:49,430
give a name here so what will happen is

00:05:47,420 --> 00:05:51,800
when you try to insert a row with you

00:05:49,430 --> 00:05:55,370
know twice the value Louise at koco.com

00:05:51,800 --> 00:06:02,060
that's on my real email address it will

00:05:55,370 --> 00:06:04,690
fail with key already exists enough fun

00:06:02,060 --> 00:06:08,180
stuff because that was kind of you know

00:06:04,690 --> 00:06:10,940
basic so you can also create partial

00:06:08,180 --> 00:06:14,150
indexes which is really cool here in my

00:06:10,940 --> 00:06:15,920
database I have appointments and 95% of

00:06:14,150 --> 00:06:19,070
them have been already done like they've

00:06:15,920 --> 00:06:21,680
you know a bird took care of it so I end

00:06:19,070 --> 00:06:24,200
up with that field on equal true for

00:06:21,680 --> 00:06:26,510
most of my rows and let's say most of my

00:06:24,200 --> 00:06:29,210
queries are going to be on Don equal

00:06:26,510 --> 00:06:31,580
false and I want the emergency level

00:06:29,210 --> 00:06:33,830
bigger than 8 so basically I would just

00:06:31,580 --> 00:06:36,440
want what is what appointments are not

00:06:33,830 --> 00:06:38,540
done and an emergency I could create a

00:06:36,440 --> 00:06:41,750
simple index like this just on emergency

00:06:38,540 --> 00:06:45,470
level but what I can also do is create

00:06:41,750 --> 00:06:48,380
an index with a condition here and it's

00:06:45,470 --> 00:06:50,360
available from django 2.2 so if you

00:06:48,380 --> 00:06:52,290
don't use it you'll have to do some rice

00:06:50,360 --> 00:06:55,780
ql things

00:06:52,290 --> 00:06:58,720
so here I had the condition down equal

00:06:55,780 --> 00:07:02,560
false in my indexes and so it's going to

00:06:58,720 --> 00:07:06,430
generate the following thing seeing is

00:07:02,560 --> 00:07:07,870
not the right term but so trade index

00:07:06,430 --> 00:07:11,050
with a we're close

00:07:07,870 --> 00:07:13,450
so why is it great it's great for so

00:07:11,050 --> 00:07:15,790
first the size of my index here is much

00:07:13,450 --> 00:07:18,400
smaller I had 13 megabytes and now it's

00:07:15,790 --> 00:07:20,590
like 350 kilobytes so really smaller and

00:07:18,400 --> 00:07:23,080
also now the time of my career is

00:07:20,590 --> 00:07:26,080
actually 10 times faster than with

00:07:23,080 --> 00:07:28,570
normal index so that really is a good

00:07:26,080 --> 00:07:30,940
trick especially like if you have some

00:07:28,570 --> 00:07:33,310
stop deletes let's say you have a forum

00:07:30,940 --> 00:07:35,320
you delete the people can delete their

00:07:33,310 --> 00:07:37,150
messages but you don't you know remove

00:07:35,320 --> 00:07:39,550
them from a database you mark them as

00:07:37,150 --> 00:07:42,510
deleted this can be the kind of use case

00:07:39,550 --> 00:07:45,400
where partial index is is pretty good

00:07:42,510 --> 00:07:48,760
you can also of course do partial unique

00:07:45,400 --> 00:07:50,680
indexes again like my email let's say I

00:07:48,760 --> 00:07:54,010
have history and I can't actually have a

00:07:50,680 --> 00:07:58,480
unique in constraint on the entire table

00:07:54,010 --> 00:08:01,210
so I can say for example okay now I had

00:07:58,480 --> 00:08:03,850
unique constraints on email with a

00:08:01,210 --> 00:08:06,970
condition that is it's been created

00:08:03,850 --> 00:08:11,650
after 2019

00:08:06,970 --> 00:08:16,000
September 1st that is also available

00:08:11,650 --> 00:08:17,830
Django 2.2 and it transforms into create

00:08:16,000 --> 00:08:20,350
unique index again with just a we're

00:08:17,830 --> 00:08:22,570
close here again it will create a

00:08:20,350 --> 00:08:25,960
various index that will be much much

00:08:22,570 --> 00:08:28,810
smaller so here it's not just saving

00:08:25,960 --> 00:08:31,870
this space that's a very good thing in

00:08:28,810 --> 00:08:34,780
general it's also that you have were

00:08:31,870 --> 00:08:37,300
going to have much faster indexes sorry

00:08:34,780 --> 00:08:40,180
inserts because when you insert and

00:08:37,300 --> 00:08:42,820
there's a unique constraint Postgres

00:08:40,180 --> 00:08:44,380
will go through the the index and check

00:08:42,820 --> 00:08:47,080
that you're not breaking the constraint

00:08:44,380 --> 00:08:49,390
so having a smaller index will actually

00:08:47,080 --> 00:08:51,430
help you a lot in terms of performance

00:08:49,390 --> 00:08:53,590
and again if you have self deletes like

00:08:51,430 --> 00:08:56,530
your users they can delete their account

00:08:53,590 --> 00:08:59,530
but they can read join but with a new

00:08:56,530 --> 00:09:01,330
account that's a good thing to do to

00:08:59,530 --> 00:09:04,890
have like a unique index on email where

00:09:01,330 --> 00:09:04,890
dd-did equal false or something

00:09:05,070 --> 00:09:12,200
GDP or you should just delete the data

00:09:07,260 --> 00:09:16,970
she's just saying so you also have

00:09:12,200 --> 00:09:19,320
multi-column indexes so here I have

00:09:16,970 --> 00:09:23,550
appointment I'm filtering the

00:09:19,320 --> 00:09:25,020
appointment for a specific bird and we

00:09:23,550 --> 00:09:27,780
want to know kind of like just the

00:09:25,020 --> 00:09:31,290
appointment that the the bird did that

00:09:27,780 --> 00:09:33,420
are an emergency and I kind of want to

00:09:31,290 --> 00:09:36,870
optimize that

00:09:33,420 --> 00:09:40,320
so I here I create an index and in

00:09:36,870 --> 00:09:43,320
fields there are two columns so in rice

00:09:40,320 --> 00:09:45,420
QL you do a create index in on table and

00:09:43,320 --> 00:09:48,450
instead of having just one field you

00:09:45,420 --> 00:09:51,240
have two three four five just don't go

00:09:48,450 --> 00:09:55,410
too crazy about that but you have more

00:09:51,240 --> 00:09:58,310
than one field now to think that you

00:09:55,410 --> 00:10:01,200
have to know about multi-column indexes

00:09:58,310 --> 00:10:04,560
the first thing is that you can actually

00:10:01,200 --> 00:10:06,060
reuse your index the reason is like so I

00:10:04,560 --> 00:10:08,790
decided to do this little thing with

00:10:06,060 --> 00:10:10,770
colors because it was I wanted to be

00:10:08,790 --> 00:10:13,530
able to explain that in simple terms so

00:10:10,770 --> 00:10:15,750
if you have your index and so it's

00:10:13,530 --> 00:10:17,550
indexing the values and here basically

00:10:15,750 --> 00:10:19,890
have the first column is the profit bird

00:10:17,550 --> 00:10:23,160
ID and the second one is the emergency

00:10:19,890 --> 00:10:25,350
level in the index well you know order

00:10:23,160 --> 00:10:28,050
by plover ID for the first column and

00:10:25,350 --> 00:10:31,380
then for each player birds it will be

00:10:28,050 --> 00:10:34,110
ordered by emergency level so what you

00:10:31,380 --> 00:10:37,350
can see is that here the first column is

00:10:34,110 --> 00:10:40,710
ordered the second is ordered by profit

00:10:37,350 --> 00:10:43,950
bird by emergency level so here it still

00:10:40,710 --> 00:10:46,140
goes six ten ten and then 160 cetera so

00:10:43,950 --> 00:10:49,830
it's actually not ordered overall only

00:10:46,140 --> 00:10:52,170
the first column is so you can reuse

00:10:49,830 --> 00:10:55,500
that index if you're doing a you know

00:10:52,170 --> 00:10:58,710
just a simple filter 12 a bird equals

00:10:55,500 --> 00:11:01,170
value so that would reuse the index it's

00:10:58,710 --> 00:11:05,550
important to note that because you might

00:11:01,170 --> 00:11:07,650
if you need a multi column index then

00:11:05,550 --> 00:11:10,980
you might also want to clean the useless

00:11:07,650 --> 00:11:15,150
indexes that could be just reused by

00:11:10,980 --> 00:11:16,350
this one so that's the first thing the

00:11:15,150 --> 00:11:18,990
second thing that you have to think

00:11:16,350 --> 00:11:23,370
about is that you should put your most

00:11:18,990 --> 00:11:25,470
train column first that means that at

00:11:23,370 --> 00:11:30,420
least try it's not always possible this

00:11:25,470 --> 00:11:33,990
is like very theoretical here I have you

00:11:30,420 --> 00:11:37,410
know seventy five thousand appointments

00:11:33,990 --> 00:11:40,649
that are emergency level bigger or equal

00:11:37,410 --> 00:11:43,200
than nine and I have five appointments

00:11:40,649 --> 00:11:45,779
that are from this bird here when I do

00:11:43,200 --> 00:11:48,959
the index with clever bird and an

00:11:45,779 --> 00:11:50,730
appointment it will look only it will

00:11:48,959 --> 00:11:54,959
you know get the five and out of the

00:11:50,730 --> 00:11:57,870
five filter on appointment level emerges

00:11:54,959 --> 00:11:59,580
emergency level sorry if you did the

00:11:57,870 --> 00:12:03,240
opposite it would actually be filtering

00:11:59,580 --> 00:12:05,820
out of 75,000 so you can actually I've

00:12:03,240 --> 00:12:07,320
had that problem a lot at ciders where

00:12:05,820 --> 00:12:08,970
people are like how I created that

00:12:07,320 --> 00:12:11,580
multi-column indexing it actually

00:12:08,970 --> 00:12:14,010
doesn't really help and like let's you

00:12:11,580 --> 00:12:17,490
know try to see actually what order you

00:12:14,010 --> 00:12:23,550
used because that does change a lot and

00:12:17,490 --> 00:12:27,779
so now a little bit of fun with Postgres

00:12:23,550 --> 00:12:30,000
and indexed types the first time the

00:12:27,779 --> 00:12:33,089
first index I'm going to be talking

00:12:30,000 --> 00:12:34,500
about is B trees it's the default index

00:12:33,089 --> 00:12:38,520
so everything that you've seen before

00:12:34,500 --> 00:12:40,380
just B trees nothing crazy about that so

00:12:38,520 --> 00:12:43,700
when you do create index it's just going

00:12:40,380 --> 00:12:47,850
to create a B tree so what is a B tree

00:12:43,700 --> 00:12:50,459
it's a balance tree that's the first

00:12:47,850 --> 00:12:53,610
thing the difference between a balance

00:12:50,459 --> 00:12:56,160
tree and a binary tree is that all the

00:12:53,610 --> 00:12:58,260
so first all the leaves are at equal

00:12:56,160 --> 00:13:01,500
distance from the root this is the root

00:12:58,260 --> 00:13:03,480
these are the leaves and a parent node

00:13:01,500 --> 00:13:06,420
can have multiple children it's not only

00:13:03,480 --> 00:13:08,579
two so that means that basically the

00:13:06,420 --> 00:13:10,470
depth of the tree will be smaller which

00:13:08,579 --> 00:13:12,810
is good when you're going to search into

00:13:10,470 --> 00:13:14,670
the tree to kind of limit the amount of

00:13:12,810 --> 00:13:17,970
you know changing the reading head

00:13:14,670 --> 00:13:20,880
between pages so right now I'm talking

00:13:17,970 --> 00:13:23,070
about pages and because I don't want to

00:13:20,880 --> 00:13:26,250
scare anything anyone I'm just gonna say

00:13:23,070 --> 00:13:29,550
a page is basically where everything is

00:13:26,250 --> 00:13:32,610
stored almost in phosphorus it's a 8

00:13:29,550 --> 00:13:38,010
kilobyte data structure it's not nothing

00:13:32,610 --> 00:13:41,070
it's just that the name is page so in an

00:13:38,010 --> 00:13:42,600
index what is a page in what does it

00:13:41,070 --> 00:13:44,880
contain

00:13:42,600 --> 00:13:47,040
it contains the block number that is

00:13:44,880 --> 00:13:50,070
going to be used for the pointer it's

00:13:47,040 --> 00:13:53,370
going to define a high key and what is a

00:13:50,070 --> 00:13:57,300
high key it's the high basically in that

00:13:53,370 --> 00:14:00,660
page any item will have a value lower or

00:13:57,300 --> 00:14:03,410
equal to the high key and then it has

00:14:00,660 --> 00:14:07,560
items and we'll go through items later

00:14:03,410 --> 00:14:10,050
so I was talking about high key so here

00:14:07,560 --> 00:14:13,140
for example I may be in the back you

00:14:10,050 --> 00:14:17,430
don't see as well I'm sorry I hope you

00:14:13,140 --> 00:14:20,970
do but not sure here I have this page as

00:14:17,430 --> 00:14:23,700
has the high key 16 so it means that I

00:14:20,970 --> 00:14:26,339
will only find crocodiles with 16 or

00:14:23,700 --> 00:14:29,610
less teeth in this one the high key is

00:14:26,339 --> 00:14:31,589
31 so it will be 31 or less and here I

00:14:29,610 --> 00:14:33,690
don't have a high key because it's the

00:14:31,589 --> 00:14:36,959
last page of the level so you can I

00:14:33,690 --> 00:14:41,959
don't know how many teeth curcuit I will

00:14:36,959 --> 00:14:45,000
have it could be like a hundred probably

00:14:41,959 --> 00:14:47,820
and now there are also items and the

00:14:45,000 --> 00:14:49,470
items basically contains the value and a

00:14:47,820 --> 00:14:52,079
pointer that was what I was describing

00:14:49,470 --> 00:14:54,060
before the value will be basically just

00:14:52,079 --> 00:14:56,250
the value of the of what you indexing of

00:14:54,060 --> 00:14:59,100
the column and the pointer will be in

00:14:56,250 --> 00:15:04,980
the leaves the pointer to the row in the

00:14:59,100 --> 00:15:08,010
parents a pointer to the the children so

00:15:04,980 --> 00:15:10,410
to sum up you have a B trees a balanced

00:15:08,010 --> 00:15:12,480
tree the values that are indexed are the

00:15:10,410 --> 00:15:15,000
values of the rows and I know this

00:15:12,480 --> 00:15:17,459
sounds very trivial and very obvious but

00:15:15,000 --> 00:15:21,029
it's not the case for every index that's

00:15:17,459 --> 00:15:23,279
why I am saying it the data is torn in

00:15:21,029 --> 00:15:25,110
pages and the pages have a high key and

00:15:23,279 --> 00:15:29,640
items that are pointing either church

00:15:25,110 --> 00:15:32,100
hide page or to the row and so war RB

00:15:29,640 --> 00:15:34,320
tree is so good then they're very good

00:15:32,100 --> 00:15:36,890
for anything where you compare data

00:15:34,320 --> 00:15:41,069
attic is it equal bigger lower bigger

00:15:36,890 --> 00:15:43,290
equal and lower than or equal why it's

00:15:41,069 --> 00:15:46,320
basically again like you are indexing

00:15:43,290 --> 00:15:48,840
the value in a structure with height

00:15:46,320 --> 00:15:51,720
he the Heike really matters when it

00:15:48,840 --> 00:15:53,790
comes to the binary search and that's

00:15:51,720 --> 00:15:55,560
what Postgres is using to search into

00:15:53,790 --> 00:15:58,590
the tree it's going to do binary search

00:15:55,560 --> 00:16:00,750
so B trees are good for almost

00:15:58,590 --> 00:16:03,420
everything that you want to do like

00:16:00,750 --> 00:16:06,420
really commonly you won't need anything

00:16:03,420 --> 00:16:09,600
else than a bee tree but when you do

00:16:06,420 --> 00:16:16,320
there are other types the second tile is

00:16:09,600 --> 00:16:20,090
the one I will talk about is Jin so Jin

00:16:16,320 --> 00:16:23,670
is used to index arrays and Jason B

00:16:20,090 --> 00:16:27,360
Tia's vector ts vector for those of you

00:16:23,670 --> 00:16:30,150
who are not necessarily you know don't

00:16:27,360 --> 00:16:32,370
really use that it's full text search in

00:16:30,150 --> 00:16:34,620
Postgres it will basically just

00:16:32,370 --> 00:16:37,830
transform a text into a series of

00:16:34,620 --> 00:16:40,920
vectors of Lex M which is basically just

00:16:37,830 --> 00:16:43,170
the root of the word it sufficient for

00:16:40,920 --> 00:16:46,620
this operators which probably don't mean

00:16:43,170 --> 00:16:48,540
much this is basically anything that

00:16:46,620 --> 00:16:51,300
would be like oh does this array

00:16:48,540 --> 00:16:54,360
contains this value does this array can

00:16:51,300 --> 00:16:58,320
change this array does this element you

00:16:54,360 --> 00:17:00,480
know overlap to that for full-text

00:16:58,320 --> 00:17:02,610
search for examples really good because

00:17:00,480 --> 00:17:04,920
you're going to be wanted really often

00:17:02,610 --> 00:17:08,939
to have like oh does is that word in

00:17:04,920 --> 00:17:11,699
that text or something so here I added a

00:17:08,939 --> 00:17:14,970
new column it's the Hilty since the what

00:17:11,699 --> 00:17:18,900
the crocodiles got hurt and the lava

00:17:14,970 --> 00:17:21,689
bird dentist had to repair so here I

00:17:18,900 --> 00:17:25,530
have I randomly generated this this is

00:17:21,689 --> 00:17:28,640
not my real I think that this would be a

00:17:25,530 --> 00:17:32,040
lot of teeth damaged but yeah

00:17:28,640 --> 00:17:32,820
so I created in index and so how they do

00:17:32,040 --> 00:17:36,600
that

00:17:32,820 --> 00:17:40,170
Postgres is very good with Django and

00:17:36,600 --> 00:17:43,920
Django is amazing and so you have in

00:17:40,170 --> 00:17:46,800
Django contrib Postgres indexes gene

00:17:43,920 --> 00:17:48,720
index and basically Django supports all

00:17:46,800 --> 00:17:51,540
the different types of indexes that

00:17:48,720 --> 00:17:54,540
Postgres provides out of the box so it's

00:17:51,540 --> 00:17:56,490
really easy for you to use that so you

00:17:54,540 --> 00:17:59,830
can just simply create a gene index with

00:17:56,490 --> 00:18:03,700
the fields if you're using rice trio

00:17:59,830 --> 00:18:08,320
because you love SQL and it's fun i

00:18:03,700 --> 00:18:11,440
guess i mean i do is i yeah

00:18:08,320 --> 00:18:15,700
you can do create index using gin that's

00:18:11,440 --> 00:18:19,390
how it works so how is it different from

00:18:15,700 --> 00:18:21,700
a b-tree earlier i was telling you oh we

00:18:19,390 --> 00:18:25,000
in the bee tree we just you know index

00:18:21,700 --> 00:18:27,220
the value as it is if we were to use a

00:18:25,000 --> 00:18:30,040
bee tree on an array it would just index

00:18:27,220 --> 00:18:32,260
the entire array what gin does is that

00:18:30,040 --> 00:18:34,870
it's going to take the array and split

00:18:32,260 --> 00:18:40,090
it and each value will be an entry in

00:18:34,870 --> 00:18:43,030
the tree each value is unique so here

00:18:40,090 --> 00:18:47,770
what you can see is this is again my

00:18:43,030 --> 00:18:52,660
array of heel teeth and it was actually

00:18:47,770 --> 00:18:54,220
split and so this this you know branch

00:18:52,660 --> 00:18:56,050
of the tree will contain all the

00:18:54,220 --> 00:18:58,690
crocodiles that have the chief one

00:18:56,050 --> 00:19:03,700
healed and this one will have the four

00:18:58,690 --> 00:19:06,370
six and whatever it's and the difference

00:19:03,700 --> 00:19:08,679
is that so in a bee tree each element of

00:19:06,370 --> 00:19:11,530
your table has an item in the leaves

00:19:08,679 --> 00:19:14,650
here instead what there is in the leaf

00:19:11,530 --> 00:19:18,670
is a list of the all the crocodiles that

00:19:14,650 --> 00:19:21,820
have the teeth one healed when you know

00:19:18,670 --> 00:19:23,890
the sometimes the the the the list just

00:19:21,820 --> 00:19:26,320
becomes so big that just doesn't even

00:19:23,890 --> 00:19:29,920
fit in a page anymore and what happens

00:19:26,320 --> 00:19:31,809
in that moment is that what we do is we

00:19:29,920 --> 00:19:36,360
have a passing tree which just contains

00:19:31,809 --> 00:19:40,450
also pointers to crocodiles or rows that

00:19:36,360 --> 00:19:46,900
are just stored in a in a tree instead

00:19:40,450 --> 00:19:50,050
of in the page so here i have the time

00:19:46,900 --> 00:19:52,540
that i if I was this I I showed that

00:19:50,050 --> 00:19:55,150
example because I actually created an

00:19:52,540 --> 00:19:57,670
index a b-tree index too just to show

00:19:55,150 --> 00:20:00,790
that it would actually not even be used

00:19:57,670 --> 00:20:03,460
by PostgreSQL when executing the query

00:20:00,790 --> 00:20:05,620
so here it used to take a hundred sick

00:20:03,460 --> 00:20:07,929
and 60 millisecond even with an air

00:20:05,620 --> 00:20:11,050
between decks and now it takes forty one

00:20:07,929 --> 00:20:13,040
millisecond and you can see here in the

00:20:11,050 --> 00:20:18,140
bitmap in there's a bit

00:20:13,040 --> 00:20:20,060
index can and on my index for those who

00:20:18,140 --> 00:20:20,600
of you who don't really know what that

00:20:20,060 --> 00:20:23,390
come from

00:20:20,600 --> 00:20:25,640
it's an explained plan that you can

00:20:23,390 --> 00:20:27,560
actually execute on your query with and

00:20:25,640 --> 00:20:31,930
password scale just to kind of see

00:20:27,560 --> 00:20:35,810
whatever is done when executing a query

00:20:31,930 --> 00:20:38,290
so to sum it up so gin is also a balance

00:20:35,810 --> 00:20:42,430
tree so that's pretty close to be tree

00:20:38,290 --> 00:20:45,260
and each values in the tree is unique we

00:20:42,430 --> 00:20:48,500
instead of just indexing the row we

00:20:45,260 --> 00:20:51,710
split the value and each value is an

00:20:48,500 --> 00:20:53,500
entry a unique entry in the tree so it's

00:20:51,710 --> 00:21:00,650
very efficient for a full-text search

00:20:53,500 --> 00:21:05,600
and you know overlapping data etc and

00:21:00,650 --> 00:21:07,430
I'm gonna speak about gist so just is an

00:21:05,600 --> 00:21:10,730
index a little is a little bit weird

00:21:07,430 --> 00:21:13,670
because it is a framework so you could

00:21:10,730 --> 00:21:17,870
write your own just index for your own

00:21:13,670 --> 00:21:19,850
data if you have time and patience so it

00:21:17,870 --> 00:21:22,490
provides like if you look into it and

00:21:19,850 --> 00:21:24,320
there are articles on my blog about this

00:21:22,490 --> 00:21:25,970
but if you look into it there's like a

00:21:24,320 --> 00:21:28,400
list of functions that you could

00:21:25,970 --> 00:21:30,260
implement for any data type that you

00:21:28,400 --> 00:21:34,820
would have and they would do a genetics

00:21:30,260 --> 00:21:36,920
adjust index sorry so what is the

00:21:34,820 --> 00:21:40,430
difference between a gist index and a

00:21:36,920 --> 00:21:44,150
b-tree or a gin the first thing is that

00:21:40,430 --> 00:21:46,540
the data is not ordered in it which

00:21:44,150 --> 00:21:53,330
seems weird but does make sense

00:21:46,540 --> 00:21:57,290
weirdly here I created a weird data type

00:21:53,330 --> 00:22:01,730
for an integer range just to show you

00:21:57,290 --> 00:22:04,610
that in here you can see that here it's

00:22:01,730 --> 00:22:08,150
3 to 5 the range and then here it's 0 to

00:22:04,610 --> 00:22:10,880
2 and here it's 4 th so it overlaps and

00:22:08,150 --> 00:22:13,880
it's not even ordered why is it this way

00:22:10,880 --> 00:22:16,570
if you're using just index it's most

00:22:13,880 --> 00:22:21,080
likely because you're using you know

00:22:16,570 --> 00:22:24,320
cheapest GIS and if you in using

00:22:21,080 --> 00:22:26,470
geometry and everything what happens is

00:22:24,320 --> 00:22:28,510
in a geometry you

00:22:26,470 --> 00:22:30,340
if you think about it a little bit it

00:22:28,510 --> 00:22:33,250
makes sense that it's almost impossible

00:22:30,340 --> 00:22:36,520
to build a tree on a geometry that just

00:22:33,250 --> 00:22:39,130
never overlaps you know geometry like if

00:22:36,520 --> 00:22:41,230
you take two big circles it's pretty you

00:22:39,130 --> 00:22:43,540
you will have some overlapping so when

00:22:41,230 --> 00:22:45,640
you build a just index there will be

00:22:43,540 --> 00:22:51,190
overlapping and that's something that

00:22:45,640 --> 00:22:53,470
has to be taken in account so the same

00:22:51,190 --> 00:22:56,799
value can be inserted in several places

00:22:53,470 --> 00:22:58,780
which is why you have if you build your

00:22:56,799 --> 00:23:00,850
own just index you'll have to be very

00:22:58,780 --> 00:23:02,830
careful because you can end up with bad

00:23:00,850 --> 00:23:06,970
performance but you can trust the people

00:23:02,830 --> 00:23:09,160
who build just 4 plus G is when you

00:23:06,970 --> 00:23:12,160
create a just index again very simple

00:23:09,160 --> 00:23:15,669
it's in contrib Postgres indexes you can

00:23:12,160 --> 00:23:21,850
just use just index or again you can use

00:23:15,669 --> 00:23:24,910
create index using just so it's Y usages

00:23:21,850 --> 00:23:26,530
and X for any overlapping you know

00:23:24,910 --> 00:23:30,580
things that you would want to do with

00:23:26,530 --> 00:23:32,830
whether it's geometry array ranges I the

00:23:30,580 --> 00:23:35,500
main test I did with gist for this talk

00:23:32,830 --> 00:23:39,490
was on a TS range and that's a pretty

00:23:35,500 --> 00:23:41,650
good example I think it's well again

00:23:39,490 --> 00:23:44,320
especially used for post GIS and for

00:23:41,650 --> 00:23:47,530
nearest neighbor operations it's also

00:23:44,320 --> 00:23:52,299
used very commonly for full-text search

00:23:47,530 --> 00:23:54,760
and there are some very if you you want

00:23:52,299 --> 00:23:57,880
to use you know full-text search and you

00:23:54,760 --> 00:24:00,820
want to use gin or Geist there are

00:23:57,880 --> 00:24:02,590
several differences between them I don't

00:24:00,820 --> 00:24:04,990
think I have time to talk about them

00:24:02,590 --> 00:24:07,030
right now so I'm going to pass that if

00:24:04,990 --> 00:24:09,370
you have questions about it I'm happy to

00:24:07,030 --> 00:24:13,419
answer them in the hallway I'll be

00:24:09,370 --> 00:24:17,760
probably hanging out at the booth my not

00:24:13,419 --> 00:24:23,740
Postgres sorry Microsoft where do I work

00:24:17,760 --> 00:24:26,280
booth sorry teri it's filmed and the

00:24:23,740 --> 00:24:31,600
last one they will be speaking about

00:24:26,280 --> 00:24:34,059
brain indexes are amazing I love that so

00:24:31,600 --> 00:24:36,960
they are very different because they're

00:24:34,059 --> 00:24:39,740
not even a tree there it's the only

00:24:36,960 --> 00:24:42,080
index that is not a tree so

00:24:39,740 --> 00:24:44,630
it's something that we call block range

00:24:42,080 --> 00:24:46,160
index and what it contains and be

00:24:44,630 --> 00:24:48,500
careful because it's going to be very

00:24:46,160 --> 00:24:51,620
confusing until and until I show you

00:24:48,500 --> 00:24:53,720
what it is is that it's going to have a

00:24:51,620 --> 00:24:56,540
group of pages that are physically

00:24:53,720 --> 00:25:02,120
adjacent and the range of value that

00:24:56,540 --> 00:25:05,210
this adjacent block range contains so it

00:25:02,120 --> 00:25:07,640
makes brain index is very very small and

00:25:05,210 --> 00:25:11,480
good when you have to fast can like

00:25:07,640 --> 00:25:15,470
really really big tables so what I mean

00:25:11,480 --> 00:25:19,370
with all of that is that here I have a

00:25:15,470 --> 00:25:22,970
brain index on a created at so from for

00:25:19,370 --> 00:25:28,370
the pages from 0 to 128 I have the range

00:25:22,970 --> 00:25:34,070
2008 to 2009 July something then 2028 to

00:25:28,370 --> 00:25:37,640
256 its 2009 2010 something so here you

00:25:34,070 --> 00:25:40,220
can see how a brain index is but be

00:25:37,640 --> 00:25:42,230
careful because it's not always good in

00:25:40,220 --> 00:25:45,679
this case like if I'm just try looking

00:25:42,230 --> 00:25:48,110
for 2013 but I know it will be here but

00:25:45,679 --> 00:25:50,840
if you want to use it for a birthday

00:25:48,110 --> 00:25:54,440
column that will be terrible because all

00:25:50,840 --> 00:25:56,510
the ranges will be really big so when

00:25:54,440 --> 00:25:59,929
you use a brain index you have to be

00:25:56,510 --> 00:26:02,120
careful about having values that or have

00:25:59,929 --> 00:26:05,330
a correlation with the physical location

00:26:02,120 --> 00:26:08,120
of your data so basically any data that

00:26:05,330 --> 00:26:10,490
actually increments would be a good

00:26:08,120 --> 00:26:13,780
thing you also have to be careful about

00:26:10,490 --> 00:26:16,309
deletes because when you delete data

00:26:13,780 --> 00:26:18,230
from you know I don't know two years ago

00:26:16,309 --> 00:26:21,020
whatever and then you vacuumed the

00:26:18,230 --> 00:26:24,350
spaces then reused and then your ranges

00:26:21,020 --> 00:26:26,660
are really bad again so it's something

00:26:24,350 --> 00:26:28,070
to think about when you have you when

00:26:26,660 --> 00:26:31,490
you want to add a brain indexes

00:26:28,070 --> 00:26:35,330
correlation and not delete switch again

00:26:31,490 --> 00:26:38,179
gdpr yeah so when you create a brand X

00:26:35,330 --> 00:26:41,450
again yeah super easy Postgres indexes

00:26:38,179 --> 00:26:46,190
brain index you added to your meta and

00:26:41,450 --> 00:26:49,669
indexes and that's it so conclusion a

00:26:46,190 --> 00:26:53,059
b-tree is great for any comparison

00:26:49,669 --> 00:26:53,700
operators gin are good when it comes to

00:26:53,059 --> 00:26:55,919
array

00:26:53,700 --> 00:26:58,289
and when it comes full-text search when

00:26:55,919 --> 00:27:01,049
you have to kind of have oh this array

00:26:58,289 --> 00:27:03,149
contains whatever jstor good for

00:27:01,049 --> 00:27:04,830
overlapping especially for geometry that

00:27:03,149 --> 00:27:08,010
can also be used for full text search

00:27:04,830 --> 00:27:11,450
and Brin are really good when it comes

00:27:08,010 --> 00:27:14,990
to fast scanning large amount of data

00:27:11,450 --> 00:27:14,990
thank you for attention

00:27:16,490 --> 00:27:22,049
all right so we have time for one maybe

00:27:19,889 --> 00:27:23,669
two questions that I was curious about

00:27:22,049 --> 00:27:26,010
Jen you son

00:27:23,669 --> 00:27:27,960
he said JSON be it would be used on JSON

00:27:26,010 --> 00:27:31,230
B specifically I was curious about like

00:27:27,960 --> 00:27:36,029
depth how that's handled can you only

00:27:31,230 --> 00:27:40,440
index on like an array or keys from what

00:27:36,029 --> 00:27:42,510
I remember it's on the keys but you know

00:27:40,440 --> 00:27:45,630
what I'm not sure because I would guess

00:27:42,510 --> 00:27:49,490
the keys I've only mostly used Jin

00:27:45,630 --> 00:27:51,779
indexes for full-text search actually so

00:27:49,490 --> 00:27:53,789
if you're curious about that they are

00:27:51,779 --> 00:27:56,039
like some pretty good extensions to

00:27:53,789 --> 00:27:57,779
Postgres where you can actually that's

00:27:56,039 --> 00:27:59,940
what I was showing for Brin you can

00:27:57,779 --> 00:28:02,159
actually go and analyze what the pages

00:27:59,940 --> 00:28:03,389
contain so when it's things like that

00:28:02,159 --> 00:28:05,700
way you don't know exactly what is

00:28:03,389 --> 00:28:08,370
indexed you can use this extensions to

00:28:05,700 --> 00:28:10,139
go and see that all right can you

00:28:08,370 --> 00:28:13,110
elaborate a little bit on how you handle

00:28:10,139 --> 00:28:16,380
the regulatory things like gdpr

00:28:13,110 --> 00:28:18,059
or CCPA like did you hard delete the

00:28:16,380 --> 00:28:19,919
rows or did you scrub them and if you

00:28:18,059 --> 00:28:24,149
describe them like how did you handle a

00:28:19,919 --> 00:28:26,700
certain constraint issues oh okay so

00:28:24,149 --> 00:28:29,279
it's sorry the is the question on

00:28:26,700 --> 00:28:39,419
constraints or on brain and handling a

00:28:29,279 --> 00:28:42,330
brain index I'm not sure okay so in my

00:28:39,419 --> 00:28:44,549
company that I worked for before what we

00:28:42,330 --> 00:28:47,250
had was a very complex I think that

00:28:44,549 --> 00:28:51,510
anyone has a complex system where so our

00:28:47,250 --> 00:28:54,000
constraints had conditions for deleted

00:28:51,510 --> 00:28:56,159
accounts and then after six month I

00:28:54,000 --> 00:28:57,690
think of the Nikhil Markus deleted we

00:28:56,159 --> 00:29:01,919
would delete all the data because

00:28:57,690 --> 00:29:03,670
legally we have to I think okay that's

00:29:01,919 --> 00:29:07,420
it

00:29:03,670 --> 00:29:20,799
[Applause]

00:29:07,420 --> 00:29:20,799

YouTube URL: https://www.youtube.com/watch?v=ncwqtsjlSBE


