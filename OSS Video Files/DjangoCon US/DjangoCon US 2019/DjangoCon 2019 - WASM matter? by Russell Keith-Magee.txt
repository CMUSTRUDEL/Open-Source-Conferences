Title: DjangoCon 2019 - WASM matter? by Russell Keith-Magee
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - WASM matter? by Russell Keith-Magee

One of the biggest developments in web technology in the last few years is the emergence of WASM - Web Assembly. But what is WASM? Can you use it in your web projects? Should you? And if so... how?

This talk was presented at: https://2019.djangocon.us/talks/wasm-matter/

LINKS:
Follow Russell Keith-Magee ðŸ‘‡
On Twitter: https://twitter.com/freakboy3742
Official homepage: https://cecinestpasun.com

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:12,679
[Music]

00:00:14,530 --> 00:00:18,740
well good afternoon all yes my name is

00:00:17,000 --> 00:00:21,050
Russell Keith McGee I do unfortunately

00:00:18,740 --> 00:00:23,770
occasionally when excited to speak

00:00:21,050 --> 00:00:25,939
quickly and I'm often excited I

00:00:23,770 --> 00:00:27,080
apologize to the transcriptionists in

00:00:25,939 --> 00:00:28,400
advance there are voluntary

00:00:27,080 --> 00:00:32,720
organizations available to help

00:00:28,400 --> 00:00:35,120
rehabilitate afterwards in my day job I

00:00:32,720 --> 00:00:36,710
am a senior data engineer at savato we

00:00:35,120 --> 00:00:38,510
are a brand intelligence platform we use

00:00:36,710 --> 00:00:40,370
Python and data science to deliver

00:00:38,510 --> 00:00:43,070
consumer insights and predictive

00:00:40,370 --> 00:00:44,780
analytics to help customers improve the

00:00:43,070 --> 00:00:46,309
impact of their brand marketing they

00:00:44,780 --> 00:00:47,720
give me the flexibility to attend

00:00:46,309 --> 00:00:49,760
conferences like Jango Khan which is

00:00:47,720 --> 00:00:51,170
something I'm very grateful for also we

00:00:49,760 --> 00:00:53,239
are hiring at the moment particularly

00:00:51,170 --> 00:00:54,470
for front-end engineers so if you are

00:00:53,239 --> 00:00:55,460
looking for a change please come and

00:00:54,470 --> 00:00:55,670
find me I might get to help you out

00:00:55,460 --> 00:00:59,239
there

00:00:55,670 --> 00:01:00,890
I am a long-term fixture at Jango Khan

00:00:59,239 --> 00:01:02,330
along with Android God wouldn't we are

00:01:00,890 --> 00:01:05,960
the only two people who have been to

00:01:02,330 --> 00:01:09,049
every Jango con us I joined the Jango

00:01:05,960 --> 00:01:11,150
core team way back in 2006 I'm not as

00:01:09,049 --> 00:01:13,310
active in the Jango community as I once

00:01:11,150 --> 00:01:14,750
was though and there's many reasons for

00:01:13,310 --> 00:01:18,079
that but at least one of the reasons is

00:01:14,750 --> 00:01:19,969
the way that the web has changed over

00:01:18,079 --> 00:01:22,549
the last few years web development has

00:01:19,969 --> 00:01:24,079
become extremely JavaScript heavy and

00:01:22,549 --> 00:01:26,090
there's absolutely nothing wrong with

00:01:24,079 --> 00:01:29,000
JavaScript as a language I just happen

00:01:26,090 --> 00:01:30,950
to prefer Python 15 years ago when I

00:01:29,000 --> 00:01:33,170
started using Django you could almost

00:01:30,950 --> 00:01:35,149
ignore JavaScript now your logic was

00:01:33,170 --> 00:01:36,710
client so it was all server-side the

00:01:35,149 --> 00:01:39,079
client was just navigating through a

00:01:36,710 --> 00:01:40,789
series of pages that may have been

00:01:39,079 --> 00:01:42,020
generated from dynamic content but they

00:01:40,789 --> 00:01:45,140
were static when they were delivered to

00:01:42,020 --> 00:01:47,780
the user it's a lot harder to ignore

00:01:45,140 --> 00:01:49,939
JavaScript these days users expect a

00:01:47,780 --> 00:01:51,049
rich client-side experience in Java

00:01:49,939 --> 00:01:52,729
scripts the only language that's

00:01:51,049 --> 00:01:56,090
available in the browser so that means

00:01:52,729 --> 00:01:58,999
we need to use JavaScript note though

00:01:56,090 --> 00:02:01,850
that I say use JavaScript not

00:01:58,999 --> 00:02:03,109
necessarily write JavaScript what I'd

00:02:01,850 --> 00:02:04,909
like to talk about today is a

00:02:03,109 --> 00:02:07,280
development in the JavaScript ecosystem

00:02:04,909 --> 00:02:09,800
that has the potential to reduce the

00:02:07,280 --> 00:02:11,390
significance of JavaScript as a language

00:02:09,800 --> 00:02:14,720
and open up more opportunities for

00:02:11,390 --> 00:02:17,270
Python and by extension Django that

00:02:14,720 --> 00:02:19,730
development is webassembly or wasm now

00:02:17,270 --> 00:02:20,989
to explain what wisdom is you have to

00:02:19,730 --> 00:02:23,090
dig a little bit into how you actually

00:02:20,989 --> 00:02:23,460
get code running on a computer in the

00:02:23,090 --> 00:02:26,430
first

00:02:23,460 --> 00:02:28,680
place when code runs on your computer

00:02:26,430 --> 00:02:30,990
it's running as machine language binary

00:02:28,680 --> 00:02:34,020
instructions specific to a particular

00:02:30,990 --> 00:02:35,940
CPU those binary instructions aren't

00:02:34,020 --> 00:02:37,650
especially easy to write so one of the

00:02:35,940 --> 00:02:39,780
first programming interfaces was

00:02:37,650 --> 00:02:41,970
assembly language assembly language is a

00:02:39,780 --> 00:02:43,830
human readable version of machine

00:02:41,970 --> 00:02:45,720
language every machine language

00:02:43,830 --> 00:02:47,880
construct is exposed directly as an

00:02:45,720 --> 00:02:50,220
assembly language analog so assembly

00:02:47,880 --> 00:02:53,220
source code can be easily assembled into

00:02:50,220 --> 00:02:56,040
a machine language binary executable now

00:02:53,220 --> 00:02:58,260
I say human readable assembly code isn't

00:02:56,040 --> 00:03:00,240
that easy to read or write for that

00:02:58,260 --> 00:03:02,340
matter and so developers wrote

00:03:00,240 --> 00:03:03,660
abstractions the first level of

00:03:02,340 --> 00:03:07,020
abstraction comes in the form of

00:03:03,660 --> 00:03:08,910
compiled languages like C in a compiled

00:03:07,020 --> 00:03:10,680
language you take your source code you

00:03:08,910 --> 00:03:12,570
run it through the compiler and that

00:03:10,680 --> 00:03:14,250
produces the equivalent assembly

00:03:12,570 --> 00:03:16,110
language which can then be converted

00:03:14,250 --> 00:03:18,480
into machine language to produce an

00:03:16,110 --> 00:03:20,100
executable modern compilers will often

00:03:18,480 --> 00:03:22,050
just go directly to machine language

00:03:20,100 --> 00:03:24,870
output but internally the same thing is

00:03:22,050 --> 00:03:27,000
effectively happening when you send AC

00:03:24,870 --> 00:03:29,190
program to someone else what you're

00:03:27,000 --> 00:03:32,130
passing around isn't the C source code

00:03:29,190 --> 00:03:34,440
its source code converted into a machine

00:03:32,130 --> 00:03:36,780
language format so that it can run on

00:03:34,440 --> 00:03:39,570
that particular CPU on that particular

00:03:36,780 --> 00:03:42,120
computer it doesn't contain any remnants

00:03:39,570 --> 00:03:44,790
of the original source code that

00:03:42,120 --> 00:03:47,670
compiled executable form is tightly

00:03:44,790 --> 00:03:49,800
bound to one specific CPU architecture

00:03:47,670 --> 00:03:53,400
and to these specific libraries provided

00:03:49,800 --> 00:03:55,650
by a specific operating system the next

00:03:53,400 --> 00:03:57,180
level of abstraction is the interpreted

00:03:55,650 --> 00:03:58,920
language like JavaScript now when you

00:03:57,180 --> 00:04:00,900
send a JavaScript program to someone

00:03:58,920 --> 00:04:02,760
else what you're sending is the source

00:04:00,900 --> 00:04:04,980
code but at the end of the day the

00:04:02,760 --> 00:04:07,350
computer does everything in machine

00:04:04,980 --> 00:04:09,330
language the interpreter itself is a

00:04:07,350 --> 00:04:11,820
machine language native executable that

00:04:09,330 --> 00:04:13,980
can read the source code and interpret

00:04:11,820 --> 00:04:16,140
the Machine language consequences of the

00:04:13,980 --> 00:04:17,820
source code it has been given the

00:04:16,140 --> 00:04:21,090
benefit of this approach is the code you

00:04:17,820 --> 00:04:23,670
pass around isn't machine dependent the

00:04:21,090 --> 00:04:25,350
same JavaScript source code runs the

00:04:23,670 --> 00:04:27,420
same everywhere because it's the

00:04:25,350 --> 00:04:29,160
interpreter that does the hard part of

00:04:27,420 --> 00:04:31,110
working out what machine language

00:04:29,160 --> 00:04:34,590
instructions are needed on this computer

00:04:31,110 --> 00:04:36,090
to provide the desired effect now let's

00:04:34,590 --> 00:04:37,350
say we're using JavaScript we've written

00:04:36,090 --> 00:04:39,510
our self an ad

00:04:37,350 --> 00:04:42,210
it takes two arguments it adds them

00:04:39,510 --> 00:04:43,560
together and it returns the result when

00:04:42,210 --> 00:04:44,940
this is run through a JavaScript

00:04:43,560 --> 00:04:47,760
interpreter the interpreter has to

00:04:44,940 --> 00:04:51,330
convert it into CPU instructions but

00:04:47,760 --> 00:04:53,850
which CPU instructions now if first and

00:04:51,330 --> 00:04:56,220
second are integers then we need to do

00:04:53,850 --> 00:04:58,350
an integer addition if first and second

00:04:56,220 --> 00:05:00,750
are strings then we need to do string

00:04:58,350 --> 00:05:02,340
concatenation if it's two completely

00:05:00,750 --> 00:05:04,800
different types then you know it gets

00:05:02,340 --> 00:05:07,320
even more complicated that means that

00:05:04,800 --> 00:05:09,870
the interpreter has to be ready to do

00:05:07,320 --> 00:05:13,140
almost anything because the code will

00:05:09,870 --> 00:05:14,610
allow you to do almost anything and it

00:05:13,140 --> 00:05:16,770
has to work out what it's doing at

00:05:14,610 --> 00:05:18,990
runtime the price you pay for that

00:05:16,770 --> 00:05:20,150
flexibility is that your code is a

00:05:18,990 --> 00:05:23,340
little bit slower

00:05:20,150 --> 00:05:25,110
however because JavaScript is now so

00:05:23,340 --> 00:05:27,240
important to the end-user experience in

00:05:25,110 --> 00:05:30,180
the browser the runtime performance of

00:05:27,240 --> 00:05:33,510
JavaScript engines has seen a lot of

00:05:30,180 --> 00:05:35,730
attention once our code starts running

00:05:33,510 --> 00:05:38,130
we might find that because of the way

00:05:35,730 --> 00:05:40,860
the code is being invoked the arguments

00:05:38,130 --> 00:05:43,200
are always integers and the interpreter

00:05:40,860 --> 00:05:45,600
can exploit that it can see that our add

00:05:43,200 --> 00:05:47,100
method is only ever being invoked with

00:05:45,600 --> 00:05:49,320
integers and therefore come up with an

00:05:47,100 --> 00:05:51,870
optimized interpretation of the add

00:05:49,320 --> 00:05:54,570
method that will only ever do integer

00:05:51,870 --> 00:05:56,430
math because of that narrowed scope the

00:05:54,570 --> 00:05:58,500
optimized version is faster because it

00:05:56,430 --> 00:05:59,940
is dynamically adapting to every

00:05:58,500 --> 00:06:02,250
possible input type which makes it

00:05:59,940 --> 00:06:04,350
closer to the bare machine language

00:06:02,250 --> 00:06:06,810
instructions the computer actually needs

00:06:04,350 --> 00:06:08,490
to execute now this is effectively the

00:06:06,810 --> 00:06:10,170
same thing that a compiler does on a

00:06:08,490 --> 00:06:13,110
compiled language but it happens at

00:06:10,170 --> 00:06:14,310
runtime and for that reason the process

00:06:13,110 --> 00:06:16,440
that's going on here is called

00:06:14,310 --> 00:06:18,000
just-in-time compilation because the

00:06:16,440 --> 00:06:20,400
conversion to machine language is

00:06:18,000 --> 00:06:22,800
happening just in time for the code to

00:06:20,400 --> 00:06:25,920
execute in contrast to ahead of time

00:06:22,800 --> 00:06:27,990
compilation of a compiled language so a

00:06:25,920 --> 00:06:30,090
jetting interpreter a just-in-time

00:06:27,990 --> 00:06:33,060
interpreter will optimize the code at

00:06:30,090 --> 00:06:35,520
runtime to make it run faster the

00:06:33,060 --> 00:06:38,670
question then becomes can we game the

00:06:35,520 --> 00:06:40,350
system can we do something to our code

00:06:38,670 --> 00:06:42,950
that will make it easier for the

00:06:40,350 --> 00:06:45,540
interpreter to identify possible in

00:06:42,950 --> 00:06:49,230
optimizations and it turns out the

00:06:45,540 --> 00:06:51,030
answer is yes for example in JavaScript

00:06:49,230 --> 00:06:54,300
the result of a logical or

00:06:51,030 --> 00:06:57,810
with an integer is always an integer if

00:06:54,300 --> 00:07:00,060
you or an integer or two or with an

00:06:57,810 --> 00:07:03,510
integer of zero you get the original

00:07:00,060 --> 00:07:05,550
integer so if we or both of our

00:07:03,510 --> 00:07:07,950
functions arguments were zero the

00:07:05,550 --> 00:07:10,770
interpreter can know that the indicial

00:07:07,950 --> 00:07:12,750
operation must be an integer operation

00:07:10,770 --> 00:07:15,720
it doesn't matter what the types of

00:07:12,750 --> 00:07:17,790
first and second are the the addition is

00:07:15,720 --> 00:07:19,710
an integer addition and because of that

00:07:17,790 --> 00:07:21,270
the JavaScript engine can easily

00:07:19,710 --> 00:07:23,640
identify that it can optimize the

00:07:21,270 --> 00:07:25,410
implementation of this method and only

00:07:23,640 --> 00:07:27,240
do integer addition something that has a

00:07:25,410 --> 00:07:30,570
direct interpretation in machine

00:07:27,240 --> 00:07:32,970
language and is therefore fast okay

00:07:30,570 --> 00:07:35,010
that's a neat trick but why do we care

00:07:32,970 --> 00:07:36,720
after all we have to you know deface our

00:07:35,010 --> 00:07:38,580
code pretty badly to be able to realize

00:07:36,720 --> 00:07:41,820
that optimization so you know is it

00:07:38,580 --> 00:07:43,440
really worth it well you know if you're

00:07:41,820 --> 00:07:45,960
looking at this as a way to speed up

00:07:43,440 --> 00:07:49,080
your handwritten JavaScript probably not

00:07:45,960 --> 00:07:52,260
but take another look at what we've just

00:07:49,080 --> 00:07:54,330
been able to do by just annotating our

00:07:52,260 --> 00:07:56,640
JavaScript code we've been able to

00:07:54,330 --> 00:07:59,010
convince the JavaScript interpreter the

00:07:56,640 --> 00:08:01,380
dynamic JavaScript interpreter to give

00:07:59,010 --> 00:08:03,900
us near direct access to optimized

00:08:01,380 --> 00:08:05,670
integer arithmetic it's a very

00:08:03,900 --> 00:08:07,080
roundabout way of expressing it and the

00:08:05,670 --> 00:08:08,970
optimization doesn't happen until the

00:08:07,080 --> 00:08:12,480
code is actually running but we have

00:08:08,970 --> 00:08:15,600
used an interpreted language to expose a

00:08:12,480 --> 00:08:18,150
primitive machine language construct if

00:08:15,600 --> 00:08:20,970
we can expose one machine language

00:08:18,150 --> 00:08:24,330
construct can we expose all the

00:08:20,970 --> 00:08:25,650
capabilities of machine language a few

00:08:24,330 --> 00:08:27,300
years back a team at Mozilla looked at

00:08:25,650 --> 00:08:29,280
the JavaScript language to determine if

00:08:27,300 --> 00:08:30,960
there was a set of JavaScript code

00:08:29,280 --> 00:08:33,420
annotations and conventions that you

00:08:30,960 --> 00:08:35,430
could use to trick a jigging JavaScript

00:08:33,420 --> 00:08:37,470
interpreter to expose near direct access

00:08:35,430 --> 00:08:39,840
to the full capabilities of your CPU and

00:08:37,470 --> 00:08:44,400
what they came up with is called a SMD

00:08:39,840 --> 00:08:47,670
is a SM jeaious is 100% legal javascript

00:08:44,400 --> 00:08:49,320
code it is not pretty JavaScript code it

00:08:47,670 --> 00:08:51,330
only uses a subset of everything that's

00:08:49,320 --> 00:08:52,890
available in JavaScript and the code is

00:08:51,330 --> 00:08:54,540
covered with annotations and weird

00:08:52,890 --> 00:08:57,020
coding conventions like the zero was

00:08:54,540 --> 00:08:59,580
that I showed before but in combination

00:08:57,020 --> 00:09:01,560
those annotations and conventions

00:08:59,580 --> 00:09:03,420
provide our set of low-level primitives

00:09:01,560 --> 00:09:04,680
to perform integer and floating-point

00:09:03,420 --> 00:09:06,930
arithmetic I'll

00:09:04,680 --> 00:09:09,810
Cape memory define and invoke functions

00:09:06,930 --> 00:09:11,580
and so on capabilities that map directly

00:09:09,810 --> 00:09:14,100
under the capabilities of machine

00:09:11,580 --> 00:09:16,110
language they have effectively defined a

00:09:14,100 --> 00:09:18,630
way to expose machine language

00:09:16,110 --> 00:09:21,450
capabilities of a CPU using nothing but

00:09:18,630 --> 00:09:24,410
JavaScript a dynamic language which

00:09:21,450 --> 00:09:28,470
means effectively it is a crossed CPU

00:09:24,410 --> 00:09:30,060
assembly language but even a smj s can

00:09:28,470 --> 00:09:32,700
be improved upon what is delivered by a

00:09:30,060 --> 00:09:34,620
smj s is still JavaScript code

00:09:32,700 --> 00:09:37,140
admittedly it's almost entirely

00:09:34,620 --> 00:09:38,459
illegible JavaScript code but it and it

00:09:37,140 --> 00:09:41,310
does need to be transmitted in a text

00:09:38,459 --> 00:09:44,399
format then parsed then interpreted then

00:09:41,310 --> 00:09:46,110
executed and then jittered if we know

00:09:44,399 --> 00:09:47,459
ahead of time that our code will be

00:09:46,110 --> 00:09:50,100
compatible with the fast JavaScript

00:09:47,459 --> 00:09:52,709
subset can we send our code to the

00:09:50,100 --> 00:09:55,709
browser in a ready-to-use format and

00:09:52,709 --> 00:09:58,440
that's what webassembly or wasm is web

00:09:55,709 --> 00:10:00,870
assembly is a binary format formalizing

00:09:58,440 --> 00:10:02,310
the ASM jeaious language subset in a

00:10:00,870 --> 00:10:05,399
format that can be delivered to the

00:10:02,310 --> 00:10:07,410
browser in a pre passed form pre hinted

00:10:05,399 --> 00:10:09,810
for jetting purposes that makes it

00:10:07,410 --> 00:10:12,330
smaller to transmit than is MJS because

00:10:09,810 --> 00:10:14,010
it is a binary format it's faster to

00:10:12,330 --> 00:10:16,560
start because you don't have to parse

00:10:14,010 --> 00:10:18,630
any code it's in binary format and it's

00:10:16,560 --> 00:10:20,250
more consistent in operation because you

00:10:18,630 --> 00:10:24,120
are telling the JIT where the

00:10:20,250 --> 00:10:27,120
optimizations are so that's how we got

00:10:24,120 --> 00:10:29,490
here but how do we actually use it well

00:10:27,120 --> 00:10:31,500
the development story for Azzam actually

00:10:29,490 --> 00:10:33,029
pretty closely mirrors the story that

00:10:31,500 --> 00:10:36,089
I've already just told you about running

00:10:33,029 --> 00:10:38,610
normal executive or binaries wasm is

00:10:36,089 --> 00:10:40,589
ultimately a binary format but unless

00:10:38,610 --> 00:10:43,020
you belong to the standing in a hammock

00:10:40,589 --> 00:10:45,240
school of programming you're not going

00:10:43,020 --> 00:10:47,820
over going to write raw wisdom directly

00:10:45,240 --> 00:10:49,920
what you want is a human readable text

00:10:47,820 --> 00:10:53,640
based assembly format that can easily

00:10:49,920 --> 00:10:54,839
compiled into Azzam the tool chain you

00:10:53,640 --> 00:10:57,390
need to do this is called the web

00:10:54,839 --> 00:10:58,560
assembly binary toolkit the toolkit

00:10:57,390 --> 00:11:00,660
gives you a bunch of tools for

00:10:58,560 --> 00:11:02,820
manipulating wasm code including an

00:11:00,660 --> 00:11:05,339
assembly language compiler that lets you

00:11:02,820 --> 00:11:10,290
write wasm code in a text format called

00:11:05,339 --> 00:11:12,300
wet for web assembly text what looks

00:11:10,290 --> 00:11:14,579
like a weird hybrid between Lisp and

00:11:12,300 --> 00:11:17,070
assembly it is a core set of very

00:11:14,579 --> 00:11:17,670
primitive operations with a brace syntax

00:11:17,070 --> 00:11:20,370
to

00:11:17,670 --> 00:11:23,010
scoping rules explicit so here is our

00:11:20,370 --> 00:11:25,170
integer adding example in wet we define

00:11:23,010 --> 00:11:27,870
a module that contains a function called

00:11:25,170 --> 00:11:29,730
add it accepts two parameters namely

00:11:27,870 --> 00:11:32,250
first and second both of which are

00:11:29,730 --> 00:11:34,410
declared as being of type I 32 32-bit

00:11:32,250 --> 00:11:37,050
signed integers and it also returns a

00:11:34,410 --> 00:11:38,340
32-bit signed integer now the body of

00:11:37,050 --> 00:11:40,530
the method and executing where's a

00:11:38,340 --> 00:11:42,510
method is a stack based virtual machine

00:11:40,530 --> 00:11:44,970
so to do our addition we need to load

00:11:42,510 --> 00:11:46,590
the values provided as arguments onto

00:11:44,970 --> 00:11:48,720
our stack we get them and put them onto

00:11:46,590 --> 00:11:50,250
our stack I do the same for this first

00:11:48,720 --> 00:11:52,260
argument then the second argument now

00:11:50,250 --> 00:11:54,660
we've got two values on our stack we can

00:11:52,260 --> 00:11:57,180
then invoke the integer add operation I

00:11:54,660 --> 00:11:59,460
32 add that pops the top two values off

00:11:57,180 --> 00:12:00,960
the stack does the add pushes a single

00:11:59,460 --> 00:12:03,060
result back on to the stack which is the

00:12:00,960 --> 00:12:05,250
result of the addition we're now at the

00:12:03,060 --> 00:12:06,570
end of our method the value that is on

00:12:05,250 --> 00:12:08,100
top of the stack at that point is

00:12:06,570 --> 00:12:09,480
considered to be the return value of the

00:12:08,100 --> 00:12:11,820
method and so we've got a return value

00:12:09,480 --> 00:12:13,830
for our add method that completes a

00:12:11,820 --> 00:12:16,110
method definition we can now export that

00:12:13,830 --> 00:12:17,730
function to say okay this module defines

00:12:16,110 --> 00:12:19,980
the function and I want other modules to

00:12:17,730 --> 00:12:23,070
be able to see this function and that's

00:12:19,980 --> 00:12:25,110
it you save that as example dot wet you

00:12:23,070 --> 00:12:27,930
run a compiler called West to azzam over

00:12:25,110 --> 00:12:30,780
it and you get example dot wasm which

00:12:27,930 --> 00:12:34,080
spits out as a binary file 41 bytes in

00:12:30,780 --> 00:12:36,090
size to use that ways on file you need

00:12:34,080 --> 00:12:38,220
to write a little bit of JavaScript we

00:12:36,090 --> 00:12:40,050
fetch our wasm document we use the

00:12:38,220 --> 00:12:42,270
payload to instantiate the web assembly

00:12:40,050 --> 00:12:43,890
module and then we access the export of

00:12:42,270 --> 00:12:45,090
the module and just invoke them as if

00:12:43,890 --> 00:12:47,100
they were a standard function in this

00:12:45,090 --> 00:12:49,500
case we just call the exported add

00:12:47,100 --> 00:12:51,000
method with a couple of integers the add

00:12:49,500 --> 00:12:52,440
method returns an integer we can do

00:12:51,000 --> 00:12:54,060
whatever we need to do with that integer

00:12:52,440 --> 00:12:57,060
in this case we're setting the text

00:12:54,060 --> 00:12:59,010
content of an element on our page and to

00:12:57,060 --> 00:13:01,500
be clear this is not some theoretical

00:12:59,010 --> 00:13:03,480
future thing either this example will

00:13:01,500 --> 00:13:04,650
work in all of the major browsers that

00:13:03,480 --> 00:13:06,810
are in the field have been released in

00:13:04,650 --> 00:13:08,340
about the last two years there are a

00:13:06,810 --> 00:13:10,020
couple of optimizations you can use if

00:13:08,340 --> 00:13:12,540
you're cutting down to just Chrome and

00:13:10,020 --> 00:13:14,820
Firefox but this example as he is works

00:13:12,540 --> 00:13:17,640
in IE it works in Safari it works in

00:13:14,820 --> 00:13:20,010
chrome it works in Firefox alright so

00:13:17,640 --> 00:13:21,450
that's a simple addition example but

00:13:20,010 --> 00:13:23,520
integer addition is only gonna get you

00:13:21,450 --> 00:13:24,780
so far in the big wide world so what

00:13:23,520 --> 00:13:27,480
else can we do with wisdom

00:13:24,780 --> 00:13:30,030
well we're zoomed by itself is very

00:13:27,480 --> 00:13:31,400
primitive the full wisdom instruction

00:13:30,030 --> 00:13:34,340
specification is

00:13:31,400 --> 00:13:37,010
one relatively terse HTML page and it

00:13:34,340 --> 00:13:38,630
only has five sections first there are

00:13:37,010 --> 00:13:40,430
numeric instructions add subtract

00:13:38,630 --> 00:13:41,870
multiply divide there are billions like

00:13:40,430 --> 00:13:43,820
and' and or' there are function

00:13:41,870 --> 00:13:46,340
operations like square roots ceiling and

00:13:43,820 --> 00:13:48,010
floor min and Max comparison operations

00:13:46,340 --> 00:13:50,360
like equality less than greater than

00:13:48,010 --> 00:13:53,000
these can be invoked on integers and

00:13:50,360 --> 00:13:55,340
floats in 32 and 64-bit ranges signed

00:13:53,000 --> 00:13:57,380
and unsigned okay then there are

00:13:55,340 --> 00:13:59,450
variable instructions operations to get

00:13:57,380 --> 00:14:01,970
and set variables in your local scope

00:13:59,450 --> 00:14:03,500
there's also a T operation lets you set

00:14:01,970 --> 00:14:05,870
the variable and keep it on the stack at

00:14:03,500 --> 00:14:08,030
the same time next there are control

00:14:05,870 --> 00:14:10,610
instructions mechanisms to do branch

00:14:08,030 --> 00:14:12,470
control looping invoke other functions

00:14:10,610 --> 00:14:14,540
return a value from a function things

00:14:12,470 --> 00:14:16,460
like that there are memory instructions

00:14:14,540 --> 00:14:18,410
or mechanisms to allocate a block of

00:14:16,460 --> 00:14:21,140
memory for the wasm interpreter to load

00:14:18,410 --> 00:14:23,000
and store values into that memory memory

00:14:21,140 --> 00:14:25,820
is actually just implemented as an array

00:14:23,000 --> 00:14:27,650
of bytes the array can be grown in size

00:14:25,820 --> 00:14:30,490
but can't be shrunk so there's no free

00:14:27,650 --> 00:14:33,020
no no free discarding of memory and

00:14:30,490 --> 00:14:34,670
lastly there are parametric instructions

00:14:33,020 --> 00:14:35,930
these exist to let you discard values

00:14:34,670 --> 00:14:38,930
that happen to be on the stack you don't

00:14:35,930 --> 00:14:40,610
need anymore these instructions are then

00:14:38,930 --> 00:14:42,620
wrapped up in a module a module

00:14:40,610 --> 00:14:43,640
obviously includes function definitions

00:14:42,620 --> 00:14:45,740
but it includes lots of other

00:14:43,640 --> 00:14:47,750
information too there are types and

00:14:45,740 --> 00:14:49,670
tables that you describe more complex

00:14:47,750 --> 00:14:51,170
data structures in reference other

00:14:49,670 --> 00:14:53,510
functions in your weather module

00:14:51,170 --> 00:14:55,040
memories describe blocks of memory that

00:14:53,510 --> 00:14:57,080
can be allocated and referenced by your

00:14:55,040 --> 00:14:59,900
net weather methods Global's define

00:14:57,080 --> 00:15:02,180
global variables global to the module

00:14:59,900 --> 00:15:04,550
exports to find the interface that your

00:15:02,180 --> 00:15:06,620
weather module exposes externally and

00:15:04,550 --> 00:15:08,180
inputs describe the external functions

00:15:06,620 --> 00:15:10,640
that your weather module will be able to

00:15:08,180 --> 00:15:12,380
invoke and depend upon and lastly

00:15:10,640 --> 00:15:13,880
there's space for you to define data and

00:15:12,380 --> 00:15:16,880
code that will execute when the module

00:15:13,880 --> 00:15:18,800
is instantiated one thing you might have

00:15:16,880 --> 00:15:21,050
noticed that I haven't mentioned any

00:15:18,800 --> 00:15:23,660
discussion of text strings

00:15:21,050 --> 00:15:26,450
that's because wisdom doesn't support

00:15:23,660 --> 00:15:28,550
text strings a string in wisdom is

00:15:26,450 --> 00:15:30,560
handled the same way your CPU handles it

00:15:28,550 --> 00:15:32,660
wisdom only knows about integers and

00:15:30,560 --> 00:15:34,580
floats so to create a string you

00:15:32,660 --> 00:15:36,500
allocate a block of memory and use an

00:15:34,580 --> 00:15:38,180
integer as a pointer to the position of

00:15:36,500 --> 00:15:40,280
that memory in the overall memory of

00:15:38,180 --> 00:15:42,020
your wasm instance you use that block of

00:15:40,280 --> 00:15:44,000
memory to store a list of integers and

00:15:42,020 --> 00:15:44,899
you assign some sort of significance to

00:15:44,000 --> 00:15:47,629
the value of those

00:15:44,899 --> 00:15:49,639
integers be that ASCII or utf-8 encoded

00:15:47,629 --> 00:15:51,860
code points or whatever encoding

00:15:49,639 --> 00:15:54,050
structure you want when I say where's 'm

00:15:51,860 --> 00:15:56,869
exposes primitives that's what I mean

00:15:54,050 --> 00:15:59,809
primitives remember it's an assembly

00:15:56,869 --> 00:16:02,329
language but just as very few people

00:15:59,809 --> 00:16:04,040
write raw assembly code anymore very few

00:16:02,329 --> 00:16:06,110
people actually need to write raw azzam

00:16:04,040 --> 00:16:08,480
either a much easier approach is to use

00:16:06,110 --> 00:16:11,029
a compiler for a language that can

00:16:08,480 --> 00:16:12,949
target wisdom the most notable of these

00:16:11,029 --> 00:16:15,949
compilers in the first by some quite

00:16:12,949 --> 00:16:18,470
some period was in script n' in script

00:16:15,949 --> 00:16:20,029
n' is a back-end to the clang c compiler

00:16:18,470 --> 00:16:22,220
if you've got a language that clang can

00:16:20,029 --> 00:16:24,709
compile like c and almost every other

00:16:22,220 --> 00:16:27,860
language that's compiled inscription can

00:16:24,709 --> 00:16:30,379
turn that code into a wasm binary so

00:16:27,860 --> 00:16:33,589
let's go we'll define ourselves a simple

00:16:30,379 --> 00:16:35,509
c function to do our addition we use

00:16:33,589 --> 00:16:37,519
them in script and compiler directive to

00:16:35,509 --> 00:16:38,929
say this is a keepalive function this is

00:16:37,519 --> 00:16:42,019
a function that we want to be able to

00:16:38,929 --> 00:16:44,119
export out of our module we then use the

00:16:42,019 --> 00:16:47,269
in script in C compiler EMCC

00:16:44,119 --> 00:16:49,459
to compile example dot C into example J

00:16:47,269 --> 00:16:52,670
s now notice here we don't compile

00:16:49,459 --> 00:16:54,829
example dot wisdom directly using C

00:16:52,670 --> 00:16:56,509
means there is some overhead there's a

00:16:54,829 --> 00:16:58,370
bunch of C related infrastructure that

00:16:56,509 --> 00:17:01,100
needs to be set up an example dot J s

00:16:58,370 --> 00:17:03,290
contains that bootstrapping code we need

00:17:01,100 --> 00:17:05,240
to tell EMCC the name of the module that

00:17:03,290 --> 00:17:06,740
we want to export it was call it example

00:17:05,240 --> 00:17:08,600
in this case and we want to tell it that

00:17:06,740 --> 00:17:10,579
we want to export the C R app runtime

00:17:08,600 --> 00:17:13,640
method I'll come back to that one in

00:17:10,579 --> 00:17:15,230
just a moment if our wasm module

00:17:13,640 --> 00:17:17,299
contained an entry point if it had a

00:17:15,230 --> 00:17:19,610
main method a main entry method we could

00:17:17,299 --> 00:17:21,020
just include example J s in our HTML

00:17:19,610 --> 00:17:23,510
page and every time the page was loaded

00:17:21,020 --> 00:17:25,789
our work as a module will be executed as

00:17:23,510 --> 00:17:27,740
well however if we want to interact with

00:17:25,789 --> 00:17:31,130
the module we need to hook into the

00:17:27,740 --> 00:17:33,020
modules lifecycle so in our HTML we pre

00:17:31,130 --> 00:17:35,960
declared the existence of an example

00:17:33,020 --> 00:17:38,480
module an example object and we define a

00:17:35,960 --> 00:17:40,610
method to invoke when the wasm runtime

00:17:38,480 --> 00:17:42,710
has been initialized in that method

00:17:40,610 --> 00:17:44,750
we're going to define a wrapper for our

00:17:42,710 --> 00:17:47,570
C method declaring the mapping from the

00:17:44,750 --> 00:17:49,399
JavaScript types to the C types and then

00:17:47,570 --> 00:17:50,630
return the types are the types in the

00:17:49,399 --> 00:17:53,360
arguments and we can invoke that

00:17:50,630 --> 00:17:55,279
JavaScript function ok and that's that's

00:17:53,360 --> 00:17:57,440
the role of the of the c wrap method

00:17:55,279 --> 00:17:58,429
that we exposed in the last slide we

00:17:57,440 --> 00:18:00,889
then include the

00:17:58,429 --> 00:18:03,460
example script this will augment the pre

00:18:00,889 --> 00:18:07,129
declared example module as example Datuk

00:18:03,460 --> 00:18:09,139
is is is executed now for a simple

00:18:07,129 --> 00:18:10,789
example like this that's a lot of oh

00:18:09,139 --> 00:18:12,889
there is a lot of overhead the example

00:18:10,789 --> 00:18:15,289
this example produces about a hundred

00:18:12,889 --> 00:18:17,629
kilobytes of bootstrapping support code

00:18:15,289 --> 00:18:21,649
at about twenty one kilobytes of was in

00:18:17,629 --> 00:18:25,159
binary however a lot of that overhead is

00:18:21,649 --> 00:18:27,259
included just in case and by default c

00:18:25,159 --> 00:18:30,559
compilers optimized for compilation

00:18:27,259 --> 00:18:32,149
speed not output size so when you are

00:18:30,559 --> 00:18:34,730
ready to go into production you can tell

00:18:32,149 --> 00:18:36,529
EMCC to strip out everything that isn't

00:18:34,730 --> 00:18:38,480
needed and that dramatically reduces the

00:18:36,529 --> 00:18:40,039
payload size and it can also minify the

00:18:38,480 --> 00:18:42,139
javascript as well while that's at it

00:18:40,039 --> 00:18:43,730
that optimization can be performed at

00:18:42,139 --> 00:18:46,159
various levels of severity and

00:18:43,730 --> 00:18:47,570
optimization level three the complete

00:18:46,159 --> 00:18:49,490
output of this example this this

00:18:47,570 --> 00:18:52,399
addition example is ninety nineteen

00:18:49,490 --> 00:18:54,499
kilobytes of minified javascript and a

00:18:52,399 --> 00:18:56,330
hundred and sixty five bytes of wasm

00:18:54,499 --> 00:18:58,580
which is yes more than our original

00:18:56,330 --> 00:19:02,480
forty one byte handcrafted watt derived

00:18:58,580 --> 00:19:03,799
output but there there is still you get

00:19:02,480 --> 00:19:06,590
you get do gets and benefits out of that

00:19:03,799 --> 00:19:08,330
there is still some overhead but the

00:19:06,590 --> 00:19:09,619
benefits you get you don't have to one

00:19:08,330 --> 00:19:12,049
you don't have to write assembly by hand

00:19:09,619 --> 00:19:15,019
and things like strings are handled

00:19:12,049 --> 00:19:17,360
almost transparently you can declare a c

00:19:15,019 --> 00:19:19,369
function that takes a c string a

00:19:17,360 --> 00:19:21,799
character pointer as an argument or

00:19:19,369 --> 00:19:24,320
return a c string you can invoke c

00:19:21,799 --> 00:19:26,690
built-in methods like string length or

00:19:24,320 --> 00:19:27,919
do console output with printf on the

00:19:26,690 --> 00:19:30,019
JavaScript side you can wrap that

00:19:27,919 --> 00:19:31,639
function and you can invoke the function

00:19:30,019 --> 00:19:33,139
with javascript strings you don't have

00:19:31,639 --> 00:19:36,070
to do an exchange back and forth and

00:19:33,139 --> 00:19:38,570
worry about the the encoding process in

00:19:36,070 --> 00:19:41,149
scripting also makes it easy to interact

00:19:38,570 --> 00:19:42,590
with javascript simple scripts can be

00:19:41,149 --> 00:19:44,480
just invoked directly there is a c

00:19:42,590 --> 00:19:46,789
function called in script and run script

00:19:44,480 --> 00:19:48,619
and it will run javascript or you can

00:19:46,789 --> 00:19:50,690
setup a block of javascript as a c

00:19:48,619 --> 00:19:53,029
callable function so here's another

00:19:50,690 --> 00:19:56,240
example the second card lock the int

00:19:53,029 --> 00:19:58,159
myfunc is written in c it directly

00:19:56,240 --> 00:20:00,110
invokes the JavaScript alert method

00:19:58,159 --> 00:20:03,529
using in script and run script and then

00:20:00,110 --> 00:20:06,440
it calls the j s add function j s add is

00:20:03,529 --> 00:20:08,119
defined in the first code block es j s

00:20:06,440 --> 00:20:09,710
is another in script and compiler

00:20:08,119 --> 00:20:12,080
directive it allows you to embed

00:20:09,710 --> 00:20:14,600
directly embed javascript code in

00:20:12,080 --> 00:20:16,700
you're see source code file and expose

00:20:14,600 --> 00:20:18,260
that JavaScript code as if it was a

00:20:16,700 --> 00:20:23,029
JavaScript me sorry as if it was AC

00:20:18,260 --> 00:20:25,640
method my func is AC method so when it's

00:20:23,029 --> 00:20:27,529
invoked we will be using in scripting to

00:20:25,640 --> 00:20:29,419
compile the C function that wraps a

00:20:27,529 --> 00:20:35,750
JavaScript function that does addition

00:20:29,419 --> 00:20:37,429
in JavaScript you also get access to a

00:20:35,750 --> 00:20:39,230
bunch of other tools and api's that are

00:20:37,429 --> 00:20:41,450
part of the in scripting tool chain in

00:20:39,230 --> 00:20:43,010
scripting provides bindings to html5

00:20:41,450 --> 00:20:44,840
events so you can write native

00:20:43,010 --> 00:20:47,360
implementations of keyboard mouse and

00:20:44,840 --> 00:20:48,230
scroll handlers you get access to a file

00:20:47,360 --> 00:20:50,120
system API

00:20:48,230 --> 00:20:51,740
you are still sandbox you don't can't

00:20:50,120 --> 00:20:53,929
read and write files from your users

00:20:51,740 --> 00:20:55,639
file system but you do get a virtualized

00:20:53,929 --> 00:20:58,580
file system that you can feed binary

00:20:55,639 --> 00:21:00,950
blobs and treat them as files and access

00:20:58,580 --> 00:21:02,929
them using C file api's you can use the

00:21:00,950 --> 00:21:04,880
browser's fetch API to retrieve other

00:21:02,929 --> 00:21:07,100
network resources and you can access

00:21:04,880 --> 00:21:11,149
Hardware optimized web api's like WebGL

00:21:07,100 --> 00:21:12,409
and web VR now inscription was very much

00:21:11,149 --> 00:21:13,820
the first player in this compiled

00:21:12,409 --> 00:21:15,679
language space but it isn't the only

00:21:13,820 --> 00:21:17,840
player anymore by long long shot for

00:21:15,679 --> 00:21:20,630
example the rust compiler can compile

00:21:17,840 --> 00:21:21,889
directly to resum the rust project has a

00:21:20,630 --> 00:21:23,630
really good tutorial for how to write

00:21:21,889 --> 00:21:26,929
and deploy logic for your web app

00:21:23,630 --> 00:21:29,539
completely in rust all right so that's

00:21:26,929 --> 00:21:31,940
the how you generate wasm code but why

00:21:29,539 --> 00:21:34,399
is wisdom of interest to us as Python

00:21:31,940 --> 00:21:36,500
and Django users well there are two

00:21:34,399 --> 00:21:39,679
primary use cases for wasm in production

00:21:36,500 --> 00:21:41,840
right now today the first is deploying a

00:21:39,679 --> 00:21:44,779
full application that is written in C

00:21:41,840 --> 00:21:47,360
already for example if you head to quake

00:21:44,779 --> 00:21:50,029
J Escom you will find a full port of

00:21:47,360 --> 00:21:52,370
quake 3 compiled and running in your

00:21:50,029 --> 00:21:54,230
browser it does take a minute or two to

00:21:52,370 --> 00:21:56,570
download because you are downloading the

00:21:54,230 --> 00:21:58,549
whole of quake but once it's there it is

00:21:56,570 --> 00:22:02,090
a fully functioning 3d first-person

00:21:58,549 --> 00:22:04,309
shooter running in your browser why does

00:22:02,090 --> 00:22:06,980
this work well quake is written in C

00:22:04,309 --> 00:22:09,559
code using OpenGL keeper and keyboard

00:22:06,980 --> 00:22:12,320
inputs that means it Maps directly onto

00:22:09,559 --> 00:22:13,580
the capabilities of web assembly and so

00:22:12,320 --> 00:22:16,250
it's an easy win you just have to

00:22:13,580 --> 00:22:18,679
recompile essentially quake with MCC and

00:22:16,250 --> 00:22:21,710
you get a webpage you can load that is

00:22:18,679 --> 00:22:23,029
quake the QT widget toolkit is also

00:22:21,710 --> 00:22:24,620
working on a web assembly port so if

00:22:23,029 --> 00:22:26,390
you've got a QT app

00:22:24,620 --> 00:22:28,940
you can compile that app and deliver it

00:22:26,390 --> 00:22:31,070
over the web potentially now I won't say

00:22:28,940 --> 00:22:33,620
it is trivial to do this but the

00:22:31,070 --> 00:22:35,660
inscription build tool chain Maps really

00:22:33,620 --> 00:22:37,880
well onto the Auto confer tall chain so

00:22:35,660 --> 00:22:40,220
if you've got AC project with an auto

00:22:37,880 --> 00:22:43,640
conf configuration which again is a lot

00:22:40,220 --> 00:22:45,950
of them compiling an existing C project

00:22:43,640 --> 00:22:47,570
for wasm can be relatively

00:22:45,950 --> 00:22:50,690
straightforward if once you've worked

00:22:47,570 --> 00:22:53,240
out you know the little details use case

00:22:50,690 --> 00:22:54,830
to is to identify hot loops or critical

00:22:53,240 --> 00:22:56,990
bit over for business critical business

00:22:54,830 --> 00:22:59,600
capabilities and replace those hot loops

00:22:56,990 --> 00:23:00,950
with where some implementations for

00:22:59,600 --> 00:23:03,710
example google has published a

00:23:00,950 --> 00:23:06,170
demonstrator app called Skoosh Skoosh is

00:23:03,710 --> 00:23:08,090
an app for doing image manipulation for

00:23:06,170 --> 00:23:09,760
exploring the before and after effects

00:23:08,090 --> 00:23:12,620
of various forms of image compression

00:23:09,760 --> 00:23:14,510
resizing and resampling algorithms the

00:23:12,620 --> 00:23:17,570
app itself is a node app delivering

00:23:14,510 --> 00:23:19,550
basic app scaffolding and content but it

00:23:17,570 --> 00:23:22,580
uses wisdom to implement the image

00:23:19,550 --> 00:23:24,950
processing almost all of your standard

00:23:22,580 --> 00:23:27,290
image codecs like Lib JPEG are written

00:23:24,950 --> 00:23:30,350
in C so instead of trying to re

00:23:27,290 --> 00:23:32,240
implement all of Lib jpg in JavaScript

00:23:30,350 --> 00:23:33,830
or having some server back and forth

00:23:32,240 --> 00:23:36,490
that is going to have some latency which

00:23:33,830 --> 00:23:39,860
you know trust me in Australia we notice

00:23:36,490 --> 00:23:42,350
you you can just say take Lib JPEG and

00:23:39,860 --> 00:23:44,270
put it in the browser if you've got an

00:23:42,350 --> 00:23:46,910
existing C library you need to use

00:23:44,270 --> 00:23:49,370
client-side you can and you just call it

00:23:46,910 --> 00:23:51,590
as if it was JavaScript or if you're

00:23:49,370 --> 00:23:53,270
writing a web app that has a hot loop a

00:23:51,590 --> 00:23:55,760
method or part of a method that is very

00:23:53,270 --> 00:23:57,740
CPU intensive you can replace that hot

00:23:55,760 --> 00:23:59,630
loop with Waze and code written in C or

00:23:57,740 --> 00:24:02,480
rust or any other compiled language that

00:23:59,630 --> 00:24:04,040
can target plasm if you want to quickly

00:24:02,480 --> 00:24:05,809
play around with wisdom the best tool I

00:24:04,040 --> 00:24:07,880
can recommend is web assembly studio

00:24:05,809 --> 00:24:09,740
that is actually a URL not a product

00:24:07,880 --> 00:24:11,780
name if you stick that into your browser

00:24:09,740 --> 00:24:12,679
you will get a simple wasm development

00:24:11,780 --> 00:24:14,300
environment that you can play around

00:24:12,679 --> 00:24:16,160
with without having to download and

00:24:14,300 --> 00:24:17,510
compile any of the tool chains if you

00:24:16,160 --> 00:24:19,309
like what you see there then it's well

00:24:17,510 --> 00:24:21,230
worth downloading web assembly binary

00:24:19,309 --> 00:24:24,500
toolkit and scripting or rust spasm

00:24:21,230 --> 00:24:26,929
tooling so those are the viable use

00:24:24,500 --> 00:24:29,929
cases today but what does the future

00:24:26,929 --> 00:24:32,720
hold how do we make use of Python in the

00:24:29,929 --> 00:24:34,130
wasm world well if you think back to the

00:24:32,720 --> 00:24:36,050
start of this talk I spoke about the

00:24:34,130 --> 00:24:37,940
past of getting code to run from

00:24:36,050 --> 00:24:38,330
assembly language to compiled language

00:24:37,940 --> 00:24:40,640
to in

00:24:38,330 --> 00:24:42,350
languages and then I described a similar

00:24:40,640 --> 00:24:44,060
path with wisdom to finding an assembly

00:24:42,350 --> 00:24:46,430
language compilers that target that

00:24:44,060 --> 00:24:49,100
assembly language there's one more step

00:24:46,430 --> 00:24:51,590
to take you can write language

00:24:49,100 --> 00:24:54,680
interpreters that can be deployed as

00:24:51,590 --> 00:24:56,720
well now I can't say this is quite ready

00:24:54,680 --> 00:24:58,040
for primetime today there are a couple

00:24:56,720 --> 00:24:59,810
of projects exploring this space that

00:24:58,040 --> 00:25:01,520
are worth keeping an eye on the most

00:24:59,810 --> 00:25:03,620
notable at the moment is paya Diet from

00:25:01,520 --> 00:25:06,410
Mozilla paya died is quite literally the

00:25:03,620 --> 00:25:08,090
sea Python source code compiled within

00:25:06,410 --> 00:25:09,830
scripting they've also gone to the

00:25:08,090 --> 00:25:11,660
trouble of compiling numpy and supply

00:25:09,830 --> 00:25:14,690
and matplotlib some other key parts of

00:25:11,660 --> 00:25:16,940
the scientific Python ecosystem if you

00:25:14,690 --> 00:25:19,400
take the wasm binary produced by in

00:25:16,940 --> 00:25:20,990
script and compiling C Python hook it up

00:25:19,400 --> 00:25:23,600
to the elements of a webpage the input

00:25:20,990 --> 00:25:25,370
elements of a web page you get a Python

00:25:23,600 --> 00:25:27,620
shell in your browser completely

00:25:25,370 --> 00:25:30,860
client-side no server side component and

00:25:27,620 --> 00:25:32,980
the PI a demo is effectively a 100%

00:25:30,860 --> 00:25:35,360
client-side Python environment

00:25:32,980 --> 00:25:38,120
comparable to a Jupiter notebook session

00:25:35,360 --> 00:25:41,690
it is a full Python parser compiler

00:25:38,120 --> 00:25:43,970
runtime and X and a graphics engine the

00:25:41,690 --> 00:25:46,370
downside is that it's big

00:25:43,970 --> 00:25:48,200
the wasm file for the pi died version is

00:25:46,370 --> 00:25:49,760
of just C Python is around three

00:25:48,200 --> 00:25:51,470
megabytes and that's before you've given

00:25:49,760 --> 00:25:54,710
at any Python code or standard library

00:25:51,470 --> 00:25:56,510
to run with sorry if C Python is too big

00:25:54,710 --> 00:25:58,280
maybe we just need a smaller Python

00:25:56,510 --> 00:26:00,650
what about micro pison it's written in C

00:25:58,280 --> 00:26:02,360
can we compile that well yes you can and

00:26:00,650 --> 00:26:05,300
yes it's been done and yes it's on NPM

00:26:02,360 --> 00:26:06,890
you can install via NPM a JavaScript

00:26:05,300 --> 00:26:08,600
package that provides the micro Python

00:26:06,890 --> 00:26:10,430
virtual machine and yes it is small and

00:26:08,600 --> 00:26:12,860
tired I'd the official distributions

00:26:10,430 --> 00:26:14,420
just shy of one megabyte both of those

00:26:12,860 --> 00:26:16,160
projects are still experimental but they

00:26:14,420 --> 00:26:17,660
are very interesting developments but

00:26:16,160 --> 00:26:20,420
they both take a very similar approach

00:26:17,660 --> 00:26:23,900
they're exposing a full Python ripple in

00:26:20,420 --> 00:26:25,160
the browser my own experimentation in

00:26:23,900 --> 00:26:26,780
this space has been somewhat their

00:26:25,160 --> 00:26:29,180
somewhat different Battaglia

00:26:26,780 --> 00:26:31,280
provides Python in the browser by just

00:26:29,180 --> 00:26:33,530
implementing the C Python virtual

00:26:31,280 --> 00:26:35,600
machine so it doesn't need to have the

00:26:33,530 --> 00:26:37,220
compiler and parser it just needs the

00:26:35,600 --> 00:26:39,590
bits that runs the bytecode

00:26:37,220 --> 00:26:41,540
if you take if you transmit python

00:26:39,590 --> 00:26:43,790
bytecode the py c file the contents of

00:26:41,540 --> 00:26:46,100
your py c files on the wire you don't

00:26:43,790 --> 00:26:48,530
need a compiler and a parcel you just

00:26:46,100 --> 00:26:50,420
need the bytecode machine Batavia

00:26:48,530 --> 00:26:51,520
currently does this by implementing the

00:26:50,420 --> 00:26:54,280
C Python Baker

00:26:51,520 --> 00:26:56,260
virtual machine in pure JavaScript but

00:26:54,280 --> 00:26:58,360
wisdom might provide an alternative here

00:26:56,260 --> 00:27:00,610
if you were to take the C Python sources

00:26:58,360 --> 00:27:02,560
strip out the parser and the compiler

00:27:00,610 --> 00:27:04,300
you should end up with a much smaller

00:27:02,560 --> 00:27:06,790
Python interpreter the one that's

00:27:04,300 --> 00:27:09,040
capable of running all C price and

00:27:06,790 --> 00:27:11,910
bytecode and it would actually support

00:27:09,040 --> 00:27:13,660
the seatpost the C module extension API

00:27:11,910 --> 00:27:15,820
combine that with some smart

00:27:13,660 --> 00:27:19,750
tree-shaking and an entirely client-side

00:27:15,820 --> 00:27:21,640
Python starts to look plausible and that

00:27:19,750 --> 00:27:22,990
C module compatibility is itself a point

00:27:21,640 --> 00:27:24,700
of interest one of the major reasons

00:27:22,990 --> 00:27:26,380
that people write C modules today for

00:27:24,700 --> 00:27:27,970
Python is for performance reasons to

00:27:26,380 --> 00:27:31,120
take the hot loop in your Python code

00:27:27,970 --> 00:27:32,590
and run it in C but using a C module

00:27:31,120 --> 00:27:34,060
means that your Python no longer runs

00:27:32,590 --> 00:27:36,130
cross-platform at least not without

00:27:34,060 --> 00:27:38,350
recompiling it for each platform that

00:27:36,130 --> 00:27:42,100
you need to deploy to but if you compile

00:27:38,350 --> 00:27:45,040
your C module code to well you get a

00:27:42,100 --> 00:27:46,810
cross-platform native binary all you

00:27:45,040 --> 00:27:49,210
need then is the ability to invoke it

00:27:46,810 --> 00:27:50,710
from within your place in code which is

00:27:49,210 --> 00:27:53,200
what a Python module called was Emma

00:27:50,710 --> 00:27:54,670
does ways OMA is part of a larger binary

00:27:53,200 --> 00:27:57,340
project that aims to be a way to

00:27:54,670 --> 00:27:59,290
distribute wasm code as Universal

00:27:57,340 --> 00:28:04,660
binaries that can run on any platform

00:27:59,290 --> 00:28:07,630
you want so wrapping up in the mid-90s

00:28:04,660 --> 00:28:09,640
Java was the hotness because it was

00:28:07,630 --> 00:28:12,070
gonna deliver write once run anywhere

00:28:09,640 --> 00:28:14,800
code it was able to run everywhere

00:28:12,070 --> 00:28:17,110
because it specified a bytecode format

00:28:14,800 --> 00:28:19,660
and provided a cross-platform virtual

00:28:17,110 --> 00:28:22,360
machine but it strongly coupled a new

00:28:19,660 --> 00:28:24,520
programming language Java to that whole

00:28:22,360 --> 00:28:26,680
runtime experience and while the world

00:28:24,520 --> 00:28:29,230
got really enthusiastic about Java and

00:28:26,680 --> 00:28:30,970
Java isn't going anywhere it wasn't able

00:28:29,230 --> 00:28:34,870
to completely replace all other

00:28:30,970 --> 00:28:36,760
programming languages javascript was

00:28:34,870 --> 00:28:38,500
invented at about the same time and it

00:28:36,760 --> 00:28:40,540
is called JavaScript not because it has

00:28:38,500 --> 00:28:42,430
anything to do with Java but for

00:28:40,540 --> 00:28:43,900
marketing purposes to capitalize on that

00:28:42,430 --> 00:28:46,300
cross-platform enterprise-ready

00:28:43,900 --> 00:28:48,360
computing buzz that bid nineties Java

00:28:46,300 --> 00:28:51,130
had managed to develop so successfully

00:28:48,360 --> 00:28:53,350
javascript was a new language and it was

00:28:51,130 --> 00:28:57,190
cross-platform too so by golly it had to

00:28:53,350 --> 00:28:59,050
have Java in its name JavaScript didn't

00:28:57,190 --> 00:29:00,430
have a standardized bytecode form at all

00:28:59,050 --> 00:29:02,110
provide a virtual machine to make a

00:29:00,430 --> 00:29:04,440
cross-platform e to only work in the

00:29:02,110 --> 00:29:06,300
browser but over time the importance

00:29:04,440 --> 00:29:08,220
of the web as a platform has meant that

00:29:06,300 --> 00:29:10,800
people have tried bringing JavaScript

00:29:08,220 --> 00:29:12,900
everywhere they have essentially

00:29:10,800 --> 00:29:16,590
reinvented they tried to reinvent the

00:29:12,900 --> 00:29:18,540
universe using only JavaScript making

00:29:16,590 --> 00:29:22,280
exactly the same mistake for Java made

00:29:18,540 --> 00:29:25,170
focusing on the language not the runtime

00:29:22,280 --> 00:29:27,090
the great irony in all of this is that

00:29:25,170 --> 00:29:30,180
the promise that Java originally made

00:29:27,090 --> 00:29:32,580
write once run everywhere that promise

00:29:30,180 --> 00:29:34,800
may end up being delivered by JavaScript

00:29:32,580 --> 00:29:37,050
a language that borrowed the Java name

00:29:34,800 --> 00:29:39,210
purely for marketing purposes but even

00:29:37,050 --> 00:29:43,400
then we're going to get the capability

00:29:39,210 --> 00:29:46,110
by ignoring the language entirely

00:29:43,400 --> 00:29:48,540
javascript has the potential to actually

00:29:46,110 --> 00:29:50,220
be a universal computing platform not

00:29:48,540 --> 00:29:52,050
because javascript the language not

00:29:50,220 --> 00:29:53,790
because of javascript the language but

00:29:52,050 --> 00:29:55,980
because of the importance of the web as

00:29:53,790 --> 00:29:57,900
a platform and all the effort that's

00:29:55,980 --> 00:30:01,220
been put into optimizing JavaScript

00:29:57,900 --> 00:30:03,630
runtimes as a result almost by accident

00:30:01,220 --> 00:30:05,610
we have ended up with web assembly a

00:30:03,630 --> 00:30:07,800
mechanism for describing cross-platform

00:30:05,610 --> 00:30:09,570
native executables and that is

00:30:07,800 --> 00:30:11,460
ultimately better for everyone because

00:30:09,570 --> 00:30:13,080
it abandons the idea that there is one

00:30:11,460 --> 00:30:15,210
programming language to rule them all

00:30:13,080 --> 00:30:17,010
let alone let every language find its

00:30:15,210 --> 00:30:20,010
own niche and let different languages

00:30:17,010 --> 00:30:23,820
including Python coexist and cooperate

00:30:20,010 --> 00:30:25,170
in a universal binary world there is a

00:30:23,820 --> 00:30:26,460
lot of work that still needs to be done

00:30:25,170 --> 00:30:28,050
before we can speak about having an

00:30:26,460 --> 00:30:30,060
experience as a web developer that

00:30:28,050 --> 00:30:32,010
doesn't actually involve JavaScript or

00:30:30,060 --> 00:30:33,930
at least only involves JavaScript as an

00:30:32,010 --> 00:30:35,520
execution platform for our Python or

00:30:33,930 --> 00:30:37,620
whatever other language you happen to

00:30:35,520 --> 00:30:39,060
want to use I would like to be able to

00:30:37,620 --> 00:30:40,830
spend a lot more time working on this on

00:30:39,060 --> 00:30:42,570
batavia other aspects of the Python

00:30:40,830 --> 00:30:43,890
ecosystem by way of a quick plug if

00:30:42,570 --> 00:30:45,510
you'd like to support my work you can

00:30:43,890 --> 00:30:47,280
join the beware project as a financial

00:30:45,510 --> 00:30:49,320
member or if you prefer you can back me

00:30:47,280 --> 00:30:50,790
on github sponsors I will also be here

00:30:49,320 --> 00:30:52,650
for the rest of django con through the

00:30:50,790 --> 00:30:54,030
end of sprints if this or any of the

00:30:52,650 --> 00:30:55,440
other beware stuff interest you please

00:30:54,030 --> 00:30:57,900
come and have a chat I'm always happy to

00:30:55,440 --> 00:30:59,080
talk about any of this and more thank

00:30:57,900 --> 00:31:03,470
you all very much

00:30:59,080 --> 00:31:16,779
[Applause]

00:31:03,470 --> 00:31:16,779

YouTube URL: https://www.youtube.com/watch?v=M7KDhPG7vHw


