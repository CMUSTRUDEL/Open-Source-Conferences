Title: DjangoCon 2019 - Lazy Looping: The Next Iteration by Trey Hunner
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - Lazy Looping: The Next Iteration by Trey Hunner

In this talk we'll learn about the properties of iterators, learn how to create our own iterators with generators, and take a look at how iterators and generators allow us to write our looping code in a fundamentally different way.

This talk was presented at: https://2019.djangocon.us/talks/lazy-looping-the-next-iteration/

LINKS:
Follow Trey Hunner ðŸ‘‡
On Twitter: https://twitter.com/treyhunner
Official homepage: http://treyhunner.com

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:12,679
[Music]

00:00:15,290 --> 00:00:20,360
so my name is Trey and if you write

00:00:18,290 --> 00:00:21,890
Python code for a living you might want

00:00:20,360 --> 00:00:24,980
to check out a service that I run called

00:00:21,890 --> 00:00:27,289
Python morsels sign up choose your skill

00:00:24,980 --> 00:00:28,940
level novice intermediate advanced and

00:00:27,289 --> 00:00:30,770
you will learn something new about

00:00:28,940 --> 00:00:33,379
Python every week and if you don't send

00:00:30,770 --> 00:00:34,910
me an email because I want to know so we

00:00:33,379 --> 00:00:36,500
are going to quickly start with a

00:00:34,910 --> 00:00:39,440
problem

00:00:36,500 --> 00:00:42,500
this code finds lines in a log file that

00:00:39,440 --> 00:00:44,000
contain errors but it prints out not

00:00:42,500 --> 00:00:47,540
just the airline but the line just

00:00:44,000 --> 00:00:48,920
before it and the line just after it you

00:00:47,540 --> 00:00:50,360
don't need to understand this code we

00:00:48,920 --> 00:00:53,960
are going to look at it later so for now

00:00:50,360 --> 00:00:56,059
just forget about it when we do refactor

00:00:53,960 --> 00:00:58,309
that code later we're going to use lazy

00:00:56,059 --> 00:01:00,620
looping which is all about iterables and

00:00:58,309 --> 00:01:03,559
iterators so we need to define what

00:01:00,620 --> 00:01:06,350
iterables and iterators are an iterable

00:01:03,559 --> 00:01:08,750
is anything that you can loop over lists

00:01:06,350 --> 00:01:11,210
tuples files lots of things in Python

00:01:08,750 --> 00:01:13,340
are iterables if you can loop over

00:01:11,210 --> 00:01:15,259
something if you can write a for loop to

00:01:13,340 --> 00:01:17,630
iterate over anything in python that

00:01:15,259 --> 00:01:20,149
thing is by definition an iterable

00:01:17,630 --> 00:01:21,350
you are able to iterate over it so we

00:01:20,149 --> 00:01:23,509
kind of already know what intervals are

00:01:21,350 --> 00:01:26,869
even if you don't know this term but

00:01:23,509 --> 00:01:29,030
what our iterators so an iterator is a

00:01:26,869 --> 00:01:30,320
bit more complicated than iterables

00:01:29,030 --> 00:01:33,439
there are two definitions of these

00:01:30,320 --> 00:01:35,840
things first one is that iterators are

00:01:33,439 --> 00:01:39,079
the object that powers all iteration

00:01:35,840 --> 00:01:42,799
under the hood in Python second they're

00:01:39,079 --> 00:01:45,770
kind of a lazy iterable which is

00:01:42,799 --> 00:01:47,090
consumed as you loop over it we are

00:01:45,770 --> 00:01:48,649
going to completely ignore that first

00:01:47,090 --> 00:01:51,049
definition it's outside of the scope of

00:01:48,649 --> 00:01:54,590
this talk we're gonna focus entirely on

00:01:51,049 --> 00:01:56,390
using iterators as lazy intervals if you

00:01:54,590 --> 00:01:58,219
are interested in that first definition

00:01:56,390 --> 00:02:00,049
now you can watch another talk that I've

00:01:58,219 --> 00:02:02,299
given in the past called loop better in

00:02:00,049 --> 00:02:03,609
and I talked about how for loops under

00:02:02,299 --> 00:02:07,100
the hood and Python are powered by

00:02:03,609 --> 00:02:08,090
iterators we're again not going to talk

00:02:07,100 --> 00:02:13,069
about that though we're talking about

00:02:08,090 --> 00:02:17,350
how iterators are lazy intervals so this

00:02:13,069 --> 00:02:20,420
is one example of an iterator in Python

00:02:17,350 --> 00:02:22,400
file objects in Python are iterators

00:02:20,420 --> 00:02:23,599
you've probably worked with files before

00:02:22,400 --> 00:02:24,130
in Python but you might not have known

00:02:23,599 --> 00:02:26,590
that

00:02:24,130 --> 00:02:28,510
iterators I'm going to use this object

00:02:26,590 --> 00:02:30,850
here to show you what the two things you

00:02:28,510 --> 00:02:32,650
can do with iterators are so first thing

00:02:30,850 --> 00:02:34,750
we can do is pass an iterator to the

00:02:32,650 --> 00:02:37,210
next function that is built into Python

00:02:34,750 --> 00:02:39,070
this will give us the next item in the

00:02:37,210 --> 00:02:42,160
iterator which in the case of files

00:02:39,070 --> 00:02:44,740
gives us the next line in the file the

00:02:42,160 --> 00:02:46,900
second thing we can do is loop over them

00:02:44,740 --> 00:02:50,530
which is the same thing we can do with

00:02:46,900 --> 00:02:53,260
any other iterable on python but unlike

00:02:50,530 --> 00:02:56,440
other iterables iterators are consumed

00:02:53,260 --> 00:02:58,510
as you loop over them so if you start

00:02:56,440 --> 00:03:01,270
getting items from an iterator and then

00:02:58,510 --> 00:03:02,770
you stop the next time you start again

00:03:01,270 --> 00:03:05,560
you'll be right where you left off

00:03:02,770 --> 00:03:07,330
before and if you loop all the way

00:03:05,560 --> 00:03:10,150
through an iterator and then you try to

00:03:07,330 --> 00:03:12,340
loop over it again the second time it

00:03:10,150 --> 00:03:13,810
will be empty because this iterator at

00:03:12,340 --> 00:03:17,080
this point has been exhausted we've

00:03:13,810 --> 00:03:18,970
consumed all the items from within it so

00:03:17,080 --> 00:03:20,740
the benefit of iterators is that they

00:03:18,970 --> 00:03:23,650
are lazy instead of doing a whole bunch

00:03:20,740 --> 00:03:27,010
of work upfront they do little bits of

00:03:23,650 --> 00:03:29,860
work as we loop over them they usually

00:03:27,010 --> 00:03:32,770
don't know what items they've given you

00:03:29,860 --> 00:03:36,160
already or what items they might give

00:03:32,770 --> 00:03:37,780
you next or in the future they only know

00:03:36,160 --> 00:03:39,190
how to give you their next item how to

00:03:37,780 --> 00:03:40,750
compute that next item and give it to

00:03:39,190 --> 00:03:42,640
you which means that they're often

00:03:40,750 --> 00:03:44,470
pretty memory efficient if we loop over

00:03:42,640 --> 00:03:46,660
a file in Python it whether it's one

00:03:44,470 --> 00:03:48,460
megabyte or one gigabyte it will store

00:03:46,660 --> 00:03:50,160
the same amount of memory as we are

00:03:48,460 --> 00:03:53,230
looping over it

00:03:50,160 --> 00:03:55,510
so because we consume items from

00:03:53,230 --> 00:03:57,580
iterators as we loop over them you can

00:03:55,510 --> 00:04:00,790
think of iterators as like Hello Kitty

00:03:57,580 --> 00:04:04,060
Pez dispensers when you take a Pez out

00:04:00,790 --> 00:04:05,980
it is gone you've consumed it and once

00:04:04,060 --> 00:04:08,350
that dispenser is empty it's useless

00:04:05,980 --> 00:04:10,570
there's no way to reload this iterator

00:04:08,350 --> 00:04:11,860
and it has no memory of what used to be

00:04:10,570 --> 00:04:14,170
in it it has no idea how many things

00:04:11,860 --> 00:04:18,700
might be in it iterators are lazy

00:04:14,170 --> 00:04:20,380
single-use intervals so lazy looping is

00:04:18,700 --> 00:04:22,390
all about creating iterators and looping

00:04:20,380 --> 00:04:23,710
over iterators we've already seen how to

00:04:22,390 --> 00:04:27,060
loop over an iterator you just write a

00:04:23,710 --> 00:04:30,430
for loop how do you create an iterator

00:04:27,060 --> 00:04:32,080
so this function is very similar to the

00:04:30,430 --> 00:04:33,850
built-in enumerate function in Python

00:04:32,080 --> 00:04:37,270
it's just called enumerate instead of

00:04:33,850 --> 00:04:38,080
counting upwards it counts downwards if

00:04:37,270 --> 00:04:41,289
we take

00:04:38,080 --> 00:04:43,300
an iterable say a list of strings and we

00:04:41,289 --> 00:04:45,759
pass it to this do numerate function and

00:04:43,300 --> 00:04:48,220
then loop over the results the thing

00:04:45,759 --> 00:04:51,039
will get back our tuples that have two

00:04:48,220 --> 00:04:52,800
things in them numbers counting downward

00:04:51,039 --> 00:04:59,080
and the actual items that were in that

00:04:52,800 --> 00:05:01,419
iterable in this case a list so when we

00:04:59,080 --> 00:05:04,330
call this thing it does all the work

00:05:01,419 --> 00:05:06,550
upfront it's building up a list of

00:05:04,330 --> 00:05:08,949
tuples and then it's going to return

00:05:06,550 --> 00:05:12,400
that list of tuples to us all at once

00:05:08,949 --> 00:05:13,930
which might not be the most memory

00:05:12,400 --> 00:05:17,229
efficient thing depending on how big the

00:05:13,930 --> 00:05:20,050
thing that we're looping over is instead

00:05:17,229 --> 00:05:24,280
of creating all of the tuples right away

00:05:20,050 --> 00:05:26,970
as this function does we could make this

00:05:24,280 --> 00:05:29,820
function return a lazy iterator to us

00:05:26,970 --> 00:05:33,039
one which would only make the tuples

00:05:29,820 --> 00:05:35,139
just before we need them it would delay

00:05:33,039 --> 00:05:36,819
evaluation only make them just before we

00:05:35,139 --> 00:05:39,310
need them we can actually do this by

00:05:36,819 --> 00:05:40,710
removing code from this function the

00:05:39,310 --> 00:05:42,639
first thing that we would remove

00:05:40,710 --> 00:05:43,630
somewhat strangely is that return

00:05:42,639 --> 00:05:44,650
statement we're not going to return

00:05:43,630 --> 00:05:46,750
anything anymore

00:05:44,650 --> 00:05:48,580
then we would also remove the values

00:05:46,750 --> 00:05:50,050
equals an empty list and then this

00:05:48,580 --> 00:05:52,479
values dot append which doesn't actually

00:05:50,050 --> 00:05:55,990
make any sense anymore we are going to

00:05:52,479 --> 00:05:57,490
turn this into a yield statement so this

00:05:55,990 --> 00:06:00,039
thing that we've just made it is called

00:05:57,490 --> 00:06:02,139
a generator function generator functions

00:06:00,039 --> 00:06:04,300
return iterators when you call them so

00:06:02,139 --> 00:06:06,880
when we call this de numerate function

00:06:04,300 --> 00:06:08,440
this new one that we've made we can take

00:06:06,880 --> 00:06:10,150
the thing that we get back from it and

00:06:08,440 --> 00:06:13,030
just like a file object we can call next

00:06:10,150 --> 00:06:15,280
on it or we can loop over it but if we

00:06:13,030 --> 00:06:17,289
loop over the second time just like the

00:06:15,280 --> 00:06:21,130
file it will be exhausted it'll be empty

00:06:17,289 --> 00:06:22,840
and this is all because of that yield

00:06:21,130 --> 00:06:24,520
statement that turned what was a regular

00:06:22,840 --> 00:06:26,110
function in Python into a generator

00:06:24,520 --> 00:06:28,870
function and generator functions are

00:06:26,110 --> 00:06:31,330
really different from other functions in

00:06:28,870 --> 00:06:33,909
Python if you have a regular function

00:06:31,330 --> 00:06:35,800
Python and you call it it will execute

00:06:33,909 --> 00:06:37,570
that function and if we look at the

00:06:35,800 --> 00:06:40,419
thing that it gave us back we'll see it

00:06:37,570 --> 00:06:42,759
gave us its return value but if you take

00:06:40,419 --> 00:06:46,300
a generator function and you call it

00:06:42,759 --> 00:06:49,240
nothing will seem to happen the function

00:06:46,300 --> 00:06:50,260
doesn't actually execute at all and if

00:06:49,240 --> 00:06:52,070
we look at the thing that it gave us

00:06:50,260 --> 00:06:55,910
back we will see it gave us

00:06:52,070 --> 00:06:57,920
object functions and generator functions

00:06:55,910 --> 00:07:01,190
are completely different animals all

00:06:57,920 --> 00:07:03,770
because of that yield statement so we're

00:07:01,190 --> 00:07:06,350
gonna walk through every step of looping

00:07:03,770 --> 00:07:07,940
over a generator object this is going to

00:07:06,350 --> 00:07:09,920
be quick so if you've been asleep up

00:07:07,940 --> 00:07:12,830
till now wake up for a minute or sell

00:07:09,920 --> 00:07:15,050
I'm gonna be bolding the code as we go

00:07:12,830 --> 00:07:16,820
here so when we loop over a generator

00:07:15,050 --> 00:07:18,950
object it is going to start executing

00:07:16,820 --> 00:07:22,040
their function so we will see those

00:07:18,950 --> 00:07:24,580
first couple print calls happen and then

00:07:22,040 --> 00:07:27,260
the generator gets to that yield

00:07:24,580 --> 00:07:30,620
statement and it will put itself on

00:07:27,260 --> 00:07:33,770
pause and yield control back to our loop

00:07:30,620 --> 00:07:35,480
passing that tuple back to us then we

00:07:33,770 --> 00:07:38,030
execute the body of our loop which will

00:07:35,480 --> 00:07:40,790
print something out and then we will ask

00:07:38,030 --> 00:07:42,890
the generator for its next item which

00:07:40,790 --> 00:07:46,040
will start it up right where we left off

00:07:42,890 --> 00:07:47,750
right after that yield so it prints

00:07:46,040 --> 00:07:51,020
again and then it gets to another

00:07:47,750 --> 00:07:54,140
iteration of its loop which prints again

00:07:51,020 --> 00:07:57,740
and then it will yield again which puts

00:07:54,140 --> 00:08:00,530
itself on pause again gives us another

00:07:57,740 --> 00:08:01,910
twofold back in our loop so we execute

00:08:00,530 --> 00:08:03,710
the body of our loop again which will

00:08:01,910 --> 00:08:06,260
print something out and then again we

00:08:03,710 --> 00:08:09,020
ask the generator for another item yet

00:08:06,260 --> 00:08:10,460
again starts looping right where we left

00:08:09,020 --> 00:08:12,770
off right after that yield which will

00:08:10,460 --> 00:08:14,450
print and then when it asks for another

00:08:12,770 --> 00:08:15,740
thing from its loop it'll see you it's

00:08:14,450 --> 00:08:17,900
actually empty there's no more items

00:08:15,740 --> 00:08:20,810
left so it'll get to the end of that

00:08:17,900 --> 00:08:24,680
generator function which will actually

00:08:20,810 --> 00:08:26,420
exhaust the iterator so when this

00:08:24,680 --> 00:08:27,830
returns this iterator this generator is

00:08:26,420 --> 00:08:31,750
now exhausted there are no more items

00:08:27,830 --> 00:08:34,099
within it so we are done looping

00:08:31,750 --> 00:08:36,890
generators and all iterators compute

00:08:34,099 --> 00:08:38,540
their items as you loop over them when

00:08:36,890 --> 00:08:40,490
you ask a generator for its next slide

00:08:38,540 --> 00:08:42,770
it will execute some code to figure out

00:08:40,490 --> 00:08:45,320
what that item is it'll yield that item

00:08:42,770 --> 00:08:47,930
to you to whoever it is who's looping

00:08:45,320 --> 00:08:50,480
over it there and it will put itself on

00:08:47,930 --> 00:08:53,720
pause until you ask it to generate

00:08:50,480 --> 00:08:55,910
another item for you so lazy looping is

00:08:53,720 --> 00:08:58,190
all about not doing any work at all

00:08:55,910 --> 00:09:02,900
until just before the moment where you

00:08:58,190 --> 00:09:05,630
need that next item generator functions

00:09:02,900 --> 00:09:07,460
return generators to us they were

00:09:05,630 --> 00:09:11,090
generator objects and generators are

00:09:07,460 --> 00:09:12,920
iterators this is a generator function

00:09:11,090 --> 00:09:14,210
it's yielding just like our de numerate

00:09:12,920 --> 00:09:16,520
generator function did but it does

00:09:14,210 --> 00:09:18,920
something a little bit different here if

00:09:16,520 --> 00:09:21,560
we call this generator function the

00:09:18,920 --> 00:09:24,440
thing that we get back is a generator

00:09:21,560 --> 00:09:26,240
object but this is not the only way to

00:09:24,440 --> 00:09:28,900
make generator object in Python there's

00:09:26,240 --> 00:09:32,840
another way to make generator objects

00:09:28,900 --> 00:09:34,310
this is a generator expression it looks

00:09:32,840 --> 00:09:35,990
like a list comprehension if you've ever

00:09:34,310 --> 00:09:38,660
seen these things before except that

00:09:35,990 --> 00:09:41,480
list comprehensions give us new lists

00:09:38,660 --> 00:09:44,570
back when we execute them generator

00:09:41,480 --> 00:09:46,670
objects give us new generators so this

00:09:44,570 --> 00:09:49,100
object that we just got back from this

00:09:46,670 --> 00:09:51,290
generator expression it does the same

00:09:49,100 --> 00:09:53,150
thing as this other generator object

00:09:51,290 --> 00:09:55,700
that we got back from this generator

00:09:53,150 --> 00:09:58,640
function so instead of making a whole

00:09:55,700 --> 00:10:00,200
new function sometimes you can just

00:09:58,640 --> 00:10:02,270
write a single expression that does the

00:10:00,200 --> 00:10:06,110
same thing makes a generator for you all

00:10:02,270 --> 00:10:08,720
in one line of code so to make an

00:10:06,110 --> 00:10:11,030
iterator in Python you can either make a

00:10:08,720 --> 00:10:13,250
generator function or make a generator

00:10:11,030 --> 00:10:15,400
expression and calling a generator

00:10:13,250 --> 00:10:17,450
function it makes a generator object

00:10:15,400 --> 00:10:19,040
evaluating a generator expression makes

00:10:17,450 --> 00:10:21,890
a generator object as well and

00:10:19,040 --> 00:10:23,510
generators are iterators the same way

00:10:21,890 --> 00:10:27,140
that files our iterators they are lazy

00:10:23,510 --> 00:10:30,350
iterables technically there is another

00:10:27,140 --> 00:10:31,460
way to make your own iterator but you

00:10:30,350 --> 00:10:33,620
don't need to know about that we're not

00:10:31,460 --> 00:10:35,150
going to talk about that and it probably

00:10:33,620 --> 00:10:37,640
will never be important for you in your

00:10:35,150 --> 00:10:39,710
code now once you've got an iterator

00:10:37,640 --> 00:10:41,930
whether you made a generator function or

00:10:39,710 --> 00:10:42,580
generator expression what do we do with

00:10:41,930 --> 00:10:45,320
it

00:10:42,580 --> 00:10:47,480
so the obvious thing to do with it which

00:10:45,320 --> 00:10:50,690
we've already been doing is loop over it

00:10:47,480 --> 00:10:53,030
we can take an iterator of numbers here

00:10:50,690 --> 00:10:57,050
and loop over that iterator and maybe

00:10:53,030 --> 00:10:59,840
sum up all of those numbers or we could

00:10:57,050 --> 00:11:02,240
pass that iterator to a function that'll

00:10:59,840 --> 00:11:03,620
do the work of looping for us this

00:11:02,240 --> 00:11:06,110
second way of doing things it's actually

00:11:03,620 --> 00:11:09,500
so common in Python that the Python core

00:11:06,110 --> 00:11:11,930
developers have made a special rule just

00:11:09,500 --> 00:11:13,790
for generator expressions if we pass a

00:11:11,930 --> 00:11:16,700
generator expression into a function as

00:11:13,790 --> 00:11:18,530
its only argument we can actually drop

00:11:16,700 --> 00:11:19,190
those extra set of parentheses kind of

00:11:18,530 --> 00:11:20,810
merging the

00:11:19,190 --> 00:11:23,930
function call syntax and the generator

00:11:20,810 --> 00:11:25,880
expression syntax in the one regardless

00:11:23,930 --> 00:11:28,160
of how you're looping over iterators

00:11:25,880 --> 00:11:30,770
whether manually or passing them off to

00:11:28,160 --> 00:11:32,300
a function looping is really the very

00:11:30,770 --> 00:11:33,530
last thing that we will do with them

00:11:32,300 --> 00:11:35,210
because once we've looped over them they

00:11:33,530 --> 00:11:37,820
are exhausted there's really no use for

00:11:35,210 --> 00:11:40,520
these things anymore but before we do

00:11:37,820 --> 00:11:43,780
loop over them we could take this

00:11:40,520 --> 00:11:45,890
iterator and wrap it in another iterator

00:11:43,780 --> 00:11:48,500
so as an example of this we're gonna

00:11:45,890 --> 00:11:51,260
write some code that adds up travel

00:11:48,500 --> 00:11:52,760
expenses we will read a CSV file that

00:11:51,260 --> 00:11:55,460
has expenses within it

00:11:52,760 --> 00:11:57,890
we'll use Python CSV file to help us

00:11:55,460 --> 00:12:00,230
parse it or CSV module to help us parse

00:11:57,890 --> 00:12:01,430
it so we have here a file object and we

00:12:00,230 --> 00:12:04,760
already talked about this that file

00:12:01,430 --> 00:12:07,580
objects in Python are iterators we're

00:12:04,760 --> 00:12:10,070
passing it to CSV dot Reader which is

00:12:07,580 --> 00:12:13,040
actually going to return to us another

00:12:10,070 --> 00:12:15,290
iterator we're gonna take that iterator

00:12:13,040 --> 00:12:17,120
and wrap a generator expression around

00:12:15,290 --> 00:12:20,090
it and that generate expression is going

00:12:17,120 --> 00:12:21,920
to unpack the columns from each row grab

00:12:20,090 --> 00:12:23,870
only the travel expenses from it and

00:12:21,920 --> 00:12:24,860
then take the costs from those travel

00:12:23,870 --> 00:12:27,170
expenses and convert them to

00:12:24,860 --> 00:12:28,640
floating-point numbers we're then going

00:12:27,170 --> 00:12:31,010
to take that generate expression which

00:12:28,640 --> 00:12:34,060
again is an iterator and pass it to the

00:12:31,010 --> 00:12:36,290
sum function so we have now an iterator

00:12:34,060 --> 00:12:39,170
wrapped in another iterator which is

00:12:36,290 --> 00:12:40,640
wrapped in another iterator and no

00:12:39,170 --> 00:12:44,360
looping is actually going to happen

00:12:40,640 --> 00:12:46,430
until we pass that final iterator to the

00:12:44,360 --> 00:12:48,140
sum function it will start looping over

00:12:46,430 --> 00:12:50,840
that outermost one and then we actually

00:12:48,140 --> 00:12:54,080
start the chain of work happening inside

00:12:50,840 --> 00:12:56,060
each of those iterators and again

00:12:54,080 --> 00:12:57,770
because we're passing a generator

00:12:56,060 --> 00:12:59,270
expression as the single argument to a

00:12:57,770 --> 00:13:04,190
function we can actually drop those

00:12:59,270 --> 00:13:06,650
extra set of parentheses so that analogy

00:13:04,190 --> 00:13:08,570
of Hello Kitty Pez dispensers it doesn't

00:13:06,650 --> 00:13:11,060
really reflect the fact that iterators

00:13:08,570 --> 00:13:13,430
can be wrapped in other iterators which

00:13:11,060 --> 00:13:16,100
is kind of unfortunate so if you'd like

00:13:13,430 --> 00:13:19,339
to you could instead think of iterators

00:13:16,100 --> 00:13:21,470
is kind of like Xenomorphs where there's

00:13:19,339 --> 00:13:23,270
one head that's wrapped in side of

00:13:21,470 --> 00:13:25,970
another head or another heads wrapped

00:13:23,270 --> 00:13:28,220
around it except that this also doesn't

00:13:25,970 --> 00:13:29,810
really you know model the world properly

00:13:28,220 --> 00:13:32,040
because you can wrap in a terse as many

00:13:29,810 --> 00:13:33,360
levels deep as you like

00:13:32,040 --> 00:13:36,360
can have heads inside of heads inside of

00:13:33,360 --> 00:13:38,100
heads and also that Pez analogy still

00:13:36,360 --> 00:13:40,290
holds because iterators are consumed as

00:13:38,100 --> 00:13:42,089
you loop over them so maybe iterators

00:13:40,290 --> 00:13:46,589
are really like recursive Hello Kitty

00:13:42,089 --> 00:13:48,690
Pez dispensers xenomorphs when you loop

00:13:46,589 --> 00:13:50,100
over an iterator you wrap an iterator

00:13:48,690 --> 00:13:51,930
rather around another iterator the

00:13:50,100 --> 00:13:53,550
outermost one has to delegate to the

00:13:51,930 --> 00:13:54,779
inner one all the way down until you get

00:13:53,550 --> 00:13:56,100
to the innermost one and then you have

00:13:54,779 --> 00:13:56,880
to work all the way back up until you

00:13:56,100 --> 00:13:58,519
get the thing that you're actually

00:13:56,880 --> 00:14:01,139
looking for

00:13:58,519 --> 00:14:02,490
if this analogy doesn't work for you I'm

00:14:01,139 --> 00:14:04,050
sorry but I you're gonna have to come up

00:14:02,490 --> 00:14:06,690
with your own analogy I don't know of a

00:14:04,050 --> 00:14:08,100
better one so there are two general

00:14:06,690 --> 00:14:09,779
things you can do with an iterator you

00:14:08,100 --> 00:14:13,050
can wrap it in another iterator as many

00:14:09,779 --> 00:14:15,360
times as you'd like and the last thing

00:14:13,050 --> 00:14:17,100
you always do eventually is loop over

00:14:15,360 --> 00:14:18,750
the outermost generator but only once

00:14:17,100 --> 00:14:21,750
because once you've looped over it is

00:14:18,750 --> 00:14:24,870
exhausted there are three ways to wrap

00:14:21,750 --> 00:14:27,360
around an iterator the first way is to

00:14:24,870 --> 00:14:29,639
pass it your generator function or you

00:14:27,360 --> 00:14:31,350
can pass it to a generator expression or

00:14:29,639 --> 00:14:33,360
you could pass it to some other function

00:14:31,350 --> 00:14:36,540
that will return an iterator back to us

00:14:33,360 --> 00:14:39,029
like CSV dot reader did there are also a

00:14:36,540 --> 00:14:41,250
couple ways to loop over an iterator you

00:14:39,029 --> 00:14:43,110
could write a for loop or you could

00:14:41,250 --> 00:14:44,339
write a list comprehension or again you

00:14:43,110 --> 00:14:46,139
could pass it to some other function

00:14:44,339 --> 00:14:50,399
that will do the looping for us kind of

00:14:46,139 --> 00:14:51,600
like the sum function Python did all

00:14:50,399 --> 00:14:54,329
right so we're gonna finally revisit

00:14:51,600 --> 00:14:57,410
that problem code that we saw earlier we

00:14:54,329 --> 00:15:00,149
were trying to find errors in a log file

00:14:57,410 --> 00:15:02,399
but we also wanted to print out the line

00:15:00,149 --> 00:15:06,149
just before the error and the line just

00:15:02,399 --> 00:15:09,660
after the air this is what we started

00:15:06,149 --> 00:15:11,910
with which is kind of a lot of code it's

00:15:09,660 --> 00:15:14,130
it's at least dense code here a lot of

00:15:11,910 --> 00:15:16,649
this logic is around getting the line

00:15:14,130 --> 00:15:19,829
just before the current line and the

00:15:16,649 --> 00:15:23,269
line just after the current line so we

00:15:19,829 --> 00:15:28,079
could refactor our code to look like

00:15:23,269 --> 00:15:30,120
this and we're done except not really

00:15:28,079 --> 00:15:31,889
because we're actually passing our log

00:15:30,120 --> 00:15:33,480
file to two functions that don't exist

00:15:31,889 --> 00:15:37,620
we're kind of is a sort of aspirational

00:15:33,480 --> 00:15:39,600
programming here one of these in theory

00:15:37,620 --> 00:15:40,769
will lazily strip new lines from the

00:15:39,600 --> 00:15:43,560
ends of our lines kind of like we were

00:15:40,769 --> 00:15:45,420
doing before the other one should give

00:15:43,560 --> 00:15:48,630
us the line just before the current line

00:15:45,420 --> 00:15:50,250
just after the current line if these

00:15:48,630 --> 00:15:51,420
functions did exist if we're you know

00:15:50,250 --> 00:15:54,090
we're practicing aspirational

00:15:51,420 --> 00:15:55,620
programming if these did exist and they

00:15:54,090 --> 00:15:58,350
gave us lazy intervals they gave us

00:15:55,620 --> 00:16:01,710
iterators back then our code would be

00:15:58,350 --> 00:16:03,990
just as efficient as before but it a lot

00:16:01,710 --> 00:16:05,310
more readable at least in my opinion so

00:16:03,990 --> 00:16:07,200
if we can figure out how to write these

00:16:05,310 --> 00:16:09,870
functions our code would be more

00:16:07,200 --> 00:16:11,040
readable fortunately you don't have to

00:16:09,870 --> 00:16:12,320
figure out how to write these because I

00:16:11,040 --> 00:16:15,090
wrote them for you

00:16:12,320 --> 00:16:17,670
this is strip new lines and this is

00:16:15,090 --> 00:16:18,780
around which is a big and scary function

00:16:17,670 --> 00:16:21,420
but it's already been written so you

00:16:18,780 --> 00:16:22,620
don't have to care about it so this code

00:16:21,420 --> 00:16:24,780
it's a lot longer than what we started

00:16:22,620 --> 00:16:27,450
with if you take the original for loop

00:16:24,780 --> 00:16:30,930
it is shorter than this code here but I

00:16:27,450 --> 00:16:32,970
find it more readable mostly because the

00:16:30,930 --> 00:16:35,790
four lines that we ended up with in that

00:16:32,970 --> 00:16:37,830
loop they hide the details of what we're

00:16:35,790 --> 00:16:39,210
doing the details that we don't need to

00:16:37,830 --> 00:16:40,410
care about if we're just glancing at

00:16:39,210 --> 00:16:43,500
this loop trying to figure out what it

00:16:40,410 --> 00:16:46,890
even does so we've broken up our loop

00:16:43,500 --> 00:16:48,960
into little bits of work that the reader

00:16:46,890 --> 00:16:51,150
of our code doesn't have to understand

00:16:48,960 --> 00:16:56,460
unless they decide they want to dig into

00:16:51,150 --> 00:16:59,130
a specific detail now I do want to make

00:16:56,460 --> 00:17:01,590
an important note while you are writing

00:16:59,130 --> 00:17:03,420
generator functions keep in mind that

00:17:01,590 --> 00:17:06,780
the best code is code that you don't

00:17:03,420 --> 00:17:08,880
even need to write python has a bunch of

00:17:06,780 --> 00:17:12,780
iterator returning functions built into

00:17:08,880 --> 00:17:15,060
it a bunch of lazy looping helpers an

00:17:12,780 --> 00:17:16,740
example is the enumerate function which

00:17:15,060 --> 00:17:18,900
is what that D numerate thing was based

00:17:16,740 --> 00:17:22,589
on it's built into Python there's also

00:17:18,900 --> 00:17:23,699
zip and reversed and any and all and a

00:17:22,589 --> 00:17:25,410
whole module in the standard library

00:17:23,699 --> 00:17:27,690
called itertools it's really just full

00:17:25,410 --> 00:17:28,950
of lazy looping helpers I'm not gonna

00:17:27,690 --> 00:17:30,960
explain what these do but you can look

00:17:28,950 --> 00:17:33,000
them up on your own and if you don't

00:17:30,960 --> 00:17:36,000
find what you're looking for built into

00:17:33,000 --> 00:17:37,980
Python you might find it hiding in a

00:17:36,000 --> 00:17:41,220
third-party library there's one called

00:17:37,980 --> 00:17:42,690
more itertools which is like the

00:17:41,220 --> 00:17:44,550
itertools module there's just more of it

00:17:42,690 --> 00:17:46,590
and there's another called bolt ons

00:17:44,550 --> 00:17:51,630
which has a whole section is just for

00:17:46,590 --> 00:17:54,120
eater tools like stuff for example this

00:17:51,630 --> 00:17:57,810
around generator function that big scary

00:17:54,120 --> 00:17:59,330
function that I wrote I could have

00:17:57,810 --> 00:18:03,690
actually written this

00:17:59,330 --> 00:18:05,760
like this the boltons module and the

00:18:03,690 --> 00:18:08,730
more age tools module actually include a

00:18:05,760 --> 00:18:11,370
helper in them called windowed so here I

00:18:08,730 --> 00:18:13,260
am using this windowed thing which

00:18:11,370 --> 00:18:15,809
returns an iterator I'm wrapping around

00:18:13,260 --> 00:18:17,549
it and in fact it is also wrapping

00:18:15,809 --> 00:18:19,440
around chain which wraps around some

00:18:17,549 --> 00:18:21,090
other things so we're relying on

00:18:19,440 --> 00:18:27,330
third-party code that does a lot of our

00:18:21,090 --> 00:18:31,380
work for us which is kind of nice so I

00:18:27,330 --> 00:18:32,760
have some bad news the way I used the

00:18:31,380 --> 00:18:35,610
word generator throughout this whole

00:18:32,760 --> 00:18:39,450
talk is not a universal usage of that

00:18:35,610 --> 00:18:42,720
word so the way I defined these terms is

00:18:39,450 --> 00:18:45,210
that an iterator is a lazy single use

00:18:42,720 --> 00:18:47,400
interval that computes its next item and

00:18:45,210 --> 00:18:49,490
gives it back to you as you loop over it

00:18:47,400 --> 00:18:51,929
does work as you loop over it a

00:18:49,490 --> 00:18:53,669
generator function is a special syntax

00:18:51,929 --> 00:18:55,880
that we can use to make a function that

00:18:53,669 --> 00:18:58,380
returns one of these iterators a

00:18:55,880 --> 00:18:59,640
generator expression is also a special

00:18:58,380 --> 00:19:03,000
syntax that looks like a list

00:18:59,640 --> 00:19:07,590
comprehension and when you evaluate it

00:19:03,000 --> 00:19:09,000
it gives you an iterator back the type

00:19:07,590 --> 00:19:11,040
of iterator that you get back from these

00:19:09,000 --> 00:19:13,919
things is called a generator object or

00:19:11,040 --> 00:19:16,080
for short just a generator when you call

00:19:13,919 --> 00:19:18,240
a generator function or evaluate a

00:19:16,080 --> 00:19:21,870
generator expression you will get a

00:19:18,240 --> 00:19:24,900
generator object back and generator

00:19:21,870 --> 00:19:26,580
objects are a type of iterator they're

00:19:24,900 --> 00:19:29,580
basically the easiest way to make an

00:19:26,580 --> 00:19:32,669
iterator in Python so this is how I

00:19:29,580 --> 00:19:36,960
defined these terms the Python

00:19:32,669 --> 00:19:39,120
documentation disagrees with me what I

00:19:36,960 --> 00:19:42,380
call a generator function it calls a

00:19:39,120 --> 00:19:45,929
generator what I call a generator object

00:19:42,380 --> 00:19:48,210
or just a generator it calls a generator

00:19:45,929 --> 00:19:49,890
iterator which is not a term that I've

00:19:48,210 --> 00:19:51,540
heard anyone use outside of the Python

00:19:49,890 --> 00:19:54,210
documentation I'm sure some people do

00:19:51,540 --> 00:19:56,460
though unfortunately a generator

00:19:54,210 --> 00:19:58,290
expression it also calls a generator

00:19:56,460 --> 00:19:59,809
expression do I do sometimes wish they

00:19:58,290 --> 00:20:01,620
were called generator comprehensions

00:19:59,809 --> 00:20:04,679
because it would be easier for me to

00:20:01,620 --> 00:20:08,280
teach them so you might think at this

00:20:04,679 --> 00:20:09,780
point tre thinks one thing the Python

00:20:08,280 --> 00:20:12,590
documentation thinks another thing

00:20:09,780 --> 00:20:15,180
so obviously tre is wrong

00:20:12,590 --> 00:20:16,800
and I would agree with you except that

00:20:15,180 --> 00:20:19,560
I'm not the only one who uses these

00:20:16,800 --> 00:20:21,180
terms this way many other Python

00:20:19,560 --> 00:20:23,190
educators and many other folks in the

00:20:21,180 --> 00:20:25,530
Python community use the term generator

00:20:23,190 --> 00:20:30,780
the same way I do they use it to

00:20:25,530 --> 00:20:32,940
describe a generator object in fact the

00:20:30,780 --> 00:20:34,770
Python documentation says the term

00:20:32,940 --> 00:20:39,210
generator may be used to refer to a

00:20:34,770 --> 00:20:41,130
generator iterator in some contexts so

00:20:39,210 --> 00:20:42,350
these terms are confusing different

00:20:41,130 --> 00:20:44,670
people use them differently in different

00:20:42,350 --> 00:20:47,250
contexts and that's just the way life is

00:20:44,670 --> 00:20:48,660
in generator land I don't have a

00:20:47,250 --> 00:20:49,920
solution to this problem we don't think

00:20:48,660 --> 00:20:51,510
there really is one

00:20:49,920 --> 00:20:55,440
it really depends in the context what

00:20:51,510 --> 00:20:57,870
these terms mean so to recap iterators

00:20:55,440 --> 00:20:59,910
lazily compute their next item as you

00:20:57,870 --> 00:21:02,040
loop over them and the easiest way to

00:20:59,910 --> 00:21:05,100
make your own iterator is to make a

00:21:02,040 --> 00:21:06,510
generator though you often don't need to

00:21:05,100 --> 00:21:09,030
actually make your own iterator because

00:21:06,510 --> 00:21:10,800
the Python Python itself comes bundled

00:21:09,030 --> 00:21:13,380
with a lot of lazy looping tools

00:21:10,800 --> 00:21:15,500
built-in and third-party libraries have

00:21:13,380 --> 00:21:18,840
a lot of tools that you can use instead

00:21:15,500 --> 00:21:21,840
the purpose of iterators is to make your

00:21:18,840 --> 00:21:23,070
code more memory efficient even if

00:21:21,840 --> 00:21:26,010
you're looping over a really big

00:21:23,070 --> 00:21:28,950
iterable also wrapping iterators and

00:21:26,010 --> 00:21:32,550
iterators can really help you break your

00:21:28,950 --> 00:21:35,220
loops your big loops into small chunks

00:21:32,550 --> 00:21:37,080
and give descriptive names for each of

00:21:35,220 --> 00:21:38,460
these steps in your loop which can

00:21:37,080 --> 00:21:40,440
really help improve the readability of

00:21:38,460 --> 00:21:43,710
your code which is my favorite reason of

00:21:40,440 --> 00:21:45,330
using an iterator in python if you were

00:21:43,710 --> 00:21:47,460
interested in diving into this topic

00:21:45,330 --> 00:21:48,870
more deeply I gave a three-hour tutorial

00:21:47,460 --> 00:21:50,340
on this at PyCon if you would like to

00:21:48,870 --> 00:21:52,020
sit through three hours of this it's

00:21:50,340 --> 00:21:54,480
also more hands-on so it might actually

00:21:52,020 --> 00:21:55,740
be more useful to learn from and that

00:21:54,480 --> 00:21:58,700
tutorial as well as a whole bunch of

00:21:55,740 --> 00:22:01,030
other resources are linked to this URL

00:21:58,700 --> 00:22:04,660
thank you

00:22:01,030 --> 00:22:04,660
[Applause]

00:22:04,710 --> 00:22:09,639
anyway thank you very much tre you said

00:22:08,559 --> 00:22:11,919
that words are hard and one of the

00:22:09,639 --> 00:22:14,889
things I've always found confusing about

00:22:11,919 --> 00:22:19,919
this is the word yield and I've always

00:22:14,889 --> 00:22:23,440
wondered why that word is chosen as the

00:22:19,919 --> 00:22:24,909
as the name for what's happening and in

00:22:23,440 --> 00:22:27,940
fact used in two different ways you said

00:22:24,909 --> 00:22:30,730
it yields control back to the loop and

00:22:27,940 --> 00:22:33,009
you also said it yields some values

00:22:30,730 --> 00:22:34,570
can you explain what yield is doing

00:22:33,009 --> 00:22:36,970
there and how we should understand it to

00:22:34,570 --> 00:22:40,740
help understand what these things do

00:22:36,970 --> 00:22:44,139
ah good question I don't think I can

00:22:40,740 --> 00:22:45,730
however I can say that kind of like how

00:22:44,139 --> 00:22:47,799
no one really knows what yield signs do

00:22:45,730 --> 00:22:49,779
in the u.s. no one really knows what the

00:22:47,799 --> 00:22:52,990
yield statement does so I don't think

00:22:49,779 --> 00:22:55,570
that helped actually at all but III see

00:22:52,990 --> 00:22:58,149
it as it puts itself on pause and gives

00:22:55,570 --> 00:22:59,830
you an item back at the same time but I

00:22:58,149 --> 00:23:01,389
don't really know why the word yield was

00:22:59,830 --> 00:23:03,159
chosen although I suspect there was

00:23:01,389 --> 00:23:04,570
probably an argument on a Python core

00:23:03,159 --> 00:23:07,299
developers mailing list years ago that

00:23:04,570 --> 00:23:10,169
might explain it in your function in

00:23:07,299 --> 00:23:12,580
your example for the generator function

00:23:10,169 --> 00:23:14,889
you showed that there's a variable and

00:23:12,580 --> 00:23:16,720
then the yield statement and next time

00:23:14,889 --> 00:23:19,480
you go to a for loop you'll get a new

00:23:16,720 --> 00:23:21,090
value so I'm just curious I'm assuming

00:23:19,480 --> 00:23:24,100
that's the single threaded execution

00:23:21,090 --> 00:23:26,139
where does the state of the variable

00:23:24,100 --> 00:23:29,139
stored for the generator function I mean

00:23:26,139 --> 00:23:32,230
is there a separate stack that gets

00:23:29,139 --> 00:23:33,820
created or what happened yeah this is

00:23:32,230 --> 00:23:38,049
another complex question it's putting me

00:23:33,820 --> 00:23:40,059
on the spot I don't actually I think

00:23:38,049 --> 00:23:41,350
that this may not be the code that I

00:23:40,059 --> 00:23:44,259
wrote there may not actually be thread

00:23:41,350 --> 00:23:49,119
safe in the sense of if you're executing

00:23:44,259 --> 00:23:50,379
in two different threads it well I don't

00:23:49,119 --> 00:23:51,369
know actually let's talk about that in

00:23:50,379 --> 00:23:52,809
the hallway someone who probably has a

00:23:51,369 --> 00:23:53,830
better answer for that might because

00:23:52,809 --> 00:23:56,110
generators are kind of their own

00:23:53,830 --> 00:23:58,360
interesting thing threads with their own

00:23:56,110 --> 00:24:01,119
interesting thing and I haven't really

00:23:58,360 --> 00:24:02,919
mixed the two too much in my own code I

00:24:01,119 --> 00:24:05,409
mean in general with web development

00:24:02,919 --> 00:24:06,759
it's not that common to use a generator

00:24:05,409 --> 00:24:09,309
in the sense that we often don't have

00:24:06,759 --> 00:24:11,080
giant data structures it's much less

00:24:09,309 --> 00:24:13,389
common to use a thread at least in the

00:24:11,080 --> 00:24:15,340
sense of the request response loop so

00:24:13,389 --> 00:24:16,880
maybe we can talk about that later I'm

00:24:15,340 --> 00:24:21,440
hoping someone can maybe pop

00:24:16,880 --> 00:24:23,210
the hall and answer that for me okay if

00:24:21,440 --> 00:24:24,080
you have more questions I would talk to

00:24:23,210 --> 00:24:26,960
Trey in the hallway

00:24:24,080 --> 00:24:27,920
ya see in the next talk after the break

00:24:26,960 --> 00:24:29,450
thank you

00:24:27,920 --> 00:24:42,749
[Applause]

00:24:29,450 --> 00:24:42,749

YouTube URL: https://www.youtube.com/watch?v=q8czHnhcVGE


