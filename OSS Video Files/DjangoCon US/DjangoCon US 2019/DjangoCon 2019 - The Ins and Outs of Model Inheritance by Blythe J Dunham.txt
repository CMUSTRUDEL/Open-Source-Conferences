Title: DjangoCon 2019 - The Ins and Outs of Model Inheritance by Blythe J Dunham
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - The Ins and Outs of Model Inheritance by Blythe J Dunham

This talk was presented at: https://2019.djangocon.us/talks/the-ins-and-outs-of-model-inheritance/

LINKS:
Follow Blythe J Dunham ğŸ‘‡
On GitHub: https://github.com/blythedunham
Official homepage: https://www.linkedin.com/in/blythedunham/

Follow DjangCon US ğŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ğŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:12,679
[Music]

00:00:14,469 --> 00:00:18,830
welcome friends welcome sorry about the

00:00:17,150 --> 00:00:21,560
technical difficulties I needed my

00:00:18,830 --> 00:00:23,420
speaker notes so I'm Blythe Dunham and

00:00:21,560 --> 00:00:25,849
I'm just venturing out on my own to

00:00:23,420 --> 00:00:28,369
freelance as snow giraffe I've been

00:00:25,849 --> 00:00:30,650
doing Django for about three years at

00:00:28,369 --> 00:00:33,350
rover comm the largest network of

00:00:30,650 --> 00:00:38,420
trusted dog sitters and walkers and now

00:00:33,350 --> 00:00:40,910
we support cats and hire humans so prior

00:00:38,420 --> 00:00:42,979
to that I worked on Ruby on Rails for

00:00:40,910 --> 00:00:46,129
almost a decade and since I've been in

00:00:42,979 --> 00:00:47,930
the tech industry for over 20 years you

00:00:46,129 --> 00:00:50,890
could probably say that I've spent a lot

00:00:47,930 --> 00:00:56,780
of time hanging out with models yeah

00:00:50,890 --> 00:00:58,820
jokes get better so as you can tell from

00:00:56,780 --> 00:01:01,430
the name snowdrop I really love snow

00:00:58,820 --> 00:01:03,710
sports and giraffes and so I thought I'd

00:01:01,430 --> 00:01:05,720
include them in today's adventure we're

00:01:03,710 --> 00:01:08,240
gonna be talking about composition and

00:01:05,720 --> 00:01:10,640
inheritance the three types of model

00:01:08,240 --> 00:01:12,860
inheritance that Django supports two

00:01:10,640 --> 00:01:16,850
alternatives to model inheritance and

00:01:12,860 --> 00:01:20,990
then avoiding inheritance altogether so

00:01:16,850 --> 00:01:26,659
who's seen this before okay I think I

00:01:20,990 --> 00:01:28,429
put it in the abstract so so in 1994 a

00:01:26,659 --> 00:01:30,530
book called design patterns came out

00:01:28,429 --> 00:01:32,780
where they advised folks viewing

00:01:30,530 --> 00:01:34,939
object-oriented design to prefer

00:01:32,780 --> 00:01:37,399
composition over inheritance because

00:01:34,939 --> 00:01:40,340
it's more flexible so what does this

00:01:37,399 --> 00:01:42,829
mean composition is a mechanism to

00:01:40,340 --> 00:01:44,990
combine objects or data into more

00:01:42,829 --> 00:01:48,499
complex ones you can think of it as a

00:01:44,990 --> 00:01:53,240
has a relationship for example a giraffe

00:01:48,499 --> 00:01:55,759
has a blue tongue inheritance is a way

00:01:53,240 --> 00:01:58,009
of deriving a subclass from a parent or

00:01:55,759 --> 00:02:01,670
base class to create a hierarchy of

00:01:58,009 --> 00:02:03,079
shared attributes and methods you can

00:02:01,670 --> 00:02:05,840
think of inheritance as the is a

00:02:03,079 --> 00:02:07,660
relationship so our giraffe is a

00:02:05,840 --> 00:02:10,759
glorious animal

00:02:07,660 --> 00:02:13,220
so while inheritance provides a way to

00:02:10,759 --> 00:02:15,260
avoid repeating yourself it's more

00:02:13,220 --> 00:02:17,690
obvious and natural for us to build

00:02:15,260 --> 00:02:19,580
association between objects than it is

00:02:17,690 --> 00:02:24,030
to try to find commonalities and

00:02:19,580 --> 00:02:26,100
organize them into a hierarchy so the

00:02:24,030 --> 00:02:28,920
plot thickens when we think about how

00:02:26,100 --> 00:02:31,200
objects map to the database via the ORM

00:02:28,920 --> 00:02:33,420
the object relational mapping we find

00:02:31,200 --> 00:02:35,310
that composition is really intuitive and

00:02:33,420 --> 00:02:37,800
has a natural mapping however

00:02:35,310 --> 00:02:40,560
inheritance isn't even supported by

00:02:37,800 --> 00:02:42,840
relational databases therefore we have

00:02:40,560 --> 00:02:45,150
several different approaches to choose

00:02:42,840 --> 00:02:47,250
from since each has its own ins and outs

00:02:45,150 --> 00:02:48,300
it's important to choose wisely are

00:02:47,250 --> 00:02:52,470
better yet

00:02:48,300 --> 00:02:55,560
rethink the problem using composition so

00:02:52,470 --> 00:02:58,920
let's look at composition in django we

00:02:55,560 --> 00:03:01,620
have a giraffe class it has a name field

00:02:58,920 --> 00:03:04,680
we have a tongue class and it has a

00:03:01,620 --> 00:03:06,900
one-to-one field back to giraffe now if

00:03:04,680 --> 00:03:09,060
giraffes had multiple tongues I would

00:03:06,900 --> 00:03:10,190
use well that would be scary and I would

00:03:09,060 --> 00:03:13,160
use a fork

00:03:10,190 --> 00:03:16,830
I'd use a foreign key type here instead

00:03:13,160 --> 00:03:19,019
for the one-to-many relationship so if

00:03:16,830 --> 00:03:21,630
we look at the object-oriented UML

00:03:19,019 --> 00:03:23,819
diagram we represent our objects with a

00:03:21,630 --> 00:03:26,790
one-to-one relationship and this looks

00:03:23,819 --> 00:03:29,130
super similar to the entity relational

00:03:26,790 --> 00:03:31,410
diagram or erd that represents our

00:03:29,130 --> 00:03:34,739
database schema the objects are

00:03:31,410 --> 00:03:39,299
represented as tables and the foreign

00:03:34,739 --> 00:03:41,489
keys are used to show the Association so

00:03:39,299 --> 00:03:43,590
unfortunately model inheritance is a

00:03:41,489 --> 00:03:46,860
little bit more awkward it doesn't have

00:03:43,590 --> 00:03:49,560
that natural mapping so up first is

00:03:46,860 --> 00:03:51,750
abstract models the point of abstract

00:03:49,560 --> 00:03:54,650
models is to reuse the parent classes

00:03:51,750 --> 00:03:58,079
fields and field related functionality

00:03:54,650 --> 00:04:00,420
so as the name suggests the parent is

00:03:58,079 --> 00:04:02,760
abstract and not backed by a table in

00:04:00,420 --> 00:04:05,910
the database therefore each derived

00:04:02,760 --> 00:04:08,989
class will have all of the fields from

00:04:05,910 --> 00:04:12,900
the parent and itself on its own table

00:04:08,989 --> 00:04:16,859
so in Django we have an animal parent

00:04:12,900 --> 00:04:19,470
class that subclasses model and we have

00:04:16,859 --> 00:04:22,260
a name field we have a method for speak

00:04:19,470 --> 00:04:24,539
that returns gibberish and we have

00:04:22,260 --> 00:04:26,960
overridden the meta class definition to

00:04:24,539 --> 00:04:30,600
set abstract to true

00:04:26,960 --> 00:04:33,000
giraffes subclasses animals we add a

00:04:30,600 --> 00:04:35,610
field for the number of spots that the

00:04:33,000 --> 00:04:38,010
giraffe has and we override speak to

00:04:35,610 --> 00:04:39,600
return home because that's what your

00:04:38,010 --> 00:04:45,210
do you just can't hear it it's

00:04:39,600 --> 00:04:47,190
infrasonic so the EOD diagram looks like

00:04:45,210 --> 00:04:49,680
this assuming I've named my Jango app

00:04:47,190 --> 00:04:51,960
abstract we have an abstract draft table

00:04:49,680 --> 00:04:54,660
we have an integer auto incremented

00:04:51,960 --> 00:04:56,700
field for the ID we have the name field

00:04:54,660 --> 00:05:01,140
from the parent animal and the spots

00:04:56,700 --> 00:05:05,370
count from the giraffe class if we were

00:05:01,140 --> 00:05:07,350
to override our sorry subclass animal

00:05:05,370 --> 00:05:09,390
again with zebra it would have that idea

00:05:07,350 --> 00:05:13,320
name field and then anything that it

00:05:09,390 --> 00:05:15,210
adds like a striped count so when we

00:05:13,320 --> 00:05:18,150
query for our giraffes

00:05:15,210 --> 00:05:21,360
this is gonna go query against the

00:05:18,150 --> 00:05:24,510
abstract giraffe table we can't query

00:05:21,360 --> 00:05:27,450
with animal dot objects all because that

00:05:24,510 --> 00:05:29,700
animal table doesn't exist and so when

00:05:27,450 --> 00:05:32,900
we call speak on the giraffe it returns

00:05:29,700 --> 00:05:36,750
hum because we've overridden that method

00:05:32,900 --> 00:05:39,150
so use cases abstract models work best

00:05:36,750 --> 00:05:42,000
when there's a lot of duplicated fields

00:05:39,150 --> 00:05:44,220
if there's only a few fields it's better

00:05:42,000 --> 00:05:47,220
to be explicit and just define them on

00:05:44,220 --> 00:05:50,090
each model so great examples include any

00:05:47,220 --> 00:05:53,340
sort of base or Core model functionality

00:05:50,090 --> 00:05:56,070
that all are many of your models inherit

00:05:53,340 --> 00:05:58,410
for example in two scoops of Django it

00:05:56,070 --> 00:06:00,780
walks you through the timestamp model

00:05:58,410 --> 00:06:03,660
which is also implemented in Django

00:06:00,780 --> 00:06:07,140
extensions and what it does is it adds

00:06:03,660 --> 00:06:09,060
and added and modified date/time fields

00:06:07,140 --> 00:06:12,180
that are updated when the record is

00:06:09,060 --> 00:06:14,130
saved so you could use that with any of

00:06:12,180 --> 00:06:16,830
your models if it's a giraffe it's the

00:06:14,130 --> 00:06:21,170
location if it's a customized user

00:06:16,830 --> 00:06:24,270
anything like that so the advantages of

00:06:21,170 --> 00:06:27,300
abstract models are that you can easily

00:06:24,270 --> 00:06:30,210
reuse the parent classes fields and

00:06:27,300 --> 00:06:32,730
field related lotta logic however the

00:06:30,210 --> 00:06:36,510
parent class can't be used in isolation

00:06:32,730 --> 00:06:38,640
so if you have any related models you

00:06:36,510 --> 00:06:43,740
can't have an animal ID you'll need to

00:06:38,640 --> 00:06:45,900
have a zebra ID and a giraffe ID okay

00:06:43,740 --> 00:06:49,050
this is my favorite slide in the whole

00:06:45,900 --> 00:06:51,090
deck and the photographer atif side

00:06:49,050 --> 00:06:53,610
granted me permission to use it

00:06:51,090 --> 00:06:56,880
I could warn you about using multiple

00:06:53,610 --> 00:07:03,810
table inheritance don't get eaten by the

00:06:56,880 --> 00:07:07,530
lion so multi table inheritance is

00:07:03,810 --> 00:07:09,780
defined like this in Django we have a

00:07:07,530 --> 00:07:13,560
big cat parent class with a name field

00:07:09,780 --> 00:07:16,740
and we have a subclass lion the adds

00:07:13,560 --> 00:07:19,500
giraffes hunted and a method called

00:07:16,740 --> 00:07:22,199
speak now notice that I haven't

00:07:19,500 --> 00:07:24,000
overridden the metaclass definition this

00:07:22,199 --> 00:07:28,650
is vanilla out of the box model

00:07:24,000 --> 00:07:31,200
inheritance in Jenga so first this is

00:07:28,650 --> 00:07:33,780
called concrete inheritance because the

00:07:31,200 --> 00:07:35,820
parent class is concrete we have a big

00:07:33,780 --> 00:07:41,580
cat table on the database with that ID

00:07:35,820 --> 00:07:44,340
and a name field the lion table has a

00:07:41,580 --> 00:07:46,620
pointer a big cat pointer which is a

00:07:44,340 --> 00:07:48,539
foreign key back to big cat and then it

00:07:46,620 --> 00:07:51,510
adds any fields of its own like giraffes

00:07:48,539 --> 00:07:53,639
hunted now notice we don't have an ID

00:07:51,510 --> 00:07:56,700
field here which is not usually the

00:07:53,639 --> 00:07:59,250
default in Django so the primary key of

00:07:56,700 --> 00:08:03,810
the lion table is this big cat pointer

00:07:59,250 --> 00:08:06,270
ID if we subclass big cat with cheetah

00:08:03,810 --> 00:08:07,950
and cheetah has none of its own fields

00:08:06,270 --> 00:08:11,820
then we still have that big cat pointer

00:08:07,950 --> 00:08:13,650
ID so notice here that you could

00:08:11,820 --> 00:08:17,960
implement this explicitly with

00:08:13,650 --> 00:08:21,330
one-to-one relationships if you want it

00:08:17,960 --> 00:08:25,139
what happens when we query let's try to

00:08:21,330 --> 00:08:28,530
get all of the Lions this execute a

00:08:25,139 --> 00:08:31,530
query on the lion table join to the big

00:08:28,530 --> 00:08:33,690
cat table and what this does is it

00:08:31,530 --> 00:08:36,419
allows you to access the big cat

00:08:33,690 --> 00:08:39,570
instance the big cat pointer without

00:08:36,419 --> 00:08:42,330
executing an additional query you can

00:08:39,570 --> 00:08:46,140
also call any of the fields or methods

00:08:42,330 --> 00:08:51,240
on the parent directly on lions so you

00:08:46,140 --> 00:08:54,570
can say lion dot name the problem starts

00:08:51,240 --> 00:08:57,690
when we try to get all of the species of

00:08:54,570 --> 00:09:00,300
cats regardless of lion cheetah whatever

00:08:57,690 --> 00:09:02,160
so it starts out simple give me all the

00:09:00,300 --> 00:09:04,410
big cats we'll run a query on the big

00:09:02,160 --> 00:09:06,779
cat table

00:09:04,410 --> 00:09:09,810
then I want to access the speak method

00:09:06,779 --> 00:09:12,360
on the child but I don't know if this is

00:09:09,810 --> 00:09:16,259
a cheetah or a lion because that foreign

00:09:12,360 --> 00:09:19,730
key is on the cheetah and lion fields so

00:09:16,259 --> 00:09:22,259
I run a query on the cheetah table and

00:09:19,730 --> 00:09:25,649
it's not a cheetah so you get an

00:09:22,259 --> 00:09:29,040
exception and then we can try again with

00:09:25,649 --> 00:09:31,860
lion so this times it it works

00:09:29,040 --> 00:09:35,490
it returns roar but we've executed

00:09:31,860 --> 00:09:37,649
another query on the Lion table so what

00:09:35,490 --> 00:09:41,220
this means is for each record you have

00:09:37,649 --> 00:09:44,100
you'll execute up to n queries where n

00:09:41,220 --> 00:09:46,410
is the number of subclasses so if you

00:09:44,100 --> 00:09:51,120
add another subclass then your

00:09:46,410 --> 00:09:53,069
performance might be degraded but wait

00:09:51,120 --> 00:09:55,620
you say I love to either load and

00:09:53,069 --> 00:09:58,410
optimize everything okay that's great

00:09:55,620 --> 00:09:59,790
good for you and second of all you're

00:09:58,410 --> 00:10:02,610
still going to have to do a prefetch

00:09:59,790 --> 00:10:08,250
query or a select related which causes

00:10:02,610 --> 00:10:10,620
an evil left join per subclass so a good

00:10:08,250 --> 00:10:13,500
use case for multiple table inheritance

00:10:10,620 --> 00:10:15,990
is the classic shopping cart where a

00:10:13,500 --> 00:10:18,240
travel store we sell trips with start

00:10:15,990 --> 00:10:21,360
and end dates and we sell t-shirts with

00:10:18,240 --> 00:10:23,399
sizing information so the car or the

00:10:21,360 --> 00:10:25,259
order has a many-to-many relationship

00:10:23,399 --> 00:10:29,670
with product which means I have a join

00:10:25,259 --> 00:10:31,889
table here and if I just need that name

00:10:29,670 --> 00:10:34,050
and pricing information I don't have to

00:10:31,889 --> 00:10:37,680
follow the pointer to the trip and

00:10:34,050 --> 00:10:40,769
clothing classes then it's not really a

00:10:37,680 --> 00:10:43,290
performance problem if in addition if I

00:10:40,769 --> 00:10:45,569
only have a few products in a cart at a

00:10:43,290 --> 00:10:49,230
time then you can follow that foreign

00:10:45,569 --> 00:10:51,779
key and it shouldn't be too terrible so

00:10:49,230 --> 00:10:53,670
in conclusion the advantages of multiple

00:10:51,779 --> 00:10:55,740
table inheritance are that all the

00:10:53,670 --> 00:10:59,519
common parent attributes can be queried

00:10:55,740 --> 00:11:03,089
easily together however when you start

00:10:59,519 --> 00:11:04,649
accessing those subclasses it could lead

00:11:03,089 --> 00:11:07,259
to inefficient queries that hurt

00:11:04,649 --> 00:11:09,600
performance and make scaling difficult a

00:11:07,259 --> 00:11:11,939
lot of this is lack of understanding of

00:11:09,600 --> 00:11:13,829
what's happening under the covers so

00:11:11,939 --> 00:11:16,559
sometimes it is better to be more

00:11:13,829 --> 00:11:17,910
explicit because if your coworker adds a

00:11:16,559 --> 00:11:20,220
subclass two years now

00:11:17,910 --> 00:11:24,690
the road you might find yourself having

00:11:20,220 --> 00:11:27,360
performance problems okay last but not

00:11:24,690 --> 00:11:29,280
least we have proxy models the purpose

00:11:27,360 --> 00:11:31,170
of proxy models is to override the

00:11:29,280 --> 00:11:34,620
behavior and functionality of the parent

00:11:31,170 --> 00:11:36,830
class so we have exactly one table to

00:11:34,620 --> 00:11:39,840
rule them all

00:11:36,830 --> 00:11:42,120
so for lack of a better word everyone in

00:11:39,840 --> 00:11:44,130
middle-earth is a person this is our

00:11:42,120 --> 00:11:46,080
parent class they have a name and a

00:11:44,130 --> 00:11:48,240
person type that I'll talk about in a

00:11:46,080 --> 00:11:50,160
minute and there's a method called

00:11:48,240 --> 00:11:54,780
characteristic that returns middle earth

00:11:50,160 --> 00:11:56,670
dweller Hobbit subclasses person it sets

00:11:54,780 --> 00:11:59,030
proxy to true on the meta class

00:11:56,670 --> 00:12:02,390
definition and it defines a method

00:11:59,030 --> 00:12:06,750
characteristic that returns hairy feet

00:12:02,390 --> 00:12:09,800
so again there's one precious table no

00:12:06,750 --> 00:12:13,440
matter how many subclasses you add and

00:12:09,800 --> 00:12:15,180
when we access this via hobbit we'll get

00:12:13,440 --> 00:12:17,640
back a hobbit instance and calling

00:12:15,180 --> 00:12:21,480
characteristic will return hairy feet if

00:12:17,640 --> 00:12:23,850
we access it through person will use the

00:12:21,480 --> 00:12:26,430
same row in the database the same record

00:12:23,850 --> 00:12:28,620
but when we call characteristic we'll

00:12:26,430 --> 00:12:31,640
get back middle-earth dweller so we

00:12:28,620 --> 00:12:35,970
basically just changed the behavior of

00:12:31,640 --> 00:12:40,170
the subclass so what cool thing you can

00:12:35,970 --> 00:12:43,710
do with this is add a custom manager so

00:12:40,170 --> 00:12:47,430
this elf has an elf manager the elf

00:12:43,710 --> 00:12:49,620
manager overrides create to set the

00:12:47,430 --> 00:12:53,250
person type to e when the record is

00:12:49,620 --> 00:12:58,080
inserted we also override the query set

00:12:53,250 --> 00:13:00,900
to filter on person type equals e so

00:12:58,080 --> 00:13:03,090
this means if we query person objects at

00:13:00,900 --> 00:13:06,570
all then we'll get back instances of

00:13:03,090 --> 00:13:08,640
person for Frodo and Legolas however if

00:13:06,570 --> 00:13:11,550
we query with elf we get back only

00:13:08,640 --> 00:13:17,010
Legolas as an elf instance because Frodo

00:13:11,550 --> 00:13:19,020
is a hobbit so again one table we're

00:13:17,010 --> 00:13:21,240
just changing the where clause or the

00:13:19,020 --> 00:13:24,570
sorting order of the the columns that we

00:13:21,240 --> 00:13:28,830
select it's against proxy person which

00:13:24,570 --> 00:13:30,510
is our one and only table the advantages

00:13:28,830 --> 00:13:31,649
of proxy models are that it's really

00:13:30,510 --> 00:13:34,769
easy to modify this

00:13:31,649 --> 00:13:37,980
classes behavior the disadvantages are

00:13:34,769 --> 00:13:40,999
that fields used by any subclass must be

00:13:37,980 --> 00:13:43,619
defined for everyone on that one table

00:13:40,999 --> 00:13:46,199
use cases are things like an ordered

00:13:43,619 --> 00:13:49,800
model where you change the sorting to

00:13:46,199 --> 00:13:52,499
sort on like an added field or an active

00:13:49,800 --> 00:13:54,949
model where you filter out deactivated

00:13:52,499 --> 00:13:59,759
models if you're doing soft deletes and

00:13:54,949 --> 00:14:02,550
you can create a custom user model but

00:13:59,759 --> 00:14:05,100
it might be better to think of that as a

00:14:02,550 --> 00:14:10,319
one-to-one relationship between user and

00:14:05,100 --> 00:14:12,449
user profile so one thing you can do

00:14:10,319 --> 00:14:16,379
with proxy models is down casting and

00:14:12,449 --> 00:14:19,529
single table inheritance down casting is

00:14:16,379 --> 00:14:22,529
a way to cast instances into the

00:14:19,529 --> 00:14:26,639
subclass so normally when we query with

00:14:22,529 --> 00:14:29,459
person it returns a person in sorry a

00:14:26,639 --> 00:14:31,230
person in instance when you call

00:14:29,459 --> 00:14:34,619
characteristic it it returns middle

00:14:31,230 --> 00:14:37,620
earth dweller with down casting it will

00:14:34,619 --> 00:14:39,540
return a hobbit and an elf instance and

00:14:37,620 --> 00:14:42,749
the way that this works is we have a

00:14:39,540 --> 00:14:45,689
type field and we set it with the class

00:14:42,749 --> 00:14:47,699
name so we do one query we get that

00:14:45,689 --> 00:14:50,579
class name and then we instantiate the

00:14:47,699 --> 00:14:53,699
correct subclass and so when we get

00:14:50,579 --> 00:14:59,220
Frodo and call characteristic we've

00:14:53,699 --> 00:15:01,879
never wanted hairy feet so much so down

00:14:59,220 --> 00:15:05,399
casting is not supported out of the box

00:15:01,879 --> 00:15:07,949
you can use Django typed models or you

00:15:05,399 --> 00:15:10,860
could do it pretty cheaply and quickly

00:15:07,949 --> 00:15:13,220
on your own there's an article called

00:15:10,860 --> 00:15:16,350
Django STI on the cheap

00:15:13,220 --> 00:15:18,179
there is also down casting packages for

00:15:16,350 --> 00:15:19,889
multiple table inheritance but you have

00:15:18,179 --> 00:15:23,730
to be careful because you will still

00:15:19,889 --> 00:15:28,499
incur that extra query or select related

00:15:23,730 --> 00:15:30,329
depending on the implementation so the

00:15:28,499 --> 00:15:32,240
advantages of single table inheritance

00:15:30,329 --> 00:15:35,790
is performance performance performance

00:15:32,240 --> 00:15:39,660
one table means one query the

00:15:35,790 --> 00:15:41,939
disadvantage is that since each subclass

00:15:39,660 --> 00:15:44,279
all of the fields have to be represented

00:15:41,939 --> 00:15:45,370
on that one table it can lead to clutter

00:15:44,279 --> 00:15:47,950
and blah

00:15:45,370 --> 00:15:50,980
so some people call this the

00:15:47,950 --> 00:15:56,770
normalization of all the data on one

00:15:50,980 --> 00:15:58,360
table for performance the use cases for

00:15:56,770 --> 00:16:00,220
a single table and multiple table

00:15:58,360 --> 00:16:03,040
inheritance are really similar the

00:16:00,220 --> 00:16:05,170
shopping cart scenario would work the

00:16:03,040 --> 00:16:08,170
way that you can choose between them is

00:16:05,170 --> 00:16:10,750
ask yourself do most of the subclasses

00:16:08,170 --> 00:16:12,700
share fields and functionality and if so

00:16:10,750 --> 00:16:14,500
and you want a performance boost single

00:16:12,700 --> 00:16:17,440
table inheritance might be appropriate

00:16:14,500 --> 00:16:21,780
if they're vastly different then

00:16:17,440 --> 00:16:21,780
multiple table inheritance is preferable

00:16:21,810 --> 00:16:26,200
so now that we've gone through all this

00:16:24,130 --> 00:16:28,270
I'm going to tell you that sometimes the

00:16:26,200 --> 00:16:31,060
best type of model inheritance is not to

00:16:28,270 --> 00:16:33,130
use inheritance at all and so we have a

00:16:31,060 --> 00:16:34,960
couple of alternative approaches and

00:16:33,130 --> 00:16:39,850
then we have some ways to rethink the

00:16:34,960 --> 00:16:41,950
problem so this guy it's not really good

00:16:39,850 --> 00:16:46,450
to play a generic explosives all the

00:16:41,950 --> 00:16:48,970
time we have something called generic

00:16:46,450 --> 00:16:51,220
foreign keys in Django to implement

00:16:48,970 --> 00:16:53,920
polymorphism polymorphism is the ability

00:16:51,220 --> 00:16:57,070
of an object to take on many forms as

00:16:53,920 --> 00:16:58,780
you saw with inheritance so your

00:16:57,070 --> 00:17:01,870
homework is to look up how to define

00:16:58,780 --> 00:17:04,449
this in Django but in short a generic

00:17:01,870 --> 00:17:07,000
foreign key fakes a real foreign key

00:17:04,449 --> 00:17:09,459
with two fields the first field is the

00:17:07,000 --> 00:17:11,860
content type ID and that is a foreign

00:17:09,459 --> 00:17:15,130
key to the Kengo content types table

00:17:11,860 --> 00:17:17,470
that holds the name and the app label

00:17:15,130 --> 00:17:21,160
for all of your concrete models across

00:17:17,470 --> 00:17:24,339
all of your apps the other field is an

00:17:21,160 --> 00:17:28,270
object ID which is just an integer so we

00:17:24,339 --> 00:17:31,360
put the ID of the related model here you

00:17:28,270 --> 00:17:34,030
could put 0 or nonsense data it's just

00:17:31,360 --> 00:17:37,480
an integer field and so for that reason

00:17:34,030 --> 00:17:39,520
we have a very weak relationship to

00:17:37,480 --> 00:17:41,320
anything you want it to be it could be a

00:17:39,520 --> 00:17:45,640
blog it could be a giraffe it could be a

00:17:41,320 --> 00:17:48,010
location it doesn't matter so the

00:17:45,640 --> 00:17:49,600
advantages are that you can use any

00:17:48,010 --> 00:17:52,570
model you don't have to do another

00:17:49,600 --> 00:17:54,610
migration the use cases for generic

00:17:52,570 --> 00:17:57,040
foreign keys are things like tags and

00:17:54,610 --> 00:17:58,820
comments where the related object can be

00:17:57,040 --> 00:18:01,580
anything like a blog post

00:17:58,820 --> 00:18:05,300
or a giraffe or a location and the

00:18:01,580 --> 00:18:08,900
object the comment is not usually

00:18:05,300 --> 00:18:12,380
accessed outside of the blog post or

00:18:08,900 --> 00:18:14,690
giraffe a related object so what I mean

00:18:12,380 --> 00:18:16,580
is your typical use case would be like I

00:18:14,690 --> 00:18:18,500
have a blog post give me all of my

00:18:16,580 --> 00:18:21,110
comments for this particular blog post

00:18:18,500 --> 00:18:22,730
if you're asking the question like give

00:18:21,110 --> 00:18:24,620
me all the comments in the world I don't

00:18:22,730 --> 00:18:26,840
care what the object related to it is

00:18:24,620 --> 00:18:28,820
and then I need to go look into this

00:18:26,840 --> 00:18:31,280
object and do another query to see what

00:18:28,820 --> 00:18:32,750
it is then you might consider using a

00:18:31,280 --> 00:18:37,520
single table or multiple table

00:18:32,750 --> 00:18:40,190
inheritance so the disadvantages are

00:18:37,520 --> 00:18:43,280
that code can become hard to maintain if

00:18:40,190 --> 00:18:45,380
you're using dynamic type checking then

00:18:43,280 --> 00:18:46,910
two years down the road you might not

00:18:45,380 --> 00:18:48,520
remember what this object is that you're

00:18:46,910 --> 00:18:51,410
passing around in all your methods

00:18:48,520 --> 00:18:53,780
another disadvantage is in order to

00:18:51,410 --> 00:18:55,280
access those objects from the scenario

00:18:53,780 --> 00:18:57,800
where we have all the comments in the

00:18:55,280 --> 00:19:00,530
world you need you can't use select

00:18:57,800 --> 00:19:02,930
related so you're going to have to write

00:19:00,530 --> 00:19:05,270
custom sequel if you want to optimize

00:19:02,930 --> 00:19:07,250
the performance the other major

00:19:05,270 --> 00:19:09,200
disadvantage is that there's no

00:19:07,250 --> 00:19:11,960
referential integrity

00:19:09,200 --> 00:19:14,930
I think of referential integrity as a

00:19:11,960 --> 00:19:17,270
seat belt so you can drive your car down

00:19:14,930 --> 00:19:20,360
the road 200 miles an hour but you

00:19:17,270 --> 00:19:22,310
probably want to put on a seat belt so

00:19:20,360 --> 00:19:24,320
this means that you have nothing to

00:19:22,310 --> 00:19:26,750
prevent you from putting dirty data in

00:19:24,320 --> 00:19:29,300
the database if you delete a record it's

00:19:26,750 --> 00:19:32,030
just an object the object ID field is

00:19:29,300 --> 00:19:36,440
just an integer so it might not cascade

00:19:32,030 --> 00:19:41,470
through and you could just end up with a

00:19:36,440 --> 00:19:44,870
little bit of unclean data so the second

00:19:41,470 --> 00:19:48,380
alternative to model inheritance is

00:19:44,870 --> 00:19:50,810
unstructured data we have JSON field for

00:19:48,380 --> 00:19:52,400
Postgres and there's a JSON fields

00:19:50,810 --> 00:19:54,920
package that you can use with other

00:19:52,400 --> 00:19:57,350
databases now what we're doing here is

00:19:54,920 --> 00:19:59,120
we're taking a bunch of fields and we're

00:19:57,350 --> 00:20:02,810
serializing and then we're just shoving

00:19:59,120 --> 00:20:04,730
them into the database so this can avoid

00:20:02,810 --> 00:20:06,950
the clutter that you see with single

00:20:04,730 --> 00:20:10,790
table inheritance because each subclass

00:20:06,950 --> 00:20:12,260
just uses that one database field to jam

00:20:10,790 --> 00:20:15,260
in whatever it wants

00:20:12,260 --> 00:20:17,510
and as similarly it avoids the need for

00:20:15,260 --> 00:20:21,140
related objects as with multiple table

00:20:17,510 --> 00:20:23,299
inheritance the disadvantages are that

00:20:21,140 --> 00:20:26,270
it's pretty tough to query against

00:20:23,299 --> 00:20:29,240
unstructured fields Postgres will let

00:20:26,270 --> 00:20:31,520
you do it but for the most part you want

00:20:29,240 --> 00:20:35,240
to just put data into the database and

00:20:31,520 --> 00:20:38,360
not index against it or query against it

00:20:35,240 --> 00:20:40,190
the other disadvantage is that you lose

00:20:38,360 --> 00:20:44,630
data integrity it's not enforced by the

00:20:40,190 --> 00:20:47,059
database again and so all the validation

00:20:44,630 --> 00:20:49,549
has to be on the application level and

00:20:47,059 --> 00:20:51,890
then this can lead to dirty data since

00:20:49,549 --> 00:20:55,760
we're just putting in exactly what each

00:20:51,890 --> 00:20:57,620
subclass wants and you make a change so

00:20:55,760 --> 00:21:02,030
you have another blob and some of your

00:20:57,620 --> 00:21:03,140
data might be a little bit dirty okay

00:21:02,030 --> 00:21:07,280
so we've gotten through the two

00:21:03,140 --> 00:21:11,390
alternatives but maybe we could rethink

00:21:07,280 --> 00:21:13,429
this a little bit this lady is going

00:21:11,390 --> 00:21:15,559
into Corbett school or in Jackson Hole

00:21:13,429 --> 00:21:16,940
and she probably could have rethought

00:21:15,559 --> 00:21:21,440
her approach to a little bit this is the

00:21:16,940 --> 00:21:23,150
easy entrance she made it and I went in

00:21:21,440 --> 00:21:27,710
after her so is it's all good

00:21:23,150 --> 00:21:29,929
but my point is just because objects

00:21:27,710 --> 00:21:31,429
share attributes it doesn't mean we

00:21:29,929 --> 00:21:34,669
should represent them together in a

00:21:31,429 --> 00:21:36,980
hierarchy like a human and a beetle both

00:21:34,669 --> 00:21:43,070
have legs but they're not inherently

00:21:36,980 --> 00:21:45,260
similar or most of them the good news is

00:21:43,070 --> 00:21:48,559
that most izi relationships can be

00:21:45,260 --> 00:21:52,520
expressed as a has a relationship so a

00:21:48,559 --> 00:21:54,950
user is a seller or a user has a seller

00:21:52,520 --> 00:21:56,809
profile this is that one-to-one

00:21:54,950 --> 00:21:59,630
relationship I was talking about it with

00:21:56,809 --> 00:22:02,090
user you can create a profile instead of

00:21:59,630 --> 00:22:05,510
subclassing it another example is a

00:22:02,090 --> 00:22:08,299
manager is an employee or an employee

00:22:05,510 --> 00:22:11,179
has a managerial job and when you

00:22:08,299 --> 00:22:12,890
rethink the problem with composition you

00:22:11,179 --> 00:22:18,049
can take advantage of that natural

00:22:12,890 --> 00:22:20,059
mapping and the last thing I wanted to

00:22:18,049 --> 00:22:22,520
say was sometimes it's good to be

00:22:20,059 --> 00:22:25,070
explicit sometimes you can use multiple

00:22:22,520 --> 00:22:26,120
foreign keys instead of inheritance like

00:22:25,070 --> 00:22:28,490
proxy models

00:22:26,120 --> 00:22:30,679
or maybe if you only have one field to

00:22:28,490 --> 00:22:33,529
repeat you can just add it to multiple

00:22:30,679 --> 00:22:35,630
models and finally with multiple table

00:22:33,529 --> 00:22:38,390
inheritance you won't get the bells and

00:22:35,630 --> 00:22:40,490
whistles that Django provides but it's a

00:22:38,390 --> 00:22:43,539
lot more explicit to implement it as a

00:22:40,490 --> 00:22:45,980
one to one with one-to-one fields so

00:22:43,539 --> 00:22:48,890
everybody in your organization knows

00:22:45,980 --> 00:22:51,130
what's going on and you will recognize

00:22:48,890 --> 00:22:55,789
the fact that when you add a subclass

00:22:51,130 --> 00:22:58,429
your performance will be degraded so

00:22:55,789 --> 00:23:00,950
your future self will thank you and I

00:22:58,429 --> 00:23:02,690
thank you - I really appreciate it and a

00:23:00,950 --> 00:23:04,669
big shout out to all the organizers and

00:23:02,690 --> 00:23:07,309
volunteers at to make Django Khan so

00:23:04,669 --> 00:23:10,370
special please feel free to hit me up on

00:23:07,309 --> 00:23:14,390
all of the normal means I've put the

00:23:10,370 --> 00:23:17,090
slides and the the code that I used at

00:23:14,390 --> 00:23:20,120
Blythe Dunham DMI for Django model

00:23:17,090 --> 00:23:21,370
inheritance on github and thank you very

00:23:20,120 --> 00:23:25,220
much

00:23:21,370 --> 00:23:32,230
[Applause]

00:23:25,220 --> 00:23:32,230
[Music]

00:23:35,130 --> 00:23:37,190

YouTube URL: https://www.youtube.com/watch?v=BEHM210eR50


