Title: DjangoCon 2019 - Building effective Django queries with expressions by Vanessa Barreiros
Publication date: 2019-10-25
Playlist: DjangoCon US 2019
Description: 
	DjangoCon 2019 - Building effective Django queries with expressions by Vanessa Barreiros

In Django, we have a powerful tool called ORM to manipulate databases. For small queries, it can be quite simple but what happens when you need to do tricks like nested queries or computed values? One of the answers is query expressions. In this talk, we'll learn how to power-up queries effectively.

This talk was presented at: https://2019.djangocon.us/talks/building-effective-django-queries-with/

LINKS:
Follow Vanessa Barreiros ðŸ‘‡
On Twitter: https://twitter.com/vcfbarreiros
Official homepage: https://vinta.software/

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/

Intro music: "This Is How We Quirk It" by Avocado Junkie.
Video production by Confreaks TV.
Captions by White Coat Captioning.
Captions: 
	00:00:00,000 --> 00:00:17,930
[Music]

00:00:15,440 --> 00:00:20,630
I'm very happy to be here today and also

00:00:17,930 --> 00:00:22,400
this is a subject of some bleep all know

00:00:20,630 --> 00:00:25,700
long ago and I'm eager to share with all

00:00:22,400 --> 00:00:28,160
of you here this talk actually came up

00:00:25,700 --> 00:00:32,000
from a challenge with a project I work

00:00:28,160 --> 00:00:34,670
on which has some tables with more than

00:00:32,000 --> 00:00:37,400
millions of records so more than ten

00:00:34,670 --> 00:00:41,150
millions records so performance was

00:00:37,400 --> 00:00:45,739
required and we have to do we've had to

00:00:41,150 --> 00:00:47,570
do some optimizations and one of the

00:00:45,739 --> 00:00:51,170
most things we use it or career

00:00:47,570 --> 00:00:53,989
expressions so okay just some context

00:00:51,170 --> 00:00:55,790
about me I am Vanessa I'm from hissy-fit

00:00:53,989 --> 00:00:57,320
Brazil the red mark to the straight

00:00:55,790 --> 00:01:00,620
batter so I've come a long way to be

00:00:57,320 --> 00:01:04,070
here today and also I my jungle girls

00:01:00,620 --> 00:01:06,470
organizer at my hometown hissy fit and I

00:01:04,070 --> 00:01:11,390
also was part of the first female

00:01:06,470 --> 00:01:16,070
majority hackathon in my hometown hey

00:01:11,390 --> 00:01:17,329
girl and they both Texan blue is my

00:01:16,070 --> 00:01:20,240
twitter handle and I'm gonna post the

00:01:17,329 --> 00:01:21,439
slides there after this talk and also if

00:01:20,240 --> 00:01:23,030
you have any questions comments or

00:01:21,439 --> 00:01:28,490
general feedback please feel free to

00:01:23,030 --> 00:01:30,859
reach me there um as I said where I work

00:01:28,490 --> 00:01:33,409
as a software developer at Vita software

00:01:30,859 --> 00:01:36,380
we are a product consider C Company from

00:01:33,409 --> 00:01:39,259
hissy-fit Brazil which work with our

00:01:36,380 --> 00:01:41,210
clients mostly from the Bay Area in New

00:01:39,259 --> 00:01:42,799
York to F of the products using

00:01:41,210 --> 00:01:45,499
top-notch e wax and development

00:01:42,799 --> 00:01:49,249
techniques and we was we work mostly

00:01:45,499 --> 00:01:50,929
with django and react we also love open

00:01:49,249 --> 00:01:52,549
source so we have a lot of tools and I

00:01:50,929 --> 00:01:55,490
hope that you can check it again he owns

00:01:52,549 --> 00:01:57,409
lash printer software and we've got a

00:01:55,490 --> 00:01:59,569
playbook as well we all processes to

00:01:57,409 --> 00:02:03,439
learn so far so you can check it out on

00:01:59,569 --> 00:02:04,850
our website it's pretty cool so ok on to

00:02:03,439 --> 00:02:07,280
the topic we're going to talk about

00:02:04,850 --> 00:02:09,530
curry expressions today but first I want

00:02:07,280 --> 00:02:11,450
you guys call a question have you ever

00:02:09,530 --> 00:02:13,819
tried to fetch complex data in an

00:02:11,450 --> 00:02:16,580
application and got really confused it

00:02:13,819 --> 00:02:18,769
it's a rhetorical question almost there

00:02:16,580 --> 00:02:21,409
but it's happened a lot to me so I can

00:02:18,769 --> 00:02:24,110
only imagine how many times has happen

00:02:21,409 --> 00:02:25,760
it to all of you here

00:02:24,110 --> 00:02:28,100
and as I use Django in my day-to-day

00:02:25,760 --> 00:02:29,720
after some time ago that this framework

00:02:28,100 --> 00:02:32,510
is 14 years old

00:02:29,720 --> 00:02:34,610
so a lot of people use it so it must

00:02:32,510 --> 00:02:38,170
have something to help me get whatever I

00:02:34,610 --> 00:02:40,940
want in the best possible way and I also

00:02:38,170 --> 00:02:44,120
I've worked it with applications like we

00:02:40,940 --> 00:02:47,390
were large over time and we change this

00:02:44,120 --> 00:02:49,010
on business rules and contacts it became

00:02:47,390 --> 00:02:53,030
very common to create some redundancies

00:02:49,010 --> 00:02:54,890
along the way and we win we ended up

00:02:53,030 --> 00:02:56,540
creating more and more fields in a

00:02:54,890 --> 00:02:59,480
database then we actually need it

00:02:56,540 --> 00:03:02,360
and that's a reality of a lot of systems

00:02:59,480 --> 00:03:04,520
out there and to mitigate some very

00:03:02,360 --> 00:03:06,760
prominent problems like this sometimes

00:03:04,520 --> 00:03:09,800
people follow paths such as caching or

00:03:06,760 --> 00:03:11,270
denormalization and by the way if you're

00:03:09,800 --> 00:03:13,100
interested in the normalization there's

00:03:11,270 --> 00:03:14,780
a great talk about it by Flavio now he's

00:03:13,100 --> 00:03:17,480
one of mintus partners you could check

00:03:14,780 --> 00:03:19,550
it out on YouTube but if your

00:03:17,480 --> 00:03:21,320
application isn't really complex

00:03:19,550 --> 00:03:24,709
it doesn't need dimension and adversity

00:03:21,320 --> 00:03:26,930
techniques you don't have an excuse not

00:03:24,709 --> 00:03:28,910
to use their or em and to do your

00:03:26,930 --> 00:03:32,570
queries and we're gonna learn why and

00:03:28,910 --> 00:03:34,250
how today but we can start talking about

00:03:32,570 --> 00:03:38,510
query expressions without explaining

00:03:34,250 --> 00:03:40,550
what theyÃµre means it's powerful to call

00:03:38,510 --> 00:03:43,850
the ramp as you may know in general go

00:03:40,550 --> 00:03:45,730
we have the RAM the object relational

00:03:43,850 --> 00:03:49,670
mapping and for those who don't know

00:03:45,730 --> 00:03:51,590
it's uh it's in few words it's a tool to

00:03:49,670 --> 00:03:53,870
translate or most of the time relational

00:03:51,590 --> 00:03:55,640
database dialect into pythonic objects

00:03:53,870 --> 00:03:58,250
name it models so they become more

00:03:55,640 --> 00:03:59,720
readable in manipulatable and it has

00:03:58,250 --> 00:04:01,790
lots of useful things that we can use to

00:03:59,720 --> 00:04:04,400
search for something in our database so

00:04:01,790 --> 00:04:08,600
for example we have pewter which you're

00:04:04,400 --> 00:04:10,700
gonna be using a lot today and decide it

00:04:08,600 --> 00:04:13,940
has lots of abstractions to help to

00:04:10,700 --> 00:04:18,859
gather data much more easily than

00:04:13,940 --> 00:04:20,209
writing the pure SQL SQL sorry but today

00:04:18,859 --> 00:04:23,270
we're not going to talk about simple

00:04:20,209 --> 00:04:27,140
filters we're gonna talk more about and

00:04:23,270 --> 00:04:30,110
dive into some concepts about the create

00:04:27,140 --> 00:04:32,150
expressions such as Q&F objects database

00:04:30,110 --> 00:04:33,710
functions conditional expressions in

00:04:32,150 --> 00:04:35,510
presenter many ways in which you can

00:04:33,710 --> 00:04:37,940
appease your advanc'd query needs with

00:04:35,510 --> 00:04:40,760
Python in a few more which

00:04:37,940 --> 00:04:43,970
buildings also and all of that we're

00:04:40,760 --> 00:04:45,770
gonna be using pure expressions which

00:04:43,970 --> 00:04:47,420
are is mark yet straightforward

00:04:45,770 --> 00:04:50,150
functions that can be used to compute

00:04:47,420 --> 00:04:51,380
values on query execution so for example

00:04:50,150 --> 00:04:55,160
if you want to do queries with or

00:04:51,380 --> 00:04:58,820
statements on string manipulations

00:04:55,160 --> 00:05:01,190
calculations and so on everything at a

00:04:58,820 --> 00:05:03,230
time iago hits the database you're gonna

00:05:01,190 --> 00:05:04,550
be using query expressions for that so

00:05:03,230 --> 00:05:07,610
this removes the necessity of having

00:05:04,550 --> 00:05:10,190
extra columns there in our database and

00:05:07,610 --> 00:05:14,150
how helps you generate readable and

00:05:10,190 --> 00:05:17,240
optimize it queries so for instance with

00:05:14,150 --> 00:05:18,890
a simple database of 500,000 records to

00:05:17,240 --> 00:05:20,990
get people who were born in a lip here

00:05:18,890 --> 00:05:23,870
for example instead of writing the SQL

00:05:20,990 --> 00:05:26,210
on top or maybe the native code on the

00:05:23,870 --> 00:05:28,760
left which one by the way we in an

00:05:26,210 --> 00:05:30,650
average of almost four seconds we're

00:05:28,760 --> 00:05:32,780
gonna write the code on the right which

00:05:30,650 --> 00:05:34,490
running in an average point 32 seconds

00:05:32,780 --> 00:05:38,720
and for that we're gonna be used in

00:05:34,490 --> 00:05:40,190
query expressions learn 8 today and just

00:05:38,720 --> 00:05:42,200
start to start with them we're gonna

00:05:40,190 --> 00:05:45,380
understand more we need to understand

00:05:42,200 --> 00:05:46,880
more about cue objects so because they

00:05:45,380 --> 00:05:49,370
are the most common solution and if

00:05:46,880 --> 00:05:51,980
you're familiar jungle you must have

00:05:49,370 --> 00:05:54,350
used it a lot they're usually the first

00:05:51,980 --> 00:05:56,720
contact one has with complex fearing

00:05:54,350 --> 00:05:59,270
because it's API is not difficult to

00:05:56,720 --> 00:06:00,040
understand so they serve as a nice call

00:05:59,270 --> 00:06:02,540
encapsulator

00:06:00,040 --> 00:06:04,030
for queries with different conditions so

00:06:02,540 --> 00:06:06,710
if you want to do queries with or

00:06:04,030 --> 00:06:09,470
statements or negative statements cue

00:06:06,710 --> 00:06:12,110
objects or what you're looking for so to

00:06:09,470 --> 00:06:13,880
start with a simple example if we want

00:06:12,110 --> 00:06:16,310
to fetch people who were born in

00:06:13,880 --> 00:06:18,740
different generations by the way birth

00:06:16,310 --> 00:06:21,740
date birth date is a field in our person

00:06:18,740 --> 00:06:24,169
model we need to change the cue objects

00:06:21,740 --> 00:06:26,740
like this passing each one of our

00:06:24,169 --> 00:06:29,750
conditions into a cue object and then

00:06:26,740 --> 00:06:32,870
separating them using the or operator

00:06:29,750 --> 00:06:34,910
operator and Django is a smart enough to

00:06:32,870 --> 00:06:38,600
generate the SQL and filter everything

00:06:34,910 --> 00:06:41,060
for us so in case he wants you do to add

00:06:38,600 --> 00:06:43,640
more conditions it's possible to compose

00:06:41,060 --> 00:06:46,580
complex filters with cue objects as well

00:06:43,640 --> 00:06:51,320
so remember our first puter by years now

00:06:46,580 --> 00:06:51,889
we've added a location filter inside a

00:06:51,320 --> 00:06:56,449
cue object

00:06:51,889 --> 00:06:59,330
as well so this for this wheel feeder by

00:06:56,449 --> 00:07:01,849
anyone was born in one of these ranges

00:06:59,330 --> 00:07:02,599
and range of years and lives in

00:07:01,849 --> 00:07:06,680
California

00:07:02,599 --> 00:07:08,569
so you can mix key objects using the

00:07:06,680 --> 00:07:11,509
operators of the Empress trend or the

00:07:08,569 --> 00:07:14,360
vertical bar so to include more

00:07:11,509 --> 00:07:17,560
conditions you can just add more key

00:07:14,360 --> 00:07:21,379
objects and separate them and so good

00:07:17,560 --> 00:07:23,629
and just a tip because it's very

00:07:21,379 --> 00:07:26,810
extensible complex fears with key

00:07:23,629 --> 00:07:28,639
objects can get huge over time so when I

00:07:26,810 --> 00:07:30,830
know some people say that gue code is

00:07:28,639 --> 00:07:32,990
self documenting but it's advised to

00:07:30,830 --> 00:07:35,000
comment just a little bit so you won't

00:07:32,990 --> 00:07:37,400
lose time trying to understand the code

00:07:35,000 --> 00:07:40,370
you wrote a year ago how it works

00:07:37,400 --> 00:07:42,979
today and as I said before I can add as

00:07:40,370 --> 00:07:47,719
many spheres as you want such as bullet

00:07:42,979 --> 00:07:50,330
type job as I did here and so moving on

00:07:47,719 --> 00:07:52,430
let's say that our application has an

00:07:50,330 --> 00:07:55,310
interface that users can search search

00:07:52,430 --> 00:07:57,379
stuff and they user can input whatever

00:07:55,310 --> 00:08:00,529
they want and we're gonna search for all

00:07:57,379 --> 00:08:03,919
possible fields fields using excessive

00:08:00,529 --> 00:08:07,759
contains for example they look up and

00:08:03,919 --> 00:08:10,069
that will work but what if the user ones

00:08:07,759 --> 00:08:13,069
wants to search just for the first name

00:08:10,069 --> 00:08:15,740
for example or a job title we can give

00:08:13,069 --> 00:08:18,409
our user the freedom to search for

00:08:15,740 --> 00:08:20,479
whatever things they want and that's

00:08:18,409 --> 00:08:23,300
possible with we mount a key object

00:08:20,479 --> 00:08:27,139
before doing the query by using an

00:08:23,300 --> 00:08:29,210
approach with some ifs in Cuba there are

00:08:27,139 --> 00:08:31,939
some other approaches but I've chosen

00:08:29,210 --> 00:08:33,769
chosen just one so it will check which

00:08:31,939 --> 00:08:35,300
fields the user has selected for example

00:08:33,769 --> 00:08:38,060
in our future

00:08:35,300 --> 00:08:41,269
the the UI in add conditionals

00:08:38,060 --> 00:08:44,449
accordingly so for example email field

00:08:41,269 --> 00:08:48,800
was not included in the search so we

00:08:44,449 --> 00:08:50,180
won't be added to our final field and at

00:08:48,800 --> 00:08:52,130
the end you're just gonna pass the

00:08:50,180 --> 00:08:56,600
demoted fewer they mounted queue object

00:08:52,130 --> 00:08:59,720
to the the or am theater and it's gonna

00:08:56,600 --> 00:09:02,510
work it's gonna find for example people

00:08:59,720 --> 00:09:05,149
with mark as name for celeste people

00:09:02,510 --> 00:09:05,810
which works which work as a chief

00:09:05,149 --> 00:09:09,950
marketing

00:09:05,810 --> 00:09:11,960
officer trademark attorney and so and

00:09:09,950 --> 00:09:14,840
just a quick of topic if you are more

00:09:11,960 --> 00:09:16,820
familiar with SQL and want to see what

00:09:14,840 --> 00:09:20,540
your database reads you can print your

00:09:16,820 --> 00:09:21,890
query without query the yellow arrow and

00:09:20,540 --> 00:09:23,960
you're gonna see the output below in

00:09:21,890 --> 00:09:25,220
this case for both words databases I've

00:09:23,960 --> 00:09:28,100
omitted so many for just for

00:09:25,220 --> 00:09:30,650
simplification as well if you want if

00:09:28,100 --> 00:09:32,810
you also want to format it you can use a

00:09:30,650 --> 00:09:34,790
lip called SQL parse it's a jungle

00:09:32,810 --> 00:09:37,850
dependency so it already comes when you

00:09:34,790 --> 00:09:39,740
saw on jungle the point is that it's

00:09:37,850 --> 00:09:42,560
important to understand the eddying

00:09:39,740 --> 00:09:44,680
everything is escrow it took me some

00:09:42,560 --> 00:09:47,120
time to realize that and as you can see

00:09:44,680 --> 00:09:49,100
django handles everything for us so we

00:09:47,120 --> 00:09:51,589
don't have to worry about writing super

00:09:49,100 --> 00:09:54,080
long as closed statements which is not

00:09:51,589 --> 00:09:55,730
quite the case now since we have a very

00:09:54,080 --> 00:09:59,800
simple example but that becomes a

00:09:55,730 --> 00:10:02,600
reality on your application skills

00:09:59,800 --> 00:10:04,940
another base resource which is very

00:10:02,600 --> 00:10:08,720
useful for queries is called f

00:10:04,940 --> 00:10:10,930
expressions or f objects and to start we

00:10:08,720 --> 00:10:13,630
did i want to show in a simple first

00:10:10,930 --> 00:10:17,480
according to the American Red Cross

00:10:13,630 --> 00:10:19,160
people can donate blood every 56 days so

00:10:17,480 --> 00:10:21,290
we have our person model here that you

00:10:19,160 --> 00:10:24,230
already know about with your field was

00:10:21,290 --> 00:10:26,420
donated in kinda neon and theoretically

00:10:24,230 --> 00:10:29,360
speaking when the lesson edit gets

00:10:26,420 --> 00:10:33,080
updated we should donate we should

00:10:29,360 --> 00:10:36,140
update the can donate on as well with 56

00:10:33,080 --> 00:10:38,270
days ahead if you want to get people who

00:10:36,140 --> 00:10:42,350
can already donate you could do

00:10:38,270 --> 00:10:47,810
something like this using fewer the less

00:10:42,350 --> 00:10:49,700
than or equal the today's date and but

00:10:47,810 --> 00:10:52,580
what happens if the last native field is

00:10:49,700 --> 00:10:56,540
updated but can donate on is not for any

00:10:52,580 --> 00:10:58,190
reason it's critical because we can go

00:10:56,540 --> 00:11:01,760
and see that this field is going to have

00:10:58,190 --> 00:11:03,230
a reliable value and it's also critical

00:11:01,760 --> 00:11:07,310
because we can let people then I put

00:11:03,230 --> 00:11:10,790
before the 56 days so this code could

00:11:07,310 --> 00:11:12,800
cause serious inconsistencies and to

00:11:10,790 --> 00:11:15,380
solve this problem you will have to use

00:11:12,800 --> 00:11:19,220
F objects because the value will always

00:11:15,380 --> 00:11:19,850
be calculated at query execution so we

00:11:19,220 --> 00:11:22,699
will

00:11:19,850 --> 00:11:25,730
be correct enough objects or is it when

00:11:22,699 --> 00:11:28,459
you want to reference model fields or

00:11:25,730 --> 00:11:32,209
reference annotations without having to

00:11:28,459 --> 00:11:34,250
load the values into your memory so you

00:11:32,209 --> 00:11:36,019
can do basic read medical operations on

00:11:34,250 --> 00:11:39,470
query execution for example as I said

00:11:36,019 --> 00:11:41,420
people can donate blood every 56 days so

00:11:39,470 --> 00:11:43,579
to know when they can donate again you

00:11:41,420 --> 00:11:46,670
can annotate the date use a knife to get

00:11:43,579 --> 00:11:50,240
a lesson edit value' and add 56 days

00:11:46,670 --> 00:11:52,310
using time data for example and without

00:11:50,240 --> 00:11:56,350
it we will you would have to worry the

00:11:52,310 --> 00:11:59,029
raw SQL because or fiddle with Python

00:11:56,350 --> 00:12:02,209
which we saw in the beginning of the

00:11:59,029 --> 00:12:03,649
sock decreases performance a lot because

00:12:02,209 --> 00:12:05,720
there's no such way to do operations

00:12:03,649 --> 00:12:09,560
like this in an effective way

00:12:05,720 --> 00:12:12,170
without easy knife as far as I know so

00:12:09,560 --> 00:12:14,209
we can also use F to do operations with

00:12:12,170 --> 00:12:17,029
different fields or to reference

00:12:14,209 --> 00:12:19,100
annotations as I said so from our last

00:12:17,029 --> 00:12:21,290
example we annotated as exact date in

00:12:19,100 --> 00:12:23,990
which P in which people can donate Bohr

00:12:21,290 --> 00:12:25,459
again use a knife and time data but now

00:12:23,990 --> 00:12:28,670
we're gonna use a F for everything

00:12:25,459 --> 00:12:30,920
it is example we run a blood bank and

00:12:28,670 --> 00:12:34,279
want to check how many bags are missing

00:12:30,920 --> 00:12:36,439
for our goal oh and to do that we can

00:12:34,279 --> 00:12:38,870
use the annotation of how many blood

00:12:36,439 --> 00:12:41,990
bags we currently have in our bank and

00:12:38,870 --> 00:12:44,089
subtract this value use a knife from the

00:12:41,990 --> 00:12:47,149
goal quantity which is a food in our

00:12:44,089 --> 00:12:50,000
blood bank Maru so we can get exactly

00:12:47,149 --> 00:12:54,649
how many bags we are missing from our

00:12:50,000 --> 00:12:57,649
goal 500 in this case so in the previous

00:12:54,649 --> 00:13:00,410
example with F with two fields but both

00:12:57,649 --> 00:13:02,899
were integers so in case we want to do

00:13:00,410 --> 00:13:05,480
operations with different fields or with

00:13:02,899 --> 00:13:07,069
fields of different types I mean we have

00:13:05,480 --> 00:13:08,870
to use something called expression

00:13:07,069 --> 00:13:12,139
wrapper because when you try to for

00:13:08,870 --> 00:13:16,910
example in our event model some the

00:13:12,139 --> 00:13:20,750
event duration with the the starts the

00:13:16,910 --> 00:13:23,000
end so on they start at sorry jungle is

00:13:20,750 --> 00:13:26,600
gonna it's going to throw food error

00:13:23,000 --> 00:13:28,069
because it's a duration field and add a

00:13:26,600 --> 00:13:31,250
time field different types

00:13:28,069 --> 00:13:33,050
so that's offered by wrapping or some in

00:13:31,250 --> 00:13:35,180
expression wrapper you

00:13:33,050 --> 00:13:37,640
we call expression wiper in setting the

00:13:35,180 --> 00:13:39,500
output field as a datum field in general

00:13:37,640 --> 00:13:42,320
which gonna is gonna be a smart enough

00:13:39,500 --> 00:13:44,990
to to do the operation and give the

00:13:42,320 --> 00:13:47,390
result the result to us in a day time

00:13:44,990 --> 00:13:49,730
field so for example if we have anything

00:13:47,390 --> 00:13:52,730
that starts today in a saturation of one

00:13:49,730 --> 00:13:57,050
day the end zone should be tomorrow same

00:13:52,730 --> 00:13:58,790
time in at the end we can mix f NQ

00:13:57,050 --> 00:14:01,399
objects all together to create unique

00:13:58,790 --> 00:14:03,800
queries in this case we want to get

00:14:01,399 --> 00:14:06,410
people whose first name equals their

00:14:03,800 --> 00:14:08,690
last name and don't have mark in their

00:14:06,410 --> 00:14:12,769
job titles I have nothing against marks

00:14:08,690 --> 00:14:14,450
this is just an example and as you can

00:14:12,769 --> 00:14:17,180
see query expressions are very modular

00:14:14,450 --> 00:14:20,899
just like other resources where you're

00:14:17,180 --> 00:14:23,180
gonna see soon we've seen how to create

00:14:20,899 --> 00:14:24,769
filters how to access into operations

00:14:23,180 --> 00:14:26,329
with different fields and now we're

00:14:24,769 --> 00:14:29,120
going to use we're going to learn and

00:14:26,329 --> 00:14:32,450
use how to manipulate data with database

00:14:29,120 --> 00:14:34,640
functions they are basically some

00:14:32,450 --> 00:14:37,279
abstractions that to helps us to get our

00:14:34,640 --> 00:14:40,279
database to access database level

00:14:37,279 --> 00:14:42,529
functions as the name suggests directly

00:14:40,279 --> 00:14:45,589
so for example to count how many pets we

00:14:42,529 --> 00:14:48,020
have in our system how many pet types I

00:14:45,589 --> 00:14:51,680
mean we have to use a function called

00:14:48,020 --> 00:14:53,779
count in an annotation in that just like

00:14:51,680 --> 00:14:56,300
most of the the basic functions are

00:14:53,779 --> 00:14:58,399
going to be available using the few do

00:14:56,300 --> 00:15:00,670
pass then include the name of the few D

00:14:58,399 --> 00:15:04,160
pass dunder the database function name

00:15:00,670 --> 00:15:04,850
so in our case we have typed the

00:15:04,160 --> 00:15:06,800
undercount

00:15:04,850 --> 00:15:09,310
so that at the end we have the

00:15:06,800 --> 00:15:12,350
distribution of pet types easily and

00:15:09,310 --> 00:15:13,790
there are more than 50 database track

00:15:12,350 --> 00:15:16,790
record sorry

00:15:13,790 --> 00:15:18,890
there are base functions and so I won't

00:15:16,790 --> 00:15:21,800
show them all today because of the time

00:15:18,890 --> 00:15:25,459
but you we're gonna see some of them and

00:15:21,800 --> 00:15:27,410
see how easy for they are database

00:15:25,459 --> 00:15:30,170
functions is it with annotations are

00:15:27,410 --> 00:15:32,390
very important resource especially when

00:15:30,170 --> 00:15:34,779
performance is needed so another good

00:15:32,390 --> 00:15:38,420
example we have a person water here and

00:15:34,779 --> 00:15:40,220
we have it has two fields first name and

00:15:38,420 --> 00:15:42,589
last name and I want to search for a

00:15:40,220 --> 00:15:44,720
string in their full name so adding a

00:15:42,589 --> 00:15:46,970
property would do the trick

00:15:44,720 --> 00:15:50,150
I just have to

00:15:46,970 --> 00:15:53,840
everyone every person into your memory

00:15:50,150 --> 00:15:57,020
and do the search but there's a problem

00:15:53,840 --> 00:16:00,280
here since it's a property it cannot be

00:15:57,020 --> 00:16:03,020
used in queries so if I wanted to search

00:16:00,280 --> 00:16:05,000
do a search in everybody's name in this

00:16:03,020 --> 00:16:09,170
scenario I would have to load everyone

00:16:05,000 --> 00:16:11,150
into memory that's not what I want in a

00:16:09,170 --> 00:16:13,010
solution to that realize I'm in an old

00:16:11,150 --> 00:16:15,890
function called concat which stands for

00:16:13,010 --> 00:16:17,660
concatenation so it can annotate the

00:16:15,890 --> 00:16:20,000
full name by calling this function with

00:16:17,660 --> 00:16:23,240
the few names by the way I have to put I

00:16:20,000 --> 00:16:26,030
had to put a value there because Django

00:16:23,240 --> 00:16:28,280
if I if I had just but the empty string

00:16:26,030 --> 00:16:32,030
Jiang would try to look for a field name

00:16:28,280 --> 00:16:35,090
in mp shrink and it would throw an error

00:16:32,030 --> 00:16:37,460
and after annotating the full name I can

00:16:35,090 --> 00:16:40,490
use as many strings lookups as I want

00:16:37,460 --> 00:16:44,390
and it's gonna work just so you see I

00:16:40,490 --> 00:16:46,550
wanted to bring this gave just to

00:16:44,390 --> 00:16:49,070
compare our solutions with the full name

00:16:46,550 --> 00:16:51,410
property and the annotation so at first

00:16:49,070 --> 00:16:53,870
is very fast but as I admire diversity

00:16:51,410 --> 00:16:55,850
my limit the worse it gets so the last

00:16:53,870 --> 00:16:57,950
frame was like five hundred thousand

00:16:55,850 --> 00:17:00,860
records and took about four seconds to

00:16:57,950 --> 00:17:02,870
load everyone's full name and in a big

00:17:00,860 --> 00:17:05,870
applications such as they wanna work on

00:17:02,870 --> 00:17:07,930
with millions records that's too long

00:17:05,870 --> 00:17:13,339
for the end user and we cannot let

00:17:07,930 --> 00:17:16,069
things like this happen in back we are

00:17:13,339 --> 00:17:18,170
full name example here's a tip to avoid

00:17:16,069 --> 00:17:20,689
calling the Honan annotation and

00:17:18,170 --> 00:17:23,000
importing everything every time we want

00:17:20,689 --> 00:17:24,680
to load everyone's full name you can add

00:17:23,000 --> 00:17:28,850
this annotation to a query set or a

00:17:24,680 --> 00:17:32,240
manager I pick a career set just for

00:17:28,850 --> 00:17:36,020
simplification and a decree aside to the

00:17:32,240 --> 00:17:38,090
model using da as manager so now you

00:17:36,020 --> 00:17:39,950
don't have to worry about it whenever

00:17:38,090 --> 00:17:42,740
you have the person model you can just

00:17:39,950 --> 00:17:45,350
call annotate if your name annotate full

00:17:42,740 --> 00:17:49,370
name method and it's gonna work and then

00:17:45,350 --> 00:17:53,000
you can do the search just like as you

00:17:49,370 --> 00:17:55,520
want and another great example is a

00:17:53,000 --> 00:17:56,510
database function called Colley's it

00:17:55,520 --> 00:17:59,570
returns the north

00:17:56,510 --> 00:18:00,860
move the first non loop value given at

00:17:59,570 --> 00:18:03,320
least two field names

00:18:00,860 --> 00:18:05,450
for example person person model has a

00:18:03,320 --> 00:18:07,970
nickname field and if they have one I

00:18:05,450 --> 00:18:10,100
want to show it and if they don't I want

00:18:07,970 --> 00:18:13,429
to just roll the first name and that

00:18:10,100 --> 00:18:15,440
works but there's a pitfall as a circle

00:18:13,429 --> 00:18:19,460
I call this returns the first no no

00:18:15,440 --> 00:18:21,769
value if anyone has for some reason an

00:18:19,460 --> 00:18:25,370
empty string as a nickname the

00:18:21,769 --> 00:18:28,460
annotation will return an empty string

00:18:25,370 --> 00:18:30,380
that's not what I want in a solution to

00:18:28,460 --> 00:18:34,789
that is using another database function

00:18:30,380 --> 00:18:36,830
called know if added in Django 2.0 and

00:18:34,789 --> 00:18:39,320
we just have two expressions in return

00:18:36,830 --> 00:18:41,919
known returns known if they are equal so

00:18:39,320 --> 00:18:44,750
in our case in our case we compare our

00:18:41,919 --> 00:18:47,990
nickname with an empty string value and

00:18:44,750 --> 00:18:50,419
again I had to use the value function

00:18:47,990 --> 00:18:54,230
because if I hadn't juggle would look

00:18:50,419 --> 00:18:58,340
for field called empty string and that's

00:18:54,230 --> 00:19:00,139
gonna work we see that we can do some

00:18:58,340 --> 00:19:02,600
conditional queries with only no leaf

00:19:00,139 --> 00:19:05,750
for example in our last example but if

00:19:02,600 --> 00:19:08,120
we want to do some complex queries with

00:19:05,750 --> 00:19:11,230
just one term we can use conditional

00:19:08,120 --> 00:19:15,289
expressions so they allow you to use

00:19:11,230 --> 00:19:17,210
conditional logic in queries that means

00:19:15,289 --> 00:19:19,940
furies updates annotations and such

00:19:17,210 --> 00:19:21,500
things and without them you know you

00:19:19,940 --> 00:19:25,460
will have to use Python and the code

00:19:21,500 --> 00:19:27,740
will be bigger so from for our example I

00:19:25,460 --> 00:19:32,779
said that people can order things for

00:19:27,740 --> 00:19:36,200
some marketplace commerce and let's give

00:19:32,779 --> 00:19:38,570
them discount if these orders if there

00:19:36,200 --> 00:19:41,360
are two days or if there are loyal

00:19:38,570 --> 00:19:43,789
customers so using their orders for

00:19:41,360 --> 00:19:46,039
today let's get if the user join it or

00:19:43,789 --> 00:19:48,649
system this decade or in this case we're

00:19:46,039 --> 00:19:52,669
going to give them a 20% discount in

00:19:48,649 --> 00:19:55,220
case they join it between 2000 in 1995

00:19:52,669 --> 00:19:58,429
we're gonna give them 40% discount and

00:19:55,220 --> 00:20:00,260
so on so by the way it's point a in

00:19:58,429 --> 00:20:02,360
point 6 because the discount is

00:20:00,260 --> 00:20:05,059
subtracted subtracted from the full

00:20:02,360 --> 00:20:08,380
price and we can understand this code

00:20:05,059 --> 00:20:10,070
but it's not really too easy to read a

00:20:08,380 --> 00:20:13,580
better way to do it

00:20:10,070 --> 00:20:15,310
we'll be using case and when expressions

00:20:13,580 --> 00:20:19,160
so case is very useful because you can

00:20:15,310 --> 00:20:21,770
use like if a leaves and houses in or in

00:20:19,160 --> 00:20:23,240
our query in little to no time and it's

00:20:21,770 --> 00:20:25,480
better because the value is calculated

00:20:23,240 --> 00:20:29,570
at the time the query it's exact its

00:20:25,480 --> 00:20:33,820
executed so it would be much faster and

00:20:29,570 --> 00:20:37,490
if you want you can you can also filter

00:20:33,820 --> 00:20:40,400
the result at the base level so you hit

00:20:37,490 --> 00:20:43,570
it only once so and that's it it's an

00:20:40,400 --> 00:20:47,930
annotation we don't lose the original

00:20:43,570 --> 00:20:50,210
order total in at the end we can mix

00:20:47,930 --> 00:20:52,640
everything we learn it to annotate with

00:20:50,210 --> 00:20:54,770
someone's birth year is a leap year for

00:20:52,640 --> 00:20:56,360
example so just to give some context

00:20:54,770 --> 00:21:00,560
about how to calculate a leap year

00:20:56,360 --> 00:21:04,760
it's very difficult it took me some time

00:21:00,560 --> 00:21:08,450
to to understand it should be exactly

00:21:04,760 --> 00:21:11,900
divisible by 4 if it can be exactly

00:21:08,450 --> 00:21:14,840
divisible by 100 it's not unless it's

00:21:11,900 --> 00:21:19,100
exactly divisible by 400 it's a bit

00:21:14,840 --> 00:21:21,350
tricky but just forget the idea so we

00:21:19,100 --> 00:21:23,720
start by doing on the new annotations

00:21:21,350 --> 00:21:26,540
with database functions cast to

00:21:23,720 --> 00:21:29,090
transform the value from extract here to

00:21:26,540 --> 00:21:30,830
an integer because extract here at the

00:21:29,090 --> 00:21:33,500
base level returns a double precision

00:21:30,830 --> 00:21:36,040
floating point that I don't know I don't

00:21:33,500 --> 00:21:39,020
know about it

00:21:36,040 --> 00:21:41,660
I've never personally use it that as

00:21:39,020 --> 00:21:44,000
well but that's where they were ever set

00:21:41,660 --> 00:21:47,090
enough objects to do the operations with

00:21:44,000 --> 00:21:49,870
reference annotations to get the modulus

00:21:47,090 --> 00:21:52,850
of the inner integer first ample and

00:21:49,870 --> 00:21:54,920
then we use the previous annotations

00:21:52,850 --> 00:21:58,580
into a conditional expressions with key

00:21:54,920 --> 00:22:01,550
objects in the one second line we define

00:21:58,580 --> 00:22:06,020
false by default and we can do all the

00:22:01,550 --> 00:22:07,790
math to make it true and finally we

00:22:06,020 --> 00:22:10,880
filter by the annotation we just did and

00:22:07,790 --> 00:22:13,100
from now on it's just testing if we did

00:22:10,880 --> 00:22:15,350
the right thing so at the end with we

00:22:13,100 --> 00:22:18,680
have done calculations and conditionals

00:22:15,350 --> 00:22:22,790
just hitting the database ones it's

00:22:18,680 --> 00:22:24,920
pretty amazing and these are the

00:22:22,790 --> 00:22:27,740
references and helping me inspiring me

00:22:24,920 --> 00:22:29,570
to do this talk it has the link

00:22:27,740 --> 00:22:31,790
that I'm gonna put I'm gonna post the

00:22:29,570 --> 00:22:37,000
slides on the Twitter you're gonna check

00:22:31,790 --> 00:22:37,000
it out there aim that's it thank you

00:22:39,670 --> 00:22:45,290
Thank You Vanessa for your talk it was

00:22:42,770 --> 00:22:47,270
very interesting to confirm it appears

00:22:45,290 --> 00:22:50,150
that Q objects can handle nested

00:22:47,270 --> 00:22:52,970
parentheses if this is the case have you

00:22:50,150 --> 00:22:56,120
used Q objects to create complex filters

00:22:52,970 --> 00:22:58,220
inside a DRF theoretically this would

00:22:56,120 --> 00:23:12,650
allow complex filtering on the API

00:22:58,220 --> 00:23:15,680
endpoints thanks again okay can you

00:23:12,650 --> 00:23:21,500
confirm that the Q object can handle

00:23:15,680 --> 00:23:25,910
nested parentheses so a group inside of

00:23:21,500 --> 00:23:29,510
a group for example yeah you can debug

00:23:25,910 --> 00:23:32,000
this with a doc query if you want to see

00:23:29,510 --> 00:23:34,310
the I scroll the output okay that's cool

00:23:32,000 --> 00:23:39,110
now the second part have you used Q

00:23:34,310 --> 00:23:45,680
objects using Django rest framework yeah

00:23:39,110 --> 00:23:51,350
but I'm not to proficient with that but

00:23:45,680 --> 00:23:55,610
I use it but it's it works normally just

00:23:51,350 --> 00:23:59,570
as I'm using juggle okay if we have if

00:23:55,610 --> 00:24:04,790
you have any specific scenario we can

00:23:59,570 --> 00:24:07,370
talk after okay thank you thank you I

00:24:04,790 --> 00:24:16,700
have a question about the extract he

00:24:07,370 --> 00:24:21,290
returned an integer are you talking

00:24:16,700 --> 00:24:25,220
about it for the double yes I'm not sure

00:24:21,290 --> 00:24:29,450
okay I'm not sure I'd use it post words

00:24:25,220 --> 00:24:35,680
before to make this examples but I think

00:24:29,450 --> 00:24:35,680
that my skull works the same way

00:24:40,910 --> 00:24:48,870
all right do we have any others no okay

00:24:47,130 --> 00:24:49,260
in which case can we thank Vanessa once

00:24:48,870 --> 00:24:52,670
again

00:24:49,260 --> 00:25:05,969
[Applause]

00:24:52,670 --> 00:25:05,969

YouTube URL: https://www.youtube.com/watch?v=a-sfr6y_hY8


