Title: DjangoCon US 2018 - Django REST Framework: Moving Past the Tutorial to Production by Drew Winstel
Publication date: 2018-11-08
Playlist: DjangoCon US 2018
Description: 
	DjangoCon US 2018 - Django REST Framework: Moving Past the Tutorial to Production by Drew Winstel

So youâ€™ve made your first attempt at creating a DRF API, but now you need to figure out how to put the hair on the proverbial pony. You want to make things easier on your client developers so they can get exactly what they need. Iâ€™ll walk through things that made our lives better developing a Django REST Framework API serving a React frontend.

Iâ€™ll include optimizations such as embedding related fields into serializers, using different serializers for different users and use cases (HTTP methods), and using DRFâ€™s actions decorator to provide easy access to related tasks. Iâ€™ll also touch on some third-party libraries that made life way easier, such as rest-framework-filters, django-rest-swagger, and django-simple-history.

This talk was presented at: https://2018.djangocon.us/talk/django-rest-framework-moving-past-the-to/

LINKS:
Follow Drew Winstel ðŸ‘‡
On Twitter: https://twitter.com/hops_and_smoke
Official homepage: https://github.com/drewbrew/

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:16,580 --> 00:00:21,900
morning everyone and welcome to my first

00:00:18,930 --> 00:00:23,699
ever conference talk today I'll be

00:00:21,900 --> 00:00:24,900
talking about moving Django rest

00:00:23,699 --> 00:00:27,359
framework from the tutorial to

00:00:24,900 --> 00:00:28,439
production Jake at rest framework great

00:00:27,359 --> 00:00:30,510
piece of software but it's a bit of a

00:00:28,439 --> 00:00:34,070
mouthful so I'm just gonna say DRF from

00:00:30,510 --> 00:00:36,329
here on out so why are we here today

00:00:34,070 --> 00:00:37,920
what's the goal behind the presentation

00:00:36,329 --> 00:00:41,070
are you here just to see me do a song

00:00:37,920 --> 00:00:44,280
and dance too bad you're all in the

00:00:41,070 --> 00:00:47,010
wrong room you've made your first debit

00:00:44,280 --> 00:00:48,149
creating a DRF API but what's next you

00:00:47,010 --> 00:00:49,230
want to make things easier on your

00:00:48,149 --> 00:00:51,660
client developer so they can get

00:00:49,230 --> 00:00:52,920
actually the data they want I'm here to

00:00:51,660 --> 00:00:55,350
show you the things that help me and my

00:00:52,920 --> 00:00:56,640
team move from the DRF tutorial into

00:00:55,350 --> 00:00:59,879
production while converting a homegrown

00:00:56,640 --> 00:01:02,460
PHP stack into a DRF and react excuse me

00:00:59,879 --> 00:01:03,750
a drf into react web app I'm not here to

00:01:02,460 --> 00:01:05,760
authoritative Lee say this is the only

00:01:03,750 --> 00:01:09,420
way to get things done but it works for

00:01:05,760 --> 00:01:11,369
me so by now you've probably seen jokes

00:01:09,420 --> 00:01:14,549
like this on the web before how to draw

00:01:11,369 --> 00:01:17,939
a horse step 1

00:01:14,549 --> 00:01:21,479
draw two circles step two draw the legs

00:01:17,939 --> 00:01:23,460
step three draw the face and step four

00:01:21,479 --> 00:01:26,580
draw the hair step 5

00:01:23,460 --> 00:01:27,900
add small details well today I'm gonna

00:01:26,580 --> 00:01:29,070
help you put some of those small details

00:01:27,900 --> 00:01:32,549
into your project to help you move

00:01:29,070 --> 00:01:34,380
towards production so a little bit of

00:01:32,549 --> 00:01:36,030
assumptions I'm assuming that you at

00:01:34,380 --> 00:01:38,490
least have a basic familiarity with DRF

00:01:36,030 --> 00:01:40,350
terminology and you've at least touched

00:01:38,490 --> 00:01:43,799
Jenga filter and how it works with DRF

00:01:40,350 --> 00:01:45,689
if you were at fills API driven dude API

00:01:43,799 --> 00:01:49,200
driven Django tutorial on Sunday you'll

00:01:45,689 --> 00:01:50,250
be fine so here's a quick overview about

00:01:49,200 --> 00:01:52,560
what I'll be talking today I'll

00:01:50,250 --> 00:01:54,329
introduce myself talk about making the

00:01:52,560 --> 00:01:55,649
API is nice for end-users and talk about

00:01:54,329 --> 00:01:58,979
a couple useful libraries for

00:01:55,649 --> 00:02:01,229
documentation before I get started a

00:01:58,979 --> 00:02:02,729
couple quick notes if you have questions

00:02:01,229 --> 00:02:04,590
but you see your little camera-shy you

00:02:02,729 --> 00:02:05,969
don't want your voice recorded that's

00:02:04,590 --> 00:02:07,920
fine I understand that feeling entirely

00:02:05,969 --> 00:02:11,190
you can either use that link up at the

00:02:07,920 --> 00:02:13,200
top of the slide or even send it slack

00:02:11,190 --> 00:02:16,110
DM or Twitter message to Russ or

00:02:13,200 --> 00:02:19,860
first chair he is apt freak-boy 3742

00:02:16,110 --> 00:02:21,660
that's freak-boy 374 2 on both Twitter

00:02:19,860 --> 00:02:24,540
and slack and he will have you to ask

00:02:21,660 --> 00:02:26,190
for you and I also just tweeted out that

00:02:24,540 --> 00:02:28,260
blink a few minutes ago you can find me

00:02:26,190 --> 00:02:29,970
on Twitter at hops and smoke like any

00:02:28,260 --> 00:02:35,220
good Python developer that's in snake

00:02:29,970 --> 00:02:36,660
case so here's a rough overview of how I

00:02:35,220 --> 00:02:38,489
got to where I am today in front of you

00:02:36,660 --> 00:02:40,799
I've had about four years of DRF

00:02:38,489 --> 00:02:42,360
experience starting way back when South

00:02:40,799 --> 00:02:44,819
migrations were still a thing it wasn't

00:02:42,360 --> 00:02:47,849
built into Django yet and kept going all

00:02:44,819 --> 00:02:49,200
the way through Django 2.0 my degree is

00:02:47,849 --> 00:02:52,680
in Wireless and electrical engineering

00:02:49,200 --> 00:02:54,120
from Auburn War Eagle in 2008 I've done

00:02:52,680 --> 00:02:56,250
a mix of Defense and Internet of Things

00:02:54,120 --> 00:02:57,780
work and before since then before coming

00:02:56,250 --> 00:03:00,030
to Rackspace where I've been since June

00:02:57,780 --> 00:03:03,840
this year where I'm developing REST API

00:03:00,030 --> 00:03:05,720
is using flask and MongoDB and I got

00:03:03,840 --> 00:03:08,069
code up on github and get lab already

00:03:05,720 --> 00:03:10,110
you can find me there and I'll take a

00:03:08,069 --> 00:03:12,690
look at the example code we burn from

00:03:10,110 --> 00:03:14,340
learn read rip sorry read it and

00:03:12,690 --> 00:03:17,099
hopefully learn from it no guarantees

00:03:14,340 --> 00:03:21,530
and as I mentioned I'm on Twitter also

00:03:17,099 --> 00:03:23,880
on Mastodon as well so a quick recap

00:03:21,530 --> 00:03:25,769
serializers these are probably the most

00:03:23,880 --> 00:03:27,569
powerful thing in drf it's wonderful

00:03:25,769 --> 00:03:28,950
they're responsible for converting your

00:03:27,569 --> 00:03:30,750
data between the Django instances you

00:03:28,950 --> 00:03:32,340
know and love and then formats we could

00:03:30,750 --> 00:03:34,620
easily transfer it over the web like

00:03:32,340 --> 00:03:36,030
JSON XML or you can write your own

00:03:34,620 --> 00:03:38,549
renderers if you really feel like doing

00:03:36,030 --> 00:03:40,049
something unusual they delegate that

00:03:38,549 --> 00:03:41,819
responsibility to the individual fields

00:03:40,049 --> 00:03:44,220
which are defined in the Senor serialize

00:03:41,819 --> 00:03:46,109
er classes they use the two internal

00:03:44,220 --> 00:03:48,120
value and to representation methods to

00:03:46,109 --> 00:03:52,019
convert to and from serializable types

00:03:48,120 --> 00:03:53,549
respectively on the Left it's a JSON

00:03:52,019 --> 00:03:55,079
submitted from a client it's been

00:03:53,549 --> 00:03:57,239
converted to a Python dictionary by the

00:03:55,079 --> 00:03:59,519
view set it has a date in a couple of

00:03:57,239 --> 00:04:01,889
decimal objects a quick tip if you're

00:03:59,519 --> 00:04:03,239
using a coordinates in your methods in

00:04:01,889 --> 00:04:05,400
your models but don't actually have geo

00:04:03,239 --> 00:04:07,290
Django installed make sure you save them

00:04:05,400 --> 00:04:10,139
as decimal fields otherwise you'll lose

00:04:07,290 --> 00:04:13,130
data to rounding errors my the previous

00:04:10,139 --> 00:04:15,810
database found that out the hard way and

00:04:13,130 --> 00:04:17,070
also JSON does not have a decimal object

00:04:15,810 --> 00:04:21,450
which is why you see them as strings in

00:04:17,070 --> 00:04:23,460
there and then this is what the results

00:04:21,450 --> 00:04:25,830
from the validated data valid ated data

00:04:23,460 --> 00:04:27,629
property of the serializer

00:04:25,830 --> 00:04:29,520
as you can see the serializer has

00:04:27,629 --> 00:04:32,550
converted the date into a date time date

00:04:29,520 --> 00:04:35,280
object and the two decimal strings into

00:04:32,550 --> 00:04:36,870
a Python decimal objects then the

00:04:35,280 --> 00:04:38,669
serializers use either the create or

00:04:36,870 --> 00:04:42,689
update method to save those fields into

00:04:38,669 --> 00:04:44,939
the database using your Django models so

00:04:42,689 --> 00:04:47,610
two internal value like I mentioned take

00:04:44,939 --> 00:04:49,740
serializable types like numbers and

00:04:47,610 --> 00:04:53,009
strings and turns them into Python types

00:04:49,740 --> 00:04:54,449
like date times decimals you name it you

00:04:53,009 --> 00:04:56,340
can build us a translator for it and

00:04:54,449 --> 00:04:59,039
then there's two representation which

00:04:56,340 --> 00:05:01,229
does the same thing only in Reverse then

00:04:59,039 --> 00:05:03,240
DRF serializers say that data using

00:05:01,229 --> 00:05:04,800
create and update typically you won't

00:05:03,240 --> 00:05:06,180
have to modify the DS unless you're

00:05:04,800 --> 00:05:06,870
modifying multiple models in the same

00:05:06,180 --> 00:05:08,190
serializer

00:05:06,870 --> 00:05:12,210
which I'm going to demonstrate a little

00:05:08,190 --> 00:05:13,740
bit later the few sets are extremely

00:05:12,210 --> 00:05:15,840
powerful accommodations of generic

00:05:13,740 --> 00:05:18,870
classes that provides general-purpose

00:05:15,840 --> 00:05:21,650
methods for basic API access you get off

00:05:18,870 --> 00:05:24,150
access control query set generation

00:05:21,650 --> 00:05:25,919
serializer selection and filtering all

00:05:24,150 --> 00:05:29,699
just by providing class attributes like

00:05:25,919 --> 00:05:31,949
these if your first exposure to DRF was

00:05:29,699 --> 00:05:33,900
Phil's tutorial on Sunday just combine

00:05:31,949 --> 00:05:35,520
the list in detail view generic classes

00:05:33,900 --> 00:05:36,900
that you used are in that tutorial and

00:05:35,520 --> 00:05:40,319
that gives you the concept behind a view

00:05:36,900 --> 00:05:42,150
set it also includes this very simple

00:05:40,319 --> 00:05:44,669
create retrieve update and destroy

00:05:42,150 --> 00:05:46,110
actions that are known as crud that will

00:05:44,669 --> 00:05:49,650
serve the majority of you needs really

00:05:46,110 --> 00:05:51,779
well so quick reek so let's talk about

00:05:49,650 --> 00:05:53,099
what it does in detail after

00:05:51,779 --> 00:05:54,569
authenticating the user the view sets

00:05:53,099 --> 00:05:57,389
first task is to call each permission

00:05:54,569 --> 00:05:59,460
classes has permission method if any of

00:05:57,389 --> 00:06:01,199
these methods don't return true the

00:05:59,460 --> 00:06:04,650
request stops and returns a 403

00:06:01,199 --> 00:06:06,089
forbidden next up the view set will

00:06:04,650 --> 00:06:08,190
refresh the query set like calling dot

00:06:06,089 --> 00:06:10,379
all on this attribute if it's looking

00:06:08,190 --> 00:06:11,759
for a specific object like you know if

00:06:10,379 --> 00:06:13,830
we're doing an update or a retrieve

00:06:11,759 --> 00:06:15,599
action then the view set will also call

00:06:13,830 --> 00:06:17,039
each permission classes has object

00:06:15,599 --> 00:06:18,779
permission on that out with that object

00:06:17,039 --> 00:06:23,099
as an argument that's another chance for

00:06:18,779 --> 00:06:24,810
a 403 forbidden to fall out in the case

00:06:23,099 --> 00:06:26,279
of list actions the view set will then

00:06:24,810 --> 00:06:28,169
pass the query through the films each

00:06:26,279 --> 00:06:29,909
filter back and you specified which

00:06:28,169 --> 00:06:32,159
modifies the query set appropriately if

00:06:29,909 --> 00:06:34,050
you if like me you're using the Django

00:06:32,159 --> 00:06:37,080
filter back-end which you probably will

00:06:34,050 --> 00:06:39,580
be the Django filter back and looks up

00:06:37,080 --> 00:06:43,509
the filter class I'll attribute and

00:06:39,580 --> 00:06:45,849
uses that to modify the query set next

00:06:43,509 --> 00:06:48,159
up the view set passes the query set

00:06:45,849 --> 00:06:49,900
results into the serializer class which

00:06:48,159 --> 00:06:51,939
converts from complex data types into

00:06:49,900 --> 00:06:53,289
easily serializable types which you'll

00:06:51,939 --> 00:06:57,310
remember there are things like strings

00:06:53,289 --> 00:06:58,750
numbers boolean x' and null and if

00:06:57,310 --> 00:07:00,460
you're using a list route it'll feed the

00:06:58,750 --> 00:07:02,500
pageant pagination class into the

00:07:00,460 --> 00:07:03,849
serializer so it only has to serialize a

00:07:02,500 --> 00:07:05,439
subset of the query settings

00:07:03,849 --> 00:07:10,060
assuming you have more results than your

00:07:05,439 --> 00:07:11,680
pagination allows in this talk I'm gonna

00:07:10,060 --> 00:07:13,539
use some horribly horribly contrived set

00:07:11,680 --> 00:07:14,979
clinic examples this has nothing to do

00:07:13,539 --> 00:07:16,659
with the market that our app was working

00:07:14,979 --> 00:07:19,629
in it just a convenient excuse for

00:07:16,659 --> 00:07:21,370
animal pictures so please enjoy this is

00:07:19,629 --> 00:07:23,860
sassy she was my grandparents half black

00:07:21,370 --> 00:07:25,240
lab half Rottweiler she wouldn't ever be

00:07:23,860 --> 00:07:26,770
caught dead without a toy in her hands

00:07:25,240 --> 00:07:30,430
in her mouth at any time she's probably

00:07:26,770 --> 00:07:32,560
the sweetest dog ever could have met so

00:07:30,430 --> 00:07:36,340
what do I mean by making the API client

00:07:32,560 --> 00:07:37,930
friendly it's about knowing your users

00:07:36,340 --> 00:07:39,939
if you're working with end users

00:07:37,930 --> 00:07:41,860
accessing your data via web or a mobile

00:07:39,939 --> 00:07:43,180
app speed is usually far more of a

00:07:41,860 --> 00:07:45,279
concern than just if you're dealing with

00:07:43,180 --> 00:07:47,169
automated services where the extra

00:07:45,279 --> 00:07:50,110
second delay for getting all the data at

00:07:47,169 --> 00:07:52,360
once it is worth a while but for mobile

00:07:50,110 --> 00:07:54,849
apps especially speed is so important

00:07:52,360 --> 00:07:56,409
that an extra delay of say a second

00:07:54,849 --> 00:07:58,000
while fetching data is the difference

00:07:56,409 --> 00:07:58,779
between a four star and two star rating

00:07:58,000 --> 00:08:03,669
in the app stores

00:07:58,779 --> 00:08:05,560
nobody wants a bad rating so I'm talking

00:08:03,669 --> 00:08:07,029
about related fields there's a problem

00:08:05,560 --> 00:08:09,430
you'll always run into and dealing with

00:08:07,029 --> 00:08:12,039
information transfer your model of the

00:08:09,430 --> 00:08:14,050
data never matches what your users how

00:08:12,039 --> 00:08:16,389
you to see the data not a bad thing it's

00:08:14,050 --> 00:08:18,639
just a fact of life your users care

00:08:16,389 --> 00:08:20,469
about different things than you do for

00:08:18,639 --> 00:08:22,509
example in a vet clinic your user only

00:08:20,469 --> 00:08:25,599
cares that slide I was a black lab not

00:08:22,509 --> 00:08:26,979
that he is breed ID 42 how do we

00:08:25,599 --> 00:08:30,069
simultaneously give the user the

00:08:26,979 --> 00:08:31,330
information she needs black lab and the

00:08:30,069 --> 00:08:35,169
information she needs in case you needs

00:08:31,330 --> 00:08:38,409
to update things later breed ID 42 we

00:08:35,169 --> 00:08:39,849
use nested serializers so here's a

00:08:38,409 --> 00:08:41,890
trivial example of how you embed those

00:08:39,849 --> 00:08:43,870
into the serializer you can just call

00:08:41,890 --> 00:08:44,769
the serializer and then DRF will take

00:08:43,870 --> 00:08:48,790
care of the rest

00:08:44,769 --> 00:08:51,290
forget operations but wait

00:08:48,790 --> 00:08:54,020
remember how I only said get requests

00:08:51,290 --> 00:08:55,190
drf documentation specifically says they

00:08:54,020 --> 00:08:56,990
don't provide an implementation for

00:08:55,190 --> 00:09:00,500
saving serializers with writable nested

00:08:56,990 --> 00:09:02,690
fields so how do we work around that by

00:09:00,500 --> 00:09:07,580
the way that is my dog Henry he's a half

00:09:02,690 --> 00:09:10,070
Corgi half something he was badly abused

00:09:07,580 --> 00:09:11,330
as a puppy left outside and he during

00:09:10,070 --> 00:09:15,020
those terrific tornadoes that came

00:09:11,330 --> 00:09:16,400
through Alabama in 2011 horribly afraid

00:09:15,020 --> 00:09:18,620
of people it took almost a year before I

00:09:16,400 --> 00:09:20,540
could pet him but with my three-year-old

00:09:18,620 --> 00:09:23,540
daughter he's like her best friend ever

00:09:20,540 --> 00:09:24,590
so it's kind of fun of course she drops

00:09:23,540 --> 00:09:28,670
food all the time so that makes it

00:09:24,590 --> 00:09:30,920
easier now you're not gonna like this

00:09:28,670 --> 00:09:33,620
part there is no single right answer for

00:09:30,920 --> 00:09:35,120
all use cases you've got three really

00:09:33,620 --> 00:09:37,520
viable options for handling updated

00:09:35,120 --> 00:09:38,720
related data you can either override the

00:09:37,520 --> 00:09:41,000
create and update methods and the

00:09:38,720 --> 00:09:42,440
serialize or the host relationship such

00:09:41,000 --> 00:09:45,140
as the Breen sterilizer hosting the

00:09:42,440 --> 00:09:46,970
species relationship or you could create

00:09:45,140 --> 00:09:50,000
a separate write only field like species

00:09:46,970 --> 00:09:51,980
ID or last you could create a separate

00:09:50,000 --> 00:09:53,630
field entirely to describe the

00:09:51,980 --> 00:09:57,410
relationship we actually build a field

00:09:53,630 --> 00:10:00,290
class you choose option one over writing

00:09:57,410 --> 00:10:01,460
create an update you use this if you're

00:10:00,290 --> 00:10:02,600
most like users are most likely to

00:10:01,460 --> 00:10:05,240
create new data rather than updating

00:10:02,600 --> 00:10:06,620
existing data how do you have to cue a

00:10:05,240 --> 00:10:09,380
few questions to answer though number

00:10:06,620 --> 00:10:11,270
one how does the user create data the

00:10:09,380 --> 00:10:14,060
easy answer you post a dictionary

00:10:11,270 --> 00:10:15,170
without a primary key should the next

00:10:14,060 --> 00:10:17,600
question is should the user be allowed

00:10:15,170 --> 00:10:18,890
to update existing data if the data in

00:10:17,600 --> 00:10:20,210
that related dictionary does not match

00:10:18,890 --> 00:10:22,580
what's in the database for the object

00:10:20,210 --> 00:10:24,620
you can say yes you can say no either

00:10:22,580 --> 00:10:26,960
way is fine just make sure you document

00:10:24,620 --> 00:10:29,420
it and be extremely firm and consistent

00:10:26,960 --> 00:10:30,680
with your decision so don't have one

00:10:29,420 --> 00:10:32,000
endpoint where you can update things and

00:10:30,680 --> 00:10:33,260
one where you can't that will just

00:10:32,000 --> 00:10:39,080
confuse your users and make everyone

00:10:33,260 --> 00:10:40,850
miserable so the create method it way is

00:10:39,080 --> 00:10:42,320
basic for freely totally simple you have

00:10:40,850 --> 00:10:45,860
to pull out the Related field and look

00:10:42,320 --> 00:10:47,360
up the source data let's dig in first

00:10:45,860 --> 00:10:48,980
thing we do is we pull out the Related

00:10:47,360 --> 00:10:50,330
object which will be a Python dictionary

00:10:48,980 --> 00:10:51,950
you don't have to worry about the

00:10:50,330 --> 00:10:53,660
related object being missing because the

00:10:51,950 --> 00:10:55,160
DRF validation will return a 400 bad

00:10:53,660 --> 00:10:56,570
request before this code even runs if

00:10:55,160 --> 00:10:58,640
it's missing because we said required

00:10:56,570 --> 00:11:02,630
because we did not look specified as an

00:10:58,640 --> 00:11:05,300
optional field next we've got to handle

00:11:02,630 --> 00:11:07,850
that related object if it's a new object

00:11:05,300 --> 00:11:09,890
we need to create it if you have nested

00:11:07,850 --> 00:11:10,730
fields inside those nested fields first

00:11:09,890 --> 00:11:12,500
of all I'm sorry

00:11:10,730 --> 00:11:14,120
second of all you have to go into that

00:11:12,500 --> 00:11:16,190
serializer and handle those related

00:11:14,120 --> 00:11:17,330
fields you can call that serial icers

00:11:16,190 --> 00:11:19,820
create method where I just called

00:11:17,330 --> 00:11:21,380
species object stop create you don't

00:11:19,820 --> 00:11:22,760
know also then note that you don't have

00:11:21,380 --> 00:11:24,800
to manually validate there's serialize

00:11:22,760 --> 00:11:28,850
related object DRF took care of that for

00:11:24,800 --> 00:11:29,839
you already you also have a big design

00:11:28,850 --> 00:11:31,790
decision to make here

00:11:29,839 --> 00:11:33,470
what happens if the user provides the

00:11:31,790 --> 00:11:35,149
related that the data the user provides

00:11:33,470 --> 00:11:37,310
for the related object does not match

00:11:35,149 --> 00:11:38,990
what's already in the database you can

00:11:37,310 --> 00:11:41,660
either reject the request give them a

00:11:38,990 --> 00:11:43,820
400 bad request or you can implicitly

00:11:41,660 --> 00:11:45,649
update the related data both options

00:11:43,820 --> 00:11:46,940
have their pros and cons just make sure

00:11:45,649 --> 00:11:48,830
you document you to the design decision

00:11:46,940 --> 00:11:50,540
extremely well also if you're a fan of

00:11:48,830 --> 00:11:52,220
functional programming you'll hate the

00:11:50,540 --> 00:11:53,660
sight of tech late option late the site

00:11:52,220 --> 00:11:55,490
if I claim the option of you updating

00:11:53,660 --> 00:12:01,760
the related models and you're probably

00:11:55,490 --> 00:12:03,470
cringing right now and then lastly we

00:12:01,760 --> 00:12:05,510
have to just drop that Django model

00:12:03,470 --> 00:12:07,610
instance with back into the validated

00:12:05,510 --> 00:12:08,990
data dictionary and pass it to the DRF

00:12:07,610 --> 00:12:13,250
base implementation worry I'll take care

00:12:08,990 --> 00:12:15,020
of saving everything the update method

00:12:13,250 --> 00:12:16,310
is pretty much the same as create but we

00:12:15,020 --> 00:12:18,440
have to consider blood edge one case

00:12:16,310 --> 00:12:19,820
where the user does a patch where you

00:12:18,440 --> 00:12:21,410
don't have to include the entire body of

00:12:19,820 --> 00:12:24,320
the object in the inner when you're

00:12:21,410 --> 00:12:26,839
submitting to a request so just pop it

00:12:24,320 --> 00:12:28,370
out first and use a data that you set

00:12:26,839 --> 00:12:30,350
value that's completely invalid if it's

00:12:28,370 --> 00:12:34,160
not present like I used false there for

00:12:30,350 --> 00:12:36,740
example and then if it's actually that

00:12:34,160 --> 00:12:38,120
that is that note that bogus value just

00:12:36,740 --> 00:12:39,500
turn it return it upstream let upstream

00:12:38,120 --> 00:12:41,480
do its thing it's easier that way than

00:12:39,500 --> 00:12:45,649
writing it yourself other than that it

00:12:41,480 --> 00:12:47,899
is exactly the same as update now the

00:12:45,649 --> 00:12:52,160
option to is creating a separate write

00:12:47,899 --> 00:12:53,839
only field this requires firm agreement

00:12:52,160 --> 00:12:56,510
with your API clients that what you

00:12:53,839 --> 00:12:58,730
receive via get as a user is not what

00:12:56,510 --> 00:13:00,410
you post or put and that's the

00:12:58,730 --> 00:13:02,839
convention I've seen in a lot of api's

00:13:00,410 --> 00:13:05,000
where you know you could take the result

00:13:02,839 --> 00:13:06,529
of a get and put that into a foot and it

00:13:05,000 --> 00:13:08,570
will just work and being a completely

00:13:06,529 --> 00:13:10,760
you know no operation blood it but it is

00:13:08,570 --> 00:13:12,980
valid operation this breaks that

00:13:10,760 --> 00:13:16,040
convention it's not a huge deal you just

00:13:12,980 --> 00:13:17,870
have to documented thoroughly and show

00:13:16,040 --> 00:13:19,220
good examples in the documentation and

00:13:17,870 --> 00:13:20,839
then if your users complain about

00:13:19,220 --> 00:13:24,319
point to the docks and say hey you

00:13:20,839 --> 00:13:25,579
didn't read them that's on you it's not

00:13:24,319 --> 00:13:27,319
the end of the world just a caveat you

00:13:25,579 --> 00:13:28,850
have to be aware of and then you'll also

00:13:27,319 --> 00:13:31,000
have to write a very small validate

00:13:28,850 --> 00:13:33,949
method which I'll show in a moment in

00:13:31,000 --> 00:13:35,600
this option is pretty simple first you

00:13:33,949 --> 00:13:37,790
define two separate fields the read only

00:13:35,600 --> 00:13:39,139
um explain to serialize ER just like in

00:13:37,790 --> 00:13:41,930
the previous just like in the read-only

00:13:39,139 --> 00:13:44,120
version and then secondly you use a

00:13:41,930 --> 00:13:46,699
write only primary key related field

00:13:44,120 --> 00:13:48,019
this fields to internal value method

00:13:46,699 --> 00:13:49,430
looks up the object using the given

00:13:48,019 --> 00:13:51,889
query given query set also does

00:13:49,430 --> 00:13:55,220
validation and then returns an instance

00:13:51,889 --> 00:13:56,720
of the model being looked up remember

00:13:55,220 --> 00:13:57,920
that I said it returns an instance of

00:13:56,720 --> 00:14:00,800
their later model that's important

00:13:57,920 --> 00:14:02,870
because if you try and save it as is the

00:14:00,800 --> 00:14:04,459
Jango arm will barf at you because

00:14:02,870 --> 00:14:06,769
you're trying to save an instance to a

00:14:04,459 --> 00:14:08,089
field the under the ID field where Jango

00:14:06,769 --> 00:14:11,240
is expecting a primary key like an

00:14:08,089 --> 00:14:13,550
integer or UID working around that is

00:14:11,240 --> 00:14:15,500
very simple all you have to do is just

00:14:13,550 --> 00:14:16,209
move the species ID into the species key

00:14:15,500 --> 00:14:18,379
in the dictionary

00:14:16,209 --> 00:14:20,720
after that DRF takes care of everything

00:14:18,379 --> 00:14:22,519
for us sorry we're letting this is the

00:14:20,720 --> 00:14:23,660
option that we chose to use in our API

00:14:22,519 --> 00:14:26,959
that we pre dough forward to production

00:14:23,660 --> 00:14:29,089
because our primary front end was in our

00:14:26,959 --> 00:14:32,779
in-house web developer so your mileage

00:14:29,089 --> 00:14:33,980
may vary and then one thing I would

00:14:32,779 --> 00:14:37,129
point out that may not be readable in

00:14:33,980 --> 00:14:39,709
the back you even though we set species

00:14:37,129 --> 00:14:40,879
ID is required in the serializer it is

00:14:39,709 --> 00:14:43,970
possible for that to be missing in our

00:14:40,879 --> 00:14:45,559
body in the case of patches again so all

00:14:43,970 --> 00:14:46,730
that means we have to do is handle the

00:14:45,559 --> 00:14:48,439
case where it didn't provide the species

00:14:46,730 --> 00:14:50,689
ID by just doing a try and catch on it

00:14:48,439 --> 00:14:52,100
you can you'll be fine ignoring this

00:14:50,689 --> 00:14:54,110
error and moving on unless you really

00:14:52,100 --> 00:14:55,519
like making users miserable in which

00:14:54,110 --> 00:14:57,019
case why are you developing api's

00:14:55,519 --> 00:15:02,809
shouldn't you be forcing them to write

00:14:57,019 --> 00:15:04,009
the HTML scrapers instead so creating a

00:15:02,809 --> 00:15:05,990
separate relationship field the third

00:15:04,009 --> 00:15:07,160
option is nice because it doesn't

00:15:05,990 --> 00:15:08,629
require your clients to use a separate

00:15:07,160 --> 00:15:10,779
field for sending versus receiving of

00:15:08,629 --> 00:15:13,279
data but it has its own trade-offs you

00:15:10,779 --> 00:15:15,680
can accept a primary key or a dictionary

00:15:13,279 --> 00:15:17,569
of the data type coming in but if you

00:15:15,680 --> 00:15:19,759
set the primary key you prevent the user

00:15:17,569 --> 00:15:21,110
from creating new data or if you do

00:15:19,759 --> 00:15:22,370
accept a dictionary you have to handle

00:15:21,110 --> 00:15:25,189
the same question as an overriding

00:15:22,370 --> 00:15:26,870
update and create if you get a primary

00:15:25,189 --> 00:15:28,730
key of existing listenings do you update

00:15:26,870 --> 00:15:31,250
that you create a new object or you do

00:15:28,730 --> 00:15:33,050
you return 400 bad request and you can

00:15:31,250 --> 00:15:34,160
create a you feel that does both

00:15:33,050 --> 00:15:36,320
using this statement to switch back and

00:15:34,160 --> 00:15:39,310
forth but again you have to be clear

00:15:36,320 --> 00:15:39,310
with your users about what'll happen

00:15:39,580 --> 00:15:45,220
okay that's all great but this means you

00:15:43,610 --> 00:15:47,360
have to do extra database lookups right

00:15:45,220 --> 00:15:48,950
as you probably know you need to use

00:15:47,360 --> 00:15:51,380
select related and/or prefetch related

00:15:48,950 --> 00:15:52,760
to look up extra data however it might

00:15:51,380 --> 00:15:54,170
not make ups it make sense to dump

00:15:52,760 --> 00:15:55,670
everything you're looking at a list

00:15:54,170 --> 00:15:57,440
route particularly when you're dealing

00:15:55,670 --> 00:15:59,060
with lots of data like I had one

00:15:57,440 --> 00:16:00,529
endpoint that returned probably a

00:15:59,060 --> 00:16:02,510
hundred fields over at by the time it

00:16:00,529 --> 00:16:05,120
was done expanding everything that would

00:16:02,510 --> 00:16:07,940
take ten seconds to return 200 entries

00:16:05,120 --> 00:16:10,010
in a list room list route how do we deal

00:16:07,940 --> 00:16:11,570
with this we use separate serializers

00:16:10,010 --> 00:16:13,970
for lists in detail routes and queries

00:16:11,570 --> 00:16:15,709
to match that's all these penguins at

00:16:13,970 --> 00:16:17,600
the Lincoln Park Zoo last month in

00:16:15,709 --> 00:16:19,220
Chicago it's an eight little zoo it's

00:16:17,600 --> 00:16:21,050
the little one small side but it had the

00:16:19,220 --> 00:16:24,160
upside at being free to enter which is

00:16:21,050 --> 00:16:24,160
great when you're going with five kids

00:16:24,490 --> 00:16:29,839
well yes no for a single related object

00:16:27,500 --> 00:16:32,209
you know there's select related it's

00:16:29,839 --> 00:16:35,540
pretty much almost free the only cost is

00:16:32,209 --> 00:16:36,769
SQL join it's much faster than doing a

00:16:35,540 --> 00:16:38,630
second database lookup unless your

00:16:36,769 --> 00:16:39,709
tables they're horribly misconfigured in

00:16:38,630 --> 00:16:40,940
which case you may need to go talk to

00:16:39,709 --> 00:16:43,550
the Postgres people out there they can

00:16:40,940 --> 00:16:45,290
might be able to help you I can't if

00:16:43,550 --> 00:16:46,910
you're a traversing a many minute mini

00:16:45,290 --> 00:16:49,220
relationship or looking across a reverse

00:16:46,910 --> 00:16:50,660
foreign key lookup then you need to use

00:16:49,220 --> 00:16:53,209
prefetch related to look up the data

00:16:50,660 --> 00:16:54,980
this cost is an extra database lookup

00:16:53,209 --> 00:16:57,350
and then makes Django do the merging of

00:16:54,980 --> 00:17:01,399
data in Python land if that sounds slow

00:16:57,350 --> 00:17:04,669
to you you're right but it is way faster

00:17:01,399 --> 00:17:06,890
than not using prefetch related in which

00:17:04,669 --> 00:17:08,750
case Django does one database hit her

00:17:06,890 --> 00:17:10,130
record return to the main query that's

00:17:08,750 --> 00:17:12,610
what's referred to as the n plus one

00:17:10,130 --> 00:17:14,630
problem it's the bane of many developers

00:17:12,610 --> 00:17:16,010
prefetch objects are absolutely

00:17:14,630 --> 00:17:17,540
wonderful they let you filter their

00:17:16,010 --> 00:17:19,370
later model lookup and also run select

00:17:17,540 --> 00:17:20,630
related as part of the prefetch which

00:17:19,370 --> 00:17:22,640
could save you an extra database it if

00:17:20,630 --> 00:17:23,959
you do it right but be careful with

00:17:22,640 --> 00:17:26,209
using prefetch related and make sure you

00:17:23,959 --> 00:17:29,240
cover every related field lookup if you

00:17:26,209 --> 00:17:34,429
don't things will get hairy quickly now

00:17:29,240 --> 00:17:35,390
what do I mean by that thanks to a Jeff

00:17:34,429 --> 00:17:37,400
for letting me use them as an example

00:17:35,390 --> 00:17:39,050
here I've made this mistake many times

00:17:37,400 --> 00:17:41,390
as well I just didn't have the foresight

00:17:39,050 --> 00:17:43,220
to tweet about it I don't have time to

00:17:41,390 --> 00:17:45,470
cover today but I highly highly highly

00:17:43,220 --> 00:17:46,980
recommend using tests to count the

00:17:45,470 --> 00:17:49,320
number of queries used in a pratik

00:17:46,980 --> 00:17:50,400
API test jenga's test case has the

00:17:49,320 --> 00:17:52,770
method to count the number of queries

00:17:50,400 --> 00:17:53,820
run it's easy just a good way to make

00:17:52,770 --> 00:17:57,110
sure you don't accidentally trigger a

00:17:53,820 --> 00:17:59,070
10+1 problem when you want to five you

00:17:57,110 --> 00:18:00,419
so next up we'll talk about using

00:17:59,070 --> 00:18:04,169
different serializers for different

00:18:00,419 --> 00:18:06,059
actions now you probably seen this this

00:18:04,169 --> 00:18:07,740
pattern before where you have get

00:18:06,059 --> 00:18:10,380
serializer class looking at the action

00:18:07,740 --> 00:18:12,900
of the request if it's a detail route

00:18:10,380 --> 00:18:14,940
you do you simply return the my serial

00:18:12,900 --> 00:18:16,910
detail serialize or otherwise return to

00:18:14,940 --> 00:18:21,750
list serializer this is in the view set

00:18:16,910 --> 00:18:23,250
but you know simple and obvious but what

00:18:21,750 --> 00:18:24,270
if I told you DRF provides a way to

00:18:23,250 --> 00:18:26,600
differentiate between list and

00:18:24,270 --> 00:18:28,740
sterilizer classes with one line of code

00:18:26,600 --> 00:18:31,350
this was during a road trip last year

00:18:28,740 --> 00:18:32,880
where the dogs did objected to being

00:18:31,350 --> 00:18:34,650
left in the car while we went inside to

00:18:32,880 --> 00:18:35,790
take the kids to the bathroom so they

00:18:34,650 --> 00:18:37,380
jumped they jumped over the backseat and

00:18:35,790 --> 00:18:43,410
both of them somehow fit in my kids car

00:18:37,380 --> 00:18:48,419
seat it was very fun getting them back

00:18:43,410 --> 00:18:50,610
over willingly DRF provides a very handy

00:18:48,419 --> 00:18:54,240
list serializer class attribute in the

00:18:50,610 --> 00:18:55,410
metaclass how does it work though you

00:18:54,240 --> 00:18:56,820
use the attribute in your detail

00:18:55,410 --> 00:19:00,990
serialization to point to your list

00:18:56,820 --> 00:19:03,210
serializer class here's how it works

00:19:00,990 --> 00:19:04,470
when the view set initializes they

00:19:03,210 --> 00:19:06,059
serialize their instance with many

00:19:04,470 --> 00:19:08,010
equals true as an argument

00:19:06,059 --> 00:19:10,080
the serializer will actually switch out

00:19:08,010 --> 00:19:11,669
the instance created and replace it with

00:19:10,080 --> 00:19:14,370
the class defined by that list serialize

00:19:11,669 --> 00:19:17,580
ur class attributes now wait you may be

00:19:14,370 --> 00:19:18,570
saying aren't you supposed to get again

00:19:17,580 --> 00:19:20,309
instance to the class you instantiate

00:19:18,570 --> 00:19:22,380
when you construct a class struct an

00:19:20,309 --> 00:19:24,090
instance of a class let's take a look at

00:19:22,380 --> 00:19:26,490
the DRF source code and see what happens

00:19:24,090 --> 00:19:27,960
it uses a little bit of Python magic and

00:19:26,490 --> 00:19:30,390
overrides the double underscore new

00:19:27,960 --> 00:19:32,700
method to call a different init method

00:19:30,390 --> 00:19:35,010
entirely which is too long to show here

00:19:32,700 --> 00:19:37,110
but it ultimately returns an instance of

00:19:35,010 --> 00:19:39,480
that class as list serializer classic

00:19:37,110 --> 00:19:41,640
but specified it's pretty nifty and it

00:19:39,480 --> 00:19:45,179
was a nice little um light bulb moment

00:19:41,640 --> 00:19:46,980
when I discovered this now here's the

00:19:45,179 --> 00:19:49,200
view set using a serializer that has the

00:19:46,980 --> 00:19:52,049
list serializer class defined there are

00:19:49,200 --> 00:19:53,460
two things I want to point out here when

00:19:52,049 --> 00:19:55,380
you're specifying the serialize or class

00:19:53,460 --> 00:19:57,150
attribute you want to use the detail

00:19:55,380 --> 00:19:59,730
serialize er it's a little bit

00:19:57,150 --> 00:20:00,750
counterintuitive but drf doesn't know

00:19:59,730 --> 00:20:02,700
how to go from the list here

00:20:00,750 --> 00:20:03,870
back to find little details he realized

00:20:02,700 --> 00:20:06,600
because that relationship is only a

00:20:03,870 --> 00:20:07,920
one-way relationship and then also

00:20:06,600 --> 00:20:09,570
because you have two different to your

00:20:07,920 --> 00:20:11,400
lights are showing different data you

00:20:09,570 --> 00:20:14,670
should definitely overwrite gets query

00:20:11,400 --> 00:20:18,360
set to return just the data you want and

00:20:14,670 --> 00:20:19,800
nothing else and also when you override

00:20:18,360 --> 00:20:20,910
get query set in the various and if you

00:20:19,800 --> 00:20:22,020
set this means you have control over

00:20:20,910 --> 00:20:24,930
what data is looked up for different

00:20:22,020 --> 00:20:27,090
methods it's pretty easy you know just a

00:20:24,930 --> 00:20:30,960
pic based on the method the action being

00:20:27,090 --> 00:20:32,280
chosen and go from there now in addition

00:20:30,960 --> 00:20:34,770
to changing what you do based on the

00:20:32,280 --> 00:20:37,020
HTTP action you can also change based on

00:20:34,770 --> 00:20:38,460
who's looking at your API if you have

00:20:37,020 --> 00:20:40,530
different classes of users that need

00:20:38,460 --> 00:20:42,450
different data you can over I get

00:20:40,530 --> 00:20:46,620
serialize your class and get query set

00:20:42,450 --> 00:20:47,820
to limit or expand data as needed here

00:20:46,620 --> 00:20:48,660
are the trivial serializers I'm using

00:20:47,820 --> 00:20:50,340
for this example

00:20:48,660 --> 00:20:51,720
nothing fancy I'm just extending the

00:20:50,340 --> 00:20:53,580
animal detail serializer

00:20:51,720 --> 00:20:55,890
to add an extra field that only matters

00:20:53,580 --> 00:21:00,210
to staff just a just an appointment

00:20:55,890 --> 00:21:01,560
serializer there is excuse me a lot to

00:21:00,210 --> 00:21:03,060
go through here so I'm gonna break it

00:21:01,560 --> 00:21:04,470
into a couple of chunks I just wanted to

00:21:03,060 --> 00:21:07,710
show it also you can get quick glance as

00:21:04,470 --> 00:21:09,690
to how it interacts so here is get

00:21:07,710 --> 00:21:13,260
serializer class only at a readable zoom

00:21:09,690 --> 00:21:15,720
level it's a pretty simple just check to

00:21:13,260 --> 00:21:17,070
see if a user has permission remember

00:21:15,720 --> 00:21:19,230
that you defined those at the model

00:21:17,070 --> 00:21:21,240
level and then if the user has the

00:21:19,230 --> 00:21:23,400
permission in question you give them the

00:21:21,240 --> 00:21:25,170
explain of serializer otherwise you fall

00:21:23,400 --> 00:21:26,970
back through to the normal DRF of

00:21:25,170 --> 00:21:29,070
limitation which is just refreshing that

00:21:26,970 --> 00:21:33,680
all from this here from the query side

00:21:29,070 --> 00:21:35,790
attribute and then here is get query set

00:21:33,680 --> 00:21:38,220
sorry that was get serialize or class

00:21:35,790 --> 00:21:40,320
not get query set my dad and then here

00:21:38,220 --> 00:21:41,120
is get query set only slightly more

00:21:40,320 --> 00:21:43,440
readable

00:21:41,120 --> 00:21:45,270
now here's what you do is you can look

00:21:43,440 --> 00:21:46,800
do the permission check and make

00:21:45,270 --> 00:21:48,240
whatever changes you want I snipped

00:21:46,800 --> 00:21:50,370
those out here because otherwise it was

00:21:48,240 --> 00:21:51,960
way too small to read and then you can

00:21:50,370 --> 00:21:54,870
do the same thing with them based on the

00:21:51,960 --> 00:21:56,730
action as well and I'm leaving you know

00:21:54,870 --> 00:21:59,270
and then you can see the full list on my

00:21:56,730 --> 00:22:02,040
github to see what it was going on and

00:21:59,270 --> 00:22:04,860
then next up we will talk about view set

00:22:02,040 --> 00:22:07,020
actions which are additional HTTP

00:22:04,860 --> 00:22:10,950
endpoints you can define to relate it to

00:22:07,020 --> 00:22:12,240
a model or an instance so when your user

00:22:10,950 --> 00:22:14,250
needs to take action on the model that's

00:22:12,240 --> 00:22:15,840
related to the one you care about using

00:22:14,250 --> 00:22:18,000
action to make your users life easier

00:22:15,840 --> 00:22:19,500
for instance I probably don't want to

00:22:18,000 --> 00:22:21,420
pass a primary key when booking an

00:22:19,500 --> 00:22:23,280
appointment at the groomer when Ringo

00:22:21,420 --> 00:22:25,250
here decided to roll in Canadian goose

00:22:23,280 --> 00:22:29,760
poop for the third time in as many weeks

00:22:25,250 --> 00:22:31,020
that was a lovely smell this isn't the

00:22:29,760 --> 00:22:32,790
only way to use actions but it

00:22:31,020 --> 00:22:37,320
definitely has been those convenient for

00:22:32,790 --> 00:22:39,240
me here's a simple example of booking an

00:22:37,320 --> 00:22:40,650
appointment using an action the user

00:22:39,240 --> 00:22:41,820
does not have to specify the animal in

00:22:40,650 --> 00:22:44,040
the request body at all because it's

00:22:41,820 --> 00:22:45,930
already in the URL thereby reducing the

00:22:44,040 --> 00:22:47,640
chance of error you still have to write

00:22:45,930 --> 00:22:48,780
your own validation and access code I'm

00:22:47,640 --> 00:22:51,240
not gonna write that for you you got to

00:22:48,780 --> 00:22:53,130
do something here and the code looks up

00:22:51,240 --> 00:22:56,070
the animal passes it to a serializer

00:22:53,130 --> 00:22:58,140
validates that serializer saves a new

00:22:56,070 --> 00:22:59,730
instance see realises the new instance

00:22:58,140 --> 00:23:03,450
and then read theirs that responds back

00:22:59,730 --> 00:23:04,680
to the user the detail argument

00:23:03,450 --> 00:23:06,120
determines whether the action operates

00:23:04,680 --> 00:23:08,100
on a single instance or list of

00:23:06,120 --> 00:23:09,540
instances you could set detail equals

00:23:08,100 --> 00:23:12,300
false to perform an action on a list of

00:23:09,540 --> 00:23:13,710
instances why would you do this couple

00:23:12,300 --> 00:23:15,900
ideas you can use it for pre-canned

00:23:13,710 --> 00:23:18,150
filters such as looking up getting all

00:23:15,900 --> 00:23:20,700
dogs who are overdue for their vows here

00:23:18,150 --> 00:23:22,770
for their shots or alternative output

00:23:20,700 --> 00:23:23,970
formats like spreadsheets or PDFs like

00:23:22,770 --> 00:23:25,620
say you've got a manager who demands

00:23:23,970 --> 00:23:26,910
everything be in Excel format even if

00:23:25,620 --> 00:23:30,660
your web tables are much easier to use

00:23:26,910 --> 00:23:32,220
that's one way you can do this open PI

00:23:30,660 --> 00:23:36,060
Excel is quite quite useful for that by

00:23:32,220 --> 00:23:37,260
the way so active the action decorator

00:23:36,060 --> 00:23:39,810
also takes a couple other very useful

00:23:37,260 --> 00:23:42,150
arguments methods is just a list of

00:23:39,810 --> 00:23:45,000
strings you know get put patch delete

00:23:42,150 --> 00:23:46,980
dot that if you do not use that method

00:23:45,000 --> 00:23:49,920
methods argument the default is just get

00:23:46,980 --> 00:23:53,010
and get only and then permission classes

00:23:49,920 --> 00:23:54,090
is a list of classes that you can you

00:23:53,010 --> 00:23:58,020
know that will be applied just to that

00:23:54,090 --> 00:23:59,580
particular action however the larger

00:23:58,020 --> 00:24:01,830
view set permission classes are also

00:23:59,580 --> 00:24:03,420
enforced so if you have say an endpoint

00:24:01,830 --> 00:24:05,580
that is accessible to people who don't

00:24:03,420 --> 00:24:07,890
have access to a larger outer endpoint

00:24:05,580 --> 00:24:09,600
you'll need to put in a code to let that

00:24:07,890 --> 00:24:14,540
single endpoint fall through the

00:24:09,600 --> 00:24:16,710
permission classes of the view set so

00:24:14,540 --> 00:24:18,420
we've so far we only cover presenting

00:24:16,710 --> 00:24:20,100
data how do we help users find the right

00:24:18,420 --> 00:24:21,930
data like helping Saleem here find the

00:24:20,100 --> 00:24:23,420
right person to sleep on while trying to

00:24:21,930 --> 00:24:25,679
stay out of reach of Ringo and Henry

00:24:23,420 --> 00:24:28,080
this was actually taken by my wife last

00:24:25,679 --> 00:24:30,630
night she was selling her Halloween

00:24:28,080 --> 00:24:36,000
Jim and Celine decided to help by

00:24:30,630 --> 00:24:38,159
pulling the pins out with her teeth yes

00:24:36,000 --> 00:24:40,890
she's about two years old and very

00:24:38,159 --> 00:24:45,450
fluffy very lovey but also very

00:24:40,890 --> 00:24:48,809
obnoxious so a cat so talk about

00:24:45,450 --> 00:24:50,429
filtering right right he filters freedom

00:24:48,809 --> 00:24:51,000
all each model gets tedious rather

00:24:50,429 --> 00:24:53,190
quickly

00:24:51,000 --> 00:24:54,720
it also doesn't easily handle looking a

00:24:53,190 --> 00:24:56,159
bad tributes based on the related

00:24:54,720 --> 00:24:58,140
objects like searching for a species

00:24:56,159 --> 00:24:59,760
name of dog while you're looking at the

00:24:58,140 --> 00:25:02,130
animal view set because it has to go

00:24:59,760 --> 00:25:04,080
through breed to get there this is

00:25:02,130 --> 00:25:05,760
Sherlock he wasn't my cat but he blown

00:25:04,080 --> 00:25:07,110
to win my wife's best friends he is

00:25:05,760 --> 00:25:09,059
probably the most stereotypical cat

00:25:07,110 --> 00:25:10,769
possible when it came to sitting in

00:25:09,059 --> 00:25:13,080
boxes if there was an open box anywhere

00:25:10,769 --> 00:25:14,279
he was in there within 30 seconds no

00:25:13,080 --> 00:25:18,450
matter how small the box may have been

00:25:14,279 --> 00:25:20,370
compared to his body rest framework

00:25:18,450 --> 00:25:21,809
filters is a very handy library for

00:25:20,370 --> 00:25:23,669
extending Gengo filter to make it even

00:25:21,809 --> 00:25:25,350
more powerful its head lighting feature

00:25:23,669 --> 00:25:27,120
is the ability to nest filter sets

00:25:25,350 --> 00:25:28,860
allowing you to traverse related models

00:25:27,120 --> 00:25:31,350
and your query parameters like that the

00:25:28,860 --> 00:25:33,450
filter expression right there that way

00:25:31,350 --> 00:25:35,070
you can wire your species filters in to

00:25:33,450 --> 00:25:36,389
your breed filters I mean you don't have

00:25:35,070 --> 00:25:38,100
to write a second filter to look up only

00:25:36,389 --> 00:25:40,110
dogs which are two levels deep in this

00:25:38,100 --> 00:25:41,399
example now there is a risk of

00:25:40,110 --> 00:25:43,200
information disclosure when your nesting

00:25:41,399 --> 00:25:45,169
like this read the docs very carefully

00:25:43,200 --> 00:25:47,700
and make sure you know what you're doing

00:25:45,169 --> 00:25:48,990
now here is a quick code example of how

00:25:47,700 --> 00:25:50,610
to implement rest framework filters in

00:25:48,990 --> 00:25:52,440
the view layer it is literally a drop-in

00:25:50,610 --> 00:25:54,690
replacement for Jengo filters and it's

00:25:52,440 --> 00:25:56,010
all codes based on django filter so you

00:25:54,690 --> 00:25:58,440
just swap out how you're importing it

00:25:56,010 --> 00:26:01,289
and then the everything else is exactly

00:25:58,440 --> 00:26:02,639
the same the base filter set class is

00:26:01,289 --> 00:26:07,019
actually a subclass of gingka filters

00:26:02,639 --> 00:26:09,360
version two so here's the target filter

00:26:07,019 --> 00:26:11,639
which is just a trivially simple species

00:26:09,360 --> 00:26:13,200
filters those constants I defined

00:26:11,639 --> 00:26:14,909
earlier up in the class you can see him

00:26:13,200 --> 00:26:18,240
on github it's just you know for like

00:26:14,909 --> 00:26:20,700
numeric is just equals not equal is null

00:26:18,240 --> 00:26:24,899
greater than less than etc pretty simple

00:26:20,700 --> 00:26:26,549
stuff and then next you will just use

00:26:24,899 --> 00:26:29,519
that related filter class to tell Django

00:26:26,549 --> 00:26:31,769
where to look and the rest is almost

00:26:29,519 --> 00:26:34,080
magic remember what I said about

00:26:31,769 --> 00:26:36,090
information disclose or risk that is in

00:26:34,080 --> 00:26:37,770
the query set breed filter that I showed

00:26:36,090 --> 00:26:39,299
in a couple slides back you have to be

00:26:37,770 --> 00:26:40,710
very careful about what you expose in

00:26:39,299 --> 00:26:41,639
your filters especially to untrusted

00:26:40,710 --> 00:26:43,229
users

00:26:41,639 --> 00:26:44,969
clever adversary can use well build

00:26:43,229 --> 00:26:46,529
filter expressions to determine the

00:26:44,969 --> 00:26:48,029
innocence of the existence of objects

00:26:46,529 --> 00:26:52,459
they wouldn't have access to like say

00:26:48,029 --> 00:26:55,049
unpublished drafts in the blog law gap I

00:26:52,459 --> 00:26:58,849
took this of the next last but not least

00:26:55,049 --> 00:27:00,809
the most important thing documentation I

00:26:58,849 --> 00:27:03,539
took this polar bear picture at the

00:27:00,809 --> 00:27:04,739
Cincinnati Zoo back in 2008 if you've

00:27:03,539 --> 00:27:06,059
never been there I highly recommended

00:27:04,739 --> 00:27:07,349
it's probably the second best I've been

00:27:06,059 --> 00:27:09,299
- behind the one right here in San Diego

00:27:07,349 --> 00:27:10,589
and if you're looking to get a trip

00:27:09,299 --> 00:27:12,599
together to go the zoo while you're here

00:27:10,589 --> 00:27:15,079
I think Andrew Karl's organizing one for

00:27:12,599 --> 00:27:17,190
tomorrow so you may wanna check with him

00:27:15,079 --> 00:27:19,679
there are many ways you can present

00:27:17,190 --> 00:27:21,690
documentation there are far too many for

00:27:19,679 --> 00:27:23,549
me to even list here but the built-in

00:27:21,690 --> 00:27:25,200
browsable API it's a Spartan but

00:27:23,549 --> 00:27:27,389
functional it works you can make

00:27:25,200 --> 00:27:29,459
requests fill in form data make test

00:27:27,389 --> 00:27:31,019
requests with relative ease you can use

00:27:29,459 --> 00:27:32,429
a djenka rest wagger to provide an

00:27:31,019 --> 00:27:34,079
easy-to-use playground for users to test

00:27:32,429 --> 00:27:35,489
out requests and provide slightly better

00:27:34,079 --> 00:27:38,639
formatting than the browsable UI

00:27:35,489 --> 00:27:39,929
provides it also lets you show what

00:27:38,639 --> 00:27:41,309
method exactly what methods you can use

00:27:39,929 --> 00:27:42,839
with a given endpoint all that one

00:27:41,309 --> 00:27:46,409
largest very long list

00:27:42,839 --> 00:27:47,969
now DRF 3.7 did add a schema based

00:27:46,409 --> 00:27:51,239
documentation generation that mostly

00:27:47,969 --> 00:27:53,669
renders jake arrests wagner obsolete

00:27:51,239 --> 00:27:56,190
however it requires you to manually

00:27:53,669 --> 00:27:57,209
update the schema before it can read

00:27:56,190 --> 00:27:58,289
from it see I should have manual read

00:27:57,209 --> 00:27:59,339
command from the command line just

00:27:58,289 --> 00:28:02,249
integrate then your tooling and you're

00:27:59,339 --> 00:28:04,649
done now if you're a fan of read the

00:28:02,249 --> 00:28:05,879
docs do you can use make docs which is

00:28:04,649 --> 00:28:07,229
actually included with a template they

00:28:05,879 --> 00:28:09,389
cookie-cutter template I built this

00:28:07,229 --> 00:28:11,070
example code product on if you're

00:28:09,389 --> 00:28:12,719
starting a new project yes definitely

00:28:11,070 --> 00:28:16,139
use it it's called cookie cutter -

00:28:12,719 --> 00:28:17,729
Django - rest on github definitely use

00:28:16,139 --> 00:28:19,559
it it doesn't quite work with pip and

00:28:17,729 --> 00:28:21,839
yet although you can use my code base -

00:28:19,559 --> 00:28:25,859
um that is modified to work with Pippin

00:28:21,839 --> 00:28:28,049
if that's your style so here is rest

00:28:25,859 --> 00:28:29,609
framework swagger it's a nice way to

00:28:28,049 --> 00:28:31,200
generate your standard swagger UI is

00:28:29,609 --> 00:28:33,269
using your view sets in the filter sets

00:28:31,200 --> 00:28:34,649
they reference it requires basically def

00:28:33,269 --> 00:28:36,809
work aside from making them write good

00:28:34,649 --> 00:28:38,849
doc strings in the view sets themselves

00:28:36,809 --> 00:28:42,799
now you are enforcing good doc strings

00:28:38,849 --> 00:28:45,059
in your pull request right me neither

00:28:42,799 --> 00:28:46,229
here's a screenshot of my example code

00:28:45,059 --> 00:28:48,479
using rest framework swagger

00:28:46,229 --> 00:28:49,769
each API action is expandable letting

00:28:48,479 --> 00:28:51,839
you play with filtering options and

00:28:49,769 --> 00:28:53,339
toasting data where appropriate think of

00:28:51,839 --> 00:28:54,670
it as the built-in browsable api on

00:28:53,339 --> 00:28:57,490
steroids

00:28:54,670 --> 00:28:59,049
also quick tip if you have API resources

00:28:57,490 --> 00:29:00,400
you don't want visible to users like say

00:28:59,049 --> 00:29:02,770
there for internal use only

00:29:00,400 --> 00:29:04,510
you just you put the attribute exclude

00:29:02,770 --> 00:29:06,309
from schema and set that to true in your

00:29:04,510 --> 00:29:09,450
view set and that will hide it from this

00:29:06,309 --> 00:29:10,990
documentation entirely so here's the

00:29:09,450 --> 00:29:12,700
clicking on one of those particular

00:29:10,990 --> 00:29:14,350
endpoints and you can see what rest

00:29:12,700 --> 00:29:15,490
framework swaggered offers gives you

00:29:14,350 --> 00:29:18,730
almost all the things you would normally

00:29:15,490 --> 00:29:20,620
use postman for and one thing to note it

00:29:18,730 --> 00:29:22,179
does not seem to discover Auto does to

00:29:20,620 --> 00:29:23,710
automatically discover nested filters

00:29:22,179 --> 00:29:25,630
well like from rest framework filters

00:29:23,710 --> 00:29:29,140
about the end of the world just slightly

00:29:25,630 --> 00:29:30,520
disappointing and then there's also make

00:29:29,140 --> 00:29:31,540
Doc's which I as I mentioned came free

00:29:30,520 --> 00:29:34,600
Estella pre-installed with a cookie

00:29:31,540 --> 00:29:35,679
cutter template it's pre-configured runs

00:29:34,600 --> 00:29:38,290
in a separate docker container inside

00:29:35,679 --> 00:29:39,820
that template very easy and this is what

00:29:38,290 --> 00:29:41,860
the home page looks like it's just you

00:29:39,820 --> 00:29:44,710
read me format it very very nicely and

00:29:41,860 --> 00:29:48,669
the template also comes with off and the

00:29:44,710 --> 00:29:50,049
user API pre Aiken pre-configured now

00:29:48,669 --> 00:29:51,549
make Doc's requires you to write all of

00:29:50,049 --> 00:29:53,440
your Doc's in markdown which is

00:29:51,549 --> 00:29:54,760
wonderful and it's nicely you get the

00:29:53,440 --> 00:29:56,740
clots of control over what goes where

00:29:54,760 --> 00:29:58,390
but it also requires you to do all the

00:29:56,740 --> 00:30:00,940
work manually if you have lazy

00:29:58,390 --> 00:30:05,320
developers like me that might be

00:30:00,940 --> 00:30:06,880
troublesome so let's see I've got a few

00:30:05,320 --> 00:30:07,840
minutes a few minutes extra time so I'll

00:30:06,880 --> 00:30:09,910
talk about a couple of other useful

00:30:07,840 --> 00:30:11,679
libraries we had Genco simple history

00:30:09,910 --> 00:30:13,049
was written originally by a tree hunter

00:30:11,679 --> 00:30:15,429
who's actually talking next in this room

00:30:13,049 --> 00:30:17,860
it's a great little audit tool for

00:30:15,429 --> 00:30:19,330
tracking when users make changes there

00:30:17,860 --> 00:30:22,570
so Hugh user comes back to you to say

00:30:19,330 --> 00:30:24,160
hey where'd my and my dog go and you can

00:30:22,570 --> 00:30:27,669
look at the history for that dog and say

00:30:24,160 --> 00:30:29,559
you deleted that that's on you and then

00:30:27,669 --> 00:30:31,000
a Jenga market field is great if you say

00:30:29,559 --> 00:30:32,919
you want to be able to let your users

00:30:31,000 --> 00:30:35,290
create craft like announcements or

00:30:32,919 --> 00:30:36,700
general purpose messages that would be

00:30:35,290 --> 00:30:38,080
sent up to the users but you don't go

00:30:36,700 --> 00:30:41,110
through the trouble of putting in a full

00:30:38,080 --> 00:30:43,120
CMS they can just you know use markdown

00:30:41,110 --> 00:30:44,890
to put in their message and then you can

00:30:43,120 --> 00:30:47,650
just read that from the API endpoint it

00:30:44,890 --> 00:30:50,620
gives you both the raw markdown and HTML

00:30:47,650 --> 00:30:52,240
formatted output and then Gengo

00:30:50,620 --> 00:30:53,740
countries if you've ever had to deal

00:30:52,240 --> 00:30:56,049
with addresses you know that countries

00:30:53,740 --> 00:30:58,419
are a pain for example is England a

00:30:56,049 --> 00:31:04,540
country depends on to us like for soccer

00:30:58,419 --> 00:31:06,520
yes for the Olympics no okay so go and

00:31:04,540 --> 00:31:08,169
wrap it up I'm talking about I talked

00:31:06,520 --> 00:31:08,440
about making your IP API user friendly

00:31:08,169 --> 00:31:10,180
with

00:31:08,440 --> 00:31:13,060
related fields list in detail

00:31:10,180 --> 00:31:14,350
serializers and actions i also talked

00:31:13,060 --> 00:31:16,630
about improving filtering you can use

00:31:14,350 --> 00:31:18,850
rest framework filter to UM get a little

00:31:16,630 --> 00:31:21,220
bit extra niceties and then talk about

00:31:18,850 --> 00:31:24,460
documentation and I've got example code

00:31:21,220 --> 00:31:25,960
over there on github feel free to take a

00:31:24,460 --> 00:31:29,620
look and the link to the slides is there

00:31:25,960 --> 00:31:31,450
as well let's take a moment give special

00:31:29,620 --> 00:31:33,460
thanks to a lacy Anna and Jeff for

00:31:31,450 --> 00:31:34,750
reviewing my talk and my talk in my

00:31:33,460 --> 00:31:36,070
proposal this would not have gotten

00:31:34,750 --> 00:31:38,770
anywhere near this way without their

00:31:36,070 --> 00:31:40,030
help and then also thank my wife Bonnie

00:31:38,770 --> 00:31:50,380
for putting up with me going to San

00:31:40,030 --> 00:31:52,320
Diego without her all right that's it so

00:31:50,380 --> 00:31:54,370
Django rest framework exists yes

00:31:52,320 --> 00:31:56,380
wonderfully flexible framework there is

00:31:54,370 --> 00:31:58,120
also a graph QL out there yes are you

00:31:56,380 --> 00:31:58,630
able to comment on why you would use one

00:31:58,120 --> 00:32:01,360
or the other

00:31:58,630 --> 00:32:02,920
other than buzzword compliance but swear

00:32:01,360 --> 00:32:04,210
compliance is exactly correct but

00:32:02,920 --> 00:32:05,530
realistically I mean I don't have enough

00:32:04,210 --> 00:32:07,060
grade I do not have enough experience

00:32:05,530 --> 00:32:09,340
with crack QL to provide educated answer

00:32:07,060 --> 00:32:11,620
on that one all right then I'll just no

00:32:09,340 --> 00:32:16,240
other questions I lecture which one is

00:32:11,620 --> 00:32:17,470
your favorite dog definitely Henry he

00:32:16,240 --> 00:32:19,690
gets him till he gets into less trash

00:32:17,470 --> 00:32:21,370
that way I did thank you excellent talk

00:32:19,690 --> 00:32:24,430
by the way thank you

00:32:21,370 --> 00:32:26,830
my question is have you have you as your

00:32:24,430 --> 00:32:30,100
company done any work with using binary

00:32:26,830 --> 00:32:31,900
serialization off we have not we've been

00:32:30,100 --> 00:32:33,790
pretty much entirely unfortunate that

00:32:31,900 --> 00:32:35,020
we'd be able to use some JSON for

00:32:33,790 --> 00:32:36,880
everything they haven't really had a

00:32:35,020 --> 00:32:38,800
format they need something for binary

00:32:36,880 --> 00:32:41,710
for do you have any recommended patterns

00:32:38,800 --> 00:32:44,280
for testing serializers yeah I'd like to

00:32:41,710 --> 00:32:47,760
yeah the I would I tip eclis do we'll

00:32:44,280 --> 00:32:50,710
just you know give a feed it in eight

00:32:47,760 --> 00:32:52,720
actually fills example code from his a

00:32:50,710 --> 00:32:54,670
tutorial on Sunday has a great example

00:32:52,720 --> 00:32:56,320
of just testing the serializers you

00:32:54,670 --> 00:32:58,000
basically feed it a dictionary in and

00:32:56,320 --> 00:32:59,560
then walk through the validation steps

00:32:58,000 --> 00:33:02,260
on it and then make sure that the

00:32:59,560 --> 00:33:03,790
returns read validated data matches what

00:33:02,260 --> 00:33:05,710
you'd expect it to be and going

00:33:03,790 --> 00:33:06,550
vice-versa in that same order all right

00:33:05,710 --> 00:33:08,080
in that being the case

00:33:06,550 --> 00:33:11,430
thank you again drew for the wonderful

00:33:08,080 --> 00:33:11,430

YouTube URL: https://www.youtube.com/watch?v=-9WniUBt0fo


