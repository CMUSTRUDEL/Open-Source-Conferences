Title: DjangoCon US 2018 - A Python-Driven Web App Framework... by Kendall Chuang and Henry Olson
Publication date: 2018-11-08
Playlist: DjangoCon US 2018
Description: 
	DjangoCon US 2018 - A Python-Driven Web App Framework with Django, Channels, and React by Kendall Chuang and Henry Olson

At our company, we have faced a monumental task: designing a simple framework for data scientists to create powerful, dynamic web applications using only Python. In order to utilize the power of our machine-intelligence platform, we need to be able to quickly generate web applications to cater to different client solutions. We wanted to move standard data analysis workflows out of the command line, and into sleek, modern web apps that allow for dynamic construction of charts, tables, and other visualizations.

Our talk will focus on how we addressed this problem statement with the development of an application framework built on Django, Channels, and React. We picked these technologies for several reasons. Django is already an incredibly powerful web framework, and we realized very early on that we could use Django Models, Forms, and Form Validation to serve as the core of our backend. However, we opted to take a different approach than server-side rendering, and opted to utilize React on the frontend to display large trees of dynamically-generated components.

To connect these two segments, we decided to use websockets, via Django Channels. Our machine intelligence platform is incredibly powerful, and it allows us to perform tasks on big data with long-running jobs, such as topological modeling, auto-group generation, and feature selection. We use Channels as a way for the Django server to notify the React client on updates to these processes and to refresh different charts and tables.

Lastly, we designed our own Python SDK to allow data scientists to easily generate Python objects which are serialized and converted into React components. A developer using this framework doesnâ€™t need to know Django, React, or Channels, but can utilize the power of all three in concert to quickly prototype powerful machine-learning applications with appealing user interfaces.

Throughout this talk, we will focus on how these technologies interact with one another, the benefits of these design-choices, and the challenges that we faced. The potential applications of this architecture extend far beyond our solutions, and itâ€™s valuable for listeners to understand how Django can be used outside of traditional contexts. Hopefully this talk will inspire other Django developers to consider how their apps can utilize websockets, client-side rendering, and other web-development paradigms to address different and unique use-cases.

This talk was presented at: https://2018.djangocon.us/talk/a-python-driven-web-app-framework-with/

LINKS:
Follow Kendall Chuang ğŸ‘‡
On Twitter: https://twitter.com/kendallchuang
Official homepage: https://www.ayasdi.com

Follow Henry Olson ğŸ‘‡
Official homepage: https://www.ayasdi.com

Follow DjangCon US ğŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ğŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,050 --> 00:00:07,709
[Music]

00:00:17,130 --> 00:00:24,119
so as mentioned I'm Kendall and this is

00:00:20,490 --> 00:00:27,930
Henry and where is T so today we're

00:00:24,119 --> 00:00:30,510
gonna talk about the motivation for our

00:00:27,930 --> 00:00:33,420
app framework that we developed n is T

00:00:30,510 --> 00:00:36,000
the reactor Django architecture and

00:00:33,420 --> 00:00:39,239
we'll have a brief demo at the end and

00:00:36,000 --> 00:00:41,010
so is T is a artificial intelligence

00:00:39,239 --> 00:00:44,969
company developing software for

00:00:41,010 --> 00:00:48,320
enterprise and we have a enterprise

00:00:44,969 --> 00:00:51,270
software platform which we provide for

00:00:48,320 --> 00:00:55,890
healthcare finance and government

00:00:51,270 --> 00:00:59,070
customers and so the motivation behind

00:00:55,890 --> 00:01:02,969
the app framework we developed is called

00:00:59,070 --> 00:01:05,970
which is we call envision was to empower

00:01:02,969 --> 00:01:08,340
data scientists to build apps quickly so

00:01:05,970 --> 00:01:10,500
we want to enable them to build proof of

00:01:08,340 --> 00:01:13,740
concepts for our customers as well as to

00:01:10,500 --> 00:01:17,400
provide the data scientists working at

00:01:13,740 --> 00:01:21,570
our at our customers companies to also

00:01:17,400 --> 00:01:24,360
prototype and deploy apps quickly using

00:01:21,570 --> 00:01:28,140
our platform and also we want to build

00:01:24,360 --> 00:01:30,270
many reusable components as well so as

00:01:28,140 --> 00:01:36,240
you can see here is a demo of an app

00:01:30,270 --> 00:01:38,250
made using envision on the right so why

00:01:36,240 --> 00:01:41,189
did we choose why did we decide to go

00:01:38,250 --> 00:01:44,159
with Django there's a great open source

00:01:41,189 --> 00:01:46,290
community as you all know also data

00:01:44,159 --> 00:01:48,210
scientists like to use Python so this is

00:01:46,290 --> 00:01:50,369
a huge benefit because they have

00:01:48,210 --> 00:01:54,810
experience with the libraries like

00:01:50,369 --> 00:01:58,890
psyche I learn numpy pandas and so it

00:01:54,810 --> 00:02:02,100
was it's more familiar for them we also

00:01:58,890 --> 00:02:04,110
have support of WebSockets using Django

00:02:02,100 --> 00:02:05,430
channels which I'll talk about a bit

00:02:04,110 --> 00:02:08,190
later

00:02:05,430 --> 00:02:09,780
Django provides form validation so since

00:02:08,190 --> 00:02:12,670
we have to take you know some sort of

00:02:09,780 --> 00:02:14,680
input into our application

00:02:12,670 --> 00:02:17,170
being able to do the form validation on

00:02:14,680 --> 00:02:19,630
the back end is very helpful

00:02:17,170 --> 00:02:22,720
also there's a nice abstraction over the

00:02:19,630 --> 00:02:24,910
database in Django models and also

00:02:22,720 --> 00:02:30,120
there's so many third-party modules as

00:02:24,910 --> 00:02:34,390
well and now Henry will talk about react

00:02:30,120 --> 00:02:35,620
thanks Kendall okay so I'm sure a lot of

00:02:34,390 --> 00:02:37,930
people are wondering here you're

00:02:35,620 --> 00:02:39,250
developing an app framework isn't django

00:02:37,930 --> 00:02:41,830
an app framework why wouldn't you just

00:02:39,250 --> 00:02:45,010
use views like why why bring this

00:02:41,830 --> 00:02:46,510
complicated react thing into the mix and

00:02:45,010 --> 00:02:49,180
there are a lot of reasons why we

00:02:46,510 --> 00:02:51,790
decided to go down this route so first

00:02:49,180 --> 00:02:54,040
of all when thinking about using

00:02:51,790 --> 00:02:56,650
client-side logic we realized that it

00:02:54,040 --> 00:02:58,890
would be a lot more flexible than using

00:02:56,650 --> 00:03:01,209
a server-side templating and rendering

00:02:58,890 --> 00:03:03,760
and when we kind of started thinking

00:03:01,209 --> 00:03:05,970
down that route we realized that react

00:03:03,760 --> 00:03:08,410
was really the best option to go with

00:03:05,970 --> 00:03:10,600
some of you may know it as kind of the

00:03:08,410 --> 00:03:12,940
JavaScript framework flavor of the month

00:03:10,600 --> 00:03:16,270
right now but it actually has a lot of

00:03:12,940 --> 00:03:18,070
staying power and it's proven that it's

00:03:16,270 --> 00:03:20,410
very powerful through its use of the

00:03:18,070 --> 00:03:21,760
virtual Dom so for those of you who

00:03:20,410 --> 00:03:24,760
don't know about what the virtual DOM is

00:03:21,760 --> 00:03:27,250
at a high level basically reacts

00:03:24,760 --> 00:03:29,680
internals allow it to efficiently re

00:03:27,250 --> 00:03:32,230
render content so that when it's

00:03:29,680 --> 00:03:34,090
updating the page with new data it does

00:03:32,230 --> 00:03:36,250
so in basically a very efficient manner

00:03:34,090 --> 00:03:39,519
instead of reconstructing the entire

00:03:36,250 --> 00:03:40,959
page in addition there are tons of

00:03:39,519 --> 00:03:42,970
libraries and tools that are super

00:03:40,959 --> 00:03:44,860
useful for us so one of them that you

00:03:42,970 --> 00:03:47,080
may know is Redux which is basically a

00:03:44,860 --> 00:03:50,560
state management library for react and

00:03:47,080 --> 00:03:53,049
there's also some react router stuff and

00:03:50,560 --> 00:03:54,790
ways to make WebSockets calls which is

00:03:53,049 --> 00:03:57,880
really the meat of this talk that we're

00:03:54,790 --> 00:03:59,410
going to get into pretty soon so our

00:03:57,880 --> 00:04:01,860
last reason was when we were developing

00:03:59,410 --> 00:04:04,269
an app framework we were thinking okay

00:04:01,860 --> 00:04:07,299
we want our data scientists to be able

00:04:04,269 --> 00:04:10,180
to use these Python components and write

00:04:07,299 --> 00:04:13,360
out things like a page or a form or a

00:04:10,180 --> 00:04:15,040
chart and actually the way that react is

00:04:13,360 --> 00:04:16,930
constructed for those of you who don't

00:04:15,040 --> 00:04:19,989
know it's basically these JavaScript

00:04:16,930 --> 00:04:21,940
components so it very closely mirrors

00:04:19,989 --> 00:04:24,880
Python classes so that when we

00:04:21,940 --> 00:04:26,200
communicate and serialize that data it

00:04:24,880 --> 00:04:26,410
matches really well to the front-end

00:04:26,200 --> 00:04:30,100
that

00:04:26,410 --> 00:04:32,110
we designed so now we're going to talk

00:04:30,100 --> 00:04:35,140
about WebSockets which is basically the

00:04:32,110 --> 00:04:36,700
glue between these two worlds so let's

00:04:35,140 --> 00:04:38,800
just get a show of hands out here how

00:04:36,700 --> 00:04:41,680
many people know about WebSockets or

00:04:38,800 --> 00:04:42,970
have worked with WebSockets before okay

00:04:41,680 --> 00:04:45,220
a lot of people actually that's really

00:04:42,970 --> 00:04:47,230
awesome so for people who don't know

00:04:45,220 --> 00:04:49,570
I'll just give like a really brief

00:04:47,230 --> 00:04:52,630
explanation of what WebSockets are and

00:04:49,570 --> 00:04:55,480
why you might want to use them so when

00:04:52,630 --> 00:04:58,600
you think about like traditional HTTP

00:04:55,480 --> 00:05:00,580
communication it's kind of called a pool

00:04:58,600 --> 00:05:02,260
paradigm so what I mean by that is

00:05:00,580 --> 00:05:05,590
basically you have the idea of a client

00:05:02,260 --> 00:05:08,470
and a server the client makes requests

00:05:05,590 --> 00:05:11,050
to the server and receives a response so

00:05:08,470 --> 00:05:14,470
imagine for a second that I'm react over

00:05:11,050 --> 00:05:16,720
here and Kendal's Django so if I want to

00:05:14,470 --> 00:05:18,490
get some information from Django I have

00:05:16,720 --> 00:05:22,900
to go and ask Kendall hey can I get a

00:05:18,490 --> 00:05:24,700
chart or hey can I get some data and yes

00:05:22,900 --> 00:05:26,200
so Kendall can send me a response

00:05:24,700 --> 00:05:28,110
now if Kendall wants to talk to me I

00:05:26,200 --> 00:05:31,240
don't really care I'm not gonna listen

00:05:28,110 --> 00:05:33,850
yeah yeah it's it's not very friendly

00:05:31,240 --> 00:05:35,380
and it's not very efficient because

00:05:33,850 --> 00:05:38,130
every time that we want to talk we have

00:05:35,380 --> 00:05:40,840
to open a socket communication

00:05:38,130 --> 00:05:42,970
WebSockets on the other hand allows for

00:05:40,840 --> 00:05:45,940
a push paradigm and a persistent

00:05:42,970 --> 00:05:48,310
connection so basically how that works

00:05:45,940 --> 00:05:51,910
is we first have our little handshake

00:05:48,310 --> 00:05:53,680
upgrade so we start with HTTP so I'm

00:05:51,910 --> 00:05:55,240
like hey Kendal do you want to use

00:05:53,680 --> 00:05:56,220
WebSockets instead like this really

00:05:55,240 --> 00:05:58,540
sucks

00:05:56,220 --> 00:06:01,360
okay cool so now we're using WebSockets

00:05:58,540 --> 00:06:03,400
and now what this means is I can send

00:06:01,360 --> 00:06:06,190
Kendal messages and Kendall can send me

00:06:03,400 --> 00:06:08,350
messages whenever he wants so you can do

00:06:06,190 --> 00:06:11,260
really cool stuff with WebSockets where

00:06:08,350 --> 00:06:13,840
the server can actually post messages to

00:06:11,260 --> 00:06:16,120
a number of clients and this is called

00:06:13,840 --> 00:06:18,040
broadcasting so you no longer have to

00:06:16,120 --> 00:06:19,900
operate on this model of making a

00:06:18,040 --> 00:06:22,360
request waiting around for a response

00:06:19,900 --> 00:06:24,640
now the server can send information to

00:06:22,360 --> 00:06:26,350
clients whenever it's ready and we

00:06:24,640 --> 00:06:28,600
wanted to utilize this for the

00:06:26,350 --> 00:06:30,790
asynchronous loading of big data

00:06:28,600 --> 00:06:33,640
so for envision I mean you can imagine

00:06:30,790 --> 00:06:36,250
data scientists working with pandas and

00:06:33,640 --> 00:06:37,570
numpy and these huge data sets it's

00:06:36,250 --> 00:06:39,630
going to take a while to process things

00:06:37,570 --> 00:06:42,030
on our Python back-end so

00:06:39,630 --> 00:06:45,090
we want to basically push that data to

00:06:42,030 --> 00:06:46,680
the front end as soon as it's ready in

00:06:45,090 --> 00:06:49,200
addition we realized we could use this

00:06:46,680 --> 00:06:51,690
for notifications progress messages

00:06:49,200 --> 00:06:53,490
loading spinners basically a bunch of

00:06:51,690 --> 00:06:55,080
different use cases for keeping the

00:06:53,490 --> 00:06:57,300
front-end very responsive and

00:06:55,080 --> 00:07:00,840
interactive so you're not just waiting

00:06:57,300 --> 00:07:01,620
around for data to load and now Kendall

00:07:00,840 --> 00:07:03,360
is going to go ahead and talk about

00:07:01,620 --> 00:07:05,130
Django channels which is how we

00:07:03,360 --> 00:07:11,280
basically bring this architecture to

00:07:05,130 --> 00:07:13,410
life so here's a diagram of the channels

00:07:11,280 --> 00:07:17,790
architecture as you can see on the top

00:07:13,410 --> 00:07:21,380
there's the web browser and on these

00:07:17,790 --> 00:07:23,640
blue lines on the left are the HTTP

00:07:21,380 --> 00:07:27,090
messages and on the right you can see

00:07:23,640 --> 00:07:31,710
WebSockets there's this interface server

00:07:27,090 --> 00:07:32,730
which handles the basically a SGI in

00:07:31,710 --> 00:07:36,240
WSGI

00:07:32,730 --> 00:07:38,250
communications which connect to Django

00:07:36,240 --> 00:07:40,350
and Django channels and then there's

00:07:38,250 --> 00:07:44,370
this channel layer which kind of routes

00:07:40,350 --> 00:07:46,200
the messages to the consumer so you can

00:07:44,370 --> 00:07:48,270
see the consumers here there's the HTTP

00:07:46,200 --> 00:07:51,690
consumer which can route messages to

00:07:48,270 --> 00:07:53,520
your standard Django View functions and

00:07:51,690 --> 00:07:57,650
it is in addition to this you can see

00:07:53,520 --> 00:08:00,810
the WebSockets consumers on the bottom

00:07:57,650 --> 00:08:03,630
for WebSockets messages and here on the

00:08:00,810 --> 00:08:06,120
right you can see background processes

00:08:03,630 --> 00:08:07,860
as well so this is one of the other nice

00:08:06,120 --> 00:08:10,560
features that we have with django

00:08:07,860 --> 00:08:14,070
channels is you can actually have the

00:08:10,560 --> 00:08:17,460
background processes send messages back

00:08:14,070 --> 00:08:19,500
up to the client so in our case for

00:08:17,460 --> 00:08:22,170
example if you're using a background

00:08:19,500 --> 00:08:26,610
worker like celery you can have celery

00:08:22,170 --> 00:08:29,310
worker send updates all the way and push

00:08:26,610 --> 00:08:31,530
notifications up to your client when a

00:08:29,310 --> 00:08:34,440
long-running machine learning model is

00:08:31,530 --> 00:08:35,820
done training for example and so the

00:08:34,440 --> 00:08:38,729
libraries that we're using here are

00:08:35,820 --> 00:08:41,460
include include Django channels for the

00:08:38,729 --> 00:08:44,400
channel layer and consumers and also

00:08:41,460 --> 00:08:47,850
Daphne which is a package developed

00:08:44,400 --> 00:08:49,589
along with Django channels too for the

00:08:47,850 --> 00:08:51,660
interface server so the interface server

00:08:49,589 --> 00:08:55,620
is Daphne

00:08:51,660 --> 00:09:01,009
and on the back and optionally if you

00:08:55,620 --> 00:09:03,690
like you can run celery as well and so

00:09:01,009 --> 00:09:07,470
and Henry will know talking about the

00:09:03,690 --> 00:09:09,509
front-end architecture cool all right so

00:09:07,470 --> 00:09:11,100
we're back to more front-end stuff I'm

00:09:09,509 --> 00:09:13,709
just gonna give you the warning that we

00:09:11,100 --> 00:09:16,560
might get a little in depth with some

00:09:13,709 --> 00:09:18,810
react Redux stuff so if you're not

00:09:16,560 --> 00:09:20,370
familiar don't worry there's there's a

00:09:18,810 --> 00:09:23,519
like a ton of boilerplate but we'll try

00:09:20,370 --> 00:09:25,199
and stick to just the core logic here so

00:09:23,519 --> 00:09:27,449
before we dive into that we want to talk

00:09:25,199 --> 00:09:29,839
a little bit about the object model that

00:09:27,449 --> 00:09:32,279
we designed for this application so

00:09:29,839 --> 00:09:34,500
maybe think to yourself really quickly

00:09:32,279 --> 00:09:37,889
if you're writing a framework for people

00:09:34,500 --> 00:09:40,410
to write web apps in Python what kinds

00:09:37,889 --> 00:09:41,759
of things do you need to have what kind

00:09:40,410 --> 00:09:45,810
of things do you need to expose to them

00:09:41,759 --> 00:09:47,339
and for us we are thinking of these

00:09:45,810 --> 00:09:49,980
things that you see in this hierarchy

00:09:47,339 --> 00:09:52,290
model here so first of all you have the

00:09:49,980 --> 00:09:53,910
concept of an application I mean this is

00:09:52,290 --> 00:09:56,579
really basic this is your overall app

00:09:53,910 --> 00:09:58,949
maybe just has some configuration and a

00:09:56,579 --> 00:10:02,610
theme and within an application you

00:09:58,949 --> 00:10:05,040
might have a navigation or tabs ways to

00:10:02,610 --> 00:10:08,939
move around the app and visit different

00:10:05,040 --> 00:10:11,930
pages so in our world the page is like

00:10:08,939 --> 00:10:14,880
the most important object this is what

00:10:11,930 --> 00:10:16,769
data analysts and data scientists write

00:10:14,880 --> 00:10:19,740
in our application they write pages and

00:10:16,769 --> 00:10:22,589
within pages they use forms which are

00:10:19,740 --> 00:10:25,259
very familiar to Django users forms have

00:10:22,589 --> 00:10:27,269
fields they can be submitted they can be

00:10:25,259 --> 00:10:30,569
validated they're very useful for

00:10:27,269 --> 00:10:32,790
interacting and you have blocks which

00:10:30,569 --> 00:10:35,160
are like charts tables anything that you

00:10:32,790 --> 00:10:37,559
want to display to users so with this

00:10:35,160 --> 00:10:39,809
combination of objects you can present

00:10:37,559 --> 00:10:41,930
data you can get user feedback basically

00:10:39,809 --> 00:10:44,610
everything that you would need in a

00:10:41,930 --> 00:10:47,100
simple web application that displays

00:10:44,610 --> 00:10:49,559
some information so we use this object

00:10:47,100 --> 00:10:51,629
model both on the Python side and on the

00:10:49,559 --> 00:10:54,089
react side it can be kind of annoying

00:10:51,629 --> 00:10:55,410
because sometimes you know if you create

00:10:54,089 --> 00:10:56,910
a new component you have to create both

00:10:55,410 --> 00:10:58,980
the Python component and a react

00:10:56,910 --> 00:11:01,019
component but as I mentioned earlier

00:10:58,980 --> 00:11:02,730
they are very similar so it's a pretty

00:11:01,019 --> 00:11:04,910
easy process to have them available on

00:11:02,730 --> 00:11:06,230
both sides now

00:11:04,910 --> 00:11:08,030
when we're actually rendering things on

00:11:06,230 --> 00:11:10,760
the front end we use as I mentioned

00:11:08,030 --> 00:11:13,130
react and redux and we use json-rpc

00:11:10,760 --> 00:11:17,560
methods or basically you can think of

00:11:13,130 --> 00:11:19,820
these as ways of making WebSockets calls

00:11:17,560 --> 00:11:22,700
so we're gonna go ahead and take a look

00:11:19,820 --> 00:11:24,800
at some code here so we have this demo

00:11:22,700 --> 00:11:27,140
repo and we'll show you the demo at the

00:11:24,800 --> 00:11:28,700
end but basically we'll start with a

00:11:27,140 --> 00:11:30,740
really simple example of how this

00:11:28,700 --> 00:11:32,780
JavaScript is instantiated

00:11:30,740 --> 00:11:36,020
and then move into how the actual flow

00:11:32,780 --> 00:11:38,360
works so for starters we're going to go

00:11:36,020 --> 00:11:40,400
ahead and take a look at how Django is

00:11:38,360 --> 00:11:41,870
serving up react so if you wanted to do

00:11:40,400 --> 00:11:43,370
this yourself it's actually pretty

00:11:41,870 --> 00:11:46,280
straightforward and I'll show you how

00:11:43,370 --> 00:11:47,750
it's possible so is that a good enough

00:11:46,280 --> 00:11:50,210
size for everybody can I get like a

00:11:47,750 --> 00:11:53,960
thumbs down if it's not okay great I see

00:11:50,210 --> 00:11:57,080
some thumbs up so here's basically our

00:11:53,960 --> 00:11:58,340
views function and we have one view in

00:11:57,080 --> 00:12:00,650
this application and it's really

00:11:58,340 --> 00:12:05,290
straightforward it's an index view so

00:12:00,650 --> 00:12:08,210
are you are our URL routing excuse me is

00:12:05,290 --> 00:12:10,310
set up so that this is basically loaded

00:12:08,210 --> 00:12:12,440
every time that you hit the running

00:12:10,310 --> 00:12:14,660
Django server so we hit the index view

00:12:12,440 --> 00:12:16,430
right and this is really the only line

00:12:14,660 --> 00:12:18,380
that I want you to care about here is we

00:12:16,430 --> 00:12:19,610
basically just render a template I think

00:12:18,380 --> 00:12:22,190
that's what Django is all about right

00:12:19,610 --> 00:12:23,330
it's pretty straightforward so let's go

00:12:22,190 --> 00:12:27,020
ahead and take a look at that template

00:12:23,330 --> 00:12:30,830
and see what that's doing so if we go

00:12:27,020 --> 00:12:32,900
here into our index.html okay this is

00:12:30,830 --> 00:12:35,810
pretty straightforward we have just

00:12:32,900 --> 00:12:39,170
basically a thin wrapper around base dot

00:12:35,810 --> 00:12:44,420
HTML here so this is really the meat of

00:12:39,170 --> 00:12:46,070
where this template lies and here we

00:12:44,420 --> 00:12:48,560
have some meta tags and we have some

00:12:46,070 --> 00:12:51,590
configuration information there's a few

00:12:48,560 --> 00:12:54,980
things I want to point out first of all

00:12:51,590 --> 00:12:57,710
we use this to load in any static files

00:12:54,980 --> 00:13:02,510
and the static files that we're loading

00:12:57,710 --> 00:13:05,690
are our main CSS file and our index.js

00:13:02,510 --> 00:13:07,280
file and you know you might be saying

00:13:05,690 --> 00:13:09,980
yeah this is this is pretty basic this

00:13:07,280 --> 00:13:12,050
is like Django 101 but the fun thing

00:13:09,980 --> 00:13:14,900
about our envision app is this is the

00:13:12,050 --> 00:13:16,640
only view that we have and the only set

00:13:14,900 --> 00:13:18,680
of templates that we have so this is all

00:13:16,640 --> 00:13:21,589
the front-end logic that's done

00:13:18,680 --> 00:13:22,910
that's handled by Jango after this we

00:13:21,589 --> 00:13:25,070
basically pass it off to this index

00:13:22,910 --> 00:13:26,480
touch a s and that handles everything

00:13:25,070 --> 00:13:28,610
else so that will take care of routing

00:13:26,480 --> 00:13:31,310
making calls to the back end all the

00:13:28,610 --> 00:13:34,190
user interactions so think of this as a

00:13:31,310 --> 00:13:37,310
very basic handoff from Django over to

00:13:34,190 --> 00:13:39,730
the react side and this index touch is

00:13:37,310 --> 00:13:43,700
here this is our fully compiled

00:13:39,730 --> 00:13:46,160
JavaScript repository just minified and

00:13:43,700 --> 00:13:48,050
compiled using webpack so all our react

00:13:46,160 --> 00:13:55,580
code is loaded up as soon as you hit the

00:13:48,050 --> 00:13:58,610
Django app okay so now we're gonna go

00:13:55,580 --> 00:14:00,200
ahead and do a brief explanation of how

00:13:58,610 --> 00:14:02,330
the react Redux flow works and then

00:14:00,200 --> 00:14:05,089
we're gonna tie it in to how that works

00:14:02,330 --> 00:14:06,830
with Django so once again let's just do

00:14:05,089 --> 00:14:08,209
like a quick show of hands here so how

00:14:06,830 --> 00:14:11,570
many people have worked with react and

00:14:08,209 --> 00:14:12,980
redux together on the front end okay so

00:14:11,570 --> 00:14:14,930
less people but still actually really

00:14:12,980 --> 00:14:15,940
good amount I'm very happy about that it

00:14:14,930 --> 00:14:18,709
reacts awesome

00:14:15,940 --> 00:14:19,850
so for those of you don't know we'll

00:14:18,709 --> 00:14:21,500
walk through this really quickly and

00:14:19,850 --> 00:14:23,600
maybe this will be a good refresher if

00:14:21,500 --> 00:14:27,110
for some reason you forgot how it works

00:14:23,600 --> 00:14:29,270
but basically the main concept behind

00:14:27,110 --> 00:14:30,830
react and redux when they're combined

00:14:29,270 --> 00:14:33,110
together is you have this thing called a

00:14:30,830 --> 00:14:34,940
store and it's a data store it holds

00:14:33,110 --> 00:14:37,490
your data for your application pretty

00:14:34,940 --> 00:14:40,160
straightforward now your store contains

00:14:37,490 --> 00:14:43,190
pieces of State and these might be like

00:14:40,160 --> 00:14:45,110
you know what user you have logged in or

00:14:43,190 --> 00:14:48,410
what page you're currently viewing

00:14:45,110 --> 00:14:50,660
now that state defines the UI so you

00:14:48,410 --> 00:14:52,910
have components that are rendered based

00:14:50,660 --> 00:14:54,890
on properties or props passed down

00:14:52,910 --> 00:14:57,170
through the state so when you visit that

00:14:54,890 --> 00:15:00,260
page component you can see okay now I'm

00:14:57,170 --> 00:15:04,010
gonna show this page for this user with

00:15:00,260 --> 00:15:05,690
this color the UI then triggers what we

00:15:04,010 --> 00:15:07,279
call actions so you might do something

00:15:05,690 --> 00:15:10,279
like click a button or select a

00:15:07,279 --> 00:15:13,010
drop-down and this might trigger a redux

00:15:10,279 --> 00:15:16,070
action which can basically modify some

00:15:13,010 --> 00:15:18,620
data or make an RPC call so this right

00:15:16,070 --> 00:15:21,440
here in actions this is where we make

00:15:18,620 --> 00:15:23,930
the call to the Django side when we get

00:15:21,440 --> 00:15:26,450
any data back we send that to a reducer

00:15:23,930 --> 00:15:28,820
which basically just transforms the data

00:15:26,450 --> 00:15:31,250
and passes it back into the store and

00:15:28,820 --> 00:15:32,480
then the magic of react and redux is

00:15:31,250 --> 00:15:35,119
once the store is up

00:15:32,480 --> 00:15:37,879
it updates the state and the UI gets the

00:15:35,119 --> 00:15:39,589
new props so just like that we can go

00:15:37,879 --> 00:15:42,859
from clicking a button to receiving

00:15:39,589 --> 00:15:44,509
entirely new data and here's how that

00:15:42,859 --> 00:15:47,329
flow looks like for envision so a little

00:15:44,509 --> 00:15:49,429
bit more specific so we start off with

00:15:47,329 --> 00:15:52,189
rendering our page that the user has

00:15:49,429 --> 00:15:53,689
defined and at the start the page might

00:15:52,189 --> 00:15:56,899
not have any information it might be

00:15:53,689 --> 00:15:59,299
really basic but then once you click a

00:15:56,899 --> 00:16:01,819
button or trigger some request we kick

00:15:59,299 --> 00:16:04,970
off that WebSocket call and we call it

00:16:01,819 --> 00:16:07,579
get page in this case this call goes to

00:16:04,970 --> 00:16:09,410
the backend and hits a Django consumer

00:16:07,579 --> 00:16:12,199
which is basically a listener on the

00:16:09,410 --> 00:16:13,910
WebSocket channel and that's called get

00:16:12,199 --> 00:16:14,980
page as well so that's how these two

00:16:13,910 --> 00:16:17,509
relate to each other

00:16:14,980 --> 00:16:19,549
Django does it's magic and we'll process

00:16:17,509 --> 00:16:21,230
some data and maybe use some Python

00:16:19,549 --> 00:16:23,929
libraries to do some cool stuff there

00:16:21,230 --> 00:16:26,989
and we return that data and send it to

00:16:23,929 --> 00:16:29,689
our get page action this basically goes

00:16:26,989 --> 00:16:31,999
and tells our reducer to take that data

00:16:29,689 --> 00:16:34,879
we got from the Django side and add it

00:16:31,999 --> 00:16:37,069
to the new state then the components are

00:16:34,879 --> 00:16:40,039
automatically re-rendered for us and the

00:16:37,069 --> 00:16:42,019
page now has some new data so this is a

00:16:40,039 --> 00:16:43,939
pretty standard flow and all we've

00:16:42,019 --> 00:16:45,619
really added is this piece here where we

00:16:43,939 --> 00:16:49,009
send a little message to the Django

00:16:45,619 --> 00:16:51,829
back-end and so now we're going to go

00:16:49,009 --> 00:16:52,999
ahead and do another brief code example

00:16:51,829 --> 00:16:55,549
of what this looks like on the

00:16:52,999 --> 00:16:56,480
JavaScript side so again I apologize if

00:16:55,549 --> 00:16:57,619
you're not interested in seeing any

00:16:56,480 --> 00:16:59,329
JavaScript you're gonna have to sit

00:16:57,619 --> 00:17:05,409
through a little but it's pretty cool I

00:16:59,329 --> 00:17:09,079
swear so if we go into our app here

00:17:05,409 --> 00:17:10,699
here's our app component and again we

00:17:09,079 --> 00:17:11,839
can excuse all the react weather plate

00:17:10,699 --> 00:17:13,000
I'll just highlight the parts that I

00:17:11,839 --> 00:17:15,889
think are interesting

00:17:13,000 --> 00:17:18,049
so in our render method this basically

00:17:15,889 --> 00:17:19,370
tells us you know what kind of HTML

00:17:18,049 --> 00:17:21,679
content are we going to put on the page

00:17:19,370 --> 00:17:24,500
and these are the properties that were

00:17:21,679 --> 00:17:26,720
receiving from the backend so here's

00:17:24,500 --> 00:17:29,899
some really interesting ones socket and

00:17:26,720 --> 00:17:32,029
socket node are basically components

00:17:29,899 --> 00:17:33,919
that instantiate the web socket

00:17:32,029 --> 00:17:36,559
connection so they make that handshake

00:17:33,919 --> 00:17:38,899
that I was doing with Kendall earlier in

00:17:36,559 --> 00:17:42,710
order to upgrade the HTTP connection to

00:17:38,899 --> 00:17:44,389
a WebSockets connection this next piece

00:17:42,710 --> 00:17:46,070
of state here is called page loaded

00:17:44,389 --> 00:17:47,930
which is basically a boolean

00:17:46,070 --> 00:17:50,270
tells us if the page is loaded or if

00:17:47,930 --> 00:17:51,710
it's currently loading and lastly we

00:17:50,270 --> 00:17:53,960
have our page data which is a dictionary

00:17:51,710 --> 00:17:56,450
which basically has all the stuff that

00:17:53,960 --> 00:17:58,010
we want to display so that's the

00:17:56,450 --> 00:18:00,920
information we get from the state and

00:17:58,010 --> 00:18:02,540
then we can go through down here and say

00:18:00,920 --> 00:18:05,360
you know maybe we'll make some title

00:18:02,540 --> 00:18:07,190
text and we could maybe add some images

00:18:05,360 --> 00:18:09,590
to the page but only if we have page

00:18:07,190 --> 00:18:10,970
data so if we don't have any page data

00:18:09,590 --> 00:18:14,930
here we're just gonna skip this section

00:18:10,970 --> 00:18:17,930
entirely now when we get down to

00:18:14,930 --> 00:18:19,700
rendering the actual HTML content this

00:18:17,930 --> 00:18:22,090
here is pretty important so this is

00:18:19,700 --> 00:18:24,200
where that socket component actually

00:18:22,090 --> 00:18:26,000
instantiates the connection so as soon

00:18:24,200 --> 00:18:28,760
as you hit the page it's going to go

00:18:26,000 --> 00:18:31,040
ahead and do its job to connect us to

00:18:28,760 --> 00:18:33,740
the Django server with a WebSockets

00:18:31,040 --> 00:18:37,190
connection once that connection has been

00:18:33,740 --> 00:18:39,530
established we can come down here into

00:18:37,190 --> 00:18:41,660
this block and basically we're just

00:18:39,530 --> 00:18:43,970
gonna render you know a little little

00:18:41,660 --> 00:18:45,590
header tag a little button maybe another

00:18:43,970 --> 00:18:48,740
little button and they're gonna have

00:18:45,590 --> 00:18:50,570
some on click handlers now when we click

00:18:48,740 --> 00:18:53,270
these buttons we're gonna dispatch that

00:18:50,570 --> 00:18:54,680
action that we talked about so I can

00:18:53,270 --> 00:18:55,700
just really quickly go ahead and show

00:18:54,680 --> 00:18:58,880
you what that looks like on the

00:18:55,700 --> 00:19:00,860
JavaScript side we go back to our app

00:18:58,880 --> 00:19:04,040
container here and this is what contains

00:19:00,860 --> 00:19:06,770
the business logic and here we have the

00:19:04,040 --> 00:19:07,970
function called by the buttons so when

00:19:06,770 --> 00:19:09,980
you click a button it's going to call

00:19:07,970 --> 00:19:13,580
load page the first thing it's going to

00:19:09,980 --> 00:19:14,870
do is send a message to our or it's

00:19:13,580 --> 00:19:17,510
gonna send an action which is going to

00:19:14,870 --> 00:19:19,370
basically tell us hey let's set that

00:19:17,510 --> 00:19:21,040
page loaded to false the page is no

00:19:19,370 --> 00:19:23,840
longer loaded don't display anything and

00:19:21,040 --> 00:19:26,240
then it's gonna go ahead and dispatch a

00:19:23,840 --> 00:19:28,700
socket message so this is the WebSockets

00:19:26,240 --> 00:19:30,590
call here it's gonna dispatch a message

00:19:28,700 --> 00:19:33,310
called get page and it's gonna pass

00:19:30,590 --> 00:19:35,900
along a page ID pretty straightforward

00:19:33,310 --> 00:19:38,870
once it receives the response from the

00:19:35,900 --> 00:19:41,180
Django consumer then we'll go ahead and

00:19:38,870 --> 00:19:43,940
dispatch an action to set that data in

00:19:41,180 --> 00:19:45,650
the state and reload the page so when we

00:19:43,940 --> 00:19:47,360
do the demo in a second you'll see this

00:19:45,650 --> 00:19:49,340
happens incredibly fast but this is the

00:19:47,360 --> 00:19:52,250
entire round-trip that's happening in

00:19:49,340 --> 00:19:56,030
order to basically render some

00:19:52,250 --> 00:19:58,400
information from Django in react and now

00:19:56,030 --> 00:19:59,220
Kendall is going to go ahead I believe

00:19:58,400 --> 00:20:01,740
and

00:19:59,220 --> 00:20:03,600
about how this looks like on the Django

00:20:01,740 --> 00:20:10,049
side so what actually Django consumer

00:20:03,600 --> 00:20:13,980
does so we have this protocol called

00:20:10,049 --> 00:20:16,230
JSON RPC and so JSON RPC lets us have a

00:20:13,980 --> 00:20:19,289
nice interface for sending and receiving

00:20:16,230 --> 00:20:22,470
messages and what it provides us is an

00:20:19,289 --> 00:20:25,250
example like this you have an ID tag

00:20:22,470 --> 00:20:28,559
which lets the client the web browser

00:20:25,250 --> 00:20:31,289
set a ID for which when you send a

00:20:28,559 --> 00:20:33,330
message then the response you get back

00:20:31,289 --> 00:20:34,669
should have the same ID so you send a

00:20:33,330 --> 00:20:39,000
bunch of messages it helps you organize

00:20:34,669 --> 00:20:40,470
the responses the JSON RPC is the

00:20:39,000 --> 00:20:41,820
version and you can look online to see

00:20:40,470 --> 00:20:44,880
the difference between the different

00:20:41,820 --> 00:20:47,490
versions and here we're using 2.0 the

00:20:44,880 --> 00:20:48,750
method is the name of the Python method

00:20:47,490 --> 00:20:53,159
which we're going to call in the backend

00:20:48,750 --> 00:20:55,200
and the parameters are the page ID and

00:20:53,159 --> 00:20:58,830
so we're using this nice library called

00:20:55,200 --> 00:21:00,780
Django channels JSON RPC which is and

00:20:58,830 --> 00:21:02,970
we're subclassing from the Django

00:21:00,780 --> 00:21:05,039
channels WebSockets consumer so this is

00:21:02,970 --> 00:21:09,110
a main consumer which I showed in the

00:21:05,039 --> 00:21:12,299
block diagram above previous slide and

00:21:09,110 --> 00:21:15,900
the Django consumer will then return the

00:21:12,299 --> 00:21:18,900
JSON response and so here's our actual

00:21:15,900 --> 00:21:22,320
get page method as you can see here we

00:21:18,900 --> 00:21:26,370
have subclass from the JSON RPC consumer

00:21:22,320 --> 00:21:28,820
and made a demo RPC consumer and so all

00:21:26,370 --> 00:21:32,690
you have to do is create a decorator at

00:21:28,820 --> 00:21:35,070
RPC method and then define your

00:21:32,690 --> 00:21:38,640
WebSockets consumer method so basically

00:21:35,070 --> 00:21:41,640
here we define get page it takes in the

00:21:38,640 --> 00:21:44,730
page ID and it returns a dictionary of

00:21:41,640 --> 00:21:49,289
the information you need to render a

00:21:44,730 --> 00:21:53,600
page on the front end and so now Henry

00:21:49,289 --> 00:21:56,280
will show a quick demo of the WebSockets

00:21:53,600 --> 00:21:58,190
alright so we're gonna do a live demo so

00:21:56,280 --> 00:22:03,720
bear with me hopefully everything works

00:21:58,190 --> 00:22:05,820
ok so the page is loaded this is good so

00:22:03,720 --> 00:22:09,680
what I'm gonna do I have this up here

00:22:05,820 --> 00:22:12,770
you all can see that right ok cool so

00:22:09,680 --> 00:22:15,470
we have open here basically the

00:22:12,770 --> 00:22:19,120
developer tools console and the reason

00:22:15,470 --> 00:22:22,510
why this is open actually sorry that's

00:22:19,120 --> 00:22:24,440
let me get a tiny bit smaller

00:22:22,510 --> 00:22:27,140
all right okay

00:22:24,440 --> 00:22:28,960
just that we can click through it so

00:22:27,140 --> 00:22:31,610
basically what we're gonna do here is

00:22:28,960 --> 00:22:33,110
show the actual WebSockets calls that

00:22:31,610 --> 00:22:35,090
happen while this application is running

00:22:33,110 --> 00:22:37,100
so you can do this yourself

00:22:35,090 --> 00:22:38,600
this is available to you it's a handy

00:22:37,100 --> 00:22:41,210
little tool and if you're writing any

00:22:38,600 --> 00:22:42,710
WebSocket applications it's incredibly

00:22:41,210 --> 00:22:45,740
useful to see the responses you're

00:22:42,710 --> 00:22:47,570
getting so when you open your developer

00:22:45,740 --> 00:22:49,160
tools in chrome it's in the network tab

00:22:47,570 --> 00:22:52,520
under WS here

00:22:49,160 --> 00:22:55,040
WebSockets so first things first when I

00:22:52,520 --> 00:22:56,720
went ahead and loaded the page we

00:22:55,040 --> 00:22:58,700
already got something in here so let's

00:22:56,720 --> 00:22:59,440
go ahead and investigate this and see

00:22:58,700 --> 00:23:04,460
what this is

00:22:59,440 --> 00:23:07,040
so this WebSocket message is actually we

00:23:04,460 --> 00:23:08,510
have here a 101 switching protocols so

00:23:07,040 --> 00:23:10,280
this is that handshake upgrade that I

00:23:08,510 --> 00:23:12,590
was talking about as soon as we load the

00:23:10,280 --> 00:23:14,960
page and enter the application we switch

00:23:12,590 --> 00:23:17,360
over from HTTP and open that persistent

00:23:14,960 --> 00:23:19,310
WebSocket connection and here you can

00:23:17,360 --> 00:23:21,410
see that indeed we were connected to

00:23:19,310 --> 00:23:25,370
Daphne the server so everything is

00:23:21,410 --> 00:23:27,830
working as intended so now what we're

00:23:25,370 --> 00:23:29,600
going to do is go ahead and click a

00:23:27,830 --> 00:23:31,400
button and start that flow that I was

00:23:29,600 --> 00:23:32,930
talking about earlier so just again

00:23:31,400 --> 00:23:35,060
what's gonna happen is I'm gonna click

00:23:32,930 --> 00:23:37,570
the button we actually have a time sleep

00:23:35,060 --> 00:23:40,820
on it but it's still really fast so

00:23:37,570 --> 00:23:43,040
it'll be pretty quickly like blink if

00:23:40,820 --> 00:23:45,170
you miss it but basically when you click

00:23:43,040 --> 00:23:47,630
on this button we're gonna go ahead set

00:23:45,170 --> 00:23:50,060
the page to loading go get some data

00:23:47,630 --> 00:23:54,770
from the Django consumer and return it

00:23:50,060 --> 00:23:57,680
to the front-end and render it so BAM we

00:23:54,770 --> 00:23:59,720
got some company logos and if you look

00:23:57,680 --> 00:24:02,450
here we got some WebSockets information

00:23:59,720 --> 00:24:05,000
so we can go ahead and inspect that so

00:24:02,450 --> 00:24:07,880
here sure enough this is our get page

00:24:05,000 --> 00:24:10,280
WebSocket method that was sent out you

00:24:07,880 --> 00:24:12,890
can see like the JSON RPC number the

00:24:10,280 --> 00:24:15,980
method name and sure enough we sent over

00:24:12,890 --> 00:24:19,310
the page ID and then if we actually go

00:24:15,980 --> 00:24:22,460
to the terminal we have printing in the

00:24:19,310 --> 00:24:23,270
consumer get page so indeed our Django

00:24:22,460 --> 00:24:25,460
consumer picked up that

00:24:23,270 --> 00:24:27,560
message did some processing and returned

00:24:25,460 --> 00:24:30,110
us some image links and a title to

00:24:27,560 --> 00:24:33,050
display and you can see that here in the

00:24:30,110 --> 00:24:35,690
response so if we look at the result BAM

00:24:33,050 --> 00:24:38,420
there's the the images and the page name

00:24:35,690 --> 00:24:39,860
and this actually it works on the other

00:24:38,420 --> 00:24:42,650
page to you so we can kind of go ahead

00:24:39,860 --> 00:24:44,510
and toggle between pages and this is

00:24:42,650 --> 00:24:47,360
like the basic functioning of a

00:24:44,510 --> 00:24:50,090
standards WebSockets loop now you're

00:24:47,360 --> 00:24:51,650
probably wondering isn't this like

00:24:50,090 --> 00:24:53,630
extremely basic I couldn't we just do

00:24:51,650 --> 00:24:55,970
this with HTTP and views like why do we

00:24:53,630 --> 00:24:59,060
need WebSockets to to load images you

00:24:55,970 --> 00:25:00,140
know I can do that my sleep so if you

00:24:59,060 --> 00:25:02,390
thought that you wouldn't be wrong

00:25:00,140 --> 00:25:05,960
because yeah this is a pretty basic

00:25:02,390 --> 00:25:08,030
example but as we'll explain as we go on

00:25:05,960 --> 00:25:09,860
where WebSockets really shines is in

00:25:08,030 --> 00:25:12,500
those other kind of interactions where

00:25:09,860 --> 00:25:14,600
the server can actually push data when

00:25:12,500 --> 00:25:15,830
it's ready to the front end so here

00:25:14,600 --> 00:25:19,070
we're kind of doing a standard request

00:25:15,830 --> 00:25:20,900
response but for example because we have

00:25:19,070 --> 00:25:23,930
that persistent connection open we could

00:25:20,900 --> 00:25:25,310
actually you know send the request to

00:25:23,930 --> 00:25:26,780
the server and the server could go do

00:25:25,310 --> 00:25:28,820
whatever it wants for 10 minutes and

00:25:26,780 --> 00:25:29,990
push a response when it's ready and the

00:25:28,820 --> 00:25:32,240
front end doesn't have to sit there

00:25:29,990 --> 00:25:36,080
poling for it but we'll get into more

00:25:32,240 --> 00:25:37,730
that in a little bit so now Kendall's

00:25:36,080 --> 00:25:44,780
going to walk us through how state

00:25:37,730 --> 00:25:48,170
management works in our envision app so

00:25:44,780 --> 00:25:51,730
here's the diagram we had again with

00:25:48,170 --> 00:25:53,810
ambition we have a stateless API so

00:25:51,730 --> 00:25:57,380
basically what this means is we're not

00:25:53,810 --> 00:26:01,220
storing this state in the Python code we

00:25:57,380 --> 00:26:04,520
have the date data backed up by jingo

00:26:01,220 --> 00:26:08,300
models so basically the nice thing about

00:26:04,520 --> 00:26:10,340
this having the separate datastore for

00:26:08,300 --> 00:26:13,180
example Postgres is that we can allow

00:26:10,340 --> 00:26:15,080
the view function the consume the

00:26:13,180 --> 00:26:17,540
WebSocket consumer and any other

00:26:15,080 --> 00:26:20,960
background processes to talk to the same

00:26:17,540 --> 00:26:24,650
database and share data through the

00:26:20,960 --> 00:26:27,260
database and also as Henry mentioned we

00:26:24,650 --> 00:26:30,250
store minimal state on the front end as

00:26:27,260 --> 00:26:33,620
well and re-render when we have a new

00:26:30,250 --> 00:26:36,290
information on the page the other nice

00:26:33,620 --> 00:26:39,350
thing about having the state on the

00:26:36,290 --> 00:26:41,870
having the background processes is

00:26:39,350 --> 00:26:44,650
basically we can send notifications up

00:26:41,870 --> 00:26:49,250
from after running a long task as well

00:26:44,650 --> 00:26:52,370
and also another place where we're

00:26:49,250 --> 00:26:55,220
storing another database we're using is

00:26:52,370 --> 00:26:57,350
Redis and so the channel layer is

00:26:55,220 --> 00:27:00,760
actually backed by Redis data store

00:26:57,350 --> 00:27:03,140
basically so this will it manages the

00:27:00,760 --> 00:27:05,929
recipient so when you have the channel

00:27:03,140 --> 00:27:08,090
layer you want to know who you're

00:27:05,929 --> 00:27:11,240
sending the messages to so this channel

00:27:08,090 --> 00:27:14,870
layer allows us to broadcast the

00:27:11,240 --> 00:27:16,820
messages to multiple web browsers for

00:27:14,870 --> 00:27:19,250
example if you're connected to the same

00:27:16,820 --> 00:27:22,820
page and they all want to be updated at

00:27:19,250 --> 00:27:24,260
the same time so now Henry will talk

00:27:22,820 --> 00:27:28,760
about some of the challenges that we

00:27:24,260 --> 00:27:30,250
faced in developing envision alrighty so

00:27:28,760 --> 00:27:33,950
this is what I was alluding to earlier

00:27:30,250 --> 00:27:37,460
this is asynchronous loading of charts

00:27:33,950 --> 00:27:39,050
tables and other big data so in the

00:27:37,460 --> 00:27:42,020
example that I gave and in our first

00:27:39,050 --> 00:27:44,570
draft of envision our WebSockets calls

00:27:42,020 --> 00:27:47,660
basically rebuilt the entire page and

00:27:44,570 --> 00:27:51,050
the reason why that was happening is we

00:27:47,660 --> 00:27:54,559
had a page object written in Python and

00:27:51,050 --> 00:27:57,170
we sent a WebSockets call get page to go

00:27:54,559 --> 00:27:59,450
get that information we then serialized

00:27:57,170 --> 00:28:02,059
that page and send the entire thing up

00:27:59,450 --> 00:28:03,830
and while that works great for really

00:28:02,059 --> 00:28:06,800
small pages you can imagine that that

00:28:03,830 --> 00:28:08,240
might be really painful if the content

00:28:06,800 --> 00:28:10,940
that you want to display on the page is

00:28:08,240 --> 00:28:12,470
extremely large or might take some

00:28:10,940 --> 00:28:15,200
additional processing based on the

00:28:12,470 --> 00:28:16,670
requests that came in so it took us a

00:28:15,200 --> 00:28:18,380
while but we thought about some

00:28:16,670 --> 00:28:20,120
interesting ways around this and this is

00:28:18,380 --> 00:28:23,780
really where we decided to take

00:28:20,120 --> 00:28:25,880
advantage of WebSockets so we created

00:28:23,780 --> 00:28:28,160
this publish/subscribe model and I have

00:28:25,880 --> 00:28:29,750
subscribin quotes because we took

00:28:28,160 --> 00:28:31,670
inspiration from this kind of model but

00:28:29,750 --> 00:28:33,290
it's not actually how it's working well

00:28:31,670 --> 00:28:36,320
there's no polling or subscriptions

00:28:33,290 --> 00:28:37,760
going on instead what we do is when we

00:28:36,320 --> 00:28:40,850
send that data to the front-end for the

00:28:37,760 --> 00:28:43,700
first time we might send up say a pie

00:28:40,850 --> 00:28:46,250
chart and it has no data associated with

00:28:43,700 --> 00:28:48,440
it originally but we can define a data

00:28:46,250 --> 00:28:49,929
source which is basically like a key so

00:28:48,440 --> 00:28:54,009
let's say we send up a pie

00:28:49,929 --> 00:28:55,720
chart and has this datasource key hi so

00:28:54,009 --> 00:28:57,580
when we loaded the page we might have

00:28:55,720 --> 00:29:00,639
some content that is displayed like a

00:28:57,580 --> 00:29:02,980
title or some fields and instead of

00:29:00,639 --> 00:29:04,539
trying to wait and display this pie

00:29:02,980 --> 00:29:07,600
chart when it's finished loading or

00:29:04,539 --> 00:29:10,389
processing we can just display a blank

00:29:07,600 --> 00:29:12,639
box or maybe a loading spinner something

00:29:10,389 --> 00:29:15,309
that indicates that the chart is yet to

00:29:12,639 --> 00:29:16,659
come and then what we can do is we can

00:29:15,309 --> 00:29:19,179
actually manage that processing

00:29:16,659 --> 00:29:21,789
asynchronously on the Django side so

00:29:19,179 --> 00:29:24,610
this is where we can use subprocesses

00:29:21,789 --> 00:29:26,740
workers additional threads or even

00:29:24,610 --> 00:29:29,190
something like celery to basically

00:29:26,740 --> 00:29:31,929
handle some additional processing and

00:29:29,190 --> 00:29:34,299
maybe it'll take a really large dataset

00:29:31,929 --> 00:29:36,399
and condense it down use a library like

00:29:34,299 --> 00:29:38,409
plot laid to create this beautiful chart

00:29:36,399 --> 00:29:40,990
and then serialize it and send it up

00:29:38,409 --> 00:29:42,369
when it's ready and the way that it's

00:29:40,990 --> 00:29:44,860
going to send it back up is through a

00:29:42,369 --> 00:29:48,580
different RPC method we created called

00:29:44,860 --> 00:29:49,779
refresh widget so this call is kind of

00:29:48,580 --> 00:29:52,179
the inverse of what I was demoing

00:29:49,779 --> 00:29:53,590
earlier where the server is just sending

00:29:52,179 --> 00:29:56,169
a message to the front-end without any

00:29:53,590 --> 00:29:59,169
previous requests this wouldn't be

00:29:56,169 --> 00:30:00,759
possible in HTTP so the server whenever

00:29:59,169 --> 00:30:03,129
it's finished can just send up this

00:30:00,759 --> 00:30:05,230
serialized chart information along with

00:30:03,129 --> 00:30:08,169
that key pie that we mentioned earlier

00:30:05,230 --> 00:30:10,619
and the front-end will receive this data

00:30:08,169 --> 00:30:12,999
and can basically go through the dom

00:30:10,619 --> 00:30:15,399
find the element that was rendered with

00:30:12,999 --> 00:30:17,710
that datasource key and repopulate it

00:30:15,399 --> 00:30:19,990
with this data so you can have a case

00:30:17,710 --> 00:30:21,669
where you see some of the page loaded

00:30:19,990 --> 00:30:24,279
instantly and then other pieces come in

00:30:21,669 --> 00:30:25,840
over time as processing is finished this

00:30:24,279 --> 00:30:27,940
is incredibly useful for the kind of

00:30:25,840 --> 00:30:29,499
work that we do the software that I Asti

00:30:27,940 --> 00:30:31,389
is built on involves a lot of machine

00:30:29,499 --> 00:30:33,549
learning algorithms that can take hours

00:30:31,389 --> 00:30:35,649
or sometimes days to run when we're

00:30:33,549 --> 00:30:38,860
talking about datasets that are a

00:30:35,649 --> 00:30:40,299
million columns by a million rows so it

00:30:38,860 --> 00:30:41,889
was essential for us to be able to have

00:30:40,299 --> 00:30:43,179
this asynchronous loading and it could

00:30:41,889 --> 00:30:48,460
really only be accomplished with

00:30:43,179 --> 00:30:51,519
WebSockets okay so do you think we have

00:30:48,460 --> 00:30:54,369
time to do a quick demo of what the

00:30:51,519 --> 00:30:56,850
actual application looks like Kendall's

00:30:54,369 --> 00:31:02,799
going to go ahead and show that to you

00:30:56,850 --> 00:31:03,730
sure so here's a demo of our ast here

00:31:02,799 --> 00:31:06,039
you can see on the

00:31:03,730 --> 00:31:09,309
we have well we have the application

00:31:06,039 --> 00:31:13,299
which is in this case sample app we have

00:31:09,309 --> 00:31:16,750
this navigation bar it's step based

00:31:13,299 --> 00:31:19,299
workflow so we were just showing for

00:31:16,750 --> 00:31:21,880
example a fields page a blocks page in

00:31:19,299 --> 00:31:24,880
containers page and then mixed fields in

00:31:21,880 --> 00:31:29,679
blocks and so I can type in something

00:31:24,880 --> 00:31:34,720
here a Kindle and then fill out a form I

00:31:29,679 --> 00:31:37,809
can upload a file and this is basically

00:31:34,720 --> 00:31:39,309
the react version of a django form that

00:31:37,809 --> 00:31:43,929
we would instantiate on the backend

00:31:39,309 --> 00:31:46,389
basically and then we click OK and then

00:31:43,929 --> 00:31:50,470
you can see some progress being sent up

00:31:46,389 --> 00:31:52,330
and then loading the next page and here

00:31:50,470 --> 00:31:55,570
you can see an example of some of the

00:31:52,330 --> 00:31:57,460
other components which for which Henry

00:31:55,570 --> 00:32:01,090
described basically for each of these

00:31:57,460 --> 00:32:05,649
components for example a table another

00:32:01,090 --> 00:32:08,139
table an image markdown we have both the

00:32:05,649 --> 00:32:12,159
Python component and then a reaction

00:32:08,139 --> 00:32:14,169
component so the the difficult part is

00:32:12,159 --> 00:32:16,360
the first time is we have to develop

00:32:14,169 --> 00:32:19,210
this pair of components so it's a bit

00:32:16,360 --> 00:32:20,769
extra work but then in the end the

00:32:19,210 --> 00:32:22,659
result is of the data scientist who

00:32:20,769 --> 00:32:24,429
wants to instantiate these just needs to

00:32:22,659 --> 00:32:26,620
write some Python code to instantiate a

00:32:24,429 --> 00:32:28,720
react chart so this is really powerful

00:32:26,620 --> 00:32:31,590
because in the data scientists doesn't

00:32:28,720 --> 00:32:35,830
need to know JavaScript to develop these

00:32:31,590 --> 00:32:42,960
components and here's an example of some

00:32:35,830 --> 00:32:45,760
other charts that we can show and some

00:32:42,960 --> 00:32:49,710
containers so we can have different

00:32:45,760 --> 00:32:54,220
styling of the containers as well and

00:32:49,710 --> 00:32:56,769
showing hiding enabled through so in a

00:32:54,220 --> 00:32:59,230
lot of cases to enable these we have to

00:32:56,769 --> 00:33:02,080
provide extra parameters in our Python

00:32:59,230 --> 00:33:07,570
objects so if we want this container to

00:33:02,080 --> 00:33:09,039
be be able to show and hide this

00:33:07,570 --> 00:33:12,190
container we have to have a parameter

00:33:09,039 --> 00:33:15,080
which lets you set this configuration on

00:33:12,190 --> 00:33:19,399
the front end as well

00:33:15,080 --> 00:33:21,379
and then on the last page see mixed

00:33:19,399 --> 00:33:23,690
fields you can see here's an example

00:33:21,379 --> 00:33:29,149
where we can intermix like both the

00:33:23,690 --> 00:33:34,460
Django form field as well as some images

00:33:29,149 --> 00:33:37,820
and tables so I think that's it for the

00:33:34,460 --> 00:33:43,970
demo yeah do you guys have any questions

00:33:37,820 --> 00:33:45,590
on the demo or the yes or you know like

00:33:43,970 --> 00:33:47,509
a WebSocket I don't know the connection

00:33:45,590 --> 00:33:50,330
being dropped and and the client like

00:33:47,509 --> 00:33:52,909
waiting for a response that never never

00:33:50,330 --> 00:33:56,239
got here or or what if the client will

00:33:52,909 --> 00:33:58,970
like close the tab after or something

00:33:56,239 --> 00:34:00,799
like that yeah so yeah a lot I mean this

00:33:58,970 --> 00:34:03,139
happens so the question is if what

00:34:00,799 --> 00:34:04,639
happen to do own a WebSockets drops so

00:34:03,139 --> 00:34:06,409
yeah a lot of times like you you know

00:34:04,639 --> 00:34:08,899
you have to sometimes refresh the page

00:34:06,409 --> 00:34:10,760
and so then it'll Rhian instantiate the

00:34:08,899 --> 00:34:12,589
WebSockets connection but then the nice

00:34:10,760 --> 00:34:14,629
thing is since we're a database fact if

00:34:12,589 --> 00:34:16,429
you go to the page okay so Henry

00:34:14,629 --> 00:34:18,859
mentioned this previously but we're

00:34:16,429 --> 00:34:23,169
using react to route for the URLs so

00:34:18,859 --> 00:34:26,240
this actually we're still loading the

00:34:23,169 --> 00:34:29,389
index J us here but you can see the URL

00:34:26,240 --> 00:34:32,839
is objective slash 14 so this will tell

00:34:29,389 --> 00:34:35,419
react okay we need to get this this

00:34:32,839 --> 00:34:36,260
objective 4 and maybe this page number

00:34:35,419 --> 00:34:39,349
00:34:36,260 --> 00:34:41,000
so then if you refresh your browser then

00:34:39,349 --> 00:34:43,790
you can go back to the same page because

00:34:41,000 --> 00:34:45,200
the you're fetching the data for the

00:34:43,790 --> 00:34:47,379
page from the database and you know

00:34:45,200 --> 00:34:50,119
which which page you're on basically

00:34:47,379 --> 00:34:53,869
hello are there are there any special

00:34:50,119 --> 00:34:57,650
considerations regarding authentication

00:34:53,869 --> 00:35:01,730
and session that comes into play with

00:34:57,650 --> 00:35:03,829
channels yes so there's there's a lot

00:35:01,730 --> 00:35:06,079
it's a really really complicated topic

00:35:03,829 --> 00:35:07,490
and maybe maybe next year at django con

00:35:06,079 --> 00:35:10,910
we can talk about authentication with

00:35:07,490 --> 00:35:12,440
channels but you know in brief the one

00:35:10,910 --> 00:35:15,140
thing that you want to keep track of is

00:35:12,440 --> 00:35:17,510
basically when you create a session or

00:35:15,140 --> 00:35:20,660
get some cookies you will want to

00:35:17,510 --> 00:35:23,569
recreate the WebSocket connection using

00:35:20,660 --> 00:35:26,720
those cookies so that's kind of one of

00:35:23,569 --> 00:35:28,880
the issues that we've had to face is you

00:35:26,720 --> 00:35:30,380
know making sure that basically you

00:35:28,880 --> 00:35:32,930
Stan she ate the WebSocket connection

00:35:30,380 --> 00:35:34,970
you might hit a specific endpoint or

00:35:32,930 --> 00:35:36,950
enter some data on the page and it

00:35:34,970 --> 00:35:40,279
authenticates you and creates a Django

00:35:36,950 --> 00:35:42,170
user object and provides a session or

00:35:40,279 --> 00:35:43,819
some cookies basically some way to track

00:35:42,170 --> 00:35:45,950
that you're logged in and you actually

00:35:43,819 --> 00:35:48,079
have to recreate the WebSocket

00:35:45,950 --> 00:35:49,519
connection with that and make sure that

00:35:48,079 --> 00:35:53,210
that information is passed with every

00:35:49,519 --> 00:35:54,529
request so that is so something we're

00:35:53,210 --> 00:35:57,349
kind of building out on the envision

00:35:54,529 --> 00:35:58,880
side but another thing to note is that

00:35:57,349 --> 00:36:02,059
that's actually the only other place

00:35:58,880 --> 00:36:03,440
where we use a Django endpoint so I lied

00:36:02,059 --> 00:36:05,089
earlier when I said that that was the

00:36:03,440 --> 00:36:07,730
only view we actually have one more

00:36:05,089 --> 00:36:09,049
which is for logging in because that's

00:36:07,730 --> 00:36:11,089
another thing that Django provides us

00:36:09,049 --> 00:36:13,609
that's great is the user system and

00:36:11,089 --> 00:36:16,279
authentication and so we actually use a

00:36:13,609 --> 00:36:18,619
standard HTTP authentication endpoint

00:36:16,279 --> 00:36:20,539
for Django and then once that is

00:36:18,619 --> 00:36:23,900
established we recreate the WebSocket

00:36:20,539 --> 00:36:26,089
connection and make sure that those

00:36:23,900 --> 00:36:27,680
cookies so that authenticate a trace of

00:36:26,089 --> 00:36:30,410
that authenticated user is present in

00:36:27,680 --> 00:36:31,819
every single call kind of curious how

00:36:30,410 --> 00:36:34,400
you deal with load balancing in a

00:36:31,819 --> 00:36:36,559
situation let's say you've got two

00:36:34,400 --> 00:36:38,960
clients that are accessing the same

00:36:36,559 --> 00:36:41,569
server and all of a sudden one client

00:36:38,960 --> 00:36:44,269
starts up a task that's gonna be like

00:36:41,569 --> 00:36:46,220
really demanding on the server now the

00:36:44,269 --> 00:36:48,500
other guy is gonna be waiting and I

00:36:46,220 --> 00:36:50,210
don't know how you can dynamically load

00:36:48,500 --> 00:36:53,089
balance basically in a channel type

00:36:50,210 --> 00:36:59,059
environment yeah so for load balancing

00:36:53,089 --> 00:37:01,789
as far as the tasks we the the tasks

00:36:59,059 --> 00:37:04,579
between the front-end browsers and the

00:37:01,789 --> 00:37:08,450
Django app should be pretty light most

00:37:04,579 --> 00:37:11,480
we have a separate API a separate

00:37:08,450 --> 00:37:15,230
machine learning platform where most of

00:37:11,480 --> 00:37:17,029
the big data processing happens like in

00:37:15,230 --> 00:37:19,250
Hadoop so this is kind of asynchronous

00:37:17,029 --> 00:37:21,799
this is why it's nice to have WebSockets

00:37:19,250 --> 00:37:25,190
because we can have like for example a

00:37:21,799 --> 00:37:27,230
celery worker waiting on a big task and

00:37:25,190 --> 00:37:30,109
then when the when the task is done on

00:37:27,230 --> 00:37:31,819
the on and and so there's an HTTP API so

00:37:30,109 --> 00:37:33,890
maybe it's it's it's actually waiting on

00:37:31,819 --> 00:37:36,470
an HTTP response but then when the

00:37:33,890 --> 00:37:39,519
celery worker is kids it gets the

00:37:36,470 --> 00:37:42,260
response back it can send a WebSockets

00:37:39,519 --> 00:37:44,690
notification back to the two browsers

00:37:42,260 --> 00:37:48,940
okay this long-running tusk is done so

00:37:44,690 --> 00:37:54,440
we offload the work to our our platform

00:37:48,940 --> 00:37:56,450
for four big tasks yeah hello thanks for

00:37:54,440 --> 00:37:57,920
the great talk I really think this is

00:37:56,450 --> 00:37:59,990
really cool

00:37:57,920 --> 00:38:03,590
my question is for all these data

00:37:59,990 --> 00:38:05,210
components are they served the mark-up

00:38:03,590 --> 00:38:08,960
and the logic for that are they served

00:38:05,210 --> 00:38:14,420
initially or are they served as a

00:38:08,960 --> 00:38:16,520
response to the RPC request and somehow

00:38:14,420 --> 00:38:19,990
that component is injected into the

00:38:16,520 --> 00:38:22,970
reactor yes so it's more like the latter

00:38:19,990 --> 00:38:24,950
basically as Kendall is mentioning we

00:38:22,970 --> 00:38:27,170
use the react routers when you visit a

00:38:24,950 --> 00:38:29,000
page with a specific route it makes that

00:38:27,170 --> 00:38:32,030
get page call to the backend and

00:38:29,000 --> 00:38:33,890
essentially if you were to break at that

00:38:32,030 --> 00:38:35,440
point in JavaScript or pause on a

00:38:33,890 --> 00:38:38,600
breakpoint you would see a blank page

00:38:35,440 --> 00:38:41,420
and that data basically you would send

00:38:38,600 --> 00:38:43,520
the request to the consumer side it

00:38:41,420 --> 00:38:46,520
would process the data and serialize the

00:38:43,520 --> 00:38:48,340
whole page as a result and then that's

00:38:46,520 --> 00:38:52,400
returned up to the front end and then

00:38:48,340 --> 00:38:53,690
load it in there so essentially that's

00:38:52,400 --> 00:38:55,430
why we try and keep the pages as

00:38:53,690 --> 00:38:57,110
lightweight as possible because if you

00:38:55,430 --> 00:38:59,240
were to refresh the page or hit another

00:38:57,110 --> 00:39:01,670
page you're doing another round trip

00:38:59,240 --> 00:39:04,430
through the consumer side that's really

00:39:01,670 --> 00:39:07,190
cool thank you thanks for the talk so

00:39:04,430 --> 00:39:17,330
how do you write tests for this kind of

00:39:07,190 --> 00:39:20,690
thing good question so okay so for

00:39:17,330 --> 00:39:22,670
testing we had yeah it was it's kind of

00:39:20,690 --> 00:39:24,740
it is kind of tricky to test we we did a

00:39:22,670 --> 00:39:27,350
couple of things for unit tests we mark

00:39:24,740 --> 00:39:30,290
out the WebSockets server so we have

00:39:27,350 --> 00:39:33,860
this mock object which mimics the server

00:39:30,290 --> 00:39:36,560
in addition to this we have this we call

00:39:33,860 --> 00:39:39,350
it the driver so a Python WebSockets

00:39:36,560 --> 00:39:41,570
client to also test out against a live

00:39:39,350 --> 00:39:43,310
like Django app which is which you can

00:39:41,570 --> 00:39:45,830
test in addition to this we have

00:39:43,310 --> 00:39:48,290
selenium tests so it's it is pretty

00:39:45,830 --> 00:39:52,490
complicated to test but we we are able

00:39:48,290 --> 00:39:55,190
to test using these three methods and it

00:39:52,490 --> 00:39:57,950
is important to have a lot of testing

00:39:55,190 --> 00:39:59,900
assuming with WebSocket you have kind of

00:39:57,950 --> 00:40:02,089
a back and forth different stage

00:39:59,900 --> 00:40:10,369
carrying over between the conversations

00:40:02,089 --> 00:40:16,190
how do you emulate those so the question

00:40:10,369 --> 00:40:19,359
sorry question yeah for WebSocket it's

00:40:16,190 --> 00:40:24,190
kind of a back and forth message passing

00:40:19,359 --> 00:40:28,479
how do you emulate those metaphors and

00:40:24,190 --> 00:40:33,229
maybe even in the interruption of the

00:40:28,479 --> 00:40:35,380
connection yes so we for our unit

00:40:33,229 --> 00:40:38,539
testing we actually mock out all the

00:40:35,380 --> 00:40:41,779
calls and will typically test out for

00:40:38,539 --> 00:40:43,460
example like one method at a time so

00:40:41,779 --> 00:40:46,519
like using unit test principles we can

00:40:43,460 --> 00:40:48,499
basically mock out the RPC client and

00:40:46,519 --> 00:40:50,869
there's some boilerplate that you can

00:40:48,499 --> 00:40:53,029
look into that basically sets up a fake

00:40:50,869 --> 00:40:55,970
WebSocket connection so you can just

00:40:53,029 --> 00:40:57,680
kind of test that indeed the right

00:40:55,970 --> 00:41:00,440
parameters are being sent over the

00:40:57,680 --> 00:41:02,119
connection in terms of testing the full

00:41:00,440 --> 00:41:04,390
back and forth connection that's what

00:41:02,119 --> 00:41:06,979
our selenium tests handles so basically

00:41:04,390 --> 00:41:10,549
we have a bunch of sample applications

00:41:06,979 --> 00:41:13,249
that test that okay if I do indeed hit

00:41:10,549 --> 00:41:15,469
this page then this thing gets called

00:41:13,249 --> 00:41:18,650
and the page gets rear-ended with this

00:41:15,469 --> 00:41:21,079
data so we kind of if that makes sense

00:41:18,650 --> 00:41:23,390
yeah we we test each method individually

00:41:21,079 --> 00:41:24,829
with all the RPC stuff mocked out and

00:41:23,390 --> 00:41:27,950
then we test the full end-to-end

00:41:24,829 --> 00:41:31,579
application using a lie of selenium test

00:41:27,950 --> 00:41:32,290
so now at the end give a round of

00:41:31,579 --> 00:41:39,849
applause

00:41:32,290 --> 00:41:39,849

YouTube URL: https://www.youtube.com/watch?v=eDUg1h3mxbA


