Title: DjangoCon US 2018 - Building Workflows With Celery by Josue Balandrano Coronel
Publication date: 2018-11-08
Playlist: DjangoCon US 2018
Description: 
	Task Queues is a topic which most developers will eventually have to dive into, specially in todayâ€™s web development world. The idea is really simple: whenever one has any functionality which might take too long to perform, one can spawn a process which will take care of this functionality without having to block the appâ€™s main loop. A task queue will use worker processes to execute these long-running tasks and the user does not have to wait until the task is done. Instead, an acknowledged message is presented to de user while the task is executed in the background. This concept is really important when building web applications. HTTP Requests have timeout and making the user wait a long time for something to finish is not a good user experience practice. Usually, these tasks are used in groups creating a workflow where the work is distributed into smaller tasks.

Celery is usually the first project one encounters when searching for task queues and Django. I have been using Celery for over four years. The Celery project is one of the most robust task queues out there. It is certainly not the only task queue. And, it can be difficult planning the correct architecture for a specific workflow. This talk will explain enough of Celeryâ€™s basics to understand how to build workflows with Celery.

Building workflows with Celery is never straight forward. This is mainly because Celery offers the building blocks to build workflows but it tries to move out of the way. By not being too intrusive, Celery allows building complex workflows. I will explain common patters and tips to successfully use celery to build workflow of different complexities.

This talk was presented at: https://2018.djangocon.us/talk/building-workflows-with-celery/

LINKS:
Follow Josue Balandrano Coronel ðŸ‘‡
On Twitter: https://twitter.com/rmcomplexity
Official homepage: https://rmcomplexity.com

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,050 --> 00:00:07,709
[Music]

00:00:15,529 --> 00:00:26,910
when I start this I promise you this

00:00:20,220 --> 00:00:30,150
talk will be in English in traditional

00:00:26,910 --> 00:00:32,700
Senor Josue Coronel and TT Louis who

00:00:30,150 --> 00:00:41,370
this representation building workflows

00:00:32,700 --> 00:00:46,530
with salary so yeah well welcome Josue :

00:00:41,370 --> 00:00:49,680
n for his talk in English how's it going

00:00:46,530 --> 00:00:51,960
everybody so let's start well first the

00:00:49,680 --> 00:00:53,730
app my name is josue vallavan Coronel I

00:00:51,960 --> 00:00:57,690
work for the Texas Advanced Computer

00:00:53,730 --> 00:01:00,420
Center at Austin and I'm also a small

00:00:57,690 --> 00:01:05,580
part of the of the core team for salary

00:01:00,420 --> 00:01:08,010
so let's start with these hopefully very

00:01:05,580 --> 00:01:10,049
interesting presentation and first we

00:01:08,010 --> 00:01:11,939
start with a very quick overview of what

00:01:10,049 --> 00:01:14,790
salary is for anybody who doesn't know

00:01:11,939 --> 00:01:18,299
out there and sorry it's it's basically

00:01:14,790 --> 00:01:20,430
basically a task queue which what what

00:01:18,299 --> 00:01:22,380
allows us to do is to run things

00:01:20,430 --> 00:01:24,030
asynchronously now the only thing is

00:01:22,380 --> 00:01:26,070
that you might be thinking well nowadays

00:01:24,030 --> 00:01:27,360
we have all these different projects

00:01:26,070 --> 00:01:31,049
like async IO

00:01:27,360 --> 00:01:33,780
and all the different a synchronic world

00:01:31,049 --> 00:01:36,299
out there but the very interesting thing

00:01:33,780 --> 00:01:38,670
about salary is that it allows us to do

00:01:36,299 --> 00:01:41,070
distributed things so run things

00:01:38,670 --> 00:01:44,460
remotely in other different other

00:01:41,070 --> 00:01:46,530
computers also it it gives us a lot of

00:01:44,460 --> 00:01:48,479
different things that we you know in a

00:01:46,530 --> 00:01:51,000
way that we can for instance apply a

00:01:48,479 --> 00:01:53,399
retry policy on different tasks that

00:01:51,000 --> 00:01:55,049
doesn't run or they error out or

00:01:53,399 --> 00:01:57,750
something like that and we can also

00:01:55,049 --> 00:02:00,270
store results in different ways this is

00:01:57,750 --> 00:02:04,020
just like a very quick thing a very

00:02:00,270 --> 00:02:05,549
quick also way to view how the salary

00:02:04,020 --> 00:02:07,680
architecture actually works and

00:02:05,549 --> 00:02:09,479
everything starts with our main

00:02:07,680 --> 00:02:12,569
application which one we it's usually

00:02:09,479 --> 00:02:13,500
where we call our our producer and we

00:02:12,569 --> 00:02:15,890
call like that because

00:02:13,500 --> 00:02:18,780
this is actually what creates or

00:02:15,890 --> 00:02:21,420
produces all the different messages that

00:02:18,780 --> 00:02:23,160
are going to be sent to the workers and

00:02:21,420 --> 00:02:25,590
the workers are the ones who are

00:02:23,160 --> 00:02:28,320
actually going to run these different

00:02:25,590 --> 00:02:30,540
tasks that were queuing right the the

00:02:28,320 --> 00:02:31,890
cool thing about this is that if we if

00:02:30,540 --> 00:02:34,140
you think about it you can run different

00:02:31,890 --> 00:02:36,209
tasks in different machines that have

00:02:34,140 --> 00:02:39,590
different resources or have access to

00:02:36,209 --> 00:02:42,180
other different different resources

00:02:39,590 --> 00:02:44,430
inside each one of these workers where

00:02:42,180 --> 00:02:46,560
we have is usually a main process and

00:02:44,430 --> 00:02:49,709
then a number of other worker processes

00:02:46,560 --> 00:02:52,620
and this is how we can run things also

00:02:49,709 --> 00:02:55,020
concurrently and all of these actually

00:02:52,620 --> 00:02:57,630
the the way that that communicates

00:02:55,020 --> 00:02:59,250
between themselves is using something

00:02:57,630 --> 00:03:01,530
that's called transport which is usually

00:02:59,250 --> 00:03:04,170
something like RabbitMQ or we can also

00:03:01,530 --> 00:03:06,560
use readies and there is other supports

00:03:04,170 --> 00:03:10,260
for other types of transports even a

00:03:06,560 --> 00:03:12,300
simple file transport and we also we can

00:03:10,260 --> 00:03:17,040
also use a back in which is usually what

00:03:12,300 --> 00:03:21,440
we name what we what we use to to to

00:03:17,040 --> 00:03:24,900
save the different task results so how

00:03:21,440 --> 00:03:27,709
can we start building these different

00:03:24,900 --> 00:03:30,000
workflows with salary because we have

00:03:27,709 --> 00:03:32,250
telekinetically just run different code

00:03:30,000 --> 00:03:34,200
in in remote machines right and

00:03:32,250 --> 00:03:35,660
distributed machines if if you can call

00:03:34,200 --> 00:03:38,880
it that

00:03:35,660 --> 00:03:41,190
so the the everything starts actually in

00:03:38,880 --> 00:03:43,440
salary we work with what we call

00:03:41,190 --> 00:03:46,110
signatures and signatures are basically

00:03:43,440 --> 00:03:48,209
very related to a Python partials are

00:03:46,110 --> 00:03:50,730
they're implemented in a different way

00:03:48,209 --> 00:03:54,750
but the idea of it it's basically the

00:03:50,730 --> 00:03:57,959
same so the way that they work is that

00:03:54,750 --> 00:04:00,560
if we have a task for instance here the

00:03:57,959 --> 00:04:04,500
task that we're going to to use is

00:04:00,560 --> 00:04:06,209
projects the tasks that my tasks we can

00:04:04,500 --> 00:04:09,600
create a signature with a greater

00:04:06,209 --> 00:04:13,920
signature from this task and this

00:04:09,600 --> 00:04:16,470
signature is basically going to be going

00:04:13,920 --> 00:04:18,510
to be a representation of what we have

00:04:16,470 --> 00:04:23,250
here at the at the at the end of the

00:04:18,510 --> 00:04:25,800
slide which is just a way to to actually

00:04:23,250 --> 00:04:27,210
execute that function itself which is

00:04:25,800 --> 00:04:29,789
break the ties of my test

00:04:27,210 --> 00:04:33,360
with some specific arguments it will be

00:04:29,789 --> 00:04:36,870
just like normal parameters or also

00:04:33,360 --> 00:04:39,630
keyboard parameters the other cool thing

00:04:36,870 --> 00:04:41,699
about this type of signatures is that

00:04:39,630 --> 00:04:44,610
there is Lisa R else's silly

00:04:41,699 --> 00:04:49,430
serializable sorry that's really really

00:04:44,610 --> 00:04:54,300
hard to promise Sorella see yeah okay

00:04:49,430 --> 00:04:56,940
let's just continue with that yeah okay

00:04:54,300 --> 00:04:59,460
so for instance the the serialization of

00:04:56,940 --> 00:05:01,740
this task or well of these signatures we

00:04:59,460 --> 00:05:04,530
can take a look at it here it's actually

00:05:01,740 --> 00:05:08,099
just a very very simple dictionary and

00:05:04,530 --> 00:05:10,830
this is what allows us to actually send

00:05:08,099 --> 00:05:12,360
this message in to our workers through

00:05:10,830 --> 00:05:15,300
something like Road and queue already's

00:05:12,360 --> 00:05:17,669
or any other type of broker and have

00:05:15,300 --> 00:05:20,490
that worker know what it needs to

00:05:17,669 --> 00:05:22,889
execute so we can see signatures

00:05:20,490 --> 00:05:25,199
actually starts creating this message

00:05:22,889 --> 00:05:26,870
that we're going to send so the message

00:05:25,199 --> 00:05:30,030
itself doesn't contain any code and

00:05:26,870 --> 00:05:34,889
that's one of the things that we we have

00:05:30,030 --> 00:05:37,110
to to kind of get a grasp on because we

00:05:34,889 --> 00:05:39,270
have to have the code that we need to

00:05:37,110 --> 00:05:41,729
run in each one of the workers that way

00:05:39,270 --> 00:05:44,010
the producer only tells the worker what

00:05:41,729 --> 00:05:46,680
it needs to run with which parameters

00:05:44,010 --> 00:05:48,750
and then the worker does its job

00:05:46,680 --> 00:05:50,280
there are a cool thing about signatures

00:05:48,750 --> 00:05:54,449
is that we're able to define different

00:05:50,280 --> 00:05:56,340
options that are celery actually uses so

00:05:54,449 --> 00:06:00,630
for instance we can specify different

00:05:56,340 --> 00:06:03,360
cues on where these these these tasks

00:06:00,630 --> 00:06:04,860
are going to run and we have this

00:06:03,360 --> 00:06:07,080
example here where we're actually

00:06:04,860 --> 00:06:09,599
setting a custom cue whenever we're

00:06:07,080 --> 00:06:11,159
creating our signature then the or the

00:06:09,599 --> 00:06:13,440
other good thing is that we can create a

00:06:11,159 --> 00:06:16,380
signature and then after creating that

00:06:13,440 --> 00:06:18,240
signature we can set different arguments

00:06:16,380 --> 00:06:20,759
for it or we can merge different

00:06:18,240 --> 00:06:22,860
different options so for instance here

00:06:20,759 --> 00:06:25,500
on the first line we're creating a

00:06:22,860 --> 00:06:27,570
signature or well we're using a

00:06:25,500 --> 00:06:29,909
signature that we're all ready we that

00:06:27,570 --> 00:06:32,490
we have already created here and we are

00:06:29,909 --> 00:06:35,159
actually using another parameter which

00:06:32,490 --> 00:06:37,950
is going to be this string called world

00:06:35,159 --> 00:06:41,009
world with the value new model ID or we

00:06:37,950 --> 00:06:44,369
can also set another cue that

00:06:41,009 --> 00:06:47,129
he's gonna go to now this is this is the

00:06:44,369 --> 00:06:49,319
the very beginning of how or how to

00:06:47,129 --> 00:06:52,169
start creative work lose the other idea

00:06:49,319 --> 00:06:54,960
that we need that we need to to to

00:06:52,169 --> 00:06:57,029
realize here is that we can we can

00:06:54,960 --> 00:07:00,149
create signatures in different ways

00:06:57,029 --> 00:07:02,639
right and one of the other ways is to

00:07:00,149 --> 00:07:04,199
create it directly from the task objects

00:07:02,639 --> 00:07:06,539
so we can see here there are some

00:07:04,199 --> 00:07:08,279
shortcuts which is dades and that is I

00:07:06,539 --> 00:07:10,589
so door is I

00:07:08,279 --> 00:07:12,749
well that is first creates regular

00:07:10,589 --> 00:07:14,610
signature as we as we just just saw and

00:07:12,749 --> 00:07:16,680
that is I what it does is that it

00:07:14,610 --> 00:07:19,830
creates an immutable signature and that

00:07:16,680 --> 00:07:22,680
signature will not allow to get any new

00:07:19,830 --> 00:07:25,139
parameters or in fact that the other

00:07:22,680 --> 00:07:27,300
thing to see here is callbacks because

00:07:25,139 --> 00:07:29,550
now we know how we can send these tasks

00:07:27,300 --> 00:07:31,529
to different workers now how can we

00:07:29,550 --> 00:07:33,930
start creating this workflows so the

00:07:31,529 --> 00:07:34,529
very first step of it is to create an a

00:07:33,930 --> 00:07:37,469
callback

00:07:34,529 --> 00:07:40,529
after one task its run or one function

00:07:37,469 --> 00:07:42,809
runs and it's it's it successful that we

00:07:40,529 --> 00:07:45,509
can run something else and this is the

00:07:42,809 --> 00:07:47,939
way that we can actually start setting

00:07:45,509 --> 00:07:50,039
different callbacks it's very simple one

00:07:47,939 --> 00:07:52,709
of the of the of the main ways to do it

00:07:50,039 --> 00:07:56,189
is whenever we kill one task we can tell

00:07:52,709 --> 00:07:58,349
salary to actually run something after

00:07:56,189 --> 00:08:00,930
it has been successful using the link

00:07:58,349 --> 00:08:02,370
parameter the link underscore error that

00:08:00,930 --> 00:08:05,550
is going to be the callback the error

00:08:02,370 --> 00:08:07,919
callback whenever that task fails or if

00:08:05,550 --> 00:08:11,099
we're creating a signature then we can

00:08:07,919 --> 00:08:16,709
actually set these different links or

00:08:11,099 --> 00:08:19,529
link error to callbacks now after these

00:08:16,709 --> 00:08:21,569
this is this is the very basic ideas on

00:08:19,529 --> 00:08:24,749
how how everything that has to do with

00:08:21,569 --> 00:08:26,459
work flows work in celery and then it's

00:08:24,749 --> 00:08:29,309
really it's it's a little bit hard to

00:08:26,459 --> 00:08:31,649
just kind of start building workflows

00:08:29,309 --> 00:08:34,319
which we just did these two different

00:08:31,649 --> 00:08:36,060
objects so sorry allows us or well

00:08:34,319 --> 00:08:38,909
ciliary gives us these different

00:08:36,060 --> 00:08:41,550
primitives which we can use to start

00:08:38,909 --> 00:08:43,740
creating better and just a little bit

00:08:41,550 --> 00:08:45,569
more complicated workflows the first one

00:08:43,740 --> 00:08:47,850
is a chain which is basically what we

00:08:45,569 --> 00:08:50,819
just saw it's running first one function

00:08:47,850 --> 00:08:52,860
and then once that function executes we

00:08:50,819 --> 00:08:54,390
can run something else so first this one

00:08:52,860 --> 00:08:56,280
and then we send the result

00:08:54,390 --> 00:08:58,350
to whatever the callback is going to be

00:08:56,280 --> 00:09:02,400
and this is the way that we can actually

00:08:58,350 --> 00:09:04,050
define a chain as we can see here it

00:09:02,400 --> 00:09:06,450
might be a little bit difficult to see

00:09:04,050 --> 00:09:10,050
first but the way that what we're using

00:09:06,450 --> 00:09:12,060
here is a pipe operator operand or we

00:09:10,050 --> 00:09:14,490
can also just use the actual chain

00:09:12,060 --> 00:09:16,650
function that we can import from from

00:09:14,490 --> 00:09:19,350
salary the other thing though that we

00:09:16,650 --> 00:09:21,570
can use it's a group and basically what

00:09:19,350 --> 00:09:24,300
we do with a group is that we queue

00:09:21,570 --> 00:09:26,370
multiple tasks with the same well with

00:09:24,300 --> 00:09:28,710
different arguments but they are going

00:09:26,370 --> 00:09:31,260
to run in parallel as we can see here in

00:09:28,710 --> 00:09:32,670
the image so for instance here what

00:09:31,260 --> 00:09:35,520
we're going to do is that we're going to

00:09:32,670 --> 00:09:37,500
run a an array of tasks and they're

00:09:35,520 --> 00:09:39,570
going to run each one with different

00:09:37,500 --> 00:09:42,030
parameters and they're going to run in

00:09:39,570 --> 00:09:44,640
parallel here and we're creating this

00:09:42,030 --> 00:09:46,710
array of tasks here in this in these

00:09:44,640 --> 00:09:48,180
four statements the other thing the

00:09:46,710 --> 00:09:50,850
other primitive that we can use our

00:09:48,180 --> 00:09:53,900
quartz and these as we can see from the

00:09:50,850 --> 00:09:57,480
image actually it's just it's calling a

00:09:53,900 --> 00:09:59,310
one or more or more tasks and running

00:09:57,480 --> 00:10:01,410
those in parallel and then running a

00:09:59,310 --> 00:10:03,930
callback after each one of those has

00:10:01,410 --> 00:10:08,280
been run successfully and this is

00:10:03,930 --> 00:10:10,800
basically what we can also call a group

00:10:08,280 --> 00:10:13,410
with a callback so there is two ways to

00:10:10,800 --> 00:10:15,510
to create a court one is to create a

00:10:13,410 --> 00:10:18,630
header which is an array of one or more

00:10:15,510 --> 00:10:21,990
tasks and then a callback and execute

00:10:18,630 --> 00:10:24,330
that but also we can just chain a group

00:10:21,990 --> 00:10:26,460
with a callback and that's basically the

00:10:24,330 --> 00:10:28,530
same thing salary will know that this is

00:10:26,460 --> 00:10:31,140
going to be a court the other primitive

00:10:28,530 --> 00:10:32,810
is map which is something that we can

00:10:31,140 --> 00:10:35,880
use whenever we have an array of

00:10:32,810 --> 00:10:39,120
parameters and we need to run this this

00:10:35,880 --> 00:10:40,470
array on the same task and and is the

00:10:39,120 --> 00:10:42,540
only difference is that it's not going

00:10:40,470 --> 00:10:45,450
to be in parallel as a group it's going

00:10:42,540 --> 00:10:47,070
to be sequential and we also have star

00:10:45,450 --> 00:10:49,950
map which is basically the same thing as

00:10:47,070 --> 00:10:51,090
map but is whenever the array has each

00:10:49,950 --> 00:10:54,060
one of the elements

00:10:51,090 --> 00:10:56,550
it's another interval so let's start

00:10:54,060 --> 00:10:58,200
let's let's see how would like which

00:10:56,550 --> 00:10:59,910
kind of workflows can we create from

00:10:58,200 --> 00:11:02,460
this now let's think about whenever

00:10:59,910 --> 00:11:05,610
somebody logs into an account and you

00:11:02,460 --> 00:11:07,500
wanna you want to check if that user is

00:11:05,610 --> 00:11:08,820
logging in from a new device

00:11:07,500 --> 00:11:11,430
different things that we can do in the

00:11:08,820 --> 00:11:12,960
background and one of them let's let's

00:11:11,430 --> 00:11:14,310
go through kind of just like the

00:11:12,960 --> 00:11:16,350
requirements that we need for it

00:11:14,310 --> 00:11:19,020
first we need to check if the device has

00:11:16,350 --> 00:11:20,730
been used before then we need to if the

00:11:19,020 --> 00:11:23,100
device has been used before then we need

00:11:20,730 --> 00:11:26,010
to notify the user so this is a new

00:11:23,100 --> 00:11:29,790
device and we need to save that that

00:11:26,010 --> 00:11:31,470
event into a database these two program

00:11:29,790 --> 00:11:33,690
probably run in parallel so we're

00:11:31,470 --> 00:11:35,970
already kind of building this workflow

00:11:33,690 --> 00:11:38,340
in our own mind then we can send

00:11:35,970 --> 00:11:41,340
whatever we we get from all these

00:11:38,340 --> 00:11:43,710
different from these these events we can

00:11:41,340 --> 00:11:45,330
send it to an external API let's say

00:11:43,710 --> 00:11:46,980
that is not really external to the

00:11:45,330 --> 00:11:49,920
company but it's just an API that

00:11:46,980 --> 00:11:51,720
another group is is developing so for us

00:11:49,920 --> 00:11:53,400
is going to be external and let's say

00:11:51,720 --> 00:11:55,560
that that API I don't know does some

00:11:53,400 --> 00:11:57,300
machine learning stuff like outlier

00:11:55,560 --> 00:12:00,810
analysis or something like that

00:11:57,300 --> 00:12:03,720
and then then finally we get whatever

00:12:00,810 --> 00:12:05,760
response we get from this API and we

00:12:03,720 --> 00:12:07,650
post process it in different ways we

00:12:05,760 --> 00:12:09,120
could probably again save it into a

00:12:07,650 --> 00:12:11,820
database or maybe send a lot of

00:12:09,120 --> 00:12:14,910
notification if there was already just

00:12:11,820 --> 00:12:17,760
flip a switch somewhere so let's start

00:12:14,910 --> 00:12:21,240
how can we can we start drawing in our

00:12:17,760 --> 00:12:24,600
workflow first the first step is going

00:12:21,240 --> 00:12:27,000
to be just to check the device that if

00:12:24,600 --> 00:12:29,270
the device is a new device right and

00:12:27,000 --> 00:12:31,790
then we have these two tasks which we

00:12:29,270 --> 00:12:34,920
already said that we can run in parallel

00:12:31,790 --> 00:12:37,710
so we start we start kind of drawing

00:12:34,920 --> 00:12:39,720
them here so we have an idea of the

00:12:37,710 --> 00:12:42,060
different tools that we can use then

00:12:39,720 --> 00:12:45,240
we're gonna do a call to a third party

00:12:42,060 --> 00:12:47,760
API which is over here this node and

00:12:45,240 --> 00:12:49,500
then we're we're finally going to post

00:12:47,760 --> 00:12:52,470
process whatever response we're gonna

00:12:49,500 --> 00:12:55,920
get so the first one is going to be a

00:12:52,470 --> 00:12:59,400
task as we were talking about these ones

00:12:55,920 --> 00:13:01,290
and then after these we can use a group

00:12:59,400 --> 00:13:05,910
in order to run these two tasks in

00:13:01,290 --> 00:13:07,920
parallel then we can and the result of

00:13:05,910 --> 00:13:09,990
this group is going to be an array

00:13:07,920 --> 00:13:12,240
because the group is going to wait until

00:13:09,990 --> 00:13:14,460
each one of these tasks are going to to

00:13:12,240 --> 00:13:16,860
finish to go to the next step

00:13:14,460 --> 00:13:19,440
then this this array of results are

00:13:16,860 --> 00:13:21,240
going to be to be sent to this other

00:13:19,440 --> 00:13:23,580
task which is going to be our state

00:13:21,240 --> 00:13:26,790
three and this one which is basically a

00:13:23,580 --> 00:13:29,399
callback is is going to post all of this

00:13:26,790 --> 00:13:32,220
data into this a third party API and

00:13:29,399 --> 00:13:34,820
then these respond is going to be fed

00:13:32,220 --> 00:13:37,980
into this last step which is our last

00:13:34,820 --> 00:13:40,170
and all of these we have to put into a

00:13:37,980 --> 00:13:43,170
chain that way we can go from step to

00:13:40,170 --> 00:13:45,570
step so let's take a look at it in code

00:13:43,170 --> 00:13:48,110
this is basically how it looks and as we

00:13:45,570 --> 00:13:49,890
can see salary gives us different tools

00:13:48,110 --> 00:13:52,110
all the different tools that we're

00:13:49,890 --> 00:13:54,209
talking about in order to do this and

00:13:52,110 --> 00:13:58,220
it's very easy to read and it's very

00:13:54,209 --> 00:14:00,839
easy to write to so now so first well

00:13:58,220 --> 00:14:03,870
for instance we can see here we have our

00:14:00,839 --> 00:14:05,310
step one then we have these step two

00:14:03,870 --> 00:14:07,290
which is the group that we're we're

00:14:05,310 --> 00:14:10,350
running in parallel then we have our

00:14:07,290 --> 00:14:14,010
step three which is where we're posting

00:14:10,350 --> 00:14:16,100
to our third party API and then we're

00:14:14,010 --> 00:14:21,120
post-processing the result from these

00:14:16,100 --> 00:14:23,760
external API now this is only very very

00:14:21,120 --> 00:14:25,529
very kind of simple example with no

00:14:23,760 --> 00:14:28,290
errors and we assume that everything is

00:14:25,529 --> 00:14:29,850
perfect in the world which is not so

00:14:28,290 --> 00:14:31,620
let's string a few around how can we

00:14:29,850 --> 00:14:33,510
handle errors there are different ways

00:14:31,620 --> 00:14:37,740
and we can handle it in different levels

00:14:33,510 --> 00:14:40,350
from within or from within the DR the

00:14:37,740 --> 00:14:42,660
workflow one thing that we can do is for

00:14:40,350 --> 00:14:45,690
every error we can just retry one task

00:14:42,660 --> 00:14:48,270
or the other thing is that we can set

00:14:45,690 --> 00:14:50,850
different callback errors and instead of

00:14:48,270 --> 00:14:52,770
returning the task we probably switch

00:14:50,850 --> 00:14:54,690
another I mean flip another switch or

00:14:52,770 --> 00:14:57,930
maybe do something else right

00:14:54,690 --> 00:15:00,029
I depends on what kind of varies so if

00:14:57,930 --> 00:15:02,430
we want to you want to retry the one

00:15:00,029 --> 00:15:05,250
task then the only thing is that we can

00:15:02,430 --> 00:15:07,680
only do it in the task we cannot do it

00:15:05,250 --> 00:15:10,020
in you know the entire group level we

00:15:07,680 --> 00:15:13,950
will have to do it in one in one task

00:15:10,020 --> 00:15:15,420
but within one group if we start retry

00:15:13,950 --> 00:15:17,730
in one of the tasks that are running

00:15:15,420 --> 00:15:19,260
Apollo the group is well the entire

00:15:17,730 --> 00:15:22,350
chain is not going to move to the next

00:15:19,260 --> 00:15:25,170
step until every single one of the tasks

00:15:22,350 --> 00:15:26,790
in a group finishes that means even if

00:15:25,170 --> 00:15:30,870
one of the tasks is retraining and

00:15:26,790 --> 00:15:33,670
retraining this is one of the way that

00:15:30,870 --> 00:15:36,070
we can we can retry within a task

00:15:33,670 --> 00:15:37,840
and it is a little bit manual there is

00:15:36,070 --> 00:15:40,690
another way that we can do it which is

00:15:37,840 --> 00:15:42,160
sitting and auto retry and specify the

00:15:40,690 --> 00:15:45,400
different exceptions that we can catch

00:15:42,160 --> 00:15:49,300
but in in in my well historically

00:15:45,400 --> 00:15:51,160
actually in in in in the different

00:15:49,300 --> 00:15:52,900
things that we have implemented we've

00:15:51,160 --> 00:15:56,710
seen that it's easier to put it this way

00:15:52,900 --> 00:15:59,470
because it's more it's more explicit

00:15:56,710 --> 00:16:00,730
what we're actually trying to do the

00:15:59,470 --> 00:16:02,800
other thing that we can do is that we

00:16:00,730 --> 00:16:05,800
can set different compacts we can save a

00:16:02,800 --> 00:16:08,560
callback on a task level so whenever

00:16:05,800 --> 00:16:10,840
this step is gonna is going to fail then

00:16:08,560 --> 00:16:12,730
we're gonna fire out this callback which

00:16:10,840 --> 00:16:15,010
is this is one of the ways that we can

00:16:12,730 --> 00:16:16,690
do it as we can see it is the same code

00:16:15,010 --> 00:16:19,870
that we had before but we're adding and

00:16:16,690 --> 00:16:23,950
dot on error and then the different

00:16:19,870 --> 00:16:26,950
handler then we or we can also do a

00:16:23,950 --> 00:16:29,620
callback just on one of the tasks on any

00:16:26,950 --> 00:16:31,720
group or even we can do it on the entire

00:16:29,620 --> 00:16:33,520
group itself so for instance if we went

00:16:31,720 --> 00:16:35,800
to an entire group we can we can also

00:16:33,520 --> 00:16:38,590
use this link underscore error which is

00:16:35,800 --> 00:16:40,090
what we're looking at before or the

00:16:38,590 --> 00:16:41,890
other thing is that we can also add a

00:16:40,090 --> 00:16:45,010
callback error for the entire chain

00:16:41,890 --> 00:16:46,660
itself it depends it really depends on a

00:16:45,010 --> 00:16:50,220
lot of different things and it's a

00:16:46,660 --> 00:16:53,410
decision on whatever it is that each

00:16:50,220 --> 00:16:58,000
team is implementing this is a way to

00:16:53,410 --> 00:17:01,390
add a an error callback after or if

00:16:58,000 --> 00:17:03,220
anything goes wrong in a in a chain the

00:17:01,390 --> 00:17:06,250
other thing to take a look at here is

00:17:03,220 --> 00:17:11,170
how can we handle different results so

00:17:06,250 --> 00:17:13,780
we have our entire our entire workflow

00:17:11,170 --> 00:17:15,940
but we want to check we want to go back

00:17:13,780 --> 00:17:18,160
and when I check what were the results

00:17:15,940 --> 00:17:20,440
of each one of these tasks so the good

00:17:18,160 --> 00:17:22,480
thing is that celery gives a specific

00:17:20,440 --> 00:17:25,390
task ID which is unique to each one of

00:17:22,480 --> 00:17:28,150
the tasks and we can grab that task and

00:17:25,390 --> 00:17:30,760
use this class which is called async

00:17:28,150 --> 00:17:33,910
result in order to grab the result of

00:17:30,760 --> 00:17:35,380
that specific task and there's there's

00:17:33,910 --> 00:17:40,480
different ways to there one way to do it

00:17:35,380 --> 00:17:42,610
is to to use the async result class and

00:17:40,480 --> 00:17:44,410
we have to give it a task ID then we

00:17:42,610 --> 00:17:47,470
have to specify which back-end are we're

00:17:44,410 --> 00:17:49,809
using usually it's going to be ready

00:17:47,470 --> 00:17:53,140
or it could also be a better base any

00:17:49,809 --> 00:17:55,419
other database or it could be they could

00:17:53,140 --> 00:17:58,360
also be arrived in queue but there it

00:17:55,419 --> 00:18:00,490
that depends also on urinates and you

00:17:58,360 --> 00:18:02,350
also have to specify which salary app

00:18:00,490 --> 00:18:04,000
are you using because of the the

00:18:02,350 --> 00:18:06,340
different configuration that you can set

00:18:04,000 --> 00:18:10,090
on each one of the apps the other way to

00:18:06,340 --> 00:18:12,400
do it is to to use the async result

00:18:10,090 --> 00:18:15,970
class that comes from the task object

00:18:12,400 --> 00:18:17,919
and that way we only have to give it a

00:18:15,970 --> 00:18:19,510
task ID and we don't have to specify the

00:18:17,919 --> 00:18:22,000
backend or the app because the task

00:18:19,510 --> 00:18:25,240
object is already bound to a specific

00:18:22,000 --> 00:18:28,570
app which has configured the backend

00:18:25,240 --> 00:18:31,690
correctly so one way to do it is to grab

00:18:28,570 --> 00:18:34,059
that and then to to use to use the

00:18:31,690 --> 00:18:36,880
specific task ID in order to get the

00:18:34,059 --> 00:18:38,710
result now these are different the

00:18:36,880 --> 00:18:41,620
different things that we can use from

00:18:38,710 --> 00:18:43,510
the result object different attributes

00:18:41,620 --> 00:18:46,030
in order to analyze it

00:18:43,510 --> 00:18:48,520
so the first one is how we can get the

00:18:46,030 --> 00:18:50,440
value of the actual result then if we're

00:18:48,520 --> 00:18:53,740
within a workflow like this one or

00:18:50,440 --> 00:18:56,080
within a chain we can go up and down in

00:18:53,740 --> 00:18:59,230
the chain or in the workflow by using

00:18:56,080 --> 00:19:01,330
toad children and our parent now the

00:18:59,230 --> 00:19:03,159
only thing is that this workflow is very

00:19:01,330 --> 00:19:05,890
interesting because the second step is

00:19:03,159 --> 00:19:08,080
actually a group result it's not an a

00:19:05,890 --> 00:19:10,030
single task so the class of what you're

00:19:08,080 --> 00:19:13,000
going to have to use here is called also

00:19:10,030 --> 00:19:17,350
group result which is basically an array

00:19:13,000 --> 00:19:20,230
of async async results and here it works

00:19:17,350 --> 00:19:22,809
a little bit different but most of it

00:19:20,230 --> 00:19:24,970
it's basically the same thing so for

00:19:22,809 --> 00:19:26,980
both classes we're gonna have these

00:19:24,970 --> 00:19:29,679
different methods the first one is to

00:19:26,980 --> 00:19:31,360
check if the if the result is ready

00:19:29,679 --> 00:19:33,610
because all of this is running

00:19:31,360 --> 00:19:36,010
asynchronously and we don't know when is

00:19:33,610 --> 00:19:37,990
it gonna so we can continuously check if

00:19:36,010 --> 00:19:40,809
a result is gonna be ready we can also

00:19:37,990 --> 00:19:43,120
check if it's going to be well if it has

00:19:40,809 --> 00:19:45,370
been successful it it's either going to

00:19:43,120 --> 00:19:47,080
be one task or if it's a group result

00:19:45,370 --> 00:19:49,390
then it's going to check if every one of

00:19:47,080 --> 00:19:52,210
the results within that group were

00:19:49,390 --> 00:19:55,419
successful then whenever we have an

00:19:52,210 --> 00:19:57,970
async result we can get the result which

00:19:55,419 --> 00:20:01,040
is another which is the method you know

00:19:57,970 --> 00:20:03,500
that we can use to get the same

00:20:01,040 --> 00:20:07,300
thing as we were going as we were doing

00:20:03,500 --> 00:20:10,310
when we were accessing result dot result

00:20:07,300 --> 00:20:12,650
then whenever we have a group result we

00:20:10,310 --> 00:20:15,200
can use giant which what it does is that

00:20:12,650 --> 00:20:19,370
it looks through each one of the async

00:20:15,200 --> 00:20:21,110
results that is inside one group and is

00:20:19,370 --> 00:20:23,420
going to wait for each one of those

00:20:21,110 --> 00:20:26,000
acing results to be ready and then it's

00:20:23,420 --> 00:20:29,630
going to return an array of each one of

00:20:26,000 --> 00:20:32,000
those results and this is that was

00:20:29,630 --> 00:20:34,340
pretty much all the different ways that

00:20:32,000 --> 00:20:37,790
we can create and manage different

00:20:34,340 --> 00:20:39,350
workflows in celery this is where you

00:20:37,790 --> 00:20:42,380
can contact me if you have any questions

00:20:39,350 --> 00:20:44,300
or outside my halls also celery project

00:20:42,380 --> 00:20:47,690
is going to be in Sprint's so drop bytes

00:20:44,300 --> 00:20:51,260
you pick up some stickers and or pins

00:20:47,690 --> 00:20:53,990
and we also have some sticker and pins

00:20:51,260 --> 00:21:01,640
right here and and front if you guys

00:20:53,990 --> 00:21:04,400
want to pick up some Thank You Josue Hey

00:21:01,640 --> 00:21:06,140
in your experience so which back I'm

00:21:04,400 --> 00:21:10,130
sorry I'm which processing back-end do

00:21:06,140 --> 00:21:12,440
you prefer like rabbitmq or versus Redis

00:21:10,130 --> 00:21:16,400
or whatever well in my experience is

00:21:12,440 --> 00:21:19,730
usually better to use RabbitMQ because

00:21:16,400 --> 00:21:21,950
it has more it supports more things and

00:21:19,730 --> 00:21:23,360
it's more robust and the only thing is

00:21:21,950 --> 00:21:25,280
that whenever we're doing like for

00:21:23,360 --> 00:21:27,130
instance this type of workflows salary

00:21:25,280 --> 00:21:29,720
has to do to send different messages

00:21:27,130 --> 00:21:32,150
that is you're not gonna see those right

00:21:29,720 --> 00:21:34,160
but your back-end is gonna see it so if

00:21:32,150 --> 00:21:35,990
it's an actual implementation of AMQP

00:21:34,160 --> 00:21:37,190
then it's going to be more of us and

00:21:35,990 --> 00:21:40,070
it's going to handle these multiple

00:21:37,190 --> 00:21:44,300
messages better thanks for the talk we

00:21:40,070 --> 00:21:47,750
use some workflows in all work and we

00:21:44,300 --> 00:21:49,910
had some bugs like things weren't being

00:21:47,750 --> 00:21:53,270
called because of some like even though

00:21:49,910 --> 00:21:56,350
we're calling retry or like messages

00:21:53,270 --> 00:22:00,170
being lost even though the configuration

00:21:56,350 --> 00:22:03,020
kind of handle that so do you know if

00:22:00,170 --> 00:22:05,090
this is well tested inside of salary or

00:22:03,020 --> 00:22:08,690
did you have any problems like that

00:22:05,090 --> 00:22:11,420
because we've we had many bugs on

00:22:08,690 --> 00:22:14,240
workflows and kind of right now we are

00:22:11,420 --> 00:22:16,250
trying not to be so complex workflows

00:22:14,240 --> 00:22:18,230
or better the bugging at production do

00:22:16,250 --> 00:22:20,059
you have any problems like that

00:22:18,230 --> 00:22:21,530
well yeah it's it's always better to

00:22:20,059 --> 00:22:25,250
keep your workflows as simple as

00:22:21,530 --> 00:22:27,260
possible but and we do test a lot of

00:22:25,250 --> 00:22:29,480
these different things and within the

00:22:27,260 --> 00:22:32,030
salary project but there is there are

00:22:29,480 --> 00:22:34,070
some work some bug's around it I mean

00:22:32,030 --> 00:22:36,860
these are very complicated things to

00:22:34,070 --> 00:22:39,559
implement so yeah if you have some bugs

00:22:36,860 --> 00:22:41,570
I do recommend you to submit some issues

00:22:39,559 --> 00:22:43,730
we're always taking a look at those even

00:22:41,570 --> 00:22:46,240
though if we take time also if you wanna

00:22:43,730 --> 00:22:49,940
drop by the springs and help out

00:22:46,240 --> 00:22:51,470
can I invoke our teens from within

00:22:49,940 --> 00:22:53,900
salary is that possible

00:22:51,470 --> 00:22:55,429
can you what's our core audience like I

00:22:53,900 --> 00:22:59,720
think I owe things

00:22:55,429 --> 00:23:02,270
oh well no yes there is there is a way

00:22:59,720 --> 00:23:04,640
to do it but it's not fully supported by

00:23:02,270 --> 00:23:07,400
my salary right now because it doesn't

00:23:04,640 --> 00:23:10,460
support all the way to 3.7 we're working

00:23:07,400 --> 00:23:12,020
on that and hopefully hope well soon

00:23:10,460 --> 00:23:14,480
we're gonna we're gonna do that release

00:23:12,020 --> 00:23:16,640
what's going to full support 3.7 okay

00:23:14,480 --> 00:23:18,380
just one more thing if you guys are

00:23:16,640 --> 00:23:21,020
gonna drop by the sprints and we have a

00:23:18,380 --> 00:23:23,270
lot of different beginner tasks and also

00:23:21,020 --> 00:23:27,040
advanced tests so feel free to drop by

00:23:23,270 --> 00:23:27,040
and to grab some slack

00:23:27,850 --> 00:23:34,829

YouTube URL: https://www.youtube.com/watch?v=8YLeWxLtVgo


