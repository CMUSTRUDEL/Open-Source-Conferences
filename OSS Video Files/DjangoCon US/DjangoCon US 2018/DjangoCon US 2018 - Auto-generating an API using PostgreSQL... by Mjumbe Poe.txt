Title: DjangoCon US 2018 - Auto-generating an API using PostgreSQL... by Mjumbe Poe
Publication date: 2018-11-08
Playlist: DjangoCon US 2018
Description: 
	DjangoCon US 2018 - Auto-generating an API using PostgreSQL, Django, and Django REST Framework by Mjumbe Poe

We have an API whose database schema changes constantly with no need for changes to our code that exposes the data. This is an extremely powerful (but quite possibly a bad) idea. See how we do it!

This talk was presented at: https://2018.djangocon.us/talk/auto-generating-an-api-using-postgresql/

LINKS:
Follow Mjumbe Poe ðŸ‘‡
On Twitter: https://twitter.com/mjumbewu

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,050 --> 00:00:07,709
[Music]

00:00:15,680 --> 00:00:25,320
hi so thank you for being here

00:00:21,869 --> 00:00:27,269
first of all every time I every time I

00:00:25,320 --> 00:00:32,279
stand up in front of a large group of

00:00:27,269 --> 00:00:35,160
people it is nerve-racking but after

00:00:32,279 --> 00:00:38,070
it's over I enjoyed it and I feel like

00:00:35,160 --> 00:00:39,510
it usually goes pretty well so I'm

00:00:38,070 --> 00:00:45,870
hoping that we can all have a little bit

00:00:39,510 --> 00:00:49,789
of fun all of us here so today I'm gonna

00:00:45,870 --> 00:00:52,980
be talking about auto-generating api's

00:00:49,789 --> 00:00:55,949
from an existing Postgres database using

00:00:52,980 --> 00:01:01,109
tools like Django rest framework and

00:00:55,949 --> 00:01:03,539
Django filters so in this talk I want to

00:01:01,109 --> 00:01:07,409
I want to try to dive into some of the

00:01:03,539 --> 00:01:10,140
specifics of how we go about doing this

00:01:07,409 --> 00:01:12,990
talk about some of the situations in

00:01:10,140 --> 00:01:17,159
which it makes sense and some situations

00:01:12,990 --> 00:01:19,200
in which it doesn't make sense and try

00:01:17,159 --> 00:01:23,250
to give my sense of whether or not this

00:01:19,200 --> 00:01:27,960
is something that I recommend for other

00:01:23,250 --> 00:01:29,880
people to do spoiler it is often not a

00:01:27,960 --> 00:01:31,950
thing that I would recommend for other

00:01:29,880 --> 00:01:36,780
people to do but it's still a really

00:01:31,950 --> 00:01:39,750
cool really neat idea and something that

00:01:36,780 --> 00:01:42,210
I would recommend people try even if

00:01:39,750 --> 00:01:50,759
it's not something that you would need

00:01:42,210 --> 00:01:54,509
for your production application so yeah

00:01:50,759 --> 00:01:57,060
so I realized earlier today that I

00:01:54,509 --> 00:02:00,299
didn't actually talk about what I mean

00:01:57,060 --> 00:02:03,240
by generating an API and so I added

00:02:00,299 --> 00:02:07,649
these slides a little earlier this

00:02:03,240 --> 00:02:11,009
afternoon and so at a high level what I

00:02:07,649 --> 00:02:13,560
mean by auto-generating an API you can

00:02:11,009 --> 00:02:15,480
think of an api as consisting of

00:02:13,560 --> 00:02:17,670
very high-level three components you

00:02:15,480 --> 00:02:19,400
have your database or data store or

00:02:17,670 --> 00:02:23,010
wherever wherever the stuff that you are

00:02:19,400 --> 00:02:26,340
serving out is stored or the stuff that

00:02:23,010 --> 00:02:29,730
you are taking in gets stored you have

00:02:26,340 --> 00:02:32,820
your views or your external interface to

00:02:29,730 --> 00:02:36,590
your API so in Django this is this is

00:02:32,820 --> 00:02:39,959
views and then you have your models

00:02:36,590 --> 00:02:42,630
which serve as your interface your

00:02:39,959 --> 00:02:46,380
internal interface between your external

00:02:42,630 --> 00:02:49,520
interface and your data so there are a

00:02:46,380 --> 00:02:53,030
few ways that people generally go about

00:02:49,520 --> 00:02:58,650
constructing applications in general and

00:02:53,030 --> 00:03:03,450
specifically AP is a very Django way of

00:02:58,650 --> 00:03:06,030
doing things is to write your models and

00:03:03,450 --> 00:03:08,430
your views explicitly so actually code

00:03:06,030 --> 00:03:10,140
up a models dot Pi file code up a views

00:03:08,430 --> 00:03:13,170
dot Pi file or whatever you want to call

00:03:10,140 --> 00:03:15,180
these things and then use the rules that

00:03:13,170 --> 00:03:17,580
are built into Django to inspect the

00:03:15,180 --> 00:03:19,620
structure of your models PI file to

00:03:17,580 --> 00:03:21,660
generate a structure for your database

00:03:19,620 --> 00:03:23,670
that's one way of going about things

00:03:21,660 --> 00:03:26,010
another way that some people go about

00:03:23,670 --> 00:03:28,590
things for for API is is they already

00:03:26,010 --> 00:03:31,580
have a database full of a bunch of data

00:03:28,590 --> 00:03:34,830
and then they build models dot PI files

00:03:31,580 --> 00:03:39,299
to act as the interface on top of that

00:03:34,830 --> 00:03:42,380
data between the database and their

00:03:39,299 --> 00:03:46,100
views what I'm talking about when I say

00:03:42,380 --> 00:03:49,320
generating auto-generating an API is

00:03:46,100 --> 00:03:52,980
more something like this where you start

00:03:49,320 --> 00:03:57,360
with a database full of data you use a

00:03:52,980 --> 00:04:03,060
set of rules to inspect that database

00:03:57,360 --> 00:04:08,880
and build models which you then use to

00:04:03,060 --> 00:04:10,829
build views well build an external

00:04:08,880 --> 00:04:12,660
interface for your API so you don't

00:04:10,829 --> 00:04:14,760
explicitly code your models you don't

00:04:12,660 --> 00:04:17,820
explicitly code your views you just

00:04:14,760 --> 00:04:19,799
build rules to take the data in your

00:04:17,820 --> 00:04:25,349
database and construct models and views

00:04:19,799 --> 00:04:26,340
on top of that data very high-level all

00:04:25,349 --> 00:04:32,370
right

00:04:26,340 --> 00:04:36,970
so so that's the that's the what about

00:04:32,370 --> 00:04:41,530
this this endeavor so now I just want to

00:04:36,970 --> 00:04:43,690
talk a little bit about why why why we

00:04:41,530 --> 00:04:45,670
decided to to build an idea and actually

00:04:43,690 --> 00:04:49,360
let me back up and tell you a little bit

00:04:45,670 --> 00:04:52,330
about who we is and who I am for that

00:04:49,360 --> 00:04:56,020
matter so I I'm the CTO of a company

00:04:52,330 --> 00:04:59,440
called stepwise analytics we build tools

00:04:56,020 --> 00:05:01,300
for helping people making helping people

00:04:59,440 --> 00:05:07,210
to make smarter and more impactful real

00:05:01,300 --> 00:05:09,810
estate investment decisions so a lot of

00:05:07,210 --> 00:05:13,030
the data that we use for these tools

00:05:09,810 --> 00:05:16,240
comes from open data sources data that's

00:05:13,030 --> 00:05:22,030
published by governments from city level

00:05:16,240 --> 00:05:24,970
up to the federal level so we work with

00:05:22,030 --> 00:05:27,250
a lot of open data and when I say a lot

00:05:24,970 --> 00:05:29,020
of data I'm not like talking about you

00:05:27,250 --> 00:05:32,440
know for example we're not we're not

00:05:29,020 --> 00:05:35,170
working with human genome level big data

00:05:32,440 --> 00:05:38,380
kind of data but we are working with

00:05:35,170 --> 00:05:41,980
data on the on the level of for each of

00:05:38,380 --> 00:05:43,270
the cities that we support a few dozen

00:05:41,980 --> 00:05:45,730
gigabytes of data for each of those

00:05:43,270 --> 00:05:48,700
cities so it's a significant amount of

00:05:45,730 --> 00:05:52,000
data and it split up into a significant

00:05:48,700 --> 00:05:54,310
amount of data sources so a little bit

00:05:52,000 --> 00:05:57,910
about my background with these kinds of

00:05:54,310 --> 00:05:59,710
data sources so before I was at step

00:05:57,910 --> 00:06:02,200
wise I used to work with the city of

00:05:59,710 --> 00:06:05,200
Philadelphia and the open data and

00:06:02,200 --> 00:06:07,740
digital transformation office the office

00:06:05,200 --> 00:06:12,940
of open data and digital transformation

00:06:07,740 --> 00:06:15,370
before that I was at open plans a a

00:06:12,940 --> 00:06:19,180
company up in New York where we made

00:06:15,370 --> 00:06:20,800
tools for helping just helping citizens

00:06:19,180 --> 00:06:23,110
to get involved in the urban planning

00:06:20,800 --> 00:06:25,150
process and before that I was a Code for

00:06:23,110 --> 00:06:27,760
America fellow so I've been working

00:06:25,150 --> 00:06:29,980
around government open data sources and

00:06:27,760 --> 00:06:34,210
and in the in the space of government

00:06:29,980 --> 00:06:35,820
open data for for several years and in

00:06:34,210 --> 00:06:38,290
that time I've learned a few things

00:06:35,820 --> 00:06:39,460
about these kinds of data sources so in

00:06:38,290 --> 00:06:43,370
my experience

00:06:39,460 --> 00:06:48,530
government data sources can be scattered

00:06:43,370 --> 00:06:50,260
so they are there are a number of

00:06:48,530 --> 00:06:53,840
different places that you might look and

00:06:50,260 --> 00:06:56,330
find data sources that are related but

00:06:53,840 --> 00:06:58,540
not directly connected to each other so

00:06:56,330 --> 00:07:02,090
it they require a lot of

00:06:58,540 --> 00:07:05,390
cross-referencing and cleaning up in

00:07:02,090 --> 00:07:09,230
order to do that cross-referencing and

00:07:05,390 --> 00:07:11,050
you know there are a number of a number

00:07:09,230 --> 00:07:14,120
of them across different departments so

00:07:11,050 --> 00:07:16,310
you know the government of a city as a

00:07:14,120 --> 00:07:19,280
whole is generally not the one that's

00:07:16,310 --> 00:07:22,280
producing data sets for that city it's

00:07:19,280 --> 00:07:23,930
usually you know licensing and

00:07:22,280 --> 00:07:26,180
inspection in the city and the

00:07:23,930 --> 00:07:29,060
Department of Records and you know all

00:07:26,180 --> 00:07:31,910
of these other independent entities that

00:07:29,060 --> 00:07:35,840
don't necessarily communicate about what

00:07:31,910 --> 00:07:38,660
the single single way single format

00:07:35,840 --> 00:07:39,920
around that data single schema around

00:07:38,660 --> 00:07:41,390
different things that should be included

00:07:39,920 --> 00:07:44,890
and so on

00:07:41,390 --> 00:07:50,570
so these data sets can be sat scattered

00:07:44,890 --> 00:07:54,700
moreover you can oftentimes you'll find

00:07:50,570 --> 00:07:59,870
that data sets pop up and disappear

00:07:54,700 --> 00:08:02,090
without warning and more often within

00:07:59,870 --> 00:08:04,550
any particular data set you'll find that

00:08:02,090 --> 00:08:06,320
new fields appear or disappear without

00:08:04,550 --> 00:08:08,780
warning and these are all things that we

00:08:06,320 --> 00:08:16,820
just have to deal with in dealing with

00:08:08,780 --> 00:08:21,440
open data so we stepwise we had to come

00:08:16,820 --> 00:08:23,510
up with some place to ensure that the

00:08:21,440 --> 00:08:27,020
data that we were using and serving up

00:08:23,510 --> 00:08:29,840
to our application through our API met

00:08:27,020 --> 00:08:32,300
certain expectations and so we we built

00:08:29,840 --> 00:08:34,760
an entire data pipeline around ingesting

00:08:32,300 --> 00:08:36,530
all of these different data sources and

00:08:34,760 --> 00:08:43,190
built in certain expectations to that

00:08:36,530 --> 00:08:45,410
data pipeline and what we initially did

00:08:43,190 --> 00:08:47,320
was in addition to building in

00:08:45,410 --> 00:08:50,450
expectations in the pipeline we also

00:08:47,320 --> 00:08:52,370
created models by hand for each one of

00:08:50,450 --> 00:08:53,190
these data sources that we were pulling

00:08:52,370 --> 00:08:55,259
in

00:08:53,190 --> 00:08:57,779
from all these different cities what we

00:08:55,259 --> 00:08:59,459
found is that because we were repeating

00:08:57,779 --> 00:09:01,050
ourselves we were building an

00:08:59,459 --> 00:09:02,670
expectations about what the data was

00:09:01,050 --> 00:09:04,139
going to be structured like at the data

00:09:02,670 --> 00:09:05,519
pipeline level and we were building in

00:09:04,139 --> 00:09:06,690
expectations about what the data was

00:09:05,519 --> 00:09:09,509
going to be structured like at the

00:09:06,690 --> 00:09:12,990
application level those things often got

00:09:09,509 --> 00:09:16,560
out of sync and so in order to stop

00:09:12,990 --> 00:09:19,740
repeating ourselves we said well why

00:09:16,560 --> 00:09:22,769
don't we try instead auto-generating our

00:09:19,740 --> 00:09:25,139
API based on the data that we're getting

00:09:22,769 --> 00:09:27,660
in since we're already checking that the

00:09:25,139 --> 00:09:30,120
structure of this data meets certain

00:09:27,660 --> 00:09:32,940
expectations though we wanted to be

00:09:30,120 --> 00:09:37,199
flexible enough around where it didn't

00:09:32,940 --> 00:09:39,360
need to meet hard expectations but as

00:09:37,199 --> 00:09:45,300
long as it met certain expectations we

00:09:39,360 --> 00:09:50,149
wanted our API to run with it so we

00:09:45,300 --> 00:09:50,149
decided to start Auto generating our API

00:09:50,779 --> 00:09:57,389
so this is all of those reasons that I

00:09:54,480 --> 00:09:58,980
just laid out so there can be a lot of

00:09:57,389 --> 00:10:01,019
different tables coming from a number of

00:09:58,980 --> 00:10:03,689
different store sources those the schema

00:10:01,019 --> 00:10:06,870
of those tables may change on a regular

00:10:03,689 --> 00:10:08,850
basis and our table structure was

00:10:06,870 --> 00:10:10,230
already defined elsewhere specifically

00:10:08,850 --> 00:10:12,300
in our data pipeline so we didn't want

00:10:10,230 --> 00:10:16,110
to repeat ourselves by defining it as

00:10:12,300 --> 00:10:21,660
well in the application layer so that's

00:10:16,110 --> 00:10:27,240
the the what and the why around our

00:10:21,660 --> 00:10:29,189
approach to generating an API now we're

00:10:27,240 --> 00:10:31,589
going to talk about the how so at a very

00:10:29,189 --> 00:10:34,259
high level very high level these are the

00:10:31,589 --> 00:10:38,819
steps that we take so first we inspect

00:10:34,259 --> 00:10:41,310
the database depend on that structure we

00:10:38,819 --> 00:10:43,350
create models based on those models we

00:10:41,310 --> 00:10:45,839
create serializers and filter sets

00:10:43,350 --> 00:10:49,290
serializers are a Django rest framework

00:10:45,839 --> 00:10:50,939
construct and filter sets are in Django

00:10:49,290 --> 00:10:54,209
filters which works with Django rest

00:10:50,939 --> 00:10:55,740
framework and then based on those or

00:10:54,209 --> 00:10:59,910
using those as well as a few other

00:10:55,740 --> 00:11:01,920
things we create and expose views so

00:10:59,910 --> 00:11:05,339
this seems pretty simple and like all

00:11:01,920 --> 00:11:06,800
things simple it's actually not but at a

00:11:05,339 --> 00:11:09,410
high level view

00:11:06,800 --> 00:11:11,839
this is this is the this is the general

00:11:09,410 --> 00:11:16,399
process and I'm gonna dive into each one

00:11:11,839 --> 00:11:19,790
of these each one of these points on

00:11:16,399 --> 00:11:24,140
their own so we start with inspecting

00:11:19,790 --> 00:11:26,000
the database and this is this is really

00:11:24,140 --> 00:11:27,829
just figuring out what is in your

00:11:26,000 --> 00:11:30,200
database and so the way that we do this

00:11:27,829 --> 00:11:31,519
is with something called introspection

00:11:30,200 --> 00:11:33,649
introspection is actually a term that

00:11:31,519 --> 00:11:38,380
comes from psychology I believe and it's

00:11:33,649 --> 00:11:42,050
it's the process of asking oneself about

00:11:38,380 --> 00:11:46,010
oneself how am I feeling what am I

00:11:42,050 --> 00:11:47,810
thinking so much like introspection in

00:11:46,010 --> 00:11:53,690
psychology is asking oneself about

00:11:47,810 --> 00:11:56,290
oneself introspection in in databases or

00:11:53,690 --> 00:12:01,160
in programming languages is about asking

00:11:56,290 --> 00:12:04,040
that database about itself and so

00:12:01,160 --> 00:12:06,110
there's a there's a tool that we use to

00:12:04,040 --> 00:12:10,670
do this that's called the information

00:12:06,110 --> 00:12:14,360
schema so the information schema is an

00:12:10,670 --> 00:12:17,990
ANSI standard and as such it's supported

00:12:14,360 --> 00:12:21,200
among most of the major relational

00:12:17,990 --> 00:12:25,130
database management systems and there

00:12:21,200 --> 00:12:27,850
are slight differences between what's

00:12:25,130 --> 00:12:32,029
available in each one of these

00:12:27,850 --> 00:12:34,370
relational databases but by and large

00:12:32,029 --> 00:12:37,040
the information schema is a thing that

00:12:34,370 --> 00:12:39,260
you can use to ask the database about

00:12:37,040 --> 00:12:43,040
itself so it gives information on

00:12:39,260 --> 00:12:45,380
columns tables views and procedures as

00:12:43,040 --> 00:12:49,100
well as a number of other objects that

00:12:45,380 --> 00:12:53,720
exist in the database indexes and so on

00:12:49,100 --> 00:12:55,790
and there are some difficulties that you

00:12:53,720 --> 00:12:57,620
may run into when working with the

00:12:55,790 --> 00:13:00,230
information schema for example since we

00:12:57,620 --> 00:13:02,480
deal in real estate data one of the

00:13:00,230 --> 00:13:04,339
things that we have to use a lot of is

00:13:02,480 --> 00:13:05,930
geographic data and so we use an

00:13:04,339 --> 00:13:09,529
extension on top of Postgres called

00:13:05,930 --> 00:13:12,459
PostGIS where the gist is GIS it stands

00:13:09,529 --> 00:13:17,240
for geographic information systems and

00:13:12,459 --> 00:13:19,880
that is a Postgres specific well it

00:13:17,240 --> 00:13:22,190
builds a set of specific objects with

00:13:19,880 --> 00:13:27,700
the database that you can use for

00:13:22,190 --> 00:13:27,700
managing geographic information systems

00:13:29,020 --> 00:13:35,570
now post gist object types don't always

00:13:33,530 --> 00:13:39,910
fit very well into the information

00:13:35,570 --> 00:13:44,980
schema and so that's just one example of

00:13:39,910 --> 00:13:49,430
where a database specific feature

00:13:44,980 --> 00:13:51,110
doesn't always make its way into the

00:13:49,430 --> 00:13:56,360
information schema in a clean and clear

00:13:51,110 --> 00:13:58,220
way but for the most part you can query

00:13:56,360 --> 00:14:00,100
just about anything about all the

00:13:58,220 --> 00:14:04,370
objects in the database that you want

00:14:00,100 --> 00:14:05,930
again with some caveats but just about

00:14:04,370 --> 00:14:07,490
anything you want through the

00:14:05,930 --> 00:14:10,820
information schema and you query it just

00:14:07,490 --> 00:14:12,830
like you use normal sequel to query the

00:14:10,820 --> 00:14:15,440
information schema it looks something

00:14:12,830 --> 00:14:18,740
like this so this is an example that's

00:14:15,440 --> 00:14:21,440
similar to some of the code that we use

00:14:18,740 --> 00:14:23,030
in our code base to query the

00:14:21,440 --> 00:14:29,920
information schema in fact I will show

00:14:23,030 --> 00:14:29,920
you what this actually looks like and

00:14:30,940 --> 00:14:38,810
can people read that text in the back

00:14:33,850 --> 00:14:40,220
yeah all right so this is actually what

00:14:38,810 --> 00:14:42,470
it looks like when we query the

00:14:40,220 --> 00:14:44,840
information schema so you know instead

00:14:42,470 --> 00:14:46,520
of just asking for a table name column

00:14:44,840 --> 00:14:48,230
data type and whether it's nullable or

00:14:46,520 --> 00:14:49,730
not we're actually asking for all of

00:14:48,230 --> 00:14:51,260
these different fields because all of

00:14:49,730 --> 00:14:55,430
these different fields may come into

00:14:51,260 --> 00:14:57,470
play when we're determining what type of

00:14:55,430 --> 00:15:00,860
thing were pulling out of the database

00:14:57,470 --> 00:15:03,560
but this is essentially asking for all

00:15:00,860 --> 00:15:05,230
the different columns that exist in the

00:15:03,560 --> 00:15:12,770
schema that we are concerned about

00:15:05,230 --> 00:15:18,280
within our database there are some

00:15:12,770 --> 00:15:22,700
things here that are ill-advised in

00:15:18,280 --> 00:15:26,530
database programming and I was talking

00:15:22,700 --> 00:15:30,650
with Tim a moment ago it turns out that

00:15:26,530 --> 00:15:33,050
both us at step wise and them at Wharton

00:15:30,650 --> 00:15:34,250
are doing these kind of auto-generating

00:15:33,050 --> 00:15:38,140
of AP

00:15:34,250 --> 00:15:43,850
and one thing that we were talking about

00:15:38,140 --> 00:15:47,030
was that there are in both of our code

00:15:43,850 --> 00:15:49,780
bases a lot of things that you might

00:15:47,030 --> 00:15:52,700
kind of scratch or scratch your chin at

00:15:49,780 --> 00:15:56,300
and say really do you want to do it that

00:15:52,700 --> 00:16:02,390
way but it works and it's it's still

00:15:56,300 --> 00:16:04,790
kind of neat so so yeah so this is this

00:16:02,390 --> 00:16:06,950
is again just pulling out all of the

00:16:04,790 --> 00:16:08,570
columns in the in our schema ordering

00:16:06,950 --> 00:16:10,190
them by table so that we can start to

00:16:08,570 --> 00:16:19,460
get a sense of what models are in our

00:16:10,190 --> 00:16:21,860
database so with that tool with the

00:16:19,460 --> 00:16:23,390
information schema we're able to know

00:16:21,860 --> 00:16:28,160
what's in the database but we still need

00:16:23,390 --> 00:16:30,650
to tell Jango what's in there and also

00:16:28,160 --> 00:16:32,570
if we want to use all the awesome tools

00:16:30,650 --> 00:16:34,040
with django or that come with different

00:16:32,570 --> 00:16:37,190
django packages like Django rest

00:16:34,040 --> 00:16:40,220
framework and general filters then we

00:16:37,190 --> 00:16:41,510
need to create some models so Django

00:16:40,220 --> 00:16:43,760
loves models and when I say general

00:16:41,510 --> 00:16:47,390
loves models I don't just mean like the

00:16:43,760 --> 00:16:51,710
core of the application platform that we

00:16:47,390 --> 00:16:57,380
all know and love but I mean the

00:16:51,710 --> 00:17:03,020
community Django and the ecosystem of

00:16:57,380 --> 00:17:07,390
tools and add-ons that is Django loves

00:17:03,020 --> 00:17:10,760
models because they are this consistent

00:17:07,390 --> 00:17:14,450
extendable interface on top of so many

00:17:10,760 --> 00:17:15,890
types of different data systems so

00:17:14,450 --> 00:17:18,980
there's good reason for Django to love

00:17:15,890 --> 00:17:22,390
models but one of the implications is

00:17:18,980 --> 00:17:24,800
that it becomes very difficult to do

00:17:22,390 --> 00:17:28,600
anything with all of those different

00:17:24,800 --> 00:17:33,400
add-ons in Django without having models

00:17:28,600 --> 00:17:36,980
so we have to create some models the way

00:17:33,400 --> 00:17:40,100
that we create models we add stepwise

00:17:36,980 --> 00:17:42,920
because it turns out there's a thousand

00:17:40,100 --> 00:17:46,820
different ways to do anything and you

00:17:42,920 --> 00:17:47,540
know again in my conversation a moment

00:17:46,820 --> 00:17:50,620
ago

00:17:47,540 --> 00:17:52,910
the folks are for with Tim from Wharton

00:17:50,620 --> 00:17:56,390
we're doing this in slightly different

00:17:52,910 --> 00:17:59,810
ways but the way that we're doing it at

00:17:56,390 --> 00:18:02,210
stepwise is with metaprogramming so what

00:17:59,810 --> 00:18:03,860
we're doing is we're building up so for

00:18:02,210 --> 00:18:05,750
those that aren't familiar with meta

00:18:03,860 --> 00:18:08,090
programming the idea behind it is that

00:18:05,750 --> 00:18:10,670
you're building up programming

00:18:08,090 --> 00:18:13,550
components using other programming

00:18:10,670 --> 00:18:17,630
components so in this case what we're

00:18:13,550 --> 00:18:20,450
doing is we're creating classes using

00:18:17,630 --> 00:18:21,920
functions as opposed to explicitly

00:18:20,450 --> 00:18:23,690
writing our classes so this is this is

00:18:21,920 --> 00:18:26,840
kind of an important concept in the way

00:18:23,690 --> 00:18:28,580
that were Auto generating this API so I

00:18:26,840 --> 00:18:31,690
want to I want to make sure that it's

00:18:28,580 --> 00:18:34,970
clear to everybody what it means so

00:18:31,690 --> 00:18:41,930
quick introduction to meta programming

00:18:34,970 --> 00:18:43,190
let's say you have the following now you

00:18:41,930 --> 00:18:46,430
know most people in the room will

00:18:43,190 --> 00:18:50,390
understand what this means this is

00:18:46,430 --> 00:18:53,750
creating a model called my model that's

00:18:50,390 --> 00:18:56,570
the name of that class it is extending

00:18:53,750 --> 00:18:59,060
the class models dot model that's the

00:18:56,570 --> 00:19:04,100
set of bases it's a set of one base

00:18:59,060 --> 00:19:08,960
class and it is adding a an attribute to

00:19:04,100 --> 00:19:10,760
that model called my field so fairly

00:19:08,960 --> 00:19:13,430
simple model here but let's say you

00:19:10,760 --> 00:19:16,910
needed another one that looked you know

00:19:13,430 --> 00:19:19,220
similar but had a few differences so you

00:19:16,910 --> 00:19:23,690
know maybe you copy and paste this one

00:19:19,220 --> 00:19:26,120
and create a a model one class that also

00:19:23,690 --> 00:19:28,430
has a my field maybe it has my field one

00:19:26,120 --> 00:19:32,060
or it has some slightly differently

00:19:28,430 --> 00:19:34,670
named attribute now let's say you need

00:19:32,060 --> 00:19:38,810
another one so you could copy and paste

00:19:34,670 --> 00:19:40,460
in your models app pie file again all

00:19:38,810 --> 00:19:42,620
right so now you have three model

00:19:40,460 --> 00:19:45,470
classes that all look about the same but

00:19:42,620 --> 00:19:48,590
are slightly different let's say you I

00:19:45,470 --> 00:19:50,540
don't need 50 of these then after a

00:19:48,590 --> 00:19:52,510
while you know you start adding and

00:19:50,540 --> 00:19:56,060
adding to your models dot pie file and

00:19:52,510 --> 00:19:59,870
you know this is this is a bit you know

00:19:56,060 --> 00:20:00,770
hyperbolic and is is a very much a toy

00:19:59,870 --> 00:20:03,290
example because

00:20:00,770 --> 00:20:04,850
there's not much utility 222 models that

00:20:03,290 --> 00:20:08,090
all have a single field called my field

00:20:04,850 --> 00:20:09,860
but at the same time I have found myself

00:20:08,090 --> 00:20:13,340
in a situation where I have a models dot

00:20:09,860 --> 00:20:14,180
pi file that's you know several thousand

00:20:13,340 --> 00:20:16,940
lines long

00:20:14,180 --> 00:20:21,410
and it could be split out into multiple

00:20:16,940 --> 00:20:22,820
models now PI files or multiple sub into

00:20:21,410 --> 00:20:25,750
a package that has multiple modules

00:20:22,820 --> 00:20:28,610
within it but it would still be

00:20:25,750 --> 00:20:32,600
thousands of lines of code to maintain

00:20:28,610 --> 00:20:35,720
in there and instead of doing that one

00:20:32,600 --> 00:20:39,290
thing that you could do is a little bit

00:20:35,720 --> 00:20:41,990
of meta programming so for example this

00:20:39,290 --> 00:20:47,150
code here will create 50 different

00:20:41,990 --> 00:20:49,460
models yeah this code here will create

00:20:47,150 --> 00:20:55,720
50 different models and they only named

00:20:49,460 --> 00:20:58,880
my model zero to my model 49 it will

00:20:55,720 --> 00:21:01,280
give it a set of base classes a set of

00:20:58,880 --> 00:21:04,730
one base class called models dot model

00:21:01,280 --> 00:21:07,970
and it will add some attributes to that

00:21:04,730 --> 00:21:10,520
model a set of one attribute called my

00:21:07,970 --> 00:21:13,550
field and then it will create a class

00:21:10,520 --> 00:21:21,140
from that name set of bases instead of

00:21:13,550 --> 00:21:25,820
attributes that last mine set adder on

00:21:21,140 --> 00:21:30,050
this module named model class is because

00:21:25,820 --> 00:21:33,230
of the way that we are getting Jango to

00:21:30,050 --> 00:21:36,950
recognize our models they have to be

00:21:33,230 --> 00:21:40,970
registered within the models dot pi

00:21:36,950 --> 00:21:44,510
module at load time so we have to

00:21:40,970 --> 00:21:47,960
actually bolt them on to the models dot

00:21:44,510 --> 00:21:52,250
PI module so it's it's a little bit of a

00:21:47,960 --> 00:21:54,350
hack but it works now the astute among

00:21:52,250 --> 00:21:56,000
you may say well do you really need some

00:21:54,350 --> 00:21:58,550
meta programming to do this no you might

00:21:56,000 --> 00:22:00,140
be able to just do this right you might

00:21:58,550 --> 00:22:02,060
be able to say okay well I have a for

00:22:00,140 --> 00:22:05,210
loop and you know

00:22:02,060 --> 00:22:10,330
I will there is a typo in this in this

00:22:05,210 --> 00:22:13,010
code but I have a for loop and I'll just

00:22:10,330 --> 00:22:14,540
put a normal class declaration inside of

00:22:13,010 --> 00:22:19,580
that for loop and add each one of those

00:22:14,540 --> 00:22:22,250
classes to my my module however the

00:22:19,580 --> 00:22:24,920
challenge starts when you need more than

00:22:22,250 --> 00:22:26,660
a single attribute called my field on

00:22:24,920 --> 00:22:28,370
each one of those classes if you don't

00:22:26,660 --> 00:22:30,920
know all of the different attributes

00:22:28,370 --> 00:22:35,690
that you need to put onto those classes

00:22:30,920 --> 00:22:38,300
beforehand then you're back to needing

00:22:35,690 --> 00:22:40,040
some more powerful solution and the

00:22:38,300 --> 00:22:43,340
beauty about meta programming is that

00:22:40,040 --> 00:22:46,100
you can treat the attributes on a class

00:22:43,340 --> 00:22:50,630
just like data you can create a

00:22:46,100 --> 00:22:56,540
dictionary of attributes for the class

00:22:50,630 --> 00:22:58,630
that you're creating so let me let me

00:22:56,540 --> 00:23:04,940
show you what this looks like in

00:22:58,630 --> 00:23:07,970
practice as well it's a little bit less

00:23:04,940 --> 00:23:10,730
clean than that simple for loop that I

00:23:07,970 --> 00:23:12,710
showed before but this is this is

00:23:10,730 --> 00:23:14,240
essentially let's see make API miles

00:23:12,710 --> 00:23:19,670
yeah this is essentially the function

00:23:14,240 --> 00:23:25,040
that we use to create the models in our

00:23:19,670 --> 00:23:27,590
API so it goes through it creates

00:23:25,040 --> 00:23:29,390
attributes creates base classes a set of

00:23:27,590 --> 00:23:33,050
one base class and creates a name for

00:23:29,390 --> 00:23:34,700
each one of the models and then it

00:23:33,050 --> 00:23:37,100
actually uses what's called a count

00:23:34,700 --> 00:23:39,590
cashing geometry aggregating query set

00:23:37,100 --> 00:23:40,520
as the manager on those models and I'm

00:23:39,590 --> 00:23:42,980
not gonna go into the geometry

00:23:40,520 --> 00:23:45,350
aggregating piece but I it's a really

00:23:42,980 --> 00:23:50,090
long name and that's okay because I only

00:23:45,350 --> 00:23:51,530
use it once but I will go into the count

00:23:50,090 --> 00:23:53,780
cashing part of that later

00:23:51,530 --> 00:23:55,700
not the geometry aggregating part that's

00:23:53,780 --> 00:24:01,210
that's going to be out of the scope and

00:23:55,700 --> 00:24:04,100
I have plenty I've plenty of opinions on

00:24:01,210 --> 00:24:06,440
integrating geometries into all of all

00:24:04,100 --> 00:24:07,760
of this thing but I'm not going to talk

00:24:06,440 --> 00:24:09,590
about all of those opinions because I

00:24:07,760 --> 00:24:11,950
don't have quite enough time so if you

00:24:09,590 --> 00:24:13,760
want to know more about integrating

00:24:11,950 --> 00:24:16,639
geometries and you

00:24:13,760 --> 00:24:23,779
type stuff into this kind of thing talk

00:24:16,639 --> 00:24:25,309
to me alright so let's move on though

00:24:23,779 --> 00:24:30,230
and know what about primary keys right

00:24:25,309 --> 00:24:33,710
okay so the Django ORM requires a single

00:24:30,230 --> 00:24:39,880
primary key field on every model now

00:24:33,710 --> 00:24:43,159
because we don't control entirely the

00:24:39,880 --> 00:24:47,029
the data that we're ingesting from all

00:24:43,159 --> 00:24:49,100
these city sources I also learned a neat

00:24:47,029 --> 00:24:52,850
trick when I was talking to Tim about

00:24:49,100 --> 00:24:55,220
this but because we don't control all of

00:24:52,850 --> 00:24:57,559
the the data that comes in from all

00:24:55,220 --> 00:24:59,750
these sources what we do is we actually

00:24:57,559 --> 00:25:02,870
add a throw away field to each and every

00:24:59,750 --> 00:25:05,750
table when we create that table in our

00:25:02,870 --> 00:25:08,210
data store and we use a tool an awesome

00:25:05,750 --> 00:25:12,320
tool this is an awesome tool by the way

00:25:08,210 --> 00:25:16,340
it's called DBT it's it's I think it

00:25:12,320 --> 00:25:18,529
stands for database tool honestly but it

00:25:16,340 --> 00:25:20,480
is it is really good

00:25:18,529 --> 00:25:21,950
it's from shout out to Fishtown

00:25:20,480 --> 00:25:23,470
analytics there's some folks out of

00:25:21,950 --> 00:25:30,039
Philadelphia

00:25:23,470 --> 00:25:32,720
and it allows you to manipulate your

00:25:30,039 --> 00:25:35,450
database with sequel queries but

00:25:32,720 --> 00:25:37,309
templated sequel queries it actually

00:25:35,450 --> 00:25:40,029
uses ginger templates so that you can do

00:25:37,309 --> 00:25:43,519
things like instead of creating gnarly

00:25:40,029 --> 00:25:45,409
huge sequel queries with all sorts of

00:25:43,519 --> 00:25:47,090
nested sequel queries inside of them and

00:25:45,409 --> 00:25:50,529
so on which is sometimes necessary you

00:25:47,090 --> 00:25:53,870
can include sequel queries from other

00:25:50,529 --> 00:25:55,070
sequel templates so it's it's actually

00:25:53,870 --> 00:25:57,440
that's one of the things that it does

00:25:55,070 --> 00:26:01,549
but it's it's an awesome tool you should

00:25:57,440 --> 00:26:05,539
check it out all right so after this we

00:26:01,549 --> 00:26:07,370
have our models so the next thing that

00:26:05,539 --> 00:26:09,260
we have to do is create the serializers

00:26:07,370 --> 00:26:10,460
and this is actually a lot simpler than

00:26:09,260 --> 00:26:12,769
creating the model so it should be

00:26:10,460 --> 00:26:15,860
quicker well let's see

00:26:12,769 --> 00:26:19,490
yeah it involves less metaprogramming

00:26:15,860 --> 00:26:22,490
not not none but less in some classes

00:26:19,490 --> 00:26:25,220
the model serialize a class so and we

00:26:22,490 --> 00:26:25,690
exclude the primary key that we added

00:26:25,220 --> 00:26:31,440
because

00:26:25,690 --> 00:26:31,440
Django needed us to so this is what our

00:26:31,799 --> 00:26:39,039
our serializer creation function looks

00:26:34,929 --> 00:26:44,169
like so here is we're actually getting

00:26:39,039 --> 00:26:46,509
rid of that primary key because it is

00:26:44,169 --> 00:26:48,639
useless for us to expose that Django ID

00:26:46,509 --> 00:26:51,820
it doesn't mean anything it's just an

00:26:48,639 --> 00:26:56,649
auto incrementing number that we add

00:26:51,820 --> 00:26:58,990
onto each table because we had to so we

00:26:56,649 --> 00:27:04,210
get rid of it when we serialize the data

00:26:58,990 --> 00:27:07,240
for rendering through the API and then

00:27:04,210 --> 00:27:13,840
we create a model serializer class that

00:27:07,240 --> 00:27:15,000
points to the each model and yeah that's

00:27:13,840 --> 00:27:19,570
that one

00:27:15,000 --> 00:27:25,450
so serializers again are relatively

00:27:19,570 --> 00:27:32,559
simple and the filter sets are slightly

00:27:25,450 --> 00:27:35,009
less simple but still not too bad so the

00:27:32,559 --> 00:27:38,289
way that the filter set generation work

00:27:35,009 --> 00:27:41,440
oh by the way so for those of you who

00:27:38,289 --> 00:27:43,960
don't know have never used I've never

00:27:41,440 --> 00:27:46,659
been exposed to Django filters jangle

00:27:43,960 --> 00:27:49,779
filters the package not just filters and

00:27:46,659 --> 00:27:51,460
Django's for example on query sets but

00:27:49,779 --> 00:27:55,120
django filters is a package that allows

00:27:51,460 --> 00:27:58,929
us to quit make queries in our api that

00:27:55,120 --> 00:28:02,169
our django like for example this one

00:27:58,929 --> 00:28:04,659
here this is a sample query string where

00:28:02,169 --> 00:28:07,269
we're saying okay well give me

00:28:04,659 --> 00:28:09,220
everything where the region is in a

00:28:07,269 --> 00:28:11,169
single region it could just be region

00:28:09,220 --> 00:28:12,549
equals phl and improved areas less than

00:28:11,169 --> 00:28:14,860
or equal to a few thousand feet and

00:28:12,549 --> 00:28:16,570
vacant is true so it allows us to

00:28:14,860 --> 00:28:18,129
construct query strings like that that

00:28:16,570 --> 00:28:19,600
will just pass that information it will

00:28:18,129 --> 00:28:25,179
actually validate that information then

00:28:19,600 --> 00:28:28,110
pass it along to our query sets so we

00:28:25,179 --> 00:28:31,600
determine what filters are available

00:28:28,110 --> 00:28:33,480
based on the type of each field and then

00:28:31,600 --> 00:28:38,520
we also add in our

00:28:33,480 --> 00:28:45,450
own custom filters to to Jango filter

00:28:38,520 --> 00:28:49,799
sets so that code is also not

00:28:45,450 --> 00:28:51,270
particularly interesting it simply loops

00:28:49,799 --> 00:28:54,240
over each one of the tables in the

00:28:51,270 --> 00:29:00,179
database gets the model class for that

00:28:54,240 --> 00:29:03,809
table generates the names for each one

00:29:00,179 --> 00:29:06,360
of the fields it comes up here and says

00:29:03,809 --> 00:29:08,010
alright if it's a character field then

00:29:06,360 --> 00:29:10,650
you can do these things with it if it's

00:29:08,010 --> 00:29:12,450
a integer field you can also do these

00:29:10,650 --> 00:29:14,460
things with it all fields you can do

00:29:12,450 --> 00:29:17,490
these things with and it just creates

00:29:14,460 --> 00:29:20,580
those sets of filter that those filter

00:29:17,490 --> 00:29:22,950
sets for each one of your models so that

00:29:20,580 --> 00:29:27,030
you can do things like query from an API

00:29:22,950 --> 00:29:34,400
so the last thing that we need to do is

00:29:27,030 --> 00:29:38,700
create and expose the views or more more

00:29:34,400 --> 00:29:41,010
or rather the view sets so Django rest

00:29:38,700 --> 00:29:45,390
framework has a concept of view sets

00:29:41,010 --> 00:29:47,700
which are essentially collections of

00:29:45,390 --> 00:29:49,950
views that are bottled up into they're

00:29:47,700 --> 00:29:52,230
essentially class-based views they're

00:29:49,950 --> 00:29:57,150
very similar to class-based views in

00:29:52,230 --> 00:29:59,010
Django but they're based around each one

00:29:57,150 --> 00:30:01,830
of your resources so you can say okay

00:29:59,010 --> 00:30:09,419
for this resource I want to have a list

00:30:01,830 --> 00:30:11,850
a detail a we create and an update

00:30:09,419 --> 00:30:15,270
function and all of those are exposed at

00:30:11,850 --> 00:30:21,660
different endpoints or with different

00:30:15,270 --> 00:30:24,540
HTTP methods so the view set creation

00:30:21,660 --> 00:30:26,510
code for us is mostly straightforward it

00:30:24,540 --> 00:30:29,640
does require some more meta programming

00:30:26,510 --> 00:30:31,710
and it does and one of the things that

00:30:29,640 --> 00:30:34,169
we do is start to auto-generate some of

00:30:31,710 --> 00:30:35,850
the documentation I don't know if how

00:30:34,169 --> 00:30:38,040
many people in here have ever seen

00:30:35,850 --> 00:30:41,100
Django rest framework auto-generated

00:30:38,040 --> 00:30:43,010
that or rather documentation how many

00:30:41,100 --> 00:30:45,470
people have used Django rest framework

00:30:43,010 --> 00:30:48,320
you ask that and how many people have

00:30:45,470 --> 00:30:51,110
used the the browsable api feature on

00:30:48,320 --> 00:30:53,300
Django rest framework okay so that that

00:30:51,110 --> 00:31:00,100
documentation feature that comes with a

00:30:53,300 --> 00:31:00,100
browsable api where you can set the

00:31:06,880 --> 00:31:17,950
essentially for each one of our

00:31:11,780 --> 00:31:20,330
endpoints we build up a a set of

00:31:17,950 --> 00:31:23,300
documentation that if you go to that

00:31:20,330 --> 00:31:24,920
endpoint you can see the the

00:31:23,300 --> 00:31:28,630
documentation for using that endpoint

00:31:24,920 --> 00:31:28,630
directly on it

00:31:29,380 --> 00:31:35,000
there are also fancier ways to do this

00:31:32,660 --> 00:31:36,620
again I have to keep referring to the

00:31:35,000 --> 00:31:38,750
work that they've done over at Wharton

00:31:36,620 --> 00:31:40,880
cuz I got a tour of it from Tim and I'm

00:31:38,750 --> 00:31:44,000
just like oh yeah this is great

00:31:40,880 --> 00:31:46,400
but we we have been trying to solve some

00:31:44,000 --> 00:31:52,670
of the same problems independently

00:31:46,400 --> 00:31:55,280
within the same city somehow so as I

00:31:52,670 --> 00:31:57,740
said generating these view sets requires

00:31:55,280 --> 00:32:01,510
a little bit more meta programming where

00:31:57,740 --> 00:32:03,440
we are grabbing the table name

00:32:01,510 --> 00:32:06,920
generating the name of the view set

00:32:03,440 --> 00:32:10,130
using a whole bunch of base classes that

00:32:06,920 --> 00:32:12,250
do things that are somewhat outside of

00:32:10,130 --> 00:32:20,800
the scope of this talk some of them are

00:32:12,250 --> 00:32:27,590
and then creating the actual view set

00:32:20,800 --> 00:32:29,390
using the type meta class and one of the

00:32:27,590 --> 00:32:32,630
things that I didn't talk about in meta

00:32:29,390 --> 00:32:36,020
programming is meta classes and a meta

00:32:32,630 --> 00:32:38,210
class is essentially for this purpose it

00:32:36,020 --> 00:32:41,000
is a thing it's a function that will

00:32:38,210 --> 00:32:44,240
return a class object not an instance of

00:32:41,000 --> 00:32:46,280
a class object but a class itself so

00:32:44,240 --> 00:32:48,290
this when we're calling type here we're

00:32:46,280 --> 00:32:50,330
using type as a kind of meta class type

00:32:48,290 --> 00:32:53,330
as the meta class of most classes by

00:32:50,330 --> 00:32:54,950
default but we're using type as a meta

00:32:53,330 --> 00:32:58,880
class as a function

00:32:54,950 --> 00:33:03,919
to create a class object just like we

00:32:58,880 --> 00:33:06,919
did with model base which is actually

00:33:03,919 --> 00:33:13,010
the base the the metaclass for models

00:33:06,919 --> 00:33:15,440
model in django that it uses so we use

00:33:13,010 --> 00:33:19,100
that model based class to create our

00:33:15,440 --> 00:33:24,909
model classes but they're all just

00:33:19,100 --> 00:33:24,909
functions that create classes so

00:33:25,779 --> 00:33:32,330
additionally with view sets you'll also

00:33:30,080 --> 00:33:34,610
want to set up throttling authentication

00:33:32,330 --> 00:33:36,490
permissions pagination and any special

00:33:34,610 --> 00:33:39,139
renderers that you might want to use

00:33:36,490 --> 00:33:41,570
most of those again are out of scope for

00:33:39,139 --> 00:33:43,970
this talk but there are two things that

00:33:41,570 --> 00:33:47,269
i want to i want to talk about which are

00:33:43,970 --> 00:33:49,370
the permissions and the pagination so as

00:33:47,269 --> 00:33:51,860
far as permissions go we wanted our api

00:33:49,370 --> 00:33:55,340
to be consumable by our clients but not

00:33:51,860 --> 00:34:00,159
all of the endpoints so the thing that

00:33:55,340 --> 00:34:02,360
we decided to do in our api was use

00:34:00,159 --> 00:34:05,570
Django rest framework permission

00:34:02,360 --> 00:34:12,169
framework so first what we did was we

00:34:05,570 --> 00:34:15,169
created a an access profile that is

00:34:12,169 --> 00:34:20,419
attached to each user and essentially

00:34:15,169 --> 00:34:26,800
tells what which routes which which

00:34:20,419 --> 00:34:33,889
resources a particular user can access

00:34:26,800 --> 00:34:38,899
we then use that off profile or that

00:34:33,889 --> 00:34:41,000
access profile in a Django rest

00:34:38,899 --> 00:34:42,700
framework permissions class that is

00:34:41,000 --> 00:34:45,919
derived from is authenticated and

00:34:42,700 --> 00:34:48,950
essentially just checks whether the user

00:34:45,919 --> 00:34:50,780
is authenticated and if they are well if

00:34:48,950 --> 00:34:54,260
they're not then they can't access this

00:34:50,780 --> 00:34:58,640
resource but if they are then we've

00:34:54,260 --> 00:35:00,260
added a function to all of our views

00:34:58,640 --> 00:35:04,640
that was this comes from one of those

00:35:00,260 --> 00:35:07,780
base classes on the view sets so it adds

00:35:04,640 --> 00:35:07,780
a function to each of the views

00:35:09,140 --> 00:35:16,310
allows us to get the endpoints that the

00:35:13,040 --> 00:35:18,349
user is requesting the endpoint that the

00:35:16,310 --> 00:35:22,040
user is requesting and allows us to

00:35:18,349 --> 00:35:29,030
check whether the user has access to

00:35:22,040 --> 00:35:32,329
that endpoint so the other thing that I

00:35:29,030 --> 00:35:33,980
wanted to talk about was pagination not

00:35:32,329 --> 00:35:37,190
specifically pagination but really just

00:35:33,980 --> 00:35:39,349
counting counting in the API so by

00:35:37,190 --> 00:35:42,560
default Django rest framework pagination

00:35:39,349 --> 00:35:45,200
classes include the total count of

00:35:42,560 --> 00:35:48,470
records that match any particular filter

00:35:45,200 --> 00:35:53,630
that you throw at them in the response

00:35:48,470 --> 00:35:54,500
now initially I didn't think this was

00:35:53,630 --> 00:35:58,579
gonna be a problem

00:35:54,500 --> 00:36:00,950
I thought databases were pretty fast at

00:35:58,579 --> 00:36:03,079
counting how many things match our query

00:36:00,950 --> 00:36:06,020
and it turns out they are when I say you

00:36:03,079 --> 00:36:07,490
know fast I mean like milliseconds not

00:36:06,020 --> 00:36:09,710
seconds it turns out it's closer to

00:36:07,490 --> 00:36:15,710
seconds when you get up to millions of

00:36:09,710 --> 00:36:18,470
rows of data so that is too slow when

00:36:15,710 --> 00:36:21,760
you're talking about an API that a an

00:36:18,470 --> 00:36:24,980
application is is being built on top of

00:36:21,760 --> 00:36:30,430
so in order to get around this what we

00:36:24,980 --> 00:36:35,230
had to do was implement our own

00:36:30,430 --> 00:36:38,329
pagination class and by the way it is

00:36:35,230 --> 00:36:40,670
awesome that Django rest framework like

00:36:38,329 --> 00:36:43,099
even allows you to do this like that it

00:36:40,670 --> 00:36:44,900
it had that you know tom christie and

00:36:43,099 --> 00:36:46,160
everybody who else who works on generous

00:36:44,900 --> 00:36:48,440
framework all of those awesome people

00:36:46,160 --> 00:36:50,210
had the foresight to say you know maybe

00:36:48,440 --> 00:36:52,069
people are gonna want to customize the

00:36:50,210 --> 00:36:57,859
way that they paginate their their data

00:36:52,069 --> 00:36:59,569
in the api so specifically we use

00:36:57,859 --> 00:37:02,450
something called a conditional count

00:36:59,569 --> 00:37:07,300
pagination class which subclasses limit

00:37:02,450 --> 00:37:10,690
offset pagination and if the user

00:37:07,300 --> 00:37:14,480
includes a certain query parameter in

00:37:10,690 --> 00:37:18,200
their query then we give them the count

00:37:14,480 --> 00:37:19,140
of the objects along with the results of

00:37:18,200 --> 00:37:22,259
their

00:37:19,140 --> 00:37:24,269
the results of their their query if they

00:37:22,259 --> 00:37:27,329
don't then we don't count the objects

00:37:24,269 --> 00:37:29,969
all we do is we give them the the

00:37:27,329 --> 00:37:33,419
response this speeds things up

00:37:29,969 --> 00:37:36,959
dramatically you would be if you've

00:37:33,419 --> 00:37:39,059
never experienced this you I kid you not

00:37:36,959 --> 00:37:40,529
you would be surprised how long it takes

00:37:39,059 --> 00:37:45,239
the database just to count the things

00:37:40,529 --> 00:37:47,369
that it is able to return to you I mean

00:37:45,239 --> 00:37:54,569
but otherwise Postgres is wonderful it

00:37:47,369 --> 00:38:01,739
just takes a long time to count so so we

00:37:54,569 --> 00:38:04,589
have this custom paginate ER and we

00:38:01,739 --> 00:38:06,839
override a few of the limit offset

00:38:04,589 --> 00:38:10,529
pagination functions specifically

00:38:06,839 --> 00:38:15,689
paginate query set where we only include

00:38:10,529 --> 00:38:18,209
the count if we are asked to otherwise

00:38:15,689 --> 00:38:21,209
we just skip it

00:38:18,209 --> 00:38:23,459
get next link because in Django rest

00:38:21,209 --> 00:38:26,489
framework you have a link to the next

00:38:23,459 --> 00:38:30,269
page of results and the way that Django

00:38:26,489 --> 00:38:33,509
rest framework works is if you don't

00:38:30,269 --> 00:38:35,249
have any more results on the next page

00:38:33,509 --> 00:38:38,579
then it won't give you a next link it'll

00:38:35,249 --> 00:38:40,289
just say no if you have not asked with

00:38:38,579 --> 00:38:42,359
our paginate or if you have not asked

00:38:40,289 --> 00:38:44,099
for the count and we always give you a

00:38:42,359 --> 00:38:45,650
next link and you just have to check it

00:38:44,099 --> 00:38:48,749
and see if there are any results there

00:38:45,650 --> 00:38:50,729
but it turns out that this for our use

00:38:48,749 --> 00:39:00,630
case is faster than including the count

00:38:50,729 --> 00:39:04,679
with every page of results so at this

00:39:00,630 --> 00:39:07,529
point we have an auto-generated API

00:39:04,679 --> 00:39:09,719
we've we've we've created our models

00:39:07,529 --> 00:39:13,559
we've created serializers and filter

00:39:09,719 --> 00:39:16,259
sets and views as well and now people

00:39:13,559 --> 00:39:21,469
can access data all the way from the

00:39:16,259 --> 00:39:21,469
database out to their browser

00:39:21,589 --> 00:39:29,300
so in conclusion should you Auto

00:39:26,909 --> 00:39:33,320
generate an API

00:39:29,300 --> 00:39:39,380
so my recommendation would be if you

00:39:33,320 --> 00:39:41,630
just have a few tables no just create

00:39:39,380 --> 00:39:43,490
models for all of those tables and

00:39:41,630 --> 00:39:45,830
what's a few I mean it's really up to

00:39:43,490 --> 00:39:47,810
you it depends on how many fields are in

00:39:45,830 --> 00:39:50,660
those tables and how complicated your

00:39:47,810 --> 00:39:53,540
logic gets when dealing with each one of

00:39:50,660 --> 00:39:56,060
those tables and how customized your

00:39:53,540 --> 00:40:00,830
logic is in in dealing with each one of

00:39:56,060 --> 00:40:02,420
those tables for us the the number of

00:40:00,830 --> 00:40:04,370
tables that are generally served by our

00:40:02,420 --> 00:40:07,220
API is somewhere on the order of several

00:40:04,370 --> 00:40:11,980
hundred for some folks it's several

00:40:07,220 --> 00:40:16,250
thousand but if you have fewer than like

00:40:11,980 --> 00:40:19,330
40 or so tables no don't don't do it

00:40:16,250 --> 00:40:22,100
just maintain your models dot pie file

00:40:19,330 --> 00:40:25,430
if the majority of your data is user

00:40:22,100 --> 00:40:28,010
generated I wouldn't recommend you do

00:40:25,430 --> 00:40:33,410
this either because you're not starting

00:40:28,010 --> 00:40:36,530
from a an existing data source your data

00:40:33,410 --> 00:40:38,180
is coming from your users and so there's

00:40:36,530 --> 00:40:44,510
really no need for you to go through the

00:40:38,180 --> 00:40:46,370
extra headache of spinning up a database

00:40:44,510 --> 00:40:49,010
to do a bunch of extra logic on you

00:40:46,370 --> 00:40:52,820
should just let Jen go handle your

00:40:49,010 --> 00:40:55,420
migrations and manage your database if

00:40:52,820 --> 00:41:00,470
most of your data is coming from is

00:40:55,420 --> 00:41:03,590
generated by your users if you can trust

00:41:00,470 --> 00:41:07,150
your schema to be predictable and this

00:41:03,590 --> 00:41:09,440
one's a little a little I'm not sure

00:41:07,150 --> 00:41:11,420
because if you can trust your schema to

00:41:09,440 --> 00:41:13,490
be predictable but it's still thousands

00:41:11,420 --> 00:41:15,350
of tables thousands of predictable

00:41:13,490 --> 00:41:19,100
tables and maybe you should Auto

00:41:15,350 --> 00:41:22,360
generate your API but you know you could

00:41:19,100 --> 00:41:22,360
you could go either way you could just

00:41:22,840 --> 00:41:29,480
generate your for example generate your

00:41:25,820 --> 00:41:31,790
models dot pie files there are tools to

00:41:29,480 --> 00:41:34,130
do this you could use inspect DB but

00:41:31,790 --> 00:41:37,710
that has some drawbacks the folks at

00:41:34,130 --> 00:41:41,310
Wharton are using I

00:41:37,710 --> 00:41:44,849
Martin at this point but the folks at

00:41:41,310 --> 00:41:47,369
Wharton have developed more

00:41:44,849 --> 00:41:49,440
sophisticated methods of generating

00:41:47,369 --> 00:41:52,250
models type I files and we should

00:41:49,440 --> 00:41:59,310
totally all open-source this stuff but

00:41:52,250 --> 00:42:01,920
takes take some time but yeah if your

00:41:59,310 --> 00:42:06,830
schema is predictable a better choice

00:42:01,920 --> 00:42:13,740
might just be to generate models pi and

00:42:06,830 --> 00:42:17,550
leave it at that so would I do this

00:42:13,740 --> 00:42:21,450
again if I had the chance to go back in

00:42:17,550 --> 00:42:25,109
time I don't know it's still kind of

00:42:21,450 --> 00:42:28,320
neat and you know for that matter we've

00:42:25,109 --> 00:42:31,020
been running on this for upwards of two

00:42:28,320 --> 00:42:33,510
years at this point which is a pretty

00:42:31,020 --> 00:42:37,320
good time for for any particular system

00:42:33,510 --> 00:42:39,690
I mean you know it's still it's still

00:42:37,320 --> 00:42:46,070
going sometimes it's a little bit of a

00:42:39,690 --> 00:42:49,740
headache to to maintain and to have to

00:42:46,070 --> 00:42:51,780
go in and fix something for a particular

00:42:49,740 --> 00:42:56,970
end point and not have it break all the

00:42:51,780 --> 00:42:59,730
others but but I don't know it's it's

00:42:56,970 --> 00:43:04,260
all trade-offs so if you're creating a

00:42:59,730 --> 00:43:07,500
data warehouse and none of those points

00:43:04,260 --> 00:43:10,320
above apply then maybe maybe you should

00:43:07,500 --> 00:43:11,820
use this method otherwise I'm not really

00:43:10,320 --> 00:43:12,990
sure but it's still neat and I would

00:43:11,820 --> 00:43:16,820
recommend it just for your own

00:43:12,990 --> 00:43:16,820
edification that's it

00:43:19,070 --> 00:43:22,109
thank you

00:43:20,640 --> 00:43:23,310
do you I was just curious do you have a

00:43:22,109 --> 00:43:25,800
lot of relationships you have to work

00:43:23,310 --> 00:43:27,900
with and my job we've got a lot of

00:43:25,800 --> 00:43:32,580
relationships and I didn't see mentioned

00:43:27,900 --> 00:43:34,530
right no and that is useful it is useful

00:43:32,580 --> 00:43:39,240
to not have a lot of relationships to

00:43:34,530 --> 00:43:40,920
work with in in this case I have thought

00:43:39,240 --> 00:43:42,390
about that a lot because there are a lot

00:43:40,920 --> 00:43:44,550
of relationships that we could build

00:43:42,390 --> 00:43:47,339
into the database it just happened to be

00:43:44,550 --> 00:43:50,440
that we weren't when we put this

00:43:47,339 --> 00:43:52,810
together and if we did

00:43:50,440 --> 00:43:58,320
it would require rethinking the way that

00:43:52,810 --> 00:44:01,810
we do a few things specifically in

00:43:58,320 --> 00:44:03,430
reading the in introspecting the

00:44:01,810 --> 00:44:06,280
database right now we're not we're not

00:44:03,430 --> 00:44:09,640
picking out any kind of foreign key

00:44:06,280 --> 00:44:13,360
relationships any kind of um any any of

00:44:09,640 --> 00:44:15,910
that stuff so we may move in that

00:44:13,360 --> 00:44:19,270
direction in the future I don't know

00:44:15,910 --> 00:44:21,850
whether we will use this exact same

00:44:19,270 --> 00:44:22,870
method if we do custom fascinators are

00:44:21,850 --> 00:44:24,010
going to be a solution to a problem

00:44:22,870 --> 00:44:26,680
we're facing in production right now

00:44:24,010 --> 00:44:30,130
thank you for that tip have you given

00:44:26,680 --> 00:44:31,930
any investigation to using explain plans

00:44:30,130 --> 00:44:48,040
from the database to get the counts

00:44:31,930 --> 00:44:50,350
faster yes ultimately it was a it was a

00:44:48,040 --> 00:44:52,990
better use of my time to just do the

00:44:50,350 --> 00:44:56,380
custom paginate er so I spent a lot of

00:44:52,990 --> 00:45:02,970
time trying to explain what in the

00:44:56,380 --> 00:45:08,080
database was taking so long and

00:45:02,970 --> 00:45:12,310
ultimately I I tried a number of things

00:45:08,080 --> 00:45:15,310
one of them was just using an estimate

00:45:12,310 --> 00:45:17,380
of how many things were in the database

00:45:15,310 --> 00:45:20,020
or in a particular query as opposed to

00:45:17,380 --> 00:45:21,250
the exact number but it turns out for a

00:45:20,020 --> 00:45:23,020
number of reasons

00:45:21,250 --> 00:45:27,760
sometimes we need the exact number and

00:45:23,020 --> 00:45:29,980
so it did for our use case this was just

00:45:27,760 --> 00:45:31,480
the best solution there are other

00:45:29,980 --> 00:45:33,310
approaches that people might be able to

00:45:31,480 --> 00:45:37,210
take in terms of estimating the number

00:45:33,310 --> 00:45:39,550
of the number of results but for our use

00:45:37,210 --> 00:45:41,140
case this was the best solution I guess

00:45:39,550 --> 00:45:42,280
the best I don't know it was the

00:45:41,140 --> 00:45:45,490
solution that I came up with at the time

00:45:42,280 --> 00:45:47,320
thank you that was really great um I was

00:45:45,490 --> 00:45:49,300
wondering if you do any tricks or

00:45:47,320 --> 00:45:51,070
anything or if it's fast enough when you

00:45:49,300 --> 00:45:52,960
do application restarts but maybe you

00:45:51,070 --> 00:45:54,220
only have one new data table if you like

00:45:52,960 --> 00:45:55,900
cache them or anything because you're

00:45:54,220 --> 00:46:00,369
pushing everything onto the stack on the

00:45:55,900 --> 00:46:03,279
start right so caching caching

00:46:00,369 --> 00:46:04,479
or rather caching the information about

00:46:03,279 --> 00:46:06,400
tables is something that we've

00:46:04,479 --> 00:46:08,200
considered it just hasn't been something

00:46:06,400 --> 00:46:14,019
that we tackled yet were four people

00:46:08,200 --> 00:46:15,700
right now and growing by the way but but

00:46:14,019 --> 00:46:16,960
it just hasn't been something we tackled

00:46:15,700 --> 00:46:19,960
yet so like you know something I was

00:46:16,960 --> 00:46:23,289
thinking about is is at the end of our

00:46:19,960 --> 00:46:26,200
data pipeline refresh maybe we you know

00:46:23,289 --> 00:46:28,630
dump out a like a sequel representation

00:46:26,200 --> 00:46:30,039
of the schema and then we can just read

00:46:28,630 --> 00:46:31,119
that in as opposed to going all the way

00:46:30,039 --> 00:46:33,729
to the database and running those

00:46:31,119 --> 00:46:35,499
queries to because that does take I mean

00:46:33,729 --> 00:46:38,920
not an inordinate amount of time with

00:46:35,499 --> 00:46:41,739
hundreds of tables it's maybe okay maybe

00:46:38,920 --> 00:46:43,390
like 30 seconds or so but yeah hi it

00:46:41,739 --> 00:46:44,680
looks like when you get a data set

00:46:43,390 --> 00:46:46,869
that's different from your previous data

00:46:44,680 --> 00:46:49,569
sets that's gonna change all the filters

00:46:46,869 --> 00:46:50,680
on your API so the interface for clients

00:46:49,569 --> 00:46:55,059
is gonna change if you do anything to

00:46:50,680 --> 00:46:57,729
control for that so there are there are

00:46:55,059 --> 00:47:00,489
things in our in our API that are okay

00:46:57,729 --> 00:47:02,380
to change some things are not and those

00:47:00,489 --> 00:47:04,719
things we check for at the data pipeline

00:47:02,380 --> 00:47:07,529
level for the things that are okay to

00:47:04,719 --> 00:47:10,599
change right now we just let them change

00:47:07,529 --> 00:47:13,900
and we do we do get notified when things

00:47:10,599 --> 00:47:16,089
do change and so we are able to let

00:47:13,900 --> 00:47:18,069
clients know and so on and you know

00:47:16,089 --> 00:47:20,769
we're able to respond to it internally

00:47:18,069 --> 00:47:24,670
but there are just things that are okay

00:47:20,769 --> 00:47:26,619
to change and for those things that are

00:47:24,670 --> 00:47:29,200
not okay to change we we respond to it

00:47:26,619 --> 00:47:30,640
earlier than at the application level by

00:47:29,200 --> 00:47:32,559
building those checks into the data

00:47:30,640 --> 00:47:34,970
pipeline thank you again

00:47:32,559 --> 00:47:41,789
do be ready for the next

00:47:34,970 --> 00:47:41,789

YouTube URL: https://www.youtube.com/watch?v=fNXpQ14LKfk


