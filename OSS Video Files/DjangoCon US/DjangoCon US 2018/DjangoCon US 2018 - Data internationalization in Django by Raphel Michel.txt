Title: DjangoCon US 2018 - Data internationalization in Django by Raphel Michel
Publication date: 2018-11-10
Playlist: DjangoCon US 2018
Description: 
	DjangoCon US 2018 - Data internationalization in Django by Raphel Michel

There is a multitude of options to translate database data in Django, for example django-parler, django-modeltranslation, django-nece, django-hvad, and django-i18nfield (which is my own). The interesting thing is that these libraries are not multiple implementations of the same thing, but they are all radically different in their design and there are good reasons for every one of them. The sometimes subtle differences might not be obvious to a beginner in the Django world. This talk will help them navigate through different solutions and make an informed decision.

This talk was presented at: https://2018.djangocon.us/talk/data-internationalization-in-django/

LINKS:
Follow Raphel Michel ðŸ‘‡
On Twitter: https://twitter.com/_rami_
Official homepage: https://www.raphaelmichel.de

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,050 --> 00:00:07,709
[Music]

00:00:15,949 --> 00:00:19,800
good afternoon from my side as well my

00:00:18,510 --> 00:00:23,100
name is Rafael I'm a software developer

00:00:19,800 --> 00:00:25,380
from Heidelberg in Germany and I've been

00:00:23,100 --> 00:00:29,039
the co-chair of jeguk on Europe this

00:00:25,380 --> 00:00:31,920
year and as this conference is coming to

00:00:29,039 --> 00:00:33,960
you to close shortly I will want to take

00:00:31,920 --> 00:00:35,820
the opportunity to thank to thank the

00:00:33,960 --> 00:00:38,100
organizers for putting up this

00:00:35,820 --> 00:00:39,780
conference because once you've done

00:00:38,100 --> 00:00:43,710
something like this you get to really

00:00:39,780 --> 00:00:45,510
appreciate not having to do it and just

00:00:43,710 --> 00:00:47,100
sitting here and enjoy the wonderful

00:00:45,510 --> 00:00:48,780
conference that they created for us

00:00:47,100 --> 00:00:54,300
thank you so much for bringing me here

00:00:48,780 --> 00:00:57,059
to see this now let's get to the the

00:00:54,300 --> 00:00:59,160
topic I want to be talking about which

00:00:57,059 --> 00:01:01,920
is data internationalization in Django

00:00:59,160 --> 00:01:04,589
and before we do that let's recap

00:01:01,920 --> 00:01:07,430
shortly what internationalization in

00:01:04,589 --> 00:01:10,920
Django without the data could mean and

00:01:07,430 --> 00:01:13,010
we've had a talk I think yesterday or

00:01:10,920 --> 00:01:16,049
the day before on the subject before

00:01:13,010 --> 00:01:18,390
Django has set of features that allows

00:01:16,049 --> 00:01:21,960
you to translate your application into

00:01:18,390 --> 00:01:26,430
other languages this means that you can

00:01:21,960 --> 00:01:28,350
use certain functions to mark strings in

00:01:26,430 --> 00:01:31,020
your code or in your templates to say

00:01:28,350 --> 00:01:32,759
okay this is a string that is different

00:01:31,020 --> 00:01:34,650
when my application is not run in

00:01:32,759 --> 00:01:36,450
English or not used in English but in

00:01:34,650 --> 00:01:38,820
another language and then you can use

00:01:36,450 --> 00:01:40,710
the getx toolkit which is like the

00:01:38,820 --> 00:01:43,680
standard translation toolkit in the

00:01:40,710 --> 00:01:46,170
whole UNIX world do you extract all of

00:01:43,680 --> 00:01:48,030
those strings create a file with all the

00:01:46,170 --> 00:01:51,030
translations Senate our two translators

00:01:48,030 --> 00:01:53,549
collect the translations again compile

00:01:51,030 --> 00:01:57,090
it and use it and that's great but

00:01:53,549 --> 00:01:59,700
sometimes it's not enough one of the

00:01:57,090 --> 00:02:02,850
open source projects I'm maintaining is

00:01:59,700 --> 00:02:05,540
protects which is an open source ticket

00:02:02,850 --> 00:02:10,170
shop for events just like this one and

00:02:05,540 --> 00:02:12,840
it allows you to create shop that speaks

00:02:10,170 --> 00:02:13,470
to a multilingual audience so if you

00:02:12,840 --> 00:02:14,640
have a

00:02:13,470 --> 00:02:17,250
attendees coming from different

00:02:14,640 --> 00:02:20,040
countries speaking different languages

00:02:17,250 --> 00:02:22,530
you might want to present your shop in

00:02:20,040 --> 00:02:24,600
multiple languages at the same time and

00:02:22,530 --> 00:02:27,600
that means it's not sufficient if only

00:02:24,600 --> 00:02:30,480
the application is translated you need

00:02:27,600 --> 00:02:32,790
to translate data as well and buy data I

00:02:30,480 --> 00:02:34,650
mean things that are entered by the

00:02:32,790 --> 00:02:36,920
administrator for the shop for example

00:02:34,650 --> 00:02:39,330
the names of the products or the

00:02:36,920 --> 00:02:41,160
description on how to get to the event

00:02:39,330 --> 00:02:43,260
and so on that's all something that

00:02:41,160 --> 00:02:47,040
needs to be entered in multiple

00:02:43,260 --> 00:02:48,959
languages and then in the output must be

00:02:47,040 --> 00:02:53,610
shown in the language of the respective

00:02:48,959 --> 00:02:56,640
user so we need forms or some kind of

00:02:53,610 --> 00:03:00,270
input method that allows to store data

00:02:56,640 --> 00:03:02,580
in multiple languages so it's not really

00:03:00,270 --> 00:03:05,250
suitable to use get text for that

00:03:02,580 --> 00:03:07,709
because we would need to like every time

00:03:05,250 --> 00:03:09,690
someone changed something we would need

00:03:07,709 --> 00:03:11,880
to you generate certain files and the

00:03:09,690 --> 00:03:14,040
translators and so on but this just

00:03:11,880 --> 00:03:17,090
doesn't work and so we cannot really use

00:03:14,040 --> 00:03:20,580
their tools provided by Django surely

00:03:17,090 --> 00:03:22,709
there is a third party library that we

00:03:20,580 --> 00:03:25,769
just need to install and that will solve

00:03:22,709 --> 00:03:27,810
this problem for us I've got good news

00:03:25,769 --> 00:03:30,720
and bad news for you the good news is

00:03:27,810 --> 00:03:36,420
very such a library the bad news is I

00:03:30,720 --> 00:03:38,250
counted 23 of them until I stopped say

00:03:36,420 --> 00:03:43,440
who in this room has ever used one of

00:03:38,250 --> 00:03:44,970
these libraries okay that's not that

00:03:43,440 --> 00:03:49,019
much is there someone here who has

00:03:44,970 --> 00:03:50,730
written one of these libraries okay that

00:03:49,019 --> 00:03:54,000
was more people are doing a con Europe

00:03:50,730 --> 00:03:58,799
last year and so disclaimer I'm the

00:03:54,000 --> 00:04:00,810
author of Django I 18 and field I put

00:03:58,799 --> 00:04:02,910
those seven at the top who appear to be

00:04:00,810 --> 00:04:05,010
actively maintained by that I mean they

00:04:02,910 --> 00:04:07,410
are they at least have a development

00:04:05,010 --> 00:04:11,209
branch that is comfortable to Django 2.1

00:04:07,410 --> 00:04:14,940
and they had commits like in the last

00:04:11,209 --> 00:04:18,150
six to 12 months so I will be focusing

00:04:14,940 --> 00:04:20,519
on giving you a short brief overview

00:04:18,150 --> 00:04:23,849
over those top seven libraries because

00:04:20,519 --> 00:04:26,520
the problem is there is not a single

00:04:23,849 --> 00:04:27,370
best library for this use case because

00:04:26,520 --> 00:04:29,669
they're fun

00:04:27,370 --> 00:04:33,520
mentally different in their approach and

00:04:29,669 --> 00:04:36,160
fundamentally differently appropriate

00:04:33,520 --> 00:04:38,110
for the different use cases if I get

00:04:36,160 --> 00:04:39,729
something wrong about of one of these

00:04:38,110 --> 00:04:42,220
levers please feel free to correct me

00:04:39,729 --> 00:04:44,500
later and slack I haven't used most of

00:04:42,220 --> 00:04:47,110
them actually in an actual product but

00:04:44,500 --> 00:04:52,090
I've played around with all of them so

00:04:47,110 --> 00:04:55,120
to compare these we want to look at

00:04:52,090 --> 00:04:57,190
different categories and we want to look

00:04:55,120 --> 00:05:00,370
at how the data is stored in the

00:04:57,190 --> 00:05:02,740
database we want to know how they're

00:05:00,370 --> 00:05:05,380
Python API looks and how easy it is to

00:05:02,740 --> 00:05:06,669
work with them what are the features

00:05:05,380 --> 00:05:09,479
they might provide for example

00:05:06,669 --> 00:05:13,930
integration with Django admin and

00:05:09,479 --> 00:05:15,370
integration with forms and so on and we

00:05:13,930 --> 00:05:18,880
are interested in if they have a

00:05:15,370 --> 00:05:22,419
significant performance impact and how

00:05:18,880 --> 00:05:25,060
large that is so do you have an example

00:05:22,419 --> 00:05:27,490
to work with let's use a model where we

00:05:25,060 --> 00:05:29,770
can store a list of movies and for every

00:05:27,490 --> 00:05:31,840
movie we want to store the title of the

00:05:29,770 --> 00:05:32,910
movie and the year the movie was

00:05:31,840 --> 00:05:36,430
released

00:05:32,910 --> 00:05:38,830
obviously the year is something that is

00:05:36,430 --> 00:05:40,840
not really local dependent although it

00:05:38,830 --> 00:05:42,490
might be but the title is certainly

00:05:40,840 --> 00:05:43,840
something that is different everywhere

00:05:42,490 --> 00:05:47,169
in the world even though it's the same

00:05:43,840 --> 00:05:50,470
movie so let's look at how different

00:05:47,169 --> 00:05:52,660
libraries try to represent that in a

00:05:50,470 --> 00:05:55,270
database and the first approach that

00:05:52,660 --> 00:05:57,669
we've see for example in Django well in

00:05:55,270 --> 00:06:02,020
Django poly is to have a separate table

00:05:57,669 --> 00:06:05,080
that contains the translated strings so

00:06:02,020 --> 00:06:07,479
in our main table movies we have just

00:06:05,080 --> 00:06:10,720
the the untranslated attributes with the

00:06:07,479 --> 00:06:13,229
ID of the movie and the year and then we

00:06:10,720 --> 00:06:16,840
have a second table where every row

00:06:13,229 --> 00:06:21,310
references an object in the main table

00:06:16,840 --> 00:06:23,260
and then says ok for English this is the

00:06:21,310 --> 00:06:26,199
name of the movie and for Italian this

00:06:23,260 --> 00:06:28,570
is the name of the movie so this is in

00:06:26,199 --> 00:06:31,199
terms of relational databases this is a

00:06:28,570 --> 00:06:34,030
very clean approach it kind of fits the

00:06:31,199 --> 00:06:37,630
normal eyes until it hurts that we

00:06:34,030 --> 00:06:39,849
learned yesterday and if we are

00:06:37,630 --> 00:06:41,070
interested to you like build our shop

00:06:39,849 --> 00:06:43,170
front and

00:06:41,070 --> 00:06:45,300
and we won't you have Ally or our movie

00:06:43,170 --> 00:06:47,910
list and we want to have lists and we

00:06:45,300 --> 00:06:49,950
want to have the Italian movie Italian

00:06:47,910 --> 00:06:51,840
title for every movie then this is also

00:06:49,950 --> 00:06:53,660
very efficient because modern database

00:06:51,840 --> 00:06:56,490
is a very good at performing joins

00:06:53,660 --> 00:06:57,630
however for example in the back end

00:06:56,490 --> 00:06:59,220
where we want to have lists of the

00:06:57,630 --> 00:07:01,110
movies where we want to show every

00:06:59,220 --> 00:07:03,390
language per movie this gets really

00:07:01,110 --> 00:07:05,190
expensive because we need to do either a

00:07:03,390 --> 00:07:09,660
lot of queries or we need to work with

00:07:05,190 --> 00:07:11,460
the query data a lot a separate approach

00:07:09,660 --> 00:07:13,920
seen in django model translation or

00:07:11,460 --> 00:07:16,920
django translated fields is to just have

00:07:13,920 --> 00:07:19,620
separate columns per language this way

00:07:16,920 --> 00:07:21,210
you don't need any joints and it's very

00:07:19,620 --> 00:07:23,940
cheap to get all languages at the same

00:07:21,210 --> 00:07:25,470
time however every time you add a new

00:07:23,940 --> 00:07:29,270
language you need to do a database

00:07:25,470 --> 00:07:32,160
migration which can be very annoying and

00:07:29,270 --> 00:07:34,230
the third style that we see used in

00:07:32,160 --> 00:07:38,070
django i18n filled django nietzsche and

00:07:34,230 --> 00:07:42,150
Django model trance is to to use a Jason

00:07:38,070 --> 00:07:45,960
like field this is less clean in terms

00:07:42,150 --> 00:07:48,270
of database normalization but we don't

00:07:45,960 --> 00:07:50,400
do it need to do any joins we don't need

00:07:48,270 --> 00:07:54,630
to do any changes to her schema when we

00:07:50,400 --> 00:07:56,340
add languages and and it's all contained

00:07:54,630 --> 00:07:58,680
and one field as we had it before

00:07:56,340 --> 00:08:01,950
if we were in Postgres and if we use

00:07:58,680 --> 00:08:04,650
jason and Postgres native JSON data type

00:08:01,950 --> 00:08:07,110
we can still retain the functionality of

00:08:04,650 --> 00:08:09,300
filtering by them or searching the name

00:08:07,110 --> 00:08:12,600
in a specific language or sorting by

00:08:09,300 --> 00:08:15,540
name if we're not in Postgres we kind of

00:08:12,600 --> 00:08:18,030
lose the functionality to you to index

00:08:15,540 --> 00:08:20,220
or query that data that might be a

00:08:18,030 --> 00:08:24,480
problem or might be totally fine for

00:08:20,220 --> 00:08:28,470
your use case and django model Trends is

00:08:24,480 --> 00:08:32,430
a bit different than the other two it it

00:08:28,470 --> 00:08:35,099
uses not one J's and column per per

00:08:32,430 --> 00:08:36,540
translated column but only one jason

00:08:35,099 --> 00:08:38,969
column for the whole table no matter how

00:08:36,540 --> 00:08:41,700
many fields you translate but apart from

00:08:38,969 --> 00:08:43,500
that those are similar dissimilar

00:08:41,700 --> 00:08:47,550
Nietzsche and model trans only work in

00:08:43,500 --> 00:08:50,610
Postgres i18n field drops the the

00:08:47,550 --> 00:08:54,240
indexing and filtering possibilities and

00:08:50,610 --> 00:08:54,540
there but version all databases i've are

00:08:54,240 --> 00:08:57,810
we

00:08:54,540 --> 00:09:01,170
working at the sprints on something that

00:08:57,810 --> 00:09:03,180
uses the Postgres datatype when you are

00:09:01,170 --> 00:09:04,769
on prosperous and gracefully falls back

00:09:03,180 --> 00:09:09,930
to your text field on all other

00:09:04,769 --> 00:09:13,250
databases next we want to look at how

00:09:09,930 --> 00:09:15,300
you define your models and there again a

00:09:13,250 --> 00:09:17,339
couple of different styles for example

00:09:15,300 --> 00:09:19,920
in Django well django poly and Django

00:09:17,339 --> 00:09:21,810
Nietzsche and you have a custom base

00:09:19,920 --> 00:09:24,569
class that you inherit your models form

00:09:21,810 --> 00:09:26,579
from and they will change your query

00:09:24,569 --> 00:09:29,060
manager and change a lot of things and

00:09:26,579 --> 00:09:32,339
how your model work to you like as

00:09:29,060 --> 00:09:35,459
automatically as possible build those

00:09:32,339 --> 00:09:38,880
joints for you or translate your queries

00:09:35,459 --> 00:09:43,139
for you sometimes you need to wrap your

00:09:38,880 --> 00:09:45,300
fields tee in in some wrapper object you

00:09:43,139 --> 00:09:48,720
to tell the library which once you

00:09:45,300 --> 00:09:50,880
translate sometimes you have an

00:09:48,720 --> 00:09:55,699
additional meta option but in the end

00:09:50,880 --> 00:09:58,470
it's the same thing the other style is

00:09:55,699 --> 00:10:00,569
that you have a custom field type and do

00:09:58,470 --> 00:10:04,319
not change the way the model in itself

00:10:00,569 --> 00:10:06,510
works at all for example in Django i18n

00:10:04,319 --> 00:10:10,230
field or Django translated fields you

00:10:06,510 --> 00:10:12,899
just have a custom type that is a

00:10:10,230 --> 00:10:16,290
translated character field or translated

00:10:12,899 --> 00:10:18,209
text field whereas in general model

00:10:16,290 --> 00:10:21,810
Trends you like have per model you have

00:10:18,209 --> 00:10:22,980
one field that is called I 18 n or

00:10:21,810 --> 00:10:25,019
whatever you want to call it and that

00:10:22,980 --> 00:10:30,029
stores the translation for all other

00:10:25,019 --> 00:10:33,199
fields the third style is to decouple it

00:10:30,029 --> 00:10:35,790
from the model definition process

00:10:33,199 --> 00:10:39,389
completely and have like a separate

00:10:35,790 --> 00:10:44,220
registry where you register those

00:10:39,389 --> 00:10:47,550
options this is like the the most I

00:10:44,220 --> 00:10:49,980
would call it the most unclean style of

00:10:47,550 --> 00:10:52,050
doing it because he it's kind of not

00:10:49,980 --> 00:10:55,560
obvious where your code lives on the

00:10:52,050 --> 00:10:58,170
other hand this allows you to to enable

00:10:55,560 --> 00:11:00,569
translations for models that are not in

00:10:58,170 --> 00:11:06,029
the code that you control which might be

00:11:00,569 --> 00:11:08,670
something you need okay such

00:11:06,029 --> 00:11:11,520
registration patterns

00:11:08,670 --> 00:11:14,790
and the third thing I want to look at a

00:11:11,520 --> 00:11:19,200
detail is how to interact with your

00:11:14,790 --> 00:11:21,690
model objects in some of the libraries

00:11:19,200 --> 00:11:24,600
you can only interact with one language

00:11:21,690 --> 00:11:27,990
at a time this is mostly because of this

00:11:24,600 --> 00:11:31,440
this joins that they're performing if

00:11:27,990 --> 00:11:33,090
you pull the object from the database it

00:11:31,440 --> 00:11:35,730
will pull the information for one

00:11:33,090 --> 00:11:38,640
language like you need to specify that

00:11:35,730 --> 00:11:39,930
within your query and then the title

00:11:38,640 --> 00:11:42,690
attribute of the object will be

00:11:39,930 --> 00:11:45,090
populated with the Italian title and

00:11:42,690 --> 00:11:47,550
then if you want to access the English

00:11:45,090 --> 00:11:49,590
title you need to change the language

00:11:47,550 --> 00:11:52,020
and will it will perform a new query or

00:11:49,590 --> 00:11:54,060
depending on the implementation or in

00:11:52,020 --> 00:11:57,120
case of Nietzsche it will not but it

00:11:54,060 --> 00:12:02,310
will change like the the the state and

00:11:57,120 --> 00:12:05,910
title will now contain an English the

00:12:02,310 --> 00:12:08,550
English title the other option is to be

00:12:05,910 --> 00:12:12,780
able to access all properties at once

00:12:08,550 --> 00:12:15,000
this comes naturally to the to the

00:12:12,780 --> 00:12:19,140
libraries where you have separate

00:12:15,000 --> 00:12:23,280
columns per language because you and you

00:12:19,140 --> 00:12:27,330
have your your main attribute title that

00:12:23,280 --> 00:12:30,630
usually evaluates lazily to the value of

00:12:27,330 --> 00:12:33,210
the currently active locale and you can

00:12:30,630 --> 00:12:35,580
directly access every other language by

00:12:33,210 --> 00:12:37,920
just using title underscore and the

00:12:35,580 --> 00:12:40,170
language code because that's just either

00:12:37,920 --> 00:12:42,030
because that's just the field that the

00:12:40,170 --> 00:12:45,060
library creates or because it virtually

00:12:42,030 --> 00:12:48,120
creates it for you in Django I 18 and

00:12:45,060 --> 00:12:51,270
field it's a bit different the the title

00:12:48,120 --> 00:12:54,630
attribute will always contain a special

00:12:51,270 --> 00:12:57,720
datatype lazy internationalized string

00:12:54,630 --> 00:12:59,580
which is some some in some ways like

00:12:57,720 --> 00:13:03,150
what you get in return from you get X

00:12:59,580 --> 00:13:05,400
underscore lazy it will whenever you

00:13:03,150 --> 00:13:10,020
cast it to is string it will curse to

00:13:05,400 --> 00:13:11,700
the currently active locale but it is a

00:13:10,020 --> 00:13:14,940
special data object that contains the

00:13:11,700 --> 00:13:18,920
information on all language so you can

00:13:14,940 --> 00:13:18,920
pass that around as one object

00:13:19,380 --> 00:13:29,920
so to recap and to add the other

00:13:24,760 --> 00:13:36,070
features we have a couple of different

00:13:29,920 --> 00:13:38,740
database layouts that that are in use we

00:13:36,070 --> 00:13:42,370
have the diversion where we have

00:13:38,740 --> 00:13:44,560
everything in its own table like we have

00:13:42,370 --> 00:13:46,000
multiple tables to store our model we

00:13:44,560 --> 00:13:49,029
have the version where we have a very

00:13:46,000 --> 00:13:50,770
wide table with multiple columns for

00:13:49,029 --> 00:13:53,760
every language that we have and we have

00:13:50,770 --> 00:13:59,950
the like embedded version within one

00:13:53,760 --> 00:14:01,930
column we have database support for most

00:13:59,950 --> 00:14:03,640
of the libraries for all databases that

00:14:01,930 --> 00:14:04,990
django supports but in the case of

00:14:03,640 --> 00:14:10,510
Django Nietzsche and wrangle model

00:14:04,990 --> 00:14:13,420
trains they only run on PostgreSQL we

00:14:10,510 --> 00:14:17,170
can we have different levels of support

00:14:13,420 --> 00:14:20,350
for for filtering the the objects for

00:14:17,170 --> 00:14:23,200
example in those that use normalize

00:14:20,350 --> 00:14:26,140
database load is really easy although it

00:14:23,200 --> 00:14:30,190
might be computationally expensive where

00:14:26,140 --> 00:14:32,709
is in those that is the the PostgreSQL

00:14:30,190 --> 00:14:34,810
Jason field it should be easy they don't

00:14:32,709 --> 00:14:36,579
provide any utilities for you to make it

00:14:34,810 --> 00:14:38,320
even easier like querying in the

00:14:36,579 --> 00:14:40,390
currently default language you need to

00:14:38,320 --> 00:14:43,959
do that under your own but it it's

00:14:40,390 --> 00:14:45,640
conceptually possible where is in I 18

00:14:43,959 --> 00:14:48,279
in field it's currently not really

00:14:45,640 --> 00:14:51,750
possible like searching somehow works

00:14:48,279 --> 00:14:54,250
but ordering or indexing is not possible

00:14:51,750 --> 00:14:57,399
we have the separate styles of defining

00:14:54,250 --> 00:15:00,040
the model either by defining a baek's

00:14:57,399 --> 00:15:03,190
class or by registration or by a custom

00:15:00,040 --> 00:15:05,020
field type and we have the separate

00:15:03,190 --> 00:15:08,110
styles of object operation where we can

00:15:05,020 --> 00:15:12,040
either access one language at a time or

00:15:08,110 --> 00:15:14,829
all of the language at once I didn't

00:15:12,040 --> 00:15:19,390
talk in detail about firm support some

00:15:14,829 --> 00:15:22,270
of them provide for most of them forum

00:15:19,390 --> 00:15:25,600
support comes naturally by just like

00:15:22,270 --> 00:15:30,190
when they generate the your your model

00:15:25,600 --> 00:15:32,390
fields that have a separate column per

00:15:30,190 --> 00:15:35,570
language

00:15:32,390 --> 00:15:37,340
then it will just when you use a model

00:15:35,570 --> 00:15:41,030
form it was will just automatically get

00:15:37,340 --> 00:15:43,190
generate that number of fields so in

00:15:41,030 --> 00:15:45,050
some of them you will get in a model

00:15:43,190 --> 00:15:46,760
form you will get a field that just

00:15:45,050 --> 00:15:49,760
allows you to edit the currently active

00:15:46,760 --> 00:15:53,450
language which I don't think is useful

00:15:49,760 --> 00:15:56,300
in very many use cases in some you will

00:15:53,450 --> 00:16:00,380
like get different form fields for each

00:15:56,300 --> 00:16:02,000
one form field per language nature

00:16:00,380 --> 00:16:03,470
doesn't have form support at all it just

00:16:02,000 --> 00:16:07,130
gives you a text widget where you can

00:16:03,470 --> 00:16:08,900
edit the adjacent blob and in i18n field

00:16:07,130 --> 00:16:11,930
you will get a special form field type

00:16:08,900 --> 00:16:14,210
with a special widget that inverse like

00:16:11,930 --> 00:16:16,850
the compound daytime widget just has

00:16:14,210 --> 00:16:21,020
compound input fields within one widget

00:16:16,850 --> 00:16:23,420
to ask for the different languages some

00:16:21,020 --> 00:16:26,950
of them have very elaborate support for

00:16:23,420 --> 00:16:29,960
the Django admin and do that very nicely

00:16:26,950 --> 00:16:35,230
others just present you with the JSON

00:16:29,960 --> 00:16:35,230
blob or just different fields below I

00:16:35,260 --> 00:16:40,820
did a small benchmark to have a look at

00:16:39,080 --> 00:16:42,710
their performance the benchmark is of

00:16:40,820 --> 00:16:46,790
course not representative for real-life

00:16:42,710 --> 00:16:48,860
application it just stores a lot of

00:16:46,790 --> 00:16:50,540
objects into the database pulls them out

00:16:48,860 --> 00:16:53,840
again and tries to access the attributes

00:16:50,540 --> 00:16:56,840
in various languages that obviously is

00:16:53,840 --> 00:16:59,480
rather slow on those that need to do

00:16:56,840 --> 00:17:03,290
joins and need to refresh although at

00:16:59,480 --> 00:17:06,820
least Django poly can make use of

00:17:03,290 --> 00:17:09,880
caching to reduce this while the others

00:17:06,820 --> 00:17:14,089
quite unsurprisingly the PostgreSQL

00:17:09,880 --> 00:17:16,430
Jason field Beck implementations are

00:17:14,089 --> 00:17:21,079
very very fast and the others also

00:17:16,430 --> 00:17:24,170
reasonably fast I've created a demo app

00:17:21,079 --> 00:17:26,030
that uses all of the seven libraries and

00:17:24,170 --> 00:17:28,339
also contains the bank benchmark O's

00:17:26,030 --> 00:17:32,030
code in case you're interested in that

00:17:28,339 --> 00:17:34,700
and with that I'm a bit faster than I

00:17:32,030 --> 00:17:37,010
expected at the end of my talk and I

00:17:34,700 --> 00:17:39,700
would be happy if you have any questions

00:17:37,010 --> 00:17:39,700
on that subject

00:17:41,890 --> 00:17:47,090
and that was a great talk thank you

00:17:45,260 --> 00:17:48,500
just one question where did you get the

00:17:47,090 --> 00:17:52,910
inspiration to do the emoji future

00:17:48,500 --> 00:17:55,070
comparison Hey I don't remember I've

00:17:52,910 --> 00:17:58,429
seen a lot of emojis at the Django

00:17:55,070 --> 00:18:03,500
conferences I've attended so it's maybe

00:17:58,429 --> 00:18:05,900
Katie's fault but yeah hi great thanks

00:18:03,500 --> 00:18:09,470
for the presentation right-to-left

00:18:05,900 --> 00:18:14,420
support how easy is that to implement

00:18:09,470 --> 00:18:17,870
and how do the libraries need in context

00:18:14,420 --> 00:18:22,070
of storing the data I haven't tried I

00:18:17,870 --> 00:18:24,530
don't see any problems ahead there

00:18:22,070 --> 00:18:27,380
because in the end those libraries are

00:18:24,530 --> 00:18:29,450
just about how to store these unicode

00:18:27,380 --> 00:18:30,730
strings that uses input and layout that

00:18:29,450 --> 00:18:33,590
we output at a later stage

00:18:30,730 --> 00:18:36,470
so I think on this on the on the model

00:18:33,590 --> 00:18:37,940
level it's not that important might get

00:18:36,470 --> 00:18:39,470
more interesting if you have like if

00:18:37,940 --> 00:18:41,210
you're rendering a form and you need to

00:18:39,470 --> 00:18:43,100
render some of the widgets with

00:18:41,210 --> 00:18:44,750
left-to-right CSS and others with

00:18:43,100 --> 00:18:46,730
right-to-left see this that might get

00:18:44,750 --> 00:18:50,120
interesting but on the database level I

00:18:46,730 --> 00:18:51,620
don't think it should be a problem let's

00:18:50,120 --> 00:18:58,449
give a big round to Raphael

00:18:51,620 --> 00:18:58,449

YouTube URL: https://www.youtube.com/watch?v=4WEMXydnQs8


