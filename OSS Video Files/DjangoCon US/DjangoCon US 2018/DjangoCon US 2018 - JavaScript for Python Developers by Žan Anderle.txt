Title: DjangoCon US 2018 - JavaScript for Python Developers by Å½an Anderle
Publication date: 2018-11-08
Playlist: DjangoCon US 2018
Description: 
	DjangoCon US 2018 - JavaScript for Python Developers by Å½an Anderle

Having a hard time keeping track of where the modern JavaScript is going? Are you familiar only with jQuery and you want to know more? Or maybe youâ€™re not familiar with JavaScript at all and want to learn it but you donâ€™t know where to start? Then this talk is for you!

Youâ€™ll learn about modern JavaScript from a perspective of a Python developer. By the end of the talk youâ€™ll know everything you need to know about the language, its ecosystem, and different tools and frameworks. Youâ€™ll be able to start using JavaScript more confidently and be familiar with different tools that are at your disposal.

Weâ€™ll go over all the things I wish Iâ€™d known when I first got started with JavaScript.:

Basics of the language (types, operators, data structures, functions, modules, etc. as seen in ES6) and how they are similar to or different from Python.
Overview of the commonly used development and build tools.
Overview of the popular frontend frameworks.
A look into the newest features of ES6 and Typescript.
How to get started and make sense of everything with so much going on.

This talk was presented at: https://2018.djangocon.us/talk/javascript-for-python-developers/

LINKS:
Follow Å½an Anderle ðŸ‘‡
On Twitter: https://twitter.com/z_anderle
Official homepage: https://zanderle.com

Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:22,140
I hope you all had a good lunch my name

00:00:19,170 --> 00:00:24,750
is John that's me I'm here I'm hiking

00:00:22,140 --> 00:00:26,279
with my family near my hometown I'm

00:00:24,750 --> 00:00:28,859
coming here all the way from Slovenia

00:00:26,279 --> 00:00:33,630
and no that's not Pennsylvania that's

00:00:28,859 --> 00:00:35,489
Slovenia I get that a lot

00:00:33,630 --> 00:00:37,890
I'm a consultant and a full stack web

00:00:35,489 --> 00:00:39,180
engineer and if you need some help to

00:00:37,890 --> 00:00:41,700
make sense of your front-end and

00:00:39,180 --> 00:00:43,920
back-end needs or if you need someone to

00:00:41,700 --> 00:00:48,059
mentor your junior folks please come say

00:00:43,920 --> 00:00:51,030
hi okay let's start by taking a short

00:00:48,059 --> 00:00:53,270
trip to arendelle yes I mean the kingdom

00:00:51,030 --> 00:00:55,500
from the animated movie frozen

00:00:53,270 --> 00:00:59,699
specifically let's talk about the queen

00:00:55,500 --> 00:01:01,730
of arendelle Elsa now if you've seen the

00:00:59,699 --> 00:01:04,170
movie you'll know how the story goes

00:01:01,730 --> 00:01:06,960
Elsa is born with some magical powers

00:01:04,170 --> 00:01:08,090
which as a kid she uses to play around

00:01:06,960 --> 00:01:11,159
and do cool stuff

00:01:08,090 --> 00:01:14,340
soon she realizes that she's way more

00:01:11,159 --> 00:01:15,900
powerful than she imagined one time she

00:01:14,340 --> 00:01:19,110
even accidentally injures her younger

00:01:15,900 --> 00:01:21,090
sister her parents warned her that she

00:01:19,110 --> 00:01:22,860
needs to do a that she needs to learn

00:01:21,090 --> 00:01:25,790
how to control her powers otherwise

00:01:22,860 --> 00:01:28,950
she'll be a threat to herself and others

00:01:25,790 --> 00:01:31,799
they try to do the best job they can to

00:01:28,950 --> 00:01:33,600
help her with that but unfortunately

00:01:31,799 --> 00:01:35,729
they pass away in a horrible accident

00:01:33,600 --> 00:01:37,500
so now teenage Elsa is left to figure

00:01:35,729 --> 00:01:39,200
out how to control her amazing powers

00:01:37,500 --> 00:01:42,479
all on her own

00:01:39,200 --> 00:01:44,220
fast forward a few years her powers get

00:01:42,479 --> 00:01:46,549
out of control and she puts the whole

00:01:44,220 --> 00:01:49,200
kingdom in a state of eternal winter

00:01:46,549 --> 00:01:51,810
again fast-forward a bunch of challenges

00:01:49,200 --> 00:01:54,149
she has to face and a few plot twists

00:01:51,810 --> 00:01:56,880
and she finally learns how to control

00:01:54,149 --> 00:01:59,280
her powers it's not worth hiding and

00:01:56,880 --> 00:02:02,759
controlling it's what acceptance and

00:01:59,280 --> 00:02:04,680
love and then later her uncle bang came

00:02:02,759 --> 00:02:07,549
to her and told her that with great

00:02:04,680 --> 00:02:07,549
power comes great responsibility

00:02:08,450 --> 00:02:16,079
sorry wrong movie okay so why on earth

00:02:14,310 --> 00:02:17,129
are we talking about Elsa in this

00:02:16,079 --> 00:02:20,340
JavaScript talk

00:02:17,129 --> 00:02:24,209
well we my fellow Jenga notes are a lot

00:02:20,340 --> 00:02:27,420
like Elsa and JavaScript is a lot like

00:02:24,209 --> 00:02:28,920
the powers that she has here are some

00:02:27,420 --> 00:02:32,730
amazing and incredible things that we

00:02:28,920 --> 00:02:34,079
can do with JavaScript but it there are

00:02:32,730 --> 00:02:36,450
some amazing and incredible things that

00:02:34,079 --> 00:02:38,760
we can do with JavaScript but if we're

00:02:36,450 --> 00:02:41,939
not careful about which tooling we use

00:02:38,760 --> 00:02:44,250
how we include it how use how we use it

00:02:41,939 --> 00:02:47,280
within our Django project it can easily

00:02:44,250 --> 00:02:51,030
blow up so let's go over that stuff real

00:02:47,280 --> 00:02:54,949
quick JavaScript ecosystem is kind of

00:02:51,030 --> 00:02:58,500
astonishing in both good and bad sense

00:02:54,949 --> 00:03:02,159
there's a great talk by offer Finnish

00:02:58,500 --> 00:03:05,909
vishna called wait you can do that with

00:03:02,159 --> 00:03:07,189
JavaScript it showcases some awesome

00:03:05,909 --> 00:03:10,919
things that you can do with JavaScript

00:03:07,189 --> 00:03:12,750
you know the like you can do front-end

00:03:10,919 --> 00:03:14,669
back-end we all know that but he also

00:03:12,750 --> 00:03:19,530
talks about how you can do mobile

00:03:14,669 --> 00:03:21,239
development stuff like VR and AR and let

00:03:19,530 --> 00:03:22,979
me just show you my favorite example of

00:03:21,239 --> 00:03:26,040
what you can do in JavaScript hopefully

00:03:22,979 --> 00:03:29,310
this will work now all of this is

00:03:26,040 --> 00:03:34,319
implemented in in JavaScript and it uses

00:03:29,310 --> 00:03:37,229
a neural network to in order to predict

00:03:34,319 --> 00:03:39,090
or like or to continue the melody that

00:03:37,229 --> 00:03:41,900
you just played so if we play something

00:03:39,090 --> 00:03:41,900
like

00:03:44,580 --> 00:04:04,860
I think that's so cool okay but of

00:04:02,730 --> 00:04:07,080
course all of this comes with at a great

00:04:04,860 --> 00:04:10,020
cost it can be really hard to navigate

00:04:07,080 --> 00:04:12,240
so many packages it's hard to decide

00:04:10,020 --> 00:04:14,520
what to use when to use and it can also

00:04:12,240 --> 00:04:16,170
feel like why are there so many tools

00:04:14,520 --> 00:04:17,640
that I have to learn before I have to

00:04:16,170 --> 00:04:22,049
work before I can write a single line of

00:04:17,640 --> 00:04:24,060
code now a lot of that is hype and a lot

00:04:22,049 --> 00:04:25,320
of the problems also come from feeling

00:04:24,060 --> 00:04:29,460
that you have to use and learn

00:04:25,320 --> 00:04:31,140
everything at once you don't if you know

00:04:29,460 --> 00:04:32,970
about these few ones that I'll mention

00:04:31,140 --> 00:04:35,130
you'll have all the basics covered

00:04:32,970 --> 00:04:37,220
really and you don't need to use them

00:04:35,130 --> 00:04:40,230
all at once use them when you need them

00:04:37,220 --> 00:04:43,410
so first of all let's look at the

00:04:40,230 --> 00:04:46,500
package management in python we have pip

00:04:43,410 --> 00:04:49,320
and more recently pip ends in JavaScript

00:04:46,500 --> 00:04:52,380
there is NPM node package manager and

00:04:49,320 --> 00:04:54,300
the competing yarn they're very similar

00:04:52,380 --> 00:04:56,700
from the users perspective but are

00:04:54,300 --> 00:04:59,430
different under the hood the way you use

00:04:56,700 --> 00:05:00,810
them is quite similar to Pip and there

00:04:59,430 --> 00:05:02,910
is no need for a virtual environment

00:05:00,810 --> 00:05:07,560
because everything is installed in the

00:05:02,910 --> 00:05:10,320
local node modules folder so you can use

00:05:07,560 --> 00:05:13,350
NPM or yarn for installing any

00:05:10,320 --> 00:05:14,760
development tools or any packages that

00:05:13,350 --> 00:05:18,240
you are using within your JavaScript

00:05:14,760 --> 00:05:20,760
project then we have this thing called

00:05:18,240 --> 00:05:23,010
Babel this is useful when you want to

00:05:20,760 --> 00:05:25,470
write your code in the latest version of

00:05:23,010 --> 00:05:28,140
JavaScript but also want to support the

00:05:25,470 --> 00:05:30,780
older browsers so it's kind of like if

00:05:28,140 --> 00:05:33,210
you if you wrote all your code in Python

00:05:30,780 --> 00:05:35,520
3 and there was a tool that trans filed

00:05:33,210 --> 00:05:36,810
that into Python 2 so that it could be

00:05:35,520 --> 00:05:39,780
used on machines that don't support

00:05:36,810 --> 00:05:42,450
Python 3 now I know it's not a perfect

00:05:39,780 --> 00:05:44,220
analogy but that's the gist of it the

00:05:42,450 --> 00:05:45,990
that stuff's really important when it

00:05:44,220 --> 00:05:48,030
comes to JavaScript because you have

00:05:45,990 --> 00:05:50,610
countless different combinations of

00:05:48,030 --> 00:05:55,220
browsers and computers that your code

00:05:50,610 --> 00:05:55,220
has to work on and Internet Explorer

00:05:55,600 --> 00:06:00,140
given the demands for the applications

00:05:58,160 --> 00:06:03,100
on the web there are usually a couple of

00:06:00,140 --> 00:06:06,080
things to be done if we want it to be

00:06:03,100 --> 00:06:09,560
production ready so that it's fast small

00:06:06,080 --> 00:06:11,960
in size and supported in all browsers we

00:06:09,560 --> 00:06:15,410
might want to minify and uglify the code

00:06:11,960 --> 00:06:18,050
to to get the smaller sizes if we're

00:06:15,410 --> 00:06:20,870
using something like a CSS extension

00:06:18,050 --> 00:06:23,900
language like SAS we need to compile

00:06:20,870 --> 00:06:26,690
those files into CSS and many other

00:06:23,900 --> 00:06:28,130
things to add to the complexity they're

00:06:26,690 --> 00:06:30,590
usually different set of requirements

00:06:28,130 --> 00:06:33,740
for local development and production

00:06:30,590 --> 00:06:35,660
ready applications all of this makes it

00:06:33,740 --> 00:06:39,950
very useful and important to be able to

00:06:35,660 --> 00:06:42,080
automate the build process the tools

00:06:39,950 --> 00:06:46,030
usually used for this are either

00:06:42,080 --> 00:06:49,850
grunt or gulp and if we're using modules

00:06:46,030 --> 00:06:52,540
like we also want to bundle our code

00:06:49,850 --> 00:06:55,280
into a single file from separate files

00:06:52,540 --> 00:06:57,770
we can use webpack which is very

00:06:55,280 --> 00:07:01,610
powerful and sometimes difficult to

00:06:57,770 --> 00:07:05,510
understand then there are a ton of

00:07:01,610 --> 00:07:07,820
different testing tools just going

00:07:05,510 --> 00:07:11,900
through that would be a talk in itself

00:07:07,820 --> 00:07:14,570
so I'm not gonna do that at all then we

00:07:11,900 --> 00:07:16,850
come to arguably one of the reasons for

00:07:14,570 --> 00:07:18,860
popularity popularity of the modern

00:07:16,850 --> 00:07:21,440
JavaScript different front-end

00:07:18,860 --> 00:07:23,600
frameworks similarly as with testing

00:07:21,440 --> 00:07:26,480
tools going through them would take a

00:07:23,600 --> 00:07:28,220
whole new talk so let's just look at

00:07:26,480 --> 00:07:30,920
four of these and like what's the

00:07:28,220 --> 00:07:32,390
general idea behind them so as the web

00:07:30,920 --> 00:07:35,450
applications are becoming more and more

00:07:32,390 --> 00:07:38,000
dynamic and interactive we have to

00:07:35,450 --> 00:07:40,760
provide a rope in order to provide a

00:07:38,000 --> 00:07:43,700
richer experience we're getting more and

00:07:40,760 --> 00:07:47,360
more JavaScript code and underlying HTML

00:07:43,700 --> 00:07:50,300
is simply not enough so in order to make

00:07:47,360 --> 00:07:52,250
some sense out of that chaos we can use

00:07:50,300 --> 00:07:54,290
the front-end frameworks all of these

00:07:52,250 --> 00:07:57,620
frameworks make it really easy to bind

00:07:54,290 --> 00:07:59,150
some variables to the HTML they make it

00:07:57,620 --> 00:08:01,760
really easy for you to define your own

00:07:59,150 --> 00:08:05,090
components that HTML doesn't have by

00:08:01,760 --> 00:08:06,740
default some custom components and then

00:08:05,090 --> 00:08:08,550
you can use that and make it let make

00:08:06,740 --> 00:08:13,320
them nice reusable

00:08:08,550 --> 00:08:16,680
code angular and amber are both

00:08:13,320 --> 00:08:18,840
full-featured MVC frameworks complete

00:08:16,680 --> 00:08:20,400
with routers and everything this means

00:08:18,840 --> 00:08:23,550
you can use them to create single page

00:08:20,400 --> 00:08:26,820
applications react and view are more

00:08:23,550 --> 00:08:27,870
like the V part of the MVC they can

00:08:26,820 --> 00:08:30,030
still be used as full for a

00:08:27,870 --> 00:08:32,130
full-featured framework as well but the

00:08:30,030 --> 00:08:32,910
nice things about those two is that you

00:08:32,130 --> 00:08:34,320
can use it

00:08:32,910 --> 00:08:35,880
you can use them in your existing

00:08:34,320 --> 00:08:40,500
applications without like changing

00:08:35,880 --> 00:08:42,510
everything about it so when it comes to

00:08:40,500 --> 00:08:44,750
JavaScript and Django there are a few

00:08:42,510 --> 00:08:47,880
different ways that they can be combined

00:08:44,750 --> 00:08:50,700
possibly one of the best way especially

00:08:47,880 --> 00:08:53,730
for larger projects with lots of and

00:08:50,700 --> 00:08:57,120
lots of interactivity is to have the

00:08:53,730 --> 00:08:58,590
whole front end as a separate project so

00:08:57,120 --> 00:09:00,870
in this case you could use one of the

00:08:58,590 --> 00:09:04,260
frameworks I mentioned and use Django

00:09:00,870 --> 00:09:05,760
just for the supporting API I have a lot

00:09:04,260 --> 00:09:08,840
of good experiences with this model as

00:09:05,760 --> 00:09:11,730
do other people another way is to have

00:09:08,840 --> 00:09:15,060
JavaScript within within your project

00:09:11,730 --> 00:09:16,800
with that if if you wanted to do some

00:09:15,060 --> 00:09:19,020
additional processing of your JavaScript

00:09:16,800 --> 00:09:21,600
code like bundling ugly fiying or

00:09:19,020 --> 00:09:23,640
whatever you can either make use of all

00:09:21,600 --> 00:09:26,280
the JavaScript tooling that I talked

00:09:23,640 --> 00:09:29,400
about or you can use Django loaders

00:09:26,280 --> 00:09:32,160
pipelines and such that will hide the

00:09:29,400 --> 00:09:36,720
jas tooling from you personally I prefer

00:09:32,160 --> 00:09:38,760
the former and then finally if you just

00:09:36,720 --> 00:09:41,280
want some minimal JavaScript in your

00:09:38,760 --> 00:09:42,870
project without any additional stuff the

00:09:41,280 --> 00:09:45,540
very least you should do is put your

00:09:42,870 --> 00:09:49,980
JavaScript in separate files it doesn't

00:09:45,540 --> 00:09:51,360
belong in your templates cool you're now

00:09:49,980 --> 00:09:54,140
on a great way to start controlling your

00:09:51,360 --> 00:09:57,420
powers congratulations

00:09:54,140 --> 00:09:59,670
okay so let's talk for a second about

00:09:57,420 --> 00:10:02,070
the story of Beauty and the Beast now

00:09:59,670 --> 00:10:05,010
we've all heard a story there is the

00:10:02,070 --> 00:10:08,070
scary beast leaving living in a remote

00:10:05,010 --> 00:10:11,340
castle and Belle somehow ends up trapped

00:10:08,070 --> 00:10:13,860
there and the Beast won't let her go as

00:10:11,340 --> 00:10:15,450
time goes by Belle learns more and more

00:10:13,860 --> 00:10:19,070
about the creature and gets to know it

00:10:15,450 --> 00:10:21,240
she realizes to be staying that bad

00:10:19,070 --> 00:10:22,019
after a while she even falls in love

00:10:21,240 --> 00:10:23,730
with him

00:10:22,019 --> 00:10:25,350
and then when they kiss for the first

00:10:23,730 --> 00:10:27,420
time we find out that the beast was a

00:10:25,350 --> 00:10:31,290
handsome prince all along spoiler alert

00:10:27,420 --> 00:10:34,739
but was turned into a beast by some

00:10:31,290 --> 00:10:36,360
awful curse again why are we talking

00:10:34,739 --> 00:10:39,239
about some fairy tale at a JavaScript

00:10:36,360 --> 00:10:42,589
dock well it turns out javascript is a

00:10:39,239 --> 00:10:45,179
lot like the beast it seems scary

00:10:42,589 --> 00:10:47,610
irrational but if you just get to know

00:10:45,179 --> 00:10:50,160
it you realize there's actually

00:10:47,610 --> 00:10:51,629
something great inside a powerful

00:10:50,160 --> 00:10:54,389
expressive language it's hidden

00:10:51,629 --> 00:10:57,600
somewhere in there now it's JavaScript

00:10:54,389 --> 00:10:58,019
the beast without its flaws absolutely

00:10:57,600 --> 00:11:00,809
not

00:10:58,019 --> 00:11:02,999
is it justifiable that a kidnapper

00:11:00,809 --> 00:11:06,540
kidnaps us and takes us hostage of

00:11:02,999 --> 00:11:09,480
course not but then again the fault is

00:11:06,540 --> 00:11:11,910
not entirely its own Douglas Crockford

00:11:09,480 --> 00:11:17,509
the guy who wrote the book JavaScript

00:11:11,910 --> 00:11:19,589
the good parts once said once said

00:11:17,509 --> 00:11:21,119
javascript is the only programming

00:11:19,589 --> 00:11:23,549
language that people don't bother to

00:11:21,119 --> 00:11:27,990
learn before using and I find that very

00:11:23,549 --> 00:11:30,959
true think about it have you heard of

00:11:27,990 --> 00:11:32,670
Zen of Python before have you heard of

00:11:30,959 --> 00:11:35,369
this thing called the pythonic way of

00:11:32,670 --> 00:11:37,019
doing things of course you have because

00:11:35,369 --> 00:11:39,059
we put effort into actually learning the

00:11:37,019 --> 00:11:42,439
language before using it but with

00:11:39,059 --> 00:11:46,230
JavaScript is very often very different

00:11:42,439 --> 00:11:48,240
it's it gives you a sense of oh it's

00:11:46,230 --> 00:11:52,769
such an easy language just because it's

00:11:48,240 --> 00:11:55,410
it tries to be lenient and yeah that

00:11:52,769 --> 00:11:57,749
gives you a false sense and it's

00:11:55,410 --> 00:11:59,399
actually not that easy if like it's easy

00:11:57,749 --> 00:12:01,319
to get started and to do some basic

00:11:59,399 --> 00:12:02,999
stuff but if you actually want to design

00:12:01,319 --> 00:12:06,480
the whole system's around it and build

00:12:02,999 --> 00:12:09,299
something that takes time and effort so

00:12:06,480 --> 00:12:11,309
why don't we do that right now why don't

00:12:09,299 --> 00:12:13,589
we take the next 15 minutes and go over

00:12:11,309 --> 00:12:15,869
the basics of the language we won't be

00:12:13,589 --> 00:12:17,509
able to cover everything but it should

00:12:15,869 --> 00:12:21,149
give us a good idea of how things work

00:12:17,509 --> 00:12:23,249
this might go fast so feel free to go

00:12:21,149 --> 00:12:25,049
over my slides later and try some of

00:12:23,249 --> 00:12:26,399
these stuff in your browser's console

00:12:25,049 --> 00:12:29,220
that's the best way to learn about this

00:12:26,399 --> 00:12:32,879
stuff and don't don't worry if you don't

00:12:29,220 --> 00:12:35,400
get everything right now before that

00:12:32,879 --> 00:12:37,680
let's have a quick word about different

00:12:35,400 --> 00:12:39,480
script versions the whole history of

00:12:37,680 --> 00:12:41,430
JavaScript is really interesting and

00:12:39,480 --> 00:12:43,920
fascinating but unfortunately what we

00:12:41,430 --> 00:12:46,140
don't have time for that what you need

00:12:43,920 --> 00:12:48,750
to know about is that javascript is a

00:12:46,140 --> 00:12:52,410
language standardized by the ACMA script

00:12:48,750 --> 00:12:53,720
standard yes for short and javascript is

00:12:52,410 --> 00:12:56,540
its most known application

00:12:53,720 --> 00:12:58,800
implementation sorry

00:12:56,540 --> 00:13:00,990
throughout the years new versions of

00:12:58,800 --> 00:13:02,490
ACMA scripts have been released the

00:13:00,990 --> 00:13:04,950
version that is supported even by the

00:13:02,490 --> 00:13:08,730
older browsers like Internet Explorer

00:13:04,950 --> 00:13:10,620
and stuff is es5 if you've never tried

00:13:08,730 --> 00:13:11,880
any of the newer versions or have no

00:13:10,620 --> 00:13:15,170
idea what I'm talking about right now

00:13:11,880 --> 00:13:19,940
that's the one you're familiar with in

00:13:15,170 --> 00:13:23,220
2015 ACMA script 6 or es6 or equi script

00:13:19,940 --> 00:13:25,170
2015 was released and the release was

00:13:23,220 --> 00:13:27,390
quite a big it was kind of like Python 3

00:13:25,170 --> 00:13:30,090
of the JavaScript world world but

00:13:27,390 --> 00:13:33,440
without the breaking changes it added a

00:13:30,090 --> 00:13:36,150
lot of new syntax to help write complex

00:13:33,440 --> 00:13:36,840
applications and fill in the missing

00:13:36,150 --> 00:13:39,630
gaps

00:13:36,840 --> 00:13:41,910
it added things like classes modules

00:13:39,630 --> 00:13:44,840
iterators generators arrow functions

00:13:41,910 --> 00:13:47,280
promises and a bunch of other things

00:13:44,840 --> 00:13:50,400
this is also the release where a lot of

00:13:47,280 --> 00:13:52,470
us stopped keeping up the version is

00:13:50,400 --> 00:13:56,550
well supported by modern browsers but

00:13:52,470 --> 00:13:59,010
not by older ones after that there was

00:13:56,550 --> 00:14:01,550
one release per year with more new

00:13:59,010 --> 00:14:07,230
features but not not nearly as big as

00:14:01,550 --> 00:14:09,330
echo script 2015 so ok let's do this the

00:14:07,230 --> 00:14:12,690
examples I'll show are using ACMA

00:14:09,330 --> 00:14:15,180
scripts to 2016 but most of them would

00:14:12,690 --> 00:14:17,460
work with ACMA script 2015 which you

00:14:15,180 --> 00:14:20,430
just mentioned and some would work with

00:14:17,460 --> 00:14:22,260
the classic es 5 since this is

00:14:20,430 --> 00:14:24,840
JavaScript for Python developers

00:14:22,260 --> 00:14:27,450
I will go very quickly over the parts

00:14:24,840 --> 00:14:29,310
that are similar and spend more time on

00:14:27,450 --> 00:14:32,700
the parts that aren't which I think are

00:14:29,310 --> 00:14:34,980
the interesting bits and this will be a

00:14:32,700 --> 00:14:37,040
handful but nothing that we can handle

00:14:34,980 --> 00:14:40,950
ok let's get right to it

00:14:37,040 --> 00:14:42,830
the syntax somewhat resembles Java but

00:14:40,950 --> 00:14:45,960
shouldn't be too foreign to Python users

00:14:42,830 --> 00:14:48,090
it's similar to Python it just uses

00:14:45,960 --> 00:14:48,780
curly braces semicolons and a lot more

00:14:48,090 --> 00:14:55,080
parental

00:14:48,780 --> 00:14:57,120
is so javascript is a dynamic and weakly

00:14:55,080 --> 00:15:00,590
typed language this means that just like

00:14:57,120 --> 00:15:02,760
in Python you can do the following but

00:15:00,590 --> 00:15:05,490
because it's a weakly typed language

00:15:02,760 --> 00:15:07,380
unlike Python it also means you can do

00:15:05,490 --> 00:15:13,830
stuff like this which doesn't always

00:15:07,380 --> 00:15:16,890
make sense so when you define a variable

00:15:13,830 --> 00:15:20,790
in JavaScript you have to use var let or

00:15:16,890 --> 00:15:23,370
Const var is function scoped while let

00:15:20,790 --> 00:15:25,920
and Const are block scoped additionally

00:15:23,370 --> 00:15:28,410
Const variable as the name implies is

00:15:25,920 --> 00:15:30,900
constant so trying to change it will

00:15:28,410 --> 00:15:32,190
result in an error and let's talk more

00:15:30,900 --> 00:15:35,910
about scope because we don't really

00:15:32,190 --> 00:15:37,740
think about that in Python so Python and

00:15:35,910 --> 00:15:40,080
JavaScript are similar when it comes to

00:15:37,740 --> 00:15:42,600
function scoped variables so if you look

00:15:40,080 --> 00:15:45,540
at the first example it works as you

00:15:42,600 --> 00:15:48,300
would expect expected and variable B is

00:15:45,540 --> 00:15:50,580
not defined outside of the function but

00:15:48,300 --> 00:15:54,810
unlike Python JavaScript also knows

00:15:50,580 --> 00:15:57,390
knows of a thing called block scope this

00:15:54,810 --> 00:15:59,760
is also used in other languages block is

00:15:57,390 --> 00:16:02,670
defined by a set of curly braces so that

00:15:59,760 --> 00:16:05,970
means for and while loops if statements

00:16:02,670 --> 00:16:08,460
and so on that's all blocks if you're

00:16:05,970 --> 00:16:10,830
using less or Const those variables will

00:16:08,460 --> 00:16:12,840
be defined only within that block but

00:16:10,830 --> 00:16:16,920
not outside of it and this is different

00:16:12,840 --> 00:16:18,900
from how Python does it if however you

00:16:16,920 --> 00:16:22,920
used var to define the variable it would

00:16:18,900 --> 00:16:26,240
behave the same as Python usually we

00:16:22,920 --> 00:16:28,950
want to use let and Const because that's

00:16:26,240 --> 00:16:30,540
other developers might expect that as

00:16:28,950 --> 00:16:33,690
well

00:16:30,540 --> 00:16:35,040
so okay function versus the function

00:16:33,690 --> 00:16:37,680
versus block scope is easy to work

00:16:35,040 --> 00:16:41,100
around but there is a way bigger problem

00:16:37,680 --> 00:16:44,130
with JavaScript scope and that is global

00:16:41,100 --> 00:16:46,620
scope so every JavaScript code that runs

00:16:44,130 --> 00:16:49,440
on your website can define thing in the

00:16:46,620 --> 00:16:51,710
global scope even if it's two separate

00:16:49,440 --> 00:16:54,510
files they will share the global scope

00:16:51,710 --> 00:16:56,670
this can be useful in small program

00:16:54,510 --> 00:16:57,060
programs and not really that big of a

00:16:56,670 --> 00:16:59,529
deal

00:16:57,060 --> 00:17:02,829
but it's very dangerous in error-prone

00:16:59,529 --> 00:17:04,390
as decided of the program grows so it's

00:17:02,829 --> 00:17:07,780
important to package your code into

00:17:04,390 --> 00:17:11,010
modules classes objects and closures you

00:17:07,780 --> 00:17:13,689
do not want to pollute the global scope

00:17:11,010 --> 00:17:16,480
that way you know you can you should

00:17:13,689 --> 00:17:20,289
minimize the global footprint and make

00:17:16,480 --> 00:17:23,260
things a lot saner so by the way if you

00:17:20,289 --> 00:17:25,929
ever define a fungal without using

00:17:23,260 --> 00:17:28,360
varlet or const the variable will

00:17:25,929 --> 00:17:32,710
automatically be assigned to global

00:17:28,360 --> 00:17:34,240
scope which can be a real problem ok

00:17:32,710 --> 00:17:36,700
since we're talking about varlet and

00:17:34,240 --> 00:17:39,190
const yeah like i said generally

00:17:36,700 --> 00:17:41,440
speaking you should avoid far that's

00:17:39,190 --> 00:17:45,130
because variable is defined with var or

00:17:41,440 --> 00:17:47,830
are also hoisted so used left or Const

00:17:45,130 --> 00:17:50,950
instead hosting which is something we're

00:17:47,830 --> 00:17:53,049
not familiar in Python is it means that

00:17:50,950 --> 00:17:55,740
the two examples here are interpreted in

00:17:53,049 --> 00:17:57,640
the same way and this can lead to some

00:17:55,740 --> 00:18:00,039
unexpected behavior if you're not

00:17:57,640 --> 00:18:02,669
careful so this is a simple example

00:18:00,039 --> 00:18:07,270
showing why hoisting can be problematic

00:18:02,669 --> 00:18:09,370
so here we have a variable X that's

00:18:07,270 --> 00:18:13,960
assigned a value 10 then we define a

00:18:09,370 --> 00:18:16,360
function func that prints out the X then

00:18:13,960 --> 00:18:19,000
there's a lot of code then it defines a

00:18:16,360 --> 00:18:23,710
variable X and then again it brings the

00:18:19,000 --> 00:18:25,510
prints out the variable X now it's not a

00:18:23,710 --> 00:18:28,659
complicated but imagine that there's a

00:18:25,510 --> 00:18:30,580
lot of code in between or that the X on

00:18:28,659 --> 00:18:35,649
line 5 is added later by another

00:18:30,580 --> 00:18:37,690
developer so what happens here is like

00:18:35,649 --> 00:18:44,919
you get undefined first and then you get

00:18:37,690 --> 00:18:46,890
5 because of hoisting so with all that

00:18:44,919 --> 00:18:50,110
knowledge here's a riddle for you

00:18:46,890 --> 00:18:53,710
here we have a code we have a list of

00:18:50,110 --> 00:18:57,280
factors 2 4 6 8 we have an empty list of

00:18:53,710 --> 00:19:02,110
multipliers and then we we iterate

00:18:57,280 --> 00:19:04,809
through the list of factors and add an

00:19:02,110 --> 00:19:07,409
anonymous function which will take an

00:19:04,809 --> 00:19:11,549
argument and multiply it by the factor

00:19:07,409 --> 00:19:11,549
so if we look at the

00:19:11,870 --> 00:19:19,090
I could if we look at the output of the

00:19:16,610 --> 00:19:24,410
last line what do you think it should be

00:19:19,090 --> 00:19:25,850
any guesses if you let's actually that's

00:19:24,410 --> 00:19:27,980
if you think that's this is just

00:19:25,850 --> 00:19:30,620
JavaScript let's translate this example

00:19:27,980 --> 00:19:33,110
to Python this should be easier right

00:19:30,620 --> 00:19:36,970
this is a this is a Django conference

00:19:33,110 --> 00:19:42,950
what's the output going going to be here

00:19:36,970 --> 00:19:45,800
for it's actually 16 now the reason for

00:19:42,950 --> 00:19:48,890
that and the same thing happens in

00:19:45,800 --> 00:19:52,340
JavaScript this is because the variable

00:19:48,890 --> 00:19:55,100
factor is function scoped and the

00:19:52,340 --> 00:19:57,380
anonymous function will evaluate factor

00:19:55,100 --> 00:20:00,110
when the function is called not when

00:19:57,380 --> 00:20:04,040
it's defined so by the time we call

00:20:00,110 --> 00:20:08,510
multipliers the for loop has ran and the

00:20:04,040 --> 00:20:10,880
factor equals 8 however this would be

00:20:08,510 --> 00:20:14,059
fixed if we used block scope instead so

00:20:10,880 --> 00:20:17,630
like what happens if we change if we

00:20:14,059 --> 00:20:18,710
changed let if we change var to let we

00:20:17,630 --> 00:20:22,970
get what we expect

00:20:18,710 --> 00:20:25,700
what would we would expect for okay

00:20:22,970 --> 00:20:28,720
enough about that that stuff you just

00:20:25,700 --> 00:20:30,950
have to try out and get a sense of it

00:20:28,720 --> 00:20:31,700
let's talk about data types in

00:20:30,950 --> 00:20:35,390
JavaScript

00:20:31,700 --> 00:20:38,179
so JavaScript has has five different

00:20:35,390 --> 00:20:41,300
simple types and everything else is an

00:20:38,179 --> 00:20:44,000
object objects in JavaScript are key

00:20:41,300 --> 00:20:46,850
collections that are mutable so the

00:20:44,000 --> 00:20:50,360
simple types are boolean null undefined

00:20:46,850 --> 00:20:52,490
string and number these types types are

00:20:50,360 --> 00:20:56,000
immutable and they're object like in the

00:20:52,490 --> 00:20:58,520
sense that they have methods objects on

00:20:56,000 --> 00:21:01,490
the other hand are mutable arrays

00:20:58,520 --> 00:21:04,940
functions and of course objects are all

00:21:01,490 --> 00:21:07,520
objects this means they can have that

00:21:04,940 --> 00:21:10,790
they can have attributes methods and can

00:21:07,520 --> 00:21:13,130
be passed around as parameters and can

00:21:10,790 --> 00:21:15,520
be returned by functions this is very

00:21:13,130 --> 00:21:18,470
cool because that is what makes

00:21:15,520 --> 00:21:21,260
functions first-class which gives

00:21:18,470 --> 00:21:24,130
JavaScript the super powers to be used

00:21:21,260 --> 00:21:24,130
as a functional language

00:21:24,440 --> 00:21:29,070
let's talk it let's look at the simple

00:21:27,480 --> 00:21:31,590
types so boolean is what you would

00:21:29,070 --> 00:21:34,080
expect and is similar to Python now is

00:21:31,590 --> 00:21:36,269
the JavaScript version of none then

00:21:34,080 --> 00:21:37,799
there is undefined which represents

00:21:36,269 --> 00:21:40,799
something that hasn't been defined

00:21:37,799 --> 00:21:43,679
versus the empty value which is now if

00:21:40,799 --> 00:21:47,519
it seems confusing is because it's it's

00:21:43,679 --> 00:21:49,799
because it is JavaScript has only one

00:21:47,519 --> 00:21:53,250
way to encode strings and that's 16-bit

00:21:49,799 --> 00:21:54,990
unicode and there is only one way to one

00:21:53,250 --> 00:21:57,330
type for numbers which uses

00:21:54,990 --> 00:21:58,980
floating-point for everything meaning

00:21:57,330 --> 00:22:03,990
there is no separate integer or decimal

00:21:58,980 --> 00:22:05,700
type which can also be problematic now

00:22:03,990 --> 00:22:07,350
when it comes to objects there are

00:22:05,700 --> 00:22:09,720
different ways to declare them just like

00:22:07,350 --> 00:22:12,179
in python usually we use the object

00:22:09,720 --> 00:22:14,490
literal to declare them which is similar

00:22:12,179 --> 00:22:17,549
to how you usually declare a dictionary

00:22:14,490 --> 00:22:19,500
in Python so the syntax should be

00:22:17,549 --> 00:22:23,240
familiar except in JavaScript you can

00:22:19,500 --> 00:22:25,679
also define methods on an object and

00:22:23,240 --> 00:22:27,299
because the objects in JavaScript are

00:22:25,679 --> 00:22:30,779
immutable we have to be careful about

00:22:27,299 --> 00:22:36,509
changing the state this is similar to to

00:22:30,779 --> 00:22:38,820
Python the logical operators look

00:22:36,509 --> 00:22:41,759
similar to Python except they're more

00:22:38,820 --> 00:22:44,129
verbose there's one big catch though

00:22:41,759 --> 00:22:48,179
when doing comparisons you have two

00:22:44,129 --> 00:22:51,149
options there is abstract equality the

00:22:48,179 --> 00:22:53,399
double equal sign or strict equality the

00:22:51,149 --> 00:22:57,090
triple equal sign you should almost

00:22:53,399 --> 00:22:59,549
always use the triple equal sign so the

00:22:57,090 --> 00:23:01,470
strict equality because it will give you

00:22:59,549 --> 00:23:04,259
the result you would most likely expect

00:23:01,470 --> 00:23:09,899
the abstract version will only compare

00:23:04,259 --> 00:23:12,149
the value but not the type let's look at

00:23:09,899 --> 00:23:15,289
what happens if if you're using the

00:23:12,149 --> 00:23:15,289
abstract version instead

00:23:21,299 --> 00:23:29,829
so simply use the triple equal sign most

00:23:25,149 --> 00:23:31,629
of the time and you should be fine there

00:23:29,829 --> 00:23:34,179
are two main ways you can define a

00:23:31,629 --> 00:23:36,519
function in JavaScript you can use a

00:23:34,179 --> 00:23:38,979
function keyword or using a fat arrow

00:23:36,519 --> 00:23:41,349
function you can define a function

00:23:38,979 --> 00:23:43,389
globally inside another function as a

00:23:41,349 --> 00:23:45,999
method on an object as a method on a

00:23:43,389 --> 00:23:47,469
class for that matter you can define a

00:23:45,999 --> 00:23:50,409
function anywhere as an anonymous

00:23:47,469 --> 00:23:53,829
function using the anonymous functions

00:23:50,409 --> 00:23:55,209
is very common in JavaScript so common

00:23:53,829 --> 00:23:57,190
in fact that it's one of the reasons

00:23:55,209 --> 00:24:05,109
that JavaScript has arrow functions

00:23:57,190 --> 00:24:07,719
which are quicker to write this is an

00:24:05,109 --> 00:24:11,619
example of function as a method on an

00:24:07,719 --> 00:24:13,659
object so with arguments it's quite

00:24:11,619 --> 00:24:15,729
similar to Python you can give the

00:24:13,659 --> 00:24:18,519
function arguments and you can give

00:24:15,729 --> 00:24:19,929
those arguments default values when the

00:24:18,519 --> 00:24:22,659
function is called it can be called

00:24:19,929 --> 00:24:25,149
that's different it can be called with

00:24:22,659 --> 00:24:26,940
any number of parameters regardless of

00:24:25,149 --> 00:24:29,619
how many were in the function definition

00:24:26,940 --> 00:24:31,869
if it's so if you call a function with

00:24:29,619 --> 00:24:35,019
fewer arguments that the rest will just

00:24:31,869 --> 00:24:37,539
be filled with undefined and if you call

00:24:35,019 --> 00:24:42,519
a function with extra arguments those

00:24:37,539 --> 00:24:43,959
will simply be ignored and a good thing

00:24:42,519 --> 00:24:46,629
to notice that a function in JavaScript

00:24:43,959 --> 00:24:48,849
will always return something if you

00:24:46,629 --> 00:24:55,149
don't specify what it will return

00:24:48,849 --> 00:24:57,759
undefined so okay this is this is also

00:24:55,149 --> 00:24:59,829
one of them one of the bigger like

00:24:57,759 --> 00:25:02,589
points of confusion when it comes to

00:24:59,829 --> 00:25:04,719
JavaScript so in Python we have self

00:25:02,589 --> 00:25:07,299
when working with classes and objects

00:25:04,719 --> 00:25:09,009
self will be passed to methods and it's

00:25:07,299 --> 00:25:13,149
a reference to the instance of the

00:25:09,009 --> 00:25:15,639
object in JavaScript we have this but it

00:25:13,149 --> 00:25:18,099
behaves a bit differently let's let's

00:25:15,639 --> 00:25:21,579
first look at this example so it's like

00:25:18,099 --> 00:25:23,739
an object called pets it has like two

00:25:21,579 --> 00:25:28,359
attributes names an owner and then it

00:25:23,739 --> 00:25:31,979
has a method which will return like a

00:25:28,359 --> 00:25:31,979
description of the object

00:25:32,130 --> 00:25:40,360
now to understand what's going on like

00:25:38,170 --> 00:25:42,880
let's explain this a bit more so in

00:25:40,360 --> 00:25:46,240
JavaScript this is best passed to every

00:25:42,880 --> 00:25:49,210
function not just method if we define

00:25:46,240 --> 00:25:50,910
function as a method this will store the

00:25:49,210 --> 00:25:54,250
object which is what we would expect

00:25:50,910 --> 00:25:56,500
however if a function was not defined as

00:25:54,250 --> 00:25:57,880
a method this will reference the global

00:25:56,500 --> 00:26:02,380
object which is where the confusion

00:25:57,880 --> 00:26:04,240
comes so for example if we if a method

00:26:02,380 --> 00:26:06,160
will have some anonymous function we

00:26:04,240 --> 00:26:08,920
have to be careful as this might not be

00:26:06,160 --> 00:26:11,740
in the object we want it was not defined

00:26:08,920 --> 00:26:15,790
as a method so for example what do you

00:26:11,740 --> 00:26:22,990
think that the description method will

00:26:15,790 --> 00:26:25,480
output here any guesses so it should it

00:26:22,990 --> 00:26:29,710
return like this owner so that's Walt

00:26:25,480 --> 00:26:33,430
knows an awesome cat named Pat and it

00:26:29,710 --> 00:26:35,530
should do this for for for every name in

00:26:33,430 --> 00:26:37,770
the list so like it should be a list of

00:26:35,530 --> 00:26:40,890
these descriptions the first one being

00:26:37,770 --> 00:26:44,950
world knows an awesome pet named Simba

00:26:40,890 --> 00:26:47,080
now is that what we get no we get

00:26:44,950 --> 00:26:51,520
undefined and because of the reason I

00:26:47,080 --> 00:26:54,160
explained this in this example is bound

00:26:51,520 --> 00:26:59,110
to to the global object so it doesn't

00:26:54,160 --> 00:27:02,680
know of a an attribute called owner so

00:26:59,110 --> 00:27:05,440
like if if instead we used an arrow

00:27:02,680 --> 00:27:07,480
function we might get something

00:27:05,440 --> 00:27:09,970
different and the reason for that is

00:27:07,480 --> 00:27:12,970
that arrow functions are special in the

00:27:09,970 --> 00:27:17,380
sense that they don't that they don't

00:27:12,970 --> 00:27:20,830
bind their this so this will just be

00:27:17,380 --> 00:27:24,190
inherited from their scope in this

00:27:20,830 --> 00:27:26,710
example that's exactly what we need so

00:27:24,190 --> 00:27:30,430
here we get Walt knows an like like we

00:27:26,710 --> 00:27:32,860
would expect in order to avoid this

00:27:30,430 --> 00:27:36,160
problem it used to be a lot more verbose

00:27:32,860 --> 00:27:39,340
before es6 usually developers would do

00:27:36,160 --> 00:27:40,540
like that equals this and then in the

00:27:39,340 --> 00:27:43,450
inner function they would use that

00:27:40,540 --> 00:27:46,300
because it's the disk that they would

00:27:43,450 --> 00:27:48,690
once and yes it's as confusing as it

00:27:46,300 --> 00:27:48,690
sounds

00:27:49,390 --> 00:27:54,580
javascript is prototypal in nature which

00:27:52,180 --> 00:27:57,880
is in fact a lot more flexible than the

00:27:54,580 --> 00:27:59,740
object-oriented inheritance model but it

00:27:57,880 --> 00:28:01,300
can also support the classes that we are

00:27:59,740 --> 00:28:04,570
familiar with from Python and other

00:28:01,300 --> 00:28:06,370
languages it used to be a lot more

00:28:04,570 --> 00:28:09,730
verbose to implement this behavior that

00:28:06,370 --> 00:28:14,470
you're seeing here but since es6 it's

00:28:09,730 --> 00:28:17,680
very easy and straightforward and we

00:28:14,470 --> 00:28:20,590
have then we have modules they're quite

00:28:17,680 --> 00:28:23,410
easy to use in JavaScript in one sense

00:28:20,590 --> 00:28:25,930
not header they do require some kind of

00:28:23,410 --> 00:28:28,990
module loader so they won't work on

00:28:25,930 --> 00:28:34,780
their own you have to use like a web

00:28:28,990 --> 00:28:36,700
pack for example to get this to work so

00:28:34,780 --> 00:28:39,370
we're not going to go into that in

00:28:36,700 --> 00:28:41,530
detail but the syntax is somewhat

00:28:39,370 --> 00:28:44,890
familiar to Python the difference is

00:28:41,530 --> 00:28:47,950
that we also have to use export keywords

00:28:44,890 --> 00:28:52,090
and specifically do you know which part

00:28:47,950 --> 00:28:55,930
we want to export so we all love the new

00:28:52,090 --> 00:28:57,940
F strings right well JavaScript also

00:28:55,930 --> 00:28:59,950
offers the similar backtick template

00:28:57,940 --> 00:29:02,080
literal and they were actually

00:28:59,950 --> 00:29:04,630
implemented one year before Python got F

00:29:02,080 --> 00:29:06,640
strings and they work a lot like f

00:29:04,630 --> 00:29:08,170
strings so if you know if strings you

00:29:06,640 --> 00:29:11,310
should be familiar with this they can

00:29:08,170 --> 00:29:13,780
even be multi-line in my opinion

00:29:11,310 --> 00:29:15,850
javascript needed this way more than

00:29:13,780 --> 00:29:18,880
Python did because the alternative here

00:29:15,850 --> 00:29:20,500
looked like this and this is just insane

00:29:18,880 --> 00:29:25,030
like no one no one wants to write code

00:29:20,500 --> 00:29:31,060
like that then we come to a really big

00:29:25,030 --> 00:29:34,150
part called promises so a promise is an

00:29:31,060 --> 00:29:37,000
object that represents a value that is

00:29:34,150 --> 00:29:39,280
not known at the time of the creation it

00:29:37,000 --> 00:29:41,770
will be known sometime in the future but

00:29:39,280 --> 00:29:45,340
it's not known when you create it so

00:29:41,770 --> 00:29:47,500
what you do with it is you give it a

00:29:45,340 --> 00:29:50,320
function that it should called when when

00:29:47,500 --> 00:29:53,380
the value is known this is something

00:29:50,320 --> 00:29:55,450
that is very useful to have because when

00:29:53,380 --> 00:29:57,040
building web applications this is

00:29:55,450 --> 00:30:00,490
something we need all the time

00:29:57,040 --> 00:30:04,030
so you know in browsers javascript is

00:30:00,490 --> 00:30:07,270
single threaded so that means if like we

00:30:04,030 --> 00:30:08,950
make a request synchronously it will

00:30:07,270 --> 00:30:10,480
it'll brought block the whole

00:30:08,950 --> 00:30:11,890
application you won't be able to scroll

00:30:10,480 --> 00:30:14,980
you won't be able to click you won't be

00:30:11,890 --> 00:30:15,730
able to do anything so we have to do

00:30:14,980 --> 00:30:17,920
these things

00:30:15,730 --> 00:30:21,760
a synchronously and because this is so

00:30:17,920 --> 00:30:25,270
common we use promises which is kind of

00:30:21,760 --> 00:30:28,360
like a sensible way to do these things

00:30:25,270 --> 00:30:31,270
we also in the newer features there are

00:30:28,360 --> 00:30:33,460
new other ways to do this but if you

00:30:31,270 --> 00:30:37,930
learn about promises that should get you

00:30:33,460 --> 00:30:41,230
quite far and like to just quickly go

00:30:37,930 --> 00:30:45,580
over this example so we have load page

00:30:41,230 --> 00:30:47,940
element which calls get page and get

00:30:45,580 --> 00:30:53,080
page is a promise

00:30:47,940 --> 00:30:56,860
so we do then which does what we would

00:30:53,080 --> 00:30:59,080
expect it to so when get page will have

00:30:56,860 --> 00:30:59,620
the value that we want sometime in the

00:30:59,080 --> 00:31:03,010
future

00:30:59,620 --> 00:31:05,680
the then will be called and that's this

00:31:03,010 --> 00:31:10,270
function so we do something with the

00:31:05,680 --> 00:31:12,880
result and we also do the catch method

00:31:10,270 --> 00:31:18,360
which will handle the error if anything

00:31:12,880 --> 00:31:20,890
went wrong while trying to get page and

00:31:18,360 --> 00:31:25,680
like so this is a really common thing to

00:31:20,890 --> 00:31:28,450
see in most of JavaScript applications

00:31:25,680 --> 00:31:30,490
now as I've said it's not like

00:31:28,450 --> 00:31:33,640
JavaScript is without its flaws it has

00:31:30,490 --> 00:31:36,040
many it was designed in a hurry had a

00:31:33,640 --> 00:31:39,910
rough childhood and is plagued by being

00:31:36,040 --> 00:31:42,400
used with some awful Dom api's those

00:31:39,910 --> 00:31:46,450
aren't a part of JavaScript itself but

00:31:42,400 --> 00:31:47,980
javascript gets to blame for them but if

00:31:46,450 --> 00:31:49,630
you think about it you can do weird

00:31:47,980 --> 00:31:52,330
stuff with our other languages as well

00:31:49,630 --> 00:31:55,330
if you want to but you don't because you

00:31:52,330 --> 00:31:57,700
learn how to use it right so for example

00:31:55,330 --> 00:32:00,280
let's look at Python you can write ugly

00:31:57,700 --> 00:32:01,960
Python code like there's nothing

00:32:00,280 --> 00:32:04,540
stopping you from doing this and it's

00:32:01,960 --> 00:32:07,900
it's a valid code but you wouldn't do

00:32:04,540 --> 00:32:09,430
that even worse you wouldn't do you

00:32:07,900 --> 00:32:10,630
wouldn't do that because you're messing

00:32:09,430 --> 00:32:12,550
up with the iteration

00:32:10,630 --> 00:32:14,140
but there's nothing stopping you from

00:32:12,550 --> 00:32:17,950
doing it you just learn how to you know

00:32:14,140 --> 00:32:20,230
not do it and since we're at a Django

00:32:17,950 --> 00:32:24,370
conference I've seen that in like in one

00:32:20,230 --> 00:32:27,610
pull request one time you wouldn't do

00:32:24,370 --> 00:32:29,440
that but there's nothing stopping you

00:32:27,610 --> 00:32:30,510
from doing it like the language allows

00:32:29,440 --> 00:32:33,640
you to do that

00:32:30,510 --> 00:32:35,140
so let me try to get a visual in your

00:32:33,640 --> 00:32:38,430
head do you remember a movie called

00:32:35,140 --> 00:32:40,690
gremlins for those of you who don't

00:32:38,430 --> 00:32:44,710
there's this little cute little creature

00:32:40,690 --> 00:32:47,350
creature called Mogwai it gets named

00:32:44,710 --> 00:32:50,850
gizmo now it's the cutest thing ever

00:32:47,350 --> 00:32:54,070
right but it comes with three rules

00:32:50,850 --> 00:32:56,410
never expose it to direct sunlight do

00:32:54,070 --> 00:32:58,960
not let it get wet and do not feed it

00:32:56,410 --> 00:33:02,080
after midnight what happens if you do

00:32:58,960 --> 00:33:04,510
any of those things chaos and

00:33:02,080 --> 00:33:07,870
destruction and that brings us to

00:33:04,510 --> 00:33:09,310
JavaScript learn about the parts you

00:33:07,870 --> 00:33:12,300
shouldn't be using it the first place

00:33:09,310 --> 00:33:15,030
and you're going to have a great time

00:33:12,300 --> 00:33:17,650
I've mentioned this earlier in my talk

00:33:15,030 --> 00:33:21,010
but I suggest a book this is actually a

00:33:17,650 --> 00:33:22,930
really good book both of them are it's

00:33:21,010 --> 00:33:25,330
called JavaScript the good parts by

00:33:22,930 --> 00:33:27,250
Douglas Crockford it's a bit outdated

00:33:25,330 --> 00:33:30,270
but still very very useful

00:33:27,250 --> 00:33:33,070
I also here he's working with a new one

00:33:30,270 --> 00:33:35,200
the book focuses on the good parts of

00:33:33,070 --> 00:33:37,380
JavaScript and also talks about parts

00:33:35,200 --> 00:33:39,910
that were just not a good idea

00:33:37,380 --> 00:33:41,880
it talks about a source of a lot of

00:33:39,910 --> 00:33:47,110
confusion and unexpected behavior

00:33:41,880 --> 00:33:48,820
however I think the es6 and above are

00:33:47,110 --> 00:33:51,640
doing a great job at addressing these

00:33:48,820 --> 00:33:54,310
problems but the bad parts are still

00:33:51,640 --> 00:34:00,010
there so you have to be aware of them

00:33:54,310 --> 00:34:02,020
and avoid them a quick shout-out to my

00:34:00,010 --> 00:34:04,480
friends add Lacey

00:34:02,020 --> 00:34:07,240
Sarang Yura and and Raj who helped me

00:34:04,480 --> 00:34:08,150
bring this talk to its final form thank

00:34:07,240 --> 00:34:10,599
you

00:34:08,150 --> 00:34:15,190
[Applause]

00:34:10,599 --> 00:34:18,669
I had a question so what was the most

00:34:15,190 --> 00:34:22,299
difficult part of kind of organizing

00:34:18,669 --> 00:34:24,729
this talk because it is such a you know

00:34:22,299 --> 00:34:26,950
expansive task to compare two languages

00:34:24,729 --> 00:34:31,119
in the way that you did and have them

00:34:26,950 --> 00:34:33,460
side-by-side it was a journey like this

00:34:31,119 --> 00:34:35,710
is the third iteration of the talk I

00:34:33,460 --> 00:34:38,859
first gave this talk at Euro Python this

00:34:35,710 --> 00:34:40,659
year and then a local Python Meetup and

00:34:38,859 --> 00:34:43,419
like what you saw right now is a

00:34:40,659 --> 00:34:45,159
completely different thing it's

00:34:43,419 --> 00:34:47,319
difficult to get right because there's

00:34:45,159 --> 00:34:50,739
the subject like there's so much to talk

00:34:47,319 --> 00:34:53,019
about there's a lot to explain so it's

00:34:50,739 --> 00:34:55,289
hard to get it right I don't know if

00:34:53,019 --> 00:34:58,779
it's there yet but it's getting there

00:34:55,289 --> 00:35:00,640
yeah so the question was how would a

00:34:58,779 --> 00:35:04,599
promise be different than a callback

00:35:00,640 --> 00:35:06,819
because so before promises in JavaScript

00:35:04,599 --> 00:35:09,249
we would use callbacks in order to

00:35:06,819 --> 00:35:11,380
handle the asynchronous code what would

00:35:09,249 --> 00:35:13,720
happen then I don't have this here but

00:35:11,380 --> 00:35:15,519
what would happen is you would have a

00:35:13,720 --> 00:35:18,190
call back within a call back within a

00:35:15,519 --> 00:35:20,440
call back within a callback which is

00:35:18,190 --> 00:35:23,259
commonly referred to as the callback

00:35:20,440 --> 00:35:24,450
hell and you want to avoid that at any

00:35:23,259 --> 00:35:27,609
cost because it's completely

00:35:24,450 --> 00:35:31,239
unmaintainable very very difficult to

00:35:27,609 --> 00:35:33,489
read so the problem with it is that if

00:35:31,239 --> 00:35:36,279
an error happens in one of those

00:35:33,489 --> 00:35:38,319
callbacks it's just like you have to

00:35:36,279 --> 00:35:43,269
handle errors at every point of the way

00:35:38,319 --> 00:35:45,489
whereas here where you see the where you

00:35:43,269 --> 00:35:48,460
see get page and then you're doing done

00:35:45,489 --> 00:35:50,529
and then you have catch catch will

00:35:48,460 --> 00:35:53,589
handle any of the errors that happen

00:35:50,529 --> 00:35:57,160
above basically like you want to test

00:35:53,589 --> 00:35:59,079
this stuff out how exactly it works but

00:35:57,160 --> 00:36:02,229
that's the nice part about it like you

00:35:59,079 --> 00:36:04,569
put like a general catch-all on how to

00:36:02,229 --> 00:36:07,150
handle if something goes wrong and then

00:36:04,569 --> 00:36:09,759
you you can chain them which is a lot a

00:36:07,150 --> 00:36:13,210
lot easier to read and maintain so we

00:36:09,759 --> 00:36:16,420
like you can you can do ad n will always

00:36:13,210 --> 00:36:19,749
will return a dent method will always

00:36:16,420 --> 00:36:22,869
return a promise so you can then chain

00:36:19,749 --> 00:36:23,940
them you do ten something and then on

00:36:22,869 --> 00:36:26,010
that you put Dan

00:36:23,940 --> 00:36:29,550
something and basically you're like

00:36:26,010 --> 00:36:31,650
doing this train of things like okay

00:36:29,550 --> 00:36:33,180
first this should happen then this just

00:36:31,650 --> 00:36:35,490
happened and this should happen and it

00:36:33,180 --> 00:36:37,410
all happens asynchronously and it's a

00:36:35,490 --> 00:36:37,950
lot easier to to wrap your head around

00:36:37,410 --> 00:36:40,350
it

00:36:37,950 --> 00:36:42,510
but then again promises are something

00:36:40,350 --> 00:36:45,810
that is it's one of those concepts where

00:36:42,510 --> 00:36:49,140
it feels really weird if you're not used

00:36:45,810 --> 00:36:51,780
to it and then one day it clicks and you

00:36:49,140 --> 00:36:54,330
don't know why I didn't get it you know

00:36:51,780 --> 00:36:55,950
why I didn't get it before then you then

00:36:54,330 --> 00:36:58,890
it just feels like okay I've always

00:36:55,950 --> 00:37:00,840
known about this first question is is

00:36:58,890 --> 00:37:02,460
JavaScript becoming more like Python or

00:37:00,840 --> 00:37:06,480
is Python becoming more like JavaScript

00:37:02,460 --> 00:37:07,650
in my opinion right well did they get

00:37:06,480 --> 00:37:12,270
something from each other

00:37:07,650 --> 00:37:14,670
so but I think JavaScript is because I

00:37:12,270 --> 00:37:16,470
don't like putting it that way that

00:37:14,670 --> 00:37:19,500
JavaScript is becoming more like Python

00:37:16,470 --> 00:37:21,540
but it does draw some things it did draw

00:37:19,500 --> 00:37:24,270
some things from Python in the latest

00:37:21,540 --> 00:37:27,120
version so like you have spread spread

00:37:24,270 --> 00:37:30,420
operator which when you do like arts and

00:37:27,120 --> 00:37:35,850
carts and like the Asterix thing in

00:37:30,420 --> 00:37:37,920
Python JavaScript borrowed that I think

00:37:35,850 --> 00:37:40,080
yeah it's that way around but then if

00:37:37,920 --> 00:37:48,210
you ask it what was your second question

00:37:40,080 --> 00:37:50,550
I think both my I mean like one of the

00:37:48,210 --> 00:37:53,250
things I liked that Douglas Crockford

00:37:50,550 --> 00:37:56,310
was also talking about was that a

00:37:53,250 --> 00:37:58,230
language can become important for two

00:37:56,310 --> 00:38:01,050
reason two reasons it can become

00:37:58,230 --> 00:38:03,810
important for its you know ideas how it

00:38:01,050 --> 00:38:06,990
does things or it can become important

00:38:03,810 --> 00:38:09,870
just due to popularity and like you

00:38:06,990 --> 00:38:12,180
could argue that python is important

00:38:09,870 --> 00:38:15,600
because it has great ideas and also it's

00:38:12,180 --> 00:38:17,940
popular but in JavaScript could argue is

00:38:15,600 --> 00:38:20,940
important because of its popularity and

00:38:17,940 --> 00:38:25,620
it's not like it's going away just just

00:38:20,940 --> 00:38:28,620
because of how how widely it's used so

00:38:25,620 --> 00:38:30,870
like I think we're stuck with both thank

00:38:28,620 --> 00:38:32,610
you again for a great talk besides

00:38:30,870 --> 00:38:34,410
JavaScript the good parts what other

00:38:32,610 --> 00:38:36,540
resources would you recommend and this

00:38:34,410 --> 00:38:37,680
talk obviously what other resources

00:38:36,540 --> 00:38:39,690
would you recommend for us

00:38:37,680 --> 00:38:41,220
someone that is a Python developer that

00:38:39,690 --> 00:38:43,260
wants to learn JavaScript or at least be

00:38:41,220 --> 00:38:45,780
professional yeah so I really like the

00:38:43,260 --> 00:38:47,550
JavaScript the good parts I actually

00:38:45,780 --> 00:38:49,710
read it just for this stock and I was

00:38:47,550 --> 00:38:51,090
surprised it's quite outdated because it

00:38:49,710 --> 00:38:53,160
doesn't talk about the newest versions

00:38:51,090 --> 00:38:54,780
but just the the way it talks about it

00:38:53,160 --> 00:38:57,420
and explains a few things I found very

00:38:54,780 --> 00:38:59,220
useful and I personally got a like a

00:38:57,420 --> 00:39:03,180
much deeper understanding of JavaScript

00:38:59,220 --> 00:39:06,060
because of it the definitive guide is

00:39:03,180 --> 00:39:09,470
also I heard I've heard as a good book

00:39:06,060 --> 00:39:12,420
but it's you know we saw much bigger so

00:39:09,470 --> 00:39:14,730
how I see it is it's good to get some

00:39:12,420 --> 00:39:18,330
sense of the language like with that

00:39:14,730 --> 00:39:20,370
book with the good parts that's one

00:39:18,330 --> 00:39:23,370
thing but then the other thing as with

00:39:20,370 --> 00:39:25,410
any language so on one hand you have the

00:39:23,370 --> 00:39:27,300
syntax and how the language works right

00:39:25,410 --> 00:39:30,090
but on the other hand you have

00:39:27,300 --> 00:39:32,250
frameworks packages ecosystem which is

00:39:30,090 --> 00:39:34,590
just as big as how the language itself

00:39:32,250 --> 00:39:38,220
works right that's the same in any

00:39:34,590 --> 00:39:40,080
language and that part is just a scary

00:39:38,220 --> 00:39:41,790
if not more scary in JavaScript just

00:39:40,080 --> 00:39:44,250
because of how many packages you have

00:39:41,790 --> 00:39:47,210
how it's so difficult to decide you have

00:39:44,250 --> 00:39:51,090
no idea where to start and with that I

00:39:47,210 --> 00:39:53,130
the thing I found very useful was to

00:39:51,090 --> 00:39:57,000
start with a with one of those

00:39:53,130 --> 00:40:00,030
frameworks what for example angular and

00:39:57,000 --> 00:40:03,630
ember those two I really liked

00:40:00,030 --> 00:40:04,260
just because there they set things up

00:40:03,630 --> 00:40:07,140
for you

00:40:04,260 --> 00:40:09,060
much like Django does like Django will

00:40:07,140 --> 00:40:11,520
let you just start writing code and not

00:40:09,060 --> 00:40:13,950
bother you with the details that you

00:40:11,520 --> 00:40:16,410
don't want to like deal with right now

00:40:13,950 --> 00:40:19,350
but you can if you want to and angular

00:40:16,410 --> 00:40:21,090
and amber are the same way like they set

00:40:19,350 --> 00:40:23,640
things up for you and you don't have to

00:40:21,090 --> 00:40:25,260
deal with any of the like complicated

00:40:23,640 --> 00:40:27,150
 stuff and stuff like that and

00:40:25,260 --> 00:40:29,100
you can just start writing code and it's

00:40:27,150 --> 00:40:32,520
like an MVC framework so you're kind of

00:40:29,100 --> 00:40:36,150
used to that and then it lets you

00:40:32,520 --> 00:40:39,450
iteratively like learn about all the

00:40:36,150 --> 00:40:40,650
other components and parts and I found I

00:40:39,450 --> 00:40:43,080
personally found that very useful

00:40:40,650 --> 00:40:45,420
because I can be like okay I'm dealing

00:40:43,080 --> 00:40:47,790
with angular now I'm learning this and

00:40:45,420 --> 00:40:50,540
then be like hey I actually need needed

00:40:47,790 --> 00:40:52,970
to to do the processing a bit

00:40:50,540 --> 00:40:55,100
they let me go and check into that but I

00:40:52,970 --> 00:40:57,320
didn't need to do that part until after

00:40:55,100 --> 00:40:58,850
I needed it you know and that makes a

00:40:57,320 --> 00:41:00,620
big difference and I feel like that's a

00:40:58,850 --> 00:41:03,830
really good learning process where you

00:41:00,620 --> 00:41:05,540
can touch something or do something only

00:41:03,830 --> 00:41:08,630
when you need it not at the very

00:41:05,540 --> 00:41:10,460
beginning hey I was just wondering

00:41:08,630 --> 00:41:11,930
assuming that there could be a zener

00:41:10,460 --> 00:41:14,120
javascript what would be like an example

00:41:11,930 --> 00:41:16,340
of an element in that I think it would

00:41:14,120 --> 00:41:19,580
be a lot of it would be similar to

00:41:16,340 --> 00:41:22,670
because design of Python is very general

00:41:19,580 --> 00:41:24,470
it can be applied to a lot of things not

00:41:22,670 --> 00:41:30,620
just Python so I think you could use a

00:41:24,470 --> 00:41:32,480
lot of its from Python but otherwise I

00:41:30,620 --> 00:41:34,400
have to think about it I'm not able to

00:41:32,480 --> 00:41:35,810
give you that the answer right away it's

00:41:34,400 --> 00:41:39,440
a good question though you can find me

00:41:35,810 --> 00:41:42,290
later I don't think about it do you

00:41:39,440 --> 00:41:44,960
think angular has a long future or is it

00:41:42,290 --> 00:41:49,010
a winner-take-all game with reactant

00:41:44,960 --> 00:41:51,560
view and all those I think the four the

00:41:49,010 --> 00:41:53,240
four frameworks that I mentioned maybe

00:41:51,560 --> 00:41:54,470
with the exception of amber but I don't

00:41:53,240 --> 00:41:58,820
want to say that because I really like

00:41:54,470 --> 00:42:01,100
amber but those I think well it's I mean

00:41:58,820 --> 00:42:02,930
this is just speculation right but I

00:42:01,100 --> 00:42:05,960
feel like those are mature enough and

00:42:02,930 --> 00:42:09,500
like have the support and everything I

00:42:05,960 --> 00:42:12,530
like backed by companies I think that

00:42:09,500 --> 00:42:15,050
they should be staying around but I know

00:42:12,530 --> 00:42:18,530
that like angular did a really poor job

00:42:15,050 --> 00:42:24,080
of of how they did angular 1 to angular

00:42:18,530 --> 00:42:27,530
2 transition so sorry but yeah I think

00:42:24,080 --> 00:42:29,120
angular it's it's quite widely used and

00:42:27,530 --> 00:42:33,740
like I said it's you know it's backed by

00:42:29,120 --> 00:42:35,690
Google so I think those are it's a

00:42:33,740 --> 00:42:38,210
common concern just like with the sea of

00:42:35,690 --> 00:42:41,870
frameworks but I feel like those are so

00:42:38,210 --> 00:42:43,280
big right now that they should be around

00:42:41,870 --> 00:42:46,490
for a while but then again you don't

00:42:43,280 --> 00:42:49,250
know like if some new JavaScript

00:42:46,490 --> 00:42:51,350
features will come out or like we'll end

00:42:49,250 --> 00:42:53,810
up doing things way differently in five

00:42:51,350 --> 00:42:55,670
years and those will become obsolete but

00:42:53,810 --> 00:42:59,210
you know that stuff plagues any

00:42:55,670 --> 00:43:01,190
framework Django as well you know okay

00:42:59,210 --> 00:43:01,700
thank you so much for the talk and

00:43:01,190 --> 00:43:02,350
here's

00:43:01,700 --> 00:43:09,969
cookie

00:43:02,350 --> 00:43:09,969

YouTube URL: https://www.youtube.com/watch?v=2KrClg7UCVA


