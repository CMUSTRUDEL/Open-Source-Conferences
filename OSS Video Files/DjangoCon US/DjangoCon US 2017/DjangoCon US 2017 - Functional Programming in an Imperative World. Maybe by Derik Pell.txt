Title: DjangoCon US 2017 - Functional Programming in an Imperative World. Maybe by Derik Pell
Publication date: 2017-09-07
Playlist: DjangoCon US 2017
Description: 
	DjangoCon US 2017 - Functional Programming in an Imperative World. Maybe by Derik Pell

Let’s start by looking at the core concepts that differentiate FP from the OO / imperative style most programmers are familiar with. Along the way I’ll introduce you to:

1. Immutable data structures. Having data structures that don’t change makes your code safer, especially when dealing with concurrency and parallelism, but they require you to approach solutions in a different way than you would with mutable data.

2. “Pure” functions. Pure, or idempotent, functions do not mutate state or cause other kinds of side effects. As a result, you are guaranteed that every time you call a function with the same parameters, you will always get the same value.

3. Recursion: While recursion is something most of us know about, it’s not something we tend to use often in imperative programming, and with good reason. Nonetheless, it’s a worth knowing about it’s various forms.

4. Function composition. When you have pure functions that handle only one task, you can build larger, more complex and more beneficial programs by composing functions together to form new functions.

5. First class functions: passing around functions as parameters and return values, just like any other object.

6. The holy trinity: map, reduce, filter. These three functions are the work horses of FP, helping us manipulate and transform data quickly and elegantly.

FP in python

Now, let’s take a look at how we can or cannot apply these concepts in python.

1. While most data structures in python are mutable, tuples are a built in immutable data structure that we have at our disposal. We’ll see that tuples have a solid place in python, but they’re not as easy to work with as we might like.

2. Recursion isn’t really well developed in python (on purpose) so let’s take a look at it’s pitfalls and how to avoid them.

3. Function composition is something you probably already do some in python and perhaps don’t even know it.

4. The trinity:

Filter is easy, we just call it “list comprehension”

Reduce. Let’s try to get beyond flattening nested lists and doing tricks with math.

Map. You probably don’t use this enough in python so let’s see if we can change that.

FP is great! Maybe.

Now that we’ve seen how FP can be used, we really need to decide if it should be used. Python is not a functional programming language, despite the tools it has. We’ve talked about some of the technical drawbacks to these tools, but we also need to decide if working in an FP paradigm is right for our work environment. We’ll look at some examples of where running into FP can be jarring and talk about the additional cognitive load on co-workers who aren’t used to seeing these tools in place.

This talk was presented at: https://2017.djangocon.us/talks/functional-programming-in-an-imperative-world-maybe/

LINKS:
Follow Derik Pell 👇
On Twitter: https://twitter.com/_gignosko_
Official homepage: http://blog.gignosko.me
Github: https://github.com/gignosko/

Follow DjangCon US 👇
https://twitter.com/djangocon

Follow DEFNA 👇
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:18,700
[Music]

00:00:13,800 --> 00:00:21,310
everybody thanks I appreciate it

00:00:18,700 --> 00:00:24,340
so my name is Derrick Bell I'm an

00:00:21,310 --> 00:00:29,169
engineer at Emma email marketing that's

00:00:24,340 --> 00:00:31,810
me on github and Twitter actually if you

00:00:29,169 --> 00:00:34,540
go out to my github if you go out to

00:00:31,810 --> 00:00:36,760
that URL to the Django con 2017

00:00:34,540 --> 00:00:38,980
this is my entire presentation is going

00:00:36,760 --> 00:00:40,960
to is being done in in a in a Jupiter

00:00:38,980 --> 00:00:42,670
notebook and I've uploaded it to github

00:00:40,960 --> 00:00:46,630
so if you can't see the slide you can

00:00:42,670 --> 00:00:48,490
pull it up in github and follow along it

00:00:46,630 --> 00:00:51,220
won't run the code and github but you

00:00:48,490 --> 00:00:55,690
can look at it all clone it run it

00:00:51,220 --> 00:00:57,490
Python three quick show of hands how

00:00:55,690 --> 00:01:01,390
many people showed up hoping I was going

00:00:57,490 --> 00:01:02,770
to explain monads no sorry

00:01:01,390 --> 00:01:04,869
as far as I know they're still just

00:01:02,770 --> 00:01:07,869
burritos so if you don't know what I'm

00:01:04,869 --> 00:01:09,729
talking about Google it anyway so what I

00:01:07,869 --> 00:01:12,159
want to do is talk a little bit about

00:01:09,729 --> 00:01:13,840
functional programming functional

00:01:12,159 --> 00:01:17,950
programming has become sort of the hot

00:01:13,840 --> 00:01:20,259
new buzzword right and coming from an

00:01:17,950 --> 00:01:22,929
object-oriented language like Python

00:01:20,259 --> 00:01:25,479
sometimes we might see functional

00:01:22,929 --> 00:01:26,979
programming is something mysterious I

00:01:25,479 --> 00:01:29,079
want to kind of break that up a little

00:01:26,979 --> 00:01:31,630
bit for you and introduce you to some of

00:01:29,079 --> 00:01:34,210
the tools that help functional

00:01:31,630 --> 00:01:36,579
programming you know do its job and

00:01:34,210 --> 00:01:43,090
recognize that most of these tools exist

00:01:36,579 --> 00:01:44,799
in Python not always to the best they're

00:01:43,090 --> 00:01:47,200
not always the best tool to use but

00:01:44,799 --> 00:01:49,869
they're all there and so I just want to

00:01:47,200 --> 00:01:51,819
sort of get everybody just an overview

00:01:49,869 --> 00:01:54,520
of what functional programming is right

00:01:51,819 --> 00:01:56,469
but let's why would we use function

00:01:54,520 --> 00:01:57,880
programming why would we stop talking

00:01:56,469 --> 00:02:00,249
about object-oriented programming and

00:01:57,880 --> 00:02:01,630
look at this new style of programming

00:02:00,249 --> 00:02:04,119
well functional programming is very

00:02:01,630 --> 00:02:06,039
expressive as we will see through some

00:02:04,119 --> 00:02:09,039
of the code examples you can do a lot

00:02:06,039 --> 00:02:11,319
with a very little bit of code it can

00:02:09,039 --> 00:02:13,750
you can just very much you can shrink

00:02:11,319 --> 00:02:15,880
your code base pretty considerably in

00:02:13,750 --> 00:02:18,280
the right places it can be very

00:02:15,880 --> 00:02:21,790
efficient things run really quickly when

00:02:18,280 --> 00:02:23,890
your language actively supports

00:02:21,790 --> 00:02:26,500
functional programming paradigm and

00:02:23,890 --> 00:02:26,710
we'll see some places in Python where he

00:02:26,500 --> 00:02:28,390
does

00:02:26,710 --> 00:02:31,710
that very well some places where it

00:02:28,390 --> 00:02:33,900
doesn't quite so well it can be safer

00:02:31,710 --> 00:02:36,190
hyphenated that on purpose to sort of

00:02:33,900 --> 00:02:38,800
emphasize the fact that it's still not

00:02:36,190 --> 00:02:40,660
safe like there's still problems but it

00:02:38,800 --> 00:02:42,640
still it it can be safer it can't

00:02:40,660 --> 00:02:43,930
overcome a lot of the problems a lot of

00:02:42,640 --> 00:02:47,590
the bugs that we see in day to day

00:02:43,930 --> 00:02:49,090
object-oriented programming and it's

00:02:47,590 --> 00:02:51,030
easier to work with concurrent and

00:02:49,090 --> 00:02:53,770
parallel programming we won't actually

00:02:51,030 --> 00:02:55,870
directly dig into that but that's really

00:02:53,770 --> 00:02:57,700
the sort of the reason that functional

00:02:55,870 --> 00:02:59,440
programming has become so popular the

00:02:57,700 --> 00:03:01,750
last several years as we've stopped

00:02:59,440 --> 00:03:03,910
getting core processors that can go

00:03:01,750 --> 00:03:07,390
faster and faster and instead using more

00:03:03,910 --> 00:03:10,570
and more cores being able to effectively

00:03:07,390 --> 00:03:14,020
take our code and spread that across a

00:03:10,570 --> 00:03:16,090
couple different cores is is the next

00:03:14,020 --> 00:03:18,100
step in making our our applications run

00:03:16,090 --> 00:03:22,150
faster functional programming can help

00:03:18,100 --> 00:03:24,970
lead into that but what is functional

00:03:22,150 --> 00:03:28,780
programming it's really just a style of

00:03:24,970 --> 00:03:31,270
programming that utilizes pure functions

00:03:28,780 --> 00:03:35,290
which are functions that don't have side

00:03:31,270 --> 00:03:37,000
effects and it uses those functions to

00:03:35,290 --> 00:03:38,410
transform data so a functional

00:03:37,000 --> 00:03:40,980
programming actually thinks about data

00:03:38,410 --> 00:03:42,340
in a very different way than

00:03:40,980 --> 00:03:44,680
object-oriented programming

00:03:42,340 --> 00:03:47,500
object-oriented programming we hide our

00:03:44,680 --> 00:03:49,390
data away and we're very particular

00:03:47,500 --> 00:03:50,620
about how we use it and whatever and who

00:03:49,390 --> 00:03:52,570
can access it and that sort of thing

00:03:50,620 --> 00:03:55,000
functional programming is a more open

00:03:52,570 --> 00:03:57,520
data model it's like no like there's no

00:03:55,000 --> 00:03:59,620
need to hide your data away let's you

00:03:57,520 --> 00:04:01,780
know take it and work on it in a more

00:03:59,620 --> 00:04:03,520
mathematical sense that's where we have

00:04:01,780 --> 00:04:05,350
these we try to have pure functions

00:04:03,520 --> 00:04:07,180
things that don't have these side

00:04:05,350 --> 00:04:10,240
effects because they don't really they

00:04:07,180 --> 00:04:11,530
don't always make sense to have side

00:04:10,240 --> 00:04:13,600
effects like in the middle of your code

00:04:11,530 --> 00:04:15,220
on yeah on the IO boundaries of course

00:04:13,600 --> 00:04:16,660
you have to have side effects you have

00:04:15,220 --> 00:04:18,220
to write to a database print to a screen

00:04:16,660 --> 00:04:19,810
ring from a database that type of thing

00:04:18,220 --> 00:04:21,910
but in the middle of your code there's a

00:04:19,810 --> 00:04:23,770
lot of places where we do side-effects

00:04:21,910 --> 00:04:25,360
where we don't necessarily have to and

00:04:23,770 --> 00:04:26,920
functional programming is a way of

00:04:25,360 --> 00:04:28,510
thinking that helps you sort of reduce

00:04:26,920 --> 00:04:31,290
those because a lot of times those side

00:04:28,510 --> 00:04:34,300
effects are places where you have bugs

00:04:31,290 --> 00:04:35,710
so what I want to do though is start

00:04:34,300 --> 00:04:37,540
looking through some of the tools that

00:04:35,710 --> 00:04:39,370
help you get to functional programming

00:04:37,540 --> 00:04:40,830
there's like functional programming is

00:04:39,370 --> 00:04:43,300
not

00:04:40,830 --> 00:04:44,770
it's like saying you know if you were to

00:04:43,300 --> 00:04:46,540
explain object-oriented programming you

00:04:44,770 --> 00:04:48,730
might start with okay this is how you

00:04:46,540 --> 00:04:51,100
build an object but an object building

00:04:48,730 --> 00:04:52,960
an object or a class is not the totality

00:04:51,100 --> 00:04:54,790
of object-oriented programming in the

00:04:52,960 --> 00:04:56,410
same way there's not one part a

00:04:54,790 --> 00:04:58,570
functional programming it's really just

00:04:56,410 --> 00:05:02,560
a set of tools and the mindset on how

00:04:58,570 --> 00:05:05,520
you use them so with that let's start

00:05:02,560 --> 00:05:09,910
looking at the tools the first one is

00:05:05,520 --> 00:05:11,680
higher-order functions if you've never

00:05:09,910 --> 00:05:14,320
come across this phrase before and a lot

00:05:11,680 --> 00:05:16,060
of this stuff you guys may have seen you

00:05:14,320 --> 00:05:17,890
just may not realize that it is sort of

00:05:16,060 --> 00:05:20,350
like hand-in-hand with a with more

00:05:17,890 --> 00:05:22,540
functional thinking but higher-order

00:05:20,350 --> 00:05:25,210
functions just means that functions get

00:05:22,540 --> 00:05:27,700
treated like first-class citizens they

00:05:25,210 --> 00:05:29,950
can be passed they can be passed to

00:05:27,700 --> 00:05:31,690
other functions as parameters they can

00:05:29,950 --> 00:05:33,670
be returned from other functions as

00:05:31,690 --> 00:05:36,340
values and they can be stored in

00:05:33,670 --> 00:05:38,740
variables so you know they're just like

00:05:36,340 --> 00:05:43,630
any other piece of data in your

00:05:38,740 --> 00:05:47,830
application so let's take a couple of

00:05:43,630 --> 00:05:49,090
look at a couple of examples so here is

00:05:47,830 --> 00:05:51,130
something that sort of real-world issue

00:05:49,090 --> 00:05:56,860
this kind of thing quite a bit at work

00:05:51,130 --> 00:05:58,420
we're we need to pack we we will make a

00:05:56,860 --> 00:05:59,860
function that knows how to talk to our

00:05:58,420 --> 00:06:02,020
database it knows how to make the

00:05:59,860 --> 00:06:03,310
initialization to the database or maybe

00:06:02,020 --> 00:06:05,560
it's just pulling a connection off a

00:06:03,310 --> 00:06:07,600
pool or something or other but at the

00:06:05,560 --> 00:06:09,400
end of the day we have one function that

00:06:07,600 --> 00:06:12,610
knows how to grab a cursor to our

00:06:09,400 --> 00:06:14,800
database then we have all these other

00:06:12,610 --> 00:06:18,580
types of functions that need that cursor

00:06:14,800 --> 00:06:20,680
so we may have inserts that will return

00:06:18,580 --> 00:06:22,510
a row ID right but that's going to be

00:06:20,680 --> 00:06:24,550
different than using a query that's

00:06:22,510 --> 00:06:28,720
going to return you an entire result set

00:06:24,550 --> 00:06:31,240
right so instead of trying to make some

00:06:28,720 --> 00:06:34,150
instead of trying to make each

00:06:31,240 --> 00:06:36,100
individual either making each individual

00:06:34,150 --> 00:06:38,740
query like make its own connection to

00:06:36,100 --> 00:06:40,120
the database or make some function that

00:06:38,740 --> 00:06:42,910
connects to the database in a way that's

00:06:40,120 --> 00:06:44,440
versatile enough to like return a row ID

00:06:42,910 --> 00:06:46,390
in this situation that returned an

00:06:44,440 --> 00:06:49,540
entire row set and this results in this

00:06:46,390 --> 00:06:51,250
other what we do is we make a function

00:06:49,540 --> 00:06:53,770
that knows how to connect to the

00:06:51,250 --> 00:06:54,529
database grabs the cursor and then we

00:06:53,770 --> 00:06:58,699
make others

00:06:54,529 --> 00:07:00,289
functions that use that cursor and each

00:06:58,699 --> 00:07:02,299
individual function all it needs to know

00:07:00,289 --> 00:07:03,309
is how to use the cursor it doesn't need

00:07:02,299 --> 00:07:06,589
to know how to connect to the database

00:07:03,309 --> 00:07:08,929
so what we do is we have something along

00:07:06,589 --> 00:07:11,959
the lines of called database which takes

00:07:08,929 --> 00:07:14,479
a function somewhere in there makes the

00:07:11,959 --> 00:07:16,699
cursor and then as its return value it

00:07:14,479 --> 00:07:20,869
calls the function that we passed in

00:07:16,699 --> 00:07:22,099
giving it the cursor right so one

00:07:20,869 --> 00:07:26,149
example might be where you query a

00:07:22,099 --> 00:07:29,889
database we the query database function

00:07:26,149 --> 00:07:32,239
takes a cursor and then it knows how to

00:07:29,889 --> 00:07:33,769
loop over the result set or grab the

00:07:32,239 --> 00:07:35,509
result set and pass it back or whatever

00:07:33,769 --> 00:07:37,429
it needs to do it just depends on your

00:07:35,509 --> 00:07:43,039
business logic but the idea is that

00:07:37,429 --> 00:07:44,599
we're passing when we do this we're

00:07:43,039 --> 00:07:47,029
going to like this next line down here

00:07:44,599 --> 00:07:49,789
we're going to take the results we're

00:07:47,029 --> 00:07:51,769
going to get them by calling directly to

00:07:49,789 --> 00:07:54,469
the call a database function and passing

00:07:51,769 --> 00:07:58,429
it in the query database function right

00:07:54,469 --> 00:07:59,629
so we can see here call database is

00:07:58,429 --> 00:08:01,699
doing its thing to initialize the

00:07:59,629 --> 00:08:03,319
database then it gets a cursor and it

00:08:01,699 --> 00:08:05,569
passes that cursor into whatever

00:08:03,319 --> 00:08:07,639
function we called it with which in this

00:08:05,569 --> 00:08:10,429
case is query database so it's querying

00:08:07,639 --> 00:08:12,289
the database with our cursor right but

00:08:10,429 --> 00:08:15,639
if we also need to do something slightly

00:08:12,289 --> 00:08:19,219
different we can do something like

00:08:15,639 --> 00:08:22,279
returning a new the new row value right

00:08:19,219 --> 00:08:24,019
so we use we can reuse this same called

00:08:22,279 --> 00:08:26,449
database function because all it does is

00:08:24,019 --> 00:08:30,009
one thing work on the on the cursor and

00:08:26,449 --> 00:08:33,289
it just passes a cursory and whenever we

00:08:30,009 --> 00:08:34,879
call whenever we pass it a function it

00:08:33,289 --> 00:08:37,250
calls that function passes in the cursor

00:08:34,879 --> 00:08:38,769
right so that's something that that's

00:08:37,250 --> 00:08:43,420
the place where we use quite often

00:08:38,769 --> 00:08:48,199
passing a function into another function

00:08:43,420 --> 00:08:49,910
you can also return functions so this is

00:08:48,199 --> 00:08:51,889
a little more contrived example this is

00:08:49,910 --> 00:08:53,720
probably not something that would

00:08:51,889 --> 00:08:56,089
actually happen quite a bit but if for

00:08:53,720 --> 00:08:58,610
instance let's say you were you had some

00:08:56,089 --> 00:08:59,959
data coming in somewhere and you had it

00:08:58,610 --> 00:09:01,610
could potentially come in from several

00:08:59,959 --> 00:09:04,309
different sources right it could come in

00:09:01,610 --> 00:09:05,720
from a source that needs to read off s3

00:09:04,309 --> 00:09:07,470
or another source that needs to read out

00:09:05,720 --> 00:09:11,550
of a single database

00:09:07,470 --> 00:09:13,170
you can create these functions that do

00:09:11,550 --> 00:09:15,060
whatever they need to do like you have

00:09:13,170 --> 00:09:17,280
an s3 function that knows how to call

00:09:15,060 --> 00:09:19,380
out to a3 and retrieve the data over

00:09:17,280 --> 00:09:20,610
another function that like we just saw

00:09:19,380 --> 00:09:24,090
that calls out to the database and

00:09:20,610 --> 00:09:26,280
retrieves data from the database but you

00:09:24,090 --> 00:09:28,650
need to dynamically choose which of

00:09:26,280 --> 00:09:30,510
those functions based on the in the the

00:09:28,650 --> 00:09:32,130
source coming in so it's this is this

00:09:30,510 --> 00:09:35,940
essentially becomes like almost like a

00:09:32,130 --> 00:09:39,450
poor-man's polymorphism but it's a it's

00:09:35,940 --> 00:09:41,670
a pretty straightforward example what we

00:09:39,450 --> 00:09:44,670
do is we have a source that comes in in

00:09:41,670 --> 00:09:46,620
this case from s3 we ask for a new

00:09:44,670 --> 00:09:49,110
function by calling out to this give me

00:09:46,620 --> 00:09:51,240
a function give me a function takes our

00:09:49,110 --> 00:09:53,790
source and says okay well let's s3 I'm

00:09:51,240 --> 00:09:54,510
going to return this complex s3 function

00:09:53,790 --> 00:09:56,790
to you

00:09:54,510 --> 00:09:58,350
right it doesn't call it it doesn't do

00:09:56,790 --> 00:10:01,020
anything with it it's just passing the

00:09:58,350 --> 00:10:03,960
function back to us and then it's up to

00:10:01,020 --> 00:10:05,910
us once we get this new function it's up

00:10:03,960 --> 00:10:09,480
to us to actually call it with whatever

00:10:05,910 --> 00:10:12,540
we need to call it with right so we get

00:10:09,480 --> 00:10:15,390
this you know we're essentially saying

00:10:12,540 --> 00:10:16,770
here's we're coming in from s3 what do I

00:10:15,390 --> 00:10:18,870
do with it give me some function that I

00:10:16,770 --> 00:10:21,270
know how to handle that will know how to

00:10:18,870 --> 00:10:24,050
handle s3 or give me some function that

00:10:21,270 --> 00:10:26,070
will know how to handle sequel and

00:10:24,050 --> 00:10:29,040
because these are actually what it's

00:10:26,070 --> 00:10:31,230
passing back our functions we don't

00:10:29,040 --> 00:10:33,330
actually have to even do this where we

00:10:31,230 --> 00:10:35,190
assign it to a value and then call it

00:10:33,330 --> 00:10:37,980
you can just call it straight away this

00:10:35,190 --> 00:10:41,130
way right so we're calling into sorry

00:10:37,980 --> 00:10:42,570
calling into give me a function passing

00:10:41,130 --> 00:10:45,480
it in our source and whatever comes back

00:10:42,570 --> 00:10:46,680
we immediately call it just like we

00:10:45,480 --> 00:10:48,210
would any other function because that's

00:10:46,680 --> 00:10:51,900
all it is it's Pat it's just passing us

00:10:48,210 --> 00:10:53,370
back a function now anyone who's and

00:10:51,900 --> 00:10:55,320
like I said you may have seen this sort

00:10:53,370 --> 00:10:56,880
of stuff especially this could this type

00:10:55,320 --> 00:11:01,110
of thing we use a lot when we're doing

00:10:56,880 --> 00:11:07,440
JavaScript if you have to do that but we

00:11:01,110 --> 00:11:09,300
actually use it a lot in decorators who

00:11:07,440 --> 00:11:11,400
has worked with created looked at

00:11:09,300 --> 00:11:14,940
decorators a lot of people yeah oh and

00:11:11,400 --> 00:11:16,830
the entire room right so so yeah that's

00:11:14,940 --> 00:11:19,560
all a decorator really is you're passing

00:11:16,830 --> 00:11:21,050
in a function to a decorator function in

00:11:19,560 --> 00:11:23,610
this case decorated

00:11:21,050 --> 00:11:27,390
that has a nested function which we

00:11:23,610 --> 00:11:28,740
typically call wrapper and then it does

00:11:27,390 --> 00:11:31,020
whatever kind of work you need to do

00:11:28,740 --> 00:11:32,100
before calling your function whatever

00:11:31,020 --> 00:11:37,770
kind of work you need to do after

00:11:32,100 --> 00:11:38,760
calling your function so yeah this

00:11:37,770 --> 00:11:40,770
should be pretty straightforward to

00:11:38,760 --> 00:11:42,930
everybody who's ever used decorators

00:11:40,770 --> 00:11:46,050
before and that and that's all it is so

00:11:42,930 --> 00:11:47,550
without higher-order functions Python

00:11:46,050 --> 00:11:49,370
couldn't have decorators so we have to

00:11:47,550 --> 00:11:54,240
be able to pass those functions around

00:11:49,370 --> 00:11:56,190
and so you see it's not just usable in

00:11:54,240 --> 00:11:58,140
functional programming we use it all the

00:11:56,190 --> 00:12:00,750
time in object-oriented programming in

00:11:58,140 --> 00:12:02,280
certain languages and that's sort of the

00:12:00,750 --> 00:12:04,440
key is like functional programming isn't

00:12:02,280 --> 00:12:06,990
really a mystery it's really just a set

00:12:04,440 --> 00:12:10,680
of tools that you use in a slightly

00:12:06,990 --> 00:12:13,590
different way the next set of tools I

00:12:10,680 --> 00:12:15,030
wanna look at is our immutable data or

00:12:13,590 --> 00:12:17,790
immutable data structures now this is

00:12:15,030 --> 00:12:20,430
something we don't use as much in Python

00:12:17,790 --> 00:12:21,690
because mutable data is sort of the

00:12:20,430 --> 00:12:25,260
bread and butter of object-oriented

00:12:21,690 --> 00:12:27,120
programming but for immutable data it's

00:12:25,260 --> 00:12:28,110
a structure that never changes itself so

00:12:27,120 --> 00:12:30,120
like you have a list

00:12:28,110 --> 00:12:33,870
you don't actually add something new to

00:12:30,120 --> 00:12:36,870
the list instead your list can't be

00:12:33,870 --> 00:12:39,420
changed like you're sorry about that

00:12:36,870 --> 00:12:42,650
your list is sort of set in stone and

00:12:39,420 --> 00:12:44,610
we're looking a little bit about how you

00:12:42,650 --> 00:12:46,410
overcome that because that seems like a

00:12:44,610 --> 00:12:48,360
limitation right like you create a list

00:12:46,410 --> 00:12:50,880
you can't add to it you can't delete

00:12:48,360 --> 00:12:52,980
from it what good is it how do you make

00:12:50,880 --> 00:12:54,000
any changes what's you have to think

00:12:52,980 --> 00:12:56,100
about your list in a completely

00:12:54,000 --> 00:12:59,070
different way because whenever you make

00:12:56,100 --> 00:13:00,570
some update we're used to passing in a

00:12:59,070 --> 00:13:03,270
list adding something to it getting that

00:13:00,570 --> 00:13:05,190
list back with immutable data you don't

00:13:03,270 --> 00:13:07,170
do that you pass in a list if you add

00:13:05,190 --> 00:13:08,910
something to it you get a brand new list

00:13:07,170 --> 00:13:12,870
back it's a it's a completely different

00:13:08,910 --> 00:13:14,700
data structure same is same idea if you

00:13:12,870 --> 00:13:16,560
take something off the list you know you

00:13:14,700 --> 00:13:18,390
pass it in the list to a function it

00:13:16,560 --> 00:13:20,750
takes something off that list what you

00:13:18,390 --> 00:13:23,100
get back completely different list

00:13:20,750 --> 00:13:24,480
though that's a very safe way of

00:13:23,100 --> 00:13:25,770
handling things though that means that

00:13:24,480 --> 00:13:27,960
list isn't going to change out from

00:13:25,770 --> 00:13:29,460
under you right Emme bug how many times

00:13:27,960 --> 00:13:31,530
have we all done this track try to track

00:13:29,460 --> 00:13:32,880
down the bug where because we've passed

00:13:31,530 --> 00:13:34,410
off a list we don't realize that

00:13:32,880 --> 00:13:36,750
whatever function we're passing it to

00:13:34,410 --> 00:13:39,209
is mutating that list before it comes

00:13:36,750 --> 00:13:40,470
back to us well with immutable data

00:13:39,209 --> 00:13:42,779
structures you don't have to worry about

00:13:40,470 --> 00:13:44,639
that you can pass them a list they can

00:13:42,779 --> 00:13:47,930
do whatever they want to with it your

00:13:44,639 --> 00:13:51,240
list never changes their list it's

00:13:47,930 --> 00:13:52,319
adjusted to a new list now history we

00:13:51,240 --> 00:13:54,449
don't do this a lot because historically

00:13:52,319 --> 00:13:55,949
they have been very inefficient what you

00:13:54,449 --> 00:13:59,339
have to do is take that list it's

00:13:55,949 --> 00:14:01,230
sitting in memory the Opera the language

00:13:59,339 --> 00:14:02,970
has to then copy the entire list to a

00:14:01,230 --> 00:14:04,949
new part of memory so that you

00:14:02,970 --> 00:14:07,470
essentially have two lists it's very

00:14:04,949 --> 00:14:08,699
slow to do but there have been new data

00:14:07,470 --> 00:14:10,589
structures called persistent data

00:14:08,699 --> 00:14:12,689
structures that make this much more

00:14:10,589 --> 00:14:14,610
efficient if you download this I've got

00:14:12,689 --> 00:14:17,399
a link to persistent data structures to

00:14:14,610 --> 00:14:18,779
the description that Wikipedia I'm not

00:14:17,399 --> 00:14:20,939
going to dive into them but they're much

00:14:18,779 --> 00:14:22,829
more efficient at this sort of thing so

00:14:20,939 --> 00:14:25,980
it lets you use an immutable data

00:14:22,829 --> 00:14:28,199
structure without paying the additional

00:14:25,980 --> 00:14:32,459
cost of like all that copying over in

00:14:28,199 --> 00:14:35,430
memory if you're not familiar with the

00:14:32,459 --> 00:14:38,220
problem with mutable data structures so

00:14:35,430 --> 00:14:39,750
what and probably almost all of you have

00:14:38,220 --> 00:14:41,279
seen something like this this is like

00:14:39,750 --> 00:14:44,519
almost every language I've ever looked

00:14:41,279 --> 00:14:45,779
at has this sort of warning of this kind

00:14:44,519 --> 00:14:49,829
of thing where you create a list and

00:14:45,779 --> 00:14:52,230
then you create a second list you point

00:14:49,829 --> 00:14:53,550
a second list to the first list anytime

00:14:52,230 --> 00:14:55,079
you change that first list you've

00:14:53,550 --> 00:14:58,949
automatically changed that second list

00:14:55,079 --> 00:15:03,050
right so that's not a safe way of making

00:14:58,949 --> 00:15:06,600
sure your data store listing

00:15:03,050 --> 00:15:09,240
typically you can see here list one and

00:15:06,600 --> 00:15:10,589
list two they are the same thing they're

00:15:09,240 --> 00:15:13,290
basically the same list because what we

00:15:10,589 --> 00:15:17,220
have are two pointers to the same piece

00:15:13,290 --> 00:15:18,930
of memory and this can be a problem here

00:15:17,220 --> 00:15:20,100
in that sort of situation but you can

00:15:18,930 --> 00:15:23,189
also create some really interesting

00:15:20,100 --> 00:15:26,490
problems if you're not thinking about it

00:15:23,189 --> 00:15:28,740
so this is just a quick function that

00:15:26,490 --> 00:15:30,449
goes through takes a list of integers

00:15:28,740 --> 00:15:33,329
and then sums up that list right and

00:15:30,449 --> 00:15:35,279
gives you the results so if you pass in

00:15:33,329 --> 00:15:37,470
the list one two three three the

00:15:35,279 --> 00:15:39,620
summation of that is six but if

00:15:37,470 --> 00:15:42,750
somewhere in there you accidentally

00:15:39,620 --> 00:15:44,790
start appending to your list what you're

00:15:42,750 --> 00:15:46,750
going to get or some really weird

00:15:44,790 --> 00:15:48,910
results right

00:15:46,750 --> 00:15:50,980
you're in the middle of working your way

00:15:48,910 --> 00:15:53,199
through a list in a way that we do every

00:15:50,980 --> 00:15:54,579
day it's just a for-loop but somehow

00:15:53,199 --> 00:15:56,079
we've appended to that list in the

00:15:54,579 --> 00:15:58,509
middle of that loop and now our list is

00:15:56,079 --> 00:16:01,000
going to continue to grow add to this if

00:15:58,509 --> 00:16:03,310
clause in there because if I don't catch

00:16:01,000 --> 00:16:06,699
for a list of a certain size this will

00:16:03,310 --> 00:16:08,050
grow until I run out of memory so that's

00:16:06,699 --> 00:16:10,720
one of the things that we end up having

00:16:08,050 --> 00:16:13,509
to track down sometimes when we work

00:16:10,720 --> 00:16:16,959
with mutable data but if you work with

00:16:13,509 --> 00:16:19,839
immutable data a lot of those situations

00:16:16,959 --> 00:16:21,160
disappear so right here we're doing the

00:16:19,839 --> 00:16:23,139
same thing that we did above with a list

00:16:21,160 --> 00:16:24,339
right we're creating a tuple instead of

00:16:23,139 --> 00:16:27,720
we're creating a list we're creating a

00:16:24,339 --> 00:16:30,730
tuple adding some items to it and then

00:16:27,720 --> 00:16:32,529
creating another another tuple pointer

00:16:30,730 --> 00:16:33,879
to the same tuple right so we've got two

00:16:32,529 --> 00:16:37,180
pointers for the same tuple just like we

00:16:33,879 --> 00:16:39,160
did with the list above but now when we

00:16:37,180 --> 00:16:42,220
update the one tuple it does not update

00:16:39,160 --> 00:16:43,720
the second one because in Python

00:16:42,220 --> 00:16:46,449
whenever you try to update whenever you

00:16:43,720 --> 00:16:48,850
try to concatenate an item into a tuple

00:16:46,449 --> 00:16:51,579
you get back an entirely new data

00:16:48,850 --> 00:16:53,529
structure right so before we do the

00:16:51,579 --> 00:16:56,079
concatenation we look at these two tuple

00:16:53,529 --> 00:16:57,759
1 and tuple 2 they are the same after we

00:16:56,079 --> 00:16:59,290
do the concatenation they're no longer

00:16:57,759 --> 00:17:01,149
the same because Python has created a

00:16:59,290 --> 00:17:03,939
brand-new data structure for us it's a

00:17:01,149 --> 00:17:06,370
safe way to do it but it's slow because

00:17:03,939 --> 00:17:10,409
these were not created as persistent

00:17:06,370 --> 00:17:13,390
data structures and you can do you

00:17:10,409 --> 00:17:15,699
typically if we want an immutable data

00:17:13,390 --> 00:17:17,169
structure we go to a tuple you can do

00:17:15,699 --> 00:17:19,150
something along the same lines with

00:17:17,169 --> 00:17:21,220
pretty much any with lists or

00:17:19,150 --> 00:17:23,199
dictionaries you can use a deep copy and

00:17:21,220 --> 00:17:25,630
instead of actually just making two

00:17:23,199 --> 00:17:28,569
pointers you make a deep copy of the

00:17:25,630 --> 00:17:30,460
list that way when you when you change

00:17:28,569 --> 00:17:32,440
one it does not change the other because

00:17:30,460 --> 00:17:34,299
you start off with two different lists

00:17:32,440 --> 00:17:37,539
but again it's slow because it has to

00:17:34,299 --> 00:17:39,159
take that list copy it over in memory so

00:17:37,539 --> 00:17:40,510
those are some of the problems that we

00:17:39,159 --> 00:17:42,250
can see with immutable data that we can

00:17:40,510 --> 00:17:48,580
hopefully solve with more mutable data

00:17:42,250 --> 00:17:50,980
structures but working with immutable

00:17:48,580 --> 00:17:52,240
data structures means we have to start

00:17:50,980 --> 00:17:54,460
thinking about things slightly

00:17:52,240 --> 00:17:56,169
differently often like we don't want to

00:17:54,460 --> 00:17:59,970
do a for loop on an immutable

00:17:56,169 --> 00:18:03,780
list because it doesn't

00:17:59,970 --> 00:18:05,760
Luke quite as well it'll loop in in

00:18:03,780 --> 00:18:07,050
Python in a lot of functional

00:18:05,760 --> 00:18:08,820
programming languages though they just

00:18:07,050 --> 00:18:11,370
pulled a loop out of there because if

00:18:08,820 --> 00:18:13,530
you aren't mutating your list you don't

00:18:11,370 --> 00:18:17,160
necessarily need loops you can come up

00:18:13,530 --> 00:18:18,930
with other ways of looping of getting

00:18:17,160 --> 00:18:20,400
through everything in your list and one

00:18:18,930 --> 00:18:22,890
of those ways is recursion or the big

00:18:20,400 --> 00:18:25,740
way is recursion if you've never worked

00:18:22,890 --> 00:18:28,740
with recursion most of you probably I

00:18:25,740 --> 00:18:32,430
assume seen it the recursion is when you

00:18:28,740 --> 00:18:33,810
call a function from within itself it

00:18:32,430 --> 00:18:35,700
takes the like I said it takes the place

00:18:33,810 --> 00:18:37,110
of loops in many programming languages

00:18:35,700 --> 00:18:39,420
and we'll see that here in just a moment

00:18:37,110 --> 00:18:42,030
how we can use recursion instead of a

00:18:39,420 --> 00:18:44,580
loop the problem with recursion is that

00:18:42,030 --> 00:18:47,130
every time you make a call back to the

00:18:44,580 --> 00:18:48,630
function you add a frame to the call

00:18:47,130 --> 00:18:52,860
stack and that call set can grow and

00:18:48,630 --> 00:18:56,310
grow and grow in languages that embrace

00:18:52,860 --> 00:18:58,290
recursion they often do this thing

00:18:56,310 --> 00:19:01,980
called tail call optimization which lets

00:18:58,290 --> 00:19:04,470
you more efficiently do recursion

00:19:01,980 --> 00:19:05,790
without adding to the call stack but

00:19:04,470 --> 00:19:08,370
Python does not have hell call

00:19:05,790 --> 00:19:09,990
optimization Guido has if you've ever

00:19:08,370 --> 00:19:12,270
looked at it he's sort of famously come

00:19:09,990 --> 00:19:14,130
out against tail call optimization in

00:19:12,270 --> 00:19:16,020
Python because it really does it hides

00:19:14,130 --> 00:19:17,310
your stack trace what tail call

00:19:16,020 --> 00:19:19,050
optimization does is it

00:19:17,310 --> 00:19:21,300
instead of building up every stack

00:19:19,050 --> 00:19:23,190
anytime you call back if you if you do

00:19:21,300 --> 00:19:25,260
your recursive call properly it just

00:19:23,190 --> 00:19:27,180
overwrites the existing frame on your

00:19:25,260 --> 00:19:29,550
stack so that you don't build you just

00:19:27,180 --> 00:19:31,800
sort of keep reusing the same frame it's

00:19:29,550 --> 00:19:33,570
much more memory efficient but you do

00:19:31,800 --> 00:19:36,030
lose your call sack if something happens

00:19:33,570 --> 00:19:37,890
you know five or six calls deep you

00:19:36,030 --> 00:19:39,840
don't know exactly where it happened you

00:19:37,890 --> 00:19:42,120
don't have all the context for it

00:19:39,840 --> 00:19:43,160
so we probably will never get tail call

00:19:42,120 --> 00:19:45,870
optimizations

00:19:43,160 --> 00:19:49,470
but regardless let's take a quick look

00:19:45,870 --> 00:19:51,960
at recursion so this is a recursive

00:19:49,470 --> 00:19:54,630
version of the summation list that we

00:19:51,960 --> 00:19:56,340
did above so insta bug we're giving it

00:19:54,630 --> 00:19:58,740
the list and looping through the list

00:19:56,340 --> 00:20:01,230
here what we're doing is we're giving it

00:19:58,740 --> 00:20:04,380
the list and then instead of looping

00:20:01,230 --> 00:20:07,950
through each item we send the list back

00:20:04,380 --> 00:20:10,650
into the function itself so the function

00:20:07,950 --> 00:20:12,510
in this case has to take a list but it

00:20:10,650 --> 00:20:13,770
also has to take the summation because

00:20:12,510 --> 00:20:15,540
we are

00:20:13,770 --> 00:20:17,460
recalling back into itself it's harder

00:20:15,540 --> 00:20:19,050
to keep track of the state you have to

00:20:17,460 --> 00:20:22,080
pass this you typically end up having to

00:20:19,050 --> 00:20:26,460
pass the state back into the function

00:20:22,080 --> 00:20:28,710
along with whatever like well in this

00:20:26,460 --> 00:20:32,190
case we're passing the list in we also

00:20:28,710 --> 00:20:33,900
are passing in the cumulative sum there

00:20:32,190 --> 00:20:35,310
are ways depending on what algorithm

00:20:33,900 --> 00:20:36,600
you're using they're getting through

00:20:35,310 --> 00:20:39,720
there ways to do this without having to

00:20:36,600 --> 00:20:43,050
pass the state back in but in this case

00:20:39,720 --> 00:20:46,250
we are for recursive functions you

00:20:43,050 --> 00:20:49,500
almost always have to have a base case

00:20:46,250 --> 00:20:51,540
base case is the point that tells the

00:20:49,500 --> 00:20:54,030
recursive function stop recursing we're

00:20:51,540 --> 00:20:56,220
done just return a value don't call back

00:20:54,030 --> 00:20:58,470
into the function again so in this case

00:20:56,220 --> 00:21:00,360
we're done when the list is empty when

00:20:58,470 --> 00:21:02,370
there's no when it's just an empty list

00:21:00,360 --> 00:21:05,010
we have summed up everything in the list

00:21:02,370 --> 00:21:08,370
just return the summation if that's not

00:21:05,010 --> 00:21:10,860
the case what we do is we pop the last

00:21:08,370 --> 00:21:14,310
item off the list add it to the current

00:21:10,860 --> 00:21:20,270
sum as the new sum return everything

00:21:14,310 --> 00:21:23,220
back into the loop again all right so

00:21:20,270 --> 00:21:24,570
that's our sum last our function and

00:21:23,220 --> 00:21:28,410
here we're calling it we're calling it

00:21:24,570 --> 00:21:31,260
with a list one two three we get our

00:21:28,410 --> 00:21:33,870
result of six now we still have the same

00:21:31,260 --> 00:21:36,210
issue that we had with the iterative

00:21:33,870 --> 00:21:38,310
approach which is if this list gets

00:21:36,210 --> 00:21:40,830
changed while we're doing the summation

00:21:38,310 --> 00:21:42,330
it's going to you know mess up our

00:21:40,830 --> 00:21:42,750
recursive calls this does not fix that

00:21:42,330 --> 00:21:45,020
problem

00:21:42,750 --> 00:21:50,430
that's a mutable data structure problem

00:21:45,020 --> 00:21:52,230
but if you were to try to solve you know

00:21:50,430 --> 00:21:53,670
you know try to implement this in a more

00:21:52,230 --> 00:21:54,870
functional language this is the kind of

00:21:53,670 --> 00:21:56,880
thing you would do you would loop

00:21:54,870 --> 00:22:00,900
through it using a recursive call rather

00:21:56,880 --> 00:22:05,570
than an actual for loop now one of the

00:22:00,900 --> 00:22:09,750
problems with recursion inside Python is

00:22:05,570 --> 00:22:12,000
if you try to go too big if you try to

00:22:09,750 --> 00:22:14,100
recurse too many times you can get a

00:22:12,000 --> 00:22:15,210
recursion error now in a lot of

00:22:14,100 --> 00:22:17,070
languages you don't have something

00:22:15,210 --> 00:22:20,610
called a recursion error Python has

00:22:17,070 --> 00:22:22,410
built in a limit on the number of frames

00:22:20,610 --> 00:22:25,440
you can put in a stack which by default

00:22:22,410 --> 00:22:26,460
is a thousand you can up that if you

00:22:25,440 --> 00:22:29,190
need to

00:22:26,460 --> 00:22:31,050
but in its sooner or later you're gonna

00:22:29,190 --> 00:22:32,520
run out of memory if you if your list is

00:22:31,050 --> 00:22:34,110
big enough if you recurse deep enough

00:22:32,520 --> 00:22:35,820
you're gonna run out of memory because

00:22:34,110 --> 00:22:38,250
you know the language has to keep track

00:22:35,820 --> 00:22:39,990
of everything on the stack that's where

00:22:38,250 --> 00:22:42,480
you get a stack overflow so in most

00:22:39,990 --> 00:22:44,940
other languages if they don't limit your

00:22:42,480 --> 00:22:46,740
recursion depth like Python does then

00:22:44,940 --> 00:22:47,940
you'll just recur and keep going and

00:22:46,740 --> 00:22:49,200
going until you run out of memory and

00:22:47,940 --> 00:22:51,410
get a stack overflow

00:22:49,200 --> 00:22:53,610
so without tail call optimization

00:22:51,410 --> 00:22:56,730
recursion is actually really dangerous

00:22:53,610 --> 00:22:59,900
to do so you don't see it a lot I've

00:22:56,730 --> 00:23:02,430
never seen it in the wild in Python and

00:22:59,900 --> 00:23:05,640
there's a really good reason so if you

00:23:02,430 --> 00:23:07,740
don't know how deep your your recursion

00:23:05,640 --> 00:23:10,560
is going to go come up with a different

00:23:07,740 --> 00:23:12,180
solution you can always use an iterative

00:23:10,560 --> 00:23:13,440
solution there's there's there are no

00:23:12,180 --> 00:23:15,930
problems you can solve with a recursion

00:23:13,440 --> 00:23:18,810
that you can't solve with just a loop in

00:23:15,930 --> 00:23:23,580
some capacity so in Python we definitely

00:23:18,810 --> 00:23:27,540
tend to favor loops of a recursion so

00:23:23,580 --> 00:23:29,460
anyway you'll just some of the ways that

00:23:27,540 --> 00:23:30,840
recursion gets used and that's how we

00:23:29,460 --> 00:23:33,780
kind of get around some of the problems

00:23:30,840 --> 00:23:35,280
of mutable data and I don't think I

00:23:33,780 --> 00:23:36,720
pointed that out well but essentially

00:23:35,280 --> 00:23:39,450
what you're doing is you're taking that

00:23:36,720 --> 00:23:41,280
list and sending a new version of the

00:23:39,450 --> 00:23:42,930
list back through the recursive loop

00:23:41,280 --> 00:23:45,540
each time in this case we're popping the

00:23:42,930 --> 00:23:47,370
last item off but in other situations

00:23:45,540 --> 00:23:48,870
you a lot of a lot of functional

00:23:47,370 --> 00:23:50,340
languages have this concept of the head

00:23:48,870 --> 00:23:51,630
and the tail of the list the head of the

00:23:50,340 --> 00:23:53,370
list is the first item the tail is

00:23:51,630 --> 00:23:55,470
everything else and a lot of recursive

00:23:53,370 --> 00:23:58,620
calls will use the head and pass the

00:23:55,470 --> 00:24:04,560
tail back along so that's sort of

00:23:58,620 --> 00:24:07,910
essentially what we're doing here so

00:24:04,560 --> 00:24:09,720
yeah those are if you've looked into

00:24:07,910 --> 00:24:11,130
functional programming just sort of at a

00:24:09,720 --> 00:24:13,020
surface level those are probably the

00:24:11,130 --> 00:24:16,580
minor players that we've gone over so

00:24:13,020 --> 00:24:19,350
far the big three the Holy Trinity of

00:24:16,580 --> 00:24:24,180
functional programming are map filter

00:24:19,350 --> 00:24:26,430
and reduce and this is where the more

00:24:24,180 --> 00:24:28,920
functional style really shines out well

00:24:26,430 --> 00:24:30,990
and fun in program in Python if you've

00:24:28,920 --> 00:24:32,760
never used any of these in Python if you

00:24:30,990 --> 00:24:35,430
get nothing else out of this talk I hope

00:24:32,760 --> 00:24:37,290
you can walk away with a sense of I need

00:24:35,430 --> 00:24:38,670
to check into map filter and reduce and

00:24:37,290 --> 00:24:39,770
figure out how to use them because they

00:24:38,670 --> 00:24:41,300
make your code

00:24:39,770 --> 00:24:46,730
once you get used to how they work

00:24:41,300 --> 00:24:51,050
they're beautiful so a lot of times

00:24:46,730 --> 00:24:53,150
though to really use these tools map

00:24:51,050 --> 00:24:55,580
filter and reduce we a lot of times end

00:24:53,150 --> 00:24:58,370
up using lambdas lambdas are anonymous

00:24:55,580 --> 00:25:00,020
functions and that really just means

00:24:58,370 --> 00:25:01,760
it's a function that doesn't that we

00:25:00,020 --> 00:25:03,980
don't name right instead of saying def

00:25:01,760 --> 00:25:08,900
you know call dB

00:25:03,980 --> 00:25:12,890
we just have we well this is the this is

00:25:08,900 --> 00:25:15,890
how it falls out in Python you use the

00:25:12,890 --> 00:25:17,900
keyword lambda you pass it whatever

00:25:15,890 --> 00:25:20,179
variables you need in this case x and y

00:25:17,900 --> 00:25:21,980
and then there's a colon that separates

00:25:20,179 --> 00:25:24,559
the variables from the body

00:25:21,980 --> 00:25:27,620
all right lambdas are used for typically

00:25:24,559 --> 00:25:28,970
one-liners if your lambda gets much more

00:25:27,620 --> 00:25:31,130
complex than you can fit on one line

00:25:28,970 --> 00:25:33,650
you're probably better off just making a

00:25:31,130 --> 00:25:35,750
named function and going to the typical

00:25:33,650 --> 00:25:37,730
route there but lambdas are really good

00:25:35,750 --> 00:25:40,160
for these in line one offs where it

00:25:37,730 --> 00:25:42,140
doesn't even make sense to make an

00:25:40,160 --> 00:25:44,030
entire function just to add two numbers

00:25:42,140 --> 00:25:47,570
together right you just throw it into a

00:25:44,030 --> 00:25:49,730
lambda in this case we're assigning that

00:25:47,570 --> 00:25:50,960
lambda to a variable name some we call

00:25:49,730 --> 00:25:53,090
some just like we would any other

00:25:50,960 --> 00:25:56,750
function and it sums up whatever we give

00:25:53,090 --> 00:25:59,059
it right you don't usually use lambdas

00:25:56,750 --> 00:26:02,690
this particular way but you do use them

00:25:59,059 --> 00:26:04,190
quite a bit in that filter and reduce so

00:26:02,690 --> 00:26:07,640
let's start looking at some of those

00:26:04,190 --> 00:26:11,570
three tools filter does exactly what you

00:26:07,640 --> 00:26:13,309
think it would do it you pass in a

00:26:11,570 --> 00:26:15,590
filtering function which we'll go over

00:26:13,309 --> 00:26:20,350
in a moment and a collection to operate

00:26:15,590 --> 00:26:22,790
on the filter the actual filter function

00:26:20,350 --> 00:26:26,330
takes whatever filtering function you

00:26:22,790 --> 00:26:29,360
pass in and applies it to every item in

00:26:26,330 --> 00:26:30,920
the list one at a time so it takes the

00:26:29,360 --> 00:26:33,530
first item runs it through your

00:26:30,920 --> 00:26:35,420
filtering function the filtering

00:26:33,530 --> 00:26:38,860
function needs to evaluate to either

00:26:35,420 --> 00:26:42,080
true or false so if it evaluates to true

00:26:38,860 --> 00:26:44,510
the filter will then take that item out

00:26:42,080 --> 00:26:46,970
of the list and add it to your new list

00:26:44,510 --> 00:26:48,470
if it evaluates to false that item does

00:26:46,970 --> 00:26:50,690
not get added to your new list

00:26:48,470 --> 00:26:52,790
technically map filter and reduce all

00:26:50,690 --> 00:26:53,570
return iterators now in Python 2 they

00:26:52,790 --> 00:26:55,040
would return

00:26:53,570 --> 00:26:57,770
but now they're returning iterators

00:26:55,040 --> 00:26:59,180
which is much better that way you can

00:26:57,770 --> 00:27:00,650
kind of evaluate that as you want it

00:26:59,180 --> 00:27:04,520
doesn't build your entire list at one

00:27:00,650 --> 00:27:05,810
time it yields back one item at a time

00:27:04,520 --> 00:27:11,180
so you can loop through it however you

00:27:05,810 --> 00:27:13,370
need to but essentially if you take

00:27:11,180 --> 00:27:14,900
something like that list if we look at

00:27:13,370 --> 00:27:17,960
our filter right here we're going to

00:27:14,900 --> 00:27:20,450
create a new list iterator using filter

00:27:17,960 --> 00:27:23,300
we pass it in a lambda that's basically

00:27:20,450 --> 00:27:25,970
just saying looking to whether or not

00:27:23,300 --> 00:27:29,240
the value that we're looking at is it

00:27:25,970 --> 00:27:32,540
even our HOD right if it's even then we

00:27:29,240 --> 00:27:34,850
assume modulo two is equal to zero then

00:27:32,540 --> 00:27:36,380
it gets added into the iterator modulo

00:27:34,850 --> 00:27:38,240
two doesn't equal zero it doesn't get

00:27:36,380 --> 00:27:41,150
added to the iterator we're passing it

00:27:38,240 --> 00:27:46,430
list one as the collection that we want

00:27:41,150 --> 00:27:50,180
to iterate over and so it's filtered out

00:27:46,430 --> 00:27:53,560
all of our I guess you can say it's

00:27:50,180 --> 00:27:56,300
filtered out all the non all the odd

00:27:53,560 --> 00:27:59,750
integers it's filtered in the even

00:27:56,300 --> 00:28:02,360
integers I don't know semantics but any

00:27:59,750 --> 00:28:04,460
case that's what filter does you can

00:28:02,360 --> 00:28:06,590
pass it to lambda like this or you can

00:28:04,460 --> 00:28:09,170
do something much more complex as long

00:28:06,590 --> 00:28:10,880
as it the fill as long as the filtering

00:28:09,170 --> 00:28:12,920
function ends up evaluating to true or

00:28:10,880 --> 00:28:17,360
false so filter knows whether or not to

00:28:12,920 --> 00:28:21,110
add that value into the new list the

00:28:17,360 --> 00:28:22,520
same kind of thing is true for map map

00:28:21,110 --> 00:28:24,470
takes a mapping function and a

00:28:22,520 --> 00:28:27,260
collection to operate on and then it

00:28:24,470 --> 00:28:30,230
applies that function to every item in

00:28:27,260 --> 00:28:32,720
the collection one at a time it does not

00:28:30,230 --> 00:28:35,300
filter out any items it is not you know

00:28:32,720 --> 00:28:37,220
if you pass in a ten item list you will

00:28:35,300 --> 00:28:40,370
get back at ten item list or you should

00:28:37,220 --> 00:28:44,540
get back at ten item list so but what it

00:28:40,370 --> 00:28:46,490
does is it says you know I have this

00:28:44,540 --> 00:28:48,020
whole list of users and I want to

00:28:46,490 --> 00:28:50,150
transform them in this particular way

00:28:48,020 --> 00:28:52,910
you can use map and give it whatever

00:28:50,150 --> 00:28:55,070
trance whatever a function that's going

00:28:52,910 --> 00:28:56,480
to transform your list of users and then

00:28:55,070 --> 00:28:57,830
give it the list and that will go

00:28:56,480 --> 00:29:00,950
through and do the transformation for

00:28:57,830 --> 00:29:02,240
you so you it's a simpler way of you

00:29:00,950 --> 00:29:04,040
just don't have to call it all in a loop

00:29:02,240 --> 00:29:06,410
right like normally if you're not using

00:29:04,040 --> 00:29:06,740
map you might you know just for every

00:29:06,410 --> 00:29:09,169
item

00:29:06,740 --> 00:29:13,490
in this list call out to this function

00:29:09,169 --> 00:29:15,380
manually map does it for you map is

00:29:13,490 --> 00:29:18,679
actually a lot more efficient at it it

00:29:15,380 --> 00:29:19,820
will run a lot faster so map is if you

00:29:18,679 --> 00:29:21,309
have one of those sort of simple

00:29:19,820 --> 00:29:23,690
situations where you just need to pass

00:29:21,309 --> 00:29:25,909
every item in a list one at a time to a

00:29:23,690 --> 00:29:30,440
function the map is a really good

00:29:25,909 --> 00:29:32,330
alternative to using a for loop and same

00:29:30,440 --> 00:29:36,370
kind of thing here we're calling Matt

00:29:32,330 --> 00:29:38,840
we're using list one we're calling map

00:29:36,370 --> 00:29:40,610
we're passing at this lambda this

00:29:38,840 --> 00:29:42,770
anonymous function that all it does is

00:29:40,610 --> 00:29:45,320
take whatever item I give it and

00:29:42,770 --> 00:29:48,260
multiply it by two and then put it back

00:29:45,320 --> 00:29:50,090
in the new list right so there we're

00:29:48,260 --> 00:29:52,789
taking list 1 and we've multiplied it by

00:29:50,090 --> 00:29:55,039
two every item in there by two and get

00:29:52,789 --> 00:29:57,710
back a new list and you'll notice even

00:29:55,039 --> 00:30:00,190
though we did a filtering on the firt on

00:29:57,710 --> 00:30:02,570
the list one earlier we didn't actually

00:30:00,190 --> 00:30:06,110
adjust list one at all we got a brand

00:30:02,570 --> 00:30:08,480
new list back again because this is

00:30:06,110 --> 00:30:10,340
happening because these functions were

00:30:08,480 --> 00:30:11,750
built map filter and reduce were built

00:30:10,340 --> 00:30:13,760
to work this way they're much more

00:30:11,750 --> 00:30:15,890
efficient than if we tried to reproduce

00:30:13,760 --> 00:30:20,120
them ourselves so this is actually a

00:30:15,890 --> 00:30:22,850
safe efficient way to go through a list

00:30:20,120 --> 00:30:24,230
of items and do something with it rather

00:30:22,850 --> 00:30:27,130
than just sort of manually looping

00:30:24,230 --> 00:30:30,049
through it risking the possibility of

00:30:27,130 --> 00:30:32,059
adjusting your list inline or anything

00:30:30,049 --> 00:30:36,770
like that so this is a really safe way

00:30:32,059 --> 00:30:41,330
of doing this type of thing and the last

00:30:36,770 --> 00:30:47,630
of these is reduce reduce is a little

00:30:41,330 --> 00:30:50,029
bit different than the other two so what

00:30:47,630 --> 00:30:51,919
reduce does it starts off the same it

00:30:50,029 --> 00:30:54,890
takes a reducing function alright and it

00:30:51,919 --> 00:30:56,029
takes a collection to reduce but the

00:30:54,890 --> 00:30:57,980
reducing functions a little bit

00:30:56,029 --> 00:31:01,250
different it doesn't just act on one

00:30:57,980 --> 00:31:03,590
item in the list it acts on two items in

00:31:01,250 --> 00:31:06,260
the list at a time you can actually send

00:31:03,590 --> 00:31:08,240
it an optional initial initial value so

00:31:06,260 --> 00:31:10,190
the reducing function instead of acting

00:31:08,240 --> 00:31:12,470
on the first and second item it'll start

00:31:10,190 --> 00:31:16,580
off acting on the initial value that you

00:31:12,470 --> 00:31:18,980
send it and then the first item and the

00:31:16,580 --> 00:31:20,570
way it works is this your reducing

00:31:18,980 --> 00:31:22,850
function takes these two items

00:31:20,570 --> 00:31:26,179
does something to it so that the output

00:31:22,850 --> 00:31:29,210
is one item of the same type that comes

00:31:26,179 --> 00:31:32,779
in you know we're not strictly using

00:31:29,210 --> 00:31:35,389
type you know like integer versus string

00:31:32,779 --> 00:31:37,549
versus whatever but essentially what's

00:31:35,389 --> 00:31:39,110
going to happen is it will take the

00:31:37,549 --> 00:31:41,029
reducing function the reducing function

00:31:39,110 --> 00:31:43,940
will take two values do something with

00:31:41,029 --> 00:31:47,630
it spit back out a new value that new

00:31:43,940 --> 00:31:50,480
value then becomes the first parameter

00:31:47,630 --> 00:31:52,159
in the when it calls the reducing

00:31:50,480 --> 00:31:56,169
function again and the next item in the

00:31:52,159 --> 00:32:01,250
list becomes the second parameter and so

00:31:56,169 --> 00:32:03,049
let's take a quick look here and this

00:32:01,250 --> 00:32:04,340
reduce reduce was the one that for

00:32:03,049 --> 00:32:05,690
whatever reason was hardest for me to

00:32:04,340 --> 00:32:07,669
wrap my head around exactly what it's

00:32:05,690 --> 00:32:09,110
doing map and filter were pretty

00:32:07,669 --> 00:32:10,460
straightforward for me reduce was a

00:32:09,110 --> 00:32:12,529
little harder to overcome so I've got a

00:32:10,460 --> 00:32:15,830
couple of examples that might help it

00:32:12,529 --> 00:32:19,090
solidify but in any case this first one

00:32:15,830 --> 00:32:22,100
is the sort of standard reducing example

00:32:19,090 --> 00:32:23,570
we have we're calling reduce on this

00:32:22,100 --> 00:32:25,909
anonymous function that just takes two

00:32:23,570 --> 00:32:27,950
variables and adds them together right

00:32:25,909 --> 00:32:29,870
so just like we did above when we were

00:32:27,950 --> 00:32:31,309
looking at lambdas initially we're just

00:32:29,870 --> 00:32:33,769
taking x and y and adding them together

00:32:31,309 --> 00:32:34,879
and returning that value what this is

00:32:33,769 --> 00:32:37,700
going to do though is this going to

00:32:34,879 --> 00:32:39,529
start with one and two out of the list

00:32:37,700 --> 00:32:40,940
that's going to be the first x and y

00:32:39,529 --> 00:32:43,580
it's going to add them together and

00:32:40,940 --> 00:32:47,840
you're going to get 3/3 is then passed

00:32:43,580 --> 00:32:50,600
back in as the X and the next item in

00:32:47,840 --> 00:32:52,429
the list which is also three gets passed

00:32:50,600 --> 00:32:55,580
in is why those two get added together

00:32:52,429 --> 00:32:58,220
just to get six six gets passed back in

00:32:55,580 --> 00:33:01,789
as the X and the next item in the list

00:32:58,220 --> 00:33:04,210
is four gets passed in as Y and at the

00:33:01,789 --> 00:33:11,179
end of the list you end up with your sum

00:33:04,210 --> 00:33:13,129
of 10 right now this is the same kind of

00:33:11,179 --> 00:33:14,330
thing that we saw above right we saw

00:33:13,129 --> 00:33:16,820
into that we saw an iterative approach

00:33:14,330 --> 00:33:18,320
and a recursive approach to taking a

00:33:16,820 --> 00:33:18,769
list of numbers and adding them all

00:33:18,320 --> 00:33:21,679
together

00:33:18,769 --> 00:33:24,139
this is using a reducer just to do the

00:33:21,679 --> 00:33:25,639
same thing and it has it's so much

00:33:24,139 --> 00:33:27,500
better if this is the kind of thing you

00:33:25,639 --> 00:33:30,889
need to do you need to start looking at

00:33:27,500 --> 00:33:32,990
reduce for one thing before when we try

00:33:30,889 --> 00:33:36,350
to use the

00:33:32,990 --> 00:33:39,049
recursive approach and we did - we added

00:33:36,350 --> 00:33:42,320
a thousand we blew the sack right or you

00:33:39,049 --> 00:33:43,970
had that recursive error here because of

00:33:42,320 --> 00:33:46,940
the way it's built behind the scenes

00:33:43,970 --> 00:33:48,409
it adds the first thousand numbers all

00:33:46,940 --> 00:33:49,789
together without going through the stack

00:33:48,409 --> 00:33:53,570
it knows what it's doing

00:33:49,789 --> 00:33:55,669
but it also does it really fast that's

00:33:53,570 --> 00:33:58,580
the first thousand numbers it's the

00:33:55,669 --> 00:34:00,289
first ten thousand numbers it's the

00:33:58,580 --> 00:34:02,840
first hundred thousand and one numbers I

00:34:00,289 --> 00:34:04,700
mean it's super speedy it's incredibly

00:34:02,840 --> 00:34:06,350
efficient this is probably much faster

00:34:04,700 --> 00:34:08,109
than we could manually go it is much

00:34:06,350 --> 00:34:11,810
faster because when we were doing the

00:34:08,109 --> 00:34:13,730
recursive approach above I started it

00:34:11,810 --> 00:34:15,800
off and we had to wait for a moment for

00:34:13,730 --> 00:34:17,300
it to blow through the stack this is

00:34:15,800 --> 00:34:20,179
going through it just lightning fast

00:34:17,300 --> 00:34:21,710
these things were made to do this type

00:34:20,179 --> 00:34:24,050
of work they're very efficient on the

00:34:21,710 --> 00:34:26,349
back end you really need to start

00:34:24,050 --> 00:34:30,950
looking at map filter and reduce as

00:34:26,349 --> 00:34:32,540
viable options for whatever kind of like

00:34:30,950 --> 00:34:34,250
wherever you think you can find you can

00:34:32,540 --> 00:34:36,740
put them it's probably a good place to

00:34:34,250 --> 00:34:40,869
put them because they really do make

00:34:36,740 --> 00:34:42,830
things so much easier and so much faster

00:34:40,869 --> 00:34:44,510
I'll go through one more quick example

00:34:42,830 --> 00:34:45,770
there's a couple of examples you can

00:34:44,510 --> 00:34:48,530
pull them down and look at them if you

00:34:45,770 --> 00:34:50,810
want I like this example essentially

00:34:48,530 --> 00:34:52,419
what this is going to do is it's going

00:34:50,810 --> 00:34:56,030
to go through and count

00:34:52,419 --> 00:34:58,030
it'll sum up all of the A's in all three

00:34:56,030 --> 00:35:00,410
of these strings right so this is

00:34:58,030 --> 00:35:02,780
imagine this is a DNA sequence it's got

00:35:00,410 --> 00:35:04,580
three A's here the next sequence

00:35:02,780 --> 00:35:08,510
sequence has two and the last sequence

00:35:04,580 --> 00:35:13,550
has none the reducing function in here

00:35:08,510 --> 00:35:15,109
is taking a in X in this case we're

00:35:13,550 --> 00:35:17,780
starting with initial value of zero so

00:35:15,109 --> 00:35:23,480
the first time it goes through the a is

00:35:17,780 --> 00:35:26,180
zero and the X is whatever the next item

00:35:23,480 --> 00:35:28,280
is in this particular case X is that

00:35:26,180 --> 00:35:29,930
particular string what the reducing

00:35:28,280 --> 00:35:32,570
function does is it takes that string

00:35:29,930 --> 00:35:34,369
does account of the A's adds that count

00:35:32,570 --> 00:35:38,330
back into whatever the eight whatever

00:35:34,369 --> 00:35:41,390
the a value is and kind of sums it up

00:35:38,330 --> 00:35:43,880
that way right so this is the same kind

00:35:41,390 --> 00:35:47,710
of problem we were trying to solve above

00:35:43,880 --> 00:35:47,710
more or less we're we're

00:35:47,750 --> 00:35:52,350
anyway I forgot which one I was but in

00:35:50,520 --> 00:35:55,650
any case this is a really efficient way

00:35:52,350 --> 00:35:57,600
of like you can give this huge list of

00:35:55,650 --> 00:36:00,600
DNA strains and it will go through and

00:35:57,600 --> 00:36:07,320
tell you all these markers in it just by

00:36:00,600 --> 00:36:11,040
using a reduce you can also mimic map

00:36:07,320 --> 00:36:14,280
and filter inside Python using list

00:36:11,040 --> 00:36:15,600
comprehensions we list comprehensions or

00:36:14,280 --> 00:36:18,450
something I'm sure every one of us has

00:36:15,600 --> 00:36:21,090
done day in and day out you can throw a

00:36:18,450 --> 00:36:23,850
lambda inside a list comprehension the

00:36:21,090 --> 00:36:29,910
lambdas too ugly you can pull it out you

00:36:23,850 --> 00:36:35,160
can also so a filtering function more or

00:36:29,910 --> 00:36:40,350
less inside the fill inside a list

00:36:35,160 --> 00:36:41,610
comprehension and anyway so these are

00:36:40,350 --> 00:36:43,140
tools that are already built into PI

00:36:41,610 --> 00:36:44,850
into Python that we use day in and day

00:36:43,140 --> 00:36:47,610
out but we don't think of them as being

00:36:44,850 --> 00:36:49,260
functional programming perhaps but they

00:36:47,610 --> 00:36:50,580
really are they're at their core they do

00:36:49,260 --> 00:36:53,310
the same type of thing that we would do

00:36:50,580 --> 00:36:55,380
in functional programming so leads us to

00:36:53,310 --> 00:36:57,320
the question of should we bring

00:36:55,380 --> 00:36:59,070
functional programming into our code

00:36:57,320 --> 00:37:01,440
because it is a really different

00:36:59,070 --> 00:37:03,450
paradigm I think of course you should

00:37:01,440 --> 00:37:04,650
function like I think I've shown in a

00:37:03,450 --> 00:37:07,170
couple different places functional

00:37:04,650 --> 00:37:09,450
programming can be less verbose it can

00:37:07,170 --> 00:37:10,890
be much more efficient and it can help

00:37:09,450 --> 00:37:12,810
you think through problems in a way that

00:37:10,890 --> 00:37:14,369
maybe you weren't you weren't able to

00:37:12,810 --> 00:37:16,290
think through before so maybe solutions

00:37:14,369 --> 00:37:18,450
become more obvious when you're using a

00:37:16,290 --> 00:37:20,880
different set of tools but there are

00:37:18,450 --> 00:37:23,580
some very real drawbacks as we've also

00:37:20,880 --> 00:37:26,130
seen or he with the immutable data can

00:37:23,580 --> 00:37:27,990
be slower especially in languages like

00:37:26,130 --> 00:37:29,640
Python again we have there's a

00:37:27,990 --> 00:37:31,710
persistent data structure library that's

00:37:29,640 --> 00:37:33,330
in Python now that someone's building I

00:37:31,710 --> 00:37:35,280
don't know anything about it I haven't

00:37:33,330 --> 00:37:38,340
had a chance to look at it if it turns

00:37:35,280 --> 00:37:39,690
out it it works well then I'm going to

00:37:38,340 --> 00:37:42,960
start trying to use it more in my code

00:37:39,690 --> 00:37:44,880
because it's much safer but in the but

00:37:42,960 --> 00:37:48,020
the immutable data is still slow in

00:37:44,880 --> 00:37:49,770
Python as its the built in versions

00:37:48,020 --> 00:37:50,340
recursion can blow through the stack

00:37:49,770 --> 00:37:52,230
very quickly

00:37:50,340 --> 00:37:54,840
as we've seen so recursion is not a good

00:37:52,230 --> 00:37:57,030
solution in most cases and functional

00:37:54,840 --> 00:37:59,380
code looks sort of weird I have

00:37:57,030 --> 00:38:01,630
coworker who loves to throw functional

00:37:59,380 --> 00:38:03,430
code into our Python and every time I

00:38:01,630 --> 00:38:04,960
hit it even though I like looking at

00:38:03,430 --> 00:38:07,240
functional code every time I hit it it's

00:38:04,960 --> 00:38:08,500
still a little bit of a speed bump when

00:38:07,240 --> 00:38:09,160
I first started hitting it it was a

00:38:08,500 --> 00:38:10,810
brick wall

00:38:09,160 --> 00:38:12,910
so it like totally slowed me down and

00:38:10,810 --> 00:38:13,960
stopped me but now that I understand

00:38:12,910 --> 00:38:16,180
what's going on with it

00:38:13,960 --> 00:38:17,920
I can scan through it more easily and

00:38:16,180 --> 00:38:19,240
understand it so if you're going to

00:38:17,920 --> 00:38:20,950
bring functional programming into your

00:38:19,240 --> 00:38:22,119
code probably something you need to

00:38:20,950 --> 00:38:24,040
discuss with your team or your

00:38:22,119 --> 00:38:25,990
management if you're working on a team

00:38:24,040 --> 00:38:27,550
and decide as a team hey is this

00:38:25,990 --> 00:38:29,589
something we really want to approach

00:38:27,550 --> 00:38:31,210
because if you if you just start

00:38:29,589 --> 00:38:32,530
throwing it in there and your teammates

00:38:31,210 --> 00:38:34,720
don't know anything about it they're

00:38:32,530 --> 00:38:36,520
gonna have quite a learning curve but

00:38:34,720 --> 00:38:39,869
you can help them learn and that's kind

00:38:36,520 --> 00:38:42,790
of funny yes I think so so that's our

00:38:39,869 --> 00:38:47,050
speed run through functional programming

00:38:42,790 --> 00:38:48,010
in Python how much time do I have okay

00:38:47,050 --> 00:38:56,829
all right

00:38:48,010 --> 00:38:58,810
did anyone have any questions thank you

00:38:56,829 --> 00:39:01,119
for the talk so you mentioned that you

00:38:58,810 --> 00:39:02,380
know in some situations might be good to

00:39:01,119 --> 00:39:05,230
bring functional programming into your

00:39:02,380 --> 00:39:07,660
code but I was wondering it sounds like

00:39:05,230 --> 00:39:09,190
you are saying it can be possible to

00:39:07,660 --> 00:39:11,020
just have a bit sprinkled in here and

00:39:09,190 --> 00:39:14,890
there is that right is it kind of do you

00:39:11,020 --> 00:39:17,050
recommend you know having it basically

00:39:14,890 --> 00:39:18,819
be the paradigm like choosing one or the

00:39:17,050 --> 00:39:21,160
other or do you think it can succeed if

00:39:18,819 --> 00:39:23,170
it's half-and-half or sprinkled in yeah

00:39:21,160 --> 00:39:24,730
I would definitely in Python you it's

00:39:23,170 --> 00:39:26,829
better to sprinkle it in like python

00:39:24,730 --> 00:39:29,170
while it supports all of these tools and

00:39:26,829 --> 00:39:31,780
a whole slew of others there's the func

00:39:29,170 --> 00:39:34,020
tools library in Python which is really

00:39:31,780 --> 00:39:36,460
great for doing these things efficiently

00:39:34,020 --> 00:39:39,490
Python is at heart an object-oriented

00:39:36,460 --> 00:39:41,319
language and so making that full

00:39:39,490 --> 00:39:43,060
transition transition into a functional

00:39:41,319 --> 00:39:44,530
paradigm probably isn't really going to

00:39:43,060 --> 00:39:45,880
work out there are a lot of good places

00:39:44,530 --> 00:39:48,160
where you can put it where you might not

00:39:45,880 --> 00:39:50,710
think you can one thing I didn't I

00:39:48,160 --> 00:39:53,020
didn't get a chance to touch on is the

00:39:50,710 --> 00:39:56,020
idea of data pipelines so one of the

00:39:53,020 --> 00:39:59,859
things you can do is compose functions

00:39:56,020 --> 00:40:02,760
which is sort of like if you've ever

00:39:59,859 --> 00:40:05,079
done any UNIX programming where you pipe

00:40:02,760 --> 00:40:06,550
output from one function call to another

00:40:05,079 --> 00:40:08,589
or if you've done

00:40:06,550 --> 00:40:09,670
like maybe node working with promises

00:40:08,589 --> 00:40:12,190
where you can then

00:40:09,670 --> 00:40:13,779
one function the results of one function

00:40:12,190 --> 00:40:16,150
call into that into the next that's

00:40:13,779 --> 00:40:18,460
composing functions you can build really

00:40:16,150 --> 00:40:20,230
great data pipelines doing that and you

00:40:18,460 --> 00:40:22,690
can do that in pipe in Python my thumb's

00:40:20,230 --> 00:40:24,490
are really great with like data science

00:40:22,690 --> 00:40:26,619
and kind of things so there are a lot of

00:40:24,490 --> 00:40:28,869
places where you can use a more

00:40:26,619 --> 00:40:31,269
functional mindset but it's probably not

00:40:28,869 --> 00:40:33,369
the paradigm you're going to run with

00:40:31,269 --> 00:40:34,630
completely inside Python you might be

00:40:33,369 --> 00:40:35,650
able to even if you can let me know

00:40:34,630 --> 00:40:39,069
because I want to know how that works

00:40:35,650 --> 00:40:41,049
out but my I've never been able to do

00:40:39,069 --> 00:40:44,829
that all right great talk

00:40:41,049 --> 00:40:49,720
thank you um you mentioned emulating map

00:40:44,829 --> 00:40:50,589
with list comprehension yeah I was

00:40:49,720 --> 00:40:51,849
wondering other other than

00:40:50,589 --> 00:40:52,720
considerations of who else is reading

00:40:51,849 --> 00:40:53,980
the code and whether that they're

00:40:52,720 --> 00:40:55,900
familiar with functional programming um

00:40:53,980 --> 00:40:57,309
are there technical differences

00:40:55,900 --> 00:40:59,140
differences between the two and how

00:40:57,309 --> 00:41:01,500
should you decide which one to use I

00:40:59,140 --> 00:41:04,390
don't know the technical differences I

00:41:01,500 --> 00:41:09,579
there there are I'm just going to assume

00:41:04,390 --> 00:41:10,690
that there are I know be the difference

00:41:09,579 --> 00:41:15,009
that you're going to run up against

00:41:10,690 --> 00:41:17,920
would be efficiency and speed my guess

00:41:15,009 --> 00:41:22,450
and I again this is just a guess but my

00:41:17,920 --> 00:41:23,890
guess is now maps are probably they're

00:41:22,450 --> 00:41:26,259
not going to be any slower than doing a

00:41:23,890 --> 00:41:27,849
list comprehension I cannot I can almost

00:41:26,259 --> 00:41:30,039
safely say that they may be a little

00:41:27,849 --> 00:41:32,619
more efficient a little faster because

00:41:30,039 --> 00:41:34,779
of the func tools that have been brought

00:41:32,619 --> 00:41:39,009
in map and filter are still a core part

00:41:34,779 --> 00:41:42,039
of Python reduced has to be brought has

00:41:39,009 --> 00:41:44,890
to be imported but I'm gonna I'm gonna

00:41:42,039 --> 00:41:45,279
go out on a limb and say it's a coin

00:41:44,890 --> 00:41:47,440
toss

00:41:45,279 --> 00:41:48,700
probably more or less you might get a

00:41:47,440 --> 00:41:50,140
little more efficiency with one or the

00:41:48,700 --> 00:41:52,660
other you're probably not going to

00:41:50,140 --> 00:41:53,950
notice a huge difference if I'm wrong

00:41:52,660 --> 00:41:57,250
about that I'm sure the internet will

00:41:53,950 --> 00:41:59,170
let me know has incorporating functional

00:41:57,250 --> 00:42:05,920
programming in your code change to your

00:41:59,170 --> 00:42:08,829
caching strategies at all it's not

00:42:05,920 --> 00:42:11,049
change our caching strategies I can see

00:42:08,829 --> 00:42:13,960
how it would we just we haven't gotten

00:42:11,049 --> 00:42:16,480
to that place yet really there's a

00:42:13,960 --> 00:42:19,720
there's only one or two other people at

00:42:16,480 --> 00:42:21,400
my office who start implementing

00:42:19,720 --> 00:42:22,560
functional programming so we're still

00:42:21,400 --> 00:42:25,140
sort of

00:42:22,560 --> 00:42:26,280
kind of I'm right he's like not even as

00:42:25,140 --> 00:42:27,420
a company we're building it out then you

00:42:26,280 --> 00:42:29,520
know like it's just something that some

00:42:27,420 --> 00:42:31,230
of us know about and like oh yeah this

00:42:29,520 --> 00:42:34,220
is this is a really good place to you

00:42:31,230 --> 00:42:37,200
know so a filter so a map in or whatever

00:42:34,220 --> 00:42:38,010
our former architect loved functional

00:42:37,200 --> 00:42:39,900
programming and he's the one that's

00:42:38,010 --> 00:42:41,520
first started putting it in and he's got

00:42:39,900 --> 00:42:42,840
weird functional stuff all over the

00:42:41,520 --> 00:42:45,510
place and that's where I sometimes hit a

00:42:42,840 --> 00:42:48,900
brick wall looking at functional code

00:42:45,510 --> 00:42:53,270
but I can definitely see how it can

00:42:48,900 --> 00:42:56,100
change our caching strategies especially

00:42:53,270 --> 00:42:57,930
since it a lot of these like math and

00:42:56,100 --> 00:43:00,120
filter are returning iterators now so

00:42:57,930 --> 00:43:03,330
they're lazy evaluations we don't have

00:43:00,120 --> 00:43:06,720
to like cache this whole huge you know

00:43:03,330 --> 00:43:09,600
change of the list or whatever we can

00:43:06,720 --> 00:43:11,520
sort of slowly build those changes and

00:43:09,600 --> 00:43:12,090
use them as needed and then kind of get

00:43:11,520 --> 00:43:14,470
rid of them

00:43:12,090 --> 00:43:22,170
alright great thank you very much

00:43:14,470 --> 00:43:22,170

YouTube URL: https://www.youtube.com/watch?v=Nk2kqwz7jjs


