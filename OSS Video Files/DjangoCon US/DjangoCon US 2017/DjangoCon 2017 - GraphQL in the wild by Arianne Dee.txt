Title: DjangoCon 2017 - GraphQL in the wild by Arianne Dee
Publication date: 2017-09-11
Playlist: DjangoCon US 2017
Description: 
	GraphQL in the wild by Arianne Dee

Since being released by Facebook in 2015, GraphQL has gained a lot of hype for being the best thing since sliced bread and REST APIs. But what is all the hype about and how does GraphQL fare in the real world?

As a Django developer who has been using GraphQL in production since September 2017, I will discuss how we have addressed real-world concerns like performance and security. I will also highlight some of the joys of using GraphQL and why we have stopped writing REST APIs for new features.

If you have never heard of GraphQL or have never used the Graphene library, have no fear. There will be an overview of what GraphQL is, as well as a demo on how to incorporate it into a Django project using Graphene.

This talk was presented at: https://2017.djangocon.us/talks/graphql-in-the-wild/

LINKS:
Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:15,950
[Music]

00:00:13,480 --> 00:00:17,900
thank you for coming to my talk I know

00:00:15,950 --> 00:00:20,150
there's a pretty awesome talk happening

00:00:17,900 --> 00:00:21,520
at the same time so I really appreciate

00:00:20,150 --> 00:00:26,150
it

00:00:21,520 --> 00:00:32,440
first off a show of hands who here has

00:00:26,150 --> 00:00:35,420
used explored a graph QL API before and

00:00:32,440 --> 00:00:38,329
who here has tried to implement a graph

00:00:35,420 --> 00:00:43,700
QL schema in the back end on a side

00:00:38,329 --> 00:00:49,730
project couple people and who here has

00:00:43,700 --> 00:00:52,160
used it in production one person yeah so

00:00:49,730 --> 00:00:59,539
your questions can be directed at her as

00:00:52,160 --> 00:01:01,760
well afterward so thank you my talk

00:00:59,539 --> 00:01:03,739
today is called graph QL in the wild

00:01:01,760 --> 00:01:08,600
some people here like lemur so I added

00:01:03,739 --> 00:01:10,370
that in so now I know a bit about your

00:01:08,600 --> 00:01:14,570
experience I'm gonna talk a little bit

00:01:10,370 --> 00:01:17,210
about mine I have I own would say I'm a

00:01:14,570 --> 00:01:18,619
generalist have done a lot of stuff in

00:01:17,210 --> 00:01:21,650
the past you can read about in my bio

00:01:18,619 --> 00:01:25,070
but related to this talk I taught myself

00:01:21,650 --> 00:01:28,579
Jenko about two years ago as the only

00:01:25,070 --> 00:01:31,100
employee at a start-up then I realized I

00:01:28,579 --> 00:01:34,520
needed some mentorship and I worked at

00:01:31,100 --> 00:01:36,890
70s they were using Django and I've been

00:01:34,520 --> 00:01:39,170
there for one and a half years so we're

00:01:36,890 --> 00:01:42,950
based in Vancouver Canada or about 30

00:01:39,170 --> 00:01:45,140
employees total but back then there were

00:01:42,950 --> 00:01:46,250
like four back end engineers and two of

00:01:45,140 --> 00:01:48,860
them were doing separate things so

00:01:46,250 --> 00:01:53,180
they're kind of just two of us and then

00:01:48,860 --> 00:01:56,479
like for front-end engineers and we and

00:01:53,180 --> 00:01:59,180
so my coworker Tony who is amazing is

00:01:56,479 --> 00:02:00,890
very curious about new things and was

00:01:59,180 --> 00:02:06,439
into interested in trying out graph QL

00:02:00,890 --> 00:02:08,750
kind of you know early on and so we have

00:02:06,439 --> 00:02:12,560
been using graph QL in production for

00:02:08,750 --> 00:02:15,440
about a year in the talk description it

00:02:12,560 --> 00:02:16,820
says 2017 and I think all their sixes

00:02:15,440 --> 00:02:19,370
got changed into seven because it

00:02:16,820 --> 00:02:22,099
happened in different one two so yeah

00:02:19,370 --> 00:02:24,140
it's been about a year there have been a

00:02:22,099 --> 00:02:26,520
lot of talks there's a lot of resources

00:02:24,140 --> 00:02:30,240
online about graph QL in general

00:02:26,520 --> 00:02:32,430
not as much about using it in Python but

00:02:30,240 --> 00:02:35,390
I wanted to focus this talk less so on

00:02:32,430 --> 00:02:38,640
like an intro to graph QL and more about

00:02:35,390 --> 00:02:41,820
what we've done to move it from like

00:02:38,640 --> 00:02:45,030
cool pet project to using it in

00:02:41,820 --> 00:02:46,740
production and how it's helped us but

00:02:45,030 --> 00:02:48,750
there will be an overview of that but

00:02:46,740 --> 00:02:50,040
I'm gonna kind of breeze through it a

00:02:48,750 --> 00:02:51,630
little bit so that there's room for

00:02:50,040 --> 00:02:53,160
questions at the end and then if you

00:02:51,630 --> 00:02:57,150
have questions about it we can kind of

00:02:53,160 --> 00:03:02,190
go back so first of all let's talk about

00:02:57,150 --> 00:03:03,660
rest rest is pretty awesome you can you

00:03:02,190 --> 00:03:06,720
know you've got that separation of

00:03:03,660 --> 00:03:08,910
clients and server code you can not

00:03:06,720 --> 00:03:12,090
update the server and still have like

00:03:08,910 --> 00:03:15,240
mobile views and and just different

00:03:12,090 --> 00:03:16,200
views of the same stuff and yeah it's

00:03:15,240 --> 00:03:18,810
great right

00:03:16,200 --> 00:03:21,000
we all loved our DRF I actually haven't

00:03:18,810 --> 00:03:22,620
been I only have like a few months of

00:03:21,000 --> 00:03:26,700
drf experience so I know more about

00:03:22,620 --> 00:03:30,060
graph QL but there are some issues with

00:03:26,700 --> 00:03:33,780
rest one thing was that we were noticing

00:03:30,060 --> 00:03:35,300
a lot of performance issues one thing is

00:03:33,780 --> 00:03:37,500
when you're trying to get related data

00:03:35,300 --> 00:03:38,820
so you've got you know you normal

00:03:37,500 --> 00:03:41,580
ListView that's cool but what if you

00:03:38,820 --> 00:03:44,400
want like a dashboard view and so you

00:03:41,580 --> 00:03:47,310
want to show a lot of related data you

00:03:44,400 --> 00:03:49,500
know you have to go into this nested

00:03:47,310 --> 00:03:54,600
structure each one of those endpoints is

00:03:49,500 --> 00:03:55,650
like a different request so that takes a

00:03:54,600 --> 00:03:58,230
long time because you need a lot of

00:03:55,650 --> 00:04:00,180
requests another thing is the amount of

00:03:58,230 --> 00:04:03,240
time I was taking for serialization that

00:04:00,180 --> 00:04:05,130
ended up being the vast majority of the

00:04:03,240 --> 00:04:09,180
performance issues we were seeing per

00:04:05,130 --> 00:04:09,900
request for example our user resource

00:04:09,180 --> 00:04:11,790
you know

00:04:09,900 --> 00:04:14,820
so what 7-piece does is we have a

00:04:11,790 --> 00:04:17,220
performance management platform so you

00:04:14,820 --> 00:04:19,770
can set goals you can have meetings with

00:04:17,220 --> 00:04:22,080
your managers and give peer feedback and

00:04:19,770 --> 00:04:24,390
give peer recognitions and a lot of all

00:04:22,080 --> 00:04:27,180
of that is user focused right so we're

00:04:24,390 --> 00:04:30,870
sending the the user with everything our

00:04:27,180 --> 00:04:32,910
user extended user resource has 34

00:04:30,870 --> 00:04:35,190
fields in it only four of them are

00:04:32,910 --> 00:04:36,510
important so we're wasting about 88% of

00:04:35,190 --> 00:04:37,900
the data that we're getting back from

00:04:36,510 --> 00:04:41,650
the server

00:04:37,900 --> 00:04:44,260
so Rasmus still working for us

00:04:41,650 --> 00:04:47,320
performance issues aside but then the

00:04:44,260 --> 00:04:51,040
designers came up with this dashboard

00:04:47,320 --> 00:04:52,930
that to build it looks like this you

00:04:51,040 --> 00:04:57,070
know you can see my objective my

00:04:52,930 --> 00:04:58,840
objectives or my goals the tasks that

00:04:57,070 --> 00:05:02,710
are related to those goals the overall

00:04:58,840 --> 00:05:04,750
progress and stats my latest update to

00:05:02,710 --> 00:05:06,880
the goals but then this is also on the

00:05:04,750 --> 00:05:09,640
page and all of the goals related to my

00:05:06,880 --> 00:05:10,240
co-workers and my manager and then just

00:05:09,640 --> 00:05:12,490
for fun

00:05:10,240 --> 00:05:16,560
some summaries about the organization

00:05:12,490 --> 00:05:18,640
and the team that I on so for an example

00:05:16,560 --> 00:05:22,360
bunch of data that we need to get from

00:05:18,640 --> 00:05:24,010
that we were shaking in our boots about

00:05:22,360 --> 00:05:29,950
like how we were gonna do this with rest

00:05:24,010 --> 00:05:32,950
right and so we had a little bit of a

00:05:29,950 --> 00:05:34,420
challenge my coworker Tony had used

00:05:32,950 --> 00:05:37,030
graph QL before he thought this might be

00:05:34,420 --> 00:05:39,250
a good time to check it try it out he

00:05:37,030 --> 00:05:41,710
and I had a little bit of a friendly

00:05:39,250 --> 00:05:43,990
competition going I would try to use our

00:05:41,710 --> 00:05:45,400
REST API endpoints I didn't have to

00:05:43,990 --> 00:05:48,460
worry about versioning I could like

00:05:45,400 --> 00:05:52,420
reduce the number of data I was sending

00:05:48,460 --> 00:05:58,270
per resource and he was going to look at

00:05:52,420 --> 00:06:01,930
graph ul the winner of this challenge if

00:05:58,270 --> 00:06:10,750
I won I would get to name his about to

00:06:01,930 --> 00:06:12,490
be born baby boy my mom I'm Filipino my

00:06:10,750 --> 00:06:15,190
mom is a travel agent we have weird

00:06:12,490 --> 00:06:18,070
names she knows someone whose child is

00:06:15,190 --> 00:06:21,910
named spaghetti 88 so I was just going

00:06:18,070 --> 00:06:26,080
to take that so so Tony's son was gonna

00:06:21,910 --> 00:06:28,480
be named spaghetti 88 angrily so and if

00:06:26,080 --> 00:06:30,660
he won he I would not get to name his

00:06:28,480 --> 00:06:30,660
son

00:06:31,389 --> 00:06:40,370
so it was on and our results were with

00:06:36,740 --> 00:06:42,169
rests this is what it looked like in the

00:06:40,370 --> 00:06:45,259
chrome inspector but the network calls

00:06:42,169 --> 00:06:46,960
there were a lot of them and in craft QL

00:06:45,259 --> 00:06:50,360
it looked like this

00:06:46,960 --> 00:06:52,310
so comparison of a ten point three

00:06:50,360 --> 00:06:55,190
seconds overall in five point five a lot

00:06:52,310 --> 00:06:59,870
of that is just loading stuff so what is

00:06:55,190 --> 00:07:03,289
this crazy voodoo magic like and how how

00:06:59,870 --> 00:07:05,750
do we actually use this in production we

00:07:03,289 --> 00:07:07,729
wanted to know there were you know the

00:07:05,750 --> 00:07:08,810
security guys like what about this and

00:07:07,729 --> 00:07:10,180
what about this what about this and

00:07:08,810 --> 00:07:15,770
we're like uh I think we can solve them

00:07:10,180 --> 00:07:18,319
so as many of you know github is one of

00:07:15,770 --> 00:07:20,690
the major players to move to a graph QL

00:07:18,319 --> 00:07:23,330
API and we all love and trust github

00:07:20,690 --> 00:07:26,060
right so if they could do it we could do

00:07:23,330 --> 00:07:28,699
it we actually did it about the same

00:07:26,060 --> 00:07:31,699
time and I'm just going to show you

00:07:28,699 --> 00:07:34,580
quickly a little bit about what that

00:07:31,699 --> 00:07:36,949
looks like so here is the graphical app

00:07:34,580 --> 00:07:39,199
it is awesome it's like swagger but way

00:07:36,949 --> 00:07:45,289
better or the Django rest framework

00:07:39,199 --> 00:07:48,169
stuff so I want a new query and so I am

00:07:45,289 --> 00:07:51,199
the viewer let's see I want some

00:07:48,169 --> 00:07:56,870
repositories and I only want to get the

00:07:51,199 --> 00:08:02,900
first ten and this is weird stuff that

00:07:56,870 --> 00:08:07,490
I'll go over briefly later and let's see

00:08:02,900 --> 00:08:08,690
oh those have some issues cool no I

00:08:07,490 --> 00:08:11,360
don't want that right now because this

00:08:08,690 --> 00:08:15,639
is just a demo but let's see where that

00:08:11,360 --> 00:08:15,639
comes up so

00:08:16,860 --> 00:08:23,409
so I can see my name I've got a few

00:08:20,199 --> 00:08:26,769
repositories in here but pretty much

00:08:23,409 --> 00:08:30,039
graphic you well you can it's a query

00:08:26,769 --> 00:08:33,779
language it defines how you query data

00:08:30,039 --> 00:08:35,979
from your api's it's similar to SQL

00:08:33,779 --> 00:08:39,639
which is a query language for your

00:08:35,979 --> 00:08:41,649
databases but this is above the layer of

00:08:39,639 --> 00:08:43,149
databases this is API business level

00:08:41,649 --> 00:08:45,130
logic you can have totally different

00:08:43,149 --> 00:08:46,870
models in the backend from what you

00:08:45,130 --> 00:08:53,740
display in the front-end and that's

00:08:46,870 --> 00:08:55,089
actually highly encouraged so according

00:08:53,740 --> 00:08:58,449
to github

00:08:55,089 --> 00:09:00,730
the ability to define precisely the data

00:08:58,449 --> 00:09:05,680
you want and only the data you want is a

00:09:00,730 --> 00:09:07,899
powerful advantage over a REST API some

00:09:05,680 --> 00:09:10,689
of these advantages include yeah the

00:09:07,899 --> 00:09:15,639
data that you want and nothing more

00:09:10,689 --> 00:09:19,360
nested fields and strong typing so does

00:09:15,639 --> 00:09:23,829
it play well with Django the answer is

00:09:19,360 --> 00:09:26,170
kind of since this is really powerful

00:09:23,829 --> 00:09:29,259
for front-end and JavaScript and

00:09:26,170 --> 00:09:31,569
especially react so Facebook I forgot to

00:09:29,259 --> 00:09:34,029
mention Facebook was where the people

00:09:31,569 --> 00:09:36,639
who actually created graph QL they've

00:09:34,029 --> 00:09:39,370
been using it internally in production

00:09:36,639 --> 00:09:41,019
since 2012 they had this issue with

00:09:39,370 --> 00:09:42,610
getting too much data especially for

00:09:41,019 --> 00:09:48,250
their mobile app that doesn't need as

00:09:42,610 --> 00:09:50,470
much data as their website and they open

00:09:48,250 --> 00:09:51,670
sourced it they announced it in January

00:09:50,470 --> 00:09:53,709
00:09:51,670 --> 00:09:56,680
so about two years ago open sourced it

00:09:53,709 --> 00:09:58,209
about half a year later and now you know

00:09:56,680 --> 00:10:02,500
it's just grown and evolved over time

00:09:58,209 --> 00:10:04,269
but because it's more for the front end

00:10:02,500 --> 00:10:06,490
I think the JavaScript communities have

00:10:04,269 --> 00:10:09,459
really taken to it there's like five

00:10:06,490 --> 00:10:11,920
different versions of it a node and in

00:10:09,459 --> 00:10:15,189
Django we've got graphing which is

00:10:11,920 --> 00:10:19,089
pretty cool it's pretty easy but there

00:10:15,189 --> 00:10:22,870
are some drawbacks so here's the github

00:10:19,089 --> 00:10:25,389
readme for it so you can just use in

00:10:22,870 --> 00:10:28,180
Python it has hooks to work with Django

00:10:25,389 --> 00:10:28,960
especially their ORM you can also use

00:10:28,180 --> 00:10:31,420
SQL

00:10:28,960 --> 00:10:34,420
and maybe peewee sometime in the future

00:10:31,420 --> 00:10:37,990
that's been there for like a year so how

00:10:34,420 --> 00:10:40,990
do we set it up it's like two seconds

00:10:37,990 --> 00:10:44,680
pip install graphene Django add it to

00:10:40,990 --> 00:10:47,230
your installed apps and set the URL that

00:10:44,680 --> 00:10:50,560
you want olive graph QL to go to so

00:10:47,230 --> 00:10:53,800
graph QL it has a single endpoint and

00:10:50,560 --> 00:10:56,110
you send the data that you want in the

00:10:53,800 --> 00:11:00,280
query and your variables either through

00:10:56,110 --> 00:11:03,970
the get query parameters or through the

00:11:00,280 --> 00:11:07,720
post body so that can be anywhere I'm

00:11:03,970 --> 00:11:10,540
calling it graph QL it also has it comes

00:11:07,720 --> 00:11:14,530
built in with that graphical app which

00:11:10,540 --> 00:11:17,860
you can explore it everything with so so

00:11:14,530 --> 00:11:23,920
that's it mostly then you have to define

00:11:17,860 --> 00:11:27,070
your queries and your schema it's as

00:11:23,920 --> 00:11:29,890
simple as this if you're using Django

00:11:27,070 --> 00:11:32,080
you just say hey I've got everything in

00:11:29,890 --> 00:11:33,460
red by the way sorry for anyone who's

00:11:32,080 --> 00:11:36,490
colorblind hopefully you can see it but

00:11:33,460 --> 00:11:39,610
like Genco object type is in red I

00:11:36,490 --> 00:11:41,350
wanted to do that so you can see what

00:11:39,610 --> 00:11:44,080
exactly is coming from the graafian

00:11:41,350 --> 00:11:46,240
library or the Django graphene library

00:11:44,080 --> 00:11:49,060
so it wasn't so long

00:11:46,240 --> 00:11:51,970
so yeah say it's a Gengo object type

00:11:49,060 --> 00:11:54,460
you're creating a node and it's gonna be

00:11:51,970 --> 00:11:59,710
based off of this model the task model

00:11:54,460 --> 00:12:01,300
in Django you also have to define so

00:11:59,710 --> 00:12:03,040
beside your nodes you have to define how

00:12:01,300 --> 00:12:05,140
you're going to enter the schema so your

00:12:03,040 --> 00:12:08,290
root query so here I'm just saying it's

00:12:05,140 --> 00:12:10,660
goals because this is the kind of data

00:12:08,290 --> 00:12:12,850
that I'm working with in my company and

00:12:10,660 --> 00:12:16,150
then you can resolve goals in a certain

00:12:12,850 --> 00:12:20,190
way by saying here's the query set to

00:12:16,150 --> 00:12:23,650
look at and then add it to your schema

00:12:20,190 --> 00:12:25,300
so here's a little bit of a drawing that

00:12:23,650 --> 00:12:29,440
I overlaid with things I got from the

00:12:25,300 --> 00:12:31,300
Apollo blog thanks Apollo so you've got

00:12:29,440 --> 00:12:33,340
the triangles is where you're entering

00:12:31,300 --> 00:12:35,200
the schema and then you can use graph QL

00:12:33,340 --> 00:12:37,030
to traverse the rest of it and the

00:12:35,200 --> 00:12:39,070
yellow bits are the nodes

00:12:37,030 --> 00:12:41,920
and then all the little things coming

00:12:39,070 --> 00:12:44,620
off of it are like fields of that node

00:12:41,920 --> 00:12:47,920
so graphene will take that automatically

00:12:44,620 --> 00:12:51,040
from your Django models you can exclude

00:12:47,920 --> 00:12:53,560
things of course you can also define

00:12:51,040 --> 00:12:56,770
custom notes so for the user node if I

00:12:53,560 --> 00:13:00,760
want full name I can say full name is

00:12:56,770 --> 00:13:04,030
this type string and string is from the

00:13:00,760 --> 00:13:06,340
graphene library and then resolve it and

00:13:04,030 --> 00:13:07,960
so whenever you have resolved anything

00:13:06,340 --> 00:13:12,280
that's like a field you can have a

00:13:07,960 --> 00:13:14,740
resolver for and I'm because I'm going

00:13:12,280 --> 00:13:17,770
to talk about resolvers later a bit so

00:13:14,740 --> 00:13:22,060
you can say what it returns great so

00:13:17,770 --> 00:13:26,860
that's pretty easy so I'm just gonna

00:13:22,060 --> 00:13:29,020
show you a bit about all that stuff I've

00:13:26,860 --> 00:13:35,440
done just now what that looks like that

00:13:29,020 --> 00:13:45,330
will get us this goals I've got some

00:13:35,440 --> 00:13:45,330
tasks and they each have a name ok and

00:13:46,020 --> 00:13:54,490
yeah so that's it for now so that gets

00:13:51,820 --> 00:13:56,410
you that and so you can use this on top

00:13:54,490 --> 00:13:58,300
of any project that you're using

00:13:56,410 --> 00:14:02,650
regardless of whether you have a REST

00:13:58,300 --> 00:14:04,990
API or not so next to adding filters and

00:14:02,650 --> 00:14:07,570
pagination this makes it a little more

00:14:04,990 --> 00:14:10,810
complicated so you've got goals and name

00:14:07,570 --> 00:14:14,280
and progress but how do we get certain

00:14:10,810 --> 00:14:16,840
things like what the total count is and

00:14:14,280 --> 00:14:21,610
how do we do pagination and filter on

00:14:16,840 --> 00:14:23,140
them so these red arrows are now going

00:14:21,610 --> 00:14:28,840
to be called connections we're gonna add

00:14:23,140 --> 00:14:31,240
a few different things and so when

00:14:28,840 --> 00:14:34,750
you're when you have like a many to one

00:14:31,240 --> 00:14:37,060
or many to many relationship it's going

00:14:34,750 --> 00:14:38,680
to now be called edges so that you can

00:14:37,060 --> 00:14:41,200
do things like get the total count of

00:14:38,680 --> 00:14:43,300
the edges or get these things called

00:14:41,200 --> 00:14:46,060
cursor for pagination and I'm just gonna

00:14:43,300 --> 00:14:49,170
and then you can also use you can filter

00:14:46,060 --> 00:14:52,240
you see Oh No

00:14:49,170 --> 00:14:54,130
anyways it also adds it also adds

00:14:52,240 --> 00:14:58,780
filtering so how you get that is

00:14:54,130 --> 00:15:03,730
something called relay Facebook relay

00:14:58,780 --> 00:15:07,320
has is kind of like Redux for JavaScript

00:15:03,730 --> 00:15:09,940
it but let's not worry about that you

00:15:07,320 --> 00:15:12,970
you don't have to use relay in

00:15:09,940 --> 00:15:16,450
JavaScript to use the relay pagination

00:15:12,970 --> 00:15:18,760
features in graphene so all you do is

00:15:16,450 --> 00:15:20,560
say I'm using this relay node interface

00:15:18,760 --> 00:15:25,450
and that changes all of your connections

00:15:20,560 --> 00:15:27,340
to changes your lists to connections and

00:15:25,450 --> 00:15:29,290
then you can use something called Jenko

00:15:27,340 --> 00:15:32,110
filter connection field and that adds

00:15:29,290 --> 00:15:34,330
the ability to define your Jenko filters

00:15:32,110 --> 00:15:38,130
class that you want to use and so you

00:15:34,330 --> 00:15:42,280
can use your Jango filters on every node

00:15:38,130 --> 00:15:44,350
lastly or almost lastly we have kind of

00:15:42,280 --> 00:15:47,830
built in documentation which is one of

00:15:44,350 --> 00:15:50,500
my favorite features of graph QL so I

00:15:47,830 --> 00:15:55,270
can just say here is the description of

00:15:50,500 --> 00:15:59,920
this field and then what that ends up

00:15:55,270 --> 00:16:03,640
looking like is in these docs I can go

00:15:59,920 --> 00:16:04,840
into query I can look at goal node I can

00:16:03,640 --> 00:16:08,890
look at oh no

00:16:04,840 --> 00:16:10,750
sorry that is a mistake where did I add

00:16:08,890 --> 00:16:16,850
it to

00:16:10,750 --> 00:16:19,160
anyways here so if I go into progress I

00:16:16,850 --> 00:16:20,930
can see the description just in here but

00:16:19,160 --> 00:16:22,340
you can also you've almost never in need

00:16:20,930 --> 00:16:27,290
descriptions because they should be

00:16:22,340 --> 00:16:29,030
describing themselves ideally hey then

00:16:27,290 --> 00:16:31,100
there's a lot of other fancy stuff that

00:16:29,030 --> 00:16:32,960
you get which we're not going to talk

00:16:31,100 --> 00:16:36,320
about but if you have questions you can

00:16:32,960 --> 00:16:38,900
ask me outside and pretty much the

00:16:36,320 --> 00:16:40,370
answer is it can do everything pretty

00:16:38,900 --> 00:16:42,290
much everything that you want it to do

00:16:40,370 --> 00:16:46,100
you might need a little bit of tweaking

00:16:42,290 --> 00:16:49,430
but we've added our own new fields we

00:16:46,100 --> 00:16:54,290
can return different Django model types

00:16:49,430 --> 00:16:57,320
on the same node using unions everything

00:16:54,290 --> 00:17:01,010
like that so you've got some pretty cool

00:16:57,320 --> 00:17:04,550
stuff there's some pros for graph QL

00:17:01,010 --> 00:17:06,350
it's excel explorable like you don't

00:17:04,550 --> 00:17:08,750
have to send anything else up and it's

00:17:06,350 --> 00:17:11,360
pretty fun you've got easy documentation

00:17:08,750 --> 00:17:14,300
I find it personally more intuitive to

00:17:11,360 --> 00:17:17,390
implement than Django rest framework and

00:17:14,300 --> 00:17:19,220
that's just on the back side like you

00:17:17,390 --> 00:17:24,460
know in building AP is there's a whole

00:17:19,220 --> 00:17:27,050
load of benefits for the front-end so

00:17:24,460 --> 00:17:28,610
what makes what are some use cases I

00:17:27,050 --> 00:17:30,890
make it better than rest so as we saw

00:17:28,610 --> 00:17:34,790
that before those complex views if you

00:17:30,890 --> 00:17:37,100
want summaries dashboards stats they

00:17:34,790 --> 00:17:39,290
your nodes don't have to be connected at

00:17:37,100 --> 00:17:41,600
all to Jenko models you can return

00:17:39,290 --> 00:17:44,150
whatever you want so we have a stats

00:17:41,600 --> 00:17:47,170
node that does a lot of processing in

00:17:44,150 --> 00:17:51,950
the backend and send it to the front and

00:17:47,170 --> 00:17:56,170
we were good this way that you know that

00:17:51,950 --> 00:17:56,170
was about September to November

00:17:56,430 --> 00:18:04,420
we were only using graph QL for complex

00:18:00,550 --> 00:18:07,870
views and gets but then we had this

00:18:04,420 --> 00:18:11,290
other challenge we were building the

00:18:07,870 --> 00:18:15,750
feedback form and we wanted to create a

00:18:11,290 --> 00:18:17,860
survey builder that would autosave and

00:18:15,750 --> 00:18:20,080
the front-end people had tried

00:18:17,860 --> 00:18:21,790
implementing it already in Brest there

00:18:20,080 --> 00:18:27,550
was like all this stuff we were using

00:18:21,790 --> 00:18:30,910
like reactive like rxjs to to do certain

00:18:27,550 --> 00:18:34,060
things you know determining when you're

00:18:30,910 --> 00:18:36,790
creating a new object so a post versus

00:18:34,060 --> 00:18:38,410
when you're updating an object versus

00:18:36,790 --> 00:18:40,990
when you're deleting it things have to

00:18:38,410 --> 00:18:42,400
be done in the right order and if you if

00:18:40,990 --> 00:18:45,430
something fails you have to remember

00:18:42,400 --> 00:18:49,840
what else needs to come back come after

00:18:45,430 --> 00:18:55,390
it so we had this idea to use graph QL

00:18:49,840 --> 00:18:59,440
for it and it ended up working really

00:18:55,390 --> 00:19:02,710
well so instead of doing each item we

00:18:59,440 --> 00:19:04,360
just like send it a big payload and the

00:19:02,710 --> 00:19:06,160
back end it's up to the backend to

00:19:04,360 --> 00:19:08,650
figure out how to save everything so

00:19:06,160 --> 00:19:09,970
that what's in the database actually

00:19:08,650 --> 00:19:12,400
looks like with a payload that you got

00:19:09,970 --> 00:19:14,020
so if you got a successful response you

00:19:12,400 --> 00:19:17,290
know that what you're showing is

00:19:14,020 --> 00:19:18,970
actually what's on the backend and you

00:19:17,290 --> 00:19:20,920
know you could do this without graph ul

00:19:18,970 --> 00:19:22,990
but the benefits of doing it with graph

00:19:20,920 --> 00:19:25,600
ul are the type checking you don't have

00:19:22,990 --> 00:19:28,510
to check each input that yes this is a

00:19:25,600 --> 00:19:32,530
float yes this is a string because it'll

00:19:28,510 --> 00:19:35,170
it'll do all that for you and give you

00:19:32,530 --> 00:19:38,440
an error if it's not right so there are

00:19:35,170 --> 00:19:39,970
these things called mutations instead of

00:19:38,440 --> 00:19:45,220
queries so those are the two main

00:19:39,970 --> 00:19:49,180
components of graph QL and how you set

00:19:45,220 --> 00:19:52,360
that up this is what it looks like in

00:19:49,180 --> 00:19:54,940
the end you've got a mutation here you

00:19:52,360 --> 00:19:56,860
can pass in some variables and pass

00:19:54,940 --> 00:20:00,210
those variables into the mutation and

00:19:56,860 --> 00:20:04,480
then when you press when you send it

00:20:00,210 --> 00:20:07,060
what is in here is another query and

00:20:04,480 --> 00:20:09,280
that's the data that you get back that's

00:20:07,060 --> 00:20:12,010
the result of doing those

00:20:09,280 --> 00:20:13,780
that mutation so you know have you if

00:20:12,010 --> 00:20:16,060
you've ever had this problem where you

00:20:13,780 --> 00:20:17,650
change some data something else then

00:20:16,060 --> 00:20:21,160
changes and so you need to do another

00:20:17,650 --> 00:20:24,070
request to see how it affected it that's

00:20:21,160 --> 00:20:30,160
all in one request now and you just yeah

00:20:24,070 --> 00:20:32,860
define what you want to return so you

00:20:30,160 --> 00:20:37,030
can define some inputs there like nodes

00:20:32,860 --> 00:20:39,850
but there's actually no quick way that I

00:20:37,030 --> 00:20:41,230
know of of getting the input types from

00:20:39,850 --> 00:20:41,890
the Jenko model you kind of to build

00:20:41,230 --> 00:20:45,340
these yourself

00:20:41,890 --> 00:20:48,790
and in that way it's different from a

00:20:45,340 --> 00:20:50,410
put or a patch because you're not you

00:20:48,790 --> 00:20:52,300
you're not supposed to think about it in

00:20:50,410 --> 00:20:53,680
terms of I have this object I want to

00:20:52,300 --> 00:20:56,170
change this field to this in this field

00:20:53,680 --> 00:20:58,030
to this it's more like I want to mutate

00:20:56,170 --> 00:20:59,980
this object in some way I want to do

00:20:58,030 --> 00:21:01,810
something to it and the back end should

00:20:59,980 --> 00:21:07,120
have a better understanding about what

00:21:01,810 --> 00:21:14,590
that means and do it itself oops that

00:21:07,120 --> 00:21:18,250
was not supposed to be like that so yeah

00:21:14,590 --> 00:21:21,160
you can define a mutation like so you

00:21:18,250 --> 00:21:23,080
have the graph QL mutation class you

00:21:21,160 --> 00:21:25,300
define what inputs you're taking in I'm

00:21:23,080 --> 00:21:28,000
actually only taking in an int and a

00:21:25,300 --> 00:21:29,680
float in this case and not the inputs

00:21:28,000 --> 00:21:31,300
that I showed on the previous frame but

00:21:29,680 --> 00:21:35,590
I wanted to show you how it could be

00:21:31,300 --> 00:21:38,200
done and and then the gold part is

00:21:35,590 --> 00:21:40,390
defining what node is being returned by

00:21:38,200 --> 00:21:41,860
it so that's what you can query on when

00:21:40,390 --> 00:21:44,770
you're actually doing the mutation for

00:21:41,860 --> 00:21:48,150
your return data and then you do a bunch

00:21:44,770 --> 00:21:48,150
of stuff make sure it's atomic

00:21:49,070 --> 00:21:58,600
and then you just add it as a mutation

00:21:52,460 --> 00:22:02,049
onto your schema bless you okay so

00:21:58,600 --> 00:22:04,340
looking back at our graphical a viewer

00:22:02,049 --> 00:22:05,900
you know you can see that where the

00:22:04,340 --> 00:22:12,950
different parts fit in the inputs the

00:22:05,900 --> 00:22:14,960
return data the variables and so this

00:22:12,950 --> 00:22:17,590
simplifies the client-side logic that

00:22:14,960 --> 00:22:20,809
they have to do you don't have to yeah

00:22:17,590 --> 00:22:23,299
along with the gets and the writes the

00:22:20,809 --> 00:22:26,240
front end loves it if you want to make

00:22:23,299 --> 00:22:31,429
your front-end developers happy think

00:22:26,240 --> 00:22:33,169
about using it but what's the catch and

00:22:31,429 --> 00:22:36,740
so this is the more important part of

00:22:33,169 --> 00:22:39,890
the talk so one thing is that graphene

00:22:36,740 --> 00:22:42,679
is the only library that you know is

00:22:39,890 --> 00:22:47,659
really viable to you to implement a

00:22:42,679 --> 00:22:48,890
graph QL schema and Django and Python it

00:22:47,659 --> 00:22:50,330
was released about a year ago and you

00:22:48,890 --> 00:22:53,780
can see since then there hasn't been

00:22:50,330 --> 00:22:56,150
that much activity on it there it is a

00:22:53,780 --> 00:22:58,190
young library and there hasn't been a

00:22:56,150 --> 00:23:03,650
ton of contributions and so there are

00:22:58,190 --> 00:23:04,970
bugs there are you know so is released

00:23:03,650 --> 00:23:07,850
in 2016

00:23:04,970 --> 00:23:10,640
the docs are not super complete if you

00:23:07,850 --> 00:23:14,530
have questions often you have to ask a

00:23:10,640 --> 00:23:16,970
question as an issue in the in github

00:23:14,530 --> 00:23:19,280
also sometimes it lags behind the graph

00:23:16,970 --> 00:23:22,159
QL specs so for example total count is

00:23:19,280 --> 00:23:24,380
in the graph QL specifications but as

00:23:22,159 --> 00:23:26,240
far as I know is still not yet in the

00:23:24,380 --> 00:23:30,830
graphene library so we had to build that

00:23:26,240 --> 00:23:34,730
ourselves there are some bugs with the

00:23:30,830 --> 00:23:36,890
resolvers if it kind of has some weird

00:23:34,730 --> 00:23:38,870
logic so we've had to rewrite a lot of

00:23:36,890 --> 00:23:43,159
that logic about how things get resolved

00:23:38,870 --> 00:23:45,140
because you know first we want to return

00:23:43,159 --> 00:23:47,840
the resolver query set then we want to

00:23:45,140 --> 00:23:49,880
filter on that and then we want to do

00:23:47,840 --> 00:23:55,630
other stuff and the order that it does

00:23:49,880 --> 00:23:57,799
it by default is not right and lastly

00:23:55,630 --> 00:23:59,780
one of the big things is that the source

00:23:57,799 --> 00:24:02,659
code is quite complicated there's a lot

00:23:59,780 --> 00:24:04,970
of meta programming in it and as someone

00:24:02,659 --> 00:24:08,299
who is only an intermediate Python

00:24:04,970 --> 00:24:09,710
developer it's kind of hard to dive in

00:24:08,299 --> 00:24:13,159
and make the changes that you want to

00:24:09,710 --> 00:24:19,909
make so I would say that's kind of the

00:24:13,159 --> 00:24:22,700
biggest hurdle to using it so yeah the

00:24:19,909 --> 00:24:24,919
real world is messy and you're not gonna

00:24:22,700 --> 00:24:28,510
want to use graphene exactly in the way

00:24:24,919 --> 00:24:31,610
that it was made this is not actually

00:24:28,510 --> 00:24:35,900
spaghetti 88 just a baby I found in

00:24:31,610 --> 00:24:39,440
gippy but yeah the real world is messy

00:24:35,900 --> 00:24:42,290
and graph QL is just a query language

00:24:39,440 --> 00:24:44,780
it's not telling you how you should do

00:24:42,290 --> 00:24:49,130
certain things like authentication and

00:24:44,780 --> 00:24:55,190
authorization and and caching and stuff

00:24:49,130 --> 00:24:58,520
like that so we had to dress it still so

00:24:55,190 --> 00:25:00,890
first what about permissions you know

00:24:58,520 --> 00:25:04,370
for us permissions were a really big

00:25:00,890 --> 00:25:06,650
issue because we have different

00:25:04,370 --> 00:25:08,179
companies using our product people from

00:25:06,650 --> 00:25:11,950
one company should not be able to see

00:25:08,179 --> 00:25:11,950
any of the data from another company so

00:25:12,190 --> 00:25:17,419
one option that is kind of what the

00:25:15,799 --> 00:25:20,149
graphing Doc's say you should do is

00:25:17,419 --> 00:25:23,840
perform authorization on each resolver

00:25:20,149 --> 00:25:25,700
and that would be a pain in the butt we

00:25:23,840 --> 00:25:27,740
don't want to have to call our our DRF

00:25:25,700 --> 00:25:31,820
authorization class every time we want

00:25:27,740 --> 00:25:33,559
to get a connection the other option is

00:25:31,820 --> 00:25:35,929
to extend graphene to perform that

00:25:33,559 --> 00:25:37,790
authorization on every connection which

00:25:35,929 --> 00:25:40,970
is what we did and what I encourage you

00:25:37,790 --> 00:25:43,130
to do it's not like DRF it doesn't have

00:25:40,970 --> 00:25:45,590
all these hooks to like you know put

00:25:43,130 --> 00:25:47,630
your custom logic here you know you have

00:25:45,590 --> 00:25:50,899
to you have to actually extend the

00:25:47,630 --> 00:25:53,740
classes what we did if any of you have

00:25:50,899 --> 00:25:53,740
tried to do it

00:25:53,880 --> 00:26:03,310
so we first of all added to each node

00:26:00,370 --> 00:26:06,160
what the DRF class that we're we're

00:26:03,310 --> 00:26:08,020
using for authorization is and then we

00:26:06,160 --> 00:26:11,650
extended a Django filter connection

00:26:08,020 --> 00:26:14,230
field on the connection resolver we

00:26:11,650 --> 00:26:16,570
added the user authentication so are

00:26:14,230 --> 00:26:18,940
they logged in can they actually see any

00:26:16,570 --> 00:26:22,120
data and then when you resolve the

00:26:18,940 --> 00:26:23,080
connection we say okay from your node we

00:26:22,120 --> 00:26:24,970
know you're supposed to have this

00:26:23,080 --> 00:26:27,640
authorization class we'll apply those

00:26:24,970 --> 00:26:29,350
authorization limits on the original

00:26:27,640 --> 00:26:33,940
query set and then that's what you

00:26:29,350 --> 00:26:35,770
should use to do the rest of it so

00:26:33,940 --> 00:26:38,230
that's pretty good that's a solvable

00:26:35,770 --> 00:26:40,960
issue if not it like even though it kind

00:26:38,230 --> 00:26:42,730
of takes some effort but what if someone

00:26:40,960 --> 00:26:46,480
is requesting too much data

00:26:42,730 --> 00:26:47,920
we've got denial of service doesn't

00:26:46,480 --> 00:26:49,240
necessarily have to be an attack it

00:26:47,920 --> 00:26:52,000
could just be someone who's requesting

00:26:49,240 --> 00:26:56,560
too much data and it's hogging up time

00:26:52,000 --> 00:26:58,270
on your server and so what we did

00:26:56,560 --> 00:27:01,060
because you know you can traverse as

00:26:58,270 --> 00:27:02,890
much as you want graph QL has some

00:27:01,060 --> 00:27:04,900
things like you can't do cyclical things

00:27:02,890 --> 00:27:07,000
so you can't have an infinite loop which

00:27:04,900 --> 00:27:09,520
is good but you can just like have

00:27:07,000 --> 00:27:12,550
someone like a script create like a

00:27:09,520 --> 00:27:13,870
really big amount of stuff so what we

00:27:12,550 --> 00:27:16,960
went with that first which is the

00:27:13,870 --> 00:27:18,850
easiest way of doing it is having a

00:27:16,960 --> 00:27:20,680
white list for the allowed query so we

00:27:18,850 --> 00:27:24,310
actually had all of our queries in the

00:27:20,680 --> 00:27:26,710
back end in Python and gave each of them

00:27:24,310 --> 00:27:29,410
an identifier and then the front end

00:27:26,710 --> 00:27:32,410
would have to call that graph QL query

00:27:29,410 --> 00:27:34,090
by its name and so that way we were

00:27:32,410 --> 00:27:37,740
allowed to say these are only the

00:27:34,090 --> 00:27:42,700
queries that anyone can run on graph UL

00:27:37,740 --> 00:27:46,150
that you know works oh it works up to a

00:27:42,700 --> 00:27:47,530
point and it definitely had its downside

00:27:46,150 --> 00:27:50,920
so we were trying to move away from that

00:27:47,530 --> 00:27:54,580
so another thing you can do which github

00:27:50,920 --> 00:27:58,060
but first did is add a maximum limit to

00:27:54,580 --> 00:28:01,120
any connection so there's at first was

00:27:58,060 --> 00:28:02,860
30 now it's a hundred so every time you

00:28:01,120 --> 00:28:06,060
want to get a list of stuff you have to

00:28:02,860 --> 00:28:06,060
define how much you want

00:28:06,210 --> 00:28:11,070
they also have implemented a maximum

00:28:09,150 --> 00:28:14,780
query cost which is something that we

00:28:11,070 --> 00:28:18,900
have only just done last month finally

00:28:14,780 --> 00:28:22,520
so you can say you know you can max

00:28:18,900 --> 00:28:26,160
Axess 5,000 nodes on any given query and

00:28:22,520 --> 00:28:28,620
this is how github calculates theirs we

00:28:26,160 --> 00:28:30,450
do it a little differently but you know

00:28:28,620 --> 00:28:33,539
having it there is awesome and it

00:28:30,450 --> 00:28:35,309
enforces limits as well because we just

00:28:33,539 --> 00:28:38,480
said if you don't have a limit then

00:28:35,309 --> 00:28:42,900
we're assuming you're getting a thousand

00:28:38,480 --> 00:28:45,299
and something graph you all also has is

00:28:42,900 --> 00:28:48,570
rate limiting based on query cost so

00:28:45,299 --> 00:28:50,580
before there v3 API had a certain rate

00:28:48,570 --> 00:28:51,929
limit now you can't that rate limit

00:28:50,580 --> 00:28:54,630
doesn't make as much sense since you can

00:28:51,929 --> 00:28:57,510
grab so much more data so it has a

00:28:54,630 --> 00:28:59,400
different way of calculating the cost

00:28:57,510 --> 00:29:00,960
that's based on the number of database

00:28:59,400 --> 00:29:02,990
connections that you're actually getting

00:29:00,960 --> 00:29:08,630
and so they rate limit you based on that

00:29:02,990 --> 00:29:12,289
and so lastly what about performance and

00:29:08,630 --> 00:29:14,549
for some people this is the big elephant

00:29:12,289 --> 00:29:19,679
everyone uses this so I add it to my

00:29:14,549 --> 00:29:24,419
slide so sometimes these queries take a

00:29:19,679 --> 00:29:26,549
lot of time and Django graphine doesn't

00:29:24,419 --> 00:29:28,860
really at first especially at the

00:29:26,549 --> 00:29:31,080
beginning didn't really do much to focus

00:29:28,860 --> 00:29:32,610
on performance and it mostly focused on

00:29:31,080 --> 00:29:34,980
getting it to work

00:29:32,610 --> 00:29:36,720
since v1 has came out that was like a

00:29:34,980 --> 00:29:38,010
big performance improvement but there's

00:29:36,720 --> 00:29:42,090
still a lot more that can be done for

00:29:38,010 --> 00:29:44,669
example by default it doesn't do select

00:29:42,090 --> 00:29:48,350
related and prefetch related when it

00:29:44,669 --> 00:29:51,240
resolves the query as it traverses it

00:29:48,350 --> 00:29:53,909
which is not necessarily the it's not

00:29:51,240 --> 00:29:56,929
the most performant something we also

00:29:53,909 --> 00:30:01,429
did is reduce the number of count calls

00:29:56,929 --> 00:30:04,770
other so something you can do instead is

00:30:01,429 --> 00:30:09,480
have something that looks at the entire

00:30:04,770 --> 00:30:11,740
query and and adds things to it and

00:30:09,480 --> 00:30:14,649
resolve it all at once

00:30:11,740 --> 00:30:16,570
so that brings us to the data loader

00:30:14,649 --> 00:30:22,840
this is Facebook's answer to the

00:30:16,570 --> 00:30:24,549
performance issues so initially like

00:30:22,840 --> 00:30:28,840
without the data loader this could take

00:30:24,549 --> 00:30:30,880
thirteen database calls for all these

00:30:28,840 --> 00:30:33,610
different fields right it's a lot of

00:30:30,880 --> 00:30:36,700
database queries but what the data

00:30:33,610 --> 00:30:40,809
loader does is it analyzes everything

00:30:36,700 --> 00:30:44,049
which returns a promise and then it

00:30:40,809 --> 00:30:46,090
batches grabbing things so if you have a

00:30:44,049 --> 00:30:49,210
bunch of users here in the friends that

00:30:46,090 --> 00:30:50,740
have the same PK then you don't have to

00:30:49,210 --> 00:30:56,470
get them multiple times you just get

00:30:50,740 --> 00:30:57,909
them in one big batch so having a max

00:30:56,470 --> 00:31:00,850
query cost also helps with the

00:30:57,909 --> 00:31:02,350
performance issue and for us one of the

00:31:00,850 --> 00:31:04,390
biggest thing is just front-end

00:31:02,350 --> 00:31:08,529
education about how to use graph QL

00:31:04,390 --> 00:31:09,850
since this was a back-end initiative you

00:31:08,529 --> 00:31:11,770
know they were like hey okay we'll use

00:31:09,850 --> 00:31:13,299
it that's cool and they really liked it

00:31:11,770 --> 00:31:15,010
but they didn't necessarily know much

00:31:13,299 --> 00:31:17,020
about it and they see it more as a

00:31:15,010 --> 00:31:19,149
back-end thing than a front-end thing

00:31:17,020 --> 00:31:21,070
and so they're like we'll get all the

00:31:19,149 --> 00:31:23,409
data especially before we had the query

00:31:21,070 --> 00:31:25,659
class and they were doing things like

00:31:23,409 --> 00:31:28,149
this where they're saying I have all

00:31:25,659 --> 00:31:29,950
these goals give me the idea of all of

00:31:28,149 --> 00:31:32,260
them and then in the front-end I'm just

00:31:29,950 --> 00:31:34,809
going to count the entire length and

00:31:32,260 --> 00:31:36,520
that's gonna then that's all I need that

00:31:34,809 --> 00:31:39,850
we're like I actually don't get any of

00:31:36,520 --> 00:31:43,059
that and just get the count if you're

00:31:39,850 --> 00:31:46,000
only going to show to like either the

00:31:43,059 --> 00:31:47,679
full name or if there's more than to one

00:31:46,000 --> 00:31:51,330
person than just the number of people

00:31:47,679 --> 00:31:51,330
then just grab the first person

00:31:52,320 --> 00:31:59,380
yeah and this is you know 34 comments on

00:31:57,520 --> 00:32:03,430
here this is one of the longer issues in

00:31:59,380 --> 00:32:05,590
github about graphene and you know you

00:32:03,430 --> 00:32:07,240
can follow it it keeps changing its kind

00:32:05,590 --> 00:32:10,540
of interesting he's added a whole bunch

00:32:07,240 --> 00:32:13,180
of new stuff but there's still more work

00:32:10,540 --> 00:32:16,780
to be done so there are some

00:32:13,180 --> 00:32:20,860
considerations it's still a young

00:32:16,780 --> 00:32:24,610
library I'm hoping Cyrus isn't here

00:32:20,860 --> 00:32:27,100
today is he no ok the maintainer like I

00:32:24,610 --> 00:32:28,630
was hoping to like maybe we could sprint

00:32:27,100 --> 00:32:31,120
on it tomorrow but I actually don't know

00:32:28,630 --> 00:32:33,550
how much he's into that but yeah I could

00:32:31,120 --> 00:32:37,570
use some work because especially because

00:32:33,550 --> 00:32:39,760
graph QL is just a query language and it

00:32:37,570 --> 00:32:42,220
doesn't specify had to do things so how

00:32:39,760 --> 00:32:46,330
would graphene know what to do about

00:32:42,220 --> 00:32:48,760
these things yeah and then authorization

00:32:46,330 --> 00:32:50,170
denial of service and performance are

00:32:48,760 --> 00:32:53,740
some of the big things that you have to

00:32:50,170 --> 00:32:56,590
look at if you are using it so should

00:32:53,740 --> 00:33:00,990
you use it who is maybe considering

00:32:56,590 --> 00:33:04,300
using it now after this talk that's cool

00:33:00,990 --> 00:33:07,180
so go for it if it's just a side project

00:33:04,300 --> 00:33:11,590
and for fun it is really fun to know and

00:33:07,180 --> 00:33:13,930
to like have as a tool that you know so

00:33:11,590 --> 00:33:17,590
also if rest is causing some performance

00:33:13,930 --> 00:33:18,940
issues that you're like I actually don't

00:33:17,590 --> 00:33:21,400
know how to get around this I could

00:33:18,940 --> 00:33:22,870
replace all my serializes serializers

00:33:21,400 --> 00:33:27,430
with something faster but you know

00:33:22,870 --> 00:33:29,740
that's a lot of work also if your rest

00:33:27,430 --> 00:33:34,450
format is making it difficult to read or

00:33:29,740 --> 00:33:37,090
write things and importantly though you

00:33:34,450 --> 00:33:38,950
have the resources and like development

00:33:37,090 --> 00:33:44,770
experience to know how to extend it in

00:33:38,950 --> 00:33:47,560
the way that you want and you know hold

00:33:44,770 --> 00:33:49,960
up just like back off a little bit I

00:33:47,560 --> 00:33:52,570
mean you should still try to do it but

00:33:49,960 --> 00:33:55,390
think about it if you have a lot of

00:33:52,570 --> 00:33:57,220
sensitive information and/or you're

00:33:55,390 --> 00:33:58,420
trying to create a public API in which

00:33:57,220 --> 00:34:01,780
case you have to worry about rate

00:33:58,420 --> 00:34:03,610
limiting and query costs and you don't

00:34:01,780 --> 00:34:04,940
have enough development resources to do

00:34:03,610 --> 00:34:07,369
it

00:34:04,940 --> 00:34:12,649
or not enough experiment experience to

00:34:07,369 --> 00:34:15,319
know how to extend it so that's pretty

00:34:12,649 --> 00:34:17,990
much it here there's a lot of great

00:34:15,319 --> 00:34:22,040
resources on the web the zero de Graaff

00:34:17,990 --> 00:34:23,750
QL video is you know probably the one

00:34:22,040 --> 00:34:30,399
that's posted everywhere about a good

00:34:23,750 --> 00:34:30,399
intro yeah and so thank you very much

00:34:32,980 --> 00:34:44,899
thank you what database engines do you

00:34:37,760 --> 00:34:50,599
recommend for the supporting this I'm

00:34:44,899 --> 00:34:53,409
not sure we use my sequel and is that

00:34:50,599 --> 00:34:58,369
what you mean by database engines ok

00:34:53,409 --> 00:35:00,290
yeah because you can it really it

00:34:58,369 --> 00:35:03,079
doesn't matter I don't think maybe for

00:35:00,290 --> 00:35:05,000
performance it could be a lot better for

00:35:03,079 --> 00:35:07,670
one or the other but I can't say for

00:35:05,000 --> 00:35:09,170
sure first of all thank you I've been

00:35:07,670 --> 00:35:10,220
wanting to learn more about this for a

00:35:09,170 --> 00:35:13,160
long time so it's great to have somebody

00:35:10,220 --> 00:35:15,440
whose experience explain it to us

00:35:13,160 --> 00:35:17,660
I think the part of it that I don't

00:35:15,440 --> 00:35:20,990
quite understand is how do I have to do

00:35:17,660 --> 00:35:23,839
something special when I create my data

00:35:20,990 --> 00:35:25,880
models like if I I like to make lots of

00:35:23,839 --> 00:35:28,339
little like Union tables for permissions

00:35:25,880 --> 00:35:30,319
and stuff like that is that does that

00:35:28,339 --> 00:35:32,359
work with this can I just use what I

00:35:30,319 --> 00:35:35,359
already have or do I have to redesign

00:35:32,359 --> 00:35:39,650
the way that I handle I store my data to

00:35:35,359 --> 00:35:43,700
use this stuff I don't exactly know what

00:35:39,650 --> 00:35:46,010
you mean by Union models but we've used

00:35:43,700 --> 00:35:48,530
all of our same authorization from

00:35:46,010 --> 00:35:53,000
Django rest framework there you can just

00:35:48,530 --> 00:35:55,010
kind of like add to the node so we added

00:35:53,000 --> 00:35:56,480
an authorization model to the node so if

00:35:55,010 --> 00:35:59,809
you have other things that you want and

00:35:56,480 --> 00:36:00,740
then on a higher level the Django

00:35:59,809 --> 00:36:03,890
connection field

00:36:00,740 --> 00:36:06,609
what's a node oh yeah no thank you

00:36:03,890 --> 00:36:06,609
so

00:36:08,550 --> 00:36:11,689
[Music]

00:36:13,030 --> 00:36:20,950
so the yellow circles are nodes and so

00:36:18,700 --> 00:36:22,570
in this example it's like list user and

00:36:20,950 --> 00:36:27,190
to do our different nodes that for us

00:36:22,570 --> 00:36:29,830
they relate to our models yeah so so

00:36:27,190 --> 00:36:33,280
it's just like I don't know

00:36:29,830 --> 00:36:37,390
that make sense so they're the the parts

00:36:33,280 --> 00:36:41,350
of the graph that you can traverse that

00:36:37,390 --> 00:36:42,760
are not scalar types so so they're the

00:36:41,350 --> 00:36:46,000
ones that you create yourself and

00:36:42,760 --> 00:36:48,640
they're the ones that you yeah

00:36:46,000 --> 00:36:50,710
define based on your models or the way

00:36:48,640 --> 00:36:53,830
that your business logic is as like a

00:36:50,710 --> 00:36:56,370
resource it's like a resource right so

00:36:53,830 --> 00:36:59,560
if I if I'm assuming that that map's to

00:36:56,370 --> 00:37:02,320
like a normal Django model that I have

00:36:59,560 --> 00:37:06,130
what if I have a foreign key yeah how

00:37:02,320 --> 00:37:08,350
does does is just graphene do the kind

00:37:06,130 --> 00:37:09,820
of right traversal to the foreign keys

00:37:08,350 --> 00:37:12,730
for me automatically is that the whole

00:37:09,820 --> 00:37:18,190
point it does do it automatically but

00:37:12,730 --> 00:37:22,840
you can also you'd also can add as much

00:37:18,190 --> 00:37:27,480
or as little as you want to it so for

00:37:22,840 --> 00:37:33,220
example this goal node if I don't have

00:37:27,480 --> 00:37:35,020
this it'll still have tasks or well

00:37:33,220 --> 00:37:37,320
actually my models are my models are

00:37:35,020 --> 00:37:40,300
actually different as I'm showing a

00:37:37,320 --> 00:37:43,420
something not based on the okay our goal

00:37:40,300 --> 00:37:47,880
methodology that we use so if I remove

00:37:43,420 --> 00:37:51,610
these fields it'll have a key results

00:37:47,880 --> 00:37:57,550
which is like tasks already on it but

00:37:51,610 --> 00:38:00,820
it's just the default settings I can do

00:37:57,550 --> 00:38:03,880
this to say actually change that field

00:38:00,820 --> 00:38:06,010
from the original name key results to

00:38:03,880 --> 00:38:07,960
the name tasks and then I can add

00:38:06,010 --> 00:38:12,460
different things in here so I can add a

00:38:07,960 --> 00:38:13,870
description for the docs I can for

00:38:12,460 --> 00:38:16,840
different fields you can add the

00:38:13,870 --> 00:38:19,090
defaults and whatever and then if you

00:38:16,840 --> 00:38:20,770
want to limit the subset of tasks that

00:38:19,090 --> 00:38:24,270
actually receives because right now is

00:38:20,770 --> 00:38:24,270
getting all of them

00:38:25,280 --> 00:38:29,270
actually I would need to do this if I

00:38:26,780 --> 00:38:31,000
need to to change the name right now

00:38:29,270 --> 00:38:33,950
it's getting all of them you can also

00:38:31,000 --> 00:38:36,050
use the resolver to change the

00:38:33,950 --> 00:38:39,950
functionality of what the default is and

00:38:36,050 --> 00:38:48,920
send you know a filtered list of tasks

00:38:39,950 --> 00:38:50,390
down like that and so this is the query

00:38:48,920 --> 00:38:53,960
set that it's going to return from the

00:38:50,390 --> 00:38:56,450
resolver and then the authorization is

00:38:53,960 --> 00:39:00,110
going to be on that and any filters that

00:38:56,450 --> 00:39:03,310
you add are going to be on that first of

00:39:00,110 --> 00:39:03,310
all thanks for the talk is really great

00:39:05,390 --> 00:39:09,290
I was curious when creating graphical

00:39:07,430 --> 00:39:10,910
endpoints in practice in a real

00:39:09,290 --> 00:39:13,480
production application do you find

00:39:10,910 --> 00:39:16,760
yourself making basically one giant

00:39:13,480 --> 00:39:18,350
graph QL like endpoint that we can get

00:39:16,760 --> 00:39:20,630
everything or do you like tailor it to

00:39:18,350 --> 00:39:23,900
more specific pages or use cases like

00:39:20,630 --> 00:39:28,100
how do you divide that up yeah so we do

00:39:23,900 --> 00:39:30,010
have one big schema that you can access

00:39:28,100 --> 00:39:32,900
from you know all these different nodes

00:39:30,010 --> 00:39:34,340
but that's based on our app if you

00:39:32,900 --> 00:39:36,440
wanted to have different endpoints you

00:39:34,340 --> 00:39:38,870
can easily do that in URLs and just have

00:39:36,440 --> 00:39:43,400
different versions of the schema in

00:39:38,870 --> 00:39:45,500
different places actually yeah I think

00:39:43,400 --> 00:39:49,370
there's some sort of setting to say

00:39:45,500 --> 00:39:51,590
which view uses which schema and I think

00:39:49,370 --> 00:39:53,060
right now that's in the settings up high

00:39:51,590 --> 00:39:54,470
I actually don't remember I think it

00:39:53,060 --> 00:39:55,730
might just look for it automatically but

00:39:54,470 --> 00:39:58,370
you can just set up two different

00:39:55,730 --> 00:39:59,870
schemas if that works for you do you

00:39:58,370 --> 00:40:01,550
have a recommendation on what like in

00:39:59,870 --> 00:40:03,080
your experience over the last year so

00:40:01,550 --> 00:40:04,580
like what has worked better for you is

00:40:03,080 --> 00:40:06,590
it easier just to keep everything in one

00:40:04,580 --> 00:40:08,990
place yeah because you don't know when

00:40:06,590 --> 00:40:11,960
you're gonna need something from from a

00:40:08,990 --> 00:40:14,600
different part of the app like ours are

00:40:11,960 --> 00:40:16,330
all kind of interrelated anyways so it

00:40:14,600 --> 00:40:19,370
makes sense to have all that information

00:40:16,330 --> 00:40:20,840
available like a user for a user I need

00:40:19,370 --> 00:40:22,910
to know everything that they've done how

00:40:20,840 --> 00:40:25,070
many recognitions have they received how

00:40:22,910 --> 00:40:27,020
many goals have they created and checked

00:40:25,070 --> 00:40:27,650
in too so that makes sense for us sure

00:40:27,020 --> 00:40:33,440
yeah that makes sense

00:40:27,650 --> 00:40:35,480
Thanks I saw the the interactive like

00:40:33,440 --> 00:40:38,440
query builder where you can start

00:40:35,480 --> 00:40:42,160
building your query yeah this

00:40:38,440 --> 00:40:44,830
mean that the server is exposing some

00:40:42,160 --> 00:40:46,720
sort of schema to the client I mean

00:40:44,830 --> 00:40:50,350
because something that I would like to

00:40:46,720 --> 00:40:52,990
do in in the client side is have a

00:40:50,350 --> 00:40:55,450
schema that I can use either to validate

00:40:52,990 --> 00:40:56,920
data as it comes in or to auto-generate

00:40:55,450 --> 00:41:01,300
forms instead of having to actually

00:40:56,920 --> 00:41:03,910
create the form tags if I if graph QL is

00:41:01,300 --> 00:41:06,310
exposing the schema I was wondering if I

00:41:03,910 --> 00:41:10,120
can use that in JavaScript yeah

00:41:06,310 --> 00:41:12,970
so it has introspection and can tell you

00:41:10,120 --> 00:41:13,870
what the schema is and people have used

00:41:12,970 --> 00:41:16,960
it

00:41:13,870 --> 00:41:20,650
thinking typescript I don't know if it

00:41:16,960 --> 00:41:26,530
worked very well but it is possible to

00:41:20,650 --> 00:41:28,960
get what that schema is yeah another

00:41:26,530 --> 00:41:31,630
thing I didn't mention is when we use

00:41:28,960 --> 00:41:35,770
the white listing query method we

00:41:31,630 --> 00:41:37,330
actually didn't expose that view to the

00:41:35,770 --> 00:41:41,140
outside world you can only use it in

00:41:37,330 --> 00:41:46,180
development just you know so other

00:41:41,140 --> 00:41:47,860
people can rents up on it yeah so all of

00:41:46,180 --> 00:41:49,960
those extensions you've made like for

00:41:47,860 --> 00:41:52,270
the authorization your extensions to the

00:41:49,960 --> 00:41:54,400
filter connection field are those things

00:41:52,270 --> 00:41:59,230
that we can expect to see an upstream

00:41:54,400 --> 00:41:59,830
graphene at some point I'm really hoping

00:41:59,230 --> 00:42:01,390
so

00:41:59,830 --> 00:42:03,310
I think now that I've given this talk

00:42:01,390 --> 00:42:05,230
there's more incentive for us to get

00:42:03,310 --> 00:42:08,370
things merged and not just like keep it

00:42:05,230 --> 00:42:08,370
in our own utils library

00:42:08,580 --> 00:42:16,990
besides that like I think what we should

00:42:13,570 --> 00:42:18,130
do is add pull request to it and

00:42:16,990 --> 00:42:20,320
regardless of whether you they get

00:42:18,130 --> 00:42:23,310
merged you can see what we've done and

00:42:20,320 --> 00:42:23,310
just copy it into yours

00:42:24,450 --> 00:42:28,400
that's our time sorry so let's thank

00:42:26,730 --> 00:42:35,860
Arianne for her great talk

00:42:28,400 --> 00:42:35,860

YouTube URL: https://www.youtube.com/watch?v=bTh-JPgKKdQ


