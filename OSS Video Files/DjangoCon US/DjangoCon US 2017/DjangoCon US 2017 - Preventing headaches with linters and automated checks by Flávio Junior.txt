Title: DjangoCon US 2017 - Preventing headaches with linters and automated checks by Flávio Junior
Publication date: 2017-09-08
Playlist: DjangoCon US 2017
Description: 
	DjangoCon US 2017 - Preventing headaches with linters and automated checks by Flávio Junior

While it’s very common to enforce PEP8 code style with tools like flake8, it’s rare for Django projects to use any other types of tools for automated checks. However, linters and automated checks are a good way to enforce code quality beyond code style. Human-based code reviews are great, but if an experienced programmer leaves the organization, all quality-related knowledge they have will be gone. One way to prevent this is to make developers consolidate their knowledge as custom check tools. Instead of repeating to every junior programmer how they should code, experienced developers should write tools to do that for them. Having this kind of “executable knowledge” is great to ensure long-lasting good practices in organizations.

Thankfully, Python already has a number of extensible linters and check tools that can be used to consolidate knowledge. Also, Django has the System check framework, which can be used to write custom static validations to Django projects. In this talk, we’ll discuss existing linters and tools, what benefit they bring to Django projects, how to extend them and how to build custom ones. Combined with IDEs, pre-commit hooks, and CI tools, linters can validate code at programming time, commit time, or CI time, thereby ensuring good practices in all development workflow.

This talk was presented at: https://2017.djangocon.us/talks/preventing-headaches-with-linters-and-automated-checks/

LINKS:
Follow Flávio Junior 👇
On Twitter: https://twitter.com/flaviojuvenal
Official homepage: https://www.vinta.com.br

Follow DjangCon US 👇
https://twitter.com/djangocon

Follow DEFNA 👇
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:20,600
[Music]

00:00:14,110 --> 00:00:22,970
thank you all like like she said my name

00:00:20,600 --> 00:00:42,440
is Flavio and I'm going to talk about

00:00:22,970 --> 00:00:45,109
litres is it it's fine oh hello if any

00:00:42,440 --> 00:00:50,390
of you can't hear me well just let me

00:00:45,109 --> 00:00:53,539
know just and okay so these lights are

00:00:50,390 --> 00:00:56,750
here really happy to be with you all

00:00:53,539 --> 00:00:58,910
today here I'm finding this conference

00:00:56,750 --> 00:01:01,489
really great really congratulate the

00:00:58,910 --> 00:01:04,250
organizers organizers the sponsors

00:01:01,489 --> 00:01:07,400
everyone with volunteering been really

00:01:04,250 --> 00:01:12,200
nice if you want to check the slides

00:01:07,400 --> 00:01:15,830
they are here I work at veinte from

00:01:12,200 --> 00:01:18,920
Brazil on a CD called her hissy fit the

00:01:15,830 --> 00:01:20,689
CD I was born E and excited to start

00:01:18,920 --> 00:01:23,360
inter because I couldn't find a great

00:01:20,689 --> 00:01:25,340
place to work with Django and Python on

00:01:23,360 --> 00:01:26,960
my CD and we started winter with other

00:01:25,340 --> 00:01:31,070
partners and we work with companies

00:01:26,960 --> 00:01:32,750
worldwide doing development services

00:01:31,070 --> 00:01:37,430
cool stone web development with Django

00:01:32,750 --> 00:01:39,920
and reactors

00:01:37,430 --> 00:01:42,799
what are they why using them how to

00:01:39,920 --> 00:01:45,710
implement them when to run them and

00:01:42,799 --> 00:01:49,759
which ones exist and we can use in our

00:01:45,710 --> 00:01:55,149
Django projects first of all what what

00:01:49,759 --> 00:01:58,430
are these themes I I'm not sure if

00:01:55,149 --> 00:02:01,840
native speakers know that I didn't knew

00:01:58,430 --> 00:02:05,240
but linked is that little thing that

00:02:01,840 --> 00:02:07,250
little thing that called I really like

00:02:05,240 --> 00:02:10,640
that that nation is clinging for this

00:02:07,250 --> 00:02:12,830
plug that accumulates and this last part

00:02:10,640 --> 00:02:16,100
and we hate I just added it but you can

00:02:12,830 --> 00:02:20,450
check that on Wiktionary it's a real

00:02:16,100 --> 00:02:22,129
definition and also good suggestion here

00:02:20,450 --> 00:02:24,709
clinging fuzzy fluff I think it's a

00:02:22,129 --> 00:02:26,240
really good name for an indie band so if

00:02:24,709 --> 00:02:30,260
you are looking for our name for

00:02:26,240 --> 00:02:33,680
our indie band that's an idea here and a

00:02:30,260 --> 00:02:36,080
link to it's not not many people called

00:02:33,680 --> 00:02:38,330
diesel inter but some do it's that thing

00:02:36,080 --> 00:02:41,680
that removed that little stuff that we

00:02:38,330 --> 00:02:44,060
hate and this is also valid for software

00:02:41,680 --> 00:02:46,810
there is link turns on software that

00:02:44,060 --> 00:02:49,340
analyze code to find flaws and errors

00:02:46,810 --> 00:02:54,170
helping to remove that cleaning for the

00:02:49,340 --> 00:02:56,660
flow that we red tape and here is a very

00:02:54,170 --> 00:02:59,870
basic example using PI flakes I think

00:02:56,660 --> 00:03:01,790
the most well-known linker on Python

00:02:59,870 --> 00:03:05,270
data can detect that you are my son

00:03:01,790 --> 00:03:08,420
function uses its duplicating their

00:03:05,270 --> 00:03:13,700
argument X you can finds that in this is

00:03:08,420 --> 00:03:18,950
quite a common bug that we may we make

00:03:13,700 --> 00:03:21,260
do ok but why you may not become he said

00:03:18,950 --> 00:03:23,660
okay but I don't make this kind of

00:03:21,260 --> 00:03:25,810
mistake so I got an expert developer I

00:03:23,660 --> 00:03:28,750
don't need that okay

00:03:25,810 --> 00:03:35,440
what's wrong with this code can anybody

00:03:28,750 --> 00:03:44,270
find error here get anyone what's wrong

00:03:35,440 --> 00:03:47,330
ten seconds don't wanna find error is

00:03:44,270 --> 00:03:50,830
that it turned yeah missing the return

00:03:47,330 --> 00:03:54,650
like if you are overriding first set

00:03:50,830 --> 00:03:56,630
remember that future expert all those

00:03:54,650 --> 00:03:58,280
things return a new query said so you

00:03:56,630 --> 00:03:59,750
need to attribute it again to the

00:03:58,280 --> 00:04:02,300
variable you are working where for you

00:03:59,750 --> 00:04:06,040
need to return so this is a sort of book

00:04:02,300 --> 00:04:09,140
that many Django developers already did

00:04:06,040 --> 00:04:12,320
and can our linter II really detect this

00:04:09,140 --> 00:04:15,620
kind of things yes it can yes I can and

00:04:12,320 --> 00:04:17,660
we'll see how and linters prevent bad

00:04:15,620 --> 00:04:20,299
sigh oh it's the first thing that

00:04:17,660 --> 00:04:23,420
winters were made for but they also can

00:04:20,299 --> 00:04:25,010
prevent bad patterns bugs and even

00:04:23,420 --> 00:04:28,580
security vulnerabilities there are

00:04:25,010 --> 00:04:30,860
leaders for that in Python you know

00:04:28,580 --> 00:04:32,810
another thing that many people don't

00:04:30,860 --> 00:04:35,169
consider but I think is really important

00:04:32,810 --> 00:04:38,090
is that expert developers know language

00:04:35,169 --> 00:04:40,310
framework library related queries and

00:04:38,090 --> 00:04:41,870
common mistakes and maybe though

00:04:40,310 --> 00:04:45,290
expert developers should write that

00:04:41,870 --> 00:04:47,570
knowledge down as linter checks and this

00:04:45,290 --> 00:04:52,220
way the the knowledge is perpetuated

00:04:47,570 --> 00:04:54,710
into checks and it will go and do a lot

00:04:52,220 --> 00:04:57,230
of benefit the community

00:04:54,710 --> 00:05:01,190
so for organizations linters can

00:04:57,230 --> 00:05:02,870
consolidate knowledge therefore in this

00:05:01,190 --> 00:05:05,210
way you can enforce long lasting good

00:05:02,870 --> 00:05:07,310
practices you can automate code quality

00:05:05,210 --> 00:05:09,110
checks and you can even help to train

00:05:07,310 --> 00:05:11,810
your developers and in fact

00:05:09,110 --> 00:05:14,350
organizations are already doing this I

00:05:11,810 --> 00:05:16,580
don't know much about closing source

00:05:14,350 --> 00:05:18,740
organizations but open source orgs are

00:05:16,580 --> 00:05:21,940
doing these twists that has its own

00:05:18,740 --> 00:05:25,910
checker with pilot and fly gate plugins

00:05:21,940 --> 00:05:28,760
opens type to EDX to south stack to all

00:05:25,910 --> 00:05:31,970
of them implemented with my code silo

00:05:28,760 --> 00:05:34,490
placate pilot bandit plugins because

00:05:31,970 --> 00:05:37,820
those linkers are extensible in you can

00:05:34,490 --> 00:05:39,350
write your own check for them and the

00:05:37,820 --> 00:05:41,480
kind of things that organizations are

00:05:39,350 --> 00:05:43,310
shaking I like if you are using some

00:05:41,480 --> 00:05:45,530
blacklisted modules or module that

00:05:43,310 --> 00:05:49,790
should be test only and should shouldn't

00:05:45,530 --> 00:05:51,860
be used in the real code that for the

00:05:49,790 --> 00:05:54,350
project on the project inconsistent

00:05:51,860 --> 00:05:56,120
string formatting unfortunately a string

00:05:54,350 --> 00:05:58,520
for writing in Python doesn't respect

00:05:56,120 --> 00:06:00,740
the single way single obvious way to do

00:05:58,520 --> 00:06:02,570
something right now there are many ways

00:06:00,740 --> 00:06:05,420
to string formatting Python so you can

00:06:02,570 --> 00:06:08,780
write a check to prevent that you can

00:06:05,420 --> 00:06:11,930
like make people aware that they are

00:06:08,780 --> 00:06:14,720
forgetting to call supper on unit tests

00:06:11,930 --> 00:06:16,870
at our port Islam and anyway there are

00:06:14,720 --> 00:06:19,730
many many things you can check and

00:06:16,870 --> 00:06:21,380
organizations are doing this also

00:06:19,730 --> 00:06:25,100
another thing that linkers do it that

00:06:21,380 --> 00:06:27,740
they make better UX for libraries and

00:06:25,100 --> 00:06:30,410
frameworks because error prevention is

00:06:27,740 --> 00:06:32,150
good UX and in fact general does that

00:06:30,410 --> 00:06:34,820
many people don't know but general

00:06:32,150 --> 00:06:36,710
computing with some checks the system

00:06:34,820 --> 00:06:39,530
check framework with some buting checks

00:06:36,710 --> 00:06:42,470
that you can run with python minute or

00:06:39,530 --> 00:06:44,990
two I check if you have a person for

00:06:42,470 --> 00:06:49,280
example project that's duplicating the

00:06:44,990 --> 00:06:52,220
namespace for for the URL into two

00:06:49,280 --> 00:06:53,500
different apps app one app one but it

00:06:52,220 --> 00:06:55,570
should be at one app too

00:06:53,500 --> 00:06:57,940
if you run the check it will detect that

00:06:55,570 --> 00:07:01,300
for you to show a warning

00:06:57,940 --> 00:07:05,950
anyway true return that comment with an

00:07:01,300 --> 00:07:09,460
nonzero exit code and then you can run

00:07:05,950 --> 00:07:13,720
this even as a part of your CI to to

00:07:09,460 --> 00:07:15,130
check for this kind of stuff but there

00:07:13,720 --> 00:07:17,980
are many shocks that Django doesn't

00:07:15,130 --> 00:07:20,530
implement yet but it could for example

00:07:17,980 --> 00:07:23,410
if you if you use on are a field this is

00:07:20,530 --> 00:07:25,950
straightforward Django Docs you should

00:07:23,410 --> 00:07:29,350
make sure that you are passing callable

00:07:25,950 --> 00:07:32,290
before because incorrectly using Defoe

00:07:29,350 --> 00:07:34,570
with empty lists create some with

00:07:32,290 --> 00:07:36,790
waterfall that is shared between noun

00:07:34,570 --> 00:07:40,030
instances of a ref you then you probably

00:07:36,790 --> 00:07:41,620
don't want that and that's just on for

00:07:40,030 --> 00:07:45,520
Django and we can work on that on

00:07:41,620 --> 00:07:48,580
Springs I'm really happy to join someone

00:07:45,520 --> 00:07:51,700
to work on this is that perhaps every

00:07:48,580 --> 00:07:53,860
ensure remember - don't forget or

00:07:51,700 --> 00:07:56,290
similar warnings that are on the docs

00:07:53,860 --> 00:07:58,720
should become a new system check this

00:07:56,290 --> 00:08:02,050
way developers would be able to check

00:07:58,720 --> 00:08:04,540
their own code and prevent bugs or

00:08:02,050 --> 00:08:06,520
mistakes because they forgot to read the

00:08:04,540 --> 00:08:10,450
documentation where were they missed

00:08:06,520 --> 00:08:13,210
something okay but how how can we write

00:08:10,450 --> 00:08:16,050
those checks we can either do via

00:08:13,210 --> 00:08:18,340
dynamic analysis or static analysis

00:08:16,050 --> 00:08:21,130
dynamic analysis is performed by

00:08:18,340 --> 00:08:23,740
executing code not necessarily at

00:08:21,130 --> 00:08:26,560
runtime you can just run the code to

00:08:23,740 --> 00:08:29,560
check it but you have to run the code in

00:08:26,560 --> 00:08:30,700
order to work certain checks need need

00:08:29,560 --> 00:08:33,070
to be dynamic

00:08:30,700 --> 00:08:34,839
for example they need to execute Django

00:08:33,070 --> 00:08:37,450
they need to introspect models of

00:08:34,839 --> 00:08:39,580
something I check for an applied

00:08:37,450 --> 00:08:40,030
migration it's an example you can't do

00:08:39,580 --> 00:08:41,740
that

00:08:40,030 --> 00:08:43,719
statically you need to connect to your

00:08:41,740 --> 00:08:46,570
database to check if the migration isn't

00:08:43,719 --> 00:08:49,930
applied and Django system check

00:08:46,570 --> 00:08:52,990
framework is dynamic we can solve this

00:08:49,930 --> 00:08:56,020
problem that I just told you of setting

00:08:52,990 --> 00:08:59,620
up empty list the foe to array field

00:08:56,020 --> 00:09:01,900
with a dynamic check let's see how so

00:08:59,620 --> 00:09:07,680
like demo because live demos never go

00:09:01,900 --> 00:09:11,460
wrong so I have here the model

00:09:07,680 --> 00:09:14,160
okay with empty lists as the default and

00:09:11,460 --> 00:09:17,700
it's an array field so it's wrong

00:09:14,160 --> 00:09:21,149
because other like outposts we share the

00:09:17,700 --> 00:09:24,630
same default the same tags it's not good

00:09:21,149 --> 00:09:28,080
and we can write like that checks that

00:09:24,630 --> 00:09:30,420
py file or something that we import the

00:09:28,080 --> 00:09:33,140
register from checks with your arrives

00:09:30,420 --> 00:09:37,170
at the function the check function and

00:09:33,140 --> 00:09:41,270
inside this check function we iterate

00:09:37,170 --> 00:09:45,060
over all models from our apps and

00:09:41,270 --> 00:09:48,959
iterate over our fields for these models

00:09:45,060 --> 00:09:51,990
and if the field is an array field if

00:09:48,959 --> 00:09:54,660
the field has a dafoe and this before is

00:09:51,990 --> 00:09:57,149
not callable then this is an error and

00:09:54,660 --> 00:10:00,690
we just append the error here in this

00:09:57,149 --> 00:10:02,550
errors list any there are sales few

00:10:00,690 --> 00:10:04,740
users that they for instance that shared

00:10:02,550 --> 00:10:07,950
between blah blah blah user palamoun

00:10:04,740 --> 00:10:12,570
sell and then add dessert they release

00:10:07,950 --> 00:10:15,990
return deserve if we run like I had to

00:10:12,570 --> 00:10:17,930
of course I had to add these checks up

00:10:15,990 --> 00:10:23,400
here on star depth

00:10:17,930 --> 00:10:29,060
okay so just edit the app here and if I

00:10:23,400 --> 00:10:33,900
run village that view I check it says

00:10:29,060 --> 00:10:37,170
that he found that at post dot tags uses

00:10:33,900 --> 00:10:39,630
our before instance that share between

00:10:37,170 --> 00:10:44,209
our field instances it should use that

00:10:39,630 --> 00:10:50,400
color bow instead and if we fix here and

00:10:44,209 --> 00:10:52,589
run it again there is gone so we wrote a

00:10:50,400 --> 00:10:55,760
check that really works and is really

00:10:52,589 --> 00:11:00,420
doing the right thing preventing bugs

00:10:55,760 --> 00:11:02,579
that's great but there is also a static

00:11:00,420 --> 00:11:05,089
analysis and that's performed without

00:11:02,579 --> 00:11:07,950
actually a security in a cold and

00:11:05,089 --> 00:11:10,050
because of that is safer and more

00:11:07,950 --> 00:11:12,600
general the in dynamic analysis it can

00:11:10,050 --> 00:11:15,480
analyze our code flows so when dynamic

00:11:12,600 --> 00:11:18,329
when dynamic analysis go inside ieave it

00:11:15,480 --> 00:11:19,709
goes obviously into one of the

00:11:18,329 --> 00:11:21,420
conditions because it's actually

00:11:19,709 --> 00:11:23,220
executing the code

00:11:21,420 --> 00:11:25,320
with static analysis you are looking

00:11:23,220 --> 00:11:29,270
through the cone not as accusing it so

00:11:25,320 --> 00:11:32,280
you can analyze out branches output flow

00:11:29,270 --> 00:11:35,370
is similar to coal review but performed

00:11:32,280 --> 00:11:38,460
by machines there are many types of

00:11:35,370 --> 00:11:40,860
static analysis mainly for these are

00:11:38,460 --> 00:11:43,530
something that I divided like not

00:11:40,860 --> 00:11:46,410
academic divided like that but there are

00:11:43,530 --> 00:11:49,470
texts and regex Basin static analysis

00:11:46,410 --> 00:11:53,010
there is token basic static analysis is

00:11:49,470 --> 00:11:55,770
debated and inference dated that's in

00:11:53,010 --> 00:11:57,990
reflex visit its idea for simple checks

00:11:55,770 --> 00:12:00,600
you are just like looking for something

00:11:57,990 --> 00:12:03,380
on your code like just a simple contains

00:12:00,600 --> 00:12:07,110
check or a simple rejects Mack match

00:12:03,380 --> 00:12:09,450
check and there is a library that does

00:12:07,110 --> 00:12:12,390
something like that is called doji and

00:12:09,450 --> 00:12:15,030
it looks for Python at Python code

00:12:12,390 --> 00:12:18,630
searching for things like passwords are

00:12:15,030 --> 00:12:20,100
diff that someone forgot that there are

00:12:18,630 --> 00:12:23,280
there is also the token there is an

00:12:20,100 --> 00:12:26,280
approach which uses the talking that the

00:12:23,280 --> 00:12:28,800
language has to analyze the code here is

00:12:26,280 --> 00:12:32,280
an example you have this file note there

00:12:28,800 --> 00:12:35,670
is a space okay between the prints print

00:12:32,280 --> 00:12:38,550
function and the open parenthesis and if

00:12:35,670 --> 00:12:41,420
you talk in eyes this little file you

00:12:38,550 --> 00:12:44,820
see that the tokens are named free an

00:12:41,420 --> 00:12:48,240
operator parenthesis and there is a

00:12:44,820 --> 00:12:51,500
distance of one between them so you can

00:12:48,240 --> 00:12:54,180
you can write style shacks with token

00:12:51,500 --> 00:12:57,870
token basic static analysis and in fact

00:12:54,180 --> 00:12:59,970
bytecode style uses these so it's better

00:12:57,870 --> 00:13:03,300
to get structure than route tax

00:12:59,970 --> 00:13:05,520
obviously it does not lose info so if

00:13:03,300 --> 00:13:07,380
you took a nice so okay neither code and

00:13:05,520 --> 00:13:07,860
I'm talking I did you get the same code

00:13:07,380 --> 00:13:10,770
back

00:13:07,860 --> 00:13:14,450
it's ideal for style checks and pipe

00:13:10,770 --> 00:13:18,390
outside part of play case uses this and

00:13:14,450 --> 00:13:22,250
more interesting there is the abstract

00:13:18,390 --> 00:13:25,050
syntax tree basil checks here's a

00:13:22,250 --> 00:13:26,760
example of abstract syntax tree you can

00:13:25,050 --> 00:13:29,820
run that code if you want if you just

00:13:26,760 --> 00:13:33,300
start the Hester library to free print

00:13:29,820 --> 00:13:35,370
the ast but you can just parse the St

00:13:33,300 --> 00:13:38,010
ast is part of

00:13:35,370 --> 00:13:39,900
Python buting modules and you can damp

00:13:38,010 --> 00:13:42,540
it with duster and you see something

00:13:39,900 --> 00:13:46,050
like that that's a tree representation

00:13:42,540 --> 00:13:47,880
of the code the code is a module it has

00:13:46,050 --> 00:13:50,850
a function definition inside it with

00:13:47,880 --> 00:13:53,730
arguments and a body that has a return

00:13:50,850 --> 00:13:54,240
that's a operation between left and

00:13:53,730 --> 00:13:56,370
right

00:13:54,240 --> 00:13:58,200
operators and it's an ADD operation and

00:13:56,370 --> 00:14:02,250
everything so it's a tree representation

00:13:58,200 --> 00:14:05,880
of the code and it abstracts so me far

00:14:02,250 --> 00:14:09,240
away so for example if else a leaf else

00:14:05,880 --> 00:14:11,040
becomes nested if else's so that's why

00:14:09,240 --> 00:14:13,550
it's called abstract because it

00:14:11,040 --> 00:14:16,440
abstracts on me far away from the code

00:14:13,550 --> 00:14:18,300
and it's ideal for checks that need to

00:14:16,440 --> 00:14:19,230
analyze the structure of the code as a

00:14:18,300 --> 00:14:21,300
whole

00:14:19,230 --> 00:14:24,180
checking the relationship between parts

00:14:21,300 --> 00:14:27,990
for example logic errors like undefined

00:14:24,180 --> 00:14:31,050
and name and placate use this AST basic

00:14:27,990 --> 00:14:35,790
check like like you can see in this

00:14:31,050 --> 00:14:40,140
example here and there's T is made for

00:14:35,790 --> 00:14:42,570
walking okay you you can you can you can

00:14:40,140 --> 00:14:45,420
walk through the ast using a node V

00:14:42,570 --> 00:14:48,120
store abstraction and here is that just

00:14:45,420 --> 00:14:50,870
a simple example of some code that

00:14:48,120 --> 00:14:58,290
prints out the functions inside the

00:14:50,870 --> 00:15:00,540
exciti ast so it's it's it's recursive

00:14:58,290 --> 00:15:03,000
okay because after visiting the function

00:15:00,540 --> 00:15:05,490
definition you keep visiting the other

00:15:03,000 --> 00:15:08,940
stuff so it you have to couch generic

00:15:05,490 --> 00:15:12,209
visit again but this no code here just

00:15:08,940 --> 00:15:17,490
prints out the other function it can

00:15:12,209 --> 00:15:19,680
find on the of the code and we can solve

00:15:17,490 --> 00:15:22,529
that problem we saw that we forgot to

00:15:19,680 --> 00:15:28,500
return on the query set with ASD walking

00:15:22,529 --> 00:15:31,740
we just need to know that we must we

00:15:28,500 --> 00:15:35,010
must check for cow okay because we are

00:15:31,740 --> 00:15:37,500
we are checking for a cow to filter and

00:15:35,010 --> 00:15:40,410
we must check for a expression node

00:15:37,500 --> 00:15:43,020
because expression ode is like a

00:15:40,410 --> 00:15:46,050
function cow or expression something

00:15:43,020 --> 00:15:48,060
that's not returned or stored in a

00:15:46,050 --> 00:15:49,050
variable something like that it's like a

00:15:48,060 --> 00:15:51,660
function call that

00:15:49,050 --> 00:15:54,120
does not return or it's not assign it

00:15:51,660 --> 00:15:56,760
and exactly that what we are looking for

00:15:54,120 --> 00:16:03,080
we are looking for a cow to filter

00:15:56,760 --> 00:16:07,320
that's an expression and demo for that

00:16:03,080 --> 00:16:09,540
we have here the code to check to find

00:16:07,320 --> 00:16:11,760
this bud okay to find that we are

00:16:09,540 --> 00:16:15,899
missing the return here we need to

00:16:11,760 --> 00:16:18,899
define a visitor and this visit of

00:16:15,899 --> 00:16:22,709
visits expressions that's what we are

00:16:18,899 --> 00:16:28,310
looking for and this expression needs to

00:16:22,709 --> 00:16:28,310
have a cow inside it it needs to have

00:16:28,610 --> 00:16:34,500
the the code function must been a

00:16:31,230 --> 00:16:37,680
attribute of a class because itself that

00:16:34,500 --> 00:16:40,500
puter this method needs to return a

00:16:37,680 --> 00:16:42,720
query set obviously we need to teach

00:16:40,500 --> 00:16:44,850
that to the code so we just create here

00:16:42,720 --> 00:16:47,970
a list of words that returning methods

00:16:44,850 --> 00:16:51,240
filter explode out this is larger than

00:16:47,970 --> 00:16:53,010
that just an example here and these

00:16:51,240 --> 00:16:55,740
methods needs to be called over our name

00:16:53,010 --> 00:16:57,930
and this name must be self because we

00:16:55,740 --> 00:17:00,870
are looking for the self dot puter so

00:16:57,930 --> 00:17:03,600
this part here checks that is an

00:17:00,870 --> 00:17:08,250
attribute dot filter and this part below

00:17:03,600 --> 00:17:11,250
checked its self dot and if we if all of

00:17:08,250 --> 00:17:15,630
that is true we just found a self dot

00:17:11,250 --> 00:17:18,390
filter and as an expression it's missing

00:17:15,630 --> 00:17:20,790
the return probably and then we can just

00:17:18,390 --> 00:17:24,360
print query set expressions not assign

00:17:20,790 --> 00:17:26,640
it is an error one thing that's missing

00:17:24,360 --> 00:17:29,309
here is that I'm visiting expression on

00:17:26,640 --> 00:17:31,740
all the code the entire code on our

00:17:29,309 --> 00:17:35,940
classes I need to make sure that I only

00:17:31,740 --> 00:17:38,700
visit if it's inside our class that

00:17:35,940 --> 00:17:40,290
inherits from prior set and but it is

00:17:38,700 --> 00:17:43,169
very easy I just need to create a

00:17:40,290 --> 00:17:46,559
parasite class that visitor that checks

00:17:43,169 --> 00:17:49,830
if the base is an attribute and if the

00:17:46,559 --> 00:17:52,230
desire boot is query set if I do that

00:17:49,830 --> 00:17:54,600
I'm checking that I'm inside a class

00:17:52,230 --> 00:17:59,059
that's inheriting from model that were

00:17:54,600 --> 00:17:59,059
set and if I if I run this code

00:18:04,220 --> 00:18:11,430
parents code I find that it it finds the

00:18:07,380 --> 00:18:14,460
the self dot filter thing and if I fix

00:18:11,430 --> 00:18:17,730
it with return then run it again

00:18:14,460 --> 00:18:21,330
there goes away so it's working that's

00:18:17,730 --> 00:18:25,820
great we made that new Shack a new

00:18:21,330 --> 00:18:28,650
linter here well it's not perfect if we

00:18:25,820 --> 00:18:31,080
if we do something like this we can't

00:18:28,650 --> 00:18:33,030
detect because we are detecting self dot

00:18:31,080 --> 00:18:36,630
filter we are not detecting something

00:18:33,030 --> 00:18:38,760
that returns a query set and operating

00:18:36,630 --> 00:18:41,160
over a query set again returns the query

00:18:38,760 --> 00:18:44,580
set we are not checking that obviously

00:18:41,160 --> 00:18:47,250
it's quite difficult to check this so

00:18:44,580 --> 00:18:49,740
how how can we fix this it would be

00:18:47,250 --> 00:18:53,460
great if we could infer the type of self

00:18:49,740 --> 00:18:57,210
dot outer style and we can we inference

00:18:53,460 --> 00:18:59,460
based checks we can infer improve from

00:18:57,210 --> 00:19:01,290
ASC nodes we can infer things like

00:18:59,460 --> 00:19:04,440
import variables at the Bhoots

00:19:01,290 --> 00:19:06,930
resolutions operation results method

00:19:04,440 --> 00:19:08,550
resolution orders etc we can do

00:19:06,930 --> 00:19:10,590
something like an interpreter that

00:19:08,550 --> 00:19:12,930
doesn't actually execute the code but

00:19:10,590 --> 00:19:15,750
analyzes it inferring some info and

00:19:12,930 --> 00:19:20,810
finally does that with the this library

00:19:15,750 --> 00:19:25,770
called us asteroid and we can show that

00:19:20,810 --> 00:19:28,710
we hear the same code ok the same bug we

00:19:25,770 --> 00:19:30,630
saw if we had self dot outer skull here

00:19:28,710 --> 00:19:34,200
the other linter could detect it put

00:19:30,630 --> 00:19:37,340
them detectives but using asteroid that

00:19:34,200 --> 00:19:42,630
the lift that powers file it we can

00:19:37,340 --> 00:19:46,140
visit expressions again ok and if the

00:19:42,630 --> 00:19:49,770
expression has a cow inside it and if we

00:19:46,140 --> 00:19:53,610
infer the result of this cow and the

00:19:49,770 --> 00:19:55,800
result of this cow is a query set we are

00:19:53,610 --> 00:19:58,020
you are not done we already found

00:19:55,800 --> 00:20:00,540
something that returns query set and

00:19:58,020 --> 00:20:01,980
design is an expression and it's

00:20:00,540 --> 00:20:04,530
probably wrong because you don't do

00:20:01,980 --> 00:20:07,500
operations on query sets and do nothing

00:20:04,530 --> 00:20:09,870
after it you usually return or assigned

00:20:07,500 --> 00:20:12,750
to something so just by doing that but

00:20:09,870 --> 00:20:15,720
buying fairing we found that the bug and

00:20:12,750 --> 00:20:19,169
if we run this code here

00:20:15,720 --> 00:20:22,169
you see that it takes a lot of time to

00:20:19,169 --> 00:20:24,870
infer stuff but he finds the bug and I

00:20:22,169 --> 00:20:28,230
printed here what what was inferred and

00:20:24,870 --> 00:20:30,690
it was inferred that the result the

00:20:28,230 --> 00:20:35,070
result of the operation should be a

00:20:30,690 --> 00:20:37,980
person query set and that's great but if

00:20:35,070 --> 00:20:39,510
I'm doing something here that I'm not

00:20:37,980 --> 00:20:42,390
showing - you're shown right now I'm

00:20:39,510 --> 00:20:44,520
teaching asteroid to infer 12 sets

00:20:42,390 --> 00:20:46,740
because if first that code is quite

00:20:44,520 --> 00:20:48,870
complex asteroid can't analyze it and

00:20:46,740 --> 00:20:51,539
figure out that future returns a query

00:20:48,870 --> 00:20:53,510
set of the class that uses the model and

00:20:51,539 --> 00:20:57,150
everything I need to teach that to

00:20:53,510 --> 00:20:58,770
asteroid but it's not very difficult I

00:20:57,150 --> 00:21:02,520
just need to do the same I need to say

00:20:58,770 --> 00:21:06,809
that Christ returns method returns per

00:21:02,520 --> 00:21:09,630
sets again so I just say that hey you

00:21:06,809 --> 00:21:13,770
have a query set instance okay and if

00:21:09,630 --> 00:21:16,559
it's if these instances of this acquires

00:21:13,770 --> 00:21:18,960
is really a query set for this kind of

00:21:16,559 --> 00:21:23,429
methods filter return ow

00:21:18,960 --> 00:21:26,010
you will infer another query set because

00:21:23,429 --> 00:21:28,049
the operations of a car set like filter

00:21:26,010 --> 00:21:29,909
return a Nordic Ware set so I need to

00:21:28,049 --> 00:21:33,210
teach that to us right buddy it doesn't

00:21:29,909 --> 00:21:35,039
take much just this code here and now

00:21:33,210 --> 00:21:39,240
asteroid knows how to infer where is

00:21:35,039 --> 00:21:41,820
that that's amazing but some of you

00:21:39,240 --> 00:21:43,500
might think what about my file my PI can

00:21:41,820 --> 00:21:46,200
do type inference what about it

00:21:43,500 --> 00:21:48,690
fortunately it's not there yet I ask at

00:21:46,200 --> 00:21:54,809
these on my file my PI issue and Vito

00:21:48,690 --> 00:21:57,299
answer it really happy he said that it

00:21:54,809 --> 00:22:01,140
would be very useful in power to use my

00:21:57,299 --> 00:22:03,360
PI for inference but also be very

00:22:01,140 --> 00:22:05,909
complicated and this is not something

00:22:03,360 --> 00:22:08,010
they're working on right now but I was

00:22:05,909 --> 00:22:10,080
on PI Bay last week and there were

00:22:08,010 --> 00:22:11,909
people from my finder and they are

00:22:10,080 --> 00:22:14,460
really excited about this so they work

00:22:11,909 --> 00:22:17,010
on these like sometimes not right now

00:22:14,460 --> 00:22:19,160
but we can disobey Guido and just try to

00:22:17,010 --> 00:22:22,590
infer it

00:22:19,160 --> 00:22:25,200
and there is some code for that it's not

00:22:22,590 --> 00:22:27,060
very useful you can check there there

00:22:25,200 --> 00:22:28,980
are some this code is commented you can

00:22:27,060 --> 00:22:32,400
check what I'm doing but it's not very

00:22:28,980 --> 00:22:34,530
you there are other types of libraries

00:22:32,400 --> 00:22:37,980
that also do type inference by type by

00:22:34,530 --> 00:22:39,930
charm both make use of type annotations

00:22:37,980 --> 00:22:43,470
are great and having furnace

00:22:39,930 --> 00:22:48,000
capabilities asteroid don't use type

00:22:43,470 --> 00:22:51,150
annotations yet but it will use and but

00:22:48,000 --> 00:22:53,430
pies happen fortunately has only initial

00:22:51,150 --> 00:22:55,410
Python 3 support even though it's used

00:22:53,430 --> 00:22:58,170
on more than 500 internal Google

00:22:55,410 --> 00:23:00,440
projects and fashion is implemented in

00:22:58,170 --> 00:23:00,440
Java

00:23:01,880 --> 00:23:07,560
ok when when to run this we can run

00:23:05,550 --> 00:23:09,300
linkers on programming time commit time

00:23:07,560 --> 00:23:11,820
continuous integration time or code

00:23:09,300 --> 00:23:16,040
review time programming time most of you

00:23:11,820 --> 00:23:18,360
must have editors that's apart linkers

00:23:16,040 --> 00:23:19,920
but there is also some stuff that should

00:23:18,360 --> 00:23:21,810
never be committed this from a real

00:23:19,920 --> 00:23:24,120
government website from Brazil you can

00:23:21,810 --> 00:23:27,210
see here someone committed a mass

00:23:24,120 --> 00:23:30,540
conflict and to prevent committing this

00:23:27,210 --> 00:23:31,560
kind of stuff you should run checks on

00:23:30,540 --> 00:23:33,720
commit time ok

00:23:31,560 --> 00:23:36,390
you have recommend for that like great -

00:23:33,720 --> 00:23:38,700
written in Python so if you don't use it

00:23:36,390 --> 00:23:42,300
try to use it it checks for these kind

00:23:38,700 --> 00:23:44,520
of things - like conflict and security

00:23:42,300 --> 00:23:46,770
related stuff or even any leader you

00:23:44,520 --> 00:23:48,780
want just in configure continuous

00:23:46,770 --> 00:23:50,550
integration time many people don't do

00:23:48,780 --> 00:23:53,040
that but you should failure your build

00:23:50,550 --> 00:23:55,430
if you if any linter reports any issue

00:23:53,040 --> 00:23:58,110
it's really important especially for

00:23:55,430 --> 00:23:59,880
popping is related to security there are

00:23:58,110 --> 00:24:02,760
links related to security like bandit

00:23:59,880 --> 00:24:06,390
and safety and you should failure your

00:24:02,760 --> 00:24:08,640
view any of those links fail and also

00:24:06,390 --> 00:24:13,170
code review time you can have a bot that

00:24:08,640 --> 00:24:15,450
comments on poor requests especially

00:24:13,170 --> 00:24:18,660
useful for open-source projects there's

00:24:15,450 --> 00:24:20,790
a project firmly if that does that which

00:24:18,660 --> 00:24:23,160
leaders there are out there many many

00:24:20,790 --> 00:24:24,920
dozens of linkers are available link

00:24:23,160 --> 00:24:27,750
there's for quality imports dogs

00:24:24,920 --> 00:24:29,760
security packagings even spelling

00:24:27,750 --> 00:24:32,220
someone routes a linter to check the

00:24:29,760 --> 00:24:36,210
spell not of the strings

00:24:32,220 --> 00:24:38,309
but the code itself the variables and

00:24:36,210 --> 00:24:39,840
you can rub them out with prospector a

00:24:38,309 --> 00:24:41,700
Python only - but if you have a

00:24:39,840 --> 00:24:44,190
multi-language project you can use koala

00:24:41,700 --> 00:24:47,659
koala dot io so I get great project that

00:24:44,190 --> 00:24:49,710
wraps linkers from all languages and

00:24:47,659 --> 00:24:51,539
let's clean other things

00:24:49,710 --> 00:24:54,030
I created a list of all the links I

00:24:51,539 --> 00:24:56,070
could fight fine it's their use of the

00:24:54,030 --> 00:24:58,169
slash Python winters and code analysis

00:24:56,070 --> 00:25:01,289
there are many many liters that you can

00:24:58,169 --> 00:25:03,990
use and I have some ideas for new Django

00:25:01,289 --> 00:25:09,380
checks right like checking for a string

00:25:03,990 --> 00:25:12,600
formatting in Rowell apps that means

00:25:09,380 --> 00:25:15,270
that no true a char field the text field

00:25:12,600 --> 00:25:18,360
I think we can work on that on Springs

00:25:15,270 --> 00:25:19,620
so if you are interesting interested in

00:25:18,360 --> 00:25:21,679
writing custom checks

00:25:19,620 --> 00:25:24,210
let me know look for me on Sprint's I

00:25:21,679 --> 00:25:26,730
want to make a new project called Django

00:25:24,210 --> 00:25:30,720
book finder to have checks for that kind

00:25:26,730 --> 00:25:33,330
of and finally some people criticize

00:25:30,720 --> 00:25:35,460
code analysis because it gives false

00:25:33,330 --> 00:25:40,289
positives or it doesn't understand

00:25:35,460 --> 00:25:42,059
dynamic stuff but maybe if understanding

00:25:40,289 --> 00:25:44,220
your code maybe your code is like too

00:25:42,059 --> 00:25:46,110
complex maybe your fellow developers

00:25:44,220 --> 00:25:48,390
won't understand it too so let's try to

00:25:46,110 --> 00:25:50,460
write simple code testable code check

00:25:48,390 --> 00:25:52,850
about code that our fellow developers

00:25:50,460 --> 00:25:57,270
and code analysis tool can check to and

00:25:52,850 --> 00:25:58,350
that's it let here is my contact info

00:25:57,270 --> 00:26:02,640
feel free to reach me

00:25:58,350 --> 00:26:05,760
let's boot on this Django book find the

00:26:02,640 --> 00:26:08,010
thing that I'm just interviewed with and

00:26:05,760 --> 00:26:10,799
you can check the Python winters and

00:26:08,010 --> 00:26:13,230
code analysis repository for a full list

00:26:10,799 --> 00:26:15,630
of all linkers I could found there are

00:26:13,230 --> 00:26:18,570
other talks from vinta available on

00:26:15,630 --> 00:26:22,260
these or this link will give another

00:26:18,570 --> 00:26:25,260
talk today about salary that Phillippi

00:26:22,260 --> 00:26:32,549
one of my partner's that I think the who

00:26:25,260 --> 00:26:34,710
that will give it thank you very much so

00:26:32,549 --> 00:26:36,450
I really love the title of your talk I

00:26:34,710 --> 00:26:38,610
thought it was funny because we've all

00:26:36,450 --> 00:26:41,789
been there right or many of us have been

00:26:38,610 --> 00:26:43,620
there so what was it that it inspired

00:26:41,789 --> 00:26:45,929
you to become so passionate about

00:26:43,620 --> 00:26:49,409
helping you know people come on bore

00:26:45,929 --> 00:26:54,809
with you with making it easier to to

00:26:49,409 --> 00:26:57,509
check your code so on vita we do a lot

00:26:54,809 --> 00:27:00,659
of code review outputs code revealed so

00:26:57,509 --> 00:27:02,940
I found myself repeating myself too much

00:27:00,659 --> 00:27:04,710
like the same mistakes again and again

00:27:02,940 --> 00:27:08,490
because we knew people were joining the

00:27:04,710 --> 00:27:10,679
company and so I thought maybe I should

00:27:08,490 --> 00:27:12,600
write something to check for this kind

00:27:10,679 --> 00:27:15,179
of stuff so for example a simple finger

00:27:12,600 --> 00:27:17,279
wrote one of the first checks who has to

00:27:15,179 --> 00:27:21,149
check if someone forgot to run make

00:27:17,279 --> 00:27:22,919
migration so this like and this is

00:27:21,149 --> 00:27:25,440
difficult to check on pull requests like

00:27:22,919 --> 00:27:28,049
it you need to look that someone changed

00:27:25,440 --> 00:27:30,210
the models but didn't include the

00:27:28,049 --> 00:27:31,799
migration on the PO request so this is

00:27:30,210 --> 00:27:33,600
even a foot but something that we are

00:27:31,799 --> 00:27:35,789
repeating or sub hey you forgot to run

00:27:33,600 --> 00:27:37,409
make migration so we wrote a check for

00:27:35,789 --> 00:27:39,570
that and we are trying we're still

00:27:37,409 --> 00:27:41,669
beginning to do that on visa but we are

00:27:39,570 --> 00:27:44,369
trying to consolidate the knowledge we

00:27:41,669 --> 00:27:46,200
have from code reviews and years of

00:27:44,369 --> 00:27:48,150
experience in the form of linkers

00:27:46,200 --> 00:27:56,419
thanks al it's break time

00:27:48,150 --> 00:27:56,419

YouTube URL: https://www.youtube.com/watch?v=IMRHFlDxaqU


