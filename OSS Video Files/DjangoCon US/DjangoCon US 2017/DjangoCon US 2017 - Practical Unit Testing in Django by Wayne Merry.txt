Title: DjangoCon US 2017 - Practical Unit Testing in Django by Wayne Merry
Publication date: 2017-09-08
Playlist: DjangoCon US 2017
Description: 
	DjangoCon US 2017 - Practical Unit Testing in Django by Wayne Merry

This talk is an opportunity for you to explore practical ways of improving the test code you write. Unit testing can be challenging, but with the right toolbox of techniques, it is much easier to write unit tests that not only enable high degrees of code coverage, but assurance on each action of your code.

Django provides an excellent test environment that facilitates testing across the whole of a project, however Djangoâ€™s documentation and many online examples focus on integration tests. Any typical use of the Django test client is an integration test. Tools such as selenium also provide a frame work for usability tests, functional tests or integration tests. What is missing in this is a close look at unit tests. It is difficult to obtain high code coverage with integration tests alone.

This talk will build on Daniel Davisâ€™ DjangoCon2015 talk â€œWhy Unit Testing Doesnâ€™t Have To Be So Hardâ€. That talk introduced the concept of using mocking to deal with the complexity of unit testing and gave a number of simple examples. In this talk, we will apply mocking, dummy objects and harnesses to unit test in the Django environment.

We will focus first on class based views. Django provides an extensive Generic Class Base View hierarchy of base classes and mixins. These define a series of methods that focus on various elements of the response process. For more complex applications, this system provides much of what is needed but often customizations are needed and these can take the form of subclasses overriding one or more methods, or perhaps mixins that are built to implement abstractions of these customizations.

In order to unit test these customizations, we want to place each individual method under test. To obtain strong assurance of code performance, we want to place under test each action of the code, plus its coupling with its base class(es). A test harness, mocks and dummy objects all assist in this process and we will explore examples of such. Mocks particularly facilitate our tests by us being able assert on what is passed on other method calls and on the super() call. Mixins are used to implement customization abstractions. Their methods can be unit tested making use of dummy subclasses.

Form classes also benefit from unit testing. Form classes may define clean methods for validation, and these clean methods can be called directly in unit tests for both valid and invalid data. Some modelform classes may implement business logic in their save() methods and these also highly benefit from unit testing.

Both forms and views often make use of the ORM. When performing integration testing, this often means setting up test fixtures, but for unit testing it might be much more efficient to mock out ORM calls such as filter(), all(), count(), etc. Sometimes code under test will chain these ORM functions and this also can be mocked.

We will then consider a more complex example of a view that makes use of an inlineformset. inlineformsets are more complex form objects, but various approaches can be used to unit test views that make use of formsets (along with unit tests of the formset itself).

We will close with some template unit testing.

The content of this talk is built on examples taken from real systems implementation. These should give many Django practitioners a boost in their day to day testing toolkit.

This talk was presented at: https://2017.djangocon.us/talks/practical-unit-testing-in-django/

LINKS:
Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:15,910
[Music]

00:00:13,500 --> 00:00:18,910
thank you for coming can you all hear me

00:00:15,910 --> 00:00:20,500
I know fall back here so today we're

00:00:18,910 --> 00:00:25,029
going to look at practical unit testing

00:00:20,500 --> 00:00:27,070
in Django if you went to the testing

00:00:25,029 --> 00:00:29,320
talk yesterday we're going to dive into

00:00:27,070 --> 00:00:32,980
it more details specifically about unit

00:00:29,320 --> 00:00:39,310
testing rather than general Django

00:00:32,980 --> 00:00:41,350
testing and so this a if you're if

00:00:39,310 --> 00:00:45,070
you've not done mocking before a good

00:00:41,350 --> 00:00:47,440
intro talk is from Django con US 2015

00:00:45,070 --> 00:00:51,010
why unit testing doesn't have to be so

00:00:47,440 --> 00:00:53,860
hard that's when my introduction to soon

00:00:51,010 --> 00:00:56,440
- mocking happened then and then using

00:00:53,860 --> 00:00:59,590
that in a Django context and a few fewer

00:00:56,440 --> 00:01:01,540
T's later then we're sort of developed

00:00:59,590 --> 00:01:04,329
some techniques so that's definitely a

00:01:01,540 --> 00:01:07,960
good talk to check out if you're new to

00:01:04,329 --> 00:01:09,820
this area and so what we're covering is

00:01:07,960 --> 00:01:11,829
recovering University we're going to

00:01:09,820 --> 00:01:15,939
look at some examples of testing with

00:01:11,829 --> 00:01:18,009
views forms fields and some template

00:01:15,939 --> 00:01:20,259
tags we're not covering integration

00:01:18,009 --> 00:01:22,509
testing so I'm not going to get into the

00:01:20,259 --> 00:01:24,969
whether you should use or not use mock

00:01:22,509 --> 00:01:26,799
mocks when it comes to those things that

00:01:24,969 --> 00:01:28,359
much apart from stating a personal

00:01:26,799 --> 00:01:30,460
opinion I would never use mocks in

00:01:28,359 --> 00:01:32,590
integration tests if I can avoid it

00:01:30,460 --> 00:01:36,909
anyway but they're essential when it

00:01:32,590 --> 00:01:40,359
comes to unit is so why unit test well I

00:01:36,909 --> 00:01:42,789
I started by Django adventure by doing

00:01:40,359 --> 00:01:46,209
the tutorial then the tutorial into it

00:01:42,789 --> 00:01:50,380
has a section on testing that section on

00:01:46,209 --> 00:01:52,600
testing is integration testing now the

00:01:50,380 --> 00:01:54,969
problem is as a project grows in scope

00:01:52,600 --> 00:01:58,389
it becomes very hard to get a high level

00:01:54,969 --> 00:02:00,729
code coverage using the Django test

00:01:58,389 --> 00:02:02,889
client where the code that you're trying

00:02:00,729 --> 00:02:06,579
to test might be twenty method calls

00:02:02,889 --> 00:02:10,149
down the tree and so that doesn't really

00:02:06,579 --> 00:02:12,760
work in terms of really exploring the

00:02:10,149 --> 00:02:15,819
code that you're placing under test in a

00:02:12,760 --> 00:02:18,490
particular module so we need we need a

00:02:15,819 --> 00:02:20,170
more direct way of attacking what we're

00:02:18,490 --> 00:02:22,840
trying to test rather than trying to

00:02:20,170 --> 00:02:25,540
test the whole stack but you know in a

00:02:22,840 --> 00:02:26,590
project you would do integration testing

00:02:25,540 --> 00:02:30,099
so those tests

00:02:26,590 --> 00:02:31,269
still there but then you you so there's

00:02:30,099 --> 00:02:33,670
a percentage of tests that are

00:02:31,269 --> 00:02:35,950
integration and functional tests but a

00:02:33,670 --> 00:02:36,550
whole lot of tests are going to be unit

00:02:35,950 --> 00:02:39,250
tests

00:02:36,550 --> 00:02:44,080
there's many dependencies that can exist

00:02:39,250 --> 00:02:46,780
in a project methods can often be more

00:02:44,080 --> 00:02:48,700
than just take what the parameters that

00:02:46,780 --> 00:02:50,440
come in and a result that comes out

00:02:48,700 --> 00:02:52,269
those side effects there's there's

00:02:50,440 --> 00:02:53,890
classes there's attributes of classes

00:02:52,269 --> 00:02:56,080
you might be changing those attributes

00:02:53,890 --> 00:02:59,140
of classes and so those things are

00:02:56,080 --> 00:03:02,049
side-effects and they they increase the

00:02:59,140 --> 00:03:03,640
complexity of testing and so we need a

00:03:02,049 --> 00:03:05,650
way of getting some sanity about all

00:03:03,640 --> 00:03:09,130
this because that kind of drives you

00:03:05,650 --> 00:03:11,440
crazy and sometimes really could be so

00:03:09,130 --> 00:03:13,329
complicated complicated it can it just

00:03:11,440 --> 00:03:19,150
not be even plausible to try and manage

00:03:13,329 --> 00:03:22,720
it at such a high level so what is a

00:03:19,150 --> 00:03:27,370
unit test the idea is to place one

00:03:22,720 --> 00:03:30,370
method under test and you're testing the

00:03:27,370 --> 00:03:33,480
internal operation of that method you're

00:03:30,370 --> 00:03:36,430
testing how it calls other methods and

00:03:33,480 --> 00:03:38,079
you're looking at what it does when it

00:03:36,430 --> 00:03:40,690
gets the results of other methods back

00:03:38,079 --> 00:03:42,069
and it what it might do with that which

00:03:40,690 --> 00:03:45,880
might be simply just returning it

00:03:42,069 --> 00:03:49,290
onwards then you presume everything else

00:03:45,880 --> 00:03:52,750
is reliable

00:03:49,290 --> 00:03:54,430
so pythons duck place typing so can you

00:03:52,750 --> 00:03:57,090
tell me a bit of interaction here what

00:03:54,430 --> 00:03:59,230
is that animal that we see on the screen

00:03:57,090 --> 00:04:04,180
no we don't see anything on the screen

00:03:59,230 --> 00:04:07,389
at all now hopefully that stays there

00:04:04,180 --> 00:04:10,510
don't touch anything okay well so the

00:04:07,389 --> 00:04:13,090
point is it doesn't really matter what

00:04:10,510 --> 00:04:15,160
is what is the big picture of what

00:04:13,090 --> 00:04:17,799
you're testing you are testing a method

00:04:15,160 --> 00:04:20,530
so we've got the nose of a duck a little

00:04:17,799 --> 00:04:22,930
toy duck on this line it doesn't matter

00:04:20,530 --> 00:04:25,360
the thing is a line you're just testing

00:04:22,930 --> 00:04:28,570
that narrow bit with an O that red nose

00:04:25,360 --> 00:04:29,979
and so long as that does you only need

00:04:28,570 --> 00:04:32,440
to do enough to make it work in the

00:04:29,979 --> 00:04:34,330
context of your method everything else

00:04:32,440 --> 00:04:36,520
that it does doesn't really matter

00:04:34,330 --> 00:04:38,710
and I'll fill that out in some details

00:04:36,520 --> 00:04:40,240
as we go along but to get you thinking

00:04:38,710 --> 00:04:44,080
if you're testing sir

00:04:40,240 --> 00:04:46,509
some code that takes an orm result and

00:04:44,080 --> 00:04:48,759
you all say adding something to it you

00:04:46,509 --> 00:04:52,389
actually don't need the RM to test your

00:04:48,759 --> 00:04:55,539
what you are doing the RM itself is out

00:04:52,389 --> 00:04:57,550
of scope of your particular method and

00:04:55,539 --> 00:05:00,340
we'll have we'll have a look at some

00:04:57,550 --> 00:05:02,229
examples the point is if you're testing

00:05:00,340 --> 00:05:06,729
just at that red nose that's all that

00:05:02,229 --> 00:05:09,669
matters everything else is irrelevant so

00:05:06,729 --> 00:05:11,800
our first sort of domain that we want to

00:05:09,669 --> 00:05:14,199
talk about is testing class-based views

00:05:11,800 --> 00:05:15,849
if you are using functional views I

00:05:14,199 --> 00:05:17,289
don't really use them anymore so I'm

00:05:15,849 --> 00:05:19,659
going to be focused on class-based views

00:05:17,289 --> 00:05:21,159
now class-based views there's a big

00:05:19,659 --> 00:05:23,860
hierarchy and there's lots of methods in

00:05:21,159 --> 00:05:26,650
there what then typically happens is you

00:05:23,860 --> 00:05:29,680
might be you might be inheriting from

00:05:26,650 --> 00:05:32,979
say create view or update view and you

00:05:29,680 --> 00:05:35,349
might be defining a few methods that add

00:05:32,979 --> 00:05:38,349
to that just do a few things extra maybe

00:05:35,349 --> 00:05:40,720
just one line of code extra what you're

00:05:38,349 --> 00:05:43,509
testing is that one line of code and the

00:05:40,720 --> 00:05:45,190
call to the super function and the

00:05:43,509 --> 00:05:46,990
result that comes back and that's all

00:05:45,190 --> 00:05:51,520
you're testing you're not testing

00:05:46,990 --> 00:05:53,169
anything else so so what we see as the

00:05:51,520 --> 00:05:54,849
slide talks about each override that you

00:05:53,169 --> 00:05:59,169
make is going to be a method that you

00:05:54,849 --> 00:06:01,330
made sure you're either deriving from

00:05:59,169 --> 00:06:03,009
the class and writing a specific

00:06:01,330 --> 00:06:04,780
override or perhaps you've noticed

00:06:03,009 --> 00:06:06,610
you've done that a few times and so now

00:06:04,780 --> 00:06:09,280
it's time for a mix in and so we're

00:06:06,610 --> 00:06:11,500
going to we're going to define a mixin

00:06:09,280 --> 00:06:14,500
that does one or two things in one or

00:06:11,500 --> 00:06:16,120
two methods and we want to test that so

00:06:14,500 --> 00:06:21,219
what we want to do is we want to test

00:06:16,120 --> 00:06:22,780
those methods now what we want what we

00:06:21,219 --> 00:06:24,460
don't want to do is we don't want to

00:06:22,780 --> 00:06:26,080
call the Django test client because

00:06:24,460 --> 00:06:28,210
that's an integration test and that

00:06:26,080 --> 00:06:30,190
relies on the whole kaboodle to be there

00:06:28,210 --> 00:06:31,240
and we don't really want that so what we

00:06:30,190 --> 00:06:34,930
need to do is we need to basically

00:06:31,240 --> 00:06:36,789
create another our view in memory so we

00:06:34,930 --> 00:06:39,550
can call the function we actually want

00:06:36,789 --> 00:06:41,889
to test and so the top function there is

00:06:39,550 --> 00:06:44,110
a function that just rips out a little

00:06:41,889 --> 00:06:45,849
bit of from the as view function that's

00:06:44,110 --> 00:06:49,930
from the Django class base view

00:06:45,849 --> 00:06:53,469
hierarchy to set up a test object a view

00:06:49,930 --> 00:06:54,129
object I should say so it sets up the

00:06:53,469 --> 00:06:56,649
attributes

00:06:54,129 --> 00:06:59,259
request dogs and keywords and it returns

00:06:56,649 --> 00:07:00,939
the view if you look at as view in the

00:06:59,259 --> 00:07:03,219
Django source code you'll notice that

00:07:00,939 --> 00:07:04,839
that exists in there it does a few other

00:07:03,219 --> 00:07:07,589
things but they're not really needed for

00:07:04,839 --> 00:07:11,289
our unit test and then to actually test

00:07:07,589 --> 00:07:13,449
this thing in the setup function in the

00:07:11,289 --> 00:07:15,550
test class we see that we go to the

00:07:13,449 --> 00:07:17,080
request back tree so that was the

00:07:15,550 --> 00:07:19,689
existence of the request factor has

00:07:17,080 --> 00:07:21,279
talked about yes no we in this case

00:07:19,689 --> 00:07:23,830
we're testing a get method but that

00:07:21,279 --> 00:07:25,569
could be that could be other HTTP

00:07:23,830 --> 00:07:27,279
methods it doesn't really matter what

00:07:25,569 --> 00:07:29,019
URL you'd give it you don't need to

00:07:27,279 --> 00:07:32,080
worry about URL resolving you can call

00:07:29,019 --> 00:07:35,050
it ABC it's really irrelevant just feed

00:07:32,080 --> 00:07:38,769
it some string all right we create our

00:07:35,050 --> 00:07:40,779
view which is the view under test and we

00:07:38,769 --> 00:07:43,839
call that method that's up the top and

00:07:40,779 --> 00:07:45,279
that sets up the view and then what we

00:07:43,839 --> 00:07:48,369
can do is we can directly call the

00:07:45,279 --> 00:07:50,229
method so if we if our method that if

00:07:48,369 --> 00:07:52,749
our class on a test has got say a

00:07:50,229 --> 00:07:54,550
dispatch method override then we can

00:07:52,749 --> 00:07:59,469
just directly call that by going view

00:07:54,550 --> 00:08:01,899
dot dispatch with the request and any

00:07:59,469 --> 00:08:03,219
arguments keyword arguments so we can

00:08:01,899 --> 00:08:05,050
directly call that method and we don't

00:08:03,219 --> 00:08:07,089
need to worry about all everything else

00:08:05,050 --> 00:08:09,099
that goes with it if we're common

00:08:07,089 --> 00:08:12,179
functions to override is get context

00:08:09,099 --> 00:08:14,529
data you just call it directly with a

00:08:12,179 --> 00:08:16,869
with a dictionary as your keyword args

00:08:14,529 --> 00:08:17,349
and then you look then you look at what

00:08:16,869 --> 00:08:24,429
it does

00:08:17,349 --> 00:08:26,559
inside so moving on to forms so we want

00:08:24,429 --> 00:08:27,849
to test the idea is to test every action

00:08:26,559 --> 00:08:29,979
of a method to get some kind of

00:08:27,849 --> 00:08:33,519
assurance that this code is going to do

00:08:29,979 --> 00:08:35,919
what it does so he's a he's a function

00:08:33,519 --> 00:08:38,469
we want to test so it's got so it's the

00:08:35,919 --> 00:08:41,139
clean method of a form and what it does

00:08:38,469 --> 00:08:43,750
is it's testing two dates and if the end

00:08:41,139 --> 00:08:45,670
date is after the start date we just

00:08:43,750 --> 00:08:47,290
want to make it the same like we want to

00:08:45,670 --> 00:08:50,199
make the start date the same as the end

00:08:47,290 --> 00:08:53,079
date so if the start dates later so so

00:08:50,199 --> 00:08:57,160
does it do that or not and if there's an

00:08:53,079 --> 00:08:58,360
exception then we want that not we

00:08:57,160 --> 00:09:03,519
wanted to basically do nothing

00:08:58,360 --> 00:09:05,199
so here are two tests that do that so we

00:09:03,519 --> 00:09:06,600
haven't look what they do the first

00:09:05,199 --> 00:09:09,450
thing is they patch

00:09:06,600 --> 00:09:11,670
the clean method that's in that's

00:09:09,450 --> 00:09:14,280
inherited all right the super call is

00:09:11,670 --> 00:09:16,560
going to call the forum clean method we

00:09:14,280 --> 00:09:18,660
actually don't want to call the the

00:09:16,560 --> 00:09:21,570
forum clean method because we're not

00:09:18,660 --> 00:09:25,170
interested in testing what that does we

00:09:21,570 --> 00:09:27,600
just want we need to patch that and so

00:09:25,170 --> 00:09:28,860
the audio spectral test whether we're

00:09:27,600 --> 00:09:30,900
calling it in the way that it would be

00:09:28,860 --> 00:09:32,010
expected and then we give it a result

00:09:30,900 --> 00:09:34,380
value we're just going to give it a

00:09:32,010 --> 00:09:38,100
result of ABC we call it whatever we

00:09:34,380 --> 00:09:40,170
want and then so then the method the

00:09:38,100 --> 00:09:43,050
first line is it creates the form form

00:09:40,170 --> 00:09:45,300
equals self test form then it sets up

00:09:43,050 --> 00:09:46,860
some clean data now when you're doing an

00:09:45,300 --> 00:09:48,900
integration test that's already done

00:09:46,860 --> 00:09:50,820
somewhere else but when you we're just

00:09:48,900 --> 00:09:52,470
gonna be calling clean so clean data

00:09:50,820 --> 00:09:55,320
doesn't exist so we need to make that

00:09:52,470 --> 00:09:57,510
that's a dependency so we need to set

00:09:55,320 --> 00:09:58,980
that up and we'll put some clean data in

00:09:57,510 --> 00:10:02,300
there and the first one there is no end

00:09:58,980 --> 00:10:02,300
date so that would throw an exception

00:10:03,140 --> 00:10:07,890
we're testing for only a start date then

00:10:06,120 --> 00:10:10,800
it says result equals form clean it

00:10:07,890 --> 00:10:12,540
calls the clean method directly then it

00:10:10,800 --> 00:10:15,900
looks at what comes out the first

00:10:12,540 --> 00:10:18,660
assertion is did it call the super

00:10:15,900 --> 00:10:24,000
method did that clean method of the form

00:10:18,660 --> 00:10:26,340
get called and was it called once which

00:10:24,000 --> 00:10:28,740
is what we expect the previous method

00:10:26,340 --> 00:10:30,210
has got one call to super what happens

00:10:28,740 --> 00:10:31,980
if we made a coding error and we called

00:10:30,210 --> 00:10:35,640
it twice well then the assertion will

00:10:31,980 --> 00:10:38,280
fail then the next line is it asserts

00:10:35,640 --> 00:10:40,320
that clean data has only got a start

00:10:38,280 --> 00:10:42,270
date in it there's no end date that

00:10:40,320 --> 00:10:46,590
appeared because our codes not supposed

00:10:42,270 --> 00:10:48,420
to do that now if I if I wanted to pass

00:10:46,590 --> 00:10:50,430
it if I want to throw the exception and

00:10:48,420 --> 00:10:53,730
not capture it I could use an assertion

00:10:50,430 --> 00:10:55,500
called assert raises and put the

00:10:53,730 --> 00:10:57,480
exception in there and then the test

00:10:55,500 --> 00:11:01,080
will pass if an exception is thrown

00:10:57,480 --> 00:11:02,910
that's not captured so I can whether I

00:11:01,080 --> 00:11:05,130
need to throw the exception or not I can

00:11:02,910 --> 00:11:07,110
test specifically for that and then the

00:11:05,130 --> 00:11:10,800
final thing is this last session

00:11:07,110 --> 00:11:13,260
assertion is is the result ABC we go

00:11:10,800 --> 00:11:16,230
back in over the code it takes a result

00:11:13,260 --> 00:11:18,360
if the result from super is put into a

00:11:16,230 --> 00:11:20,450
variable called result and then down the

00:11:18,360 --> 00:11:22,760
bottom return result if I

00:11:20,450 --> 00:11:24,800
leave that bottom line out forget to

00:11:22,760 --> 00:11:28,850
return the result then that final

00:11:24,800 --> 00:11:31,010
assertion will fail so I am testing it's

00:11:28,850 --> 00:11:34,370
my method that takes the result of the

00:11:31,010 --> 00:11:36,140
super call and will pass that out to the

00:11:34,370 --> 00:11:38,150
caller I want to test that that's

00:11:36,140 --> 00:11:40,460
something that my method is doing so

00:11:38,150 --> 00:11:42,200
anything that my methods doing I want to

00:11:40,460 --> 00:11:47,210
test that and that's what that final

00:11:42,200 --> 00:11:49,370
assertion the search result ABC needs to

00:11:47,210 --> 00:11:52,400
test if I change the return value back

00:11:49,370 --> 00:11:54,410
on the patch at the top line to D F then

00:11:52,400 --> 00:11:58,610
my assertion will fail unless they test

00:11:54,410 --> 00:12:02,840
for D and so that's the is the concept

00:11:58,610 --> 00:12:05,810
of detailed unit testing so going on

00:12:02,840 --> 00:12:08,390
it's just talking about this at a more

00:12:05,810 --> 00:12:11,150
conceptual level so methods do things

00:12:08,390 --> 00:12:13,280
they and we want to try and capture each

00:12:11,150 --> 00:12:15,590
thing that it does so some of it is

00:12:13,280 --> 00:12:17,330
direct in method actions such as

00:12:15,590 --> 00:12:19,460
assignments or doing some sort of

00:12:17,330 --> 00:12:21,080
mathematics or whatever and the other

00:12:19,460 --> 00:12:23,540
thing that they typically do is call

00:12:21,080 --> 00:12:26,270
staff and most often but not always

00:12:23,540 --> 00:12:28,220
that's a call to super but sometimes

00:12:26,270 --> 00:12:30,740
it's a call to other things whatever a

00:12:28,220 --> 00:12:33,620
calls you want to test that it's calling

00:12:30,740 --> 00:12:35,210
it as you expect it will call it given

00:12:33,620 --> 00:12:37,880
the inputs that you're feeding to this

00:12:35,210 --> 00:12:40,580
function if you say if you only

00:12:37,880 --> 00:12:43,760
sometimes call super based on certain

00:12:40,580 --> 00:12:46,340
inputs then you want test case that test

00:12:43,760 --> 00:12:48,410
for the domain of inputs that should

00:12:46,340 --> 00:12:50,030
call super and then for the ones that

00:12:48,410 --> 00:12:54,800
shouldn't call super you'll be looking

00:12:50,030 --> 00:12:56,840
at its core count is zero now as soon as

00:12:54,800 --> 00:12:59,240
you introduce an if statement you've got

00:12:56,840 --> 00:13:01,970
a code branch and so that's likely to

00:12:59,240 --> 00:13:06,230
mean more than one test case so you can

00:13:01,970 --> 00:13:07,730
test each branch if you're getting too

00:13:06,230 --> 00:13:09,980
many of them and you're getting a whole

00:13:07,730 --> 00:13:11,780
pile of test cases that's a prime

00:13:09,980 --> 00:13:16,520
indication that you need to break the

00:13:11,780 --> 00:13:17,990
thing up it's just a few notes on in the

00:13:16,520 --> 00:13:20,660
Python mock library has this thing

00:13:17,990 --> 00:13:22,550
called call args and kwargs lists so to

00:13:20,660 --> 00:13:26,600
save you a bit of blood sweat and tears

00:13:22,550 --> 00:13:28,910
the first index element contains all the

00:13:26,600 --> 00:13:30,980
positional arguments it's not just stuff

00:13:28,910 --> 00:13:33,430
that you put in star args but anything

00:13:30,980 --> 00:13:37,420
that's called as a positional argument

00:13:33,430 --> 00:13:40,240
the second index is anything that you

00:13:37,420 --> 00:13:43,600
call it's a keyword args if the thing is

00:13:40,240 --> 00:13:46,270
a method that's on an object self will

00:13:43,600 --> 00:13:50,170
be the first positional argument but if

00:13:46,270 --> 00:13:51,940
it is a class method class is not passed

00:13:50,170 --> 00:13:54,670
as a positional argument even though you

00:13:51,940 --> 00:13:56,890
put it in the code because Python

00:13:54,670 --> 00:13:59,589
already knows the name of the class so

00:13:56,890 --> 00:14:01,660
class is actually not passed as the

00:13:59,589 --> 00:14:02,529
first positional keyword are so first

00:14:01,660 --> 00:14:04,360
positional Arg

00:14:02,529 --> 00:14:06,250
even though you actually physically

00:14:04,360 --> 00:14:09,160
write CLS or what do you want to call it

00:14:06,250 --> 00:14:10,510
in the code and if it's a static method

00:14:09,160 --> 00:14:12,820
where you're expecting not something to

00:14:10,510 --> 00:14:14,890
be passed about stage call args list is

00:14:12,820 --> 00:14:17,890
used when you're calling the function

00:14:14,890 --> 00:14:20,589
more than once it allows you to to make

00:14:17,890 --> 00:14:26,620
assertions on the parameters for each

00:14:20,589 --> 00:14:27,970
call so next thing is mix-ins so we

00:14:26,620 --> 00:14:30,460
discussed the mix-ins a little bit

00:14:27,970 --> 00:14:33,430
before and so if you write a mix scene

00:14:30,460 --> 00:14:35,100
and you you be wanting to test a myth

00:14:33,430 --> 00:14:41,050
it's method so in this case we've got a

00:14:35,100 --> 00:14:42,970
validation object which is designed it's

00:14:41,050 --> 00:14:46,810
a mix inside it's designed to work with

00:14:42,970 --> 00:14:49,450
other with other stuff and it has an

00:14:46,810 --> 00:14:52,810
innate method that does some stuff so to

00:14:49,450 --> 00:14:55,540
test that in our test server vowel

00:14:52,810 --> 00:14:57,070
mixing which is not in the database so

00:14:55,540 --> 00:15:00,690
we can use simple test case to make

00:14:57,070 --> 00:15:05,200
things a bit faster so we create a dummy

00:15:00,690 --> 00:15:07,750
field that inherits from the test class

00:15:05,200 --> 00:15:10,390
that's the class that's under test plus

00:15:07,750 --> 00:15:11,709
char field that field doesn't need it do

00:15:10,390 --> 00:15:12,910
it that class doesn't need to do

00:15:11,709 --> 00:15:16,690
anything else so that's why we've got

00:15:12,910 --> 00:15:18,220
passed there and when we create this

00:15:16,690 --> 00:15:20,380
field we're going to be calling the unit

00:15:18,220 --> 00:15:22,900
method but we don't want to call the

00:15:20,380 --> 00:15:25,630
init method of char field because I

00:15:22,900 --> 00:15:28,510
don't care what goes on inside that I'm

00:15:25,630 --> 00:15:31,660
not testing Django I'm testing my code

00:15:28,510 --> 00:15:35,350
so I don't want to I just I need to

00:15:31,660 --> 00:15:37,600
patch that theme and so wherever the top

00:15:35,350 --> 00:15:39,070
there wherever surveil mix-ins defined

00:15:37,600 --> 00:15:41,640
that's the thing I need put next to

00:15:39,070 --> 00:15:43,959
patch object module we're imported to

00:15:41,640 --> 00:15:46,810
not where it's defined where it's

00:15:43,959 --> 00:15:47,230
important to the init method auto spec

00:15:46,810 --> 00:15:48,610
equals

00:15:47,230 --> 00:15:51,610
true and it doesn't return anything so

00:15:48,610 --> 00:15:54,280
don't any return baby so then in the

00:15:51,610 --> 00:15:56,980
test I create the test field you could

00:15:54,280 --> 00:16:00,100
see I'm using keyword args the double

00:15:56,980 --> 00:16:01,630
star I'm passing in whatever doesn't

00:16:00,100 --> 00:16:04,810
matter what I'm just passing in some

00:16:01,630 --> 00:16:07,630
dictionary but this an admit that is

00:16:04,810 --> 00:16:09,670
supposed to pass that on this test case

00:16:07,630 --> 00:16:14,950
is is testing where I provide no

00:16:09,670 --> 00:16:16,780
settings to the to the actual mixing but

00:16:14,950 --> 00:16:18,250
the mixing is used in the context of

00:16:16,780 --> 00:16:21,400
where it's mixed in with something else

00:16:18,250 --> 00:16:25,210
you never use it a lot and so one of the

00:16:21,400 --> 00:16:28,120
assertions which is the bottom one tests

00:16:25,210 --> 00:16:32,710
to see whether the net method of the of

00:16:28,120 --> 00:16:34,960
the base class was called with that 11

00:16:32,710 --> 00:16:38,350
and 12 dictionary that's what that

00:16:34,960 --> 00:16:41,350
bottom line is doing so I'm actually

00:16:38,350 --> 00:16:43,450
seeing I'm testing the super call in the

00:16:41,350 --> 00:16:47,250
mid method and if it doesn't pass it on

00:16:43,450 --> 00:16:51,220
then my assertion will fail

00:16:47,250 --> 00:16:53,050
so just a few comments about marks by

00:16:51,220 --> 00:16:54,880
default when you when you create a mark

00:16:53,050 --> 00:16:56,320
everything's defined so if you're

00:16:54,880 --> 00:17:01,870
testing that it's not there you need to

00:16:56,320 --> 00:17:05,950
delete it which is under so in this this

00:17:01,870 --> 00:17:08,860
test case here we see on line 3 & 4 this

00:17:05,950 --> 00:17:11,680
del mock one dot save and del to mock so

00:17:08,860 --> 00:17:15,460
this is testing something that is a

00:17:11,680 --> 00:17:17,500
mixing that could be used with a model

00:17:15,460 --> 00:17:19,960
form but it could be used in an ordinary

00:17:17,500 --> 00:17:22,540
form and model forms have got a save

00:17:19,960 --> 00:17:24,160
method and ordinary forms don't well

00:17:22,540 --> 00:17:25,390
what happens I want to test it with

00:17:24,160 --> 00:17:27,760
something that has it in something that

00:17:25,390 --> 00:17:30,130
doesn't and is it going to work or is it

00:17:27,760 --> 00:17:36,240
going to just throw an exception and so

00:17:30,130 --> 00:17:36,240
this this test method tests for that

00:17:36,540 --> 00:17:41,140
it's setting up a view that's got some

00:17:39,010 --> 00:17:45,220
forms it creates a dictionary of forms

00:17:41,140 --> 00:17:48,160
for modern form 2 and it then passes

00:17:45,220 --> 00:17:53,200
that to the form valid method of the

00:17:48,160 --> 00:17:54,670
thing that's under test another note is

00:17:53,200 --> 00:17:57,460
up the top you see there's three patches

00:17:54,670 --> 00:18:00,880
its patching they get success URL

00:17:57,460 --> 00:18:03,730
because that's what form about if you

00:18:00,880 --> 00:18:06,520
call for valid call form valid calls

00:18:03,730 --> 00:18:07,690
that get success URL so but I don't want

00:18:06,520 --> 00:18:09,970
it to do that I don't want it to go

00:18:07,690 --> 00:18:14,020
through the class-based view hierarchy I

00:18:09,970 --> 00:18:16,900
just want it to to do what I need this

00:18:14,020 --> 00:18:21,400
thing to do I don't want it to redirect

00:18:16,900 --> 00:18:23,590
I don't it's calling the it's it's doing

00:18:21,400 --> 00:18:25,840
its saving several forms its doing it at

00:18:23,590 --> 00:18:28,090
a transaction is that transaction

00:18:25,840 --> 00:18:29,890
actually invoked and the assertion that

00:18:28,090 --> 00:18:33,010
tests for that is the fourth up from the

00:18:29,890 --> 00:18:34,420
bottom one little quick tip when it

00:18:33,010 --> 00:18:36,280
comes to these patches when there's more

00:18:34,420 --> 00:18:38,620
than one of them

00:18:36,280 --> 00:18:41,200
the order unique it's like a mirror

00:18:38,620 --> 00:18:44,860
image the closest one in is the first

00:18:41,200 --> 00:18:47,410
the TA patch then the next one up is the

00:18:44,860 --> 00:18:49,600
HAR patch you need to do them in a

00:18:47,410 --> 00:18:53,140
mirror order not the top patch is the

00:18:49,600 --> 00:18:55,960
first positional argument after self you

00:18:53,140 --> 00:18:57,250
do them like in a in a mirror image is

00:18:55,960 --> 00:18:59,980
the best way that I found to think about

00:18:57,250 --> 00:19:04,630
that so we're getting low on time so

00:18:59,980 --> 00:19:08,110
just a a quick a quick look at template

00:19:04,630 --> 00:19:10,240
unit testing so here's a dictionary

00:19:08,110 --> 00:19:11,980
object that but the base test just does

00:19:10,240 --> 00:19:13,180
what Jango does but it also does

00:19:11,980 --> 00:19:15,640
indirect lookups

00:19:13,180 --> 00:19:19,210
so I test it to see whether it can do

00:19:15,640 --> 00:19:21,550
those things or not so all I need to do

00:19:19,210 --> 00:19:23,410
is to set up a template with a minimal

00:19:21,550 --> 00:19:25,900
string that just load the test tags and

00:19:23,410 --> 00:19:29,050
then actually invokes the tag set up a

00:19:25,900 --> 00:19:31,240
context run it which is what that render

00:19:29,050 --> 00:19:33,340
function does dumps the resulting

00:19:31,240 --> 00:19:36,280
rendered and then I can assert that that

00:19:33,340 --> 00:19:38,220
rendered the tag is doing what it's

00:19:36,280 --> 00:19:41,740
supposed to be doing

00:19:38,220 --> 00:19:44,950
all right so in summary a unit test is

00:19:41,740 --> 00:19:47,980
focused on a specific method and that's

00:19:44,950 --> 00:19:51,370
it whatever that methods doing directly

00:19:47,980 --> 00:19:53,470
or what it's calling how when I say when

00:19:51,370 --> 00:19:55,810
it what it's calling only how it calls

00:19:53,470 --> 00:19:59,820
it and what comes back not what's going

00:19:55,810 --> 00:19:59,820
on inside that's effectively a blackbox

00:20:01,080 --> 00:20:05,350
view classes you set up the instance

00:20:03,760 --> 00:20:07,000
with sort of a dummy function and you'll

00:20:05,350 --> 00:20:09,160
probably find versions of that around on

00:20:07,000 --> 00:20:11,140
the net or I'll look to try and put

00:20:09,160 --> 00:20:12,910
these slides up they've got the Twitter

00:20:11,140 --> 00:20:13,850
handle there so I've got to get them

00:20:12,910 --> 00:20:18,540
hosted somewhere

00:20:13,850 --> 00:20:20,490
and so you're testing on arguments to

00:20:18,540 --> 00:20:23,309
test the cohesion and you use dummy

00:20:20,490 --> 00:20:26,850
classes subclasses to text to test mix

00:20:23,309 --> 00:20:29,040
in mocks you can have they have

00:20:26,850 --> 00:20:31,170
attributes which we didn't get too much

00:20:29,040 --> 00:20:33,450
time to go into and you need to delete

00:20:31,170 --> 00:20:36,480
attributes and methods where you need to

00:20:33,450 --> 00:20:45,809
test for their absence so we've got any

00:20:36,480 --> 00:20:47,610
questions do you find that getting in

00:20:45,809 --> 00:20:49,790
particularly the last example where

00:20:47,610 --> 00:20:52,260
you're sort of mocking things and

00:20:49,790 --> 00:20:54,090
getting into a little bit of the

00:20:52,260 --> 00:20:57,200
semantics of how the underlying layers

00:20:54,090 --> 00:20:59,910
work do you find that tests the

00:20:57,200 --> 00:21:03,150
semantics change between versions of

00:20:59,910 --> 00:21:04,830
Django or versions of Python in other

00:21:03,150 --> 00:21:06,750
words your tests are very detailed and

00:21:04,830 --> 00:21:09,620
very specific and and do you find that

00:21:06,750 --> 00:21:12,179
there's an additional maintenance burden

00:21:09,620 --> 00:21:13,740
by getting into that much detail that

00:21:12,179 --> 00:21:15,660
you're that you're doing I mean the

00:21:13,740 --> 00:21:19,110
tests look very nice but I worry about

00:21:15,660 --> 00:21:21,510
maintenance okay it does exist but it's

00:21:19,110 --> 00:21:24,809
minimal and the advantage of testing

00:21:21,510 --> 00:21:27,090
this way is that it pays off for it so

00:21:24,809 --> 00:21:29,070
many times what typically happens as you

00:21:27,090 --> 00:21:30,390
write all these unit tests is your

00:21:29,070 --> 00:21:32,790
there's a lot of assurance on the

00:21:30,390 --> 00:21:34,650
underlying code when you come to do an

00:21:32,790 --> 00:21:36,480
integration test you might find that a

00:21:34,650 --> 00:21:39,600
few bits don't quite fit in quite right

00:21:36,480 --> 00:21:43,050
but once you fix the cohesion issues

00:21:39,600 --> 00:21:45,240
everything just seems to work going from

00:21:43,050 --> 00:21:48,120
one version to Django to the other the

00:21:45,240 --> 00:21:49,410
problems that can arise from that where

00:21:48,120 --> 00:21:53,370
you actually got to change the code

00:21:49,410 --> 00:21:54,960
under test not the testing code because

00:21:53,370 --> 00:21:57,510
the testing code is mocking out all this

00:21:54,960 --> 00:21:59,910
other stuff but your code is expecting

00:21:57,510 --> 00:22:02,490
Django to work in a certain way

00:21:59,910 --> 00:22:04,910
and that's all you're testing so the

00:22:02,490 --> 00:22:08,160
problems are really when they do arise

00:22:04,910 --> 00:22:10,980
with your tested code not your testing

00:22:08,160 --> 00:22:13,050
code and you want your tests to fail in

00:22:10,980 --> 00:22:18,690
that situation so I have a question

00:22:13,050 --> 00:22:20,550
about how do you go about deciding if an

00:22:18,690 --> 00:22:24,210
integration test would be better for a

00:22:20,550 --> 00:22:27,510
particular view rather than you know

00:22:24,210 --> 00:22:30,720
doing a unit test for each little blah

00:22:27,510 --> 00:22:35,220
of code because it seems like with an

00:22:30,720 --> 00:22:38,310
integration test you can easily request

00:22:35,220 --> 00:22:42,210
do the request and and make sure you get

00:22:38,310 --> 00:22:44,280
back what you're wanting but with a unit

00:22:42,210 --> 00:22:46,470
test in your examples anyway there's a

00:22:44,280 --> 00:22:48,090
lot of setup in terms of mocking the

00:22:46,470 --> 00:22:50,190
things that you don't want and you have

00:22:48,090 --> 00:22:51,990
to decide what you don't want and that

00:22:50,190 --> 00:22:55,380
type of thing um well the answer to that

00:22:51,990 --> 00:22:57,780
is I do both I integration test the user

00:22:55,380 --> 00:23:00,090
stories including the alternative cases

00:22:57,780 --> 00:23:01,830
from use case text so I want to see that

00:23:00,090 --> 00:23:04,320
those stories are captured in the

00:23:01,830 --> 00:23:05,970
integration tests and then the unit

00:23:04,320 --> 00:23:09,270
tests focus on the detail of each

00:23:05,970 --> 00:23:11,670
function so I don't do a trade-off there

00:23:09,270 --> 00:23:14,430
I actually do both and it improves the

00:23:11,670 --> 00:23:16,770
integrity of the code once you get used

00:23:14,430 --> 00:23:18,390
to these mocks and dummy objects you get

00:23:16,770 --> 00:23:21,600
used to pumping them out pretty quickly

00:23:18,390 --> 00:23:23,220
like the RM you can have complicated

00:23:21,600 --> 00:23:25,020
queries you don't need to worry about

00:23:23,220 --> 00:23:27,720
setting up fixtures you just look at

00:23:25,020 --> 00:23:30,210
your parameters an integration test

00:23:27,720 --> 00:23:32,640
needs fixtures and the integration test

00:23:30,210 --> 00:23:34,560
to see if your query makes sense or not

00:23:32,640 --> 00:23:36,900
and then your unit tests can deal with

00:23:34,560 --> 00:23:38,400
all the little edge cases where they'll

00:23:36,900 --> 00:23:40,680
be pretty much impossible to create all

00:23:38,400 --> 00:23:44,150
those fixtures so in the end it ends up

00:23:40,680 --> 00:23:44,610
working quite quickly thank you again

00:23:44,150 --> 00:23:52,240
[Music]

00:23:44,610 --> 00:23:52,240

YouTube URL: https://www.youtube.com/watch?v=Ue-a20-tKPI


