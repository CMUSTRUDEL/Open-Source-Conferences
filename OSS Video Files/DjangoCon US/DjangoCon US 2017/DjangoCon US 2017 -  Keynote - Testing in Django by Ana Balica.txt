Title: DjangoCon US 2017 -  Keynote - Testing in Django by Ana Balica
Publication date: 2017-09-07
Playlist: DjangoCon US 2017
Description: 
	DjangoCon US 2017 -  Keynote - Testing in Django by Ana Balica

The Django documentation section on testing starts with this: “Automated testing is an extremely useful bug-killing tool for the modern Web developer.” Nobody can argue with that. Testing is an integral part of modern software development, and Ana’s talk will offer an in-depth overview of how the Django testing framework evolved; showcase some common techniques, tools, and best practices; talk about speed improvements; and guide you through a real-world example of testing a Django app. Testing is fun, isn’t it?

This talk was presented at: https://2017.djangocon.us/talks/keynote-2/

LINKS:
Follow Ana Balica 👇
On Twitter: https://twitter.com/anabalica
Official homepage: https://ana-balica.github.io

Follow DjangCon US 👇
https://twitter.com/djangocon

Follow DEFNA 👇
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:00,000 --> 00:00:17,680
[Music]

00:00:13,470 --> 00:00:19,960
good morning everyone morning how are

00:00:17,680 --> 00:00:24,250
you feeling great

00:00:19,960 --> 00:00:26,110
are you energized a full of energy oh

00:00:24,250 --> 00:00:28,689
that's just repeating myself people have

00:00:26,110 --> 00:00:37,000
energy to get started with a day full of

00:00:28,689 --> 00:00:39,250
learning yes yes we are and we're going

00:00:37,000 --> 00:00:42,910
to get started with a very long talk a

00:00:39,250 --> 00:00:44,430
few rough overview of testing in Django

00:00:42,910 --> 00:00:47,230
and within Django

00:00:44,430 --> 00:00:49,480
I'd like to say thank you to the

00:00:47,230 --> 00:00:52,690
organizers and the volunteers who make

00:00:49,480 --> 00:00:56,170
Django con us happen because you and I

00:00:52,690 --> 00:00:59,320
we have no idea how much effort it takes

00:00:56,170 --> 00:01:01,960
to bring a conference to life and not

00:00:59,320 --> 00:01:04,390
only that would also create a welcoming

00:01:01,960 --> 00:01:07,740
environment where we all feel safe so

00:01:04,390 --> 00:01:07,740
let's just give them a round of applause

00:01:13,510 --> 00:01:21,290
you might be wondering who am i I'm Anna

00:01:16,850 --> 00:01:28,310
hello and this is my twitter handle if

00:01:21,290 --> 00:01:30,170
you want to get in touch with me there's

00:01:28,310 --> 00:01:31,729
nothing you probably haven't heard about

00:01:30,170 --> 00:01:33,970
me because there's nothing outstanding

00:01:31,729 --> 00:01:36,050
that I did in my life

00:01:33,970 --> 00:01:37,820
generally I'm the kind of person who

00:01:36,050 --> 00:01:41,330
goes to work every day and tries to be

00:01:37,820 --> 00:01:43,509
the best developer I can become I

00:01:41,330 --> 00:01:46,100
usually say I'm in a long-term

00:01:43,509 --> 00:01:48,500
successful and happy relationship with

00:01:46,100 --> 00:01:52,130
Python I've been doing Jango for the

00:01:48,500 --> 00:01:53,930
past couple of years and in terms of

00:01:52,130 --> 00:01:58,070
community involvement I usually do

00:01:53,930 --> 00:02:02,990
little things currently I'm Co

00:01:58,070 --> 00:02:07,160
organizing the London hi ladies

00:02:02,990 --> 00:02:10,789
Meetup and I have organized Jenga con

00:02:07,160 --> 00:02:13,820
Europe last year I sometimes mentor

00:02:10,789 --> 00:02:17,450
people and most often I gave talks at

00:02:13,820 --> 00:02:19,670
conferences I recently joined a company

00:02:17,450 --> 00:02:24,110
called street team as a senior software

00:02:19,670 --> 00:02:25,970
engineer so yes questions I won't be

00:02:24,110 --> 00:02:29,810
taking questions on stage and there are

00:02:25,970 --> 00:02:32,209
two reasons for that first is we

00:02:29,810 --> 00:02:35,299
actually might run out of time and the

00:02:32,209 --> 00:02:36,709
second one is it never works out for me

00:02:35,299 --> 00:02:39,799
I'll be honest

00:02:36,709 --> 00:02:43,100
well I'm most age I'm a bit nervous and

00:02:39,799 --> 00:02:45,049
by the end of the talk it's getting a

00:02:43,100 --> 00:02:47,299
little bit tricky to think straight and

00:02:45,049 --> 00:02:48,620
give a proper answer to a question and I

00:02:47,299 --> 00:02:50,860
feel like I'm actually doing a

00:02:48,620 --> 00:02:53,810
disservice so let's take it off stage

00:02:50,860 --> 00:02:57,850
I'll be a Django Cohen for the rest of

00:02:53,810 --> 00:03:00,079
the conference until Friday so come and

00:02:57,850 --> 00:03:03,260
come to me if you have questions

00:03:00,079 --> 00:03:08,120
comments or feedback I'll be happy to

00:03:03,260 --> 00:03:09,799
have a chat with you right so now that

00:03:08,120 --> 00:03:12,350
we got to know each other a little bit

00:03:09,799 --> 00:03:15,049
better let's get started with testing

00:03:12,350 --> 00:03:19,489
we're going to take a trip all the way

00:03:15,049 --> 00:03:22,870
from version 1.0 to 1.11 and see how the

00:03:19,489 --> 00:03:26,410
Django test framework evolved over time

00:03:22,870 --> 00:03:29,319
it all started about 10 11 years ago

00:03:26,410 --> 00:03:34,690
sometime before getting jungle out of

00:03:29,319 --> 00:03:36,580
beta this stick it gets created ad unit

00:03:34,690 --> 00:03:39,220
s framework for end-user django

00:03:36,580 --> 00:03:42,250
applications and it lists all sorts of

00:03:39,220 --> 00:03:45,010
benefits that you can have while having

00:03:42,250 --> 00:03:48,069
an integrated framework to test your

00:03:45,010 --> 00:03:50,680
apps but there's this killer argument as

00:03:48,069 --> 00:03:57,489
an added incentive this is a feature

00:03:50,680 --> 00:04:00,099
that is present in rails and that's how

00:03:57,489 --> 00:04:03,610
it started it started with a management

00:04:00,099 --> 00:04:05,709
command test it accepts you to pass at

00:04:03,610 --> 00:04:09,579
the time that point to test so you get a

00:04:05,709 --> 00:04:11,799
AB dot test closed dot test method we

00:04:09,579 --> 00:04:13,510
get a test runner a test runner is also

00:04:11,799 --> 00:04:16,090
a config variable that points to a

00:04:13,510 --> 00:04:18,280
function that runs your tests that means

00:04:16,090 --> 00:04:20,289
that from the very beginning anyone can

00:04:18,280 --> 00:04:23,080
write their own test Runner and has

00:04:20,289 --> 00:04:25,180
discovered the test runner setups the

00:04:23,080 --> 00:04:27,580
test environment and it looks up for

00:04:25,180 --> 00:04:29,789
tests in files tested by and models that

00:04:27,580 --> 00:04:32,289
part at the very end the test Runner

00:04:29,789 --> 00:04:35,770
teardowns the test environment and

00:04:32,289 --> 00:04:38,139
returns the results at this point you

00:04:35,770 --> 00:04:42,070
might be squinting and thinking models

00:04:38,139 --> 00:04:44,349
at Phi if she's serious well 10 years

00:04:42,070 --> 00:04:46,630
ago apparently doctors were very popular

00:04:44,349 --> 00:04:50,349
and they were used to test all around a

00:04:46,630 --> 00:04:53,289
lot so models that why we're the place

00:04:50,349 --> 00:04:55,660
where model an application-level tests

00:04:53,289 --> 00:04:59,770
were meant to be and everything that

00:04:55,660 --> 00:05:02,500
else was left to testify client makes

00:04:59,770 --> 00:05:04,930
its appearance as a basic stateful

00:05:02,500 --> 00:05:07,360
browser mimicking mimicking stub that

00:05:04,930 --> 00:05:10,300
constructs request passes them to the

00:05:07,360 --> 00:05:13,320
views and returns a response bypassing

00:05:10,300 --> 00:05:15,430
all networking altogether and

00:05:13,320 --> 00:05:19,240
interacting directly with a whiskey

00:05:15,430 --> 00:05:21,099
interface at its core client it is the

00:05:19,240 --> 00:05:22,919
same kind that we have today is just a

00:05:21,099 --> 00:05:25,499
more limited one

00:05:22,919 --> 00:05:27,900
if you're writing your tasks using

00:05:25,499 --> 00:05:30,180
Python unit test library then you've

00:05:27,900 --> 00:05:32,340
probably heard of test case or Django

00:05:30,180 --> 00:05:35,610
also has its own version of the test

00:05:32,340 --> 00:05:37,770
case which is an extension of the unit

00:05:35,610 --> 00:05:40,139
test test case because it can also do

00:05:37,770 --> 00:05:42,810
extra things like load fixtures and

00:05:40,139 --> 00:05:45,749
clean the stubby mailbox and initialize

00:05:42,810 --> 00:05:48,659
the client and clean clean the data

00:05:45,749 --> 00:05:51,479
after each test and it provides a couple

00:05:48,659 --> 00:05:53,520
of assert helper methods for example

00:05:51,479 --> 00:05:54,840
like I said redirection template here is

00:05:53,520 --> 00:05:59,090
the ones that we actually still have

00:05:54,840 --> 00:06:03,360
today version 1.1 comes shortly after

00:05:59,090 --> 00:06:06,330
with a revolutionary set of HTTP methods

00:06:03,360 --> 00:06:08,250
so restful api is are not yet the next

00:06:06,330 --> 00:06:11,219
big thing but Django is looking into the

00:06:08,250 --> 00:06:15,330
future and as to the client put had

00:06:11,219 --> 00:06:18,000
delete and options along with the test

00:06:15,330 --> 00:06:20,129
case we also get a transaction test case

00:06:18,000 --> 00:06:21,509
this is where we need to make a clear

00:06:20,129 --> 00:06:23,370
distinction what is the difference

00:06:21,509 --> 00:06:26,279
between a test case and a transaction

00:06:23,370 --> 00:06:28,949
test case so a test case acts like a

00:06:26,279 --> 00:06:30,960
burger because it wraps each test into

00:06:28,949 --> 00:06:33,180
an atomic block it enters the

00:06:30,960 --> 00:06:35,419
transaction it runs the test that as

00:06:33,180 --> 00:06:38,490
does messy things to the database and

00:06:35,419 --> 00:06:40,439
finally the test case rollbacks this

00:06:38,490 --> 00:06:43,800
transaction and leaves a clean slate for

00:06:40,439 --> 00:06:47,399
the next test because of that a test

00:06:43,800 --> 00:06:50,699
case will always prevent any commits all

00:06:47,399 --> 00:06:51,990
roll backs to the database because it

00:06:50,699 --> 00:06:54,539
wants to ensure that at the very end

00:06:51,990 --> 00:06:56,580
when you roll backs the transaction the

00:06:54,539 --> 00:06:58,979
test restores the database to its

00:06:56,580 --> 00:07:02,370
initial state and this is a big

00:06:58,979 --> 00:07:05,310
performance booster to the test case and

00:07:02,370 --> 00:07:07,349
for us to writing our tests if you want

00:07:05,310 --> 00:07:10,409
to use transactions that this is where

00:07:07,349 --> 00:07:12,719
you need to use transaction test case it

00:07:10,409 --> 00:07:15,270
will clean up after each test by

00:07:12,719 --> 00:07:17,370
flushing the database at the start of

00:07:15,270 --> 00:07:19,349
each test and by the way the test case

00:07:17,370 --> 00:07:24,779
from the previous version 1.0 is doing

00:07:19,349 --> 00:07:28,050
exactly that 1.2 Django defines a new

00:07:24,779 --> 00:07:30,509
interface for test runners so we're

00:07:28,050 --> 00:07:32,759
switching from a function to a class the

00:07:30,509 --> 00:07:33,620
class should have a method called run

00:07:32,759 --> 00:07:36,830
tests

00:07:33,620 --> 00:07:40,690
will act as an entry point by default

00:07:36,830 --> 00:07:43,940
Jenko provides Django test suit runner

00:07:40,690 --> 00:07:46,070
so this is not really related to the

00:07:43,940 --> 00:07:48,500
evolution of the Django test framework

00:07:46,070 --> 00:07:52,160
but it's a it's a silly bug that I

00:07:48,500 --> 00:07:53,570
really like so I decided to put it in so

00:07:52,160 --> 00:07:56,090
the test runner returns the number of

00:07:53,570 --> 00:08:00,050
errors plus failures all some together

00:07:56,090 --> 00:08:03,530
and what django does it spits out this

00:08:00,050 --> 00:08:06,740
number of failed tests as a city exit so

00:08:03,530 --> 00:08:08,900
if you have if no tests have failed then

00:08:06,740 --> 00:08:11,120
it will naturally exit with a zero which

00:08:08,900 --> 00:08:12,530
is a success if you have one test

00:08:11,120 --> 00:08:14,810
failure then this is going to be one

00:08:12,530 --> 00:08:17,300
which is a failure that looks correct if

00:08:14,810 --> 00:08:21,050
you have 42 failed tests that'll be fine

00:08:17,300 --> 00:08:31,370
as well if you have 256 it suddenly

00:08:21,050 --> 00:08:34,130
becomes a success whoops this is because

00:08:31,370 --> 00:08:36,080
this exit number is an 8-bit number so

00:08:34,130 --> 00:08:40,430
it overflows into a zero when you have

00:08:36,080 --> 00:08:47,600
256 I'm talking from experience it's not

00:08:40,430 --> 00:08:51,410
very hard to get 256 fail tests so we

00:08:47,600 --> 00:08:53,510
fixed it we just say CS exit 1 so now

00:08:51,410 --> 00:08:59,690
will always either get a zero for

00:08:53,510 --> 00:09:02,810
success or a 1 for failure 256 now is a

00:08:59,690 --> 00:09:04,130
failure as it should be let's take a

00:09:02,810 --> 00:09:05,870
look at the definition of the test

00:09:04,130 --> 00:09:08,839
runner because something changed from

00:09:05,870 --> 00:09:11,839
the previous fashion there's a new

00:09:08,839 --> 00:09:14,209
argument fail fast it allows you to

00:09:11,839 --> 00:09:18,709
terminate the test run on the first

00:09:14,209 --> 00:09:20,480
failure and I find it very handy if the

00:09:18,709 --> 00:09:22,339
implementation has been removed ever

00:09:20,480 --> 00:09:24,860
since from the Django test framework

00:09:22,339 --> 00:09:27,529
because it's now available within the

00:09:24,860 --> 00:09:30,589
Python unit test lib but good to know it

00:09:27,529 --> 00:09:32,779
exists Django has support for multiple

00:09:30,589 --> 00:09:35,209
databases with our application strategy

00:09:32,779 --> 00:09:38,720
so you can have primary database and

00:09:35,209 --> 00:09:41,060
multiple replicas can be created this is

00:09:38,720 --> 00:09:43,430
how it looks like in DB settings there's

00:09:41,060 --> 00:09:45,980
a default database

00:09:43,430 --> 00:09:48,560
there's a replica if the test mirror

00:09:45,980 --> 00:09:50,800
setting from the replica dictionary is

00:09:48,560 --> 00:09:53,500
missing then there won't be any

00:09:50,800 --> 00:09:56,390
replication happening during your tests

00:09:53,500 --> 00:09:59,290
just the default database is created and

00:09:56,390 --> 00:10:02,089
tested against if you want to test

00:09:59,290 --> 00:10:04,160
replication then you need to set up a

00:10:02,089 --> 00:10:08,390
test mirror and if you want to use it

00:10:04,160 --> 00:10:09,250
today settings have changed so should

00:10:08,390 --> 00:10:13,040
look like this

00:10:09,250 --> 00:10:15,080
so let's go back to our databases when

00:10:13,040 --> 00:10:18,550
the test environment is configured a

00:10:15,080 --> 00:10:21,440
test version of the replica is not

00:10:18,550 --> 00:10:23,870
created instead the connection to

00:10:21,440 --> 00:10:26,720
replicas will be redirected to point a

00:10:23,870 --> 00:10:29,149
default so as a result the rights to the

00:10:26,720 --> 00:10:32,029
default will appear on the replica but

00:10:29,149 --> 00:10:33,800
not because there's in this sort of data

00:10:32,029 --> 00:10:35,480
replication happening between the two

00:10:33,800 --> 00:10:42,440
but because it's actually the same

00:10:35,480 --> 00:10:44,660
database 1.3 we can now do a third query

00:10:42,440 --> 00:10:47,209
set equal and assert number of queries

00:10:44,660 --> 00:10:49,910
which is handy for the test case we also

00:10:47,209 --> 00:10:52,250
see a split of the two roles that

00:10:49,910 --> 00:10:55,070
declined embodied so the role of

00:10:52,250 --> 00:10:57,260
manufacturing requests is turned over to

00:10:55,070 --> 00:11:00,290
the request factory and obtaining the

00:10:57,260 --> 00:11:02,839
response was left to the client the

00:11:00,290 --> 00:11:05,900
requestfactory becomes part of the

00:11:02,839 --> 00:11:07,040
public documented API so how do you

00:11:05,900 --> 00:11:10,300
manufacture requests with the

00:11:07,040 --> 00:11:14,180
requestfactory very simple you just

00:11:10,300 --> 00:11:16,160
create a whiskey request object with a

00:11:14,180 --> 00:11:18,560
set of whiskey and request specific

00:11:16,160 --> 00:11:22,670
attributes like the protocol the request

00:11:18,560 --> 00:11:24,589
method payload cookies URL scheme that's

00:11:22,670 --> 00:11:29,120
pretty much it doesn't do anything else

00:11:24,589 --> 00:11:32,870
very simple very tractor ish so dog

00:11:29,120 --> 00:11:33,800
tests in the beginning it seemed like

00:11:32,870 --> 00:11:35,839
such a great idea

00:11:33,800 --> 00:11:37,640
you get both tests and you got and you

00:11:35,839 --> 00:11:40,250
get both documentation

00:11:37,640 --> 00:11:43,580
in the long run it became a nuisance to

00:11:40,250 --> 00:11:46,490
pick up to debug it also became apparent

00:11:43,580 --> 00:11:48,200
that doctors aren't really good at

00:11:46,490 --> 00:11:51,290
providing neither high quality

00:11:48,200 --> 00:11:54,070
documentation no comprehensive tests

00:11:51,290 --> 00:11:57,440
that's why doctors will be discovered

00:11:54,070 --> 00:11:59,630
discouraged to be used in the future and

00:11:57,440 --> 00:12:02,000
Django is a good example of a big

00:11:59,630 --> 00:12:04,070
project that came through a loved stage

00:12:02,000 --> 00:12:09,170
with the doctors and just proved that

00:12:04,070 --> 00:12:11,210
this relationship can't work 1.4 in

00:12:09,170 --> 00:12:13,520
version 1.4 the familiar of the test

00:12:11,210 --> 00:12:15,770
case classes receives an exam extension

00:12:13,520 --> 00:12:17,360
pack so we also we get a simple test

00:12:15,770 --> 00:12:21,470
case and the live server test case

00:12:17,360 --> 00:12:25,040
simple test case is very light because

00:12:21,470 --> 00:12:27,770
it doesn't hit the database my server

00:12:25,040 --> 00:12:29,600
test case runs an HTTP server so that

00:12:27,770 --> 00:12:32,600
you can use a testing framework like

00:12:29,600 --> 00:12:35,920
selenium for your end-to-end tests and

00:12:32,600 --> 00:12:39,620
it is based on the transaction test case

00:12:35,920 --> 00:12:44,030
version 1.5 is the time when poison-free

00:12:39,620 --> 00:12:45,920
support landed in django rio we talked

00:12:44,030 --> 00:12:47,780
about the transaction test case and we

00:12:45,920 --> 00:12:52,130
said that it's flushing the database

00:12:47,780 --> 00:12:53,690
before each test well at the time all

00:12:52,130 --> 00:12:55,880
the tests run has become popular for

00:12:53,690 --> 00:12:58,190
example nerves and developers figured

00:12:55,880 --> 00:13:00,350
out that there's a bit of a mass left by

00:12:58,190 --> 00:13:02,810
the transaction test case so it has been

00:13:00,350 --> 00:13:06,010
updated so that now we flush the

00:13:02,810 --> 00:13:09,140
database not before each test but after

00:13:06,010 --> 00:13:12,320
let me show you so if you flush the

00:13:09,140 --> 00:13:14,180
database before the test you get the

00:13:12,320 --> 00:13:16,190
following sequence of actions you flush

00:13:14,180 --> 00:13:18,470
you run the transaction test case and

00:13:16,190 --> 00:13:21,350
then you can run your test cases what

00:13:18,470 --> 00:13:23,120
happens is that right after the running

00:13:21,350 --> 00:13:25,100
the transaction test case you get some

00:13:23,120 --> 00:13:27,980
dirty state right writing there so your

00:13:25,100 --> 00:13:32,420
test cases actually start with a not

00:13:27,980 --> 00:13:35,570
clean database that's why Django default

00:13:32,420 --> 00:13:38,060
test Runner is always rearranging tests

00:13:35,570 --> 00:13:40,970
so that the test case is run first and

00:13:38,060 --> 00:13:44,660
then the transaction test cases go come

00:13:40,970 --> 00:13:46,730
and even even though the transaction

00:13:44,660 --> 00:13:48,050
test case leaves some dirty stating

00:13:46,730 --> 00:13:52,990
there it actually doesn't matter because

00:13:48,050 --> 00:13:55,070
we're going to destroy the database but

00:13:52,990 --> 00:13:55,820
we can solve this problem in a different

00:13:55,070 --> 00:13:57,740
way

00:13:55,820 --> 00:13:59,450
we can just flush after and then all of

00:13:57,740 --> 00:14:00,710
our problems are solved and it doesn't

00:13:59,450 --> 00:14:05,720
really matter in what order we're

00:14:00,710 --> 00:14:08,450
running our tests one point six so

00:14:05,720 --> 00:14:09,080
there's one more HTTP method added to

00:14:08,450 --> 00:14:11,450
the client

00:14:09,080 --> 00:14:16,220
this is patch and if you thought this

00:14:11,450 --> 00:14:19,820
list is complete it is not version 1.6

00:14:16,220 --> 00:14:21,740
we see various improvements we get a new

00:14:19,820 --> 00:14:23,840
test runner that is able to the k test

00:14:21,740 --> 00:14:26,570
not only interested by models that work

00:14:23,840 --> 00:14:28,220
but anywhere from the installed apps as

00:14:26,570 --> 00:14:31,040
long as it matches specific file

00:14:28,220 --> 00:14:33,710
patterns the new test discovery also

00:14:31,040 --> 00:14:37,610
means that we have no more tests in

00:14:33,710 --> 00:14:40,490
models at pi array SUDEP apps are also

00:14:37,610 --> 00:14:44,870
removed now we can use real file system

00:14:40,490 --> 00:14:47,420
or dotted directory paths this also

00:14:44,870 --> 00:14:49,520
allows running tests that are not inside

00:14:47,420 --> 00:14:53,180
a Django out listed in installed apps

00:14:49,520 --> 00:14:57,740
and finally doc test won't be discovered

00:14:53,180 --> 00:15:01,100
anymore and we say farewell to them 1.7

00:14:57,740 --> 00:15:04,280
so free versions before 1.7 django

00:15:01,100 --> 00:15:06,800
introduced unit tests to unit tester is

00:15:04,280 --> 00:15:08,420
a backward of the unit test features

00:15:06,800 --> 00:15:10,190
that work with all the versions of

00:15:08,420 --> 00:15:13,340
vitamin because django at the time was

00:15:10,190 --> 00:15:16,970
supporting twice and 2.4 it was van

00:15:13,340 --> 00:15:19,040
during unit test to 1.7 django dropped

00:15:16,970 --> 00:15:21,140
support for older versions of Python and

00:15:19,040 --> 00:15:25,880
so it removes the unit test too and we

00:15:21,140 --> 00:15:27,589
can just use the regular unit test at

00:15:25,880 --> 00:15:30,350
first when the live server test case was

00:15:27,589 --> 00:15:33,170
introduced it was serving all the static

00:15:30,350 --> 00:15:36,440
files as if you were running your server

00:15:33,170 --> 00:15:36,980
with debug equals true from this point

00:15:36,440 --> 00:15:39,490
on

00:15:36,980 --> 00:15:43,100
why server test case will serve only

00:15:39,490 --> 00:15:44,960
files from the static route trying to

00:15:43,100 --> 00:15:46,760
simulate the real production environment

00:15:44,960 --> 00:15:49,209
as close as possible if you want to

00:15:46,760 --> 00:15:53,199
serve all of the static files then you

00:15:49,209 --> 00:15:57,309
use the static live server test case in

00:15:53,199 --> 00:16:00,040
1.8 we get the last known HTTP method to

00:15:57,309 --> 00:16:04,110
the test client can you tell me which

00:16:00,040 --> 00:16:04,110
one is that which one are missing

00:16:05,220 --> 00:16:11,439
they should be sparks someone okay okay

00:16:08,019 --> 00:16:15,369
this is trace this is the last one and

00:16:11,439 --> 00:16:18,999
once this one was defined the client is

00:16:15,369 --> 00:16:21,850
complete test case and it's Berger

00:16:18,999 --> 00:16:25,509
strategy was a performance Boston and

00:16:21,850 --> 00:16:27,579
around version 1.8 a few other intricate

00:16:25,509 --> 00:16:31,600
changes were introduced that made the

00:16:27,579 --> 00:16:34,179
test case even better before that think

00:16:31,600 --> 00:16:36,819
version 1.7 what test case did is wrap

00:16:34,179 --> 00:16:38,499
each test into your transaction but it

00:16:36,819 --> 00:16:40,839
did it in the following way you will

00:16:38,499 --> 00:16:43,509
enter the atomic block and you would

00:16:40,839 --> 00:16:45,759
load the fixtures you'd run the test you

00:16:43,509 --> 00:16:47,679
would exit the atomic in other words

00:16:45,759 --> 00:16:49,209
rollback and then you would close all of

00:16:47,679 --> 00:16:52,089
your database connections and you would

00:16:49,209 --> 00:16:57,240
repeat that for every single test that

00:16:52,089 --> 00:17:00,459
you have with the arrival of Django 1.8

00:16:57,240 --> 00:17:03,670
we can do something better so we

00:17:00,459 --> 00:17:06,039
actually wrap all of our tests from a

00:17:03,670 --> 00:17:08,890
test case inside of a different atomic

00:17:06,039 --> 00:17:12,189
block that is going to happen only once

00:17:08,890 --> 00:17:13,750
and what we are doing we are loading the

00:17:12,189 --> 00:17:16,659
fixtures and we are closing the

00:17:13,750 --> 00:17:20,459
connections a single time rather than

00:17:16,659 --> 00:17:23,559
doing it for every other test so now

00:17:20,459 --> 00:17:28,000
every other every test by then also runs

00:17:23,559 --> 00:17:30,700
within its own transaction block but we

00:17:28,000 --> 00:17:32,679
get also the benefit of closing the

00:17:30,700 --> 00:17:34,809
connections and loading our fixtures a

00:17:32,679 --> 00:17:42,250
single time rather than doing it every

00:17:34,809 --> 00:17:44,620
time 1.9 whoever works or worked on a

00:17:42,250 --> 00:17:47,740
large project knows the pain of waiting

00:17:44,620 --> 00:17:50,289
for tests to finish from my experience

00:17:47,740 --> 00:17:52,450
that would take the pain starts with

00:17:50,289 --> 00:17:54,370
about 20 minutes sometimes it's 48

00:17:52,450 --> 00:17:58,120
depends how large it is

00:17:54,370 --> 00:18:01,000
um and most of us know that the quick

00:17:58,120 --> 00:18:03,820
easy win for that is to paralyze our

00:18:01,000 --> 00:18:05,620
tests and also that's the time when you

00:18:03,820 --> 00:18:09,100
find out how many non pure tests you

00:18:05,620 --> 00:18:11,620
have djenka 1.9 comes with a built-in

00:18:09,100 --> 00:18:14,260
support for parallelizing tests using

00:18:11,620 --> 00:18:16,890
Python multi processing module in fact

00:18:14,260 --> 00:18:20,830
Django's test suit is also parallelized

00:18:16,890 --> 00:18:22,900
how does it work the test Runner spawns

00:18:20,830 --> 00:18:24,790
a number of workers so if you don't

00:18:22,900 --> 00:18:29,190
specify how many will pick up the max

00:18:24,790 --> 00:18:34,570
number of holes that you have for each

00:18:29,190 --> 00:18:37,090
process we'll get an instant its own

00:18:34,570 --> 00:18:39,400
database so each each worker gets its

00:18:37,090 --> 00:18:41,700
own database therefore if you have four

00:18:39,400 --> 00:18:45,520
workers you're gonna get four databases

00:18:41,700 --> 00:18:48,870
test discovery builds a test suit which

00:18:45,520 --> 00:18:52,720
is partitioned into chunks of test case

00:18:48,870 --> 00:18:55,510
subclasses workers pick up those

00:18:52,720 --> 00:18:57,280
substitutes of chess and run them once

00:18:55,510 --> 00:18:58,809
they're finished they pick up the next

00:18:57,280 --> 00:19:00,309
one and they're finished and they pick

00:18:58,809 --> 00:19:05,830
up the next one until they're done and

00:19:00,309 --> 00:19:09,700
they return the result if you stuck with

00:19:05,830 --> 00:19:13,059
a version of Jango prior to 1.9 then you

00:19:09,700 --> 00:19:14,950
can use knows multi-process plug-in it's

00:19:13,059 --> 00:19:16,450
also using Python multi processing

00:19:14,950 --> 00:19:19,960
module but the main difference between

00:19:16,450 --> 00:19:21,910
the Jango ones and the knows multi

00:19:19,960 --> 00:19:25,540
process is that you get only one

00:19:21,910 --> 00:19:27,130
database so you get a shared state and

00:19:25,540 --> 00:19:35,170
because of that you sometimes can get

00:19:27,130 --> 00:19:36,700
bizarre failures and errors 1.10 my

00:19:35,170 --> 00:19:40,210
favorite feature that was introduced in

00:19:36,700 --> 00:19:43,210
1.10 is tanks you can tag your tests

00:19:40,210 --> 00:19:46,480
creating buckets or certain types of

00:19:43,210 --> 00:19:49,000
tests that you'd like to run together or

00:19:46,480 --> 00:19:52,840
you would like to exclude from your test

00:19:49,000 --> 00:19:55,510
run similar feature is implemented by

00:19:52,840 --> 00:19:58,179
other test runners like nose and eye

00:19:55,510 --> 00:20:00,700
tests if you're not in Django 1.10 you

00:19:58,179 --> 00:20:02,560
always have the option to use nose a

00:20:00,700 --> 00:20:03,770
tree plug-in or the whitest custom

00:20:02,560 --> 00:20:09,240
markers

00:20:03,770 --> 00:20:11,940
and finally 1.11 we get all sorts of

00:20:09,240 --> 00:20:15,660
speed ups and improvements in fact with

00:20:11,940 --> 00:20:18,990
every version we continuously try to get

00:20:15,660 --> 00:20:21,420
better in in different areas of the

00:20:18,990 --> 00:20:23,130
testing framework but there's one

00:20:21,420 --> 00:20:26,160
feature that caught my eye which i think

00:20:23,130 --> 00:20:29,550
is nice to know about so starting with

00:20:26,160 --> 00:20:32,820
bison 3.4 unit test module adds a

00:20:29,550 --> 00:20:35,760
context manager called sub test it says

00:20:32,820 --> 00:20:39,210
a sub test executes the enclosed block

00:20:35,760 --> 00:20:43,200
as a sub test in this example what

00:20:39,210 --> 00:20:45,690
happens is that the test won't exit on

00:20:43,200 --> 00:20:48,900
its first failure when I equals 1

00:20:45,690 --> 00:20:51,360
because 1 is an odd number it will

00:20:48,900 --> 00:20:55,680
actually run through all of the options

00:20:51,360 --> 00:20:58,710
and it will and it will return all of

00:20:55,680 --> 00:21:02,910
the results for all of the values of the

00:20:58,710 --> 00:21:04,650
I so now with Django 1.11 you can do

00:21:02,910 --> 00:21:06,780
that you can write your sub test when

00:21:04,650 --> 00:21:08,990
running tests in parallel and Django

00:21:06,780 --> 00:21:11,610
will report all of the results correctly

00:21:08,990 --> 00:21:13,470
if you're with white ass you probably

00:21:11,610 --> 00:21:20,220
this probably looks familiar to you

00:21:13,470 --> 00:21:22,410
because white us has parameters we went

00:21:20,220 --> 00:21:25,080
through the history of the Django test

00:21:22,410 --> 00:21:28,980
framework and we've touched on different

00:21:25,080 --> 00:21:31,590
topics here and there but let's see the

00:21:28,980 --> 00:21:34,350
flow of running a test suit as a whole

00:21:31,590 --> 00:21:37,080
or what happens when you run manage that

00:21:34,350 --> 00:21:39,570
by tests so let's fill up the test bad

00:21:37,080 --> 00:21:41,430
into multiple pieces and analyze each

00:21:39,570 --> 00:21:44,550
one of them and see what happens under

00:21:41,430 --> 00:21:48,470
the hood we woke the management command

00:21:44,550 --> 00:21:48,470
test and if we zoom in

00:21:52,000 --> 00:21:57,200
came back and if we zoom in there's

00:21:55,490 --> 00:21:59,830
pretty much a straightforward invocation

00:21:57,200 --> 00:22:03,200
so we're getting the test runner and

00:21:59,830 --> 00:22:05,630
we're creating an instance of it passing

00:22:03,200 --> 00:22:11,390
a bunch of options and we run the test

00:22:05,630 --> 00:22:13,820
let's zoom in inside run tests so the

00:22:11,390 --> 00:22:14,780
first line in run test is setting up the

00:22:13,820 --> 00:22:16,460
testing environment

00:22:14,780 --> 00:22:20,090
that'll do a bunch of things so the main

00:22:16,460 --> 00:22:23,390
free key point of this method is setting

00:22:20,090 --> 00:22:25,850
up the lock mam email back-end so that

00:22:23,390 --> 00:22:29,360
all the email that we're sending during

00:22:25,850 --> 00:22:32,510
tests is stored in to establish that we

00:22:29,360 --> 00:22:35,929
can inspect and we can access it easily

00:22:32,510 --> 00:22:40,549
this is a very reduced email backend in

00:22:35,929 --> 00:22:44,990
its functionality we also get the Django

00:22:40,549 --> 00:22:48,290
the Django test renderer is replaced by

00:22:44,990 --> 00:22:52,340
an instrumented test render it sends

00:22:48,290 --> 00:22:54,290
signals to let others know about various

00:22:52,340 --> 00:22:56,870
events that happened during rendering

00:22:54,290 --> 00:23:00,020
and finally we deactivate translation so

00:22:56,870 --> 00:23:01,460
that during tests your project will the

00:23:00,020 --> 00:23:05,000
test will respect your project set

00:23:01,460 --> 00:23:06,650
language the next step after setting up

00:23:05,000 --> 00:23:08,870
the test environment is to build the

00:23:06,650 --> 00:23:11,120
suit of tests the heavy load of building

00:23:08,870 --> 00:23:15,190
this suit is done by the Python unit

00:23:11,120 --> 00:23:18,620
test library but Django extends it

00:23:15,190 --> 00:23:21,049
because it allows you to specify tags a

00:23:18,620 --> 00:23:23,809
number of Kools and debug mode and all

00:23:21,049 --> 00:23:26,390
the different things so it builds up a

00:23:23,809 --> 00:23:28,760
suit of tests this is an aggregation of

00:23:26,390 --> 00:23:31,820
instances of test case classes all

00:23:28,760 --> 00:23:35,929
collected in a single place and there's

00:23:31,820 --> 00:23:38,799
nothing more than that the next step we

00:23:35,929 --> 00:23:41,480
set up the databases we run the checks

00:23:38,799 --> 00:23:43,340
then we run the tests which is by the

00:23:41,480 --> 00:23:46,210
way completely delegated to the unit

00:23:43,340 --> 00:23:49,450
test text test runner

00:23:46,210 --> 00:23:54,399
and for the cleanup we tear down the

00:23:49,450 --> 00:23:55,840
databases afterwards we need to tear

00:23:54,399 --> 00:23:57,999
down the testing environment this is

00:23:55,840 --> 00:23:59,950
pretty much the reversed order of what

00:23:57,999 --> 00:24:02,110
we did in the setup test environment so

00:23:59,950 --> 00:24:04,809
we need to bring back the original email

00:24:02,110 --> 00:24:07,029
back and the original test renderer and

00:24:04,809 --> 00:24:10,539
finally we delete the state and the

00:24:07,029 --> 00:24:14,110
mailbox last step we return the results

00:24:10,539 --> 00:24:17,950
of the testitude by combining the number

00:24:14,110 --> 00:24:19,539
of total failures and errors and this

00:24:17,950 --> 00:24:23,740
line should probably look familiar to

00:24:19,539 --> 00:24:27,340
you at this point a quick recap on the

00:24:23,740 --> 00:24:29,830
different test classes and how they

00:24:27,340 --> 00:24:33,039
relate to each other so this is the

00:24:29,830 --> 00:24:35,289
hierarchy and the simple test case is at

00:24:33,039 --> 00:24:37,779
the very top so close by the transaction

00:24:35,289 --> 00:24:39,519
test case which is subclass by the test

00:24:37,779 --> 00:24:42,669
case and loyal servitors case finally

00:24:39,519 --> 00:24:44,110
specialized version of life-saving test

00:24:42,669 --> 00:24:46,240
case which is the static light server

00:24:44,110 --> 00:24:51,789
test case I've been saying test so many

00:24:46,240 --> 00:24:53,590
times simple test case is very very fast

00:24:51,789 --> 00:24:55,840
because it doesn't interact with the

00:24:53,590 --> 00:24:57,129
database you can't you can't query you

00:24:55,840 --> 00:24:59,830
can't say it can't do any of those

00:24:57,129 --> 00:25:02,980
things it has access to the test client

00:24:59,830 --> 00:25:05,169
though so think of it as a slightly more

00:25:02,980 --> 00:25:08,169
advanced version of the usual poison

00:25:05,169 --> 00:25:11,049
unit test test case transaction test

00:25:08,169 --> 00:25:14,799
case is not fast at all but it allows

00:25:11,049 --> 00:25:16,659
database queries and transactions test

00:25:14,799 --> 00:25:18,610
case is faster than the transaction test

00:25:16,659 --> 00:25:21,129
case but not as fast as a simple test

00:25:18,610 --> 00:25:24,179
case it will allow you to do database

00:25:21,129 --> 00:25:27,340
queries but will restrict transactions

00:25:24,179 --> 00:25:29,830
like server test case will act as a

00:25:27,340 --> 00:25:32,259
transaction test case and it will launch

00:25:29,830 --> 00:25:34,720
a live HTTP server in a separate thread

00:25:32,259 --> 00:25:38,039
from the thread that's running the tests

00:25:34,720 --> 00:25:40,899
and finally the Saticoy service is the

00:25:38,039 --> 00:25:43,899
specialization that in addition to

00:25:40,899 --> 00:25:47,879
everything else will serve all static

00:25:43,899 --> 00:25:51,840
files client is a very handy utility

00:25:47,879 --> 00:25:55,749
when you're testing your Django apps and

00:25:51,840 --> 00:25:57,389
the free poor actors involved in browser

00:25:55,749 --> 00:25:59,969
mimicking are the

00:25:57,389 --> 00:26:01,919
requestfactory Klein handler and the

00:25:59,969 --> 00:26:05,479
client we've talked about the request

00:26:01,919 --> 00:26:10,739
factory being the most straightforward

00:26:05,479 --> 00:26:14,129
actor it constructs requests and it

00:26:10,739 --> 00:26:16,950
encodes data client on the other hand

00:26:14,129 --> 00:26:19,440
performs more actions first off the

00:26:16,950 --> 00:26:21,599
client is stateful so it retains cookies

00:26:19,440 --> 00:26:24,959
and hands sessions for the duration of

00:26:21,599 --> 00:26:30,149
the test client it also does a few other

00:26:24,959 --> 00:26:33,179
things to the response so we talked

00:26:30,149 --> 00:26:36,859
about the instrumented test render well

00:26:33,179 --> 00:26:39,839
the client is listening to those events

00:26:36,859 --> 00:26:42,359
events like template rendered and a

00:26:39,839 --> 00:26:44,279
request exception and that's why it is

00:26:42,359 --> 00:26:46,139
able to list all of the templates and

00:26:44,279 --> 00:26:50,219
template contacts that was used to

00:26:46,139 --> 00:26:52,139
render your response it also sets a

00:26:50,219 --> 00:26:55,499
couple of other things on the response

00:26:52,139 --> 00:26:59,759
for example the original request the

00:26:55,499 --> 00:27:01,829
client object Jason resolved a match it

00:26:59,759 --> 00:27:05,519
can also handle redirects and build a

00:27:01,829 --> 00:27:08,309
redirect chain that we can inspect main

00:27:05,519 --> 00:27:11,249
goal of the client handler is to return

00:27:08,309 --> 00:27:14,489
a Django HTTP response with the whiskey

00:27:11,249 --> 00:27:16,169
request attached to it it will load all

00:27:14,489 --> 00:27:18,690
the middleware that you've said in new

00:27:16,169 --> 00:27:21,359
settings it will disable the co set of

00:27:18,690 --> 00:27:24,570
checks which can be enabled back if you

00:27:21,359 --> 00:27:29,209
want to and it tries to emulate as close

00:27:24,570 --> 00:27:29,209
as possible server and browser behavior

00:27:29,479 --> 00:27:35,190
we've talked about all the different

00:27:31,799 --> 00:27:37,589
tools that django provides for testing

00:27:35,190 --> 00:27:41,369
but how do we achieve quality in our

00:27:37,589 --> 00:27:44,940
tests how do we how do we make sure that

00:27:41,369 --> 00:27:48,239
the tests we write are reliable future

00:27:44,940 --> 00:27:50,539
proof and fast enough reasoning about

00:27:48,239 --> 00:27:53,700
quality is not easy

00:27:50,539 --> 00:27:56,759
besides our intuitive human

00:27:53,700 --> 00:27:59,849
understanding of what quality is there

00:27:56,759 --> 00:28:01,309
are some tools that can help us and

00:27:59,849 --> 00:28:04,120
let's start with something simple

00:28:01,309 --> 00:28:07,630
introduced Factory boy to your tests

00:28:04,120 --> 00:28:09,400
lots of people like it because because

00:28:07,630 --> 00:28:12,909
it has their shortcut methods for

00:28:09,400 --> 00:28:15,250
creating models it generates random yet

00:28:12,909 --> 00:28:16,990
realistic data because it's based on a

00:28:15,250 --> 00:28:20,380
different library called faker and

00:28:16,990 --> 00:28:23,890
fakers providers that based on certain

00:28:20,380 --> 00:28:28,710
rules create this random yet realistic

00:28:23,890 --> 00:28:32,320
data the important part though is that

00:28:28,710 --> 00:28:33,909
every time you run your tests you'll get

00:28:32,320 --> 00:28:35,830
different values compared to what you

00:28:33,909 --> 00:28:40,299
get with fixtures and there is a slim

00:28:35,830 --> 00:28:42,909
chance the factory boy might catch a bug

00:28:40,299 --> 00:28:43,750
for you if you're interested in this

00:28:42,909 --> 00:28:45,700
kind of stuff

00:28:43,750 --> 00:28:48,220
I'd suggest looking at the pythons

00:28:45,700 --> 00:28:51,039
hypothesis library it's doing property

00:28:48,220 --> 00:28:56,470
based testing and it takes the idea of

00:28:51,039 --> 00:28:58,179
random input to a whole new level so the

00:28:56,470 --> 00:28:59,919
idea of the property based testing came

00:28:58,179 --> 00:29:02,799
from a haskell library called quick

00:28:59,919 --> 00:29:06,370
check and hypothesis is the Python

00:29:02,799 --> 00:29:11,580
implementation you can use so the way

00:29:06,370 --> 00:29:14,710
you do it you use given decorator which

00:29:11,580 --> 00:29:18,039
can inject randomly generated data to

00:29:14,710 --> 00:29:20,110
your tests you specify what kind of

00:29:18,039 --> 00:29:22,690
strategies do you want so in this case

00:29:20,110 --> 00:29:25,200
we're using a strategy text which is

00:29:22,690 --> 00:29:29,110
very similar to the Factory boys

00:29:25,200 --> 00:29:31,630
providers and what it does

00:29:29,110 --> 00:29:37,929
once we decorate a function with the

00:29:31,630 --> 00:29:41,470
given function this test will run

00:29:37,929 --> 00:29:43,510
multiple times usually about 200 and it

00:29:41,470 --> 00:29:46,870
will test your function with all sorts

00:29:43,510 --> 00:29:51,240
of different edge edge cases that

00:29:46,870 --> 00:29:55,779
usually that often easily slip away from

00:29:51,240 --> 00:29:57,460
developers attention since Django is an

00:29:55,779 --> 00:29:59,980
established way of doing web development

00:29:57,460 --> 00:30:01,720
in the Python world hypothesis comes

00:29:59,980 --> 00:30:03,720
with an extra module with support for

00:30:01,720 --> 00:30:06,220
Django

00:30:03,720 --> 00:30:10,100
similar to Factory boy we can create

00:30:06,220 --> 00:30:13,309
modules populated with random data

00:30:10,100 --> 00:30:18,700
to be noted with the hypothesis we

00:30:13,309 --> 00:30:18,700
always save the created model examples

00:30:20,110 --> 00:30:24,740
so this is a real-world example of how

00:30:23,030 --> 00:30:27,470
hypotheses can be used for testing

00:30:24,740 --> 00:30:29,600
django apps if you look at the very top

00:30:27,470 --> 00:30:32,020
at the four inputs that we have there's

00:30:29,600 --> 00:30:35,299
one important import that is the most

00:30:32,020 --> 00:30:37,940
important and this says the test case

00:30:35,299 --> 00:30:39,710
we're using the hypothesis test case to

00:30:37,940 --> 00:30:41,419
be able to wrap each hypothesis test

00:30:39,710 --> 00:30:44,059
into its own transaction rather than

00:30:41,419 --> 00:30:45,919
running all 200 of them in one single

00:30:44,059 --> 00:30:50,360
transaction because then we'll get a

00:30:45,919 --> 00:30:52,610
mess so let's remove the imports and

00:30:50,360 --> 00:30:55,100
focus on the test this is a slightly

00:30:52,610 --> 00:30:59,630
stripped-down example that I borrowed

00:30:55,100 --> 00:31:02,090
from a presentation made a Django Locke

00:30:59,630 --> 00:31:05,000
local user group in London made by the

00:31:02,090 --> 00:31:06,620
author of hypothesis Dave so we are

00:31:05,000 --> 00:31:08,960
testing what we're testing here we're

00:31:06,620 --> 00:31:11,630
testing that if the project model

00:31:08,960 --> 00:31:13,520
instance can respect the limit of users

00:31:11,630 --> 00:31:15,890
a single project in half you can specify

00:31:13,520 --> 00:31:17,360
a collaboration limit on this project I

00:31:15,890 --> 00:31:22,100
just want to have three people and no

00:31:17,360 --> 00:31:24,230
more so what we are doing we are

00:31:22,100 --> 00:31:28,130
injecting one project model instance and

00:31:24,230 --> 00:31:33,049
a list of random amount of user models

00:31:28,130 --> 00:31:35,570
from 0 to 20 then we check if the

00:31:33,049 --> 00:31:38,570
project is at its collaborate limit and

00:31:35,570 --> 00:31:40,610
we try to add another user we expect an

00:31:38,570 --> 00:31:42,470
exception to be raised because we don't

00:31:40,610 --> 00:31:45,580
want to accept more users than we have

00:31:42,470 --> 00:31:48,740
in our collaboration limit otherwise

00:31:45,580 --> 00:31:52,190
adding a new user should work just fine

00:31:48,740 --> 00:31:54,409
and when you run the test if I if

00:31:52,190 --> 00:31:56,330
hypothesis encounters that the test

00:31:54,409 --> 00:31:58,960
didn't succeed with a set of randomly

00:31:56,330 --> 00:32:02,360
generated data it will tell you

00:31:58,960 --> 00:32:04,580
falsifying example so in this case we

00:32:02,360 --> 00:32:07,100
have a project with a limit with a

00:32:04,580 --> 00:32:10,100
collaboration limit of 1 and we've been

00:32:07,100 --> 00:32:12,080
able to add two users where the second

00:32:10,100 --> 00:32:15,110
one didn't trigger an exception which

00:32:12,080 --> 00:32:16,590
means there's something wrong you have a

00:32:15,110 --> 00:32:20,049
bug

00:32:16,590 --> 00:32:22,149
here's the catch with all of that just a

00:32:20,049 --> 00:32:25,539
best kept when there is simple and

00:32:22,149 --> 00:32:28,779
stupid and one should not have bugs in

00:32:25,539 --> 00:32:31,990
there tests with hypothesis tests can

00:32:28,779 --> 00:32:34,600
become more complex and you might even

00:32:31,990 --> 00:32:38,850
reach a point where you will need tests

00:32:34,600 --> 00:32:44,590
for your tests which has ridiculous

00:32:38,850 --> 00:32:47,200
so when using but when used properly and

00:32:44,590 --> 00:32:52,619
timely property based testing can be a

00:32:47,200 --> 00:32:55,119
very valuable tool so keep in mind that

00:32:52,619 --> 00:32:58,929
test code coverage is probably the most

00:32:55,119 --> 00:33:00,460
known and widely used metric it's about

00:32:58,929 --> 00:33:04,210
a week ago I checked

00:33:00,460 --> 00:33:08,320
Django's test code coverage I ran it

00:33:04,210 --> 00:33:09,730
against sequel I'd and I got 75% but

00:33:08,320 --> 00:33:12,220
here's the thing test coverage is

00:33:09,730 --> 00:33:14,590
generally a deceptive metric if you have

00:33:12,220 --> 00:33:15,940
load code code coverage then yes you

00:33:14,590 --> 00:33:18,100
definitely need more tests you're

00:33:15,940 --> 00:33:20,379
probably not testing your code properly

00:33:18,100 --> 00:33:22,539
but if you have high code coverage well

00:33:20,379 --> 00:33:24,249
highly bet your tests are very good but

00:33:22,539 --> 00:33:26,289
maybe you just kind of wrote them in a

00:33:24,249 --> 00:33:28,299
way that you hit all of the lines of

00:33:26,289 --> 00:33:33,100
your code but you didn't through roughly

00:33:28,299 --> 00:33:35,019
tested it so unfortunately from in my

00:33:33,100 --> 00:33:37,860
opinion high code coverage doesn't

00:33:35,019 --> 00:33:40,299
necessarily imply high quality of tests

00:33:37,860 --> 00:33:42,279
we can do better we can do better with

00:33:40,299 --> 00:33:44,950
mutation testing rotation testing is a

00:33:42,279 --> 00:33:48,429
concept that was introduced in the 70s

00:33:44,950 --> 00:33:51,460
and it involves changing the code of a

00:33:48,429 --> 00:33:54,249
program in some small ways like little

00:33:51,460 --> 00:33:56,799
twigs and observing what happens when we

00:33:54,249 --> 00:33:58,960
run the test on this modified version of

00:33:56,799 --> 00:34:01,600
the code and this is a very powerful

00:33:58,960 --> 00:34:04,960
idea I thought it's it's so simple and

00:34:01,600 --> 00:34:06,399
yet so brilliant in Python mutation

00:34:04,960 --> 00:34:09,579
testing is implemented by a package

00:34:06,399 --> 00:34:13,179
called multiply and multiply operates on

00:34:09,579 --> 00:34:14,079
the Python ast to implement mutations so

00:34:13,179 --> 00:34:17,859
how does it work

00:34:14,079 --> 00:34:19,179
you involve mutation multiply from the

00:34:17,859 --> 00:34:21,879
comment line and you need to specify

00:34:19,179 --> 00:34:22,720
your target and your unit test the unit

00:34:21,879 --> 00:34:28,389
test obviously

00:34:22,720 --> 00:34:30,580
need to test your target code so if your

00:34:28,389 --> 00:34:32,830
target source source code has an if

00:34:30,580 --> 00:34:35,349
statement and the if statement has a

00:34:32,830 --> 00:34:39,820
logical operand and so you're saying if

00:34:35,349 --> 00:34:42,490
foo and bar then do this Matt Bai takes

00:34:39,820 --> 00:34:43,540
this logical operand and and invert set

00:34:42,490 --> 00:34:47,020
in turn all

00:34:43,540 --> 00:34:49,570
so our target code becomes a slightly

00:34:47,020 --> 00:34:53,320
modified version of the original and we

00:34:49,570 --> 00:34:56,320
call it a mutant now what we do we run

00:34:53,320 --> 00:34:59,680
the test on the mutant if the test

00:34:56,320 --> 00:35:01,660
failed on the mutant this is good we say

00:34:59,680 --> 00:35:04,510
that the mutant was killed by our test

00:35:01,660 --> 00:35:08,140
which adds points to our final mutation

00:35:04,510 --> 00:35:13,480
score but if the mutant survived when

00:35:08,140 --> 00:35:15,550
our test isn't good enough it means that

00:35:13,480 --> 00:35:19,840
it doesn't really matter if we're using

00:35:15,550 --> 00:35:22,180
and or or the test passed anyway we must

00:35:19,840 --> 00:35:25,000
we're probably not testing what we

00:35:22,180 --> 00:35:26,680
should be testing and what I can do a

00:35:25,000 --> 00:35:29,500
lot more there's a fairly long list of

00:35:26,680 --> 00:35:31,450
mutants it can replace arithmetic

00:35:29,500 --> 00:35:35,940
operands break continue statements

00:35:31,450 --> 00:35:38,920
conditional operands constants logical

00:35:35,940 --> 00:35:41,050
operators and it can delete it can even

00:35:38,920 --> 00:35:45,670
delete whole conditional branches and

00:35:41,050 --> 00:35:48,700
decorators and do a lot more this is

00:35:45,670 --> 00:35:50,859
what a stripped down example of a test

00:35:48,700 --> 00:35:53,470
run looks like you get a mutation score

00:35:50,859 --> 00:35:56,230
which is a percentage in this case 32.1

00:35:53,470 --> 00:35:58,720
and it also tells you the total amount

00:35:56,230 --> 00:36:00,190
of mutant that it generated the number

00:35:58,720 --> 00:36:04,990
of mutants that were killed survived

00:36:00,190 --> 00:36:06,700
incompetent and timed out and I took I

00:36:04,990 --> 00:36:08,560
took this tool and I started playing

00:36:06,700 --> 00:36:12,460
with the Jango test and see what results

00:36:08,560 --> 00:36:14,109
I can get so one Pleasant trend is the

00:36:12,460 --> 00:36:16,240
correlation of the high code coverage

00:36:14,109 --> 00:36:19,270
with a high mutation score for example

00:36:16,240 --> 00:36:22,390
Jango duration utils has a mutation

00:36:19,270 --> 00:36:26,890
score of 89 and it's mutation score is

00:36:22,390 --> 00:36:28,990
100% this looks really nice this doesn't

00:36:26,890 --> 00:36:32,109
always hold true for example Jango

00:36:28,990 --> 00:36:34,190
encoding you tails mutation score is 64

00:36:32,109 --> 00:36:40,940
percent while the

00:36:34,190 --> 00:36:43,880
code coverage is 100% so you can see

00:36:40,940 --> 00:36:47,240
that mutation score can actually give

00:36:43,880 --> 00:36:52,040
you better insight into what how good

00:36:47,240 --> 00:36:55,010
your tests are Jango tutorial is

00:36:52,040 --> 00:36:57,460
excellent beginners don't need to search

00:36:55,010 --> 00:37:00,560
the internet for any video tutorials

00:36:57,460 --> 00:37:02,630
courses because if you go to the Jango

00:37:00,560 --> 00:37:04,790
official web page you get the Jango

00:37:02,630 --> 00:37:06,800
official tutorial and a whole section of

00:37:04,790 --> 00:37:08,600
it is dedicated to testing because

00:37:06,800 --> 00:37:13,070
testing in the Jango world is an

00:37:08,600 --> 00:37:15,440
integral part of developing an app in my

00:37:13,070 --> 00:37:17,690
second year at university I discovered

00:37:15,440 --> 00:37:20,600
Jango it's also the first time that I

00:37:17,690 --> 00:37:22,310
wrote a test it was a very silly one I

00:37:20,600 --> 00:37:26,330
was just making a request though URL and

00:37:22,310 --> 00:37:28,310
expecting a 200 response you know but

00:37:26,330 --> 00:37:31,280
you know why why I wrote this test is

00:37:28,310 --> 00:37:34,400
because when I follow the tutorial and I

00:37:31,280 --> 00:37:38,060
created my Jango app I also got this

00:37:34,400 --> 00:37:40,820
file test at PI and that caught my

00:37:38,060 --> 00:37:42,620
attention the tutorial explained exactly

00:37:40,820 --> 00:37:45,320
what I need to do to get started with

00:37:42,620 --> 00:37:48,320
testing my code so a testing framework

00:37:45,320 --> 00:37:50,960
is a powerful tool to motivate people to

00:37:48,320 --> 00:37:54,440
write tests and especially especially

00:37:50,960 --> 00:37:57,140
beginners Jango testing tutorial

00:37:54,440 --> 00:38:00,140
contains a section named when testing

00:37:57,140 --> 00:38:01,400
more is better it says that yes soon

00:38:00,140 --> 00:38:03,230
enough you're gonna feel like your

00:38:01,400 --> 00:38:06,260
project is spinning out of control

00:38:03,230 --> 00:38:09,020
because it grew so big and you have so

00:38:06,260 --> 00:38:10,880
many tests but you know just let it spin

00:38:09,020 --> 00:38:13,790
out of control it's fine let them grow

00:38:10,880 --> 00:38:16,460
when testing who is better there's a

00:38:13,790 --> 00:38:19,010
trap in there when with the number of

00:38:16,460 --> 00:38:23,090
tests growing your total test run time

00:38:19,010 --> 00:38:25,430
becomes slower and Jango gives you all

00:38:23,090 --> 00:38:28,100
of the tools and encourages you to write

00:38:25,430 --> 00:38:30,200
very high level sort of functional style

00:38:28,100 --> 00:38:33,190
tests so the speed of your tests can

00:38:30,200 --> 00:38:35,840
suffer and this has other implications

00:38:33,190 --> 00:38:37,730
with slow tests you get a slow feedback

00:38:35,840 --> 00:38:39,710
loop with a slow feedback loop you get a

00:38:37,730 --> 00:38:42,140
slow development cycle

00:38:39,710 --> 00:38:44,500
sometimes if tests are so slow people

00:38:42,140 --> 00:38:47,089
just stop running them

00:38:44,500 --> 00:38:50,599
and that's why here are seven tips on

00:38:47,089 --> 00:38:53,359
how to make your test not be slower than

00:38:50,599 --> 00:39:02,960
they actually need to be and number four

00:38:53,359 --> 00:39:05,119
will show you number one use the first

00:39:02,960 --> 00:39:07,520
and last secure password hash during

00:39:05,119 --> 00:39:12,560
your test like md5 this is what Django

00:39:07,520 --> 00:39:14,570
does for its own test abuse simple test

00:39:12,560 --> 00:39:16,700
case when possible if you don't need the

00:39:14,570 --> 00:39:19,570
database if you're just writing simple

00:39:16,700 --> 00:39:22,609
tests use simple test cases brilliant

00:39:19,570 --> 00:39:24,470
use setup test data if you don't plan to

00:39:22,609 --> 00:39:25,310
mutate any of the objects that you

00:39:24,470 --> 00:39:26,990
create in it

00:39:25,310 --> 00:39:31,640
because it's going to be called just

00:39:26,990 --> 00:39:35,180
once and here's the shocking bullet

00:39:31,640 --> 00:39:40,900
point number four use mocks everywhere

00:39:35,180 --> 00:39:43,460
and I'm joking I'm not serious just

00:39:40,900 --> 00:39:46,339
trying to emphasize that yes this is a

00:39:43,460 --> 00:39:49,700
joke there's nothing he Haran T bad with

00:39:46,339 --> 00:39:51,680
mocks in themselves mocks are really

00:39:49,700 --> 00:39:54,500
good tool that you need to know how to

00:39:51,680 --> 00:39:56,810
use but if you're using mocks for with

00:39:54,500 --> 00:39:58,369
the intention of speed ups then there's

00:39:56,810 --> 00:40:01,220
probably something wrong in your app

00:39:58,369 --> 00:40:03,020
design and not in your tests MOOCs are

00:40:01,220 --> 00:40:07,250
really good for isolations so use them

00:40:03,020 --> 00:40:11,050
for isolation be very careful what gets

00:40:07,250 --> 00:40:13,819
created in the setup method

00:40:11,050 --> 00:40:17,329
don't save model objects if it's not

00:40:13,819 --> 00:40:19,369
necessary and try to isolate your unit

00:40:17,329 --> 00:40:23,079
test from the rest of the test from the

00:40:19,369 --> 00:40:25,280
rest of your tests and I would like to

00:40:23,079 --> 00:40:29,630
talk a bit more about the last three

00:40:25,280 --> 00:40:32,359
points so last year I learned that this

00:40:29,630 --> 00:40:35,210
is called the tight loop so a tight loop

00:40:32,359 --> 00:40:39,440
like this where we create some model

00:40:35,210 --> 00:40:43,599
instances are red flags that need to be

00:40:39,440 --> 00:40:43,599
identified removed or reduced

00:40:44,810 --> 00:40:49,770
instead of doing create how we did in

00:40:47,520 --> 00:40:52,710
the previous example well we can do we

00:40:49,770 --> 00:40:58,050
can create an emery model just like this

00:40:52,710 --> 00:41:01,260
just like this similarly an in-memory

00:40:58,050 --> 00:41:04,080
model can be created using factory-built

00:41:01,260 --> 00:41:05,910
method or you can create a stub object

00:41:04,080 --> 00:41:07,950
which is just a couple of attributes

00:41:05,910 --> 00:41:11,460
using the stub method the last two are

00:41:07,950 --> 00:41:13,890
taking from the factory boy the caveat

00:41:11,460 --> 00:41:15,870
here is that you can't always do that

00:41:13,890 --> 00:41:18,480
for example when you have a many-to-many

00:41:15,870 --> 00:41:22,020
relationship you just have to save the

00:41:18,480 --> 00:41:24,150
model and finally isolate unit tests

00:41:22,020 --> 00:41:26,100
from the rest of your tests your

00:41:24,150 --> 00:41:30,510
testitude may look like this it's a mix

00:41:26,100 --> 00:41:33,510
of unity unit ish like test functional

00:41:30,510 --> 00:41:36,420
integration tests and but it would have

00:41:33,510 --> 00:41:39,060
been a lot more useful and would allow

00:41:36,420 --> 00:41:40,950
creating a faster feedback loop if we

00:41:39,060 --> 00:41:43,170
separate unit tests from the rest

00:41:40,950 --> 00:41:44,790
because you can run unit tests all the

00:41:43,170 --> 00:41:46,770
time you can even run them in a watch

00:41:44,790 --> 00:41:48,600
mode they're really fast they're gonna

00:41:46,770 --> 00:41:50,550
give you they're going to give you the

00:41:48,600 --> 00:41:54,600
results instantly and then you can run

00:41:50,550 --> 00:41:56,700
all the rest of the tests less often one

00:41:54,600 --> 00:41:58,620
way to do it is to use simple test case

00:41:56,700 --> 00:42:03,090
classes for unit tests and tag them with

00:41:58,620 --> 00:42:04,890
a special label if you're in Jango 1.10

00:42:03,090 --> 00:42:07,230
if you are stuck with an older version

00:42:04,890 --> 00:42:10,050
you can separate them in a different

00:42:07,230 --> 00:42:11,930
folder so that you can run them in total

00:42:10,050 --> 00:42:14,640
isolation from the rest of the tests

00:42:11,930 --> 00:42:18,150
even better you can make them simple

00:42:14,640 --> 00:42:21,600
unit tests or PI tests which have no

00:42:18,150 --> 00:42:24,860
idea of what Jango is and write more of

00:42:21,600 --> 00:42:27,360
them but don't neglect functional and

00:42:24,860 --> 00:42:31,020
integration tests because obviously they

00:42:27,360 --> 00:42:33,510
are the one that validate the contracts

00:42:31,020 --> 00:42:38,550
between your units so you definitely

00:42:33,510 --> 00:42:40,920
should have both so your friend runs a

00:42:38,550 --> 00:42:43,620
little bakery business and they sell

00:42:40,920 --> 00:42:47,040
freshly baked bread and other similar

00:42:43,620 --> 00:42:50,250
nibbles they hire you to help them build

00:42:47,040 --> 00:42:52,110
an internal app for them what the app

00:42:50,250 --> 00:42:55,380
needs to do is to help them figure out

00:42:52,110 --> 00:42:55,910
what should be the correct v80 value for

00:42:55,380 --> 00:42:57,740
their

00:42:55,910 --> 00:43:02,150
and this will save some time for their

00:42:57,740 --> 00:43:05,630
account because taxes so we started with

00:43:02,150 --> 00:43:07,309
a basic naive schema where we get the

00:43:05,630 --> 00:43:08,930
product model and the product

00:43:07,309 --> 00:43:10,670
questionnaire model where they want one

00:43:08,930 --> 00:43:12,980
relationship between them the product

00:43:10,670 --> 00:43:15,440
questionnaire is the key to our the

00:43:12,980 --> 00:43:18,440
unity decision-making it's a little

00:43:15,440 --> 00:43:20,869
add-on where we define basic yes-or-no

00:43:18,440 --> 00:43:23,660
questions and we build a decision tree

00:43:20,869 --> 00:43:27,109
to eventually land on a defined answer

00:43:23,660 --> 00:43:31,849
as this product 0 rated VT or is it a

00:43:27,109 --> 00:43:33,710
standard rated V 18 will need a view and

00:43:31,849 --> 00:43:37,119
will need a model for the view will

00:43:33,710 --> 00:43:40,069
display the questionnaire and answers

00:43:37,119 --> 00:43:42,289
will be saved on the product model for

00:43:40,069 --> 00:43:44,450
on the product questionnaire model for

00:43:42,289 --> 00:43:47,359
possible future recalculations

00:43:44,450 --> 00:43:49,519
in the same view will converge to a

00:43:47,359 --> 00:43:51,589
final decision and save it to the

00:43:49,519 --> 00:43:53,509
product with the known VI T value is

00:43:51,589 --> 00:43:56,750
going to be really easy to compute the

00:43:53,509 --> 00:43:58,579
final price of the product so I'll be

00:43:56,750 --> 00:44:00,980
showing the example code for different

00:43:58,579 --> 00:44:03,769
approaches on how to solve this problem

00:44:00,980 --> 00:44:05,869
where the very top we can have the

00:44:03,769 --> 00:44:09,920
production code and at the bottom is

00:44:05,869 --> 00:44:13,849
going to be the test code solution

00:44:09,920 --> 00:44:15,799
number one in a view once we know that

00:44:13,849 --> 00:44:18,769
the form is valid we check if the

00:44:15,799 --> 00:44:21,079
product is a biscuit and is it coated in

00:44:18,769 --> 00:44:24,740
chocolate so in that case we're going to

00:44:21,079 --> 00:44:28,220
set the VT to 20% this is a closed base

00:44:24,740 --> 00:44:30,769
view because of its brevity if you have

00:44:28,220 --> 00:44:32,450
an allergy towards class-based views you

00:44:30,769 --> 00:44:35,690
can just translate it in your mind into

00:44:32,450 --> 00:44:37,670
a function based view as for the test

00:44:35,690 --> 00:44:40,579
what we are doing we are creating a

00:44:37,670 --> 00:44:43,579
product object we are making a request

00:44:40,579 --> 00:44:44,930
by pass passing some data and then we

00:44:43,579 --> 00:44:47,779
are refreshing the product from the

00:44:44,930 --> 00:44:52,430
database and we're checking if the VA T

00:44:47,779 --> 00:44:54,710
equals to 20 in reality we understand

00:44:52,430 --> 00:44:57,529
that the if-else is going to be much

00:44:54,710 --> 00:44:59,750
bigger we can split it into multiple

00:44:57,529 --> 00:45:01,670
methods but the essential part is that

00:44:59,750 --> 00:45:03,970
the entry point of this calculation is

00:45:01,670 --> 00:45:07,489
going to be in the view

00:45:03,970 --> 00:45:09,680
and for each brunch we're gonna have one

00:45:07,489 --> 00:45:11,869
test and each test will do the same

00:45:09,680 --> 00:45:14,720
thing it will create a product object

00:45:11,869 --> 00:45:16,609
and it will make the request and it will

00:45:14,720 --> 00:45:18,739
check this v80 value and that'll be

00:45:16,609 --> 00:45:20,930
that'll be they'll be just repeating

00:45:18,739 --> 00:45:23,989
ourselves and we're good we're going to

00:45:20,930 --> 00:45:28,549
do it for biscuits and bread and

00:45:23,989 --> 00:45:31,190
flapjacks and other items so to test

00:45:28,549 --> 00:45:34,460
each one of those items and to calculate

00:45:31,190 --> 00:45:37,069
they're to check their v80 value we will

00:45:34,460 --> 00:45:40,009
also be testing the route the router

00:45:37,069 --> 00:45:42,559
will be interacting with the database to

00:45:40,009 --> 00:45:45,140
eventually send an input to receive an

00:45:42,559 --> 00:45:47,059
output and if you're thinking that you

00:45:45,140 --> 00:45:51,349
can remove the database interactions

00:45:47,059 --> 00:45:54,079
will the mocks I think marks are not a

00:45:51,349 --> 00:45:57,470
solution in this case because we can do

00:45:54,079 --> 00:45:59,660
better solution number two the

00:45:57,470 --> 00:46:04,339
conditional check gets moved to a more

00:45:59,660 --> 00:46:07,249
appropriate place before so in the test

00:46:04,339 --> 00:46:09,410
we're again creating a product model we

00:46:07,249 --> 00:46:11,359
are instantiating the home we're passing

00:46:09,410 --> 00:46:13,549
in some data checking here the form is

00:46:11,359 --> 00:46:15,680
valid we're going to save the form

00:46:13,549 --> 00:46:19,999
refresh the product from the database

00:46:15,680 --> 00:46:21,739
and check if the VA T equals 20 to test

00:46:19,999 --> 00:46:24,200
it we again need to create a product

00:46:21,739 --> 00:46:26,480
object but we know long but we are no

00:46:24,200 --> 00:46:28,720
longer testing the routing which is an

00:46:26,480 --> 00:46:31,970
improvement over the solution number one

00:46:28,720 --> 00:46:34,430
via the form we send an input the

00:46:31,970 --> 00:46:37,930
answers to the questions to receive an

00:46:34,430 --> 00:46:41,269
output further than the last solution

00:46:37,930 --> 00:46:45,079
moves the entire decision-making to an

00:46:41,269 --> 00:46:47,420
old boring Python class or a function if

00:46:45,079 --> 00:46:50,150
you want to it has a method called

00:46:47,420 --> 00:46:52,759
calculate vit that does exactly what it

00:46:50,150 --> 00:46:55,579
says and in the test we're instantiating

00:46:52,759 --> 00:46:57,349
the vit calculator calling the method

00:46:55,579 --> 00:47:01,880
with a bunch of arguments and we're

00:46:57,349 --> 00:47:04,460
expecting the result to be 20 somehow we

00:47:01,880 --> 00:47:07,579
forget that Django is a web framework

00:47:04,460 --> 00:47:10,279
not a programming language different

00:47:07,579 --> 00:47:11,930
constructs can live outside of core

00:47:10,279 --> 00:47:15,349
Django components

00:47:11,930 --> 00:47:19,490
the VT calculator has no idea what Jango

00:47:15,349 --> 00:47:22,250
is and it doesn't need to when testing

00:47:19,490 --> 00:47:25,640
we're not testing the router we're not

00:47:22,250 --> 00:47:29,480
testing the URL all we do was sending an

00:47:25,640 --> 00:47:32,240
input to receive an output and what we

00:47:29,480 --> 00:47:36,079
did is called decoupling the coupling

00:47:32,240 --> 00:47:38,930
has various benefits reusability as a

00:47:36,079 --> 00:47:41,299
developer I can pull out the VHA

00:47:38,930 --> 00:47:43,430
calculate and build a separate app that

00:47:41,299 --> 00:47:45,700
calculates v80 and helps others maybe

00:47:43,430 --> 00:47:49,190
figure out their v80 values

00:47:45,700 --> 00:47:50,869
extensibility if my friend decides to

00:47:49,190 --> 00:47:53,359
expand their little business to a new

00:47:50,869 --> 00:47:55,670
country and this place has different vit

00:47:53,359 --> 00:47:59,089
values it's going to be much easier to

00:47:55,670 --> 00:48:01,039
update them in one place in the v80

00:47:59,089 --> 00:48:03,380
calculator rather than going for all of

00:48:01,039 --> 00:48:07,220
the views and forms and trying to update

00:48:03,380 --> 00:48:09,920
it there and finally to stability you

00:48:07,220 --> 00:48:13,789
saw how easy it was to test the v80

00:48:09,920 --> 00:48:16,640
calculator this approach of isolating

00:48:13,789 --> 00:48:18,589
business logic allows creating more and

00:48:16,640 --> 00:48:20,869
faster unit tests and keep the

00:48:18,589 --> 00:48:25,130
functional and integration tests at a

00:48:20,869 --> 00:48:28,220
manageable rate test have more in them

00:48:25,130 --> 00:48:31,460
than we think a test has the capability

00:48:28,220 --> 00:48:33,559
to drive a better app design in terms of

00:48:31,460 --> 00:48:36,440
Jango it's about moving complex logic

00:48:33,559 --> 00:48:38,690
away from any Jango related components

00:48:36,440 --> 00:48:41,839
if it's a complex behavior that isn't

00:48:38,690 --> 00:48:45,950
directly tied to the database templates

00:48:41,839 --> 00:48:48,319
forms or views and build objects that

00:48:45,950 --> 00:48:51,680
perform those complex actions and you

00:48:48,319 --> 00:48:53,720
need to test them thank you very much

00:48:51,680 --> 00:48:55,530
for your undivided attention and happy

00:48:53,720 --> 00:49:04,059
testing everyone

00:48:55,530 --> 00:49:04,059

YouTube URL: https://www.youtube.com/watch?v=Zo5q48BG8A4


