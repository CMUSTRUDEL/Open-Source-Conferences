Title: DjangoCon US 2016 - Django for IOT: From Hackathon to Production by Anna Schneider
Publication date: 2016-08-12
Playlist: DjangoCon US 2016
Description: 
	Django for IOT: From Hackathon to Production by Anna Schneider

Itâ€™s Friday night of hackathon weekend. The latest snazzy Internet-connected thingy is sitting on the table next to your beverage of choice, the deviceâ€™s API docs are open in a browser tab, and your fingers are itching to write some Django. Whatâ€™s the fastest way to get started? And next month when you come back to it, what will you want to upgrade?

This talk will walk through a common IoT use case, sending HTTP requests to turn on and off a device in response to some external data. I do this all the time at WattTime and I'll share some of the tricks I've picked up over the last couple years.

Weâ€™ll focus on two big differences from your typical blog or polls app: the data model abstractions that fit the problem, and the need to run frequent periodic tasks to hit the deviceâ€™s API. I'll share a data model that's worked well for me across a bunch of IoT apps. And I'll show you two ways to run those periodic background tasks in Django: a hackathon-friendly version, and a production-friendly version using Celery. You'll walk away with a complete demo template that you can use in your own projects!

This talk was presented at: https://2016.djangocon.us/schedule/presentation/16/

LINKS:
Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:17,600 --> 00:00:24,510
you don't want to hang out at overflow

00:00:19,740 --> 00:00:26,279
room you have to go see so I was

00:00:24,510 --> 00:00:28,289
introduced to Django at the hackathon

00:00:26,279 --> 00:00:30,359
where my startup is born Oh

00:00:28,289 --> 00:00:32,850
so we're called watt time and we use

00:00:30,359 --> 00:00:34,320
Django it's to fight climate change so

00:00:32,850 --> 00:00:36,420
we do that by enabling Internet

00:00:34,320 --> 00:00:37,649
connected devices like smart thermostats

00:00:36,420 --> 00:00:40,469
or the electric vehicle charging

00:00:37,649 --> 00:00:43,410
stations that you see pictured here to

00:00:40,469 --> 00:00:45,329
turn on when energy is clean coming from

00:00:43,410 --> 00:00:50,190
the grid and turn off when it's only one

00:00:45,329 --> 00:00:51,449
dirty fossil fuels another side project

00:00:50,190 --> 00:00:54,539
that I'm working on right now is the

00:00:51,449 --> 00:00:55,920
unconscious bias project oh and for that

00:00:54,539 --> 00:00:58,469
we're collecting evidence-based

00:00:55,920 --> 00:01:00,570
resources to help you identify reduce

00:00:58,469 --> 00:01:04,290
and cope with the effects of unconscious

00:01:00,570 --> 00:01:05,189
bias in science intact but they don't

00:01:04,290 --> 00:01:06,990
those are what I'm actually talking

00:01:05,189 --> 00:01:09,210
about here today so I'm talking about

00:01:06,990 --> 00:01:12,600
Django for the Internet of Things from

00:01:09,210 --> 00:01:14,509
hackathon to production what that was a

00:01:12,600 --> 00:01:16,770
lot of words let's break this down a bit

00:01:14,509 --> 00:01:19,650
so Django we all know and love

00:01:16,770 --> 00:01:21,900
everyone's favorite web framework on the

00:01:19,650 --> 00:01:23,430
Internet of Things so this has been

00:01:21,900 --> 00:01:26,250
something that you don't normally think

00:01:23,430 --> 00:01:30,020
about the computer like a thermostat or

00:01:26,250 --> 00:01:33,090
a car it can receive and transmit data

00:01:30,020 --> 00:01:36,689
and even respond to controls all in real

00:01:33,090 --> 00:01:38,100
time and when some people talk about the

00:01:36,689 --> 00:01:39,630
Internet of Things they talk about right

00:01:38,100 --> 00:01:42,000
maybe embedded code that runs on the

00:01:39,630 --> 00:01:44,490
device but a lot of devices that you can

00:01:42,000 --> 00:01:46,320
buy these days have api's that the

00:01:44,490 --> 00:01:47,520
vendor provides so today I'm going to

00:01:46,320 --> 00:01:48,930
focus on the use case where you're

00:01:47,520 --> 00:01:54,329
writing code that interacts with that

00:01:48,930 --> 00:01:56,310
API hackathon so hackathons are we can

00:01:54,329 --> 00:01:58,380
events where you form a team write a

00:01:56,310 --> 00:02:00,960
bunch of code bring a bunch of coffee

00:01:58,380 --> 00:02:01,650
and or here and these usually winners

00:02:00,960 --> 00:02:04,800
and prizes

00:02:01,650 --> 00:02:06,000
everyone has a great time and as IOT has

00:02:04,800 --> 00:02:07,740
grown in general it's become

00:02:06,000 --> 00:02:10,560
particularly popular for hackathon

00:02:07,740 --> 00:02:11,970
projects but because hackathons are so

00:02:10,560 --> 00:02:14,040
short and compressed they're just the

00:02:11,970 --> 00:02:18,180
weekends are the kind of notorious for

00:02:14,040 --> 00:02:19,560
producing really bad peloton so what if

00:02:18,180 --> 00:02:22,440
you want to put your code into action

00:02:19,560 --> 00:02:24,000
with real users so reliability matters

00:02:22,440 --> 00:02:25,500
in a different way for Internet of

00:02:24,000 --> 00:02:28,770
Things apps then for a lot of other

00:02:25,500 --> 00:02:31,500
things you might work on so say you have

00:02:28,770 --> 00:02:33,390
a Wi-Fi enabled walk on your house what

00:02:31,500 --> 00:02:35,580
happens if the server goes down can you

00:02:33,390 --> 00:02:38,700
still get into your house and then you

00:02:35,580 --> 00:02:39,959
wouldn't get into your house so you'll

00:02:38,700 --> 00:02:42,000
want to be a little bit more careful

00:02:39,959 --> 00:02:43,260
when you're coding for production eat

00:02:42,000 --> 00:02:45,510
your fruits and veggies while you're

00:02:43,260 --> 00:02:47,700
drinking your beer and make sure that

00:02:45,510 --> 00:02:49,709
your code is extensible and testable and

00:02:47,700 --> 00:02:52,650
use those dependencies that are reliable

00:02:49,709 --> 00:02:56,910
so that when you ship it you can trust

00:02:52,650 --> 00:02:59,550
it then go have fun so today we're gonna

00:02:56,910 --> 00:03:01,470
talk about some design patterns that

00:02:59,550 --> 00:03:03,950
have worked for us at watt time while

00:03:01,470 --> 00:03:06,810
writing in the point in django projects

00:03:03,950 --> 00:03:09,150
that monitor and control in the night of

00:03:06,810 --> 00:03:12,120
things devices using the vendor provided

00:03:09,150 --> 00:03:13,890
api's some things will streamline your

00:03:12,120 --> 00:03:15,510
work for your next hackathon and other

00:03:13,890 --> 00:03:18,209
things will help you as you move into

00:03:15,510 --> 00:03:21,120
production I mean as we go we'll be

00:03:18,209 --> 00:03:23,280
using this emoji for hackathons this one

00:03:21,120 --> 00:03:28,380
for production and this one for

00:03:23,280 --> 00:03:30,120
anti-patterns to a boy great so imagine

00:03:28,380 --> 00:03:31,950
it's Friday night you're at a hackathon

00:03:30,120 --> 00:03:35,760
and you have this awesome idea for an

00:03:31,950 --> 00:03:38,610
IOT project where do you start usually

00:03:35,760 --> 00:03:40,260
start with some models so for comparison

00:03:38,610 --> 00:03:41,400
let's think about the standard box out

00:03:40,260 --> 00:03:43,980
but you may have seen in this tutorial

00:03:41,400 --> 00:03:46,170
oh we have an author model with a name

00:03:43,980 --> 00:03:48,299
and the hometown attributes and we have

00:03:46,170 --> 00:03:49,890
a book model with title a foreign keys

00:03:48,299 --> 00:03:54,120
author and year that the book was

00:03:49,890 --> 00:03:56,250
published and analogous IOT model would

00:03:54,120 --> 00:03:57,959
look pretty similar to start with so

00:03:56,250 --> 00:03:59,760
into the book we have a device within

00:03:57,959 --> 00:04:02,940
the in the location and instead of

00:03:59,760 --> 00:04:06,030
author sorry other way around there so

00:04:02,940 --> 00:04:07,890
instead of device being a author we have

00:04:06,030 --> 00:04:09,350
a device with a name of the location and

00:04:07,890 --> 00:04:12,450
so the book if you have an observation

00:04:09,350 --> 00:04:15,840
with a value a foreign key back to the

00:04:12,450 --> 00:04:16,889
device and a timestamp so even though it

00:04:15,840 --> 00:04:20,549
said the words wrong there's a lot

00:04:16,889 --> 00:04:23,100
that's similar so what's different the

00:04:20,549 --> 00:04:25,920
main change to the device model is to

00:04:23,100 --> 00:04:27,380
add a vendor provided that I gain

00:04:25,920 --> 00:04:29,670
something like an app address maybe

00:04:27,380 --> 00:04:31,770
you'll almost always need this to pass

00:04:29,670 --> 00:04:33,300
on to the vendors API so uniquely

00:04:31,770 --> 00:04:35,880
identify what device you want to be

00:04:33,300 --> 00:04:38,160
talking to so this might be analogous to

00:04:35,880 --> 00:04:44,040
the author's social security number of a

00:04:38,160 --> 00:04:45,600
national ID number when you're writing

00:04:44,040 --> 00:04:48,330
these apps just thinking about the

00:04:45,600 --> 00:04:50,310
observations so eiope it's fundamentally

00:04:48,330 --> 00:04:51,930
about time series data in the way that

00:04:50,310 --> 00:04:54,210
most other django starter projects

00:04:51,930 --> 00:04:55,530
aren't I'm at the number of observations

00:04:54,210 --> 00:04:57,720
that you'll be dealing with grows a lot

00:04:55,530 --> 00:05:01,500
faster than the content in the early

00:04:57,720 --> 00:05:02,790
stage of a typical content driven app so

00:05:01,500 --> 00:05:05,940
a lot of time we tend to deal with

00:05:02,790 --> 00:05:07,320
medium sized data since we pull a new

00:05:05,940 --> 00:05:09,180
energy data from the power grid every

00:05:07,320 --> 00:05:11,669
five minutes so it's not like huge data

00:05:09,180 --> 00:05:13,620
um your project might enter Big Data

00:05:11,669 --> 00:05:15,900
territory much faster than you expect

00:05:13,620 --> 00:05:17,400
because many Sun States have readings of

00:05:15,900 --> 00:05:20,660
holding extremely quickly

00:05:17,400 --> 00:05:24,300
I mean even that my very first hackathon

00:05:20,660 --> 00:05:25,680
having a database indexed to timestamp

00:05:24,300 --> 00:05:27,449
because the difference between it our

00:05:25,680 --> 00:05:30,090
demo timing out and they've actually

00:05:27,449 --> 00:05:31,710
running quickly and smoothly so I think

00:05:30,090 --> 00:05:35,810
it was underlying structure of your

00:05:31,710 --> 00:05:37,800
database tables might be more important

00:05:35,810 --> 00:05:39,660
and the last difference I'm going to

00:05:37,800 --> 00:05:41,220
talk about it is you want to be storing

00:05:39,660 --> 00:05:43,500
different types of observations in a lot

00:05:41,220 --> 00:05:45,000
of cases so with books it's a good bet

00:05:43,500 --> 00:05:47,790
that the title is gonna be well

00:05:45,000 --> 00:05:49,380
represented by character data but with

00:05:47,790 --> 00:05:51,150
IOT you'll probably want to be storing

00:05:49,380 --> 00:05:53,250
both numerical data like how much energy

00:05:51,150 --> 00:05:55,199
is being used by the device and maybe

00:05:53,250 --> 00:05:58,020
boolean data like by they did devices on

00:05:55,199 --> 00:06:00,270
or off I'm possibly also care data like

00:05:58,020 --> 00:06:02,490
display messages or data with choices

00:06:00,270 --> 00:06:03,780
like the color of a light bulb so you

00:06:02,490 --> 00:06:05,419
might want to use different models for

00:06:03,780 --> 00:06:08,190
those different data types

00:06:05,419 --> 00:06:12,360
great so we have a basic data model on

00:06:08,190 --> 00:06:14,370
two views right wrong so instead of

00:06:12,360 --> 00:06:16,330
views which are for interactions with

00:06:14,370 --> 00:06:18,460
people our basic unit of Internet

00:06:16,330 --> 00:06:19,659
Tiffany is going to be tasks which are

00:06:18,460 --> 00:06:22,870
for interactions that can be checked

00:06:19,659 --> 00:06:24,039
over about a human pressing a button and

00:06:22,870 --> 00:06:26,259
see why this is important let's think

00:06:24,039 --> 00:06:28,449
about the normal vanilla and BC Django

00:06:26,259 --> 00:06:30,310
project in this case your app is only

00:06:28,449 --> 00:06:34,330
responsible for sending data to a user

00:06:30,310 --> 00:06:36,729
if they request it from you but most

00:06:34,330 --> 00:06:39,759
third party API is including almost

00:06:36,729 --> 00:06:41,830
every API if used for an IOT project um

00:06:39,759 --> 00:06:43,690
they put the responsibility on your app

00:06:41,830 --> 00:06:46,300
to make the request to them whenever you

00:06:43,690 --> 00:06:47,770
want to push or pull data and the person

00:06:46,300 --> 00:06:48,789
big part of the point of the Internet of

00:06:47,770 --> 00:06:51,340
Things is machine to machine

00:06:48,789 --> 00:06:53,229
communication doing what the user

00:06:51,340 --> 00:06:55,629
magically wants without making and ask

00:06:53,229 --> 00:06:57,789
for it so it's crucial to all the

00:06:55,629 --> 00:06:59,919
important stuff that happens in your app

00:06:57,789 --> 00:07:02,860
can be initiated outside that they use a

00:06:59,919 --> 00:07:04,690
rep and request response cycle then

00:07:02,860 --> 00:07:07,180
pretty much Natalia rest of the talk

00:07:04,690 --> 00:07:12,969
today is going to be focusing on how to

00:07:07,180 --> 00:07:15,849
make that happen because it's what tasks

00:07:12,969 --> 00:07:18,069
do we need to be doing the two basic

00:07:15,849 --> 00:07:19,419
kinds of functionality for an IOT

00:07:18,069 --> 00:07:21,219
application are going to be monitoring

00:07:19,419 --> 00:07:23,650
so getting the state of the device and

00:07:21,219 --> 00:07:26,050
control changing to see them at the race

00:07:23,650 --> 00:07:28,710
so for each kind of observation you have

00:07:26,050 --> 00:07:32,770
you might want a separate task function

00:07:28,710 --> 00:07:35,050
to get the data and to set it if the

00:07:32,770 --> 00:07:37,240
vendor lets you modify it on some api's

00:07:35,050 --> 00:07:38,880
don't let you multiply as many attribute

00:07:37,240 --> 00:07:41,080
doesn't want to so check that before

00:07:38,880 --> 00:07:45,460
getting your heart set on specific

00:07:41,080 --> 00:07:47,409
applications you'll also need a driver

00:07:45,460 --> 00:07:49,719
task so let's call it they'd do

00:07:47,409 --> 00:07:52,719
something else and it's going to stitch

00:07:49,719 --> 00:07:55,919
all of this together more or less speed

00:07:52,719 --> 00:07:59,469
evolve cool so for this particularly

00:07:55,919 --> 00:08:02,560
demo application we're gonna have an

00:07:59,469 --> 00:08:04,330
AIDS of ice we're going to based on some

00:08:02,560 --> 00:08:08,949
external data decide whether to turn it

00:08:04,330 --> 00:08:10,960
on or off we will pass that is on

00:08:08,949 --> 00:08:14,500
message on to the device using the

00:08:10,960 --> 00:08:16,599
devices API we will save that new status

00:08:14,500 --> 00:08:19,389
to the database so that's what's

00:08:16,599 --> 00:08:21,219
happening here it's kind of funny after

00:08:19,389 --> 00:08:22,900
working on Internet of Things apps for a

00:08:21,219 --> 00:08:24,150
while the part where you interact with

00:08:22,900 --> 00:08:26,910
the device itself has

00:08:24,150 --> 00:08:28,440
less exciting to me and because that's

00:08:26,910 --> 00:08:29,730
part this kind of a thing between both

00:08:28,440 --> 00:08:31,380
abs like you're talking to your light

00:08:29,730 --> 00:08:34,110
bulb that part is gonna be the same but

00:08:31,380 --> 00:08:36,000
the part that I get excited about now is

00:08:34,110 --> 00:08:38,010
the decision criteria for why you're

00:08:36,000 --> 00:08:39,900
turning that light on or off why you're

00:08:38,010 --> 00:08:49,140
actually taking action because that's

00:08:39,900 --> 00:08:50,730
what that makes your ambient so once

00:08:49,140 --> 00:08:58,230
you've decided what sort of awesome

00:08:50,730 --> 00:09:02,580
thing you actually want to do so writing

00:08:58,230 --> 00:09:06,990
the code is going to be as just as

00:09:02,580 --> 00:09:08,850
simple or as hard as your idea but there

00:09:06,990 --> 00:09:11,400
is when it gotcha that we'll talk about

00:09:08,850 --> 00:09:13,920
quickly so we're building up to any of

00:09:11,400 --> 00:09:15,690
these paths asynchronously so in a

00:09:13,920 --> 00:09:17,520
production situation you can't

00:09:15,690 --> 00:09:19,050
necessarily count on the state of the

00:09:17,520 --> 00:09:22,080
database being the same when the task

00:09:19,050 --> 00:09:24,000
runs as when you called it so here since

00:09:22,080 --> 00:09:26,970
we're passing the device as the

00:09:24,000 --> 00:09:29,820
parameters what happens the database may

00:09:26,970 --> 00:09:32,730
be different by the time we get here so

00:09:29,820 --> 00:09:34,500
a better convention that I like is

00:09:32,730 --> 00:09:36,840
passing in the primary key to the device

00:09:34,500 --> 00:09:39,240
and then it you can make the query

00:09:36,840 --> 00:09:40,590
together exactly the right object that

00:09:39,240 --> 00:09:43,980
you want from the database right when

00:09:40,590 --> 00:09:46,200
you need it also gives it a convention

00:09:43,980 --> 00:09:48,270
of returning a primary keys and you

00:09:46,200 --> 00:09:51,360
objects instead of something like error

00:09:48,270 --> 00:09:57,210
codes then you can change a fantastic

00:09:51,360 --> 00:09:59,310
effort really easily so we have our

00:09:57,210 --> 00:10:02,310
models we have our tasks let's put it

00:09:59,310 --> 00:10:04,590
together into acts so in the hackathon

00:10:02,310 --> 00:10:07,320
situation just possible into one app no

00:10:04,590 --> 00:10:10,530
wonder like airs but if you want to

00:10:07,320 --> 00:10:13,680
organize a little bit better I like to

00:10:10,530 --> 00:10:16,410
split up my apps this way so devices has

00:10:13,680 --> 00:10:18,740
the device model observations might have

00:10:16,410 --> 00:10:21,810
attributes that it's anything else

00:10:18,740 --> 00:10:24,960
interactions is where the tasks go and

00:10:21,810 --> 00:10:26,990
it'll have the wrapper around the vendor

00:10:24,960 --> 00:10:29,160
client

00:10:26,990 --> 00:10:31,620
so this might seem like a lot of

00:10:29,160 --> 00:10:34,110
structure for now but each app will grow

00:10:31,620 --> 00:10:35,850
over time as you start adding views for

00:10:34,110 --> 00:10:39,449
adding and removing devices so the user

00:10:35,850 --> 00:10:41,519
can manage what they have if you want to

00:10:39,449 --> 00:10:43,610
start adding and eb-3 dashboards you can

00:10:41,519 --> 00:10:45,990
put those views and the observations app

00:10:43,610 --> 00:10:47,069
you're probably going to want to log but

00:10:45,990 --> 00:10:48,629
interactions that you're making with a

00:10:47,069 --> 00:10:50,970
device so that can go into interactions

00:10:48,629 --> 00:10:52,800
app and if you want to start having

00:10:50,970 --> 00:10:54,480
multiple kinds of devices that you're

00:10:52,800 --> 00:10:58,620
supporting then you can swap out a bit

00:10:54,480 --> 00:11:00,360
better it guys pretty easily well they

00:10:58,620 --> 00:11:04,290
have models we have tasks there and apps

00:11:00,360 --> 00:11:06,420
let's deploy it the Howey in a deploy

00:11:04,290 --> 00:11:08,730
these tasks running a web server isn't

00:11:06,420 --> 00:11:10,199
actually going to help us yet but we

00:11:08,730 --> 00:11:12,059
really need is something to act like if

00:11:10,199 --> 00:11:14,160
you're familiar with the UNIX concept of

00:11:12,059 --> 00:11:15,749
cron their cron tabs where we want

00:11:14,160 --> 00:11:18,509
something like that but that can run in

00:11:15,749 --> 00:11:20,160
a distributed cloud environment so we

00:11:18,509 --> 00:11:22,889
want to be able to run it our tasks

00:11:20,160 --> 00:11:24,689
anytime we want at frequent and

00:11:22,889 --> 00:11:27,059
deterministic times

00:11:24,689 --> 00:11:30,120
and outside of their request rate clock

00:11:27,059 --> 00:11:31,439
cycle so and this is the situation this

00:11:30,120 --> 00:11:34,199
is the part of the code where hackathon

00:11:31,439 --> 00:11:35,490
and production differ most so I'm gonna

00:11:34,199 --> 00:11:38,160
talk about two different ways to run

00:11:35,490 --> 00:11:40,199
these tasks both of which you can deploy

00:11:38,160 --> 00:11:43,290
to Heroku or a lot of other cloud

00:11:40,199 --> 00:11:46,050
environments so let's see the hackathon

00:11:43,290 --> 00:11:48,240
day first I'm using Heroku it had an

00:11:46,050 --> 00:11:50,879
add-on code scheduler and we'll use that

00:11:48,240 --> 00:11:52,680
to run management commands so you're

00:11:50,879 --> 00:11:54,600
already familiar with the Django

00:11:52,680 --> 00:11:57,509
management commands like make migrations

00:11:54,600 --> 00:11:58,920
or run server probably and you can write

00:11:57,509 --> 00:12:00,629
your own management commands to you

00:11:58,920 --> 00:12:02,160
there's boilerplate and the tankards ox

00:12:00,629 --> 00:12:04,680
me essentially just copy the app and

00:12:02,160 --> 00:12:06,209
that's a great way to get started and in

00:12:04,680 --> 00:12:07,889
this case we'll just have a simple

00:12:06,209 --> 00:12:11,730
management command that rounds the tasks

00:12:07,889 --> 00:12:13,649
that we already have and then to get it

00:12:11,730 --> 00:12:16,529
running on Heroku scheduler there's this

00:12:13,649 --> 00:12:19,170
free add-on with a cute little web

00:12:16,529 --> 00:12:20,850
interface to set up to run your tasks so

00:12:19,170 --> 00:12:23,519
it's pretty easy to set up which is good

00:12:20,850 --> 00:12:25,199
the downsides to using this one we could

00:12:23,519 --> 00:12:27,509
only through the bowl for hackathon

00:12:25,199 --> 00:12:28,949
situations is that it has very limited

00:12:27,509 --> 00:12:31,560
frequency is that it lets you either

00:12:28,949 --> 00:12:33,240
fast so you can do daily hourly or

00:12:31,560 --> 00:12:36,420
ten minutes but if you want to do every

00:12:33,240 --> 00:12:38,100
five minutes you're a dilash and that's

00:12:36,420 --> 00:12:40,620
also if they only operate at the best

00:12:38,100 --> 00:12:42,990
efforts or test so I have noticed it's

00:12:40,620 --> 00:12:45,240
kept some and tasks if you let her run

00:12:42,990 --> 00:12:48,420
long enough and then are sad when you

00:12:45,240 --> 00:12:51,690
don't have that one day to play but it's

00:12:48,420 --> 00:12:53,670
awesome for hackathons if you need to go

00:12:51,690 --> 00:12:55,800
into production and do it for real

00:12:53,670 --> 00:12:58,110
you want both more flexibility and more

00:12:55,800 --> 00:13:01,050
reliability is than these three atoms

00:12:58,110 --> 00:13:03,089
can give you so as the fifth production

00:13:01,050 --> 00:13:06,960
I'll eat your veggies so we're going to

00:13:03,089 --> 00:13:10,320
use a package called celery so what is

00:13:06,960 --> 00:13:15,450
celery celery is a distributed Message

00:13:10,320 --> 00:13:17,820
Queuing system or asynchronous most

00:13:15,450 --> 00:13:20,070
tutorials for celery focus on how it's

00:13:17,820 --> 00:13:20,850
really good for long running

00:13:20,070 --> 00:13:22,860
event-driven

00:13:20,850 --> 00:13:24,570
background tasks like maybe sending the

00:13:22,860 --> 00:13:27,210
user assignment email after they sign

00:13:24,570 --> 00:13:28,680
that for your site that's something that

00:13:27,210 --> 00:13:29,850
doesn't come off as much into toriel's

00:13:28,680 --> 00:13:34,050
but that we're gonna be using it for

00:13:29,850 --> 00:13:37,980
today is scheduling periodic tasks so in

00:13:34,050 --> 00:13:40,320
a generic app I may want to run some

00:13:37,980 --> 00:13:44,610
daily analytics like Clinton was just

00:13:40,320 --> 00:13:47,310
using for aggregating all those data for

00:13:44,610 --> 00:13:49,560
the police calls but here we're going to

00:13:47,310 --> 00:13:54,180
be using it for doing our cron in the

00:13:49,560 --> 00:13:56,280
cloud solution the main reason I don't

00:13:54,180 --> 00:13:58,080
recommend celery for hackathons is that

00:13:56,280 --> 00:14:00,870
it complicates your architecture a lot

00:13:58,080 --> 00:14:03,240
so do a brief overview of everything

00:14:00,870 --> 00:14:06,060
that you need to have setup to run a

00:14:03,240 --> 00:14:08,160
celery app so we have our web servers

00:14:06,060 --> 00:14:11,880
those can trigger the adventure than

00:14:08,160 --> 00:14:15,930
tasks we also run a scheduler server

00:14:11,880 --> 00:14:18,330
that can trigger the periodic tasks both

00:14:15,930 --> 00:14:20,160
of those put messages on a message

00:14:18,330 --> 00:14:22,950
broker transport to you that's what

00:14:20,160 --> 00:14:25,080
celery calls it hamid it's just been a

00:14:22,950 --> 00:14:27,510
first in first out of Kyoto where

00:14:25,080 --> 00:14:29,880
wherever tasks get put on they can then

00:14:27,510 --> 00:14:32,190
get consumed by worker servers that

00:14:29,880 --> 00:14:34,770
actually do the work of running that

00:14:32,190 --> 00:14:35,630
task function so maybe they'll go out

00:14:34,770 --> 00:14:37,250
and have externally

00:14:35,630 --> 00:14:38,630
yeah eyes maybe a little but these in

00:14:37,250 --> 00:14:41,390
the database they'll do whatever you

00:14:38,630 --> 00:14:44,660
need them to do and if there is we

00:14:41,390 --> 00:14:45,800
tournament data from that function it

00:14:44,660 --> 00:14:48,950
will go into something called the reads

00:14:45,800 --> 00:14:50,870
song story and there's a bunch of

00:14:48,950 --> 00:14:52,850
different options for backing services

00:14:50,870 --> 00:14:54,830
or both the queue and the result story

00:14:52,850 --> 00:14:58,520
Redis is a popular one because it's

00:14:54,830 --> 00:15:01,640
really good to go look at them um rabbit

00:14:58,520 --> 00:15:02,930
am TP yeah I am Kiki's services are also

00:15:01,640 --> 00:15:06,880
good for the queue but not for the

00:15:02,930 --> 00:15:09,950
results or so to make it more concrete

00:15:06,880 --> 00:15:12,500
for IOT application we're going to have

00:15:09,950 --> 00:15:14,780
every few minutes our scheduler is going

00:15:12,500 --> 00:15:17,390
to put a do something awesome message

00:15:14,780 --> 00:15:20,720
into the queue our worker will pull it

00:15:17,390 --> 00:15:24,740
off it will decide whatever you want to

00:15:20,720 --> 00:15:28,370
do me turn on our light bulb it will

00:15:24,740 --> 00:15:30,320
send the API request to our vendor it

00:15:28,370 --> 00:15:34,580
states have a light bulb the vendor will

00:15:30,320 --> 00:15:36,560
return yes it's on mode good job the

00:15:34,580 --> 00:15:38,600
worker will then that store that new

00:15:36,560 --> 00:15:44,540
status in the database and return the

00:15:38,600 --> 00:15:46,490
primary key to the results are so once

00:15:44,540 --> 00:15:49,460
you got all that architecture configured

00:15:46,490 --> 00:15:51,680
actually changing our plain of Python

00:15:49,460 --> 00:15:56,000
tasks and cheese celery tasks is really

00:15:51,680 --> 00:15:57,740
easy just add a separator and then to

00:15:56,000 --> 00:16:03,010
configure when the tasks are going to

00:15:57,740 --> 00:16:06,650
rhyme there is this dictionary syntax

00:16:03,010 --> 00:16:08,570
and this syntax for defining the period

00:16:06,650 --> 00:16:11,210
to see itself it's pretty similar to

00:16:08,570 --> 00:16:13,190
UNIX con tab so you can have really

00:16:11,210 --> 00:16:15,650
flexible intervals anywhere between the

00:16:13,190 --> 00:16:17,270
lunch minute and once a year I'm

00:16:15,650 --> 00:16:20,120
including things like day of the week or

00:16:17,270 --> 00:16:24,440
like only at new and on Tuesdays or

00:16:20,120 --> 00:16:26,720
anything like that and after all might

00:16:24,440 --> 00:16:30,170
talk about passing primary keys around

00:16:26,720 --> 00:16:32,000
you probably tempted to do a query here

00:16:30,170 --> 00:16:35,000
and pass the results as argument

00:16:32,000 --> 00:16:37,370
sensitive tasks right unfortunately this

00:16:35,000 --> 00:16:39,500
doesn't work very well because this

00:16:37,370 --> 00:16:40,970
dictionary is only evaluated once like

00:16:39,500 --> 00:16:45,490
everything else in your settings file

00:16:40,970 --> 00:16:45,490
for instance so you can only use static

00:16:46,489 --> 00:16:54,269
that's not an option why have you been

00:16:49,709 --> 00:16:56,339
sort of workarounds is to have a wrapper

00:16:54,269 --> 00:16:58,230
task that spawns

00:16:56,339 --> 00:17:02,329
all the daughter tasks that you need and

00:16:58,230 --> 00:17:02,329
so your database call only happens here

00:17:05,539 --> 00:17:10,559
we have a final of production ready

00:17:08,220 --> 00:17:13,860
project so we have the same apps as

00:17:10,559 --> 00:17:17,010
before at the bottom the schedule file

00:17:13,860 --> 00:17:18,179
has been added to the interaction and

00:17:17,010 --> 00:17:20,579
then there's a bunch of other

00:17:18,179 --> 00:17:22,970
boilerplate to configure all of the

00:17:20,579 --> 00:17:25,380
salary architecture that's involved so

00:17:22,970 --> 00:17:26,730
there's some pretty important subtleties

00:17:25,380 --> 00:17:32,429
math if I don't have time to get into

00:17:26,730 --> 00:17:34,500
today but the docs are getting and if

00:17:32,429 --> 00:17:36,630
you didn't I'll memorize all that very

00:17:34,500 --> 00:17:41,370
well so put together a cookie cutter

00:17:36,630 --> 00:17:43,710
template I github.com plus a SCH n slash

00:17:41,370 --> 00:17:45,450
cookie cutter Django I owe to you so

00:17:43,710 --> 00:17:47,460
this has all the boilerplate configured

00:17:45,450 --> 00:17:49,770
for you it has all with the diva models

00:17:47,460 --> 00:17:52,169
configured for you all you have to do is

00:17:49,770 --> 00:17:55,850
write your actual interactions with the

00:17:52,169 --> 00:17:58,889
vendor API and do something awesome is

00:17:55,850 --> 00:18:01,020
this should make things a lot faster for

00:17:58,889 --> 00:18:02,010
you to deploy either with salary or with

00:18:01,020 --> 00:18:05,010
the management commands

00:18:02,010 --> 00:18:06,270
that's all configure to one on Heroku so

00:18:05,010 --> 00:18:12,110
hopefully this will be helpful for your

00:18:06,270 --> 00:18:12,110
next saxophone so what have you learned

00:18:12,169 --> 00:18:17,250
IOT is fundamentally about time series

00:18:14,820 --> 00:18:19,500
data in a way that most other a Django

00:18:17,250 --> 00:18:21,270
starter projects aren't so that would

00:18:19,500 --> 00:18:22,649
mean bigger data and that will mean you

00:18:21,270 --> 00:18:24,149
have to think a little bit differently

00:18:22,649 --> 00:18:25,320
about which of your models are going to

00:18:24,149 --> 00:18:29,850
be big and what to them are going to be

00:18:25,320 --> 00:18:32,010
small and IOT is also fundamentally

00:18:29,850 --> 00:18:35,000
about asynchronous processes instead of

00:18:32,010 --> 00:18:38,549
the standard MVC request response cycle

00:18:35,000 --> 00:18:39,419
so think about putting it the actually

00:18:38,549 --> 00:18:41,250
important stuff

00:18:39,419 --> 00:18:42,600
not in views but in somewhere that can

00:18:41,250 --> 00:18:46,260
be accessed to me tasks there's

00:18:42,600 --> 00:18:48,510
something else to run those tasks a easy

00:18:46,260 --> 00:18:50,360
but really rigid way that's gonna back

00:18:48,510 --> 00:18:53,220
down situations is for every scheduler

00:18:50,360 --> 00:18:56,190
and the flexible more complex way

00:18:53,220 --> 00:18:57,780
is using salary and I keep talking about

00:18:56,190 --> 00:18:59,400
Heroku just because that's really common

00:18:57,780 --> 00:19:04,020
for hackathons but Celebi of course can

00:18:59,400 --> 00:19:05,610
run anywhere if you want to get started

00:19:04,020 --> 00:19:08,100
some of using some of those better and

00:19:05,610 --> 00:19:14,010
faster then cookie cutter a django iot

00:19:08,100 --> 00:19:15,960
as ready for your perusal and just again

00:19:14,010 --> 00:19:17,669
old more philosophical for a sack I'm

00:19:15,960 --> 00:19:22,110
getting back to the you know this

00:19:17,669 --> 00:19:25,140
morning a IOT is typically thought I've

00:19:22,110 --> 00:19:28,080
been very privileged situations it makes

00:19:25,140 --> 00:19:31,380
life easier for people who already have

00:19:28,080 --> 00:19:33,000
it really easy but a lot of time we

00:19:31,380 --> 00:19:36,150
think that the Internet of Things can be

00:19:33,000 --> 00:19:38,130
more powerful than that so we like to

00:19:36,150 --> 00:19:39,840
use the IOT for environmental

00:19:38,130 --> 00:19:41,789
applications but I encourage you to

00:19:39,840 --> 00:19:43,799
think about ways in your life look we're

00:19:41,789 --> 00:19:45,630
having despite this response to what's

00:19:43,799 --> 00:19:52,700
happening around them to be much more

00:19:45,630 --> 00:19:52,700
broadly as thank you

00:20:02,650 --> 00:20:13,220
are you saying make the time the primary

00:20:06,320 --> 00:20:15,650
key and so I haven't actually tried

00:20:13,220 --> 00:20:28,040
doing it that way I just use the

00:20:15,650 --> 00:20:29,870
standard Django primary so if you're

00:20:28,040 --> 00:20:30,500
running on one of these platform

00:20:29,870 --> 00:20:37,820
as-a-service

00:20:30,500 --> 00:20:38,990
situations you can't access cron oh I

00:20:37,820 --> 00:20:40,700
guess he might have answered that

00:20:38,990 --> 00:20:43,670
question I understand that celery has

00:20:40,700 --> 00:20:51,260
the advantage of the of a queuing for

00:20:43,670 --> 00:20:54,620
asynchronous tasks but but why Heroku

00:20:51,260 --> 00:21:03,680
versus cron is that also is that also is

00:20:54,620 --> 00:21:05,390
you may not have access just set up just

00:21:03,680 --> 00:21:16,340
setting up a job in a cron tap and

00:21:05,390 --> 00:21:18,020
invoking like an environment where you

00:21:16,340 --> 00:21:19,490
have access to con and you know that

00:21:18,020 --> 00:21:22,760
you're going to only be running on that

00:21:19,490 --> 00:21:25,130
machine then cron can do the job for you

00:21:22,760 --> 00:21:26,840
but in some sort of more distributed

00:21:25,130 --> 00:21:29,680
situation where you can't rely on having

00:21:26,840 --> 00:21:29,680
access to those

00:21:43,610 --> 00:21:47,850
yeah I didn't have a lot of success with

00:21:46,890 --> 00:21:51,090
salary

00:21:47,850 --> 00:21:53,070
flower flower harpy say it and I wanted

00:21:51,090 --> 00:21:53,550
to like it you couldn't get a lot out of

00:21:53,070 --> 00:21:55,950
it

00:21:53,550 --> 00:21:58,170
I actually don't use Redis for my

00:21:55,950 --> 00:22:02,340
production situations I use a cloud am

00:21:58,170 --> 00:22:04,590
KP I'm another MPP services and I find

00:22:02,340 --> 00:22:06,330
the monitoring on that is pretty good

00:22:04,590 --> 00:22:08,160
but again not quite as much detail as I

00:22:06,330 --> 00:22:10,290
want so lately I've been looking into

00:22:08,160 --> 00:22:12,750
using LeBron out with some of those sort

00:22:10,290 --> 00:22:14,370
of blogging things when they think if I

00:22:12,750 --> 00:22:19,470
just found out about lebra though is

00:22:14,370 --> 00:22:22,710
that you can you can send alerts based

00:22:19,470 --> 00:22:24,510
on when the line show up in your log

00:22:22,710 --> 00:22:27,180
file so either based on the content or

00:22:24,510 --> 00:22:29,040
if it just like if your cue stops you

00:22:27,180 --> 00:22:30,750
porting for 10 minutes and you can have

00:22:29,040 --> 00:22:34,080
little Bravo checker and a lot of base

00:22:30,750 --> 00:22:35,850
not bad my infamous setting that up as

00:22:34,080 --> 00:22:38,540
we speak today so I'm pretty excited to

00:22:35,850 --> 00:22:38,540
see how that works for us

00:22:46,860 --> 00:22:49,860
sorry

00:22:58,290 --> 00:23:06,669
the task decorator yeah yeah there's a

00:23:04,900 --> 00:23:13,510
periodic pass separator where you just

00:23:06,669 --> 00:23:15,250
feed it to contact because I don't like

00:23:13,510 --> 00:23:18,130
to have the tasks only be available

00:23:15,250 --> 00:23:19,809
periodically if you do it just make you

00:23:18,130 --> 00:23:22,900
can call it from multiple places and

00:23:19,809 --> 00:23:25,870
different ways what's the biggest

00:23:22,900 --> 00:23:31,360
challenges had to solve with doing an

00:23:25,870 --> 00:23:32,440
INT project I guess one application that

00:23:31,360 --> 00:23:35,440
we're working on right now is

00:23:32,440 --> 00:23:39,340
controlling smart thermostats so we have

00:23:35,440 --> 00:23:42,520
a data coming in about whether the power

00:23:39,340 --> 00:23:43,870
grid in Chicago how much carbon

00:23:42,520 --> 00:23:47,380
pollution there isn't that electricity

00:23:43,870 --> 00:23:51,130
you um and so the API that I'm working

00:23:47,380 --> 00:23:53,490
with for that partner is a so ppi it's

00:23:51,130 --> 00:23:56,740
been incredibly annoying to deal with

00:23:53,490 --> 00:23:59,470
that like little liner it's like status

00:23:56,740 --> 00:24:02,860
is actually like a huge really annoying

00:23:59,470 --> 00:24:06,940
method there so pinky your parties

00:24:02,860 --> 00:24:08,530
carefully is important another question

00:24:06,940 --> 00:24:11,049
I noticed early on in your slides you

00:24:08,530 --> 00:24:13,960
had a ascend status and then a status

00:24:11,049 --> 00:24:15,580
set create and I'm wondering what's the

00:24:13,960 --> 00:24:17,080
purpose of duplicating that in other

00:24:15,580 --> 00:24:19,330
words I'm thinking about the ecobee

00:24:17,080 --> 00:24:20,590
thermostat where everything you do it

00:24:19,330 --> 00:24:23,919
just queries everything again from

00:24:20,590 --> 00:24:26,290
scratch and I wonder if if that model of

00:24:23,919 --> 00:24:30,340
the avoids desynchronization of the

00:24:26,290 --> 00:24:32,470
state of the device versus the the are

00:24:30,340 --> 00:24:36,340
the databases view of the state of the

00:24:32,470 --> 00:24:39,160
device can be a problem I'm for some

00:24:36,340 --> 00:24:41,290
devices they only let you access maybe

00:24:39,160 --> 00:24:42,760
like 10 days of historical data and so

00:24:41,290 --> 00:24:45,190
having your own record of it can be

00:24:42,760 --> 00:24:46,600
really useful too even if that does

00:24:45,190 --> 00:24:47,559
create the additional challenge of

00:24:46,600 --> 00:24:50,169
trying to keep them up to date

00:24:47,559 --> 00:24:52,360
it makes sense because it just depend on

00:24:50,169 --> 00:24:54,510
ask reacting the state if that doesn't

00:24:52,360 --> 00:24:57,760
take you long rather than depending on

00:24:54,510 --> 00:24:59,799
the state in the database being yeah so

00:24:57,760 --> 00:25:00,650
if you are able to ask the device for

00:24:59,799 --> 00:25:05,060
its own historical

00:25:00,650 --> 00:25:18,530
that is likely to be more accurate so if

00:25:05,060 --> 00:25:21,560
that's an option that is something that

00:25:18,530 --> 00:25:24,670
celery has some helper functions for and

00:25:21,560 --> 00:25:24,670

YouTube URL: https://www.youtube.com/watch?v=yv9xKEN4rXg


