Title: DjangoCon US 2016 - Django and PostgreSQL: An Even-Closer Union by Christophe Pettus
Publication date: 2016-08-11
Playlist: DjangoCon US 2016
Description: 
	DjangoCon US 2016 - Django and PostgreSQL: An Even-Closer Union by Christophe Pettus

Django 1.8 and 1.9 include many very cool PostgreSQL-related features. Let's show them off!

This talk was presented at: https://2016.djangocon.us/schedule/presentation/64/

LINKS:
Follow DjangCon US ğŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ğŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:14,860 --> 00:00:23,930
okay so hi I'm Brooke I'm Christoph

00:00:21,380 --> 00:00:27,080
pedis I'm the CEO PostgreSQL experts Inc

00:00:23,930 --> 00:00:28,759
were in Alameda California you could

00:00:27,080 --> 00:00:31,099
look at the slides will be up in about a

00:00:28,759 --> 00:00:33,170
week at the bill comm and my twitter

00:00:31,099 --> 00:00:37,960
handle is xof I was an early adopter

00:00:33,170 --> 00:00:40,340
and there's my email address okay so

00:00:37,960 --> 00:00:42,500
there's so much stuff here 170

00:00:40,340 --> 00:00:43,910
introduced Native migrations and but

00:00:42,500 --> 00:00:46,430
we're specifically talking about today

00:00:43,910 --> 00:00:49,190
is one 8 + 1 9 extended introduced an

00:00:46,430 --> 00:00:50,300
extended Django Contreras which is

00:00:49,190 --> 00:00:53,210
basically what we're talking about today

00:00:50,300 --> 00:00:54,740
lots of features not much time and but

00:00:53,210 --> 00:00:56,300
we have to thank marked Hamlin who did

00:00:54,740 --> 00:00:58,510
most the work on this and deserves the

00:00:56,300 --> 00:01:02,480
thanks of a grateful nation

00:00:58,510 --> 00:01:04,489
ok the big stuff array field range field

00:01:02,480 --> 00:01:07,220
each store field JSON field we array

00:01:04,489 --> 00:01:10,310
field ok arrays are first-class types in

00:01:07,220 --> 00:01:12,710
PostgreSQL and array field allows you to

00:01:10,310 --> 00:01:14,990
use them directly you can store an array

00:01:12,710 --> 00:01:17,329
as a single field in Postgres that it's

00:01:14,990 --> 00:01:18,619
a very handy feature they map into

00:01:17,329 --> 00:01:19,929
Python lists you probably could have

00:01:18,619 --> 00:01:22,909
guessed that

00:01:19,929 --> 00:01:24,200
remember PostgreSQL arrays are of

00:01:22,909 --> 00:01:27,380
homogeneous type they're good old

00:01:24,200 --> 00:01:28,639
Fortran style arrays so they're integer

00:01:27,380 --> 00:01:29,630
arrays where they're character arrays or

00:01:28,639 --> 00:01:31,999
there's something like that they're not

00:01:29,630 --> 00:01:35,920
you they can't be homogeneous Raji

00:01:31,999 --> 00:01:39,590
Gnaeus the way Python lists could be so

00:01:35,920 --> 00:01:42,200
the and PostgreSQL multi-dimensional

00:01:39,590 --> 00:01:43,639
arrays are rectangular I realize most

00:01:42,200 --> 00:01:45,340
people in the world were not born before

00:01:43,639 --> 00:01:48,889
languages discarded this is a bad idea

00:01:45,340 --> 00:01:50,990
but the multi-dimensional arrays are

00:01:48,889 --> 00:01:54,429
rectangular so it's it's four entries

00:01:50,990 --> 00:01:56,929
wide by three entries high it's a grid

00:01:54,429 --> 00:01:58,849
individual entries can be null though so

00:01:56,929 --> 00:02:02,359
you can kinda do ragged arrays that way

00:01:58,849 --> 00:02:04,490
um when you have a once you have one of

00:02:02,359 --> 00:02:06,889
these you can do queries on them the

00:02:04,490 --> 00:02:08,539
basic one is contains so it matches the

00:02:06,889 --> 00:02:10,300
filled array on the Left contains all of

00:02:08,539 --> 00:02:13,160
the entries of the lists on the right so

00:02:10,300 --> 00:02:15,200
ABC contains a B but did you do you

00:02:13,160 --> 00:02:19,130
probably could have figured that out an

00:02:15,200 --> 00:02:20,540
order is not important on contains you

00:02:19,130 --> 00:02:21,430
have contains by which basically goes

00:02:20,540 --> 00:02:23,659
the other way

00:02:21,430 --> 00:02:24,980
matches the list on the right with all

00:02:23,659 --> 00:02:30,200
the entries on the left

00:02:24,980 --> 00:02:34,090
so the tada tada tada and the order is

00:02:30,200 --> 00:02:37,760
not important here right there overlaps

00:02:34,090 --> 00:02:40,940
works the way you probably expect so ABC

00:02:37,760 --> 00:02:42,349
overlaps a and D but ABC does not

00:02:40,940 --> 00:02:43,750
overlap D because they have no members

00:02:42,349 --> 00:02:46,250
in common

00:02:43,750 --> 00:02:48,230
you also could take the length of it

00:02:46,250 --> 00:02:51,069
which returns the link to the field on

00:02:48,230 --> 00:02:51,069
the left as an integer

00:02:51,160 --> 00:02:56,780
the so you can do queries like this

00:02:54,049 --> 00:02:58,750
where you you're querying for everything

00:02:56,780 --> 00:03:01,579
of length 2 or whatever you might want

00:02:58,750 --> 00:03:02,810
remember that in unless and we'll talk

00:03:01,579 --> 00:03:04,819
about indexing on these things because

00:03:02,810 --> 00:03:07,310
that's where things get really fun you

00:03:04,819 --> 00:03:08,900
if the if you create unless you create

00:03:07,310 --> 00:03:10,519
an expression index you're going to do a

00:03:08,900 --> 00:03:14,090
full table scan so it'll pick up every

00:03:10,519 --> 00:03:16,970
entry and rattle it check its length we

00:03:14,090 --> 00:03:18,349
also have transforms such as I want to

00:03:16,970 --> 00:03:21,849
find everything where there's where the

00:03:18,349 --> 00:03:24,620
first element the zeroth element is a

00:03:21,849 --> 00:03:26,660
the one nice thing about this is if

00:03:24,620 --> 00:03:28,400
there's if it's walking through this and

00:03:26,660 --> 00:03:29,690
you're saying find me the twelfth

00:03:28,400 --> 00:03:31,549
element and there's an array field that

00:03:29,690 --> 00:03:33,200
only has seven elements in it it'll just

00:03:31,549 --> 00:03:35,090
say false it won't return an error so

00:03:33,200 --> 00:03:38,120
you don't have to write fancy trapping

00:03:35,090 --> 00:03:41,450
code for that one downside is unless use

00:03:38,120 --> 00:03:43,519
kwargs you can't specify the index the 0

00:03:41,450 --> 00:03:48,609
in this case programmatically because

00:03:43,519 --> 00:03:48,609
it's baked into the to the the parameter

00:03:49,870 --> 00:03:55,010
you could also just lie suss so if I'd

00:03:52,370 --> 00:03:57,799
me everything for 0 0 entry 0 or 1 match

00:03:55,010 --> 00:03:59,900
that or find everything where 0 or to

00:03:57,799 --> 00:04:02,450
contain this so you can get arbitrarily

00:03:59,900 --> 00:04:04,480
complex expressions and really slow your

00:04:02,450 --> 00:04:07,900
database down

00:04:04,480 --> 00:04:10,060
unless you indexed them yay

00:04:07,900 --> 00:04:12,819
so you just specify DB and x equals true

00:04:10,060 --> 00:04:14,200
and everything's solved right wrong this

00:04:12,819 --> 00:04:16,570
creates a b-tree index which is pretty

00:04:14,200 --> 00:04:20,590
useless on array and other non scalar

00:04:16,570 --> 00:04:22,540
types so Postgres has lots of index

00:04:20,590 --> 00:04:24,250
types most people are only familiar with

00:04:22,540 --> 00:04:26,050
b-tree indexes because if you say DB

00:04:24,250 --> 00:04:29,260
index equals true which everyone does

00:04:26,050 --> 00:04:32,320
too much stop it

00:04:29,260 --> 00:04:35,380
the then what you get is a basic b-tree

00:04:32,320 --> 00:04:36,790
index B trees are nice interestingly

00:04:35,380 --> 00:04:38,889
enough no one actually knows why they're

00:04:36,790 --> 00:04:40,990
called B trees they like balanced or

00:04:38,889 --> 00:04:42,340
Boeing or something like that but

00:04:40,990 --> 00:04:43,660
they're really they're kind of like a

00:04:42,340 --> 00:04:44,800
really good solution to the problem

00:04:43,660 --> 00:04:46,960
they're fast they're compact and they

00:04:44,800 --> 00:04:49,810
provide tool ordering but they're not

00:04:46,960 --> 00:04:51,729
perfect because first of all B tree

00:04:49,810 --> 00:04:54,100
indexes require a totally order type and

00:04:51,729 --> 00:04:56,139
you know a points and raise an H store

00:04:54,100 --> 00:04:58,930
total ordering doesn't make sense I mean

00:04:56,139 --> 00:05:00,190
two points which one's greater than this

00:04:58,930 --> 00:05:03,389
point I mean you can make something up

00:05:00,190 --> 00:05:07,030
but there's no intrinsic meaning to that

00:05:03,389 --> 00:05:09,010
so never feel fail when in doubt post

00:05:07,030 --> 00:05:13,780
Chris has your feature rid waiting for

00:05:09,010 --> 00:05:15,639
you it'll do just engine indexes Jin

00:05:13,780 --> 00:05:17,590
indexes are used for two types of

00:05:15,639 --> 00:05:19,780
contain keys and values like arrays at H

00:05:17,590 --> 00:05:22,300
storage JSON B and just sort for things

00:05:19,780 --> 00:05:23,830
that this is my really big I sounds so

00:05:22,300 --> 00:05:26,380
smart even though I'm the world's worth

00:05:23,830 --> 00:05:28,000
mathematician I'm just an extra do four

00:05:26,380 --> 00:05:30,370
types of partition of mathematical space

00:05:28,000 --> 00:05:33,700
like a point or a range or something

00:05:30,370 --> 00:05:35,380
like that the nice part about them is

00:05:33,700 --> 00:05:37,210
once you create them just like any index

00:05:35,380 --> 00:05:38,919
they just work if it can optimize a

00:05:37,210 --> 00:05:41,250
query of will you don't have to say oh

00:05:38,919 --> 00:05:44,380
by the way on this query use this index

00:05:41,250 --> 00:05:47,470
so indexing array fields generally you

00:05:44,380 --> 00:05:49,750
want a gin index and it accelerates

00:05:47,470 --> 00:05:52,410
contains contained by and overlaps it

00:05:49,750 --> 00:05:55,060
doesn't help with links or size sorry

00:05:52,410 --> 00:05:56,740
but you kind of have to use a raw sequel

00:05:55,060 --> 00:05:59,650
migration who's used more on sequel

00:05:56,740 --> 00:06:02,260
migrations everyone gratuitously put one

00:05:59,650 --> 00:06:04,510
into your next push just to get familiar

00:06:02,260 --> 00:06:09,220
with them you'll love them they've

00:06:04,510 --> 00:06:11,349
always spoken well of you um so you you

00:06:09,220 --> 00:06:14,289
throw in this fancy using gin field

00:06:11,349 --> 00:06:15,390
Clause one downside of gin things is

00:06:14,289 --> 00:06:18,080
they're not free to update

00:06:15,390 --> 00:06:19,819
they're actually updated but in a batch

00:06:18,080 --> 00:06:21,199
you do a vacuum and if that makes no

00:06:19,819 --> 00:06:24,590
sense at all to you just ask me up the

00:06:21,199 --> 00:06:26,689
booth about that so don't create one

00:06:24,590 --> 00:06:28,219
unless you need it specifically if it's

00:06:26,689 --> 00:06:29,960
a small table like an easy little

00:06:28,219 --> 00:06:31,490
mapping table the whole thing's gonna be

00:06:29,960 --> 00:06:36,770
in memory so don't don't do this but if

00:06:31,490 --> 00:06:39,349
it's a big table do that so you say well

00:06:36,770 --> 00:06:41,210
I was promised by an earlier slide that

00:06:39,349 --> 00:06:43,490
you would show me how to accelerate the

00:06:41,210 --> 00:06:44,599
search on the length field that's how

00:06:43,490 --> 00:06:46,430
you accelerate the search on the length

00:06:44,599 --> 00:06:49,280
field what you're doing there is saying

00:06:46,430 --> 00:06:51,710
I want to create a index on the

00:06:49,280 --> 00:06:54,259
expression array length field comma 1

00:06:51,710 --> 00:06:55,909
the comma 1 is the dimension so you're

00:06:54,259 --> 00:06:56,210
saying on the first dimension of this

00:06:55,909 --> 00:07:01,550
table

00:06:56,210 --> 00:07:03,289
remember Fortran it's back so and you

00:07:01,550 --> 00:07:05,030
can index light you can also do slices

00:07:03,289 --> 00:07:06,919
if for example this is something you do

00:07:05,030 --> 00:07:09,560
a lot you can create one of these

00:07:06,919 --> 00:07:11,900
posters is really smart and when you use

00:07:09,560 --> 00:07:16,069
this expression in a query it'll just

00:07:11,900 --> 00:07:17,810
find that index and use it just remember

00:07:16,069 --> 00:07:19,400
also post groceries are one base not

00:07:17,810 --> 00:07:21,500
zero base like every other programming

00:07:19,400 --> 00:07:23,990
language you know since well you know

00:07:21,500 --> 00:07:27,469
posters from the 90s it was different

00:07:23,990 --> 00:07:29,479
then so why would you use a ray field

00:07:27,469 --> 00:07:31,219
well if the underlying data actually is

00:07:29,479 --> 00:07:33,650
an array sometimes you want to put

00:07:31,219 --> 00:07:35,569
arrays in the database um they can be a

00:07:33,650 --> 00:07:37,190
replacement for a mini two mini table if

00:07:35,569 --> 00:07:39,020
you want we can chat about later about

00:07:37,190 --> 00:07:42,169
how that um you know Holloway track

00:07:39,020 --> 00:07:44,150
about how you might do that um you can

00:07:42,169 --> 00:07:45,469
also and this is very common use them as

00:07:44,150 --> 00:07:47,210
a denormalization if you have a really

00:07:45,469 --> 00:07:49,729
expensive query and you want to stuff

00:07:47,210 --> 00:07:51,729
that result in the database and the

00:07:49,729 --> 00:07:55,190
results of it happens to be an array

00:07:51,729 --> 00:07:57,259
okay range fields range fields just are

00:07:55,190 --> 00:08:01,550
wonderful they've native range types

00:07:57,259 --> 00:08:03,259
they specify are about a they span a

00:08:01,550 --> 00:08:06,710
range of a scalar type I can read my own

00:08:03,259 --> 00:08:09,319
slides for example 1 comma 8 is an in

00:08:06,710 --> 00:08:11,690
for range that includes 1 through 8 the

00:08:09,319 --> 00:08:15,650
the brackets the square brackets mean

00:08:11,690 --> 00:08:17,539
inclusive you can also do parens which

00:08:15,650 --> 00:08:19,370
are exclusive which means it only goes

00:08:17,539 --> 00:08:21,949
up through 7 that's really handy if it's

00:08:19,370 --> 00:08:27,279
like a float because or some infinitely

00:08:21,949 --> 00:08:27,279
divisible type and that's the default

00:08:27,310 --> 00:08:31,550
you can omit a bound to mean all values

00:08:30,020 --> 00:08:34,010
greater than or less than so

00:08:31,550 --> 00:08:35,510
dates also have a special infinity value

00:08:34,010 --> 00:08:37,279
which psycho PG does everything it can

00:08:35,510 --> 00:08:39,050
to handle in a nice way

00:08:37,279 --> 00:08:41,750
given the there's kind of this impedance

00:08:39,050 --> 00:08:46,310
mismatch between post Chris daytime and

00:08:41,750 --> 00:08:47,480
Python daytime psycho PG two which is

00:08:46,310 --> 00:08:49,850
the interface library if you're not

00:08:47,480 --> 00:08:51,290
familiar with it includes a Python range

00:08:49,850 --> 00:08:53,060
based type that handles all of that

00:08:51,290 --> 00:08:54,410
stuff for you so you probably when

00:08:53,060 --> 00:08:56,690
you're using it inside your application

00:08:54,410 --> 00:08:59,630
code you want to import that and use

00:08:56,690 --> 00:09:02,839
that as your actual application type I'm

00:08:59,630 --> 00:09:05,209
honey and this one nine support integer

00:09:02,839 --> 00:09:09,110
range and big integer range float range

00:09:05,209 --> 00:09:10,880
date/time range and date range um you

00:09:09,110 --> 00:09:11,870
can do contains contain by and overlaps

00:09:10,880 --> 00:09:14,510
they work pretty much the way you'd

00:09:11,870 --> 00:09:15,589
expect you can also do fully less than

00:09:14,510 --> 00:09:17,209
fully greater than so if they're

00:09:15,589 --> 00:09:20,690
completely disjoint one way or the other

00:09:17,209 --> 00:09:22,850
he said gesturing wildly and adjacent to

00:09:20,690 --> 00:09:25,100
is means that they bump up against each

00:09:22,850 --> 00:09:29,839
other exactly there are no values

00:09:25,100 --> 00:09:32,420
missing between them and then not less

00:09:29,839 --> 00:09:35,899
then not greater then can't work the way

00:09:32,420 --> 00:09:38,750
you expect this is where you use a gist

00:09:35,899 --> 00:09:41,300
index it looks just like the genetics

00:09:38,750 --> 00:09:42,740
only who say just instead of gin and

00:09:41,300 --> 00:09:45,829
accelerates everything we've talked

00:09:42,740 --> 00:09:47,089
about woohoo goes really fast and why

00:09:45,829 --> 00:09:49,339
would you use one of these well here's a

00:09:47,089 --> 00:09:50,870
really hard problem and we had no good

00:09:49,339 --> 00:09:53,180
solution for it until we had range types

00:09:50,870 --> 00:09:55,339
so you're writing a booking system

00:09:53,180 --> 00:09:57,079
because you know people do things like

00:09:55,339 --> 00:09:58,399
that and you say don't allow to book

00:09:57,079 --> 00:09:59,630
used to be inserted into the enemies for

00:09:58,399 --> 00:10:01,790
the same room where the dates overlap

00:09:59,630 --> 00:10:03,620
okay you want to constraint that

00:10:01,790 --> 00:10:05,630
prevents that situation from arising at

00:10:03,620 --> 00:10:06,920
a database with traditionally unique

00:10:05,630 --> 00:10:08,870
constraints there's no way of expressing

00:10:06,920 --> 00:10:11,390
that because you're not talking about a

00:10:08,870 --> 00:10:13,850
unique range because the ranges could

00:10:11,390 --> 00:10:14,680
overlap but they're not equal so they

00:10:13,850 --> 00:10:17,779
don't do that

00:10:14,680 --> 00:10:19,010
but post chris has a feature because

00:10:17,779 --> 00:10:20,870
plus chris has always has a feature

00:10:19,010 --> 00:10:22,459
called constraint exclusion that will

00:10:20,870 --> 00:10:24,470
save you

00:10:22,459 --> 00:10:27,050
constraint exclusion is a generalization

00:10:24,470 --> 00:10:29,089
of the idea of unique indexes which

00:10:27,050 --> 00:10:31,550
basically said don't allow to equal

00:10:29,089 --> 00:10:33,260
entries based on this set of comparison

00:10:31,550 --> 00:10:36,649
operators so it's a generalization

00:10:33,260 --> 00:10:38,720
beyond equals if these two things pass

00:10:36,649 --> 00:10:40,540
this comparison operator which could be

00:10:38,720 --> 00:10:42,649
equals or it could be something else

00:10:40,540 --> 00:10:44,900
into the table like those could be

00:10:42,649 --> 00:10:45,800
overlap for example

00:10:44,900 --> 00:10:48,410
now this is starting to sound pretty

00:10:45,800 --> 00:10:50,690
good and you can they can be any index

00:10:48,410 --> 00:10:51,920
supported boolean predicates and they're

00:10:50,690 --> 00:10:55,400
anted to get and they're all added

00:10:51,920 --> 00:10:57,710
together so there's one catch which just

00:10:55,400 --> 00:11:00,350
has to be a single index and range types

00:10:57,710 --> 00:11:02,690
require adjust indexes so the index has

00:11:00,350 --> 00:11:04,220
to be just index but by default the

00:11:02,690 --> 00:11:05,779
simple scalar values like the room

00:11:04,220 --> 00:11:07,820
number which it was probably a character

00:11:05,779 --> 00:11:09,830
field or an integer don't have just

00:11:07,820 --> 00:11:12,100
indexing oh dear I lied to you this

00:11:09,830 --> 00:11:14,300
feature won't work at all well okay

00:11:12,100 --> 00:11:16,339
there's an extension built into post

00:11:14,300 --> 00:11:19,370
Chris called b-tree gist that gives you

00:11:16,339 --> 00:11:21,620
all of those just indexes for simple

00:11:19,370 --> 00:11:22,790
types like editor a character it's a

00:11:21,620 --> 00:11:25,370
post Chris extension it's part of

00:11:22,790 --> 00:11:27,740
contribu can use you can use creative

00:11:25,370 --> 00:11:30,110
the create extension migration to get it

00:11:27,740 --> 00:11:31,160
for you but it ships with post quests so

00:11:30,110 --> 00:11:33,830
you don't have to worry about it not

00:11:31,160 --> 00:11:35,000
being there on any installation and just

00:11:33,830 --> 00:11:37,250
use the create extension migration

00:11:35,000 --> 00:11:40,820
operator and you're done okay so how is

00:11:37,250 --> 00:11:43,310
this look in your model you say I have a

00:11:40,820 --> 00:11:45,290
bookie and it's a character field and

00:11:43,310 --> 00:11:46,790
and and the dates of the booking

00:11:45,290 --> 00:11:48,440
probably all you need to build a

00:11:46,790 --> 00:11:53,209
reservation system right long weekend

00:11:48,440 --> 00:11:54,500
project done and so you run you run a

00:11:53,209 --> 00:11:58,430
migration and that's what it looks like

00:11:54,500 --> 00:12:00,050
you know it has the usual integer

00:11:58,430 --> 00:12:03,050
sequence that we all love so much in

00:12:00,050 --> 00:12:05,630
post in Django the room and the dates

00:12:03,050 --> 00:12:06,529
and a primary key who cares about the

00:12:05,630 --> 00:12:09,200
primary key we're not going to use that

00:12:06,529 --> 00:12:12,440
for this and then you run this really

00:12:09,200 --> 00:12:15,350
exciting looking statement which you are

00:12:12,440 --> 00:12:17,900
adding an exclusion constraint that says

00:12:15,350 --> 00:12:20,089
don't let anything where the room is

00:12:17,900 --> 00:12:23,150
equal and the dates overlap be inserted

00:12:20,089 --> 00:12:25,490
into this database because that is the

00:12:23,150 --> 00:12:30,080
is the Postgres version of the overlap

00:12:25,490 --> 00:12:32,000
operator where you need looking so

00:12:30,080 --> 00:12:34,070
you'll you know people be so impressed

00:12:32,000 --> 00:12:35,930
when you do stuff like this so you

00:12:34,070 --> 00:12:38,480
created this booking and you create a

00:12:35,930 --> 00:12:39,560
date range and you save it say well ok

00:12:38,480 --> 00:12:41,410
it's the first one the database so it

00:12:39,560 --> 00:12:44,060
better about and that better work bawd

00:12:41,410 --> 00:12:45,230
you created another one but those dates

00:12:44,060 --> 00:12:49,070
though to overlap they've checked out

00:12:45,230 --> 00:12:50,540
that the you create another one with the

00:12:49,070 --> 00:12:53,270
exact same time but it's a different

00:12:50,540 --> 00:12:54,980
room so that's fine and now we're gonna

00:12:53,270 --> 00:12:57,079
create a third one back on that room

00:12:54,980 --> 00:12:58,170
except we're check trying to check in

00:12:57,079 --> 00:12:59,910
before that guy is checked out

00:12:58,170 --> 00:13:02,639
then you get the blah blah blah blah

00:12:59,910 --> 00:13:04,920
stacktrace integrity error and it didn't

00:13:02,639 --> 00:13:07,740
let you do that so you could catch that

00:13:04,920 --> 00:13:10,589
and produce an error too or you know

00:13:07,740 --> 00:13:12,149
whatever so why would you use rain

00:13:10,589 --> 00:13:13,589
fields well you probably want to use

00:13:12,149 --> 00:13:16,139
them to represent ranges that's a good

00:13:13,589 --> 00:13:17,730
idea they're more natural than the

00:13:16,139 --> 00:13:20,130
traditional high-low thing that we were

00:13:17,730 --> 00:13:21,720
stuck with before we have them and you

00:13:20,130 --> 00:13:25,079
can do all this kind of cool database

00:13:21,720 --> 00:13:27,480
integrity checking on them so they have

00:13:25,079 --> 00:13:29,089
a CH sore field H or fields are boring

00:13:27,480 --> 00:13:34,079
we're not going to talk about those

00:13:29,089 --> 00:13:36,630
because they have been suckin read about

00:13:34,079 --> 00:13:39,180
them if you want to because we have the

00:13:36,630 --> 00:13:41,639
new hotness which is JSON fields they're

00:13:39,180 --> 00:13:43,709
doing 1/9 and they support arbitrary

00:13:41,639 --> 00:13:46,620
JSON structures and they're stored as

00:13:43,709 --> 00:13:50,310
JSON B because Jade Postgres has two

00:13:46,620 --> 00:13:51,870
different JSON types and it supports the

00:13:50,310 --> 00:13:53,850
usual stuff contains and contains by

00:13:51,870 --> 00:13:55,709
both the Keen eval you have to match has

00:13:53,850 --> 00:13:58,350
ki which fires JSON structures with a

00:13:55,709 --> 00:14:00,959
particular key of has keys finds

00:13:58,350 --> 00:14:03,750
everything that matches a list you know

00:14:00,959 --> 00:14:07,560
all the good stuff and has any keys so

00:14:03,750 --> 00:14:10,140
cool you can do path type queries you

00:14:07,560 --> 00:14:12,899
know you can say find me and I mean the

00:14:10,140 --> 00:14:14,640
data is a JSON field so by me data that

00:14:12,899 --> 00:14:17,640
has an object owner that has a field

00:14:14,640 --> 00:14:20,279
name whose value is Bob okay that's cool

00:14:17,640 --> 00:14:23,490
this is straight out of the docs you can

00:14:20,279 --> 00:14:26,519
use um array indexing if there's a JSON

00:14:23,490 --> 00:14:28,410
if it's a Sun so data owner other pets

00:14:26,519 --> 00:14:30,269
which is an array inside of the JSON

00:14:28,410 --> 00:14:34,380
structure not a post Chris or a JSON

00:14:30,269 --> 00:14:35,699
array number zero s the name fishy there

00:14:34,380 --> 00:14:39,540
remember I said there are two different

00:14:35,699 --> 00:14:41,910
JSON types or JSON a JSON be JSON stores

00:14:39,540 --> 00:14:44,190
the raw text of the JSON whitespace and

00:14:41,910 --> 00:14:46,470
all exactly the way you put it in it is

00:14:44,190 --> 00:14:50,339
in fact just a syntactic wrapper around

00:14:46,470 --> 00:14:51,990
the text type JSON B is a compact

00:14:50,339 --> 00:14:55,380
indexable representation it's like piece

00:14:51,990 --> 00:14:58,769
on only much much better um so why use

00:14:55,380 --> 00:15:00,180
JSON smj zombie JSON is a little faster

00:14:58,769 --> 00:15:02,819
to insert since it doesn't have to point

00:15:00,180 --> 00:15:05,160
to all this parsing fun and there are

00:15:02,819 --> 00:15:09,329
two dubious features that some people

00:15:05,160 --> 00:15:10,570
because JSON um started using in JSON

00:15:09,329 --> 00:15:12,640
which are duplicate

00:15:10,570 --> 00:15:14,920
jakey's at the same level which is not

00:15:12,640 --> 00:15:17,860
supported in the spec and stable object

00:15:14,920 --> 00:15:20,740
key order where the idea being if you

00:15:17,860 --> 00:15:22,930
store a JSON field that has filled a it

00:15:20,740 --> 00:15:24,370
feel B it'll always come out a B there's

00:15:22,930 --> 00:15:29,050
nothing in the spec that requires this

00:15:24,370 --> 00:15:30,820
behavior one thing to use JSON for is if

00:15:29,050 --> 00:15:32,560
you're just logging data and you don't

00:15:30,820 --> 00:15:36,400
really expect to do a lot of querying on

00:15:32,560 --> 00:15:39,820
it it's faster to insert um basically

00:15:36,400 --> 00:15:42,100
everything else you want JSON B and the

00:15:39,820 --> 00:15:43,000
the biggest advantage is JSON B can be

00:15:42,100 --> 00:15:45,250
indexed in useful ways

00:15:43,000 --> 00:15:46,780
unlike JSON and the JSON field type

00:15:45,250 --> 00:15:50,170
gives you JSON B anyway so just roll

00:15:46,780 --> 00:15:51,850
with it index a JSON so we use gen

00:15:50,170 --> 00:15:56,500
indexing remember this is for key value

00:15:51,850 --> 00:15:59,980
pair kind of stuff it supports the head

00:15:56,500 --> 00:16:02,620
the containing the has key has has a

00:15:59,980 --> 00:16:06,300
single key the the path has a single key

00:16:02,620 --> 00:16:09,160
has any keys has all key here you get it

00:16:06,300 --> 00:16:10,780
one thing to remember is right now

00:16:09,160 --> 00:16:12,700
there's no single operator that's in

00:16:10,780 --> 00:16:15,190
Postgres that says find me this JSON

00:16:12,700 --> 00:16:17,020
field that has this key at any level in

00:16:15,190 --> 00:16:18,490
the structure you have to look you have

00:16:17,020 --> 00:16:22,660
to start at the top level and walk your

00:16:18,490 --> 00:16:24,610
way down by anything's you can query

00:16:22,660 --> 00:16:26,440
them but only in paths that are rooted

00:16:24,610 --> 00:16:27,910
at the top level this isn't as big a

00:16:26,440 --> 00:16:30,610
restriction as you might think but it is

00:16:27,910 --> 00:16:32,170
a restriction so why would you say so

00:16:30,610 --> 00:16:35,230
well if you're logging JSON data like

00:16:32,170 --> 00:16:36,520
API calls that's a good reason you can

00:16:35,230 --> 00:16:38,710
use it for an audit table that works

00:16:36,520 --> 00:16:40,690
across schemas this is a big problem in

00:16:38,710 --> 00:16:41,860
relational databases you want an audit

00:16:40,690 --> 00:16:44,590
table that every time you change

00:16:41,860 --> 00:16:46,330
something you spit a record into a table

00:16:44,590 --> 00:16:48,400
that says I change this but that means

00:16:46,330 --> 00:16:51,580
but what schema does that audit table

00:16:48,400 --> 00:16:52,630
have it could might have to that does

00:16:51,580 --> 00:16:54,370
that mean you have to create a separate

00:16:52,630 --> 00:16:57,100
audit table for every table your to the

00:16:54,370 --> 00:16:59,410
database that's pretty gross or these

00:16:57,100 --> 00:17:02,110
but with JSON and you can just turn the

00:16:59,410 --> 00:17:04,750
the record into a JSON blob and store it

00:17:02,110 --> 00:17:07,210
right in it's a it's a friendly readable

00:17:04,750 --> 00:17:09,850
way of pickling JSON objects that isn't

00:17:07,210 --> 00:17:13,990
that doesn't have like infinite security

00:17:09,850 --> 00:17:16,210
problems like CPA Laurie amel and you

00:17:13,990 --> 00:17:17,590
use it for attributes or rare fields for

00:17:16,210 --> 00:17:19,420
example you're building a system and

00:17:17,590 --> 00:17:21,520
you're going to deploy it but your model

00:17:19,420 --> 00:17:22,659
is what it is but you want the user to

00:17:21,520 --> 00:17:24,189
be able to create the

00:17:22,659 --> 00:17:25,209
objects like it's an inventory control

00:17:24,189 --> 00:17:26,739
system and they want to be able to

00:17:25,209 --> 00:17:28,899
create color or size or something like

00:17:26,739 --> 00:17:30,249
that you can store them in JSON so you

00:17:28,899 --> 00:17:34,809
don't have to modify the schema in the

00:17:30,249 --> 00:17:36,460
field and there's other goodies most of

00:17:34,809 --> 00:17:38,499
these things have everything has admin

00:17:36,460 --> 00:17:39,009
widgets that go with it of course the

00:17:38,499 --> 00:17:40,059
age stored

00:17:39,009 --> 00:17:41,200
Jace I would just are kind of really

00:17:40,059 --> 00:17:43,029
going good for debugging because it's

00:17:41,200 --> 00:17:47,889
like gives you this text in there you

00:17:43,029 --> 00:17:50,349
deal with it and there's full text

00:17:47,889 --> 00:17:51,729
search now full text searches a ten to

00:17:50,349 --> 00:17:55,090
one ten features which is in beta

00:17:51,729 --> 00:17:57,190
everyone downloading give it a go it's

00:17:55,090 --> 00:18:00,309
it's poster school has had full text

00:17:57,190 --> 00:18:02,499
search built in for a long time 110

00:18:00,309 --> 00:18:03,970
finally contains model level support for

00:18:02,499 --> 00:18:05,799
it first

00:18:03,970 --> 00:18:07,479
you have to get some concepts down and

00:18:05,799 --> 00:18:09,249
this is a little bit hard to wrap your

00:18:07,479 --> 00:18:11,349
brain around I have to go back to the

00:18:09,249 --> 00:18:13,419
dock sometimes out of this there's this

00:18:11,349 --> 00:18:15,159
thing called the TS vector which is a

00:18:13,419 --> 00:18:17,019
block of text you can think of it like

00:18:15,159 --> 00:18:18,669
the blog entry or the description in a

00:18:17,019 --> 00:18:21,609
catalog or say like that big ol block of

00:18:18,669 --> 00:18:23,109
text encoded for full text search so

00:18:21,609 --> 00:18:25,769
transformations have been done on it to

00:18:23,109 --> 00:18:27,820
normalize it strip all the the

00:18:25,769 --> 00:18:30,190
uninteresting extensions out remove the

00:18:27,820 --> 00:18:33,129
stop or it's all that stuff it's a built

00:18:30,190 --> 00:18:34,450
in post Chris type doing that

00:18:33,129 --> 00:18:36,549
transformation requires this thing

00:18:34,450 --> 00:18:37,809
called a configuration which I am NOT

00:18:36,549 --> 00:18:42,029
going to go into because we could have

00:18:37,809 --> 00:18:45,849
been the entire time so and I write out

00:18:42,029 --> 00:18:49,029
okay I'm gonna plow through because I

00:18:45,849 --> 00:18:50,649
want to get through this so you know

00:18:49,029 --> 00:18:53,080
post Chris has a bunch of configurations

00:18:50,649 --> 00:18:55,690
generally just use those like English as

00:18:53,080 --> 00:18:57,309
the standard one just use it to TS

00:18:55,690 --> 00:18:59,440
vector is a function builds it to

00:18:57,309 --> 00:19:02,049
Postgres that takes texture returns a TX

00:18:59,440 --> 00:19:03,399
vector like that fortunately you don't

00:19:02,049 --> 00:19:04,659
have to worry too much about this Django

00:19:03,399 --> 00:19:07,419
calls this under the hood for most

00:19:04,659 --> 00:19:10,299
situations and then you have a search

00:19:07,419 --> 00:19:11,799
functionality so you can search a text

00:19:10,299 --> 00:19:13,090
field using full text searching using

00:19:11,799 --> 00:19:15,789
the underscore underscore a search

00:19:13,090 --> 00:19:17,729
predicate in a query set without indexes

00:19:15,789 --> 00:19:22,330
it does a sequential scan which is bad

00:19:17,729 --> 00:19:24,399
so you don't want to do that you can

00:19:22,330 --> 00:19:26,820
there's a TS effect a search vector

00:19:24,399 --> 00:19:29,320
object at the top level in Django that

00:19:26,820 --> 00:19:30,639
represents a TS vector unless you search

00:19:29,320 --> 00:19:33,070
more than one field of time by combining

00:19:30,639 --> 00:19:33,580
them merging searching happens the query

00:19:33,070 --> 00:19:35,980
runs

00:19:33,580 --> 00:19:38,140
search query represents a query out

00:19:35,980 --> 00:19:40,120
tres does the stemming and things like

00:19:38,140 --> 00:19:44,020
that so you can use searches like that

00:19:40,120 --> 00:19:45,820
cool you hit a certain PostgreSQL also

00:19:44,020 --> 00:19:48,179
has rankings so you can sort things in

00:19:45,820 --> 00:19:50,350
relevancy order and blah blah blah

00:19:48,179 --> 00:19:53,350
there's lots more these slides will be

00:19:50,350 --> 00:19:55,450
online the important the important thing

00:19:53,350 --> 00:19:57,760
to remember is you need an index which

00:19:55,450 --> 00:20:00,820
is a Djinn index in order to make this

00:19:57,760 --> 00:20:02,860
work fast you can combine multiple

00:20:00,820 --> 00:20:05,049
fields with different weights and all

00:20:02,860 --> 00:20:06,549
this kind of stuff generally you need to

00:20:05,049 --> 00:20:08,500
use a trigger to do that kind of stuff

00:20:06,549 --> 00:20:09,250
there's examples in the documentation on

00:20:08,500 --> 00:20:12,429
how to do that

00:20:09,250 --> 00:20:13,720
and there's three things which you can

00:20:12,429 --> 00:20:18,120
read about in the docs which were

00:20:13,720 --> 00:20:18,120
relatively small features questions know

00:20:24,630 --> 00:20:30,860
and if you didn't understand any of that

00:20:27,030 --> 00:20:30,860

YouTube URL: https://www.youtube.com/watch?v=xGkH2yoy2MY


