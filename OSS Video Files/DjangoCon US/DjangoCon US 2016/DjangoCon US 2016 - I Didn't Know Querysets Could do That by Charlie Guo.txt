Title: DjangoCon US 2016 - I Didn't Know Querysets Could do That by Charlie Guo
Publication date: 2016-08-24
Playlist: DjangoCon US 2016
Description: 
	I Didn't Know Querysets Could do That by Charlie Guo

QuerySets and object Managers are a core part of Django, and can be extremely powerful. But I didn't always know about some of their more advanced capabilities.

BASIC METHODS

You have likely used filter(), exclude(), and order_by(). You've even probably used an aggregation method like Sum() or Count(). Less common, however, are query(), only()/defer(), and select_related().

F EXPRESSIONS / Q OBJECTS

For some more complex queries, those basic functions and filters won't cut it. How do you construct a query that needs to check for field A or field B? What do you do if you need to multiply two fields together and then sum them? Look no further than F() and Q().

RAW SQL / THE EXTRA() METHOD

As a last resort, it's entirely possible to use raw SQL queries to get the database results that you need. The sky's the limit, but there are definitely downsides to this approach; pitfalls include SQL injections and database backend portability issues.

MANAGERS

A talk on QuerySets would be incomplete without mentioning Managers, and how to leverage Manager customization to make your life easier. Writing methods on existing Managers, and creating custom ones can go a long way towards being DRY and reducing the potential for errors.

This talk was presented at: https://2016.djangocon.us/schedule/presentation/43/

LINKS:
Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:02,000 --> 00:00:04,950
[Music]

00:00:03,410 --> 00:00:09,000
[Applause]

00:00:04,950 --> 00:00:09,000
[Music]

00:00:14,090 --> 00:00:19,530
hey everybody thanks for coming I didn't

00:00:18,240 --> 00:00:22,140
know query sets could do that is

00:00:19,530 --> 00:00:24,480
something that I've thought or said to

00:00:22,140 --> 00:00:26,369
myself a number of times over the last

00:00:24,480 --> 00:00:28,560
few years while learning the ins and

00:00:26,369 --> 00:00:30,150
outs of Django and I was hoping to share

00:00:28,560 --> 00:00:34,650
some of those moments with you guys

00:00:30,150 --> 00:00:36,300
today but first you know why is this

00:00:34,650 --> 00:00:38,970
important why should you care about the

00:00:36,300 --> 00:00:41,160
words coming out of my mouth if you're a

00:00:38,970 --> 00:00:43,440
devout reader of the documentation than

00:00:41,160 --> 00:00:46,199
to be honest this talk might not be that

00:00:43,440 --> 00:00:48,540
interesting for you but if you're more

00:00:46,199 --> 00:00:50,730
like me in that you read just enough of

00:00:48,540 --> 00:00:52,979
the documentation and/or Stack Overflow

00:00:50,730 --> 00:00:54,600
in order to solve the problem you're

00:00:52,979 --> 00:00:56,760
currently facing and then you put it

00:00:54,600 --> 00:00:58,860
back down then it might be worth a

00:00:56,760 --> 00:01:00,059
listen like a lot of the stuff that a

00:00:58,860 --> 00:01:01,920
lot of these solutions that I've

00:01:00,059 --> 00:01:03,360
encountered I've only encountered them

00:01:01,920 --> 00:01:06,630
because they were relevant to what I was

00:01:03,360 --> 00:01:08,310
working on and simply knowing that I

00:01:06,630 --> 00:01:10,049
could have done something in native

00:01:08,310 --> 00:01:12,120
Django would have gone a long way

00:01:10,049 --> 00:01:15,270
towards figuring out how to do it in

00:01:12,120 --> 00:01:17,159
native tango and even if you're fairly

00:01:15,270 --> 00:01:18,780
advanced a lot of these concepts have

00:01:17,159 --> 00:01:21,149
only been fleshed out in the last few

00:01:18,780 --> 00:01:23,250
versions I know for a fact that at least

00:01:21,149 --> 00:01:25,680
a couple of these examples could not

00:01:23,250 --> 00:01:27,600
have been done before 1.8 because in

00:01:25,680 --> 00:01:30,000
order to do them I was hacking around

00:01:27,600 --> 00:01:31,619
private internal functions I want to

00:01:30,000 --> 00:01:33,539
offer practical examples in the hopes

00:01:31,619 --> 00:01:36,719
that you can use them towards your own

00:01:33,539 --> 00:01:39,600
code and achieve if not best practices

00:01:36,719 --> 00:01:42,869
at least better practices then all

00:01:39,600 --> 00:01:44,729
haven't been said let's dive in just as

00:01:42,869 --> 00:01:46,979
a sanity check for everybody query sets

00:01:44,729 --> 00:01:49,710
are the things that are returned when

00:01:46,979 --> 00:01:51,810
you do a model query in tango right so

00:01:49,710 --> 00:01:55,170
every time you say article or user dot

00:01:51,810 --> 00:01:57,649
objects at all or article objects not

00:01:55,170 --> 00:01:59,820
filter you're working with query sense

00:01:57,649 --> 00:02:01,799
later on in the talk I'm going to run

00:01:59,820 --> 00:02:04,289
through some examples of lesser-known

00:02:01,799 --> 00:02:06,659
query set behavior and those revolve

00:02:04,289 --> 00:02:09,750
around a pretty basic ecommerce app

00:02:06,659 --> 00:02:11,190
right everybody likes making money just

00:02:09,750 --> 00:02:12,750
to be on the same page I'm going to take

00:02:11,190 --> 00:02:14,430
a look at some of the rough model

00:02:12,750 --> 00:02:17,880
references that we're going to be using

00:02:14,430 --> 00:02:21,690
we've got products with names prices and

00:02:17,880 --> 00:02:24,540
sellers orders right and each order has

00:02:21,690 --> 00:02:27,590
many items so each item has two foreign

00:02:24,540 --> 00:02:31,530
keys a quantity and a float unit

00:02:27,590 --> 00:02:33,930
hopefully that'll make sense now if

00:02:31,530 --> 00:02:35,790
you've done a django app that's even

00:02:33,930 --> 00:02:38,310
slightly more complex than a duelist

00:02:35,790 --> 00:02:40,260
you've probably run into some of these

00:02:38,310 --> 00:02:43,110
methods right the ones on the Left

00:02:40,260 --> 00:02:44,670
returned query sets meaning that you can

00:02:43,110 --> 00:02:47,670
chain them you can filter and then

00:02:44,670 --> 00:02:49,709
exclude and then reverse write the ones

00:02:47,670 --> 00:02:51,660
on the right return something else that

00:02:49,709 --> 00:02:53,310
could be a model instance that could be

00:02:51,660 --> 00:02:56,519
a boolean value that could be a

00:02:53,310 --> 00:02:58,830
dictionary full of stuff I don't want to

00:02:56,519 --> 00:03:00,690
spend too much time here but there are a

00:02:58,830 --> 00:03:04,560
couple of things I want to point out

00:03:00,690 --> 00:03:06,930
about annotate and aggregate write they

00:03:04,560 --> 00:03:09,120
are somewhat similar they both accept an

00:03:06,930 --> 00:03:12,630
expression here we're using the count

00:03:09,120 --> 00:03:14,670
and some classes to define the

00:03:12,630 --> 00:03:16,290
expression that we want to compute but

00:03:14,670 --> 00:03:18,510
annotate will compute that expression

00:03:16,290 --> 00:03:21,260
for each item in the set right and it

00:03:18,510 --> 00:03:24,120
returns each item with a new property

00:03:21,260 --> 00:03:26,280
storing the result whereas aggregate

00:03:24,120 --> 00:03:28,110
will compute the expression across all

00:03:26,280 --> 00:03:31,590
of the items in the set and it returns a

00:03:28,110 --> 00:03:35,459
dictionary with the final value you know

00:03:31,590 --> 00:03:36,660
with annotate you can add some new value

00:03:35,459 --> 00:03:39,239
and they use later on in the filter

00:03:36,660 --> 00:03:41,069
expression if you provide a keyword

00:03:39,239 --> 00:03:43,230
argument then that becomes the name of

00:03:41,069 --> 00:03:45,269
the property or dictionary key but if

00:03:43,230 --> 00:03:47,700
you don't provide one Django will

00:03:45,269 --> 00:03:50,220
automatically generate one by using the

00:03:47,700 --> 00:03:53,069
name of the field double underscores and

00:03:50,220 --> 00:03:54,840
then the name of the function right kind

00:03:53,069 --> 00:03:58,160
of a subtle point to note is that

00:03:54,840 --> 00:04:00,840
actually in the top example we are

00:03:58,160 --> 00:04:02,459
counting all of the items despite the

00:04:00,840 --> 00:04:04,920
fact that the product class if you

00:04:02,459 --> 00:04:06,959
recall didn't have an explicit foreign

00:04:04,920 --> 00:04:08,630
key for an item on it right which means

00:04:06,959 --> 00:04:10,620
that here Django is implicitly

00:04:08,630 --> 00:04:12,329
traversing the reverse relationship

00:04:10,620 --> 00:04:14,010
counting up all of the items and then

00:04:12,329 --> 00:04:17,420
adding that as a field on our final

00:04:14,010 --> 00:04:17,420
query set of product

00:04:17,440 --> 00:04:22,330
and of course if you aren't using these

00:04:20,200 --> 00:04:23,470
functions to count stuff to some stuff

00:04:22,330 --> 00:04:25,660
to average stuff

00:04:23,470 --> 00:04:27,940
you absolutely should it varies a little

00:04:25,660 --> 00:04:29,890
bit based on your underlying database

00:04:27,940 --> 00:04:32,170
management system but they tend to be

00:04:29,890 --> 00:04:34,960
significantly faster than riding a four

00:04:32,170 --> 00:04:39,370
loop by hand or using even pythons built

00:04:34,960 --> 00:04:40,780
in some function o so beyond those more

00:04:39,370 --> 00:04:43,660
common ones there are some lesser-known

00:04:40,780 --> 00:04:47,140
queries set method right these generally

00:04:43,660 --> 00:04:49,030
revolve around optimizations or you know

00:04:47,140 --> 00:04:52,690
interacting with the underlying database

00:04:49,030 --> 00:04:55,870
table structure you may or may not know

00:04:52,690 --> 00:04:56,650
that when you access a foreign key on an

00:04:55,870 --> 00:04:58,750
object

00:04:56,650 --> 00:05:01,030
Django goes back to the database there's

00:04:58,750 --> 00:05:03,250
an extra query in order to populate the

00:05:01,030 --> 00:05:06,520
foreign keys information right so when

00:05:03,250 --> 00:05:08,380
we print the seller ID and I product it

00:05:06,520 --> 00:05:12,250
takes not one but two queries in order

00:05:08,380 --> 00:05:13,840
to execute that print statement but and

00:05:12,250 --> 00:05:16,180
I should note the same thing happens you

00:05:13,840 --> 00:05:18,100
know with mates many and many to one

00:05:16,180 --> 00:05:22,180
reverse relationship right not just for

00:05:18,100 --> 00:05:25,390
anything but we can use select related

00:05:22,180 --> 00:05:27,220
to compress that down to one right

00:05:25,390 --> 00:05:29,920
select related takes in a list of

00:05:27,220 --> 00:05:32,440
arguments that it will go ahead and join

00:05:29,920 --> 00:05:35,650
in the underlying sequel allowing you to

00:05:32,440 --> 00:05:38,410
save time later when accessing it the

00:05:35,650 --> 00:05:40,570
big limitation of select related is that

00:05:38,410 --> 00:05:42,220
it it's limited to foreign keys because

00:05:40,570 --> 00:05:44,860
it's doing sort of the joining they're

00:05:42,220 --> 00:05:47,620
lying sequel but it is very similar to

00:05:44,860 --> 00:05:49,540
prefetch related right which allows you

00:05:47,620 --> 00:05:51,550
to do the same thing with reverse

00:05:49,540 --> 00:05:53,950
lookups and many many fields right

00:05:51,550 --> 00:05:55,419
prefetch rather than doing it all in the

00:05:53,950 --> 00:05:58,240
sequel it will do the joining in Python

00:05:55,419 --> 00:06:00,460
but you get to do it upfront once rather

00:05:58,240 --> 00:06:04,150
than many times ad hoc like you might do

00:06:00,460 --> 00:06:05,919
when rendering a template but what if

00:06:04,150 --> 00:06:07,900
you have the opposite problem right what

00:06:05,919 --> 00:06:11,500
if you don't want more information from

00:06:07,900 --> 00:06:12,910
the database but let this could be for

00:06:11,500 --> 00:06:15,160
example because you have a model with

00:06:12,910 --> 00:06:18,370
hundreds of fields on it and you only

00:06:15,160 --> 00:06:20,740
need to access one or two then you can

00:06:18,370 --> 00:06:23,200
use only which as the name implies will

00:06:20,740 --> 00:06:24,910
only fetch the explicitly listed fields

00:06:23,200 --> 00:06:26,669
if you know which ones you're gonna need

00:06:24,910 --> 00:06:29,620
you can optimize your lookups by

00:06:26,669 --> 00:06:31,180
grabbing those obviously though if you

00:06:29,620 --> 00:06:34,800
access other fields outside of them

00:06:31,180 --> 00:06:37,270
that you asked for you kind of lose the

00:06:34,800 --> 00:06:39,100
performance benefit because you have to

00:06:37,270 --> 00:06:42,150
go back to the database anyway

00:06:39,100 --> 00:06:44,320
defer is the other side of this coin if

00:06:42,150 --> 00:06:47,470
retreats all of the fields on a model

00:06:44,320 --> 00:06:49,690
except for the given ones you might want

00:06:47,470 --> 00:06:52,300
to do this because you have a field type

00:06:49,690 --> 00:06:54,820
that's particularly expensive to convert

00:06:52,300 --> 00:06:56,830
to native Python maybe it's some

00:06:54,820 --> 00:06:59,350
geospatial data maybe it's something

00:06:56,830 --> 00:07:03,330
more custom than that and so defer lets

00:06:59,350 --> 00:07:05,470
you punt on having to do that processing

00:07:03,330 --> 00:07:07,300
the last one of these methods I want to

00:07:05,470 --> 00:07:09,009
touch on is in bulk mostly because I

00:07:07,300 --> 00:07:12,070
recently discovered it and I think it's

00:07:09,009 --> 00:07:14,410
super cool you pass it a list of IDs and

00:07:12,070 --> 00:07:18,970
it returns a dictionary mapping each ID

00:07:14,410 --> 00:07:20,199
to the Associated model register to me

00:07:18,970 --> 00:07:21,910
this is interesting because there's a

00:07:20,199 --> 00:07:24,400
type of query that I run into a lot

00:07:21,910 --> 00:07:27,070
right suppose you want to get all of the

00:07:24,400 --> 00:07:29,560
products ordered in a given month you'd

00:07:27,070 --> 00:07:32,080
probably start by filtering for all of

00:07:29,560 --> 00:07:33,789
the items ordered Thank You Ven one you

00:07:32,080 --> 00:07:35,770
would use values lists right but he

00:07:33,789 --> 00:07:38,169
comes true and distinct in order to

00:07:35,770 --> 00:07:40,330
distill that down to a list of product

00:07:38,169 --> 00:07:42,639
IDs and then you can pass those two in

00:07:40,330 --> 00:07:44,620
bulk in order to just rapidly generate a

00:07:42,639 --> 00:07:46,150
mapping between the two the other way

00:07:44,620 --> 00:07:49,000
I've done this is using filter right you

00:07:46,150 --> 00:07:51,550
can say filter product ID in list it

00:07:49,000 --> 00:07:52,780
also works as far as I know these are

00:07:51,550 --> 00:07:55,419
kind of the cleanest ways to do this

00:07:52,780 --> 00:07:57,310
lookup but if anybody knows a better way

00:07:55,419 --> 00:07:58,150
to do it please come talk to me after

00:07:57,310 --> 00:07:59,560
the talk

00:07:58,150 --> 00:08:01,030
for whatever reason I end up writing

00:07:59,560 --> 00:08:06,669
this style of theory a lot and I would

00:08:01,030 --> 00:08:08,500
love to reduce my lines without now an

00:08:06,669 --> 00:08:10,210
interesting thing about the filter and

00:08:08,500 --> 00:08:13,449
exclude methods that we saw earlier is

00:08:10,210 --> 00:08:15,729
that when the underlying sequel is

00:08:13,449 --> 00:08:19,630
generated it's always generated using

00:08:15,729 --> 00:08:23,080
and right so if we look at this example

00:08:19,630 --> 00:08:24,820
the resulting sequel is that we select

00:08:23,080 --> 00:08:28,479
all of the orders where the status is

00:08:24,820 --> 00:08:31,060
ship and it was ordered yesterday that

00:08:28,479 --> 00:08:32,529
begs the question what happens if I want

00:08:31,060 --> 00:08:34,659
to get all of the orders where the

00:08:32,529 --> 00:08:37,329
status is shipped or it was ordered

00:08:34,659 --> 00:08:38,740
yesterday right to answer that question

00:08:37,329 --> 00:08:42,120
I want to look at not searching orders

00:08:38,740 --> 00:08:42,120
but searching users

00:08:43,820 --> 00:08:50,400
suppose your customer support team right

00:08:46,680 --> 00:08:52,410
says we really want a flexible search

00:08:50,400 --> 00:08:55,380
view where we can just type in a keyword

00:08:52,410 --> 00:08:57,450
term and it will return all of the users

00:08:55,380 --> 00:09:00,090
you know across first name last name

00:08:57,450 --> 00:09:02,430
email and we can use them for our

00:09:00,090 --> 00:09:05,820
tickets right the brute force solution

00:09:02,430 --> 00:09:07,950
is to write three queries you know first

00:09:05,820 --> 00:09:11,060
name last name email convert them to

00:09:07,950 --> 00:09:14,220
lists and then concatenate them together

00:09:11,060 --> 00:09:19,590
and this solution while it does work is

00:09:14,220 --> 00:09:21,750
not the most efficient you're hitting

00:09:19,590 --> 00:09:24,150
the database not once but price once for

00:09:21,750 --> 00:09:26,070
each field and then you are spending

00:09:24,150 --> 00:09:28,530
time not just converting each of those

00:09:26,070 --> 00:09:31,170
query sets to lists but then putting

00:09:28,530 --> 00:09:33,030
those lists all together and the last

00:09:31,170 --> 00:09:35,160
thing you know your final object type is

00:09:33,030 --> 00:09:37,640
a list not a query set which means that

00:09:35,160 --> 00:09:40,560
you can't filter on it further you can't

00:09:37,640 --> 00:09:43,080
order it and can't remove duplicates

00:09:40,560 --> 00:09:45,840
easily and this starts to break down

00:09:43,080 --> 00:09:47,700
pretty quickly right requests will start

00:09:45,840 --> 00:09:49,650
coming out without you know too many

00:09:47,700 --> 00:09:50,910
results that you're trying to return and

00:09:49,650 --> 00:09:52,590
like I said you get extra constraints

00:09:50,910 --> 00:09:59,510
that just adds to the response time even

00:09:52,590 --> 00:10:02,220
more but fortunately we have q and q are

00:09:59,510 --> 00:10:04,410
these great objects they encapsulate

00:10:02,220 --> 00:10:06,810
query constraints right and you can

00:10:04,410 --> 00:10:09,990
combine them with various operators like

00:10:06,810 --> 00:10:12,360
and or and not right and so we were to

00:10:09,990 --> 00:10:15,120
rewrite that previous query we would do

00:10:12,360 --> 00:10:16,980
it by combining creating three Q objects

00:10:15,120 --> 00:10:18,930
right one for each of our fields one for

00:10:16,980 --> 00:10:21,350
each for our constraint and then joining

00:10:18,930 --> 00:10:24,900
them with a bitwise or operator right

00:10:21,350 --> 00:10:26,250
and you can see what the so you know we

00:10:24,900 --> 00:10:28,080
get a query set we can order by last

00:10:26,250 --> 00:10:30,600
name we can you know ask for distinct

00:10:28,080 --> 00:10:36,360
and best of all it all reduces down to a

00:10:30,600 --> 00:10:38,340
single ooh theoretically you can create

00:10:36,360 --> 00:10:40,380
as complex of Q expressions as you want

00:10:38,340 --> 00:10:42,480
as long as they can be combined with

00:10:40,380 --> 00:10:48,029
bitwise ORS and

00:10:42,480 --> 00:10:50,010
not I suppose sales comes to you and

00:10:48,029 --> 00:10:51,690
they say we really want you to build us

00:10:50,010 --> 00:10:54,420
some dashboards right we need to track

00:10:51,690 --> 00:10:56,760
our metrics our kpi's so you decide to

00:10:54,420 --> 00:10:59,310
write a function called item total that

00:10:56,760 --> 00:11:00,959
takes in a set of line items and returns

00:10:59,310 --> 00:11:02,490
the total right at first you might be

00:11:00,959 --> 00:11:04,320
saying Oh totally know how to do this

00:11:02,490 --> 00:11:06,810
easy peasy

00:11:04,320 --> 00:11:09,209
let's just use a some aggregate across

00:11:06,810 --> 00:11:11,269
our query set right and then get the

00:11:09,209 --> 00:11:14,579
value out of the results in dictionary

00:11:11,269 --> 00:11:20,910
but let's recall for a second how we

00:11:14,579 --> 00:11:24,000
define the above approach totally works

00:11:20,910 --> 00:11:27,240
if we had a total price field rather

00:11:24,000 --> 00:11:29,089
than a unit price but because we

00:11:27,240 --> 00:11:31,649
structured it this way we are not taking

00:11:29,089 --> 00:11:34,320
the quantity into account for each part

00:11:31,649 --> 00:11:36,089
line item it might be tempting to just

00:11:34,320 --> 00:11:38,550
say screw it you know we'll write a

00:11:36,089 --> 00:11:40,769
total price method and then we'll use a

00:11:38,550 --> 00:11:43,620
list comprehension to sum to get that

00:11:40,769 --> 00:11:45,899
total and this works right really works

00:11:43,620 --> 00:11:48,209
but if we're taking our own advice about

00:11:45,899 --> 00:11:51,170
using annotate and aggragate where

00:11:48,209 --> 00:11:54,720
possible we can do better

00:11:51,170 --> 00:11:56,670
that's where F comes in while Q

00:11:54,720 --> 00:11:58,980
represented a query constraint F

00:11:56,670 --> 00:12:01,800
represents an implicit reference on a

00:11:58,980 --> 00:12:02,670
model field in database call if that if

00:12:01,800 --> 00:12:04,860
you don't know what that means that's

00:12:02,670 --> 00:12:06,540
fine it took me forever to understand

00:12:04,860 --> 00:12:10,579
what that means but let's look at it

00:12:06,540 --> 00:12:16,010
completely alright for this example

00:12:10,579 --> 00:12:18,300
we're rewriting that product and sum as

00:12:16,010 --> 00:12:19,980
expression right but rather than saying

00:12:18,300 --> 00:12:21,920
so for example if we did it with a for

00:12:19,980 --> 00:12:25,350
loop we would say for item in items

00:12:21,920 --> 00:12:28,050
items sum plus equals item dot unit

00:12:25,350 --> 00:12:30,449
price bus item got minus 4 times out

00:12:28,050 --> 00:12:34,019
impact line but we can rewrite that

00:12:30,449 --> 00:12:36,449
using a some class and using F in order

00:12:34,019 --> 00:12:38,490
to implicitly create this expression and

00:12:36,449 --> 00:12:40,769
without having to access any individual

00:12:38,490 --> 00:12:42,200
item instances compute the aggregate

00:12:40,769 --> 00:12:48,890
cell

00:12:42,200 --> 00:12:50,720
hopefully that makes sense and let's get

00:12:48,890 --> 00:12:52,280
one more F example you know this time

00:12:50,720 --> 00:12:55,160
just to really illustrate that that's

00:12:52,280 --> 00:12:57,380
self referential I expect suppose now

00:12:55,160 --> 00:12:59,900
your manager says you know Charlie sales

00:12:57,380 --> 00:13:01,730
are up everything's great but I want you

00:12:59,900 --> 00:13:04,100
to add a field to our product so that we

00:13:01,730 --> 00:13:06,770
can keep track of how many times each

00:13:04,100 --> 00:13:08,660
one has been purchased right and at

00:13:06,770 --> 00:13:09,290
first you're like that's dumb why would

00:13:08,660 --> 00:13:11,360
you do that

00:13:09,290 --> 00:13:14,030
but it's your boss so you have to do it

00:13:11,360 --> 00:13:15,890
anyway and the for-loop to do it right

00:13:14,030 --> 00:13:17,930
is extremely simple it's be honest we

00:13:15,890 --> 00:13:20,900
can't really do much better than this in

00:13:17,930 --> 00:13:26,380
terms of performance but while we can't

00:13:20,900 --> 00:13:29,300
save much time we can save space and

00:13:26,380 --> 00:13:30,710
using F in this case can actually avoid

00:13:29,300 --> 00:13:32,000
a race condition all right so what's

00:13:30,710 --> 00:13:34,310
happening is we're using the update

00:13:32,000 --> 00:13:36,320
method on a query set to update all of

00:13:34,310 --> 00:13:38,840
the values at once and then we're using

00:13:36,320 --> 00:13:41,150
apps to implicitly refer to the

00:13:38,840 --> 00:13:42,860
purchases field on each of the products

00:13:41,150 --> 00:13:44,990
incrementing it by one for putting it

00:13:42,860 --> 00:13:48,110
back this converts down to a single

00:13:44,990 --> 00:13:49,940
atomic database transaction right so in

00:13:48,110 --> 00:13:51,890
the above example it is possible if you

00:13:49,940 --> 00:13:54,230
had two processes trying to do this at

00:13:51,890 --> 00:13:56,510
once that one could clobber the results

00:13:54,230 --> 00:14:02,510
of the other but if we use update and F

00:13:56,510 --> 00:14:04,730
we avoid that race condition now as it

00:14:02,510 --> 00:14:06,380
turns out F objects are just a single

00:14:04,730 --> 00:14:09,560
example of a much more general Jango

00:14:06,380 --> 00:14:11,960
class called query expression you might

00:14:09,560 --> 00:14:14,540
know some of these from the aggregate

00:14:11,960 --> 00:14:18,440
function right but they actually have a

00:14:14,540 --> 00:14:21,260
very close cousin in database function

00:14:18,440 --> 00:14:23,180
so the ones on the right you know while

00:14:21,260 --> 00:14:25,490
performing a query you can include and

00:14:23,180 --> 00:14:27,680
they will in line concatenate two fields

00:14:25,490 --> 00:14:31,360
together compared to and return the

00:14:27,680 --> 00:14:33,950
smaller convert to upper or lower case

00:14:31,360 --> 00:14:36,290
and some of you might be thinking hey

00:14:33,950 --> 00:14:38,959
those look like a lot of sequel

00:14:36,290 --> 00:14:40,970
functions that I know right that's

00:14:38,959 --> 00:14:43,760
because they are super fun

00:14:40,970 --> 00:14:47,180
you can subclass the database function

00:14:43,760 --> 00:14:49,070
class which simply takes a list of

00:14:47,180 --> 00:14:50,810
arguments and then the corresponding

00:14:49,070 --> 00:14:53,810
sequel function to apply that through

00:14:50,810 --> 00:14:55,250
right so the top example without having

00:14:53,810 --> 00:14:56,899
to iterate over any products we're

00:14:55,250 --> 00:14:59,089
converting all of the names to lowercase

00:14:56,899 --> 00:15:01,250
and adding that right to each individual

00:14:59,089 --> 00:15:03,529
product and in the bottom example we're

00:15:01,250 --> 00:15:05,540
taking all of our users using the split

00:15:03,529 --> 00:15:08,810
part function and sequel to break the

00:15:05,540 --> 00:15:11,980
email based on the at sign delimiter and

00:15:08,810 --> 00:15:16,820
just grab the second of that split I

00:15:11,980 --> 00:15:17,990
don't mean the value class that you're

00:15:16,820 --> 00:15:26,750
saying there is simply a wrapper around

00:15:17,990 --> 00:15:28,820
raw Python value right so some more you

00:15:26,750 --> 00:15:31,660
know weary expression subclasses F

00:15:28,820 --> 00:15:33,740
segregates function values we just saw

00:15:31,660 --> 00:15:36,709
expression wrappers we'll touch on in a

00:15:33,740 --> 00:15:38,329
minute and conditionals actually are a

00:15:36,709 --> 00:15:41,029
really powerful subclass that allow you

00:15:38,329 --> 00:15:43,790
to implement conditional logic inside of

00:15:41,029 --> 00:15:46,550
a query right so you can say add this

00:15:43,790 --> 00:15:48,500
computation add this extension if a

00:15:46,550 --> 00:15:51,790
certain case is true otherwise add a

00:15:48,500 --> 00:15:53,899
second completely different compensation

00:15:51,790 --> 00:15:55,760
and these are these are pretty powerful

00:15:53,899 --> 00:15:57,680
but if you find that you need to write

00:15:55,760 --> 00:15:58,610
your own query expression it's actually

00:15:57,680 --> 00:16:01,250
not that bad

00:15:58,610 --> 00:16:03,470
you only have to define four or so

00:16:01,250 --> 00:16:07,070
methods as sequel get look up get

00:16:03,470 --> 00:16:08,540
transform and help with you if you need

00:16:07,070 --> 00:16:10,790
to write if you need to customize the

00:16:08,540 --> 00:16:12,890
sequel output for post Greece or my

00:16:10,790 --> 00:16:14,779
sequel a sequel light you can define and

00:16:12,890 --> 00:16:16,520
as vendor name function right where you

00:16:14,779 --> 00:16:19,279
replace vendor name with the name of

00:16:16,520 --> 00:16:20,870
your desired back end since writing your

00:16:19,279 --> 00:16:22,760
own expression is a fairly advanced

00:16:20,870 --> 00:16:25,279
exercise I'm not going to delve too deep

00:16:22,760 --> 00:16:26,570
into what exactly these entail but

00:16:25,279 --> 00:16:28,730
rather I'm going to point you to the

00:16:26,570 --> 00:16:31,270
excellent Django documentation and leave

00:16:28,730 --> 00:16:31,270
it as an exercise

00:16:32,369 --> 00:16:36,790
it is at this point that I do have to

00:16:34,839 --> 00:16:41,069
admit one of our previous examples

00:16:36,790 --> 00:16:43,149
wasn't exactly correct that's my beat

00:16:41,069 --> 00:16:45,430
technically speaking this code will

00:16:43,149 --> 00:16:47,649
absolutely work if unit price and

00:16:45,430 --> 00:16:48,939
quantity are the same type of right if

00:16:47,649 --> 00:16:49,329
they're both integers Django can say

00:16:48,939 --> 00:16:51,759
okay

00:16:49,329 --> 00:16:53,860
an integer times an integer we probably

00:16:51,759 --> 00:16:55,990
want an integer back out but because

00:16:53,860 --> 00:16:58,809
unit price is a float we have to

00:16:55,990 --> 00:17:02,499
explicitly tell Django what feel type we

00:16:58,809 --> 00:17:03,819
want to come back out and as you can see

00:17:02,499 --> 00:17:05,319
we're invoking the expression wrapper

00:17:03,819 --> 00:17:06,760
class to do this right the final code

00:17:05,319 --> 00:17:08,020
ends up being a little bit more verbose

00:17:06,760 --> 00:17:09,970
but you get some more fine-grained

00:17:08,020 --> 00:17:11,620
control over it we're specifying our

00:17:09,970 --> 00:17:15,510
output field as a flow field in this

00:17:11,620 --> 00:17:15,510
case so that we can coerce it

00:17:16,949 --> 00:17:21,490
now hopefully ideally you're convinced

00:17:19,390 --> 00:17:23,140
that you can execute 90 something

00:17:21,490 --> 00:17:25,600
percent of the queries that you need in

00:17:23,140 --> 00:17:27,939
Django natively right but on the same

00:17:25,600 --> 00:17:29,950
chance that these haven't solved your

00:17:27,939 --> 00:17:31,659
problems you can roll your sleeves all

00:17:29,950 --> 00:17:32,200
the way up and start writing some

00:17:31,659 --> 00:17:35,590
bare-bones

00:17:32,200 --> 00:17:39,549
sequel as a side note I just want to say

00:17:35,590 --> 00:17:42,070
one quick thing if you're writing raw

00:17:39,549 --> 00:17:45,700
sequel you should probably rethink what

00:17:42,070 --> 00:17:47,649
you're about to do now this isn't to say

00:17:45,700 --> 00:17:49,149
that you should never write raw sequel

00:17:47,649 --> 00:17:50,559
right there are plenty of valid use

00:17:49,149 --> 00:17:52,690
cases where it's the right thing to do

00:17:50,559 --> 00:17:55,029
and there are absolutely performance and

00:17:52,690 --> 00:17:56,980
convenience benefits to be had however

00:17:55,029 --> 00:17:59,080
there are probably different more

00:17:56,980 --> 00:18:00,820
maintainable ways of reaping those same

00:17:59,080 --> 00:18:02,740
benefits if you're looking for speed

00:18:00,820 --> 00:18:04,240
increases consider refactoring your code

00:18:02,740 --> 00:18:05,710
to be more efficient right maybe using

00:18:04,240 --> 00:18:07,840
some of those clear set tricks we just

00:18:05,710 --> 00:18:10,390
learned you know we're introducing

00:18:07,840 --> 00:18:11,919
caching when it comes to convenience you

00:18:10,390 --> 00:18:13,630
could write wos equal or you could

00:18:11,919 --> 00:18:15,789
consider restructuring your models and

00:18:13,630 --> 00:18:17,850
your tables to take advantage of more

00:18:15,789 --> 00:18:20,320
than a two functionality

00:18:17,850 --> 00:18:22,330
writing your own sequel you know wow

00:18:20,320 --> 00:18:24,340
great in some situations means that you

00:18:22,330 --> 00:18:26,380
lose portability options when it comes

00:18:24,340 --> 00:18:28,899
to changing database management system

00:18:26,380 --> 00:18:31,419
and of course if you're using dynamic

00:18:28,899 --> 00:18:34,780
values you start opening yourself up to

00:18:31,419 --> 00:18:38,890
the possibility of equal

00:18:34,780 --> 00:18:40,420
anyway now that my PSA is over the first

00:18:38,890 --> 00:18:42,520
way that you can start writing sequel is

00:18:40,420 --> 00:18:44,980
the extra method right it lets you

00:18:42,520 --> 00:18:47,890
inject specific clauses into a query

00:18:44,980 --> 00:18:49,510
sets generated sequel you should be

00:18:47,890 --> 00:18:51,250
aware that this method while not

00:18:49,510 --> 00:18:54,190
currently deprecated is planned for

00:18:51,250 --> 00:18:56,440
deprecation so if you really need to use

00:18:54,190 --> 00:18:58,330
it make sure you file a ticket with the

00:18:56,440 --> 00:19:00,340
Django project so that the core devs are

00:18:58,330 --> 00:19:01,780
aware of your use case and can ideally

00:19:00,340 --> 00:19:06,310
try to build some native functionality

00:19:01,780 --> 00:19:09,310
to take care of it so in this example

00:19:06,310 --> 00:19:13,380
right we're introducing an is recent

00:19:09,310 --> 00:19:16,570
attribute into our select clause and the

00:19:13,380 --> 00:19:17,770
generated sequel like that pretty

00:19:16,570 --> 00:19:18,790
straightforward there are a bunch of

00:19:17,770 --> 00:19:21,160
different clauses that you can work with

00:19:18,790 --> 00:19:23,590
using extra you've got select where

00:19:21,160 --> 00:19:26,620
tables order by and if you need to start

00:19:23,590 --> 00:19:28,540
escaping dynamic parameters for the

00:19:26,620 --> 00:19:30,100
Select clause you can use select frames

00:19:28,540 --> 00:19:31,420
and for all the others you can use

00:19:30,100 --> 00:19:34,180
regular params

00:19:31,420 --> 00:19:36,550
I have no idea why they're two different

00:19:34,180 --> 00:19:38,050
keyword arguments for these but there

00:19:36,550 --> 00:19:39,580
are a number of Django core devs

00:19:38,050 --> 00:19:42,130
floating around so I wouldn't suggest

00:19:39,580 --> 00:19:45,850
this read them

00:19:42,130 --> 00:19:49,809
and if this really truly has not solved

00:19:45,850 --> 00:19:51,460
your problem you can just write some

00:19:49,809 --> 00:19:54,490
lawsuit all right that raw we'll just

00:19:51,460 --> 00:19:57,460
take a string pipe it out to what's

00:19:54,490 --> 00:19:59,559
beneath and I knew back to the zone this

00:19:57,460 --> 00:20:01,480
example is very trivial and should not

00:19:59,559 --> 00:20:04,240
at all be you know done using law sequel

00:20:01,480 --> 00:20:06,010
for a couple reasons one I was too lazy

00:20:04,240 --> 00:20:08,530
to come up with a more complex one and

00:20:06,010 --> 00:20:13,570
two I am employed as a Python programmer

00:20:08,530 --> 00:20:16,090
and not a DBA so let's recap right

00:20:13,570 --> 00:20:18,549
we had our basic methods we can annotate

00:20:16,090 --> 00:20:20,740
and aggregate more possible our advanced

00:20:18,549 --> 00:20:22,900
methods where we can reduce joins with

00:20:20,740 --> 00:20:25,720
select and prefetch related and use only

00:20:22,900 --> 00:20:27,429
in defer to partially fetch data our Q

00:20:25,720 --> 00:20:29,620
objects which were encapsulated query

00:20:27,429 --> 00:20:32,770
constraints our F objects which were

00:20:29,620 --> 00:20:34,450
implicit field references our database

00:20:32,770 --> 00:20:36,700
functions and one a sum average count

00:20:34,450 --> 00:20:39,130
you might no contact ready to lower you

00:20:36,700 --> 00:20:41,530
might not query expressions which are

00:20:39,130 --> 00:20:44,020
crazy powerful and see the docs that you

00:20:41,530 --> 00:20:47,830
need write your own and Ross equal

00:20:44,020 --> 00:20:49,390
thanked with extra and wrong my name is

00:20:47,830 --> 00:20:50,830
Charlie you can find me around the

00:20:49,390 --> 00:20:53,020
internet usually at charlie argh whoa

00:20:50,830 --> 00:20:55,150
please note the are there is another

00:20:53,020 --> 00:21:00,030
Charlie who does not use the are and he

00:20:55,150 --> 00:21:02,260
gets a lot of my email I write stuff

00:21:00,030 --> 00:21:03,669
this one time I wrote a book it's called

00:21:02,260 --> 00:21:05,110
unscalable it's a collection of

00:21:03,669 --> 00:21:07,890
interviews with startup founders on a

00:21:05,110 --> 00:21:12,600
theme of few things that don't scale

00:21:07,890 --> 00:21:12,600
that's my shameless plug and thank

00:21:20,460 --> 00:21:24,940
am i doing on time yes so we have about

00:21:23,350 --> 00:21:26,650
five minutes for questions if you have

00:21:24,940 --> 00:21:29,020
them please I use the microphones at the

00:21:26,650 --> 00:21:30,880
ends of the aisles I I had a quick

00:21:29,020 --> 00:21:33,160
question about a query that we had some

00:21:30,880 --> 00:21:35,350
trouble with something we had refactor

00:21:33,160 --> 00:21:36,910
dudas changes that we were going through

00:21:35,350 --> 00:21:39,720
where we had to introduce Norris

00:21:36,910 --> 00:21:42,670
statement into an already complex query

00:21:39,720 --> 00:21:44,830
so we had an or statement which then we

00:21:42,670 --> 00:21:47,140
fed into a filter with a bunch of other

00:21:44,830 --> 00:21:48,430
ands and by the time we were done with

00:21:47,140 --> 00:21:50,710
this query it was so long running

00:21:48,430 --> 00:21:52,000
because the datasets were so large that

00:21:50,710 --> 00:21:54,250
we had to break it up into multiple

00:21:52,000 --> 00:21:56,410
smaller queries to be able to have it

00:21:54,250 --> 00:21:59,410
run effectively and not timeout all the

00:21:56,410 --> 00:22:00,640
time would you have any suggestions for

00:21:59,410 --> 00:22:02,530
how we might be able to handle that and

00:22:00,640 --> 00:22:06,580
be able to do that in a single query set

00:22:02,530 --> 00:22:10,740
yeah again gonna emphasize that I'm not

00:22:06,580 --> 00:22:13,090
employed as a DBA but I would say that

00:22:10,740 --> 00:22:16,270
it is possible to do some things where

00:22:13,090 --> 00:22:18,580
you essentially like use the cubes and

00:22:16,270 --> 00:22:21,730
then back filters on them is that what

00:22:18,580 --> 00:22:25,720
you guys originally were doing or so we

00:22:21,730 --> 00:22:28,630
we took the Q's and ordered them into

00:22:25,720 --> 00:22:31,330
one larger queue essentially and then

00:22:28,630 --> 00:22:33,670
use that in a filter with other criteria

00:22:31,330 --> 00:22:36,460
as you know anding all of that together

00:22:33,670 --> 00:22:37,540
and it was just massively long running

00:22:36,460 --> 00:22:38,800
so I don't know if like we did something

00:22:37,540 --> 00:22:40,570
wrong there if there was a way we could

00:22:38,800 --> 00:22:42,400
have reorganized that so it would have

00:22:40,570 --> 00:22:44,140
created a more efficient query off the

00:22:42,400 --> 00:22:46,240
top of my head I'm not sure probably the

00:22:44,140 --> 00:22:47,710
way I approach it is just for all I use

00:22:46,240 --> 00:22:49,540
query set you can print I think it

00:22:47,710 --> 00:22:51,280
stopped theory and it will spit out what

00:22:49,540 --> 00:22:53,440
this equals I can generating so figuring

00:22:51,280 --> 00:22:55,980
out from there what to refactor and

00:22:53,440 --> 00:22:55,980
let's break down

00:22:58,660 --> 00:23:03,650
thank you that was great

00:23:01,150 --> 00:23:07,870
my question is I ended up in a situation

00:23:03,650 --> 00:23:10,190
where I needed to query the same model

00:23:07,870 --> 00:23:13,940
imagine that different categories right

00:23:10,190 --> 00:23:17,360
but I wanted to have two slices I'd say

00:23:13,940 --> 00:23:20,390
first one 10 items instances on and the

00:23:17,360 --> 00:23:22,490
other one 5 it's not even possible

00:23:20,390 --> 00:23:25,130
I don't know if anything the questions

00:23:22,490 --> 00:23:30,320
you need one modern imagined article and

00:23:25,130 --> 00:23:33,860
I did I need 10 items from 1 Katori many

00:23:30,320 --> 00:23:38,780
to many right and 5 items from another

00:23:33,860 --> 00:23:40,550
category in one query set oh so you have

00:23:38,780 --> 00:23:44,360
two queries and then you want to join

00:23:40,550 --> 00:23:47,450
them together essentially or if you know

00:23:44,360 --> 00:23:48,980
so if you know for example the queue

00:23:47,450 --> 00:23:51,620
that you generate if you can generate a

00:23:48,980 --> 00:23:54,620
10 and then you can generate the 5 right

00:23:51,620 --> 00:23:56,540
if you have the code to do that you

00:23:54,620 --> 00:23:59,510
could put them both into cubes right and

00:23:56,540 --> 00:24:04,750
then music new thing I was actually

00:23:59,510 --> 00:24:09,800
using the queue for the categories but

00:24:04,750 --> 00:24:13,310
human was like once you take a slice you

00:24:09,800 --> 00:24:15,770
can't actually have another slice the

00:24:13,310 --> 00:24:17,360
worst problem I don't know if that the

00:24:15,770 --> 00:24:18,410
section you sliced it and then yeah I

00:24:17,360 --> 00:24:21,050
would figure out a way to do without

00:24:18,410 --> 00:24:22,550
slice if you know which ID you need

00:24:21,050 --> 00:24:25,130
right like if there's a limit if you can

00:24:22,550 --> 00:24:27,110
order by ID and then just take the first

00:24:25,130 --> 00:24:28,550
10 this would be a good place where

00:24:27,110 --> 00:24:29,900
those extra database functions would

00:24:28,550 --> 00:24:34,100
come in handy right because you could

00:24:29,900 --> 00:24:38,720
say no if this is greater than 9 other

00:24:34,100 --> 00:24:40,820
ones right then stop but I would suggest

00:24:38,720 --> 00:24:43,670
you I can take a look at it everyone if

00:24:40,820 --> 00:24:46,280
you want have fun it just it seems to be

00:24:43,670 --> 00:24:48,860
a bit weird that having two different

00:24:46,280 --> 00:24:51,650
questions for same model you know just

00:24:48,860 --> 00:24:55,760
to get items to different from different

00:24:51,650 --> 00:25:00,190
categories kind of thing so I didn't I

00:24:55,760 --> 00:25:00,190
ended up having to query sets at the end

00:25:01,250 --> 00:25:08,480
I just wanted to clarify on your last

00:25:04,520 --> 00:25:13,180
example there so when you do a raw query

00:25:08,480 --> 00:25:16,520
you can add any number of computed

00:25:13,180 --> 00:25:19,750
columns on and it'll just return them

00:25:16,520 --> 00:25:22,280
back as if they were part of the model

00:25:19,750 --> 00:25:25,490
if you I believe if you use an ad yeah

00:25:22,280 --> 00:25:27,770
it just you'll just have new properties

00:25:25,490 --> 00:25:29,360
on your model that are sort of temporary

00:25:27,770 --> 00:25:33,820
properties just from your query I

00:25:29,360 --> 00:25:33,820
believe so but check the evacuation okay

00:25:36,100 --> 00:25:45,890
thank you a big round of applause

00:25:38,460 --> 00:25:45,890
[Applause]

00:25:51,500 --> 00:25:56,420

YouTube URL: https://www.youtube.com/watch?v=5y7vU52jOiQ


