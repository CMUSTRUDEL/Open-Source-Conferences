Title: DjangoCon US 2016 - WebSockets: Intro to Messaging by Josue Balandrano Coronel
Publication date: 2016-08-11
Playlist: DjangoCon US 2016
Description: 
	DjangoCon US 2016 - WebSockets: Intro to Messaging by Josue Balandrano Coronel

Todayâ€™s web applications demand information to be delivered immediately after it is available. This is a huge step from where everything started, simple HTTP blocking requests. In order to solve this Server Side Events (SSE) and Websockets (WS) were created. SSE works from the server to the client only and it uses the HTTP protocol. WS is bidirectional and implements a layer on top of HTTP. WS started to get more momentum and now most of modern web browsers support it.

This talk was presented at: https://2016.djangocon.us/schedule/presentation/34/

LINKS:
Follow DjangCon US ðŸ‘‡
https://twitter.com/djangocon

Follow DEFNA ðŸ‘‡
https://twitter.com/defnado
https://www.defna.org/
Captions: 
	00:00:13,970 --> 00:00:18,869
thank you good afternoon so today is

00:00:17,130 --> 00:00:21,240
gonna be a day of firsts because this is

00:00:18,869 --> 00:00:23,490
my first django con this is my first

00:00:21,240 --> 00:00:25,439
time I gave a talk at a conference ever

00:00:23,490 --> 00:00:27,570
this might be the first time that you

00:00:25,439 --> 00:00:31,349
guys hear about django channels the

00:00:27,570 --> 00:00:32,850
first time I wear this jacket today so

00:00:31,349 --> 00:00:34,620
let's start why

00:00:32,850 --> 00:00:35,850
WebSockets why talk about WebSockets

00:00:34,620 --> 00:00:38,430
weather well the thing is that actually

00:00:35,850 --> 00:00:41,010
our web applications have been growing

00:00:38,430 --> 00:00:43,829
more and more every year and now we have

00:00:41,010 --> 00:00:46,170
way more robust applications not only

00:00:43,829 --> 00:00:47,519
under under back in but also on the

00:00:46,170 --> 00:00:50,519
front end the in front of the interfaces

00:00:47,519 --> 00:00:53,579
are way more complex and they now need

00:00:50,519 --> 00:00:57,149
to talk to the server more regularly as

00:00:53,579 --> 00:00:59,399
well as the server we're now processing

00:00:57,149 --> 00:01:01,170
more data on this on a server so what

00:00:59,399 --> 00:01:05,190
this happens is that without a regular

00:01:01,170 --> 00:01:06,990
HTTP parody of request response there's

00:01:05,190 --> 00:01:12,690
a lot of latency in this communication

00:01:06,990 --> 00:01:16,049
and in order to solve this some well we

00:01:12,690 --> 00:01:18,450
created the the WebSockets aspects and

00:01:16,049 --> 00:01:19,770
basically what WebSockets is the idea

00:01:18,450 --> 00:01:21,689
behind WebSockets is to have a

00:01:19,770 --> 00:01:23,759
persistent connection between the client

00:01:21,689 --> 00:01:25,560
and the server by having this persistent

00:01:23,759 --> 00:01:28,110
connection we can just send information

00:01:25,560 --> 00:01:30,600
back and forth and anybody can start

00:01:28,110 --> 00:01:34,560
sending the data even the server or the

00:01:30,600 --> 00:01:36,210
client with this we lower our latency

00:01:34,560 --> 00:01:39,060
and we have a better response and a

00:01:36,210 --> 00:01:41,789
real-time application we can see the

00:01:39,060 --> 00:01:43,680
difference on both protocols here which

00:01:41,789 --> 00:01:46,409
is the HTTP it just opens a connection

00:01:43,680 --> 00:01:48,750
sends a request then the server process

00:01:46,409 --> 00:01:50,460
the request sends the request back I

00:01:48,750 --> 00:01:53,070
mean the response back and it closes the

00:01:50,460 --> 00:01:54,869
connection while on WebSockets the

00:01:53,070 --> 00:01:57,090
challenges always happen all this the

00:01:54,869 --> 00:02:00,539
client closest ear or the server decides

00:01:57,090 --> 00:02:03,450
to close their connection so let's take

00:02:00,539 --> 00:02:06,060
a quick look at at the WebSockets spec

00:02:03,450 --> 00:02:08,100
just some key points here first of all

00:02:06,060 --> 00:02:10,380
we need to realize that WebSockets still

00:02:08,100 --> 00:02:12,450
run on top of tcp/ip it's just a

00:02:10,380 --> 00:02:14,280
persistent connection and also the way

00:02:12,450 --> 00:02:17,070
to start our website or to open a

00:02:14,280 --> 00:02:19,590
WebSocket is to give a to set an HTTP

00:02:17,070 --> 00:02:23,130
request but it has an augury header on

00:02:19,590 --> 00:02:25,290
it and after this the WebSocket is open

00:02:23,130 --> 00:02:27,329
and all the data that goes through it

00:02:25,290 --> 00:02:28,469
actually goes in frames that are called

00:02:27,329 --> 00:02:30,030
messages we're going to call these

00:02:28,469 --> 00:02:33,689
WebSocket messages just to avoid

00:02:30,030 --> 00:02:35,310
confusion so what about on the server

00:02:33,689 --> 00:02:37,469
side what's happening because that's

00:02:35,310 --> 00:02:39,930
that's what we're here for so let's take

00:02:37,469 --> 00:02:42,659
a look at a WebSocket server under the

00:02:39,930 --> 00:02:46,079
hood we're gonna go into much detail but

00:02:42,659 --> 00:02:47,370
just the the overall overview so the

00:02:46,079 --> 00:02:49,170
first thing that we need to keep in mind

00:02:47,370 --> 00:02:51,480
is the WebSockets cannot behind by

00:02:49,170 --> 00:02:53,010
regular whiskey workflow because if we

00:02:51,480 --> 00:02:55,409
take a look at the whiskey workflow it

00:02:53,010 --> 00:02:59,099
is pretty much based on on the regular

00:02:55,409 --> 00:03:00,510
HTTP request/response parody so whenever

00:02:59,099 --> 00:03:01,859
a client sends a request the server

00:03:00,510 --> 00:03:04,439
process it and when the server is

00:03:01,859 --> 00:03:07,799
processing a request we have this

00:03:04,439 --> 00:03:09,239
workflow right here which is we the

00:03:07,799 --> 00:03:11,370
packet is probably gonna go on through

00:03:09,239 --> 00:03:13,319
an HTTP server like Apache or nginx

00:03:11,370 --> 00:03:15,209
and then it's going to go to the whiskey

00:03:13,319 --> 00:03:16,590
server which will then send all the

00:03:15,209 --> 00:03:18,450
information with header and a whiskey

00:03:16,590 --> 00:03:21,150
dictionary to django django is going to

00:03:18,450 --> 00:03:22,919
process all process all the data and

00:03:21,150 --> 00:03:25,349
create a response and then it will send

00:03:22,919 --> 00:03:26,909
it back to the to the client and the

00:03:25,349 --> 00:03:29,970
connection is going to be closed now

00:03:26,909 --> 00:03:31,650
when this is happening here when when

00:03:29,970 --> 00:03:34,319
everything happens through the years

00:03:31,650 --> 00:03:35,699
through the whiskey server and then and

00:03:34,319 --> 00:03:38,040
then Django gets called and all that

00:03:35,699 --> 00:03:40,319
that's happening on a thread so if we

00:03:38,040 --> 00:03:42,780
would like to keep this same workflow

00:03:40,319 --> 00:03:45,090
and try to implement WebSockets that

00:03:42,780 --> 00:03:47,579
would mean that whenever our response

00:03:45,090 --> 00:03:49,139
goes back this thread is not going to

00:03:47,579 --> 00:03:51,209
finish this or it is not going to exit

00:03:49,139 --> 00:03:53,579
and we're gonna have to keep the thread

00:03:51,209 --> 00:03:54,959
running on an infinite loop just waiting

00:03:53,579 --> 00:03:56,459
for other messages either from the

00:03:54,959 --> 00:03:58,799
server to the client or from the client

00:03:56,459 --> 00:04:00,239
to the server obviously this is not very

00:03:58,799 --> 00:04:03,540
scalable and we're going to run out of

00:04:00,239 --> 00:04:06,930
threads very quickly so one of the

00:04:03,540 --> 00:04:09,599
solutions actually is a concept that's

00:04:06,930 --> 00:04:11,340
called off loading and unloading is

00:04:09,599 --> 00:04:13,139
using water Moroso handles lower

00:04:11,340 --> 00:04:16,409
learning running tasks which can be

00:04:13,139 --> 00:04:19,560
managed in a non-blocking way we can see

00:04:16,409 --> 00:04:19,919
that now our workflow changes a little

00:04:19,560 --> 00:04:22,620
bit

00:04:19,919 --> 00:04:25,889
usually in production when we see with

00:04:22,620 --> 00:04:29,400
WebSockets is that a lot of people just

00:04:25,889 --> 00:04:31,919
runs two different whiskey servers one

00:04:29,400 --> 00:04:34,110
of them is going to process all the HTTP

00:04:31,919 --> 00:04:36,120
requests the way that we all know and

00:04:34,110 --> 00:04:38,219
the other one is going to process a

00:04:36,120 --> 00:04:38,760
WebSocket messages so now here's where

00:04:38,219 --> 00:04:39,960
they

00:04:38,760 --> 00:04:41,760
very interesting because when a

00:04:39,960 --> 00:04:43,470
WebSocket message comes in what's

00:04:41,760 --> 00:04:46,140
happening is that the whiskey server

00:04:43,470 --> 00:04:48,720
actually fired super worker thread which

00:04:46,140 --> 00:04:50,940
will then process the request this is

00:04:48,720 --> 00:04:52,920
going to free the whiskey server to be

00:04:50,940 --> 00:04:54,870
able to handle any other concurrent

00:04:52,920 --> 00:04:58,230
requests that are going to come into or

00:04:54,870 --> 00:05:00,570
messages or sort of messages so this is

00:04:58,230 --> 00:05:02,760
an improvement on the whole or a whole

00:05:00,570 --> 00:05:04,700
workflow but the thing here is that now

00:05:02,760 --> 00:05:08,340
we're starting to talk about three

00:05:04,700 --> 00:05:11,310
directorates we're talking about using

00:05:08,340 --> 00:05:14,640
threads to process the requests and how

00:05:11,310 --> 00:05:16,680
do we manage this well there's a lot of

00:05:14,640 --> 00:05:19,290
entry consists in the whole topic of

00:05:16,680 --> 00:05:21,960
this but the simple answer is just to

00:05:19,290 --> 00:05:24,480
use an async library something like G of

00:05:21,960 --> 00:05:27,240
N or or a sync i/o there's a lot of

00:05:24,480 --> 00:05:30,420
different different libraries like this

00:05:27,240 --> 00:05:33,360
in in Python now the issue with this is

00:05:30,420 --> 00:05:34,650
that is it there's there's a lot of

00:05:33,360 --> 00:05:36,690
things that we need to keep in mind and

00:05:34,650 --> 00:05:38,760
there's number of caveats just would use

00:05:36,690 --> 00:05:42,870
one when we start diving into the hole a

00:05:38,760 --> 00:05:45,450
synchronous topic and thread managing so

00:05:42,870 --> 00:05:47,370
first of all let's let's mention that

00:05:45,450 --> 00:05:49,170
offloading is not a new concept and

00:05:47,370 --> 00:05:52,050
other frameworks are using it like not

00:05:49,170 --> 00:05:54,120
years or maybe go to we are diving into

00:05:52,050 --> 00:05:56,540
the same world as I was mentioning this

00:05:54,120 --> 00:05:58,950
has a lot of different different issues

00:05:56,540 --> 00:06:00,780
one of them well there's there's a lot

00:05:58,950 --> 00:06:02,430
of different issues that can make us

00:06:00,780 --> 00:06:06,990
actually shoot ourselves in on the foot

00:06:02,430 --> 00:06:09,870
very easily and we need to figure out

00:06:06,990 --> 00:06:11,460
also how to set how to make these

00:06:09,870 --> 00:06:15,660
threads to communicate with each other

00:06:11,460 --> 00:06:18,090
in order to to persist the data let's

00:06:15,660 --> 00:06:19,980
say the session data or cookies there or

00:06:18,090 --> 00:06:21,570
things like that because every thread

00:06:19,980 --> 00:06:23,280
that we fire up is going to be working

00:06:21,570 --> 00:06:25,980
on or is going to be processing things

00:06:23,280 --> 00:06:28,320
on a different context so then we can't

00:06:25,980 --> 00:06:30,330
just put data on global variables and

00:06:28,320 --> 00:06:33,930
expect all the threads to know about

00:06:30,330 --> 00:06:38,160
those variables the but the cool thing

00:06:33,930 --> 00:06:41,220
is that by using these new workflow now

00:06:38,160 --> 00:06:43,830
our application is event based now our

00:06:41,220 --> 00:06:45,990
our server is not going to send

00:06:43,830 --> 00:06:47,880
information only when the client clicks

00:06:45,990 --> 00:06:50,610
a button or refreshes a page or

00:06:47,880 --> 00:06:51,190
something like that but we can also run

00:06:50,610 --> 00:06:52,720
long

00:06:51,190 --> 00:06:54,130
tasks on the server and whenever

00:06:52,720 --> 00:06:57,180
something happens on the server we can

00:06:54,130 --> 00:06:59,740
let the client know one or many clients

00:06:57,180 --> 00:07:01,600
there are still physical constraints of

00:06:59,740 --> 00:07:04,000
course this is another thing that we

00:07:01,600 --> 00:07:05,440
need to keep in mind which is the amount

00:07:04,000 --> 00:07:07,690
of worker threads that we can actually

00:07:05,440 --> 00:07:12,010
use the processing power and the memory

00:07:07,690 --> 00:07:14,260
capacity now how to bring WebSockets

00:07:12,010 --> 00:07:18,520
into janko well there are different ways

00:07:14,260 --> 00:07:20,140
to do this the whole point of this talk

00:07:18,520 --> 00:07:22,090
is to talk about general channels but

00:07:20,140 --> 00:07:25,750
I'm going to talk about other projects

00:07:22,090 --> 00:07:27,700
that try to actually do this just to see

00:07:25,750 --> 00:07:29,680
where those jungle channels actually

00:07:27,700 --> 00:07:32,950
come from and what is jag which also is

00:07:29,680 --> 00:07:35,260
a it's actually trying to solve so the

00:07:32,950 --> 00:07:37,660
first solution the people came up with

00:07:35,260 --> 00:07:39,820
is to use just another intern complete

00:07:37,660 --> 00:07:42,910
different service to handle web sockets

00:07:39,820 --> 00:07:45,730
like nodejs and this is going to change

00:07:42,910 --> 00:07:47,800
our workflow a little bit and it will be

00:07:45,730 --> 00:07:50,200
something like this so we can still use

00:07:47,800 --> 00:07:52,090
our HTTP server to to load-balanced

00:07:50,200 --> 00:07:53,740
different requests the HTTP requests

00:07:52,090 --> 00:07:56,080
they're going to be handled by django

00:07:53,740 --> 00:07:57,640
and the web sockets can be handled by

00:07:56,080 --> 00:07:59,980
nodejs now the only thing is that we

00:07:57,640 --> 00:08:02,919
don't want to actually start developing

00:07:59,980 --> 00:08:05,620
things in two different languages on the

00:08:02,919 --> 00:08:06,730
server so we might want to build a

00:08:05,620 --> 00:08:09,520
restful api

00:08:06,730 --> 00:08:11,740
so they both can talk on and that we

00:08:09,520 --> 00:08:13,500
know Jesus can get some information that

00:08:11,740 --> 00:08:16,750
he needs whenever a message comes in

00:08:13,500 --> 00:08:20,470
this is this this llll is still putting

00:08:16,750 --> 00:08:23,320
a lot of different overhead on the whole

00:08:20,470 --> 00:08:26,140
communication of this nevertheless it is

00:08:23,320 --> 00:08:28,330
a solution that people use out there so

00:08:26,140 --> 00:08:30,490
the the other thing is that these are

00:08:28,330 --> 00:08:32,860
just two different technologies which

00:08:30,490 --> 00:08:35,260
can be hard to maintain sometimes and

00:08:32,860 --> 00:08:39,099
it's really not Jenny it's more of a

00:08:35,260 --> 00:08:41,080
kind of hack although it works the other

00:08:39,099 --> 00:08:42,910
thing is that we can just use an order

00:08:41,080 --> 00:08:46,000
Python a synchronous event framework

00:08:42,910 --> 00:08:48,339
like twister or tornado so the idea is

00:08:46,000 --> 00:08:51,190
basically the same one a little bit

00:08:48,339 --> 00:08:53,830
since we will be running jungle in

00:08:51,190 --> 00:08:57,100
parallel with this other a synchronous

00:08:53,830 --> 00:08:59,020
event framework and then we'll we we can

00:08:57,100 --> 00:09:01,000
we can make those to toggle with each

00:08:59,020 --> 00:09:04,330
other the other thing is to use whiskey

00:09:01,000 --> 00:09:05,020
offloading and the and a way to actually

00:09:04,330 --> 00:09:06,940
make

00:09:05,020 --> 00:09:10,330
threats decide to themselves so that way

00:09:06,940 --> 00:09:12,160
we don't fall into into two different

00:09:10,330 --> 00:09:15,100
issues that come with with different

00:09:12,160 --> 00:09:16,690
thread context is to use storage back in

00:09:15,100 --> 00:09:19,210
like readies or something like that that

00:09:16,690 --> 00:09:24,250
every thread can actually read and write

00:09:19,210 --> 00:09:26,710
to so if we already have all these

00:09:24,250 --> 00:09:28,840
different solutions they why talk about

00:09:26,710 --> 00:09:31,420
genre channels why is language channels

00:09:28,840 --> 00:09:33,100
try to solve if we can already just use

00:09:31,420 --> 00:09:36,700
all that well

00:09:33,100 --> 00:09:38,230
the thing is that first of all none of

00:09:36,700 --> 00:09:40,120
these solutions are actually gang

00:09:38,230 --> 00:09:41,320
grenade I mean this these are just kind

00:09:40,120 --> 00:09:44,560
of things that you're running probably

00:09:41,320 --> 00:09:48,760
with jungle and what we love and like

00:09:44,560 --> 00:09:51,340
and we want to develop on its its jungle

00:09:48,760 --> 00:09:52,930
the only thing is that all the solutions

00:09:51,340 --> 00:09:54,760
that I just mentioned they're really not

00:09:52,930 --> 00:09:57,250
malleable in the way that Django is

00:09:54,760 --> 00:10:00,670
malleable because Django lets us

00:09:57,250 --> 00:10:03,910
actually just replace or extend any

00:10:00,670 --> 00:10:06,340
piece of it the any way that we want it

00:10:03,910 --> 00:10:07,900
maybe use a different library maybe just

00:10:06,340 --> 00:10:11,170
a modified library in some way or

00:10:07,900 --> 00:10:13,660
another or something like that the other

00:10:11,170 --> 00:10:17,290
thing is that Django challenge is trying

00:10:13,660 --> 00:10:19,150
to abstract the the acing handling of

00:10:17,290 --> 00:10:20,740
the entire offloading of the threads

00:10:19,150 --> 00:10:24,760
that way we don't have to worry that

00:10:20,740 --> 00:10:27,940
much about it and and and we don't share

00:10:24,760 --> 00:10:30,130
ourselves on the food that much the

00:10:27,940 --> 00:10:31,690
other thing is that also Django is

00:10:30,130 --> 00:10:35,080
always been very friendly with other

00:10:31,690 --> 00:10:38,530
technologies and and and it's very easy

00:10:35,080 --> 00:10:40,000
to just maybe run a script outside yak

00:10:38,530 --> 00:10:42,490
or something like that and make it talk

00:10:40,000 --> 00:10:44,440
to jangle and and jammu will will

00:10:42,490 --> 00:10:47,980
actually do a lot of pretty cool things

00:10:44,440 --> 00:10:51,280
with this so let's just overview again

00:10:47,980 --> 00:10:53,740
the the way that we can actually

00:10:51,280 --> 00:10:56,410
implement uploading with wizzy because

00:10:53,740 --> 00:10:59,890
this is one of the things that were kind

00:10:56,410 --> 00:11:03,100
of kind of approaches more the model of

00:10:59,890 --> 00:11:05,470
django channels so we remember we have

00:11:03,100 --> 00:11:07,710
two whisky servers which one of them is

00:11:05,470 --> 00:11:09,730
going to be handling the WebSocket

00:11:07,710 --> 00:11:11,860
connections and then prior worker

00:11:09,730 --> 00:11:16,060
threads so if we take a look at how

00:11:11,860 --> 00:11:19,320
Jagger channels actually works we can

00:11:16,060 --> 00:11:22,380
see that this is a little bit like

00:11:19,320 --> 00:11:24,260
it's not necessarily the same but the

00:11:22,380 --> 00:11:27,330
idea behind it is is the same one

00:11:24,260 --> 00:11:28,980
whenever we have a packet card come in

00:11:27,330 --> 00:11:32,370
we're gonna have an interface server

00:11:28,980 --> 00:11:34,710
because the processing of the entire of

00:11:32,370 --> 00:11:36,990
all the requests or messages are going

00:11:34,710 --> 00:11:40,830
to happen on a worker threads then our

00:11:36,990 --> 00:11:42,630
our whisky server or our HTTP server

00:11:40,830 --> 00:11:46,650
actually becomes only an interface

00:11:42,630 --> 00:11:49,670
server which is a layer between our our

00:11:46,650 --> 00:11:52,500
Jagga project and the wild out there

00:11:49,670 --> 00:11:55,380
then after this we have a channel a

00:11:52,500 --> 00:11:58,220
channel backing which is the the new

00:11:55,380 --> 00:12:01,530
thing that we were going to talk about

00:11:58,220 --> 00:12:03,540
this is going to let us actually control

00:12:01,530 --> 00:12:05,580
the different information that all these

00:12:03,540 --> 00:12:06,990
worker threads are going to need in

00:12:05,580 --> 00:12:09,240
order to know when when they're going to

00:12:06,990 --> 00:12:12,300
fire off and what do they need to do and

00:12:09,240 --> 00:12:14,460
all that then we have the workers and

00:12:12,300 --> 00:12:17,040
then all the worker threads can actually

00:12:14,460 --> 00:12:18,450
use the process different types of

00:12:17,040 --> 00:12:21,150
requests it could be web sockets or

00:12:18,450 --> 00:12:22,950
equals be HTTP requests or it could be

00:12:21,150 --> 00:12:25,290
any other kind of protocol so the one

00:12:22,950 --> 00:12:28,680
we're going to talk about HTTP or well

00:12:25,290 --> 00:12:30,750
specifically WebSockets actually so

00:12:28,680 --> 00:12:33,320
let's dive a little bit more into it

00:12:30,750 --> 00:12:36,150
what exactly are channels it themselves

00:12:33,320 --> 00:12:38,520
channels are basically just data

00:12:36,150 --> 00:12:40,070
structures that behaves like a first in

00:12:38,520 --> 00:12:44,370
first out queue

00:12:40,070 --> 00:12:48,270
they have message expiring and they have

00:12:44,370 --> 00:12:50,640
a policy to deliver at most one once to

00:12:48,270 --> 00:12:52,620
actual listener at a time this means

00:12:50,640 --> 00:12:56,790
that when we put a message into a

00:12:52,620 --> 00:12:58,470
channel then at the most one listener is

00:12:56,790 --> 00:12:59,970
going to get that message if something

00:12:58,470 --> 00:13:03,030
goes wrong nobody's going to get the

00:12:59,970 --> 00:13:04,530
message so we need to keep this in mind

00:13:03,030 --> 00:13:06,960
the other thing is the channels have a

00:13:04,530 --> 00:13:09,600
unique string identifier which is which

00:13:06,960 --> 00:13:12,120
makes it very easy to actually use

00:13:09,600 --> 00:13:14,790
reference one channel in different types

00:13:12,120 --> 00:13:17,070
of contexts and the cool part is that

00:13:14,790 --> 00:13:19,110
this is network transparent which means

00:13:17,070 --> 00:13:21,420
that it can be accessible over network

00:13:19,110 --> 00:13:23,190
which means though we can actually have

00:13:21,420 --> 00:13:27,570
different servers communicate with each

00:13:23,190 --> 00:13:29,910
other by using Java channels and it also

00:13:27,570 --> 00:13:31,890
has capacity and that means that

00:13:29,910 --> 00:13:33,120
whenever we start putting messages into

00:13:31,890 --> 00:13:35,610
a channel they're going to

00:13:33,120 --> 00:13:37,080
stay there until listener comes in or a

00:13:35,610 --> 00:13:39,570
consumer that we're gonna have for you

00:13:37,080 --> 00:13:43,500
want to call it a consumer comes in and

00:13:39,570 --> 00:13:47,850
grabs the message so how do we use

00:13:43,500 --> 00:13:51,360
channels basically this is the way that

00:13:47,850 --> 00:13:55,350
we use check it's it's it's a very very

00:13:51,360 --> 00:13:58,920
basic function that we can use and it's

00:13:55,350 --> 00:14:01,830
something that's very like views like

00:13:58,920 --> 00:14:04,380
Django views so and also just like like

00:14:01,830 --> 00:14:07,050
Django views we can have function views

00:14:04,380 --> 00:14:09,390
or classifies views we Jagga child we

00:14:07,050 --> 00:14:11,850
can have function function consumers

00:14:09,390 --> 00:14:14,100
this is work well whatever a consumer

00:14:11,850 --> 00:14:16,980
function is going to look like or we can

00:14:14,100 --> 00:14:19,140
have class based consumers we're going

00:14:16,980 --> 00:14:21,540
to give examples about about function

00:14:19,140 --> 00:14:24,300
consumers just for simplicity so

00:14:21,540 --> 00:14:27,060
basically what it is is just a function

00:14:24,300 --> 00:14:28,920
that is going to get a message it's

00:14:27,060 --> 00:14:31,980
going to get a message as a parameter

00:14:28,920 --> 00:14:34,200
and then it's going to send back that

00:14:31,980 --> 00:14:37,260
message there's a few things that we

00:14:34,200 --> 00:14:40,230
need to see on this example first of all

00:14:37,260 --> 00:14:42,270
the the actual work I just created this

00:14:40,230 --> 00:14:44,910
other function here which is going to

00:14:42,270 --> 00:14:47,700
actually process the message and and we

00:14:44,910 --> 00:14:50,250
need to to see that every message has

00:14:47,700 --> 00:14:52,950
this dictionary that's called content so

00:14:50,250 --> 00:14:56,120
with it in inside of it we can actually

00:14:52,950 --> 00:14:59,160
access a lot of different information

00:14:56,120 --> 00:15:01,680
when we try to access count the the key

00:14:59,160 --> 00:15:05,190
the the key text of it we're actually

00:15:01,680 --> 00:15:07,950
getting the text that the client is said

00:15:05,190 --> 00:15:10,020
into the server and whenever we're going

00:15:07,950 --> 00:15:11,730
to send back something through through a

00:15:10,020 --> 00:15:15,750
web socket channel we need to during our

00:15:11,730 --> 00:15:17,550
key value format because he needs to be

00:15:15,750 --> 00:15:20,279
easily see release able in order to go

00:15:17,550 --> 00:15:23,010
through through their web sockets so

00:15:20,279 --> 00:15:24,900
once once we have a response we just

00:15:23,010 --> 00:15:27,750
send it through through the through the

00:15:24,900 --> 00:15:29,970
channel let's talk a little bit more

00:15:27,750 --> 00:15:32,790
about how to communicate back on to the

00:15:29,970 --> 00:15:35,730
client and and just to to have a more

00:15:32,790 --> 00:15:37,560
visual aspect of it so we've been

00:15:35,730 --> 00:15:39,990
talking about channels which is just a

00:15:37,560 --> 00:15:42,329
cue and first in first out queue and

00:15:39,990 --> 00:15:44,970
then we have we have the consumer

00:15:42,329 --> 00:15:45,530
functions but how the way that they come

00:15:44,970 --> 00:15:48,260
in

00:15:45,530 --> 00:15:51,050
and come come together is that we will

00:15:48,260 --> 00:15:57,170
have a worker thread pool which will

00:15:51,050 --> 00:16:00,020
actually assign a thread with with one

00:15:57,170 --> 00:16:02,030
of these of these consumer functions to

00:16:00,020 --> 00:16:07,340
every message that comes into the

00:16:02,030 --> 00:16:09,470
channel but the thing is that that that

00:16:07,340 --> 00:16:11,420
is how we process in this example that

00:16:09,470 --> 00:16:13,520
is how we process a message that comes

00:16:11,420 --> 00:16:16,370
into the channel let's say from a client

00:16:13,520 --> 00:16:18,920
but then what about after we process it

00:16:16,370 --> 00:16:21,590
well if we take a look at this we're

00:16:18,920 --> 00:16:23,600
actually using this other thing on the

00:16:21,590 --> 00:16:26,450
message object which is called reply

00:16:23,600 --> 00:16:30,470
channel so for every client that sends a

00:16:26,450 --> 00:16:33,440
message or the opens our web socket into

00:16:30,470 --> 00:16:35,570
the server we're going to the jungle

00:16:33,440 --> 00:16:38,270
child's create our reply channel and

00:16:35,570 --> 00:16:40,880
this reply channel is just it's a it's a

00:16:38,270 --> 00:16:43,820
unique channel it has a unique string

00:16:40,880 --> 00:16:46,220
identifier and this is mapped always to

00:16:43,820 --> 00:16:48,170
just one client so whatever we send

00:16:46,220 --> 00:16:52,180
through that is going to get sent back

00:16:48,170 --> 00:16:54,770
to the client so the only thing is that

00:16:52,180 --> 00:16:56,540
we're now talking about sending sending

00:16:54,770 --> 00:16:59,300
stuff back to the client but just to one

00:16:56,540 --> 00:17:01,340
client and that's not always fun because

00:16:59,300 --> 00:17:04,610
what about if we want to want to

00:17:01,340 --> 00:17:08,210
implement the overly used chat or

00:17:04,610 --> 00:17:09,950
something like that or maybe I don't

00:17:08,210 --> 00:17:12,860
know let's say just a broadcast

00:17:09,950 --> 00:17:15,110
application then we need to send the

00:17:12,860 --> 00:17:17,210
message different messages or well the

00:17:15,110 --> 00:17:20,060
same message to different reply channels

00:17:17,210 --> 00:17:22,760
so we will have to to keep that in mind

00:17:20,060 --> 00:17:24,770
we will have to to keep the track of the

00:17:22,760 --> 00:17:26,870
all of those reply channels and we need

00:17:24,770 --> 00:17:32,150
to and then look through those and all

00:17:26,870 --> 00:17:33,530
that luckily luckily Django challenge

00:17:32,150 --> 00:17:35,420
already comes with something that's

00:17:33,530 --> 00:17:37,580
called groups so what they do is they

00:17:35,420 --> 00:17:39,680
keep track of a set of reply channels or

00:17:37,580 --> 00:17:41,780
regular channels we need to to keep that

00:17:39,680 --> 00:17:44,420
in mind that that is not only for reply

00:17:41,780 --> 00:17:46,010
channels we can also make groups for I

00:17:44,420 --> 00:17:47,330
don't know maybe a cluster of service

00:17:46,010 --> 00:17:52,220
that we want to send some information

00:17:47,330 --> 00:17:53,060
and then make them process something the

00:17:52,220 --> 00:17:56,270
other thing is that they have an

00:17:53,060 --> 00:17:59,120
exploration policy because because a

00:17:56,270 --> 00:18:01,790
group is just is just a closer

00:17:59,120 --> 00:18:04,430
members then whenever we put a message

00:18:01,790 --> 00:18:06,620
in all of those are all of those

00:18:04,430 --> 00:18:08,960
channels then we need to keep track

00:18:06,620 --> 00:18:11,870
whenever those messages actually expire

00:18:08,960 --> 00:18:14,260
or else we might just keep sending

00:18:11,870 --> 00:18:17,360
messages to to expire your connections

00:18:14,260 --> 00:18:20,210
so this is basically the way that we

00:18:17,360 --> 00:18:22,220
used that we use channels and it is very

00:18:20,210 --> 00:18:25,400
easy django channels and their project

00:18:22,220 --> 00:18:27,500
itself it's actually has actually given

00:18:25,400 --> 00:18:29,770
us all the interfaces that we need to

00:18:27,500 --> 00:18:32,920
make all of this easy as we can see

00:18:29,770 --> 00:18:36,679
right now I'm setting up three different

00:18:32,920 --> 00:18:39,110
consumers consumer functions the first

00:18:36,679 --> 00:18:41,090
one is going to to fire up whenever

00:18:39,110 --> 00:18:43,760
somebody connects through a WebSocket

00:18:41,090 --> 00:18:46,190
and what's happening here is that we're

00:18:43,760 --> 00:18:48,890
just creating this group broadcast and

00:18:46,190 --> 00:18:51,500
we're going to add the reply channel now

00:18:48,890 --> 00:18:54,470
this the creation of the of the group

00:18:51,500 --> 00:18:55,730
it's actually implicit here because if

00:18:54,470 --> 00:18:57,140
it doesn't exist it's just going to

00:18:55,730 --> 00:18:59,510
create a group if it exists is just

00:18:57,140 --> 00:19:01,460
going to add it to that group then

00:18:59,510 --> 00:19:03,500
whenever we get a message while we're

00:19:01,460 --> 00:19:06,020
doing here is we're just echoing that

00:19:03,500 --> 00:19:08,120
message back through every client in

00:19:06,020 --> 00:19:10,790
that in the group and the way that we do

00:19:08,120 --> 00:19:13,700
it is we just use that this send

00:19:10,790 --> 00:19:16,400
function and then send it again on a on

00:19:13,700 --> 00:19:19,309
a key value format this becomes pretty

00:19:16,400 --> 00:19:21,710
easy and and we really don't don't don't

00:19:19,309 --> 00:19:25,940
need to to worry about anything else

00:19:21,710 --> 00:19:27,800
other than removing the specific member

00:19:25,940 --> 00:19:32,840
whenever the WebSocket actually

00:19:27,800 --> 00:19:35,270
disconnects so the other thing is how

00:19:32,840 --> 00:19:37,910
are we going to route all of these

00:19:35,270 --> 00:19:40,610
consumer functions well it is pretty

00:19:37,910 --> 00:19:44,179
easy and what we do is that we set up a

00:19:40,610 --> 00:19:46,280
routing function and in surrounding file

00:19:44,179 --> 00:19:51,200
which is supposed to live just right

00:19:46,280 --> 00:19:53,870
next to URLs dot py and it's actually it

00:19:51,200 --> 00:19:57,980
actually looks a lot like like my url so

00:19:53,870 --> 00:20:00,740
py and this is the way that we that we

00:19:57,980 --> 00:20:02,510
map all those consumer functions onto

00:20:00,740 --> 00:20:05,960
all those different different channels

00:20:02,510 --> 00:20:08,570
now one thing that we need to to mention

00:20:05,960 --> 00:20:11,330
here is these three different channels I

00:20:08,570 --> 00:20:12,860
haven't I haven't actually explained

00:20:11,330 --> 00:20:15,289
where did those channels come from

00:20:12,860 --> 00:20:20,539
who created those channels or were they

00:20:15,289 --> 00:20:23,539
actually Stan or or define and what

00:20:20,539 --> 00:20:28,100
happens here is that Yaga channels also

00:20:23,539 --> 00:20:31,519
created a speck in order to to give a

00:20:28,100 --> 00:20:33,740
more malleable approach to all these to

00:20:31,519 --> 00:20:35,690
all this implementation and what's

00:20:33,740 --> 00:20:38,210
happening here is that on the and

00:20:35,690 --> 00:20:41,240
disrespect is called a SGI as in a

00:20:38,210 --> 00:20:43,519
synchronous asynchronous SGI and the a

00:20:41,240 --> 00:20:46,419
SGI spec tells us that whatever

00:20:43,519 --> 00:20:49,639
interface server as we mention before

00:20:46,419 --> 00:20:52,000
whatever interface server is going to to

00:20:49,639 --> 00:20:54,139
follow this spec whenever it gets

00:20:52,000 --> 00:20:55,940
WebSocket connection is going to create

00:20:54,139 --> 00:20:58,220
these three different channels so

00:20:55,940 --> 00:20:59,720
they're so these three different

00:20:58,220 --> 00:21:02,240
channels we don't have to worry about

00:20:59,720 --> 00:21:03,919
creating them or or coffee or in them or

00:21:02,240 --> 00:21:05,600
anything like that but our interface

00:21:03,919 --> 00:21:07,460
server is the one who's going to to

00:21:05,600 --> 00:21:08,840
create that I'll talk a little bit more

00:21:07,460 --> 00:21:13,399
about interface service you know a

00:21:08,840 --> 00:21:15,889
little bit so now now that we know about

00:21:13,399 --> 00:21:18,080
replay channels the the challenge that

00:21:15,889 --> 00:21:20,269
we usually have are a little bit more

00:21:18,080 --> 00:21:22,669
like this so we have the worker thread

00:21:20,269 --> 00:21:25,039
pool and there is going to be our

00:21:22,669 --> 00:21:27,230
general channels and our response

00:21:25,039 --> 00:21:29,990
channels which those map directly to

00:21:27,230 --> 00:21:33,860
each one of the clients and this is the

00:21:29,990 --> 00:21:35,330
the the format that the a SGI spec tells

00:21:33,860 --> 00:21:37,490
us that the response journalist is going

00:21:35,330 --> 00:21:40,250
to be which is going to to contain this

00:21:37,490 --> 00:21:44,240
exclamation point and then anything on

00:21:40,250 --> 00:21:48,980
that has to do with with these these

00:21:44,240 --> 00:21:51,350
characters the other thing is that how

00:21:48,980 --> 00:21:53,960
are we on track well we already

00:21:51,350 --> 00:21:56,740
mentioned how to route the consumer

00:21:53,960 --> 00:22:00,289
functions onto on to a specific channel

00:21:56,740 --> 00:22:02,510
so we already talked about workers and

00:22:00,289 --> 00:22:05,450
let's just go back into our overview of

00:22:02,510 --> 00:22:08,179
django channels each one of these things

00:22:05,450 --> 00:22:10,039
we're gonna we're gonna go through it so

00:22:08,179 --> 00:22:12,440
what we talked about about these these

00:22:10,039 --> 00:22:15,710
different workers and we mention how to

00:22:12,440 --> 00:22:17,630
use to use consumer functions to

00:22:15,710 --> 00:22:20,200
actually process the message that comes

00:22:17,630 --> 00:22:23,649
in in through a WebSocket

00:22:20,200 --> 00:22:26,630
the the next thing is that how are we

00:22:23,649 --> 00:22:28,280
going to make all these workers for it

00:22:26,630 --> 00:22:30,350
communicate with each other because we

00:22:28,280 --> 00:22:32,690
mentioned that jaga chance is is no

00:22:30,350 --> 00:22:34,970
network well we can we can talk with

00:22:32,690 --> 00:22:38,030
with jaga channels through the network

00:22:34,970 --> 00:22:39,320
so how can we actually do this and the

00:22:38,030 --> 00:22:41,780
way that we do it is that there is

00:22:39,320 --> 00:22:44,800
there's a channels back in later and

00:22:41,780 --> 00:22:47,390
they're out of the box the Aqua channels

00:22:44,800 --> 00:22:49,670
support different backing layers the

00:22:47,390 --> 00:22:51,980
most basic one is memory back in and

00:22:49,670 --> 00:22:53,840
this is pretty much only good if if

00:22:51,980 --> 00:22:56,780
you're debugging something on your

00:22:53,840 --> 00:22:58,370
localhost because it's not it doesn't

00:22:56,780 --> 00:22:59,290
have inter process communication or

00:22:58,370 --> 00:23:03,020
anything like that because it's just

00:22:59,290 --> 00:23:05,780
it's just a backing layer in you know in

00:23:03,020 --> 00:23:07,580
a piece of memory but we can also use IP

00:23:05,780 --> 00:23:09,620
C which is supposing shared memory

00:23:07,580 --> 00:23:11,740
segments the benefit of this is that

00:23:09,620 --> 00:23:14,990
it's also memory it's it's lightweight

00:23:11,740 --> 00:23:18,470
but it also has inter process

00:23:14,990 --> 00:23:22,340
communication which means that basically

00:23:18,470 --> 00:23:24,710
we can we can write to a different a

00:23:22,340 --> 00:23:27,020
different channel or group from outside

00:23:24,710 --> 00:23:30,140
jungle from from up from any other type

00:23:27,020 --> 00:23:33,350
of context and the other one it's raitis

00:23:30,140 --> 00:23:36,290
this is the the one that suggested to

00:23:33,350 --> 00:23:39,350
actually use in production because it's

00:23:36,290 --> 00:23:43,690
it's more robust and it also gives us

00:23:39,350 --> 00:23:47,270
the ability to to coffee group charting

00:23:43,690 --> 00:23:49,400
I need it this is a the backing layer

00:23:47,270 --> 00:23:51,740
that actually works throughout network

00:23:49,400 --> 00:23:53,090
because IPC is not going to work to

00:23:51,740 --> 00:23:54,620
network or a memory back and it's not

00:23:53,090 --> 00:23:57,710
gonna but I will work through the

00:23:54,620 --> 00:24:00,080
network the way that we use some of

00:23:57,710 --> 00:24:02,270
these of these backing layers in this

00:24:00,080 --> 00:24:06,020
example this is Redis we just say

00:24:02,270 --> 00:24:10,610
stallions GI underscore readies project

00:24:06,020 --> 00:24:12,890
I mean packet and then we put this in

00:24:10,610 --> 00:24:15,880
our settings of py as we can see this is

00:24:12,890 --> 00:24:19,520
a lot like the database configuration

00:24:15,880 --> 00:24:22,670
and it's because it's it they they do

00:24:19,520 --> 00:24:25,490
have some kind a lot of similarities the

00:24:22,670 --> 00:24:27,650
same way if we want to use IPC we're

00:24:25,490 --> 00:24:29,930
going to have to install a SGI

00:24:27,650 --> 00:24:35,510
underscore IPC and then use the

00:24:29,930 --> 00:24:38,660
appropriate the appropriate model name

00:24:35,510 --> 00:24:42,230
so those that's that's basically how we

00:24:38,660 --> 00:24:44,030
how we we configure a channel back in

00:24:42,230 --> 00:24:46,460
and the way that we use it is whenever

00:24:44,030 --> 00:24:48,500
we write on to a group or we write into

00:24:46,460 --> 00:24:53,300
a channel we're actually writing onto

00:24:48,500 --> 00:24:55,250
these this back and layer and now what

00:24:53,300 --> 00:24:58,160
about the interface layers I mean the

00:24:55,250 --> 00:24:59,690
interface servers so what happens with

00:24:58,160 --> 00:25:02,480
the interface service is that Jango

00:24:59,690 --> 00:25:04,220
channels actually already ships with an

00:25:02,480 --> 00:25:06,500
interface server that's called Daphne

00:25:04,220 --> 00:25:09,410
and this interface server what it does

00:25:06,500 --> 00:25:10,700
is that it's based on untwisted because

00:25:09,410 --> 00:25:12,920
twistin are really gives us an

00:25:10,700 --> 00:25:16,970
implementation of WebSockets and HTTP

00:25:12,920 --> 00:25:19,610
long-haul into and so Daphne is just

00:25:16,970 --> 00:25:25,520
using these implementations in order to

00:25:19,610 --> 00:25:28,310
to keep to to the a sei spec what we can

00:25:25,520 --> 00:25:31,460
do is we can we can use Daphne as our

00:25:28,310 --> 00:25:33,380
sole interface interface server and and

00:25:31,460 --> 00:25:35,210
Daphne can actually have knows how to

00:25:33,380 --> 00:25:37,940
handle different requests like HTTP

00:25:35,210 --> 00:25:39,980
regular HTTP request or WebSocket voice

00:25:37,940 --> 00:25:41,900
that is going to route them the way that

00:25:39,980 --> 00:25:45,230
we wanted to now the only thing is that

00:25:41,900 --> 00:25:47,570
Davin is pretty new and maybe we don't

00:25:45,230 --> 00:25:50,690
want to do that on production but we can

00:25:47,570 --> 00:25:53,300
also run whiskey and Daphne side-by-side

00:25:50,690 --> 00:25:55,310
so the only thing is that we're going to

00:25:53,300 --> 00:25:57,350
have ancient something like nginx

00:25:55,310 --> 00:25:59,120
to actually load balance different

00:25:57,350 --> 00:26:01,400
requests so the HTTP requests they're

00:25:59,120 --> 00:26:03,920
going to go through our regular whiskey

00:26:01,400 --> 00:26:07,640
server and the WebSocket messages are

00:26:03,920 --> 00:26:10,820
going to go through Daphne so basically

00:26:07,640 --> 00:26:13,730
the way that we're going to set up our

00:26:10,820 --> 00:26:15,950
interface server because because our

00:26:13,730 --> 00:26:18,050
interface server is really just just

00:26:15,950 --> 00:26:19,910
another another server like like a

00:26:18,050 --> 00:26:24,980
whiskey server we're going to create an

00:26:19,910 --> 00:26:26,840
AAC Idol py file and we're going to put

00:26:24,980 --> 00:26:29,030
this into it and the only thing that

00:26:26,840 --> 00:26:31,910
we're doing here is that we are actually

00:26:29,030 --> 00:26:35,270
getting the channel layer which is the

00:26:31,910 --> 00:26:36,830
one that we can figure here as you can

00:26:35,270 --> 00:26:40,460
see this one is called channel layers

00:26:36,830 --> 00:26:42,740
and we this this one is the default one

00:26:40,460 --> 00:26:45,380
we can have multiple channel layers too

00:26:42,740 --> 00:26:47,390
if we want to if our application is very

00:26:45,380 --> 00:26:48,470
convoluted and maybe there is a lot of

00:26:47,390 --> 00:26:50,450
different types of

00:26:48,470 --> 00:26:52,970
of servers in the back in talking to

00:26:50,450 --> 00:26:56,120
each other etc or maybe we just want to

00:26:52,970 --> 00:27:02,060
separate our our channel layers by

00:26:56,120 --> 00:27:04,550
concerns so and the way that I will run

00:27:02,060 --> 00:27:06,440
Daphne it's basically just doing this

00:27:04,550 --> 00:27:09,770
Daphne is the command and then we just

00:27:06,440 --> 00:27:13,190
give it give it this this the model the

00:27:09,770 --> 00:27:15,650
module as a parameter pretty much the

00:27:13,190 --> 00:27:17,660
same way that we that we run whiskey so

00:27:15,650 --> 00:27:20,930
that's the interface server

00:27:17,660 --> 00:27:23,510
now what about well we talked about

00:27:20,930 --> 00:27:29,200
about how Jago channels are actually

00:27:23,510 --> 00:27:32,510
work throughout the network right so

00:27:29,200 --> 00:27:34,100
what about you how can we can we use

00:27:32,510 --> 00:27:37,580
channels from somewhere else outside

00:27:34,100 --> 00:27:39,590
Django so the only thing that we can

00:27:37,580 --> 00:27:41,000
well the thing that we need to keep in

00:27:39,590 --> 00:27:42,710
mind is that we don't need to be in a

00:27:41,000 --> 00:27:45,260
specific country to write to a channel

00:27:42,710 --> 00:27:49,280
we just not we just need to have access

00:27:45,260 --> 00:27:52,040
to the channel back in later and and the

00:27:49,280 --> 00:27:53,690
way that we do it is just using the same

00:27:52,040 --> 00:27:57,560
things that we've already seen which is

00:27:53,690 --> 00:27:59,840
just you already have the the name or

00:27:57,560 --> 00:28:02,870
the string of the of the group we can

00:27:59,840 --> 00:28:04,820
just send that to we can just use this

00:28:02,870 --> 00:28:06,830
interface to actually write to that

00:28:04,820 --> 00:28:10,190
group and every member of that group is

00:28:06,830 --> 00:28:12,470
going to get that message if we want to

00:28:10,190 --> 00:28:14,360
send it to specific client we can

00:28:12,470 --> 00:28:16,430
actually just use the reply channel now

00:28:14,360 --> 00:28:20,000
the reply channel again it's only a

00:28:16,430 --> 00:28:23,240
string so if we dive into into the

00:28:20,000 --> 00:28:26,090
jungle channels can everybody see that

00:28:23,240 --> 00:28:29,120
if we were diving into the jungle

00:28:26,090 --> 00:28:32,380
channels code we can see that a message

00:28:29,120 --> 00:28:36,430
actually has a the way that they create

00:28:32,380 --> 00:28:39,950
reply channel is just instantiating a

00:28:36,430 --> 00:28:42,170
channel object with the reply channel

00:28:39,950 --> 00:28:44,780
string and then use the channel layer

00:28:42,170 --> 00:28:46,760
now we don't necessarily need to know

00:28:44,780 --> 00:28:48,590
which channel layer we're going to use

00:28:46,760 --> 00:28:51,590
if we only have one because it's always

00:28:48,590 --> 00:28:53,960
going to default to the default word but

00:28:51,590 --> 00:28:56,090
if we got a we have multiple ones the

00:28:53,960 --> 00:29:00,740
way that we do it is that we can

00:28:56,090 --> 00:29:02,110
actually use use just a a string that's

00:29:00,740 --> 00:29:04,390
going to be the alien

00:29:02,110 --> 00:29:09,309
of it and the alias of it we've already

00:29:04,390 --> 00:29:11,710
configured it here these for instance

00:29:09,309 --> 00:29:13,240
the alias is default if we add another

00:29:11,710 --> 00:29:17,170
one the alias is going to be I don't

00:29:13,240 --> 00:29:20,670
know maybe image processing or something

00:29:17,170 --> 00:29:25,240
like that so let's continue with this

00:29:20,670 --> 00:29:27,640
okay well and now since we still have

00:29:25,240 --> 00:29:28,679
time that was a little bit quicker than

00:29:27,640 --> 00:29:35,740
I expected

00:29:28,679 --> 00:29:40,660
I'm gonna show you real quick how we can

00:29:35,740 --> 00:29:42,220
write to to a so a Jaguar channel

00:29:40,660 --> 00:29:45,090
actually also from Django because I

00:29:42,220 --> 00:29:48,520
think this is this is one example that

00:29:45,090 --> 00:29:51,190
leverages our on on every every aspect

00:29:48,520 --> 00:29:53,500
of Django channels so basically what I

00:29:51,190 --> 00:29:55,450
did here I'm just running Django it's

00:29:53,500 --> 00:30:00,190
it's a very funny installation of jungle

00:29:55,450 --> 00:30:03,010
and I'm just using run server so after

00:30:00,190 --> 00:30:05,679
installing channels we can see that when

00:30:03,010 --> 00:30:07,390
we run going to run this we're gonna

00:30:05,679 --> 00:30:09,040
have all these information about the

00:30:07,390 --> 00:30:11,350
workers now what's happening here is

00:30:09,040 --> 00:30:13,510
that actually the workers are are being

00:30:11,350 --> 00:30:15,910
executed in the same in the same thread

00:30:13,510 --> 00:30:17,890
as as a raw server and this is just

00:30:15,910 --> 00:30:19,780
because it's for debugging if we were in

00:30:17,890 --> 00:30:22,210
production what we needed to do is to

00:30:19,780 --> 00:30:24,700
actually run the the Whiskey server and

00:30:22,210 --> 00:30:29,169
then rolled up in our process and then

00:30:24,700 --> 00:30:31,690
run the the swarm of worker threads so

00:30:29,169 --> 00:30:34,120
now we know that we're listening on all

00:30:31,690 --> 00:30:36,790
these different channels HTTP requests

00:30:34,120 --> 00:30:39,669
is another channel that the a SGI spec

00:30:36,790 --> 00:30:41,559
tells us that the interface server is

00:30:39,669 --> 00:30:48,870
going to create whenever an HTTP request

00:30:41,559 --> 00:30:48,870
comes in so if we go into the client

00:30:49,139 --> 00:30:56,080
so late this basically the way that we

00:30:52,360 --> 00:30:58,480
do it is we create a WebSocket like

00:30:56,080 --> 00:31:01,389
these WebSockets the the support of

00:30:58,480 --> 00:31:07,120
WebSockets are in actually most of the

00:31:01,389 --> 00:31:09,070
major browsers and we can we can just

00:31:07,120 --> 00:31:12,789
open a WebSocket like this is it's

00:31:09,070 --> 00:31:15,940
pretty easy once we created it we get

00:31:12,789 --> 00:31:19,029
all this information back now if we take

00:31:15,940 --> 00:31:22,059
a look at this I have here what I'm

00:31:19,029 --> 00:31:23,620
doing is I'm actually printing different

00:31:22,059 --> 00:31:26,110
information that we can get from from a

00:31:23,620 --> 00:31:29,169
web circuit so as we can see here the

00:31:26,110 --> 00:31:30,909
reply channel it's just this string we

00:31:29,169 --> 00:31:36,279
can see that it has this this

00:31:30,909 --> 00:31:39,070
exclamation point here so if we said

00:31:36,279 --> 00:31:40,840
like we're gonna set this this function

00:31:39,070 --> 00:31:43,330
were what it's going to do is that

00:31:40,840 --> 00:31:46,840
whenever we get a message on a client

00:31:43,330 --> 00:31:51,129
it's just going to is it's just going to

00:31:46,840 --> 00:31:54,250
read it to the to the console so right

00:31:51,129 --> 00:31:56,080
now what our whatever backing is is

00:31:54,250 --> 00:31:59,529
doing or whatever where our server is

00:31:56,080 --> 00:32:01,600
doing it's just doing an echo on the on

00:31:59,529 --> 00:32:03,730
the message itself so we send something

00:32:01,600 --> 00:32:04,299
we're gonna get back the same thing

00:32:03,730 --> 00:32:07,600
right

00:32:04,299 --> 00:32:10,360
so what about writing something onto

00:32:07,600 --> 00:32:12,759
onto a channel from anywhere else so

00:32:10,360 --> 00:32:16,750
because we just open a channel

00:32:12,759 --> 00:32:19,809
we now have here obviously on a better

00:32:16,750 --> 00:32:23,289
project where we will save these a

00:32:19,809 --> 00:32:26,350
string on a model or something like that

00:32:23,289 --> 00:32:29,860
but we can copy this a string and here

00:32:26,350 --> 00:32:34,840
I'm just the same virtual machine and

00:32:29,860 --> 00:32:37,779
we're going to send it using these using

00:32:34,840 --> 00:32:39,340
these this Django command I'm gonna go

00:32:37,779 --> 00:32:41,259
through the junk of anita you know a

00:32:39,340 --> 00:32:43,929
little bit so basically what it's doing

00:32:41,259 --> 00:32:47,649
is that i'm just giving it a string

00:32:43,929 --> 00:32:50,529
which is the the channel ID and i'm just

00:32:47,649 --> 00:32:53,259
giving it a message to send which right

00:32:50,529 --> 00:32:56,889
here is just message underscore sent so

00:32:53,259 --> 00:33:00,399
once i sell it we can see that we got

00:32:56,889 --> 00:33:01,539
here so now we're actually writing onto

00:33:00,399 --> 00:33:03,419
django from outside

00:33:01,539 --> 00:33:06,070
languages from from the console and

00:33:03,419 --> 00:33:07,539
where we can I mean we can do what

00:33:06,070 --> 00:33:13,509
everyone with this actually we can just

00:33:07,539 --> 00:33:15,100
set up a machine monitoring system to to

00:33:13,509 --> 00:33:20,919
be sending messages to our phones or

00:33:15,100 --> 00:33:23,889
whatever so now let's take a look at at

00:33:20,919 --> 00:33:25,479
the at the command basically this is

00:33:23,889 --> 00:33:27,429
just this is the command bar that I just

00:33:25,479 --> 00:33:30,399
use and what it does is it just grabs

00:33:27,429 --> 00:33:34,749
the channel ID and then the message and

00:33:30,399 --> 00:33:36,669
it creates the channel like that it just

00:33:34,749 --> 00:33:39,429
instantly is the channel and then it

00:33:36,669 --> 00:33:40,989
just uses the same function to send a

00:33:39,429 --> 00:33:45,159
message back to the client and then the

00:33:40,989 --> 00:33:49,749
client is gonna is gonna get it now the

00:33:45,159 --> 00:33:56,849
other interesting part about this is the

00:33:49,749 --> 00:34:07,659
way that we're echoing back the the

00:33:56,849 --> 00:34:10,599
message and let me sorry yeah so this

00:34:07,659 --> 00:34:13,389
this is our these are our three

00:34:10,599 --> 00:34:16,929
different customer functions so as we

00:34:13,389 --> 00:34:18,909
can see and we're gonna have this ws

00:34:16,929 --> 00:34:21,700
underscore connect function what it does

00:34:18,909 --> 00:34:25,030
is it only tries to prints out the user

00:34:21,700 --> 00:34:26,859
but because we don't have any kind of of

00:34:25,030 --> 00:34:28,690
authentication is going to print an

00:34:26,859 --> 00:34:30,460
empty string if you see here it's just

00:34:28,690 --> 00:34:32,109
prettier an empty string but this is

00:34:30,460 --> 00:34:33,909
pretty interesting because the other

00:34:32,109 --> 00:34:38,230
cool thing about Django chances are it

00:34:33,909 --> 00:34:41,109
comes already with different types of of

00:34:38,230 --> 00:34:43,510
decorators that gives us access to to

00:34:41,109 --> 00:34:46,270
the to the user object and to the user

00:34:43,510 --> 00:34:48,010
session that way we can we can use

00:34:46,270 --> 00:34:49,899
authentication or we can just check

00:34:48,010 --> 00:34:53,230
which user is sending the message and

00:34:49,899 --> 00:34:58,089
route accordingly or maybe we can just

00:34:53,230 --> 00:34:59,500
put something under user session now the

00:34:58,089 --> 00:35:04,599
important thing to note here is that

00:34:59,500 --> 00:35:07,270
we're going to use these these these

00:35:04,599 --> 00:35:09,730
decorator whenever a user connects

00:35:07,270 --> 00:35:12,670
because whenever I user connects is when

00:35:09,730 --> 00:35:15,190
first is going to send the HTTP packet

00:35:12,670 --> 00:35:17,110
and then after that any concept

00:35:15,190 --> 00:35:19,990
when messages that go through the web

00:35:17,110 --> 00:35:22,360
circuit it doesn't actually has any

00:35:19,990 --> 00:35:24,550
other type of information that I read

00:35:22,360 --> 00:35:26,890
HTTP requests is going to have like

00:35:24,550 --> 00:35:29,470
cookies or recession or and all that so

00:35:26,890 --> 00:35:32,560
when we use this Django Chavez actually

00:35:29,470 --> 00:35:34,780
saves all of that data and then when we

00:35:32,560 --> 00:35:38,920
want to use it again on a message we use

00:35:34,780 --> 00:35:41,920
this order this or decorator which will

00:35:38,920 --> 00:35:43,930
then gives us access to the session

00:35:41,920 --> 00:35:48,100
so here the other thing that we're doing

00:35:43,930 --> 00:35:50,470
is just sending it back to the user that

00:35:48,100 --> 00:35:53,650
this is a pretty basic example I'll be

00:35:50,470 --> 00:35:55,950
uploading actually a more convoluted

00:35:53,650 --> 00:35:59,800
example for a more complete example

00:35:55,950 --> 00:36:01,630
afterwards just didn't want to to go

00:35:59,800 --> 00:36:05,860
through a lot of lines of code at the

00:36:01,630 --> 00:36:08,920
same time that as the talk so any

00:36:05,860 --> 00:36:11,410
questions yeah um what I was curious

00:36:08,920 --> 00:36:14,800
about what you described I'm using kind

00:36:11,410 --> 00:36:17,500
of the hybrid whiskey ASCII model

00:36:14,800 --> 00:36:18,880
yeah is you're essentially running two

00:36:17,500 --> 00:36:23,170
copies of the application correct I mean

00:36:18,880 --> 00:36:24,580
ASCII works similarly to how you know

00:36:23,170 --> 00:36:27,820
the good corner you are you whiskey does

00:36:24,580 --> 00:36:29,740
today with where it essentially is the

00:36:27,820 --> 00:36:32,350
loader for your application

00:36:29,740 --> 00:36:33,850
yeah okay so you're basically so there's

00:36:32,350 --> 00:36:37,090
going to be some implications there then

00:36:33,850 --> 00:36:39,400
for you know like how you would size an

00:36:37,090 --> 00:36:42,550
instance for running that sort of model

00:36:39,400 --> 00:36:44,710
then well actually what what the whole

00:36:42,550 --> 00:36:48,100
model what it does is that it's going to

00:36:44,710 --> 00:36:51,670
to just if you if we take a look at how

00:36:48,100 --> 00:36:53,260
we're running our interface server this

00:36:51,670 --> 00:36:54,880
is the own thing that we're giving it

00:36:53,260 --> 00:36:57,310
we're only giving it the channel layer

00:36:54,880 --> 00:36:59,770
so it's I think what you're saying is

00:36:57,310 --> 00:37:01,060
that is that then the the interface

00:36:59,770 --> 00:37:02,770
server is actually running another

00:37:01,060 --> 00:37:04,750
Django instance and all that but

00:37:02,770 --> 00:37:06,880
actually what it's doing is there is a

00:37:04,750 --> 00:37:09,070
whenever a message come seen is just

00:37:06,880 --> 00:37:10,840
going to fire up or well he's going to

00:37:09,070 --> 00:37:12,940
put it in the channel and then a worker

00:37:10,840 --> 00:37:14,530
thread he's gonna get that channel and

00:37:12,940 --> 00:37:17,200
it's just gonna fire up that consumer

00:37:14,530 --> 00:37:19,180
function and then the consumer function

00:37:17,200 --> 00:37:21,100
is just gonna gonna put it back there

00:37:19,180 --> 00:37:22,660
and he's gonna come back into it and

00:37:21,100 --> 00:37:24,850
because Django chalice is just

00:37:22,660 --> 00:37:27,520
everything inside Django then we can you

00:37:24,850 --> 00:37:28,930
can still use things that are using

00:37:27,520 --> 00:37:31,839
Django like models or

00:37:28,930 --> 00:37:34,660
things but it's not actually just firing

00:37:31,839 --> 00:37:36,520
up another instance or another overjack

00:37:34,660 --> 00:37:39,190
ways where the only thing that were

00:37:36,520 --> 00:37:41,349
given it there is just just those those

00:37:39,190 --> 00:37:42,910
things okay and then the communication

00:37:41,349 --> 00:37:44,500
then between the whiskey sided thing

00:37:42,910 --> 00:37:47,650
that ASCII sided things that would be

00:37:44,500 --> 00:37:49,240
via the backend message yeah yeah the

00:37:47,650 --> 00:37:51,880
background layer so you would not be

00:37:49,240 --> 00:37:54,430
able to use that kind of hybrid model

00:37:51,880 --> 00:37:56,650
with a memory only back-end you would

00:37:54,430 --> 00:37:58,359
have to use at least IPC well you you

00:37:56,650 --> 00:38:00,280
can't you can use it yeah without a PC

00:37:58,359 --> 00:38:01,569
the only other thing with IPC is that

00:38:00,280 --> 00:38:06,309
you cannot use it through the network

00:38:01,569 --> 00:38:07,390
right right yeah okay thank you thank

00:38:06,309 --> 00:38:10,359
you very much if we need to talk about

00:38:07,390 --> 00:38:12,490
how to do this so my question for you is

00:38:10,359 --> 00:38:13,720
like obviously you've done a lot of

00:38:12,490 --> 00:38:15,430
experiment with channels what do you

00:38:13,720 --> 00:38:17,380
think is the most amazing most from

00:38:15,430 --> 00:38:20,800
channels so far that is missing most

00:38:17,380 --> 00:38:23,410
yeah what do you want that's that's a

00:38:20,800 --> 00:38:26,800
pretty interesting idea but I think the

00:38:23,410 --> 00:38:30,160
the the things that are amazing a little

00:38:26,800 --> 00:38:33,160
bit maybe is just some something on top

00:38:30,160 --> 00:38:35,710
of the of the current interfaces that it

00:38:33,160 --> 00:38:39,150
already has to make it a little bit more

00:38:35,710 --> 00:38:41,770
more easier for instance to to send

00:38:39,150 --> 00:38:45,130
message to to a channel from outside

00:38:41,770 --> 00:38:47,109
Jango but but to a specific user I mean

00:38:45,130 --> 00:38:50,740
it's pretty pretty easy to do it with

00:38:47,109 --> 00:38:52,930
groups but let's say that I want that I

00:38:50,740 --> 00:38:55,270
have two servers right and then one

00:38:52,930 --> 00:38:56,650
server is just use the front and it just

00:38:55,270 --> 00:38:58,540
handles requests for the front and in

00:38:56,650 --> 00:39:01,270
the other one it's just some kind of

00:38:58,540 --> 00:39:02,290
heavy heavy processing like machine

00:39:01,270 --> 00:39:04,359
learning processing or something like

00:39:02,290 --> 00:39:05,980
that so then the first server I would

00:39:04,359 --> 00:39:07,450
like to use Jagga challenges to actually

00:39:05,980 --> 00:39:09,700
have these to communicate with

00:39:07,450 --> 00:39:11,859
themselves so then on the first server I

00:39:09,700 --> 00:39:14,890
want to send that information through

00:39:11,859 --> 00:39:17,020
the channel and then or through a group

00:39:14,890 --> 00:39:18,640
maybe and it on the on the other server

00:39:17,020 --> 00:39:21,490
I would like to send out just that

00:39:18,640 --> 00:39:23,140
specific reply channel so just getting a

00:39:21,490 --> 00:39:25,500
hang on there on that reply channel it's

00:39:23,140 --> 00:39:28,160
sometimes gets a little bit convoluted

00:39:25,500 --> 00:39:32,210
thank you

00:39:28,160 --> 00:39:34,160
oh yes hi um I was wondering and maybe

00:39:32,210 --> 00:39:37,670
you may have just kind of explained it

00:39:34,160 --> 00:39:39,530
but between the persistence the

00:39:37,670 --> 00:39:43,340
interface server and the channel layer

00:39:39,530 --> 00:39:45,400
yeah how do you handle persistence if

00:39:43,340 --> 00:39:48,650
you were gonna have multiple servers

00:39:45,400 --> 00:39:52,370
like at what point like so if each

00:39:48,650 --> 00:39:53,990
channel is going to a client and the

00:39:52,370 --> 00:39:55,730
client comes back in through your load

00:39:53,990 --> 00:39:57,530
balancing situation ends up in a

00:39:55,730 --> 00:39:59,600
different place over here how do you

00:39:57,530 --> 00:40:01,640
make sure that they're still in a

00:39:59,600 --> 00:40:04,160
channel like well do that in your load

00:40:01,640 --> 00:40:07,010
balancing or okay let me see if I if

00:40:04,160 --> 00:40:08,690
I've got that question correct and and

00:40:07,010 --> 00:40:10,100
what happens here is because of the of

00:40:08,690 --> 00:40:11,480
the backing layer if we use something

00:40:10,100 --> 00:40:12,980
like readies then it's going to go

00:40:11,480 --> 00:40:16,250
through through the network so whenever

00:40:12,980 --> 00:40:17,990
a message comes in then that is going to

00:40:16,250 --> 00:40:20,270
go to my child that's where that's going

00:40:17,990 --> 00:40:22,370
to be called let's we saw a WebSocket

00:40:20,270 --> 00:40:24,260
message right I mean sorry I think it

00:40:22,370 --> 00:40:26,330
was received so when it goes through the

00:40:24,260 --> 00:40:29,150
channel actually anybody that has access

00:40:26,330 --> 00:40:31,250
to readies he's gonna be able to to read

00:40:29,150 --> 00:40:33,020
that at my channel and Jack with

00:40:31,250 --> 00:40:35,360
challenge is gonna go like okay somebody

00:40:33,020 --> 00:40:36,350
needs to take care of this message he's

00:40:35,360 --> 00:40:37,220
going to tell that so they're working

00:40:36,350 --> 00:40:38,660
through a pool

00:40:37,220 --> 00:40:40,610
the workers for the pool is gonna grab

00:40:38,660 --> 00:40:42,440
that now we're gonna have different

00:40:40,610 --> 00:40:45,680
worker thread pools trying to grab that

00:40:42,440 --> 00:40:47,000
message but one is one one of those

00:40:45,680 --> 00:40:49,070
three DS is the only one who's going to

00:40:47,000 --> 00:40:51,440
grab the message and then they always go

00:40:49,070 --> 00:40:53,600
away all right this was already taken

00:40:51,440 --> 00:40:55,070
care of and when going back that's why

00:40:53,600 --> 00:40:57,470
we have the reply channels which are

00:40:55,070 --> 00:40:59,000
unique per client so whenever you put

00:40:57,470 --> 00:41:01,610
there the only thing nobody else is

00:40:59,000 --> 00:41:04,760
going to get the message on that one

00:41:01,610 --> 00:41:06,560
claim hence why Django channel is the

00:41:04,760 --> 00:41:09,980
positive Django challenge is to deliver

00:41:06,560 --> 00:41:12,350
at most once to one a listener or any

00:41:09,980 --> 00:41:15,520
kind of message instead instead of the

00:41:12,350 --> 00:41:18,800
we were too many thank you no problem

00:41:15,520 --> 00:41:20,990
clarify that with the Redis Redis

00:41:18,800 --> 00:41:22,760
handles the incoming but it doesn't it

00:41:20,990 --> 00:41:25,010
doesn't notify in terms of outgoing use

00:41:22,760 --> 00:41:26,660
we're saying like cuz right now that in

00:41:25,010 --> 00:41:28,760
a normal way of doing it that's what

00:41:26,660 --> 00:41:31,430
we'll do now like even calm the Redis

00:41:28,760 --> 00:41:32,930
write a signal right and then once

00:41:31,430 --> 00:41:34,580
they're done processing good signal back

00:41:32,930 --> 00:41:36,470
to Redis and then and then update

00:41:34,580 --> 00:41:37,910
everybody right yeah that's route but

00:41:36,470 --> 00:41:41,160
that but now with with Django channels

00:41:37,910 --> 00:41:43,840
that's not true or is that still true

00:41:41,160 --> 00:41:46,150
wait I got a little bit confused there

00:41:43,840 --> 00:41:48,760
so you mean that when going back when

00:41:46,150 --> 00:41:51,040
when send it back to the to the client

00:41:48,760 --> 00:41:52,720
well actually gives because the one that

00:41:51,040 --> 00:41:55,990
sends back to the client needs social

00:41:52,720 --> 00:41:58,210
worker thread so something because

00:41:55,990 --> 00:42:00,160
because we need to remember that our

00:41:58,210 --> 00:42:01,540
replay Channel it's just that it's

00:42:00,160 --> 00:42:03,610
another Channel the other thing is that

00:42:01,540 --> 00:42:06,010
it has a unique string so that way we're

00:42:03,610 --> 00:42:08,320
not going to have different members on

00:42:06,010 --> 00:42:11,920
that on that one channel this is just

00:42:08,320 --> 00:42:13,960
gonna gonna have one one one client so

00:42:11,920 --> 00:42:15,880
whenever we need to reply something we

00:42:13,960 --> 00:42:18,040
put that we put that message into that

00:42:15,880 --> 00:42:19,990
channel and then reddy's is what I was

00:42:18,040 --> 00:42:22,420
gonna go like hey I got something meal

00:42:19,990 --> 00:42:24,910
for somebody and the workers somebody's

00:42:22,420 --> 00:42:27,520
gonna go and grab it and with that with

00:42:24,910 --> 00:42:29,290
with that unique channel Jagga child's

00:42:27,520 --> 00:42:30,700
know how to actually route it back to

00:42:29,290 --> 00:42:37,990
the clients gonna go like okay there you

00:42:30,700 --> 00:42:40,240
go oh sorry

00:42:37,990 --> 00:42:46,300
so have you played with celery at all

00:42:40,240 --> 00:42:48,070
yeah that's kind of like you know a lot

00:42:46,300 --> 00:42:50,170
of the naming conventions that I see

00:42:48,070 --> 00:42:52,150
using like groups channels that kind of

00:42:50,170 --> 00:42:55,270
stuff I see it a lot in terms of just

00:42:52,150 --> 00:42:57,220
like celery implementing AMQP sits thank

00:42:55,270 --> 00:42:59,500
you like it's a message protocol so like

00:42:57,220 --> 00:43:01,210
the future of this the end of trying to

00:42:59,500 --> 00:43:04,510
do you see yourselves trying to push for

00:43:01,210 --> 00:43:06,400
like persistent message protocol or like

00:43:04,510 --> 00:43:08,170
website get message protocol like in

00:43:06,400 --> 00:43:10,930
Django because it could it could grow

00:43:08,170 --> 00:43:12,430
out to include topics and fan outs and I

00:43:10,930 --> 00:43:14,020
can see that kind of stuff happening -

00:43:12,430 --> 00:43:16,540
so it's curious as to where you saw God

00:43:14,020 --> 00:43:19,300
yeah well actually the only thing is

00:43:16,540 --> 00:43:22,240
that Jo Jones is it's it kind of

00:43:19,300 --> 00:43:25,090
resembles her a name PQ but it's really

00:43:22,240 --> 00:43:27,130
not that what he's trying to do is he's

00:43:25,090 --> 00:43:29,260
just trying to give us a an abstraction

00:43:27,130 --> 00:43:31,240
layer for us to actually use something

00:43:29,260 --> 00:43:34,000
like that so all of that is really not

00:43:31,240 --> 00:43:35,350
gonna be a choice is not gonna try to to

00:43:34,000 --> 00:43:37,420
put into there's nothing to try to clash

00:43:35,350 --> 00:43:39,750
on that but for instance well what I've

00:43:37,420 --> 00:43:41,080
been using it for is that I still use

00:43:39,750 --> 00:43:43,510
celery

00:43:41,080 --> 00:43:46,030
so whenever a request comes seen from

00:43:43,510 --> 00:43:47,350
let's say a user voices a button or

00:43:46,030 --> 00:43:49,780
something like that or clicks a button

00:43:47,350 --> 00:43:51,790
then the celery touch will start and

00:43:49,780 --> 00:43:53,980
whenever whenever the certain task needs

00:43:51,790 --> 00:43:54,190
to say something to the to the client it

00:43:53,980 --> 00:43:55,930
will

00:43:54,190 --> 00:43:57,940
just write something to that channel but

00:43:55,930 --> 00:44:02,140
that's that's that's all the involvement

00:43:57,940 --> 00:44:03,910
of janma channel cool so uh if you have

00:44:02,140 --> 00:44:05,950
any other questions these are the ways

00:44:03,910 --> 00:44:08,140
that you can contact me my email my

00:44:05,950 --> 00:44:11,710
Twitter it's a little bit weird and I'm

00:44:08,140 --> 00:44:12,520
always on IRC special thanks to

00:44:11,710 --> 00:44:16,440
everybody

00:44:12,520 --> 00:44:16,440

YouTube URL: https://www.youtube.com/watch?v=2kw8QC8djE4


