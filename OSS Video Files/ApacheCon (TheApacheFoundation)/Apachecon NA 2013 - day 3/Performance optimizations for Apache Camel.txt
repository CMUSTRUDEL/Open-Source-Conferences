Title: Performance optimizations for Apache Camel
Publication date: 2013-10-18
Playlist: Apachecon NA 2013 - day 3
Description: 
	Christian Müller
ApacheCon NA 2013
Caravan
Captions: 
	00:00:00,079 --> 00:00:05,339
yeah welcome to my talk about

00:00:02,780 --> 00:00:11,389
performance optimizations for pet you

00:00:05,339 --> 00:00:11,389
come in before i start i should mention

00:00:11,450 --> 00:00:21,350
i'm jed left so I based in Germany it

00:00:17,789 --> 00:00:24,570
took me 17 hours to come to Portland and

00:00:21,350 --> 00:00:27,150
so we have the time difference from nine

00:00:24,570 --> 00:00:30,090
hours I wake up three o'clock in the

00:00:27,150 --> 00:00:38,960
morning if I make any mistakes so please

00:00:30,090 --> 00:00:41,820
excuse so after brief introduction I

00:00:38,960 --> 00:00:44,969
want to talk about performance

00:00:41,820 --> 00:00:48,030
optimizations for our common components

00:00:44,969 --> 00:00:53,550
and common enterprise integration

00:00:48,030 --> 00:00:56,340
patterns and by doing this I will also

00:00:53,550 --> 00:01:01,710
talk about a few core concepts for

00:00:56,340 --> 00:01:07,189
interfaces and core classes we have in

00:01:01,710 --> 00:01:11,369
camel and you will see during this

00:01:07,189 --> 00:01:14,400
demonstration and at the end we will

00:01:11,369 --> 00:01:19,340
have roughly ten minutes for question

00:01:14,400 --> 00:01:22,439
and answers if I'm running out of time

00:01:19,340 --> 00:01:25,470
I'm here in this room for the rest of

00:01:22,439 --> 00:01:32,320
the day feel free to contact me and ask

00:01:25,470 --> 00:01:36,320
questions okay

00:01:32,320 --> 00:01:38,870
so my name is Christian villa i'm in

00:01:36,320 --> 00:01:41,210
durham at date job i'm in senior

00:01:38,870 --> 00:01:46,040
software developer at artists bloodline

00:01:41,210 --> 00:01:47,960
in frankfurt germany in this company i

00:01:46,040 --> 00:01:50,780
am technically responsible for our

00:01:47,960 --> 00:01:55,340
integration platform which is based on

00:01:50,780 --> 00:01:58,970
service mix and apache cannon since

00:01:55,340 --> 00:02:02,479
almost 11 years I architecture and

00:01:58,970 --> 00:02:05,840
develop enterprise integration solution

00:02:02,479 --> 00:02:11,110
based on Java for the enterprise mostly

00:02:05,840 --> 00:02:14,989
and banking finance and Tycho sector I

00:02:11,110 --> 00:02:18,680
came into contact with camera round

00:02:14,989 --> 00:02:22,880
about four years ago by working on a new

00:02:18,680 --> 00:02:25,250
project I'm in regularly are committed

00:02:22,880 --> 00:02:30,019
sins more than two years and shortly

00:02:25,250 --> 00:02:37,610
after I was invited to join the chem

00:02:30,019 --> 00:02:44,900
bpmc and since the end of 2011 I was

00:02:37,610 --> 00:02:47,930
elected to pisa kemah pmc sham before i

00:02:44,900 --> 00:02:50,989
start my presentation I would like to

00:02:47,930 --> 00:02:54,680
invite you to take part of our

00:02:50,989 --> 00:03:02,209
discussion about chemistry dello it's

00:02:54,680 --> 00:03:05,890
our next major release and we start a

00:03:02,209 --> 00:03:09,010
few discussions a few weeks ago and I

00:03:05,890 --> 00:03:12,950
would like or we would like to know

00:03:09,010 --> 00:03:17,060
audio dislike in camera who you are see

00:03:12,950 --> 00:03:21,100
improvements and which feature you are

00:03:17,060 --> 00:03:25,480
missing and so on so please be involved

00:03:21,100 --> 00:03:29,060
on our mailing list is here tell us your

00:03:25,480 --> 00:03:31,930
ideas your wishes and be part of

00:03:29,060 --> 00:03:31,930
chemistry at all

00:03:32,790 --> 00:03:39,750
okay let's start first I want to show

00:03:37,170 --> 00:03:42,790
some performance optimizations for

00:03:39,750 --> 00:03:46,410
content based routing one of the most

00:03:42,790 --> 00:03:53,770
common enterprise integration patterns

00:03:46,410 --> 00:03:56,980
and in this case I use an XML message

00:03:53,770 --> 00:03:59,920
which looks like this so it's in soap

00:03:56,980 --> 00:04:09,930
message with many many many many orders

00:03:59,920 --> 00:04:09,930
is browned out 10k in size okay i

00:04:10,920 --> 00:04:18,940
started with ya base rod test so that i

00:04:16,750 --> 00:04:25,510
don't have to repeat all the setup for

00:04:18,940 --> 00:04:28,770
each different test I have this class

00:04:25,510 --> 00:04:33,640
extends camera test support this is a

00:04:28,770 --> 00:04:37,260
one class from our test kit which should

00:04:33,640 --> 00:04:40,810
be used if you test your camera out and

00:04:37,260 --> 00:04:46,320
if you don't let us bring on blueprint

00:04:40,810 --> 00:04:46,320
or some other things

00:04:47,180 --> 00:04:59,570
okay so test itself is simple I have a

00:04:55,580 --> 00:05:01,250
template this template is an instance

00:04:59,570 --> 00:05:03,560
variable which comes from the camera

00:05:01,250 --> 00:05:06,620
test support it's a producer template

00:05:03,560 --> 00:05:09,050
and on this producer template I set as

00:05:06,620 --> 00:05:12,229
the default endpoint your eyes Oded I

00:05:09,050 --> 00:05:16,729
don't have to repeat this for each test

00:05:12,229 --> 00:05:22,300
execution then I use simply iou tears

00:05:16,729 --> 00:05:27,440
from comments I owe to read my test file

00:05:22,300 --> 00:05:32,690
into memory then I warm up our system a

00:05:27,440 --> 00:05:39,500
little bit it's done here I use some

00:05:32,690 --> 00:05:44,300
more component set my expectations so I

00:05:39,500 --> 00:05:47,570
expect 10,000 messages and this

00:05:44,300 --> 00:05:50,419
component and I also tell the more

00:05:47,570 --> 00:05:53,930
component as a component should not

00:05:50,419 --> 00:05:57,229
store all the message because if you do

00:05:53,930 --> 00:05:59,630
some large shoulder big test and it's

00:05:57,229 --> 00:06:06,130
possible to run out of memory or have

00:05:59,630 --> 00:06:09,949
some performance impacts then I send

00:06:06,130 --> 00:06:12,220
10,000 messages with this payload two

00:06:09,949 --> 00:06:12,220
days

00:06:13,920 --> 00:06:27,310
direct start end point then I wait until

00:06:21,430 --> 00:06:30,490
all the messages arrived at this end

00:06:27,310 --> 00:06:35,190
point and then i reset my mock end point

00:06:30,490 --> 00:06:40,360
i do this only to warm up my system and

00:06:35,190 --> 00:06:44,370
afterwards I do my real test which is

00:06:40,360 --> 00:06:46,930
really similar and I use a stopwatch to

00:06:44,370 --> 00:06:51,870
measure the time I need for for this

00:06:46,930 --> 00:06:58,180
execution okay let's start with the

00:06:51,870 --> 00:07:03,610
exposure our test as Chi in the previous

00:06:58,180 --> 00:07:05,470
talk say it normally you would in this

00:07:03,610 --> 00:07:09,340
carrier in this place you would

00:07:05,470 --> 00:07:12,340
instantiate your arm yeah you're out

00:07:09,340 --> 00:07:20,250
build up and use this route builder but

00:07:12,340 --> 00:07:26,620
for convenience do not switch too many

00:07:20,250 --> 00:07:29,950
sites i use an anonymous inner route

00:07:26,620 --> 00:07:33,700
better class and describe her out and

00:07:29,950 --> 00:07:40,290
this routes listened on an direct

00:07:33,700 --> 00:07:43,570
standpoint it was choice is a camel

00:07:40,290 --> 00:07:52,750
where to implement content-based router

00:07:43,570 --> 00:07:55,410
i have am sorry i have fear my exposé

00:07:52,750 --> 00:07:55,410
expression

00:08:09,160 --> 00:08:12,030
ok it's

00:08:15,230 --> 00:08:26,300
okay I xpath expression where I look for

00:08:19,160 --> 00:08:29,330
a symbol element with a value IBM and if

00:08:26,300 --> 00:08:35,150
this is the case the message should be

00:08:29,330 --> 00:08:41,470
router to this mock endpoint I think

00:08:35,150 --> 00:08:44,350
it's simple so let's execute this test

00:08:41,470 --> 00:08:47,350
let me first go into this direction a

00:08:44,350 --> 00:08:47,350
directory

00:08:58,279 --> 00:09:04,600
and runs a test

00:09:00,640 --> 00:09:08,350
so the tests are built on I execute his

00:09:04,600 --> 00:09:11,760
test Smith with maven three dot 0 dot 4

00:09:08,350 --> 00:09:11,760
and this Java 7

00:09:24,190 --> 00:09:32,140
okay you will see this test roundabout

00:09:26,890 --> 00:09:37,030
needs eight seconds to send 10,000

00:09:32,140 --> 00:09:39,510
messages to the content-based router now

00:09:37,030 --> 00:09:46,030
it's a message to the right hand point

00:09:39,510 --> 00:09:49,330
not bad but also not good so for the

00:09:46,030 --> 00:09:58,360
next test I don't change anything in my

00:09:49,330 --> 00:10:02,760
route I only include a camera Saxon into

00:09:58,360 --> 00:10:08,200
my class pass because Saxon has a much

00:10:02,760 --> 00:10:15,250
much more better expose engine than so

00:10:08,200 --> 00:10:17,610
on and the JDK and I simply repeat the

00:10:15,250 --> 00:10:17,610
test

00:10:23,070 --> 00:10:30,290
and we will see this test now pass much

00:10:27,750 --> 00:10:30,290
more faster

00:10:33,960 --> 00:10:45,290
it's okay as you can see it needs only

00:10:37,400 --> 00:10:45,290
for not 67 seconds okay

00:10:49,580 --> 00:10:51,640
Oh

00:10:56,380 --> 00:10:59,130
sorry

00:11:02,230 --> 00:11:04,980
ok

00:11:15,059 --> 00:11:20,059
good but not good enough

00:11:21,680 --> 00:11:32,100
so let's try out xquery because section

00:11:27,690 --> 00:11:36,870
has an xquery implementation which is

00:11:32,100 --> 00:11:41,060
also faster than the xpath expression so

00:11:36,870 --> 00:11:46,770
i use the same base rod test class so i

00:11:41,060 --> 00:11:51,510
don't have to go into this again but in

00:11:46,770 --> 00:11:56,070
my Creator out builder now i use xquery

00:11:51,510 --> 00:11:58,980
to define my ex query expression but

00:11:56,070 --> 00:12:03,810
it's the same expression like 4x pass

00:11:58,980 --> 00:12:06,350
and i also sent this or you know these

00:12:03,810 --> 00:12:13,110
messages to the more end point is if

00:12:06,350 --> 00:12:15,680
match to this expression ok let's do

00:12:13,110 --> 00:12:15,680
this test

00:12:32,400 --> 00:12:43,600
and we should see that using xquery is

00:12:37,440 --> 00:12:46,420
again a bit more performant then yeah

00:12:43,600 --> 00:12:53,400
it's a bit more performant than using

00:12:46,420 --> 00:12:53,400
xpath so let's try to make it faster

00:12:57,510 --> 00:13:00,510
another

00:13:05,810 --> 00:13:15,200
language we can use in this case is how

00:13:09,650 --> 00:13:17,090
dt xml how dt xml is GPL so you have to

00:13:15,200 --> 00:13:23,720
think about whether you can use it or

00:13:17,090 --> 00:13:27,020
not and because because it's a GPL we

00:13:23,720 --> 00:13:29,029
host this component at chem Alexa but

00:13:27,020 --> 00:13:32,960
it's officially a patchy can a

00:13:29,029 --> 00:13:41,360
repository and it's also the reason why

00:13:32,960 --> 00:13:47,740
we don't have and.yeah DS l for this

00:13:41,360 --> 00:13:53,540
like four for the xquery or XPath

00:13:47,740 --> 00:13:56,390
expressions but it's not a problem so

00:13:53,540 --> 00:14:00,400
only thing you have to to provide is a

00:13:56,390 --> 00:14:05,450
predicate predicate is and one of the

00:14:00,400 --> 00:14:09,020
core interfaces camel has it's simply an

00:14:05,450 --> 00:14:13,160
interface with one message which takes

00:14:09,020 --> 00:14:17,720
an exchange object and it has to return

00:14:13,160 --> 00:14:24,020
a boolean and it's all so and it's the

00:14:17,720 --> 00:14:29,350
case we implement this we have an XPath

00:14:24,020 --> 00:14:34,270
builder from 4dt xml we use this in our

00:14:29,350 --> 00:14:37,640
wendys are and if this expression

00:14:34,270 --> 00:14:41,920
matched then we send this message to

00:14:37,640 --> 00:14:41,920
this mock endpoint again

00:15:01,870 --> 00:15:16,870
and busy again it's faster okay is it

00:15:10,240 --> 00:15:23,890
possible to be faster there are some

00:15:16,870 --> 00:15:30,910
possibilities one possibility is not to

00:15:23,890 --> 00:15:33,880
use XML xquery X pass things it's we

00:15:30,910 --> 00:15:36,700
could in some cases we can do simple

00:15:33,880 --> 00:15:41,170
things like we can check whether this

00:15:36,700 --> 00:15:44,890
XML has an element with and specific

00:15:41,170 --> 00:15:49,360
where you like this one so I think it's

00:15:44,890 --> 00:15:56,050
easy to understand we take our body and

00:15:49,360 --> 00:16:02,250
check whether this body contains this

00:15:56,050 --> 00:16:02,250
character sequence ok let's try this one

00:16:16,410 --> 00:16:25,079
ok

00:16:19,089 --> 00:16:25,079
less than 600 milliseconds that's fast

00:16:27,059 --> 00:16:37,149
okay and sometimes we also have the

00:16:33,370 --> 00:16:43,839
possibility to route on message headers

00:16:37,149 --> 00:16:46,720
so as you can see here we check whether

00:16:43,839 --> 00:16:49,569
the header routing condition is equals

00:16:46,720 --> 00:16:55,029
to IBM and in this case resent this

00:16:49,569 --> 00:17:00,569
message to this endpoint so let's do

00:16:55,029 --> 00:17:00,569
this last test for this

00:17:02,400 --> 00:17:05,570
arp perdon

00:17:10,530 --> 00:17:15,200
okay you again a little bit faster

00:17:17,790 --> 00:17:26,970
okay if the test I did do I run some of

00:17:23,670 --> 00:17:32,550
such as multiple times I got more or

00:17:26,970 --> 00:17:38,520
less this picture if you use sex part

00:17:32,550 --> 00:17:52,080
from the JDK so that's you should not do

00:17:38,520 --> 00:17:55,740
this oops and yeah so that's a sitz

00:17:52,080 --> 00:18:00,870
times I could measure and the conclusion

00:17:55,740 --> 00:18:02,730
is if you can use conditions based on

00:18:00,870 --> 00:18:06,320
your message header you should do this

00:18:02,730 --> 00:18:10,010
so that says a fastest one if I go back

00:18:06,320 --> 00:18:16,730
so it's round about 500 milliseconds to

00:18:10,010 --> 00:18:21,000
process 10,000 messages with 10 kilobyte

00:18:16,730 --> 00:18:24,930
if it's not possible then check whether

00:18:21,000 --> 00:18:27,420
you can use string contains check with a

00:18:24,930 --> 00:18:31,020
simple language or is some other

00:18:27,420 --> 00:18:36,000
scripting languages if this is not

00:18:31,020 --> 00:18:38,880
possible to think about whether we'd vdt

00:18:36,000 --> 00:18:43,920
XML is possible or not so as I said it's

00:18:38,880 --> 00:18:45,870
GPL license and if there's no spot if

00:18:43,920 --> 00:18:51,000
this is not possible done you with

00:18:45,870 --> 00:18:54,270
xquery and if this is also not possible

00:18:51,000 --> 00:18:57,360
and you have to use X pass then make

00:18:54,270 --> 00:19:05,870
sure you have the Saxon library in your

00:18:57,360 --> 00:19:05,870
classpath okay so next demo is

00:19:07,740 --> 00:19:20,160
about splitter a IP which is also a

00:19:14,250 --> 00:19:20,160
common used pattern

00:19:29,970 --> 00:19:41,850
so I again start with an X pass test so

00:19:37,440 --> 00:19:47,070
this split test extended split based

00:19:41,850 --> 00:19:49,260
test so it's again we set up some

00:19:47,070 --> 00:19:51,780
expected method count in this case we

00:19:49,260 --> 00:19:55,110
expect once ours messages on our mock

00:19:51,780 --> 00:19:58,110
endpoint i configure this make a mock

00:19:55,110 --> 00:20:01,620
endpoint to not store the messages which

00:19:58,110 --> 00:20:04,040
did receive for performance reason then

00:20:01,620 --> 00:20:10,050
I have a stopwatch which I stopped

00:20:04,040 --> 00:20:14,550
because I read of in this test i read a

00:20:10,050 --> 00:20:17,280
file from the file system i configure

00:20:14,550 --> 00:20:18,900
this route to not stop start up

00:20:17,280 --> 00:20:22,800
automatically if i start my camel

00:20:18,900 --> 00:20:27,180
context so let's reason why i start my

00:20:22,800 --> 00:20:32,370
route at this point and then I wait

00:20:27,180 --> 00:20:35,790
until all my messages arrived in my mock

00:20:32,370 --> 00:20:42,320
component and I mean I print out say

00:20:35,790 --> 00:20:45,780
time I needed so this is my my route as

00:20:42,320 --> 00:20:50,490
I fade I read from a file endpoint in

00:20:45,780 --> 00:20:56,280
source test data file I have a 10

00:20:50,490 --> 00:20:59,030
megabyte file which I read and then I

00:20:56,280 --> 00:20:59,030
provide some

00:21:01,380 --> 00:21:13,650
infamous second i provide some other

00:21:06,610 --> 00:21:13,650
options to camera which are useful for

00:21:14,010 --> 00:21:20,430
this unit tests almost done

00:21:22,279 --> 00:21:27,970
No

00:21:24,169 --> 00:21:30,259
okay as a NOP equals true means normally

00:21:27,970 --> 00:21:32,450
camera will pick up a file and after

00:21:30,259 --> 00:21:36,919
finest process can we move it to an

00:21:32,450 --> 00:21:38,330
subdirectory dr. camera and for unit

00:21:36,919 --> 00:21:40,220
test it's not so good because then

00:21:38,330 --> 00:21:42,350
before your can do with the next unit

00:21:40,220 --> 00:21:45,379
test you have to move the file back end

00:21:42,350 --> 00:21:49,700
zone and that's really nice option to

00:21:45,379 --> 00:21:51,590
say camel don't move this file and I

00:21:49,700 --> 00:21:54,139
also use the initial delay equals null

00:21:51,590 --> 00:21:57,230
because by default a camera will wait

00:21:54,139 --> 00:22:04,249
one second before it starts pulling the

00:21:57,230 --> 00:22:09,879
directory okay after i get my file i use

00:22:04,249 --> 00:22:14,720
an xpath expression to to split this in

00:22:09,879 --> 00:22:20,499
in my individual order elements and then

00:22:14,720 --> 00:22:26,749
I send this user to the mock endpoint so

00:22:20,499 --> 00:22:29,679
let's try this with a ex pass let me

00:22:26,749 --> 00:22:29,679
check one thing before

00:22:43,080 --> 00:22:50,690
so I do this test without section in the

00:22:45,720 --> 00:22:50,690
glass pass and

00:22:52,650 --> 00:22:56,070
you will see

00:22:59,149 --> 00:23:02,919
that I get some air balls

00:23:04,990 --> 00:23:07,770
sorry

00:23:17,340 --> 00:23:22,380
so

00:23:19,260 --> 00:23:25,770
I have to stop this test after a few

00:23:22,380 --> 00:23:29,070
seconds because you can see it consumes

00:23:25,770 --> 00:23:33,390
all my memory and it will know it

00:23:29,070 --> 00:23:35,610
doesn't finish the test in one minute so

00:23:33,390 --> 00:23:40,580
again it's really bad idea to use X

00:23:35,610 --> 00:23:40,580
paths with the JDK expose implementation

00:23:42,590 --> 00:23:51,380
ok let's use a section again and do the

00:23:48,900 --> 00:23:51,380
same test

00:24:01,389 --> 00:24:04,769
take a few seconds

00:24:06,690 --> 00:24:15,200
okay 88 or four seconds not bad not good

00:24:15,560 --> 00:24:29,670
okay let's try for the tea XML again so

00:24:24,120 --> 00:24:33,860
this route is really similar we read

00:24:29,670 --> 00:24:41,070
from the same file endpoint be split

00:24:33,860 --> 00:24:43,530
based on this X path builder and yeah

00:24:41,070 --> 00:24:46,880
because then then the messages to the

00:24:43,530 --> 00:24:46,880
same mark endpoint

00:25:01,590 --> 00:25:12,419
okay five dot one second it's a bit

00:25:07,440 --> 00:25:17,789
faster than X pass and last but not

00:25:12,419 --> 00:25:23,429
least form 45 splitting iosif and test

00:25:17,789 --> 00:25:28,380
with with the tokenized xml yeah get

00:25:23,429 --> 00:25:31,470
some simple tokenizing functionality we

00:25:28,380 --> 00:25:41,240
provide from Canada's no library behind

00:25:31,470 --> 00:25:41,240
this and let's test it on

00:25:55,480 --> 00:26:00,990
okay takes a bit longer than 42 xml and

00:26:01,470 --> 00:26:04,890
at the end

00:26:06,950 --> 00:26:19,370
I got a similar result with xpath

00:26:14,510 --> 00:26:23,230
expression JDK I could not process such

00:26:19,370 --> 00:26:27,350
a big XML file so it was 100 megabyte

00:26:23,230 --> 00:26:31,480
where is Saxon it tooks round about

00:26:27,350 --> 00:26:37,279
eight or eight seconds with foul dt xml

00:26:31,480 --> 00:26:41,750
5 21 seconds and we say XML tokenizer 7

00:26:37,279 --> 00:26:44,510
dot 4 seconds I also method as a memory

00:26:41,750 --> 00:26:47,779
footprint and it's also important if you

00:26:44,510 --> 00:26:53,480
process such a big file and as you can

00:26:47,779 --> 00:27:00,169
see the xpath jdk needs one on one

00:26:53,480 --> 00:27:03,260
gigabyte if you use saxon it's only 480

00:27:00,169 --> 00:27:07,039
megabytes this for TT XML it's round

00:27:03,260 --> 00:27:10,519
about two hundred megabyte and if you

00:27:07,039 --> 00:27:16,039
use XML tokenizer it was only eight

00:27:10,519 --> 00:27:18,860
megabyte so my conclusion is if it's

00:27:16,039 --> 00:27:24,830
possible for you to you for TT XML and

00:27:18,860 --> 00:27:29,299
use for dt XML if it's not possible then

00:27:24,830 --> 00:27:31,880
try to use XML to organizer it supports

00:27:29,299 --> 00:27:37,730
namespaces but it has also some

00:27:31,880 --> 00:27:41,299
limitations and if both are not possible

00:27:37,730 --> 00:27:44,659
for you then you can of course use X

00:27:41,299 --> 00:27:48,309
pass but then again sure you have a

00:27:44,659 --> 00:27:48,309
Saxon library in your class pass

00:27:50,269 --> 00:28:05,119
okay for the next example I want to show

00:28:00,440 --> 00:28:11,499
you some marshaling and and unmask

00:28:05,119 --> 00:28:11,499
awning functionality can be provides

00:28:18,340 --> 00:28:26,470
so that's again the base class for this

00:28:21,970 --> 00:28:29,860
test it's very similar like the first

00:28:26,470 --> 00:28:32,500
one I set up my template to send all the

00:28:29,860 --> 00:28:40,690
message to messages to this direct start

00:28:32,500 --> 00:28:45,610
end point I create my java object which

00:28:40,690 --> 00:28:49,900
is shown here it's by a stock's object

00:28:45,610 --> 00:28:53,679
with Jack's p annotations was it Jack's

00:28:49,900 --> 00:29:00,190
p test of course then I put 10 orders in

00:28:53,679 --> 00:29:04,840
his buy stocks object afterwards I warm

00:29:00,190 --> 00:29:08,679
up my system again so I send 10,000

00:29:04,840 --> 00:29:12,990
messages to this mock end point I was it

00:29:08,679 --> 00:29:16,210
my mock end point at the end and then I

00:29:12,990 --> 00:29:20,529
said my expectations again start my

00:29:16,210 --> 00:29:24,340
stopwatch sent all the 10,000 messages

00:29:20,529 --> 00:29:28,140
again stop my watch and check how long

00:29:24,340 --> 00:29:28,140
does it take

00:29:31,270 --> 00:29:36,950
ok

00:29:32,940 --> 00:29:41,360
let's stop with an extreme mashallah

00:29:36,950 --> 00:29:41,360
because Xtreme is well-known

00:29:53,779 --> 00:30:00,229
and by the way all the tests are

00:29:55,460 --> 00:30:03,609
available on github I put it the URL in

00:30:00,229 --> 00:30:03,609
in my slides

00:30:12,930 --> 00:30:20,670
okay as I conceive it took almost three

00:30:17,190 --> 00:30:25,940
seconds to process ponte marshall and

00:30:20,670 --> 00:30:30,360
unmask shall 10,000 messages with

00:30:25,940 --> 00:30:33,120
extreme okay let's check whether we have

00:30:30,360 --> 00:30:40,700
other possibilities another possibility

00:30:33,120 --> 00:30:45,000
is to use XML beans so it's simply

00:30:40,700 --> 00:30:48,600
similar out I read from I direct start

00:30:45,000 --> 00:30:51,930
end point Marsha using XML beans son

00:30:48,600 --> 00:30:56,300
Marshall it back using XML beans and I

00:30:51,930 --> 00:30:56,300
sent this message to smoke n point

00:31:18,250 --> 00:31:26,380
okay to the two seconds a little bit

00:31:21,250 --> 00:31:32,200
faster okay let's see whether we can do

00:31:26,380 --> 00:31:35,320
more of course we have checks beam for

00:31:32,200 --> 00:31:42,540
Jack's p i configure the jacks p data

00:31:35,320 --> 00:31:42,540
formats to use not ready print

00:31:53,820 --> 00:31:58,190
and let's see how fast Jack's piece

00:32:11,010 --> 00:32:21,420
two or four seconds that's not really

00:32:14,520 --> 00:32:26,640
sir let's run it run it again yeah from

00:32:21,420 --> 00:32:29,390
time to time you get some yup bed

00:32:26,640 --> 00:32:36,240
numbers which is not really

00:32:29,390 --> 00:32:38,810
representative representative to the sex

00:32:36,240 --> 00:32:38,810
okay

00:32:41,740 --> 00:32:46,660
I don't want to go through all the

00:32:44,860 --> 00:32:52,780
marshaling and unmask erling

00:32:46,660 --> 00:33:01,200
possibilities we have but i will show

00:32:52,780 --> 00:33:01,200
you two more one is Jackson JS mashallah

00:33:02,190 --> 00:33:10,260
because XML is not the only possibility

00:33:07,690 --> 00:33:10,260
we have

00:33:20,310 --> 00:33:29,760
okay and you can see is much more faster

00:33:22,770 --> 00:33:32,580
only one not one seconds and from either

00:33:29,760 --> 00:33:35,510
interesting question was also how long

00:33:32,580 --> 00:33:38,670
does it take if you use the normal java

00:33:35,510 --> 00:33:41,460
salvation mechanism so good you can also

00:33:38,670 --> 00:33:47,340
do in camera with Marcia I ization and

00:33:41,460 --> 00:33:51,050
unmask authorization okay let's have a

00:33:47,340 --> 00:33:51,050
look how long that does it take

00:34:04,790 --> 00:34:12,790
okay and you can see java theorization

00:34:07,970 --> 00:34:12,790
is not faster than using a sauna spa

00:34:13,990 --> 00:34:24,520
surprised me a little bit but it's good

00:34:18,230 --> 00:34:24,520
to zine okay

00:34:24,899 --> 00:34:35,460
at the end during my test I got the

00:34:30,059 --> 00:34:37,679
following result this is a vm need

00:34:35,460 --> 00:34:42,059
roundabouts wheedled 1 seconds using

00:34:37,679 --> 00:34:44,429
extreme two or three seconds using XML

00:34:42,059 --> 00:34:51,960
beans to the two seconds using Jack's

00:34:44,429 --> 00:34:59,069
beam one that eight seconds using ji

00:34:51,960 --> 00:35:03,150
beaks if you use extreme in Jason it

00:34:59,069 --> 00:35:06,960
took five seconds surprise me also a

00:35:03,150 --> 00:35:10,680
little bit using Jason one or two

00:35:06,960 --> 00:35:13,410
seconds 800 milliseconds or in this case

00:35:10,680 --> 00:35:16,200
now we had one-on-one seconds for

00:35:13,410 --> 00:35:21,390
Jackson and java Sarah's asian one not

00:35:16,200 --> 00:35:25,349
one second okay one thing I have to

00:35:21,390 --> 00:35:27,180
mention is GI bx which was as a fastest

00:35:25,349 --> 00:35:34,559
theorization and easier ization

00:35:27,180 --> 00:35:40,880
mechanism for xml doesn't work with java

00:35:34,559 --> 00:35:44,010
7 really well if you use some list

00:35:40,880 --> 00:35:49,380
elements then you will get some arrows

00:35:44,010 --> 00:35:52,760
that's better but takes the case in this

00:35:49,380 --> 00:35:58,109
case you should consider using Jack's p

00:35:52,760 --> 00:36:02,930
but if you can use a jsf for marshalling

00:35:58,109 --> 00:36:05,250
you should use definitely jackson and

00:36:02,930 --> 00:36:08,490
from my point of view there's no reason

00:36:05,250 --> 00:36:13,220
to use Java Asura's Asian it's not

00:36:08,490 --> 00:36:19,369
interoperable it's not easy to read

00:36:13,220 --> 00:36:24,200
there's no real reason for okay

00:36:19,369 --> 00:36:25,730
in the next example i will show you some

00:36:24,200 --> 00:36:28,480
improvements you can make if you're

00:36:25,730 --> 00:36:28,480
working with files

00:36:53,700 --> 00:36:56,450
ok

00:36:56,480 --> 00:37:12,650
this is my route I will read a file from

00:37:06,230 --> 00:37:19,030
the source test data directory I will

00:37:12,650 --> 00:37:24,670
split this file based on the body and

00:37:19,030 --> 00:37:27,800
backslash n character I stream this body

00:37:24,670 --> 00:37:34,460
to not load the entire file into memory

00:37:27,800 --> 00:37:39,440
and then for each individual line I will

00:37:34,460 --> 00:37:42,280
write this line into a new file in my

00:37:39,440 --> 00:37:42,280
target directory

00:38:21,180 --> 00:38:25,099
I think this test take while

00:38:27,920 --> 00:38:36,220
okay 14 seconds to to process this fire

00:38:37,030 --> 00:38:47,030
it's a lot and the reason why it's not

00:38:40,960 --> 00:38:49,339
it's because for each line we send to

00:38:47,030 --> 00:38:53,000
this file camera will open a new file

00:38:49,339 --> 00:38:55,609
and you write this line into this file

00:38:53,000 --> 00:39:01,510
and close to second so that's a lot of

00:38:55,609 --> 00:39:05,869
file opening and closing things happen

00:39:01,510 --> 00:39:08,410
ok there are a possibility us to improve

00:39:05,869 --> 00:39:08,410
this

00:39:14,510 --> 00:39:26,150
so one possibility to improve this is to

00:39:18,800 --> 00:39:29,240
you as an aggregator in this case we

00:39:26,150 --> 00:39:33,520
fetch one thousand lines together into

00:39:29,240 --> 00:39:36,800
one line or into one exchange object and

00:39:33,520 --> 00:39:39,830
we also configured in completion time

00:39:36,800 --> 00:39:44,000
out of 200 milliseconds which means if

00:39:39,830 --> 00:39:46,940
there is no new messages problem if no

00:39:44,000 --> 00:39:50,480
new message arrived in this aggregation

00:39:46,940 --> 00:39:53,650
aggregator within 200 milliseconds then

00:39:50,480 --> 00:40:00,790
this exchange will be finished and

00:39:53,650 --> 00:40:04,190
flushed then we configured a string

00:40:00,790 --> 00:40:09,410
aggregation strategy that's also one of

00:40:04,190 --> 00:40:12,590
the core interfaces camel has we use

00:40:09,410 --> 00:40:19,160
this in multiple enterprise integration

00:40:12,590 --> 00:40:23,810
patterns likes multicast some enrich arm

00:40:19,160 --> 00:40:26,710
and also in the aggregator and it simply

00:40:23,810 --> 00:40:30,980
has one method aggregate and in this

00:40:26,710 --> 00:40:35,270
aggregate message take two exchanges 10

00:40:30,980 --> 00:40:37,370
it exchange one you exchange and what

00:40:35,270 --> 00:40:43,540
you have to do is to combine those

00:40:37,370 --> 00:40:49,130
exchanges and return one so in this case

00:40:43,540 --> 00:40:52,220
if I receive the first message then the

00:40:49,130 --> 00:40:57,020
oil to exchange will be nigh at this

00:40:52,220 --> 00:41:04,090
case I am reach as data my body from my

00:40:57,020 --> 00:41:04,090
new exchange put is yeah

00:41:04,710 --> 00:41:14,640
put an epic /n before and then return

00:41:07,869 --> 00:41:21,190
the new exchange and for all subsequent

00:41:14,640 --> 00:41:25,390
exchanges I simply append my new

00:41:21,190 --> 00:41:33,610
exchange on the existing body in my

00:41:25,390 --> 00:41:36,600
mileage exchange okay let's test whether

00:41:33,610 --> 00:41:36,600
this is a good idea or not

00:41:48,700 --> 00:41:57,339
and in a few seconds we will see you

00:41:51,420 --> 00:41:59,290
that's not the best idea because they

00:41:57,339 --> 00:42:07,359
have a lot of string concatenation is

00:41:59,290 --> 00:42:16,410
going on at the end this test need some

00:42:07,359 --> 00:42:20,160
little bit more time so 18 seconds ok a

00:42:16,410 --> 00:42:20,160
better thing we could do is

00:42:26,560 --> 00:42:29,370
sorry

00:42:42,070 --> 00:42:51,370
so that's really the same setup with one

00:42:48,700 --> 00:42:56,170
difference in this case use a

00:42:51,370 --> 00:42:59,490
stringbuilder aggregation strategy and

00:42:56,170 --> 00:43:03,190
this stringbuilder aggregation strategy

00:42:59,490 --> 00:43:09,150
use of course a stringbuilder to do all

00:43:03,190 --> 00:43:14,770
the concatenations and we do not

00:43:09,150 --> 00:43:21,090
concatenate so many strings okay let's

00:43:14,770 --> 00:43:21,090
test how fast this is

00:43:34,530 --> 00:43:38,510
ok it's for a second

00:43:38,650 --> 00:43:55,840
if you remember the first time it was 14

00:43:41,500 --> 00:43:58,510
second okay that's the test I made the

00:43:55,840 --> 00:44:01,840
first test was young I lived with more

00:43:58,510 --> 00:44:05,950
than 14 seconds by writing line by line

00:44:01,840 --> 00:44:10,210
to the output file using string

00:44:05,950 --> 00:44:13,960
concatenation and fetching 1000 lines

00:44:10,210 --> 00:44:15,490
together tooks a bit longer but using a

00:44:13,960 --> 00:44:19,860
stringbuilder instead of sinking

00:44:15,490 --> 00:44:19,860
coordination it's four or three seconds

00:44:20,640 --> 00:44:27,640
another possibility in camera is to use

00:44:25,120 --> 00:44:29,800
as a stream component we also have a

00:44:27,640 --> 00:44:36,910
stream component which means the v's

00:44:29,800 --> 00:44:42,100
dream say content into a file and the

00:44:36,910 --> 00:44:47,950
fastest implementation was to use the

00:44:42,100 --> 00:44:50,340
built-in aggregator let me Shh oh you

00:44:47,950 --> 00:44:50,340
this

00:44:58,570 --> 00:45:01,170
so

00:45:02,160 --> 00:45:10,079
this is this line which is a bit

00:45:04,200 --> 00:45:14,309
different if you use a split a AP chem

00:45:10,079 --> 00:45:19,880
normally use a default aggregation

00:45:14,309 --> 00:45:24,299
strategy which will send the file which

00:45:19,880 --> 00:45:26,220
comes to the splitter to the next

00:45:24,299 --> 00:45:30,109
endpoints after the splitter after

00:45:26,220 --> 00:45:34,109
splitting is done but you can also

00:45:30,109 --> 00:45:38,670
provide your own aggregation strategy

00:45:34,109 --> 00:45:41,190
that's what I did in this case the

00:45:38,670 --> 00:45:46,849
advantage is you don't have to configure

00:45:41,190 --> 00:45:49,410
how big the bed should be or not because

00:45:46,849 --> 00:45:53,809
there's a split component knows when

00:45:49,410 --> 00:45:53,809
other elements are splitted and finished

00:46:01,540 --> 00:46:10,150
okay the conclusion is use an aggregator

00:46:04,570 --> 00:46:13,900
to reduce the number of file exes and if

00:46:10,150 --> 00:46:16,450
it's possible to use a bit in one down

00:46:13,900 --> 00:46:21,700
men made some cases that is not possible

00:46:16,450 --> 00:46:23,710
if this file is too big and of course

00:46:21,700 --> 00:46:31,960
use a string builder to concatenate

00:46:23,710 --> 00:46:34,440
strings so the next one is using

00:46:31,960 --> 00:46:34,440
databases

00:46:44,530 --> 00:46:52,000
so in camel graphs as I mentioned we

00:46:48,760 --> 00:46:55,660
have multiple components to talk to a

00:46:52,000 --> 00:47:06,120
database for this example I use sequent

00:46:55,660 --> 00:47:12,130
component so this test is really simple

00:47:06,120 --> 00:47:15,130
in my setup method I am use a embedded

00:47:12,130 --> 00:47:19,330
database paid off from spring to setup

00:47:15,130 --> 00:47:24,370
and embedded Derby database and to

00:47:19,330 --> 00:47:29,080
analogy initialize my database I also

00:47:24,370 --> 00:47:34,690
put my datasource into my registry this

00:47:29,080 --> 00:47:41,530
is because my endpoint your eye for my

00:47:34,690 --> 00:47:44,130
secret component I have to provide as a

00:47:41,530 --> 00:47:44,130
data source

00:47:48,200 --> 00:47:56,599
so just test it's triggered again by a

00:47:51,589 --> 00:47:59,750
direct start and point and it will

00:47:56,599 --> 00:48:05,720
execute in insert statement into my auto

00:47:59,750 --> 00:48:09,530
table this component expects yeah a list

00:48:05,720 --> 00:48:15,550
or an iterable and for each of my

00:48:09,530 --> 00:48:18,650
elements I will replace this and then

00:48:15,550 --> 00:48:22,099
sets send a message to the mock endpoint

00:48:18,650 --> 00:48:25,160
so that my unit test knows okay when all

00:48:22,099 --> 00:48:32,589
the messages are processed and the other

00:48:25,160 --> 00:48:35,150
stuff is like for the other tests so

00:48:32,589 --> 00:48:43,510
this is my list object i use for this

00:48:35,150 --> 00:48:43,510
test I said some values and then I do

00:48:43,690 --> 00:48:48,040
again 10,000 iterations

00:49:24,460 --> 00:49:35,470
okay as you can see three or four

00:49:28,480 --> 00:49:41,589
seconds in this test we have a similar

00:49:35,470 --> 00:49:45,430
issue like writing entries line by line

00:49:41,589 --> 00:49:49,690
into a file we have a lot a lot of i/o

00:49:45,430 --> 00:49:57,520
traffic and one thing to improve this is

00:49:49,690 --> 00:50:04,810
again to use in to you as an educator so

00:49:57,520 --> 00:50:11,080
in this case it betch together 10

00:50:04,810 --> 00:50:16,839
messages and sent it to a database which

00:50:11,080 --> 00:50:19,800
reduce amount of the number of database

00:50:16,839 --> 00:50:19,800
course we have to do

00:50:25,010 --> 00:50:32,480
and of course in this example I use an

00:50:28,010 --> 00:50:35,330
embedded database in real life you have

00:50:32,480 --> 00:50:37,730
to talk about tcp/ip with your database

00:50:35,330 --> 00:50:41,060
which means the difference you will see

00:50:37,730 --> 00:50:44,270
is much more larger and as we can see

00:50:41,060 --> 00:50:48,380
here now it takes only one or three

00:50:44,270 --> 00:50:54,640
seconds to send all the 10,000 entries

00:50:48,380 --> 00:51:00,020
to the database so as numbers I measured

00:50:54,640 --> 00:51:03,680
was this one if i write sentries record

00:51:00,020 --> 00:51:08,150
by record i need round about 32 seconds

00:51:03,680 --> 00:51:10,400
if I betch this together it doesn't

00:51:08,150 --> 00:51:13,810
really matter whether it's ten one

00:51:10,400 --> 00:51:13,810
hundred or thousand records

00:51:17,570 --> 00:51:22,520
yeah as a conclusion again is to use an

00:51:20,150 --> 00:51:27,050
aggregator to patch together the

00:51:22,520 --> 00:51:32,750
messages and yeah limit the database

00:51:27,050 --> 00:51:40,370
access because I'm running a little bit

00:51:32,750 --> 00:51:44,990
out of time I will only show you some

00:51:40,370 --> 00:51:48,860
some code examples and don't execute so

00:51:44,990 --> 00:51:53,090
test another possibility you have in

00:51:48,860 --> 00:52:01,850
camel is as a threat dsl which is really

00:51:53,090 --> 00:52:06,940
useful if you want to process some

00:52:01,850 --> 00:52:12,470
messages in parallel let's start with

00:52:06,940 --> 00:52:17,300
this one so in this case you again Paul

00:52:12,470 --> 00:52:20,860
a directory written file we have an

00:52:17,300 --> 00:52:25,640
processor which simulate some expensive

00:52:20,860 --> 00:52:30,590
processing and at the end we will send

00:52:25,640 --> 00:52:33,170
this message to the mock endpoint so bad

00:52:30,590 --> 00:52:36,890
thing here is that chemical pick up the

00:52:33,170 --> 00:52:41,600
next file only after this file is

00:52:36,890 --> 00:52:46,940
process which means after one second if

00:52:41,600 --> 00:52:55,100
you use such Fred's dsl be introduced

00:52:46,940 --> 00:53:00,050
and thread pool and camel will run in 10

00:52:55,100 --> 00:53:02,810
parallel threads to to process this

00:53:00,050 --> 00:53:07,250
message which means the pickup's of fire

00:53:02,810 --> 00:53:10,450
hand it over to a thread and then go

00:53:07,250 --> 00:53:10,450
back and with the next file

00:53:15,940 --> 00:53:23,620
by doing this you can see that it of

00:53:21,220 --> 00:53:26,980
course depends how many threats you

00:53:23,620 --> 00:53:31,300
configured you can speed up or paralyze

00:53:26,980 --> 00:53:37,230
your execution and by using 10 threads

00:53:31,300 --> 00:53:37,230
you can see okay it needs more or less

00:53:37,440 --> 00:53:55,060
yeah if i don't use this thread TSL i

00:53:47,460 --> 00:53:57,430
eat 10 times more yeah if it's possible

00:53:55,060 --> 00:54:03,040
to paralyze your reactor and use threats

00:53:57,430 --> 00:54:05,640
teaser another example is using

00:54:03,040 --> 00:54:09,130
templates it's also commonly used to

00:54:05,640 --> 00:54:11,590
sending some males you normally use a

00:54:09,130 --> 00:54:18,070
rel 0 CT template or free make a

00:54:11,590 --> 00:54:21,280
template or a string template these are

00:54:18,070 --> 00:54:27,220
the three template mechanism camel

00:54:21,280 --> 00:54:30,000
provides out of the box they are all

00:54:27,220 --> 00:54:30,000
really similar

00:54:31,710 --> 00:54:37,770
as you can see here I read again a

00:54:34,830 --> 00:54:41,060
message from a dialogue endpoint in this

00:54:37,770 --> 00:54:45,359
case I call my free maker template I

00:54:41,060 --> 00:54:47,910
cause a free maker component which will

00:54:45,359 --> 00:54:50,940
pick up this free make a template to

00:54:47,910 --> 00:54:52,710
choose a string replacement and then

00:54:50,940 --> 00:54:55,859
send the message to the Mexican point or

00:54:52,710 --> 00:54:59,990
can point the templates are really

00:54:55,859 --> 00:55:06,200
similar I have text I have some

00:54:59,990 --> 00:55:06,200
expressions and that's all

00:55:09,560 --> 00:55:15,890
so I did the test for for this trees

00:55:11,660 --> 00:55:21,560
component and as a string template was

00:55:15,890 --> 00:55:24,830
the one which takes most of time sweet

00:55:21,560 --> 00:55:27,550
old one second and Sophie maker template

00:55:24,830 --> 00:55:32,480
engine was fastest one this one second

00:55:27,550 --> 00:55:35,410
to process 10,000 messages okay the

00:55:32,480 --> 00:55:39,110
conclusion is prepare free maker or

00:55:35,410 --> 00:55:46,790
velocity and turned us sistering

00:55:39,110 --> 00:55:51,310
templates okay because then also has and

00:55:46,790 --> 00:55:56,930
talk about Canada and seeks after day i

00:55:51,310 --> 00:56:01,610
do not go into detail in this but the

00:55:56,930 --> 00:56:04,520
conclusion is if you use zxf make sure

00:56:01,610 --> 00:56:07,790
you have woodstock in your class pass

00:56:04,520 --> 00:56:11,240
because woodstock is much more much more

00:56:07,790 --> 00:56:17,770
performant stacks engine than the one

00:56:11,240 --> 00:56:17,770
from the jdk and think about whether

00:56:20,369 --> 00:56:26,190
you need the Java object for your

00:56:23,279 --> 00:56:31,799
further processing or whether you only

00:56:26,190 --> 00:56:34,619
need XML payload or the entire soap

00:56:31,799 --> 00:56:39,630
message because in this case we can skip

00:56:34,619 --> 00:56:42,900
the unmarked shala step and of course

00:56:39,630 --> 00:56:45,359
you have to fine tune your container

00:56:42,900 --> 00:56:49,490
cheerio tomcat and to use the right

00:56:45,359 --> 00:56:49,490
settings for your connector acceptor and

00:56:58,400 --> 00:57:04,210
I also prepared a demo for messaging

00:57:20,630 --> 00:57:29,100
okay one thing you should know about JMS

00:57:24,870 --> 00:57:32,580
component is if you have to use as in

00:57:29,100 --> 00:57:37,440
out message exchange pattern committed

00:57:32,580 --> 00:57:40,280
by default us and temper IQ this is the

00:57:37,440 --> 00:57:40,280
case if you were

00:57:46,720 --> 00:57:53,320
in this way you only send your message

00:57:50,260 --> 00:57:54,930
shown in out q and listen on the

00:57:53,320 --> 00:58:03,099
response and after response received

00:57:54,930 --> 00:58:06,070
kind of process this exchange further if

00:58:03,099 --> 00:58:13,300
you use an explicitly configured reply

00:58:06,070 --> 00:58:17,250
to Q then make sure you use apply to

00:58:13,300 --> 00:58:23,220
type equals exclusive if I can use this

00:58:17,250 --> 00:58:27,670
this will speed up your listening part

00:58:23,220 --> 00:58:30,910
or set in received time out which fits

00:58:27,670 --> 00:58:34,030
your needs by default camel has an

00:58:30,910 --> 00:58:35,770
received timeout from one second which

00:58:34,030 --> 00:58:38,080
means if I put a message into a queue

00:58:35,770 --> 00:58:42,630
camera the start after one second to

00:58:38,080 --> 00:58:45,099
read the response which is in most cases

00:58:42,630 --> 00:58:46,510
not really performant because you

00:58:45,099 --> 00:58:52,119
receive your response after a few

00:58:46,510 --> 00:58:54,369
millions a concern but if there's no

00:58:52,119 --> 00:59:01,060
reason not to use a temporary Q's then

00:58:54,369 --> 00:59:08,130
he was temporary queues and if you can

00:59:01,060 --> 00:59:11,290
really write your out to use in only

00:59:08,130 --> 00:59:14,800
message exchange pattern then use this

00:59:11,290 --> 00:59:17,230
because this is much more faster because

00:59:14,800 --> 00:59:19,089
you don't have to to wait for the

00:59:17,230 --> 00:59:24,599
response of the second queue before you

00:59:19,089 --> 00:59:26,530
can process this flow so in this case i

00:59:24,599 --> 00:59:30,010
configure the second router is

00:59:26,530 --> 00:59:36,190
concurrent consumers equals five and at

00:59:30,010 --> 00:59:38,950
the end yeah it's round about five times

00:59:36,190 --> 00:59:41,790
faster because i achieve some parallel

00:59:38,950 --> 00:59:41,790
processing here

00:59:42,230 --> 00:59:50,109
i also have an example about a new s JMS

00:59:47,090 --> 00:59:55,910
component coming with chemical at eleven

00:59:50,109 --> 00:59:58,820
there you can do some things for

00:59:55,910 --> 01:00:01,869
the consumer and producer which means

00:59:58,820 --> 01:00:06,950
the produce our consent and list to the

01:00:01,869 --> 01:00:08,960
sgm s endpoint and CMS endpoint will

01:00:06,950 --> 01:00:11,630
iterate over this list and send all the

01:00:08,960 --> 01:00:14,660
messages to the broker and on the

01:00:11,630 --> 01:00:17,240
consumer part we have suppose ability to

01:00:14,660 --> 01:00:20,090
make some veg acknowledgments so we

01:00:17,240 --> 01:00:22,490
don't acknowledge each and every message

01:00:20,090 --> 01:00:25,040
so you can configure it in this way that

01:00:22,490 --> 01:00:29,000
you consume 100 or 1000 messages and

01:00:25,040 --> 01:00:33,910
then Santa commit what is faster then

01:00:29,000 --> 01:00:33,910
commit each and every using your message

01:00:35,760 --> 01:00:45,810
okay so as I see the code is available

01:00:39,180 --> 01:00:49,140
on github try it out I hope you could

01:00:45,810 --> 01:00:52,620
see it it's not so complicated to set up

01:00:49,140 --> 01:00:55,640
some some tests with scanner to your own

01:00:52,620 --> 01:01:00,180
performance tests for your own needs and

01:00:55,640 --> 01:01:02,780
see what works best for you so now I'm

01:01:00,180 --> 01:01:02,780
open for questions

01:01:13,750 --> 01:01:16,290
the best way

01:01:27,450 --> 01:01:36,840
i would say it really depends on your

01:01:29,730 --> 01:01:39,440
out I think I cannot answer this for for

01:01:36,840 --> 01:01:39,440
all use cases

01:01:43,579 --> 01:01:46,999

YouTube URL: https://www.youtube.com/watch?v=g-ebJiLzqgU


