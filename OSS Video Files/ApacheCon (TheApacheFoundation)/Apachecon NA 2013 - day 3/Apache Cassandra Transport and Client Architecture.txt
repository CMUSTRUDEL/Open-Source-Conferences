Title: Apache Cassandra Transport and Client Architecture
Publication date: 2013-10-18
Playlist: Apachecon NA 2013 - day 3
Description: 
	Nate McCall
ApacheCon NA 2013
Cassandra
Captions: 
	00:00:00,500 --> 00:00:04,170
we're going to talk about Cassandra from

00:00:02,730 --> 00:00:09,510
the client and the transport

00:00:04,170 --> 00:00:12,300
architecture perspective my name is Nate

00:00:09,510 --> 00:00:14,730
I worked at Apogee arm the platform

00:00:12,300 --> 00:00:16,139
development lead for app services team

00:00:14,730 --> 00:00:20,189
there I've been working with Cassandra

00:00:16,139 --> 00:00:22,949
for about three years now I'm coming up

00:00:20,189 --> 00:00:26,099
on for the lead developer for Hector the

00:00:22,949 --> 00:00:28,289
primary java client side of doing this

00:00:26,099 --> 00:00:33,239
for a couple years I know a little bit

00:00:28,289 --> 00:00:36,360
out clients and transports here Apogee

00:00:33,239 --> 00:00:38,610
real quick does API analytics bakit into

00:00:36,360 --> 00:00:40,320
service we have eight asf licensed open

00:00:38,610 --> 00:00:42,360
source project called user grid that's a

00:00:40,320 --> 00:00:45,930
pretty cool blah blah blah I don't like

00:00:42,360 --> 00:00:49,430
thunder pictures either so clients and

00:00:45,930 --> 00:00:52,199
transports an Apache Cassandra um but

00:00:49,430 --> 00:00:55,949
real quick who's using Cassandra right

00:00:52,199 --> 00:01:03,149
now in production okay not that made

00:00:55,949 --> 00:01:04,229
people um who's Justin cql okay how many

00:01:03,149 --> 00:01:08,520
you been using center for more than a

00:01:04,229 --> 00:01:13,380
year does it raise your hands okay cool

00:01:08,520 --> 00:01:14,640
so few people all right um take a quick

00:01:13,380 --> 00:01:16,259
step back and look some high-level

00:01:14,640 --> 00:01:18,060
architectural stuff we're going to need

00:01:16,259 --> 00:01:21,720
to stand understand for the scope of

00:01:18,060 --> 00:01:24,360
this discussion cassandra is what's

00:01:21,720 --> 00:01:26,729
called a sparsely columnar datastore um

00:01:24,360 --> 00:01:30,600
that's just a fancy way of saying that

00:01:26,729 --> 00:01:34,890
how when you have a DBMS in a way our

00:01:30,600 --> 00:01:38,369
dbms to stores tables is that you end up

00:01:34,890 --> 00:01:40,740
storing information like your table

00:01:38,369 --> 00:01:42,329
structure external through the data and

00:01:40,740 --> 00:01:43,829
you have to map the data usually in a

00:01:42,329 --> 00:01:45,869
b-tree and so you end up with stuff like

00:01:43,829 --> 00:01:51,509
null on disk and you have to reserve

00:01:45,869 --> 00:01:52,860
space for the snowfields the Cassandra

00:01:51,509 --> 00:01:54,570
does things a little bit differently

00:01:52,860 --> 00:01:56,670
where if the data is not there it's not

00:01:54,570 --> 00:01:59,040
stored this is what's meant by the

00:01:56,670 --> 00:02:02,610
sparsely part and the columnar structure

00:01:59,040 --> 00:02:05,070
itself is something that is can be

00:02:02,610 --> 00:02:08,840
dynamic so in one set of rows we have

00:02:05,070 --> 00:02:11,480
you know privo defines of modeling cats

00:02:08,840 --> 00:02:13,160
next set of rows maybe we have all

00:02:11,480 --> 00:02:15,230
within the same you know table structure

00:02:13,160 --> 00:02:18,050
that we can have entirely different

00:02:15,230 --> 00:02:19,849
columns and values so that that's pretty

00:02:18,050 --> 00:02:23,540
powerful and again if Dean is not there

00:02:19,849 --> 00:02:24,890
it's not stored or you know on the end

00:02:23,540 --> 00:02:27,080
of that field I could just as easily put

00:02:24,890 --> 00:02:32,120
a blob if I wanted to buzz in that type

00:02:27,080 --> 00:02:34,370
of thing the data modeling and Cassandra

00:02:32,120 --> 00:02:37,010
therefore is really just how you take

00:02:34,370 --> 00:02:39,920
advantage of the columnar data structure

00:02:37,010 --> 00:02:44,060
there just sort of for common patterns

00:02:39,920 --> 00:02:47,150
or even fall I'm gonna detail three of

00:02:44,060 --> 00:02:49,940
them here's four times sake the simple

00:02:47,150 --> 00:02:51,560
object to row bars objects to Rose

00:02:49,940 --> 00:02:55,250
materialized views and what's called a

00:02:51,560 --> 00:02:56,470
manual index a lot of presentations out

00:02:55,250 --> 00:02:58,430
there have only this first three I

00:02:56,470 --> 00:03:01,310
usually like to add that last one

00:02:58,430 --> 00:03:02,930
because there seems to be a kind of calm

00:03:01,310 --> 00:03:07,190
patterns emerging about how that works

00:03:02,930 --> 00:03:11,360
so let's look at the first three simple

00:03:07,190 --> 00:03:13,910
object to row it's pretty easy easy to

00:03:11,360 --> 00:03:14,840
grok um that's just a static column

00:03:13,910 --> 00:03:17,329
family like we had in the previous

00:03:14,840 --> 00:03:20,239
example sparse objects are a little more

00:03:17,329 --> 00:03:22,190
interesting like our previous examples

00:03:20,239 --> 00:03:26,540
say it such as modeling cats you wanna

00:03:22,190 --> 00:03:28,130
model pets right so I have a water

00:03:26,540 --> 00:03:31,209
temperature there it's only really

00:03:28,130 --> 00:03:34,579
relevant for a fish and I have a type

00:03:31,209 --> 00:03:37,160
every row needs to have a tight maybe

00:03:34,579 --> 00:03:39,349
I'm deducing in my application maybe

00:03:37,160 --> 00:03:40,400
that's how I do like an hibernate or

00:03:39,349 --> 00:03:43,340
something like that how i do

00:03:40,400 --> 00:03:45,530
discriminators um do something similar

00:03:43,340 --> 00:03:46,639
your application level but nobody else

00:03:45,530 --> 00:03:49,579
needs to have a water temperature if is

00:03:46,639 --> 00:03:54,049
not fish so i can store that and i can

00:03:49,579 --> 00:03:56,169
store that efficiently and this is what

00:03:54,049 --> 00:03:58,069
we refer to as dynamic all families

00:03:56,169 --> 00:03:59,989
materialized views are a little

00:03:58,069 --> 00:04:02,419
different um as those you generally find

00:03:59,989 --> 00:04:04,489
an time series data like a weblog

00:04:02,419 --> 00:04:07,040
storage is a common usage pattern so i

00:04:04,489 --> 00:04:09,799
have a key that sort of loosely models

00:04:07,040 --> 00:04:13,160
like a date structure yesterday at ten o

00:04:09,799 --> 00:04:14,180
3 and five seconds mouse toward those

00:04:13,160 --> 00:04:16,340
log lines

00:04:14,180 --> 00:04:17,900
then at 1003 in 10 seconds I store some

00:04:16,340 --> 00:04:19,579
different log rods so that that makes

00:04:17,900 --> 00:04:25,240
querying really efficient because those

00:04:19,579 --> 00:04:28,280
things just lay on a disk in order and a

00:04:25,240 --> 00:04:30,050
previous you keegan-michael did a good

00:04:28,280 --> 00:04:32,389
job of touching on sort of how the reeds

00:04:30,050 --> 00:04:33,979
work there so I'm not going to go into

00:04:32,389 --> 00:04:35,900
that there's a lot of information out

00:04:33,979 --> 00:04:38,090
there if you really want to know how the

00:04:35,900 --> 00:04:41,870
reeds come off the disk but just know

00:04:38,090 --> 00:04:43,460
that that this that any of these data

00:04:41,870 --> 00:04:47,270
models that this is how the data sets on

00:04:43,460 --> 00:04:49,430
disk so regardless of the approach we

00:04:47,270 --> 00:04:50,389
use there are four overall goals when

00:04:49,430 --> 00:04:56,330
you try to design something for

00:04:50,389 --> 00:04:59,139
Cassandra you normalize right joins are

00:04:56,330 --> 00:05:01,009
expensive joins its joins don't scale

00:04:59,139 --> 00:05:04,639
anybody tells you different cell

00:05:01,009 --> 00:05:07,400
insulting you try to eliminate seeks any

00:05:04,639 --> 00:05:09,979
design for reads and optimize for blind

00:05:07,400 --> 00:05:12,530
rights then that's really the way to

00:05:09,979 --> 00:05:16,039
fully take advantage of a common or data

00:05:12,530 --> 00:05:19,789
store like this so with that background

00:05:16,039 --> 00:05:22,099
let's take a look at protocols um the

00:05:19,789 --> 00:05:25,250
current one the traditional protocol is

00:05:22,099 --> 00:05:27,050
a patchy thrift been around for a while

00:05:25,250 --> 00:05:28,760
it's been with Cassandra since the

00:05:27,050 --> 00:05:30,289
beginning because it came out of

00:05:28,760 --> 00:05:33,289
Facebook Cassandra itself came out of

00:05:30,289 --> 00:05:36,710
Facebook it's referred to

00:05:33,289 --> 00:05:38,060
interchangeably as API and the protocol

00:05:36,710 --> 00:05:41,510
because that's essentially how earth

00:05:38,060 --> 00:05:45,470
works so thrift is our pc based which is

00:05:41,510 --> 00:05:47,120
uh interesting by itself some patchy

00:05:45,470 --> 00:05:49,130
project it's been around for a little

00:05:47,120 --> 00:05:50,509
while i'm going to came out facebook its

00:05:49,130 --> 00:05:53,740
and uses a lot of internal

00:05:50,509 --> 00:05:56,030
infrastructure and a bunch of companies

00:05:53,740 --> 00:05:58,789
supports a lot of languages there's a

00:05:56,030 --> 00:06:00,949
lot of uh that's easy to make an object

00:05:58,789 --> 00:06:03,259
definition and then compile it and have

00:06:00,949 --> 00:06:05,300
it spit out for your language it's

00:06:03,259 --> 00:06:06,949
extensible you can extend the thrift

00:06:05,300 --> 00:06:09,289
methods in Cassandra if you know how to

00:06:06,949 --> 00:06:11,659
do it datastax Enterprise actually works

00:06:09,289 --> 00:06:13,430
this way there's a couple other projects

00:06:11,659 --> 00:06:15,500
out there that do something similar we

00:06:13,430 --> 00:06:21,530
do something similar internally for some

00:06:15,500 --> 00:06:24,590
bar things so then they're cql which is

00:06:21,530 --> 00:06:25,449
as a protocol goes is shiny brand-new

00:06:24,590 --> 00:06:28,180
it's a

00:06:25,449 --> 00:06:29,620
um well defined binary protocol there's

00:06:28,180 --> 00:06:31,749
an excellent documentation out there

00:06:29,620 --> 00:06:36,939
that's on the wiki that details how the

00:06:31,749 --> 00:06:39,309
protocol works it supports compression

00:06:36,939 --> 00:06:41,469
which is interesting by itself you can

00:06:39,309 --> 00:06:44,259
turn that on and enable that and thrift

00:06:41,469 --> 00:06:46,509
but it's not straightforward and the way

00:06:44,259 --> 00:06:48,370
the thrift to sort of been shoved around

00:06:46,509 --> 00:06:51,249
and hacked and Cassandra makes it sort

00:06:48,370 --> 00:06:55,719
of arduous task and it's not it have to

00:06:51,249 --> 00:06:59,759
be some hacking to do that it's based on

00:06:55,719 --> 00:07:02,259
Nettie and nioh arm which is a really

00:06:59,759 --> 00:07:04,569
sort of a good idea because that's

00:07:02,259 --> 00:07:07,389
become the winning horse and a lot of

00:07:04,569 --> 00:07:09,639
the you know java api out there not in a

00:07:07,389 --> 00:07:13,330
patrick patchy project but is the solid

00:07:09,639 --> 00:07:14,379
solid api it's been around for years and

00:07:13,330 --> 00:07:18,039
a lot of people in our project know what

00:07:14,379 --> 00:07:20,560
they're doing so the two protocols there

00:07:18,039 --> 00:07:23,860
let's look at actual storage mechanics

00:07:20,560 --> 00:07:26,020
of how both of those interface with the

00:07:23,860 --> 00:07:28,629
data model that we looked at UM get

00:07:26,020 --> 00:07:30,580
slice this I'm just going to detail this

00:07:28,629 --> 00:07:31,930
one again there's any number

00:07:30,580 --> 00:07:34,419
presentations out there about how this

00:07:31,930 --> 00:07:36,610
works on the Internet has covered a lil

00:07:34,419 --> 00:07:38,529
bit before but at most and reread

00:07:36,610 --> 00:07:40,569
methods are all the scenery methods are

00:07:38,529 --> 00:07:41,949
permutations of this largely they all

00:07:40,569 --> 00:07:44,499
hit the same method eventually in

00:07:41,949 --> 00:07:46,389
storage proxy so this is a thrift

00:07:44,499 --> 00:07:49,569
definition and sort of all its glory and

00:07:46,389 --> 00:07:53,680
all its ugliness um you know it does

00:07:49,569 --> 00:07:55,060
what it does and as we go through this

00:07:53,680 --> 00:07:57,249
here it's pretty easy to see that okay I

00:07:55,060 --> 00:07:58,629
need a key to do you know let's get

00:07:57,249 --> 00:08:00,909
slice to pull some columns off the disk

00:07:58,629 --> 00:08:02,979
I didn't call impaired I need to know

00:08:00,909 --> 00:08:06,279
what what column family our table I'm

00:08:02,979 --> 00:08:08,830
cornering the slides predicate is like a

00:08:06,279 --> 00:08:10,839
query predicate this is what defines the

00:08:08,830 --> 00:08:13,719
row range I'm looking for and what

00:08:10,839 --> 00:08:15,069
columns I'm looking for and then start

00:08:13,719 --> 00:08:16,930
more interesting and these were covered

00:08:15,069 --> 00:08:19,120
in presentations previous presentations

00:08:16,930 --> 00:08:20,469
as well it's easy to spend minutes on

00:08:19,120 --> 00:08:23,259
this but i'm not going to is consistency

00:08:20,469 --> 00:08:27,189
level on each operation is can define

00:08:23,259 --> 00:08:32,800
its own consistency level so this seems

00:08:27,189 --> 00:08:35,050
at first glance it kind of is but we

00:08:32,800 --> 00:08:37,089
take a step back and then look at why

00:08:35,050 --> 00:08:38,649
sequel was created to address some of

00:08:37,089 --> 00:08:44,079
these perceived problems of

00:08:38,649 --> 00:08:45,550
usability um somewhat like this is one

00:08:44,079 --> 00:08:48,069
person's abstraction linkages in those

00:08:45,550 --> 00:08:53,619
data is another preferred method of rien

00:08:48,069 --> 00:08:55,119
data so when looking at these two api's

00:08:53,619 --> 00:08:56,709
it's really a matter of how closely you

00:08:55,119 --> 00:09:00,490
want to understand and interact with the

00:08:56,709 --> 00:09:02,529
storage a Michaels presentation early to

00:09:00,490 --> 00:09:05,160
excellent job of sign summing up sort of

00:09:02,529 --> 00:09:08,889
the new changes and how the schema works

00:09:05,160 --> 00:09:10,300
so take a look at that as and I'll go in

00:09:08,889 --> 00:09:13,110
a little bit of detail there about not

00:09:10,300 --> 00:09:15,129
as much of what's going on but just some

00:09:13,110 --> 00:09:17,230
from perspective of what you need to

00:09:15,129 --> 00:09:21,579
know is a application developer working

00:09:17,230 --> 00:09:25,709
on this stuff so back to where we are

00:09:21,579 --> 00:09:29,139
with the look at the client api's um so

00:09:25,709 --> 00:09:31,889
working with rift the benefits you have

00:09:29,139 --> 00:09:34,660
are as mature selection clients there's

00:09:31,889 --> 00:09:37,240
not one not two but three really mature

00:09:34,660 --> 00:09:39,009
Java clients out there that have been

00:09:37,240 --> 00:09:42,220
two of them had been in the water for

00:09:39,009 --> 00:09:45,429
years and years for three years this

00:09:42,220 --> 00:09:50,439
point you have Hector which is one my

00:09:45,429 --> 00:09:52,029
project and I'm not gonna marinade

00:09:50,439 --> 00:09:56,050
Dominic's project and I feel bad she's a

00:09:52,029 --> 00:09:59,259
good guy nasty onyx is netflix on what's

00:09:56,050 --> 00:10:01,629
Dominic's project that one there's

00:09:59,259 --> 00:10:04,809
there's third one out there I haven't

00:10:01,629 --> 00:10:07,120
can remember life of me and then you

00:10:04,809 --> 00:10:09,249
have a ste onyx which is a sort of the

00:10:07,120 --> 00:10:10,889
new client and probably like an S next

00:10:09,249 --> 00:10:13,209
best hope for thrift I'm pretty much in

00:10:10,889 --> 00:10:15,579
patch maintenance mode on Hector I don't

00:10:13,209 --> 00:10:17,410
have time to devote to it and netflix

00:10:15,579 --> 00:10:19,149
has like three people on asti onyx and

00:10:17,410 --> 00:10:25,410
it's it's a solid client if you want to

00:10:19,149 --> 00:10:28,569
do throughout so multiple languages um

00:10:25,410 --> 00:10:29,679
there's drivers out there for a lot of

00:10:28,569 --> 00:10:32,470
stuff there's a lot of people than

00:10:29,679 --> 00:10:33,910
hacking on a civet over the years it's

00:10:32,470 --> 00:10:35,790
well documented there's a lot of

00:10:33,910 --> 00:10:37,660
tutorials there's a lot of a

00:10:35,790 --> 00:10:38,920
documentation on the truth methods

00:10:37,660 --> 00:10:41,679
themselves strangely as one of the few

00:10:38,920 --> 00:10:44,230
paces there are and you can use drift in

00:10:41,679 --> 00:10:45,930
other places in your architecture and a

00:10:44,230 --> 00:10:47,790
lot of a lot of places do I think

00:10:45,930 --> 00:10:51,510
has extensive thrift deployment

00:10:47,790 --> 00:10:54,570
internally as does a square given that

00:10:51,510 --> 00:10:58,350
they Brian duxbury work sir um the

00:10:54,570 --> 00:11:00,750
drawbacks of thrift are that as we saw

00:10:58,350 --> 00:11:04,370
net get slice you have to compose

00:11:00,750 --> 00:11:07,290
several objects for any request you do

00:11:04,370 --> 00:11:10,770
some of the api's have gone to great

00:11:07,290 --> 00:11:12,450
lengths to hide this but in doing so

00:11:10,770 --> 00:11:14,730
they get quite different in their

00:11:12,450 --> 00:11:16,529
implementations so what you're doing in

00:11:14,730 --> 00:11:17,970
Ruby looks wildly different from what

00:11:16,529 --> 00:11:20,370
you're doing in Java is not at all what

00:11:17,970 --> 00:11:22,410
you're doing at Python and if you have

00:11:20,370 --> 00:11:23,670
seen a sword polyglot develop it going

00:11:22,410 --> 00:11:28,649
on in your shop that's kind of a big

00:11:23,670 --> 00:11:30,690
deal and something you think about and

00:11:28,649 --> 00:11:32,670
there's upstream dependency issues this

00:11:30,690 --> 00:11:34,589
is not project directly under control of

00:11:32,670 --> 00:11:37,020
Apache and if you actually open the

00:11:34,589 --> 00:11:39,480
transports and Cassandra source code

00:11:37,020 --> 00:11:43,830
there's there's comments in there like

00:11:39,480 --> 00:11:46,110
fix for thrift 631 you know ssl issue

00:11:43,830 --> 00:11:47,820
hat like sidehack for this because you

00:11:46,110 --> 00:11:50,339
know you couldnt get above taking up

00:11:47,820 --> 00:11:51,900
spring and like a cast of habits when

00:11:50,339 --> 00:11:53,520
you have like a core dependent seen it's

00:11:51,900 --> 00:11:55,230
you know upstream project is not moving

00:11:53,520 --> 00:11:57,510
the same velocity you are removing a

00:11:55,230 --> 00:12:00,300
different way so that's something to

00:11:57,510 --> 00:12:02,760
think about not the case we c ql because

00:12:00,300 --> 00:12:04,830
it's a language defined as a binary

00:12:02,760 --> 00:12:07,529
protocol so that's really not an issue

00:12:04,830 --> 00:12:12,150
of dealing with you know project

00:12:07,529 --> 00:12:14,070
dependencies schema changes in cluster

00:12:12,150 --> 00:12:16,200
health needs to be done proactively and

00:12:14,070 --> 00:12:19,529
we'll show you a bit more on this when

00:12:16,200 --> 00:12:21,750
you go into the benefits of CQ well but

00:12:19,529 --> 00:12:23,910
there's you have to actually proactively

00:12:21,750 --> 00:12:26,580
query from these AP is it's like how the

00:12:23,910 --> 00:12:28,279
cluster doing or all the nodes up are

00:12:26,580 --> 00:12:30,720
the reins kima changes what's going on

00:12:28,279 --> 00:12:34,920
as opposed to having that state pushed

00:12:30,720 --> 00:12:38,160
back over a channel and so that gets us

00:12:34,920 --> 00:12:40,380
in the benefits of the c ql api stored

00:12:38,160 --> 00:12:41,940
procedures is one that's that's really

00:12:40,380 --> 00:12:44,459
compelling if you do a lot of small

00:12:41,940 --> 00:12:47,040
tight reads this is an awesome feature

00:12:44,459 --> 00:12:49,320
it is faster it goes it works very well

00:12:47,040 --> 00:12:52,620
and a lot of people do a lot of time on

00:12:49,320 --> 00:12:54,270
to this the common operations are really

00:12:52,620 --> 00:12:55,980
straightforward to do if you're just

00:12:54,270 --> 00:12:57,750
doing like really granular selects

00:12:55,980 --> 00:13:00,209
against static on families it works

00:12:57,750 --> 00:13:02,649
really well

00:13:00,209 --> 00:13:04,930
cluster health and schema changes are

00:13:02,649 --> 00:13:07,060
pushed back over the NAIA channel this

00:13:04,930 --> 00:13:09,120
might go on into this in presentation I

00:13:07,060 --> 00:13:12,160
can't emphasize how big a deal this is

00:13:09,120 --> 00:13:14,709
when you have a large cluster in the

00:13:12,160 --> 00:13:16,480
water and a large number of web edits

00:13:14,709 --> 00:13:18,850
hitting that like app web applications

00:13:16,480 --> 00:13:20,440
or whatever getting that health sent

00:13:18,850 --> 00:13:24,220
back and forth over the wire and be able

00:13:20,440 --> 00:13:26,019
to you know make make adjustments in

00:13:24,220 --> 00:13:31,120
your application code after receiving

00:13:26,019 --> 00:13:33,310
messages is huge the fact that they

00:13:31,120 --> 00:13:34,510
built that in is just that makes it I'd

00:13:33,310 --> 00:13:36,760
put that downs of benefit here is

00:13:34,510 --> 00:13:38,079
there's awesome client available and

00:13:36,760 --> 00:13:40,000
talking with Michael and looking what

00:13:38,079 --> 00:13:42,730
Michael and Sylvain have done you know

00:13:40,000 --> 00:13:44,290
I'm building this client out is um it's

00:13:42,730 --> 00:13:45,639
really like everything I would have done

00:13:44,290 --> 00:13:48,430
if I had a chance to start from a clean

00:13:45,639 --> 00:13:50,380
slate and I can't emphasize that enough

00:13:48,430 --> 00:13:53,110
it's this really is a solid piece of

00:13:50,380 --> 00:13:55,389
software for anything like along these

00:13:53,110 --> 00:13:57,940
lawns it's certainly worth looking at

00:13:55,389 --> 00:14:00,970
depending on your workload and what

00:13:57,940 --> 00:14:08,470
you're trying to do so that gets a sense

00:14:00,970 --> 00:14:11,680
of the drawbacks of cql API you still

00:14:08,470 --> 00:14:13,449
have videomatic clients still about a

00:14:11,680 --> 00:14:16,420
binary protocol so you still need client

00:14:13,449 --> 00:14:23,589
to run and parse it and generate queries

00:14:16,420 --> 00:14:25,899
and send us over the wire except you

00:14:23,589 --> 00:14:29,139
still have a default in the default

00:14:25,899 --> 00:14:31,870
storage model exposes some substantial

00:14:29,139 --> 00:14:34,720
restrictions I have a gotcha Sun and

00:14:31,870 --> 00:14:37,720
poses some substantial restrictions have

00:14:34,720 --> 00:14:39,250
a gauzy section on this later but we'll

00:14:37,720 --> 00:14:41,500
get into that in more detail but first

00:14:39,250 --> 00:14:43,829
let's let's look at just high-level

00:14:41,500 --> 00:14:47,380
considerations for your application

00:14:43,829 --> 00:14:51,370
stick with drift if you have heavy

00:14:47,380 --> 00:14:53,319
update workloads there's some

00:14:51,370 --> 00:14:56,680
shenanigans going on the c ql created

00:14:53,319 --> 00:14:58,750
tables to generate some sort of

00:14:56,680 --> 00:15:00,760
extraneous marker rose that can fill up

00:14:58,750 --> 00:15:03,180
space pretty quickly under some

00:15:00,760 --> 00:15:03,180
conditions

00:15:03,620 --> 00:15:09,360
dynamic large batch and searches if you

00:15:07,050 --> 00:15:11,160
do lots of large insertions of like time

00:15:09,360 --> 00:15:13,560
series data for like web logs like one

00:15:11,160 --> 00:15:15,839
of the examples we've shown seek where

00:15:13,560 --> 00:15:17,610
you know one insertion can have a

00:15:15,839 --> 00:15:19,290
hundred mutations another assertion can

00:15:17,610 --> 00:15:23,670
have you know several thousand mutations

00:15:19,290 --> 00:15:26,760
back-to-back it's not trivial to write

00:15:23,670 --> 00:15:29,430
the cql for that you basically have to

00:15:26,760 --> 00:15:32,070
generate a large string concatenated the

00:15:29,430 --> 00:15:33,120
expressions and pump those over the wire

00:15:32,070 --> 00:15:36,930
you can't use the stored procedure

00:15:33,120 --> 00:15:38,880
because the store procedure has that I

00:15:36,930 --> 00:15:40,950
have an issue link to hear in a

00:15:38,880 --> 00:15:42,779
different section um the stored

00:15:40,950 --> 00:15:43,950
procedure can't take a dynamic number of

00:15:42,779 --> 00:15:45,240
batch insertions there's an open issue

00:15:43,950 --> 00:15:47,430
for that it'll get worked on eventually

00:15:45,240 --> 00:15:50,190
but it's not there yet Hadoop

00:15:47,430 --> 00:15:54,029
integration the all Hadoop tools big

00:15:50,190 --> 00:15:57,360
hive Hadoop can't read the cql table

00:15:54,029 --> 00:15:59,460
definitions 4421 is issue for that if

00:15:57,360 --> 00:16:03,150
you want to track that that's also open

00:15:59,460 --> 00:16:05,910
no progress on that if you commonly deal

00:16:03,150 --> 00:16:08,070
with a really wide rows for the same

00:16:05,910 --> 00:16:10,320
sort of reason so there's there's no

00:16:08,070 --> 00:16:12,750
real benefit to using cql because the

00:16:10,320 --> 00:16:19,140
rows are named store procedures don't

00:16:12,750 --> 00:16:21,540
work so it one of the things here to

00:16:19,140 --> 00:16:23,880
also know is that you know we're we

00:16:21,540 --> 00:16:27,839
write wide rows with cql is that you

00:16:23,880 --> 00:16:30,209
have to do things like as you saw in

00:16:27,839 --> 00:16:32,640
michael's presentation is when you set

00:16:30,209 --> 00:16:35,490
up the table and pick you know the key

00:16:32,640 --> 00:16:37,170
that you're going to share it on you

00:16:35,490 --> 00:16:41,930
have to pick that shard key carefully

00:16:37,170 --> 00:16:45,839
and you know as I've seen this language

00:16:41,930 --> 00:16:47,370
before and I saw this on am a list you

00:16:45,839 --> 00:16:49,070
know when we first started talking about

00:16:47,370 --> 00:16:51,930
this not something my cellphone wherever

00:16:49,070 --> 00:16:57,860
I heard that before you know it sounds

00:16:51,930 --> 00:16:57,860
like you know let's pick our sharkeez oh

00:16:58,220 --> 00:17:01,910
that's where I've seen that before

00:17:02,370 --> 00:17:08,199
you know I did something I i don't i

00:17:05,740 --> 00:17:10,270
don't like that that that's an issue

00:17:08,199 --> 00:17:12,480
that that's a real big issue now going

00:17:10,270 --> 00:17:15,730
to talk a little more about that later

00:17:12,480 --> 00:17:17,980
so consider cql if you have a lot of

00:17:15,730 --> 00:17:19,419
static column families the take

00:17:17,980 --> 00:17:20,650
advantage of store procedures for common

00:17:19,419 --> 00:17:27,280
reads they're faster they're a lot

00:17:20,650 --> 00:17:29,260
faster compressed wire format despite

00:17:27,280 --> 00:17:30,880
the Sharkey jab the cql make does make

00:17:29,260 --> 00:17:33,070
it use of storage engine the way the

00:17:30,880 --> 00:17:34,870
roads are laid out again see Michaels

00:17:33,070 --> 00:17:38,919
presentation for just the way that

00:17:34,870 --> 00:17:40,750
structured you can replace some custom

00:17:38,919 --> 00:17:42,880
serialization with the collection stuff

00:17:40,750 --> 00:17:45,039
that's available now that's pretty slick

00:17:42,880 --> 00:17:48,190
there's a lot that's could be useful to

00:17:45,039 --> 00:17:50,470
some people it's really easy to

00:17:48,190 --> 00:17:53,080
integrate with jdbc and bi tools given

00:17:50,470 --> 00:17:55,030
that it's a query language and that's

00:17:53,080 --> 00:17:56,710
sort of what's been the goal along on

00:17:55,030 --> 00:17:59,470
the data stacks roadmap is to make that

00:17:56,710 --> 00:18:00,760
easy to use for enterprise developers if

00:17:59,470 --> 00:18:02,799
you're a large enterprise shop this

00:18:00,760 --> 00:18:08,740
might make sense for you because it's

00:18:02,799 --> 00:18:10,630
going to be a big one cql is also really

00:18:08,740 --> 00:18:13,090
wire efficient doesn't return to

00:18:10,630 --> 00:18:18,100
timestamp or TTL by default yet dad vs

00:18:13,090 --> 00:18:19,720
explicitly which does could burn you

00:18:18,100 --> 00:18:21,580
know 64 bytes each on the wire with

00:18:19,720 --> 00:18:26,950
you're doing a high rework load that's

00:18:21,580 --> 00:18:28,480
you know that adds up so larger

00:18:26,950 --> 00:18:30,880
potentially more transient environments

00:18:28,480 --> 00:18:32,710
if you have large clusters with nodes

00:18:30,880 --> 00:18:36,159
going in and out the ring state push

00:18:32,710 --> 00:18:39,520
back and the schema change stuff that

00:18:36,159 --> 00:18:43,090
that's that's a good idea that they

00:18:39,520 --> 00:18:44,860
provide a lot of benefits for you um the

00:18:43,090 --> 00:18:47,289
data stacks driver again takes a gossip

00:18:44,860 --> 00:18:50,950
listeners and lessons for ring state

00:18:47,289 --> 00:18:53,380
changes and gets notifications of when

00:18:50,950 --> 00:18:57,429
their schema updates and capaces around

00:18:53,380 --> 00:18:59,950
and you know make decisions application

00:18:57,429 --> 00:19:01,330
level based on that and you can do this

00:18:59,950 --> 00:19:03,210
with rift as well but again you have to

00:19:01,330 --> 00:19:06,730
be proactive you have to make that query

00:19:03,210 --> 00:19:07,870
explicitly and a lot of the client

00:19:06,730 --> 00:19:09,380
libraries out there at least hector

00:19:07,870 --> 00:19:12,800
nasty onyx will both

00:19:09,380 --> 00:19:14,930
go out and run like a background thread

00:19:12,800 --> 00:19:17,270
every 10 seconds or configurable number

00:19:14,930 --> 00:19:18,650
of seconds to say you know query ring

00:19:17,270 --> 00:19:21,020
state and make sure that all the hosts

00:19:18,650 --> 00:19:25,970
are still up into a looker can see if

00:19:21,020 --> 00:19:28,970
there's many schema changes etc but at

00:19:25,970 --> 00:19:33,350
the end of day this cql this newish um

00:19:28,970 --> 00:19:35,870
and it's an abstraction this abstraction

00:19:33,350 --> 00:19:40,640
model over some hidden match nations in

00:19:35,870 --> 00:19:42,230
the storage engine that you know because

00:19:40,640 --> 00:19:44,240
it's new because it's abstractions

00:19:42,230 --> 00:19:47,000
there's going to there are there have

00:19:44,240 --> 00:19:51,230
been in there will be bugs nature of the

00:19:47,000 --> 00:19:53,350
beast and and general but some cases it

00:19:51,230 --> 00:19:56,000
might not do what you think it should um

00:19:53,350 --> 00:19:58,790
because this abstraction there's going

00:19:56,000 --> 00:20:00,980
to be in penis mismatches so there's

00:19:58,790 --> 00:20:03,560
some pitfalls to be aware of the most

00:20:00,980 --> 00:20:04,970
common ones and some of the most sort of

00:20:03,560 --> 00:20:07,810
severe ones that stuck out to me and

00:20:04,970 --> 00:20:09,710
researching this past month of do whirl

00:20:07,810 --> 00:20:13,760
collections can only be retrieved in

00:20:09,710 --> 00:20:15,650
their entirety like that's sort of okay

00:20:13,760 --> 00:20:20,420
so you have maps he upsets um plis but

00:20:15,650 --> 00:20:22,280
if I want you know number you know 20 of

00:20:20,420 --> 00:20:25,130
a 50 item list to have to go down there

00:20:22,280 --> 00:20:29,320
if I want member you know 200 of a 5,000

00:20:25,130 --> 00:20:32,570
item list you know you get the idea that

00:20:29,320 --> 00:20:34,910
it is documented that is probably not a

00:20:32,570 --> 00:20:37,190
good idea for larger rose but it's it

00:20:34,910 --> 00:20:38,210
can give you the wrong idea they're

00:20:37,190 --> 00:20:42,320
certainly not a replacement for

00:20:38,210 --> 00:20:43,670
materialized views in a column but there

00:20:42,320 --> 00:20:44,960
are eyes to be fair they are a good

00:20:43,670 --> 00:20:47,120
replacement if you're doing a lot of

00:20:44,960 --> 00:20:49,990
your own custom serialization within a

00:20:47,120 --> 00:20:52,490
rose it's a good way to think of that

00:20:49,990 --> 00:20:55,070
and that gets us another big issues you

00:20:52,490 --> 00:20:58,930
can't mix static and dive data in a

00:20:55,070 --> 00:21:01,640
column family so when either original

00:20:58,930 --> 00:21:03,530
data modeling use cases we saw their the

00:21:01,640 --> 00:21:05,030
sparse objects you can't do that with

00:21:03,530 --> 00:21:07,190
cql because every column needs a name

00:21:05,030 --> 00:21:12,970
you know you'd have to name every column

00:21:07,190 --> 00:21:15,260
for your entire data model to do

00:21:12,970 --> 00:21:16,820
discriminators type stuff and that that

00:21:15,260 --> 00:21:20,450
could be a pain to but if that's what

00:21:16,820 --> 00:21:21,690
you're doing keys only arrange slices

00:21:20,450 --> 00:21:24,120
don't work this

00:21:21,690 --> 00:21:26,519
is a is all over the place than some of

00:21:24,120 --> 00:21:28,080
my code for what we do there's a really

00:21:26,519 --> 00:21:29,879
efficient way to check for existence of

00:21:28,080 --> 00:21:31,230
rose and Cassandra and not have to touch

00:21:29,879 --> 00:21:34,230
the Cubs on the disk where you just

00:21:31,230 --> 00:21:36,269
touch the key index I recommend you look

00:21:34,230 --> 00:21:38,610
at that issue if that's the use case you

00:21:36,269 --> 00:21:39,990
use or something you think would work in

00:21:38,610 --> 00:21:43,909
your app because it's kind of a big deal

00:21:39,990 --> 00:21:46,320
if you make use of it a lot also

00:21:43,909 --> 00:21:49,710
arguably a feature is that range goats

00:21:46,320 --> 00:21:52,799
aren't returned anymore and thrift when

00:21:49,710 --> 00:21:55,019
you delete a column you still will get

00:21:52,799 --> 00:21:57,090
that column and every we need elite a

00:21:55,019 --> 00:21:59,490
row you still get that row in a response

00:21:57,090 --> 00:22:00,870
back with no columns um if you've been

00:21:59,490 --> 00:22:02,309
using Cassandra for a long time you know

00:22:00,870 --> 00:22:03,389
this and you've accounted for this in

00:22:02,309 --> 00:22:06,450
your code and you probably have a lot of

00:22:03,389 --> 00:22:07,950
legacy code to deal with this again

00:22:06,450 --> 00:22:09,360
arguably this is a feature because it's

00:22:07,950 --> 00:22:12,509
sort of a payment of pain in her butt

00:22:09,360 --> 00:22:13,919
but at the same time it's different from

00:22:12,509 --> 00:22:15,960
what you'd anticipate it as an

00:22:13,919 --> 00:22:18,570
experienced cassandra user it's just

00:22:15,960 --> 00:22:19,529
just not what you would think and you

00:22:18,570 --> 00:22:21,950
might have some code out there it's

00:22:19,529 --> 00:22:24,059
designed to deal specifically with this

00:22:21,950 --> 00:22:27,899
so that's just something to be aware of

00:22:24,059 --> 00:22:32,580
um batch in search or clunky but talked

00:22:27,899 --> 00:22:35,009
about that and that you can't say I'm

00:22:32,580 --> 00:22:37,769
going to do a stored procedure you can't

00:22:35,009 --> 00:22:40,049
say I'm going to do a vestige of inserts

00:22:37,769 --> 00:22:42,720
in 1 and 10 and the other you have to

00:22:40,049 --> 00:22:45,600
define those two separately which sort

00:22:42,720 --> 00:22:49,230
of negates the benefit as a way batch

00:22:45,600 --> 00:22:50,759
mutate works in a way I performance

00:22:49,230 --> 00:22:52,110
right rights works and gets inspected

00:22:50,759 --> 00:22:54,509
you know some of the four original

00:22:52,110 --> 00:22:55,740
reasons why we designed Cassandra

00:22:54,509 --> 00:22:58,379
databases way we do is you have to

00:22:55,740 --> 00:23:01,559
optimize for blind rights you can't do

00:22:58,379 --> 00:23:03,350
it with cql it's difficult you have to

00:23:01,559 --> 00:23:05,370
compose those statements with

00:23:03,350 --> 00:23:06,870
concatenation of strings the same way

00:23:05,370 --> 00:23:09,419
you would or like some sort of builder

00:23:06,870 --> 00:23:12,139
object under the hood which is you might

00:23:09,419 --> 00:23:16,710
as well be doing mutations at that point

00:23:12,139 --> 00:23:19,110
and that's when a blue this is a big

00:23:16,710 --> 00:23:22,710
deal with non compact storage a whole

00:23:19,110 --> 00:23:26,159
row must be read every time now this is

00:23:22,710 --> 00:23:29,340
the the pseudo row 2 is in there in the

00:23:26,159 --> 00:23:31,110
road chunking not the shard robisz it's

00:23:29,340 --> 00:23:33,029
super important to know that if you have

00:23:31,110 --> 00:23:33,670
like a biggish object like 20 fields in

00:23:33,029 --> 00:23:36,700
the only one

00:23:33,670 --> 00:23:39,120
field one you know name that you're

00:23:36,700 --> 00:23:41,050
still going to get those 20 fields back

00:23:39,120 --> 00:23:43,860
regardless they need to be read

00:23:41,050 --> 00:23:47,200
regardless of which one you want to do

00:23:43,860 --> 00:23:49,360
and so that this may not be something

00:23:47,200 --> 00:23:52,810
that you want to do depending on how you

00:23:49,360 --> 00:23:54,580
use your data to take away from this is

00:23:52,810 --> 00:24:00,610
that you have some options particularly

00:23:54,580 --> 00:24:02,440
good ones for java you have the really

00:24:00,610 --> 00:24:05,080
solid datastax client that sort of built

00:24:02,440 --> 00:24:06,700
on what has been learned over the past

00:24:05,080 --> 00:24:12,090
couple years use cases and what

00:24:06,700 --> 00:24:14,230
everyone's doing a solid and and

00:24:12,090 --> 00:24:16,480
currently high velocity development

00:24:14,230 --> 00:24:18,010
client for netflix has a lot of tricks

00:24:16,480 --> 00:24:20,500
in it can do like binary object

00:24:18,010 --> 00:24:23,580
serialization write ahead logging so you

00:24:20,500 --> 00:24:25,920
can do client-side a failure blogging

00:24:23,580 --> 00:24:28,240
bunch of neat little tricks like that

00:24:25,920 --> 00:24:29,560
Hector's been around for a while again

00:24:28,240 --> 00:24:31,120
we're just in patch maintenance mode at

00:24:29,560 --> 00:24:32,740
this point but it's solid there's very

00:24:31,120 --> 00:24:33,700
few bugs there now and it's well

00:24:32,740 --> 00:24:35,500
understood and there's a number of

00:24:33,700 --> 00:24:39,700
examples of how to use it it's got a big

00:24:35,500 --> 00:24:41,620
community so wake do is you know turn on

00:24:39,700 --> 00:24:44,800
both the transports see which one works

00:24:41,620 --> 00:24:45,670
best for you they're both options and

00:24:44,800 --> 00:24:48,280
you know this is a standard

00:24:45,670 --> 00:24:49,600
configuration file for one dot too so if

00:24:48,280 --> 00:24:51,700
you can turn these both on and play

00:24:49,600 --> 00:24:56,040
around at the same time I'm on different

00:24:51,700 --> 00:24:56,040
ports and see we see what you like so

00:24:59,929 --> 00:25:06,320
take another set because i have no

00:25:01,820 --> 00:25:09,190
section here it's sort of going to

00:25:06,320 --> 00:25:12,950
ruffle some feathers the past year

00:25:09,190 --> 00:25:14,480
working to Apogee so i've been went from

00:25:12,950 --> 00:25:17,029
you know in the trenches of dealing with

00:25:14,480 --> 00:25:18,529
api's and cassandra that booth way out

00:25:17,029 --> 00:25:21,590
to the edge where i'm doing nothing but

00:25:18,529 --> 00:25:25,279
working with developers on you know rest

00:25:21,590 --> 00:25:30,350
endpoints learned a lot about what

00:25:25,279 --> 00:25:33,200
developers particularly one when you've

00:25:30,350 --> 00:25:34,429
seen what we've seen at of apogee in

00:25:33,200 --> 00:25:35,720
terms of how people want to use

00:25:34,429 --> 00:25:37,460
Cassandra we've had a couple big

00:25:35,720 --> 00:25:39,619
customers come to us with what we're

00:25:37,460 --> 00:25:41,600
doing with user grid and say gee that's

00:25:39,619 --> 00:25:44,419
sort of exactly how I want to use

00:25:41,600 --> 00:25:45,799
Cassandra and just in conversations I've

00:25:44,419 --> 00:25:49,490
had with friends you know the past

00:25:45,799 --> 00:25:51,289
couple of months particularly over cql

00:25:49,490 --> 00:25:54,889
and the directions is obtained taken is

00:25:51,289 --> 00:25:56,389
um you know most developers want to

00:25:54,889 --> 00:25:57,769
interact with services they want the

00:25:56,389 --> 00:26:01,460
services to not be in a way and they

00:25:57,769 --> 00:26:03,529
want them to be familiar so I think

00:26:01,460 --> 00:26:07,009
there's like a larger problem here that

00:26:03,529 --> 00:26:07,879
the sort of fundamental to shape the

00:26:07,009 --> 00:26:12,110
community where we're going in the

00:26:07,879 --> 00:26:15,799
future what I've seen from real users

00:26:12,110 --> 00:26:17,600
you know some of these people send these

00:26:15,799 --> 00:26:18,980
people are custom customers of you know

00:26:17,600 --> 00:26:21,350
large dome sequel vendors and caused me

00:26:18,980 --> 00:26:25,340
to like really rethink how I want to

00:26:21,350 --> 00:26:30,200
persist tough um and this next slide I'm

00:26:25,340 --> 00:26:31,340
going to show is you know as hasn't put

00:26:30,200 --> 00:26:33,789
it up here but I really think you need

00:26:31,340 --> 00:26:33,789
to be out there

00:26:38,100 --> 00:26:48,100
that's real quote that's an issue i

00:26:44,380 --> 00:26:50,800
think is a big problem this is another

00:26:48,100 --> 00:26:56,410
thing i think the market spoken and you

00:26:50,800 --> 00:27:00,460
know we made a new wheel and we made it

00:26:56,410 --> 00:27:02,790
square it seems like every other than a

00:27:00,460 --> 00:27:06,280
sequel vendor out there has you know

00:27:02,790 --> 00:27:10,240
rest dead points and that's how people

00:27:06,280 --> 00:27:12,540
want to work with you know data sources

00:27:10,240 --> 00:27:15,940
at this point everyone understands this

00:27:12,540 --> 00:27:19,230
this is this is easy people get that you

00:27:15,940 --> 00:27:19,230
could do this from a JavaScript client

00:27:19,770 --> 00:27:23,920
this actually fits with one of the

00:27:21,910 --> 00:27:25,770
funnel must when the fundamental

00:27:23,920 --> 00:27:28,510
characteristics of Cassandra iden pose

00:27:25,770 --> 00:27:31,570
also how many HTTP clients do you think

00:27:28,510 --> 00:27:34,600
there are out there now not only do not

00:27:31,570 --> 00:27:38,670
have the protocol language problem you

00:27:34,600 --> 00:27:38,670
don't have the client problem anymore

00:27:38,940 --> 00:27:43,660
Sandra MVP actually maintains a

00:27:41,530 --> 00:27:45,850
restaurant end there's two large dataset

00:27:43,660 --> 00:27:47,679
customers actually run dressed service

00:27:45,850 --> 00:27:51,220
infrastructures hacked on topic a sander

00:27:47,679 --> 00:27:54,760
in production people are doing this

00:27:51,220 --> 00:27:58,210
anyway and I think this is something

00:27:54,760 --> 00:28:01,120
we've just missed the boat on and and

00:27:58,210 --> 00:28:04,120
looking at this with internally apogee

00:28:01,120 --> 00:28:05,170
this is one thing we hit on one thing we

00:28:04,120 --> 00:28:07,690
realize will work better for our

00:28:05,170 --> 00:28:09,490
workloads so we've gone and done

00:28:07,690 --> 00:28:13,990
something about this is we've actually

00:28:09,490 --> 00:28:17,590
created an internal project in

00:28:13,990 --> 00:28:20,050
development right now that is just pure

00:28:17,590 --> 00:28:23,700
experimentation like what would happen

00:28:20,050 --> 00:28:27,880
if we did you know a couple things like

00:28:23,700 --> 00:28:30,160
what if we left the operation is to be

00:28:27,880 --> 00:28:32,679
defined in JSON payloads completely

00:28:30,160 --> 00:28:34,030
where you could group any set of

00:28:32,679 --> 00:28:35,290
operations together the same payload

00:28:34,030 --> 00:28:38,110
that you wanted to and send them to an

00:28:35,290 --> 00:28:39,820
end point as a post and say that you

00:28:38,110 --> 00:28:42,040
know I want to insert five columns I

00:28:39,820 --> 00:28:44,670
want to take the results that insert and

00:28:42,040 --> 00:28:44,670
apply them to

00:28:45,260 --> 00:28:50,300
a get operation down in the next below

00:28:48,860 --> 00:28:52,880
that and then I want to take the results

00:28:50,300 --> 00:28:54,680
that get operation and take some jet

00:28:52,880 --> 00:28:57,110
some JavaScript i just uploaded in this

00:28:54,680 --> 00:28:58,760
pay well as payload as well and do some

00:28:57,110 --> 00:29:02,450
dynamic transformation on that before i

00:28:58,760 --> 00:29:03,710
return to results back to the client so

00:29:02,450 --> 00:29:05,390
we started messing around with this and

00:29:03,710 --> 00:29:07,370
there's a project out there that we're

00:29:05,390 --> 00:29:09,710
going to talk about a lot in the next

00:29:07,370 --> 00:29:10,760
month or so i'm working with a couple

00:29:09,710 --> 00:29:13,040
different people who are really popular

00:29:10,760 --> 00:29:16,280
in community on this call an introvert

00:29:13,040 --> 00:29:17,540
is based on vertex in Cassandra ACF

00:29:16,280 --> 00:29:19,010
license and it's been driven by

00:29:17,540 --> 00:29:20,450
real-world requirements people in the

00:29:19,010 --> 00:29:24,890
trenches has been writing cassander apps

00:29:20,450 --> 00:29:25,850
for a long time so you'll be hearing a

00:29:24,890 --> 00:29:29,360
lot more about this in the next couple

00:29:25,850 --> 00:29:31,340
weeks March joining us particularly at

00:29:29,360 --> 00:29:32,330
the data stack summit cocina NYC is

00:29:31,340 --> 00:29:36,670
going to be the sort of the coming-out

00:29:32,330 --> 00:29:38,600
party for this so it'd be kind of neat

00:29:36,670 --> 00:29:39,980
that said after I rent out a couple

00:29:38,600 --> 00:29:54,730
parades anybody have any questions about

00:29:39,980 --> 00:29:54,730
client transport stuff do

00:29:56,559 --> 00:30:01,749
it's a real easy one it's the cql client

00:30:00,129 --> 00:30:02,980
that you recommended basically if you

00:30:01,749 --> 00:30:06,610
would have built it yourself you would

00:30:02,980 --> 00:30:09,789
have did the same way so I just need the

00:30:06,610 --> 00:30:12,940
the name acid ace tax driver that um

00:30:09,789 --> 00:30:18,809
Michael showed earlier it's on datastax

00:30:12,940 --> 00:30:18,809
is github study actually

00:30:25,789 --> 00:30:30,160
ooh salad

00:30:28,390 --> 00:30:32,370
so i get for looking to not take them

00:30:30,160 --> 00:30:32,370
all

00:30:38,720 --> 00:30:42,590
it is great i love it it's called Java

00:30:40,760 --> 00:30:47,360
driver I'm so glad that didn't continue

00:30:42,590 --> 00:30:48,770
in the name of weird mythology that was

00:30:47,360 --> 00:30:51,830
just annoying and we need to stop doing

00:30:48,770 --> 00:30:55,809
that oh so I'm actually glad it's called

00:30:51,830 --> 00:30:55,809
Java driver make sense

00:31:01,570 --> 00:31:07,120
so she knows we've got 10 15 minutes he

00:31:04,210 --> 00:31:09,640
on there until lunch or a break at least

00:31:07,120 --> 00:31:11,950
and maybe you want to take the platform

00:31:09,640 --> 00:31:15,340
to just discuss more about and develop

00:31:11,950 --> 00:31:17,820
and just there maybe drivers for you

00:31:15,340 --> 00:31:23,200
guys do now or what you know I mean

00:31:17,820 --> 00:31:26,650
we've got about a team here so and you

00:31:23,200 --> 00:31:30,580
know I actually had a presentation i did

00:31:26,650 --> 00:31:33,550
i cribbed some stuff from it before four

00:31:30,580 --> 00:31:39,370
this is an internal abdi presentation i

00:31:33,550 --> 00:31:49,960
did a couple months ago um yeah Oh get

00:31:39,370 --> 00:31:51,640
real quick all right um so a tale of two

00:31:49,960 --> 00:31:54,970
protocols some of what we went over and

00:31:51,640 --> 00:31:56,770
a high level the good of thrift useful

00:31:54,970 --> 00:31:59,980
transfer options flexible extensible API

00:31:56,770 --> 00:32:01,990
definition bad generated code means ugly

00:31:59,980 --> 00:32:06,190
generate clients are basically bias st

00:32:01,990 --> 00:32:07,780
idiomatic clients these next couple of

00:32:06,190 --> 00:32:12,760
slides are opinion and again this was

00:32:07,780 --> 00:32:15,900
generated for internal audience so I do

00:32:12,760 --> 00:32:20,560
have some strong opinions there so

00:32:15,900 --> 00:32:23,830
introverted main features easy to

00:32:20,560 --> 00:32:27,700
construct those common operations simple

00:32:23,830 --> 00:32:30,820
resume post you know Mikey space my

00:32:27,700 --> 00:32:33,430
column family key 1i sent a username get

00:32:30,820 --> 00:32:39,250
get that username back pretty stupid

00:32:33,430 --> 00:32:40,900
simple the the guys that health market

00:32:39,250 --> 00:32:42,250
sciences actually have this

00:32:40,900 --> 00:32:43,750
functionality up on their website I

00:32:42,250 --> 00:32:45,610
forget the name of the project but it's

00:32:43,750 --> 00:32:47,140
on they have a rest and point for

00:32:45,610 --> 00:32:48,700
example working already we actually took

00:32:47,140 --> 00:32:51,610
some of the functionality for that for

00:32:48,700 --> 00:32:54,880
any simple operations but the real fun

00:32:51,610 --> 00:32:57,670
stuff comes in the JSON payload defined

00:32:54,880 --> 00:32:59,680
slice operation I want to make a slice

00:32:57,670 --> 00:33:04,840
someone's start at 90 and at five and

00:32:59,680 --> 00:33:07,129
since size of you know for set operation

00:33:04,840 --> 00:33:09,869
very straightforward

00:33:07,129 --> 00:33:14,519
really easy-to-use composites you know

00:33:09,869 --> 00:33:16,499
they're just json arrays um one or more

00:33:14,519 --> 00:33:18,179
commands for payload so here's what the

00:33:16,499 --> 00:33:20,159
payload looks like set key space create

00:33:18,179 --> 00:33:26,039
key space create column family set all

00:33:20,159 --> 00:33:27,960
the time stamp set and then slice so you

00:33:26,039 --> 00:33:30,989
can really batch these things pretty

00:33:27,960 --> 00:33:32,850
well the batching is flexible you can

00:33:30,989 --> 00:33:34,320
put both reads and writes together you

00:33:32,850 --> 00:33:36,840
can do different key spaces in the same

00:33:34,320 --> 00:33:38,820
mutations on you can change key space

00:33:36,840 --> 00:33:42,629
that's mid op and you can string back

00:33:38,820 --> 00:33:44,159
over HTTP um here's a neat idea but if

00:33:42,629 --> 00:33:46,200
you could you know fire off some really

00:33:44,159 --> 00:33:49,919
big ups and stream results back over the

00:33:46,200 --> 00:33:53,519
WebSocket that constantly server-side

00:33:49,919 --> 00:33:55,739
filtering get me everybody where age is

00:33:53,519 --> 00:33:58,499
greater than 21 this is crib right out

00:33:55,739 --> 00:34:00,720
of an internal test case so it's going

00:33:58,499 --> 00:34:02,460
directly to the storage service layer

00:34:00,720 --> 00:34:06,269
but you can see here that I'm uploading

00:34:02,460 --> 00:34:08,879
a groobee a groovy script dynamically by

00:34:06,269 --> 00:34:15,710
a payload to actually filter the results

00:34:08,879 --> 00:34:18,149
of return age everything rages over 21

00:34:15,710 --> 00:34:20,220
get ref there's one or two people who do

00:34:18,149 --> 00:34:22,859
this already is like pl/sql for

00:34:20,220 --> 00:34:27,599
Cassandra probably results 1 operations

00:34:22,859 --> 00:34:32,159
input from another I want to set Robi to

00:34:27,599 --> 00:34:37,889
the results of getting the value of key

00:34:32,159 --> 00:34:41,790
5 triggers perform complex multi-step

00:34:37,889 --> 00:34:43,770
service operations examining change

00:34:41,790 --> 00:34:45,839
request objects interface directly with

00:34:43,770 --> 00:34:50,359
introverted interface directly with

00:34:45,839 --> 00:34:54,030
Cassandra you know good bad and ugly but

00:34:50,359 --> 00:34:55,589
with this presentation is about 60 days

00:34:54,030 --> 00:34:58,170
old at this point we put a lot of our

00:34:55,589 --> 00:35:00,770
stuff in there now there's also the

00:34:58,170 --> 00:35:00,770
ability to do

00:35:03,339 --> 00:35:10,810
well one of the things that we we sort

00:35:07,190 --> 00:35:13,790
of hit on is it with this type of fun of

00:35:10,810 --> 00:35:16,190
functionality this is using invoke

00:35:13,790 --> 00:35:17,270
dynamic in jdk 7 so there's a lot of

00:35:16,190 --> 00:35:18,710
stuff you can do here this could be

00:35:17,270 --> 00:35:20,630
groovy this could be JavaScript this

00:35:18,710 --> 00:35:22,670
could be Python this could be whatever

00:35:20,630 --> 00:35:24,530
you wanted it to be but we have not only

00:35:22,670 --> 00:35:26,300
filters we also have the concept of

00:35:24,530 --> 00:35:30,560
coprocessors and processors like you

00:35:26,300 --> 00:35:33,680
have an H base as well as a you know

00:35:30,560 --> 00:35:35,570
ability to do unions and you know entire

00:35:33,680 --> 00:35:37,820
column family iteration and like spit

00:35:35,570 --> 00:35:41,390
out results as you go along so you know

00:35:37,820 --> 00:35:43,520
but if we took some of that stuff put it

00:35:41,390 --> 00:35:45,950
together a certain way used callback

00:35:43,520 --> 00:35:48,380
mechanisms built into vertex like you

00:35:45,950 --> 00:35:50,780
know web socket and push that stuff back

00:35:48,380 --> 00:35:52,880
over the wire with the ability to

00:35:50,780 --> 00:35:54,530
scatter it around by vertexes event bus

00:35:52,880 --> 00:35:57,829
which I highly encourage you to look at

00:35:54,530 --> 00:35:59,150
cannot looked at yet and all of a sudden

00:35:57,829 --> 00:36:04,280
you can do things like mapreduce

00:35:59,150 --> 00:36:06,109
mediated from a client and you know

00:36:04,280 --> 00:36:09,829
change what you're doing on the fly by

00:36:06,109 --> 00:36:11,329
JavaScript from the client and suddenly

00:36:09,829 --> 00:36:14,690
there's some really sort of interesting

00:36:11,329 --> 00:36:16,160
use cases that open up there so again

00:36:14,690 --> 00:36:17,750
we'll be talking a lot more about this

00:36:16,160 --> 00:36:20,589
towards the end of the month but it's up

00:36:17,750 --> 00:36:20,589
there I'll get up already

00:36:28,279 --> 00:36:33,140

YouTube URL: https://www.youtube.com/watch?v=9ygybW-9F1E


