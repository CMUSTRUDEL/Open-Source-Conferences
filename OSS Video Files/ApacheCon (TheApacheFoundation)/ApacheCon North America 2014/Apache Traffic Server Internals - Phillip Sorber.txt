Title: Apache Traffic Server Internals - Phillip Sorber
Publication date: 2014-04-25
Playlist: ApacheCon North America 2014
Description: 
	ApacheCon North America 2014
Captions: 
	00:00:00,000 --> 00:00:05,730
my name is Phil sober and I'm going to

00:00:03,510 --> 00:00:08,880
do a talk on Apache Apache traffic

00:00:05,730 --> 00:00:10,530
server internals the alternate title for

00:00:08,880 --> 00:00:12,719
this is how i learned to stop worrying

00:00:10,530 --> 00:00:15,320
and love ats but i was told that at

00:00:12,719 --> 00:00:19,439
least two other people stole that line

00:00:15,320 --> 00:00:21,949
with the different ending but what I

00:00:19,439 --> 00:00:24,119
really wanted to do in this talk was

00:00:21,949 --> 00:00:26,460
talk about the internals and show what's

00:00:24,119 --> 00:00:28,349
cool about 80s to get people excited

00:00:26,460 --> 00:00:32,160
about it and want to join our community

00:00:28,349 --> 00:00:33,960
but I also wanted to show that it's a

00:00:32,160 --> 00:00:35,550
code base that's manageable and new

00:00:33,960 --> 00:00:38,070
people can contribute make an impact

00:00:35,550 --> 00:00:41,520
right away and I also did this talk

00:00:38,070 --> 00:00:43,800
because this is what I wish i had when i

00:00:41,520 --> 00:00:49,860
started working on 80s it was a bit

00:00:43,800 --> 00:00:51,960
overwhelming at first so with that yeah

00:00:49,860 --> 00:00:55,530
alright so that's let's see that's the

00:00:51,960 --> 00:00:58,530
tertiary title now a little bit about me

00:00:55,530 --> 00:01:00,420
or maybe why you should listen to me I'm

00:00:58,530 --> 00:01:03,539
a principal engineer comcast and I work

00:01:00,420 --> 00:01:06,659
on the IP CDN team and if you were here

00:01:03,539 --> 00:01:07,890
earlier for yawns talk that's the group

00:01:06,659 --> 00:01:11,670
that I work with and that's what we do

00:01:07,890 --> 00:01:14,610
i'm also a committer 280s now for about

00:01:11,670 --> 00:01:16,110
a year and a half and sometimes people

00:01:14,610 --> 00:01:18,330
say i'm a generally cool guy but i was

00:01:16,110 --> 00:01:20,130
told that i need a citation for that so

00:01:18,330 --> 00:01:21,330
i don't know if we can might have to

00:01:20,130 --> 00:01:25,770
race that bullet point from the slides

00:01:21,330 --> 00:01:29,610
before i upload them what's that I do

00:01:25,770 --> 00:01:30,900
not I live here in Denver I probably

00:01:29,610 --> 00:01:33,560
wouldn't be working for comcast if they

00:01:30,900 --> 00:01:33,560
made me live in Philly

00:01:37,700 --> 00:01:48,960
so I did live I did live in Pennsylvania

00:01:46,800 --> 00:01:52,950
I lived in Harrisburg but I Philly was

00:01:48,960 --> 00:01:54,330
out of the question and so if that

00:01:52,950 --> 00:01:57,330
previous slide didn't convince you that

00:01:54,330 --> 00:01:59,400
that you should stay here hopefully this

00:01:57,330 --> 00:02:02,700
one will what I'm going to talk about in

00:01:59,400 --> 00:02:04,490
here is things like CPU memory storage

00:02:02,700 --> 00:02:07,500
network some of the abstractions and

00:02:04,490 --> 00:02:09,240
just how 80s works internally I'm kind

00:02:07,500 --> 00:02:12,380
of going to go kind of an intermediate

00:02:09,240 --> 00:02:14,280
level I'm not going to dive real deep

00:02:12,380 --> 00:02:16,500
kind of want to get an overview of

00:02:14,280 --> 00:02:21,570
things but a little bit deeper than just

00:02:16,500 --> 00:02:23,460
you know talking about caching so just

00:02:21,570 --> 00:02:25,890
in case you guys didn't know Apache

00:02:23,460 --> 00:02:32,750
traffic server is a caching proxy it's

00:02:25,890 --> 00:02:35,460
written primarily in C++ see also I

00:02:32,750 --> 00:02:37,110
wasn't really sure how much detail to go

00:02:35,460 --> 00:02:38,820
into for the audience how much you

00:02:37,110 --> 00:02:40,350
wanted to talk about so if there's

00:02:38,820 --> 00:02:45,690
questions along the way feel free to ask

00:02:40,350 --> 00:02:49,170
him give you a brief history about 80s

00:02:45,690 --> 00:02:51,600
it was started in editing tomy in the

00:02:49,170 --> 00:02:53,370
late 90s I think there's some difference

00:02:51,600 --> 00:02:56,870
of opinion on what year it started I've

00:02:53,370 --> 00:03:00,989
96 in my slides but then Inc tony was

00:02:56,870 --> 00:03:02,390
acquired by yahoo in 2002 and they did a

00:03:00,989 --> 00:03:05,220
lot of stuff with it internally as well

00:03:02,390 --> 00:03:06,570
and if you were here for the previous

00:03:05,220 --> 00:03:09,600
talk they talked about the history a lot

00:03:06,570 --> 00:03:12,290
as well and then it was open source to

00:03:09,600 --> 00:03:14,910
apache in 2009 into the incubator and

00:03:12,290 --> 00:03:18,030
then in 2010 it became a top-level

00:03:14,910 --> 00:03:19,200
project what the point though that i'm

00:03:18,030 --> 00:03:21,269
trying to make with this slide is that

00:03:19,200 --> 00:03:22,620
it's had a very long history and had a

00:03:21,269 --> 00:03:24,660
lot of different groups of people

00:03:22,620 --> 00:03:26,760
working on it and then completely

00:03:24,660 --> 00:03:28,500
leaving for cliff leaving new group

00:03:26,760 --> 00:03:31,670
coming in and work on working on it and

00:03:28,500 --> 00:03:33,900
it did that twice so there's a bit of

00:03:31,670 --> 00:03:36,720
code archaeology when it comes to

00:03:33,900 --> 00:03:38,310
working on 80s so half the fun is

00:03:36,720 --> 00:03:43,530
getting in there and figuring out how

00:03:38,310 --> 00:03:47,190
things actually do work so first thing I

00:03:43,530 --> 00:03:48,360
want to cover is how 80s deals with the

00:03:47,190 --> 00:03:51,240
CPU

00:03:48,360 --> 00:03:53,700
we are a multi-threaded application but

00:03:51,240 --> 00:03:54,870
we are not a thread per request or

00:03:53,700 --> 00:03:58,470
thread per connection or anything like

00:03:54,870 --> 00:04:01,080
that it's more like a thread pool and

00:03:58,470 --> 00:04:03,990
we're asynchronous and event-driven so

00:04:01,080 --> 00:04:06,450
we have an event loop running in a

00:04:03,990 --> 00:04:08,990
thread that does that allows us to do

00:04:06,450 --> 00:04:11,460
asynchronous stuff this is kind of like

00:04:08,990 --> 00:04:13,320
engine X and nodejs and stuff like that

00:04:11,460 --> 00:04:16,700
so we don't have a bunch of we

00:04:13,320 --> 00:04:16,700
don't have a bunch of context switches

00:04:20,690 --> 00:04:26,580
so it's more efficient that way we also

00:04:23,880 --> 00:04:30,180
use continuations which are they're

00:04:26,580 --> 00:04:32,280
essentially a callback handler with some

00:04:30,180 --> 00:04:35,190
state attached to it so it's different

00:04:32,280 --> 00:04:38,820
than something like a co routine which

00:04:35,190 --> 00:04:41,610
would have to yield this one it just

00:04:38,820 --> 00:04:44,160
gets called back it's a bad description

00:04:41,610 --> 00:04:45,930
but and the other thing with it that's

00:04:44,160 --> 00:04:50,280
really important for us is CPU affinity

00:04:45,930 --> 00:04:51,570
so when you're running on one cpu all

00:04:50,280 --> 00:04:54,210
the time and you have all the all the

00:04:51,570 --> 00:04:56,370
clock cycles you are not having to do

00:04:54,210 --> 00:04:57,479
deal with context switches and it also

00:04:56,370 --> 00:04:59,760
helps you when you're dealing with

00:04:57,479 --> 00:05:06,120
memory which I'll cover and a little bit

00:04:59,760 --> 00:05:08,640
later slide so here is my depiction of

00:05:06,120 --> 00:05:10,290
an event loop essentially you have

00:05:08,640 --> 00:05:12,660
something running in your continuation

00:05:10,290 --> 00:05:14,310
and it registers an event and says hey I

00:05:12,660 --> 00:05:16,440
have a socket whether it's a network

00:05:14,310 --> 00:05:18,660
socket or you're doing some disk i/o and

00:05:16,440 --> 00:05:20,460
says when there's data to be read on

00:05:18,660 --> 00:05:23,430
this or yeah David to be read on this

00:05:20,460 --> 00:05:25,380
call me back or when I can write data to

00:05:23,430 --> 00:05:27,720
this call me back and it goes into a

00:05:25,380 --> 00:05:30,960
pending event queue and then some point

00:05:27,720 --> 00:05:33,840
in the future the event fires whilst

00:05:30,960 --> 00:05:35,550
sitting in the pending event queue other

00:05:33,840 --> 00:05:37,740
continuations can run so basically

00:05:35,550 --> 00:05:39,870
continuations are interleaved and then

00:05:37,740 --> 00:05:43,050
the event fires and then it's runnable

00:05:39,870 --> 00:05:45,120
and so when there's a CPU to run it on a

00:05:43,050 --> 00:05:47,130
thread to run it on that continuation is

00:05:45,120 --> 00:05:49,169
called and it runs the event handler

00:05:47,130 --> 00:05:55,229
again and it basically repeats over and

00:05:49,169 --> 00:05:59,960
over going through a state machine any

00:05:55,229 --> 00:05:59,960
questions budding this yet all right

00:06:03,780 --> 00:06:10,990
so there's when you're doing disk i/o

00:06:08,620 --> 00:06:13,450
you have to have a synchronous i/o

00:06:10,990 --> 00:06:16,780
threads that are actually blocking doing

00:06:13,450 --> 00:06:19,180
the blocking because aio a little bit

00:06:16,780 --> 00:06:20,830
complicated in it and you'll see stuff

00:06:19,180 --> 00:06:21,850
in like G whoopsie documentation or

00:06:20,830 --> 00:06:23,260
something like that where it says oh you

00:06:21,850 --> 00:06:26,830
can do AI oh but it really spawns

00:06:23,260 --> 00:06:29,170
threads in the background and Linux

00:06:26,830 --> 00:06:30,670
kernel also there ridicula has an aio

00:06:29,170 --> 00:06:33,160
interface but if you do the slightest

00:06:30,670 --> 00:06:37,060
thing wrong it defaults back to threads

00:06:33,160 --> 00:06:38,950
so what 80s does in this case is we just

00:06:37,060 --> 00:06:41,770
have our own aio thread so we control

00:06:38,950 --> 00:06:43,120
the process and then it's you know when

00:06:41,770 --> 00:07:06,310
you control it you can do things better

00:06:43,120 --> 00:07:09,720
for yourself yeah and there is it's not

00:07:06,310 --> 00:07:13,510
exactly this simple there's there's a

00:07:09,720 --> 00:07:16,150
couple event loops so to speak in 80s

00:07:13,510 --> 00:07:17,710
and would like to make that a little bit

00:07:16,150 --> 00:07:19,780
cleaner and simpler so that this picture

00:07:17,710 --> 00:07:23,260
does apply but this is this is the

00:07:19,780 --> 00:07:29,110
general idea I'm going kind of fast here

00:07:23,260 --> 00:07:31,000
so so I said before that 80s was

00:07:29,110 --> 00:07:34,630
multi-threaded we have a bunch of

00:07:31,000 --> 00:07:37,510
different thread types the main thread

00:07:34,630 --> 00:07:39,730
type is the net thread that's where most

00:07:37,510 --> 00:07:41,860
of the good stuff happens that's where

00:07:39,730 --> 00:07:44,110
when the connection comes in you know

00:07:41,860 --> 00:07:47,350
creates a state machine to transaction

00:07:44,110 --> 00:07:51,760
and starts handling all the stuff starts

00:07:47,350 --> 00:07:53,680
doing the cache lookups then we have aio

00:07:51,760 --> 00:07:56,440
threads so those are the ones that are

00:07:53,680 --> 00:07:59,500
actually doing the IO requests the disk

00:07:56,440 --> 00:08:02,530
and blocking I believe right the default

00:07:59,500 --> 00:08:06,640
right now is eight aio threads per disk

00:08:02,530 --> 00:08:09,580
or volume and they spend most of their

00:08:06,640 --> 00:08:12,190
time blocking do we also have task

00:08:09,580 --> 00:08:13,930
threads task threads or when you want to

00:08:12,190 --> 00:08:15,910
do something but it's not time critical

00:08:13,930 --> 00:08:16,449
and maybe it's going to block for a

00:08:15,910 --> 00:08:18,249
little bit

00:08:16,449 --> 00:08:20,889
that's something that you just can't

00:08:18,249 --> 00:08:22,449
help like that so you might want to run

00:08:20,889 --> 00:08:24,219
it on Tesco instead of a neck threat if

00:08:22,449 --> 00:08:26,110
you block in that thread then you start

00:08:24,219 --> 00:08:27,490
getting latency issues and your request

00:08:26,110 --> 00:08:28,990
start backing up and stuff like that so

00:08:27,490 --> 00:08:32,529
we have task threads that are set aside

00:08:28,990 --> 00:08:35,289
specifically for that then we have

00:08:32,529 --> 00:08:40,089
except threads so we have two ways to do

00:08:35,289 --> 00:08:41,889
except we can do blocking except in an

00:08:40,089 --> 00:08:43,539
accept thread so those threads actually

00:08:41,889 --> 00:08:45,550
sit there and block and only get woken

00:08:43,539 --> 00:08:48,220
up by the kernel when there's an

00:08:45,550 --> 00:08:50,199
incoming connection or we can do except

00:08:48,220 --> 00:08:53,410
per net thread and when we do except for

00:08:50,199 --> 00:08:55,990
net thread that's another event another

00:08:53,410 --> 00:08:59,560
socket event on the net thread event

00:08:55,990 --> 00:09:02,920
loop there's some other types of threads

00:08:59,560 --> 00:09:04,990
that are less common some people you

00:09:02,920 --> 00:09:07,660
know live and die by them but they're

00:09:04,990 --> 00:09:10,240
not on by default so SSL threads I'm

00:09:07,660 --> 00:09:12,070
sure Yahoo you guys use SSL threads so

00:09:10,240 --> 00:09:15,250
that the SSL work can be pushed off to

00:09:12,070 --> 00:09:17,440
those to free up the net threads DNS

00:09:15,250 --> 00:09:20,889
thread the same thing you can do all

00:09:17,440 --> 00:09:24,310
your DNS requests on DNS threads remap

00:09:20,889 --> 00:09:26,440
threads are a special case where when

00:09:24,310 --> 00:09:28,510
you when you're doing the loading of a

00:09:26,440 --> 00:09:29,889
remap file and leaf I have to correct me

00:09:28,510 --> 00:09:32,260
on this when you when you're loading a

00:09:29,889 --> 00:09:34,029
remap file and processing all that that

00:09:32,260 --> 00:09:35,290
happens on the remap thread so that

00:09:34,029 --> 00:09:37,660
you're not blocking a net thread when

00:09:35,290 --> 00:09:47,850
you're updating your remap config is

00:09:37,660 --> 00:09:47,850
that roughly right getting that look now

00:09:48,210 --> 00:10:03,190
uh-huh okay and is it every remap I

00:10:01,900 --> 00:10:07,290
remember talking about this noise every

00:10:03,190 --> 00:10:07,290
remap plug-in that has to run there then

00:10:09,930 --> 00:10:21,790
okay so okay so so there's there's

00:10:19,710 --> 00:10:23,020
plugins I don't talk about plugins in

00:10:21,790 --> 00:10:24,460
here too much but there's there's

00:10:23,020 --> 00:10:27,580
plugins in 80's and there's to plug in

00:10:24,460 --> 00:10:30,570
AP is one of them is the regular API and

00:10:27,580 --> 00:10:34,270
one of them is a remap API for doing

00:10:30,570 --> 00:10:36,940
reverse remap for like a reverse proxy

00:10:34,270 --> 00:10:38,800
and so what they're saying is those

00:10:36,940 --> 00:10:40,330
plugins would get run on those threads

00:10:38,800 --> 00:10:42,760
so if you do something blocking in there

00:10:40,330 --> 00:10:45,120
that they can block on those threads

00:10:42,760 --> 00:10:48,670
while the net threads continue to run

00:10:45,120 --> 00:10:51,960
also the regular plug-in API has some

00:10:48,670 --> 00:10:54,460
thread stuff where you can pass it a

00:10:51,960 --> 00:10:56,530
function pointer and say run this

00:10:54,460 --> 00:10:58,120
function on that thread until it exits

00:10:56,530 --> 00:11:00,370
and it'll run it on a separate thread

00:10:58,120 --> 00:11:02,050
and you can do whatever you want if you

00:11:00,370 --> 00:11:04,210
want to block on that thread if you want

00:11:02,050 --> 00:11:05,610
to do a sleep for 60 seconds and then

00:11:04,210 --> 00:11:09,840
free some memory or something like that

00:11:05,610 --> 00:11:09,840
you would do that on those threads

00:11:15,180 --> 00:11:21,790
memory so 80s does a lot of fun stuff

00:11:19,090 --> 00:11:24,550
with memory memories being fast is

00:11:21,790 --> 00:11:26,650
really important because CPUs are so

00:11:24,550 --> 00:11:29,320
fast these days that most of the time

00:11:26,650 --> 00:11:34,210
that's wasted is is stalls on the CPU

00:11:29,320 --> 00:11:35,800
waiting for memory so the stuff we do in

00:11:34,210 --> 00:11:38,170
here and this area is really important

00:11:35,800 --> 00:11:40,780
one of the things that we have is a ram

00:11:38,170 --> 00:11:44,830
catch and this is not a ramdisk this is

00:11:40,780 --> 00:11:47,890
actually a ram cash per storage device

00:11:44,830 --> 00:11:49,840
where when you have a hot something

00:11:47,890 --> 00:11:51,520
that's hot an object that's hot it gets

00:11:49,840 --> 00:11:53,020
stored in RAM cash and serve directly

00:11:51,520 --> 00:11:55,570
out of RAM so you don't have to do disk

00:11:53,020 --> 00:11:58,830
i/o so this guy was even worse than the

00:11:55,570 --> 00:12:01,779
memory i/o as far as installing the CPU

00:11:58,830 --> 00:12:03,639
also doing things with new

00:12:01,779 --> 00:12:06,999
very important you guys remember the

00:12:03,639 --> 00:12:09,069
Numa Numa guy no I wanted to put the

00:12:06,999 --> 00:12:10,389
video in here but I figured I'd get in

00:12:09,069 --> 00:12:13,810
trouble for something copyrighted or

00:12:10,389 --> 00:12:17,110
something but yeah so keeping keeping

00:12:13,810 --> 00:12:19,089
the the memory close to the thread

00:12:17,110 --> 00:12:21,910
that's going to use it on that same Numa

00:12:19,089 --> 00:12:24,370
node is very important and then there's

00:12:21,910 --> 00:12:29,050
memory management and HTS uses free list

00:12:24,370 --> 00:12:30,459
for that so the free list essentially

00:12:29,050 --> 00:12:32,439
when we allocate memory from the

00:12:30,459 --> 00:12:35,620
operating system we don't ever give it

00:12:32,439 --> 00:12:37,269
back we just keep it and we track it in

00:12:35,620 --> 00:12:38,860
a free list and then when something

00:12:37,269 --> 00:12:42,100
needs it again we pull it out of the

00:12:38,860 --> 00:12:44,499
free list there's a couple kinds that we

00:12:42,100 --> 00:12:47,649
have start off with the allocators which

00:12:44,499 --> 00:12:48,999
is essentially a c++ wrapper of the free

00:12:47,649 --> 00:12:52,120
list so you just say I want to block a

00:12:48,999 --> 00:12:55,420
memory this size and it'll give you that

00:12:52,120 --> 00:12:56,499
then there's a class allocators the

00:12:55,420 --> 00:12:59,680
class allocators I think are pretty

00:12:56,499 --> 00:13:01,209
ingenious they have an instance of the

00:12:59,680 --> 00:13:04,149
class of the type they are so that

00:13:01,209 --> 00:13:05,800
they're like a C++ template and they

00:13:04,149 --> 00:13:09,399
have an instance of that class inside

00:13:05,800 --> 00:13:12,459
them so when you say hey I want a you

00:13:09,399 --> 00:13:13,870
know an HTTP state machine it takes it

00:13:12,459 --> 00:13:16,269
finds a block of memory on the free list

00:13:13,870 --> 00:13:19,000
and then it does a mem copy of that

00:13:16,269 --> 00:13:20,170
instance that it has over the block of

00:13:19,000 --> 00:13:21,670
memory that it's going to give you and

00:13:20,170 --> 00:13:24,550
then it hands it off so you don't have

00:13:21,670 --> 00:13:26,199
to do like a in place initialization or

00:13:24,550 --> 00:13:29,019
anything like that it just directly

00:13:26,199 --> 00:13:32,980
copies it something else to note about

00:13:29,019 --> 00:13:35,259
the class allocators is their global so

00:13:32,980 --> 00:13:38,589
there's we have multiple threads

00:13:35,259 --> 00:13:41,920
accessing them so it's the concurrency

00:13:38,589 --> 00:13:44,259
is put in check by atomic operators I'll

00:13:41,920 --> 00:13:45,519
actually go into the the free list and

00:13:44,259 --> 00:13:47,889
the atomic operators a little bit more

00:13:45,519 --> 00:13:49,750
than others in the next slide we also

00:13:47,889 --> 00:13:52,480
have proxy allocators which are

00:13:49,750 --> 00:13:54,040
essentially class allocators except

00:13:52,480 --> 00:13:56,319
their per thread and since they're per

00:13:54,040 --> 00:13:58,689
thread we don't have to have any locks

00:13:56,319 --> 00:14:00,850
on them or any Atomics they're always

00:13:58,689 --> 00:14:05,079
set to one to that one particular thread

00:14:00,850 --> 00:14:08,379
and the proxy allocators get their

00:14:05,079 --> 00:14:11,679
memory from the class allocators so the

00:14:08,379 --> 00:14:13,870
class allocator will allocate say 128

00:14:11,679 --> 00:14:15,310
chunks of memory all of a certain size

00:14:13,870 --> 00:14:16,990
for your class

00:14:15,310 --> 00:14:18,430
and then when the proxy allocators need

00:14:16,990 --> 00:14:22,660
memory they just go to the class

00:14:18,430 --> 00:14:24,640
allocators and then inside the thread

00:14:22,660 --> 00:14:27,790
the thread uses the proxy allocator and

00:14:24,640 --> 00:14:29,640
it's much faster the other one is arenas

00:14:27,790 --> 00:14:32,620
and I think arenas are pretty cool

00:14:29,640 --> 00:14:34,870
basically we give 11 arena to every

00:14:32,620 --> 00:14:37,300
transaction and then that transaction

00:14:34,870 --> 00:14:39,010
can allocate memory for itself and not

00:14:37,300 --> 00:14:40,360
have to worry about the cleanup that

00:14:39,010 --> 00:14:41,650
block of memory has just passed along

00:14:40,360 --> 00:14:43,300
through the whole state machine with

00:14:41,650 --> 00:14:47,200
that transaction and then at the end

00:14:43,300 --> 00:14:48,580
when the transaction is done it the

00:14:47,200 --> 00:14:50,950
transaction goes back on the free list

00:14:48,580 --> 00:14:53,200
but the arena is cleared as well so that

00:14:50,950 --> 00:14:54,820
goes on a different free list actually I

00:14:53,200 --> 00:15:01,029
think that's where the alligators are

00:14:54,820 --> 00:15:02,890
for and also huge pages so right now we

00:15:01,029 --> 00:15:05,950
don't use huge pages directly there was

00:15:02,890 --> 00:15:08,740
kind of a bug big bug that we ran to

00:15:05,950 --> 00:15:12,130
comcast recently where Linux is trying

00:15:08,740 --> 00:15:14,200
to make you use huge pages without you

00:15:12,130 --> 00:15:17,529
seeing them and some of the stuff that

00:15:14,200 --> 00:15:21,940
does in the background causes 80s to

00:15:17,529 --> 00:15:24,610
lock up four minutes so huge pages are

00:15:21,940 --> 00:15:27,490
something I'd like to see put into 80's

00:15:24,610 --> 00:15:28,930
in the very near future and give you a

00:15:27,490 --> 00:15:31,690
little background on huge pages it's a

00:15:28,930 --> 00:15:35,500
Linux feature other operating systems

00:15:31,690 --> 00:15:37,420
have similar things but basically rather

00:15:35,500 --> 00:15:40,930
than allocating your memory in like 4k

00:15:37,420 --> 00:15:42,250
or 2k chunks it does it in two mags or 4

00:15:40,930 --> 00:15:45,280
Meg's depending on your architecture

00:15:42,250 --> 00:15:48,580
they also have ones that are 1 gigabyte

00:15:45,280 --> 00:15:52,089
in size and this lowers your TLB

00:15:48,580 --> 00:15:57,760
pressure the TLB is basically your cash

00:15:52,089 --> 00:16:00,850
for virtual memory lookups so when you

00:15:57,760 --> 00:16:02,350
have to do when you when you your

00:16:00,850 --> 00:16:04,839
continuation that's running on your cpu

00:16:02,350 --> 00:16:07,450
needs to go get memory and that memory

00:16:04,839 --> 00:16:09,280
that page isn't in the TLB it has to go

00:16:07,450 --> 00:16:11,260
out and get that page and bring it into

00:16:09,280 --> 00:16:12,790
the virtual memory space and all that

00:16:11,260 --> 00:16:14,770
other fun stuff so when you can have

00:16:12,790 --> 00:16:16,420
bigger pages in memory you have fewer of

00:16:14,770 --> 00:16:18,520
those entries so you can have more

00:16:16,420 --> 00:16:22,120
basically more physical memory mapped in

00:16:18,520 --> 00:16:26,230
the virtual memory at once all right

00:16:22,120 --> 00:16:28,030
this is basically what the free list

00:16:26,230 --> 00:16:29,130
looks like there's a couple other

00:16:28,030 --> 00:16:31,110
variables

00:16:29,130 --> 00:16:33,480
stating how big these trunks should be

00:16:31,110 --> 00:16:35,640
and how many of you want to get it once

00:16:33,480 --> 00:16:38,850
but essentially this is the free list

00:16:35,640 --> 00:16:41,430
and it's a linked list stack so we have

00:16:38,850 --> 00:16:43,800
the head pointer and these this next

00:16:41,430 --> 00:16:44,970
pointer basically this when it's inside

00:16:43,800 --> 00:16:47,850
the free list this whole block of memory

00:16:44,970 --> 00:16:49,440
is a void star so the next pointer is

00:16:47,850 --> 00:16:52,080
really the beginning of that memory

00:16:49,440 --> 00:16:54,210
space but since we're going to copy over

00:16:52,080 --> 00:16:55,650
it when we free it for when we remove it

00:16:54,210 --> 00:16:57,120
from the free list it doesn't matter

00:16:55,650 --> 00:17:00,000
that we're using that space so there's

00:16:57,120 --> 00:17:02,070
no extra data that we need to have

00:17:00,000 --> 00:17:04,290
around no extra structures that we need

00:17:02,070 --> 00:17:06,600
to have to point at these I believe it's

00:17:04,290 --> 00:17:16,319
called an intrusive container something

00:17:06,600 --> 00:17:19,069
like that yes when it goes on the free

00:17:16,319 --> 00:17:19,069
list yes

00:17:29,990 --> 00:17:36,809
yes so so what he's saying is that the

00:17:33,440 --> 00:17:38,220
the virtual function table pointer is

00:17:36,809 --> 00:17:40,320
usually at the top and since it's being

00:17:38,220 --> 00:17:42,330
overwritten when you try and call a

00:17:40,320 --> 00:17:49,260
method on it it should crash or you

00:17:42,330 --> 00:17:51,179
would hope it would I know right right

00:17:49,260 --> 00:17:56,610
so any verte any virtual method that

00:17:51,179 --> 00:17:59,400
you've done and and that's that's yeah

00:17:56,610 --> 00:18:02,100
when you have with no right wait what

00:17:59,400 --> 00:18:03,840
they call it on know so so yeah that's

00:18:02,100 --> 00:18:05,730
something that if anybody has any great

00:18:03,840 --> 00:18:08,039
ideas I know this guy right up here

00:18:05,730 --> 00:18:09,720
front Brian Geffen is looking to figure

00:18:08,039 --> 00:18:12,230
out how we can make sure that you're not

00:18:09,720 --> 00:18:14,580
using memory on the free list it is a

00:18:12,230 --> 00:18:19,049
problem and you know with multi-threaded

00:18:14,580 --> 00:18:20,970
things so so yeah over here we also have

00:18:19,049 --> 00:18:23,429
this version pointer so each one of

00:18:20,970 --> 00:18:25,830
these pointers is 64 bits in size and so

00:18:23,429 --> 00:18:29,010
the head in the version is 128 bits and

00:18:25,830 --> 00:18:32,039
the reason for the version is to solve

00:18:29,010 --> 00:18:34,289
the ABA problem basically if you pop

00:18:32,039 --> 00:18:38,130
this guy off and this guy off and then

00:18:34,289 --> 00:18:39,990
put this guy back on your your head

00:18:38,130 --> 00:18:42,210
pointer will be the same pointing to

00:18:39,990 --> 00:18:43,830
this guy here but when he thinks he

00:18:42,210 --> 00:18:45,000
needs to do the compare-and-swap he's

00:18:43,830 --> 00:18:47,100
going to end up pointing at this guy

00:18:45,000 --> 00:18:48,750
instead of this guy when he was freed so

00:18:47,100 --> 00:18:51,539
the version gets incremented every time

00:18:48,750 --> 00:18:54,030
and we do that with a 128-bit

00:18:51,539 --> 00:18:57,630
compare-and-swap that again Brian Geffen

00:18:54,030 --> 00:18:59,419
graced us with so that's basically the

00:18:57,630 --> 00:19:04,010
free list any questions about that I

00:18:59,419 --> 00:19:07,380
think this is pretty cool to know

00:19:04,010 --> 00:19:09,809
continue on so before I was talking

00:19:07,380 --> 00:19:11,850
about Numa and I wanted to just explain

00:19:09,809 --> 00:19:14,070
real quick exactly what that meant so

00:19:11,850 --> 00:19:15,990
this is a modern architecture this is

00:19:14,070 --> 00:19:18,809
probably you know an Intel qpi bus and

00:19:15,990 --> 00:19:21,120
you have your two sockets and back in

00:19:18,809 --> 00:19:22,289
the day you would have your southbridge

00:19:21,120 --> 00:19:24,299
with your memory controller on your

00:19:22,289 --> 00:19:25,950
South Bridge and it was a shared bus to

00:19:24,299 --> 00:19:27,600
all that memory and they said well

00:19:25,950 --> 00:19:29,820
that's really slow so we're going to put

00:19:27,600 --> 00:19:32,580
our memory controller with the socket

00:19:29,820 --> 00:19:34,110
with the CPU on the die so that you have

00:19:32,580 --> 00:19:36,630
direct access to it you don't just share

00:19:34,110 --> 00:19:38,850
it over a bus but this causes a problem

00:19:36,630 --> 00:19:39,580
that when you have a thread running over

00:19:38,850 --> 00:19:41,650
here and it

00:19:39,580 --> 00:19:44,280
access this memory it now has the added

00:19:41,650 --> 00:19:47,440
latency of going over this qpi bus so

00:19:44,280 --> 00:19:48,730
the the concept is that when you have

00:19:47,440 --> 00:19:50,230
your you keep your threads that you

00:19:48,730 --> 00:19:52,330
start over here that are allocating

00:19:50,230 --> 00:19:55,930
memory over here stay running here and

00:19:52,330 --> 00:19:57,220
that memory stays here and also that

00:19:55,930 --> 00:20:00,490
huge page problem i was mentioning

00:19:57,220 --> 00:20:02,290
before the transparent huge pages linux

00:20:00,490 --> 00:20:04,720
was trying to move memory from this side

00:20:02,290 --> 00:20:06,520
to this side and when that's happening

00:20:04,720 --> 00:20:08,350
your processes can't touch it because

00:20:06,520 --> 00:20:13,240
it's not really where it's supposed to

00:20:08,350 --> 00:20:14,650
be and also the proxy allocators when

00:20:13,240 --> 00:20:16,750
you're when you're dealing with Numa and

00:20:14,650 --> 00:20:18,070
your threads there they're getting all

00:20:16,750 --> 00:20:19,780
their memory from the same side and they

00:20:18,070 --> 00:20:21,880
don't have to worry about dealing with

00:20:19,780 --> 00:20:23,350
other threads on the same socket trying

00:20:21,880 --> 00:20:31,510
to access their memory so there's no

00:20:23,350 --> 00:20:33,760
locking there okay storage I don't know

00:20:31,510 --> 00:20:36,510
how many of you guys were in here to

00:20:33,760 --> 00:20:39,130
talks ago for alan's great storage talk

00:20:36,510 --> 00:20:42,970
but i'm going to do kind of a higher

00:20:39,130 --> 00:20:46,390
level than what he went into so 80s

00:20:42,970 --> 00:20:49,960
prefers to use raw devices you can use a

00:20:46,390 --> 00:20:52,720
file but then you're adding file system

00:20:49,960 --> 00:20:55,600
overhead on top of writing out since we

00:20:52,720 --> 00:20:58,660
basically have our own file system

00:20:55,600 --> 00:21:01,540
layout our own disk layout within ATS

00:20:58,660 --> 00:21:02,890
within the cash and each store and since

00:21:01,540 --> 00:21:05,950
you're using raw devices you don't want

00:21:02,890 --> 00:21:08,560
to do things like raid you want to have

00:21:05,950 --> 00:21:10,600
each device addressed independently and

00:21:08,560 --> 00:21:16,180
you basically end up with unique caches

00:21:10,600 --> 00:21:17,620
so if you lose a disk you don't lose all

00:21:16,180 --> 00:21:21,760
your data you just lose anything that

00:21:17,620 --> 00:21:24,580
was mapped to that one drive with each

00:21:21,760 --> 00:21:28,000
of those unique caches on each disc you

00:21:24,580 --> 00:21:29,380
also get a unique Ram cash so when we

00:21:28,000 --> 00:21:31,570
talk about the RAM cash it sounds like a

00:21:29,380 --> 00:21:34,180
big cloud of memory but it's actually a

00:21:31,570 --> 00:21:36,010
bunch of little clouds of memory and

00:21:34,180 --> 00:21:39,310
also it's done using consistent hashing

00:21:36,010 --> 00:21:41,920
so when you have an object stored on a

00:21:39,310 --> 00:21:43,300
disk it's always going to be in the same

00:21:41,920 --> 00:21:44,860
one so when you do lookups it goes back

00:21:43,300 --> 00:21:47,080
to the same disk and if you have to

00:21:44,860 --> 00:21:51,100
remove a disk you don't reorder

00:21:47,080 --> 00:21:53,799
everything and also our on disk format

00:21:51,100 --> 00:21:55,989
is a circular cash it's optimized

00:21:53,799 --> 00:21:57,940
for spinning disk which was the only

00:21:55,989 --> 00:22:00,220
option back in the late 90s when this

00:21:57,940 --> 00:22:03,399
was written but it makes it very easy to

00:22:00,220 --> 00:22:07,230
use cheap spinning disks in 80's rather

00:22:03,399 --> 00:22:07,230
than having to spend the money on SSDs

00:22:08,489 --> 00:22:15,070
so you get a lot more bang for your buck

00:22:10,480 --> 00:22:18,309
there is a diagram of some storage so

00:22:15,070 --> 00:22:22,989
you can see here we have all our volumes

00:22:18,309 --> 00:22:24,129
the name these are these are I'm calling

00:22:22,989 --> 00:22:26,139
them volumes here and in some of the

00:22:24,129 --> 00:22:27,460
configs that referred to as volumes but

00:22:26,139 --> 00:22:29,289
in Alan's talk you refer to them as

00:22:27,460 --> 00:22:30,639
spans and maybe some other things

00:22:29,289 --> 00:22:32,799
depending on how they were configured

00:22:30,639 --> 00:22:33,999
but just to keep it simple I'm going to

00:22:32,799 --> 00:22:36,249
refer to these as volumes so these are

00:22:33,999 --> 00:22:40,149
each separate physical disks these have

00:22:36,249 --> 00:22:42,970
their own Ram cash so when when you

00:22:40,149 --> 00:22:45,879
request an object and 80s has to go back

00:22:42,970 --> 00:22:47,499
to the origin or to a parent it will be

00:22:45,879 --> 00:22:49,989
written onto the disk and serve to the

00:22:47,499 --> 00:22:51,460
client at the same time but the next

00:22:49,989 --> 00:22:53,739
time you come in and says oh I have that

00:22:51,460 --> 00:22:56,499
on disk then it also copies that to ram

00:22:53,739 --> 00:22:59,200
cash so there's a to look up costs there

00:22:56,499 --> 00:23:02,109
to get it into ram cash I think you can

00:22:59,200 --> 00:23:03,929
also extend that with an option a filter

00:23:02,109 --> 00:23:09,190
option to make sure that you're not

00:23:03,929 --> 00:23:10,450
thrashing your RAM cash by looking up a

00:23:09,190 --> 00:23:12,609
whole bunch of different things it'll

00:23:10,450 --> 00:23:15,639
it'll keep it for hot items and our Ram

00:23:12,609 --> 00:23:17,139
caches while the all the on disk format

00:23:15,639 --> 00:23:18,820
is a circular and it just kind of over

00:23:17,139 --> 00:23:22,179
rights old data as it's going through

00:23:18,820 --> 00:23:26,609
the RAM caches can BL are you or this

00:23:22,179 --> 00:23:29,139
other kind of conglomeration of

00:23:26,609 --> 00:23:33,399
algorithms that we think it's called see

00:23:29,139 --> 00:23:35,109
flus so I go quite into an algorithm but

00:23:33,399 --> 00:23:38,249
very smart guy came up with it and wrote

00:23:35,109 --> 00:23:40,840
it unfortunately it's not here today and

00:23:38,249 --> 00:23:44,230
so the consistent hash on explain that

00:23:40,840 --> 00:23:48,429
real quick to basically some identifier

00:23:44,230 --> 00:23:50,230
for each device is hashed and converted

00:23:48,429 --> 00:23:51,909
to a basically numeric value and then

00:23:50,230 --> 00:23:55,419
when you go to look up an object that's

00:23:51,909 --> 00:23:57,759
that object identifier is also hashed

00:23:55,419 --> 00:23:59,710
and then you try and find the one that

00:23:57,759 --> 00:24:02,109
has the closest proximity to the value

00:23:59,710 --> 00:24:05,649
of this so that way if you have to

00:24:02,109 --> 00:24:07,990
remove a volume the only ones that

00:24:05,649 --> 00:24:09,550
change are the ones that were close

00:24:07,990 --> 00:24:11,020
to this guy because all the other one

00:24:09,550 --> 00:24:14,160
still continued to match so if you just

00:24:11,020 --> 00:24:16,480
did a regular hash with like a modulo

00:24:14,160 --> 00:24:19,360
everything would get reordered and you

00:24:16,480 --> 00:24:22,929
and you'd basically have one over N

00:24:19,360 --> 00:24:26,230
Things not being or one of our end

00:24:22,929 --> 00:24:30,820
things not being recast which would kill

00:24:26,230 --> 00:24:33,040
your your hit ratio and then if you add

00:24:30,820 --> 00:24:36,760
if you actually the contrapositive

00:24:33,040 --> 00:24:38,050
there's if you add a disc back in some

00:24:36,760 --> 00:24:40,540
of the things that were previously being

00:24:38,050 --> 00:24:43,120
hashed to these other guys are now going

00:24:40,540 --> 00:24:45,340
to be closer with the consistent hash to

00:24:43,120 --> 00:24:46,600
volume 4 and so well even though you

00:24:45,340 --> 00:24:49,030
might have them cached on the other

00:24:46,600 --> 00:24:54,010
volumes they're no longer accessible and

00:24:49,030 --> 00:24:56,170
so they'll have to be recast each of

00:24:54,010 --> 00:24:58,600
these volumes also has its own directory

00:24:56,170 --> 00:25:00,460
which is essentially an index and it's

00:24:58,600 --> 00:25:02,350
10 bytes per object which is very

00:25:00,460 --> 00:25:04,390
efficient and if you were here for

00:25:02,350 --> 00:25:06,550
Brian's talk you'd know that that's

00:25:04,390 --> 00:25:10,360
pretty much the smallest one across all

00:25:06,550 --> 00:25:12,730
the major open source caches and also

00:25:10,360 --> 00:25:14,679
the whole the whole system with the

00:25:12,730 --> 00:25:18,040
directory and the on disk format is

00:25:14,679 --> 00:25:21,580
crash proof so it's not I'll say it uses

00:25:18,040 --> 00:25:23,080
database like mechanisms so an object is

00:25:21,580 --> 00:25:25,059
written to the cash first and then it's

00:25:23,080 --> 00:25:27,460
updated in the directory once it's on

00:25:25,059 --> 00:25:29,890
disk and since everything is direct I oh

00:25:27,460 --> 00:25:33,070
you don't have to worry about filesystem

00:25:29,890 --> 00:25:34,809
caching and then when the index is

00:25:33,070 --> 00:25:38,410
written out every couple of seconds

00:25:34,809 --> 00:25:40,240
there's two copies on each volume so the

00:25:38,410 --> 00:25:41,500
oldest one gets overwritten and then

00:25:40,240 --> 00:25:43,870
when it's completely written out a

00:25:41,500 --> 00:25:45,250
pointer gets switched and on disappoint

00:25:43,870 --> 00:25:47,740
or get switch to point to that one so it

00:25:45,250 --> 00:25:49,390
next restart that copy of the directory

00:25:47,740 --> 00:25:50,620
is loaded off disk and if you have a

00:25:49,390 --> 00:25:52,420
power failure in the middle of a

00:25:50,620 --> 00:26:00,300
directory right out or an object right

00:25:52,420 --> 00:26:02,800
out you're still consistent okay network

00:26:00,300 --> 00:26:04,090
there's not a whole lot of stuff you can

00:26:02,800 --> 00:26:05,830
do with the network but some of the

00:26:04,090 --> 00:26:08,920
things that we do our connection pools

00:26:05,830 --> 00:26:12,840
we have global connection pools or we

00:26:08,920 --> 00:26:15,250
can also do per thread connection pools

00:26:12,840 --> 00:26:17,230
again doing it per thread so you don't

00:26:15,250 --> 00:26:18,549
have to deal with the locking makes it

00:26:17,230 --> 00:26:22,580
more efficient

00:26:18,549 --> 00:26:26,210
and we can there's the concept of

00:26:22,580 --> 00:26:29,299
cheered caches where you have an edge

00:26:26,210 --> 00:26:32,299
cash talking to a mid so that if you can

00:26:29,299 --> 00:26:34,039
get a ninety percent cache hit ratio or

00:26:32,299 --> 00:26:36,559
ninety percent offload from your edges

00:26:34,039 --> 00:26:37,970
and you can get a ninety percent hit

00:26:36,559 --> 00:26:40,190
rate from your mids that means you're

00:26:37,970 --> 00:26:51,830
getting a ninety-nine percent offload

00:26:40,190 --> 00:26:53,780
from your origins in theory and also I

00:26:51,830 --> 00:26:57,620
have the concept of parent selection so

00:26:53,780 --> 00:26:59,179
instead of always having one mid cash

00:26:57,620 --> 00:27:01,220
that you would go to you can have

00:26:59,179 --> 00:27:04,280
several to select from and this can help

00:27:01,220 --> 00:27:07,250
with things like content affinity so if

00:27:04,280 --> 00:27:09,500
you have a cluster of caches you don't

00:27:07,250 --> 00:27:13,240
have to basically be duplicating your

00:27:09,500 --> 00:27:16,429
data across them you can use like a

00:27:13,240 --> 00:27:20,000
consistent hash to always go to the same

00:27:16,429 --> 00:27:24,440
mid for the same content so here's a

00:27:20,000 --> 00:27:26,179
diagram of the tiered caching have your

00:27:24,440 --> 00:27:27,230
origin up here and I try to make these

00:27:26,179 --> 00:27:28,970
lines a little thicker in a little

00:27:27,230 --> 00:27:31,250
different colors so that you would have

00:27:28,970 --> 00:27:34,549
multiple connections from one edge to

00:27:31,250 --> 00:27:36,080
one mid you know if you had 32 threads

00:27:34,549 --> 00:27:38,090
running on here and you had per thread

00:27:36,080 --> 00:27:40,700
session pools it would have 32

00:27:38,090 --> 00:27:44,419
connections going up there also if you

00:27:40,700 --> 00:27:46,820
were querying stuff from the same mid

00:27:44,419 --> 00:27:48,260
for the same content you might end up

00:27:46,820 --> 00:27:52,539
with a couple connections because you

00:27:48,260 --> 00:27:54,620
can't multiplex an HTTP 1.1 that

00:27:52,539 --> 00:27:57,140
theoretically into you can and we

00:27:54,620 --> 00:28:04,429
talking about how we're going to do HTTP

00:27:57,140 --> 00:28:08,210
2.0 so yeah any questions on this one

00:28:04,429 --> 00:28:09,860
other thing I want to point out since

00:28:08,210 --> 00:28:11,750
these connections here persistent in

00:28:09,860 --> 00:28:13,520
these connections here persistent if you

00:28:11,750 --> 00:28:15,740
could have this really close to you in

00:28:13,520 --> 00:28:18,530
some geographic area like Denver and

00:28:15,740 --> 00:28:20,299
this mid is in I don't know Chicago or

00:28:18,530 --> 00:28:21,770
something like that since these

00:28:20,299 --> 00:28:23,570
connections always persistent when

00:28:21,770 --> 00:28:24,890
you're doing your TCP handshake you're

00:28:23,570 --> 00:28:26,780
only dealing with the latency of the

00:28:24,890 --> 00:28:29,299
round trip here and not having to deal

00:28:26,780 --> 00:28:31,179
with it going all the way to the origin

00:28:29,299 --> 00:28:35,720
so allows for faster connections

00:28:31,179 --> 00:28:38,419
connections set up and in this version

00:28:35,720 --> 00:28:39,950
of diagram I just have it than both

00:28:38,419 --> 00:28:42,499
connecting to both meds so you can see

00:28:39,950 --> 00:28:46,809
what the parent would it might look like

00:28:42,499 --> 00:28:50,539
with a consistent hatch parents election

00:28:46,809 --> 00:28:55,850
questions I guess you guys all know

00:28:50,539 --> 00:28:59,149
about tiered caching all right this is

00:28:55,850 --> 00:29:00,679
the last section is all the wonderful

00:28:59,149 --> 00:29:02,749
abstractions that we have so on top of

00:29:00,679 --> 00:29:06,320
all the wonderful things we do on with

00:29:02,749 --> 00:29:08,840
the CPU in the memory and the network we

00:29:06,320 --> 00:29:11,899
have these abstractions we put on top so

00:29:08,840 --> 00:29:14,840
we have our processors these are kind of

00:29:11,899 --> 00:29:17,090
related back to like the the thread

00:29:14,840 --> 00:29:19,369
types that we had before so we have a

00:29:17,090 --> 00:29:23,239
net processor and basically that sets up

00:29:19,369 --> 00:29:25,220
the the thread pool for the net and it's

00:29:23,239 --> 00:29:27,019
also responsible for scheduling the

00:29:25,220 --> 00:29:30,259
continuation so essentially this is

00:29:27,019 --> 00:29:31,850
where the event loops live and there's

00:29:30,259 --> 00:29:35,299
several different kinds there's host DB

00:29:31,850 --> 00:29:36,889
which is for caching DNS requests then

00:29:35,299 --> 00:29:38,809
there's a DNS one for actually doing the

00:29:36,889 --> 00:29:41,779
lookups there's the net which we talked

00:29:38,809 --> 00:29:44,330
about already SSL cash so all the cash

00:29:41,779 --> 00:29:48,950
lookups and all that happens on the cash

00:29:44,330 --> 00:29:51,169
processor and then remaps but you won't

00:29:48,950 --> 00:29:53,029
when you won't always have all these

00:29:51,169 --> 00:29:54,830
thread types so for instance you always

00:29:53,029 --> 00:29:57,080
have dns but you don't always have dns

00:29:54,830 --> 00:30:04,399
threads they actually fall back to

00:29:57,080 --> 00:30:06,259
running on the net processor threads we

00:30:04,399 --> 00:30:08,659
also have state machine state machines

00:30:06,259 --> 00:30:10,220
are very important so the processors are

00:30:08,659 --> 00:30:11,779
what's going to run the continuations

00:30:10,220 --> 00:30:14,119
and move things through but state

00:30:11,779 --> 00:30:16,639
machines are tracking where you are in

00:30:14,119 --> 00:30:18,230
the transaction so you know when you

00:30:16,639 --> 00:30:21,289
have when you have a connection then you

00:30:18,230 --> 00:30:27,200
do a DNS lookup on the origin then you

00:30:21,289 --> 00:30:28,749
need to do a cash look up and so on and

00:30:27,200 --> 00:30:31,669
so forth and in between all those

00:30:28,749 --> 00:30:33,139
distinct events there's what would

00:30:31,669 --> 00:30:35,450
normally be blocking time so when you're

00:30:33,139 --> 00:30:37,190
doing a DNS lookup it requests for the

00:30:35,450 --> 00:30:38,749
DNS server and in a normal application

00:30:37,190 --> 00:30:41,179
you might just sit there and wait until

00:30:38,749 --> 00:30:41,760
the new dns server returned back to you

00:30:41,179 --> 00:30:44,190
but

00:30:41,760 --> 00:30:46,800
what we'll do is say hey we're going to

00:30:44,190 --> 00:30:48,690
we're going to wait for an event on this

00:30:46,800 --> 00:30:50,220
network socket call us back when we're

00:30:48,690 --> 00:30:52,650
good and we'll set the state so that

00:30:50,220 --> 00:30:55,470
when we come back from the when we come

00:30:52,650 --> 00:30:59,280
back from the event loop will know where

00:30:55,470 --> 00:31:02,340
we are I have a picture about that on

00:30:59,280 --> 00:31:04,050
the next slide too also we do clustering

00:31:02,340 --> 00:31:05,760
which is that starts really an

00:31:04,050 --> 00:31:08,160
abstraction but thought it was very

00:31:05,760 --> 00:31:10,770
important to talk about so you can put

00:31:08,160 --> 00:31:13,980
several 80s instances together and

00:31:10,770 --> 00:31:15,150
cluster them and then if you have an

00:31:13,980 --> 00:31:17,100
incoming connection to one and it

00:31:15,150 --> 00:31:20,370
doesn't have the content it'll look it

00:31:17,100 --> 00:31:22,770
up on the other ones and pass it back

00:31:20,370 --> 00:31:28,170
through so basically they look like one

00:31:22,770 --> 00:31:29,790
giant 80s cash it does add state so you

00:31:28,170 --> 00:31:33,060
might not want to use it depends on your

00:31:29,790 --> 00:31:35,160
use case but it exists I believe there's

00:31:33,060 --> 00:31:37,350
only one there's one group that I know

00:31:35,160 --> 00:31:40,710
that uses it heavily and I don't know if

00:31:37,350 --> 00:31:47,270
they're even using it anymore do a

00:31:40,710 --> 00:31:49,770
question over here okay so here's I

00:31:47,270 --> 00:31:53,160
stole this from the documentation it's

00:31:49,770 --> 00:31:54,540
actually about API hooks but it also

00:31:53,160 --> 00:31:58,350
shows the state so that's why I wanted

00:31:54,540 --> 00:32:00,630
to show it here so so you you know you

00:31:58,350 --> 00:32:01,860
haven't except here and then you want to

00:32:00,630 --> 00:32:03,900
read through the request header and

00:32:01,860 --> 00:32:06,690
decide what you want to do you have the

00:32:03,900 --> 00:32:09,750
OS DNS lookup and that's where you would

00:32:06,690 --> 00:32:11,430
say okay I'm going to put this event in

00:32:09,750 --> 00:32:13,440
the event loop to when i get the dns

00:32:11,430 --> 00:32:15,690
information back and then i'll let some

00:32:13,440 --> 00:32:17,880
other continuation run and then when it

00:32:15,690 --> 00:32:20,070
comes back we do the cash look up and

00:32:17,880 --> 00:32:21,780
then i say oh there's i/o involved so

00:32:20,070 --> 00:32:24,840
i'm going to send this i/o request to

00:32:21,780 --> 00:32:26,190
the aio threads you know I want to get I

00:32:24,840 --> 00:32:29,520
wanted to see if this is in there get it

00:32:26,190 --> 00:32:32,310
off disk and then you do again you

00:32:29,520 --> 00:32:33,330
register your event and you go basically

00:32:32,310 --> 00:32:35,610
go to sleep while some other

00:32:33,330 --> 00:32:37,380
continuations run on the event loop so

00:32:35,610 --> 00:32:39,840
they're all interleave like that and it

00:32:37,380 --> 00:32:44,820
there's no context switching but you're

00:32:39,840 --> 00:32:47,120
switching in the transaction state any

00:32:44,820 --> 00:32:51,300
questions on that guys are so quiet

00:32:47,120 --> 00:32:52,620
moving too fast you guys want to get to

00:32:51,300 --> 00:32:55,970
be rhino in the last talk of the day

00:32:52,620 --> 00:32:55,970
that's what this is really about

00:32:56,889 --> 00:33:06,320
I'll buy somebody beer if they have a

00:32:58,940 --> 00:33:12,350
question all right all right well that's

00:33:06,320 --> 00:33:15,500
all I got so if you want to contact me

00:33:12,350 --> 00:33:16,970
there's my email address Twitter there's

00:33:15,500 --> 00:33:19,070
a this is where you can get the software

00:33:16,970 --> 00:33:21,169
and all kinds of other documentation

00:33:19,070 --> 00:33:24,409
that we have there and if you have

00:33:21,169 --> 00:33:26,779
questions we hang out and pound traffic

00:33:24,409 --> 00:33:28,490
server on freenode I'm psu game in there

00:33:26,779 --> 00:33:31,970
and all these guys right here in this

00:33:28,490 --> 00:33:33,500
row and this guy here and some other

00:33:31,970 --> 00:33:34,970
guys around flowing around maybe back

00:33:33,500 --> 00:33:38,450
there will be there to answer your

00:33:34,970 --> 00:33:40,880
questions as well so nothing else let's

00:33:38,450 --> 00:33:56,539
go get some beer or the keynotes and

00:33:40,880 --> 00:33:58,970
then go get some beer so just to repeat

00:33:56,539 --> 00:34:00,470
with Alan saying documentation is a

00:33:58,970 --> 00:34:02,120
really easy thing to work on so this

00:34:00,470 --> 00:34:03,620
looks interesting and you don't think

00:34:02,120 --> 00:34:05,269
you can contribute to the code right

00:34:03,620 --> 00:34:06,740
away because it's complex and you want

00:34:05,269 --> 00:34:08,300
to learn it better you can at least come

00:34:06,740 --> 00:34:10,869
find all these things that I did wrong

00:34:08,300 --> 00:34:16,300
in this presentation and go back and

00:34:10,869 --> 00:34:16,300
correct them in the documentation so

00:34:17,379 --> 00:34:21,250
nothing else oh wait

00:34:23,980 --> 00:34:37,570
yes hmm from from locking frizzy you

00:34:44,860 --> 00:35:00,310
wanted to say that in online because I

00:34:48,110 --> 00:35:04,130
didn't really understand that right

00:35:00,310 --> 00:35:08,090
right okay so and so that kind of goes

00:35:04,130 --> 00:35:10,610
back to not really to numa but kind of

00:35:08,090 --> 00:35:12,530
having the same everything together in

00:35:10,610 --> 00:35:14,120
one thread so you want to have kind of

00:35:12,530 --> 00:35:17,560
have a transaction hit one thread and

00:35:14,120 --> 00:35:17,560
stay on that one thread for its lifetime

00:35:23,410 --> 00:35:26,410
okay

00:35:31,230 --> 00:35:35,920
although I must add the global

00:35:34,030 --> 00:35:37,270
threadpool seems to be safer to use for

00:35:35,920 --> 00:35:39,630
certain things because I've seen a lot

00:35:37,270 --> 00:35:39,630
of crashes

00:36:20,920 --> 00:36:26,150
okay we should get the microphone so we

00:36:23,150 --> 00:36:28,670
can like we can hear that so I want to

00:36:26,150 --> 00:36:36,460
repeat all that but and Eric's trying to

00:36:28,670 --> 00:36:36,460
start the slow clap back there all right

00:36:42,650 --> 00:36:49,310
no Alan has alan wants more beer yeah I

00:36:47,810 --> 00:36:51,470
will buy you a beer i'm not going to

00:36:49,310 --> 00:36:53,000
defer your beers to anybody else so so

00:36:51,470 --> 00:36:54,770
if you want a beer and i also doing once

00:36:53,000 --> 00:37:13,430
you drink it then we'll do that but

00:36:54,770 --> 00:37:16,910
otherwise sorry non-transferable so the

00:37:13,430 --> 00:37:20,840
AL so i agree that the plugins are

00:37:16,910 --> 00:37:23,120
limited need work and and yes I can he

00:37:20,840 --> 00:37:25,250
was making the comment that he felt that

00:37:23,120 --> 00:37:26,570
the plugin api's were little limited

00:37:25,250 --> 00:37:28,490
that that all these wonderful things

00:37:26,570 --> 00:37:29,990
that I just talked about you didn't have

00:37:28,490 --> 00:37:33,910
access to all of them for instance the

00:37:29,990 --> 00:37:36,020
free list the alligators and we are

00:37:33,910 --> 00:37:37,520
we're currently in the process of

00:37:36,020 --> 00:37:39,950
working on our five point overly so

00:37:37,520 --> 00:37:43,340
we're allowed to break api's right now

00:37:39,950 --> 00:37:46,070
and so life is hard at work on breaking

00:37:43,340 --> 00:37:48,500
everything he can and getting us to fix

00:37:46,070 --> 00:37:50,180
it for him and and one of the tickets

00:37:48,500 --> 00:37:53,240
that he has open actually for me is to

00:37:50,180 --> 00:37:56,570
have the plug-in API have access to free

00:37:53,240 --> 00:37:58,930
lists and there's some discussion on how

00:37:56,570 --> 00:37:58,930
to do that

00:38:12,930 --> 00:38:24,930
so so Alan saying that he wants to add a

00:38:21,009 --> 00:38:24,930
lot of the network internal network

00:38:24,990 --> 00:38:31,119
helpers into the plug-in API and also

00:38:29,470 --> 00:38:33,400
know that he wants to add a lot of cash

00:38:31,119 --> 00:38:35,259
stuff to the plug-in API based on his

00:38:33,400 --> 00:38:36,700
talk to talks to go that I know you were

00:38:35,259 --> 00:38:41,079
all here for as well because you love

00:38:36,700 --> 00:38:45,910
80's that much what a mighty magic words

00:38:41,079 --> 00:38:47,710
Eric supposed to be thanking me I'm the

00:38:45,910 --> 00:38:51,210
one who gave you the information she can

00:38:47,710 --> 00:38:51,210

YouTube URL: https://www.youtube.com/watch?v=E8fVQ1isd6E


