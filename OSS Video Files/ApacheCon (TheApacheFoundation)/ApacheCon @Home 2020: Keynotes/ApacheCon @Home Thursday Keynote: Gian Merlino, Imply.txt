Title: ApacheCon @Home Thursday Keynote: Gian Merlino, Imply
Publication date: 2020-10-09
Playlist: ApacheCon @Home 2020: Keynotes
Description: 
	The heat is on: architecting for hot analytics

Gian Merlino, CTO and Co-Founder, Imply and Apache Druid PMC Chair


Today, the industry offers numerous systems for the analysis of large amounts of data. Under the hood, they span a variety of interesting and unique architectures. In this talk, we'll discuss why you can never seem to find that single perfect system, and how to think about and evaluate the capabilities of various systems through the prism of a temperature-based spectrum of use cases, from cold to hot analytics.


ApacheCon @Home 2020 - https://apachecon.com/acah2020/
The Apache Software Foundation - https://apache.org
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,160 --> 00:00:28,160
we're now going to move on to our final

00:00:26,560 --> 00:00:30,400
keynote of the morning and

00:00:28,160 --> 00:00:31,279
our final keynote of this year's apache

00:00:30,400 --> 00:00:34,719
con

00:00:31,279 --> 00:00:37,760
our next speaker is gian morlino

00:00:34,719 --> 00:00:38,640
and merlino and he is uh the cto and

00:00:37,760 --> 00:00:40,960
co-founder of

00:00:38,640 --> 00:00:43,440
imply he's also the pmc chair of the

00:00:40,960 --> 00:00:46,480
apache druid project

00:00:43,440 --> 00:00:49,600
so welcome and uh

00:00:46,480 --> 00:00:52,239
i will uh get out of your way here

00:00:49,600 --> 00:00:53,199
all right hey cool great um let me share

00:00:52,239 --> 00:00:56,640
my screen

00:00:53,199 --> 00:00:59,039
all right and

00:00:56,640 --> 00:00:59,840
here we go uh very good i can see it i

00:00:59,039 --> 00:01:03,199
see me again too

00:00:59,840 --> 00:01:04,720
great um hey everybody uh thanks for

00:01:03,199 --> 00:01:06,799
uh thanks for the intro thanks for the

00:01:04,720 --> 00:01:08,799
opportunity to speak here

00:01:06,799 --> 00:01:10,080
um twice i really enjoyed speaking on

00:01:08,799 --> 00:01:12,640
tuesday uh

00:01:10,080 --> 00:01:13,680
kind of in depth technically about the

00:01:12,640 --> 00:01:15,200
the project that

00:01:13,680 --> 00:01:17,759
that i spent most of my time on apache

00:01:15,200 --> 00:01:18,880
druid um and today at least talking a

00:01:17,759 --> 00:01:22,240
little bit more high level

00:01:18,880 --> 00:01:25,119
about um you know apache

00:01:22,240 --> 00:01:27,200
apache projects have done a lot of great

00:01:25,119 --> 00:01:30,560
work in the data space over the last

00:01:27,200 --> 00:01:31,759
uh couple decades and i wanted to talk

00:01:30,560 --> 00:01:34,159
about

00:01:31,759 --> 00:01:36,079
sort of a way that that at least in the

00:01:34,159 --> 00:01:37,759
druid world

00:01:36,079 --> 00:01:39,200
and and from what i can see how we've

00:01:37,759 --> 00:01:40,720
been thinking about how

00:01:39,200 --> 00:01:42,880
data architecture has evolved and what

00:01:40,720 --> 00:01:44,880
part apache has to play in that

00:01:42,880 --> 00:01:47,119
and a part apache project's playing that

00:01:44,880 --> 00:01:47,119
so

00:01:47,360 --> 00:01:52,799
let's uh let's talk about that and the

00:01:50,399 --> 00:01:55,520
title of the talk is the heat is on

00:01:52,799 --> 00:01:56,399
meant to be evoking the fact that uh the

00:01:55,520 --> 00:01:58,799
theme i think

00:01:56,399 --> 00:01:59,520
of the first wave of big data work was

00:01:58,799 --> 00:02:00,960
just about

00:01:59,520 --> 00:02:02,560
getting things to work at all getting

00:02:00,960 --> 00:02:04,560
things to scale um

00:02:02,560 --> 00:02:06,799
now uh all the focus is on getting

00:02:04,560 --> 00:02:08,080
things to be lightning fast

00:02:06,799 --> 00:02:10,399
so how do we think about that how do we

00:02:08,080 --> 00:02:13,120
do that so who am i

00:02:10,399 --> 00:02:13,520
um um gian rolino uh like richard

00:02:13,120 --> 00:02:16,400
mentioned

00:02:13,520 --> 00:02:18,959
committer and pmc chair and apache druid

00:02:16,400 --> 00:02:21,840
and i'm also co-founder of imply

00:02:18,959 --> 00:02:23,040
which is a company that is built around

00:02:21,840 --> 00:02:25,120
apache druid and

00:02:23,040 --> 00:02:26,720
where we spend a lot of time and effort

00:02:25,120 --> 00:02:29,120
contributing to apache druid

00:02:26,720 --> 00:02:29,760
um and uh little point if you're

00:02:29,120 --> 00:02:32,640
interested in

00:02:29,760 --> 00:02:33,040
and getting paid to work on uh projects

00:02:32,640 --> 00:02:36,400
like

00:02:33,040 --> 00:02:39,440
druid then uh give me a chat afterwards

00:02:36,400 --> 00:02:41,200
um so agenda

00:02:39,440 --> 00:02:42,720
we'll talk about today strolling down

00:02:41,200 --> 00:02:44,959
memory lane um

00:02:42,720 --> 00:02:47,440
looking at some of the the work that's

00:02:44,959 --> 00:02:49,519
been done over the past 15 years or so

00:02:47,440 --> 00:02:50,800
in the in data architectures and where

00:02:49,519 --> 00:02:54,000
we might go from here

00:02:50,800 --> 00:02:57,519
and then this idea can we have it all in

00:02:54,000 --> 00:02:57,519
in asf alone we've got

00:02:57,680 --> 00:03:02,319
dozens of data projects filling all

00:03:00,159 --> 00:03:05,360
kinds of different niches

00:03:02,319 --> 00:03:08,400
and i've got some thoughts

00:03:05,360 --> 00:03:12,560
uh on why there's so many and

00:03:08,400 --> 00:03:12,560
um how things might look in the future

00:03:12,800 --> 00:03:16,480
okay so first off strolling down memory

00:03:14,560 --> 00:03:18,319
lane and displaying the network lane

00:03:16,480 --> 00:03:19,760
we're gonna be talking about uh

00:03:18,319 --> 00:03:22,080
hardware and architecture and how they

00:03:19,760 --> 00:03:25,040
evolve together

00:03:22,080 --> 00:03:25,920
so in the good old days uh before big

00:03:25,040 --> 00:03:28,959
data

00:03:25,920 --> 00:03:30,239
um your analytics architecture

00:03:28,959 --> 00:03:32,239
you didn't really have one you had a

00:03:30,239 --> 00:03:33,120
relational database that you put all

00:03:32,239 --> 00:03:34,560
your stuff in

00:03:33,120 --> 00:03:36,239
whether whatever related to your

00:03:34,560 --> 00:03:39,360
business whether it was your

00:03:36,239 --> 00:03:40,799
shopping carts or your information from

00:03:39,360 --> 00:03:41,360
your point of sale system or what have

00:03:40,799 --> 00:03:42,799
you

00:03:41,360 --> 00:03:45,040
you put that in your relational database

00:03:42,799 --> 00:03:46,799
and you do analytical and transactional

00:03:45,040 --> 00:03:50,080
queries on the same database

00:03:46,799 --> 00:03:52,239
um this works fine for

00:03:50,080 --> 00:03:53,760
small data sets and relatively modest

00:03:52,239 --> 00:03:55,519
analytics needs it's a

00:03:53,760 --> 00:03:58,879
and it's it's where a lot of people

00:03:55,519 --> 00:03:58,879
start and where the industry started

00:03:59,680 --> 00:04:04,400
pretty soon people realize that doing

00:04:02,560 --> 00:04:05,920
all of your analytical queries out of

00:04:04,400 --> 00:04:08,319
the same database that you're running

00:04:05,920 --> 00:04:10,159
your business on is not a great idea

00:04:08,319 --> 00:04:11,519
and so it makes sense to separate your

00:04:10,159 --> 00:04:13,920
analytical architecture

00:04:11,519 --> 00:04:15,599
from the system that runs your business

00:04:13,920 --> 00:04:17,120
uh and so that's where the data

00:04:15,599 --> 00:04:19,600
warehouse concept comes from

00:04:17,120 --> 00:04:20,959
um that's this is one of the oldest uh

00:04:19,600 --> 00:04:22,320
analytical architectures

00:04:20,959 --> 00:04:25,040
and the first ones were just single

00:04:22,320 --> 00:04:28,479
machines um later data warehouses

00:04:25,040 --> 00:04:31,520
uh especially in the mid to late 90s

00:04:28,479 --> 00:04:34,400
started becoming scale out and clustered

00:04:31,520 --> 00:04:35,360
and you have some etl process as they

00:04:34,400 --> 00:04:37,440
call it extract

00:04:35,360 --> 00:04:38,800
transform load to get data out of the

00:04:37,440 --> 00:04:40,479
database that runs your business

00:04:38,800 --> 00:04:43,600
and into the database that you're going

00:04:40,479 --> 00:04:46,080
to use for analyzing your business

00:04:43,600 --> 00:04:47,680
um a lot of this stuff is still based

00:04:46,080 --> 00:04:49,199
around single machine installation so

00:04:47,680 --> 00:04:52,160
you're going to have one machine running

00:04:49,199 --> 00:04:53,680
your transactional database one machine

00:04:52,160 --> 00:04:55,120
running your data warehouse and then

00:04:53,680 --> 00:04:58,240
maybe a third machine running

00:04:55,120 --> 00:04:58,240
your transformations

00:05:01,120 --> 00:05:04,320
these data warehouses being single

00:05:03,280 --> 00:05:08,960
machines

00:05:04,320 --> 00:05:10,560
being single bottlenecks tends to

00:05:08,960 --> 00:05:11,759
they tended to have scaling issues

00:05:10,560 --> 00:05:13,520
people would start getting bigger and

00:05:11,759 --> 00:05:14,880
bigger warehouses trying to fit as many

00:05:13,520 --> 00:05:16,160
processors as they can as much

00:05:14,880 --> 00:05:18,479
memory and disk as they can in that

00:05:16,160 --> 00:05:20,160
machine and

00:05:18,479 --> 00:05:22,000
for the purpose of doing a wide variety

00:05:20,160 --> 00:05:23,759
of workloads on them people would do

00:05:22,000 --> 00:05:26,320
reporting workloads people would do

00:05:23,759 --> 00:05:29,440
online workloads

00:05:26,320 --> 00:05:29,759
and what started being popular uh after

00:05:29,440 --> 00:05:32,240
some

00:05:29,759 --> 00:05:32,960
additional time is having a third

00:05:32,240 --> 00:05:34,960
database

00:05:32,960 --> 00:05:37,440
your online analytical database your

00:05:34,960 --> 00:05:39,759
olap database so the ola stands for

00:05:37,440 --> 00:05:41,120
um and your online analytical database

00:05:39,759 --> 00:05:43,039
is something that

00:05:41,120 --> 00:05:44,479
is geared towards a more narrow range of

00:05:43,039 --> 00:05:45,600
use cases in your warehouse your

00:05:44,479 --> 00:05:46,560
warehouse to sort of do anything

00:05:45,600 --> 00:05:48,639
analytical

00:05:46,560 --> 00:05:50,160
your online analytical database will do

00:05:48,639 --> 00:05:51,680
the online stuff we'll do stuff that

00:05:50,160 --> 00:05:53,199
needs to be interactive needs to be

00:05:51,680 --> 00:05:54,080
super high speed and for this we're

00:05:53,199 --> 00:05:57,199
targeting

00:05:54,080 --> 00:05:59,440
uh really high performance stuff um we

00:05:57,199 --> 00:06:01,280
might store a subset of the data

00:05:59,440 --> 00:06:02,400
we might store a summarized version of

00:06:01,280 --> 00:06:03,600
the data you know we'll do whatever

00:06:02,400 --> 00:06:05,440
tricks we need to do to get that

00:06:03,600 --> 00:06:08,000
performance

00:06:05,440 --> 00:06:08,479
and so that enables uh not just ability

00:06:08,000 --> 00:06:10,240
to do

00:06:08,479 --> 00:06:13,600
analytics but it enables the ability to

00:06:10,240 --> 00:06:15,440
do it really rapidly which is great

00:06:13,600 --> 00:06:16,800
um these are still sort of the single

00:06:15,440 --> 00:06:18,800
machine world uh

00:06:16,800 --> 00:06:20,560
we keep moving on in the evolution this

00:06:18,800 --> 00:06:21,680
is the big data world

00:06:20,560 --> 00:06:23,840
and the big data world changes

00:06:21,680 --> 00:06:24,880
everything um now we don't have that

00:06:23,840 --> 00:06:27,360
warehouses anymore

00:06:24,880 --> 00:06:28,800
we don't have olap databases anymore uh

00:06:27,360 --> 00:06:30,400
what we have is we have a bunch of data

00:06:28,800 --> 00:06:32,800
sources that are all sharded out

00:06:30,400 --> 00:06:34,720
everything is multi-machine now we're

00:06:32,800 --> 00:06:37,600
using technologies like uh

00:06:34,720 --> 00:06:39,280
like kafka and airflow to get data

00:06:37,600 --> 00:06:40,960
moving from place to place

00:06:39,280 --> 00:06:42,319
um one of the places they're going to

00:06:40,960 --> 00:06:45,759
live in is a data lake

00:06:42,319 --> 00:06:48,240
uh it might be one based on hdfs

00:06:45,759 --> 00:06:49,120
another apache project that's going to

00:06:48,240 --> 00:06:50,639
be a pure

00:06:49,120 --> 00:06:52,240
storage there's not going to be any

00:06:50,639 --> 00:06:55,039
computation happening there

00:06:52,240 --> 00:06:55,759
um and then you have a query engine that

00:06:55,039 --> 00:06:56,960
queries

00:06:55,759 --> 00:06:59,280
stuff from the data lake might be

00:06:56,960 --> 00:07:03,199
something like hive

00:06:59,280 --> 00:07:05,280
or maybe like mapreduce um and

00:07:03,199 --> 00:07:06,400
the idea here is that we sort of split

00:07:05,280 --> 00:07:07,759
stuff into

00:07:06,400 --> 00:07:09,440
different kinds of components instead of

00:07:07,759 --> 00:07:11,199
having a

00:07:09,440 --> 00:07:12,639
warehouse an olap database we have a

00:07:11,199 --> 00:07:14,240
lake it does storage and we have a query

00:07:12,639 --> 00:07:15,599
engine that does query and each one can

00:07:14,240 --> 00:07:17,120
scale out

00:07:15,599 --> 00:07:18,639
each one can scale out to as much

00:07:17,120 --> 00:07:21,840
storage as you want as much

00:07:18,639 --> 00:07:23,280
quarry capabilities as you want and then

00:07:21,840 --> 00:07:27,440
each of these arrows is also

00:07:23,280 --> 00:07:27,440
scale out data movement arrows

00:07:28,560 --> 00:07:33,120
of course uh everything that has

00:07:31,919 --> 00:07:34,160
happened in the past is destined to

00:07:33,120 --> 00:07:35,840
happen again

00:07:34,160 --> 00:07:37,280
um and then people started adding

00:07:35,840 --> 00:07:40,400
serving databases to this

00:07:37,280 --> 00:07:41,840
uh people are not necessarily running

00:07:40,400 --> 00:07:43,520
interactive analytical applications on

00:07:41,840 --> 00:07:46,400
top of apache hive what they might be

00:07:43,520 --> 00:07:48,960
doing is they might run them on top of

00:07:46,400 --> 00:07:51,440
hbase or cassandra where a couple of the

00:07:48,960 --> 00:07:54,639
early choices people use there

00:07:51,440 --> 00:07:56,479
and those are databases that while not

00:07:54,639 --> 00:07:58,800
being as

00:07:56,479 --> 00:08:01,520
maybe not being as capable as something

00:07:58,800 --> 00:08:02,319
like in terms of quarry functionality

00:08:01,520 --> 00:08:03,520
and power

00:08:02,319 --> 00:08:04,800
are able to serve things much more

00:08:03,520 --> 00:08:06,240
quickly and are able to store more

00:08:04,800 --> 00:08:09,680
optimized copies

00:08:06,240 --> 00:08:11,360
um the database that i work on

00:08:09,680 --> 00:08:14,639
druid is in that category in that

00:08:11,360 --> 00:08:14,639
category of serving database

00:08:14,879 --> 00:08:18,400
uh and so you sort of think of this as

00:08:16,240 --> 00:08:20,080
like an online your online database you

00:08:18,400 --> 00:08:22,720
have a query engine that might run

00:08:20,080 --> 00:08:23,199
using uh might run in yarn might run

00:08:22,720 --> 00:08:25,520
using some

00:08:23,199 --> 00:08:27,039
sort of elastic infrastructure might

00:08:25,520 --> 00:08:28,400
spin it up and spin it down and then you

00:08:27,039 --> 00:08:29,840
have an online database

00:08:28,400 --> 00:08:32,080
that's more likely to be continuously

00:08:29,840 --> 00:08:34,560
running and is going to be used for

00:08:32,080 --> 00:08:36,240
these really low latency

00:08:34,560 --> 00:08:38,399
these low latency online use cases the

00:08:36,240 --> 00:08:39,200
equivalent of the olap databases of your

00:08:38,399 --> 00:08:41,360
and that's

00:08:39,200 --> 00:08:42,719
like i said that's the the category that

00:08:41,360 --> 00:08:45,600
um that

00:08:42,719 --> 00:08:46,880
the practice i work on about here is in

00:08:45,600 --> 00:08:49,839
um

00:08:46,880 --> 00:08:51,200
and we sort of have now have we've sort

00:08:49,839 --> 00:08:53,279
of now come to

00:08:51,200 --> 00:08:54,959
today this is a picture of a lot of

00:08:53,279 --> 00:08:56,000
people's data stacks internally you have

00:08:54,959 --> 00:08:57,920
a bunch of

00:08:56,000 --> 00:08:59,279
federated data sources you're moving

00:08:57,920 --> 00:09:00,240
data around with a bunch of big data

00:08:59,279 --> 00:09:01,360
technologies

00:09:00,240 --> 00:09:03,519
you're storing a lot of stuff in the

00:09:01,360 --> 00:09:04,959
lake coring it with query engines

00:09:03,519 --> 00:09:06,880
and then you're also going to have some

00:09:04,959 --> 00:09:09,040
collection of online databases

00:09:06,880 --> 00:09:10,160
that are serving your online use cases

00:09:09,040 --> 00:09:11,440
that need to be

00:09:10,160 --> 00:09:14,000
always available and need to be really

00:09:11,440 --> 00:09:14,000
latency

00:09:14,160 --> 00:09:19,519
um so these are some

00:09:17,360 --> 00:09:20,959
why do we do that why do we separate why

00:09:19,519 --> 00:09:23,200
do we separate query engines from online

00:09:20,959 --> 00:09:25,519
databases the reason is performance

00:09:23,200 --> 00:09:26,880
so uh these are some third-party

00:09:25,519 --> 00:09:28,959
benchmarks and never trust the

00:09:26,880 --> 00:09:30,800
benchmarks done by the project itself

00:09:28,959 --> 00:09:32,240
so these are there's some third-party

00:09:30,800 --> 00:09:34,320
ones um

00:09:32,240 --> 00:09:36,480
apache juror versus hive and apache

00:09:34,320 --> 00:09:38,399
versus presto uh

00:09:36,480 --> 00:09:40,000
and we see pretty big speed ups we see

00:09:38,399 --> 00:09:43,760
speed ups in the

00:09:40,000 --> 00:09:46,080
double triple digit range um and so this

00:09:43,760 --> 00:09:48,320
is this is what motivates people to use

00:09:46,080 --> 00:09:49,440
these online databases and these survey

00:09:48,320 --> 00:09:51,120
databases for

00:09:49,440 --> 00:09:53,680
applications that need to have really

00:09:51,120 --> 00:09:56,240
latency um

00:09:53,680 --> 00:09:57,440
but why not why do these both why don't

00:09:56,240 --> 00:09:58,959
you use something like

00:09:57,440 --> 00:10:00,560
why aren't using something like druid or

00:09:58,959 --> 00:10:01,680
hbase or cassandra for everything these

00:10:00,560 --> 00:10:02,839
things that people use for serving

00:10:01,680 --> 00:10:06,320
databases

00:10:02,839 --> 00:10:09,600
um and the reason is usually

00:10:06,320 --> 00:10:10,560
cost or query power so traditionally a

00:10:09,600 --> 00:10:12,720
lot of these

00:10:10,560 --> 00:10:14,160
a lot of these databases designed for

00:10:12,720 --> 00:10:17,120
survey

00:10:14,160 --> 00:10:17,680
don't always have the full uh i would

00:10:17,120 --> 00:10:19,519
say

00:10:17,680 --> 00:10:21,440
express ability and power of something

00:10:19,519 --> 00:10:23,680
designed as an offline quarter engine

00:10:21,440 --> 00:10:24,560
um or since design is a query engine and

00:10:23,680 --> 00:10:26,160
also cost

00:10:24,560 --> 00:10:27,600
these query engines are you know i

00:10:26,160 --> 00:10:29,200
mentioned earlier that you can run them

00:10:27,600 --> 00:10:30,079
on yarn you can sort of scale them up

00:10:29,200 --> 00:10:32,480
and scale them down

00:10:30,079 --> 00:10:34,880
with quarries spin up resources to do a

00:10:32,480 --> 00:10:36,560
query spin them down the quarry is done

00:10:34,880 --> 00:10:38,399
and these online databases are designed

00:10:36,560 --> 00:10:40,720
to be on all the time

00:10:38,399 --> 00:10:42,480
um and so they're best for their best

00:10:40,720 --> 00:10:44,560
use for applications that

00:10:42,480 --> 00:10:45,839
actually need to be available 24 7 and

00:10:44,560 --> 00:10:47,279
actually have highly concurrent usage

00:10:45,839 --> 00:10:49,040
all the time otherwise you're likely to

00:10:47,279 --> 00:10:52,000
pay for resources that you're not

00:10:49,040 --> 00:10:55,040
actually using and so that's why both of

00:10:52,000 --> 00:10:55,040
them have a place in the world

00:10:55,120 --> 00:10:59,120
but can we have it all uh so this is

00:10:57,920 --> 00:11:00,720
this is the part where

00:10:59,120 --> 00:11:02,640
i want to talk about the future can we

00:11:00,720 --> 00:11:05,120
have it all can we imagine a world

00:11:02,640 --> 00:11:06,720
where um we actually don't need to split

00:11:05,120 --> 00:11:08,160
things into into quarry engines and

00:11:06,720 --> 00:11:11,920
serving databases and

00:11:08,160 --> 00:11:11,920
where we can can we build a system

00:11:12,160 --> 00:11:15,839
that can actually handle both of these

00:11:13,600 --> 00:11:18,720
things

00:11:15,839 --> 00:11:19,120
so to answer that or to think about that

00:11:18,720 --> 00:11:20,560
um

00:11:19,120 --> 00:11:22,480
i don't necessarily have an answer for

00:11:20,560 --> 00:11:23,279
you but i have some things to think

00:11:22,480 --> 00:11:25,680
about

00:11:23,279 --> 00:11:26,839
um let's look at some of the differences

00:11:25,680 --> 00:11:30,000
between the systems

00:11:26,839 --> 00:11:32,000
so on the query engine side

00:11:30,000 --> 00:11:34,160
um we have data and remember this is

00:11:32,000 --> 00:11:37,600
things like hive and presto

00:11:34,160 --> 00:11:39,440
we're fetching data on demand um they're

00:11:37,600 --> 00:11:41,600
elastic they're fault tolerant they're

00:11:39,440 --> 00:11:43,920
shared nothing

00:11:41,600 --> 00:11:44,880
um on the server database side things

00:11:43,920 --> 00:11:47,600
like druid

00:11:44,880 --> 00:11:48,640
we have those same properties um we're

00:11:47,600 --> 00:11:50,160
loading data

00:11:48,640 --> 00:11:52,240
uh from batch we're loading data and

00:11:50,160 --> 00:11:53,600
streaming um

00:11:52,240 --> 00:11:55,200
the one important difference is that

00:11:53,600 --> 00:11:56,480
instead of fetching data ahead of time

00:11:55,200 --> 00:11:58,800
oh sorry instead of fetching data on

00:11:56,480 --> 00:12:01,680
demand we're fetching data ahead of time

00:11:58,800 --> 00:12:03,120
partitioning it and indexing it and then

00:12:01,680 --> 00:12:04,800
keeping it available on those servers at

00:12:03,120 --> 00:12:06,079
all times and that ahead of time fetch

00:12:04,800 --> 00:12:08,480
versus on-demand fetch is a big

00:12:06,079 --> 00:12:08,480
difference

00:12:08,800 --> 00:12:12,079
some other differences uh on the quarry

00:12:10,880 --> 00:12:14,399
engine side

00:12:12,079 --> 00:12:16,399
the we're supporting federated data

00:12:14,399 --> 00:12:19,440
sources so we're going to be coordinated

00:12:16,399 --> 00:12:20,000
live somewhere else on the database side

00:12:19,440 --> 00:12:21,440
on the

00:12:20,000 --> 00:12:22,880
serving database side we actually are a

00:12:21,440 --> 00:12:25,680
database we're going to be storing data

00:12:22,880 --> 00:12:27,680
within ourselves

00:12:25,680 --> 00:12:28,800
there's on the core engine side spot

00:12:27,680 --> 00:12:30,720
elasticity

00:12:28,800 --> 00:12:33,360
is something that is really cool it's

00:12:30,720 --> 00:12:36,399
that's the ability to

00:12:33,360 --> 00:12:37,839
scale up and scale down really rapidly

00:12:36,399 --> 00:12:38,959
and on the certain database side you're

00:12:37,839 --> 00:12:39,600
gonna get better performance on the same

00:12:38,959 --> 00:12:41,680
hardware

00:12:39,600 --> 00:12:42,800
um by actually designing the query

00:12:41,680 --> 00:12:44,880
engine and data

00:12:42,800 --> 00:12:46,639
engine uh to work really closely

00:12:44,880 --> 00:12:48,079
together the data format or engine to

00:12:46,639 --> 00:12:50,240
work really closely together

00:12:48,079 --> 00:12:52,160
um you get better performance that is

00:12:50,240 --> 00:12:53,600
possible with with a query engine plus a

00:12:52,160 --> 00:12:55,120
data lake that's that's where we get

00:12:53,600 --> 00:12:56,000
these double triple digits speed ups

00:12:55,120 --> 00:12:57,440
from

00:12:56,000 --> 00:12:58,800
um you also get a lower performance

00:12:57,440 --> 00:12:59,519
floor by having everything all stored

00:12:58,800 --> 00:13:02,560
together

00:12:59,519 --> 00:13:04,160
um you get to actually use the whole

00:13:02,560 --> 00:13:06,880
buffalo so to speak of the server you

00:13:04,160 --> 00:13:08,800
get to use memory and disk and network

00:13:06,880 --> 00:13:10,320
uh at to the fullest as opposed to the

00:13:08,800 --> 00:13:12,880
query engines which mostly focus

00:13:10,320 --> 00:13:16,399
on um they mostly focus on network they

00:13:12,880 --> 00:13:16,399
also focus on retrieving data remotely

00:13:16,480 --> 00:13:22,000
um so when we dig into these differences

00:13:19,680 --> 00:13:22,880
they they actually don't look they don't

00:13:22,000 --> 00:13:24,480
look that

00:13:22,880 --> 00:13:26,079
huge they look like you know it looks

00:13:24,480 --> 00:13:28,079
like their differences are things like

00:13:26,079 --> 00:13:29,680
are we fetching data ahead of time or we

00:13:28,079 --> 00:13:32,240
effection date on demand

00:13:29,680 --> 00:13:33,360
um are we storing data locally or are we

00:13:32,240 --> 00:13:36,399
querying it remotely

00:13:33,360 --> 00:13:37,839
do we allow external tables or do we do

00:13:36,399 --> 00:13:38,720
all tables require data in our own

00:13:37,839 --> 00:13:42,000
format

00:13:38,720 --> 00:13:43,760
um and you can uh this this little

00:13:42,000 --> 00:13:45,279
diagram i have here is a diagram of how

00:13:43,760 --> 00:13:46,959
it works internally internally jordan

00:13:45,279 --> 00:13:48,000
actually does use a data link for

00:13:46,959 --> 00:13:52,320
storage

00:13:48,000 --> 00:13:54,480
um it just doesn't query it directly

00:13:52,320 --> 00:13:55,519
and so you can imagine um you can

00:13:54,480 --> 00:13:57,519
imagine what if

00:13:55,519 --> 00:13:59,199
instead of pulling data from deep

00:13:57,519 --> 00:14:00,560
storage locally and then ordering it

00:13:59,199 --> 00:14:01,199
what if we ordered directly out of deep

00:14:00,560 --> 00:14:02,480
storage

00:14:01,199 --> 00:14:03,920
we wouldn't be able to use as many

00:14:02,480 --> 00:14:05,360
indexes because we wouldn't have the

00:14:03,920 --> 00:14:06,959
ability to random access

00:14:05,360 --> 00:14:08,399
over the network we need to focus on

00:14:06,959 --> 00:14:11,920
sequential scans

00:14:08,399 --> 00:14:12,880
um but that would enable better spot

00:14:11,920 --> 00:14:14,560
elasticity

00:14:12,880 --> 00:14:16,320
and on the flip side what if something

00:14:14,560 --> 00:14:19,040
what if one of these query engines

00:14:16,320 --> 00:14:21,120
decided to aggressively cache data

00:14:19,040 --> 00:14:24,000
locally

00:14:21,120 --> 00:14:25,279
and on the flip side again what if juror

00:14:24,000 --> 00:14:27,279
decided to add support for several

00:14:25,279 --> 00:14:29,440
tables

00:14:27,279 --> 00:14:31,279
so it's i guess what i'm trying to say

00:14:29,440 --> 00:14:32,959
here is that that these things to me

00:14:31,279 --> 00:14:34,160
don't seem too fundamentally different

00:14:32,959 --> 00:14:36,560
it seems like

00:14:34,160 --> 00:14:37,199
a natural evolution towards the future

00:14:36,560 --> 00:14:40,399
is

00:14:37,199 --> 00:14:42,880
a system that's actually able to to

00:14:40,399 --> 00:14:44,160
satisfy both of these kinds of workloads

00:14:42,880 --> 00:14:45,360
and maybe simplify the weekday

00:14:44,160 --> 00:14:47,120
architecture a little bit

00:14:45,360 --> 00:14:49,360
and that's one of the reasons i'm so

00:14:47,120 --> 00:14:51,199
excited about working

00:14:49,360 --> 00:14:52,959
i guess in the apache ecosystem and on

00:14:51,199 --> 00:14:54,480
apache george specifically because i

00:14:52,959 --> 00:14:56,160
think that these sorts of

00:14:54,480 --> 00:14:58,480
these sorts of communities are really a

00:14:56,160 --> 00:15:02,000
really great ways to explore these ideas

00:14:58,480 --> 00:15:03,279
and a lot of great software's come out

00:15:02,000 --> 00:15:04,560
in the past with these efforts and i

00:15:03,279 --> 00:15:05,600
think there's a lot of great software

00:15:04,560 --> 00:15:07,360
that's that's due to come out in the

00:15:05,600 --> 00:15:09,920
future

00:15:07,360 --> 00:15:09,920
so with that

00:15:10,480 --> 00:15:15,600
thank you for coming and um hopefully i

00:15:13,120 --> 00:15:18,079
left you with something to think about

00:15:15,600 --> 00:15:19,440
thank you so much for taking the time to

00:15:18,079 --> 00:15:27,839
speak with us today

00:15:19,440 --> 00:15:27,839
and uh thank you everyone for attending

00:15:30,000 --> 00:15:32,079

YouTube URL: https://www.youtube.com/watch?v=7Zt0DyOU5ZY


