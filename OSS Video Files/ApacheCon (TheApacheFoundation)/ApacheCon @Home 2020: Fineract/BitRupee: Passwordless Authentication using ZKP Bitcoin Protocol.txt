Title: BitRupee: Passwordless Authentication using ZKP Bitcoin Protocol
Publication date: 2020-10-17
Playlist: ApacheCon @Home 2020: Fineract
Description: 
	BitRupee: Passwordless Authentication using ZKP Bitcoin Protocol
Saransh Sharma, Atharva Dhekne, Advait Madhekar

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

In this digital day and age, passwords are no longer adequate. Users worldwide are victims of multiple malfeasances like brute force attacks, injection attacks, phishing, unsafe credentials, data theft, among others. The flaws of using passwords - which have increasingly become predictable, leave users vulnerable to data and identity theft. Even the strongest passwords are easy to crack and prone to phishing nonetheless. Hence, given all these nuisances, thereâ€™s a need to eliminate character-based authentication protocols, which would ultimately benefit all developers as well as end-users. An implementation on Apache Fineract will also be presented.

Saransh Sharma
Saransh carries out research in multiple fields like mathematics and Open Source. He is a Researcher at Muellners, as well as its non-profit arm Muellners Foundation. Saransh is a Core Committer of Apache Fineract and is an active supporter of Fintech.

Atharva Dhekne
Atharva is a Research Fellow & Technical Writer for Muellners Foundation, working on multiple projects in Fintech as well as other domains. Being an Open Source enthusiast, Atharva contributes to multiple OSS organizations - he is also a Technical Writer & Core Committer at WordPress.org. Atharva is completing his undergraduate Computer Engineering studies at the University of Pune (SPPU).

Advait Madhekar
Advait is a Research Fellow & Technical Writer for Muellners Foundation, working on multiple projects in Fintech as well as other domains. He is completing his undergraduate Mechanical Engineering studies at the University of Pune (SPPU).
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,080 --> 00:00:27,680
uh

00:00:24,480 --> 00:00:29,279
welcome to day three of apache con and

00:00:27,680 --> 00:00:31,119
the finrax track

00:00:29,279 --> 00:00:33,120
i'm wearing javier shoes for a little

00:00:31,119 --> 00:00:34,480
bit in the morning and introducing this

00:00:33,120 --> 00:00:36,399
session

00:00:34,480 --> 00:00:37,520
so we've got a number of good panels and

00:00:36,399 --> 00:00:39,280
talks today so

00:00:37,520 --> 00:00:41,280
try to stay on for the whole day but

00:00:39,280 --> 00:00:43,280
it's my pleasure to introduce to you

00:00:41,280 --> 00:00:47,440
three members of the mall nurse

00:00:43,280 --> 00:00:49,360
saran sharma atari and advaith madhakar

00:00:47,440 --> 00:00:51,120
and so i know personally surance for a

00:00:49,360 --> 00:00:52,000
number of years and he's been an active

00:00:51,120 --> 00:00:54,079
member of the finra

00:00:52,000 --> 00:00:55,680
community and really starting to bring

00:00:54,079 --> 00:00:57,840
some of the

00:00:55,680 --> 00:00:59,440
talented services and innovation he's

00:00:57,840 --> 00:01:01,039
built into the upstream code base in the

00:00:59,440 --> 00:01:03,520
near future so looking forward to that

00:01:01,039 --> 00:01:04,960
but today you know his team and himself

00:01:03,520 --> 00:01:07,040
they're going to focus on

00:01:04,960 --> 00:01:08,720
a topic around security that's come up

00:01:07,040 --> 00:01:10,240
fairly often out of hachicon

00:01:08,720 --> 00:01:12,159
and i think bitcoin's also been coming

00:01:10,240 --> 00:01:12,960
up fairly often so nicely tying the two

00:01:12,159 --> 00:01:14,799
together

00:01:12,960 --> 00:01:16,720
uh speaking about bit rupee and

00:01:14,799 --> 00:01:18,240
passwordless authentication

00:01:16,720 --> 00:01:20,080
so i'll let you all more properly

00:01:18,240 --> 00:01:21,600
introduce yourselves but looking forward

00:01:20,080 --> 00:01:27,840
to your talk today

00:01:21,600 --> 00:01:27,840
and let you guys take it away thank you

00:01:27,920 --> 00:01:33,439
thanks ed uh greetings everyone

00:01:31,119 --> 00:01:35,040
welcome to our talk courtesy of wellness

00:01:33,439 --> 00:01:37,520
foundation denmark

00:01:35,040 --> 00:01:38,960
and the apache software foundation uh

00:01:37,520 --> 00:01:40,960
our talk is titled

00:01:38,960 --> 00:01:44,640
bit rupee passwordless authentication

00:01:40,960 --> 00:01:47,920
using that kpb bitcoin protocol

00:01:44,640 --> 00:01:50,320
right about the speakers our first first

00:01:47,920 --> 00:01:52,560
presenter is mr saran sharma

00:01:50,320 --> 00:01:54,960
so ranch is a researcher at mueller's as

00:01:52,560 --> 00:01:56,000
well as its uh non-profit arm villas

00:01:54,960 --> 00:01:58,479
foundation

00:01:56,000 --> 00:01:59,920
uh he's a committer at apache in iraq

00:01:58,479 --> 00:02:02,079
and is involved with the fintech and

00:01:59,920 --> 00:02:04,079
bitcoin domain

00:02:02,079 --> 00:02:05,600
joins us right now from himachal pradesh

00:02:04,079 --> 00:02:08,959
india so

00:02:05,600 --> 00:02:10,879
he is living in a hilly region

00:02:08,959 --> 00:02:12,640
he might have some intermittent network

00:02:10,879 --> 00:02:15,680
issues so please uh don't mind

00:02:12,640 --> 00:02:17,440
regarding that i'm atharva dickney

00:02:15,680 --> 00:02:19,120
a research and development fellow at

00:02:17,440 --> 00:02:21,599
mueller's foundation

00:02:19,120 --> 00:02:22,319
i'm an open source enthusiast and i'm

00:02:21,599 --> 00:02:24,400
currently

00:02:22,319 --> 00:02:26,959
a committer and technical writer at

00:02:24,400 --> 00:02:29,040
wordpress.org as well

00:02:26,959 --> 00:02:30,480
i'm completing my final year of

00:02:29,040 --> 00:02:32,800
undergraduate studies in

00:02:30,480 --> 00:02:33,760
computer engineering at the university

00:02:32,800 --> 00:02:35,680
of pune

00:02:33,760 --> 00:02:37,760
and i also double a little bit in sound

00:02:35,680 --> 00:02:40,400
design and music technology

00:02:37,760 --> 00:02:41,920
finally we have advaith madhykar advaith

00:02:40,400 --> 00:02:42,879
is also a research fellow at mueller's

00:02:41,920 --> 00:02:44,879
foundation

00:02:42,879 --> 00:02:46,239
he is also completing his final year of

00:02:44,879 --> 00:02:48,239
undergraduate studies

00:02:46,239 --> 00:02:50,160
in mechanical engineering engineering at

00:02:48,239 --> 00:02:52,239
the university of pune

00:02:50,160 --> 00:02:54,080
both advaith and i are joining from

00:02:52,239 --> 00:02:57,360
india

00:02:54,080 --> 00:02:58,319
right so the synopsis i'll go go over

00:02:57,360 --> 00:03:01,440
the abstract

00:02:58,319 --> 00:03:03,360
briefly there are numerous

00:03:01,440 --> 00:03:04,000
vulnerabilities that are caused because

00:03:03,360 --> 00:03:06,800
of traditional

00:03:04,000 --> 00:03:08,000
password-based authentication uh

00:03:06,800 --> 00:03:10,640
passwords make use

00:03:08,000 --> 00:03:13,040
users vulnerable to phishing data theft

00:03:10,640 --> 00:03:16,239
attacks and much more

00:03:13,040 --> 00:03:18,159
so financial applications such as finrac

00:03:16,239 --> 00:03:19,280
rely on password-based authentication

00:03:18,159 --> 00:03:22,560
for uh secure

00:03:19,280 --> 00:03:25,200
transactions the existing approach

00:03:22,560 --> 00:03:27,519
relies on a plain text transfer of

00:03:25,200 --> 00:03:29,920
transactions over https

00:03:27,519 --> 00:03:30,799
so this could lead to potential security

00:03:29,920 --> 00:03:33,440
risk for

00:03:30,799 --> 00:03:35,200
all the parties concerned therefore

00:03:33,440 --> 00:03:35,920
there's a need to replace this world out

00:03:35,200 --> 00:03:38,959
protocol

00:03:35,920 --> 00:03:41,040
and make way for for something new

00:03:38,959 --> 00:03:46,560
you guys can have a look at the first

00:03:41,040 --> 00:03:49,840
part of the synopsis abstract rather

00:03:46,560 --> 00:03:50,480
okay so this called for developing a

00:03:49,840 --> 00:03:52,400
fast

00:03:50,480 --> 00:03:55,360
yet lightweight user authentication

00:03:52,400 --> 00:03:57,439
model using a bitcoin identity protocol

00:03:55,360 --> 00:04:00,000
and zero knowledge proof

00:03:57,439 --> 00:04:01,439
so bitropy is a secure passwordless

00:04:00,000 --> 00:04:03,680
authentication protocol

00:04:01,439 --> 00:04:05,680
that asks the client to sign each

00:04:03,680 --> 00:04:07,280
request using a private key

00:04:05,680 --> 00:04:08,720
and the server checks to make sure that

00:04:07,280 --> 00:04:11,680
the signature is valid

00:04:08,720 --> 00:04:13,120
and it matches the public key so we'll

00:04:11,680 --> 00:04:14,720
discuss about the current state of

00:04:13,120 --> 00:04:17,600
authentication protocols

00:04:14,720 --> 00:04:18,079
the technology stack and more you can

00:04:17,600 --> 00:04:20,239
have a

00:04:18,079 --> 00:04:22,799
look at the second part of that abstract

00:04:20,239 --> 00:04:22,799
for a bit

00:04:26,240 --> 00:04:30,560
all right let's go over the current

00:04:28,240 --> 00:04:32,720
state of authentication protocols

00:04:30,560 --> 00:04:34,160
so first of all character-based

00:04:32,720 --> 00:04:36,479
authentication protocols have

00:04:34,160 --> 00:04:38,240
increasingly become predictable and

00:04:36,479 --> 00:04:41,520
password passwords are only as

00:04:38,240 --> 00:04:43,280
strong as the user can think of moreover

00:04:41,520 --> 00:04:44,240
most people use the same password for

00:04:43,280 --> 00:04:47,520
various sites

00:04:44,240 --> 00:04:49,520
as as it becomes easier to remember uh

00:04:47,520 --> 00:04:51,360
offenders can use brute force

00:04:49,520 --> 00:04:53,040
injection attacks replay attacks and

00:04:51,360 --> 00:04:54,080
phishing to acquire the password

00:04:53,040 --> 00:04:57,120
nonetheless

00:04:54,080 --> 00:05:00,080
so even if it isn't their fault they can

00:04:57,120 --> 00:05:02,160
get their passwords uh users are prone

00:05:00,080 --> 00:05:04,479
to identity identity theft and

00:05:02,160 --> 00:05:06,000
impersonation even even if it isn't

00:05:04,479 --> 00:05:07,919
their fault

00:05:06,000 --> 00:05:09,120
all of this is very expensive

00:05:07,919 --> 00:05:11,280
maintaining the

00:05:09,120 --> 00:05:13,520
login credentials on the server and

00:05:11,280 --> 00:05:16,720
using encryption to secure it is

00:05:13,520 --> 00:05:18,400
immensely expensive so not all

00:05:16,720 --> 00:05:20,720
all the organizations prefer to

00:05:18,400 --> 00:05:23,120
implement it

00:05:20,720 --> 00:05:26,080
uh two factor authentication is not the

00:05:23,120 --> 00:05:28,400
best in terms of being robust

00:05:26,080 --> 00:05:30,080
attackers can use same swapping they can

00:05:28,400 --> 00:05:33,199
gain access to emails and

00:05:30,080 --> 00:05:36,160
whatnot so it isn't the best

00:05:33,199 --> 00:05:38,560
in terms of authentication as a extra

00:05:36,160 --> 00:05:40,720
layer it is good

00:05:38,560 --> 00:05:42,720
then the authenticity of the token

00:05:40,720 --> 00:05:43,520
provided by the service can be can't be

00:05:42,720 --> 00:05:46,240
proven by the

00:05:43,520 --> 00:05:49,280
client so there are existing security

00:05:46,240 --> 00:05:52,320
vulnerabilities in addition to that

00:05:49,280 --> 00:05:54,960
such as or2 having removed signatures

00:05:52,320 --> 00:05:56,000
and also in fenrik's case a simple plain

00:05:54,960 --> 00:05:59,759
text transfer

00:05:56,000 --> 00:06:02,160
and base64 encoding is used

00:05:59,759 --> 00:06:04,000
right so what are the advantages of

00:06:02,160 --> 00:06:05,600
passwordless authentication

00:06:04,000 --> 00:06:07,199
so first of all of course it is

00:06:05,600 --> 00:06:09,520
passwordless so

00:06:07,199 --> 00:06:11,199
the user logs in using the same look and

00:06:09,520 --> 00:06:14,720
feel as they're used to

00:06:11,199 --> 00:06:16,880
now so the attacks uh attacks are

00:06:14,720 --> 00:06:18,080
associated with middlemen are out of the

00:06:16,880 --> 00:06:20,960
question

00:06:18,080 --> 00:06:23,360
uh this type of authentication is is

00:06:20,960 --> 00:06:25,759
based on the bitcoin framework

00:06:23,360 --> 00:06:26,639
uh with the growing popularity of

00:06:25,759 --> 00:06:28,800
bitcoin

00:06:26,639 --> 00:06:31,759
there is an abundance of libraries

00:06:28,800 --> 00:06:35,280
written in multiple languages

00:06:31,759 --> 00:06:38,400
then cryptography is durable and secure

00:06:35,280 --> 00:06:39,919
no denying that then as the private key

00:06:38,400 --> 00:06:41,440
is never revealed to the server

00:06:39,919 --> 00:06:43,199
the exchange between the keys is not

00:06:41,440 --> 00:06:45,759
possible the

00:06:43,199 --> 00:06:47,199
authentication being decentralized uh

00:06:45,759 --> 00:06:50,160
the private keys

00:06:47,199 --> 00:06:52,400
not stored stored anywhere on the server

00:06:50,160 --> 00:06:56,400
and even if the server is compromised

00:06:52,400 --> 00:06:59,039
the user credentials remain safe

00:06:56,400 --> 00:07:01,199
okay so an offender cannot impersonate

00:06:59,039 --> 00:07:03,199
someone with a stolen identity

00:07:01,199 --> 00:07:04,479
since the server itself doesn't have the

00:07:03,199 --> 00:07:06,880
client info

00:07:04,479 --> 00:07:09,360
and this is actually essential for the

00:07:06,880 --> 00:07:12,479
privacy of the user

00:07:09,360 --> 00:07:13,440
next encrypted information can't be sent

00:07:12,479 --> 00:07:15,919
to a designated

00:07:13,440 --> 00:07:17,039
can be sent to a designated party rather

00:07:15,919 --> 00:07:20,240
using the existing

00:07:17,039 --> 00:07:21,919
public key uh for example a loan

00:07:20,240 --> 00:07:25,440
transaction can be shared with a

00:07:21,919 --> 00:07:27,120
credit uh agency right these are the

00:07:25,440 --> 00:07:30,720
advantages of passwordless

00:07:27,120 --> 00:07:32,560
authentication that we are hoping

00:07:30,720 --> 00:07:34,479
all of these would be incorporated in

00:07:32,560 --> 00:07:37,520
between

00:07:34,479 --> 00:07:38,560
now let's move on to the technology

00:07:37,520 --> 00:07:40,400
stack

00:07:38,560 --> 00:07:42,840
uh advaitha and saranch will discuss

00:07:40,400 --> 00:07:45,840
more about the technology stack for

00:07:42,840 --> 00:07:45,840
better

00:08:01,039 --> 00:08:04,479
hello everyone i am

00:08:04,960 --> 00:08:09,680
now i will be starting by introducing

00:08:06,400 --> 00:08:09,680
what is zero knowledge proof

00:08:10,160 --> 00:08:13,759
zero knowledge proof is a method by

00:08:11,919 --> 00:08:14,400
which one party can prove to another

00:08:13,759 --> 00:08:18,240
party

00:08:14,400 --> 00:08:20,160
that they know certain value x without

00:08:18,240 --> 00:08:22,240
without conveying any information apart

00:08:20,160 --> 00:08:23,120
from the fact that they know the value

00:08:22,240 --> 00:08:26,240
of x

00:08:23,120 --> 00:08:28,240
it uh allows use cases such as customer

00:08:26,240 --> 00:08:31,680
identification that is kyc

00:08:28,240 --> 00:08:33,760
data sharing across integrators service

00:08:31,680 --> 00:08:35,279
communication between apis loan

00:08:33,760 --> 00:08:38,399
transaction sharing

00:08:35,279 --> 00:08:41,839
now uh here is our approach with zkp

00:08:38,399 --> 00:08:41,839
can next slide please

00:08:42,479 --> 00:08:48,880
uh here uh the client manages uh

00:08:45,600 --> 00:08:51,040
all private keys uh and only the assign

00:08:48,880 --> 00:08:53,040
uh that is a system identification

00:08:51,040 --> 00:08:55,200
number is sent to the server side

00:08:53,040 --> 00:08:56,480
the pin direct end random challenges and

00:08:55,200 --> 00:08:59,040
security checks are done

00:08:56,480 --> 00:09:01,360
which happen at browser and client side

00:08:59,040 --> 00:09:03,040
the browser acts as a intermediary by

00:09:01,360 --> 00:09:04,640
managing the graphs and sends it to

00:09:03,040 --> 00:09:09,440
finrac

00:09:04,640 --> 00:09:11,920
can we have the next side please

00:09:09,440 --> 00:09:13,920
uh another protocol we would be using is

00:09:11,920 --> 00:09:16,080
the bitcoin identity protocol

00:09:13,920 --> 00:09:17,680
uh bitcoin works on generating private

00:09:16,080 --> 00:09:19,760
and public keys using assign

00:09:17,680 --> 00:09:22,080
that is system identification number

00:09:19,760 --> 00:09:24,160
this assign can be used by users to

00:09:22,080 --> 00:09:27,640
prove identity on the server side

00:09:24,160 --> 00:09:29,040
bitcoin currently uses ecc that is

00:09:27,640 --> 00:09:30,959
sccpk256

00:09:29,040 --> 00:09:33,440
it adds a data to the public key and the

00:09:30,959 --> 00:09:36,000
other parties can just sim

00:09:33,440 --> 00:09:37,279
can uh just simply verify the message

00:09:36,000 --> 00:09:38,959
both technology stacks

00:09:37,279 --> 00:09:40,720
are combined and are to be integrated

00:09:38,959 --> 00:09:42,080
with thinner act on the earth level for

00:09:40,720 --> 00:09:43,920
data encryption

00:09:42,080 --> 00:09:46,399
now i would like to request ranch to

00:09:43,920 --> 00:09:48,720
further expand on this and explain it

00:09:46,399 --> 00:09:51,839
its implementation in finland over to

00:09:48,720 --> 00:09:51,839
you savant

00:09:58,320 --> 00:10:01,360
hey thank you very much

00:10:01,519 --> 00:10:05,839
um so

00:10:08,480 --> 00:10:12,079
um so we could start with the idea that

00:10:11,440 --> 00:10:16,000
finrac

00:10:12,079 --> 00:10:16,000
uses i mean definitely the finra

00:10:16,839 --> 00:10:19,839
community

00:10:26,000 --> 00:10:33,839
you're having network issues

00:10:44,839 --> 00:10:47,839
uh

00:11:46,000 --> 00:11:52,000
which is for the for the delay he

00:11:49,200 --> 00:11:52,399
is living in a area the if you might

00:11:52,000 --> 00:11:57,839
know

00:11:52,399 --> 00:11:57,839
the imagine himalayas rather

00:11:59,360 --> 00:12:03,760
this intermittent network issues where

00:12:02,320 --> 00:12:11,839
he lives

00:12:03,760 --> 00:12:11,839
so just a sec daily joints

00:12:20,639 --> 00:12:26,240
hey guys can you hear me now

00:12:24,079 --> 00:12:26,240
go

00:12:27,120 --> 00:12:32,480
perfect it's okay so as i was mentioning

00:12:30,480 --> 00:12:33,120
the fact that finrax uses right now

00:12:32,480 --> 00:12:36,160
basic

00:12:33,120 --> 00:12:39,519
uh which is kind of like

00:12:36,160 --> 00:12:41,040
using a randomized time based uh base64

00:12:39,519 --> 00:12:42,720
encoding

00:12:41,040 --> 00:12:44,560
and if you're using an overwatch

00:12:42,720 --> 00:12:46,480
technology or oauth protocol

00:12:44,560 --> 00:12:48,240
or based authentication so then you are

00:12:46,480 --> 00:12:49,519
basically using the uid and

00:12:48,240 --> 00:12:51,839
the more of the passwords that's kind of

00:12:49,519 --> 00:12:53,440
like you know based on the

00:12:51,839 --> 00:12:55,120
different based of different encryption

00:12:53,440 --> 00:12:58,240
schemes

00:12:55,120 --> 00:13:00,160
um and if the password is you know like

00:12:58,240 --> 00:13:01,600
for instance the major problem here is

00:13:00,160 --> 00:13:03,040
the passwords are stolen then anybody

00:13:01,600 --> 00:13:03,680
can actually access your protected

00:13:03,040 --> 00:13:06,000
resources

00:13:03,680 --> 00:13:07,360
definitely the rest apis also at the

00:13:06,000 --> 00:13:10,639
same time

00:13:07,360 --> 00:13:12,399
and if the server hosting uh the

00:13:10,639 --> 00:13:13,120
database of interact is kind of like

00:13:12,399 --> 00:13:14,560
compromise

00:13:13,120 --> 00:13:16,560
then you have like a lot of issues going

00:13:14,560 --> 00:13:17,920
on this is kind of like a problems

00:13:16,560 --> 00:13:20,720
statement which where we started

00:13:17,920 --> 00:13:21,839
technically and the most important issue

00:13:20,720 --> 00:13:22,639
here is that a couple of these

00:13:21,839 --> 00:13:26,480
technologies

00:13:22,639 --> 00:13:28,639
do not have like for instance oauth

00:13:26,480 --> 00:13:30,320
itself lacks a very important feature of

00:13:28,639 --> 00:13:31,600
signature derivation

00:13:30,320 --> 00:13:33,519
which makes it vulnerable to different

00:13:31,600 --> 00:13:35,440
kind of attack vectors

00:13:33,519 --> 00:13:38,000
um the important segment here is that

00:13:35,440 --> 00:13:41,199
the password is transmitted over

00:13:38,000 --> 00:13:43,519
uh the plain text over https

00:13:41,199 --> 00:13:45,440
um so you essentially like you know the

00:13:43,519 --> 00:13:46,320
client is simply sending a plain text

00:13:45,440 --> 00:13:49,120
password so

00:13:46,320 --> 00:13:50,800
if somebody's into metal could simply

00:13:49,120 --> 00:13:52,240
just derive the password and use all

00:13:50,800 --> 00:13:54,240
those things

00:13:52,240 --> 00:13:56,320
um and it opens up opens and leaves the

00:13:54,240 --> 00:13:57,040
vulnerability so the same techniques are

00:13:56,320 --> 00:13:58,959
kind of like

00:13:57,040 --> 00:14:00,160
um can be implemented to encrypt that

00:13:58,959 --> 00:14:02,720
and you know sort of

00:14:00,160 --> 00:14:04,959
if we and if if this adversarial is

00:14:02,720 --> 00:14:06,959
attack is found in the future

00:14:04,959 --> 00:14:08,240
uh finra currently uses two factor

00:14:06,959 --> 00:14:10,639
authentication also which

00:14:08,240 --> 00:14:12,560
fails if the attacker gets the you know

00:14:10,639 --> 00:14:13,600
he gets the access to the email in case

00:14:12,560 --> 00:14:16,720
of social hacking

00:14:13,600 --> 00:14:18,639
you know so a bunch of problems which we

00:14:16,720 --> 00:14:20,399
are we're trying to solve

00:14:18,639 --> 00:14:21,519
uh uh the major problem here is that

00:14:20,399 --> 00:14:22,320
we're trying to solve is the data

00:14:21,519 --> 00:14:31,839
privacy

00:14:22,320 --> 00:14:31,839
uh which um which is which is a

00:15:10,639 --> 00:15:17,360
it's discussed are you guys uh

00:15:14,000 --> 00:15:18,800
is it okay so

00:15:17,360 --> 00:15:21,120
i could see some things going on with

00:15:18,800 --> 00:15:24,320
the screen so

00:15:21,120 --> 00:15:24,959
are you guys there you might you might

00:15:24,320 --> 00:15:28,240
uh

00:15:24,959 --> 00:15:32,399
turn off your video okay

00:15:28,240 --> 00:15:32,399
yeah my god

00:15:33,519 --> 00:15:40,880
okay is it possible is it good okay

00:15:37,199 --> 00:15:43,040
yeah so this is something which which

00:15:40,880 --> 00:15:44,959
gets created or which gets kind of like

00:15:43,040 --> 00:15:45,360
used as a framework on the client side

00:15:44,959 --> 00:15:47,120
so

00:15:45,360 --> 00:15:48,720
imagine a client side could simply just

00:15:47,120 --> 00:15:50,079
produce all these lines

00:15:48,720 --> 00:15:52,160
and could simply have to store all of

00:15:50,079 --> 00:15:54,000
these information in their own

00:15:52,160 --> 00:15:55,600
preferred way there is no hard code

00:15:54,000 --> 00:15:57,279
method there

00:15:55,600 --> 00:15:58,800
um so these primary functions are

00:15:57,279 --> 00:16:00,639
getting used or the methods are getting

00:15:58,800 --> 00:16:02,000
used on the client side so client side

00:16:00,639 --> 00:16:02,639
could be like you know user user

00:16:02,000 --> 00:16:06,079
interface

00:16:02,639 --> 00:16:09,519
or your you know your

00:16:06,079 --> 00:16:10,800
uh you know um your uh service

00:16:09,519 --> 00:16:14,160
which is kind of interacting with the

00:16:10,800 --> 00:16:19,120
rest apis um server side library

00:16:14,160 --> 00:16:19,120
uh you know are basically packaged

00:16:20,839 --> 00:16:23,839
bitcoin

00:16:28,959 --> 00:16:32,399
we're actually using base 58 encoding

00:16:30,800 --> 00:16:36,000
from bitcoin j not really the whole

00:16:32,399 --> 00:16:38,480
bitcoin need right now and uh tuany is

00:16:36,000 --> 00:16:41,680
recently incubated by apache donated by

00:16:38,480 --> 00:16:44,399
consensus one of the blockchain based

00:16:41,680 --> 00:16:46,320
system developers they recently donated

00:16:44,399 --> 00:16:47,839
it to apache apache incubated and it

00:16:46,320 --> 00:16:50,880
contained

00:16:47,839 --> 00:16:53,040
specific methods related to our

00:16:50,880 --> 00:16:53,920
you know implementation here in apache

00:16:53,040 --> 00:17:05,839
interact

00:16:53,920 --> 00:17:05,839
so on the apache interact in the server

00:17:17,520 --> 00:17:20,799
you know a couple of methods like

00:17:19,199 --> 00:17:22,720
receiving the response and extracting

00:17:20,799 --> 00:17:24,720
the information from those public keys

00:17:22,720 --> 00:17:28,720
as part of the essential

00:17:24,720 --> 00:17:33,840
um so moving on to the next part of the

00:17:28,720 --> 00:17:33,840
slide which

00:17:35,280 --> 00:17:39,039
the user flow so i would like to go

00:17:36,880 --> 00:17:42,559
through the user flow

00:17:39,039 --> 00:17:44,240
it's pretty straightforward we did not

00:17:42,559 --> 00:17:46,240
want to change the existing user flow

00:17:44,240 --> 00:17:48,240
that how the user is going to

00:17:46,240 --> 00:17:49,679
log in i mean we want to give them same

00:17:48,240 --> 00:17:52,480
look and feel

00:17:49,679 --> 00:17:53,760
and it does have existing look and feel

00:17:52,480 --> 00:17:55,840
uh

00:17:53,760 --> 00:17:58,640
right now we're trying it on our end

00:17:55,840 --> 00:18:00,160
just to by hitting the apis

00:17:58,640 --> 00:18:01,760
so essentially the user flow works in a

00:18:00,160 --> 00:18:04,960
very simple way so when a

00:18:01,760 --> 00:18:07,039
super user is automatically loaded

00:18:04,960 --> 00:18:08,640
on the first instance of the let's say

00:18:07,039 --> 00:18:10,320
you're filing up an instance of finrac

00:18:08,640 --> 00:18:12,320
so this is what our primary goal is an

00:18:10,320 --> 00:18:14,880
automatic syn will be generated it could

00:18:12,320 --> 00:18:16,400
you know get loaded into the database

00:18:14,880 --> 00:18:18,400
and these private and public keys would

00:18:16,400 --> 00:18:21,520
be sent out on the email to

00:18:18,400 --> 00:18:22,160
for the admin so once the admin gets the

00:18:21,520 --> 00:18:25,360
access

00:18:22,160 --> 00:18:27,760
and they have to manually provide the

00:18:25,360 --> 00:18:29,200
the identity keys and the signature so

00:18:27,760 --> 00:18:30,799
so that they could be able to access the

00:18:29,200 --> 00:18:33,200
protected resources

00:18:30,799 --> 00:18:35,440
and once that is done they could create

00:18:33,200 --> 00:18:37,919
and go they could go ahead and create

00:18:35,440 --> 00:18:38,480
users and those users could have those

00:18:37,919 --> 00:18:40,080
uh

00:18:38,480 --> 00:18:42,160
you know those private keys and public

00:18:40,080 --> 00:18:44,480
keys sent out on their email

00:18:42,160 --> 00:18:45,440
and the syn automatic generation happens

00:18:44,480 --> 00:18:47,120
from there so

00:18:45,440 --> 00:18:49,120
essentially the first user need to have

00:18:47,120 --> 00:18:51,679
this manual process

00:18:49,120 --> 00:18:53,280
so so you know when you go through this

00:18:51,679 --> 00:18:54,799
user flow you realize that it's pretty

00:18:53,280 --> 00:18:56,480
much similar and bunch of things are

00:18:54,799 --> 00:18:58,320
happening in the background

00:18:56,480 --> 00:18:59,840
so every user has to have this but

00:18:58,320 --> 00:19:00,799
eventually a user has to have this

00:18:59,840 --> 00:19:02,799
access

00:19:00,799 --> 00:19:04,240
uh in the near future we are we're kind

00:19:02,799 --> 00:19:07,360
of like figuring out ways

00:19:04,240 --> 00:19:09,440
like uh or say to say that in the

00:19:07,360 --> 00:19:10,960
near future people you know users could

00:19:09,440 --> 00:19:13,840
actually use their wallets or

00:19:10,960 --> 00:19:15,280
specific kind of you know like probably

00:19:13,840 --> 00:19:17,280
add on two-factor authentication which

00:19:15,280 --> 00:19:18,720
could just simply show up a barcode

00:19:17,280 --> 00:19:21,280
and when you scan that barcode it

00:19:18,720 --> 00:19:23,600
automatically does everything for you

00:19:21,280 --> 00:19:25,840
so if zkp is optional we don't really go

00:19:23,600 --> 00:19:27,200
into the zkp part but if that kp is not

00:19:25,840 --> 00:19:30,480
an optional component here

00:19:27,200 --> 00:19:32,240
so zkp essentially is zero knowledge

00:19:30,480 --> 00:19:33,280
proof based authentication happening so

00:19:32,240 --> 00:19:36,880
it's a second level

00:19:33,280 --> 00:19:38,880
or layer of security added to this

00:19:36,880 --> 00:19:40,960
specific component which we've kind of

00:19:38,880 --> 00:19:41,840
like derived when we set out of create

00:19:40,960 --> 00:19:45,360
creating this

00:19:41,840 --> 00:19:47,039
uh authentication protocol we realized

00:19:45,360 --> 00:19:48,960
that kp could actually

00:19:47,039 --> 00:19:50,960
unleash and create and pandora box which

00:19:48,960 --> 00:19:53,200
could open a bunch of new things which

00:19:50,960 --> 00:19:54,240
are not uh kind of like available

00:19:53,200 --> 00:19:56,480
directly in finra

00:19:54,240 --> 00:19:58,080
and could actually we could actually

00:19:56,480 --> 00:19:59,840
leverage both of these technology

00:19:58,080 --> 00:20:01,600
combined to create a sophisticated level

00:19:59,840 --> 00:20:03,520
of encryption within finra

00:20:01,600 --> 00:20:05,520
is protected resources and an

00:20:03,520 --> 00:20:08,559
interchange of data when happens

00:20:05,520 --> 00:20:10,720
so when adding zkp we we kind of like

00:20:08,559 --> 00:20:12,480
use this uh with the existing identity

00:20:10,720 --> 00:20:13,280
protocol or the identity signatures

00:20:12,480 --> 00:20:15,120
which we derive

00:20:13,280 --> 00:20:17,120
in the previous slides which i've

00:20:15,120 --> 00:20:18,720
mentioned and so when you sign this

00:20:17,120 --> 00:20:20,000
message say for an example you want to

00:20:18,720 --> 00:20:22,559
sign a message and then you say that

00:20:20,000 --> 00:20:24,400
hey i have a bunch of loan information

00:20:22,559 --> 00:20:26,159
and so wants to sort of like verify

00:20:24,400 --> 00:20:27,440
it on the server and so when it does the

00:20:26,159 --> 00:20:29,360
verification

00:20:27,440 --> 00:20:31,120
it base basically sends an interactive

00:20:29,360 --> 00:20:32,880
challenge to the to the prover

00:20:31,120 --> 00:20:34,720
and once it gets verified the user or

00:20:32,880 --> 00:20:37,600
the service gets access to this

00:20:34,720 --> 00:20:39,840
information and this all happens without

00:20:37,600 --> 00:20:41,919
revealing the true information

00:20:39,840 --> 00:20:43,520
you know so that's that's a breakthrough

00:20:41,919 --> 00:20:46,720
here which you're trying to

00:20:43,520 --> 00:20:49,919
uh create uh here for finra

00:20:46,720 --> 00:20:53,039
so it's kind of like an um you know

00:20:49,919 --> 00:20:54,559
encryption inbuilt with finrac uh

00:20:53,039 --> 00:20:56,960
happening for the first time so

00:20:54,559 --> 00:20:58,080
we we are trying out this implementation

00:20:56,960 --> 00:21:00,640
on on

00:20:58,080 --> 00:21:03,200
on a current basis we've yet not

00:21:00,640 --> 00:21:04,799
submitted the prs because we feel that

00:21:03,200 --> 00:21:06,320
we would like to go for a

00:21:04,799 --> 00:21:08,000
complete integration test because when

00:21:06,320 --> 00:21:09,360
you deal with such kind of sophisticated

00:21:08,000 --> 00:21:11,679
cryptographic stuff

00:21:09,360 --> 00:21:12,480
you need to you know set out and set up

00:21:11,679 --> 00:21:15,360
on

00:21:12,480 --> 00:21:16,640
uh different levels of testing not just

00:21:15,360 --> 00:21:17,280
integration testing because we're not

00:21:16,640 --> 00:21:19,600
dealing with

00:21:17,280 --> 00:21:20,799
um you know loan data or some simple

00:21:19,600 --> 00:21:24,159
stuff we're dealing with

00:21:20,799 --> 00:21:26,960
a couple of uh encryption on

00:21:24,159 --> 00:21:28,640
you know methods here and couple of

00:21:26,960 --> 00:21:31,200
protocol level stuff

00:21:28,640 --> 00:21:31,760
so there's a link you guys could go

00:21:31,200 --> 00:21:33,679
there

00:21:31,760 --> 00:21:35,440
so uh moving on to the technical notes

00:21:33,679 --> 00:21:38,400
um thank you

00:21:35,440 --> 00:21:40,240
for uh taking care of all of this um

00:21:38,400 --> 00:21:42,400
server-side implementation

00:21:40,240 --> 00:21:44,000
is essential for verifying sin by sort

00:21:42,400 --> 00:21:47,840
of like deriving it from public key so

00:21:44,000 --> 00:21:49,840
this allows us to you know encompass

00:21:47,840 --> 00:21:50,960
different dimensions of storage of data

00:21:49,840 --> 00:21:52,799
into you know

00:21:50,960 --> 00:21:54,559
when you send out information from

00:21:52,799 --> 00:21:55,840
client side to the use to the server

00:21:54,559 --> 00:21:57,919
side

00:21:55,840 --> 00:21:59,120
maintaining a user association this is

00:21:57,919 --> 00:22:02,240
something which

00:21:59,120 --> 00:22:04,720
uh which we have to yet finish

00:22:02,240 --> 00:22:06,720
and work on like for instance there is

00:22:04,720 --> 00:22:08,880
no concept of password

00:22:06,720 --> 00:22:11,039
uh remains here in this on the server

00:22:08,880 --> 00:22:12,000
side so your user association with like

00:22:11,039 --> 00:22:14,159
a user

00:22:12,000 --> 00:22:15,679
could could or should be able to manage

00:22:14,159 --> 00:22:17,360
multiple public keys

00:22:15,679 --> 00:22:18,960
a multiple synths and could be like you

00:22:17,360 --> 00:22:20,480
know their hardware their devices like

00:22:18,960 --> 00:22:22,320
for instance i want to access it from my

00:22:20,480 --> 00:22:23,360
ipad i want to accept my mobile phone so

00:22:22,320 --> 00:22:25,360
i could do that

00:22:23,360 --> 00:22:27,200
and that requires us to prove ourselves

00:22:25,360 --> 00:22:29,600
and that in that basis we have to

00:22:27,200 --> 00:22:29,600
generate

00:22:35,440 --> 00:22:39,840
started out developing this feature like

00:22:37,200 --> 00:22:40,640
for instance implementing a two filter

00:22:39,840 --> 00:22:42,720
which sort of like

00:22:40,640 --> 00:22:44,640
maintains and check validations across

00:22:42,720 --> 00:22:45,919
figures for the verification of the sin

00:22:44,640 --> 00:22:46,960
which happens with the signatures that

00:22:45,919 --> 00:22:48,880
happen

00:22:46,960 --> 00:22:50,080
um client is going to store all of this

00:22:48,880 --> 00:22:52,880
information you know

00:22:50,080 --> 00:22:54,320
a bunch of stuffs which we've mentioned

00:22:52,880 --> 00:22:56,240
um

00:22:54,320 --> 00:22:58,159
one important stuff here that we could

00:22:56,240 --> 00:23:01,679
actually use decentralized blockchain

00:22:58,159 --> 00:23:03,520
is an option if some parties or some uh

00:23:01,679 --> 00:23:04,720
partners would like to integrate and

00:23:03,520 --> 00:23:05,120
when they see that they would want to

00:23:04,720 --> 00:23:06,400
use

00:23:05,120 --> 00:23:10,159
rather than storing all of this

00:23:06,400 --> 00:23:10,159
information onto the server they could

00:23:13,520 --> 00:23:16,640
more decent

00:23:20,559 --> 00:23:25,679
morphic graphs which reduces the

00:23:22,159 --> 00:23:25,679
complications of the

00:23:30,880 --> 00:23:37,760
computation we

00:23:36,000 --> 00:23:39,360
we're going to implement all of this and

00:23:37,760 --> 00:23:40,559
how we have actually implemented all of

00:23:39,360 --> 00:23:44,720
this

00:23:40,559 --> 00:23:44,720
um moving on to the next slide

00:23:48,640 --> 00:23:52,880
so there are a couple of drawbacks uh

00:23:50,480 --> 00:23:52,880
for this

00:23:58,400 --> 00:24:01,360
which you wanted to distribute which you

00:24:00,000 --> 00:24:02,480
wanted to spread out in the community

00:24:01,360 --> 00:24:03,919
also because

00:24:02,480 --> 00:24:06,080
more the people have information we

00:24:03,919 --> 00:24:07,279
could find couple of solutions also

00:24:06,080 --> 00:24:08,559
like for instance we have this

00:24:07,279 --> 00:24:10,080
computational complexity we're not

00:24:08,559 --> 00:24:11,600
really running away from this

00:24:10,080 --> 00:24:13,440
we have this because on the server side

00:24:11,600 --> 00:24:15,760
encryption is a big task

00:24:13,440 --> 00:24:17,279
you know like deriving information from

00:24:15,760 --> 00:24:18,159
public key deriving information or

00:24:17,279 --> 00:24:20,559
deriving data

00:24:18,159 --> 00:24:21,760
out of it you know um client and

00:24:20,559 --> 00:24:26,720
processing is also

00:24:21,760 --> 00:24:26,720
good because

00:24:28,960 --> 00:24:35,440
to support such kind of client

00:24:33,200 --> 00:24:36,799
but the other open source broad projects

00:24:35,440 --> 00:24:38,240
are kind of like taking care of but we

00:24:36,799 --> 00:24:41,760
have to be aware of these

00:24:38,240 --> 00:24:43,600
uh drawbacks when we use this

00:24:41,760 --> 00:24:45,039
definitely there's not this only secure

00:24:43,600 --> 00:24:46,799
method but this is the best secure

00:24:45,039 --> 00:24:47,200
method which we could kind of like test

00:24:46,799 --> 00:24:51,840
out

00:24:47,200 --> 00:24:51,840
and set up on in the for the future

00:24:56,000 --> 00:25:00,640
yeah thank you sir so future

00:24:59,039 --> 00:25:00,960
improvements and functionalities which

00:25:00,640 --> 00:25:02,880
we

00:25:00,960 --> 00:25:04,080
see that could be used right now in the

00:25:02,880 --> 00:25:05,919
future

00:25:04,080 --> 00:25:07,360
so authentication is taken care with

00:25:05,919 --> 00:25:09,600
this protocol

00:25:07,360 --> 00:25:10,480
said and i mean this is done we've

00:25:09,600 --> 00:25:13,760
implemented

00:25:10,480 --> 00:25:16,400
almost the functionality um

00:25:13,760 --> 00:25:17,120
data encryption with this func feature

00:25:16,400 --> 00:25:20,559
we could actually

00:25:17,120 --> 00:25:22,080
use uh so for an example uh finrac has

00:25:20,559 --> 00:25:24,559
this user interface

00:25:22,080 --> 00:25:25,919
which could simply right now is sending

00:25:24,559 --> 00:25:28,400
a plain text

00:25:25,919 --> 00:25:29,760
uh you know based uh information so it

00:25:28,400 --> 00:25:31,520
could actually send some sensitive

00:25:29,760 --> 00:25:33,919
information in

00:25:31,520 --> 00:25:34,640
an encrypted way because essentially you

00:25:33,919 --> 00:25:36,559
could

00:25:34,640 --> 00:25:38,320
package everything into a small

00:25:36,559 --> 00:25:39,360
hexadecimal string which could get

00:25:38,320 --> 00:25:42,240
derived out there

00:25:39,360 --> 00:25:43,279
into the server side and nobody would

00:25:42,240 --> 00:25:45,360
get to know even

00:25:43,279 --> 00:25:46,480
on on the on the level of zkp for an

00:25:45,360 --> 00:25:48,640
instant you could actually send some

00:25:46,480 --> 00:25:51,360
information secret information where

00:25:48,640 --> 00:25:52,400
the even the the verifier wouldn't even

00:25:51,360 --> 00:25:54,559
get to know

00:25:52,400 --> 00:25:56,320
so such level of encryption could be

00:25:54,559 --> 00:25:57,120
utilized with the existing technology

00:25:56,320 --> 00:25:59,840
which we are

00:25:57,120 --> 00:26:00,799
implementing um identity and reputation

00:25:59,840 --> 00:26:02,240
system is

00:26:00,799 --> 00:26:04,080
something which we are looking forward

00:26:02,240 --> 00:26:06,080
for with using this technology because

00:26:04,080 --> 00:26:08,320
this technology simply allows kyc people

00:26:06,080 --> 00:26:10,000
to have kyc done on the client and

00:26:08,320 --> 00:26:11,600
without actually revealing such

00:26:10,000 --> 00:26:14,000
sensitive information

00:26:11,600 --> 00:26:14,880
um we would like to see if community

00:26:14,000 --> 00:26:15,840
would like to

00:26:14,880 --> 00:26:18,480
integrate different kind of

00:26:15,840 --> 00:26:21,840
cryptographic schemes to it the bunch of

00:26:18,480 --> 00:26:25,200
cryptographic schemes out there um

00:26:21,840 --> 00:26:27,200
you know uh accessing data yeah so

00:26:25,200 --> 00:26:28,559
such such kind of functionalities could

00:26:27,200 --> 00:26:31,360
be implemented

00:26:28,559 --> 00:26:31,760
um and the most important functionality

00:26:31,360 --> 00:26:33,200
which

00:26:31,760 --> 00:26:34,880
i would like to personally see is

00:26:33,200 --> 00:26:36,640
encryption of data happening on the

00:26:34,880 --> 00:26:38,960
on the rest apis without actually

00:26:36,640 --> 00:26:40,400
revealing any information

00:26:38,960 --> 00:26:42,400
so think about like you know credit

00:26:40,400 --> 00:26:53,840
bureau asking for your

00:26:42,400 --> 00:26:53,840
you know

00:26:54,000 --> 00:27:07,840
simply them to use

00:27:12,000 --> 00:27:21,840
encryption method um

00:27:15,520 --> 00:27:21,840
so moving on to the next

00:27:46,840 --> 00:27:49,840
okay

00:27:50,080 --> 00:27:52,159

YouTube URL: https://www.youtube.com/watch?v=cwofy0GYOak


