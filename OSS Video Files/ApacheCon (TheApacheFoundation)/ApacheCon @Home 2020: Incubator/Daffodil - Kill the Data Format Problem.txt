Title: Daffodil - Kill the Data Format Problem
Publication date: 2020-10-16
Playlist: ApacheCon @Home 2020: Incubator
Description: 
	Daffodil - Kill the Data Format Problem
Michael Beckerle

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Daffodil is an incubator project. Its goal is killing the data format problem by providing an implementation of DFDL (Data Format Description Language - an emerging standard from the Open Grid Forum) that we can all use and extend, and integrate into all our data-consuming frameworks and applications. This talk will use numerous compelling examples of Daffodil parsing, and unparsing (reconstructing) data in a variety of data formats - textual and binary, industry standard formats, and ad-hoc one-of-a-kind formats as well, and using both XML and JSON to make the data tangible and visible.

Apache commiter since 2017. Currently applying knowledge of scalable computing systems and data format issues at Owl Cyber Defense Solutions (formerly Tresys Technology). Since 2002, Co-chair DFDL Workgroup of Open Grid Forum - working towards a standard for data format description so we can all stop solving this problem over and over again. Former life as a CTO of a few small/startup companies. Likes to program in Scala and to do data archeology to figure out data from just the bits.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:25,199 --> 00:00:28,880
okay it's

00:00:26,160 --> 00:00:31,119
1 35 pm and i think it's time to start

00:00:28,880 --> 00:00:33,440
the session i hope you can

00:00:31,119 --> 00:00:35,920
hear me clearly when i tested this

00:00:33,440 --> 00:00:39,760
earlier it seemed to work quite well

00:00:35,920 --> 00:00:40,559
um uh what i'm here to tell you about

00:00:39,760 --> 00:00:42,320
today

00:00:40,559 --> 00:00:45,039
if you get my control panel up here in

00:00:42,320 --> 00:00:47,520
front of me um

00:00:45,039 --> 00:00:48,960
is my talk is titled kill the data

00:00:47,520 --> 00:00:51,360
format problem

00:00:48,960 --> 00:00:52,480
uh using apache daffodil which is an

00:00:51,360 --> 00:00:54,960
incubator project

00:00:52,480 --> 00:00:58,399
that i think is very exciting and we're

00:00:54,960 --> 00:01:01,840
i'm i'm going to tell you more about

00:00:58,399 --> 00:01:03,440
my uh you can see my my uh company name

00:01:01,840 --> 00:01:05,280
some of you know me from working for a

00:01:03,440 --> 00:01:07,520
company named traces

00:01:05,280 --> 00:01:09,119
in the past but uh tracy's has been

00:01:07,520 --> 00:01:12,000
rebranded owl

00:01:09,119 --> 00:01:13,600
hence the two uh affectionately known as

00:01:12,000 --> 00:01:16,799
the nerd birds

00:01:13,600 --> 00:01:16,799
owls on my slide

00:01:17,360 --> 00:01:23,040
thank you for listening today

00:01:20,400 --> 00:01:25,119
so what is daffodil about what do i mean

00:01:23,040 --> 00:01:28,640
by kill the data format problem

00:01:25,119 --> 00:01:30,880
well the data format problem is this

00:01:28,640 --> 00:01:31,680
imagine you've got edifact data that

00:01:30,880 --> 00:01:34,880
effect is a

00:01:31,680 --> 00:01:37,680
a very common data standard it's used in

00:01:34,880 --> 00:01:38,960
um electronic data interchange think you

00:01:37,680 --> 00:01:42,000
know supply chain

00:01:38,960 --> 00:01:42,560
things of that sort it's a big standard

00:01:42,000 --> 00:01:44,720
there's

00:01:42,560 --> 00:01:47,040
lots of complexity to this and it also

00:01:44,720 --> 00:01:50,000
gets customized in various ways

00:01:47,040 --> 00:01:51,600
by the people who use it so it's it's

00:01:50,000 --> 00:01:52,479
not one of these things where you can

00:01:51,600 --> 00:01:54,640
just

00:01:52,479 --> 00:01:57,200
get an edifact software package it

00:01:54,640 --> 00:02:00,240
actually will require some tweaking

00:01:57,200 --> 00:02:01,759
um so ediffect is a good example of a

00:02:00,240 --> 00:02:03,520
data format that you may

00:02:01,759 --> 00:02:05,680
find that you ultimately have to deal

00:02:03,520 --> 00:02:05,680
with

00:02:05,759 --> 00:02:09,920
another common thing people run into is

00:02:07,759 --> 00:02:11,200
some data formats that have been very

00:02:09,920 --> 00:02:14,080
carefully packed

00:02:11,200 --> 00:02:15,280
to use every bit so all the little bit

00:02:14,080 --> 00:02:18,000
flags

00:02:15,280 --> 00:02:19,680
are uh are individually identified and

00:02:18,000 --> 00:02:20,879
they're packed into the bytes very

00:02:19,680 --> 00:02:24,640
densely

00:02:20,879 --> 00:02:25,840
this is um uh in many cases these

00:02:24,640 --> 00:02:27,760
formats are old

00:02:25,840 --> 00:02:28,959
and they date from when bandwidth was

00:02:27,760 --> 00:02:32,160
not so

00:02:28,959 --> 00:02:34,239
available as it is nowadays

00:02:32,160 --> 00:02:36,480
but these are kind of things also come

00:02:34,239 --> 00:02:38,879
up in the big data situations

00:02:36,480 --> 00:02:40,400
one of my favorite quotes from the big

00:02:38,879 --> 00:02:42,480
data world was

00:02:40,400 --> 00:02:43,440
uh comes from a data warehousing project

00:02:42,480 --> 00:02:45,120
where the

00:02:43,440 --> 00:02:47,440
manager of the project told me if you

00:02:45,120 --> 00:02:49,680
make that record one byte bigger i have

00:02:47,440 --> 00:02:52,720
to buy 22 disk drives

00:02:49,680 --> 00:02:53,360
so in many cases it's important to pack

00:02:52,720 --> 00:02:55,760
the data

00:02:53,360 --> 00:02:57,440
so you can end up with these kinds of

00:02:55,760 --> 00:03:00,800
densely packed things that you need to

00:02:57,440 --> 00:03:04,000
take apart in order to manipulate

00:03:00,800 --> 00:03:06,400
nacho is another important data

00:03:04,000 --> 00:03:07,680
format nacho data is for credit card

00:03:06,400 --> 00:03:10,959
transactions

00:03:07,680 --> 00:03:13,920
uh and it looks textual here

00:03:10,959 --> 00:03:15,680
but uh this is there's it's not textual

00:03:13,920 --> 00:03:17,280
in the typical sense there's no line

00:03:15,680 --> 00:03:20,800
endings in this data

00:03:17,280 --> 00:03:22,959
for example so it's one giant long line

00:03:20,800 --> 00:03:24,959
it just happens that all the data values

00:03:22,959 --> 00:03:28,239
in it are textual

00:03:24,959 --> 00:03:30,640
um so pulling uh notcha data apart

00:03:28,239 --> 00:03:33,120
it's another typical problem that is

00:03:30,640 --> 00:03:36,560
easy to easily solve with daffodil

00:03:33,120 --> 00:03:39,360
um here's another one iso 8583

00:03:36,560 --> 00:03:39,920
this is another credit card related data

00:03:39,360 --> 00:03:42,560
standard

00:03:39,920 --> 00:03:44,080
but this one's binary data even though

00:03:42,560 --> 00:03:46,560
most of it looks like

00:03:44,080 --> 00:03:47,840
text on your screen right here there are

00:03:46,560 --> 00:03:50,879
some pieces in here that

00:03:47,840 --> 00:03:51,840
actually uh there are characters uh in

00:03:50,879 --> 00:03:54,720
here that really

00:03:51,840 --> 00:03:56,879
uh aren't normal printing characters in

00:03:54,720 --> 00:03:59,200
this data they're actually binary fields

00:03:56,879 --> 00:04:02,080
there's bit flags in here

00:03:59,200 --> 00:04:03,840
all kinds of things so iso e5 a3 is

00:04:02,080 --> 00:04:06,159
another credit card transaction

00:04:03,840 --> 00:04:07,040
data type very popular very commonly

00:04:06,159 --> 00:04:10,080
used

00:04:07,040 --> 00:04:11,120
and uh and hard to deal with without

00:04:10,080 --> 00:04:13,439
some way

00:04:11,120 --> 00:04:14,720
of describing this format to your

00:04:13,439 --> 00:04:17,919
software

00:04:14,720 --> 00:04:19,919
so that's what daffodil is about solving

00:04:17,919 --> 00:04:21,840
these kinds of data situations you've

00:04:19,919 --> 00:04:24,080
got this kind of data you need to read

00:04:21,840 --> 00:04:25,440
it you need to write it

00:04:24,080 --> 00:04:28,320
because you have to integrate with

00:04:25,440 --> 00:04:32,800
systems that use this kind of data

00:04:28,320 --> 00:04:36,800
they consume it they produce it um

00:04:32,800 --> 00:04:39,440
so daffodil uh is named daffodil

00:04:36,800 --> 00:04:40,320
uh spelled out like the flower daffodils

00:04:39,440 --> 00:04:42,880
uh but

00:04:40,320 --> 00:04:45,040
it's it's really play on the the the

00:04:42,880 --> 00:04:46,639
name of the language it implements which

00:04:45,040 --> 00:04:47,360
is called data format description

00:04:46,639 --> 00:04:50,000
language

00:04:47,360 --> 00:04:52,400
or dfdl and we just decided you can

00:04:50,000 --> 00:04:55,360
pronounce dfdl daffodil

00:04:52,400 --> 00:04:56,880
um but there is a distinction there is

00:04:55,360 --> 00:04:59,840
apache daffodil

00:04:56,880 --> 00:05:01,039
the incubating software package and

00:04:59,840 --> 00:05:04,880
there's dfdl

00:05:01,039 --> 00:05:07,280
the language and so a couple important

00:05:04,880 --> 00:05:09,600
things about dfdl dfdl is

00:05:07,280 --> 00:05:11,440
a way of describing data formats it's

00:05:09,600 --> 00:05:14,560
not a data format

00:05:11,440 --> 00:05:16,880
right so uh there's lots of of

00:05:14,560 --> 00:05:18,240
uh useful data formats out there in the

00:05:16,880 --> 00:05:20,240
world and apache

00:05:18,240 --> 00:05:22,400
has a bunch of them avro is one of the

00:05:20,240 --> 00:05:24,560
ones i hear about a lot

00:05:22,400 --> 00:05:26,800
those are those are data formats they're

00:05:24,560 --> 00:05:29,919
not ways of describing data formats

00:05:26,800 --> 00:05:32,240
dfdl serves a different role you don't

00:05:29,919 --> 00:05:34,160
it's for projects and situations where

00:05:32,240 --> 00:05:36,240
you don't get to choose the data format

00:05:34,160 --> 00:05:36,880
the data formats already been chosen for

00:05:36,240 --> 00:05:38,800
you

00:05:36,880 --> 00:05:40,639
now you have to describe it to your

00:05:38,800 --> 00:05:43,759
software

00:05:40,639 --> 00:05:44,880
now dfdl the language is actually an

00:05:43,759 --> 00:05:47,120
open standard

00:05:44,880 --> 00:05:49,360
that's emerging from a little-known

00:05:47,120 --> 00:05:51,120
group called the open grid forum

00:05:49,360 --> 00:05:53,039
uh it's been been worked on for quite a

00:05:51,120 --> 00:05:56,160
few years i actually started working on

00:05:53,039 --> 00:05:57,840
dfdl in the early 2000s

00:05:56,160 --> 00:05:59,600
and i uh co-chaired the standards

00:05:57,840 --> 00:06:00,960
committee on dfdl

00:05:59,600 --> 00:06:02,960
we're hoping that the final

00:06:00,960 --> 00:06:04,800
specification of this

00:06:02,960 --> 00:06:06,720
will come out in the first half of next

00:06:04,800 --> 00:06:08,800
year

00:06:06,720 --> 00:06:09,840
there's draft specifications available

00:06:08,800 --> 00:06:12,880
right now

00:06:09,840 --> 00:06:13,759
there uh despite the apache uh daffodil

00:06:12,880 --> 00:06:16,880
incubator

00:06:13,759 --> 00:06:17,759
implementation of of dfl there are two

00:06:16,880 --> 00:06:20,479
other

00:06:17,759 --> 00:06:21,600
implementations out there ibm actually

00:06:20,479 --> 00:06:24,720
ibm has several

00:06:21,600 --> 00:06:26,400
of its own implementations of dfdl uh

00:06:24,720 --> 00:06:28,319
including ones that run on mainframes

00:06:26,400 --> 00:06:29,199
one that run on general computing

00:06:28,319 --> 00:06:31,520
systems

00:06:29,199 --> 00:06:32,639
one's written in java one's written in c

00:06:31,520 --> 00:06:34,960
um

00:06:32,639 --> 00:06:36,639
there's also an interesting dfdl

00:06:34,960 --> 00:06:37,680
implementation from the european space

00:06:36,639 --> 00:06:40,000
agency that was

00:06:37,680 --> 00:06:42,639
uh specifically set up for dealing with

00:06:40,000 --> 00:06:44,319
the binary data feeds from satellites

00:06:42,639 --> 00:06:46,080
so uh it's quite interesting that

00:06:44,319 --> 00:06:47,600
there's these other implementations out

00:06:46,080 --> 00:06:51,520
there as well

00:06:47,600 --> 00:06:55,039
um now so what um

00:06:51,520 --> 00:06:57,919
uh standards essentially emerged

00:06:55,039 --> 00:06:58,960
as a standardization effort trying to

00:06:57,919 --> 00:07:01,199
take a union

00:06:58,960 --> 00:07:02,639
of all the capabilities across a whole

00:07:01,199 --> 00:07:04,400
bunch of

00:07:02,639 --> 00:07:06,000
the integration products and tools that

00:07:04,400 --> 00:07:08,960
were in the marketplace

00:07:06,000 --> 00:07:10,080
uh in the in the 90s and in the early

00:07:08,960 --> 00:07:13,280
2000s

00:07:10,080 --> 00:07:17,199
um and we needed

00:07:13,280 --> 00:07:20,479
a standard for this stuff in order to

00:07:17,199 --> 00:07:23,840
get adequate adoption of

00:07:20,479 --> 00:07:25,280
of the standard instead of every data

00:07:23,840 --> 00:07:27,199
tool in the world having

00:07:25,280 --> 00:07:29,120
its own little data description

00:07:27,199 --> 00:07:31,039
technique because every

00:07:29,120 --> 00:07:32,720
everything that needs to bring in data

00:07:31,039 --> 00:07:33,919
ends up growing a little bit of a

00:07:32,720 --> 00:07:36,240
daffodil

00:07:33,919 --> 00:07:38,880
like thing in order to describe certain

00:07:36,240 --> 00:07:42,080
kinds of data but they're usually not

00:07:38,880 --> 00:07:45,360
complete enough and powerful

00:07:42,080 --> 00:07:47,199
enough and dfdl is quite powerful

00:07:45,360 --> 00:07:49,919
quite capable and really represents the

00:07:47,199 --> 00:07:51,759
union of what you see across

00:07:49,919 --> 00:07:53,520
marketplace of data integration products

00:07:51,759 --> 00:07:57,120
to tools for

00:07:53,520 --> 00:08:00,080
intake and export of data

00:07:57,120 --> 00:08:00,560
so using daffodil you recall that some

00:08:00,080 --> 00:08:02,000
of that

00:08:00,560 --> 00:08:04,720
data i showed you in the first few

00:08:02,000 --> 00:08:05,599
slides you can uh have your notcha data

00:08:04,720 --> 00:08:08,160
as json

00:08:05,599 --> 00:08:08,960
so here it is it's json this is the same

00:08:08,160 --> 00:08:12,160
piece of data

00:08:08,960 --> 00:08:15,280
of course doesn't fit on one slide

00:08:12,160 --> 00:08:17,919
but json is of course an extremely

00:08:15,280 --> 00:08:20,000
popular standard right now

00:08:17,919 --> 00:08:21,520
but of course you might want it as xml

00:08:20,000 --> 00:08:25,360
same data notcha data

00:08:21,520 --> 00:08:27,680
but now i've i've converted it into xml

00:08:25,360 --> 00:08:28,960
so daffodil will bi-directionally

00:08:27,680 --> 00:08:32,000
convert data

00:08:28,960 --> 00:08:35,360
from uh native formats

00:08:32,000 --> 00:08:36,880
to and from json xml and other things as

00:08:35,360 --> 00:08:40,159
i'll show you

00:08:36,880 --> 00:08:43,680
um so to give you um

00:08:40,159 --> 00:08:45,120
an idea how this works i'm gonna in just

00:08:43,680 --> 00:08:48,640
four slides

00:08:45,120 --> 00:08:49,519
create a tiny little dfdl schema a dfdl

00:08:48,640 --> 00:08:52,640
schema

00:08:49,519 --> 00:08:53,519
is the uh the thing that is a format

00:08:52,640 --> 00:08:56,880
description

00:08:53,519 --> 00:08:58,800
we call it a schema and

00:08:56,880 --> 00:09:01,519
i'll show you a teeny little example

00:08:58,800 --> 00:09:03,839
here so here's some delimited text data

00:09:01,519 --> 00:09:04,959
okay this is a completely made up

00:09:03,839 --> 00:09:06,959
example but

00:09:04,959 --> 00:09:09,120
it's got a couple of numbers in it and

00:09:06,959 --> 00:09:12,160
it's got these tag like things

00:09:09,120 --> 00:09:16,240
uh our limit and rp and gx

00:09:12,160 --> 00:09:19,600
telling us what these data fields are

00:09:16,240 --> 00:09:23,440
so um the first thing

00:09:19,600 --> 00:09:25,120
is the um you can see there's a couple

00:09:23,440 --> 00:09:27,200
of it there's a couple numbers in here

00:09:25,120 --> 00:09:29,040
one's an integer one's a floating point

00:09:27,200 --> 00:09:32,160
number uh and then there's

00:09:29,040 --> 00:09:33,040
the other stuff around it uh in dfdl

00:09:32,160 --> 00:09:34,839
language

00:09:33,040 --> 00:09:36,240
these tag-like structures are called

00:09:34,839 --> 00:09:38,399
initiators

00:09:36,240 --> 00:09:40,080
uh there's a separator separating the

00:09:38,399 --> 00:09:42,480
two uh numeric

00:09:40,080 --> 00:09:43,440
fields here which is this semicolon in

00:09:42,480 --> 00:09:45,519
the middle

00:09:43,440 --> 00:09:47,519
uh and then there's the second field of

00:09:45,519 --> 00:09:48,560
course also has its initiator so those

00:09:47,519 --> 00:09:50,480
are the characteristics of this

00:09:48,560 --> 00:09:53,839
particular data format

00:09:50,480 --> 00:09:56,160
now the red part that i've shown here is

00:09:53,839 --> 00:09:56,959
uh in daffodil speak is what we call

00:09:56,160 --> 00:09:59,680
framing

00:09:56,959 --> 00:10:02,560
and the black is what we call content

00:09:59,680 --> 00:10:05,440
these separators and initiators

00:10:02,560 --> 00:10:06,560
are delimiters which are part of the

00:10:05,440 --> 00:10:08,000
framing

00:10:06,560 --> 00:10:11,600
these are just some of the terms that

00:10:08,000 --> 00:10:14,720
you find in in daffodil

00:10:11,600 --> 00:10:18,079
so dfdl schemas use

00:10:14,720 --> 00:10:21,680
xml schema you basically use xml schema

00:10:18,079 --> 00:10:24,880
as a grammar scaffolding so

00:10:21,680 --> 00:10:28,240
our our little uh piece of data had two

00:10:24,880 --> 00:10:31,279
elements in it which i've created

00:10:28,240 --> 00:10:32,480
a complex type here i've decided since

00:10:31,279 --> 00:10:35,440
their names began with

00:10:32,480 --> 00:10:37,519
r to call them the r values so this

00:10:35,440 --> 00:10:39,519
little pair of data looks like this in

00:10:37,519 --> 00:10:42,160
xml schema

00:10:39,519 --> 00:10:44,079
right now this is xml schema it's not a

00:10:42,160 --> 00:10:46,079
dfdl schema yet

00:10:44,079 --> 00:10:48,160
it's just describing the logical

00:10:46,079 --> 00:10:51,279
elements there are limit element

00:10:48,160 --> 00:10:52,399
uh is an integer that rpngx whatever

00:10:51,279 --> 00:10:55,600
that stands for

00:10:52,399 --> 00:10:57,360
is a floating point number um so to make

00:10:55,600 --> 00:11:00,800
this into a dfdl schema

00:10:57,360 --> 00:11:03,920
we add these annotations to that schema

00:11:00,800 --> 00:11:07,600
the at the top here we have a block of

00:11:03,920 --> 00:11:10,079
format annotation that uh covers things

00:11:07,600 --> 00:11:11,920
that apply to the entire schema

00:11:10,079 --> 00:11:13,440
which often is much bigger than a little

00:11:11,920 --> 00:11:16,640
definition like this

00:11:13,440 --> 00:11:19,360
but uh so this is representation

00:11:16,640 --> 00:11:21,360
textual data as opposed to binary data

00:11:19,360 --> 00:11:22,880
uh it has standard text numbers which

00:11:21,360 --> 00:11:25,360
means the numbers are made up of

00:11:22,880 --> 00:11:28,079
the usual digits it's encoding is the

00:11:25,360 --> 00:11:31,760
ascii character set

00:11:28,079 --> 00:11:33,360
the length kind is delimited so

00:11:31,760 --> 00:11:35,760
there's a number of different ways the

00:11:33,360 --> 00:11:38,800
length of data can be determined

00:11:35,760 --> 00:11:41,360
and then those apply across the entire

00:11:38,800 --> 00:11:42,320
schema but then i had decorate also the

00:11:41,360 --> 00:11:44,800
specific

00:11:42,320 --> 00:11:45,680
uh complex type here for my r values

00:11:44,800 --> 00:11:47,600
with the

00:11:45,680 --> 00:11:49,200
properties directly on it that are

00:11:47,600 --> 00:11:51,600
particular to its

00:11:49,200 --> 00:11:53,200
uh intricacies like the sequence of two

00:11:51,600 --> 00:11:56,399
elements they're separated by a

00:11:53,200 --> 00:12:00,000
semicolon you can see that

00:11:56,399 --> 00:12:03,360
the uh in our limit and rpm gx

00:12:00,000 --> 00:12:06,399
elements each have an initiator which uh

00:12:03,360 --> 00:12:09,519
is this is uh listed here

00:12:06,399 --> 00:12:11,360
uh these things are called uh dfdl

00:12:09,519 --> 00:12:14,399
properties in particular these are what

00:12:11,360 --> 00:12:18,000
we call format properties

00:12:14,399 --> 00:12:21,519
now once you've got a dfdl schema

00:12:18,000 --> 00:12:22,560
for your data then it's off to the races

00:12:21,519 --> 00:12:24,720
now

00:12:22,560 --> 00:12:26,399
that data the schema here is in the

00:12:24,720 --> 00:12:30,000
middle of my picture

00:12:26,399 --> 00:12:32,560
um and is used both by parsing and

00:12:30,000 --> 00:12:33,760
the inverse of parsing which we call

00:12:32,560 --> 00:12:38,320
unparsing

00:12:33,760 --> 00:12:40,320
in daffodil speak so the um

00:12:38,320 --> 00:12:42,240
the data of course can be parsed by

00:12:40,320 --> 00:12:44,399
daffodil and it creates

00:12:42,240 --> 00:12:45,440
this tree-like structure you see at the

00:12:44,399 --> 00:12:47,120
bottom

00:12:45,440 --> 00:12:48,880
called which we call the daffodil

00:12:47,120 --> 00:12:52,800
infoset

00:12:48,880 --> 00:12:53,360
and that infoset uh can be projected

00:12:52,800 --> 00:12:56,720
then

00:12:53,360 --> 00:12:59,519
to and from json or xml as you saw

00:12:56,720 --> 00:13:00,720
in the example slides um it could be

00:12:59,519 --> 00:13:03,519
directly transferred

00:13:00,720 --> 00:13:04,959
uh tran uh projected into apache nifi

00:13:03,519 --> 00:13:06,000
records which i'll talk about a little

00:13:04,959 --> 00:13:08,079
bit more

00:13:06,000 --> 00:13:10,320
or other data processing frameworks that

00:13:08,079 --> 00:13:13,440
have their own sort of native ways

00:13:10,320 --> 00:13:15,360
of carrying around data

00:13:13,440 --> 00:13:16,880
you can also start from any of those

00:13:15,360 --> 00:13:20,079
formats create an

00:13:16,880 --> 00:13:22,959
info set and then go the inverse pathway

00:13:20,079 --> 00:13:25,040
and unparse it to get the data in text

00:13:22,959 --> 00:13:28,480
or binary formats

00:13:25,040 --> 00:13:31,839
uh so uh you

00:13:28,480 --> 00:13:34,959
now so schema can be written so that it

00:13:31,839 --> 00:13:36,480
both supports parsing and unparsing it's

00:13:34,959 --> 00:13:39,360
possible to write schemas that

00:13:36,480 --> 00:13:40,399
only support parsing or only support

00:13:39,360 --> 00:13:44,480
unparsing

00:13:40,399 --> 00:13:47,120
if that's all you need but most schemas

00:13:44,480 --> 00:13:49,279
are going to try to capture everything

00:13:47,120 --> 00:13:52,560
about the data format so that they're

00:13:49,279 --> 00:13:55,920
highly reusable for both parsing

00:13:52,560 --> 00:13:57,360
and serializing or unparsing of the data

00:13:55,920 --> 00:13:59,440
format

00:13:57,360 --> 00:14:01,120
a quick note on the term unparsed which

00:13:59,440 --> 00:14:04,399
does bother some people

00:14:01,120 --> 00:14:06,079
we use the term unparsed because the the

00:14:04,399 --> 00:14:08,480
common other terms for this are

00:14:06,079 --> 00:14:11,760
marshaling or serialization

00:14:08,480 --> 00:14:14,639
and both of those connote a um

00:14:11,760 --> 00:14:15,440
a serial process that we didn't really

00:14:14,639 --> 00:14:19,120
want to

00:14:15,440 --> 00:14:21,600
talk about in the dfdl standard um

00:14:19,120 --> 00:14:22,720
it's possible for example using dfdl to

00:14:21,600 --> 00:14:25,600
build

00:14:22,720 --> 00:14:26,240
access to data uh so in which case when

00:14:25,600 --> 00:14:28,000
you're

00:14:26,240 --> 00:14:29,440
quote unquote on parsing here it would

00:14:28,000 --> 00:14:33,279
actually be writing a

00:14:29,440 --> 00:14:35,440
chunk of data so uh the directions here

00:14:33,279 --> 00:14:36,720
are parson on parse in some sense and

00:14:35,440 --> 00:14:40,000
that's why we

00:14:36,720 --> 00:14:40,000
coined the term on parse

00:14:40,240 --> 00:14:45,120
so uh so the the next

00:14:43,279 --> 00:14:47,600
question that comes up of course is if i

00:14:45,120 --> 00:14:49,760
can parse data and i can unparse data

00:14:47,600 --> 00:14:51,760
great uh where do these schemas come

00:14:49,760 --> 00:14:55,839
from and the answer is

00:14:51,760 --> 00:14:58,959
you can write them or you can get them

00:14:55,839 --> 00:15:01,120
and there's sort of three kinds of

00:14:58,959 --> 00:15:02,880
or two kind of ways you can get them you

00:15:01,120 --> 00:15:04,160
can find them published

00:15:02,880 --> 00:15:06,240
um there's quite a few that are

00:15:04,160 --> 00:15:08,560
available on github

00:15:06,240 --> 00:15:10,079
most of these are on github uh or will

00:15:08,560 --> 00:15:11,839
be soon some of the new ones

00:15:10,079 --> 00:15:14,320
every time i show this slide it's

00:15:11,839 --> 00:15:16,800
obsolete by the time i show it

00:15:14,320 --> 00:15:18,320
um so there's a there's quite a bunch of

00:15:16,800 --> 00:15:18,959
them and they cover everything from

00:15:18,320 --> 00:15:22,560
images

00:15:18,959 --> 00:15:25,760
and credit card data and uh edifact and

00:15:22,560 --> 00:15:28,240
some point of sale things and uh there's

00:15:25,760 --> 00:15:28,800
a few quite a few um that have to do

00:15:28,240 --> 00:15:31,279
with

00:15:28,800 --> 00:15:33,440
uh mapping and imagery there's quite a

00:15:31,279 --> 00:15:36,480
few that have to do with avionics uh

00:15:33,440 --> 00:15:36,480
asterix is one

00:15:36,880 --> 00:15:42,480
uh aft and flight plan so there's quite

00:15:39,839 --> 00:15:44,800
a few that um

00:15:42,480 --> 00:15:46,720
that cover different different areas

00:15:44,800 --> 00:15:47,199
that are available and they're great to

00:15:46,720 --> 00:15:49,839
use as

00:15:47,199 --> 00:15:52,160
starting points for learning about dfdl

00:15:49,839 --> 00:15:53,920
schema writing

00:15:52,160 --> 00:15:56,000
there's quite a few that have to do with

00:15:53,920 --> 00:15:59,600
military uh data formats

00:15:56,000 --> 00:16:01,519
uh which is for me personally

00:15:59,600 --> 00:16:02,720
and i'll actually talk about that a

00:16:01,519 --> 00:16:06,800
little bit more

00:16:02,720 --> 00:16:08,079
uh uh in the the use case uh of cyber

00:16:06,800 --> 00:16:11,199
security which is what

00:16:08,079 --> 00:16:12,639
my company does and is the motivation

00:16:11,199 --> 00:16:14,959
for my company's interest

00:16:12,639 --> 00:16:16,800
in apache daffodil and why we're

00:16:14,959 --> 00:16:19,279
interested in contributing to it

00:16:16,800 --> 00:16:20,800
um there are also schemas available

00:16:19,279 --> 00:16:23,759
under commercial license

00:16:20,800 --> 00:16:27,199
uh for these really large and complex

00:16:23,759 --> 00:16:30,000
data formats you know hl7 for example or

00:16:27,199 --> 00:16:30,800
usmtf these are big complicated things

00:16:30,000 --> 00:16:33,920
it's not

00:16:30,800 --> 00:16:37,680
that easy to create one and

00:16:33,920 --> 00:16:40,720
uh and just publish it uh for free

00:16:37,680 --> 00:16:42,639
uh they require support and so forth so

00:16:40,720 --> 00:16:45,600
some some schemas are available for

00:16:42,639 --> 00:16:45,600
commercial license

00:16:46,000 --> 00:16:51,279
so there's there's quite a an ecosystem

00:16:49,040 --> 00:16:55,839
sort of starting to grow around building

00:16:51,279 --> 00:16:55,839
dfdl schemas for important data types

00:16:56,720 --> 00:17:02,000
so um so i want to come back to the

00:16:58,959 --> 00:17:04,079
theme of killing the data format problem

00:17:02,000 --> 00:17:05,760
so we've got this system that i've

00:17:04,079 --> 00:17:09,360
talked about apache daffodil

00:17:05,760 --> 00:17:12,559
there and this um uh and this standard

00:17:09,360 --> 00:17:14,319
and that's really about the strength

00:17:12,559 --> 00:17:16,000
we have for trying to kill the data

00:17:14,319 --> 00:17:18,319
format problem which is

00:17:16,000 --> 00:17:20,400
you really do need two things to kill

00:17:18,319 --> 00:17:21,760
the data format problem you need an open

00:17:20,400 --> 00:17:24,480
standard language

00:17:21,760 --> 00:17:25,839
that everyone can have a nation of and

00:17:24,480 --> 00:17:29,200
that has multiple

00:17:25,839 --> 00:17:32,480
implementations that interoperate um and

00:17:29,200 --> 00:17:36,000
with some sponsors uh behind it

00:17:32,480 --> 00:17:39,039
uh which includes um ibm as well as

00:17:36,000 --> 00:17:41,919
uh the usdod and canada dnd

00:17:39,039 --> 00:17:43,200
um the primary use case for this is

00:17:41,919 --> 00:17:44,720
cyber security and i'll tell you a

00:17:43,200 --> 00:17:46,240
little bit more about that use case in

00:17:44,720 --> 00:17:49,120
the next couple slides

00:17:46,240 --> 00:17:50,960
but i think nowadays if you don't you

00:17:49,120 --> 00:17:51,919
you want to solve a real problem for our

00:17:50,960 --> 00:17:53,919
industry you

00:17:51,919 --> 00:17:55,200
have to build a high quality open source

00:17:53,919 --> 00:17:56,799
implementation

00:17:55,200 --> 00:17:58,880
um and it has to have a community of

00:17:56,799 --> 00:18:00,559
developers uh you can have

00:17:58,880 --> 00:18:02,480
available commercial support which my

00:18:00,559 --> 00:18:04,559
company does provide for people

00:18:02,480 --> 00:18:05,600
um and that's the role apache daffodil

00:18:04,559 --> 00:18:08,480
plays which is that

00:18:05,600 --> 00:18:09,280
it uh it ensures that people can have

00:18:08,480 --> 00:18:10,880
free access

00:18:09,280 --> 00:18:12,880
not only to the standard but to an

00:18:10,880 --> 00:18:14,640
implementation of the standard

00:18:12,880 --> 00:18:16,320
so they can get off the ground using it

00:18:14,640 --> 00:18:20,000
quickly and easily

00:18:16,320 --> 00:18:20,000
with a high quality piece of software

00:18:20,160 --> 00:18:23,760
now i wanted to talk about the um the

00:18:22,960 --> 00:18:26,000
use case

00:18:23,760 --> 00:18:28,160
of the cyber security use case because

00:18:26,000 --> 00:18:31,840
people often ask me

00:18:28,160 --> 00:18:33,520
why uh what daffodil has to do per se

00:18:31,840 --> 00:18:36,559
with cyber security

00:18:33,520 --> 00:18:37,360
so the um the cyber security use case is

00:18:36,559 --> 00:18:41,280
what we call

00:18:37,360 --> 00:18:43,280
bad data denial of service bad data dos

00:18:41,280 --> 00:18:44,960
so what you see here is a little picture

00:18:43,280 --> 00:18:46,240
of a firewall and you have some high

00:18:44,960 --> 00:18:49,520
threat network on the left

00:18:46,240 --> 00:18:50,640
like the internet and you have a secure

00:18:49,520 --> 00:18:52,559
network on the other side of the

00:18:50,640 --> 00:18:54,400
firewall maybe that's your application

00:18:52,559 --> 00:18:56,400
servers your database back ends

00:18:54,400 --> 00:18:57,919
whatever it is and the firewall is of

00:18:56,400 --> 00:18:59,039
course supposed to be protecting one

00:18:57,919 --> 00:19:02,000
from the other

00:18:59,039 --> 00:19:03,840
now uh this yellow circle here is uh

00:19:02,000 --> 00:19:05,840
depicting a piece of data that says is

00:19:03,840 --> 00:19:09,760
of some format which i'm calling format

00:19:05,840 --> 00:19:10,000
x so the question that the firewall has

00:19:09,760 --> 00:19:11,520
to

00:19:10,000 --> 00:19:13,600
answer the firewall may be very

00:19:11,520 --> 00:19:16,000
demanding it may say whitelist

00:19:13,600 --> 00:19:17,679
i only allow data to go across this

00:19:16,000 --> 00:19:18,559
firewall if it is of one of the

00:19:17,679 --> 00:19:22,080
recognized

00:19:18,559 --> 00:19:25,760
formats but how does it really know

00:19:22,080 --> 00:19:28,160
if that data is of format x and won't

00:19:25,760 --> 00:19:29,760
crash the applications once it gets over

00:19:28,160 --> 00:19:31,440
onto the secure network side

00:19:29,760 --> 00:19:32,960
i mean what if this data is just

00:19:31,440 --> 00:19:35,360
pretending to be format

00:19:32,960 --> 00:19:37,360
x has the right magic number and the

00:19:35,360 --> 00:19:38,080
right file extension and all those

00:19:37,360 --> 00:19:40,400
things

00:19:38,080 --> 00:19:42,160
and looks at the beginning to be format

00:19:40,400 --> 00:19:45,520
x but it's actually

00:19:42,160 --> 00:19:49,440
bad data right so how is the firewall

00:19:45,520 --> 00:19:52,000
going to do this better so that it can

00:19:49,440 --> 00:19:53,039
rule out the pretenders well so the

00:19:52,000 --> 00:19:55,520
cyber 30

00:19:53,039 --> 00:19:57,280
the reason we're using daffodil is

00:19:55,520 --> 00:20:00,240
roughly speaking like this

00:19:57,280 --> 00:20:01,760
the data says it's format x well let's

00:20:00,240 --> 00:20:04,799
prove its format x

00:20:01,760 --> 00:20:08,000
way we do that is we parse it using a

00:20:04,799 --> 00:20:10,159
dfdl schema for format x we get out an

00:20:08,000 --> 00:20:10,799
info set which can be validated and so

00:20:10,159 --> 00:20:13,760
forth and

00:20:10,799 --> 00:20:15,120
scrutinized then we un-parse it back to

00:20:13,760 --> 00:20:16,559
its native format

00:20:15,120 --> 00:20:18,720
so when the data comes out the other

00:20:16,559 --> 00:20:20,960
side of the firewall it is proven to be

00:20:18,720 --> 00:20:24,480
format x by construction

00:20:20,960 --> 00:20:26,880
it is format x for sure now and if it

00:20:24,480 --> 00:20:28,720
can't survive this process then it was

00:20:26,880 --> 00:20:31,120
bad data

00:20:28,720 --> 00:20:33,120
so that's the site essentially in a

00:20:31,120 --> 00:20:34,880
nutshell there's a lot more nuances to

00:20:33,120 --> 00:20:36,640
it of course but that's the cyber

00:20:34,880 --> 00:20:40,159
security use case

00:20:36,640 --> 00:20:43,280
for uh for fdl and apache data

00:20:40,159 --> 00:20:45,120
is you need you need of course schemas

00:20:43,280 --> 00:20:47,520
for all kinds of data that you want to

00:20:45,120 --> 00:20:51,120
have across the firewall

00:20:47,520 --> 00:20:54,960
but you don't packages for every

00:20:51,120 --> 00:20:54,960
kind of data that crosses the phone

00:20:55,280 --> 00:21:01,200
now i want to talk about quickly

00:20:58,880 --> 00:21:02,400
daffodil because the purpose of this

00:21:01,200 --> 00:21:05,840
library

00:21:02,400 --> 00:21:07,200
is to be integrated into other software

00:21:05,840 --> 00:21:10,480
packages that

00:21:07,200 --> 00:21:13,120
provide the manipulation fabrics for

00:21:10,480 --> 00:21:14,159
data of all kinds so one of the ones

00:21:13,120 --> 00:21:17,600
that's popular

00:21:14,159 --> 00:21:19,440
is apache nifi and we have uh now i

00:21:17,600 --> 00:21:21,039
what i call a native integration and

00:21:19,440 --> 00:21:22,559
i'll talk a little bit more about that

00:21:21,039 --> 00:21:24,799
in the next couple slides

00:21:22,559 --> 00:21:26,080
um we have an apache spark integration

00:21:24,799 --> 00:21:28,159
that uses uh

00:21:26,080 --> 00:21:29,440
converts data to xml and hands it off as

00:21:28,159 --> 00:21:31,840
xml to spark

00:21:29,440 --> 00:21:32,720
i'd like to upgrade that to a native one

00:21:31,840 --> 00:21:35,440
um

00:21:32,720 --> 00:21:37,039
there's an x proc engine which is a xml

00:21:35,440 --> 00:21:38,080
transformation pipeline tool called

00:21:37,039 --> 00:21:40,080
calabash

00:21:38,080 --> 00:21:41,840
there's a daffodil integration for that

00:21:40,080 --> 00:21:43,520
a company called software ag

00:21:41,840 --> 00:21:45,520
has done an integration with their

00:21:43,520 --> 00:21:46,880
product called integration server which

00:21:45,520 --> 00:21:49,440
you might have heard of it used to be

00:21:46,880 --> 00:21:52,159
called web methods

00:21:49,440 --> 00:21:52,880
our my company's products embed apache

00:21:52,159 --> 00:21:54,799
daffodil

00:21:52,880 --> 00:21:57,600
other companies products are embedding

00:21:54,799 --> 00:21:59,919
apache daffodil

00:21:57,600 --> 00:22:01,360
there's a lot of important potential for

00:21:59,919 --> 00:22:04,000
native integrations

00:22:01,360 --> 00:22:05,520
into a variety of the processing fabrics

00:22:04,000 --> 00:22:07,679
and utilities that we have

00:22:05,520 --> 00:22:08,880
in the apache software foundation

00:22:07,679 --> 00:22:11,919
projects uh

00:22:08,880 --> 00:22:14,000
spark flink beam hadoop all these things

00:22:11,919 --> 00:22:18,159
can benefit tremendously from

00:22:14,000 --> 00:22:19,919
using dfdl uh and daffodil to provide

00:22:18,159 --> 00:22:21,919
access to the kinds of data that are

00:22:19,919 --> 00:22:22,960
otherwise quite hard for them to cope

00:22:21,919 --> 00:22:25,840
with

00:22:22,960 --> 00:22:27,679
so let me talk quickly about difi just

00:22:25,840 --> 00:22:30,720
as an example of how

00:22:27,679 --> 00:22:32,640
an integration works so i realize this

00:22:30,720 --> 00:22:35,600
diagram isn't that easy to read but

00:22:32,640 --> 00:22:37,360
on the left there's a daffodil parsing

00:22:35,600 --> 00:22:37,919
this was a little example flow we built

00:22:37,360 --> 00:22:40,400
it's actually

00:22:37,919 --> 00:22:42,880
parsing pcapp data which is developed

00:22:40,400 --> 00:22:44,880
relatively easy to parse

00:22:42,880 --> 00:22:46,400
and feeding it through and unparsing it

00:22:44,880 --> 00:22:48,720
again on the other side

00:22:46,400 --> 00:22:50,159
and there's a transformation in between

00:22:48,720 --> 00:22:52,400
so

00:22:50,159 --> 00:22:53,280
the question is what moves on the arcs

00:22:52,400 --> 00:22:55,760
between

00:22:53,280 --> 00:22:58,799
the daffodil parse component and the

00:22:55,760 --> 00:23:02,000
transform component

00:22:58,799 --> 00:23:04,720
and the and recently a direct

00:23:02,000 --> 00:23:06,080
native data and metadata bridge has been

00:23:04,720 --> 00:23:08,880
built for nifi

00:23:06,080 --> 00:23:09,919
so this bypasses all the xml and json

00:23:08,880 --> 00:23:11,600
overheads

00:23:09,919 --> 00:23:13,280
basically you have two parts to this

00:23:11,600 --> 00:23:16,159
thing there's a metadata bridge

00:23:13,280 --> 00:23:17,760
which runs essentially at compile time

00:23:16,159 --> 00:23:21,360
or startup time of

00:23:17,760 --> 00:23:25,039
the job uh and that is able to come

00:23:21,360 --> 00:23:26,640
project a dfdl schema into a native nifi

00:23:25,039 --> 00:23:29,520
record schema

00:23:26,640 --> 00:23:30,000
uh allowing uh so it's a metadata

00:23:29,520 --> 00:23:31,840
mapping

00:23:30,000 --> 00:23:35,039
and then of course at runtime the data

00:23:31,840 --> 00:23:36,720
bridge converts the dfdl infoset tree in

00:23:35,039 --> 00:23:39,840
directly into a nifi

00:23:36,720 --> 00:23:41,600
record native nifi record and so that

00:23:39,840 --> 00:23:44,640
the data can be carried through

00:23:41,600 --> 00:23:48,320
nifi flow in the most efficient way

00:23:44,640 --> 00:23:50,400
which is nifi's own native record format

00:23:48,320 --> 00:23:52,320
a similar kind of native integration

00:23:50,400 --> 00:23:53,440
with these two parts the metadata bridge

00:23:52,320 --> 00:23:55,600
and the data bridge

00:23:53,440 --> 00:23:56,720
uh can be done for any of the big data

00:23:55,600 --> 00:23:58,799
frameworks um

00:23:56,720 --> 00:24:00,320
they they all they have a they'll have

00:23:58,799 --> 00:24:04,000
some sort of way of

00:24:00,320 --> 00:24:06,880
native carrying structure for data

00:24:04,000 --> 00:24:08,640
uh and uh the metadata bridge and the

00:24:06,880 --> 00:24:10,880
data bridge can be built for those

00:24:08,640 --> 00:24:12,559
and then they would have a native they

00:24:10,880 --> 00:24:17,520
would have a native adaptive

00:24:12,559 --> 00:24:21,039
adapter to anything described

00:24:17,520 --> 00:24:22,240
um okay so um popping up to sort of uh

00:24:21,039 --> 00:24:24,960
procedural

00:24:22,240 --> 00:24:26,640
things daffodil is an incubator project

00:24:24,960 --> 00:24:30,240
right

00:24:26,640 --> 00:24:33,440
now for three years since september 2017

00:24:30,240 --> 00:24:36,000
we've had seven apache releases by the

00:24:33,440 --> 00:24:38,000
way this code base is written in scala

00:24:36,000 --> 00:24:40,159
it runs on the java virtual machines it

00:24:38,000 --> 00:24:42,159
has a java api of course

00:24:40,159 --> 00:24:44,400
the status of our project is community

00:24:42,159 --> 00:24:46,080
building we believe we're ready for new

00:24:44,400 --> 00:24:47,760
developers there's some new developers

00:24:46,080 --> 00:24:49,200
that have come on board this year

00:24:47,760 --> 00:24:50,559
there's a lot of beginner tickets out

00:24:49,200 --> 00:24:52,159
there available for people to get

00:24:50,559 --> 00:24:54,240
started

00:24:52,159 --> 00:24:57,279
a bunch of interesting new areas for

00:24:54,240 --> 00:25:00,080
people to contribute to

00:24:57,279 --> 00:25:00,400
the reason we're still poddling still in

00:25:00,080 --> 00:25:03,919
the

00:25:00,400 --> 00:25:06,159
incubator is because the we need

00:25:03,919 --> 00:25:07,279
more developers from a more diverse

00:25:06,159 --> 00:25:10,000
group of companies

00:25:07,279 --> 00:25:11,919
apache software foundation's guidance of

00:25:10,000 --> 00:25:12,640
course is top level projects need to

00:25:11,919 --> 00:25:15,120
have

00:25:12,640 --> 00:25:16,720
viability even if a company decides they

00:25:15,120 --> 00:25:18,799
no longer want to contribute there need

00:25:16,720 --> 00:25:21,440
to be enough other companies involved

00:25:18,799 --> 00:25:22,159
that the project is viable and not just

00:25:21,440 --> 00:25:24,320
something

00:25:22,159 --> 00:25:25,760
that lives or dies with one company's

00:25:24,320 --> 00:25:28,080
interest

00:25:25,760 --> 00:25:28,960
so so that's where we are in community

00:25:28,080 --> 00:25:31,039
building i'm quite

00:25:28,960 --> 00:25:33,840
optimistic that sometime in the next uh

00:25:31,039 --> 00:25:36,080
six months or so we're going to have it

00:25:33,840 --> 00:25:37,679
to be able to graduate uh keeping my

00:25:36,080 --> 00:25:39,840
fingers crossed on that i um

00:25:37,679 --> 00:25:41,279
i've seen some new contributors from

00:25:39,840 --> 00:25:44,080
another whole company

00:25:41,279 --> 00:25:45,679
just in the last 48 hours so that's kind

00:25:44,080 --> 00:25:48,720
of exciting

00:25:45,679 --> 00:25:52,000
um so uh

00:25:48,720 --> 00:25:54,000
there's some um cool new ideas

00:25:52,000 --> 00:25:55,200
uh here's where i'm going to start

00:25:54,000 --> 00:25:57,760
advertising about

00:25:55,200 --> 00:25:59,360
why i want you guys who are developers

00:25:57,760 --> 00:26:02,640
who are interested in this

00:25:59,360 --> 00:26:04,080
to get involved in daffodil project uh

00:26:02,640 --> 00:26:04,720
so one of the things we're doing with

00:26:04,080 --> 00:26:07,279
daffodil

00:26:04,720 --> 00:26:10,000
is we're extending it to have a sort of

00:26:07,279 --> 00:26:13,440
sax style event streaming capability

00:26:10,000 --> 00:26:15,919
that allows it to fits in memory

00:26:13,440 --> 00:26:17,039
this is partly done not entirely done

00:26:15,919 --> 00:26:19,200
yet

00:26:17,039 --> 00:26:20,559
but it's an exciting capability because

00:26:19,200 --> 00:26:23,840
in many cases people have

00:26:20,559 --> 00:26:27,200
gigantic pieces of data

00:26:23,840 --> 00:26:30,960
that they want to cross

00:26:27,200 --> 00:26:32,799
they want to use daffodil to process

00:26:30,960 --> 00:26:34,400
the i already mentioned the integration

00:26:32,799 --> 00:26:36,799
with um

00:26:34,400 --> 00:26:38,000
with nifi integration with other big

00:26:36,799 --> 00:26:40,720
data frameworks and data

00:26:38,000 --> 00:26:41,039
tools in the apache uh community are of

00:26:40,720 --> 00:26:43,200
course

00:26:41,039 --> 00:26:44,240
exciting because they immediately bring

00:26:43,200 --> 00:26:47,200
the uh

00:26:44,240 --> 00:26:48,559
benefits of using daffodil to uh the

00:26:47,200 --> 00:26:49,440
community of people using that

00:26:48,559 --> 00:26:51,919
particular

00:26:49,440 --> 00:26:52,880
framework so we want to do more of those

00:26:51,919 --> 00:26:54,799
um there's an

00:26:52,880 --> 00:26:57,039
exciting project which kind of got

00:26:54,799 --> 00:27:00,640
kicked off of two years ago

00:26:57,039 --> 00:27:02,480
um uh but is finally just starting to

00:27:00,640 --> 00:27:05,600
produce some fruition which is

00:27:02,480 --> 00:27:07,919
we're building a ultra small uh

00:27:05,600 --> 00:27:08,720
ultra-fast small footprint back-end for

00:27:07,919 --> 00:27:11,279
daffodil that

00:27:08,720 --> 00:27:12,320
actually takes a dftl format description

00:27:11,279 --> 00:27:14,880
it converts it to c

00:27:12,320 --> 00:27:16,400
code to actually generate c code uh and

00:27:14,880 --> 00:27:16,960
that project has the ambitions to

00:27:16,400 --> 00:27:20,480
generate

00:27:16,960 --> 00:27:21,600
actually fpga logic for hardware in

00:27:20,480 --> 00:27:24,080
essence logic

00:27:21,600 --> 00:27:25,120
from dfdl schemas for wire speed parts

00:27:24,080 --> 00:27:26,720
and on parse

00:27:25,120 --> 00:27:28,640
so that's kind of exciting the current

00:27:26,720 --> 00:27:29,200
backend is written in scala and it's

00:27:28,640 --> 00:27:31,679
really

00:27:29,200 --> 00:27:33,360
it's fast but it's designed really more

00:27:31,679 --> 00:27:35,840
for correctness

00:27:33,360 --> 00:27:35,840
than speed

00:27:36,399 --> 00:27:40,320
and then finally the whole purpose of

00:27:39,679 --> 00:27:42,480
having a

00:27:40,320 --> 00:27:44,799
standard data format description

00:27:42,480 --> 00:27:47,440
language is people could start to invest

00:27:44,799 --> 00:27:48,000
in the tooling more seriously because

00:27:47,440 --> 00:27:50,880
the tooling

00:27:48,000 --> 00:27:52,720
then has more universal usage across all

00:27:50,880 --> 00:27:53,279
the different frameworks and things that

00:27:52,720 --> 00:27:56,159
plug in

00:27:53,279 --> 00:27:57,200
apache daffodil uh so the project just

00:27:56,159 --> 00:28:01,039
started to create

00:27:57,200 --> 00:28:03,440
a um a plugin

00:28:01,039 --> 00:28:05,440
uh for uh uh integrated development

00:28:03,440 --> 00:28:08,799
environment this particular project

00:28:05,440 --> 00:28:10,480
uh is uh using eclipse right now

00:28:08,799 --> 00:28:11,919
you should use apache netbeans and i'd

00:28:10,480 --> 00:28:15,120
love to see that too

00:28:11,919 --> 00:28:17,039
um and uh but the idea is to have

00:28:15,120 --> 00:28:18,640
what i call a data format debugger

00:28:17,039 --> 00:28:20,399
that's something that gives you multiple

00:28:18,640 --> 00:28:22,000
panel view where you can see the data

00:28:20,399 --> 00:28:22,880
you can see what it turns into when you

00:28:22,000 --> 00:28:24,960
parse it

00:28:22,880 --> 00:28:27,440
uh you can see the schema and you can

00:28:24,960 --> 00:28:30,240
interact with those pieces

00:28:27,440 --> 00:28:30,880
to get your schema to parse the data

00:28:30,240 --> 00:28:33,520
properly

00:28:30,880 --> 00:28:34,880
or unparse it properly uh and so forth

00:28:33,520 --> 00:28:36,640
and gives you a nice interactive

00:28:34,880 --> 00:28:39,360
capability to do that

00:28:36,640 --> 00:28:40,720
um today we we do this by uh we have a

00:28:39,360 --> 00:28:42,159
command line tool that comes with

00:28:40,720 --> 00:28:44,320
daffodil that is the

00:28:42,159 --> 00:28:46,640
the packaging of it that lets you use

00:28:44,320 --> 00:28:49,760
the circuit right away

00:28:46,640 --> 00:28:52,960
so um developers are wanted uh develop

00:28:49,760 --> 00:28:54,880
daffodil is quite big and comp

00:28:52,960 --> 00:28:56,480
it's both good and bad it means it's

00:28:54,880 --> 00:28:58,159
quite a learning curve on the other hand

00:28:56,480 --> 00:29:01,279
it's nice and meaty and exciting

00:28:58,159 --> 00:29:03,120
and fun to work on and

00:29:01,279 --> 00:29:05,360
worked on a compiler you'll learn a lot

00:29:03,120 --> 00:29:07,520
about compilers

00:29:05,360 --> 00:29:09,679
it has this pretty efficient low-level

00:29:07,520 --> 00:29:12,880
runtime and of course the c

00:29:09,679 --> 00:29:15,440
new c runtime that is exciting and

00:29:12,880 --> 00:29:17,679
just coming out you get to know or if

00:29:15,440 --> 00:29:20,240
you know or want to learn scala

00:29:17,679 --> 00:29:21,600
if you know or want to learn xml schema

00:29:20,240 --> 00:29:24,399
these are things that we

00:29:21,600 --> 00:29:25,360
use heavily um it is a pretty big

00:29:24,399 --> 00:29:28,559
codebase it's

00:29:25,360 --> 00:29:30,320
295 000 lines of stuff

00:29:28,559 --> 00:29:32,080
a hundred and seven thousand lines of

00:29:30,320 --> 00:29:36,480
that are the implementation

00:29:32,080 --> 00:29:36,960
scala uh something closer to 180 000

00:29:36,480 --> 00:29:40,240
lines

00:29:36,960 --> 00:29:42,799
are test related so it's a it's a mature

00:29:40,240 --> 00:29:44,720
it matured solid code base with a lot of

00:29:42,799 --> 00:29:47,200
tests associated with it i think

00:29:44,720 --> 00:29:48,640
uh that speaks well to the seriousness

00:29:47,200 --> 00:29:50,320
that we uh

00:29:48,640 --> 00:29:51,600
uh we take the quality of the software

00:29:50,320 --> 00:29:54,159
with the team that are currently

00:29:51,600 --> 00:29:55,600
contributing it's really quite a uh

00:29:54,159 --> 00:29:57,600
quite a nice thing to be able to show

00:29:55,600 --> 00:29:59,200
this pie chart so we

00:29:57,600 --> 00:30:01,360
do need developers who are kind of

00:29:59,200 --> 00:30:02,799
undaunted by these challenges who look

00:30:01,360 --> 00:30:05,039
at a big code base and they see

00:30:02,799 --> 00:30:07,679
opportunity as opposed to very

00:30:05,039 --> 00:30:10,960
intimidated by it

00:30:07,679 --> 00:30:13,279
and who are motivated by data format

00:30:10,960 --> 00:30:16,399
problem once and for all

00:30:13,279 --> 00:30:17,679
so with that um i

00:30:16,399 --> 00:30:19,520
actually have a little time for

00:30:17,679 --> 00:30:22,399
questions uh and uh

00:30:19,520 --> 00:30:24,320
happy to take them here in the chat or

00:30:22,399 --> 00:30:28,720
you can reach me

00:30:24,320 --> 00:30:31,919
via m beckerly apache.org

00:30:28,720 --> 00:30:35,120
and i hope you will browse

00:30:31,919 --> 00:30:36,960
the the daffodil

00:30:35,120 --> 00:30:39,840
easiest place to start is the daffodil

00:30:36,960 --> 00:30:41,679
apache.org site and from there you can

00:30:39,840 --> 00:30:44,159
find your way to everything about apache

00:30:41,679 --> 00:30:47,520
daffodil and the dfdl standard

00:30:44,159 --> 00:30:50,320
and so forth so

00:30:47,520 --> 00:30:52,480
i'll uh i'll pause for questions and if

00:30:50,320 --> 00:30:54,240
you have any type them in

00:30:52,480 --> 00:31:05,840
i look forward to talking with you thank

00:30:54,240 --> 00:31:05,840
you very much

00:31:52,799 --> 00:31:55,919
looks like my video froze for a period

00:31:54,720 --> 00:31:57,440
of time

00:31:55,919 --> 00:32:00,799
of course i'm hoping that you were

00:31:57,440 --> 00:32:00,799
looking at slides not me

00:32:04,080 --> 00:32:08,399
but it's back now i actually can wave to

00:32:12,840 --> 00:32:15,840
everybody

00:32:26,880 --> 00:32:30,080
okay well if there's no questions i

00:32:28,399 --> 00:32:30,399
guess i'll wrap it up and you can go on

00:32:30,080 --> 00:32:32,240
to

00:32:30,399 --> 00:32:33,679
enjoy some more of the apache con

00:32:32,240 --> 00:32:35,360
sessions uh

00:32:33,679 --> 00:32:37,360
look forward to talking with people on

00:32:35,360 --> 00:32:41,120
emails or other chat channels

00:32:37,360 --> 00:32:57,840
and thank you very much for uh

00:32:41,120 --> 00:32:57,840
thank you very much for listening

00:33:25,519 --> 00:33:27,600

YouTube URL: https://www.youtube.com/watch?v=6XHeAa4h_9s


