Title: Solr Query Parsing
Publication date: 2013-10-17
Playlist: Apachecon NA 2013 - day 2
Description: 
	Erik Hatcher
ApacheCon NA 2013
Big Data
Captions: 
	00:00:00,000 --> 00:00:07,410
have Erik catcher and he's going to

00:00:02,310 --> 00:00:11,519
explain us about solar query pasa thanks

00:00:07,410 --> 00:00:13,440
I guess I should start with a pole first

00:00:11,519 --> 00:00:16,949
the Vols show of hands how many people

00:00:13,440 --> 00:00:18,359
are using solar now so hopefully a good

00:00:16,949 --> 00:00:21,000
portion of you since this is going to be

00:00:18,359 --> 00:00:23,699
you know specifically about a slice of a

00:00:21,000 --> 00:00:26,789
slice of solar but not an intro to solar

00:00:23,699 --> 00:00:29,340
per se well it's good to see a big

00:00:26,789 --> 00:00:32,279
turnout here my name is Eric Hatcher I'm

00:00:29,340 --> 00:00:33,750
a leucine and solar committer I work for

00:00:32,279 --> 00:00:37,020
a company called lucid works we support

00:00:33,750 --> 00:00:40,829
leucine solar and so on training and

00:00:37,020 --> 00:00:44,399
such so I'm going to talk about solar

00:00:40,829 --> 00:00:53,670
query parsing solar is a search engine

00:00:44,399 --> 00:00:55,020
that scales to big data and so on and in

00:00:53,670 --> 00:00:56,940
order to query it of course you have to

00:00:55,020 --> 00:00:58,289
be able to send inquiries you know very

00:00:56,940 --> 00:00:59,789
much like a database right to send in a

00:00:58,289 --> 00:01:01,710
sequel query but there's a lot of

00:00:59,789 --> 00:01:03,780
different types of ways that you can

00:01:01,710 --> 00:01:07,680
send queries in the solar it's a very

00:01:03,780 --> 00:01:11,310
rich and extensible framework basically

00:01:07,680 --> 00:01:13,380
inside and of course in order to find

00:01:11,310 --> 00:01:15,810
the data that you want you need to be

00:01:13,380 --> 00:01:18,330
able to come up with the expressions

00:01:15,810 --> 00:01:20,700
from your front end and be able to send

00:01:18,330 --> 00:01:22,170
those into solar to you know match the

00:01:20,700 --> 00:01:28,439
documents that you that you care about

00:01:22,170 --> 00:01:30,479
there ok so we talked about basically

00:01:28,439 --> 00:01:34,650
the entire query parsing framework

00:01:30,479 --> 00:01:38,400
that's in solar this is the definitive

00:01:34,650 --> 00:01:40,530
list of built-in query parsers it looks

00:01:38,400 --> 00:01:42,420
a little funny here you know this copy

00:01:40,530 --> 00:01:44,250
and paste from the code I took all of

00:01:42,420 --> 00:01:46,740
those constants there where it says dot

00:01:44,250 --> 00:01:49,229
name and turned them actually just slide

00:01:46,740 --> 00:01:51,450
purposes to what they resolved to so

00:01:49,229 --> 00:01:55,170
that you can see those names these names

00:01:51,450 --> 00:01:58,259
on the left side here are the key to the

00:01:55,170 --> 00:02:00,030
query parser so in order to address or

00:01:58,259 --> 00:02:03,180
to pick a certain query parser you need

00:02:00,030 --> 00:02:04,880
to know that string in order to you know

00:02:03,180 --> 00:02:08,009
to select that query parser to be in use

00:02:04,880 --> 00:02:12,870
the default query parser is what's

00:02:08,009 --> 00:02:13,900
called busine it's not the leucine query

00:02:12,870 --> 00:02:16,620
parser

00:02:13,900 --> 00:02:20,019
exactly but it is the leucine syntax

00:02:16,620 --> 00:02:22,150
query parser so if you've used leucine

00:02:20,019 --> 00:02:25,060
before show hands people usually seen

00:02:22,150 --> 00:02:26,650
before solar all right good so if you're

00:02:25,060 --> 00:02:30,760
familiar with what's literally called

00:02:26,650 --> 00:02:33,040
query parser class in lucene you're

00:02:30,760 --> 00:02:36,670
familiar with that syntax there and

00:02:33,040 --> 00:02:38,109
we'll go through many of these query

00:02:36,670 --> 00:02:43,629
parsers here so you can see what these

00:02:38,109 --> 00:02:46,090
things do as they go first I'll talk

00:02:43,629 --> 00:02:48,819
about what's new in 40 X here there's a

00:02:46,090 --> 00:02:50,290
surround query parser if you've used

00:02:48,819 --> 00:02:52,569
this underscore query underscore i'll

00:02:50,290 --> 00:02:54,549
talk about that in a bit that's no

00:02:52,569 --> 00:02:57,010
longer necessary to have that underscore

00:02:54,549 --> 00:02:58,720
query underscore silliness in there and

00:02:57,010 --> 00:03:01,150
then there's a new query parser that

00:02:58,720 --> 00:03:02,290
just got committed two days ago called

00:03:01,150 --> 00:03:07,689
the switch gray boxer and I'll show you

00:03:02,290 --> 00:03:12,879
example of that in a bit as well so

00:03:07,689 --> 00:03:14,709
first the lucene syntax query parser the

00:03:12,879 --> 00:03:16,689
special thing about this above and

00:03:14,709 --> 00:03:19,569
beyond what the lucene syntax offers is

00:03:16,689 --> 00:03:21,819
that it is field type aware so in solar

00:03:19,569 --> 00:03:24,459
you have a schema your schema maps to

00:03:21,819 --> 00:03:26,379
your field names to field types and

00:03:24,459 --> 00:03:28,750
those field types have different types

00:03:26,379 --> 00:03:31,629
of analysis on them and so on so you

00:03:28,750 --> 00:03:34,180
need to be able to when you query for a

00:03:31,629 --> 00:03:36,370
particular term it needs to know what

00:03:34,180 --> 00:03:38,470
that field type is for the field that

00:03:36,370 --> 00:03:41,019
you're querying in order to do things

00:03:38,470 --> 00:03:45,299
with the range queries if it's a date

00:03:41,019 --> 00:03:48,220
field it will do date math if it's

00:03:45,299 --> 00:03:49,780
numerics you may in depending on the

00:03:48,220 --> 00:03:51,519
numeric field type so this is where the

00:03:49,780 --> 00:03:53,560
field type awareness comes in it needs

00:03:51,519 --> 00:03:56,650
to convert that numeric value into what

00:03:53,560 --> 00:04:00,220
the underlying index value is in order

00:03:56,650 --> 00:04:01,720
to obviously to match there's a few

00:04:00,220 --> 00:04:04,479
other bells and whistles in there in

00:04:01,720 --> 00:04:07,709
this leucine query parser reverse

00:04:04,479 --> 00:04:10,810
wildcard terms so if you use this filter

00:04:07,709 --> 00:04:14,260
called the reverse wildcard filter what

00:04:10,810 --> 00:04:18,639
that does is allows you to have better

00:04:14,260 --> 00:04:22,690
performance on prefixed queries so if

00:04:18,639 --> 00:04:25,270
you say you know search for star foo if

00:04:22,690 --> 00:04:26,670
i gave you a dictionary and said find me

00:04:25,270 --> 00:04:29,390
all documents

00:04:26,670 --> 00:04:31,230
finally all words that match star foo

00:04:29,390 --> 00:04:33,420
you would have to do an exhaustive

00:04:31,230 --> 00:04:34,770
search through that dictionary to do

00:04:33,420 --> 00:04:36,960
that and the same thing happens in

00:04:34,770 --> 00:04:41,640
lucene so it can be a performance hit in

00:04:36,960 --> 00:04:44,160
order to to match those there's this

00:04:41,640 --> 00:04:45,480
reverse wildcard filter as your indexing

00:04:44,160 --> 00:04:47,370
the documents so you just set this

00:04:45,480 --> 00:04:51,390
reverse wildcard filter on your index

00:04:47,370 --> 00:04:54,210
time analysis chain in your schema field

00:04:51,390 --> 00:04:57,180
type definition when you have that

00:04:54,210 --> 00:04:59,850
defined and your index time side at

00:04:57,180 --> 00:05:02,670
query time the leucine query parser

00:04:59,850 --> 00:05:04,590
understands knows that that field type

00:05:02,670 --> 00:05:07,620
knows that the was reversed at index

00:05:04,590 --> 00:05:11,060
time and if you search for star foo it

00:05:07,620 --> 00:05:14,070
will reverse it and search 400f star

00:05:11,060 --> 00:05:17,100
basically and so it was indexed in a

00:05:14,070 --> 00:05:19,920
reverse manner as well as in forward

00:05:17,100 --> 00:05:24,150
order as well so a few tricks like that

00:05:19,920 --> 00:05:26,910
that's in there the leucine query parser

00:05:24,150 --> 00:05:29,700
syntax isn't really extensible other

00:05:26,910 --> 00:05:33,390
than the field name so you can say field

00:05:29,700 --> 00:05:35,730
name colon and then expression either in

00:05:33,390 --> 00:05:39,230
prints or quotes or just a raw term with

00:05:35,730 --> 00:05:42,470
the field name prefixed in front of it

00:05:39,230 --> 00:05:44,670
the leucine quarter has to backdoor

00:05:42,470 --> 00:05:46,860
special field names underscore Val

00:05:44,670 --> 00:05:49,230
underscore and underscore query

00:05:46,860 --> 00:05:51,510
underscore that underscore valence core

00:05:49,230 --> 00:05:54,890
maps to function queries so and your

00:05:51,510 --> 00:05:57,210
leucine query syntax you can say and

00:05:54,890 --> 00:05:59,240
underscore val underscore colon and then

00:05:57,210 --> 00:06:01,350
give it a function query expression

00:05:59,240 --> 00:06:03,300
likewise with the underscore query one

00:06:01,350 --> 00:06:05,760
you can do that and then have a portal

00:06:03,300 --> 00:06:07,470
where you can stick in a quoted

00:06:05,760 --> 00:06:11,250
expression underscore query underscore

00:06:07,470 --> 00:06:14,010
colon in quotes put another expression

00:06:11,250 --> 00:06:16,200
which selects a different query parser

00:06:14,010 --> 00:06:17,370
and so you can use that for nested

00:06:16,200 --> 00:06:20,220
queries and we'll talk about that in a

00:06:17,370 --> 00:06:23,610
second as well and the final feature

00:06:20,220 --> 00:06:25,710
that this the solar lucene queries are

00:06:23,610 --> 00:06:28,230
sir has available to it is this

00:06:25,710 --> 00:06:31,230
multi-term analysis when you do queries

00:06:28,230 --> 00:06:33,170
at the leucine level with the leucine

00:06:31,230 --> 00:06:37,200
query parser and so on and you say

00:06:33,170 --> 00:06:40,810
search for capital foo star but when you

00:06:37,200 --> 00:06:44,930
indexed you lower cased everything

00:06:40,810 --> 00:06:46,340
the by default there's no analysis

00:06:44,930 --> 00:06:50,270
there's nothing that happens two

00:06:46,340 --> 00:06:53,450
wild-card expressions you know foo star

00:06:50,270 --> 00:06:55,070
or food ? bar that kind of stuff if

00:06:53,450 --> 00:06:57,890
you've got wildcard expressions in there

00:06:55,070 --> 00:07:02,450
or fuzzy expressions with the tilde in

00:06:57,890 --> 00:07:06,380
there there is no analysis done by

00:07:02,450 --> 00:07:09,740
default and that can be a drag because

00:07:06,380 --> 00:07:11,480
you don't really expect that you when

00:07:09,740 --> 00:07:13,730
you lower case things at index time that

00:07:11,480 --> 00:07:17,660
when you and and you query for all terms

00:07:13,730 --> 00:07:20,510
it will lower case but when you put in

00:07:17,660 --> 00:07:22,910
these regular expression syntax or wild

00:07:20,510 --> 00:07:27,110
card or fuzzy expressions in there it

00:07:22,910 --> 00:07:31,580
doesn't know what to do with those terms

00:07:27,110 --> 00:07:33,020
because how do you stem for example food

00:07:31,580 --> 00:07:35,570
star because you don't know whether they

00:07:33,020 --> 00:07:36,620
were doing what which word they were

00:07:35,570 --> 00:07:38,180
actually doing so you don't know how to

00:07:36,620 --> 00:07:40,100
do stemming on it but there is this

00:07:38,180 --> 00:07:44,870
feature called multi-term analysis where

00:07:40,100 --> 00:07:47,240
four components that are implementing

00:07:44,870 --> 00:07:53,180
the multi term aware component interface

00:07:47,240 --> 00:07:54,950
these terms will let these prefix

00:07:53,180 --> 00:07:56,810
wildcard regular expression all these

00:07:54,950 --> 00:07:59,990
things will run through the multi term

00:07:56,810 --> 00:08:02,030
aware components to lower case and so on

00:07:59,990 --> 00:08:03,230
not stem you wouldn't need to do

00:08:02,030 --> 00:08:04,880
stemming but you at least need to do

00:08:03,230 --> 00:08:07,940
lower casing to do the matching for

00:08:04,880 --> 00:08:09,230
example generally so those are the bells

00:08:07,940 --> 00:08:16,100
and whistles of that leucine query

00:08:09,230 --> 00:08:17,840
parser the next query parser that so the

00:08:16,100 --> 00:08:20,930
leucine quarter this is the default one

00:08:17,840 --> 00:08:23,540
so if you say q equals some expression

00:08:20,930 --> 00:08:25,400
if you don't otherwise override which

00:08:23,540 --> 00:08:27,560
query parts are using this is the one

00:08:25,400 --> 00:08:30,530
you're going to get this is not

00:08:27,560 --> 00:08:32,540
necessarily user-friendly because if

00:08:30,530 --> 00:08:35,800
there's a syntax error in there it

00:08:32,540 --> 00:08:37,790
basically gives a parse exception and

00:08:35,800 --> 00:08:40,250
returns that back to the client and you

00:08:37,790 --> 00:08:44,510
get an error response back from solar if

00:08:40,250 --> 00:08:46,130
your query expression is bogus so you

00:08:44,510 --> 00:08:47,780
need something that's more user friendly

00:08:46,130 --> 00:08:50,270
to be able to take stuff right from your

00:08:47,780 --> 00:08:52,700
search box and pass that right to solar

00:08:50,270 --> 00:08:53,750
and kind of do the right thing and so

00:08:52,700 --> 00:08:56,360
dis max was the

00:08:53,750 --> 00:08:58,940
for that purpose this max allows you to

00:08:56,360 --> 00:09:00,530
do and basically the syntax is very

00:08:58,940 --> 00:09:02,480
simple it's exactly what you see there

00:09:00,530 --> 00:09:05,000
you can do quoted phrases you can do

00:09:02,480 --> 00:09:07,730
plus and minus and you can just do and

00:09:05,000 --> 00:09:09,740
and you can just do loose terms and

00:09:07,730 --> 00:09:11,990
that's it that's all the syntax that you

00:09:09,740 --> 00:09:14,900
can do doesn't do wildcards doesn't do

00:09:11,990 --> 00:09:17,420
any other fancy stuff in there just that

00:09:14,900 --> 00:09:21,260
so it's quite suitable for you know

00:09:17,420 --> 00:09:23,000
basic search boxes and taking that input

00:09:21,260 --> 00:09:26,390
from the user and passing it through to

00:09:23,000 --> 00:09:29,480
solar the one of the main reasons people

00:09:26,390 --> 00:09:31,670
go to this dis max parser is because of

00:09:29,480 --> 00:09:35,360
the second bullet point here is that it

00:09:31,670 --> 00:09:37,880
spreads the query terms across multiple

00:09:35,360 --> 00:09:40,580
fields and allows you to wait different

00:09:37,880 --> 00:09:43,340
fields with different weights so you can

00:09:40,580 --> 00:09:46,700
say for example a very common one is if

00:09:43,340 --> 00:09:48,550
you're indexing just say articles where

00:09:46,700 --> 00:09:51,560
they have a title and a body text

00:09:48,550 --> 00:09:54,070
generally you want query terms that

00:09:51,560 --> 00:09:56,540
match on the title to boost the

00:09:54,070 --> 00:09:58,130
relevance of those documents higher than

00:09:56,540 --> 00:10:00,830
if the the terms that the user search

00:09:58,130 --> 00:10:04,370
for were in the body and so you can say

00:10:00,830 --> 00:10:07,070
title carrot the carrot character five

00:10:04,370 --> 00:10:10,100
and then body carrot 1 which is implicit

00:10:07,070 --> 00:10:11,900
so you want to put the carrot 1 and it

00:10:10,100 --> 00:10:14,060
will do will spread the query terms

00:10:11,900 --> 00:10:16,880
across those fields and and do the

00:10:14,060 --> 00:10:18,710
boosting as you've specified and then

00:10:16,880 --> 00:10:21,170
you can see the dis max actually stands

00:10:18,710 --> 00:10:23,660
for disjunction maximum so it just joins

00:10:21,170 --> 00:10:26,270
the query terms across many fields and

00:10:23,660 --> 00:10:30,530
then the score is the maximum produced

00:10:26,270 --> 00:10:36,320
by all the sub queries and you can play

00:10:30,530 --> 00:10:38,089
games with how much and it or is really

00:10:36,320 --> 00:10:42,110
factored in there it doesn't do and and

00:10:38,089 --> 00:10:44,210
or explicitly but with this mmm

00:10:42,110 --> 00:10:47,960
parameter means minimum match you can

00:10:44,210 --> 00:10:52,970
say if fifty percent of the terms must

00:10:47,960 --> 00:10:54,710
match so it's kind of Ord but still

00:10:52,970 --> 00:10:56,510
fifty percent of those terms must match

00:10:54,710 --> 00:10:58,280
and you can do very elaborate

00:10:56,510 --> 00:11:02,320
expressions where you can say if there's

00:10:58,280 --> 00:11:05,030
less than five terms in the query that

00:11:02,320 --> 00:11:07,320
you know three of them must match if

00:11:05,030 --> 00:11:09,540
there's greater than five

00:11:07,320 --> 00:11:10,890
you know thirty percent must match or

00:11:09,540 --> 00:11:16,920
something like that so you can do a very

00:11:10,890 --> 00:11:18,420
sophisticated expression to say how many

00:11:16,920 --> 00:11:20,640
should match given how many terms there

00:11:18,420 --> 00:11:21,750
are in the query expression itself if

00:11:20,640 --> 00:11:27,450
there's some other things that you can

00:11:21,750 --> 00:11:29,310
do you can do additive boosts with

00:11:27,450 --> 00:11:32,580
boosting query so you can provide an

00:11:29,310 --> 00:11:34,800
additional query that when documents

00:11:32,580 --> 00:11:36,150
matched that it boosts the realms here

00:11:34,800 --> 00:11:39,990
you can also provide a boosting function

00:11:36,150 --> 00:11:42,450
say a function that says boost more

00:11:39,990 --> 00:11:45,810
recent documents higher than older

00:11:42,450 --> 00:11:47,820
documents and it will use what's what an

00:11:45,810 --> 00:11:50,460
additive boost in there and additive is

00:11:47,820 --> 00:11:52,530
I'm calling that out because the next

00:11:50,460 --> 00:11:54,180
great pressure we talk about can do the

00:11:52,530 --> 00:11:55,830
boosting query in the boosting function

00:11:54,180 --> 00:11:58,410
with additive but there's also a way to

00:11:55,830 --> 00:12:03,900
do multiplicative which is often more

00:11:58,410 --> 00:12:05,580
what people want in there so first let

00:12:03,900 --> 00:12:08,190
me I want to back up before we talk

00:12:05,580 --> 00:12:10,920
about that next query parser and show

00:12:08,190 --> 00:12:12,240
you the syntax that it takes to use

00:12:10,920 --> 00:12:13,890
these query parsers so I've showed you

00:12:12,240 --> 00:12:16,170
the to the default on the leucine one

00:12:13,890 --> 00:12:19,140
and the diss Maxwell in which you know

00:12:16,170 --> 00:12:20,820
is very commonly used now you need to

00:12:19,140 --> 00:12:22,490
kind of back up and look at the syntax

00:12:20,820 --> 00:12:25,830
that it takes to spell these things out

00:12:22,490 --> 00:12:27,900
there is a parameter that you can define

00:12:25,830 --> 00:12:30,630
you can do this in your request handler

00:12:27,900 --> 00:12:33,660
definition in solar config or you can do

00:12:30,630 --> 00:12:35,880
it as a parameter on the request URL

00:12:33,660 --> 00:12:38,580
that you're sending into solar and you

00:12:35,880 --> 00:12:40,230
specified f-type means default query

00:12:38,580 --> 00:12:41,640
parser type I don't know why we made it

00:12:40,230 --> 00:12:43,920
such a silly name when it started its

00:12:41,640 --> 00:12:47,280
call it you know query parser but it's

00:12:43,920 --> 00:12:50,400
called def type so that's one way that

00:12:47,280 --> 00:12:52,230
you can specify the query parser often

00:12:50,400 --> 00:12:53,790
you'll you know spell that out in your

00:12:52,230 --> 00:12:58,410
solar config in your request handler

00:12:53,790 --> 00:13:02,100
definitions the next syntax that you can

00:12:58,410 --> 00:13:05,010
use is this curly bracket bang ! syntax

00:13:02,100 --> 00:13:06,900
where you say the parser name and then

00:13:05,010 --> 00:13:09,510
you can specify local parameters and

00:13:06,900 --> 00:13:11,400
then after the closing curly bracket you

00:13:09,510 --> 00:13:12,300
put the expression and there's different

00:13:11,400 --> 00:13:14,160
ways that you can do you don't actually

00:13:12,300 --> 00:13:15,660
the expression can be nested as one of

00:13:14,160 --> 00:13:17,880
the parameters as well like this bottom

00:13:15,660 --> 00:13:18,590
example but all of those expressions

00:13:17,880 --> 00:13:23,120
there are

00:13:18,590 --> 00:13:25,660
equivalent q equals Apache con na 2013

00:13:23,120 --> 00:13:29,420
and then I'm setting def type to dis max

00:13:25,660 --> 00:13:31,550
minimum match 22 and the query fields is

00:13:29,420 --> 00:13:32,570
set to the name field and I can spend

00:13:31,550 --> 00:13:35,960
this is where I'd specify multiple

00:13:32,570 --> 00:13:38,900
fields if I wanted to have boosting

00:13:35,960 --> 00:13:43,850
across different fields and this next

00:13:38,900 --> 00:13:45,770
one simply puts the specification of the

00:13:43,850 --> 00:13:48,980
query parser itself inside this curly

00:13:45,770 --> 00:13:50,480
bracket bang syntax all together that

00:13:48,980 --> 00:13:53,360
way instead of separate parameters and

00:13:50,480 --> 00:13:55,070
then the final example here use it

00:13:53,360 --> 00:13:57,110
instead of the query expression living

00:13:55,070 --> 00:14:02,660
outside of the curly brackets it's now

00:13:57,110 --> 00:14:04,430
the V parameter that's in there okay so

00:14:02,660 --> 00:14:06,140
that's that's how you spell out query

00:14:04,430 --> 00:14:08,510
parsers different ways to do this stuff

00:14:06,140 --> 00:14:10,370
so maybe slightly confusing and we'll

00:14:08,510 --> 00:14:14,450
see you know many examples down the line

00:14:10,370 --> 00:14:17,360
here the next feature of solar query

00:14:14,450 --> 00:14:19,430
parsing is what's called local parameter

00:14:17,360 --> 00:14:23,360
substitution this is the ability to

00:14:19,430 --> 00:14:26,480
dereference a separate parameter and

00:14:23,360 --> 00:14:30,620
inject that into one of these main

00:14:26,480 --> 00:14:32,120
parameters I'm showing this example in a

00:14:30,620 --> 00:14:35,720
more realistic way where you would

00:14:32,120 --> 00:14:37,490
define basically the query that is

00:14:35,720 --> 00:14:41,960
parameterised with these local parameter

00:14:37,490 --> 00:14:43,430
substitutions in a solar config set up

00:14:41,960 --> 00:14:47,450
this way so I'm defining a request

00:14:43,430 --> 00:14:50,540
handler and I've defined it a slash

00:14:47,450 --> 00:14:51,620
document the idea here is that I want to

00:14:50,540 --> 00:14:54,650
be able to have one request handler

00:14:51,620 --> 00:14:57,760
record to say / document ? ID equals and

00:14:54,650 --> 00:15:02,720
then a unique ID of the document itself

00:14:57,760 --> 00:15:07,190
now you know in you could simply say you

00:15:02,720 --> 00:15:10,760
know / select Q equals ID colon and then

00:15:07,190 --> 00:15:14,720
the ID you could do that doesn't look as

00:15:10,760 --> 00:15:18,410
clean in your logs if you have special

00:15:14,720 --> 00:15:20,960
characters in your ID Colin's for

00:15:18,410 --> 00:15:23,030
example ID colon something colon

00:15:20,960 --> 00:15:26,630
something else doesn't really work well

00:15:23,030 --> 00:15:28,640
the parser is going to be mad at you for

00:15:26,630 --> 00:15:30,290
that that you can backslash escape these

00:15:28,640 --> 00:15:31,640
special characters and so on so there's

00:15:30,290 --> 00:15:32,180
a lot of kind of special ways you can do

00:15:31,640 --> 00:15:34,310
this

00:15:32,180 --> 00:15:36,589
this is just a neat trick here where I

00:15:34,310 --> 00:15:40,010
can say I'm going to use the term query

00:15:36,589 --> 00:15:42,920
parser on the field i D F equals ID and

00:15:40,010 --> 00:15:45,589
then i'm going to substitute in dollar

00:15:42,920 --> 00:15:47,600
sign ID so that takes the request

00:15:45,589 --> 00:15:50,120
parameter ID and injects it into the

00:15:47,600 --> 00:15:52,399
value of the term query parser there so

00:15:50,120 --> 00:15:53,899
it at the lucene level if it familiar

00:15:52,399 --> 00:15:57,410
with that it's simply doing a term query

00:15:53,899 --> 00:15:58,790
for ID and a value and so that's how

00:15:57,410 --> 00:16:00,500
that works and I just spelled out some

00:15:58,790 --> 00:16:02,060
extra components in here because you

00:16:00,500 --> 00:16:04,940
might want to do highlighting for

00:16:02,060 --> 00:16:08,390
example where you could say ID equals 13

00:16:04,940 --> 00:16:10,339
and then you can say HL Q equals and

00:16:08,390 --> 00:16:11,959
then give it a query and it will

00:16:10,339 --> 00:16:13,640
highlight the query terms in the

00:16:11,959 --> 00:16:15,910
document that gets returned as well so

00:16:13,640 --> 00:16:18,920
just kind of a neat little bonus there

00:16:15,910 --> 00:16:20,740
and I'm leveraging the trick with

00:16:18,920 --> 00:16:23,330
request handler definitions here to

00:16:20,740 --> 00:16:26,870
spell out invariants meaning that

00:16:23,330 --> 00:16:29,060
there's no way that a that the request

00:16:26,870 --> 00:16:31,130
coming into solar can override what the

00:16:29,060 --> 00:16:33,470
Q parameter is or the Rose you will

00:16:31,130 --> 00:16:37,760
always only get one or zero documents

00:16:33,470 --> 00:16:42,470
back from that query but so that's local

00:16:37,760 --> 00:16:45,709
parameter substitution next up is nested

00:16:42,470 --> 00:16:48,020
query parsing this is leveraging that

00:16:45,709 --> 00:16:52,820
underscore query underscore trick that's

00:16:48,020 --> 00:16:55,790
in the leucine query parser allowing you

00:16:52,820 --> 00:16:59,150
to have basically a backdoor to parse a

00:16:55,790 --> 00:17:00,950
different expression with a different

00:16:59,150 --> 00:17:02,839
query parser and then you can and and or

00:17:00,950 --> 00:17:10,850
those things together using leucine

00:17:02,839 --> 00:17:13,370
syntax and I again since solar for dot X

00:17:10,850 --> 00:17:15,890
I think that underscore query thing is

00:17:13,370 --> 00:17:21,199
not necessary anymore you can just spell

00:17:15,890 --> 00:17:23,449
out the the curly bracket stuff and so

00:17:21,199 --> 00:17:26,750
this is an example where we are taking

00:17:23,449 --> 00:17:29,179
say an advanced search where we have two

00:17:26,750 --> 00:17:32,330
different boxes that people are putting

00:17:29,179 --> 00:17:34,150
in here I have user query and topic it

00:17:32,330 --> 00:17:37,790
could be you know keywords and author

00:17:34,150 --> 00:17:39,890
and you're spreading using a dis max on

00:17:37,790 --> 00:17:42,200
one field and in a dis max on another

00:17:39,890 --> 00:17:43,940
field or a set of fields and a set of

00:17:42,200 --> 00:17:45,230
fields and then adding those things and

00:17:43,940 --> 00:17:45,779
having different boosts for each one of

00:17:45,230 --> 00:17:48,379
those

00:17:45,779 --> 00:17:51,979
Russians there so you can really do some

00:17:48,379 --> 00:17:58,409
crazy advanced search type stuff there

00:17:51,979 --> 00:17:59,999
stanford university is buddies with a

00:17:58,409 --> 00:18:01,529
lot of people that work there they've

00:17:59,999 --> 00:18:03,059
done some very interesting things on

00:18:01,529 --> 00:18:04,889
their advanced search page for their

00:18:03,059 --> 00:18:08,729
library search where they've got many

00:18:04,889 --> 00:18:12,210
many boxes there where you can put in

00:18:08,729 --> 00:18:15,029
refined searches and they use this dis

00:18:12,210 --> 00:18:16,739
max nested query thing because they have

00:18:15,029 --> 00:18:18,989
if you're familiar with library data

00:18:16,739 --> 00:18:20,759
books can have you know it's not just a

00:18:18,989 --> 00:18:22,979
title of a book books can have a title a

00:18:20,759 --> 00:18:25,859
subtitle an alternate title they can

00:18:22,979 --> 00:18:27,629
have a main author secondary author and

00:18:25,859 --> 00:18:30,419
so on many fields for each one of those

00:18:27,629 --> 00:18:32,249
boxes so when you type something into

00:18:30,419 --> 00:18:41,099
the author box it's actually spreading

00:18:32,249 --> 00:18:43,549
it across many other fields okay so next

00:18:41,099 --> 00:18:46,769
up is this EDA smacks extended dis max

00:18:43,549 --> 00:18:50,099
extended this max is dis max plus

00:18:46,769 --> 00:18:53,549
leucine syntax so many people now are

00:18:50,099 --> 00:18:55,830
using this as their main query parser

00:18:53,549 --> 00:18:59,969
because it allows for wildcard

00:18:55,830 --> 00:19:01,649
expressions ands and ORS and fuzzy

00:18:59,969 --> 00:19:04,080
queries and and all that kind of stuff

00:19:01,649 --> 00:19:05,369
but you also benefit from the dis max

00:19:04,080 --> 00:19:06,960
capabilities they're being able to

00:19:05,369 --> 00:19:09,330
specify many fields and spreading the

00:19:06,960 --> 00:19:11,099
terms across many fields if you're not

00:19:09,330 --> 00:19:13,979
using fielded syntax and so on in there

00:19:11,099 --> 00:19:16,909
so it's it's a pretty nice parser here

00:19:13,979 --> 00:19:18,779
it's got several other additional

00:19:16,909 --> 00:19:22,499
capabilities that the dis max doesn't

00:19:18,779 --> 00:19:23,999
have being able to limit which fields

00:19:22,499 --> 00:19:26,309
can be searched maybe you have a cost

00:19:23,999 --> 00:19:27,960
field where you wouldn't want the end

00:19:26,309 --> 00:19:31,950
user to be able to search on the cost

00:19:27,960 --> 00:19:36,769
field for example and so on and you can

00:19:31,950 --> 00:19:40,799
do the shingling stuff to improve

00:19:36,769 --> 00:19:45,119
relevancy when multiple terms match a

00:19:40,799 --> 00:19:46,710
particular field and so on so and

00:19:45,119 --> 00:19:49,739
there's some stop word magic that's in

00:19:46,710 --> 00:19:53,190
there when it makes phrase queries that

00:19:49,739 --> 00:19:55,799
can remove stop words from that it's got

00:19:53,190 --> 00:19:58,379
a boost parameter which is on top of it

00:19:55,799 --> 00:19:58,990
also supports BF and BQ the boost

00:19:58,379 --> 00:20:01,750
function abuse

00:19:58,990 --> 00:20:03,900
query parameters that just max has but

00:20:01,750 --> 00:20:09,070
it's got the multiplicative boost

00:20:03,900 --> 00:20:10,960
parameter as well and you know just a

00:20:09,070 --> 00:20:15,640
bunch of other kind of parameters that

00:20:10,960 --> 00:20:17,260
are there to refine this stuff and in

00:20:15,640 --> 00:20:18,550
fact I've seen some commits lately where

00:20:17,260 --> 00:20:20,650
it fixed there's some odd issues in

00:20:18,550 --> 00:20:23,230
there this we're trailing minus sign

00:20:20,650 --> 00:20:25,330
caused errors and so on because it

00:20:23,230 --> 00:20:26,670
thinks that's special syntax so some

00:20:25,330 --> 00:20:31,390
things have been fixed in this as

00:20:26,670 --> 00:20:36,850
recently as yesterday so pretty fancy

00:20:31,390 --> 00:20:38,710
query parser there just kind of going

00:20:36,850 --> 00:20:41,050
through all of the other query parsers

00:20:38,710 --> 00:20:45,700
that are there this term query parser is

00:20:41,050 --> 00:20:50,470
a useful one in that it allows you to

00:20:45,700 --> 00:20:52,750
specify an exact term for a field and

00:20:50,470 --> 00:20:54,640
not have to worry about all of this

00:20:52,750 --> 00:20:57,250
other even though this is a query parser

00:20:54,640 --> 00:21:00,190
itself it's kind of lightweight in that

00:20:57,250 --> 00:21:04,270
all the Q parser does is generate a

00:21:00,190 --> 00:21:06,370
leucine query object you don't need to

00:21:04,270 --> 00:21:09,190
do any fancy escaping if you're using

00:21:06,370 --> 00:21:10,690
leucine query syntax and you're trying

00:21:09,190 --> 00:21:14,860
to do a query like this where you said

00:21:10,690 --> 00:21:17,679
you know q equals facet underscore field

00:21:14,860 --> 00:21:19,750
colon and then that crazy value there

00:21:17,679 --> 00:21:23,290
with a colon and a smiley face and so on

00:21:19,750 --> 00:21:26,679
in there you would have to back slash

00:21:23,290 --> 00:21:28,660
escape the colon and both of those

00:21:26,679 --> 00:21:30,820
colons and sand and and may be

00:21:28,660 --> 00:21:32,590
surrounded by quotes to get that thing

00:21:30,820 --> 00:21:35,460
to work because the query parser you

00:21:32,590 --> 00:21:37,420
know splits at white space and so on so

00:21:35,460 --> 00:21:40,650
the nice thing about this term quick

00:21:37,420 --> 00:21:43,030
parser is it eliminates all of that

00:21:40,650 --> 00:21:48,100
escaping nastiness that you have to deal

00:21:43,030 --> 00:21:52,120
with and just uses basically a raw term

00:21:48,100 --> 00:21:56,530
query at the at the very final parsing

00:21:52,120 --> 00:21:59,530
step here okay so term query again

00:21:56,530 --> 00:22:04,320
useful we saw that in the local

00:21:59,530 --> 00:22:04,320
parameter substitution slide a few back

00:22:04,710 --> 00:22:13,420
there's also a prefix query parser the

00:22:08,230 --> 00:22:15,310
prefix query parser simply basically

00:22:13,420 --> 00:22:18,430
adds a star at the end of the query and

00:22:15,310 --> 00:22:22,950
makes it into a what's called a prefix

00:22:18,430 --> 00:22:25,420
query as far as leucine is concerned I

00:22:22,950 --> 00:22:27,880
don't really have a use case where this

00:22:25,420 --> 00:22:29,470
would be handy per se versus just using

00:22:27,880 --> 00:22:31,990
you know standard leucine query syntax

00:22:29,470 --> 00:22:34,540
for this and there is a note there that

00:22:31,990 --> 00:22:36,790
it doesn't do the multi term stuff so if

00:22:34,540 --> 00:22:39,610
you did lowercase at index time and then

00:22:36,790 --> 00:22:42,210
you did a capital foo therefore the

00:22:39,610 --> 00:22:48,670
prefix value it wouldn't lower case

00:22:42,210 --> 00:22:50,800
there so kind of an issue there's a

00:22:48,670 --> 00:22:54,070
boost query parser the boost query

00:22:50,800 --> 00:22:56,830
parser is multiplicative to the score of

00:22:54,070 --> 00:22:59,020
the nested query that you're using and

00:22:56,830 --> 00:23:02,290
you can use any query parser that you

00:22:59,020 --> 00:23:05,080
want for that nested query and so you

00:23:02,290 --> 00:23:07,450
simply just say boost quarry parser B

00:23:05,080 --> 00:23:10,360
equals and a function query and that's

00:23:07,450 --> 00:23:14,320
it and then give it a nested query the e

00:23:10,360 --> 00:23:16,450
disse max boost parameter if that's

00:23:14,320 --> 00:23:18,940
specified basically this it uses this

00:23:16,450 --> 00:23:21,820
query parser on the covers and wraps the

00:23:18,940 --> 00:23:27,520
main query so this one's this one's

00:23:21,820 --> 00:23:35,410
quite handy there is a field query

00:23:27,520 --> 00:23:37,810
parser this one does feel type awareness

00:23:35,410 --> 00:23:44,410
in that it will again run through the

00:23:37,810 --> 00:23:46,930
analysis if that's a text field and it

00:23:44,410 --> 00:23:48,670
will basically look at the schema and

00:23:46,930 --> 00:23:52,630
figure out what the field type is and

00:23:48,670 --> 00:23:54,910
come up with a query for the expression

00:23:52,630 --> 00:23:56,740
that you had based on the field type and

00:23:54,910 --> 00:23:59,320
you can see there's a number of cases

00:23:56,740 --> 00:24:01,450
here if it's a text field which type of

00:23:59,320 --> 00:24:03,160
query does it actually generate under

00:24:01,450 --> 00:24:04,960
the covers and it really depends on how

00:24:03,160 --> 00:24:08,080
many tokens come out of the analysis

00:24:04,960 --> 00:24:10,210
process and what positions those things

00:24:08,080 --> 00:24:12,280
are in in order to figure out the right

00:24:10,210 --> 00:24:13,870
query to leverage there and you can see

00:24:12,280 --> 00:24:16,240
there's also some special handling for

00:24:13,870 --> 00:24:18,820
certain field types there if you

00:24:16,240 --> 00:24:22,270
have a location field type a lat long

00:24:18,820 --> 00:24:23,590
maybe you can just simply specify that

00:24:22,270 --> 00:24:26,860
and it will create the right type of

00:24:23,590 --> 00:24:28,390
query under the covers for that so again

00:24:26,860 --> 00:24:35,760
this was this was a this is a handy one

00:24:28,390 --> 00:24:39,960
as well there's a surround query parser

00:24:35,760 --> 00:24:43,960
this came in 40 it's not in the 3x

00:24:39,960 --> 00:24:46,900
versions this is kind of a niche one

00:24:43,960 --> 00:24:49,300
although the ultimate idea of this one

00:24:46,900 --> 00:24:53,860
needs to really come out in other ways

00:24:49,300 --> 00:24:56,890
but this generates what's called span

00:24:53,860 --> 00:25:00,700
queries at the lucene level a span query

00:24:56,890 --> 00:25:02,290
is a proximity query that can do more

00:25:00,700 --> 00:25:04,450
sophisticated things than say a phrase

00:25:02,290 --> 00:25:07,600
query or phrase query will match you

00:25:04,450 --> 00:25:09,429
know term beside term within distance

00:25:07,600 --> 00:25:13,929
maybe order doesn't matter of those

00:25:09,429 --> 00:25:17,500
terms whereas a span query can take do

00:25:13,929 --> 00:25:20,320
that but also say this phrase must be

00:25:17,500 --> 00:25:24,090
within 10 words of this other phrase and

00:25:20,320 --> 00:25:26,800
this other term can't be in the middle

00:25:24,090 --> 00:25:29,230
for example maybe you have special some

00:25:26,800 --> 00:25:30,910
people use special terms that are end of

00:25:29,230 --> 00:25:33,040
sentence boundaries or into paragraph

00:25:30,910 --> 00:25:36,670
boundaries and you want to match this

00:25:33,040 --> 00:25:38,410
phrase near this other phrase where

00:25:36,670 --> 00:25:40,840
there can't be a paragraph break in the

00:25:38,410 --> 00:25:43,120
middle so you know that would require

00:25:40,840 --> 00:25:44,440
special analysis in there to put those

00:25:43,120 --> 00:25:46,270
extra tokens in there but that's the

00:25:44,440 --> 00:25:48,309
kind of thing people have done with

00:25:46,270 --> 00:25:53,860
these span queries very sophisticated

00:25:48,309 --> 00:25:56,110
proximity operations the surround query

00:25:53,860 --> 00:26:00,280
parser has its own kind of funky syntax

00:25:56,110 --> 00:26:03,400
where it's got this these operators in

00:26:00,280 --> 00:26:04,809
and W and so you can do the query

00:26:03,400 --> 00:26:06,610
expressions like this bottom one here

00:26:04,809 --> 00:26:09,850
where I'm saying a patch and star so it

00:26:06,610 --> 00:26:14,410
does wild cards as well and within four

00:26:09,850 --> 00:26:16,630
words of the word Portland and you can

00:26:14,410 --> 00:26:22,809
do ordered or unordered and so on it

00:26:16,630 --> 00:26:25,120
does wildcards fuzzy regular expressions

00:26:22,809 --> 00:26:28,120
and so on so it's quite rich that way

00:26:25,120 --> 00:26:29,299
now there is one important note here

00:26:28,120 --> 00:26:32,049
about the surround quarry part

00:26:29,299 --> 00:26:35,570
it does not do an ounce so it is not

00:26:32,049 --> 00:26:37,399
fieldtype aware if you are lower casing

00:26:35,570 --> 00:26:39,980
when you index the query that you send

00:26:37,399 --> 00:26:41,960
in needs to be lower cased so again

00:26:39,980 --> 00:26:45,889
quite niche but if you need to do

00:26:41,960 --> 00:26:48,559
sophisticated matching with proximity

00:26:45,889 --> 00:26:51,350
this is the one for you here and the

00:26:48,559 --> 00:26:52,909
fact that it does wildcards actually

00:26:51,350 --> 00:26:54,350
makes that analysis stuff and that's

00:26:52,909 --> 00:26:55,970
this was the reason that it wasn't

00:26:54,350 --> 00:26:57,830
really built from the ground up to be

00:26:55,970 --> 00:27:01,029
filled type of where's the use case is a

00:26:57,830 --> 00:27:03,679
lot of people are doing often just doing

00:27:01,029 --> 00:27:05,779
kind of prefix queries wildcard queries

00:27:03,679 --> 00:27:07,159
so you don't need to do stemming and all

00:27:05,779 --> 00:27:10,039
that if you just search for food star

00:27:07,159 --> 00:27:13,330
near these other things as long as

00:27:10,039 --> 00:27:13,330
you're using these wild cards on there

00:27:14,109 --> 00:27:23,659
there's a joint query parser the join

00:27:17,179 --> 00:27:26,869
query parser is not quite a sequel join

00:27:23,659 --> 00:27:31,609
but does allow you to connect the dots

00:27:26,869 --> 00:27:34,309
between one type of document or even the

00:27:31,609 --> 00:27:36,710
same type of document to another set of

00:27:34,309 --> 00:27:38,749
documents by having an inner expression

00:27:36,710 --> 00:27:41,239
that basically comes up with a list of

00:27:38,749 --> 00:27:43,070
terms or a list of ID's and then that

00:27:41,239 --> 00:27:48,919
list of ID's that match that inner one

00:27:43,070 --> 00:27:52,779
is then used to filter on the outer join

00:27:48,919 --> 00:27:56,929
query basically there you can join

00:27:52,779 --> 00:28:00,499
across documents in the same index so

00:27:56,929 --> 00:28:04,149
you could index different types of

00:28:00,499 --> 00:28:06,889
documents in the same solar core and

00:28:04,149 --> 00:28:09,799
join across them and you could have it

00:28:06,889 --> 00:28:12,200
you know say a document type field that

00:28:09,799 --> 00:28:13,909
distinguishes which type there are and

00:28:12,200 --> 00:28:16,399
you could kind of have a primary key

00:28:13,909 --> 00:28:20,539
foreign key relationship in there you

00:28:16,399 --> 00:28:22,220
can also do joins across solar cores the

00:28:20,539 --> 00:28:24,379
cores have to the constraint here is the

00:28:22,220 --> 00:28:29,929
Coors have to be on the same solar

00:28:24,379 --> 00:28:32,299
instance they can't be remote but that

00:28:29,929 --> 00:28:34,039
actually adds some very interesting

00:28:32,299 --> 00:28:36,190
power to be able to join across cores

00:28:34,039 --> 00:28:39,350
and that you could have one core that is

00:28:36,190 --> 00:28:41,119
documents another core is maybe security

00:28:39,350 --> 00:28:42,540
information about those documents who

00:28:41,119 --> 00:28:46,650
can access those documents

00:28:42,540 --> 00:28:48,930
the access information turns more and is

00:28:46,650 --> 00:28:51,240
smaller than the corpus of the full-text

00:28:48,930 --> 00:28:54,240
documents that you're searching and so

00:28:51,240 --> 00:28:56,160
you can commit change and do all the

00:28:54,240 --> 00:28:58,170
stuff quicker on on a small on a

00:28:56,160 --> 00:29:01,590
separate core that's of just security

00:28:58,170 --> 00:29:04,800
information and then join across them if

00:29:01,590 --> 00:29:06,230
when needed for example and and yannick

00:29:04,800 --> 00:29:08,670
the Creator solar actually has done some

00:29:06,230 --> 00:29:14,520
good presentations about this there's a

00:29:08,670 --> 00:29:16,260
pointer there to some n stuff there's a

00:29:14,520 --> 00:29:18,620
number of spatial query parsers being

00:29:16,260 --> 00:29:23,820
able to do Geo hash lat long point type

00:29:18,620 --> 00:29:28,020
querying where you can filter on exact

00:29:23,820 --> 00:29:32,850
distance you can do bounding box and

00:29:28,020 --> 00:29:34,350
radial type searches there and range

00:29:32,850 --> 00:29:36,150
queries you can see the range query

00:29:34,350 --> 00:29:38,400
syntax here where you're doing lat long

00:29:36,150 --> 00:29:41,760
to lat long basically coming up with a

00:29:38,400 --> 00:29:44,670
bounding box for geo queries and so on

00:29:41,760 --> 00:29:48,090
so there's some pretty cool geo

00:29:44,670 --> 00:29:51,450
capabilities in there and I'm down here

00:29:48,090 --> 00:29:54,140
just in conjunction with the geo queries

00:29:51,450 --> 00:29:57,240
often people want to sort by distance

00:29:54,140 --> 00:29:59,940
which you could sort by a function query

00:29:57,240 --> 00:30:02,970
here or you may want to return that

00:29:59,940 --> 00:30:04,830
distance in the results and this is a

00:30:02,970 --> 00:30:07,200
new feature and solar for being able to

00:30:04,830 --> 00:30:09,270
do the pseudo fields basically here

00:30:07,200 --> 00:30:12,510
where I say underscore dist underscore

00:30:09,270 --> 00:30:14,430
colon geo dist and so I get a field back

00:30:12,510 --> 00:30:16,650
in my document response that has the

00:30:14,430 --> 00:30:24,210
distance computed and put into each

00:30:16,650 --> 00:30:28,590
documents response basically there's a

00:30:24,210 --> 00:30:31,380
function range query this one's a pretty

00:30:28,590 --> 00:30:32,910
a pretty powerful one we'll see a little

00:30:31,380 --> 00:30:38,040
bit more about this one in a second when

00:30:32,910 --> 00:30:39,060
we talk about post filtering so you know

00:30:38,040 --> 00:30:40,080
just depending on what you need to do

00:30:39,060 --> 00:30:46,350
there but you get the idea with

00:30:40,080 --> 00:30:48,060
functions there and this is one of the

00:30:46,350 --> 00:30:50,070
final query parsers we're talking about

00:30:48,060 --> 00:30:54,420
maybe the final line this is the

00:30:50,070 --> 00:30:55,470
brand-new switch query parser it's a

00:30:54,420 --> 00:30:57,840
little bit

00:30:55,470 --> 00:31:02,400
I'm judgment still out for me on this

00:30:57,840 --> 00:31:03,750
one whether I like it or not but what

00:31:02,400 --> 00:31:07,140
you see is what you get here basically

00:31:03,750 --> 00:31:10,140
you can do a switch query parser and you

00:31:07,140 --> 00:31:12,230
can provide a parameter that fills in

00:31:10,140 --> 00:31:15,539
where it says v equals dollar in stock

00:31:12,230 --> 00:31:18,240
you can imagine this top portion that fq

00:31:15,539 --> 00:31:20,159
portion being embedded in your solar

00:31:18,240 --> 00:31:22,490
config so you've got this filter query

00:31:20,159 --> 00:31:25,140
already there it's parameterised and

00:31:22,490 --> 00:31:28,260
from your client all you need to do is

00:31:25,140 --> 00:31:30,330
send in the value to fill in the blanks

00:31:28,260 --> 00:31:33,150
for that switch and when you say in

00:31:30,330 --> 00:31:36,390
stock equals yes here then it picks the

00:31:33,150 --> 00:31:37,980
yes option out of this case and uses the

00:31:36,390 --> 00:31:40,320
filter in stock colon true which is a

00:31:37,980 --> 00:31:45,659
leucine query parser sent axed query

00:31:40,320 --> 00:31:48,330
there this one's not so this example

00:31:45,659 --> 00:31:50,370
here is more like that / document one

00:31:48,330 --> 00:31:51,600
that I provided where it's it's fairly

00:31:50,370 --> 00:31:52,770
straightforward in fact this one's even

00:31:51,600 --> 00:31:56,610
more straightforward where I could use

00:31:52,770 --> 00:31:58,890
that term query one and simply pass in

00:31:56,610 --> 00:32:01,890
true or false and have it substituted

00:31:58,890 --> 00:32:05,900
into query like we saw before but you

00:32:01,890 --> 00:32:10,700
could imagine having one that says case

00:32:05,900 --> 00:32:13,049
yesterday case today case forever and

00:32:10,700 --> 00:32:15,299
you pass in you know you just want

00:32:13,049 --> 00:32:18,110
documents from yesterday and it uses a

00:32:15,299 --> 00:32:21,750
date math expression for case yesterday

00:32:18,110 --> 00:32:27,140
that you know narrows down to now minus

00:32:21,750 --> 00:32:29,010
one day 22 now basically and so on so

00:32:27,140 --> 00:32:32,429
there's some interesting things that you

00:32:29,010 --> 00:32:36,450
could do there that aren't so kind of

00:32:32,429 --> 00:32:39,090
silly examples like that this just got

00:32:36,450 --> 00:32:40,890
committed like two days ago so this is

00:32:39,090 --> 00:32:47,370
going to this is on the forex branch it

00:32:40,890 --> 00:32:52,890
will be in for two not in for one post

00:32:47,370 --> 00:32:57,419
filter this is a way to implement an

00:32:52,890 --> 00:33:01,799
interface on a query object a queer

00:32:57,419 --> 00:33:05,039
class and what happens at the end of

00:33:01,799 --> 00:33:06,990
doing the query filtering and the the

00:33:05,039 --> 00:33:08,160
filtering of getting the document result

00:33:06,990 --> 00:33:09,990
set from the queue

00:33:08,160 --> 00:33:12,600
and the fq parameters the query and the

00:33:09,990 --> 00:33:15,330
filter query parameters there's one more

00:33:12,600 --> 00:33:18,510
pass that can go through to eliminate

00:33:15,330 --> 00:33:20,430
documents from the result and this is

00:33:18,510 --> 00:33:22,140
called the post filter the reason you

00:33:20,430 --> 00:33:24,870
need this post filtering thing is that

00:33:22,140 --> 00:33:27,210
you may have filters that are very

00:33:24,870 --> 00:33:29,150
expensive to compute so you want to

00:33:27,210 --> 00:33:32,070
compute those on the most minimal

00:33:29,150 --> 00:33:34,530
document set possible if you are doing

00:33:32,070 --> 00:33:37,230
for examples ACL filtering and you want

00:33:34,530 --> 00:33:41,420
to say only give me documents that I

00:33:37,230 --> 00:33:46,200
have permission to see if I have to

00:33:41,420 --> 00:33:48,630
compute for every document in my billion

00:33:46,200 --> 00:33:53,040
document index all of the documents that

00:33:48,630 --> 00:33:55,350
i can see first you know then I'm doing

00:33:53,040 --> 00:34:00,270
a billion computations of access control

00:33:55,350 --> 00:34:01,860
list whereas with post filtering it's

00:34:00,270 --> 00:34:04,320
only going to narrow down to all the

00:34:01,860 --> 00:34:06,270
documents that for that main result set

00:34:04,320 --> 00:34:07,830
there's a couple of really nice blog

00:34:06,270 --> 00:34:09,120
entries there well was really nice the

00:34:07,830 --> 00:34:12,270
other one I wrote but actually both of

00:34:09,120 --> 00:34:14,370
them are very useful there about how

00:34:12,270 --> 00:34:15,900
this post filter stuff works so good

00:34:14,370 --> 00:34:18,510
stuff there there are a couple of a few

00:34:15,900 --> 00:34:20,730
built-in queries that that do this

00:34:18,510 --> 00:34:23,070
automatically but if you're going to do

00:34:20,730 --> 00:34:25,020
like security stuff I wrote this last

00:34:23,070 --> 00:34:27,300
blog entry there you have to write

00:34:25,020 --> 00:34:29,700
custom custom code and then write your

00:34:27,300 --> 00:34:38,940
own q parser plug-in and then it plugs

00:34:29,700 --> 00:34:41,280
right into solar this way more on query

00:34:38,940 --> 00:34:43,560
parsing here this is more kind of a best

00:34:41,280 --> 00:34:45,690
practice or a way to use these things if

00:34:43,560 --> 00:34:49,860
you're going to do fuzzier type matching

00:34:45,690 --> 00:34:55,890
where you need phonetics stemming or

00:34:49,860 --> 00:34:57,570
synonym injection you can do this in

00:34:55,890 --> 00:35:00,540
different ways and one of the techniques

00:34:57,570 --> 00:35:03,120
that people have often used is to come

00:35:00,540 --> 00:35:06,120
up with parallel fields you copy field

00:35:03,120 --> 00:35:08,310
this is a schema directive copy field

00:35:06,120 --> 00:35:10,320
say in this example name to name

00:35:08,310 --> 00:35:12,900
underscore phonetic where the name field

00:35:10,320 --> 00:35:14,880
is simply you know basically analyzed in

00:35:12,900 --> 00:35:17,130
the name phonetic field has a phonetic

00:35:14,880 --> 00:35:20,070
filter built into it and then you can

00:35:17,130 --> 00:35:21,230
you know boost documents that are exact

00:35:20,070 --> 00:35:23,480
matches to the user's query

00:35:21,230 --> 00:35:26,000
over ones that are you know are

00:35:23,480 --> 00:35:27,619
phonetically similar so you can put

00:35:26,000 --> 00:35:28,850
these types of boosting expressions in

00:35:27,619 --> 00:35:31,280
there so it's just using the dis max

00:35:28,850 --> 00:35:32,900
query parser here and spreading across

00:35:31,280 --> 00:35:36,520
different fields so this is really just

00:35:32,900 --> 00:35:39,890
a technique for using query parsers to

00:35:36,520 --> 00:35:45,800
you know boost across exact and exact

00:35:39,890 --> 00:35:48,680
matches another technique I wanted to

00:35:45,800 --> 00:35:50,660
talk about here is when we're doing

00:35:48,680 --> 00:35:52,640
suggest interfaces you know this is the

00:35:50,660 --> 00:35:54,800
query box the modern query box where

00:35:52,640 --> 00:35:58,730
you're typing in and suggestions are

00:35:54,800 --> 00:36:01,340
popping up as you're typing there's ways

00:35:58,730 --> 00:36:03,080
in lucene and solar to do this suggests

00:36:01,340 --> 00:36:06,500
right from the main index where you can

00:36:03,080 --> 00:36:09,200
suggest terms from your full text fields

00:36:06,500 --> 00:36:11,210
and and see those terms and there's

00:36:09,200 --> 00:36:14,390
techniques to have a light analysis that

00:36:11,210 --> 00:36:17,300
you're not suggesting stems or or other

00:36:14,390 --> 00:36:23,300
funky types of things that happen during

00:36:17,300 --> 00:36:24,619
an analysis process but let's flip it

00:36:23,300 --> 00:36:29,420
around a little bit rather than trying

00:36:24,619 --> 00:36:30,950
to do suggestions from one index where

00:36:29,420 --> 00:36:33,350
it's a little bit of an awkward fit

00:36:30,950 --> 00:36:35,390
let's talk about doing suggestions think

00:36:33,350 --> 00:36:37,940
about doing suggestions from a separate

00:36:35,390 --> 00:36:39,109
index and the example here is and I've

00:36:37,940 --> 00:36:40,820
worked with a customer that had this

00:36:39,109 --> 00:36:43,880
exact use case here where they're

00:36:40,820 --> 00:36:45,290
selling automobile parts and they need

00:36:43,880 --> 00:36:48,100
to have that suggest in there so as

00:36:45,290 --> 00:36:51,740
you're typing it's suggesting vehicles

00:36:48,100 --> 00:36:53,180
1987 chevrolet corvette and it needs to

00:36:51,740 --> 00:36:57,770
pick the right one as you're typing

00:36:53,180 --> 00:37:01,310
there you could index parts and it's

00:36:57,770 --> 00:37:03,560
actually quite hard to you know put all

00:37:01,310 --> 00:37:08,050
of the vehicles that apart belongs to on

00:37:03,560 --> 00:37:12,710
a part so have a separate index where

00:37:08,050 --> 00:37:14,750
you have the vehicles and their make

00:37:12,710 --> 00:37:18,230
model year and so on in that index and

00:37:14,750 --> 00:37:23,869
you query that index for suggest rather

00:37:18,230 --> 00:37:25,750
than trying to shoehorn suggest into an

00:37:23,869 --> 00:37:28,369
index where it doesn't quite fit so

00:37:25,750 --> 00:37:29,660
consider that as a something to think

00:37:28,369 --> 00:37:30,590
about as you're building you suggest

00:37:29,660 --> 00:37:34,160
things that maybe you want to suggest

00:37:30,590 --> 00:37:36,260
use a real index and a real query for

00:37:34,160 --> 00:37:40,570
those suggests and not use maybe the

00:37:36,260 --> 00:37:40,570
built-in suggest stuff at a solar there

00:37:41,680 --> 00:37:47,600
and you know basically finally here

00:37:45,230 --> 00:37:51,560
relevancy certainly the query that you

00:37:47,600 --> 00:37:53,900
provide is basically the formula that's

00:37:51,560 --> 00:37:56,480
used to compute the score the relevancy

00:37:53,900 --> 00:38:00,080
score of each one of the documents

00:37:56,480 --> 00:38:03,619
returned matching as well as the score

00:38:00,080 --> 00:38:07,400
of that document so you're going to have

00:38:03,619 --> 00:38:09,890
to figure out how to use query parsers

00:38:07,400 --> 00:38:11,390
and and do the tuning every application

00:38:09,890 --> 00:38:13,190
that you're building out there is

00:38:11,390 --> 00:38:14,630
different has different needs some

00:38:13,190 --> 00:38:17,150
people don't care about this kind of

00:38:14,630 --> 00:38:19,460
stuff other people are very hyper

00:38:17,150 --> 00:38:25,640
sensitive to this sort of stuff and need

00:38:19,460 --> 00:38:28,460
to you know have corpuses with tests and

00:38:25,640 --> 00:38:31,369
and anytime one of these knobs and dials

00:38:28,460 --> 00:38:33,859
changes that you have to basically run

00:38:31,369 --> 00:38:35,119
tests and make sure that documents that

00:38:33,859 --> 00:38:37,369
you think should match certain queries

00:38:35,119 --> 00:38:41,450
still match that query still appear in

00:38:37,369 --> 00:38:43,160
the top list and so on so tools are

00:38:41,450 --> 00:38:44,270
there are tools that have kind of been

00:38:43,160 --> 00:38:47,270
posted out there in the open source

00:38:44,270 --> 00:38:49,340
recently we're building a relevancy

00:38:47,270 --> 00:38:50,690
workbench into our product as well so

00:38:49,340 --> 00:38:55,790
we're getting more and more tooling out

00:38:50,690 --> 00:38:57,590
there for this sort of stuff kind of

00:38:55,790 --> 00:38:59,180
down to the wire here for in terms of

00:38:57,590 --> 00:39:01,520
time so I'll be kind of quick here

00:38:59,180 --> 00:39:03,980
there's debugging capabilities in there

00:39:01,520 --> 00:39:06,140
there's an analysis request handler

00:39:03,980 --> 00:39:08,300
where you can send in text and get back

00:39:06,140 --> 00:39:11,420
out the positional information and what

00:39:08,300 --> 00:39:14,119
comes out of the analyzer there there's

00:39:11,420 --> 00:39:18,380
debug options you can see the complete

00:39:14,119 --> 00:39:21,020
debug expression for query the raw query

00:39:18,380 --> 00:39:22,400
and then the the parsed query and so on

00:39:21,020 --> 00:39:24,800
so you can see what happens to the query

00:39:22,400 --> 00:39:28,070
parser there and then you can get

00:39:24,800 --> 00:39:31,040
relevancy results there too and see the

00:39:28,070 --> 00:39:33,440
overall leucine score explanation there

00:39:31,040 --> 00:39:35,900
why did this document get the numerical

00:39:33,440 --> 00:39:37,970
score that it got because the field

00:39:35,900 --> 00:39:39,080
appeared this many times the term Pibb

00:39:37,970 --> 00:39:40,940
this many times in the field the

00:39:39,080 --> 00:39:43,190
document had this many documents had

00:39:40,940 --> 00:39:44,630
that term and the field weights or this

00:39:43,190 --> 00:39:45,880
and the boost or this it gives you the

00:39:44,630 --> 00:39:50,140
very complicated

00:39:45,880 --> 00:39:51,850
explanation back and I'll just wrap up

00:39:50,140 --> 00:39:55,390
here with a little bit about the future

00:39:51,850 --> 00:39:58,210
of solar query parsing there is now a

00:39:55,390 --> 00:40:00,910
patch out there not committed yet but a

00:39:58,210 --> 00:40:03,700
prototype patch for JSON query parsing

00:40:00,910 --> 00:40:05,950
and then there's an xml query parser

00:40:03,700 --> 00:40:07,600
that I've been working on and there's

00:40:05,950 --> 00:40:08,980
also a payload turn gray parser and

00:40:07,600 --> 00:40:13,390
there's a little bit about each one of

00:40:08,980 --> 00:40:15,400
these here and these just leverage the Q

00:40:13,390 --> 00:40:16,960
parser framework so those names there

00:40:15,400 --> 00:40:21,310
are the names of those key parsers that

00:40:16,960 --> 00:40:24,040
we already saw there's an xml query

00:40:21,310 --> 00:40:25,720
parser still a work in progress on this

00:40:24,040 --> 00:40:27,130
one all three of these work in progress

00:40:25,720 --> 00:40:29,350
basically they're all patches that are

00:40:27,130 --> 00:40:31,060
sitting out there and then you know this

00:40:29,350 --> 00:40:33,910
one is more niche here maybe you want to

00:40:31,060 --> 00:40:36,490
do boosting on bold words within a text

00:40:33,910 --> 00:40:39,040
the payload stuff something that's not

00:40:36,490 --> 00:40:42,160
supported yet but may very well be in

00:40:39,040 --> 00:40:45,100
the near future and even fancier here is

00:40:42,160 --> 00:40:47,350
this block join query being able to do

00:40:45,100 --> 00:40:50,290
hierarchical type things this one is

00:40:47,350 --> 00:40:52,800
more about indexing properly solar

00:40:50,290 --> 00:40:55,300
doesn't support yet the block join

00:40:52,800 --> 00:40:56,980
indexing capabilities but when it does

00:40:55,300 --> 00:40:59,500
we'll need a query that can leverage

00:40:56,980 --> 00:41:05,230
that so you can do to child and to

00:40:59,500 --> 00:41:07,690
parent type queries there and that's uh

00:41:05,230 --> 00:41:09,990
that's all I got timing worked out

00:41:07,690 --> 00:41:09,990
pretty well

00:41:12,200 --> 00:41:26,900
a couple of questions yeah any questions

00:41:17,750 --> 00:41:29,480
we have time for a question not do so

00:41:26,900 --> 00:41:31,160
thanks very much anyway and saw what I

00:41:29,480 --> 00:41:32,660
mean before the technology people are

00:41:31,160 --> 00:41:35,030
pushing the boundaries so specifically

00:41:32,660 --> 00:41:36,380
with the creative person what's going on

00:41:35,030 --> 00:41:39,470
just know in the solar community that's

00:41:36,380 --> 00:41:42,109
just you know pushing it pushing it to

00:41:39,470 --> 00:41:44,780
the maximum and I know you've discussed

00:41:42,109 --> 00:41:47,119
a lot about you know the various bits

00:41:44,780 --> 00:41:49,070
and pieces so they're special regards to

00:41:47,119 --> 00:41:51,410
development the parties and the way that

00:41:49,070 --> 00:41:53,420
the community as I mean it's moving on

00:41:51,410 --> 00:41:55,099
to mayors and over so I'm in Port sports

00:41:53,420 --> 00:41:58,130
really pushing it with regards to even

00:41:55,099 --> 00:42:00,230
maybe summer in New what applications

00:41:58,130 --> 00:42:02,150
and you know what you guys customers are

00:42:00,230 --> 00:42:03,890
doing etcetera to to really get some

00:42:02,150 --> 00:42:06,530
good performance from from the creek

00:42:03,890 --> 00:42:07,820
I'll sensative things good performance I

00:42:06,530 --> 00:42:09,230
mean really it boils down to the

00:42:07,820 --> 00:42:12,020
complexity of the queries and being able

00:42:09,230 --> 00:42:13,970
to you know especially for using dis max

00:42:12,020 --> 00:42:16,010
some people get really carried away and

00:42:13,970 --> 00:42:17,839
try to diss max across you know dozens

00:42:16,010 --> 00:42:20,270
of fields and then if you've got a query

00:42:17,839 --> 00:42:22,970
that's got you know a dozen terms in it

00:42:20,270 --> 00:42:24,980
x a dozen fields it becomes an extremely

00:42:22,970 --> 00:42:25,910
large complex query especially if you

00:42:24,980 --> 00:42:29,000
turn on some of the other bells and

00:42:25,910 --> 00:42:31,130
whistles with dis max so you know

00:42:29,000 --> 00:42:32,900
reducing the number of fields maybe that

00:42:31,130 --> 00:42:34,579
means having some copy fields that merge

00:42:32,900 --> 00:42:36,380
fields together it's been a very common

00:42:34,579 --> 00:42:38,329
technique you know got title and body if

00:42:36,380 --> 00:42:40,220
you don't care about the relevancy of

00:42:38,329 --> 00:42:42,619
certain things then you can just blend

00:42:40,220 --> 00:42:44,569
all the fields together and simplify the

00:42:42,619 --> 00:42:48,339
query expressions so that's just one

00:42:44,569 --> 00:42:48,339
thing that we we encounter

00:42:50,940 --> 00:43:01,390
alright well thank you very much Oh Oh

00:42:53,650 --> 00:43:04,510
Marcus sure first one basically on this

00:43:01,390 --> 00:43:08,380
one is instant like a big data section I

00:43:04,510 --> 00:43:10,570
was wanting all these posters on do you

00:43:08,380 --> 00:43:12,670
get the data like a big data what kind

00:43:10,570 --> 00:43:16,420
of storage yeah sure I mean these

00:43:12,670 --> 00:43:18,700
queries work in solar there's now solar

00:43:16,420 --> 00:43:21,160
cloud which is a basically a set of

00:43:18,700 --> 00:43:22,990
technologies to scale solar into big

00:43:21,160 --> 00:43:24,970
data basically having a cluster of solar

00:43:22,990 --> 00:43:27,780
servers where I mean we have customers

00:43:24,970 --> 00:43:30,310
that are in the several billion document

00:43:27,780 --> 00:43:32,520
situation now and so they have a cluster

00:43:30,310 --> 00:43:35,950
of you know tens to hundreds of servers

00:43:32,520 --> 00:43:38,050
the queries will spread across that

00:43:35,950 --> 00:43:39,850
entire cluster and aggregate the

00:43:38,050 --> 00:43:43,900
document back so absolutely all these

00:43:39,850 --> 00:43:46,870
queries work in solar cloud yeah okay

00:43:43,900 --> 00:43:50,280
next question I think it you talk about

00:43:46,870 --> 00:43:53,990
a different process and my concern is it

00:43:50,280 --> 00:43:57,770
basically you have when you first

00:43:53,990 --> 00:44:01,360
index your bed flat so for example index

00:43:57,770 --> 00:44:01,360
in this way and then you'll feel

00:44:06,210 --> 00:44:11,730
well i mean the the simple answer but

00:44:09,780 --> 00:44:13,980
not necessarily easy answer is you have

00:44:11,730 --> 00:44:15,750
to reindex and that's you know often the

00:44:13,980 --> 00:44:17,730
case if you start changing around how

00:44:15,750 --> 00:44:20,640
terms are analyzed and so on you just

00:44:17,730 --> 00:44:22,890
simply have to re-index now you can get

00:44:20,640 --> 00:44:24,720
fancier with regular expressions and so

00:44:22,890 --> 00:44:27,300
on so you know you could index in a very

00:44:24,720 --> 00:44:29,010
basic way and still query in very

00:44:27,300 --> 00:44:30,839
sophisticated ways but maybe less

00:44:29,010 --> 00:44:32,760
performance so you could just simply

00:44:30,839 --> 00:44:35,070
whitespace tokenize and lowercase all

00:44:32,760 --> 00:44:37,140
your text and then if you need to do

00:44:35,070 --> 00:44:38,810
kind of pattern matching or you know

00:44:37,140 --> 00:44:43,020
kind of stimming or something like that

00:44:38,810 --> 00:44:47,010
you know you can do regular expressions

00:44:43,020 --> 00:44:49,080
okay so it's possible you build your

00:44:47,010 --> 00:44:51,420
database and you later you realize that

00:44:49,080 --> 00:44:53,700
you you can run and you want to run some

00:44:51,420 --> 00:44:55,050
search but it doesn't work right you

00:44:53,700 --> 00:45:02,010
have to review it for something yeah

00:44:55,050 --> 00:45:05,790
absolutely okay okay thank you thanks

00:45:02,010 --> 00:45:07,410
everybody and also just one more note

00:45:05,790 --> 00:45:10,320
there's there's a meetup tonight for

00:45:07,410 --> 00:45:13,040
leucine and solar yeah so there's a

00:45:10,320 --> 00:45:15,900
meetup tonight at eight o'clock so let's

00:45:13,040 --> 00:45:18,589
come up come out tonight let's talk some

00:45:15,900 --> 00:45:18,589

YouTube URL: https://www.youtube.com/watch?v=Hx0o2NV7Ykc


