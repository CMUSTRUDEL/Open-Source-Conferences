Title: Introduction to Apache Shiro
Publication date: 2013-10-17
Playlist: Apachecon NA 2013 - day 2
Description: 
	Les Hazlewood
ApacheCon NA 2013
How Secure?
Captions: 
	00:00:00,230 --> 00:00:05,400
okay well welcome to presentation my

00:00:03,540 --> 00:00:08,189
name is Leslie wood I'm the apache shiro

00:00:05,400 --> 00:00:11,759
pmc chair most of the CTO and co-founder

00:00:08,189 --> 00:00:13,830
of storm paths just to get that out of

00:00:11,759 --> 00:00:16,379
the way storm path is a cloud identity

00:00:13,830 --> 00:00:18,630
management provider so if you're

00:00:16,379 --> 00:00:20,970
building applications that are internet

00:00:18,630 --> 00:00:22,380
or publicly web facing and you need to

00:00:20,970 --> 00:00:24,510
integrate or manage users and

00:00:22,380 --> 00:00:25,769
authenticate them in a secure way you

00:00:24,510 --> 00:00:27,240
know avoiding some of the things that

00:00:25,769 --> 00:00:30,150
we've seen with twitter and linkedin and

00:00:27,240 --> 00:00:31,940
sony and those kind of guys we prevent

00:00:30,150 --> 00:00:34,890
those those things from happening so

00:00:31,940 --> 00:00:37,649
we're a cloud-based id id provider we're

00:00:34,890 --> 00:00:39,719
specifically targeted developers at our

00:00:37,649 --> 00:00:42,360
core were arrest json api and then we

00:00:39,719 --> 00:00:44,190
offer apache licensed SDKs that sit on

00:00:42,360 --> 00:00:49,730
top of the api that you can drop in to

00:00:44,190 --> 00:00:49,730
your application so that storm path

00:00:49,789 --> 00:00:54,750
what about Shara what is Apache Shiro

00:00:52,350 --> 00:00:56,370
so Apache Shiro is an application

00:00:54,750 --> 00:00:59,940
security framework it's something that

00:00:56,370 --> 00:01:01,949
an application developer drops in to

00:00:59,940 --> 00:01:05,159
their source code as a library jar file

00:01:01,949 --> 00:01:07,229
or multiple jars to enforce security

00:01:05,159 --> 00:01:09,630
policies in behavior within an

00:01:07,229 --> 00:01:12,290
application or a top-level project we've

00:01:09,630 --> 00:01:15,210
been top-level for a couple of years now

00:01:12,290 --> 00:01:18,479
the core focus of the project is to make

00:01:15,210 --> 00:01:20,430
security quick and easy to use security

00:01:18,479 --> 00:01:24,330
can be very difficult to understand

00:01:20,430 --> 00:01:25,740
sometimes very challenging even for you

00:01:24,330 --> 00:01:27,030
know junior people coming out of high

00:01:25,740 --> 00:01:29,009
school or college they may not have a

00:01:27,030 --> 00:01:30,600
good understanding of this stuff so we

00:01:29,009 --> 00:01:32,700
do our best to really make things easy

00:01:30,600 --> 00:01:34,710
to use whenever possible and that's

00:01:32,700 --> 00:01:37,759
that's the primary reason why we exist

00:01:34,710 --> 00:01:43,740
and to simplify these more complex

00:01:37,759 --> 00:01:45,570
topics the numbers are actually a lot

00:01:43,740 --> 00:01:49,140
bigger than this nowadays that this is

00:01:45,570 --> 00:01:50,460
an old number but we share as a lot

00:01:49,140 --> 00:01:52,380
especially in the last year and a half

00:01:50,460 --> 00:01:54,740
has been adopted by a lot of financial

00:01:52,380 --> 00:01:57,360
and government organizations so

00:01:54,740 --> 00:01:58,979
government organizations that we cannot

00:01:57,360 --> 00:02:00,450
name as well as you know New York Stock

00:01:58,979 --> 00:02:02,219
Exchange and Nasdaq and stuff a lot of

00:02:00,450 --> 00:02:03,600
those guys you share with their core

00:02:02,219 --> 00:02:08,399
security layer for their Java based

00:02:03,600 --> 00:02:10,860
applications so this is the agenda what

00:02:08,399 --> 00:02:12,780
we're going to talk about Shiro at its

00:02:10,860 --> 00:02:15,270
core really focuses

00:02:12,780 --> 00:02:17,220
focuses on what we consider four

00:02:15,270 --> 00:02:19,410
cornerstones of application security

00:02:17,220 --> 00:02:21,240
there's authentication access control

00:02:19,410 --> 00:02:23,370
session management and cryptography and

00:02:21,240 --> 00:02:24,180
then in addition to those four

00:02:23,370 --> 00:02:27,510
cornerstones

00:02:24,180 --> 00:02:29,730
Shiro's also offers some nice web

00:02:27,510 --> 00:02:31,140
support and auxilary features for

00:02:29,730 --> 00:02:32,569
multi-threaded environments and one that

00:02:31,140 --> 00:02:34,410
we'll talk about those at the end but

00:02:32,569 --> 00:02:36,380
we're going to cover these four

00:02:34,410 --> 00:02:39,470
cornerstones first and then talk about

00:02:36,380 --> 00:02:43,020
the web and auxilary support afterwards

00:02:39,470 --> 00:02:45,269
so but before we get started I want to

00:02:43,020 --> 00:02:47,190
cover some quick terminology these are

00:02:45,269 --> 00:02:49,320
words and terms that are used and

00:02:47,190 --> 00:02:51,209
throughout Shiro's documentation in the

00:02:49,320 --> 00:02:52,530
source code and in this presentation so

00:02:51,209 --> 00:02:54,750
I want to make sure that we all get on

00:02:52,530 --> 00:02:56,820
the same page but we refer to the

00:02:54,750 --> 00:02:58,620
subject quite a lot quite a bit and a

00:02:56,820 --> 00:03:03,150
subject is really just a security

00:02:58,620 --> 00:03:05,519
specific view of an application user so

00:03:03,150 --> 00:03:07,709
it's basically the current person or

00:03:05,519 --> 00:03:10,140
thing executing or interacting with the

00:03:07,709 --> 00:03:11,970
software we don't use the word user

00:03:10,140 --> 00:03:16,650
because the word user often implies a

00:03:11,970 --> 00:03:18,480
human being but a subject can be a human

00:03:16,650 --> 00:03:19,950
being it can be a third-party process it

00:03:18,480 --> 00:03:21,480
can be a daemon system daemon that's

00:03:19,950 --> 00:03:24,299
running anything that's currently

00:03:21,480 --> 00:03:27,209
interacting with the software principles

00:03:24,299 --> 00:03:28,769
are subjects identifying attributes so

00:03:27,209 --> 00:03:31,530
first name last name social security

00:03:28,769 --> 00:03:33,750
number anything that identifies the

00:03:31,530 --> 00:03:36,600
subject is considered a principle of

00:03:33,750 --> 00:03:38,340
course you should or most applications

00:03:36,600 --> 00:03:40,829
typically have a single primary

00:03:38,340 --> 00:03:43,350
identifying principle like a username or

00:03:40,829 --> 00:03:45,299
a relational database primary key

00:03:43,350 --> 00:03:49,200
something that uniquely identifies that

00:03:45,299 --> 00:03:52,430
subject among all others credentials are

00:03:49,200 --> 00:03:54,590
secret values that verify identity so

00:03:52,430 --> 00:03:58,109
passwords of course is probably the most

00:03:54,590 --> 00:04:01,769
referenced credentials x.509

00:03:58,109 --> 00:04:03,540
certificates fingerprint scans retina

00:04:01,769 --> 00:04:06,390
scans these are all types of credentials

00:04:03,540 --> 00:04:08,400
that verify an identity and finally

00:04:06,390 --> 00:04:10,410
Shiro represents or talks about the

00:04:08,400 --> 00:04:11,910
notion of a realm quite a bit and a

00:04:10,410 --> 00:04:14,700
realm for us is really a security

00:04:11,910 --> 00:04:17,820
specific Dao or datasource it's really

00:04:14,700 --> 00:04:20,489
the the representation of security

00:04:17,820 --> 00:04:22,080
specific data for users accounts

00:04:20,489 --> 00:04:24,180
permissions and whatnot and it's the

00:04:22,080 --> 00:04:24,750
thing that buffers Shiro from your

00:04:24,180 --> 00:04:30,060
actual

00:04:24,750 --> 00:04:32,630
source so those are terms any questions

00:04:30,060 --> 00:04:34,890
on these okay good

00:04:32,630 --> 00:04:36,930
so let's let's start talking about

00:04:34,890 --> 00:04:39,750
authentication so we define

00:04:36,930 --> 00:04:42,060
authentication as that's the process of

00:04:39,750 --> 00:04:44,880
verifying identity it's proving a user

00:04:42,060 --> 00:04:46,620
is who they say they are so just because

00:04:44,880 --> 00:04:48,330
I say I'm John Smith doesn't mean I'm

00:04:46,620 --> 00:04:50,250
really John Smith I need to provide some

00:04:48,330 --> 00:04:51,990
additional information or credentials to

00:04:50,250 --> 00:04:54,810
actually verify that I am who I say that

00:04:51,990 --> 00:04:57,870
I am and so that's what authentication

00:04:54,810 --> 00:05:00,390
is this is some of these are some of the

00:04:57,870 --> 00:05:03,120
features that Shero offers in its

00:05:00,390 --> 00:05:05,400
authentication process everything ensure

00:05:03,120 --> 00:05:07,470
mostly almost everything that a

00:05:05,400 --> 00:05:09,360
developer interacts with rushiro is

00:05:07,470 --> 00:05:10,800
subject base so most of the security

00:05:09,360 --> 00:05:13,290
operations are performed on the

00:05:10,800 --> 00:05:14,790
currently executing subject it's a

00:05:13,290 --> 00:05:16,770
single method call you have one method

00:05:14,790 --> 00:05:18,660
to call and if it's successful they're

00:05:16,770 --> 00:05:20,100
logged in if it's not successful there's

00:05:18,660 --> 00:05:22,530
different conditions that you can

00:05:20,100 --> 00:05:24,510
process there's a rich exception

00:05:22,530 --> 00:05:27,780
hierarchy that explains exactly why an

00:05:24,510 --> 00:05:29,729
authentication attempt would fail Sheryl

00:05:27,780 --> 00:05:32,010
also supports the notion of remember me

00:05:29,729 --> 00:05:33,570
built-in so obviously if you go to a

00:05:32,010 --> 00:05:35,010
website and you enter a username

00:05:33,570 --> 00:05:37,560
password and click remember me it's

00:05:35,010 --> 00:05:39,540
built into the framework and we have

00:05:37,560 --> 00:05:41,610
this notion of event listeners where you

00:05:39,540 --> 00:05:44,340
can listen to different failed or

00:05:41,610 --> 00:05:46,320
successful attempts via events so you

00:05:44,340 --> 00:05:48,870
can plug into that for custom behavior

00:05:46,320 --> 00:05:51,440
based on what you might want in your

00:05:48,870 --> 00:05:53,850
applications based on these events so

00:05:51,440 --> 00:05:55,979
how do you authenticate with your how do

00:05:53,850 --> 00:05:58,520
you authenticate a user the first step

00:05:55,979 --> 00:06:01,110
is to collect principles and credentials

00:05:58,520 --> 00:06:04,380
and again this could be anything Shiro

00:06:01,110 --> 00:06:06,750
is protocol agnostic so you acquire this

00:06:04,380 --> 00:06:09,090
information however a you see fit so for

00:06:06,750 --> 00:06:11,520
some it's a username and password on an

00:06:09,090 --> 00:06:15,600
SSL based forum others it's an x.509

00:06:11,520 --> 00:06:17,250
certificate or Kerberos or what have you

00:06:15,600 --> 00:06:19,410
but the basic idea is you collect the

00:06:17,250 --> 00:06:20,550
principles and credentials you need then

00:06:19,410 --> 00:06:22,229
you submit them to the authentication

00:06:20,550 --> 00:06:26,580
system or Toshiro's authentication

00:06:22,229 --> 00:06:28,200
system and you either allow access if

00:06:26,580 --> 00:06:30,330
they're successful or you allow them to

00:06:28,200 --> 00:06:31,800
retry if it's not successful or maybe

00:06:30,330 --> 00:06:34,169
after a certain amount of times you can

00:06:31,800 --> 00:06:36,810
block access for that account if if they

00:06:34,169 --> 00:06:38,400
fail too many times this is the over the

00:06:36,810 --> 00:06:39,780
overall process

00:06:38,400 --> 00:06:42,150
regardless of the actual type of

00:06:39,780 --> 00:06:43,530
authentication but as an example we'll

00:06:42,150 --> 00:06:45,570
show you what it looks like if you're

00:06:43,530 --> 00:06:49,320
using the most common user name and

00:06:45,570 --> 00:06:50,520
password based authentication so step

00:06:49,320 --> 00:06:51,990
one we collect our principles and

00:06:50,520 --> 00:06:54,479
credentials and in this case we

00:06:51,990 --> 00:06:56,370
instantiate a username password token

00:06:54,479 --> 00:06:58,530
instance this is an implementation of

00:06:56,370 --> 00:07:00,479
the authentication token interface and

00:06:58,530 --> 00:07:02,310
of course it takes in a username and

00:07:00,479 --> 00:07:04,770
password and this particular example

00:07:02,310 --> 00:07:06,660
work or setting remember me to true

00:07:04,770 --> 00:07:09,330
because we want zero to remember the

00:07:06,660 --> 00:07:12,750
identity of the user on subsequent

00:07:09,330 --> 00:07:13,979
sessions and that's it we've collected

00:07:12,750 --> 00:07:16,080
our principles of credentials there's

00:07:13,979 --> 00:07:19,199
not much more to it for this particular

00:07:16,080 --> 00:07:22,080
case now that we have this we need to

00:07:19,199 --> 00:07:24,900
submit it to Shiro and so well Shiro we

00:07:22,080 --> 00:07:27,360
have this notion of a security utils and

00:07:24,900 --> 00:07:30,000
security details get subject returns a

00:07:27,360 --> 00:07:31,620
subject instance that represents the

00:07:30,000 --> 00:07:33,990
currently executing subject the

00:07:31,620 --> 00:07:36,270
currently executing user and so you can

00:07:33,990 --> 00:07:39,860
use this in your code anywhere to obtain

00:07:36,270 --> 00:07:42,630
the current the current user

00:07:39,860 --> 00:07:45,630
up to and including sure one at two this

00:07:42,630 --> 00:07:47,430
is thread-local based future versions of

00:07:45,630 --> 00:07:49,289
Sheryl will provide sort of an access or

00:07:47,430 --> 00:07:50,910
interface that allows you to obtain the

00:07:49,289 --> 00:07:53,520
subject from different locations other

00:07:50,910 --> 00:07:54,900
than just thread-local but most people

00:07:53,520 --> 00:07:56,520
care about the currently executing user

00:07:54,900 --> 00:07:59,430
and that almost always has a one-to-one

00:07:56,520 --> 00:08:01,470
correspondence with a thread so this has

00:07:59,430 --> 00:08:04,110
got enough the framework quite far and

00:08:01,470 --> 00:08:05,820
it's quite useful but basically you

00:08:04,110 --> 00:08:07,800
acquire the subject and then the second

00:08:05,820 --> 00:08:10,830
line is you just pass the token to the

00:08:07,800 --> 00:08:13,409
login method if this method returns

00:08:10,830 --> 00:08:15,240
quietly you're done the user is

00:08:13,409 --> 00:08:16,620
authenticated successfully they can go

00:08:15,240 --> 00:08:19,349
on about their business using the

00:08:16,620 --> 00:08:21,590
application but if it doesn't return

00:08:19,349 --> 00:08:25,139
successfully there's any number of

00:08:21,590 --> 00:08:26,820
exceptions that you can catch and react

00:08:25,139 --> 00:08:29,610
to that indicate exactly why the

00:08:26,820 --> 00:08:31,860
authentication attempt failed so you

00:08:29,610 --> 00:08:33,719
know maybe there isn't an account for

00:08:31,860 --> 00:08:34,919
that particular username or the account

00:08:33,719 --> 00:08:38,339
has been locked and therefore they're

00:08:34,919 --> 00:08:39,990
not allowed to use the application maybe

00:08:38,339 --> 00:08:42,599
they've specified an incorrect password

00:08:39,990 --> 00:08:44,880
or you can of course catch the general

00:08:42,599 --> 00:08:46,140
Ithaca an exception and and do what you

00:08:44,880 --> 00:08:48,420
do what you want

00:08:46,140 --> 00:08:50,490
there's no problems again you can show a

00:08:48,420 --> 00:08:52,339
particular view or some kind of response

00:08:50,490 --> 00:08:55,010
that indicates that everything's fine I

00:08:52,339 --> 00:08:57,390
should also note here though that

00:08:55,010 --> 00:08:59,579
indicating to an end-user at least why

00:08:57,390 --> 00:09:01,860
an authentication attempt fails is not a

00:08:59,579 --> 00:09:03,690
good idea right you don't want to ever

00:09:01,860 --> 00:09:05,370
let them know you know that either

00:09:03,690 --> 00:09:06,630
account exists or the password is

00:09:05,370 --> 00:09:08,700
incorrect you don't want to provide any

00:09:06,630 --> 00:09:11,279
information to an attacker that might be

00:09:08,700 --> 00:09:13,170
used to compromise an account so this

00:09:11,279 --> 00:09:14,910
information is provided specifically for

00:09:13,170 --> 00:09:17,070
the developers using Shiro the

00:09:14,910 --> 00:09:18,300
developers can catch these things and

00:09:17,070 --> 00:09:20,220
react to them in a way that makes sense

00:09:18,300 --> 00:09:21,630
for their application but they should

00:09:20,220 --> 00:09:26,579
never show this information to the

00:09:21,630 --> 00:09:28,649
end-user so a little bit of discrepancy

00:09:26,579 --> 00:09:30,720
there not discrepancy but discretion is

00:09:28,649 --> 00:09:33,060
needed when when catching exceptions

00:09:30,720 --> 00:09:35,810
just the common recommendation we give

00:09:33,060 --> 00:09:38,070
to anyone is just indicate you know

00:09:35,810 --> 00:09:39,750
invalid user name or password right

00:09:38,070 --> 00:09:41,880
that's the generic message that you see

00:09:39,750 --> 00:09:43,589
in a lot of login forms and it doesn't

00:09:41,880 --> 00:09:46,430
give any legitimate information for an

00:09:43,589 --> 00:09:49,440
attacker so it's there for the developer

00:09:46,430 --> 00:09:53,339
but but be prudent about what you show

00:09:49,440 --> 00:09:55,500
your end-users how does this work you

00:09:53,339 --> 00:09:58,050
know we have this login call how's it

00:09:55,500 --> 00:10:00,750
function so this is a little bit of

00:09:58,050 --> 00:10:02,660
Shiro's architecture so when you call

00:10:00,750 --> 00:10:06,000
the login method on a subject instance

00:10:02,660 --> 00:10:08,459
what you're really doing is interacting

00:10:06,000 --> 00:10:11,279
with a proxy and the subject is actually

00:10:08,459 --> 00:10:13,079
a proxy to the security manager and the

00:10:11,279 --> 00:10:14,910
security manager here is Shiro's

00:10:13,079 --> 00:10:16,649
internal representation of a security

00:10:14,910 --> 00:10:19,890
manager has nothing to do with the

00:10:16,649 --> 00:10:22,709
java.lang that security manager so this

00:10:19,890 --> 00:10:24,899
is Shiro's api but the subject is a

00:10:22,709 --> 00:10:26,880
proxy to the security manager the

00:10:24,899 --> 00:10:29,279
subject indicates or represents rather a

00:10:26,880 --> 00:10:30,899
single identity whereas the security

00:10:29,279 --> 00:10:33,089
manager can manage security operations

00:10:30,899 --> 00:10:36,540
for all users or all identities in an

00:10:33,089 --> 00:10:38,870
application so when you call login the

00:10:36,540 --> 00:10:41,579
security managers actually invoked and

00:10:38,870 --> 00:10:44,699
it in turn delegates to an internal

00:10:41,579 --> 00:10:46,740
Authenticator object that will do what

00:10:44,699 --> 00:10:48,890
it needs to do and so this is a common

00:10:46,740 --> 00:10:50,910
theme within Shiro security manager is

00:10:48,890 --> 00:10:53,220
it does a lot of things authentication

00:10:50,910 --> 00:10:54,990
access control remember me but in

00:10:53,220 --> 00:10:57,899
reality the security manager sort of an

00:10:54,990 --> 00:10:59,670
umbrella component that wraps other more

00:10:57,899 --> 00:11:01,800
specific components that are

00:10:59,670 --> 00:11:04,800
designated for a particular function so

00:11:01,800 --> 00:11:06,510
in an authentication case we'll talk to

00:11:04,800 --> 00:11:07,920
an Authenticator and the Authenticator

00:11:06,510 --> 00:11:10,920
is the one for responsible for

00:11:07,920 --> 00:11:13,140
performing the attempt the Authenticator

00:11:10,920 --> 00:11:15,120
in turn can go out and communicate or

00:11:13,140 --> 00:11:17,490
interact with multiple realms it could

00:11:15,120 --> 00:11:20,070
be one realm it could be multiple realms

00:11:17,490 --> 00:11:22,590
maybe one of these is a you know a

00:11:20,070 --> 00:11:24,390
properties based file that has username

00:11:22,590 --> 00:11:26,070
password pairs maybe another realm talks

00:11:24,390 --> 00:11:27,900
to LDAP or Active Directory may be a

00:11:26,070 --> 00:11:30,330
another realm is for proprietary

00:11:27,900 --> 00:11:32,970
datastore but the idea is that the

00:11:30,330 --> 00:11:34,890
Authenticator access this has excuse me

00:11:32,970 --> 00:11:36,750
accesses identity information from any

00:11:34,890 --> 00:11:39,450
of these realms to perform the

00:11:36,750 --> 00:11:41,310
authentication attempt and you can

00:11:39,450 --> 00:11:44,100
coordinate how that occurs with this

00:11:41,310 --> 00:11:45,300
notion of an authentication strategy you

00:11:44,100 --> 00:11:47,070
can plug-in custom authentication

00:11:45,300 --> 00:11:49,620
strategies there's a few that come out

00:11:47,070 --> 00:11:51,480
of the box like maybe the first one the

00:11:49,620 --> 00:11:55,230
60-seat succeeds is the one that we're

00:11:51,480 --> 00:11:57,240
going to use maybe everyone is consulted

00:11:55,230 --> 00:11:58,710
has to succeed and if any one of them

00:11:57,240 --> 00:12:00,990
fail the authentication attempt fails

00:11:58,710 --> 00:12:03,960
but the idea is that you can customize

00:12:00,990 --> 00:12:06,600
how the interaction occurs across realm

00:12:03,960 --> 00:12:09,210
instances based on your needs and again

00:12:06,600 --> 00:12:10,770
we have more than a few out-of-the-box

00:12:09,210 --> 00:12:14,820
implementations that you can use based

00:12:10,770 --> 00:12:18,680
on your requirements any questions about

00:12:14,820 --> 00:12:18,680
this before we go on to authorization

00:12:21,020 --> 00:12:25,860
okay so we've talked about

00:12:24,030 --> 00:12:29,820
authentication proving identity

00:12:25,860 --> 00:12:31,590
how does Shiro handle authorization so

00:12:29,820 --> 00:12:33,390
and what we mean by authorization is is

00:12:31,590 --> 00:12:36,090
it's really the process of determining

00:12:33,390 --> 00:12:39,570
who can do what this otherwise known as

00:12:36,090 --> 00:12:41,880
access control and in other venues but

00:12:39,570 --> 00:12:43,380
the idea of determining who is allowed

00:12:41,880 --> 00:12:45,690
to perform certain functionality or

00:12:43,380 --> 00:12:49,350
interact with specific resources that's

00:12:45,690 --> 00:12:51,990
really authorization and in Shiro there

00:12:49,350 --> 00:12:53,430
are some core concepts that we have the

00:12:51,990 --> 00:12:55,770
notion of permissions which I'll cover

00:12:53,430 --> 00:12:57,540
what those are in a second roles and

00:12:55,770 --> 00:13:00,210
users and again we don't really have a

00:12:57,540 --> 00:13:01,500
user concept we have a subject but the

00:13:00,210 --> 00:13:02,790
idea is that you could perform role

00:13:01,500 --> 00:13:05,850
based access control or very

00:13:02,790 --> 00:13:07,260
fine-grained access control in with

00:13:05,850 --> 00:13:09,260
permissions you know I'll explain how

00:13:07,260 --> 00:13:12,120
that how that functions in a bit

00:13:09,260 --> 00:13:13,500
permissions are Shiro's most atomic

00:13:12,120 --> 00:13:15,660
security element you can't break

00:13:13,500 --> 00:13:18,480
anything down further beyond a

00:13:15,660 --> 00:13:20,580
permission in insurance model and a

00:13:18,480 --> 00:13:23,040
permission at its core is really a

00:13:20,580 --> 00:13:26,850
statement that describes a resource type

00:13:23,040 --> 00:13:30,120
and an Associated behavior so opening a

00:13:26,850 --> 00:13:32,250
file or deleting a user or you know

00:13:30,120 --> 00:13:34,350
sending a message these are all actions

00:13:32,250 --> 00:13:36,630
that are taken upon particular resources

00:13:34,350 --> 00:13:38,670
and permissions at the core really

00:13:36,630 --> 00:13:40,770
define what the application is possible

00:13:38,670 --> 00:13:42,540
there's capable of doing so if a user

00:13:40,770 --> 00:13:44,850
can view a file or they can delete a

00:13:42,540 --> 00:13:46,530
user or they can you know open a

00:13:44,850 --> 00:13:48,150
document or send an email right these

00:13:46,530 --> 00:13:49,710
are all behaviors that can be taken

00:13:48,150 --> 00:13:51,060
within an application they funnel mean

00:13:49,710 --> 00:13:53,280
fundamentally define what the

00:13:51,060 --> 00:13:56,010
application can do but they have no

00:13:53,280 --> 00:13:57,450
notion of who so in the permission

00:13:56,010 --> 00:14:00,090
definition or permission statement

00:13:57,450 --> 00:14:03,900
there's no notion of a user you know

00:14:00,090 --> 00:14:06,420
maybe J Smith can do these things and

00:14:03,900 --> 00:14:09,120
we'll explain how those associations are

00:14:06,420 --> 00:14:11,250
made in the second but ideally they're

00:14:09,120 --> 00:14:13,170
just definitions of behavior nothing

00:14:11,250 --> 00:14:16,380
more this is also known as you know

00:14:13,170 --> 00:14:17,780
rights rights management rights rights

00:14:16,380 --> 00:14:20,010
control

00:14:17,780 --> 00:14:26,370
in addition permissions we have roles

00:14:20,010 --> 00:14:27,510
and these are kind of what people would

00:14:26,370 --> 00:14:29,040
expect when they when they think about

00:14:27,510 --> 00:14:30,450
role based access control where you

00:14:29,040 --> 00:14:32,790
basically have a name of a bunch of role

00:14:30,450 --> 00:14:33,160
or roles and if I have the admin role I

00:14:32,790 --> 00:14:35,480
can

00:14:33,160 --> 00:14:36,709
whatever an administrator can do if I

00:14:35,480 --> 00:14:39,290
have the user role I can do whatever

00:14:36,709 --> 00:14:40,700
users allowed to do but the interesting

00:14:39,290 --> 00:14:43,610
thing about traditional role based

00:14:40,700 --> 00:14:45,230
access control is that typically they're

00:14:43,610 --> 00:14:49,220
just names they're strings administrator

00:14:45,230 --> 00:14:52,190
user contractor right there's nothing

00:14:49,220 --> 00:14:53,959
inherent to the word that actually tells

00:14:52,190 --> 00:14:56,959
the software what that individual role

00:14:53,959 --> 00:14:59,360
is allowed to do and so that is sort of

00:14:56,959 --> 00:15:01,279
an implicit construct right just because

00:14:59,360 --> 00:15:02,810
I have a role called administrator means

00:15:01,279 --> 00:15:05,180
I could do administrative things but

00:15:02,810 --> 00:15:05,990
nothing if software actually knows what

00:15:05,180 --> 00:15:09,110
those things are

00:15:05,990 --> 00:15:11,089
so enshiro we prefer to have roles be

00:15:09,110 --> 00:15:12,890
explicit constructs in that they're

00:15:11,089 --> 00:15:15,860
really a named collection of permissions

00:15:12,890 --> 00:15:18,260
so if I have an administrator role that

00:15:15,860 --> 00:15:21,260
has the delete user permission in the

00:15:18,260 --> 00:15:23,060
you know create you know document

00:15:21,260 --> 00:15:25,670
permission and any of these kind of

00:15:23,060 --> 00:15:26,750
explicitly listed behaviors the

00:15:25,670 --> 00:15:29,690
aggregate of those things together

00:15:26,750 --> 00:15:31,190
really form a set of behaviors that are

00:15:29,690 --> 00:15:34,550
allowed to be performed by a particular

00:15:31,190 --> 00:15:36,560
classification of user and so Shiro's

00:15:34,550 --> 00:15:38,209
permission construct in the notion of

00:15:36,560 --> 00:15:40,579
roles that wrap those together gives you

00:15:38,209 --> 00:15:42,290
a really really fine grain explicit way

00:15:40,579 --> 00:15:48,980
of defining who can do what within an

00:15:42,290 --> 00:15:50,630
application and also with Xero you can

00:15:48,980 --> 00:15:52,640
dynamically modify these things at

00:15:50,630 --> 00:15:54,290
runtime so you can change what

00:15:52,640 --> 00:15:56,510
permissions are associated to roles you

00:15:54,290 --> 00:15:59,870
can change you know hierarchies of roles

00:15:56,510 --> 00:16:03,020
as your data store or your requirements

00:15:59,870 --> 00:16:04,700
allow you or whatever your software

00:16:03,020 --> 00:16:07,310
requires you can do these things at

00:16:04,700 --> 00:16:08,720
runtime and instantly see those changes

00:16:07,310 --> 00:16:11,870
without requiring the user to log out

00:16:08,720 --> 00:16:14,060
and log back in again and if Cheryl has

00:16:11,870 --> 00:16:17,060
some caching layers in place to help

00:16:14,060 --> 00:16:21,560
make that as fast as possible talk about

00:16:17,060 --> 00:16:23,329
caching a little bit so users right this

00:16:21,560 --> 00:16:25,579
is really the who of the application

00:16:23,329 --> 00:16:28,269
right there the jay Smith's or the

00:16:25,579 --> 00:16:30,199
daemon accounts or you know the actual

00:16:28,269 --> 00:16:34,370
subjects that are interacting with the

00:16:30,199 --> 00:16:37,070
software and so finally we can assign to

00:16:34,370 --> 00:16:38,779
users or subjects permissions and roles

00:16:37,070 --> 00:16:41,449
and it's based on these associations

00:16:38,779 --> 00:16:43,940
that really in turn tells the software

00:16:41,449 --> 00:16:45,649
what that subjects allowed to do so if

00:16:43,940 --> 00:16:46,460
there's a this concept of a printer

00:16:45,649 --> 00:16:48,560
permission

00:16:46,460 --> 00:16:49,910
and you know maybe I can print to the

00:16:48,560 --> 00:16:51,470
printer on the third floor if that

00:16:49,910 --> 00:16:53,000
permission is directly assigned with my

00:16:51,470 --> 00:16:54,290
user or one of the roles that are

00:16:53,000 --> 00:16:57,440
assigned to the user then through that

00:16:54,290 --> 00:16:59,720
direct Association or even transitive

00:16:57,440 --> 00:17:00,980
Association you know exactly what that

00:16:59,720 --> 00:17:02,660
user is allowed to do and what they're

00:17:00,980 --> 00:17:05,000
not allowed to do much more concrete

00:17:02,660 --> 00:17:08,809
representation of behavior than just a

00:17:05,000 --> 00:17:10,550
simple string name and this is up to you

00:17:08,809 --> 00:17:11,809
however you wish to model this in your

00:17:10,550 --> 00:17:14,630
application whether it's relational

00:17:11,809 --> 00:17:16,309
database or LDAP or Active Directory you

00:17:14,630 --> 00:17:18,559
can model this out in these associations

00:17:16,309 --> 00:17:21,079
however you desire it's really the Shero

00:17:18,559 --> 00:17:26,569
realm that translates your data model

00:17:21,079 --> 00:17:29,000
into a format that Shero understands so

00:17:26,569 --> 00:17:31,340
what are the features of authorization

00:17:29,000 --> 00:17:33,980
and cheero so again like authentication

00:17:31,340 --> 00:17:35,870
at subject centric you can do a security

00:17:33,980 --> 00:17:39,020
or excuse me a permission or a role

00:17:35,870 --> 00:17:40,790
check based on the current user you can

00:17:39,020 --> 00:17:43,880
check against individual role names or

00:17:40,790 --> 00:17:46,040
in individual permission and Cheryl

00:17:43,880 --> 00:17:47,570
provides this out-of-the-box wildcard

00:17:46,040 --> 00:17:51,320
permission that allows you to define

00:17:47,570 --> 00:17:54,440
your own kind of wildcard syntax maybe

00:17:51,320 --> 00:17:57,800
you can delete any user or I can create

00:17:54,440 --> 00:17:59,270
any document or delete all users I mean

00:17:57,800 --> 00:18:01,309
you can use the wildcard character the

00:17:59,270 --> 00:18:04,910
the asterisk to kind of build up your

00:18:01,309 --> 00:18:07,070
own definitions the permission itself is

00:18:04,910 --> 00:18:08,390
a class or excuse me an interface so the

00:18:07,070 --> 00:18:10,309
implementation could be whatever you

00:18:08,390 --> 00:18:12,080
wish most people find the wildcard

00:18:10,309 --> 00:18:14,660
permission sufficient for their needs

00:18:12,080 --> 00:18:17,090
and again any data model that you have

00:18:14,660 --> 00:18:18,830
to represent this will will be fine it's

00:18:17,090 --> 00:18:20,090
really the realms that decide the realm

00:18:18,830 --> 00:18:22,760
that communicates with your datastore

00:18:20,090 --> 00:18:27,040
that does the translation to a format

00:18:22,760 --> 00:18:29,510
that she understands so how do you

00:18:27,040 --> 00:18:32,270
users with 0 there's a there's a few

00:18:29,510 --> 00:18:36,290
means of course programmatic where you

00:18:32,270 --> 00:18:40,400
interact with a subject we have jdk 1.5

00:18:36,290 --> 00:18:43,309
annotations that can be integrated with

00:18:40,400 --> 00:18:46,550
AOP to prevent methods from executing or

00:18:43,309 --> 00:18:50,090
not and there is a JSP GSP tag libraries

00:18:46,550 --> 00:18:51,410
available there's also JSF integration

00:18:50,090 --> 00:18:54,740
in the current trunk it's not yet

00:18:51,410 --> 00:18:57,379
released but you can control page output

00:18:54,740 --> 00:19:01,169
based on an authorization state

00:18:57,379 --> 00:19:02,730
so here's some examples so in a simple

00:19:01,169 --> 00:19:04,980
roll check you know i acquire the

00:19:02,730 --> 00:19:06,929
current user and then i just do a check

00:19:04,980 --> 00:19:09,360
you know does the current user have the

00:19:06,929 --> 00:19:11,999
administrator role and if so maybe i

00:19:09,360 --> 00:19:13,320
show the delete user button but maybe if

00:19:11,999 --> 00:19:15,779
they don't have that role I don't show

00:19:13,320 --> 00:19:17,340
the button maybe I grayed out you know

00:19:15,779 --> 00:19:19,200
you can change the functionality of your

00:19:17,340 --> 00:19:21,989
software or your user interfaces based

00:19:19,200 --> 00:19:25,889
on their their authorization

00:19:21,989 --> 00:19:28,919
capabilities here is a similar check

00:19:25,889 --> 00:19:30,749
using permissions so in this in this

00:19:28,919 --> 00:19:35,549
case I am instantiating a permission

00:19:30,749 --> 00:19:37,379
instance where I have the the type of

00:19:35,549 --> 00:19:40,350
object that's being interacted with as a

00:19:37,379 --> 00:19:42,119
user I list a user permission the target

00:19:40,350 --> 00:19:44,639
the actual identifier of that of the

00:19:42,119 --> 00:19:46,409
actual object is J Smith and the action

00:19:44,639 --> 00:19:48,779
being performed in this case is delete

00:19:46,409 --> 00:19:51,929
and so this is a type safe way of

00:19:48,779 --> 00:19:53,789
representing behavioral statements you

00:19:51,929 --> 00:19:55,789
can instantiate this and then do a check

00:19:53,789 --> 00:19:58,950
if the current user is permitted to

00:19:55,789 --> 00:20:00,600
delete the J Smith user then maybe I

00:19:58,950 --> 00:20:03,749
show the delete button on that page

00:20:00,600 --> 00:20:05,070
otherwise maybe I don't show it the

00:20:03,749 --> 00:20:06,779
really cool thing about this is that

00:20:05,070 --> 00:20:09,359
it's showing you an example of a very

00:20:06,779 --> 00:20:11,879
fine-grained access control check where

00:20:09,359 --> 00:20:13,950
you can get a level of granularity in

00:20:11,879 --> 00:20:18,210
your authorization that you just really

00:20:13,950 --> 00:20:19,409
can't get with the rules if you don't

00:20:18,210 --> 00:20:21,659
want to create your own permission

00:20:19,409 --> 00:20:23,580
classes and you're okay with you know

00:20:21,659 --> 00:20:26,129
foregoing type safety you can use

00:20:23,580 --> 00:20:28,559
strings and this is kind of where the

00:20:26,129 --> 00:20:30,840
wild card permission comes into play you

00:20:28,559 --> 00:20:33,450
can define your own string syntax and

00:20:30,840 --> 00:20:37,109
the wild card permission has this notion

00:20:33,450 --> 00:20:39,149
of delimited tokens with a colon and in

00:20:37,109 --> 00:20:41,489
this case the the domain or the type of

00:20:39,149 --> 00:20:43,649
data is represented in the first token

00:20:41,489 --> 00:20:45,840
the behavior being taken is the second

00:20:43,649 --> 00:20:47,940
token and the actual identifier of the

00:20:45,840 --> 00:20:50,220
instance to interact with is the the

00:20:47,940 --> 00:20:52,619
third token and so you can take that

00:20:50,220 --> 00:20:54,359
string pass it into you know if current

00:20:52,619 --> 00:20:56,039
user is permitted to do that permission

00:20:54,359 --> 00:20:58,649
then maybe I show the button maybe

00:20:56,039 --> 00:21:00,749
otherwise I don't so this is a case

00:20:58,649 --> 00:21:03,269
where it's convenient to create strings

00:21:00,749 --> 00:21:04,830
and again your realm is responsible for

00:21:03,269 --> 00:21:06,359
translating these things into permission

00:21:04,830 --> 00:21:07,830
instances that Shiro knows how to

00:21:06,359 --> 00:21:10,080
interact with

00:21:07,830 --> 00:21:12,090
and by default all the the base realms

00:21:10,080 --> 00:21:13,800
that Cheryl provides translate these

00:21:12,090 --> 00:21:14,760
automatically to wildcard permissions so

00:21:13,800 --> 00:21:19,340
you don't have to do that if you don't

00:21:14,760 --> 00:21:22,800
want to so there's that option

00:21:19,340 --> 00:21:25,830
there's also annotation checks so in

00:21:22,800 --> 00:21:27,540
this example maybe I want to open an

00:21:25,830 --> 00:21:29,730
account but the only people that should

00:21:27,540 --> 00:21:31,710
be able to do that have are that those

00:21:29,730 --> 00:21:37,559
that are in the teller role bank teller

00:21:31,710 --> 00:21:39,990
and so if code executes and the current

00:21:37,559 --> 00:21:42,059
subject does not have the teller role

00:21:39,990 --> 00:21:44,010
then this method won't ever be invoked

00:21:42,059 --> 00:21:45,780
and accept an authorization exception

00:21:44,010 --> 00:21:49,050
will be thrown you know probably a

00:21:45,780 --> 00:21:50,670
transaction would be a rollback but you

00:21:49,050 --> 00:21:53,730
can use a notations to prevent methods

00:21:50,670 --> 00:21:56,390
from being executed similarly there's

00:21:53,730 --> 00:21:59,190
also in annotation for permission checks

00:21:56,390 --> 00:22:01,620
so you can have you know comma delimited

00:21:59,190 --> 00:22:03,510
list of one or more of these to make

00:22:01,620 --> 00:22:05,580
sure that the current subject is

00:22:03,510 --> 00:22:09,990
permitted to do these things before the

00:22:05,580 --> 00:22:12,320
method is executed any questions about

00:22:09,990 --> 00:22:12,320
authorization

00:22:16,549 --> 00:22:21,450
that is actually dependent upon your

00:22:18,690 --> 00:22:25,230
runtime environment so Shiro has aspectj

00:22:21,450 --> 00:22:26,820
support by default we have integration

00:22:25,230 --> 00:22:29,130
for spring as well so if you're using

00:22:26,820 --> 00:22:32,520
spring it just uses Springs EOP based

00:22:29,130 --> 00:22:34,380
proxy support juice has its own

00:22:32,520 --> 00:22:36,030
mechanism I believe for this stuff but

00:22:34,380 --> 00:22:39,240
it's really based on whatever your

00:22:36,030 --> 00:22:41,549
runtime is that you want you could just

00:22:39,240 --> 00:22:49,650
plug in whatever AOP support that we

00:22:41,549 --> 00:22:52,650
have another question so that was acts

00:22:49,650 --> 00:22:56,220
authorization in authentication and

00:22:52,650 --> 00:22:58,080
that's where most of the modern kind of

00:22:56,220 --> 00:23:00,929
security frameworks stop in their their

00:22:58,080 --> 00:23:03,480
scope but she wrote actually goes in

00:23:00,929 --> 00:23:05,909
deals with a couple other things that we

00:23:03,480 --> 00:23:08,640
feel are pretty critical to a security

00:23:05,909 --> 00:23:11,220
experience and those are session

00:23:08,640 --> 00:23:13,110
management cryptography so I'll cover

00:23:11,220 --> 00:23:15,690
session management now session

00:23:13,110 --> 00:23:17,130
management is managing the lifecycle of

00:23:15,690 --> 00:23:18,870
a subject-specific

00:23:17,130 --> 00:23:21,179
temporal data context and that's really

00:23:18,870 --> 00:23:23,429
just a mouthful to mean what we're all

00:23:21,179 --> 00:23:26,010
comfortable and familiar with with HTTP

00:23:23,429 --> 00:23:27,480
sessions raise the session represents a

00:23:26,010 --> 00:23:30,809
bunch of data that's specific to a

00:23:27,480 --> 00:23:32,309
particular end user and you can you know

00:23:30,809 --> 00:23:34,289
add or remove data from it in the

00:23:32,309 --> 00:23:38,960
context goes away when the users either

00:23:34,289 --> 00:23:41,700
logged out or their session expires so

00:23:38,960 --> 00:23:44,850
nothing out of the ordinary if you know

00:23:41,700 --> 00:23:46,980
based on the HTTP sessions here are some

00:23:44,850 --> 00:23:50,159
features so one of the cool things about

00:23:46,980 --> 00:23:52,409
Shiro is that it allows heterogeneous

00:23:50,159 --> 00:23:55,080
client access and by that I mean as long

00:23:52,409 --> 00:23:57,390
as you have a secure handle to like a

00:23:55,080 --> 00:23:59,100
session identifier you can access

00:23:57,390 --> 00:24:02,730
session state and contribute to session

00:23:59,100 --> 00:24:04,470
state from any client technology so part

00:24:02,730 --> 00:24:05,970
of this came out years ago when I was

00:24:04,470 --> 00:24:09,150
working on a government contract and

00:24:05,970 --> 00:24:12,990
they had a Java based web application

00:24:09,150 --> 00:24:15,809
and a desktop java application or an

00:24:12,990 --> 00:24:17,490
embedded Java applet and two of those

00:24:15,809 --> 00:24:19,890
are technically fundamentally different

00:24:17,490 --> 00:24:21,990
types of client technologies but they

00:24:19,890 --> 00:24:24,240
both needed to share and operate with

00:24:21,990 --> 00:24:26,520
and share data in the same actual

00:24:24,240 --> 00:24:28,440
session ejbs couldn't do this at the

00:24:26,520 --> 00:24:30,480
time because they EJB

00:24:28,440 --> 00:24:31,830
maintain communication state and of

00:24:30,480 --> 00:24:35,180
course the webserver didn't know about a

00:24:31,830 --> 00:24:37,620
desktop-based operating mechanism so

00:24:35,180 --> 00:24:39,240
Shiro allows you from different clients

00:24:37,620 --> 00:24:42,030
to access the same session state if need

00:24:39,240 --> 00:24:43,530
be everything in Shiro session

00:24:42,030 --> 00:24:46,500
management and actually everything in

00:24:43,530 --> 00:24:48,270
Shiro in general is POJO j2se based it's

00:24:46,500 --> 00:24:50,970
IOC friendly so you don't need any

00:24:48,270 --> 00:24:54,330
special interfaces or api's to make sure

00:24:50,970 --> 00:24:55,770
I'll work like the authentication there

00:24:54,330 --> 00:24:57,240
are event listener so you can listen to

00:24:55,770 --> 00:25:00,090
various events during the sessions

00:24:57,240 --> 00:25:04,110
lifecycle when users log in when they

00:25:00,090 --> 00:25:05,520
log out there's also we also retain the

00:25:04,110 --> 00:25:07,860
host address from where the sessions

00:25:05,520 --> 00:25:09,840
initiated so if you for example in

00:25:07,860 --> 00:25:11,820
intranet kind of security policies you

00:25:09,840 --> 00:25:13,530
might want to restrict access to

00:25:11,820 --> 00:25:15,270
applications based on the host IP from

00:25:13,530 --> 00:25:17,250
where they originate so will retain that

00:25:15,270 --> 00:25:20,760
information if that's necessary for you

00:25:17,250 --> 00:25:22,350
in security policies and we also offered

00:25:20,760 --> 00:25:25,290
this notion of inactivity and expiration

00:25:22,350 --> 00:25:27,180
support be a touch method so if you're

00:25:25,290 --> 00:25:30,390
creating a rich client application like

00:25:27,180 --> 00:25:33,360
a flex application or a JavaScript

00:25:30,390 --> 00:25:36,510
application and the end users actively

00:25:33,360 --> 00:25:39,360
using the the user interface but they're

00:25:36,510 --> 00:25:41,460
not invoking any server-side calls it's

00:25:39,360 --> 00:25:43,170
it's likely that the server-side session

00:25:41,460 --> 00:25:45,810
will expire even though they're actively

00:25:43,170 --> 00:25:48,770
using the software and so there's a

00:25:45,810 --> 00:25:51,330
touch method that can be invoked on

00:25:48,770 --> 00:25:53,550
behalf of a client that will just keep

00:25:51,330 --> 00:25:55,050
the session alive to make sure that it

00:25:53,550 --> 00:25:57,360
doesn't expire if they're legitimately

00:25:55,050 --> 00:26:01,050
using the software application so maybe

00:25:57,360 --> 00:26:02,820
in like a flex or a JavaScript app you

00:26:01,050 --> 00:26:04,080
can send in a request of the server

00:26:02,820 --> 00:26:06,090
every five minutes to prevent it from

00:26:04,080 --> 00:26:09,210
timing out if they're actually using the

00:26:06,090 --> 00:26:12,720
software and it's also transparent in

00:26:09,210 --> 00:26:15,090
the web tier so Shiro implements the

00:26:12,720 --> 00:26:16,920
servlet specification for HTTP the HTTP

00:26:15,090 --> 00:26:19,440
session API and they should be servlet

00:26:16,920 --> 00:26:22,050
request API so you can use Shiro

00:26:19,440 --> 00:26:23,580
sessions inside of any servlet container

00:26:22,050 --> 00:26:26,940
like Tomcat or jetty or what have you

00:26:23,580 --> 00:26:29,580
and your code doesn't have to change

00:26:26,940 --> 00:26:32,400
because it's the same API one of the

00:26:29,580 --> 00:26:33,960
nice probably the most powerful reasons

00:26:32,400 --> 00:26:35,700
for doing this is that you can now get

00:26:33,960 --> 00:26:38,280
container independent session clustering

00:26:35,700 --> 00:26:41,160
so Shiro allows you to plug in a

00:26:38,280 --> 00:26:42,030
clustering data store or cluster data

00:26:41,160 --> 00:26:43,470
store in

00:26:42,030 --> 00:26:45,720
it's session management infrastructure

00:26:43,470 --> 00:26:47,820
and that means that you don't have to

00:26:45,720 --> 00:26:51,660
change your your session clustering

00:26:47,820 --> 00:26:53,420
configuration much whether you're in

00:26:51,660 --> 00:26:56,490
development or you go into production or

00:26:53,420 --> 00:26:58,560
you know alpha-beta so if you're using

00:26:56,490 --> 00:27:01,830
maybe you know Toronto MO and production

00:26:58,560 --> 00:27:04,250
and jetty in testing you don't have to

00:27:01,830 --> 00:27:07,020
change any of that

00:27:04,250 --> 00:27:09,210
cluster configuration because it Shiro

00:27:07,020 --> 00:27:11,250
just works with it all so if they all

00:27:09,210 --> 00:27:12,900
point to say a memcache cluster none of

00:27:11,250 --> 00:27:14,340
your applications configuration needs to

00:27:12,900 --> 00:27:16,590
change based on environment that's got a

00:27:14,340 --> 00:27:18,990
lot of a real bit of appeal for people

00:27:16,590 --> 00:27:22,710
that have to work in multi environment

00:27:18,990 --> 00:27:24,150
scenarios the other benefit is that once

00:27:22,710 --> 00:27:26,580
you once you cluster and share at once

00:27:24,150 --> 00:27:28,110
you don't have to worry about how to do

00:27:26,580 --> 00:27:29,970
things specifically in jetty or in

00:27:28,110 --> 00:27:31,230
tomcat or geronimo or JBoss right it's

00:27:29,970 --> 00:27:32,370
all done the same way you don't have to

00:27:31,230 --> 00:27:38,730
worry about multiple different

00:27:32,370 --> 00:27:41,760
clustering mechanisms so how do I create

00:27:38,730 --> 00:27:44,130
a session or how do I get access to one

00:27:41,760 --> 00:27:46,320
it's basically identical to what you've

00:27:44,130 --> 00:27:49,110
seen with it the servlet request API or

00:27:46,320 --> 00:27:52,530
the httpservletrequest except replace

00:27:49,110 --> 00:27:54,450
requests with subject so when I call

00:27:52,530 --> 00:27:56,130
subject get session it guarantees that a

00:27:54,450 --> 00:27:57,720
session exists if it doesn't exist it

00:27:56,130 --> 00:28:00,360
will automatically create one at that

00:27:57,720 --> 00:28:02,190
time otherwise I can pass in a boolean

00:28:00,360 --> 00:28:03,900
argument to say you know give me the

00:28:02,190 --> 00:28:06,330
session if it exists but don't create

00:28:03,900 --> 00:28:07,650
one for me if it doesn't so we're all

00:28:06,330 --> 00:28:09,750
very familiar and comfortable with these

00:28:07,650 --> 00:28:12,870
things based on the server that request

00:28:09,750 --> 00:28:14,730
API I should also note though this is

00:28:12,870 --> 00:28:16,620
actually a really important point for

00:28:14,730 --> 00:28:17,910
this stuff is sessions work in any

00:28:16,620 --> 00:28:19,920
environment you don't have to be in an

00:28:17,910 --> 00:28:22,260
HTTP server you don't have to be an EJB

00:28:19,920 --> 00:28:23,820
server we have people with you know

00:28:22,260 --> 00:28:25,320
using share and mobile phones creating

00:28:23,820 --> 00:28:29,130
server-side sessions even though they're

00:28:25,320 --> 00:28:31,200
not using the HTTP protocol so the same

00:28:29,130 --> 00:28:33,360
unified session experience that the API

00:28:31,200 --> 00:28:35,010
works in any tier in any deployment

00:28:33,360 --> 00:28:36,990
environment regardless of your container

00:28:35,010 --> 00:28:41,760
which is a really nice benefit to for

00:28:36,990 --> 00:28:43,650
consistency and the API is again what

00:28:41,760 --> 00:28:45,750
you probably expect there's a start

00:28:43,650 --> 00:28:47,220
timestamp the last access time and

00:28:45,750 --> 00:28:48,300
getting set attributes you can set the

00:28:47,220 --> 00:28:50,040
timeout of the session

00:28:48,300 --> 00:28:52,710
there's the touch method that we covered

00:28:50,040 --> 00:28:54,210
briefly where you can prolong the

00:28:52,710 --> 00:28:56,500
sessions lifetime if

00:28:54,210 --> 00:28:58,480
all things that were mostly comfortable

00:28:56,500 --> 00:29:03,180
with with the servlet request API same

00:28:58,480 --> 00:29:03,180
kind of mirrored API in Shiro session

00:29:03,240 --> 00:29:09,640
any questions about the session API

00:29:07,270 --> 00:29:21,220
before we move on or how sessions work

00:29:09,640 --> 00:29:23,350
how session clustering yes is the

00:29:21,220 --> 00:29:33,790
time-out stuff linked to the remember me

00:29:23,350 --> 00:29:35,260
stuff for authentication no they're

00:29:33,790 --> 00:29:36,090
they're independent they're not linked

00:29:35,260 --> 00:29:38,680
at all

00:29:36,090 --> 00:29:42,100
so in Shiro there's a there's this

00:29:38,680 --> 00:29:43,750
notion so as you saw the authentication

00:29:42,100 --> 00:29:45,610
right you have this master security

00:29:43,750 --> 00:29:47,500
manager that wrapped an Authenticator

00:29:45,610 --> 00:29:49,750
well there's also a Remember Me manager

00:29:47,500 --> 00:29:52,090
that it wraps in addition and you can

00:29:49,750 --> 00:29:54,100
configure that to specify how long the

00:29:52,090 --> 00:29:55,750
cookie stays alive or you know any other

00:29:54,100 --> 00:29:57,370
storage techniques other than cookies

00:29:55,750 --> 00:30:00,280
perhaps you know you get to configure

00:29:57,370 --> 00:30:02,050
how that stuff operates but it's

00:30:00,280 --> 00:30:05,530
actually an interesting point I'm glad

00:30:02,050 --> 00:30:07,840
you brought that up there's this notion

00:30:05,530 --> 00:30:09,640
in Shiro of remember me versus

00:30:07,840 --> 00:30:11,020
authentication state and Shiro

00:30:09,640 --> 00:30:13,900
distinguishes the two completely

00:30:11,020 --> 00:30:16,180
separate on purpose for security reasons

00:30:13,900 --> 00:30:19,840
and here's a really good example let's

00:30:16,180 --> 00:30:21,400
say you're using amazon.com and you log

00:30:19,840 --> 00:30:23,620
in one day and you add some books to

00:30:21,400 --> 00:30:24,640
your shopping cart but then you go home

00:30:23,620 --> 00:30:26,520
at the end of the business day you

00:30:24,640 --> 00:30:30,580
forget to logout and you come back

00:30:26,520 --> 00:30:32,050
tomorrow Amazon will remember who you

00:30:30,580 --> 00:30:34,210
are right it remembers your name it

00:30:32,050 --> 00:30:36,760
shows you what what your recommendations

00:30:34,210 --> 00:30:38,170
are and maybe your cart but if you want

00:30:36,760 --> 00:30:41,290
to change your credit card at that time

00:30:38,170 --> 00:30:42,880
Amazon forces you to log in because your

00:30:41,290 --> 00:30:44,620
authentication state with Amazon is

00:30:42,880 --> 00:30:46,270
remembered but you're not authenticated

00:30:44,620 --> 00:30:49,990
authentication has a very strong

00:30:46,270 --> 00:30:52,270
connotation with proof and so Shiro

00:30:49,990 --> 00:30:54,700
retains that state for you automatically

00:30:52,270 --> 00:30:56,860
and so on the subject api you can do

00:30:54,700 --> 00:30:58,930
subject is authenticated or dot is

00:30:56,860 --> 00:31:01,660
remember me and there are THOG '''l

00:30:58,930 --> 00:31:02,890
actually opposing concerns so if one

00:31:01,660 --> 00:31:05,260
returns true the other is going to

00:31:02,890 --> 00:31:06,730
return false when we do that

00:31:05,260 --> 00:31:09,190
specifically for the scenario that

00:31:06,730 --> 00:31:10,660
just outlined because you're remembered

00:31:09,190 --> 00:31:12,220
by cookie it does not mean that you've

00:31:10,660 --> 00:31:13,510
actually proven your identity in the

00:31:12,220 --> 00:31:14,679
context of the current session and

00:31:13,510 --> 00:31:16,690
that's really important for things like

00:31:14,679 --> 00:31:21,250
you know the scenario I just described

00:31:16,690 --> 00:31:22,690
or banking situations but she remembers

00:31:21,250 --> 00:31:26,460
that state so you don't have to worry

00:31:22,690 --> 00:31:26,460
about how to resolve that that issue

00:31:27,750 --> 00:31:31,890
okay any other questions about sessions

00:31:32,160 --> 00:31:36,240
okay let's talk about cryptography

00:31:36,690 --> 00:31:41,169
cryptography as you might expect is

00:31:39,309 --> 00:31:43,390
basically protecting information from

00:31:41,169 --> 00:31:46,210
undesired access by hiding it or

00:31:43,390 --> 00:31:48,340
converting it to nonsense and so the the

00:31:46,210 --> 00:31:49,960
core kind of elements of cryptography

00:31:48,340 --> 00:31:55,110
that Shiro supports is this notion of

00:31:49,960 --> 00:31:59,230
ciphers and hashes when the cipher is a

00:31:55,110 --> 00:32:00,640
encryption or encrypt sorry a cipher

00:31:59,230 --> 00:32:02,620
allows you to encrypt and decrypt data

00:32:00,640 --> 00:32:05,880
based on shared and or public private

00:32:02,620 --> 00:32:09,280
keys it's a transformation process a

00:32:05,880 --> 00:32:12,730
mathematical algorithm based on the

00:32:09,280 --> 00:32:14,650
notion of keys and there's two types of

00:32:12,730 --> 00:32:17,200
ciphers that come up frequently there's

00:32:14,650 --> 00:32:19,750
notions of symmetric ciphers which use

00:32:17,200 --> 00:32:22,150
the same or trivially similar key to

00:32:19,750 --> 00:32:23,919
encrypt and decrypt data and within

00:32:22,150 --> 00:32:25,679
symmetric ciphers there's two types of

00:32:23,919 --> 00:32:29,080
them there's really block ciphers and

00:32:25,679 --> 00:32:31,360
stream ciphers it's important to know

00:32:29,080 --> 00:32:33,190
here however that a stream cipher

00:32:31,360 --> 00:32:35,470
doesn't just encrypt streams of data

00:32:33,190 --> 00:32:37,360
like an input stream for example and a

00:32:35,470 --> 00:32:40,540
block cipher only works on on byte

00:32:37,360 --> 00:32:42,820
arrays the notion of the word stream has

00:32:40,540 --> 00:32:44,380
to deal with the key itself not not what

00:32:42,820 --> 00:32:46,990
you're encrypting or decrypting so a

00:32:44,380 --> 00:32:49,660
stream cipher has a stream of key bits

00:32:46,990 --> 00:32:52,990
and a block cipher has a chunk of bits

00:32:49,660 --> 00:32:54,669
basically a byte array in addition to

00:32:52,990 --> 00:32:56,679
symmetric ciphers there's asymmetric

00:32:54,669 --> 00:32:58,360
ciphers which use totally different keys

00:32:56,679 --> 00:33:01,210
so you know the RSA kind of

00:32:58,360 --> 00:33:02,740
public/private key approach that we're

00:33:01,210 --> 00:33:07,600
all familiar with is an example of an

00:33:02,740 --> 00:33:09,760
asymmetric cipher and hashes so a hash

00:33:07,600 --> 00:33:12,910
is a one-way irreversible conversion of

00:33:09,760 --> 00:33:16,150
an input source this is also known as a

00:33:12,910 --> 00:33:17,770
message digest and it's most commonly

00:33:16,150 --> 00:33:19,179
used for credentials transformation so

00:33:17,770 --> 00:33:20,150
if I've got a password and I want to

00:33:19,179 --> 00:33:21,950
chain

00:33:20,150 --> 00:33:25,160
a format that people can't understand or

00:33:21,950 --> 00:33:27,410
can't can't reverse you can you can use

00:33:25,160 --> 00:33:29,780
it for passwords it's also obviously

00:33:27,410 --> 00:33:33,590
like md5 is used to create check sums

00:33:29,780 --> 00:33:35,300
for files so you can see if a files been

00:33:33,590 --> 00:33:36,800
manipulated and transmitted you can

00:33:35,300 --> 00:33:39,710
check the checksum to say to make sure

00:33:36,800 --> 00:33:42,350
that it's the same and Shiro can be used

00:33:39,710 --> 00:33:46,600
can can basically hash anything with an

00:33:42,350 --> 00:33:48,800
underlying byte array so files streams

00:33:46,600 --> 00:33:51,830
and we'll show you an example that API

00:33:48,800 --> 00:33:53,390
in just a second so some of the stuff

00:33:51,830 --> 00:33:55,370
that we really focused on when creating

00:33:53,390 --> 00:33:57,830
the cryptography stuff and cheero is

00:33:55,370 --> 00:34:00,440
that again we wanted to really focus on

00:33:57,830 --> 00:34:01,640
simplicity regardless of your knowledge

00:34:00,440 --> 00:34:04,010
or understanding of underlying

00:34:01,640 --> 00:34:06,050
cryptographic concepts it's all

00:34:04,010 --> 00:34:10,400
interface driven and pojo based so

00:34:06,050 --> 00:34:11,900
there's no no surprises there we we

00:34:10,400 --> 00:34:14,090
don't however implement our own

00:34:11,900 --> 00:34:16,430
cryptography infrastructure we sit on

00:34:14,090 --> 00:34:20,180
top of the existing jce that's part of

00:34:16,430 --> 00:34:21,740
the JDK so we're not there to reinvent

00:34:20,180 --> 00:34:24,410
the wheel and rewrite all the crypto

00:34:21,740 --> 00:34:25,850
algorithms we sit on what exists already

00:34:24,410 --> 00:34:29,450
so that means if you like for example

00:34:25,850 --> 00:34:31,490
plug-in bouncy castle into your your jce

00:34:29,450 --> 00:34:34,580
environment Shiro can now work with that

00:34:31,490 --> 00:34:35,780
stuff as well but the big reason why it

00:34:34,580 --> 00:34:37,880
exists is that kind of really

00:34:35,780 --> 00:34:39,470
object-oriented eyes a lot of these

00:34:37,880 --> 00:34:41,390
cryptography concepts if you've ever

00:34:39,470 --> 00:34:43,640
worked with how many people in here have

00:34:41,390 --> 00:34:46,490
worked with the the JDK jce cipher

00:34:43,640 --> 00:34:47,870
object okay great that's awesome I'm

00:34:46,490 --> 00:34:49,940
glad to see we have a large

00:34:47,870 --> 00:34:51,920
representation so as you probably know

00:34:49,940 --> 00:34:53,870
it's not fun to work with write stateful

00:34:51,920 --> 00:34:56,210
it throws a lot of checked exceptions

00:34:53,870 --> 00:34:57,590
it's a pain in the ass to use and you

00:34:56,210 --> 00:34:58,910
have to be really careful about it you

00:34:57,590 --> 00:35:01,400
know the constructor arguments that are

00:34:58,910 --> 00:35:05,000
or at least that are used to acquire one

00:35:01,400 --> 00:35:06,800
it is it is not fun Shiro's wrapper

00:35:05,000 --> 00:35:08,570
api's are a lot cleaner a lot easier to

00:35:06,800 --> 00:35:11,570
use and the API is much easier to

00:35:08,570 --> 00:35:14,420
understand so ultimately it's it's a

00:35:11,570 --> 00:35:16,880
hierarchy I that we've changed it into a

00:35:14,420 --> 00:35:18,440
service level kind of mechanism or you

00:35:16,880 --> 00:35:19,370
invoke a method on a service and you get

00:35:18,440 --> 00:35:20,660
a result you know if they're worried

00:35:19,370 --> 00:35:23,720
about state you don't have to worry

00:35:20,660 --> 00:35:26,510
about the difficulties in managing the

00:35:23,720 --> 00:35:29,090
state and so you'll see in zeros API

00:35:26,510 --> 00:35:30,800
there's a JC a cipher service there's an

00:35:29,090 --> 00:35:32,450
abstract symmetric cipher services a

00:35:30,800 --> 00:35:34,550
default block cipher service

00:35:32,450 --> 00:35:39,320
so we have a hierarchy that represents

00:35:34,550 --> 00:35:41,300
the mathematical concepts that are true

00:35:39,320 --> 00:35:43,579
to their nature and in cheery you just

00:35:41,300 --> 00:35:45,829
instantiate a class if you again if

00:35:43,579 --> 00:35:47,119
you've worked with the jce and you want

00:35:45,829 --> 00:35:48,890
to acquire say for instance you have to

00:35:47,119 --> 00:35:50,660
specify this crazy thing called a

00:35:48,890 --> 00:35:53,060
transformation string using a factory

00:35:50,660 --> 00:35:54,829
methods where you take these strings and

00:35:53,060 --> 00:35:56,359
you delimit them what slashes and then

00:35:54,829 --> 00:35:57,530
you hope to god that your configuration

00:35:56,359 --> 00:36:01,369
is correct and you just call the method

00:35:57,530 --> 00:36:04,130
and see if it works which is not oo and

00:36:01,369 --> 00:36:06,440
it's it's it's not type safe you know

00:36:04,130 --> 00:36:09,230
it's a little weird for me to see that

00:36:06,440 --> 00:36:10,460
kind of stuff in in the JDK but they're

00:36:09,230 --> 00:36:11,420
paying to work with and if you don't

00:36:10,460 --> 00:36:12,920
understand what the configuration

00:36:11,420 --> 00:36:16,910
parameters are in this transformation

00:36:12,920 --> 00:36:18,950
string you could obviously break

00:36:16,910 --> 00:36:22,310
something and even worse have less

00:36:18,950 --> 00:36:23,829
secure encryption going on because you

00:36:22,310 --> 00:36:25,700
don't understand what these things mean

00:36:23,829 --> 00:36:27,349
the other really important thing about

00:36:25,700 --> 00:36:29,900
Shearer's wrap around this stuff is that

00:36:27,349 --> 00:36:33,740
we provide more secure default settings

00:36:29,900 --> 00:36:36,050
in the JDK so things like cipher modes

00:36:33,740 --> 00:36:38,000
of operation initialization vectors we

00:36:36,050 --> 00:36:39,440
we automate and incorporate these things

00:36:38,000 --> 00:36:44,630
out of the box even if you have no idea

00:36:39,440 --> 00:36:46,930
what they are so I'll give you an

00:36:44,630 --> 00:36:49,900
example of how this works

00:36:46,930 --> 00:36:52,010
JDK by default uses I think the ECB

00:36:49,900 --> 00:36:54,890
cipher mode which is the stands for

00:36:52,010 --> 00:36:56,599
electronic cookbook and the ECB's cipher

00:36:54,890 --> 00:36:59,630
mode for block ciphers is not really

00:36:56,599 --> 00:37:02,060
secure at all and as an example you know

00:36:59,630 --> 00:37:04,700
let's say we wanted to encrypt you know

00:37:02,060 --> 00:37:06,349
this image of tux and this this is our

00:37:04,700 --> 00:37:08,900
plaintext that's gonna go in through

00:37:06,349 --> 00:37:10,069
encryption and we're just gonna you know

00:37:08,900 --> 00:37:11,359
create a cipher using a default

00:37:10,069 --> 00:37:13,579
transformation sharing maybe some

00:37:11,359 --> 00:37:15,400
factory string that I picked up off the

00:37:13,579 --> 00:37:18,230
internet that I copied and pasted and

00:37:15,400 --> 00:37:19,609
obviously I'm using AES 256-bit and

00:37:18,230 --> 00:37:22,150
everything's gonna work fine and I feel

00:37:19,609 --> 00:37:27,230
good about my encryption and we're fine

00:37:22,150 --> 00:37:29,780
but that's not the case because if you

00:37:27,230 --> 00:37:31,430
don't change the mode of operation to

00:37:29,780 --> 00:37:33,109
something other than ECB this is the

00:37:31,430 --> 00:37:35,210
resulting output of the encrypted image

00:37:33,109 --> 00:37:37,190
which as you can see is not secure at

00:37:35,210 --> 00:37:39,020
all your data is not secure if you use

00:37:37,190 --> 00:37:41,060
the standard JDK settings and most

00:37:39,020 --> 00:37:42,220
people don't realize to change these

00:37:41,060 --> 00:37:45,290
things when they're using encryption

00:37:42,220 --> 00:37:47,030
they just think oh it's 256 bit AES I

00:37:45,290 --> 00:37:50,510
must be

00:37:47,030 --> 00:37:53,010
however Shiro does do do the the more

00:37:50,510 --> 00:37:55,500
complicated things such as changing the

00:37:53,010 --> 00:37:57,240
mode auto generating an initialization

00:37:55,500 --> 00:37:58,920
vector how many people here know what

00:37:57,240 --> 00:38:00,119
initialization vector is all right

00:37:58,920 --> 00:38:01,800
better question how many people do not

00:38:00,119 --> 00:38:05,309
know what in theirs initialization

00:38:01,800 --> 00:38:08,730
vectors okay so an initialization vector

00:38:05,309 --> 00:38:10,589
is ideally a seed of random data the

00:38:08,730 --> 00:38:13,770
kick-starts your encryption process and

00:38:10,589 --> 00:38:15,690
so if you have a random byte array a

00:38:13,770 --> 00:38:18,480
random seed from a secure random number

00:38:15,690 --> 00:38:21,690
generator and that's incorporated in

00:38:18,480 --> 00:38:23,520
your cipher algorithm all the bits that

00:38:21,690 --> 00:38:25,680
come out of your cipher process are

00:38:23,520 --> 00:38:27,780
randomized you know based on that

00:38:25,680 --> 00:38:29,130
initial token or that initial seed and

00:38:27,780 --> 00:38:31,680
that's really it's basically like having

00:38:29,130 --> 00:38:33,240
a salt for a hash right you need some

00:38:31,680 --> 00:38:35,160
sort of random input data to make sure

00:38:33,240 --> 00:38:38,160
your output is secure if you don't

00:38:35,160 --> 00:38:40,829
provide an initialization vector you can

00:38:38,160 --> 00:38:42,150
encrypt this image for example 20

00:38:40,829 --> 00:38:43,859
different times and you'll see the same

00:38:42,150 --> 00:38:45,569
thing 20 different times it's not a good

00:38:43,859 --> 00:38:47,819
thing if you provide an initialization

00:38:45,569 --> 00:38:49,559
vector however this is what the output

00:38:47,819 --> 00:38:51,540
would look like so it's completely

00:38:49,559 --> 00:38:53,640
randomized you can't infer at all what

00:38:51,540 --> 00:38:55,530
was behind that data and Shiro

00:38:53,640 --> 00:38:57,329
automatically creates in a pens

00:38:55,530 --> 00:38:59,339
initialization vector data to your

00:38:57,329 --> 00:39:06,720
encrypted output so you don't ever have

00:38:59,339 --> 00:39:10,680
to worry about these things yes c.b.c is

00:39:06,720 --> 00:39:13,470
a default so because anything greater

00:39:10,680 --> 00:39:19,490
than 128-bit requires the jce extensions

00:39:13,470 --> 00:39:23,280
we default 128-bit AES encryption with

00:39:19,490 --> 00:39:26,369
CBC mode of encryption and of course we

00:39:23,280 --> 00:39:27,839
Auto generate an initialization vector

00:39:26,369 --> 00:39:29,910
equivalent to the block size of the

00:39:27,839 --> 00:39:31,230
algorithm but again if you don't know

00:39:29,910 --> 00:39:33,180
what any of this stuff means you can

00:39:31,230 --> 00:39:35,640
rest assured that when you use 0 you're

00:39:33,180 --> 00:39:37,650
gonna get some secure output and then

00:39:35,640 --> 00:39:39,809
you can configure these things in the

00:39:37,650 --> 00:39:41,190
settings and the ECB mode in the padding

00:39:39,809 --> 00:39:42,630
scheme and all these other things you

00:39:41,190 --> 00:39:43,920
can configure them as simple poggio

00:39:42,630 --> 00:39:44,460
properties on the cipher that you've

00:39:43,920 --> 00:39:45,329
created

00:39:44,460 --> 00:39:46,920
you know if to worry about

00:39:45,329 --> 00:39:48,690
transformation strings you get type safe

00:39:46,920 --> 00:39:51,990
methods that you can that you can call

00:39:48,690 --> 00:39:53,579
and interact with much easier to use and

00:39:51,990 --> 00:39:55,140
understand as you start to learn more

00:39:53,579 --> 00:39:56,849
about the different security options on

00:39:55,140 --> 00:40:00,430
the ciphers

00:39:56,849 --> 00:40:05,430
so this is our cypher service unlike the

00:40:00,430 --> 00:40:08,140
cypher class in the JK it is a stateless

00:40:05,430 --> 00:40:11,410
mechanism basically you make a single

00:40:08,140 --> 00:40:13,059
call and what comes out it's a single

00:40:11,410 --> 00:40:15,849
method operation you make an you invoke

00:40:13,059 --> 00:40:17,950
it and your operation is done you can

00:40:15,849 --> 00:40:19,869
also excuse me encrypt and decrypt

00:40:17,950 --> 00:40:23,230
streams of data in addition or standard

00:40:19,869 --> 00:40:24,700
byte arrays and a byte source is just

00:40:23,230 --> 00:40:26,470
sheer a simple wrapper around the binary

00:40:24,700 --> 00:40:30,309
that allows you to do things like base64

00:40:26,470 --> 00:40:32,109
encoding and decoding but single method

00:40:30,309 --> 00:40:33,730
operation stateless when when the

00:40:32,109 --> 00:40:35,890
methods done your work is done you can

00:40:33,730 --> 00:40:37,270
move on with the data that comes out so

00:40:35,890 --> 00:40:38,950
much more aligned with what most

00:40:37,270 --> 00:40:43,180
application developers want out of a

00:40:38,950 --> 00:40:44,980
crypto API oh and again you don't see

00:40:43,180 --> 00:40:46,599
any exceptions here there is a cipher

00:40:44,980 --> 00:40:48,640
exception that Shiro has in fact Shiro

00:40:46,599 --> 00:40:49,869
has exceptions across the board our

00:40:48,640 --> 00:40:51,339
philosophy is that everything is a

00:40:49,869 --> 00:40:53,319
runtime exception you don't have to

00:40:51,339 --> 00:40:54,460
catch things if you don't want to but

00:40:53,319 --> 00:40:57,849
you can of course catch whatever you

00:40:54,460 --> 00:41:00,880
wish and it's all documented in the Java

00:40:57,849 --> 00:41:03,329
doc what's thrown so you're not forced

00:41:00,880 --> 00:41:06,490
to catch exceptions if you don't want to

00:41:03,329 --> 00:41:08,410
and so of course within Shiro's

00:41:06,490 --> 00:41:09,910
implementation there's you know default

00:41:08,410 --> 00:41:12,940
interface implementations with so we

00:41:09,910 --> 00:41:17,589
have md5 the sha-2 for sha-1 sha-256

00:41:12,940 --> 00:41:19,630
sha-2 family of hash algorithms there's

00:41:17,589 --> 00:41:21,789
built-in hexan base64 you know

00:41:19,630 --> 00:41:23,260
conversion which to this day blows my

00:41:21,789 --> 00:41:25,990
mind that they're actually part of the

00:41:23,260 --> 00:41:27,880
JDK still all these years later so

00:41:25,990 --> 00:41:30,730
Cheryl has them you know you can use

00:41:27,880 --> 00:41:32,710
them out of the box and there's also

00:41:30,730 --> 00:41:35,710
built in support for salts and repeated

00:41:32,710 --> 00:41:38,799
hashing for hashes and I'll explain why

00:41:35,710 --> 00:41:40,779
that's important a little bit so we saw

00:41:38,799 --> 00:41:43,630
the cipher service here's the hash

00:41:40,779 --> 00:41:45,279
interface it's very simple once the hash

00:41:43,630 --> 00:41:48,130
is computed you can get the bytes you

00:41:45,279 --> 00:41:49,440
can call two hex two base64 really nice

00:41:48,130 --> 00:41:52,390
you know you don't have to worry about

00:41:49,440 --> 00:41:53,940
how do I go find that that hacky chunk

00:41:52,390 --> 00:41:56,170
of code that I've looked at all the time

00:41:53,940 --> 00:41:58,299
on the internet a copy and paste of my

00:41:56,170 --> 00:42:01,390
project but you can use that or actually

00:41:58,299 --> 00:42:02,559
I think Commons has one as well but

00:42:01,390 --> 00:42:05,440
they're built into the interface you can

00:42:02,559 --> 00:42:07,680
call them and our our hashing API is

00:42:05,440 --> 00:42:09,600
also a much cleaner and more intuitive

00:42:07,680 --> 00:42:11,280
like we think compared to the message

00:42:09,600 --> 00:42:13,500
digest class in the JDK right you have

00:42:11,280 --> 00:42:15,570
to you have to use a factory method to

00:42:13,500 --> 00:42:18,630
get an algorithm you have to try catch

00:42:15,570 --> 00:42:21,030
you know messaging exception or whatever

00:42:18,630 --> 00:42:22,860
the JDK has for us you could just take

00:42:21,030 --> 00:42:24,510
in data into the constructor called two

00:42:22,860 --> 00:42:26,940
hex you can take in a file you can take

00:42:24,510 --> 00:42:29,790
in a stream you know maybe I have a

00:42:26,940 --> 00:42:31,650
password that I want to sha 512 it you

00:42:29,790 --> 00:42:33,510
know taking a hash maybe do a thousand

00:42:31,650 --> 00:42:36,120
iterations and then I can finally get

00:42:33,510 --> 00:42:37,770
the base64 value of that these are all

00:42:36,120 --> 00:42:40,350
things that we as application developers

00:42:37,770 --> 00:42:46,680
wish that we're in the JDK so they're in

00:42:40,350 --> 00:42:49,460
Shiro for sure any questions about the

00:42:46,680 --> 00:42:49,460
hashing support

00:42:53,570 --> 00:43:00,170
and you know anybody know why we have an

00:42:56,300 --> 00:43:01,820
iteration count on on the constructor so

00:43:00,170 --> 00:43:03,970
it takes in a password and an assault

00:43:01,820 --> 00:43:06,470
why would you have an iteration count

00:43:03,970 --> 00:43:10,940
why why would you why might you want to

00:43:06,470 --> 00:43:12,490
hash a password more than once what's

00:43:10,940 --> 00:43:16,640
that

00:43:12,490 --> 00:43:19,520
yep key strengthening in it basically

00:43:16,640 --> 00:43:21,380
computational complexity right the if

00:43:19,520 --> 00:43:23,210
I'm an attacker and I have access to the

00:43:21,380 --> 00:43:24,350
raw hash values maybe I've compromised

00:43:23,210 --> 00:43:27,980
your database and I can see your

00:43:24,350 --> 00:43:29,960
password hashes you know I might have a

00:43:27,980 --> 00:43:31,250
rainbow table while actually assaults

00:43:29,960 --> 00:43:33,620
help prevent against remove temples but

00:43:31,250 --> 00:43:35,690
I might have two for each one of the

00:43:33,620 --> 00:43:37,430
passwords try to encrypt or hash it a

00:43:35,690 --> 00:43:39,830
number of times maybe it's a thousand

00:43:37,430 --> 00:43:41,570
this a thousand by the way is just an

00:43:39,830 --> 00:43:44,180
example it's really bad to go that low

00:43:41,570 --> 00:43:45,320
because modern GPUs will easily you know

00:43:44,180 --> 00:43:48,470
be able to go through a thousand

00:43:45,320 --> 00:43:49,610
iterations on Shah really quickly but

00:43:48,470 --> 00:43:53,480
maybe half a million a million

00:43:49,610 --> 00:43:55,940
iterations this will increase the time

00:43:53,480 --> 00:43:57,860
that a comparison is required say for a

00:43:55,940 --> 00:43:59,510
login attempt maybe a little bit maybe

00:43:57,860 --> 00:44:00,050
like point two point three point four

00:43:59,510 --> 00:44:02,030
seconds

00:44:00,050 --> 00:44:04,070
that's negligible for most end users

00:44:02,030 --> 00:44:06,110
most people locking into a UI they'll

00:44:04,070 --> 00:44:07,160
never see that extra delay but if you're

00:44:06,110 --> 00:44:08,690
an attacker and you're trying to

00:44:07,160 --> 00:44:09,680
compromise hundreds of thousands of

00:44:08,690 --> 00:44:11,690
passwords that you were able to

00:44:09,680 --> 00:44:13,340
compromise from a database this will to

00:44:11,690 --> 00:44:14,540
exponentially increase the amount of

00:44:13,340 --> 00:44:17,750
time it takes you to try to compromise

00:44:14,540 --> 00:44:20,540
the password database so we recommend

00:44:17,750 --> 00:44:23,660
that use a complexity factor like an

00:44:20,540 --> 00:44:25,880
iteration count also probably in Shiro

00:44:23,660 --> 00:44:30,650
1.3 we'll have bcrypt natively supported

00:44:25,880 --> 00:44:33,350
using the blowfish blowfish key

00:44:30,650 --> 00:44:35,780
scheduler to artificially slow down the

00:44:33,350 --> 00:44:37,460
computing process so these are more

00:44:35,780 --> 00:44:39,530
techniques that are used to forward

00:44:37,460 --> 00:44:40,940
attackers in the event that your

00:44:39,530 --> 00:44:44,420
password database is actually

00:44:40,940 --> 00:44:46,190
compromised always salt your passwords

00:44:44,420 --> 00:44:47,780
they'll always without without question

00:44:46,190 --> 00:44:48,950
and they should always be random you

00:44:47,780 --> 00:44:50,210
should never have a salt based on

00:44:48,950 --> 00:44:51,740
something that can be derived like a

00:44:50,210 --> 00:44:57,290
user name or an email address or

00:44:51,740 --> 00:45:00,460
something so anyway it's really easy to

00:44:57,290 --> 00:45:02,720
create different hashes and Shiro and

00:45:00,460 --> 00:45:03,940
there's also a generic hash classic

00:45:02,720 --> 00:45:05,590
can't remember that a lot

00:45:03,940 --> 00:45:06,970
to pass in the name of the algorithm so

00:45:05,590 --> 00:45:08,470
if there's a hash auger and you want to

00:45:06,970 --> 00:45:10,450
use that's not part of the JDK maybe

00:45:08,470 --> 00:45:14,140
it's an bouncy castle or something you

00:45:10,450 --> 00:45:15,850
can pass that in as well ok any

00:45:14,140 --> 00:45:23,170
questions about cryptography and hashing

00:45:15,850 --> 00:45:24,580
before we go into web support so the web

00:45:23,170 --> 00:45:26,250
is obviously super important these days

00:45:24,580 --> 00:45:28,450
and so Shiro

00:45:26,250 --> 00:45:29,920
although the four cornerstones are the

00:45:28,450 --> 00:45:31,869
basis of the framework we have really

00:45:29,920 --> 00:45:33,430
really good in solid web support in fact

00:45:31,869 --> 00:45:35,880
probably the majority of people you sure

00:45:33,430 --> 00:45:37,900
use it because of the web support

00:45:35,880 --> 00:45:40,600
setting it up is pretty easy it's a

00:45:37,900 --> 00:45:43,240
basically a simple web filter inside a

00:45:40,600 --> 00:45:44,980
webbed XML and you can use sheer to

00:45:43,240 --> 00:45:47,050
protect all of the URL endpoints in your

00:45:44,980 --> 00:45:48,900
application it's got some pretty

00:45:47,050 --> 00:45:52,420
innovative innovative filtering um

00:45:48,900 --> 00:45:55,930
techniques with URL specific filter

00:45:52,420 --> 00:45:58,119
chains so if you've ever had you know

00:45:55,930 --> 00:46:00,730
filter soup inside of web.xml trying to

00:45:58,119 --> 00:46:02,470
figure out what filters are processing

00:46:00,730 --> 00:46:02,890
which requests is a really big pain in

00:46:02,470 --> 00:46:06,460
the butt

00:46:02,890 --> 00:46:08,590
Shiro has a really nice clean way of

00:46:06,460 --> 00:46:10,270
helping you determine the exact flow of

00:46:08,590 --> 00:46:12,609
a request through a chain and it's easy

00:46:10,270 --> 00:46:14,109
to see visually so I'll show you what

00:46:12,609 --> 00:46:17,020
that looks like of course as I mentioned

00:46:14,109 --> 00:46:18,970
before there's JSP tag support and again

00:46:17,020 --> 00:46:20,950
there's transparent HTTP session support

00:46:18,970 --> 00:46:22,930
so if you are using shade Shiro's native

00:46:20,950 --> 00:46:24,070
sessions and session clustering you

00:46:22,930 --> 00:46:25,720
don't have to change any of your web

00:46:24,070 --> 00:46:30,010
code because we implement the servlet

00:46:25,720 --> 00:46:32,290
api for sessions here's an example of

00:46:30,010 --> 00:46:34,960
how to configure Shiro's filter it's out

00:46:32,290 --> 00:46:38,410
of web.xml this has changed a little bit

00:46:34,960 --> 00:46:40,750
since Shiro 1.2 we have a concert

00:46:38,410 --> 00:46:42,250
context listener that you also specify

00:46:40,750 --> 00:46:44,650
but this is the basic gist of it you

00:46:42,250 --> 00:46:46,780
specify your filter and then in the

00:46:44,650 --> 00:46:48,400
filter mapping you specify a URL pattern

00:46:46,780 --> 00:46:49,990
of slash star so we want Shiro to

00:46:48,400 --> 00:46:51,520
intercept and filter every single

00:46:49,990 --> 00:46:53,440
request that comes into your application

00:46:51,520 --> 00:46:56,140
and you'll want to set this filter

00:46:53,440 --> 00:46:57,580
mapping higher up in the file compared

00:46:56,140 --> 00:47:01,170
to any other filter mapping to make sure

00:46:57,580 --> 00:47:01,170
that show sits in front of all the rest

00:47:01,619 --> 00:47:07,840
and here's an example of some

00:47:04,420 --> 00:47:09,430
configuration for Shiro so you could

00:47:07,840 --> 00:47:10,859
because everything in Shiro's POJO based

00:47:09,430 --> 00:47:13,330
you can use any pojo based configuration

00:47:10,859 --> 00:47:15,760
mechanism that you want so whether it's

00:47:13,330 --> 00:47:17,140
Spring XML or JBoss beans XML or

00:47:15,760 --> 00:47:19,809
whatever you have

00:47:17,140 --> 00:47:21,720
you can use that but we also provide ini

00:47:19,809 --> 00:47:23,619
a sort of the lowest common denominator

00:47:21,720 --> 00:47:26,380
configuration format if you don't want

00:47:23,619 --> 00:47:28,510
to use these other mechanisms so in this

00:47:26,380 --> 00:47:31,059
example in the main section we're

00:47:28,510 --> 00:47:33,940
basically configuring a realm to talk to

00:47:31,059 --> 00:47:35,440
an LDAP server and then we configure

00:47:33,940 --> 00:47:36,940
that realm on the security manager and

00:47:35,440 --> 00:47:39,029
this is basically what we like to call

00:47:36,940 --> 00:47:42,190
the pseudo dev team is like poor-man's

00:47:39,029 --> 00:47:44,529
dependency or inversion of control or

00:47:42,190 --> 00:47:46,510
dependency injection so basically be a

00:47:44,529 --> 00:47:50,529
simple kind of object graph navigation

00:47:46,510 --> 00:47:52,450
kind of syntax you can set properties

00:47:50,529 --> 00:47:55,839
and objects on each other and it's

00:47:52,450 --> 00:47:56,619
pretty easy to use in the URL section

00:47:55,839 --> 00:47:59,260
though this is kind of what's

00:47:56,619 --> 00:48:04,329
interesting for the web stuff you can

00:47:59,260 --> 00:48:06,190
specify as key value pairs a ant based

00:48:04,329 --> 00:48:07,450
path expression on the left and on the

00:48:06,190 --> 00:48:10,839
right hand side of the equal sign

00:48:07,450 --> 00:48:12,490
it's a comma delimited list of filter

00:48:10,839 --> 00:48:14,680
names that you want to execute for that

00:48:12,490 --> 00:48:16,510
particular endpoint which is really nice

00:48:14,680 --> 00:48:18,339
because if you look here you can see

00:48:16,510 --> 00:48:20,950
that for example on the remoting

00:48:18,339 --> 00:48:22,329
endpoint anything that matches remoting

00:48:20,950 --> 00:48:23,829
or anything below it is going to go

00:48:22,329 --> 00:48:24,880
through the authentication filter then

00:48:23,829 --> 00:48:26,079
it's going to make sure it has the b2b

00:48:24,880 --> 00:48:27,880
client role then it's going to make sure

00:48:26,079 --> 00:48:30,279
it does whatever else comes after it so

00:48:27,880 --> 00:48:32,200
in a very succinct kind of format you

00:48:30,279 --> 00:48:34,869
can visually see exactly what filters

00:48:32,200 --> 00:48:37,539
are being executed and in what order and

00:48:34,869 --> 00:48:39,039
you can define filters inside of the

00:48:37,539 --> 00:48:40,630
Shiro's main section there's a there's a

00:48:39,039 --> 00:48:42,009
bunch of defaults that come enabled out

00:48:40,630 --> 00:48:43,779
of the box so there like there's an ssl

00:48:42,009 --> 00:48:45,730
filter to enforce ssl connections

00:48:43,779 --> 00:48:48,309
there's authentication authorization

00:48:45,730 --> 00:48:49,480
there's HTTP basic authentication filter

00:48:48,309 --> 00:48:51,400
there's all sorts of things that come

00:48:49,480 --> 00:48:52,599
out of the box you can of course define

00:48:51,400 --> 00:48:54,910
your own and then use them in these

00:48:52,599 --> 00:48:57,819
filter change so it's a really succinct

00:48:54,910 --> 00:49:01,450
easy way to enforce security policies

00:48:57,819 --> 00:49:06,490
without having to you know go searching

00:49:01,450 --> 00:49:09,210
through a web XML here's how you might

00:49:06,490 --> 00:49:12,460
use some of the JSP tag libs so

00:49:09,210 --> 00:49:14,170
Shiro has a tag tag Lib in this case

00:49:12,460 --> 00:49:16,029
we've given it the prefix of Shiro could

00:49:14,170 --> 00:49:18,549
be whatever you want and in here or

00:49:16,029 --> 00:49:20,109
showing the particular link to manage

00:49:18,549 --> 00:49:22,359
users is only visible if you have the

00:49:20,109 --> 00:49:25,119
administrator role but if you don't have

00:49:22,359 --> 00:49:26,500
the role if you lack the role you know

00:49:25,119 --> 00:49:26,980
will show some other text or some other

00:49:26,500 --> 00:49:30,040
kind of but

00:49:26,980 --> 00:49:31,869
so this is just a very simple example of

00:49:30,040 --> 00:49:34,570
how you can control page rendering based

00:49:31,869 --> 00:49:35,950
on security state there's a whole bunch

00:49:34,570 --> 00:49:37,690
of other kind of tags that you can use

00:49:35,950 --> 00:49:39,640
you can determine you know common

00:49:37,690 --> 00:49:41,079
scenario is if there are a guest show

00:49:39,640 --> 00:49:42,940
them the login link but if they're not a

00:49:41,079 --> 00:49:44,859
guest if they're a user you know shown

00:49:42,940 --> 00:49:47,339
the you know welcome Tony kind of

00:49:44,859 --> 00:49:49,690
message you can use all these tags to

00:49:47,339 --> 00:49:51,940
change the output based on their current

00:49:49,690 --> 00:49:54,130
state of the end user so you can check

00:49:51,940 --> 00:49:57,700
for permissions roles see if they're

00:49:54,130 --> 00:49:59,380
authenticated or not and all of this

00:49:57,700 --> 00:50:01,720
stuff has been replicated as of late in

00:49:59,380 --> 00:50:06,180
the in the trunk in the jsf support so

00:50:01,720 --> 00:50:08,980
should work fine for JFS use JSF users

00:50:06,180 --> 00:50:12,250
and finally we have some auxilary

00:50:08,980 --> 00:50:13,660
features that we'll cover quickly as I

00:50:12,250 --> 00:50:17,230
mentioned before getting current subject

00:50:13,660 --> 00:50:19,839
is currently in enshiro tied to a thread

00:50:17,230 --> 00:50:22,839
local which can pause cause some

00:50:19,839 --> 00:50:25,810
problems for threading and multi their

00:50:22,839 --> 00:50:28,150
concurrent execution so oshiro has is a

00:50:25,810 --> 00:50:29,920
couple wrapper executor services in

00:50:28,150 --> 00:50:34,030
scheduled executor service and whatnot

00:50:29,920 --> 00:50:35,619
that wrap the incoming call in a

00:50:34,030 --> 00:50:37,660
callable or a runnable object that

00:50:35,619 --> 00:50:40,359
retains the subject state across threads

00:50:37,660 --> 00:50:41,950
so if you are executing on one thread

00:50:40,359 --> 00:50:42,970
and then you dispatch to an executor

00:50:41,950 --> 00:50:45,010
service to do some asynchronous

00:50:42,970 --> 00:50:47,230
processing sure will automatically

00:50:45,010 --> 00:50:47,619
without your code even having to adapt

00:50:47,230 --> 00:50:50,440
to it

00:50:47,619 --> 00:50:52,420
retain the run as excuse me the the

00:50:50,440 --> 00:50:54,640
subjects identity and authentication

00:50:52,420 --> 00:50:55,750
state across threads and when that

00:50:54,640 --> 00:50:57,369
thread is done executing it

00:50:55,750 --> 00:51:00,609
automatically cleans up the thread so

00:50:57,369 --> 00:51:04,240
you have multi-threading and concurrency

00:51:00,609 --> 00:51:05,980
support using the callable runnable we

00:51:04,240 --> 00:51:09,069
have run nest support so allows you to

00:51:05,980 --> 00:51:10,510
kind of pop a stack of identities on the

00:51:09,069 --> 00:51:13,180
currently executing user so it's really

00:51:10,510 --> 00:51:16,329
useful in scenarios where you know maybe

00:51:13,180 --> 00:51:18,190
I am an administrator logged in to a web

00:51:16,329 --> 00:51:19,660
console and I want to run as a

00:51:18,190 --> 00:51:21,940
particular end user so I could see

00:51:19,660 --> 00:51:24,010
whatever they're seeing you can have run

00:51:21,940 --> 00:51:27,099
as support in the field by interacting

00:51:24,010 --> 00:51:30,190
with the subject you can create subjects

00:51:27,099 --> 00:51:32,079
whenever you want I'm right up until now

00:51:30,190 --> 00:51:33,160
you'd only seen security utils not get

00:51:32,079 --> 00:51:34,750
subject but if you're a framework

00:51:33,160 --> 00:51:37,690
developer or another Apache project

00:51:34,750 --> 00:51:39,190
committer you can create subject

00:51:37,690 --> 00:51:40,330
instances based on an incoming request

00:51:39,190 --> 00:51:41,770
or an incoming

00:51:40,330 --> 00:51:44,590
remote method invocation or what have

00:51:41,770 --> 00:51:47,260
you based on subject state using a

00:51:44,590 --> 00:51:48,820
subject builder that uses the Builder

00:51:47,260 --> 00:51:51,340
design pattern to you know basically

00:51:48,820 --> 00:51:52,690
populate the state that's required and

00:51:51,340 --> 00:51:54,940
then once the subjects created you can

00:51:52,690 --> 00:51:57,670
do whatever you want with it we have

00:51:54,940 --> 00:52:01,150
unit testing support so naturally using

00:51:57,670 --> 00:52:02,800
thread locals in certain static method

00:52:01,150 --> 00:52:05,170
calls is kind of a pain in certain

00:52:02,800 --> 00:52:06,670
environments so we have some unit

00:52:05,170 --> 00:52:09,370
testing support out of the box that

00:52:06,670 --> 00:52:11,980
allows you to to simulate you know

00:52:09,370 --> 00:52:13,270
currently logged-in users and again I

00:52:11,980 --> 00:52:15,520
had mentioned earlier about the notion

00:52:13,270 --> 00:52:17,200
of authenticated versus remembered it's

00:52:15,520 --> 00:52:19,510
really important that Sherrill remembers

00:52:17,200 --> 00:52:20,980
that state you can choose to use those

00:52:19,510 --> 00:52:24,370
methods is authenticated or is

00:52:20,980 --> 00:52:26,320
remembered to customize your UI if you

00:52:24,370 --> 00:52:28,390
wish if you if you don't care then it's

00:52:26,320 --> 00:52:30,450
it's not a big deal but she remembers of

00:52:28,390 --> 00:52:33,670
the state in case you need it

00:52:30,450 --> 00:52:36,460
and finally logging out after the users

00:52:33,670 --> 00:52:38,290
done they can call you can get the

00:52:36,460 --> 00:52:40,300
subject and then just call log on and it

00:52:38,290 --> 00:52:42,360
evaluates their security state it'll

00:52:40,300 --> 00:52:45,940
close out their session automatically

00:52:42,360 --> 00:52:48,100
and then to perform application-specific

00:52:45,940 --> 00:52:49,480
logout logic you can do whatever you

00:52:48,100 --> 00:52:51,610
need to before after this call you can

00:52:49,480 --> 00:52:53,470
also listen listen for authentication or

00:52:51,610 --> 00:53:00,790
stop session events and react

00:52:53,470 --> 00:53:01,990
accordingly and in 1.3 and 12.0 we've

00:53:00,790 --> 00:53:04,180
got some pretty cool things that are

00:53:01,990 --> 00:53:07,050
coming out we now have a really nice

00:53:04,180 --> 00:53:09,160
type safe event bus in the project so

00:53:07,050 --> 00:53:11,860
what that allows us to do is the

00:53:09,160 --> 00:53:13,300
development team is trigger type safe

00:53:11,860 --> 00:53:15,400
events that contain a bunch of

00:53:13,300 --> 00:53:16,780
information and you can list you can

00:53:15,400 --> 00:53:18,700
create listeners that listen to those

00:53:16,780 --> 00:53:22,120
particular events and so gives you a

00:53:18,700 --> 00:53:25,120
much lower looser kind of high cohesion

00:53:22,120 --> 00:53:26,200
low coupling plug-in capability into

00:53:25,120 --> 00:53:27,520
Shiro so you can just implement

00:53:26,200 --> 00:53:29,740
listeners and implement specific

00:53:27,520 --> 00:53:31,450
functionality without having a subclass

00:53:29,740 --> 00:53:33,550
you know Shiro specific components and

00:53:31,450 --> 00:53:35,470
so we're moving towards more

00:53:33,550 --> 00:53:39,640
event-driven kind of architectures in

00:53:35,470 --> 00:53:42,430
newer revisions in earlier versions of

00:53:39,640 --> 00:53:43,870
Shiro there was a lot of you know sub

00:53:42,430 --> 00:53:45,580
classing techniques where you had to

00:53:43,870 --> 00:53:48,490
take a Shiro class subclass at override

00:53:45,580 --> 00:53:49,840
a method and you know obviously we want

00:53:48,490 --> 00:53:52,200
a favored composition over inheritance

00:53:49,840 --> 00:53:53,190
so the new stuff that's coming out

00:53:52,200 --> 00:53:54,660
where stuff is all going to be

00:53:53,190 --> 00:53:56,070
composition based so you can plug in

00:53:54,660 --> 00:53:58,320
objects instead of having the subclass

00:53:56,070 --> 00:54:00,210
things or implement an interface and

00:53:58,320 --> 00:54:02,910
plug it in so it's a lot easier to work

00:54:00,210 --> 00:54:05,430
with we're gonna have stronger j ee

00:54:02,910 --> 00:54:09,060
support so I mentioned JSF should be

00:54:05,430 --> 00:54:12,359
coming out will have better CDI support

00:54:09,060 --> 00:54:15,030
for the the j ee crowd they'll probably

00:54:12,359 --> 00:54:17,810
be a default realm implementation right

00:54:15,030 --> 00:54:19,980
now all the realms are specific to a

00:54:17,810 --> 00:54:21,510
technology that interacts with your data

00:54:19,980 --> 00:54:23,490
store so we'll have a JDBC realm and

00:54:21,510 --> 00:54:28,560
LDAP realm or a relational database I

00:54:23,490 --> 00:54:30,329
mean a filesystem realm in the vast

00:54:28,560 --> 00:54:31,859
majority of all these realms there's

00:54:30,329 --> 00:54:33,930
things like caching and permission

00:54:31,859 --> 00:54:35,880
creation that are all common across all

00:54:33,930 --> 00:54:38,099
of them so we'll probably have a default

00:54:35,880 --> 00:54:39,990
realm implementation where you can plug

00:54:38,099 --> 00:54:42,150
in strategies that allow you to look up

00:54:39,990 --> 00:54:44,670
account data and in kind of

00:54:42,150 --> 00:54:46,680
authentication data so this will be more

00:54:44,670 --> 00:54:48,630
pluggable and one of the other things

00:54:46,680 --> 00:54:50,520
that we've had a lot of feedback on is

00:54:48,630 --> 00:54:52,619
this notion of it doesn't exist yet but

00:54:50,520 --> 00:54:54,540
we want to add it what we're calling a

00:54:52,619 --> 00:54:56,670
default authentication filter that will

00:54:54,540 --> 00:54:58,619
support any number of HTTP

00:54:56,670 --> 00:55:00,569
authentication schemes and then fall

00:54:58,619 --> 00:55:03,450
back to like a user interface based page

00:55:00,569 --> 00:55:05,460
to support user login so this is

00:55:03,450 --> 00:55:07,200
becoming more prevalent in modern API

00:55:05,460 --> 00:55:09,900
based services where if I authenticate

00:55:07,200 --> 00:55:11,849
via OAuth or or they should be basic

00:55:09,900 --> 00:55:13,200
then I'm authenticated but if I don't

00:55:11,849 --> 00:55:15,270
attend t'k 8 being any of those means

00:55:13,200 --> 00:55:17,250
then redirect me to a login page before

00:55:15,270 --> 00:55:18,510
I continue to use the app and so you'll

00:55:17,250 --> 00:55:23,520
be able to do that all with a single

00:55:18,510 --> 00:55:25,619
filter that you can configure so that's

00:55:23,520 --> 00:55:27,030
it you know thanks for your time if you

00:55:25,619 --> 00:55:29,940
want to give a shot you know take a look

00:55:27,030 --> 00:55:32,280
at storm path we sure can enforce stuff

00:55:29,940 --> 00:55:34,109
in your app storm paths can be an

00:55:32,280 --> 00:55:35,670
identity provider for Shero in the cloud

00:55:34,109 --> 00:55:38,130
as spring security and other things as

00:55:35,670 --> 00:55:41,010
well so if you feel that you have cloud

00:55:38,130 --> 00:55:43,200
publicly facing web apps store path

00:55:41,010 --> 00:55:45,359
might be a good solution for you and we

00:55:43,200 --> 00:55:47,550
also integrate natively with Active

00:55:45,359 --> 00:55:48,720
Directory behind firewalls so if that's

00:55:47,550 --> 00:55:51,930
a problem you're trying to solve we

00:55:48,720 --> 00:55:56,430
solve that problem too thanks your time

00:55:51,930 --> 00:55:58,109
I'm here for any questions we have four

00:55:56,430 --> 00:56:00,589
and a half minutes left so if you have

00:55:58,109 --> 00:56:00,589
anything yeah

00:56:17,470 --> 00:56:21,950
so the question is is can we use

00:56:19,910 --> 00:56:22,820
separate modules within jira so if I

00:56:21,950 --> 00:56:25,070
only want to use the cryptographic

00:56:22,820 --> 00:56:26,540
modules can I just use that and maybe

00:56:25,070 --> 00:56:29,150
the log and stuff or vice versa

00:56:26,540 --> 00:56:30,860
and the answer to that today is no but

00:56:29,150 --> 00:56:32,480
in Shiro - I think we're going to be

00:56:30,860 --> 00:56:35,300
able to do that in a lot cleaner fashion

00:56:32,480 --> 00:56:37,070
so if you depend on sheer oak or you'll

00:56:35,300 --> 00:56:39,620
get crypto out of the box as well as

00:56:37,070 --> 00:56:41,360
subject base login and stuff like that

00:56:39,620 --> 00:56:43,040
things like integration with LDAP and

00:56:41,360 --> 00:56:45,080
Active Directory those will be separated

00:56:43,040 --> 00:56:46,370
into their own modules and we're going

00:56:45,080 --> 00:56:48,380
to try to have a much more modular

00:56:46,370 --> 00:56:51,620
approach and part of the reason for that

00:56:48,380 --> 00:56:53,390
is to reduce the files of the amount the

00:56:51,620 --> 00:56:55,340
the size of the files required to run

00:56:53,390 --> 00:56:57,050
like in a mobile application so we've

00:56:55,340 --> 00:56:58,730
had people who run in mobile that wants

00:56:57,050 --> 00:57:00,830
smaller jars so that they can only

00:56:58,730 --> 00:57:04,130
depend on what they absolutely require

00:57:00,830 --> 00:57:05,810
so because that will probably involve

00:57:04,130 --> 00:57:07,040
some backwards incompatible things

00:57:05,810 --> 00:57:11,410
that's probably gonna have to wait till

00:57:07,040 --> 00:57:11,410
- dotto but but yeah it's on the roadmap

00:57:29,300 --> 00:57:33,450
so the question is is you know

00:57:31,410 --> 00:57:35,520
permissions are kind of represented in a

00:57:33,450 --> 00:57:37,350
realm and then the realm can represent

00:57:35,520 --> 00:57:38,790
this information however it wants an

00:57:37,350 --> 00:57:40,730
LDAP or Active Directory or relational

00:57:38,790 --> 00:57:43,980
database are there any tools to utilize

00:57:40,730 --> 00:57:45,660
to convert between your data source and

00:57:43,980 --> 00:57:47,820
Shiro's internal representation

00:57:45,660 --> 00:57:49,320
currently there's not so the way that

00:57:47,820 --> 00:57:50,970
most people end up doing that is they

00:57:49,320 --> 00:57:53,130
subclass the realm to do whatever they

00:57:50,970 --> 00:57:54,810
need and as they do a query from their

00:57:53,130 --> 00:57:57,630
data source they just spit out those

00:57:54,810 --> 00:57:59,670
strings that Shiro understands or you

00:57:57,630 --> 00:58:02,490
can return the actual permission

00:57:59,670 --> 00:58:03,990
instances most people tend to like the

00:58:02,490 --> 00:58:05,280
string based representation so they

00:58:03,990 --> 00:58:08,100
don't have to worry about type safety or

00:58:05,280 --> 00:58:10,470
creating specific subclasses so it

00:58:08,100 --> 00:58:12,390
usually becomes a exercise of let me

00:58:10,470 --> 00:58:13,860
query this database table concatenate

00:58:12,390 --> 00:58:16,050
the columns and then return it to Shiro

00:58:13,860 --> 00:58:18,120
and share just works so but there's no

00:58:16,050 --> 00:58:27,930
actual tools used it's because it's very

00:58:18,120 --> 00:58:29,670
Danis source specific yep absolutely you

00:58:27,930 --> 00:58:32,130
can either do that or like I said you

00:58:29,670 --> 00:58:33,860
know have a little helper component that

00:58:32,130 --> 00:58:39,300
does it in Java you know it's up to you

00:58:33,860 --> 00:58:42,150
yep any questions okay thanks for your

00:58:39,300 --> 00:58:43,920
time if you need to contact me there's

00:58:42,150 --> 00:58:48,560
my contact info I'm always available via

00:58:43,920 --> 00:58:48,560

YouTube URL: https://www.youtube.com/watch?v=4gXvTeTbgc8


