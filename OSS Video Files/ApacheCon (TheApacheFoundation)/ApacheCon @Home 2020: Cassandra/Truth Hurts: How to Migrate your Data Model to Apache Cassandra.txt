Title: Truth Hurts: How to Migrate your Data Model to Apache Cassandra
Publication date: 2020-10-21
Playlist: ApacheCon @Home 2020: Cassandra
Description: 
	Truth Hurts: How to Migrate your Data Model to Apache Cassandra
Amanda Moran

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

I just took a DNA test, and it turns out my data model is 100% wrong. This session will focus on how to correctly data model for Apache Cassandra and NoSQL databases. Topics will include: - A brief comparison of relational databases and NoSQL databases - The benefits of Apache Cassandra - Transitioning a relational data model to a Cassandra data model - Common issues that can be solved with a good data model This session is intended for folks new to Cassandra/NoSQL or folks transitioning from operations to a more data engineering and cloud-focused role.

Amanda has been an committer and PMC member for Apache Trafodion since 2015. She was previously a Developer Advocate with DataStax where she spent many, many hours helping users get better with Apache Cassandra.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,080 --> 00:00:27,920
basis of

00:00:25,039 --> 00:00:29,199
what i was forming my talk around i did

00:00:27,920 --> 00:00:32,079
a little rewriting

00:00:29,199 --> 00:00:33,360
of her song today uh so this is the

00:00:32,079 --> 00:00:35,760
truth hertz

00:00:33,360 --> 00:00:37,200
data modeling edition okay so if you

00:00:35,760 --> 00:00:38,480
know the song

00:00:37,200 --> 00:00:40,079
you'll kind of follow along with it and

00:00:38,480 --> 00:00:41,040
if you don't go listen to it and then

00:00:40,079 --> 00:00:43,440
you'll you'll get it

00:00:41,040 --> 00:00:44,879
okay so i just did this today this

00:00:43,440 --> 00:00:46,480
morning on my walk so we'll see how it

00:00:44,879 --> 00:00:48,480
goes

00:00:46,480 --> 00:00:50,239
why does my data model great until it

00:00:48,480 --> 00:00:52,800
needs to be great

00:00:50,239 --> 00:00:54,000
i just took a dna test turns out my data

00:00:52,800 --> 00:00:56,960
model is 100

00:00:54,000 --> 00:00:58,079
wrong even when i'm crying crazy yeah i

00:00:56,960 --> 00:01:00,320
got data problems

00:00:58,079 --> 00:01:01,520
that's the human in me but bling bling

00:01:00,320 --> 00:01:04,719
when i'm gonna solve them

00:01:01,520 --> 00:01:04,719
that's the goddess in me

00:01:04,879 --> 00:01:09,040
you could have had apache cassandra help

00:01:06,799 --> 00:01:10,880
you with your career just a little bit

00:01:09,040 --> 00:01:12,960
they won't hold you down or hold you

00:01:10,880 --> 00:01:15,360
back and the sound of them

00:01:12,960 --> 00:01:16,560
will be of them calling you back why

00:01:15,360 --> 00:01:19,119
does my data model

00:01:16,560 --> 00:01:19,840
great until it needs to be great don't

00:01:19,119 --> 00:01:22,000
page me

00:01:19,840 --> 00:01:22,880
tell it straight to my face my

00:01:22,000 --> 00:01:25,200
organization

00:01:22,880 --> 00:01:26,799
sent me to a apache con to get these

00:01:25,200 --> 00:01:29,360
problems out of my hair

00:01:26,799 --> 00:01:30,320
fresh ideas that are so enlightening a

00:01:29,360 --> 00:01:32,960
new data model

00:01:30,320 --> 00:01:33,759
with cassandra truth hurts i guess i

00:01:32,960 --> 00:01:36,799
needed something

00:01:33,759 --> 00:01:37,439
more exciting okay so if you know the

00:01:36,799 --> 00:01:39,200
song

00:01:37,439 --> 00:01:40,880
you now understand my rewritten lyrics

00:01:39,200 --> 00:01:42,799
so hopefully you enjoyed that

00:01:40,880 --> 00:01:43,840
that was a fun thing for me to do today

00:01:42,799 --> 00:01:44,960
all right so what are we actually going

00:01:43,840 --> 00:01:46,240
to be talking about no more fun and

00:01:44,960 --> 00:01:47,680
games right

00:01:46,240 --> 00:01:50,479
we're going to do some comparison of

00:01:47,680 --> 00:01:51,759
relational databases and nosql databases

00:01:50,479 --> 00:01:54,000
we're going to talk about the benefits

00:01:51,759 --> 00:01:55,680
of apache cassandra we're going to talk

00:01:54,000 --> 00:01:57,520
about transitioning to an apache

00:01:55,680 --> 00:01:59,200
cassandra data model

00:01:57,520 --> 00:02:01,439
and i'm going to talk about some common

00:01:59,200 --> 00:02:04,320
issues solved by a good data model

00:02:01,439 --> 00:02:05,520
for apache cassandra and i was asked

00:02:04,320 --> 00:02:07,119
earlier about my twitter handle you'll

00:02:05,520 --> 00:02:10,239
see it down there at the bottom

00:02:07,119 --> 00:02:11,920
uh which is amanda k underscore data

00:02:10,239 --> 00:02:13,520
so let's just talk a little bit about me

00:02:11,920 --> 00:02:16,239
here for a second so

00:02:13,520 --> 00:02:18,400
um my always so i'm an apache committer

00:02:16,239 --> 00:02:20,400
and pmc member on apache trafodian

00:02:18,400 --> 00:02:22,319
apache trafodian is a sequel on top of

00:02:20,400 --> 00:02:25,200
hadoop or hbase

00:02:22,319 --> 00:02:26,800
type transactional sql layer and i did

00:02:25,200 --> 00:02:28,239
all the initial installation work for

00:02:26,800 --> 00:02:29,840
that project

00:02:28,239 --> 00:02:32,000
and i still keep up with it even though

00:02:29,840 --> 00:02:34,560
uh you know now i'm working for apple

00:02:32,000 --> 00:02:36,160
so i'm a current field engineer in the

00:02:34,560 --> 00:02:38,000
apple cloud services

00:02:36,160 --> 00:02:39,840
organization in the past i've worked for

00:02:38,000 --> 00:02:40,560
data stacks and data bricks and teradata

00:02:39,840 --> 00:02:42,640
and hp

00:02:40,560 --> 00:02:43,840
i really like companies with data in the

00:02:42,640 --> 00:02:45,920
name

00:02:43,840 --> 00:02:46,959
and i like distributed systems that deal

00:02:45,920 --> 00:02:48,480
with that data

00:02:46,959 --> 00:02:49,840
so i have a bachelor's from the

00:02:48,480 --> 00:02:51,120
university of washington and a master's

00:02:49,840 --> 00:02:53,680
from santa clara

00:02:51,120 --> 00:02:55,760
and the things that i love are disney

00:02:53,680 --> 00:02:58,640
dogs and running

00:02:55,760 --> 00:03:00,000
all right so let's jump in right into uh

00:02:58,640 --> 00:03:01,040
when should we be using a relational

00:03:00,000 --> 00:03:02,800
database so we're going to kind of

00:03:01,040 --> 00:03:06,000
compare and contrast relational

00:03:02,800 --> 00:03:07,440
and nosql and you might be thinking okay

00:03:06,000 --> 00:03:09,280
well i know the difference

00:03:07,440 --> 00:03:11,280
okay and maybe you do and that's

00:03:09,280 --> 00:03:12,959
wonderful uh but you're going to see how

00:03:11,280 --> 00:03:14,239
that flows into

00:03:12,959 --> 00:03:15,920
how we're going to be doing our data

00:03:14,239 --> 00:03:17,680
modeling differently and it's directly

00:03:15,920 --> 00:03:18,959
because of these uh differences between

00:03:17,680 --> 00:03:20,080
the two systems so i want to make sure

00:03:18,959 --> 00:03:21,920
that i pointed out

00:03:20,080 --> 00:03:23,760
just make a lot more sense when you

00:03:21,920 --> 00:03:26,959
realize how you have to translate

00:03:23,760 --> 00:03:28,640
transition your data model so when you

00:03:26,959 --> 00:03:32,400
should use relational

00:03:28,640 --> 00:03:33,680
so if you need to use sql if everyone on

00:03:32,400 --> 00:03:36,400
your team knows sql

00:03:33,680 --> 00:03:37,280
um you need that kind of um that query

00:03:36,400 --> 00:03:40,239
language

00:03:37,280 --> 00:03:41,840
um you know for nosql databases uh

00:03:40,239 --> 00:03:42,959
especially patrick cassandra they have

00:03:41,840 --> 00:03:44,840
similar type

00:03:42,959 --> 00:03:46,000
query languages but they're not

00:03:44,840 --> 00:03:47,599
identical

00:03:46,000 --> 00:03:49,920
another thing is if you need to use

00:03:47,599 --> 00:03:52,159
joins or do aggregations

00:03:49,920 --> 00:03:53,360
or do analytics that's really where the

00:03:52,159 --> 00:03:54,080
bread and butter of a relational

00:03:53,360 --> 00:03:57,120
database

00:03:54,080 --> 00:03:58,400
is um no sql databases than apache

00:03:57,120 --> 00:04:00,319
cassandra

00:03:58,400 --> 00:04:01,519
they're not very most of them don't

00:04:00,319 --> 00:04:03,760
support joins

00:04:01,519 --> 00:04:04,879
uh doing aggregations again uh not

00:04:03,760 --> 00:04:06,000
necessarily

00:04:04,879 --> 00:04:07,920
and they're not really built for

00:04:06,000 --> 00:04:09,760
analytics right they're not they're not

00:04:07,920 --> 00:04:13,120
built for those types of um

00:04:09,760 --> 00:04:15,120
of queries if you have smaller data

00:04:13,120 --> 00:04:16,639
so nosql and apache cassandra it's

00:04:15,120 --> 00:04:19,680
really built for big data

00:04:16,639 --> 00:04:21,199
not for smaller data there's no use in

00:04:19,680 --> 00:04:23,440
having the overhead of a distributed

00:04:21,199 --> 00:04:25,840
system on a distributed database if you

00:04:23,440 --> 00:04:28,400
just have small data

00:04:25,840 --> 00:04:30,560
if you need flexibility in your queries

00:04:28,400 --> 00:04:31,759
so if you have a lot of ad hoc queries

00:04:30,560 --> 00:04:35,120
that you do

00:04:31,759 --> 00:04:36,240
um then you may again you may want to

00:04:35,120 --> 00:04:38,800
think about

00:04:36,240 --> 00:04:40,800
using a relational database um instead

00:04:38,800 --> 00:04:41,840
of a nosql one and we'll talk about a

00:04:40,800 --> 00:04:43,199
little bit of the inverse and the

00:04:41,840 --> 00:04:46,560
difference between them

00:04:43,199 --> 00:04:49,040
um but apache cassandra doesn't

00:04:46,560 --> 00:04:50,560
i could argue it does just fine we

00:04:49,040 --> 00:04:53,199
there's workarounds for doing ad hoc

00:04:50,560 --> 00:04:54,560
ad hoc queries uh but nevertheless if

00:04:53,199 --> 00:04:55,440
you just do a lot of ad hoc queries you

00:04:54,560 --> 00:04:56,800
might want to think about using

00:04:55,440 --> 00:05:00,000
relational

00:04:56,800 --> 00:05:01,039
if you need acid transactions if you

00:05:00,000 --> 00:05:02,880
need that

00:05:01,039 --> 00:05:04,720
you know nosql databases for the most

00:05:02,880 --> 00:05:05,520
part especially at patrick standard

00:05:04,720 --> 00:05:08,720
don't support

00:05:05,520 --> 00:05:09,680
acid actually an open source database

00:05:08,720 --> 00:05:11,520
that does

00:05:09,680 --> 00:05:13,600
an example of that is foundation db it

00:05:11,520 --> 00:05:15,440
actually does support asset transactions

00:05:13,600 --> 00:05:16,800
and is a nosql database so there are

00:05:15,440 --> 00:05:17,840
exceptions to the rule

00:05:16,800 --> 00:05:19,840
uh but if we're just talking about

00:05:17,840 --> 00:05:22,960
cassandra it does not

00:05:19,840 --> 00:05:25,039
and the simplicity right um if you

00:05:22,960 --> 00:05:26,560
if you just have small data simple

00:05:25,039 --> 00:05:28,639
queries you don't really need the

00:05:26,560 --> 00:05:30,639
overhead of nosql

00:05:28,639 --> 00:05:32,000
so when not to use it okay so this kind

00:05:30,639 --> 00:05:33,280
of these are kind of the inverse of what

00:05:32,000 --> 00:05:35,120
we just talked about right

00:05:33,280 --> 00:05:37,360
so if you have a large amount of data

00:05:35,120 --> 00:05:38,320
relational uh may or may not work for

00:05:37,360 --> 00:05:40,880
you

00:05:38,320 --> 00:05:42,560
uh if you need true high availability a

00:05:40,880 --> 00:05:44,880
lot of relational beta bases they have a

00:05:42,560 --> 00:05:47,039
single point of failure

00:05:44,880 --> 00:05:48,720
and there's time that you're going to

00:05:47,039 --> 00:05:50,080
have to deal with when you

00:05:48,720 --> 00:05:52,000
do have a failure that you're going to

00:05:50,080 --> 00:05:53,199
have to hot swap that

00:05:52,000 --> 00:05:55,280
and so that's going to lead to not

00:05:53,199 --> 00:05:58,400
having a highly available up all the

00:05:55,280 --> 00:06:01,600
time no downtime type of system

00:05:58,400 --> 00:06:02,960
if you need really high read performance

00:06:01,600 --> 00:06:04,000
you may not want to think about using

00:06:02,960 --> 00:06:06,000
relational you may want to start

00:06:04,000 --> 00:06:08,639
thinking about using nosql

00:06:06,000 --> 00:06:09,280
because of that um we're going to talk a

00:06:08,639 --> 00:06:11,600
lot about

00:06:09,280 --> 00:06:12,479
read performance here in a little bit um

00:06:11,600 --> 00:06:14,800
but

00:06:12,479 --> 00:06:16,160
relational is not because of those joins

00:06:14,800 --> 00:06:18,000
and those ad hoc queries

00:06:16,160 --> 00:06:21,600
and the aggregations it's not really

00:06:18,000 --> 00:06:23,919
built for for high read performance

00:06:21,600 --> 00:06:26,400
if you need flexibility in your schema

00:06:23,919 --> 00:06:27,039
so no sql databases and apache cassandra

00:06:26,400 --> 00:06:28,800
they

00:06:27,039 --> 00:06:31,120
provide flexibility in your schema where

00:06:28,800 --> 00:06:32,880
it's much more rigid and relational

00:06:31,120 --> 00:06:34,400
and it's easier if you need to store

00:06:32,880 --> 00:06:36,800
different types of file formats

00:06:34,400 --> 00:06:38,479
um some relational databases are okay

00:06:36,800 --> 00:06:41,759
with that and but it's just a general

00:06:38,479 --> 00:06:43,919
rule kind of at a high level they're not

00:06:41,759 --> 00:06:45,600
so again when to use nosql again these

00:06:43,919 --> 00:06:47,120
are kind of just the inverse of kind of

00:06:45,600 --> 00:06:48,400
what we've already been talking about

00:06:47,120 --> 00:06:50,560
but if you truly need that high

00:06:48,400 --> 00:06:51,599
availability that's where nosql comes

00:06:50,560 --> 00:06:54,080
into the picture

00:06:51,599 --> 00:06:56,000
if you have big data if you need linear

00:06:54,080 --> 00:06:57,199
scalability

00:06:56,000 --> 00:06:59,360
so we'll talk about that i think we

00:06:57,199 --> 00:07:01,759
talked about that a little bit later um

00:06:59,360 --> 00:07:03,759
so with a nosql database it's very

00:07:01,759 --> 00:07:05,360
especially apache cassandra it's very

00:07:03,759 --> 00:07:07,440
easy to add nodes

00:07:05,360 --> 00:07:09,440
and as you add those nodes it actually

00:07:07,440 --> 00:07:12,800
gives you that linear scalability

00:07:09,440 --> 00:07:14,400
and when you add them it you don't even

00:07:12,800 --> 00:07:16,240
need a restart of the database

00:07:14,400 --> 00:07:18,080
um you just bootstrap the note in and

00:07:16,240 --> 00:07:19,840
it's good it's good to go essentially

00:07:18,080 --> 00:07:21,919
yeah you have to wait for the data to

00:07:19,840 --> 00:07:23,120
stream to it so um

00:07:21,919 --> 00:07:25,039
it does take a little bit of time in

00:07:23,120 --> 00:07:27,039
that aspect but um

00:07:25,039 --> 00:07:28,720
after the data streams do it um you're

00:07:27,039 --> 00:07:30,639
good to go and you you've added that

00:07:28,720 --> 00:07:32,319
capacity and performance to your to your

00:07:30,639 --> 00:07:34,240
cluster

00:07:32,319 --> 00:07:36,400
if you need low latency and you need

00:07:34,240 --> 00:07:38,319
fast reads and fast rights

00:07:36,400 --> 00:07:39,759
so not just fast rights but also fast

00:07:38,319 --> 00:07:43,280
reads

00:07:39,759 --> 00:07:43,280
if you have a distributed users

00:07:43,360 --> 00:07:47,520
nosql especially cassandra is really

00:07:45,759 --> 00:07:50,400
built for that because you can have

00:07:47,520 --> 00:07:51,440
your full apache cluster with multiple

00:07:50,400 --> 00:07:53,520
data centers

00:07:51,440 --> 00:07:55,520
um and having that data stream between

00:07:53,520 --> 00:07:57,039
them um and you don't have to copy that

00:07:55,520 --> 00:07:58,479
data the data is going to get replicated

00:07:57,039 --> 00:07:59,440
throughout the data centers and the full

00:07:58,479 --> 00:08:02,080
cluster

00:07:59,440 --> 00:08:04,960
just automatically and if you need

00:08:02,080 --> 00:08:07,120
flexibility with your schema

00:08:04,960 --> 00:08:08,160
so again just kind of to reiterate when

00:08:07,120 --> 00:08:10,800
not to use it

00:08:08,160 --> 00:08:12,080
if you really need to use sql because

00:08:10,800 --> 00:08:13,520
apache cassandra for example

00:08:12,080 --> 00:08:17,120
uses cql we're going to talk about that

00:08:13,520 --> 00:08:18,800
in a second and it's not the same as sql

00:08:17,120 --> 00:08:20,479
if you need acid transactions because

00:08:18,800 --> 00:08:21,440
apache cassandra does not support asset

00:08:20,479 --> 00:08:25,680
transactions

00:08:21,440 --> 00:08:28,400
uh i guess in a sense i might argue

00:08:25,680 --> 00:08:29,360
with you if why you really need acid

00:08:28,400 --> 00:08:31,599
transactions

00:08:29,360 --> 00:08:33,519
um sometimes people think that they do

00:08:31,599 --> 00:08:35,760
need them and they really don't

00:08:33,519 --> 00:08:37,039
um i would i would really think about

00:08:35,760 --> 00:08:37,760
your use case and really consider

00:08:37,039 --> 00:08:39,279
whether that's

00:08:37,760 --> 00:08:41,360
that's the case or not if you do then

00:08:39,279 --> 00:08:42,000
then so be it until you should go with a

00:08:41,360 --> 00:08:44,720
relational

00:08:42,000 --> 00:08:46,480
database but if you really don't or for

00:08:44,720 --> 00:08:48,160
not all of your use cases you don't

00:08:46,480 --> 00:08:50,880
you may want to consider using apache

00:08:48,160 --> 00:08:54,640
cassandra or nosql database

00:08:50,880 --> 00:08:56,480
if you need to be able to do joins again

00:08:54,640 --> 00:08:57,440
i may argue with you that maybe you

00:08:56,480 --> 00:08:58,480
don't need that and that's what we're

00:08:57,440 --> 00:09:00,880
going to talk about here

00:08:58,480 --> 00:09:02,320
a lot with our data modeling talk why

00:09:00,880 --> 00:09:04,080
you don't need joins

00:09:02,320 --> 00:09:05,040
but if you really do need them then

00:09:04,080 --> 00:09:06,640
you're not going to be able to have a

00:09:05,040 --> 00:09:07,839
nosql database

00:09:06,640 --> 00:09:09,920
if you need to be able to do a lot of

00:09:07,839 --> 00:09:10,640
those ad hoc queries and if you have

00:09:09,920 --> 00:09:12,320
small data

00:09:10,640 --> 00:09:15,279
if you have small data there's really no

00:09:12,320 --> 00:09:17,200
point in in going about all of this

00:09:15,279 --> 00:09:18,320
all right so why should you use apache

00:09:17,200 --> 00:09:20,320
cassandra

00:09:18,320 --> 00:09:22,240
so um because i kind of was talking more

00:09:20,320 --> 00:09:23,920
generally about nosql so let's talk

00:09:22,240 --> 00:09:26,480
about just cassandra itself

00:09:23,920 --> 00:09:27,600
so cassandra itself and most of you are

00:09:26,480 --> 00:09:29,279
probably

00:09:27,600 --> 00:09:30,720
maybe cassandra experts out there but

00:09:29,279 --> 00:09:32,240
for those of you who aren't

00:09:30,720 --> 00:09:34,640
and let's just kind of go over this a

00:09:32,240 --> 00:09:35,680
little bit so cassandra has a leaderless

00:09:34,640 --> 00:09:38,560
architecture

00:09:35,680 --> 00:09:39,600
which gives you true high availability

00:09:38,560 --> 00:09:42,640
all the nodes

00:09:39,600 --> 00:09:45,279
in the cluster do the exact same job

00:09:42,640 --> 00:09:46,000
um when you come in to do a write that

00:09:45,279 --> 00:09:47,120
that node

00:09:46,000 --> 00:09:49,279
and we'll talk about the right path here

00:09:47,120 --> 00:09:50,000
in a bit it will act as a coordinator

00:09:49,279 --> 00:09:53,279
node during

00:09:50,000 --> 00:09:53,760
that time but after that it it gives up

00:09:53,279 --> 00:09:55,440
that

00:09:53,760 --> 00:09:57,519
after that writes then it gives up that

00:09:55,440 --> 00:09:58,800
that task it's no longer the coordinator

00:09:57,519 --> 00:10:00,800
and you truly you truly have a

00:09:58,800 --> 00:10:01,760
leaderless architecture so any node can

00:10:00,800 --> 00:10:03,600
go down and that's

00:10:01,760 --> 00:10:04,959
that's totally fine because there's no

00:10:03,600 --> 00:10:06,399
leader

00:10:04,959 --> 00:10:08,000
i talked about this a little bit earlier

00:10:06,399 --> 00:10:08,720
it's really easy to scale with no

00:10:08,000 --> 00:10:09,920
downtime

00:10:08,720 --> 00:10:11,920
and you truly get that linear

00:10:09,920 --> 00:10:14,800
scalability as you add in more nodes

00:10:11,920 --> 00:10:15,279
you get better performance and like i

00:10:14,800 --> 00:10:16,560
said

00:10:15,279 --> 00:10:18,959
you don't even need a restart which i

00:10:16,560 --> 00:10:21,200
think is really impressive

00:10:18,959 --> 00:10:22,959
so it's built for fast reads and writes

00:10:21,200 --> 00:10:24,000
and all the nodes are ready for those

00:10:22,959 --> 00:10:26,480
reads and writes

00:10:24,000 --> 00:10:28,320
and we're going to talk about how

00:10:26,480 --> 00:10:30,160
cassandra's really built for fast

00:10:28,320 --> 00:10:33,040
rights and how we're going to help it

00:10:30,160 --> 00:10:35,600
with our data model get that fast read

00:10:33,040 --> 00:10:37,519
and do i really have to say it the true

00:10:35,600 --> 00:10:38,480
thing is our amazing community so all of

00:10:37,519 --> 00:10:40,320
you out there

00:10:38,480 --> 00:10:42,240
all of the committers on this project

00:10:40,320 --> 00:10:44,079
all the various people that just are in

00:10:42,240 --> 00:10:47,120
the apache cassandra community

00:10:44,079 --> 00:10:47,760
are all truly amazing anytime you need

00:10:47,120 --> 00:10:49,600
help

00:10:47,760 --> 00:10:51,680
um there's so many different forums to

00:10:49,600 --> 00:10:53,680
get that help or get training

00:10:51,680 --> 00:10:55,360
um it's really an amazing community and

00:10:53,680 --> 00:10:57,680
uh it's definitely there for

00:10:55,360 --> 00:10:59,279
for you uh you know as you're working

00:10:57,680 --> 00:11:01,200
through this this transition

00:10:59,279 --> 00:11:02,880
uh from either relational database or a

00:11:01,200 --> 00:11:04,160
different type of nosql database

00:11:02,880 --> 00:11:06,399
there's a lot of people out there to

00:11:04,160 --> 00:11:08,000
help okay

00:11:06,399 --> 00:11:10,399
so let's talk about when we talk about

00:11:08,000 --> 00:11:12,959
low latency i really want to dig into

00:11:10,399 --> 00:11:14,560
how how how can that be so this is where

00:11:12,959 --> 00:11:15,920
i like to check about the right path for

00:11:14,560 --> 00:11:18,079
apache cassandra because

00:11:15,920 --> 00:11:19,680
this is what proves that lo why you're

00:11:18,079 --> 00:11:21,760
able to get that low latency

00:11:19,680 --> 00:11:23,360
so the right path is really i call it

00:11:21,760 --> 00:11:25,040
beautiful in its simplicity

00:11:23,360 --> 00:11:26,880
it's so simple and that's why it just it

00:11:25,040 --> 00:11:28,640
just makes intuitive sense once you hear

00:11:26,880 --> 00:11:30,480
it for the first time

00:11:28,640 --> 00:11:31,920
so let's talk a little bit about the

00:11:30,480 --> 00:11:33,440
right path from the client to the

00:11:31,920 --> 00:11:36,160
cluster

00:11:33,440 --> 00:11:37,120
so if you're the client and you're going

00:11:36,160 --> 00:11:40,320
to write

00:11:37,120 --> 00:11:43,360
a piece of data let's say that data is

00:11:40,320 --> 00:11:44,480
a um it's going to come in to

00:11:43,360 --> 00:11:47,040
one of the nodes it's going to hit one

00:11:44,480 --> 00:11:49,760
of the nodes um if your client

00:11:47,040 --> 00:11:51,920
is using one of the cassandra drivers it

00:11:49,760 --> 00:11:52,800
may actually already be token range

00:11:51,920 --> 00:11:55,360
aware

00:11:52,800 --> 00:11:56,240
and in that case it would actually go to

00:11:55,360 --> 00:11:58,639
the node

00:11:56,240 --> 00:12:00,399
um that that actually needs to go to and

00:11:58,639 --> 00:12:02,720
be and to write that piece of data

00:12:00,399 --> 00:12:04,399
um in this case let's say that uh you're

00:12:02,720 --> 00:12:04,959
not using a driver that is token range

00:12:04,399 --> 00:12:07,760
aware

00:12:04,959 --> 00:12:08,560
uh you're just using the client and so

00:12:07,760 --> 00:12:09,920
it's just gonna hit

00:12:08,560 --> 00:12:11,760
uh the node that you point it to

00:12:09,920 --> 00:12:13,440
essentially so in this particular case

00:12:11,760 --> 00:12:15,440
it's going to hit node a

00:12:13,440 --> 00:12:17,200
and what like i said before node a is

00:12:15,440 --> 00:12:18,160
going to take on that role as a

00:12:17,200 --> 00:12:21,279
coordinator node

00:12:18,160 --> 00:12:22,320
it's going to figure out which node or

00:12:21,279 --> 00:12:24,000
nodes i should say

00:12:22,320 --> 00:12:25,839
that that data piece of data needs to be

00:12:24,000 --> 00:12:27,200
written to within the token range so in

00:12:25,839 --> 00:12:27,519
this particular case you're seeing that

00:12:27,200 --> 00:12:29,920
that

00:12:27,519 --> 00:12:30,880
piece of data needs to be written to b

00:12:29,920 --> 00:12:34,959
and to a

00:12:30,880 --> 00:12:36,240
b and c and what happens and i don't

00:12:34,959 --> 00:12:36,959
want to talk too much about consistency

00:12:36,240 --> 00:12:39,200
levels here

00:12:36,959 --> 00:12:40,399
because that's not really the part the

00:12:39,200 --> 00:12:42,160
main part of this talk

00:12:40,399 --> 00:12:43,519
but what's going to happen is depending

00:12:42,160 --> 00:12:44,800
on your consistency level

00:12:43,519 --> 00:12:46,720
it's going to figure out how many of

00:12:44,800 --> 00:12:48,560
those rights need to be successful

00:12:46,720 --> 00:12:49,920
before it returns back to the client so

00:12:48,560 --> 00:12:52,480
if your consistency

00:12:49,920 --> 00:12:53,839
level is one uh it'll write to one node

00:12:52,480 --> 00:12:54,959
and then return back to the client that

00:12:53,839 --> 00:12:57,680
it was successful

00:12:54,959 --> 00:12:59,760
um and then after that the um it will be

00:12:57,680 --> 00:13:02,320
an asynchronous call that will write the

00:12:59,760 --> 00:13:04,079
the other nodes uh at the same time it

00:13:02,320 --> 00:13:05,360
just whoever gets done first will let

00:13:04,079 --> 00:13:06,800
the client know that it's been

00:13:05,360 --> 00:13:09,279
successful

00:13:06,800 --> 00:13:11,600
and that's that's it it's very simple so

00:13:09,279 --> 00:13:12,560
let's talk about um on the internals of

00:13:11,600 --> 00:13:14,959
that

00:13:12,560 --> 00:13:15,600
so uh it's a little it's same kind of

00:13:14,959 --> 00:13:16,880
process

00:13:15,600 --> 00:13:19,279
uh so let's just go into it in a little

00:13:16,880 --> 00:13:20,959
bit more detail so if you go to write

00:13:19,279 --> 00:13:23,440
that you're getting your zero

00:13:20,959 --> 00:13:25,120
so i have this number zero through three

00:13:23,440 --> 00:13:26,399
step zero

00:13:25,120 --> 00:13:27,680
you're gonna get a request from the

00:13:26,399 --> 00:13:28,720
client just like we did here on the

00:13:27,680 --> 00:13:30,800
other side

00:13:28,720 --> 00:13:32,399
and at the very same time an

00:13:30,800 --> 00:13:33,279
asynchronous call is gonna go to the

00:13:32,399 --> 00:13:35,120
commit log

00:13:33,279 --> 00:13:36,560
and it's going to append to the commit

00:13:35,120 --> 00:13:39,839
log and

00:13:36,560 --> 00:13:41,040
write to the mem table that's in memory

00:13:39,839 --> 00:13:42,560
and that's what's going to happen on

00:13:41,040 --> 00:13:43,519
each one of the nodes that that you're

00:13:42,560 --> 00:13:44,720
writing to

00:13:43,519 --> 00:13:46,959
and then it's going to return back to

00:13:44,720 --> 00:13:49,199
the client so again

00:13:46,959 --> 00:13:50,160
very simple and it's a like beautiful

00:13:49,199 --> 00:13:52,000
it's simplicity

00:13:50,160 --> 00:13:54,399
it that's really all it is and then over

00:13:52,000 --> 00:13:56,720
time you see here at number three

00:13:54,399 --> 00:13:58,480
eventually that mem table um once it

00:13:56,720 --> 00:14:01,040
gets full it's gonna flush to

00:13:58,480 --> 00:14:03,199
to disk and and then it's gonna persist

00:14:01,040 --> 00:14:04,880
as an ss immutable table

00:14:03,199 --> 00:14:07,519
and and that's really that's really all

00:14:04,880 --> 00:14:10,000
there is to it

00:14:07,519 --> 00:14:10,720
all right so we've talked about why

00:14:10,000 --> 00:14:14,320
there's fast

00:14:10,720 --> 00:14:16,000
rights but why is there fast reads

00:14:14,320 --> 00:14:18,000
and this is where we get into now we're

00:14:16,000 --> 00:14:20,160
getting into uh how we can do this with

00:14:18,000 --> 00:14:22,000
a good data model

00:14:20,160 --> 00:14:24,000
so to get those fast reads that's what

00:14:22,000 --> 00:14:25,600
it depends on it depends on us

00:14:24,000 --> 00:14:27,279
um so right you don't get anything for

00:14:25,600 --> 00:14:28,079
free and once i figured this out about

00:14:27,279 --> 00:14:30,000
cassandra

00:14:28,079 --> 00:14:31,440
it just made so much more sense to me

00:14:30,000 --> 00:14:33,199
like once i figured out okay

00:14:31,440 --> 00:14:35,519
it was built for these really fast

00:14:33,199 --> 00:14:36,720
rights and then i have to do my part

00:14:35,519 --> 00:14:38,399
nothing's for free

00:14:36,720 --> 00:14:40,880
and i have to give it a good data model

00:14:38,399 --> 00:14:42,560
to get these fast reads

00:14:40,880 --> 00:14:44,160
so we're going to talk a little bit more

00:14:42,560 --> 00:14:46,320
about this in just a bit but right your

00:14:44,160 --> 00:14:48,480
data is going to be partitioned across

00:14:46,320 --> 00:14:49,680
your cluster and across your nodes and

00:14:48,480 --> 00:14:53,360
so with that

00:14:49,680 --> 00:14:55,199
we have to help it figure out where is

00:14:53,360 --> 00:14:56,480
what i'm looking for which node does it

00:14:55,199 --> 00:14:58,720
live on right

00:14:56,480 --> 00:15:00,480
and so that's by the way we partition

00:14:58,720 --> 00:15:02,800
our data and we basically

00:15:00,480 --> 00:15:04,639
point to that partition in our in our

00:15:02,800 --> 00:15:07,760
query

00:15:04,639 --> 00:15:09,600
so in that aspect we'll query only one

00:15:07,760 --> 00:15:11,360
node and return the data

00:15:09,600 --> 00:15:12,639
and that gives us kind of it gives us

00:15:11,360 --> 00:15:15,279
that kind of it gives us

00:15:12,639 --> 00:15:16,880
constant time read access so if you look

00:15:15,279 --> 00:15:19,760
here at my query here

00:15:16,880 --> 00:15:21,120
select star from my table where artist

00:15:19,760 --> 00:15:23,839
equals lizzo

00:15:21,120 --> 00:15:25,040
so this particular case what i'm saying

00:15:23,839 --> 00:15:28,720
is that

00:15:25,040 --> 00:15:31,920
or what we can assume is that our data

00:15:28,720 --> 00:15:34,320
is partitioned across our cluster by

00:15:31,920 --> 00:15:35,920
artist probably not the best way to

00:15:34,320 --> 00:15:37,279
partition data but that's a totally

00:15:35,920 --> 00:15:38,560
different conversation

00:15:37,279 --> 00:15:40,480
but nevertheless we know it's

00:15:38,560 --> 00:15:41,199
partitioned by that and then that's what

00:15:40,480 --> 00:15:44,560
we're going to

00:15:41,199 --> 00:15:44,560
to point to in our where clause

00:15:44,720 --> 00:15:49,120
okay so like i said data modeling is

00:15:47,920 --> 00:15:52,240
different that's the whole point of this

00:15:49,120 --> 00:15:55,040
talk relational data modeling this is

00:15:52,240 --> 00:15:56,800
catchy cassandra data modeling uh one of

00:15:55,040 --> 00:15:58,000
the things just to point out here is the

00:15:56,800 --> 00:15:58,880
difference between the two query

00:15:58,000 --> 00:16:01,360
languages

00:15:58,880 --> 00:16:03,199
uh cassandra query language and sql or

00:16:01,360 --> 00:16:04,560
sql

00:16:03,199 --> 00:16:06,399
and i always say cassandra query

00:16:04,560 --> 00:16:07,759
language because i'll just flip them

00:16:06,399 --> 00:16:10,639
and say the wrong one and everyone will

00:16:07,759 --> 00:16:12,560
be confused uh but for sequel

00:16:10,639 --> 00:16:14,639
so just this is just an example of a

00:16:12,560 --> 00:16:17,199
query you can do a select star

00:16:14,639 --> 00:16:19,120
from song a table of songs and you can

00:16:17,199 --> 00:16:21,600
join it on the artist

00:16:19,120 --> 00:16:22,480
uh join it on the artist table on a

00:16:21,600 --> 00:16:25,120
common id

00:16:22,480 --> 00:16:27,040
so in this case we have song artist id

00:16:25,120 --> 00:16:28,399
equals artist.id

00:16:27,040 --> 00:16:30,160
and and what we would do is we're

00:16:28,399 --> 00:16:32,160
getting data back from both of those

00:16:30,160 --> 00:16:34,480
tables and sending that back

00:16:32,160 --> 00:16:35,440
uh with a cassandra query language we

00:16:34,480 --> 00:16:37,120
can't do that

00:16:35,440 --> 00:16:38,959
there are no joins and so this

00:16:37,120 --> 00:16:40,880
particular case we would only be able to

00:16:38,959 --> 00:16:42,959
do a select star from my table

00:16:40,880 --> 00:16:44,480
where and then artist equals whatever

00:16:42,959 --> 00:16:46,880
artist i'm looking for and how i've

00:16:44,480 --> 00:16:48,560
partitioned it

00:16:46,880 --> 00:16:50,639
so let's talk a little bit about data

00:16:48,560 --> 00:16:51,519
modeling for relational databases what

00:16:50,639 --> 00:16:52,800
that really means

00:16:51,519 --> 00:16:54,959
so that we can talk about how we're

00:16:52,800 --> 00:16:56,560
going to transition into doing that for

00:16:54,959 --> 00:16:58,399
cassandra

00:16:56,560 --> 00:17:00,079
so relational is all around

00:16:58,399 --> 00:17:05,199
normalization

00:17:00,079 --> 00:17:07,360
so uh normalization was um

00:17:05,199 --> 00:17:09,280
really prescribed and developed in the

00:17:07,360 --> 00:17:11,280
1970s

00:17:09,280 --> 00:17:12,880
and it was all and actually at ibm and

00:17:11,280 --> 00:17:15,039
it was all around making sure that you

00:17:12,880 --> 00:17:18,160
reduce your data redundancy

00:17:15,039 --> 00:17:20,720
and increase your data integrity so

00:17:18,160 --> 00:17:23,199
think about the systems of the 1970s you

00:17:20,720 --> 00:17:25,120
can't have extra copies of that data

00:17:23,199 --> 00:17:26,799
you don't have the space it is so

00:17:25,120 --> 00:17:28,880
incredibly expensive

00:17:26,799 --> 00:17:29,919
so you need to make sure that whatever

00:17:28,880 --> 00:17:33,280
data that you're writing

00:17:29,919 --> 00:17:36,559
is only being written to one place

00:17:33,280 --> 00:17:38,240
and with that i mean while you're

00:17:36,559 --> 00:17:40,480
reducing that data redundancy

00:17:38,240 --> 00:17:42,559
and but having that lack of space you

00:17:40,480 --> 00:17:44,640
are increasing data integrity your data

00:17:42,559 --> 00:17:47,679
is only written to one place

00:17:44,640 --> 00:17:49,280
so it can't be um

00:17:47,679 --> 00:17:51,520
you can't have any issues with the data

00:17:49,280 --> 00:17:54,640
being out of sync for example

00:17:51,520 --> 00:17:55,600
so that is a benefit of that so

00:17:54,640 --> 00:17:57,360
uh when you're talking about

00:17:55,600 --> 00:17:58,480
normalization for relational you're

00:17:57,360 --> 00:18:00,960
talking about the various

00:17:58,480 --> 00:18:02,400
uh normal forms i think normal form

00:18:00,960 --> 00:18:03,840
actually goes up to six

00:18:02,400 --> 00:18:06,080
normal forms but i don't think that's

00:18:03,840 --> 00:18:07,679
ever actually possible uh i think

00:18:06,080 --> 00:18:10,559
it's only theoretical that they've had

00:18:07,679 --> 00:18:12,559
different articles about

00:18:10,559 --> 00:18:14,240
but the more natural process is third

00:18:12,559 --> 00:18:15,840
normal form that's what most

00:18:14,240 --> 00:18:16,880
of when you're doing relational data

00:18:15,840 --> 00:18:17,919
modeling that's what you're trying to

00:18:16,880 --> 00:18:20,480
achieve

00:18:17,919 --> 00:18:23,120
and i've read a lot of articles about

00:18:20,480 --> 00:18:25,679
this and it says it's a natural process

00:18:23,120 --> 00:18:27,120
i would argue it really isn't but it

00:18:25,679 --> 00:18:28,559
feels like it if this is how you were

00:18:27,120 --> 00:18:30,559
formally trained

00:18:28,559 --> 00:18:32,240
i think most of us myself included when

00:18:30,559 --> 00:18:33,200
we started learning about databases and

00:18:32,240 --> 00:18:36,240
we learned about

00:18:33,200 --> 00:18:38,320
sql and data modeling we did that for

00:18:36,240 --> 00:18:39,360
relational databases first so i think

00:18:38,320 --> 00:18:42,160
this process

00:18:39,360 --> 00:18:43,120
feels more natural but in all honesty i

00:18:42,160 --> 00:18:46,720
would argue that

00:18:43,120 --> 00:18:49,120
it really isn't so what does that mean

00:18:46,720 --> 00:18:51,360
uh so with relational because we we're

00:18:49,120 --> 00:18:54,240
only having one copy of that data

00:18:51,360 --> 00:18:56,400
and we are breaking up all of our uh

00:18:54,240 --> 00:18:59,600
into these smaller and smaller tables

00:18:56,400 --> 00:19:01,679
what saves the day is joins so the only

00:18:59,600 --> 00:19:03,200
way we can combine that data to get all

00:19:01,679 --> 00:19:06,880
of the information that we need

00:19:03,200 --> 00:19:09,039
is with a join so ad hoc queries are

00:19:06,880 --> 00:19:10,000
are okay that's how you can just kind of

00:19:09,039 --> 00:19:12,799
you can just whatever

00:19:10,000 --> 00:19:14,240
your data model is you can do any query

00:19:12,799 --> 00:19:15,280
that you want on it to get the data that

00:19:14,240 --> 00:19:17,679
you want

00:19:15,280 --> 00:19:19,919
and so i say it's okay but honestly it's

00:19:17,679 --> 00:19:22,160
actually super expensive

00:19:19,919 --> 00:19:23,679
and they can take a lot of resources and

00:19:22,160 --> 00:19:25,520
a lot of time

00:19:23,679 --> 00:19:28,000
so here's just an example of that joint

00:19:25,520 --> 00:19:30,400
right so if i have a table called

00:19:28,000 --> 00:19:31,360
song and a table called artist and let's

00:19:30,400 --> 00:19:32,880
say i want

00:19:31,360 --> 00:19:35,280
right just like i want to show on my

00:19:32,880 --> 00:19:36,960
playlist i want to show the song name

00:19:35,280 --> 00:19:39,039
the year and the artist right that's

00:19:36,960 --> 00:19:40,000
just natural so what i'm going to have

00:19:39,039 --> 00:19:42,000
to do in this case

00:19:40,000 --> 00:19:43,840
is i'm going to have to select star from

00:19:42,000 --> 00:19:45,039
song and join on artist

00:19:43,840 --> 00:19:47,840
and then we need to join them on a

00:19:45,039 --> 00:19:50,480
common id in this particular case

00:19:47,840 --> 00:19:51,200
we have artist id artist idea and song

00:19:50,480 --> 00:19:54,000
and artist

00:19:51,200 --> 00:19:55,039
just id and in the artist table and so

00:19:54,000 --> 00:19:56,960
if we do that

00:19:55,039 --> 00:19:58,799
um we'll get the results back so for

00:19:56,960 --> 00:20:02,159
each song we'll also get

00:19:58,799 --> 00:20:05,039
the artist but what

00:20:02,159 --> 00:20:05,520
really saves the day so we talked about

00:20:05,039 --> 00:20:07,120
joins

00:20:05,520 --> 00:20:08,880
yes we have those and we have that

00:20:07,120 --> 00:20:09,600
ability but like we said they're super

00:20:08,880 --> 00:20:10,880
expensive

00:20:09,600 --> 00:20:12,640
so what really saves the day especially

00:20:10,880 --> 00:20:14,640
when we're talking about performance and

00:20:12,640 --> 00:20:16,559
that's denormalization

00:20:14,640 --> 00:20:18,720
so with denormalization and now this

00:20:16,559 --> 00:20:18,960
goes for not only for nosql databases

00:20:18,720 --> 00:20:20,880
and

00:20:18,960 --> 00:20:22,080
apache cassandra but also for relational

00:20:20,880 --> 00:20:25,520
databases

00:20:22,080 --> 00:20:28,720
um so it'll reduce the need for joins

00:20:25,520 --> 00:20:31,840
by combining and adding tables

00:20:28,720 --> 00:20:33,280
so add well i should say adding data to

00:20:31,840 --> 00:20:34,000
the tables you don't want to add more

00:20:33,280 --> 00:20:35,360
tables that's

00:20:34,000 --> 00:20:36,799
kind of the exact opposite of what we

00:20:35,360 --> 00:20:38,080
want to do because then you need more

00:20:36,799 --> 00:20:39,360
joins

00:20:38,080 --> 00:20:41,200
so what this is going to do is really

00:20:39,360 --> 00:20:42,480
going to reduce the time for your reads

00:20:41,200 --> 00:20:44,159
because you're not having to do those

00:20:42,480 --> 00:20:46,000
expensive joints

00:20:44,159 --> 00:20:47,440
but i will add a caveat it will increase

00:20:46,000 --> 00:20:49,120
the time for rights

00:20:47,440 --> 00:20:50,880
most likely because you're probably

00:20:49,120 --> 00:20:52,240
writing the same piece of data to

00:20:50,880 --> 00:20:54,000
multiple tables

00:20:52,240 --> 00:20:55,280
um but if you're working so if you're

00:20:54,000 --> 00:20:56,559
working with a relational that may be

00:20:55,280 --> 00:20:58,159
something you need to consider

00:20:56,559 --> 00:20:59,919
if you're working with nosql it's really

00:20:58,159 --> 00:21:02,960
not something you really need to keep

00:20:59,919 --> 00:21:05,039
in mind because the rights are so fast

00:21:02,960 --> 00:21:07,520
so here's basically the combination of

00:21:05,039 --> 00:21:09,760
those two previous tables into one table

00:21:07,520 --> 00:21:11,039
so here's the music table now we have

00:21:09,760 --> 00:21:13,280
our song our id

00:21:11,039 --> 00:21:14,960
our song our year and our artist and

00:21:13,280 --> 00:21:15,360
because in this particular case i'm

00:21:14,960 --> 00:21:17,919
using

00:21:15,360 --> 00:21:18,640
a relational query i can say select star

00:21:17,919 --> 00:21:20,240
from music

00:21:18,640 --> 00:21:22,720
and it's going to give me back my my

00:21:20,240 --> 00:21:25,840
playlist

00:21:22,720 --> 00:21:27,280
so here's just some relational

00:21:25,840 --> 00:21:29,120
tips so when you're doing relational

00:21:27,280 --> 00:21:30,799
data modeling you really start with your

00:21:29,120 --> 00:21:32,480
data right

00:21:30,799 --> 00:21:34,559
and you model the data according to

00:21:32,480 --> 00:21:36,000
those normal forms so you actually work

00:21:34,559 --> 00:21:37,440
slowly through the normal forms you

00:21:36,000 --> 00:21:39,679
start with first normal form

00:21:37,440 --> 00:21:41,200
then to second into third and you're

00:21:39,679 --> 00:21:41,600
always making sure you're reducing that

00:21:41,200 --> 00:21:44,960
data

00:21:41,600 --> 00:21:45,760
redundancy so then you can determine

00:21:44,960 --> 00:21:49,039
your queries

00:21:45,760 --> 00:21:49,039
based off of your data model

00:21:49,440 --> 00:21:53,600
so let's now talk about data modeling

00:21:51,679 --> 00:21:55,520
for apache cassandra

00:21:53,600 --> 00:21:57,280
so what you so basically everything that

00:21:55,520 --> 00:21:58,880
i just said you really need to flip it

00:21:57,280 --> 00:22:00,320
upside down

00:21:58,880 --> 00:22:03,520
you really want to start with your

00:22:00,320 --> 00:22:05,200
queries and your access patterns

00:22:03,520 --> 00:22:07,840
and you're saying wait what are you

00:22:05,200 --> 00:22:09,679
talking about how can i possibly know

00:22:07,840 --> 00:22:11,360
all of my queries that i need to do on

00:22:09,679 --> 00:22:13,600
my database

00:22:11,360 --> 00:22:15,520
and i would argue with you because you

00:22:13,600 --> 00:22:18,000
know a database like apache cassandra

00:22:15,520 --> 00:22:19,760
because it's built for

00:22:18,000 --> 00:22:21,919
applications right it's an application

00:22:19,760 --> 00:22:22,799
database when you think about it when

00:22:21,919 --> 00:22:25,280
you really sit down

00:22:22,799 --> 00:22:26,000
you whiteboard it out with your team you

00:22:25,280 --> 00:22:27,520
really can

00:22:26,000 --> 00:22:29,120
make you really can know all of your

00:22:27,520 --> 00:22:30,240
queries in advance maybe not every

00:22:29,120 --> 00:22:31,520
single one and

00:22:30,240 --> 00:22:33,520
then maybe some things that come down

00:22:31,520 --> 00:22:35,280
the line as you add new features etc

00:22:33,520 --> 00:22:37,200
but for the most part if you really take

00:22:35,280 --> 00:22:37,520
the time and outline it and think about

00:22:37,200 --> 00:22:39,679
it

00:22:37,520 --> 00:22:41,280
you really can get all of your queries

00:22:39,679 --> 00:22:45,039
uh noted

00:22:41,280 --> 00:22:48,240
um and provide the the tables that

00:22:45,039 --> 00:22:50,320
correspond to that so you're going to

00:22:48,240 --> 00:22:51,919
have to create a denormalized data model

00:22:50,320 --> 00:22:53,360
that's really essential there's really

00:22:51,919 --> 00:22:54,400
no way around it because we don't have

00:22:53,360 --> 00:22:57,520
joints

00:22:54,400 --> 00:22:58,880
and you apply that model to your data so

00:22:57,520 --> 00:23:01,919
just a reminder here

00:22:58,880 --> 00:23:03,760
bolded and in red denormalization of

00:23:01,919 --> 00:23:05,200
your tables for apache cassandra is

00:23:03,760 --> 00:23:06,799
absolutely critical

00:23:05,200 --> 00:23:08,159
that's what you have to do to make sure

00:23:06,799 --> 00:23:10,400
that you have a good data model for

00:23:08,159 --> 00:23:12,240
cassandra

00:23:10,400 --> 00:23:14,000
so okay how are we going to go about

00:23:12,240 --> 00:23:15,760
doing that so we really first we have to

00:23:14,000 --> 00:23:18,080
distribute the data

00:23:15,760 --> 00:23:19,440
so it's all about again we got red and

00:23:18,080 --> 00:23:20,159
we got bold here so you know it's

00:23:19,440 --> 00:23:22,640
important

00:23:20,159 --> 00:23:23,760
it's all about the primary key and i

00:23:22,640 --> 00:23:25,039
said seriously

00:23:23,760 --> 00:23:26,480
always always it's always about the

00:23:25,039 --> 00:23:28,960
primary key so let's talk about what the

00:23:26,480 --> 00:23:30,640
primary key actually is

00:23:28,960 --> 00:23:31,760
so what the primary key is going to do

00:23:30,640 --> 00:23:33,679
is actually it's going to distribute

00:23:31,760 --> 00:23:35,679
your data across the cluster

00:23:33,679 --> 00:23:37,200
and it's going to do that so the primary

00:23:35,679 --> 00:23:37,919
key we'll talk about this in a second

00:23:37,200 --> 00:23:40,559
but it's

00:23:37,919 --> 00:23:42,320
made up of the partition key and one or

00:23:40,559 --> 00:23:44,880
more clustering columns

00:23:42,320 --> 00:23:47,600
so the partition key is what's going to

00:23:44,880 --> 00:23:49,840
distribute it across the cluster

00:23:47,600 --> 00:23:50,960
and it's also going to provide a

00:23:49,840 --> 00:23:54,159
uniqueness

00:23:50,960 --> 00:23:56,159
to that row of data so in this

00:23:54,159 --> 00:23:58,000
particular table that i have

00:23:56,159 --> 00:24:00,000
i say i'm going to create the table

00:23:58,000 --> 00:24:01,919
we're going to call it cool jams

00:24:00,000 --> 00:24:03,360
we're going to have a column year a

00:24:01,919 --> 00:24:05,279
column song song name

00:24:03,360 --> 00:24:06,720
a column artist name and then we're

00:24:05,279 --> 00:24:08,559
going to use a primary key

00:24:06,720 --> 00:24:10,480
and also it's also going to this

00:24:08,559 --> 00:24:12,400
particular case our primary key is also

00:24:10,480 --> 00:24:15,440
our partition key

00:24:12,400 --> 00:24:18,640
and we're going to do that by year

00:24:15,440 --> 00:24:20,559
so when you think about this table so

00:24:18,640 --> 00:24:22,000
here's already a hint why this may be

00:24:20,559 --> 00:24:23,760
problematic right

00:24:22,000 --> 00:24:25,440
we think about what we're trying to save

00:24:23,760 --> 00:24:28,240
here which is year

00:24:25,440 --> 00:24:30,080
song name and artist name uh primary key

00:24:28,240 --> 00:24:31,600
and distributing by year

00:24:30,080 --> 00:24:34,640
probably not going to give us a unique

00:24:31,600 --> 00:24:36,960
value most likely

00:24:34,640 --> 00:24:39,039
actually very likely so this isn't

00:24:36,960 --> 00:24:41,600
really the best example for uniqueness

00:24:39,039 --> 00:24:43,600
but it's more around the idea of it just

00:24:41,600 --> 00:24:46,400
giving you of how you would partition

00:24:43,600 --> 00:24:47,600
partition the data in some some universe

00:24:46,400 --> 00:24:50,240
partitioning by year

00:24:47,600 --> 00:24:52,320
for songs may work but in ours it won't

00:24:50,240 --> 00:24:54,720
but you get the idea

00:24:52,320 --> 00:24:56,720
and then just to follow up on that again

00:24:54,720 --> 00:24:58,400
so your primary key can either just be

00:24:56,720 --> 00:25:01,679
made of just your partition key

00:24:58,400 --> 00:25:03,039
or one or more clustering columns

00:25:01,679 --> 00:25:05,360
so let's talk a little bit more about

00:25:03,039 --> 00:25:06,720
that partition key so it's what's

00:25:05,360 --> 00:25:09,120
actually going to determine the

00:25:06,720 --> 00:25:12,880
distribution of the data

00:25:09,120 --> 00:25:15,919
so it's going to um the partition key

00:25:12,880 --> 00:25:18,240
is your row value hashed

00:25:15,919 --> 00:25:19,120
so that's where once you you feed in

00:25:18,240 --> 00:25:20,960
that uh

00:25:19,120 --> 00:25:22,240
that partition key it's going to get

00:25:20,960 --> 00:25:24,480
hashed to a value

00:25:22,240 --> 00:25:25,440
which uh needs to be unique right

00:25:24,480 --> 00:25:26,159
because that's how it's going to be

00:25:25,440 --> 00:25:28,559
stored

00:25:26,159 --> 00:25:29,760
and from there that's where you know

00:25:28,559 --> 00:25:33,760
where it's going to live

00:25:29,760 --> 00:25:35,279
on the token uh the token range

00:25:33,760 --> 00:25:36,159
uh within your ring so that you're

00:25:35,279 --> 00:25:39,200
saying we're all familiar with the

00:25:36,159 --> 00:25:41,279
cassandra ring that's where it'll live

00:25:39,200 --> 00:25:42,320
so in this particular example i'm going

00:25:41,279 --> 00:25:44,720
to insert

00:25:42,320 --> 00:25:45,919
into my cool jams table which has year

00:25:44,720 --> 00:25:49,440
song name and artist name

00:25:45,919 --> 00:25:51,840
the values of 2018 truth hurts and lizzo

00:25:49,440 --> 00:25:54,000
and so because we partitioned by year

00:25:51,840 --> 00:25:54,720
2018 is going to go into our hash

00:25:54,000 --> 00:25:58,000
function

00:25:54,720 --> 00:25:59,120
it's going to pop out at 59 just just as

00:25:58,000 --> 00:25:59,919
an example would probably be something

00:25:59,120 --> 00:26:01,760
very different

00:25:59,919 --> 00:26:04,080
and then once i go to write that to my

00:26:01,760 --> 00:26:07,279
token my to my cluster

00:26:04,080 --> 00:26:09,200
it will figure out which where 59 lives

00:26:07,279 --> 00:26:11,919
on the token range and what node that

00:26:09,200 --> 00:26:13,520
that node would that data would be on

00:26:11,919 --> 00:26:14,159
and again this is kind of highlighting

00:26:13,520 --> 00:26:16,400
again

00:26:14,159 --> 00:26:17,760
why year is probably not the best value

00:26:16,400 --> 00:26:19,520
to partition by

00:26:17,760 --> 00:26:20,880
because any other song that was written

00:26:19,520 --> 00:26:22,720
in 2018

00:26:20,880 --> 00:26:25,600
would get hashed to 59 and that data

00:26:22,720 --> 00:26:26,799
would be overwritten

00:26:25,600 --> 00:26:28,880
so let's take a second and talk about

00:26:26,799 --> 00:26:29,360
clustering columns so again you can have

00:26:28,880 --> 00:26:33,840
zero

00:26:29,360 --> 00:26:35,279
or or or more of the clustering columns

00:26:33,840 --> 00:26:37,120
so not only does it provide some

00:26:35,279 --> 00:26:38,000
uniqueness to your to your key your

00:26:37,120 --> 00:26:40,000
primary key

00:26:38,000 --> 00:26:42,240
it also sorts the data in ascending

00:26:40,000 --> 00:26:44,159
order which is good to know

00:26:42,240 --> 00:26:45,360
um so in this particular case now we're

00:26:44,159 --> 00:26:48,720
seeing create table

00:26:45,360 --> 00:26:50,559
cool jams year artist name and song name

00:26:48,720 --> 00:26:52,240
and their primary key is now our

00:26:50,559 --> 00:26:53,760
partition key is still here

00:26:52,240 --> 00:26:55,360
but then we're adding a clustering

00:26:53,760 --> 00:26:57,679
column of artist name

00:26:55,360 --> 00:26:59,279
so we see here it's actually starting to

00:26:57,679 --> 00:27:02,720
be less problematic

00:26:59,279 --> 00:27:06,000
slightly because that value will uh

00:27:02,720 --> 00:27:08,320
will hash to a unique a more

00:27:06,000 --> 00:27:09,600
unique value uh than what we had before

00:27:08,320 --> 00:27:11,520
with just year

00:27:09,600 --> 00:27:13,279
um but in this particular case it's

00:27:11,520 --> 00:27:15,360
still not good enough because

00:27:13,279 --> 00:27:17,520
we would have i you know this is

00:27:15,360 --> 00:27:18,240
assuming an artist only has one song per

00:27:17,520 --> 00:27:20,399
year

00:27:18,240 --> 00:27:23,120
which we know is wrong uh but again this

00:27:20,399 --> 00:27:24,960
is just an example for y'all

00:27:23,120 --> 00:27:26,480
so let's talk uh about some data

00:27:24,960 --> 00:27:28,399
modeling best practices when we're

00:27:26,480 --> 00:27:31,120
dealing with apache cassandra

00:27:28,399 --> 00:27:31,520
so i think i made it pretty clear from

00:27:31,120 --> 00:27:33,520
this

00:27:31,520 --> 00:27:36,000
from this talk is that you don't want to

00:27:33,520 --> 00:27:38,720
move your data model from relational

00:27:36,000 --> 00:27:40,399
over to apache cassandra as is that's

00:27:38,720 --> 00:27:43,679
incredibly problematic

00:27:40,399 --> 00:27:46,799
it's not going to work um unless maybe

00:27:43,679 --> 00:27:48,320
all of your um tables that you had in

00:27:46,799 --> 00:27:51,279
relational were all

00:27:48,320 --> 00:27:53,039
uh denormalized and i don't know it just

00:27:51,279 --> 00:27:54,240
seems very highly highly unlikely you're

00:27:53,039 --> 00:27:54,720
gonna have to go back to the drawing

00:27:54,240 --> 00:27:56,399
board

00:27:54,720 --> 00:27:58,240
and really think about what you're

00:27:56,399 --> 00:27:59,760
trying to do with with cassandra what

00:27:58,240 --> 00:28:00,960
your application is trying to do what

00:27:59,760 --> 00:28:03,840
kind of queries you need

00:28:00,960 --> 00:28:06,399
etc the likelihood of bringing it over

00:28:03,840 --> 00:28:08,559
one for one is very unlikely

00:28:06,399 --> 00:28:10,880
so it really does take some thought but

00:28:08,559 --> 00:28:14,399
if you do that upfront work

00:28:10,880 --> 00:28:15,760
it it'll pay off so much in the long run

00:28:14,399 --> 00:28:18,960
another thing is you might want to think

00:28:15,760 --> 00:28:21,520
about using just one table per query

00:28:18,960 --> 00:28:22,960
um so that's that's really key here and

00:28:21,520 --> 00:28:24,320
really important

00:28:22,960 --> 00:28:25,760
and that's where we were talking about

00:28:24,320 --> 00:28:26,480
you know if you figure out your queries

00:28:25,760 --> 00:28:29,600
in advance

00:28:26,480 --> 00:28:32,640
you can set your tables up for that um

00:28:29,600 --> 00:28:36,320
so that way uh it's it's

00:28:32,640 --> 00:28:39,120
much simpler and you're not trying to

00:28:36,320 --> 00:28:41,840
make your table unnatural so that it can

00:28:39,120 --> 00:28:43,279
fit more than one query

00:28:41,840 --> 00:28:45,760
it's a much more natural process just to

00:28:43,279 --> 00:28:47,279
do the one table per one query

00:28:45,760 --> 00:28:48,480
so know your queries in advance we

00:28:47,279 --> 00:28:49,039
talked about that a little bit earlier

00:28:48,480 --> 00:28:51,200
before

00:28:49,039 --> 00:28:52,799
know your access patterns you know

00:28:51,200 --> 00:28:53,679
whiteboard it out with the team figure

00:28:52,799 --> 00:28:55,520
it out

00:28:53,679 --> 00:28:57,279
once you have those you can make the one

00:28:55,520 --> 00:28:59,440
table per one query

00:28:57,279 --> 00:29:02,399
and and you're going to be good to go

00:28:59,440 --> 00:29:05,039
also think about your where clause

00:29:02,399 --> 00:29:06,399
think about what you're actually because

00:29:05,039 --> 00:29:07,840
like we've been talking about you need

00:29:06,399 --> 00:29:08,799
to partition your data by something

00:29:07,840 --> 00:29:11,200
unique

00:29:08,799 --> 00:29:12,720
but you need to make sure that when

00:29:11,200 --> 00:29:14,720
you're going to be writing those queries

00:29:12,720 --> 00:29:16,559
that you're going to have the value

00:29:14,720 --> 00:29:18,399
that you need in that where clause

00:29:16,559 --> 00:29:19,200
because the where clause is essential

00:29:18,399 --> 00:29:21,200
you

00:29:19,200 --> 00:29:22,720
you can't do a select star from table in

00:29:21,200 --> 00:29:24,559
apache cassandra

00:29:22,720 --> 00:29:26,000
actually technically you can if you

00:29:24,559 --> 00:29:28,960
allow filtering which you should never

00:29:26,000 --> 00:29:29,919
ever do and there's no reason for that

00:29:28,960 --> 00:29:33,440
but

00:29:29,919 --> 00:29:35,200
um you have to have this where clause

00:29:33,440 --> 00:29:37,120
but you need to think about

00:29:35,200 --> 00:29:38,240
what values you will have in that moment

00:29:37,120 --> 00:29:40,240
to do that query

00:29:38,240 --> 00:29:41,679
so for example a really good way to

00:29:40,240 --> 00:29:43,840
partition um

00:29:41,679 --> 00:29:45,039
and get those unique keys is by using a

00:29:43,840 --> 00:29:47,039
uuid

00:29:45,039 --> 00:29:48,880
that will give you a unique key uh it'll

00:29:47,039 --> 00:29:52,080
distribute it evenly across the cluster

00:29:48,880 --> 00:29:53,600
that's all great but this is like a

00:29:52,080 --> 00:29:55,200
super long confusing

00:29:53,600 --> 00:29:57,360
number and letters i think there's

00:29:55,200 --> 00:29:59,120
letters in it too if i recall correctly

00:29:57,360 --> 00:30:01,520
you're most likely not going to have

00:29:59,120 --> 00:30:02,799
that uh accessible to you to do your

00:30:01,520 --> 00:30:05,120
query maybe you will

00:30:02,799 --> 00:30:06,240
uh and then that's great uh but you just

00:30:05,120 --> 00:30:08,799
want to think about

00:30:06,240 --> 00:30:10,799
what you what you will have um you know

00:30:08,799 --> 00:30:13,840
from your application from your users

00:30:10,799 --> 00:30:16,159
and to do that work clause and also just

00:30:13,840 --> 00:30:18,640
another reminder that denormalization is

00:30:16,159 --> 00:30:20,720
your best friend

00:30:18,640 --> 00:30:22,720
so uh here's a really nice tweet i got

00:30:20,720 --> 00:30:23,919
this a couple years ago and it was

00:30:22,720 --> 00:30:27,360
actually a

00:30:23,919 --> 00:30:28,720
really good uh it was a really long

00:30:27,360 --> 00:30:31,200
thread on twitter

00:30:28,720 --> 00:30:32,159
from jeremy daly it's really great so

00:30:31,200 --> 00:30:33,760
his was on

00:30:32,159 --> 00:30:36,159
how to switch from relational to

00:30:33,760 --> 00:30:36,880
dynamodb in 20 steps and so he had 20

00:30:36,159 --> 00:30:38,720
tweets

00:30:36,880 --> 00:30:40,320
um now this particular case is talking

00:30:38,720 --> 00:30:42,240
about dynamodb

00:30:40,320 --> 00:30:43,760
but nevertheless it's just another nosql

00:30:42,240 --> 00:30:44,799
database so i thought that this tweet

00:30:43,760 --> 00:30:46,480
was still

00:30:44,799 --> 00:30:48,240
still applicable uh to what we're

00:30:46,480 --> 00:30:50,240
talking about today so in this

00:30:48,240 --> 00:30:53,440
particular case he says determine

00:30:50,240 --> 00:30:55,200
if your user access patterns require ad

00:30:53,440 --> 00:30:55,919
hoc queries that need to reshape the

00:30:55,200 --> 00:30:57,279
data

00:30:55,919 --> 00:30:58,080
so we already kind of talked about that

00:30:57,279 --> 00:30:59,279
right when we're talking about

00:30:58,080 --> 00:31:01,120
relational and

00:30:59,279 --> 00:31:02,799
you know ad-hoc queries and in this

00:31:01,120 --> 00:31:05,919
particular case he's even outlining

00:31:02,799 --> 00:31:08,080
uh needing to reshape the data right

00:31:05,919 --> 00:31:10,080
so likely if you're looking at a nosql

00:31:08,080 --> 00:31:12,960
database the answer is no

00:31:10,080 --> 00:31:14,000
however if you're building an olap

00:31:12,960 --> 00:31:15,519
application

00:31:14,000 --> 00:31:17,279
so something that does these ad hoc

00:31:15,519 --> 00:31:21,039
queries and these analytics and these

00:31:17,279 --> 00:31:22,880
aggregations etc then nosql is no good

00:31:21,039 --> 00:31:24,640
pat yourself on the back for trying and

00:31:22,880 --> 00:31:26,240
use another technology

00:31:24,640 --> 00:31:27,600
so i really like this tweet because it's

00:31:26,240 --> 00:31:29,120
really really highlighting the

00:31:27,600 --> 00:31:32,159
differences between

00:31:29,120 --> 00:31:35,679
what one type of technology it's good

00:31:32,159 --> 00:31:35,679
for and what the other one is good for

00:31:35,840 --> 00:31:39,200
okay so since we have a little bit of

00:31:37,600 --> 00:31:41,200
time here i want to talk about how

00:31:39,200 --> 00:31:42,399
to fix some common issues uh that we've

00:31:41,200 --> 00:31:44,559
seen out there

00:31:42,399 --> 00:31:46,640
uh that uh these are a little bit more

00:31:44,559 --> 00:31:47,360
advanced than kind of the the basics but

00:31:46,640 --> 00:31:49,039
you know once

00:31:47,360 --> 00:31:50,799
once you kind of get things uh

00:31:49,039 --> 00:31:53,120
transferred over and then

00:31:50,799 --> 00:31:54,000
um you know some some issues that you

00:31:53,120 --> 00:31:55,760
may find

00:31:54,000 --> 00:31:57,200
along the way so there's data

00:31:55,760 --> 00:31:59,279
distribution issues

00:31:57,200 --> 00:32:01,840
deleting data issues and data integrity

00:31:59,279 --> 00:32:01,840
issues

00:32:03,919 --> 00:32:08,000
so issues with your primary key so we've

00:32:06,720 --> 00:32:09,039
i've already kind of talked about this

00:32:08,000 --> 00:32:11,200
quite a bit now

00:32:09,039 --> 00:32:12,240
but make sure that that primary key

00:32:11,200 --> 00:32:15,440
actually gives you

00:32:12,240 --> 00:32:16,960
unique rows um i've done that a lot just

00:32:15,440 --> 00:32:18,000
myself especially when i was getting

00:32:16,960 --> 00:32:19,200
started

00:32:18,000 --> 00:32:20,559
i would think i was getting something

00:32:19,200 --> 00:32:21,279
unique and then my data was being

00:32:20,559 --> 00:32:24,399
overwritten

00:32:21,279 --> 00:32:26,880
and i wouldn't really realize why uh

00:32:24,399 --> 00:32:28,399
and this happens out in even production

00:32:26,880 --> 00:32:29,120
systems as well so make sure that you

00:32:28,399 --> 00:32:31,120
have that

00:32:29,120 --> 00:32:33,760
make sure that the primary key evenly

00:32:31,120 --> 00:32:35,120
just distributes the data

00:32:33,760 --> 00:32:37,279
so you want to make sure that you're not

00:32:35,120 --> 00:32:38,799
going to have um you know hot partitions

00:32:37,279 --> 00:32:40,960
where you've you've picked a

00:32:38,799 --> 00:32:42,240
distribution or a partition key

00:32:40,960 --> 00:32:44,159
that actually doesn't distribute the

00:32:42,240 --> 00:32:44,640
data very evenly let's just think about

00:32:44,159 --> 00:32:47,840
like a

00:32:44,640 --> 00:32:50,559
a good example uh would be maybe state

00:32:47,840 --> 00:32:51,840
if you're if you're using key of state

00:32:50,559 --> 00:32:53,360
uh because a lot more people live in the

00:32:51,840 --> 00:32:55,200
state of california like i do

00:32:53,360 --> 00:32:57,279
versus people who live in rhode island

00:32:55,200 --> 00:32:59,840
right so most likely that's probably not

00:32:57,279 --> 00:33:01,519
going to distribute your data evenly

00:32:59,840 --> 00:33:04,159
so that's all about testing testing

00:33:01,519 --> 00:33:05,039
tests stress tests for hot partitions

00:33:04,159 --> 00:33:07,360
that's how you're going to kind of

00:33:05,039 --> 00:33:09,039
figure that out also make sure that your

00:33:07,360 --> 00:33:11,039
partitions are not too large

00:33:09,039 --> 00:33:12,559
i know there's a fix for that in apache

00:33:11,039 --> 00:33:14,320
cassandra 4.0

00:33:12,559 --> 00:33:15,600
uh but and if you're not using apache

00:33:14,320 --> 00:33:17,120
cassandra 4.0

00:33:15,600 --> 00:33:18,960
you can use bucketing to break up those

00:33:17,120 --> 00:33:21,200
large partitions

00:33:18,960 --> 00:33:22,399
so let's talk a second about tombstones

00:33:21,200 --> 00:33:24,000
um i know i might be

00:33:22,399 --> 00:33:26,159
getting close to my time here so i'm

00:33:24,000 --> 00:33:27,360
going to kind of speed it up here

00:33:26,159 --> 00:33:28,720
but if you're not familiar with

00:33:27,360 --> 00:33:29,840
tombstones if you're if you're brand new

00:33:28,720 --> 00:33:32,320
to cassandra

00:33:29,840 --> 00:33:32,960
tombstones are a deletion marker so it

00:33:32,320 --> 00:33:35,039
actually

00:33:32,960 --> 00:33:36,320
with cassandra it treats a delete as an

00:33:35,039 --> 00:33:38,880
additional insert or

00:33:36,320 --> 00:33:40,559
upsert and they will be removed with

00:33:38,880 --> 00:33:41,760
compaction but it really depends on what

00:33:40,559 --> 00:33:44,320
your compaction

00:33:41,760 --> 00:33:46,080
schedule is uh whether this will be

00:33:44,320 --> 00:33:48,399
affect you and your cluster

00:33:46,080 --> 00:33:50,240
so they happen uh when you have a lot of

00:33:48,399 --> 00:33:53,440
deletes or just any deletes

00:33:50,240 --> 00:33:56,080
and inserting null values so why is this

00:33:53,440 --> 00:33:58,880
so scary why is it called the tombstone

00:33:56,080 --> 00:34:00,159
so it impacts performance it will cause

00:33:58,880 --> 00:34:02,159
slow reads

00:34:00,159 --> 00:34:04,080
it will uh fill up your disk space for

00:34:02,159 --> 00:34:06,720
sure especially have a lot of

00:34:04,080 --> 00:34:08,000
nulls or a lot of deletes and this is

00:34:06,720 --> 00:34:09,919
kind of one of the reasons why we will

00:34:08,000 --> 00:34:12,240
actually see apache cassandra crash

00:34:09,919 --> 00:34:15,040
apache cassandra's super stable but a

00:34:12,240 --> 00:34:17,200
lot of tombstones will cause it to crash

00:34:15,040 --> 00:34:18,159
so how do you prevent them so first and

00:34:17,200 --> 00:34:21,280
foremost avoid

00:34:18,159 --> 00:34:22,960
null so when adding a row with an

00:34:21,280 --> 00:34:24,560
unknown column value you don't know it

00:34:22,960 --> 00:34:25,919
yet just leave it blank

00:34:24,560 --> 00:34:27,599
you don't have to put null like you do

00:34:25,919 --> 00:34:29,440
in a relational database you just don't

00:34:27,599 --> 00:34:31,599
say anything at all

00:34:29,440 --> 00:34:33,440
or when you're editing a row you can

00:34:31,599 --> 00:34:36,399
actually use unset

00:34:33,440 --> 00:34:37,839
to remove that value so only update the

00:34:36,399 --> 00:34:40,000
fields that you need

00:34:37,839 --> 00:34:41,760
don't add null just add nothing do

00:34:40,000 --> 00:34:43,280
nothing

00:34:41,760 --> 00:34:45,599
okay and then just one last thing here

00:34:43,280 --> 00:34:46,240
around batches so to increase the

00:34:45,599 --> 00:34:48,159
likelihood

00:34:46,240 --> 00:34:49,599
of having data integrity you can

00:34:48,159 --> 00:34:52,079
actually use batches

00:34:49,599 --> 00:34:53,679
now this is not transactional um in that

00:34:52,079 --> 00:34:54,159
sense but it does kind of help you

00:34:53,679 --> 00:34:55,520
because

00:34:54,159 --> 00:34:57,520
you may be writing the same piece of

00:34:55,520 --> 00:34:59,280
data to many different tables

00:34:57,520 --> 00:35:00,640
um and because of it because you've done

00:34:59,280 --> 00:35:03,119
all that denormalization

00:35:00,640 --> 00:35:04,720
batches really help you with that so you

00:35:03,119 --> 00:35:06,079
can actually put all your inserts that

00:35:04,720 --> 00:35:07,839
you need to do of that same piece of

00:35:06,079 --> 00:35:11,200
data that are into other tables

00:35:07,839 --> 00:35:11,520
um in the same batch and they'll all

00:35:11,200 --> 00:35:13,040
come

00:35:11,520 --> 00:35:15,040
they will all complete or an error will

00:35:13,040 --> 00:35:15,680
return with a timeout so the error will

00:35:15,040 --> 00:35:17,839
return

00:35:15,680 --> 00:35:19,520
again it's not acid there's no rollback

00:35:17,839 --> 00:35:21,920
but at least you'll know that there was

00:35:19,520 --> 00:35:24,079
an issue and you'll know to go retry

00:35:21,920 --> 00:35:26,000
so you start off a batch with begin

00:35:24,079 --> 00:35:27,760
batch then your insert statements

00:35:26,000 --> 00:35:29,119
and then apply batch and it will it'll

00:35:27,760 --> 00:35:32,000
go

00:35:29,119 --> 00:35:32,560
righty well i hope that was helpful um

00:35:32,000 --> 00:35:35,760
just as

00:35:32,560 --> 00:35:37,599
a note uh we are hiring at apple um

00:35:35,760 --> 00:35:38,960
we have our booth uh please come to our

00:35:37,599 --> 00:35:39,680
booth i think we're open for a little

00:35:38,960 --> 00:35:41,760
bit longer

00:35:39,680 --> 00:35:43,680
not quite sure uh but nevertheless uh

00:35:41,760 --> 00:35:46,640
access these links we're hiring

00:35:43,680 --> 00:35:48,880
on my team and greater apple of course

00:35:46,640 --> 00:35:50,400
internships and full-time

00:35:48,880 --> 00:35:51,599
and thank you so much for this this is

00:35:50,400 --> 00:35:52,960
wonderful i hope you all learned

00:35:51,599 --> 00:35:55,760
something today and i really enjoyed

00:35:52,960 --> 00:35:59,839
uh chatting with you all so i don't know

00:35:55,760 --> 00:35:59,839
if we have time for questions

00:36:04,000 --> 00:36:07,839
i'm actually not quite sure when my

00:36:05,760 --> 00:36:13,839
session ends

00:36:07,839 --> 00:36:13,839
that's why we need the moderator

00:36:18,000 --> 00:36:20,720
thanks everyone

00:36:23,599 --> 00:36:27,839
oh and dan you did find my twitter

00:36:25,040 --> 00:36:27,839
awesome thank you

00:36:34,320 --> 00:36:37,920
so we do have a question around what's a

00:36:36,560 --> 00:36:39,359
good use case for changing from

00:36:37,920 --> 00:36:41,359
relational to nosql

00:36:39,359 --> 00:36:43,119
um that kind of goes around think about

00:36:41,359 --> 00:36:44,800
your so think about basically all of the

00:36:43,119 --> 00:36:45,680
applications that are actually on your

00:36:44,800 --> 00:36:47,280
phone

00:36:45,680 --> 00:36:49,119
um that's always a good way i've heard a

00:36:47,280 --> 00:36:52,480
lot of my former colleagues state

00:36:49,119 --> 00:36:53,119
um you know think of applications that

00:36:52,480 --> 00:36:54,880
need

00:36:53,119 --> 00:36:57,280
high availability they always need to be

00:36:54,880 --> 00:36:59,599
up you can have no downtime

00:36:57,280 --> 00:37:01,119
um those types of and that need that

00:36:59,599 --> 00:37:03,839
fast reason rights

00:37:01,119 --> 00:37:06,000
um so think about think about twitter

00:37:03,839 --> 00:37:08,800
twitter has a huge cassandra cluster

00:37:06,000 --> 00:37:10,560
uh think about netflix um things like

00:37:08,800 --> 00:37:11,599
that so if you have applications that

00:37:10,560 --> 00:37:14,480
need that kind of

00:37:11,599 --> 00:37:15,680
high availability and scalability and

00:37:14,480 --> 00:37:17,920
read and write throughput

00:37:15,680 --> 00:37:20,000
then you want to think about using nosql

00:37:17,920 --> 00:37:36,640
and and and probably cassandra but

00:37:20,000 --> 00:37:39,839
nosql for sure good question

00:37:36,640 --> 00:37:41,680
awesome everyone well

00:37:39,839 --> 00:37:43,119
like i said i'm not quite sure when my

00:37:41,680 --> 00:37:46,160
session is over

00:37:43,119 --> 00:37:46,880
but i think i think it's now so i'm

00:37:46,160 --> 00:37:49,599
gonna sign

00:37:46,880 --> 00:37:51,280
off and thank you all for joining and

00:37:49,599 --> 00:37:52,400
thank you for coming to apachecon and i

00:37:51,280 --> 00:37:55,760
hope to see you all

00:37:52,400 --> 00:37:57,040
hopefully in person next year next year

00:37:55,760 --> 00:38:05,839
the year after that

00:37:57,040 --> 00:38:05,839
alrighty everyone stay well thank you

00:38:18,720 --> 00:38:20,800

YouTube URL: https://www.youtube.com/watch?v=td5QRYOeGag


