Title: SourceMarker - Continuous Feedback for Developers
Publication date: 2020-10-16
Playlist: ApacheCon @Home 2020: Observability
Description: 
	SourceMarker - Continuous Feedback for Developers
Brandon Fergerson

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Today's monitoring solutions are geared towards operational tasks, displaying behavior as time-series graphs inside dashboards and other abstractions. These abstractions are immensely useful but are largely designed for software operators, whose responsibilities require them to think in systems, rather than the underlying source code. This is problematic given that an ongoing trend of software development is the blurring boundaries between building and operating software. This trend makes it increasingly necessary for programming environments to not just support development-centric activities, but operation-centric activities as well. Such is the goal of the feedback-driven development approach. By combining IDE and APM technology, software developers can intuitively explore multiple dimensions of their software simultaneously with continuous feedback about their software from inception to production.

Brandon Fergerson is an open-source software developer who does not regard himself as a specialist in the field of programming, but rather as someone who is a devoted admirer. He discovered the beauty of programming at a young age and views programming as an art and those who do it well to be artists. He has an affinity towards getting meta and combining that with admiration of programming, has found source code analysis to be exceptionally interesting. Lately, his primary focus involves researching and building AI-based pair programming technology.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:25,119 --> 00:00:27,760
hello everyone

00:00:26,080 --> 00:00:29,359
my name is brandon ferguson and my

00:00:27,760 --> 00:00:31,439
presentation is called source marker

00:00:29,359 --> 00:00:33,040
continuous feedback for developers it is

00:00:31,439 --> 00:00:34,399
my hope that this talk excites software

00:00:33,040 --> 00:00:35,920
developers about a novel way for

00:00:34,399 --> 00:00:36,480
developing and operating software in

00:00:35,920 --> 00:00:37,760
tandem

00:00:36,480 --> 00:00:38,719
the software is still in early

00:00:37,760 --> 00:00:40,320
development so if you have any

00:00:38,719 --> 00:00:41,520
suggestions i would be very easy to hear

00:00:40,320 --> 00:00:43,360
them

00:00:41,520 --> 00:00:44,960
like i said my name is brandon ferguson

00:00:43,360 --> 00:00:46,480
i'm a software developer by trade

00:00:44,960 --> 00:00:48,320
and these days i primarily find myself

00:00:46,480 --> 00:00:49,200
working on ai-based pair programming

00:00:48,320 --> 00:00:50,559
technology

00:00:49,200 --> 00:00:52,160
if that or anything in this talk

00:00:50,559 --> 00:00:53,680
interests you there's my email feel free

00:00:52,160 --> 00:00:55,440
to message me

00:00:53,680 --> 00:00:57,039
for an idea of how i structure this talk

00:00:55,440 --> 00:00:58,559
i've included a brief agenda

00:00:57,039 --> 00:01:00,399
first i'll offer my perspective and

00:00:58,559 --> 00:01:01,680
introduce an issue i see a possible

00:01:00,399 --> 00:01:03,280
solution to that issue

00:01:01,680 --> 00:01:04,960
my implementation and demonstration of

00:01:03,280 --> 00:01:06,320
that solution and then i'll finish the

00:01:04,960 --> 00:01:09,040
talk off with where i think this type of

00:01:06,320 --> 00:01:10,479
technology is headed

00:01:09,040 --> 00:01:11,600
so before we can talk about where things

00:01:10,479 --> 00:01:12,159
are headed i'd like to give some

00:01:11,600 --> 00:01:13,280
perspective

00:01:12,159 --> 00:01:14,720
about where i believe the field of

00:01:13,280 --> 00:01:17,040
software development has come from and

00:01:14,720 --> 00:01:18,640
where it is

00:01:17,040 --> 00:01:19,840
my motivating belief for this talk is

00:01:18,640 --> 00:01:21,439
that the lines between software

00:01:19,840 --> 00:01:23,040
development and software operation are

00:01:21,439 --> 00:01:24,640
becoming increasingly blurred

00:01:23,040 --> 00:01:26,640
that is to say that these days

00:01:24,640 --> 00:01:27,600
developing software invariably involves

00:01:26,640 --> 00:01:29,200
operating software

00:01:27,600 --> 00:01:31,040
and operating software invariably

00:01:29,200 --> 00:01:32,560
involves developing software

00:01:31,040 --> 00:01:34,560
you can see that trend happening with

00:01:32,560 --> 00:01:35,759
the rise of low no code development and

00:01:34,560 --> 00:01:37,280
serverless computing

00:01:35,759 --> 00:01:38,640
it's even easier to see that trend when

00:01:37,280 --> 00:01:39,840
you look at how we create software

00:01:38,640 --> 00:01:42,000
compared to how we used to create

00:01:39,840 --> 00:01:43,600
software

00:01:42,000 --> 00:01:44,880
one of the earliest methodologies we

00:01:43,600 --> 00:01:46,720
used for creating software was called

00:01:44,880 --> 00:01:48,399
the waterfall methodology which involved

00:01:46,720 --> 00:01:50,320
a long stage of designing followed by a

00:01:48,399 --> 00:01:51,600
long stage of building and so on

00:01:50,320 --> 00:01:53,119
each stage in the style development

00:01:51,600 --> 00:01:54,000
would only start once the previous stage

00:01:53,119 --> 00:01:55,119
was completely finished

00:01:54,000 --> 00:01:57,040
and we called that completion of

00:01:55,119 --> 00:01:58,560
milestone

00:01:57,040 --> 00:01:59,759
and a consequence of this style of

00:01:58,560 --> 00:02:01,439
software development is that there is a

00:01:59,759 --> 00:02:02,880
long interval between designing features

00:02:01,439 --> 00:02:03,680
and delivering or deploying those

00:02:02,880 --> 00:02:05,520
features

00:02:03,680 --> 00:02:06,719
the reason being the waterfall mythology

00:02:05,520 --> 00:02:07,439
is an everything or nothing sort of

00:02:06,719 --> 00:02:08,720
mythology

00:02:07,439 --> 00:02:10,560
you either get all the features or you

00:02:08,720 --> 00:02:11,920
get none of the features here you can

00:02:10,560 --> 00:02:13,280
see that there are four pictures to

00:02:11,920 --> 00:02:15,120
deliver and all four features are

00:02:13,280 --> 00:02:16,400
delivered together

00:02:15,120 --> 00:02:18,160
you can visualize the waterfall

00:02:16,400 --> 00:02:19,760
mythology like this a long period of

00:02:18,160 --> 00:02:20,560
little to no value followed by a rapid

00:02:19,760 --> 00:02:22,080
increase in value

00:02:20,560 --> 00:02:24,239
once the entire product with all the

00:02:22,080 --> 00:02:26,160
features is delivered

00:02:24,239 --> 00:02:28,000
then we improved on this process and we

00:02:26,160 --> 00:02:29,120
developed the agile mythology here you

00:02:28,000 --> 00:02:30,640
can see we've shortened the amount of

00:02:29,120 --> 00:02:32,239
time we spent on each stage and instead

00:02:30,640 --> 00:02:33,840
of milestones we have sprints

00:02:32,239 --> 00:02:35,440
whereas a milestone indicated we were

00:02:33,840 --> 00:02:36,080
done with a specific stage for the life

00:02:35,440 --> 00:02:37,599
of the product

00:02:36,080 --> 00:02:39,519
a sprint simply indicates that we've

00:02:37,599 --> 00:02:40,959
delivered or deployed some features and

00:02:39,519 --> 00:02:43,360
now it's time to do it again with even

00:02:40,959 --> 00:02:44,879
more features

00:02:43,360 --> 00:02:46,720
here you can see instead of delivering

00:02:44,879 --> 00:02:47,920
all four features at once two features

00:02:46,720 --> 00:02:49,360
are delivered at a time

00:02:47,920 --> 00:02:51,200
whereas milestones are typically

00:02:49,360 --> 00:02:52,720
measured in months sprints are typically

00:02:51,200 --> 00:02:54,239
measured in weeks and the reason why

00:02:52,720 --> 00:02:55,760
sprints can be completed in weeks is

00:02:54,239 --> 00:02:56,480
because they deliver fewer features at a

00:02:55,760 --> 00:02:58,000
time

00:02:56,480 --> 00:02:59,840
instead of delivering all four features

00:02:58,000 --> 00:03:01,760
at once as with the waterfall mythology

00:02:59,840 --> 00:03:03,200
the agile mythology incentivizes

00:03:01,760 --> 00:03:04,959
smaller groupings of features with

00:03:03,200 --> 00:03:06,720
additional features coming via software

00:03:04,959 --> 00:03:08,480
updates

00:03:06,720 --> 00:03:10,400
and then finally we have what's known as

00:03:08,480 --> 00:03:12,239
a devops mythology this is where we get

00:03:10,400 --> 00:03:13,920
concepts such as continuous integration

00:03:12,239 --> 00:03:14,640
continuous delivery and continuous

00:03:13,920 --> 00:03:15,920
deployment

00:03:14,640 --> 00:03:17,519
one of the first things you notice about

00:03:15,920 --> 00:03:19,120
this mythology is that there are no

00:03:17,519 --> 00:03:20,879
milestones or sprints

00:03:19,120 --> 00:03:22,319
this mythology automates the process of

00:03:20,879 --> 00:03:24,000
delivering features so well

00:03:22,319 --> 00:03:25,680
that the act of delivering or deploying

00:03:24,000 --> 00:03:27,120
something is not seen as a special event

00:03:25,680 --> 00:03:28,879
but rather as a non-event

00:03:27,120 --> 00:03:30,480
it is viewed as just another step among

00:03:28,879 --> 00:03:32,560
many other steps in the process of

00:03:30,480 --> 00:03:34,159
developing software

00:03:32,560 --> 00:03:35,519
and what the devops mythology allows you

00:03:34,159 --> 00:03:36,959
to do is to get features delivered

00:03:35,519 --> 00:03:37,680
faster than all the other mythologies

00:03:36,959 --> 00:03:38,959
before it

00:03:37,680 --> 00:03:40,799
instead of taking months to complete a

00:03:38,959 --> 00:03:42,159
milestone or weeks to complete a sprint

00:03:40,799 --> 00:03:43,360
you can deliver features in a matter of

00:03:42,159 --> 00:03:45,040
hours or days

00:03:43,360 --> 00:03:47,280
the limiting factor being however long

00:03:45,040 --> 00:03:49,040
it takes to code and test those features

00:03:47,280 --> 00:03:50,480
the reason why the devops mythology can

00:03:49,040 --> 00:03:51,920
do this is because it provides the

00:03:50,480 --> 00:03:52,400
infrastructure to deliver features one

00:03:51,920 --> 00:03:53,760
at a time

00:03:52,400 --> 00:03:56,159
given that this process is heavily

00:03:53,760 --> 00:03:57,439
automated

00:03:56,159 --> 00:03:58,959
you can see the difference between the

00:03:57,439 --> 00:04:00,879
devops and the waterfall mythologies

00:03:58,959 --> 00:04:02,480
when you contrast how they deliver value

00:04:00,879 --> 00:04:03,760
using the waterfall mythology you need

00:04:02,480 --> 00:04:05,280
to know up front what value you'll be

00:04:03,760 --> 00:04:07,360
delivering and until you realize that

00:04:05,280 --> 00:04:09,360
you typically aren't providing any value

00:04:07,360 --> 00:04:11,280
conversely the devops mythology provides

00:04:09,360 --> 00:04:13,280
much more flexibility by allowing you to

00:04:11,280 --> 00:04:14,879
incrementally improve value over time

00:04:13,280 --> 00:04:16,079
you can release a feature see how well

00:04:14,879 --> 00:04:18,000
it's received and then use that

00:04:16,079 --> 00:04:19,840
reception as a catalyst for determining

00:04:18,000 --> 00:04:20,639
how to maximize the value your software

00:04:19,840 --> 00:04:22,320
provides

00:04:20,639 --> 00:04:23,840
consequently increasing software

00:04:22,320 --> 00:04:25,680
operations influence on software

00:04:23,840 --> 00:04:27,360
development which explains the rise in

00:04:25,680 --> 00:04:29,360
software monitoring and observability

00:04:27,360 --> 00:04:30,720
technology

00:04:29,360 --> 00:04:31,759
in the waterfall mythology a

00:04:30,720 --> 00:04:32,800
relationship between software

00:04:31,759 --> 00:04:34,800
development and software

00:04:32,800 --> 00:04:36,160
operation does exist but they're fairly

00:04:34,800 --> 00:04:37,360
far removed from each other

00:04:36,160 --> 00:04:39,280
before everything was connected to

00:04:37,360 --> 00:04:40,639
internet software was often physically

00:04:39,280 --> 00:04:42,320
shipped inside products and that

00:04:40,639 --> 00:04:44,160
software was difficult to update and

00:04:42,320 --> 00:04:45,520
when software is difficult to update

00:04:44,160 --> 00:04:47,040
ideally you want all the features that

00:04:45,520 --> 00:04:48,000
are necessary or desired to be

00:04:47,040 --> 00:04:49,600
pre-included

00:04:48,000 --> 00:04:51,360
again the everything or nothing sort of

00:04:49,600 --> 00:04:53,199
mythology and a consequence of this

00:04:51,360 --> 00:04:54,800
mythology is that the team that supports

00:04:53,199 --> 00:04:56,080
the operations of the software is often

00:04:54,800 --> 00:04:57,840
completely different than the team which

00:04:56,080 --> 00:04:59,840
developed it

00:04:57,840 --> 00:05:01,440
then we moved to the agile mythology in

00:04:59,840 --> 00:05:02,720
the agile mythology the gap between

00:05:01,440 --> 00:05:04,639
software development and software

00:05:02,720 --> 00:05:06,240
operations dramatically decreased

00:05:04,639 --> 00:05:07,680
this methodology is less useful for

00:05:06,240 --> 00:05:08,960
products which are difficult to update

00:05:07,680 --> 00:05:10,720
and require the everything or nothing

00:05:08,960 --> 00:05:12,800
sort of delivery but can be very useful

00:05:10,720 --> 00:05:14,240
for software which is easy to update

00:05:12,800 --> 00:05:15,680
you still have a team dedicated to

00:05:14,240 --> 00:05:17,520
development in a team dedicated to

00:05:15,680 --> 00:05:18,560
operation but in the agile mythology

00:05:17,520 --> 00:05:20,080
there is an increased amount of

00:05:18,560 --> 00:05:21,919
communication happening between these

00:05:20,080 --> 00:05:23,360
teams

00:05:21,919 --> 00:05:25,360
and then finally we moved on to the

00:05:23,360 --> 00:05:26,960
devops mythology using the devops

00:05:25,360 --> 00:05:28,320
mythology the gap between software

00:05:26,960 --> 00:05:30,000
development and software operations

00:05:28,320 --> 00:05:31,280
dramatically decreased yet again

00:05:30,000 --> 00:05:33,280
now we're almost to a point where there

00:05:31,280 --> 00:05:34,800
is no gap an example of this small gap

00:05:33,280 --> 00:05:36,800
can be seen with technology such as

00:05:34,800 --> 00:05:38,720
function as a service architecture

00:05:36,800 --> 00:05:40,720
this technology enables us to build and

00:05:38,720 --> 00:05:42,000
operate vastly scalable applications

00:05:40,720 --> 00:05:42,560
with not much more than an internet

00:05:42,000 --> 00:05:44,400
connection

00:05:42,560 --> 00:05:46,080
and a bit of programming knowledge the

00:05:44,400 --> 00:05:47,280
devops mythology has created a gap

00:05:46,080 --> 00:05:48,960
between software development and

00:05:47,280 --> 00:05:50,800
software operations so small

00:05:48,960 --> 00:05:53,280
that we even have those that jump back

00:05:50,800 --> 00:05:54,880
and forth between these practices

00:05:53,280 --> 00:05:56,720
these are the ones we call our devops

00:05:54,880 --> 00:05:58,720
engineers and i think that's progress

00:05:56,720 --> 00:06:00,319
so then what's the issue well i believe

00:05:58,720 --> 00:06:01,440
the issue is that even though the lines

00:06:00,319 --> 00:06:02,800
between software development and

00:06:01,440 --> 00:06:03,840
software operation are becoming

00:06:02,800 --> 00:06:06,639
increasingly blurred

00:06:03,840 --> 00:06:07,759
most still view these practices like so

00:06:06,639 --> 00:06:09,039
which is essentially that they're

00:06:07,759 --> 00:06:10,800
completely different practices which

00:06:09,039 --> 00:06:12,639
require completely different teams

00:06:10,800 --> 00:06:14,080
and this mostly makes sense when you see

00:06:12,639 --> 00:06:16,800
how different the typical environment

00:06:14,080 --> 00:06:18,479
involved with these practices appear

00:06:16,800 --> 00:06:20,800
as software developers we consider the

00:06:18,479 --> 00:06:21,680
ide to be close to if not the heart of

00:06:20,800 --> 00:06:22,960
our profession

00:06:21,680 --> 00:06:24,319
almost everything we do related to

00:06:22,960 --> 00:06:25,280
software development we do inside a

00:06:24,319 --> 00:06:27,039
variety ease

00:06:25,280 --> 00:06:28,720
to us an application is mainly a

00:06:27,039 --> 00:06:30,319
collection of logic and configuration

00:06:28,720 --> 00:06:32,160
files

00:06:30,319 --> 00:06:33,600
as software operators we have a much

00:06:32,160 --> 00:06:34,400
different view of that very same

00:06:33,600 --> 00:06:36,000
application

00:06:34,400 --> 00:06:37,759
an application is less the collection of

00:06:36,000 --> 00:06:39,120
logic and configuration files and more

00:06:37,759 --> 00:06:40,880
of a system of services

00:06:39,120 --> 00:06:42,479
each with various health and operational

00:06:40,880 --> 00:06:43,600
metrics which indicate the current state

00:06:42,479 --> 00:06:45,600
of the application

00:06:43,600 --> 00:06:47,360
the logic of how the application works

00:06:45,600 --> 00:06:49,520
means much less to a software operator

00:06:47,360 --> 00:06:50,880
as they are less interested in specifics

00:06:49,520 --> 00:06:52,720
and more interested in the overall

00:06:50,880 --> 00:06:54,319
condition of the entire application

00:06:52,720 --> 00:06:55,919
one way to see this distinction is that

00:06:54,319 --> 00:06:57,919
software developers think about how an

00:06:55,919 --> 00:06:59,520
application could or should be used

00:06:57,919 --> 00:07:03,039
and software operators think about how

00:06:59,520 --> 00:07:04,800
an application is used in actuality

00:07:03,039 --> 00:07:06,560
and when you show developers dashboards

00:07:04,800 --> 00:07:09,520
formulated by the software they develop

00:07:06,560 --> 00:07:10,160
where you get a response is like these

00:07:09,520 --> 00:07:12,800
they'll say

00:07:10,160 --> 00:07:14,240
that's an operations thing or our devops

00:07:12,800 --> 00:07:15,199
guy handles the whole monitoring and

00:07:14,240 --> 00:07:16,400
tools thing

00:07:15,199 --> 00:07:18,000
this is because even though these

00:07:16,400 --> 00:07:18,639
metrics describe how source code

00:07:18,000 --> 00:07:20,240
operates

00:07:18,639 --> 00:07:21,840
developers have difficulty relating

00:07:20,240 --> 00:07:23,360
these metrics and their meanings into

00:07:21,840 --> 00:07:25,520
the source code that they create inside

00:07:23,360 --> 00:07:27,120
of their ides

00:07:25,520 --> 00:07:29,280
so instead what you find is that

00:07:27,120 --> 00:07:30,720
developers before utilizing existing

00:07:29,280 --> 00:07:32,319
metrics much rather rely on their

00:07:30,720 --> 00:07:33,440
experience and intuition to solve

00:07:32,319 --> 00:07:35,520
problems

00:07:33,440 --> 00:07:37,599
yes developers will turn to metrics but

00:07:35,520 --> 00:07:39,280
this is more of a last-ditch effort

00:07:37,599 --> 00:07:40,960
given an issue in production most

00:07:39,280 --> 00:07:42,319
developers would rather jump straight to

00:07:40,960 --> 00:07:43,120
the source code and think about what

00:07:42,319 --> 00:07:44,800
should have happened

00:07:43,120 --> 00:07:46,560
and start guessing at what must have

00:07:44,800 --> 00:07:48,319
happened for the issue to occur

00:07:46,560 --> 00:07:50,000
even when you have monitoring data which

00:07:48,319 --> 00:07:52,160
makes it obvious what the issue is

00:07:50,000 --> 00:07:54,479
to developers source code is software

00:07:52,160 --> 00:07:56,240
software is source code

00:07:54,479 --> 00:07:57,840
everything stems from source code the

00:07:56,240 --> 00:07:58,720
source code should explain why the issue

00:07:57,840 --> 00:08:00,080
is occurring

00:07:58,720 --> 00:08:02,720
but that doesn't necessarily mean that

00:08:00,080 --> 00:08:04,319
the source code will make it obvious

00:08:02,720 --> 00:08:05,919
and this is problematic if developers

00:08:04,319 --> 00:08:07,199
only care about source code given that

00:08:05,919 --> 00:08:08,240
source code is only showing you a

00:08:07,199 --> 00:08:10,479
portion of reality

00:08:08,240 --> 00:08:12,160
it is a description of software and when

00:08:10,479 --> 00:08:13,840
developers refuse to integrate

00:08:12,160 --> 00:08:15,520
operational data into their development

00:08:13,840 --> 00:08:16,160
activities they are essentially arguing

00:08:15,520 --> 00:08:18,319
that the map

00:08:16,160 --> 00:08:20,400
is the territory that the menu is the

00:08:18,319 --> 00:08:22,240
meal the reality is that the map is not

00:08:20,400 --> 00:08:23,919
the territory and in the same way that a

00:08:22,240 --> 00:08:24,319
menu only represents what a meal should

00:08:23,919 --> 00:08:25,680
be

00:08:24,319 --> 00:08:28,240
source code only represents what

00:08:25,680 --> 00:08:29,919
software should do

00:08:28,240 --> 00:08:31,759
instead to know what software actually

00:08:29,919 --> 00:08:33,360
does you need to include operational

00:08:31,759 --> 00:08:35,279
data into your thinking

00:08:33,360 --> 00:08:37,039
only then will you get the entire scope

00:08:35,279 --> 00:08:38,640
of software

00:08:37,039 --> 00:08:40,880
remember source code only explains what

00:08:38,640 --> 00:08:41,680
software can do it is operational data

00:08:40,880 --> 00:08:43,599
that explains what

00:08:41,680 --> 00:08:45,600
software actually did as software

00:08:43,599 --> 00:08:47,760
developers we should care just as much

00:08:45,600 --> 00:08:49,440
if not more about how software actually

00:08:47,760 --> 00:08:50,320
operates as we do about how it was

00:08:49,440 --> 00:08:51,839
designed to

00:08:50,320 --> 00:08:53,440
if we are not viewing source code and

00:08:51,839 --> 00:08:54,000
operational data in tandem then

00:08:53,440 --> 00:08:56,640
figuratively

00:08:54,000 --> 00:08:58,240
when we're programming we might as well

00:08:56,640 --> 00:09:00,160
be programming while squinting

00:08:58,240 --> 00:09:01,519
we can make out how software should work

00:09:00,160 --> 00:09:02,959
but not how it will work

00:09:01,519 --> 00:09:04,560
looking at a method we have an idea if

00:09:02,959 --> 00:09:04,959
it should take a short or long time to

00:09:04,560 --> 00:09:06,720
run

00:09:04,959 --> 00:09:08,000
but really we're just guessing and when

00:09:06,720 --> 00:09:09,360
we're investigating production

00:09:08,000 --> 00:09:10,800
issues we followed the source code

00:09:09,360 --> 00:09:12,080
thinking it should have done this and

00:09:10,800 --> 00:09:13,680
then it should have won here and we're

00:09:12,080 --> 00:09:14,959
not thinking here's exactly what it did

00:09:13,680 --> 00:09:15,760
in that instance and here is why it

00:09:14,959 --> 00:09:16,880
broke

00:09:15,760 --> 00:09:18,560
and the fact that we don't think in

00:09:16,880 --> 00:09:20,480
those terms of absolutes just goes to

00:09:18,560 --> 00:09:22,720
show that source code by itself cannot

00:09:20,480 --> 00:09:23,920
tell the whole story

00:09:22,720 --> 00:09:25,760
given that developers are creating

00:09:23,920 --> 00:09:26,720
software with a limited view the menu as

00:09:25,760 --> 00:09:28,240
opposed to the mill

00:09:26,720 --> 00:09:29,839
i believe the solution is then to

00:09:28,240 --> 00:09:30,399
somehow create a more holistic view of

00:09:29,839 --> 00:09:31,920
software

00:09:30,399 --> 00:09:34,959
by combining source code with the

00:09:31,920 --> 00:09:36,800
operational data it produces

00:09:34,959 --> 00:09:38,480
this is the exact idea about a process

00:09:36,800 --> 00:09:40,959
called feedback driven development

00:09:38,480 --> 00:09:42,560
effectively continuous feedback feedback

00:09:40,959 --> 00:09:44,240
driven development works by integrating

00:09:42,560 --> 00:09:45,519
runtime monitoring data from production

00:09:44,240 --> 00:09:47,440
deployments of the software

00:09:45,519 --> 00:09:49,040
into the tools that developers utilize

00:09:47,440 --> 00:09:52,160
in their daily workflows to enable

00:09:49,040 --> 00:09:53,680
tighter feedback loops

00:09:52,160 --> 00:09:55,600
conceptually this process looks

00:09:53,680 --> 00:09:57,040
something like this we start with a

00:09:55,600 --> 00:09:57,839
developer who creates some source code

00:09:57,040 --> 00:09:59,200
in their ide

00:09:57,839 --> 00:10:01,519
they do their testing and once it's

00:09:59,200 --> 00:10:03,120
ready for production

00:10:01,519 --> 00:10:05,839
they trigger an application deployment

00:10:03,120 --> 00:10:07,279
via committing code merging branches etc

00:10:05,839 --> 00:10:09,040
once their code is finally used in

00:10:07,279 --> 00:10:10,079
production it'll ultimately produce some

00:10:09,040 --> 00:10:12,160
operational data

00:10:10,079 --> 00:10:14,240
data like service load response times

00:10:12,160 --> 00:10:15,760
traces logs and various other metrics

00:10:14,240 --> 00:10:18,079
in feedback driven development as this

00:10:15,760 --> 00:10:19,360
operational data is produced it

00:10:18,079 --> 00:10:21,200
eventually makes its way back to

00:10:19,360 --> 00:10:22,800
developers ide where they can use that

00:10:21,200 --> 00:10:24,240
data to see how their source code is

00:10:22,800 --> 00:10:26,079
operating and help them make future

00:10:24,240 --> 00:10:26,880
decisions on how best to operate their

00:10:26,079 --> 00:10:28,160
software

00:10:26,880 --> 00:10:29,680
what you can immediately see from the

00:10:28,160 --> 00:10:31,040
feedback driven development approach is

00:10:29,680 --> 00:10:33,040
that there is a nice little loop between

00:10:31,040 --> 00:10:34,399
the ide and the application

00:10:33,040 --> 00:10:35,920
as you change the source code the

00:10:34,399 --> 00:10:37,200
operational data changes which you can

00:10:35,920 --> 00:10:39,279
use to change the source code which

00:10:37,200 --> 00:10:40,720
changes the operational data and so on

00:10:39,279 --> 00:10:42,240
and thus why they call it feedback

00:10:40,720 --> 00:10:43,839
driven development you are using

00:10:42,240 --> 00:10:45,279
feedback gathered from your application

00:10:43,839 --> 00:10:46,320
during the development of that very

00:10:45,279 --> 00:10:48,079
application

00:10:46,320 --> 00:10:49,200
now this is a very simplistic conceptual

00:10:48,079 --> 00:10:50,480
understanding of feedback driven

00:10:49,200 --> 00:10:52,160
development since feedback driven

00:10:50,480 --> 00:10:53,600
development does not actually involve

00:10:52,160 --> 00:10:55,760
sending raw operations back to

00:10:53,600 --> 00:10:57,600
developers ide if it did you would end

00:10:55,760 --> 00:10:59,600
up with essentially turning the ide into

00:10:57,600 --> 00:11:00,959
yet another operational dashboard which

00:10:59,600 --> 00:11:02,640
wouldn't change developers seeing

00:11:00,959 --> 00:11:04,399
operations as an operation

00:11:02,640 --> 00:11:05,519
thing instead feedback driven

00:11:04,399 --> 00:11:07,440
development isn't about giving

00:11:05,519 --> 00:11:08,640
developers raw operations data but

00:11:07,440 --> 00:11:10,079
rather

00:11:08,640 --> 00:11:11,920
feedback driven development is about

00:11:10,079 --> 00:11:13,279
making operations that are actionable

00:11:11,920 --> 00:11:14,480
for software developers

00:11:13,279 --> 00:11:15,920
and this is achieved by giving

00:11:14,480 --> 00:11:16,399
developers feedback in the form of

00:11:15,920 --> 00:11:19,360
advice

00:11:16,399 --> 00:11:20,959
not just raw data so instead of simply

00:11:19,360 --> 00:11:22,880
streaming operation data back to

00:11:20,959 --> 00:11:24,480
developers there are two processes which

00:11:22,880 --> 00:11:26,320
operation data goes through before

00:11:24,480 --> 00:11:28,079
getting back to developers

00:11:26,320 --> 00:11:30,000
and these processes are called feedback

00:11:28,079 --> 00:11:31,839
mapping and feedback control

00:11:30,000 --> 00:11:33,200
feedback control acts like a database

00:11:31,839 --> 00:11:34,959
for operations data

00:11:33,200 --> 00:11:36,880
its job is to collect filter and

00:11:34,959 --> 00:11:38,240
aggregate operations data

00:11:36,880 --> 00:11:39,920
feedback mapping acts like an

00:11:38,240 --> 00:11:41,760
intermediator between the source code

00:11:39,920 --> 00:11:43,839
and the aggregated operations atom

00:11:41,760 --> 00:11:45,360
its job is to take specific source code

00:11:43,839 --> 00:11:47,120
find the aggregated operations that are

00:11:45,360 --> 00:11:48,399
that it produced link them together and

00:11:47,120 --> 00:11:50,240
surface any advice which can be

00:11:48,399 --> 00:11:51,360
extracted the analysis of that combined

00:11:50,240 --> 00:11:53,120
structure

00:11:51,360 --> 00:11:54,959
adding both of these processes together

00:11:53,120 --> 00:11:56,079
instead of sending raw operations data

00:11:54,959 --> 00:11:58,959
back to the ide

00:11:56,079 --> 00:12:00,800
instead what we send is feedback this is

00:11:58,959 --> 00:12:02,720
feedback which developers can use to

00:12:00,800 --> 00:12:03,519
continuously evaluate and correct their

00:12:02,720 --> 00:12:05,360
software

00:12:03,519 --> 00:12:06,959
continuous feedback which is actionable

00:12:05,360 --> 00:12:08,480
for software developers

00:12:06,959 --> 00:12:09,839
now we'll get into exactly what feedback

00:12:08,480 --> 00:12:11,440
looks like soon but first i think it's

00:12:09,839 --> 00:12:14,000
important to understand how feedback

00:12:11,440 --> 00:12:15,680
mapping and feedback control works

00:12:14,000 --> 00:12:17,040
again feedback control is the process of

00:12:15,680 --> 00:12:18,959
collecting filtering and

00:12:17,040 --> 00:12:20,399
aggregating operations data and before

00:12:18,959 --> 00:12:22,399
you can collect operations data you

00:12:20,399 --> 00:12:24,160
first have to produce it

00:12:22,399 --> 00:12:25,839
which is typically done via the users of

00:12:24,160 --> 00:12:27,040
your application as they make use of

00:12:25,839 --> 00:12:28,720
your application your application

00:12:27,040 --> 00:12:30,880
produces various streams of operational

00:12:28,720 --> 00:12:32,560
data which can be monitored

00:12:30,880 --> 00:12:34,959
here we can see some streams of traces

00:12:32,560 --> 00:12:35,600
logs and metrics this operations data is

00:12:34,959 --> 00:12:37,600
collected

00:12:35,600 --> 00:12:38,959
and saved creating an aggregated data

00:12:37,600 --> 00:12:40,560
source

00:12:38,959 --> 00:12:42,240
and then finally this aggregated

00:12:40,560 --> 00:12:43,600
operations data is made available for

00:12:42,240 --> 00:12:45,120
querying and this is typically where

00:12:43,600 --> 00:12:47,200
it's turned into a bunch of charts and

00:12:45,120 --> 00:12:48,320
dashboards for the operations team

00:12:47,200 --> 00:12:50,399
and that's the end of the feedback

00:12:48,320 --> 00:12:52,000
control process the feedback control

00:12:50,399 --> 00:12:54,399
process has successfully collected

00:12:52,000 --> 00:12:56,079
filtered and aggregated operations data

00:12:54,399 --> 00:12:57,839
this is where its job stops and where

00:12:56,079 --> 00:12:59,839
the feedback mapping takes over

00:12:57,839 --> 00:13:01,519
feedback mapping happens simultaneously

00:12:59,839 --> 00:13:03,440
to feedback control but it occurs mainly

00:13:01,519 --> 00:13:04,959
in the developer's ide as they browse

00:13:03,440 --> 00:13:06,639
source code

00:13:04,959 --> 00:13:08,079
as a developer views source code it is

00:13:06,639 --> 00:13:09,440
turned into a dependency graph

00:13:08,079 --> 00:13:10,800
not the dependency graph for the entire

00:13:09,440 --> 00:13:12,320
code base but more or less just the

00:13:10,800 --> 00:13:12,720
source code developers currently looking

00:13:12,320 --> 00:13:14,160
at

00:13:12,720 --> 00:13:15,839
so it's more like a dependency graph

00:13:14,160 --> 00:13:17,440
fragment

00:13:15,839 --> 00:13:19,200
this dependency graph fragment is then

00:13:17,440 --> 00:13:21,440
used as the basis for querying the

00:13:19,200 --> 00:13:23,040
available aggregated operations data

00:13:21,440 --> 00:13:24,560
the reason only a fragment is used for

00:13:23,040 --> 00:13:25,920
querying is because software can contain

00:13:24,560 --> 00:13:27,760
a large amount of source code and

00:13:25,920 --> 00:13:28,160
operations data and at any one point in

00:13:27,760 --> 00:13:29,519
time

00:13:28,160 --> 00:13:30,880
a developer is only interested in a

00:13:29,519 --> 00:13:32,480
portion of it and this portion is

00:13:30,880 --> 00:13:34,880
primarily determined by whatever source

00:13:32,480 --> 00:13:36,800
code the developer is currently viewing

00:13:34,880 --> 00:13:38,000
the aggregated operation setup which was

00:13:36,800 --> 00:13:39,199
produced by the source code the

00:13:38,000 --> 00:13:40,399
developer is currently viewing

00:13:39,199 --> 00:13:41,839
is returned and combined with the

00:13:40,399 --> 00:13:43,199
dependency graph creating a more

00:13:41,839 --> 00:13:45,440
comprehensive structure called a

00:13:43,199 --> 00:13:46,959
feedback annotated dependency graph

00:13:45,440 --> 00:13:48,639
this is a structure created from static

00:13:46,959 --> 00:13:50,399
analysis of source code combines the

00:13:48,639 --> 00:13:52,720
dynamic analysis of that software

00:13:50,399 --> 00:13:54,320
undergoing actual production usage

00:13:52,720 --> 00:13:56,000
this is the distinguishing feature of

00:13:54,320 --> 00:13:57,680
feedback driven development the data

00:13:56,000 --> 00:13:59,760
you're integrating with source code is

00:13:57,680 --> 00:14:01,360
what actually happens in production and

00:13:59,760 --> 00:14:02,000
not what happens when you run it locally

00:14:01,360 --> 00:14:04,320
or in a test

00:14:02,000 --> 00:14:06,079
environment and then finally this

00:14:04,320 --> 00:14:07,600
feedback annotated dependency graph is

00:14:06,079 --> 00:14:09,440
analyzed to provide near real-time

00:14:07,600 --> 00:14:11,040
information and cautionary advice based

00:14:09,440 --> 00:14:12,560
on the current state of production

00:14:11,040 --> 00:14:14,000
if production is experiencing issues

00:14:12,560 --> 00:14:15,360
with user signups and you're viewing

00:14:14,000 --> 00:14:17,040
user signup code then you're going to

00:14:15,360 --> 00:14:17,920
see that happening in real time inside

00:14:17,040 --> 00:14:20,560
the source code

00:14:17,920 --> 00:14:22,320
no websites or dashboards necessary the

00:14:20,560 --> 00:14:24,000
source code no longer only represents

00:14:22,320 --> 00:14:26,000
static logic but also represents the

00:14:24,000 --> 00:14:27,839
dynamic state of the source code as it

00:14:26,000 --> 00:14:29,279
stands in production

00:14:27,839 --> 00:14:30,399
a very cool side effect of feedback

00:14:29,279 --> 00:14:32,160
driven development is that you can

00:14:30,399 --> 00:14:33,760
actually navigate operations data by

00:14:32,160 --> 00:14:36,240
simply navigating source code

00:14:33,760 --> 00:14:37,519
i'll show an example of this later okay

00:14:36,240 --> 00:14:38,800
so given that the feedback driven

00:14:37,519 --> 00:14:40,720
development approach involves two

00:14:38,800 --> 00:14:42,320
processes feedback mapping and feedback

00:14:40,720 --> 00:14:43,680
control the most intuitive approach for

00:14:42,320 --> 00:14:45,199
implementing feedback driven development

00:14:43,680 --> 00:14:45,839
would be to combine these two separate

00:14:45,199 --> 00:14:47,360
systems

00:14:45,839 --> 00:14:48,800
a system for implementing feedback

00:14:47,360 --> 00:14:50,480
mapping and a system for implementing

00:14:48,800 --> 00:14:52,000
feedback control

00:14:50,480 --> 00:14:53,440
this is what i've done and i've chosen

00:14:52,000 --> 00:14:54,959
to implement feedback mapping with a

00:14:53,440 --> 00:14:55,600
project i'm working on called source

00:14:54,959 --> 00:14:57,120
marker

00:14:55,600 --> 00:14:58,480
this project has not been released yet

00:14:57,120 --> 00:14:59,440
but i've included a link to the github

00:14:58,480 --> 00:15:00,800
repository at the end of the

00:14:59,440 --> 00:15:01,760
presentation where you can follow its

00:15:00,800 --> 00:15:03,519
progress express

00:15:01,760 --> 00:15:05,839
interest offer suggestions and things

00:15:03,519 --> 00:15:07,120
like that for feedback control i've

00:15:05,839 --> 00:15:08,399
chosen to implement that with an

00:15:07,120 --> 00:15:09,199
existing project called apache

00:15:08,399 --> 00:15:10,639
skywalking

00:15:09,199 --> 00:15:12,320
this is a project i'm sure a lot of you

00:15:10,639 --> 00:15:13,279
are aware of but if not it is a very

00:15:12,320 --> 00:15:14,639
popular open source

00:15:13,279 --> 00:15:16,320
application performance management

00:15:14,639 --> 00:15:18,079
system with a lot of useful features

00:15:16,320 --> 00:15:19,519
that make feedback control really easy

00:15:18,079 --> 00:15:21,519
to implement

00:15:19,519 --> 00:15:23,279
okay so how can we use apache skywalker

00:15:21,519 --> 00:15:24,880
to implement feedback control

00:15:23,279 --> 00:15:26,399
remember feedback control involves

00:15:24,880 --> 00:15:29,199
producing filtering collecting

00:15:26,399 --> 00:15:31,040
and aggregating operations data this

00:15:29,199 --> 00:15:32,480
means that feedback control's job is to

00:15:31,040 --> 00:15:32,800
start with the cloud application at one

00:15:32,480 --> 00:15:34,480
end

00:15:32,800 --> 00:15:36,800
and end with filtered and aggregated

00:15:34,480 --> 00:15:38,480
operations data at the other end

00:15:36,800 --> 00:15:40,160
producing operation data starts with our

00:15:38,480 --> 00:15:41,759
cloud application and this is created

00:15:40,160 --> 00:15:42,399
naturally as our users make use of our

00:15:41,759 --> 00:15:44,000
application

00:15:42,399 --> 00:15:45,519
so that takes care of producing data but

00:15:44,000 --> 00:15:47,279
simply producing data is a very little

00:15:45,519 --> 00:15:48,160
value if we are not actually monitoring

00:15:47,279 --> 00:15:49,920
it

00:15:48,160 --> 00:15:51,519
this is where apache skywalking agents

00:15:49,920 --> 00:15:52,959
come in these programs are able to hook

00:15:51,519 --> 00:15:54,399
into applications and monitor the

00:15:52,959 --> 00:15:55,440
operations data that the application

00:15:54,399 --> 00:15:57,120
produces

00:15:55,440 --> 00:15:58,720
this allows us to monitor operations

00:15:57,120 --> 00:16:00,480
data but everybody's application is

00:15:58,720 --> 00:16:01,120
different so the agent by itself isn't

00:16:00,480 --> 00:16:02,560
enough

00:16:01,120 --> 00:16:04,079
it needs to be told specifically what

00:16:02,560 --> 00:16:05,839
we're interested in monitoring inside of

00:16:04,079 --> 00:16:07,440
our application

00:16:05,839 --> 00:16:09,120
here we can make use of a plug-in the

00:16:07,440 --> 00:16:10,480
agent comes with called the customize

00:16:09,120 --> 00:16:11,839
enhanced plugin

00:16:10,480 --> 00:16:13,279
this plugin allows us to create

00:16:11,839 --> 00:16:15,120
something called a trace enhanced

00:16:13,279 --> 00:16:16,959
specification which describes exactly

00:16:15,120 --> 00:16:18,399
what the agent should monitor

00:16:16,959 --> 00:16:20,800
in this specification we have the

00:16:18,399 --> 00:16:23,040
ability to specify exactly which classes

00:16:20,800 --> 00:16:25,199
methods data logs etc inside of our

00:16:23,040 --> 00:16:27,120
application should be monitored

00:16:25,199 --> 00:16:28,320
using our application source code we can

00:16:27,120 --> 00:16:30,079
generate the trace enhanced

00:16:28,320 --> 00:16:31,120
specification and combine that with our

00:16:30,079 --> 00:16:32,720
agents

00:16:31,120 --> 00:16:34,639
together these components enable us to

00:16:32,720 --> 00:16:37,120
both filter and transmit the operations

00:16:34,639 --> 00:16:39,040
data which our application produces

00:16:37,120 --> 00:16:40,880
the trace enhanced specification handles

00:16:39,040 --> 00:16:42,000
filtering since it specifies what should

00:16:40,880 --> 00:16:43,360
and should not be monitored

00:16:42,000 --> 00:16:45,519
and the agents handle the actual

00:16:43,360 --> 00:16:46,959
transmission of the operations data

00:16:45,519 --> 00:16:49,519
now all we need to do is collect and

00:16:46,959 --> 00:16:51,120
aggregate that operations data

00:16:49,519 --> 00:16:53,920
here is where the apache skywalking

00:16:51,120 --> 00:16:55,600
observability analysis platform comes in

00:16:53,920 --> 00:16:57,279
using this platform we have a place for

00:16:55,600 --> 00:16:58,240
collecting the operations data the agent

00:16:57,279 --> 00:17:00,320
transmits

00:16:58,240 --> 00:17:01,759
it allows us to aggregate save and query

00:17:00,320 --> 00:17:03,279
for operation data but again

00:17:01,759 --> 00:17:04,799
applications can be very different so

00:17:03,279 --> 00:17:05,760
the operations that they produce can be

00:17:04,799 --> 00:17:07,520
very different

00:17:05,760 --> 00:17:08,720
this means that not all applications are

00:17:07,520 --> 00:17:11,199
going to want the same rules for how

00:17:08,720 --> 00:17:13,199
they aggregate their operations data

00:17:11,199 --> 00:17:14,400
apache scam conveniently has an answer

00:17:13,199 --> 00:17:16,240
for that as well with something they

00:17:14,400 --> 00:17:16,720
call an observation analysis language

00:17:16,240 --> 00:17:18,480
script

00:17:16,720 --> 00:17:19,919
these scripts allow us to define custom

00:17:18,480 --> 00:17:22,799
rules for how operations that

00:17:19,919 --> 00:17:24,559
should be aggregated and saved again

00:17:22,799 --> 00:17:26,160
using our application source code we can

00:17:24,559 --> 00:17:27,679
generate the observation analysis

00:17:26,160 --> 00:17:29,919
language script and combine that with

00:17:27,679 --> 00:17:31,360
the observability analysis platform

00:17:29,919 --> 00:17:33,120
together these components enable us to

00:17:31,360 --> 00:17:34,559
both collect and aggregate the

00:17:33,120 --> 00:17:35,919
operations data which the agent

00:17:34,559 --> 00:17:37,760
transmits

00:17:35,919 --> 00:17:39,280
the observation analysis language script

00:17:37,760 --> 00:17:40,960
handles how the operations data should

00:17:39,280 --> 00:17:42,480
be aggregated and the observability

00:17:40,960 --> 00:17:45,520
analysis platform handles the collecting

00:17:42,480 --> 00:17:46,960
and saving of aggregated operations data

00:17:45,520 --> 00:17:48,559
combining these three steps together

00:17:46,960 --> 00:17:50,559
what you're left with is the filtered

00:17:48,559 --> 00:17:52,320
and aggregated operations data necessary

00:17:50,559 --> 00:17:53,679
to fill all the requirements of feedback

00:17:52,320 --> 00:17:56,240
control

00:17:53,679 --> 00:17:58,000
okay now on to how called source marker

00:17:56,240 --> 00:17:59,520
is used to implement feedback mapping

00:17:58,000 --> 00:18:01,120
remember feedback mapping involves

00:17:59,520 --> 00:18:01,679
correlating source code with operations

00:18:01,120 --> 00:18:03,200
data

00:18:01,679 --> 00:18:04,960
analyzing that structure to provide

00:18:03,200 --> 00:18:06,640
actionable advice and bringing that

00:18:04,960 --> 00:18:09,200
advice to developers attention inside

00:18:06,640 --> 00:18:10,720
their ide

00:18:09,200 --> 00:18:12,000
rather than having something at one end

00:18:10,720 --> 00:18:13,200
and something at the other end instead

00:18:12,000 --> 00:18:15,760
we have here is a loop

00:18:13,200 --> 00:18:17,440
a continuous feedback loop this loop

00:18:15,760 --> 00:18:18,880
starts with the ide which contains

00:18:17,440 --> 00:18:20,640
source code this source code is

00:18:18,880 --> 00:18:22,400
transformed into a dependency graph

00:18:20,640 --> 00:18:24,559
populated with operations data creating

00:18:22,400 --> 00:18:26,320
a feedback annotated dependency graph

00:18:24,559 --> 00:18:28,480
and then analyze to produce advice which

00:18:26,320 --> 00:18:30,320
is placed back inside the ide

00:18:28,480 --> 00:18:32,320
as the source code and or operations

00:18:30,320 --> 00:18:34,240
data changes so does the advice

00:18:32,320 --> 00:18:36,320
giving continuous feedback to developers

00:18:34,240 --> 00:18:37,840
as they develop their application

00:18:36,320 --> 00:18:39,600
so then the question becomes what kind

00:18:37,840 --> 00:18:40,960
of advice can we provide to software

00:18:39,600 --> 00:18:42,480
developers

00:18:40,960 --> 00:18:44,880
well there's primarily two classes of

00:18:42,480 --> 00:18:47,440
advice we can offer informative advice

00:18:44,880 --> 00:18:49,200
and cautionary advice for informative

00:18:47,440 --> 00:18:50,640
advice we can of course provide metrics

00:18:49,200 --> 00:18:52,400
about how long source code takes to

00:18:50,640 --> 00:18:53,840
operate and how often it operates

00:18:52,400 --> 00:18:55,919
we can show a type of data the source

00:18:53,840 --> 00:18:57,520
code consumed and consequently produced

00:18:55,919 --> 00:18:59,200
and we can show several other various

00:18:57,520 --> 00:19:01,520
advisories which simply state how the

00:18:59,200 --> 00:19:03,280
source code operated in production

00:19:01,520 --> 00:19:05,200
for cautionary advice we can warn

00:19:03,280 --> 00:19:07,039
developers when their source code is cpu

00:19:05,200 --> 00:19:08,840
or memory intensive and can even detect

00:19:07,039 --> 00:19:10,160
when they create performance

00:19:08,840 --> 00:19:11,919
anti-patterns

00:19:10,160 --> 00:19:13,520
for an example here's how we can use

00:19:11,919 --> 00:19:14,799
feedback driven development to detect

00:19:13,520 --> 00:19:17,200
when a developer has created what's

00:19:14,799 --> 00:19:18,480
known as a performance ramp anti-pattern

00:19:17,200 --> 00:19:19,760
this is an anti-pattern where you've

00:19:18,480 --> 00:19:21,360
created some source code which will

00:19:19,760 --> 00:19:23,840
continually take longer and longer to

00:19:21,360 --> 00:19:25,200
execute over

00:19:23,840 --> 00:19:26,559
you can often tell when you've created a

00:19:25,200 --> 00:19:28,799
performance ramp when your service

00:19:26,559 --> 00:19:30,480
response time trend looks like this

00:19:28,799 --> 00:19:32,080
as time progresses so does the amount of

00:19:30,480 --> 00:19:32,960
duration required for the service to

00:19:32,080 --> 00:19:34,559
execute

00:19:32,960 --> 00:19:36,080
this does not definitely mean you've

00:19:34,559 --> 00:19:37,679
created a performance ramp however

00:19:36,080 --> 00:19:39,039
as there can be many different reasons

00:19:37,679 --> 00:19:40,720
why a service is taking longer to

00:19:39,039 --> 00:19:42,000
execute

00:19:40,720 --> 00:19:43,600
you can also often tell where

00:19:42,000 --> 00:19:45,039
performance ramp might appear if you

00:19:43,600 --> 00:19:47,200
search your source code for things like

00:19:45,039 --> 00:19:48,480
sql select statements with no pagination

00:19:47,200 --> 00:19:50,000
or limits on them

00:19:48,480 --> 00:19:51,440
this however also does not mean you've

00:19:50,000 --> 00:19:53,200
created a performance ramp since you may

00:19:51,440 --> 00:19:56,320
be querying a table with only a few rows

00:19:53,200 --> 00:19:58,240
in it or a table which never changes

00:19:56,320 --> 00:20:00,960
it is only once you take that operations

00:19:58,240 --> 00:20:02,240
data which suggests a performance ram

00:20:00,960 --> 00:20:03,840
and combine it with the fact that you

00:20:02,240 --> 00:20:05,440
have source code which is known to cause

00:20:03,840 --> 00:20:07,600
performance ramps they can actually

00:20:05,440 --> 00:20:09,120
determine if a performance ramp exists

00:20:07,600 --> 00:20:10,720
here we can see we're doing a select

00:20:09,120 --> 00:20:12,400
everything from our users table and it's

00:20:10,720 --> 00:20:12,880
taking longer to run each time we call

00:20:12,400 --> 00:20:14,480
it

00:20:12,880 --> 00:20:16,400
using the operations data and source

00:20:14,480 --> 00:20:18,240
code in tandem we can safely conclude

00:20:16,400 --> 00:20:18,960
that a performance ramp does indeed

00:20:18,240 --> 00:20:20,720
exist

00:20:18,960 --> 00:20:22,400
and what this advice does is it gives

00:20:20,720 --> 00:20:23,919
developers the ability to integrate

00:20:22,400 --> 00:20:24,720
operations data into development

00:20:23,919 --> 00:20:26,240
activities

00:20:24,720 --> 00:20:28,000
no longer will they feel that monitoring

00:20:26,240 --> 00:20:29,440
is an operations thing because they can

00:20:28,000 --> 00:20:31,520
see how operations data

00:20:29,440 --> 00:20:32,960
and the source code fit together in this

00:20:31,520 --> 00:20:34,000
case now they can start thinking about

00:20:32,960 --> 00:20:37,440
adding pagination to

00:20:34,000 --> 00:20:39,039
their query hopefully all that helped

00:20:37,440 --> 00:20:40,480
explain feedback mapping and feedback

00:20:39,039 --> 00:20:41,919
control because now i would like to show

00:20:40,480 --> 00:20:43,280
a demonstration of how it would look to

00:20:41,919 --> 00:20:44,720
developer programming with feedback

00:20:43,280 --> 00:20:46,159
driven development technology

00:20:44,720 --> 00:20:47,120
this is just my implementation and

00:20:46,159 --> 00:20:48,400
doesn't encapsulate all the

00:20:47,120 --> 00:20:49,840
possibilities of feedback dream

00:20:48,400 --> 00:20:51,120
technology though it should spark some

00:20:49,840 --> 00:20:52,559
ideas in your head of how you can

00:20:51,120 --> 00:20:54,240
program with a more holistic view of

00:20:52,559 --> 00:20:56,960
software by combining source code and

00:20:54,240 --> 00:20:58,320
operational data

00:20:56,960 --> 00:21:00,240
let's start with the traditional view of

00:20:58,320 --> 00:21:01,520
some simple java source code can you

00:21:00,240 --> 00:21:02,960
tell if there any production issues

00:21:01,520 --> 00:21:04,400
happening here

00:21:02,960 --> 00:21:05,600
one of the methods there's an exception

00:21:04,400 --> 00:21:07,520
each time it's called but can you tell

00:21:05,600 --> 00:21:08,880
if anyone's ever called it

00:21:07,520 --> 00:21:10,159
these are questions you cannot answer if

00:21:08,880 --> 00:21:12,320
you're just reading source code by

00:21:10,159 --> 00:21:14,000
itself

00:21:12,320 --> 00:21:15,520
however adding some feedback driven

00:21:14,000 --> 00:21:16,960
development power icon to the source

00:21:15,520 --> 00:21:18,400
code the answers to those questions

00:21:16,960 --> 00:21:20,159
becomes obvious

00:21:18,400 --> 00:21:21,919
here we've added two icons to the source

00:21:20,159 --> 00:21:23,440
code one which indicates a performance

00:21:21,919 --> 00:21:24,960
ramp has been detected and one which

00:21:23,440 --> 00:21:26,240
keeps track of how often exception has

00:21:24,960 --> 00:21:27,200
been thrown since the application

00:21:26,240 --> 00:21:28,559
started

00:21:27,200 --> 00:21:30,000
okay so that answers our previous

00:21:28,559 --> 00:21:31,679
questions but now we might be wondering

00:21:30,000 --> 00:21:32,640
things like how often are these methods

00:21:31,679 --> 00:21:33,840
called

00:21:32,640 --> 00:21:35,919
how long does it take when they're

00:21:33,840 --> 00:21:38,400
called when was the last time the

00:21:35,919 --> 00:21:39,919
runtime exception was actually thrown

00:21:38,400 --> 00:21:42,880
again these are questions that cannot be

00:21:39,919 --> 00:21:44,720
answered by the source code itself

00:21:42,880 --> 00:21:46,080
however we can add some feedback driven

00:21:44,720 --> 00:21:47,679
development powered inlay hints to

00:21:46,080 --> 00:21:49,440
answer even those questions

00:21:47,679 --> 00:21:50,720
now we have some near real-time metrics

00:21:49,440 --> 00:21:51,919
which answer all of the previous

00:21:50,720 --> 00:21:53,520
questions we've asked

00:21:51,919 --> 00:21:55,360
we can see how often these methods are

00:21:53,520 --> 00:21:56,799
called how long they take to run

00:21:55,360 --> 00:21:58,720
and how many times they've been called

00:21:56,799 --> 00:22:00,400
since the application started

00:21:58,720 --> 00:22:02,159
even better this information is updated

00:22:00,400 --> 00:22:03,600
in real time so we can always keep track

00:22:02,159 --> 00:22:06,240
of the current state of the source code

00:22:03,600 --> 00:22:06,240
in production

00:22:07,360 --> 00:22:10,880
feedback driven development powered icon

00:22:09,200 --> 00:22:12,000
to inlay hints are very useful for

00:22:10,880 --> 00:22:13,440
getting developers attention

00:22:12,000 --> 00:22:15,120
but they're not expressive enough for

00:22:13,440 --> 00:22:15,600
more complex informative and cautionary

00:22:15,120 --> 00:22:17,120
advice

00:22:15,600 --> 00:22:18,240
they only offer summarized data and

00:22:17,120 --> 00:22:19,600
their main goal is to get the

00:22:18,240 --> 00:22:21,360
developer's attention so that they'll

00:22:19,600 --> 00:22:23,200
view what's known as the source portal

00:22:21,360 --> 00:22:24,799
this is a ui that changes based on the

00:22:23,200 --> 00:22:26,559
source code you're currently viewing

00:22:24,799 --> 00:22:28,080
for example this source code is a class

00:22:26,559 --> 00:22:29,760
called web app controller which is a

00:22:28,080 --> 00:22:31,760
spring rest controller that contains a

00:22:29,760 --> 00:22:33,360
couple git and post end points

00:22:31,760 --> 00:22:34,880
again reading this source code alone

00:22:33,360 --> 00:22:36,400
it's impossible to tell how it's

00:22:34,880 --> 00:22:38,080
performing in production besides the

00:22:36,400 --> 00:22:40,400
fact that kit users are suffering from a

00:22:38,080 --> 00:22:42,400
performance ramp

00:22:40,400 --> 00:22:44,320
but using a keyboard shortcut we can

00:22:42,400 --> 00:22:45,840
bring up the source portal and a pop-up

00:22:44,320 --> 00:22:46,640
above our code which shows in much

00:22:45,840 --> 00:22:48,159
greater detail

00:22:46,640 --> 00:22:49,919
how this entire rest controller is

00:22:48,159 --> 00:22:51,520
currently operating in production

00:22:49,919 --> 00:22:53,200
here we can see how all of the endpoints

00:22:51,520 --> 00:22:54,640
we've defined are operating

00:22:53,200 --> 00:22:56,559
we can see their average throughput

00:22:54,640 --> 00:22:57,919
response time and sla

00:22:56,559 --> 00:22:59,919
and given that this ui is hooked up

00:22:57,919 --> 00:23:01,360
directly to our ide we can navigate our

00:22:59,919 --> 00:23:02,720
source code by simply clicking what

00:23:01,360 --> 00:23:04,159
we're interested in

00:23:02,720 --> 00:23:05,600
since the get user's endpoint is

00:23:04,159 --> 00:23:07,280
currently suffering from a performance

00:23:05,600 --> 00:23:09,840
ramp let's take a closer look at that by

00:23:07,280 --> 00:23:09,840
clicking it

00:23:10,320 --> 00:23:13,760
notice how not only the ui changes to

00:23:12,080 --> 00:23:15,440
show us the gate user's endpoint in more

00:23:13,760 --> 00:23:17,520
detail but also how we've jumped in the

00:23:15,440 --> 00:23:19,200
source code to the git user's method

00:23:17,520 --> 00:23:20,799
this allows us to see the source code

00:23:19,200 --> 00:23:21,280
and the operational data at the same

00:23:20,799 --> 00:23:22,320
time

00:23:21,280 --> 00:23:24,320
we don't need to dig through any

00:23:22,320 --> 00:23:26,960
dashboards as the correct and specific

00:23:24,320 --> 00:23:28,720
operational data is already visible

00:23:26,960 --> 00:23:30,320
okay so given that this getuser's method

00:23:28,720 --> 00:23:32,159
has a performance ramp icon

00:23:30,320 --> 00:23:33,520
let's verify if that's true we're

00:23:32,159 --> 00:23:35,039
looking at the last five minutes and

00:23:33,520 --> 00:23:36,480
there seems to be an upward trend but it

00:23:35,039 --> 00:23:38,000
doesn't look that bad

00:23:36,480 --> 00:23:39,760
let's try looking at how it's performed

00:23:38,000 --> 00:23:42,080
for the last three hours we can click

00:23:39,760 --> 00:23:45,360
the time drop down

00:23:42,080 --> 00:23:45,360
select the last three hours

00:23:45,520 --> 00:23:48,559
and now it's a bit more obvious that the

00:23:47,039 --> 00:23:49,679
performance ramp advice we're getting

00:23:48,559 --> 00:23:51,279
seems to be valid

00:23:49,679 --> 00:23:52,559
we can see in the last three hours the

00:23:51,279 --> 00:23:54,240
average response time has gone from

00:23:52,559 --> 00:23:55,760
something like 20 milliseconds to almost

00:23:54,240 --> 00:23:57,520
900 milliseconds

00:23:55,760 --> 00:23:59,120
that appears to be very indicative to a

00:23:57,520 --> 00:24:00,720
performance ramp though we can dig even

00:23:59,120 --> 00:24:02,320
deeper into this problem by looking at

00:24:00,720 --> 00:24:03,200
some of the collected traces related to

00:24:02,320 --> 00:24:06,559
this endpoint

00:24:03,200 --> 00:24:06,559
so let's click the traces tab

00:24:07,200 --> 00:24:10,000
and here we can view the live request

00:24:08,799 --> 00:24:11,600
that this source code is currently

00:24:10,000 --> 00:24:13,120
processing we can even see the values

00:24:11,600 --> 00:24:14,720
being passed to this method

00:24:13,120 --> 00:24:16,400
in this case our endpoint only accepts a

00:24:14,720 --> 00:24:18,080
boolean so all we see is trues and

00:24:16,400 --> 00:24:19,440
falses being processed

00:24:18,080 --> 00:24:20,799
let's click on one of these traces and

00:24:19,440 --> 00:24:23,919
see if we can figure out why we have a

00:24:20,799 --> 00:24:23,919
performance ramp warning

00:24:25,279 --> 00:24:28,240
we can see that this endpoint is using

00:24:26,559 --> 00:24:29,520
the spring framework it's making some

00:24:28,240 --> 00:24:31,039
general computations

00:24:29,520 --> 00:24:33,200
and it's executing a sql select

00:24:31,039 --> 00:24:34,880
statement if we wanted to we can get a

00:24:33,200 --> 00:24:38,159
summary of this trace stack by clicking

00:24:34,880 --> 00:24:38,159
the trace stack drop down

00:24:39,039 --> 00:24:42,080
and we can see that this trace started

00:24:40,480 --> 00:24:44,159
and finished at 1103 pm

00:24:42,080 --> 00:24:47,840
and overall it was successful that's all

00:24:44,159 --> 00:24:47,840
good but if we go back to the tray stack

00:24:47,919 --> 00:24:51,279
we can see that the select statement

00:24:49,279 --> 00:24:52,799
does have a caution status we can go

00:24:51,279 --> 00:24:54,159
directly into that to get straight to

00:24:52,799 --> 00:24:55,919
the issue but i want to further show how

00:24:54,159 --> 00:24:57,440
we can navigate operational data and

00:24:55,919 --> 00:24:58,880
source code in tandem

00:24:57,440 --> 00:25:00,799
currently we are viewing the summarize

00:24:58,880 --> 00:25:03,679
trace stack let's click the detailed

00:25:00,799 --> 00:25:03,679
trace stack instead

00:25:04,240 --> 00:25:06,960
now we can see each method that was

00:25:05,440 --> 00:25:07,679
called during this trace one method at a

00:25:06,960 --> 00:25:09,360
time

00:25:07,679 --> 00:25:11,760
here i can see the issue is coming from

00:25:09,360 --> 00:25:14,000
the user service input git users call

00:25:11,760 --> 00:25:17,039
which we've passed the value of false to

00:25:14,000 --> 00:25:17,039
we can click that method

00:25:17,840 --> 00:25:21,919
and again notice how not only ui changes

00:25:20,080 --> 00:25:22,720
but our position in the source code also

00:25:21,919 --> 00:25:24,720
changes

00:25:22,720 --> 00:25:26,960
now we add the user service input class

00:25:24,720 --> 00:25:28,799
looking at the get users method

00:25:26,960 --> 00:25:30,400
here we can see that the caution status

00:25:28,799 --> 00:25:31,840
comes from the sql select statement

00:25:30,400 --> 00:25:34,000
which is being performed via our

00:25:31,840 --> 00:25:34,960
execution of the user storage find all

00:25:34,000 --> 00:25:36,159
call

00:25:34,960 --> 00:25:38,720
we can click that to get more

00:25:36,159 --> 00:25:38,720
information

00:25:39,200 --> 00:25:42,960
and we finally reach the root cause of

00:25:40,720 --> 00:25:44,640
the caution status here we can see yes

00:25:42,960 --> 00:25:46,080
the performance ramp was detected and

00:25:44,640 --> 00:25:47,760
the issue stems from the fact that we're

00:25:46,080 --> 00:25:48,880
making it select everything from user's

00:25:47,760 --> 00:25:50,320
query

00:25:48,880 --> 00:25:52,480
we can also see when it was first

00:25:50,320 --> 00:25:54,159
detected when it was last detected

00:25:52,480 --> 00:25:55,760
how long it used to take how long it

00:25:54,159 --> 00:25:57,120
currently takes and the percentage

00:25:55,760 --> 00:25:58,720
increase it's gone through since we've

00:25:57,120 --> 00:26:00,080
turned our application on

00:25:58,720 --> 00:26:01,440
this is actionable information a

00:26:00,080 --> 00:26:03,039
developer can use to start thinking

00:26:01,440 --> 00:26:03,600
about the appropriate way to solve this

00:26:03,039 --> 00:26:05,600
problem

00:26:03,600 --> 00:26:06,640
again the likely fix is pagination but

00:26:05,600 --> 00:26:08,000
that's up to you

00:26:06,640 --> 00:26:09,440
source marker aims to give you a more

00:26:08,000 --> 00:26:10,000
holistic view of your software and give

00:26:09,440 --> 00:26:11,760
you advice

00:26:10,000 --> 00:26:13,520
but it can't fix code for you as a

00:26:11,760 --> 00:26:15,919
developer it's your job to decide what

00:26:13,520 --> 00:26:17,440
fix works best for you

00:26:15,919 --> 00:26:18,960
okay so that was an example of how we

00:26:17,440 --> 00:26:20,000
can follow some cautionary advice to

00:26:18,960 --> 00:26:21,840
find its root cause

00:26:20,000 --> 00:26:24,000
we navigated our operational data and in

00:26:21,840 --> 00:26:25,440
doing so also navigated our source code

00:26:24,000 --> 00:26:27,200
cautionary advice is not all that's

00:26:25,440 --> 00:26:28,480
possible though informative advice can

00:26:27,200 --> 00:26:30,159
also be useful and something that

00:26:28,480 --> 00:26:31,919
developers often find themselves doing

00:26:30,159 --> 00:26:33,520
is looking through logs let's see a

00:26:31,919 --> 00:26:35,679
feedback driven development approach

00:26:33,520 --> 00:26:36,559
towards viewing logs again here's some

00:26:35,679 --> 00:26:37,840
source code

00:26:36,559 --> 00:26:39,840
can you tell me how many times we've

00:26:37,840 --> 00:26:41,520
logged any of the debug info or error

00:26:39,840 --> 00:26:42,720
calls

00:26:41,520 --> 00:26:44,000
it would be pretty important to know if

00:26:42,720 --> 00:26:45,600
we logged a lot of errors in production

00:26:44,000 --> 00:26:47,279
wouldn't it

00:26:45,600 --> 00:26:48,720
unfortunately source code by itself does

00:26:47,279 --> 00:26:49,840
not tell you what production is

00:26:48,720 --> 00:26:53,679
currently experiencing

00:26:49,840 --> 00:26:55,279
it can only tell you what's possible

00:26:53,679 --> 00:26:56,799
but adding some feedback driven

00:26:55,279 --> 00:26:57,200
development powered icons to the source

00:26:56,799 --> 00:26:58,559
code

00:26:57,200 --> 00:27:00,720
the answer to those questions becomes

00:26:58,559 --> 00:27:01,600
obvious here we can see the error logs

00:27:00,720 --> 00:27:03,679
were never called

00:27:01,600 --> 00:27:05,200
so that's good to know and again

00:27:03,679 --> 00:27:06,320
feedback driven development icons are

00:27:05,200 --> 00:27:08,159
useful for getting the developer's

00:27:06,320 --> 00:27:10,000
attention but don't tell us too much but

00:27:08,159 --> 00:27:11,600
basic information about how something is

00:27:10,000 --> 00:27:13,279
currently operating

00:27:11,600 --> 00:27:16,400
let's see the keyboard shortcut to bring

00:27:13,279 --> 00:27:18,399
up the source portal again

00:27:16,400 --> 00:27:20,320
and notice in doing so the source portal

00:27:18,399 --> 00:27:21,760
automatically brings up the logs view

00:27:20,320 --> 00:27:23,120
again the source portal changes what it

00:27:21,760 --> 00:27:24,159
looks like based on the source code

00:27:23,120 --> 00:27:25,120
you're currently viewing when you

00:27:24,159 --> 00:27:26,720
trigger it

00:27:25,120 --> 00:27:28,240
here we can see a summarized view of how

00:27:26,720 --> 00:27:29,679
many times each log pattern has been

00:27:28,240 --> 00:27:31,520
triggered in production

00:27:29,679 --> 00:27:33,279
this is useful information but just like

00:27:31,520 --> 00:27:34,720
when we're viewing summarized traces we

00:27:33,279 --> 00:27:37,760
can get more detail by clicking the

00:27:34,720 --> 00:27:37,760
detailed view icon

00:27:38,960 --> 00:27:42,320
and now we can watch the logs specific

00:27:40,720 --> 00:27:44,480
to this method in near real time as

00:27:42,320 --> 00:27:45,919
they're occurring in production

00:27:44,480 --> 00:27:47,279
that's pretty useful but let's say we

00:27:45,919 --> 00:27:49,200
aren't interested in all the logs inside

00:27:47,279 --> 00:27:50,000
this method but rather only one specific

00:27:49,200 --> 00:27:51,440
one

00:27:50,000 --> 00:27:53,919
we can click the one we're interested in

00:27:51,440 --> 00:27:53,919
like so

00:27:55,200 --> 00:27:58,480
and just like that we have a near real

00:27:56,640 --> 00:28:03,840
time feed of all the logs produced by

00:27:58,480 --> 00:28:03,840
the single statement in production

00:28:06,159 --> 00:28:09,279
i hope those demonstrations helped you

00:28:07,760 --> 00:28:10,399
see how source could only tell is part

00:28:09,279 --> 00:28:12,159
of the story and only when you're

00:28:10,399 --> 00:28:12,720
receiving continuous feedback about your

00:28:12,159 --> 00:28:14,399
software

00:28:12,720 --> 00:28:16,000
are able to program with a more holistic

00:28:14,399 --> 00:28:17,440
understanding of it and while you may

00:28:16,000 --> 00:28:18,960
think continuous feedback is simply

00:28:17,440 --> 00:28:20,399
something that would be nice to have i

00:28:18,960 --> 00:28:21,919
think it will gradually present itself

00:28:20,399 --> 00:28:23,360
as something necessary to have

00:28:21,919 --> 00:28:24,559
i think that becomes obvious when you

00:28:23,360 --> 00:28:27,039
look at the automation of software

00:28:24,559 --> 00:28:27,039
development

00:28:27,120 --> 00:28:30,720
we've automated going from developing to

00:28:28,880 --> 00:28:32,399
testing with continuous integration

00:28:30,720 --> 00:28:34,320
we've automated going from developing to

00:28:32,399 --> 00:28:35,919
releasing with continuous delivery

00:28:34,320 --> 00:28:37,919
we've automated going from developing to

00:28:35,919 --> 00:28:39,679
operating with continuous deployment

00:28:37,919 --> 00:28:41,039
all of these automations mark progress

00:28:39,679 --> 00:28:42,799
for the field of software development

00:28:41,039 --> 00:28:44,480
however

00:28:42,799 --> 00:28:45,919
we are living in a world powered by

00:28:44,480 --> 00:28:47,120
software which is consistently

00:28:45,919 --> 00:28:48,880
undergoing development

00:28:47,120 --> 00:28:50,880
software needs to evolve to remain

00:28:48,880 --> 00:28:52,559
relevant so continuously updating it is

00:28:50,880 --> 00:28:54,000
necessary but continuous delivery

00:28:52,559 --> 00:28:56,399
without continuous feedback

00:28:54,000 --> 00:28:58,399
is very very dangerous the more we rely

00:28:56,399 --> 00:29:00,240
on software the more we amplify the

00:28:58,399 --> 00:29:01,039
ability for software bugs to cause

00:29:00,240 --> 00:29:02,240
damage

00:29:01,039 --> 00:29:04,159
if we're going to be continuously

00:29:02,240 --> 00:29:06,000
delivering and deploying software we

00:29:04,159 --> 00:29:09,520
must also be continuously receiving and

00:29:06,000 --> 00:29:10,880
utilizing feedback about that software

00:29:09,520 --> 00:29:12,720
and this is what feedback driven

00:29:10,880 --> 00:29:13,760
development aka continuous feedback

00:29:12,720 --> 00:29:15,600
allows us to do

00:29:13,760 --> 00:29:17,279
and i believe in doing so enables us to

00:29:15,600 --> 00:29:18,960
finish removing the gap between software

00:29:17,279 --> 00:29:20,480
development and software operation

00:29:18,960 --> 00:29:23,200
and i believe removing that last little

00:29:20,480 --> 00:29:24,559
bit of gap will result in

00:29:23,200 --> 00:29:26,880
what's known as live software

00:29:24,559 --> 00:29:28,559
development or interactive programming

00:29:26,880 --> 00:29:30,080
live software development is the result

00:29:28,559 --> 00:29:31,520
of merging software development with

00:29:30,080 --> 00:29:33,120
software operation

00:29:31,520 --> 00:29:34,559
in this style of software development

00:29:33,120 --> 00:29:36,240
there is no gap between software

00:29:34,559 --> 00:29:37,760
development and software operation

00:29:36,240 --> 00:29:39,120
when you're programming you're literally

00:29:37,760 --> 00:29:40,480
modifying the currently operating

00:29:39,120 --> 00:29:42,240
software and when you modify the

00:29:40,480 --> 00:29:43,600
currently operating software there is no

00:29:42,240 --> 00:29:45,679
need for deploying updates

00:29:43,600 --> 00:29:47,039
you effectively deployed your changes by

00:29:45,679 --> 00:29:48,320
virtue of making them

00:29:47,039 --> 00:29:49,520
i believe this to be where software

00:29:48,320 --> 00:29:50,880
development is headed and i think

00:29:49,520 --> 00:29:52,640
feedback driven development is the

00:29:50,880 --> 00:29:54,080
precursor and i'd like to use my last

00:29:52,640 --> 00:29:56,240
remaining slides to envision that

00:29:54,080 --> 00:29:57,440
transition

00:29:56,240 --> 00:29:59,360
let's start with standard software

00:29:57,440 --> 00:30:00,080
development we have our development team

00:29:59,360 --> 00:30:01,520
that develop

00:30:00,080 --> 00:30:03,440
build and test their code with

00:30:01,520 --> 00:30:05,440
development requests which ideally mimic

00:30:03,440 --> 00:30:07,120
production requests as much as possible

00:30:05,440 --> 00:30:08,960
they then use the feedback they receive

00:30:07,120 --> 00:30:10,480
from testing and go back to developing

00:30:08,960 --> 00:30:12,000
where everything works as expected

00:30:10,480 --> 00:30:13,600
and their code is deployed and operated

00:30:12,000 --> 00:30:15,440
in production where it eventually starts

00:30:13,600 --> 00:30:17,200
experiencing production requests

00:30:15,440 --> 00:30:18,880
one thing to notice in this diagram is

00:30:17,200 --> 00:30:20,960
that the operations team is not needed

00:30:18,880 --> 00:30:22,480
to help developers test software

00:30:20,960 --> 00:30:24,000
they are able to do this all themselves

00:30:22,480 --> 00:30:25,279
because whenever they test they get

00:30:24,000 --> 00:30:26,960
immediate feedback

00:30:25,279 --> 00:30:28,399
however whenever the software receives

00:30:26,960 --> 00:30:29,440
production requests which cause it to

00:30:28,399 --> 00:30:31,120
act incorrectly

00:30:29,440 --> 00:30:32,559
it is the operations team that gives

00:30:31,120 --> 00:30:34,159
feedback to developers

00:30:32,559 --> 00:30:35,840
this delay in communication is one of

00:30:34,159 --> 00:30:37,200
the primary reasons why there's still a

00:30:35,840 --> 00:30:39,679
gap between software development and

00:30:37,200 --> 00:30:41,279
software operation

00:30:39,679 --> 00:30:43,200
feedback driven development comes in and

00:30:41,279 --> 00:30:44,480
says okay in the same way developers can

00:30:43,200 --> 00:30:45,679
see how their code operates during

00:30:44,480 --> 00:30:47,120
development is how we're going to let

00:30:45,679 --> 00:30:48,000
them see how their code operates during

00:30:47,120 --> 00:30:49,520
production

00:30:48,000 --> 00:30:51,039
and this essentially automates away a

00:30:49,520 --> 00:30:52,559
portion of the operations team

00:30:51,039 --> 00:30:53,760
i've added a robot to the operations

00:30:52,559 --> 00:30:55,760
team to signify some of their

00:30:53,760 --> 00:30:57,039
responsibilities have been automated

00:30:55,760 --> 00:30:58,720
now this is just what's known as

00:30:57,039 --> 00:31:00,320
analytic feedback driven development

00:30:58,720 --> 00:31:01,760
while i do not show in the demos

00:31:00,320 --> 00:31:04,000
there's another stage of feedback driven

00:31:01,760 --> 00:31:05,919
development which is called

00:31:04,000 --> 00:31:07,519
predictive feedback driven development

00:31:05,919 --> 00:31:08,080
predictive feedback driven development

00:31:07,519 --> 00:31:09,519
says hey

00:31:08,080 --> 00:31:10,720
i'm noticing that there are correlations

00:31:09,519 --> 00:31:12,159
between development requests and

00:31:10,720 --> 00:31:13,679
production requests which drive

00:31:12,159 --> 00:31:15,519
correlations between development

00:31:13,679 --> 00:31:17,279
feedback and production feedback

00:31:15,519 --> 00:31:19,120
it then uses those correlations to offer

00:31:17,279 --> 00:31:19,600
future predictions how the software will

00:31:19,120 --> 00:31:21,519
operate

00:31:19,600 --> 00:31:22,720
in production based on how the software

00:31:21,519 --> 00:31:24,559
operates locally

00:31:22,720 --> 00:31:26,240
for example let's say i write code which

00:31:24,559 --> 00:31:27,840
calls a method in a loop several times

00:31:26,240 --> 00:31:29,600
and locally that method executes very

00:31:27,840 --> 00:31:30,880
fast but in production that method takes

00:31:29,600 --> 00:31:32,240
a long time to execute

00:31:30,880 --> 00:31:34,240
what predictive feedback driven

00:31:32,240 --> 00:31:34,720
development does is while you're writing

00:31:34,240 --> 00:31:36,159
that loop

00:31:34,720 --> 00:31:38,000
it tells you that if you deploy this

00:31:36,159 --> 00:31:38,799
code it will take a long time to run in

00:31:38,000 --> 00:31:40,320
production

00:31:38,799 --> 00:31:42,159
this would then allow developers to

00:31:40,320 --> 00:31:43,039
foresee and avoid certain production

00:31:42,159 --> 00:31:44,880
issues

00:31:43,039 --> 00:31:46,080
in this case now i can consider using

00:31:44,880 --> 00:31:48,000
some sort of transaction

00:31:46,080 --> 00:31:49,120
or batching logic and avoid calling that

00:31:48,000 --> 00:31:51,039
method in a loop

00:31:49,120 --> 00:31:52,799
since it's typically the operations team

00:31:51,039 --> 00:31:54,399
which have the metrics and ability to

00:31:52,799 --> 00:31:56,080
predict how production will respond to

00:31:54,399 --> 00:31:57,279
changes in traffic and predictive

00:31:56,080 --> 00:31:59,039
feedback driven development gives

00:31:57,279 --> 00:32:00,480
disability to software developers

00:31:59,039 --> 00:32:02,159
have added yet another robot to their

00:32:00,480 --> 00:32:05,200
team to show how more responsibilities

00:32:02,159 --> 00:32:05,200
are being automated away

00:32:05,600 --> 00:32:08,880
finally all this continuous feedback

00:32:07,279 --> 00:32:10,559
will allow us to finish merging software

00:32:08,880 --> 00:32:12,000
development and software operation

00:32:10,559 --> 00:32:13,600
so that developing software is

00:32:12,000 --> 00:32:14,799
indistinguishable from operating

00:32:13,600 --> 00:32:16,240
software

00:32:14,799 --> 00:32:17,840
there won't be a development environment

00:32:16,240 --> 00:32:18,960
there won't be an operations team and

00:32:17,840 --> 00:32:21,039
testing and production will be

00:32:18,960 --> 00:32:22,480
considered safe and conventional

00:32:21,039 --> 00:32:23,840
this is the promise that live software

00:32:22,480 --> 00:32:24,880
development offers and i think it will

00:32:23,840 --> 00:32:26,559
primarily offer that through

00:32:24,880 --> 00:32:28,720
automatically wrapping feature flags to

00:32:26,559 --> 00:32:30,240
every change which developers introduce

00:32:28,720 --> 00:32:32,000
these feature flags will progressively

00:32:30,240 --> 00:32:33,760
become more comprehensive and will allow

00:32:32,000 --> 00:32:35,600
developers to make changes in production

00:32:33,760 --> 00:32:36,799
safely and efficiently if you're

00:32:35,600 --> 00:32:38,159
interested in how exactly that would

00:32:36,799 --> 00:32:39,440
work i'd recommend looking into the

00:32:38,159 --> 00:32:41,120
pluralist architecture

00:32:39,440 --> 00:32:43,039
specifically dark laying and large

00:32:41,120 --> 00:32:44,320
sparkling if you're still having trouble

00:32:43,039 --> 00:32:45,679
seeing how developing and production

00:32:44,320 --> 00:32:48,720
could ever become a reality

00:32:45,679 --> 00:32:50,480
let's look at this logically

00:32:48,720 --> 00:32:51,760
we established early on that the lines

00:32:50,480 --> 00:32:53,600
between software development and

00:32:51,760 --> 00:32:55,120
software operation are blurring

00:32:53,600 --> 00:32:57,279
this is primarily due to software

00:32:55,120 --> 00:32:59,600
automation a key component to the devops

00:32:57,279 --> 00:33:00,799
approach

00:32:59,600 --> 00:33:02,480
started with automating away the

00:33:00,799 --> 00:33:05,279
difficult process of building software

00:33:02,480 --> 00:33:06,799
with continuous integration

00:33:05,279 --> 00:33:08,159
and we automated away the difficult

00:33:06,799 --> 00:33:11,039
process of releasing software with

00:33:08,159 --> 00:33:12,240
continuous delivery

00:33:11,039 --> 00:33:13,919
followed by automating away the

00:33:12,240 --> 00:33:16,960
difficult process of deploying software

00:33:13,919 --> 00:33:18,240
with continuous deployment

00:33:16,960 --> 00:33:20,080
and we've even automated away the

00:33:18,240 --> 00:33:21,519
difficult process of monitoring software

00:33:20,080 --> 00:33:22,960
and making sure it's both running and

00:33:21,519 --> 00:33:25,039
running correctly with continuous

00:33:22,960 --> 00:33:26,559
monitoring

00:33:25,039 --> 00:33:28,559
all that remains is the fact that the

00:33:26,559 --> 00:33:29,440
operations team operates or controls

00:33:28,559 --> 00:33:30,960
production

00:33:29,440 --> 00:33:32,559
primarily because they are aware of the

00:33:30,960 --> 00:33:33,919
metrics which indicate the health of the

00:33:32,559 --> 00:33:35,679
software and are able to use those

00:33:33,919 --> 00:33:37,600
metrics to know and predict how the

00:33:35,679 --> 00:33:39,279
software is or will perform

00:33:37,600 --> 00:33:40,960
and these are precisely the abilities

00:33:39,279 --> 00:33:42,480
analytic and predictive feedback driven

00:33:40,960 --> 00:33:44,960
development gives developers through

00:33:42,480 --> 00:33:46,720
continuous feedback

00:33:44,960 --> 00:33:48,240
after all that all you're left with is a

00:33:46,720 --> 00:33:50,399
production environment which is governed

00:33:48,240 --> 00:33:52,399
by a team with no responsibilities

00:33:50,399 --> 00:33:53,760
in the same way that devops removed the

00:33:52,399 --> 00:33:54,559
specialness of getting things into

00:33:53,760 --> 00:33:56,080
production

00:33:54,559 --> 00:33:58,399
live software development will remove

00:33:56,080 --> 00:34:00,399
the specialness of production

00:33:58,399 --> 00:34:01,600
after all if we're able to safely build

00:34:00,399 --> 00:34:03,440
release deploy

00:34:01,600 --> 00:34:04,880
monitor and operate in production then

00:34:03,440 --> 00:34:05,360
there's nothing stopping us from safely

00:34:04,880 --> 00:34:07,679
planning

00:34:05,360 --> 00:34:09,040
coding and testing in production as well

00:34:07,679 --> 00:34:11,119
and this is what i believe will become

00:34:09,040 --> 00:34:12,879
normal for software developers

00:34:11,119 --> 00:34:15,919
at least until automation takes over

00:34:12,879 --> 00:34:15,919
software development as well

00:34:16,000 --> 00:34:18,800
thanks for listening if you want to

00:34:17,200 --> 00:34:20,399
follow the progress of source marker you

00:34:18,800 --> 00:34:23,359
can see the github repo right there

00:34:20,399 --> 00:34:24,320
it's github.com source plus plus slash

00:34:23,359 --> 00:34:25,919
source marker

00:34:24,320 --> 00:34:27,280
we're very close to our first release so

00:34:25,919 --> 00:34:28,639
maybe give it a star and watch for

00:34:27,280 --> 00:34:29,599
releases so you'll be the first to know

00:34:28,639 --> 00:34:30,960
when it happens

00:34:29,599 --> 00:34:32,639
and finally i would like to thank the

00:34:30,960 --> 00:34:34,720
apache software foundation and the

00:34:32,639 --> 00:34:36,079
apache skywalking team specifically wu

00:34:34,720 --> 00:34:36,960
xing for inviting me to speak at

00:34:36,079 --> 00:34:49,839
apachecon

00:34:36,960 --> 00:34:49,839
it was very much an honor thank you

00:35:04,480 --> 00:35:08,560
test i'm not sure if this is working but

00:35:07,280 --> 00:35:17,839
if you guys have any questions

00:35:08,560 --> 00:35:17,839
um feel free to ask them

00:35:21,920 --> 00:35:31,839
just leave that up

00:36:58,000 --> 00:37:00,079

YouTube URL: https://www.youtube.com/watch?v=IWounkxhfi0


