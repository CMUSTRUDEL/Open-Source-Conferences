Title: Netflix: Finding middle ground between monolithic and microservice architectures.
Publication date: 2020-10-16
Playlist: ApacheCon @Home 2020: Karaf
Description: 
	Netflix: Finding middle ground between monolithic and microservice architectures.
Dmitry Vasilyev, Saeid Mirzaei, George Ye

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/


The world of business applications is evolving. Monolithic applications are being split up into smaller microservices and deployed into virtualized environments. Engineers are striving to achieve responsiveness, resilience and elasticity at the same time improving separation of concerns and deployments via CI. The tradeoffs are usually more complex operations, harder dependency testability, lower developer productivity in some cases and cognitive overhead as well as infrastructure costs. We will discuss how our team at Netflix is settling in the middle between monolithic and microservice architectures getting the best of the two worlds. We’ll go through different phases of the application development lifecycle from initiation to production deployment as well as we’ll talk how Apache Karaf enables us to achieve the aforementioned properties of the systems we build.

Dmitry Vasilyev, Saeid Mirzaei, George Ye
Captions: 
	00:00:02,330 --> 00:00:06,570
[Music]

00:00:10,090 --> 00:00:13,160
[Music]

00:00:22,160 --> 00:00:27,599
okay i think i'll go ahead and start

00:00:24,320 --> 00:00:29,760
so basically today

00:00:27,599 --> 00:00:31,119
we're going to talk about finding the

00:00:29,760 --> 00:00:34,160
middle ground

00:00:31,119 --> 00:00:36,640
between uh

00:00:34,160 --> 00:00:38,079
monolithic and microservice

00:00:36,640 --> 00:00:40,960
architectures

00:00:38,079 --> 00:00:43,200
and we're going to take a look at the

00:00:40,960 --> 00:00:46,320
use case where we are trying to

00:00:43,200 --> 00:00:48,719
get like best of the both worlds

00:00:46,320 --> 00:00:50,559
and journey together and see like what

00:00:48,719 --> 00:00:59,840
are the trade-offs

00:00:50,559 --> 00:00:59,840
that we have to take for this

00:01:24,880 --> 00:01:32,079
uh sorry it seems that we

00:01:28,479 --> 00:01:34,240
losing your sound so maybe you are muted

00:01:32,079 --> 00:01:34,240
or

00:01:35,200 --> 00:01:44,560
about yeah that's better okay

00:01:41,280 --> 00:01:48,240
okay sorry for that

00:01:44,560 --> 00:01:49,280
so uh my name is dmitry i'm with media

00:01:48,240 --> 00:01:52,000
cloud

00:01:49,280 --> 00:01:54,720
engineering team at netflix i'm going to

00:01:52,000 --> 00:01:56,560
give a little bit of background uh

00:01:54,720 --> 00:01:58,079
on whatever team is doing because it

00:01:56,560 --> 00:01:59,920
gives like better understanding of the

00:01:58,079 --> 00:02:03,439
use case uh

00:01:59,920 --> 00:02:09,840
uh for basically karaf

00:02:03,439 --> 00:02:14,160
uh so as the

00:02:09,840 --> 00:02:17,280
name of the team stays with basically

00:02:14,160 --> 00:02:23,840
processing media in the cloud

00:02:17,280 --> 00:02:23,840
and we're doing it at scale

00:02:30,720 --> 00:02:35,760
uh sorry waste the sun is still off

00:02:34,080 --> 00:02:38,160
there with me again i don't know what's

00:02:35,760 --> 00:02:38,160
going on

00:02:39,440 --> 00:02:46,400
can you cry okay how about now yeah

00:02:42,560 --> 00:02:50,160
now it's good it's good yeah

00:02:46,400 --> 00:02:52,080
some of the functions of our team

00:02:50,160 --> 00:02:53,360
is we're building a platform to support

00:02:52,080 --> 00:02:56,000
uh

00:02:53,360 --> 00:02:56,640
uh a variety of media transformations

00:02:56,000 --> 00:02:59,920
and uh

00:02:56,640 --> 00:03:02,879
innovations at scale for uh

00:02:59,920 --> 00:03:04,239
netflix uh we're focusing on scalability

00:03:02,879 --> 00:03:09,519
reliability

00:03:04,239 --> 00:03:09,519
developer productivity and compute

00:03:16,840 --> 00:03:21,200
efficiency

00:03:18,159 --> 00:03:22,959
uh basically one of the

00:03:21,200 --> 00:03:24,879
uh key things that we're doing is we're

00:03:22,959 --> 00:03:28,239
abstracting uh

00:03:24,879 --> 00:03:32,000
uh out uh all sorts of common uh

00:03:28,239 --> 00:03:35,280
functionality uh across uh multiple

00:03:32,000 --> 00:03:38,159
applications and we let engineers who

00:03:35,280 --> 00:03:38,159
are focusing on

00:03:38,720 --> 00:03:44,080
media processing like encoding like

00:03:41,680 --> 00:03:47,599
video encoding audio coding or

00:03:44,080 --> 00:03:51,120
processing images uh

00:03:47,599 --> 00:03:55,360
uh we'll let them basically focus 100

00:03:51,120 --> 00:03:59,840
on uh their job while we're taking care

00:03:55,360 --> 00:04:04,159
of uh scalability

00:03:59,840 --> 00:04:07,360
and uh basically compute efficiency

00:04:04,159 --> 00:04:14,000
uh distributing the system and

00:04:07,360 --> 00:04:16,320
hiding all this complexity for them

00:04:14,000 --> 00:04:18,799
uh we're building reusable frameworks

00:04:16,320 --> 00:04:23,440
and applications and services to

00:04:18,799 --> 00:04:27,360
drive agility in content engineering

00:04:23,440 --> 00:04:29,280
so what are we going to talk about today

00:04:27,360 --> 00:04:31,120
uh and like taking a little step a

00:04:29,280 --> 00:04:33,600
little bit uh back since we're

00:04:31,120 --> 00:04:35,040
involved uh a lot with media processing

00:04:33,600 --> 00:04:38,479
and media processing is

00:04:35,040 --> 00:04:41,919
uh a very

00:04:38,479 --> 00:04:44,479
uh computationally intensive uh process

00:04:41,919 --> 00:04:47,199
in most cases

00:04:44,479 --> 00:04:48,080
we will be talking about systems that

00:04:47,199 --> 00:04:51,360
are mostly

00:04:48,080 --> 00:04:53,120
asynchronous in nature

00:04:51,360 --> 00:04:55,520
so what are we going to talk about so we

00:04:53,120 --> 00:04:58,240
will discuss

00:04:55,520 --> 00:04:59,600
limitation transcend advantages of both

00:04:58,240 --> 00:05:03,039
uh microservice and

00:04:59,600 --> 00:05:05,759
uh monolithic uh architectures

00:05:03,039 --> 00:05:06,720
uh and uh identify what are the

00:05:05,759 --> 00:05:08,880
properties

00:05:06,720 --> 00:05:10,240
that we're interested in from uh getting

00:05:08,880 --> 00:05:13,280
from both of them

00:05:10,240 --> 00:05:16,400
in our design

00:05:13,280 --> 00:05:20,320
we will go through

00:05:16,400 --> 00:05:23,600
development and release cycles of

00:05:20,320 --> 00:05:26,639
our systems to basically show how

00:05:23,600 --> 00:05:30,080
our design based on garage

00:05:26,639 --> 00:05:33,120
fits those

00:05:30,080 --> 00:05:35,600
we will analyze trade-offs of taking the

00:05:33,120 --> 00:05:38,160
hybrid approach

00:05:35,600 --> 00:05:39,039
and we will discuss how specifically

00:05:38,160 --> 00:05:40,960
karaf

00:05:39,039 --> 00:05:42,160
helps us to facilitate this hybrid

00:05:40,960 --> 00:05:45,759
approach and

00:05:42,160 --> 00:05:47,600
what are some perks that we are getting

00:05:45,759 --> 00:05:50,720
out of it

00:05:47,600 --> 00:05:52,960
so we will start with monoliths because

00:05:50,720 --> 00:05:56,160
this is basically how we started

00:05:52,960 --> 00:06:00,400
uh back when netflix started uh

00:05:56,160 --> 00:06:03,120
streaming so uh there are like

00:06:00,400 --> 00:06:05,440
um there is a multitude of different

00:06:03,120 --> 00:06:07,680
definitions uh that you can find online

00:06:05,440 --> 00:06:08,639
of what a monolithic application is we

00:06:07,680 --> 00:06:12,160
will just

00:06:08,639 --> 00:06:13,840
uh try to define uh

00:06:12,160 --> 00:06:16,000
how we see it like within our

00:06:13,840 --> 00:06:19,440
organization uh

00:06:16,000 --> 00:06:22,560
and what makes sense to our uh use case

00:06:19,440 --> 00:06:26,960
so basically monolithic architecture

00:06:22,560 --> 00:06:28,240
uh assumes that the system that is built

00:06:26,960 --> 00:06:31,039
is like independent and

00:06:28,240 --> 00:06:33,440
self-contained uh that means it's not

00:06:31,039 --> 00:06:35,280
going to it might use some

00:06:33,440 --> 00:06:36,720
database or search engine or messaging

00:06:35,280 --> 00:06:39,840
queue

00:06:36,720 --> 00:06:42,880
but it doesn't

00:06:39,840 --> 00:06:45,120
talk to other systems

00:06:42,880 --> 00:06:46,800
so it performs its functions like end to

00:06:45,120 --> 00:06:48,800
end

00:06:46,800 --> 00:06:50,400
that means like this whole uh

00:06:48,800 --> 00:06:53,680
application which is monolithic

00:06:50,400 --> 00:06:56,560
is going to perform like each and every

00:06:53,680 --> 00:06:57,280
single tasks that the system is supposed

00:06:56,560 --> 00:07:01,280
to

00:06:57,280 --> 00:07:04,319
uh perform uh it is stateless and

00:07:01,280 --> 00:07:05,680
this is like an interesting part and

00:07:04,319 --> 00:07:08,800
later we will see

00:07:05,680 --> 00:07:12,319
why why uh i include this into

00:07:08,800 --> 00:07:14,639
uh definitions but again this is kind of

00:07:12,319 --> 00:07:17,759
some of the

00:07:14,639 --> 00:07:19,360
principles that we we uh

00:07:17,759 --> 00:07:22,560
see important for even analytic

00:07:19,360 --> 00:07:25,360
architectures in our team

00:07:22,560 --> 00:07:28,000
uh so it is tightly coupled with

00:07:25,360 --> 00:07:31,599
technology stack

00:07:28,000 --> 00:07:34,560
basically for analytic applications

00:07:31,599 --> 00:07:36,560
it's really hard to migrate from one

00:07:34,560 --> 00:07:38,880
database to another database or to

00:07:36,560 --> 00:07:42,639
different messages system or

00:07:38,880 --> 00:07:46,080
to any other technology like

00:07:42,639 --> 00:07:48,400
even even uh i don't know from

00:07:46,080 --> 00:07:49,360
uh spring boot to craft just because

00:07:48,400 --> 00:07:52,800
there's

00:07:49,360 --> 00:07:53,680
uh it's always a big bang and you have

00:07:52,800 --> 00:07:56,800
to like

00:07:53,680 --> 00:07:58,080
change uh everything and in many cases

00:07:56,800 --> 00:08:01,360
it's just easier

00:07:58,080 --> 00:08:03,120
to just throw the old system away and

00:08:01,360 --> 00:08:06,800
just write a new one

00:08:03,120 --> 00:08:10,639
with the technology stack that you want

00:08:06,800 --> 00:08:10,639
which is actually what we did

00:08:11,199 --> 00:08:15,440
so a monolithic application resides in a

00:08:14,240 --> 00:08:19,199
single source code

00:08:15,440 --> 00:08:21,039
repository and it's okay when it's

00:08:19,199 --> 00:08:22,479
small and the application is young but

00:08:21,039 --> 00:08:24,879
when it starts growing

00:08:22,479 --> 00:08:27,360
it becomes a problem and we will see

00:08:24,879 --> 00:08:30,479
what kind of problems are

00:08:27,360 --> 00:08:34,399
there associated with this

00:08:30,479 --> 00:08:37,680
property of a monolithic application

00:08:34,399 --> 00:08:39,039
now an example of a monolith and i'll

00:08:37,680 --> 00:08:41,839
just come

00:08:39,039 --> 00:08:43,039
i'll just mention like a very classic

00:08:41,839 --> 00:08:46,080
one which is a

00:08:43,039 --> 00:08:49,519
web store which prefer performs like

00:08:46,080 --> 00:08:50,320
uh a set of functions like search of

00:08:49,519 --> 00:08:53,440
products

00:08:50,320 --> 00:08:54,959
product view and then you

00:08:53,440 --> 00:08:56,800
add your products to shopping cart when

00:08:54,959 --> 00:08:59,839
you order them and

00:08:56,800 --> 00:09:01,279
then you may leave some reviews and

00:08:59,839 --> 00:09:03,040
some other one and this is just one

00:09:01,279 --> 00:09:05,440
application so all of the things are

00:09:03,040 --> 00:09:08,399
residing in one repository they deployed

00:09:05,440 --> 00:09:10,000
as a single uh

00:09:08,399 --> 00:09:11,680
unit they don't talk to any other

00:09:10,000 --> 00:09:15,120
applications

00:09:11,680 --> 00:09:20,160
they're like independent and self

00:09:15,120 --> 00:09:23,600
contained and basically

00:09:20,160 --> 00:09:25,600
they work to some extent but

00:09:23,600 --> 00:09:27,920
to the point where they stop like

00:09:25,600 --> 00:09:31,760
working in some ways

00:09:27,920 --> 00:09:33,839
so what are some pros of of

00:09:31,760 --> 00:09:36,560
monolithic applications they're really

00:09:33,839 --> 00:09:38,320
simple to develop

00:09:36,560 --> 00:09:41,120
there are no like complex dependencies

00:09:38,320 --> 00:09:41,120
you don't have to

00:09:41,920 --> 00:09:47,839
basically have five different uh

00:09:45,200 --> 00:09:51,360
ids open with your source code uh going

00:09:47,839 --> 00:09:51,360
through different changes in different

00:09:52,320 --> 00:09:55,040
layers and

00:09:56,320 --> 00:10:02,880
again it just works when when it's small

00:09:59,760 --> 00:10:04,320
it is simple to test that's a good part

00:10:02,880 --> 00:10:07,120
about monolith whether

00:10:04,320 --> 00:10:08,160
it's small or big uh because it's

00:10:07,120 --> 00:10:11,440
self-contained

00:10:08,160 --> 00:10:15,120
uh it's it's

00:10:11,440 --> 00:10:17,600
uh easier to cover it with uh unit tests

00:10:15,120 --> 00:10:19,600
uh and as well as end-to-end tests like

00:10:17,600 --> 00:10:21,680
smoke test regression tests or

00:10:19,600 --> 00:10:24,320
whatever tests you can come up with it's

00:10:21,680 --> 00:10:27,519
easy with monolithic application

00:10:24,320 --> 00:10:29,760
uh deployment is easy uh so

00:10:27,519 --> 00:10:32,079
it's packaged to the single uh

00:10:29,760 --> 00:10:35,279
deliverable and then this deliverable

00:10:32,079 --> 00:10:37,279
just gets deployed and if you

00:10:35,279 --> 00:10:39,120
don't have any automation you can just

00:10:37,279 --> 00:10:42,160
copy your

00:10:39,120 --> 00:10:42,160
you know binary to

00:10:44,079 --> 00:10:48,959
your target machine or instance and it's

00:10:47,120 --> 00:10:51,600
going to work

00:10:48,959 --> 00:10:52,160
uh and simple horizontal scaling and

00:10:51,600 --> 00:10:54,880
this is

00:10:52,160 --> 00:10:55,600
uh where the server serverless comes in

00:10:54,880 --> 00:10:57,200
play

00:10:55,600 --> 00:11:00,079
uh why is it simple it's just because

00:10:57,200 --> 00:11:03,120
you can just run multiple instances of

00:11:00,079 --> 00:11:04,240
the same code base and they will be

00:11:03,120 --> 00:11:05,920
handling

00:11:04,240 --> 00:11:08,320
behind some load balancer and they will

00:11:05,920 --> 00:11:12,240
be handling requests

00:11:08,320 --> 00:11:12,240
and working just fine

00:11:12,720 --> 00:11:16,800
operations are easy because uh

00:11:14,880 --> 00:11:20,399
everything is one place

00:11:16,800 --> 00:11:23,760
uh you don't have to dig through

00:11:20,399 --> 00:11:25,680
uh various layers of uh

00:11:23,760 --> 00:11:27,760
networking to figure out what's going on

00:11:25,680 --> 00:11:30,079
with your system if something goes

00:11:27,760 --> 00:11:30,079
wrong

00:11:31,839 --> 00:11:36,399
okay what are some of the cons of this

00:11:36,640 --> 00:11:42,320
architecture basically it has

00:11:40,000 --> 00:11:44,240
various practical limitations insights

00:11:42,320 --> 00:11:47,360
and complexity and

00:11:44,240 --> 00:11:48,320
what that means is uh once your code

00:11:47,360 --> 00:11:52,320
base gets

00:11:48,320 --> 00:11:55,279
bigger it's really hard to

00:11:52,320 --> 00:11:56,240
understand what's going on in the system

00:11:55,279 --> 00:12:00,399
especially for

00:11:56,240 --> 00:12:02,639
people who are joining the team or uh

00:12:00,399 --> 00:12:04,320
uh even people like who never worked

00:12:02,639 --> 00:12:06,320
with this application and they just

00:12:04,320 --> 00:12:09,120
start working with it it's hard

00:12:06,320 --> 00:12:10,560
and complex and also also it's uh hard

00:12:09,120 --> 00:12:12,880
to understand what are the

00:12:10,560 --> 00:12:13,600
what is the impact of the changes that

00:12:12,880 --> 00:12:18,000
i'm

00:12:13,600 --> 00:12:20,079
uh making to the system and which parts

00:12:18,000 --> 00:12:24,160
i can affect because everything is

00:12:20,079 --> 00:12:27,040
uh in the same code base

00:12:24,160 --> 00:12:28,720
all those classes could be shared and

00:12:27,040 --> 00:12:31,839
behavior that i'm changing

00:12:28,720 --> 00:12:35,120
could not be expected by some other

00:12:31,839 --> 00:12:35,120
parts of the system

00:12:36,720 --> 00:12:41,040
lower development productivity with less

00:12:39,440 --> 00:12:43,760
larger code bases

00:12:41,040 --> 00:12:44,959
uh not just because it's complex and you

00:12:43,760 --> 00:12:46,959
have to be really

00:12:44,959 --> 00:12:48,800
careful about the changes that you're

00:12:46,959 --> 00:12:50,160
making but just because like with a huge

00:12:48,800 --> 00:12:53,839
code base your

00:12:50,160 --> 00:12:57,040
uh ide starts working

00:12:53,839 --> 00:13:00,160
uh like pretty slowly

00:12:57,040 --> 00:13:01,120
and and uh it's getting bogged and uh it

00:13:00,160 --> 00:13:04,320
all takes time

00:13:01,120 --> 00:13:07,760
uh builds take uh time because

00:13:04,320 --> 00:13:10,959
all this needs to get compiled and

00:13:07,760 --> 00:13:14,079
basically tests are

00:13:10,959 --> 00:13:17,279
running longer because the remote has to

00:13:14,079 --> 00:13:17,279
cover a bigger code base

00:13:17,440 --> 00:13:22,079
continuous deployment is hard or

00:13:19,680 --> 00:13:26,399
impossible well for the same reasons

00:13:22,079 --> 00:13:27,839
because you cannot be really confident

00:13:26,399 --> 00:13:29,279
uh

00:13:27,839 --> 00:13:31,279
about the changes that you're making

00:13:29,279 --> 00:13:35,200
there is like a big set of

00:13:31,279 --> 00:13:37,760
uh tasks that that are developed to

00:13:35,200 --> 00:13:39,839
uh make sure that there is no regression

00:13:37,760 --> 00:13:43,279
uh in any part of the system

00:13:39,839 --> 00:13:46,000
and those tastes um basically

00:13:43,279 --> 00:13:49,120
those tests take longer and also because

00:13:46,000 --> 00:13:51,600
it's like a uh

00:13:49,120 --> 00:13:53,199
single b code base which is which the

00:13:51,600 --> 00:13:55,680
entire team is working on

00:13:53,199 --> 00:13:56,399
uh there are various commits coming from

00:13:55,680 --> 00:13:58,610
uh

00:13:56,399 --> 00:13:59,839
different people uh

00:13:58,610 --> 00:14:02,079
[Music]

00:13:59,839 --> 00:14:04,480
and like continuous deployment and

00:14:02,079 --> 00:14:09,040
continuous integration is either

00:14:04,480 --> 00:14:09,040
really hard or even impossible

00:14:10,160 --> 00:14:14,000
so there are also concerns like about

00:14:12,399 --> 00:14:16,800
reliability

00:14:14,000 --> 00:14:17,279
because there is no failure isolation if

00:14:16,800 --> 00:14:20,160
there is

00:14:17,279 --> 00:14:21,120
one line of code which goes into some

00:14:20,160 --> 00:14:23,199
infinite loop and

00:14:21,120 --> 00:14:25,839
allocates memory this would just kill

00:14:23,199 --> 00:14:29,360
the entire application

00:14:25,839 --> 00:14:33,440
and basically uh

00:14:29,360 --> 00:14:36,480
this is a part that uh microservices are

00:14:33,440 --> 00:14:40,399
better at and yeah

00:14:36,480 --> 00:14:43,440
hard to adopt new technologies uh

00:14:40,399 --> 00:14:44,079
because everything is like uh very

00:14:43,440 --> 00:14:47,680
dependent

00:14:44,079 --> 00:14:49,760
inside the monolith uh the only way to

00:14:47,680 --> 00:14:50,720
change to a new technology is to do like

00:14:49,760 --> 00:14:53,279
a big

00:14:50,720 --> 00:14:55,440
bang or like start developing some sort

00:14:53,279 --> 00:14:59,040
of obstructions in java layer but

00:14:55,440 --> 00:15:02,639
uh one way or another it is hard and

00:14:59,040 --> 00:15:05,920
this is why many of uh monolithic

00:15:02,639 --> 00:15:10,079
uh applications uh they're pretty much

00:15:05,920 --> 00:15:12,959
married to their technology stack and

00:15:10,079 --> 00:15:14,079
at best migrating to newer versions of

00:15:12,959 --> 00:15:18,160
uh things that

00:15:14,079 --> 00:15:18,160
uh they're using already

00:15:20,480 --> 00:15:24,959
okay yeah so this this is these are

00:15:23,279 --> 00:15:26,720
monolithic applications and we've been

00:15:24,959 --> 00:15:30,480
operating those for

00:15:26,720 --> 00:15:35,279
quite some time and

00:15:30,480 --> 00:15:38,839
when when the entire netflix

00:15:35,279 --> 00:15:40,639
started switching to microservices we

00:15:38,839 --> 00:15:43,920
basically uh

00:15:40,639 --> 00:15:47,440
did not rush we first thing we did is we

00:15:43,920 --> 00:15:50,079
uh just extracted a few

00:15:47,440 --> 00:15:51,440
services out of uh our monolith and we

00:15:50,079 --> 00:15:54,240
continued to

00:15:51,440 --> 00:15:57,759
uh operate it uh till the point where we

00:15:54,240 --> 00:15:57,759
decided okay now it's time to

00:15:58,959 --> 00:16:03,920
rewrite our platform due to various

00:16:02,320 --> 00:16:05,839
limitations

00:16:03,920 --> 00:16:07,360
and evolve and then we started looking

00:16:05,839 --> 00:16:09,199
into microservices

00:16:07,360 --> 00:16:10,959
and at this point of netflix there was

00:16:09,199 --> 00:16:12,720
already some paved path for

00:16:10,959 --> 00:16:14,800
microservices and there was like some

00:16:12,720 --> 00:16:18,160
experience accumulated

00:16:14,800 --> 00:16:20,639
so microservices

00:16:18,160 --> 00:16:22,000
again this is a definition which makes

00:16:20,639 --> 00:16:25,440
sense for

00:16:22,000 --> 00:16:27,040
ours and uh us and basically uh

00:16:25,440 --> 00:16:28,480
it doesn't like identify what a

00:16:27,040 --> 00:16:31,839
microservices

00:16:28,480 --> 00:16:32,560
uh from all possible aspects by any

00:16:31,839 --> 00:16:35,199
means but

00:16:32,560 --> 00:16:36,160
uh this is what we have and this is what

00:16:35,199 --> 00:16:39,519
makes sense to us

00:16:36,160 --> 00:16:41,920
so microservices are

00:16:39,519 --> 00:16:43,199
loosely coupled with other microservices

00:16:41,920 --> 00:16:47,600
they always work

00:16:43,199 --> 00:16:49,120
as a group each microservice performs

00:16:47,600 --> 00:16:52,160
like a specific tasks

00:16:49,120 --> 00:16:55,680
a task rather than an end-to-end

00:16:52,160 --> 00:16:57,920
function like

00:16:55,680 --> 00:16:59,680
a group of microservices would perform

00:16:57,920 --> 00:17:02,800
an end-to-end function

00:16:59,680 --> 00:17:06,160
and then each microservice

00:17:02,800 --> 00:17:08,400
out of uh the group uh would reside in

00:17:06,160 --> 00:17:11,600
its own source code repository

00:17:08,400 --> 00:17:12,000
um and it's a separate deployment as

00:17:11,600 --> 00:17:14,640
well

00:17:12,000 --> 00:17:16,720
and it's also stateless so an example

00:17:14,640 --> 00:17:19,760
would be basically the same web store

00:17:16,720 --> 00:17:23,039
where each of the uh mentioned

00:17:19,760 --> 00:17:23,039
like uh

00:17:23,439 --> 00:17:26,400
groups of tasks is performed by

00:17:25,039 --> 00:17:28,079
microservices so there's going to be a

00:17:26,400 --> 00:17:30,720
product search microsoft

00:17:28,079 --> 00:17:32,880
product few microservers all the place

00:17:30,720 --> 00:17:34,799
placement microservice uh

00:17:32,880 --> 00:17:37,120
product reviews microservice and maybe

00:17:34,799 --> 00:17:38,799
some others

00:17:37,120 --> 00:17:40,880
this is like the web store which can

00:17:38,799 --> 00:17:44,720
split into microservices

00:17:40,880 --> 00:17:46,000
so some of the process of microservices

00:17:44,720 --> 00:17:48,640
independent development of each

00:17:46,000 --> 00:17:52,320
microservice and uh

00:17:48,640 --> 00:17:53,440
lower complexity uh for uh individual

00:17:52,320 --> 00:17:56,960
microservice

00:17:53,440 --> 00:17:58,720
um like the scope of the microservices

00:17:56,960 --> 00:18:01,679
is related to a single task and

00:17:58,720 --> 00:18:01,679
easier to understand that

00:18:02,000 --> 00:18:08,400
it's faster to learn microservice code

00:18:05,840 --> 00:18:08,400
based on the

00:18:08,880 --> 00:18:13,200
development of a single microservices

00:18:11,200 --> 00:18:14,480
faster failure isolation so yeah if

00:18:13,200 --> 00:18:16,320
something fails

00:18:14,480 --> 00:18:17,679
uh in a system we just build out of

00:18:16,320 --> 00:18:20,799
microservices

00:18:17,679 --> 00:18:23,280
uh uh

00:18:20,799 --> 00:18:24,000
and if it's done like uh in the correct

00:18:23,280 --> 00:18:27,039
way

00:18:24,000 --> 00:18:30,240
then only like this specific microsoft

00:18:27,039 --> 00:18:31,760
would fail or potentially like some

00:18:30,240 --> 00:18:35,280
microsources that

00:18:31,760 --> 00:18:35,919
depend on it as well so uh continuous

00:18:35,280 --> 00:18:38,799
integration

00:18:35,919 --> 00:18:39,360
continuous uh deployment now because

00:18:38,799 --> 00:18:41,440
during

00:18:39,360 --> 00:18:44,640
the code base is not too big there are

00:18:41,440 --> 00:18:46,480
not the amount of tests that need to run

00:18:44,640 --> 00:18:48,880
if you change something is not too big

00:18:46,480 --> 00:18:53,120
you can go with a continuous

00:18:48,880 --> 00:18:56,320
uh deployment and continuous integration

00:18:53,120 --> 00:18:59,280
independent horizontal scaling

00:18:56,320 --> 00:19:01,280
let's click one of the good parts is

00:18:59,280 --> 00:19:04,559
that you can scale

00:19:01,280 --> 00:19:07,919
only only parts that

00:19:04,559 --> 00:19:07,919
care about scaling without

00:19:08,880 --> 00:19:16,240
scaling microservices that don't

00:19:13,760 --> 00:19:17,120
uh lower barrier an adoption of new

00:19:16,240 --> 00:19:19,520
technologies

00:19:17,120 --> 00:19:20,640
uh yeah you can you can in in this

00:19:19,520 --> 00:19:22,720
architecture you can go just

00:19:20,640 --> 00:19:24,559
microservice by microservice and the

00:19:22,720 --> 00:19:26,000
amount of changes that need to happen to

00:19:24,559 --> 00:19:30,799
a micro service is

00:19:26,000 --> 00:19:32,799
just isolated to this micro service and

00:19:30,799 --> 00:19:34,559
different micro services inside the

00:19:32,799 --> 00:19:37,039
system can run on different

00:19:34,559 --> 00:19:40,080
uh technology stacks or use different

00:19:37,039 --> 00:19:40,080
databases or

00:19:40,160 --> 00:19:43,679
different search engines different cues

00:19:42,080 --> 00:19:46,640
or anything

00:19:43,679 --> 00:19:49,840
they want to and it's easier to switch

00:19:46,640 --> 00:19:49,840
back and forth if needed

00:19:51,039 --> 00:19:58,880
some of the kinds of microservices so

00:19:55,200 --> 00:20:00,799
high complexity for uh

00:19:58,880 --> 00:20:02,159
microservice group because now it's like

00:20:00,799 --> 00:20:03,360
a distributed system with all the

00:20:02,159 --> 00:20:06,960
complexities of

00:20:03,360 --> 00:20:10,159
the inheritance complexes of distributed

00:20:06,960 --> 00:20:11,760
systems so lower testability of the

00:20:10,159 --> 00:20:14,080
entire system because

00:20:11,760 --> 00:20:15,039
now in order to test something you just

00:20:14,080 --> 00:20:18,880
need to

00:20:15,039 --> 00:20:22,240
have all of your micro services running

00:20:18,880 --> 00:20:24,720
uh harder to

00:20:22,240 --> 00:20:26,799
implement and roll out changes spanning

00:20:24,720 --> 00:20:28,159
multiple microservices this usually

00:20:26,799 --> 00:20:31,520
happens in steps

00:20:28,159 --> 00:20:33,120
first you do one micro service then you

00:20:31,520 --> 00:20:34,000
release it and has to be in a backward

00:20:33,120 --> 00:20:36,720
compatible

00:20:34,000 --> 00:20:38,559
manner then uh the next micro server

00:20:36,720 --> 00:20:41,360
speaks this change app and

00:20:38,559 --> 00:20:42,960
uh there we go in in monolithic

00:20:41,360 --> 00:20:44,400
application you just change your code

00:20:42,960 --> 00:20:46,480
base and you deploy it

00:20:44,400 --> 00:20:48,000
and this because like this deployment is

00:20:46,480 --> 00:20:51,280
like more or less atomic

00:20:48,000 --> 00:20:51,280
is it's gonna just fly

00:20:53,360 --> 00:20:58,640
harder operations for uh microservice

00:20:56,640 --> 00:21:02,320
group yeah there's gonna be a lot more

00:20:58,640 --> 00:21:05,280
jenkins job pipelines places to look for

00:21:02,320 --> 00:21:05,280
logs uh

00:21:05,360 --> 00:21:08,799
monitoring dashboards and others coming

00:21:08,000 --> 00:21:13,120
from

00:21:08,799 --> 00:21:16,480
different ways and uh whoever is on call

00:21:13,120 --> 00:21:16,480
for the system like this

00:21:18,159 --> 00:21:22,960
dreams every time to go back to

00:21:20,640 --> 00:21:24,640
monolithic application

00:21:22,960 --> 00:21:27,039
increased computational resource

00:21:24,640 --> 00:21:30,960
consumption like uh

00:21:27,039 --> 00:21:36,080
in order to work together there is a

00:21:30,960 --> 00:21:39,120
quite a bit of like services that are

00:21:36,080 --> 00:21:42,559
microservices would need uh

00:21:39,120 --> 00:21:46,400
to be able to copyright and

00:21:42,559 --> 00:21:48,240
there's definitely uh for example in our

00:21:46,400 --> 00:21:49,840
case each microservice is going to run a

00:21:48,240 --> 00:21:50,880
separate jvm which is already in

00:21:49,840 --> 00:21:52,640
overhead and

00:21:50,880 --> 00:21:54,480
there are many other aspects with which

00:21:52,640 --> 00:21:57,039
increase uh computational resource

00:21:54,480 --> 00:21:57,039
consumption

00:21:57,520 --> 00:22:06,480
so uh general uh monolithic

00:22:02,159 --> 00:22:09,360
uh applications

00:22:06,480 --> 00:22:11,120
uh and it's it's in its inside structure

00:22:09,360 --> 00:22:13,360
and not very different from

00:22:11,120 --> 00:22:16,000
microservices so what is it is it a

00:22:13,360 --> 00:22:20,320
microservice or is it a

00:22:16,000 --> 00:22:22,240
monolith it could be anything right

00:22:20,320 --> 00:22:23,840
uh what are some myths right about

00:22:22,240 --> 00:22:24,880
microservices and they're not really

00:22:23,840 --> 00:22:28,080
myth but

00:22:24,880 --> 00:22:31,440
things that are more not practical

00:22:28,080 --> 00:22:34,640
like polyglot this like uh the idea of

00:22:31,440 --> 00:22:36,320
polyglot uh yeah they can be polyglot

00:22:34,640 --> 00:22:38,080
each microservice could be built in its

00:22:36,320 --> 00:22:39,200
own language but is it practical like

00:22:38,080 --> 00:22:42,240
just imagine

00:22:39,200 --> 00:22:44,000
yourself being a hiring manager who runs

00:22:42,240 --> 00:22:46,159
a team of five engineers

00:22:44,000 --> 00:22:47,760
and uh the team owns like 10

00:22:46,159 --> 00:22:49,280
microsources different than five

00:22:47,760 --> 00:22:54,080
different language

00:22:49,280 --> 00:22:56,400
hiring you know uh

00:22:54,080 --> 00:22:57,280
engineers with experiences and all those

00:22:56,400 --> 00:23:00,080
five languages

00:22:57,280 --> 00:23:01,760
is just going to be a nightmare so uh is

00:23:00,080 --> 00:23:02,799
it like really practical or does it

00:23:01,760 --> 00:23:06,159
really matter

00:23:02,799 --> 00:23:08,799
uh at least not for us

00:23:06,159 --> 00:23:09,360
sure nothing yeah well that's another uh

00:23:08,799 --> 00:23:12,159
thing that

00:23:09,360 --> 00:23:12,880
uh microservice community would brag

00:23:12,159 --> 00:23:16,000
about but

00:23:12,880 --> 00:23:16,799
the reality is like uh you could build

00:23:16,000 --> 00:23:19,200
micro

00:23:16,799 --> 00:23:20,480
services that share nothing but this

00:23:19,200 --> 00:23:22,720
would be just you know

00:23:20,480 --> 00:23:24,240
each and every team for each and every

00:23:22,720 --> 00:23:25,280
microservice would be coming with a

00:23:24,240 --> 00:23:27,440
technology

00:23:25,280 --> 00:23:29,840
stack and then building this whole

00:23:27,440 --> 00:23:31,840
auxiliary services that i needed to

00:23:29,840 --> 00:23:33,039
run all those microservices this would

00:23:31,840 --> 00:23:36,080
be like very

00:23:33,039 --> 00:23:40,159
very uh uh impractical

00:23:36,080 --> 00:23:43,279
and and too uh expensive

00:23:40,159 --> 00:23:45,840
yep so is it it is possible but not

00:23:43,279 --> 00:23:45,840
practical

00:23:46,640 --> 00:23:53,440
uh so what do microservices share

00:23:50,240 --> 00:23:57,279
so common libraries and frameworks

00:23:53,440 --> 00:23:57,279
common infrastructure level services

00:23:57,840 --> 00:24:03,600
such as discovery configuration metrics

00:24:01,840 --> 00:24:05,600
login each and every microservice

00:24:03,600 --> 00:24:08,960
basically needs to have those

00:24:05,600 --> 00:24:12,559
in order to function uh properly or

00:24:08,960 --> 00:24:16,159
like being operational operational

00:24:12,559 --> 00:24:19,440
and in general there's quite a lot of

00:24:16,159 --> 00:24:24,640
automation that needs to happen around

00:24:19,440 --> 00:24:24,640
microservices to make them work

00:24:26,799 --> 00:24:30,159
and who like ships all those common

00:24:29,440 --> 00:24:34,080
things

00:24:30,159 --> 00:24:37,360
usually like in companies uh

00:24:34,080 --> 00:24:37,679
this this is like the basically function

00:24:37,360 --> 00:24:40,880
of

00:24:37,679 --> 00:24:43,600
uh runtime teams or platform teams they

00:24:40,880 --> 00:24:44,840
uh build this framework they evaluate

00:24:43,600 --> 00:24:47,520
adopt uh

00:24:44,840 --> 00:24:48,640
they provide all those services and

00:24:47,520 --> 00:24:51,840
basically

00:24:48,640 --> 00:24:53,919
uh they focus on yeah

00:24:51,840 --> 00:24:55,520
infrastructure like for a specific

00:24:53,919 --> 00:24:59,200
premium language which is

00:24:55,520 --> 00:25:01,120
uh in our case java so

00:24:59,200 --> 00:25:03,120
they build maintenance tribute common

00:25:01,120 --> 00:25:04,640
frameworks and libraries and they

00:25:03,120 --> 00:25:07,120
build maintain and operate common

00:25:04,640 --> 00:25:10,320
services like uh

00:25:07,120 --> 00:25:13,440
discovery or configuration or

00:25:10,320 --> 00:25:15,440
login or anything else uh

00:25:13,440 --> 00:25:16,960
you can think about this needed for

00:25:15,440 --> 00:25:20,000
microservices so

00:25:16,960 --> 00:25:24,080
um and they that lets

00:25:20,000 --> 00:25:27,520
uh microsoft developers focus on

00:25:24,080 --> 00:25:29,600
business logic and also saves them from

00:25:27,520 --> 00:25:30,720
expanding their human resources on

00:25:29,600 --> 00:25:33,760
developing

00:25:30,720 --> 00:25:35,520
uh same things over and over uh

00:25:33,760 --> 00:25:36,960
and they like pretty much provide you a

00:25:35,520 --> 00:25:39,840
paved path for

00:25:36,960 --> 00:25:41,840
developing uh microsources as well as

00:25:39,840 --> 00:25:45,279
they shoot them

00:25:41,840 --> 00:25:48,400
their comments to

00:25:45,279 --> 00:25:49,919
on daily basis uh with ladies and

00:25:48,400 --> 00:25:53,039
gentles to

00:25:49,919 --> 00:25:53,760
the owners of microservices so this is

00:25:53,039 --> 00:25:57,440
what the

00:25:53,760 --> 00:25:57,440
function of this team is and uh

00:25:58,320 --> 00:26:04,799
this is like uh was like a key

00:26:01,360 --> 00:26:06,799
to one of the keys to to our uh

00:26:04,799 --> 00:26:08,080
decision to use graphics since we have

00:26:06,799 --> 00:26:10,080
this uh

00:26:08,080 --> 00:26:12,000
all those common services and we have

00:26:10,080 --> 00:26:16,159
all this like big bundle

00:26:12,000 --> 00:26:20,000
of libraries uh shipped to basically our

00:26:16,159 --> 00:26:23,279
platform we usually just leverage this

00:26:20,000 --> 00:26:24,320
uh and later we'll see how so full cycle

00:26:23,279 --> 00:26:28,640
development

00:26:24,320 --> 00:26:31,120
um basically this is how development

00:26:28,640 --> 00:26:31,679
of a microservice like what usually

00:26:31,120 --> 00:26:35,200
happen

00:26:31,679 --> 00:26:37,360
and uh an important thing here is the

00:26:35,200 --> 00:26:40,240
responsibility of uh

00:26:37,360 --> 00:26:40,799
like every engineer in the team so you

00:26:40,240 --> 00:26:42,720
design

00:26:40,799 --> 00:26:43,919
you develop then you test then you

00:26:42,720 --> 00:26:46,559
deploy

00:26:43,919 --> 00:26:48,559
then you operate it and you support it

00:26:46,559 --> 00:26:51,679
and

00:26:48,559 --> 00:26:52,080
this just goes in circles uh well you

00:26:51,679 --> 00:26:54,080
are

00:26:52,080 --> 00:26:56,720
only in this microsoft this is basically

00:26:54,080 --> 00:27:00,880
what a full cycle development means so

00:26:56,720 --> 00:27:05,039
uh which is also another like uh

00:27:00,880 --> 00:27:08,159
uh aspect of uh uh

00:27:05,039 --> 00:27:11,440
and actually one of the reasons why we

00:27:08,159 --> 00:27:14,640
chose the hybrid approach and uh

00:27:11,440 --> 00:27:17,760
uh basically used uh graph to

00:27:14,640 --> 00:27:19,919
implement it uh so

00:27:17,760 --> 00:27:21,679
uh microservice like a typical

00:27:19,919 --> 00:27:25,360
microservice development

00:27:21,679 --> 00:27:26,240
lifecycle ci cd so there's a project

00:27:25,360 --> 00:27:28,240
structure which

00:27:26,240 --> 00:27:29,600
is getting usually generated by some

00:27:28,240 --> 00:27:31,360
cradle plugin

00:27:29,600 --> 00:27:34,080
uh and it's going to create a git

00:27:31,360 --> 00:27:37,440
repository jenkins jobs and spinach

00:27:34,080 --> 00:27:40,080
pipelines for his deployment

00:27:37,440 --> 00:27:41,120
and then an engineer would create a

00:27:40,080 --> 00:27:43,600
feature branch

00:27:41,120 --> 00:27:45,919
develop a feature cover it with tests

00:27:43,600 --> 00:27:45,919
and then

00:27:46,799 --> 00:27:50,240
the code is getting pushed into this

00:27:48,399 --> 00:27:53,760
feature branch uh indeed

00:27:50,240 --> 00:27:55,760
and is going to trigger changes jobs

00:27:53,760 --> 00:27:57,120
execution and spinning her pipelines

00:27:55,760 --> 00:27:59,520
when it's going to get

00:27:57,120 --> 00:28:01,120
uh deployed in into cloud into a

00:27:59,520 --> 00:28:04,559
non-production environment

00:28:01,120 --> 00:28:07,440
and then cloud instance uh basically

00:28:04,559 --> 00:28:09,600
gets created and turned tests uh run

00:28:07,440 --> 00:28:12,720
against it and if everything is

00:28:09,600 --> 00:28:14,399
uh successful then

00:28:12,720 --> 00:28:16,000
an engineer would create a pull request

00:28:14,399 --> 00:28:19,039
to master

00:28:16,000 --> 00:28:21,520
uh make you know some teammates uh

00:28:19,039 --> 00:28:22,240
look at it approve it and then screen to

00:28:21,520 --> 00:28:26,000
get

00:28:22,240 --> 00:28:28,559
uh merged and once this happened

00:28:26,000 --> 00:28:29,120
there's a game there's uh another

00:28:28,559 --> 00:28:33,279
instance

00:28:29,120 --> 00:28:35,760
of uh microservice which

00:28:33,279 --> 00:28:37,120
is getting created and then again

00:28:35,760 --> 00:28:40,080
end-to-end tests

00:28:37,120 --> 00:28:41,600
are run and if they're successful then

00:28:40,080 --> 00:28:42,240
the push is merged and it goes to

00:28:41,600 --> 00:28:44,399
production

00:28:42,240 --> 00:28:45,360
and here is like another important thing

00:28:44,399 --> 00:28:48,399
is

00:28:45,360 --> 00:28:51,840
uh those instances that are constantly

00:28:48,399 --> 00:28:52,799
getting created in the cloud to just you

00:28:51,840 --> 00:28:56,480
know serve

00:28:52,799 --> 00:28:59,679
a few requests and then

00:28:56,480 --> 00:29:03,440
usually what would happen is they would

00:28:59,679 --> 00:29:06,960
just expire after certain ttl

00:29:03,440 --> 00:29:10,000
and they will just uh go away

00:29:06,960 --> 00:29:12,320
but still most of the time of

00:29:10,000 --> 00:29:15,200
their lifespan they're just sitting

00:29:12,320 --> 00:29:15,200
there doing nothing

00:29:16,799 --> 00:29:19,919
so what were our goals when we were

00:29:18,880 --> 00:29:22,640
looking uh

00:29:19,919 --> 00:29:24,840
at carafe so we thought you care about

00:29:22,640 --> 00:29:27,200
microservices are okay but

00:29:24,840 --> 00:29:28,880
uh would also like to have like some

00:29:27,200 --> 00:29:31,279
easier operations and

00:29:28,880 --> 00:29:32,799
less cognitive overhead of all those

00:29:31,279 --> 00:29:36,320
micro services and

00:29:32,799 --> 00:29:39,520
uh lots of jenkins jobs and uh

00:29:36,320 --> 00:29:41,440
spinnaker pipelines and

00:29:39,520 --> 00:29:43,279
like some better dependency management

00:29:41,440 --> 00:29:46,000
because uh

00:29:43,279 --> 00:29:47,919
it's spring boot and typical like uh

00:29:46,000 --> 00:29:51,360
microsoft you said netflix

00:29:47,919 --> 00:29:52,840
uh many things many

00:29:51,360 --> 00:29:55,100
if there's a bug for instance in

00:29:52,840 --> 00:29:56,880
platform which leaked and

00:29:55,100 --> 00:29:58,960
[Music]

00:29:56,880 --> 00:30:00,960
many microservices picked it up they

00:29:58,960 --> 00:30:03,919
need to also pick up a fix

00:30:00,960 --> 00:30:05,200
and uh for this you need to chase people

00:30:03,919 --> 00:30:08,320
and ask them to

00:30:05,200 --> 00:30:10,399
update their their dependencies uh

00:30:08,320 --> 00:30:12,080
sometimes like uh this happens

00:30:10,399 --> 00:30:15,360
automatically but if it

00:30:12,080 --> 00:30:17,520
fails or um

00:30:15,360 --> 00:30:18,799
the the job basically their their

00:30:17,520 --> 00:30:22,240
dependency of the job

00:30:18,799 --> 00:30:23,600
uh insurance fails this would not happen

00:30:22,240 --> 00:30:24,960
or sometimes people not

00:30:23,600 --> 00:30:27,279
just paying attention it's just a

00:30:24,960 --> 00:30:29,120
dependency job it's not impacting

00:30:27,279 --> 00:30:32,240
anything

00:30:29,120 --> 00:30:33,120
you basically need to let them know that

00:30:32,240 --> 00:30:36,799
there is a problem

00:30:33,120 --> 00:30:39,440
and they need to address it

00:30:36,799 --> 00:30:42,799
yeah and the other thing is spend less

00:30:39,440 --> 00:30:42,799
on cloud infrastructure

00:30:43,360 --> 00:30:50,320
and get a bit of better testability of

00:30:46,960 --> 00:30:53,039
microservice groups together because

00:30:50,320 --> 00:30:55,360
like deploying each and every service

00:30:53,039 --> 00:30:58,880
into its isolated environment

00:30:55,360 --> 00:30:58,880
is not really practical

00:30:59,279 --> 00:31:03,360
so this is where karaf comes in picture

00:31:01,840 --> 00:31:06,799
we started looking at

00:31:03,360 --> 00:31:06,799
what can we do we found

00:31:06,960 --> 00:31:14,000
a carafe because we were looking at osgi

00:31:10,240 --> 00:31:16,960
and so some of the key things

00:31:14,000 --> 00:31:18,480
that were again influenced our decisions

00:31:16,960 --> 00:31:20,720
so we knew that we are

00:31:18,480 --> 00:31:22,399
uh not going to build public micro

00:31:20,720 --> 00:31:22,720
services because we are a jabber shop

00:31:22,399 --> 00:31:25,840
and

00:31:22,720 --> 00:31:30,480
uh this uh runtime team

00:31:25,840 --> 00:31:32,799
provides support only for java so

00:31:30,480 --> 00:31:34,080
that's like safe to assume that in

00:31:32,799 --> 00:31:37,200
nearest future we are not

00:31:34,080 --> 00:31:40,720
going away from job so okay this

00:31:37,200 --> 00:31:44,080
this is perfect we can use graph uh

00:31:40,720 --> 00:31:47,440
we also wanted to be uh multi-town so

00:31:44,080 --> 00:31:50,720
we wanted to leverage

00:31:47,440 --> 00:31:54,399
and reuse resources on the

00:31:50,720 --> 00:31:54,399
host especially in

00:31:54,480 --> 00:31:59,360
non-production environments where all

00:31:57,120 --> 00:32:01,600
those

00:31:59,360 --> 00:32:03,519
instances they just serve couple

00:32:01,600 --> 00:32:08,399
requests and then they sit for

00:32:03,519 --> 00:32:12,799
a few days without doing anything

00:32:08,399 --> 00:32:12,799
they're just being paid for um

00:32:13,279 --> 00:32:17,519
yeah and then we wanted to have an

00:32:16,159 --> 00:32:22,320
ability to deploy

00:32:17,519 --> 00:32:24,799
uh in a reasonable manner uh

00:32:22,320 --> 00:32:26,720
services into an isolated environment so

00:32:24,799 --> 00:32:28,880
that we could test them together

00:32:26,720 --> 00:32:29,760
or debug something when they're running

00:32:28,880 --> 00:32:32,240
together

00:32:29,760 --> 00:32:33,279
and the reason for like isolated

00:32:32,240 --> 00:32:36,799
environment is

00:32:33,279 --> 00:32:39,039
again uh because uh

00:32:36,799 --> 00:32:40,880
we are mostly asynchronous and we are

00:32:39,039 --> 00:32:43,519
communicating through messaging systems

00:32:40,880 --> 00:32:46,480
and there's a good chance that

00:32:43,519 --> 00:32:47,919
some other microservice will just pick

00:32:46,480 --> 00:32:49,840
up your message or some other instance

00:32:47,919 --> 00:32:53,360
of microservice would just pick up your

00:32:49,840 --> 00:32:53,360
message and you won't see what happened

00:32:54,840 --> 00:33:01,279
um and we also wanted to

00:32:58,080 --> 00:33:04,720
uh share uh

00:33:01,279 --> 00:33:08,559
all those common services um

00:33:04,720 --> 00:33:12,000
like login metrics uh configuration

00:33:08,559 --> 00:33:12,480
and discovery between various services

00:33:12,000 --> 00:33:15,840
because

00:33:12,480 --> 00:33:18,960
they present like a quite a big overhead

00:33:15,840 --> 00:33:20,159
uh even given like for instance

00:33:18,960 --> 00:33:25,519
discovery

00:33:20,159 --> 00:33:28,559
uh like only all the uh

00:33:25,519 --> 00:33:31,440
map of uh netflix microservices

00:33:28,559 --> 00:33:33,039
is get getting shipped to your instance

00:33:31,440 --> 00:33:34,080
so that you could call any of those

00:33:33,039 --> 00:33:36,840
services

00:33:34,080 --> 00:33:39,840
pretty much same same same comes to

00:33:36,840 --> 00:33:39,840
configuration

00:33:42,640 --> 00:33:49,120
so we also wanted to

00:33:45,679 --> 00:33:52,240
have an ability to quickly

00:33:49,120 --> 00:33:55,600
ship any fixes

00:33:52,240 --> 00:33:58,799
or library updates

00:33:55,600 --> 00:34:00,480
or features to all of the microservices

00:33:58,799 --> 00:34:04,080
that are built on top of our

00:34:00,480 --> 00:34:06,480
platform and we'll see later how how

00:34:04,080 --> 00:34:08,960
this was achieved

00:34:06,480 --> 00:34:10,079
yeah also reducing the number of

00:34:08,960 --> 00:34:12,800
changing jobs and

00:34:10,079 --> 00:34:16,320
deployment pipelines to make like

00:34:12,800 --> 00:34:16,320
operations easier is a good thing

00:34:16,879 --> 00:34:22,000
and of course uh academic in

00:34:19,839 --> 00:34:25,839
computational resources that

00:34:22,000 --> 00:34:29,919
uh that would be needed to run

00:34:25,839 --> 00:34:32,839
uh if we just

00:34:29,919 --> 00:34:35,520
started using the standard microservice

00:34:32,839 --> 00:34:39,040
approach

00:34:35,520 --> 00:34:42,639
so basically this is how uh our

00:34:39,040 --> 00:34:45,200
our platform uh looks like in a nutshell

00:34:42,639 --> 00:34:47,440
so there is this wherever this platform

00:34:45,200 --> 00:34:51,200
team ships to us

00:34:47,440 --> 00:34:53,679
is like a runtime bundle

00:34:51,200 --> 00:34:55,520
and basically it's going to include

00:34:53,679 --> 00:34:57,040
configuration service discovery service

00:34:55,520 --> 00:35:00,240
magic service login servers

00:34:57,040 --> 00:35:03,920
uh and all the common dependencies

00:35:00,240 --> 00:35:07,920
uh the libraries and also some of our

00:35:03,920 --> 00:35:09,680
own code that basically is needed to

00:35:07,920 --> 00:35:11,760
make all of this happen and then there

00:35:09,680 --> 00:35:13,280
are all those microservices which are

00:35:11,760 --> 00:35:17,839
going to have only

00:35:13,280 --> 00:35:20,560
uh their own code and uh

00:35:17,839 --> 00:35:21,839
it's only their own code and maybe some

00:35:20,560 --> 00:35:23,680
of the dependencies

00:35:21,839 --> 00:35:25,760
that they print which is part of the

00:35:23,680 --> 00:35:31,839
bundle

00:35:25,760 --> 00:35:31,839
so this is how we structure it

00:35:33,359 --> 00:35:39,599
so login configuration metrics discovery

00:35:36,960 --> 00:35:40,640
uh and some other services they're just

00:35:39,599 --> 00:35:45,119
exposed as

00:35:40,640 --> 00:35:45,119
uh through osgi registry and

00:35:45,599 --> 00:35:49,280
as services and the

00:35:49,520 --> 00:35:52,960
common dependencies uh are shared

00:35:52,560 --> 00:35:57,040
through

00:35:52,960 --> 00:35:57,040
export package and this is how

00:35:57,119 --> 00:36:02,560
like microservice bundles can use it um

00:36:02,720 --> 00:36:06,800
so runtime is activated by essentially

00:36:05,119 --> 00:36:08,800
anti-goose container with all those

00:36:06,800 --> 00:36:11,839
services and some of the services that

00:36:08,800 --> 00:36:13,040
that we built to to basically make this

00:36:11,839 --> 00:36:16,960
architecture

00:36:13,040 --> 00:36:18,480
work and then micro service is activated

00:36:16,960 --> 00:36:22,240
by

00:36:18,480 --> 00:36:26,720
pins in common uh uh

00:36:22,240 --> 00:36:29,200
usgi services from from registry uh

00:36:26,720 --> 00:36:30,480
and again instantiating a juice

00:36:29,200 --> 00:36:32,400
container

00:36:30,480 --> 00:36:34,720
uh and after that that's it the

00:36:32,400 --> 00:36:36,240
microservices started

00:36:34,720 --> 00:36:38,240
so some of the things that we had to

00:36:36,240 --> 00:36:40,160
build so uh

00:36:38,240 --> 00:36:41,599
because karaf gives you like so much

00:36:40,160 --> 00:36:45,680
freedom there are just so many

00:36:41,599 --> 00:36:48,079
ways that that you can structure uh

00:36:45,680 --> 00:36:49,520
similar like architectures we we just

00:36:48,079 --> 00:36:52,320
didn't find anything that

00:36:49,520 --> 00:36:55,200
which could work for us uh to package

00:36:52,320 --> 00:36:59,440
neither on time

00:36:55,200 --> 00:37:00,000
nor like this micro services out of the

00:36:59,440 --> 00:37:03,440
box

00:37:00,000 --> 00:37:08,000
so we just had to build some of them so

00:37:03,440 --> 00:37:11,839
for runtime we used uh

00:37:08,000 --> 00:37:14,400
like a huge osgi bundle which is

00:37:11,839 --> 00:37:15,280
uh basically a number jar of all the

00:37:14,400 --> 00:37:18,480
dependencies

00:37:15,280 --> 00:37:20,839
and uh it just exports uh common

00:37:18,480 --> 00:37:22,000
libraries that will be needed by

00:37:20,839 --> 00:37:23,760
microservices

00:37:22,000 --> 00:37:27,280
it also gets packaged together with

00:37:23,760 --> 00:37:27,280
carafe in a docker

00:37:27,440 --> 00:37:34,160
image with all the needed

00:37:30,480 --> 00:37:37,280
dependencies and this is going to be our

00:37:34,160 --> 00:37:39,760
base image which uh we're going to use

00:37:37,280 --> 00:37:41,839
later to deploy microservices too so

00:37:39,760 --> 00:37:44,079
microservices packaging

00:37:41,839 --> 00:37:47,040
will leverage bing tools and we will

00:37:44,079 --> 00:37:49,440
only package dependencies that are not

00:37:47,040 --> 00:37:51,119
supplied by runtime the other ones will

00:37:49,440 --> 00:37:53,359
be skipped

00:37:51,119 --> 00:37:54,240
uh and there is also a microservice

00:37:53,359 --> 00:37:57,440
lifecycle

00:37:54,240 --> 00:38:01,440
management tool that we uh have

00:37:57,440 --> 00:38:03,040
and basically uh it is responsible for

00:38:01,440 --> 00:38:04,880
extracting stock in microservices

00:38:03,040 --> 00:38:06,240
deploying them and

00:38:04,880 --> 00:38:09,200
are really in the back of the

00:38:06,240 --> 00:38:09,200
malfunction and

00:38:11,280 --> 00:38:15,520
yeah then pretty much these are its

00:38:13,599 --> 00:38:18,079
basic responsibilities so

00:38:15,520 --> 00:38:19,599
uh i think i'm gonna go like quickly

00:38:18,079 --> 00:38:20,320
through some achievements because we're

00:38:19,599 --> 00:38:23,920
running uh

00:38:20,320 --> 00:38:26,480
of time uh so we reduced infrastructure

00:38:23,920 --> 00:38:29,680
of course compared to like previously

00:38:26,480 --> 00:38:31,599
systems that we are running uh as a

00:38:29,680 --> 00:38:32,400
monolith by approximately like ninety

00:38:31,599 --> 00:38:34,880
percent

00:38:32,400 --> 00:38:36,560
uh it's easier operations due to less

00:38:34,880 --> 00:38:38,400
changes drop in deployment pipelines

00:38:36,560 --> 00:38:41,599
better dependency management

00:38:38,400 --> 00:38:43,680
uh faster deployments uh improved

00:38:41,599 --> 00:38:47,200
testability of the system

00:38:43,680 --> 00:38:49,839
uh i think it's just

00:38:47,200 --> 00:38:51,359
duplicated somehow so some problems like

00:38:49,839 --> 00:38:54,240
that we have to like

00:38:51,359 --> 00:38:56,240
uh still solve but one of them is like

00:38:54,240 --> 00:38:59,520
failure isolation because

00:38:56,240 --> 00:39:01,440
uh we're back to like

00:38:59,520 --> 00:39:03,359
being sort of kind of like a monolith

00:39:01,440 --> 00:39:04,480
where one microservice can just consume

00:39:03,359 --> 00:39:07,200
all the

00:39:04,480 --> 00:39:08,000
uh resources or consume of the memory

00:39:07,200 --> 00:39:10,560
and just

00:39:08,000 --> 00:39:12,720
kill gdm or use all the cpu or just

00:39:10,560 --> 00:39:16,000
iterate network interface

00:39:12,720 --> 00:39:19,359
uh and the other one is uh

00:39:16,000 --> 00:39:22,000
which is maybe less of a problem but

00:39:19,359 --> 00:39:22,640
uh immutable infrastructure is one of

00:39:22,000 --> 00:39:25,119
the like

00:39:22,640 --> 00:39:25,760
key paradigms of microservices as well

00:39:25,119 --> 00:39:29,200
like

00:39:25,760 --> 00:39:32,640
your once packaged or your

00:39:29,200 --> 00:39:35,680
your code cannot change anymore

00:39:32,640 --> 00:39:38,560
and you can just it's like a repeatable

00:39:35,680 --> 00:39:41,200
deployment for

00:39:38,560 --> 00:39:44,000
uh for a microservice or you can roll

00:39:41,200 --> 00:39:47,520
back to like the previous version easily

00:39:44,000 --> 00:39:50,320
but again as long as we can figure out a

00:39:47,520 --> 00:39:51,359
similar alternative uh we could do this

00:39:50,320 --> 00:39:54,400
or

00:39:51,359 --> 00:39:57,680
um very very

00:39:54,400 --> 00:39:58,000
like uh straightforward way to solve it

00:39:57,680 --> 00:40:01,520
is

00:39:58,000 --> 00:40:04,960
uh you just deploy each microservice

00:40:01,520 --> 00:40:08,000
uh into like a separate graph

00:40:04,960 --> 00:40:10,960
instance uh which also

00:40:08,000 --> 00:40:11,280
delivers you failed with your isolation

00:40:10,960 --> 00:40:14,480
and

00:40:11,280 --> 00:40:17,280
immutable infrastructure but uh

00:40:14,480 --> 00:40:19,200
if you basically it's going to be the

00:40:17,280 --> 00:40:22,240
same as sprint boot and if you do it

00:40:19,200 --> 00:40:24,800
basically for only production

00:40:22,240 --> 00:40:28,000
environments you will still finish it

00:40:24,800 --> 00:40:31,200
okay we're a little bit over of time

00:40:28,000 --> 00:40:31,200
this is the end for me

00:40:33,200 --> 00:40:39,839
i'm going to take questions that i see

00:40:42,319 --> 00:40:49,839
how you test your microservices in graph

00:40:46,160 --> 00:40:49,839
system integration tests

00:40:50,839 --> 00:40:56,960
so

00:40:53,760 --> 00:40:59,040
it's no it's testing is

00:40:56,960 --> 00:41:00,640
a bit complex because now there are two

00:40:59,040 --> 00:41:01,760
parts to it you just deploy your

00:41:00,640 --> 00:41:03,520
microservice

00:41:01,760 --> 00:41:05,680
and you also deploy this runtime those

00:41:03,520 --> 00:41:09,520
two deployments are

00:41:05,680 --> 00:41:11,839
separate so for runtime

00:41:09,520 --> 00:41:14,560
there is a step like before it goes to

00:41:11,839 --> 00:41:14,560
production which

00:41:14,640 --> 00:41:17,839
which basically takes all the

00:41:16,240 --> 00:41:22,880
microservices that we have

00:41:17,839 --> 00:41:26,079
and it tries to start them on a new uh

00:41:22,880 --> 00:41:27,200
version of runtime and then performs a

00:41:26,079 --> 00:41:30,800
health check

00:41:27,200 --> 00:41:34,640
and after that it can go

00:41:30,800 --> 00:41:38,480
to production for microservices

00:41:34,640 --> 00:41:42,079
there is like uh uh regular

00:41:38,480 --> 00:41:45,119
ci cd uh basically

00:41:42,079 --> 00:41:46,800
uh there are unit tests

00:41:45,119 --> 00:41:49,040
there's like a test environment there

00:41:46,800 --> 00:41:51,119
are unit tests

00:41:49,040 --> 00:41:54,400
which run every run and they run every

00:41:51,119 --> 00:41:54,400
time you build them and then

00:41:55,040 --> 00:41:58,800
there are basically integration tests

00:41:59,200 --> 00:42:03,760
and end-to-end tests that are run in the

00:42:01,520 --> 00:42:06,960
cloud

00:42:03,760 --> 00:42:10,640
and what we do is like

00:42:06,960 --> 00:42:13,520
specifically for this component that we

00:42:10,640 --> 00:42:15,839
uh use on graph we just we just create a

00:42:13,520 --> 00:42:17,359
separate stack and we just deployed

00:42:15,839 --> 00:42:18,960
all the services that you needed into

00:42:17,359 --> 00:42:22,000
this stack

00:42:18,960 --> 00:42:22,560
that's again also to have like isolation

00:42:22,000 --> 00:42:26,400
in

00:42:22,560 --> 00:42:28,480
messaging layer and in the database so

00:42:26,400 --> 00:42:30,160
you can guarantee that this specific

00:42:28,480 --> 00:42:32,960
project is going to be completed by this

00:42:30,160 --> 00:42:32,960
specific stack

00:42:33,119 --> 00:42:36,800
okay hope that answers the question

00:42:39,920 --> 00:42:45,839
how you resolve the external

00:42:41,359 --> 00:42:45,839
dependencies are not available

00:42:46,640 --> 00:42:53,599
as osg bundle uh so

00:42:50,160 --> 00:42:56,400
there's a gradle there is a

00:42:53,599 --> 00:42:57,280
gradle plugin which we developed for

00:42:56,400 --> 00:43:00,560
packaging

00:42:57,280 --> 00:43:03,520
and uh if

00:43:00,560 --> 00:43:04,480
those if so this plugin would look into

00:43:03,520 --> 00:43:07,359
runtime and see

00:43:04,480 --> 00:43:09,359
if those dependencies are present

00:43:07,359 --> 00:43:11,599
they're unexported and if not

00:43:09,359 --> 00:43:13,280
that's just going to package it those

00:43:11,599 --> 00:43:16,480
dependencies into

00:43:13,280 --> 00:43:16,480
the microservice bundle

00:43:19,200 --> 00:43:24,240
yeah exactly what whatever jb said

00:43:24,839 --> 00:43:27,839
uh

00:43:34,890 --> 00:43:39,599
[Music]

00:43:36,560 --> 00:43:40,000
yeah again runtime team is you can think

00:43:39,599 --> 00:43:42,480
about

00:43:40,000 --> 00:43:43,119
them as like uh somebody provides you

00:43:42,480 --> 00:43:46,560
like

00:43:43,119 --> 00:43:49,680
like sprint for instance nothing

00:43:46,560 --> 00:43:54,400
uh nothing different they give you

00:43:49,680 --> 00:43:57,839
spring boot and they operate those uh

00:43:54,400 --> 00:43:59,760
and they operate those uh global

00:43:57,839 --> 00:44:02,560
services like to register your

00:43:59,760 --> 00:44:02,560
microservice

00:44:04,640 --> 00:44:11,440
and provide you with all this

00:44:08,160 --> 00:44:12,160
infrastructure and then uh the rest is

00:44:11,440 --> 00:44:15,359
pretty much

00:44:12,160 --> 00:44:16,079
uh the rest is pretty much uh working

00:44:15,359 --> 00:44:19,359
the same way

00:44:16,079 --> 00:44:23,119
as uh as uh

00:44:19,359 --> 00:44:25,599
like he described so

00:44:23,119 --> 00:44:26,160
you design you develop your test you

00:44:25,599 --> 00:44:29,440
deploy

00:44:26,160 --> 00:44:31,680
you operate and you support it including

00:44:29,440 --> 00:44:37,839
answering all the questions to teams

00:44:31,680 --> 00:44:37,839
that are going to use your microservice

00:44:39,040 --> 00:44:46,880
yeah well 90 is like specific to our

00:44:42,480 --> 00:44:49,359
case uh might not be the same for

00:44:46,880 --> 00:44:50,960
like everyone but we figured out that

00:44:49,359 --> 00:44:54,079
we're using like a lot of

00:44:50,960 --> 00:44:55,599
uh a lot of computational

00:44:54,079 --> 00:44:57,200
resources for non-production

00:44:55,599 --> 00:45:00,560
environments and

00:44:57,200 --> 00:45:03,520
uh this is one thing and then probably

00:45:00,560 --> 00:45:04,000
there's a good chunk of savings that are

00:45:03,520 --> 00:45:07,599
coming

00:45:04,000 --> 00:45:10,000
from not running uh all those

00:45:07,599 --> 00:45:11,040
uh like common services for each and

00:45:10,000 --> 00:45:14,319
every

00:45:11,040 --> 00:45:16,000
micro service and not not trying gvm

00:45:14,319 --> 00:45:18,400
because every time you start gvm

00:45:16,000 --> 00:45:19,280
you're just saying uh this is the

00:45:18,400 --> 00:45:21,680
minimum

00:45:19,280 --> 00:45:22,560
memory that i'm going to need or you're

00:45:21,680 --> 00:45:25,440
going to

00:45:22,560 --> 00:45:26,560
just if you start like every java

00:45:25,440 --> 00:45:28,800
application

00:45:26,560 --> 00:45:30,480
you will basically right away start a

00:45:28,800 --> 00:45:33,680
bunch of threads that are going to

00:45:30,480 --> 00:45:34,880
to be uh trying to do like garbage

00:45:33,680 --> 00:45:37,359
collections and all their

00:45:34,880 --> 00:45:38,400
because they'll be stuff for and

00:45:37,359 --> 00:45:43,599
consuming

00:45:38,400 --> 00:45:43,599
cpu especially if you're on uh

00:45:44,000 --> 00:45:47,839
t1 uh garbage collector

00:45:48,160 --> 00:45:53,280
okay hope that answers all the questions

00:45:54,640 --> 00:45:58,560
if that's it then thanks everyone thanks

00:45:57,440 --> 00:46:02,160
timothy

00:45:58,560 --> 00:46:04,720
was great very

00:46:02,160 --> 00:46:06,000
i liked the analysis at the beginning

00:46:04,720 --> 00:46:08,720
because it's a

00:46:06,000 --> 00:46:10,480
clear state of the art so yeah that's a

00:46:08,720 --> 00:46:13,599
great session

00:46:10,480 --> 00:46:16,880
very interesting i hope you

00:46:13,599 --> 00:46:20,000
opened some some minds uh to the

00:46:16,880 --> 00:46:21,359
different use cases and uh and use of

00:46:20,000 --> 00:46:24,160
carafe

00:46:21,359 --> 00:46:24,800
and now we have at the end of the carafe

00:46:24,160 --> 00:46:28,240
track

00:46:24,800 --> 00:46:30,640
so it was a it was really great uh

00:46:28,240 --> 00:46:31,599
i think very well balanced talks a

00:46:30,640 --> 00:46:34,480
different

00:46:31,599 --> 00:46:36,160
perspective different standpoint and uh

00:46:34,480 --> 00:46:39,200
yeah

00:46:36,160 --> 00:46:42,720
again don't hesitate to jump on

00:46:39,200 --> 00:46:45,440
website mainly list um i'm gonna share

00:46:42,720 --> 00:46:48,480
my slides i guess but dimitri and other

00:46:45,440 --> 00:46:49,280
speakers will we'll share as well but

00:46:48,480 --> 00:46:51,760
yeah

00:46:49,280 --> 00:46:53,920
don't hesitate to ping us if you have

00:46:51,760 --> 00:46:57,440
any question or if you

00:46:53,920 --> 00:47:00,800
want to give a try to carafe and the new

00:46:57,440 --> 00:47:01,920
new features um the next couple of

00:47:00,800 --> 00:47:04,560
months will be a

00:47:01,920 --> 00:47:05,119
very strategic i think for for for the

00:47:04,560 --> 00:47:07,599
project

00:47:05,119 --> 00:47:08,480
and that we open to a new use cases

00:47:07,599 --> 00:47:10,880
again

00:47:08,480 --> 00:47:11,680
so yeah that's very exciting thanks a

00:47:10,880 --> 00:47:14,800
lot for

00:47:11,680 --> 00:47:18,640
all for your for attending and uh

00:47:14,800 --> 00:47:18,640
enjoy the rest of apache con

00:47:19,040 --> 00:47:25,839
see you guys cheers

00:47:39,680 --> 00:47:41,760

YouTube URL: https://www.youtube.com/watch?v=eVo1qcuZggY


