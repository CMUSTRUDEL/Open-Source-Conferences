Title: Will it blend? Java agents and OSGi
Publication date: 2020-10-16
Playlist: ApacheCon @Home 2020: Karaf
Description: 
	Will it blend? Java agents and OSGi
Robert Munteanu

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/


Java agents are a little-known but extremely powerful part of the Java ecosystem. Agents are able to transform existing classes at runtime, allowing scenarios such as logging and monitoring, hot reload or gathering code coverage. However, their usage presents a number of pitfalls as well. In this talk we will present the steps of writing a java agent from scratch, indicate various common mistakes and pain points and draw conclusions on best practices. Special care will be taken to discuss how running in an OSGi environment affects Java agents and how we can best approach integration testing in a modular environment. After this talk participants will have a better understanding of the Java instrumentation API, how it fits in with OSGi runtimes and about should / should not be done with it.

Working as a Senior Computer Scientist in the AEM Cloud Foundation team at Adobe, Robert Munteanu is a software developer with a passion for open source. He is a member of the Apache Software Foundation and frequent contributor to many open source projects, notably Apache Sling and Apache Jackrabbit. Robert is a frequent conference speaker, having spoken at Devoxx, ApacheCon and EclipseCon, amongst others.
Captions: 
	00:00:01,770 --> 00:00:06,490
[Music]

00:00:09,520 --> 00:00:12,590
[Music]

00:00:21,600 --> 00:00:24,960
so

00:00:22,240 --> 00:00:26,800
i guess it's time to start hello

00:00:24,960 --> 00:00:29,599
everybody thank you for joining

00:00:26,800 --> 00:00:30,640
my name is robert montano and i will

00:00:29,599 --> 00:00:33,520
talk to you about

00:00:30,640 --> 00:00:36,480
an unlikely combination of java agents

00:00:33,520 --> 00:00:36,480
and osgi

00:00:37,120 --> 00:00:41,520
click click

00:00:41,840 --> 00:00:45,280
to start off a few words about myself i

00:00:44,480 --> 00:00:48,800
am currently

00:00:45,280 --> 00:00:50,559
working for adobe in battle switzerland

00:00:48,800 --> 00:00:51,840
although i'm originally from bucharest

00:00:50,559 --> 00:00:54,160
romania

00:00:51,840 --> 00:00:55,440
i'm working on a product called adobe

00:00:54,160 --> 00:00:58,559
experience manager which

00:00:55,440 --> 00:01:01,440
is basically uh our

00:00:58,559 --> 00:01:02,079
content management system um that

00:01:01,440 --> 00:01:05,280
product

00:01:02,079 --> 00:01:07,760
has strong roots in projects hosted at

00:01:05,280 --> 00:01:09,680
the apache software foundation

00:01:07,760 --> 00:01:11,280
apache sling apache felix apache

00:01:09,680 --> 00:01:13,200
jackrabbit

00:01:11,280 --> 00:01:14,320
i'm currently serving as the pmc chair

00:01:13,200 --> 00:01:17,119
of apache slaying

00:01:14,320 --> 00:01:20,720
and i'm a committer for felix committer

00:01:17,119 --> 00:01:20,720
and pmc member for jackrabbit

00:01:21,200 --> 00:01:25,439
i'm also on twitter about that's

00:01:23,200 --> 00:01:28,560
something of less importance than

00:01:25,439 --> 00:01:31,280
i like to think so

00:01:28,560 --> 00:01:33,360
for today i will start off with a quick

00:01:31,280 --> 00:01:35,840
demo about java agents

00:01:33,360 --> 00:01:38,640
then we will progressively go deeper

00:01:35,840 --> 00:01:40,479
into the subject matter so that means

00:01:38,640 --> 00:01:41,920
talking about the fundamentals of java

00:01:40,479 --> 00:01:45,040
agents

00:01:41,920 --> 00:01:48,720
asking about the all important

00:01:45,040 --> 00:01:50,240
why think why do we want to use java

00:01:48,720 --> 00:01:52,720
agents

00:01:50,240 --> 00:01:55,439
i will be talking about osg integration

00:01:52,720 --> 00:01:58,799
and integration testing because that is

00:01:55,439 --> 00:02:01,119
a very interesting topic when it comes

00:01:58,799 --> 00:02:03,439
to java agents

00:02:01,119 --> 00:02:04,159
at the end i will do a more full-fledged

00:02:03,439 --> 00:02:07,520
demo

00:02:04,159 --> 00:02:10,640
just to show how how things work in

00:02:07,520 --> 00:02:10,640
more or less in real life

00:02:10,720 --> 00:02:17,120
so for the quick demo

00:02:14,560 --> 00:02:17,840
i have something prepared here which is

00:02:17,120 --> 00:02:21,680
a

00:02:17,840 --> 00:02:24,319
very very simple java application it's

00:02:21,680 --> 00:02:26,080
probably the thing which most of us have

00:02:24,319 --> 00:02:29,280
written for the first time

00:02:26,080 --> 00:02:31,599
a static void main uh with a system out

00:02:29,280 --> 00:02:34,319
print line

00:02:31,599 --> 00:02:34,959
now of course the expectation is that

00:02:34,319 --> 00:02:38,319
when you

00:02:34,959 --> 00:02:39,360
run such a such a class you will only

00:02:38,319 --> 00:02:43,440
get hello world

00:02:39,360 --> 00:02:43,440
printed on the console

00:02:46,959 --> 00:02:52,720
and surprisingly there's something more

00:02:49,599 --> 00:02:54,239
the world says hello back

00:02:52,720 --> 00:02:56,560
now because it's a talk about java

00:02:54,239 --> 00:02:58,080
agents you probably expected a bit of

00:02:56,560 --> 00:03:00,319
mischief for me

00:02:58,080 --> 00:03:00,319
so

00:03:03,200 --> 00:03:07,280
this is not going to be the most visible

00:03:05,280 --> 00:03:10,000
thing in the world but

00:03:07,280 --> 00:03:13,440
if you take a look at the vm arguments

00:03:10,000 --> 00:03:16,560
there is a java agent

00:03:13,440 --> 00:03:19,519
flag here which basically

00:03:16,560 --> 00:03:21,920
tells the jvm let me put this uh a bit

00:03:19,519 --> 00:03:21,920
larger

00:03:22,239 --> 00:03:25,760
basically tells the jva hey launch with

00:03:25,200 --> 00:03:27,760
this

00:03:25,760 --> 00:03:30,840
particular agent right so that's the

00:03:27,760 --> 00:03:33,040
kind of things we can expect for java

00:03:30,840 --> 00:03:36,799
agents

00:03:33,040 --> 00:03:37,599
so how do java agents actually work how

00:03:36,799 --> 00:03:40,959
do we start

00:03:37,599 --> 00:03:41,920
writing one so the answer is neatly put

00:03:40,959 --> 00:03:44,080
in the javadoc

00:03:41,920 --> 00:03:45,760
although maybe a bit opaque so the java

00:03:44,080 --> 00:03:47,680
lang instrument

00:03:45,760 --> 00:03:49,519
package has been there for some quite

00:03:47,680 --> 00:03:52,159
some time in java

00:03:49,519 --> 00:03:53,360
and it provides services that allow java

00:03:52,159 --> 00:03:55,760
programming language

00:03:53,360 --> 00:03:57,120
agents to instrument programs running on

00:03:55,760 --> 00:04:00,319
the jvm

00:03:57,120 --> 00:04:03,519
and right the agents are the things

00:04:00,319 --> 00:04:06,000
which we write which we implement and

00:04:03,519 --> 00:04:08,720
by instrumenting we basically mean

00:04:06,000 --> 00:04:11,760
rewriting the byte code

00:04:08,720 --> 00:04:13,040
we are still tied to the rules of the

00:04:11,760 --> 00:04:16,160
java virtual machine

00:04:13,040 --> 00:04:18,400
and the java programming language but

00:04:16,160 --> 00:04:19,440
other than that we can by rewriting

00:04:18,400 --> 00:04:22,560
bytecode

00:04:19,440 --> 00:04:24,639
we can basically do anything

00:04:22,560 --> 00:04:26,720
without touching the original source

00:04:24,639 --> 00:04:30,479
code or the jar files

00:04:26,720 --> 00:04:30,479
so on on the fly at runtime

00:04:30,800 --> 00:04:37,120
so i typically split these agents

00:04:34,400 --> 00:04:38,560
into i i call the first category static

00:04:37,120 --> 00:04:41,680
agents

00:04:38,560 --> 00:04:42,960
and these are the ones like the one you

00:04:41,680 --> 00:04:46,800
just saw earlier

00:04:42,960 --> 00:04:48,800
there is a flag that you give to your

00:04:46,800 --> 00:04:52,320
job application startup and that

00:04:48,800 --> 00:04:55,440
flag is a location on disk to a jar file

00:04:52,320 --> 00:04:58,639
and say hey launch my application

00:04:55,440 --> 00:05:00,320
but with this just java agent

00:04:58,639 --> 00:05:02,080
and you can have multiple agents if

00:05:00,320 --> 00:05:05,360
needed

00:05:02,080 --> 00:05:07,039
and then the runtime will inspect the

00:05:05,360 --> 00:05:09,039
manifest of that agent and

00:05:07,039 --> 00:05:11,039
is going to look for an entry called

00:05:09,039 --> 00:05:13,199
pre-bane class

00:05:11,039 --> 00:05:14,880
and that in turns points to a fully

00:05:13,199 --> 00:05:17,840
qualified class name

00:05:14,880 --> 00:05:17,840
which is an agent

00:05:18,320 --> 00:05:24,479
and that agent should in turn have a

00:05:22,000 --> 00:05:26,160
method called pre-main and no that's a

00:05:24,479 --> 00:05:29,759
subtle signal that comes

00:05:26,160 --> 00:05:33,120
before the main method so pre-main um

00:05:29,759 --> 00:05:35,680
we which takes a string argument so not

00:05:33,120 --> 00:05:37,280
a string array just a single string

00:05:35,680 --> 00:05:38,720
and that allows you to pass various

00:05:37,280 --> 00:05:42,800
command line arguments

00:05:38,720 --> 00:05:43,840
to to your agent and an instrumentation

00:05:42,800 --> 00:05:46,160
class

00:05:43,840 --> 00:05:48,639
now as you see here the instrumentation

00:05:46,160 --> 00:05:52,400
class is the entry point

00:05:48,639 --> 00:05:53,199
and this is what allows you to register

00:05:52,400 --> 00:05:56,720
various

00:05:53,199 --> 00:05:59,199
um transformers various classes

00:05:56,720 --> 00:06:02,560
sorry versus several implementations

00:05:59,199 --> 00:06:02,560
that will do the actual work

00:06:03,280 --> 00:06:07,520
on the other hand you can have dynamic

00:06:06,240 --> 00:06:11,360
agents

00:06:07,520 --> 00:06:14,800
dynamic agents do not force you

00:06:11,360 --> 00:06:17,840
to uh update the command line

00:06:14,800 --> 00:06:19,600
sorry the launch the launch command

00:06:17,840 --> 00:06:23,039
to your application you can do this

00:06:19,600 --> 00:06:25,280
dynamically once you have a running jvm

00:06:23,039 --> 00:06:27,039
and you know it's process identifier

00:06:25,280 --> 00:06:31,919
it's bid

00:06:27,039 --> 00:06:36,160
you can attach and then load an agent

00:06:31,919 --> 00:06:39,039
now this looks very nice and convenient

00:06:36,160 --> 00:06:40,080
but there are a couple of things to note

00:06:39,039 --> 00:06:43,840
first of all this

00:06:40,080 --> 00:06:47,120
is um sun

00:06:43,840 --> 00:06:49,280
oracle specific api the virtual machine

00:06:47,120 --> 00:06:51,840
it is not necessarily available

00:06:49,280 --> 00:06:51,840
everywhere

00:06:52,160 --> 00:06:59,120
second as of java 8 or 9

00:06:55,199 --> 00:07:01,280
you are no longer allowed to self attach

00:06:59,120 --> 00:07:02,960
agents to the java virtual machine so

00:07:01,280 --> 00:07:06,479
this

00:07:02,960 --> 00:07:08,080
vm process identifier cannot be the

00:07:06,479 --> 00:07:10,000
process identifier of the application

00:07:08,080 --> 00:07:12,000
running this code

00:07:10,000 --> 00:07:14,800
of course as with all interesting

00:07:12,000 --> 00:07:18,240
challenges there's a library

00:07:14,800 --> 00:07:20,400
who does that um but again it's

00:07:18,240 --> 00:07:23,599
something to keep in mind

00:07:20,400 --> 00:07:27,199
and this agent is still

00:07:23,599 --> 00:07:30,160
a file a path to a jar file on disk

00:07:27,199 --> 00:07:31,919
uh there is no fantasy network loading

00:07:30,160 --> 00:07:33,440
no abstraction playing into here it

00:07:31,919 --> 00:07:36,639
still has to be available

00:07:33,440 --> 00:07:38,400
on on the file system that is accessible

00:07:36,639 --> 00:07:40,800
to the currently running java virtual

00:07:38,400 --> 00:07:40,800
machine

00:07:42,000 --> 00:07:46,800
and there is also a requirement for a

00:07:44,560 --> 00:07:49,759
manifest entry called agent class

00:07:46,800 --> 00:07:52,400
this time that again points to a fully

00:07:49,759 --> 00:07:55,199
qualified class name

00:07:52,400 --> 00:07:55,840
and the agent class implementation will

00:07:55,199 --> 00:07:59,199
look

00:07:55,840 --> 00:08:02,960
a lot like the pre-main method it's

00:07:59,199 --> 00:08:05,759
called agent main but then

00:08:02,960 --> 00:08:07,280
it has the exact same signature takes a

00:08:05,759 --> 00:08:10,840
string argument

00:08:07,280 --> 00:08:13,199
and has this instrumentation entry point

00:08:10,840 --> 00:08:16,000
class

00:08:13,199 --> 00:08:17,039
now that we're over that i'd like to

00:08:16,000 --> 00:08:20,080
talk to you about

00:08:17,039 --> 00:08:22,560
the class file transformer which is the

00:08:20,080 --> 00:08:23,360
interface that you'll be implementing to

00:08:22,560 --> 00:08:27,759
write

00:08:23,360 --> 00:08:29,759
actual java agents

00:08:27,759 --> 00:08:31,199
and probably the first two things you

00:08:29,759 --> 00:08:34,320
will be looking at

00:08:31,199 --> 00:08:37,279
is the class file name

00:08:34,320 --> 00:08:39,200
because as a java agent you will have

00:08:37,279 --> 00:08:42,560
you'll probably not want to transform

00:08:39,200 --> 00:08:44,560
all the classes loaded by jpm by the jvm

00:08:42,560 --> 00:08:46,080
you'll have a set of classes that you

00:08:44,560 --> 00:08:49,120
will want to inspect

00:08:46,080 --> 00:08:51,360
and most often the criteria is the class

00:08:49,120 --> 00:08:51,360
name

00:08:51,440 --> 00:08:55,600
whether you want to look up for some

00:08:53,040 --> 00:08:58,080
plus name patterns or package names

00:08:55,600 --> 00:08:59,760
or even dynamically inspect the class

00:08:58,080 --> 00:09:02,560
definition to look for say

00:08:59,760 --> 00:09:04,000
annotations or common superclass the

00:09:02,560 --> 00:09:07,360
entry point is usually

00:09:04,000 --> 00:09:10,320
this class name and then

00:09:07,360 --> 00:09:10,959
you will have access to the class file

00:09:10,320 --> 00:09:14,320
buffer

00:09:10,959 --> 00:09:15,360
which is the byte code the current

00:09:14,320 --> 00:09:17,200
definition

00:09:15,360 --> 00:09:19,839
of the java class that is being

00:09:17,200 --> 00:09:19,839
transformed

00:09:20,480 --> 00:09:26,560
now being an osg talk i will not

00:09:23,920 --> 00:09:28,560
avoid talking about the class loader so

00:09:26,560 --> 00:09:29,920
the class loader is extremely important

00:09:28,560 --> 00:09:31,360
because it gives you the exact class

00:09:29,920 --> 00:09:35,040
loader that was used

00:09:31,360 --> 00:09:38,080
to load this class definition and

00:09:35,040 --> 00:09:40,640
when you load it as in as

00:09:38,080 --> 00:09:43,040
as you're in a structured class loader

00:09:40,640 --> 00:09:46,000
aware or multi-class loader environment

00:09:43,040 --> 00:09:46,959
you will not implicitly have access to

00:09:46,000 --> 00:09:50,240
all the

00:09:46,959 --> 00:09:51,839
classes for instance the super classes

00:09:50,240 --> 00:09:54,320
or various classes that you want to work

00:09:51,839 --> 00:09:56,720
with so you need to take this into

00:09:54,320 --> 00:09:56,720
account

00:09:58,160 --> 00:10:05,040
and further on

00:10:01,360 --> 00:10:07,279
i mentioned this byte argument the class

00:10:05,040 --> 00:10:10,320
file buffer

00:10:07,279 --> 00:10:12,640
and it turns out that

00:10:10,320 --> 00:10:13,600
this byte code follows some very

00:10:12,640 --> 00:10:16,160
specific rules

00:10:13,600 --> 00:10:19,600
um laid down in the java virtual machine

00:10:16,160 --> 00:10:23,440
machine specification

00:10:19,600 --> 00:10:25,839
it had it is composed of a number of

00:10:23,440 --> 00:10:28,880
bytecode instructions or operations uh

00:10:25,839 --> 00:10:31,760
there are around 200 defined at

00:10:28,880 --> 00:10:33,760
a given moment and is it's basically

00:10:31,760 --> 00:10:34,959
what you get if you inspect a compiled

00:10:33,760 --> 00:10:37,440
class while using

00:10:34,959 --> 00:10:39,600
for instance the java p command line

00:10:37,440 --> 00:10:44,240
tool

00:10:39,600 --> 00:10:46,000
so a very simple hello world program has

00:10:44,240 --> 00:10:47,839
basically compiles the following

00:10:46,000 --> 00:10:50,880
instructions so you have

00:10:47,839 --> 00:10:54,079
a get static op code

00:10:50,880 --> 00:10:56,240
which takes the argument number 16. now

00:10:54,079 --> 00:10:59,120
that argument goes back to the

00:10:56,240 --> 00:11:00,880
class java constant pool definition for

00:10:59,120 --> 00:11:02,720
that class so there is

00:11:00,880 --> 00:11:04,720
something of a header which defines all

00:11:02,720 --> 00:11:10,240
the constants available

00:11:04,720 --> 00:11:14,640
and java has helpfully listed

00:11:10,240 --> 00:11:17,040
that number 16 points to system out

00:11:14,640 --> 00:11:18,800
right and then you load an argument on

00:11:17,040 --> 00:11:22,399
the stack

00:11:18,800 --> 00:11:25,360
that is the string hello world um

00:11:22,399 --> 00:11:27,519
it's constant number 22 and then you

00:11:25,360 --> 00:11:31,040
call the invoke virtual method which

00:11:27,519 --> 00:11:34,320
surprisingly involves a virtual method

00:11:31,040 --> 00:11:38,079
number 24 in the constant pool as

00:11:34,320 --> 00:11:38,720
print stream print line taking a string

00:11:38,079 --> 00:11:42,560
argument

00:11:38,720 --> 00:11:46,720
and returning a void method

00:11:42,560 --> 00:11:49,839
now the reason for my showing of this is

00:11:46,720 --> 00:11:54,160
to give you a sense of the kind of work

00:11:49,839 --> 00:11:55,680
that's writing bytecode involves

00:11:54,160 --> 00:11:57,839
now you may be the kind of person that

00:11:55,680 --> 00:11:59,680
says hey i'll take this as a challenge

00:11:57,839 --> 00:12:02,480
and hammer something out during the

00:11:59,680 --> 00:12:06,000
weekend or a couple of evenings

00:12:02,480 --> 00:12:08,880
but it quickly turns from fun

00:12:06,000 --> 00:12:11,279
into a chore there are obviously a

00:12:08,880 --> 00:12:13,200
number of libraries that handle this

00:12:11,279 --> 00:12:16,240
kind of work for you

00:12:13,200 --> 00:12:19,839
and i strongly recom advise that you

00:12:16,240 --> 00:12:21,600
you pick one of them i will not

00:12:19,839 --> 00:12:24,160
recommend something there

00:12:21,600 --> 00:12:25,040
are these are listed in alphabetical

00:12:24,160 --> 00:12:28,079
order following

00:12:25,040 --> 00:12:29,519
a quick web search you will obviously

00:12:28,079 --> 00:12:31,680
need to make a decision based on

00:12:29,519 --> 00:12:35,040
licensing committee size

00:12:31,680 --> 00:12:38,079
feature set high level versus low level

00:12:35,040 --> 00:12:41,120
support etc now for my

00:12:38,079 --> 00:12:44,560
work i i chose to use javasist which

00:12:41,120 --> 00:12:48,880
will struck a good compromise for me

00:12:44,560 --> 00:12:53,200
and this is a very basic implementation

00:12:48,880 --> 00:12:55,440
of a java agent

00:12:53,200 --> 00:12:57,120
of a classified transformer using job

00:12:55,440 --> 00:12:58,560
assist

00:12:57,120 --> 00:13:00,320
so first of all the entry point is

00:12:58,560 --> 00:13:03,519
something called a class pool

00:13:00,320 --> 00:13:05,680
that is the java agent object that

00:13:03,519 --> 00:13:07,279
gives you access to all the class

00:13:05,680 --> 00:13:10,800
definition

00:13:07,279 --> 00:13:14,000
and then you say hey i this

00:13:10,800 --> 00:13:16,639
descriptor to java name

00:13:14,000 --> 00:13:18,320
transforms the class name that the

00:13:16,639 --> 00:13:19,200
instrumentation api gives you into

00:13:18,320 --> 00:13:21,519
something

00:13:19,200 --> 00:13:23,120
which javasis can work with and then you

00:13:21,519 --> 00:13:25,200
ask for a method

00:13:23,120 --> 00:13:27,600
for this class name give me the main

00:13:25,200 --> 00:13:27,600
method

00:13:27,680 --> 00:13:31,760
and then javasci is nice enough to give

00:13:29,519 --> 00:13:33,680
you a method that says

00:13:31,760 --> 00:13:35,120
insert this code at the end of the

00:13:33,680 --> 00:13:37,839
method

00:13:35,120 --> 00:13:38,800
yeah and here you can see how nice it is

00:13:37,839 --> 00:13:41,680
to write

00:13:38,800 --> 00:13:44,079
java code in strings by hand but it

00:13:41,680 --> 00:13:44,079
works

00:13:44,160 --> 00:13:51,680
to wrap up we say we take the class and

00:13:48,320 --> 00:13:55,199
generate the new byte code clean up

00:13:51,680 --> 00:13:57,760
and then inside the transfer method

00:13:55,199 --> 00:14:00,560
we have the option of returning a byte

00:13:57,760 --> 00:14:03,600
array which is the new byte code

00:14:00,560 --> 00:14:05,920
we can also return null but in

00:14:03,600 --> 00:14:07,600
and in that case the instrumentation

00:14:05,920 --> 00:14:10,800
framework will know that we do not want

00:14:07,600 --> 00:14:10,800
to transform that class

00:14:11,839 --> 00:14:19,199
so but back to the important questions

00:14:15,519 --> 00:14:21,519
when would we want to use java agents so

00:14:19,199 --> 00:14:23,440
these are some rules of the thumb that i

00:14:21,519 --> 00:14:26,399
use for for writing java agents

00:14:23,440 --> 00:14:28,160
and the first one is it has to be code

00:14:26,399 --> 00:14:31,600
that i do not control

00:14:28,160 --> 00:14:34,079
or that you do not control

00:14:31,600 --> 00:14:34,800
in my opinion it doesn't make a lot of

00:14:34,079 --> 00:14:38,320
sense

00:14:34,800 --> 00:14:41,600
to write a java agent which is

00:14:38,320 --> 00:14:45,360
a more difficult task for code

00:14:41,600 --> 00:14:48,560
that you can alter if

00:14:45,360 --> 00:14:51,680
i mean you can just change it right

00:14:48,560 --> 00:14:53,760
um then

00:14:51,680 --> 00:14:55,519
you should ask yourself do i have some

00:14:53,760 --> 00:14:58,079
platform facilities

00:14:55,519 --> 00:14:59,199
now if you're working with let's say the

00:14:58,079 --> 00:15:02,800
servlet api

00:14:59,199 --> 00:15:03,120
there are tons of filters and listeners

00:15:02,800 --> 00:15:07,600
and

00:15:03,120 --> 00:15:11,040
whatnot osgi has a rich

00:15:07,600 --> 00:15:14,480
service layer of dependency injection

00:15:11,040 --> 00:15:17,920
and eventing and whatever do we actually

00:15:14,480 --> 00:15:21,519
have a better platform facility to use

00:15:17,920 --> 00:15:21,519
instead of writing a java agent

00:15:21,920 --> 00:15:25,040
and then i said usually these need to be

00:15:23,760 --> 00:15:29,839
cross-cutting concerns

00:15:25,040 --> 00:15:33,600
so touching code in multiple areas

00:15:29,839 --> 00:15:38,720
pardon that is not that easy to

00:15:33,600 --> 00:15:38,720
patch out or alter in creative ways

00:15:38,800 --> 00:15:42,560
if it's just one or two classes if you

00:15:41,120 --> 00:15:44,880
have the source code available

00:15:42,560 --> 00:15:46,240
it's usually much easier to just fork

00:15:44,880 --> 00:15:48,320
the code

00:15:46,240 --> 00:15:50,560
deploy it somewhere where it is

00:15:48,320 --> 00:15:54,000
accessible to you as a jar file

00:15:50,560 --> 00:15:57,040
and then replace it or we can get to

00:15:54,000 --> 00:16:00,560
creative class paths tricks embedding

00:15:57,040 --> 00:16:04,000
you know just i would personally avoid

00:16:00,560 --> 00:16:08,720
writing agents or using agents um for

00:16:04,000 --> 00:16:11,920
modifying one or two classes

00:16:08,720 --> 00:16:13,519
that being said some real-life examples

00:16:11,920 --> 00:16:15,519
where i've seen an agent use are for

00:16:13,519 --> 00:16:17,199
instance monitoring

00:16:15,519 --> 00:16:20,240
there are a number of services that say

00:16:17,199 --> 00:16:22,240
hey i will gather all the

00:16:20,240 --> 00:16:23,759
uncaught exceptions in your application

00:16:22,240 --> 00:16:24,959
ship them to my system

00:16:23,759 --> 00:16:27,839
and then i will give you a nice

00:16:24,959 --> 00:16:27,839
dashboard with it

00:16:28,160 --> 00:16:34,240
or um i will gather performance data

00:16:31,199 --> 00:16:34,240
from your application

00:16:34,959 --> 00:16:39,120
and that is usually in these kinds of

00:16:38,240 --> 00:16:42,160
applications

00:16:39,120 --> 00:16:45,920
look for the less least invasive way

00:16:42,160 --> 00:16:48,160
of being included and for java that is a

00:16:45,920 --> 00:16:50,880
java agent

00:16:48,160 --> 00:16:52,560
it allows them to rewrite more or less

00:16:50,880 --> 00:16:55,040
your application to add their

00:16:52,560 --> 00:16:58,399
instrumentation various points without

00:16:55,040 --> 00:16:58,399
you needing to touch anything

00:16:58,720 --> 00:17:02,839
profiling is another interesting area

00:17:01,440 --> 00:17:06,079
because it allows

00:17:02,839 --> 00:17:08,160
um a profiler to attach to

00:17:06,079 --> 00:17:09,839
an application at runtime using the

00:17:08,160 --> 00:17:12,799
dynamic

00:17:09,839 --> 00:17:13,839
agent approach and to instrument various

00:17:12,799 --> 00:17:16,959
methods

00:17:13,839 --> 00:17:20,480
insert a before and after and

00:17:16,959 --> 00:17:23,839
ship that profiling data somewhere it is

00:17:20,480 --> 00:17:23,839
simple and non-invasive

00:17:24,640 --> 00:17:30,080
debugging is a sort of a mix scenario

00:17:28,480 --> 00:17:32,559
here i

00:17:30,080 --> 00:17:34,080
on one hand i firmly believe that you

00:17:32,559 --> 00:17:36,960
should not be making

00:17:34,080 --> 00:17:38,720
code changes in production uncontrolled

00:17:36,960 --> 00:17:41,520
code changes in production

00:17:38,720 --> 00:17:42,880
uh like editing jsps or something like

00:17:41,520 --> 00:17:44,240
that

00:17:42,880 --> 00:17:46,080
on the other hand there are scenarios

00:17:44,240 --> 00:17:49,200
where you might say

00:17:46,080 --> 00:17:52,799
hey the my application

00:17:49,200 --> 00:17:55,440
is in a pretty bad state

00:17:52,799 --> 00:17:56,559
i cannot recover more information from

00:17:55,440 --> 00:17:58,799
it

00:17:56,559 --> 00:18:00,640
i did not insert the right logging

00:17:58,799 --> 00:18:02,320
statements or my metrics are not

00:18:00,640 --> 00:18:04,480
collecting anymore

00:18:02,320 --> 00:18:06,720
what do i do if i restart i will never

00:18:04,480 --> 00:18:09,520
know what happened

00:18:06,720 --> 00:18:11,280
so this is where a java agent can help

00:18:09,520 --> 00:18:13,840
you attach a java agent

00:18:11,280 --> 00:18:15,520
you insert some debugging some log

00:18:13,840 --> 00:18:19,440
statements

00:18:15,520 --> 00:18:22,160
extract the data that you need and then

00:18:19,440 --> 00:18:22,640
just restart the application or reset it

00:18:22,160 --> 00:18:26,320
to a

00:18:22,640 --> 00:18:28,559
good state mocking libraries

00:18:26,320 --> 00:18:29,600
is also something that can be used to

00:18:28,559 --> 00:18:34,400
circumvent

00:18:29,600 --> 00:18:36,559
uh the the way um

00:18:34,400 --> 00:18:38,480
the java virtual machine works right

00:18:36,559 --> 00:18:39,360
there are mocking static methods or

00:18:38,480 --> 00:18:43,840
final methods

00:18:39,360 --> 00:18:46,240
is something that is

00:18:43,840 --> 00:18:47,760
is much better achieved by using a java

00:18:46,240 --> 00:18:51,919
agent

00:18:47,760 --> 00:18:54,799
and at the end code reloader hot swapper

00:18:51,919 --> 00:18:56,640
products and open source projects that

00:18:54,799 --> 00:18:59,039
allow you to reload

00:18:56,640 --> 00:19:00,400
the code they deploy an instrument

00:18:59,039 --> 00:19:03,120
version of the class

00:19:00,400 --> 00:19:05,760
and when they detect a change on disk

00:19:03,120 --> 00:19:07,919
they reload the class with the

00:19:05,760 --> 00:19:09,520
the new byte code but on the other hand

00:19:07,919 --> 00:19:12,960
we have osj for that so

00:19:09,520 --> 00:19:12,960
that's less of a concern

00:19:14,000 --> 00:19:19,360
talking about osgi now

00:19:17,120 --> 00:19:21,440
of course one of the the first tough

00:19:19,360 --> 00:19:24,320
lessons when getting osgi

00:19:21,440 --> 00:19:26,320
is that there isn't a flat class path

00:19:24,320 --> 00:19:28,799
and that we need to be mindful of class

00:19:26,320 --> 00:19:28,799
loaders

00:19:28,880 --> 00:19:36,000
so this is part of an actual patch uh

00:19:32,160 --> 00:19:39,679
an actual commit that i made to uh to

00:19:36,000 --> 00:19:42,880
to a java agent making it work

00:19:39,679 --> 00:19:43,760
from like from plain default

00:19:42,880 --> 00:19:47,120
applications

00:19:43,760 --> 00:19:48,480
to osg applications as opposed to

00:19:47,120 --> 00:19:51,840
getting a default

00:19:48,480 --> 00:19:54,240
class pool which is has a very narrow

00:19:51,840 --> 00:19:57,280
definition for javasis

00:19:54,240 --> 00:19:58,080
we create a class path that with the

00:19:57,280 --> 00:20:00,320
true argu

00:19:58,080 --> 00:20:01,280
surya class pool uh with the default

00:20:00,320 --> 00:20:04,240
argument which says

00:20:01,280 --> 00:20:04,240
it inherits

00:20:04,320 --> 00:20:10,480
the the default the system class path

00:20:07,520 --> 00:20:11,919
and then we take a loader class path

00:20:10,480 --> 00:20:14,480
which construct

00:20:11,919 --> 00:20:15,280
inserts all the classes that are

00:20:14,480 --> 00:20:17,440
available

00:20:15,280 --> 00:20:19,520
in the class loader passed to us by the

00:20:17,440 --> 00:20:22,159
instrumentation api

00:20:19,520 --> 00:20:23,760
and finally a byte array class path

00:20:22,159 --> 00:20:26,000
which represents the class we're

00:20:23,760 --> 00:20:30,400
currently transforming

00:20:26,000 --> 00:20:30,400
and then things start working on in osgi

00:20:31,760 --> 00:20:35,919
another interesting point that is made

00:20:34,640 --> 00:20:39,679
due to the modular

00:20:35,919 --> 00:20:42,960
nature of oh applications is that

00:20:39,679 --> 00:20:44,400
if you rewrite a class such as that it

00:20:42,960 --> 00:20:47,280
depends

00:20:44,400 --> 00:20:48,080
on a package that is not currently

00:20:47,280 --> 00:20:51,679
imported

00:20:48,080 --> 00:20:53,760
by the bundle it will fail spectacularly

00:20:51,679 --> 00:20:55,919
at runtime

00:20:53,760 --> 00:20:57,919
so there are a couple of ways around

00:20:55,919 --> 00:21:00,240
that

00:20:57,919 --> 00:21:04,559
you can process so you can take the

00:21:00,240 --> 00:21:04,559
bundle object and alter it at runtime

00:21:04,640 --> 00:21:08,159
you can even for your hands and ear give

00:21:06,559 --> 00:21:10,400
up and say this bundle

00:21:08,159 --> 00:21:11,600
dynamically imports all packages which

00:21:10,400 --> 00:21:15,440
is

00:21:11,600 --> 00:21:19,039
well a bad idea but

00:21:15,440 --> 00:21:21,200
the key point here is that it's not as

00:21:19,039 --> 00:21:22,240
quite as simple to add new dependencies

00:21:21,200 --> 00:21:26,240
to

00:21:22,240 --> 00:21:26,240
to a class when you're running in an osg

00:21:28,840 --> 00:21:32,960
environment

00:21:31,120 --> 00:21:34,960
and well as i was talking about better

00:21:32,960 --> 00:21:37,520
platform alternatives

00:21:34,960 --> 00:21:38,799
turns out osgi does have a better

00:21:37,520 --> 00:21:42,840
alternative

00:21:38,799 --> 00:21:44,000
which is a weaving hook or the weaving

00:21:42,840 --> 00:21:46,799
hooks

00:21:44,000 --> 00:21:48,720
and it's much easier to deploy it's an

00:21:46,799 --> 00:21:51,520
osj bundle so

00:21:48,720 --> 00:21:52,880
you and it's ready you just create a

00:21:51,520 --> 00:21:56,240
service and register it

00:21:52,880 --> 00:21:58,640
via the osj whiteboard and you don't

00:21:56,240 --> 00:22:02,559
have to mess with command line arguments

00:21:58,640 --> 00:22:05,600
or trying to dynamically attach

00:22:02,559 --> 00:22:07,280
an agent you deploy your provisioner or

00:22:05,600 --> 00:22:08,960
your application in exactly the same way

00:22:07,280 --> 00:22:10,880
as before just that you include an extra

00:22:08,960 --> 00:22:14,799
bundle

00:22:10,880 --> 00:22:17,440
and it has no sorry

00:22:14,799 --> 00:22:19,039
it has weights to dynamically update the

00:22:17,440 --> 00:22:22,799
bundle imports

00:22:19,039 --> 00:22:26,159
so it seems to tick all the check boxes

00:22:22,799 --> 00:22:28,960
with the drawback that it's an osi

00:22:26,159 --> 00:22:30,400
only solution and well i say it's a

00:22:28,960 --> 00:22:33,520
drawback

00:22:30,400 --> 00:22:35,520
because getting a bit ahead of myself um

00:22:33,520 --> 00:22:36,559
this time one of the major challenges

00:22:35,520 --> 00:22:40,640
with

00:22:36,559 --> 00:22:43,679
java agents is testing so

00:22:40,640 --> 00:22:46,400
that means you will have

00:22:43,679 --> 00:22:47,840
besides your regular testing harnesses

00:22:46,400 --> 00:22:50,799
you will have to have

00:22:47,840 --> 00:22:51,840
osgi specific testing harnesses as well

00:22:50,799 --> 00:22:53,760
and

00:22:51,840 --> 00:22:57,919
it's a situation where you need to ask

00:22:53,760 --> 00:23:00,880
yourself do i want to support

00:22:57,919 --> 00:23:02,480
only osg applications do i want to use

00:23:00,880 --> 00:23:04,400
regular launchers so

00:23:02,480 --> 00:23:07,039
via the java agent flags or do i want to

00:23:04,400 --> 00:23:07,039
support both

00:23:07,200 --> 00:23:10,960
and if you have the resources to support

00:23:09,280 --> 00:23:14,080
both that's fine

00:23:10,960 --> 00:23:15,280
if not a potentially pragmatic approach

00:23:14,080 --> 00:23:18,559
is to say

00:23:15,280 --> 00:23:19,200
i will only support the command line

00:23:18,559 --> 00:23:21,200
launch

00:23:19,200 --> 00:23:22,880
or the dynamic java agent launch because

00:23:21,200 --> 00:23:26,080
it works with osgi

00:23:22,880 --> 00:23:26,080
applications anyway

00:23:27,440 --> 00:23:31,840
keeping that in mind this is a

00:23:29,919 --> 00:23:34,080
simplified implementation of a weaving

00:23:31,840 --> 00:23:34,080
hook

00:23:34,320 --> 00:23:37,600
if you take a look at the body of the

00:23:35,840 --> 00:23:40,720
implementation it is

00:23:37,600 --> 00:23:42,720
basically the same as the

00:23:40,720 --> 00:23:45,919
the regular java agent implementation it

00:23:42,720 --> 00:23:49,760
still relies on a class pool

00:23:45,919 --> 00:23:54,559
and on the javasys class and method

00:23:49,760 --> 00:23:54,559
objects and we insert some code before

00:23:54,720 --> 00:24:01,120
the major difference is that we get

00:23:58,000 --> 00:24:02,080
passed in a woven class parameter which

00:24:01,120 --> 00:24:05,440
has a set

00:24:02,080 --> 00:24:07,840
bytes method um and

00:24:05,440 --> 00:24:09,120
that this woven class object allows us

00:24:07,840 --> 00:24:10,960
to

00:24:09,120 --> 00:24:12,799
access the bundle the bundle and by

00:24:10,960 --> 00:24:16,159
extension the class loader

00:24:12,799 --> 00:24:17,279
and it has it's just in my opinion a

00:24:16,159 --> 00:24:19,840
nicer api

00:24:17,279 --> 00:24:23,039
and of course it has all the benefits of

00:24:19,840 --> 00:24:23,039
osgi integration

00:24:23,919 --> 00:24:31,760
now talking about integration testing

00:24:28,159 --> 00:24:35,600
i am very much used and enjoy writing

00:24:31,760 --> 00:24:39,520
simple unit tests that run quickly

00:24:35,600 --> 00:24:42,240
fail fast can be debugged etc

00:24:39,520 --> 00:24:42,640
on the other hand java agents they have

00:24:42,240 --> 00:24:44,840
they

00:24:42,640 --> 00:24:46,720
you cannot run them as plain java

00:24:44,840 --> 00:24:49,039
classes

00:24:46,720 --> 00:24:51,919
this they must be packages jar files and

00:24:49,039 --> 00:24:53,919
they have requirements in the manifest

00:24:51,919 --> 00:24:55,520
it's not trivial to attach them to the

00:24:53,919 --> 00:24:58,960
current process

00:24:55,520 --> 00:25:01,760
and even if it would be

00:24:58,960 --> 00:25:03,360
it is quite complicated to support

00:25:01,760 --> 00:25:07,200
rolling back

00:25:03,360 --> 00:25:09,120
changes that the java agent has done

00:25:07,200 --> 00:25:11,120
it's going to be either memory or

00:25:09,120 --> 00:25:14,240
compute intensive

00:25:11,120 --> 00:25:15,200
probably memory intensive and it's

00:25:14,240 --> 00:25:17,840
something that

00:25:15,200 --> 00:25:20,400
you probably do not want to pollute

00:25:17,840 --> 00:25:23,919
production code with

00:25:20,400 --> 00:25:27,760
so usually end up with a

00:25:23,919 --> 00:25:31,200
test launcher that launches the java

00:25:27,760 --> 00:25:35,279
as external processes so i

00:25:31,200 --> 00:25:39,120
i call these unit tests with air quotes

00:25:35,279 --> 00:25:43,360
because i they can be made to test

00:25:39,120 --> 00:25:47,679
a single thing transformer

00:25:43,360 --> 00:25:49,520
but these are more heavyweights so you

00:25:47,679 --> 00:25:50,960
the approach is basically to launch a

00:25:49,520 --> 00:25:53,760
java process

00:25:50,960 --> 00:25:54,400
that has a custom agent attached and

00:25:53,760 --> 00:25:57,279
then you

00:25:54,400 --> 00:25:59,440
need to ask yourself okay so how do i

00:25:57,279 --> 00:26:02,159
communicate with the java agent how do i

00:25:59,440 --> 00:26:05,200
know that it actually worked

00:26:02,159 --> 00:26:07,360
and additionally there is no out of the

00:26:05,200 --> 00:26:10,559
box support for code coverage and

00:26:07,360 --> 00:26:14,000
other tools that you might be using in

00:26:10,559 --> 00:26:14,000
your regular build life cycle

00:26:14,400 --> 00:26:18,720
now i ended up with a simple and

00:26:17,200 --> 00:26:23,120
simplistic solution that

00:26:18,720 --> 00:26:25,120
ends up working quite well so

00:26:23,120 --> 00:26:27,919
and this is a sketch first of all we

00:26:25,120 --> 00:26:30,400
need to find the java executable

00:26:27,919 --> 00:26:32,720
and looking for the java.home property

00:26:30,400 --> 00:26:35,360
usually works

00:26:32,720 --> 00:26:36,960
because it's the same jvm as the one

00:26:35,360 --> 00:26:40,320
launching the test

00:26:36,960 --> 00:26:41,279
and it allows you to launch the asian

00:26:40,320 --> 00:26:44,480
test with more

00:26:41,279 --> 00:26:47,279
multiple java versions just by giving

00:26:44,480 --> 00:26:50,480
them a different java home

00:26:47,279 --> 00:26:52,240
then we need to find the agent jar and

00:26:50,480 --> 00:26:54,080
usually if you're running maven that's

00:26:52,240 --> 00:26:56,640
usually somewhere below the target

00:26:54,080 --> 00:27:00,559
directory and with a jar extension

00:26:56,640 --> 00:27:01,840
and follows the search naming convention

00:27:00,559 --> 00:27:03,520
and that you need to build the class

00:27:01,840 --> 00:27:05,600
path if there are any external

00:27:03,520 --> 00:27:08,960
dependencies for your tests

00:27:05,600 --> 00:27:11,840
not necessarily for your agent and

00:27:08,960 --> 00:27:12,799
i'll take a little step back and mention

00:27:11,840 --> 00:27:15,760
that

00:27:12,799 --> 00:27:18,240
java agents do not have access to the

00:27:15,760 --> 00:27:20,080
application class path

00:27:18,240 --> 00:27:23,279
so they should have all their

00:27:20,080 --> 00:27:25,840
dependencies bundled in

00:27:23,279 --> 00:27:26,399
right so we now build the testing class

00:27:25,840 --> 00:27:28,880
path

00:27:26,399 --> 00:27:30,159
and use the regular java apis to build a

00:27:28,880 --> 00:27:33,200
new process

00:27:30,159 --> 00:27:34,000
give it this java agent argument and

00:27:33,200 --> 00:27:36,880
then it's basically

00:27:34,000 --> 00:27:38,159
java there's java agent followed by the

00:27:36,880 --> 00:27:40,960
class path

00:27:38,159 --> 00:27:41,360
and now a test application that is used

00:27:40,960 --> 00:27:44,399
to

00:27:41,360 --> 00:27:44,399
to run the tests

00:27:45,679 --> 00:27:49,679
and now uh the simplest thing that i

00:27:48,559 --> 00:27:53,279
found

00:27:49,679 --> 00:27:56,880
to work is to lock some things

00:27:53,279 --> 00:28:00,320
on standard out in the test application

00:27:56,880 --> 00:28:00,880
uh throw a stack trace if things don't

00:28:00,320 --> 00:28:04,080
go wrong

00:28:00,880 --> 00:28:06,960
and set an exit code to something

00:28:04,080 --> 00:28:06,960
other than zero

00:28:08,240 --> 00:28:11,360
code coverage is actually surprisingly

00:28:10,640 --> 00:28:14,559
simple

00:28:11,360 --> 00:28:15,919
as long as we have the code coverage

00:28:14,559 --> 00:28:19,360
agent whether the

00:28:15,919 --> 00:28:20,080
jacoko jar or something else we can just

00:28:19,360 --> 00:28:23,440
pass it

00:28:20,080 --> 00:28:26,399
to our test harness but

00:28:23,440 --> 00:28:27,600
before our java agent otherwise

00:28:26,399 --> 00:28:30,240
obviously would not

00:28:27,600 --> 00:28:33,760
instrument our java agent so code

00:28:30,240 --> 00:28:33,760
coverage data will not be useful

00:28:35,120 --> 00:28:39,600
obviously we have a nice setup for

00:28:38,080 --> 00:28:42,960
testing with osgi

00:28:39,600 --> 00:28:44,000
with pax exam so we use the same java

00:28:42,960 --> 00:28:47,120
agent option

00:28:44,000 --> 00:28:49,360
and we give it our agent jar

00:28:47,120 --> 00:28:52,960
and then we need to do the work of

00:28:49,360 --> 00:28:54,640
asserting that the agent actually works

00:28:52,960 --> 00:28:56,720
and of course it must run in a fourth

00:28:54,640 --> 00:28:59,039
container otherwise the jvm

00:28:56,720 --> 00:28:59,760
and these vm options sorry that these vm

00:28:59,039 --> 00:29:03,360
options

00:28:59,760 --> 00:29:03,360
will not apply to the jv app

00:29:04,159 --> 00:29:11,039
okay it's time to get into the

00:29:07,600 --> 00:29:11,039
a bit more involved demo

00:29:11,679 --> 00:29:20,080
so make this just a bit smaller

00:29:16,000 --> 00:29:23,520
so this is how the simple agent

00:29:20,080 --> 00:29:23,520
that i demoed before works

00:29:25,279 --> 00:29:31,600
there is a class to transform

00:29:28,559 --> 00:29:33,200
that i am checking and if this

00:29:31,600 --> 00:29:36,000
is not the class i want to transfer and

00:29:33,200 --> 00:29:36,000
just return null

00:29:37,200 --> 00:29:43,919
and these are the javasyst apis

00:29:40,720 --> 00:29:46,000
i get a class pool i get a hold of a

00:29:43,919 --> 00:29:49,520
main method

00:29:46,000 --> 00:29:49,520
and then insert some code

00:29:50,880 --> 00:29:57,440
as for the weaving hook the weaving hook

00:29:54,399 --> 00:30:00,080
is let me turn on word wrap

00:29:57,440 --> 00:30:02,480
i think it makes things slightly more

00:30:00,080 --> 00:30:02,480
readable

00:30:02,799 --> 00:30:06,960
these are the classical objects that i'm

00:30:04,799 --> 00:30:10,960
constructing using this woven clasp

00:30:06,960 --> 00:30:14,399
so using the class definition

00:30:10,960 --> 00:30:14,399
and the bundles class loader

00:30:16,080 --> 00:30:23,679
and in the end i set

00:30:19,279 --> 00:30:27,039
the transform byte code

00:30:23,679 --> 00:30:29,760
now the actual agent that

00:30:27,039 --> 00:30:30,320
motivated this talk is an agent that

00:30:29,760 --> 00:30:33,279
helps

00:30:30,320 --> 00:30:34,559
forgetful developers in case they make

00:30:33,279 --> 00:30:38,240
network calls

00:30:34,559 --> 00:30:40,720
and they forget to set timeouts

00:30:38,240 --> 00:30:42,480
which when when it's not needed it's

00:30:40,720 --> 00:30:42,799
okay but when it's needed and it's not

00:30:42,480 --> 00:30:45,919
there

00:30:42,799 --> 00:30:49,279
it's disastrous so

00:30:45,919 --> 00:30:51,679
what this agent does is

00:30:49,279 --> 00:30:52,559
reads some command line arguments so

00:30:51,679 --> 00:30:55,840
this is done

00:30:52,559 --> 00:30:58,080
as manual as it gets uh because there

00:30:55,840 --> 00:30:59,039
are really no external libraries backed

00:30:58,080 --> 00:31:02,640
in

00:30:59,039 --> 00:31:04,559
uh backed in the agent so we support

00:31:02,640 --> 00:31:07,679
setting both a connect

00:31:04,559 --> 00:31:07,679
and the read timeout

00:31:08,880 --> 00:31:12,000
and then we have a set of transformers

00:31:11,600 --> 00:31:17,279
now

00:31:12,000 --> 00:31:20,159
out of care of not setting

00:31:17,279 --> 00:31:20,640
timeouts on socket connections directly

00:31:20,159 --> 00:31:23,760
and

00:31:20,640 --> 00:31:24,720
just overreaching their implementations

00:31:23,760 --> 00:31:26,799
for

00:31:24,720 --> 00:31:29,440
a number of libraries starting from the

00:31:26,799 --> 00:31:32,640
default java.net

00:31:29,440 --> 00:31:36,000
uh http client library and also for a

00:31:32,640 --> 00:31:36,000
couple of other libraries

00:31:36,080 --> 00:31:43,679
so by

00:31:39,200 --> 00:31:43,679
so these are the classes that we support

00:31:44,000 --> 00:31:51,519
sunnet dubbed dub etc the http

00:31:47,519 --> 00:31:52,320
and the https variant and luckily they

00:31:51,519 --> 00:31:55,760
have

00:31:52,320 --> 00:31:59,840
this both have this connect method

00:31:55,760 --> 00:32:02,240
where i can insert this check

00:31:59,840 --> 00:32:04,080
if the configure connect timeout is zero

00:32:02,240 --> 00:32:07,039
so wait indefinitely

00:32:04,080 --> 00:32:09,600
then i will set the connect timeout to

00:32:07,039 --> 00:32:12,960
whatever it has been configured

00:32:09,600 --> 00:32:15,200
and the same goes for re-timeout

00:32:12,960 --> 00:32:17,840
or there are other a bit more

00:32:15,200 --> 00:32:21,919
interesting

00:32:17,840 --> 00:32:24,000
ones such as when you want to

00:32:21,919 --> 00:32:25,840
when you have a factory method like we

00:32:24,000 --> 00:32:29,600
do for the http clan 3

00:32:25,840 --> 00:32:32,799
which create param has great params and

00:32:29,600 --> 00:32:33,840
works on an object and returns it you do

00:32:32,799 --> 00:32:37,039
not know the name

00:32:33,840 --> 00:32:38,559
of that parameter all right so javasis

00:32:37,039 --> 00:32:42,640
just has this nice

00:32:38,559 --> 00:32:45,919
baller underscore method that says

00:32:42,640 --> 00:32:49,039
info that it will be resolved as the

00:32:45,919 --> 00:32:52,640
object which is going to be returned

00:32:49,039 --> 00:32:52,640
from from the method

00:32:53,760 --> 00:32:59,519
and we actually wrote a a test

00:32:56,880 --> 00:32:59,519
application

00:33:00,080 --> 00:33:05,840
that is not rocket science it basically

00:33:03,440 --> 00:33:09,039
supports each of the launchers

00:33:05,840 --> 00:33:11,840
and accepts a

00:33:09,039 --> 00:33:11,840
url

00:33:13,039 --> 00:33:16,880
and tries to connect to it using various

00:33:15,519 --> 00:33:21,919
libraries

00:33:16,880 --> 00:33:21,919
and this is how it works

00:33:23,440 --> 00:33:27,200
so this is java dash java agent i

00:33:26,240 --> 00:33:27,679
probably should definitely need that

00:33:27,200 --> 00:33:31,120
jump

00:33:27,679 --> 00:33:33,760
jar to something shorter and then you

00:33:31,120 --> 00:33:34,320
you see here the equals after the name

00:33:33,760 --> 00:33:37,679
as

00:33:34,320 --> 00:33:41,039
how we pass commentary arguments

00:33:37,679 --> 00:33:42,960
the first argument is the connect

00:33:41,039 --> 00:33:43,440
timeout in milliseconds and the second

00:33:42,960 --> 00:33:46,720
one

00:33:43,440 --> 00:33:50,480
is the read time of the milliseconds

00:33:46,720 --> 00:33:54,640
classbot arguments class name and here

00:33:50,480 --> 00:33:59,840
we are using hc4 which means

00:33:54,640 --> 00:33:59,840
http clan4 now let me edit that briefly

00:34:01,840 --> 00:34:09,519
and give it no actual timeouts

00:34:05,519 --> 00:34:09,519
well sorry just one second timeout so

00:34:10,399 --> 00:34:17,679
it loaded the url just fine

00:34:14,000 --> 00:34:21,200
now if i give it

00:34:17,679 --> 00:34:22,879
a connect timeout of one millisecond so

00:34:21,200 --> 00:34:24,720
again this is an argument to the java

00:34:22,879 --> 00:34:26,399
agent it's not interpreted by the

00:34:24,720 --> 00:34:28,320
application the application never sees

00:34:26,399 --> 00:34:31,679
this

00:34:28,320 --> 00:34:35,839
it will fail immediately think that it

00:34:31,679 --> 00:34:35,839
cannot connect to this host

00:34:38,399 --> 00:34:45,119
let's reset it and in a similar manner

00:34:42,079 --> 00:34:47,359
if i tell it to set the read timeout it

00:34:45,119 --> 00:34:50,480
gives me a read timeout

00:34:47,359 --> 00:34:52,079
and this works if you do if you use

00:34:50,480 --> 00:34:53,679
other libraries you'll see it's a

00:34:52,079 --> 00:34:57,040
different stack trace

00:34:53,679 --> 00:35:00,640
but still the same connect timeout

00:34:57,040 --> 00:35:03,839
now i think i have about

00:35:00,640 --> 00:35:03,839
five minutes left so

00:35:04,079 --> 00:35:08,320
these i will leave this resources slide

00:35:06,720 --> 00:35:10,480
for a couple of resources

00:35:08,320 --> 00:35:11,520
um so the java instrumentation entry

00:35:10,480 --> 00:35:14,880
point

00:35:11,520 --> 00:35:15,599
java assists the bytecode generation

00:35:14,880 --> 00:35:17,839
library

00:35:15,599 --> 00:35:19,119
and this link connection timeout agent

00:35:17,839 --> 00:35:22,880
which is

00:35:19,119 --> 00:35:25,119
other thing i've demoed at the end and

00:35:22,880 --> 00:35:31,839
if there are any questions i am happy to

00:35:25,119 --> 00:35:31,839
take them now

00:35:40,480 --> 00:35:44,560
so i'm looking at the fn chad uh thank

00:35:42,720 --> 00:35:46,800
you i'm not sure if there

00:35:44,560 --> 00:35:48,880
uh probably aren't any question or maybe

00:35:46,800 --> 00:35:51,359
someone is typing i will wait for just a

00:35:48,880 --> 00:35:51,359
bit more

00:35:56,160 --> 00:36:01,280
okay so uh i guess no questions

00:35:59,200 --> 00:36:02,800
thank you for very much for your time

00:36:01,280 --> 00:36:04,079
yeah feel free to reach out to me if you

00:36:02,800 --> 00:36:06,720
have any questions

00:36:04,079 --> 00:36:08,400
uh either through the conference chat or

00:36:06,720 --> 00:36:10,839
um

00:36:08,400 --> 00:36:12,000
twitter or email uh these are easily

00:36:10,839 --> 00:36:27,839
accessible

00:36:12,000 --> 00:36:27,839
thank you very much

00:36:34,079 --> 00:36:36,160

YouTube URL: https://www.youtube.com/watch?v=2aOJE95qK4E


