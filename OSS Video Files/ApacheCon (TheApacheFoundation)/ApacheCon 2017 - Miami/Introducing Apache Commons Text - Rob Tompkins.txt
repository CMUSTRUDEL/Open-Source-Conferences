Title: Introducing Apache Commons Text - Rob Tompkins
Publication date: 2017-05-17
Playlist: ApacheCon 2017 - Miami
Description: 
	Introducing Apache Commons Text - Rob Tompkins

The Apache Commons Project has a new component, Commons Text. We will go over what this new component provides.

About Rob Tompkins
I am a Java developer who also practices a considerable amount of dev-ops primarily using AWS. Furthermore, I am a member of the Apache Commons project.
Captions: 
	00:00:00,000 --> 00:00:05,520
thank you um so I'm Rob Tompkins I'm

00:00:03,149 --> 00:00:07,470
from Richmond Virginia I probably should

00:00:05,520 --> 00:00:12,679
go to my who is this guy slide but I

00:00:07,470 --> 00:00:16,920
changed it a little bit so who I am I am

00:00:12,679 --> 00:00:18,750
shitake which is an artifact of my

00:00:16,920 --> 00:00:21,119
Virginia Tech email address the first

00:00:18,750 --> 00:00:23,609
two of my first name and the first six

00:00:21,119 --> 00:00:25,560
of my last name so my first names

00:00:23,609 --> 00:00:28,890
actually Christopher if you're trying to

00:00:25,560 --> 00:00:32,250
find me um I'm a committer on Apache

00:00:28,890 --> 00:00:36,270
Commons on the release manager for

00:00:32,250 --> 00:00:36,870
Commons text um and I do software

00:00:36,270 --> 00:00:40,320
development

00:00:36,870 --> 00:00:42,390
I do Java and DevOps I tend to end up in

00:00:40,320 --> 00:00:44,910
the DevOps space because I end up doing

00:00:42,390 --> 00:00:47,820
the work that nobody wants to do and it

00:00:44,910 --> 00:00:49,200
gets the stuff out the door and I

00:00:47,820 --> 00:00:51,180
figured I just put that I'm a

00:00:49,200 --> 00:00:54,750
mathematician and a logician on here

00:00:51,180 --> 00:00:58,590
maybe I I did that in school so why not

00:00:54,750 --> 00:01:00,719
um oh and pardon the minimal slide

00:00:58,590 --> 00:01:02,309
design I kind of like minimal slide

00:01:00,719 --> 00:01:03,510
designs but if that puts you guys to

00:01:02,309 --> 00:01:04,920
sleep it wouldn't be the first time that

00:01:03,510 --> 00:01:06,799
people fell asleep while I was talking

00:01:04,920 --> 00:01:10,290
um

00:01:06,799 --> 00:01:12,210
so introducing comments text I've got

00:01:10,290 --> 00:01:17,340
two goals here for what we want to do

00:01:12,210 --> 00:01:20,340
with Commons text um let me see

00:01:17,340 --> 00:01:23,689
is this the gold slide yeah this is the

00:01:20,340 --> 00:01:29,360
gold slide the goals are to introduce a

00:01:23,689 --> 00:01:32,070
standardized set of text processing

00:01:29,360 --> 00:01:36,990
algorithms and libraries for reuse

00:01:32,070 --> 00:01:43,950
across Apache um projects the big goal

00:01:36,990 --> 00:01:46,979
here is reuse so it's kind of open-ended

00:01:43,950 --> 00:01:48,540
on how complex our algorithms get and

00:01:46,979 --> 00:01:50,189
whether or not we get into natural

00:01:48,540 --> 00:01:53,640
language processing and stuff like that

00:01:50,189 --> 00:01:55,290
because we have a top-level project that

00:01:53,640 --> 00:02:00,750
is natural language processing namely

00:01:55,290 --> 00:02:03,680
open NLP um in the second goal this kind

00:02:00,750 --> 00:02:06,920
of pulls me into the second goal and

00:02:03,680 --> 00:02:10,349
that's to remove some of the heavier

00:02:06,920 --> 00:02:11,370
text ear sort of things from common

00:02:10,349 --> 00:02:17,900
slang

00:02:11,370 --> 00:02:22,349
so that um Commons Lang stays to being a

00:02:17,900 --> 00:02:26,069
relatively all-inclusive but minimally

00:02:22,349 --> 00:02:29,670
all-inclusive library for any Java

00:02:26,069 --> 00:02:33,959
developer right so we want to give them

00:02:29,670 --> 00:02:38,160
a very very solid set of tools that

00:02:33,959 --> 00:02:44,280
doesn't include the kitchen sink and you

00:02:38,160 --> 00:02:46,170
know a couple of sports cars so what's

00:02:44,280 --> 00:02:49,349
the history of Commons texts um in

00:02:46,170 --> 00:02:56,220
October of 2014

00:02:49,349 --> 00:03:00,900
um I think Bruno brought to the dev list

00:02:56,220 --> 00:03:07,530
an appetite for including the Levenstein

00:03:00,900 --> 00:03:10,470
edit distance in Commons lang and if you

00:03:07,530 --> 00:03:13,910
go out there and look it's under lang

00:03:10,470 --> 00:03:19,470
591 I think that's the the JIRA issue um

00:03:13,910 --> 00:03:22,590
and I think the community decided that

00:03:19,470 --> 00:03:25,790
was too complex for Commons lang it

00:03:22,590 --> 00:03:28,019
doesn't really fit into that um you know

00:03:25,790 --> 00:03:31,620
space where it's going to be arbitrarily

00:03:28,019 --> 00:03:36,540
useful for any Java developer um and so

00:03:31,620 --> 00:03:38,970
Bruno and Benedict um put together a

00:03:36,540 --> 00:03:44,340
proposal to create a sandbox component

00:03:38,970 --> 00:03:48,299
and did substantive development over two

00:03:44,340 --> 00:03:51,660
years um to where I kind of jumped in

00:03:48,299 --> 00:03:54,510
last fall and I was fortunate enough to

00:03:51,660 --> 00:03:57,150
have a really solid code base to work

00:03:54,510 --> 00:03:57,359
from because these guys did so much good

00:03:57,150 --> 00:04:00,329
work

00:03:57,359 --> 00:04:03,959
and so I I kind of picked up right where

00:04:00,329 --> 00:04:09,030
they left off and by March of this year

00:04:03,959 --> 00:04:09,660
we had our 1.0 so um what's the current

00:04:09,030 --> 00:04:13,500
layout

00:04:09,660 --> 00:04:15,900
well fortunate if you guys are familiar

00:04:13,500 --> 00:04:20,130
with lang a lot of the code bases from

00:04:15,900 --> 00:04:22,729
lang so um if you've seen that before

00:04:20,130 --> 00:04:24,600
pardon but we'll do a little bit of

00:04:22,729 --> 00:04:27,060
looking at that so

00:04:24,600 --> 00:04:32,040
the currently what the pardon the

00:04:27,060 --> 00:04:35,900
current layout for text is things that

00:04:32,040 --> 00:04:39,000
are text here then string utils um

00:04:35,900 --> 00:04:42,720
specifically the stuff from the text

00:04:39,000 --> 00:04:45,960
package and Lang in hopes of deprecating

00:04:42,720 --> 00:04:50,640
that stuff and altogether removing it in

00:04:45,960 --> 00:04:53,430
the 4.0 version of Lang um so string

00:04:50,640 --> 00:04:55,800
builder formattable utils on string

00:04:53,430 --> 00:04:57,390
substitute or string tokenizer these are

00:04:55,800 --> 00:05:00,300
all things that we've included in the

00:04:57,390 --> 00:05:02,670
code base along with some extra stuff so

00:05:00,300 --> 00:05:05,790
we've got some difficuit illa T's that

00:05:02,670 --> 00:05:10,370
are under a dispatch we've got some

00:05:05,790 --> 00:05:14,010
string similarity and edit distance arm

00:05:10,370 --> 00:05:15,960
utilities now that that that brings me

00:05:14,010 --> 00:05:18,830
to the distinction between what a

00:05:15,960 --> 00:05:23,310
similarity and an edit distance is a

00:05:18,830 --> 00:05:27,870
similarity is kind of a number that

00:05:23,310 --> 00:05:30,690
indicates whether two strings are the

00:05:27,870 --> 00:05:34,590
same or not right but it doesn't conform

00:05:30,690 --> 00:05:38,820
to the mathematical definition of a

00:05:34,590 --> 00:05:41,640
distance meaning that the if you have

00:05:38,820 --> 00:05:44,240
three points on a plane that they either

00:05:41,640 --> 00:05:46,530
form a triangle or a straight line um

00:05:44,240 --> 00:05:48,750
it's called the triangle inequality if

00:05:46,530 --> 00:05:50,730
you guys are familiar with that um if

00:05:48,750 --> 00:05:53,820
you're not you're welcome to look it up

00:05:50,730 --> 00:05:56,250
it's a it would be interesting if you

00:05:53,820 --> 00:05:59,070
could set it up so that one of the legs

00:05:56,250 --> 00:06:03,120
of the triangle was longer than two of

00:05:59,070 --> 00:06:05,250
the other sides it do something like

00:06:03,120 --> 00:06:07,500
that the addition of the two of the

00:06:05,250 --> 00:06:11,220
other sides it wouldn't be a triangle

00:06:07,500 --> 00:06:12,980
then anyway um and we've got some

00:06:11,220 --> 00:06:20,400
translation stuff specifically for

00:06:12,980 --> 00:06:23,580
escaping um all types of text files XML

00:06:20,400 --> 00:06:25,440
CSD JSON Java there's a bunch of

00:06:23,580 --> 00:06:29,060
different escape utilities that we have

00:06:25,440 --> 00:06:31,500
um and the translation package supports

00:06:29,060 --> 00:06:34,680
something that's at the top level

00:06:31,500 --> 00:06:37,420
package of text that does string

00:06:34,680 --> 00:06:39,670
escaping so

00:06:37,420 --> 00:06:43,860
let's look at the code that we brought

00:06:39,670 --> 00:06:47,230
over from Lang arm so string builder

00:06:43,860 --> 00:06:50,850
string builder is an alternative or STR

00:06:47,230 --> 00:06:54,120
builder excuse me is an alternative to

00:06:50,850 --> 00:06:58,650
java.lang string builder which arm

00:06:54,120 --> 00:07:03,490
provides our veterans this methods it

00:06:58,650 --> 00:07:06,850
because it's offering more mutability at

00:07:03,490 --> 00:07:12,160
the string level it loses its thread

00:07:06,850 --> 00:07:16,360
safety so um it's worth knowing that but

00:07:12,160 --> 00:07:19,870
it does afford you a lot more subtle

00:07:16,360 --> 00:07:22,050
mechanics around building a string and

00:07:19,870 --> 00:07:33,910
so let's look at some examples here um

00:07:22,050 --> 00:07:38,160
so we're building it up with the string

00:07:33,910 --> 00:07:41,250
test and we can read from a readable as

00:07:38,160 --> 00:07:44,080
well as append and all the standard

00:07:41,250 --> 00:07:49,150
string builder methods that you would

00:07:44,080 --> 00:07:53,920
find arm pardon the reuse of the

00:07:49,150 --> 00:07:57,520
variable here but we can new up another

00:07:53,920 --> 00:08:01,150
one and replace all the B's in this

00:07:57,520 --> 00:08:07,390
string with a different string um we can

00:08:01,150 --> 00:08:10,240
replace beginning from with this string

00:08:07,390 --> 00:08:12,550
and have the string continue at the

00:08:10,240 --> 00:08:15,490
index of one so we have a bunch of

00:08:12,550 --> 00:08:19,420
different options that string builder

00:08:15,490 --> 00:08:25,060
doesn't necessarily afford us with this

00:08:19,420 --> 00:08:28,060
one um formattable utils this affords

00:08:25,060 --> 00:08:30,430
you the ability to do justification and

00:08:28,060 --> 00:08:31,930
things like that so if i've got a string

00:08:30,430 --> 00:08:34,750
and i want to left justify at or right

00:08:31,930 --> 00:08:36,310
justify it and specify what characters i

00:08:34,750 --> 00:08:42,400
want to use in the justification

00:08:36,310 --> 00:08:45,370
paradigm um i can do that it provides

00:08:42,400 --> 00:08:51,250
control over the formatter

00:08:45,370 --> 00:08:53,500
and it gives us that control over wow we

00:08:51,250 --> 00:08:59,020
want to pad the string on either side

00:08:53,500 --> 00:09:03,220
and such so um if we look at this we

00:08:59,020 --> 00:09:06,190
have a string food that we want to left

00:09:03,220 --> 00:09:09,060
justify and we want it to be six long

00:09:06,190 --> 00:09:12,790
and we don't want to have a maximum

00:09:09,060 --> 00:09:14,260
amount here so let's go through the I've

00:09:12,790 --> 00:09:21,460
got it written down what the signature

00:09:14,260 --> 00:09:23,980
is on this so we've got the car sequence

00:09:21,460 --> 00:09:26,140
that we want to justify our char

00:09:23,980 --> 00:09:28,900
sequence the formatter that we're going

00:09:26,140 --> 00:09:31,180
to use to format it so we can pass

00:09:28,900 --> 00:09:32,770
around the formatter if we want on the

00:09:31,180 --> 00:09:36,760
type of justification that we want to do

00:09:32,770 --> 00:09:40,360
the minimal length of the output string

00:09:36,760 --> 00:09:43,330
the desired maximum of the output string

00:09:40,360 --> 00:09:45,310
and the character with which we want to

00:09:43,330 --> 00:09:47,770
Pat it um if you pass in negative one

00:09:45,310 --> 00:09:51,370
obviously or maybe not obviously but

00:09:47,770 --> 00:09:55,270
that accommodates arbitrary maximum in

00:09:51,370 --> 00:09:58,180
size okay so the output of this would be

00:09:55,270 --> 00:10:00,850
foo star star star and the output of

00:09:58,180 --> 00:10:04,060
this one would be foo and because we

00:10:00,850 --> 00:10:07,020
didn't I thought I remember that comma

00:10:04,060 --> 00:10:10,720
shouldn't be there pardon that comma

00:10:07,020 --> 00:10:14,590
clearly that would not compile um if you

00:10:10,720 --> 00:10:17,440
don't pass in a character with which to

00:10:14,590 --> 00:10:22,860
use as your padding character um you

00:10:17,440 --> 00:10:24,940
just get spaces so the next one arm

00:10:22,860 --> 00:10:27,160
Benedick will actually talk about later

00:10:24,940 --> 00:10:31,230
but I changed my example so that we

00:10:27,160 --> 00:10:36,210
don't use the same example um is

00:10:31,230 --> 00:10:40,960
essentially a templating engine okay and

00:10:36,210 --> 00:10:46,410
um it essentially accommodates you using

00:10:40,960 --> 00:10:49,300
dollar sign squiggly braces and a map to

00:10:46,410 --> 00:10:53,020
do variable replacement in a string

00:10:49,300 --> 00:10:55,720
which is um convenient uh at my day job

00:10:53,020 --> 00:10:58,480
we use this for doing content

00:10:55,720 --> 00:11:04,839
replacement in the in the you

00:10:58,480 --> 00:11:11,320
I actually so let's look at this so if

00:11:04,839 --> 00:11:17,620
we've got our dollar sign variables okay

00:11:11,320 --> 00:11:21,660
in a string and we have a values map

00:11:17,620 --> 00:11:24,910
that we pass in during the instantiation

00:11:21,660 --> 00:11:26,920
then when we do the replacement the

00:11:24,910 --> 00:11:29,920
left-hand side or the keys on the map

00:11:26,920 --> 00:11:36,399
will get replaced with the right-hand

00:11:29,920 --> 00:11:38,639
side here and our output will become and

00:11:36,399 --> 00:11:45,699
yet again another typographic error I

00:11:38,639 --> 00:11:47,620
left out the period being being a

00:11:45,699 --> 00:11:58,720
presentation on text typographic errors

00:11:47,620 --> 00:12:02,920
feel really really bad um so you can

00:11:58,720 --> 00:12:05,250
also use on some arbitrary maps in the

00:12:02,920 --> 00:12:07,779
instantiation of this you can use the

00:12:05,250 --> 00:12:10,050
operating system map and different

00:12:07,779 --> 00:12:15,959
things like that for population of it um

00:12:10,050 --> 00:12:21,389
and I believe that you can use different

00:12:15,959 --> 00:12:27,069
variable sin taxes syntheses sin taxes

00:12:21,389 --> 00:12:32,680
um but for the sake of simplicity of

00:12:27,069 --> 00:12:37,470
examples we stuck with this one arm the

00:12:32,680 --> 00:12:41,019
string tokenizer is a generalization on

00:12:37,470 --> 00:12:45,399
comma separated value parsing so it

00:12:41,019 --> 00:12:49,360
accommodates um the limiters and quote

00:12:45,399 --> 00:12:53,860
characters and um even ignored

00:12:49,360 --> 00:12:56,620
characters um it's similar to string

00:12:53,860 --> 00:12:59,740
tokenizer with a with more flexibility

00:12:56,620 --> 00:13:02,260
we've implemented the list iterator

00:12:59,740 --> 00:13:07,420
interface um so let's look at our

00:13:02,260 --> 00:13:11,510
example on that one so our goal is to

00:13:07,420 --> 00:13:13,760
parse this string right

00:13:11,510 --> 00:13:16,130
using semicolon as a delimiter with on

00:13:13,760 --> 00:13:19,580
the quote character being the standard

00:13:16,130 --> 00:13:23,240
quote arm this is taken directly from

00:13:19,580 --> 00:13:26,600
our unit tests actually simplified it a

00:13:23,240 --> 00:13:29,900
little bit but um one would expect

00:13:26,600 --> 00:13:35,210
because we have quotes around the value

00:13:29,900 --> 00:13:42,020
here that we would get that as our

00:13:35,210 --> 00:13:45,440
delimited value obviously and set

00:13:42,020 --> 00:13:50,900
ignored matter in this case says that if

00:13:45,440 --> 00:13:53,780
I'm dealing with a space character that

00:13:50,900 --> 00:13:56,000
I want to trim that down and have it be

00:13:53,780 --> 00:13:59,840
represented as the empty string coming

00:13:56,000 --> 00:14:04,400
out so our output array ends up being

00:13:59,840 --> 00:14:06,620
and ignore empty tokens that simply says

00:14:04,400 --> 00:14:08,480
that if I have the empty string as a

00:14:06,620 --> 00:14:11,570
value in the array I want it to remain

00:14:08,480 --> 00:14:15,170
in the array and so we end up with what

00:14:11,570 --> 00:14:19,820
we would expect out of that which is a b

00:14:15,170 --> 00:14:27,920
c d semicolon e f and then three empty

00:14:19,820 --> 00:14:29,480
strings and again I'm real good at

00:14:27,920 --> 00:14:31,970
typographic errors if you guys didn't

00:14:29,480 --> 00:14:34,130
notice this is this is one of the

00:14:31,970 --> 00:14:36,260
benefits of open source work is that

00:14:34,130 --> 00:14:38,360
there's generally another set of eyes on

00:14:36,260 --> 00:14:40,070
what you're working on and so you're

00:14:38,360 --> 00:14:45,980
less likely to get typographic errors

00:14:40,070 --> 00:14:50,570
like this um exactly exactly

00:14:45,980 --> 00:14:51,920
and this isn't action well this is an

00:14:50,570 --> 00:14:54,800
open source project you guys are welcome

00:14:51,920 --> 00:14:59,030
the the project itself or the slide deck

00:14:54,800 --> 00:15:05,000
is actually on on the web so if you guys

00:14:59,030 --> 00:15:08,050
want to see that it's come on go back to

00:15:05,000 --> 00:15:09,950
the beginning it's actually at this URL

00:15:08,050 --> 00:15:13,000
so if you guys want to follow along

00:15:09,950 --> 00:15:19,750
you're welcome to follow along there um

00:15:13,000 --> 00:15:19,750
you can also find it under cheat on key

00:15:20,300 --> 00:15:26,250
we did formattable we did substitute er

00:15:22,860 --> 00:15:28,770
we did tokenizer and string escape utils

00:15:26,250 --> 00:15:30,300
so this is that whole translation bit

00:15:28,770 --> 00:15:34,890
that I was talking about that package

00:15:30,300 --> 00:15:39,810
dedicated to translation um getting to

00:15:34,890 --> 00:15:45,890
and from different escapes um is what

00:15:39,810 --> 00:15:49,260
we're going for here and so we can do

00:15:45,890 --> 00:15:51,540
JSON escaping where you know our single

00:15:49,260 --> 00:15:52,920
quote character needs to nest needs to

00:15:51,540 --> 00:15:58,020
be escaped because single quotes are

00:15:52,920 --> 00:16:02,520
used in JSON and they don't represent

00:15:58,020 --> 00:16:05,640
valid values in Java strings or um in

00:16:02,520 --> 00:16:08,100
this case we can do Java escaping where

00:16:05,640 --> 00:16:13,050
we need you know extra back slashes on

00:16:08,100 --> 00:16:18,600
each backslash um it's worth noting that

00:16:13,050 --> 00:16:26,720
uh there was said to be a vulnerability

00:16:18,600 --> 00:16:31,890
in the ECMA escape routine in that if

00:16:26,720 --> 00:16:41,420
you include the ECMA escaped text in

00:16:31,890 --> 00:16:48,030
HTML it may render the HTML invalid but

00:16:41,420 --> 00:16:51,330
that's in line in HTML and um if people

00:16:48,030 --> 00:16:55,490
are needing that level of security they

00:16:51,330 --> 00:16:59,340
might need to go to a library that um

00:16:55,490 --> 00:17:00,300
specifically works in the security space

00:16:59,340 --> 00:17:03,600
um

00:17:00,300 --> 00:17:06,300
the Javadoc actually points over to one

00:17:03,600 --> 00:17:07,980
in particular um that was suggested in

00:17:06,300 --> 00:17:14,070
the issue we closed the issue we moved

00:17:07,980 --> 00:17:16,980
on from that but um the purpose of the

00:17:14,070 --> 00:17:19,590
library is you know very specifically to

00:17:16,980 --> 00:17:24,630
escape JSON or escape JavaScript or ECMA

00:17:19,590 --> 00:17:27,360
for that matter um so one has to be

00:17:24,630 --> 00:17:29,520
careful when using it outside of those

00:17:27,360 --> 00:17:32,670
contexts

00:17:29,520 --> 00:17:36,990
um so now that we've gone through the

00:17:32,670 --> 00:17:39,930
stuff that was in Lang let's go over to

00:17:36,990 --> 00:17:41,760
some unique functionality to text and I

00:17:39,930 --> 00:17:44,970
am realizing that I'm way ahead of

00:17:41,760 --> 00:17:46,350
schedule oh well we can talk about text

00:17:44,970 --> 00:17:51,870
after this at what we where we think the

00:17:46,350 --> 00:17:55,190
library should go um so the the big bit

00:17:51,870 --> 00:17:57,750
of unique functionality is in two places

00:17:55,190 --> 00:18:01,080
one is code that I'm not particularly

00:17:57,750 --> 00:18:02,670
familiar with but I'm have spent a

00:18:01,080 --> 00:18:05,850
little bit of time and that's the differ

00:18:02,670 --> 00:18:09,080
and the other stuff that I've actually

00:18:05,850 --> 00:18:11,250
spent considerable time in is in the

00:18:09,080 --> 00:18:17,730
similarity score and edit distance space

00:18:11,250 --> 00:18:19,760
and so something that we implemented was

00:18:17,730 --> 00:18:21,960
uh the longest common subsequence

00:18:19,760 --> 00:18:26,570
algorithm which is kind of a convenient

00:18:21,960 --> 00:18:26,570
algorithm to use for determining

00:18:27,140 --> 00:18:32,460
similarities between words or strings I

00:18:30,120 --> 00:18:37,410
use words and strings interchangeably

00:18:32,460 --> 00:18:41,820
because in mathematics and logic they

00:18:37,410 --> 00:18:44,600
refer to the elements over the cleaning

00:18:41,820 --> 00:18:46,680
closure over an alphabet as words and in

00:18:44,600 --> 00:18:54,180
computer science they refer to them as

00:18:46,680 --> 00:19:01,830
strings um but uh if we look at this one

00:18:54,180 --> 00:19:04,800
might wonder how a DBA and a BA B has a

00:19:01,830 --> 00:19:09,600
common subsequence of three right

00:19:04,800 --> 00:19:14,460
because one might think that well

00:19:09,600 --> 00:19:20,100
clearly the shortest substring in common

00:19:14,460 --> 00:19:23,690
is a B right but the definition of

00:19:20,100 --> 00:19:26,370
subsequence in this case is any

00:19:23,690 --> 00:19:31,230
combination of characters moving from

00:19:26,370 --> 00:19:35,900
left to right with some characters

00:19:31,230 --> 00:19:40,190
removed they need not necessary at

00:19:35,900 --> 00:19:40,190
for this a b b

00:19:40,920 --> 00:19:49,320
and the right hand side a B and then the

00:19:45,420 --> 00:19:53,280
subsequent be counted subsequences okay

00:19:49,320 --> 00:19:55,260
and so the subsequence on this one's

00:19:53,280 --> 00:19:57,450
three the subsequence on this one's

00:19:55,260 --> 00:19:58,050
pretty straightforward frog and fog

00:19:57,450 --> 00:20:02,880
right

00:19:58,050 --> 00:20:08,400
just remove the R and and it's the same

00:20:02,880 --> 00:20:12,600
arm Pennsylvania and some contrivance of

00:20:08,400 --> 00:20:15,150
the word Pennsylvania has a a common

00:20:12,600 --> 00:20:17,720
subsequence of eleven an elephant and

00:20:15,150 --> 00:20:24,380
hippo has a common subsequence of one

00:20:17,720 --> 00:20:27,990
whether it's either the H or the P um

00:20:24,380 --> 00:20:29,880
it's also worth noting that the longest

00:20:27,990 --> 00:20:34,530
common subsequence algorithm is

00:20:29,880 --> 00:20:38,550
particularly slow in that the fastest

00:20:34,530 --> 00:20:41,820
that we can do it is the order of the

00:20:38,550 --> 00:20:43,410
left hand word the size of the left hand

00:20:41,820 --> 00:20:50,220
word times the size of the right hand

00:20:43,410 --> 00:20:54,630
word and if you're trying to do longest

00:20:50,220 --> 00:20:58,380
common subsequence across an arbitrary

00:20:54,630 --> 00:21:02,580
number of words you start bumping up

00:20:58,380 --> 00:21:04,740
into the np-complete area okay so we've

00:21:02,580 --> 00:21:11,850
chosen to limit ourselves to two words

00:21:04,740 --> 00:21:14,510
just to keep people from bumping

00:21:11,850 --> 00:21:19,590
themselves into the np-complete space um

00:21:14,510 --> 00:21:22,920
I haven't thought about generalizing

00:21:19,590 --> 00:21:27,030
this to an arbitrary number of words or

00:21:22,920 --> 00:21:28,710
a longer number number of words um it's

00:21:27,030 --> 00:21:29,610
not unreasonable to think that we could

00:21:28,710 --> 00:21:31,890
do something like that

00:21:29,610 --> 00:21:34,970
that kind of feels like it still sits

00:21:31,890 --> 00:21:38,820
within the space of the library um

00:21:34,970 --> 00:21:43,370
anyway so that's the longest common

00:21:38,820 --> 00:21:48,330
subsequence if we take that and

00:21:43,370 --> 00:21:49,830
normalize it on normalization in the

00:21:48,330 --> 00:21:54,260
sense of creating a distance out of it

00:21:49,830 --> 00:21:56,360
um it becomes the

00:21:54,260 --> 00:22:00,770
a we take a subsequence and impose

00:21:56,360 --> 00:22:04,340
characters to get from one string to the

00:22:00,770 --> 00:22:07,400
next string and that gives us a type of

00:22:04,340 --> 00:22:11,210
edit distance and that the way you edit

00:22:07,400 --> 00:22:15,200
is what drives the output of your your

00:22:11,210 --> 00:22:17,840
distance metric so arm if you

00:22:15,200 --> 00:22:20,840
accommodate substitutions right that's

00:22:17,840 --> 00:22:24,440
one type of editing whereas if you pluck

00:22:20,840 --> 00:22:26,120
a subsequence and insert characters and

00:22:24,440 --> 00:22:32,350
pluck another subsequence and insert

00:22:26,120 --> 00:22:36,680
characters it's not quite substitution

00:22:32,350 --> 00:22:39,350
anyway it's pretty clear that we only

00:22:36,680 --> 00:22:43,460
have to do two edits to get from a BBA

00:22:39,350 --> 00:22:46,880
to a B a B and one edit to get from frog

00:22:43,460 --> 00:22:48,290
to fog um I don't know what the three

00:22:46,880 --> 00:22:50,540
edits are to get from Pennsylvania to

00:22:48,290 --> 00:22:52,700
the contrivance on the right and I

00:22:50,540 --> 00:22:58,730
haven't done the exercise of getting

00:22:52,700 --> 00:23:02,170
from elephant to hippo but do know that

00:22:58,730 --> 00:23:09,260
we're moving from left to right okay

00:23:02,170 --> 00:23:12,070
so P H and H P over here won't

00:23:09,260 --> 00:23:17,870
necessarily fit together appropriately

00:23:12,070 --> 00:23:19,970
um another one that we've got is the

00:23:17,870 --> 00:23:21,770
levenshtein distance so if we look at

00:23:19,970 --> 00:23:25,180
this and we compare it with the results

00:23:21,770 --> 00:23:28,970
of the other one we notice that

00:23:25,180 --> 00:23:34,790
everything is the same except for it's

00:23:28,970 --> 00:23:38,630
fewer edits on hippo two elephant and my

00:23:34,790 --> 00:23:41,680
guess would happen I'm less familiar

00:23:38,630 --> 00:23:44,930
with the levenshtein distance um

00:23:41,680 --> 00:23:47,570
algorithm off the top of my head but it

00:23:44,930 --> 00:23:50,660
wouldn't surprise me if the ordering had

00:23:47,570 --> 00:23:54,950
less to do because a sequence is

00:23:50,660 --> 00:23:56,540
necessarily left to right and um the

00:23:54,950 --> 00:24:00,620
levenshtein distance has to do with

00:23:56,540 --> 00:24:01,960
substitutions okay um

00:24:00,620 --> 00:24:06,610
[Music]

00:24:01,960 --> 00:24:10,269
so those are two of our edit distances

00:24:06,610 --> 00:24:12,669
we've got a bunch more um I actually

00:24:10,269 --> 00:24:15,720
have that on the next slide so what else

00:24:12,669 --> 00:24:22,749
is there we've got a variety of diff

00:24:15,720 --> 00:24:27,129
under text diff uhm the diff algorithm

00:24:22,749 --> 00:24:29,799
and there is largely based upon the

00:24:27,129 --> 00:24:34,019
longest common subsequence okay

00:24:29,799 --> 00:24:36,159
and I believe that it's the Meyers

00:24:34,019 --> 00:24:41,340
algorithm on the longest common

00:24:36,159 --> 00:24:46,029
subsequence um should put a reference in

00:24:41,340 --> 00:24:49,659
regardless it's in the Javadoc so um if

00:24:46,029 --> 00:24:50,679
you want to get into that we can um you

00:24:49,659 --> 00:24:53,950
should dig into the Javadoc

00:24:50,679 --> 00:24:57,879
it's um it's good stuff in there um we

00:24:53,950 --> 00:25:00,789
have other various similarity scores and

00:24:57,879 --> 00:25:02,889
distance tools namely we've got cosine

00:25:00,789 --> 00:25:05,470
similarity we've got the hamming

00:25:02,889 --> 00:25:09,759
distance you've got the jaakor distance

00:25:05,470 --> 00:25:13,749
we've got the Haro wink hora Winkler

00:25:09,759 --> 00:25:15,869
pardon my um my mispronunciation on that

00:25:13,749 --> 00:25:19,899
the class was originally named ha row

00:25:15,869 --> 00:25:25,450
rank ler I was like the rank ler anyway

00:25:19,899 --> 00:25:27,190
so it's horri Winkler arm and we've got

00:25:25,450 --> 00:25:29,200
about to translate stuff that mainly

00:25:27,190 --> 00:25:31,179
supports string escape utils

00:25:29,200 --> 00:25:34,960
but has more there's more in there than

00:25:31,179 --> 00:25:39,639
just that so the question is what's next

00:25:34,960 --> 00:25:43,139
for comments texts right arm and with

00:25:39,639 --> 00:25:46,749
the idea that we're trying to do

00:25:43,139 --> 00:25:52,059
considerable deprecation of the text

00:25:46,749 --> 00:25:54,090
e'er things in Lang right we would

00:25:52,059 --> 00:25:57,610
probably want to move over word utils

00:25:54,090 --> 00:26:00,970
minimally and I don't know how much more

00:25:57,610 --> 00:26:07,200
we could move over on the boundary that

00:26:00,970 --> 00:26:10,179
I see between text and Lang would be I

00:26:07,200 --> 00:26:13,389
brought this up on the listserv maybe I

00:26:10,179 --> 00:26:17,549
guess it was in the fall sometime but if

00:26:13,389 --> 00:26:17,549
I'm a Java developer that's work

00:26:17,940 --> 00:26:26,980
let's say I don't know an Android app

00:26:22,840 --> 00:26:29,519
okay I'm probably going to want Lang and

00:26:26,980 --> 00:26:35,110
I'm probably not going to want text if

00:26:29,519 --> 00:26:38,169
I'm doing you know natural language

00:26:35,110 --> 00:26:40,019
processing in Java then I probably would

00:26:38,169 --> 00:26:42,399
want text or something like that where

00:26:40,019 --> 00:26:46,330
I'm trying to find kind of that natural

00:26:42,399 --> 00:26:49,480
boundary between the two where if I'm

00:26:46,330 --> 00:26:51,429
actually focused on doing work in text

00:26:49,480 --> 00:26:52,600
manipulation then Commons text is

00:26:51,429 --> 00:26:56,169
something that I would want to include

00:26:52,600 --> 00:26:58,659
whereas with Lang I want everybody to be

00:26:56,169 --> 00:27:01,809
like yeah I want that guy I want that

00:26:58,659 --> 00:27:07,260
one just because it's really really nice

00:27:01,809 --> 00:27:13,330
to not have to write is blank everywhere

00:27:07,260 --> 00:27:20,100
because it's an ugly if statement to

00:27:13,330 --> 00:27:22,590
have you know null check and then is

00:27:20,100 --> 00:27:26,679
empty

00:27:22,590 --> 00:27:30,220
so that's kind of where I see the line

00:27:26,679 --> 00:27:34,120
between those so um I really want to get

00:27:30,220 --> 00:27:36,880
a 1.1 out in the next month uh we talked

00:27:34,120 --> 00:27:41,130
about a 1.1 we pulled some stuff out of

00:27:36,880 --> 00:27:44,019
the 1.0 release that was um potentially

00:27:41,130 --> 00:27:46,029
contentious in the sense that um people

00:27:44,019 --> 00:27:49,990
were in the midst of having discussions

00:27:46,029 --> 00:27:50,649
about design and whatnot and we were

00:27:49,990 --> 00:27:52,269
like okay

00:27:50,649 --> 00:27:53,850
well if people are talking about the

00:27:52,269 --> 00:27:56,590
design of these components we can just

00:27:53,850 --> 00:27:58,630
pull them and set them aside for the

00:27:56,590 --> 00:28:00,490
time being and roll out with 1.0 with

00:27:58,630 --> 00:28:03,220
what we've got so that we can actively

00:28:00,490 --> 00:28:04,899
deprecated that stuff in lang and then

00:28:03,220 --> 00:28:06,669
we can pull that stuff in because it's

00:28:04,899 --> 00:28:09,159
not an API change it's a non-breaking

00:28:06,669 --> 00:28:13,090
change pull that stuff in and provide

00:28:09,159 --> 00:28:15,779
more tools and that's cool and the code

00:28:13,090 --> 00:28:18,460
base now has those two things in it

00:28:15,779 --> 00:28:23,889
specifically Ward utils and a random

00:28:18,460 --> 00:28:26,529
string generator um and so rolling a one

00:28:23,889 --> 00:28:29,390
dot o or one dot one um isn't

00:28:26,529 --> 00:28:32,190
unreasonable at this point in fact

00:28:29,390 --> 00:28:33,420
probably could have done it last week or

00:28:32,190 --> 00:28:36,360
the week before had I not been

00:28:33,420 --> 00:28:37,230
underwater at work but that's the nature

00:28:36,360 --> 00:28:40,140
of having a day job

00:28:37,230 --> 00:28:43,350
um and I'm assuming that we don't have

00:28:40,140 --> 00:28:49,800
any bugs in in in 1.0 and we don't have

00:28:43,350 --> 00:28:52,320
to roll a 10.1 so um that's what I've

00:28:49,800 --> 00:28:55,500
got so we've got word utils coming in um

00:28:52,320 --> 00:29:01,770
we've got some updates to it can I

00:28:55,500 --> 00:29:04,590
remember what the update is now I can't

00:29:01,770 --> 00:29:07,370
remember what the update is um it has to

00:29:04,590 --> 00:29:10,770
do with reading a method that is in a

00:29:07,370 --> 00:29:16,250
couple of different places it's in

00:29:10,770 --> 00:29:16,250
string utils but the mechanics of it are

00:29:16,580 --> 00:29:21,360
more wordy in nature and the

00:29:19,440 --> 00:29:25,320
implementation is vastly different from

00:29:21,360 --> 00:29:28,680
what's in string utils so um it being in

00:29:25,320 --> 00:29:30,090
word utils isn't unreasonable we could

00:29:28,680 --> 00:29:31,770
pull up the pull request if we wanted to

00:29:30,090 --> 00:29:35,820
look at it after this um the other thing

00:29:31,770 --> 00:29:40,260
is the random string generator and a lot

00:29:35,820 --> 00:29:41,880
of things go out to the Commons orangy

00:29:40,260 --> 00:29:44,820
crew for putting that in there um

00:29:41,880 --> 00:29:46,530
they've been doing a whole lot of solid

00:29:44,820 --> 00:29:50,040
work in the random space and the the

00:29:46,530 --> 00:29:53,880
probabilistic space on with the Commons

00:29:50,040 --> 00:29:56,370
RNG component and I guess the the

00:29:53,880 --> 00:29:59,310
forthcoming Commons numbers component

00:29:56,370 --> 00:30:01,680
and some of that stuff um I kind of

00:29:59,310 --> 00:30:03,210
weighed over into the the math territory

00:30:01,680 --> 00:30:05,940
a little bit having come from a

00:30:03,210 --> 00:30:09,150
mathematical background but um my

00:30:05,940 --> 00:30:12,600
research in math was in the combinatoric

00:30:09,150 --> 00:30:15,930
onward space and and functions that map

00:30:12,600 --> 00:30:17,520
you know elements out of one Queeny

00:30:15,930 --> 00:30:19,670
closure to another cleany closure and

00:30:17,520 --> 00:30:24,180
how to avoid patterns in that space

00:30:19,670 --> 00:30:27,090
anyway um so that's the next thing on

00:30:24,180 --> 00:30:33,650
the list is to deprecated the stuff that

00:30:27,090 --> 00:30:36,510
is in text for the upcoming Lang release

00:30:33,650 --> 00:30:39,690
which we may or may not be fast enough

00:30:36,510 --> 00:30:42,780
for depending upon if Benedict decides

00:30:39,690 --> 00:30:43,140
to run with that release sooner than

00:30:42,780 --> 00:30:46,170
later

00:30:43,140 --> 00:30:50,450
um I think some of the deprecations have

00:30:46,170 --> 00:30:54,450
been done thanks to Pascal Schumacher

00:30:50,450 --> 00:30:57,470
but um I have to get into Lang and look

00:30:54,450 --> 00:31:01,110
a bit a little bit more carefully so um

00:30:57,470 --> 00:31:01,800
like I said I'm running fast this is all

00:31:01,110 --> 00:31:04,230
I've got

00:31:01,800 --> 00:31:06,530
so do you guys have any questions on

00:31:04,230 --> 00:31:13,220
things um

00:31:06,530 --> 00:31:16,700
I'm some thoughts occur to me are that

00:31:13,220 --> 00:31:21,030
I've been doing a lot of the work out of

00:31:16,700 --> 00:31:24,330
the mo fare book on applied combinatoric

00:31:21,030 --> 00:31:26,310
onwards and taking some of the more

00:31:24,330 --> 00:31:30,810
fundamental principles out of that book

00:31:26,310 --> 00:31:33,180
and you know writing those into the

00:31:30,810 --> 00:31:36,660
codebase would be reasonable for open

00:31:33,180 --> 00:31:38,900
NLP and other texty or sort of

00:31:36,660 --> 00:31:40,950
applications or bioinformatics

00:31:38,900 --> 00:31:42,840
applications you know have a common

00:31:40,950 --> 00:31:44,400
place for them to go because a lot of

00:31:42,840 --> 00:31:47,640
these distance functions aren't really

00:31:44,400 --> 00:31:49,170
easily findable out there in the java

00:31:47,640 --> 00:31:52,410
environment and a lot of people are

00:31:49,170 --> 00:31:55,560
probably implementing than themselves so

00:31:52,410 --> 00:31:59,010
um the goal is to have a common place

00:31:55,560 --> 00:32:01,950
for that and so I tend to fall back to

00:31:59,010 --> 00:32:05,430
that book and maybe a little bit of the

00:32:01,950 --> 00:32:07,530
work out of um University of Waterloo

00:32:05,430 --> 00:32:10,890
they've got a pretty solid Commodus

00:32:07,530 --> 00:32:14,520
works on words crew that um comes up

00:32:10,890 --> 00:32:17,370
with interesting stuff but um that's

00:32:14,520 --> 00:32:23,580
kind of where I see maybe the 1.2 or the

00:32:17,370 --> 00:32:26,930
2.0 Commons text going um but you guys

00:32:23,580 --> 00:32:26,930
have any questions on what we have here

00:32:34,980 --> 00:32:48,250
not terrified let's say any vector pair

00:32:45,660 --> 00:32:51,960
because that I think definitely open up

00:32:48,250 --> 00:32:55,920
a bunch of stuff a bunch of reuse over

00:32:51,960 --> 00:32:59,530
sure from all those metrics on on

00:32:55,920 --> 00:33:01,630
something working air that seems

00:32:59,530 --> 00:33:03,010
reasonable

00:33:01,630 --> 00:33:12,150
no that seem that seems quite reasonable

00:33:03,010 --> 00:33:12,150
I mean I suppose you would need

00:33:12,510 --> 00:33:16,540
something that implements the comparable

00:33:14,890 --> 00:33:19,060
interface or something along those lines

00:33:16,540 --> 00:33:22,870
where you can say okay well this this is

00:33:19,060 --> 00:33:28,720
a list of items that we know how to

00:33:22,870 --> 00:33:31,060
compare but aside from that arm the

00:33:28,720 --> 00:33:35,320
mechanics of going through one of those

00:33:31,060 --> 00:33:37,330
metrics is I mean it's it's elemental in

00:33:35,320 --> 00:33:41,500
the sense of its you're doing it element

00:33:37,330 --> 00:33:44,080
wise so no matter what the alphabet is

00:33:41,500 --> 00:33:45,970
so to speak you're still operating on

00:33:44,080 --> 00:33:49,840
individual characters of the alphabet

00:33:45,970 --> 00:33:54,160
and so it's easily generalizable to to

00:33:49,840 --> 00:33:57,060
whatever has that you know mechanism

00:33:54,160 --> 00:33:57,060
that seems quite reasonable

00:34:03,989 --> 00:34:23,940
yes um well so I know that um I know

00:34:19,000 --> 00:34:23,940
that Bruno is a committer on open NLP um

00:34:24,419 --> 00:34:30,520
he hasn't he's been I'm assuming he's

00:34:28,720 --> 00:34:34,149
been quite busy lately because he's been

00:34:30,520 --> 00:34:37,210
kind of mildly in in on participation

00:34:34,149 --> 00:34:41,520
here in the last couple um pull requests

00:34:37,210 --> 00:34:44,049
that have come in he's at least been

00:34:41,520 --> 00:34:46,299
looking at them but he hasn't been

00:34:44,049 --> 00:34:49,629
actively contributing code on a on a

00:34:46,299 --> 00:34:53,470
regular basis so I mean that'sthat's one

00:34:49,629 --> 00:34:55,240
of the drawbacks of um being in the open

00:34:53,470 --> 00:34:59,440
source world is you never know what

00:34:55,240 --> 00:35:04,180
other people's timelines are and so it's

00:34:59,440 --> 00:35:05,799
all it's all just a slow game but um he

00:35:04,180 --> 00:35:08,260
definitely you mean so we have at least

00:35:05,799 --> 00:35:10,690
one committer out there it wouldn't be

00:35:08,260 --> 00:35:12,490
unreasonable for me to probably start

00:35:10,690 --> 00:35:15,549
treading over in that space I haven't

00:35:12,490 --> 00:35:18,099
done that yet personally I'm fairly new

00:35:15,549 --> 00:35:20,380
to the whole open source world I I

00:35:18,099 --> 00:35:24,970
hadn't made any open source commits

00:35:20,380 --> 00:35:31,270
prior to March of last year or something

00:35:24,970 --> 00:35:32,740
like that so um I don't I I enjoy it so

00:35:31,270 --> 00:35:35,790
there's no reason to think that I

00:35:32,740 --> 00:35:35,790
shouldn't tread over in that space

00:35:47,800 --> 00:35:57,170
sure

00:35:49,040 --> 00:36:01,010
sure arm it finding Apache projects that

00:35:57,170 --> 00:36:02,930
have it seems to me like the best thing

00:36:01,010 --> 00:36:04,870
to do would be to find Apache projects

00:36:02,930 --> 00:36:07,550
that have levenshtein distance

00:36:04,870 --> 00:36:09,920
implemented in them or you know some

00:36:07,550 --> 00:36:13,210
something like the Hara winkler or a

00:36:09,920 --> 00:36:17,540
Hamming distance or what have you and

00:36:13,210 --> 00:36:20,120
maybe opening conversations in those

00:36:17,540 --> 00:36:23,170
projects saying hey guys can we

00:36:20,120 --> 00:36:27,770
standardize on location here and then

00:36:23,170 --> 00:36:30,980
maybe we can build the community in the

00:36:27,770 --> 00:36:33,610
sense of they're thinking okay all these

00:36:30,980 --> 00:36:36,590
text processing algorithms that that are

00:36:33,610 --> 00:36:37,910
that we've reinvented the wheel in eight

00:36:36,590 --> 00:36:40,820
different locations how can we

00:36:37,910 --> 00:36:42,790
centralize that um that's probably a

00:36:40,820 --> 00:36:50,360
conversation that's worth starting and

00:36:42,790 --> 00:36:54,890
um not unreasonable to figure that out I

00:36:50,360 --> 00:36:57,590
know that I feel like spark has

00:36:54,890 --> 00:36:59,900
something like that in it and a couple

00:36:57,590 --> 00:37:05,270
other projects have these

00:36:59,900 --> 00:37:08,600
implementations out there um even was it

00:37:05,270 --> 00:37:10,820
the jaw card the jaw card distance had a

00:37:08,600 --> 00:37:12,740
bug in it where they were pointing to an

00:37:10,820 --> 00:37:14,450
implementation of the jaw card distance

00:37:12,740 --> 00:37:18,980
in another Apache project that had been

00:37:14,450 --> 00:37:21,770
fixed and it's like does this make sense

00:37:18,980 --> 00:37:24,110
guys does this make sense but I mean I

00:37:21,770 --> 00:37:28,490
suppose that's just the slow game of

00:37:24,110 --> 00:37:30,200
open-source development so um I don't

00:37:28,490 --> 00:37:34,370
know how many people are on the the

00:37:30,200 --> 00:37:36,260
Commons listserv it hop into the the dev

00:37:34,370 --> 00:37:38,630
list and I mean there's no reason that

00:37:36,260 --> 00:37:43,490
we shouldn't start that I'm all for it

00:37:38,630 --> 00:37:46,190
uh and if you think of fundamental

00:37:43,490 --> 00:37:48,290
algorithms that are in the text

00:37:46,190 --> 00:37:51,230
processing space that seem like they

00:37:48,290 --> 00:37:52,140
could be widely reused there's no reason

00:37:51,230 --> 00:37:55,530
to

00:37:52,140 --> 00:38:12,780
not open a JIRA issue and just commit

00:37:55,530 --> 00:38:16,380
the code everybody but Benedict

00:38:12,780 --> 00:38:18,900
everybody so lots of thanks lots of

00:38:16,380 --> 00:38:21,990
thanks go to Benedict and and Bruno whom

00:38:18,900 --> 00:38:26,430
I don't think is at the conference for

00:38:21,990 --> 00:38:34,920
on getting the component as far as it

00:38:26,430 --> 00:38:38,910
was when I jumped in in November um well

00:38:34,920 --> 00:38:48,590
hey hey I don't know how I did it was

00:38:38,910 --> 00:38:51,330
there um I don't know I I think that the

00:38:48,590 --> 00:39:07,320
fundamental algorithms if we don't have

00:38:51,330 --> 00:39:13,340
them are definitely welcome sure sure

00:39:07,320 --> 00:39:13,340
sure yeah that seems quite reasonable um

00:39:14,090 --> 00:39:19,500
get with me after and we can figure out

00:39:17,400 --> 00:39:24,680
where that stuff is and start moving on

00:39:19,500 --> 00:39:24,680
it better

00:39:29,310 --> 00:39:36,820
from China couldn't wondering whether or

00:39:32,950 --> 00:39:39,760
I will also work on different languages

00:39:36,820 --> 00:39:42,880
which protect from carelessness so for

00:39:39,760 --> 00:39:46,990
example the world is just one web symbol

00:39:42,880 --> 00:39:51,240
and most made up of character so make

00:39:46,990 --> 00:39:56,880
them that a lot is a they do and that

00:39:51,240 --> 00:40:02,110
opens us into the utf-8 utf-16

00:39:56,880 --> 00:40:03,160
transition right so in utf-8 so it don't

00:40:02,110 --> 00:40:05,950
know how many people are familiar with

00:40:03,160 --> 00:40:09,820
this but in utf-8 up to what is it 65

00:40:05,950 --> 00:40:13,290
thousand whatever the maximal is on on

00:40:09,820 --> 00:40:15,400
utf-8 right those are all represented as

00:40:13,290 --> 00:40:19,180
individual characters and then as soon

00:40:15,400 --> 00:40:21,940
as you cross over past that into utf-16

00:40:19,180 --> 00:40:24,190
the characters start being represented

00:40:21,940 --> 00:40:29,440
as pairs of characters that are

00:40:24,190 --> 00:40:32,020
conjugate pairs and um like if you're

00:40:29,440 --> 00:40:36,840
trying to represent an emoji and emoji

00:40:32,020 --> 00:40:42,790
is two characters under the hood and so

00:40:36,840 --> 00:40:45,540
fortunately um the Java API has affords

00:40:42,790 --> 00:40:49,920
the ability to two predicate upon is

00:40:45,540 --> 00:40:52,120
conjugate pair and you can do arm

00:40:49,920 --> 00:40:53,500
counting of characters or movement

00:40:52,120 --> 00:40:55,480
across characters that are these

00:40:53,500 --> 00:40:57,310
conjugate pairs and I think that that

00:40:55,480 --> 00:41:03,340
affords us the ability to operate in

00:40:57,310 --> 00:41:05,680
other languages um it still is pretty

00:41:03,340 --> 00:41:08,710
subtle when you start thinking about

00:41:05,680 --> 00:41:10,570
last character of and things like that

00:41:08,710 --> 00:41:15,030
when you're trying to get that out of a

00:41:10,570 --> 00:41:17,140
string um I worked on a pull request

00:41:15,030 --> 00:41:18,700
specifically in the Langer Lee er this

00:41:17,140 --> 00:41:25,420
year where we were dealing with that and

00:41:18,700 --> 00:41:29,440
we decided to go with what um the Java

00:41:25,420 --> 00:41:32,070
string API does which um takes a

00:41:29,440 --> 00:41:37,210
conjugate pair and counts it is one and

00:41:32,070 --> 00:41:38,650
that's pretty standard um so I mean

00:41:37,210 --> 00:41:41,620
that's that's kind of where we settled

00:41:38,650 --> 00:41:44,500
on that and I tend to

00:41:41,620 --> 00:41:46,720
defer to if there is a Java

00:41:44,500 --> 00:41:48,670
implementation of an algorithm for doing

00:41:46,720 --> 00:41:51,160
that sort of thing defer to what Java

00:41:48,670 --> 00:41:52,720
does because that way we're not doing

00:41:51,160 --> 00:41:55,210
two different things and getting

00:41:52,720 --> 00:41:59,140
different results out of it but um there

00:41:55,210 --> 00:42:00,610
are some subtle mechanics under the hood

00:41:59,140 --> 00:42:07,390
there that happen when you're in the

00:42:00,610 --> 00:42:08,440
character space um we technically got

00:42:07,390 --> 00:42:16,780
another five minutes

00:42:08,440 --> 00:42:19,420
but um yeah I feel kind of data and the

00:42:16,780 --> 00:42:22,540
areas of trouble me character type

00:42:19,420 --> 00:42:27,130
detection and I'd sure if it was the

00:42:22,540 --> 00:42:33,640
third-party library is that kind of

00:42:27,130 --> 00:42:38,560
seems like yeah that that doesn't seem

00:42:33,640 --> 00:42:41,700
unreasonable like like whether it's a

00:42:38,560 --> 00:42:51,760
utf-8 character or whether it's a

00:42:41,700 --> 00:42:54,790
whatever wingdings wing-dings um yeah

00:42:51,760 --> 00:42:57,790
those that all seems quite reasonable

00:42:54,790 --> 00:42:59,920
for the library and I mean we're

00:42:57,790 --> 00:43:01,540
definitely in a fledgling sort of space

00:42:59,920 --> 00:43:04,750
right now in that we've just come out

00:43:01,540 --> 00:43:08,350
with a one dot oh we're trying to focus

00:43:04,750 --> 00:43:11,410
on text your things than Lang so I'm

00:43:08,350 --> 00:43:13,270
pretty open as to what should be here

00:43:11,410 --> 00:43:17,830
I'm not real prescriptive about what

00:43:13,270 --> 00:43:19,030
should be here I think that it I don't

00:43:17,830 --> 00:43:20,650
know the more word we get out and the

00:43:19,030 --> 00:43:23,260
more people get interested in it the

00:43:20,650 --> 00:43:24,400
easier it is to kind of say oh that's

00:43:23,260 --> 00:43:28,750
the direction we should go because

00:43:24,400 --> 00:43:30,820
that's where we're going um that tends

00:43:28,750 --> 00:43:32,410
to be my philosophy on on things

00:43:30,820 --> 00:43:34,900
generally is to you know just be like

00:43:32,410 --> 00:43:36,340
okay well what's on the plate now I've

00:43:34,900 --> 00:43:38,230
got these things I'll do those things

00:43:36,340 --> 00:43:40,540
I'll get a release out the door and if

00:43:38,230 --> 00:43:42,490
we can start moving you know in a

00:43:40,540 --> 00:43:45,000
direction regardless of the direction

00:43:42,490 --> 00:43:45,000
I'm okay with it

00:43:46,330 --> 00:43:55,420
perhaps also like visit English Spanish

00:43:49,610 --> 00:43:55,420
Italian Russian kind of like a streamer

00:43:59,500 --> 00:44:11,500
that's really hard to do whoa um yeah um

00:44:12,730 --> 00:44:22,220
yeah yeah um that that opens the

00:44:20,030 --> 00:44:23,600
question of does that should that be in

00:44:22,220 --> 00:44:25,970
this one or should should we try to work

00:44:23,600 --> 00:44:28,130
on that and open in LP or where is the

00:44:25,970 --> 00:44:29,870
line between the two and I don't think

00:44:28,130 --> 00:44:32,420
we've actually ever gotten to that

00:44:29,870 --> 00:44:34,370
boundary yet so I mean I'm open to those

00:44:32,420 --> 00:44:35,810
discussions and there's no reason that

00:44:34,370 --> 00:44:37,610
we shouldn't have those discussions I

00:44:35,810 --> 00:44:39,440
just we haven't gotten to that place

00:44:37,610 --> 00:44:41,240
where it's like this seems something

00:44:39,440 --> 00:44:42,380
this seems like it's really complex and

00:44:41,240 --> 00:44:44,030
it should go in the natural language

00:44:42,380 --> 00:44:45,890
processing toolbox as opposed to our

00:44:44,030 --> 00:44:47,360
toolbox but I mean there's no reason to

00:44:45,890 --> 00:44:52,580
say that we shouldn't start thinking

00:44:47,360 --> 00:44:53,780
about those sorts of things um I think

00:44:52,580 --> 00:44:56,960
I'm going to let the floor go to the

00:44:53,780 --> 00:44:59,240
next guy so that uh I'm not crowding the

00:44:56,960 --> 00:45:01,610
microphone so um thanks everybody I

00:44:59,240 --> 00:45:05,150
appreciate it and um feel free to grab

00:45:01,610 --> 00:45:07,730
me in here outside after this and we can

00:45:05,150 --> 00:45:10,300
keep plugging away at the new library

00:45:07,730 --> 00:45:10,300
Thanks

00:45:10,450 --> 00:45:13,350

YouTube URL: https://www.youtube.com/watch?v=rqBJHpQ5yvo


