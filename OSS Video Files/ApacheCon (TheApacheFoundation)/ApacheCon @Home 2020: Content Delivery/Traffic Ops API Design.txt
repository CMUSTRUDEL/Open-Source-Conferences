Title: Traffic Ops API Design
Publication date: 2020-10-15
Playlist: ApacheCon @Home 2020: Content Delivery
Description: 
	Traffic Ops API Design
ocket8888

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

For the past few months, the Traffic Ops working group has been iterating on a design document for the Traffic Ops API. Some pieces of it have already been incorporated into the existing API, others are still a work in progress. This talk will be an overview of the design in progress, motivations and considerations, and lessons learned.

ocket8888 is a software engineer on the CDN team at Comcast. ocket8888 is an Apache Traffic Control committer and one of the leads of the Traffic Ops Working group.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:25,199 --> 00:00:27,599
okay

00:00:25,680 --> 00:00:29,599
so for those of you who don't know

00:00:27,599 --> 00:00:32,239
traffic ops is

00:00:29,599 --> 00:00:33,440
sort of like the center of an atc

00:00:32,239 --> 00:00:35,440
deployment

00:00:33,440 --> 00:00:37,040
and interacting with its api is how you

00:00:35,440 --> 00:00:40,079
change configuration of

00:00:37,040 --> 00:00:43,120
other components and how you

00:00:40,079 --> 00:00:46,480
basically set up all your cdns

00:00:43,120 --> 00:00:47,920
so for the past few months the traffic

00:00:46,480 --> 00:00:50,000
ops working group

00:00:47,920 --> 00:00:53,280
has been meeting every once in a while

00:00:50,000 --> 00:00:56,559
to discuss changes to the api

00:00:53,280 --> 00:00:58,879
that we feel address

00:00:56,559 --> 00:01:00,320
tech debt and limitations of the current

00:00:58,879 --> 00:01:04,479
system

00:01:00,320 --> 00:01:06,320
so this is going to be

00:01:04,479 --> 00:01:08,000
sort of walking through what those

00:01:06,320 --> 00:01:11,600
meetings look like

00:01:08,000 --> 00:01:14,799
what we discussed and the considerations

00:01:11,600 --> 00:01:14,799
in anything we learned along the way

00:01:15,520 --> 00:01:21,840
so we started meeting in december

00:01:19,280 --> 00:01:23,040
we've got consistent attendance from

00:01:21,840 --> 00:01:24,640
four people there have been meetings

00:01:23,040 --> 00:01:26,720
with more but consistently it's been

00:01:24,640 --> 00:01:31,280
about four people

00:01:26,720 --> 00:01:34,400
and we meet for just an hour to discuss

00:01:31,280 --> 00:01:34,960
a design document that lives as a pull

00:01:34,400 --> 00:01:37,920
request

00:01:34,960 --> 00:01:39,680
in my fork of the traffic control repo

00:01:37,920 --> 00:01:41,119
which was

00:01:39,680 --> 00:01:43,439
it was a really nice way to collaborate

00:01:41,119 --> 00:01:44,479
because it lets people leave comments on

00:01:43,439 --> 00:01:47,680
like

00:01:44,479 --> 00:01:49,759
lines that they think should be worded

00:01:47,680 --> 00:01:51,280
differently or just taken out altogether

00:01:49,759 --> 00:01:53,680
you know on a line by line basis on the

00:01:51,280 --> 00:01:55,600
pull request

00:01:53,680 --> 00:01:58,399
uh so far these meetings have resulted

00:01:55,600 --> 00:02:01,600
in two merged blueprints

00:01:58,399 --> 00:02:03,600
which are just a statement of intent

00:02:01,600 --> 00:02:06,320
to do something basically that's used by

00:02:03,600 --> 00:02:10,640
the traffic control project

00:02:06,320 --> 00:02:12,879
and we had one blueprint that was

00:02:10,640 --> 00:02:15,760
rejected and one that's out there in

00:02:12,879 --> 00:02:21,280
kind of limbo right now

00:02:15,760 --> 00:02:23,280
so that's our progress so far

00:02:21,280 --> 00:02:24,560
and mainly we talked about things that

00:02:23,280 --> 00:02:26,080
can be grouped into two different

00:02:24,560 --> 00:02:28,800
categories

00:02:26,080 --> 00:02:29,440
there's things that deal with just uh

00:02:28,800 --> 00:02:32,400
all around

00:02:29,440 --> 00:02:33,120
best practices that don't have anything

00:02:32,400 --> 00:02:38,480
to do with

00:02:33,120 --> 00:02:40,879
specific objects or specific endpoints

00:02:38,480 --> 00:02:42,160
and they're just sort of quality of life

00:02:40,879 --> 00:02:43,120
improvements for interacting with the

00:02:42,160 --> 00:02:46,239
api

00:02:43,120 --> 00:02:50,400
and then the more controversial

00:02:46,239 --> 00:02:54,640
and by far harder to tackle aspect

00:02:50,400 --> 00:02:58,080
is the data model itself looking at

00:02:54,640 --> 00:02:59,519
the objects that are received and

00:02:58,080 --> 00:03:01,120
returned by the api

00:02:59,519 --> 00:03:03,360
and seeing how those could possibly be

00:03:01,120 --> 00:03:06,400
improved

00:03:03,360 --> 00:03:08,560
and the reason for that is like the

00:03:06,400 --> 00:03:10,319
traffic ops api builds up out of

00:03:08,560 --> 00:03:13,200
necessity over the years

00:03:10,319 --> 00:03:14,080
if you need a new thing then you just

00:03:13,200 --> 00:03:16,959
add it

00:03:14,080 --> 00:03:18,480
so we think it can be beneficial to take

00:03:16,959 --> 00:03:19,360
a step back every once in a while and

00:03:18,480 --> 00:03:21,200
ask yourself

00:03:19,360 --> 00:03:23,280
if you were designing all of the things

00:03:21,200 --> 00:03:25,440
you know you need today

00:03:23,280 --> 00:03:26,319
from scratch what might you do

00:03:25,440 --> 00:03:27,760
differently

00:03:26,319 --> 00:03:32,879
and are there any steps you can take to

00:03:27,760 --> 00:03:34,480
move in that direction so as far as best

00:03:32,879 --> 00:03:37,519
practices

00:03:34,480 --> 00:03:40,400
one of the most basic things that

00:03:37,519 --> 00:03:42,319
we sort of codified this was sort of an

00:03:40,400 --> 00:03:45,599
unwritten rule

00:03:42,319 --> 00:03:47,920
in traffic control it's a problem that

00:03:45,599 --> 00:03:50,319
existed in very old versions of the

00:03:47,920 --> 00:03:51,840
traffic ops api but that people all

00:03:50,319 --> 00:03:53,439
generally agreed were bad and had

00:03:51,840 --> 00:03:55,439
resolved not to do again

00:03:53,439 --> 00:03:56,560
and we basically just wrote down that

00:03:55,439 --> 00:04:00,239
rule

00:03:56,560 --> 00:04:04,400
so one of the

00:04:00,239 --> 00:04:08,000
things in that category is using http

00:04:04,400 --> 00:04:11,680
request methods incorrectly you can see

00:04:08,000 --> 00:04:15,680
here the get delivery services xml id

00:04:11,680 --> 00:04:20,160
blah blah blah delete path

00:04:15,680 --> 00:04:23,280
was a get request that deleted ssl keys

00:04:20,160 --> 00:04:24,960
which is not only something that doesn't

00:04:23,280 --> 00:04:25,680
make the most intuitive sense it could

00:04:24,960 --> 00:04:28,240
make

00:04:25,680 --> 00:04:31,199
but it's actually a vulnerability in

00:04:28,240 --> 00:04:32,639
cross site request forgery attacks

00:04:31,199 --> 00:04:34,479
because if you can get a user to click

00:04:32,639 --> 00:04:36,240
on this in an email they think they're

00:04:34,479 --> 00:04:40,000
opening a web page but they're actually

00:04:36,240 --> 00:04:40,000
destroying some information somewhere

00:04:40,560 --> 00:04:44,800
another improvement with regard to http

00:04:43,120 --> 00:04:47,759
request methods

00:04:44,800 --> 00:04:50,160
is if you look down in the box for the

00:04:47,759 --> 00:04:51,840
example put request

00:04:50,160 --> 00:04:53,600
a delivery service is one of the most

00:04:51,840 --> 00:04:57,600
common objects to manipulate

00:04:53,600 --> 00:05:01,280
in the traffic ops api and they have

00:04:57,600 --> 00:05:04,080
several dozen fields depending on

00:05:01,280 --> 00:05:05,600
what context you're looking at them in

00:05:04,080 --> 00:05:07,039
this is just sort of a stripped down

00:05:05,600 --> 00:05:08,320
example of some things that could be

00:05:07,039 --> 00:05:11,520
problematic

00:05:08,320 --> 00:05:14,160
but if you wanted to update just this

00:05:11,520 --> 00:05:16,000
array here consistent hash query params

00:05:14,160 --> 00:05:17,360
and say you wanted to remove the entries

00:05:16,000 --> 00:05:18,639
it has and replace them with something

00:05:17,360 --> 00:05:20,880
else

00:05:18,639 --> 00:05:23,120
you have to put up the entire

00:05:20,880 --> 00:05:26,160
representation of the delivery service

00:05:23,120 --> 00:05:29,039
because put is an it important method

00:05:26,160 --> 00:05:30,479
and if you omit fields then you're

00:05:29,039 --> 00:05:33,199
implicitly setting them

00:05:30,479 --> 00:05:34,479
to null because the way the parser works

00:05:33,199 --> 00:05:36,240
on the server

00:05:34,479 --> 00:05:39,680
is it doesn't differentiate between

00:05:36,240 --> 00:05:42,639
undefined and null

00:05:39,680 --> 00:05:43,280
so if you just want to change that one

00:05:42,639 --> 00:05:44,400
field

00:05:43,280 --> 00:05:46,479
you still have to push up this

00:05:44,400 --> 00:05:47,680
representation and make sure you get all

00:05:46,479 --> 00:05:50,720
these fields right

00:05:47,680 --> 00:05:51,600
xml id is an identifier for delivery

00:05:50,720 --> 00:05:53,840
service

00:05:51,600 --> 00:05:54,880
that's used as you can see above in

00:05:53,840 --> 00:05:56,319
request paths

00:05:54,880 --> 00:05:58,319
but it's mutable because they have

00:05:56,319 --> 00:06:00,240
another identifier

00:05:58,319 --> 00:06:01,759
so if you get that wrong you can break a

00:06:00,240 --> 00:06:04,400
lot of things

00:06:01,759 --> 00:06:05,360
in fact that doesn't even only break the

00:06:04,400 --> 00:06:06,880
api

00:06:05,360 --> 00:06:09,360
that would also break routing and

00:06:06,880 --> 00:06:09,360
caching

00:06:09,520 --> 00:06:13,360
display name is kind of innocuous long

00:06:12,160 --> 00:06:15,360
description

00:06:13,360 --> 00:06:16,560
a delivery service has three of those

00:06:15,360 --> 00:06:18,720
and they have no

00:06:16,560 --> 00:06:19,600
text length which makes the payloads for

00:06:18,720 --> 00:06:22,800
put requests

00:06:19,600 --> 00:06:24,160
gigantic and raw remap text is another

00:06:22,800 --> 00:06:25,759
thing where if you change this

00:06:24,160 --> 00:06:29,039
you can break not only this delivery

00:06:25,759 --> 00:06:29,039
service but possibly others

00:06:29,360 --> 00:06:32,960
now if you compare that to a patch

00:06:31,600 --> 00:06:35,120
request

00:06:32,960 --> 00:06:37,520
this is it this is the entire thing with

00:06:35,120 --> 00:06:40,560
nothing cut out for space

00:06:37,520 --> 00:06:41,680
you specify only what you want to change

00:06:40,560 --> 00:06:43,840
this is something that people have

00:06:41,680 --> 00:06:46,240
wanted for a long time but we didn't

00:06:43,840 --> 00:06:47,520
have the ability to support it until

00:06:46,240 --> 00:06:48,960
recently

00:06:47,520 --> 00:06:51,360
in fact i think that might even still be

00:06:48,960 --> 00:06:54,479
pending i'm not sure if the etags pull

00:06:51,360 --> 00:06:54,479
request has been merged yet

00:06:54,639 --> 00:07:00,880
but the new api best practices

00:06:59,520 --> 00:07:03,039
which have been merged that was one of

00:07:00,880 --> 00:07:06,800
the blueprints that was approved

00:07:03,039 --> 00:07:09,199
specify that endpoints should try to

00:07:06,800 --> 00:07:10,880
implement this so moving forward we

00:07:09,199 --> 00:07:18,240
should be able to do that

00:07:10,880 --> 00:07:18,240
makes things safer and easier uh

00:07:18,479 --> 00:07:25,919
the api best practices document also

00:07:22,720 --> 00:07:28,880
specified what all the

00:07:25,919 --> 00:07:31,360
response codes are for and what things

00:07:28,880 --> 00:07:34,080
you're not allowed to do with them

00:07:31,360 --> 00:07:36,080
which is important because this here is

00:07:34,080 --> 00:07:37,840
a mistake that i made actually

00:07:36,080 --> 00:07:40,400
in one of my pull requests that was

00:07:37,840 --> 00:07:40,400
pointed out

00:07:40,560 --> 00:07:46,479
if you request delivery services

00:07:44,720 --> 00:07:48,720
what you get back isn't a list of all

00:07:46,479 --> 00:07:50,479
the delivery services that exist

00:07:48,720 --> 00:07:53,680
they're implicitly filtered by the ones

00:07:50,479 --> 00:07:53,680
that you have access to

00:07:53,840 --> 00:07:58,479
so i was writing some endpoint i don't

00:07:56,720 --> 00:08:00,240
remember what it was

00:07:58,479 --> 00:08:02,000
but you required you were required to

00:08:00,240 --> 00:08:03,599
identify a delivery service as part of

00:08:02,000 --> 00:08:06,160
it

00:08:03,599 --> 00:08:08,560
so because they were omitted from the

00:08:06,160 --> 00:08:10,000
response of all delivery services

00:08:08,560 --> 00:08:13,360
i thought it'd be appropriate to send

00:08:10,000 --> 00:08:16,800
back a 404 and pretend it doesn't exist

00:08:13,360 --> 00:08:19,039
but that's kind of a worse ux

00:08:16,800 --> 00:08:20,800
and you can discover which delivery

00:08:19,039 --> 00:08:23,440
services exist anyway

00:08:20,800 --> 00:08:24,960
by trying to create some with their ids

00:08:23,440 --> 00:08:27,759
then it'll tell you a delivery service

00:08:24,960 --> 00:08:30,400
without id already exists

00:08:27,759 --> 00:08:32,560
so it doesn't really provide anything to

00:08:30,400 --> 00:08:34,719
hide that information from the user

00:08:32,560 --> 00:08:38,320
and it kind of harms the ability to

00:08:34,719 --> 00:08:40,240
build things on top of the api

00:08:38,320 --> 00:08:43,680
so i know just for me it was useful to

00:08:40,240 --> 00:08:43,680
be able to write these things down

00:08:47,519 --> 00:08:51,040
this is something that has been

00:08:49,440 --> 00:08:53,279
discussed

00:08:51,040 --> 00:08:54,880
i believe only on pull requests up until

00:08:53,279 --> 00:08:57,760
the point it was written

00:08:54,880 --> 00:08:59,680
in the api best practices document is

00:08:57,760 --> 00:09:02,880
that if a component is failing

00:08:59,680 --> 00:09:05,360
because the traffic ops api acts as a

00:09:02,880 --> 00:09:06,880
proxy for a lot of other services you

00:09:05,360 --> 00:09:08,959
don't want to expose

00:09:06,880 --> 00:09:10,959
that those are failing so instead of

00:09:08,959 --> 00:09:13,200
sending back like a

00:09:10,959 --> 00:09:15,440
bad gateway response you should just

00:09:13,200 --> 00:09:18,720
send back an internal server error

00:09:15,440 --> 00:09:20,959
so that way you

00:09:18,720 --> 00:09:22,000
don't have information that you don't

00:09:20,959 --> 00:09:24,000
need and that's available

00:09:22,000 --> 00:09:25,200
in the log files for administrators who

00:09:24,000 --> 00:09:27,600
would want to be able to fix the problem

00:09:25,200 --> 00:09:27,600
anyway

00:09:29,360 --> 00:09:36,160
and just as one more example

00:09:33,600 --> 00:09:38,720
just to be compliant with the http spec

00:09:36,160 --> 00:09:41,120
when you create an object on the server

00:09:38,720 --> 00:09:43,680
the new best practices guidelines

00:09:41,120 --> 00:09:46,080
recommend that you use 201 created

00:09:43,680 --> 00:09:48,080
whereas previously we used 200 okay

00:09:46,080 --> 00:09:51,440
which is a pretty

00:09:48,080 --> 00:09:54,399
boring change i guess

00:09:51,440 --> 00:09:54,399
but it's one that was made

00:09:58,560 --> 00:10:03,680
another thing that we saw a lot of in

00:10:01,360 --> 00:10:06,959
older api versions

00:10:03,680 --> 00:10:11,200
is the exposure of a

00:10:06,959 --> 00:10:14,800
relationship as its own table

00:10:11,200 --> 00:10:16,880
so if you had like we have topologies

00:10:14,800 --> 00:10:18,640
now

00:10:16,880 --> 00:10:20,640
talk was just given about that i think

00:10:18,640 --> 00:10:24,880
like an hour ago

00:10:20,640 --> 00:10:28,000
and under

00:10:24,880 --> 00:10:30,160
similar circumstances as other

00:10:28,000 --> 00:10:31,519
api endpoints have been created what you

00:10:30,160 --> 00:10:35,040
might see is like

00:10:31,519 --> 00:10:36,800
a delivery services underscore

00:10:35,040 --> 00:10:38,079
topologies endpoint

00:10:36,800 --> 00:10:40,560
for delivery services that use

00:10:38,079 --> 00:10:42,560
topologies you would interact with their

00:10:40,560 --> 00:10:45,040
relationship through this

00:10:42,560 --> 00:10:45,839
endpoint in the api because there's a

00:10:45,040 --> 00:10:48,880
join table

00:10:45,839 --> 00:10:51,120
and the join table demands that

00:10:48,880 --> 00:10:53,200
there be an end point to interact with

00:10:51,120 --> 00:10:53,200
it

00:10:53,839 --> 00:10:59,839
but to illustrate how this can get weird

00:10:57,279 --> 00:11:01,680
let's just look at assigning service

00:10:59,839 --> 00:11:04,160
servers to delivery services and vice

00:11:01,680 --> 00:11:07,360
versa each one can be assigned to

00:11:04,160 --> 00:11:08,320
many or none of the other so you can

00:11:07,360 --> 00:11:12,000
look at

00:11:08,320 --> 00:11:14,399
a server's particular delivery services

00:11:12,000 --> 00:11:15,839
manipulate them that way we have this

00:11:14,399 --> 00:11:18,000
endpoint where you can manipulate the

00:11:15,839 --> 00:11:21,279
servers of a delivery service

00:11:18,000 --> 00:11:21,839
which is all fine so far but delivery

00:11:21,279 --> 00:11:23,680
services

00:11:21,839 --> 00:11:25,200
can also be identified this way so we

00:11:23,680 --> 00:11:26,959
have this endpoint

00:11:25,200 --> 00:11:29,279
which isn't the worst thing either but

00:11:26,959 --> 00:11:30,800
now we get a little bit weirder

00:11:29,279 --> 00:11:32,480
we also have this delivery service

00:11:30,800 --> 00:11:34,880
underscore server endpoint

00:11:32,480 --> 00:11:36,160
where you can manipulate the assignment

00:11:34,880 --> 00:11:38,480
the linking between

00:11:36,160 --> 00:11:39,839
any given delivery service and any given

00:11:38,480 --> 00:11:41,760
server

00:11:39,839 --> 00:11:42,959
we also have this which is not the same

00:11:41,760 --> 00:11:45,040
thing

00:11:42,959 --> 00:11:46,560
because the representations it uses are

00:11:45,040 --> 00:11:48,000
entirely different

00:11:46,560 --> 00:11:51,600
but it also still serves the same

00:11:48,000 --> 00:11:51,600
purpose as the one with the underscore

00:11:51,920 --> 00:11:56,079
and then we have this which shows you

00:11:54,399 --> 00:11:57,440
all of the servers that can be assigned

00:11:56,079 --> 00:11:59,040
to a delivery service

00:11:57,440 --> 00:12:01,040
which is essentially just all of those

00:11:59,040 --> 00:12:04,079
that are not all ready and are of the

00:12:01,040 --> 00:12:04,079
type that can be assigned

00:12:04,560 --> 00:12:08,720
so we've got all of these different ways

00:12:07,040 --> 00:12:11,440
to do things

00:12:08,720 --> 00:12:12,959
and they all use different data types

00:12:11,440 --> 00:12:13,920
and their requests and response which

00:12:12,959 --> 00:12:17,279
makes them

00:12:13,920 --> 00:12:19,680
hard to switch between so if you wanted

00:12:17,279 --> 00:12:21,360
to leave one behind

00:12:19,680 --> 00:12:25,760
it gets a little hard for clients

00:12:21,360 --> 00:12:27,440
because they have to update everything

00:12:25,760 --> 00:12:29,440
and you don't want to have to maintain

00:12:27,440 --> 00:12:32,399
all of these so

00:12:29,440 --> 00:12:32,399
there's some friction there

00:12:33,760 --> 00:12:36,959
but the new api guidelines say don't do

00:12:35,839 --> 00:12:38,720
this

00:12:36,959 --> 00:12:41,040
which thankfully we're moving to

00:12:38,720 --> 00:12:43,279
topologies instead because to try to fit

00:12:41,040 --> 00:12:44,639
servers as a property of delivery

00:12:43,279 --> 00:12:47,760
services would be

00:12:44,639 --> 00:12:53,760
insane the payload sizes would increase

00:12:47,760 --> 00:12:56,959
by orders of magnitude

00:12:53,760 --> 00:13:00,079
another minor thing is that

00:12:56,959 --> 00:13:02,160
a lot of api responses in the in version

00:13:00,079 --> 00:13:04,959
1 of the api

00:13:02,160 --> 00:13:07,600
will show you these strings as success

00:13:04,959 --> 00:13:11,279
messages

00:13:07,600 --> 00:13:13,600
and if this were designed today

00:13:11,279 --> 00:13:14,560
what it would look like according to the

00:13:13,600 --> 00:13:17,920
guidelines

00:13:14,560 --> 00:13:21,360
in the docs is something more like this

00:13:17,920 --> 00:13:23,120
where it returns the actual object you

00:13:21,360 --> 00:13:24,320
made and these aren't real key

00:13:23,120 --> 00:13:27,440
these aren't real keys for anybody

00:13:24,320 --> 00:13:27,440
having a heart attack right now

00:13:27,680 --> 00:13:34,399
and it returns this alerts array

00:13:31,279 --> 00:13:36,000
which is the standard way that

00:13:34,399 --> 00:13:38,880
traffic ops endpoints are supposed to

00:13:36,000 --> 00:13:40,639
communicate client hints

00:13:38,880 --> 00:13:42,880
so that way you can write more robust

00:13:40,639 --> 00:13:44,959
tests because

00:13:42,880 --> 00:13:46,639
you don't want to key off of exactly

00:13:44,959 --> 00:13:48,000
what this text is because it's just a

00:13:46,639 --> 00:13:50,320
client hint and it should be able to

00:13:48,000 --> 00:13:50,320
change

00:13:53,760 --> 00:13:57,199
and now let's talk about the data model

00:13:56,000 --> 00:13:58,399
changes

00:13:57,199 --> 00:14:00,959
that we were looking at and were

00:13:58,399 --> 00:14:00,959
proposed

00:14:01,199 --> 00:14:06,160
so one of the big concerns in the

00:14:04,800 --> 00:14:10,000
current data model

00:14:06,160 --> 00:14:11,680
or yeah one of the big concerns in the

00:14:10,000 --> 00:14:14,480
current data model

00:14:11,680 --> 00:14:15,920
is that it's tied very directly to

00:14:14,480 --> 00:14:17,760
database tables like you remember

00:14:15,920 --> 00:14:18,399
earlier the delivery service underscore

00:14:17,760 --> 00:14:21,600
servers

00:14:18,399 --> 00:14:23,279
endpoint is literally just

00:14:21,600 --> 00:14:24,800
a window into the delivery service

00:14:23,279 --> 00:14:28,560
underscore server

00:14:24,800 --> 00:14:29,440
table and when you expose things like

00:14:28,560 --> 00:14:33,760
that

00:14:29,440 --> 00:14:36,320
it tends to cause breakages like

00:14:33,760 --> 00:14:37,279
in the api guidelines like where it says

00:14:36,320 --> 00:14:39,199
you shouldn't have

00:14:37,279 --> 00:14:41,279
relationships as objects if you can help

00:14:39,199 --> 00:14:43,440
it because

00:14:41,279 --> 00:14:45,120
if you have a join table and you're

00:14:43,440 --> 00:14:46,560
exposing all your database tables then

00:14:45,120 --> 00:14:50,160
you're exposing that relationship

00:14:46,560 --> 00:14:54,399
as an object things like that

00:14:50,160 --> 00:14:56,399
and in general the the idea here is that

00:14:54,399 --> 00:14:59,839
an endpoint should be designed so that

00:14:56,399 --> 00:15:03,440
you can fulfill some purpose

00:14:59,839 --> 00:15:06,240
and not just to expose access to some

00:15:03,440 --> 00:15:06,240
stored data

00:15:06,480 --> 00:15:09,680
which is an important distinction

00:15:11,199 --> 00:15:18,399
so a lot of objects in the

00:15:14,800 --> 00:15:19,600
traffic ops api have ids that are

00:15:18,399 --> 00:15:22,880
numeric

00:15:19,600 --> 00:15:24,959
and also names that

00:15:22,880 --> 00:15:26,240
you can't really use to uniquely

00:15:24,959 --> 00:15:29,680
identify them

00:15:26,240 --> 00:15:32,800
but they must be unique so

00:15:29,680 --> 00:15:34,000
that's not always the case but when that

00:15:32,800 --> 00:15:37,120
is the case

00:15:34,000 --> 00:15:38,800
it makes it makes it very difficult to

00:15:37,120 --> 00:15:41,040
remember

00:15:38,800 --> 00:15:42,639
what kind of uh ident or what the

00:15:41,040 --> 00:15:44,160
identifier is for an object you're

00:15:42,639 --> 00:15:46,880
trying to interact with

00:15:44,160 --> 00:15:47,360
it also makes it non-deterministic if

00:15:46,880 --> 00:15:50,160
you

00:15:47,360 --> 00:15:50,800
have scripts that set up environments

00:15:50,160 --> 00:15:53,279
and you

00:15:50,800 --> 00:15:54,880
want to create a bunch of objects then

00:15:53,279 --> 00:15:58,079
the ids you get back

00:15:54,880 --> 00:15:59,040
are all in implementation detail and you

00:15:58,079 --> 00:16:01,519
can't count on

00:15:59,040 --> 00:16:03,839
just the name to uniquely identify

00:16:01,519 --> 00:16:03,839
things

00:16:03,920 --> 00:16:09,360
but using names as ids also solves

00:16:07,600 --> 00:16:12,000
what's called the n plus one query

00:16:09,360 --> 00:16:15,920
problem or at least partially

00:16:12,000 --> 00:16:18,880
which is where if you had

00:16:15,920 --> 00:16:20,240
a topology on a delivery service for

00:16:18,880 --> 00:16:22,800
example

00:16:20,240 --> 00:16:24,560
identified by id but they also have

00:16:22,800 --> 00:16:26,240
names that are unique

00:16:24,560 --> 00:16:28,079
what you want to show to the user in a

00:16:26,240 --> 00:16:30,240
ui is the name

00:16:28,079 --> 00:16:32,320
because the id means nothing to them

00:16:30,240 --> 00:16:34,000
they know what the name means

00:16:32,320 --> 00:16:36,160
so if you get back a list of delivery

00:16:34,000 --> 00:16:38,079
services then you've made your

00:16:36,160 --> 00:16:39,920
one request and then for each of those

00:16:38,079 --> 00:16:41,199
delivery services you have to go look up

00:16:39,920 --> 00:16:43,920
that topology id

00:16:41,199 --> 00:16:44,959
which is where the end comes from so

00:16:43,920 --> 00:16:47,680
ideally

00:16:44,959 --> 00:16:48,880
you want your payloads to be complete

00:16:47,680 --> 00:16:50,560
enough to build a ui

00:16:48,880 --> 00:16:54,160
on top of so that you only have to make

00:16:50,560 --> 00:16:56,000
one query instead of n plus one

00:16:54,160 --> 00:16:58,480
it makes things easier and reduces load

00:16:56,000 --> 00:16:58,480
on the server

00:17:01,600 --> 00:17:07,280
another possible problem with the data

00:17:04,640 --> 00:17:09,760
model that we looked at was

00:17:07,280 --> 00:17:12,959
trying to reduce what what i would call

00:17:09,760 --> 00:17:16,000
harmful levels of reflection

00:17:12,959 --> 00:17:19,280
so traffic ops in the api has

00:17:16,000 --> 00:17:21,760
types which are customizable fully

00:17:19,280 --> 00:17:22,559
you can delete types you can create

00:17:21,760 --> 00:17:25,839
types

00:17:22,559 --> 00:17:30,240
and you can modify types type is a type

00:17:25,839 --> 00:17:30,240
of data so

00:17:30,480 --> 00:17:33,600
they also have a property on them called

00:17:32,640 --> 00:17:37,039
use and table

00:17:33,600 --> 00:17:39,280
and until version three of the api

00:17:37,039 --> 00:17:40,160
you are able to create types of

00:17:39,280 --> 00:17:42,559
arbitrary

00:17:40,160 --> 00:17:43,600
use and table values which is exactly

00:17:42,559 --> 00:17:45,600
what it sounds like

00:17:43,600 --> 00:17:46,720
it's the table in which this type is

00:17:45,600 --> 00:17:49,520
used

00:17:46,720 --> 00:17:50,720
so that ties the database again directly

00:17:49,520 --> 00:17:52,080
to the api

00:17:50,720 --> 00:17:54,240
and makes it very difficult to make

00:17:52,080 --> 00:17:58,480
changes to the to the database

00:17:54,240 --> 00:17:58,480
because it's now a part of our versioned

00:17:58,840 --> 00:18:03,200
api

00:18:00,240 --> 00:18:04,240
and just to illustrate how confusing

00:18:03,200 --> 00:18:05,679
this can get

00:18:04,240 --> 00:18:07,600
let's just look at the process for

00:18:05,679 --> 00:18:09,200
finding out if a server is an edge to

00:18:07,600 --> 00:18:11,280
your cache server

00:18:09,200 --> 00:18:14,160
the most obvious thing to do is check

00:18:11,280 --> 00:18:16,720
its type

00:18:14,160 --> 00:18:18,720
because of some of the reasons i

00:18:16,720 --> 00:18:22,080
mentioned on the last slide

00:18:18,720 --> 00:18:23,360
you can't always trust the name returned

00:18:22,080 --> 00:18:25,760
by the api

00:18:23,360 --> 00:18:27,760
sometimes it'll lie to you under very

00:18:25,760 --> 00:18:30,000
specific circumstances

00:18:27,760 --> 00:18:32,720
the true identifier of a type is its id

00:18:30,000 --> 00:18:35,120
so you look it up by its id

00:18:32,720 --> 00:18:35,840
and then you check to see if it has the

00:18:35,120 --> 00:18:38,640
type name

00:18:35,840 --> 00:18:39,840
edge which exists when you install

00:18:38,640 --> 00:18:43,679
traffic control

00:18:39,840 --> 00:18:46,240
but like any type in api 2.0

00:18:43,679 --> 00:18:47,840
and lower it's totally mutable so you

00:18:46,240 --> 00:18:49,760
can change that name

00:18:47,840 --> 00:18:52,640
you can even delete the type if it's not

00:18:49,760 --> 00:18:52,640
being used by anything

00:18:53,039 --> 00:18:56,880
so if that doesn't match then a lot of

00:18:55,919 --> 00:18:58,640
places

00:18:56,880 --> 00:19:00,480
in the code will use this regular

00:18:58,640 --> 00:19:02,320
expression

00:19:00,480 --> 00:19:03,600
i think some of them actually also only

00:19:02,320 --> 00:19:07,200
check to see if

00:19:03,600 --> 00:19:11,200
the literal word edge is contained just

00:19:07,200 --> 00:19:12,960
somewhere in the type name

00:19:11,200 --> 00:19:15,440
but this is i think the most common way

00:19:12,960 --> 00:19:15,440
i've seen it

00:19:15,760 --> 00:19:21,520
but also that's not

00:19:18,880 --> 00:19:25,360
the only way to check if a cache server

00:19:21,520 --> 00:19:29,120
has the edge to your type

00:19:25,360 --> 00:19:30,559
a lot of places don't have

00:19:29,120 --> 00:19:33,039
i guess it's not fair to say that they

00:19:30,559 --> 00:19:34,480
don't have access to this information

00:19:33,039 --> 00:19:36,320
but they don't look at it a lot of

00:19:34,480 --> 00:19:38,799
places check the profile instead

00:19:36,320 --> 00:19:39,600
and there's a reason for that so when

00:19:38,799 --> 00:19:41,280
you're checking

00:19:39,600 --> 00:19:44,000
if an edge to your cache or if a cache

00:19:41,280 --> 00:19:45,679
server is an edge to your cache server

00:19:44,000 --> 00:19:47,679
then you look at its profile and you

00:19:45,679 --> 00:19:50,160
look its profile up by its id

00:19:47,679 --> 00:19:52,000
and then you check its profile type a

00:19:50,160 --> 00:19:55,840
profile type is not a type

00:19:52,000 --> 00:19:57,520
it's uh it's immutable you can't make

00:19:55,840 --> 00:19:59,600
more you can't modify the ones that

00:19:57,520 --> 00:20:00,320
exist and that's why a lot of places

00:19:59,600 --> 00:20:02,720
will check

00:20:00,320 --> 00:20:04,640
the profile instead because if it's an

00:20:02,720 --> 00:20:06,480
ats profile

00:20:04,640 --> 00:20:08,400
then you know you don't need to look at

00:20:06,480 --> 00:20:10,400
the type name of the profile any

00:20:08,400 --> 00:20:11,919
deeper than this this is for an apache

00:20:10,400 --> 00:20:13,679
traffic server instance

00:20:11,919 --> 00:20:15,039
it's a cache server but that doesn't

00:20:13,679 --> 00:20:16,640
tell you if it's an edge to your cache

00:20:15,039 --> 00:20:18,799
server

00:20:16,640 --> 00:20:20,240
so you have to go a little bit deeper

00:20:18,799 --> 00:20:23,760
and a lot of places will then check the

00:20:20,240 --> 00:20:23,760
profile's name matches this pattern

00:20:24,000 --> 00:20:28,080
so that's a lot of steps to go through

00:20:26,640 --> 00:20:29,840
to try to figure out

00:20:28,080 --> 00:20:32,840
if any given server is an edge to your

00:20:29,840 --> 00:20:35,600
cache server suffers from the n plus one

00:20:32,840 --> 00:20:39,280
problem and it also sort of muddies the

00:20:35,600 --> 00:20:39,280
waters surrounding what a type is

00:20:42,080 --> 00:20:45,360
another problem that you see a lot in

00:20:44,400 --> 00:20:48,480
the data model

00:20:45,360 --> 00:20:51,760
is field abuse

00:20:48,480 --> 00:20:55,760
in air quotes if you have any

00:20:51,760 --> 00:20:57,760
basically unstructured text area

00:20:55,760 --> 00:20:59,520
on a on an object it'll get used to

00:20:57,760 --> 00:21:02,480
house business logic

00:20:59,520 --> 00:21:04,240
which is parsed by some third-party tool

00:21:02,480 --> 00:21:06,159
somewhere

00:21:04,240 --> 00:21:07,520
because they didn't have anywhere else

00:21:06,159 --> 00:21:08,640
to store that information but they

00:21:07,520 --> 00:21:10,080
needed it

00:21:08,640 --> 00:21:11,600
and that makes it difficult to upgrade

00:21:10,080 --> 00:21:13,039
things it makes it difficult to change

00:21:11,600 --> 00:21:14,559
the data model

00:21:13,039 --> 00:21:16,000
because if you change the form of

00:21:14,559 --> 00:21:17,360
something if you start validating a

00:21:16,000 --> 00:21:19,360
field that you haven't been validating

00:21:17,360 --> 00:21:22,159
before then all of a sudden

00:21:19,360 --> 00:21:24,640
somebody's entire work pipeline is just

00:21:22,159 --> 00:21:24,640
busted

00:21:26,559 --> 00:21:34,240
all right now let's talk about

00:21:30,080 --> 00:21:38,000
the considerations when making changes

00:21:34,240 --> 00:21:39,360
and any lessons we learned while doing

00:21:38,000 --> 00:21:42,480
that

00:21:39,360 --> 00:21:44,240
and starting as a lesson

00:21:42,480 --> 00:21:46,159
sometimes you might not think something

00:21:44,240 --> 00:21:49,600
will break the api

00:21:46,159 --> 00:21:52,080
but it will and as an example

00:21:49,600 --> 00:21:54,720
remember earlier i said that creation

00:21:52,080 --> 00:21:56,400
now uses the 201 creator it's

00:21:54,720 --> 00:21:58,799
it's recommended that you use the 201

00:21:56,400 --> 00:22:01,679
created response code

00:21:58,799 --> 00:22:02,640
just to be compliant with the http spec

00:22:01,679 --> 00:22:03,280
you wouldn't think that would break

00:22:02,640 --> 00:22:07,280
anything

00:22:03,280 --> 00:22:11,440
but it does because the go client

00:22:07,280 --> 00:22:13,280
in api versions 2.0 and 1.0

00:22:11,440 --> 00:22:14,880
looked at the response code for any

00:22:13,280 --> 00:22:18,240
given request

00:22:14,880 --> 00:22:20,080
sometimes and decided whether it was

00:22:18,240 --> 00:22:22,000
a success or a failure based on whether

00:22:20,080 --> 00:22:24,320
or not it was literally equal to 200

00:22:22,000 --> 00:22:24,320
okay

00:22:24,840 --> 00:22:29,679
so you can't change

00:22:27,760 --> 00:22:31,679
the response code in old versions

00:22:29,679 --> 00:22:34,480
because people who are using those old

00:22:31,679 --> 00:22:36,640
clients will now see this success code

00:22:34,480 --> 00:22:38,480
but consider it a failure

00:22:36,640 --> 00:22:40,320
and that's why when the server's

00:22:38,480 --> 00:22:44,880
endpoint was rewritten

00:22:40,320 --> 00:22:48,320
only the api v3

00:22:44,880 --> 00:22:50,240
handler for the endpoint used this new

00:22:48,320 --> 00:22:55,840
response code the old ones still use the

00:22:50,240 --> 00:22:55,840
old response code

00:22:56,240 --> 00:23:00,480
something you have to consider when

00:22:58,000 --> 00:23:02,720
you're looking at

00:23:00,480 --> 00:23:04,080
why uh how to fix something that you

00:23:02,720 --> 00:23:08,960
think is bad

00:23:04,080 --> 00:23:12,799
is why did people feel the need to do it

00:23:08,960 --> 00:23:15,200
and a big example of this is

00:23:12,799 --> 00:23:16,960
the types problem that i talked about

00:23:15,200 --> 00:23:19,600
earlier

00:23:16,960 --> 00:23:21,200
people created these types because they

00:23:19,600 --> 00:23:23,600
wanted to be able to group servers

00:23:21,200 --> 00:23:25,600
together like if you have

00:23:23,600 --> 00:23:27,120
a cache server an edge to your cache

00:23:25,600 --> 00:23:29,840
server that's running

00:23:27,120 --> 00:23:32,240
ubuntu 18 and you have some other cache

00:23:29,840 --> 00:23:34,880
servers that are running ubuntu 20

00:23:32,240 --> 00:23:36,559
you might make a type that's like edge

00:23:34,880 --> 00:23:40,480
underscore ubuntu

00:23:36,559 --> 00:23:42,080
18 and edge underscore ubuntu 20.

00:23:40,480 --> 00:23:44,559
and that way you can keep all of your

00:23:42,080 --> 00:23:45,760
cache servers grouped together nicely

00:23:44,559 --> 00:23:47,520
so that if you need to do bulk

00:23:45,760 --> 00:23:49,520
operations on them that depend on what

00:23:47,520 --> 00:23:52,240
operating system version they're running

00:23:49,520 --> 00:23:54,400
you can do that very easily so the

00:23:52,240 --> 00:23:57,520
solution we came up to that was

00:23:54,400 --> 00:24:00,000
tags it's exactly what it sounds like

00:23:57,520 --> 00:24:01,840
you just put a tag on something so

00:24:00,000 --> 00:24:02,480
instead of needing to create a custom

00:24:01,840 --> 00:24:05,919
type

00:24:02,480 --> 00:24:08,159
you can just say this has the ubuntu 18

00:24:05,919 --> 00:24:08,159
tag

00:24:09,679 --> 00:24:16,000
so it's you can't just create

00:24:12,799 --> 00:24:19,520
like a a database upgrade that says

00:24:16,000 --> 00:24:22,799
well if it fits the current criteria

00:24:19,520 --> 00:24:25,919
for an edge to your cache server then

00:24:22,799 --> 00:24:27,679
make its type name just edge and then

00:24:25,919 --> 00:24:28,480
take away people's ability to create new

00:24:27,679 --> 00:24:30,400
types

00:24:28,480 --> 00:24:32,400
because there's a real use case for the

00:24:30,400 --> 00:24:34,720
reasons that people are doing these

00:24:32,400 --> 00:24:34,720
things

00:24:35,919 --> 00:24:39,360
tags also could help with field abuse

00:24:37,840 --> 00:24:40,960
but as it turns out

00:24:39,360 --> 00:24:42,720
that's not actually the main reason that

00:24:40,960 --> 00:24:44,559
people put business logic in there it's

00:24:42,720 --> 00:24:47,520
not for grouping things

00:24:44,559 --> 00:24:49,440
they want key value pairs but that's

00:24:47,520 --> 00:24:52,960
beside the point

00:24:49,440 --> 00:24:54,400
another example of this is profiles and

00:24:52,960 --> 00:24:56,640
basically a profile

00:24:54,400 --> 00:24:58,159
is a collection of parameters that you

00:24:56,640 --> 00:25:00,240
assign to some

00:24:58,159 --> 00:25:01,679
server or delivery service but we don't

00:25:00,240 --> 00:25:05,039
talk about that

00:25:01,679 --> 00:25:08,799
so you can create arbitrary

00:25:05,039 --> 00:25:11,520
configuration on these servers

00:25:08,799 --> 00:25:12,880
most often these parameters being

00:25:11,520 --> 00:25:14,640
associated with a server

00:25:12,880 --> 00:25:16,880
represent some line in some

00:25:14,640 --> 00:25:20,000
configuration file

00:25:16,880 --> 00:25:21,840
so basically you can tune just arbitrary

00:25:20,000 --> 00:25:24,000
parts of a cache server's file system

00:25:21,840 --> 00:25:26,240
with this which is a lot of power

00:25:24,000 --> 00:25:27,520
it also means that you can't validate

00:25:26,240 --> 00:25:28,720
anything

00:25:27,520 --> 00:25:30,720
which makes it a little bit of a

00:25:28,720 --> 00:25:32,000
headache to work with sometimes

00:25:30,720 --> 00:25:33,840
especially in the cases where the

00:25:32,000 --> 00:25:36,799
parameters don't actually

00:25:33,840 --> 00:25:38,240
correspond to a line in a configuration

00:25:36,799 --> 00:25:39,600
file

00:25:38,240 --> 00:25:43,039
which is the case for a lot of

00:25:39,600 --> 00:25:45,200
monitoring properties of cache servers

00:25:43,039 --> 00:25:46,720
so when you're looking at trying to do

00:25:45,200 --> 00:25:48,320
more validation on these

00:25:46,720 --> 00:25:50,000
values because they're they're not

00:25:48,320 --> 00:25:51,440
currently valid validated because they

00:25:50,000 --> 00:25:52,799
can't be because they can represent

00:25:51,440 --> 00:25:56,080
arbitrary

00:25:52,799 --> 00:26:00,159
concepts you can pull out certain

00:25:56,080 --> 00:26:02,159
things but you can't rework the idea

00:26:00,159 --> 00:26:04,799
entirely

00:26:02,159 --> 00:26:05,440
because there is a good reason for it

00:26:04,799 --> 00:26:10,880
and it

00:26:05,440 --> 00:26:13,200
does provide a lot of power

00:26:10,880 --> 00:26:14,880
uh one of the things learned along the

00:26:13,200 --> 00:26:18,159
way while designing it

00:26:14,880 --> 00:26:19,919
was initially this

00:26:18,159 --> 00:26:21,440
this whole design document was supposed

00:26:19,919 --> 00:26:24,720
to eventually wind up

00:26:21,440 --> 00:26:26,159
as uh as its own blueprint as a pull

00:26:24,720 --> 00:26:30,480
request into the

00:26:26,159 --> 00:26:32,799
main repository but clearly

00:26:30,480 --> 00:26:34,000
there were a lot of things looked at and

00:26:32,799 --> 00:26:36,720
there were a lot of

00:26:34,000 --> 00:26:38,640
proposed changes and not all of them

00:26:36,720 --> 00:26:41,200
have been approved not all of them

00:26:38,640 --> 00:26:42,320
going forward will be approved some of

00:26:41,200 --> 00:26:45,360
them will be changed and some will be

00:26:42,320 --> 00:26:48,640
dropped entirely so you have to make

00:26:45,360 --> 00:26:51,279
your changes to the api very small

00:26:48,640 --> 00:26:52,080
basically as small as you can so that

00:26:51,279 --> 00:26:56,559
people can

00:26:52,080 --> 00:26:57,600
digest them easily and also quickly

00:26:56,559 --> 00:27:00,799
because you don't want to read through

00:26:57,600 --> 00:27:00,799
an entire wall of text

00:27:00,960 --> 00:27:04,559
there's a couple couple examples of

00:27:02,799 --> 00:27:08,799
where this was done

00:27:04,559 --> 00:27:10,480
this is a prop um

00:27:08,799 --> 00:27:12,480
this this was actually shot down this

00:27:10,480 --> 00:27:14,400
was made into a blueprint

00:27:12,480 --> 00:27:15,840
but this is the one that was rejected i

00:27:14,400 --> 00:27:17,200
still think though that it illustrates

00:27:15,840 --> 00:27:18,399
the concept of breaking things into

00:27:17,200 --> 00:27:21,600
small chunks

00:27:18,399 --> 00:27:24,080
very well so basically today we have

00:27:21,600 --> 00:27:25,600
servers which encompasses just any kind

00:27:24,080 --> 00:27:26,880
of server that has anything to do with

00:27:25,600 --> 00:27:28,640
the cdn

00:27:26,880 --> 00:27:31,760
because traffic ops is a system of

00:27:28,640 --> 00:27:33,919
record for all servers so

00:27:31,760 --> 00:27:35,840
if you have a machine that just runs

00:27:33,919 --> 00:27:37,360
grafana it's in there it's right next to

00:27:35,840 --> 00:27:40,399
the

00:27:37,360 --> 00:27:42,399
traffic routers so the idea was to break

00:27:40,399 --> 00:27:43,679
them up into all of these disparate

00:27:42,399 --> 00:27:45,520
types

00:27:43,679 --> 00:27:49,039
which like i said was deemed to be just

00:27:45,520 --> 00:27:52,559
too excessive but

00:27:49,039 --> 00:27:52,960
the plan at the time was to introduce

00:27:52,559 --> 00:27:55,919
these

00:27:52,960 --> 00:27:58,799
each separately so instead of having one

00:27:55,919 --> 00:28:00,960
proposal for breaking up all the servers

00:27:58,799 --> 00:28:02,640
you put in a proposal for breaking

00:28:00,960 --> 00:28:04,240
traffic portals out

00:28:02,640 --> 00:28:05,360
then you have just traffic portals and

00:28:04,240 --> 00:28:07,440
then everything else and then you can

00:28:05,360 --> 00:28:09,039
extract things one at a time

00:28:07,440 --> 00:28:12,080
it's a lot easier to do and it's a lot

00:28:09,039 --> 00:28:12,080
easier to read and review

00:28:12,640 --> 00:28:17,440
so and the other example is delivery

00:28:15,840 --> 00:28:18,880
services

00:28:17,440 --> 00:28:20,320
which i've talked about a lot so you can

00:28:18,880 --> 00:28:22,320
probably tell that they were thought

00:28:20,320 --> 00:28:23,919
about a lot

00:28:22,320 --> 00:28:25,840
and delivery services have lots of

00:28:23,919 --> 00:28:29,120
properties these are just like

00:28:25,840 --> 00:28:31,919
two things that were looked at uh this

00:28:29,120 --> 00:28:36,080
top one was actually approved

00:28:31,919 --> 00:28:37,840
and this bottom one is pending but

00:28:36,080 --> 00:28:40,640
the point is that they were done

00:28:37,840 --> 00:28:43,279
separately instead of submitting a giant

00:28:40,640 --> 00:28:44,000
blueprint to change everything about a

00:28:43,279 --> 00:28:46,480
delivery service

00:28:44,000 --> 00:28:46,480
all at once

00:28:49,360 --> 00:28:53,120
and the hardest lesson to learn for me

00:28:52,640 --> 00:28:56,399
at least

00:28:53,120 --> 00:28:59,520
was that knowing something is bad isn't

00:28:56,399 --> 00:29:03,039
enough to get rid of it because

00:28:59,520 --> 00:29:06,240
sometimes you have a set of

00:29:03,039 --> 00:29:07,840
power that just cannot be replicated

00:29:06,240 --> 00:29:10,159
in what you might consider to be a more

00:29:07,840 --> 00:29:12,640
sane way

00:29:10,159 --> 00:29:13,440
and i think the poster child for this is

00:29:12,640 --> 00:29:15,919
the any map

00:29:13,440 --> 00:29:18,640
delivery service i don't think i've ever

00:29:15,919 --> 00:29:20,960
heard anyone say anything truly positive

00:29:18,640 --> 00:29:22,559
about any maps i think neutral is as

00:29:20,960 --> 00:29:25,760
positive as it gets

00:29:22,559 --> 00:29:26,240
but the thing is most people generally

00:29:25,760 --> 00:29:28,399
agree

00:29:26,240 --> 00:29:29,440
that this is going to be around for the

00:29:28,399 --> 00:29:32,080
foreseeable future

00:29:29,440 --> 00:29:32,799
because what an any map delivery service

00:29:32,080 --> 00:29:34,960
is

00:29:32,799 --> 00:29:36,880
is instead of doing any routing through

00:29:34,960 --> 00:29:40,000
normal cdn means

00:29:36,880 --> 00:29:42,559
you just put a raw line somewhere in an

00:29:40,000 --> 00:29:43,919
apache traffic server configuration file

00:29:42,559 --> 00:29:46,399
and then clients

00:29:43,919 --> 00:29:47,360
use that to do their thing which makes

00:29:46,399 --> 00:29:50,240
it

00:29:47,360 --> 00:29:52,159
pretty dangerous and pretty obscure

00:29:50,240 --> 00:29:53,840
because the way that raw

00:29:52,159 --> 00:29:55,600
line is handled is different for this

00:29:53,840 --> 00:29:57,840
type of delivery service than any other

00:29:55,600 --> 00:29:57,840
type

00:29:58,399 --> 00:30:02,159
but because of the way it works you're

00:30:01,279 --> 00:30:05,440
able to do

00:30:02,159 --> 00:30:07,120
some extremely complex things with very

00:30:05,440 --> 00:30:10,399
small changes

00:30:07,120 --> 00:30:12,080
and there's just no way that i at least

00:30:10,399 --> 00:30:13,600
or anybody

00:30:12,080 --> 00:30:16,000
that i talk to in the working group

00:30:13,600 --> 00:30:19,919
about it could think of

00:30:16,000 --> 00:30:23,840
to replicate that so

00:30:19,919 --> 00:30:23,840
it's gonna stick around

00:30:25,039 --> 00:30:29,520
and finally doing something better can

00:30:27,440 --> 00:30:33,760
sometimes mean that you have to

00:30:29,520 --> 00:30:33,760
put in some weird logic

00:30:34,320 --> 00:30:40,960
like for the all cdn so

00:30:38,159 --> 00:30:42,159
servers currently represent every kind

00:30:40,960 --> 00:30:46,080
of server

00:30:42,159 --> 00:30:48,640
and all servers must be in some cdn

00:30:46,080 --> 00:30:49,200
however for some types of servers that

00:30:48,640 --> 00:30:51,840
doesn't

00:30:49,200 --> 00:30:52,559
make the most sense because their

00:30:51,840 --> 00:30:54,960
operation

00:30:52,559 --> 00:30:57,120
isn't restricted to a single cdn the

00:30:54,960 --> 00:30:59,600
most obvious one is traffic portal which

00:30:57,120 --> 00:31:02,720
is the ui for traffic ops

00:30:59,600 --> 00:31:04,080
so by design and definition it doesn't

00:31:02,720 --> 00:31:06,000
operate within a single cdn

00:31:04,080 --> 00:31:07,200
because it shows you all of them it

00:31:06,000 --> 00:31:07,760
shows you everything you have permission

00:31:07,200 --> 00:31:12,000
to see

00:31:07,760 --> 00:31:12,000
it's the ui into the entire atc system

00:31:12,080 --> 00:31:18,559
but you can't just get rid

00:31:15,440 --> 00:31:22,559
of the all cdn

00:31:18,559 --> 00:31:25,919
the lcdn being this special

00:31:22,559 --> 00:31:29,840
string that you use to name a cdn

00:31:25,919 --> 00:31:32,399
that encompasses all cdns in every

00:31:29,840 --> 00:31:34,720
s almost every sense it behaves pretty

00:31:32,399 --> 00:31:37,840
much exactly like a cdn

00:31:34,720 --> 00:31:39,279
of any other name but specifically

00:31:37,840 --> 00:31:41,919
there's a lot of code that looks

00:31:39,279 --> 00:31:43,760
at cdn names and does things differently

00:31:41,919 --> 00:31:47,519
or sometimes not at all

00:31:43,760 --> 00:31:49,279
if their name is all

00:31:47,519 --> 00:31:51,039
because this is just meant for grouping

00:31:49,279 --> 00:31:52,080
things that don't truly belong to anyone

00:31:51,039 --> 00:31:54,480
cdn

00:31:52,080 --> 00:31:56,159
and you can't really get rid of it

00:31:54,480 --> 00:31:57,919
immediately because

00:31:56,159 --> 00:32:00,000
if you do that you break old api

00:31:57,919 --> 00:32:03,440
versions

00:32:00,000 --> 00:32:04,640
you can't give back null somewhere where

00:32:03,440 --> 00:32:07,840
null used to not

00:32:04,640 --> 00:32:12,159
be allowed that'll break chain

00:32:07,840 --> 00:32:14,240
that'll break clients so even though

00:32:12,159 --> 00:32:16,240
you can make data changes that make the

00:32:14,240 --> 00:32:17,360
all cdn not necessary it has to stick

00:32:16,240 --> 00:32:20,720
around

00:32:17,360 --> 00:32:20,720
for at least a major version

00:32:22,159 --> 00:32:28,880
and that's uh that's all the changes and

00:32:26,000 --> 00:32:30,320
lessons that we learned the source code

00:32:28,880 --> 00:32:30,799
for this presentation is available on

00:32:30,320 --> 00:32:34,399
github

00:32:30,799 --> 00:32:36,640
if you click on it on the slide so

00:32:34,399 --> 00:32:38,240
sweet thanks brennan um we have a couple

00:32:36,640 --> 00:32:40,720
of questions

00:32:38,240 --> 00:32:42,080
that popped into the chat uh rob asked

00:32:40,720 --> 00:32:45,440
how does that interact

00:32:42,080 --> 00:32:47,440
with it with down keys

00:32:45,440 --> 00:32:50,080
example given hostname and port and he's

00:32:47,440 --> 00:32:51,919
talking about names not ids

00:32:50,080 --> 00:32:53,279
yeah so like i said there are some cases

00:32:51,919 --> 00:32:56,159
where you can't

00:32:53,279 --> 00:32:57,840
identify something purely by name like

00:32:56,159 --> 00:33:00,320
in the case of servers where we want

00:32:57,840 --> 00:33:02,480
host names to be able to be

00:33:00,320 --> 00:33:05,200
the same for two servers so that you can

00:33:02,480 --> 00:33:08,720
run multiple services on the same server

00:33:05,200 --> 00:33:09,840
and uh the way the best practices

00:33:08,720 --> 00:33:13,679
document handled that

00:33:09,840 --> 00:33:16,720
was if you have an object

00:33:13,679 --> 00:33:19,440
it must be identifiable by one property

00:33:16,720 --> 00:33:20,000
so it says not to use compound keys and

00:33:19,440 --> 00:33:24,480
that's why

00:33:20,000 --> 00:33:27,200
servers would still have an id

00:33:24,480 --> 00:33:27,760
gotcha okay and then the next question

00:33:27,200 --> 00:33:29,679
um

00:33:27,760 --> 00:33:31,200
are there recommendations around what to

00:33:29,679 --> 00:33:32,960
use for api tracing

00:33:31,200 --> 00:33:35,760
since there are multiple api versions

00:33:32,960 --> 00:33:41,360
that work together

00:33:35,760 --> 00:33:41,360
uh api tracing in what sense

00:33:43,519 --> 00:33:47,519
we're gonna have to wait for rogers

00:33:46,320 --> 00:33:51,039
fourier to

00:33:47,519 --> 00:33:54,159
type there um

00:33:51,039 --> 00:33:54,559
i'm guessing she's asking how to know

00:33:54,159 --> 00:33:59,440
which

00:33:54,559 --> 00:34:02,880
version to use um on each component

00:33:59,440 --> 00:34:02,880
maybe uh

00:34:03,440 --> 00:34:07,360
well i guess in that case what we've

00:34:06,880 --> 00:34:10,399
done

00:34:07,360 --> 00:34:11,280
is we support three api versions at a

00:34:10,399 --> 00:34:13,839
time

00:34:11,280 --> 00:34:15,760
a legacy version a stable version and

00:34:13,839 --> 00:34:17,359
the version under development

00:34:15,760 --> 00:34:19,520
and when the version under development

00:34:17,359 --> 00:34:21,599
becomes a stable version you just

00:34:19,520 --> 00:34:23,599
change the version that the components

00:34:21,599 --> 00:34:25,359
use yeah what apis

00:34:23,599 --> 00:34:26,720
yeah in the sense that when portal calls

00:34:25,359 --> 00:34:28,560
an api

00:34:26,720 --> 00:34:30,240
and ops calls other components how do we

00:34:28,560 --> 00:34:32,320
tell what's going on

00:34:30,240 --> 00:34:33,760
um what api's getting built for our

00:34:32,320 --> 00:34:35,760
workflow

00:34:33,760 --> 00:34:38,000
you can find which api version is being

00:34:35,760 --> 00:34:40,960
called in the logs

00:34:38,000 --> 00:34:42,159
yeah the logs have the full request path

00:34:40,960 --> 00:34:44,159
so the api version

00:34:42,159 --> 00:34:45,839
i don't show it in the urls because it

00:34:44,159 --> 00:34:49,520
gets tedious

00:34:45,839 --> 00:34:52,800
but the urls always include slash api

00:34:49,520 --> 00:34:52,800
version number at the front

00:34:54,879 --> 00:34:58,159
so it's always very explicit

00:34:59,599 --> 00:35:02,720
does ui show us if something failed no

00:35:02,320 --> 00:35:05,359
uh

00:35:02,720 --> 00:35:05,920
i'll let you answer that brian it

00:35:05,359 --> 00:35:08,480
doesn't

00:35:05,920 --> 00:35:10,160
show you it shows you if a request

00:35:08,480 --> 00:35:10,880
failed because it's your fault but if

00:35:10,160 --> 00:35:12,560
it's

00:35:10,880 --> 00:35:14,560
because something's going wrong on the

00:35:12,560 --> 00:35:16,400
server the ui just says

00:35:14,560 --> 00:35:17,760
500 internal server error and that's all

00:35:16,400 --> 00:35:18,800
the information that the client gets

00:35:17,760 --> 00:35:21,119
back

00:35:18,800 --> 00:35:23,520
yeah yeah we use the logs for all of

00:35:21,119 --> 00:35:25,839
that information

00:35:23,520 --> 00:35:26,800
uh we we pipe all of the access logs

00:35:25,839 --> 00:35:31,040
into our

00:35:26,800 --> 00:35:33,839
login analytics system

00:35:31,040 --> 00:35:33,839
another question

00:35:43,850 --> 00:35:46,940
[Music]

00:35:48,880 --> 00:36:01,760
what time is the next mission 1255 okay

00:35:59,599 --> 00:36:03,680
my path left i've seen microservices log

00:36:01,760 --> 00:36:04,320
activities that is pushed into a log

00:36:03,680 --> 00:36:07,680
stash

00:36:04,320 --> 00:36:10,240
or oso and then there is the trace id

00:36:07,680 --> 00:36:13,839
so we can look at a single place to tell

00:36:10,240 --> 00:36:13,839
what happened

00:36:17,119 --> 00:36:26,079
or so yeah like like we were saying

00:36:22,720 --> 00:36:27,760
you can definitely have some

00:36:26,079 --> 00:36:30,240
sort of application that takes all the

00:36:27,760 --> 00:36:33,280
logs and put them puts them into a

00:36:30,240 --> 00:36:36,000
system um we happen to do that with our

00:36:33,280 --> 00:36:37,599
internal logging analytics system

00:36:36,000 --> 00:36:39,440
um but you could do that with like an

00:36:37,599 --> 00:36:42,079
elk type solution or splunk

00:36:39,440 --> 00:36:44,079
yeah and uh requests if you're concerned

00:36:42,079 --> 00:36:45,760
about seeing like a bunch of requests

00:36:44,079 --> 00:36:47,359
in the logs because they're all being

00:36:45,760 --> 00:36:49,839
serviced at the same time

00:36:47,359 --> 00:36:51,839
requests do have an id which i think

00:36:49,839 --> 00:36:54,160
might be what you mean by trace id

00:36:51,839 --> 00:36:57,520
so you can associate the correct log

00:36:54,160 --> 00:36:57,520
lines with the correct request

00:37:04,720 --> 00:37:08,400
all right well thanks again brennan um

00:37:06,640 --> 00:37:10,960
we're out of time we can any more

00:37:08,400 --> 00:37:12,560
questions we can just move them to slack

00:37:10,960 --> 00:37:15,599
but really appreciate it brennan this

00:37:12,560 --> 00:37:15,599
was really helpful

00:37:16,480 --> 00:37:23,839
cool all right see ya

00:37:33,599 --> 00:37:35,680

YouTube URL: https://www.youtube.com/watch?v=3Wj7hIro0GY


