Title: Nicholas Kolba | FINOS | OSSF 2020: Powering Micro UIs with FDC3
Publication date: 2020-12-22
Playlist: FINOS Open Source Strategy Forum 2020
Description: 
	Nicholas Kolba | FINOS | OSSF 2020: Powering Micro UIs with FDC3 | FINOS OSSF 2020

Nicholas Kolba, Global Head of Platform, Genesis Global

Powering Micro UIs with FDC3 - OSSF 2020

The use of Micro-UIs (or Micro Frontends) is a relatively new pattern for splitting complex monoliths into vertically integrated components. This is of particular interest to financial application development, since data dense views and complex workflows can be broken into logical and re-mixable parts. In this session, we will demonstrate how key features of FDC3 1.1 and emerging FDC3 standards can be used to build micro-ui based workflows that span across applications and components from multiple providers and how the genesis Low Code Application Platform (LCAP) is leveraging open source web technologies and the FDC3 standards to transform application development in finance.

Nicholas Kolba's BIO

Nick has been a contributor to open source development in finance for over a decade - most notably, leading the creation of the widely adopted FDC3 interoperability standard and as a board member at FINOS. As Global Head of Platform at genesis he is focused on delivering the firm’s technology strategy around its Low Code Application Platform. Nick has an extensive background in technology, including serving as CPO and CTO at OpenFin, technology director at Thomson Reuters, and VP of Product at AdFin.

-=-=-=-=-

This video is from the FINOS / Linux Foundation Open Source Strategy Forum (OSSF) Virtual 2020. 

►►For free access to all 2020 videos from the conference - please register HERE: https://events.linuxfoundation.org/open-source-strategy-forum/register/
 
►► More information HERE: https://events.linuxfoundation.org/open-source-strategy-forum/
►► 2020 Schedule HERE: https://events.linuxfoundation.org/open-source-strategy-forum/program/schedule/

Learn more about FINOS and how we deliver the power of open source to financial services:
►► FINOS: https://www.finos.org/
Captions: 
	00:00:01,720 --> 00:00:06,809
[Music]

00:00:07,759 --> 00:00:10,800
hello

00:00:08,400 --> 00:00:13,200
and welcome to powering micro uis with

00:00:10,800 --> 00:00:16,480
ftc 3.

00:00:13,200 --> 00:00:16,880
i'm nick colba i am co-chair of the ftc

00:00:16,480 --> 00:00:19,279
00:00:16,880 --> 00:00:21,920
project at finos and the global head of

00:00:19,279 --> 00:00:24,880
platform at genesis

00:00:21,920 --> 00:00:26,640
first of all i want to thank finnos and

00:00:24,880 --> 00:00:27,599
the linux foundation for all their

00:00:26,640 --> 00:00:30,800
amazing work

00:00:27,599 --> 00:00:32,719
in organizing and hosting ossf

00:00:30,800 --> 00:00:34,480
and in general for supporting open

00:00:32,719 --> 00:00:36,640
source development and finance

00:00:34,480 --> 00:00:39,120
it's been an incredible long journey

00:00:36,640 --> 00:00:41,760
with finnos for me personally and

00:00:39,120 --> 00:00:43,040
they're an amazing group of people and

00:00:41,760 --> 00:00:45,760
it's just

00:00:43,040 --> 00:00:48,399
terrific and humbling to work with them

00:00:45,760 --> 00:00:51,840
over the years

00:00:48,399 --> 00:00:53,520
a little bit about genesis genesis is

00:00:51,840 --> 00:00:55,920
the only financial markets

00:00:53,520 --> 00:00:57,600
native low code application platform or

00:00:55,920 --> 00:01:00,399
lcap

00:00:57,600 --> 00:01:02,879
we have a library that provides

00:01:00,399 --> 00:01:08,159
ready-to-build building blocks

00:01:02,879 --> 00:01:10,960
that address complex financial workflows

00:01:08,159 --> 00:01:12,080
our platform enables us to build highly

00:01:10,960 --> 00:01:15,840
performant scalable

00:01:12,080 --> 00:01:18,320
and secure solutions and to do this

00:01:15,840 --> 00:01:20,720
much faster than if you're building from

00:01:18,320 --> 00:01:20,720
scratch

00:01:22,240 --> 00:01:26,000
so many of you probably are very

00:01:24,479 --> 00:01:29,119
familiar with fdc3

00:01:26,000 --> 00:01:31,360
already but i do think it would be good

00:01:29,119 --> 00:01:34,880
to give a quick tour and background

00:01:31,360 --> 00:01:38,880
onto the history and purpose of ftc3

00:01:34,880 --> 00:01:41,119
so ftc3 itself is a standard

00:01:38,880 --> 00:01:42,960
for application interoperability and

00:01:41,119 --> 00:01:46,560
finance

00:01:42,960 --> 00:01:50,399
it covers three main areas app directory

00:01:46,560 --> 00:01:54,000
or describing the metadata for catalog

00:01:50,399 --> 00:01:57,439
of applications that can interoperate

00:01:54,000 --> 00:02:00,479
context data intense which is a taxonomy

00:01:57,439 --> 00:02:02,560
of the verbs and nouns uh

00:02:00,479 --> 00:02:03,920
describing interactivity between

00:02:02,560 --> 00:02:07,439
applications

00:02:03,920 --> 00:02:11,440
and then finally the api which is

00:02:07,439 --> 00:02:14,239
um a standard for the

00:02:11,440 --> 00:02:15,760
interface between applications and

00:02:14,239 --> 00:02:17,599
platforms

00:02:15,760 --> 00:02:23,120
or containers that provide the

00:02:17,599 --> 00:02:26,480
interoperability to them

00:02:23,120 --> 00:02:29,920
so fdc3 itself started way back

00:02:26,480 --> 00:02:33,120
in october of 2017

00:02:29,920 --> 00:02:36,720
so over three years ago uh we started

00:02:33,120 --> 00:02:39,519
open fin with a slide deck

00:02:36,720 --> 00:02:40,560
and about 12 technologists from across

00:02:39,519 --> 00:02:44,160
the industry

00:02:40,560 --> 00:02:48,000
we got people together and uh

00:02:44,160 --> 00:02:51,920
started this group we broke up into four

00:02:48,000 --> 00:02:54,800
working groups at the time and

00:02:51,920 --> 00:02:55,519
built a lot of momentum there were

00:02:54,800 --> 00:02:58,640
roughly

00:02:55,519 --> 00:03:01,120
40 community firms involved with

00:02:58,640 --> 00:03:03,120
the creation and the feedback phase of

00:03:01,120 --> 00:03:04,879
the initial standards

00:03:03,120 --> 00:03:08,319
and those standards themselves were

00:03:04,879 --> 00:03:11,200
released in march of 2019

00:03:08,319 --> 00:03:12,000
uh in the meantime ftc three been

00:03:11,200 --> 00:03:16,840
contributed

00:03:12,000 --> 00:03:18,800
into finos uh and we launched

00:03:16,840 --> 00:03:22,000
ftc3.finos.org

00:03:18,800 --> 00:03:25,440
and created a lot of tooling around

00:03:22,000 --> 00:03:30,319
supporting the standard and

00:03:25,440 --> 00:03:32,159
in this year in march we had our 1.1

00:03:30,319 --> 00:03:34,239
release which was a really major

00:03:32,159 --> 00:03:37,599
improvement to the standard

00:03:34,239 --> 00:03:41,760
and we've also seen a lot of

00:03:37,599 --> 00:03:42,480
production implementations go into the

00:03:41,760 --> 00:03:45,840
wild

00:03:42,480 --> 00:03:46,400
over the past year or more some notables

00:03:45,840 --> 00:03:49,519
including

00:03:46,400 --> 00:03:52,560
factset jpmorgan obviously

00:03:49,519 --> 00:03:55,280
open fin glue 42 and

00:03:52,560 --> 00:03:57,519
kosaic ensemble and there are many many

00:03:55,280 --> 00:03:57,519
more

00:03:57,680 --> 00:04:01,920
and finally this year we've been focused

00:04:00,000 --> 00:04:04,159
on the one two release

00:04:01,920 --> 00:04:05,280
which i'm going to touch on a little bit

00:04:04,159 --> 00:04:10,000
and uh

00:04:05,280 --> 00:04:15,840
we're hoping to put the 1.2

00:04:10,000 --> 00:04:15,840
ftc 3 release out in q1 of next year

00:04:18,079 --> 00:04:25,919
so what was the motivation behind ftc3

00:04:22,800 --> 00:04:27,759
uh so let's take a little bit of a look

00:04:25,919 --> 00:04:30,880
at what the world looked like

00:04:27,759 --> 00:04:33,680
before fdc3

00:04:30,880 --> 00:04:34,960
so apps get built as always as they

00:04:33,680 --> 00:04:37,520
always do

00:04:34,960 --> 00:04:39,680
and you have different apps coming from

00:04:37,520 --> 00:04:44,320
different development teams

00:04:39,680 --> 00:04:47,520
and when they want to interoperate often

00:04:44,320 --> 00:04:49,520
developer a will talk to developer b

00:04:47,520 --> 00:04:53,520
and they may create some informal

00:04:49,520 --> 00:04:53,520
bilateral protocols or apis

00:04:54,720 --> 00:04:59,120
as this matures they may uh create a

00:04:58,160 --> 00:05:02,320
more specific

00:04:59,120 --> 00:05:04,960
proprietary api that they can go through

00:05:02,320 --> 00:05:06,560
so developers don't have to kind of like

00:05:04,960 --> 00:05:08,840
send emails back and forth or get on the

00:05:06,560 --> 00:05:11,280
phone to figure out how to make things

00:05:08,840 --> 00:05:14,400
work

00:05:11,280 --> 00:05:16,800
then as this scales and we get

00:05:14,400 --> 00:05:17,919
more applications and more developers

00:05:16,800 --> 00:05:21,120
into the mix

00:05:17,919 --> 00:05:24,320
this starts to get really quite messy

00:05:21,120 --> 00:05:27,680
as developers need to track

00:05:24,320 --> 00:05:29,919
different apis that may be formal

00:05:27,680 --> 00:05:31,520
or informal across different

00:05:29,919 --> 00:05:35,199
applications

00:05:31,520 --> 00:05:38,880
and try to make everything work

00:05:35,199 --> 00:05:42,240
so with ftc3

00:05:38,880 --> 00:05:45,280
all everybody just speaks ftc3

00:05:42,240 --> 00:05:49,280
so each developer only needs to

00:05:45,280 --> 00:05:51,360
speak to this one api and

00:05:49,280 --> 00:05:52,479
as more applications are dropped into an

00:05:51,360 --> 00:05:55,039
environment

00:05:52,479 --> 00:05:56,240
they'll simply because they're talking

00:05:55,039 --> 00:06:00,240
ftc3

00:05:56,240 --> 00:06:00,240
be able to interoperate with each other

00:06:01,759 --> 00:06:06,960
fdc3 also works across a

00:06:04,960 --> 00:06:08,800
number of different technologies

00:06:06,960 --> 00:06:12,720
including as mentioned before

00:06:08,800 --> 00:06:16,080
open fin ensemble blue 42 but also any

00:06:12,720 --> 00:06:18,800
electron uh based container also

00:06:16,080 --> 00:06:20,160
runs in wpf there's implementations in

00:06:18,800 --> 00:06:22,160
java as well

00:06:20,160 --> 00:06:23,280
and there's even implementations

00:06:22,160 --> 00:06:24,960
directly in chrome

00:06:23,280 --> 00:06:27,840
which you'll actually see a little bit

00:06:24,960 --> 00:06:27,840
about later

00:06:29,039 --> 00:06:36,880
so let's talk about micro uis

00:06:33,520 --> 00:06:37,600
so a micro ui is kind of a you know it's

00:06:36,880 --> 00:06:40,880
become

00:06:37,600 --> 00:06:44,000
a bit of a buzzword but

00:06:40,880 --> 00:06:47,199
what these are really about is uh

00:06:44,000 --> 00:06:48,319
creating small self-contained front ends

00:06:47,199 --> 00:06:52,319
that can be

00:06:48,319 --> 00:06:55,680
put together kind of like lego bricks

00:06:52,319 --> 00:06:56,560
so micro services have been hugely

00:06:55,680 --> 00:06:58,479
successful

00:06:56,560 --> 00:07:00,720
in enabling platforms to scale on the

00:06:58,479 --> 00:07:04,080
back-end side of things

00:07:00,720 --> 00:07:05,520
but until recently uh most micro service

00:07:04,080 --> 00:07:07,440
platforms

00:07:05,520 --> 00:07:09,599
uh have been fronted by what are

00:07:07,440 --> 00:07:12,800
monolithic uis

00:07:09,599 --> 00:07:14,400
so here we have all of your nicely

00:07:12,800 --> 00:07:16,960
decoupled microservices

00:07:14,400 --> 00:07:19,440
going into a single monolithic

00:07:16,960 --> 00:07:23,039
application

00:07:19,440 --> 00:07:26,000
so when we create

00:07:23,039 --> 00:07:27,199
an analogous set of services using micro

00:07:26,000 --> 00:07:30,000
uis

00:07:27,199 --> 00:07:31,280
uh you can scale the front end in in a

00:07:30,000 --> 00:07:35,120
kind of analogous way

00:07:31,280 --> 00:07:35,120
to micro services on the back end

00:07:36,319 --> 00:07:41,840
so design systems which have been very

00:07:39,680 --> 00:07:44,720
popular

00:07:41,840 --> 00:07:46,479
in application development are only

00:07:44,720 --> 00:07:47,440
concerned with visual language but micro

00:07:46,479 --> 00:07:52,080
uis

00:07:47,440 --> 00:07:52,080
create a functional workflow language

00:07:52,160 --> 00:07:56,319
they create building blocks that combine

00:07:54,240 --> 00:07:58,720
both front end experience and back-end

00:07:56,319 --> 00:08:01,039
functionality and data

00:07:58,720 --> 00:08:03,199
so let's look at some of the major

00:08:01,039 --> 00:08:05,520
advantages of micro uis and application

00:08:03,199 --> 00:08:08,800
development

00:08:05,520 --> 00:08:11,199
so big one is reusability

00:08:08,800 --> 00:08:12,240
micro uis make it very easy to stamp out

00:08:11,199 --> 00:08:15,840
front ends

00:08:12,240 --> 00:08:19,520
into minor with minor variants

00:08:15,840 --> 00:08:22,160
uh flexibility is also critical and you

00:08:19,520 --> 00:08:25,360
can configure micro uis very easily

00:08:22,160 --> 00:08:28,879
uh using them as building blocks to make

00:08:25,360 --> 00:08:28,879
very different shapes

00:08:29,360 --> 00:08:36,080
and finally uh personalization

00:08:32,719 --> 00:08:38,479
the uh componentized ui makes it easy

00:08:36,080 --> 00:08:41,120
for end users to configure the front end

00:08:38,479 --> 00:08:42,479
and to meet to meet their specific needs

00:08:41,120 --> 00:08:44,959
uh it also makes it

00:08:42,479 --> 00:08:46,800
easier for applications to fit into an

00:08:44,959 --> 00:08:49,600
end user's preferred workflow

00:08:46,800 --> 00:08:50,399
through embeddable components there are

00:08:49,600 --> 00:08:52,640
examples of

00:08:50,399 --> 00:08:54,000
embeddable components everywhere from

00:08:52,640 --> 00:08:57,120
google maps widgets

00:08:54,000 --> 00:09:00,320
to uh sign in with x

00:08:57,120 --> 00:09:01,279
sso buttons embedding symphony or other

00:09:00,320 --> 00:09:05,519
chats into

00:09:01,279 --> 00:09:08,880
applications or embedding youtube videos

00:09:05,519 --> 00:09:10,720
these are all examples of self-contained

00:09:08,880 --> 00:09:15,680
micro uis that can be

00:09:10,720 --> 00:09:15,680
uh injected into a workflow

00:09:16,080 --> 00:09:19,440
so here's an example of micro uis that

00:09:18,640 --> 00:09:22,480
we've built

00:09:19,440 --> 00:09:25,680
using the genesis platform um

00:09:22,480 --> 00:09:27,680
actually in this particular case these

00:09:25,680 --> 00:09:29,120
these uh applications are running in

00:09:27,680 --> 00:09:30,560
openfin

00:09:29,120 --> 00:09:33,120
and using as a container for the

00:09:30,560 --> 00:09:35,440
presentation layer and this allows

00:09:33,120 --> 00:09:36,720
each ui to run as its own app but to be

00:09:35,440 --> 00:09:38,959
composable

00:09:36,720 --> 00:09:40,000
with with the other applications in

00:09:38,959 --> 00:09:44,959
these kinds of

00:09:40,000 --> 00:09:44,959
tabs or split

00:09:48,839 --> 00:09:51,839
layouts

00:09:52,080 --> 00:09:58,320
so but the micro ui

00:09:55,279 --> 00:10:01,360
approach isn't without its challenges

00:09:58,320 --> 00:10:04,240
uh when we give up

00:10:01,360 --> 00:10:06,160
the control of a monolithic application

00:10:04,240 --> 00:10:07,760
front end

00:10:06,160 --> 00:10:10,079
there are a number of new problems that

00:10:07,760 --> 00:10:10,079
emerge

00:10:11,760 --> 00:10:18,399
the first one we can think about is

00:10:15,360 --> 00:10:18,880
kind of component inflation so in this

00:10:18,399 --> 00:10:22,240
case if

00:10:18,880 --> 00:10:24,399
components aren't shareable uh the reuse

00:10:22,240 --> 00:10:25,760
of those components can create kind of

00:10:24,399 --> 00:10:29,760
bloat noise and

00:10:25,760 --> 00:10:33,040
poor user experience um this means that

00:10:29,760 --> 00:10:35,519
because it's so you know because these

00:10:33,040 --> 00:10:36,959
components can proliferate so easily we

00:10:35,519 --> 00:10:40,480
just end up with

00:10:36,959 --> 00:10:43,360
a lot of access noise within

00:10:40,480 --> 00:10:45,040
our user interface so common services

00:10:43,360 --> 00:10:47,279
and capabilities

00:10:45,040 --> 00:10:48,079
uh and information can just end up being

00:10:47,279 --> 00:10:51,120
repeated

00:10:48,079 --> 00:10:52,880
across lots of places

00:10:51,120 --> 00:10:55,440
a really simple example of this

00:10:52,880 --> 00:10:56,000
phenomena is the proliferation of tabs

00:10:55,440 --> 00:10:59,200
right we

00:10:56,000 --> 00:10:59,200
experience in browsers

00:10:59,440 --> 00:11:02,880
now consider that versus repurposing of

00:11:02,079 --> 00:11:06,079
apps

00:11:02,880 --> 00:11:09,680
when we go across contexts in mobile

00:11:06,079 --> 00:11:12,079
where we we don't end up with you know

00:11:09,680 --> 00:11:12,800
20 different instances of the google

00:11:12,079 --> 00:11:17,040
maps app

00:11:12,800 --> 00:11:20,160
opening up every time we open a new map

00:11:17,040 --> 00:11:23,279
well if you're running in a browser

00:11:20,160 --> 00:11:23,279
that can very well happen

00:11:24,640 --> 00:11:31,279
another issue is discoverability uh

00:11:28,160 --> 00:11:31,839
when workflows are divided up into many

00:11:31,279 --> 00:11:34,800
different

00:11:31,839 --> 00:11:35,920
independent components how is an end

00:11:34,800 --> 00:11:38,079
user

00:11:35,920 --> 00:11:39,680
going to discover relevant content and

00:11:38,079 --> 00:11:42,160
functions at the right time

00:11:39,680 --> 00:11:42,720
right so you make everything to a lego

00:11:42,160 --> 00:11:45,519
brick

00:11:42,720 --> 00:11:46,560
but pretty soon your pile starts to look

00:11:45,519 --> 00:11:49,920
like this

00:11:46,560 --> 00:11:51,760
and it becomes very hard especially the

00:11:49,920 --> 00:11:56,320
more generic you get

00:11:51,760 --> 00:12:00,079
to find the right things

00:11:56,320 --> 00:12:01,600
finally um once you have everything as a

00:12:00,079 --> 00:12:04,880
micro ui

00:12:01,600 --> 00:12:07,680
where does your workflow logic live uh

00:12:04,880 --> 00:12:09,120
when you have things as monoliths uh you

00:12:07,680 --> 00:12:13,040
can have controllers that

00:12:09,120 --> 00:12:15,839
orchestrate across uh your monolith

00:12:13,040 --> 00:12:17,519
quite easily but when things are

00:12:15,839 --> 00:12:21,440
decoupled

00:12:17,519 --> 00:12:24,560
doing that orchestration becomes

00:12:21,440 --> 00:12:29,760
trickier and you need a mechanism that

00:12:24,560 --> 00:12:29,760
components can rely on to communicate

00:12:31,839 --> 00:12:38,800
so in summary micro ui strategies

00:12:35,760 --> 00:12:40,560
are good at disassembling

00:12:38,800 --> 00:12:42,079
monolithic applications into more

00:12:40,560 --> 00:12:46,160
flexible and personalized

00:12:42,079 --> 00:12:50,720
dashboards but

00:12:46,160 --> 00:12:53,040
creating multi-step workflows

00:12:50,720 --> 00:12:54,240
sharing common components enabling end

00:12:53,040 --> 00:12:56,399
user discovery

00:12:54,240 --> 00:12:57,680
and integrating second and third party

00:12:56,399 --> 00:13:02,560
components

00:12:57,680 --> 00:13:02,560
uh is quite a bit more complicated

00:13:04,480 --> 00:13:10,399
so fdc3 helps us solve these problems

00:13:15,200 --> 00:13:18,959
those areas of ftc iii we talked about

00:13:17,920 --> 00:13:21,519
before

00:13:18,959 --> 00:13:22,160
bring huge amounts of value when we're

00:13:21,519 --> 00:13:25,279
working

00:13:22,160 --> 00:13:28,480
with micro uis to build uh

00:13:25,279 --> 00:13:32,720
interactive user workflows so

00:13:28,480 --> 00:13:32,720
app directory and intents

00:13:32,959 --> 00:13:38,959
solve for discoverability uh across

00:13:36,000 --> 00:13:39,920
applications and across uis context

00:13:38,959 --> 00:13:42,320
sharing

00:13:39,920 --> 00:13:43,839
solves for workflow integration across

00:13:42,320 --> 00:13:46,880
those uis

00:13:43,839 --> 00:13:47,199
and finally data-driven intents solves

00:13:46,880 --> 00:13:49,839
for

00:13:47,199 --> 00:13:49,839
service reuse

00:13:52,480 --> 00:13:58,959
so let's look at the first use case of

00:13:55,360 --> 00:13:58,959
connecting to the app directory

00:14:01,440 --> 00:14:06,800
so in this example we have a grid of

00:14:05,279 --> 00:14:10,639
instruments

00:14:06,800 --> 00:14:10,639
running in one application

00:14:11,199 --> 00:14:18,639
and when right clicking on a ticker

00:14:16,000 --> 00:14:20,639
ftc 3 is going to allow us to easily

00:14:18,639 --> 00:14:22,560
search an app directory and discover

00:14:20,639 --> 00:14:25,600
the applications and intents that are

00:14:22,560 --> 00:14:28,800
relevant to that ticker

00:14:25,600 --> 00:14:31,839
you can see here you've now

00:14:28,800 --> 00:14:45,839
gotten a whole list of applications

00:14:31,839 --> 00:14:45,839
organized by intents

00:14:51,199 --> 00:14:56,079
and let's look at the code that enabled

00:14:54,399 --> 00:14:58,399
that

00:14:56,079 --> 00:15:00,320
you can see it's quite simple to

00:14:58,399 --> 00:15:03,120
implement this kind of functionality in

00:15:00,320 --> 00:15:03,120
ftc3

00:15:03,440 --> 00:15:11,120
in this case we're using a

00:15:06,560 --> 00:15:14,320
api called find intense by context

00:15:11,120 --> 00:15:16,240
which we see here uh we pass in a

00:15:14,320 --> 00:15:20,959
context it's going to come to us

00:15:16,240 --> 00:15:24,399
off of the grid uh context

00:15:20,959 --> 00:15:28,240
and we get back

00:15:24,399 --> 00:15:31,600
a uh this is actually

00:15:28,240 --> 00:15:34,320
it's an asynchronous response we wait

00:15:31,600 --> 00:15:36,639
um and in fact what this this is getting

00:15:34,320 --> 00:15:39,279
back a data response that we then

00:15:36,639 --> 00:15:41,279
pass into what actually is a web

00:15:39,279 --> 00:15:44,880
component that we're using here

00:15:41,279 --> 00:15:47,040
to render that menu interestingly enough

00:15:44,880 --> 00:15:50,160
one of the things that

00:15:47,040 --> 00:15:54,480
we are doing in ftc 3

00:15:50,160 --> 00:15:55,920
1.2 is making this kind of workflow even

00:15:54,480 --> 00:15:58,800
easier to implement for an

00:15:55,920 --> 00:15:59,759
application because you'll be able to

00:15:58,800 --> 00:16:03,759
pass just

00:15:59,759 --> 00:16:07,120
a single api to the desktop agent

00:16:03,759 --> 00:16:08,079
on the ftc 3 ap basically ftc 3 api

00:16:07,120 --> 00:16:10,079
provider

00:16:08,079 --> 00:16:11,759
and then they'll draw will be

00:16:10,079 --> 00:16:14,320
responsible for drawing

00:16:11,759 --> 00:16:15,759
that menu for you in this case the

00:16:14,320 --> 00:16:18,720
application itself

00:16:15,759 --> 00:16:18,720
is drawing the menu

00:16:20,560 --> 00:16:24,959
so let's go to the use case of uh

00:16:23,360 --> 00:16:28,480
sharing context

00:16:24,959 --> 00:16:30,560
with using channels in ftc3

00:16:28,480 --> 00:16:31,600
so once we've discovered our

00:16:30,560 --> 00:16:33,040
applications

00:16:31,600 --> 00:16:35,600
we want to be able to keep them

00:16:33,040 --> 00:16:37,600
synchronized through sharing context

00:16:35,600 --> 00:16:40,720
and there's been a lot of work that's

00:16:37,600 --> 00:16:44,079
gone into especially ftc 311

00:16:40,720 --> 00:16:50,160
to enable rich context sharing

00:16:44,079 --> 00:16:53,040
using this concept called channels

00:16:50,160 --> 00:16:55,199
so in this example here we're going to

00:16:53,040 --> 00:16:55,199
see

00:16:55,279 --> 00:17:01,040
um using the

00:16:58,639 --> 00:17:03,040
ftc3 desktop agent here to select a

00:17:01,040 --> 00:17:06,079
color channel

00:17:03,040 --> 00:17:09,199
that i'm going to put this application

00:17:06,079 --> 00:17:12,000
on i just put it onto the red channel

00:17:09,199 --> 00:17:19,839
and now i can i'll receive and be able

00:17:12,000 --> 00:17:19,839
to broadcast context over that channel

00:17:21,600 --> 00:17:27,199
and then in this example

00:17:25,120 --> 00:17:28,160
we can see that in action in a little

00:17:27,199 --> 00:17:31,039
more detail

00:17:28,160 --> 00:17:32,640
and also combine combined with intents

00:17:31,039 --> 00:17:35,840
so

00:17:32,640 --> 00:17:38,559
i'm going to again

00:17:35,840 --> 00:17:39,919
discover applications by intense for

00:17:38,559 --> 00:17:43,039
this context

00:17:39,919 --> 00:17:45,120
i open up a news application and now

00:17:43,039 --> 00:17:47,919
i'm going to put the news application

00:17:45,120 --> 00:17:51,039
onto the red channel

00:17:47,919 --> 00:17:52,799
and i'm going to move that app over to

00:17:51,039 --> 00:17:53,760
the side so we can see both these in

00:17:52,799 --> 00:17:57,039
action

00:17:53,760 --> 00:17:58,880
and i'm going to have my grid already on

00:17:57,039 --> 00:18:00,240
the red channel so as i click through

00:17:58,880 --> 00:18:02,320
new contacts

00:18:00,240 --> 00:18:05,760
it's going to reload the news with the

00:18:02,320 --> 00:18:05,760
new contacts i selected

00:18:06,960 --> 00:18:12,840
and you can see how doing this really

00:18:10,160 --> 00:18:15,600
enables end users to

00:18:12,840 --> 00:18:16,559
discover functionality and also to build

00:18:15,600 --> 00:18:29,600
new connections

00:18:16,559 --> 00:18:34,080
between unrelated apps

00:18:29,600 --> 00:18:34,080
this is right okay so

00:18:35,919 --> 00:18:40,480
let's look at now taking the channel

00:18:38,960 --> 00:18:44,000
concept

00:18:40,480 --> 00:18:44,640
and publishing data with channels so

00:18:44,000 --> 00:18:47,760
taking

00:18:44,640 --> 00:18:50,960
ftc3 channels we can take that

00:18:47,760 --> 00:18:53,280
color channel example but there's also

00:18:50,960 --> 00:18:54,840
another kind of channel in ftc3 that's

00:18:53,280 --> 00:18:58,559
called an app

00:18:54,840 --> 00:19:01,679
channel that essentially allows

00:18:58,559 --> 00:19:02,720
the creation of what we can think of as

00:19:01,679 --> 00:19:05,760
private channels

00:19:02,720 --> 00:19:09,280
for applications

00:19:05,760 --> 00:19:12,559
so we can actually adapt

00:19:09,280 --> 00:19:15,679
that api

00:19:12,559 --> 00:19:18,720
excuse me that api

00:19:15,679 --> 00:19:22,640
to um allow us to

00:19:18,720 --> 00:19:25,840
publish data to other applications

00:19:22,640 --> 00:19:25,840
using those channels

00:19:26,400 --> 00:19:34,640
so in this video you're going to see

00:19:31,520 --> 00:19:35,600
this is the ftc3 channel manager demo

00:19:34,640 --> 00:19:39,120
app

00:19:35,600 --> 00:19:41,919
that i've now created

00:19:39,120 --> 00:19:42,960
a a private channel or app channel

00:19:41,919 --> 00:19:44,960
called my channel

00:19:42,960 --> 00:19:46,960
on both these apps so they both have

00:19:44,960 --> 00:19:50,840
created the same

00:19:46,960 --> 00:19:54,160
channel so they're synchronized to it

00:19:50,840 --> 00:19:57,280
and they are now uh

00:19:54,160 --> 00:19:59,760
exchanging context

00:19:57,280 --> 00:20:02,559
back and forth over that channel so this

00:19:59,760 --> 00:20:02,559
could be used

00:20:02,799 --> 00:20:07,600
to create this kind of private

00:20:04,400 --> 00:20:11,840
interaction but it could also be used

00:20:07,600 --> 00:20:14,960
to broadcast or to publish

00:20:11,840 --> 00:20:18,000
let's say streaming updates

00:20:14,960 --> 00:20:20,159
uh for some data over

00:20:18,000 --> 00:20:21,520
a specific context channel right so

00:20:20,159 --> 00:20:25,039
there's it's a very

00:20:21,520 --> 00:20:26,640
flexible api that allows you to do a

00:20:25,039 --> 00:20:29,120
number of different

00:20:26,640 --> 00:20:29,120
things

00:20:31,280 --> 00:20:37,120
so this is what that api

00:20:35,360 --> 00:20:39,280
looks like so this is some of the code

00:20:37,120 --> 00:20:43,200
that went into that app

00:20:39,280 --> 00:20:45,360
again it's not a whole lot of code to

00:20:43,200 --> 00:20:48,480
implement ftc3

00:20:45,360 --> 00:20:51,039
so in this case when i clicked on

00:20:48,480 --> 00:20:52,480
uh the button to create the channel it's

00:20:51,039 --> 00:20:55,280
using the ftc three

00:20:52,480 --> 00:20:56,000
get or create channel api and i pass in

00:20:55,280 --> 00:20:59,840
a name

00:20:56,000 --> 00:21:03,760
so this is going to uh either return

00:20:59,840 --> 00:21:04,799
that my channel app channel if it

00:21:03,760 --> 00:21:06,559
already exists

00:21:04,799 --> 00:21:08,720
if it doesn't it's going to create it

00:21:06,559 --> 00:21:12,240
and then return it to me

00:21:08,720 --> 00:21:14,400
once i have a channel object i can now

00:21:12,240 --> 00:21:16,720
both add a context listener to it i can

00:21:14,400 --> 00:21:20,400
also broadcast over it

00:21:16,720 --> 00:21:23,039
um and in this case you see the code for

00:21:20,400 --> 00:21:24,799
me to broadcast i'm sorry to add a

00:21:23,039 --> 00:21:28,799
context listener onto it

00:21:24,799 --> 00:21:31,440
um and then once i get a context on it i

00:21:28,799 --> 00:21:35,840
can just respond to that

00:21:31,440 --> 00:21:35,840
the uh so

00:21:39,120 --> 00:21:45,120
this is great but there are problems

00:21:43,039 --> 00:21:46,880
with this kind of pattern using app

00:21:45,120 --> 00:21:51,600
channels

00:21:46,880 --> 00:21:55,440
if we wanted to build a kind of client

00:21:51,600 --> 00:21:58,960
provider relationship

00:21:55,440 --> 00:21:59,600
so where an app maybe is streaming data

00:21:58,960 --> 00:22:03,679
out to

00:21:59,600 --> 00:22:05,840
a number of subscriber apps one

00:22:03,679 --> 00:22:07,280
there's no service discovery here for

00:22:05,840 --> 00:22:10,480
for app channels

00:22:07,280 --> 00:22:12,080
uh app channels because actually because

00:22:10,480 --> 00:22:15,440
of number two because they rely

00:22:12,080 --> 00:22:18,480
on security through obscurity um

00:22:15,440 --> 00:22:21,919
there's no mechanism for

00:22:18,480 --> 00:22:22,480
uh publishing the identity of those

00:22:21,919 --> 00:22:25,760
channels

00:22:22,480 --> 00:22:30,240
or built into ftc

00:22:25,760 --> 00:22:32,960
or to sort of discover

00:22:30,240 --> 00:22:33,440
that through another mechanism like we

00:22:32,960 --> 00:22:36,159
have

00:22:33,440 --> 00:22:37,600
for example for intents where i can say

00:22:36,159 --> 00:22:40,320
i want to view a chart

00:22:37,600 --> 00:22:41,760
and i can get a list provided by the

00:22:40,320 --> 00:22:44,880
desktop agent

00:22:41,760 --> 00:22:48,159
of applications that

00:22:44,880 --> 00:22:51,520
support that functionality

00:22:48,159 --> 00:22:54,400
um this also risks

00:22:51,520 --> 00:22:54,799
fragmentation of standards so if we

00:22:54,400 --> 00:22:58,000
create

00:22:54,799 --> 00:23:01,120
lots of kind of private channels

00:22:58,000 --> 00:23:02,799
to do various functionalities across our

00:23:01,120 --> 00:23:06,159
applications

00:23:02,799 --> 00:23:08,960
chances are it's going to be very hard

00:23:06,159 --> 00:23:09,760
to upstream anything we're doing there

00:23:08,960 --> 00:23:12,720
back into

00:23:09,760 --> 00:23:15,039
the standard it's not really it's not

00:23:12,720 --> 00:23:17,120
really helping advance a common language

00:23:15,039 --> 00:23:20,799
it's really creating more opportunity

00:23:17,120 --> 00:23:24,000
for just private conversations to happen

00:23:20,799 --> 00:23:26,159
and then finally it

00:23:24,000 --> 00:23:28,080
really creates a lot of need for

00:23:26,159 --> 00:23:30,000
handshakes and life cycle management so

00:23:28,080 --> 00:23:32,640
the example we just looked at

00:23:30,000 --> 00:23:34,480
is very simple we're just broadcasting

00:23:32,640 --> 00:23:37,600
context back and forth but

00:23:34,480 --> 00:23:40,880
in a real example if if i wanted to

00:23:37,600 --> 00:23:44,000
like share a data feed to something

00:23:40,880 --> 00:23:44,799
i need to know uh first of all i need to

00:23:44,000 --> 00:23:48,400
be able to

00:23:44,799 --> 00:23:50,240
initiate the uh back and forth between

00:23:48,400 --> 00:23:54,159
two applications

00:23:50,240 --> 00:23:56,320
and then um

00:23:54,159 --> 00:23:57,440
i would need to know when an application

00:23:56,320 --> 00:24:00,640
goes away

00:23:57,440 --> 00:24:03,760
um if it's

00:24:00,640 --> 00:24:06,960
when it's loaded etc so so

00:24:03,760 --> 00:24:08,799
there's uh really no space

00:24:06,960 --> 00:24:11,600
in that api for that kind of

00:24:08,799 --> 00:24:11,600
functionality

00:24:12,880 --> 00:24:18,720
so this leads us to

00:24:16,000 --> 00:24:19,760
data driven intents which is a proposal

00:24:18,720 --> 00:24:22,880
that

00:24:19,760 --> 00:24:24,960
actually we've discussed for quite some

00:24:22,880 --> 00:24:27,600
time on and off

00:24:24,960 --> 00:24:28,960
within the ftc iii community and there's

00:24:27,600 --> 00:24:33,840
uh

00:24:28,960 --> 00:24:38,080
we're now been working on a formal pr

00:24:33,840 --> 00:24:40,559
around this for the 1.2

00:24:38,080 --> 00:24:40,559
standard

00:24:41,279 --> 00:24:47,440
so what is the proposal

00:24:45,440 --> 00:24:49,440
at the heart of the idea of data-driven

00:24:47,440 --> 00:24:52,559
intents is

00:24:49,440 --> 00:24:56,480
is that you can have an intent

00:24:52,559 --> 00:25:00,240
that's going to return data or initiate

00:24:56,480 --> 00:25:02,720
a sort of data stream um

00:25:00,240 --> 00:25:03,520
as opposed to the intents that have

00:25:02,720 --> 00:25:06,960
existed in

00:25:03,520 --> 00:25:09,520
ftc three so far which have been

00:25:06,960 --> 00:25:11,120
largely kind of fire and forget you say

00:25:09,520 --> 00:25:15,120
i want to view a chart

00:25:11,120 --> 00:25:18,000
erase that send a context over to

00:25:15,120 --> 00:25:19,279
some application that gets resolved to

00:25:18,000 --> 00:25:22,080
context goes over

00:25:19,279 --> 00:25:23,120
and you never hear from that app again

00:25:22,080 --> 00:25:27,120
um

00:25:23,120 --> 00:25:30,640
so that has its place

00:25:27,120 --> 00:25:33,679
but it's also fairly limited

00:25:30,640 --> 00:25:35,440
so at the heart of the proposal for

00:25:33,679 --> 00:25:37,520
data-driven intents

00:25:35,440 --> 00:25:38,720
is really the concept of the app

00:25:37,520 --> 00:25:42,240
instance

00:25:38,720 --> 00:25:47,440
that we can get a

00:25:42,240 --> 00:25:50,559
reference to an app instance as part of

00:25:47,440 --> 00:25:52,000
a resolution of an intent or an exchange

00:25:50,559 --> 00:25:55,120
of context data

00:25:52,000 --> 00:25:57,200
and that i can as an application use

00:25:55,120 --> 00:26:00,720
that app instance

00:25:57,200 --> 00:26:04,240
identifier to then

00:26:00,720 --> 00:26:07,520
either listen to context events

00:26:04,240 --> 00:26:12,080
from the app instance or to

00:26:07,520 --> 00:26:16,159
broadcast additional context to it

00:26:12,080 --> 00:26:18,640
so again the app instance

00:26:16,159 --> 00:26:19,279
will provide a reference to a specific

00:26:18,640 --> 00:26:22,320
app

00:26:19,279 --> 00:26:25,120
a specific app instance not the app as a

00:26:22,320 --> 00:26:26,559
kind of class

00:26:25,120 --> 00:26:29,360
it can be created from a source

00:26:26,559 --> 00:26:29,919
identifier now the source identifier was

00:26:29,360 --> 00:26:33,760
something

00:26:29,919 --> 00:26:36,000
that existed in ftc 310

00:26:33,760 --> 00:26:37,039
as part of the intent resolution object

00:26:36,000 --> 00:26:38,640
so after

00:26:37,039 --> 00:26:40,400
you've raised an attempt it gets

00:26:38,640 --> 00:26:41,679
resolved and routed to some other

00:26:40,400 --> 00:26:44,640
application

00:26:41,679 --> 00:26:45,440
in the resolution you get back in the

00:26:44,640 --> 00:26:48,880
api

00:26:45,440 --> 00:26:53,679
you will get a source but this has been

00:26:48,880 --> 00:26:55,360
fairly vague what it is um

00:26:53,679 --> 00:26:57,600
with this update to the spec we're

00:26:55,360 --> 00:27:00,640
saying that a source identifier

00:26:57,600 --> 00:27:03,200
is a identifier a token

00:27:00,640 --> 00:27:04,080
i can use to return back to the desktop

00:27:03,200 --> 00:27:06,880
agent

00:27:04,080 --> 00:27:07,760
and then it will give me a reference to

00:27:06,880 --> 00:27:10,720
that specific

00:27:07,760 --> 00:27:12,400
application instance based on that on

00:27:10,720 --> 00:27:15,440
that token

00:27:12,400 --> 00:27:17,520
um so

00:27:15,440 --> 00:27:18,799
and that will be returned not just from

00:27:17,520 --> 00:27:21,039
intent resolution

00:27:18,799 --> 00:27:24,159
but also from context messages so if i

00:27:21,039 --> 00:27:27,600
get context broadcast to me

00:27:24,159 --> 00:27:30,799
there will be a source token

00:27:27,600 --> 00:27:33,279
associated with that message that

00:27:30,799 --> 00:27:34,559
i can then use if i receive context from

00:27:33,279 --> 00:27:36,720
another application

00:27:34,559 --> 00:27:38,640
to get a reference back to the

00:27:36,720 --> 00:27:42,320
application that

00:27:38,640 --> 00:27:42,320
sent me that context

00:27:43,440 --> 00:27:49,760
the app instance object itself will

00:27:47,360 --> 00:27:50,960
support both broadcast and on context

00:27:49,760 --> 00:27:54,799
listener methods

00:27:50,960 --> 00:27:57,200
as well as lifecycle events so you'll

00:27:54,799 --> 00:27:58,159
be able to listen to the status of that

00:27:57,200 --> 00:28:01,600
instance

00:27:58,159 --> 00:28:04,480
and know when it's gone away

00:28:01,600 --> 00:28:04,480
and when it's loaded

00:28:06,880 --> 00:28:14,159
so let's look at the uh draft

00:28:10,080 --> 00:28:17,679
type for app instance for a second

00:28:14,159 --> 00:28:20,720
to illustrate uh

00:28:17,679 --> 00:28:23,600
the the previous points

00:28:20,720 --> 00:28:24,520
uh again this is a draft this is

00:28:23,600 --> 00:28:27,679
essentially

00:28:24,520 --> 00:28:31,600
pre-pr um

00:28:27,679 --> 00:28:35,520
meaning that there's uh this code exists

00:28:31,600 --> 00:28:38,559
in a on my fork to be honest today

00:28:35,520 --> 00:28:42,480
but it will be uh there will be a pr

00:28:38,559 --> 00:28:45,520
uh coming soon uh

00:28:42,480 --> 00:28:48,559
you can see that we have uh

00:28:45,520 --> 00:28:49,840
the standard interfaces for add context

00:28:48,559 --> 00:28:52,720
listener

00:28:49,840 --> 00:28:53,679
you can listen both uh you can add a

00:28:52,720 --> 00:28:55,760
listener about just

00:28:53,679 --> 00:28:58,559
adding a function or using a context

00:28:55,760 --> 00:29:01,600
type filter

00:28:58,559 --> 00:29:04,000
you can broadcast uh and then there's

00:29:01,600 --> 00:29:07,120
this on status change

00:29:04,000 --> 00:29:09,279
which um supports

00:29:07,120 --> 00:29:10,399
a handler can be passed into it and

00:29:09,279 --> 00:29:13,600
there is

00:29:10,399 --> 00:29:17,600
a status property that can be

00:29:13,600 --> 00:29:17,600
ready loading or unregistered

00:29:20,320 --> 00:29:27,279
so let's go to a demo

00:29:23,840 --> 00:29:30,480
we can see what this looks like

00:29:27,279 --> 00:29:34,720
this is uh built using

00:29:30,480 --> 00:29:38,000
some tooling from the genesis platform

00:29:34,720 --> 00:29:41,440
and then using the uh

00:29:38,000 --> 00:29:44,559
ftc3 desktop agent project uh

00:29:41,440 --> 00:29:48,399
to uh model out the functionality

00:29:44,559 --> 00:29:52,080
that's being proposed so in this case

00:29:48,399 --> 00:29:52,720
i've got two uh client applications on

00:29:52,080 --> 00:29:53,840
the left

00:29:52,720 --> 00:29:56,480
i'm just going to pause that for a

00:29:53,840 --> 00:30:00,640
second and

00:29:56,480 --> 00:30:01,919
a three provider applications on the

00:30:00,640 --> 00:30:06,000
right

00:30:01,919 --> 00:30:06,000
the provider applications are providing

00:30:06,320 --> 00:30:12,799
well it's all mock data but uh fx

00:30:09,760 --> 00:30:14,880
uh pricing on currency pairs

00:30:12,799 --> 00:30:16,399
from each from a different liquidity

00:30:14,880 --> 00:30:19,600
provider

00:30:16,399 --> 00:30:20,880
and then the client applications on the

00:30:19,600 --> 00:30:25,120
left

00:30:20,880 --> 00:30:27,840
are going to uh create

00:30:25,120 --> 00:30:29,520
raise intents for a specific currency

00:30:27,840 --> 00:30:32,559
pair

00:30:29,520 --> 00:30:34,960
actually send over an instrument context

00:30:32,559 --> 00:30:34,960
for that

00:30:35,520 --> 00:30:38,559
to get pricing for that currency pair

00:30:38,000 --> 00:30:41,039
and then

00:30:38,559 --> 00:30:41,760
what's going to happen is that since

00:30:41,039 --> 00:30:45,279
there are

00:30:41,760 --> 00:30:48,799
multiple providers of pricing

00:30:45,279 --> 00:30:51,919
running in this uh desktop

00:30:48,799 --> 00:30:53,039
agent instance uh the end user will get

00:30:51,919 --> 00:30:55,360
prompted

00:30:53,039 --> 00:30:58,240
for which provider they want to get the

00:30:55,360 --> 00:30:58,240
pricing from

00:31:02,000 --> 00:31:08,559
so there is our intent resolver

00:31:05,679 --> 00:31:11,039
we've chosen bnp and we start getting

00:31:08,559 --> 00:31:13,120
pricing back and you'll see that also

00:31:11,039 --> 00:31:14,960
pricing should update in this case we've

00:31:13,120 --> 00:31:18,000
now chosen city

00:31:14,960 --> 00:31:21,519
for the other currency pair and we can

00:31:18,000 --> 00:31:22,799
actually switch to a different provider

00:31:21,519 --> 00:31:25,120
we're going to switch to db

00:31:22,799 --> 00:31:27,679
here and you can see the pricing gets

00:31:25,120 --> 00:31:27,679
updated

00:31:29,120 --> 00:31:36,480
so that is data driven

00:31:32,960 --> 00:31:41,519
intense going across

00:31:36,480 --> 00:31:45,519
ftc3 again we have

00:31:41,519 --> 00:31:48,159
two different clients that are

00:31:45,519 --> 00:31:49,840
raising intents to request pricing

00:31:48,159 --> 00:31:54,000
they're presented with options

00:31:49,840 --> 00:31:56,399
of different registered uh

00:31:54,000 --> 00:31:58,240
providers for that from different

00:31:56,399 --> 00:32:03,200
liquidity sources

00:31:58,240 --> 00:32:06,320
and once a

00:32:03,200 --> 00:32:07,279
provider is chosen by the end user that

00:32:06,320 --> 00:32:09,440
application now

00:32:07,279 --> 00:32:11,440
listens to context updates from the

00:32:09,440 --> 00:32:12,559
provider the provider is sending those

00:32:11,440 --> 00:32:15,440
updates

00:32:12,559 --> 00:32:16,480
specifically to that client so they

00:32:15,440 --> 00:32:20,640
they're forming

00:32:16,480 --> 00:32:23,600
a a uh one-to-one relationship

00:32:20,640 --> 00:32:23,600
with that handshake

00:32:24,559 --> 00:32:30,000
so let's look a little bit what that

00:32:26,320 --> 00:32:33,760
code looks like so

00:32:30,000 --> 00:32:36,880
this is uh the code for

00:32:33,760 --> 00:32:40,399
within the data

00:32:36,880 --> 00:32:43,200
provider they are handling

00:32:40,399 --> 00:32:43,519
the intent so at the top here you can

00:32:43,200 --> 00:32:46,000
see

00:32:43,519 --> 00:32:47,039
that we're using ftc three add intent

00:32:46,000 --> 00:32:50,240
listener

00:32:47,039 --> 00:32:52,880
we've created a um

00:32:50,240 --> 00:32:54,159
in this case just a genesis name spaced

00:32:52,880 --> 00:32:57,039
um

00:32:54,159 --> 00:33:00,159
uh intent name that's you know just a

00:32:57,039 --> 00:33:02,880
working title find fx price

00:33:00,159 --> 00:33:03,840
um and we're passing in a handler which

00:33:02,880 --> 00:33:08,840
is this uh

00:33:03,840 --> 00:33:11,519
handle price intent function within that

00:33:08,840 --> 00:33:14,640
um what's interesting is we have

00:33:11,519 --> 00:33:18,559
this we um

00:33:14,640 --> 00:33:21,840
get from the intent the source is handed

00:33:18,559 --> 00:33:25,360
is passed into us from the intent

00:33:21,840 --> 00:33:27,760
handler so this is new and from this

00:33:25,360 --> 00:33:27,760
source

00:33:28,720 --> 00:33:35,919
we are resolving that

00:33:31,919 --> 00:33:35,919
into an app instance

00:33:36,320 --> 00:33:44,480
and then we do some things to get

00:33:40,080 --> 00:33:48,159
data um and we also do some things

00:33:44,480 --> 00:33:50,880
to um to create uh

00:33:48,159 --> 00:33:52,080
to push the last value cache when the

00:33:50,880 --> 00:33:54,799
subscriptions

00:33:52,080 --> 00:33:54,799
first made

00:33:59,760 --> 00:34:09,760
so as a service provider when we want to

00:34:06,880 --> 00:34:12,399
when we get our data update from the

00:34:09,760 --> 00:34:12,399
back end

00:34:12,720 --> 00:34:20,560
uh we now um are going to

00:34:17,520 --> 00:34:24,399
so we've basically taken our

00:34:20,560 --> 00:34:29,040
um instances and we've created

00:34:24,399 --> 00:34:32,159
a map of them called subscribers

00:34:29,040 --> 00:34:37,520
uh and then when we get an update for

00:34:32,159 --> 00:34:40,240
specific um currency pair

00:34:37,520 --> 00:34:42,320
we are now going to push that to any

00:34:40,240 --> 00:34:45,679
subscribers for the currency pair

00:34:42,320 --> 00:34:47,679
obviously there's a bunch of uh

00:34:45,679 --> 00:34:49,679
details that are fudged here for the

00:34:47,679 --> 00:34:52,320
demo but

00:34:49,679 --> 00:34:52,879
you know you can see the structure of

00:34:52,320 --> 00:34:56,879
how this

00:34:52,879 --> 00:34:59,760
would work um

00:34:56,879 --> 00:35:01,599
when we get our subscriber we're just

00:34:59,760 --> 00:35:04,800
going to

00:35:01,599 --> 00:35:05,760
we've basically put the instances into

00:35:04,800 --> 00:35:08,320
the map that we

00:35:05,760 --> 00:35:09,359
resolved originally when the handshake

00:35:08,320 --> 00:35:10,880
was made

00:35:09,359 --> 00:35:13,920
and now we're just going to broadcast

00:35:10,880 --> 00:35:13,920
the new context

00:35:14,160 --> 00:35:18,880
back to that instance once again i think

00:35:17,200 --> 00:35:21,119
it's important to point out that

00:35:18,880 --> 00:35:22,079
we're not doing a broadcast over a

00:35:21,119 --> 00:35:24,400
channel that

00:35:22,079 --> 00:35:26,240
anything could listen to we're doing a

00:35:24,400 --> 00:35:27,119
broadcast specifically to that instance

00:35:26,240 --> 00:35:30,400
so it's only

00:35:27,119 --> 00:35:32,160
it's a it's a direct message to that

00:35:30,400 --> 00:35:36,400
instance

00:35:32,160 --> 00:35:39,920
which allows kind of the space for

00:35:36,400 --> 00:35:43,599
a desktop agent or for an app to provide

00:35:39,920 --> 00:35:44,160
a real real privacy around the data and

00:35:43,599 --> 00:35:47,280
how

00:35:44,160 --> 00:35:50,400
it's going to be routed or if if a

00:35:47,280 --> 00:35:50,720
a application instance is even going to

00:35:50,400 --> 00:35:55,440
be

00:35:50,720 --> 00:35:55,440
allowed to connect to the provider

00:35:57,119 --> 00:36:02,640
so this is what the code for actually

00:36:00,560 --> 00:36:04,000
raising the data intent looks like from

00:36:02,640 --> 00:36:06,960
the client

00:36:04,000 --> 00:36:07,760
um and again this should look pretty

00:36:06,960 --> 00:36:10,839
familiar

00:36:07,760 --> 00:36:12,240
we're calling ftc3 raise intent get a

00:36:10,839 --> 00:36:14,640
results

00:36:12,240 --> 00:36:16,240
uh what's new here is that once we get

00:36:14,640 --> 00:36:19,520
the result

00:36:16,240 --> 00:36:21,280
we are um using the source property the

00:36:19,520 --> 00:36:22,640
result which has always been there it's

00:36:21,280 --> 00:36:24,480
just that we haven't really been able to

00:36:22,640 --> 00:36:27,680
do very much with it

00:36:24,480 --> 00:36:30,960
and we are getting an app instance

00:36:27,680 --> 00:36:34,640
and then once we get the app instance

00:36:30,960 --> 00:36:37,760
uh well we we're doing some things to

00:36:34,640 --> 00:36:39,119
resubscribe to uh things that we only

00:36:37,760 --> 00:36:42,240
are listening to

00:36:39,119 --> 00:36:44,480
one feed at a time and then here we're

00:36:42,240 --> 00:36:49,760
going to add a contacts listener on that

00:36:44,480 --> 00:36:49,760
instance itself for the update fx price

00:36:49,920 --> 00:36:55,599
context and again we're listening

00:36:53,440 --> 00:36:57,200
just to this source it's a direct

00:36:55,599 --> 00:37:00,320
connection

00:36:57,200 --> 00:37:03,599
um and then we're using that to

00:37:00,320 --> 00:37:03,599
update our ui

00:37:05,359 --> 00:37:11,280
so what's next with all this

00:37:09,040 --> 00:37:11,280
um

00:37:12,079 --> 00:37:17,599
l caps are really accelerating the trend

00:37:15,440 --> 00:37:19,520
towards greater reusability and

00:37:17,599 --> 00:37:22,560
composability of back ends

00:37:19,520 --> 00:37:24,320
and front ends and that's unlocking

00:37:22,560 --> 00:37:26,000
enormous value

00:37:24,320 --> 00:37:28,320
that's because we're delivering high

00:37:26,000 --> 00:37:30,400
quality applications at an even faster

00:37:28,320 --> 00:37:32,960
pace

00:37:30,400 --> 00:37:35,359
ftc 3 fits into this whole story because

00:37:32,960 --> 00:37:37,440
it provides a wealth of tools

00:37:35,359 --> 00:37:39,440
that make user experience and

00:37:37,440 --> 00:37:41,200
componentized workflows

00:37:39,440 --> 00:37:43,520
even more personal intuitive and

00:37:41,200 --> 00:37:46,640
effective

00:37:43,520 --> 00:37:47,280
data driven intense i believe promises

00:37:46,640 --> 00:37:51,200
to be

00:37:47,280 --> 00:37:53,760
a really critical addition to this

00:37:51,200 --> 00:37:53,760
toolkit

00:37:55,200 --> 00:38:01,680
so contribute to ftc3

00:37:59,680 --> 00:38:03,280
uh there are a lot of different ways to

00:38:01,680 --> 00:38:07,839
get involved

00:38:03,280 --> 00:38:11,680
i first step go to the github site

00:38:07,839 --> 00:38:13,839
github finos ftc3 there's a

00:38:11,680 --> 00:38:14,880
huge amount of information there and of

00:38:13,839 --> 00:38:17,599
course

00:38:14,880 --> 00:38:18,320
you can see all the code you want to see

00:38:17,599 --> 00:38:21,040
the code

00:38:18,320 --> 00:38:23,119
for the desktop agent which was used in

00:38:21,040 --> 00:38:25,920
all these demos

00:38:23,119 --> 00:38:27,760
and use the code contribute to the code

00:38:25,920 --> 00:38:31,839
um

00:38:27,760 --> 00:38:35,599
it's also a finos

00:38:31,839 --> 00:38:37,440
open source project this allows you to

00:38:35,599 --> 00:38:40,800
run a chrome extension

00:38:37,440 --> 00:38:41,440
that fully implements fdc3 it goes

00:38:40,800 --> 00:38:45,200
against

00:38:41,440 --> 00:38:48,640
a app directory that is

00:38:45,200 --> 00:38:50,000
public and you can actually swap it out

00:38:48,640 --> 00:38:51,760
to your own app directory

00:38:50,000 --> 00:38:53,680
and once again all the code's open

00:38:51,760 --> 00:38:56,960
source so

00:38:53,680 --> 00:38:59,599
feel free to fork to make prs

00:38:56,960 --> 00:39:00,079
um and contribute it's a really great

00:38:59,599 --> 00:39:04,320
way

00:39:00,079 --> 00:39:07,839
to get ftc 3 up and running fast

00:39:04,320 --> 00:39:13,280
and also to be able to model quickly

00:39:07,839 --> 00:39:17,200
uh new ideas in ftc 3 like this one

00:39:13,280 --> 00:39:20,800
subscribe to the meetings calendar so

00:39:17,200 --> 00:39:24,960
ftc three holds a

00:39:20,800 --> 00:39:27,839
a standards uh working group meeting

00:39:24,960 --> 00:39:30,079
every four weeks you can find the

00:39:27,839 --> 00:39:33,200
information on that there

00:39:30,079 --> 00:39:36,079
if you are interested in helping just

00:39:33,200 --> 00:39:36,880
contributing from a project management

00:39:36,079 --> 00:39:40,000
aspect or

00:39:36,880 --> 00:39:42,800
product management aspect there's also

00:39:40,000 --> 00:39:43,440
our project management committee or pmc

00:39:42,800 --> 00:39:47,040
that meets

00:39:43,440 --> 00:39:49,040
every two weeks um

00:39:47,040 --> 00:39:50,880
and then finally you can always join the

00:39:49,040 --> 00:39:54,079
general lists

00:39:50,880 --> 00:39:56,880
send emails there for information and

00:39:54,079 --> 00:39:57,200
you can always reach out directly to me

00:39:56,880 --> 00:40:00,320
or

00:39:57,200 --> 00:40:01,040
other uh members the ftc three group if

00:40:00,320 --> 00:40:04,960
you have

00:40:01,040 --> 00:40:07,760
any questions at all are just unsure of

00:40:04,960 --> 00:40:09,200
where to get involved first but there's

00:40:07,760 --> 00:40:12,720
a lot going on

00:40:09,200 --> 00:40:16,000
and uh we're a friendly group

00:40:12,720 --> 00:40:20,319
uh so thank you very much

00:40:16,000 --> 00:40:20,319
for your time and

00:40:21,200 --> 00:40:35,599
i hope to see you on the

00:40:24,400 --> 00:40:35,599

YouTube URL: https://www.youtube.com/watch?v=SKc22W8Uzl4


