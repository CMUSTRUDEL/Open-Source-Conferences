Title: Stephen Goldbaum & Adam Hurwitz | FINOS | OSSF 2020: Morphir
Publication date: 2020-12-22
Playlist: FINOS Open Source Strategy Forum 2020
Description: 
	Stephen Goldbaum & Adam Hurwitz | FINOS | OSSF 2020: Morphir: Highly Automated Application Development Turning Business Concepts into Transparent and Reliable Cloud Services  | FINOS OSSF 2020

Stephen Goldbaum, Executive Director, Morgan Stanley
Adam Hurwitz, Azure App Dev Specialist, Microsoft

Morphir: Highly Automated Application Development Turning Business Concepts into Transparent and Reliable Cloud Services - OSSF 2020

App development requires substantial effort on code that's not core to the app's value. Some estimates indicate that developers spend the majority of their time on non-value tasks like serialization, messaging, technical debt, and compliance with regulations. And with studies estimating 10 bugs per 1,000 lines of code, all of that tangential code adds considerable risk. In this talk we introduce Morphir for building reliable applications in today’s multi-paradigm world. Morphir is the project open-sourced by Morgan Stanley and recently contributed into FINOS. It recognizes the business logic as the most valuable asset across in an ever-changing tech landscape. Morphir focuses on business logic and automates the rest. We'll explore using Morphir with Microsoft’s Dapr to quickly turn business concepts into transparent and reliable cloud services. Morphir generates all of the necessary code while Dapr provides a robust cloud runtime. The result is one-touch deployment from pure business logic to running micro-services. We conclude by highlighting ongoing work with Microsoft Research to further automate the development process with even more reliability and transparency.

Stephen Goldbaum's BIO

Stephen Goldbaum is co-creator of Morphir and an Executive Director at Morgan Stanley, where he has performed a variety of technical leadership roles. Stephen’s career has spanned a number of industries. Prior roles include: CTO at a privacy start-up, owner of a software consulting firm, Northeast head of Application Consulting at Netscape, and engineer roles at Sun Microsystems and IBM. Stephen has presented extensively on Morphir, functional domain modeling, and software development, including the keynote address at the Chinese American Academic Professional Society Internet Expo. He has M.S. in Computer Science from NYU and a B.F.A. in Music Performance.

Adam Hurwitz's BIO

Adam Hurwitz is an Azure App Dev Specialist at Microsoft in the Financial Services organization. He is a technologist with broad experience creating software products and services in various industries. His previous roles include: CTO at a mobile healthcare start-up, Program Manager creating cloud-based services in the SQL organization of Microsoft, CIO of Business Intelligence Associates, Inc. (BIA) where he built their industry leading e-discovery software and managed data analytics projects involving large corporate databases, and ecommerce programmer at Gateway computers. He has spoken at a handful of events, including the first O’Reilly Strata Big Data conference, published a few things including “The e-Discovery Maturity Model”, and is sole inventor of a patent in machine learning involving record linking. He is a Certified Information Systems Security Professional (CISSP) and has a BA from Vassar College in Physics and Philosophy.

-=-=-=-=-

This video is from the FINOS / Linux Foundation Open Source Strategy Forum (OSSF) Virtual 2020. 

►►For free access to all 2020 videos from the conference - please register HERE: https://events.linuxfoundation.org/open-source-strategy-forum/register/
 
►► More information HERE: https://events.linuxfoundation.org/open-source-strategy-forum/
►► 2020 Schedule HERE: https://events.linuxfoundation.org/open-source-strategy-forum/program/schedule/

Learn more about FINOS and how we deliver the power of open source to financial services:
►► FINOS: https://www.finos.org/
Captions: 
	00:00:03,670 --> 00:00:09,840
[Music]

00:00:08,320 --> 00:00:11,840
hi i'm steven goldberg from morgan

00:00:09,840 --> 00:00:12,880
stanley i'm here with adam hurwitz from

00:00:11,840 --> 00:00:14,480
microsoft

00:00:12,880 --> 00:00:16,720
we're here to talk about greatly

00:00:14,480 --> 00:00:19,119
increasing development efficiency

00:00:16,720 --> 00:00:20,800
with the combination of two powerful

00:00:19,119 --> 00:00:22,720
open source projects

00:00:20,800 --> 00:00:25,039
morpher which is a phenolized project

00:00:22,720 --> 00:00:27,599
recently contributed by morgan stanley

00:00:25,039 --> 00:00:29,760
and dapper which is a microsoft open

00:00:27,599 --> 00:00:32,079
source project

00:00:29,760 --> 00:00:32,960
so application development this is

00:00:32,079 --> 00:00:35,520
really where

00:00:32,960 --> 00:00:37,600
the um the developer provides real value

00:00:35,520 --> 00:00:40,480
and what is it they do they

00:00:37,600 --> 00:00:43,440
take complex business concepts and they

00:00:40,480 --> 00:00:45,760
turn them into complex computer concepts

00:00:43,440 --> 00:00:47,600
that's really the the bulk of what the

00:00:45,760 --> 00:00:48,399
value is that a developer does in an

00:00:47,600 --> 00:00:50,559
application

00:00:48,399 --> 00:00:52,000
development environment of course and

00:00:50,559 --> 00:00:54,079
then we need to make it run

00:00:52,000 --> 00:00:55,360
so that's the most important thing is

00:00:54,079 --> 00:00:58,480
that it needs to run

00:00:55,360 --> 00:01:01,600
and so that's what we think of as

00:00:58,480 --> 00:01:04,800
the core developer value in the process

00:01:01,600 --> 00:01:04,800
of developing applications

00:01:04,879 --> 00:01:08,240
then we hit the enterprise and we find

00:01:07,040 --> 00:01:10,240
out that that's just a

00:01:08,240 --> 00:01:11,360
small fraction of what we need to do in

00:01:10,240 --> 00:01:12,799
terms of coding

00:01:11,360 --> 00:01:14,320
all of a sudden we go to the enterprise

00:01:12,799 --> 00:01:16,080
and we find out that there's probably

00:01:14,320 --> 00:01:17,759
some

00:01:16,080 --> 00:01:20,240
standard frameworks that we need to

00:01:17,759 --> 00:01:22,880
support we've got regulations we've got

00:01:20,240 --> 00:01:25,040
blueprints standards

00:01:22,880 --> 00:01:27,119
we need to register data here we need to

00:01:25,040 --> 00:01:28,720
register lineage

00:01:27,119 --> 00:01:31,600
there's all kinds of stuff that we need

00:01:28,720 --> 00:01:33,520
to do and it actually takes up

00:01:31,600 --> 00:01:34,799
probably the majority of the development

00:01:33,520 --> 00:01:38,000
time so

00:01:34,799 --> 00:01:40,079
what we consider as developer value is

00:01:38,000 --> 00:01:42,240
not what most developers spend most of

00:01:40,079 --> 00:01:45,520
their time on

00:01:42,240 --> 00:01:46,159
and that also has consequences in terms

00:01:45,520 --> 00:01:49,360
of

00:01:46,159 --> 00:01:52,720
well it's not that efficient anymore

00:01:49,360 --> 00:01:53,119
and it's risky because some studies show

00:01:52,720 --> 00:01:56,000
that

00:01:53,119 --> 00:01:57,920
for every thousand lines of computer

00:01:56,000 --> 00:01:58,719
code that a developer writes there's 10

00:01:57,920 --> 00:02:01,360
bugs

00:01:58,719 --> 00:02:02,640
and so with all that code that we're

00:02:01,360 --> 00:02:05,520
writing on top of the

00:02:02,640 --> 00:02:06,000
the business code we're just adding more

00:02:05,520 --> 00:02:09,840
bugs

00:02:06,000 --> 00:02:12,319
and so that's that's a risk issue

00:02:09,840 --> 00:02:14,720
and so naturally you might think well

00:02:12,319 --> 00:02:16,560
what if what if we could go back to

00:02:14,720 --> 00:02:18,080
just concentrating on what's important

00:02:16,560 --> 00:02:19,680
back to turning the

00:02:18,080 --> 00:02:21,280
computer the business concepts into

00:02:19,680 --> 00:02:22,959
computer concepts

00:02:21,280 --> 00:02:24,239
and we could do something else with all

00:02:22,959 --> 00:02:25,920
these other things we can't make them

00:02:24,239 --> 00:02:27,840
disappear because they're important they

00:02:25,920 --> 00:02:29,599
need to be done

00:02:27,840 --> 00:02:31,200
there's a couple ways that you can deal

00:02:29,599 --> 00:02:33,519
with it you can try to put it all behind

00:02:31,200 --> 00:02:36,560
trainer so that puts a lot of

00:02:33,519 --> 00:02:37,680
pressure on frameworks or maybe and this

00:02:36,560 --> 00:02:39,840
is what we try to do

00:02:37,680 --> 00:02:42,000
you can automate a lot of that and

00:02:39,840 --> 00:02:45,760
that's where morpher comes in

00:02:42,000 --> 00:02:48,720
so at its core morpher is a

00:02:45,760 --> 00:02:50,480
set of tools aimed at logic interchange

00:02:48,720 --> 00:02:53,040
and what that means is that

00:02:50,480 --> 00:02:54,239
we can define a set of logic put it into

00:02:53,040 --> 00:02:56,160
a data format

00:02:54,239 --> 00:02:58,800
in this case it's the morpher

00:02:56,160 --> 00:03:00,720
intermediary language or ir

00:02:58,800 --> 00:03:02,239
and once it's in a data format then we

00:03:00,720 --> 00:03:03,440
can do all kinds of things with it just

00:03:02,239 --> 00:03:06,720
like any other data

00:03:03,440 --> 00:03:08,400
so we can use that that data format to

00:03:06,720 --> 00:03:10,239
generate other code that runs in

00:03:08,400 --> 00:03:13,200
different runtime contexts or

00:03:10,239 --> 00:03:14,879
generate configuration and setup to the

00:03:13,200 --> 00:03:17,120
database and all these other kind of

00:03:14,879 --> 00:03:18,319
definitions that we might need

00:03:17,120 --> 00:03:20,720
we don't have to stop there we can

00:03:18,319 --> 00:03:22,720
generate full applications so

00:03:20,720 --> 00:03:24,480
we don't have to just concentrate on the

00:03:22,720 --> 00:03:26,080
code we can get into everything else

00:03:24,480 --> 00:03:27,360
that makes an application

00:03:26,080 --> 00:03:29,200
and that's what we're really talking

00:03:27,360 --> 00:03:30,799
about in the enterprise

00:03:29,200 --> 00:03:32,480
and on top of that we can do things like

00:03:30,799 --> 00:03:34,720
generate documentation

00:03:32,480 --> 00:03:36,239
generate lineage generate you know all

00:03:34,720 --> 00:03:39,040
these other things that the enterprise

00:03:36,239 --> 00:03:39,040
ask us to do

00:03:40,000 --> 00:03:44,239
morpher project has a number of goals

00:03:42,159 --> 00:03:46,159
the primary goal is to make business

00:03:44,239 --> 00:03:48,319
logic a first class asset

00:03:46,159 --> 00:03:49,680
something that's protected and stored

00:03:48,319 --> 00:03:50,959
separately from the rest of the

00:03:49,680 --> 00:03:53,680
application

00:03:50,959 --> 00:03:54,799
once it's in that format then we can do

00:03:53,680 --> 00:03:56,560
things like share it

00:03:54,799 --> 00:03:58,319
which is important if we want it to run

00:03:56,560 --> 00:04:00,000
in different contexts or maybe we want

00:03:58,319 --> 00:04:01,760
the same logic to run across different

00:04:00,000 --> 00:04:03,680
teams or maybe even different firms when

00:04:01,760 --> 00:04:05,840
we're talking about something like

00:04:03,680 --> 00:04:07,439
regulations we want to be able to

00:04:05,840 --> 00:04:08,560
translate it because

00:04:07,439 --> 00:04:10,000
we want it to run a different

00:04:08,560 --> 00:04:11,599
environment and in order to do that we

00:04:10,000 --> 00:04:12,400
need to translate it into different

00:04:11,599 --> 00:04:15,840
languages

00:04:12,400 --> 00:04:17,680
maybe different platforms uh

00:04:15,840 --> 00:04:19,600
documentation so we want to be able to

00:04:17,680 --> 00:04:20,799
take that logic and translate it into

00:04:19,600 --> 00:04:22,560
other tools

00:04:20,799 --> 00:04:24,880
we want to be able to store it because

00:04:22,560 --> 00:04:25,759
it is an asset right we don't want the

00:04:24,880 --> 00:04:28,400
um

00:04:25,759 --> 00:04:30,639
we don't have to risk rewriting it every

00:04:28,400 --> 00:04:33,680
time we want to change technologies

00:04:30,639 --> 00:04:35,360
and we all know that business evolves

00:04:33,680 --> 00:04:36,639
different than the technologies and they

00:04:35,360 --> 00:04:38,800
should be able to evolve

00:04:36,639 --> 00:04:40,400
independently and we want to be able to

00:04:38,800 --> 00:04:42,400
visualize it we want to

00:04:40,400 --> 00:04:44,320
give as much knowledge as possible we

00:04:42,400 --> 00:04:45,840
want new developers to be able to really

00:04:44,320 --> 00:04:49,280
understand the system

00:04:45,840 --> 00:04:50,960
uh without piecing through and diving

00:04:49,280 --> 00:04:53,520
into all kinds of

00:04:50,960 --> 00:04:54,400
uh hard to read code because it's mixed

00:04:53,520 --> 00:04:57,600
in with all

00:04:54,400 --> 00:04:58,880
all the persistence and messaging and

00:04:57,600 --> 00:05:00,320
all these other things that go into an

00:04:58,880 --> 00:05:03,199
application

00:05:00,320 --> 00:05:04,479
and some other goals that we have are

00:05:03,199 --> 00:05:07,680
that we want to increase

00:05:04,479 --> 00:05:10,000
efficiency with automation and

00:05:07,680 --> 00:05:11,840
that's that's a primary thing of what

00:05:10,000 --> 00:05:13,360
morpher does is that once you've got it

00:05:11,840 --> 00:05:15,520
in the stored format

00:05:13,360 --> 00:05:16,800
you can automate a whole lot of things

00:05:15,520 --> 00:05:19,680
not just code but

00:05:16,800 --> 00:05:20,720
documentation regulations audit all

00:05:19,680 --> 00:05:22,479
kinds of stuff

00:05:20,720 --> 00:05:23,759
we want to make sure it's correct so

00:05:22,479 --> 00:05:25,759
this is vital

00:05:23,759 --> 00:05:26,800
it's difficult to make sure that an

00:05:25,759 --> 00:05:28,240
application is

00:05:26,800 --> 00:05:30,479
correct and that is doing the right

00:05:28,240 --> 00:05:33,280
thing when the logic is

00:05:30,479 --> 00:05:35,280
all over the place or when the logic is

00:05:33,280 --> 00:05:38,800
mixed in with things like persistence

00:05:35,280 --> 00:05:41,520
and messaging and loading and so

00:05:38,800 --> 00:05:42,960
by consolidating on a model we're able

00:05:41,520 --> 00:05:44,960
to make it more correct

00:05:42,960 --> 00:05:46,479
and by consolidating on a functional

00:05:44,960 --> 00:05:49,759
model we're even

00:05:46,479 --> 00:05:51,280
able to do more than than just

00:05:49,759 --> 00:05:53,600
look at it and see that it's correct

00:05:51,280 --> 00:05:56,479
we're able to apply powerful tools

00:05:53,600 --> 00:05:58,080
to ensure that the model is more correct

00:05:56,479 --> 00:06:00,639
than we would usually be able to do with

00:05:58,080 --> 00:06:03,919
other programming languages

00:06:00,639 --> 00:06:04,880
it's important to note that bugs are a

00:06:03,919 --> 00:06:06,560
symptom

00:06:04,880 --> 00:06:08,160
they're a symptom of the code being

00:06:06,560 --> 00:06:10,880
wrong and

00:06:08,160 --> 00:06:12,720
testing and unit testing are great ways

00:06:10,880 --> 00:06:15,440
to handle that symptom

00:06:12,720 --> 00:06:17,039
it still means that we want to be able

00:06:15,440 --> 00:06:18,880
to take care of the cause

00:06:17,039 --> 00:06:20,080
and the causes we need to get the code

00:06:18,880 --> 00:06:22,720
right and so

00:06:20,080 --> 00:06:24,400
we want to be able to provide tools that

00:06:22,720 --> 00:06:26,400
enable us to do that

00:06:24,400 --> 00:06:28,240
we want to build knowledge as i said

00:06:26,400 --> 00:06:29,759
before we want new developers to be able

00:06:28,240 --> 00:06:31,440
to understand the system we also want

00:06:29,759 --> 00:06:32,080
the business users to understand the

00:06:31,440 --> 00:06:34,720
system

00:06:32,080 --> 00:06:36,240
and have confidence in the stem system

00:06:34,720 --> 00:06:38,560
and understand that

00:06:36,240 --> 00:06:39,360
what we have developed is actually what

00:06:38,560 --> 00:06:41,199
they wanted

00:06:39,360 --> 00:06:43,840
to do and there are a lot of things that

00:06:41,199 --> 00:06:46,319
we can do in terms of automating tools

00:06:43,840 --> 00:06:48,960
that allow the business users to have

00:06:46,319 --> 00:06:51,599
that confidence either in terms of

00:06:48,960 --> 00:06:54,240
of you know showing data flow through

00:06:51,599 --> 00:06:55,759
the system and why it's making decisions

00:06:54,240 --> 00:06:56,960
so not just that the data is going

00:06:55,759 --> 00:06:58,080
through the system and is making

00:06:56,960 --> 00:07:00,479
decisions but

00:06:58,080 --> 00:07:01,280
you know why did it make that decision

00:07:00,479 --> 00:07:03,840
and

00:07:01,280 --> 00:07:06,000
those are are important things for both

00:07:03,840 --> 00:07:08,479
the business and the technology

00:07:06,000 --> 00:07:09,520
finally we want a community we want to

00:07:08,479 --> 00:07:12,560
build a community

00:07:09,520 --> 00:07:14,880
we've realized that um

00:07:12,560 --> 00:07:16,400
once people start to to use more for and

00:07:14,880 --> 00:07:19,120
understand it then

00:07:16,400 --> 00:07:20,479
they get a lot of creative solutions and

00:07:19,120 --> 00:07:22,240
some of those solutions

00:07:20,479 --> 00:07:24,560
always come back and everybody can take

00:07:22,240 --> 00:07:25,199
advantage of them and it just builds a

00:07:24,560 --> 00:07:27,759
much

00:07:25,199 --> 00:07:29,360
stronger and stronger ecosystem and that

00:07:27,759 --> 00:07:31,039
was part of the motivation of open

00:07:29,360 --> 00:07:32,560
sourcing it was that

00:07:31,039 --> 00:07:36,479
we felt that we could build a really

00:07:32,560 --> 00:07:36,479
really strong ecosystem around this

00:07:37,360 --> 00:07:41,759
all right so what is the flow of

00:07:39,680 --> 00:07:42,880
developing a more for application

00:07:41,759 --> 00:07:44,879
so the first thing you're going to want

00:07:42,880 --> 00:07:48,400
to do is get your business logic

00:07:44,879 --> 00:07:49,599
sound in in into the morpher format so

00:07:48,400 --> 00:07:52,400
the first thing you do is

00:07:49,599 --> 00:07:54,479
work with the business closely and come

00:07:52,400 --> 00:07:56,160
up with what the business model

00:07:54,479 --> 00:07:58,720
design is so we're going to design the

00:07:56,160 --> 00:08:00,319
model once we have that model

00:07:58,720 --> 00:08:02,000
then we're going to want to generate

00:08:00,319 --> 00:08:03,680
something so we probably want to

00:08:02,000 --> 00:08:05,280
generate documentation

00:08:03,680 --> 00:08:07,039
we probably want to generate some kind

00:08:05,280 --> 00:08:09,120
of registration into whatever

00:08:07,039 --> 00:08:10,960
systems our enterprise use and most

00:08:09,120 --> 00:08:12,479
importantly we want to generate

00:08:10,960 --> 00:08:14,000
onto the platform that this thing's

00:08:12,479 --> 00:08:16,080
going to run on or maybe multiple

00:08:14,000 --> 00:08:18,000
platforms but we want to generate that

00:08:16,080 --> 00:08:19,680
so imagine that it's running in a

00:08:18,000 --> 00:08:20,960
microservice

00:08:19,680 --> 00:08:23,360
environment we want to be able to

00:08:20,960 --> 00:08:24,639
generate the code that actually runs

00:08:23,360 --> 00:08:26,400
that microservice

00:08:24,639 --> 00:08:27,919
and then once we have that code

00:08:26,400 --> 00:08:29,680
obviously we need to run it

00:08:27,919 --> 00:08:31,199
and so that's basically the more for

00:08:29,680 --> 00:08:33,599
flow design

00:08:31,199 --> 00:08:35,200
the business logic generate the

00:08:33,599 --> 00:08:38,399
application

00:08:35,200 --> 00:08:39,120
run the application and so what does

00:08:38,399 --> 00:08:41,120
that look at

00:08:39,120 --> 00:08:42,320
like in the bigger scheme of software

00:08:41,120 --> 00:08:44,000
development so

00:08:42,320 --> 00:08:46,880
probably right now you have something

00:08:44,000 --> 00:08:48,399
like the uh the top flow where

00:08:46,880 --> 00:08:50,800
you work with the business to come up

00:08:48,399 --> 00:08:52,839
with the business specifications

00:08:50,800 --> 00:08:54,560
you architect a solution for that

00:08:52,839 --> 00:08:57,839
particular problem

00:08:54,560 --> 00:08:59,120
then you code up the the business logic

00:08:57,839 --> 00:09:00,399
into that

00:08:59,120 --> 00:09:02,560
particular solution that you've

00:09:00,399 --> 00:09:04,320
architected and then

00:09:02,560 --> 00:09:05,680
you've got the regular build test and

00:09:04,320 --> 00:09:08,399
the deploy cycle

00:09:05,680 --> 00:09:09,040
so the first three steps here are very

00:09:08,399 --> 00:09:11,680
manual

00:09:09,040 --> 00:09:12,640
in the current flow what we want to do

00:09:11,680 --> 00:09:15,839
is

00:09:12,640 --> 00:09:17,680
move that so that the we minimize

00:09:15,839 --> 00:09:18,880
as much manual effort as possible and we

00:09:17,680 --> 00:09:21,839
can do that by

00:09:18,880 --> 00:09:23,680
getting the business specs together and

00:09:21,839 --> 00:09:25,120
that's the only manual process anything

00:09:23,680 --> 00:09:25,920
about it that should be the only manual

00:09:25,120 --> 00:09:28,000
process

00:09:25,920 --> 00:09:30,560
and then everything else after that we

00:09:28,000 --> 00:09:30,560
can automate

00:09:30,640 --> 00:09:34,480
so let's dig in and take a look at what

00:09:32,399 --> 00:09:37,279
that actually looks like

00:09:34,480 --> 00:09:38,320
we're gonna take a sample common

00:09:37,279 --> 00:09:40,080
application so

00:09:38,320 --> 00:09:42,720
i think about a microservice or any kind

00:09:40,080 --> 00:09:44,240
of service that takes a request

00:09:42,720 --> 00:09:46,000
and does something with it so in this

00:09:44,240 --> 00:09:48,720
case we're going to have a

00:09:46,000 --> 00:09:50,800
a small micro service sample called

00:09:48,720 --> 00:09:51,120
books and records that takes a request

00:09:50,800 --> 00:09:55,200
to

00:09:51,120 --> 00:09:56,880
book a deal and run some logic

00:09:55,200 --> 00:09:59,519
to see whether we should book that deal

00:09:56,880 --> 00:10:01,360
and if so it books it and if not it

00:09:59,519 --> 00:10:03,519
rejects it for some reason so

00:10:01,360 --> 00:10:04,800
standard microservice architecture

00:10:03,519 --> 00:10:06,560
application

00:10:04,800 --> 00:10:08,320
so the thing we realize with a

00:10:06,560 --> 00:10:10,320
microservice is that

00:10:08,320 --> 00:10:12,240
you know this is actually a business

00:10:10,320 --> 00:10:12,880
process and it's a business process that

00:10:12,240 --> 00:10:15,920
follows

00:10:12,880 --> 00:10:17,440
a very standard pattern of it takes some

00:10:15,920 --> 00:10:20,000
input

00:10:17,440 --> 00:10:21,120
it runs some logic and then it produces

00:10:20,000 --> 00:10:22,959
some results

00:10:21,120 --> 00:10:25,279
and whenever we have a pattern like that

00:10:22,959 --> 00:10:27,600
that's a good case for automation

00:10:25,279 --> 00:10:29,279
and so let's look at that so in this

00:10:27,600 --> 00:10:31,920
case the request

00:10:29,279 --> 00:10:32,959
the input is that we either create a

00:10:31,920 --> 00:10:34,640
deal

00:10:32,959 --> 00:10:36,240
um in which case we're trying to book it

00:10:34,640 --> 00:10:38,000
into our booking system

00:10:36,240 --> 00:10:39,360
or we close the deal in which case we're

00:10:38,000 --> 00:10:39,839
trying to remove it from our booking

00:10:39,360 --> 00:10:44,240
system

00:10:39,839 --> 00:10:44,240
in one way or the other and so

00:10:45,040 --> 00:10:50,160
how we would model that so more for

00:10:48,160 --> 00:10:51,600
as i said before it's using a open

00:10:50,160 --> 00:10:54,959
source programming language called

00:10:51,600 --> 00:10:57,120
elm and in elm that looks like this

00:10:54,959 --> 00:10:59,040
and it really reads as um you're

00:10:57,120 --> 00:11:02,160
defining a union type

00:10:59,040 --> 00:11:03,440
where either of these could be a command

00:11:02,160 --> 00:11:05,200
you can

00:11:03,440 --> 00:11:07,279
have a command that either says open the

00:11:05,200 --> 00:11:08,160
deal with all the parameters that are

00:11:07,279 --> 00:11:12,640
required

00:11:08,160 --> 00:11:14,720
or close the deal so similarly

00:11:12,640 --> 00:11:17,440
we want to see the results right and so

00:11:14,720 --> 00:11:18,880
the specifications say

00:11:17,440 --> 00:11:20,480
that a client would want to see the

00:11:18,880 --> 00:11:22,959
results maybe there's somebody else that

00:11:20,480 --> 00:11:24,480
wants to receive the results so

00:11:22,959 --> 00:11:26,000
maybe we should we should do something

00:11:24,480 --> 00:11:28,399
with that as well but

00:11:26,000 --> 00:11:29,760
in the end you know the pattern is that

00:11:28,399 --> 00:11:32,959
we need to see a result

00:11:29,760 --> 00:11:35,120
and what that looks like in morpher is

00:11:32,959 --> 00:11:36,640
again another union type of here's the

00:11:35,120 --> 00:11:38,560
possible things that

00:11:36,640 --> 00:11:39,920
the outcomes that we could have for the

00:11:38,560 --> 00:11:41,839
inputs that we have

00:11:39,920 --> 00:11:43,600
so we can either open the deal and say

00:11:41,839 --> 00:11:44,399
that yeah it was successfully opened or

00:11:43,600 --> 00:11:46,959
closed

00:11:44,399 --> 00:11:47,760
or something was wrong and the request

00:11:46,959 --> 00:11:50,399
was invalid

00:11:47,760 --> 00:11:52,800
in which case we want to let them know

00:11:50,399 --> 00:11:54,399
that as well

00:11:52,800 --> 00:11:56,079
most microservices have some kind of

00:11:54,399 --> 00:11:58,800
state in between calls

00:11:56,079 --> 00:12:00,560
um so this is common still a business

00:11:58,800 --> 00:12:02,639
model you know business model says that

00:12:00,560 --> 00:12:05,279
we want to keep some state

00:12:02,639 --> 00:12:07,200
and in this case the state is a bunch of

00:12:05,279 --> 00:12:10,880
deals or a list of deals

00:12:07,200 --> 00:12:12,639
and so in the deal these are the

00:12:10,880 --> 00:12:14,639
the parameters that we want to store

00:12:12,639 --> 00:12:16,880
this again we work out with the business

00:12:14,639 --> 00:12:18,800
this is how we would model it in elm

00:12:16,880 --> 00:12:20,399
and in this case this is a record type

00:12:18,800 --> 00:12:22,399
which is you know standard data

00:12:20,399 --> 00:12:25,839
structure

00:12:22,399 --> 00:12:29,200
and then finally uh and not not

00:12:25,839 --> 00:12:31,760
the the least is the the logic

00:12:29,200 --> 00:12:33,600
so when we get a request you know what

00:12:31,760 --> 00:12:34,560
do we need to do with it in our case we

00:12:33,600 --> 00:12:36,639
want to check

00:12:34,560 --> 00:12:38,000
that the price and the quantity are

00:12:36,639 --> 00:12:42,160
valid um

00:12:38,000 --> 00:12:45,040
so there's no specification on there uh

00:12:42,160 --> 00:12:46,000
that that says that you know these are

00:12:45,040 --> 00:12:48,560
these are

00:12:46,000 --> 00:12:49,440
they can only be less than zero or

00:12:48,560 --> 00:12:52,000
greater than zero

00:12:49,440 --> 00:12:52,800
and so um that's what our business

00:12:52,000 --> 00:12:54,639
object is doing

00:12:52,800 --> 00:12:56,240
so we kept it very simple for the

00:12:54,639 --> 00:12:58,160
example obviously

00:12:56,240 --> 00:13:00,720
most applications have much more complex

00:12:58,160 --> 00:13:03,120
business logic

00:13:00,720 --> 00:13:03,839
but that's it and so it's a standard

00:13:03,120 --> 00:13:06,720
pattern

00:13:03,839 --> 00:13:10,160
it's a request response state and then

00:13:06,720 --> 00:13:10,160
the logic for processing it

00:13:12,320 --> 00:13:15,680
all right so let's take a look at this

00:13:14,079 --> 00:13:17,519
code in an ide

00:13:15,680 --> 00:13:18,959
so one of the things i want to point out

00:13:17,519 --> 00:13:21,120
is that with with

00:13:18,959 --> 00:13:22,320
more for we're really focused on

00:13:21,120 --> 00:13:25,120
domain-driven

00:13:22,320 --> 00:13:25,760
development or domain-driven design and

00:13:25,120 --> 00:13:28,320
one of the

00:13:25,760 --> 00:13:29,519
principles of that is that we use the

00:13:28,320 --> 00:13:32,480
business language

00:13:29,519 --> 00:13:33,279
when we make our technology so we want

00:13:32,480 --> 00:13:35,680
to use

00:13:33,279 --> 00:13:37,040
terms like price and quantity especially

00:13:35,680 --> 00:13:37,760
when we're talking with the business we

00:13:37,040 --> 00:13:39,920
would never say

00:13:37,760 --> 00:13:41,920
things like float or into the business

00:13:39,920 --> 00:13:44,800
and so we want to capture that

00:13:41,920 --> 00:13:45,120
in our model and we do this with the elm

00:13:44,800 --> 00:13:49,279
type

00:13:45,120 --> 00:13:52,240
aliases so that's very important and

00:13:49,279 --> 00:13:53,760
um you know we see all the rest here the

00:13:52,240 --> 00:13:55,199
the commands and the inputs and the

00:13:53,760 --> 00:13:57,519
outputs in the state

00:13:55,199 --> 00:13:59,519
and in the business logic and that's it

00:13:57,519 --> 00:14:02,079
that's the entire application

00:13:59,519 --> 00:14:04,320
so you'll notice nothing in here says

00:14:02,079 --> 00:14:05,199
that this is restful or using a message

00:14:04,320 --> 00:14:09,279
queue

00:14:05,199 --> 00:14:12,320
or if it's event sourced or using

00:14:09,279 --> 00:14:13,920
regular oltp and database transactions

00:14:12,320 --> 00:14:15,920
or any of that stuff

00:14:13,920 --> 00:14:17,680
none of that is in there and what that

00:14:15,920 --> 00:14:20,240
does is it makes it very easy

00:14:17,680 --> 00:14:20,720
to understand the code so we can see

00:14:20,240 --> 00:14:23,279
that

00:14:20,720 --> 00:14:24,880
this service is is really you know

00:14:23,279 --> 00:14:26,560
here's the inputs and outputs it's very

00:14:24,880 --> 00:14:29,760
easy to understand

00:14:26,560 --> 00:14:32,320
and it's often very difficult to do when

00:14:29,760 --> 00:14:34,240
you look at enterprise software because

00:14:32,320 --> 00:14:36,480
the code is scattered throughout

00:14:34,240 --> 00:14:37,920
different parts of the system

00:14:36,480 --> 00:14:39,920
and it's you know some of the codes in

00:14:37,920 --> 00:14:41,279
the database and some of the codes in ui

00:14:39,920 --> 00:14:42,639
code and some of the codes in the

00:14:41,279 --> 00:14:45,360
service

00:14:42,639 --> 00:14:48,000
and so if we can model it like this as

00:14:45,360 --> 00:14:50,079
the system gets bigger and more complex

00:14:48,000 --> 00:14:51,920
it's really nice to be able to look at

00:14:50,079 --> 00:14:53,760
the thing holistically and really

00:14:51,920 --> 00:14:56,160
understand what's going on

00:14:53,760 --> 00:14:58,240
without being distracted with oh it's

00:14:56,160 --> 00:14:58,480
got to save something here or it's you

00:14:58,240 --> 00:15:00,240
know

00:14:58,480 --> 00:15:01,440
loading stuff from the database there or

00:15:00,240 --> 00:15:02,959
any of that stuff that makes it

00:15:01,440 --> 00:15:06,560
difficult to understand

00:15:02,959 --> 00:15:08,079
and so that's a really important concept

00:15:06,560 --> 00:15:10,079
and so what we're going to do here is

00:15:08,079 --> 00:15:13,120
we're going to take this model

00:15:10,079 --> 00:15:17,440
and we're going to basically

00:15:13,120 --> 00:15:19,279
turn it into the morpher ir

00:15:17,440 --> 00:15:20,480
again we're using elm in this case to do

00:15:19,279 --> 00:15:22,399
the modeling

00:15:20,480 --> 00:15:24,079
and so what we're doing is we're parsing

00:15:22,399 --> 00:15:28,000
elm into

00:15:24,079 --> 00:15:30,399
the morpher ir and um

00:15:28,000 --> 00:15:32,160
just as a reminder that elm is not the

00:15:30,399 --> 00:15:34,160
only language we can do this with

00:15:32,160 --> 00:15:36,320
and so this is often interesting in

00:15:34,160 --> 00:15:39,360
terms of enterprises because

00:15:36,320 --> 00:15:40,800
often an enterprise has a lot of little

00:15:39,360 --> 00:15:44,000
bespoke

00:15:40,800 --> 00:15:47,279
dsls domain domain

00:15:44,000 --> 00:15:48,560
languages and you know little expression

00:15:47,279 --> 00:15:52,000
languages that pepper

00:15:48,560 --> 00:15:54,480
throughout the entire enterprise

00:15:52,000 --> 00:15:56,000
and they've kind of end of life nobody's

00:15:54,480 --> 00:15:58,480
really keeping them up but they're still

00:15:56,000 --> 00:16:00,320
making the application run and so nobody

00:15:58,480 --> 00:16:02,320
really knows what to do with that and so

00:16:00,320 --> 00:16:03,440
morpher is a is an interesting way of

00:16:02,320 --> 00:16:06,639
dealing with that

00:16:03,440 --> 00:16:08,480
and if you can parse those languages

00:16:06,639 --> 00:16:09,839
into the morpher ir

00:16:08,480 --> 00:16:12,000
then you can take advantage of the

00:16:09,839 --> 00:16:14,000
morpher tools which means that you can

00:16:12,000 --> 00:16:16,399
transpile them into scala

00:16:14,000 --> 00:16:18,160
into elm into some other language and

00:16:16,399 --> 00:16:20,839
that gives a lifeline to those languages

00:16:18,160 --> 00:16:23,600
they're no longer stuck in a bespoke

00:16:20,839 --> 00:16:25,279
dsl

00:16:23,600 --> 00:16:28,480
and so the next thing we're going to do

00:16:25,279 --> 00:16:32,000
is once we've got that ir

00:16:28,480 --> 00:16:33,759
we still want to make this thing run and

00:16:32,000 --> 00:16:36,399
what we're going to do is we're going to

00:16:33,759 --> 00:16:38,959
say well this time we want

00:16:36,399 --> 00:16:40,000
this to run in dapper so our output

00:16:38,959 --> 00:16:42,800
target is a

00:16:40,000 --> 00:16:43,440
adapter application and so we'll see

00:16:42,800 --> 00:16:46,800
that it's

00:16:43,440 --> 00:16:48,959
it's generating all this code

00:16:46,800 --> 00:16:50,320
it generated over here and one of the

00:16:48,959 --> 00:16:52,000
things we notice here is that it's

00:16:50,320 --> 00:16:54,320
generating the maven

00:16:52,000 --> 00:16:57,759
as well so it's not just generating code

00:16:54,320 --> 00:16:59,279
it's generating the entire application

00:16:57,759 --> 00:17:00,959
and so we can look at the code and we

00:16:59,279 --> 00:17:01,519
can see that everything that was in the

00:17:00,959 --> 00:17:03,839
model

00:17:01,519 --> 00:17:05,199
is now in case classes in scala so that

00:17:03,839 --> 00:17:07,199
it's it's all there

00:17:05,199 --> 00:17:09,039
the logic is here so the you know the

00:17:07,199 --> 00:17:12,160
logic gets translated too

00:17:09,039 --> 00:17:14,160
and then all the dapper stuff

00:17:12,160 --> 00:17:16,640
is is in there as well so all the things

00:17:14,160 --> 00:17:19,919
that we would normally write by hand

00:17:16,640 --> 00:17:22,480
we are now generating and that

00:17:19,919 --> 00:17:25,199
is advantageous because it saves time

00:17:22,480 --> 00:17:28,559
and it saves bugs as we mentioned before

00:17:25,199 --> 00:17:30,880
the less human code is written

00:17:28,559 --> 00:17:33,840
the the the less bugs will be produced

00:17:30,880 --> 00:17:36,960
so it saves us from possible bugs

00:17:33,840 --> 00:17:39,600
um and it also makes things uh

00:17:36,960 --> 00:17:40,799
um you know kind of future proof and

00:17:39,600 --> 00:17:42,640
evolution proof

00:17:40,799 --> 00:17:45,919
so if we wanted to do something like

00:17:42,640 --> 00:17:47,039
change the messaging format from jackson

00:17:45,919 --> 00:17:49,919
and jason to

00:17:47,039 --> 00:17:50,480
grpc we could do that and we wouldn't

00:17:49,919 --> 00:17:52,640
have to go

00:17:50,480 --> 00:17:55,039
back to the developers and tell them to

00:17:52,640 --> 00:17:58,080
do that or if we wanted to make this run

00:17:55,039 --> 00:18:00,480
you know dapper is a great runtime but

00:17:58,080 --> 00:18:02,160
a lot of this logic might need to run

00:18:00,480 --> 00:18:03,840
somewhere else like in the database if

00:18:02,160 --> 00:18:06,640
we're running reports

00:18:03,840 --> 00:18:08,880
and if we want to be able to to you know

00:18:06,640 --> 00:18:10,480
like replay something and see why it

00:18:08,880 --> 00:18:12,799
came to a conclusion

00:18:10,480 --> 00:18:14,880
you know why did it reject this thing

00:18:12,799 --> 00:18:15,440
well you know we can do things like make

00:18:14,880 --> 00:18:18,240
that run

00:18:15,440 --> 00:18:18,720
in the in the browser and and make that

00:18:18,240 --> 00:18:20,320
run in

00:18:18,720 --> 00:18:24,080
in a different system at a different

00:18:20,320 --> 00:18:24,080
time using different technologies

00:18:24,240 --> 00:18:29,520
and know that we get consistent results

00:18:27,440 --> 00:18:31,360
and uh you know that's that's obviously

00:18:29,520 --> 00:18:33,200
important too and

00:18:31,360 --> 00:18:35,600
you know we can also think about other

00:18:33,200 --> 00:18:36,799
ways we can use this so

00:18:35,600 --> 00:18:40,000
you know let's take something like

00:18:36,799 --> 00:18:41,520
contract driven development where

00:18:40,000 --> 00:18:43,440
a contract driven development is

00:18:41,520 --> 00:18:46,880
basically a way to do

00:18:43,440 --> 00:18:48,480
rest rest api testing where

00:18:46,880 --> 00:18:50,240
the the server doesn't have to be

00:18:48,480 --> 00:18:51,919
running you should be able to

00:18:50,240 --> 00:18:53,840
have some confidence that the client

00:18:51,919 --> 00:18:56,080
code you're writing is going to get

00:18:53,840 --> 00:18:56,960
the some certain results from the server

00:18:56,080 --> 00:18:59,760
without

00:18:56,960 --> 00:19:01,600
making the server be running and the way

00:18:59,760 --> 00:19:04,720
to do that is that you have these mock

00:19:01,600 --> 00:19:05,919
clients there or mock servers um that

00:19:04,720 --> 00:19:07,679
the clients call

00:19:05,919 --> 00:19:09,760
well imagine that if we could take the

00:19:07,679 --> 00:19:10,000
entire set of business logic that's in

00:19:09,760 --> 00:19:12,720
the

00:19:10,000 --> 00:19:13,919
server that the server's running and

00:19:12,720 --> 00:19:16,240
make that run

00:19:13,919 --> 00:19:17,919
on that mock or in the browser so then

00:19:16,240 --> 00:19:20,559
we could type in things

00:19:17,919 --> 00:19:22,480
and test our clients and immediately

00:19:20,559 --> 00:19:23,919
know the full range of results that

00:19:22,480 --> 00:19:26,320
we're going to get which is

00:19:23,919 --> 00:19:27,440
a lot more meaningful than just a couple

00:19:26,320 --> 00:19:29,280
test cases

00:19:27,440 --> 00:19:31,200
that that contract driven development

00:19:29,280 --> 00:19:34,400
does now so there's a whole lot of

00:19:31,200 --> 00:19:34,400
things that we can do with this

00:19:34,720 --> 00:19:38,480
and so in summary what have we done

00:19:36,400 --> 00:19:40,400
we've taken

00:19:38,480 --> 00:19:42,240
a pattern that's common in the business

00:19:40,400 --> 00:19:46,799
world inputs outputs

00:19:42,240 --> 00:19:49,200
some state we've converted that into

00:19:46,799 --> 00:19:50,000
computer concepts high level computer

00:19:49,200 --> 00:19:51,600
concepts

00:19:50,000 --> 00:19:54,160
not you know how are these things going

00:19:51,600 --> 00:19:56,880
to run but computer concepts

00:19:54,160 --> 00:19:58,559
and then we've automated turning that

00:19:56,880 --> 00:20:01,600
into a running

00:19:58,559 --> 00:20:04,400
application and that application is

00:20:01,600 --> 00:20:07,280
is on dapper so we've automated the code

00:20:04,400 --> 00:20:07,760
the the json bindings the persistence

00:20:07,280 --> 00:20:10,400
the

00:20:07,760 --> 00:20:11,440
event mechanism and most importantly the

00:20:10,400 --> 00:20:13,360
dapper code

00:20:11,440 --> 00:20:15,760
and with that i'm going to pass this to

00:20:13,360 --> 00:20:17,919
adam and he's going to explain

00:20:15,760 --> 00:20:19,360
dapper and its advantages and how it

00:20:17,919 --> 00:20:21,760
works

00:20:19,360 --> 00:20:23,280
hey adam herwitz here with microsoft i'm

00:20:21,760 --> 00:20:24,240
an azure specialist in the financial

00:20:23,280 --> 00:20:27,840
services

00:20:24,240 --> 00:20:29,280
organization and you just heard from

00:20:27,840 --> 00:20:32,400
stephen goldbaum

00:20:29,280 --> 00:20:34,080
from morgan stanley about the

00:20:32,400 --> 00:20:36,159
the morpher project and the first thing

00:20:34,080 --> 00:20:38,799
i want to do is i just want to commend

00:20:36,159 --> 00:20:39,679
morgan stanley absolutely in terms of

00:20:38,799 --> 00:20:41,679
open

00:20:39,679 --> 00:20:43,679
sourcing this project and taking their

00:20:41,679 --> 00:20:45,039
years of experience in ip and sharing it

00:20:43,679 --> 00:20:46,640
with the community

00:20:45,039 --> 00:20:47,760
i think there's a lot of benefit that

00:20:46,640 --> 00:20:48,720
other companies are going to get from

00:20:47,760 --> 00:20:50,799
this and

00:20:48,720 --> 00:20:52,240
you know we're definitely excited to see

00:20:50,799 --> 00:20:55,360
how this project

00:20:52,240 --> 00:20:58,559
develops as an open source project

00:20:55,360 --> 00:21:01,679
what i'm here to talk about is dapper

00:20:58,559 --> 00:21:02,000
you would have heard about that uh just

00:21:01,679 --> 00:21:05,120
now

00:21:02,000 --> 00:21:07,600
with uh from stephen that morpher

00:21:05,120 --> 00:21:09,360
the morpho project can work well in

00:21:07,600 --> 00:21:11,520
combination with dapper and dapper is a

00:21:09,360 --> 00:21:13,679
microsoft open source project

00:21:11,520 --> 00:21:15,200
and so you know this is what we want to

00:21:13,679 --> 00:21:16,320
explore right now

00:21:15,200 --> 00:21:19,520
go a little deeper make sure you

00:21:16,320 --> 00:21:22,799
understand uh how this what this tool is

00:21:19,520 --> 00:21:24,000
and in the basics of how it works so let

00:21:22,799 --> 00:21:27,760
me just switch over

00:21:24,000 --> 00:21:30,000
here so dapper

00:21:27,760 --> 00:21:31,440
it's uh you know it's a cute name open

00:21:30,000 --> 00:21:32,320
source projects all have to have cute

00:21:31,440 --> 00:21:35,039
names now

00:21:32,320 --> 00:21:37,120
d-a-p-r um and it's a distributed

00:21:35,039 --> 00:21:39,280
application runtime it's available

00:21:37,120 --> 00:21:41,039
you know you should go check it out uh

00:21:39,280 --> 00:21:44,400
dapper.io

00:21:41,039 --> 00:21:46,240
uh it's a open source project uh

00:21:44,400 --> 00:21:48,000
it's in github so this will click

00:21:46,240 --> 00:21:48,880
through to various repos that we have in

00:21:48,000 --> 00:21:51,280
github

00:21:48,880 --> 00:21:52,880
um and you know a distributed

00:21:51,280 --> 00:21:55,840
application runtime it

00:21:52,880 --> 00:21:57,520
the focus here is you know you're you're

00:21:55,840 --> 00:22:01,200
a developer

00:21:57,520 --> 00:22:02,559
and you are creating services that are

00:22:01,200 --> 00:22:04,240
part of

00:22:02,559 --> 00:22:06,480
a distributed application and you know

00:22:04,240 --> 00:22:08,000
so many applications now

00:22:06,480 --> 00:22:10,080
are distributed certainly all the

00:22:08,000 --> 00:22:11,360
significant applications being built now

00:22:10,080 --> 00:22:13,200
the kind of complexity they have the

00:22:11,360 --> 00:22:16,240
number of people they have have the

00:22:13,200 --> 00:22:18,960
you know a microservice architecture um

00:22:16,240 --> 00:22:20,640
um distributed out but you know such

00:22:18,960 --> 00:22:21,600
that multiple teams are working on this

00:22:20,640 --> 00:22:24,960
so

00:22:21,600 --> 00:22:27,679
dapper provides building blocks uh

00:22:24,960 --> 00:22:29,120
for you to use as a developer to build

00:22:27,679 --> 00:22:30,960
your application and do it

00:22:29,120 --> 00:22:32,159
in an easier fashion without having to

00:22:30,960 --> 00:22:34,960
worry about

00:22:32,159 --> 00:22:37,120
um how those building blocks are

00:22:34,960 --> 00:22:39,360
implemented exactly

00:22:37,120 --> 00:22:41,280
and how those how they're provided to

00:22:39,360 --> 00:22:45,039
you and i'll get into more detail

00:22:41,280 --> 00:22:45,039
what i mean by that um

00:22:45,120 --> 00:22:49,760
first i want to just uh say some of the

00:22:48,240 --> 00:22:53,120
high level goals here okay

00:22:49,760 --> 00:22:55,919
so we have a developer wants to build a

00:22:53,120 --> 00:22:57,840
distributed application into a team so

00:22:55,919 --> 00:23:00,960
they're going to decide to use

00:22:57,840 --> 00:23:01,840
dapper they want to have best practice

00:23:00,960 --> 00:23:03,280
building blocks

00:23:01,840 --> 00:23:04,480
around building the application they

00:23:03,280 --> 00:23:05,600
want to use any language or framework

00:23:04,480 --> 00:23:08,000
this is an interesting point

00:23:05,600 --> 00:23:09,919
i just want to touch on because you know

00:23:08,000 --> 00:23:12,480
certainly in large

00:23:09,919 --> 00:23:14,080
systems there's multiple teams lots of

00:23:12,480 --> 00:23:16,159
teams maybe there's some legacy code as

00:23:14,080 --> 00:23:18,720
well for certain functionality

00:23:16,159 --> 00:23:19,600
perhaps and you know they're using

00:23:18,720 --> 00:23:22,000
different languages

00:23:19,600 --> 00:23:23,520
using different tech stacks and so it's

00:23:22,000 --> 00:23:25,440
very important that that is supported

00:23:23,520 --> 00:23:26,880
for a distributed application

00:23:25,440 --> 00:23:28,640
as is talked about it's open source we

00:23:26,880 --> 00:23:31,280
want the community to be involved

00:23:28,640 --> 00:23:31,679
uh and and and have it use standards and

00:23:31,280 --> 00:23:35,600
be

00:23:31,679 --> 00:23:38,720
open in terms of the api and consistent

00:23:35,600 --> 00:23:41,120
agnostic to cloud platform is important

00:23:38,720 --> 00:23:42,400
and edge you know this should not be

00:23:41,120 --> 00:23:45,039
tied to

00:23:42,400 --> 00:23:46,159
um one cloud platform it should be

00:23:45,039 --> 00:23:49,520
something that you can run

00:23:46,159 --> 00:23:51,200
on premise cloud uh really anywhere

00:23:49,520 --> 00:23:52,480
uh for it to really be usable in terms

00:23:51,200 --> 00:23:53,600
of your distributed application because

00:23:52,480 --> 00:23:54,320
that's what we're seeing we're seeing

00:23:53,600 --> 00:23:56,799
people

00:23:54,320 --> 00:23:58,400
um who want to make sure that they have

00:23:56,799 --> 00:23:59,360
uh you know their application running in

00:23:58,400 --> 00:24:02,159
multiple places

00:23:59,360 --> 00:24:03,520
often um and then of course extensible

00:24:02,159 --> 00:24:06,799
and plugable it's how

00:24:03,520 --> 00:24:08,240
you know pluggable gets into for

00:24:06,799 --> 00:24:10,080
in a second it'll be a little more clear

00:24:08,240 --> 00:24:12,400
what we mean by that these building

00:24:10,080 --> 00:24:14,080
blocks these services that you're using

00:24:12,400 --> 00:24:15,440
in your application for it to work

00:24:14,080 --> 00:24:18,080
there should be different ways to plug

00:24:15,440 --> 00:24:21,360
in different implementations

00:24:18,080 --> 00:24:25,360
essentially um and extensible you know

00:24:21,360 --> 00:24:27,440
instead of others

00:24:25,360 --> 00:24:29,360
other companies other other developers

00:24:27,440 --> 00:24:30,720
wanting to

00:24:29,360 --> 00:24:32,000
work on the core functionality they

00:24:30,720 --> 00:24:34,240
should be able to add in other

00:24:32,000 --> 00:24:37,360
components and extend these

00:24:34,240 --> 00:24:40,240
the implementation of uh of the system

00:24:37,360 --> 00:24:41,360
uh really so let's start at the bottom

00:24:40,240 --> 00:24:43,039
here

00:24:41,360 --> 00:24:45,039
these building blocks i'm talking about

00:24:43,039 --> 00:24:46,240
what are you know let's talk about some

00:24:45,039 --> 00:24:48,159
of them um

00:24:46,240 --> 00:24:49,200
you know at a high level i think they're

00:24:48,159 --> 00:24:51,200
relatively straightforward if you've

00:24:49,200 --> 00:24:52,799
been working on any distributed

00:24:51,200 --> 00:24:54,159
applications of course you know let's

00:24:52,799 --> 00:24:55,200
just start this simple one i won't go

00:24:54,159 --> 00:24:56,480
through all these but

00:24:55,200 --> 00:24:59,200
the you know service to service

00:24:56,480 --> 00:25:02,159
invocation obvious you know initial

00:24:59,200 --> 00:25:04,480
uh problem to uh to deal with and solve

00:25:02,159 --> 00:25:06,400
um you have multiple micro services

00:25:04,480 --> 00:25:08,240
uh that are operating as part of your

00:25:06,400 --> 00:25:09,760
system how do they talk to each other

00:25:08,240 --> 00:25:12,720
how do they call each other

00:25:09,760 --> 00:25:14,240
um so that service to service uh

00:25:12,720 --> 00:25:14,960
invoking a function on a different

00:25:14,240 --> 00:25:16,240
service

00:25:14,960 --> 00:25:17,440
is something that dapper can provide

00:25:16,240 --> 00:25:19,440
that's one of these building blocks

00:25:17,440 --> 00:25:22,880
which is incredibly useful

00:25:19,440 --> 00:25:26,000
state management of course another

00:25:22,880 --> 00:25:28,000
you know foundational need

00:25:26,000 --> 00:25:29,039
for your application you need to save

00:25:28,000 --> 00:25:30,720
state

00:25:29,039 --> 00:25:32,640
and et cetera you can see across these

00:25:30,720 --> 00:25:35,840
different building blocks

00:25:32,640 --> 00:25:37,120
that you know we feel are generally the

00:25:35,840 --> 00:25:38,320
ones

00:25:37,120 --> 00:25:39,600
that you know that you need when you're

00:25:38,320 --> 00:25:40,880
building your application now we're

00:25:39,600 --> 00:25:42,559
going to be adding to these

00:25:40,880 --> 00:25:44,480
you can pick and choose which ones make

00:25:42,559 --> 00:25:46,159
sense to you you know one here for

00:25:44,480 --> 00:25:47,840
instance actors

00:25:46,159 --> 00:25:50,159
you know is that a programming model

00:25:47,840 --> 00:25:51,520
that you use you know if so then this is

00:25:50,159 --> 00:25:54,000
great some people do

00:25:51,520 --> 00:25:55,360
uh many people don't so that's just not

00:25:54,000 --> 00:25:56,159
you know a building block that you make

00:25:55,360 --> 00:25:57,919
use of

00:25:56,159 --> 00:26:00,159
now what's really important here to

00:25:57,919 --> 00:26:03,679
point out uh and notice

00:26:00,159 --> 00:26:05,360
um is the api so i talked about let's do

00:26:03,679 --> 00:26:07,279
standards let's do opens do portable

00:26:05,360 --> 00:26:09,440
let's do consistent well look you know

00:26:07,279 --> 00:26:10,799
you have look at how the apis are

00:26:09,440 --> 00:26:15,120
talking it's http

00:26:10,799 --> 00:26:18,080
it's grpc you know anybody

00:26:15,120 --> 00:26:18,960
any system any application code

00:26:18,080 --> 00:26:22,080
techstack

00:26:18,960 --> 00:26:24,320
can speak http at this point

00:26:22,080 --> 00:26:25,440
certainly and you know they have grpc

00:26:24,320 --> 00:26:28,720
implementations of

00:26:25,440 --> 00:26:31,760
uh uh certainly as well but http

00:26:28,720 --> 00:26:33,919
um by and large um uh you know

00:26:31,760 --> 00:26:35,120
allows us to to say across the board any

00:26:33,919 --> 00:26:37,120
code uh

00:26:35,120 --> 00:26:39,120
or framework uh that you wanna use that

00:26:37,120 --> 00:26:41,760
you want to bring

00:26:39,120 --> 00:26:42,559
so that is how your code calls into

00:26:41,760 --> 00:26:43,919
dapper

00:26:42,559 --> 00:26:46,320
into the dapper system into these

00:26:43,919 --> 00:26:47,679
building blocks um is through that

00:26:46,320 --> 00:26:50,080
that api and just give you a little

00:26:47,679 --> 00:26:51,440
flavor here you know this error

00:26:50,080 --> 00:26:54,080
are some standard calls that you're

00:26:51,440 --> 00:26:54,799
gonna make i'll get a little deeper into

00:26:54,080 --> 00:26:59,520
this now

00:26:54,799 --> 00:27:02,400
um you know the architecture in general

00:26:59,520 --> 00:27:03,760
uh is a sidecar architecture this is

00:27:02,400 --> 00:27:05,919
becoming more popular

00:27:03,760 --> 00:27:07,679
it's certainly something more people

00:27:05,919 --> 00:27:09,840
have been uh you know uh

00:27:07,679 --> 00:27:11,840
thinking about talking about in the last

00:27:09,840 --> 00:27:15,679
uh i don't know a few years

00:27:11,840 --> 00:27:18,840
or so and so you can see here um

00:27:15,679 --> 00:27:20,000
now in this you know uh uh description

00:27:18,840 --> 00:27:21,600
of

00:27:20,000 --> 00:27:23,919
a system that uses dapper that's built

00:27:21,600 --> 00:27:26,480
with tapper you know you have two

00:27:23,919 --> 00:27:27,440
applications two services two micro

00:27:26,480 --> 00:27:30,000
services

00:27:27,440 --> 00:27:31,200
service code a service code b that make

00:27:30,000 --> 00:27:32,960
up your application

00:27:31,200 --> 00:27:35,520
and then of course there's a side car

00:27:32,960 --> 00:27:38,399
with each which is dapper

00:27:35,520 --> 00:27:40,640
right so there's a dapper demon running

00:27:38,399 --> 00:27:44,000
that associated with each one

00:27:40,640 --> 00:27:45,840
and the service code interacts with that

00:27:44,000 --> 00:27:46,320
sidecar and that's how they interact

00:27:45,840 --> 00:27:48,720
with

00:27:46,320 --> 00:27:50,880
the rest of the of the dapper system now

00:27:48,720 --> 00:27:52,399
that might be calling each other right

00:27:50,880 --> 00:27:54,399
and that's secure communication with

00:27:52,399 --> 00:27:56,320
mtls um

00:27:54,399 --> 00:27:58,080
or you know as i pointed out before

00:27:56,320 --> 00:28:01,200
state store pub sub

00:27:58,080 --> 00:28:03,039
now you'll see with the state store

00:28:01,200 --> 00:28:04,799
for instance you'll see a number of

00:28:03,039 --> 00:28:08,480
technologies there

00:28:04,799 --> 00:28:11,600
that are outlined as implementations

00:28:08,480 --> 00:28:12,159
of the state store that are used as the

00:28:11,600 --> 00:28:14,559
service

00:28:12,159 --> 00:28:15,279
that is that is being used as a safe

00:28:14,559 --> 00:28:19,600
store

00:28:15,279 --> 00:28:21,679
so um for the service code

00:28:19,600 --> 00:28:22,960
the application that you're writing you

00:28:21,679 --> 00:28:24,399
know that you need a state sort you know

00:28:22,960 --> 00:28:25,600
you need to store something in state

00:28:24,399 --> 00:28:28,000
retrieve it

00:28:25,600 --> 00:28:28,880
but for but as a developer you know you

00:28:28,000 --> 00:28:31,200
don't you don't

00:28:28,880 --> 00:28:33,200
it doesn't you don't care what store

00:28:31,200 --> 00:28:34,240
maybe is being used it's not necessarily

00:28:33,200 --> 00:28:36,000
something that you're thinking about you

00:28:34,240 --> 00:28:39,760
need to put it in you need to get it out

00:28:36,000 --> 00:28:41,520
and make use of it and so for the the

00:28:39,760 --> 00:28:43,039
administrator for the operator of the

00:28:41,520 --> 00:28:44,559
system

00:28:43,039 --> 00:28:46,159
they're going to determine what is the

00:28:44,559 --> 00:28:48,399
best state store and they're going to

00:28:46,159 --> 00:28:49,760
plug it in they're going to configure

00:28:48,399 --> 00:28:52,559
dapper dapper

00:28:49,760 --> 00:28:53,600
to make use of that storage service uh

00:28:52,559 --> 00:28:57,360
in this case certainly

00:28:53,600 --> 00:28:59,279
you know redis azure cosmos db

00:28:57,360 --> 00:29:01,360
cassandra and this is where some of the

00:28:59,279 --> 00:29:03,840
extensibility comes in because

00:29:01,360 --> 00:29:05,039
there are some that are uh uh that are

00:29:03,840 --> 00:29:07,440
there that are where there are

00:29:05,039 --> 00:29:08,320
you know connectors into these storage

00:29:07,440 --> 00:29:10,559
services

00:29:08,320 --> 00:29:12,159
but of course um this is an open source

00:29:10,559 --> 00:29:14,720
project and

00:29:12,159 --> 00:29:16,320
there are those who are you know they

00:29:14,720 --> 00:29:17,039
want to use a certain storage service

00:29:16,320 --> 00:29:19,679
here

00:29:17,039 --> 00:29:21,360
and they're writing that connector and

00:29:19,679 --> 00:29:23,840
that that that component to make sure

00:29:21,360 --> 00:29:26,000
that they can use it as a state store

00:29:23,840 --> 00:29:27,440
and we're seeing quite a bit of that at

00:29:26,000 --> 00:29:30,880
this point which is great

00:29:27,440 --> 00:29:32,960
um pub sub same thing um

00:29:30,880 --> 00:29:35,039
you know as you can see listed here and

00:29:32,960 --> 00:29:36,880
so this is another level of detail of

00:29:35,039 --> 00:29:40,640
how the system works

00:29:36,880 --> 00:29:43,919
let me go you know a touch deeper now

00:29:40,640 --> 00:29:45,279
into hosting so

00:29:43,919 --> 00:29:47,200
right now you're saying well what can

00:29:45,279 --> 00:29:50,320
you run this how do you run this

00:29:47,200 --> 00:29:51,840
so you can run it locally

00:29:50,320 --> 00:29:53,919
um what happens is you're going to get a

00:29:51,840 --> 00:29:56,480
dapper cli you're going to

00:29:53,919 --> 00:29:58,480
install and run you can run locally

00:29:56,480 --> 00:30:00,000
mainly for development

00:29:58,480 --> 00:30:03,039
and then the primary target at this

00:30:00,000 --> 00:30:05,840
point is kubernetes

00:30:03,039 --> 00:30:08,000
kubernetes certainly has become you know

00:30:05,840 --> 00:30:10,960
the way in which

00:30:08,000 --> 00:30:12,240
enterprises certainly lots of companies

00:30:10,960 --> 00:30:15,840
lots of

00:30:12,240 --> 00:30:19,200
startups as well are choosing

00:30:15,840 --> 00:30:20,240
to abstract infrastructure and manage

00:30:19,200 --> 00:30:22,480
infrastructure

00:30:20,240 --> 00:30:23,520
essentially um and manage their

00:30:22,480 --> 00:30:26,640
containers

00:30:23,520 --> 00:30:30,240
running on top of that uh infrastructure

00:30:26,640 --> 00:30:33,279
and so um that is our target

00:30:30,240 --> 00:30:34,000
uh primarily for for hosting and so what

00:30:33,279 --> 00:30:37,440
happens is you

00:30:34,000 --> 00:30:40,159
install some pods dapper pods

00:30:37,440 --> 00:30:40,640
into kubernetes and those are the you

00:30:40,159 --> 00:30:43,279
know the

00:30:40,640 --> 00:30:44,559
the guts of the system if you will um

00:30:43,279 --> 00:30:45,200
and they do a variety of things

00:30:44,559 --> 00:30:47,679
including

00:30:45,200 --> 00:30:48,320
sidecar injector uh there's an operator

00:30:47,679 --> 00:30:50,559
there

00:30:48,320 --> 00:30:51,760
uh there's a pod that that manages the

00:30:50,559 --> 00:30:55,760
security

00:30:51,760 --> 00:30:57,200
um and so in kubernetes as you can see

00:30:55,760 --> 00:30:59,360
now if you know i mean it has that

00:30:57,200 --> 00:31:01,760
interesting concept of the pod

00:30:59,360 --> 00:31:03,840
which can be one or more containers

00:31:01,760 --> 00:31:07,519
which is an interesting

00:31:03,840 --> 00:31:10,559
aspect of the of the service and

00:31:07,519 --> 00:31:14,080
of the system and so when you deploy

00:31:10,559 --> 00:31:14,880
your your application into a dapper

00:31:14,080 --> 00:31:18,000
enabled

00:31:14,880 --> 00:31:19,279
adapter or aware cluster and you say

00:31:18,000 --> 00:31:22,960
that this is using dapper

00:31:19,279 --> 00:31:23,919
the sidecar injector will put the dapper

00:31:22,960 --> 00:31:26,720
container

00:31:23,919 --> 00:31:28,080
the sidecar container into your pod and

00:31:26,720 --> 00:31:30,480
then your container

00:31:28,080 --> 00:31:31,840
can talk to it and it can interact

00:31:30,480 --> 00:31:33,679
through the configuration that you have

00:31:31,840 --> 00:31:36,880
done on the cluster

00:31:33,679 --> 00:31:40,000
with the other services the other

00:31:36,880 --> 00:31:42,480
the other services the other

00:31:40,000 --> 00:31:43,760
building blocks uh you know for instance

00:31:42,480 --> 00:31:45,440
if we've been talking about

00:31:43,760 --> 00:31:47,279
pub sub state store certainly

00:31:45,440 --> 00:31:48,640
distributed tracing

00:31:47,279 --> 00:31:50,960
um one thing that's interesting about

00:31:48,640 --> 00:31:54,000
the system i'll just mention is

00:31:50,960 --> 00:31:55,760
observability um you know

00:31:54,000 --> 00:31:57,120
everything is running through dapper

00:31:55,760 --> 00:31:58,960
then certainly

00:31:57,120 --> 00:32:00,960
um that gives you a very interesting way

00:31:58,960 --> 00:32:03,440
to observe what's happening

00:32:00,960 --> 00:32:04,320
in the system and so it connects with

00:32:03,440 --> 00:32:07,840
known

00:32:04,320 --> 00:32:11,200
uh logging you know open telemetry

00:32:07,840 --> 00:32:13,679
prometheus grafana azure monitor for you

00:32:11,200 --> 00:32:14,880
to understand what's happening in your

00:32:13,679 --> 00:32:17,360
system which is a real

00:32:14,880 --> 00:32:18,720
real real big benefit um as well and

00:32:17,360 --> 00:32:20,559
certainly kubernetes

00:32:18,720 --> 00:32:21,919
it's it's kubernetes whatever cloud

00:32:20,559 --> 00:32:25,440
on-prem et cetera

00:32:21,919 --> 00:32:30,799
and so um that is

00:32:25,440 --> 00:32:30,799
uh very uh very useful for people

00:32:31,279 --> 00:32:34,399
i'm going to show just a little bit of

00:32:32,399 --> 00:32:36,640
code before i close out here

00:32:34,399 --> 00:32:38,159
um just so you get a flavor again

00:32:36,640 --> 00:32:39,039
another level lower in terms of what i'm

00:32:38,159 --> 00:32:42,480
talking about so

00:32:39,039 --> 00:32:44,399
what i have here quickly is a yaml file

00:32:42,480 --> 00:32:45,279
to deploy so just so you know so you

00:32:44,399 --> 00:32:46,399
have your container with your

00:32:45,279 --> 00:32:48,320
application

00:32:46,399 --> 00:32:50,399
um you deploy it into kubernetes you can

00:32:48,320 --> 00:32:52,720
see here i mean it's books and records

00:32:50,399 --> 00:32:54,640
which is one of the examples that's part

00:32:52,720 --> 00:32:57,039
of morpher

00:32:54,640 --> 00:32:57,679
and you know this is just a real vanilla

00:32:57,039 --> 00:32:59,840
simple

00:32:57,679 --> 00:33:01,039
uh example you can see it's just a you

00:32:59,840 --> 00:33:02,720
know there's a service there's a

00:33:01,039 --> 00:33:03,760
deployment

00:33:02,720 --> 00:33:08,080
and you can see here there's an

00:33:03,760 --> 00:33:10,720
annotation right so the annotation here

00:33:08,080 --> 00:33:11,919
lets the system know this is dapper

00:33:10,720 --> 00:33:14,480
enabled right

00:33:11,919 --> 00:33:15,760
uh the name of your service support to

00:33:14,480 --> 00:33:17,440
call it on

00:33:15,760 --> 00:33:18,799
and there it is it's both we're gonna

00:33:17,440 --> 00:33:20,960
call it books and record

00:33:18,799 --> 00:33:22,320
um and it's it's part of dapper so that

00:33:20,960 --> 00:33:25,279
sidecar is gonna get

00:33:22,320 --> 00:33:26,320
uh injected and then you know otherwise

00:33:25,279 --> 00:33:27,760
again it's

00:33:26,320 --> 00:33:29,039
it's just your container this one

00:33:27,760 --> 00:33:30,159
happens to be an azure container

00:33:29,039 --> 00:33:34,399
registry

00:33:30,159 --> 00:33:38,480
um you know deploying uh two kubernetes

00:33:34,399 --> 00:33:40,720
your app very simple example um

00:33:38,480 --> 00:33:42,320
could look like this uh this is just a

00:33:40,720 --> 00:33:45,440
flask python

00:33:42,320 --> 00:33:48,559
you know few liner um where

00:33:45,440 --> 00:33:49,200
there's an add function right there's an

00:33:48,559 --> 00:33:52,000
add

00:33:49,200 --> 00:33:53,440
uh there's a route for add which is post

00:33:52,000 --> 00:33:54,880
it's not returning anything it's only

00:33:53,440 --> 00:33:58,240
returning a string right now

00:33:54,880 --> 00:34:01,519
but that could be your service and

00:33:58,240 --> 00:34:02,559
um the the another service wanting to

00:34:01,519 --> 00:34:03,840
call it

00:34:02,559 --> 00:34:06,640
you know the call would just look like

00:34:03,840 --> 00:34:08,560
this so what this call would be from

00:34:06,640 --> 00:34:10,639
let's say service b

00:34:08,560 --> 00:34:11,839
um or some client perhaps of the books

00:34:10,639 --> 00:34:15,040
and record uh

00:34:11,839 --> 00:34:16,720
application service would be you know

00:34:15,040 --> 00:34:19,520
local host right so it's going to be

00:34:16,720 --> 00:34:20,720
hitting its own dapper side car on a

00:34:19,520 --> 00:34:22,240
port

00:34:20,720 --> 00:34:24,320
it's going to be invoking this is

00:34:22,240 --> 00:34:26,639
service invocation and then books and

00:34:24,320 --> 00:34:27,599
records is the id that we had in the

00:34:26,639 --> 00:34:30,480
yaml

00:34:27,599 --> 00:34:31,359
for that container and then the method

00:34:30,480 --> 00:34:33,919
it's going to call

00:34:31,359 --> 00:34:34,720
is add and it's this happens to be a

00:34:33,919 --> 00:34:37,040
post

00:34:34,720 --> 00:34:38,639
uh dash x uh this was part of like a you

00:34:37,040 --> 00:34:41,599
know a curl command

00:34:38,639 --> 00:34:42,639
um to call that service so that's how

00:34:41,599 --> 00:34:45,919
it's gonna look

00:34:42,639 --> 00:34:48,159
um for get state uh let's start with

00:34:45,919 --> 00:34:50,159
save state

00:34:48,159 --> 00:34:52,399
so with save state you have your key

00:34:50,159 --> 00:34:55,200
value pairs

00:34:52,399 --> 00:34:56,879
uh formatted in this situation and

00:34:55,200 --> 00:35:00,880
you're just making a request

00:34:56,879 --> 00:35:02,880
of your dapper sidecar http

00:35:00,880 --> 00:35:05,359
on the port and this one is a state

00:35:02,880 --> 00:35:08,400
request

00:35:05,359 --> 00:35:11,200
and then to get that out just

00:35:08,400 --> 00:35:12,880
you know you you're now doing a get and

00:35:11,200 --> 00:35:13,440
for that key that you defined of where

00:35:12,880 --> 00:35:16,560
your

00:35:13,440 --> 00:35:18,320
your your state is being stored under as

00:35:16,560 --> 00:35:19,760
in the state store and then you get it

00:35:18,320 --> 00:35:22,400
back

00:35:19,760 --> 00:35:22,880
the last thing i just want to show here

00:35:22,400 --> 00:35:26,880
uh

00:35:22,880 --> 00:35:29,920
quickly is in warfare

00:35:26,880 --> 00:35:31,280
this is integrated steven we've talked

00:35:29,920 --> 00:35:34,160
about this a bit

00:35:31,280 --> 00:35:35,280
um but you know there's a stateful app

00:35:34,160 --> 00:35:38,160
that is defined

00:35:35,280 --> 00:35:40,000
for instance and you can see in this elm

00:35:38,160 --> 00:35:41,680
code that morpher uses

00:35:40,000 --> 00:35:43,040
you know it just says it's a stateful

00:35:41,680 --> 00:35:46,079
app

00:35:43,040 --> 00:35:46,640
so that any interaction with state you

00:35:46,079 --> 00:35:48,160
know

00:35:46,640 --> 00:35:50,320
what is so interesting that they have

00:35:48,160 --> 00:35:52,000
done that uh the morpher team stephen

00:35:50,320 --> 00:35:55,040
and attila and so on

00:35:52,000 --> 00:35:56,720
have done is that it

00:35:55,040 --> 00:35:58,240
it is going to generate out that dapper

00:35:56,720 --> 00:36:00,640
code for you

00:35:58,240 --> 00:36:02,079
so that when you you've modeled your

00:36:00,640 --> 00:36:06,720
application

00:36:02,079 --> 00:36:09,440
and then it will implement it in

00:36:06,720 --> 00:36:10,400
whichever language you choose java.net

00:36:09,440 --> 00:36:12,960
etc

00:36:10,400 --> 00:36:14,079
and we'll have the dapper code there so

00:36:12,960 --> 00:36:16,720
that when you deploy it

00:36:14,079 --> 00:36:17,680
uh into a cluster um you know it will be

00:36:16,720 --> 00:36:19,520
able to interact

00:36:17,680 --> 00:36:21,599
with the system uh however it's

00:36:19,520 --> 00:36:25,119
configured for whichever state store

00:36:21,599 --> 00:36:28,240
pub sub um uh etc

00:36:25,119 --> 00:36:30,720
and that's what i wanted to just go over

00:36:28,240 --> 00:36:31,839
um i hope you're excited about dapper um

00:36:30,720 --> 00:36:34,320
it's a

00:36:31,839 --> 00:36:35,119
um we're very excited about it it's it's

00:36:34,320 --> 00:36:36,480
it's being

00:36:35,119 --> 00:36:38,160
received well by the community i think

00:36:36,480 --> 00:36:41,760
it's about 8 000

00:36:38,160 --> 00:36:45,040
um uh likes on uh

00:36:41,760 --> 00:36:45,680
on github and it helps sorry stars on

00:36:45,040 --> 00:36:47,599
github

00:36:45,680 --> 00:36:49,280
plenty of forks a lot of community

00:36:47,599 --> 00:36:50,880
involvement there's regular community

00:36:49,280 --> 00:36:52,480
meetings that you can join

00:36:50,880 --> 00:36:54,160
i encourage you to check it out and of

00:36:52,480 --> 00:36:56,960
course uh encourage

00:36:54,160 --> 00:36:57,280
you uh to check out more for uh part of

00:36:56,960 --> 00:36:59,920
the

00:36:57,280 --> 00:37:00,560
part of finos right now and consider it

00:36:59,920 --> 00:37:03,680
for

00:37:00,560 --> 00:37:06,000
uh for your project um and uh thank you

00:37:03,680 --> 00:37:08,000
for listening

00:37:06,000 --> 00:37:10,480
okay thank you adam and so there we have

00:37:08,000 --> 00:37:13,200
it the combination of dapper and morpher

00:37:10,480 --> 00:37:14,800
with dapper you get a powerful run time

00:37:13,200 --> 00:37:15,359
it does a lot of the heavy lifting that

00:37:14,800 --> 00:37:18,400
we would

00:37:15,359 --> 00:37:20,480
normally have to do you know with with

00:37:18,400 --> 00:37:22,640
pulling in our own components and it

00:37:20,480 --> 00:37:23,200
does the the job of making this all work

00:37:22,640 --> 00:37:25,839
in a

00:37:23,200 --> 00:37:27,599
in a effective and efficient run time

00:37:25,839 --> 00:37:30,000
and then we have morpher

00:37:27,599 --> 00:37:31,920
uh and morpher enshrines the business

00:37:30,000 --> 00:37:33,280
knowledge into a data format so that

00:37:31,920 --> 00:37:35,520
it's protected from

00:37:33,280 --> 00:37:36,560
technology evolution it makes it

00:37:35,520 --> 00:37:38,880
evolution ready

00:37:36,560 --> 00:37:40,400
and that we can take that same business

00:37:38,880 --> 00:37:42,640
logic and make it run in different

00:37:40,400 --> 00:37:44,720
technologies the technology evolves

00:37:42,640 --> 00:37:46,560
it gives us the capabilities that are

00:37:44,720 --> 00:37:47,040
things that are outside of the run time

00:37:46,560 --> 00:37:50,240
like

00:37:47,040 --> 00:37:52,240
documentation live documentation maybe

00:37:50,240 --> 00:37:53,119
interactive documentation even so that

00:37:52,240 --> 00:37:55,040
you can audit

00:37:53,119 --> 00:37:56,960
you know how did the system come to this

00:37:55,040 --> 00:37:58,320
conclusion at this particular time

00:37:56,960 --> 00:38:00,400
so there's a lot of things you can do

00:37:58,320 --> 00:38:02,640
that are outside of a run time

00:38:00,400 --> 00:38:05,119
that we can still do with automation

00:38:02,640 --> 00:38:07,520
once we have that business logic

00:38:05,119 --> 00:38:08,720
for example we can use it to generate

00:38:07,520 --> 00:38:10,640
the full lineage

00:38:08,720 --> 00:38:12,880
so we can see that these inputs and

00:38:10,640 --> 00:38:15,280
these outputs in a calculation

00:38:12,880 --> 00:38:17,200
um you know here's the results that we

00:38:15,280 --> 00:38:18,000
got and here's exactly why we got those

00:38:17,200 --> 00:38:19,599
results so

00:38:18,000 --> 00:38:22,400
it's more than just watching the data

00:38:19,599 --> 00:38:25,520
flow it's watching the data flow

00:38:22,400 --> 00:38:28,320
with the whole reason that we got it and

00:38:25,520 --> 00:38:30,000
finally it makes the logic portable so

00:38:28,320 --> 00:38:31,520
you know logic is often

00:38:30,000 --> 00:38:33,280
used throughout the system or even

00:38:31,520 --> 00:38:34,960
across

00:38:33,280 --> 00:38:37,040
projects and even across firms in the

00:38:34,960 --> 00:38:39,440
case of something like regulations

00:38:37,040 --> 00:38:40,240
and so being able to define that logic

00:38:39,440 --> 00:38:42,960
in a

00:38:40,240 --> 00:38:45,040
common format that doesn't dictate a

00:38:42,960 --> 00:38:48,400
technology means that we can run it

00:38:45,040 --> 00:38:51,119
across projects across technologies and

00:38:48,400 --> 00:38:54,320
across firms

00:38:51,119 --> 00:38:56,000
so with that

00:38:54,320 --> 00:38:57,680
we have actually successfully done what

00:38:56,000 --> 00:39:02,320
we set out to do

00:38:57,680 --> 00:39:05,280
we've moved all that that manual process

00:39:02,320 --> 00:39:06,480
into just one manual step and the rest

00:39:05,280 --> 00:39:08,400
is automated

00:39:06,480 --> 00:39:09,839
what we didn't show you was that we've

00:39:08,400 --> 00:39:12,560
actually done it so that

00:39:09,839 --> 00:39:13,440
when you we've tied into the github

00:39:12,560 --> 00:39:16,560
pipeline

00:39:13,440 --> 00:39:18,320
so that when a developer checks in

00:39:16,560 --> 00:39:21,280
the business model the pure business

00:39:18,320 --> 00:39:24,240
model it kicks off the entire process

00:39:21,280 --> 00:39:25,920
does the the build the testing and then

00:39:24,240 --> 00:39:27,040
the deployment so think of it as like

00:39:25,920 --> 00:39:28,960
one touch

00:39:27,040 --> 00:39:30,960
write your pure business logic check it

00:39:28,960 --> 00:39:33,040
in do a merge

00:39:30,960 --> 00:39:35,680
and it ends up in production in a

00:39:33,040 --> 00:39:35,680
running system

00:39:37,200 --> 00:39:43,599
so what's next both of these projects

00:39:40,400 --> 00:39:47,119
are by developers and forward developers

00:39:43,599 --> 00:39:48,000
uh and so both would love the

00:39:47,119 --> 00:39:50,800
contribution

00:39:48,000 --> 00:39:51,599
of the development community so anybody

00:39:50,800 --> 00:39:55,280
who's interested

00:39:51,599 --> 00:39:58,079
please go to morpher.os.org for the

00:39:55,280 --> 00:39:59,520
the morpher project and dapper.io for

00:39:58,079 --> 00:40:08,400
the dapper project

00:39:59,520 --> 00:40:08,400

YouTube URL: https://www.youtube.com/watch?v=DCxIYpShau0


