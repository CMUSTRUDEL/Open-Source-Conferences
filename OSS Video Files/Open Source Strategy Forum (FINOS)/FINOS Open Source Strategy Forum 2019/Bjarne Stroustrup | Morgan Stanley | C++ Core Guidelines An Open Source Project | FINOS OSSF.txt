Title: Bjarne Stroustrup | Morgan Stanley | C++ Core Guidelines An Open Source Project | FINOS OSSF
Publication date: 2021-01-07
Playlist: FINOS Open Source Strategy Forum 2019
Description: 
	Bjarne Stroustrup | Morgan Stanley | C++ Core Guidelines An Open Source Project Breakout | FINOS OSSF 2019

Bjarne Stroustrup, Creator of C++ & Managing Director, Morgan Stanley

Bjarne Stroustrup's BIO

Bjarne Stroustrup is the designer and original implementer of C++ as well as the author of The C++ Programming Language (4th Edition) and A Tour of C++ (2nd edition), Programming: Principles and Practice using C++ (2nd Edition), and many popular and academic publications. Dr. Stroustrup is a Technical Fellow and a Managing Director in the technology division of Morgan Stanley in New York City as well as a visiting professor at Columbia University. He is a member of the US National Academy of Engineering, and an IEEE, ACM, and CHM fellow. He is the recipient of the 2018 NAE Charles Stark Draper Prize for Engineering and the 2017 IET Faraday Medal. He did much of his most important work in Bell Labs. His research interests include distributed systems, design, programming techniques, software development tools, and programming languages. To make C++ a stable and up-to-date base for real-world software development, he has been a leading figure with the ISO C++ standards effort for more than 25 years. He holds a master’s in Mathematics from Aarhus University and a PhD in Computer Science from Cambridge University, where he is an honorary fellow of Churchill College.

-=-=-=-=-

This video is from the FINOS Open Source Strategy Forum (OSSF) NYC 2019. 

►►For free access to all 2019 videos from the conference - visit our website here: https://www.finos.org/ossf-2019-recap
 
►► More information HERE: https://events.linuxfoundation.org/open-source-strategy-forum/

Learn more about FINOS and how we deliver the power of open source to financial services:
►► FINOS: https://www.finos.org/
Captions: 
	00:00:03,690 --> 00:00:14,429
[Music]

00:00:11,719 --> 00:00:18,510
how many of you were here this morning

00:00:14,429 --> 00:00:20,910
and hurt the first version of this okay

00:00:18,510 --> 00:00:28,619
just over half that's the worst possible

00:00:20,910 --> 00:00:30,539
situation so I will rush through what I

00:00:28,619 --> 00:00:34,440
did this morning and then we'll go into

00:00:30,539 --> 00:00:37,380
some greater detail and some more

00:00:34,440 --> 00:00:40,410
explanations so basically a few years

00:00:37,380 --> 00:00:43,200
ago I realized that a lot of people

00:00:40,410 --> 00:00:46,260
would like to write more modern C++ they

00:00:43,200 --> 00:00:48,600
had gotten convinced that that was a

00:00:46,260 --> 00:00:50,760
good thing for both their reliability

00:00:48,600 --> 00:00:54,120
and their performance but they didn't

00:00:50,760 --> 00:00:56,610
know how sort of got lost in the feature

00:00:54,120 --> 00:01:01,020
set you go on the web and you get every

00:00:56,610 --> 00:01:03,840
possible advice so I said well what's

00:01:01,020 --> 00:01:05,610
modern C++ how would you like to look

00:01:03,840 --> 00:01:08,850
you're you're code to look like in five

00:01:05,610 --> 00:01:11,189
years and I wasn't the only one

00:01:08,850 --> 00:01:13,170
considering this so I found several

00:01:11,189 --> 00:01:17,430
other people involved in projects like

00:01:13,170 --> 00:01:20,790
that so we made a joint project and of

00:01:17,430 --> 00:01:24,630
course to have us all work together

00:01:20,790 --> 00:01:26,549
it had to be open source there was

00:01:24,630 --> 00:01:28,799
people from different and competing

00:01:26,549 --> 00:01:32,640
organizations and our Chino's party only

00:01:28,799 --> 00:01:35,850
way and basically I want a useful answer

00:01:32,640 --> 00:01:39,450
to this not a theoretical answer and you

00:01:35,850 --> 00:01:42,329
can find it all on github if you can

00:01:39,450 --> 00:01:44,939
type in C++ core guidelines you can find

00:01:42,329 --> 00:01:48,750
it if you can't type that in well you

00:01:44,939 --> 00:01:51,990
probably don't need it anyway so the aim

00:01:48,750 --> 00:01:54,509
that we're trying to do is to to

00:01:51,990 --> 00:01:56,610
basically get C++ to where it was

00:01:54,509 --> 00:01:58,680
supposed to be this is something that

00:01:56,610 --> 00:02:00,420
somebody can do if they know what

00:01:58,680 --> 00:02:02,250
they're doing and we want the vast

00:02:00,420 --> 00:02:05,070
majority of the people to be helped to

00:02:02,250 --> 00:02:08,910
do it I want complete type and resource

00:02:05,070 --> 00:02:10,979
safety no memory corruption no leaks no

00:02:08,910 --> 00:02:12,760
garbage collector just don't generate

00:02:10,979 --> 00:02:16,150
any garbage

00:02:12,760 --> 00:02:19,150
and no runtime overheads except if you

00:02:16,150 --> 00:02:21,520
want the light for your runtime range

00:02:19,150 --> 00:02:24,190
checking can't be done statically no

00:02:21,520 --> 00:02:27,310
limits to express ability we really want

00:02:24,190 --> 00:02:31,030
to say as much as we can in ordinary C++

00:02:27,310 --> 00:02:32,770
and we want ISO C++ I don't want to go

00:02:31,030 --> 00:02:36,220
and design another language it's just

00:02:32,770 --> 00:02:39,370
too hard too much work and we want to

00:02:36,220 --> 00:02:42,160
see the good code the the reliable code

00:02:39,370 --> 00:02:44,380
the efficient code to be simpler and we

00:02:42,160 --> 00:02:46,030
want to reinforcement because people

00:02:44,380 --> 00:02:49,420
can't do that without help

00:02:46,030 --> 00:02:51,250
not at scale you may be able to do it on

00:02:49,420 --> 00:02:55,090
a page you don't do it on a million line

00:02:51,250 --> 00:02:57,900
code base so one C++ on steroids and

00:02:55,090 --> 00:03:01,590
that's sort of one of the Holy Grails of

00:02:57,900 --> 00:03:04,930
computing and this is work in progress

00:03:01,590 --> 00:03:06,820
we have a general approach where we have

00:03:04,930 --> 00:03:09,400
some guidelines we have some library

00:03:06,820 --> 00:03:11,950
support and we have some static analysis

00:03:09,400 --> 00:03:14,350
it is not production-ready in general

00:03:11,950 --> 00:03:16,930
though there are large projects million

00:03:14,350 --> 00:03:19,769
in code bases that are using some of

00:03:16,930 --> 00:03:24,700
this and it is not science fiction

00:03:19,769 --> 00:03:26,920
because of that ok so the question that

00:03:24,700 --> 00:03:31,540
I get very often is why don't you just

00:03:26,920 --> 00:03:33,970
fix C++ make it simpler and nicer and of

00:03:31,540 --> 00:03:36,370
course I know how to do that however

00:03:33,970 --> 00:03:37,959
that would break a lot of people's code

00:03:36,370 --> 00:03:42,519
so the story goes

00:03:37,959 --> 00:03:44,950
it's C++ to being complicated agreed so

00:03:42,519 --> 00:03:48,220
simplified and give me just two more

00:03:44,950 --> 00:03:49,530
extra features and whatever you do don't

00:03:48,220 --> 00:03:54,130
break my coat

00:03:49,530 --> 00:03:56,709
this is impossible and by the way this

00:03:54,130 --> 00:04:00,790
will happen to every successful large

00:03:56,709 --> 00:04:03,400
system this is not specific to C++ it is

00:04:00,790 --> 00:04:05,890
just dramatically difficult for C++

00:04:03,400 --> 00:04:08,530
because C++ is older and more successful

00:04:05,890 --> 00:04:10,660
and most alternatives and we have to

00:04:08,530 --> 00:04:13,540
remember stability compatibility is the

00:04:10,660 --> 00:04:16,120
feature code that we wrote 20 years ago

00:04:13,540 --> 00:04:17,669
tend to run today if somebody hasn't

00:04:16,120 --> 00:04:20,560
broken the operating system and

00:04:17,669 --> 00:04:23,349
therefore we can assume it'll run again

00:04:20,560 --> 00:04:25,340
in 20 years time what we right now

00:04:23,349 --> 00:04:28,639
that's very important

00:04:25,340 --> 00:04:29,930
it is a large-scale issue this is why we

00:04:28,639 --> 00:04:32,470
can't break all of these nice

00:04:29,930 --> 00:04:36,080
applications there's a lot of C++

00:04:32,470 --> 00:04:40,430
applications hundreds of billions of

00:04:36,080 --> 00:04:43,880
lines of code millions of developers and

00:04:40,430 --> 00:04:46,720
it's it's everywhere C++ is generally

00:04:43,880 --> 00:04:49,220
invisible you don't see it it's like

00:04:46,720 --> 00:04:52,040
housework it's only seen when you don't

00:04:49,220 --> 00:04:53,840
do it but it's underneath everything we

00:04:52,040 --> 00:04:56,660
saw some Python examples this morning

00:04:53,840 --> 00:05:01,310
what do you think runs the the AI for

00:04:56,660 --> 00:05:04,630
Python C++ of course okay so we want

00:05:01,310 --> 00:05:08,180
something that's the coding guidelines

00:05:04,630 --> 00:05:10,820
we want static type checking really no

00:05:08,180 --> 00:05:13,639
release as I said before

00:05:10,820 --> 00:05:16,910
also no range errors no node pointer

00:05:13,639 --> 00:05:19,490
references no misuse of uses no bloat

00:05:16,910 --> 00:05:21,800
all of these good kind of things you

00:05:19,490 --> 00:05:25,520
don't get that from a language by itself

00:05:21,800 --> 00:05:29,090
you get it from proper use of the

00:05:25,520 --> 00:05:30,650
language and so the this is part of the

00:05:29,090 --> 00:05:33,289
answer that we can't simplify the

00:05:30,650 --> 00:05:35,720
language but we can simplify use of the

00:05:33,289 --> 00:05:37,400
language and when we simplify use of the

00:05:35,720 --> 00:05:41,330
language wouldn't get all kinds of other

00:05:37,400 --> 00:05:43,310
interesting properties okay now I'm

00:05:41,330 --> 00:05:48,590
going to slow down a bit I've done my 10

00:05:43,310 --> 00:05:50,900
minutes talking five minutes and we hate

00:05:48,590 --> 00:05:52,900
coding rules I mean I've never met a

00:05:50,900 --> 00:05:55,550
programmer that liked coding rules

00:05:52,900 --> 00:05:59,330
everybody wants to write code just the

00:05:55,550 --> 00:06:02,300
way they like it and part of the reason

00:05:59,330 --> 00:06:05,630
is that the rules are written to prevent

00:06:02,300 --> 00:06:08,950
misuse by pro-poor programmers not by

00:06:05,630 --> 00:06:12,919
mackney magnify the effects of good

00:06:08,950 --> 00:06:15,380
programmers they are also written very

00:06:12,919 --> 00:06:17,740
often by people whose first project with

00:06:15,380 --> 00:06:21,169
c++ is to write the coding guidelines

00:06:17,740 --> 00:06:23,450
and so they are panic struct about all

00:06:21,169 --> 00:06:24,830
kinds of problems they've heard of or

00:06:23,450 --> 00:06:27,800
they've seen in their previous

00:06:24,830 --> 00:06:29,840
programming language and so you get a

00:06:27,800 --> 00:06:31,729
lot of rules that focused on how you

00:06:29,840 --> 00:06:34,580
layout things and whether you use

00:06:31,729 --> 00:06:36,890
underscores and names and they're very

00:06:34,580 --> 00:06:39,860
keen on any feature they don't quite

00:06:36,890 --> 00:06:42,200
understand that it has to be bent this

00:06:39,860 --> 00:06:43,880
is very unpleasant for those of us who

00:06:42,200 --> 00:06:47,539
actually know how to use the features

00:06:43,880 --> 00:06:50,360
and what we need to do is have the rules

00:06:47,539 --> 00:06:53,539
based on solid programming principles

00:06:50,360 --> 00:06:57,260
not by fiddly details and restrictions

00:06:53,539 --> 00:07:00,650
and also the rules tend to get old and

00:06:57,260 --> 00:07:02,690
before a bad advice a lot of people have

00:07:00,650 --> 00:07:04,940
had coding guidelines that wanted you to

00:07:02,690 --> 00:07:08,630
write pseudo Java if you want to write

00:07:04,940 --> 00:07:11,720
Java write Java support C with classes

00:07:08,630 --> 00:07:15,650
sort of eliminating 20 years of progress

00:07:11,720 --> 00:07:20,300
in C++ or even worse right C when which

00:07:15,650 --> 00:07:24,229
brings you back to about 18 1980 we need

00:07:20,300 --> 00:07:28,280
to do better so we can do better

00:07:24,229 --> 00:07:30,310
modern C++ prescriptive not punitive and

00:07:28,280 --> 00:07:33,729
we want a teachable

00:07:30,310 --> 00:07:36,169
flexible and of course non proprietary

00:07:33,729 --> 00:07:38,570
because we want to work with people

00:07:36,169 --> 00:07:41,599
working for other fields we don't we

00:07:38,570 --> 00:07:44,150
actually have a lot of experience in how

00:07:41,599 --> 00:07:47,240
to make code good

00:07:44,150 --> 00:07:50,240
there's old problems like thanking

00:07:47,240 --> 00:07:53,090
pointers memo memory corruption boffo or

00:07:50,240 --> 00:07:56,450
flow with known solutions of these kind

00:07:53,090 --> 00:07:57,580
of things for 40 years at least I mean I

00:07:56,450 --> 00:08:00,950
remember having

00:07:57,580 --> 00:08:04,340
exercises settle is like that when I was

00:08:00,950 --> 00:08:07,340
in undergrad manual resource management

00:08:04,340 --> 00:08:10,099
does not scale so remember to delete

00:08:07,340 --> 00:08:14,150
your mem memory when you're finished

00:08:10,099 --> 00:08:15,050
with it call it delete call it free I

00:08:14,150 --> 00:08:18,050
don't care

00:08:15,050 --> 00:08:20,659
doesn't scale it works on a one-page but

00:08:18,050 --> 00:08:22,940
probably not much more smart pointers

00:08:20,659 --> 00:08:25,010
adds complexity and cost especially

00:08:22,940 --> 00:08:27,349
shared pointers can be quite expensive

00:08:25,010 --> 00:08:29,060
in a multi-threaded system where you

00:08:27,349 --> 00:08:31,490
have to synchronize access to the use

00:08:29,060 --> 00:08:35,240
count garbage collection is asbestos

00:08:31,490 --> 00:08:38,900
partial solution it just don't handle

00:08:35,240 --> 00:08:41,150
non memory resources like threads and

00:08:38,900 --> 00:08:44,150
files and locks and things like that

00:08:41,150 --> 00:08:46,459
also it's non-local we hate things that

00:08:44,150 --> 00:08:47,390
in modern systems hate things that are

00:08:46,459 --> 00:08:50,270
non low

00:08:47,390 --> 00:08:52,460
it always has a cost to it just having

00:08:50,270 --> 00:08:55,400
the memory over there on different

00:08:52,460 --> 00:08:57,260
process near a different processor can

00:08:55,400 --> 00:08:59,570
be enough to kill your performance in

00:08:57,260 --> 00:09:01,730
some areas and of course if it's in

00:08:59,570 --> 00:09:04,460
another part of a distributed system you

00:09:01,730 --> 00:09:07,460
can't garbage collect it and we want

00:09:04,460 --> 00:09:11,570
predictability static analysis which is

00:09:07,460 --> 00:09:13,070
my favorite doesn't scale the algorithms

00:09:11,570 --> 00:09:18,589
are complicated

00:09:13,070 --> 00:09:21,170
Oh cubed or something worse and it

00:09:18,589 --> 00:09:23,900
doesn't actually work for arbitrary code

00:09:21,170 --> 00:09:26,839
I can write code that cannot be

00:09:23,900 --> 00:09:29,630
statically analyze to be true B be

00:09:26,839 --> 00:09:33,140
correct and so we have to have something

00:09:29,630 --> 00:09:36,170
that stops us from from writing the code

00:09:33,140 --> 00:09:38,839
that cannot be analyzed and verified and

00:09:36,170 --> 00:09:43,270
so we work with a cocktail of techniques

00:09:38,839 --> 00:09:46,550
the basic idea here is that for medicine

00:09:43,270 --> 00:09:52,600
there's no miracle cure

00:09:46,550 --> 00:09:55,610
no one drug can kill the the bug and so

00:09:52,600 --> 00:09:57,710
but if you use two or three different

00:09:55,610 --> 00:10:00,050
approaches you can get to it and that's

00:09:57,710 --> 00:10:03,140
what we're doing we have rules we have

00:10:00,050 --> 00:10:04,910
libraries we have the type system and we

00:10:03,140 --> 00:10:08,570
have static analysis which in phase

00:10:04,910 --> 00:10:11,839
really enhances the type system none of

00:10:08,570 --> 00:10:14,720
them can do it themselves but it works

00:10:11,839 --> 00:10:18,400
in combination the other principle were

00:10:14,720 --> 00:10:21,530
working on is the subset of superset

00:10:18,400 --> 00:10:23,690
idea which is an old idea of mine but

00:10:21,530 --> 00:10:26,690
anyway it is observed that everybody

00:10:23,690 --> 00:10:29,510
wants to subset the language but to

00:10:26,690 --> 00:10:31,700
subset C++ you start by the most

00:10:29,510 --> 00:10:34,550
dangerous features are the ones we use

00:10:31,700 --> 00:10:39,110
to implement the abstractions you need

00:10:34,550 --> 00:10:42,140
to be safe so you cannot cut into the

00:10:39,110 --> 00:10:45,529
uses of pointers say without destroying

00:10:42,140 --> 00:10:48,620
vectors but you need vectors to avoid

00:10:45,529 --> 00:10:50,420
pointers so we have to do something else

00:10:48,620 --> 00:10:52,250
and the way we do it is first we

00:10:50,420 --> 00:10:56,870
superset the language to a more ideal

00:10:52,250 --> 00:10:59,270
language we do that by using the STR or

00:10:56,870 --> 00:11:00,889
standard template library and the other

00:10:59,270 --> 00:11:02,959
standard libraries and

00:11:00,889 --> 00:11:04,970
something called the GSL it's about ten

00:11:02,959 --> 00:11:07,579
classes that's written specifically for

00:11:04,970 --> 00:11:10,399
the guidelines and then once that's done

00:11:07,579 --> 00:11:15,649
we can say don't do the nasty things

00:11:10,399 --> 00:11:19,480
that get you into trouble and so that's

00:11:15,649 --> 00:11:22,970
basically how we get the steroids and

00:11:19,480 --> 00:11:26,179
then we get to how we write code

00:11:22,970 --> 00:11:28,699
guidelines on average people have

00:11:26,179 --> 00:11:31,100
written guidelines just by writing a set

00:11:28,699 --> 00:11:35,480
of guidelines that they think look good

00:11:31,100 --> 00:11:38,149
and they've heard of no that doesn't

00:11:35,480 --> 00:11:41,239
work it doesn't scale what we need is a

00:11:38,149 --> 00:11:43,879
hair have a conceptual framework and has

00:11:41,239 --> 00:11:46,069
to be articulated we have to have the

00:11:43,879 --> 00:11:48,619
rules that says what we are trying to do

00:11:46,069 --> 00:11:50,899
that guides people when they come with

00:11:48,619 --> 00:11:53,089
one with a bright rule that says okay

00:11:50,899 --> 00:11:56,540
does it actually support where we want

00:11:53,089 --> 00:12:00,559
to go so this is this is the framework

00:11:56,540 --> 00:12:03,589
that allows us to basically approve or

00:12:00,559 --> 00:12:07,339
disapprove rules and that's some semi

00:12:03,589 --> 00:12:11,029
philosophical things like static type

00:12:07,339 --> 00:12:13,549
safety totally any resources don't waste

00:12:11,029 --> 00:12:17,259
time and space the still C++ that's the

00:12:13,549 --> 00:12:19,939
Sarah or and principle in disguise and

00:12:17,259 --> 00:12:22,790
so I'm not going to go through this in

00:12:19,939 --> 00:12:24,939
great detail if we get time for a Q&A I

00:12:22,790 --> 00:12:28,309
can get there but I don't think we will

00:12:24,939 --> 00:12:32,540
but the idea is a framework you can go

00:12:28,309 --> 00:12:34,970
and look at it and then we cannot test

00:12:32,540 --> 00:12:38,149
we cannot write a program that tests

00:12:34,970 --> 00:12:40,489
philosophy that that's not feasible but

00:12:38,149 --> 00:12:41,720
we can test the individual rules once we

00:12:40,489 --> 00:12:44,749
write them because they are directly

00:12:41,720 --> 00:12:47,329
related to the language itself and the

00:12:44,749 --> 00:12:49,730
way the language is used some can be

00:12:47,329 --> 00:12:53,059
completely checked in principle we could

00:12:49,730 --> 00:12:56,809
put it into the compiler others are just

00:12:53,059 --> 00:12:59,029
heuristics so some says you violated

00:12:56,809 --> 00:13:04,279
this the other one says this is probably

00:12:59,029 --> 00:13:07,970
bad and we have analyzers that look into

00:13:04,279 --> 00:13:10,399
this so the examples are here manage

00:13:07,970 --> 00:13:12,949
resources automatically using resource

00:13:10,399 --> 00:13:15,050
handles and ra íí- I think that's

00:13:12,949 --> 00:13:21,530
probably the most

00:13:15,050 --> 00:13:24,260
most important room we lost amor and so

00:13:21,530 --> 00:13:27,050
we look for things that's acquired and

00:13:24,260 --> 00:13:28,940
see if they're released mostly through

00:13:27,050 --> 00:13:33,500
resource handles otherwise it gets

00:13:28,940 --> 00:13:36,860
complicated we don't have a raw pointer

00:13:33,500 --> 00:13:39,380
just points it doesn't own something it

00:13:36,860 --> 00:13:42,890
isn't an array that's the first rule

00:13:39,380 --> 00:13:47,630
here again important for simplifying

00:13:42,890 --> 00:13:49,600
things okay I just broke every old C++

00:13:47,630 --> 00:13:52,760
program in existence with that rule

00:13:49,600 --> 00:13:56,180
because it's very rare to find a program

00:13:52,760 --> 00:13:59,030
there's a subject that doesn't subscribe

00:13:56,180 --> 00:14:01,220
that one and what else do you do if you

00:13:59,030 --> 00:14:04,460
how else do you represent the ownership

00:14:01,220 --> 00:14:05,540
I'll get to that obviously there has to

00:14:04,460 --> 00:14:07,910
be alternatives

00:14:05,540 --> 00:14:10,520
you can't just ban you have to provide a

00:14:07,910 --> 00:14:14,530
better alternative otherwise there's no

00:14:10,520 --> 00:14:18,740
hope of moving forward and this is not

00:14:14,530 --> 00:14:23,140
science fiction here is old example

00:14:18,740 --> 00:14:26,510
actually a five-year-old example from

00:14:23,140 --> 00:14:29,330
Microsoft Visual Studio that catches a

00:14:26,510 --> 00:14:35,000
potential leak and it dumps you straight

00:14:29,330 --> 00:14:38,420
into the into the rule that says what

00:14:35,000 --> 00:14:41,210
you did wrong and that also if you click

00:14:38,420 --> 00:14:45,830
through in the guidelines will tell you

00:14:41,210 --> 00:14:50,060
what you can do instead so here is what

00:14:45,830 --> 00:14:53,300
you can do instead for for subscribing

00:14:50,060 --> 00:14:56,960
we have an abstraction it was built into

00:14:53,300 --> 00:14:59,570
the GSL the guideline support library

00:14:56,960 --> 00:15:01,940
which is basically saying this is a rank

00:14:59,570 --> 00:15:04,820
particulars range of objects of a given

00:15:01,940 --> 00:15:06,950
type and that's what we use pointers to

00:15:04,820 --> 00:15:09,740
that's where we subscript that's why you

00:15:06,950 --> 00:15:11,930
use pointer arithmetic given this one we

00:15:09,740 --> 00:15:16,540
can get rid of most of that so basically

00:15:11,930 --> 00:15:19,970
there's an array of a hundred a hundred

00:15:16,540 --> 00:15:21,830
integers and if we need to subscribe we

00:15:19,970 --> 00:15:26,700
either have to check the range checking

00:15:21,830 --> 00:15:29,940
which ranges which slows us down or we

00:15:26,700 --> 00:15:32,160
run the risk of making mistakes what I'm

00:15:29,940 --> 00:15:34,710
saying here give me a span of that a

00:15:32,160 --> 00:15:36,300
span is an abstraction that keep track

00:15:34,710 --> 00:15:40,680
of where the elements are and how many

00:15:36,300 --> 00:15:45,150
there are given that I can then do a

00:15:40,680 --> 00:15:47,910
range for for election s that one will

00:15:45,150 --> 00:15:51,240
have no range checking and it will have

00:15:47,910 --> 00:15:54,240
no chance of all run you can't do

00:15:51,240 --> 00:15:56,010
everything with that but that's a good

00:15:54,240 --> 00:15:59,360
example the information it's the end we

00:15:56,010 --> 00:16:01,350
can use it of course it also allowed

00:15:59,360 --> 00:16:03,510
subscripting and things like that but

00:16:01,350 --> 00:16:06,120
it's checkable one of the fundamental

00:16:03,510 --> 00:16:09,570
rules of the game is if we can't check

00:16:06,120 --> 00:16:11,540
it at compile time at least we should be

00:16:09,570 --> 00:16:14,490
able to write a check but checks it at

00:16:11,540 --> 00:16:16,260
runtime in other words there has to be

00:16:14,490 --> 00:16:20,220
information enough to do the checking

00:16:16,260 --> 00:16:24,480
this thing is going to disappear from

00:16:20,220 --> 00:16:28,170
the GSL because we have gotten it into

00:16:24,480 --> 00:16:30,420
the standards it's part of C++ 20 we

00:16:28,170 --> 00:16:34,170
want to put ourselves out of the library

00:16:30,420 --> 00:16:36,570
business that that's an important thing

00:16:34,170 --> 00:16:40,590
we don't want to be another burden of

00:16:36,570 --> 00:16:43,680
things you have to load up and learn so

00:16:40,590 --> 00:16:47,850
they're called core guidelines Kol rules

00:16:43,680 --> 00:16:50,790
is because not everybody can do it all

00:16:47,850 --> 00:16:54,390
and everybody will have extensions and

00:16:50,790 --> 00:16:59,820
we hope that there will be more work

00:16:54,390 --> 00:17:02,310
with more more extensible rules and for

00:16:59,820 --> 00:17:05,640
specific areas in particular I would

00:17:02,310 --> 00:17:09,089
like to see rules for hard real-time

00:17:05,640 --> 00:17:12,630
code where you need predictability very

00:17:09,089 --> 00:17:14,040
hard to write so we start with what's

00:17:12,630 --> 00:17:16,770
essential for everybody

00:17:14,040 --> 00:17:21,240
no resource leaks we basically know how

00:17:16,770 --> 00:17:25,020
to do that every resource has to be

00:17:21,240 --> 00:17:28,500
anchored in a handle which live in a

00:17:25,020 --> 00:17:30,930
scope and we can then use our III we can

00:17:28,500 --> 00:17:33,300
use move constructors and optimization

00:17:30,930 --> 00:17:35,910
to move these handles between scopes and

00:17:33,300 --> 00:17:39,060
basically you then have a closed system

00:17:35,910 --> 00:17:40,470
for resources you never leak so I'm not

00:17:39,060 --> 00:17:43,080
going to go into that

00:17:40,470 --> 00:17:47,250
I'm going into my least-favorite problem

00:17:43,080 --> 00:17:50,370
here dangling pointers here we see my

00:17:47,250 --> 00:17:53,160
illustration of a nightmare because this

00:17:50,370 --> 00:17:56,160
is the worst nightmare here we have a

00:17:53,160 --> 00:17:58,770
piece of code that function f takes a

00:17:56,160 --> 00:18:02,100
pointer looks innocent it deletes that

00:17:58,770 --> 00:18:04,740
then I go down use it I make a new

00:18:02,100 --> 00:18:08,070
object I call the function and then I

00:18:04,740 --> 00:18:14,340
use the point I got this is disaster

00:18:08,070 --> 00:18:16,740
because we basically used the object

00:18:14,340 --> 00:18:20,070
after deletion so instead of using my

00:18:16,740 --> 00:18:24,860
object I may be scrambling yours this

00:18:20,070 --> 00:18:24,860
has to be solid for about any form of

00:18:25,130 --> 00:18:32,580
safety and guarantee to be done so we do

00:18:28,230 --> 00:18:37,830
that the rules catch deletes of things

00:18:32,580 --> 00:18:40,380
that aren't illness and it it catches

00:18:37,830 --> 00:18:43,020
news that isn't assigned to some kind of

00:18:40,380 --> 00:18:45,150
owner so new and deletes disappears into

00:18:43,020 --> 00:18:48,330
constructors destructors and other

00:18:45,150 --> 00:18:50,990
resource management functions and yeah

00:18:48,330 --> 00:18:54,240
associate we just have to solve this

00:18:50,990 --> 00:18:56,460
basically the rule is simple it's been

00:18:54,240 --> 00:18:59,370
there from the early days of C plus B of

00:18:56,460 --> 00:19:02,700
C basically you mustn´t points on

00:18:59,370 --> 00:19:05,460
objects that's below you in the stack

00:19:02,700 --> 00:19:08,370
assuming here stacks co-op words or

00:19:05,460 --> 00:19:10,320
illustration and then we have to

00:19:08,370 --> 00:19:14,190
distinguish between pointers at just

00:19:10,320 --> 00:19:18,350
point and pointers that are owners okay

00:19:14,190 --> 00:19:22,740
so let's do that we have a low-level

00:19:18,350 --> 00:19:25,740
owner abstraction basically an owner is

00:19:22,740 --> 00:19:28,320
a pointer that must be deleted or

00:19:25,740 --> 00:19:30,960
transferred to somebody else which means

00:19:28,320 --> 00:19:33,630
and all the other pointers should must

00:19:30,960 --> 00:19:38,880
be deleted because they don't own

00:19:33,630 --> 00:19:42,090
anything and this is not just pointers

00:19:38,880 --> 00:19:46,380
we have to deal there anything that can

00:19:42,090 --> 00:19:49,170
point to things references smart

00:19:46,380 --> 00:19:52,080
pointers right whatever containers or

00:19:49,170 --> 00:19:54,410
pointers and such and and we can deal

00:19:52,080 --> 00:19:54,410
with this

00:19:54,660 --> 00:19:59,230
marking every pointer with whether it's

00:19:57,250 --> 00:20:00,850
an owner or not doesn't scale this has

00:19:59,230 --> 00:20:03,460
been tried many times in many

00:20:00,850 --> 00:20:06,520
organizations once you get the large

00:20:03,460 --> 00:20:08,740
number people make mistakes they mark

00:20:06,520 --> 00:20:11,560
things for Palmers that isn't mark

00:20:08,740 --> 00:20:13,090
things that is known that is owners they

00:20:11,560 --> 00:20:15,850
forget to mark them and things like that

00:20:13,090 --> 00:20:19,830
it doesn't scale so the idea is we make

00:20:15,850 --> 00:20:22,240
most of that ownership annotation inside

00:20:19,830 --> 00:20:25,870
the implementations of ownership

00:20:22,240 --> 00:20:28,000
abstractions and use it only when we

00:20:25,870 --> 00:20:33,100
have to pass things through interfaces

00:20:28,000 --> 00:20:36,850
like to see and so here's a use of an

00:20:33,100 --> 00:20:39,640
owner that point the vector is usually

00:20:36,850 --> 00:20:41,680
implemented by three pointers and owner

00:20:39,640 --> 00:20:45,850
and two things that just says something

00:20:41,680 --> 00:20:48,090
about the allocated memory and so

00:20:45,850 --> 00:20:52,270
there's one owner and soon on owners and

00:20:48,090 --> 00:20:55,450
to be able to get link compatibility and

00:20:52,270 --> 00:20:56,860
all of these good things owner of T star

00:20:55,450 --> 00:20:59,230
is simply an alias

00:20:56,860 --> 00:21:02,080
you've seen the definition there on the

00:20:59,230 --> 00:21:04,600
screen that is meant to feed the static

00:21:02,080 --> 00:21:08,230
analyzer so that they can make enforce

00:21:04,600 --> 00:21:10,000
the rules and the guarantees and that

00:21:08,230 --> 00:21:13,810
that sort of work it's not too difficult

00:21:10,000 --> 00:21:18,070
as long as you keep it relatively

00:21:13,810 --> 00:21:20,560
localized all of our static analysis

00:21:18,070 --> 00:21:23,470
rules are local static analysis rules we

00:21:20,560 --> 00:21:25,690
don't rely on global static analysis

00:21:23,470 --> 00:21:30,010
because we can't for real size programs

00:21:25,690 --> 00:21:32,470
and but dangling pointers we have a

00:21:30,010 --> 00:21:35,530
fairly simple rule and object points to

00:21:32,470 --> 00:21:37,960
something so if I get a pointer it's

00:21:35,530 --> 00:21:41,410
either a null pointer point to something

00:21:37,960 --> 00:21:43,510
so I can return it pointer to a local

00:21:41,410 --> 00:21:45,820
variable obviously I can't return

00:21:43,510 --> 00:21:49,060
compilers neighbors catch that for a

00:21:45,820 --> 00:21:52,090
couple of decades and when I put

00:21:49,060 --> 00:21:55,090
something into a new into the FreeStore

00:21:52,090 --> 00:21:57,580
yes it points to something I can pass it

00:21:55,090 --> 00:21:59,530
out there is however still a bug here

00:21:57,580 --> 00:22:03,340
because that was only the dangling point

00:21:59,530 --> 00:22:06,550
of taking it was not the the ownership

00:22:03,340 --> 00:22:09,490
checking that new point if it's

00:22:06,550 --> 00:22:12,610
should be coming out of the function

00:22:09,490 --> 00:22:17,050
would have to be marked as an owner but

00:22:12,610 --> 00:22:20,730
so both things have to handle be handled

00:22:17,050 --> 00:22:26,230
there's the ownership and there's the

00:22:20,730 --> 00:22:30,150
access so together they leave as fairly

00:22:26,230 --> 00:22:33,670
simple system for checking whether

00:22:30,150 --> 00:22:37,060
objects are live so a dangling pointer

00:22:33,670 --> 00:22:40,240
song summary it's actually fairly simple

00:22:37,060 --> 00:22:42,570
and it's not just pointers then we have

00:22:40,240 --> 00:22:45,640
to deal with all the other problems

00:22:42,570 --> 00:22:49,030
mostly the other problems can be handled

00:22:45,640 --> 00:22:52,990
by runtime checking or by abstractions

00:22:49,030 --> 00:22:55,840
that help span there's a not null type

00:22:52,990 --> 00:23:01,630
where if you assign something to it it

00:22:55,840 --> 00:23:08,050
checks whether it's not and we will

00:23:01,630 --> 00:23:09,750
check for misuse of of smart pointers we

00:23:08,050 --> 00:23:13,990
check for misuses of

00:23:09,750 --> 00:23:19,960
unions for variant and such so this can

00:23:13,990 --> 00:23:22,420
all be done and to allow gradual

00:23:19,960 --> 00:23:24,760
adoption of this stuff we have a notion

00:23:22,420 --> 00:23:27,250
called profiles so you can say today

00:23:24,760 --> 00:23:28,300
I'll check for dangling pointers just

00:23:27,250 --> 00:23:30,610
dangling pointers

00:23:28,300 --> 00:23:33,640
they run the checking for that once

00:23:30,610 --> 00:23:35,800
you've got your code clean of that you

00:23:33,640 --> 00:23:37,810
can check for ownership you can check

00:23:35,800 --> 00:23:40,870
for for other things but it's really

00:23:37,810 --> 00:23:44,470
important for large code bases that you

00:23:40,870 --> 00:23:49,090
can drop this stuff gradually and so

00:23:44,470 --> 00:23:52,390
there's lots of rules here there's the

00:23:49,090 --> 00:23:55,390
philosophical rules and all the others

00:23:52,390 --> 00:23:56,980
they're classified this is not the

00:23:55,390 --> 00:24:00,460
classification of what you can check

00:23:56,980 --> 00:24:03,070
individually the the profiles go across

00:24:00,460 --> 00:24:04,930
the categories but if you actually want

00:24:03,070 --> 00:24:06,610
to read this from the beginning to the

00:24:04,930 --> 00:24:09,760
end which I don't recognize man

00:24:06,610 --> 00:24:12,610
recommend that's the organization the

00:24:09,760 --> 00:24:14,500
idea is to use a tool and then be told

00:24:12,610 --> 00:24:16,750
where to read it when you're violated

00:24:14,500 --> 00:24:20,410
the rules and there's a lot of support

00:24:16,750 --> 00:24:23,410
stuff here I think it's important

00:24:20,410 --> 00:24:26,290
mentioned that the initial work on this

00:24:23,410 --> 00:24:31,930
was done by people from Robin Stanley

00:24:26,290 --> 00:24:34,810
Microsoft Facebook redhead and CERN so

00:24:31,930 --> 00:24:37,030
it was a broad spectrum in the industry

00:24:34,810 --> 00:24:40,120
including people that usually compete

00:24:37,030 --> 00:24:42,400
this is this is good this is necessary

00:24:40,120 --> 00:24:45,550
it also makes open-source necessary

00:24:42,400 --> 00:24:48,430
because we could not collaborate in in

00:24:45,550 --> 00:24:52,120
it so I understand this group where we

00:24:48,430 --> 00:24:55,980
most of us came from and/or it is open

00:24:52,120 --> 00:24:57,940
source you can't just have a closed our

00:24:55,980 --> 00:25:02,100
condition for working with each other

00:24:57,940 --> 00:25:05,680
was that it was available and so endless

00:25:02,100 --> 00:25:08,860
specialized rules here if I had an hour

00:25:05,680 --> 00:25:12,760
hour or day I could walk you through it

00:25:08,860 --> 00:25:16,660
but but I don't I'm running out of time

00:25:12,760 --> 00:25:20,500
and I plan to end on time so I'll go to

00:25:16,660 --> 00:25:23,950
the overview here basically maintain

00:25:20,500 --> 00:25:27,820
static type safety don't throw in casts

00:25:23,950 --> 00:25:32,560
if you throw in casts you you sort of

00:25:27,820 --> 00:25:35,350
blind any checker so so don't and will

00:25:32,560 --> 00:25:38,620
we the rules will guide you towards not

00:25:35,350 --> 00:25:41,260
needing to have casts untagged unions

00:25:38,620 --> 00:25:44,920
again there are problem if you use this

00:25:41,260 --> 00:25:47,710
kind of type punning in unions you are

00:25:44,920 --> 00:25:49,810
deep trouble so don't use a variant be

00:25:47,710 --> 00:25:54,190
precise about ownership you see

00:25:49,810 --> 00:25:59,650
ownership abstractions and use owner if

00:25:54,190 --> 00:26:02,860
you are doing low-level stuff and that

00:25:59,650 --> 00:26:06,610
means that resource release is implicit

00:26:02,860 --> 00:26:09,790
both of memory and non memory resources

00:26:06,610 --> 00:26:12,250
we get the static guarantees and then

00:26:09,790 --> 00:26:14,590
you can check for null point on rage if

00:26:12,250 --> 00:26:18,280
you feel like it I recommend that you

00:26:14,590 --> 00:26:20,350
feel like it because very very few

00:26:18,280 --> 00:26:24,100
programs are so critical that you can't

00:26:20,350 --> 00:26:26,350
afford it if your code is clean like the

00:26:24,100 --> 00:26:29,520
range force means that you don't

00:26:26,350 --> 00:26:30,780
actually have to check on the individual

00:26:29,520 --> 00:26:34,170
element

00:26:30,780 --> 00:26:37,740
on the range and I'm out of time so

00:26:34,170 --> 00:26:41,480
unfortunately I can't do a QA you'll

00:26:37,740 --> 00:26:46,630
have to find me afterwards thank you

00:26:41,480 --> 00:26:46,630
[Applause]

00:26:47,810 --> 00:26:57,999

YouTube URL: https://www.youtube.com/watch?v=BZTSs_d6kYI


