Title: Bjarne Stroustrup | C++ Core Guidelines Project Keynote | FINOS OSSF
Publication date: 2020-02-25
Playlist: FINOS Open Source Strategy Forum 2019
Description: 
	The FINOS Open Source Strategy Forum (OSSF) Virtual 2020 Registration and schedule is live:

►► More information HERE: https://events.linuxfoundation.org/open-source-strategy-forum/
►► Register HERE: https://events.linuxfoundation.org/open-source-strategy-forum/register/
►► Schedule HERE: https://events.linuxfoundation.org/open-source-strategy-forum/program/schedule/

See all of the FINOS Open Source Strategy Forum (OSSF) 2019 talks at our website:
►► OSSF 2019 Recap: https://www.finos.org/ossf-2019-recap

Learn more about FINOS and how we accelerate open source software development in financial services:
►► FINOS: https://www.finos.org/
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬

BJARNE STROUSTRUP | "C++ CORE GUIDELINES PROJECT" Keynote | FINOS OSSF 2019

►► Download Bjarne's talk slides here: https://www.finos.org/ossf-2019-speaker-bjarne-stroustrup

Bjarne Stroustrup, Creator of C++ and Managing Director at Morgan Stanley, was one of our keynote speakers for the FINOS Open Source Strategy Forum (OSSF) 2019. 

Bjarne's keynote talk, "C++ Core Guidelines Project" discusses the questions "What is good modern C++?", and "What would you like your code to look like in 5 years time?".

Code is often the focus for an open-source project, though rarely the only focus; there is also documentation, tutorials, and more. “Open-source” can also provide a forum that enables unlikely collaborations. Bjarne briefly describes the C++ Core Guidelines, a project involving people from many organizations aiming to guide developers to a type- and resource-safe style of efficient C++, supported by tools and a small library.

BJARNE'S BIO

Bjarne Stroustrup is the designer and original implementer of C++ as well as the author of The C++ Programming Language (4th Edition) and A Tour of C++ (2nd edition), Programming: Principles and Practice using C++ (2nd Edition), and many popular and academic publications. Dr. Stroustrup is a Technical Fellow and a Managing Director in the technology division of Morgan Stanley in New York City as well as a visiting professor at Columbia University. He is a member of the US National Academy of Engineering, and an IEEE, ACM, and CHM fellow. He is the recipient of the 2018 NAE Charles Stark Draper Prize for Engineering and the 2017 IET Faraday Medal. He did much of his most important work in Bell Labs. His research interests include distributed systems, design, programming techniques, software development tools, and programming languages. To make C++ a stable and up-to-date base for real-world software development, he has been a leading figure with the ISO C++ standards effort for more than 25 years. He holds a master’s in Mathematics from Aarhus University and a PhD in Computer Science from Cambridge University, where he is an honorary fellow of Churchill College.
Captions: 
	00:00:03,690 --> 00:00:14,480
[Music]

00:00:11,090 --> 00:00:17,730
so I've been involved with the

00:00:14,480 --> 00:00:20,820
open-source since about 2002 maybe

00:00:17,730 --> 00:00:26,150
before and I'm going to talk just about

00:00:20,820 --> 00:00:29,010
a small fairly unusual project today

00:00:26,150 --> 00:00:32,009
basically a couple of years ago I ran

00:00:29,010 --> 00:00:33,719
into the problem that C++ was a very

00:00:32,009 --> 00:00:36,149
modern language was really great

00:00:33,719 --> 00:00:40,290
features people wanted to use it and

00:00:36,149 --> 00:00:42,059
they didn't know how and so I started a

00:00:40,290 --> 00:00:43,829
project trying to figure out how to

00:00:42,059 --> 00:00:46,020
answer the question what would you like

00:00:43,829 --> 00:00:49,170
your code looks like in about five years

00:00:46,020 --> 00:00:52,379
and I'd like to point out that if you

00:00:49,170 --> 00:00:55,379
say just like I do today I think you're

00:00:52,379 --> 00:00:57,539
sort of lost so we started a project

00:00:55,379 --> 00:00:59,910
because I find obviously I wasn't the

00:00:57,539 --> 00:01:05,489
only one trying to answer that question

00:00:59,910 --> 00:01:10,650
so I I went with some of my friends and

00:01:05,489 --> 00:01:13,320
people started a project to give a

00:01:10,650 --> 00:01:16,290
concrete useful answer to that question

00:01:13,320 --> 00:01:19,380
and that had to be sort of cross

00:01:16,290 --> 00:01:25,909
industry and basically a set of

00:01:19,380 --> 00:01:29,310
guidelines supported by by tools and

00:01:25,909 --> 00:01:33,479
it's an open-source project you can find

00:01:29,310 --> 00:01:35,579
all of the text at that github site

00:01:33,479 --> 00:01:38,310
there and there's a small support

00:01:35,579 --> 00:01:43,369
library that's also there there you can

00:01:38,310 --> 00:01:46,610
find references to it so it's it's there

00:01:43,369 --> 00:01:51,869
basically to give an executive summary

00:01:46,610 --> 00:01:54,090
we would like to have C++ we can write

00:01:51,869 --> 00:01:57,299
code that is completely tight and

00:01:54,090 --> 00:01:59,820
regional safe no memory corruption no

00:01:57,299 --> 00:02:03,090
leaks no garbage collector because we

00:01:59,820 --> 00:02:07,469
don't generate any garbage no runtime

00:02:03,090 --> 00:02:10,440
overheads compared to C++ and No Limits

00:02:07,469 --> 00:02:12,420
RS to express ability you can do just

00:02:10,440 --> 00:02:13,230
about anything if you stop people to do

00:02:12,420 --> 00:02:17,909
anything interests

00:02:13,230 --> 00:02:20,250
think we will over there and I ISO C++

00:02:17,909 --> 00:02:22,349
obviously I don't want to get involved

00:02:20,250 --> 00:02:25,290
in designing a new language that's just

00:02:22,349 --> 00:02:27,930
too much work and we want to simplify

00:02:25,290 --> 00:02:30,780
the code because that is a key to both

00:02:27,930 --> 00:02:33,780
maintainability and performance and we

00:02:30,780 --> 00:02:36,120
want to enforcement because if you say a

00:02:33,780 --> 00:02:39,000
set of rules you can do this people

00:02:36,120 --> 00:02:41,239
don't do it people break the rules

00:02:39,000 --> 00:02:45,540
without knowing it we can't have that

00:02:41,239 --> 00:02:47,310
this is where it is a work in progress

00:02:45,540 --> 00:02:50,370
and of course would you look at that

00:02:47,310 --> 00:02:53,069
list of there it's one of the Holy

00:02:50,370 --> 00:02:56,549
Grails of computing and programming

00:02:53,069 --> 00:03:00,120
hence the illustration and so basically

00:02:56,549 --> 00:03:03,870
we want C++ on steroids not a new church

00:03:00,120 --> 00:03:06,480
subset and work in progress we have a

00:03:03,870 --> 00:03:08,849
general approach which is we have a set

00:03:06,480 --> 00:03:11,730
of guidelines we have a support library

00:03:08,849 --> 00:03:16,410
and we have some static analysis tools

00:03:11,730 --> 00:03:18,480
that help you enforce the rules and it's

00:03:16,410 --> 00:03:21,480
not production-ready

00:03:18,480 --> 00:03:24,870
some say it's experimental some is mere

00:03:21,480 --> 00:03:27,060
conjecture but it is being used in

00:03:24,870 --> 00:03:30,510
production in various places for million

00:03:27,060 --> 00:03:35,549
coline code bases so it's it's it's not

00:03:30,510 --> 00:03:38,310
science fiction so one of the questions

00:03:35,549 --> 00:03:43,799
I am asked quite often is why don't you

00:03:38,310 --> 00:03:45,810
just fix C++ and the answer is well yeah

00:03:43,799 --> 00:03:48,000
it's big and it's complicated and we

00:03:45,810 --> 00:03:49,859
would like it simpler but everybody

00:03:48,000 --> 00:03:53,730
wants a simpler language was just two

00:03:49,859 --> 00:03:57,569
more features and they want a guarantee

00:03:53,730 --> 00:04:02,549
that you don't break their code this is

00:03:57,569 --> 00:04:03,599
impossible so hundreds of billions of

00:04:02,549 --> 00:04:05,970
lines of code

00:04:03,599 --> 00:04:07,590
I mean I've argued with people they say

00:04:05,970 --> 00:04:09,120
I should say half a trillion and I don't

00:04:07,590 --> 00:04:11,790
feel comfortable with that because I

00:04:09,120 --> 00:04:13,889
can't prove it but it's a lot and you

00:04:11,790 --> 00:04:16,109
don't change that furthermore there is a

00:04:13,889 --> 00:04:18,150
lot of legacy stored in people's heads

00:04:16,109 --> 00:04:22,680
and you need to deal with that too and

00:04:18,150 --> 00:04:25,800
so we can't simplify the language we can

00:04:22,680 --> 00:04:26,730
simplify the use of the language so

00:04:25,800 --> 00:04:28,890
that's

00:04:26,730 --> 00:04:31,290
the point where I'm going to try an

00:04:28,890 --> 00:04:34,830
attack and and here's sort of the bigger

00:04:31,290 --> 00:04:36,540
bigger problem the value of language is

00:04:34,830 --> 00:04:38,960
in its applications there's a lot of

00:04:36,540 --> 00:04:42,300
great applications we must break them

00:04:38,960 --> 00:04:44,550
the C++ development community is about

00:04:42,300 --> 00:04:46,590
four and a half million people you have

00:04:44,550 --> 00:04:49,530
to train them you can't retrain hunt

00:04:46,590 --> 00:04:51,450
four and a half million people easily

00:04:49,530 --> 00:04:54,390
you can't even teach the teachers fast

00:04:51,450 --> 00:04:56,790
enough need help and they seem to

00:04:54,390 --> 00:05:00,870
increased by about a hundred thousand a

00:04:56,790 --> 00:05:03,840
year so this is a big problem so what is

00:05:00,870 --> 00:05:06,600
this to do with open source basically

00:05:03,840 --> 00:05:10,530
some things are suspect unless they're

00:05:06,600 --> 00:05:13,590
done in public the C++ standard session

00:05:10,530 --> 00:05:17,430
is done public on the ISO rules and

00:05:13,590 --> 00:05:19,650
these guidelines we we need to do them

00:05:17,430 --> 00:05:22,740
in public furthermore we want everybody

00:05:19,650 --> 00:05:25,050
to benefit so we can't have it private

00:05:22,740 --> 00:05:27,540
or expensive and furthermore what so

00:05:25,050 --> 00:05:30,720
able to everybody to contribute the

00:05:27,540 --> 00:05:33,000
initial contributors included Morgan

00:05:30,720 --> 00:05:36,720
Stanley of course Microsoft Red Hat

00:05:33,000 --> 00:05:40,440
Facebook and CERN notice Red Hat and

00:05:36,720 --> 00:05:43,890
Microsoft that's unusual combination

00:05:40,440 --> 00:05:46,170
even more a few years ago we we have to

00:05:43,890 --> 00:05:48,180
do something like open source so major

00:05:46,170 --> 00:05:51,380
open source everything we do is under

00:05:48,180 --> 00:05:54,840
MIT license by the way and there's about

00:05:51,380 --> 00:05:57,330
230 contributors well I was wrong I

00:05:54,840 --> 00:06:00,660
checked it this morning there was 262

00:05:57,330 --> 00:06:02,490
it's a very small number in the in the

00:06:00,660 --> 00:06:06,360
open source community but this is a

00:06:02,490 --> 00:06:09,030
small project in this unusual one

00:06:06,360 --> 00:06:12,390
problem we have is that the guidelines

00:06:09,030 --> 00:06:15,750
taste is really important that is it is

00:06:12,390 --> 00:06:18,000
there's there's no science to what I

00:06:15,750 --> 00:06:20,160
what what code should look like there's

00:06:18,000 --> 00:06:23,760
a lot of parts that could be scientific

00:06:20,160 --> 00:06:26,610
but or all when you want to say to

00:06:23,760 --> 00:06:30,150
people this is what you should try and

00:06:26,610 --> 00:06:32,640
do we need taste and people with taste

00:06:30,150 --> 00:06:36,090
don't have the same taste and so how do

00:06:32,640 --> 00:06:39,120
you mean coherence integrity and of

00:06:36,090 --> 00:06:40,610
design and for that you need to

00:06:39,120 --> 00:06:43,370
articulate principles

00:06:40,610 --> 00:06:46,939
and that's part of what the guidelines

00:06:43,370 --> 00:06:51,949
do and we have to have a stable a team

00:06:46,939 --> 00:06:54,770
of gatekeepers that approve the the pull

00:06:51,949 --> 00:06:57,349
requests that's what we've got meetings

00:06:54,770 --> 00:07:00,860
and all of that right and stuff so what

00:06:57,349 --> 00:07:04,400
is it basically you need a philosophical

00:07:00,860 --> 00:07:07,340
framework for a set of rules you can't

00:07:04,400 --> 00:07:09,439
just individually design rule after rule

00:07:07,340 --> 00:07:11,539
looking at the language features and

00:07:09,439 --> 00:07:13,969
saying well I like that rule

00:07:11,539 --> 00:07:16,039
let's have that you actually it has to

00:07:13,969 --> 00:07:17,539
have a framework so the first thing we

00:07:16,039 --> 00:07:20,960
did was to design sort of a

00:07:17,539 --> 00:07:23,870
philosophical framework and it's fairly

00:07:20,960 --> 00:07:27,620
obvious we want to express ideas and

00:07:23,870 --> 00:07:31,819
code not encrypt it in pointers and

00:07:27,620 --> 00:07:35,029
bytes and bits we want ISO standard C++

00:07:31,819 --> 00:07:38,300
we are not doing proprietary extensions

00:07:35,029 --> 00:07:42,080
and such expressing intent it's really

00:07:38,300 --> 00:07:44,060
nice to say say sort this as opposed to

00:07:42,080 --> 00:07:47,779
just having to read the code and figure

00:07:44,060 --> 00:07:50,779
out it's a sort statically type safe

00:07:47,779 --> 00:07:52,789
it's C++ that's the idea

00:07:50,779 --> 00:07:55,069
compile-time checking to runtime

00:07:52,789 --> 00:07:58,729
checking it's really good we do a lot of

00:07:55,069 --> 00:08:00,800
stuff that not just has to be fast it

00:07:58,729 --> 00:08:03,199
also has to be reliable and for that

00:08:00,800 --> 00:08:05,360
reason I don't want errors to be found

00:08:03,199 --> 00:08:08,060
late so that I have to write an error

00:08:05,360 --> 00:08:10,009
handler to to try and deal with the

00:08:08,060 --> 00:08:14,029
problem it's much better if we can find

00:08:10,009 --> 00:08:16,969
it early what can't be checked it should

00:08:14,029 --> 00:08:19,430
be checkable that is you may decide that

00:08:16,969 --> 00:08:22,219
you don't ford range checking on

00:08:19,430 --> 00:08:24,620
everything but at least your code should

00:08:22,219 --> 00:08:28,190
be such that I can put it in debug a

00:08:24,620 --> 00:08:30,469
testing mode and then test it principles

00:08:28,190 --> 00:08:33,229
like that don't bleak any resources

00:08:30,469 --> 00:08:36,229
don't waste time and space again it's

00:08:33,229 --> 00:08:42,110
C++ if you can run faster we have to do

00:08:36,229 --> 00:08:46,370
better and so philosophical rules are

00:08:42,110 --> 00:08:49,220
not checkable by machines and we want we

00:08:46,370 --> 00:08:51,170
want automatic checking and so we can

00:08:49,220 --> 00:08:53,180
build checkers and so there's a

00:08:51,170 --> 00:08:53,840
lower-level rules that fit into the

00:08:53,180 --> 00:08:57,080
philosophical

00:08:53,840 --> 00:08:59,330
framework and they provide enforcement

00:08:57,080 --> 00:09:01,790
sometimes you can do perfect enforcement

00:08:59,330 --> 00:09:05,420
sometimes you have rely on heuristic

00:09:01,790 --> 00:09:09,500
depends on the rules and so basically

00:09:05,420 --> 00:09:13,250
the the specific rules are aimed at

00:09:09,500 --> 00:09:15,920
machines and those rules like a row

00:09:13,250 --> 00:09:16,820
pointer is a non only minder so if you

00:09:15,920 --> 00:09:18,800
have a point

00:09:16,820 --> 00:09:22,460
you shouldn't say delete to it because

00:09:18,800 --> 00:09:23,930
it don't own things similarly it points

00:09:22,460 --> 00:09:26,990
to a single object so you shouldn't

00:09:23,930 --> 00:09:30,410
subscript it this sort of break every

00:09:26,990 --> 00:09:35,360
traditional C++ program however we also

00:09:30,410 --> 00:09:39,230
provide alternatives so this is just a

00:09:35,360 --> 00:09:42,440
proof that it's not not science fiction

00:09:39,230 --> 00:09:45,470
it's a cut out of an old Visual Studio

00:09:42,440 --> 00:09:47,900
version with stuff ships dishes Visual

00:09:45,470 --> 00:09:51,290
Studio some of the rules ship with

00:09:47,900 --> 00:09:54,790
client ID also and basically that one is

00:09:51,290 --> 00:09:57,470
catching a potential memory leak and

00:09:54,790 --> 00:10:00,500
this shows how I would like this stuff

00:09:57,470 --> 00:10:02,870
to be done you you run the checker it

00:10:00,500 --> 00:10:06,620
points to a line of code it tells you

00:10:02,870 --> 00:10:09,020
which rule that is violated it dumps you

00:10:06,620 --> 00:10:12,260
into the specification of where the rule

00:10:09,020 --> 00:10:14,960
is you click on that one and it will

00:10:12,260 --> 00:10:16,730
tell you what is the rule what is it

00:10:14,960 --> 00:10:19,730
called what's the rationale for the core

00:10:16,730 --> 00:10:21,980
the 404 for it what's an example of what

00:10:19,730 --> 00:10:24,530
goes wrong if you proceed and what is a

00:10:21,980 --> 00:10:28,100
way to fixing it this is really quite

00:10:24,530 --> 00:10:32,840
practical and there's a support library

00:10:28,100 --> 00:10:34,730
that we we rely on because the general

00:10:32,840 --> 00:10:38,810
trick is not so tell you how to use

00:10:34,730 --> 00:10:39,350
every little low-level feature in a safe

00:10:38,810 --> 00:10:42,290
way

00:10:39,350 --> 00:10:45,740
that's impossible you assume ends up

00:10:42,290 --> 00:10:47,720
with hitting the halting problem if you

00:10:45,740 --> 00:10:50,420
want to say prove that there's no memory

00:10:47,720 --> 00:10:54,160
leaks you can however raise the

00:10:50,420 --> 00:10:57,470
abstraction level by a few of libraries

00:10:54,160 --> 00:11:01,040
that are also very efficient and then

00:10:57,470 --> 00:11:03,320
you can subset after that that's how I

00:11:01,040 --> 00:11:04,910
get away with saying the pointers point

00:11:03,320 --> 00:11:06,740
to something they don't own it and they

00:11:04,910 --> 00:11:07,250
you don't subscribe them one of the

00:11:06,740 --> 00:11:12,650
things

00:11:07,250 --> 00:11:15,230
in the library's span this is in GSL

00:11:12,650 --> 00:11:17,510
with guide line support library but we

00:11:15,230 --> 00:11:19,910
want to be out of business in that

00:11:17,510 --> 00:11:24,980
library by getting it standardized and

00:11:19,910 --> 00:11:27,350
span isn't G in C++ 20 so it will

00:11:24,980 --> 00:11:29,990
disappear if we want to put ourselves

00:11:27,350 --> 00:11:34,610
out of business but here's a span this

00:11:29,990 --> 00:11:36,590
is how you avoid range errors there's an

00:11:34,610 --> 00:11:38,750
array if we poke into it with

00:11:36,590 --> 00:11:40,850
subscripting and pointers we will

00:11:38,750 --> 00:11:43,070
eventually get range errors because

00:11:40,850 --> 00:11:45,590
people don't get it right however we can

00:11:43,070 --> 00:11:49,460
say make me a span for that and this

00:11:45,590 --> 00:11:51,950
bind together the size and where the

00:11:49,460 --> 00:11:55,400
elements are and so now I can do things

00:11:51,950 --> 00:11:58,520
like arrange for over it you cannot have

00:11:55,400 --> 00:11:59,810
a range error for something that is

00:11:58,520 --> 00:12:02,630
guaranteed to be in range

00:11:59,810 --> 00:12:05,780
problem solved and so we have about 10

00:12:02,630 --> 00:12:09,410
things in the guideline support library

00:12:05,780 --> 00:12:14,330
stand MIT license open source code and

00:12:09,410 --> 00:12:17,860
it this one went out of business good

00:12:14,330 --> 00:12:20,570
its non-standard and so somewhere here

00:12:17,860 --> 00:12:22,760
we want to maintain static type safety

00:12:20,570 --> 00:12:26,270
which means that we look at things like

00:12:22,760 --> 00:12:28,730
casts and on tag unions and try to make

00:12:26,270 --> 00:12:30,440
sure you don't do it in the standard we

00:12:28,730 --> 00:12:33,100
now have variants so we can do without

00:12:30,440 --> 00:12:36,200
the uncheck unions and don't glitter

00:12:33,100 --> 00:12:39,410
don't leak memory we also know how to do

00:12:36,200 --> 00:12:41,390
that using ownership abstractions like a

00:12:39,410 --> 00:12:45,460
vector looks care takes care of its

00:12:41,390 --> 00:12:50,210
elements a task thread takes care of its

00:12:45,460 --> 00:12:54,320
operating systems support we eliminate

00:12:50,210 --> 00:12:57,470
dangling pointers we make resource

00:12:54,320 --> 00:12:59,120
management implicit and provide the

00:12:57,470 --> 00:13:00,589
static guarantees and then there's some

00:12:59,120 --> 00:13:03,280
libraries for things that can't be

00:13:00,589 --> 00:13:07,070
guaranteed statically and that's

00:13:03,280 --> 00:13:11,210
basically it I encourage you to try look

00:13:07,070 --> 00:13:14,089
at it to try it if you can and give

00:13:11,210 --> 00:13:14,540
feedback it's there and github for you

00:13:14,089 --> 00:13:16,940
too

00:13:14,540 --> 00:13:18,890
so give feedback otherwise if you don't

00:13:16,940 --> 00:13:19,830
want to go straight there send emails

00:13:18,890 --> 00:13:22,160
one of the

00:13:19,830 --> 00:13:27,780
editor's thank you

00:13:22,160 --> 00:13:27,780
[Applause]

00:13:30,600 --> 00:13:38,799

YouTube URL: https://www.youtube.com/watch?v=A6awiN5QQo8


