Title: FINOS Open Source in Fintech Meetup | Code Coverage Paradox | Diffblue | Feb 2021
Publication date: 2021-04-11
Playlist: FINOS Guest Speakers & Meetups
Description: 
	Guest Speaker: Enrico Trentin of Diffblue, presented "The Code Coverage Paradox: When 90% Isn’t Enough, But Less Might Be". 

This video was from a live FINOS Open Source in Fintech Meetup on February 17, 2020. Join us live for future "Meetups" to see real examples of successful collaboration, hear a few top tips from active contributors, and learn about some innovative approaches to maintaining open source projects.

Enrico's Presentation: The Code Coverage Paradox: When 90% Isn’t Enough, But Less Might Be - February 17th, 2021

Talk abstract - Code coverage is the metric everyone knows - but is it really what you need to be using? In this talk, we will walk you through the code metrics that actually matter, identify areas of risk, and efficiently improve them with manual and automated means, using examples from FINOS open source projects and data-modelling platforms.

Enrico's Bio:

Enrico Trentin, Developer Relations Lead, Diffblue
Enrico Trentin is the developer relations lead at Diffblue. He has been a developer for eight years, primarily working in Java. Originally from Italy, he is now based in Oxford, UK.

►►Visit here for more FINOS Events https://finos.org/hosted-events

►►Visit the FINOS website https://finos.org/ and Get Involved https://finos.org/get-involved)
 
►►Join us for the FINOS & Linux Foundation Open Source Strategy Forum (OSSF)

London https://events.linuxfoundation.org/open-source-strategy-forum-london

New York https://events.linuxfoundation.org/open-source-strategy-forum-new-york/

►►Listen to all of our podcasts on these platforms as well as others: 

Apple Podcasts https://podcasts.apple.com/us/podcast/finos-open-source-in-fintech-podcast/id1512371068

Anchor.fm https://anchor.fm/finos

Spotify https://open.spotify.com/show/431XdfX2fBdCUsopwh8td3

Check it out, subscribe, and don’t forget to rate us (5 stars)!
Captions: 
	00:00:03,650 --> 00:00:11,849
[Music]

00:00:13,920 --> 00:00:16,240
hi

00:00:14,320 --> 00:00:18,160
good day good afternoon good morning i'm

00:00:16,240 --> 00:00:18,960
james mcleod finnos director of

00:00:18,160 --> 00:00:22,000
community

00:00:18,960 --> 00:00:24,240
and i'm your host for today's call um

00:00:22,000 --> 00:00:25,599
so being the host um it means that i'm

00:00:24,240 --> 00:00:27,439
actually looking after everybody who's

00:00:25,599 --> 00:00:30,240
on the pool including enrico

00:00:27,439 --> 00:00:32,320
who's um presenter for today and say if

00:00:30,240 --> 00:00:35,600
i can ask everybody who's joining us

00:00:32,320 --> 00:00:36,960
um just to place yourselves on mute um

00:00:35,600 --> 00:00:39,520
that'll be great because it means that

00:00:36,960 --> 00:00:41,840
we can keep um any background noise down

00:00:39,520 --> 00:00:44,239
um or if you're unable to mute yourself

00:00:41,840 --> 00:00:46,320
um i can do that as host

00:00:44,239 --> 00:00:47,280
i'd like to welcome everybody to our

00:00:46,320 --> 00:00:50,719
first finos

00:00:47,280 --> 00:00:53,680
meetup um of 2021

00:00:50,719 --> 00:00:54,559
and i'm james macleod finish director of

00:00:53,680 --> 00:00:58,000
community

00:00:54,559 --> 00:01:00,879
and i'm joined by enrique trenton um

00:00:58,000 --> 00:01:02,480
development relations lead at diff blee

00:01:00,879 --> 00:01:05,360
who are a finnos member

00:01:02,480 --> 00:01:05,840
um and enrico's here to present to us

00:01:05,360 --> 00:01:09,119
today

00:01:05,840 --> 00:01:09,680
the code coverage paradox where 90 isn't

00:01:09,119 --> 00:01:12,720
enough

00:01:09,680 --> 00:01:13,920
but less might be but before i hand over

00:01:12,720 --> 00:01:16,560
to emiko

00:01:13,920 --> 00:01:17,680
for his presentation i'd like to remind

00:01:16,560 --> 00:01:20,880
everybody to

00:01:17,680 --> 00:01:22,720
visit um finnos at finos.org to

00:01:20,880 --> 00:01:24,400
subscribe to our mailing lists

00:01:22,720 --> 00:01:26,159
and learn how to get involved with the

00:01:24,400 --> 00:01:28,960
finnos community

00:01:26,159 --> 00:01:30,240
i'd also encourage developers and

00:01:28,960 --> 00:01:33,360
engineers to visit

00:01:30,240 --> 00:01:36,159
the finnos organization on github by

00:01:33,360 --> 00:01:38,000
visiting github.com forward slash finos

00:01:36,159 --> 00:01:40,320
if you're an engineer or developer

00:01:38,000 --> 00:01:42,079
wanting to contribute or leverage finos

00:01:40,320 --> 00:01:45,200
open source projects

00:01:42,079 --> 00:01:47,040
um plus also uh for anybody who's

00:01:45,200 --> 00:01:49,360
registered for today's call

00:01:47,040 --> 00:01:50,240
um we'll also be drawing a couple of

00:01:49,360 --> 00:01:53,280
attendees

00:01:50,240 --> 00:01:57,200
um out of our out of the hat um

00:01:53,280 --> 00:01:59,119
randomly um and shipping you

00:01:57,200 --> 00:02:00,880
finnos t-shirt each as well which is

00:01:59,119 --> 00:02:03,280
great and so with that

00:02:00,880 --> 00:02:04,640
i'd like to welcome enrique to today's

00:02:03,280 --> 00:02:08,160
um meetup

00:02:04,640 --> 00:02:09,520
it's over to you thanks and thanks

00:02:08,160 --> 00:02:12,239
everyone for joining

00:02:09,520 --> 00:02:14,080
i'm eric i'm the developer relations

00:02:12,239 --> 00:02:16,319
lead here at diff blue

00:02:14,080 --> 00:02:17,520
where spin out from oxford university

00:02:16,319 --> 00:02:22,640
founder

00:02:17,520 --> 00:02:22,640
16 with series a founding lab

00:02:22,800 --> 00:02:27,040
we're a silver member of finos and

00:02:24,800 --> 00:02:29,680
provide the full version of our product

00:02:27,040 --> 00:02:31,200
blue cover for free to use on finos

00:02:29,680 --> 00:02:34,160
projects

00:02:31,200 --> 00:02:35,599
we build tools that use a techniques to

00:02:34,160 --> 00:02:38,480
automatically generate

00:02:35,599 --> 00:02:40,480
unit tests for your job application more

00:02:38,480 --> 00:02:41,920
on this

00:02:40,480 --> 00:02:44,239
in this talk i'm going to give you an

00:02:41,920 --> 00:02:46,720
overview on software metrics and how

00:02:44,239 --> 00:02:48,080
they can be used to minimize risk

00:02:46,720 --> 00:02:50,800
and increase the quality of an

00:02:48,080 --> 00:02:53,120
application i will start with coverage

00:02:50,800 --> 00:02:53,920
and as the title suggests i will explore

00:02:53,120 --> 00:02:56,160
its strengths

00:02:53,920 --> 00:02:58,000
and weaknesses and i'll show you why

00:02:56,160 --> 00:03:01,599
coverage alone is not enough

00:02:58,000 --> 00:03:03,599
to assess the risk in your application

00:03:01,599 --> 00:03:05,280
i will then introduce other metrics that

00:03:03,599 --> 00:03:08,400
can be used in conjunction with

00:03:05,280 --> 00:03:11,760
coverage so that i have a more complete

00:03:08,400 --> 00:03:13,280
set of tools for a risk assessment

00:03:11,760 --> 00:03:14,879
finally i will talk about deep blue

00:03:13,280 --> 00:03:16,840
cover what it is and

00:03:14,879 --> 00:03:19,040
the party can play in the reaction of

00:03:16,840 --> 00:03:22,319
risks

00:03:19,040 --> 00:03:23,120
let's start with an example in this

00:03:22,319 --> 00:03:26,319
chart

00:03:23,120 --> 00:03:27,360
using the code coverage of my pro now

00:03:26,319 --> 00:03:29,760
familiar with

00:03:27,360 --> 00:03:32,000
coverage it's that percentage that tells

00:03:29,760 --> 00:03:35,519
us how much our application has been

00:03:32,000 --> 00:03:37,680
tested and frankly we all get obsessed

00:03:35,519 --> 00:03:39,840
with percentages sometimes

00:03:37,680 --> 00:03:41,440
and they end up being the only indicator

00:03:39,840 --> 00:03:43,920
we look at

00:03:41,440 --> 00:03:46,400
and you can see the coverage of this

00:03:43,920 --> 00:03:49,200
project is impressive it reaches

00:03:46,400 --> 00:03:50,319
nine percent and those of you that work

00:03:49,200 --> 00:03:53,680
in a company where

00:03:50,319 --> 00:03:54,239
coverage target exists uh know how much

00:03:53,680 --> 00:03:58,319
time

00:03:54,239 --> 00:04:00,640
resources it takes to reach these levels

00:03:58,319 --> 00:04:01,599
however once i hit this number is my

00:04:00,640 --> 00:04:04,560
work done

00:04:01,599 --> 00:04:05,920
am i now confident that the risk of this

00:04:04,560 --> 00:04:08,959
application is low

00:04:05,920 --> 00:04:11,840
only by looking at this 90 percent

00:04:08,959 --> 00:04:12,959
or perhaps someone working with legacy

00:04:11,840 --> 00:04:15,519
code and

00:04:12,959 --> 00:04:16,959
which hasn't been sufficiently tested

00:04:15,519 --> 00:04:20,479
and are working on improving

00:04:16,959 --> 00:04:24,960
its coverage do i need to reach

00:04:20,479 --> 00:04:24,960
90 percent before i start feeling safe

00:04:25,040 --> 00:04:28,320
in order to find the answer to these

00:04:27,120 --> 00:04:30,880
questions i

00:04:28,320 --> 00:04:31,680
need to have a closer look at my

00:04:30,880 --> 00:04:36,160
application

00:04:31,680 --> 00:04:39,280
and at its tests ultimately how am i

00:04:36,160 --> 00:04:42,400
doubting this 90 percent of coverage

00:04:39,280 --> 00:04:43,600
is necessary it effectively catches

00:04:42,400 --> 00:04:46,800
regressions

00:04:43,600 --> 00:04:46,800
and increases quality

00:04:47,440 --> 00:04:51,120
let's start by having a look at some of

00:04:49,440 --> 00:04:53,520
the code that has been covered

00:04:51,120 --> 00:04:54,240
in this we're still looking at the

00:04:53,520 --> 00:04:56,720
applique

00:04:54,240 --> 00:04:57,680
from my previous example but i have

00:04:56,720 --> 00:05:01,120
zoomed in

00:04:57,680 --> 00:05:04,320
on one specific class and its methods

00:05:01,120 --> 00:05:06,400
the coverage of this class is 100 but

00:05:04,320 --> 00:05:08,479
when i look at the method names i notice

00:05:06,400 --> 00:05:11,280
they're all getters and setters

00:05:08,479 --> 00:05:13,600
plus the class constructor for those of

00:05:11,280 --> 00:05:16,400
you not familiar with the concept

00:05:13,600 --> 00:05:17,280
these are very common methods that tend

00:05:16,400 --> 00:05:19,600
to be very short

00:05:17,280 --> 00:05:20,880
most of the time just one line and they

00:05:19,600 --> 00:05:24,320
con

00:05:20,880 --> 00:05:28,000
logic and at diff blue we call this

00:05:24,320 --> 00:05:28,479
trivial methods in other words this

00:05:28,000 --> 00:05:31,440
class

00:05:28,479 --> 00:05:33,120
and its methods are not contributing any

00:05:31,440 --> 00:05:35,919
significant risk

00:05:33,120 --> 00:05:37,280
for my application writing test for

00:05:35,919 --> 00:05:40,639
these methods is not

00:05:37,280 --> 00:05:44,240
a good use of developers time and

00:05:40,639 --> 00:05:46,880
clearly testing is fitting this

00:05:44,240 --> 00:05:48,080
the code good coverage so it makes us

00:05:46,880 --> 00:05:50,240
feel better

00:05:48,080 --> 00:05:52,080
but this does not decrease the risk in

00:05:50,240 --> 00:05:54,320
my application in any significant

00:05:52,080 --> 00:05:54,320
way

00:05:55,759 --> 00:06:02,960
what that has been covered and

00:05:58,800 --> 00:06:05,360
does contain logic an example of a cloud

00:06:02,960 --> 00:06:07,280
that i called calculator it has a single

00:06:05,360 --> 00:06:09,919
method called divide

00:06:07,280 --> 00:06:11,440
and as you may expect given two numbers

00:06:09,919 --> 00:06:14,479
it returns the numerator

00:06:11,440 --> 00:06:17,039
divided by the denominator

00:06:14,479 --> 00:06:19,280
and here is the unit test very simple it

00:06:17,039 --> 00:06:22,639
just checks that dividing one by one

00:06:19,280 --> 00:06:25,280
results in one

00:06:22,639 --> 00:06:27,280
the class calculator has 100 coverage we

00:06:25,280 --> 00:06:30,319
have tested every line of the code

00:06:27,280 --> 00:06:32,560
but clearly the risk isn't mitigated and

00:06:30,319 --> 00:06:36,160
my application is not 100

00:06:32,560 --> 00:06:37,280
safe from failure i haven't tested for

00:06:36,160 --> 00:06:39,680
example what happens

00:06:37,280 --> 00:06:41,360
if i divide by zero if i try and divide

00:06:39,680 --> 00:06:42,400
by zero my application will throw an

00:06:41,360 --> 00:06:44,560
exception

00:06:42,400 --> 00:06:46,080
and if that's not handled my application

00:06:44,560 --> 00:06:48,479
will crash

00:06:46,080 --> 00:06:50,400
in the worst case i may even lose

00:06:48,479 --> 00:06:52,240
important information being processed by

00:06:50,400 --> 00:06:55,280
my application

00:06:52,240 --> 00:06:58,479
in this case 100 coverage did not

00:06:55,280 --> 00:06:58,479
protect me from failure

00:06:59,039 --> 00:07:02,960
and finally let's have a look at code

00:07:01,120 --> 00:07:04,639
that hasn't been covered

00:07:02,960 --> 00:07:07,280
just because ninety percent of the code

00:07:04,639 --> 00:07:08,800
has been tested it doesn't mean

00:07:07,280 --> 00:07:10,800
that a failure cannot happen in the

00:07:08,800 --> 00:07:13,199
remaining ten percent

00:07:10,800 --> 00:07:14,240
it just takes a bug in a single line to

00:07:13,199 --> 00:07:17,520
potentially cause

00:07:14,240 --> 00:07:17,759
destructive damage let's see an example

00:07:17,520 --> 00:07:21,360
i

00:07:17,759 --> 00:07:24,800
focus on one untested piece of code

00:07:21,360 --> 00:07:26,720
and i have some information about it

00:07:24,800 --> 00:07:29,120
it was written a long time ago its

00:07:26,720 --> 00:07:31,520
author may even have left the company

00:07:29,120 --> 00:07:32,720
it hasn't been touched in nine years i

00:07:31,520 --> 00:07:36,319
can see that

00:07:32,720 --> 00:07:38,160
the class is bigger than the average

00:07:36,319 --> 00:07:40,240
and i had a look inside and i saw it was

00:07:38,160 --> 00:07:44,000
pretty complex

00:07:40,240 --> 00:07:46,240
so what is this piece of code

00:07:44,000 --> 00:07:47,280
it is the function that restores backups

00:07:46,240 --> 00:07:49,759
after a failure

00:07:47,280 --> 00:07:50,639
it is critical for my application it's

00:07:49,759 --> 00:07:53,120
only used

00:07:50,639 --> 00:07:55,280
in case of emergency so we don't need

00:07:53,120 --> 00:07:57,199
this functionality very often

00:07:55,280 --> 00:07:58,720
but when we do we cannot afford a

00:07:57,199 --> 00:08:01,759
failure it must work

00:07:58,720 --> 00:08:02,639
and it must work properly so in this

00:08:01,759 --> 00:08:05,680
case coverage

00:08:02,639 --> 00:08:08,479
has been helpful it has been pointing to

00:08:05,680 --> 00:08:10,800
the class connected to the highest risk

00:08:08,479 --> 00:08:13,120
my mistake was that i stopped at the

00:08:10,800 --> 00:08:15,680
headline figure 90

00:08:13,120 --> 00:08:18,720
and i haven't looked at the breakdown by

00:08:15,680 --> 00:08:18,720
classes and methods

00:08:20,080 --> 00:08:24,560
so as we've seen coverage gives us some

00:08:22,720 --> 00:08:27,199
information about our project

00:08:24,560 --> 00:08:29,360
and can guide us towards the riskiest

00:08:27,199 --> 00:08:31,280
part of our code base

00:08:29,360 --> 00:08:32,560
the coverage needs to be inspected

00:08:31,280 --> 00:08:34,719
closely and

00:08:32,560 --> 00:08:36,640
is still not enough to protect us from

00:08:34,719 --> 00:08:39,760
failures

00:08:36,640 --> 00:08:41,760
so what can i do to mitigate the risk of

00:08:39,760 --> 00:08:44,000
failure in my project

00:08:41,760 --> 00:08:44,880
it all boils down to having a deeper

00:08:44,000 --> 00:08:47,519
understanding

00:08:44,880 --> 00:08:48,160
of the code and there are a lot of other

00:08:47,519 --> 00:08:51,440
metrics

00:08:48,160 --> 00:08:51,440
that can help us with that

00:08:52,320 --> 00:08:56,880
i have selected four popular metrics

00:08:54,480 --> 00:08:59,040
that together with coverage can complete

00:08:56,880 --> 00:09:01,120
the picture and provide enough

00:08:59,040 --> 00:09:04,480
information for me to spot

00:09:01,120 --> 00:09:06,320
the risks in my code

00:09:04,480 --> 00:09:07,600
i will talk about each one of them in

00:09:06,320 --> 00:09:10,800
the next few slides

00:09:07,600 --> 00:09:11,760
but i want you to keep in mind that none

00:09:10,800 --> 00:09:14,080
of this metrics

00:09:11,760 --> 00:09:15,760
on his own is the solution to all of my

00:09:14,080 --> 00:09:17,519
problems

00:09:15,760 --> 00:09:19,440
and is by using them together that i

00:09:17,519 --> 00:09:23,839
build up more and more confidence

00:09:19,440 --> 00:09:23,839
in my piece of software

00:09:23,920 --> 00:09:26,959
the first metric i want to suggest is

00:09:25,600 --> 00:09:29,120
the stability

00:09:26,959 --> 00:09:31,200
sometimes the reason for a lack of

00:09:29,120 --> 00:09:34,800
coverage in an area of my code base is

00:09:31,200 --> 00:09:34,800
that my code is not testable

00:09:34,839 --> 00:09:39,440
perhaps i'm writing a test for a

00:09:37,839 --> 00:09:42,240
specific piece of code but

00:09:39,440 --> 00:09:43,920
i cannot access all of it and this makes

00:09:42,240 --> 00:09:45,440
it impossible for me to verify the

00:09:43,920 --> 00:09:48,240
behavior of my code

00:09:45,440 --> 00:09:49,680
with unit tests the situation i just

00:09:48,240 --> 00:09:52,800
described could be called

00:09:49,680 --> 00:09:55,360
pool testability

00:09:52,800 --> 00:09:57,519
in the context of unit tests a method is

00:09:55,360 --> 00:10:02,079
testable when i can fully control

00:09:57,519 --> 00:10:03,360
its inputs and fully observe its effects

00:10:02,079 --> 00:10:05,040
if you're working on increasing the

00:10:03,360 --> 00:10:06,160
coverage of a project and you're

00:10:05,040 --> 00:10:08,800
struggling to

00:10:06,160 --> 00:10:09,920
write tests for a specific method or

00:10:08,800 --> 00:10:11,519
class

00:10:09,920 --> 00:10:13,360
double check the testability of the

00:10:11,519 --> 00:10:15,440
source code

00:10:13,360 --> 00:10:17,680
sometimes the solution to reduce risk

00:10:15,440 --> 00:10:21,120
involves a refactoring of the code

00:10:17,680 --> 00:10:21,120
to increase the testability

00:10:21,519 --> 00:10:25,279
here i have an example of a method with

00:10:23,839 --> 00:10:27,680
pool testability

00:10:25,279 --> 00:10:28,560
as you can see the method increment

00:10:27,680 --> 00:10:31,360
modifies

00:10:28,560 --> 00:10:32,880
a private attribute of the class counter

00:10:31,360 --> 00:10:35,760
and does not return

00:10:32,880 --> 00:10:37,519
any value when i try and write a test

00:10:35,760 --> 00:10:40,720
for this method i realize

00:10:37,519 --> 00:10:42,399
that i have no way of checking the new

00:10:40,720 --> 00:10:46,640
value of the private attribute

00:10:42,399 --> 00:10:48,560
counter a simple refactoring that

00:10:46,640 --> 00:10:49,360
improves the testability of this code

00:10:48,560 --> 00:10:52,079
involves

00:10:49,360 --> 00:10:53,839
adding a method that returns the private

00:10:52,079 --> 00:10:56,079
attribute counter

00:10:53,839 --> 00:10:57,680
and after that i can successfully test

00:10:56,079 --> 00:11:01,839
that the value has been

00:10:57,680 --> 00:11:01,839
incremented as as expected

00:11:04,480 --> 00:11:07,760
the next metric is cyclomatic complexity

00:11:07,279 --> 00:11:10,560
it's

00:11:07,760 --> 00:11:12,160
a metric that quantifies how complex my

00:11:10,560 --> 00:11:15,279
code is

00:11:12,160 --> 00:11:17,120
is an example of a piece of code and

00:11:15,279 --> 00:11:18,959
every piece of code can be represented

00:11:17,120 --> 00:11:19,600
by a diagram like the one that i've

00:11:18,959 --> 00:11:22,959
drawn

00:11:19,600 --> 00:11:25,839
on the right every blue node represents

00:11:22,959 --> 00:11:27,040
a set of instructions and every yellow

00:11:25,839 --> 00:11:30,560
node represents

00:11:27,040 --> 00:11:32,480
a decision point the formula for

00:11:30,560 --> 00:11:34,880
calculating this metric is simple

00:11:32,480 --> 00:11:36,560
and as shown in the slide the complexity

00:11:34,880 --> 00:11:39,680
for this piece of code is

00:11:36,560 --> 00:11:41,680
three the higher the complexity for a

00:11:39,680 --> 00:11:44,720
piece of code the higher the risk

00:11:41,680 --> 00:11:45,279
of making mistakes in order to reduce

00:11:44,720 --> 00:11:49,120
risk

00:11:45,279 --> 00:11:49,120
we want to keep the complexity low

00:11:51,279 --> 00:11:54,880
let's check once again the project that

00:11:54,000 --> 00:11:56,480
i've been using

00:11:54,880 --> 00:11:58,079
as an example at the beginning of this

00:11:56,480 --> 00:12:00,240
presentation

00:11:58,079 --> 00:12:01,200
this time the callers are expressing the

00:12:00,240 --> 00:12:04,320
complexity

00:12:01,200 --> 00:12:06,800
of each part of my project

00:12:04,320 --> 00:12:08,000
here this metric is highlighting classes

00:12:06,800 --> 00:12:11,279
and methods with

00:12:08,000 --> 00:12:14,160
medium complexity and really pointing at

00:12:11,279 --> 00:12:15,600
four methods where the complexity is

00:12:14,160 --> 00:12:17,519
high

00:12:15,600 --> 00:12:19,040
in order to reduce the risk i have to

00:12:17,519 --> 00:12:22,240
make sure that these

00:12:19,040 --> 00:12:24,959
methods are well tested

00:12:22,240 --> 00:12:25,839
alternatively by breaking down a complex

00:12:24,959 --> 00:12:29,279
method into

00:12:25,839 --> 00:12:31,920
multiple smaller units of functionality

00:12:29,279 --> 00:12:32,880
we reduce the complexity making it

00:12:31,920 --> 00:12:37,120
easier to test

00:12:32,880 --> 00:12:39,120
the code and thus help reduce risk

00:12:37,120 --> 00:12:40,720
and different sources suggest different

00:12:39,120 --> 00:12:43,120
thresholds but

00:12:40,720 --> 00:12:43,760
if the complexity of a piece of code

00:12:43,120 --> 00:12:49,040
exceeds

00:12:43,760 --> 00:12:49,040
15 i'd strongly consider refactoring

00:12:51,120 --> 00:12:54,320
another technique to determine risks

00:12:53,440 --> 00:12:56,560
connected

00:12:54,320 --> 00:12:59,440
to a piece of software is analyzing the

00:12:56,560 --> 00:13:01,839
dependencies between classes

00:12:59,440 --> 00:13:03,120
in the chart in this slide each circle

00:13:01,839 --> 00:13:04,959
represents a class

00:13:03,120 --> 00:13:08,399
and dependencies between classes are

00:13:04,959 --> 00:13:10,399
represented by arrows

00:13:08,399 --> 00:13:12,240
when i have multiple classes depending

00:13:10,399 --> 00:13:12,800
on the correct behavior of a single

00:13:12,240 --> 00:13:15,120
class

00:13:12,800 --> 00:13:16,240
like for example the green circle in the

00:13:15,120 --> 00:13:19,519
middle of this

00:13:16,240 --> 00:13:22,639
graphic then i can say that the risk

00:13:19,519 --> 00:13:23,600
of that class is high because a single

00:13:22,639 --> 00:13:26,320
failure there

00:13:23,600 --> 00:13:28,959
can cause multiple errors in the rest of

00:13:26,320 --> 00:13:30,639
my application

00:13:28,959 --> 00:13:32,639
in order to mitigate the risk in this

00:13:30,639 --> 00:13:35,680
case i want to make sure that

00:13:32,639 --> 00:13:38,480
classes that are highly depended on are

00:13:35,680 --> 00:13:38,480
well tested

00:13:39,120 --> 00:13:42,240
and i have a warning here pieces of code

00:13:41,279 --> 00:13:44,639
that are not

00:13:42,240 --> 00:13:46,480
depended on by others are not

00:13:44,639 --> 00:13:48,959
necessarily less critical

00:13:46,480 --> 00:13:50,639
i should avoid testing i should not

00:13:48,959 --> 00:13:52,560
avoid testing code

00:13:50,639 --> 00:13:55,600
just because no other part of my

00:13:52,560 --> 00:13:57,360
application depends on it

00:13:55,600 --> 00:13:59,920
if you remember the example that i gave

00:13:57,360 --> 00:14:02,000
with the function that restores backup

00:13:59,920 --> 00:14:05,360
after a failure you can immediately see

00:14:02,000 --> 00:14:05,360
how it applies here

00:14:08,160 --> 00:14:12,079
the main purpose of unit tests is to

00:14:11,040 --> 00:14:14,240
identify

00:14:12,079 --> 00:14:15,839
incorrect behaviors of my code or

00:14:14,240 --> 00:14:19,279
regressions

00:14:15,839 --> 00:14:21,920
mutation testing is a technique

00:14:19,279 --> 00:14:22,880
that verifies the ability of your test

00:14:21,920 --> 00:14:26,160
to catch

00:14:22,880 --> 00:14:27,600
these mistakes it consists of changing

00:14:26,160 --> 00:14:29,120
your source code by introducing

00:14:27,600 --> 00:14:32,160
mutations

00:14:29,120 --> 00:14:33,920
this mutation should result in failures

00:14:32,160 --> 00:14:36,160
in your tests

00:14:33,920 --> 00:14:36,959
if a test does not fail and return

00:14:36,160 --> 00:14:40,480
returns are

00:14:36,959 --> 00:14:43,440
false positive this means that the tests

00:14:40,480 --> 00:14:44,240
are of poor quality and are not a good

00:14:43,440 --> 00:14:48,399
indicator

00:14:44,240 --> 00:14:52,079
of the core behavior of the application

00:14:48,399 --> 00:14:52,480
let's see an example here i have again

00:14:52,079 --> 00:14:55,839
my

00:14:52,480 --> 00:14:58,079
divide method we could add a mutation

00:14:55,839 --> 00:15:00,959
by changing the division operator to

00:14:58,079 --> 00:15:03,519
multiplication

00:15:00,959 --> 00:15:05,120
and now the method divide multiplies

00:15:03,519 --> 00:15:08,560
which is definitely not

00:15:05,120 --> 00:15:10,839
the expected behavior so i need my tests

00:15:08,560 --> 00:15:13,120
to tell me that a regression has been

00:15:10,839 --> 00:15:14,880
introduced

00:15:13,120 --> 00:15:16,959
by looking at the test i can see that

00:15:14,880 --> 00:15:20,000
what happens is

00:15:16,959 --> 00:15:23,199
one is multiplied by one the result

00:15:20,000 --> 00:15:24,839
is still one the test passes and the

00:15:23,199 --> 00:15:27,440
regression has me

00:15:24,839 --> 00:15:30,160
caught

00:15:27,440 --> 00:15:32,000
there are tools available for the most

00:15:30,160 --> 00:15:34,320
popular programming languages here for

00:15:32,000 --> 00:15:36,240
example i'm using pit test

00:15:34,320 --> 00:15:38,320
they can automatically introduce

00:15:36,240 --> 00:15:40,639
mutations run the tests

00:15:38,320 --> 00:15:41,360
and check that your tests are actually

00:15:40,639 --> 00:15:44,160
catching

00:15:41,360 --> 00:15:44,160
regressions

00:15:46,399 --> 00:15:50,320
and last i have a suggestion on how to

00:15:48,399 --> 00:15:52,959
use time more efficiently

00:15:50,320 --> 00:15:54,320
when writing unit tests i already

00:15:52,959 --> 00:15:56,560
mentioned trivia methods

00:15:54,320 --> 00:15:59,199
these pieces of code with very little

00:15:56,560 --> 00:16:01,199
risk connected to them

00:15:59,199 --> 00:16:03,199
the problem with writing tests for

00:16:01,199 --> 00:16:05,920
trivial methods is that they create

00:16:03,199 --> 00:16:08,720
a lot of noise unnecessarily in addition

00:16:05,920 --> 00:16:12,639
to costing time and resources

00:16:08,720 --> 00:16:15,680
in my example there are 97 methods

00:16:12,639 --> 00:16:17,839
31 of which are trivial

00:16:15,680 --> 00:16:19,440
i can still achieve coverage by testing

00:16:17,839 --> 00:16:22,480
them indirectly

00:16:19,440 --> 00:16:24,560
what i mean by that is that this

00:16:22,480 --> 00:16:26,079
trivial methods are typically invoked

00:16:24,560 --> 00:16:28,079
from other classes

00:16:26,079 --> 00:16:30,399
and by testing these classes all my

00:16:28,079 --> 00:16:32,079
trivial methods can be effectively

00:16:30,399 --> 00:16:33,680
covered without having to spend

00:16:32,079 --> 00:16:37,839
additional time

00:16:33,680 --> 00:16:37,839
writing tests for each trivial method

00:16:40,399 --> 00:16:44,800
we've seen how each one of these metrics

00:16:42,480 --> 00:16:45,440
can add to my understanding of the

00:16:44,800 --> 00:16:47,279
project

00:16:45,440 --> 00:16:48,480
and can point me in the right direction

00:16:47,279 --> 00:16:51,839
to identify

00:16:48,480 --> 00:16:52,720
and mitigate risk but what happens once

00:16:51,839 --> 00:16:56,720
i'm done

00:16:52,720 --> 00:16:59,040
and the risk in my project is low

00:16:56,720 --> 00:16:59,839
software projects are changing all the

00:16:59,040 --> 00:17:02,160
time

00:16:59,839 --> 00:17:04,640
new features are added some libraries or

00:17:02,160 --> 00:17:07,360
dependencies need to be updated

00:17:04,640 --> 00:17:07,919
and keeping on top of all these changes

00:17:07,360 --> 00:17:10,400
and

00:17:07,919 --> 00:17:11,679
writing new tests and adjusting the the

00:17:10,400 --> 00:17:15,280
existing ones

00:17:11,679 --> 00:17:15,679
is a lot of work or perhaps you realize

00:17:15,280 --> 00:17:18,160
that

00:17:15,679 --> 00:17:20,240
your project does not have enough tests

00:17:18,160 --> 00:17:24,000
and you're organizing with your team to

00:17:20,240 --> 00:17:26,160
work on it this blue cover

00:17:24,000 --> 00:17:28,400
automates unit test generation and

00:17:26,160 --> 00:17:30,400
maintenance for java projects

00:17:28,400 --> 00:17:34,080
and is available for free for use on

00:17:30,400 --> 00:17:34,080
finos open source projects

00:17:36,559 --> 00:17:40,720
this blue cover uses ai techniques to

00:17:38,720 --> 00:17:43,520
produce valuable tests

00:17:40,720 --> 00:17:45,039
that appear exactly like tests a human

00:17:43,520 --> 00:17:47,280
would write

00:17:45,039 --> 00:17:48,320
we find the pathways through your code

00:17:47,280 --> 00:17:51,039
simulate

00:17:48,320 --> 00:17:53,039
real-world inputs and generate tests

00:17:51,039 --> 00:17:56,640
that describe the current behavior

00:17:53,039 --> 00:17:59,440
of your code we also generate detailed

00:17:56,640 --> 00:18:00,799
reports that show you the potential

00:17:59,440 --> 00:18:03,440
risks

00:18:00,799 --> 00:18:05,200
as we've discussed in this talk there

00:18:03,440 --> 00:18:07,760
are several ways to use it

00:18:05,200 --> 00:18:09,760
there is a command line version that can

00:18:07,760 --> 00:18:12,320
be run from your terminal

00:18:09,760 --> 00:18:13,600
or it can be scripted and used inside

00:18:12,320 --> 00:18:15,600
any ci pipeline

00:18:13,600 --> 00:18:17,039
so that every time new code is committed

00:18:15,600 --> 00:18:19,919
to a repository

00:18:17,039 --> 00:18:20,640
cover can generate and maintain the unit

00:18:19,919 --> 00:18:24,480
tests

00:18:20,640 --> 00:18:26,480
for you automatically and if look over

00:18:24,480 --> 00:18:27,280
is also available as a plugin for

00:18:26,480 --> 00:18:30,880
intellij

00:18:27,280 --> 00:18:33,039
and it's incredibly easy to install and

00:18:30,880 --> 00:18:36,400
use

00:18:33,039 --> 00:18:38,720
now let's have a look at the sample test

00:18:36,400 --> 00:18:39,600
here we have a test generated by div

00:18:38,720 --> 00:18:42,960
blue cover

00:18:39,600 --> 00:18:43,440
that for a class that uploads documents

00:18:42,960 --> 00:18:46,880
to the

00:18:43,440 --> 00:18:47,760
aws cloud it's really important that

00:18:46,880 --> 00:18:49,360
developers can

00:18:47,760 --> 00:18:51,919
open this test and immediately

00:18:49,360 --> 00:18:54,880
understand exactly what's going on

00:18:51,919 --> 00:18:56,240
they don't have time to decipher garbage

00:18:54,880 --> 00:18:58,240
tests

00:18:56,240 --> 00:18:59,919
and as you can see this test is very

00:18:58,240 --> 00:19:02,160
readable

00:18:59,919 --> 00:19:04,400
if we cover creates a mock for the

00:19:02,160 --> 00:19:06,400
amazon s3 client

00:19:04,400 --> 00:19:08,160
initialize the objects needed for the

00:19:06,400 --> 00:19:10,880
tests

00:19:08,160 --> 00:19:12,400
defines the behavior of the mock and

00:19:10,880 --> 00:19:15,600
then goes on to creating

00:19:12,400 --> 00:19:16,720
all the necessary assertions to exercise

00:19:15,600 --> 00:19:20,960
the behavior

00:19:16,720 --> 00:19:23,919
of the method we can also see that

00:19:20,960 --> 00:19:25,520
upload file to bucket has some string

00:19:23,919 --> 00:19:28,480
parameters

00:19:25,520 --> 00:19:29,440
and we don't just use strings like full

00:19:28,480 --> 00:19:32,400
and bar

00:19:29,440 --> 00:19:33,919
or null values we use reinforcement

00:19:32,400 --> 00:19:36,559
learning techniques to

00:19:33,919 --> 00:19:38,240
to determine valid inputs and ensure

00:19:36,559 --> 00:19:41,039
that they are appropriately

00:19:38,240 --> 00:19:41,039
human readable

00:19:43,360 --> 00:19:46,480
so we've seen that the cover where the

00:19:45,120 --> 00:19:48,799
coverage falls short

00:19:46,480 --> 00:19:50,320
and that by using multiple metrics

00:19:48,799 --> 00:19:52,400
together we can achieve a better

00:19:50,320 --> 00:19:54,000
understanding of the code

00:19:52,400 --> 00:19:55,440
starting from the parts of our

00:19:54,000 --> 00:19:57,679
applications that

00:19:55,440 --> 00:19:59,200
we haven't covered inspecting issues

00:19:57,679 --> 00:20:01,440
with the stability

00:19:59,200 --> 00:20:02,720
making sure that the most complex parts

00:20:01,440 --> 00:20:05,200
of my code

00:20:02,720 --> 00:20:06,640
as well as the most depended on are well

00:20:05,200 --> 00:20:08,799
tested

00:20:06,640 --> 00:20:12,080
and using mutation score to verify the

00:20:08,799 --> 00:20:14,320
quality of our tests

00:20:12,080 --> 00:20:18,640
by doing this we are able to identify

00:20:14,320 --> 00:20:18,640
risks in our code and mitigate it

00:20:18,880 --> 00:20:21,919
we've seen how the cover can

00:20:20,320 --> 00:20:24,799
automatically generate

00:20:21,919 --> 00:20:25,440
generate unit tests for you and how it

00:20:24,799 --> 00:20:27,280
can

00:20:25,440 --> 00:20:30,080
guide you to improve your project

00:20:27,280 --> 00:20:30,080
testability

00:20:31,120 --> 00:20:34,559
i know there are a few minutes for

00:20:32,400 --> 00:20:36,960
questions if there's

00:20:34,559 --> 00:20:37,919
anything else you want to ask me in the

00:20:36,960 --> 00:20:40,080
next few days

00:20:37,919 --> 00:20:43,360
or if you want just to have a chat feel

00:20:40,080 --> 00:20:46,960
free to send me an email to lenriko.30

00:20:43,360 --> 00:20:47,919
at diffblue.com and you can get started

00:20:46,960 --> 00:20:50,000
with the

00:20:47,919 --> 00:20:51,600
deep blue cover for venus projects by

00:20:50,000 --> 00:20:54,880
visiting

00:20:51,600 --> 00:20:58,159
blue slash finos

00:20:54,880 --> 00:20:59,600
thanks for your attention and i'm happy

00:20:58,159 --> 00:21:03,039
to answer any question

00:20:59,600 --> 00:21:04,880
you may have

00:21:03,039 --> 00:21:06,480
enrique thank you very much for that

00:21:04,880 --> 00:21:08,400
presentation um

00:21:06,480 --> 00:21:10,559
it was extremely insightful thank you

00:21:08,400 --> 00:21:11,039
and that we do actually have a couple of

00:21:10,559 --> 00:21:14,240
um

00:21:11,039 --> 00:21:18,080
questions um the first coming from

00:21:14,240 --> 00:21:20,880
ross rhodes um who asks it sounds like

00:21:18,080 --> 00:21:22,240
um sorry my questions have just

00:21:20,880 --> 00:21:24,240
refreshed it sounds like diff

00:21:22,240 --> 00:21:25,360
blue cover is tailored specifically to

00:21:24,240 --> 00:21:28,840
java

00:21:25,360 --> 00:21:30,159
and he plans to broaden horizons to say

00:21:28,840 --> 00:21:33,520
python

00:21:30,159 --> 00:21:33,919
right um yes it is true this blue cover

00:21:33,520 --> 00:21:38,480
is

00:21:33,919 --> 00:21:41,679
tailored for java and um

00:21:38,480 --> 00:21:44,320
we kind of have a roadmap for expanding

00:21:41,679 --> 00:21:47,280
to other languages but

00:21:44,320 --> 00:21:48,000
we haven't published it yet python is

00:21:47,280 --> 00:21:50,000
particularly

00:21:48,000 --> 00:21:51,200
it's quite different from java so it's

00:21:50,000 --> 00:21:54,480
not at the top of

00:21:51,200 --> 00:21:58,480
our list i must say um

00:21:54,480 --> 00:22:02,320
but yeah who knows okay

00:21:58,480 --> 00:22:05,039
that's awesome um and uh manus also asks

00:22:02,320 --> 00:22:07,280
um does difficulty work for android java

00:22:05,039 --> 00:22:07,280
00:22:07,360 --> 00:22:15,760
um so diff blue

00:22:11,679 --> 00:22:18,799
div blue cover reads java byte code

00:22:15,760 --> 00:22:21,760
and as long as

00:22:18,799 --> 00:22:23,440
the language used for example kotlin

00:22:21,760 --> 00:22:26,320
generates java byte code

00:22:23,440 --> 00:22:28,240
then this blue cover can read it

00:22:26,320 --> 00:22:30,799
interpret it and generate tests

00:22:28,240 --> 00:22:32,880
but of course the tests at least right

00:22:30,799 --> 00:22:36,559
now they are they are generated

00:22:32,880 --> 00:22:40,080
in java so this is this is the catch

00:22:36,559 --> 00:22:42,960
um as i mentioned earlier there is

00:22:40,080 --> 00:22:44,799
a road map that that involves having uh

00:22:42,960 --> 00:22:46,240
expanding to other languages in the

00:22:44,799 --> 00:22:49,440
future but we are

00:22:46,240 --> 00:22:49,440
not quite there yet

00:22:49,840 --> 00:22:54,720
right awesome um before i ask any um

00:22:52,880 --> 00:22:57,200
further questions i'd like to actually

00:22:54,720 --> 00:22:57,679
announce um the finos t-shirt winners

00:22:57,200 --> 00:23:00,480
for

00:22:57,679 --> 00:23:01,120
people who are on the call right now so

00:23:00,480 --> 00:23:02,640
um

00:23:01,120 --> 00:23:05,280
the the people behind the scenes have

00:23:02,640 --> 00:23:08,080
actually picked two people from random

00:23:05,280 --> 00:23:09,840
um who registered for the event and i'm

00:23:08,080 --> 00:23:13,600
pleased to say that parvis

00:23:09,840 --> 00:23:16,640
aravi from intel um and robin wise

00:23:13,600 --> 00:23:19,760
from fidelity um will both be shipped

00:23:16,640 --> 00:23:22,640
um finos t-shirts um from the finis team

00:23:19,760 --> 00:23:23,600
and so no doubt um somebody will be in

00:23:22,640 --> 00:23:26,559
contact um

00:23:23,600 --> 00:23:28,799
with you in order to get your address

00:23:26,559 --> 00:23:30,960
okay amico if it's okay with you i've

00:23:28,799 --> 00:23:33,039
got another question to ask and if um

00:23:30,960 --> 00:23:34,159
uh people would also like to ask their

00:23:33,039 --> 00:23:36,960
questions in chat

00:23:34,159 --> 00:23:37,520
as well um we've got a few minutes um

00:23:36,960 --> 00:23:39,840
left

00:23:37,520 --> 00:23:41,840
in the q a so feel free to ping your

00:23:39,840 --> 00:23:44,720
your questions in chat

00:23:41,840 --> 00:23:46,720
um can i ask the question is there

00:23:44,720 --> 00:23:51,840
anything to be worried about when using

00:23:46,720 --> 00:23:51,840
ai to develop tests

00:23:53,360 --> 00:23:58,480
all right well yes

00:23:58,559 --> 00:24:04,400
ais are less deterministic than

00:24:02,240 --> 00:24:05,520
traditional code they use more advanced

00:24:04,400 --> 00:24:08,240
techniques so

00:24:05,520 --> 00:24:09,120
we have to make sure that we can

00:24:08,240 --> 00:24:11,200
reproduce

00:24:09,120 --> 00:24:12,480
every time step by step and have a

00:24:11,200 --> 00:24:16,080
reliable

00:24:12,480 --> 00:24:19,039
result every time of course at this blue

00:24:16,080 --> 00:24:22,640
we have a lot of effort

00:24:19,039 --> 00:24:23,200
into uh into making this blue cover our

00:24:22,640 --> 00:24:27,520
product

00:24:23,200 --> 00:24:27,520
as reliable as it can possibly get

00:24:28,720 --> 00:24:32,080
yes so i would say that this this is the

00:24:30,799 --> 00:24:34,640
main risk and and

00:24:32,080 --> 00:24:35,120
what we should be worried about talking

00:24:34,640 --> 00:24:40,480
about

00:24:35,120 --> 00:24:42,400
generic ai tools that can be used

00:24:40,480 --> 00:24:43,679
right that's great and um mana says

00:24:42,400 --> 00:24:46,080
thank you for your answer

00:24:43,679 --> 00:24:47,279
in chat um it's um it's our potential

00:24:46,080 --> 00:24:50,000
manners

00:24:47,279 --> 00:24:52,000
um okay so another question if software

00:24:50,000 --> 00:24:54,880
is developed by multiple engineers

00:24:52,000 --> 00:24:58,400
how do you ensure test cover is in place

00:24:54,880 --> 00:24:58,400
where different areas of the product

00:24:58,840 --> 00:25:03,240
interact

00:25:00,799 --> 00:25:04,480
all right if we are talking about

00:25:03,240 --> 00:25:07,760
dependencies

00:25:04,480 --> 00:25:10,159
and how um uh

00:25:07,760 --> 00:25:11,600
one object uses another let's say for

00:25:10,159 --> 00:25:14,559
four

00:25:11,600 --> 00:25:15,279
object-oriented languages at least unit

00:25:14,559 --> 00:25:18,320
tests

00:25:15,279 --> 00:25:20,960
can use

00:25:18,320 --> 00:25:22,400
each other each other's code for

00:25:20,960 --> 00:25:25,039
different parts of the application

00:25:22,400 --> 00:25:25,600
so in this case it would be covered

00:25:25,039 --> 00:25:28,559
there are

00:25:25,600 --> 00:25:30,720
other cases of course in which

00:25:28,559 --> 00:25:34,640
integration tests can

00:25:30,720 --> 00:25:37,600
help us testing the integration between

00:25:34,640 --> 00:25:37,600
different systems

00:25:39,200 --> 00:25:42,960
right that's thank you very much for

00:25:40,880 --> 00:25:45,760
answering that and then finally

00:25:42,960 --> 00:25:49,360
um can developers evaluate different

00:25:45,760 --> 00:25:52,960
software against their current projects

00:25:49,360 --> 00:25:55,600
of course so if we're talking about

00:25:52,960 --> 00:25:56,159
finos open source projects as i as i

00:25:55,600 --> 00:25:58,960
mentioned

00:25:56,159 --> 00:25:59,440
deep blue cover is is free for you and

00:25:58,960 --> 00:26:03,120
uh

00:25:59,440 --> 00:26:06,480
here at deaf double slash finals uh

00:26:03,120 --> 00:26:08,799
you will find out how to um

00:26:06,480 --> 00:26:10,080
to reach us and and see how you can

00:26:08,799 --> 00:26:13,200
start using

00:26:10,080 --> 00:26:16,400
this blue cover for other

00:26:13,200 --> 00:26:19,200
open source projects we have

00:26:16,400 --> 00:26:21,360
a community edition which is free it's a

00:26:19,200 --> 00:26:23,600
plugin for intellij

00:26:21,360 --> 00:26:24,880
you can find it in the intelligent

00:26:23,600 --> 00:26:29,279
marketplace

00:26:24,880 --> 00:26:29,279
and and you can start using it right

00:26:29,600 --> 00:26:33,039
that's brilliant so thank you so much

00:26:32,240 --> 00:26:35,440
enrique

00:26:33,039 --> 00:26:37,440
um for your presentation the code

00:26:35,440 --> 00:26:40,559
coverage paradox when 90

00:26:37,440 --> 00:26:42,480
isn't enough but less might be um

00:26:40,559 --> 00:26:45,200
so i would like to thank um enrique

00:26:42,480 --> 00:26:46,960
trenton uh development relations

00:26:45,200 --> 00:26:48,640
relations lead from differently for

00:26:46,960 --> 00:26:50,640
joining us this afternoon

00:26:48,640 --> 00:26:52,080
and also remind everyone to visit

00:26:50,640 --> 00:26:54,480
finnos.org to subscribe

00:26:52,080 --> 00:26:55,679
to our mailing lists um where you'll

00:26:54,480 --> 00:26:59,200
also hear about

00:26:55,679 --> 00:27:01,360
um other up-and-coming meetups as well

00:26:59,200 --> 00:27:02,400
and also if you're an engineer or a

00:27:01,360 --> 00:27:04,640
software developer

00:27:02,400 --> 00:27:05,520
feel free to head over to the fitness

00:27:04,640 --> 00:27:09,039
organization

00:27:05,520 --> 00:27:10,080
at github um dot com forward slash

00:27:09,039 --> 00:27:12,640
finnos

00:27:10,080 --> 00:27:13,919
uh to contribute or leverage finnos open

00:27:12,640 --> 00:27:15,760
source projects

00:27:13,919 --> 00:27:17,440
um and with that i'd like to say thank

00:27:15,760 --> 00:27:19,120
you very much enrique for being with us

00:27:17,440 --> 00:27:35,840
this afternoon

00:27:19,120 --> 00:27:35,840

YouTube URL: https://www.youtube.com/watch?v=daiq4cZlgv4


