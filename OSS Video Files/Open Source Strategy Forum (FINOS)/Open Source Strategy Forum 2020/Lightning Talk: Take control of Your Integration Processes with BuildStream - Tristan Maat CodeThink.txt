Title: Lightning Talk: Take control of Your Integration Processes with BuildStream - Tristan Maat CodeThink
Publication date: 2020-11-19
Playlist: Open Source Strategy Forum 2020
Description: 
	Lightning Talk: Take control of Your Integration Processes with BuildStream - Tristan Maat, CodeThink
Captions: 
	00:00:04,960 --> 00:00:07,759
hello hi

00:00:05,759 --> 00:00:09,760
i'm justin mudd and i work for good

00:00:07,759 --> 00:00:11,599
think i'd like to talk about

00:00:09,760 --> 00:00:14,400
build stream and how it can help keep

00:00:11,599 --> 00:00:16,080
control of the integration processes

00:00:14,400 --> 00:00:17,680
um we won't have time to follow many

00:00:16,080 --> 00:00:19,359
questions today because this is a

00:00:17,680 --> 00:00:21,039
lighting talk so please

00:00:19,359 --> 00:00:22,480
use my email to ask questions after the

00:00:21,039 --> 00:00:25,279
talk

00:00:22,480 --> 00:00:28,160
um today i'll quickly introduce you and

00:00:25,279 --> 00:00:29,920
explain to you what build stream is

00:00:28,160 --> 00:00:31,199
i'll show how it is currently actively

00:00:29,920 --> 00:00:32,880
in using projects

00:00:31,199 --> 00:00:35,200
i'll explain how i think the features

00:00:32,880 --> 00:00:37,360
shown are more broadly applicable

00:00:35,200 --> 00:00:38,719
i'll actually show you the tool running

00:00:37,360 --> 00:00:42,160
and i'll summarize

00:00:38,719 --> 00:00:44,480
quickly at the end right so let's get

00:00:42,160 --> 00:00:46,399
right into it also in a nutshell

00:00:44,480 --> 00:00:47,760
so build room is an integration tool in

00:00:46,399 --> 00:00:49,680
rough terms it's a

00:00:47,760 --> 00:00:51,360
way to model the whole system required

00:00:49,680 --> 00:00:53,840
to build one or more software products

00:00:51,360 --> 00:00:56,239
so simply put just build various

00:00:53,840 --> 00:00:57,840
packages together integration system

00:00:56,239 --> 00:00:59,840
it was originally known project now

00:00:57,840 --> 00:01:01,199
apache mostly coming out of the

00:00:59,840 --> 00:01:03,280
requirement of having lots of open

00:01:01,199 --> 00:01:06,880
source developers work on

00:01:03,280 --> 00:01:07,439
a build system on a an operating system

00:01:06,880 --> 00:01:09,200
that

00:01:07,439 --> 00:01:11,439
doesn't have specific source code

00:01:09,200 --> 00:01:13,760
anywhere

00:01:11,439 --> 00:01:14,640
um the gold goals for this were to build

00:01:13,760 --> 00:01:16,400
repeatedly

00:01:14,640 --> 00:01:18,640
uh we don't want to be unsure if a build

00:01:16,400 --> 00:01:20,159
would work if the code is okay

00:01:18,640 --> 00:01:22,080
we want to be able to produce distinct

00:01:20,159 --> 00:01:23,600
targets because we want to deploy in

00:01:22,080 --> 00:01:24,000
lots of different formats for example

00:01:23,600 --> 00:01:27,520
tars

00:01:24,000 --> 00:01:28,720
exe stock images we also want to stay

00:01:27,520 --> 00:01:30,159
transparent doing so

00:01:28,720 --> 00:01:31,920
because it should always be obvious what

00:01:30,159 --> 00:01:34,880
the system actually contains we

00:01:31,920 --> 00:01:35,920
can't not know what we're deploying or

00:01:34,880 --> 00:01:37,119
delivering

00:01:35,920 --> 00:01:39,280
and at the same time this should still

00:01:37,119 --> 00:01:42,960
be easy to use because we don't want

00:01:39,280 --> 00:01:45,040
developers to have to learn another tool

00:01:42,960 --> 00:01:46,880
the outcome of this was a young based

00:01:45,040 --> 00:01:47,840
language that models these software

00:01:46,880 --> 00:01:49,759
stacks

00:01:47,840 --> 00:01:51,840
a ci tool to actually consume this

00:01:49,759 --> 00:01:53,360
language as well as sandboxing and cloud

00:01:51,840 --> 00:01:56,960
build infrastructure to

00:01:53,360 --> 00:02:00,240
facilitate builds of this sort of stack

00:01:56,960 --> 00:02:02,560
right um this is all but abstract so let

00:02:00,240 --> 00:02:04,719
me get into a slightly more concrete

00:02:02,560 --> 00:02:06,000
example this is a little toy example of

00:02:04,719 --> 00:02:09,200
what i'd think a

00:02:06,000 --> 00:02:11,120
firefox build would look like

00:02:09,200 --> 00:02:13,200
and the boxes that you see here are

00:02:11,120 --> 00:02:15,599
elements

00:02:13,200 --> 00:02:17,040
which is the built-in terminology for

00:02:15,599 --> 00:02:18,160
something similar to district packages

00:02:17,040 --> 00:02:19,520
although they are a little bit more

00:02:18,160 --> 00:02:21,440
powerful

00:02:19,520 --> 00:02:22,879
and on the right here you can see my

00:02:21,440 --> 00:02:24,400
rough estimate as to where these

00:02:22,879 --> 00:02:26,239
packages belong

00:02:24,400 --> 00:02:28,239
so at the core of a build stream model

00:02:26,239 --> 00:02:30,879
you have a runtime

00:02:28,239 --> 00:02:32,080
usually which is just core utils with

00:02:30,879 --> 00:02:33,519
some compilers

00:02:32,080 --> 00:02:36,080
usually an image of the actual target

00:02:33,519 --> 00:02:37,280
system um on top of that you have

00:02:36,080 --> 00:02:39,200
libraries which are the direct

00:02:37,280 --> 00:02:41,360
dependencies of an application

00:02:39,200 --> 00:02:43,040
uh on top of that the application sits

00:02:41,360 --> 00:02:44,560
which needs these dependencies to build

00:02:43,040 --> 00:02:45,440
and on top of that we have the

00:02:44,560 --> 00:02:48,319
deployments which

00:02:45,440 --> 00:02:49,360
need the application to build now you

00:02:48,319 --> 00:02:52,560
might be wondering what

00:02:49,360 --> 00:02:55,040
build stream does with these elements so

00:02:52,560 --> 00:02:56,080
this is what an element looks like in

00:02:55,040 --> 00:02:59,200
build stream

00:02:56,080 --> 00:03:01,280
and bottom bit there this is the gtk

00:02:59,200 --> 00:03:03,680
element from the previous slide

00:03:01,280 --> 00:03:04,879
as you can see gtk is built with amazon

00:03:03,680 --> 00:03:06,720
build stream will figure out which

00:03:04,879 --> 00:03:09,519
commands to use for that

00:03:06,720 --> 00:03:11,120
uh the source code where'd you get it

00:03:09,519 --> 00:03:12,400
from us listed there as well as well as

00:03:11,120 --> 00:03:15,680
the dependencies which in this

00:03:12,400 --> 00:03:17,440
case just a runtime build stream with

00:03:15,680 --> 00:03:19,120
one of these elements it will download

00:03:17,440 --> 00:03:20,400
and verify the source code that we need

00:03:19,120 --> 00:03:21,920
for it

00:03:20,400 --> 00:03:24,400
uh it will prepare the build

00:03:21,920 --> 00:03:25,599
dependencies which just means recursive

00:03:24,400 --> 00:03:27,120
we follow the steps that you do for this

00:03:25,599 --> 00:03:30,159
element basically

00:03:27,120 --> 00:03:31,200
um it will prepare a sandbox and this is

00:03:30,159 --> 00:03:34,239
the important bit

00:03:31,200 --> 00:03:37,680
with kernel namespaces so

00:03:34,239 --> 00:03:39,040
this will ensure that only the specified

00:03:37,680 --> 00:03:40,400
dependencies are actually

00:03:39,040 --> 00:03:42,799
in the sandbox as well as the source

00:03:40,400 --> 00:03:44,319
code for the project with the sandbox we

00:03:42,799 --> 00:03:46,080
can then invoke the both commands for

00:03:44,319 --> 00:03:48,560
the build system

00:03:46,080 --> 00:03:49,120
and when we get a result we store that

00:03:48,560 --> 00:03:52,959
for

00:03:49,120 --> 00:03:54,000
later builds um this is still a bit

00:03:52,959 --> 00:03:56,959
abstract i'd say

00:03:54,000 --> 00:03:59,120
so let me just show you an actual

00:03:56,959 --> 00:04:01,680
project that uses build stream

00:03:59,120 --> 00:04:03,280
that is free desktop sdk uh free desktop

00:04:01,680 --> 00:04:06,720
ca is a completely separate project

00:04:03,280 --> 00:04:08,239
that tries to be the canonical sdk for

00:04:06,720 --> 00:04:09,439
the linux desktop

00:04:08,239 --> 00:04:11,120
naturally this means there's lots of

00:04:09,439 --> 00:04:12,560
packages for various different

00:04:11,120 --> 00:04:14,640
deployments

00:04:12,560 --> 00:04:16,400
um and they use build stream to

00:04:14,640 --> 00:04:19,919
facilitate this

00:04:16,400 --> 00:04:21,600
so this here is a diagram of one of the

00:04:19,919 --> 00:04:22,880
paths through this sdk system

00:04:21,600 --> 00:04:25,120
specifically the one that will build

00:04:22,880 --> 00:04:26,800
docker images

00:04:25,120 --> 00:04:28,160
and let's start at the bottom again so

00:04:26,800 --> 00:04:30,320
in this case the runtime

00:04:28,160 --> 00:04:32,160
is what they call the bootstrap and this

00:04:30,320 --> 00:04:34,880
is a stage three

00:04:32,160 --> 00:04:37,199
that is built entirely from scratch uh

00:04:34,880 --> 00:04:40,080
just core utils and gtc

00:04:37,199 --> 00:04:40,639
and this is built using stage one of an

00:04:40,080 --> 00:04:43,680
old

00:04:40,639 --> 00:04:45,120
version of this sdk i really like this

00:04:43,680 --> 00:04:46,960
example because it really just

00:04:45,120 --> 00:04:48,320
shows how much detail build stream can

00:04:46,960 --> 00:04:50,960
actually define

00:04:48,320 --> 00:04:52,639
even the very core runtime can be built

00:04:50,960 --> 00:04:55,120
inside build stream here

00:04:52,639 --> 00:04:56,720
and on top of that 3ds vista k builds

00:04:55,120 --> 00:04:58,160
various libraries for the platform and

00:04:56,720 --> 00:05:00,080
the sdk where the platform is just a

00:04:58,160 --> 00:05:02,000
normal deployment system and the sdk is

00:05:00,080 --> 00:05:03,919
the actual development system

00:05:02,000 --> 00:05:06,400
the platform contains things like ffmpeg

00:05:03,919 --> 00:05:10,000
or cool whereas the sdk

00:05:06,400 --> 00:05:11,199
contains things like cmake and gdb um on

00:05:10,000 --> 00:05:12,479
top of that we have the application

00:05:11,199 --> 00:05:14,800
layer which in this case is just

00:05:12,479 --> 00:05:16,880
collections of these packages and on the

00:05:14,800 --> 00:05:18,560
left side we have the platform

00:05:16,880 --> 00:05:20,560
which contains the usual packages that

00:05:18,560 --> 00:05:22,720
will actually be used to run

00:05:20,560 --> 00:05:24,639
and the sdk includes the platform to

00:05:22,720 --> 00:05:26,800
have all those packages as well as the

00:05:24,639 --> 00:05:27,520
developer tools which are then deployed

00:05:26,800 --> 00:05:29,919
into the

00:05:27,520 --> 00:05:32,639
various oci formats these are just

00:05:29,919 --> 00:05:36,160
docker images

00:05:32,639 --> 00:05:38,400
um so i will show you this

00:05:36,160 --> 00:05:41,360
actually building in a minute but first

00:05:38,400 --> 00:05:45,840
i'd actually like to talk about

00:05:41,360 --> 00:05:47,280
why we do all of this so

00:05:45,840 --> 00:05:49,280
the first advantage that i've already

00:05:47,280 --> 00:05:51,680
alluded to are the sandbox builds

00:05:49,280 --> 00:05:53,280
builds it means that we know the exact

00:05:51,680 --> 00:05:54,720
build provenance of the system

00:05:53,280 --> 00:05:57,680
this means we can't have something like

00:05:54,720 --> 00:06:00,000
an accidental open ssl compiled into our

00:05:57,680 --> 00:06:03,280
binaries

00:06:00,000 --> 00:06:04,080
um we also get a full transparent view

00:06:03,280 --> 00:06:06,319
of the software

00:06:04,080 --> 00:06:08,319
all its dependencies and deployments

00:06:06,319 --> 00:06:09,680
this is very nice to have

00:06:08,319 --> 00:06:10,960
because you can actually reason about

00:06:09,680 --> 00:06:12,319
the system you have and know what's

00:06:10,960 --> 00:06:14,400
inside of it

00:06:12,319 --> 00:06:16,240
and this is in the build stream world a

00:06:14,400 --> 00:06:18,000
hierarchical set of package definitions

00:06:16,240 --> 00:06:20,240
you can have similar things in docker

00:06:18,000 --> 00:06:22,080
files and such but i find the cmo format

00:06:20,240 --> 00:06:24,560
significantly easier to understand than

00:06:22,080 --> 00:06:26,560
comments in a docker file

00:06:24,560 --> 00:06:28,319
on top of that the build system is fully

00:06:26,560 --> 00:06:30,720
defined inside

00:06:28,319 --> 00:06:32,000
elements this means that there's no gold

00:06:30,720 --> 00:06:33,919
server that we need to

00:06:32,000 --> 00:06:35,199
maintain separately without any

00:06:33,919 --> 00:06:36,639
supervision

00:06:35,199 --> 00:06:38,000
rather the build system is defined and

00:06:36,639 --> 00:06:39,360
built from scratch every time that we

00:06:38,000 --> 00:06:41,120
built the software

00:06:39,360 --> 00:06:43,120
and the changes to it can simply be made

00:06:41,120 --> 00:06:45,280
with git commits with all usual tooling

00:06:43,120 --> 00:06:47,280
for that

00:06:45,280 --> 00:06:48,319
um on top of that we have a programmatic

00:06:47,280 --> 00:06:50,080
system definition

00:06:48,319 --> 00:06:51,919
this makes other features significantly

00:06:50,080 --> 00:06:53,440
more feasible such as build shells that

00:06:51,919 --> 00:06:55,199
allow developers to look inside

00:06:53,440 --> 00:06:56,720
what's happening inside the build

00:06:55,199 --> 00:06:57,759
cloud-based builds we can just push

00:06:56,720 --> 00:06:59,360
around images to

00:06:57,759 --> 00:07:01,759
actually make the individual steps of

00:06:59,360 --> 00:07:02,639
the build as well as automated license

00:07:01,759 --> 00:07:04,400
verification

00:07:02,639 --> 00:07:06,000
uh we have some example projects for

00:07:04,400 --> 00:07:08,240
this they mostly still work in progress

00:07:06,000 --> 00:07:08,240
though

00:07:08,479 --> 00:07:12,720
right i will show you build stream

00:07:10,960 --> 00:07:14,960
actually in action here

00:07:12,720 --> 00:07:17,440
this is the free desktop scale that was

00:07:14,960 --> 00:07:19,360
talking about earlier

00:07:17,440 --> 00:07:21,120
i'll show you here what we're building

00:07:19,360 --> 00:07:23,759
this is

00:07:21,120 --> 00:07:24,319
this command will load up all four

00:07:23,759 --> 00:07:26,960
elements

00:07:24,319 --> 00:07:28,840
and show the current state and you might

00:07:26,960 --> 00:07:30,080
notice that most of this is already

00:07:28,840 --> 00:07:31,759
cached

00:07:30,080 --> 00:07:33,599
uh built stream will remember over time

00:07:31,759 --> 00:07:36,000
what it has built previously and just

00:07:33,599 --> 00:07:37,520
keep those elements around and one of

00:07:36,000 --> 00:07:40,080
these elements needs to be built still

00:07:37,520 --> 00:07:42,160
before that we invert the build command

00:07:40,080 --> 00:07:44,319
button will start going on its merry way

00:07:42,160 --> 00:07:46,000
and actually pull the sources and

00:07:44,319 --> 00:07:47,280
dependencies together

00:07:46,000 --> 00:07:49,199
until eventually it finds out how to

00:07:47,280 --> 00:07:50,240
build a sandbox and it's quick and

00:07:49,199 --> 00:07:51,759
already starts running the build

00:07:50,240 --> 00:07:53,599
commands here

00:07:51,759 --> 00:07:55,599
and this will take a bit actually i

00:07:53,599 --> 00:07:58,960
skipped ahead in time a little bit there

00:07:55,599 --> 00:08:01,680
it completes its at which point it has

00:07:58,960 --> 00:08:03,039
its build artifacts somewhere deep in

00:08:01,680 --> 00:08:05,199
the file system

00:08:03,039 --> 00:08:06,479
we can check this out in the directory

00:08:05,199 --> 00:08:09,039
um

00:08:06,479 --> 00:08:10,840
i missed that there actually let me fix

00:08:09,039 --> 00:08:13,599
that

00:08:10,840 --> 00:08:15,360
and this will produce a directory that

00:08:13,599 --> 00:08:18,639
will will have to tell up so that

00:08:15,360 --> 00:08:21,599
um docker can actually load it

00:08:18,639 --> 00:08:27,360
we'll take a second yeah that's the

00:08:21,599 --> 00:08:28,800
guidance of that file

00:08:27,360 --> 00:08:30,560
unfortunately needs to consume it's

00:08:28,800 --> 00:08:35,039
alpha it can't just

00:08:30,560 --> 00:08:35,039
eat the raw directory we input that

00:08:36,159 --> 00:08:41,839
and in a second i will run it and prove

00:08:38,880 --> 00:08:41,839
to you that it actually works

00:08:42,159 --> 00:08:47,040
again there's lots of features here a

00:08:45,279 --> 00:08:49,680
lot of what's happening in here

00:08:47,040 --> 00:08:50,480
is not covered because it's difficult to

00:08:49,680 --> 00:08:53,120
cover everything

00:08:50,480 --> 00:08:53,120
in 10 minutes

00:08:53,680 --> 00:08:59,279
just showing off the actual file system

00:08:57,040 --> 00:09:00,959
uh that's the hostname inside the docker

00:08:59,279 --> 00:09:01,839
container which is different from my

00:09:00,959 --> 00:09:03,920
host hostname

00:09:01,839 --> 00:09:05,440
so you can see that it actually works

00:09:03,920 --> 00:09:08,720
nice

00:09:05,440 --> 00:09:10,480
all right in summary uh buildstream is a

00:09:08,720 --> 00:09:12,480
tool that helps us provide insight into

00:09:10,480 --> 00:09:14,000
what is included in the deployments even

00:09:12,480 --> 00:09:15,440
hidden details like the compilers of the

00:09:14,000 --> 00:09:17,040
dependencies

00:09:15,440 --> 00:09:18,880
it helps ensure a build environment

00:09:17,040 --> 00:09:20,720
closely matches our expectations

00:09:18,880 --> 00:09:22,640
and it has tons of other features please

00:09:20,720 --> 00:09:25,519
see documentation for this and

00:09:22,640 --> 00:09:27,839
well what i'd like from the audience

00:09:25,519 --> 00:09:30,720
here is please give milton a try

00:09:27,839 --> 00:09:32,480
supernova is coming out soon um we want

00:09:30,720 --> 00:09:33,040
use cases for this before the next table

00:09:32,480 --> 00:09:36,959
i hit

00:09:33,040 --> 00:09:38,320
stable api hits so get them in quickly

00:09:36,959 --> 00:09:48,080
feel free to ask me any questions via

00:09:38,320 --> 00:09:48,080

YouTube URL: https://www.youtube.com/watch?v=s758qQEkeFk


