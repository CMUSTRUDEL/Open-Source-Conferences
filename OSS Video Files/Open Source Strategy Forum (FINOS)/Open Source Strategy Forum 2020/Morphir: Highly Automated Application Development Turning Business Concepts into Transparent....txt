Title: Morphir: Highly Automated Application Development Turning Business Concepts into Transparent...
Publication date: 2020-11-19
Playlist: Open Source Strategy Forum 2020
Description: 
	Morphir: Highly Automated Application Development Turning Business Concepts into Transparent and Reliable Cloud Services - Stephen Goldbaum, Morgan Stanley & Adam Hurwitz, Microsoft
Captions: 
	00:00:06,799 --> 00:00:08,960
hi i'm stephen goldbaum from morgan

00:00:08,400 --> 00:00:10,320
stanley

00:00:08,960 --> 00:00:12,559
i'm here with adam hurwitz from

00:00:10,320 --> 00:00:14,320
microsoft we're here to talk about

00:00:12,559 --> 00:00:16,160
greatly increasing development

00:00:14,320 --> 00:00:19,359
efficiency with the combination

00:00:16,160 --> 00:00:21,279
of two powerful open source projects

00:00:19,359 --> 00:00:23,519
morpher which is a phenolized project

00:00:21,279 --> 00:00:23,840
recently contributed by morgan stanley

00:00:23,519 --> 00:00:26,400
and

00:00:23,840 --> 00:00:28,240
dapper which is a microsoft open source

00:00:26,400 --> 00:00:30,640
project

00:00:28,240 --> 00:00:31,519
so application development this is

00:00:30,640 --> 00:00:34,079
really where

00:00:31,519 --> 00:00:36,079
the um the developer provides real value

00:00:34,079 --> 00:00:39,040
and what is it they do they

00:00:36,079 --> 00:00:41,920
take complex business concepts and they

00:00:39,040 --> 00:00:44,239
turn them into complex computer concepts

00:00:41,920 --> 00:00:46,160
that's really the the bulk of what the

00:00:44,239 --> 00:00:46,960
value is that a developer does in an

00:00:46,160 --> 00:00:49,039
application

00:00:46,960 --> 00:00:50,480
development environment um of course and

00:00:49,039 --> 00:00:52,559
then we need to make it run

00:00:50,480 --> 00:00:53,920
so that's the most important thing is

00:00:52,559 --> 00:00:56,960
that it needs to run

00:00:53,920 --> 00:01:00,079
and so that's what we think of as

00:00:56,960 --> 00:01:03,359
the core developer value in the process

00:01:00,079 --> 00:01:03,359
of developing applications

00:01:03,440 --> 00:01:06,720
then we hit the enterprise and we find

00:01:05,600 --> 00:01:08,799
out that that's just a

00:01:06,720 --> 00:01:09,840
small fraction of what we need to do in

00:01:08,799 --> 00:01:11,360
terms of coding

00:01:09,840 --> 00:01:12,880
all of a sudden we go to the enterprise

00:01:11,360 --> 00:01:14,560
and we find out that there's probably

00:01:12,880 --> 00:01:16,240
some

00:01:14,560 --> 00:01:17,600
standard frameworks that we need to

00:01:16,240 --> 00:01:19,520
support we've got

00:01:17,600 --> 00:01:21,439
regulations we've got blueprints

00:01:19,520 --> 00:01:23,520
standards

00:01:21,439 --> 00:01:25,680
we need to register data here we need to

00:01:23,520 --> 00:01:27,280
register lineage

00:01:25,680 --> 00:01:30,159
there's all kinds of stuff that we need

00:01:27,280 --> 00:01:32,000
to do and it actually takes up

00:01:30,159 --> 00:01:33,280
probably the majority of the development

00:01:32,000 --> 00:01:36,479
time so

00:01:33,280 --> 00:01:38,560
what we consider as developer value is

00:01:36,479 --> 00:01:40,799
not what most developers spend most of

00:01:38,560 --> 00:01:44,079
their time on

00:01:40,799 --> 00:01:44,640
and that also has consequences in terms

00:01:44,079 --> 00:01:47,920
of

00:01:44,640 --> 00:01:51,280
well it's not that efficient anymore

00:01:47,920 --> 00:01:51,680
and it's risky because some studies show

00:01:51,280 --> 00:01:54,479
that

00:01:51,680 --> 00:01:56,479
for every thousand lines of computer

00:01:54,479 --> 00:01:57,200
code that a developer writes there's ten

00:01:56,479 --> 00:01:59,840
bugs

00:01:57,200 --> 00:02:01,119
and so with all that code that we're

00:01:59,840 --> 00:02:03,840
writing on top of the

00:02:01,119 --> 00:02:04,560
the business code um we're just adding

00:02:03,840 --> 00:02:08,319
more bugs

00:02:04,560 --> 00:02:10,800
and so that's that's a risk issue

00:02:08,319 --> 00:02:13,200
and so naturally you might think well

00:02:10,800 --> 00:02:15,120
what if what if we could go back to

00:02:13,200 --> 00:02:16,640
just concentrating on what's important

00:02:15,120 --> 00:02:18,160
back to turning the

00:02:16,640 --> 00:02:19,760
computer the business concepts into

00:02:18,160 --> 00:02:21,440
computer concepts

00:02:19,760 --> 00:02:22,800
and we could do something else with all

00:02:21,440 --> 00:02:23,440
these other things we can't make them

00:02:22,800 --> 00:02:24,800
disappear

00:02:23,440 --> 00:02:27,360
because they're important they need to

00:02:24,800 --> 00:02:27,920
be done um there's a couple ways that

00:02:27,360 --> 00:02:29,440
you can

00:02:27,920 --> 00:02:31,840
deal with it you can try to put it all

00:02:29,440 --> 00:02:34,879
behind framework so that puts a lot of

00:02:31,840 --> 00:02:36,239
of pressure on frameworks or maybe and

00:02:34,879 --> 00:02:38,400
this is what we try to do

00:02:36,239 --> 00:02:40,480
you can automate a lot of that and

00:02:38,400 --> 00:02:44,239
that's where morpher comes in

00:02:40,480 --> 00:02:47,200
so at its core morpher is a

00:02:44,239 --> 00:02:48,959
set of tools aimed at logic interchange

00:02:47,200 --> 00:02:51,519
and what that means is that

00:02:48,959 --> 00:02:52,720
we can define a set of logic put it into

00:02:51,519 --> 00:02:54,720
a data format

00:02:52,720 --> 00:02:57,360
in this case it's the morpher

00:02:54,720 --> 00:02:59,280
intermediary language or ir

00:02:57,360 --> 00:03:00,720
and once it's in a data format then we

00:02:59,280 --> 00:03:02,000
can do all kinds of things with it just

00:03:00,720 --> 00:03:05,200
like any other data

00:03:02,000 --> 00:03:06,879
so we can use that that data format to

00:03:05,200 --> 00:03:10,000
generate other code that runs in

00:03:06,879 --> 00:03:12,400
different runtime contexts or generate

00:03:10,000 --> 00:03:14,080
configuration and setup to the database

00:03:12,400 --> 00:03:15,360
and all these other kind of definitions

00:03:14,080 --> 00:03:16,879
that we might need

00:03:15,360 --> 00:03:18,640
um we don't have to stop there we can

00:03:16,879 --> 00:03:21,120
generate full applications

00:03:18,640 --> 00:03:23,040
so we don't have to just concentrate on

00:03:21,120 --> 00:03:24,560
the code we can get into everything else

00:03:23,040 --> 00:03:25,840
that makes an application

00:03:24,560 --> 00:03:27,760
and that's what we're really talking

00:03:25,840 --> 00:03:29,280
about in the enterprise

00:03:27,760 --> 00:03:30,959
and on top of that we can do things like

00:03:29,280 --> 00:03:33,200
generate documentation

00:03:30,959 --> 00:03:34,799
generate lineage generate you know all

00:03:33,200 --> 00:03:37,519
these other things that the enterprise

00:03:34,799 --> 00:03:37,519
ask us to do

00:03:38,560 --> 00:03:42,720
morpher project has a number of goals

00:03:40,640 --> 00:03:44,640
the primary goal is to make business

00:03:42,720 --> 00:03:46,799
logic a first-class asset

00:03:44,640 --> 00:03:48,239
something that's protected and stored

00:03:46,799 --> 00:03:49,440
separately from the rest of the

00:03:48,239 --> 00:03:52,159
application

00:03:49,440 --> 00:03:53,360
once it's in that format then we can do

00:03:52,159 --> 00:03:55,120
things like share it

00:03:53,360 --> 00:03:56,799
which is important if we want it to run

00:03:55,120 --> 00:03:58,480
in different contexts or maybe we want

00:03:56,799 --> 00:04:00,319
the same logic to run across different

00:03:58,480 --> 00:04:02,159
teams or maybe even different firms when

00:04:00,319 --> 00:04:04,319
we're talking about something like

00:04:02,159 --> 00:04:05,920
regulations we want to be able to

00:04:04,319 --> 00:04:07,120
translate it because

00:04:05,920 --> 00:04:08,560
we want it to run in different

00:04:07,120 --> 00:04:10,159
environments and in order to do that we

00:04:08,560 --> 00:04:10,959
need to translate it into different

00:04:10,159 --> 00:04:14,400
languages

00:04:10,959 --> 00:04:16,239
maybe different platforms uh

00:04:14,400 --> 00:04:18,160
documentation so we want to be able to

00:04:16,239 --> 00:04:19,359
take that logic and translate it into

00:04:18,160 --> 00:04:21,040
other tools

00:04:19,359 --> 00:04:23,360
we want to be able to store it because

00:04:21,040 --> 00:04:24,240
it is an asset right we don't want the

00:04:23,360 --> 00:04:25,919
um

00:04:24,240 --> 00:04:27,919
we don't want to have to risk rewriting

00:04:25,919 --> 00:04:29,199
it every time we want to change

00:04:27,919 --> 00:04:32,240
technologies

00:04:29,199 --> 00:04:33,919
and we all know that business evolves

00:04:32,240 --> 00:04:35,120
different than the technologies and they

00:04:33,919 --> 00:04:37,280
should be able to evolve

00:04:35,120 --> 00:04:38,960
independently and we want to be able to

00:04:37,280 --> 00:04:40,880
visualize it we want to

00:04:38,960 --> 00:04:42,880
give as much knowledge as possible we

00:04:40,880 --> 00:04:44,400
want new developers to be able to really

00:04:42,880 --> 00:04:47,759
understand the system

00:04:44,400 --> 00:04:49,840
uh without piecing through and diving

00:04:47,759 --> 00:04:52,160
into all kinds of

00:04:49,840 --> 00:04:52,960
hard to read code because it's mixed in

00:04:52,160 --> 00:04:56,000
with all

00:04:52,960 --> 00:04:57,280
all the persistence and messaging

00:04:56,000 --> 00:05:00,240
and all these other things that go into

00:04:57,280 --> 00:05:02,000
an application and

00:05:00,240 --> 00:05:03,759
some other goals that we have are that

00:05:02,000 --> 00:05:05,039
we want to increase efficiency with

00:05:03,759 --> 00:05:08,240
automation

00:05:05,039 --> 00:05:10,000
and that's that's a primary thing of

00:05:08,240 --> 00:05:11,840
what morpher does is that once you've

00:05:10,000 --> 00:05:14,000
got it in the stored format

00:05:11,840 --> 00:05:15,360
you can automate a whole lot of things

00:05:14,000 --> 00:05:18,240
not just code but

00:05:15,360 --> 00:05:19,199
documentation regulations audit all

00:05:18,240 --> 00:05:21,039
kinds of stuff

00:05:19,199 --> 00:05:22,320
we want to make sure it's correct so

00:05:21,039 --> 00:05:24,320
this is vital

00:05:22,320 --> 00:05:26,400
it's difficult to make sure that an

00:05:24,320 --> 00:05:27,520
application is correct and that is doing

00:05:26,400 --> 00:05:30,240
the right thing

00:05:27,520 --> 00:05:31,759
when the logic is all over the place or

00:05:30,240 --> 00:05:33,759
when the logic is

00:05:31,759 --> 00:05:35,600
mixed in with things like persistence

00:05:33,759 --> 00:05:39,759
and messaging and loading

00:05:35,600 --> 00:05:41,440
and so by consolidating on a model we're

00:05:39,759 --> 00:05:43,520
able to make it more correct

00:05:41,440 --> 00:05:44,960
and by consolidating on a functional

00:05:43,520 --> 00:05:48,320
model we're even

00:05:44,960 --> 00:05:49,759
able to do more than than just

00:05:48,320 --> 00:05:52,160
look at it and see that it's correct

00:05:49,759 --> 00:05:54,960
we're able to apply powerful tools

00:05:52,160 --> 00:05:56,560
to ensure that the model is more correct

00:05:54,960 --> 00:05:59,199
than we would usually be able to do with

00:05:56,560 --> 00:06:02,479
other programming languages

00:05:59,199 --> 00:06:03,360
it's important to note that bugs are a

00:06:02,479 --> 00:06:05,039
symptom

00:06:03,360 --> 00:06:06,639
they're a symptom of the code being

00:06:05,039 --> 00:06:09,360
wrong and

00:06:06,639 --> 00:06:11,199
testing and unit testing are great ways

00:06:09,360 --> 00:06:13,919
to handle that symptom

00:06:11,199 --> 00:06:15,520
it still means that we want to be able

00:06:13,919 --> 00:06:17,440
to take care of the cause

00:06:15,520 --> 00:06:18,639
and the causes we need to get the code

00:06:17,440 --> 00:06:21,199
right and so

00:06:18,639 --> 00:06:22,880
we want to be able to provide tools that

00:06:21,199 --> 00:06:24,880
enable us to do that

00:06:22,880 --> 00:06:26,720
we want to build knowledge as i said

00:06:24,880 --> 00:06:28,240
before we want new developers to be able

00:06:26,720 --> 00:06:29,919
to understand the system we also want

00:06:28,240 --> 00:06:30,639
the business users to understand the

00:06:29,919 --> 00:06:33,280
system

00:06:30,639 --> 00:06:34,319
and have confidence in the stem system

00:06:33,280 --> 00:06:36,880
and understand

00:06:34,319 --> 00:06:37,840
that what we have developed is actually

00:06:36,880 --> 00:06:39,759
what they wanted

00:06:37,840 --> 00:06:42,400
to do and there are a lot of things that

00:06:39,759 --> 00:06:44,800
we can do in terms of automating tools

00:06:42,400 --> 00:06:45,759
that allow the business users to have

00:06:44,800 --> 00:06:49,280
that confidence

00:06:45,759 --> 00:06:51,199
either in terms of of you know showing

00:06:49,280 --> 00:06:52,720
data flow through the system and why

00:06:51,199 --> 00:06:54,240
it's making decisions

00:06:52,720 --> 00:06:55,520
so not just that the data is going

00:06:54,240 --> 00:06:56,639
through the system and is making

00:06:55,520 --> 00:06:59,039
decisions but

00:06:56,639 --> 00:06:59,759
you know why did it make that decision

00:06:59,039 --> 00:07:02,400
and

00:06:59,759 --> 00:07:04,479
those are are important things for both

00:07:02,400 --> 00:07:06,960
the business and the technology

00:07:04,479 --> 00:07:08,080
finally we want a community we want to

00:07:06,960 --> 00:07:11,759
build a community

00:07:08,080 --> 00:07:13,919
we've realized that once people

00:07:11,759 --> 00:07:14,880
start to to use more for and understand

00:07:13,919 --> 00:07:17,599
it then

00:07:14,880 --> 00:07:19,039
they get a lot of creative solutions and

00:07:17,599 --> 00:07:20,800
some of those solutions

00:07:19,039 --> 00:07:23,120
always come back and everybody can take

00:07:20,800 --> 00:07:23,759
advantage of them and it just builds a

00:07:23,120 --> 00:07:26,319
much

00:07:23,759 --> 00:07:27,919
stronger and stronger ecosystem and that

00:07:26,319 --> 00:07:29,520
was part of the motivation of open

00:07:27,919 --> 00:07:31,120
sourcing it was that

00:07:29,520 --> 00:07:34,960
we felt that we could build a really

00:07:31,120 --> 00:07:34,960
really strong ecosystem around us

00:07:35,919 --> 00:07:40,319
all right so what is the flow of

00:07:38,160 --> 00:07:41,360
developing a more for application

00:07:40,319 --> 00:07:43,360
so the first thing you're going to want

00:07:41,360 --> 00:07:46,879
to do is get your business logic

00:07:43,360 --> 00:07:48,160
sound in in into the morpher format so

00:07:46,879 --> 00:07:50,960
the first thing you do is

00:07:48,160 --> 00:07:52,960
work with the business closely and come

00:07:50,960 --> 00:07:54,720
up with what the business model

00:07:52,960 --> 00:07:57,199
design is so we're going to design the

00:07:54,720 --> 00:07:58,879
model once we have that model

00:07:57,199 --> 00:08:00,560
then we're going to want to generate

00:07:58,879 --> 00:08:02,240
something so we probably want to

00:08:00,560 --> 00:08:03,840
generate documentation

00:08:02,240 --> 00:08:05,599
we probably want to generate some kind

00:08:03,840 --> 00:08:07,680
of registration into whatever

00:08:05,599 --> 00:08:09,520
systems our enterprise use and most

00:08:07,680 --> 00:08:10,960
importantly we want to generate

00:08:09,520 --> 00:08:12,560
onto the platform that this thing is

00:08:10,960 --> 00:08:14,560
going to run on or maybe multiple

00:08:12,560 --> 00:08:16,560
platforms but we want to generate that

00:08:14,560 --> 00:08:18,160
so imagine that it's running in a in a

00:08:16,560 --> 00:08:19,520
microservice

00:08:18,160 --> 00:08:21,840
environment we want to be able to

00:08:19,520 --> 00:08:23,199
generate the code that actually runs

00:08:21,840 --> 00:08:24,960
that microservice

00:08:23,199 --> 00:08:26,400
and then once we have that code

00:08:24,960 --> 00:08:28,160
obviously we need to run it

00:08:26,400 --> 00:08:29,759
and so that's basically the more for

00:08:28,160 --> 00:08:32,159
flow design

00:08:29,759 --> 00:08:33,760
the business logic generate the

00:08:32,159 --> 00:08:36,880
application

00:08:33,760 --> 00:08:38,880
run the application and so what does

00:08:36,880 --> 00:08:39,200
that look at like in the bigger scheme

00:08:38,880 --> 00:08:41,519
of

00:08:39,200 --> 00:08:43,440
software development so probably right

00:08:41,519 --> 00:08:46,080
now you have something like the uh

00:08:43,440 --> 00:08:47,600
the top flow where you work with the

00:08:46,080 --> 00:08:49,279
business to come up with the business

00:08:47,600 --> 00:08:51,360
specifications

00:08:49,279 --> 00:08:53,040
you architect a solution for that

00:08:51,360 --> 00:08:56,320
particular problem

00:08:53,040 --> 00:08:57,600
then you code up the the business logic

00:08:56,320 --> 00:08:58,880
into that

00:08:57,600 --> 00:09:01,040
particular solution that you've

00:08:58,880 --> 00:09:02,880
architected and then

00:09:01,040 --> 00:09:04,160
you've got the regular build test and

00:09:02,880 --> 00:09:06,880
the deploy cycle

00:09:04,160 --> 00:09:07,600
so the first three steps here are very

00:09:06,880 --> 00:09:10,240
manual

00:09:07,600 --> 00:09:11,200
in the current flow what we want to do

00:09:10,240 --> 00:09:14,480
is

00:09:11,200 --> 00:09:16,160
move that so that the we minimize as

00:09:14,480 --> 00:09:17,440
much manual effort as possible and we

00:09:16,160 --> 00:09:20,320
can do that by

00:09:17,440 --> 00:09:22,000
getting the business specs together and

00:09:20,320 --> 00:09:23,200
that's the only manual process if you

00:09:22,000 --> 00:09:24,480
think about it that should be the only

00:09:23,200 --> 00:09:26,480
manual process

00:09:24,480 --> 00:09:29,120
and then everything else after that we

00:09:26,480 --> 00:09:29,120
can automate

00:09:29,200 --> 00:09:32,959
so let's dig in and take a look at what

00:09:30,880 --> 00:09:35,760
that actually looks like

00:09:32,959 --> 00:09:36,560
we're going to take a sample common

00:09:35,760 --> 00:09:38,399
application

00:09:36,560 --> 00:09:39,760
so i think about a microservice or any

00:09:38,399 --> 00:09:42,160
kind of service that

00:09:39,760 --> 00:09:44,560
takes a request and does something with

00:09:42,160 --> 00:09:47,519
it so in this case we're going to have a

00:09:44,560 --> 00:09:49,920
a small microservice sample called books

00:09:47,519 --> 00:09:50,959
and records that takes a request to book

00:09:49,920 --> 00:09:54,480
a deal

00:09:50,959 --> 00:09:55,440
and run some logic to see whether we

00:09:54,480 --> 00:09:58,080
should book that deal

00:09:55,440 --> 00:09:59,839
and if so it books it and if not it

00:09:58,080 --> 00:10:02,079
rejects it for some reason so

00:09:59,839 --> 00:10:03,360
standard microservice architecture

00:10:02,079 --> 00:10:05,040
application

00:10:03,360 --> 00:10:06,880
so the thing we realize with a

00:10:05,040 --> 00:10:08,880
microservice is that

00:10:06,880 --> 00:10:10,800
you know this is actually a business

00:10:08,880 --> 00:10:11,440
process and it's a business process that

00:10:10,800 --> 00:10:14,480
follows

00:10:11,440 --> 00:10:16,000
a very standard pattern of it takes some

00:10:14,480 --> 00:10:18,560
input

00:10:16,000 --> 00:10:19,600
it runs some logic and then it produces

00:10:18,560 --> 00:10:21,519
some results

00:10:19,600 --> 00:10:23,760
and whenever we have a pattern like that

00:10:21,519 --> 00:10:26,079
that's a good case for automation

00:10:23,760 --> 00:10:27,760
and so let's look at that so in this

00:10:26,079 --> 00:10:30,480
case the request

00:10:27,760 --> 00:10:31,920
the input is that we either create a

00:10:30,480 --> 00:10:33,120
deal

00:10:31,920 --> 00:10:35,600
in which case we're trying to book it

00:10:33,120 --> 00:10:36,720
into our booking system or we close the

00:10:35,600 --> 00:10:38,320
deal in which case we're trying to

00:10:36,720 --> 00:10:42,800
remove it from our booking system

00:10:38,320 --> 00:10:42,800
in one way or the other and so

00:10:43,600 --> 00:10:49,040
how we remodel that so more for

00:10:46,640 --> 00:10:51,120
as i said before is using a open source

00:10:49,040 --> 00:10:53,839
programming language called elm

00:10:51,120 --> 00:10:55,519
and in elm that looks like this and it

00:10:53,839 --> 00:10:59,279
really reads as

00:10:55,519 --> 00:11:00,880
you're defining a union type where

00:10:59,279 --> 00:11:03,600
either of these could be a command you

00:11:00,880 --> 00:11:04,160
can have a command that either says open

00:11:03,600 --> 00:11:05,760
the deal

00:11:04,160 --> 00:11:09,279
with all the parameters that are

00:11:05,760 --> 00:11:12,560
required or close the deal

00:11:09,279 --> 00:11:15,920
so similarly we want to see the results

00:11:12,560 --> 00:11:17,360
right and so the specifications say

00:11:15,920 --> 00:11:18,959
that a client would want to see the

00:11:17,360 --> 00:11:21,440
results maybe there's somebody else that

00:11:18,959 --> 00:11:23,040
wants to receive the results so

00:11:21,440 --> 00:11:24,480
maybe we should we should do something

00:11:23,040 --> 00:11:26,880
with that as well but

00:11:24,480 --> 00:11:28,320
in the end you know the pattern is that

00:11:26,880 --> 00:11:31,440
we need to see a result

00:11:28,320 --> 00:11:33,600
and what that looks like in morpher is

00:11:31,440 --> 00:11:35,200
again another union type of here's the

00:11:33,600 --> 00:11:37,120
possible things that

00:11:35,200 --> 00:11:38,399
the outcomes that we could have for the

00:11:37,120 --> 00:11:40,320
inputs that we have

00:11:38,399 --> 00:11:42,160
so we can either open the deal and say

00:11:40,320 --> 00:11:42,959
that yeah it was successfully opened or

00:11:42,160 --> 00:11:45,440
closed

00:11:42,959 --> 00:11:47,519
or something was wrong and the request

00:11:45,440 --> 00:11:51,279
was invalid in which case we want to

00:11:47,519 --> 00:11:52,959
let them know that as well

00:11:51,279 --> 00:11:55,120
most microservices have some kind of

00:11:52,959 --> 00:11:57,600
state in between calls

00:11:55,120 --> 00:11:59,200
so this is common still a business model

00:11:57,600 --> 00:12:01,120
you know business model says that we

00:11:59,200 --> 00:12:03,760
want to keep some state

00:12:01,120 --> 00:12:05,680
and in this case the state is a bunch of

00:12:03,760 --> 00:12:08,720
deals or a list of deals

00:12:05,680 --> 00:12:10,320
and so in the deal

00:12:08,720 --> 00:12:12,480
these are the the parameters that we

00:12:10,320 --> 00:12:13,760
want to store this again we would work

00:12:12,480 --> 00:12:15,360
out with the business this is how we

00:12:13,760 --> 00:12:17,279
would model it in elm

00:12:15,360 --> 00:12:18,880
and in this case this is a record type

00:12:17,279 --> 00:12:20,880
which is you know standard data

00:12:18,880 --> 00:12:24,399
structure

00:12:20,880 --> 00:12:27,680
and then finally uh and not not

00:12:24,399 --> 00:12:30,480
the the least is the the logic

00:12:27,680 --> 00:12:32,000
so when we get a request and what do we

00:12:30,480 --> 00:12:34,480
need to do with it in our case

00:12:32,000 --> 00:12:36,079
we want to check that the price and the

00:12:34,480 --> 00:12:39,120
quantity are valid

00:12:36,079 --> 00:12:42,720
um so there's no specification on there

00:12:39,120 --> 00:12:44,880
uh that that says that

00:12:42,720 --> 00:12:46,720
you know these are these are they can

00:12:44,880 --> 00:12:49,920
only be less than zero

00:12:46,720 --> 00:12:51,360
or greater than zero and so um that's

00:12:49,920 --> 00:12:53,200
what our business object's doing

00:12:51,360 --> 00:12:54,720
so we kept it very simple for the

00:12:53,200 --> 00:12:56,720
example obviously

00:12:54,720 --> 00:12:59,200
most applications have much more complex

00:12:56,720 --> 00:13:01,680
business logic

00:12:59,200 --> 00:13:02,320
but that's it and so it's a standard

00:13:01,680 --> 00:13:05,200
pattern

00:13:02,320 --> 00:13:08,639
it's a request response state and then

00:13:05,200 --> 00:13:08,639
the logic for processing it

00:13:10,800 --> 00:13:14,240
all right so let's take a look at this

00:13:12,639 --> 00:13:16,079
code in an ide

00:13:14,240 --> 00:13:17,440
so one of the things i want to point out

00:13:16,079 --> 00:13:19,680
is that with with

00:13:17,440 --> 00:13:20,800
morpher we're really focused on

00:13:19,680 --> 00:13:23,680
domain-driven

00:13:20,800 --> 00:13:26,079
development or domain-driven design and

00:13:23,680 --> 00:13:29,440
one of the principles of that is that

00:13:26,079 --> 00:13:31,760
we use the business language when we

00:13:29,440 --> 00:13:34,160
make our technology so we want to use

00:13:31,760 --> 00:13:35,519
terms like price and quantity especially

00:13:34,160 --> 00:13:37,279
when we're talking with the business we

00:13:35,519 --> 00:13:38,480
would never say things like float or

00:13:37,279 --> 00:13:40,720
into the business

00:13:38,480 --> 00:13:41,600
and so we want to capture that in our

00:13:40,720 --> 00:13:45,279
model

00:13:41,600 --> 00:13:49,040
and we do this with the elm type aliases

00:13:45,279 --> 00:13:50,720
so that's very important and um

00:13:49,040 --> 00:13:52,240
you know we see all the rest here the

00:13:50,720 --> 00:13:53,760
the commands and the inputs and the

00:13:52,240 --> 00:13:56,079
outputs in the state

00:13:53,760 --> 00:13:58,000
and in the business logic and that's it

00:13:56,079 --> 00:14:00,560
that's the entire application

00:13:58,000 --> 00:14:02,800
so you'll notice nothing in here says

00:14:00,560 --> 00:14:03,680
that this is restful or using a message

00:14:02,800 --> 00:14:07,839
queue

00:14:03,680 --> 00:14:10,880
or if it's event sourced or using

00:14:07,839 --> 00:14:12,480
regular oltp and database transactions

00:14:10,880 --> 00:14:14,480
or any of that stuff

00:14:12,480 --> 00:14:16,160
none of that is in there and what that

00:14:14,480 --> 00:14:18,800
does is it makes it very easy

00:14:16,160 --> 00:14:19,279
to understand the code so we can see

00:14:18,800 --> 00:14:21,760
that

00:14:19,279 --> 00:14:23,440
this service is is really you know

00:14:21,760 --> 00:14:25,120
here's the inputs and outputs it's very

00:14:23,440 --> 00:14:28,240
easy to understand

00:14:25,120 --> 00:14:30,800
and it's often very difficult to do when

00:14:28,240 --> 00:14:32,800
you look at enterprise software because

00:14:30,800 --> 00:14:35,040
the code is scattered throughout

00:14:32,800 --> 00:14:36,399
different parts of the system

00:14:35,040 --> 00:14:38,480
and it's you know some of the codes in

00:14:36,399 --> 00:14:39,839
the database and some of the codes in ui

00:14:38,480 --> 00:14:41,120
code and some of the codes in the

00:14:39,839 --> 00:14:43,920
service

00:14:41,120 --> 00:14:46,560
and so if we can model it like this as

00:14:43,920 --> 00:14:48,560
the system gets bigger and more complex

00:14:46,560 --> 00:14:50,480
it's really nice to be able to look at

00:14:48,560 --> 00:14:52,959
the thing holistically and really

00:14:50,480 --> 00:14:53,920
understand what's going on without being

00:14:52,959 --> 00:14:56,079
distracted

00:14:53,920 --> 00:14:56,959
with oh it's got to save something here

00:14:56,079 --> 00:14:58,720
or it's you know

00:14:56,959 --> 00:14:59,920
loading stuff from the database there or

00:14:58,720 --> 00:15:01,440
any of that stuff that makes it

00:14:59,920 --> 00:15:05,040
difficult to understand

00:15:01,440 --> 00:15:06,560
and so that's a really important concept

00:15:05,040 --> 00:15:08,639
and so what we're going to do here is

00:15:06,560 --> 00:15:12,160
we're going to take this model

00:15:08,639 --> 00:15:13,920
and we're going to basically turn it

00:15:12,160 --> 00:15:17,120
into

00:15:13,920 --> 00:15:18,959
the morpher ir again we're using elm in

00:15:17,120 --> 00:15:20,880
this case to do the modeling

00:15:18,959 --> 00:15:22,639
and so what we're doing is we're parsing

00:15:20,880 --> 00:15:26,480
elm into

00:15:22,639 --> 00:15:28,880
the morpher ir and um

00:15:26,480 --> 00:15:30,720
just as a reminder that elm is not the

00:15:28,880 --> 00:15:32,720
only language we can do this with

00:15:30,720 --> 00:15:34,800
and so this is often interesting in

00:15:32,720 --> 00:15:37,920
terms of enterprises because

00:15:34,800 --> 00:15:39,360
often an enterprise has a lot of little

00:15:37,920 --> 00:15:42,560
bespoke

00:15:39,360 --> 00:15:45,839
dsls domain domain

00:15:42,560 --> 00:15:47,120
languages and you know little expression

00:15:45,839 --> 00:15:50,480
languages that pepper

00:15:47,120 --> 00:15:52,959
throughout the entire enterprise

00:15:50,480 --> 00:15:54,560
and they've kind of end of life nobody's

00:15:52,959 --> 00:15:57,040
really keeping them up but they're still

00:15:54,560 --> 00:15:58,240
making the application run and so nobody

00:15:57,040 --> 00:16:00,560
really knows what to do with that

00:15:58,240 --> 00:16:01,920
and so morpher is a is an interesting

00:16:00,560 --> 00:16:05,199
way of dealing with that

00:16:01,920 --> 00:16:07,040
and if you can parse those languages

00:16:05,199 --> 00:16:08,399
into the more for ir

00:16:07,040 --> 00:16:10,560
then you can take advantage of the

00:16:08,399 --> 00:16:12,480
morpher tools which means that you can

00:16:10,560 --> 00:16:14,959
transpile them into scala

00:16:12,480 --> 00:16:16,720
into elm into some other language and

00:16:14,959 --> 00:16:19,560
that gives a lifeline to those languages

00:16:16,720 --> 00:16:22,160
they're no longer stuck in a bespoke

00:16:19,560 --> 00:16:23,839
dsl um

00:16:22,160 --> 00:16:27,040
and so the next thing we're going to do

00:16:23,839 --> 00:16:30,480
is once we've got that ir

00:16:27,040 --> 00:16:32,240
we still want to make this thing run and

00:16:30,480 --> 00:16:34,880
what we're going to do is we're going to

00:16:32,240 --> 00:16:37,440
say well this time we want

00:16:34,880 --> 00:16:38,000
this to run in dapper so our output

00:16:37,440 --> 00:16:41,120
target

00:16:38,000 --> 00:16:41,920
is a adapter application and so we'll

00:16:41,120 --> 00:16:45,279
see that it's

00:16:41,920 --> 00:16:47,519
it's generating all this code uh

00:16:45,279 --> 00:16:48,880
it generated it over here and one of the

00:16:47,519 --> 00:16:50,560
things we notice here is that it's

00:16:48,880 --> 00:16:52,880
generating the maven

00:16:50,560 --> 00:16:54,480
as well so it's not just generating code

00:16:52,880 --> 00:16:57,279
it's generating the entire

00:16:54,480 --> 00:16:58,880
application um and so we can look at the

00:16:57,279 --> 00:17:00,880
code and we can see that everything

00:16:58,880 --> 00:17:02,399
that was in the model is now in case

00:17:00,880 --> 00:17:05,360
classes in scala so

00:17:02,399 --> 00:17:07,600
it's all there the logic is here so the

00:17:05,360 --> 00:17:10,720
you know the logic gets translated to

00:17:07,600 --> 00:17:12,640
and then all the dapper stuff

00:17:10,720 --> 00:17:15,199
is is in there as well so all the things

00:17:12,640 --> 00:17:18,480
that we would normally write by hand

00:17:15,199 --> 00:17:21,039
we are now generating and that

00:17:18,480 --> 00:17:23,679
is advantageous because it saves time

00:17:21,039 --> 00:17:27,120
and it saves bugs as we mentioned before

00:17:23,679 --> 00:17:30,000
the less human code is written

00:17:27,120 --> 00:17:32,960
the the less bugs will be produced so it

00:17:30,000 --> 00:17:36,320
saves us from possible bugs

00:17:32,960 --> 00:17:38,160
and it also makes things

00:17:36,320 --> 00:17:39,360
you know kind of future-proof and

00:17:38,160 --> 00:17:41,200
evolution-proof

00:17:39,360 --> 00:17:44,400
so if we wanted to do something like

00:17:41,200 --> 00:17:47,840
change the messaging format from jackson

00:17:44,400 --> 00:17:49,440
and jason to grpc we could do that

00:17:47,840 --> 00:17:50,960
and we wouldn't have to go back to the

00:17:49,440 --> 00:17:52,720
developers and tell them

00:17:50,960 --> 00:17:54,720
to do that or if we wanted to make this

00:17:52,720 --> 00:17:56,880
run you know

00:17:54,720 --> 00:17:57,760
dapper is a is a great runtime but a lot

00:17:56,880 --> 00:18:00,000
of this logic

00:17:57,760 --> 00:18:02,320
might need to run somewhere else like in

00:18:00,000 --> 00:18:05,200
the database if we're running reports

00:18:02,320 --> 00:18:06,559
and if we want to be able to to you know

00:18:05,200 --> 00:18:09,120
like replay something

00:18:06,559 --> 00:18:11,280
and see why it came to a conclusion you

00:18:09,120 --> 00:18:13,360
know why did it reject this thing

00:18:11,280 --> 00:18:15,679
well you know we can do things like make

00:18:13,360 --> 00:18:17,840
that run in the in the browser

00:18:15,679 --> 00:18:19,440
and and make that run in a different

00:18:17,840 --> 00:18:21,200
system at a different time using

00:18:19,440 --> 00:18:24,400
different technologies

00:18:21,200 --> 00:18:25,919
um and know that we get consistent

00:18:24,400 --> 00:18:28,080
results

00:18:25,919 --> 00:18:29,919
and uh you know that's that's obviously

00:18:28,080 --> 00:18:31,679
important too and

00:18:29,919 --> 00:18:34,080
you know we can also think about other

00:18:31,679 --> 00:18:35,360
ways we can use this so

00:18:34,080 --> 00:18:37,919
you know let's take something like

00:18:35,360 --> 00:18:40,080
contract driven development where

00:18:37,919 --> 00:18:42,000
um a contract-driven development is

00:18:40,080 --> 00:18:45,360
basically a way to do

00:18:42,000 --> 00:18:47,039
rest rest api testing where

00:18:45,360 --> 00:18:48,799
the the server doesn't have to be

00:18:47,039 --> 00:18:50,400
running you should be able to

00:18:48,799 --> 00:18:52,320
have some confidence that the client

00:18:50,400 --> 00:18:54,640
code you're writing is going to get

00:18:52,320 --> 00:18:55,440
the some certain results from the server

00:18:54,640 --> 00:18:58,320
without

00:18:55,440 --> 00:19:00,160
making the server be running and the way

00:18:58,320 --> 00:19:03,840
to do that is that you have these mock

00:19:00,160 --> 00:19:04,400
clients or mock servers that the clients

00:19:03,840 --> 00:19:06,160
call

00:19:04,400 --> 00:19:08,320
well imagine that if we could take the

00:19:06,160 --> 00:19:09,280
entire set of business logic that's in

00:19:08,320 --> 00:19:11,679
the server

00:19:09,280 --> 00:19:12,480
that the server is running and make that

00:19:11,679 --> 00:19:14,799
run

00:19:12,480 --> 00:19:16,400
on that mock or in the browser so then

00:19:14,799 --> 00:19:19,039
we could type in things

00:19:16,400 --> 00:19:21,039
and test our clients and immediately

00:19:19,039 --> 00:19:22,400
know the full range of results that

00:19:21,039 --> 00:19:24,880
we're going to get which is

00:19:22,400 --> 00:19:25,919
a lot more meaningful than just a couple

00:19:24,880 --> 00:19:27,840
test cases

00:19:25,919 --> 00:19:29,679
that that contract driven development

00:19:27,840 --> 00:19:32,880
does now so there's a whole lot of

00:19:29,679 --> 00:19:32,880
things that we can do with this

00:19:33,280 --> 00:19:37,039
and so in summary what have we done

00:19:34,960 --> 00:19:38,960
we've taken

00:19:37,039 --> 00:19:40,799
a pattern that's common in the business

00:19:38,960 --> 00:19:45,280
world inputs outputs

00:19:40,799 --> 00:19:47,760
some state we've converted that into

00:19:45,280 --> 00:19:48,559
computer concepts high-level computer

00:19:47,760 --> 00:19:50,080
concepts

00:19:48,559 --> 00:19:52,640
not you know how are these things going

00:19:50,080 --> 00:19:55,440
to run but computer concepts

00:19:52,640 --> 00:19:55,919
and then we've automated turning that

00:19:55,440 --> 00:19:58,960
into

00:19:55,919 --> 00:19:59,760
a running application and that

00:19:58,960 --> 00:20:02,000
application

00:19:59,760 --> 00:20:02,880
is is on dapper so we've automated the

00:20:02,000 --> 00:20:05,760
code

00:20:02,880 --> 00:20:06,320
the the json bindings the persistence

00:20:05,760 --> 00:20:08,960
the

00:20:06,320 --> 00:20:09,919
event mechanism and most importantly the

00:20:08,960 --> 00:20:11,919
dapper code

00:20:09,919 --> 00:20:14,240
and with that i'm going to pass this to

00:20:11,919 --> 00:20:16,400
adam and he's going to explain

00:20:14,240 --> 00:20:17,919
dapper and its advantages and how it

00:20:16,400 --> 00:20:20,240
works

00:20:17,919 --> 00:20:21,760
hey adam herwitz here with microsoft i'm

00:20:20,240 --> 00:20:22,720
an azure specialist in the financial

00:20:21,760 --> 00:20:26,400
services

00:20:22,720 --> 00:20:27,840
organization and you just heard from

00:20:26,400 --> 00:20:30,960
stephen goldbaum

00:20:27,840 --> 00:20:32,640
from morgan stanley and about the

00:20:30,960 --> 00:20:34,640
the morpher project and the first thing

00:20:32,640 --> 00:20:37,360
i want to do is i just want to commend

00:20:34,640 --> 00:20:38,159
morgan stanley absolutely in terms of

00:20:37,360 --> 00:20:40,240
open

00:20:38,159 --> 00:20:42,159
sourcing this project and taking their

00:20:40,240 --> 00:20:43,600
years of experience in ip and sharing it

00:20:42,159 --> 00:20:45,120
with the community

00:20:43,600 --> 00:20:46,320
i think there's a lot of benefit that

00:20:45,120 --> 00:20:47,200
other companies are going to get from

00:20:46,320 --> 00:20:49,360
this and

00:20:47,200 --> 00:20:50,720
you know we're definitely excited to see

00:20:49,360 --> 00:20:53,840
how this project

00:20:50,720 --> 00:20:57,039
develops as an open source project

00:20:53,840 --> 00:21:00,240
what i'm here to talk about is dapper uh

00:20:57,039 --> 00:21:02,480
you would have heard about that uh just

00:21:00,240 --> 00:21:05,600
now with uh from stephen

00:21:02,480 --> 00:21:07,679
that morpher the morpho project can work

00:21:05,600 --> 00:21:10,000
well in combination with dapper dapper

00:21:07,679 --> 00:21:12,240
is a microsoft open source project

00:21:10,000 --> 00:21:13,679
and so you know this is what we want to

00:21:12,240 --> 00:21:14,880
explore right now

00:21:13,679 --> 00:21:18,080
go a little deeper make sure you

00:21:14,880 --> 00:21:21,280
understand uh how this what this tool is

00:21:18,080 --> 00:21:22,520
and in the basics of how it works so let

00:21:21,280 --> 00:21:26,320
me just switch over

00:21:22,520 --> 00:21:28,559
here so dapper

00:21:26,320 --> 00:21:30,000
it's uh you know it's a cute name open

00:21:28,559 --> 00:21:30,799
source projects all have to have cute

00:21:30,000 --> 00:21:33,600
names now

00:21:30,799 --> 00:21:35,600
d-a-p-r and it's a distributed

00:21:33,600 --> 00:21:37,840
application runtime it's available

00:21:35,600 --> 00:21:39,840
you know you should go check it out uh

00:21:37,840 --> 00:21:42,960
dapper.io

00:21:39,840 --> 00:21:44,799
it's a open source project

00:21:42,960 --> 00:21:46,480
it's in github so this will click

00:21:44,799 --> 00:21:47,440
through to various repos that we have in

00:21:46,480 --> 00:21:49,760
github

00:21:47,440 --> 00:21:50,880
um and you know a distributed

00:21:49,760 --> 00:21:54,159
application runtime

00:21:50,880 --> 00:21:56,080
it the focus here is you know you're

00:21:54,159 --> 00:21:59,520
you're a developer

00:21:56,080 --> 00:22:00,799
and you are uh creating services that

00:21:59,520 --> 00:22:02,559
are part of

00:22:00,799 --> 00:22:04,080
um a distributed application and you

00:22:02,559 --> 00:22:06,000
know so many

00:22:04,080 --> 00:22:07,120
applications now are distributed

00:22:06,000 --> 00:22:08,559
certainly all the significant

00:22:07,120 --> 00:22:09,840
applications being built now

00:22:08,559 --> 00:22:11,679
the kind of complexity they have the

00:22:09,840 --> 00:22:15,120
number of people they have have the

00:22:11,679 --> 00:22:17,760
you know a microservice architecture um

00:22:15,120 --> 00:22:20,080
distributed out but you know such that

00:22:17,760 --> 00:22:23,440
multiple teams are working on this so

00:22:20,080 --> 00:22:26,159
dapper provides building blocks uh

00:22:23,440 --> 00:22:27,679
for you to use as a developer to build

00:22:26,159 --> 00:22:29,520
your application into it

00:22:27,679 --> 00:22:30,720
in an easier fashion without having to

00:22:29,520 --> 00:22:33,440
worry about

00:22:30,720 --> 00:22:35,600
um how those building blocks are

00:22:33,440 --> 00:22:37,840
implemented exactly

00:22:35,600 --> 00:22:40,080
and how those how they're provided to

00:22:37,840 --> 00:22:42,640
you and i'll get into more detail what i

00:22:40,080 --> 00:22:42,640
mean by that

00:22:43,600 --> 00:22:47,919
first i want to just uh say some of the

00:22:46,720 --> 00:22:50,080
high-level goals here

00:22:47,919 --> 00:22:54,000
okay so we have a developer wants to

00:22:50,080 --> 00:22:58,080
build a a distributed application a team

00:22:54,000 --> 00:22:59,840
so they're going to decide to use dapper

00:22:58,080 --> 00:23:01,679
they want to have best practice building

00:22:59,840 --> 00:23:02,720
blocks around building the application

00:23:01,679 --> 00:23:04,240
they want to use any language or

00:23:02,720 --> 00:23:05,600
framework this is an interesting point i

00:23:04,240 --> 00:23:08,480
just want to touch on

00:23:05,600 --> 00:23:09,360
because you know certainly in large uh

00:23:08,480 --> 00:23:11,440
systems there's

00:23:09,360 --> 00:23:13,039
multiple teams lots of teams maybe

00:23:11,440 --> 00:23:14,480
there's some legacy code as well for

00:23:13,039 --> 00:23:17,200
certain functionality

00:23:14,480 --> 00:23:18,480
uh perhaps and you know they're using

00:23:17,200 --> 00:23:19,120
different languages they're using

00:23:18,480 --> 00:23:21,200
different

00:23:19,120 --> 00:23:22,799
tech stacks and so it's very important

00:23:21,200 --> 00:23:23,919
that that is supported for a distributed

00:23:22,799 --> 00:23:25,360
application

00:23:23,919 --> 00:23:27,120
as is talked about it's open source we

00:23:25,360 --> 00:23:29,760
want the community to be involved

00:23:27,120 --> 00:23:30,240
uh and and and have it use standards and

00:23:29,760 --> 00:23:34,159
be

00:23:30,240 --> 00:23:37,200
open in terms of the api and consistent

00:23:34,159 --> 00:23:38,240
agnostic to cloud platform is important

00:23:37,200 --> 00:23:40,960
and edge

00:23:38,240 --> 00:23:41,919
um you know this should not be tied to

00:23:40,960 --> 00:23:43,600
um

00:23:41,919 --> 00:23:45,279
one cloud platform it should be

00:23:43,600 --> 00:23:46,000
something that you can run on premise

00:23:45,279 --> 00:23:48,799
cloud

00:23:46,000 --> 00:23:50,400
uh um really anywhere for it to really

00:23:48,799 --> 00:23:51,440
be usable in terms of your distributed

00:23:50,400 --> 00:23:52,880
application because that's what we're

00:23:51,440 --> 00:23:55,279
seeing we're seeing people

00:23:52,880 --> 00:23:56,880
um who want to make sure that they have

00:23:55,279 --> 00:23:57,919
uh you know their application running in

00:23:56,880 --> 00:24:00,640
multiple places

00:23:57,919 --> 00:24:02,000
often um and then of course extensible

00:24:00,640 --> 00:24:05,279
and plugable now

00:24:02,000 --> 00:24:06,720
you know pluggable gets into for

00:24:05,279 --> 00:24:08,559
in a second it'll be a little more clear

00:24:06,720 --> 00:24:10,880
what we mean by that these building

00:24:08,559 --> 00:24:12,559
blocks these services that you're using

00:24:10,880 --> 00:24:13,919
in your application for it to work

00:24:12,559 --> 00:24:16,640
there should be different ways to plug

00:24:13,919 --> 00:24:19,919
in different um implementations

00:24:16,640 --> 00:24:23,919
essentially and extensible you know

00:24:19,919 --> 00:24:26,000
instead of others um

00:24:23,919 --> 00:24:27,840
other companies other other developers

00:24:26,000 --> 00:24:29,200
wanting to

00:24:27,840 --> 00:24:30,559
work on the core functionality they

00:24:29,200 --> 00:24:32,559
should be able to add in other

00:24:30,559 --> 00:24:35,840
components and extend these

00:24:32,559 --> 00:24:38,799
the implementation of uh of the system

00:24:35,840 --> 00:24:39,919
uh really so let's start at the bottom

00:24:38,799 --> 00:24:41,600
here

00:24:39,919 --> 00:24:43,600
these building blocks i'm talking about

00:24:41,600 --> 00:24:44,320
what are you know let's talk about some

00:24:43,600 --> 00:24:46,559
of them

00:24:44,320 --> 00:24:47,600
um you know at a high level um i think

00:24:46,559 --> 00:24:49,440
they're relatively straightforward if

00:24:47,600 --> 00:24:51,279
you've been working on any distributed

00:24:49,440 --> 00:24:52,640
um applications of course you know let's

00:24:51,279 --> 00:24:53,760
just start this simple and i won't go

00:24:52,640 --> 00:24:55,039
through all these but

00:24:53,760 --> 00:24:57,760
the you know service to service

00:24:55,039 --> 00:25:00,960
invocation obvious you know initial

00:24:57,760 --> 00:25:03,520
uh problem to uh to deal with and solve

00:25:00,960 --> 00:25:05,760
you have multiple micro services that

00:25:03,520 --> 00:25:06,960
are operating as part of your system

00:25:05,760 --> 00:25:08,799
how do they talk to each other how do

00:25:06,960 --> 00:25:11,840
they call each other

00:25:08,799 --> 00:25:13,440
so that service to service invoking a

00:25:11,840 --> 00:25:14,799
function on a different service

00:25:13,440 --> 00:25:15,919
is something that dapper can provide

00:25:14,799 --> 00:25:17,679
that's one of these building blocks

00:25:15,919 --> 00:25:21,440
which is incredibly useful

00:25:17,679 --> 00:25:24,480
uh state management of course another

00:25:21,440 --> 00:25:26,559
you know foundational need

00:25:24,480 --> 00:25:27,520
for your application you need to save

00:25:26,559 --> 00:25:29,200
state

00:25:27,520 --> 00:25:31,120
and et cetera you can see across these

00:25:29,200 --> 00:25:34,320
different building blocks

00:25:31,120 --> 00:25:35,679
that you know we feel are generally the

00:25:34,320 --> 00:25:36,880
ones

00:25:35,679 --> 00:25:38,080
that you know that you need when you're

00:25:36,880 --> 00:25:39,360
building your application now we're

00:25:38,080 --> 00:25:41,120
going to be adding to these

00:25:39,360 --> 00:25:42,960
you can pick and choose which ones make

00:25:41,120 --> 00:25:44,720
sense to you you know one here for

00:25:42,960 --> 00:25:46,320
instance actors

00:25:44,720 --> 00:25:48,640
you know is that a programming model

00:25:46,320 --> 00:25:50,000
that you use you know if so then this is

00:25:48,640 --> 00:25:52,480
great some people do

00:25:50,000 --> 00:25:53,919
uh many people don't so that's just not

00:25:52,480 --> 00:25:54,720
you know a building block that you make

00:25:53,919 --> 00:25:56,480
use of

00:25:54,720 --> 00:25:59,200
now what's really important here to

00:25:56,480 --> 00:26:02,159
point out and notice

00:25:59,200 --> 00:26:03,840
is the api so i talked about let's see

00:26:02,159 --> 00:26:05,840
standards let's do opens do portable

00:26:03,840 --> 00:26:07,919
let's do consistent well look you know

00:26:05,840 --> 00:26:09,360
you have look at how the apis are

00:26:07,919 --> 00:26:13,039
talking it's http

00:26:09,360 --> 00:26:16,320
it's grpc you know anybody

00:26:13,039 --> 00:26:19,600
uh any system any application code

00:26:16,320 --> 00:26:20,400
uh techstack can speak http at this

00:26:19,600 --> 00:26:22,880
point

00:26:20,400 --> 00:26:24,240
uh certainly and you know they have grpc

00:26:22,880 --> 00:26:28,000
implementations uh

00:26:24,240 --> 00:26:31,200
uh certainly as well but http um by and

00:26:28,000 --> 00:26:33,840
large you know allows us to

00:26:31,200 --> 00:26:34,799
to say across the board any code or

00:26:33,840 --> 00:26:36,000
framework

00:26:34,799 --> 00:26:39,279
that you want to use that you want to

00:26:36,000 --> 00:26:42,080
bring so that is how your code

00:26:39,279 --> 00:26:43,919
calls into dapper into the dapper system

00:26:42,080 --> 00:26:45,919
into these building blocks

00:26:43,919 --> 00:26:46,960
is through that that api and just give

00:26:45,919 --> 00:26:49,360
you a little flavor here

00:26:46,960 --> 00:26:51,360
you know this error are some standard

00:26:49,360 --> 00:26:53,279
calls that you're going to make

00:26:51,360 --> 00:26:55,039
i'll get a little deeper into this now

00:26:53,279 --> 00:26:58,080
um

00:26:55,039 --> 00:27:00,880
you know the architecture in general

00:26:58,080 --> 00:27:03,520
uh is a sidecar architecture this is

00:27:00,880 --> 00:27:05,360
becoming more popular um it's certainly

00:27:03,520 --> 00:27:07,760
something more people have been uh you

00:27:05,360 --> 00:27:10,559
know uh thinking about talking about

00:27:07,760 --> 00:27:11,600
in the last i don't know a few years or

00:27:10,559 --> 00:27:15,279
so

00:27:11,600 --> 00:27:18,559
and so you can see here um now in this

00:27:15,279 --> 00:27:20,080
you know uh description of

00:27:18,559 --> 00:27:22,480
a system that uses dapper that's built

00:27:20,080 --> 00:27:24,960
with tapper you know you have two

00:27:22,480 --> 00:27:26,000
applications two services two micro

00:27:24,960 --> 00:27:28,480
services

00:27:26,000 --> 00:27:29,679
service code a service code b that make

00:27:28,480 --> 00:27:31,440
up your application

00:27:29,679 --> 00:27:34,080
and then of course there's a side car

00:27:31,440 --> 00:27:36,480
with each which is dapper

00:27:34,080 --> 00:27:39,200
right so there's a dapper daemon running

00:27:36,480 --> 00:27:42,559
um that associated with each one

00:27:39,200 --> 00:27:44,399
and the service code interacts with that

00:27:42,559 --> 00:27:44,799
sidecar and that's how they interact

00:27:44,399 --> 00:27:47,200
with

00:27:44,799 --> 00:27:49,120
the rest of the of the dapper system

00:27:47,200 --> 00:27:50,880
that might be calling each other right

00:27:49,120 --> 00:27:52,320
um and that's secure communication with

00:27:50,880 --> 00:27:54,880
mtls

00:27:52,320 --> 00:27:55,760
um or you know as i pointed out before

00:27:54,880 --> 00:27:59,039
state store

00:27:55,760 --> 00:27:59,760
pub sub now you'll see with the state

00:27:59,039 --> 00:28:01,520
store

00:27:59,760 --> 00:28:03,279
for instance you'll see a number of

00:28:01,520 --> 00:28:06,960
technologies there

00:28:03,279 --> 00:28:10,159
that are outlined as implementations

00:28:06,960 --> 00:28:11,919
of the state store that are used as the

00:28:10,159 --> 00:28:16,080
service that is

00:28:11,919 --> 00:28:18,720
that is being used as a safe store so um

00:28:16,080 --> 00:28:20,000
for the service code the application

00:28:18,720 --> 00:28:21,279
that you're writing

00:28:20,000 --> 00:28:22,559
you know that you need a state sort you

00:28:21,279 --> 00:28:24,159
know you need to store something in

00:28:22,559 --> 00:28:26,559
state retrieve it

00:28:24,159 --> 00:28:27,440
but for but as a developer you know you

00:28:26,559 --> 00:28:29,679
don't you don't

00:28:27,440 --> 00:28:31,679
it doesn't you don't care what store

00:28:29,679 --> 00:28:32,799
maybe is being used it's not necessarily

00:28:31,679 --> 00:28:34,559
something that you're thinking about you

00:28:32,799 --> 00:28:38,320
need to put it in you need to get it out

00:28:34,559 --> 00:28:40,080
and make use of it um and so for the the

00:28:38,320 --> 00:28:41,120
administrator for the operator of the

00:28:40,080 --> 00:28:43,039
system

00:28:41,120 --> 00:28:44,640
um they're gonna determine what is the

00:28:43,039 --> 00:28:45,279
best state store and they're going to

00:28:44,640 --> 00:28:47,600
plug it

00:28:45,279 --> 00:28:48,320
in they're going to configure dapper

00:28:47,600 --> 00:28:51,200
dapper

00:28:48,320 --> 00:28:52,080
to make use of that storage service in

00:28:51,200 --> 00:28:55,840
this case certainly

00:28:52,080 --> 00:28:57,840
you know redis azure cosmos db

00:28:55,840 --> 00:28:59,919
cassandra and this is where some of the

00:28:57,840 --> 00:29:02,399
extensibility comes in because

00:28:59,919 --> 00:29:03,600
there are some that are uh that are

00:29:02,399 --> 00:29:06,000
there that are where there are

00:29:03,600 --> 00:29:06,799
you know connectors into these storage

00:29:06,000 --> 00:29:09,120
services

00:29:06,799 --> 00:29:09,840
but of course this is an open source

00:29:09,120 --> 00:29:13,039
project

00:29:09,840 --> 00:29:14,480
and there are those who are you know

00:29:13,039 --> 00:29:16,480
they want to use a certain storage

00:29:14,480 --> 00:29:17,360
service here and they're writing that

00:29:16,480 --> 00:29:19,679
connector

00:29:17,360 --> 00:29:20,960
and that that that component to make

00:29:19,679 --> 00:29:22,080
sure that they can use it as a state

00:29:20,960 --> 00:29:24,399
store

00:29:22,080 --> 00:29:26,000
um and we're seeing quite a bit of that

00:29:24,399 --> 00:29:29,360
at this point which is great

00:29:26,000 --> 00:29:31,520
um pub sub same thing um

00:29:29,360 --> 00:29:33,600
you know as you can see listed here and

00:29:31,520 --> 00:29:35,360
so this is another level of detail of

00:29:33,600 --> 00:29:39,200
how the system works

00:29:35,360 --> 00:29:42,399
let me go you know a touch deeper now

00:29:39,200 --> 00:29:43,840
into hosting so

00:29:42,399 --> 00:29:45,760
right now you're saying well where can

00:29:43,840 --> 00:29:49,279
you run this how do you run this

00:29:45,760 --> 00:29:50,320
so you can run it locally

00:29:49,279 --> 00:29:52,480
what happens is you're going to get

00:29:50,320 --> 00:29:54,960
adapter cli you're going to

00:29:52,480 --> 00:29:56,559
install and run you can run locally

00:29:54,960 --> 00:29:58,480
mainly for development

00:29:56,559 --> 00:29:59,679
um and then the primary target at this

00:29:58,480 --> 00:30:02,799
point um

00:29:59,679 --> 00:30:04,000
is kubernetes kubernetes certainly has

00:30:02,799 --> 00:30:07,919
become

00:30:04,000 --> 00:30:08,880
you know the way in which enterprises uh

00:30:07,919 --> 00:30:12,080
certainly lots of

00:30:08,880 --> 00:30:15,360
companies lots of uh startups as well

00:30:12,080 --> 00:30:17,760
are choosing um to

00:30:15,360 --> 00:30:18,720
abstract uh infrastructure and manage

00:30:17,760 --> 00:30:21,039
infrastructure

00:30:18,720 --> 00:30:22,000
essentially um and manage their

00:30:21,039 --> 00:30:25,200
containers

00:30:22,000 --> 00:30:28,799
running on top of that uh infrastructure

00:30:25,200 --> 00:30:31,760
and so um that is our target

00:30:28,799 --> 00:30:33,520
uh primarily for for hosting and so what

00:30:31,760 --> 00:30:37,279
happens is you install

00:30:33,520 --> 00:30:39,600
some pods dapper pods into kubernetes

00:30:37,279 --> 00:30:41,360
um and those are the you know the the

00:30:39,600 --> 00:30:43,039
guts of the system if you will

00:30:41,360 --> 00:30:45,200
um and they do a variety of things

00:30:43,039 --> 00:30:47,360
including sidecar injector

00:30:45,200 --> 00:30:48,399
uh there's an operator there uh there's

00:30:47,360 --> 00:30:51,919
a pod that that

00:30:48,399 --> 00:30:54,799
manages the security um and

00:30:51,919 --> 00:30:56,080
so in kubernetes as you can see if you

00:30:54,799 --> 00:30:57,679
know i mean it has that interesting

00:30:56,080 --> 00:31:00,240
concept of the pod

00:30:57,679 --> 00:31:02,320
uh which can be one or more containers

00:31:00,240 --> 00:31:05,840
which is an interesting

00:31:02,320 --> 00:31:09,039
aspect of the of the service and

00:31:05,840 --> 00:31:09,840
uh of the system and so when you deploy

00:31:09,039 --> 00:31:13,440
your

00:31:09,840 --> 00:31:16,480
your application into a dapper enabled

00:31:13,440 --> 00:31:18,480
adapter or aware uh cluster and you say

00:31:16,480 --> 00:31:19,360
that this is using dapper the sidecar

00:31:18,480 --> 00:31:22,399
injector

00:31:19,360 --> 00:31:25,279
will put the dapper container

00:31:22,399 --> 00:31:26,640
the sidecar container into your pod and

00:31:25,279 --> 00:31:29,039
then your container

00:31:26,640 --> 00:31:30,399
can talk to it and it can interact

00:31:29,039 --> 00:31:32,240
through the configuration that you have

00:31:30,399 --> 00:31:35,440
done on the cluster

00:31:32,240 --> 00:31:38,559
with the other services the other

00:31:35,440 --> 00:31:40,960
the other services the other um

00:31:38,559 --> 00:31:42,240
building blocks uh you know for instance

00:31:40,960 --> 00:31:44,000
if we've been talking about

00:31:42,240 --> 00:31:46,159
pub sub state store certainly

00:31:44,000 --> 00:31:47,279
distributed tracing um

00:31:46,159 --> 00:31:49,519
one thing that's interesting about the

00:31:47,279 --> 00:31:52,960
system i'll just mention is

00:31:49,519 --> 00:31:53,840
observability um you know everything is

00:31:52,960 --> 00:31:56,559
running through

00:31:53,840 --> 00:31:58,399
dapper then certainly that gives you a

00:31:56,559 --> 00:31:59,440
very interesting way to observe what's

00:31:58,399 --> 00:32:01,919
happening

00:31:59,440 --> 00:32:02,799
in the system and so it connects with

00:32:01,919 --> 00:32:06,320
known

00:32:02,799 --> 00:32:09,279
uh logging um you know open telemetry

00:32:06,320 --> 00:32:09,760
prometheus grafana azure monitor uh for

00:32:09,279 --> 00:32:12,159
you

00:32:09,760 --> 00:32:13,360
to um understand what's happening in

00:32:12,159 --> 00:32:15,919
your system which is a real

00:32:13,360 --> 00:32:17,279
real real big benefit um as well and

00:32:15,919 --> 00:32:19,120
certainly kubernetes

00:32:17,279 --> 00:32:20,480
it's it's kubernetes whatever cloud

00:32:19,120 --> 00:32:24,000
on-prem et cetera

00:32:20,480 --> 00:32:29,760
and so um that is

00:32:24,000 --> 00:32:30,880
uh very uh very useful for people

00:32:29,760 --> 00:32:32,880
i'm going to show just a little bit of

00:32:30,880 --> 00:32:35,200
code before i close out here

00:32:32,880 --> 00:32:36,640
um just so you get a flavor again

00:32:35,200 --> 00:32:37,519
another level lower in terms of what i'm

00:32:36,640 --> 00:32:41,039
talking about so

00:32:37,519 --> 00:32:42,960
what i have here quickly is a yaml file

00:32:41,039 --> 00:32:43,760
to deploy so just so you know so you

00:32:42,960 --> 00:32:45,200
have your container with your

00:32:43,760 --> 00:32:46,880
application

00:32:45,200 --> 00:32:48,880
you deploy it into kubernetes you can

00:32:46,880 --> 00:32:51,039
see here i mean it's books and records

00:32:48,880 --> 00:32:53,120
which is one of the examples uh that's

00:32:51,039 --> 00:32:55,600
part of morpher

00:32:53,120 --> 00:32:56,240
and you know this is just a real vanilla

00:32:55,600 --> 00:32:58,399
simple

00:32:56,240 --> 00:32:59,519
uh example you can see it's just a you

00:32:58,399 --> 00:33:01,279
know there's a service there's a

00:32:59,519 --> 00:33:02,320
deployment

00:33:01,279 --> 00:33:06,559
and you can see here there's an

00:33:02,320 --> 00:33:09,279
annotation right so the annotation here

00:33:06,559 --> 00:33:10,480
lets the system know this is dapper

00:33:09,279 --> 00:33:13,360
enabled right

00:33:10,480 --> 00:33:14,320
uh the name of your support to call it

00:33:13,360 --> 00:33:16,000
on

00:33:14,320 --> 00:33:17,679
and there it is it's both we're going to

00:33:16,000 --> 00:33:19,440
call it books and record um

00:33:17,679 --> 00:33:20,880
and it's it's part of dapper so that

00:33:19,440 --> 00:33:23,840
sidecar is going to get

00:33:20,880 --> 00:33:24,240
uh injected and then you know otherwise

00:33:23,840 --> 00:33:26,320
again

00:33:24,240 --> 00:33:27,519
it's it's just your container this one

00:33:26,320 --> 00:33:28,720
happens to be an azure container

00:33:27,519 --> 00:33:32,960
registry

00:33:28,720 --> 00:33:36,320
um you know deploying uh two kubernetes

00:33:32,960 --> 00:33:39,120
your app very simple example

00:33:36,320 --> 00:33:39,840
um could look like this uh this is just

00:33:39,120 --> 00:33:43,279
a flask

00:33:39,840 --> 00:33:46,640
python you know few liner um

00:33:43,279 --> 00:33:49,279
where there's an add function right

00:33:46,640 --> 00:33:49,760
there's an add there's a route for add

00:33:49,279 --> 00:33:51,760
which is

00:33:49,760 --> 00:33:53,360
post it's not returning anything it's

00:33:51,760 --> 00:33:56,799
only returning a string right now

00:33:53,360 --> 00:34:00,080
but that could be your service and

00:33:56,799 --> 00:34:01,120
um the the another service wanting to

00:34:00,080 --> 00:34:02,320
call it

00:34:01,120 --> 00:34:04,480
you know the call would just look like

00:34:02,320 --> 00:34:07,519
this so what this call

00:34:04,480 --> 00:34:09,200
would be from let's say service b or

00:34:07,519 --> 00:34:10,320
some client perhaps of the books and

00:34:09,200 --> 00:34:13,520
record

00:34:10,320 --> 00:34:15,280
application service would be you know

00:34:13,520 --> 00:34:16,320
local host right so it's going to be

00:34:15,280 --> 00:34:19,440
hitting

00:34:16,320 --> 00:34:20,000
its own dapper side car on a port it's

00:34:19,440 --> 00:34:22,240
going to be

00:34:20,000 --> 00:34:23,359
invoking this is service invocation and

00:34:22,240 --> 00:34:27,119
then books and records

00:34:23,359 --> 00:34:29,119
is the id that we had in the yaml for

00:34:27,119 --> 00:34:30,560
that container and then the method it's

00:34:29,119 --> 00:34:33,520
going to call is

00:34:30,560 --> 00:34:34,320
add and it's this happens to be a post

00:34:33,520 --> 00:34:36,240
dash x

00:34:34,320 --> 00:34:38,000
this was part of like a you know a curl

00:34:36,240 --> 00:34:40,240
command

00:34:38,000 --> 00:34:41,599
to call that service so that's how it's

00:34:40,240 --> 00:34:44,639
going to look

00:34:41,599 --> 00:34:46,639
for get state let's start with save

00:34:44,639 --> 00:34:48,720
state

00:34:46,639 --> 00:34:50,879
so with save state you have your key

00:34:48,720 --> 00:34:53,760
value pairs

00:34:50,879 --> 00:34:55,359
uh formatted in this situation and

00:34:53,760 --> 00:34:59,359
you're just making a request

00:34:55,359 --> 00:35:01,359
of your dapper sidecar http

00:34:59,359 --> 00:35:03,839
on the port and this one is a state

00:35:01,359 --> 00:35:06,880
request

00:35:03,839 --> 00:35:09,680
and then to get that out just

00:35:06,880 --> 00:35:11,440
you know you you're now doing a get and

00:35:09,680 --> 00:35:12,000
for that key that you defined of where

00:35:11,440 --> 00:35:15,119
your

00:35:12,000 --> 00:35:16,800
your your state is being stored under as

00:35:15,119 --> 00:35:18,240
in the state store and then you get it

00:35:16,800 --> 00:35:20,880
back

00:35:18,240 --> 00:35:21,440
the last thing i just want to show here

00:35:20,880 --> 00:35:25,440
uh

00:35:21,440 --> 00:35:28,480
quickly um is in warfare

00:35:25,440 --> 00:35:30,400
this is integrated steven we've talked

00:35:28,480 --> 00:35:32,960
about this a bit

00:35:30,400 --> 00:35:33,760
but you know there's a stateful app that

00:35:32,960 --> 00:35:36,640
is defined

00:35:33,760 --> 00:35:38,480
for instance and you can see in this elm

00:35:36,640 --> 00:35:40,240
code that morpher uses

00:35:38,480 --> 00:35:41,599
you know it just says it's a stateful

00:35:40,240 --> 00:35:44,560
app

00:35:41,599 --> 00:35:45,119
so that any interaction with state you

00:35:44,560 --> 00:35:46,640
know

00:35:45,119 --> 00:35:48,880
what is so interesting that they have

00:35:46,640 --> 00:35:50,480
done that uh the morpher team stephen

00:35:48,880 --> 00:35:53,599
and attila and so on have

00:35:50,480 --> 00:35:55,200
have done is that it

00:35:53,599 --> 00:35:58,320
it is going to generate out that dapper

00:35:55,200 --> 00:36:01,280
code for you um so that when you

00:35:58,320 --> 00:36:03,280
you've modeled your application and then

00:36:01,280 --> 00:36:05,680
uh

00:36:03,280 --> 00:36:08,880
it will implement it in whichever

00:36:05,680 --> 00:36:11,440
language you choose java.net etc

00:36:08,880 --> 00:36:12,640
and we'll have the dapper code there so

00:36:11,440 --> 00:36:15,200
that when you deploy it

00:36:12,640 --> 00:36:16,240
uh into a cluster um you know it will be

00:36:15,200 --> 00:36:18,079
able to interact

00:36:16,240 --> 00:36:20,160
with the system uh however it's

00:36:18,079 --> 00:36:23,599
configured for whichever state store

00:36:20,160 --> 00:36:26,960
pub sub um etc

00:36:23,599 --> 00:36:29,280
and that's what i wanted to just go over

00:36:26,960 --> 00:36:30,320
i hope you're excited about dapper um

00:36:29,280 --> 00:36:32,880
it's a

00:36:30,320 --> 00:36:33,680
um we're very excited about it it's it's

00:36:32,880 --> 00:36:35,040
it's being

00:36:33,680 --> 00:36:37,359
received well by the community i think

00:36:35,040 --> 00:36:41,680
it's about 8 000 um

00:36:37,359 --> 00:36:44,160
uh likes on uh on github

00:36:41,680 --> 00:36:45,359
and it helps sorry stars on github

00:36:44,160 --> 00:36:46,960
plenty of forks

00:36:45,359 --> 00:36:48,560
a lot of community involvement there's

00:36:46,960 --> 00:36:49,440
regular community meetings that you can

00:36:48,560 --> 00:36:50,960
join

00:36:49,440 --> 00:36:53,280
i encourage you to check it out and of

00:36:50,960 --> 00:36:55,760
course uh encourage you

00:36:53,280 --> 00:36:57,520
uh to check out more for uh part of the

00:36:55,760 --> 00:37:00,960
part of finnos right now

00:36:57,520 --> 00:37:04,480
and consider it for uh for your project

00:37:00,960 --> 00:37:06,560
and uh thank you for listening

00:37:04,480 --> 00:37:09,040
okay thank you adam and so there we have

00:37:06,560 --> 00:37:11,680
it the combination of dapper and morpher

00:37:09,040 --> 00:37:13,359
with dapper you get a powerful run time

00:37:11,680 --> 00:37:14,560
it does a lot of the heavy lifting that

00:37:13,359 --> 00:37:17,359
we would normally

00:37:14,560 --> 00:37:18,720
have to do you know with with pulling in

00:37:17,359 --> 00:37:20,640
our own components

00:37:18,720 --> 00:37:22,480
and it does the the job of making this

00:37:20,640 --> 00:37:24,480
all work in a in a

00:37:22,480 --> 00:37:26,400
effective and efficient run time and

00:37:24,480 --> 00:37:28,480
then we have morpher

00:37:26,400 --> 00:37:30,400
and morpher enshrines the business

00:37:28,480 --> 00:37:31,760
knowledge into a data format so that

00:37:30,400 --> 00:37:34,079
it's protected from

00:37:31,760 --> 00:37:36,400
technology evolution it makes it

00:37:34,079 --> 00:37:38,160
evolution ready and that we can

00:37:36,400 --> 00:37:39,760
take that same business logic and make

00:37:38,160 --> 00:37:41,119
it run in different technologies as

00:37:39,760 --> 00:37:43,280
technology evolves

00:37:41,119 --> 00:37:45,119
it gives us the capabilities that are

00:37:43,280 --> 00:37:45,520
things that are outside of the run time

00:37:45,119 --> 00:37:48,800
like

00:37:45,520 --> 00:37:50,079
documentation live documentation maybe

00:37:48,800 --> 00:37:52,079
interactive documentation

00:37:50,079 --> 00:37:54,160
even so that you can audit you know how

00:37:52,079 --> 00:37:55,520
did the system come to this conclusion

00:37:54,160 --> 00:37:56,880
at this particular time

00:37:55,520 --> 00:37:58,880
so there's a lot of things you can do

00:37:56,880 --> 00:38:01,200
that are outside of a run time

00:37:58,880 --> 00:38:03,599
that we can still do with automation

00:38:01,200 --> 00:38:06,000
once we have that business logic

00:38:03,599 --> 00:38:07,280
for example we can use it to generate

00:38:06,000 --> 00:38:09,119
the full lineage

00:38:07,280 --> 00:38:11,359
so we can see that these inputs and

00:38:09,119 --> 00:38:13,839
these outputs in a calculation

00:38:11,359 --> 00:38:15,760
um you know here's the results that we

00:38:13,839 --> 00:38:16,320
got and here's exactly why we got those

00:38:15,760 --> 00:38:18,079
results

00:38:16,320 --> 00:38:20,880
so it's more than just watching the data

00:38:18,079 --> 00:38:24,000
flow it's watching the data flow

00:38:20,880 --> 00:38:26,880
with the whole reason that we got it and

00:38:24,000 --> 00:38:28,480
finally it makes the logic portable so

00:38:26,880 --> 00:38:30,000
you know logic is often

00:38:28,480 --> 00:38:31,760
used throughout the system or even

00:38:30,000 --> 00:38:33,520
across

00:38:31,760 --> 00:38:35,599
projects and even across firms in the

00:38:33,520 --> 00:38:38,000
case of something like regulations

00:38:35,599 --> 00:38:38,800
and so being able to define that logic

00:38:38,000 --> 00:38:41,520
in a

00:38:38,800 --> 00:38:43,599
common format that doesn't dictate a

00:38:41,520 --> 00:38:46,960
technology means that we can run it

00:38:43,599 --> 00:38:49,599
across projects across technologies and

00:38:46,960 --> 00:38:52,800
across firms

00:38:49,599 --> 00:38:54,480
so with that

00:38:52,800 --> 00:38:56,160
we have actually successfully done what

00:38:54,480 --> 00:39:00,880
we set out to do

00:38:56,160 --> 00:39:03,839
we've moved all that that manual process

00:39:00,880 --> 00:39:04,960
into just one manual step and the rest

00:39:03,839 --> 00:39:06,960
is automated

00:39:04,960 --> 00:39:08,320
what we didn't show you was that we've

00:39:06,960 --> 00:39:11,119
actually done it so that

00:39:08,320 --> 00:39:12,000
when you we tied into the github

00:39:11,119 --> 00:39:15,119
pipeline

00:39:12,000 --> 00:39:16,800
so that when a developer checks in

00:39:15,119 --> 00:39:19,839
the business model the pure business

00:39:16,800 --> 00:39:22,720
model it kicks off the entire process

00:39:19,839 --> 00:39:24,480
does the the build the testing and then

00:39:22,720 --> 00:39:25,520
the deployment so think of it as like

00:39:24,480 --> 00:39:27,520
one touch

00:39:25,520 --> 00:39:29,520
write your pure business logic check it

00:39:27,520 --> 00:39:31,520
in do a merge

00:39:29,520 --> 00:39:34,160
and it ends up in production in a

00:39:31,520 --> 00:39:34,160
running system

00:39:35,760 --> 00:39:42,400
so what's next both of these projects

00:39:38,960 --> 00:39:46,480
are by developers and forward developers

00:39:42,400 --> 00:39:48,079
and so both would love the contribution

00:39:46,480 --> 00:39:52,040
of the development community

00:39:48,079 --> 00:39:54,400
so anybody who's interested please go to

00:39:52,040 --> 00:39:54,960
morefor.os.org for the the more for

00:39:54,400 --> 00:39:58,000
project

00:39:54,960 --> 00:40:06,480
and dapper.io for the dapper project

00:39:58,000 --> 00:40:06,480

YouTube URL: https://www.youtube.com/watch?v=gaZdF3-6HL8


