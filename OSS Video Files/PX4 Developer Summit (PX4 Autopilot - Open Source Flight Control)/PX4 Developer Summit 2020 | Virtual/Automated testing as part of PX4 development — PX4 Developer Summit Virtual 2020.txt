Title: Automated testing as part of PX4 development â€” PX4 Developer Summit Virtual 2020
Publication date: 2020-07-21
Playlist: PX4 Developer Summit 2020 | Virtual
Description: 
	Title: Automated testing as part of PX4 development

Summary: Who this session is for: anybody who wants to contribute to, debug or maintain PX4.
This session motivates the use of automated testing in PX4, of all types, and explains which type of testing should be used in what circumstances.
It ends with a technical demo of how to implement Unit and Functional tests with GTest, as a kickoff point for new contributors.

The PX4 Developer Summit 2020 is the annual flagship conference hosted by Dronecode for the drone development community. https://bit.ly/2YXe4Rd
Captions: 
	00:00:00,000 --> 00:00:03,750
hey guys welcome back to the peach for

00:00:01,829 --> 00:00:06,779
developer summit I got your next speaker

00:00:03,750 --> 00:00:09,360
line up and the next presentation is

00:00:06,779 --> 00:00:12,480
called automated testing as part of the

00:00:09,360 --> 00:00:14,340
px4 development our speaker is called

00:00:12,480 --> 00:00:16,289
Julian Kent he is calling in from Zurich

00:00:14,340 --> 00:00:17,820
Switzerland he's the senior engineer at

00:00:16,289 --> 00:00:19,590
etherion where he coordinates the

00:00:17,820 --> 00:00:21,060
robotics focused activities balancing

00:00:19,590 --> 00:00:22,920
core future development with supporting

00:00:21,060 --> 00:00:24,960
authoring customer integration work he

00:00:22,920 --> 00:00:26,849
also lends his expertise in electronics

00:00:24,960 --> 00:00:28,460
software and hardware design around the

00:00:26,849 --> 00:00:30,960
company is needed jack-of-all-trades

00:00:28,460 --> 00:00:33,149
this session motivates the use of

00:00:30,960 --> 00:00:34,860
automated testing and B explore of all

00:00:33,149 --> 00:00:36,300
times then explain which types of

00:00:34,860 --> 00:00:38,579
testing should be used in what

00:00:36,300 --> 00:00:39,870
circumstances Julian will show you how

00:00:38,579 --> 00:00:42,629
to implement unique and functional

00:00:39,870 --> 00:00:44,070
testing wiki tests and as a kickoff

00:00:42,629 --> 00:00:50,940
point for any contributions

00:00:44,070 --> 00:00:53,489
please welcome Julian Kent thanks for

00:00:50,940 --> 00:00:54,719
the introduction everyone today we're

00:00:53,489 --> 00:00:57,840
going to be talking about automated

00:00:54,719 --> 00:00:59,910
testing as part of px4 development now I

00:00:57,840 --> 00:01:01,710
have a quick overview for you we're

00:00:59,910 --> 00:01:03,870
going to start with what is automated

00:01:01,710 --> 00:01:05,309
testing because of course this isn't a

00:01:03,870 --> 00:01:06,720
topic that's familiar to absolutely

00:01:05,309 --> 00:01:10,020
everyone

00:01:06,720 --> 00:01:11,220
next step is my motivation for automated

00:01:10,020 --> 00:01:14,670
testing and to me this is the most

00:01:11,220 --> 00:01:16,680
important part in px4 we now have the

00:01:14,670 --> 00:01:18,630
technical parts to get the automated

00:01:16,680 --> 00:01:20,250
testing working what we really need is

00:01:18,630 --> 00:01:22,200
the cultural stuff and this needs to

00:01:20,250 --> 00:01:25,110
come from everybody this is community

00:01:22,200 --> 00:01:29,970
members this is core developers this is

00:01:25,110 --> 00:01:32,549
REM everybody so for me this is the

00:01:29,970 --> 00:01:35,070
really the core part it's the extra work

00:01:32,549 --> 00:01:37,290
yes but why automate we're going to go

00:01:35,070 --> 00:01:39,060
through a few steps of how do you do

00:01:37,290 --> 00:01:41,880
this in practice and then I'm going to

00:01:39,060 --> 00:01:44,040
end off with a demo and hopefully that

00:01:41,880 --> 00:01:47,939
will work just like Jonases one did in

00:01:44,040 --> 00:01:51,259
the presentation just before so we'll

00:01:47,939 --> 00:01:53,520
start with what is automated testing and

00:01:51,259 --> 00:01:55,950
while I'm sure most people are familiar

00:01:53,520 --> 00:01:58,380
with the process of manual testing that

00:01:55,950 --> 00:02:00,000
is you write some code and afterwards

00:01:58,380 --> 00:02:02,399
you go and you check whether it works

00:02:00,000 --> 00:02:04,439
there's actually a lot of stuff here a

00:02:02,399 --> 00:02:06,390
lot of different layers of automated

00:02:04,439 --> 00:02:08,729
testing that you can do to make sure

00:02:06,390 --> 00:02:10,950
that your code really works and that end

00:02:08,729 --> 00:02:12,849
users get the best code and that you

00:02:10,950 --> 00:02:15,459
have the best developer experience

00:02:12,849 --> 00:02:17,739
now we're gonna the first one is unit

00:02:15,459 --> 00:02:19,299
testing and this is very low level one

00:02:17,739 --> 00:02:21,670
function at a time one class at a time

00:02:19,299 --> 00:02:23,409
you check that that has exactly the

00:02:21,670 --> 00:02:26,079
behavior that you wanted it to have and

00:02:23,409 --> 00:02:29,620
this is really for you for the developer

00:02:26,079 --> 00:02:31,719
to make sure that you got that you

00:02:29,620 --> 00:02:34,750
implemented the thing that you wanted to

00:02:31,719 --> 00:02:37,329
implement and that your idea is actually

00:02:34,750 --> 00:02:38,769
captured in the code the next step is

00:02:37,329 --> 00:02:40,329
functional testing and this is a higher

00:02:38,769 --> 00:02:43,540
level this is with multiple classes

00:02:40,329 --> 00:02:45,189
working together this is maybe passing

00:02:43,540 --> 00:02:47,260
messages backwards and forwards or one

00:02:45,189 --> 00:02:48,730
library calling it to another this is to

00:02:47,260 --> 00:02:50,769
make sure that they work together that

00:02:48,730 --> 00:02:52,419
the one library when it calls into the

00:02:50,769 --> 00:02:54,579
other gives it the right type of data or

00:02:52,419 --> 00:02:57,909
these kinds of things in px4 we have

00:02:54,579 --> 00:03:01,480
your messaging and this is included in

00:02:57,909 --> 00:03:03,519
the px4 functional testing libraries the

00:03:01,480 --> 00:03:05,769
next is integration testing and this is

00:03:03,519 --> 00:03:08,680
usually with a full system in web

00:03:05,769 --> 00:03:11,260
development this would be calling fake

00:03:08,680 --> 00:03:13,449
servers with with your actual data or

00:03:11,260 --> 00:03:14,650
putting your data onto a fake server and

00:03:13,449 --> 00:03:16,870
calling it and checking that it's

00:03:14,650 --> 00:03:20,560
working in px4 this is something like

00:03:16,870 --> 00:03:22,750
civil testing where you run your whole

00:03:20,560 --> 00:03:24,970
system in a simulation and basically

00:03:22,750 --> 00:03:26,889
this covers everything except for the

00:03:24,970 --> 00:03:33,370
specifics of running on the actual

00:03:26,889 --> 00:03:35,500
hardware target then finally we get to

00:03:33,370 --> 00:03:38,280
the manual testing which I think

00:03:35,500 --> 00:03:42,579
everybody is familiar with and that is

00:03:38,280 --> 00:03:44,939
the user this is in in the testing world

00:03:42,579 --> 00:03:48,040
known as user acceptance testing and

00:03:44,939 --> 00:03:51,040
this is where a real human tests it

00:03:48,040 --> 00:03:53,229
often on real hardware and especially

00:03:51,040 --> 00:03:55,540
for us with drone development if

00:03:53,229 --> 00:03:58,180
something goes wrong here this can end

00:03:55,540 --> 00:04:00,819
up being quite expensive if things you

00:03:58,180 --> 00:04:02,290
can end up with broken frames but even

00:04:00,819 --> 00:04:03,969
if something doesn't go horrific later

00:04:02,290 --> 00:04:06,069
on this is also expensive because it's

00:04:03,969 --> 00:04:08,250
taking up users time every single time

00:04:06,069 --> 00:04:11,379
something like this needs to be tracked

00:04:08,250 --> 00:04:13,509
so now that you have a brief background

00:04:11,379 --> 00:04:16,150
of what these different types of testing

00:04:13,509 --> 00:04:19,120
are that I'll be referring to let's go

00:04:16,150 --> 00:04:22,419
for my motivation about why it's so

00:04:19,120 --> 00:04:26,320
important so the first step is that

00:04:22,419 --> 00:04:29,560
development with testing is May

00:04:26,320 --> 00:04:31,600
unintuitive Li a lot faster and that is

00:04:29,560 --> 00:04:35,560
because you get feedback on whether your

00:04:31,600 --> 00:04:37,780
code works a lot sooner if you to go

00:04:35,560 --> 00:04:39,460
back to the previous example with if

00:04:37,780 --> 00:04:41,680
your code goes all the way to a user

00:04:39,460 --> 00:04:44,280
before you know if it works that can

00:04:41,680 --> 00:04:47,620
take days to get a response or months or

00:04:44,280 --> 00:04:49,990
something like this whereas if an

00:04:47,620 --> 00:04:56,200
automated test runs you can have your

00:04:49,990 --> 00:04:57,940
results in seconds now if this can

00:04:56,200 --> 00:05:00,970
actually have a big improvement for

00:04:57,940 --> 00:05:02,950
developers as well from another

00:05:00,970 --> 00:05:04,780
perspective in that you haven't

00:05:02,950 --> 00:05:07,870
forgotten what you're working on and all

00:05:04,780 --> 00:05:11,410
the very low-level details when you get

00:05:07,870 --> 00:05:12,700
to the automated test when you get to

00:05:11,410 --> 00:05:16,300
the results of whether your tests are

00:05:12,700 --> 00:05:18,490
working so this means that you have a

00:05:16,300 --> 00:05:20,350
full in your mind every little detail

00:05:18,490 --> 00:05:22,660
and when you get that feedback that

00:05:20,350 --> 00:05:24,310
there's a bug here or it's maybe it's

00:05:22,660 --> 00:05:26,500
not a bug but maybe it's not doing

00:05:24,310 --> 00:05:29,830
exactly what you expected it to do you

00:05:26,500 --> 00:05:32,650
can have your full mental model is still

00:05:29,830 --> 00:05:35,710
there and you get really quick feedback

00:05:32,650 --> 00:05:37,810
cycles this makes less bugs get

00:05:35,710 --> 00:05:42,420
introduced as well during the bug fixing

00:05:37,810 --> 00:05:45,730
and it's less development time in total

00:05:42,420 --> 00:05:48,010
so the next one is let's try to split

00:05:45,730 --> 00:05:49,810
human work in computer work and make

00:05:48,010 --> 00:05:51,850
computers do work that computers are

00:05:49,810 --> 00:05:54,040
good at and humans do work the humans

00:05:51,850 --> 00:05:55,960
are good at so computers are good at

00:05:54,040 --> 00:05:58,240
running code and they're good at

00:05:55,960 --> 00:06:00,010
comparing outputs humans are good at

00:05:58,240 --> 00:06:02,350
pattern matching creative thinking and

00:06:00,010 --> 00:06:04,390
problem solving so if you're thinking

00:06:02,350 --> 00:06:07,180
about checking whether code runs

00:06:04,390 --> 00:06:09,580
correctly this is very obviously a

00:06:07,180 --> 00:06:11,110
computer task it's you rerun the code

00:06:09,580 --> 00:06:13,240
and then you compare the output with the

00:06:11,110 --> 00:06:14,820
previous time the code ran or with what

00:06:13,240 --> 00:06:17,590
the specifications were for the code

00:06:14,820 --> 00:06:19,780
whereas for humans the designing the

00:06:17,590 --> 00:06:20,800
tests is writing specifications and

00:06:19,780 --> 00:06:24,390
writing code and this is things

00:06:20,800 --> 00:06:27,190
something that computers are not good at

00:06:24,390 --> 00:06:29,800
next reason for automated testing is

00:06:27,190 --> 00:06:33,340
that tested code is reusable code if you

00:06:29,800 --> 00:06:35,620
have code that is completely untested or

00:06:33,340 --> 00:06:38,800
that tests are only done at a very high

00:06:35,620 --> 00:06:40,169
level then you cannot reuse the lower

00:06:38,800 --> 00:06:42,719
components of that code because

00:06:40,169 --> 00:06:45,330
they'll probably not be architected in a

00:06:42,719 --> 00:06:46,919
way that allows them to be run in

00:06:45,330 --> 00:06:50,310
isolation without all of the pieces

00:06:46,919 --> 00:06:52,770
around them so if you only have civil

00:06:50,310 --> 00:06:54,509
tests then this means that you'll

00:06:52,770 --> 00:06:56,879
probably only be able to reuse your code

00:06:54,509 --> 00:06:59,099
across different vehicles and this means

00:06:56,879 --> 00:07:01,830
taking the entire flight controller as a

00:06:59,099 --> 00:07:03,749
stack whereas if you have unit tests if

00:07:01,830 --> 00:07:05,430
you have functional tests you can take

00:07:03,749 --> 00:07:07,830
whatever those units or whatever those

00:07:05,430 --> 00:07:10,650
functional functions are and pull them

00:07:07,830 --> 00:07:12,990
into other areas and this means that you

00:07:10,650 --> 00:07:16,529
can and this is entirely due to the way

00:07:12,990 --> 00:07:18,960
because the tests point to the code so

00:07:16,529 --> 00:07:20,759
you have to have your code architected

00:07:18,960 --> 00:07:23,699
in a way that multiple things point to

00:07:20,759 --> 00:07:25,620
it via a well defined API that your

00:07:23,699 --> 00:07:29,039
tests actually specify what the behavior

00:07:25,620 --> 00:07:30,990
is so this means that the interface of

00:07:29,039 --> 00:07:34,020
the tests and the interface of the

00:07:30,990 --> 00:07:37,139
system is very similar and so this works

00:07:34,020 --> 00:07:40,229
quite well a next step is low-risk

00:07:37,139 --> 00:07:42,779
refactoring if you have already quite a

00:07:40,229 --> 00:07:44,639
few tests in your system then if you

00:07:42,779 --> 00:07:47,339
refactor and you broke something

00:07:44,639 --> 00:07:49,770
probably a test will fail and this is

00:07:47,339 --> 00:07:51,300
much quicker to find out then putting it

00:07:49,770 --> 00:07:55,379
on a vehicle and trying to fly it and

00:07:51,300 --> 00:07:57,719
then the vehicle crashes and then this

00:07:55,379 --> 00:08:01,469
is more to make the maintainers lives

00:07:57,719 --> 00:08:03,180
easier if you have untested code that is

00:08:01,469 --> 00:08:05,580
under active development you end up with

00:08:03,180 --> 00:08:07,500
more bugs if you have untested code that

00:08:05,580 --> 00:08:08,969
is not under active development this

00:08:07,500 --> 00:08:10,860
code is hard to maintain because it's

00:08:08,969 --> 00:08:12,620
probably not specified or documented

00:08:10,860 --> 00:08:14,879
very well exactly how it should behave

00:08:12,620 --> 00:08:16,620
whereas if it was tested it would be

00:08:14,879 --> 00:08:18,300
easy to maintain because the tests say

00:08:16,620 --> 00:08:20,310
exactly what the code is meant to do and

00:08:18,300 --> 00:08:23,370
if you had tested code that's under

00:08:20,310 --> 00:08:25,979
active development fewer new bugs and

00:08:23,370 --> 00:08:29,569
then when we come to industry outcomes

00:08:25,979 --> 00:08:32,849
on the right I've got here a study from

00:08:29,569 --> 00:08:34,409
1985 and I've actually less left out a

00:08:32,849 --> 00:08:36,389
bunch of the different types of testing

00:08:34,409 --> 00:08:40,229
and design reviews that they've gone

00:08:36,389 --> 00:08:43,829
through but they've said that roughly

00:08:40,229 --> 00:08:46,819
25% of bugs are caught in unit testing

00:08:43,829 --> 00:08:50,910
and they actually said it was between

00:08:46,819 --> 00:08:53,100
20% and 50% and more are caught in

00:08:50,910 --> 00:08:53,790
functional testing more are caught in

00:08:53,100 --> 00:08:57,060
integrate

00:08:53,790 --> 00:08:59,640
testing and then in field testing and

00:08:57,060 --> 00:09:01,530
code review both catch about 50% however

00:08:59,640 --> 00:09:02,940
the cumulative effect of having all of

00:09:01,530 --> 00:09:06,480
these different layers of testing and

00:09:02,940 --> 00:09:08,780
reviewed add up to around 99% of bugs so

00:09:06,480 --> 00:09:10,770
if you're only doing some of these

00:09:08,780 --> 00:09:13,650
you're probably not going to catch as

00:09:10,770 --> 00:09:15,600
many bugs as you could be and if you're

00:09:13,650 --> 00:09:17,880
and if then this ties in quite well with

00:09:15,600 --> 00:09:20,190
here in how many actionable feedback

00:09:17,880 --> 00:09:22,770
cycles do you get per hour with a unit

00:09:20,190 --> 00:09:25,430
test if something breaks then you know

00:09:22,770 --> 00:09:27,990
almost down to the line what is broken

00:09:25,430 --> 00:09:30,720
with a functional test you probably know

00:09:27,990 --> 00:09:34,110
within within a hundred lines where the

00:09:30,720 --> 00:09:37,350
bug is integration tests it could be

00:09:34,110 --> 00:09:39,090
pretty big and in field tests it could

00:09:37,350 --> 00:09:42,000
be even hardware that's a problem you

00:09:39,090 --> 00:09:43,320
don't know so and code review of you can

00:09:42,000 --> 00:09:46,260
only do one or two of those an hour

00:09:43,320 --> 00:09:48,180
right so it's really there is a

00:09:46,260 --> 00:09:50,130
trade-off here between how many bugs you

00:09:48,180 --> 00:09:52,140
catch and how quickly you can get

00:09:50,130 --> 00:09:55,740
feedback and how specific that feedback

00:09:52,140 --> 00:09:57,840
is on exactly the type of bug and just

00:09:55,740 --> 00:10:00,930
to give an example of the type of things

00:09:57,840 --> 00:10:03,800
that high level or infield testing might

00:10:00,930 --> 00:10:06,180
not catch but unit tests would catch is

00:10:03,800 --> 00:10:08,760
something like a controller that is not

00:10:06,180 --> 00:10:11,220
that is clamping its inputs because the

00:10:08,760 --> 00:10:12,870
inputs are wrong and you would never

00:10:11,220 --> 00:10:15,360
find that out if you didn't have a unit

00:10:12,870 --> 00:10:17,190
test and the functional and infield

00:10:15,360 --> 00:10:18,930
tests or the infield testing and

00:10:17,190 --> 00:10:21,290
integration tests would probably pass

00:10:18,930 --> 00:10:24,360
but you'd have reduced performance and

00:10:21,290 --> 00:10:25,800
this is something where the unit testing

00:10:24,360 --> 00:10:28,020
would give you that better performance

00:10:25,800 --> 00:10:32,280
even if technically at the high level it

00:10:28,020 --> 00:10:33,900
was working if not very well so who

00:10:32,280 --> 00:10:35,130
benefits from unit tests and I didn't

00:10:33,900 --> 00:10:36,720
put those on the overview because I

00:10:35,130 --> 00:10:38,640
wanted to surprise you with it everyone

00:10:36,720 --> 00:10:40,380
benefits from unit tests and everyone

00:10:38,640 --> 00:10:41,850
Bennett's from functional tests everyone

00:10:40,380 --> 00:10:44,790
Bennett's benefits from integration

00:10:41,850 --> 00:10:47,010
tests and in field testing more testing

00:10:44,790 --> 00:10:48,840
is better right up in to the point where

00:10:47,010 --> 00:10:50,340
we stopped finding any bugs at all and I

00:10:48,840 --> 00:10:51,990
think that's a very very long ways away

00:10:50,340 --> 00:10:56,370
for basically all software that you've

00:10:51,990 --> 00:10:59,640
ever met so the community contributors

00:10:56,370 --> 00:11:01,770
they find this they are less likely to

00:10:59,640 --> 00:11:04,020
introduce new bugs into the software if

00:11:01,770 --> 00:11:05,430
there's code is tested and the

00:11:04,020 --> 00:11:07,500
maintainer is like that as well and

00:11:05,430 --> 00:11:08,850
because they are less

00:11:07,500 --> 00:11:12,000
have bugs so they're more likely to

00:11:08,850 --> 00:11:13,650
review it and merge it quicker and also

00:11:12,000 --> 00:11:15,240
this means that your code is less likely

00:11:13,650 --> 00:11:19,590
to break in the future when changes

00:11:15,240 --> 00:11:22,050
happen the core developers this more

00:11:19,590 --> 00:11:25,800
tests in the code means it's easier to

00:11:22,050 --> 00:11:28,530
maintain and the bugs tend to surface

00:11:25,800 --> 00:11:30,600
before it gets to end-users and this

00:11:28,530 --> 00:11:32,010
really means that less bug reports and

00:11:30,600 --> 00:11:33,780
the developers can deal with the

00:11:32,010 --> 00:11:36,500
problems themselves instead of having

00:11:33,780 --> 00:11:39,780
this giant loop around to end-users

00:11:36,500 --> 00:11:43,050
manufacturers you deal with less bug

00:11:39,780 --> 00:11:44,160
reports from your end-users if you have

00:11:43,050 --> 00:11:46,940
custom features that need to be

00:11:44,160 --> 00:11:49,950
developed and they can go quicker and

00:11:46,940 --> 00:11:51,960
new airframe bring up new testing new

00:11:49,950 --> 00:11:53,940
things putting it things on real

00:11:51,960 --> 00:11:55,860
vehicles chances are the bugs already

00:11:53,940 --> 00:11:57,540
got caught on an earlier level and so

00:11:55,860 --> 00:12:02,510
you're not going to have as many crashes

00:11:57,540 --> 00:12:06,060
as many FRA Fried motors fried Hardware

00:12:02,510 --> 00:12:08,430
broken whatever lost glossed customer

00:12:06,060 --> 00:12:10,590
trust and end users of course they like

00:12:08,430 --> 00:12:12,240
less bugs they like faster bug fixes and

00:12:10,590 --> 00:12:13,890
they like more features because remember

00:12:12,240 --> 00:12:18,540
we can do more features in the same time

00:12:13,890 --> 00:12:22,560
when we have tests so in practice how do

00:12:18,540 --> 00:12:25,860
you make this really really happen I'd

00:12:22,560 --> 00:12:28,980
like to go over a few places here we're

00:12:25,860 --> 00:12:31,320
testing automated testing 100% makes

00:12:28,980 --> 00:12:32,940
sense if you have new code write unit

00:12:31,320 --> 00:12:36,230
tests for it write functional tests for

00:12:32,940 --> 00:12:38,940
it get right your tests as

00:12:36,230 --> 00:12:40,980
specifications make sure that your tests

00:12:38,940 --> 00:12:44,730
explain what your code is meant to do

00:12:40,980 --> 00:12:45,990
and and then test against that check

00:12:44,730 --> 00:12:48,900
that your code is doing the right thing

00:12:45,990 --> 00:12:50,580
if you have untested code and you don't

00:12:48,900 --> 00:12:52,440
know what the quality is like you don't

00:12:50,580 --> 00:12:54,360
know how it behaves write tests for it

00:12:52,440 --> 00:12:55,620
you can then find out exactly how it

00:12:54,360 --> 00:12:57,480
behaves you can give it any type of

00:12:55,620 --> 00:12:58,860
input you want and you can make sure

00:12:57,480 --> 00:13:01,200
that it does the things you wanted to do

00:12:58,860 --> 00:13:02,790
if you have code that needs to be

00:13:01,200 --> 00:13:04,890
debugged because you think there's a bug

00:13:02,790 --> 00:13:08,720
in this test or in the code there's a

00:13:04,890 --> 00:13:11,400
perfect place to write a test because

00:13:08,720 --> 00:13:13,680
often bugs have are triggered by edge

00:13:11,400 --> 00:13:15,089
cases because well you don't usually

00:13:13,680 --> 00:13:17,220
write bugs on things that are working

00:13:15,089 --> 00:13:19,050
well or find bugs and things that are

00:13:17,220 --> 00:13:20,300
working well so it's gonna be in an edge

00:13:19,050 --> 00:13:23,820
case

00:13:20,300 --> 00:13:25,440
so and these edge cases are unreal

00:13:23,820 --> 00:13:27,660
vehicles very difficult to reproduce

00:13:25,440 --> 00:13:29,550
maybe you have to have it at a certain

00:13:27,660 --> 00:13:31,590
time of day maybe you need your GPS to

00:13:29,550 --> 00:13:34,410
fail at the same time as you're taking

00:13:31,590 --> 00:13:36,900
off maybe you need some other strange

00:13:34,410 --> 00:13:38,520
combination of things however if you

00:13:36,900 --> 00:13:41,820
have some theory about what's triggering

00:13:38,520 --> 00:13:44,370
your bug write a test make in your tests

00:13:41,820 --> 00:13:47,220
trigger that exact use case if the thing

00:13:44,370 --> 00:13:49,470
breaks your theory is correct you now

00:13:47,220 --> 00:13:52,170
have a reproducible situation on your

00:13:49,470 --> 00:13:53,310
computer where the tests are showing

00:13:52,170 --> 00:13:56,040
exactly where the bug is

00:13:53,310 --> 00:13:58,400
now you can fix your code and when your

00:13:56,040 --> 00:14:01,500
tests pass you know the bug is gone

00:13:58,400 --> 00:14:04,830
there are some cases where testing

00:14:01,500 --> 00:14:06,180
sometimes doesn't work if you don't know

00:14:04,830 --> 00:14:08,040
what your code is meant to do maybe

00:14:06,180 --> 00:14:09,570
you're trying to explore some new image

00:14:08,040 --> 00:14:11,190
processing algorithm and you just want

00:14:09,570 --> 00:14:13,800
it to look cool and but you're not

00:14:11,190 --> 00:14:16,740
exactly sure how to write what does cool

00:14:13,800 --> 00:14:18,630
look like then great maybe you don't

00:14:16,740 --> 00:14:20,370
need tests for that however you should

00:14:18,630 --> 00:14:22,080
probably still try to set up a quick

00:14:20,370 --> 00:14:25,860
feedback loop so you can very quickly

00:14:22,080 --> 00:14:28,760
get feedback on whether your code is

00:14:25,860 --> 00:14:31,410
doing what you think it is glue code is

00:14:28,760 --> 00:14:32,940
where you have a bunch of systems and

00:14:31,410 --> 00:14:37,770
yohko just sticks things together

00:14:32,940 --> 00:14:40,110
and in this case putting code together

00:14:37,770 --> 00:14:42,810
it can be a lot of pain to set up a test

00:14:40,110 --> 00:14:45,690
for something like this I would still

00:14:42,810 --> 00:14:48,000
recommend having something that you can

00:14:45,690 --> 00:14:50,220
check that it at least runs and it at

00:14:48,000 --> 00:14:52,020
least thinks it know it it thinks it

00:14:50,220 --> 00:14:54,540
knows what it's doing even if you're not

00:14:52,020 --> 00:14:57,000
a hundred percent sure testing of course

00:14:54,540 --> 00:14:58,770
you not going to catch every single bug

00:14:57,000 --> 00:15:01,650
but you shouldn't at least try to catch

00:14:58,770 --> 00:15:03,630
the easy ones and the last one is your

00:15:01,650 --> 00:15:06,839
test code or your build code does that

00:15:03,630 --> 00:15:08,700
need testing probably not unless you

00:15:06,839 --> 00:15:10,980
have something big that you're trying to

00:15:08,700 --> 00:15:12,150
do in your testing code like you're

00:15:10,980 --> 00:15:14,190
trying to generate a whole bunch of

00:15:12,150 --> 00:15:15,600
sample data to test your other stuff

00:15:14,190 --> 00:15:16,920
with maybe you want to make sure that

00:15:15,600 --> 00:15:19,620
you're actually generating the sample

00:15:16,920 --> 00:15:21,030
data that you think you are otherwise it

00:15:19,620 --> 00:15:25,050
when your two other tests start failing

00:15:21,030 --> 00:15:28,680
you might be very confused so zombies

00:15:25,050 --> 00:15:31,080
surprised there were zombies here and

00:15:28,680 --> 00:15:33,089
this is actually an acronym this is to

00:15:31,080 --> 00:15:34,070
help you remember what kind of tests you

00:15:33,089 --> 00:15:39,140
need to write

00:15:34,070 --> 00:15:41,900
so the first one is zero no data no this

00:15:39,140 --> 00:15:43,760
is try to test the simplest use case

00:15:41,900 --> 00:15:44,420
just to make sure that your thing gives

00:15:43,760 --> 00:15:46,220
you back

00:15:44,420 --> 00:15:48,470
probably something similar to what you

00:15:46,220 --> 00:15:50,750
gave it don't just set your test up

00:15:48,470 --> 00:15:53,300
don't do anything make sure that there's

00:15:50,750 --> 00:15:55,790
no surprises the next thing is one just

00:15:53,300 --> 00:15:57,860
put a little bit of data in check that

00:15:55,790 --> 00:15:59,540
it still works now you can build your

00:15:57,860 --> 00:16:01,280
tests up to do everything that you think

00:15:59,540 --> 00:16:02,990
it did that you want to do you can add

00:16:01,280 --> 00:16:05,960
more tests doing all the functionality

00:16:02,990 --> 00:16:07,640
you want boundaries catch you off by one

00:16:05,960 --> 00:16:09,800
errors make sure that you loop through

00:16:07,640 --> 00:16:13,340
every single element in your array make

00:16:09,800 --> 00:16:14,570
sure that if you specify that something

00:16:13,340 --> 00:16:16,340
should stop at a certain point that it

00:16:14,570 --> 00:16:17,810
stops at exactly that point check right

00:16:16,340 --> 00:16:19,330
before and right after to make sure that

00:16:17,810 --> 00:16:22,520
it stops at the right time

00:16:19,330 --> 00:16:24,470
interfaces make sure that your API does

00:16:22,520 --> 00:16:27,560
the things that it promises and make

00:16:24,470 --> 00:16:29,990
sure that you are actually testing what

00:16:27,560 --> 00:16:31,460
your API promises and not some other

00:16:29,990 --> 00:16:33,080
functionality that your API isn't

00:16:31,460 --> 00:16:34,880
actually promising and that is maybe

00:16:33,080 --> 00:16:38,330
more specific to the implementation than

00:16:34,880 --> 00:16:40,340
the API exceptions try throwing garbage

00:16:38,330 --> 00:16:41,420
at your code and see what happens make

00:16:40,340 --> 00:16:43,520
sure it doesn't crash

00:16:41,420 --> 00:16:45,200
best-case like especially when you're

00:16:43,520 --> 00:16:46,580
working on high reliability systems like

00:16:45,200 --> 00:16:50,410
drones we don't want our code to

00:16:46,580 --> 00:16:52,700
segfault hard faults whatever it is -

00:16:50,410 --> 00:16:55,310
and because that can lead to really

00:16:52,700 --> 00:16:58,040
really bad outcomes and then simple at

00:16:55,310 --> 00:16:59,750
the end I think they needed an S here so

00:16:58,040 --> 00:17:02,030
they added a simple just put up

00:16:59,750 --> 00:17:03,770
something simple and make sure that this

00:17:02,030 --> 00:17:08,570
works often this is the first kind of

00:17:03,770 --> 00:17:10,400
test that I do after the zeros so when

00:17:08,570 --> 00:17:12,199
you're doing your testing it can often

00:17:10,400 --> 00:17:14,000
fit into a framework we call behavior

00:17:12,199 --> 00:17:16,520
driven development where you use it to

00:17:14,000 --> 00:17:19,189
test a specification for your code we

00:17:16,520 --> 00:17:20,390
set it up with a given when then so

00:17:19,189 --> 00:17:22,910
given the initial conditions of your

00:17:20,390 --> 00:17:24,410
code we do this when we do the thing we

00:17:22,910 --> 00:17:27,800
want to test then you should get your

00:17:24,410 --> 00:17:30,170
outputs and here's a real example but

00:17:27,800 --> 00:17:37,289
I'm going to do a demo for you know with

00:17:30,170 --> 00:17:43,120
an actual real example so in

00:17:37,289 --> 00:17:45,640
px4 there's this function here and my

00:17:43,120 --> 00:17:48,460
colleague Roman recently wanted to call

00:17:45,640 --> 00:17:50,559
it and I said oh that looks like it's

00:17:48,460 --> 00:17:53,710
got nice inputs and outputs it can very

00:17:50,559 --> 00:17:56,860
easily be used for a unit test so this

00:17:53,710 --> 00:17:58,690
is going to be what my demo is this is a

00:17:56,860 --> 00:18:02,169
waypoint from heading in distance and

00:17:58,690 --> 00:18:04,870
this has existed in px for at leasts for

00:18:02,169 --> 00:18:06,520
four years it hasn't been modified so

00:18:04,870 --> 00:18:09,789
let's add a test for it and see how we

00:18:06,520 --> 00:18:12,280
go it you give it your latitude and

00:18:09,789 --> 00:18:15,190
longitude start your bearing in radians

00:18:12,280 --> 00:18:19,900
a distance in meters your latitude

00:18:15,190 --> 00:18:23,280
target and your longitude target so

00:18:19,900 --> 00:18:36,100
let's copy that

00:18:23,280 --> 00:18:38,110
let's make a new test here we put from

00:18:36,100 --> 00:18:40,539
heading in distance and let's start with

00:18:38,110 --> 00:18:51,340
our zombie acronym so let's do zero as a

00:18:40,539 --> 00:18:53,049
starting point so let's start with our

00:18:51,340 --> 00:19:04,750
behavior driven development a given when

00:18:53,049 --> 00:19:20,289
then zero distance and ring from a

00:19:04,750 --> 00:19:27,270
starting point when we call this then it

00:19:20,289 --> 00:19:34,320
should give the input so let's make a

00:19:27,270 --> 00:19:34,320
few things so we have doubles actually

00:19:36,179 --> 00:19:39,809
it's three three

00:19:41,539 --> 00:19:47,509
00:19:44,380 --> 00:19:47,509
[Music]

00:19:48,109 --> 00:20:06,470
these are floods okay so this is our

00:20:03,499 --> 00:20:16,940
inputs now we need to call the function

00:20:06,470 --> 00:20:19,549
with that start long start see here we

00:20:16,940 --> 00:20:22,759
have that start long start bearing

00:20:19,549 --> 00:20:45,259
distance and lat target long target and

00:20:22,759 --> 00:20:48,919
so I'm gonna start distance okay is this

00:20:45,259 --> 00:20:57,229
complaining yes I need to point pointers

00:20:48,919 --> 00:20:58,970
to these now my function is happy for

00:20:57,229 --> 00:21:00,409
those of you who are wondering I'm using

00:20:58,970 --> 00:21:04,999
K develop as an IDE

00:21:00,409 --> 00:21:19,820
it works really well with px4 then we

00:21:04,999 --> 00:21:22,119
have expect float equal that start that

00:21:19,820 --> 00:21:22,119
end

00:21:34,660 --> 00:21:45,890
okay so this is now a test we've written

00:21:40,610 --> 00:21:49,880
the test we've added a test so let's run

00:21:45,890 --> 00:21:53,890
the tests we can just do actually if you

00:21:49,880 --> 00:21:58,970
go into ECL you can do make tests and

00:21:53,890 --> 00:22:00,880
there our test passed let's just make

00:21:58,970 --> 00:22:04,310
sure that it's actually working let's

00:22:00,880 --> 00:22:09,110
let's add a let's you know let's make

00:22:04,310 --> 00:22:16,280
the distance - a thousand and check that

00:22:09,110 --> 00:22:18,290
our test fails oh yes it looks like our

00:22:16,280 --> 00:22:23,420
test fails so let's go and see what it

00:22:18,290 --> 00:22:25,970
said it said - 33 and it but it should

00:22:23,420 --> 00:22:31,400
have but what it actually gave us at lat

00:22:25,970 --> 00:22:34,370
end is minus 30 2.99 now I put - a

00:22:31,400 --> 00:22:36,650
thousand and the bearing is zero you

00:22:34,370 --> 00:22:39,320
would think that if I gave - a thousand

00:22:36,650 --> 00:22:41,630
if the latitude will go further negative

00:22:39,320 --> 00:22:44,780
not go north so that's a bit of a

00:22:41,630 --> 00:22:53,750
surprise there if I do plus a thousand

00:22:44,780 --> 00:22:55,490
do I get the same results yes I get the

00:22:53,750 --> 00:22:57,170
same results so now this is something

00:22:55,490 --> 00:23:01,670
that I would say is unexpected behavior

00:22:57,170 --> 00:23:09,920
from the test and let's actually call

00:23:01,670 --> 00:23:11,900
this distance is negative now this is

00:23:09,920 --> 00:23:14,690
actually something that I think we

00:23:11,900 --> 00:23:17,540
should fix so if it's saying - a

00:23:14,690 --> 00:23:19,130
thousand and you having a bearing of

00:23:17,540 --> 00:23:23,450
zero that should mean it should go south

00:23:19,130 --> 00:23:25,250
if not go north so let's see what

00:23:23,450 --> 00:23:30,020
actually is happening inside of this

00:23:25,250 --> 00:23:31,250
function well there's the offender it's

00:23:30,020 --> 00:23:32,630
taking the absolute value of the

00:23:31,250 --> 00:23:34,880
distance that doesn't make much sense

00:23:32,630 --> 00:23:37,880
for this standard 2d projection type of

00:23:34,880 --> 00:23:39,799
function so let's take that out

00:23:37,880 --> 00:23:41,270
I'll check afterwards to make sure that

00:23:39,799 --> 00:23:43,100
it's not being used anywhere that's

00:23:41,270 --> 00:23:46,010
expecting that negative distance to be

00:23:43,100 --> 00:23:48,080
positive but still this is something

00:23:46,010 --> 00:23:49,820
that I think is unexpected behavior and

00:23:48,080 --> 00:23:53,230
if it doesn't hurt somebody now it might

00:23:49,820 --> 00:23:59,210
hurt somebody in the future so now if we

00:23:53,230 --> 00:24:01,280
go back here and run the test again now

00:23:59,210 --> 00:24:03,169
we get a more negative number when we

00:24:01,280 --> 00:24:06,860
did - a thousand which is exactly what

00:24:03,169 --> 00:24:09,679
we expected so I will go back and figure

00:24:06,860 --> 00:24:12,710
out the exact transforms to get this

00:24:09,679 --> 00:24:14,690
into the correct values but now you've

00:24:12,710 --> 00:24:16,730
seen how to make a test how to write a

00:24:14,690 --> 00:24:19,010
test and if you're doing it anywhere

00:24:16,730 --> 00:24:21,830
else in px4 this is basically the same

00:24:19,010 --> 00:24:24,320
process you will go in you will write

00:24:21,830 --> 00:24:28,820
tests according to exactly the G test

00:24:24,320 --> 00:24:30,679
and there are also there's also in the

00:24:28,820 --> 00:24:33,850
user guide a fairly extensive way and

00:24:30,679 --> 00:24:53,110
there are also examples that are there

00:24:33,850 --> 00:24:53,110
yeah so questions the questions

00:24:57,730 --> 00:25:03,500
so the first question is do I have

00:25:01,550 --> 00:25:05,390
experience on using TDD in these type of

00:25:03,500 --> 00:25:07,750
platforms yes

00:25:05,390 --> 00:25:12,950
I prefer behavior driven development

00:25:07,750 --> 00:25:14,990
instead of TDD but I knew what it would

00:25:12,950 --> 00:25:16,310
test in TDD as test-driven development

00:25:14,990 --> 00:25:19,160
I feel like test-driven development

00:25:16,310 --> 00:25:22,100
sometimes deviates a little bit from

00:25:19,160 --> 00:25:23,570
where the from what the actual value is

00:25:22,100 --> 00:25:25,610
for the code that you're providing and

00:25:23,570 --> 00:25:27,080
said focused a bit too much on providing

00:25:25,610 --> 00:25:29,060
value to the tests instead of the code

00:25:27,080 --> 00:25:30,890
which is the why I like behavior driven

00:25:29,060 --> 00:25:34,040
development because you're doing it but

00:25:30,890 --> 00:25:36,500
yes I think behavior driven development

00:25:34,040 --> 00:25:38,150
on these types of systems is very

00:25:36,500 --> 00:25:39,770
valuable because you end up with

00:25:38,150 --> 00:25:43,120
something that is well specified that

00:25:39,770 --> 00:25:43,120
you know exactly what it's meant to do

00:25:44,500 --> 00:25:55,130
do we have a system tracing standard

00:25:49,450 --> 00:25:59,380
there is some stuff I know that you can

00:25:55,130 --> 00:26:03,250
output stack trace or stack pointers on

00:25:59,380 --> 00:26:05,990
on there's a high speed bus and this is

00:26:03,250 --> 00:26:11,180
definitely available in v5 X I'm not

00:26:05,990 --> 00:26:16,280
sure about others yet but and this can

00:26:11,180 --> 00:26:19,970
be used for profiling and yes however I

00:26:16,280 --> 00:26:21,650
think for a lot of the development or a

00:26:19,970 --> 00:26:23,090
lot of at least business logic things

00:26:21,650 --> 00:26:26,180
that don't involve drivers and things

00:26:23,090 --> 00:26:29,060
that don't involve actual hardware based

00:26:26,180 --> 00:26:30,380
performance tests where you're more

00:26:29,060 --> 00:26:33,710
interested in relative performance

00:26:30,380 --> 00:26:36,050
rather than absolute performance I think

00:26:33,710 --> 00:26:39,680
a lot of it can be done on your laptop

00:26:36,050 --> 00:26:42,110
cross compiled and not have to go

00:26:39,680 --> 00:26:44,840
through a difficult debugging cycle and

00:26:42,110 --> 00:26:48,500
special ID is that can connect over jtag

00:26:44,840 --> 00:26:50,330
and things like this yes and any more

00:26:48,500 --> 00:26:52,940
questions you can find me on slack I

00:26:50,330 --> 00:26:55,550
will be there to ask answer anything

00:26:52,940 --> 00:26:58,600
else you want to know and I hope to see

00:26:55,550 --> 00:26:58,600

YouTube URL: https://www.youtube.com/watch?v=KXxInO5w3_8


