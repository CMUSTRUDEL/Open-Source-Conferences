Title: Hardfault debugging on PX4 - PX4 Developer Summit 2019
Publication date: 2019-07-03
Playlist: PX4 Developer Summit 2019 | ETH ZÃ¼rich
Description: 
	David Sidrane
Owner, NSCDG

A demonstration of the tools and techniques to debug a Hard Fault on the PX4 platform. Concentrating on real-time debugging and post mortem analysis of hard fault logs.
Captions: 
	00:00:11,960 --> 00:00:16,860
all right so please give an applause to

00:00:15,120 --> 00:00:17,450
Davey siren he's gonna present hardball

00:00:16,860 --> 00:00:23,099
debugging

00:00:17,450 --> 00:00:24,750
okay explore well I want to say thank

00:00:23,099 --> 00:00:28,019
you to everybody that's here in this

00:00:24,750 --> 00:00:29,699
room because I realize how much we all

00:00:28,019 --> 00:00:31,890
depend on each other and and how we

00:00:29,699 --> 00:00:35,489
further this project and it is really

00:00:31,890 --> 00:00:38,129
wonderful to see everybody here my

00:00:35,489 --> 00:00:42,180
background is that I'm the owner of a

00:00:38,129 --> 00:00:46,890
company called NS C D G and I've been in

00:00:42,180 --> 00:00:52,230
doing embedded systems for 30 35 plus

00:00:46,890 --> 00:00:59,789
years and I got involved in px4 during I

00:00:52,230 --> 00:01:01,559
guess it was the end of 2015 when Lorenz

00:00:59,789 --> 00:01:03,090
reached out to me and he said that he

00:01:01,559 --> 00:01:05,880
needed somebody to help with nedick's

00:01:03,090 --> 00:01:12,420
integration I think I just finished

00:01:05,880 --> 00:01:15,990
loading the last thing and what what he

00:01:12,420 --> 00:01:19,200
was looking for was bringing px4 up to

00:01:15,990 --> 00:01:23,009
using current knotek's it was about two

00:01:19,200 --> 00:01:26,039
years in the arrears of where upstream

00:01:23,009 --> 00:01:27,450
nedick's was at the time and I I got

00:01:26,039 --> 00:01:29,160
involved in the project and I started

00:01:27,450 --> 00:01:32,759
learning I knew nothing about drones I

00:01:29,160 --> 00:01:34,740
knew nothing about flying there's a joke

00:01:32,759 --> 00:01:36,690
that you know all that I have is on my

00:01:34,740 --> 00:01:40,500
desk is is the hardware I don't have

00:01:36,690 --> 00:01:43,289
propellers I don't have full systems but

00:01:40,500 --> 00:01:45,360
I work with typical manufacturers

00:01:43,289 --> 00:01:48,209
bringing up the initial hardware and

00:01:45,360 --> 00:01:52,530
porting px4 to two different processors

00:01:48,209 --> 00:01:55,979
and one of the ideas that Lorentz had

00:01:52,530 --> 00:01:58,349
was that he wanted to make sure that if

00:01:55,979 --> 00:02:02,459
anything happened in the air we had the

00:01:58,349 --> 00:02:05,190
ability to log it and if there was a

00:02:02,459 --> 00:02:07,619
processor fault or a bug in a driver or

00:02:05,190 --> 00:02:11,520
a bug in the OS we wanted to know where

00:02:07,619 --> 00:02:13,790
exactly that occurred and how to track

00:02:11,520 --> 00:02:16,860
it down and he came up with a really a

00:02:13,790 --> 00:02:20,190
genius idea which was if we could store

00:02:16,860 --> 00:02:22,260
this information after the crash in the

00:02:20,190 --> 00:02:24,000
non-volatile memory of the processor

00:02:22,260 --> 00:02:24,600
we'd have the ability to get that

00:02:24,000 --> 00:02:27,300
information

00:02:24,600 --> 00:02:32,010
after boot when things were seen again

00:02:27,300 --> 00:02:34,170
in the environment so that was the the

00:02:32,010 --> 00:02:36,270
birth of hard fault logging now does

00:02:34,170 --> 00:02:40,410
does everybody know what hard-fought

00:02:36,270 --> 00:02:43,560
logging in px4 is Johanna okay

00:02:40,410 --> 00:02:45,420
so Julian went through something and he

00:02:43,560 --> 00:02:47,970
was showing you Val grind and call grind

00:02:45,420 --> 00:02:51,060
and and you know how to find bugs in gdb

00:02:47,970 --> 00:02:53,550
if they get past that point and they

00:02:51,060 --> 00:02:56,130
make it on to the hardware we have a

00:02:53,550 --> 00:02:58,850
probability of a few different

00:02:56,130 --> 00:03:00,990
situations that can occur one of them is

00:02:58,850 --> 00:03:03,330
actually executing an invalid

00:03:00,990 --> 00:03:04,920
instruction because we've vectored

00:03:03,330 --> 00:03:05,480
through a table that got corrupted in

00:03:04,920 --> 00:03:09,480
memory

00:03:05,480 --> 00:03:11,790
another possibility is dereferencing a

00:03:09,480 --> 00:03:14,130
pointer that's pointing the null which

00:03:11,790 --> 00:03:16,710
happens to be address 0 and a processor

00:03:14,130 --> 00:03:19,050
detects that and false that type of

00:03:16,710 --> 00:03:21,330
fault is called a hard fault there are

00:03:19,050 --> 00:03:25,790
many different types of faults that you

00:03:21,330 --> 00:03:25,790
can get get a mouse over there

00:03:36,209 --> 00:03:43,300
so so in not X there are the designer

00:03:41,200 --> 00:03:47,050
not x4 it's interrupt handling and it's

00:03:43,300 --> 00:03:49,450
exception handling is very portable

00:03:47,050 --> 00:03:52,209
across many different platforms and its

00:03:49,450 --> 00:03:55,540
generic in a lot of ways and to

00:03:52,209 --> 00:03:58,540
accommodate that every type of interrupt

00:03:55,540 --> 00:04:02,440
goes through a common vector table and

00:03:58,540 --> 00:04:03,580
we end up into a service that we're

00:04:02,440 --> 00:04:05,530
supposed to run if it's hardware

00:04:03,580 --> 00:04:06,819
interrupts we enter into the UART let's

00:04:05,530 --> 00:04:08,620
hit the UART that had receives a

00:04:06,819 --> 00:04:10,870
character there's an interrupt that's

00:04:08,620 --> 00:04:13,840
generated we go through this vector

00:04:10,870 --> 00:04:15,940
table we end up in the you r is our we

00:04:13,840 --> 00:04:18,190
process the data there we return from

00:04:15,940 --> 00:04:21,310
the interrupt things are going well but

00:04:18,190 --> 00:04:24,130
if you're in a situation where you've

00:04:21,310 --> 00:04:26,500
executed bad code because you vector it

00:04:24,130 --> 00:04:28,960
off well we used to call into the weeds

00:04:26,500 --> 00:04:30,940
you will end up in a heart fault

00:04:28,960 --> 00:04:33,220
situation the processor will execute an

00:04:30,940 --> 00:04:36,520
instruction that's invalid for the

00:04:33,220 --> 00:04:38,470
execution context that it's in and these

00:04:36,520 --> 00:04:41,530
can fall into different classes there's

00:04:38,470 --> 00:04:43,690
hard faults which are like an invalid

00:04:41,530 --> 00:04:45,400
instruction there's a memory manager

00:04:43,690 --> 00:04:47,889
fault where you've accessed an area in

00:04:45,400 --> 00:04:50,590
memory you shouldn't be accessing there

00:04:47,889 --> 00:04:53,320
are bus faults for instance you have a

00:04:50,590 --> 00:04:56,560
peripheral that hasn't been enabled and

00:04:53,320 --> 00:04:59,620
you go to access or register in it and

00:04:56,560 --> 00:05:00,490
you have usage faults which is a little

00:04:59,620 --> 00:05:02,979
bit more complicated

00:05:00,490 --> 00:05:04,750
it's a context that you're running in

00:05:02,979 --> 00:05:08,020
that you try to do something that isn't

00:05:04,750 --> 00:05:10,060
valid for that usage and you but through

00:05:08,020 --> 00:05:14,380
knotek's we all end up in the same place

00:05:10,060 --> 00:05:16,660
which is called UPS cert now depending

00:05:14,380 --> 00:05:19,720
on the architecture of the processor

00:05:16,660 --> 00:05:21,880
we're usually on ARM cores but there are

00:05:19,720 --> 00:05:26,550
many different types of processors that

00:05:21,880 --> 00:05:29,139
we run on you have a normal mechanism of

00:05:26,550 --> 00:05:31,840
exception handling and what that looks

00:05:29,139 --> 00:05:33,760
like is is this when there's an

00:05:31,840 --> 00:05:35,380
exception or an interrupt the processor

00:05:33,760 --> 00:05:37,180
leaves the threat of execution that's

00:05:35,380 --> 00:05:40,870
running in and it vectors through this

00:05:37,180 --> 00:05:43,120
table to do that it has to save context

00:05:40,870 --> 00:05:44,950
on a stack so that it can return from

00:05:43,120 --> 00:05:48,100
what just happened back to where it was

00:05:44,950 --> 00:05:50,710
running and you could look at that

00:05:48,100 --> 00:05:53,350
and you could spend time decoding the

00:05:50,710 --> 00:05:57,130
offsets and the addresses to find the

00:05:53,350 --> 00:05:59,710
registers that it saved on the stack one

00:05:57,130 --> 00:06:02,440
of those registers is the address of the

00:05:59,710 --> 00:06:03,610
thing that caused the fault but you'd

00:06:02,440 --> 00:06:05,670
have to spend a lot of time

00:06:03,610 --> 00:06:07,780
understanding the processor

00:06:05,670 --> 00:06:10,390
understanding the architecture of this

00:06:07,780 --> 00:06:12,430
processor understanding how it stacked

00:06:10,390 --> 00:06:16,390
and what I wanted to point out to people

00:06:12,430 --> 00:06:19,240
is it's a lot simpler to do a couple of

00:06:16,390 --> 00:06:21,790
tricks and the trick is based on the

00:06:19,240 --> 00:06:27,130
fact that we always end up in in UPS

00:06:21,790 --> 00:06:29,830
cert so let me go through it here a

00:06:27,130 --> 00:06:33,700
little bit so both hardware and software

00:06:29,830 --> 00:06:35,920
can cause a fault you could have the

00:06:33,700 --> 00:06:37,630
example of a part that hasn't been

00:06:35,920 --> 00:06:40,210
initialized an IP block that hasn't been

00:06:37,630 --> 00:06:43,960
turned on that you access you will fault

00:06:40,210 --> 00:06:45,850
you can have an issue where you have an

00:06:43,960 --> 00:06:47,440
interrupt that was running and an inner

00:06:45,850 --> 00:06:50,470
a priority that was set higher than it

00:06:47,440 --> 00:06:52,270
that interrupts interrupts this and you

00:06:50,470 --> 00:06:55,180
have nested interrupts which isn't

00:06:52,270 --> 00:06:57,510
supported and metics you will fault so

00:06:55,180 --> 00:06:59,980
what does this look like typically

00:06:57,510 --> 00:07:01,780
you're sitting well actually let me ask

00:06:59,980 --> 00:07:04,150
another question how many people here

00:07:01,780 --> 00:07:07,300
run px4 with a developers console

00:07:04,150 --> 00:07:09,910
connected okay

00:07:07,300 --> 00:07:14,080
is that on the serial console or is that

00:07:09,910 --> 00:07:15,250
through math link serial okay so that's

00:07:14,080 --> 00:07:16,930
how many people actually have a

00:07:15,250 --> 00:07:21,970
hardwired serial connected to their

00:07:16,930 --> 00:07:23,740
hardware okay that's good so what this

00:07:21,970 --> 00:07:25,840
looks like on the console is your

00:07:23,740 --> 00:07:27,370
running code things are working you

00:07:25,840 --> 00:07:29,530
might start seeing what Julian was

00:07:27,370 --> 00:07:31,390
showing where there's a stall and then

00:07:29,530 --> 00:07:33,460
all of a sudden you get this dump

00:07:31,390 --> 00:07:37,390
of registers on the screen and the

00:07:33,460 --> 00:07:41,100
Machine reboots that's a hard fault

00:07:37,390 --> 00:07:41,100
that's what it looks like to you

00:07:46,280 --> 00:07:52,590
there's there's different there's

00:07:49,460 --> 00:07:54,300
different levels of complication when

00:07:52,590 --> 00:07:57,780
you have a hard fall and the debugging

00:07:54,300 --> 00:07:59,550
is equally broken in the two categories

00:07:57,780 --> 00:08:01,470
the easy to find ones and the hard to

00:07:59,550 --> 00:08:02,820
find ones I was talking to somebody the

00:08:01,470 --> 00:08:05,280
other night and I said the easy to find

00:08:02,820 --> 00:08:07,620
ones are you know four hours two hours

00:08:05,280 --> 00:08:09,870
maybe it's pretty simple to figure out

00:08:07,620 --> 00:08:11,670
what causes it the hard ones start to

00:08:09,870 --> 00:08:14,070
get to one to two days when you're into

00:08:11,670 --> 00:08:15,750
a week of debugging in a hardware

00:08:14,070 --> 00:08:19,290
debugger you know you've had a really

00:08:15,750 --> 00:08:20,910
hard problem right so we'll start with

00:08:19,290 --> 00:08:23,490
the simple ones and we'll talk about why

00:08:20,910 --> 00:08:26,100
they're simple they're repeatable every

00:08:23,490 --> 00:08:27,600
time you run the code it crashes always

00:08:26,100 --> 00:08:29,550
crashes in the same place

00:08:27,600 --> 00:08:32,490
you can almost debug this from looking

00:08:29,550 --> 00:08:36,090
at the console output but there's

00:08:32,490 --> 00:08:37,590
another there's an easier way so I gave

00:08:36,090 --> 00:08:40,229
you the example of executing a pure

00:08:37,590 --> 00:08:42,229
virtual function so does everybody know

00:08:40,229 --> 00:08:44,310
what a pure virtual function is in C++

00:08:42,229 --> 00:08:48,420
does everybody know what that looks like

00:08:44,310 --> 00:08:52,830
an assembler okay so what that boils

00:08:48,420 --> 00:08:55,140
down to is a boils down to it can be a

00:08:52,830 --> 00:08:56,940
call to something that will execute an

00:08:55,140 --> 00:08:59,640
invalid instructions so that you get a

00:08:56,940 --> 00:09:01,590
fault or it will call exit and give you

00:08:59,640 --> 00:09:04,050
a reference to where the the pure

00:09:01,590 --> 00:09:07,800
virtual is invoked but ultimately what

00:09:04,050 --> 00:09:10,290
it is is it is a and it's kind of

00:09:07,800 --> 00:09:12,930
syntactically indicated that way in C++

00:09:10,290 --> 00:09:14,730
that it's set equal to zero if you're

00:09:12,930 --> 00:09:17,760
running on real hardware and it doesn't

00:09:14,730 --> 00:09:20,520
have exception handling in C++ that's

00:09:17,760 --> 00:09:22,950
going to end up executing at address

00:09:20,520 --> 00:09:26,850
zero which is a hard fault

00:09:22,950 --> 00:09:29,160
so those are easy to find if you if you

00:09:26,850 --> 00:09:31,530
look at it from the more complex point

00:09:29,160 --> 00:09:35,540
of view you have a task that's running

00:09:31,530 --> 00:09:38,070
here and it's allocated a buffer but it

00:09:35,540 --> 00:09:40,290
miscalculated its its address references

00:09:38,070 --> 00:09:42,180
to that buffer and it's writing down

00:09:40,290 --> 00:09:45,420
here in somebody else's stack space

00:09:42,180 --> 00:09:46,800
well that process may get suspended and

00:09:45,420 --> 00:09:50,130
while it's suspended and it's sitting

00:09:46,800 --> 00:09:53,880
out waiting to run again its stack got

00:09:50,130 --> 00:09:56,730
overwritten and on its stack was this

00:09:53,880 --> 00:09:58,110
pointer to an object that it's going to

00:09:56,730 --> 00:10:01,080
manipulate when

00:09:58,110 --> 00:10:03,930
comes back you now have junk or zero in

00:10:01,080 --> 00:10:04,740
that address when you dereference that

00:10:03,930 --> 00:10:08,460
pointer

00:10:04,740 --> 00:10:10,650
you will also crash so what happens is

00:10:08,460 --> 00:10:12,570
every one of these things leads to the

00:10:10,650 --> 00:10:13,980
same place in the execution path and

00:10:12,570 --> 00:10:16,410
they give you the same results on the

00:10:13,980 --> 00:10:21,480
screen you have to ferret out what the

00:10:16,410 --> 00:10:24,870
cause is so the way we do this with the

00:10:21,480 --> 00:10:27,240
hardware is we started with when I

00:10:24,870 --> 00:10:28,680
started working on the drones I would

00:10:27,240 --> 00:10:30,030
get different boards from different

00:10:28,680 --> 00:10:33,480
manufacturers with many different

00:10:30,030 --> 00:10:37,770
connectors on them and I had this this

00:10:33,480 --> 00:10:40,290
board on the on the Left main that I

00:10:37,770 --> 00:10:41,940
wired up and I would hang this off of

00:10:40,290 --> 00:10:44,040
the drone and I would hang a JTAG

00:10:41,940 --> 00:10:46,290
debugger off of it and I would run the

00:10:44,040 --> 00:10:48,360
code and I'd download it and that was my

00:10:46,290 --> 00:10:51,630
development environment the problem with

00:10:48,360 --> 00:10:54,930
it is that it was very unstable it was

00:10:51,630 --> 00:10:57,600
handmade and when you're debugging a

00:10:54,930 --> 00:10:59,040
problem you wanna it's it's like the

00:10:57,600 --> 00:11:00,210
same situation where you start out

00:10:59,040 --> 00:11:02,040
you've got a brand new piece of hardware

00:11:00,210 --> 00:11:03,780
and brand new software you're trying to

00:11:02,040 --> 00:11:06,030
integrate them you don't know where the

00:11:03,780 --> 00:11:08,730
problem is well you don't want the

00:11:06,030 --> 00:11:10,620
problem to be your tools so we decided

00:11:08,730 --> 00:11:12,270
that what we would do is we would make

00:11:10,620 --> 00:11:16,280
up a debug board that would allow us to

00:11:12,270 --> 00:11:19,050
integrate with px fours platforms and be

00:11:16,280 --> 00:11:21,870
rock-solid and one of the things we

00:11:19,050 --> 00:11:23,340
found over time was that the old way

00:11:21,870 --> 00:11:25,320
that we used to debug if you have a

00:11:23,340 --> 00:11:27,930
remember version two point four point

00:11:25,320 --> 00:11:29,910
six you had two connectors on it one of

00:11:27,930 --> 00:11:32,010
them that went to the debugger one of

00:11:29,910 --> 00:11:35,070
them went to the console the console was

00:11:32,010 --> 00:11:37,470
connected to an FTDI cable if you

00:11:35,070 --> 00:11:39,750
plugged in the FTDI cable and then you

00:11:37,470 --> 00:11:41,970
brought the system up there was a

00:11:39,750 --> 00:11:44,280
voltage that was back feeding into the

00:11:41,970 --> 00:11:46,950
board and it would raise the voltage

00:11:44,280 --> 00:11:47,760
high enough on the SD card that it would

00:11:46,950 --> 00:11:50,280
brown it out

00:11:47,760 --> 00:11:52,620
so you'd boot and you'd get an error

00:11:50,280 --> 00:11:54,240
that your SD card wasn't mounted so how

00:11:52,620 --> 00:11:56,340
many people remember popping the card

00:11:54,240 --> 00:11:58,230
out and plugging it back in and Psyche

00:11:56,340 --> 00:12:00,570
and and then popping the card in and

00:11:58,230 --> 00:12:03,950
recycling the power and having to do

00:12:00,570 --> 00:12:07,860
that to get their SD card to work again

00:12:03,950 --> 00:12:09,270
Johanns okay it happens so so one of the

00:12:07,860 --> 00:12:11,790
features that we added to the board was

00:12:09,270 --> 00:12:15,269
isolation to allow

00:12:11,790 --> 00:12:16,980
no no back feeding of voltages from the

00:12:15,269 --> 00:12:20,730
debugging environment back into the

00:12:16,980 --> 00:12:25,680
target and over time we had two

00:12:20,730 --> 00:12:27,839
connectors on there we have we now have

00:12:25,680 --> 00:12:30,180
quite a few connectors on there because

00:12:27,839 --> 00:12:32,250
of of different hardware platforms

00:12:30,180 --> 00:12:36,000
the first connector on the board that's

00:12:32,250 --> 00:12:40,709
the the board closest to me is the the

00:12:36,000 --> 00:12:43,110
interface to the V 2.1 hardware and it's

00:12:40,709 --> 00:12:45,779
a really fine cable the next connector

00:12:43,110 --> 00:12:47,790
that's on there is for all the targets

00:12:45,779 --> 00:12:50,970
that support the drone code six pin

00:12:47,790 --> 00:12:52,890
connector but prior to that there were

00:12:50,970 --> 00:12:55,680
some part parts that were fabricated

00:12:52,890 --> 00:12:57,660
boards are fabricated not realizing what

00:12:55,680 --> 00:13:00,390
the specification for the connector was

00:12:57,660 --> 00:13:03,660
we'd receive boards that had the next

00:13:00,390 --> 00:13:06,510
connector on it and then finally an XP

00:13:03,660 --> 00:13:08,279
flight uses an 8-pin connector with a

00:13:06,510 --> 00:13:10,490
reset signal which is one of the

00:13:08,279 --> 00:13:13,769
recommendations on the drone code sight

00:13:10,490 --> 00:13:15,770
and well if we look at the last

00:13:13,769 --> 00:13:19,350
connector that's on there that's the new

00:13:15,770 --> 00:13:23,339
v5 x/d bug connector that's defined and

00:13:19,350 --> 00:13:25,140
it adds some features it adds some

00:13:23,339 --> 00:13:27,060
features where we have actually Hardware

00:13:25,140 --> 00:13:29,550
trace that I think Scott had mentioned

00:13:27,060 --> 00:13:34,290
so that we can do full code coverage and

00:13:29,550 --> 00:13:37,079
profiling in hardware so without any

00:13:34,290 --> 00:13:41,399
other delay let's talk about what it

00:13:37,079 --> 00:13:44,490
takes to debug when I started which was

00:13:41,399 --> 00:13:47,130
a long time ago in this industry it took

00:13:44,490 --> 00:13:52,260
a desktop full of equipment to do what

00:13:47,130 --> 00:13:53,760
we can do with a $20 parts nowadays it

00:13:52,260 --> 00:13:55,910
you'd have to go in and you'd have to

00:13:53,760 --> 00:13:57,839
tell your boss I need a budget of

00:13:55,910 --> 00:14:00,240
$15,000 to buy this piece of equipment

00:13:57,839 --> 00:14:02,910
so that we can find this really hard

00:14:00,240 --> 00:14:06,690
problem we're having that there's no

00:14:02,910 --> 00:14:09,630
other way to solve it and you ended up

00:14:06,690 --> 00:14:12,420
with this huge system you you had to

00:14:09,630 --> 00:14:13,860
bring it up they had a one of the best

00:14:12,420 --> 00:14:17,699
features about it was there was this

00:14:13,860 --> 00:14:20,250
thing called a hardware verification so

00:14:17,699 --> 00:14:21,990
you would plug in you'd plug in the ice

00:14:20,250 --> 00:14:23,490
it was actually called a nice back then

00:14:21,990 --> 00:14:25,150
and a lot of people when I'm talking to

00:14:23,490 --> 00:14:27,340
him about JTAG I call him my

00:14:25,150 --> 00:14:29,920
is because it's what I remember which

00:14:27,340 --> 00:14:31,360
stands for in-circuit emulator the

00:14:29,920 --> 00:14:33,790
reason that we're so expensive is they

00:14:31,360 --> 00:14:35,260
had to produce special silicon with the

00:14:33,790 --> 00:14:37,690
bond out to be able to get to the

00:14:35,260 --> 00:14:42,910
internals of the processor to be able to

00:14:37,690 --> 00:14:46,060
do what we do with the $20 part so the

00:14:42,910 --> 00:14:48,210
the barrier to being able to do Hardware

00:14:46,060 --> 00:14:52,120
debugging has dropped significantly

00:14:48,210 --> 00:14:54,850
every one of the px4 picks hawk platform

00:14:52,120 --> 00:14:57,940
supports Hardware debugging and a hard

00:14:54,850 --> 00:15:00,970
console on it and I would if you're if

00:14:57,940 --> 00:15:03,130
you're seriously developing and you want

00:15:00,970 --> 00:15:04,750
to get to the root cause of problems it

00:15:03,130 --> 00:15:07,090
the fastest way to do that is through

00:15:04,750 --> 00:15:11,620
the hardware console and with the JTAG

00:15:07,090 --> 00:15:14,820
debugger so let's look at this so what

00:15:11,620 --> 00:15:14,820
I'm going to demo here is the

00:15:29,550 --> 00:15:32,940
where is it

00:15:39,360 --> 00:16:03,010
No my VM hanger is this just in front of

00:15:51,130 --> 00:16:04,920
it let me come around this thing there

00:16:03,010 --> 00:16:07,720
we go

00:16:04,920 --> 00:16:12,760
how many you are you are familiar with

00:16:07,720 --> 00:16:17,230
the arm MCU Eclipse plugin okay that's

00:16:12,760 --> 00:16:18,760
good so to me this this is where I

00:16:17,230 --> 00:16:21,100
started to say at the beginning I was

00:16:18,760 --> 00:16:23,320
kind of taking issue with it's hard to

00:16:21,100 --> 00:16:25,900
debug on hardware because in in this

00:16:23,320 --> 00:16:27,370
environment your D being it debugging on

00:16:25,900 --> 00:16:31,410
hardware and it looks just like you're

00:16:27,370 --> 00:16:31,410
running gdb on in the simulation

00:16:38,610 --> 00:16:45,899
okay it's gonna be a little bit trickier

00:16:42,670 --> 00:16:45,899
cuz their buddy

00:16:58,290 --> 00:17:13,350
I need to get a console over here so

00:17:11,310 --> 00:17:15,690
when the Hart fall debug hurt fault

00:17:13,350 --> 00:17:17,910
logging was built part of it was a

00:17:15,690 --> 00:17:19,410
command to test it and I'm gonna go

00:17:17,910 --> 00:17:21,120
ahead and issue a hard fault so you can

00:17:19,410 --> 00:17:23,870
see what it looks like in case you're

00:17:21,120 --> 00:17:23,870
not familiar with it

00:17:34,660 --> 00:17:45,320
okay I'm not sure you can hear the

00:17:43,250 --> 00:17:52,970
system from back there but let me look

00:17:45,320 --> 00:17:55,340
can everybody see this this the this is

00:17:52,970 --> 00:17:57,050
the actual processor register dump that

00:17:55,340 --> 00:18:01,930
occurred because we hit a bad address

00:17:57,050 --> 00:18:04,850
and there's context here from nedick's

00:18:01,930 --> 00:18:06,890
what's here is is also the task list

00:18:04,850 --> 00:18:09,560
that was running and the depth of each

00:18:06,890 --> 00:18:12,170
one of the stacks that has has been used

00:18:09,560 --> 00:18:14,320
in each one of the tasks so for every of

00:18:12,170 --> 00:18:16,580
every one of the tasks that's running

00:18:14,320 --> 00:18:18,740
it'll give you an idea of whether or not

00:18:16,580 --> 00:18:21,170
you've exceeded your your stack space

00:18:18,740 --> 00:18:22,400
and overwritten the process below it so

00:18:21,170 --> 00:18:24,620
that's one thing that's worth while

00:18:22,400 --> 00:18:27,020
looking at at this point but there's a

00:18:24,620 --> 00:18:28,610
lot of information here okay

00:18:27,020 --> 00:18:31,670
there's a lot of information here and

00:18:28,610 --> 00:18:33,920
it's kind of hard to interpret it but

00:18:31,670 --> 00:18:43,510
what's really simple to do is come in

00:18:33,920 --> 00:18:45,440
here and set a breakpoint on UPR default

00:18:43,510 --> 00:18:47,420
earlier I was talking about how

00:18:45,440 --> 00:18:50,120
complicated the different architectures

00:18:47,420 --> 00:18:52,520
are and what the stack looks like and

00:18:50,120 --> 00:18:53,990
figuring out how to unwind it and this

00:18:52,520 --> 00:18:56,230
is the trick that I like to share with

00:18:53,990 --> 00:18:56,230
you

00:19:03,680 --> 00:19:18,220
I can't split the screen so I have to be

00:19:14,630 --> 00:19:18,220
jumping back and forth I'm sorry

00:19:34,570 --> 00:19:40,720
okay work we're in the debugger we've

00:19:38,050 --> 00:19:42,490
stopped or at the heart fault handler we

00:19:40,720 --> 00:19:45,400
want to know how do we get here

00:19:42,490 --> 00:19:47,890
so you've got a you've got a build the

00:19:45,400 --> 00:19:49,690
build runs it runs for maybe an hour and

00:19:47,890 --> 00:19:51,370
then it crashes all you do is you set up

00:19:49,690 --> 00:19:54,100
the JTAG you place the breakpoint on a

00:19:51,370 --> 00:20:00,790
hard fault handler and this is this is

00:19:54,100 --> 00:20:02,440
where the magic comes in you go to the

00:20:00,790 --> 00:20:04,090
registers and you have to understand a

00:20:02,440 --> 00:20:06,610
little bit about the processor in the

00:20:04,090 --> 00:20:09,850
architecture but basically the link

00:20:06,610 --> 00:20:13,060
register is used to return to the

00:20:09,850 --> 00:20:15,760
previous frame when you're returning

00:20:13,060 --> 00:20:20,590
from a call so what we do is we grab the

00:20:15,760 --> 00:20:26,370
link register and we drop that back into

00:20:20,590 --> 00:20:30,600
the PC we switch ourself into

00:20:26,370 --> 00:20:37,840
instruction stepping load then we stop I

00:20:30,600 --> 00:20:40,240
can see which thing it is okay so we're

00:20:37,840 --> 00:20:42,910
stepping assembly code and C plus our C

00:20:40,240 --> 00:20:45,880
code at the same time the reason we're

00:20:42,910 --> 00:20:48,610
stepping in in instruction mode is

00:20:45,880 --> 00:20:49,900
because it's uninterruptible we're

00:20:48,610 --> 00:20:51,190
already in an interrupt so we're

00:20:49,900 --> 00:20:53,860
probably not worried about really taking

00:20:51,190 --> 00:20:56,580
another one but what we're doing is

00:20:53,860 --> 00:21:00,760
we're stepping through the handler and

00:20:56,580 --> 00:21:06,760
you'll notice that I let me get back to

00:21:00,760 --> 00:21:08,350
here that instruction was the return we

00:21:06,760 --> 00:21:10,780
just returned to the code that actually

00:21:08,350 --> 00:21:14,110
caused the hard fall and in this case

00:21:10,780 --> 00:21:15,550
it's due to an undefined instruction the

00:21:14,110 --> 00:21:18,880
under to find instruction when you look

00:21:15,550 --> 00:21:22,360
at it is because the compiler is smart

00:21:18,880 --> 00:21:24,880
it knew that I was trying to take one

00:21:22,360 --> 00:21:26,590
and divide it by zero and instead of

00:21:24,880 --> 00:21:28,030
putting that floating point math in

00:21:26,590 --> 00:21:30,340
there and creating all the code that was

00:21:28,030 --> 00:21:34,000
needed for it it replaced it with an

00:21:30,340 --> 00:21:36,130
undefined instruction so it's it's this

00:21:34,000 --> 00:21:38,380
simple is to place the breakpoint in

00:21:36,130 --> 00:21:39,910
heart fault and step back in instruction

00:21:38,380 --> 00:21:41,650
mode until you exit the interrupt

00:21:39,910 --> 00:21:43,770
handler and you're at the line of code

00:21:41,650 --> 00:21:47,020
where your problem is in your code and

00:21:43,770 --> 00:21:48,370
that should save a huge amount of time

00:21:47,020 --> 00:21:50,890
in debugging a

00:21:48,370 --> 00:21:53,500
a serious heart fault it will take you

00:21:50,890 --> 00:22:00,590
right to the to the source line of code

00:21:53,500 --> 00:22:06,349
where the problem exists thank you David

00:22:00,590 --> 00:22:06,349
[Applause]

00:22:12,550 --> 00:22:14,610

YouTube URL: https://www.youtube.com/watch?v=KZkAM_PVOi0


