Title: ROS2 Powered PX4 - PX4 Developer Summit 2019
Publication date: 2019-07-03
Playlist: PX4 Developer Summit 2019 | ETH ZÃ¼rich
Description: 
	Nuno Marques
Software Engineer, Drone Tech Consultant

As we look towards more complex systems, PX4-powered UAS will become a subsystem in a larger system. With the current developments of ROS 2 and its infrastructure, the demand to make PX4 capable of integrating with such framework has increased, besides the current already supported ROS-Mavlink bridge package, MAVROS.

The ability to isolate telemetry links over Mavlink and provide a more tight integration of the PX4 internal communication architecture with the companion systems lead us to explore the benefits of DDS (Data Distribution Service) standard and, for that reason, implement a bridge that allows PX4 uORB publisher/subscriber architecture to connect to RTPS (Real Time Publish-Subscribe) protocol participants over the same DDS standard layer, while looking to gradually abandon the usage of Mavlink in companion computer links.

As being the default middleware of ROS2, eProsima Fast-RTPS was the chosen RTPS implementation to bridge PX4 uORB topics with ROS 2 nodes.

This presentation will show how the px4_ros_com, a ROS2 package for bridging PX4 and ROS2 through a micro-RTPS bridge - a slimmed down RTPS point-to-point link using micro-RTPS (client/FCU side) and Fast-CDR (agent/companion side) for serialization and deserialization - is architecture and implemented, how can it be used and provide an overall status about its current development state and future works. It will also be offered a pros/cons comparison between using RTPS-supported and Mavlink-supported communication in PX4 and companion computer links.
Captions: 
	00:00:17,130 --> 00:00:21,270
okay good morning everyone quite nice

00:00:20,490 --> 00:00:24,539
room here

00:00:21,270 --> 00:00:28,919
nice to see like these big community of

00:00:24,539 --> 00:00:31,759
px4 developers here today welcome to my

00:00:28,919 --> 00:00:34,110
session it's about rose to power px4

00:00:31,759 --> 00:00:37,580
it's the last session before lunch so

00:00:34,110 --> 00:00:37,580
I'll try not to kill anyone

00:00:38,150 --> 00:00:44,670
so create a presentation about me so I'm

00:00:41,960 --> 00:00:47,519
I've been doing the x4 upstream

00:00:44,670 --> 00:00:52,289
contributions not just big for but also

00:00:47,519 --> 00:00:55,760
Mavs link since 2015 and I've been doing

00:00:52,289 --> 00:00:58,770
containers as well of Mavros since then

00:00:55,760 --> 00:01:03,030
it was created in 2014 and I've been

00:00:58,770 --> 00:01:10,229
doing commentaries of my rows since next

00:01:03,030 --> 00:01:12,649
year also I'm a mini parent consultant

00:01:10,229 --> 00:01:17,490
I've been working with many companies

00:01:12,649 --> 00:01:20,460
since 2015 as well mainly integrated

00:01:17,490 --> 00:01:22,229
into a group which is called drone crew

00:01:20,460 --> 00:01:25,890
I don't know if I want to desert of it

00:01:22,229 --> 00:01:30,240
was founded by okay was funded by James

00:01:25,890 --> 00:01:32,280
Gobert in 2015 and I've been working

00:01:30,240 --> 00:01:37,110
with him is all and some other projects

00:01:32,280 --> 00:01:42,030
I create also current solutions are IO

00:01:37,110 --> 00:01:44,759
which is something quite new we are also

00:01:42,030 --> 00:01:48,390
working as consultants in other

00:01:44,759 --> 00:01:53,100
companies as well and if no one's heard

00:01:48,390 --> 00:01:55,579
about these the.21 then just go to

00:01:53,100 --> 00:02:00,540
github you'll see some commits and some

00:01:55,579 --> 00:02:04,560
annoying discussions there as well so 20

00:02:00,540 --> 00:02:09,420
JSC 21 so quick agenda the idea behind

00:02:04,560 --> 00:02:13,709
this presentation is actually present

00:02:09,420 --> 00:02:17,430
you what is the current state of the px4

00:02:13,709 --> 00:02:20,400
we'd raus raus to slash GDS you can see

00:02:17,430 --> 00:02:24,090
it like this integration and also

00:02:20,400 --> 00:02:26,400
explained to you our how are we doing

00:02:24,090 --> 00:02:28,260
this integration and what are the

00:02:26,400 --> 00:02:31,040
technologies behind it so I will start

00:02:28,260 --> 00:02:34,579
with a quick introduction of what is

00:02:31,040 --> 00:02:37,670
yes how it works our faster GPS comes

00:02:34,579 --> 00:02:41,599
into the game as well and all this all

00:02:37,670 --> 00:02:45,400
feeds into rows to then explain what is

00:02:41,599 --> 00:02:50,269
our motivation behind actually using

00:02:45,400 --> 00:02:53,930
Ross to DDS and a quick comparison

00:02:50,269 --> 00:02:55,909
between MAV link versus our GPS EDS so I

00:02:53,930 --> 00:02:59,629
can probably answer some questions that

00:02:55,909 --> 00:03:02,900
were made before as well and then a

00:02:59,629 --> 00:03:05,599
quick explanation of all these bridges

00:03:02,900 --> 00:03:06,889
are currently permitted and how they

00:03:05,599 --> 00:03:09,169
work

00:03:06,889 --> 00:03:12,470
comparison between Mavros and pigs for

00:03:09,169 --> 00:03:15,829
Rosco probably you have you want to know

00:03:12,470 --> 00:03:20,150
as well why why do we want to bring

00:03:15,829 --> 00:03:23,959
these pigs for Roskam bridge and as a

00:03:20,150 --> 00:03:28,060
replacement of Mavros and the future of

00:03:23,959 --> 00:03:33,769
this implementation and a quick summary

00:03:28,060 --> 00:03:36,680
so according the DDS foundation DDS

00:03:33,769 --> 00:03:40,220
Foundation website data distribution

00:03:36,680 --> 00:03:42,260
service or DDS it's a middle protocol

00:03:40,220 --> 00:03:44,329
and APR standard for data centric

00:03:42,260 --> 00:03:49,310
connectivity from the object Management

00:03:44,329 --> 00:03:51,919
Group and I wanted to quickly focus on

00:03:49,310 --> 00:03:55,069
these this expression which is

00:03:51,919 --> 00:03:57,949
middleware protocol API standard and

00:03:55,069 --> 00:04:00,199
data centric from now on on the

00:03:57,949 --> 00:04:04,669
presentation okay because they these are

00:04:00,199 --> 00:04:09,079
basically the core components of DDS it

00:04:04,669 --> 00:04:12,470
Bay it allows us to have a system where

00:04:09,079 --> 00:04:16,090
all the there's an integration on that

00:04:12,470 --> 00:04:19,519
system of different components in in a

00:04:16,090 --> 00:04:22,789
infrastructure that guarantees us high

00:04:19,519 --> 00:04:25,220
confidence and reliability direct

00:04:22,789 --> 00:04:28,520
connectivity and low latency and as well

00:04:25,220 --> 00:04:30,830
as calibre architecture and it's mainly

00:04:28,520 --> 00:04:36,110
targets it'sa standard mainly targeted

00:04:30,830 --> 00:04:38,930
to mission-critical applications so DDS

00:04:36,110 --> 00:04:42,260
is a data strength implementation so

00:04:38,930 --> 00:04:44,389
most middleware basically works by

00:04:42,260 --> 00:04:44,900
sending information between applications

00:04:44,389 --> 00:04:50,290
and sis

00:04:44,900 --> 00:04:53,350
right so this data centricity of DDS

00:04:50,290 --> 00:04:55,970
ensures that all these messages

00:04:53,350 --> 00:04:59,690
basically include some contextual

00:04:55,970 --> 00:05:01,960
information that any application that is

00:04:59,690 --> 00:05:04,820
connected in the same DDS domain

00:05:01,960 --> 00:05:07,910
understands the data that it receives so

00:05:04,820 --> 00:05:10,490
basically it allows to any application

00:05:07,910 --> 00:05:12,770
that is kinetic under the same DD

00:05:10,490 --> 00:05:14,600
estimate to understand how the domain is

00:05:12,770 --> 00:05:17,510
structure and what kind of information

00:05:14,600 --> 00:05:20,420
it's actually receiving and was actually

00:05:17,510 --> 00:05:23,450
publishing it what type of application

00:05:20,420 --> 00:05:26,000
is actually publishing that data etc so

00:05:23,450 --> 00:05:30,890
usually programmers use this data

00:05:26,000 --> 00:05:35,060
centric data centric middleware just to

00:05:30,890 --> 00:05:38,330
write code that specifies basically when

00:05:35,060 --> 00:05:42,140
and when to share that data and then

00:05:38,330 --> 00:05:44,030
basically they write the code to share

00:05:42,140 --> 00:05:47,230
the data values so they don't actually

00:05:44,030 --> 00:05:50,750
have to worry about all the message

00:05:47,230 --> 00:05:53,120
infrastructure works they just need to

00:05:50,750 --> 00:05:57,260
worry about the data and how and when to

00:05:53,120 --> 00:05:59,600
publish it so this this this graph here

00:05:57,260 --> 00:06:02,060
so you have data writers and there are

00:05:59,600 --> 00:06:04,700
readers you can basically associate them

00:06:02,060 --> 00:06:09,730
with publishers for the case of data

00:06:04,700 --> 00:06:14,540
writers and data readers as subscribers

00:06:09,730 --> 00:06:18,500
so the other thing is DDS also

00:06:14,540 --> 00:06:21,770
implements quality of service mechanisms

00:06:18,500 --> 00:06:26,510
and they're basically specifications for

00:06:21,770 --> 00:06:29,510
liability system health and security so

00:06:26,510 --> 00:06:32,960
these are kind of a flexible quality of

00:06:29,510 --> 00:06:35,690
service mechanism and the developer just

00:06:32,960 --> 00:06:37,250
needs to set the key the quality of

00:06:35,690 --> 00:06:40,370
service parameters for the desire

00:06:37,250 --> 00:06:43,670
control mechanism so we dis quality of

00:06:40,370 --> 00:06:45,260
services for example there there are

00:06:43,670 --> 00:06:48,080
many examples of quality of services

00:06:45,260 --> 00:06:51,080
mechanisms but for example if the

00:06:48,080 --> 00:06:53,210
messages don't don't always reach their

00:06:51,080 --> 00:06:56,090
intended destinations for example the

00:06:53,210 --> 00:06:58,760
middleware for example implements some

00:06:56,090 --> 00:07:00,770
kind of reliability

00:06:58,760 --> 00:07:04,580
when that's that's required or for

00:07:00,770 --> 00:07:08,840
example if the total data size of that

00:07:04,580 --> 00:07:13,010
is being exchanged is huge DDS basically

00:07:08,840 --> 00:07:15,560
or intelligently filters and sends only

00:07:13,010 --> 00:07:18,400
the data to each endpoint that it's

00:07:15,560 --> 00:07:21,620
really required so those kind of

00:07:18,400 --> 00:07:26,080
mechanisms that you can find on under

00:07:21,620 --> 00:07:29,270
DDS as quality of service also DDS

00:07:26,080 --> 00:07:32,600
provides the dynamic this dynamic

00:07:29,270 --> 00:07:35,480
discovery mechanism which is being used

00:07:32,600 --> 00:07:38,170
by Ross too as well so basically one

00:07:35,480 --> 00:07:42,230
application don't actually have to

00:07:38,170 --> 00:07:44,210
configure its endpoints because there's

00:07:42,230 --> 00:07:46,700
a discovery mechanism implemented by DDS

00:07:44,210 --> 00:07:51,800
that allows to find all the publishers

00:07:46,700 --> 00:07:54,140
and subscribers under the same domain so

00:07:51,800 --> 00:07:57,830
then it comes a prozium of faster GPS

00:07:54,140 --> 00:08:01,490
and faster GPS by itself it's a C++

00:07:57,830 --> 00:08:02,920
implementation of the our TPS protocol

00:08:01,490 --> 00:08:05,840
which is so-called the real-time

00:08:02,920 --> 00:08:09,280
publish/subscribe protocol and it

00:08:05,840 --> 00:08:11,990
basically provides a way or a

00:08:09,280 --> 00:08:14,540
communication middleware based on

00:08:11,990 --> 00:08:18,260
publishers and subscribers that works

00:08:14,540 --> 00:08:22,370
quite well under unreliable transport

00:08:18,260 --> 00:08:26,810
protocols as as the the case of UDP UDP

00:08:22,370 --> 00:08:32,030
our TPS by itself it's it found its

00:08:26,810 --> 00:08:34,060
fruits on the industrial automation it

00:08:32,030 --> 00:08:36,590
was specifically developed to support

00:08:34,060 --> 00:08:41,419
the requirements of data distribution

00:08:36,590 --> 00:08:45,590
systems and currently and and when it

00:08:41,419 --> 00:08:48,110
was created he was created so to find a

00:08:45,590 --> 00:08:50,510
standard or create a standard for

00:08:48,110 --> 00:08:54,380
publish and subscribe wire protocol that

00:08:50,510 --> 00:08:58,810
closely match those of DDS so currently

00:08:54,380 --> 00:09:02,270
our TPS by itself it's the wire protocol

00:08:58,810 --> 00:09:05,540
underneath DDS so it allows that

00:09:02,270 --> 00:09:07,520
different DDS vendors interoperate

00:09:05,540 --> 00:09:11,870
between each other using this same wire

00:09:07,520 --> 00:09:12,950
protocol from faster these faster GPS

00:09:11,870 --> 00:09:14,270
from where protein

00:09:12,950 --> 00:09:17,090
which is the one that we are actually

00:09:14,270 --> 00:09:20,600
using in px4 that's why I'm referring to

00:09:17,090 --> 00:09:23,540
it it's compliant with the current our

00:09:20,600 --> 00:09:25,250
TPS 22.2 and as I said it's

00:09:23,540 --> 00:09:27,560
interoperable with other DDS

00:09:25,250 --> 00:09:33,020
implementation as the case of connects

00:09:27,560 --> 00:09:36,530
DDS opensplice so the key features of

00:09:33,020 --> 00:09:38,500
foster GPS are mainly light it's the

00:09:36,530 --> 00:09:41,060
case it's the fact that it's lightweight

00:09:38,500 --> 00:09:44,840
it's a simplest path implementation

00:09:41,060 --> 00:09:49,370
though it provides an RPC layer that is

00:09:44,840 --> 00:09:52,130
available through a prism RPL RPC it

00:09:49,370 --> 00:09:57,110
meets I true put requirements of every

00:09:52,130 --> 00:09:59,920
data exchange it also meets real-time

00:09:57,110 --> 00:10:04,810
requirements of time critical systems

00:09:59,920 --> 00:10:07,550
with latency measured in microseconds

00:10:04,810 --> 00:10:10,370
it's well fitted as you can see well

00:10:07,550 --> 00:10:13,820
feed it under to intermittent unreliable

00:10:10,370 --> 00:10:18,470
and low bandwidth later links provides

00:10:13,820 --> 00:10:22,340
security over networks such as Wi-Fi and

00:10:18,470 --> 00:10:26,900
radio it's fully open source with apache

00:10:22,340 --> 00:10:28,970
license and this is basically the most

00:10:26,900 --> 00:10:32,690
important part it is the default

00:10:28,970 --> 00:10:38,210
middleware or frost - and it's aligned

00:10:32,690 --> 00:10:41,270
with its development roadmap so a quick

00:10:38,210 --> 00:10:43,880
one on rusty so I pick up this this

00:10:41,270 --> 00:10:46,370
sentence from dark which it's you can

00:10:43,880 --> 00:10:49,070
find under the design documents of Rosco

00:10:46,370 --> 00:10:51,380
which says the goal of frost to project

00:10:49,070 --> 00:10:54,530
is to leverage what is great about rows

00:10:51,380 --> 00:10:56,570
1 and improve what isn't so I'm not

00:10:54,530 --> 00:10:59,920
talking about rose to that much because

00:10:56,570 --> 00:11:03,620
slowly already did that key features

00:10:59,920 --> 00:11:08,510
were already presented as well so I'm

00:11:03,620 --> 00:11:11,750
also skipping this so px4 px4 not GPS

00:11:08,510 --> 00:11:14,570
why we wanted to take advantage of

00:11:11,750 --> 00:11:16,280
course so one of the first things is we

00:11:14,570 --> 00:11:19,580
want to take advantage of the benefits

00:11:16,280 --> 00:11:21,500
of the DDS middleware so you know what I

00:11:19,580 --> 00:11:25,920
already refer to them so high confidence

00:11:21,500 --> 00:11:28,500
low latency scalable architecture

00:11:25,920 --> 00:11:31,400
we were we also wanted to have a more

00:11:28,500 --> 00:11:34,050
clear straightforward point to point or

00:11:31,400 --> 00:11:39,240
multi-point to multi-point data exchange

00:11:34,050 --> 00:11:42,480
between what is the px4 internals using

00:11:39,240 --> 00:11:48,480
micro harp and the companion computer

00:11:42,480 --> 00:11:50,250
side using Ross to DDS also we wanted to

00:11:48,480 --> 00:11:52,640
make sure that we had a clear separation

00:11:50,250 --> 00:11:56,540
between what is the madelung stream

00:11:52,640 --> 00:12:00,050
through barricaded to telemetry

00:11:56,540 --> 00:12:04,700
telemetry links and DDS

00:12:00,050 --> 00:12:07,920
used for links with the companion site

00:12:04,700 --> 00:12:10,140
at the same time using faster GPS we can

00:12:07,920 --> 00:12:12,510
facilitate of course the integration

00:12:10,140 --> 00:12:16,339
we'd with Ross - because it's the

00:12:12,510 --> 00:12:20,580
default middleware and based on this we

00:12:16,339 --> 00:12:22,740
wanted to use organic at least a near

00:12:20,580 --> 00:12:26,270
optimal performance standard which is

00:12:22,740 --> 00:12:28,529
DDS for mission-critical applications

00:12:26,270 --> 00:12:32,070
specifically for applications that

00:12:28,529 --> 00:12:35,459
require external computational resources

00:12:32,070 --> 00:12:36,860
such as obstacle avoidance visual

00:12:35,459 --> 00:12:41,490
inertial odometry path planning

00:12:36,860 --> 00:12:44,910
artificial intelligence so maverick

00:12:41,490 --> 00:12:47,580
versus DDS so not going to like focus

00:12:44,910 --> 00:12:51,660
too much on this but just take into

00:12:47,580 --> 00:12:54,450
consideration that MAV link is dedicated

00:12:51,660 --> 00:12:56,330
for communication with drones it was

00:12:54,450 --> 00:13:01,230
built for being lightweight and

00:12:56,330 --> 00:13:04,230
efficient but fortunately it doesn't and

00:13:01,230 --> 00:13:06,480
in its implementation under run its

00:13:04,230 --> 00:13:09,600
implementation doesn't have quality of

00:13:06,480 --> 00:13:11,670
service mechanisms in the other hand DDS

00:13:09,600 --> 00:13:14,070
is not a communication protocol is

00:13:11,670 --> 00:13:16,560
mostly a middleware with an API and it's

00:13:14,070 --> 00:13:20,040
data centric and it's designed for

00:13:16,560 --> 00:13:22,860
reliability robustness performance and

00:13:20,040 --> 00:13:26,010
scalability for IOT both for industrial

00:13:22,860 --> 00:13:30,060
and consumer applications and basically

00:13:26,010 --> 00:13:32,720
it's well proven in mission critical

00:13:30,060 --> 00:13:37,550
systems like smart transportation

00:13:32,720 --> 00:13:40,060
healthcare and smart energy for example

00:13:37,550 --> 00:13:42,610
so we come up for the

00:13:40,060 --> 00:13:45,340
the the bridge itself and oh it's

00:13:42,610 --> 00:13:48,430
structure so it's also known as micro

00:13:45,340 --> 00:13:52,360
GPS bridge the first implementation was

00:13:48,430 --> 00:13:54,310
in 2017 from April Zima and that's has

00:13:52,360 --> 00:13:56,830
been updated and received several

00:13:54,310 --> 00:13:59,050
updates since then especially on the

00:13:56,830 --> 00:14:03,280
code generators for each part of the of

00:13:59,050 --> 00:14:05,050
the of the bridge itself so how does

00:14:03,280 --> 00:14:07,750
this bridge works it's quite simple so

00:14:05,050 --> 00:14:09,490
on the px4 side we have the new orb

00:14:07,750 --> 00:14:11,890
layer so all the publishers and

00:14:09,490 --> 00:14:12,670
subscribers that are connected to each

00:14:11,890 --> 00:14:14,590
module

00:14:12,670 --> 00:14:17,920
so there are publishers and there are

00:14:14,590 --> 00:14:19,630
subscribers that you want to get so data

00:14:17,920 --> 00:14:21,460
from those publishers and subscribers

00:14:19,630 --> 00:14:25,810
that you want to get on this side as

00:14:21,460 --> 00:14:27,610
well so if a new orb or if you publish

00:14:25,810 --> 00:14:30,220
for a new work topic and you want to get

00:14:27,610 --> 00:14:32,500
the data in this side there's a client's

00:14:30,220 --> 00:14:35,110
implementation of the micro GPS bridge

00:14:32,500 --> 00:14:39,040
on the px4 side that subscribes to that

00:14:35,110 --> 00:14:42,010
new orb topic serializes into using the

00:14:39,040 --> 00:14:46,870
CDR protocol serializes that met that

00:14:42,010 --> 00:14:50,830
data and writes it to a new water UDP

00:14:46,870 --> 00:14:53,050
link where an agent on the companion

00:14:50,830 --> 00:14:55,810
computer side receives that data and the

00:14:53,050 --> 00:14:59,500
processes of obviously is the opposite

00:14:55,810 --> 00:15:02,440
so it reads it dis utilizes and then it

00:14:59,500 --> 00:15:05,230
publishes for in the faster GPS layer

00:15:02,440 --> 00:15:08,830
for for TDs so if you have an

00:15:05,230 --> 00:15:10,570
application like running on Ross - you

00:15:08,830 --> 00:15:14,230
can basically subscribe to that data

00:15:10,570 --> 00:15:16,660
directly from the the faster GPS layer

00:15:14,230 --> 00:15:19,090
where is being published of course the

00:15:16,660 --> 00:15:24,160
the other way around is actually

00:15:19,090 --> 00:15:26,440
possible as well just to refer to this

00:15:24,160 --> 00:15:29,770
all of these that I'm presenting now and

00:15:26,440 --> 00:15:32,590
what you're seeing after it as well it's

00:15:29,770 --> 00:15:35,500
all documented on the dev guide so I'm

00:15:32,590 --> 00:15:38,020
doing a quick quick presentation of it

00:15:35,500 --> 00:15:42,340
but there are more details about this on

00:15:38,020 --> 00:15:45,910
on these on this link so just a quick

00:15:42,340 --> 00:15:48,550
explanation so how does this all that

00:15:45,910 --> 00:15:52,230
all does this get built on all these

00:15:48,550 --> 00:15:54,810
does this work so initially

00:15:52,230 --> 00:15:57,680
the build process needs to check if

00:15:54,810 --> 00:16:00,240
there's actually an RT PSID

00:15:57,680 --> 00:16:02,820
allocated for that message for a

00:16:00,240 --> 00:16:05,700
specific new or message because in the

00:16:02,820 --> 00:16:10,140
RTP a stream every every topic needs to

00:16:05,700 --> 00:16:11,250
have an ID associated with after that it

00:16:10,140 --> 00:16:13,260
actually checks

00:16:11,250 --> 00:16:15,600
where are the topics or the new or

00:16:13,260 --> 00:16:18,720
topics that are supposed to be published

00:16:15,600 --> 00:16:21,960
or received from the first are TPS

00:16:18,720 --> 00:16:24,420
stream after checking that is actually

00:16:21,960 --> 00:16:28,020
going to generate the IDL's which is

00:16:24,420 --> 00:16:30,780
basically files that represented the

00:16:28,020 --> 00:16:34,520
interface description language which is

00:16:30,780 --> 00:16:38,490
required on on the faster gps layer

00:16:34,520 --> 00:16:41,820
after that and using those generate the

00:16:38,490 --> 00:16:45,410
IDL files is going to generate the code

00:16:41,820 --> 00:16:49,830
base on templates for both clients and

00:16:45,410 --> 00:16:52,380
agent of that micro GPS bridge and the

00:16:49,830 --> 00:16:55,200
last process is actually build the

00:16:52,380 --> 00:17:00,000
client immediately on the px4 side while

00:16:55,200 --> 00:17:02,160
the agent code it's stored under the

00:17:00,000 --> 00:17:04,980
build folder and it needs to be built

00:17:02,160 --> 00:17:08,040
manually by the the user or the

00:17:04,980 --> 00:17:11,430
developer because it's the build process

00:17:08,040 --> 00:17:15,570
is specific for the operating system or

00:17:11,430 --> 00:17:17,670
the machine that you are working on so

00:17:15,570 --> 00:17:20,970
the build process for dating code is

00:17:17,670 --> 00:17:23,100
manually triggered but then you can for

00:17:20,970 --> 00:17:25,650
testing these you can actually generate

00:17:23,100 --> 00:17:28,830
the listener application it's optional

00:17:25,650 --> 00:17:32,400
but you can actually generate so so to

00:17:28,830 --> 00:17:34,770
actually test if the agent and the

00:17:32,400 --> 00:17:40,070
client are actually communicating and

00:17:34,770 --> 00:17:40,070
you are getting data on the our GPS side

00:17:42,380 --> 00:17:49,800
so then it come then we have the raw

00:17:46,500 --> 00:17:54,240
steel parts and the rostov part comes in

00:17:49,800 --> 00:17:58,680
a way that it represents a consumer of

00:17:54,240 --> 00:18:01,610
the micro our GPS bridge and basically

00:17:58,680 --> 00:18:04,890
the structure or the schematic for the

00:18:01,610 --> 00:18:05,880
for the for for for the bridge itself

00:18:04,890 --> 00:18:08,250
it's

00:18:05,880 --> 00:18:10,380
basically the same as I was explained

00:18:08,250 --> 00:18:14,100
before the main difference here is that

00:18:10,380 --> 00:18:17,490
you have lost you as a faster cheaper

00:18:14,100 --> 00:18:20,820
application on the system in terms of

00:18:17,490 --> 00:18:23,250
the build process itself one the the

00:18:20,820 --> 00:18:26,490
main difference is that all of the agent

00:18:23,250 --> 00:18:29,970
code is actually and 'old and produced

00:18:26,490 --> 00:18:33,330
and built on a package which is called

00:18:29,970 --> 00:18:35,190
the px4 Roskam and all the message

00:18:33,330 --> 00:18:37,410
definitions that are required to

00:18:35,190 --> 00:18:39,810
actually generate the code for the rasta

00:18:37,410 --> 00:18:43,200
side are stored under px4 messages

00:18:39,810 --> 00:18:46,680
repository again everything is playing

00:18:43,200 --> 00:18:49,770
on the dev guide and quickly just sweep

00:18:46,680 --> 00:18:51,420
around this px4 Roskam as I said

00:18:49,770 --> 00:18:54,840
generates and allows building gauge

00:18:51,420 --> 00:18:57,270
inside for the micro GPS bridge and then

00:18:54,840 --> 00:19:00,720
by by consequence in it allows you to

00:18:57,270 --> 00:19:02,700
publish the data to rows 2 and then a px

00:19:00,720 --> 00:19:05,400
for messages basically contains the

00:19:02,700 --> 00:19:07,230
message definitions that are required to

00:19:05,400 --> 00:19:12,750
generate the ideal files that are

00:19:07,230 --> 00:19:14,610
consumed by the agents on px4 Roskam the

00:19:12,750 --> 00:19:16,740
build process for this quite simple

00:19:14,610 --> 00:19:19,620
first we need to actually have a way of

00:19:16,740 --> 00:19:22,680
deploying all of these generated scripts

00:19:19,620 --> 00:19:26,340
that are required on the px4 Roskam site

00:19:22,680 --> 00:19:29,810
and those are actually deployed on px

00:19:26,340 --> 00:19:33,690
for continuous integration system and

00:19:29,810 --> 00:19:36,420
both Cole January and Rossi messages are

00:19:33,690 --> 00:19:39,240
always a better updated on these

00:19:36,420 --> 00:19:42,530
respective packages every time there is

00:19:39,240 --> 00:19:45,360
a change on on upstream TX for master

00:19:42,530 --> 00:19:47,700
the nabo process is quite simple the X

00:19:45,360 --> 00:19:49,980
for messages generates the LDL files

00:19:47,700 --> 00:19:52,050
every time they built and also the type

00:19:49,980 --> 00:19:55,160
support and it if the interface code for

00:19:52,050 --> 00:19:58,230
the rasta side while the X for Roskam

00:19:55,160 --> 00:20:00,600
generates and builds agent code while

00:19:58,230 --> 00:20:02,760
out I also building some example notes

00:20:00,600 --> 00:20:05,970
that were put in there so you can see

00:20:02,760 --> 00:20:08,370
how all the testings and and and they

00:20:05,970 --> 00:20:12,570
have an example for the listener or for

00:20:08,370 --> 00:20:15,480
a publisher code so where does rose one

00:20:12,570 --> 00:20:17,810
comes here so Rose one as you know

00:20:15,480 --> 00:20:19,539
doesn't run over DDS has a different

00:20:17,810 --> 00:20:24,159
middleware we

00:20:19,539 --> 00:20:26,979
was written by my scratch by also srf so

00:20:24,159 --> 00:20:30,190
how do we integrate these with the our

00:20:26,979 --> 00:20:32,320
bridge so we also something called the

00:20:30,190 --> 00:20:34,029
Rose one dynamic or the Rose one bridge

00:20:32,320 --> 00:20:36,850
which can be static or dynamic we

00:20:34,029 --> 00:20:40,119
actually use the dynamic to actually

00:20:36,850 --> 00:20:42,609
allow to connect rose to and Rose one

00:20:40,119 --> 00:20:45,340
stop rose on topics and that's that

00:20:42,609 --> 00:20:47,320
allows you to actually use your nodes

00:20:45,340 --> 00:20:51,940
that are actually implemented under rows

00:20:47,320 --> 00:20:54,970
one and communicate with the px4 site so

00:20:51,940 --> 00:20:58,210
just a quick sweep so to understand why

00:20:54,970 --> 00:21:00,309
why should we use px4 Roskam or why

00:20:58,210 --> 00:21:04,239
should we take advantage of px4 Roskam

00:21:00,309 --> 00:21:08,049
so it uses the benefits of VDS and

00:21:04,239 --> 00:21:12,159
direct integration with Rose to Jared

00:21:08,049 --> 00:21:15,129
I'm st. RIT theoretically is faster with

00:21:12,159 --> 00:21:17,529
lower latency over the link then Mavros

00:21:15,129 --> 00:21:21,849
it's still something to be tested but

00:21:17,529 --> 00:21:23,529
theoretically it should be faster its

00:21:21,849 --> 00:21:26,440
adder as a direct and more tight

00:21:23,529 --> 00:21:28,499
connection with between the px4

00:21:26,440 --> 00:21:32,909
internals and the awkward components and

00:21:28,499 --> 00:21:36,460
can be tied to other DDS participants

00:21:32,909 --> 00:21:39,609
that are connected under the same DD

00:21:36,460 --> 00:21:44,349
estimate and MAV SDK can be an example

00:21:39,609 --> 00:21:47,499
of that in the other way so it actually

00:21:44,349 --> 00:21:49,960
obliges that you have want one

00:21:47,499 --> 00:21:52,330
conversion between the new your topics

00:21:49,960 --> 00:21:54,970
and rows messages so you can actually

00:21:52,330 --> 00:21:58,119
you cannot actually use row standard

00:21:54,970 --> 00:22:00,159
messages in this sense and for

00:21:58,119 --> 00:22:02,710
connecting rows one as I said you need

00:22:00,159 --> 00:22:05,590
actually in another bridge a secondary

00:22:02,710 --> 00:22:08,919
bridge to to actually get data from the

00:22:05,590 --> 00:22:12,519
rows one cycle Mavros in the other hand

00:22:08,919 --> 00:22:16,929
is a long tested an additional proven

00:22:12,519 --> 00:22:20,039
application it basically parses Mavic

00:22:16,929 --> 00:22:23,529
messages and uses standard may have

00:22:20,039 --> 00:22:28,299
standard rows messages and allows

00:22:23,529 --> 00:22:30,730
network rebroadcast as a feature but

00:22:28,299 --> 00:22:33,250
it's not future-proof so currently there

00:22:30,730 --> 00:22:37,059
are no plans or no development

00:22:33,250 --> 00:22:40,780
going on currently for updating the API

00:22:37,059 --> 00:22:42,460
to use Ross - it's directly dependent on

00:22:40,780 --> 00:22:44,590
map link and of course of its

00:22:42,460 --> 00:22:46,510
limitations and doesn't tie directly

00:22:44,590 --> 00:22:50,500
with the px4 internals

00:22:46,510 --> 00:22:53,640
so no granularity and no interest no

00:22:50,500 --> 00:22:58,030
granular G for intersection and control

00:22:53,640 --> 00:22:59,890
feature next steps so first thing I'll

00:22:58,030 --> 00:23:02,559
be working on together with the

00:22:59,890 --> 00:23:05,190
avoidance team is to actually have a

00:23:02,559 --> 00:23:09,309
proof of concept of this working weed

00:23:05,190 --> 00:23:11,799
avoidance so they have avoidance first

00:23:09,309 --> 00:23:14,710
running on rows one but connected with

00:23:11,799 --> 00:23:18,390
px4 through the micro RCPS reach but

00:23:14,710 --> 00:23:23,260
then the plan is actually implement

00:23:18,390 --> 00:23:25,510
avoidance under Ross - of course the

00:23:23,260 --> 00:23:27,190
that your ethical part needs to be

00:23:25,510 --> 00:23:32,799
proven so I'll be doing some to boots

00:23:27,190 --> 00:23:34,720
latency and security tests meter we need

00:23:32,799 --> 00:23:37,840
a protocol splitter for the agent side

00:23:34,720 --> 00:23:40,570
that allows us that in the same serial

00:23:37,840 --> 00:23:45,340
link we can actually the topple and

00:23:40,570 --> 00:23:47,230
parse both madelung and faster GPS

00:23:45,340 --> 00:23:52,630
messages which is currently not possible

00:23:47,230 --> 00:23:55,000
and in in specifically for the the

00:23:52,630 --> 00:23:58,990
client side of the implementation on the

00:23:55,000 --> 00:24:01,600
on the raw side as solely as refer

00:23:58,990 --> 00:24:04,210
there's some good improvements and

00:24:01,600 --> 00:24:08,140
there's some work going on on the micro

00:24:04,210 --> 00:24:11,020
rows so we are aiming to implement

00:24:08,140 --> 00:24:15,970
something similar or use the benefits of

00:24:11,020 --> 00:24:19,659
micro rows to actually have px4 running

00:24:15,970 --> 00:24:22,659
over DDS but with micro Ross running as

00:24:19,659 --> 00:24:25,419
well on the px4 side not just with a

00:24:22,659 --> 00:24:27,850
parsing layer or with a module that does

00:24:25,419 --> 00:24:35,710
dis parsing but I have Ross - embedded

00:24:27,850 --> 00:24:39,190
on px for long term so the main idea

00:24:35,710 --> 00:24:43,000
here is we can or we are we will be able

00:24:39,190 --> 00:24:46,809
to replace mavs linked with the Ross -

00:24:43,000 --> 00:24:50,889
DDS for data exchange for onboard

00:24:46,809 --> 00:24:53,529
components and as I said as px4 as a

00:24:50,889 --> 00:25:00,009
multi note roaster subsystem so it's

00:24:53,529 --> 00:25:09,940
directly integrated we'd DDS so I asked

00:25:00,009 --> 00:25:12,490
if anyone has questions so my question

00:25:09,940 --> 00:25:14,649
is more generally related to DDS and the

00:25:12,490 --> 00:25:19,240
object management group so as someone

00:25:14,649 --> 00:25:21,039
moving from handwritten notes and

00:25:19,240 --> 00:25:23,830
communication over UNIX sockets and

00:25:21,039 --> 00:25:27,999
trying to evaluate different middleware

00:25:23,830 --> 00:25:29,769
or just to move to Roscoe when you when

00:25:27,999 --> 00:25:32,289
you go and read about DDS it's really

00:25:29,769 --> 00:25:34,899
confusing that oMG does not by itself

00:25:32,289 --> 00:25:36,580
provide a reference implementation and C

00:25:34,899 --> 00:25:38,919
or C++ but you have all these different

00:25:36,580 --> 00:25:42,759
vendors with different implementations

00:25:38,919 --> 00:25:44,289
and it's not really clear who or who in

00:25:42,759 --> 00:25:47,619
the industry is using which one or how

00:25:44,289 --> 00:25:49,629
mature a particular implementation is or

00:25:47,619 --> 00:25:51,759
whether whether it will work on like

00:25:49,629 --> 00:25:54,580
really small systems like raspberry pi

00:25:51,759 --> 00:25:56,919
zero or something so what are your

00:25:54,580 --> 00:25:58,690
opinions on that and how mature and

00:25:56,919 --> 00:26:01,990
production-ready do you think faster dps

00:25:58,690 --> 00:26:03,519
is other than that your communication

00:26:01,990 --> 00:26:06,490
layer does it only work on serial and

00:26:03,519 --> 00:26:08,259
UDP TCP etc or does it also work on UNIX

00:26:06,490 --> 00:26:12,999
sockets or say inter-process shared

00:26:08,259 --> 00:26:15,700
memory it's yeah so it's supposed to

00:26:12,999 --> 00:26:18,789
also work with other kinds of links not

00:26:15,700 --> 00:26:21,820
just network links or serial links so

00:26:18,789 --> 00:26:24,610
yes and about the first question so we

00:26:21,820 --> 00:26:27,610
aim to use faster GPS as it's the

00:26:24,610 --> 00:26:30,429
current middleware for us to as well we

00:26:27,610 --> 00:26:32,049
yeah that's also a good question so why

00:26:30,429 --> 00:26:34,450
don't we explore other DDS

00:26:32,049 --> 00:26:36,190
implementations probably cuz there's no

00:26:34,450 --> 00:26:39,190
one left to do it but it's also

00:26:36,190 --> 00:26:41,470
something that we may consider evaluate

00:26:39,190 --> 00:26:43,929
based on the resources as well so but

00:26:41,470 --> 00:26:47,440
currently we are aimed to foster GPS

00:26:43,929 --> 00:26:49,899
because actually stuff I presume started

00:26:47,440 --> 00:26:51,850
working with us with first our TPS and

00:26:49,899 --> 00:26:53,740
now we're moving on we first started

00:26:51,850 --> 00:26:56,159
years since its the middleware for

00:26:53,740 --> 00:26:56,159
Roscoe

00:26:57,950 --> 00:27:15,029
it's so the question is if faster GPS is

00:27:12,960 --> 00:27:19,140
mature enough to be used in industrial

00:27:15,029 --> 00:27:21,269
components and if it is certified yeah

00:27:19,140 --> 00:27:22,890
it's it's supposedly certified yes and

00:27:21,269 --> 00:27:25,710
it's used on Ross too based on that

00:27:22,890 --> 00:27:32,639
conception but maybe it's all we can

00:27:25,710 --> 00:27:35,100
confirm that OMG doesn't really do

00:27:32,639 --> 00:27:36,510
certification they will do compatibility

00:27:35,100 --> 00:27:38,399
tests they have like their annual

00:27:36,510 --> 00:27:40,409
meeting and they sit down and they check

00:27:38,399 --> 00:27:43,830
that different all the DD s's will talk

00:27:40,409 --> 00:27:47,250
to each other from our integration tests

00:27:43,830 --> 00:27:48,630
we actually cross cross validate all the

00:27:47,250 --> 00:27:52,049
different vendors that we test with

00:27:48,630 --> 00:27:55,039
we're testing with opensplice RTI

00:27:52,049 --> 00:27:57,360
connect and he prasena most fast our TPS

00:27:55,039 --> 00:27:58,919
we have found a lot of corner cases that

00:27:57,360 --> 00:28:00,389
we're not covered in their compatibility

00:27:58,919 --> 00:28:01,919
test because they basically send like

00:28:00,389 --> 00:28:06,000
one message and make sure it goes over

00:28:01,919 --> 00:28:07,320
and back there is you need to do your

00:28:06,000 --> 00:28:10,440
research on each of the implementations

00:28:07,320 --> 00:28:13,740
there are a lot of their proprietary

00:28:10,440 --> 00:28:16,230
ones like Twin Oaks Cordy X which is

00:28:13,740 --> 00:28:19,350
focused also on microcontrollers even

00:28:16,230 --> 00:28:21,960
before there was the X RC ii spec and

00:28:19,350 --> 00:28:25,470
the XR c ii spec is the extremely

00:28:21,960 --> 00:28:27,779
resource constrained environment so

00:28:25,470 --> 00:28:35,029
that's what we're hoping to leverage for

00:28:27,779 --> 00:28:35,029
in the px4 world all the way up there

00:28:50,880 --> 00:28:56,710
so the question is when would you

00:28:53,560 --> 00:28:58,750
migrate from Ross want to rush - yeah so

00:28:56,710 --> 00:29:00,820
first first of all we need to have a

00:28:58,750 --> 00:29:02,710
proof a proof of concept and that's why

00:29:00,820 --> 00:29:05,380
we I'll be working with the avoidance

00:29:02,710 --> 00:29:07,930
team on that so if we have a proof of

00:29:05,380 --> 00:29:12,150
concept within a subsystem that is as

00:29:07,930 --> 00:29:15,700
complex as avoidance and we the proper

00:29:12,150 --> 00:29:18,670
throughput latency test and all then I

00:29:15,700 --> 00:29:21,400
can assure you that we will be able to

00:29:18,670 --> 00:29:24,250
move from Mavros to to this to this

00:29:21,400 --> 00:29:33,370
bridge yeah I would say like in the next

00:29:24,250 --> 00:29:34,950
two to three months thank you for your

00:29:33,370 --> 00:29:37,300
presentation

00:29:34,950 --> 00:29:39,130
during the presentation you were

00:29:37,300 --> 00:29:42,370
focusing on the kind of

00:29:39,130 --> 00:29:44,490
publish/subscribe abstraction but there

00:29:42,370 --> 00:29:47,110
is also a very common use case for the

00:29:44,490 --> 00:29:50,520
request response kind of thing like the

00:29:47,110 --> 00:29:53,380
ross services and babbling commands so

00:29:50,520 --> 00:29:58,360
what's the story with that if you want

00:29:53,380 --> 00:30:03,580
to interface with this for from rose to

00:29:58,360 --> 00:30:05,910
using first 30 pins I'm not sure I

00:30:03,580 --> 00:30:09,460
understand the question so the idea is

00:30:05,910 --> 00:30:12,490
how can I use raw services to interface

00:30:09,460 --> 00:30:14,290
with px4 using this same bridge there

00:30:12,490 --> 00:30:16,350
are two basic abstractions for

00:30:14,290 --> 00:30:18,670
communication right publish/subscribe

00:30:16,350 --> 00:30:22,050
that's the one that was mentioned in the

00:30:18,670 --> 00:30:27,310
presentation and request response like

00:30:22,050 --> 00:30:30,520
raw services example of that so is there

00:30:27,310 --> 00:30:34,230
any kind of support for that if you want

00:30:30,520 --> 00:30:37,600
to sound like my fling commands to the

00:30:34,230 --> 00:30:40,480
two peaks for because you only focused

00:30:37,600 --> 00:30:44,710
on the like on the topics like when you

00:30:40,480 --> 00:30:48,010
map from Rose Toutatis to Europe topics

00:30:44,710 --> 00:30:50,650
yeah so yeah that's a good question and

00:30:48,010 --> 00:30:54,370
the idea of using publishers

00:30:50,650 --> 00:30:58,120
because new orb is based on the same the

00:30:54,370 --> 00:31:00,370
same premise so the idea of madelung

00:30:58,120 --> 00:31:02,500
commands it's not actually a Bible here

00:31:00,370 --> 00:31:04,360
because this is not the idea is not

00:31:02,500 --> 00:31:07,060
using meddling commands but actually

00:31:04,360 --> 00:31:11,490
replace that but we can think of

00:31:07,060 --> 00:31:14,590
something like using requests as

00:31:11,490 --> 00:31:17,140
commands and interface directly with the

00:31:14,590 --> 00:31:19,360
modules on the px4 side - and consider

00:31:17,140 --> 00:31:21,970
that kind of implementation but for data

00:31:19,360 --> 00:31:27,990
parsing data exchange we have published

00:31:21,970 --> 00:31:27,990
subscribe anyone else

00:31:36,120 --> 00:31:42,460
are there any plans to bring my micro

00:31:39,430 --> 00:31:46,200
TPS to other components like Han or SPI

00:31:42,460 --> 00:31:49,120
I think bevelle can answer that after

00:31:46,200 --> 00:31:51,640
you want to take that poll later later

00:31:49,120 --> 00:31:59,160
we're gonna get back to a battle session

00:31:51,640 --> 00:31:59,160
lunch anyone else yeah

00:32:14,290 --> 00:32:19,510
yes you can that's the first example I

00:32:17,420 --> 00:32:21,830
present it is actually a raw

00:32:19,510 --> 00:32:25,250
implementation for faster DPS where you

00:32:21,830 --> 00:32:28,610
can just use faster GPS on both a JIT

00:32:25,250 --> 00:32:31,130
and client and then have a faster GPS

00:32:28,610 --> 00:32:34,190
application on the computer side without

00:32:31,130 --> 00:32:37,160
actually installing Ross so yes that's

00:32:34,190 --> 00:32:39,580
possible and it's documented so they

00:32:37,160 --> 00:32:51,380
have guy does everything for that yeah

00:32:39,580 --> 00:32:54,380
all right anyone else it's a layer of I

00:32:51,380 --> 00:32:57,560
presume it's implemented under their

00:32:54,380 --> 00:33:00,950
their own repository like I'm certainly

00:32:57,560 --> 00:33:04,430
not able to answer that but I think I

00:33:00,950 --> 00:33:07,250
can discuss that with you after perfect

00:33:04,430 --> 00:33:16,910
all right everyone just one last

00:33:07,250 --> 00:33:20,600
question yes yes so that's Ross - so the

00:33:16,910 --> 00:33:23,450
question is like is final the rows one

00:33:20,600 --> 00:33:27,380
bridge works basically right or why so

00:33:23,450 --> 00:33:32,180
Rose one bridge is a package under Ross

00:33:27,380 --> 00:33:34,490
- right that basically makes a bridge

00:33:32,180 --> 00:33:38,480
between rows one topics and rows two

00:33:34,490 --> 00:33:41,090
topics based on types naming etc so you

00:33:38,480 --> 00:33:43,430
can basically publish under a certain

00:33:41,090 --> 00:33:46,400
topic name with certain type on rows one

00:33:43,430 --> 00:33:48,530
and the rows to the side will get access

00:33:46,400 --> 00:33:52,040
to that data on that topic and vice

00:33:48,530 --> 00:33:54,230
versa as well so I think you know for

00:33:52,040 --> 00:33:55,320
your time everyone Justin applause

00:33:54,230 --> 00:33:58,500
please

00:33:55,320 --> 00:33:58,500
[Applause]

00:34:05,450 --> 00:34:07,510

YouTube URL: https://www.youtube.com/watch?v=2Szw8Pk3Z0Q


