Title: Putting the Fun in Functional Programming -  Stephanie and Ed Schwartz | CPOSC2020
Publication date: 2021-01-18
Playlist: CPOSC 2020 Recorded Sessions
Description: 
	Session Page: https://cposc.org/sessions/putting-fun-functional-programming/
Demo: https://github.com/edmcman/cposc-fun
Chat Log: https://cposc.org/chat-log-putting-fun-functional-programming/

The Central Pennsylvania Open Source Conference (CPOSC) is a one-day technical conference for open source users and developers. Presentations and sessions cover all aspects of open source, with talks ranging from novice to expert skill levels and featuring case studies, best practices, code-alongs and more. Join us in 2021! https://cposc.org
Captions: 
	00:00:06,160 --> 00:00:10,559
i'd like to introduce dr

00:00:08,080 --> 00:00:12,400
stephanie and edward schwartz for the

00:00:10,559 --> 00:00:13,840
session of putting the fun in functional

00:00:12,400 --> 00:00:16,640
programming

00:00:13,840 --> 00:00:18,160
dr schwartz stephanie schwartz is a

00:00:16,640 --> 00:00:19,039
professor and chair of the computer

00:00:18,160 --> 00:00:21,600
science department

00:00:19,039 --> 00:00:23,760
at millersville university she received

00:00:21,600 --> 00:00:25,439
her phd and master's degrees

00:00:23,760 --> 00:00:26,880
in compsci from the university of

00:00:25,439 --> 00:00:28,720
delaware and

00:00:26,880 --> 00:00:30,960
holds a bachelor's of science in

00:00:28,720 --> 00:00:33,280
computer science from shippensburg

00:00:30,960 --> 00:00:34,239
her research interests include user

00:00:33,280 --> 00:00:37,280
modeling

00:00:34,239 --> 00:00:38,160
cognitive modeling machine learning data

00:00:37,280 --> 00:00:41,680
mining

00:00:38,160 --> 00:00:43,600
and artificial intelligence she teaches

00:00:41,680 --> 00:00:44,800
courses ranging from beginner

00:00:43,600 --> 00:00:47,600
programming courses

00:00:44,800 --> 00:00:48,640
to upper level electives in ai and data

00:00:47,600 --> 00:00:51,680
mining

00:00:48,640 --> 00:00:53,120
before joining mu she worked as a

00:00:51,680 --> 00:00:54,399
software engineer for companies

00:00:53,120 --> 00:00:57,520
including mapquest

00:00:54,399 --> 00:01:00,800
and amp which is now part of tyco

00:00:57,520 --> 00:01:02,079
joining stephanie is the other dr

00:01:00,800 --> 00:01:04,559
schwartz dr edward

00:01:02,079 --> 00:01:05,680
schwartz ed is a senior research

00:01:04,559 --> 00:01:08,640
scientist working

00:01:05,680 --> 00:01:11,200
on search code analysis team ed earned

00:01:08,640 --> 00:01:14,240
his phd from carnegie mellon university

00:01:11,200 --> 00:01:16,320
scilab and his dissertation studied the

00:01:14,240 --> 00:01:17,280
performance benefits of explicitly

00:01:16,320 --> 00:01:19,439
recovering

00:01:17,280 --> 00:01:21,920
program extractions when performing

00:01:19,439 --> 00:01:23,439
static binary analysis

00:01:21,920 --> 00:01:25,360
at cert he's worked in a variety of

00:01:23,439 --> 00:01:26,159
binary analysis projects in both

00:01:25,360 --> 00:01:28,240
vulnerability

00:01:26,159 --> 00:01:29,759
discovery and reverse engineering the

00:01:28,240 --> 00:01:32,960
gang i think you're in for a treat

00:01:29,759 --> 00:01:34,400
from doctors edward and stephanie

00:01:32,960 --> 00:01:36,720
schwartz and i turn it over to them for

00:01:34,400 --> 00:01:39,520
the rest of the session

00:01:36,720 --> 00:01:40,240
good morning um hopefully you're all

00:01:39,520 --> 00:01:43,119
happening

00:01:40,240 --> 00:01:45,439
because we are going to try to take you

00:01:43,119 --> 00:01:47,280
back to programming basics and show you

00:01:45,439 --> 00:01:50,399
a somewhat different way

00:01:47,280 --> 00:01:51,759
um a side note that uh we are married

00:01:50,399 --> 00:01:53,600
and we will do our best

00:01:51,759 --> 00:01:56,000
not to squabble this morning although we

00:01:53,600 --> 00:01:58,719
haven't done so well in the intro

00:01:56,000 --> 00:02:00,000
um so uh we've been cooped up together

00:01:58,719 --> 00:02:02,880
for six months

00:02:00,000 --> 00:02:03,759
and we're really hoping that that uh

00:02:02,880 --> 00:02:07,520
clause about

00:02:03,759 --> 00:02:11,599
cpas behavior doesn't apply between us

00:02:07,520 --> 00:02:11,599
so let's get started

00:02:14,959 --> 00:02:18,560
good start all right so why do we want

00:02:17,760 --> 00:02:22,239
you to

00:02:18,560 --> 00:02:24,480
know about uh functional programming

00:02:22,239 --> 00:02:25,280
what you're probably used to is a

00:02:24,480 --> 00:02:28,319
procedural

00:02:25,280 --> 00:02:31,280
or imperative approach to programming

00:02:28,319 --> 00:02:32,319
um and those languages really uh

00:02:31,280 --> 00:02:34,879
describe

00:02:32,319 --> 00:02:36,720
kind of how to do the computations and

00:02:34,879 --> 00:02:38,879
and take it kind of step by step in

00:02:36,720 --> 00:02:40,319
terms of what you want to happen

00:02:38,879 --> 00:02:42,160
functional programming is a very

00:02:40,319 --> 00:02:44,000
different programming paradigm

00:02:42,160 --> 00:02:45,920
where the goal is to describe the

00:02:44,000 --> 00:02:47,840
desired computation

00:02:45,920 --> 00:02:49,280
rather than the procedure for how to go

00:02:47,840 --> 00:02:52,080
about doing it

00:02:49,280 --> 00:02:53,040
um this difference really lets some

00:02:52,080 --> 00:02:56,319
computations

00:02:53,040 --> 00:02:59,680
and programs be super elegant and

00:02:56,319 --> 00:03:02,840
simple and just a thing of beauty

00:02:59,680 --> 00:03:04,239
i hope you agree as you see a little bit

00:03:02,840 --> 00:03:06,640
more

00:03:04,239 --> 00:03:07,760
i teach some functional programming in

00:03:06,640 --> 00:03:10,159
some of my courses

00:03:07,760 --> 00:03:11,599
at uh millersville um i teach some

00:03:10,159 --> 00:03:12,159
o'camel and i teach a little bit of

00:03:11,599 --> 00:03:14,800
bliss

00:03:12,159 --> 00:03:15,360
in the ai course and i often hear my

00:03:14,800 --> 00:03:17,599
students

00:03:15,360 --> 00:03:18,560
uh complain that they're never going to

00:03:17,599 --> 00:03:21,599
use these things

00:03:18,560 --> 00:03:24,720
in the real world and i grant them

00:03:21,599 --> 00:03:26,159
absolutely uh that

00:03:24,720 --> 00:03:28,159
you're probably not going to write

00:03:26,159 --> 00:03:29,680
programs and lists unless you have a

00:03:28,159 --> 00:03:34,159
pretty weird job

00:03:29,680 --> 00:03:36,879
um but the paradigm is really important

00:03:34,159 --> 00:03:37,440
um because it predict has predicted the

00:03:36,879 --> 00:03:38,959
future

00:03:37,440 --> 00:03:40,799
of a lot of what we're seeing in

00:03:38,959 --> 00:03:43,280
imperative languages now

00:03:40,799 --> 00:03:43,840
so things like garbage collection first

00:03:43,280 --> 00:03:47,280
uh

00:03:43,840 --> 00:03:49,280
came into lisp in 1958 was introduced in

00:03:47,280 --> 00:03:51,519
java in 95.

00:03:49,280 --> 00:03:52,720
um you see yeah you'll do some list

00:03:51,519 --> 00:03:55,840
programming in

00:03:52,720 --> 00:03:58,159
emacs and that's maybe one of the the

00:03:55,840 --> 00:04:00,400
more relevant pieces

00:03:58,159 --> 00:04:01,599
generics existed in functional

00:04:00,400 --> 00:04:03,519
programming first

00:04:01,599 --> 00:04:04,879
higher order functions which we'll talk

00:04:03,519 --> 00:04:08,239
more about

00:04:04,879 --> 00:04:09,120
um and type inference um which we're

00:04:08,239 --> 00:04:12,480
starting to see

00:04:09,120 --> 00:04:16,160
in c plus java etc came out

00:04:12,480 --> 00:04:18,160
of ml as an original language feature

00:04:16,160 --> 00:04:21,199
there

00:04:18,160 --> 00:04:23,440
so i want to kind of differentiate the

00:04:21,199 --> 00:04:26,840
the two programming paradigms with

00:04:23,440 --> 00:04:29,520
a short example so the left-hand side is

00:04:26,840 --> 00:04:31,600
java and we've got two vectors

00:04:29,520 --> 00:04:34,000
and the sole purpose of this code

00:04:31,600 --> 00:04:35,199
segment is to take the vector containing

00:04:34,000 --> 00:04:37,040
one two three

00:04:35,199 --> 00:04:38,320
and create a vector with the doubles of

00:04:37,040 --> 00:04:40,639
those numbers

00:04:38,320 --> 00:04:42,800
so you'll see me kind of going through

00:04:40,639 --> 00:04:43,360
the loop and iterating over the elements

00:04:42,800 --> 00:04:46,720
and things

00:04:43,360 --> 00:04:50,400
in java in ocam that can be done

00:04:46,720 --> 00:04:52,479
as simply as one line of a map

00:04:50,400 --> 00:04:53,840
all right and that line probably looks

00:04:52,479 --> 00:04:56,800
pretty weird to you

00:04:53,840 --> 00:04:57,680
uh to start out with um by the end of

00:04:56,800 --> 00:05:01,199
this talk you'll

00:04:57,680 --> 00:05:01,199
you'll understand that a lot more

00:05:01,919 --> 00:05:07,600
so although i'm sure you're

00:05:05,280 --> 00:05:08,720
completely impressed by that example and

00:05:07,600 --> 00:05:12,880
now you're convinced

00:05:08,720 --> 00:05:14,720
that you want to program an o camel um

00:05:12,880 --> 00:05:16,400
some of you may still be on the fence

00:05:14,720 --> 00:05:19,600
and be like okay

00:05:16,400 --> 00:05:21,840
cool but i really don't want to

00:05:19,600 --> 00:05:22,960
write all of my code in ocamel or

00:05:21,840 --> 00:05:26,800
haskell or scheme

00:05:22,960 --> 00:05:30,479
or list or closure or whatever

00:05:26,800 --> 00:05:33,440
um that's fine

00:05:30,479 --> 00:05:34,880
we're going to show you some of the o

00:05:33,440 --> 00:05:37,360
camel examples

00:05:34,880 --> 00:05:38,720
but our real point of this is that a lot

00:05:37,360 --> 00:05:40,960
of these features

00:05:38,720 --> 00:05:41,759
from these languages are appearing all

00:05:40,960 --> 00:05:44,400
over the place

00:05:41,759 --> 00:05:46,080
in your mainstream languages um but

00:05:44,400 --> 00:05:47,199
we're trying to kind of take you back to

00:05:46,080 --> 00:05:49,280
your roots

00:05:47,199 --> 00:05:52,000
uh the roots of these features so that

00:05:49,280 --> 00:05:54,639
you understand their origin better

00:05:52,000 --> 00:05:55,120
and then you can employ them in your

00:05:54,639 --> 00:05:58,160
kind of

00:05:55,120 --> 00:06:00,960
daily programming practice

00:05:58,160 --> 00:06:02,080
so although i do don't have to program

00:06:00,960 --> 00:06:03,810
in one of these languages

00:06:02,080 --> 00:06:05,759
we're about to show you how

00:06:03,810 --> 00:06:07,840
[Music]

00:06:05,759 --> 00:06:09,280
i lie all the time to my students too

00:06:07,840 --> 00:06:10,560
it's okay just get used to it i'll be

00:06:09,280 --> 00:06:13,120
all right

00:06:10,560 --> 00:06:15,520
so um fundamentals of functional

00:06:13,120 --> 00:06:17,840
programming what do we want you to know

00:06:15,520 --> 00:06:18,560
the first idea is that everything is an

00:06:17,840 --> 00:06:21,039
expression

00:06:18,560 --> 00:06:23,600
that evaluates to a value this is very

00:06:21,039 --> 00:06:26,479
different than imperative languages

00:06:23,600 --> 00:06:27,280
the second is the idea of immutability

00:06:26,479 --> 00:06:29,120
and the third

00:06:27,280 --> 00:06:31,280
is that functions are first class

00:06:29,120 --> 00:06:34,960
citizens so i'm going to walk through

00:06:31,280 --> 00:06:38,160
these in a little bit more detail

00:06:34,960 --> 00:06:41,360
in imperative or mutable programming

00:06:38,160 --> 00:06:44,720
we have commands or statements that

00:06:41,360 --> 00:06:46,080
specify how to compute by destructively

00:06:44,720 --> 00:06:49,280
changing a state

00:06:46,080 --> 00:06:51,440
so a really simple example uh is y

00:06:49,280 --> 00:06:53,759
equals y minus one

00:06:51,440 --> 00:06:54,479
in that command we're taking the value

00:06:53,759 --> 00:06:56,479
of y

00:06:54,479 --> 00:06:59,199
in the state of our program and we're

00:06:56,479 --> 00:07:01,680
changing it to decrement it by one

00:06:59,199 --> 00:07:02,400
um and the other thing about mutable

00:07:01,680 --> 00:07:04,240
programming

00:07:02,400 --> 00:07:05,840
is that functions and methods have all

00:07:04,240 --> 00:07:08,160
kinds of side effects

00:07:05,840 --> 00:07:10,560
so aside from just returning a value

00:07:08,160 --> 00:07:14,319
which is the pure functional way

00:07:10,560 --> 00:07:17,919
uh functions can also you know increment

00:07:14,319 --> 00:07:19,599
non-local variables change parameters

00:07:17,919 --> 00:07:22,400
all these things that are happening in

00:07:19,599 --> 00:07:24,800
other ways other than the return value

00:07:22,400 --> 00:07:27,440
and in functional programming that

00:07:24,800 --> 00:07:27,440
doesn't happen

00:07:28,240 --> 00:07:34,400
so in immutable programming

00:07:31,360 --> 00:07:36,240
there are no variables and

00:07:34,400 --> 00:07:37,840
i i understand that that seems a little

00:07:36,240 --> 00:07:41,520
scary um

00:07:37,840 --> 00:07:44,720
so i kind of want to uh explain

00:07:41,520 --> 00:07:47,759
how that happens so everything is an

00:07:44,720 --> 00:07:48,160
expression um and expressions don't

00:07:47,759 --> 00:07:52,000
change

00:07:48,160 --> 00:07:53,440
values so variables never change value

00:07:52,000 --> 00:07:55,919
and so i really don't call them

00:07:53,440 --> 00:07:59,520
variables i usually call them symbols

00:07:55,919 --> 00:08:02,080
because variables should vary um

00:07:59,520 --> 00:08:03,599
and in immutable programming functions

00:08:02,080 --> 00:08:05,919
never have side effects

00:08:03,599 --> 00:08:07,919
what you see is what you get you if you

00:08:05,919 --> 00:08:09,360
call the function with the same value

00:08:07,919 --> 00:08:11,360
you are always going to get the same

00:08:09,360 --> 00:08:13,140
result and nothing else is going to

00:08:11,360 --> 00:08:14,800
change

00:08:13,140 --> 00:08:17,360
[Music]

00:08:14,800 --> 00:08:18,080
so why on earth would we want to do this

00:08:17,360 --> 00:08:20,560
um

00:08:18,080 --> 00:08:22,080
the first reason is probably pretty

00:08:20,560 --> 00:08:25,280
clear if you've ever

00:08:22,080 --> 00:08:28,319
maintained or debugged a program of

00:08:25,280 --> 00:08:30,720
some complexity um

00:08:28,319 --> 00:08:32,000
you might be looking at one line and

00:08:30,720 --> 00:08:33,839
you're not entirely sure the

00:08:32,000 --> 00:08:36,000
dependencies on that line

00:08:33,839 --> 00:08:37,680
because side effects can happen and

00:08:36,000 --> 00:08:39,120
state can change in all kinds of

00:08:37,680 --> 00:08:41,279
different ways

00:08:39,120 --> 00:08:43,279
so that's the one argument is it makes

00:08:41,279 --> 00:08:45,040
your code a lot more maintainable and

00:08:43,279 --> 00:08:46,880
clear

00:08:45,040 --> 00:08:49,200
the other is that this idea of

00:08:46,880 --> 00:08:51,120
mutability and program state is kind of

00:08:49,200 --> 00:08:53,279
a fantasy

00:08:51,120 --> 00:08:54,880
where we all try to buy into the idea

00:08:53,279 --> 00:08:57,600
that there's just one state

00:08:54,880 --> 00:08:59,040
and computers do one thing at a time but

00:08:57,600 --> 00:09:00,640
really

00:08:59,040 --> 00:09:02,880
today's applications there are many

00:09:00,640 --> 00:09:04,320
threads many cores many processors many

00:09:02,880 --> 00:09:06,480
machines where our program is

00:09:04,320 --> 00:09:08,240
distributed across

00:09:06,480 --> 00:09:09,920
and applications are frequently doing

00:09:08,240 --> 00:09:13,120
multiple things at once

00:09:09,920 --> 00:09:13,760
so by using immutable programming we can

00:09:13,120 --> 00:09:16,320
get some

00:09:13,760 --> 00:09:17,360
really elegant concurrent or parallel

00:09:16,320 --> 00:09:19,200
solutions

00:09:17,360 --> 00:09:20,720
to things that we have to work really

00:09:19,200 --> 00:09:24,000
really hard to do

00:09:20,720 --> 00:09:24,000
in imperative languages

00:09:24,720 --> 00:09:30,000
um so what on earth does programming

00:09:27,760 --> 00:09:32,720
without variables look like

00:09:30,000 --> 00:09:33,600
um so i show on the left a factorial

00:09:32,720 --> 00:09:35,680
function

00:09:33,600 --> 00:09:37,519
if you've been away from academics for a

00:09:35,680 --> 00:09:40,240
little while you may have forgotten that

00:09:37,519 --> 00:09:43,680
this is a very stock example

00:09:40,240 --> 00:09:46,320
um so a factorial of a number is

00:09:43,680 --> 00:09:47,760
so factorial four is four times three

00:09:46,320 --> 00:09:49,839
times two times one

00:09:47,760 --> 00:09:51,279
okay and you see me computing that by

00:09:49,839 --> 00:09:54,480
changing the variables

00:09:51,279 --> 00:09:55,040
i and f on the left and on the right you

00:09:54,480 --> 00:09:57,360
see an

00:09:55,040 --> 00:10:00,320
immutable version of this where no

00:09:57,360 --> 00:10:03,360
symbols or variables are changing values

00:10:00,320 --> 00:10:04,959
and i'm using recursion so in recursion

00:10:03,360 --> 00:10:06,160
we always have a base case where we know

00:10:04,959 --> 00:10:09,360
the answer

00:10:06,160 --> 00:10:10,640
and then we um recurse by taking one

00:10:09,360 --> 00:10:13,760
step of work

00:10:10,640 --> 00:10:15,839
and then solving a simpler problem so if

00:10:13,760 --> 00:10:16,880
you're doing pure functional immutable

00:10:15,839 --> 00:10:18,560
programming

00:10:16,880 --> 00:10:19,920
you need to become comfortable with

00:10:18,560 --> 00:10:21,839
recursion

00:10:19,920 --> 00:10:24,640
if i just scared you it's okay that's

00:10:21,839 --> 00:10:27,120
not going to be our emphasis today

00:10:24,640 --> 00:10:27,760
today we are really just going to show

00:10:27,120 --> 00:10:31,200
you

00:10:27,760 --> 00:10:33,519
um some features and concepts

00:10:31,200 --> 00:10:35,600
that are popping up in other languages

00:10:33,519 --> 00:10:37,330
um and we're not going to emphasize kind

00:10:35,600 --> 00:10:39,279
of this recursive style

00:10:37,330 --> 00:10:42,560
[Music]

00:10:39,279 --> 00:10:44,640
so one of the other big concepts is that

00:10:42,560 --> 00:10:46,240
um everything is an expression that

00:10:44,640 --> 00:10:49,600
evaluates to a value

00:10:46,240 --> 00:10:52,320
right so what does that mean

00:10:49,600 --> 00:10:54,079
well it means that functions are also

00:10:52,320 --> 00:10:56,160
just values

00:10:54,079 --> 00:10:58,399
and so functions should be able to do

00:10:56,160 --> 00:11:01,200
anything that a regular sorry

00:10:58,399 --> 00:11:02,399
value can do so you should be able to

00:11:01,200 --> 00:11:05,120
assign a function

00:11:02,399 --> 00:11:06,640
to a symbol that's not new we name

00:11:05,120 --> 00:11:08,640
functions all the time

00:11:06,640 --> 00:11:10,480
but we should also be able to pass a

00:11:08,640 --> 00:11:11,360
function as an argument to another

00:11:10,480 --> 00:11:13,360
function

00:11:11,360 --> 00:11:15,200
or return a function from another

00:11:13,360 --> 00:11:16,640
function as the result

00:11:15,200 --> 00:11:19,040
and those two may be a little bit

00:11:16,640 --> 00:11:19,040
different

00:11:19,600 --> 00:11:22,880
so we're going to show you some

00:11:21,760 --> 00:11:25,440
functional programming in

00:11:22,880 --> 00:11:27,760
ocamel and i list here some of the

00:11:25,440 --> 00:11:29,279
reasons we like ocamo

00:11:27,760 --> 00:11:31,519
the first two are the ones i've just

00:11:29,279 --> 00:11:33,920
discussed there's also some really

00:11:31,519 --> 00:11:36,079
powerful and cool pattern matching

00:11:33,920 --> 00:11:38,560
there's static type checking it is a

00:11:36,079 --> 00:11:41,279
strongly typed language

00:11:38,560 --> 00:11:42,320
it does automatic type inference it has

00:11:41,279 --> 00:11:45,600
garbage collection

00:11:42,320 --> 00:11:47,200
it has parametric polymorphism so

00:11:45,600 --> 00:11:49,760
if you're interested it's a cool

00:11:47,200 --> 00:11:52,079
language to check out

00:11:49,760 --> 00:11:53,200
so now hopefully you took ed's advice

00:11:52,079 --> 00:11:56,000
and our advice at the

00:11:53,200 --> 00:11:57,760
at the beginning and you loaded those

00:11:56,000 --> 00:11:59,519
jupiter notebooks we're gonna start in

00:11:57,760 --> 00:12:02,160
the o camel one

00:11:59,519 --> 00:12:04,000
um it can take a while to load so if

00:12:02,160 --> 00:12:05,279
yours is loading that's okay we're gonna

00:12:04,000 --> 00:12:07,200
be walking through

00:12:05,279 --> 00:12:09,200
and you can follow along and we're gonna

00:12:07,200 --> 00:12:11,839
do most of the rest of the talk using

00:12:09,200 --> 00:12:11,839
that

00:12:12,800 --> 00:12:20,720
all right so let's see if we can uh

00:12:16,160 --> 00:12:20,720
share the notebook screen

00:12:22,720 --> 00:12:26,240
looks like you've got the whole desktop

00:12:24,880 --> 00:12:28,560
the whole desktop that's not what i

00:12:26,240 --> 00:12:28,560
wanted

00:12:32,560 --> 00:12:36,320
sorry just a second here uh while i'm

00:12:35,120 --> 00:12:39,600
doing this i want to

00:12:36,320 --> 00:12:41,200
apologize for uh our dogs uh we have

00:12:39,600 --> 00:12:41,519
four of them that are all in here with

00:12:41,200 --> 00:12:44,560
us

00:12:41,519 --> 00:12:47,839
and they are

00:12:44,560 --> 00:12:49,600
usually difficult to keep under control

00:12:47,839 --> 00:12:51,920
that's okay ed i think we gave them a

00:12:49,600 --> 00:12:54,079
free ticket for uh cpas

00:12:51,920 --> 00:12:55,680
as well so that's that's right yeah

00:12:54,079 --> 00:12:57,600
that's the best thing about crops this

00:12:55,680 --> 00:13:00,000
year is that the dogs can come along

00:12:57,600 --> 00:13:00,000
there you go

00:13:01,440 --> 00:13:08,880
who is colin i have no idea this is so

00:13:06,560 --> 00:13:08,880
going

00:13:09,519 --> 00:13:14,720
i don't know it's not my computer

00:13:14,959 --> 00:13:19,040
it's not the computer is alexander

00:13:18,079 --> 00:13:22,240
calling us

00:13:19,040 --> 00:13:25,920
is that what's happening all right so

00:13:22,240 --> 00:13:28,800
that was um that was definitely

00:13:25,920 --> 00:13:30,959
fun um so anyway if you have the jupiter

00:13:28,800 --> 00:13:33,519
notebook open it should look

00:13:30,959 --> 00:13:35,600
something like this and if you haven't

00:13:33,519 --> 00:13:38,720
used a jupiter notebook before

00:13:35,600 --> 00:13:42,000
um it's kind of a combination of

00:13:38,720 --> 00:13:42,480
of text and code and if you pick one of

00:13:42,000 --> 00:13:45,839
these

00:13:42,480 --> 00:13:48,800
code areas you can double click

00:13:45,839 --> 00:13:50,639
into one of these boxes and you could

00:13:48,800 --> 00:13:51,440
actually write okemo code here so you

00:13:50,639 --> 00:13:52,800
probably don't know

00:13:51,440 --> 00:13:54,880
what to write here but you know if you

00:13:52,800 --> 00:13:57,839
wanted to write a number um

00:13:54,880 --> 00:13:58,320
and then click on the run button it will

00:13:57,839 --> 00:14:00,560
actually

00:13:58,320 --> 00:14:01,600
evaluate whatever expression that you

00:14:00,560 --> 00:14:02,480
write in and it will give you the

00:14:01,600 --> 00:14:05,120
results

00:14:02,480 --> 00:14:06,800
um so we have code here that we're going

00:14:05,120 --> 00:14:07,600
to be walking through but if you find

00:14:06,800 --> 00:14:10,000
something that

00:14:07,600 --> 00:14:10,959
is um you know you want to try you can

00:14:10,000 --> 00:14:14,000
just edit that

00:14:10,959 --> 00:14:15,279
click on run and you don't have to worry

00:14:14,000 --> 00:14:17,360
about that

00:14:15,279 --> 00:14:19,279
i won't mess up our presentation or

00:14:17,360 --> 00:14:20,880
anything so feel free to experiment to

00:14:19,279 --> 00:14:22,399
your heart's delight

00:14:20,880 --> 00:14:24,079
hopefully this will make the font a

00:14:22,399 --> 00:14:27,120
little bit larger so you can

00:14:24,079 --> 00:14:29,839
actually see what's going on

00:14:27,120 --> 00:14:31,440
so let's get started so the good news

00:14:29,839 --> 00:14:32,800
about oh camel is that there are some

00:14:31,440 --> 00:14:34,560
things that are

00:14:32,800 --> 00:14:36,160
that are very similar to the languages

00:14:34,560 --> 00:14:39,120
that you're used to so

00:14:36,160 --> 00:14:40,880
um your basic uh literals and your basic

00:14:39,120 --> 00:14:43,120
strings you know integers

00:14:40,880 --> 00:14:44,560
uh if you evaluate the string or if you

00:14:43,120 --> 00:14:47,680
evaluate the number one

00:14:44,560 --> 00:14:50,000
you're going to get back one um so

00:14:47,680 --> 00:14:51,440
nothing real surprising there just to

00:14:50,000 --> 00:14:54,000
give you an idea of what

00:14:51,440 --> 00:14:55,360
ochem was telling us here is telling us

00:14:54,000 --> 00:14:56,560
two different things it's basically

00:14:55,360 --> 00:14:58,560
saying

00:14:56,560 --> 00:15:00,480
the type of the expression that we

00:14:58,560 --> 00:15:03,279
evaluated is an integer

00:15:00,480 --> 00:15:04,639
right not very shocking here um and here

00:15:03,279 --> 00:15:07,040
we evaluated

00:15:04,639 --> 00:15:08,720
this expression to the number ones again

00:15:07,040 --> 00:15:09,600
that's not very surprising here because

00:15:08,720 --> 00:15:12,000
we're just

00:15:09,600 --> 00:15:14,160
evaluating a number but as we look at

00:15:12,000 --> 00:15:16,000
more complicated expressions

00:15:14,160 --> 00:15:17,600
um that will be more useful to kind of

00:15:16,000 --> 00:15:18,880
see what ocamel

00:15:17,600 --> 00:15:20,800
is evaluating these different

00:15:18,880 --> 00:15:24,399
expressions to

00:15:20,800 --> 00:15:26,720
um so again strings are

00:15:24,399 --> 00:15:28,399
basically as you're used to you can also

00:15:26,720 --> 00:15:30,790
use oh camel

00:15:28,399 --> 00:15:33,820
to basically add numbers

00:15:30,790 --> 00:15:33,820
[Music]

00:15:34,320 --> 00:15:38,079
right so nothing too surprising one of

00:15:37,199 --> 00:15:39,519
the things that

00:15:38,079 --> 00:15:41,600
stephanie mentioned that's really cool

00:15:39,519 --> 00:15:43,040
about ocamel um is that it has a really

00:15:41,600 --> 00:15:44,959
strong type system

00:15:43,040 --> 00:15:46,639
um we'll see this in a couple different

00:15:44,959 --> 00:15:47,279
places but one of the things that it

00:15:46,639 --> 00:15:49,360
does

00:15:47,279 --> 00:15:50,800
um is it will stop you from doing things

00:15:49,360 --> 00:15:52,839
that are really stupid

00:15:50,800 --> 00:15:54,880
um like adding an integer and a string

00:15:52,839 --> 00:15:57,920
together um

00:15:54,880 --> 00:16:00,240
okay i don't know why all of a sudden is

00:15:57,920 --> 00:16:00,240
uh

00:16:00,480 --> 00:16:03,839
making me hit a button to show you the

00:16:01,920 --> 00:16:06,399
output here um

00:16:03,839 --> 00:16:08,720
live demos you know anyway so that's the

00:16:06,399 --> 00:16:11,279
kind of complaint that ocam will make

00:16:08,720 --> 00:16:12,480
as we go and try to do something really

00:16:11,279 --> 00:16:15,360
stupid

00:16:12,480 --> 00:16:16,160
so let's um let's look at a more complex

00:16:15,360 --> 00:16:19,440
expression

00:16:16,160 --> 00:16:22,880
um so one of the really important types

00:16:19,440 --> 00:16:24,720
in functional languages tend to be lists

00:16:22,880 --> 00:16:26,000
so here's an example of a list of

00:16:24,720 --> 00:16:28,000
integers

00:16:26,000 --> 00:16:30,000
and you can see here that as we evaluate

00:16:28,000 --> 00:16:32,959
this it turns into

00:16:30,000 --> 00:16:33,519
an int list and basically you can read

00:16:32,959 --> 00:16:36,240
that type

00:16:33,519 --> 00:16:39,920
backwards so okamo's telling you that

00:16:36,240 --> 00:16:39,920
this is really a list of integers

00:16:41,199 --> 00:16:46,560
so time for a bit of a trick question um

00:16:43,759 --> 00:16:49,120
what type does the empty list have

00:16:46,560 --> 00:16:50,560
right so it could be it list maybe but

00:16:49,120 --> 00:16:51,600
then we couldn't put other things in the

00:16:50,560 --> 00:16:55,040
list like uh

00:16:51,600 --> 00:16:57,279
like strings um so the way that ocamel

00:16:55,040 --> 00:16:59,759
actually handles this will's not allowed

00:16:57,279 --> 00:17:01,680
to answer anything today

00:16:59,759 --> 00:17:03,920
yeah anyone but will can answer the

00:17:01,680 --> 00:17:07,039
question uh the way that ocam

00:17:03,920 --> 00:17:09,439
handles this is by using a type variable

00:17:07,039 --> 00:17:10,079
that's what this apostrophe a means here

00:17:09,439 --> 00:17:12,319
basically

00:17:10,079 --> 00:17:13,679
it's uh it's basically a blank area

00:17:12,319 --> 00:17:15,839
where ocam was saying

00:17:13,679 --> 00:17:17,760
i don't know what this is yet it's some

00:17:15,839 --> 00:17:19,360
type that is yet to be determined

00:17:17,760 --> 00:17:21,439
so basically you can pick this type

00:17:19,360 --> 00:17:22,400
later and that makes sense for an empty

00:17:21,439 --> 00:17:24,480
list because right

00:17:22,400 --> 00:17:25,919
it could be an empty list of strings it

00:17:24,480 --> 00:17:28,400
could be empty listed integers

00:17:25,919 --> 00:17:29,919
we just don't know um and so this is how

00:17:28,400 --> 00:17:32,080
ocamel handles

00:17:29,919 --> 00:17:33,760
polymorphism is by using these type

00:17:32,080 --> 00:17:35,120
variables um and this is actually

00:17:33,760 --> 00:17:37,840
something that's called

00:17:35,120 --> 00:17:38,640
uh parametric polymorphism and it's a

00:17:37,840 --> 00:17:41,600
pretty neat

00:17:38,640 --> 00:17:43,360
um feature of ocamel and yeah it's a

00:17:41,600 --> 00:17:46,400
placeholder you can view it kind of

00:17:43,360 --> 00:17:49,520
like a parameter where

00:17:46,400 --> 00:17:52,720
a means everything that has a filled in

00:17:49,520 --> 00:17:54,480
needs to be the same type b if it does b

00:17:52,720 --> 00:17:55,760
those all need to be the same type

00:17:54,480 --> 00:17:57,440
you'll see a little bit more

00:17:55,760 --> 00:17:59,039
yeah we'll see more more examples of

00:17:57,440 --> 00:18:01,679
this

00:17:59,039 --> 00:18:02,880
so obviously in functional languages um

00:18:01,679 --> 00:18:05,120
functions are

00:18:02,880 --> 00:18:06,960
really important um so let's let's talk

00:18:05,120 --> 00:18:09,360
about those a little bit

00:18:06,960 --> 00:18:10,960
so uh here are some syntax for defining

00:18:09,360 --> 00:18:13,600
a function in oat camel

00:18:10,960 --> 00:18:15,039
um and the syntax is basically fun argh

00:18:13,600 --> 00:18:17,919
arrow 42 and

00:18:15,039 --> 00:18:18,880
what this means is we want the function

00:18:17,919 --> 00:18:20,960
that's going to take an

00:18:18,880 --> 00:18:22,559
argument that's called arg and it's

00:18:20,960 --> 00:18:23,440
going to compute and return the

00:18:22,559 --> 00:18:26,880
expression

00:18:23,440 --> 00:18:28,720
42. okay so if you look at what ocamel

00:18:26,880 --> 00:18:29,120
was responding with it's saying our type

00:18:28,720 --> 00:18:32,640
here

00:18:29,120 --> 00:18:35,840
is this kind of weird looking thing

00:18:32,640 --> 00:18:37,280
type variable a arrow integer and ocam

00:18:35,840 --> 00:18:40,640
is basically just saying

00:18:37,280 --> 00:18:43,440
hey this is a function type it's taking

00:18:40,640 --> 00:18:45,039
this folder type again and the reason

00:18:43,440 --> 00:18:47,039
for that is because in our function

00:18:45,039 --> 00:18:48,240
we're returning 42 so we're not actually

00:18:47,039 --> 00:18:50,480
using the argument

00:18:48,240 --> 00:18:53,600
so essentially it doesn't really matter

00:18:50,480 --> 00:18:53,600
for the type of the function

00:18:54,960 --> 00:18:58,000
the other thing that's a little bit

00:18:56,240 --> 00:18:59,200
funny here that you might not be used to

00:18:58,000 --> 00:19:02,080
is that this function

00:18:59,200 --> 00:19:02,720
doesn't have a name um so it's anonymous

00:19:02,080 --> 00:19:04,640
um

00:19:02,720 --> 00:19:06,160
a lot of functions call this ability to

00:19:04,640 --> 00:19:08,480
make these anonymous functions

00:19:06,160 --> 00:19:09,360
lambda functions um and this is

00:19:08,480 --> 00:19:11,200
something that

00:19:09,360 --> 00:19:12,880
tends to be pretty useful in functional

00:19:11,200 --> 00:19:14,559
languages um

00:19:12,880 --> 00:19:16,240
but for now let's give our function a

00:19:14,559 --> 00:19:18,880
name um

00:19:16,240 --> 00:19:20,880
we'll call it myfun and the way that we

00:19:18,880 --> 00:19:21,520
give an expression a name or a function

00:19:20,880 --> 00:19:23,919
a name

00:19:21,520 --> 00:19:24,799
since a function is an expression is we

00:19:23,919 --> 00:19:27,679
use the let

00:19:24,799 --> 00:19:28,480
binding and so we basically say let my

00:19:27,679 --> 00:19:31,600
fun

00:19:28,480 --> 00:19:34,160
equals that function expression we had

00:19:31,600 --> 00:19:36,480
uh and basically all that's saying is

00:19:34,160 --> 00:19:39,039
take the expression and give it the name

00:19:36,480 --> 00:19:40,320
or the symbol that we are asking um in

00:19:39,039 --> 00:19:43,360
this case my fun

00:19:40,320 --> 00:19:45,440
um so if we now ask bill campbell to

00:19:43,360 --> 00:19:47,520
evaluate the expression my fund

00:19:45,440 --> 00:19:49,200
we'll get back the same expression uh

00:19:47,520 --> 00:19:50,640
the same function that we declared

00:19:49,200 --> 00:19:53,360
which is that function that's always

00:19:50,640 --> 00:19:57,360
going to return 42 no matter what we

00:19:53,360 --> 00:19:58,400
pass to it um so in ocam the way that

00:19:57,360 --> 00:20:00,240
you

00:19:58,400 --> 00:20:02,320
evaluate a function on an argument is

00:20:00,240 --> 00:20:03,840
you just put a space and then the

00:20:02,320 --> 00:20:06,960
argument so here we're saying

00:20:03,840 --> 00:20:10,080
evaluate my fun on the argument zero

00:20:06,960 --> 00:20:10,960
as expected we get 42. uh and here we

00:20:10,080 --> 00:20:12,880
get to see

00:20:10,960 --> 00:20:14,400
this polymorphism again we can give it a

00:20:12,880 --> 00:20:14,880
floating point number we're still going

00:20:14,400 --> 00:20:17,440
to get

00:20:14,880 --> 00:20:19,280
42. we can give it a list of strings

00:20:17,440 --> 00:20:21,120
we're still going to get 42.

00:20:19,280 --> 00:20:22,400
and so this is the parametric

00:20:21,120 --> 00:20:24,960
polymorphism

00:20:22,400 --> 00:20:26,320
kind of showing you its strength here uh

00:20:24,960 --> 00:20:29,280
there's also a shorter

00:20:26,320 --> 00:20:29,840
um way to write functions because that's

00:20:29,280 --> 00:20:32,799
such

00:20:29,840 --> 00:20:34,000
an um a common operation in programming

00:20:32,799 --> 00:20:35,120
and most of the time we do give

00:20:34,000 --> 00:20:36,640
functions in name

00:20:35,120 --> 00:20:38,159
um so if you want to define a function

00:20:36,640 --> 00:20:38,880
and give it a name you can actually just

00:20:38,159 --> 00:20:41,360
say let

00:20:38,880 --> 00:20:42,799
the function name and argument equals

00:20:41,360 --> 00:20:44,320
the expression that you want that

00:20:42,799 --> 00:20:46,080
function to return

00:20:44,320 --> 00:20:47,760
so this is another way that we can write

00:20:46,080 --> 00:20:49,200
the function that that just always

00:20:47,760 --> 00:20:52,799
returns 42

00:20:49,200 --> 00:20:55,120
and it ignores its argument so let's uh

00:20:52,799 --> 00:20:56,640
let's look at a couple examples here

00:20:55,120 --> 00:20:58,559
so a simple function that actually does

00:20:56,640 --> 00:20:59,440
use its argument is the successor

00:20:58,559 --> 00:21:02,720
function

00:20:59,440 --> 00:21:03,760
which takes an integer n and it computes

00:21:02,720 --> 00:21:05,840
n plus one

00:21:03,760 --> 00:21:07,120
okay so it's all it does is add one um

00:21:05,840 --> 00:21:08,799
and one of the neat things that you can

00:21:07,120 --> 00:21:10,640
see here is that ocaml

00:21:08,799 --> 00:21:12,240
automatically figured out that this is a

00:21:10,640 --> 00:21:13,840
function that takes an integer and

00:21:12,240 --> 00:21:17,200
returns an integer

00:21:13,840 --> 00:21:19,200
and the reason for that is because um

00:21:17,200 --> 00:21:20,240
addition of course only works on

00:21:19,200 --> 00:21:22,880
integers

00:21:20,240 --> 00:21:25,120
um at least in ocam so in oak camel

00:21:22,880 --> 00:21:27,200
there's a separate operator for floats

00:21:25,120 --> 00:21:28,159
um so okamo basically knows when you use

00:21:27,200 --> 00:21:31,200
the plus sign

00:21:28,159 --> 00:21:34,240
you're talking about integers

00:21:31,200 --> 00:21:34,960
um as expected if you try to compute 42

00:21:34,240 --> 00:21:37,600
plus 1

00:21:34,960 --> 00:21:38,559
you will get 43 so that's how we can

00:21:37,600 --> 00:21:41,200
call that

00:21:38,559 --> 00:21:43,039
really simple function uh let's look at

00:21:41,200 --> 00:21:44,080
something that's a little bit more weird

00:21:43,039 --> 00:21:45,600
this is something that you would

00:21:44,080 --> 00:21:46,400
probably never see in an imperative

00:21:45,600 --> 00:21:48,799
language

00:21:46,400 --> 00:21:49,520
um and this is the identity function so

00:21:48,799 --> 00:21:51,919
we're saying here

00:21:49,520 --> 00:21:54,000
let's define a function called id it's

00:21:51,919 --> 00:21:56,000
going to take an argument a

00:21:54,000 --> 00:21:57,919
and then we're just going to return a

00:21:56,000 --> 00:21:59,840
we're not going to do anything else uh

00:21:57,919 --> 00:22:00,400
and okay model says okay the type for

00:21:59,840 --> 00:22:04,080
this

00:22:00,400 --> 00:22:06,159
uh is going to be a placeholder type a

00:22:04,080 --> 00:22:08,080
as the argument and then whatever that

00:22:06,159 --> 00:22:08,640
type is is also going to be the return

00:22:08,080 --> 00:22:10,480
type

00:22:08,640 --> 00:22:11,679
and that has nothing to do with the name

00:22:10,480 --> 00:22:14,400
of the argument there

00:22:11,679 --> 00:22:17,360
it's a completely different name that's

00:22:14,400 --> 00:22:17,360
why it's apostrophe

00:22:17,600 --> 00:22:21,600
yeah not to confuse you you could if you

00:22:20,000 --> 00:22:24,640
wanted to you could go back in

00:22:21,600 --> 00:22:26,480
and you could actually call this p

00:22:24,640 --> 00:22:28,640
and re-evaluate it and it's actually the

00:22:26,480 --> 00:22:30,640
same function um but the type is

00:22:28,640 --> 00:22:32,320
ocam is just going to use um a because

00:22:30,640 --> 00:22:34,559
it starts at a

00:22:32,320 --> 00:22:36,240
um so we've just defined a function that

00:22:34,559 --> 00:22:37,760
takes an undetermined type and returns

00:22:36,240 --> 00:22:40,640
the same type which is

00:22:37,760 --> 00:22:42,159
kind of crazy um so let's try this out

00:22:40,640 --> 00:22:44,159
if we pass in zero

00:22:42,159 --> 00:22:46,640
guess what we're going to get that zero

00:22:44,159 --> 00:22:49,360
if we pass a string as an argument

00:22:46,640 --> 00:22:50,159
it's going to return that string

00:22:49,360 --> 00:22:51,760
similarly

00:22:50,159 --> 00:22:53,520
you know because this is a functional

00:22:51,760 --> 00:22:54,480
language and and functions are first

00:22:53,520 --> 00:22:57,039
class citizens

00:22:54,480 --> 00:22:58,640
we can pass in a list containing our

00:22:57,039 --> 00:23:00,159
function that we defined earlier

00:22:58,640 --> 00:23:02,159
and we're going to get back that same

00:23:00,159 --> 00:23:04,240
list containing our function

00:23:02,159 --> 00:23:06,320
um so again this is just kind of showing

00:23:04,240 --> 00:23:08,000
you some of the power that you get

00:23:06,320 --> 00:23:09,360
from functional language to allow you to

00:23:08,000 --> 00:23:10,080
do some things that you know you might

00:23:09,360 --> 00:23:13,120
not do

00:23:10,080 --> 00:23:15,520
um in an imperative language all right

00:23:13,120 --> 00:23:16,880
um obviously sometimes we need to have

00:23:15,520 --> 00:23:21,120
functions that take

00:23:16,880 --> 00:23:23,840
more than one argument um but not really

00:23:21,120 --> 00:23:24,320
and so um to do that you basically just

00:23:23,840 --> 00:23:26,640
write

00:23:24,320 --> 00:23:27,440
um all the arguments before the equal

00:23:26,640 --> 00:23:29,840
sign when you're

00:23:27,440 --> 00:23:31,919
when you're writing your let um binding

00:23:29,840 --> 00:23:33,520
so we basically say let add that takes

00:23:31,919 --> 00:23:35,440
arguments a and b

00:23:33,520 --> 00:23:37,360
and then as before we write the

00:23:35,440 --> 00:23:40,559
expression so here we want that

00:23:37,360 --> 00:23:42,559
function to return a plus b um

00:23:40,559 --> 00:23:44,400
now what's a little bit confusing here

00:23:42,559 --> 00:23:47,600
uh is if you look at this type

00:23:44,400 --> 00:23:48,880
um somehow we went somehow we got three

00:23:47,600 --> 00:23:52,159
different things we have

00:23:48,880 --> 00:23:53,520
ins arrow into arrow int um so what the

00:23:52,159 --> 00:23:56,720
heck happened here

00:23:53,520 --> 00:23:57,520
um and the trick uh basically is to

00:23:56,720 --> 00:24:00,720
interpret this

00:23:57,520 --> 00:24:02,799
by pretending that there are parentheses

00:24:00,720 --> 00:24:04,400
uh on the right hand side of that so

00:24:02,799 --> 00:24:06,480
what's really going on here

00:24:04,400 --> 00:24:08,480
um is if you give this function an

00:24:06,480 --> 00:24:10,799
integer it's going to hand you back

00:24:08,480 --> 00:24:12,480
another function that will take the

00:24:10,799 --> 00:24:14,400
remaining integer argument

00:24:12,480 --> 00:24:16,640
and finally that function will return

00:24:14,400 --> 00:24:18,880
your your final answer

00:24:16,640 --> 00:24:19,919
um so this is called curing and it

00:24:18,880 --> 00:24:23,600
basically just

00:24:19,919 --> 00:24:25,760
um allows you to to evaluate one

00:24:23,600 --> 00:24:29,279
argument at a time

00:24:25,760 --> 00:24:29,679
if you want to um of course most of the

00:24:29,279 --> 00:24:31,679
time

00:24:29,679 --> 00:24:32,960
we don't really do that we pass both

00:24:31,679 --> 00:24:35,279
arguments to a function

00:24:32,960 --> 00:24:36,400
and the good news is if you do that

00:24:35,279 --> 00:24:37,520
everything just works

00:24:36,400 --> 00:24:40,559
you know the way that you're used to

00:24:37,520 --> 00:24:42,080
calling functions we can pass 40 and 2

00:24:40,559 --> 00:24:43,679
and we add those two together and we get

00:24:42,080 --> 00:24:45,200
42.

00:24:43,679 --> 00:24:47,919
but one of the cool things that you can

00:24:45,200 --> 00:24:50,320
do because of curry is you can actually

00:24:47,919 --> 00:24:51,200
partially apply a function so our

00:24:50,320 --> 00:24:53,840
function right

00:24:51,200 --> 00:24:54,559
expects two values so if we pass one

00:24:53,840 --> 00:24:56,960
value

00:24:54,559 --> 00:24:59,679
we get back a function um that's

00:24:56,960 --> 00:25:00,320
basically waiting for that last argument

00:24:59,679 --> 00:25:01,840
um

00:25:00,320 --> 00:25:03,600
and we can actually take that last

00:25:01,840 --> 00:25:04,159
argument or sorry we can take that

00:25:03,600 --> 00:25:05,840
function

00:25:04,159 --> 00:25:07,360
and then we can pass the final argument

00:25:05,840 --> 00:25:10,320
to it um so here

00:25:07,360 --> 00:25:12,320
we're basically saying okay let's add 40

00:25:10,320 --> 00:25:14,799
that's going to give us this function

00:25:12,320 --> 00:25:16,480
that is an integer that takes an integer

00:25:14,799 --> 00:25:19,120
and returns an integer

00:25:16,480 --> 00:25:20,640
we can then call that function with one

00:25:19,120 --> 00:25:23,360
more argument too

00:25:20,640 --> 00:25:23,840
and we'll finally get back our answer so

00:25:23,360 --> 00:25:26,880
this

00:25:23,840 --> 00:25:28,080
allows you to basically uh do the

00:25:26,880 --> 00:25:30,960
function application

00:25:28,080 --> 00:25:31,600
one step at a time and just to note that

00:25:30,960 --> 00:25:33,440
partial

00:25:31,600 --> 00:25:35,120
application is something that's popping

00:25:33,440 --> 00:25:37,600
up in a lot of

00:25:35,120 --> 00:25:39,039
imperative languages um to make your

00:25:37,600 --> 00:25:40,640
code more efficient

00:25:39,039 --> 00:25:42,480
if there's a complex expression or

00:25:40,640 --> 00:25:44,320
something that you don't want to compute

00:25:42,480 --> 00:25:48,000
over and over

00:25:44,320 --> 00:25:49,360
okay so taking over here um

00:25:48,000 --> 00:25:51,039
i'm going to show you a couple of

00:25:49,360 --> 00:25:54,080
concepts that

00:25:51,039 --> 00:25:57,279
are really great tools to have in your

00:25:54,080 --> 00:25:58,559
programming tool box uh if you don't

00:25:57,279 --> 00:26:00,159
already

00:25:58,559 --> 00:26:01,919
and the primary ones we're going to talk

00:26:00,159 --> 00:26:05,120
about here are map

00:26:01,919 --> 00:26:06,720
filter and fold so these are things that

00:26:05,120 --> 00:26:08,080
we're going to show you in ocamel

00:26:06,720 --> 00:26:11,039
but we're also going to show you how to

00:26:08,080 --> 00:26:12,799
do them in javascript and python

00:26:11,039 --> 00:26:15,440
and they're appearing in pretty much

00:26:12,799 --> 00:26:18,400
every language that you might be using

00:26:15,440 --> 00:26:19,360
so the idea of map is you have a bunch

00:26:18,400 --> 00:26:22,640
of values

00:26:19,360 --> 00:26:24,480
and you want to do the same computation

00:26:22,640 --> 00:26:25,360
or processing with every single one of

00:26:24,480 --> 00:26:27,760
those values

00:26:25,360 --> 00:26:29,600
and get all of the results in an

00:26:27,760 --> 00:26:30,559
imperative language you're automatically

00:26:29,600 --> 00:26:32,960
going to think

00:26:30,559 --> 00:26:34,400
loop i need to iterate over those values

00:26:32,960 --> 00:26:37,520
and do each thing

00:26:34,400 --> 00:26:39,760
in functional programming you think map

00:26:37,520 --> 00:26:41,679
all right and map is a higher order

00:26:39,760 --> 00:26:42,960
function because it takes a function as

00:26:41,679 --> 00:26:44,960
a parameter

00:26:42,960 --> 00:26:46,400
and then it applies that function to

00:26:44,960 --> 00:26:48,640
every value in the list

00:26:46,400 --> 00:26:50,559
gives you back a list of the results so

00:26:48,640 --> 00:26:52,159
the results will always have the same

00:26:50,559 --> 00:26:54,799
length

00:26:52,159 --> 00:26:56,799
of the list of the original lists that

00:26:54,799 --> 00:27:00,559
you start with

00:26:56,799 --> 00:27:03,760
so let's look at a few examples

00:27:00,559 --> 00:27:07,679
so here we're saying um

00:27:03,760 --> 00:27:12,480
i'm going to set the function add 42

00:27:07,679 --> 00:27:15,919
to be taken in argument x

00:27:12,480 --> 00:27:19,039
and take x plus 42 so

00:27:15,919 --> 00:27:20,240
now if for some mysterious reason i want

00:27:19,039 --> 00:27:23,600
to add 42

00:27:20,240 --> 00:27:25,200
to every value in a list um i can do

00:27:23,600 --> 00:27:27,520
list.map

00:27:25,200 --> 00:27:29,520
pass in the function i want to apply the

00:27:27,520 --> 00:27:30,240
list of values that i want to apply it

00:27:29,520 --> 00:27:32,640
to

00:27:30,240 --> 00:27:34,159
and i will get back the list of results

00:27:32,640 --> 00:27:35,660
so 43 44

00:27:34,159 --> 00:27:37,520
and 45.

00:27:35,660 --> 00:27:39,760
[Music]

00:27:37,520 --> 00:27:41,919
we can also do this without giving a

00:27:39,760 --> 00:27:45,200
name to that kind of dumb function maybe

00:27:41,919 --> 00:27:47,760
we don't want add 42 in our namespace

00:27:45,200 --> 00:27:48,720
okay cluttering things up so we can call

00:27:47,760 --> 00:27:51,520
this.map

00:27:48,720 --> 00:27:53,440
and use the lambda function syntax to do

00:27:51,520 --> 00:27:56,640
that anonymously

00:27:53,440 --> 00:27:56,640
we get the same results

00:27:57,120 --> 00:28:02,880
okay here's a slightly more uh

00:28:00,320 --> 00:28:04,399
useful function probably we're going to

00:28:02,880 --> 00:28:07,200
square a number

00:28:04,399 --> 00:28:07,919
so we name our function let's square x

00:28:07,200 --> 00:28:10,960
equal

00:28:07,919 --> 00:28:14,240
x times x and if we map

00:28:10,960 --> 00:28:17,440
that square function over the list 0 1 2

00:28:14,240 --> 00:28:19,679
3 4 you can see that we get the list

00:28:17,440 --> 00:28:21,679
containing all of those squares

00:28:19,679 --> 00:28:23,600
so we're doing some really powerful

00:28:21,679 --> 00:28:24,559
computation that in an imperative

00:28:23,600 --> 00:28:27,600
language

00:28:24,559 --> 00:28:30,080
would normally take you you know

00:28:27,600 --> 00:28:31,200
10 lines to write we're doing that in

00:28:30,080 --> 00:28:34,880
one line

00:28:31,200 --> 00:28:38,240
okay all right

00:28:34,880 --> 00:28:41,120
um we can also do that repeatedly

00:28:38,240 --> 00:28:42,799
so if i want to square the squares

00:28:41,120 --> 00:28:45,360
that's just one more line and

00:28:42,799 --> 00:28:47,679
actually i could do that all in one line

00:28:45,360 --> 00:28:49,919
um and you can see us kind of reapplying

00:28:47,679 --> 00:28:49,919
that

00:28:50,559 --> 00:28:55,919
another useful function is filter this

00:28:53,840 --> 00:28:58,880
is again a higher order function because

00:28:55,919 --> 00:29:01,120
it takes a function as a parameter

00:28:58,880 --> 00:29:02,080
and what filter does is it takes a

00:29:01,120 --> 00:29:05,039
function that

00:29:02,080 --> 00:29:08,240
has to return a boolean so the function

00:29:05,039 --> 00:29:10,880
we pass in here returns true or false

00:29:08,240 --> 00:29:12,000
and we take in a list of values and we

00:29:10,880 --> 00:29:14,799
apply the function to

00:29:12,000 --> 00:29:15,520
every value in that list but we only

00:29:14,799 --> 00:29:18,240
return

00:29:15,520 --> 00:29:20,000
those values where the function

00:29:18,240 --> 00:29:22,000
evaluated to true

00:29:20,000 --> 00:29:24,159
okay so this would be like i have this

00:29:22,000 --> 00:29:26,960
bunch of values tell me all the values

00:29:24,159 --> 00:29:29,140
that satisfy some condition that's when

00:29:26,960 --> 00:29:30,320
you use a filter

00:29:29,140 --> 00:29:33,360
[Music]

00:29:30,320 --> 00:29:35,520
yeah map is fabulous fold is also

00:29:33,360 --> 00:29:38,159
terrific we're going to look at that

00:29:35,520 --> 00:29:39,440
okay so let's look at a few examples of

00:29:38,159 --> 00:29:41,919
filter

00:29:39,440 --> 00:29:42,880
um so here i define a function is

00:29:41,919 --> 00:29:45,840
positive

00:29:42,880 --> 00:29:47,840
and i simply evaluate the expression is

00:29:45,840 --> 00:29:49,679
that value greater than zero

00:29:47,840 --> 00:29:52,080
that is a boolean expression so it

00:29:49,679 --> 00:29:53,520
returns true or false

00:29:52,080 --> 00:29:56,320
and if you're still awake and

00:29:53,520 --> 00:29:58,000
caffeinated enough you can probably look

00:29:56,320 --> 00:29:59,679
at the list of numbers negative two

00:29:58,000 --> 00:30:02,480
negative zero negative one

00:29:59,679 --> 00:30:04,320
zero one and two and know that only one

00:30:02,480 --> 00:30:08,559
and two are greater than zero

00:30:04,320 --> 00:30:11,919
so those are the values we get back

00:30:08,559 --> 00:30:12,640
similar example is even here we're doing

00:30:11,919 --> 00:30:14,640
the

00:30:12,640 --> 00:30:16,960
mod operator which is the remainder

00:30:14,640 --> 00:30:20,799
operator so we're basically asking

00:30:16,960 --> 00:30:22,799
is this number evenly divisible by two

00:30:20,799 --> 00:30:24,159
and we go through this list of numbers

00:30:22,799 --> 00:30:27,039
one through ten

00:30:24,159 --> 00:30:29,840
and as you can see we get back the list

00:30:27,039 --> 00:30:32,799
of the evenly divisible by two numbers

00:30:29,840 --> 00:30:32,799
the even numbers

00:30:34,399 --> 00:30:37,919
okay our favorite functional list

00:30:37,200 --> 00:30:41,440
operation

00:30:37,919 --> 00:30:44,799
is folding um and we agree on that

00:30:41,440 --> 00:30:45,600
so the intuition of folding is that you

00:30:44,799 --> 00:30:48,399
can take some

00:30:45,600 --> 00:30:49,120
operator apply it over a list and

00:30:48,399 --> 00:30:51,600
combine

00:30:49,120 --> 00:30:52,960
all of those values down to one value

00:30:51,600 --> 00:30:53,840
all right so you're folding a whole

00:30:52,960 --> 00:30:57,120
bunch of

00:30:53,840 --> 00:30:57,760
values down to one an easy way to think

00:30:57,120 --> 00:31:00,399
about this

00:30:57,760 --> 00:31:00,960
is with addition so normally we think of

00:31:00,399 --> 00:31:03,519
addition

00:31:00,960 --> 00:31:04,000
as a binary operator we take three plus

00:31:03,519 --> 00:31:07,279
two

00:31:04,000 --> 00:31:07,679
we get five but it's also easy to think

00:31:07,279 --> 00:31:10,240
about

00:31:07,679 --> 00:31:11,519
applying addition across a whole bunch

00:31:10,240 --> 00:31:14,960
of values

00:31:11,519 --> 00:31:15,519
so if we had one two and three and we

00:31:14,960 --> 00:31:17,760
applied

00:31:15,519 --> 00:31:19,200
addition across the whole list we would

00:31:17,760 --> 00:31:21,440
accumulate the value of

00:31:19,200 --> 00:31:21,440
six

00:31:22,960 --> 00:31:30,080
so um oh camel gives us a function

00:31:26,880 --> 00:31:32,799
that does this kind of in in one pass

00:31:30,080 --> 00:31:33,679
and what we're taking in here for add

00:31:32,799 --> 00:31:35,679
we're defining an

00:31:33,679 --> 00:31:39,360
add function that takes in two numbers

00:31:35,679 --> 00:31:42,799
n1 and n2 and simply adds them together

00:31:39,360 --> 00:31:46,159
so if i have my uh

00:31:42,799 --> 00:31:49,320
fold left operator here and

00:31:46,159 --> 00:31:50,640
i am calling my add function i'm

00:31:49,320 --> 00:31:54,000
initializing

00:31:50,640 --> 00:31:57,039
the uh operation at zero and

00:31:54,000 --> 00:31:58,000
i'm passing in the list so what happens

00:31:57,039 --> 00:32:01,760
here

00:31:58,000 --> 00:32:04,399
is i'm going along and i started at zero

00:32:01,760 --> 00:32:06,320
that's what this argument here is right

00:32:04,399 --> 00:32:08,480
in the fold left call

00:32:06,320 --> 00:32:09,919
so i take the first value in the list

00:32:08,480 --> 00:32:13,519
zero plus one gives me

00:32:09,919 --> 00:32:16,159
one i take that i add two

00:32:13,519 --> 00:32:16,880
all right so now i have three i take

00:32:16,159 --> 00:32:19,519
that i add

00:32:16,880 --> 00:32:21,519
three i get six i take that i add four i

00:32:19,519 --> 00:32:25,200
get ten

00:32:21,519 --> 00:32:26,080
um head corners rule no i'm not familiar

00:32:25,200 --> 00:32:29,279
with that actually

00:32:26,080 --> 00:32:32,880
okay so um

00:32:29,279 --> 00:32:36,159
now the key piece here is actually

00:32:32,880 --> 00:32:39,360
that the first argument in the function

00:32:36,159 --> 00:32:41,919
that n1 is an accumulator

00:32:39,360 --> 00:32:43,279
so we're not simply taking i mean we are

00:32:41,919 --> 00:32:44,080
taking two numbers and adding them

00:32:43,279 --> 00:32:46,880
together

00:32:44,080 --> 00:32:48,559
but what fold left is doing is always

00:32:46,880 --> 00:32:51,519
passing that first argument

00:32:48,559 --> 00:32:51,840
is the accumulator we've gotten so far

00:32:51,519 --> 00:32:55,200
so

00:32:51,840 --> 00:32:58,320
here i'm showing um multiplication

00:32:55,200 --> 00:32:58,880
we're doing a product and what we're

00:32:58,320 --> 00:33:01,840
doing

00:32:58,880 --> 00:33:03,600
is we are taking in two numbers again

00:33:01,840 --> 00:33:04,000
but here i've named that first one a

00:33:03,600 --> 00:33:05,840
queue

00:33:04,000 --> 00:33:07,440
to make it clearer that that is actually

00:33:05,840 --> 00:33:10,480
an accumulator

00:33:07,440 --> 00:33:12,480
and now we need to start the operation

00:33:10,480 --> 00:33:14,480
the accumulation at one

00:33:12,480 --> 00:33:15,840
because of course if we use zero we're

00:33:14,480 --> 00:33:17,950
just going to get back a zero

00:33:15,840 --> 00:33:19,440
as our total result

00:33:17,950 --> 00:33:22,559
[Music]

00:33:19,440 --> 00:33:24,960
so here we're folding over this

00:33:22,559 --> 00:33:26,240
and so we start at one and we take the

00:33:24,960 --> 00:33:29,600
first value one

00:33:26,240 --> 00:33:29,919
and we get one and then we multiply that

00:33:29,600 --> 00:33:33,519
by

00:33:29,919 --> 00:33:34,799
two and so we get two and we multiply

00:33:33,519 --> 00:33:37,200
that by three and we get

00:33:34,799 --> 00:33:38,559
six then we multiply that by four and we

00:33:37,200 --> 00:33:40,960
get 24.

00:33:38,559 --> 00:33:42,000
so we're taking that operation combining

00:33:40,960 --> 00:33:44,880
all the values

00:33:42,000 --> 00:33:45,279
getting that single result let's look at

00:33:44,880 --> 00:33:48,240
one

00:33:45,279 --> 00:33:50,159
that may be a little less intuitive than

00:33:48,240 --> 00:33:52,159
just like okay yeah you're summing or

00:33:50,159 --> 00:33:56,159
multiplying a list

00:33:52,159 --> 00:33:59,760
we want to know the length of a list

00:33:56,159 --> 00:34:02,720
so i'm defining this increase count

00:33:59,760 --> 00:34:03,600
function here it takes an accumulator

00:34:02,720 --> 00:34:05,840
and an element

00:34:03,600 --> 00:34:07,919
because it has to that's the format that

00:34:05,840 --> 00:34:10,320
a fold requires

00:34:07,919 --> 00:34:11,440
and you're going to just one add one to

00:34:10,320 --> 00:34:14,960
the accumulator

00:34:11,440 --> 00:34:18,560
so we're completely ignoring

00:34:14,960 --> 00:34:20,240
um the the element itself

00:34:18,560 --> 00:34:23,440
because we don't care what the value in

00:34:20,240 --> 00:34:26,399
the list is we just want to count them

00:34:23,440 --> 00:34:27,760
so here we are christians asking are

00:34:26,399 --> 00:34:28,320
basically are these built into the

00:34:27,760 --> 00:34:31,760
language

00:34:28,320 --> 00:34:32,879
we'll start it yes so yeah so list.map

00:34:31,760 --> 00:34:35,359
lists up fold

00:34:32,879 --> 00:34:36,960
left and lift that filter are all in the

00:34:35,359 --> 00:34:40,800
o chemical standard library

00:34:36,960 --> 00:34:44,000
yes okay so if we're doing

00:34:40,800 --> 00:34:47,040
if we're calling that list length um

00:34:44,000 --> 00:34:49,119
across a list of values

00:34:47,040 --> 00:34:52,399
we obviously were counting so we want to

00:34:49,119 --> 00:34:54,320
start our accumulator at zero

00:34:52,399 --> 00:34:57,200
and what we're going to get do you want

00:34:54,320 --> 00:34:57,200
to know right now

00:34:58,800 --> 00:35:05,680
that's so hot yeah what is that i'm

00:35:03,760 --> 00:35:06,890
not sure why that happened did it not

00:35:05,680 --> 00:35:11,690
run that

00:35:06,890 --> 00:35:11,690
[Music]

00:35:13,760 --> 00:35:20,960
interesting that's super weird

00:35:17,680 --> 00:35:21,920
anyway it's going to go over that list

00:35:20,960 --> 00:35:25,200
and it's going to

00:35:21,920 --> 00:35:27,599
define those it's going to fold that

00:35:25,200 --> 00:35:31,280
over and count the elements

00:35:27,599 --> 00:35:35,839
this signature has an ink coming first

00:35:31,280 --> 00:35:35,839
will spotted it yeah but this

00:35:42,839 --> 00:35:45,839
oh

00:35:50,160 --> 00:35:52,320
and

00:35:55,040 --> 00:35:59,680
all right let's i don't know what

00:35:56,720 --> 00:36:03,520
happened here this is zero

00:35:59,680 --> 00:36:06,240
oh sorry wrong example yeah yeah um

00:36:03,520 --> 00:36:07,520
okay on the next one the accumulator is

00:36:06,240 --> 00:36:09,340
um

00:36:07,520 --> 00:36:10,880
is a list

00:36:09,340 --> 00:36:13,119
[Music]

00:36:10,880 --> 00:36:14,320
yeah i think we actually got rid of the

00:36:13,119 --> 00:36:18,960
button

00:36:14,320 --> 00:36:20,880
yeah okay sorry about that all right and

00:36:18,960 --> 00:36:24,839
[Music]

00:36:20,880 --> 00:36:26,000
it's not live unless there's errors yeah

00:36:24,839 --> 00:36:28,320
okay

00:36:26,000 --> 00:36:29,040
evaluate that one too all right so

00:36:28,320 --> 00:36:31,520
that's really

00:36:29,040 --> 00:36:32,400
supposed to work it worked last night i

00:36:31,520 --> 00:36:35,119
swear

00:36:32,400 --> 00:36:36,480
okay so um there you can see the list

00:36:35,119 --> 00:36:39,040
length is three

00:36:36,480 --> 00:36:40,480
what's happening if you call list length

00:36:39,040 --> 00:36:41,920
on an empty list

00:36:40,480 --> 00:36:43,680
is that we're never actually calling

00:36:41,920 --> 00:36:44,400
that function at all we're just

00:36:43,680 --> 00:36:46,560
returning

00:36:44,400 --> 00:36:48,079
the initial value of the accumulator

00:36:46,560 --> 00:36:50,970
which was zero

00:36:48,079 --> 00:36:52,480
okay so

00:36:50,970 --> 00:36:55,520
[Music]

00:36:52,480 --> 00:36:57,839
um all right one more fold

00:36:55,520 --> 00:36:58,560
uh and what we're going to do is we're

00:36:57,839 --> 00:37:02,160
going to use

00:36:58,560 --> 00:37:05,359
fold to reverse a list okay

00:37:02,160 --> 00:37:07,520
so here what we're going to do is

00:37:05,359 --> 00:37:09,520
we're going to construct a list as our

00:37:07,520 --> 00:37:10,160
result and we haven't looked at how to

00:37:09,520 --> 00:37:13,440
do this

00:37:10,160 --> 00:37:16,800
but this is a really key operation

00:37:13,440 --> 00:37:18,400
in functional programming because lists

00:37:16,800 --> 00:37:20,000
are so important we need to be able to

00:37:18,400 --> 00:37:23,119
build lists

00:37:20,000 --> 00:37:24,400
so we read this operator as cons for

00:37:23,119 --> 00:37:27,839
construct

00:37:24,400 --> 00:37:30,880
so a cons b means take the value a

00:37:27,839 --> 00:37:31,280
and put it at the front of list b so if

00:37:30,880 --> 00:37:34,960
i do

00:37:31,280 --> 00:37:38,560
1 cons the list 2 3 i get the result 1 2

00:37:34,960 --> 00:37:41,760
three all right

00:37:38,560 --> 00:37:42,720
so we're defining this very verbose uh

00:37:41,760 --> 00:37:45,359
function here

00:37:42,720 --> 00:37:46,400
add to front of list i take in the

00:37:45,359 --> 00:37:49,280
accumulator

00:37:46,400 --> 00:37:50,720
which is the list that i've built so far

00:37:49,280 --> 00:37:52,720
and the element

00:37:50,720 --> 00:37:54,960
and i add the element to the front of

00:37:52,720 --> 00:37:58,000
the accumulated list

00:37:54,960 --> 00:38:00,800
so as i fold what i'm going to do

00:37:58,000 --> 00:38:01,280
is i'm going to take each element all

00:38:00,800 --> 00:38:03,119
right

00:38:01,280 --> 00:38:06,079
starting with an empty list which is

00:38:03,119 --> 00:38:09,119
somehow what got into our earlier

00:38:06,079 --> 00:38:11,280
example and i'm going to

00:38:09,119 --> 00:38:12,160
start adding the values from front to

00:38:11,280 --> 00:38:15,119
back to

00:38:12,160 --> 00:38:16,079
that accumulator so first i'm going to

00:38:15,119 --> 00:38:18,400
take the 1

00:38:16,079 --> 00:38:19,200
and i'm going to add that into the empty

00:38:18,400 --> 00:38:21,040
list

00:38:19,200 --> 00:38:22,480
and then i'm going to take the two and

00:38:21,040 --> 00:38:23,760
i'm going to add it to the list that

00:38:22,480 --> 00:38:25,440
contains one

00:38:23,760 --> 00:38:27,200
and then i'm going to take the three and

00:38:25,440 --> 00:38:28,400
i'm going to add that to the list that

00:38:27,200 --> 00:38:31,680
contains two and one

00:38:28,400 --> 00:38:33,200
and so i'm building it backwards notice

00:38:31,680 --> 00:38:35,359
that there is a list

00:38:33,200 --> 00:38:37,839
we've been saying fold left this whole

00:38:35,359 --> 00:38:38,320
time and that means we work from the

00:38:37,839 --> 00:38:41,359
left

00:38:38,320 --> 00:38:42,240
to the right of the list okay there is

00:38:41,359 --> 00:38:44,960
also a full

00:38:42,240 --> 00:38:46,960
right it's much less commonly used um

00:38:44,960 --> 00:38:48,410
and that means we process the list in

00:38:46,960 --> 00:38:49,839
the opposite order

00:38:48,410 --> 00:38:53,839
[Music]

00:38:49,839 --> 00:38:54,320
okay um we're running a little low on

00:38:53,839 --> 00:38:56,000
time

00:38:54,320 --> 00:38:58,000
so we just want to tell you that this

00:38:56,000 --> 00:39:00,000
example is here

00:38:58,000 --> 00:39:02,240
this is from the first day of advent of

00:39:00,000 --> 00:39:04,720
code and we both looked at this

00:39:02,240 --> 00:39:05,920
and said oh my gosh that's so nice

00:39:04,720 --> 00:39:08,400
functionally

00:39:05,920 --> 00:39:09,760
um it was the example where you need you

00:39:08,400 --> 00:39:11,839
have a whole list of numbers

00:39:09,760 --> 00:39:12,800
and you need to find two that add to

00:39:11,839 --> 00:39:15,920
00:39:12,800 --> 00:39:19,359
and then as your answer you need to uh

00:39:15,920 --> 00:39:21,119
return that value multiply them multiply

00:39:19,359 --> 00:39:23,040
them together

00:39:21,119 --> 00:39:24,880
so we walk through kind of how you do

00:39:23,040 --> 00:39:26,160
that and if you're interested definitely

00:39:24,880 --> 00:39:27,599
take a look at that

00:39:26,160 --> 00:39:29,040
but we want to show you and charlie

00:39:27,599 --> 00:39:29,839
we're going to go probably a little bit

00:39:29,040 --> 00:39:32,240
over

00:39:29,839 --> 00:39:33,040
um we want to show you these operator

00:39:32,240 --> 00:39:36,400
operations

00:39:33,040 --> 00:39:38,240
in javascript and python yeah stephanie

00:39:36,400 --> 00:39:39,760
that should be that should be fine if if

00:39:38,240 --> 00:39:41,119
we overshoot a little bit that would be

00:39:39,760 --> 00:39:42,960
okay uh just really quick jeremy

00:39:41,119 --> 00:39:44,560
stelzfus did you have a question

00:39:42,960 --> 00:39:47,040
that you wanted to get in before they

00:39:44,560 --> 00:39:49,839
show their their final examples

00:39:47,040 --> 00:39:50,960
um i think i just enabled you so you

00:39:49,839 --> 00:39:56,400
should be able to

00:39:50,960 --> 00:39:58,480
unmute yourself and ask that question

00:39:56,400 --> 00:40:00,880
and if not you can certainly add it to

00:39:58,480 --> 00:40:04,240
the chat as well

00:40:00,880 --> 00:40:06,480
okay i guess not okay great

00:40:04,240 --> 00:40:07,359
so let's um let's look at how we do some

00:40:06,480 --> 00:40:11,599
of these things

00:40:07,359 --> 00:40:14,480
in some other languages like javascript

00:40:11,599 --> 00:40:15,119
so here is an example where we're doing

00:40:14,480 --> 00:40:18,160
a map

00:40:15,119 --> 00:40:20,400
in javascript and it's it's very similar

00:40:18,160 --> 00:40:22,319
yet a little bit different so here is a

00:40:20,400 --> 00:40:23,520
list in javascript

00:40:22,319 --> 00:40:25,760
and one of the things that's a little

00:40:23,520 --> 00:40:28,880
bit different in javascript is that map

00:40:25,760 --> 00:40:30,079
is actually a method on the list type so

00:40:28,880 --> 00:40:32,480
here we're basically saying

00:40:30,079 --> 00:40:33,760
here's my list on that list i want to

00:40:32,480 --> 00:40:35,680
call the method map

00:40:33,760 --> 00:40:37,200
and then we're passing in a lambda

00:40:35,680 --> 00:40:39,119
function um

00:40:37,200 --> 00:40:41,760
this is just a little bit different

00:40:39,119 --> 00:40:43,680
syntax than you know what we saw in ocam

00:40:41,760 --> 00:40:45,680
but this is basically saying the lambda

00:40:43,680 --> 00:40:48,880
function that takes argument x

00:40:45,680 --> 00:40:50,880
um and returns x plus 42. so again this

00:40:48,880 --> 00:40:51,599
is just a function that adds 42 to

00:40:50,880 --> 00:40:54,880
whatever

00:40:51,599 --> 00:40:56,800
number that you're passing in filtering

00:40:54,880 --> 00:40:58,960
is extremely similar

00:40:56,800 --> 00:41:00,480
it's also a method that you call right

00:40:58,960 --> 00:41:02,960
on the list

00:41:00,480 --> 00:41:05,440
you also can just pass a lambda function

00:41:02,960 --> 00:41:07,359
so here this is the lambda function for

00:41:05,440 --> 00:41:10,800
filtering out and only returning the

00:41:07,359 --> 00:41:10,800
positive numbers in this list

00:41:10,960 --> 00:41:16,000
and fold is kind of weird in that it has

00:41:14,560 --> 00:41:19,200
a bunch of different names

00:41:16,000 --> 00:41:21,200
so a lot of languages call fold reduce

00:41:19,200 --> 00:41:22,400
um javascript is one of these and we'll

00:41:21,200 --> 00:41:25,280
see python

00:41:22,400 --> 00:41:26,240
also calls it reduce as kind of a side

00:41:25,280 --> 00:41:29,839
note if you've heard of

00:41:26,240 --> 00:41:31,520
mapreduce before um yeah google's

00:41:29,839 --> 00:41:35,040
mapreduce

00:41:31,520 --> 00:41:36,720
platform the map and the reduce are

00:41:35,040 --> 00:41:38,640
really the map and the fold that

00:41:36,720 --> 00:41:40,480
um that stephanie was talking about

00:41:38,640 --> 00:41:41,920
because they're so powerful with dealing

00:41:40,480 --> 00:41:44,800
with large data sets and

00:41:41,920 --> 00:41:45,839
and you know just iterating over them

00:41:44,800 --> 00:41:47,520
without iterating

00:41:45,839 --> 00:41:50,079
and obviously map is extremely

00:41:47,520 --> 00:41:52,160
paralyzable

00:41:50,079 --> 00:41:53,119
but anyway besides being called reduce

00:41:52,160 --> 00:41:56,720
and not

00:41:53,119 --> 00:41:59,440
fold again this is a method

00:41:56,720 --> 00:42:00,400
this syntax is is basically a lambda

00:41:59,440 --> 00:42:02,079
function with

00:42:00,400 --> 00:42:04,319
two parameters so we have our

00:42:02,079 --> 00:42:05,599
accumulator um we're also taking the

00:42:04,319 --> 00:42:07,680
next element

00:42:05,599 --> 00:42:08,880
and this particular lambda function is

00:42:07,680 --> 00:42:11,119
just adding them together

00:42:08,880 --> 00:42:12,319
so this is a sum of the numbers between

00:42:11,119 --> 00:42:14,319
one and four

00:42:12,319 --> 00:42:16,319
um and then the zero at the end is just

00:42:14,319 --> 00:42:18,560
our initial accumulator

00:42:16,319 --> 00:42:20,560
so again this is just a complicated way

00:42:18,560 --> 00:42:23,599
of doing some

00:42:20,560 --> 00:42:25,040
um i also have kind of an interesting

00:42:23,599 --> 00:42:28,319
example that i ran into

00:42:25,040 --> 00:42:30,480
personally recently i

00:42:28,319 --> 00:42:32,720
spend a lot of time trying to find good

00:42:30,480 --> 00:42:35,200
um deals on car leases

00:42:32,720 --> 00:42:37,520
and uh i recently found that volvo has a

00:42:35,200 --> 00:42:38,560
public api with tons and tons of uh

00:42:37,520 --> 00:42:41,760
information

00:42:38,560 --> 00:42:43,440
about um these parameters and uh one of

00:42:41,760 --> 00:42:44,880
the things that i realized is that they

00:42:43,440 --> 00:42:46,560
have

00:42:44,880 --> 00:42:48,319
the interest rate available in this

00:42:46,560 --> 00:42:50,079
information which can be kind of tedious

00:42:48,319 --> 00:42:51,920
to get otherwise

00:42:50,079 --> 00:42:54,800
but unfortunately it's in this giant

00:42:51,920 --> 00:42:56,880
list of incentives and stuff related to

00:42:54,800 --> 00:42:57,920
loans and basically you have to go

00:42:56,880 --> 00:43:00,960
through all this

00:42:57,920 --> 00:43:02,640
structured json data um and it's

00:43:00,960 --> 00:43:04,720
we have an example here if you want to

00:43:02,640 --> 00:43:05,280
go through it uh basically how to go

00:43:04,720 --> 00:43:07,680
through

00:43:05,280 --> 00:43:09,040
um with all these different requirements

00:43:07,680 --> 00:43:12,319
and basically search for

00:43:09,040 --> 00:43:14,240
the uh um the interest rate

00:43:12,319 --> 00:43:15,520
um but again we don't have time to go

00:43:14,240 --> 00:43:17,040
through that today because we just want

00:43:15,520 --> 00:43:18,640
to we want to get through kind of

00:43:17,040 --> 00:43:20,319
how do you actually use this stuff and

00:43:18,640 --> 00:43:23,839
examples so

00:43:20,319 --> 00:43:24,800
um last but not least we are going to

00:43:23,839 --> 00:43:29,920
talk about

00:43:24,800 --> 00:43:29,920
how to do this kind of stuff in python

00:43:31,920 --> 00:43:35,920
and in python it's a little bit

00:43:33,359 --> 00:43:37,520
different um the easiest way to use

00:43:35,920 --> 00:43:40,800
map and filter in python is through

00:43:37,520 --> 00:43:43,200
something called a list comprehension

00:43:40,800 --> 00:43:46,079
and so here's an example of we're going

00:43:43,200 --> 00:43:49,200
to use map to just square each element

00:43:46,079 --> 00:43:52,160
so here's our list one through five

00:43:49,200 --> 00:43:53,920
and the way that these comprehensions

00:43:52,160 --> 00:43:55,359
work is you're actually using syntax to

00:43:53,920 --> 00:43:56,000
build a new list so we're basically

00:43:55,359 --> 00:43:59,599
saying

00:43:56,000 --> 00:44:02,800
starting from lists in every element x

00:43:59,599 --> 00:44:05,680
in this list i would return a new list

00:44:02,800 --> 00:44:06,640
for x times x so this is basically

00:44:05,680 --> 00:44:09,520
equivalent to

00:44:06,640 --> 00:44:10,480
mapping over x times x and as you can

00:44:09,520 --> 00:44:12,640
see we get the

00:44:10,480 --> 00:44:14,960
the square of the values that we started

00:44:12,640 --> 00:44:18,079
from here

00:44:14,960 --> 00:44:18,880
the second example here is a filter

00:44:18,079 --> 00:44:22,640
example

00:44:18,880 --> 00:44:25,200
and kind of similar to the map example

00:44:22,640 --> 00:44:26,720
we're saying starting with each element

00:44:25,200 --> 00:44:29,760
x and list

00:44:26,720 --> 00:44:32,720
we want to return the values x

00:44:29,760 --> 00:44:34,480
but we only want to do that if this uh

00:44:32,720 --> 00:44:36,160
this particular expression is true

00:44:34,480 --> 00:44:38,000
so here we're basically saying if the

00:44:36,160 --> 00:44:39,599
value is either

00:44:38,000 --> 00:44:41,599
so here we're returning two and four the

00:44:39,599 --> 00:44:43,520
only even numbers

00:44:41,599 --> 00:44:45,200
and of course the the real beauty of

00:44:43,520 --> 00:44:46,079
comprehensions is that you can actually

00:44:45,200 --> 00:44:48,000
combine them

00:44:46,079 --> 00:44:49,200
which is where you get really really you

00:44:48,000 --> 00:44:50,240
know a lot of power in a really

00:44:49,200 --> 00:44:52,400
successful form

00:44:50,240 --> 00:44:53,359
so here we're saying uh for every x in

00:44:52,400 --> 00:44:56,640
the list that is

00:44:53,359 --> 00:44:57,760
even i want to return x squared uh and

00:44:56,640 --> 00:44:59,040
so

00:44:57,760 --> 00:45:00,319
you know here we're doing that and we're

00:44:59,040 --> 00:45:01,920
squaring the numbers and so we're

00:45:00,319 --> 00:45:03,760
getting 4 and 16.

00:45:01,920 --> 00:45:05,520
and obviously this is a really succinct

00:45:03,760 --> 00:45:06,560
and nice syntax for being able to do

00:45:05,520 --> 00:45:09,680
that

00:45:06,560 --> 00:45:10,560
um python also has fold but they call it

00:45:09,680 --> 00:45:12,960
reduce

00:45:10,560 --> 00:45:14,319
um it is not so this it's in this funk

00:45:12,960 --> 00:45:16,560
tools module which is

00:45:14,319 --> 00:45:18,720
a standard module but you have to import

00:45:16,560 --> 00:45:20,480
it manually um other than that

00:45:18,720 --> 00:45:22,560
it's basically the same as folding that

00:45:20,480 --> 00:45:25,200
we've seen so we basically

00:45:22,560 --> 00:45:25,839
pass in the function we can use addition

00:45:25,200 --> 00:45:28,560
here

00:45:25,839 --> 00:45:32,000
pass in the list that we want to sum and

00:45:28,560 --> 00:45:34,400
the accumulator and here we get 15.

00:45:32,000 --> 00:45:36,560
of course if we didn't know about this

00:45:34,400 --> 00:45:39,440
kind of pre-defined version of addition

00:45:36,560 --> 00:45:41,040
we could use a lambda function this is

00:45:39,440 --> 00:45:43,040
basically how you say the function that

00:45:41,040 --> 00:45:45,280
adds two numbers and

00:45:43,040 --> 00:45:46,560
in the lambda syntax and python and

00:45:45,280 --> 00:45:49,839
obviously we get back the

00:45:46,560 --> 00:45:50,960
the same result there so um kind of the

00:45:49,839 --> 00:45:52,240
point here is that

00:45:50,960 --> 00:45:54,480
you know even if you don't spend your

00:45:52,240 --> 00:45:57,520
days coding in a functional language

00:45:54,480 --> 00:45:59,520
um these concepts you know really are

00:45:57,520 --> 00:46:01,599
available in a lot of the languages

00:45:59,520 --> 00:46:02,800
um you know that you're using on on a

00:46:01,599 --> 00:46:05,200
daily basis

00:46:02,800 --> 00:46:06,079
um we didn't talk about them but java

00:46:05,200 --> 00:46:09,760
has the streams

00:46:06,079 --> 00:46:12,000
api um c plus plus has a new range api

00:46:09,760 --> 00:46:14,560
and the adapters are very basically

00:46:12,000 --> 00:46:16,000
allow you to do these operations um

00:46:14,560 --> 00:46:17,440
so hopefully we gave you a new way to

00:46:16,000 --> 00:46:19,119
kind of think about how to code a little

00:46:17,440 --> 00:46:20,480
bit in a functional way

00:46:19,119 --> 00:46:22,160
and we hope that you can take this and

00:46:20,480 --> 00:46:24,000
use it kind of in your you know your

00:46:22,160 --> 00:46:26,240
everyday toolbox for programming

00:46:24,000 --> 00:46:27,440
um so thanks a lot and if anybody has

00:46:26,240 --> 00:46:30,240
any other questions

00:46:27,440 --> 00:46:31,680
um you know please ask in the chat or

00:46:30,240 --> 00:46:33,200
request to share your screen

00:46:31,680 --> 00:46:34,880
and if you have time take a look at some

00:46:33,200 --> 00:46:36,720
of the examples in the notebooks that we

00:46:34,880 --> 00:46:38,640
didn't have time to go through today

00:46:36,720 --> 00:46:39,119
yeah kevin i haven't played with rust

00:46:38,640 --> 00:46:42,160
but

00:46:39,119 --> 00:46:45,359
it's it's also on my list

00:46:42,160 --> 00:46:47,680
and christian put some nice uh resources

00:46:45,359 --> 00:46:49,440
for functional programming in javascript

00:46:47,680 --> 00:46:50,720
in the chat so be sure to check those

00:46:49,440 --> 00:46:54,839
out

00:46:50,720 --> 00:46:56,160
and uh sorry for the the slight overage

00:46:54,839 --> 00:46:58,960
um

00:46:56,160 --> 00:47:00,880
yeah the uh the ipad at one point was

00:46:58,960 --> 00:47:02,960
ringing underneath the laptop

00:47:00,880 --> 00:47:06,560
and we're staring at the laptop yeah the

00:47:02,960 --> 00:47:08,880
stacks of technology cause issues

00:47:06,560 --> 00:47:10,800
well team shorts we really appreciate

00:47:08,880 --> 00:47:12,640
you working uh working this out with us

00:47:10,800 --> 00:47:14,079
again this is a brand new platform for

00:47:12,640 --> 00:47:15,599
everybody at cpask

00:47:14,079 --> 00:47:17,200
not only the presenters but also the

00:47:15,599 --> 00:47:19,040
staff so uh

00:47:17,200 --> 00:47:21,599
just getting used to obviously a virtual

00:47:19,040 --> 00:47:23,280
uh presentation is is new for many so

00:47:21,599 --> 00:47:25,520
certainly certainly appreciate your time

00:47:23,280 --> 00:47:27,920
today uh excellent talk

00:47:25,520 --> 00:47:29,760
lots of good information uh we

00:47:27,920 --> 00:47:31,760
definitely appreciate your time

00:47:29,760 --> 00:47:33,040
i know how how much time it takes to put

00:47:31,760 --> 00:47:33,680
together an excellent talk and you

00:47:33,040 --> 00:47:35,440
certainly

00:47:33,680 --> 00:47:37,040
exceeded expectations this morning so

00:47:35,440 --> 00:47:38,480
thank you again for your time and

00:47:37,040 --> 00:47:39,680
attention thank you to all of our

00:47:38,480 --> 00:47:41,760
participants

00:47:39,680 --> 00:47:42,960
and uh that is a wrap for this session

00:47:41,760 --> 00:47:44,800
take care all

00:47:42,960 --> 00:47:48,319
right and we'll hang here if there's any

00:47:44,800 --> 00:47:50,960
uh any questions too so

00:47:48,319 --> 00:47:52,000
great thanks again gang thanks charlie

00:47:50,960 --> 00:47:54,079
it does look like there's one

00:47:52,000 --> 00:47:55,040
so are list comprehensions faster

00:47:54,079 --> 00:47:58,559
compared to

00:47:55,040 --> 00:48:00,319
a for loop um

00:47:58,559 --> 00:48:01,839
i assume that's about python in

00:48:00,319 --> 00:48:03,520
particular and i

00:48:01,839 --> 00:48:04,880
i don't know the answer to that off the

00:48:03,520 --> 00:48:08,480
top of my head

00:48:04,880 --> 00:48:10,480
um one of the downsides to

00:48:08,480 --> 00:48:12,720
functional programming can be that the

00:48:10,480 --> 00:48:16,720
equivalent in functional programming

00:48:12,720 --> 00:48:16,720
not always but it can be slow

00:48:17,119 --> 00:48:21,760
well it has a lot to do oh yeah i was

00:48:20,079 --> 00:48:23,599
thinking town recursion but that's kind

00:48:21,760 --> 00:48:24,720
of a rabbit hole that we probably don't

00:48:23,599 --> 00:48:29,280
have time to go

00:48:24,720 --> 00:48:32,640
down um yeah it depends on how you write

00:48:29,280 --> 00:48:33,440
the code in a large sense what i will

00:48:32,640 --> 00:48:35,440
say is that you

00:48:33,440 --> 00:48:36,559
you can write highly performant

00:48:35,440 --> 00:48:39,920
functional code

00:48:36,559 --> 00:48:41,119
um and you can write non-performance uh

00:48:39,920 --> 00:48:43,359
functional code

00:48:41,119 --> 00:48:43,359
um

00:48:44,319 --> 00:48:48,000
yeah uh we'll also mention something

00:48:46,400 --> 00:48:49,200
that i kind of wanted to mention

00:48:48,000 --> 00:48:51,359
we've been talking about list

00:48:49,200 --> 00:48:55,200
comprehensions which are all um

00:48:51,359 --> 00:48:57,520
are kind of list map and so on

00:48:55,200 --> 00:48:58,880
these are all eager operations so

00:48:57,520 --> 00:48:59,599
another thing that's kind of cool that

00:48:58,880 --> 00:49:02,480
you can do

00:48:59,599 --> 00:49:04,880
in this functional style is you can use

00:49:02,480 --> 00:49:04,880
lazy

00:49:05,200 --> 00:49:10,319
basically lazy operations um

00:49:08,319 --> 00:49:11,920
and so will saying in python you could

00:49:10,319 --> 00:49:13,280
do that in generators

00:49:11,920 --> 00:49:14,800
and basically the idea is that if you

00:49:13,280 --> 00:49:16,079
don't need to consume all of the

00:49:14,800 --> 00:49:18,240
elements of the list

00:49:16,079 --> 00:49:19,680
you can basically kind of write an

00:49:18,240 --> 00:49:22,079
implementation of something that

00:49:19,680 --> 00:49:24,640
that can be relatively fast with very

00:49:22,079 --> 00:49:24,640
little effort

00:49:24,880 --> 00:49:32,000
definitely advanced topics yep

00:49:30,000 --> 00:49:33,040
um rust is also a really interesting

00:49:32,000 --> 00:49:36,400
language because

00:49:33,040 --> 00:49:38,160
um one of the sources of

00:49:36,400 --> 00:49:39,599
overhead and functional languages tends

00:49:38,160 --> 00:49:41,280
to be garbage collection

00:49:39,599 --> 00:49:42,960
um and rust is really interesting

00:49:41,280 --> 00:49:44,000
because it it doesn't have garbage

00:49:42,960 --> 00:49:46,400
collection

00:49:44,000 --> 00:49:47,119
um so yeah i don't have much experience

00:49:46,400 --> 00:49:48,480
with it but i

00:49:47,119 --> 00:49:50,960
i definitely do want to check that out

00:49:48,480 --> 00:49:54,400
more um one language i really

00:49:50,960 --> 00:49:57,680
love is scala

00:49:54,400 --> 00:49:59,119
it's very similar to ocamel and in many

00:49:57,680 --> 00:50:00,559
of the ways that we showed you

00:49:59,119 --> 00:50:02,559
but i think the built-in standard

00:50:00,559 --> 00:50:05,040
library is is really a lot better for

00:50:02,559 --> 00:50:07,920
kind of practical day-to-day programming

00:50:05,040 --> 00:50:09,520
um it also interfaces with java really

00:50:07,920 --> 00:50:11,520
cleanly so you have access to

00:50:09,520 --> 00:50:12,960
you know all the java libraries that are

00:50:11,520 --> 00:50:14,720
out there um

00:50:12,960 --> 00:50:16,240
which oh camel there are some libraries

00:50:14,720 --> 00:50:19,520
but you know

00:50:16,240 --> 00:50:19,520
not quite as many as java

00:50:22,720 --> 00:50:29,200
all right any other questions

00:50:27,200 --> 00:50:30,960
okay we'll send you off to your your

00:50:29,200 --> 00:50:34,079
next house

00:50:30,960 --> 00:50:35,920
um feel free to hi alexander did you

00:50:34,079 --> 00:50:38,319
make it through the whole thing

00:50:35,920 --> 00:50:40,319
that was just really excited to say

00:50:38,319 --> 00:50:42,400
thank you for the talk

00:50:40,319 --> 00:50:43,680
i jumped on and did the video thing

00:50:42,400 --> 00:50:45,599
because i thought there were no more

00:50:43,680 --> 00:50:48,079
questions but now there are

00:50:45,599 --> 00:50:49,440
we're just sadly sat here can you say

00:50:48,079 --> 00:50:52,640
goodbye

00:50:49,440 --> 00:50:52,640
no i'm not say

00:50:53,440 --> 00:50:58,000
why goodbye all these people watching

00:50:56,640 --> 00:50:59,920
guys

00:50:58,000 --> 00:51:01,200
they're all watching the great talk they

00:50:59,920 --> 00:51:02,559
did you sat through the whole thing

00:51:01,200 --> 00:51:09,200
wasn't it good

00:51:02,559 --> 00:51:11,119
yeah and not once i'd read stories

00:51:09,200 --> 00:51:13,119
uh yeah kevin so that's one of the first

00:51:11,119 --> 00:51:16,559
things you saw about rust

00:51:13,119 --> 00:51:16,559
the immutable yeah

00:51:16,960 --> 00:51:21,680
yeah it's a it's a really interesting uh

00:51:19,280 --> 00:51:23,119
concept

00:51:21,680 --> 00:51:26,079
it takes people a while to wrap their

00:51:23,119 --> 00:51:26,079
brains around that one

00:51:26,160 --> 00:51:29,680
yeah a lot of these things you know even

00:51:27,839 --> 00:51:30,960
once you kind of learn them and get used

00:51:29,680 --> 00:51:34,079
to them in the functional

00:51:30,960 --> 00:51:35,839
um context as you go and program in

00:51:34,079 --> 00:51:37,359
imperative languages you kind of take

00:51:35,839 --> 00:51:38,640
some of these ideas so

00:51:37,359 --> 00:51:41,200
you know if you look at some of the c

00:51:38,640 --> 00:51:44,480
plus plus code i write um

00:51:41,200 --> 00:51:45,680
you know i'll often generate things and

00:51:44,480 --> 00:51:47,839
you know basically treat things as

00:51:45,680 --> 00:51:49,599
immutable even though the language isn't

00:51:47,839 --> 00:51:50,960
enforcing that i'm just

00:51:49,599 --> 00:51:52,880
that's kind of how i think about the

00:51:50,960 --> 00:51:55,920
problem now um so it's a good

00:51:52,880 --> 00:51:57,420
idea to say the same thing as well that

00:51:55,920 --> 00:52:00,439
that's carried over

00:51:57,420 --> 00:52:00,439
[Music]

00:52:00,480 --> 00:52:04,079
yeah i um when i'm teaching it i really

00:52:03,280 --> 00:52:05,920
try to emphasize

00:52:04,079 --> 00:52:09,440
these are not variables these are not

00:52:05,920 --> 00:52:13,359
your variables that you're used to from

00:52:09,440 --> 00:52:13,359
yeah um i think it helps a little bit

00:52:13,440 --> 00:52:19,839
so i'm glad you like that my students

00:52:15,680 --> 00:52:19,839
just by the baffling

00:52:27,119 --> 00:52:33,839
exactly yeah these are not your father's

00:52:30,839 --> 00:52:33,839
variables

00:52:34,720 --> 00:52:41,119
all right we'll send you guys off

00:52:38,559 --> 00:52:41,119
thank you

00:52:44,559 --> 00:52:54,559

YouTube URL: https://www.youtube.com/watch?v=cylHRe7WApQ


