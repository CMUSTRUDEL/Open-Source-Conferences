Title: Reuven M. Lerner - Generators, coroutines, and nanoservices || PyCon Africa 2020
Publication date: 2020-08-29
Playlist: PyCon Africa 2020
Description: 
	Generator functions have been a part of Python for many years already, and are a well known technique for creating iterators. But generators have a few lesser-known aspects, including their "send" method and the "yield from" syntax. Many Python developers shy away from using them, unsure of what they would do, or how they would be useful â€” seeing coroutines as a solution looking for a problem.

In this talk, I'll tell you why coroutines can be useful, and how thinking about them as in-process "nanoservices" puts us in the right frame of mind to determine when they would and wouldn't be appropriate.  Among the topics we'll explore are:
- Generator function basics
- next vs. send
- How to build a coroutine
- Thinking of coroutines as nanoservices
- Sub-coroutines
- The need for `yield from`
- Using `yield from`
- Ideas for general usage
Captions: 
	00:00:14,880 --> 00:00:18,000
hi there everyone welcome welcome to my

00:00:17,119 --> 00:00:19,920
talk

00:00:18,000 --> 00:00:21,039
uh my name is reuben lerner and this is

00:00:19,920 --> 00:00:25,119
uh my talk is called

00:00:21,039 --> 00:00:26,800
generators co-routines and nano services

00:00:25,119 --> 00:00:28,480
i'm really really happy to be here a few

00:00:26,800 --> 00:00:32,239
words about myself so

00:00:28,480 --> 00:00:34,000
i have what i think is a super fun job i

00:00:32,239 --> 00:00:35,680
i teach python i go around the world

00:00:34,000 --> 00:00:38,160
well in theory i go around the world

00:00:35,680 --> 00:00:39,920
teaching python companies all over last

00:00:38,160 --> 00:00:43,040
year before a pandemic

00:00:39,920 --> 00:00:44,640
i was in the u.s and the uk and europe

00:00:43,040 --> 00:00:46,879
and israel where i live and

00:00:44,640 --> 00:00:47,840
india and china teaching different

00:00:46,879 --> 00:00:50,079
corporate training

00:00:47,840 --> 00:00:51,440
courses about python i also have a bunch

00:00:50,079 --> 00:00:53,280
of online courses

00:00:51,440 --> 00:00:54,480
i teach a set of courses called weekly

00:00:53,280 --> 00:00:56,960
python exercise

00:00:54,480 --> 00:00:58,160
i have a book printed book called the

00:00:56,960 --> 00:00:59,440
python workout which has

00:00:58,160 --> 00:01:00,719
someone in the chat just said they'd

00:00:59,440 --> 00:01:01,440
gotten it so thank you very much i

00:01:00,719 --> 00:01:02,960
appreciate it

00:01:01,440 --> 00:01:06,000
uh which helps you to level up your

00:01:02,960 --> 00:01:07,840
python with a whole bunch of exercises

00:01:06,000 --> 00:01:09,680
and i have a free week new free weekly

00:01:07,840 --> 00:01:11,520
newsletter called better developers

00:01:09,680 --> 00:01:13,920
uh which is read by currently about 80

00:01:11,520 --> 00:01:16,560
or 19 000 people each week

00:01:13,920 --> 00:01:17,360
so the most important thing to start off

00:01:16,560 --> 00:01:20,479
with

00:01:17,360 --> 00:01:22,000
this is not a talk about async io so

00:01:20,479 --> 00:01:24,159
from the title of the talk

00:01:22,000 --> 00:01:26,400
which mentions co routines you might

00:01:24,159 --> 00:01:28,240
think that this has to do with async i o

00:01:26,400 --> 00:01:29,680
because nowadays in python

00:01:28,240 --> 00:01:32,159
people when they talk about core

00:01:29,680 --> 00:01:34,079
routines they mean async io

00:01:32,159 --> 00:01:36,159
this is not one of those this is

00:01:34,079 --> 00:01:37,759
harkening back to an earlier period

00:01:36,159 --> 00:01:39,200
when we had co routines that were

00:01:37,759 --> 00:01:40,479
working with generators

00:01:39,200 --> 00:01:42,560
and on the one hand you might think of

00:01:40,479 --> 00:01:44,799
it as something a little old ancient

00:01:42,560 --> 00:01:46,159
weird at the same time this talk is

00:01:44,799 --> 00:01:48,240
meant to both explain

00:01:46,159 --> 00:01:49,840
how these technologies work how some

00:01:48,240 --> 00:01:50,880
keywords work in python

00:01:49,840 --> 00:01:53,040
that you might not have understood

00:01:50,880 --> 00:01:55,040
before and to start generating some

00:01:53,040 --> 00:01:56,079
ideas about how we might be able to use

00:01:55,040 --> 00:01:57,759
these technologies

00:01:56,079 --> 00:01:59,280
better and at the end i'll wrap up with

00:01:57,759 --> 00:02:01,439
a little bit of talk about async io and

00:01:59,280 --> 00:02:03,520
how it fits into all of this

00:02:01,439 --> 00:02:05,680
so let's start off with the dumbest

00:02:03,520 --> 00:02:08,000
function in the entire world

00:02:05,680 --> 00:02:09,200
which is def my funk as you can see

00:02:08,000 --> 00:02:11,760
return one return

00:02:09,200 --> 00:02:12,319
two return three so if i run this

00:02:11,760 --> 00:02:15,440
function

00:02:12,319 --> 00:02:17,280
and i print its return value so

00:02:15,440 --> 00:02:18,400
now what's gonna be printed out well

00:02:17,280 --> 00:02:19,599
you're not gonna be surprised to

00:02:18,400 --> 00:02:21,200
discover that it prints

00:02:19,599 --> 00:02:22,959
one right that i told you it was the

00:02:21,200 --> 00:02:24,560
dumbest function in the world well

00:02:22,959 --> 00:02:26,560
it makes sense right because return

00:02:24,560 --> 00:02:27,360
means stop the function and return a

00:02:26,560 --> 00:02:29,920
value

00:02:27,360 --> 00:02:30,959
and if you run this function through say

00:02:29,920 --> 00:02:33,040
pylint

00:02:30,959 --> 00:02:34,640
it'll warn us that the final lines are

00:02:33,040 --> 00:02:36,400
unreachable it will actually tell us

00:02:34,640 --> 00:02:38,480
how you can't get to return to any

00:02:36,400 --> 00:02:41,040
return three which is of course true

00:02:38,480 --> 00:02:42,800
and even python's byte compiler ignores

00:02:41,040 --> 00:02:45,440
the final two lines

00:02:42,800 --> 00:02:48,160
people often have this sense that python

00:02:45,440 --> 00:02:50,560
is an interpreted language but it's not

00:02:48,160 --> 00:02:52,640
actually it's a compiled language before

00:02:50,560 --> 00:02:54,160
any python code can be executed

00:02:52,640 --> 00:02:56,080
it first needs to be turned into byte

00:02:54,160 --> 00:02:57,360
codes and when you write a function when

00:02:56,080 --> 00:02:59,040
you define a function

00:02:57,360 --> 00:03:00,640
that function is compiled in the byte

00:02:59,040 --> 00:03:02,560
codes which are then executed

00:03:00,640 --> 00:03:04,400
we can take a look at those byte codes

00:03:02,560 --> 00:03:06,560
here if we use the disk

00:03:04,400 --> 00:03:07,519
module that comes with python for

00:03:06,560 --> 00:03:10,159
disassembly

00:03:07,519 --> 00:03:11,200
so if i run the disk dot disk function

00:03:10,159 --> 00:03:13,120
on my func

00:03:11,200 --> 00:03:14,879
what do i get well it's going to load up

00:03:13,120 --> 00:03:15,680
the constant 1 and it's going to return

00:03:14,879 --> 00:03:18,159
that value

00:03:15,680 --> 00:03:19,360
this is what return 1 is turned into

00:03:18,159 --> 00:03:22,400
what about return two

00:03:19,360 --> 00:03:24,480
what about return three gone ignored so

00:03:22,400 --> 00:03:26,400
even the python compiler

00:03:24,480 --> 00:03:28,640
which is sort of known for being kind of

00:03:26,400 --> 00:03:30,319
dumb and for just taking whatever code

00:03:28,640 --> 00:03:31,840
we've written and turning into bytecodes

00:03:30,319 --> 00:03:33,200
it's smart enough to realize we cannot

00:03:31,840 --> 00:03:34,560
get to return two we cannot get to

00:03:33,200 --> 00:03:36,480
return three so we're just going to

00:03:34,560 --> 00:03:37,440
ignore those all together

00:03:36,480 --> 00:03:39,040
all right now that we've looked at a

00:03:37,440 --> 00:03:40,319
really dumb function let's look at a

00:03:39,040 --> 00:03:43,519
slightly different function

00:03:40,319 --> 00:03:45,120
what about this one def my gen yield one

00:03:43,519 --> 00:03:46,640
yield two and yield three i'm gonna do

00:03:45,120 --> 00:03:47,360
the same thing as i did with my funk

00:03:46,640 --> 00:03:48,640
before

00:03:47,360 --> 00:03:50,720
i'm going to run it and i'm going to

00:03:48,640 --> 00:03:52,319
print the result so what happens when we

00:03:50,720 --> 00:03:54,000
run this code

00:03:52,319 --> 00:03:55,840
well we actually get something totally

00:03:54,000 --> 00:03:56,959
different we have this thing generator

00:03:55,840 --> 00:04:00,080
object my gen

00:03:56,959 --> 00:04:00,959
at all sorts of nonsense which is not

00:04:00,080 --> 00:04:03,040
actually nonsense

00:04:00,959 --> 00:04:04,720
it's actually the address in memory

00:04:03,040 --> 00:04:05,200
which happens to be the same thing as

00:04:04,720 --> 00:04:06,640
the id

00:04:05,200 --> 00:04:09,439
of the object but we don't need to go

00:04:06,640 --> 00:04:11,360
there right now what's going on why did

00:04:09,439 --> 00:04:12,480
we get this generator object back rather

00:04:11,360 --> 00:04:15,040
than just one

00:04:12,480 --> 00:04:17,040
well the difference is very simply yield

00:04:15,040 --> 00:04:18,880
yield is a keyword in python yield is

00:04:17,040 --> 00:04:19,840
something that python notices and does

00:04:18,880 --> 00:04:22,639
something with

00:04:19,840 --> 00:04:25,280
and so when we define our function and

00:04:22,639 --> 00:04:27,600
python is compiling it into byte codes

00:04:25,280 --> 00:04:29,040
it notices yield it says wait i'm going

00:04:27,600 --> 00:04:29,759
to do something totally different with

00:04:29,040 --> 00:04:32,560
this

00:04:29,759 --> 00:04:34,240
this is not a regular function this is a

00:04:32,560 --> 00:04:37,199
generator function

00:04:34,240 --> 00:04:39,280
and so that means that when we run it we

00:04:37,199 --> 00:04:40,800
are not going to be getting back a value

00:04:39,280 --> 00:04:42,080
right away or at least not a value from

00:04:40,800 --> 00:04:44,080
the function body

00:04:42,080 --> 00:04:45,440
rather we are going to get a generator

00:04:44,080 --> 00:04:46,639
object back

00:04:45,440 --> 00:04:47,919
and we can see that we're going to talk

00:04:46,639 --> 00:04:49,600
about what generator objects are in just

00:04:47,919 --> 00:04:51,040
a moment but we can see this with

00:04:49,600 --> 00:04:53,360
desktop show code

00:04:51,040 --> 00:04:54,639
so this is also from the disk module the

00:04:53,360 --> 00:04:56,800
disassembly module

00:04:54,639 --> 00:04:58,080
but show code is a really great function

00:04:56,800 --> 00:04:59,919
that summarizes

00:04:58,080 --> 00:05:01,919
all the hints that python leaves for

00:04:59,919 --> 00:05:03,680
itself in the function object

00:05:01,919 --> 00:05:05,199
so we get the function name the file was

00:05:03,680 --> 00:05:06,639
defined and all sorts of other things

00:05:05,199 --> 00:05:08,479
and there are a whole bunch of flags so

00:05:06,639 --> 00:05:11,600
those are actually binary flags

00:05:08,479 --> 00:05:12,639
that are set in co flags and you can see

00:05:11,600 --> 00:05:15,840
here that it's marked as

00:05:12,639 --> 00:05:17,680
generator so what happens when we define

00:05:15,840 --> 00:05:19,039
our function python notices the yield

00:05:17,680 --> 00:05:19,759
because there's a yield that's tagged as

00:05:19,039 --> 00:05:21,680
a generator

00:05:19,759 --> 00:05:24,479
and because it's a generator when we run

00:05:21,680 --> 00:05:26,160
it we get back the generator object

00:05:24,479 --> 00:05:28,240
and by the way if we try to disassemble

00:05:26,160 --> 00:05:30,639
it this does this as we did before

00:05:28,240 --> 00:05:31,600
to my funk it's a whole different kettle

00:05:30,639 --> 00:05:33,520
of fish

00:05:31,600 --> 00:05:35,039
now we're loading the constant one and

00:05:33,520 --> 00:05:36,560
yielding it and then we're loading

00:05:35,039 --> 00:05:38,160
constant two and yielding it then we're

00:05:36,560 --> 00:05:39,360
loading the constant three the nearly

00:05:38,160 --> 00:05:41,280
and then we are

00:05:39,360 --> 00:05:42,800
returning none and returning none from a

00:05:41,280 --> 00:05:44,800
generator function actually

00:05:42,800 --> 00:05:46,160
raises a stop iteration exception and

00:05:44,800 --> 00:05:47,039
we'll talk about that in a moment as

00:05:46,160 --> 00:05:49,440
well

00:05:47,039 --> 00:05:51,520
notice here by the way that yield is

00:05:49,440 --> 00:05:52,000
baked into python it's not just sort of

00:05:51,520 --> 00:05:53,039
a random

00:05:52,000 --> 00:05:55,360
keyword or something it's not a

00:05:53,039 --> 00:05:57,199
variation on return it's so big to the

00:05:55,360 --> 00:05:57,520
python that it's one of the byte codes

00:05:57,199 --> 00:05:59,120
that

00:05:57,520 --> 00:06:00,880
the lowest level of the language it

00:05:59,120 --> 00:06:02,479
really understands

00:06:00,880 --> 00:06:04,080
so that's very nice that we're getting

00:06:02,479 --> 00:06:04,960
back this generator but what is a

00:06:04,080 --> 00:06:06,639
generator

00:06:04,960 --> 00:06:08,160
well implements python's iterator

00:06:06,639 --> 00:06:09,120
protocol and this protocol is

00:06:08,160 --> 00:06:11,600
deliberately

00:06:09,120 --> 00:06:12,400
really simple basically you say to an

00:06:11,600 --> 00:06:14,720
object

00:06:12,400 --> 00:06:16,240
who is your iterator right which is the

00:06:14,720 --> 00:06:18,479
object that knows how to iterate for you

00:06:16,240 --> 00:06:19,919
in the case of a generator it is its own

00:06:18,479 --> 00:06:20,720
iterator we'll see this in a moment as

00:06:19,919 --> 00:06:22,720
well

00:06:20,720 --> 00:06:24,639
then you go to that object you say what

00:06:22,720 --> 00:06:25,520
is your next value and use the next

00:06:24,639 --> 00:06:27,440
function for that

00:06:25,520 --> 00:06:29,600
give me your next one your next one your

00:06:27,440 --> 00:06:30,240
next one and when you finally get to the

00:06:29,600 --> 00:06:32,400
end

00:06:30,240 --> 00:06:33,360
of the iterations then an object should

00:06:32,400 --> 00:06:35,759
raise this

00:06:33,360 --> 00:06:37,600
exception stop iteration by the way if

00:06:35,759 --> 00:06:38,880
you are of the opinion that exceptions

00:06:37,600 --> 00:06:40,639
are only errors

00:06:38,880 --> 00:06:42,639
that is not true and stop iteration is a

00:06:40,639 --> 00:06:45,039
perfect example of how python

00:06:42,639 --> 00:06:46,720
uses exceptions for signaling for

00:06:45,039 --> 00:06:47,600
indicating hey there's an unusual thing

00:06:46,720 --> 00:06:50,479
going on here

00:06:47,600 --> 00:06:52,000
not necessarily for errors so let's go

00:06:50,479 --> 00:06:53,520
over how a for loop works

00:06:52,000 --> 00:06:55,199
well we have a for loop right everyone

00:06:53,520 --> 00:06:57,039
who's ever programmed python for either

00:06:55,199 --> 00:07:00,319
a day or two has done one of these

00:06:57,039 --> 00:07:02,880
and so how does it work well

00:07:00,319 --> 00:07:03,840
the for loop turns to abcd turns that

00:07:02,880 --> 00:07:05,919
object there and says hey

00:07:03,840 --> 00:07:07,599
is this object iterable the answer is

00:07:05,919 --> 00:07:09,120
yes so because the answer is yes we go

00:07:07,599 --> 00:07:11,680
to the next stage it says okay

00:07:09,120 --> 00:07:12,880
ask that object for its next thing it's

00:07:11,680 --> 00:07:14,319
the next thing it's next thing

00:07:12,880 --> 00:07:16,160
each time we get the next thing we

00:07:14,319 --> 00:07:17,919
assign that thing to one item

00:07:16,160 --> 00:07:20,000
and then the body of the loop runs we go

00:07:17,919 --> 00:07:22,880
back for more next thing by the

00:07:20,000 --> 00:07:24,080
loop runs and once more when the object

00:07:22,880 --> 00:07:25,280
wants to indicate that it's out of

00:07:24,080 --> 00:07:26,960
object it raises

00:07:25,280 --> 00:07:28,319
stopped iteration no more elements

00:07:26,960 --> 00:07:29,599
nothing more to return

00:07:28,319 --> 00:07:31,919
and so in this case we're going to get

00:07:29,599 --> 00:07:32,960
of course a b c d because we get a then

00:07:31,919 --> 00:07:35,360
we get b then we get c

00:07:32,960 --> 00:07:36,479
with the lead of d this by the way is y

00:07:35,360 --> 00:07:38,479
in python

00:07:36,479 --> 00:07:39,599
we don't have indexes we don't care

00:07:38,479 --> 00:07:40,960
about indexes

00:07:39,599 --> 00:07:42,160
right because we're just triggering the

00:07:40,960 --> 00:07:43,599
objects and give me the next one the

00:07:42,160 --> 00:07:44,960
next one the next one

00:07:43,599 --> 00:07:47,520
well what about with our generator

00:07:44,960 --> 00:07:48,080
what's happening here exactly the same

00:07:47,520 --> 00:07:50,240
thing

00:07:48,080 --> 00:07:51,919
notice i'm running my gen so i'm saying

00:07:50,240 --> 00:07:53,680
is it iterable so the for loop is

00:07:51,919 --> 00:07:55,280
turning to the result of my gem

00:07:53,680 --> 00:07:57,039
to our generator object saying is it

00:07:55,280 --> 00:07:58,720
integral the answer is yes so it says

00:07:57,039 --> 00:07:59,759
okay give me your next thing your next

00:07:58,720 --> 00:08:01,759
thing your next thing

00:07:59,759 --> 00:08:02,800
and each time it will give us something

00:08:01,759 --> 00:08:04,240
new

00:08:02,800 --> 00:08:05,599
until it gets to the end at which point

00:08:04,240 --> 00:08:07,199
it will raise stop iteration raise the

00:08:05,599 --> 00:08:07,759
stop duration the four loop realizes at

00:08:07,199 --> 00:08:10,400
the end

00:08:07,759 --> 00:08:11,120
and the loop end of story and we get one

00:08:10,400 --> 00:08:14,080
two

00:08:11,120 --> 00:08:15,120
3 and then that's the end of it and by

00:08:14,080 --> 00:08:17,120
the way if i now say g

00:08:15,120 --> 00:08:19,199
equals my gen if i assign the generator

00:08:17,120 --> 00:08:20,960
object to a variable

00:08:19,199 --> 00:08:22,639
well we'll see that i can get g and i

00:08:20,960 --> 00:08:24,800
can get inner of g interval of g

00:08:22,639 --> 00:08:26,479
is our manual way probably never going

00:08:24,800 --> 00:08:27,440
to do this manually but you can turn to

00:08:26,479 --> 00:08:29,599
an object and say hey

00:08:27,440 --> 00:08:30,720
who is your iterator and you'll see that

00:08:29,599 --> 00:08:32,959
the two

00:08:30,720 --> 00:08:33,839
ids the two addresses in memory that we

00:08:32,959 --> 00:08:36,640
get back here

00:08:33,839 --> 00:08:38,240
are actually identical which means that

00:08:36,640 --> 00:08:40,159
the generator is its own

00:08:38,240 --> 00:08:41,519
iterator so when you say to a generator

00:08:40,159 --> 00:08:43,519
object hey who's your iterator it says

00:08:41,519 --> 00:08:45,040
oh i'm my own iterator

00:08:43,519 --> 00:08:46,800
but what about next well if here's my

00:08:45,040 --> 00:08:49,279
generator on the right just to sort of

00:08:46,800 --> 00:08:51,760
keep track of it so when i say next g

00:08:49,279 --> 00:08:54,000
what next does is it runs up to and

00:08:51,760 --> 00:08:55,360
including the next yield statement so

00:08:54,000 --> 00:08:57,040
next to g says run

00:08:55,360 --> 00:09:00,480
through the next yield statement it says

00:08:57,040 --> 00:09:02,880
yield one and then it goes to sleep

00:09:00,480 --> 00:09:04,560
basically the function is still around

00:09:02,880 --> 00:09:07,120
the function that the stack

00:09:04,560 --> 00:09:08,720
frame of the function is still around

00:09:07,120 --> 00:09:10,240
the function doesn't return the function

00:09:08,720 --> 00:09:11,760
doesn't exit it sticks around and it

00:09:10,240 --> 00:09:13,360
knows where it went to sleep

00:09:11,760 --> 00:09:14,880
so then when we say next g it picks up

00:09:13,360 --> 00:09:16,880
from where it left off

00:09:14,880 --> 00:09:18,480
and then runs through the next yield and

00:09:16,880 --> 00:09:19,120
returns and that picks up from where it

00:09:18,480 --> 00:09:21,040
left off

00:09:19,120 --> 00:09:22,720
runs field and then finally at the end

00:09:21,040 --> 00:09:24,160
we get stop iteration indicating we are

00:09:22,720 --> 00:09:25,839
at the end

00:09:24,160 --> 00:09:27,680
very important to understand that next

00:09:25,839 --> 00:09:28,800
is always going to say run through the

00:09:27,680 --> 00:09:30,800
next yield statement

00:09:28,800 --> 00:09:32,240
and this can be a ton of code or this

00:09:30,800 --> 00:09:34,000
could be a tiny amount of code

00:09:32,240 --> 00:09:35,360
and you can have it in a loop so that

00:09:34,000 --> 00:09:36,959
with each loop iteration

00:09:35,360 --> 00:09:38,800
you are then yielding and yielding and

00:09:36,959 --> 00:09:41,680
yielding each time

00:09:38,800 --> 00:09:42,800
we hit yield we get a value back and the

00:09:41,680 --> 00:09:45,839
function goes to sleep

00:09:42,800 --> 00:09:47,920
until we restart it what's really nice

00:09:45,839 --> 00:09:49,360
is that we're dealing with a function a

00:09:47,920 --> 00:09:50,399
function that works just like all other

00:09:49,360 --> 00:09:52,000
python functions

00:09:50,399 --> 00:09:53,519
and so the function state meaning it's

00:09:52,000 --> 00:09:55,279
local variables remain

00:09:53,519 --> 00:09:56,880
across each of these calls so you can

00:09:55,279 --> 00:09:57,680
set something up at the start of your

00:09:56,880 --> 00:09:58,959
generator

00:09:57,680 --> 00:10:00,320
and keep referring to it and that's

00:09:58,959 --> 00:10:01,920
going to be key what we're going to see

00:10:00,320 --> 00:10:04,160
in a little bit

00:10:01,920 --> 00:10:05,519
so here's like the classic example of

00:10:04,160 --> 00:10:07,200
the generator in python this is the

00:10:05,519 --> 00:10:08,399
fibonacci sequence

00:10:07,200 --> 00:10:10,160
so we're going to start off with our

00:10:08,399 --> 00:10:12,000
generator by defining first and second

00:10:10,160 --> 00:10:13,760
two local variables zero and one

00:10:12,000 --> 00:10:15,760
and then we're going to say while true

00:10:13,760 --> 00:10:19,040
notice this is going to give us an

00:10:15,760 --> 00:10:21,279
infinitely long series but we can

00:10:19,040 --> 00:10:22,000
express this infinitely long series as a

00:10:21,279 --> 00:10:23,040
generator

00:10:22,000 --> 00:10:24,800
because we know that we're going to be

00:10:23,040 --> 00:10:26,000
getting the values one at a time we

00:10:24,800 --> 00:10:26,720
don't have to worry about filling all of

00:10:26,000 --> 00:10:28,959
our memory

00:10:26,720 --> 00:10:30,240
with infinite amounts of data so what

00:10:28,959 --> 00:10:32,399
happens in the loop we're going to yield

00:10:30,240 --> 00:10:33,760
first we need zero and then we're gonna

00:10:32,399 --> 00:10:34,399
do a little switcheroo we're gonna say

00:10:33,760 --> 00:10:36,079
well take

00:10:34,399 --> 00:10:38,000
second and make it first take first

00:10:36,079 --> 00:10:40,160
person make it second meaning

00:10:38,000 --> 00:10:42,079
move everything to the left and each new

00:10:40,160 --> 00:10:43,120
value will be the sum of the previous

00:10:42,079 --> 00:10:45,040
two values

00:10:43,120 --> 00:10:46,240
so if i say g equals fifth and again i'm

00:10:45,040 --> 00:10:47,279
going to do this manually but we're

00:10:46,240 --> 00:10:48,640
going to be doing a lot of things

00:10:47,279 --> 00:10:50,399
manually in this talk

00:10:48,640 --> 00:10:51,760
then i say next to g i get zero next to

00:10:50,399 --> 00:10:54,959
g i get one next of j get

00:10:51,760 --> 00:10:56,880
one and on and on here's what you never

00:10:54,959 --> 00:10:58,399
want to do

00:10:56,880 --> 00:11:00,399
list of fib because what's going to

00:10:58,399 --> 00:11:01,839
happen list says oh i'm going to create

00:11:00,399 --> 00:11:03,760
a list from all the things that it

00:11:01,839 --> 00:11:05,920
returns from iterating over fib

00:11:03,760 --> 00:11:07,440
so it says you'll give your next give

00:11:05,920 --> 00:11:09,040
your next give your next and it will

00:11:07,440 --> 00:11:10,160
never ready to stop iteration it will

00:11:09,040 --> 00:11:11,279
just use up all the memory in your

00:11:10,160 --> 00:11:13,680
computer

00:11:11,279 --> 00:11:15,440
so maybe don't do this on your own

00:11:13,680 --> 00:11:16,800
computer but if you have a colleague or

00:11:15,440 --> 00:11:18,800
friend or someone you don't care if

00:11:16,800 --> 00:11:20,560
they're not your friend anymore perfect

00:11:18,800 --> 00:11:22,160
perfect place to experiment

00:11:20,560 --> 00:11:23,680
what about another example so here's

00:11:22,160 --> 00:11:24,160
something i like to play with called

00:11:23,680 --> 00:11:26,880
read

00:11:24,160 --> 00:11:27,680
m normally if i iterate over a file i'm

00:11:26,880 --> 00:11:30,079
going to get the

00:11:27,680 --> 00:11:31,760
elements or the lines one at a time each

00:11:30,079 --> 00:11:32,959
time i iterate over the file

00:11:31,760 --> 00:11:34,560
i'm going to get the next line and the

00:11:32,959 --> 00:11:36,560
next line the next line up to including

00:11:34,560 --> 00:11:38,240
the next new line

00:11:36,560 --> 00:11:39,519
here though i'm saying well maybe i

00:11:38,240 --> 00:11:40,320
don't want to get one line at a time

00:11:39,519 --> 00:11:42,000
maybe i want to get

00:11:40,320 --> 00:11:43,920
n lines at a time maybe i'm dealing with

00:11:42,000 --> 00:11:44,880
a file that is configured a certain way

00:11:43,920 --> 00:11:46,320
that would be really nice you have

00:11:44,880 --> 00:11:47,120
chunks of like three lines or something

00:11:46,320 --> 00:11:49,120
at a time

00:11:47,120 --> 00:11:50,800
so what am i going to do here i'm going

00:11:49,120 --> 00:11:52,160
to define my generator such that i open

00:11:50,800 --> 00:11:53,680
the file and then once again i'm going

00:11:52,160 --> 00:11:55,200
to do wild true

00:11:53,680 --> 00:11:56,800
but now what am i going to do with each

00:11:55,200 --> 00:12:00,160
iteration i'm going to read n

00:11:56,800 --> 00:12:01,760
lines i'm going to run f.readline which

00:12:00,160 --> 00:12:03,120
always returns a string if i'm at the

00:12:01,760 --> 00:12:03,760
end of the file it returns an empty

00:12:03,120 --> 00:12:05,680
string

00:12:03,760 --> 00:12:07,200
i'm going to run it n times so i'm going

00:12:05,680 --> 00:12:07,760
to get n strings i'm going to join them

00:12:07,200 --> 00:12:09,279
together

00:12:07,760 --> 00:12:10,959
and i'm going to say hey if output

00:12:09,279 --> 00:12:13,920
meaning if my string is not

00:12:10,959 --> 00:12:14,720
empty then i'll yield it but if it is

00:12:13,920 --> 00:12:16,320
empty

00:12:14,720 --> 00:12:17,680
if the output is empty then i'm going to

00:12:16,320 --> 00:12:18,240
break what happens when i break out of

00:12:17,680 --> 00:12:19,600
the loop

00:12:18,240 --> 00:12:21,600
the function ends what happens when the

00:12:19,600 --> 00:12:22,800
function ends it raises stop iteration

00:12:21,600 --> 00:12:24,160
with exit

00:12:22,800 --> 00:12:26,160
so this actually works really well and

00:12:24,160 --> 00:12:28,560
it all depends on yield returning a new

00:12:26,160 --> 00:12:31,519
value with each iteration

00:12:28,560 --> 00:12:32,720
next example next vowel so what i can do

00:12:31,519 --> 00:12:35,600
is i can run this dec

00:12:32,720 --> 00:12:36,639
as i've defined get vowels get valve the

00:12:35,600 --> 00:12:38,639
renault file name

00:12:36,639 --> 00:12:40,079
i'm going to open the file and i'm going

00:12:38,639 --> 00:12:41,440
to read through each line because that's

00:12:40,079 --> 00:12:42,800
how we iterate through files

00:12:41,440 --> 00:12:44,880
and i'm going to iterate over each

00:12:42,800 --> 00:12:46,800
character in the line one at a time

00:12:44,880 --> 00:12:48,880
because one line is a string and then i

00:12:46,800 --> 00:12:51,279
can say if the current character

00:12:48,880 --> 00:12:52,959
lowercase is a iou a vowel that healed

00:12:51,279 --> 00:12:53,760
it what happens if it's not then we go

00:12:52,959 --> 00:12:55,360
the next one

00:12:53,760 --> 00:12:56,880
next character what happens if we're out

00:12:55,360 --> 00:12:58,480
of characters on this line then we go to

00:12:56,880 --> 00:13:00,399
the next line what happens if we're out

00:12:58,480 --> 00:13:02,639
of line stop iteration

00:13:00,399 --> 00:13:04,240
and this is all once again because yield

00:13:02,639 --> 00:13:05,760
will yield one thing and if we don't

00:13:04,240 --> 00:13:06,399
yield then it'll keep running until it

00:13:05,760 --> 00:13:09,040
hits

00:13:06,399 --> 00:13:10,000
the next yield so when should we use

00:13:09,040 --> 00:13:12,320
generators

00:13:10,000 --> 00:13:13,839
so we have if we have a potentially

00:13:12,320 --> 00:13:15,120
large or infinite set of values to

00:13:13,839 --> 00:13:16,079
return right we don't want to use up

00:13:15,120 --> 00:13:17,920
tons of memory

00:13:16,079 --> 00:13:19,680
with all of our data rather we can sort

00:13:17,920 --> 00:13:21,279
of get it one chunk at a time

00:13:19,680 --> 00:13:23,680
often generators are used because it's

00:13:21,279 --> 00:13:26,160
easier to express an idea as a function

00:13:23,680 --> 00:13:27,360
and also maybe we have to set things up

00:13:26,160 --> 00:13:30,000
like a network connection

00:13:27,360 --> 00:13:31,360
or open a file and then we want to just

00:13:30,000 --> 00:13:33,360
keep that state going

00:13:31,360 --> 00:13:35,200
in our generator and it'll stay across

00:13:33,360 --> 00:13:37,200
our different iterations

00:13:35,200 --> 00:13:38,480
okay well what about this this is where

00:13:37,200 --> 00:13:41,040
things start to get a little weird

00:13:38,480 --> 00:13:41,600
and wacky but also interesting definite

00:13:41,040 --> 00:13:44,639
gen

00:13:41,600 --> 00:13:48,240
x equals none while true x

00:13:44,639 --> 00:13:48,880
equals yield x well that's kind of weird

00:13:48,240 --> 00:13:50,720
right

00:13:48,880 --> 00:13:52,399
because before we were saying yield is a

00:13:50,720 --> 00:13:53,279
statement it returns something to us

00:13:52,399 --> 00:13:55,920
then we'll go back

00:13:53,279 --> 00:13:57,519
but now yield is an expression it's

00:13:55,920 --> 00:14:00,720
something that has a value

00:13:57,519 --> 00:14:02,240
that is returned to us what the heck is

00:14:00,720 --> 00:14:05,279
going on

00:14:02,240 --> 00:14:08,160
so when we use yield as an expression

00:14:05,279 --> 00:14:09,040
meaning on the right side of assignment

00:14:08,160 --> 00:14:10,560
doesn't have to be there but it's

00:14:09,040 --> 00:14:12,320
typically going to be there all the

00:14:10,560 --> 00:14:14,480
rules for generators still apply

00:14:12,320 --> 00:14:16,399
each call to next runs to the next yield

00:14:14,480 --> 00:14:18,639
as before after yielding goes to sleep

00:14:16,399 --> 00:14:19,839
but now yield can be used for two-way

00:14:18,639 --> 00:14:22,480
communication

00:14:19,839 --> 00:14:24,000
now we can inject a value into our

00:14:22,480 --> 00:14:26,880
function

00:14:24,000 --> 00:14:27,920
by every time it yields to us it then

00:14:26,880 --> 00:14:30,560
waits to get something

00:14:27,920 --> 00:14:32,320
from us we can send it a message and

00:14:30,560 --> 00:14:34,480
that received value

00:14:32,320 --> 00:14:36,000
replaces yield in the expression and

00:14:34,480 --> 00:14:37,519
then is assigned to whatever was on the

00:14:36,000 --> 00:14:39,120
left-hand side

00:14:37,519 --> 00:14:41,440
yeah but how are we going to send a

00:14:39,120 --> 00:14:42,880
message into our generator

00:14:41,440 --> 00:14:44,959
oh we're going to use the send method of

00:14:42,880 --> 00:14:45,760
course right we can advance our

00:14:44,959 --> 00:14:48,399
generator

00:14:45,760 --> 00:14:50,160
next next next next next but we can send

00:14:48,399 --> 00:14:51,920
a value if we use the send

00:14:50,160 --> 00:14:53,360
method and notice that's a method rather

00:14:51,920 --> 00:14:54,880
than a function and that is an

00:14:53,360 --> 00:14:57,440
inconsistency i agree

00:14:54,880 --> 00:14:58,720
you can also say just g dot send of none

00:14:57,440 --> 00:14:59,839
and that then you're always using the

00:14:58,720 --> 00:15:02,320
method

00:14:59,839 --> 00:15:04,160
so what you can do is you can say def my

00:15:02,320 --> 00:15:04,800
gen x equals none while true x equals

00:15:04,160 --> 00:15:06,320
yield x

00:15:04,800 --> 00:15:08,240
x times equals five just like we had

00:15:06,320 --> 00:15:09,839
before okay so i'm going to say g equals

00:15:08,240 --> 00:15:10,720
my gen i'm going to create a generator

00:15:09,839 --> 00:15:12,399
object

00:15:10,720 --> 00:15:14,399
and now i'm going to say next of g i

00:15:12,399 --> 00:15:16,560
need to do what's known as priming

00:15:14,399 --> 00:15:18,079
what what's priming priming is running

00:15:16,560 --> 00:15:20,320
through the first

00:15:18,079 --> 00:15:21,360
yield statement on the right there so we

00:15:20,320 --> 00:15:22,399
get a value back

00:15:21,360 --> 00:15:23,519
and that's always going to be well

00:15:22,399 --> 00:15:24,639
whatever it wants to return here it's

00:15:23,519 --> 00:15:26,720
going to be none

00:15:24,639 --> 00:15:28,240
but now we've gone to sleep on the right

00:15:26,720 --> 00:15:30,240
side of that assignment

00:15:28,240 --> 00:15:31,600
so whatever we send will be assigned to

00:15:30,240 --> 00:15:34,000
x and sure enough if i say

00:15:31,600 --> 00:15:35,759
g dot send of ten that means that now

00:15:34,000 --> 00:15:37,759
we've got x equals ten

00:15:35,759 --> 00:15:40,079
x times equals five five times seven is

00:15:37,759 --> 00:15:40,560
fifty we go back to the top of the while

00:15:40,079 --> 00:15:43,040
loop

00:15:40,560 --> 00:15:44,079
we yield x so we get 50 back and now

00:15:43,040 --> 00:15:47,839
it's waiting again

00:15:44,079 --> 00:15:50,560
so i say g that's end of 23 x equals 23

00:15:47,839 --> 00:15:51,360
x times equals 5 down to 115 go back to

00:15:50,560 --> 00:15:53,120
the top of the loop

00:15:51,360 --> 00:15:54,880
yield it and we get that back i can even

00:15:53,120 --> 00:15:56,800
say g send of abc

00:15:54,880 --> 00:15:58,160
or g dot send of one two three i can

00:15:56,800 --> 00:16:00,320
send any python

00:15:58,160 --> 00:16:02,399
object i want and so long as it works

00:16:00,320 --> 00:16:05,759
within the context of this api

00:16:02,399 --> 00:16:07,120
i'm doing great this is what's known as

00:16:05,759 --> 00:16:09,680
a co routine

00:16:07,120 --> 00:16:12,160
and a co-routine is a generator that

00:16:09,680 --> 00:16:14,399
waits to get input from somewhere else

00:16:12,160 --> 00:16:16,000
the data is received within the yield

00:16:14,399 --> 00:16:16,720
expression usually on the right live

00:16:16,000 --> 00:16:18,480
assignment

00:16:16,720 --> 00:16:20,720
and our local state as before remains

00:16:18,480 --> 00:16:23,360
across calls

00:16:20,720 --> 00:16:25,759
now you might remember or you might know

00:16:23,360 --> 00:16:27,120
that when python 3.8 came out it

00:16:25,759 --> 00:16:29,680
introduced what was called the

00:16:27,120 --> 00:16:31,040
walrus operator right no one calls it

00:16:29,680 --> 00:16:32,160
the assignment expression everyone calls

00:16:31,040 --> 00:16:33,120
the wallet and you're not sure why it's

00:16:32,160 --> 00:16:34,959
called the walrus

00:16:33,120 --> 00:16:36,560
tilt your head about 90 degrees to the

00:16:34,959 --> 00:16:39,920
left and you'll see there's eyes

00:16:36,560 --> 00:16:41,759
and tusks and okay fine this

00:16:39,920 --> 00:16:42,880
expression assignment express operator

00:16:41,759 --> 00:16:44,560
of the walrus is one of the most

00:16:42,880 --> 00:16:45,519
controversial things i've ever seen in

00:16:44,560 --> 00:16:47,839
the python world

00:16:45,519 --> 00:16:49,360
it led to a whole lot of crazy

00:16:47,839 --> 00:16:52,160
discussion and anger

00:16:49,360 --> 00:16:52,959
and so forth in the python world what

00:16:52,160 --> 00:16:54,480
does it mean

00:16:52,959 --> 00:16:56,000
it means that we're going to be able to

00:16:54,480 --> 00:16:57,920
assign

00:16:56,000 --> 00:16:59,600
and assignment then becomes an

00:16:57,920 --> 00:17:01,120
expression we get the value back

00:16:59,600 --> 00:17:02,880
so what are we going to do here we're

00:17:01,120 --> 00:17:05,600
going to say death of my gen

00:17:02,880 --> 00:17:07,439
x equals none just like before but now

00:17:05,600 --> 00:17:07,919
we can tighten up that while loop i no

00:17:07,439 --> 00:17:10,400
longer

00:17:07,919 --> 00:17:11,280
need to have while true and then assign

00:17:10,400 --> 00:17:14,480
and then check

00:17:11,280 --> 00:17:18,400
rather i can just say while x walrus

00:17:14,480 --> 00:17:20,480
yield x what this means is if i get

00:17:18,400 --> 00:17:21,760
a value that's none or anything else

00:17:20,480 --> 00:17:24,400
that's empty

00:17:21,760 --> 00:17:25,919
from the yield sent to me then that will

00:17:24,400 --> 00:17:26,480
be assigned to x and be an expression

00:17:25,919 --> 00:17:28,640
and we will

00:17:26,480 --> 00:17:29,840
exit from the loop that means exit from

00:17:28,640 --> 00:17:30,880
the loop whenever we get none or

00:17:29,840 --> 00:17:32,559
something that's empty

00:17:30,880 --> 00:17:34,000
but if we don't exit from the loop then

00:17:32,559 --> 00:17:36,799
we get the value

00:17:34,000 --> 00:17:37,760
notice also we need to say yield x in

00:17:36,799 --> 00:17:38,880
parentheses

00:17:37,760 --> 00:17:40,720
and the reason we need to do that's just

00:17:38,880 --> 00:17:42,640
for syntactic uh reasons otherwise

00:17:40,720 --> 00:17:46,000
python gets really confused

00:17:42,640 --> 00:17:47,679
so i now have rewritten my co-routine

00:17:46,000 --> 00:17:49,600
such that it uses the walrus operator

00:17:47,679 --> 00:17:51,520
and that's a little shorter

00:17:49,600 --> 00:17:52,720
and a little cooler i think we'll all

00:17:51,520 --> 00:17:54,320
agree

00:17:52,720 --> 00:17:56,080
what if you don't want to prime your co

00:17:54,320 --> 00:17:56,559
routine so david beasley had a whole

00:17:56,080 --> 00:17:59,600
talk

00:17:56,559 --> 00:18:00,960
uh back in 2009 about co routines about

00:17:59,600 --> 00:18:02,080
generators he suggested using a

00:18:00,960 --> 00:18:04,160
decorator which he called

00:18:02,080 --> 00:18:06,000
co routine so you would put at co

00:18:04,160 --> 00:18:07,760
routine above your generator function

00:18:06,000 --> 00:18:10,240
and it would automatically run next and

00:18:07,760 --> 00:18:11,600
then return the prime co routine

00:18:10,240 --> 00:18:13,360
um so i'm not gonna do that here that's

00:18:11,600 --> 00:18:15,039
actually not not a bad idea because

00:18:13,360 --> 00:18:16,720
it's just a pain to do the whole priming

00:18:15,039 --> 00:18:19,200
thing

00:18:16,720 --> 00:18:20,400
so what so well like i've now shown you

00:18:19,200 --> 00:18:23,600
a whole bunch of things

00:18:20,400 --> 00:18:25,840
and you might be saying okay and

00:18:23,600 --> 00:18:28,000
where do i use co routines and i often

00:18:25,840 --> 00:18:28,960
say that co-routines have looked like a

00:18:28,000 --> 00:18:31,200
solution

00:18:28,960 --> 00:18:32,720
looking for a problem right it's like oh

00:18:31,200 --> 00:18:33,600
we came up with this fantastic

00:18:32,720 --> 00:18:35,600
technology

00:18:33,600 --> 00:18:37,919
where do we use it i don't know i'm sure

00:18:35,600 --> 00:18:39,600
someone needs this for something

00:18:37,919 --> 00:18:41,600
and so i've been struggling with this

00:18:39,600 --> 00:18:43,440
for years and i've been trying to figure

00:18:41,600 --> 00:18:45,039
out where to use co routines how they

00:18:43,440 --> 00:18:46,720
fit into the python ecosystem

00:18:45,039 --> 00:18:48,320
because there was a lot of effort put

00:18:46,720 --> 00:18:50,240
into them to add these sorts of

00:18:48,320 --> 00:18:52,160
this sort of functionality into python

00:18:50,240 --> 00:18:52,640
and yet no one seems to really use it

00:18:52,160 --> 00:18:54,799
very much

00:18:52,640 --> 00:18:56,400
moreover as we'll see in a bit some new

00:18:54,799 --> 00:18:57,360
keywords were added to the language a

00:18:56,400 --> 00:18:58,799
number of years ago

00:18:57,360 --> 00:19:00,640
and no one quite knows how to use those

00:18:58,799 --> 00:19:01,280
either so what i want to do is give you

00:19:00,640 --> 00:19:03,760
some

00:19:01,280 --> 00:19:04,559
ideas for where this could be used and

00:19:03,760 --> 00:19:07,840
we'll see

00:19:04,559 --> 00:19:10,080
where it goes so my big idea is

00:19:07,840 --> 00:19:11,520
code routines can be sort of like nano

00:19:10,080 --> 00:19:12,880
services all right some of us were

00:19:11,520 --> 00:19:14,960
joking in the chat before i started

00:19:12,880 --> 00:19:16,720
about like how how big are dinosaurs

00:19:14,960 --> 00:19:18,240
so where does this term come from and

00:19:16,720 --> 00:19:20,400
i've made it up i think

00:19:18,240 --> 00:19:22,160
right so if you really hate it um i did

00:19:20,400 --> 00:19:23,679
not make it up in any event

00:19:22,160 --> 00:19:25,200
many applications like service

00:19:23,679 --> 00:19:27,039
applications have what's known as a

00:19:25,200 --> 00:19:28,240
micro service architecture so rather

00:19:27,039 --> 00:19:30,799
than having one

00:19:28,240 --> 00:19:31,360
big program that handles everything you

00:19:30,799 --> 00:19:33,840
have

00:19:31,360 --> 00:19:35,440
a uh you know a caching server and you

00:19:33,840 --> 00:19:37,440
have an authentication server

00:19:35,440 --> 00:19:39,840
and you have a database server and you

00:19:37,440 --> 00:19:41,200
have you split things up into many many

00:19:39,840 --> 00:19:42,400
many different servers

00:19:41,200 --> 00:19:44,880
all right and so you access each

00:19:42,400 --> 00:19:47,120
microservice via a different api

00:19:44,880 --> 00:19:49,120
so i think of co routines as nano

00:19:47,120 --> 00:19:50,080
services meaning they are super super

00:19:49,120 --> 00:19:52,880
tiny

00:19:50,080 --> 00:19:53,360
in memory services we have to worry

00:19:52,880 --> 00:19:55,440
about

00:19:53,360 --> 00:19:56,799
network overhead or object overhead or

00:19:55,440 --> 00:19:58,320
thread overhead or process overhead

00:19:56,799 --> 00:19:59,360
we're not switching threads there's no

00:19:58,320 --> 00:20:01,280
contact switch

00:19:59,360 --> 00:20:02,400
and it keeps its state across different

00:20:01,280 --> 00:20:04,240
iterations

00:20:02,400 --> 00:20:06,080
and so you'll need to create your own

00:20:04,240 --> 00:20:07,440
protocol for a co-routine but you should

00:20:06,080 --> 00:20:10,080
use python's very

00:20:07,440 --> 00:20:11,600
rich data structures and this means then

00:20:10,080 --> 00:20:12,880
that basically

00:20:11,600 --> 00:20:15,600
right we can create these little

00:20:12,880 --> 00:20:17,039
services and we can use them from within

00:20:15,600 --> 00:20:19,520
our program

00:20:17,039 --> 00:20:22,159
what do i mean well here's a few

00:20:19,520 --> 00:20:24,000
examples so one example is md5 so mp5

00:20:22,159 --> 00:20:26,080
is a popular hash function it's in hash

00:20:24,000 --> 00:20:28,240
lib but i don't know about you i found

00:20:26,080 --> 00:20:29,360
it a bit of a pain to use in python

00:20:28,240 --> 00:20:31,280
so what i'm going to do is i'm going to

00:20:29,360 --> 00:20:33,280
create a little md5 service

00:20:31,280 --> 00:20:34,640
within my program okay so how's that

00:20:33,280 --> 00:20:36,320
going to work well

00:20:34,640 --> 00:20:37,840
i'm going to say here import hash lab

00:20:36,320 --> 00:20:38,720
that's where it lies you know that's

00:20:37,840 --> 00:20:41,280
where it resides in the

00:20:38,720 --> 00:20:42,640
standard library dev mp5 gen let's say

00:20:41,280 --> 00:20:44,400
output equals none and then i'm going to

00:20:42,640 --> 00:20:46,559
use the walrus right while s

00:20:44,400 --> 00:20:48,000
code equals yield output so we're going

00:20:46,559 --> 00:20:50,640
to get a string

00:20:48,000 --> 00:20:54,080
from someone we are then going to create

00:20:50,640 --> 00:20:56,080
a new md5 object n equals hashtag.mp5

00:20:54,080 --> 00:20:57,840
i then have to turn the string into

00:20:56,080 --> 00:20:58,720
bytes that's one of the annoying things

00:20:57,840 --> 00:21:00,960
about dealing with this

00:20:58,720 --> 00:21:02,400
it's going to say m.update s dot encode

00:21:00,960 --> 00:21:03,039
so i'm going to say s9 code turn into a

00:21:02,400 --> 00:21:04,799
byte string

00:21:03,039 --> 00:21:06,799
hand it to m.update and then we're going

00:21:04,799 --> 00:21:08,720
to say hey md5 object

00:21:06,799 --> 00:21:10,159
what's the hex digest what are the 40

00:21:08,720 --> 00:21:10,799
hex bytes that can get back in that

00:21:10,159 --> 00:21:13,919
output

00:21:10,799 --> 00:21:15,840
and it works right g equals mb5 gen g.10

00:21:13,919 --> 00:21:17,520
num why am i doing that gotta prime it

00:21:15,840 --> 00:21:19,039
then i say print g dot send it hello and

00:21:17,520 --> 00:21:20,159
we get something back

00:21:19,039 --> 00:21:22,400
just saying goodbye we get something

00:21:20,159 --> 00:21:23,840
back i kept out the md5 signature i

00:21:22,400 --> 00:21:25,919
don't think that exciting

00:21:23,840 --> 00:21:27,520
and then i can say g dot send of none

00:21:25,919 --> 00:21:28,000
what happens when i get none well the

00:21:27,520 --> 00:21:30,400
loop

00:21:28,000 --> 00:21:31,600
exits because of the walrus operator

00:21:30,400 --> 00:21:33,520
there and then the

00:21:31,600 --> 00:21:35,200
generator function exits which means we

00:21:33,520 --> 00:21:36,159
get a stop iteration so we exit from

00:21:35,200 --> 00:21:38,000
there

00:21:36,159 --> 00:21:40,080
here's another example so let's say i

00:21:38,000 --> 00:21:42,320
want to get the weather forecast

00:21:40,080 --> 00:21:43,200
for a particular city so it turns out

00:21:42,320 --> 00:21:45,280
that the

00:21:43,200 --> 00:21:46,960
world meteorological institute which is

00:21:45,280 --> 00:21:49,039
affiliated with united nations

00:21:46,960 --> 00:21:50,720
actually has a server where if you know

00:21:49,039 --> 00:21:52,000
the number of your city and they

00:21:50,720 --> 00:21:52,799
actually have a chart of that on their

00:21:52,000 --> 00:21:54,960
website

00:21:52,799 --> 00:21:56,720
you can pass it a url and they'll give

00:21:54,960 --> 00:21:58,799
you back json

00:21:56,720 --> 00:22:00,159
and so what you can do is you can

00:21:58,799 --> 00:22:03,200
request the weather

00:22:00,159 --> 00:22:04,640
for city any number here dot json

00:22:03,200 --> 00:22:06,720
i'm going to use request so request is a

00:22:04,640 --> 00:22:08,480
nice.json method there and then you

00:22:06,720 --> 00:22:10,320
have to dig into the forecast i can say

00:22:08,480 --> 00:22:12,880
give me one forecast per day

00:22:10,320 --> 00:22:14,000
so i say g equals get forecast 44 and

00:22:12,880 --> 00:22:16,240
then each time i say

00:22:14,000 --> 00:22:17,840
print next to g what am i going to get

00:22:16,240 --> 00:22:18,960
i'm get the next weather the next

00:22:17,840 --> 00:22:20,480
weather the next weather

00:22:18,960 --> 00:22:22,559
that's pretty great because it means i'm

00:22:20,480 --> 00:22:23,840
only requesting it once i'm only going

00:22:22,559 --> 00:22:26,559
out to the network once

00:22:23,840 --> 00:22:27,840
but i'm getting multiple values back and

00:22:26,559 --> 00:22:29,200
you might be saying wait a second that's

00:22:27,840 --> 00:22:30,400
not a co routine

00:22:29,200 --> 00:22:31,679
like like after all this talking about

00:22:30,400 --> 00:22:32,640
code reviews i was supposed to generate

00:22:31,679 --> 00:22:33,919
a routine all right

00:22:32,640 --> 00:22:36,240
so let's do something slightly different

00:22:33,919 --> 00:22:38,640
here let's say that get forecast

00:22:36,240 --> 00:22:40,080
and while city id equal so i'm gonna get

00:22:38,640 --> 00:22:41,760
a city id

00:22:40,080 --> 00:22:43,120
and then i'm going to yield each of the

00:22:41,760 --> 00:22:44,240
forecasts for that city

00:22:43,120 --> 00:22:46,559
so i'm going to say g equals get

00:22:44,240 --> 00:22:47,039
forecast next of g and look now i'm

00:22:46,559 --> 00:22:48,559
going to get

00:22:47,039 --> 00:22:50,720
send the city number or none this is

00:22:48,559 --> 00:22:54,000
like my super primitive protocol

00:22:50,720 --> 00:22:55,520
so if i say g dot send to 44 we'll get

00:22:54,000 --> 00:22:57,120
that and i can send whatever i want now

00:22:55,520 --> 00:22:58,400
until it runs out send forty fourths and

00:22:57,120 --> 00:22:59,919
forty four so i'm gonna get a few

00:22:58,400 --> 00:23:02,640
different uh weather forecasts

00:22:59,919 --> 00:23:03,280
and then if i say send 44 another time

00:23:02,640 --> 00:23:05,200
we get it

00:23:03,280 --> 00:23:06,640
and then it says oh i'm back to the top

00:23:05,200 --> 00:23:08,000
basically we ran

00:23:06,640 --> 00:23:09,679
out of weather forecast so it goes back

00:23:08,000 --> 00:23:10,880
to the top of the while loop and now we

00:23:09,679 --> 00:23:13,440
can set a different city

00:23:10,880 --> 00:23:14,880
again and again and again so basically

00:23:13,440 --> 00:23:16,400
what i'm doing here is i'm caching the

00:23:14,880 --> 00:23:17,679
weather information it's in memory so

00:23:16,400 --> 00:23:18,960
i'm not saving memory

00:23:17,679 --> 00:23:20,640
but i'm not having to deal with this

00:23:18,960 --> 00:23:21,679
huge data structure it's broken down for

00:23:20,640 --> 00:23:23,280
me

00:23:21,679 --> 00:23:26,400
here's another example of food for

00:23:23,280 --> 00:23:27,760
thought i can use psycho pg2 which is a

00:23:26,400 --> 00:23:29,679
popular library for connecting to

00:23:27,760 --> 00:23:31,360
postgresql so i can connect to the

00:23:29,679 --> 00:23:32,080
database with a database string and i

00:23:31,360 --> 00:23:34,720
can say well

00:23:32,080 --> 00:23:35,280
i want to select all the people all the

00:23:34,720 --> 00:23:36,720
people

00:23:35,280 --> 00:23:38,799
with whatever first name last name

00:23:36,720 --> 00:23:39,039
birthday they have um and i populated

00:23:38,799 --> 00:23:40,880
the

00:23:39,039 --> 00:23:42,159
database with four people me and my

00:23:40,880 --> 00:23:43,120
three children um

00:23:42,159 --> 00:23:45,279
so this is gonna be a very small

00:23:43,120 --> 00:23:46,480
database and i can then even do a little

00:23:45,279 --> 00:23:47,840
trick here where i can

00:23:46,480 --> 00:23:49,760
get information i'm gonna get a

00:23:47,840 --> 00:23:50,640
dictionary right you can see here my

00:23:49,760 --> 00:23:52,080
while loop

00:23:50,640 --> 00:23:53,919
what am i getting from yield i'm getting

00:23:52,080 --> 00:23:54,640
a dictionary so we can do is make the

00:23:53,919 --> 00:23:58,000
dictionary

00:23:54,640 --> 00:23:58,880
keys match up with the fields in the

00:23:58,000 --> 00:24:01,440
database

00:23:58,880 --> 00:24:02,640
i can create my own tiny little query

00:24:01,440 --> 00:24:03,840
language here

00:24:02,640 --> 00:24:05,200
and sure enough that i can print the

00:24:03,840 --> 00:24:06,720
query and then i'm going to just do for

00:24:05,200 --> 00:24:07,520
one record and per dot fetch all so i'm

00:24:06,720 --> 00:24:09,360
going to get

00:24:07,520 --> 00:24:11,279
all the records that match yield one

00:24:09,360 --> 00:24:13,120
record how does this work how does this

00:24:11,279 --> 00:24:14,559
look well i can say g equals people api

00:24:13,120 --> 00:24:16,400
so i'm going to create my generator

00:24:14,559 --> 00:24:18,000
i'm going to prime it next g send a

00:24:16,400 --> 00:24:20,559
query or none to quit and so now

00:24:18,000 --> 00:24:22,240
i'm going to send a uh query i'm going

00:24:20,559 --> 00:24:23,360
to say g dot send up here's my date and

00:24:22,240 --> 00:24:25,279
here's my dictionary

00:24:23,360 --> 00:24:27,120
last name learner and sure enough it'll

00:24:25,279 --> 00:24:28,640
bring me back one value and that says

00:24:27,120 --> 00:24:30,480
and then i have to say g said whatever

00:24:28,640 --> 00:24:31,279
it was like i have to get it back to the

00:24:30,480 --> 00:24:32,960
where we were

00:24:31,279 --> 00:24:34,720
said it queer and under quit i'm going

00:24:32,960 --> 00:24:36,080
to say now g that's end last name is

00:24:34,720 --> 00:24:37,039
lerner friedman that's my children's

00:24:36,080 --> 00:24:39,200
last name

00:24:37,039 --> 00:24:40,320
and so there we get one two three

00:24:39,200 --> 00:24:42,880
elements and then it's

00:24:40,320 --> 00:24:43,760
back to the top so basically we've got

00:24:42,880 --> 00:24:45,600
this little

00:24:43,760 --> 00:24:46,880
api going now i'm not trying to tell you

00:24:45,600 --> 00:24:48,240
that you should recreate

00:24:46,880 --> 00:24:50,400
well reinvent the wheel and create your

00:24:48,240 --> 00:24:52,159
own database query system but it shows

00:24:50,400 --> 00:24:52,640
you the possibilities for what you can

00:24:52,159 --> 00:24:55,279
create

00:24:52,640 --> 00:24:56,720
and how you create rich data the other

00:24:55,279 --> 00:24:57,919
thing is how can i tell the generator

00:24:56,720 --> 00:24:59,200
that i'm really done

00:24:57,919 --> 00:25:00,720
right what if i want to exit i don't

00:24:59,200 --> 00:25:02,559
want it to raise a stop iteration i can

00:25:00,720 --> 00:25:04,880
actually use the close method

00:25:02,559 --> 00:25:06,720
and the close method says i'm done you

00:25:04,880 --> 00:25:08,559
don't have to continue sticking around

00:25:06,720 --> 00:25:10,159
right don't just go to sleep but keep

00:25:08,559 --> 00:25:12,960
the stack frame active

00:25:10,159 --> 00:25:14,720
rather go to sleep and exit and you know

00:25:12,960 --> 00:25:17,200
that's it

00:25:14,720 --> 00:25:18,080
but what if i want to do something a

00:25:17,200 --> 00:25:21,279
little different from that

00:25:18,080 --> 00:25:22,400
not close the current generator but

00:25:21,279 --> 00:25:24,400
rather i want to

00:25:22,400 --> 00:25:26,000
like send it a signal of some sort not

00:25:24,400 --> 00:25:26,799
send it a message that we know we can do

00:25:26,000 --> 00:25:28,400
with send

00:25:26,799 --> 00:25:30,159
but i want to like kick it out of the

00:25:28,400 --> 00:25:31,200
inner loop and get it back out to the

00:25:30,159 --> 00:25:33,279
outer loop

00:25:31,200 --> 00:25:35,120
well for that it actually turns out that

00:25:33,279 --> 00:25:36,320
we have an option and that is the throw

00:25:35,120 --> 00:25:38,799
method

00:25:36,320 --> 00:25:40,559
so what happens is we can run the throw

00:25:38,799 --> 00:25:42,480
method on the generator

00:25:40,559 --> 00:25:44,159
and that will raise an exception an

00:25:42,480 --> 00:25:46,080
exception of our choice

00:25:44,159 --> 00:25:47,840
inside of the generator it's like we're

00:25:46,080 --> 00:25:49,360
we're really throwing an exception we're

00:25:47,840 --> 00:25:52,480
causing the exception to happen

00:25:49,360 --> 00:25:54,159
inside the generator there so how can we

00:25:52,480 --> 00:25:55,840
do this so for example i can say here

00:25:54,159 --> 00:25:57,200
class of difference city exception

00:25:55,840 --> 00:25:59,120
and i want to point out that using a

00:25:57,200 --> 00:26:00,559
custom exception is really a good idea

00:25:59,120 --> 00:26:01,520
you don't want to use just like you know

00:26:00,559 --> 00:26:03,679
any old exception

00:26:01,520 --> 00:26:05,600
so not a built-in one and now i've

00:26:03,679 --> 00:26:07,039
rewritten my code a little bit

00:26:05,600 --> 00:26:08,320
so i'm going to get the city id fine i'm

00:26:07,039 --> 00:26:09,600
going to get the request and i'm going

00:26:08,320 --> 00:26:10,720
to say try

00:26:09,600 --> 00:26:13,360
as i tell my kids it's always good to

00:26:10,720 --> 00:26:16,159
try right and so we're going to try to

00:26:13,360 --> 00:26:17,120
retrieve it and we do try and yield the

00:26:16,159 --> 00:26:18,960
thing is though

00:26:17,120 --> 00:26:20,480
every time we do a yield what happens

00:26:18,960 --> 00:26:22,240
that's right the generator returns a

00:26:20,480 --> 00:26:25,360
value and goes to sleep right there

00:26:22,240 --> 00:26:26,880
and if we then say throw

00:26:25,360 --> 00:26:28,559
that's where the exception is going to

00:26:26,880 --> 00:26:29,760
be caught and we can say except for

00:26:28,559 --> 00:26:31,679
difference in the exception

00:26:29,760 --> 00:26:33,679
continue what's going to continue the

00:26:31,679 --> 00:26:35,200
while loop meaning go back up to the top

00:26:33,679 --> 00:26:36,880
let me show you how that works so i'm

00:26:35,200 --> 00:26:37,200
going to say g equals get forecast next

00:26:36,880 --> 00:26:40,400
g

00:26:37,200 --> 00:26:43,279
gotta prime it send 44 got it send 44

00:26:40,400 --> 00:26:44,720
got it throw a different city exception

00:26:43,279 --> 00:26:46,400
and now it goes back up to the top of

00:26:44,720 --> 00:26:47,440
the while loop and it once again asks us

00:26:46,400 --> 00:26:49,039
for a city and now we can get a

00:26:47,440 --> 00:26:51,600
different city

00:26:49,039 --> 00:26:53,440
so our nano service here is available

00:26:51,600 --> 00:26:54,159
via very simple request and response

00:26:53,440 --> 00:26:56,240
interface

00:26:54,159 --> 00:26:58,159
it uses data structures for input and

00:26:56,240 --> 00:26:59,600
output we can keep state across the

00:26:58,159 --> 00:27:01,120
indications here which is perfect for

00:26:59,600 --> 00:27:02,159
network connections database connections

00:27:01,120 --> 00:27:04,000
and we even saw

00:27:02,159 --> 00:27:06,159
that it's able to yield one element at a

00:27:04,000 --> 00:27:08,000
time which is pretty great

00:27:06,159 --> 00:27:10,000
all right let's do a little thought

00:27:08,000 --> 00:27:12,400
experiment let's say

00:27:10,000 --> 00:27:13,120
we want to put lots and lots and lots of

00:27:12,400 --> 00:27:15,279
functionality

00:27:13,120 --> 00:27:17,120
into our same co-routine i know this is

00:27:15,279 --> 00:27:19,760
a bad idea and i know this goes against

00:27:17,120 --> 00:27:20,880
everything i told you so far so let's

00:27:19,760 --> 00:27:23,440
say we want to have

00:27:20,880 --> 00:27:24,159
inside of the same nano service mega

00:27:23,440 --> 00:27:26,799
service

00:27:24,159 --> 00:27:27,440
md5 hashing and weather forecasting

00:27:26,799 --> 00:27:29,520
right there's a

00:27:27,440 --> 00:27:31,279
there's an old uh fake advertisement in

00:27:29,520 --> 00:27:33,279
the united states for a comedy show

00:27:31,279 --> 00:27:35,279
where they talked about it's a floor

00:27:33,279 --> 00:27:36,000
polish no it's a dessert topping it can

00:27:35,279 --> 00:27:38,000
be both

00:27:36,000 --> 00:27:39,919
so i feel like this is this is almost as

00:27:38,000 --> 00:27:41,520
bad but less tasty

00:27:39,919 --> 00:27:43,840
so what am i going to do here i'm going

00:27:41,520 --> 00:27:44,640
to have this huge honking combined

00:27:43,840 --> 00:27:45,919
generator

00:27:44,640 --> 00:27:48,240
and it's going to do what we had in our

00:27:45,919 --> 00:27:50,320
previous two generators it's gonna say

00:27:48,240 --> 00:27:52,880
while s equals yield send one for

00:27:50,320 --> 00:27:55,600
weather two for md5 or num to exit

00:27:52,880 --> 00:27:57,520
so if the person sends one then we're

00:27:55,600 --> 00:27:59,039
gonna start doing a weather forecasting

00:27:57,520 --> 00:28:00,799
if they send two then we're gonna do our

00:27:59,039 --> 00:28:02,880
mp5 hashing

00:28:00,799 --> 00:28:05,279
oh wait does this work actually it does

00:28:02,880 --> 00:28:07,279
work it's a terrible idea but it works

00:28:05,279 --> 00:28:09,039
right as i like to say unfortunately it

00:28:07,279 --> 00:28:10,480
works so we say here g equals our

00:28:09,039 --> 00:28:12,720
combined generator we're gonna do next

00:28:10,480 --> 00:28:14,960
sends us the message send one oh well

00:28:12,720 --> 00:28:16,880
that wants a city number so i'll send 44

00:28:14,960 --> 00:28:18,080
great then i can throw an exception i'm

00:28:16,880 --> 00:28:20,320
back at the top

00:28:18,080 --> 00:28:21,840
i can give it a number or i can throw

00:28:20,320 --> 00:28:23,760
the exception i can send none and i'm

00:28:21,840 --> 00:28:25,440
back at the way way tippy top i can say

00:28:23,760 --> 00:28:27,520
i want to do md5 hashing

00:28:25,440 --> 00:28:28,960
here's the hash for hello hello

00:28:27,520 --> 00:28:31,200
exclamation point

00:28:28,960 --> 00:28:33,600
fantastic and once again unfortunately

00:28:31,200 --> 00:28:35,520
this works how can we improve this

00:28:33,600 --> 00:28:37,440
and let's think about this a generator

00:28:35,520 --> 00:28:39,039
function is basically a function right

00:28:37,440 --> 00:28:40,720
how would we do this if this were a

00:28:39,039 --> 00:28:42,159
regular function well if it were a

00:28:40,720 --> 00:28:43,600
regular function we'd break it down into

00:28:42,159 --> 00:28:44,960
smaller parts

00:28:43,600 --> 00:28:46,799
right we would take our function break

00:28:44,960 --> 00:28:49,520
it apart and then have little functions

00:28:46,799 --> 00:28:51,520
let's do that with our generator so i'm

00:28:49,520 --> 00:28:53,360
going to have say combined generator

00:28:51,520 --> 00:28:55,279
is going to be a very top level high

00:28:53,360 --> 00:28:57,279
level function it's going to say

00:28:55,279 --> 00:28:59,200
if we got 1 then i'll run the city

00:28:57,279 --> 00:29:01,200
generator and if i got two then i'll do

00:28:59,200 --> 00:29:02,480
the md5 generator

00:29:01,200 --> 00:29:04,320
and then i separate out the two

00:29:02,480 --> 00:29:05,679
generators there the only problem is

00:29:04,320 --> 00:29:06,880
this does not work other than that it's

00:29:05,679 --> 00:29:09,039
great

00:29:06,880 --> 00:29:10,640
because i say g equals combine generator

00:29:09,039 --> 00:29:11,919
next we get that i'm going to send

00:29:10,640 --> 00:29:12,640
something it ignores it completely

00:29:11,919 --> 00:29:15,120
ignores it

00:29:12,640 --> 00:29:16,240
why isn't ignoring it let's look at this

00:29:15,120 --> 00:29:18,559
right i showed you here

00:29:16,240 --> 00:29:20,240
if s equal equal 1 city generator what

00:29:18,559 --> 00:29:22,640
happens when you call a generator

00:29:20,240 --> 00:29:23,760
you just get the generator object so

00:29:22,640 --> 00:29:25,039
we're not actually

00:29:23,760 --> 00:29:26,799
incrementing the generator we're not

00:29:25,039 --> 00:29:29,120
running next on it we're just like

00:29:26,799 --> 00:29:30,159
we're not even returning it so what can

00:29:29,120 --> 00:29:32,320
we do

00:29:30,159 --> 00:29:33,840
we need it's not enough we're going to

00:29:32,320 --> 00:29:35,440
need to yield something

00:29:33,840 --> 00:29:36,960
now maybe we could just iterate over the

00:29:35,440 --> 00:29:38,480
items that that generator get returns

00:29:36,960 --> 00:29:40,000
but that's not going to be enough

00:29:38,480 --> 00:29:42,159
because you have to imagine how we have

00:29:40,000 --> 00:29:43,679
three things we have the outside person

00:29:42,159 --> 00:29:45,600
who's sending the message

00:29:43,679 --> 00:29:47,360
we have our combined generator in the

00:29:45,600 --> 00:29:49,120
middle sort of acting like an agent

00:29:47,360 --> 00:29:50,640
and then we have the actual md5

00:29:49,120 --> 00:29:51,600
generator or the weather forecasting

00:29:50,640 --> 00:29:53,679
generator

00:29:51,600 --> 00:29:54,720
so what happens from the outside if i

00:29:53,679 --> 00:29:57,679
run next

00:29:54,720 --> 00:29:58,720
or send if someone has to get past this

00:29:57,679 --> 00:30:00,640
into the end one

00:29:58,720 --> 00:30:02,240
right has to sort of do a pass through

00:30:00,640 --> 00:30:06,320
let alone what about throw

00:30:02,240 --> 00:30:09,120
or close this is where yield from

00:30:06,320 --> 00:30:10,880
comes to the rescue combined generator

00:30:09,120 --> 00:30:13,679
can be rewritten to say if s

00:30:10,880 --> 00:30:16,640
equals equals one yield from city

00:30:13,679 --> 00:30:18,880
generator and yield from mp5 generator

00:30:16,640 --> 00:30:20,240
i cannot tell you how many people are

00:30:18,880 --> 00:30:22,559
thoroughly convinced

00:30:20,240 --> 00:30:23,440
that yield from which was a new keyword

00:30:22,559 --> 00:30:26,240
introduced

00:30:23,440 --> 00:30:28,080
into python i believe three three would

00:30:26,240 --> 00:30:30,000
they really create a new keyword

00:30:28,080 --> 00:30:31,039
just to have us do a for loop that's

00:30:30,000 --> 00:30:31,760
what a lot of people think it is they're

00:30:31,039 --> 00:30:33,120
like oh

00:30:31,760 --> 00:30:34,480
if you want to iterate over a sub

00:30:33,120 --> 00:30:35,200
generator then just instead of doing a

00:30:34,480 --> 00:30:37,919
forward abuse

00:30:35,200 --> 00:30:39,440
yield problem that is not wrong but it

00:30:37,919 --> 00:30:40,399
doesn't even come close to describing

00:30:39,440 --> 00:30:43,200
what's going on

00:30:40,399 --> 00:30:44,799
what yield from does is it provides

00:30:43,200 --> 00:30:46,960
bi-directional communication

00:30:44,799 --> 00:30:48,960
between the sender on the outside

00:30:46,960 --> 00:30:51,200
through the agent in the middle

00:30:48,960 --> 00:30:52,320
all the way to the inner one so the

00:30:51,200 --> 00:30:54,640
inner

00:30:52,320 --> 00:30:56,080
sub generator and the outer collar are

00:30:54,640 --> 00:30:58,640
suddenly talking to each other

00:30:56,080 --> 00:30:59,679
they can throw they can close and they

00:30:58,640 --> 00:31:01,840
can send

00:30:59,679 --> 00:31:03,279
and it works really well yield from is

00:31:01,840 --> 00:31:05,679
designed

00:31:03,279 --> 00:31:07,039
for subco routines that do you work and

00:31:05,679 --> 00:31:08,159
so now i can do is say g equals a

00:31:07,039 --> 00:31:10,720
combined generator

00:31:08,159 --> 00:31:11,919
next of g and then we can do send of two

00:31:10,720 --> 00:31:13,600
and send it hello

00:31:11,919 --> 00:31:15,440
whoops and like we can go through each

00:31:13,600 --> 00:31:18,559
of these pieces and it works the way

00:31:15,440 --> 00:31:21,120
we would want let me

00:31:18,559 --> 00:31:21,600
let me talk about async i o for a moment

00:31:21,120 --> 00:31:23,600
it is

00:31:21,600 --> 00:31:24,880
absolutely positively true that early

00:31:23,600 --> 00:31:27,200
versions of async i o

00:31:24,880 --> 00:31:28,240
use generator functions and now what is

00:31:27,200 --> 00:31:30,480
a c o

00:31:28,240 --> 00:31:32,000
a c i o basically says enough of this

00:31:30,480 --> 00:31:35,360
context switching craziness

00:31:32,000 --> 00:31:36,480
either to different uh um processes or

00:31:35,360 --> 00:31:38,480
to different threads

00:31:36,480 --> 00:31:40,320
there's too much overhead there let's

00:31:38,480 --> 00:31:43,360
have one process

00:31:40,320 --> 00:31:45,120
one thread and each task we want to run

00:31:43,360 --> 00:31:47,360
will be on a loop and we'll just go

00:31:45,120 --> 00:31:48,640
through each of the tasks in the loop

00:31:47,360 --> 00:31:50,399
move a little move a little move a

00:31:48,640 --> 00:31:51,840
little move a little move a little what

00:31:50,399 --> 00:31:54,000
do you mean by move a little meaning

00:31:51,840 --> 00:31:55,679
execute a little bit until you can stop

00:31:54,000 --> 00:31:56,880
right everyone gets a little time slice

00:31:55,679 --> 00:31:58,159
of the clock

00:31:56,880 --> 00:31:59,600
now you can argue that's exactly what

00:31:58,159 --> 00:32:00,080
our operating system is doing but it's

00:31:59,600 --> 00:32:02,480
not

00:32:00,080 --> 00:32:03,279
our operating system is stopping these

00:32:02,480 --> 00:32:05,120
at a certain point

00:32:03,279 --> 00:32:06,480
it's using what's known as preemptive

00:32:05,120 --> 00:32:08,080
multitasking

00:32:06,480 --> 00:32:09,600
what i just described is something that

00:32:08,080 --> 00:32:11,600
used to run on many computers something

00:32:09,600 --> 00:32:14,320
known as cooperative multitasking

00:32:11,600 --> 00:32:16,159
where all the tasks need to behave well

00:32:14,320 --> 00:32:17,600
so if you have an async death if you

00:32:16,159 --> 00:32:19,440
have an async i o

00:32:17,600 --> 00:32:21,840
function running the way i just

00:32:19,440 --> 00:32:23,600
described it can in theory run forever

00:32:21,840 --> 00:32:25,679
it doesn't ever need to await

00:32:23,600 --> 00:32:27,360
so early versions of async i o use

00:32:25,679 --> 00:32:28,960
generators because they fit the bill

00:32:27,360 --> 00:32:30,559
they allow you to run them for a little

00:32:28,960 --> 00:32:32,080
bit using sender next

00:32:30,559 --> 00:32:33,919
they will stop and go to sleep and then

00:32:32,080 --> 00:32:36,559
you can go on to the next function

00:32:33,919 --> 00:32:37,919
but a number of years ago python decided

00:32:36,559 --> 00:32:40,080
to get away from using

00:32:37,919 --> 00:32:42,159
explicit generator functions and start

00:32:40,080 --> 00:32:44,240
going in the direction of using keywords

00:32:42,159 --> 00:32:45,679
now use async def to say that you want

00:32:44,240 --> 00:32:47,200
to create a special

00:32:45,679 --> 00:32:49,840
definition a special function that will

00:32:47,200 --> 00:32:52,080
be create tasks for async io

00:32:49,840 --> 00:32:53,279
and a wait which basically says i know

00:32:52,080 --> 00:32:53,760
that something's going to take a long

00:32:53,279 --> 00:32:55,919
time

00:32:53,760 --> 00:32:57,840
so i will give up control of the cpu

00:32:55,919 --> 00:32:59,519
just come back to me if you don't mind

00:32:57,840 --> 00:33:01,120
so the ideas are similar there is some

00:32:59,519 --> 00:33:02,480
overlap and historically there was

00:33:01,120 --> 00:33:04,399
especially overlapping you'll find lots

00:33:02,480 --> 00:33:05,919
of documentation online

00:33:04,399 --> 00:33:07,600
that makes it sound like the two core

00:33:05,919 --> 00:33:09,519
routines are the same but they're not

00:33:07,600 --> 00:33:11,200
don't be confused too much

00:33:09,519 --> 00:33:12,480
so after all this should you use

00:33:11,200 --> 00:33:13,440
co-routines in the way that i've been

00:33:12,480 --> 00:33:16,720
describing

00:33:13,440 --> 00:33:18,799
so i think the answer is yes but

00:33:16,720 --> 00:33:20,799
right they can be very useful they

00:33:18,799 --> 00:33:23,679
really provide you with a speedy

00:33:20,799 --> 00:33:25,440
in-memory arbitrary api using rich data

00:33:23,679 --> 00:33:27,279
you can get lots of data one chunk at a

00:33:25,440 --> 00:33:28,000
time it knows how to divide into smaller

00:33:27,279 --> 00:33:29,760
pieces

00:33:28,000 --> 00:33:31,120
it can use yield from so you have you

00:33:29,760 --> 00:33:33,440
can have all these subco

00:33:31,120 --> 00:33:34,399
routines and sub generators but there

00:33:33,440 --> 00:33:36,799
are problems

00:33:34,399 --> 00:33:38,480
right these are not well understood and

00:33:36,799 --> 00:33:40,000
it might seem weird to be using sense

00:33:38,480 --> 00:33:42,320
you'll want to probably put some sort of

00:33:40,000 --> 00:33:44,960
api around it some pointer way around it

00:33:42,320 --> 00:33:47,440
um and when things go wrong it can be

00:33:44,960 --> 00:33:49,679
hard to debug david beasley in his talk

00:33:47,440 --> 00:33:52,080
uh mentioned i think he made it analysis

00:33:49,679 --> 00:33:54,159
too like high-powered tnt

00:33:52,080 --> 00:33:55,679
right or some other explosive we're very

00:33:54,159 --> 00:33:57,360
very useful in the right

00:33:55,679 --> 00:33:59,120
place at the right time uh but it can

00:33:57,360 --> 00:34:00,159
blow up in your face and uh cause

00:33:59,120 --> 00:34:02,640
trouble

00:34:00,159 --> 00:34:04,000
so if there are questions or comments i

00:34:02,640 --> 00:34:06,240
would be delighted to

00:34:04,000 --> 00:34:07,360
address them please feel free to contact

00:34:06,240 --> 00:34:09,440
me i'm on twitter

00:34:07,360 --> 00:34:10,480
i'm on youtube and of course my better

00:34:09,440 --> 00:34:13,040
developers uh

00:34:10,480 --> 00:34:13,760
list as well okay i'm gonna unshare my

00:34:13,040 --> 00:34:16,320
screen now

00:34:13,760 --> 00:34:21,119
and i'll be delighted to answer

00:34:16,320 --> 00:34:22,879
questions and comments

00:34:21,119 --> 00:34:24,159
all right well i i'll uh i'll hang out

00:34:22,879 --> 00:34:25,359
here for a bit longer if people have

00:34:24,159 --> 00:34:28,240
questions or comments

00:34:25,359 --> 00:34:28,800
and um i very much appreciate everyone

00:34:28,240 --> 00:34:30,639
coming here

00:34:28,800 --> 00:34:32,079
coming to my talk i am super super

00:34:30,639 --> 00:34:34,879
excited to have been here

00:34:32,079 --> 00:34:35,919
here for some value here for uh you know

00:34:34,879 --> 00:34:38,000
python africa

00:34:35,919 --> 00:34:39,119
and i really and honestly was hoping to

00:34:38,000 --> 00:34:40,159
actually come physically to python

00:34:39,119 --> 00:34:41,760
africa this year

00:34:40,159 --> 00:34:43,200
uh so we'll have to hold it off for next

00:34:41,760 --> 00:34:48,399
year or two years from now

00:34:43,200 --> 00:34:52,960
whenever uh whenever it's possible

00:34:48,399 --> 00:34:52,960
thank you so so much folks thanks joseph

00:34:53,040 --> 00:34:56,480
uh okay so joseph says i didn't quite

00:34:55,119 --> 00:34:57,359
get the difference between co routines

00:34:56,480 --> 00:35:01,200
and async i o

00:34:57,359 --> 00:35:04,400
so let me describe it this way in part

00:35:01,200 --> 00:35:06,240
so here's the thing so what we did here

00:35:04,400 --> 00:35:08,240
i'm just going to move my my window over

00:35:06,240 --> 00:35:12,880
to where my camera is so i'm not like

00:35:08,240 --> 00:35:12,880
looking over to the side there we go um

00:35:12,960 --> 00:35:17,680
so so historically like

00:35:16,000 --> 00:35:19,760
back i don't know 10 years ago 15 years

00:35:17,680 --> 00:35:21,440
ago they started the co routines as i

00:35:19,760 --> 00:35:23,440
described them here we had generators we

00:35:21,440 --> 00:35:26,400
had co routines and so forth

00:35:23,440 --> 00:35:27,760
those ideas then led to the development

00:35:26,400 --> 00:35:30,160
of async io

00:35:27,760 --> 00:35:31,440
so there was a point in python history

00:35:30,160 --> 00:35:33,280
when if you wanted to create a

00:35:31,440 --> 00:35:35,280
co-routine as i showed you here

00:35:33,280 --> 00:35:37,280
you could and with a little bit of

00:35:35,280 --> 00:35:40,160
tweaking not even very much

00:35:37,280 --> 00:35:41,760
it would work in async io as well right

00:35:40,160 --> 00:35:43,440
it was basically the same thing

00:35:41,760 --> 00:35:45,520
and there were even decorators that you

00:35:43,440 --> 00:35:47,839
would use to turn a generator

00:35:45,520 --> 00:35:49,280
into an asynchronoco routine at a

00:35:47,839 --> 00:35:49,680
certain point for reasons that are not

00:35:49,280 --> 00:35:52,160
quite

00:35:49,680 --> 00:35:52,960
obvious to me um i'm guessing have to do

00:35:52,160 --> 00:35:54,640
with uh

00:35:52,960 --> 00:35:56,000
performance they said you know what

00:35:54,640 --> 00:35:57,599
we're going to stop this

00:35:56,000 --> 00:35:59,440
we're going to have ac i don't have its

00:35:57,599 --> 00:36:01,119
own async i o defs so they're not

00:35:59,440 --> 00:36:02,720
compatible anymore i was just reading up

00:36:01,119 --> 00:36:05,760
on this earlier just to double check

00:36:02,720 --> 00:36:08,160
but you can no longer use agenda code

00:36:05,760 --> 00:36:09,119
uh async co routines are now defined

00:36:08,160 --> 00:36:10,800
with async death

00:36:09,119 --> 00:36:12,400
they are not iterable so you can't run

00:36:10,800 --> 00:36:14,400
them in a for loop you

00:36:12,400 --> 00:36:16,160
might be able to use uh python

00:36:14,400 --> 00:36:17,680
generators or like scorpions that i

00:36:16,160 --> 00:36:18,560
showed today in async i o but i don't

00:36:17,680 --> 00:36:20,880
believe so

00:36:18,560 --> 00:36:21,920
i believe they've now diverged so i find

00:36:20,880 --> 00:36:23,920
it useful to

00:36:21,920 --> 00:36:25,200
teach people about actually these sorts

00:36:23,920 --> 00:36:27,119
of generation code routines

00:36:25,200 --> 00:36:29,359
before talking about async io because

00:36:27,119 --> 00:36:31,280
the ideas are similar to overlapping

00:36:29,359 --> 00:36:33,440
but they're not compatible with each

00:36:31,280 --> 00:36:35,359
other that in our

00:36:33,440 --> 00:36:36,800
nano routine you know nano service go

00:36:35,359 --> 00:36:40,000
routines i showed today

00:36:36,800 --> 00:36:41,680
you're really depending on some

00:36:40,000 --> 00:36:43,040
some service right it's going to say

00:36:41,680 --> 00:36:44,720
send send send

00:36:43,040 --> 00:36:46,480
whereas in the case of a single co

00:36:44,720 --> 00:36:49,119
routine it's the event loop

00:36:46,480 --> 00:36:50,480
that every n seconds or and that

00:36:49,119 --> 00:36:52,560
microseconds whatever it's going to be

00:36:50,480 --> 00:36:54,400
is going to basically do a send but it's

00:36:52,560 --> 00:36:56,000
also not sending any data

00:36:54,400 --> 00:36:57,839
it's just running it i guess that's

00:36:56,000 --> 00:37:00,000
actually a good difference between them

00:36:57,839 --> 00:37:00,960
that um you need to i guess it's it's a

00:37:00,000 --> 00:37:02,400
way to like

00:37:00,960 --> 00:37:04,400
the data setting is happening in the

00:37:02,400 --> 00:37:05,520
await the data is sending it's not

00:37:04,400 --> 00:37:07,839
happening with a loop

00:37:05,520 --> 00:37:08,640
uh sending it i hope that makes it look

00:37:07,839 --> 00:37:12,079
clearer

00:37:08,640 --> 00:37:13,280
um and nikhil asks um

00:37:12,079 --> 00:37:15,040
in one of the first example you primed

00:37:13,280 --> 00:37:17,040
the generator with send none which was

00:37:15,040 --> 00:37:18,960
in the walrus operating while oh

00:37:17,040 --> 00:37:20,240
why did the loop not stop then fantastic

00:37:18,960 --> 00:37:23,680
fantastic question

00:37:20,240 --> 00:37:27,200
okay right you would think that if i say

00:37:23,680 --> 00:37:28,400
um send none and i've got the walrus

00:37:27,200 --> 00:37:29,920
operator there

00:37:28,400 --> 00:37:32,160
that it's immediately going to exit

00:37:29,920 --> 00:37:35,760
except that that was being

00:37:32,160 --> 00:37:38,079
it was the first time so the first time

00:37:35,760 --> 00:37:39,280
like if i have a brand new spanking new

00:37:38,079 --> 00:37:41,760
baby generator

00:37:39,280 --> 00:37:42,560
co-routine and i send none to it that's

00:37:41,760 --> 00:37:44,720
just going to run

00:37:42,560 --> 00:37:46,800
through the first yield that first yield

00:37:44,720 --> 00:37:48,320
is on the right side of the assignment

00:37:46,800 --> 00:37:50,640
not on the left side

00:37:48,320 --> 00:37:52,320
so the right side is returned to us and

00:37:50,640 --> 00:37:53,760
then it's waiting for us then we send

00:37:52,320 --> 00:37:55,119
the second thing we send is then going

00:37:53,760 --> 00:37:57,280
to go into the assignment

00:37:55,119 --> 00:37:58,960
and go into the while so that first

00:37:57,280 --> 00:38:00,160
thing is actually never seen by the

00:37:58,960 --> 00:38:02,160
while

00:38:00,160 --> 00:38:03,280
um and is a weight syntax insurer for

00:38:02,160 --> 00:38:05,119
yield from

00:38:03,280 --> 00:38:06,960
i have not checked i don't believe it's

00:38:05,119 --> 00:38:08,079
syntactic sugar but i think it's super

00:38:06,960 --> 00:38:10,320
close

00:38:08,079 --> 00:38:11,599
um i don't think a weight uses yield

00:38:10,320 --> 00:38:12,560
from but i think like again they're

00:38:11,599 --> 00:38:15,200
overlapping

00:38:12,560 --> 00:38:15,599
things here that a weight basically says

00:38:15,200 --> 00:38:18,160
i

00:38:15,599 --> 00:38:19,119
am going to wait until i get data from

00:38:18,160 --> 00:38:21,280
such and such

00:38:19,119 --> 00:38:22,240
which is similar in some ways to yield

00:38:21,280 --> 00:38:24,160
right um

00:38:22,240 --> 00:38:25,440
yield from this for that pass-through i

00:38:24,160 --> 00:38:26,720
don't believe that a weight does any

00:38:25,440 --> 00:38:27,839
sort of pack-through stuff but i could

00:38:26,720 --> 00:38:31,040
be wrong

00:38:27,839 --> 00:38:33,040
um but like a weight and yield

00:38:31,040 --> 00:38:35,119
they have this whole new idea in python

00:38:33,040 --> 00:38:37,200
with async called a weightable

00:38:35,119 --> 00:38:38,960
and a weightable things are not

00:38:37,200 --> 00:38:40,480
generators per se they have to actually

00:38:38,960 --> 00:38:42,480
have a if i were correctly a dunder

00:38:40,480 --> 00:38:44,640
await method to find on them

00:38:42,480 --> 00:38:47,119
so again like there's overlap but

00:38:44,640 --> 00:38:48,160
they're not the same and and i am myself

00:38:47,119 --> 00:38:50,960
trying to sort of

00:38:48,160 --> 00:38:52,400
sort out uh how to describe exactly how

00:38:50,960 --> 00:38:53,520
they are different from one another

00:38:52,400 --> 00:38:54,640
i should add by the way that earlier

00:38:53,520 --> 00:38:56,560
today when i was trying to like just

00:38:54,640 --> 00:38:58,880
double check and read up on some things

00:38:56,560 --> 00:39:00,640
uh so of course one of my search results

00:38:58,880 --> 00:39:02,800
ended up being stack overflow

00:39:00,640 --> 00:39:04,320
and i said oh i see someone's talking

00:39:02,800 --> 00:39:05,520
about async and someone's talking about

00:39:04,320 --> 00:39:06,160
generators and then i realized they were

00:39:05,520 --> 00:39:08,400
talking about

00:39:06,160 --> 00:39:09,680
javascript so i really have been out of

00:39:08,400 --> 00:39:12,320
the javascript loop

00:39:09,680 --> 00:39:13,680
so to speak for many years um javascript

00:39:12,320 --> 00:39:16,480
event loop i guess you could say

00:39:13,680 --> 00:39:18,160
but i knew that javascript had obviously

00:39:16,480 --> 00:39:18,880
no js i knew that javascript had

00:39:18,160 --> 00:39:20,400
generators

00:39:18,880 --> 00:39:22,320
i did not realize that they had gone

00:39:20,400 --> 00:39:23,680
through anything similar to this in the

00:39:22,320 --> 00:39:26,079
python world

00:39:23,680 --> 00:39:27,599
so uh so it could vary will be that that

00:39:26,079 --> 00:39:29,119
there's a similar sort of overlap there

00:39:27,599 --> 00:39:31,520
i'm actually curious to learn more about

00:39:29,119 --> 00:39:31,520
this now

00:39:34,640 --> 00:39:37,839
any other questions that people might

00:39:35,920 --> 00:39:42,000
have

00:39:37,839 --> 00:39:43,680
personal problems you want to share and

00:39:42,000 --> 00:39:45,680
all right well i guess there are no more

00:39:43,680 --> 00:39:46,240
questions so if you do have questions

00:39:45,680 --> 00:39:47,359
after this

00:39:46,240 --> 00:39:49,280
or you think of them you just don't want

00:39:47,359 --> 00:39:51,200
to share them in public

00:39:49,280 --> 00:39:52,800
i'd love to hear from everyone here

00:39:51,200 --> 00:39:53,760
thank you so so much for attending my

00:39:52,800 --> 00:39:55,599
talk and i

00:39:53,760 --> 00:39:57,680
hope that you stay safe enjoy the rest

00:39:55,599 --> 00:39:58,640
the conference and i hope to be in touch

00:39:57,680 --> 00:40:01,040
and as i said

00:39:58,640 --> 00:40:03,440
even uh meet you in person at some

00:40:01,040 --> 00:40:11,839
python africa in the near future

00:40:03,440 --> 00:40:11,839
thanks everyone i really appreciate it

00:40:14,400 --> 00:40:16,480

YouTube URL: https://www.youtube.com/watch?v=tkoaeVS2zRQ


