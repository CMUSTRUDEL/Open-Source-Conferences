Title: Mainframe Performance on Commit - Ekaterina Tumanova & Petr Klomfar, Broadcom
Publication date: 2020-09-08
Playlist: Open Mainframe Summit 2020 - Virtual
Description: 
	Mainframe Performance on Commit - Ekaterina Tumanova & Petr Klomfar, Broadcom 

Nowadays digital transformation is picking up steam: the load on data servers increases, number of application changes being deployed to production is growing, while companies are adopting agile practices. At this pace of change it is essential to ensure that IT systems are undergoing sufficient amount of testing, especially performance checks to reduce risk of production downtime. Including performance testing into functional testing suits has been outlined as one of the key trends and challenges for 2020. Mainframe doesn't stand aside, vendors are developing open interfaces to make products part of the continuous integration and continuous delivery (CI/CD) process. This presentation provides an overview, example, and a live demonstration of a Mainframe pipeline with automatic detection of performance degradation and issue analysis using Zowe Plugins.
Captions: 
	00:00:00,080 --> 00:00:03,919
hello my name is iketirian domanova i'm

00:00:02,879 --> 00:00:06,560
from broadcom

00:00:03,919 --> 00:00:08,400
prague office and today together with my

00:00:06,560 --> 00:00:10,240
colleague peter clonfar

00:00:08,400 --> 00:00:13,040
we are going to make a dive into the

00:00:10,240 --> 00:00:15,200
topic of mainframe performance on commit

00:00:13,040 --> 00:00:17,119
and more specifically conducting

00:00:15,200 --> 00:00:19,520
automated performance testing

00:00:17,119 --> 00:00:20,960
in continuous integration and continuous

00:00:19,520 --> 00:00:23,920
delivery pipelines

00:00:20,960 --> 00:00:23,920
for mainframe

00:00:25,279 --> 00:00:29,359
before we jump into a conversation about

00:00:27,519 --> 00:00:31,599
automated performance testing

00:00:29,359 --> 00:00:33,760
i think it is essential that we talk

00:00:31,599 --> 00:00:36,800
about the current state of devops

00:00:33,760 --> 00:00:38,239
and how it applies to mainframe so where

00:00:36,800 --> 00:00:40,239
does this demand for

00:00:38,239 --> 00:00:41,840
automating everything into pipelines

00:00:40,239 --> 00:00:44,399
come from

00:00:41,840 --> 00:00:46,079
apart from being an industry standard

00:00:44,399 --> 00:00:48,800
for a non-mainframe world

00:00:46,079 --> 00:00:50,640
it clearly has additional value for

00:00:48,800 --> 00:00:53,280
development and testing teams

00:00:50,640 --> 00:00:54,640
on mainframe let's talk about some

00:00:53,280 --> 00:00:57,039
constraints

00:00:54,640 --> 00:00:57,680
we all know that traditional development

00:00:57,039 --> 00:01:01,199
tools

00:00:57,680 --> 00:01:03,760
for mainframe are not anymore providing

00:01:01,199 --> 00:01:06,159
the desired user experience for the new

00:01:03,760 --> 00:01:08,320
generation of developers

00:01:06,159 --> 00:01:11,360
specialists who are proficient with

00:01:08,320 --> 00:01:12,080
standard 3270 tooling are being harder

00:01:11,360 --> 00:01:15,759
harder

00:01:12,080 --> 00:01:18,080
to find in fact we all know that many

00:01:15,759 --> 00:01:19,360
highly skilled mainframers are preparing

00:01:18,080 --> 00:01:21,520
for retirement

00:01:19,360 --> 00:01:24,479
and people who are hired to replace them

00:01:21,520 --> 00:01:26,240
are coming from distributed background

00:01:24,479 --> 00:01:28,240
in order to become proficient with the

00:01:26,240 --> 00:01:29,520
tooling they have to go through a long

00:01:28,240 --> 00:01:31,920
learning curve

00:01:29,520 --> 00:01:33,680
in fact if we take an angle for example

00:01:31,920 --> 00:01:36,320
of the performance analysis

00:01:33,680 --> 00:01:37,360
mastering performance analysis using crs

00:01:36,320 --> 00:01:41,360
standard tooling

00:01:37,360 --> 00:01:42,479
can take even years but even if we take

00:01:41,360 --> 00:01:45,680
an example

00:01:42,479 --> 00:01:46,399
for example of eclipse fed eclipse

00:01:45,680 --> 00:01:49,360
clients

00:01:46,399 --> 00:01:50,000
have become sort of a standard for a

00:01:49,360 --> 00:01:53,439
part of

00:01:50,000 --> 00:01:54,159
mainframe tools but it already is

00:01:53,439 --> 00:01:56,479
considered

00:01:54,159 --> 00:01:58,560
primitive by the new generation who

00:01:56,479 --> 00:02:02,079
comes out of the universities

00:01:58,560 --> 00:02:03,360
they prefer open interfaces web ides

00:02:02,079 --> 00:02:05,439
quick scripting

00:02:03,360 --> 00:02:07,280
quick creation of testing environments

00:02:05,439 --> 00:02:10,800
something that they can quickly adjust

00:02:07,280 --> 00:02:10,800
to their particular needs

00:02:11,599 --> 00:02:15,760
that is why open source tools are so

00:02:14,000 --> 00:02:18,160
popular around the world

00:02:15,760 --> 00:02:19,760
devops concepts and open source tools

00:02:18,160 --> 00:02:22,640
are taking over the world

00:02:19,760 --> 00:02:24,480
hand in hand tools like git jenkins

00:02:22,640 --> 00:02:26,959
visual studio code

00:02:24,480 --> 00:02:29,120
open source tools are found everywhere

00:02:26,959 --> 00:02:32,560
according to gartner studies

00:02:29,120 --> 00:02:33,599
95 of the organizations leverage open

00:02:32,560 --> 00:02:36,560
source software

00:02:33,599 --> 00:02:37,920
in their mission critical i.t workloads

00:02:36,560 --> 00:02:41,519
whether they know about it

00:02:37,920 --> 00:02:44,319
or not and this is statistics from 2016

00:02:41,519 --> 00:02:46,160
so you can imagine that nowadays the

00:02:44,319 --> 00:02:48,720
numbers are even higher

00:02:46,160 --> 00:02:50,800
because every year open source software

00:02:48,720 --> 00:02:53,760
becomes a choice of more and more

00:02:50,800 --> 00:02:56,000
teams and mainframe doesn't stand aside

00:02:53,760 --> 00:02:56,000
here

00:02:56,239 --> 00:03:00,400
let's go back to our topic and talk

00:02:58,239 --> 00:03:00,720
about a bit more about the situation

00:03:00,400 --> 00:03:02,959
with

00:03:00,720 --> 00:03:04,640
performance testing today and why we

00:03:02,959 --> 00:03:07,120
speak about performance testing on

00:03:04,640 --> 00:03:09,200
mainframe being part of devops

00:03:07,120 --> 00:03:11,360
so what is the traditional approach to

00:03:09,200 --> 00:03:13,440
performance on mainframe

00:03:11,360 --> 00:03:14,879
from our experience talking to our

00:03:13,440 --> 00:03:17,599
customers we know

00:03:14,879 --> 00:03:18,000
that despite everyone understands that

00:03:17,599 --> 00:03:20,159
the more

00:03:18,000 --> 00:03:22,080
you test the fewer chances that the

00:03:20,159 --> 00:03:24,239
issue ends up in production

00:03:22,080 --> 00:03:25,760
not everyone actually does enough

00:03:24,239 --> 00:03:28,640
performance testing

00:03:25,760 --> 00:03:29,680
and even if they do it's quite often a

00:03:28,640 --> 00:03:32,799
pre-production

00:03:29,680 --> 00:03:35,120
integration level testing where it is

00:03:32,799 --> 00:03:37,760
hard to find out what is exactly the

00:03:35,120 --> 00:03:39,840
cause of the issue

00:03:37,760 --> 00:03:41,120
this leads to the situation when the

00:03:39,840 --> 00:03:43,680
issues are found

00:03:41,120 --> 00:03:45,760
in pre-production of production and

00:03:43,680 --> 00:03:46,000
highly skilled specialists are required

00:03:45,760 --> 00:03:47,920
to

00:03:46,000 --> 00:03:49,760
deal with them of course these

00:03:47,920 --> 00:03:51,519
specialists are hard to find

00:03:49,760 --> 00:03:54,400
and they are always quite busy with

00:03:51,519 --> 00:03:56,640
other things so it creates a bottleneck

00:03:54,400 --> 00:03:58,400
additional bottleneck occurs when these

00:03:56,640 --> 00:03:59,680
specialists have to communicate with

00:03:58,400 --> 00:04:02,159
development teams

00:03:59,680 --> 00:04:03,360
and advise them and discuss how to fix

00:04:02,159 --> 00:04:05,519
the problem

00:04:03,360 --> 00:04:07,599
but it doesn't have to be this way and

00:04:05,519 --> 00:04:08,239
many companies are starting to realize

00:04:07,599 --> 00:04:10,720
this

00:04:08,239 --> 00:04:11,439
especially when performance tools

00:04:10,720 --> 00:04:14,319
receive

00:04:11,439 --> 00:04:16,479
new open interfaces and performance

00:04:14,319 --> 00:04:17,280
testing becomes just one of the types of

00:04:16,479 --> 00:04:19,919
testing

00:04:17,280 --> 00:04:20,959
which can be automated scripted into the

00:04:19,919 --> 00:04:24,080
pipeline

00:04:20,959 --> 00:04:27,199
and performed by the development teams

00:04:24,080 --> 00:04:29,600
themselves themselves that would

00:04:27,199 --> 00:04:31,280
remove the bottlenecks which i mentioned

00:04:29,600 --> 00:04:33,840
and according to the studies

00:04:31,280 --> 00:04:35,520
reduce also the cost of defect

00:04:33,840 --> 00:04:39,600
resolution for the company

00:04:35,520 --> 00:04:39,600
by up to 64 times

00:04:41,440 --> 00:04:45,680
let's talk a bit more about personas who

00:04:44,080 --> 00:04:47,840
can make all this happen

00:04:45,680 --> 00:04:49,360
and here we are talking about devops

00:04:47,840 --> 00:04:50,960
engineers and architects

00:04:49,360 --> 00:04:52,720
who would include the performance

00:04:50,960 --> 00:04:55,520
testing into their automated

00:04:52,720 --> 00:04:57,840
development title pipeline and

00:04:55,520 --> 00:04:59,600
developers and qas who would actually

00:04:57,840 --> 00:05:01,520
perform this testing

00:04:59,600 --> 00:05:03,759
today's there are means to automatically

00:05:01,520 --> 00:05:05,840
detect performance degradation

00:05:03,759 --> 00:05:07,759
as part of automated pipeline and

00:05:05,840 --> 00:05:08,720
mainframe and i'll talk about this in a

00:05:07,759 --> 00:05:11,840
second

00:05:08,720 --> 00:05:13,680
and modern development solutions such as

00:05:11,840 --> 00:05:15,280
modern automation solutions such as

00:05:13,680 --> 00:05:17,280
jenkins allow you

00:05:15,280 --> 00:05:19,759
based on this detection to immediately

00:05:17,280 --> 00:05:22,479
identify development teams

00:05:19,759 --> 00:05:23,280
furthermore mainframe analysis tools

00:05:22,479 --> 00:05:25,919
nowadays

00:05:23,280 --> 00:05:27,840
also receive open interfaces like for

00:05:25,919 --> 00:05:30,240
example zoe command line

00:05:27,840 --> 00:05:31,520
and this enables developers to not only

00:05:30,240 --> 00:05:34,240
be notified

00:05:31,520 --> 00:05:35,039
but also allows them to do performance

00:05:34,240 --> 00:05:38,080
analysis

00:05:35,039 --> 00:05:40,479
using simple familiar frameworks and

00:05:38,080 --> 00:05:42,720
interfaces

00:05:40,479 --> 00:05:44,240
so let's think what happens if you don't

00:05:42,720 --> 00:05:47,440
do performance testing

00:05:44,240 --> 00:05:47,919
such case as i said mainframe teams wait

00:05:47,440 --> 00:05:51,039
weeks

00:05:47,919 --> 00:05:53,759
before finding the performance issue and

00:05:51,039 --> 00:05:55,680
it not only has business impact but also

00:05:53,759 --> 00:05:57,919
requires a lot of time from both

00:05:55,680 --> 00:05:58,880
production and development specialists

00:05:57,919 --> 00:06:00,960
moreover

00:05:58,880 --> 00:06:02,720
there's actually higher chances that the

00:06:00,960 --> 00:06:03,440
issue will be introduced in the first

00:06:02,720 --> 00:06:05,520
place

00:06:03,440 --> 00:06:07,840
because developer doesn't take

00:06:05,520 --> 00:06:12,000
performance of the code into account

00:06:07,840 --> 00:06:14,720
when he she or he is making a change

00:06:12,000 --> 00:06:15,199
they wait till it is communicated from

00:06:14,720 --> 00:06:18,319
their

00:06:15,199 --> 00:06:21,039
system management team this is not a

00:06:18,319 --> 00:06:23,520
very effective effective practice

00:06:21,039 --> 00:06:25,120
and in fact experts suggest that you

00:06:23,520 --> 00:06:27,919
test performance early

00:06:25,120 --> 00:06:29,120
and the performance is part of the

00:06:27,919 --> 00:06:33,360
development team's

00:06:29,120 --> 00:06:35,280
mindset in such case not only there are

00:06:33,360 --> 00:06:36,960
fewer chances that the issue will be

00:06:35,280 --> 00:06:38,400
introduced but

00:06:36,960 --> 00:06:40,960
if the problem occurs it is

00:06:38,400 --> 00:06:41,600
automatically found and easily addressed

00:06:40,960 --> 00:06:43,600
because

00:06:41,600 --> 00:06:44,720
it is easier to trace back to the

00:06:43,600 --> 00:06:48,400
particular code

00:06:44,720 --> 00:06:50,160
change which introduced it

00:06:48,400 --> 00:06:52,960
let's look at the example of how you

00:06:50,160 --> 00:06:52,960
could achieve it

00:06:53,360 --> 00:06:56,639
see a mainframe application tuner cmat

00:06:56,240 --> 00:06:59,599
from

00:06:56,639 --> 00:07:00,560
broadcom it is a performance sampling

00:06:59,599 --> 00:07:02,319
tool

00:07:00,560 --> 00:07:04,560
which has extensive automation

00:07:02,319 --> 00:07:06,960
capabilities

00:07:04,560 --> 00:07:08,479
it is used both in production for

00:07:06,960 --> 00:07:11,599
performance monitoring and in

00:07:08,479 --> 00:07:14,639
pre-production for performance testing

00:07:11,599 --> 00:07:17,599
you also probably know heard about

00:07:14,639 --> 00:07:20,000
zoe an open source framework which

00:07:17,599 --> 00:07:20,960
allows you to work with zos from off

00:07:20,000 --> 00:07:24,800
platform

00:07:20,960 --> 00:07:28,720
having cloud-like experience so now

00:07:24,800 --> 00:07:32,080
cmat provides two zoe cli extensions

00:07:28,720 --> 00:07:34,720
command line plugins see i'm at here

00:07:32,080 --> 00:07:36,000
cm at detect here on the left which

00:07:34,720 --> 00:07:40,160
enables

00:07:36,000 --> 00:07:42,840
devops architects like ravi to include

00:07:40,160 --> 00:07:44,000
detection of batch code performance

00:07:42,840 --> 00:07:47,360
degradation

00:07:44,000 --> 00:07:48,400
into the pipeline using cm at detect

00:07:47,360 --> 00:07:50,720
ravi can

00:07:48,400 --> 00:07:53,039
after each commit automatically check

00:07:50,720 --> 00:07:55,840
the performance metrics of the code

00:07:53,039 --> 00:07:58,240
and send them to the development team

00:07:55,840 --> 00:08:01,039
and also notify development team

00:07:58,240 --> 00:08:02,720
if there is any issue if the baseline

00:08:01,039 --> 00:08:07,360
for performance metrics was

00:08:02,720 --> 00:08:10,720
violated after the last change

00:08:07,360 --> 00:08:14,080
so he now developer such as michelle

00:08:10,720 --> 00:08:14,960
here on the right is immediately

00:08:14,080 --> 00:08:17,280
notified

00:08:14,960 --> 00:08:19,440
whenever her commit has drastically

00:08:17,280 --> 00:08:22,479
changed the code performance

00:08:19,440 --> 00:08:25,039
furthermore cmd provides another

00:08:22,479 --> 00:08:26,240
zoe plugin specifically for michelle so

00:08:25,039 --> 00:08:29,680
that she can

00:08:26,240 --> 00:08:33,039
not only be notified of the issue but

00:08:29,680 --> 00:08:33,839
immediately start analyzing the

00:08:33,039 --> 00:08:36,479
application

00:08:33,839 --> 00:08:37,760
so cmd analyze provides a set of

00:08:36,479 --> 00:08:40,159
commands

00:08:37,760 --> 00:08:41,519
and allowing michelle to access detailed

00:08:40,159 --> 00:08:44,240
measurement analysis

00:08:41,519 --> 00:08:44,959
through the command line she can use it

00:08:44,240 --> 00:08:48,320
in her

00:08:44,959 --> 00:08:48,880
for example ide terminal the great thing

00:08:48,320 --> 00:08:51,600
about

00:08:48,880 --> 00:08:52,720
these two plugins is that they actually

00:08:51,600 --> 00:08:56,720
work together

00:08:52,720 --> 00:08:59,839
so whenever cmi detect reports an issue

00:08:56,720 --> 00:09:00,320
cm analyze already has measurement data

00:08:59,839 --> 00:09:04,640
ready

00:09:00,320 --> 00:09:07,680
because the underlying component

00:09:04,640 --> 00:09:08,800
requests a measurement for every alerted

00:09:07,680 --> 00:09:11,120
issue

00:09:08,800 --> 00:09:13,440
so michelle doesn't have actually to

00:09:11,120 --> 00:09:16,480
rerun the test and reproduce

00:09:13,440 --> 00:09:19,760
she can already jump to the

00:09:16,480 --> 00:09:20,880
performance analysis because she has the

00:09:19,760 --> 00:09:24,080
data from the

00:09:20,880 --> 00:09:26,800
time each one issue occurred

00:09:24,080 --> 00:09:27,760
so here i would like to jump to the most

00:09:26,800 --> 00:09:30,080
interesting part

00:09:27,760 --> 00:09:31,600
and i would pass over the screen to

00:09:30,080 --> 00:09:34,640
peder who will show

00:09:31,600 --> 00:09:36,959
us a live demonstration of how

00:09:34,640 --> 00:09:39,040
such pipeline with performance testing

00:09:36,959 --> 00:09:43,200
may look like

00:09:39,040 --> 00:09:43,200
and better this is all yours

00:09:46,080 --> 00:09:49,600
good morning and good afternoon

00:09:47,440 --> 00:09:51,519
everybody my name is peter clonfar i am

00:09:49,600 --> 00:09:52,160
product owner for cmainframe application

00:09:51,519 --> 00:09:53,360
tuner

00:09:52,160 --> 00:09:55,680
thank you kate for handing the

00:09:53,360 --> 00:09:56,959
presentation over to me let me walk you

00:09:55,680 --> 00:09:59,040
through our implementation of

00:09:56,959 --> 00:10:01,040
functionality of performance on commit

00:09:59,040 --> 00:10:03,360
so here is the diagram before we jump to

00:10:01,040 --> 00:10:07,120
the demo to the actual demo here is the

00:10:03,360 --> 00:10:08,640
actual diagram of our implementation

00:10:07,120 --> 00:10:10,399
and we will be focusing from the

00:10:08,640 --> 00:10:11,600
perspective of michelle who's the modern

00:10:10,399 --> 00:10:14,320
developer

00:10:11,600 --> 00:10:15,839
she's going to update the code in id of

00:10:14,320 --> 00:10:16,880
her choice in our case it will be visual

00:10:15,839 --> 00:10:19,200
studio code

00:10:16,880 --> 00:10:21,519
she will save it she will stage it she

00:10:19,200 --> 00:10:23,279
will commit it to her github repository

00:10:21,519 --> 00:10:25,200
and the change from the github to the

00:10:23,279 --> 00:10:26,640
backend to the ender will be propagated

00:10:25,200 --> 00:10:28,560
through integration with c

00:10:26,640 --> 00:10:31,279
and never a source code manager

00:10:28,560 --> 00:10:35,519
throughout an enterprise git bridge

00:10:31,279 --> 00:10:37,839
solution on the endeavor when the change

00:10:35,519 --> 00:10:39,600
appears in the source code manager we

00:10:37,839 --> 00:10:41,440
have a webhook server listening to

00:10:39,600 --> 00:10:43,839
update action but it can be any

00:10:41,440 --> 00:10:44,640
uh generate in place it can be staging

00:10:43,839 --> 00:10:46,959
from

00:10:44,640 --> 00:10:48,880
dev to the qa environment but in our

00:10:46,959 --> 00:10:50,720
case it's update action which triggers

00:10:48,880 --> 00:10:52,640
our ci cd pipeline

00:10:50,720 --> 00:10:55,120
that is being orchestrated by jenkins

00:10:52,640 --> 00:10:57,920
and that is where cmed detect as part of

00:10:55,120 --> 00:11:00,399
performance on commit comes in place and

00:10:57,920 --> 00:11:02,079
collects the performance matrixes

00:11:00,399 --> 00:11:03,920
i will walk you through details in the

00:11:02,079 --> 00:11:04,720
actual pipeline but at this stage michel

00:11:03,920 --> 00:11:07,600
can already

00:11:04,720 --> 00:11:09,120
use get performance commands or get

00:11:07,600 --> 00:11:11,519
alert commands

00:11:09,120 --> 00:11:12,800
to get some matrixes directly from the

00:11:11,519 --> 00:11:14,240
cli

00:11:12,800 --> 00:11:16,160
but to make it easier for her we

00:11:14,240 --> 00:11:17,920
actually provide emails so performance

00:11:16,160 --> 00:11:18,720
reports will be generated and sent to

00:11:17,920 --> 00:11:20,320
the michelle

00:11:18,720 --> 00:11:21,839
and in our case we will focus on the

00:11:20,320 --> 00:11:23,279
alert in the

00:11:21,839 --> 00:11:25,440
dreadful situation that the performance

00:11:23,279 --> 00:11:27,680
degradation appeared

00:11:25,440 --> 00:11:29,440
she will receive similar email like this

00:11:27,680 --> 00:11:32,399
let me walk you through in a minute

00:11:29,440 --> 00:11:33,920
during the demonstration and this is

00:11:32,399 --> 00:11:36,079
also when

00:11:33,920 --> 00:11:38,000
the alert is generated where same

00:11:36,079 --> 00:11:38,320
analyze component is being kicked off

00:11:38,000 --> 00:11:40,800
and

00:11:38,320 --> 00:11:41,760
automatic measurement of the performance

00:11:40,800 --> 00:11:44,720
degradation

00:11:41,760 --> 00:11:45,440
or the program under test is being uh

00:11:44,720 --> 00:11:47,440
done

00:11:45,440 --> 00:11:49,279
so she can then drill down into the

00:11:47,440 --> 00:11:51,040
details using the cli commands

00:11:49,279 --> 00:11:53,760
respective to cm and frame application

00:11:51,040 --> 00:11:55,839
tuner bring up for example the overview

00:11:53,760 --> 00:11:57,519
of the program uh take a look on the

00:11:55,839 --> 00:11:59,760
history of the measurements

00:11:57,519 --> 00:12:02,320
or she can drill down into the code view

00:11:59,760 --> 00:12:04,079
and see sex section and

00:12:02,320 --> 00:12:06,560
inspect what is the issue and what's the

00:12:04,079 --> 00:12:09,680
culprit without any further ado let me

00:12:06,560 --> 00:12:11,440
switch to the visual studio code

00:12:09,680 --> 00:12:13,440
here we are and i will make some change

00:12:11,440 --> 00:12:16,720
on behalf of michelle

00:12:13,440 --> 00:12:19,760
so for example i will change this uh

00:12:16,720 --> 00:12:22,959
subscript in the main line i will

00:12:19,760 --> 00:12:28,160
save the change as i said

00:12:22,959 --> 00:12:28,160
i will then stage the change

00:12:28,320 --> 00:12:33,120
when the stage is staged uh i will

00:12:31,519 --> 00:12:34,800
commit it to a github

00:12:33,120 --> 00:12:38,240
with the demo command so we are

00:12:34,800 --> 00:12:40,880
transparent here

00:12:38,240 --> 00:12:42,000
and whenever i am ready i will push into

00:12:40,880 --> 00:12:44,000
the repository

00:12:42,000 --> 00:12:46,000
uh this is where our pipeline will be

00:12:44,000 --> 00:12:50,959
triggered so i can see

00:12:46,000 --> 00:12:53,279
oh passphrase because security first

00:12:50,959 --> 00:12:54,160
okay i can see that uh changes has been

00:12:53,279 --> 00:12:57,760
uh uh

00:12:54,160 --> 00:13:00,320
successfully pushed

00:12:57,760 --> 00:13:02,079
well done uh now let's switch to our ci

00:13:00,320 --> 00:13:02,959
cd pipeline i should see pipeline

00:13:02,079 --> 00:13:06,320
kicking up in

00:13:02,959 --> 00:13:08,800
any second um

00:13:06,320 --> 00:13:10,880
yes there is a pending pipeline uh

00:13:08,800 --> 00:13:12,079
whenever it kicks off i will open it in

00:13:10,880 --> 00:13:16,800
the blue ocean

00:13:12,079 --> 00:13:18,959
because it's uh easier to observe

00:13:16,800 --> 00:13:21,040
so when i'm in the blue ocean this is

00:13:18,959 --> 00:13:24,320
how the internals of the pipeline looks

00:13:21,040 --> 00:13:25,760
on the background uh autogen job is

00:13:24,320 --> 00:13:27,839
being kicked off to generate

00:13:25,760 --> 00:13:28,880
the job in the source code manager then

00:13:27,839 --> 00:13:30,560
the actual

00:13:28,880 --> 00:13:32,639
application or the job is being

00:13:30,560 --> 00:13:35,440
submitted to the mainframe processing

00:13:32,639 --> 00:13:37,519
throughout that pma as a component of

00:13:35,440 --> 00:13:39,760
cmtec

00:13:37,519 --> 00:13:42,639
collects the smf records and compares

00:13:39,760 --> 00:13:44,959
them with the ksds clusters

00:13:42,639 --> 00:13:46,560
uh for jobs and alerts for comparison

00:13:44,959 --> 00:13:48,240
and then the summary report at the end

00:13:46,560 --> 00:13:50,639
is being sent out

00:13:48,240 --> 00:13:52,160
when i'm looking at the email uh what's

00:13:50,639 --> 00:13:54,320
michel is gonna be receiving

00:13:52,160 --> 00:13:55,360
within the normal normal range is when

00:13:54,320 --> 00:13:58,000
everything is uh

00:13:55,360 --> 00:13:58,560
fine and we have a bright blue skies we

00:13:58,000 --> 00:14:01,040
have these

00:13:58,560 --> 00:14:03,199
uh tiles these styles are cpu deviation

00:14:01,040 --> 00:14:06,160
observation xcp deviation and

00:14:03,199 --> 00:14:07,839
service unit deviation they basically

00:14:06,160 --> 00:14:09,279
can have some variations dependent on

00:14:07,839 --> 00:14:11,600
the load of the machine where the

00:14:09,279 --> 00:14:12,800
job is submitted also in the email we

00:14:11,600 --> 00:14:15,360
provide

00:14:12,800 --> 00:14:17,120
the performance as details for average

00:14:15,360 --> 00:14:19,839
values for the baseline

00:14:17,120 --> 00:14:21,600
or for the current versus previous run

00:14:19,839 --> 00:14:24,160
and i should receive the email

00:14:21,600 --> 00:14:25,279
any second let me double check the

00:14:24,160 --> 00:14:27,519
jenkins pipeline

00:14:25,279 --> 00:14:29,199
oh there were there it was so let me

00:14:27,519 --> 00:14:30,800
show it and as you can see

00:14:29,199 --> 00:14:32,720
uh the performance degradation was

00:14:30,800 --> 00:14:33,519
significant enough so have we have

00:14:32,720 --> 00:14:36,320
received an

00:14:33,519 --> 00:14:38,079
alert status the alert status itself uh

00:14:36,320 --> 00:14:41,360
will be sub um

00:14:38,079 --> 00:14:43,760
similar uh with the red styles and it's

00:14:41,360 --> 00:14:46,800
gonna be providing the zoe commands for

00:14:43,760 --> 00:14:50,800
michel to easily drill down so we will

00:14:46,800 --> 00:14:53,199
jump directly to for example delay view

00:14:50,800 --> 00:14:54,480
and if i just copy the zoe command go

00:14:53,199 --> 00:14:58,000
back to the terminal

00:14:54,480 --> 00:15:00,240
of my visual studio code and i'll

00:14:58,000 --> 00:15:01,600
paste it i should be able to bring out

00:15:00,240 --> 00:15:04,720
delay view of the

00:15:01,600 --> 00:15:06,800
uh cmf measurement yes there it is so i

00:15:04,720 --> 00:15:09,920
can see that the program active uh

00:15:06,800 --> 00:15:11,680
was 45 of the whole run of the

00:15:09,920 --> 00:15:14,079
application so that's the one that i

00:15:11,680 --> 00:15:17,519
want to inspect the most

00:15:14,079 --> 00:15:19,199
let me just uh do x advanced command zoe

00:15:17,519 --> 00:15:20,560
mod monitor delay view address is for

00:15:19,199 --> 00:15:22,399
this specific profile

00:15:20,560 --> 00:15:24,240
for the major and minor category of the

00:15:22,399 --> 00:15:27,040
program activity

00:15:24,240 --> 00:15:28,720
if i press enter i should receive uh the

00:15:27,040 --> 00:15:31,440
more granular information

00:15:28,720 --> 00:15:32,320
and when i take a look here um it's a

00:15:31,440 --> 00:15:34,079
covalent program

00:15:32,320 --> 00:15:36,079
uh the statement in the cobol program

00:15:34,079 --> 00:15:37,600
can spun through the multiple offsets

00:15:36,079 --> 00:15:40,399
so let's pick the one which is the

00:15:37,600 --> 00:15:43,759
heaviest that's uh

00:15:40,399 --> 00:15:45,120
nine delta two and uh i would be

00:15:43,759 --> 00:15:48,079
interested actually to see

00:15:45,120 --> 00:15:48,480
within the within the listing so excuse

00:15:48,079 --> 00:15:52,079
me

00:15:48,480 --> 00:15:52,480
i can uh also bring up the listing from

00:15:52,079 --> 00:15:56,000
the

00:15:52,480 --> 00:15:57,839
another integration from endeavor

00:15:56,000 --> 00:15:59,279
so the listing should be coming in a

00:15:57,839 --> 00:16:02,560
second

00:15:59,279 --> 00:16:02,880
there it is and when i take a look into

00:16:02,560 --> 00:16:05,920
the

00:16:02,880 --> 00:16:09,600
assembler code respectively let's

00:16:05,920 --> 00:16:11,839
search for that uh nine delta two

00:16:09,600 --> 00:16:13,199
uh so the niner that was actually part

00:16:11,839 --> 00:16:16,480
of the instruction at

00:16:13,199 --> 00:16:18,959
it was up in this case but it was uh

00:16:16,480 --> 00:16:20,560
it was at instruction as i can see and

00:16:18,959 --> 00:16:22,720
that instruction was part of the

00:16:20,560 --> 00:16:25,120
subscript minus 100

00:16:22,720 --> 00:16:28,000
label so if i scroll up to the actual

00:16:25,120 --> 00:16:31,120
source code from the listing

00:16:28,000 --> 00:16:32,639
i am looking for subscript -2 and this

00:16:31,120 --> 00:16:33,199
is exactly the perform that i have

00:16:32,639 --> 00:16:36,639
changed

00:16:33,199 --> 00:16:38,560
for 12 000 times which is the main loop

00:16:36,639 --> 00:16:40,160
so this is what caused the degradation

00:16:38,560 --> 00:16:41,279
and this is basically the demonstration

00:16:40,160 --> 00:16:44,480
how user can

00:16:41,279 --> 00:16:47,440
uh bring up and utilize the value of the

00:16:44,480 --> 00:16:49,519
performance on commit functionality

00:16:47,440 --> 00:16:52,560
let me get back for my powerpoint

00:16:49,519 --> 00:16:52,560
presentation still

00:16:53,360 --> 00:16:57,680
because if you happen to be a user of

00:16:56,800 --> 00:16:59,600
cmt

00:16:57,680 --> 00:17:01,360
you can utilize these links to download

00:16:59,600 --> 00:17:04,079
these cli

00:17:01,360 --> 00:17:05,280
integrations for cma detect and analyze

00:17:04,079 --> 00:17:08,720
straightforward

00:17:05,280 --> 00:17:09,120
uh if you happen to be our customer or

00:17:08,720 --> 00:17:11,120
even

00:17:09,120 --> 00:17:12,880
you know observer from outside we will

00:17:11,120 --> 00:17:14,559
be very happy to hear from you your

00:17:12,880 --> 00:17:18,160
devops experience your

00:17:14,559 --> 00:17:19,839
stories from the performance tuning and

00:17:18,160 --> 00:17:21,919
you can reach out to us we will we will

00:17:19,839 --> 00:17:23,439
gladly hear what you have to say and

00:17:21,919 --> 00:17:25,839
please reach out to me as a product

00:17:23,439 --> 00:17:26,400
owner or to cate as a product manager we

00:17:25,839 --> 00:17:29,679
will

00:17:26,400 --> 00:17:31,520
be really happy to hear also as a

00:17:29,679 --> 00:17:34,480
reminder

00:17:31,520 --> 00:17:35,600
broadcom is a partner on your devops

00:17:34,480 --> 00:17:38,000
journey

00:17:35,600 --> 00:17:39,919
so we realized that your devops

00:17:38,000 --> 00:17:42,960
transformation can be challenging and

00:17:39,919 --> 00:17:43,840
none of those or there are now no two

00:17:42,960 --> 00:17:47,600
alike

00:17:43,840 --> 00:17:48,160
i should say but we are keen to work

00:17:47,600 --> 00:17:50,320
with you

00:17:48,160 --> 00:17:52,080
and help you to peel off the layers and

00:17:50,320 --> 00:17:53,840
to help you to

00:17:52,080 --> 00:17:55,120
disassemble the impediments that you may

00:17:53,840 --> 00:17:58,400
have on the road

00:17:55,120 --> 00:18:01,679
and to demonstrate our commitment and

00:17:58,400 --> 00:18:03,679
partnership offerings we offer these

00:18:01,679 --> 00:18:06,080
items that you can see on the screen for

00:18:03,679 --> 00:18:07,679
our customers free of charge

00:18:06,080 --> 00:18:09,360
so we would be able to help you with the

00:18:07,679 --> 00:18:10,080
design thinking with the environment

00:18:09,360 --> 00:18:13,440
preparation

00:18:10,080 --> 00:18:16,160
hands-on workshop or proof even

00:18:13,440 --> 00:18:16,960
concepts so be sure to reach out to us

00:18:16,160 --> 00:18:20,160
we will

00:18:16,960 --> 00:18:22,559
we'll be happy and with that

00:18:20,160 --> 00:18:23,520
basically thank you for your attention

00:18:22,559 --> 00:18:26,000
and for your time

00:18:23,520 --> 00:18:27,360
being with us through the demo and

00:18:26,000 --> 00:18:29,919
should you have

00:18:27,360 --> 00:18:33,280
any feedback or any questions please

00:18:29,919 --> 00:18:33,280

YouTube URL: https://www.youtube.com/watch?v=V55O0Hcm90I


