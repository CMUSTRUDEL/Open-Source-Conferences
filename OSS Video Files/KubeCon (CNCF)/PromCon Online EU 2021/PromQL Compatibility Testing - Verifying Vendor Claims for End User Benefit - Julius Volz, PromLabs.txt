Title: PromQL Compatibility Testing - Verifying Vendor Claims for End User Benefit - Julius Volz, PromLabs
Publication date: 2021-05-03
Playlist: PromCon Online EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

PromQL Compatibility Testing - Verifying Vendor Claims for End User Benefit - Julius Volz, PromLabs

Prometheus' query language PromQL is one of the most important interfaces in the Prometheus ecosystem. Organizations rely on it to build their dashboards, critical alerting, and automation. With Prometheus becoming more popular, we are seeing more and more PromQL implementations outside of Prometheus itself, both in open-source projects and in hosted monitoring providers. While this is great, not all implementations that claim to be PromQL-compatible actually implement PromQL correctly. To avoid user confusion, ecosystem fragmentation, and vendor lock-in, we want to encourage fully compatible implementations and at the same time increase transparency around the actual compatibility of different solutions.

In this talk, Prometheus co-founder Julius Volz will present an open-source PromQL compliance testing suite that can shine a light on the compatibility situation. He will also outline test results of actual vendor PromQL implementations, dive into some of the encountered behavioral differences, and give recommendations for anyone wanting to implement PromQL in their own product or service.
Captions: 
	00:00:00,080 --> 00:00:05,600
all right hi everyone i'm julius i'm one

00:00:03,280 --> 00:00:06,000
of the co-founders of prometheus and i'm

00:00:05,600 --> 00:00:09,120
also

00:00:06,000 --> 00:00:10,559
the founder of prom labs my company with

00:00:09,120 --> 00:00:12,799
prom labs i help

00:00:10,559 --> 00:00:14,880
other companies use prometheus get the

00:00:12,799 --> 00:00:15,759
most out of their prometheus build stuff

00:00:14,880 --> 00:00:19,119
around it

00:00:15,759 --> 00:00:20,800
so i do consulting training products

00:00:19,119 --> 00:00:23,439
like a training website

00:00:20,800 --> 00:00:25,519
or live trainings but also a prom ql

00:00:23,439 --> 00:00:27,279
query builder called promlance

00:00:25,519 --> 00:00:29,599
so if you're interested in any of that

00:00:27,279 --> 00:00:31,519
check out promlabs.com

00:00:29,599 --> 00:00:33,680
but today i'm going to talk about the

00:00:31,519 --> 00:00:35,760
prom ql compatibility efforts

00:00:33,680 --> 00:00:36,719
that i've been working on since last

00:00:35,760 --> 00:00:39,200
year

00:00:36,719 --> 00:00:40,960
so this is also mostly going to be an

00:00:39,200 --> 00:00:44,239
actual prometheus open source

00:00:40,960 --> 00:00:46,719
talk so prometheus

00:00:44,239 --> 00:00:49,360
has become really successful it's become

00:00:46,719 --> 00:00:52,079
the de facto standard for metrics based

00:00:49,360 --> 00:00:53,440
open source monitoring this is really

00:00:52,079 --> 00:00:56,079
amazing

00:00:53,440 --> 00:00:56,879
and has already also brought a lot of

00:00:56,079 --> 00:00:58,640
other players

00:00:56,879 --> 00:01:01,199
onto the playing field who want to have

00:00:58,640 --> 00:01:03,760
a piece of this who want to interoperate

00:01:01,199 --> 00:01:05,040
who you know want to build a business

00:01:03,760 --> 00:01:06,960
around it or just

00:01:05,040 --> 00:01:09,119
you know have a different alternative

00:01:06,960 --> 00:01:11,840
that is compatible

00:01:09,119 --> 00:01:13,920
in this diagram i'm showing a number of

00:01:11,840 --> 00:01:17,040
different open source projects and

00:01:13,920 --> 00:01:19,680
hosted services and other projects

00:01:17,040 --> 00:01:20,960
that promises can send data to this is

00:01:19,680 --> 00:01:24,240
not an exclusive list

00:01:20,960 --> 00:01:28,240
just a number of examples

00:01:24,240 --> 00:01:30,240
and in general this is great because

00:01:28,240 --> 00:01:32,479
you know the the standard prometheus

00:01:30,240 --> 00:01:34,560
server might not be the best for

00:01:32,479 --> 00:01:37,680
everyone for example for someone who

00:01:34,560 --> 00:01:40,079
wants a truly horizontally scalable

00:01:37,680 --> 00:01:41,840
alternative cortex might be better or

00:01:40,079 --> 00:01:43,840
for someone who doesn't want to run

00:01:41,840 --> 00:01:45,439
their own storage systems at all a

00:01:43,840 --> 00:01:47,680
cloud-based

00:01:45,439 --> 00:01:49,040
service might be very attractive and so

00:01:47,680 --> 00:01:51,280
on and so on

00:01:49,040 --> 00:01:52,079
so alternatives really offer different

00:01:51,280 --> 00:01:54,000
trade-offs

00:01:52,079 --> 00:01:55,600
for the different use cases of different

00:01:54,000 --> 00:01:58,640
people

00:01:55,600 --> 00:02:01,119
in general the interoperability then

00:01:58,640 --> 00:02:03,680
also gives people a larger ecosystem of

00:02:01,119 --> 00:02:05,280
puzzle pieces to put together in ways

00:02:03,680 --> 00:02:08,399
that they see fit

00:02:05,280 --> 00:02:10,399
and as long as this competition stays

00:02:08,399 --> 00:02:12,319
healthy and open

00:02:10,399 --> 00:02:14,560
we will get better monitoring for

00:02:12,319 --> 00:02:16,560
everyone

00:02:14,560 --> 00:02:18,000
but at the same time we have to be

00:02:16,560 --> 00:02:20,400
vigilant and

00:02:18,000 --> 00:02:21,520
be clear about compatibility

00:02:20,400 --> 00:02:23,280
expectations

00:02:21,520 --> 00:02:24,640
and actually delivery of those

00:02:23,280 --> 00:02:28,000
expectations

00:02:24,640 --> 00:02:30,640
so if someone uh does not

00:02:28,000 --> 00:02:31,440
implement one of our interfaces

00:02:30,640 --> 00:02:33,920
correctly

00:02:31,440 --> 00:02:36,239
but says they do so you know they might

00:02:33,920 --> 00:02:38,000
be misleading users or surprising users

00:02:36,239 --> 00:02:39,760
when they least expect it

00:02:38,000 --> 00:02:41,680
in the worst case an alert that you

00:02:39,760 --> 00:02:43,280
don't get at night right that would be

00:02:41,680 --> 00:02:47,200
bad

00:02:43,280 --> 00:02:48,480
or you might just be then locked into

00:02:47,200 --> 00:02:50,720
their specific

00:02:48,480 --> 00:02:52,000
behavior in feature set which is no

00:02:50,720 --> 00:02:54,239
longer compatible

00:02:52,000 --> 00:02:56,879
with the rest of the ecosystem so you

00:02:54,239 --> 00:02:59,360
can't easily switch anymore

00:02:56,879 --> 00:03:00,319
and ultimately this leads to ecosystem

00:02:59,360 --> 00:03:02,640
fragmentation

00:03:00,319 --> 00:03:03,760
making the ecosystem weaker so we want

00:03:02,640 --> 00:03:07,360
to really encourage

00:03:03,760 --> 00:03:08,400
people to be both clear around their

00:03:07,360 --> 00:03:10,239
communication

00:03:08,400 --> 00:03:11,840
when it comes to compatibility and to

00:03:10,239 --> 00:03:14,159
also implement

00:03:11,840 --> 00:03:16,640
solutions to be compatible as compatible

00:03:14,159 --> 00:03:19,040
as possible

00:03:16,640 --> 00:03:20,879
so originally when we released

00:03:19,040 --> 00:03:23,519
prometheus we focused a lot

00:03:20,879 --> 00:03:24,400
on the implementation of the different

00:03:23,519 --> 00:03:26,400
components

00:03:24,400 --> 00:03:28,879
internally like how does the prometheus

00:03:26,400 --> 00:03:31,120
server work internally what does it do

00:03:28,879 --> 00:03:32,799
um what does it target internally how

00:03:31,120 --> 00:03:34,799
does it track metrics

00:03:32,799 --> 00:03:36,159
how does alert manager dispatch alerts

00:03:34,799 --> 00:03:38,239
and so on but

00:03:36,159 --> 00:03:39,360
of course all these different boxes the

00:03:38,239 --> 00:03:42,720
components also

00:03:39,360 --> 00:03:43,280
talk to each other and especially now

00:03:42,720 --> 00:03:46,000
that

00:03:43,280 --> 00:03:47,040
people came in and said okay we are

00:03:46,000 --> 00:03:49,280
going to create

00:03:47,040 --> 00:03:51,760
prometheus compatible solutions or that

00:03:49,280 --> 00:03:53,040
interoperate with prometheus in one way

00:03:51,760 --> 00:03:56,239
or another

00:03:53,040 --> 00:03:58,959
the lines between these boxes the arrows

00:03:56,239 --> 00:04:00,000
have become more important the

00:03:58,959 --> 00:04:01,599
exposition format

00:04:00,000 --> 00:04:04,000
is a pretty prominent one for

00:04:01,599 --> 00:04:05,120
transferring metrics from a target to

00:04:04,000 --> 00:04:07,120
prometheus

00:04:05,120 --> 00:04:09,439
so you know that is currently being

00:04:07,120 --> 00:04:12,879
standardized or has been standardized

00:04:09,439 --> 00:04:15,200
as open metrics which is the standard

00:04:12,879 --> 00:04:16,079
for sending metrics to prometheus that

00:04:15,200 --> 00:04:19,840
has its own

00:04:16,079 --> 00:04:22,320
test suite and spec there is

00:04:19,840 --> 00:04:24,960
the remote write protocol which is being

00:04:22,320 --> 00:04:26,639
used to send data from prometheus to

00:04:24,960 --> 00:04:28,080
some remote storage system which could

00:04:26,639 --> 00:04:29,600
be hosted or

00:04:28,080 --> 00:04:31,199
you know another open source thing that

00:04:29,600 --> 00:04:33,840
you run yourself

00:04:31,199 --> 00:04:35,440
um there's the alerting protocol between

00:04:33,840 --> 00:04:37,680
prometheus and alert manager

00:04:35,440 --> 00:04:39,520
we haven't really seen that being

00:04:37,680 --> 00:04:42,560
re-implemented much because it's

00:04:39,520 --> 00:04:45,919
pretty specifically tied to those two

00:04:42,560 --> 00:04:48,479
and a bit low level uh but

00:04:45,919 --> 00:04:49,120
a fourth one of course that we have been

00:04:48,479 --> 00:04:52,160
seeing

00:04:49,120 --> 00:04:54,240
uh support crop up from different people

00:04:52,160 --> 00:04:55,680
in hosted services and open source

00:04:54,240 --> 00:04:58,720
projects has been

00:04:55,680 --> 00:05:01,919
our query language promql so that

00:04:58,720 --> 00:05:04,880
is also what i want to focus on today

00:05:01,919 --> 00:05:07,360
people re-implementing promql or

00:05:04,880 --> 00:05:10,400
offering it as part of their solutions

00:05:07,360 --> 00:05:12,080
and the compatibility statements they

00:05:10,400 --> 00:05:15,680
make around that versus

00:05:12,080 --> 00:05:17,759
what they actually deliver prom ql

00:05:15,680 --> 00:05:19,120
is really an important piece of the

00:05:17,759 --> 00:05:21,840
prometheus story

00:05:19,120 --> 00:05:23,440
so typically always when you collect the

00:05:21,840 --> 00:05:26,240
data and you store it

00:05:23,440 --> 00:05:27,840
you then want to first do prom ql on it

00:05:26,240 --> 00:05:29,919
to do anything useful

00:05:27,840 --> 00:05:30,960
whether that's dashboarding alerting ad

00:05:29,919 --> 00:05:33,360
hoc debugging

00:05:30,960 --> 00:05:36,240
you know automating the icd pipelines or

00:05:33,360 --> 00:05:39,360
even exporting it for later use

00:05:36,240 --> 00:05:42,479
typically you want to run prom ql on it

00:05:39,360 --> 00:05:45,440
and prom ql is quite a powerful

00:05:42,479 --> 00:05:45,759
language it's a big interface for sure

00:05:45,440 --> 00:05:49,120
uh

00:05:45,759 --> 00:05:51,680
it has a lot of subtle behaviors and

00:05:49,120 --> 00:05:52,160
you know that you can get wrong or right

00:05:51,680 --> 00:05:54,400
so

00:05:52,160 --> 00:05:56,160
it's it's quite important for users to

00:05:54,400 --> 00:05:59,840
not be surprised and so on to

00:05:56,160 --> 00:06:03,120
to get this implemented correctly

00:05:59,840 --> 00:06:06,319
so there's a number of projects vendors

00:06:03,120 --> 00:06:09,759
hosted services etc that now

00:06:06,319 --> 00:06:12,720
have prom qr support or claim partial

00:06:09,759 --> 00:06:14,000
or full prom qr support you have open

00:06:12,720 --> 00:06:16,080
source project again

00:06:14,000 --> 00:06:17,280
in here you have hosted services and so

00:06:16,080 --> 00:06:19,360
on

00:06:17,280 --> 00:06:20,560
and we're going to go into some of these

00:06:19,360 --> 00:06:24,319
a bit deeper

00:06:20,560 --> 00:06:25,280
a bit later so but the question is how

00:06:24,319 --> 00:06:28,639
do you even test

00:06:25,280 --> 00:06:29,600
compatibility the issue here is that

00:06:28,639 --> 00:06:32,720
there is no

00:06:29,600 --> 00:06:35,280
formal spec for promql you can read the

00:06:32,720 --> 00:06:36,080
documentation on prometheus.io and it

00:06:35,280 --> 00:06:38,560
will tell you

00:06:36,080 --> 00:06:39,280
the relevant or most relevant bits and

00:06:38,560 --> 00:06:41,120
pieces

00:06:39,280 --> 00:06:42,479
from the user's point of view but there

00:06:41,120 --> 00:06:44,800
are still

00:06:42,479 --> 00:06:46,639
a million small edge cases and subtle

00:06:44,800 --> 00:06:48,639
behaviors and so on that if you just

00:06:46,639 --> 00:06:49,039
read that you will probably not get that

00:06:48,639 --> 00:06:50,800
right

00:06:49,039 --> 00:06:52,479
if you just completely re-implement it

00:06:50,800 --> 00:06:54,880
from scratch

00:06:52,479 --> 00:06:55,599
so how do you test that so what i ended

00:06:54,880 --> 00:06:58,560
up doing

00:06:55,599 --> 00:06:59,599
is basically taking the prometheus

00:06:58,560 --> 00:07:02,639
server itself

00:06:59,599 --> 00:07:05,199
as the reference implementation and

00:07:02,639 --> 00:07:06,960
testing against that like comparing any

00:07:05,199 --> 00:07:08,720
vendor implementation against the

00:07:06,960 --> 00:07:12,400
prometheus server's own

00:07:08,720 --> 00:07:14,960
behavior i wrote a tool for that called

00:07:12,400 --> 00:07:18,240
the prom ql compliance tester

00:07:14,960 --> 00:07:20,240
it takes a test configuration the

00:07:18,240 --> 00:07:22,400
reference api which would be typically

00:07:20,240 --> 00:07:25,680
your prometheus server as the reference

00:07:22,400 --> 00:07:29,759
and then the vendor or

00:07:25,680 --> 00:07:30,000
open source project promql api that you

00:07:29,759 --> 00:07:33,440
want

00:07:30,000 --> 00:07:36,319
to compare and test and then it takes a

00:07:33,440 --> 00:07:38,319
number of test cases in in the example

00:07:36,319 --> 00:07:39,120
that i used i had like over 500

00:07:38,319 --> 00:07:43,120
different

00:07:39,120 --> 00:07:46,800
prom qr queries and they expect

00:07:43,120 --> 00:07:49,360
that both of the reference and the test

00:07:46,800 --> 00:07:50,160
system have been pre-populated with the

00:07:49,360 --> 00:07:51,840
same data

00:07:50,160 --> 00:07:54,160
so that you would expect in the best

00:07:51,840 --> 00:07:55,919
case exactly the same answer coming back

00:07:54,160 --> 00:07:58,560
in a query

00:07:55,919 --> 00:08:00,639
so the tester tool then runs the same

00:07:58,560 --> 00:08:02,000
query against the same data set in both

00:08:00,639 --> 00:08:04,960
implementations

00:08:02,000 --> 00:08:05,680
compares the results and writes a test

00:08:04,960 --> 00:08:08,479
output

00:08:05,680 --> 00:08:09,199
and the test output will include how

00:08:08,479 --> 00:08:11,360
many

00:08:09,199 --> 00:08:12,639
tests failed or passed and a percentage

00:08:11,360 --> 00:08:15,520
score

00:08:12,639 --> 00:08:16,639
basically you know just based on did

00:08:15,520 --> 00:08:19,440
they really return

00:08:16,639 --> 00:08:20,720
exactly the same results modulo some

00:08:19,440 --> 00:08:23,199
very slight

00:08:20,720 --> 00:08:23,919
allowances in floating point values here

00:08:23,199 --> 00:08:26,240
and there

00:08:23,919 --> 00:08:28,479
or you know it pre-sorts the result

00:08:26,240 --> 00:08:31,280
before comparing because

00:08:28,479 --> 00:08:32,399
the sorting is undefined uh completely

00:08:31,280 --> 00:08:35,519
in prom ql

00:08:32,399 --> 00:08:37,919
unless you use the sort functions um

00:08:35,519 --> 00:08:40,399
and for the cases where there's a

00:08:37,919 --> 00:08:42,640
failure it actually gives you a detailed

00:08:40,399 --> 00:08:44,800
error message or an actual diff

00:08:42,640 --> 00:08:46,800
of the difference of the sample values

00:08:44,800 --> 00:08:50,000
returned so you can debug and figure out

00:08:46,800 --> 00:08:50,000
what is actually going wrong

00:08:50,320 --> 00:08:54,720
so test summary might look something

00:08:52,240 --> 00:08:54,720
like this

00:08:54,880 --> 00:08:58,640
this is just a very small excerpt of one

00:08:57,200 --> 00:09:01,839
that's currently

00:08:58,640 --> 00:09:03,440
linked of one of the blog posts that's

00:09:01,839 --> 00:09:05,519
in this presentation

00:09:03,440 --> 00:09:07,760
on the prom labs home page in the

00:09:05,519 --> 00:09:10,000
resources section

00:09:07,760 --> 00:09:12,000
you can basically see each query that

00:09:10,000 --> 00:09:15,200
was executed

00:09:12,000 --> 00:09:16,320
and for the ones that failed either get

00:09:15,200 --> 00:09:19,120
an error message

00:09:16,320 --> 00:09:20,480
or get this kind of div output where you

00:09:19,120 --> 00:09:22,480
know in this case you can see that

00:09:20,480 --> 00:09:24,240
there's slight differences in the actual

00:09:22,480 --> 00:09:28,240
floating point values

00:09:24,240 --> 00:09:28,240
for the quantile operator

00:09:29,920 --> 00:09:33,200
so this project started as a prominent

00:09:32,399 --> 00:09:36,640
project

00:09:33,200 --> 00:09:40,320
in the promlabs github org but just now

00:09:36,640 --> 00:09:42,320
april 2021 i donated it to the new

00:09:40,320 --> 00:09:45,120
prometheus compliance repo

00:09:42,320 --> 00:09:46,240
where we as in the prometheus team all

00:09:45,120 --> 00:09:49,519
want to collaborate

00:09:46,240 --> 00:09:52,080
on you know bringing more focus

00:09:49,519 --> 00:09:54,560
on compliance and compatibility testing

00:09:52,080 --> 00:09:57,120
to the various prometheus interfaces

00:09:54,560 --> 00:09:57,839
remote right also and open metrics and

00:09:57,120 --> 00:10:00,080
so on

00:09:57,839 --> 00:10:02,320
uh so it really made sense to donate

00:10:00,080 --> 00:10:05,839
this prom ql tester there as well so now

00:10:02,320 --> 00:10:09,279
it lives there

00:10:05,839 --> 00:10:11,279
i did two initial test runs of different

00:10:09,279 --> 00:10:12,320
vendor implementations and wrote blog

00:10:11,279 --> 00:10:14,000
posts about that

00:10:12,320 --> 00:10:17,040
last year so you can find the full

00:10:14,000 --> 00:10:19,600
details in under these two links

00:10:17,040 --> 00:10:23,760
today i'm just going to talk a bit about

00:10:19,600 --> 00:10:26,240
the latest results from december 2020

00:10:23,760 --> 00:10:27,120
one note i didn't run tests in the

00:10:26,240 --> 00:10:29,279
recent months

00:10:27,120 --> 00:10:31,360
after that so it could totally be that

00:10:29,279 --> 00:10:34,160
some vendors have different results now

00:10:31,360 --> 00:10:37,600
hopefully better ones so keep in mind

00:10:34,160 --> 00:10:39,519
this is the state from december 2020

00:10:37,600 --> 00:10:41,120
but of course like we hope to have

00:10:39,519 --> 00:10:47,760
updates again in the future

00:10:41,120 --> 00:10:49,920
as the prometheus team

00:10:47,760 --> 00:10:51,200
so here are the vendors that are

00:10:49,920 --> 00:10:53,920
included in the last

00:10:51,200 --> 00:10:55,360
test run these are not all of the ones

00:10:53,920 --> 00:10:58,320
that i had initially listed

00:10:55,360 --> 00:11:00,000
because you know for example i had log z

00:10:58,320 --> 00:11:01,519
listed but i think i didn't even

00:11:00,000 --> 00:11:04,480
know that they had a hosted prometheus

00:11:01,519 --> 00:11:07,040
service yet or didn't exist yet

00:11:04,480 --> 00:11:07,920
and so they were not included and

00:11:07,040 --> 00:11:12,079
wavefront

00:11:07,920 --> 00:11:14,959
has some quite limited pronql

00:11:12,079 --> 00:11:15,760
compatible or not well capabilities i

00:11:14,959 --> 00:11:17,760
would say

00:11:15,760 --> 00:11:19,680
because they're not quite compatible uh

00:11:17,760 --> 00:11:22,240
but the http api

00:11:19,680 --> 00:11:24,240
that they had was so different that it

00:11:22,240 --> 00:11:25,760
wasn't even possible to run the tester

00:11:24,240 --> 00:11:27,760
tool against it yet

00:11:25,760 --> 00:11:29,519
i have been communicating with them so

00:11:27,760 --> 00:11:30,959
you know potentially it will become

00:11:29,519 --> 00:11:33,600
possible in the future but

00:11:30,959 --> 00:11:34,320
i can't say anything about that yet so

00:11:33,600 --> 00:11:37,120
for now i

00:11:34,320 --> 00:11:39,279
i tested you know all the ones you can

00:11:37,120 --> 00:11:42,160
see here

00:11:39,279 --> 00:11:44,720
i want to give one word of caution about

00:11:42,160 --> 00:11:48,079
interpreting the numeric test scores

00:11:44,720 --> 00:11:51,440
because either don't just look at

00:11:48,079 --> 00:11:53,120
the score alone because

00:11:51,440 --> 00:11:55,040
obviously like some differences in

00:11:53,120 --> 00:11:58,800
behavior they cause

00:11:55,040 --> 00:12:00,240
one test failure but you know depending

00:11:58,800 --> 00:12:01,200
on the difference in behavior it might

00:12:00,240 --> 00:12:04,639
actually be a really

00:12:01,200 --> 00:12:09,519
impactful breakage or a tiny

00:12:04,639 --> 00:12:11,600
difference in floating point value so

00:12:09,519 --> 00:12:12,880
really look at the detailed test results

00:12:11,600 --> 00:12:14,639
to to see like

00:12:12,880 --> 00:12:16,720
if this really matters for you and to

00:12:14,639 --> 00:12:18,240
see how bad it really is

00:12:16,720 --> 00:12:20,000
and also some differences are more

00:12:18,240 --> 00:12:20,800
general than others so they might like

00:12:20,000 --> 00:12:23,040
affect

00:12:20,800 --> 00:12:24,880
multiple query types where this one

00:12:23,040 --> 00:12:27,760
specific little bug

00:12:24,880 --> 00:12:29,279
over in a popular function potentially

00:12:27,760 --> 00:12:31,760
but that only test once

00:12:29,279 --> 00:12:33,360
so it depends a lot of course on my test

00:12:31,760 --> 00:12:34,720
query set and so on so look at the

00:12:33,360 --> 00:12:36,639
detailed results

00:12:34,720 --> 00:12:39,760
if you really want to see what is going

00:12:36,639 --> 00:12:42,079
on and want to make an informed choice

00:12:39,760 --> 00:12:43,600
when choosing a prometheus compatible

00:12:42,079 --> 00:12:46,959
system

00:12:43,600 --> 00:12:49,839
or prom compatible system so

00:12:46,959 --> 00:12:51,440
this is a quick result overview table

00:12:49,839 --> 00:12:54,560
here of the different systems i

00:12:51,440 --> 00:12:56,720
tested most of them are a hundred

00:12:54,560 --> 00:12:59,440
percent or close to a hundred percent

00:12:56,720 --> 00:13:01,360
i have two outliers here new relic and

00:12:59,440 --> 00:13:04,560
victoria metrics which are quite

00:13:01,360 --> 00:13:05,120
far from that um we're gonna see why

00:13:04,560 --> 00:13:08,560
that is

00:13:05,120 --> 00:13:11,600
later then there's the feature

00:13:08,560 --> 00:13:13,440
of cross-cutting issues that can be

00:13:11,600 --> 00:13:15,279
isolated in the tests

00:13:13,440 --> 00:13:17,440
so there are sometimes in an

00:13:15,279 --> 00:13:19,920
implementation general

00:13:17,440 --> 00:13:22,079
query bugs or issues that cause

00:13:19,920 --> 00:13:23,360
potentially even all queries to be

00:13:22,079 --> 00:13:26,880
different if you don't

00:13:23,360 --> 00:13:30,639
factor out this issue for example

00:13:26,880 --> 00:13:34,160
an older version of cortex had a slight

00:13:30,639 --> 00:13:37,200
query input timestamp parsing bug

00:13:34,160 --> 00:13:39,199
so every time stamp in the output would

00:13:37,200 --> 00:13:39,519
also be off by like one millisecond and

00:13:39,199 --> 00:13:41,519
then

00:13:39,519 --> 00:13:42,800
all the results would not be the same

00:13:41,519 --> 00:13:44,320
and basically

00:13:42,800 --> 00:13:46,160
you know to work around that and still

00:13:44,320 --> 00:13:47,440
make the rest of the results comparable

00:13:46,160 --> 00:13:50,000
i added certain

00:13:47,440 --> 00:13:51,600
query tweaks that you can turn on for

00:13:50,000 --> 00:13:54,720
test targets saying

00:13:51,600 --> 00:13:56,639
um send a query in such a way that this

00:13:54,720 --> 00:13:57,519
bug does not occur so you can still run

00:13:56,639 --> 00:14:01,120
the rest of

00:13:57,519 --> 00:14:03,120
the uh of all the comparisons

00:14:01,120 --> 00:14:04,320
so the query tweaks that are necessary

00:14:03,120 --> 00:14:06,320
to enable that

00:14:04,320 --> 00:14:07,760
are still listed here and if you click

00:14:06,320 --> 00:14:10,720
in the blog

00:14:07,760 --> 00:14:12,160
on those details you will also see uh

00:14:10,720 --> 00:14:15,360
what exactly those query

00:14:12,160 --> 00:14:16,399
tweaks were that were necessary okay

00:14:15,360 --> 00:14:19,440
let's take a look

00:14:16,399 --> 00:14:21,279
at some of the results just briefly

00:14:19,440 --> 00:14:22,959
so the first one was chronosphere i

00:14:21,279 --> 00:14:23,760
don't have to say too much about that

00:14:22,959 --> 00:14:26,399
because they got

00:14:23,760 --> 00:14:26,880
a hundred percent everything passed they

00:14:26,399 --> 00:14:30,639
are

00:14:26,880 --> 00:14:32,399
based on the open source m3 db system

00:14:30,639 --> 00:14:34,160
coming out of uber

00:14:32,399 --> 00:14:36,079
the good thing here is they reused the

00:14:34,160 --> 00:14:38,480
native prom ql engine code so

00:14:36,079 --> 00:14:39,519
you know that's already very helpful for

00:14:38,480 --> 00:14:43,040
getting very close

00:14:39,519 --> 00:14:46,160
or 100 cortex

00:14:43,040 --> 00:14:49,440
as well is reusing the prom ql engine

00:14:46,160 --> 00:14:52,560
code is an open source project got 100

00:14:49,440 --> 00:14:53,120
uh one little note here um in an older

00:14:52,560 --> 00:14:55,600
version

00:14:53,120 --> 00:14:57,199
when i was still using the legacy chunk

00:14:55,600 --> 00:14:59,680
storage mode with it

00:14:57,199 --> 00:15:00,639
it couldn't execute queries that didn't

00:14:59,680 --> 00:15:03,279
contain

00:15:00,639 --> 00:15:04,560
a metric name so for that some of the

00:15:03,279 --> 00:15:08,000
queries were failing

00:15:04,560 --> 00:15:10,480
um i only got 99.62

00:15:08,000 --> 00:15:11,600
but you know if you run cortex now with

00:15:10,480 --> 00:15:14,639
the new block storage

00:15:11,600 --> 00:15:14,639
you should get 100

00:15:15,040 --> 00:15:18,320
grafina cloud is cortex based and they

00:15:18,000 --> 00:15:21,600
are

00:15:18,320 --> 00:15:24,560
using block storage so they also got 100

00:15:21,600 --> 00:15:27,440
modulo one little cross cutting issue

00:15:24,560 --> 00:15:29,839
they align the incoming query timestamps

00:15:27,440 --> 00:15:31,040
to the resolution step to enable query

00:15:29,839 --> 00:15:34,639
caching

00:15:31,040 --> 00:15:35,120
uh so this may or may not be a problem

00:15:34,639 --> 00:15:37,120
for you

00:15:35,120 --> 00:15:38,560
depends uh but it's something that

00:15:37,120 --> 00:15:39,440
should be pointed out it's not

00:15:38,560 --> 00:15:42,880
technically

00:15:39,440 --> 00:15:44,000
correct prom ql evaluation but factoring

00:15:42,880 --> 00:15:47,199
out that issue

00:15:44,000 --> 00:15:47,199
they get a hundred percent

00:15:48,079 --> 00:15:52,399
uh m3 as the pure open source project i

00:15:50,639 --> 00:15:53,440
also just tried running that myself

00:15:52,399 --> 00:15:56,320
storing data in there

00:15:53,440 --> 00:15:57,920
querying it back out and also got 100

00:15:56,320 --> 00:16:00,959
great

00:15:57,920 --> 00:16:04,240
metric fire is another cortex-based

00:16:00,959 --> 00:16:06,639
hosted service um they are still running

00:16:04,240 --> 00:16:08,000
a slightly outdated version of cortex at

00:16:06,639 --> 00:16:09,600
least there were in december

00:16:08,000 --> 00:16:11,040
and so they didn't get the full hundred

00:16:09,600 --> 00:16:13,600
percent um

00:16:11,040 --> 00:16:15,440
but you know i i hope maybe already

00:16:13,600 --> 00:16:15,759
they're getting 100 if i would test them

00:16:15,440 --> 00:16:18,160
now

00:16:15,759 --> 00:16:20,160
they are aware of the issue and

00:16:18,160 --> 00:16:22,240
basically a cortex update

00:16:20,160 --> 00:16:24,639
hopefully will bring them to a hundred

00:16:22,240 --> 00:16:29,360
percent

00:16:24,639 --> 00:16:32,000
uh new relic is a hosted monitoring

00:16:29,360 --> 00:16:32,720
or application performance monitoring uh

00:16:32,000 --> 00:16:35,199
player

00:16:32,720 --> 00:16:36,000
that's been around for a long time um

00:16:35,199 --> 00:16:38,399
full disclosure

00:16:36,000 --> 00:16:39,839
i have been consulting with them a bit

00:16:38,399 --> 00:16:42,560
on this trying to improve

00:16:39,839 --> 00:16:43,120
the prom ql support they were building

00:16:42,560 --> 00:16:45,360
um

00:16:43,120 --> 00:16:46,560
the big challenge in their

00:16:45,360 --> 00:16:49,680
implementation

00:16:46,560 --> 00:16:51,920
is that they they

00:16:49,680 --> 00:16:54,160
wanted to reuse what they already had so

00:16:51,920 --> 00:16:54,720
they have an existing query language

00:16:54,160 --> 00:16:57,920
called

00:16:54,720 --> 00:16:59,920
nrql and an underlying database in our

00:16:57,920 --> 00:17:02,560
db

00:16:59,920 --> 00:17:04,799
and they were conceptually not really

00:17:02,560 --> 00:17:07,679
compatible with prom ql

00:17:04,799 --> 00:17:08,799
data models and language concepts so it

00:17:07,679 --> 00:17:12,160
was

00:17:08,799 --> 00:17:14,959
not really possible to to were

00:17:12,160 --> 00:17:15,839
feasible to to transpile everything

00:17:14,959 --> 00:17:19,039
faithfully

00:17:15,839 --> 00:17:21,360
into nrql so

00:17:19,039 --> 00:17:22,799
you know as some examples obviously you

00:17:21,360 --> 00:17:25,679
see the score they got in

00:17:22,799 --> 00:17:27,199
in my case was only around 31 with some

00:17:25,679 --> 00:17:29,440
cross-cutting issues

00:17:27,199 --> 00:17:31,919
so they don't you know support certain

00:17:29,440 --> 00:17:33,919
features like binary operator modifiers

00:17:31,919 --> 00:17:36,160
quite important i would say

00:17:33,919 --> 00:17:38,240
not all functions we have in prom ql

00:17:36,160 --> 00:17:40,320
staleness handling special float values

00:17:38,240 --> 00:17:41,919
and a bunch more of a little different

00:17:40,320 --> 00:17:44,799
behaviors that you can look up

00:17:41,919 --> 00:17:44,799
in the blog post

00:17:45,120 --> 00:17:49,760
so you know pointing new relic at a

00:17:48,160 --> 00:17:51,840
grafana dashboard

00:17:49,760 --> 00:17:53,760
or pointing a graffana dashboard with a

00:17:51,840 --> 00:17:54,480
prometheus data source at neuralic might

00:17:53,760 --> 00:17:56,720
give you

00:17:54,480 --> 00:17:58,240
quite similar looking results sometimes

00:17:56,720 --> 00:17:59,760
but

00:17:58,240 --> 00:18:01,280
it's it's going to have quite some

00:17:59,760 --> 00:18:04,559
differences and and

00:18:01,280 --> 00:18:08,320
not supported queries as well

00:18:04,559 --> 00:18:10,960
then there is another project which

00:18:08,320 --> 00:18:12,240
is like so prompt scale is an adapter

00:18:10,960 --> 00:18:14,640
for the time scale

00:18:12,240 --> 00:18:15,520
database by the time scale folks it's

00:18:14,640 --> 00:18:17,919
open source

00:18:15,520 --> 00:18:18,720
and it's also reusing the native prom ql

00:18:17,919 --> 00:18:23,679
engine

00:18:18,720 --> 00:18:26,559
and again great job getting 100

00:18:23,679 --> 00:18:28,320
thanos same case open source reusing

00:18:26,559 --> 00:18:32,000
prom ql engine from upstream

00:18:28,320 --> 00:18:34,559
getting 100 uh as a last

00:18:32,000 --> 00:18:36,240
case here in the alphabet i have

00:18:34,559 --> 00:18:38,720
victoria metrics

00:18:36,240 --> 00:18:40,720
they are also an interesting case in

00:18:38,720 --> 00:18:43,360
that they really position themselves

00:18:40,720 --> 00:18:45,919
marketing wise as a drop in replacement

00:18:43,360 --> 00:18:48,400
to prometheus

00:18:45,919 --> 00:18:50,880
but they have their own language dialect

00:18:48,400 --> 00:18:52,400
called matrix ql

00:18:50,880 --> 00:18:54,400
but you know in the first sentence

00:18:52,400 --> 00:18:56,799
typically describing it it says

00:18:54,400 --> 00:18:58,000
metrics ql is prom ql backwards

00:18:56,799 --> 00:19:00,240
compatible

00:18:58,000 --> 00:19:02,240
um but then if you keep on reading there

00:19:00,240 --> 00:19:04,320
is a bunch of exceptions

00:19:02,240 --> 00:19:05,919
listed how they are not compatible and

00:19:04,320 --> 00:19:07,679
they have extra functions and

00:19:05,919 --> 00:19:10,720
they do quite a bunch of things quite

00:19:07,679 --> 00:19:14,080
differently um

00:19:10,720 --> 00:19:16,400
and yeah in this case they got around 60

00:19:14,080 --> 00:19:17,520
not quite with some cross-cutting issues

00:19:16,400 --> 00:19:19,120
as well

00:19:17,520 --> 00:19:21,120
um you know they have different

00:19:19,120 --> 00:19:23,840
behaviors around when they drop metric

00:19:21,120 --> 00:19:25,679
names they select one more sample in

00:19:23,840 --> 00:19:26,559
range vector selectors than prometheus

00:19:25,679 --> 00:19:29,840
does

00:19:26,559 --> 00:19:31,120
they don't support the staleness markers

00:19:29,840 --> 00:19:34,799
that prometheus does

00:19:31,120 --> 00:19:35,840
they remove nan float values from

00:19:34,799 --> 00:19:39,120
outputs

00:19:35,840 --> 00:19:41,280
they also don't store full float values

00:19:39,120 --> 00:19:43,200
so you can't get the full float values

00:19:41,280 --> 00:19:45,919
back out of the database

00:19:43,200 --> 00:19:46,799
um so that also sometimes caused the

00:19:45,919 --> 00:19:49,360
thresholds

00:19:46,799 --> 00:19:50,320
of the comparison of the comparator to

00:19:49,360 --> 00:19:52,160
say

00:19:50,320 --> 00:19:53,840
hey you know this this query actually

00:19:52,160 --> 00:19:56,400
failed uh and there's

00:19:53,840 --> 00:19:58,080
a couple more differences uh in

00:19:56,400 --> 00:19:59,440
backwards compatibility that are not

00:19:58,080 --> 00:20:00,880
quite met here

00:19:59,440 --> 00:20:02,880
uh so this is just you know something

00:20:00,880 --> 00:20:06,159
you might want to look at if you

00:20:02,880 --> 00:20:09,840
were to choose a solution

00:20:06,159 --> 00:20:12,880
so that that's it for just diving a tiny

00:20:09,840 --> 00:20:15,120
bit into individual vendors and projects

00:20:12,880 --> 00:20:16,080
um there are still some open questions

00:20:15,120 --> 00:20:18,480
around this effort

00:20:16,080 --> 00:20:19,679
in general so like how do we deal in

00:20:18,480 --> 00:20:21,600
test reports with

00:20:19,679 --> 00:20:23,760
slight differences versus larger

00:20:21,600 --> 00:20:25,840
differences

00:20:23,760 --> 00:20:27,440
do we report them just as one test

00:20:25,840 --> 00:20:29,520
failure or do we want to like

00:20:27,440 --> 00:20:31,840
characterize them in different ways

00:20:29,520 --> 00:20:33,039
and how would that even be possible in

00:20:31,840 --> 00:20:35,600
an automated fashion

00:20:33,039 --> 00:20:37,600
so maybe it's just not and we just in

00:20:35,600 --> 00:20:38,559
general want to encourage people to get

00:20:37,600 --> 00:20:41,520
to 100

00:20:38,559 --> 00:20:42,960
anyway um so you know maybe that will

00:20:41,520 --> 00:20:46,400
not be as important

00:20:42,960 --> 00:20:49,200
um there could also be some

00:20:46,400 --> 00:20:50,960
behaviors in the native promptql engine

00:20:49,200 --> 00:20:51,840
that we actually want to treat as

00:20:50,960 --> 00:20:55,840
undefined

00:20:51,840 --> 00:20:59,440
for example the subquery alignment step

00:20:55,840 --> 00:21:01,840
the subquery step alignment or

00:20:59,440 --> 00:21:03,919
you know sorting is already undefined or

00:21:01,840 --> 00:21:05,360
i already ignore sorting in the tester

00:21:03,919 --> 00:21:07,039
but there could be other things that we

00:21:05,360 --> 00:21:08,240
don't actually want to compare in

00:21:07,039 --> 00:21:09,600
behavior

00:21:08,240 --> 00:21:12,159
and then there's also the question of

00:21:09,600 --> 00:21:13,760
how to version the compatibility and the

00:21:12,159 --> 00:21:15,919
test results over time

00:21:13,760 --> 00:21:18,799
saying like with which prom ql version

00:21:15,919 --> 00:21:21,760
are you actually compatible and how much

00:21:18,799 --> 00:21:22,159
all right there's some related future

00:21:21,760 --> 00:21:24,559
work

00:21:22,159 --> 00:21:25,840
going on as well as i mentioned in this

00:21:24,559 --> 00:21:29,360
compliance repo

00:21:25,840 --> 00:21:32,159
we are linking

00:21:29,360 --> 00:21:35,039
tests and specs for open metrics and we

00:21:32,159 --> 00:21:36,960
have tests in there for remote right

00:21:35,039 --> 00:21:39,280
someone just proposed creating remote

00:21:36,960 --> 00:21:42,000
read tests as well

00:21:39,280 --> 00:21:44,720
obviously there's the prom ql work in

00:21:42,000 --> 00:21:47,679
there as well now and potentially future

00:21:44,720 --> 00:21:49,360
interfaces as well ultimately we want to

00:21:47,679 --> 00:21:51,919
get to a point where

00:21:49,360 --> 00:21:53,440
people building systems that are

00:21:51,919 --> 00:21:56,640
prometheus compatible

00:21:53,440 --> 00:21:58,799
to get certified marks

00:21:56,640 --> 00:22:00,960
potentially even be able to self-certify

00:21:58,799 --> 00:22:01,600
themselves but we we can't say that for

00:22:00,960 --> 00:22:04,799
sure yet

00:22:01,600 --> 00:22:06,240
uh so initially for sure we you know

00:22:04,799 --> 00:22:08,320
these tests that give you some

00:22:06,240 --> 00:22:08,960
certification will require some manual

00:22:08,320 --> 00:22:11,039
effort

00:22:08,960 --> 00:22:12,000
likely input from the prometheus team as

00:22:11,039 --> 00:22:14,480
well to say that

00:22:12,000 --> 00:22:16,159
yes it's actually compatible but

00:22:14,480 --> 00:22:18,799
ultimately we should figure this out

00:22:16,159 --> 00:22:20,000
as a community so please watch this

00:22:18,799 --> 00:22:22,240
compliance repo

00:22:20,000 --> 00:22:23,039
and contribute to it and potentially

00:22:22,240 --> 00:22:26,159
like discuss

00:22:23,039 --> 00:22:27,919
on the prometheus open source channels

00:22:26,159 --> 00:22:28,880
the typical ones the mailing list the

00:22:27,919 --> 00:22:33,039
chats

00:22:28,880 --> 00:22:35,520
and so on all right so

00:22:33,039 --> 00:22:39,360
stay compatible thank you and i wish you

00:22:35,520 --> 00:22:39,360

YouTube URL: https://www.youtube.com/watch?v=bONZQhnCeTg


