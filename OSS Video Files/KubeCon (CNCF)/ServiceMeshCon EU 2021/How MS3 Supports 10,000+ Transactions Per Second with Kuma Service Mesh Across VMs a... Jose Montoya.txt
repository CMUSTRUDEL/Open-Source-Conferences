Title: How MS3 Supports 10,000+ Transactions Per Second with Kuma Service Mesh Across VMs a... Jose Montoya
Publication date: 2021-05-05
Playlist: ServiceMeshCon EU 2021
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

How MS3 Supports 10,000+ Transactions Per Second with Kuma Service Mesh Across VMs and Kubernetes - Jose Montoya, MS3

With more businesses moving to digital, MS3 needed a simple way to address cross-cutting concerns such as security and observability, to accelerate the delivery of cloud native applications in a microservices architecture using containers and Kubernetes. This session covers how Kuma end-user, MS3, leveraged the service mesh project for a cost-effective way to address these concerns at the platform level and removed from the application developers’ responsibilities. We'll provide real-world examples to help other organizations implement service mesh to expedite digital transformation initiatives due to COVID-19. We’ll cover how MS3 leverages Kuma, an open-source control plane for service mesh built on top of Envoy, for their Enterprise Integration Platform to support commercial and federal customers with no performance impact for apps handling over 10,000 transactions per second
Captions: 
	00:00:00,080 --> 00:00:04,319
hey guys my name is jose montoya welcome

00:00:02,080 --> 00:00:05,839
to this talk named tavros and kuma

00:00:04,319 --> 00:00:08,160
essential software concerns at the

00:00:05,839 --> 00:00:09,120
platform level um a little bit about

00:00:08,160 --> 00:00:11,120
myself

00:00:09,120 --> 00:00:12,639
i work for a company called mountain

00:00:11,120 --> 00:00:15,839
state software solutions or

00:00:12,639 --> 00:00:17,840
ms3 for short we specialize in

00:00:15,839 --> 00:00:20,400
enterprise integration software

00:00:17,840 --> 00:00:21,600
uh cloud migration strategies and api

00:00:20,400 --> 00:00:24,000
enablement

00:00:21,600 --> 00:00:25,359
um so i've been doing this for about

00:00:24,000 --> 00:00:28,240
five years now

00:00:25,359 --> 00:00:29,679
and for the last six months to a year

00:00:28,240 --> 00:00:32,960
i've been the principal

00:00:29,679 --> 00:00:36,559
product manager for tavros tavros is a

00:00:32,960 --> 00:00:38,239
enterprise integration platform from ms3

00:00:36,559 --> 00:00:40,079
um today i'll be taking you guys a

00:00:38,239 --> 00:00:42,960
little uh um

00:00:40,079 --> 00:00:44,399
you know journey between what tavros is

00:00:42,960 --> 00:00:46,879
and

00:00:44,399 --> 00:00:49,360
how we use kuma to address some of these

00:00:46,879 --> 00:00:52,000
essential software concerns

00:00:49,360 --> 00:00:53,280
at the platform level so we'll get right

00:00:52,000 --> 00:00:55,520
into it

00:00:53,280 --> 00:00:56,399
so the first thing that we should do is

00:00:55,520 --> 00:00:58,480
talk about

00:00:56,399 --> 00:01:00,160
this essence of software right so the

00:00:58,480 --> 00:01:01,440
concept comes from a book called the

00:01:00,160 --> 00:01:04,479
mythical man month

00:01:01,440 --> 00:01:06,159
you might be familiar with it is um

00:01:04,479 --> 00:01:08,720
is sort of a classic in software

00:01:06,159 --> 00:01:08,720
engineering

00:01:08,880 --> 00:01:14,000
in in this book frederick brooks it has

00:01:11,920 --> 00:01:15,759
basically a collection of essays about

00:01:14,000 --> 00:01:17,920
software engineering in general

00:01:15,759 --> 00:01:19,040
in particular there is one called no

00:01:17,920 --> 00:01:20,960
silver bullets

00:01:19,040 --> 00:01:22,080
the essence an accident in software

00:01:20,960 --> 00:01:24,080
engineering

00:01:22,080 --> 00:01:25,840
where he basically describes what he

00:01:24,080 --> 00:01:28,240
thinks the essence of engineering is of

00:01:25,840 --> 00:01:31,680
software engineering is and

00:01:28,240 --> 00:01:33,840
here's what i have here's what he says

00:01:31,680 --> 00:01:35,280
the hard part of building software is is

00:01:33,840 --> 00:01:38,079
this specification

00:01:35,280 --> 00:01:39,200
the sign and testing of this conceptual

00:01:38,079 --> 00:01:41,280
construct

00:01:39,200 --> 00:01:43,360
not the labor of representing it

00:01:41,280 --> 00:01:45,280
basically what brooks is saying is that

00:01:43,360 --> 00:01:46,960
the hard part is really understanding

00:01:45,280 --> 00:01:50,240
what it is that we want to build

00:01:46,960 --> 00:01:52,000
and kind of creating our mental uh

00:01:50,240 --> 00:01:53,840
this conceptual construct right

00:01:52,000 --> 00:01:54,880
designing it even as a conceptual

00:01:53,840 --> 00:01:56,479
construct

00:01:54,880 --> 00:01:58,719
the part about representing it in the

00:01:56,479 --> 00:01:59,840
software in a programming language is

00:01:58,719 --> 00:02:01,759
kind of

00:01:59,840 --> 00:02:03,759
accidental complexity right the hard

00:02:01,759 --> 00:02:05,439
part is really that conceptual construct

00:02:03,759 --> 00:02:07,040
understanding and designing it in our

00:02:05,439 --> 00:02:09,200
minds

00:02:07,040 --> 00:02:10,160
uh he goes on to talk about how he

00:02:09,200 --> 00:02:13,120
doesn't envision

00:02:10,160 --> 00:02:14,480
any individual breakthrough in software

00:02:13,120 --> 00:02:17,840
engineering that is gonna

00:02:14,480 --> 00:02:19,599
you know really uh revolutionize the

00:02:17,840 --> 00:02:21,040
productivity levels that we have when we

00:02:19,599 --> 00:02:24,080
create software

00:02:21,040 --> 00:02:25,200
um you know he talks about things like

00:02:24,080 --> 00:02:27,680
higher level

00:02:25,200 --> 00:02:28,560
programming languages or object

00:02:27,680 --> 00:02:31,680
orientation or

00:02:28,560 --> 00:02:33,200
even or even artificial intelligence

00:02:31,680 --> 00:02:35,680
as things that he doesn't think are

00:02:33,200 --> 00:02:36,160
going to be you know monumental and and

00:02:35,680 --> 00:02:38,879
their

00:02:36,160 --> 00:02:40,720
effect on software engineering he does

00:02:38,879 --> 00:02:44,160
have a few things

00:02:40,720 --> 00:02:47,200
that um he considers to be worthwhile

00:02:44,160 --> 00:02:48,840
attacks on on the essence of engineering

00:02:47,200 --> 00:02:50,080
to provide this kind of boost of

00:02:48,840 --> 00:02:52,400
productivity

00:02:50,080 --> 00:02:54,160
he lists four i've grouped them here in

00:02:52,400 --> 00:02:55,360
two groups of two because i think they

00:02:54,160 --> 00:02:57,920
you know these groups kind of go

00:02:55,360 --> 00:02:58,480
together um and so i'll go through them

00:02:57,920 --> 00:03:00,560
now so

00:02:58,480 --> 00:03:02,239
first is the requirements uh

00:03:00,560 --> 00:03:03,680
requirements refining and rapid

00:03:02,239 --> 00:03:05,680
prototyping

00:03:03,680 --> 00:03:07,920
basically here he talks about you know

00:03:05,680 --> 00:03:10,000
it is iteratively

00:03:07,920 --> 00:03:11,599
refining your your requirements

00:03:10,000 --> 00:03:12,720
gathering right so there's no way that

00:03:11,599 --> 00:03:14,480
we can get

00:03:12,720 --> 00:03:16,800
our requirements precisely and

00:03:14,480 --> 00:03:19,360
accurately all up front

00:03:16,800 --> 00:03:20,400
um so we might as well just prototype

00:03:19,360 --> 00:03:21,920
and learn as we go

00:03:20,400 --> 00:03:24,400
just keep refining our requirements and

00:03:21,920 --> 00:03:26,400
prototyping as we go

00:03:24,400 --> 00:03:27,920
i think in the same vein he talks about

00:03:26,400 --> 00:03:29,599
incremental development

00:03:27,920 --> 00:03:32,159
where he basically says that instead of

00:03:29,599 --> 00:03:34,720
trying to deliver all of the features of

00:03:32,159 --> 00:03:36,400
a software product kind of all at once

00:03:34,720 --> 00:03:39,440
with the final nail

00:03:36,400 --> 00:03:42,640
just kind of do it do it uh uh

00:03:39,440 --> 00:03:45,760
incrementally right so start from a

00:03:42,640 --> 00:03:48,560
kind of very bare

00:03:45,760 --> 00:03:50,239
piece maybe even useless but you know

00:03:48,560 --> 00:03:51,680
standalone and functional and start

00:03:50,239 --> 00:03:54,480
adding features

00:03:51,680 --> 00:03:55,040
um incrementally right so the analogy is

00:03:54,480 --> 00:03:56,799
to grow

00:03:55,040 --> 00:03:58,400
software instead of building it as a

00:03:56,799 --> 00:04:01,120
building just grow it

00:03:58,400 --> 00:04:01,760
that's a living thing um so i think

00:04:01,120 --> 00:04:04,080
these two

00:04:01,760 --> 00:04:06,080
these two attacks kind of go hand in

00:04:04,080 --> 00:04:07,040
hand and to me i group them together

00:04:06,080 --> 00:04:10,400
because this

00:04:07,040 --> 00:04:11,680
for me is just inspect and adapt right

00:04:10,400 --> 00:04:14,799
and so some of the words

00:04:11,680 --> 00:04:16,639
might have seemed familiar to you guys

00:04:14,799 --> 00:04:19,199
when we think about agile development

00:04:16,639 --> 00:04:22,079
for example or continuous delivery

00:04:19,199 --> 00:04:23,919
the idea is that we want to go at it

00:04:22,079 --> 00:04:27,040
piece by piece incrementally

00:04:23,919 --> 00:04:28,960
not all at once so agile and continuous

00:04:27,040 --> 00:04:29,600
delivery i think kind of fit that same

00:04:28,960 --> 00:04:31,600
idea

00:04:29,600 --> 00:04:34,000
of uh you know incremental development

00:04:31,600 --> 00:04:36,960
prototyping

00:04:34,000 --> 00:04:38,880
and requirements refining microservices

00:04:36,960 --> 00:04:41,199
and containerization i have here because

00:04:38,880 --> 00:04:42,320
as we make these units of functions

00:04:41,199 --> 00:04:44,240
smaller

00:04:42,320 --> 00:04:45,759
it makes it easier for us to prototype

00:04:44,240 --> 00:04:46,720
it makes it easier for us to try

00:04:45,759 --> 00:04:48,479
different languages

00:04:46,720 --> 00:04:50,880
different designs different frameworks

00:04:48,479 --> 00:04:52,960
etc and observability i have here

00:04:50,880 --> 00:04:53,520
because it is imperative for us to have

00:04:52,960 --> 00:04:55,600
good

00:04:53,520 --> 00:04:57,520
observability into our systems in order

00:04:55,600 --> 00:05:00,479
for us to really inspect

00:04:57,520 --> 00:05:02,080
meaningfully and have the ability to

00:05:00,479 --> 00:05:05,120
make educated decisions on that

00:05:02,080 --> 00:05:07,440
inspection in order to adapt

00:05:05,120 --> 00:05:09,600
um the other few the other two attacks

00:05:07,440 --> 00:05:11,120
that brooks talks about in his book is

00:05:09,600 --> 00:05:13,360
buy versus build which i think is the

00:05:11,120 --> 00:05:14,720
main one he's basically saying the most

00:05:13,360 --> 00:05:16,880
productive time

00:05:14,720 --> 00:05:18,639
uh you know trying to deliver software

00:05:16,880 --> 00:05:20,320
is where we is when we don't spend that

00:05:18,639 --> 00:05:20,880
time at all so basically you know you

00:05:20,320 --> 00:05:24,160
buy

00:05:20,880 --> 00:05:27,360
an off-the-shelf product that meets

00:05:24,160 --> 00:05:28,960
all if not most of your requirements and

00:05:27,360 --> 00:05:30,560
the other one is great designers where

00:05:28,960 --> 00:05:32,080
he basically just says hey at the end of

00:05:30,560 --> 00:05:34,960
the day

00:05:32,080 --> 00:05:35,440
software is is sort of a creative

00:05:34,960 --> 00:05:38,240
process

00:05:35,440 --> 00:05:39,759
it's an artistic process so some people

00:05:38,240 --> 00:05:40,960
are just going to be better at it than

00:05:39,759 --> 00:05:42,800
others

00:05:40,960 --> 00:05:44,639
specifically you know more experienced

00:05:42,800 --> 00:05:46,479
developers um

00:05:44,639 --> 00:05:48,240
are always just going to be better than

00:05:46,479 --> 00:05:50,880
those non-experienced so he talks about

00:05:48,240 --> 00:05:53,039
you know spending time and resources

00:05:50,880 --> 00:05:54,320
on people and get them to be these great

00:05:53,039 --> 00:05:55,120
designers but at the end of the day

00:05:54,320 --> 00:05:57,840
again

00:05:55,120 --> 00:05:59,440
um you just gotta have good good people

00:05:57,840 --> 00:06:02,479
good designers

00:05:59,440 --> 00:06:04,720
uh and so these two i uh

00:06:02,479 --> 00:06:06,240
kind of take me into domain driven

00:06:04,720 --> 00:06:07,919
design right so

00:06:06,240 --> 00:06:10,479
the main driver designed by eric evans

00:06:07,919 --> 00:06:13,039
has this concept of distillation

00:06:10,479 --> 00:06:13,919
which is basically to say in in your

00:06:13,039 --> 00:06:16,080
software

00:06:13,919 --> 00:06:17,520
components in your it landscape in your

00:06:16,080 --> 00:06:20,639
industry

00:06:17,520 --> 00:06:21,440
you gotta identify what he calls core

00:06:20,639 --> 00:06:24,800
domains

00:06:21,440 --> 00:06:27,199
versus generic subdomains so your core

00:06:24,800 --> 00:06:29,600
domains are going to be

00:06:27,199 --> 00:06:30,479
those things that are essential to your

00:06:29,600 --> 00:06:35,360
business that

00:06:30,479 --> 00:06:37,199
drive business value for your company

00:06:35,360 --> 00:06:39,280
and the generic sub domain ones are

00:06:37,199 --> 00:06:41,840
going to be just supporting roles

00:06:39,280 --> 00:06:43,039
that are still essential but are not the

00:06:41,840 --> 00:06:45,360
principal

00:06:43,039 --> 00:06:46,960
drivers of value they're not the things

00:06:45,360 --> 00:06:48,080
that are going to differentiate you

00:06:46,960 --> 00:06:51,360
versus another company

00:06:48,080 --> 00:06:53,440
in the same industry so uh for example

00:06:51,360 --> 00:06:56,160
if we think about banking

00:06:53,440 --> 00:06:56,800
a fancy crm is not going to be my core

00:06:56,160 --> 00:06:58,319
domain

00:06:56,800 --> 00:07:00,160
it's not going to differentiate me from

00:06:58,319 --> 00:07:01,280
another bank uh

00:07:00,160 --> 00:07:03,759
you know the latest and greatest

00:07:01,280 --> 00:07:06,400
identity management uh

00:07:03,759 --> 00:07:08,240
system is not going to be my core domain

00:07:06,400 --> 00:07:09,680
banking services is going to be my core

00:07:08,240 --> 00:07:11,919
domain how fast

00:07:09,680 --> 00:07:13,280
a customer can open a checking account

00:07:11,919 --> 00:07:16,160
from their phone

00:07:13,280 --> 00:07:17,840
um internally how fast or how easy

00:07:16,160 --> 00:07:19,360
internal developers can gather

00:07:17,840 --> 00:07:21,280
information from

00:07:19,360 --> 00:07:22,800
you know six or seven different back-end

00:07:21,280 --> 00:07:23,680
systems that have different types of

00:07:22,800 --> 00:07:27,039
accounts

00:07:23,680 --> 00:07:29,120
how easy they can consume compose and

00:07:27,039 --> 00:07:32,319
maybe filter that data to provide

00:07:29,120 --> 00:07:32,560
a mobile phone user interface maybe even

00:07:32,319 --> 00:07:35,680
an

00:07:32,560 --> 00:07:39,360
alexa conversation or a website etc

00:07:35,680 --> 00:07:41,039
so these are things that do drive

00:07:39,360 --> 00:07:42,560
the business value that we can offer as

00:07:41,039 --> 00:07:44,560
a bank that differentiate us

00:07:42,560 --> 00:07:47,360
as a bank so these will be our core

00:07:44,560 --> 00:07:48,800
domain so the idea is that

00:07:47,360 --> 00:07:51,199
through distillation through this

00:07:48,800 --> 00:07:52,000
process of identifying core from generic

00:07:51,199 --> 00:07:54,479
sub-domains

00:07:52,000 --> 00:07:56,560
we can strategically decide when to buy

00:07:54,479 --> 00:07:58,479
versus bill

00:07:56,560 --> 00:08:00,479
the other point that eric evans makes is

00:07:58,479 --> 00:08:01,280
that because generic subdomains are

00:08:00,479 --> 00:08:02,800
generic across

00:08:01,280 --> 00:08:04,400
industries they've been studied more

00:08:02,800 --> 00:08:05,840
they're kind of more tractable they're

00:08:04,400 --> 00:08:08,960
not domain specific

00:08:05,840 --> 00:08:10,960
they're easy to understand and attack so

00:08:08,960 --> 00:08:12,720
they sometimes attract

00:08:10,960 --> 00:08:14,319
your more skilled developers so what

00:08:12,720 --> 00:08:15,360
ends up happening is your your great

00:08:14,319 --> 00:08:17,280
designers

00:08:15,360 --> 00:08:20,000
end up working on the things that bring

00:08:17,280 --> 00:08:23,840
you the least amount of value

00:08:20,000 --> 00:08:26,639
so again the idea is spend some time

00:08:23,840 --> 00:08:28,400
identifying uh what you should build

00:08:26,639 --> 00:08:31,039
versus versus what you should buy

00:08:28,400 --> 00:08:33,200
and act on those on those uh you know on

00:08:31,039 --> 00:08:35,200
what you've identified

00:08:33,200 --> 00:08:36,959
if we take it one step further we can

00:08:35,200 --> 00:08:37,360
identify even more things that ought to

00:08:36,959 --> 00:08:39,279
be

00:08:37,360 --> 00:08:41,360
considered in this process which i call

00:08:39,279 --> 00:08:42,399
generic cross-cutting concerns these are

00:08:41,360 --> 00:08:43,760
things that applied

00:08:42,399 --> 00:08:46,240
regardless of whether there is a core

00:08:43,760 --> 00:08:49,200
domain or a generic sub-domain

00:08:46,240 --> 00:08:51,760
things like security logging tracing any

00:08:49,200 --> 00:08:53,920
of these cross-cross-functional

00:08:51,760 --> 00:08:56,240
cross-cutting concerns that apply and

00:08:53,920 --> 00:08:57,760
you need to think about because

00:08:56,240 --> 00:08:59,360
even though they they still play a

00:08:57,760 --> 00:09:00,560
supporting world it's still essential no

00:08:59,360 --> 00:09:01,760
one's going to use your system if it's

00:09:00,560 --> 00:09:05,040
not secure

00:09:01,760 --> 00:09:07,519
um so yeah we need to to keep this in

00:09:05,040 --> 00:09:10,640
mind and try to bring this into this

00:09:07,519 --> 00:09:12,720
strategic buy versus build but we'll

00:09:10,640 --> 00:09:14,480
start with the generic subdomain so

00:09:12,720 --> 00:09:16,080
let's say once we've identified you know

00:09:14,480 --> 00:09:19,120
i'm a bank i don't need to

00:09:16,080 --> 00:09:20,640
build a crm and we

00:09:19,120 --> 00:09:22,640
identify all these products and we say

00:09:20,640 --> 00:09:24,880
we're just gonna buy them we're gonna

00:09:22,640 --> 00:09:26,080
liberate our developers our great

00:09:24,880 --> 00:09:29,519
designers to work

00:09:26,080 --> 00:09:31,200
on our core domains um and not on the

00:09:29,519 --> 00:09:33,200
generic subdomains that are only you

00:09:31,200 --> 00:09:34,480
know supporting they're the supporting

00:09:33,200 --> 00:09:37,120
cast

00:09:34,480 --> 00:09:37,839
great great first step uh what happens

00:09:37,120 --> 00:09:39,519
though is that

00:09:37,839 --> 00:09:41,279
now that you have off-the-shelf products

00:09:39,519 --> 00:09:44,080
you bring in some challenges or

00:09:41,279 --> 00:09:45,519
some challenges around integration um

00:09:44,080 --> 00:09:47,279
now the surface area is going to be

00:09:45,519 --> 00:09:48,959
smaller than your core domain because

00:09:47,279 --> 00:09:51,519
integration is mostly going to be about

00:09:48,959 --> 00:09:53,680
translation and orchestration

00:09:51,519 --> 00:09:54,959
but it's still a place where you can

00:09:53,680 --> 00:09:57,920
drive

00:09:54,959 --> 00:09:59,760
value that value from right so if if if

00:09:57,920 --> 00:10:02,160
you're a bank again and you bought

00:09:59,760 --> 00:10:03,600
a system for mortgages mortgage accounts

00:10:02,160 --> 00:10:07,040
a system for credit cards

00:10:03,600 --> 00:10:09,200
credit card accounts if you

00:10:07,040 --> 00:10:10,959
develop a integration component that

00:10:09,200 --> 00:10:11,839
allows you to view all of those accounts

00:10:10,959 --> 00:10:14,320
uniformly

00:10:11,839 --> 00:10:16,640
from independently developed components

00:10:14,320 --> 00:10:18,720
that's a differentiating factor right

00:10:16,640 --> 00:10:20,160
it makes it easier for your customers to

00:10:18,720 --> 00:10:22,480
access their data makes it easier for

00:10:20,160 --> 00:10:26,000
you developers

00:10:22,480 --> 00:10:28,399
i'm sorry to develop different different

00:10:26,000 --> 00:10:29,519
user interface experiences for you for

00:10:28,399 --> 00:10:31,680
your customers so it

00:10:29,519 --> 00:10:33,279
does become a point where you can drive

00:10:31,680 --> 00:10:36,399
differentiating

00:10:33,279 --> 00:10:38,320
factors in your industry yet we still

00:10:36,399 --> 00:10:40,000
have to worry again about these generic

00:10:38,320 --> 00:10:41,760
cross-cutting concerns we have to secure

00:10:40,000 --> 00:10:43,200
these integration components we have to

00:10:41,760 --> 00:10:44,000
make sure they're performant that they

00:10:43,200 --> 00:10:47,279
have blogging

00:10:44,000 --> 00:10:48,959
and observability etc so that becomes

00:10:47,279 --> 00:10:52,560
our next step

00:10:48,959 --> 00:10:54,640
how do we buy versus build these generic

00:10:52,560 --> 00:10:57,440
cross-cutting concerns that are not

00:10:54,640 --> 00:10:58,880
really what gives us value as a bank or

00:10:57,440 --> 00:11:00,640
any other industry right

00:10:58,880 --> 00:11:01,920
how do we address these so that we can

00:11:00,640 --> 00:11:03,839
focus even more

00:11:01,920 --> 00:11:05,040
on the core domain or the integration

00:11:03,839 --> 00:11:07,760
domain to drive

00:11:05,040 --> 00:11:09,040
value so there's two ways of solving

00:11:07,760 --> 00:11:12,640
this one is

00:11:09,040 --> 00:11:14,640
um through application or language

00:11:12,640 --> 00:11:15,200
specific library so we can say okay you

00:11:14,640 --> 00:11:18,000
know what

00:11:15,200 --> 00:11:18,800
there's a a a spring boot library or a

00:11:18,000 --> 00:11:20,800
dot net

00:11:18,800 --> 00:11:22,480
core library that solves security and it

00:11:20,800 --> 00:11:23,920
solves tracing

00:11:22,480 --> 00:11:25,279
so we're going to mandate that all our

00:11:23,920 --> 00:11:26,079
applications are going to be developed

00:11:25,279 --> 00:11:27,279
in these two li

00:11:26,079 --> 00:11:29,920
in this one language and we're going to

00:11:27,279 --> 00:11:32,480
use this library you've solved it

00:11:29,920 --> 00:11:34,160
but you've kind of gone against the idea

00:11:32,480 --> 00:11:35,200
of containerization and rapid

00:11:34,160 --> 00:11:37,680
prototyping

00:11:35,200 --> 00:11:39,040
because and with microservices because

00:11:37,680 --> 00:11:42,160
the idea is that

00:11:39,040 --> 00:11:42,720
you should be able to experiment easily

00:11:42,160 --> 00:11:44,399
to say

00:11:42,720 --> 00:11:46,640
maybe this one particular component

00:11:44,399 --> 00:11:48,720
would be best implemented in this other

00:11:46,640 --> 00:11:50,560
language or this other framework

00:11:48,720 --> 00:11:52,560
and you can do that now if you've chosen

00:11:50,560 --> 00:11:55,120
to solve these generic cross-cutting

00:11:52,560 --> 00:11:57,440
concerns through a library

00:11:55,120 --> 00:11:58,240
so the other way to solve it is through

00:11:57,440 --> 00:12:01,360
service mesh

00:11:58,240 --> 00:12:02,320
and for that we've chosen to use kuma so

00:12:01,360 --> 00:12:05,040
what this does is

00:12:02,320 --> 00:12:06,639
it solves those concerns just the same

00:12:05,040 --> 00:12:09,279
but in a way that is independent

00:12:06,639 --> 00:12:11,200
of the language implementation framework

00:12:09,279 --> 00:12:14,240
anything that the actual

00:12:11,200 --> 00:12:16,000
workloads are implemented in and so

00:12:14,240 --> 00:12:19,120
this is the decision that we made at

00:12:16,000 --> 00:12:21,040
tavros and we'll get into that now

00:12:19,120 --> 00:12:22,399
so you know given the rise that we've

00:12:21,040 --> 00:12:23,920
seen obviously because we're in this

00:12:22,399 --> 00:12:26,560
industry

00:12:23,920 --> 00:12:27,680
of enterprise integration we've seen a

00:12:26,560 --> 00:12:30,639
clear demand

00:12:27,680 --> 00:12:32,160
in in uh continuing to grow demand for

00:12:30,639 --> 00:12:33,200
an integration platform that solves a

00:12:32,160 --> 00:12:36,399
lot of these

00:12:33,200 --> 00:12:38,399
uh you know kind of generic concerns for

00:12:36,399 --> 00:12:39,680
them because as as more off-the-shelf

00:12:38,399 --> 00:12:42,639
products become available

00:12:39,680 --> 00:12:44,399
and as you know we kind of digitalize

00:12:42,639 --> 00:12:46,079
ourselves as a society more and more

00:12:44,399 --> 00:12:46,639
these companies are figuring that hey

00:12:46,079 --> 00:12:49,120
maybe i

00:12:46,639 --> 00:12:50,399
really should only spend my time on what

00:12:49,120 --> 00:12:52,480
makes me

00:12:50,399 --> 00:12:53,920
you know better than my competitors

00:12:52,480 --> 00:12:56,800
instead of trying to solve

00:12:53,920 --> 00:12:58,240
logging and tracing and security over

00:12:56,800 --> 00:13:00,079
and over again because that's what we

00:12:58,240 --> 00:13:03,279
find as a consulting companies are

00:13:00,079 --> 00:13:04,800
we end up solving observability in 10

00:13:03,279 --> 00:13:06,160
different ways and 10 different clients

00:13:04,800 --> 00:13:09,200
because they try to do it

00:13:06,160 --> 00:13:10,079
on their own way not to say that that's

00:13:09,200 --> 00:13:13,360
bad but that's

00:13:10,079 --> 00:13:15,360
not those are not the the main

00:13:13,360 --> 00:13:16,959
you know the principal drivers of value

00:13:15,360 --> 00:13:19,279
for this company so that's not where

00:13:16,959 --> 00:13:21,920
they should be spending their time

00:13:19,279 --> 00:13:23,839
so we committed to tabras which is our

00:13:21,920 --> 00:13:26,000
enterprise integration platform

00:13:23,839 --> 00:13:27,839
uh writing and orchestration and data

00:13:26,000 --> 00:13:29,079
transformation are at the heart of it

00:13:27,839 --> 00:13:31,839
but we also wanted to make

00:13:29,079 --> 00:13:33,440
containerization uh important because

00:13:31,839 --> 00:13:35,680
we didn't want to be that platform that

00:13:33,440 --> 00:13:37,519
says hey only if you use our engine and

00:13:35,680 --> 00:13:39,360
our data transformation framework can

00:13:37,519 --> 00:13:41,040
you deploy to our platform if you're not

00:13:39,360 --> 00:13:42,639
using that then you can use it you have

00:13:41,040 --> 00:13:43,680
to use a different platform for your

00:13:42,639 --> 00:13:45,040
other workloads

00:13:43,680 --> 00:13:47,199
and we know some platforms that are like

00:13:45,040 --> 00:13:50,480
that and we find them to be

00:13:47,199 --> 00:13:51,040
you know pretty limiting so what we want

00:13:50,480 --> 00:13:53,760
to do

00:13:51,040 --> 00:13:55,360
is make sure that whatever choices we

00:13:53,760 --> 00:13:56,560
made to address some of these concerns

00:13:55,360 --> 00:13:58,720
for our customers

00:13:56,560 --> 00:14:00,320
that they were being addressed in a way

00:13:58,720 --> 00:14:01,120
that was independent of the language and

00:14:00,320 --> 00:14:03,120
then the framework

00:14:01,120 --> 00:14:04,639
and so that's what we achieved through

00:14:03,120 --> 00:14:06,320
service mesh and through kuma like our

00:14:04,639 --> 00:14:08,000
explanations before

00:14:06,320 --> 00:14:09,760
and then we just chose open source

00:14:08,000 --> 00:14:11,440
components to address other

00:14:09,760 --> 00:14:13,199
uh these concerns right so like

00:14:11,440 --> 00:14:14,399
observability security and continuous

00:14:13,199 --> 00:14:16,240
delivery

00:14:14,399 --> 00:14:17,440
this is a pretty high level overview of

00:14:16,240 --> 00:14:19,120
what tavros is

00:14:17,440 --> 00:14:21,279
uh so on the top right for example we

00:14:19,120 --> 00:14:22,079
have our observability components on the

00:14:21,279 --> 00:14:23,600
top

00:14:22,079 --> 00:14:25,519
on the bottom right we have some of the

00:14:23,600 --> 00:14:28,480
other ones like he clocked for security

00:14:25,519 --> 00:14:30,079
sonar cube for static code analysis

00:14:28,480 --> 00:14:32,000
things like that on the left

00:14:30,079 --> 00:14:33,839
we have jenkins and flux for example

00:14:32,000 --> 00:14:35,279
driven by git

00:14:33,839 --> 00:14:36,959
so this is kind of git ops and

00:14:35,279 --> 00:14:39,519
continuous delivery

00:14:36,959 --> 00:14:41,120
uh this provides get ups and continues

00:14:39,519 --> 00:14:42,000
delivery for our platform and for our

00:14:41,120 --> 00:14:44,160
workloads

00:14:42,000 --> 00:14:45,839
but in the middle here is what we have

00:14:44,160 --> 00:14:47,519
is where we have the

00:14:45,839 --> 00:14:49,279
application workloads they're fronted by

00:14:47,519 --> 00:14:51,600
kong as our api manager

00:14:49,279 --> 00:14:52,480
and load balancer and kuma as our

00:14:51,600 --> 00:14:54,320
service mesh

00:14:52,480 --> 00:14:55,839
to provide a lot of these generic

00:14:54,320 --> 00:14:57,440
cross-cutting concerns that we

00:14:55,839 --> 00:14:58,880
that we talked about in a way that is

00:14:57,440 --> 00:15:00,959
independent of the implementation

00:14:58,880 --> 00:15:03,279
language or framework

00:15:00,959 --> 00:15:04,639
um so what it what that ends up meaning

00:15:03,279 --> 00:15:07,040
for us is that we have this

00:15:04,639 --> 00:15:08,720
generic workload that there's an

00:15:07,040 --> 00:15:09,839
application in whatever language and

00:15:08,720 --> 00:15:11,680
then there's scuma

00:15:09,839 --> 00:15:13,199
in this particular diagram we're

00:15:11,680 --> 00:15:13,920
highlighting observability so we're

00:15:13,199 --> 00:15:15,519
saying hey

00:15:13,920 --> 00:15:17,120
regardless of where or how you

00:15:15,519 --> 00:15:18,959
implemented your application kuma is

00:15:17,120 --> 00:15:21,600
going to do observability for you

00:15:18,959 --> 00:15:23,360
if your application happens to be aware

00:15:21,600 --> 00:15:25,600
of distributed tracing

00:15:23,360 --> 00:15:27,519
then you can augment what kuma offers

00:15:25,600 --> 00:15:31,040
with application specific tracing

00:15:27,519 --> 00:15:33,279
but if it doesn't no worries a generic

00:15:31,040 --> 00:15:34,560
workload will still participate in your

00:15:33,279 --> 00:15:38,160
distributed tracing

00:15:34,560 --> 00:15:39,920
because of cool if you

00:15:38,160 --> 00:15:41,199
have an integration workload and you go

00:15:39,920 --> 00:15:42,800
with our framework

00:15:41,199 --> 00:15:44,639
then you'll get some of this kind of

00:15:42,800 --> 00:15:47,040
application augmented data

00:15:44,639 --> 00:15:48,880
uh we've used it we've chosen camo and

00:15:47,040 --> 00:15:50,800
data sonnet for our engine and our data

00:15:48,880 --> 00:15:54,000
transformation and open tracing for

00:15:50,800 --> 00:15:57,279
our um distributed tracing and process

00:15:54,000 --> 00:15:58,399
framework so this will automatically be

00:15:57,279 --> 00:16:00,480
set up in a tower

00:15:58,399 --> 00:16:02,000
integration application and so kuma is

00:16:00,480 --> 00:16:03,519
going to do what it does with

00:16:02,000 --> 00:16:04,480
distributed tracing regardless of the

00:16:03,519 --> 00:16:06,320
type of app

00:16:04,480 --> 00:16:08,000
but then because this is kind of

00:16:06,320 --> 00:16:10,959
specific to top rows you'll get some

00:16:08,000 --> 00:16:11,680
application level you know tracing

00:16:10,959 --> 00:16:14,000
information

00:16:11,680 --> 00:16:15,839
like the step in the route in your

00:16:14,000 --> 00:16:17,680
integration flows

00:16:15,839 --> 00:16:19,519
and then you can do custom application

00:16:17,680 --> 00:16:21,920
specific context diagnostic

00:16:19,519 --> 00:16:23,040
tags and things like that but the whole

00:16:21,920 --> 00:16:26,720
point of all of this

00:16:23,040 --> 00:16:30,079
again is to address

00:16:26,720 --> 00:16:32,320
these essential but supporting concerns

00:16:30,079 --> 00:16:35,360
of software so the the great designers

00:16:32,320 --> 00:16:37,920
so that the application developers can

00:16:35,360 --> 00:16:39,120
own can can focus only on the

00:16:37,920 --> 00:16:43,040
application

00:16:39,120 --> 00:16:45,279
level uh um you know concern so they can

00:16:43,040 --> 00:16:46,240
actually get to the va to the part that

00:16:45,279 --> 00:16:49,279
drives value

00:16:46,240 --> 00:16:50,639
in their business so they can so we can

00:16:49,279 --> 00:16:52,000
move that responsibility from the

00:16:50,639 --> 00:16:55,440
application developers

00:16:52,000 --> 00:16:58,480
to the platform so talking about

00:16:55,440 --> 00:17:01,839
kuma uh specifically um

00:16:58,480 --> 00:17:03,040
what we do in tavros is we have you know

00:17:01,839 --> 00:17:05,039
designated

00:17:03,040 --> 00:17:06,640
namespace environments for workloads

00:17:05,039 --> 00:17:08,480
anytime there's a deployment in one of

00:17:06,640 --> 00:17:09,919
these namespaces you'll automatically

00:17:08,480 --> 00:17:11,039
get some policies applied to your

00:17:09,919 --> 00:17:12,880
application again

00:17:11,039 --> 00:17:14,079
so that the application developer

00:17:12,880 --> 00:17:16,160
transparently get

00:17:14,079 --> 00:17:17,600
transparently gets all this value

00:17:16,160 --> 00:17:18,079
without really thinking about how it's

00:17:17,600 --> 00:17:20,480
installed

00:17:18,079 --> 00:17:22,319
and configured etc so what happens is

00:17:20,480 --> 00:17:24,319
this on as soon as an application is

00:17:22,319 --> 00:17:25,839
installed is deployed into one of these

00:17:24,319 --> 00:17:27,839
environments they'll automatically get a

00:17:25,839 --> 00:17:30,480
tracing policy

00:17:27,839 --> 00:17:32,160
the kuma is going to start adding

00:17:30,480 --> 00:17:35,200
tracing information for every incoming

00:17:32,160 --> 00:17:36,880
request and every outgoing request

00:17:35,200 --> 00:17:38,960
if this application happens to be one of

00:17:36,880 --> 00:17:40,160
the integration an integration workload

00:17:38,960 --> 00:17:42,400
from our framework then

00:17:40,160 --> 00:17:43,360
you'll get that optional application

00:17:42,400 --> 00:17:46,480
level

00:17:43,360 --> 00:17:50,559
um data but again if it's not no worries

00:17:46,480 --> 00:17:52,400
you'll you still have the benefits of

00:17:50,559 --> 00:17:54,320
getting these cross-cutting concerns

00:17:52,400 --> 00:17:55,919
addressed because of kuma working

00:17:54,320 --> 00:17:58,880
outside of your application

00:17:55,919 --> 00:18:00,640
language and so in our demo what we have

00:17:58,880 --> 00:18:02,320
here is for example

00:18:00,640 --> 00:18:04,320
this is our logical structure right so

00:18:02,320 --> 00:18:07,200
we have kong being the

00:18:04,320 --> 00:18:09,120
load balancer the the ingress basically

00:18:07,200 --> 00:18:09,760
then you have crm mobile and crm

00:18:09,120 --> 00:18:12,400
conductor

00:18:09,760 --> 00:18:14,400
implemented in a language different than

00:18:12,400 --> 00:18:16,400
our integration framework

00:18:14,400 --> 00:18:18,320
it could be net could be you know

00:18:16,400 --> 00:18:20,400
anything really

00:18:18,320 --> 00:18:22,559
so you can imagine crm mobile doing some

00:18:20,400 --> 00:18:24,880
mobile specific transformations and crm

00:18:22,559 --> 00:18:27,919
conductor is basically an orchestrator

00:18:24,880 --> 00:18:30,080
that goes into two integration specific

00:18:27,919 --> 00:18:31,600
applications one is crm salesforce that

00:18:30,080 --> 00:18:33,120
goes to talk to salesforce

00:18:31,600 --> 00:18:35,200
and the other one is the database that

00:18:33,120 --> 00:18:37,039
talks to a database

00:18:35,200 --> 00:18:38,880
the idea is that you have some customer

00:18:37,039 --> 00:18:40,160
data in both of these sources and you

00:18:38,880 --> 00:18:42,160
want to compose them

00:18:40,160 --> 00:18:44,400
for you know displaying them in a mobile

00:18:42,160 --> 00:18:47,200
application

00:18:44,400 --> 00:18:47,679
um and so what ends up happening once

00:18:47,200 --> 00:18:49,600
once

00:18:47,679 --> 00:18:51,600
you know kuma is involved and all this

00:18:49,600 --> 00:18:54,000
tracing information starts gets

00:18:51,600 --> 00:18:55,760
it starts being gathered and and

00:18:54,000 --> 00:18:56,240
reported is you end up with a graph like

00:18:55,760 --> 00:18:57,919
this

00:18:56,240 --> 00:19:00,000
in in a system like jager which is the

00:18:57,919 --> 00:19:01,600
distributed tracing system that we

00:19:00,000 --> 00:19:02,960
install and configure automatically for

00:19:01,600 --> 00:19:05,039
unitabros

00:19:02,960 --> 00:19:06,960
um so you can see it's almost a

00:19:05,039 --> 00:19:08,720
one-to-one representation of our logical

00:19:06,960 --> 00:19:11,280
understanding so you have kong

00:19:08,720 --> 00:19:11,840
crm mobile conductor and then the two

00:19:11,280 --> 00:19:14,320
one for

00:19:11,840 --> 00:19:16,000
each implementation with their

00:19:14,320 --> 00:19:20,320
integration specific

00:19:16,000 --> 00:19:22,640
uh um you know applications

00:19:20,320 --> 00:19:24,240
and so what this does and this is just a

00:19:22,640 --> 00:19:26,799
general point on observability

00:19:24,240 --> 00:19:28,160
is because we've adopted microservices

00:19:26,799 --> 00:19:31,679
as an architectural style

00:19:28,160 --> 00:19:34,880
across you know basically in

00:19:31,679 --> 00:19:36,720
the whole industry um

00:19:34,880 --> 00:19:38,240
you start needing these sorts of tools

00:19:36,720 --> 00:19:41,280
you start needing

00:19:38,240 --> 00:19:42,160
graphs in in in charts in order to make

00:19:41,280 --> 00:19:44,000
sense out of

00:19:42,160 --> 00:19:46,160
dozens and hundreds of services you need

00:19:44,000 --> 00:19:47,679
to start being able to

00:19:46,160 --> 00:19:49,760
you need to start being able to have

00:19:47,679 --> 00:19:51,919
analysis root cause analysis latency

00:19:49,760 --> 00:19:52,559
analysis figuring out what sort of stuck

00:19:51,919 --> 00:19:54,720
to

00:19:52,559 --> 00:19:56,799
what other services why this particular

00:19:54,720 --> 00:19:59,360
transaction failed where did it fail

00:19:56,799 --> 00:20:00,720
things things of that nature so you get

00:19:59,360 --> 00:20:03,200
this for free in tavros

00:20:00,720 --> 00:20:04,720
because of kuma's uh you know tracing

00:20:03,200 --> 00:20:07,120
policy and its ability to work

00:20:04,720 --> 00:20:09,440
regardless of the implementation

00:20:07,120 --> 00:20:10,559
this is another example for that we have

00:20:09,440 --> 00:20:14,000
here so if you see

00:20:10,559 --> 00:20:16,799
here in the middle we have crm database

00:20:14,000 --> 00:20:18,159
and this is again because the crm

00:20:16,799 --> 00:20:21,679
database

00:20:18,159 --> 00:20:25,039
workload was in our integration specific

00:20:21,679 --> 00:20:28,000
uh um framework we get

00:20:25,039 --> 00:20:28,880
application level tracing data so here

00:20:28,000 --> 00:20:31,360
we have

00:20:28,880 --> 00:20:33,919
data around a set header operation or a

00:20:31,360 --> 00:20:35,919
processing operation

00:20:33,919 --> 00:20:37,120
here we have a logger we have a delay

00:20:35,919 --> 00:20:39,679
things like that

00:20:37,120 --> 00:20:40,799
so the idea is that when you have an

00:20:39,679 --> 00:20:43,520
application that

00:20:40,799 --> 00:20:44,880
can ha can augment what kuma can do

00:20:43,520 --> 00:20:46,480
great but if not

00:20:44,880 --> 00:20:48,960
we still have a conductor here we still

00:20:46,480 --> 00:20:50,720
have mobile we still understand

00:20:48,960 --> 00:20:52,720
what is actually going through our

00:20:50,720 --> 00:20:54,080
integration stack through our iet

00:20:52,720 --> 00:20:55,520
landscape

00:20:54,080 --> 00:20:57,440
so that is the value that we needed to

00:20:55,520 --> 00:20:59,120
achieve for our customers

00:20:57,440 --> 00:21:02,400
and that we wouldn't have been able to

00:20:59,120 --> 00:21:04,080
without something like kuma

00:21:02,400 --> 00:21:05,440
when we tie this into your log

00:21:04,080 --> 00:21:06,880
aggregation system

00:21:05,440 --> 00:21:08,640
like we've done between jaeger and

00:21:06,880 --> 00:21:09,520
elastic you can do a lot of neat things

00:21:08,640 --> 00:21:11,440
like

00:21:09,520 --> 00:21:13,600
correlating your traces with your logs

00:21:11,440 --> 00:21:15,520
doing like we said all these root cause

00:21:13,600 --> 00:21:16,720
analysis latency analysis you can start

00:21:15,520 --> 00:21:19,360
doing trend

00:21:16,720 --> 00:21:20,799
uh forecasts and things of that nature

00:21:19,360 --> 00:21:22,960
you can start seeing you know

00:21:20,799 --> 00:21:25,760
your worst offenders and sorts of errors

00:21:22,960 --> 00:21:28,480
and you know in one single pane of glass

00:21:25,760 --> 00:21:30,000
navigate from a high level dashboard or

00:21:28,480 --> 00:21:30,720
who's been having more errors in the

00:21:30,000 --> 00:21:33,039
last

00:21:30,720 --> 00:21:34,080
you know week to specific error that has

00:21:33,039 --> 00:21:37,200
been showing up

00:21:34,080 --> 00:21:37,840
you know in in a certain percentage of

00:21:37,200 --> 00:21:40,320
your calls

00:21:37,840 --> 00:21:40,320
excuse me

00:21:41,760 --> 00:21:45,440
okay so that's observability the second

00:21:43,760 --> 00:21:48,720
one that i wanted to highlight

00:21:45,440 --> 00:21:50,480
let me do a quick time check here

00:21:48,720 --> 00:21:51,840
i'm over time already okay so the other

00:21:50,480 --> 00:21:54,320
one that i wanted to highlight is mutual

00:21:51,840 --> 00:21:56,559
tls and this is another one that we do

00:21:54,320 --> 00:21:59,120
by default in tabros uh which is

00:21:56,559 --> 00:22:00,960
basically any deployment that

00:21:59,120 --> 00:22:02,480
is any any workload that is deployed

00:22:00,960 --> 00:22:02,960
into one of the environments that we

00:22:02,480 --> 00:22:05,440
manage

00:22:02,960 --> 00:22:07,360
through mesh through kuma service mesh

00:22:05,440 --> 00:22:09,840
will automatically also be enrolled

00:22:07,360 --> 00:22:11,440
in mutual tls kong sits in the middle

00:22:09,840 --> 00:22:14,080
because it needs to

00:22:11,440 --> 00:22:15,919
take in requests externally obviously

00:22:14,080 --> 00:22:17,919
but anything from that point on

00:22:15,919 --> 00:22:21,440
needs to be in this trusted environment

00:22:17,919 --> 00:22:24,159
it needs to have a certificate

00:22:21,440 --> 00:22:25,520
provided by kuma so we transparently

00:22:24,159 --> 00:22:27,039
provide all this information your

00:22:25,520 --> 00:22:28,720
developers no longer have to worry about

00:22:27,039 --> 00:22:30,080
certificate authorities certificate

00:22:28,720 --> 00:22:31,760
signing requests

00:22:30,080 --> 00:22:35,120
rotating certificates all the stuff that

00:22:31,760 --> 00:22:38,840
it's really really hard to do really

00:22:35,120 --> 00:22:41,679
gets addressed

00:22:38,840 --> 00:22:43,919
transparently by tavros through kuma for

00:22:41,679 --> 00:22:46,080
the developer again to only have to

00:22:43,919 --> 00:22:46,960
worry about that application level logic

00:22:46,080 --> 00:22:49,120
about

00:22:46,960 --> 00:22:50,559
really driving business value for that

00:22:49,120 --> 00:22:51,919
company they don't have to worry about

00:22:50,559 --> 00:22:53,679
the stuff

00:22:51,919 --> 00:22:55,679
these are those generic things that we

00:22:53,679 --> 00:22:58,240
wanted to address and we're able to

00:22:55,679 --> 00:22:59,280
we're able to because of kuma and this

00:22:58,240 --> 00:23:01,919
allows us to

00:22:59,280 --> 00:23:02,400
provide things like zero trust security

00:23:01,919 --> 00:23:04,799
um

00:23:02,400 --> 00:23:06,080
and extending that to open policy agent

00:23:04,799 --> 00:23:07,600
we can say

00:23:06,080 --> 00:23:08,799
hey not only are we providing the

00:23:07,600 --> 00:23:09,360
security but we're doing it in a way

00:23:08,799 --> 00:23:11,039
that is so

00:23:09,360 --> 00:23:12,640
simple to understand and configure

00:23:11,039 --> 00:23:14,559
through you know declarative

00:23:12,640 --> 00:23:16,559
configurations that say

00:23:14,559 --> 00:23:18,080
you know all these services must be in a

00:23:16,559 --> 00:23:21,280
mesh and only

00:23:18,080 --> 00:23:22,720
a and b can talk to c and further than

00:23:21,280 --> 00:23:25,280
that we need to

00:23:22,720 --> 00:23:27,440
uh make sure that a particular oauth

00:23:25,280 --> 00:23:28,720
scope is available when this other one

00:23:27,440 --> 00:23:30,720
calls that other one

00:23:28,720 --> 00:23:32,720
and so it becomes a place for you to

00:23:30,720 --> 00:23:35,840
govern in a single

00:23:32,720 --> 00:23:37,520
easy to understand declarative way

00:23:35,840 --> 00:23:39,360
exactly what should be going on

00:23:37,520 --> 00:23:40,880
internally in order to provide an easy

00:23:39,360 --> 00:23:44,159
to consume and manage

00:23:40,880 --> 00:23:45,600
zero trust security so like i said i'm

00:23:44,159 --> 00:23:47,440
basically out of time so i'm running

00:23:45,600 --> 00:23:48,880
through this last slide that kind of

00:23:47,440 --> 00:23:50,799
does it all for me i think i'll be

00:23:48,880 --> 00:23:51,919
taking questions now these are some

00:23:50,799 --> 00:23:53,200
links that i'm

00:23:51,919 --> 00:23:54,559
putting out for you guys in case you're

00:23:53,200 --> 00:23:55,120
interested in tavros and the work we're

00:23:54,559 --> 00:23:59,200
doing

00:23:55,120 --> 00:23:59,200

YouTube URL: https://www.youtube.com/watch?v=UI62aCutXdY


