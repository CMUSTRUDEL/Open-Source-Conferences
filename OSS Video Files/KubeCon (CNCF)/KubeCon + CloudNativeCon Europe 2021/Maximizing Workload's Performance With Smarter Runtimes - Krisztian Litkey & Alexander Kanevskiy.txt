Title: Maximizing Workload's Performance With Smarter Runtimes - Krisztian Litkey & Alexander Kanevskiy
Publication date: 2021-05-09
Playlist: KubeCon + CloudNativeCon Europe 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Maximizing Workload's Performance With Smarter Runtimes - Krisztian Litkey & Alexander Kanevskiy, Intel

Mitigating noisy neighbours in the world of containers is not an easy task. There are several solutions exists and many of those have own limitations. This presentation will be focusing on exploring new ways of innovations for container runtimes that helps get maximum performance and resource utilisation without modifications of the workloads. In this talk we are planning to briefly cover existing extension points for containerd and CRI-O, talk about new ideas from NRI proposal, as well as covering evolution of dynamic resource usage optimisations in our project CRI-Resource-Manager. We want to share our experience on dealing with heterogenous CPU resources, multi-tiered Memory, Caches, Memory Bandwidth and Block I/O usage. We want to demonstrate how using various metrics and hints provided by Linux kernel can lead to improvements of workload performance and dynamic hardware resource utilisation optimisations.
Captions: 
	00:00:00,640 --> 00:00:05,680
hello kubecon welcome

00:00:03,040 --> 00:00:07,359
to our session i'm alexander kaninsky

00:00:05,680 --> 00:00:10,400
i'm cloud software architect

00:00:07,359 --> 00:00:11,120
working for intel and today with my

00:00:10,400 --> 00:00:12,719
colleague

00:00:11,120 --> 00:00:16,320
we are going to talk about something

00:00:12,719 --> 00:00:19,359
interesting in the run times track

00:00:16,320 --> 00:00:21,840
hello cubecon my name is christian litke

00:00:19,359 --> 00:00:24,320
i work for intel finland as a linux and

00:00:21,840 --> 00:00:26,320
cloud software engineer

00:00:24,320 --> 00:00:28,640
maximizing workloads performance with

00:00:26,320 --> 00:00:30,480
smarter runtimes

00:00:28,640 --> 00:00:33,040
we will take a look at performance

00:00:30,480 --> 00:00:34,079
optimization how kubernetes models

00:00:33,040 --> 00:00:36,480
hardware

00:00:34,079 --> 00:00:38,320
detour into hardware domains and then

00:00:36,480 --> 00:00:40,879
talk about smart runtimes

00:00:38,320 --> 00:00:42,800
so let me first start with achieving my

00:00:40,879 --> 00:00:45,600
performance optimization

00:00:42,800 --> 00:00:47,200
comes down to a very known problem of

00:00:45,600 --> 00:00:49,520
noisy neighbors

00:00:47,200 --> 00:00:52,079
we all have dozens of hundreds of

00:00:49,520 --> 00:00:54,399
workloads running now and

00:00:52,079 --> 00:00:55,760
and all of those workloads they have a

00:00:54,399 --> 00:00:59,120
different characteristics

00:00:55,760 --> 00:01:01,520
different life cycles and so on

00:00:59,120 --> 00:01:02,480
so one thing which i want to say in the

00:01:01,520 --> 00:01:04,799
very beginning

00:01:02,480 --> 00:01:06,880
the silver moon doesn't exist even

00:01:04,799 --> 00:01:07,920
though if you have some good algorithms

00:01:06,880 --> 00:01:10,400
to

00:01:07,920 --> 00:01:11,200
optimize one set of workloads most

00:01:10,400 --> 00:01:14,159
probably for

00:01:11,200 --> 00:01:16,560
ourselves it will have differences and

00:01:14,159 --> 00:01:19,600
the reason for that is what

00:01:16,560 --> 00:01:23,200
like we all have differences in the cpus

00:01:19,600 --> 00:01:25,439
caches memory and our hardware resources

00:01:23,200 --> 00:01:27,680
when usage of patterns of those

00:01:25,439 --> 00:01:30,880
resources also differs

00:01:27,680 --> 00:01:31,759
what is important is what you need to

00:01:30,880 --> 00:01:34,479
understand

00:01:31,759 --> 00:01:35,200
how those resources are used how you can

00:01:34,479 --> 00:01:38,479
measure them

00:01:35,200 --> 00:01:41,439
and how you can react in those events of

00:01:38,479 --> 00:01:44,720
the life cycle of those workloads

00:01:41,439 --> 00:01:45,600
today in our scope is just a container

00:01:44,720 --> 00:01:48,399
runtimes

00:01:45,600 --> 00:01:48,960
dryer container b and some interfaces

00:01:48,399 --> 00:01:51,759
waters

00:01:48,960 --> 00:01:53,360
connecting roads pieces together and

00:01:51,759 --> 00:01:57,119
even though

00:01:53,360 --> 00:02:01,119
here i'm talking about theory of things

00:01:57,119 --> 00:02:02,159
we we have a project which is called cri

00:02:01,119 --> 00:02:05,680
resource manager

00:02:02,159 --> 00:02:09,440
where we validated most of our materials

00:02:05,680 --> 00:02:13,200
theories and we have practical examples

00:02:09,440 --> 00:02:15,200
of what can be achieved by extending the

00:02:13,200 --> 00:02:18,560
runtimes

00:02:15,200 --> 00:02:20,959
but let's talk about

00:02:18,560 --> 00:02:22,400
how the resources are recognized how we

00:02:20,959 --> 00:02:26,480
can

00:02:22,400 --> 00:02:30,080
look at them in our kubernetes world

00:02:26,480 --> 00:02:30,480
where pristine and vanilla installation

00:02:30,080 --> 00:02:33,040
of

00:02:30,480 --> 00:02:34,879
kubernetes you have a very simplified

00:02:33,040 --> 00:02:38,480
model of resources

00:02:34,879 --> 00:02:41,840
everything is one big share pool

00:02:38,480 --> 00:02:46,400
every cpu is record every memory region

00:02:41,840 --> 00:02:49,840
is again one big shared set of resources

00:02:46,400 --> 00:02:52,239
and obviously in this setup you are not

00:02:49,840 --> 00:02:53,440
able to provide too much of your

00:02:52,239 --> 00:02:56,560
controls

00:02:53,440 --> 00:02:59,360
you have some priorities but that's it

00:02:56,560 --> 00:03:00,080
to fully embrace our control we need to

00:02:59,360 --> 00:03:02,159
start

00:03:00,080 --> 00:03:03,120
dividing those resources into a smaller

00:03:02,159 --> 00:03:05,120
challenge

00:03:03,120 --> 00:03:07,200
so we can when you can measure and

00:03:05,120 --> 00:03:09,200
control one

00:03:07,200 --> 00:03:10,800
and when people are thinking about the

00:03:09,200 --> 00:03:12,720
divisions of

00:03:10,800 --> 00:03:14,720
standard computer resources where you

00:03:12,720 --> 00:03:18,480
immediately came to the idea of

00:03:14,720 --> 00:03:20,959
no one and this current

00:03:18,480 --> 00:03:22,239
implementation of aluminum kubernetes

00:03:20,959 --> 00:03:25,440
you still

00:03:22,239 --> 00:03:26,159
have one big set of shared resources for

00:03:25,440 --> 00:03:28,159
cpus

00:03:26,159 --> 00:03:29,360
you still have one big shared set of

00:03:28,159 --> 00:03:32,400
memory

00:03:29,360 --> 00:03:34,799
uh regions you have possibility to do

00:03:32,400 --> 00:03:35,440
some exclusive allocations but it's

00:03:34,799 --> 00:03:38,720
still

00:03:35,440 --> 00:03:42,000
limited and even if we look at the

00:03:38,720 --> 00:03:43,360
newer development in white area you have

00:03:42,000 --> 00:03:46,799
some improvements

00:03:43,360 --> 00:03:49,360
you can select multiple memory regions

00:03:46,799 --> 00:03:51,599
but still this memory regions will be

00:03:49,360 --> 00:03:53,920
shared resource between the

00:03:51,599 --> 00:03:55,840
exclusive and shared allocations of

00:03:53,920 --> 00:03:58,720
workloads

00:03:55,840 --> 00:03:59,599
so when we are talking about new one it

00:03:58,720 --> 00:04:03,040
might be not

00:03:59,599 --> 00:04:05,360
enough uh for a boundary

00:04:03,040 --> 00:04:07,680
of division of resources on the system

00:04:05,360 --> 00:04:10,879
and for reason for that we need to

00:04:07,680 --> 00:04:14,080
look more deeper in the history of human

00:04:10,879 --> 00:04:17,120
two decades ago we had a setup

00:04:14,080 --> 00:04:19,280
of a system where you have multiple cpus

00:04:17,120 --> 00:04:20,239
single memory controller you had a

00:04:19,280 --> 00:04:22,320
memory bus

00:04:20,239 --> 00:04:24,400
and when all of those cpus were

00:04:22,320 --> 00:04:26,960
accessing globally

00:04:24,400 --> 00:04:28,000
that was called unifor uniform memory

00:04:26,960 --> 00:04:31,440
access

00:04:28,000 --> 00:04:33,919
or symmetric multi-processing

00:04:31,440 --> 00:04:35,600
however this setup was not really

00:04:33,919 --> 00:04:39,600
scalable

00:04:35,600 --> 00:04:43,520
and when the architecture evolved

00:04:39,600 --> 00:04:45,520
to non-uniform memory access

00:04:43,520 --> 00:04:47,520
what it means it means what you have

00:04:45,520 --> 00:04:49,040
groups of course you have independent

00:04:47,520 --> 00:04:51,280
memory controllers

00:04:49,040 --> 00:04:53,360
you have independent set of memories and

00:04:51,280 --> 00:04:56,720
you have interconnect between those

00:04:53,360 --> 00:04:59,600
groups so each of this group is becoming

00:04:56,720 --> 00:05:01,680
uh norma domain and you can have

00:04:59,600 --> 00:05:03,520
multiple of those domains

00:05:01,680 --> 00:05:05,759
and you can have multiple different

00:05:03,520 --> 00:05:07,280
links between them not necessarily like

00:05:05,759 --> 00:05:10,160
a full mesh interconnect

00:05:07,280 --> 00:05:11,199
but uh different sizes different

00:05:10,160 --> 00:05:13,520
connections

00:05:11,199 --> 00:05:14,639
and that is really model or system

00:05:13,520 --> 00:05:17,600
dependent

00:05:14,639 --> 00:05:18,639
that's why this idea of non-new format

00:05:17,600 --> 00:05:20,960
is coming from

00:05:18,639 --> 00:05:23,120
and when you're optimizing we need to

00:05:20,960 --> 00:05:24,880
understand

00:05:23,120 --> 00:05:26,880
however access between the memory

00:05:24,880 --> 00:05:29,919
regions is actually

00:05:26,880 --> 00:05:32,960
affecting your performance

00:05:29,919 --> 00:05:34,479
but even if we double click on your

00:05:32,960 --> 00:05:36,560
memory

00:05:34,479 --> 00:05:38,240
nowadays when memory became also

00:05:36,560 --> 00:05:41,759
heterogeneous resource

00:05:38,240 --> 00:05:44,800
we all know about a standard memory era

00:05:41,759 --> 00:05:47,440
but when we have already

00:05:44,800 --> 00:05:48,960
other types of memory for example obtain

00:05:47,440 --> 00:05:50,960
persistent memory

00:05:48,960 --> 00:05:54,000
it's still connected to the same memory

00:05:50,960 --> 00:05:57,039
circuits it's still dim interface

00:05:54,000 --> 00:05:59,440
however even though it's seen

00:05:57,039 --> 00:06:02,240
as a normal system memory it has a bit

00:05:59,440 --> 00:06:05,039
different performance characteristics

00:06:02,240 --> 00:06:07,840
and to fully utilize it for applications

00:06:05,039 --> 00:06:07,840
it would be good to

00:06:08,000 --> 00:06:11,280
understand those differences but that's

00:06:10,639 --> 00:06:14,639
not

00:06:11,280 --> 00:06:14,639
our end of story

00:06:14,960 --> 00:06:20,160
very soon we will have another bus which

00:06:18,160 --> 00:06:22,880
is called compute express link

00:06:20,160 --> 00:06:23,199
and one of the profiles for this bus is

00:06:22,880 --> 00:06:26,000
a

00:06:23,199 --> 00:06:26,400
memory extension and by memory it means

00:06:26,000 --> 00:06:28,639
what

00:06:26,400 --> 00:06:30,800
we're going to have a possibility to

00:06:28,639 --> 00:06:32,840
attach additional memory

00:06:30,800 --> 00:06:34,240
uh to the controllers not to the two

00:06:32,840 --> 00:06:36,720
nodes

00:06:34,240 --> 00:06:37,520
and that's not going to be like new

00:06:36,720 --> 00:06:39,840
phone

00:06:37,520 --> 00:06:41,280
type of memory you can have different

00:06:39,840 --> 00:06:43,280
types of memory give us different

00:06:41,280 --> 00:06:46,960
performance characteristics

00:06:43,280 --> 00:06:50,319
this memory can be hot plugged and so on

00:06:46,960 --> 00:06:53,919
so all of these different memory regions

00:06:50,319 --> 00:06:57,360
will be seen in linux as a separate

00:06:53,919 --> 00:06:57,360
newer memory nodes

00:06:58,319 --> 00:07:04,960
so if we double click to

00:07:01,440 --> 00:07:08,400
cpu box we can see what

00:07:04,960 --> 00:07:09,120
like modern cpus have multiple physical

00:07:08,400 --> 00:07:10,319
cores

00:07:09,120 --> 00:07:13,039
why it might be different by the

00:07:10,319 --> 00:07:13,039
frequencies but

00:07:13,120 --> 00:07:17,199
it can be also our differences for

00:07:15,120 --> 00:07:19,599
example with hyperturrets

00:07:17,199 --> 00:07:21,039
so you can have multiple hyperterrors

00:07:19,599 --> 00:07:24,080
per physical core

00:07:21,039 --> 00:07:26,319
and those hyper threads are sharing

00:07:24,080 --> 00:07:27,199
the same resource on the low level

00:07:26,319 --> 00:07:30,319
meaning

00:07:27,199 --> 00:07:33,520
one until two caches

00:07:30,319 --> 00:07:37,840
so one of the division boundaries can be

00:07:33,520 --> 00:07:41,039
also physical core versus uh

00:07:37,840 --> 00:07:41,039
one one hypertron

00:07:41,840 --> 00:07:47,360
we have alpha cash or last level cash

00:07:45,440 --> 00:07:50,240
before you reach for memory

00:07:47,360 --> 00:07:53,120
this already becomes a shared resource

00:07:50,240 --> 00:07:56,879
between multiple cores within the same

00:07:53,120 --> 00:08:00,319
socket or die and

00:07:56,879 --> 00:08:01,759
architecture is not something what is

00:08:00,319 --> 00:08:05,440
studied

00:08:01,759 --> 00:08:08,240
uh the architecture of cpus are evolving

00:08:05,440 --> 00:08:09,280
and in new versions for new generations

00:08:08,240 --> 00:08:12,479
you might have an

00:08:09,280 --> 00:08:14,560
absolutely different split of resources

00:08:12,479 --> 00:08:16,560
like water score like what is the l3

00:08:14,560 --> 00:08:21,120
cash domain and so on

00:08:16,560 --> 00:08:23,759
and that actually also goes to even more

00:08:21,120 --> 00:08:25,520
deeper separation of things so you can

00:08:23,759 --> 00:08:27,759
have

00:08:25,520 --> 00:08:29,520
the means splitted physically or

00:08:27,759 --> 00:08:31,199
logically so for example you can have

00:08:29,520 --> 00:08:34,000
multiple dice per one

00:08:31,199 --> 00:08:34,880
physical package or you might have a

00:08:34,000 --> 00:08:37,519
logical

00:08:34,880 --> 00:08:40,640
pseudonumber clustering within one

00:08:37,519 --> 00:08:44,159
physical package

00:08:40,640 --> 00:08:47,200
so based on red we need to understand

00:08:44,159 --> 00:08:49,680
what linux and actual hardware looks

00:08:47,200 --> 00:08:53,120
like in terms of hierarchy

00:08:49,680 --> 00:08:57,120
so you have physical components like

00:08:53,120 --> 00:09:00,480
sockets or packages in linux terms

00:08:57,120 --> 00:09:04,320
you have dies for multi-ship cpus

00:09:00,480 --> 00:09:07,680
and then you have inside the cpu cores

00:09:04,320 --> 00:09:08,880
and those cpu cores is practically can

00:09:07,680 --> 00:09:12,480
be grouped

00:09:08,880 --> 00:09:16,240
into same some pool or some

00:09:12,480 --> 00:09:20,560
some zone of resources which contains

00:09:16,240 --> 00:09:23,839
cpu caches memory io and so on

00:09:20,560 --> 00:09:25,040
you have possibility to have inside this

00:09:23,839 --> 00:09:28,000
small group

00:09:25,040 --> 00:09:31,200
shared set of resources and exclusively

00:09:28,000 --> 00:09:33,440
allocated set of resources

00:09:31,200 --> 00:09:36,480
and when you can mount your workloads

00:09:33,440 --> 00:09:39,040
into these small groups

00:09:36,480 --> 00:09:41,040
my next problem or next question will be

00:09:39,040 --> 00:09:41,760
of course like what if i have a workload

00:09:41,040 --> 00:09:43,839
which is

00:09:41,760 --> 00:09:45,600
bigger one with small group well you

00:09:43,839 --> 00:09:48,320
still have

00:09:45,600 --> 00:09:48,320
ability to

00:09:48,640 --> 00:09:51,839
group on the higher level so you can

00:09:50,800 --> 00:09:55,120
have a parent

00:09:51,839 --> 00:09:56,880
nodes or parent virtual groups uh which

00:09:55,120 --> 00:09:59,839
spawns across like multiple

00:09:56,880 --> 00:10:01,839
dice into one socket and one you can

00:09:59,839 --> 00:10:02,560
have a proper accounting for all of

00:10:01,839 --> 00:10:04,480
those which is

00:10:02,560 --> 00:10:07,519
practically like some of the resources

00:10:04,480 --> 00:10:10,640
of all the child nodes

00:10:07,519 --> 00:10:11,120
so to reiterate that when we are talking

00:10:10,640 --> 00:10:14,399
about

00:10:11,120 --> 00:10:16,640
resource zones where workloads about

00:10:14,399 --> 00:10:18,160
it's good to have a good understanding

00:10:16,640 --> 00:10:20,880
of what your physical

00:10:18,160 --> 00:10:21,519
layout or system looks like and that

00:10:20,880 --> 00:10:25,279
might be

00:10:21,519 --> 00:10:27,519
a lot different based on generations

00:10:25,279 --> 00:10:29,760
based on the vendors and so on

00:10:27,519 --> 00:10:31,920
because in different generations you

00:10:29,760 --> 00:10:32,720
have differences in how memory series

00:10:31,920 --> 00:10:35,040
are being

00:10:32,720 --> 00:10:36,399
organized and how what caches are

00:10:35,040 --> 00:10:39,680
divided how

00:10:36,399 --> 00:10:42,480
io buses are connected you can have

00:10:39,680 --> 00:10:43,519
different types of memory even though we

00:10:42,480 --> 00:10:47,279
will be connected

00:10:43,519 --> 00:10:48,320
to the same memory controller for linux

00:10:47,279 --> 00:10:51,760
it will be visible

00:10:48,320 --> 00:10:52,399
as separate numbers but what we actually

00:10:51,760 --> 00:10:55,600
want to

00:10:52,399 --> 00:10:58,560
understand as well how will separate

00:10:55,600 --> 00:11:00,000
reported by the linux controller by the

00:10:58,560 --> 00:11:02,399
linux kernel

00:11:00,000 --> 00:11:03,440
numa numbers can be grouped into one

00:11:02,399 --> 00:11:06,560
logical

00:11:03,440 --> 00:11:07,519
and usable resource zone we have

00:11:06,560 --> 00:11:10,000
possibility

00:11:07,519 --> 00:11:10,800
at a moment to say which zone can be

00:11:10,000 --> 00:11:13,200
used but

00:11:10,800 --> 00:11:15,440
what we don't have and this is something

00:11:13,200 --> 00:11:16,959
what i hope will be improved in the next

00:11:15,440 --> 00:11:20,320
years of the linux

00:11:16,959 --> 00:11:23,360
is the ability to control

00:11:20,320 --> 00:11:24,640
how much memory or how much of our

00:11:23,360 --> 00:11:28,320
resources can be used

00:11:24,640 --> 00:11:28,720
per zone for application and when we

00:11:28,320 --> 00:11:31,440
have

00:11:28,720 --> 00:11:32,160
even more harder tasks to understand and

00:11:31,440 --> 00:11:36,079
fix

00:11:32,160 --> 00:11:38,320
is how to understand where lower details

00:11:36,079 --> 00:11:39,519
of a workload for example the working

00:11:38,320 --> 00:11:42,720
set size

00:11:39,519 --> 00:11:46,320
to have a good split of understanding

00:11:42,720 --> 00:11:48,640
what is where what size of a memory

00:11:46,320 --> 00:11:49,680
used by application versions were called

00:11:48,640 --> 00:11:53,279
area of

00:11:49,680 --> 00:11:53,279
for pages to use by application

00:11:53,920 --> 00:12:01,120
so going first

00:11:57,440 --> 00:12:04,959
we have caches we can at one moment

00:12:01,120 --> 00:12:05,920
split one we can assign workloads to the

00:12:04,959 --> 00:12:08,959
caches

00:12:05,920 --> 00:12:12,720
however we have a problem

00:12:08,959 --> 00:12:15,600
where first of all the amount of

00:12:12,720 --> 00:12:16,160
cash classes is limited so you can't

00:12:15,600 --> 00:12:18,800
assign

00:12:16,160 --> 00:12:20,000
each of your container to separate plus

00:12:18,800 --> 00:12:23,440
second

00:12:20,000 --> 00:12:26,639
the configuration of the caches is

00:12:23,440 --> 00:12:28,000
something what is really hardwired

00:12:26,639 --> 00:12:30,160
we need to come up with a good

00:12:28,000 --> 00:12:33,200
abstraction and we think

00:12:30,160 --> 00:12:36,160
what class is one for good abstractions

00:12:33,200 --> 00:12:37,279
what we can use in kubernetes or in cncf

00:12:36,160 --> 00:12:41,040
world

00:12:37,279 --> 00:12:44,560
meaning we have a classes example like

00:12:41,040 --> 00:12:47,920
gold silver bronze and when we have a

00:12:44,560 --> 00:12:50,839
node level mapping between those

00:12:47,920 --> 00:12:52,399
classes to the actual parameters of a

00:12:50,839 --> 00:12:56,000
hardware

00:12:52,399 --> 00:12:59,120
so simplified ui for containers

00:12:56,000 --> 00:13:02,160
keep knowledge on one or level

00:12:59,120 --> 00:13:03,200
and even though if it's done for the

00:13:02,160 --> 00:13:05,440
caches we have

00:13:03,200 --> 00:13:08,079
another resource which is also can

00:13:05,440 --> 00:13:11,360
benefit from the same approach

00:13:08,079 --> 00:13:14,000
and i'm talking here about the blockade

00:13:11,360 --> 00:13:16,160
this is virtual resource known by linux

00:13:14,000 --> 00:13:17,680
kernel where you can define the priority

00:13:16,160 --> 00:13:20,720
sound

00:13:17,680 --> 00:13:21,760
limits for block storage but again like

00:13:20,720 --> 00:13:24,320
multiple

00:13:21,760 --> 00:13:26,160
nodes in the future originals cluster

00:13:24,320 --> 00:13:30,240
might have different configurations

00:13:26,160 --> 00:13:33,360
of storage devices

00:13:30,240 --> 00:13:34,959
you don't need to expose that to a end

00:13:33,360 --> 00:13:36,959
user how to control it

00:13:34,959 --> 00:13:38,959
but what you want to do is again

00:13:36,959 --> 00:13:41,120
probably with class-based

00:13:38,959 --> 00:13:42,560
abstraction for consuming of those

00:13:41,120 --> 00:13:46,320
resources

00:13:42,560 --> 00:13:48,959
and that allows you to again properly

00:13:46,320 --> 00:13:49,680
split and control those resources on

00:13:48,959 --> 00:13:52,240
paranormal

00:13:49,680 --> 00:13:52,240
basis

00:13:53,040 --> 00:13:59,519
so all of this i

00:13:56,560 --> 00:14:01,839
the reason why i talked is what we have

00:13:59,519 --> 00:14:04,320
possibility to divide the resources we

00:14:01,839 --> 00:14:07,040
have present possibility to measure one

00:14:04,320 --> 00:14:09,360
those are vendor-specific but now when

00:14:07,040 --> 00:14:10,880
we have understanding how to divide how

00:14:09,360 --> 00:14:14,320
to measure

00:14:10,880 --> 00:14:18,079
now we need to have a control for it

00:14:14,320 --> 00:14:20,160
so smarter run times ever since its

00:14:18,079 --> 00:14:21,839
introduction kubernetes has enjoyed an

00:14:20,160 --> 00:14:24,639
increasingly wide scale adoption

00:14:21,839 --> 00:14:25,440
across public and private clouds as a

00:14:24,639 --> 00:14:27,279
result

00:14:25,440 --> 00:14:29,120
both the spectrum of workloads and the

00:14:27,279 --> 00:14:30,560
diversity of the cluster hardware is

00:14:29,120 --> 00:14:33,279
rapidly growing

00:14:30,560 --> 00:14:34,320
you have ai databases content streaming

00:14:33,279 --> 00:14:37,600
network function

00:14:34,320 --> 00:14:39,360
virtualization automotive edge

00:14:37,600 --> 00:14:41,279
running anywhere from a virtualized

00:14:39,360 --> 00:14:45,040
generic public

00:14:41,279 --> 00:14:47,040
cloud something like google cloud

00:14:45,040 --> 00:14:48,079
to a bare metal custom cloud with

00:14:47,040 --> 00:14:51,839
accelerators

00:14:48,079 --> 00:14:53,920
for instance 5gh with fpgas

00:14:51,839 --> 00:14:55,440
kubernetes is literally taking over the

00:14:53,920 --> 00:14:58,079
world while this is a

00:14:55,440 --> 00:15:00,880
positive problem it is also causing some

00:14:58,079 --> 00:15:00,880
headache for us

00:15:01,680 --> 00:15:06,000
kubernetes node resource management is

00:15:03,440 --> 00:15:07,839
implemented in cubelet the node agent

00:15:06,000 --> 00:15:10,160
cubelet has a simplistic view and

00:15:07,839 --> 00:15:12,079
limited understanding of the hardware

00:15:10,160 --> 00:15:14,240
moreover it comes with a single

00:15:12,079 --> 00:15:17,839
one-size-fits-all resource algorithm or

00:15:14,240 --> 00:15:17,839
resource allocation algorithm

00:15:17,920 --> 00:15:21,120
now while this algorithm is good for

00:15:19,839 --> 00:15:23,600
many common cases

00:15:21,120 --> 00:15:24,639
critical workloads on bare metal require

00:15:23,600 --> 00:15:26,720
more optimal

00:15:24,639 --> 00:15:28,639
hardware aware resource assignment for

00:15:26,720 --> 00:15:31,279
acceptable performance

00:15:28,639 --> 00:15:31,920
similarly workloads in domain specific

00:15:31,279 --> 00:15:34,399
clusters

00:15:31,920 --> 00:15:35,839
often require custom resource allocation

00:15:34,399 --> 00:15:38,160
logic

00:15:35,839 --> 00:15:40,800
the one-size-fits-all algorithm cannot

00:15:38,160 --> 00:15:43,040
scale to satisfy all these requirements

00:15:40,800 --> 00:15:45,120
we need multiple resource allocation and

00:15:43,040 --> 00:15:48,560
assignment algorithms

00:15:45,120 --> 00:15:50,160
and support for custom logic that sounds

00:15:48,560 --> 00:15:51,759
a little bit like we need support for

00:15:50,160 --> 00:15:55,040
pluggable algorithms

00:15:51,759 --> 00:15:55,920
but where to plug these we have very few

00:15:55,040 --> 00:16:00,959
candidates

00:15:55,920 --> 00:16:00,959
either the cubelet or the runtime itself

00:16:01,120 --> 00:16:04,959
cubelet already hosts one policy so

00:16:03,360 --> 00:16:06,240
should we extend it with pluggable

00:16:04,959 --> 00:16:08,000
policies

00:16:06,240 --> 00:16:09,600
well that would be problematic for many

00:16:08,000 --> 00:16:11,519
reasons

00:16:09,600 --> 00:16:14,160
first of all we would like to keep the

00:16:11,519 --> 00:16:16,240
orchestration hardware agnostic

00:16:14,160 --> 00:16:17,759
and as it is critical infrastructure we

00:16:16,240 --> 00:16:19,199
would like to keep it as simple as

00:16:17,759 --> 00:16:22,000
possible

00:16:19,199 --> 00:16:23,680
a cubelet is already complex adding

00:16:22,000 --> 00:16:26,639
pluggable policies would definitely

00:16:23,680 --> 00:16:29,440
increase its complexity

00:16:26,639 --> 00:16:32,160
luckily another option suggests itself

00:16:29,440 --> 00:16:32,160
the run time

00:16:32,240 --> 00:16:36,560
let's plug custom algorithms to the

00:16:34,240 --> 00:16:38,720
runtime and make it smarter

00:16:36,560 --> 00:16:39,920
the kubernetes apis are predominantly

00:16:38,720 --> 00:16:43,279
declarative

00:16:39,920 --> 00:16:45,680
the user describes what a workload needs

00:16:43,279 --> 00:16:46,800
and orchestration decides how this will

00:16:45,680 --> 00:16:50,000
be achieved

00:16:46,800 --> 00:16:51,839
this is true for the resource api 2.

00:16:50,000 --> 00:16:53,680
container resources are requested in

00:16:51,839 --> 00:16:56,959
abstract terms for instance

00:16:53,680 --> 00:16:59,279
3 000 millicourse and not course 1 3 and

00:16:56,959 --> 00:16:59,279
5.

00:17:00,320 --> 00:17:05,039
but the api between the cubelet and the

00:17:02,399 --> 00:17:06,880
runtime the container runtime interface

00:17:05,039 --> 00:17:08,799
is fully imperative

00:17:06,880 --> 00:17:10,559
it carries concrete resources and

00:17:08,799 --> 00:17:12,720
related parameters

00:17:10,559 --> 00:17:14,559
to bridge this gap the cubelet turns

00:17:12,720 --> 00:17:15,839
abstract resource requirements into

00:17:14,559 --> 00:17:18,319
concrete resource

00:17:15,839 --> 00:17:20,079
assignments using its allocation

00:17:18,319 --> 00:17:23,199
algorithm

00:17:20,079 --> 00:17:25,280
but what would we need instead so

00:17:23,199 --> 00:17:27,280
let's separate the what from the how and

00:17:25,280 --> 00:17:28,960
leave resource requirements unresolved

00:17:27,280 --> 00:17:31,200
in the cubelet

00:17:28,960 --> 00:17:33,039
let's update the cri api to allow

00:17:31,200 --> 00:17:36,000
passing abstract resource requirements

00:17:33,039 --> 00:17:38,080
to the runtime itself

00:17:36,000 --> 00:17:39,840
let's extend the runtime by pluggable

00:17:38,080 --> 00:17:41,520
custom resource allocation and

00:17:39,840 --> 00:17:44,080
assignment algorithms

00:17:41,520 --> 00:17:46,400
and an api that these algorithms can use

00:17:44,080 --> 00:17:48,000
to resolve what spec requirements to

00:17:46,400 --> 00:17:50,160
concrete resources

00:17:48,000 --> 00:17:51,760
in other words let's make the runtime

00:17:50,160 --> 00:17:54,160
smarter

00:17:51,760 --> 00:17:55,679
there already exists an extension point

00:17:54,160 --> 00:17:58,160
for plugging resource allocation

00:17:55,679 --> 00:18:01,440
algorithms into runtimes

00:17:58,160 --> 00:18:05,200
this is nri the node resource interface

00:18:01,440 --> 00:18:08,080
container the subproject in draft status

00:18:05,200 --> 00:18:09,520
it is described as a new interface for

00:18:08,080 --> 00:18:12,799
managing resources

00:18:09,520 --> 00:18:14,720
on a node for pots and containers it was

00:18:12,799 --> 00:18:16,480
largely inspired by the container

00:18:14,720 --> 00:18:18,320
network interface

00:18:16,480 --> 00:18:19,840
which is used by runtimes to handle

00:18:18,320 --> 00:18:22,880
multiple implementations

00:18:19,840 --> 00:18:25,760
of the container network stack

00:18:22,880 --> 00:18:27,760
we share common interest with nri it

00:18:25,760 --> 00:18:29,360
aims improving node resource management

00:18:27,760 --> 00:18:32,080
with a structured api

00:18:29,360 --> 00:18:34,880
and plug-in design for containers we

00:18:32,080 --> 00:18:37,280
would like to do pretty much the same

00:18:34,880 --> 00:18:38,000
it wants additional interfaces to

00:18:37,280 --> 00:18:39,760
customize

00:18:38,000 --> 00:18:43,039
and con a container's runtime

00:18:39,760 --> 00:18:46,000
environment we also would like the same

00:18:43,039 --> 00:18:47,919
nris current focus however is on better

00:18:46,000 --> 00:18:50,400
control and more flexibility for

00:18:47,919 --> 00:18:53,039
injecting devices into containers

00:18:50,400 --> 00:18:55,120
this we would like to extend a bit so

00:18:53,039 --> 00:18:56,880
ideally we would like to make nri

00:18:55,120 --> 00:18:58,240
the primary integration point for

00:18:56,880 --> 00:19:01,039
extending the runtime

00:18:58,240 --> 00:19:03,360
and allow any vendor to plug in their

00:19:01,039 --> 00:19:04,160
any resource allocation and optimization

00:19:03,360 --> 00:19:07,360
algorithm

00:19:04,160 --> 00:19:09,520
so how do we want to extend nri

00:19:07,360 --> 00:19:11,520
well nri tabs into container lifecycle

00:19:09,520 --> 00:19:14,559
events and invokes corresponding

00:19:11,520 --> 00:19:16,160
plugin api functions the plugin receives

00:19:14,559 --> 00:19:17,840
information about the event

00:19:16,160 --> 00:19:20,799
and then it selects and configures

00:19:17,840 --> 00:19:23,280
resources and responds back with data

00:19:20,799 --> 00:19:25,440
about how to set up the container the

00:19:23,280 --> 00:19:28,160
current nri events are creation and

00:19:25,440 --> 00:19:30,000
removal of bots and containers

00:19:28,160 --> 00:19:32,160
to enable more generic support for

00:19:30,000 --> 00:19:35,200
resource optimization algorithms

00:19:32,160 --> 00:19:37,840
nri needs to step into a few more events

00:19:35,200 --> 00:19:39,679
to enable smart algorithms nri needs to

00:19:37,840 --> 00:19:41,679
pass all the necessary information to

00:19:39,679 --> 00:19:44,240
plugins

00:19:41,679 --> 00:19:46,000
to allow proper container setup nri

00:19:44,240 --> 00:19:47,120
plugins needs to be able to pass back

00:19:46,000 --> 00:19:51,440
enough data

00:19:47,120 --> 00:19:51,440
for correct container configuration

00:19:51,600 --> 00:19:55,679
so finally let's look at the plugin

00:19:53,840 --> 00:19:57,440
invocation mechanism

00:19:55,679 --> 00:19:58,880
the current implementation is a hook

00:19:57,440 --> 00:20:01,520
like one shot api

00:19:58,880 --> 00:20:03,360
with a separate exact for every request

00:20:01,520 --> 00:20:04,000
for stateful plugins we need another

00:20:03,360 --> 00:20:06,480
menus

00:20:04,000 --> 00:20:07,840
with minimal overhead probably a proto

00:20:06,480 --> 00:20:11,440
booth based api

00:20:07,840 --> 00:20:13,200
over grpc or ttrpc so eventually we

00:20:11,440 --> 00:20:15,600
would like nri to become the common

00:20:13,200 --> 00:20:17,120
resource integration point for all oci

00:20:15,600 --> 00:20:19,440
compatible runtimes

00:20:17,120 --> 00:20:20,159
therefore the nri core and data

00:20:19,440 --> 00:20:23,280
structures

00:20:20,159 --> 00:20:25,360
need to be run time agnostic adaptation

00:20:23,280 --> 00:20:26,000
to any corresponding runtime specific

00:20:25,360 --> 00:20:30,000
bits

00:20:26,000 --> 00:20:30,000
should happen in the runtime itself

00:20:30,480 --> 00:20:37,440
container is already integrated with nri

00:20:33,520 --> 00:20:38,880
but we need to extend on that a bit

00:20:37,440 --> 00:20:40,559
we have to hook into a few more

00:20:38,880 --> 00:20:42,240
additional lifecycle events

00:20:40,559 --> 00:20:44,240
and make sure that all the necessary

00:20:42,240 --> 00:20:46,240
data is passed back and forth to the

00:20:44,240 --> 00:20:47,919
plugins

00:20:46,240 --> 00:20:49,280
also the current code ignores plugin

00:20:47,919 --> 00:20:51,120
replies altogether

00:20:49,280 --> 00:20:52,720
that has to be updated to modify

00:20:51,120 --> 00:20:55,039
containers according to the plugin

00:20:52,720 --> 00:20:56,480
decisions

00:20:55,039 --> 00:20:59,440
once we have ironed out all these

00:20:56,480 --> 00:21:03,840
details with container d we can take

00:20:59,440 --> 00:21:03,840
cryo and integrate it to nri as well

00:21:04,000 --> 00:21:08,159
cri needs to evolve also to provide

00:21:06,080 --> 00:21:09,200
better support for smarter smarter

00:21:08,159 --> 00:21:11,280
runtimes

00:21:09,200 --> 00:21:13,120
smart algorithms need declarative

00:21:11,280 --> 00:21:14,880
resource requirements

00:21:13,120 --> 00:21:17,840
and the separation of what in the

00:21:14,880 --> 00:21:20,480
cubelet from the how in the runtime

00:21:17,840 --> 00:21:22,320
to do this cri needs to pass through

00:21:20,480 --> 00:21:24,640
both spec resource requirements where

00:21:22,320 --> 00:21:26,240
button

00:21:24,640 --> 00:21:28,840
smartel algorithms with better

00:21:26,240 --> 00:21:30,000
efficiency also need a few group

00:21:28,840 --> 00:21:32,480
operations

00:21:30,000 --> 00:21:34,000
vm-based runtimes need full information

00:21:32,480 --> 00:21:37,200
about all container resource

00:21:34,000 --> 00:21:38,960
requirements for sandbox creation

00:21:37,200 --> 00:21:41,039
also to optimize the collocation of

00:21:38,960 --> 00:21:42,799
related containers it is better to get a

00:21:41,039 --> 00:21:46,400
single request for creating all the

00:21:42,799 --> 00:21:48,080
related containers at once

00:21:46,400 --> 00:21:49,600
we also need the ability to update

00:21:48,080 --> 00:21:50,960
multiple containers with a single

00:21:49,600 --> 00:21:53,919
request

00:21:50,960 --> 00:21:56,400
and finally we would like a dedicated

00:21:53,919 --> 00:21:58,320
api for container state monitoring

00:21:56,400 --> 00:22:00,240
we want to allow clients to subscribe

00:21:58,320 --> 00:22:02,320
for content as they change events

00:22:00,240 --> 00:22:04,159
then trigger and deliver notifications

00:22:02,320 --> 00:22:06,559
from the run time when such an event

00:22:04,159 --> 00:22:06,559
occurs

00:22:07,440 --> 00:22:13,520
so based on the things what we just

00:22:11,120 --> 00:22:15,679
provided to you there are three things

00:22:13,520 --> 00:22:18,480
what we want you to take home

00:22:15,679 --> 00:22:18,960
out of this presentation first of all is

00:22:18,480 --> 00:22:22,000
a

00:22:18,960 --> 00:22:22,720
about the hardware a hard drive is

00:22:22,000 --> 00:22:24,720
evolving

00:22:22,720 --> 00:22:26,159
and the hardware is changing all the

00:22:24,720 --> 00:22:28,320
assumptions about how

00:22:26,159 --> 00:22:29,679
hardware works might be changing next

00:22:28,320 --> 00:22:33,120
day

00:22:29,679 --> 00:22:35,200
so it means no one single algorithm

00:22:33,120 --> 00:22:38,240
which will satisfy all we needs

00:22:35,200 --> 00:22:41,360
we need to have a flexibility

00:22:38,240 --> 00:22:44,640
second thing about the kubernetes

00:22:41,360 --> 00:22:48,159
coblet holds the information of what and

00:22:44,640 --> 00:22:48,400
what should be run what is the priority

00:22:48,159 --> 00:22:52,320
of

00:22:48,400 --> 00:22:55,760
things but we need to split

00:22:52,320 --> 00:22:58,799
what and how what

00:22:55,760 --> 00:23:02,240
is about runtimes runtimes now

00:22:58,799 --> 00:23:05,280
contains some information about how

00:23:02,240 --> 00:23:06,559
like linux container window os windows

00:23:05,280 --> 00:23:10,000
is containers

00:23:06,559 --> 00:23:13,280
or vm vm-based containment and so on so

00:23:10,000 --> 00:23:16,559
we want to have runtimes to control

00:23:13,280 --> 00:23:17,600
before how part of how containers are

00:23:16,559 --> 00:23:20,080
run

00:23:17,600 --> 00:23:21,039
and we want to have a plugins in this

00:23:20,080 --> 00:23:24,640
interface

00:23:21,039 --> 00:23:27,120
so what more custom logic and vendor

00:23:24,640 --> 00:23:29,200
specific projects or

00:23:27,120 --> 00:23:31,679
special installation logic can be

00:23:29,200 --> 00:23:31,679
extended

00:23:32,240 --> 00:23:38,799
on web we have reached the end of our

00:23:36,000 --> 00:23:39,679
presentation me and preston available on

00:23:38,799 --> 00:23:42,640
the github

00:23:39,679 --> 00:23:44,400
or kubernetes slug and we are happy to

00:23:42,640 --> 00:23:46,159
talk more and more details about

00:23:44,400 --> 00:23:47,440
all the things what we presented today

00:23:46,159 --> 00:23:49,360
and what we are doing

00:23:47,440 --> 00:23:51,279
for our hardware performance

00:23:49,360 --> 00:23:53,760
actualizations

00:23:51,279 --> 00:23:54,480
we will be available today after the

00:23:53,760 --> 00:23:58,159
sessions

00:23:54,480 --> 00:24:01,200
for live q a so welcome

00:23:58,159 --> 00:24:04,320
and thank you for participating in our

00:24:01,200 --> 00:24:07,360
session today thank you

00:24:04,320 --> 00:24:07,360

YouTube URL: https://www.youtube.com/watch?v=BwQmjunIsFI


