Title: Trust No One: Bringing Confidential Computing to Containers- Samuel Ortiz, Intel & Eric Ernst, Apple
Publication date: 2021-05-09
Playlist: KubeCon + CloudNativeCon Europe 2021
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Trust No One: Bringing Confidential Computing to Containers - Samuel Ortiz, Intel & Eric Ernst, Apple

Today’s containers run in wildly heterogeneous environments. When deployed on multi-tenant clouds, they can span across nodes, regions, and multiple Cloud Service Providers (CSPs) while sharing CSP-owned resources between tenants. In such hostile environments, protecting containers data and code requires full trust on the CSP stack. Confidential computing leverages emerging hardware technologies to build Trusted Execution Environments (TEE) that protect cloud code and data at rest, in transit and in use, allowing tenants to trust no one but themselves. In this presentation, we will describe cloud native gaps for supporting confidential computing through memory encryption, authenticated launch and application attestability. Attendees will learn how secure container runtimes like Kata can close those gaps and leave with a proposed software architecture to bring confidential computing to cloud native workloads.
Captions: 
	00:00:01,920 --> 00:00:06,240
hi everyone

00:00:03,439 --> 00:00:06,720
i'm samuel ortiz from intel and together

00:00:06,240 --> 00:00:08,559
with

00:00:06,720 --> 00:00:10,000
eric ernst from apple we're going to

00:00:08,559 --> 00:00:14,000
talk about

00:00:10,000 --> 00:00:14,000
confidential computing and containers

00:00:14,559 --> 00:00:18,960
so confidential computing um this may

00:00:17,760 --> 00:00:22,640
sound like yet

00:00:18,960 --> 00:00:23,680
another cloud buzzword but we actually

00:00:22,640 --> 00:00:27,039
believe that the

00:00:23,680 --> 00:00:32,000
cloud computing technology is building

00:00:27,039 --> 00:00:34,559
and providing um a way to

00:00:32,000 --> 00:00:36,480
create a very interesting new threat

00:00:34,559 --> 00:00:40,000
model

00:00:36,480 --> 00:00:42,879
so if you look at the at the existing

00:00:40,000 --> 00:00:45,840
trust computing base for a typical guest

00:00:42,879 --> 00:00:45,840
running on the cloud

00:00:46,160 --> 00:00:51,760
it needs it includes sorry the

00:00:49,520 --> 00:00:53,520
all these layers here from hardware to

00:00:51,760 --> 00:00:55,600
software

00:00:53,520 --> 00:00:57,360
including the hypervisor the the host

00:00:55,600 --> 00:00:58,000
operating system the host kernel the

00:00:57,360 --> 00:01:02,160
firmware

00:00:58,000 --> 00:01:03,760
everything must be trusted by the guest

00:01:02,160 --> 00:01:06,880
everything that's provided by the host

00:01:03,760 --> 00:01:09,119
must be trusted by the guest

00:01:06,880 --> 00:01:11,280
and what confidential computing and the

00:01:09,119 --> 00:01:14,880
related technologies

00:01:11,280 --> 00:01:15,840
is trying to build is a threat model

00:01:14,880 --> 00:01:17,920
where

00:01:15,840 --> 00:01:19,360
all the software layers provided by the

00:01:17,920 --> 00:01:22,640
host

00:01:19,360 --> 00:01:24,080
are actually no longer trusted so it's

00:01:22,640 --> 00:01:26,320
trying to remove

00:01:24,080 --> 00:01:27,600
each and every piece of software

00:01:26,320 --> 00:01:30,880
provided by the hosts

00:01:27,600 --> 00:01:34,159
out of the guest tcb

00:01:30,880 --> 00:01:36,560
this is very appealing um these

00:01:34,159 --> 00:01:39,119
essentially completely remove the host

00:01:36,560 --> 00:01:41,680
software stack from the guest ecb

00:01:39,119 --> 00:01:42,159
um including the host firmware the

00:01:41,680 --> 00:01:45,280
kernel

00:01:42,159 --> 00:01:49,520
the hypervisor everything is out

00:01:45,280 --> 00:01:53,200
and the interesting part of this is that

00:01:49,520 --> 00:01:54,640
the tenant is the only one that can see

00:01:53,200 --> 00:01:56,399
and modify its data

00:01:54,640 --> 00:01:58,079
no one else can see it no one else can

00:01:56,399 --> 00:02:00,399
can modify it

00:01:58,079 --> 00:02:01,759
and most importantly the infrastructure

00:02:00,399 --> 00:02:05,200
owner the csp

00:02:01,759 --> 00:02:08,080
the the the infrastructure

00:02:05,200 --> 00:02:08,640
provider does not need to be trusted

00:02:08,080 --> 00:02:10,640
anymore

00:02:08,640 --> 00:02:12,239
so this is a very interesting uh threat

00:02:10,640 --> 00:02:14,160
model

00:02:12,239 --> 00:02:16,080
how do we get there uh what needs to be

00:02:14,160 --> 00:02:18,239
provided by those computing uh

00:02:16,080 --> 00:02:20,000
computational computing technologies to

00:02:18,239 --> 00:02:23,120
build that threat model

00:02:20,000 --> 00:02:24,000
well the first thing is that the uh they

00:02:23,120 --> 00:02:26,400
need to protect

00:02:24,000 --> 00:02:27,040
the tenants data this is this is obvious

00:02:26,400 --> 00:02:29,120
i think

00:02:27,040 --> 00:02:30,879
uh if you don't want if you want to

00:02:29,120 --> 00:02:33,760
remove the whole software stack from

00:02:30,879 --> 00:02:36,080
from the guest tcb uh you want to make

00:02:33,760 --> 00:02:39,040
sure that the host software cannot

00:02:36,080 --> 00:02:40,640
see or tamper with the guest data and

00:02:39,040 --> 00:02:45,040
the tenants data

00:02:40,640 --> 00:02:48,239
but that's not enough we also need to

00:02:45,040 --> 00:02:50,640
let the tenant verify

00:02:48,239 --> 00:02:52,480
what it's running which software

00:02:50,640 --> 00:02:54,800
component is running

00:02:52,480 --> 00:02:55,920
how it's running and on top of which

00:02:54,800 --> 00:02:57,680
hardware is running

00:02:55,920 --> 00:03:01,440
and we're going to go through those

00:02:57,680 --> 00:03:01,440
requirements in a little bit of details

00:03:01,680 --> 00:03:07,200
so first we want

00:03:05,599 --> 00:03:10,159
computational computing technologies to

00:03:07,200 --> 00:03:12,800
protect our data

00:03:10,159 --> 00:03:14,400
and we kind of we can already do that

00:03:12,800 --> 00:03:15,440
our data can be in three different

00:03:14,400 --> 00:03:18,319
states

00:03:15,440 --> 00:03:19,280
it can be in transit that is typically

00:03:18,319 --> 00:03:21,840
where your data is

00:03:19,280 --> 00:03:23,760
is going through some networking pipes

00:03:21,840 --> 00:03:26,319
and we have tls we have vpns

00:03:23,760 --> 00:03:27,120
uh in when when our data is in that

00:03:26,319 --> 00:03:28,959
state it's

00:03:27,120 --> 00:03:30,400
it's basically protected we know how to

00:03:28,959 --> 00:03:32,640
do this

00:03:30,400 --> 00:03:34,319
same for when the data is addressed uh

00:03:32,640 --> 00:03:35,280
which means it's uh it's stored

00:03:34,319 --> 00:03:37,280
somewhere

00:03:35,280 --> 00:03:39,120
uh we have disk encryption uh we know

00:03:37,280 --> 00:03:41,360
how to protect our data when it's

00:03:39,120 --> 00:03:44,080
when it's resting in some in some

00:03:41,360 --> 00:03:46,239
physical medium

00:03:44,080 --> 00:03:48,080
the thing that we are lacking for

00:03:46,239 --> 00:03:51,040
completely protecting our data

00:03:48,080 --> 00:03:53,040
is uh protecting it when it's in use

00:03:51,040 --> 00:03:55,200
when it's being computed

00:03:53,040 --> 00:03:56,080
and to do that we need to be able to

00:03:55,200 --> 00:03:58,799
encrypt

00:03:56,080 --> 00:04:00,000
uh the memory where our data is being

00:03:58,799 --> 00:04:03,360
computed when it's being

00:04:00,000 --> 00:04:05,280
loaded and our data is also

00:04:03,360 --> 00:04:07,760
going through our cpu state our

00:04:05,280 --> 00:04:11,040
registers our stack

00:04:07,760 --> 00:04:13,760
all this needs to be encrypted as well

00:04:11,040 --> 00:04:14,560
so we we currently don't really know how

00:04:13,760 --> 00:04:16,959
to do this

00:04:14,560 --> 00:04:19,199
except when using computational

00:04:16,959 --> 00:04:23,199
computing technologies

00:04:19,199 --> 00:04:25,280
but protecting data is not enough

00:04:23,199 --> 00:04:26,400
for for confidential computing for

00:04:25,280 --> 00:04:30,560
removing the host

00:04:26,400 --> 00:04:30,560
software stack from from the guest tcb

00:04:31,120 --> 00:04:34,960
if we protect the data and we don't know

00:04:33,280 --> 00:04:38,160
which software components

00:04:34,960 --> 00:04:40,720
are using or loading or

00:04:38,160 --> 00:04:42,000
modifying this data we don't know which

00:04:40,720 --> 00:04:44,400
data it is it could be

00:04:42,000 --> 00:04:45,600
completely bogus data it could be uh it

00:04:44,400 --> 00:04:47,199
could be rogue data it could be

00:04:45,600 --> 00:04:50,240
malicious data

00:04:47,199 --> 00:04:52,479
so as a tenant i

00:04:50,240 --> 00:04:53,919
in order to not trust the software

00:04:52,479 --> 00:04:56,639
components coming from the host

00:04:53,919 --> 00:04:58,000
i want to be able to not only protect my

00:04:56,639 --> 00:05:01,120
data and make sure that

00:04:58,000 --> 00:05:02,000
my infrastructure owner cannot see or

00:05:01,120 --> 00:05:04,400
tamper

00:05:02,000 --> 00:05:05,440
tamper with it but i also want to be

00:05:04,400 --> 00:05:07,759
able to verify

00:05:05,440 --> 00:05:09,280
that the software stack that i'm running

00:05:07,759 --> 00:05:11,120
inside my guest

00:05:09,280 --> 00:05:12,320
is the one i'm expecting to to be

00:05:11,120 --> 00:05:14,000
running

00:05:12,320 --> 00:05:16,320
and also that this software stack is

00:05:14,000 --> 00:05:19,840
running on top of a hardware platform

00:05:16,320 --> 00:05:22,880
that i know and that is the expected one

00:05:19,840 --> 00:05:24,639
if i can do both at the station and

00:05:22,880 --> 00:05:26,479
basically verify that um what i'm

00:05:24,639 --> 00:05:27,120
running is the is what i'm expecting to

00:05:26,479 --> 00:05:29,120
run

00:05:27,120 --> 00:05:30,240
and i can protect my data from from the

00:05:29,120 --> 00:05:32,560
host then

00:05:30,240 --> 00:05:35,120
uh i can i can really start building

00:05:32,560 --> 00:05:38,320
this new thread model where

00:05:35,120 --> 00:05:41,759
i can safely remove the whole software

00:05:38,320 --> 00:05:44,800
layers from my tcb from my

00:05:41,759 --> 00:05:44,800
from my truss boundaries

00:05:45,280 --> 00:05:50,160
in order to do this there are some

00:05:47,840 --> 00:05:52,320
hardware dependencies

00:05:50,160 --> 00:05:53,360
protecting the data in use doing memory

00:05:52,320 --> 00:05:56,160
encryption and

00:05:53,360 --> 00:05:57,520
and cpu state encryption uh together

00:05:56,160 --> 00:05:59,840
with at the station

00:05:57,520 --> 00:06:02,479
both need hardware support uh you you

00:05:59,840 --> 00:06:04,240
you don't want to do that uh

00:06:02,479 --> 00:06:06,479
in software essentially because if you

00:06:04,240 --> 00:06:09,680
do that in software you again have to

00:06:06,479 --> 00:06:11,199
trust the host so that needs hardware

00:06:09,680 --> 00:06:13,199
support

00:06:11,199 --> 00:06:14,720
and there are a few technologies coming

00:06:13,199 --> 00:06:18,000
from amd

00:06:14,720 --> 00:06:21,440
ibm intel trust

00:06:18,000 --> 00:06:25,039
domain extensions that are providing

00:06:21,440 --> 00:06:27,280
those this support so

00:06:25,039 --> 00:06:28,400
those technologies in one way or another

00:06:27,280 --> 00:06:30,400
they provide memory

00:06:28,400 --> 00:06:31,840
and cpu state encryption and intricate

00:06:30,400 --> 00:06:34,560
integrity sorry

00:06:31,840 --> 00:06:35,600
and they provide a way to attest what

00:06:34,560 --> 00:06:38,560
kind of software

00:06:35,600 --> 00:06:39,919
stack you're running in the guest the

00:06:38,560 --> 00:06:42,639
interesting part about it

00:06:39,919 --> 00:06:43,680
is that they're all designed as hardware

00:06:42,639 --> 00:06:47,280
virtualization

00:06:43,680 --> 00:06:49,759
extensions which means that they

00:06:47,280 --> 00:06:51,520
have a strong requirement that if you

00:06:49,759 --> 00:06:52,000
want to do confidential computing if you

00:06:51,520 --> 00:06:54,880
want to

00:06:52,000 --> 00:06:56,880
as a tenant as a workload if you want to

00:06:54,880 --> 00:06:58,800
be able to take advantage of those

00:06:56,880 --> 00:07:00,319
confidential computing technology

00:06:58,800 --> 00:07:03,120
you're going to have to run inside a

00:07:00,319 --> 00:07:05,599
virtual machine

00:07:03,120 --> 00:07:06,160
so that brings software dependencies as

00:07:05,599 --> 00:07:08,479
i said

00:07:06,160 --> 00:07:10,560
if you're a workload and you want to be

00:07:08,479 --> 00:07:12,000
a confidential computing workload

00:07:10,560 --> 00:07:13,599
you're going to have to run inside a

00:07:12,000 --> 00:07:16,319
virtual machine

00:07:13,599 --> 00:07:17,199
that means that as a workload you're

00:07:16,319 --> 00:07:19,840
going to have to

00:07:17,199 --> 00:07:20,880
indirectly talk to an hypervisor you're

00:07:19,840 --> 00:07:23,280
going to have to talk to

00:07:20,880 --> 00:07:24,240
kvm and qmu or cloud provider for

00:07:23,280 --> 00:07:26,960
example

00:07:24,240 --> 00:07:28,000
or ipv or any hypervisor that actually

00:07:26,960 --> 00:07:29,360
supports

00:07:28,000 --> 00:07:31,840
those confidential computing

00:07:29,360 --> 00:07:31,840
technologies

00:07:32,639 --> 00:07:37,280
okay so now we've seen uh what we're

00:07:35,919 --> 00:07:39,520
expecting from

00:07:37,280 --> 00:07:41,360
the emerging confidential computing

00:07:39,520 --> 00:07:42,800
technologies to be able to build that

00:07:41,360 --> 00:07:44,720
new threat model

00:07:42,800 --> 00:07:46,240
let's see how we could apply

00:07:44,720 --> 00:07:49,599
confidential computing to

00:07:46,240 --> 00:07:50,319
containers and the goal here is really

00:07:49,599 --> 00:07:53,120
to

00:07:50,319 --> 00:07:54,720
to abstract all the dependencies that we

00:07:53,120 --> 00:07:55,840
just enumerated the hardware and

00:07:54,720 --> 00:07:57,520
software

00:07:55,840 --> 00:07:59,759
and provide confidential computing to

00:07:57,520 --> 00:08:02,720
cloud native in a

00:07:59,759 --> 00:08:06,240
seamless form we want this to be to be

00:08:02,720 --> 00:08:09,280
seamless for containers to consume

00:08:06,240 --> 00:08:09,840
there are a few blockers um the very

00:08:09,280 --> 00:08:13,120
first one

00:08:09,840 --> 00:08:16,800
is that run c does not talk to kvm

00:08:13,120 --> 00:08:19,120
run c is the most ubiquitous

00:08:16,800 --> 00:08:21,039
container runtime and that's the one

00:08:19,120 --> 00:08:21,360
that is going to start your containers

00:08:21,039 --> 00:08:23,520
and

00:08:21,360 --> 00:08:25,440
manage your pods on kubernetes

00:08:23,520 --> 00:08:28,319
eventually

00:08:25,440 --> 00:08:30,240
so if francie does not talk to kvm if

00:08:28,319 --> 00:08:32,000
you run your container workloads

00:08:30,240 --> 00:08:33,599
through runty you're not going to be

00:08:32,000 --> 00:08:35,200
able to access

00:08:33,599 --> 00:08:36,880
the configuration computing hardware

00:08:35,200 --> 00:08:39,440
extension because as

00:08:36,880 --> 00:08:40,000
you remember the whole design as

00:08:39,440 --> 00:08:43,279
hardware

00:08:40,000 --> 00:08:45,360
virtualization extensions so that means

00:08:43,279 --> 00:08:47,680
you cannot protect your tenant data

00:08:45,360 --> 00:08:49,120
while while it's in use

00:08:47,680 --> 00:08:53,040
and you're not going to be able to build

00:08:49,120 --> 00:08:53,040
that confidential computing thread model

00:08:53,360 --> 00:08:57,600
the other blocker is that sierra runtime

00:08:55,680 --> 00:08:58,320
expect to be able to mount container

00:08:57,600 --> 00:09:00,240
images

00:08:58,320 --> 00:09:01,440
on the host so before launching a

00:09:00,240 --> 00:09:03,680
container uh

00:09:01,440 --> 00:09:05,040
workload they actually mount the

00:09:03,680 --> 00:09:08,399
container image on the host

00:09:05,040 --> 00:09:11,040
and then they let the container uh

00:09:08,399 --> 00:09:12,959
the container workload access it through

00:09:11,040 --> 00:09:15,279
some namespaces or in

00:09:12,959 --> 00:09:17,040
in some other cases through uh

00:09:15,279 --> 00:09:18,880
virtualization

00:09:17,040 --> 00:09:21,040
technologies but they would access

00:09:18,880 --> 00:09:22,720
what's mounted on the host

00:09:21,040 --> 00:09:25,200
if we let the sierra runtime mount

00:09:22,720 --> 00:09:29,360
container images on the host

00:09:25,200 --> 00:09:32,959
we basically are letting the host

00:09:29,360 --> 00:09:36,000
access and tamper with our data

00:09:32,959 --> 00:09:38,800
and we cannot protect the tenant's data

00:09:36,000 --> 00:09:39,760
while it's at rest so those are the two

00:09:38,800 --> 00:09:43,279
main blockers

00:09:39,760 --> 00:09:46,080
um solutions for this solution for

00:09:43,279 --> 00:09:47,040
enabling confidential computing for

00:09:46,080 --> 00:09:49,600
containers

00:09:47,040 --> 00:09:50,320
are threefolds catacontainers is the

00:09:49,600 --> 00:09:54,080
first one

00:09:50,320 --> 00:09:54,880
um to use scatter containers instead of

00:09:54,080 --> 00:09:57,519
runty

00:09:54,880 --> 00:09:58,560
and leverage the hardware virtualization

00:09:57,519 --> 00:10:01,839
extensions

00:09:58,560 --> 00:10:02,320
that are providing that are providing by

00:10:01,839 --> 00:10:04,959
this

00:10:02,320 --> 00:10:06,560
confidential computing technologies the

00:10:04,959 --> 00:10:08,880
second one the second part of the

00:10:06,560 --> 00:10:11,120
solution is

00:10:08,880 --> 00:10:12,560
being able to encrypt the container

00:10:11,120 --> 00:10:16,839
image layers or at least

00:10:12,560 --> 00:10:18,160
verify and sign them and last but not

00:10:16,839 --> 00:10:19,839
least

00:10:18,160 --> 00:10:21,440
we want to be able to offload the

00:10:19,839 --> 00:10:24,640
container image service

00:10:21,440 --> 00:10:25,680
inside the virtual machine and eric is

00:10:24,640 --> 00:10:27,040
now going to

00:10:25,680 --> 00:10:29,839
go through those solutions in more

00:10:27,040 --> 00:10:31,680
details and explain why we think

00:10:29,839 --> 00:10:35,279
they will be able to bring confidential

00:10:31,680 --> 00:10:38,160
computing to the cloud native ecosystem

00:10:35,279 --> 00:10:40,240
the scene is all yours eric thanks

00:10:38,160 --> 00:10:43,920
thanks samuel

00:10:40,240 --> 00:10:45,519
so as samuel pointed out

00:10:43,920 --> 00:10:47,440
you know the solution space one of the

00:10:45,519 --> 00:10:49,200
things that we think makes sense is uh

00:10:47,440 --> 00:10:51,519
kata containers but let's kind of get

00:10:49,200 --> 00:10:53,040
into that in a little bit more detail so

00:10:51,519 --> 00:10:54,720
requirement is clear that you need to

00:10:53,040 --> 00:10:55,200
have a virtual machine in order to be

00:10:54,720 --> 00:10:58,240
able to

00:10:55,200 --> 00:11:00,880
leverage these um extensions

00:10:58,240 --> 00:11:02,160
so uh it needs to run inside of a vm

00:11:00,880 --> 00:11:05,680
that makes sense

00:11:02,160 --> 00:11:07,120
um further uh you know based on that

00:11:05,680 --> 00:11:08,720
need to use hardware virtualization as

00:11:07,120 --> 00:11:10,880
the isolation layer so

00:11:08,720 --> 00:11:12,640
normally your cri runtime will call into

00:11:10,880 --> 00:11:15,279
a runtime to actually create the virtual

00:11:12,640 --> 00:11:16,480
machine and run your pod inside of it

00:11:15,279 --> 00:11:19,519
there are a few different sandbox

00:11:16,480 --> 00:11:22,079
runtimes um g visor firecracker and

00:11:19,519 --> 00:11:24,079
kata containers are three listed here

00:11:22,079 --> 00:11:26,800
but you know there are others as well

00:11:24,079 --> 00:11:27,600
g visor we didn't really see as a

00:11:26,800 --> 00:11:28,959
perfect match

00:11:27,600 --> 00:11:31,279
just based on you know it's it's

00:11:28,959 --> 00:11:33,279
utilizing the user space kernel it's not

00:11:31,279 --> 00:11:34,480
you know it doesn't end up booting a

00:11:33,279 --> 00:11:37,839
full virtual machine

00:11:34,480 --> 00:11:40,480
um so we didn't think that that would be

00:11:37,839 --> 00:11:41,279
um a perfect match there firecracker

00:11:40,480 --> 00:11:44,640
similarly

00:11:41,279 --> 00:11:47,040
it's uh the firecracker runtime um use

00:11:44,640 --> 00:11:47,920
utilizing the firecracker vmm it has

00:11:47,040 --> 00:11:50,000
some limitations

00:11:47,920 --> 00:11:52,000
device-wise that make it a bit more

00:11:50,000 --> 00:11:52,720
challenging when using in a kubernetes

00:11:52,000 --> 00:11:54,639
environment

00:11:52,720 --> 00:11:56,079
and when you have multi-container pods

00:11:54,639 --> 00:11:58,160
and everything else so

00:11:56,079 --> 00:11:59,760
really we saw kata containers is the

00:11:58,160 --> 00:12:03,440
more natural fit

00:11:59,760 --> 00:12:05,600
solution for this in that you can have

00:12:03,440 --> 00:12:07,440
full compatibility in kubernetes

00:12:05,600 --> 00:12:08,639
you can still use vmms like cloud

00:12:07,440 --> 00:12:12,399
hypervisor

00:12:08,639 --> 00:12:14,160
or qmu and really

00:12:12,399 --> 00:12:15,680
you know provide the hooks necessary to

00:12:14,160 --> 00:12:17,760
be able to leverage confidential

00:12:15,680 --> 00:12:21,040
computing

00:12:17,760 --> 00:12:23,440
so with that then the whole

00:12:21,040 --> 00:12:24,480
image management as well as any real

00:12:23,440 --> 00:12:26,160
storage management

00:12:24,480 --> 00:12:27,519
um there are kind of two parts of it

00:12:26,160 --> 00:12:29,839
that we want to look at

00:12:27,519 --> 00:12:31,279
uh one of them being service offload so

00:12:29,839 --> 00:12:32,320
when we talk about service offload we're

00:12:31,279 --> 00:12:34,399
really saying

00:12:32,320 --> 00:12:36,399
we don't want to mount it on the host

00:12:34,399 --> 00:12:38,480
asmr kind of pointed out like we can we

00:12:36,399 --> 00:12:40,160
can do all this work to protect our data

00:12:38,480 --> 00:12:41,680
while it's executing but if we forget to

00:12:40,160 --> 00:12:43,360
protect it at rest we're kind of

00:12:41,680 --> 00:12:46,079
there's no point in anything that we're

00:12:43,360 --> 00:12:49,279
doing so we want to avoid

00:12:46,079 --> 00:12:51,120
um the cra runtime needing to mount or

00:12:49,279 --> 00:12:53,040
do anything really with the images on

00:12:51,120 --> 00:12:53,839
the host so the different ways we can do

00:12:53,040 --> 00:12:55,600
it um

00:12:53,839 --> 00:12:57,440
one of them is kind of naive i would say

00:12:55,600 --> 00:12:58,079
um and that is to fully offload it to

00:12:57,440 --> 00:13:00,880
the guest

00:12:58,079 --> 00:13:01,920
and what i'm seeing here is that um

00:13:00,880 --> 00:13:05,279
don't do anything

00:13:01,920 --> 00:13:07,519
in in the cri runtime um and instead

00:13:05,279 --> 00:13:08,800
do the pull and everything inside of the

00:13:07,519 --> 00:13:11,920
virtual machine

00:13:08,800 --> 00:13:12,800
that makes it easy and well easier um in

00:13:11,920 --> 00:13:15,200
that

00:13:12,800 --> 00:13:16,399
it's a single you know service operating

00:13:15,200 --> 00:13:18,639
inside the guest

00:13:16,399 --> 00:13:20,000
when i said it was naive before it's you

00:13:18,639 --> 00:13:23,120
know you can imagine a situation where

00:13:20,000 --> 00:13:24,160
you have 30 pods running on a node and

00:13:23,120 --> 00:13:25,839
each of them are running

00:13:24,160 --> 00:13:27,440
maybe the same image or maybe sharing

00:13:25,839 --> 00:13:29,120
most of the layers of their image

00:13:27,440 --> 00:13:31,120
what you're going to see is since it's

00:13:29,120 --> 00:13:32,560
happened inside each guest

00:13:31,120 --> 00:13:34,480
which means it happens for every single

00:13:32,560 --> 00:13:36,560
pod we do this image management

00:13:34,480 --> 00:13:37,920
there's no deduplication so every single

00:13:36,560 --> 00:13:40,160
layer is getting pulled

00:13:37,920 --> 00:13:41,839
inside each one so it's kind of a bit

00:13:40,160 --> 00:13:42,800
abusive maybe to the file system but

00:13:41,839 --> 00:13:44,560
even worse

00:13:42,800 --> 00:13:46,560
probably for the network as well as you

00:13:44,560 --> 00:13:48,639
go ahead and pull all these images

00:13:46,560 --> 00:13:50,320
for every single pod running on that

00:13:48,639 --> 00:13:52,399
node um

00:13:50,320 --> 00:13:54,720
it's a good first step i mean it really

00:13:52,399 --> 00:13:56,399
does uh move things away

00:13:54,720 --> 00:13:57,839
and protect the data but probably

00:13:56,399 --> 00:13:59,440
something a long term that you would

00:13:57,839 --> 00:14:01,760
look at is to do kind of a mix

00:13:59,440 --> 00:14:02,800
where maybe you do the pulling of the

00:14:01,760 --> 00:14:05,839
actual layers

00:14:02,800 --> 00:14:06,560
on the host itself so you can have some

00:14:05,839 --> 00:14:11,199
sharing there

00:14:06,560 --> 00:14:14,399
but then present all of these layers um

00:14:11,199 --> 00:14:16,480
to the guest and the guest then would be

00:14:14,399 --> 00:14:19,839
able to pick the appropriate ones

00:14:16,480 --> 00:14:20,800
do the verification decrypt etc inside

00:14:19,839 --> 00:14:22,959
the guest itself

00:14:20,800 --> 00:14:25,760
so i would see that's kind of um the

00:14:22,959 --> 00:14:25,760
hybrid option

00:14:26,079 --> 00:14:32,160
i for for the mixed and then

00:14:30,079 --> 00:14:33,760
uh the next step after that is looking

00:14:32,160 --> 00:14:34,639
at you know doing the encryption and

00:14:33,760 --> 00:14:36,800
verification

00:14:34,639 --> 00:14:38,720
itself so great we're not doing it on

00:14:36,800 --> 00:14:39,360
the host that's wonderful but now we

00:14:38,720 --> 00:14:42,000
actually still

00:14:39,360 --> 00:14:43,519
need to be able to do the decryption uh

00:14:42,000 --> 00:14:44,720
and everything else so we need a way to

00:14:43,519 --> 00:14:47,360
be able to

00:14:44,720 --> 00:14:48,480
decrypt as well as verify i say both of

00:14:47,360 --> 00:14:50,240
those things because you can imagine a

00:14:48,480 --> 00:14:54,160
situation where your image

00:14:50,240 --> 00:14:55,839
um you know you have uh some

00:14:54,160 --> 00:14:57,519
very confidential algorithm that you're

00:14:55,839 --> 00:14:59,600
running on top but your base image is

00:14:57,519 --> 00:15:01,680
alpine you don't really need to encrypt

00:14:59,600 --> 00:15:03,199
alpine um that that's not a secret

00:15:01,680 --> 00:15:04,800
um you just need to verify that this is

00:15:03,199 --> 00:15:06,240
the alpine you expect and you can do

00:15:04,800 --> 00:15:09,600
that through a signature

00:15:06,240 --> 00:15:10,399
instead but either way encrypted or

00:15:09,600 --> 00:15:12,880
verified

00:15:10,399 --> 00:15:14,000
um everything that's inside the guest

00:15:12,880 --> 00:15:16,160
brought into the guest

00:15:14,000 --> 00:15:17,600
needs to be uh this and anytime that you

00:15:16,160 --> 00:15:20,240
pull these things out of the guest

00:15:17,600 --> 00:15:20,959
you need to have it encrypted uh as well

00:15:20,240 --> 00:15:22,399
so anything

00:15:20,959 --> 00:15:23,839
that is going to be going to rest and

00:15:22,399 --> 00:15:25,040
kind of transporting out we need to make

00:15:23,839 --> 00:15:26,880
sure that happens so

00:15:25,040 --> 00:15:28,240
that's another aspect of things that

00:15:26,880 --> 00:15:31,600
need to happen

00:15:28,240 --> 00:15:34,639
so first let's walk through um

00:15:31,600 --> 00:15:36,320
this is what you know a high level flow

00:15:34,639 --> 00:15:37,360
of how things operate today if you're

00:15:36,320 --> 00:15:39,759
using

00:15:37,360 --> 00:15:40,480
caught a clh runtime class so using kata

00:15:39,759 --> 00:15:43,440
containers

00:15:40,480 --> 00:15:44,399
with the cloud hypervisor vmm um

00:15:43,440 --> 00:15:46,639
starting at the top

00:15:44,399 --> 00:15:48,399
you know cubelet will come in uh and see

00:15:46,639 --> 00:15:50,240
like hey there's a plot assigned to my

00:15:48,399 --> 00:15:50,560
node it's not there we need to start it

00:15:50,240 --> 00:15:53,199
up

00:15:50,560 --> 00:15:54,959
um go forward first thing it's going to

00:15:53,199 --> 00:15:55,680
do is ask the cri runtime to pull the

00:15:54,959 --> 00:15:58,480
image

00:15:55,680 --> 00:16:00,000
if the image isn't already present the

00:15:58,480 --> 00:16:02,399
cri runtime would go

00:16:00,000 --> 00:16:03,360
ahead and and pull this down and make it

00:16:02,399 --> 00:16:05,680
available

00:16:03,360 --> 00:16:06,800
after that um cubelet would ask the cri

00:16:05,680 --> 00:16:09,920
runtime

00:16:06,800 --> 00:16:12,480
to go ahead and create the container uh

00:16:09,920 --> 00:16:13,040
in doing that um the first step you know

00:16:12,480 --> 00:16:15,920
will be

00:16:13,040 --> 00:16:16,880
making that image mounted so that way it

00:16:15,920 --> 00:16:20,399
can be consumed

00:16:16,880 --> 00:16:21,920
by the container then after that

00:16:20,399 --> 00:16:24,560
in our case it'll send a create

00:16:21,920 --> 00:16:26,000
container request to kata containers

00:16:24,560 --> 00:16:27,759
on the host kind of containers you're

00:16:26,000 --> 00:16:29,440
talking to is the shim v2 and what

00:16:27,759 --> 00:16:30,560
that's going to do then is start a

00:16:29,440 --> 00:16:32,000
virtual machine so

00:16:30,560 --> 00:16:34,720
it's going to be using in this

00:16:32,000 --> 00:16:37,600
particular example it'll be using vt

00:16:34,720 --> 00:16:39,360
and kvm on top of that will be the vmm

00:16:37,600 --> 00:16:40,720
cloud hypervisor and that will start the

00:16:39,360 --> 00:16:42,240
actual virtual machine

00:16:40,720 --> 00:16:43,920
once a virtual machine is up you're

00:16:42,240 --> 00:16:46,000
running your guest kernel the first

00:16:43,920 --> 00:16:48,000
process that comes up is the kata agent

00:16:46,000 --> 00:16:49,440
the kata agent then is going to see oh i

00:16:48,000 --> 00:16:50,880
have this root fs

00:16:49,440 --> 00:16:52,639
available i'm supposed to you know

00:16:50,880 --> 00:16:53,440
here's a config json that container d

00:16:52,639 --> 00:16:55,759
gave me or

00:16:53,440 --> 00:16:56,959
cryo i'm going to go ahead and now

00:16:55,759 --> 00:16:59,600
create this virtual machine

00:16:56,959 --> 00:17:00,399
and to not you have a pod working how

00:16:59,600 --> 00:17:02,000
would this change

00:17:00,399 --> 00:17:04,160
in the case of using something like

00:17:02,000 --> 00:17:05,839
confidential computing so runtime class

00:17:04,160 --> 00:17:08,000
we'd have a unique one let's say it's

00:17:05,839 --> 00:17:09,360
cloud hypervisor with tdx

00:17:08,000 --> 00:17:10,799
similarly people that's going to do the

00:17:09,360 --> 00:17:12,160
same stuff it's going to say hey i'm

00:17:10,799 --> 00:17:13,280
going to run this pod make sure you pull

00:17:12,160 --> 00:17:15,839
the image

00:17:13,280 --> 00:17:17,039
container d in our naive case we'll

00:17:15,839 --> 00:17:18,319
describe here we're going to fully

00:17:17,039 --> 00:17:20,480
offload it um

00:17:18,319 --> 00:17:21,919
don't actually pull the image just kind

00:17:20,480 --> 00:17:24,079
of cache url

00:17:21,919 --> 00:17:25,280
perhaps and and just move on and save

00:17:24,079 --> 00:17:26,559
everything's fine

00:17:25,280 --> 00:17:28,400
now keyblade is going to continue and

00:17:26,559 --> 00:17:29,679
say okay i'm ready to create the sandbox

00:17:28,400 --> 00:17:30,640
i'm ready to create the bottom ready to

00:17:29,679 --> 00:17:32,480
create a container

00:17:30,640 --> 00:17:34,240
it's going to issue create container

00:17:32,480 --> 00:17:35,600
requests cri run time

00:17:34,240 --> 00:17:37,600
doesn't need to do any mounting at this

00:17:35,600 --> 00:17:39,600
point instead it's going to just for the

00:17:37,600 --> 00:17:41,120
information to kata containers that same

00:17:39,600 --> 00:17:44,720
shim v2

00:17:41,120 --> 00:17:46,000
to create the container kata is going to

00:17:44,720 --> 00:17:48,720
start up the vm at this point

00:17:46,000 --> 00:17:49,440
it's going to do the same thing it's you

00:17:48,720 --> 00:17:50,960
know going to

00:17:49,440 --> 00:17:52,640
boot up the kata agent is going to come

00:17:50,960 --> 00:17:54,559
up but

00:17:52,640 --> 00:17:55,679
now it needs to pull the image so what

00:17:54,559 --> 00:17:57,360
we're going to do is we have an

00:17:55,679 --> 00:17:59,039
attestation service we have

00:17:57,360 --> 00:18:00,799
um essentially the kind of agent will

00:17:59,039 --> 00:18:03,200
come up it'll say this is the image that

00:18:00,799 --> 00:18:03,200
i need

00:18:03,360 --> 00:18:06,799
based on that it needs to be able to

00:18:04,799 --> 00:18:09,520
decrypt it and it's going to need to

00:18:06,799 --> 00:18:11,440
talk to a remote attestation agent or

00:18:09,520 --> 00:18:14,400
get away to be able to find the keys

00:18:11,440 --> 00:18:15,360
so it'll talk to that remote station as

00:18:14,400 --> 00:18:17,679
an example

00:18:15,360 --> 00:18:19,280
um and it'll say this is who i am you

00:18:17,679 --> 00:18:20,240
know it did a measured boot of the host

00:18:19,280 --> 00:18:23,039
platform

00:18:20,240 --> 00:18:23,440
of the kernel itself of the vmm of the

00:18:23,039 --> 00:18:25,520
guest

00:18:23,440 --> 00:18:27,840
kernel of the kata agent up to that

00:18:25,520 --> 00:18:30,080
point all measured so we can say

00:18:27,840 --> 00:18:32,000
this is who i am uh you you should trust

00:18:30,080 --> 00:18:33,440
me um please give me the keys so that

00:18:32,000 --> 00:18:34,960
way i can

00:18:33,440 --> 00:18:36,960
work on decrypting all the layers of

00:18:34,960 --> 00:18:37,760
your image so we can run your workload

00:18:36,960 --> 00:18:39,120
so at that point

00:18:37,760 --> 00:18:41,200
assuming everything looks good we get

00:18:39,120 --> 00:18:41,600
the keys we're able to decrypt and we're

00:18:41,200 --> 00:18:43,200
able to

00:18:41,600 --> 00:18:45,360
mount the image and at this point we're

00:18:43,200 --> 00:18:47,280
at the same situation where before

00:18:45,360 --> 00:18:49,280
in the traditional case where we have a

00:18:47,280 --> 00:18:51,360
root fs on the file system

00:18:49,280 --> 00:18:52,400
in the guest and we want to launch a

00:18:51,360 --> 00:18:54,840
container and

00:18:52,400 --> 00:18:56,640
things just continue normally at this

00:18:54,840 --> 00:18:59,760
point

00:18:56,640 --> 00:19:03,039
so stepping back like great um on

00:18:59,760 --> 00:19:05,280
on a slide we show that it all works um

00:19:03,039 --> 00:19:06,960
and let's pretend you know we're a

00:19:05,280 --> 00:19:08,559
little bit ways out and all this

00:19:06,960 --> 00:19:10,080
is working and to end what does this

00:19:08,559 --> 00:19:12,240
really mean for the end user um

00:19:10,080 --> 00:19:15,200
confidential computing is very powerful

00:19:12,240 --> 00:19:16,400
it's a great new threat model um to be

00:19:15,200 --> 00:19:18,000
able to provide

00:19:16,400 --> 00:19:19,600
that security and privacy and everything

00:19:18,000 --> 00:19:22,080
else for the end user

00:19:19,600 --> 00:19:23,679
what does it mean for the developer um

00:19:22,080 --> 00:19:25,360
unlike existing technologies today

00:19:23,679 --> 00:19:27,120
really it means absolutely nothing

00:19:25,360 --> 00:19:28,720
you can get confidential computing

00:19:27,120 --> 00:19:30,559
without needing to change

00:19:28,720 --> 00:19:32,320
your workload you're just writing a

00:19:30,559 --> 00:19:35,039
container um

00:19:32,320 --> 00:19:35,520
the thing about that though is you

00:19:35,039 --> 00:19:36,880
really

00:19:35,520 --> 00:19:38,799
should follow the same best practices

00:19:36,880 --> 00:19:40,240
you always do namely if you have a back

00:19:38,799 --> 00:19:42,080
door in your base image

00:19:40,240 --> 00:19:43,280
your your top layer like this

00:19:42,080 --> 00:19:44,960
confidential is

00:19:43,280 --> 00:19:46,720
no longer confidential it can be exposed

00:19:44,960 --> 00:19:48,240
elsewhere so make sure you know

00:19:46,720 --> 00:19:49,440
what you're running i would say that

00:19:48,240 --> 00:19:50,799
that's the only thing is you should

00:19:49,440 --> 00:19:53,360
maybe focus a little bit more because

00:19:50,799 --> 00:19:55,679
you're trying to be confidential

00:19:53,360 --> 00:19:57,280
on top of that i i call this a tenant

00:19:55,679 --> 00:19:58,480
user this is the person who's going to

00:19:57,280 --> 00:20:00,240
do cue cuddle apply

00:19:58,480 --> 00:20:02,480
you know who's actually owning like the

00:20:00,240 --> 00:20:03,760
uh the yaml who's who's running the

00:20:02,480 --> 00:20:05,360
workload itself maybe

00:20:03,760 --> 00:20:07,679
it's the same person the developer maybe

00:20:05,360 --> 00:20:09,440
it's maybe somebody else

00:20:07,679 --> 00:20:10,880
in doing that what does this really mean

00:20:09,440 --> 00:20:11,919
there's two parts um

00:20:10,880 --> 00:20:14,000
one you're gonna need to update your

00:20:11,919 --> 00:20:15,840
pods back actually just generally

00:20:14,000 --> 00:20:17,360
um you're going to need to use this

00:20:15,840 --> 00:20:17,840
specific runtime class just like you

00:20:17,360 --> 00:20:19,840
would do

00:20:17,840 --> 00:20:23,360
if you're using the sandbox runtime and

00:20:19,840 --> 00:20:23,360
on top of that you're going to want to

00:20:23,919 --> 00:20:30,080
specify how do i attest so

00:20:27,440 --> 00:20:31,679
if you were getting keys from a remote

00:20:30,080 --> 00:20:32,840
at a station server you need to be able

00:20:31,679 --> 00:20:36,640
to specify

00:20:32,840 --> 00:20:38,559
hey use um this url to be able to

00:20:36,640 --> 00:20:39,760
communicate to get the keys and pull

00:20:38,559 --> 00:20:42,880
everything else down

00:20:39,760 --> 00:20:43,679
so that would have to be custom per then

00:20:42,880 --> 00:20:45,679
top of that

00:20:43,679 --> 00:20:47,039
i would say maybe that was the person

00:20:45,679 --> 00:20:48,559
doing the yaml maybe there's a person

00:20:47,039 --> 00:20:50,000
who's actually you know at the company

00:20:48,559 --> 00:20:53,520
who's using the service who's

00:20:50,000 --> 00:20:54,799
who set up the infrastructure for um

00:20:53,520 --> 00:20:56,640
running their workloads this person

00:20:54,799 --> 00:20:58,559
would have to one set up an attestation

00:20:56,640 --> 00:21:00,840
service so that way you can go through

00:20:58,559 --> 00:21:02,240
and take the measurement from the cloud

00:21:00,840 --> 00:21:03,760
provider

00:21:02,240 --> 00:21:04,960
and be able to see yes this is the

00:21:03,760 --> 00:21:05,919
hardware and everything else this is

00:21:04,960 --> 00:21:07,760
what i expect

00:21:05,919 --> 00:21:09,760
it to be running in and who would then

00:21:07,760 --> 00:21:11,280
be able to manage providing keys

00:21:09,760 --> 00:21:12,640
such that we could decrypt it if

00:21:11,280 --> 00:21:13,679
everything looks good in the running

00:21:12,640 --> 00:21:16,480
environment

00:21:13,679 --> 00:21:17,360
similarly this person would also have to

00:21:16,480 --> 00:21:20,080
um

00:21:17,360 --> 00:21:21,679
you know manage actually encrypting with

00:21:20,080 --> 00:21:23,039
those keys encrypting the images and

00:21:21,679 --> 00:21:23,760
everything else and providing container

00:21:23,039 --> 00:21:25,600
images

00:21:23,760 --> 00:21:28,000
so a little bit extra work there in

00:21:25,600 --> 00:21:31,039
order to be able to leverage

00:21:28,000 --> 00:21:33,200
as far as a provider is concerned

00:21:31,039 --> 00:21:34,799
one you have to install a runtime that

00:21:33,200 --> 00:21:36,080
supports confidential computing so i

00:21:34,799 --> 00:21:37,360
didn't put it here but that's that's

00:21:36,080 --> 00:21:39,840
kind of a base start

00:21:37,360 --> 00:21:41,039
if that's in place um there's there's

00:21:39,840 --> 00:21:42,400
kind of a couple of things

00:21:41,039 --> 00:21:44,799
introspection doesn't really exist

00:21:42,400 --> 00:21:47,039
anymore so if you're running like

00:21:44,799 --> 00:21:48,480
something that goes through like a falco

00:21:47,039 --> 00:21:49,919
or something like that

00:21:48,480 --> 00:21:51,360
and you assume that you have processes

00:21:49,919 --> 00:21:52,480
running the host that you can look at

00:21:51,360 --> 00:21:56,080
you can't anymore

00:21:52,480 --> 00:21:57,600
so um that's that's not there and

00:21:56,080 --> 00:21:59,120
again that's the whole point of what

00:21:57,600 --> 00:22:00,960
we're doing after all so

00:21:59,120 --> 00:22:02,480
a little bit of a change of how you

00:22:00,960 --> 00:22:04,720
manage things but two

00:22:02,480 --> 00:22:05,760
um there is often like for all the

00:22:04,720 --> 00:22:07,919
different architectures

00:22:05,760 --> 00:22:09,200
the number of keys that are available

00:22:07,919 --> 00:22:12,640
for encrypting each

00:22:09,200 --> 00:22:13,520
trusted domain each vm is a finite

00:22:12,640 --> 00:22:15,039
resource

00:22:13,520 --> 00:22:16,559
so you're going to need to treat it like

00:22:15,039 --> 00:22:17,200
a finite resource that you can schedule

00:22:16,559 --> 00:22:19,280
against

00:22:17,200 --> 00:22:21,919
and that'll be something you know um

00:22:19,280 --> 00:22:24,559
like a device plug-in

00:22:21,919 --> 00:22:26,080
um so that that's what it means for

00:22:24,559 --> 00:22:28,559
there so ultimately like

00:22:26,080 --> 00:22:31,200
not too much changing nothing nothing

00:22:28,559 --> 00:22:31,200
too drastic

00:22:32,400 --> 00:22:35,760
let's talk about gaps then of where we

00:22:34,640 --> 00:22:38,000
actually are today

00:22:35,760 --> 00:22:39,679
um versus kind of uh what we're working

00:22:38,000 --> 00:22:41,760
on and what's coming in the future

00:22:39,679 --> 00:22:43,039
so on the kata container side there's a

00:22:41,760 --> 00:22:46,640
few different parts

00:22:43,039 --> 00:22:47,679
um one is be able to make sure we're

00:22:46,640 --> 00:22:50,799
using a vmm

00:22:47,679 --> 00:22:53,919
that has these apis to leverage

00:22:50,799 --> 00:22:55,440
the confidential computing hardware

00:22:53,919 --> 00:22:58,159
virtualization

00:22:55,440 --> 00:22:59,039
and make sure that in doing that we are

00:22:58,159 --> 00:23:01,039
creating

00:22:59,039 --> 00:23:02,960
configuration knobs for the user to be

00:23:01,039 --> 00:23:06,400
able to specify things like how do we

00:23:02,960 --> 00:23:09,039
get the keys how do we do attestation

00:23:06,400 --> 00:23:10,400
how do we um actually enable

00:23:09,039 --> 00:23:13,440
confidential computing

00:23:10,400 --> 00:23:15,120
in general so adding these on top of

00:23:13,440 --> 00:23:17,919
that there's actual key provisioning

00:23:15,120 --> 00:23:19,280
again depending on the architecture

00:23:17,919 --> 00:23:20,480
we're going to be getting keys from

00:23:19,280 --> 00:23:21,600
different ways we could be getting it

00:23:20,480 --> 00:23:24,000
from the firmware

00:23:21,600 --> 00:23:25,919
on the host we could be getting it from

00:23:24,000 --> 00:23:27,760
a remote server

00:23:25,919 --> 00:23:29,440
in general we need a way for the kata

00:23:27,760 --> 00:23:30,880
agent to be able to get those keys so

00:23:29,440 --> 00:23:32,640
that we can go through and decrypt the

00:23:30,880 --> 00:23:34,559
images

00:23:32,640 --> 00:23:36,640
as part of that we're going to have to

00:23:34,559 --> 00:23:38,720
be able to do attestation

00:23:36,640 --> 00:23:40,000
we're going to have to be able to have a

00:23:38,720 --> 00:23:41,919
set way to be able to

00:23:40,000 --> 00:23:43,679
have a measured view up to the point and

00:23:41,919 --> 00:23:44,480
including the kata agent inside of the

00:23:43,679 --> 00:23:46,320
guest

00:23:44,480 --> 00:23:48,000
in order to facilitate um you know

00:23:46,320 --> 00:23:50,000
responding to a remote attestation that

00:23:48,000 --> 00:23:52,720
says this is who i am

00:23:50,000 --> 00:23:53,200
please give me the keys and then on top

00:23:52,720 --> 00:23:55,200
of that

00:23:53,200 --> 00:23:56,880
the agent api we're going to have to

00:23:55,200 --> 00:23:59,200
lock down a little bit more

00:23:56,880 --> 00:24:00,320
and remove some of the features example

00:23:59,200 --> 00:24:02,640
you can keep control

00:24:00,320 --> 00:24:03,520
exact into a container today and poke

00:24:02,640 --> 00:24:05,520
around

00:24:03,520 --> 00:24:07,679
if you can do that in a confidential

00:24:05,520 --> 00:24:09,440
environment things are a bit broken it's

00:24:07,679 --> 00:24:11,279
not confidential you can just

00:24:09,440 --> 00:24:13,440
access and get in all the different

00:24:11,279 --> 00:24:14,799
debug and kind of ways to interact

00:24:13,440 --> 00:24:16,799
we really need to lock some of those

00:24:14,799 --> 00:24:19,039
down so some of the aspects of the agent

00:24:16,799 --> 00:24:20,559
api itself will remove so that way we

00:24:19,039 --> 00:24:22,159
can indicate clearly that

00:24:20,559 --> 00:24:24,320
this is not supported in this

00:24:22,159 --> 00:24:26,480
configuration

00:24:24,320 --> 00:24:28,640
and the image side this is you know on

00:24:26,480 --> 00:24:29,120
the side we can figure all that out but

00:24:28,640 --> 00:24:30,480
this is

00:24:29,120 --> 00:24:32,799
this is where it's a lot more fun and

00:24:30,480 --> 00:24:34,400
interesting um interacting with kind of

00:24:32,799 --> 00:24:35,120
some of the pod life cycle that we take

00:24:34,400 --> 00:24:37,120
for granted

00:24:35,120 --> 00:24:38,799
and being able to facilitate doing this

00:24:37,120 --> 00:24:40,559
image service offloading

00:24:38,799 --> 00:24:42,240
being able to have like a remote target

00:24:40,559 --> 00:24:43,520
for who does snapshotting instead of

00:24:42,240 --> 00:24:45,520
inside the guest so

00:24:43,520 --> 00:24:46,640
there's a lot of opens there and really

00:24:45,520 --> 00:24:48,000
you know we're looking forward to

00:24:46,640 --> 00:24:49,840
talking to folks on it

00:24:48,000 --> 00:24:51,440
similarly how do we do image layer

00:24:49,840 --> 00:24:52,960
encryption um this is

00:24:51,440 --> 00:24:54,320
something you know that is beyond the

00:24:52,960 --> 00:24:55,679
scope of what we're just looking at this

00:24:54,320 --> 00:24:58,159
is something already well

00:24:55,679 --> 00:25:01,360
discussed and in progress from an oci

00:24:58,159 --> 00:25:04,480
specification standpoint

00:25:01,360 --> 00:25:06,400
so overall stepping back um

00:25:04,480 --> 00:25:09,120
some kind of takeaways in summary one

00:25:06,400 --> 00:25:12,159
conference computing requires vms

00:25:09,120 --> 00:25:13,760
so keep that in mind and that's really

00:25:12,159 --> 00:25:16,159
again why we're focused is

00:25:13,760 --> 00:25:16,960
kind of containers and other vm isolated

00:25:16,159 --> 00:25:20,159
uh

00:25:16,960 --> 00:25:22,799
workloads is a good target for this

00:25:20,159 --> 00:25:23,679
um there are a lot of different

00:25:22,799 --> 00:25:25,440
implementations

00:25:23,679 --> 00:25:27,279
from a hardware perspective on how

00:25:25,440 --> 00:25:28,320
confidential computing is being carried

00:25:27,279 --> 00:25:29,919
out

00:25:28,320 --> 00:25:31,600
but you know our goal and what we're

00:25:29,919 --> 00:25:33,440
working on is to abstract it away so

00:25:31,600 --> 00:25:34,559
that way they don't have to be exposed

00:25:33,440 --> 00:25:37,600
to this

00:25:34,559 --> 00:25:41,520
but still make it clear to understand

00:25:37,600 --> 00:25:44,320
what a level of isolation is there

00:25:41,520 --> 00:25:44,960
for the user uh and you know for the end

00:25:44,320 --> 00:25:47,039
user who

00:25:44,960 --> 00:25:48,240
down the road just wants to use this

00:25:47,039 --> 00:25:48,720
really they don't have to think about

00:25:48,240 --> 00:25:50,400
too much

00:25:48,720 --> 00:25:52,240
as long as the attestation frameworks

00:25:50,400 --> 00:25:55,520
and everything else are in place

00:25:52,240 --> 00:25:56,880
you know you are right in your same yaml

00:25:55,520 --> 00:25:58,799
and just adding a different runtime

00:25:56,880 --> 00:26:00,320
class ultimately so um

00:25:58,799 --> 00:26:01,840
it shouldn't have to change you

00:26:00,320 --> 00:26:04,080
certainly don't shouldn't have to change

00:26:01,840 --> 00:26:06,000
your actual application itself

00:26:04,080 --> 00:26:08,240
um and then the last point is that this

00:26:06,000 --> 00:26:10,159
is very much a work in progress

00:26:08,240 --> 00:26:11,840
um and you know the goal of kind of

00:26:10,159 --> 00:26:12,320
presenting here is to really put it out

00:26:11,840 --> 00:26:15,039
there

00:26:12,320 --> 00:26:16,720
get people's um to think about it and

00:26:15,039 --> 00:26:17,440
look for getting input and discussion

00:26:16,720 --> 00:26:19,679
from folks

00:26:17,440 --> 00:26:19,679
so

00:26:23,200 --> 00:26:28,880
at this point i think we are open for q

00:26:26,400 --> 00:26:30,960
a and we do have a link here to um the

00:26:28,880 --> 00:26:31,520
outstanding issue that samuel has put

00:26:30,960 --> 00:26:34,159
together

00:26:31,520 --> 00:26:34,799
um to kind of uh look at bringing

00:26:34,159 --> 00:26:36,720
support

00:26:34,799 --> 00:26:40,080
for kata containers for confidential

00:26:36,720 --> 00:26:40,080
computing and to end

00:26:40,960 --> 00:26:44,159

YouTube URL: https://www.youtube.com/watch?v=zTn9Xt1k1OA


