Title: Cloud Native & WebAssembly: Better Together - Liam Randall & Ralph Squillace
Publication date: 2021-05-13
Playlist: KubeCon + CloudNativeCon Europe 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Cloud Native & WebAssembly: Better Together - Liam Randall, Founder, Cosmonic & Co-Founder, Wasmcloud & Ralph Squillace, Principal PM, Azure Core Upstream, Microsoft Azure
Captions: 
	00:00:00,240 --> 00:00:03,199
good morning and thank you for coming to

00:00:01,920 --> 00:00:05,520
this kubecon eu

00:00:03,199 --> 00:00:06,399
2021 keynote cloud native and

00:00:05,520 --> 00:00:08,720
webassembly

00:00:06,399 --> 00:00:10,240
better together in today's keynote we're

00:00:08,720 --> 00:00:11,120
going to share the story of the rise of

00:00:10,240 --> 00:00:12,400
webassembly

00:00:11,120 --> 00:00:13,920
we're going to give you a high level

00:00:12,400 --> 00:00:14,559
overview of what webassembly is all

00:00:13,920 --> 00:00:16,240
about

00:00:14,559 --> 00:00:18,000
and why you should care and how web

00:00:16,240 --> 00:00:19,279
assembly and cloud native are better

00:00:18,000 --> 00:00:20,880
together

00:00:19,279 --> 00:00:22,080
i'm liam randall and i'm the co-founder

00:00:20,880 --> 00:00:24,080
of an open source framework for

00:00:22,080 --> 00:00:26,000
microservices called wasmcloud

00:00:24,080 --> 00:00:27,840
my co-speaker ralph is the principal

00:00:26,000 --> 00:00:29,679
program manager for azure core

00:00:27,840 --> 00:00:30,960
together we collaborate on a number of

00:00:29,679 --> 00:00:33,440
cloud native projects

00:00:30,960 --> 00:00:34,559
leveraging webassembly today ralph and i

00:00:33,440 --> 00:00:36,719
are going to take a few minutes to

00:00:34,559 --> 00:00:38,480
explain why cloud native and webassembly

00:00:36,719 --> 00:00:40,399
are simply just better together

00:00:38,480 --> 00:00:42,000
for the uninitiated webassembly

00:00:40,399 --> 00:00:45,120
abbreviated wasm

00:00:42,000 --> 00:00:47,280
or wasm is on the path to becoming

00:00:45,120 --> 00:00:48,320
as important to the enterprise and as

00:00:47,280 --> 00:00:50,719
ubiquitous

00:00:48,320 --> 00:00:52,800
as the container whether you realize it

00:00:50,719 --> 00:00:53,680
or not you are likely already adopting

00:00:52,800 --> 00:00:56,160
webassembly

00:00:53,680 --> 00:00:57,039
in your environment today the security

00:00:56,160 --> 00:00:59,199
portability

00:00:57,039 --> 00:01:01,039
and embed ability has developers

00:00:59,199 --> 00:01:03,520
throughout the cloud native ecosystem

00:01:01,039 --> 00:01:05,119
adopting both its power and potential

00:01:03,520 --> 00:01:06,960
we'll take you there but let us first

00:01:05,119 --> 00:01:09,119
set the stage

00:01:06,960 --> 00:01:11,040
over the last 30 years each wave of

00:01:09,119 --> 00:01:12,479
innovation has built upon

00:01:11,040 --> 00:01:14,799
and further scaled the previous

00:01:12,479 --> 00:01:16,799
generation's wave of technology

00:01:14,799 --> 00:01:19,200
we can observe that each new epoch of

00:01:16,799 --> 00:01:22,159
technology has been dominated

00:01:19,200 --> 00:01:23,360
by two dimensions the first dimension is

00:01:22,159 --> 00:01:24,880
its format

00:01:23,360 --> 00:01:26,960
the format is how we store our

00:01:24,880 --> 00:01:29,520
applications the what we deliver

00:01:26,960 --> 00:01:31,200
what we run and the what we move around

00:01:29,520 --> 00:01:33,040
the second critical dimension is the

00:01:31,200 --> 00:01:33,840
technology we use to orchestrate those

00:01:33,040 --> 00:01:37,200
formats

00:01:33,840 --> 00:01:38,400
to create delete scale and connect them

00:01:37,200 --> 00:01:40,400
together

00:01:38,400 --> 00:01:41,439
with the format and dimension in mind

00:01:40,400 --> 00:01:43,600
let me explain

00:01:41,439 --> 00:01:45,280
the parts of the picture in green are

00:01:43,600 --> 00:01:46,560
responses are the responsibility of the

00:01:45,280 --> 00:01:48,079
application builder

00:01:46,560 --> 00:01:49,680
and the parts of the picture that are in

00:01:48,079 --> 00:01:51,119
blue are the responsibility of the

00:01:49,680 --> 00:01:53,759
orchestration layer

00:01:51,119 --> 00:01:54,240
on the left the standalone pc started

00:01:53,759 --> 00:01:56,479
with an

00:01:54,240 --> 00:01:57,600
image and was manually orchestrated by

00:01:56,479 --> 00:01:59,280
the data center

00:01:57,600 --> 00:02:01,520
this gave way to the virtual machine and

00:01:59,280 --> 00:02:02,719
the virtual machine was orchestrated by

00:02:01,520 --> 00:02:04,799
the public cloud

00:02:02,719 --> 00:02:07,119
and we've segmented our formats even

00:02:04,799 --> 00:02:09,200
further with the rise of containers

00:02:07,119 --> 00:02:10,239
and portable pluggable multi-cloud

00:02:09,200 --> 00:02:13,920
orchestration

00:02:10,239 --> 00:02:15,920
with kubernetes now let's observe a few

00:02:13,920 --> 00:02:18,080
general trends and patterns

00:02:15,920 --> 00:02:20,000
first each epic is solved for the

00:02:18,080 --> 00:02:21,520
emerging challenges of the waves that

00:02:20,000 --> 00:02:23,920
came before it

00:02:21,520 --> 00:02:25,200
second in each progressive wave we

00:02:23,920 --> 00:02:26,800
increased the coupling of

00:02:25,200 --> 00:02:28,480
applications from their specific

00:02:26,800 --> 00:02:30,879
underlying environments

00:02:28,480 --> 00:02:31,840
the format itself embeds fewer

00:02:30,879 --> 00:02:34,000
assumptions

00:02:31,840 --> 00:02:35,680
than the format that came before it

00:02:34,000 --> 00:02:36,640
think back to the data center computers

00:02:35,680 --> 00:02:38,879
for example

00:02:36,640 --> 00:02:40,239
specific applications were tuned for

00:02:38,879 --> 00:02:43,120
specific hardware

00:02:40,239 --> 00:02:44,800
on which they resided with specific

00:02:43,120 --> 00:02:47,120
drivers

00:02:44,800 --> 00:02:48,640
third a further theme emerges the

00:02:47,120 --> 00:02:50,720
underlying layers become

00:02:48,640 --> 00:02:52,879
increasingly portable through

00:02:50,720 --> 00:02:54,879
plugability and extendability

00:02:52,879 --> 00:02:56,480
the virtual machine for example freezes

00:02:54,879 --> 00:02:59,519
from a specific size

00:02:56,480 --> 00:03:02,560
and type of computer and kubernetes

00:02:59,519 --> 00:03:05,280
frees us from a specific size and vendor

00:03:02,560 --> 00:03:07,440
of cloud

00:03:05,280 --> 00:03:08,959
fourth each wave continues to freeze

00:03:07,440 --> 00:03:10,239
further from the assumptions built into

00:03:08,959 --> 00:03:12,159
the previous generation

00:03:10,239 --> 00:03:14,720
the variable container lets developers

00:03:12,159 --> 00:03:17,280
ship and reproduce environments quickly

00:03:14,720 --> 00:03:19,440
fifth things today are hardly perfect

00:03:17,280 --> 00:03:22,480
and there are abundant assumptions

00:03:19,440 --> 00:03:23,120
baked into the way we design develop and

00:03:22,480 --> 00:03:25,599
deploy

00:03:23,120 --> 00:03:26,319
software even with containers for

00:03:25,599 --> 00:03:28,080
example

00:03:26,319 --> 00:03:30,080
we're all now living through the painful

00:03:28,080 --> 00:03:33,280
upheaval in cpu architectures

00:03:30,080 --> 00:03:35,760
with x86 and arm in the data center

00:03:33,280 --> 00:03:38,000
so as we consider what may be next let

00:03:35,760 --> 00:03:40,400
us then project these trends forward

00:03:38,000 --> 00:03:42,560
into the next wave so the fourth great

00:03:40,400 --> 00:03:43,200
epic of technology will continue a trend

00:03:42,560 --> 00:03:44,720
of

00:03:43,200 --> 00:03:47,440
further decoupling from underlying

00:03:44,720 --> 00:03:49,040
layers portability and extendability

00:03:47,440 --> 00:03:50,959
through plugability

00:03:49,040 --> 00:03:52,480
and freedom from some of today's

00:03:50,959 --> 00:03:55,599
assumptions

00:03:52,480 --> 00:03:56,799
so what's next the jobs to be done of

00:03:55,599 --> 00:03:59,360
the previous epic

00:03:56,799 --> 00:04:01,280
shaped the next epic's design the need

00:03:59,360 --> 00:04:03,360
for horizontally and skillable compute

00:04:01,280 --> 00:04:05,200
led to the rise of the public cloud the

00:04:03,360 --> 00:04:08,000
need for shippable environments

00:04:05,200 --> 00:04:09,680
led to the creation of the container in

00:04:08,000 --> 00:04:12,080
the design of everyday things we would

00:04:09,680 --> 00:04:14,159
recognize that we can use the clues

00:04:12,080 --> 00:04:15,120
in our environment to identify what we

00:04:14,159 --> 00:04:16,959
need next

00:04:15,120 --> 00:04:18,160
a well-designed product something that

00:04:16,959 --> 00:04:19,919
has real fit

00:04:18,160 --> 00:04:21,919
would have these intentions these

00:04:19,919 --> 00:04:22,960
intuitive cues that make it obvious how

00:04:21,919 --> 00:04:25,040
to use it

00:04:22,960 --> 00:04:26,320
and the solution today's to today's

00:04:25,040 --> 00:04:29,040
broad challenges

00:04:26,320 --> 00:04:30,880
will be less of a wow experience and

00:04:29,040 --> 00:04:34,320
feel more like a boring

00:04:30,880 --> 00:04:36,320
of course so here we are

00:04:34,320 --> 00:04:38,720
15 years into the launch of the public

00:04:36,320 --> 00:04:39,440
cloud eight years since the dawning of

00:04:38,720 --> 00:04:41,520
docker

00:04:39,440 --> 00:04:43,040
and seven years since the launch of

00:04:41,520 --> 00:04:45,040
kubernetes

00:04:43,040 --> 00:04:46,720
now the linux foundation edge has

00:04:45,040 --> 00:04:48,160
helpfully provided us with this

00:04:46,720 --> 00:04:51,120
wonderful continuum

00:04:48,160 --> 00:04:52,400
for what the coming world looks like and

00:04:51,120 --> 00:04:53,199
at first glance it feels pretty

00:04:52,400 --> 00:04:55,360
straightforward

00:04:53,199 --> 00:04:57,360
the next epic of technology therefore

00:04:55,360 --> 00:04:58,080
may account for the world from big to

00:04:57,360 --> 00:05:00,720
small

00:04:58,080 --> 00:05:02,479
from centralized to distributed now this

00:05:00,720 --> 00:05:04,720
broad summary can hardly show

00:05:02,479 --> 00:05:06,080
everything themes of infrastructure are

00:05:04,720 --> 00:05:08,080
bundled on the far

00:05:06,080 --> 00:05:09,120
right we have not a cloud we have

00:05:08,080 --> 00:05:11,120
multi-cloud

00:05:09,120 --> 00:05:13,120
and in the middle we have not just an

00:05:11,120 --> 00:05:14,720
edge but a multi-edge

00:05:13,120 --> 00:05:16,800
and at the user we have not just

00:05:14,720 --> 00:05:18,320
browsers but multi-browsers

00:05:16,800 --> 00:05:20,160
and it is clear that the world of

00:05:18,320 --> 00:05:20,960
tomorrow accelerates an existing

00:05:20,160 --> 00:05:23,199
challenge

00:05:20,960 --> 00:05:24,639
the incredible diversity in cpu

00:05:23,199 --> 00:05:26,639
architectures

00:05:24,639 --> 00:05:28,720
now let us take this world view and

00:05:26,639 --> 00:05:29,759
envision the great epics of technology

00:05:28,720 --> 00:05:31,199
laid over it

00:05:29,759 --> 00:05:33,039
if we consider the cloud native

00:05:31,199 --> 00:05:36,160
landscape as we understand it today

00:05:33,039 --> 00:05:36,720
we have so many great fits kubernetes on

00:05:36,160 --> 00:05:39,680
the edge

00:05:36,720 --> 00:05:41,120
and increasingly on the edges containers

00:05:39,680 --> 00:05:43,360
riding along with them

00:05:41,120 --> 00:05:44,400
into parts of the consumer edge we have

00:05:43,360 --> 00:05:47,120
service meshes like

00:05:44,400 --> 00:05:50,080
envoy we have policy engines like opa

00:05:47,120 --> 00:05:52,240
and dozens of other related projects

00:05:50,080 --> 00:05:54,160
so where in this view do we see those

00:05:52,240 --> 00:05:56,240
three tenets emerging

00:05:54,160 --> 00:05:58,080
where is the progressive decoupling

00:05:56,240 --> 00:05:59,919
where is the plugability

00:05:58,080 --> 00:06:01,199
where is the freedom from the broad

00:05:59,919 --> 00:06:04,720
assumptions that we

00:06:01,199 --> 00:06:06,560
embrace in today's models

00:06:04,720 --> 00:06:08,800
as we've accumulated these design

00:06:06,560 --> 00:06:10,400
criteria where might this happen in the

00:06:08,800 --> 00:06:13,440
cloud at the edge

00:06:10,400 --> 00:06:15,840
it is in fact not just one place

00:06:13,440 --> 00:06:17,039
webassembly builds upon the entire

00:06:15,840 --> 00:06:19,680
ecosystem

00:06:17,039 --> 00:06:22,080
and not just on the ecosystem web

00:06:19,680 --> 00:06:25,680
assembly is inside the ecosystem

00:06:22,080 --> 00:06:28,400
and in some places it is the ecosystem

00:06:25,680 --> 00:06:29,680
it is both compatible with and freeing

00:06:28,400 --> 00:06:32,160
from the assumptions

00:06:29,680 --> 00:06:33,199
of the previous generation it transcends

00:06:32,160 --> 00:06:35,840
our landscape

00:06:33,199 --> 00:06:37,360
and web assembly is poised to fit

00:06:35,840 --> 00:06:39,039
everywhere

00:06:37,360 --> 00:06:41,360
now if you haven't heard of webassembly

00:06:39,039 --> 00:06:43,120
let me start with what may seem to be an

00:06:41,360 --> 00:06:45,280
all too familiar promise

00:06:43,120 --> 00:06:47,520
webassembly was begun as a portable

00:06:45,280 --> 00:06:50,160
polygon compilation target for the web

00:06:47,520 --> 00:06:50,639
an idea like java silverlight or flash

00:06:50,160 --> 00:06:52,560
that

00:06:50,639 --> 00:06:53,680
promises right once and run everywhere

00:06:52,560 --> 00:06:56,720
execution

00:06:53,680 --> 00:06:57,680
and wasm difference differs both open

00:06:56,720 --> 00:07:00,560
source and free

00:06:57,680 --> 00:07:02,400
it's a community driven w3c standard

00:07:00,560 --> 00:07:04,479
created in close collaboration

00:07:02,400 --> 00:07:06,880
with browser engine vendors and shipping

00:07:04,479 --> 00:07:09,039
in all major browsers since 2017.

00:07:06,880 --> 00:07:10,720
webassembly is a compilation target and

00:07:09,039 --> 00:07:12,560
not a programming language

00:07:10,720 --> 00:07:14,720
this is a technology that enables

00:07:12,560 --> 00:07:16,479
developers and organizations

00:07:14,720 --> 00:07:18,720
to choose their languages their

00:07:16,479 --> 00:07:21,759
libraries and to deliver them with

00:07:18,720 --> 00:07:23,599
a consistent set of tenants and like

00:07:21,759 --> 00:07:24,479
many great technologies designed for the

00:07:23,599 --> 00:07:26,960
web before it

00:07:24,479 --> 00:07:28,960
such as javascript webassembly 2 has

00:07:26,960 --> 00:07:31,840
found a home outside the browser

00:07:28,960 --> 00:07:32,639
on the server on applications on the

00:07:31,840 --> 00:07:34,639
devices

00:07:32,639 --> 00:07:36,240
and even embedded in other platforms

00:07:34,639 --> 00:07:38,160
themselves

00:07:36,240 --> 00:07:39,440
and while the future of webassembly is

00:07:38,160 --> 00:07:41,280
simply dazzling

00:07:39,440 --> 00:07:43,919
today it already brings much to the

00:07:41,280 --> 00:07:45,280
table it's efficient and fast it runs at

00:07:43,919 --> 00:07:48,080
near native speed

00:07:45,280 --> 00:07:50,240
it's safe and secure not just sandboxed

00:07:48,080 --> 00:07:50,879
but it operates in a deny by default

00:07:50,240 --> 00:07:53,599
mode

00:07:50,879 --> 00:07:54,960
it's open and debuggable it's polyglot

00:07:53,599 --> 00:07:58,240
choose your own language

00:07:54,960 --> 00:08:01,440
it's portable from servers to browsers

00:07:58,240 --> 00:08:03,199
to embedded so today we already find

00:08:01,440 --> 00:08:06,479
webassembly runs in

00:08:03,199 --> 00:08:08,479
runs on and runs around cloud native

00:08:06,479 --> 00:08:10,720
as applications executing on our big

00:08:08,479 --> 00:08:13,120
servers as plugable engines

00:08:10,720 --> 00:08:15,680
embedded within our applications as

00:08:13,120 --> 00:08:18,319
platforms in their own right on the edge

00:08:15,680 --> 00:08:18,720
it's inside our browsers and yes it's

00:08:18,319 --> 00:08:22,000
even

00:08:18,720 --> 00:08:22,560
inside the iot webassembly is already

00:08:22,000 --> 00:08:24,800
showing up

00:08:22,560 --> 00:08:26,639
in our applications it's running in and

00:08:24,800 --> 00:08:28,639
around the cloud native ecosystem

00:08:26,639 --> 00:08:30,720
certainly most of us use webassembly on

00:08:28,639 --> 00:08:31,280
a regular basis whether we realize it or

00:08:30,720 --> 00:08:33,440
not

00:08:31,280 --> 00:08:34,640
it's speed and efficiency is part of the

00:08:33,440 --> 00:08:36,399
magic behind both

00:08:34,640 --> 00:08:38,719
google earth and microsoft microsoft

00:08:36,399 --> 00:08:40,399
flight simulator and the next crop of

00:08:38,719 --> 00:08:40,959
open source projects are already

00:08:40,399 --> 00:08:43,680
building

00:08:40,959 --> 00:08:45,440
with webassembly wasmcloud for example a

00:08:43,680 --> 00:08:46,399
distributed application runtime for the

00:08:45,440 --> 00:08:48,880
enterprise

00:08:46,399 --> 00:08:49,920
and cuborden a flexible and powerful

00:08:48,880 --> 00:08:52,640
admission controller

00:08:49,920 --> 00:08:53,360
for kubernetes both leverage wasm and

00:08:52,640 --> 00:08:54,959
these are just

00:08:53,360 --> 00:08:56,880
two of the hundreds of cloud native

00:08:54,959 --> 00:08:58,000
applications building on webassembly

00:08:56,880 --> 00:08:59,839
today

00:08:58,000 --> 00:09:02,480
and webassembly is being incorporated

00:08:59,839 --> 00:09:04,959
inside of existing cncf projects

00:09:02,480 --> 00:09:07,040
as an embedded engine webassembly's key

00:09:04,959 --> 00:09:09,680
value proposition around speed

00:09:07,040 --> 00:09:10,720
efficient size and security make it an

00:09:09,680 --> 00:09:13,040
attractive choice

00:09:10,720 --> 00:09:15,440
as an embedded engine where we might

00:09:13,040 --> 00:09:17,839
execute code from third parties

00:09:15,440 --> 00:09:18,800
where once you may have turned to lua or

00:09:17,839 --> 00:09:21,519
javascript

00:09:18,800 --> 00:09:22,240
we are now starting to find wasm for

00:09:21,519 --> 00:09:26,080
example

00:09:22,240 --> 00:09:29,120
both oppa and envoy both rely on wasm

00:09:26,080 --> 00:09:30,399
at their plugable cores and as a

00:09:29,120 --> 00:09:32,880
platform

00:09:30,399 --> 00:09:33,760
webassembly is not only one of the core

00:09:32,880 --> 00:09:35,600
technologies

00:09:33,760 --> 00:09:37,760
leveraged by companies like shopify and

00:09:35,600 --> 00:09:40,480
fastly but it's also showing up

00:09:37,760 --> 00:09:41,200
with the kubernetes rust kubelet or

00:09:40,480 --> 00:09:44,480
crustlet

00:09:41,200 --> 00:09:45,440
as a native payload and so it is as an

00:09:44,480 --> 00:09:47,839
application

00:09:45,440 --> 00:09:48,560
as an embedded engine as a platform in

00:09:47,839 --> 00:09:51,519
the browser

00:09:48,560 --> 00:09:52,399
or on the edge a new epoch of technology

00:09:51,519 --> 00:09:54,000
has emerged

00:09:52,399 --> 00:09:56,959
that decouples us further from the

00:09:54,000 --> 00:10:00,080
limitations of our previous world view

00:09:56,959 --> 00:10:03,200
webassembly security portability

00:10:00,080 --> 00:10:05,519
and decoupling of concerns transcend and

00:10:03,200 --> 00:10:08,000
are part of our cloud native landscape

00:10:05,519 --> 00:10:10,959
and both cloud native and web assembly

00:10:08,000 --> 00:10:10,959
are better together

00:10:11,600 --> 00:10:15,440
thanks liam as you just heard liam

00:10:13,680 --> 00:10:16,399
outline webassembly is perhaps

00:10:15,440 --> 00:10:18,640
surprisingly

00:10:16,399 --> 00:10:20,720
already here you may not have noticed it

00:10:18,640 --> 00:10:23,120
in envoy or istio or glue

00:10:20,720 --> 00:10:24,880
in cube warden or crustlet but it could

00:10:23,120 --> 00:10:25,839
already be running in your kubernetes

00:10:24,880 --> 00:10:27,839
clusters

00:10:25,839 --> 00:10:29,200
may not know that flight simulator or

00:10:27,839 --> 00:10:31,120
shopify uses it

00:10:29,200 --> 00:10:33,040
or that it's the way fastly does their

00:10:31,120 --> 00:10:35,040
compute at the edge

00:10:33,040 --> 00:10:36,320
already cloud native and like any good

00:10:35,040 --> 00:10:39,760
technology it's

00:10:36,320 --> 00:10:41,360
boring because it works it's the coming

00:10:39,760 --> 00:10:42,399
future that might add a little spice to

00:10:41,360 --> 00:10:44,079
the boredom

00:10:42,399 --> 00:10:46,399
have a seat i'll be talking about what's

00:10:44,079 --> 00:10:49,120
coming for a moment do a demo

00:10:46,399 --> 00:10:50,079
and tell you how you can get involved

00:10:49,120 --> 00:10:52,640
webassembly

00:10:50,079 --> 00:10:54,800
is already sandbox by default the first

00:10:52,640 --> 00:10:56,480
step to untrusted code

00:10:54,800 --> 00:10:59,360
but we want to take more steps in that

00:10:56,480 --> 00:11:00,160
direction in containerland we continue

00:10:59,360 --> 00:11:02,560
to apply

00:11:00,160 --> 00:11:04,320
all the best pod identity practices we

00:11:02,560 --> 00:11:06,800
use our back

00:11:04,320 --> 00:11:07,760
we prevent privileged containers among

00:11:06,800 --> 00:11:10,320
other things

00:11:07,760 --> 00:11:11,920
and these best practices are essentially

00:11:10,320 --> 00:11:14,640
continuing to find the holes

00:11:11,920 --> 00:11:15,360
and plug them web assembly has taken the

00:11:14,640 --> 00:11:18,079
next steps

00:11:15,360 --> 00:11:19,200
too and it's happening right now so if

00:11:18,079 --> 00:11:21,839
you're interested

00:11:19,200 --> 00:11:22,880
you can help out upstream or start

00:11:21,839 --> 00:11:25,200
experimenting

00:11:22,880 --> 00:11:26,640
either with some of the bytecode

00:11:25,200 --> 00:11:28,720
alliance projects

00:11:26,640 --> 00:11:31,920
or other run times and application

00:11:28,720 --> 00:11:33,680
models that are using webassembly

00:11:31,920 --> 00:11:34,959
for the past couple of years the members

00:11:33,680 --> 00:11:36,480
of the bytecode alliance have been

00:11:34,959 --> 00:11:39,120
collaborating on what they have been

00:11:36,480 --> 00:11:40,959
calling the nano process model

00:11:39,120 --> 00:11:42,880
something that brings portability and

00:11:40,959 --> 00:11:44,640
composability to the security and speed

00:11:42,880 --> 00:11:46,880
of local processes

00:11:44,640 --> 00:11:48,800
but with much lower overhead so that

00:11:46,880 --> 00:11:50,240
they can create a radical increase in

00:11:48,800 --> 00:11:53,519
agility

00:11:50,240 --> 00:11:56,160
the objective is secured shareability

00:11:53,519 --> 00:11:57,279
this is the genius of open source and

00:11:56,160 --> 00:11:59,200
containers

00:11:57,279 --> 00:12:01,120
without sacrificing performance or a

00:11:59,200 --> 00:12:03,279
native developer experience

00:12:01,120 --> 00:12:06,320
if containers are the big gears in cloud

00:12:03,279 --> 00:12:08,720
native webassembly components like this

00:12:06,320 --> 00:12:09,600
are like smaller gears in between the

00:12:08,720 --> 00:12:11,680
larger ones

00:12:09,600 --> 00:12:13,120
so that the entire mechanism can do more

00:12:11,680 --> 00:12:16,079
work

00:12:13,120 --> 00:12:17,040
let's click through all of this quickly

00:12:16,079 --> 00:12:20,480
first

00:12:17,040 --> 00:12:22,880
sandbox by default means the module has

00:12:20,480 --> 00:12:26,160
no access to anything

00:12:22,880 --> 00:12:28,800
default no not default yes

00:12:26,160 --> 00:12:29,519
if a runtime wants to offer a get random

00:12:28,800 --> 00:12:31,519
function

00:12:29,519 --> 00:12:34,320
it offers that function to the mod

00:12:31,519 --> 00:12:35,920
module the module does not otherwise

00:12:34,320 --> 00:12:37,760
have access

00:12:35,920 --> 00:12:39,680
this default stance is a great

00:12:37,760 --> 00:12:41,760
foundation

00:12:39,680 --> 00:12:43,760
the isolated memory model means that

00:12:41,760 --> 00:12:46,000
modules get their own memory

00:12:43,760 --> 00:12:47,760
they have no access to anyone else's

00:12:46,000 --> 00:12:52,000
memory and this

00:12:47,760 --> 00:12:55,279
is great third interface types bring

00:12:52,000 --> 00:12:57,440
two main features first they ensure that

00:12:55,279 --> 00:12:59,680
complex types can be passed into

00:12:57,440 --> 00:13:01,839
and received out of modules and that the

00:12:59,680 --> 00:13:05,920
languages will do this work for you

00:13:01,839 --> 00:13:07,360
not a complex manual chain of tools

00:13:05,920 --> 00:13:09,839
second they mean that

00:13:07,360 --> 00:13:11,360
this passing can be highly optimized and

00:13:09,839 --> 00:13:13,440
does not involve

00:13:11,360 --> 00:13:15,120
complex marshalling or serialization

00:13:13,440 --> 00:13:17,040
costs that occur

00:13:15,120 --> 00:13:19,519
in other inter-process communication

00:13:17,040 --> 00:13:21,360
environments it's very fast

00:13:19,519 --> 00:13:23,120
but still enables the typing and cross

00:13:21,360 --> 00:13:23,839
language functionality that a cloud

00:13:23,120 --> 00:13:27,839
native world

00:13:23,839 --> 00:13:30,000
needs now some things are done

00:13:27,839 --> 00:13:32,160
we can mostly pass complex types in and

00:13:30,000 --> 00:13:34,560
out that's really great

00:13:32,160 --> 00:13:35,680
but there are some things that are still

00:13:34,560 --> 00:13:37,839
in flight

00:13:35,680 --> 00:13:39,920
like handles to files and buffers these

00:13:37,839 --> 00:13:43,040
will likely appear very soon

00:13:39,920 --> 00:13:44,480
and i absolutely can't wait because

00:13:43,040 --> 00:13:45,839
there are some things that you want to

00:13:44,480 --> 00:13:48,160
do with files

00:13:45,839 --> 00:13:50,639
and networks this is part of the

00:13:48,160 --> 00:13:53,279
webassembly system interface work

00:13:50,639 --> 00:13:54,000
which is commonly called wazi now wazi

00:13:53,279 --> 00:13:56,079
does several

00:13:54,000 --> 00:13:58,639
things including enabling languages to

00:13:56,079 --> 00:14:00,800
target a single binary specification

00:13:58,639 --> 00:14:02,880
giving developers their current native

00:14:00,800 --> 00:14:04,720
dev iteration experience and ensuring

00:14:02,880 --> 00:14:06,639
that they just create their code the way

00:14:04,720 --> 00:14:08,800
they do now

00:14:06,639 --> 00:14:10,160
and securing memory internally and

00:14:08,800 --> 00:14:12,079
ensuring that modules can

00:14:10,160 --> 00:14:14,480
export and import things is great but

00:14:12,079 --> 00:14:17,120
code also does things against shared

00:14:14,480 --> 00:14:19,279
resources like files and networks

00:14:17,120 --> 00:14:21,600
and like processes and operating systems

00:14:19,279 --> 00:14:24,880
lozi ensures that calls have a fine

00:14:21,600 --> 00:14:26,560
green set of permissions or capabilities

00:14:24,880 --> 00:14:28,240
that they must have in order to use

00:14:26,560 --> 00:14:31,120
those resources

00:14:28,240 --> 00:14:33,600
it becomes possible to deny to code any

00:14:31,120 --> 00:14:35,360
outbound network permission for example

00:14:33,600 --> 00:14:37,279
and do it with the application rather

00:14:35,360 --> 00:14:39,680
than modifying the entire platform

00:14:37,279 --> 00:14:40,560
let's go to a demo first let's establish

00:14:39,680 --> 00:14:42,560
the environment

00:14:40,560 --> 00:14:44,800
as this is a deliberately simple example

00:14:42,560 --> 00:14:46,639
to ensure what is happening is clear

00:14:44,800 --> 00:14:48,880
you'll note that there are two crestlet

00:14:46,639 --> 00:14:50,720
agent nodes here one with wasmtime

00:14:48,880 --> 00:14:52,480
using the current wazi features which we

00:14:50,720 --> 00:14:54,560
had used several hours ago

00:14:52,480 --> 00:14:56,160
and one wasn't cloud node so that you

00:14:54,560 --> 00:14:57,839
can see that with crestlet you can run

00:14:56,160 --> 00:14:59,279
any web assembly runtime for which there

00:14:57,839 --> 00:15:00,959
is a provider

00:14:59,279 --> 00:15:03,199
let's have a quick look at the ammo for

00:15:00,959 --> 00:15:03,680
our web assembly if we've done things

00:15:03,199 --> 00:15:06,240
well

00:15:03,680 --> 00:15:08,399
it should be immediately understandable

00:15:06,240 --> 00:15:10,480
note two important things

00:15:08,399 --> 00:15:12,560
first the image is a web assembly module

00:15:10,480 --> 00:15:14,959
stored in azure container registry

00:15:12,560 --> 00:15:15,680
a project called wisem to oci makes this

00:15:14,959 --> 00:15:17,600
possible

00:15:15,680 --> 00:15:20,000
and it works for pretty much any oci

00:15:17,600 --> 00:15:20,959
registry but for kubernetes users this

00:15:20,000 --> 00:15:24,160
is irrelevant

00:15:20,959 --> 00:15:26,399
as it's just the image you want to run

00:15:24,160 --> 00:15:27,760
second the node selector is asking for a

00:15:26,399 --> 00:15:30,480
wasm cloud node

00:15:27,760 --> 00:15:32,160
not in linux or windows or anything else

00:15:30,480 --> 00:15:35,120
operations just got simpler

00:15:32,160 --> 00:15:37,440
no multi-arch images os based images

00:15:35,120 --> 00:15:39,600
it's always the same webassembly binary

00:15:37,440 --> 00:15:41,440
even if you change the wasm runtime

00:15:39,600 --> 00:15:42,800
let's start a simple file server just to

00:15:41,440 --> 00:15:45,839
watch it work

00:15:42,800 --> 00:15:47,279
cute control apply and we ensure the pod

00:15:45,839 --> 00:15:48,959
is running

00:15:47,279 --> 00:15:51,440
and then curl to the service to create a

00:15:48,959 --> 00:15:53,040
new file on the server

00:15:51,440 --> 00:15:55,759
and because we're running locally we can

00:15:53,040 --> 00:15:58,000
list the directory and see the file

00:15:55,759 --> 00:16:00,480
now let's go and print it out first

00:15:58,000 --> 00:16:00,480
locally

00:16:01,120 --> 00:16:05,519
and then by curling the file and finally

00:16:04,079 --> 00:16:07,600
delete it

00:16:05,519 --> 00:16:09,279
this is a simple application but the

00:16:07,600 --> 00:16:09,839
experience is the same whether it's

00:16:09,279 --> 00:16:12,959
simple

00:16:09,839 --> 00:16:12,959
or very complex

00:16:13,920 --> 00:16:17,120
now that application was a simple

00:16:15,600 --> 00:16:18,959
wasmcloud file server

00:16:17,120 --> 00:16:21,360
hosted on a crestlet node running in

00:16:18,959 --> 00:16:22,560
kubernetes not only were no oci

00:16:21,360 --> 00:16:24,160
containers involved

00:16:22,560 --> 00:16:25,600
we didn't even touch the advanced

00:16:24,160 --> 00:16:27,519
messaging and capabilities-based

00:16:25,600 --> 00:16:29,120
security of wasn't cloud

00:16:27,519 --> 00:16:31,199
nonetheless it should be clear that

00:16:29,120 --> 00:16:32,480
whether you're working inside kubernetes

00:16:31,199 --> 00:16:34,000
or building applications that

00:16:32,480 --> 00:16:35,839
communicate with it

00:16:34,000 --> 00:16:37,759
webassembly is likely to be a part of

00:16:35,839 --> 00:16:40,720
your cloud-native future

00:16:37,759 --> 00:16:42,560
so what can you do first get involved

00:16:40,720 --> 00:16:44,399
the bytecode alliance is a great place

00:16:42,560 --> 00:16:45,120
to join the webassembly community in one

00:16:44,399 --> 00:16:47,199
step

00:16:45,120 --> 00:16:49,199
but there are user groups and specific

00:16:47,199 --> 00:16:50,399
audiences like the linux foundation edge

00:16:49,199 --> 00:16:52,560
as well

00:16:50,399 --> 00:16:53,600
second pick a runtime and compile the

00:16:52,560 --> 00:16:56,240
webassembly

00:16:53,600 --> 00:16:58,800
tons of languages compiler wasm and the

00:16:56,240 --> 00:17:00,959
emerging wazi component approach

00:16:58,800 --> 00:17:03,360
give one of them a try and when new ones

00:17:00,959 --> 00:17:06,720
add wazi support try those as well

00:17:03,360 --> 00:17:09,600
and provide feedback or submit a pr

00:17:06,720 --> 00:17:10,480
third runwasm in your environment give

00:17:09,600 --> 00:17:12,880
it a try

00:17:10,480 --> 00:17:14,880
or embed wasm in your application or

00:17:12,880 --> 00:17:17,199
platform by using the language bindings

00:17:14,880 --> 00:17:19,520
for your favorite runtime

00:17:17,199 --> 00:17:21,199
as we continue uncoupling our business

00:17:19,520 --> 00:17:23,600
logic from our tech stacks and move

00:17:21,199 --> 00:17:25,919
closer and closer to zero trust code

00:17:23,600 --> 00:17:28,160
webassembly stands out as an important

00:17:25,919 --> 00:17:29,600
open source addition to kubernetes

00:17:28,160 --> 00:17:31,600
and as the webassembly component

00:17:29,600 --> 00:17:33,280
features begin to emerge its ability to

00:17:31,600 --> 00:17:34,400
run on multiple architectures and

00:17:33,280 --> 00:17:36,880
operating systems

00:17:34,400 --> 00:17:38,320
and in constrained environments means

00:17:36,880 --> 00:17:40,240
that you can start thinking how you're

00:17:38,320 --> 00:17:42,240
going to use it right now

00:17:40,240 --> 00:17:44,480
only you really know how to fill the

00:17:42,240 --> 00:17:47,840
webassembly landscape posted

00:17:44,480 --> 00:17:47,840

YouTube URL: https://www.youtube.com/watch?v=LfK7QYIU02A


