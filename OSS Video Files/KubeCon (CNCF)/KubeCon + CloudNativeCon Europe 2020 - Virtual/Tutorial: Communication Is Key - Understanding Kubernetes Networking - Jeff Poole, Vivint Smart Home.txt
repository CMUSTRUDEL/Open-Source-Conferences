Title: Tutorial: Communication Is Key - Understanding Kubernetes Networking - Jeff Poole, Vivint Smart Home
Publication date: 2020-08-27
Playlist: KubeCon + CloudNativeCon Europe 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming events: EnvoyCon Virtual on October 15 and KubeCon + CloudNativeCon North America 2020 Virtual from November 17-20. Learn more at https://kubecon.io. The conferences feature presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.  

Tutorial: Communication Is Key -- Understanding Kubernetes Networking - Jeff Poole, Vivint Smart Home 

Networking in Kubernetes has several aspects, including DNS, iptables, routing, software bridges, IP assignment, network policies, etc. While the practices for understanding the network were fairly easy to translate from physical servers to virtual machines, the level of complexity increases greatly when moving to containers in Kubernetes.  This tutorial will explain several of the networking concepts used in Kubernetes with accompanying lab exercises in a virtualized environment so that participants will become comfortable looking under the hood at how a Kubernetes cluster is working (or not working, as the case may be).  The material will be designed for people comfortable with SSH, bash, kubectl, and basic networking concepts, and will fill in the more advanced networking knowledge as the tutorial progresses. Please have Vagrant + VirtualBox installed to run the labs locally.

https://sched.co/Zej8
Captions: 
	00:00:00,160 --> 00:00:04,560
welcome to communication is key

00:00:02,080 --> 00:00:07,759
understanding kubernetes networking

00:00:04,560 --> 00:00:11,040
my name is jeff poole this is a

00:00:07,759 --> 00:00:12,080
tutorial so it'll be hands-on you can

00:00:11,040 --> 00:00:14,240
either

00:00:12,080 --> 00:00:16,400
watch me as i work or i'll give you the

00:00:14,240 --> 00:00:20,080
instructions so that you can

00:00:16,400 --> 00:00:21,439
try to work along with me kubernetes is

00:00:20,080 --> 00:00:24,400
a distributed system

00:00:21,439 --> 00:00:26,640
so it relies heavily on networking like

00:00:24,400 --> 00:00:28,720
all distributed systems

00:00:26,640 --> 00:00:31,279
but kubernetes is also very plugable you

00:00:28,720 --> 00:00:33,520
can change all sorts of things about it

00:00:31,279 --> 00:00:35,600
including the networking plugins you can

00:00:33,520 --> 00:00:40,399
change whether it uses ip tables

00:00:35,600 --> 00:00:43,520
or ebpf there's all sorts of

00:00:40,399 --> 00:00:44,960
knobs that you can tune in kubernetes in

00:00:43,520 --> 00:00:46,719
terms of the networking stack

00:00:44,960 --> 00:00:49,039
which makes it even more complicated

00:00:46,719 --> 00:00:49,600
than a normal distributed system that

00:00:49,039 --> 00:00:52,239
has

00:00:49,600 --> 00:00:54,640
fairly fixed networking protocols and

00:00:52,239 --> 00:00:56,079
standards

00:00:54,640 --> 00:00:59,039
so this makes it challenging to

00:00:56,079 --> 00:01:01,039
understand the goal of this tutorial

00:00:59,039 --> 00:01:03,920
is to demonstrate how things are

00:01:01,039 --> 00:01:03,920
supposed to work

00:01:04,239 --> 00:01:09,360
to also gain show you how to gain

00:01:07,920 --> 00:01:13,840
visibility

00:01:09,360 --> 00:01:17,600
into how it is working

00:01:13,840 --> 00:01:19,680
and learn how to debug networking issues

00:01:17,600 --> 00:01:21,439
in kubernetes as a result and

00:01:19,680 --> 00:01:24,840
application issues

00:01:21,439 --> 00:01:27,840
that could have a networking aspect to

00:01:24,840 --> 00:01:27,840
them

00:01:28,560 --> 00:01:32,560
so what i plan to cover here i'm going

00:01:30,880 --> 00:01:33,840
to do a brief introduction to general

00:01:32,560 --> 00:01:35,280
networking

00:01:33,840 --> 00:01:37,360
network name spaces and container

00:01:35,280 --> 00:01:40,079
networking mostly to make sure that

00:01:37,360 --> 00:01:41,759
we're on the same page and that i can

00:01:40,079 --> 00:01:45,119
use terminology

00:01:41,759 --> 00:01:46,880
without too much confusion

00:01:45,119 --> 00:01:49,119
then i'm going to focus on kubernetes

00:01:46,880 --> 00:01:52,000
services

00:01:49,119 --> 00:01:53,600
do a little dive into flannel with vxlan

00:01:52,000 --> 00:01:56,159
encapsulation

00:01:53,600 --> 00:01:59,439
and then take a tour of calico using ip

00:01:56,159 --> 00:01:59,439
over ip encapsulation

00:02:00,159 --> 00:02:03,520
so who's this for who should be

00:02:02,399 --> 00:02:05,520
attending this

00:02:03,520 --> 00:02:08,720
so first i think anyone who sets up

00:02:05,520 --> 00:02:10,959
clusters and needs to know how they work

00:02:08,720 --> 00:02:13,680
it'd be hard to be in a position where

00:02:10,959 --> 00:02:15,520
you have to bring up a cluster

00:02:13,680 --> 00:02:17,120
and then not know anything about the

00:02:15,520 --> 00:02:18,640
networking just have to rely on it

00:02:17,120 --> 00:02:20,080
magically working for you

00:02:18,640 --> 00:02:23,040
especially if you're bringing up on bare

00:02:20,080 --> 00:02:26,800
metal hosts or in a

00:02:23,040 --> 00:02:29,280
a less packaged environment

00:02:26,800 --> 00:02:30,480
than perhaps one of the cloud providers

00:02:29,280 --> 00:02:33,680
you know easy

00:02:30,480 --> 00:02:34,480
scale up kubernetes services i also

00:02:33,680 --> 00:02:36,080
think that

00:02:34,480 --> 00:02:37,519
developers who want to understand the

00:02:36,080 --> 00:02:41,440
limitations and advantages

00:02:37,519 --> 00:02:41,440
of how networking works in kubernetes

00:02:41,680 --> 00:02:46,239
i have had various roles over the years

00:02:45,360 --> 00:02:48,640
and

00:02:46,239 --> 00:02:50,480
in my roles as a software developer i

00:02:48,640 --> 00:02:52,400
found that if i don't understand

00:02:50,480 --> 00:02:53,599
what's going on in the layers below my

00:02:52,400 --> 00:02:56,080
code

00:02:53,599 --> 00:02:56,640
it's often hard to understand problems

00:02:56,080 --> 00:02:59,200
that come up

00:02:56,640 --> 00:03:00,640
in those layers or whether there's a

00:02:59,200 --> 00:03:03,360
problem with my application code

00:03:00,640 --> 00:03:04,080
or with the hardware operating system

00:03:03,360 --> 00:03:06,239
networking

00:03:04,080 --> 00:03:07,680
whatever so understanding how things

00:03:06,239 --> 00:03:08,879
work can help and then you know

00:03:07,680 --> 00:03:12,640
understanding for example

00:03:08,879 --> 00:03:15,760
can you send uh non-ip

00:03:12,640 --> 00:03:17,120
protocols to other pods things like that

00:03:15,760 --> 00:03:19,519
is useful depending on what you're

00:03:17,120 --> 00:03:22,080
trying to develop but i also think

00:03:19,519 --> 00:03:23,840
operations and network engineers who

00:03:22,080 --> 00:03:26,239
either are in charge of keeping things

00:03:23,840 --> 00:03:29,760
running and may have to debug them

00:03:26,239 --> 00:03:31,920
or just that you know need to

00:03:29,760 --> 00:03:33,680
be able to understand cluster networking

00:03:31,920 --> 00:03:34,640
so that they can do their jobs whether

00:03:33,680 --> 00:03:37,280
it's configuring

00:03:34,640 --> 00:03:38,080
network equipment that the cluster uses

00:03:37,280 --> 00:03:39,920
whether it's

00:03:38,080 --> 00:03:41,200
configuring networking on the hosts

00:03:39,920 --> 00:03:43,120
whether it's

00:03:41,200 --> 00:03:46,000
figuring out when things have gone wrong

00:03:43,120 --> 00:03:47,599
and you know

00:03:46,000 --> 00:03:49,440
it's a classic problem that your

00:03:47,599 --> 00:03:51,519
software developers

00:03:49,440 --> 00:03:52,560
want to say hey my code isn't working i

00:03:51,519 --> 00:03:53,760
think it's a network

00:03:52,560 --> 00:03:55,439
so you need to understand how the

00:03:53,760 --> 00:03:56,159
network is supposed to work so that you

00:03:55,439 --> 00:03:59,280
can tell them

00:03:56,159 --> 00:04:00,799
no it's actually your code i do expect a

00:03:59,280 --> 00:04:02,239
working knowledge of basic networking

00:04:00,799 --> 00:04:05,760
and linux tools here

00:04:02,239 --> 00:04:07,360
mostly because i can only teach so much

00:04:05,760 --> 00:04:11,120
without taking up

00:04:07,360 --> 00:04:11,120
all the time of introductory material

00:04:11,680 --> 00:04:15,280
so the environment that i'm planning on

00:04:13,439 --> 00:04:17,040
teaching in

00:04:15,280 --> 00:04:18,880
first if you want to follow along

00:04:17,040 --> 00:04:19,840
there's a repo here on the slide that

00:04:18,880 --> 00:04:23,520
you

00:04:19,840 --> 00:04:27,199
will want to clone it's github and

00:04:23,520 --> 00:04:29,520
you can read the url there and then

00:04:27,199 --> 00:04:30,479
once you clone that there are two

00:04:29,520 --> 00:04:32,800
options

00:04:30,479 --> 00:04:34,240
i've designed it so that you can run all

00:04:32,800 --> 00:04:35,520
this with docker and a tool called

00:04:34,240 --> 00:04:38,639
footloose

00:04:35,520 --> 00:04:41,520
footloose is a tool from weaveworks that

00:04:38,639 --> 00:04:42,160
lets you spin up a bunch of docker

00:04:41,520 --> 00:04:45,120
images

00:04:42,160 --> 00:04:45,840
that look like virtual machines and so

00:04:45,120 --> 00:04:47,919
this is

00:04:45,840 --> 00:04:50,000
the lightest weight way to get a

00:04:47,919 --> 00:04:52,320
kubernetes cluster up and running

00:04:50,000 --> 00:04:54,479
on your machine one of the problems i

00:04:52,320 --> 00:04:57,680
ran into when i was trying out different

00:04:54,479 --> 00:04:59,440
environments for this is that the amount

00:04:57,680 --> 00:05:01,840
of resources it can take to run several

00:04:59,440 --> 00:05:05,199
virtual machines at the same time

00:05:01,840 --> 00:05:06,880
it can be intense and i can't make any

00:05:05,199 --> 00:05:08,479
assumptions about what kind of hardware

00:05:06,880 --> 00:05:10,400
people are running with

00:05:08,479 --> 00:05:12,240
so i can't be like oh well everyone out

00:05:10,400 --> 00:05:14,320
there's got 32 gigs of ram so

00:05:12,240 --> 00:05:15,440
you know no problem if we give four gigs

00:05:14,320 --> 00:05:17,840
to each vm

00:05:15,440 --> 00:05:18,800
that's probably not a viable option so

00:05:17,840 --> 00:05:20,800
this is the lightweight

00:05:18,800 --> 00:05:21,840
lightest weight way to do it the biggest

00:05:20,800 --> 00:05:23,919
downsides of this

00:05:21,840 --> 00:05:25,440
other than having to have footloose

00:05:23,919 --> 00:05:27,600
running

00:05:25,440 --> 00:05:29,360
is that there are some weird

00:05:27,600 --> 00:05:33,120
interactions between the containers

00:05:29,360 --> 00:05:35,840
and the kernel of the host

00:05:33,120 --> 00:05:38,000
for example iptables if the kernel the

00:05:35,840 --> 00:05:40,560
host doesn't match the version

00:05:38,000 --> 00:05:42,320
that iptables and the container expects

00:05:40,560 --> 00:05:44,800
sometimes you'll see some weird results

00:05:42,320 --> 00:05:46,639
so that can't happen now if you've got a

00:05:44,800 --> 00:05:49,440
working vagrant and virtualbox setup

00:05:46,639 --> 00:05:50,240
i also have a vagrant file that should

00:05:49,440 --> 00:05:52,720
work

00:05:50,240 --> 00:05:54,080
that said it has been tested to the bare

00:05:52,720 --> 00:05:56,240
minimum

00:05:54,080 --> 00:05:57,120
so uh you know if you're comfortable

00:05:56,240 --> 00:06:00,400
debugging it

00:05:57,120 --> 00:06:01,039
great if not you can try either of these

00:06:00,400 --> 00:06:04,240
options

00:06:01,039 --> 00:06:06,160
and if all else fails i'll be

00:06:04,240 --> 00:06:07,680
around to try to help people out during

00:06:06,160 --> 00:06:10,880
this this talk

00:06:07,680 --> 00:06:11,120
but i also think that maybe the answer

00:06:10,880 --> 00:06:12,880
is

00:06:11,120 --> 00:06:15,199
you watch me do it and try to figure it

00:06:12,880 --> 00:06:16,560
out later

00:06:15,199 --> 00:06:17,919
um you probably can do all these

00:06:16,560 --> 00:06:18,800
demonstrations on other kubernetes

00:06:17,919 --> 00:06:20,880
clusters

00:06:18,800 --> 00:06:22,400
but if you want to do the exact same

00:06:20,880 --> 00:06:23,360
stuff i'm doing in the same environment

00:06:22,400 --> 00:06:27,120
i'm doing it

00:06:23,360 --> 00:06:28,880
then this is this is the best way to go

00:06:27,120 --> 00:06:30,160
obviously you're probably not going to

00:06:28,880 --> 00:06:32,400
get your production kubernetes cluster

00:06:30,160 --> 00:06:33,680
and swap out the networking layer so

00:06:32,400 --> 00:06:36,080
there are some things that would be hard

00:06:33,680 --> 00:06:37,280
to do in

00:06:36,080 --> 00:06:39,360
environments that people are depending

00:06:37,280 --> 00:06:40,560
on but certainly if you wanted to spin

00:06:39,360 --> 00:06:42,160
up

00:06:40,560 --> 00:06:43,680
sets of vms in different environments

00:06:42,160 --> 00:06:47,120
you could probably replicate these

00:06:43,680 --> 00:06:47,120
without using my tools at all

00:06:47,360 --> 00:06:54,160
i'm using k3s as my kubernetes layer

00:06:51,039 --> 00:06:56,639
it's a little bit different from vanilla

00:06:54,160 --> 00:06:58,960
kubernetes however it's lighter weight

00:06:56,639 --> 00:07:00,400
and very fast to start up and for a

00:06:58,960 --> 00:07:01,280
networking perspective it looks very

00:07:00,400 --> 00:07:04,080
close

00:07:01,280 --> 00:07:05,120
there's also a project k3d which is

00:07:04,080 --> 00:07:07,520
designed to run

00:07:05,120 --> 00:07:09,280
like k3s except in docker the only

00:07:07,520 --> 00:07:11,280
reason i didn't use that is because that

00:07:09,280 --> 00:07:12,800
leans on docker for the networking and

00:07:11,280 --> 00:07:15,280
therefore it's

00:07:12,800 --> 00:07:16,639
really hard to actually look into

00:07:15,280 --> 00:07:20,319
networking tools

00:07:16,639 --> 00:07:24,080
whereas this using k3d in these

00:07:20,319 --> 00:07:25,599
footloose virtual machines

00:07:24,080 --> 00:07:27,680
for lack of a term the containers that

00:07:25,599 --> 00:07:29,840
look like virtual machines

00:07:27,680 --> 00:07:31,440
they actually think that they are

00:07:29,840 --> 00:07:32,160
basically virtual machines on a real

00:07:31,440 --> 00:07:34,800
network

00:07:32,160 --> 00:07:35,520
so it looks a lot more like what you

00:07:34,800 --> 00:07:38,240
would expect

00:07:35,520 --> 00:07:39,360
if you were setting up actual hardware

00:07:38,240 --> 00:07:40,560
servers and connecting them with

00:07:39,360 --> 00:07:42,479
switches

00:07:40,560 --> 00:07:44,160
so this seemed to be the right trade-off

00:07:42,479 --> 00:07:45,039
for me in terms of having an environment

00:07:44,160 --> 00:07:46,800
that is

00:07:45,039 --> 00:07:48,879
relatively lightweight and easy to start

00:07:46,800 --> 00:07:53,759
up but also

00:07:48,879 --> 00:07:53,759
fairly true to how kubernetes works

00:07:56,479 --> 00:07:59,360
okay now i'm going to do a demo of how

00:07:58,160 --> 00:08:00,960
to get the environment set up and

00:07:59,360 --> 00:08:02,720
running

00:08:00,960 --> 00:08:06,000
okay let's talk about your options if

00:08:02,720 --> 00:08:08,560
you want to do these labs along with me

00:08:06,000 --> 00:08:09,919
the first thing you'll do regardless is

00:08:08,560 --> 00:08:13,840
you want to clone the repo

00:08:09,919 --> 00:08:13,840
where i've put all the scripts

00:08:14,879 --> 00:08:17,599
super simple

00:08:18,319 --> 00:08:22,080
now if you have a system where you have

00:08:20,639 --> 00:08:25,520
docker installed

00:08:22,080 --> 00:08:27,840
and footloose

00:08:25,520 --> 00:08:28,960
then you're you're ready to go now you

00:08:27,840 --> 00:08:30,560
can

00:08:28,960 --> 00:08:33,039
start running these scripts i've got

00:08:30,560 --> 00:08:34,399
bootscrap bootstrap.sh

00:08:33,039 --> 00:08:36,479
scripts in each of these folders to

00:08:34,399 --> 00:08:37,599
start a footloose cluster

00:08:36,479 --> 00:08:40,240
if you're in an environment where that

00:08:37,599 --> 00:08:42,479
won't work or you need

00:08:40,240 --> 00:08:43,839
to have a pristine outer environment

00:08:42,479 --> 00:08:45,279
there's a few cases where this will

00:08:43,839 --> 00:08:46,480
matter for example if you look at ip

00:08:45,279 --> 00:08:49,760
tables

00:08:46,480 --> 00:08:51,519
in a docker-based virtual machine

00:08:49,760 --> 00:08:54,480
running footloose

00:08:51,519 --> 00:08:56,399
and your kernel doesn't match what's in

00:08:54,480 --> 00:08:59,519
your host machine

00:08:56,399 --> 00:09:02,560
you sometimes get some weird results

00:08:59,519 --> 00:09:04,560
these are fairly small issues so

00:09:02,560 --> 00:09:05,920
the lightest weight way to run this is

00:09:04,560 --> 00:09:11,360
with footloose

00:09:05,920 --> 00:09:11,360
but if you need more you can

00:09:12,160 --> 00:09:16,640
run vagrant up and there's a vagrant

00:09:14,240 --> 00:09:19,200
file it's got a plug-in

00:09:16,640 --> 00:09:21,279
it's expected to use virtualbox it's set

00:09:19,200 --> 00:09:23,279
to use three gigs of ram

00:09:21,279 --> 00:09:24,399
i if any of these things don't work for

00:09:23,279 --> 00:09:27,600
you it may not

00:09:24,399 --> 00:09:28,800
work out like all sorts of weird stuff

00:09:27,600 --> 00:09:30,160
here

00:09:28,800 --> 00:09:32,000
in this case i don't have a virtual box

00:09:30,160 --> 00:09:35,760
on this this vm but

00:09:32,000 --> 00:09:38,959
you can run vagrant up vapor and ssh

00:09:35,760 --> 00:09:41,360
so after you run vagrant up and then

00:09:38,959 --> 00:09:46,160
vagrant ssh to get into the machine

00:09:41,360 --> 00:09:49,040
assuming everything works you can then

00:09:46,160 --> 00:09:50,160
become root because footloose is going

00:09:49,040 --> 00:09:52,480
to get

00:09:50,160 --> 00:09:54,399
unhappy with you if you're not root and

00:09:52,480 --> 00:09:57,120
then cd into the

00:09:54,399 --> 00:09:58,640
labs directory now i'm not in my vagrant

00:09:57,120 --> 00:09:59,440
machine right now so that that folder

00:09:58,640 --> 00:10:02,720
doesn't exist

00:09:59,440 --> 00:10:04,399
but slash labs will have mounted the git

00:10:02,720 --> 00:10:07,519
repo you started from

00:10:04,399 --> 00:10:09,600
so you'll have all the same folders that

00:10:07,519 --> 00:10:11,120
you would have if you were just sitting

00:10:09,600 --> 00:10:14,320
in that cloned repo

00:10:11,120 --> 00:10:14,320
and running this for footloose

00:10:14,800 --> 00:10:18,560
either option works like i said

00:10:16,640 --> 00:10:21,040
footloose directly is going to be the

00:10:18,560 --> 00:10:22,560
lightest weight version but if for some

00:10:21,040 --> 00:10:24,480
reason you

00:10:22,560 --> 00:10:26,800
need a compatible image on the outside

00:10:24,480 --> 00:10:27,279
that vagrant box uses debian 10 which is

00:10:26,800 --> 00:10:30,399
the same

00:10:27,279 --> 00:10:33,839
image that's used in the footloose

00:10:30,399 --> 00:10:36,880
docker based vms fair quotes

00:10:33,839 --> 00:10:38,640
and so that will make sure that the

00:10:36,880 --> 00:10:40,160
host kernel and the guest kernels are

00:10:38,640 --> 00:10:41,600
compatible and you won't see anything

00:10:40,160 --> 00:10:44,079
strange

00:10:41,600 --> 00:10:44,880
okay now let's cover some basic

00:10:44,079 --> 00:10:46,800
networking

00:10:44,880 --> 00:10:49,120
concepts just so i can refer to them

00:10:46,800 --> 00:10:49,120
later

00:10:50,160 --> 00:10:53,440
let's talk about how encapsulation works

00:10:51,839 --> 00:10:54,880
in networking in

00:10:53,440 --> 00:10:56,160
general for the purposes of this

00:10:54,880 --> 00:10:58,800
discussion i'm going to assume we're

00:10:56,160 --> 00:11:01,920
talking about ipv4 over ethernet

00:10:58,800 --> 00:11:02,640
ipv6 isn't super common yet and ethernet

00:11:01,920 --> 00:11:04,640
is

00:11:02,640 --> 00:11:07,040
the de facto standard for just about

00:11:04,640 --> 00:11:07,040
everything

00:11:07,200 --> 00:11:10,880
so let's say we want to send a packet

00:11:09,920 --> 00:11:13,519
via

00:11:10,880 --> 00:11:14,160
arbitrarily say udp could be tcp just as

00:11:13,519 --> 00:11:17,680
easily

00:11:14,160 --> 00:11:17,680
but we start with some data

00:11:18,000 --> 00:11:22,320
and then we wrap that in a udp packet so

00:11:21,040 --> 00:11:25,600
there's a udp header

00:11:22,320 --> 00:11:25,600
and then a payload of data

00:11:25,680 --> 00:11:30,959
and then the udp or tcp portion has the

00:11:28,959 --> 00:11:36,160
source destination ports that's part of

00:11:30,959 --> 00:11:39,120
the udp or tcp level which is layer four

00:11:36,160 --> 00:11:41,519
we then get that udp packet and we stick

00:11:39,120 --> 00:11:43,920
an ip header on it that's layer 3 in

00:11:41,519 --> 00:11:44,560
the networking stack that has the ip

00:11:43,920 --> 00:11:47,440
addresses

00:11:44,560 --> 00:11:48,079
source and destination and this is the

00:11:47,440 --> 00:11:50,880
level at which

00:11:48,079 --> 00:11:50,880
routing happens

00:11:52,320 --> 00:11:57,360
then we stick a layer 2 ethernet header

00:11:55,440 --> 00:11:59,279
on top of that

00:11:57,360 --> 00:12:01,040
and what this is used is to get your

00:11:59,279 --> 00:12:02,320
packet to the next hop on your local

00:12:01,040 --> 00:12:05,839
network

00:12:02,320 --> 00:12:07,360
so you either know

00:12:05,839 --> 00:12:09,600
the final destinations on your local

00:12:07,360 --> 00:12:11,600
network and address the ethernet packet

00:12:09,600 --> 00:12:14,079
to that destination

00:12:11,600 --> 00:12:15,760
or you know what the next hop should be

00:12:14,079 --> 00:12:19,760
and you address your ethernet packet

00:12:15,760 --> 00:12:22,959
to that hop on your local network

00:12:19,760 --> 00:12:27,040
when the packet gets to the next hop

00:12:22,959 --> 00:12:29,839
if it's destined for that machine

00:12:27,040 --> 00:12:30,560
then the ethernet packet ethernet header

00:12:29,839 --> 00:12:32,000
is removed

00:12:30,560 --> 00:12:34,079
the ip packet's sticking out and it's

00:12:32,000 --> 00:12:37,200
handed to the ip stack

00:12:34,079 --> 00:12:39,519
on the uh on the machine to to

00:12:37,200 --> 00:12:40,639
route to whatever process or the kernel

00:12:39,519 --> 00:12:44,079
or whatever needs to

00:12:40,639 --> 00:12:45,519
to get that packet if it's just an

00:12:44,079 --> 00:12:47,920
intermediate hop

00:12:45,519 --> 00:12:49,519
it'll look at the ip packet figure out

00:12:47,920 --> 00:12:51,839
what the next

00:12:49,519 --> 00:12:53,120
hop should be to get to that destination

00:12:51,839 --> 00:12:54,000
which may or may not be the final

00:12:53,120 --> 00:12:55,600
destination

00:12:54,000 --> 00:12:57,440
but it's the next hop that is reachable

00:12:55,600 --> 00:12:59,519
on the local network

00:12:57,440 --> 00:13:01,839
and it will put a new ethernet header on

00:12:59,519 --> 00:13:02,720
there with its address as a source

00:13:01,839 --> 00:13:04,839
address

00:13:02,720 --> 00:13:06,079
and that next top as the destination

00:13:04,839 --> 00:13:08,079
address

00:13:06,079 --> 00:13:09,600
so ethernet packets only last within a

00:13:08,079 --> 00:13:11,440
local network

00:13:09,600 --> 00:13:12,800
and the ip packet may be carried along

00:13:11,440 --> 00:13:14,720
in several ethernet packets

00:13:12,800 --> 00:13:17,360
along its way to the final ip

00:13:14,720 --> 00:13:17,360
destination

00:13:17,440 --> 00:13:23,680
okay now let's talk about docker or more

00:13:20,320 --> 00:13:23,680
generally container networking

00:13:24,800 --> 00:13:29,200
so docker allows you to run a process

00:13:26,959 --> 00:13:31,040
with various forms of isolation from the

00:13:29,200 --> 00:13:32,639
host operating system

00:13:31,040 --> 00:13:35,200
but for our purposes we're really

00:13:32,639 --> 00:13:36,959
worried about network isolation

00:13:35,200 --> 00:13:39,120
the other method other parts of it don't

00:13:36,959 --> 00:13:41,040
really matter for talk on networking

00:13:39,120 --> 00:13:42,560
so docker containers are run in network

00:13:41,040 --> 00:13:44,160
name spaces

00:13:42,560 --> 00:13:46,079
this means that they don't have access

00:13:44,160 --> 00:13:47,600
to the host network adapters by default

00:13:46,079 --> 00:13:50,959
and network name spaces allow you to

00:13:47,600 --> 00:13:53,519
isolate uh networking functionality

00:13:50,959 --> 00:13:54,000
the there's a default uh network name

00:13:53,519 --> 00:13:55,519
space

00:13:54,000 --> 00:13:57,440
often referred to as the root network

00:13:55,519 --> 00:13:59,440
namespace and that's where everything is

00:13:57,440 --> 00:14:02,720
by default unless you put it in a

00:13:59,440 --> 00:14:04,399
different network namespace

00:14:02,720 --> 00:14:05,760
let's talk about how docker works in in

00:14:04,399 --> 00:14:07,600
bridge mode

00:14:05,760 --> 00:14:09,600
we have a node it's got its root network

00:14:07,600 --> 00:14:12,639
namespace and also it has an ethernet

00:14:09,600 --> 00:14:15,040
adapter eth0

00:14:12,639 --> 00:14:17,040
when docker comes up it creates a bridge

00:14:15,040 --> 00:14:19,040
device generally called docker zero

00:14:17,040 --> 00:14:20,480
and it allocates a block of ips to

00:14:19,040 --> 00:14:24,079
containers

00:14:20,480 --> 00:14:26,560
the defaults 172.17

00:14:24,079 --> 00:14:29,360
16. so that means the last two octets

00:14:26,560 --> 00:14:31,360
are available for containers

00:14:29,360 --> 00:14:35,199
in this bridge device it operates like

00:14:31,360 --> 00:14:35,199
an ethernet switch running in software

00:14:35,600 --> 00:14:39,519
so that bridge gets attached to the host

00:14:37,040 --> 00:14:41,199
network interface

00:14:39,519 --> 00:14:43,120
and docker will create a new network

00:14:41,199 --> 00:14:44,000
namespace for each container it's trying

00:14:43,120 --> 00:14:46,480
to create

00:14:44,000 --> 00:14:49,120
i'm putting two here just to demonstrate

00:14:46,480 --> 00:14:49,120
a little bit better

00:14:49,199 --> 00:14:53,600
now docker will then create a virtual

00:14:51,680 --> 00:14:56,160
ethernet pair

00:14:53,600 --> 00:14:58,639
this is two devices that are effectively

00:14:56,160 --> 00:15:01,360
connected by a pipe

00:14:58,639 --> 00:15:02,800
you put data in one one of these devices

00:15:01,360 --> 00:15:05,600
it comes out the other

00:15:02,800 --> 00:15:06,560
very simple so it attaches one of the

00:15:05,600 --> 00:15:08,959
devices

00:15:06,560 --> 00:15:10,480
to the docker zero bridge and the other

00:15:08,959 --> 00:15:11,519
moves into the container's network

00:15:10,480 --> 00:15:15,760
namespace

00:15:11,519 --> 00:15:15,760
and names it if0 within that namespace

00:15:16,079 --> 00:15:19,360
it then gets assigned an ip from the

00:15:18,480 --> 00:15:22,480
range of

00:15:19,360 --> 00:15:24,079
ip addresses that that are associated

00:15:22,480 --> 00:15:26,399
with that bridge

00:15:24,079 --> 00:15:27,199
and then this means that the different

00:15:26,399 --> 00:15:29,759
containers

00:15:27,199 --> 00:15:31,440
have interfaces within the same subnet

00:15:29,759 --> 00:15:32,880
but with different ips so they can talk

00:15:31,440 --> 00:15:35,279
to each other across that bridge

00:15:32,880 --> 00:15:36,639
just like two devices on the same subnet

00:15:35,279 --> 00:15:39,600
with different ips can talk to each

00:15:36,639 --> 00:15:42,000
other across an ethernet switch

00:15:39,600 --> 00:15:43,920
uh traditionally docker doesn't really

00:15:42,000 --> 00:15:45,839
expose those container ips anything

00:15:43,920 --> 00:15:47,199
off the host containers or raw there's

00:15:45,839 --> 00:15:47,600
there's all sorts of solutions for this

00:15:47,199 --> 00:15:49,040
and

00:15:47,600 --> 00:15:51,360
docker swarm obviously has some

00:15:49,040 --> 00:15:53,040
solutions you can do port forwarding but

00:15:51,360 --> 00:15:54,720
it's not really part of the base docker

00:15:53,040 --> 00:15:56,079
functionality

00:15:54,720 --> 00:15:57,920
so getting traffic to and from

00:15:56,079 --> 00:15:59,920
containers on on other machines

00:15:57,920 --> 00:16:02,000
is one of the problems that kubernetes

00:15:59,920 --> 00:16:05,600
needs to solve to make this useful

00:16:02,000 --> 00:16:08,000
across a cluster of machines

00:16:05,600 --> 00:16:09,360
okay now let's take a look at container

00:16:08,000 --> 00:16:12,160
networking

00:16:09,360 --> 00:16:12,800
at the command line okay so let's take a

00:16:12,160 --> 00:16:15,519
quick look

00:16:12,800 --> 00:16:16,399
at how these interfaces work in the real

00:16:15,519 --> 00:16:19,759
world

00:16:16,399 --> 00:16:21,920
this is a fresh alpine vm

00:16:19,759 --> 00:16:24,079
you can see if i run ip adder there's a

00:16:21,920 --> 00:16:28,240
loopback and an ethernet interface

00:16:24,079 --> 00:16:28,240
pretty standard e0

00:16:30,959 --> 00:16:37,839
if i go ahead and install docker

00:16:40,240 --> 00:16:46,399
and then i start it you'll see we now

00:16:43,040 --> 00:16:46,399
have a docker zero interface

00:16:47,759 --> 00:16:52,240
and if i run bridge control show you can

00:16:50,160 --> 00:16:53,920
see it is in fact a bridge called docker

00:16:52,240 --> 00:17:05,839
0.

00:16:53,920 --> 00:17:05,839
let's try creating a vm

00:17:12,079 --> 00:17:18,880
okay so let's just run an alpine vm and

00:17:14,559 --> 00:17:21,280
have it sleep

00:17:18,880 --> 00:17:22,640
okay if i run an ipad or you can now see

00:17:21,280 --> 00:17:25,919
there's a new

00:17:22,640 --> 00:17:28,079
virtual ethernet interface it's

00:17:25,919 --> 00:17:30,160
interface number five and then ends with

00:17:28,079 --> 00:17:33,360
at if4

00:17:30,160 --> 00:17:35,840
this will be interesting so um another

00:17:33,360 --> 00:17:37,440
thing we can look at

00:17:35,840 --> 00:17:39,120
if you look at the bridge we now see

00:17:37,440 --> 00:17:41,520
that this same

00:17:39,120 --> 00:17:43,360
virtual ethernet interface is attached

00:17:41,520 --> 00:17:48,400
to it

00:17:43,360 --> 00:17:48,400
now what happens if we exec into that

00:17:51,280 --> 00:17:58,640
container okay i'm inside the container

00:17:56,799 --> 00:18:01,039
you can see inside here we have an

00:17:58,640 --> 00:18:03,679
interface it's just e0

00:18:01,039 --> 00:18:06,240
but it says at ifive note it's list is

00:18:03,679 --> 00:18:08,320
interface four

00:18:06,240 --> 00:18:09,360
this interface five in the root

00:18:08,320 --> 00:18:12,880
namespace

00:18:09,360 --> 00:18:13,760
network name space is a virtual ethernet

00:18:12,880 --> 00:18:17,360
device

00:18:13,760 --> 00:18:20,400
and it says at if4 these are two halves

00:18:17,360 --> 00:18:22,799
of the same pair so anything

00:18:20,400 --> 00:18:24,320
that you send out this interface

00:18:22,799 --> 00:18:26,559
actually goes through this virtual

00:18:24,320 --> 00:18:29,840
ethernet interface

00:18:26,559 --> 00:18:29,840
to our bridge

00:18:30,400 --> 00:18:34,720
and you can see another example this if

00:18:32,320 --> 00:18:37,520
i go and create a second

00:18:34,720 --> 00:18:37,520
alpine container

00:18:40,000 --> 00:18:44,799
you can see we now have another virtual

00:18:41,919 --> 00:18:44,799
ethernet interface

00:18:46,400 --> 00:18:56,559
we now have two interfaces attached to

00:18:49,600 --> 00:19:00,480
our docker zero bridge

00:18:56,559 --> 00:19:02,640
if i go into this new container

00:19:00,480 --> 00:19:04,880
you can see it says it's interface six

00:19:02,640 --> 00:19:07,039
e01 if7

00:19:04,880 --> 00:19:08,559
a7 in the root network namespace is at

00:19:07,039 --> 00:19:09,919
if6

00:19:08,559 --> 00:19:12,640
so you can see that these are the two

00:19:09,919 --> 00:19:14,240
houses pair another thing you can look

00:19:12,640 --> 00:19:15,679
at if

00:19:14,240 --> 00:19:18,320
i was to look it inside that other

00:19:15,679 --> 00:19:21,840
container you can see its ip address

00:19:18,320 --> 00:19:23,919
is 172.17.0.2

00:19:21,840 --> 00:19:25,440
in this container i can go ahead and

00:19:23,919 --> 00:19:27,440
ping that

00:19:25,440 --> 00:19:29,120
and what happens is it can reach that

00:19:27,440 --> 00:19:32,559
other host through the bridge

00:19:29,120 --> 00:19:34,000
they're on the same subnet so they

00:19:32,559 --> 00:19:35,360
because they're on the same segment

00:19:34,000 --> 00:19:36,240
there's actually an arp request that

00:19:35,360 --> 00:19:39,360
goes through

00:19:36,240 --> 00:19:39,360
if i do a um

00:19:44,320 --> 00:19:47,679
if i show my ip neighbor table you can

00:19:46,400 --> 00:19:53,360
see that

00:19:47,679 --> 00:19:56,080
i see that 172.17.0.2 ip address

00:19:53,360 --> 00:19:57,120
and i've got a mac address for it that

00:19:56,080 --> 00:19:59,039
is

00:19:57,120 --> 00:20:01,360
what we see in fact if i look in the

00:19:59,039 --> 00:20:06,159
other container

00:20:01,360 --> 00:20:08,640
that is the mac address it showed there

00:20:06,159 --> 00:20:10,240
so you can see that just like two

00:20:08,640 --> 00:20:11,360
devices plugged into a switch on a

00:20:10,240 --> 00:20:13,120
normal network

00:20:11,360 --> 00:20:15,919
these two containers can see each other

00:20:13,120 --> 00:20:15,919
across the bridge

00:20:16,640 --> 00:20:22,720
okay let's talk about ips

00:20:20,880 --> 00:20:24,640
so there's really three main groups of

00:20:22,720 --> 00:20:27,440
ip addresses in kubernetes

00:20:24,640 --> 00:20:29,919
node addresses pod addresses and service

00:20:27,440 --> 00:20:29,919
addresses

00:20:30,480 --> 00:20:33,600
for node addresses it's pretty simple

00:20:32,320 --> 00:20:36,559
every every node

00:20:33,600 --> 00:20:38,320
every machine needs an ip address this

00:20:36,559 --> 00:20:40,480
is used for nodes to talk to each other

00:20:38,320 --> 00:20:42,400
and the outside world and it exists

00:20:40,480 --> 00:20:43,600
before kubernetes is set up

00:20:42,400 --> 00:20:45,600
it's really outside the scope of

00:20:43,600 --> 00:20:46,799
kubernetes and it's designed by some

00:20:45,600 --> 00:20:49,919
outside process

00:20:46,799 --> 00:20:52,320
you know dhcp is an option can be manual

00:20:49,919 --> 00:20:53,360
a cloud provider might just magically

00:20:52,320 --> 00:20:54,720
assign it somehow

00:20:53,360 --> 00:20:58,320
and you just know it has an ip when it

00:20:54,720 --> 00:20:58,320
boots up doesn't really matter

00:20:58,480 --> 00:21:02,080
so pod addresses to review how

00:21:01,520 --> 00:21:04,320
kubernetes

00:21:02,080 --> 00:21:05,840
works in kubernetes a pod consists of

00:21:04,320 --> 00:21:07,840
one or more containers

00:21:05,840 --> 00:21:09,600
sharing the same network name space so

00:21:07,840 --> 00:21:10,159
they have that same virtual ethernet

00:21:09,600 --> 00:21:13,120
device

00:21:10,159 --> 00:21:13,679
as their e0 in the kubernetes network

00:21:13,120 --> 00:21:15,520
model

00:21:13,679 --> 00:21:16,640
every pod receives its own ip address

00:21:15,520 --> 00:21:18,240
and the idea is that all these ip

00:21:16,640 --> 00:21:19,120
addresses are globally routable within

00:21:18,240 --> 00:21:20,720
the cluster so

00:21:19,120 --> 00:21:23,200
any pod can talk to any other pod no

00:21:20,720 --> 00:21:24,320
matter what machine it's on

00:21:23,200 --> 00:21:26,159
these addresses are going to be

00:21:24,320 --> 00:21:27,679
allocated through the ipm functionality

00:21:26,159 --> 00:21:30,159
ip address management

00:21:27,679 --> 00:21:31,760
of the cni container network interface

00:21:30,159 --> 00:21:34,720
plugins you're using

00:21:31,760 --> 00:21:36,000
the most basic method is assigning a

00:21:34,720 --> 00:21:37,600
subnet to each node

00:21:36,000 --> 00:21:39,280
and then allowing that node to just hand

00:21:37,600 --> 00:21:40,640
out ips from that subnet because it

00:21:39,280 --> 00:21:43,919
knows which ones are in use

00:21:40,640 --> 00:21:45,679
on on itself and so it requires very

00:21:43,919 --> 00:21:47,919
little coordination other than assigning

00:21:45,679 --> 00:21:49,919
a unique subnet when the node gets set

00:21:47,919 --> 00:21:51,440
up in the first place

00:21:49,919 --> 00:21:53,520
sometimes networking plugins will do

00:21:51,440 --> 00:21:56,000
something fancier like allocate dynamic

00:21:53,520 --> 00:21:56,000
ips

00:21:56,080 --> 00:21:59,360
the cube api server process has a

00:21:58,320 --> 00:22:03,200
cluster sider

00:21:59,360 --> 00:22:05,840
flag which tells kubernetes what the

00:22:03,200 --> 00:22:10,080
range of expected pod ips are

00:22:05,840 --> 00:22:11,840
across the cluster okay now services

00:22:10,080 --> 00:22:13,679
the kubernetes service is an abstraction

00:22:11,840 --> 00:22:15,840
over a set of pods

00:22:13,679 --> 00:22:17,520
it's something that you can talk to and

00:22:15,840 --> 00:22:19,120
get a pod

00:22:17,520 --> 00:22:21,200
behind it without having to know how

00:22:19,120 --> 00:22:22,880
many pods are there if there's even more

00:22:21,200 --> 00:22:23,840
than one if it's on your host or

00:22:22,880 --> 00:22:26,400
different host

00:22:23,840 --> 00:22:29,600
doesn't matter all non-headless services

00:22:26,400 --> 00:22:31,280
will have a cluster ip assigned to them

00:22:29,600 --> 00:22:33,280
these cluster ips are handed out from a

00:22:31,280 --> 00:22:35,679
pool based on

00:22:33,280 --> 00:22:37,520
this kube api server flag service

00:22:35,679 --> 00:22:39,440
cluster ip range

00:22:37,520 --> 00:22:41,280
and the api server takes care of this

00:22:39,440 --> 00:22:42,240
generally the networking plugins aren't

00:22:41,280 --> 00:22:44,240
involved in ip

00:22:42,240 --> 00:22:45,600
address assignment for services at all

00:22:44,240 --> 00:22:47,039
because these services have to be

00:22:45,600 --> 00:22:49,120
globally assigned

00:22:47,039 --> 00:22:51,679
within the cluster anyway a service has

00:22:49,120 --> 00:22:54,720
one ip and the cluster

00:22:51,679 --> 00:22:57,200
so um the

00:22:54,720 --> 00:22:58,960
the api server will tell the kubelet

00:22:57,200 --> 00:23:02,000
processes what the service

00:22:58,960 --> 00:23:02,400
ips are and what the endpoints are for

00:23:02,000 --> 00:23:05,200
them

00:23:02,400 --> 00:23:07,120
and then the local networking stack on

00:23:05,200 --> 00:23:10,080
each node gets to be configured to

00:23:07,120 --> 00:23:10,080
support that service

00:23:10,240 --> 00:23:13,600
okay let's go take a look at it okay

00:23:13,200 --> 00:23:15,440
let's

00:23:13,600 --> 00:23:16,960
talk about getting the footloose cluster

00:23:15,440 --> 00:23:21,039
up and running and

00:23:16,960 --> 00:23:24,080
look into how services do

00:23:21,039 --> 00:23:27,919
routing to pods through ip tables

00:23:24,080 --> 00:23:29,679
so this is the repo that we checked out

00:23:27,919 --> 00:23:30,880
if you look in here we've got a calico

00:23:29,679 --> 00:23:33,760
directory in a final directory we're

00:23:30,880 --> 00:23:33,760
going to start in flannel

00:23:34,000 --> 00:23:39,840
and you'd see here we have a

00:23:36,440 --> 00:23:42,159
bootstrap.bootstrap.sh file

00:23:39,840 --> 00:23:46,000
you can see here we have a bootstrap.sh

00:23:42,159 --> 00:23:49,120
file and a footloose.yaml file

00:23:46,000 --> 00:23:51,279
first let's look at the footloose.yaml

00:23:49,120 --> 00:23:52,720
so this is the configuration for the

00:23:51,279 --> 00:23:56,080
footloose cluster

00:23:52,720 --> 00:23:56,720
now this spins up a bunch of uh docker

00:23:56,080 --> 00:23:59,120
images

00:23:56,720 --> 00:24:00,159
as if they were vms so it gives us a

00:23:59,120 --> 00:24:04,159
very lightweight

00:24:00,159 --> 00:24:06,000
way of having a cluster of vms

00:24:04,159 --> 00:24:07,440
just to show a few things here there's a

00:24:06,000 --> 00:24:10,960
cluster name

00:24:07,440 --> 00:24:12,640
i'm calling this footloose k8s

00:24:10,960 --> 00:24:14,240
you tell it how many machines to create

00:24:12,640 --> 00:24:16,960
this is designed for creating

00:24:14,240 --> 00:24:19,120
sets of homogenous machines so we're

00:24:16,960 --> 00:24:21,440
creating three machines

00:24:19,120 --> 00:24:23,120
we're using this debian temp image with

00:24:21,440 --> 00:24:25,279
a few extra things i've built into it so

00:24:23,120 --> 00:24:27,600
you don't have to download them later

00:24:25,279 --> 00:24:28,640
all the nodes are going to be named node

00:24:27,600 --> 00:24:33,279
0 1

00:24:28,640 --> 00:24:35,919
2. we need privileged for some

00:24:33,279 --> 00:24:38,080
some functionality of the os it's going

00:24:35,919 --> 00:24:40,880
to use a docker network called footloose

00:24:38,080 --> 00:24:42,240
cluster and the rest of this is sort of

00:24:40,880 --> 00:24:45,360
boilerplate

00:24:42,240 --> 00:24:47,760
if i look at bootstrap.sh this is the

00:24:45,360 --> 00:24:51,200
script you can run to bring this up

00:24:47,760 --> 00:24:52,640
it creates the docker network

00:24:51,200 --> 00:24:55,039
it will pull the image just to make sure

00:24:52,640 --> 00:24:56,960
you've got the latest version

00:24:55,039 --> 00:24:58,159
it runs footloose create which by

00:24:56,960 --> 00:25:02,880
default will use

00:24:58,159 --> 00:25:02,880
footloose.yaml to configure it

00:25:03,039 --> 00:25:07,679
once it's created the cluster i use

00:25:06,000 --> 00:25:10,880
footloose ssh

00:25:07,679 --> 00:25:14,080
to shell into node 0

00:25:10,880 --> 00:25:16,720
and i run the k3s installer so

00:25:14,080 --> 00:25:18,799
that that could set up as a master we're

00:25:16,720 --> 00:25:20,400
using k3s because it's a lighter weight

00:25:18,799 --> 00:25:22,320
distribution of kubernetes

00:25:20,400 --> 00:25:25,039
and while it's got a few quirks such as

00:25:22,320 --> 00:25:27,600
it doesn't use scd by default

00:25:25,039 --> 00:25:29,360
it's a compliant kubernetes distribution

00:25:27,600 --> 00:25:30,640
and its network behavior is

00:25:29,360 --> 00:25:33,279
very similar to what you would expect

00:25:30,640 --> 00:25:37,600
from a normal kubernetes distribution so

00:25:33,279 --> 00:25:37,600
it's a pretty good tool for this purpose

00:25:37,679 --> 00:25:41,679
after we set up the master there's a

00:25:40,400 --> 00:25:44,640
process to get the

00:25:41,679 --> 00:25:46,000
node token from the server which is what

00:25:44,640 --> 00:25:49,360
you need to authenticate

00:25:46,000 --> 00:25:50,960
uh agents or worker nodes against that

00:25:49,360 --> 00:25:55,039
master

00:25:50,960 --> 00:25:57,679
and then we install k3 us on the

00:25:55,039 --> 00:25:58,480
two worker nodes using that token and

00:25:57,679 --> 00:26:01,120
pointing them to

00:25:58,480 --> 00:26:01,120
node zero

00:26:04,320 --> 00:26:08,640
okay so let's go ahead and run the

00:26:05,840 --> 00:26:08,640
bootstrap script

00:26:09,520 --> 00:26:12,640
so the first thing that popped out that

00:26:11,039 --> 00:26:17,279
long string is just the

00:26:12,640 --> 00:26:19,120
id of the network docker created

00:26:17,279 --> 00:26:20,720
uh pulls the image fortunately i already

00:26:19,120 --> 00:26:22,960
have pulled so you don't have to wait

00:26:20,720 --> 00:26:25,360
very long

00:26:22,960 --> 00:26:26,240
you can see it's creating the three

00:26:25,360 --> 00:26:28,000
machines

00:26:26,240 --> 00:26:31,440
and you see how quickly it does it this

00:26:28,000 --> 00:26:34,960
is why i'm using footloose

00:26:31,440 --> 00:26:34,960
it's running the initial installer

00:26:35,279 --> 00:26:39,840
running on the second node and third

00:26:36,799 --> 00:26:39,840
node we're already up and running

00:26:40,799 --> 00:26:48,080
we can now foot loose ssh root at node 0

00:26:44,559 --> 00:26:53,840
and we are now on node 0.

00:26:48,080 --> 00:26:53,840
and just to prove it worked

00:26:55,200 --> 00:26:59,440
okay so you can see i can run cube

00:26:57,600 --> 00:27:01,360
cuddle get nodes

00:26:59,440 --> 00:27:04,320
right now it's the master node's fully

00:27:01,360 --> 00:27:06,240
up node one is not ready all the way

00:27:04,320 --> 00:27:07,760
okay node one's ready node two is not

00:27:06,240 --> 00:27:11,679
ready

00:27:07,760 --> 00:27:14,159
okay so we now have three

00:27:11,679 --> 00:27:14,159
nodes

00:27:15,120 --> 00:27:20,240
you can see they've got ip addresses

00:27:18,840 --> 00:27:23,200
172.19.0

00:27:20,240 --> 00:27:23,200
and then two three and four

00:27:23,919 --> 00:27:27,520
and just to prove that things are

00:27:25,200 --> 00:27:27,520
running

00:27:30,320 --> 00:27:33,440
you can see that we've got a bunch of

00:27:31,679 --> 00:27:35,919
stuff running in coop system that it

00:27:33,440 --> 00:27:38,399
started by default

00:27:35,919 --> 00:27:38,399
so now

00:27:42,000 --> 00:27:45,840
let's apply this hello kubernetes yml

00:27:43,919 --> 00:27:46,960
file i've got what this does it creates

00:27:45,840 --> 00:27:50,960
a service

00:27:46,960 --> 00:27:50,960
and three web servers behind it

00:27:52,159 --> 00:27:56,000
and it creates a default name space so i

00:27:53,840 --> 00:27:58,720
can just get po and you can see those

00:27:56,000 --> 00:27:58,720
are getting created

00:28:00,720 --> 00:28:05,760
service you can see here's the hello

00:28:02,559 --> 00:28:09,520
kubernetes service it's got a cluster ip

00:28:05,760 --> 00:28:12,159
that's its ip and it

00:28:09,520 --> 00:28:14,480
takes requests on port 80. so standard

00:28:12,159 --> 00:28:16,559
http

00:28:14,480 --> 00:28:17,679
okay our pods are running now another

00:28:16,559 --> 00:28:19,760
thing we can do is

00:28:17,679 --> 00:28:22,320
instead of get service we can get

00:28:19,760 --> 00:28:22,320
endpoints

00:28:27,760 --> 00:28:32,880
and you can see that we have these three

00:28:29,520 --> 00:28:32,880
endpoints behind that surface

00:28:33,919 --> 00:28:37,120
if i get the service ip

00:28:39,760 --> 00:28:47,039
and i curl it you see we get a page back

00:28:44,240 --> 00:28:49,440
now the part that's interesting here is

00:28:47,039 --> 00:28:59,840
it gives you its pod id

00:28:49,440 --> 00:29:02,399
it's the main reason i use this image

00:28:59,840 --> 00:29:02,399
so you can see

00:29:02,880 --> 00:29:09,600
if i keep running it i can see three

00:29:06,880 --> 00:29:11,520
different pod ids i end up getting so i

00:29:09,600 --> 00:29:13,039
know that by hitting that service ip

00:29:11,520 --> 00:29:15,120
i'm getting to all three pods on the

00:29:13,039 --> 00:29:18,240
back end

00:29:15,120 --> 00:29:19,520
so the next question is how does that

00:29:18,240 --> 00:29:21,360
happen

00:29:19,520 --> 00:29:22,880
and the the standard way of doing that

00:29:21,360 --> 00:29:24,840
kubernetes is through ip tables

00:29:22,880 --> 00:29:26,000
there's a few other solutions out there

00:29:24,840 --> 00:29:28,000
but

00:29:26,000 --> 00:29:31,200
most kubernetes installations right now

00:29:28,000 --> 00:29:31,200
we'll be using ip tables

00:29:31,679 --> 00:29:39,360
so let's take a look at the nat table

00:29:36,320 --> 00:29:42,159
and in particular let's look at

00:29:39,360 --> 00:29:42,159
cube service

00:29:42,960 --> 00:29:48,559
okay so we've got a chain called kube

00:29:46,399 --> 00:29:54,880
services

00:29:48,559 --> 00:29:56,159
and you'll see if we look down here

00:29:54,880 --> 00:29:58,799
we have some relating to hello

00:29:56,159 --> 00:29:58,799
kubernetes

00:29:59,279 --> 00:30:05,679
now this kube mark mask one

00:30:04,159 --> 00:30:08,320
we'll talk about in a little bit but

00:30:05,679 --> 00:30:11,520
just recognize that this only gets hit

00:30:08,320 --> 00:30:14,960
if the source is not

00:30:11,520 --> 00:30:17,360
in the pod network so

00:30:14,960 --> 00:30:18,399
if you if we scroll up and look at these

00:30:17,360 --> 00:30:23,200
pods

00:30:18,399 --> 00:30:27,120
they were 10.42 dot whatever

00:30:23,200 --> 00:30:29,200
so this is saying if it's not

00:30:27,120 --> 00:30:31,840
in the 10.42 network which means it's

00:30:29,200 --> 00:30:34,799
not coming from the pod network

00:30:31,840 --> 00:30:36,640
we're going to hit this path because if

00:30:34,799 --> 00:30:39,760
the destination is our

00:30:36,640 --> 00:30:40,480
service ip we're going to want to tag

00:30:39,760 --> 00:30:44,399
this to do

00:30:40,480 --> 00:30:47,279
some masquerading later if it is a pod

00:30:44,399 --> 00:30:48,240
we don't need to do the masquerading

00:30:47,279 --> 00:30:50,559
this next one

00:30:48,240 --> 00:30:52,240
says anything going to the service ip

00:30:50,559 --> 00:30:56,480
goes to this chain

00:30:52,240 --> 00:30:56,480
well let's take a look at that chain

00:30:57,519 --> 00:31:01,279
so this chain has three uh three rules

00:31:00,399 --> 00:31:04,399
in it

00:31:01,279 --> 00:31:05,919
and you may note we had three pods the

00:31:04,399 --> 00:31:09,679
first one gets hit

00:31:05,919 --> 00:31:10,960
with a random probability of one third

00:31:09,679 --> 00:31:13,840
so there's a one and three chance you'll

00:31:10,960 --> 00:31:13,840
go to the first one

00:31:13,919 --> 00:31:17,039
if you don't go to the first one you

00:31:15,440 --> 00:31:18,880
only have two pods left so there's only

00:31:17,039 --> 00:31:21,840
a 50 percent chance

00:31:18,880 --> 00:31:22,720
to hear the second and then if you fall

00:31:21,840 --> 00:31:26,000
through both of those

00:31:22,720 --> 00:31:32,000
you always go to the third one so let's

00:31:26,000 --> 00:31:35,120
take a look at these

00:31:32,000 --> 00:31:37,600
so the first one here it's also got a

00:31:35,120 --> 00:31:39,039
mark masquerade roll this one is the

00:31:37,600 --> 00:31:42,480
pods ip

00:31:39,039 --> 00:31:42,480
that we're the destination

00:31:42,559 --> 00:31:46,080
so what this next rule does it's a it's

00:31:44,640 --> 00:31:49,279
a dnat

00:31:46,080 --> 00:31:51,120
so destination net it says hey

00:31:49,279 --> 00:31:53,200
if we made it here we're going to change

00:31:51,120 --> 00:31:54,320
the destination from the service ip port

00:31:53,200 --> 00:32:00,159
00:31:54,320 --> 00:32:02,000
to the this pods ip port 8080.

00:32:00,159 --> 00:32:03,760
the reason we have this masquerade that

00:32:02,000 --> 00:32:05,679
matches at the source address is the

00:32:03,760 --> 00:32:09,679
same as that pod's ip

00:32:05,679 --> 00:32:11,760
is that if a pod tries to talk to some

00:32:09,679 --> 00:32:13,120
service ip

00:32:11,760 --> 00:32:15,519
the destination gets changed back to

00:32:13,120 --> 00:32:16,880
itself and it gets that packet

00:32:15,519 --> 00:32:18,640
when it tries to respond it's going to

00:32:16,880 --> 00:32:21,360
go i know exactly how to get there and

00:32:18,640 --> 00:32:23,279
try to send it locally

00:32:21,360 --> 00:32:24,399
it needs to go back through the nat

00:32:23,279 --> 00:32:26,720
process

00:32:24,399 --> 00:32:28,799
or else when the return packet comes

00:32:26,720 --> 00:32:32,080
back with an address that's not expected

00:32:28,799 --> 00:32:32,080
things are gonna get really confusing

00:32:32,159 --> 00:32:36,159
so this makes sure that it gets routed

00:32:34,640 --> 00:32:38,880
back through the host

00:32:36,159 --> 00:32:38,880
networking stack

00:32:40,240 --> 00:32:45,600
okay so as you can probably imagine

00:32:43,600 --> 00:32:48,240
if i look at another one of these i will

00:32:45,600 --> 00:32:51,760
just see a different

00:32:48,240 --> 00:32:56,000
pod ip so this one's 1.4

00:32:51,760 --> 00:32:58,960
and if i

00:32:56,000 --> 00:32:58,960
grab the pods again

00:33:01,440 --> 00:33:10,000
you can see that 10.42.1.4

00:33:04,799 --> 00:33:12,720
is the one running on node 1 10.42.0.7

00:33:10,000 --> 00:33:17,039
the one running on node 0. if i pulled

00:33:12,720 --> 00:33:20,320
up the last one it would have 10.42.2.3

00:33:17,039 --> 00:33:23,360
so this is how it gets

00:33:20,320 --> 00:33:25,760
for a destination service ip

00:33:23,360 --> 00:33:28,159
the networking stack randomly picks one

00:33:25,760 --> 00:33:32,000
of the back ends

00:33:28,159 --> 00:33:35,120
one other thing just to show the

00:33:32,000 --> 00:33:40,159
details of what happens with

00:33:35,120 --> 00:33:40,159
the the marking and masquerading

00:33:45,039 --> 00:33:48,320
and i guess i should also pull

00:33:51,679 --> 00:33:59,120
like up so if any of those

00:33:55,840 --> 00:34:02,559
cube mark mask rules get hit

00:33:59,120 --> 00:34:05,360
it will add hex 4000

00:34:02,559 --> 00:34:08,079
to the mark and then when you get to the

00:34:05,360 --> 00:34:11,760
post routing chain

00:34:08,079 --> 00:34:16,159
it will masquerade if it

00:34:11,760 --> 00:34:18,399
the mark matches uh 4 000 hex

00:34:16,159 --> 00:34:19,679
this random foley thing is nice in terms

00:34:18,399 --> 00:34:21,359
of it

00:34:19,679 --> 00:34:23,679
forces the networking stack to use

00:34:21,359 --> 00:34:26,879
random source ports

00:34:23,679 --> 00:34:29,440
so um you know the cases where you have

00:34:26,879 --> 00:34:30,000
one pod talking to another pod things

00:34:29,440 --> 00:34:32,480
are fine

00:34:30,000 --> 00:34:33,520
because the address will get translated

00:34:32,480 --> 00:34:37,359
on the way out

00:34:33,520 --> 00:34:39,679
get to the destination pod and then

00:34:37,359 --> 00:34:42,159
when uh when the traffic needs to come

00:34:39,679 --> 00:34:44,320
back it'll come back

00:34:42,159 --> 00:34:45,520
uh the net will be rev then adding will

00:34:44,320 --> 00:34:48,960
be reversed

00:34:45,520 --> 00:34:51,679
and the original pod won't know it's

00:34:48,960 --> 00:34:54,159
talking to some other ip

00:34:51,679 --> 00:34:55,440
but if the traffic was from outside the

00:34:54,159 --> 00:34:58,079
kubernetes cluster

00:34:55,440 --> 00:34:59,280
or you're not a pod then we probably

00:34:58,079 --> 00:35:00,160
need to force it to go through the

00:34:59,280 --> 00:35:03,200
current node

00:35:00,160 --> 00:35:05,119
just to make sure that it's handling

00:35:03,200 --> 00:35:06,720
both directions of traffic so it can

00:35:05,119 --> 00:35:09,040
reverse the nat

00:35:06,720 --> 00:35:10,400
and if it's coming from the destination

00:35:09,040 --> 00:35:11,839
pod itself

00:35:10,400 --> 00:35:13,680
we need to sort of force it to go

00:35:11,839 --> 00:35:14,640
through the node so it doesn't try to

00:35:13,680 --> 00:35:20,240
take a shortcut

00:35:14,640 --> 00:35:22,000
and skip that that natting phase

00:35:20,240 --> 00:35:23,680
so that's how services work with

00:35:22,000 --> 00:35:25,440
iptables

00:35:23,680 --> 00:35:27,040
okay let's talk about flannel a little

00:35:25,440 --> 00:35:28,320
bit

00:35:27,040 --> 00:35:30,480
so flannel's one of the earliest

00:35:28,320 --> 00:35:31,920
networking plugins and it's a decent

00:35:30,480 --> 00:35:34,400
choice for small clusters

00:35:31,920 --> 00:35:36,079
there are some issues when you get too

00:35:34,400 --> 00:35:36,640
large in terms of having to make sure

00:35:36,079 --> 00:35:39,839
your

00:35:36,640 --> 00:35:40,560
table size is large enough and it's

00:35:39,839 --> 00:35:44,480
really the same

00:35:40,560 --> 00:35:48,880
reasons why you don't make one ethernet

00:35:44,480 --> 00:35:51,599
subnet or you know ethernet lan too big

00:35:48,880 --> 00:35:52,560
but for small to medium-sized clusters

00:35:51,599 --> 00:35:54,320
just fine

00:35:52,560 --> 00:35:55,760
it's also the default for k3s which

00:35:54,320 --> 00:35:57,040
makes it a great place for us to start

00:35:55,760 --> 00:35:58,079
because we don't have to do anything

00:35:57,040 --> 00:36:01,200
special to configure

00:35:58,079 --> 00:36:03,599
it flannel runs on layer 2

00:36:01,200 --> 00:36:05,119
ethernet and the networking stack so all

00:36:03,599 --> 00:36:06,640
the pods can talk via ethernet as

00:36:05,119 --> 00:36:08,400
opposed to only ip

00:36:06,640 --> 00:36:11,280
so you don't have to necessarily use an

00:36:08,400 --> 00:36:14,640
ip-based protocol to talk between pods

00:36:11,280 --> 00:36:17,839
you can actually encapsulate non-ip

00:36:14,640 --> 00:36:17,839
stuff between your pods

00:36:20,400 --> 00:36:24,880
flannel uses a pod subnet that's

00:36:23,040 --> 00:36:26,720
statically assigned each kubernetes node

00:36:24,880 --> 00:36:28,960
when it comes to ip address management

00:36:26,720 --> 00:36:29,839
so pod ip allocation decisions are local

00:36:28,960 --> 00:36:32,720
to the node

00:36:29,839 --> 00:36:34,560
super simple the default encapsulation

00:36:32,720 --> 00:36:36,240
for flannel is vxlan which involves

00:36:34,560 --> 00:36:38,079
wrapping a layer 2 ethernet packet

00:36:36,240 --> 00:36:41,520
inside a udp packet

00:36:38,079 --> 00:36:43,359
so you have your ip packet typically

00:36:41,520 --> 00:36:45,280
wrapped in ethernet which then gets

00:36:43,359 --> 00:36:47,599
wrapped in udp which gets wrapped in ip

00:36:45,280 --> 00:36:48,880
which gets wrapped in ethernet

00:36:47,599 --> 00:36:50,640
there's a lot of pieces there and then

00:36:48,880 --> 00:36:51,599
vxlan has a little bit of header in that

00:36:50,640 --> 00:36:53,839
udp packet

00:36:51,599 --> 00:36:54,960
it's it's a little complicated and adds

00:36:53,839 --> 00:36:56,400
some overhead

00:36:54,960 --> 00:36:58,160
but it works pretty well and that way

00:36:56,400 --> 00:37:01,839
you can transport raw

00:36:58,160 --> 00:37:08,240
ethernet packets between pods

00:37:01,839 --> 00:37:09,760
okay let's dig in and take a look okay

00:37:08,240 --> 00:37:12,800
so let's take a little bit of a look

00:37:09,760 --> 00:37:12,800
at how flannel works

00:37:15,280 --> 00:37:19,200
first let's take a look at the

00:37:16,400 --> 00:37:19,200
interfaces we have

00:37:20,560 --> 00:37:25,119
you can see we've got a docker 0 but

00:37:22,400 --> 00:37:27,119
that's actually just a

00:37:25,119 --> 00:37:30,480
leftover from having docker installed

00:37:27,119 --> 00:37:33,920
it's not actually being used right now

00:37:30,480 --> 00:37:37,119
we have an interface called flannel1

00:37:33,920 --> 00:37:38,960
and we have an interface called cni0

00:37:37,119 --> 00:37:41,680
and then you can see all of our normal

00:37:38,960 --> 00:37:43,920
virtual ethernet interfaces

00:37:41,680 --> 00:37:43,920
so

00:37:45,839 --> 00:37:49,440
let's take a quick look at our bridges

00:37:47,760 --> 00:37:50,000
so you see docker 0 is a bridge but it's

00:37:49,440 --> 00:37:52,640
not really doing

00:37:50,000 --> 00:37:53,200
anything cni 0 is actually the bridge

00:37:52,640 --> 00:37:56,079
that

00:37:53,200 --> 00:37:57,680
this kubernetes cluster is using and you

00:37:56,079 --> 00:38:00,880
can see that the virtual ethernet

00:37:57,680 --> 00:38:04,960
interfaces from all my pods are attached

00:38:00,880 --> 00:38:08,400
to cni 0.

00:38:04,960 --> 00:38:11,280
so what happens if

00:38:08,400 --> 00:38:13,760
one pod tries to talk to another let's

00:38:11,280 --> 00:38:15,040
look at the routes

00:38:13,760 --> 00:38:19,240
okay so there's a couple routes here we

00:38:15,040 --> 00:38:22,240
can look at the first one

00:38:19,240 --> 00:38:22,240
172.19

00:38:23,480 --> 00:38:30,000
172.19 is the network that

00:38:26,320 --> 00:38:30,320
the nodes are on so this is the route

00:38:30,000 --> 00:38:33,440
that

00:38:30,320 --> 00:38:35,920
they take if we're talking node to node

00:38:33,440 --> 00:38:37,760
in this case you can see this node is

00:38:35,920 --> 00:38:39,599
not two

00:38:37,760 --> 00:38:41,520
so if it's trying to talk to the other

00:38:39,599 --> 00:38:45,359
nodes or dot three or dot four

00:38:41,520 --> 00:38:48,880
it'll go out eth0

00:38:45,359 --> 00:38:50,400
makes sense we can ignore the docker01

00:38:48,880 --> 00:38:53,280
because like i said that's not really

00:38:50,400 --> 00:38:53,280
not really being used

00:38:53,920 --> 00:39:02,720
so 10.42 is our pod network

00:38:58,880 --> 00:39:07,839
and it just so happens that 10.42.0.0

00:39:02,720 --> 00:39:07,839
is attached to this node in fact i can

00:39:12,839 --> 00:39:15,200
go

00:39:14,079 --> 00:39:17,680
take a quick look at the node

00:39:15,200 --> 00:39:23,440
information and you can see

00:39:17,680 --> 00:39:25,920
the pod cider is 10.42.0.0

00:39:23,440 --> 00:39:26,880
24. so slash 24 means only the last

00:39:25,920 --> 00:39:29,280
octet changes

00:39:26,880 --> 00:39:30,160
so everything on this all the pods on

00:39:29,280 --> 00:39:34,160
this node

00:39:30,160 --> 00:39:34,160
are going to start 10.42.0

00:39:34,240 --> 00:39:40,480
so if we open up that route table again

00:39:40,839 --> 00:39:44,640
10.42.0 is going to go to cni 0. that's

00:39:44,240 --> 00:39:47,839
our

00:39:44,640 --> 00:39:49,119
bridge so that makes sense if a packet

00:39:47,839 --> 00:39:51,440
is destined for a pod

00:39:49,119 --> 00:39:53,280
on this node we send it to the bridge

00:39:51,440 --> 00:39:54,800
and the bridge will figure out

00:39:53,280 --> 00:39:56,720
which interface it goes to to get to

00:39:54,800 --> 00:39:58,480
that pod

00:39:56,720 --> 00:40:01,359
now if we're looking at a pod on a

00:39:58,480 --> 00:40:06,160
different node those will be 10.42.

00:40:01,359 --> 00:40:07,920
something else dot one and dot two

00:40:06,160 --> 00:40:11,680
and you can see that both of these route

00:40:07,920 --> 00:40:13,920
via device flannel one

00:40:11,680 --> 00:40:15,520
so the question is what does flannel one

00:40:13,920 --> 00:40:18,800
do

00:40:15,520 --> 00:40:21,040
so by default flannel uses vxlan

00:40:18,800 --> 00:40:24,160
encapsulation

00:40:21,040 --> 00:40:25,680
vxlam encapsulates entire ethernet

00:40:24,160 --> 00:40:28,079
frames

00:40:25,680 --> 00:40:29,440
it gets them and it sticks them in a udp

00:40:28,079 --> 00:40:33,440
packet

00:40:29,440 --> 00:40:35,520
that it then sends to the other side so

00:40:33,440 --> 00:40:36,800
the question here is how's this all

00:40:35,520 --> 00:40:40,240
going to work

00:40:36,800 --> 00:40:40,240
let's see if we can demonstrate it

00:40:40,880 --> 00:40:44,480
first let's take a look at our what

00:40:42,640 --> 00:40:47,280
we've got going on i killed my pods

00:40:44,480 --> 00:40:47,280
since last time

00:40:49,280 --> 00:40:53,839
so let's go ahead and get those

00:40:50,839 --> 00:40:53,839
installed

00:40:57,920 --> 00:41:00,960
okay so those don't have ips yet but it

00:40:59,680 --> 00:41:02,319
looks like we'll get one on each node

00:41:00,960 --> 00:41:04,839
which is perfect

00:41:02,319 --> 00:41:06,480
so our node zero one is gonna be this

00:41:04,839 --> 00:41:09,680
guy

00:41:06,480 --> 00:41:11,839
i guess while i'm at it take a look at

00:41:09,680 --> 00:41:15,200
the services that's our service ip

00:41:11,839 --> 00:41:18,880
okay so

00:41:15,200 --> 00:41:22,160
our pods up yet great

00:41:18,880 --> 00:41:24,319
so let's see what happens if

00:41:22,160 --> 00:41:24,319
i

00:41:26,079 --> 00:41:29,200
in a different interface

00:41:29,920 --> 00:41:33,599
let's show you what i'm doing here this

00:41:31,119 --> 00:41:34,960
is t-shark so this is a terminal version

00:41:33,599 --> 00:41:38,640
of wireshark

00:41:34,960 --> 00:41:41,280
now there are several tools you can use

00:41:38,640 --> 00:41:43,440
for capturing packets on the terminal

00:41:41,280 --> 00:41:45,760
tcp dump is probably the most

00:41:43,440 --> 00:41:46,880
standard n grip is another one

00:41:45,760 --> 00:41:48,400
especially if you're

00:41:46,880 --> 00:41:49,920
great if you're looking at text-based

00:41:48,400 --> 00:41:51,839
network traffic and looking for like

00:41:49,920 --> 00:41:54,880
strings in a packet

00:41:51,839 --> 00:41:56,319
t-shark is like the terminal version of

00:41:54,880 --> 00:41:57,760
wireshark so it's got a lot of extra

00:41:56,319 --> 00:41:59,119
capabilities

00:41:57,760 --> 00:42:02,720
um which is which i'm going to take

00:41:59,119 --> 00:42:04,880
advantage of here so you may wonder i'm

00:42:02,720 --> 00:42:08,400
looking at port 8472

00:42:04,880 --> 00:42:10,720
oh you'll see in a moment

00:42:08,400 --> 00:42:13,200
okay so our pods are running so let's do

00:42:10,720 --> 00:42:17,040
a cube control

00:42:13,200 --> 00:42:20,720
uh exec

00:42:17,040 --> 00:42:22,240
let's go into the pod locally

00:42:20,720 --> 00:42:24,240
because we want to see stuff on this

00:42:22,240 --> 00:42:28,240
node so i want to make sure i don't

00:42:24,240 --> 00:42:31,839
totally involve unrelated pods

00:42:28,240 --> 00:42:31,839
and then let's just do a curl

00:42:32,880 --> 00:42:37,599
uh use the service ip

00:42:40,720 --> 00:42:45,839
and for fun let's go and grew up for

00:42:48,640 --> 00:42:59,839
hello kubernetes

00:43:00,960 --> 00:43:13,839
and that's when i remember that i don't

00:43:02,319 --> 00:43:13,839
have curl installed

00:43:15,680 --> 00:43:18,640
okay that's clean

00:43:21,520 --> 00:43:26,319
so let's take a look here so we've got a

00:43:24,000 --> 00:43:29,599
bunch of packets

00:43:26,319 --> 00:43:32,079
um so the note i'm on so node zero has

00:43:29,599 --> 00:43:34,800
the ip address ends in dot two

00:43:32,079 --> 00:43:36,480
it tried to talk to this guy which is

00:43:34,800 --> 00:43:39,760
node one

00:43:36,480 --> 00:43:40,000
and send a udp packet and the udp packet

00:43:39,760 --> 00:43:42,800
came

00:43:40,000 --> 00:43:44,319
back and then sent another one and sent

00:43:42,800 --> 00:43:47,520
another one

00:43:44,319 --> 00:43:51,599
another one back another one back

00:43:47,520 --> 00:43:55,280
um this node sent

00:43:51,599 --> 00:43:57,599
one sent another received one send one

00:43:55,280 --> 00:43:59,040
okay so you look at this and you think

00:43:57,599 --> 00:44:00,720
what in the world's going on here this

00:43:59,040 --> 00:44:02,800
isn't very useful

00:44:00,720 --> 00:44:05,040
uh and that's true so what we're seeing

00:44:02,800 --> 00:44:07,680
here is the vxlan traffic by default

00:44:05,040 --> 00:44:08,560
uh flannel is going to use port 8472 for

00:44:07,680 --> 00:44:11,280
its vxlan

00:44:08,560 --> 00:44:13,119
traffic but as you can see here all we

00:44:11,280 --> 00:44:14,160
can tell is two nodes are exchanging udp

00:44:13,119 --> 00:44:15,440
packets

00:44:14,160 --> 00:44:17,359
so when you're trying to debug what's

00:44:15,440 --> 00:44:19,839
going on in a

00:44:17,359 --> 00:44:20,640
network running flannel you have to dig

00:44:19,839 --> 00:44:22,160
a little deeper

00:44:20,640 --> 00:44:23,760
because right now all you can see is

00:44:22,160 --> 00:44:24,160
packets are flowing between two nodes

00:44:23,760 --> 00:44:26,800
and

00:44:24,160 --> 00:44:28,400
in a decent size cluster with a lot of

00:44:26,800 --> 00:44:29,920
pods doing a lot of things

00:44:28,400 --> 00:44:31,440
you're just going to see a ton of udp

00:44:29,920 --> 00:44:34,839
traffic and

00:44:31,440 --> 00:44:38,319
have no idea what's talking to what

00:44:34,839 --> 00:44:39,359
so let's try this again except i'm going

00:44:38,319 --> 00:44:42,800
to

00:44:39,359 --> 00:44:45,880
add something else this tells

00:44:42,800 --> 00:44:48,880
t-shark that things on udp port

00:44:45,880 --> 00:44:51,839
8472 should be considered

00:44:48,880 --> 00:44:51,839
vxlan

00:44:52,079 --> 00:44:56,720
and t-shark knows about vxlan so that

00:44:54,560 --> 00:44:59,599
works

00:44:56,720 --> 00:44:59,599
so let me try this

00:45:00,000 --> 00:45:06,480
okay now

00:45:04,400 --> 00:45:07,520
when we look at this packet capture you

00:45:06,480 --> 00:45:10,640
can see

00:45:07,520 --> 00:45:13,040
it's showing i should probably come up

00:45:10,640 --> 00:45:15,359
here and check

00:45:13,040 --> 00:45:17,200
our new our pod on node 0 that we're

00:45:15,359 --> 00:45:20,960
writing the request from

00:45:17,200 --> 00:45:23,599
has this 10.42.0.9 ip

00:45:20,960 --> 00:45:24,079
and we were we sent that request to the

00:45:23,599 --> 00:45:27,760
one on

00:45:24,079 --> 00:45:32,720
node 1. so we should be sending from 0.9

00:45:27,760 --> 00:45:37,359
to 1.3

00:45:32,720 --> 00:45:40,880
so sure enough 0.9 sent a tcp syn packet

00:45:37,359 --> 00:45:40,880
starting connection to 1.3

00:45:40,960 --> 00:45:48,160
uh we got a syn ack back

00:45:44,800 --> 00:45:51,359
which is the next part in the handshake

00:45:48,160 --> 00:45:53,920
an act gets sent and then because

00:45:51,359 --> 00:45:55,440
t-shark and wireshark have advanced

00:45:53,920 --> 00:45:56,640
packet dissectors

00:45:55,440 --> 00:45:58,880
they can dig in there and go hey this

00:45:56,640 --> 00:46:02,000
was actually an http request

00:45:58,880 --> 00:46:04,319
getting slash and then you can see that

00:46:02,000 --> 00:46:07,599
we got a response of a 200 okay

00:46:04,319 --> 00:46:11,119
and then the connection got torn down

00:46:07,599 --> 00:46:13,440
so by actually telling it to

00:46:11,119 --> 00:46:16,319
get these udp packets interpret them as

00:46:13,440 --> 00:46:20,160
vxlan we can see what's inside them

00:46:16,319 --> 00:46:22,560
and for an extra level of detail

00:46:20,160 --> 00:46:23,760
we can use dash capital v now i'm only

00:46:22,560 --> 00:46:25,119
going to capture two packets here

00:46:23,760 --> 00:46:28,720
because this is

00:46:25,119 --> 00:46:31,920
really verbose so

00:46:28,720 --> 00:46:31,920
let's run another one of these

00:46:32,400 --> 00:46:38,079
okay lots of stuff let me just scroll to

00:46:35,760 --> 00:46:38,079
the top

00:46:39,680 --> 00:46:43,599
so it captured a frame so it captured an

00:46:42,240 --> 00:46:45,920
ethernet frame

00:46:43,599 --> 00:46:48,640
okay everything's pretty much ethernet

00:46:45,920 --> 00:46:51,280
at the at the lowest level here

00:46:48,640 --> 00:46:51,680
inside the ethernet is an ipv4 packet

00:46:51,280 --> 00:46:52,960
okay

00:46:51,680 --> 00:46:57,760
sounds good and you can see this is

00:46:52,960 --> 00:47:02,560
between two node addresses

00:46:57,760 --> 00:47:06,560
inside that ipv4 packet is a udp packet

00:47:02,560 --> 00:47:06,560
i'm going to port 8472

00:47:07,200 --> 00:47:12,880
hey look it interpreted that as

00:47:10,319 --> 00:47:14,720
virtual extensible local area network or

00:47:12,880 --> 00:47:16,880
vxlan

00:47:14,720 --> 00:47:18,560
and so you can read the details of vxlan

00:47:16,880 --> 00:47:18,880
packet there's not a whole lot of data

00:47:18,560 --> 00:47:21,599
there

00:47:18,880 --> 00:47:22,319
the main thing that you might care about

00:47:21,599 --> 00:47:25,119
if you run

00:47:22,319 --> 00:47:26,319
multiple vxlan networks is that the

00:47:25,119 --> 00:47:29,599
vxlan network id

00:47:26,319 --> 00:47:32,800
vni is right here

00:47:29,599 --> 00:47:35,119
so the vni of one

00:47:32,800 --> 00:47:37,680
that's a default you can change it if

00:47:35,119 --> 00:47:39,359
you have multiple vxl networks but

00:47:37,680 --> 00:47:41,359
that that helps you separate traffic if

00:47:39,359 --> 00:47:44,720
you need to

00:47:41,359 --> 00:47:45,200
inside the vxlan packet is an ethernet

00:47:44,720 --> 00:47:48,240
packet

00:47:45,200 --> 00:47:50,000
remember vxlan encapsulates layer two

00:47:48,240 --> 00:47:51,440
packets so it encapsulates the entire

00:47:50,000 --> 00:47:53,040
ethernet packet

00:47:51,440 --> 00:47:54,480
this is interesting because there's some

00:47:53,040 --> 00:47:56,800
protocols you can't

00:47:54,480 --> 00:47:59,599
run over ip alone so things that rely on

00:47:56,800 --> 00:48:03,280
like multicast or

00:47:59,599 --> 00:48:06,400
you know like dhcp you can't run over ip

00:48:03,280 --> 00:48:09,920
it runs over over ethernet

00:48:06,400 --> 00:48:12,160
so we have an ethernet pack inside our

00:48:09,920 --> 00:48:13,440
vxlan packet

00:48:12,160 --> 00:48:15,920
i don't feel like looking up all the mac

00:48:13,440 --> 00:48:17,040
addresses but we could and it would we'd

00:48:15,920 --> 00:48:17,920
be able to make some sense out of them

00:48:17,040 --> 00:48:19,119
if we did

00:48:17,920 --> 00:48:21,440
but you can see inside that username

00:48:19,119 --> 00:48:25,040
packet is an ip packet

00:48:21,440 --> 00:48:29,520
and this one is going between pod ips

00:48:25,040 --> 00:48:32,480
so we had ip packets between the nodes

00:48:29,520 --> 00:48:34,800
that had udp payloads that were

00:48:32,480 --> 00:48:35,440
interpreted as vxlan that had ethernet

00:48:34,800 --> 00:48:40,160
packets

00:48:35,440 --> 00:48:43,200
that had ip packets between the pods

00:48:40,160 --> 00:48:43,200
and you can see also

00:48:43,760 --> 00:48:47,280
that inside this ip packet is tcp

00:48:46,559 --> 00:48:50,720
because

00:48:47,280 --> 00:48:53,760
http requests are tcp so

00:48:50,720 --> 00:48:54,880
vxlan uses udp on the outside but when

00:48:53,760 --> 00:48:55,680
you dig all the way in you're actually

00:48:54,880 --> 00:48:58,640
seeing tcp

00:48:55,680 --> 00:48:58,640
packets in the middle

00:48:59,760 --> 00:49:03,920
and then t-sharp can give you all sorts

00:49:02,400 --> 00:49:06,800
of information

00:49:03,920 --> 00:49:10,400
and then here we have the next frame

00:49:06,800 --> 00:49:12,480
which is another ethernet packet

00:49:10,400 --> 00:49:14,400
with another ip packet in it this one

00:49:12,480 --> 00:49:17,119
from our

00:49:14,400 --> 00:49:17,920
destination node back to the node we

00:49:17,119 --> 00:49:23,520
sent the request

00:49:17,920 --> 00:49:26,640
from inside that's a udp packet

00:49:23,520 --> 00:49:28,800
going to port 8472 note for um vxlan

00:49:26,640 --> 00:49:31,359
it's always the destination port is 8472

00:49:28,800 --> 00:49:34,400
the source port is random

00:49:31,359 --> 00:49:37,839
or at least consistently defined it the

00:49:34,400 --> 00:49:41,040
source port can be anything

00:49:37,839 --> 00:49:43,200
here's our vxlan information that we

00:49:41,040 --> 00:49:45,839
found inside the udp packet

00:49:43,200 --> 00:49:47,520
inside that another ethernet frame

00:49:45,839 --> 00:49:51,359
another ipv4

00:49:47,520 --> 00:49:54,880
ipv4 packet with uh

00:49:51,359 --> 00:49:58,079
the source being the

00:49:54,880 --> 00:49:59,680
pod that was running the http server

00:49:58,079 --> 00:50:02,559
and the destination being where our

00:49:59,680 --> 00:50:02,559
client was running

00:50:02,800 --> 00:50:07,119
inside that's a tcp packet now in this

00:50:04,559 --> 00:50:09,040
case the source ports 8080 because we

00:50:07,119 --> 00:50:12,160
we made a request to 8080 and is sending

00:50:09,040 --> 00:50:13,839
a response back

00:50:12,160 --> 00:50:15,520
and you can see that this one is a

00:50:13,839 --> 00:50:16,160
connection established acknowledge send

00:50:15,520 --> 00:50:17,520
plus ack

00:50:16,160 --> 00:50:18,880
packet so the first one is the syn

00:50:17,520 --> 00:50:20,640
packet establishing the connection this

00:50:18,880 --> 00:50:23,440
one's the syntax packet back

00:50:20,640 --> 00:50:25,440
so you can go through and you can pull

00:50:23,440 --> 00:50:28,720
apart all these layers

00:50:25,440 --> 00:50:31,680
and see the each individual piece of it

00:50:28,720 --> 00:50:32,559
so that if you ever need to debug this

00:50:31,680 --> 00:50:36,000
in many cases

00:50:32,559 --> 00:50:40,319
if you just tell a tool like t-shark to

00:50:36,000 --> 00:50:43,599
interpret the packets it sees on uh

00:50:40,319 --> 00:50:46,960
udp port 8472

00:50:43,599 --> 00:50:47,760
as vxlan then you can at least see

00:50:46,960 --> 00:50:49,760
what's inside

00:50:47,760 --> 00:50:50,880
and that's usually what you care about

00:50:49,760 --> 00:50:52,640
but if you really want to know

00:50:50,880 --> 00:50:54,880
everything that's going on

00:50:52,640 --> 00:50:55,839
you can actually dissect the whole

00:50:54,880 --> 00:50:57,280
packets

00:50:55,839 --> 00:50:59,280
and you can also do this by saving a

00:50:57,280 --> 00:51:00,000
pcap file and loading in wireshark if

00:50:59,280 --> 00:51:02,000
you don't want

00:51:00,000 --> 00:51:03,440
all this information spewing to your

00:51:02,000 --> 00:51:06,000
console

00:51:03,440 --> 00:51:06,960
and you can use that to see everything

00:51:06,000 --> 00:51:09,040
that happened inside

00:51:06,960 --> 00:51:11,280
so you can see the outside packet the

00:51:09,040 --> 00:51:11,839
vxlan information and the inside packet

00:51:11,280 --> 00:51:13,359
and

00:51:11,839 --> 00:51:16,000
you know you can also use this to

00:51:13,359 --> 00:51:19,359
display the payload if you need to

00:51:16,000 --> 00:51:22,800
and that should cover the basics of

00:51:19,359 --> 00:51:26,319
flannel and vxlan

00:51:22,800 --> 00:51:26,720
now onto calico so calico is easily the

00:51:26,319 --> 00:51:29,200
most

00:51:26,720 --> 00:51:30,319
common networking plug-in with tigera

00:51:29,200 --> 00:51:32,240
which is the company

00:51:30,319 --> 00:51:33,359
behind it claiming that you can use to

00:51:32,240 --> 00:51:35,680
some degree

00:51:33,359 --> 00:51:37,200
at least implied for network policies in

00:51:35,680 --> 00:51:39,119
most cloud provider kubernetes

00:51:37,200 --> 00:51:41,280
environments

00:51:39,119 --> 00:51:43,200
runs at layer 3 ipm the networking stack

00:51:41,280 --> 00:51:44,400
so only ip traffic can be encapsulated

00:51:43,200 --> 00:51:46,319
and everything is routed

00:51:44,400 --> 00:51:50,160
there's no way to broadcast ethernet

00:51:46,319 --> 00:51:54,160
packets across your calico

00:51:50,160 --> 00:51:57,760
your calico layer for ipm calico

00:51:54,160 --> 00:52:00,000
actually each node goes and asks either

00:51:57,760 --> 00:52:00,640
the kubernetes api server or its own lcd

00:52:00,000 --> 00:52:03,680
cluster

00:52:00,640 --> 00:52:04,079
for a block of ip addresses that can

00:52:03,680 --> 00:52:06,720
allocate

00:52:04,079 --> 00:52:08,800
out but it can keep going back for more

00:52:06,720 --> 00:52:11,040
blocks of ip addresses as needed

00:52:08,800 --> 00:52:12,240
so it is nice because it lets you

00:52:11,040 --> 00:52:13,920
dynamically

00:52:12,240 --> 00:52:16,720
adjust how many ip addresses are

00:52:13,920 --> 00:52:18,880
allocated to each node

00:52:16,720 --> 00:52:21,119
and then as far as encapsulation the

00:52:18,880 --> 00:52:22,000
default encapsulation for calco is ip

00:52:21,119 --> 00:52:24,240
and ip

00:52:22,000 --> 00:52:25,119
which involves wrapping a layer 3 ip

00:52:24,240 --> 00:52:27,680
packet

00:52:25,119 --> 00:52:30,000
inside an extra ip header so it's very

00:52:27,680 --> 00:52:30,480
low overhead all you need is an extra ip

00:52:30,000 --> 00:52:32,880
header

00:52:30,480 --> 00:52:35,040
not even tcp or udp and definitely not

00:52:32,880 --> 00:52:36,960
an extra ethernet header

00:52:35,040 --> 00:52:38,800
but it can only encapsulate ip packets

00:52:36,960 --> 00:52:40,640
literally the

00:52:38,800 --> 00:52:42,880
the protocol definition says this

00:52:40,640 --> 00:52:45,760
there's an ip header and inside it is

00:52:42,880 --> 00:52:48,480
an ip header which then may have tcp udp

00:52:45,760 --> 00:52:51,440
whatever inside of it

00:52:48,480 --> 00:52:53,200
okay let's take a look let me show you

00:52:51,440 --> 00:52:55,920
how to

00:52:53,200 --> 00:52:57,119
start up the calico cluster so first

00:52:55,920 --> 00:52:58,480
thing

00:52:57,119 --> 00:53:01,839
back in your final cluster you actually

00:52:58,480 --> 00:53:01,839
run a run

00:53:13,040 --> 00:53:19,359
the k8s net labs

00:53:16,720 --> 00:53:22,079
get repo there's a calico folder this

00:53:19,359 --> 00:53:24,640
one has a simple bootstrap calico

00:53:22,079 --> 00:53:25,119
so just like bringing up the footloose

00:53:24,640 --> 00:53:27,920
one

00:53:25,119 --> 00:53:29,119
or the just like bringing up the flannel

00:53:27,920 --> 00:53:31,680
one

00:53:29,119 --> 00:53:32,800
it's does everything for you creates a

00:53:31,680 --> 00:53:35,119
docker network

00:53:32,800 --> 00:53:36,640
it makes sure the image is pulled it

00:53:35,119 --> 00:53:38,720
creates the cluster

00:53:36,640 --> 00:53:40,000
um and it does all the stuff required to

00:53:38,720 --> 00:53:43,599
get k3s

00:53:40,000 --> 00:53:44,000
to properly uh initialize on the master

00:53:43,599 --> 00:53:45,839
and

00:53:44,000 --> 00:53:47,040
have the other nodes connect to that

00:53:45,839 --> 00:53:48,559
master

00:53:47,040 --> 00:53:50,640
this one adds a few different flags so

00:53:48,559 --> 00:53:51,520
if i look at i'll first let's take a

00:53:50,640 --> 00:53:55,760
quick look

00:53:51,520 --> 00:53:57,839
this footloose calico yaml um

00:53:55,760 --> 00:53:58,960
i name the network the cholesterol

00:53:57,839 --> 00:54:03,119
differently

00:53:58,960 --> 00:54:06,160
i put calico in front of the node names

00:54:03,119 --> 00:54:07,839
i use a different docker network just to

00:54:06,160 --> 00:54:10,000
keep everything separate

00:54:07,839 --> 00:54:12,480
but otherwise exactly the same as the

00:54:10,000 --> 00:54:12,480
last one

00:54:12,880 --> 00:54:17,440
the bootstrap script for one thing it

00:54:16,400 --> 00:54:20,800
passes this

00:54:17,440 --> 00:54:21,920
dash c footloose calico.yaml to every

00:54:20,800 --> 00:54:24,800
footloose command

00:54:21,920 --> 00:54:25,680
to tell it which file to use i just

00:54:24,800 --> 00:54:27,280
wanted to keep that

00:54:25,680 --> 00:54:30,000
clear because i originally had these in

00:54:27,280 --> 00:54:31,839
the same directory

00:54:30,000 --> 00:54:33,920
then it does the same thing both did

00:54:31,839 --> 00:54:37,359
before ssh is into the first node

00:54:33,920 --> 00:54:41,200
but it says flannel backend equals none

00:54:37,359 --> 00:54:44,160
and gives it a cluster side or parameter

00:54:41,200 --> 00:54:47,040
that is the only thing you have to do in

00:54:44,160 --> 00:54:49,280
order to tell it to not use flannel

00:54:47,040 --> 00:54:53,280
and the cluster cider is needed for

00:54:49,280 --> 00:54:56,400
calico to understand what should do

00:54:53,280 --> 00:55:00,240
and then we're going to

00:54:56,400 --> 00:55:00,240
ssh into the node

00:55:05,040 --> 00:55:08,079
so same things before footloose except

00:55:07,119 --> 00:55:11,599
i've got a use of

00:55:08,079 --> 00:55:12,160
the footloose calico dot yaml and ssh

00:55:11,599 --> 00:55:14,000
root at

00:55:12,160 --> 00:55:17,599
calico dash node zero because like i

00:55:14,000 --> 00:55:17,599
said i named it differently this time

00:55:18,640 --> 00:55:26,079
so first thing do i have the nodes yes

00:55:22,960 --> 00:55:28,079
and i can even see the rep addresses

00:55:26,079 --> 00:55:35,839
this uses 172.20

00:55:28,079 --> 00:55:35,839
so i've got here okay

00:55:38,079 --> 00:55:40,880
now you can see i've got a bunch of

00:55:38,960 --> 00:55:42,960
stuff that's in container creating and

00:55:40,880 --> 00:55:45,520
it's all on node 0.

00:55:42,960 --> 00:55:47,359
well that's because i haven't actually

00:55:45,520 --> 00:55:50,799
uh set up calico yet

00:55:47,359 --> 00:55:56,319
okay so we'll do coop control

00:55:50,799 --> 00:55:58,559
ply calico k3s.ml

00:55:56,319 --> 00:56:02,720
so this is basically the calico gamble

00:55:58,559 --> 00:56:04,720
that came from calico or from tigera

00:56:02,720 --> 00:56:06,559
it has one little tweak in it because

00:56:04,720 --> 00:56:07,440
you have to turn on ip forwarding in

00:56:06,559 --> 00:56:10,160
your pods

00:56:07,440 --> 00:56:10,559
for some of the stuff in k3 has to work

00:56:10,160 --> 00:56:17,839
so

00:56:10,559 --> 00:56:17,839
the difference between this

00:56:18,799 --> 00:56:22,880
and the default is just container

00:56:20,799 --> 00:56:31,839
settings allow ip forwarding true

00:56:22,880 --> 00:56:31,839
so super simple

00:56:33,119 --> 00:56:36,880
okay and now we actually have some pods

00:56:34,720 --> 00:56:38,640
starting up and in particular you can

00:56:36,880 --> 00:56:41,359
see we've got pod initializing on calico

00:56:38,640 --> 00:56:43,200
node zero one and two

00:56:41,359 --> 00:56:44,480
so we'll have to wait a moment for for

00:56:43,200 --> 00:56:46,240
this doll startup because obviously

00:56:44,480 --> 00:56:48,079
until calico comes up

00:56:46,240 --> 00:56:49,440
we're not going to have a whole lot of

00:56:48,079 --> 00:56:51,760
luck getting the rest of our pods to

00:56:49,440 --> 00:56:51,760
come up

00:56:52,559 --> 00:56:59,839
there we go so now we have

00:56:56,640 --> 00:56:59,839
one calico node running

00:57:00,799 --> 00:57:04,720
and oh and this one running as well and

00:57:03,839 --> 00:57:06,960
this one running

00:57:04,720 --> 00:57:06,960
great

00:57:07,920 --> 00:57:11,520
okay so now we've got all the pods

00:57:09,200 --> 00:57:14,559
coming up

00:57:11,520 --> 00:57:17,119
so this will have given us a calico

00:57:14,559 --> 00:57:17,119
installation

00:57:19,520 --> 00:57:22,960
so let's take a look around and see see

00:57:21,599 --> 00:57:23,920
how this looks one thing that's

00:57:22,960 --> 00:57:26,000
interesting is

00:57:23,920 --> 00:57:28,000
with calico it names its virtual

00:57:26,000 --> 00:57:31,200
ethernet pairs

00:57:28,000 --> 00:57:33,280
starting with cali

00:57:31,200 --> 00:57:34,559
that's just a preference i guess but it

00:57:33,280 --> 00:57:36,640
makes it look a little different but

00:57:34,559 --> 00:57:37,599
these things that i'll start with cali

00:57:36,640 --> 00:57:41,599
those are all the

00:57:37,599 --> 00:57:45,839
ones that were the same as the v-e-t-h

00:57:41,599 --> 00:57:45,839
interfaces that we had in flannel

00:57:50,319 --> 00:57:54,160
now you can see here something's

00:57:51,839 --> 00:57:56,079
interesting if we look at our bridges

00:57:54,160 --> 00:57:58,160
we've got docker zero again which yet

00:57:56,079 --> 00:58:00,000
again isn't doing anything nothing's

00:57:58,160 --> 00:58:02,640
attached to it

00:58:00,000 --> 00:58:04,480
so this is where calico and flannel

00:58:02,640 --> 00:58:06,960
differ

00:58:04,480 --> 00:58:07,680
calico does everything at layer three

00:58:06,960 --> 00:58:11,839
it's ip

00:58:07,680 --> 00:58:15,200
based routing based so because of that

00:58:11,839 --> 00:58:16,799
it doesn't rely on bridges

00:58:15,200 --> 00:58:18,480
whereas before if you look at the route

00:58:16,799 --> 00:58:21,920
table in flannel

00:58:18,480 --> 00:58:23,200
you saw one route towards the bridge for

00:58:21,920 --> 00:58:26,079
all ips that

00:58:23,200 --> 00:58:28,079
are pods that belong to this node and

00:58:26,079 --> 00:58:31,520
then you saw

00:58:28,079 --> 00:58:32,960
other routes for the other nodes

00:58:31,520 --> 00:58:35,040
that said hey send them to the flannel

00:58:32,960 --> 00:58:36,000
interface

00:58:35,040 --> 00:58:38,799
let's take a look and see what the

00:58:36,000 --> 00:58:38,799
routes look like here

00:58:39,839 --> 00:58:44,480
okay so first thing

00:58:47,040 --> 00:58:51,839
i should probably clarify this let me

00:58:50,079 --> 00:58:54,559
grab the pods and grep for

00:58:51,839 --> 00:58:54,559
node zero

00:58:55,920 --> 00:59:00,240
let me know aside from calico which came

00:58:58,400 --> 00:59:04,079
up with its own ip address because

00:59:00,240 --> 00:59:06,319
calico wasn't giving out ips then we

00:59:04,079 --> 00:59:06,319
have

00:59:06,599 --> 00:59:11,839
192.168.43

00:59:07,760 --> 00:59:13,760
addresses so calico

00:59:11,839 --> 00:59:16,480
you tell you give it a block of ip

00:59:13,760 --> 00:59:19,599
addresses that can use

00:59:16,480 --> 00:59:21,280
and then using fcd

00:59:19,599 --> 00:59:22,880
uh and and depending on how your setup

00:59:21,280 --> 00:59:25,839
it can either use the kubernetes cluster

00:59:22,880 --> 00:59:28,640
at cd or can have its own sad

00:59:25,839 --> 00:59:29,760
um it will each node will grab

00:59:28,640 --> 00:59:32,559
reservations

00:59:29,760 --> 00:59:34,960
from that block of ip addresses the

00:59:32,559 --> 00:59:35,839
calico nodes can grab as much ips as

00:59:34,960 --> 00:59:39,200
they need

00:59:35,839 --> 00:59:42,640
and in fact if you look here you'll see

00:59:39,200 --> 00:59:42,640
that we've got a route for

00:59:42,839 --> 00:59:48,000
192.168.63.128

00:59:44,839 --> 00:59:49,599
26. so we're with flannel we gave a

00:59:48,000 --> 00:59:52,240
simple slash 24

00:59:49,599 --> 00:59:53,920
which means the the whole last octet is

00:59:52,240 --> 00:59:55,680
usable by the node

00:59:53,920 --> 00:59:59,119
depending on how you want to count it

00:59:55,680 --> 01:00:04,160
you know 254

00:59:59,119 --> 01:00:07,200
ish usable ips there um

01:00:04,160 --> 01:00:09,280
calico actually grabbed two fewer bits

01:00:07,200 --> 01:00:13,839
of address space

01:00:09,280 --> 01:00:15,200
so this one's only more like 64-ish

01:00:13,839 --> 01:00:17,520
but it can grab as many of those

01:00:15,200 --> 01:00:20,480
reservations as it needs

01:00:17,520 --> 01:00:21,119
and then if you run out of ip blocks big

01:00:20,480 --> 01:00:22,720
enough

01:00:21,119 --> 01:00:26,160
it has a way where it can reserve

01:00:22,720 --> 01:00:30,160
individual ips as needed

01:00:26,160 --> 01:00:35,599
so what happened here is

01:00:30,160 --> 01:00:35,599
node 0 appears to have gotten

01:00:37,240 --> 01:00:41,200
192.168.43.0

01:00:38,559 --> 01:00:41,200
26.

01:00:41,760 --> 01:00:50,480
which makes sense dot 43.1.43.2.43.4

01:00:46,000 --> 01:00:56,400
etc node zero got that block

01:00:50,480 --> 01:01:01,440
and then node one

01:00:56,400 --> 01:01:05,680
got this block dot 63.128 26

01:01:01,440 --> 01:01:10,000
and node 2 got 186.64

01:01:05,680 --> 01:01:12,960
26. so they aren't even

01:01:10,000 --> 01:01:13,359
adjacent so that's one thing each each

01:01:12,960 --> 01:01:14,960
node

01:01:13,359 --> 01:01:16,880
dynamically grabs blocks they can have

01:01:14,960 --> 01:01:18,079
more than one

01:01:16,880 --> 01:01:19,839
so when we look at this routing table

01:01:18,079 --> 01:01:20,799
what else do we see so like for example

01:01:19,839 --> 01:01:23,839
um

01:01:20,799 --> 01:01:25,760
metric server is running here on 168 to

01:01:23,839 --> 01:01:27,839
43.1

01:01:25,760 --> 01:01:29,440
well we have a route here that says to

01:01:27,839 --> 01:01:33,200
go to

01:01:29,440 --> 01:01:35,520
this interface so instead of

01:01:33,200 --> 01:01:36,319
having a route that says oh this is a

01:01:35,520 --> 01:01:37,599
local pod

01:01:36,319 --> 01:01:39,359
go to the bridge and the bridge will

01:01:37,599 --> 01:01:42,079
figure out where to send you

01:01:39,359 --> 01:01:42,799
this one actually has a route for each

01:01:42,079 --> 01:01:46,960
pod

01:01:42,799 --> 01:01:50,480
going directly to that pod's interface

01:01:46,960 --> 01:01:53,599
similarly for things it knows

01:01:50,480 --> 01:01:55,920
are on node node

01:01:53,599 --> 01:01:55,920
one

01:01:57,200 --> 01:02:04,160
spits out to be clear

01:02:00,400 --> 01:02:05,359
calico node one has dot three

01:02:04,160 --> 01:02:07,200
for things that knows that are in node

01:02:05,359 --> 01:02:09,839
one it knows

01:02:07,200 --> 01:02:12,640
what the ip range is or all the ipa

01:02:09,839 --> 01:02:15,520
ranges that node one has reserved

01:02:12,640 --> 01:02:16,559
so it sticks around and that says hey um

01:02:15,520 --> 01:02:20,160
for anything going to

01:02:16,559 --> 01:02:22,799
this pod range we're gonna send it via

01:02:20,160 --> 01:02:22,799
node 1

01:02:23,359 --> 01:02:27,039
dev tunnel 0.

01:02:27,200 --> 01:02:31,920
now if we look up here at our interfaces

01:02:30,559 --> 01:02:33,760
from ip adder

01:02:31,920 --> 01:02:36,079
you can see we have this tunnel zero

01:02:33,760 --> 01:02:39,200
interface

01:02:36,079 --> 01:02:42,640
and it is mentions link slash

01:02:39,200 --> 01:02:45,440
ipip this

01:02:42,640 --> 01:02:46,799
interface will encapsulate the packet in

01:02:45,440 --> 01:02:49,280
ipip

01:02:46,799 --> 01:02:52,799
what does that mean well let's see if we

01:02:49,280 --> 01:02:52,799
can get an example of this

01:02:58,880 --> 01:03:03,280
okay let's see what happens if we do a

01:03:03,440 --> 01:03:06,079
t-shark

01:03:12,799 --> 01:03:19,039
let's see what that does

01:03:17,520 --> 01:03:20,960
let's start up our hello kubernetes

01:03:19,039 --> 01:03:30,799
service again because

01:03:20,960 --> 01:03:45,839
why not

01:03:30,799 --> 01:03:45,839
this is going to be our service ip

01:03:56,799 --> 01:04:01,520
see what that does i forgot to tell what

01:03:59,760 --> 01:04:04,160
the capture on it captured on

01:04:01,520 --> 01:04:04,640
the ip over ip interface which actually

01:04:04,160 --> 01:04:07,680
is

01:04:04,640 --> 01:04:09,039
useful because here you can see it went

01:04:07,680 --> 01:04:10,880
from a pod ip

01:04:09,039 --> 01:04:13,839
to a pod ip because that's what was sent

01:04:10,880 --> 01:04:13,839
to that tunnel interface

01:04:15,039 --> 01:04:20,720
i might get a lot of traffic here so

01:04:18,240 --> 01:04:22,880
i was going to localhost okay there we

01:04:20,720 --> 01:04:22,880
go

01:04:25,520 --> 01:04:31,520
okay so this actually properly decoded

01:04:28,880 --> 01:04:31,520
this packet

01:04:32,160 --> 01:04:41,839
let's see if we can

01:04:44,079 --> 01:04:49,200
it's local local

01:04:49,440 --> 01:04:53,200
so much for random okay

01:04:53,359 --> 01:04:56,960
so you can see that um here i use dash

01:04:56,240 --> 01:04:59,520
capital y

01:04:56,960 --> 01:05:00,960
which instead of using a tcp dump syntax

01:04:59,520 --> 01:05:03,039
which is very low level

01:05:00,960 --> 01:05:04,559
it uses wireshark syntax the reason i

01:05:03,039 --> 01:05:06,480
did that is wireshark understands what

01:05:04,559 --> 01:05:10,880
http is tcp dump

01:05:06,480 --> 01:05:15,039
really doesn't so in this case

01:05:10,880 --> 01:05:15,039
i told look for http and it found this

01:05:15,119 --> 01:05:18,079
now let's see what happens

01:05:18,559 --> 01:05:23,839
if i decode it all the way

01:05:25,680 --> 01:05:29,280
so you see everything including the

01:05:26,799 --> 01:05:29,280
payload

01:05:29,680 --> 01:05:36,319
if i come up here to the top

01:05:32,720 --> 01:05:38,400
okay captures a frame ethernet packet

01:05:36,319 --> 01:05:41,760
ip packet now this ip packet is going

01:05:38,400 --> 01:05:41,760
from host to host

01:05:42,559 --> 01:05:48,400
inside the ipv4 packet

01:05:45,680 --> 01:05:50,079
you have an ipv4 packet in fact if you

01:05:48,400 --> 01:05:52,960
look here at the protocol

01:05:50,079 --> 01:05:53,440
listed in the the outer i p packet it

01:05:52,960 --> 01:05:56,640
says

01:05:53,440 --> 01:05:58,720
it's i p over i p so

01:05:56,640 --> 01:06:00,559
what happens is this gets the whole

01:05:58,720 --> 01:06:02,400
packet the whole ip packet

01:06:00,559 --> 01:06:04,400
that you want to send and just sticks

01:06:02,400 --> 01:06:05,359
another ip header on it but if you look

01:06:04,400 --> 01:06:08,240
inside that ip

01:06:05,359 --> 01:06:10,880
packet you don't see tcp or udp you see

01:06:08,240 --> 01:06:14,319
just another ip packet

01:06:10,880 --> 01:06:17,839
it's a very simplistic way of doing

01:06:14,319 --> 01:06:19,599
encapsulation but you know all your

01:06:17,839 --> 01:06:21,920
network devices are going to be routing

01:06:19,599 --> 01:06:23,599
the ip packet so unless you've got some

01:06:21,920 --> 01:06:25,280
sort of stateful firewall that's looking

01:06:23,599 --> 01:06:27,440
for the type of protocol or

01:06:25,280 --> 01:06:29,280
digging inside the ip packet it's going

01:06:27,440 --> 01:06:32,160
to go it's an ip packet i know how to

01:06:29,280 --> 01:06:34,480
send that to the next hop

01:06:32,160 --> 01:06:36,480
so inside the outer ip packet is the

01:06:34,480 --> 01:06:38,799
inner ip packet this one has the pod ips

01:06:36,480 --> 01:06:38,799
in it

01:06:39,599 --> 01:06:43,280
and then you'll see the protocol inside

01:06:40,799 --> 01:06:45,839
that's tcp because it's

01:06:43,280 --> 01:06:46,960
http runs over tcp so you've got there's

01:06:45,839 --> 01:06:48,640
your tcp packet

01:06:46,960 --> 01:06:50,000
destination port 8080 which is what the

01:06:48,640 --> 01:06:51,280
web server is running on inside these

01:06:50,000 --> 01:06:52,960
pods

01:06:51,280 --> 01:06:55,680
and then you can dig all the way down

01:06:52,960 --> 01:06:58,720
see it does a http get

01:06:55,680 --> 01:07:02,319
on the other side the same thing anytime

01:06:58,720 --> 01:07:04,960
packet with an ip packet going between

01:07:02,319 --> 01:07:04,960
the nodes

01:07:05,359 --> 01:07:08,799
and then inside that is another ip

01:07:07,359 --> 01:07:10,559
packet going between the pods

01:07:08,799 --> 01:07:13,680
protocol and the other one was ipip

01:07:10,559 --> 01:07:16,160
protocol and the inner one is tcp

01:07:13,680 --> 01:07:18,720
and then tcp packet this is the response

01:07:16,160 --> 01:07:19,839
coming back from port 8080 and it has a

01:07:18,720 --> 01:07:22,559
response in it

01:07:19,839 --> 01:07:24,640
there were more packets here because i

01:07:22,559 --> 01:07:25,680
told it to look for http it ignored

01:07:24,640 --> 01:07:28,079
anything it couldn't

01:07:25,680 --> 01:07:31,280
detect the http in so if you look at

01:07:28,079 --> 01:07:31,280
these packets for example

01:07:32,319 --> 01:07:37,760
the tcp flags there's no sin

01:07:36,640 --> 01:07:39,359
because the connection's already

01:07:37,760 --> 01:07:40,640
established the connection got

01:07:39,359 --> 01:07:42,480
established and then it started sending

01:07:40,640 --> 01:07:43,839
enough stuff that t-shirt could say oh

01:07:42,480 --> 01:07:46,640
that's http

01:07:43,839 --> 01:07:46,960
so it ignored the early packets but this

01:07:46,640 --> 01:07:48,880
is

01:07:46,960 --> 01:07:51,119
this way you can see what happens you

01:07:48,880 --> 01:07:52,799
have an outer ip packet with an inner ip

01:07:51,119 --> 01:07:54,000
packet immediately inside of it with

01:07:52,799 --> 01:07:56,480
whatever your actual

01:07:54,000 --> 01:07:57,520
you know payload tcp udp whatever isn't

01:07:56,480 --> 01:07:59,359
inside that

01:07:57,520 --> 01:08:01,039
but you can only encapsulate things that

01:07:59,359 --> 01:08:03,039
go over ip

01:08:01,039 --> 01:08:04,240
because the thing you encapsulate has to

01:08:03,039 --> 01:08:08,240
be an ip packet

01:08:04,240 --> 01:08:12,160
you can't encapsulate um you know

01:08:08,240 --> 01:08:15,200
ipx or apple talk or any of those things

01:08:12,160 --> 01:08:18,000
uh that that didn't use

01:08:15,200 --> 01:08:18,319
uh an ip as an outer you know that don't

01:08:18,000 --> 01:08:20,719
have an

01:08:18,319 --> 01:08:22,000
outer ip layer to them similarly you

01:08:20,719 --> 01:08:23,520
can't do anything that's that's raw

01:08:22,000 --> 01:08:25,440
ethernet packets where you actually have

01:08:23,520 --> 01:08:27,759
to get the ethernet headers to the other

01:08:25,440 --> 01:08:27,759
side

01:08:29,120 --> 01:08:32,400
so the other part that's interesting

01:08:30,400 --> 01:08:36,159
about this is that

01:08:32,400 --> 01:08:37,679
how does calico know

01:08:36,159 --> 01:08:41,839
where to send all the different packets

01:08:37,679 --> 01:08:46,480
like what what pods are on what nodes

01:08:41,839 --> 01:08:46,480
and it actually runs bgp daemon

01:08:46,640 --> 01:08:50,719
so for anyone who doesn't know bgp is a

01:08:49,199 --> 01:08:51,520
routing protocol and it's the most

01:08:50,719 --> 01:08:54,719
common one

01:08:51,520 --> 01:08:56,799
across the internet in terms of

01:08:54,719 --> 01:08:58,880
when different networks need to talk to

01:08:56,799 --> 01:09:00,480
each other bgp is typically what they

01:08:58,880 --> 01:09:02,000
use you might use a different protocol

01:09:00,480 --> 01:09:04,719
within your network

01:09:02,000 --> 01:09:05,440
but if you want to exchange routes of

01:09:04,719 --> 01:09:09,520
comcast

01:09:05,440 --> 01:09:12,400
or at t or whoever you're going to use

01:09:09,520 --> 01:09:15,199
bgp that's the standard protocol for for

01:09:12,400 --> 01:09:15,199
exchanging routes

01:09:18,839 --> 01:09:24,480
so

01:09:21,679 --> 01:09:26,560
you can look here and see bgp using the

01:09:24,480 --> 01:09:30,480
lovely etsy services file runs on

01:09:26,560 --> 01:09:33,520
tcp port 179. so it's tcp

01:09:30,480 --> 01:09:36,719
it's point to point and with calico

01:09:33,520 --> 01:09:36,719
they connect in a full mesh

01:09:37,520 --> 01:09:41,040
so let's see what happens if i let's do

01:09:39,279 --> 01:09:44,880
tcp dump this time

01:09:41,040 --> 01:09:50,560
just for fun let's look at e0

01:09:44,880 --> 01:09:50,560
and let's look for port 179

01:09:52,400 --> 01:09:57,440
calico node 0 on its bgp port

01:09:58,400 --> 01:10:05,280
sent something to node two

01:10:02,719 --> 01:10:06,960
and presumably node two connected to

01:10:05,280 --> 01:10:09,840
node zero that's why it's got an

01:10:06,960 --> 01:10:09,840
arbitrary port here

01:10:10,480 --> 01:10:17,840
let's see

01:10:21,679 --> 01:10:24,800
see what t-sharp finds

01:10:26,320 --> 01:10:29,360
have to give in a moment they they send

01:10:27,760 --> 01:10:32,159
messages occasionally but

01:10:29,360 --> 01:10:34,239
it's not something that happens uh

01:10:32,159 --> 01:10:36,640
non-stop

01:10:34,239 --> 01:10:40,719
if things aren't changing the network

01:10:36,640 --> 01:10:40,719
bgp shouldn't be chatting too much

01:10:41,840 --> 01:10:46,159
now you see there we got a bgp keep a

01:10:43,840 --> 01:10:49,199
live message

01:10:46,159 --> 01:10:50,560
so this is how you can see that um the

01:10:49,199 --> 01:10:54,080
different nodes

01:10:50,560 --> 01:10:55,760
all talk to each other over bgp um

01:10:54,080 --> 01:10:57,840
oh great so there we go that's what we

01:10:55,760 --> 01:10:59,520
needed so you can see we have a keep

01:10:57,840 --> 01:11:02,640
alive message that went between

01:10:59,520 --> 01:11:03,360
dot four and dot two and then the other

01:11:02,640 --> 01:11:05,600
way

01:11:03,360 --> 01:11:07,040
and then between dot three and dot two

01:11:05,600 --> 01:11:09,920
and then the other way

01:11:07,040 --> 01:11:12,960
so this is showing you that node zero is

01:11:09,920 --> 01:11:16,159
talking to both of the other nodes

01:11:12,960 --> 01:11:17,760
if you build a big enough network calico

01:11:16,159 --> 01:11:20,159
is ways you can put in route reflectors

01:11:17,760 --> 01:11:21,199
because one of the problems you run into

01:11:20,159 --> 01:11:23,840
is that

01:11:21,199 --> 01:11:25,600
the number of connections you need is

01:11:23,840 --> 01:11:26,400
roughly on the order of n squared not

01:11:25,600 --> 01:11:28,640
quite but

01:11:26,400 --> 01:11:30,480
this gets a little bit out of control as

01:11:28,640 --> 01:11:32,800
that number gets closer to

01:11:30,480 --> 01:11:34,400
a hundred nodes or more so there are

01:11:32,800 --> 01:11:36,480
ways of creating route reflectors

01:11:34,400 --> 01:11:38,000
which let a subset of nodes talk to one

01:11:36,480 --> 01:11:39,120
route reflector

01:11:38,000 --> 01:11:40,480
but that's something you would you would

01:11:39,120 --> 01:11:41,360
want to do if you were having to scale

01:11:40,480 --> 01:11:43,199
this

01:11:41,360 --> 01:11:45,120
but one of the nice things about bgp is

01:11:43,199 --> 01:11:45,760
it has been tried and true at internet

01:11:45,120 --> 01:11:48,320
scale

01:11:45,760 --> 01:11:49,920
for a very long time and so the

01:11:48,320 --> 01:11:52,880
confidence that this will

01:11:49,920 --> 01:11:55,840
do what's expected is pretty high just

01:11:52,880 --> 01:11:55,840
for fun

01:12:03,679 --> 01:12:09,920
i'm going to delete a pod

01:12:08,480 --> 01:12:12,800
so you can see one's terminating one's

01:12:09,920 --> 01:12:14,320
running okay all done

01:12:12,800 --> 01:12:16,159
so we didn't exchange any bgp

01:12:14,320 --> 01:12:18,159
information then because none of the

01:12:16,159 --> 01:12:23,280
routes actually changed

01:12:18,159 --> 01:12:24,560
remember when we look at the routes

01:12:23,280 --> 01:12:26,000
you know we have routes locally for the

01:12:24,560 --> 01:12:27,440
pods that are running on our local

01:12:26,000 --> 01:12:29,600
machine

01:12:27,440 --> 01:12:30,560
but we only have routes to the subnets

01:12:29,600 --> 01:12:33,360
that these other

01:12:30,560 --> 01:12:33,840
uh these other machines have so the only

01:12:33,360 --> 01:12:36,960
way

01:12:33,840 --> 01:12:50,640
that we could get this to well

01:12:36,960 --> 01:12:54,080
let's see if we can do this

01:12:50,640 --> 01:12:54,080
this may or may not work but hey

01:12:56,320 --> 01:13:00,719
so you can see i'm getting more and more

01:12:57,679 --> 01:13:00,719
of these individual routes

01:13:01,120 --> 01:13:06,480
the other nodes still only have one

01:13:03,520 --> 01:13:06,480
block of ips

01:13:07,120 --> 01:13:10,640
but we don't have that many pods so

01:13:16,840 --> 01:13:19,840
actually

01:13:23,520 --> 01:13:33,040
since we haven't done this okay so

01:13:32,320 --> 01:13:36,880
that's the

01:13:33,040 --> 01:13:39,360
that's the route for node zero right now

01:13:36,880 --> 01:13:39,360
in fact

01:13:43,120 --> 01:13:47,760
you see we still have bgp keep alive

01:13:44,840 --> 01:14:01,840
messages

01:13:47,760 --> 01:14:01,840
okay we have now hit dot 63.

01:14:03,679 --> 01:14:07,360
this is a total of 49 pods running here

01:14:05,760 --> 01:14:08,080
so it probably has a few ips it could

01:14:07,360 --> 01:14:11,040
fill in

01:14:08,080 --> 01:14:15,840
that hasn't used yet like you can see 61

01:14:11,040 --> 01:14:15,840
wasn't used yet

01:14:17,520 --> 01:14:24,239
here we go we have bgp update messages

01:14:20,719 --> 01:14:29,840
route refresh suddenly

01:14:24,239 --> 01:14:29,840
our nodes are trying to

01:14:36,560 --> 01:14:40,840
there we go that's what i was looking

01:14:38,640 --> 01:14:45,199
for so

01:14:40,840 --> 01:14:47,600
172.20 is node 0.

01:14:45,199 --> 01:14:49,120
and it now has too many for type block

01:14:47,600 --> 01:14:50,640
so you can see it now got allocated

01:14:49,120 --> 01:14:56,239
another ip block

01:14:50,640 --> 01:14:59,520
dot 64 which gives another

01:14:56,239 --> 01:15:01,840
60 well depending on how it used it

01:14:59,520 --> 01:15:05,520
could use up to 64

01:15:01,840 --> 01:15:11,040
of those ips but sometimes you don't use

01:15:05,520 --> 01:15:14,000
the first and last so it could be 62.

01:15:11,040 --> 01:15:16,000
so anyway that's what we've got and

01:15:14,000 --> 01:15:18,000
actually

01:15:16,000 --> 01:15:21,840
didn't realize that's also node zero so

01:15:18,000 --> 01:15:24,880
node zero now has three ip blocks

01:15:21,840 --> 01:15:26,560
node two has one ip block and

01:15:24,880 --> 01:15:29,120
i'm on node one so i can't see my own

01:15:26,560 --> 01:15:29,120
routes but

01:15:29,520 --> 01:15:32,480
um looks like

01:15:33,120 --> 01:15:37,440
it's still under control so just for fun

01:15:35,760 --> 01:15:38,400
i'm going to bring that back down so

01:15:37,440 --> 01:15:41,440
that my

01:15:38,400 --> 01:15:41,440
cluster doesn't fall apart

01:15:41,760 --> 01:15:47,120
okay so that's calico uses bgp to

01:15:45,600 --> 01:15:50,560
exchange routes

01:15:47,120 --> 01:15:51,360
each node gets reservations of blocks of

01:15:50,560 --> 01:15:53,920
ips

01:15:51,360 --> 01:15:54,960
from either the kubernetes api servers

01:15:53,920 --> 01:15:58,640
at cd

01:15:54,960 --> 01:16:02,640
or its own fcd and it uses routes

01:15:58,640 --> 01:16:06,000
both to get to local pods and to get to

01:16:02,640 --> 01:16:08,800
other nodes and the standard

01:16:06,000 --> 01:16:10,719
installs encapsulating via ip over ip

01:16:08,800 --> 01:16:11,840
now calico also supports network

01:16:10,719 --> 01:16:14,560
policies

01:16:11,840 --> 01:16:16,320
it also uh supports different

01:16:14,560 --> 01:16:18,000
encapsulation as well

01:16:16,320 --> 01:16:19,600
you know you can actually get flannel to

01:16:18,000 --> 01:16:21,840
run an ip over ip and you can get

01:16:19,600 --> 01:16:24,159
calicodes vxlan

01:16:21,840 --> 01:16:25,600
it's just not their standard standard

01:16:24,159 --> 01:16:28,000
configuration

01:16:25,600 --> 01:16:29,440
and so it made more sense to show you

01:16:28,000 --> 01:16:31,760
the standard configurations of the two

01:16:29,440 --> 01:16:32,880
and get to see both flannel and calico

01:16:31,760 --> 01:16:35,760
in action

01:16:32,880 --> 01:16:37,199
as well as both vxlan and ipo ip in

01:16:35,760 --> 01:16:40,560
action

01:16:37,199 --> 01:16:42,159
okay so that brings us to the end

01:16:40,560 --> 01:16:44,640
this has been a quick tour through

01:16:42,159 --> 01:16:48,159
container networking service routing

01:16:44,640 --> 01:16:51,120
and flannel and calico in particular

01:16:48,159 --> 01:16:51,600
kubernetes networking is a huge topic so

01:16:51,120 --> 01:16:54,239
any

01:16:51,600 --> 01:16:55,760
talk can only cover a small slice

01:16:54,239 --> 01:16:58,880
there's a lot of things i would love to

01:16:55,760 --> 01:16:59,840
go into uh you know for example psyllium

01:16:58,880 --> 01:17:02,000
is fascinating

01:16:59,840 --> 01:17:05,120
um there's a bunch of other i mean the

01:17:02,000 --> 01:17:07,159
list of networking plugins is tremendous

01:17:05,120 --> 01:17:08,560
uh we could have used several other

01:17:07,159 --> 01:17:10,320
encapsulations

01:17:08,560 --> 01:17:11,760
there's all sorts of new technologies

01:17:10,320 --> 01:17:15,520
out there we could have dug

01:17:11,760 --> 01:17:16,880
deep into network policies but

01:17:15,520 --> 01:17:18,239
there's only so much we can do in a

01:17:16,880 --> 01:17:19,280
limited amount of time but hopefully

01:17:18,239 --> 01:17:21,840
this covered

01:17:19,280 --> 01:17:24,159
the tools that would make sense for

01:17:21,840 --> 01:17:26,239
looking into any of these things

01:17:24,159 --> 01:17:27,760
and at least would get you started on

01:17:26,239 --> 01:17:30,719
further exploration if you did want to

01:17:27,760 --> 01:17:33,760
go into these other topics

01:17:30,719 --> 01:17:36,320
this has been pre-recorded so i can't

01:17:33,760 --> 01:17:38,000
sit here and answer questions live but i

01:17:36,320 --> 01:17:38,800
should be available to answer questions

01:17:38,000 --> 01:17:40,800
throughout this

01:17:38,800 --> 01:17:42,840
and if you need to reach me after the

01:17:40,800 --> 01:17:45,840
talk you can email me at jeff

01:17:42,840 --> 01:17:45,840
jeffpool.net

01:17:46,000 --> 01:17:49,760

YouTube URL: https://www.youtube.com/watch?v=InZVNuKY5GY


