Title: Building Docker Images with Cloud Native Buildpacks - Ben Hale, VMware & Terence Lee, Salesforce
Publication date: 2020-08-27
Playlist: KubeCon + CloudNativeCon Europe 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming events: EnvoyCon Virtual on October 15 and KubeCon + CloudNativeCon North America 2020 Virtual from November 17-20. Learn more at https://kubecon.io. The conferences feature presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.  

Building Docker Images with Cloud Native Buildpacks - Ben Hale, VMware & Terence Lee, Salesforce 

In today’s cloud-native world, Docker Images are the lingua franca for platform portability. Unfortunately creating great, secure, and efficient images can be difficult and time consuming. In this talk, you'll learn about Cloud Native Buildpacks, a high-level abstraction for building application images. Buildpacks are a standardized tool for creating images in a secure, reproducible, and efficient manner. As an application developer, you don't need to know the best practices for command ordering to optimize layer reusability. As an operator, you will minimize the security hazards developers my introduce. Come learn how buildpacks meet developers at their source code, automate the delivery of both OS-level and application-level dependency upgrades, and help you efficiently handle day-two operations.

https://sched.co/Zeu7
Captions: 
	00:00:00,000 --> 00:00:04,160
good afternoon everybody and welcome to

00:00:02,159 --> 00:00:06,160
building docker images with cloud native

00:00:04,160 --> 00:00:08,720
build packs my name is ben hale

00:00:06,160 --> 00:00:09,840
uh i lead the java language on all of

00:00:08,720 --> 00:00:12,960
the cloud platforms

00:00:09,840 --> 00:00:16,320
at vmware with me is terence

00:00:12,960 --> 00:00:18,400
hi i'm terence i work at salesforce

00:00:16,320 --> 00:00:22,400
and work on the heroku platform there

00:00:18,400 --> 00:00:22,400
and help co-create the bill packs api

00:00:24,160 --> 00:00:28,080
so we're all here today to learn about

00:00:26,160 --> 00:00:29,279
how cloud-native build packs are going

00:00:28,080 --> 00:00:31,039
to help us

00:00:29,279 --> 00:00:33,520
build images that we can run in

00:00:31,039 --> 00:00:36,239
production but all of this is framed

00:00:33,520 --> 00:00:37,040
in the discussion of what does it mean

00:00:36,239 --> 00:00:40,000
today

00:00:37,040 --> 00:00:42,160
in a modern way to deploy and distribute

00:00:40,000 --> 00:00:44,719
applications into production

00:00:42,160 --> 00:00:46,480
we see over and over again that as the

00:00:44,719 --> 00:00:48,640
languages and frameworks that we

00:00:46,480 --> 00:00:50,879
use proliferate within our development

00:00:48,640 --> 00:00:52,480
teams it's becoming harder and harder to

00:00:50,879 --> 00:00:54,399
treat application artifacts

00:00:52,480 --> 00:00:56,399
as the immutable artifacts that pass to

00:00:54,399 --> 00:00:57,440
our systems gone are the days when we

00:00:56,399 --> 00:00:59,680
can build a jar

00:00:57,440 --> 00:01:00,480
and pass a jar through ci pass it out

00:00:59,680 --> 00:01:02,079
through cd

00:01:00,480 --> 00:01:04,159
pass it to a production team we just

00:01:02,079 --> 00:01:06,000
don't get to do that anymore

00:01:04,159 --> 00:01:07,920
many of the common languages that we see

00:01:06,000 --> 00:01:09,600
people using are actually interpreted

00:01:07,920 --> 00:01:10,720
rather than compiled this means we're

00:01:09,600 --> 00:01:13,360
distributing

00:01:10,720 --> 00:01:14,000
source repositories effectively rather

00:01:13,360 --> 00:01:16,560
than

00:01:14,000 --> 00:01:17,680
actual compiled single file artifacts at

00:01:16,560 --> 00:01:21,119
the end

00:01:17,680 --> 00:01:22,320
we also see a new trend in developers

00:01:21,119 --> 00:01:23,600
wanting to be able to both

00:01:22,320 --> 00:01:24,960
test their applications in the

00:01:23,600 --> 00:01:26,479
environment that they're going to run in

00:01:24,960 --> 00:01:29,040
this is a really good idea

00:01:26,479 --> 00:01:30,720
but also have full control of that

00:01:29,040 --> 00:01:31,520
environment that their applications are

00:01:30,720 --> 00:01:33,600
running in

00:01:31,520 --> 00:01:34,960
rather than relying on another team to

00:01:33,600 --> 00:01:37,920
configure that for them

00:01:34,960 --> 00:01:39,200
we've seen so many times a development

00:01:37,920 --> 00:01:41,520
team

00:01:39,200 --> 00:01:42,799
gets everything working on their local

00:01:41,520 --> 00:01:44,320
development systems

00:01:42,799 --> 00:01:45,840
gets it all working in their qa

00:01:44,320 --> 00:01:47,600
environment throws it over the wall to

00:01:45,840 --> 00:01:48,240
production where something is configured

00:01:47,600 --> 00:01:50,960
differently

00:01:48,240 --> 00:01:54,960
and everything breaks so all of that

00:01:50,960 --> 00:01:57,680
leads us to the following statement

00:01:54,960 --> 00:02:00,880
docker images are the lingua franca for

00:01:57,680 --> 00:02:03,280
platform portability

00:02:00,880 --> 00:02:04,479
what do i mean by this effectively what

00:02:03,280 --> 00:02:07,040
i'm saying is that

00:02:04,479 --> 00:02:08,399
this is the new immutable artifact that

00:02:07,040 --> 00:02:10,319
we want to pass around

00:02:08,399 --> 00:02:11,520
and it's great because it contains

00:02:10,319 --> 00:02:13,599
everything it contains

00:02:11,520 --> 00:02:15,840
the operating system file system it

00:02:13,599 --> 00:02:17,360
contains the application file system it

00:02:15,840 --> 00:02:19,520
contains the command that we're going to

00:02:17,360 --> 00:02:21,599
actually run the application with

00:02:19,520 --> 00:02:24,400
it gives us a nice self-contained

00:02:21,599 --> 00:02:27,040
environment that runs exactly the same

00:02:24,400 --> 00:02:28,480
everywhere that means it's going to run

00:02:27,040 --> 00:02:29,920
the same on your laptop it's going to

00:02:28,480 --> 00:02:31,200
run the same on the data center it's

00:02:29,920 --> 00:02:31,920
going to run in the public cloud it's

00:02:31,200 --> 00:02:33,440
going to run on

00:02:31,920 --> 00:02:35,519
your local docker demon it's going to

00:02:33,440 --> 00:02:39,040
run on kubernetes it's going to run

00:02:35,519 --> 00:02:39,040
everywhere exactly the same

00:02:41,680 --> 00:02:44,879
docker files are probably how most

00:02:44,400 --> 00:02:47,040
people

00:02:44,879 --> 00:02:48,000
create the docker images that ben's

00:02:47,040 --> 00:02:49,519
talking about

00:02:48,000 --> 00:02:51,120
and they're great they're easy to use

00:02:49,519 --> 00:02:51,920
they provide a lot of control to

00:02:51,120 --> 00:02:53,440
developer

00:02:51,920 --> 00:02:55,120
but it's a double-edged sword it

00:02:53,440 --> 00:02:57,040
requires a lot of work to

00:02:55,120 --> 00:02:58,560
harden these docker files for production

00:02:57,040 --> 00:03:01,440
use and you have to

00:02:58,560 --> 00:03:03,840
resort to thing what i like to call

00:03:01,440 --> 00:03:06,640
dockerfile

00:03:03,840 --> 00:03:07,920
as an example this the official alpine

00:03:06,640 --> 00:03:11,120
python docker image

00:03:07,920 --> 00:03:12,720
is 137 lines long and the main run

00:03:11,120 --> 00:03:14,879
command that does the bulk of the work

00:03:12,720 --> 00:03:17,200
is about 80 lines a single run command

00:03:14,879 --> 00:03:19,360
that is 80 lines long to

00:03:17,200 --> 00:03:21,760
configure install and install and set up

00:03:19,360 --> 00:03:21,760
python

00:03:22,879 --> 00:03:29,440
so what if you could actually go and

00:03:26,400 --> 00:03:30,159
create a good docker image without doing

00:03:29,440 --> 00:03:33,280
all that work

00:03:30,159 --> 00:03:34,959
all that dockerfile gymnastics that most

00:03:33,280 --> 00:03:38,560
people are doing today

00:03:34,959 --> 00:03:38,560
so ben's going to go ahead and demo that

00:03:39,599 --> 00:03:43,040
so the question terence has asked is

00:03:41,680 --> 00:03:45,280
what if we could create a good

00:03:43,040 --> 00:03:48,000
docker image but without result

00:03:45,280 --> 00:03:49,519
resorting to docker file gymnastics

00:03:48,000 --> 00:03:52,400
so what we're going to demonstrate here

00:03:49,519 --> 00:03:55,680
today is the pac cli

00:03:52,400 --> 00:03:57,200
the pax cli is a command line uh utility

00:03:55,680 --> 00:03:57,920
created by the cloud native build packs

00:03:57,200 --> 00:04:00,159
project

00:03:57,920 --> 00:04:02,799
that creates an application image in

00:04:00,159 --> 00:04:04,959
this case called applications demo

00:04:02,799 --> 00:04:07,920
from some sort of source in this

00:04:04,959 --> 00:04:08,799
particular case it's the demo01 snapshot

00:04:07,920 --> 00:04:10,879
jar

00:04:08,799 --> 00:04:12,640
using a builder so a bunch of build

00:04:10,879 --> 00:04:14,080
packs in this case called builders adopt

00:04:12,640 --> 00:04:15,599
open jdk

00:04:14,080 --> 00:04:17,280
so we'll go ahead and kick that off we

00:04:15,599 --> 00:04:19,199
see it go to work we say oh there could

00:04:17,280 --> 00:04:20,320
be 16 build packs but five of them are

00:04:19,199 --> 00:04:22,720
going to participate here

00:04:20,320 --> 00:04:28,240
we look at what exactly happens in this

00:04:22,720 --> 00:04:30,880
particular build

00:04:28,240 --> 00:04:32,880
what we see here is that an adopt open

00:04:30,880 --> 00:04:34,720
jdk build pack has contributed a whole

00:04:32,880 --> 00:04:36,880
lot of things but specifically it's

00:04:34,720 --> 00:04:39,199
contributed a jre because this

00:04:36,880 --> 00:04:40,720
is a java application and it's

00:04:39,199 --> 00:04:42,240
contributed some other stuff to make

00:04:40,720 --> 00:04:43,199
running inside of container a little bit

00:04:42,240 --> 00:04:45,919
easier

00:04:43,199 --> 00:04:47,840
an executable jar build pack has figured

00:04:45,919 --> 00:04:49,120
out what the command line for this

00:04:47,840 --> 00:04:50,960
particular application

00:04:49,120 --> 00:04:52,800
could should be it's pretty conventional

00:04:50,960 --> 00:04:53,759
java setting its class path settings

00:04:52,800 --> 00:04:55,840
java ops

00:04:53,759 --> 00:04:57,680
and then calling a particular class

00:04:55,840 --> 00:04:59,680
inside of it and then because we know

00:04:57,680 --> 00:05:01,840
that this application is a spring boot

00:04:59,680 --> 00:05:02,880
application it can come in here and do

00:05:01,840 --> 00:05:05,600
all sorts of things

00:05:02,880 --> 00:05:07,120
such configuration given its web

00:05:05,600 --> 00:05:09,120
application type in this case it's a

00:05:07,120 --> 00:05:11,360
reactive web application contributing

00:05:09,120 --> 00:05:13,120
some things around spring cloud bindings

00:05:11,360 --> 00:05:15,280
slicing up the application into multiple

00:05:13,120 --> 00:05:16,320
slices adding a bunch of image labels to

00:05:15,280 --> 00:05:18,000
the image itself

00:05:16,320 --> 00:05:20,320
and then when it's done it goes off and

00:05:18,000 --> 00:05:20,800
creates a particular image in this case

00:05:20,320 --> 00:05:23,280
it's called

00:05:20,800 --> 00:05:24,080
applications demo tag latest and we can

00:05:23,280 --> 00:05:29,120
see that all

00:05:24,080 --> 00:05:29,120
of that build took only 12 seconds to do

00:05:29,840 --> 00:05:33,840
so that's the demo of cloud and bill

00:05:31,759 --> 00:05:35,759
packs and cloud and build packs are a

00:05:33,840 --> 00:05:37,360
cncf sandbox project

00:05:35,759 --> 00:05:39,680
that's built on top of a technology

00:05:37,360 --> 00:05:42,240
called build packs

00:05:39,680 --> 00:05:43,840
and millpacks have been running in

00:05:42,240 --> 00:05:46,960
productions

00:05:43,840 --> 00:05:48,560
on millions of apps since 2011

00:05:46,960 --> 00:05:50,880
ranging from applications that are

00:05:48,560 --> 00:05:52,880
startups all the way up to enterprises

00:05:50,880 --> 00:05:54,560
and what they do is they provide a

00:05:52,880 --> 00:05:56,960
higher level abstraction

00:05:54,560 --> 00:05:58,479
on top of the standard docker file

00:05:56,960 --> 00:06:00,160
allowing app developers to do what they

00:05:58,479 --> 00:06:01,120
do best which is delivering business

00:06:00,160 --> 00:06:04,000
value

00:06:01,120 --> 00:06:05,440
to their customers and we're able to do

00:06:04,000 --> 00:06:08,960
this with a set of features

00:06:05,440 --> 00:06:10,080
like faster builds by using various

00:06:08,960 --> 00:06:11,919
layers not having to

00:06:10,080 --> 00:06:14,479
kind of rerun instructions that don't

00:06:11,919 --> 00:06:16,400
need to be run um

00:06:14,479 --> 00:06:17,759
being able to reproduce those images in

00:06:16,400 --> 00:06:19,120
a reliable way

00:06:17,759 --> 00:06:20,240
the build packs themselves that are

00:06:19,120 --> 00:06:21,440
being used to actually build these

00:06:20,240 --> 00:06:24,880
images

00:06:21,440 --> 00:06:26,720
can be modular and composable um

00:06:24,880 --> 00:06:28,720
and at the end of the day we're

00:06:26,720 --> 00:06:30,720
producing a docker image

00:06:28,720 --> 00:06:31,759
similar to how dockerfile also produces

00:06:30,720 --> 00:06:35,039
docker images

00:06:31,759 --> 00:06:36,479
and that makes them portable via the oci

00:06:35,039 --> 00:06:38,560
standard that ben was talking about

00:06:36,479 --> 00:06:41,600
before

00:06:38,560 --> 00:06:43,600
so we're going to go and take a deeper

00:06:41,600 --> 00:06:44,639
dive or second look at cloudant build

00:06:43,600 --> 00:06:48,720
packs and kind of look

00:06:44,639 --> 00:06:50,960
into these features in more detail

00:06:48,720 --> 00:06:52,800
so terrance just listed off a whole

00:06:50,960 --> 00:06:56,160
bunch of different things

00:06:52,800 --> 00:06:57,440
that build packs can do that are kind of

00:06:56,160 --> 00:06:59,360
advantages you might say

00:06:57,440 --> 00:07:00,880
over something like a normal doctor file

00:06:59,360 --> 00:07:03,280
so let's take a look at the first one

00:07:00,880 --> 00:07:04,319
what does it mean to reuse layers

00:07:03,280 --> 00:07:06,479
so what we're going to do is we're going

00:07:04,319 --> 00:07:07,759
to rerun the exact same command we ran

00:07:06,479 --> 00:07:09,520
previously

00:07:07,759 --> 00:07:11,120
so we're going to do that build we see

00:07:09,520 --> 00:07:12,240
detection pick the same five build packs

00:07:11,120 --> 00:07:14,880
but this time

00:07:12,240 --> 00:07:17,360
we see something even more interesting

00:07:14,880 --> 00:07:19,440
we see that as we analyze the previously

00:07:17,360 --> 00:07:21,759
existing image it noticed that there was

00:07:19,440 --> 00:07:24,160
a bunch of layers that already existed

00:07:21,759 --> 00:07:26,560
we download the metadata not the data

00:07:24,160 --> 00:07:28,880
from those layers but just the metadata

00:07:26,560 --> 00:07:31,039
which gives us the ability in this case

00:07:28,880 --> 00:07:34,800
the adopt open jdk build pack to say hey

00:07:31,039 --> 00:07:36,240
i've already delivered version 11.0.8 i

00:07:34,800 --> 00:07:38,160
don't need to do it again what i want

00:07:36,240 --> 00:07:40,560
you to do is create an image

00:07:38,160 --> 00:07:41,440
but use the layer that already existed

00:07:40,560 --> 00:07:42,639
in that image

00:07:41,440 --> 00:07:44,639
same thing in the spring boot

00:07:42,639 --> 00:07:45,680
application i already did the work i

00:07:44,639 --> 00:07:47,440
needed to do

00:07:45,680 --> 00:07:49,039
because of the web application type or

00:07:47,440 --> 00:07:51,120
around spring cloud bindings

00:07:49,039 --> 00:07:52,720
so i don't need to do those again i

00:07:51,120 --> 00:07:54,560
don't need to transfer that data

00:07:52,720 --> 00:07:56,080
and what we see now is that that same

00:07:54,560 --> 00:07:57,759
build that took

00:07:56,080 --> 00:07:59,680
more than 10 seconds last time has

00:07:57,759 --> 00:08:01,199
immediately shrunk to six seconds so

00:07:59,680 --> 00:08:05,599
we're probably seeing it being

00:08:01,199 --> 00:08:05,599
twice as fast the second time around

00:08:05,759 --> 00:08:09,680
but that's not the only kind of

00:08:07,599 --> 00:08:10,479
advantage we can get that kind of layer

00:08:09,680 --> 00:08:14,080
reuse

00:08:10,479 --> 00:08:14,319
we can also take a look at what exactly

00:08:14,080 --> 00:08:16,319
is

00:08:14,319 --> 00:08:17,840
going to be used when builds happen so

00:08:16,319 --> 00:08:20,400
if we do a pack

00:08:17,840 --> 00:08:22,560
inspect builder we're going to take a

00:08:20,400 --> 00:08:24,000
look at that adopt open jdk builder that

00:08:22,560 --> 00:08:26,240
we used before

00:08:24,000 --> 00:08:28,800
we said that build packs encourage

00:08:26,240 --> 00:08:29,360
composability and modularity and we see

00:08:28,800 --> 00:08:30,960
that

00:08:29,360 --> 00:08:32,959
in this particular builder we see that

00:08:30,960 --> 00:08:33,440
there are 15 different build packs that

00:08:32,959 --> 00:08:35,839
all

00:08:33,440 --> 00:08:37,279
participate when we build an image the

00:08:35,839 --> 00:08:39,519
first one here this

00:08:37,279 --> 00:08:41,599
is the adopt open jdk build pack you can

00:08:39,519 --> 00:08:42,159
remember we saw the executable jar

00:08:41,599 --> 00:08:45,200
buildback

00:08:42,159 --> 00:08:48,000
participate we saw the uh spring boot

00:08:45,200 --> 00:08:48,640
uh build pack participate as well and

00:08:48,000 --> 00:08:50,560
there are many

00:08:48,640 --> 00:08:52,640
others that chose not to participate but

00:08:50,560 --> 00:08:54,720
could have if we'd given it a different

00:08:52,640 --> 00:08:57,120
set of of input

00:08:54,720 --> 00:08:58,560
so if we see that this is sort of how

00:08:57,120 --> 00:08:59,200
the builder is going to behave what if

00:08:58,560 --> 00:09:02,880
we took

00:08:59,200 --> 00:09:02,880
took a look at a different builder

00:09:04,959 --> 00:09:09,360
let's take a look at a bellsoft liberica

00:09:07,040 --> 00:09:10,160
builder bellsoft liberic is just another

00:09:09,360 --> 00:09:12,880
distribution

00:09:10,160 --> 00:09:13,760
of java like adopt open jdk or oracle or

00:09:12,880 --> 00:09:15,920
sap or

00:09:13,760 --> 00:09:17,680
any of a number of others and what we'll

00:09:15,920 --> 00:09:18,480
see is because of the way the build

00:09:17,680 --> 00:09:20,640
packs are built

00:09:18,480 --> 00:09:23,279
in a modular way and the way we compose

00:09:20,640 --> 00:09:24,880
them most of the build packs 14 of the

00:09:23,279 --> 00:09:27,200
15 build packs that were in there

00:09:24,880 --> 00:09:28,720
are exactly the same as they were before

00:09:27,200 --> 00:09:30,720
but we've been able to replace

00:09:28,720 --> 00:09:31,760
just the java distribution that we want

00:09:30,720 --> 00:09:33,760
to use say we

00:09:31,760 --> 00:09:35,360
support contract with bellsoft we might

00:09:33,760 --> 00:09:36,640
want to use them instead of adopt open

00:09:35,360 --> 00:09:40,959
jdk

00:09:36,640 --> 00:09:40,959
so now if we do that same build

00:09:42,880 --> 00:09:46,959
but with the bell soft builder this this

00:09:44,880 --> 00:09:48,800
whole time or this time we see the same

00:09:46,959 --> 00:09:50,959
five of 16 participating

00:09:48,800 --> 00:09:52,480
and what we see here is that the belt

00:09:50,959 --> 00:09:56,080
soft build pack gets involved

00:09:52,480 --> 00:09:57,680
it contributes its version of 1108

00:09:56,080 --> 00:09:59,440
if there's any changes to the way memory

00:09:57,680 --> 00:09:59,839
calculation is done or certificates are

00:09:59,440 --> 00:10:02,320
loaded

00:09:59,839 --> 00:10:04,320
those all are recontributed as well but

00:10:02,320 --> 00:10:05,920
only this build pack has changed

00:10:04,320 --> 00:10:07,839
if we take a look at the spring boot

00:10:05,920 --> 00:10:09,839
build pack we get to reuse

00:10:07,839 --> 00:10:11,440
those previously cache layers because

00:10:09,839 --> 00:10:14,000
this build pack

00:10:11,440 --> 00:10:16,399
is orthogonal to the java build pack

00:10:14,000 --> 00:10:16,399
itself

00:10:16,480 --> 00:10:20,160
so we see all of these build packs um

00:10:19,120 --> 00:10:22,480
participating

00:10:20,160 --> 00:10:23,440
during a build but what is it exactly

00:10:22,480 --> 00:10:25,440
that they do

00:10:23,440 --> 00:10:27,519
build so we're going to use a utility

00:10:25,440 --> 00:10:28,640
that i absolutely love called dive

00:10:27,519 --> 00:10:33,839
and we're going to take a look at the

00:10:28,640 --> 00:10:33,839
layers inside of an application

00:10:39,519 --> 00:10:43,200
so if we take a look at the first couple

00:10:41,440 --> 00:10:45,279
of layers of this application you'll

00:10:43,200 --> 00:10:46,640
start recognizing that file system on

00:10:45,279 --> 00:10:49,920
the right as the

00:10:46,640 --> 00:10:51,760
kind of thing that typically gets built

00:10:49,920 --> 00:10:54,160
when you're installing a new operating

00:10:51,760 --> 00:10:57,760
system installing a set of packages

00:10:54,160 --> 00:11:00,640
what you're actually seeing here is

00:10:57,760 --> 00:11:02,320
a standard ubuntu bionic installation

00:11:00,640 --> 00:11:03,680
with all of the packages that normally

00:11:02,320 --> 00:11:06,399
come with that

00:11:03,680 --> 00:11:07,200
we then take that stack image which

00:11:06,399 --> 00:11:10,800
basically that

00:11:07,200 --> 00:11:12,320
base os uh and we will instead we'll

00:11:10,800 --> 00:11:13,760
then start putting stuff on it the first

00:11:12,320 --> 00:11:15,600
thing we put on it is the launcher and

00:11:13,760 --> 00:11:16,640
the launcher is a bit of the life cycle

00:11:15,600 --> 00:11:18,480
that we leave

00:11:16,640 --> 00:11:20,079
inside your application that's

00:11:18,480 --> 00:11:21,600
responsible for guaranteeing that the

00:11:20,079 --> 00:11:23,200
environment is set up right

00:11:21,600 --> 00:11:25,120
and that we start your application with

00:11:23,200 --> 00:11:27,760
the proper command line every time you

00:11:25,120 --> 00:11:29,760
try and run with this particular image

00:11:27,760 --> 00:11:30,800
but then we also start seeing the build

00:11:29,760 --> 00:11:32,399
packs themselves

00:11:30,800 --> 00:11:34,560
are contributing things we see the

00:11:32,399 --> 00:11:35,920
bellsoft librarica build packet installs

00:11:34,560 --> 00:11:37,279
this thing called a class counter some

00:11:35,920 --> 00:11:39,920
stuff around java ops

00:11:37,279 --> 00:11:42,800
eventually it installs an entire jre

00:11:39,920 --> 00:11:43,360
inside of this particular image 140 megs

00:11:42,800 --> 00:11:45,279
there

00:11:43,360 --> 00:11:47,120
but we go even further than that we can

00:11:45,279 --> 00:11:48,720
see the executable jar

00:11:47,120 --> 00:11:50,079
does some stuff with the class path

00:11:48,720 --> 00:11:51,839
that's what we see over here on the

00:11:50,079 --> 00:11:52,800
right with this class path environment

00:11:51,839 --> 00:11:55,279
at launch

00:11:52,800 --> 00:11:56,560
we see spring cloud bindings go in we

00:11:55,279 --> 00:11:58,000
see the thing that it's going to make a

00:11:56,560 --> 00:12:00,000
change because this happens to be a

00:11:58,000 --> 00:12:01,279
reactive web application type

00:12:00,000 --> 00:12:03,200
and then eventually we get to the point

00:12:01,279 --> 00:12:05,839
where we see our

00:12:03,200 --> 00:12:06,480
application as well in this particular

00:12:05,839 --> 00:12:08,639
case

00:12:06,480 --> 00:12:10,000
spring boot applications are really well

00:12:08,639 --> 00:12:12,000
known they understand what it means

00:12:10,000 --> 00:12:13,519
to go into an image and so they actually

00:12:12,000 --> 00:12:15,519
can be sliced up

00:12:13,519 --> 00:12:17,040
we effectively have a layer that has all

00:12:15,519 --> 00:12:19,040
of your dependencies on it

00:12:17,040 --> 00:12:20,959
another one that has the boot loader

00:12:19,040 --> 00:12:22,800
application if there were snapshot

00:12:20,959 --> 00:12:26,079
dependencies we put that on a layer

00:12:22,800 --> 00:12:26,959
another layer uh here that is the

00:12:26,079 --> 00:12:28,800
classes

00:12:26,959 --> 00:12:30,240
of your particular application in this

00:12:28,800 --> 00:12:32,079
case the demo application

00:12:30,240 --> 00:12:33,519
all of these end up on separate layers

00:12:32,079 --> 00:12:34,240
and that may seem like a little bit of

00:12:33,519 --> 00:12:36,560
overkill

00:12:34,240 --> 00:12:38,639
but this is really really useful when it

00:12:36,560 --> 00:12:40,480
comes time to transferring data it means

00:12:38,639 --> 00:12:40,800
that the data that changes a lot things

00:12:40,480 --> 00:12:42,880
like

00:12:40,800 --> 00:12:44,079
your application as you are developing

00:12:42,880 --> 00:12:46,880
it can be

00:12:44,079 --> 00:12:48,720
separated much smaller 5.3 kilobytes

00:12:46,880 --> 00:12:51,200
versus 20 megs of dependencies

00:12:48,720 --> 00:12:52,480
and only that 5.3 kilobytes would be

00:12:51,200 --> 00:12:54,959
transferred out to

00:12:52,480 --> 00:12:55,920
edge nodes would be duplicated inside of

00:12:54,959 --> 00:12:57,760
registries

00:12:55,920 --> 00:12:59,600
things that don't change as much things

00:12:57,760 --> 00:13:01,440
like your dependency list which you

00:12:59,600 --> 00:13:02,480
might only change once a quarter or once

00:13:01,440 --> 00:13:04,880
every six months

00:13:02,480 --> 00:13:06,720
basically can be reused and deduped and

00:13:04,880 --> 00:13:08,959
not transferred to edge nodes

00:13:06,720 --> 00:13:09,920
much more easily because you're not sort

00:13:08,959 --> 00:13:12,240
of polluting it

00:13:09,920 --> 00:13:15,200
with this kind of application code that

00:13:12,240 --> 00:13:15,200
changes quite a lot

00:13:16,160 --> 00:13:20,079
so that's what we see in here the build

00:13:17,760 --> 00:13:20,639
packs are all creating these layers that

00:13:20,079 --> 00:13:22,000
contain

00:13:20,639 --> 00:13:23,839
certain bits of the file system all

00:13:22,000 --> 00:13:26,720
those are glued together and a

00:13:23,839 --> 00:13:27,760
normal standard oci image and we say

00:13:26,720 --> 00:13:30,880
that that oci

00:13:27,760 --> 00:13:32,240
image is a portable

00:13:30,880 --> 00:13:35,040
what does that mean it means that i can

00:13:32,240 --> 00:13:37,279
do a docker run tty

00:13:35,040 --> 00:13:39,120
and we can literally use this document

00:13:37,279 --> 00:13:39,680
or this docker image that we created to

00:13:39,120 --> 00:13:41,680
start

00:13:39,680 --> 00:13:44,160
an application and docker here we go a

00:13:41,680 --> 00:13:45,839
running spring boot application

00:13:44,160 --> 00:13:47,519
and while i'm not going to demonstrate

00:13:45,839 --> 00:13:48,320
it completely you'll have to trust me on

00:13:47,519 --> 00:13:51,040
this one

00:13:48,320 --> 00:13:51,040
we also

00:13:52,079 --> 00:13:55,920
can use that exact same image as you see

00:13:54,160 --> 00:13:57,360
right here this is normal kubernetes

00:13:55,920 --> 00:13:58,800
deployment descriptor

00:13:57,360 --> 00:14:01,199
says exactly what my container is going

00:13:58,800 --> 00:14:02,720
to be sets for example the the probe so

00:14:01,199 --> 00:14:04,639
we know when the application is live and

00:14:02,720 --> 00:14:05,040
ready but we're going to use the exact

00:14:04,639 --> 00:14:06,560
same

00:14:05,040 --> 00:14:08,240
image in this particular case going to

00:14:06,560 --> 00:14:10,720
start the exact same

00:14:08,240 --> 00:14:12,639
uh start command it's going to do it

00:14:10,720 --> 00:14:13,040
with the exact same environment variable

00:14:12,639 --> 00:14:15,120
set

00:14:13,040 --> 00:14:17,040
all of that's embedded inside of that

00:14:15,120 --> 00:14:18,800
image it'll run here it'll run on heroku

00:14:17,040 --> 00:14:21,600
it'll run on cloud foundry it'll run on

00:14:18,800 --> 00:14:22,560
any platform exactly the same as long as

00:14:21,600 --> 00:14:25,519
that platform

00:14:22,560 --> 00:14:26,079
understands docker images that's really

00:14:25,519 --> 00:14:30,880
really

00:14:26,079 --> 00:14:33,360
uh awesome

00:14:30,880 --> 00:14:35,040
so all this is great for your you know

00:14:33,360 --> 00:14:36,959
app as an application developer

00:14:35,040 --> 00:14:38,160
you're you know building these images

00:14:36,959 --> 00:14:39,920
but what do you have to what happens

00:14:38,160 --> 00:14:42,160
when you actually have to run these

00:14:39,920 --> 00:14:43,519
uh images in production what do cloud

00:14:42,160 --> 00:14:46,320
name bill packs get you

00:14:43,519 --> 00:14:48,000
um and one of the nice things is that

00:14:46,320 --> 00:14:48,480
with planet build packs and the way we

00:14:48,000 --> 00:14:50,480
build

00:14:48,480 --> 00:14:52,480
uh our applications through the layers

00:14:50,480 --> 00:14:54,320
and stuff um

00:14:52,480 --> 00:14:56,000
that you saw get contributed in a very

00:14:54,320 --> 00:14:57,279
specific way is that

00:14:56,000 --> 00:14:59,120
how we build them is actually

00:14:57,279 --> 00:15:00,240
standardized and that provides a lot of

00:14:59,120 --> 00:15:02,480
benefits to

00:15:00,240 --> 00:15:03,680
operators who need to actually deal with

00:15:02,480 --> 00:15:05,519
stuff like compliance

00:15:03,680 --> 00:15:07,199
and security of your application image

00:15:05,519 --> 00:15:10,399
once it's running in production

00:15:07,199 --> 00:15:12,320
um and that allows us to help with uh

00:15:10,399 --> 00:15:13,680
kind of like two main features that we

00:15:12,320 --> 00:15:14,800
provide as part of the climate build

00:15:13,680 --> 00:15:17,040
packs ecosystem

00:15:14,800 --> 00:15:17,920
uh one of them is build materials which

00:15:17,040 --> 00:15:19,839
shows

00:15:17,920 --> 00:15:21,279
uh what is actually in your image and so

00:15:19,839 --> 00:15:23,199
this can help with auditing

00:15:21,279 --> 00:15:24,720
or kind of your client story there

00:15:23,199 --> 00:15:26,079
because you can without having to crack

00:15:24,720 --> 00:15:28,079
open your docker image you can actually

00:15:26,079 --> 00:15:29,920
see what's in that particular image

00:15:28,079 --> 00:15:31,600
um as well as a feature that we like to

00:15:29,920 --> 00:15:33,360
call git rebase um so

00:15:31,600 --> 00:15:35,040
think along the lines of like what you

00:15:33,360 --> 00:15:38,839
do when you have a git rebase

00:15:35,040 --> 00:15:41,759
and so the osa image manifests back

00:15:38,839 --> 00:15:42,320
uh has ordered pointers for various

00:15:41,759 --> 00:15:43,759
layers

00:15:42,320 --> 00:15:46,079
and this is different from kind of the

00:15:43,759 --> 00:15:46,720
older docker image v1 spec which uh

00:15:46,079 --> 00:15:48,720
treated

00:15:46,720 --> 00:15:50,560
them as kind of this tree-like structure

00:15:48,720 --> 00:15:52,160
which meant that uh if you're changing

00:15:50,560 --> 00:15:52,880
that like kind of from line when you're

00:15:52,160 --> 00:15:54,480
gonna do

00:15:52,880 --> 00:15:56,320
an operating system managed update you

00:15:54,480 --> 00:15:57,440
actually have to rebuild the entire tree

00:15:56,320 --> 00:15:59,360
because like your

00:15:57,440 --> 00:16:00,720
parent route tree is now different so

00:15:59,360 --> 00:16:01,199
you can't like make any assumptions

00:16:00,720 --> 00:16:02,399
about

00:16:01,199 --> 00:16:05,920
kind of the child properties they're all

00:16:02,399 --> 00:16:08,800
all invited and validated

00:16:05,920 --> 00:16:09,199
but one nice things with this new oca

00:16:08,800 --> 00:16:11,120
image

00:16:09,199 --> 00:16:12,320
manifest is that they're pointers and so

00:16:11,120 --> 00:16:15,279
that means that

00:16:12,320 --> 00:16:17,360
if you have stack images built on top of

00:16:15,279 --> 00:16:20,720
um

00:16:17,360 --> 00:16:22,160
operating systems that comply to this

00:16:20,720 --> 00:16:24,160
application binary interface

00:16:22,160 --> 00:16:24,639
compatibility so basically when you

00:16:24,160 --> 00:16:26,160
update

00:16:24,639 --> 00:16:28,160
uh your operating system from one

00:16:26,160 --> 00:16:29,519
version to the next if the avi interface

00:16:28,160 --> 00:16:31,839
hasn't changed you don't actually have

00:16:29,519 --> 00:16:34,320
to rebuild all those layers um

00:16:31,839 --> 00:16:34,880
on top of kind of your stack image

00:16:34,320 --> 00:16:38,079
because

00:16:34,880 --> 00:16:39,759
they complied the same avi um interface

00:16:38,079 --> 00:16:42,079
and so what this looks like in practice

00:16:39,759 --> 00:16:43,680
uh if we take a sample node

00:16:42,079 --> 00:16:46,079
buildpack that's building a node

00:16:43,680 --> 00:16:48,399
application or at the node.js layers

00:16:46,079 --> 00:16:49,440
complied this avi compatibility against

00:16:48,399 --> 00:16:50,959
this operating system

00:16:49,440 --> 00:16:52,320
and it once we need to update this

00:16:50,959 --> 00:16:54,079
operating system it's going to have an

00:16:52,320 --> 00:16:55,759
api compatible operating system

00:16:54,079 --> 00:16:57,519
update and that means we can actually do

00:16:55,759 --> 00:16:58,639
a lift and shift and just rewrite the

00:16:57,519 --> 00:17:01,279
manifest layer

00:16:58,639 --> 00:17:02,800
which is this json text file with

00:17:01,279 --> 00:17:04,880
pointing to the new layers

00:17:02,800 --> 00:17:06,559
which massively speeds up the image

00:17:04,880 --> 00:17:08,000
update as well as the push to

00:17:06,559 --> 00:17:10,000
the registry when we actually have to

00:17:08,000 --> 00:17:11,679
push these layers up um and this

00:17:10,000 --> 00:17:13,919
scales really well when you do this

00:17:11,679 --> 00:17:16,959
across an enterprise fleet of you know

00:17:13,919 --> 00:17:19,039
thousands or tens of thousands of images

00:17:16,959 --> 00:17:20,720
so ben's gonna go ahead and show uh what

00:17:19,039 --> 00:17:23,919
kind of these day two operations look

00:17:20,720 --> 00:17:23,919
like uh while using cloudmate

00:17:25,520 --> 00:17:29,679
so this next demo here is gonna focus

00:17:27,839 --> 00:17:31,200
less on application developers although

00:17:29,679 --> 00:17:32,880
this information that we're gonna see

00:17:31,200 --> 00:17:34,400
is pretty interesting and it's going to

00:17:32,880 --> 00:17:37,600
focus more on what

00:17:34,400 --> 00:17:39,600
your applications can do to help the

00:17:37,600 --> 00:17:41,360
operations teams that are around you

00:17:39,600 --> 00:17:43,919
so one of the really really interesting

00:17:41,360 --> 00:17:44,799
questions that a lot of security teams

00:17:43,919 --> 00:17:47,679
and

00:17:44,799 --> 00:17:48,960
compliance teams really care about our

00:17:47,679 --> 00:17:50,799
what sort of inputs

00:17:48,960 --> 00:17:52,400
went into the creation of this image

00:17:50,799 --> 00:17:55,039
that i am currently running

00:17:52,400 --> 00:17:56,799
right now as an application and so one

00:17:55,039 --> 00:18:00,160
of the tools inside of pac

00:17:56,799 --> 00:18:02,799
is what we call pack inspect image

00:18:00,160 --> 00:18:04,000
so inspect image allows us to take a

00:18:02,799 --> 00:18:07,120
look at some information

00:18:04,000 --> 00:18:08,960
about the the image itself so

00:18:07,120 --> 00:18:11,120
give it a second it comes in and tells

00:18:08,960 --> 00:18:13,039
us of all of those 15 build packs here

00:18:11,120 --> 00:18:14,799
were the five that were going to do

00:18:13,039 --> 00:18:16,640
their thing right we saw bellsoft

00:18:14,799 --> 00:18:17,919
liberica executable jar all of these

00:18:16,640 --> 00:18:19,840
things participated

00:18:17,919 --> 00:18:21,600
and we can even see which versions they

00:18:19,840 --> 00:18:23,520
were and we can see the command

00:18:21,600 --> 00:18:25,600
that was going to get run this is all

00:18:23,520 --> 00:18:27,039
embedded in metadata on the image

00:18:25,600 --> 00:18:28,720
one of the key things about this

00:18:27,039 --> 00:18:31,520
information is we get this

00:18:28,720 --> 00:18:33,360
not by downloading the entire image all

00:18:31,520 --> 00:18:35,760
you know 100 megs or whatever it is

00:18:33,360 --> 00:18:37,360
we download a very small amount of data

00:18:35,760 --> 00:18:39,600
a couple of tens of k

00:18:37,360 --> 00:18:40,720
effectively that contain all of this it

00:18:39,600 --> 00:18:44,480
allows our

00:18:40,720 --> 00:18:46,480
um compliance teams to iterate over

00:18:44,480 --> 00:18:49,600
large numbers of images currently

00:18:46,480 --> 00:18:50,400
in production and ensure that they are

00:18:49,600 --> 00:18:52,000
what they think they

00:18:50,400 --> 00:18:53,760
are find out if there are any existing

00:18:52,000 --> 00:18:55,919
vulnerabilities

00:18:53,760 --> 00:18:57,840
so this is the kind of information about

00:18:55,919 --> 00:18:58,799
what exactly was run to build this

00:18:57,840 --> 00:19:01,520
particular image

00:18:58,799 --> 00:19:02,160
but we can go further than that as well

00:19:01,520 --> 00:19:04,720
you can say

00:19:02,160 --> 00:19:06,080
pack inspect images and we can take a

00:19:04,720 --> 00:19:07,039
look at something called the bill of

00:19:06,080 --> 00:19:09,360
materials

00:19:07,039 --> 00:19:10,720
so whenever an image is created by

00:19:09,360 --> 00:19:13,440
specification

00:19:10,720 --> 00:19:15,039
the uh the build packs can contribute

00:19:13,440 --> 00:19:15,360
and say hey here are some things that we

00:19:15,039 --> 00:19:17,840
put

00:19:15,360 --> 00:19:20,000
into this particular image so for

00:19:17,840 --> 00:19:22,840
example we can take a look and see that

00:19:20,000 --> 00:19:24,080
we put in bellsoft liberica version

00:19:22,840 --> 00:19:25,520
11.08

00:19:24,080 --> 00:19:27,200
here's where we would have downloaded it

00:19:25,520 --> 00:19:28,720
from if we needed to download it if you

00:19:27,200 --> 00:19:31,440
want to validate it here's the

00:19:28,720 --> 00:19:33,120
java256 hash of that we can even tell

00:19:31,440 --> 00:19:34,480
you what the license was for this

00:19:33,120 --> 00:19:36,240
dependency that we've put into your

00:19:34,480 --> 00:19:38,000
image if you want to do sort of license

00:19:36,240 --> 00:19:40,240
compliance kind of testing

00:19:38,000 --> 00:19:42,720
and we do that for absolutely everything

00:19:40,240 --> 00:19:44,799
that we put into the build pack itself

00:19:42,720 --> 00:19:46,559
our memory calculator the class counter

00:19:44,799 --> 00:19:47,600
things about how we configure link local

00:19:46,559 --> 00:19:49,760
dns

00:19:47,600 --> 00:19:50,640
uh all sorts of things that come from

00:19:49,760 --> 00:19:52,640
the build packs

00:19:50,640 --> 00:19:54,559
but even beyond things that come from

00:19:52,640 --> 00:19:56,640
the build pack so for example

00:19:54,559 --> 00:19:58,559
here are a set of dependencies that your

00:19:56,640 --> 00:20:00,799
application contains so if you're

00:19:58,559 --> 00:20:02,559
running a normal spring boot application

00:20:00,799 --> 00:20:04,159
probably you're writing a rest api that

00:20:02,559 --> 00:20:05,679
returns json payloads

00:20:04,159 --> 00:20:07,520
well guess what you're probably going to

00:20:05,679 --> 00:20:09,360
use jackson so which

00:20:07,520 --> 00:20:10,960
version of jackson is in your

00:20:09,360 --> 00:20:13,520
application well you could

00:20:10,960 --> 00:20:15,520
download the image boot it up take a

00:20:13,520 --> 00:20:17,280
look inside you know use a fine command

00:20:15,520 --> 00:20:18,799
and like go and be a shell but that's

00:20:17,280 --> 00:20:20,559
actually really expensive

00:20:18,799 --> 00:20:22,159
time and transfer wise right you've got

00:20:20,559 --> 00:20:24,080
to move a lot of bytes to do that

00:20:22,159 --> 00:20:25,280
or you can take a look at this metadata

00:20:24,080 --> 00:20:26,799
and the bill of materials that we've

00:20:25,280 --> 00:20:29,640
attached and we can find out

00:20:26,799 --> 00:20:30,960
that you're using jackson core version

00:20:29,640 --> 00:20:33,760
2.11.0

00:20:30,960 --> 00:20:35,600
again if you aren't trust trustworthy of

00:20:33,760 --> 00:20:37,360
our metadata here is the hash you can go

00:20:35,600 --> 00:20:39,440
and validate that hash is exactly the

00:20:37,360 --> 00:20:41,200
version that we claimed it was

00:20:39,440 --> 00:20:42,799
and it goes beyond that right you're

00:20:41,200 --> 00:20:44,000
you're a spring user right so let's go

00:20:42,799 --> 00:20:44,640
ahead and take a look down here in

00:20:44,000 --> 00:20:47,200
spring

00:20:44,640 --> 00:20:48,080
spring boot version 2.3.0 if you want to

00:20:47,200 --> 00:20:49,600
go a little bit further

00:20:48,080 --> 00:20:51,360
you might take a look for something like

00:20:49,600 --> 00:20:54,000
spring core is really common we're using

00:20:51,360 --> 00:20:56,799
spring core version 5.2.6

00:20:54,000 --> 00:20:57,840
so in addition to the metadata about how

00:20:56,799 --> 00:21:00,320
we built this

00:20:57,840 --> 00:21:02,000
we also have metadata about what exactly

00:21:00,320 --> 00:21:02,480
we put into it when we did the build but

00:21:02,000 --> 00:21:04,400
also

00:21:02,480 --> 00:21:05,679
what we were presented with what our

00:21:04,400 --> 00:21:07,520
application was

00:21:05,679 --> 00:21:10,080
when it was built we don't have to sort

00:21:07,520 --> 00:21:11,919
of look back and try and uh

00:21:10,080 --> 00:21:13,600
corroborate this with a give and commit

00:21:11,919 --> 00:21:15,600
and figure out what the answer is

00:21:13,600 --> 00:21:17,120
we look this up during the build and we

00:21:15,600 --> 00:21:18,720
put it on as metadata that can be

00:21:17,120 --> 00:21:21,520
inspected in a very light

00:21:18,720 --> 00:21:21,520
and quick way

00:21:22,880 --> 00:21:27,919
the final thing that we uh we talked

00:21:26,080 --> 00:21:30,559
about as an operator

00:21:27,919 --> 00:21:32,080
feature is something called rebasing and

00:21:30,559 --> 00:21:36,240
so rebasing as we said

00:21:32,080 --> 00:21:38,159
is the act of taking a um a

00:21:36,240 --> 00:21:39,440
a bunch of layers that comprise things

00:21:38,159 --> 00:21:40,960
that are contributed by the build pack

00:21:39,440 --> 00:21:43,360
as well as your application

00:21:40,960 --> 00:21:44,080
that sit on top of an operating system

00:21:43,360 --> 00:21:46,320
and move

00:21:44,080 --> 00:21:49,440
all of those to a different version of

00:21:46,320 --> 00:21:50,880
the same abi compatible operating system

00:21:49,440 --> 00:21:52,159
so in this case i'm going to put the

00:21:50,880 --> 00:21:53,760
time command on the front of it so we

00:21:52,159 --> 00:21:54,400
can find out exactly how long something

00:21:53,760 --> 00:21:56,480
like this

00:21:54,400 --> 00:21:58,000
takes but we're going to do a time pack

00:21:56,480 --> 00:21:59,840
rebase we're rebasing that

00:21:58,000 --> 00:22:01,280
applications demo we're going to change

00:21:59,840 --> 00:22:03,520
what the run image is

00:22:01,280 --> 00:22:05,280
underneath it in this particular case

00:22:03,520 --> 00:22:06,320
we're going to a different version this

00:22:05,280 --> 00:22:09,120
version is 0

00:22:06,320 --> 00:22:10,960
0 4 7 which is a slightly newer version

00:22:09,120 --> 00:22:14,559
than the one we've been doing

00:22:10,960 --> 00:22:14,559
the the demo on so far

00:22:18,480 --> 00:22:21,840
so if we take a look at what the time

00:22:20,159 --> 00:22:24,080
says we we managed to

00:22:21,840 --> 00:22:27,280
change the operating system underneath

00:22:24,080 --> 00:22:29,679
this entire application in 1.39

00:22:27,280 --> 00:22:32,000
seconds right if we were working against

00:22:29,679 --> 00:22:33,440
a registry this is a weird oddity of

00:22:32,000 --> 00:22:34,240
using a docker demon it's actually much

00:22:33,440 --> 00:22:36,080
slower to do it

00:22:34,240 --> 00:22:37,360
locally against the docker demon if we

00:22:36,080 --> 00:22:39,440
were doing this against a

00:22:37,360 --> 00:22:41,360
real live docker registry even a docker

00:22:39,440 --> 00:22:43,039
registry over a network link

00:22:41,360 --> 00:22:46,159
we would have expected this to be closer

00:22:43,039 --> 00:22:47,200
to a quarter to a tenth of a second to

00:22:46,159 --> 00:22:48,960
actually get this done because we're

00:22:47,200 --> 00:22:50,400
transferring back and forth very small

00:22:48,960 --> 00:22:52,880
bits of metadata like

00:22:50,400 --> 00:22:54,720
on the order of three or four kilobytes

00:22:52,880 --> 00:22:56,480
of metadata versus

00:22:54,720 --> 00:22:57,919
hundreds of megs of data being

00:22:56,480 --> 00:22:59,679
transferred but most importantly

00:22:57,919 --> 00:23:01,120
we didn't execute any of the rest of the

00:22:59,679 --> 00:23:04,159
build we didn't have to

00:23:01,120 --> 00:23:04,960
uh untar or unjar the the application we

00:23:04,159 --> 00:23:07,440
didn't have to

00:23:04,960 --> 00:23:08,799
untar the jre we didn't have to do any

00:23:07,440 --> 00:23:09,760
install around a file system we

00:23:08,799 --> 00:23:12,960
transferred almost

00:23:09,760 --> 00:23:12,960
no data back and forth

00:23:13,840 --> 00:23:16,880
so that's great we've been doing a ton

00:23:15,200 --> 00:23:19,919
of stuff with this tax eli

00:23:16,880 --> 00:23:20,559
and pac is really just a platform but

00:23:19,919 --> 00:23:23,440
really you know

00:23:20,559 --> 00:23:25,600
built for your local cli um for your

00:23:23,440 --> 00:23:27,200
local development um

00:23:25,600 --> 00:23:29,600
but that's not the only place you can

00:23:27,200 --> 00:23:31,600
run bill packs built packs are out there

00:23:29,600 --> 00:23:32,799
uh in the wild um being used by the

00:23:31,600 --> 00:23:34,960
azure spring cloud

00:23:32,799 --> 00:23:36,240
uh on google app engine it's running on

00:23:34,960 --> 00:23:39,280
roku you know

00:23:36,240 --> 00:23:42,880
vmware and kpac uh even all the way to

00:23:39,280 --> 00:23:44,799
uh java frameworks like spring boot

00:23:42,880 --> 00:23:47,520
that are using it and really targeted

00:23:44,799 --> 00:23:50,559
towards developer productivity

00:23:47,520 --> 00:23:52,240
and so we're going to

00:23:50,559 --> 00:23:54,080
demo and show what it looks like to

00:23:52,240 --> 00:23:54,880
actually if you're a spring boot

00:23:54,080 --> 00:23:57,520
developer

00:23:54,880 --> 00:23:58,880
what it takes to actually just build a

00:23:57,520 --> 00:24:01,279
docker image that is ready for

00:23:58,880 --> 00:24:01,279
production

00:24:02,640 --> 00:24:06,000
so as terrance said spring boot can act

00:24:05,600 --> 00:24:07,919
as

00:24:06,000 --> 00:24:09,919
just another platform the same way that

00:24:07,919 --> 00:24:12,159
we consider the pac cli to be

00:24:09,919 --> 00:24:14,640
one platform the same way we consider

00:24:12,159 --> 00:24:16,480
vmware's kpac to be a platform or heroku

00:24:14,640 --> 00:24:18,480
to be a platform it turns out

00:24:16,480 --> 00:24:20,799
that platforms can come in all shapes

00:24:18,480 --> 00:24:22,320
and sizes one of my favorite platforms

00:24:20,799 --> 00:24:23,120
given my history as a member of the

00:24:22,320 --> 00:24:25,600
spring team

00:24:23,120 --> 00:24:27,200
is actually spring boots maven plug-in

00:24:25,600 --> 00:24:28,480
can be a platform

00:24:27,200 --> 00:24:30,320
so in this particular case we're going

00:24:28,480 --> 00:24:33,440
to go ahead and run a maven command

00:24:30,320 --> 00:24:36,400
maven test skip spring boot build image

00:24:33,440 --> 00:24:38,240
and what this does is it goes off uh to

00:24:36,400 --> 00:24:40,640
maven as you normally expect it to and

00:24:38,240 --> 00:24:42,480
it actually builds this jar file for us

00:24:40,640 --> 00:24:44,240
right the last thing we see is here is

00:24:42,480 --> 00:24:44,880
where it's jarring up the application

00:24:44,240 --> 00:24:46,480
itself

00:24:44,880 --> 00:24:48,559
and then it immediately kicks off a

00:24:46,480 --> 00:24:49,679
build right like internally without you

00:24:48,559 --> 00:24:51,039
ever leaving maven

00:24:49,679 --> 00:24:53,200
uh you could have done the same thing

00:24:51,039 --> 00:24:54,240
with gradle as well we see that exact

00:24:53,200 --> 00:24:56,080
same output

00:24:54,240 --> 00:24:57,919
detecting a bunch of build packs

00:24:56,080 --> 00:25:00,080
contributing the jre to the layer in

00:24:57,919 --> 00:25:00,880
this particular case it's jerry8 because

00:25:00,080 --> 00:25:03,039
that's how we

00:25:00,880 --> 00:25:04,799
we built this particular application we

00:25:03,039 --> 00:25:07,120
have this command that we ran

00:25:04,799 --> 00:25:08,559
all spring boot stuff gets added image

00:25:07,120 --> 00:25:10,640
labels open container

00:25:08,559 --> 00:25:11,919
and we see that it actually created this

00:25:10,640 --> 00:25:14,559
particular image

00:25:11,919 --> 00:25:16,320
one of the really cool things that uh

00:25:14,559 --> 00:25:18,240
building an image this way does because

00:25:16,320 --> 00:25:20,240
it's inside of a running build system

00:25:18,240 --> 00:25:22,159
it can learn things it knows which

00:25:20,240 --> 00:25:24,080
version of java you actually want is

00:25:22,159 --> 00:25:26,000
this a java 8 application is it a java

00:25:24,080 --> 00:25:26,960
11 application is it a java 14

00:25:26,000 --> 00:25:29,440
application

00:25:26,960 --> 00:25:31,120
it knows the name of the application you

00:25:29,440 --> 00:25:32,640
specified what this was as part of

00:25:31,120 --> 00:25:34,559
maven's metadata

00:25:32,640 --> 00:25:36,400
and most importantly it knows what the

00:25:34,559 --> 00:25:36,880
version of this particular application

00:25:36,400 --> 00:25:40,080
is

00:25:36,880 --> 00:25:44,480
so we could run docker run

00:25:40,080 --> 00:25:44,480
tty uh demo

00:25:45,279 --> 00:25:48,640
zero zero one snapshot that's what it's

00:25:47,360 --> 00:25:50,480
called and we see

00:25:48,640 --> 00:25:53,120
this spring boot application that was

00:25:50,480 --> 00:25:53,120
just built

00:25:55,600 --> 00:25:58,960
so in closing uh cloudant build packs

00:25:58,480 --> 00:26:01,440
brings

00:25:58,960 --> 00:26:02,559
a ton of advantages to build packs uh in

00:26:01,440 --> 00:26:04,720
this docker image world

00:26:02,559 --> 00:26:06,000
uh through some of the features that uh

00:26:04,720 --> 00:26:08,240
we've showed

00:26:06,000 --> 00:26:10,640
throughout this talk like faster builds

00:26:08,240 --> 00:26:13,120
um reproducible images

00:26:10,640 --> 00:26:14,000
being able to reuse the various layers

00:26:13,120 --> 00:26:16,000
and what have you

00:26:14,000 --> 00:26:17,200
in addition it provides because of our

00:26:16,000 --> 00:26:18,000
standardization and higher level

00:26:17,200 --> 00:26:20,559
abstraction

00:26:18,000 --> 00:26:21,679
things that docker files simply can't do

00:26:20,559 --> 00:26:22,880
and that's not because

00:26:21,679 --> 00:26:25,120
docker files are efficient it's just

00:26:22,880 --> 00:26:26,559
that our standardization allows us to

00:26:25,120 --> 00:26:28,080
have things like composability that you

00:26:26,559 --> 00:26:28,880
just can't have with all that power and

00:26:28,080 --> 00:26:30,720
flexibility

00:26:28,880 --> 00:26:32,000
uh things like the build materials that

00:26:30,720 --> 00:26:34,559
the bill packs can provide

00:26:32,000 --> 00:26:35,600
as well as uh stuff like movie basing

00:26:34,559 --> 00:26:37,279
saving you a bunch of time when you

00:26:35,600 --> 00:26:38,320
actually need to do image updates across

00:26:37,279 --> 00:26:41,679
your entire fleet

00:26:38,320 --> 00:26:43,760
um and it's common goal packs are

00:26:41,679 --> 00:26:45,520
available through local development

00:26:43,760 --> 00:26:48,159
through tools like pac as well as

00:26:45,520 --> 00:26:49,440
various cloud providers out there and

00:26:48,159 --> 00:26:50,720
one of the big goals that we're trying

00:26:49,440 --> 00:26:52,880
to achieve with this project is new

00:26:50,720 --> 00:26:54,480
developers where they are which is

00:26:52,880 --> 00:26:56,559
right at their application where they're

00:26:54,480 --> 00:26:59,039
focused on delivering value to their

00:26:56,559 --> 00:27:01,760
customers

00:26:59,039 --> 00:27:03,039
so go out and try climbing and build

00:27:01,760 --> 00:27:04,799
packs a day

00:27:03,039 --> 00:27:06,799
we have version point 12 of the taxi

00:27:04,799 --> 00:27:08,640
line just go

00:27:06,799 --> 00:27:10,480
through brew or what have you to go

00:27:08,640 --> 00:27:13,440
install that

00:27:10,480 --> 00:27:15,200
pack cli uh go to our documentation

00:27:13,440 --> 00:27:17,200
we're fairly active on slack

00:27:15,200 --> 00:27:18,640
where a lot of the kind of conversations

00:27:17,200 --> 00:27:21,039
around development outside of

00:27:18,640 --> 00:27:22,320
github r as well as join our mailing

00:27:21,039 --> 00:27:24,720
list where you can get

00:27:22,320 --> 00:27:25,760
the announcements and various things as

00:27:24,720 --> 00:27:30,159
climate build packs

00:27:25,760 --> 00:27:35,679
are being developed thank you and

00:27:30,159 --> 00:27:35,679

YouTube URL: https://www.youtube.com/watch?v=qoM3tLlcdfs


