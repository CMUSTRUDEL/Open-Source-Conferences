Title: CloudEvents - v1.0 and Beyond - Discovery Subscriptions - Doug Davis & Clemens Vasters
Publication date: 2020-08-27
Playlist: KubeCon + CloudNativeCon Europe 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming events: EnvoyCon Virtual on October 15 and KubeCon + CloudNativeCon North America 2020 Virtual from November 17-20. Learn more at https://kubecon.io. The conferences feature presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.  

CloudEvents - v1.0 and Beyond - Discovery/Subscriptions - Doug Davis, IBM & Clemens Vasters, Microsoft 

With the release of CloudEvents v1.0 the project has now expanded its scope to consider other potential pain points for the community. To that end, the group is focusing on Event Discovery and Subscriptions APIs in the hopes of reducing the friction of discovering which events are available from Event Producers as well as how someone can subscribe to those receive those events. In this session we'll quickly summarize, and review, the status of CloudEvents and then jump into the goals, design and status of the new Discovery and Subscription APIs specification being developed.

https://sched.co/ZewO
Captions: 
	00:00:00,080 --> 00:00:03,520
all right welcome everybody uh today

00:00:02,159 --> 00:00:04,640
clemens and i are going to be talking to

00:00:03,520 --> 00:00:06,799
you about cloud events

00:00:04,640 --> 00:00:07,919
in particular the uh the status of the

00:00:06,799 --> 00:00:09,280
cloud events project and where we're

00:00:07,919 --> 00:00:10,480
headed in the future

00:00:09,280 --> 00:00:12,080
um hopefully we'll have time for

00:00:10,480 --> 00:00:13,040
questions at the end so let's go ahead

00:00:12,080 --> 00:00:14,920
and jump right into it because we have a

00:00:13,040 --> 00:00:17,680
lot of material here

00:00:14,920 --> 00:00:19,279
so first of all quick agenda give you a

00:00:17,680 --> 00:00:20,880
quick update on where we are with cloud

00:00:19,279 --> 00:00:22,400
events project and then very quickly

00:00:20,880 --> 00:00:23,760
jump over to some of the new work that

00:00:22,400 --> 00:00:25,920
we're doing here

00:00:23,760 --> 00:00:27,199
so let's start with cloud events itself

00:00:25,920 --> 00:00:29,439
so not going to go into too

00:00:27,199 --> 00:00:30,720
deep detail here but for those of you

00:00:29,439 --> 00:00:32,960
who don't know what cloud events is

00:00:30,720 --> 00:00:34,640
it is a specification for defining

00:00:32,960 --> 00:00:36,800
common metadata

00:00:34,640 --> 00:00:38,160
for events and where that metadata

00:00:36,800 --> 00:00:39,840
appears and the messages that are

00:00:38,160 --> 00:00:41,600
transporting those events

00:00:39,840 --> 00:00:42,879
now it seems very simple they're a very

00:00:41,600 --> 00:00:44,640
high level and it is

00:00:42,879 --> 00:00:46,399
but we're really doing this mainly to

00:00:44,640 --> 00:00:48,559
aid in delivery of events from

00:00:46,399 --> 00:00:50,559
point a to point b this is not about

00:00:48,559 --> 00:00:51,680
defining yet another common event format

00:00:50,559 --> 00:00:52,800
or anything like that i'll show you an

00:00:51,680 --> 00:00:54,320
example in a minute

00:00:52,800 --> 00:00:56,960
this is simply about aiding in the

00:00:54,320 --> 00:00:58,399
delivery of events across middleware to

00:00:56,960 --> 00:01:00,640
its final destination

00:00:58,399 --> 00:01:02,640
and most importantly to enable people to

00:01:00,640 --> 00:01:04,320
do that without having to understand or

00:01:02,640 --> 00:01:06,240
parse the business logic of the event

00:01:04,320 --> 00:01:07,520
itself okay so let's

00:01:06,240 --> 00:01:09,520
jump into a quick example to show you

00:01:07,520 --> 00:01:11,360
what that actually means so let's say

00:01:09,520 --> 00:01:12,799
you have this event flowing over http

00:01:11,360 --> 00:01:14,799
right nothing in here too special looks

00:01:12,799 --> 00:01:16,320
like a normal http event

00:01:14,799 --> 00:01:18,320
in order to turn this into a cloud event

00:01:16,320 --> 00:01:20,400
though you add a couple bit of

00:01:18,320 --> 00:01:21,920
extra metadata as http headers in this

00:01:20,400 --> 00:01:23,360
case and you can see

00:01:21,920 --> 00:01:24,320
just four little bits of metadata and

00:01:23,360 --> 00:01:26,479
these are the only four that are

00:01:24,320 --> 00:01:28,080
required the spec version to see the

00:01:26,479 --> 00:01:29,840
cloud of inspect version that is

00:01:28,080 --> 00:01:32,320
uh the type of the event so this tells

00:01:29,840 --> 00:01:34,799
you for example whether it's a

00:01:32,320 --> 00:01:36,320
crate versus a delete type of event um

00:01:34,799 --> 00:01:37,600
where the event came from

00:01:36,320 --> 00:01:39,280
you know what is the entity that was

00:01:37,600 --> 00:01:40,640
sending out the events and then just

00:01:39,280 --> 00:01:42,880
some unique identifier

00:01:40,640 --> 00:01:44,320
okay now obviously look at that it

00:01:42,880 --> 00:01:46,399
doesn't seem too exciting

00:01:44,320 --> 00:01:48,079
but with that basic information

00:01:46,399 --> 00:01:50,960
middleware can now

00:01:48,079 --> 00:01:52,720
route the message appropriately to make

00:01:50,960 --> 00:01:54,159
its way to its final destination

00:01:52,720 --> 00:01:56,399
much in the same way you can actually

00:01:54,159 --> 00:01:58,799
see the http headers doing that

00:01:56,399 --> 00:02:00,640
for the http layer okay and i said it's

00:01:58,799 --> 00:02:02,640
actually a very very simple concept

00:02:00,640 --> 00:02:04,000
but with that one little extra bit of

00:02:02,640 --> 00:02:06,640
information

00:02:04,000 --> 00:02:07,840
middleware can now be inventing agnostic

00:02:06,640 --> 00:02:09,200
in terms of understanding the business

00:02:07,840 --> 00:02:10,720
logic all they need to do is look for

00:02:09,200 --> 00:02:12,879
these common bits of metadata

00:02:10,720 --> 00:02:14,000
to route the event appropriately okay

00:02:12,879 --> 00:02:15,920
very very simple concept but we're

00:02:14,000 --> 00:02:17,440
hearing lots of kudos from the community

00:02:15,920 --> 00:02:19,120
how this is making life easier because

00:02:17,440 --> 00:02:21,120
they no longer have to have specialized

00:02:19,120 --> 00:02:22,640
middleware for every type of event

00:02:21,120 --> 00:02:24,080
that flows through the system now

00:02:22,640 --> 00:02:25,200
obviously the final destination still

00:02:24,080 --> 00:02:26,959
needs to understand the event and the

00:02:25,200 --> 00:02:29,440
business logic to get its job done

00:02:26,959 --> 00:02:30,800
but in terms of routing this is the type

00:02:29,440 --> 00:02:32,000
of information that should be the bare

00:02:30,800 --> 00:02:33,040
minimum that people need to get their

00:02:32,000 --> 00:02:34,800
job done

00:02:33,040 --> 00:02:36,239
now this example right here is what we

00:02:34,800 --> 00:02:37,840
call the binary format just adds a

00:02:36,239 --> 00:02:39,360
couple http headers so your

00:02:37,840 --> 00:02:41,440
your original message should remain

00:02:39,360 --> 00:02:42,640
basically unchanged however there are

00:02:41,440 --> 00:02:44,239
some people who wanted to

00:02:42,640 --> 00:02:46,239
have everything encapsulated inside the

00:02:44,239 --> 00:02:47,200
body as for those particular cases we

00:02:46,239 --> 00:02:48,879
actually define

00:02:47,200 --> 00:02:50,720
some syntax for example here in this

00:02:48,879 --> 00:02:52,080
json version where we actually put

00:02:50,720 --> 00:02:53,599
everything into the body itself but you

00:02:52,080 --> 00:02:55,519
can see it's the exact same data right

00:02:53,599 --> 00:02:58,000
you got the same four pieces of metadata

00:02:55,519 --> 00:02:58,720
the content type of the data attribute

00:02:58,000 --> 00:03:00,800
when the data

00:02:58,720 --> 00:03:02,239
can hold the business logic right all

00:03:00,800 --> 00:03:03,920
the exact same information

00:03:02,239 --> 00:03:05,440
now the content type of http header

00:03:03,920 --> 00:03:06,959
level obviously tells you that this is

00:03:05,440 --> 00:03:08,879
not just a normal json object

00:03:06,959 --> 00:03:10,239
or json payload but it's a cloud event

00:03:08,879 --> 00:03:11,920
json payload so that's how you can

00:03:10,239 --> 00:03:13,680
distinguish between the left-hand side

00:03:11,920 --> 00:03:14,720
which is just application json which is

00:03:13,680 --> 00:03:16,400
binary

00:03:14,720 --> 00:03:18,080
and the structure side on the right-hand

00:03:16,400 --> 00:03:21,680
side which is application slash json

00:03:18,080 --> 00:03:23,120
or slash cloud events station okay

00:03:21,680 --> 00:03:24,480
so that's it at a very very high level

00:03:23,120 --> 00:03:25,760
very simple thing we're getting lots of

00:03:24,480 --> 00:03:26,959
kudos about it and lots of different

00:03:25,760 --> 00:03:29,680
people are picking it up

00:03:26,959 --> 00:03:30,400
across the industry um in terms of

00:03:29,680 --> 00:03:32,640
deliverables

00:03:30,400 --> 00:03:34,799
this is the big news we did go 1.0

00:03:32,640 --> 00:03:36,080
fairly recently so yay for that

00:03:34,799 --> 00:03:37,519
and in terms of what we're actually

00:03:36,080 --> 00:03:39,440
producing we have different

00:03:37,519 --> 00:03:41,280
specifications not just the spec itself

00:03:39,440 --> 00:03:43,280
in terms of what the metadata is

00:03:41,280 --> 00:03:45,360
but also how it appears in different

00:03:43,280 --> 00:03:46,319
formats right http versus amqp that kind

00:03:45,360 --> 00:03:48,000
of stuff

00:03:46,319 --> 00:03:49,680
different encoding right i showed you

00:03:48,000 --> 00:03:51,760
the json we also avro

00:03:49,680 --> 00:03:53,439
and we also included a primer because

00:03:51,760 --> 00:03:54,159
there are a lot of technical decisions

00:03:53,439 --> 00:03:56,480
we made

00:03:54,159 --> 00:03:57,360
which don't really uh go into a spec

00:03:56,480 --> 00:03:59,200
itself

00:03:57,360 --> 00:04:00,319
but um we wanted people understand why

00:03:59,200 --> 00:04:01,760
we made the decisions we made so we

00:04:00,319 --> 00:04:02,799
created a primer as a background for

00:04:01,760 --> 00:04:04,319
people to understand

00:04:02,799 --> 00:04:06,080
some of the decisions we made and some

00:04:04,319 --> 00:04:07,599
of the design choices now we do have

00:04:06,080 --> 00:04:08,799
some sdks out there with a whole bunch

00:04:07,599 --> 00:04:09,840
of different languages which you can see

00:04:08,799 --> 00:04:12,400
on the screen

00:04:09,840 --> 00:04:12,879
most of them are very very active um in

00:04:12,400 --> 00:04:14,879
particular

00:04:12,879 --> 00:04:16,479
the go 1 and the c sharp and javascript

00:04:14,879 --> 00:04:18,000
and java are very very active so please

00:04:16,479 --> 00:04:19,280
take a look at those and get a chance

00:04:18,000 --> 00:04:20,479
they're not that complicated they're

00:04:19,280 --> 00:04:22,000
just mainly there helping you to

00:04:20,479 --> 00:04:22,720
serialize and deserialize these cloud

00:04:22,000 --> 00:04:24,800
events

00:04:22,720 --> 00:04:26,240
okay so what's next for us obviously

00:04:24,800 --> 00:04:26,560
more customer feedback now that it's out

00:04:26,240 --> 00:04:28,639
there

00:04:26,560 --> 00:04:29,680
people tend to wait until things go 1.0

00:04:28,639 --> 00:04:30,880
before they adopt it

00:04:29,680 --> 00:04:32,720
so we're hoping to get more feedback

00:04:30,880 --> 00:04:35,520
from there and we have been getting

00:04:32,720 --> 00:04:37,120
a lot of kudos so far as i said and

00:04:35,520 --> 00:04:38,320
however beyond that though we're not

00:04:37,120 --> 00:04:39,360
just you know sitting back and waiting

00:04:38,320 --> 00:04:41,360
for that feedback we are

00:04:39,360 --> 00:04:42,639
starting to look at what additional pain

00:04:41,360 --> 00:04:45,520
points the community has

00:04:42,639 --> 00:04:47,360
relative to the eventing space not just

00:04:45,520 --> 00:04:48,880
for functions and servers and stuff like

00:04:47,360 --> 00:04:49,360
that but in general what are the pain

00:04:48,880 --> 00:04:51,600
points

00:04:49,360 --> 00:04:52,960
people are experiencing okay and with

00:04:51,600 --> 00:04:54,000
that let me then turn it over to

00:04:52,960 --> 00:04:55,680
clements just going to talk about some

00:04:54,000 --> 00:04:57,120
of these additional work items are doing

00:04:55,680 --> 00:04:58,880
specifically aimed at addressing some of

00:04:57,120 --> 00:05:01,919
those pain points

00:04:58,880 --> 00:05:04,639
yes and for those we have two

00:05:01,919 --> 00:05:06,000
areas discovery in the subscription apis

00:05:04,639 --> 00:05:07,440
and the schema registry which i'm going

00:05:06,000 --> 00:05:11,600
to discuss

00:05:07,440 --> 00:05:12,000
both and um what's important to note is

00:05:11,600 --> 00:05:14,400
that

00:05:12,000 --> 00:05:16,720
we in cloud events we talk in the cloud

00:05:14,400 --> 00:05:18,400
event core specification where we

00:05:16,720 --> 00:05:20,160
um or set of specifications where we

00:05:18,400 --> 00:05:22,800
have transport bindings

00:05:20,160 --> 00:05:23,680
um and encodings we're really mostly

00:05:22,800 --> 00:05:26,400
focusing on

00:05:23,680 --> 00:05:28,400
on delivery of cloud events but that's

00:05:26,400 --> 00:05:29,919
just the end of the story because before

00:05:28,400 --> 00:05:31,360
you can deliver a cloud event you

00:05:29,919 --> 00:05:34,880
obviously have to

00:05:31,360 --> 00:05:36,639
um indicate um your interest in that

00:05:34,880 --> 00:05:38,320
cloud event and then you also have to

00:05:36,639 --> 00:05:39,680
find who's actually publishing that

00:05:38,320 --> 00:05:41,680
cloud event and that's

00:05:39,680 --> 00:05:43,280
the thing that we're tackling in this

00:05:41,680 --> 00:05:44,960
next round of specifications that we're

00:05:43,280 --> 00:05:48,240
working on

00:05:44,960 --> 00:05:50,800
so the first element is how to

00:05:48,240 --> 00:05:51,759
discover which cloud events are

00:05:50,800 --> 00:05:55,120
available

00:05:51,759 --> 00:05:57,919
for subscription today what you do

00:05:55,120 --> 00:05:58,800
is you read read documentation um

00:05:57,919 --> 00:06:00,160
typically

00:05:58,800 --> 00:06:02,000
so you go on on the website

00:06:00,160 --> 00:06:03,039
documentation website and you find a

00:06:02,000 --> 00:06:05,360
list of

00:06:03,039 --> 00:06:07,600
events that's being raised and for that

00:06:05,360 --> 00:06:08,070
to be automatable we need to have a way

00:06:07,600 --> 00:06:09,680
to

00:06:08,070 --> 00:06:13,360
[Music]

00:06:09,680 --> 00:06:15,759
learn about services um be able to

00:06:13,360 --> 00:06:16,960
filter those services based on some

00:06:15,759 --> 00:06:20,240
criteria

00:06:16,960 --> 00:06:23,120
and then learn about which

00:06:20,240 --> 00:06:24,240
services exposed with which events or

00:06:23,120 --> 00:06:27,680
reversely

00:06:24,240 --> 00:06:28,479
um allow a knowing about some events

00:06:27,680 --> 00:06:30,880
that you can handle

00:06:28,479 --> 00:06:31,919
and then learning which services in your

00:06:30,880 --> 00:06:34,479
vicinity

00:06:31,919 --> 00:06:36,560
um or you know some other criteria um

00:06:34,479 --> 00:06:38,880
are supporting those events

00:06:36,560 --> 00:06:40,160
so question is questions that we have is

00:06:38,880 --> 00:06:42,560
who produces events

00:06:40,160 --> 00:06:44,400
which represent events are produced uh

00:06:42,560 --> 00:06:45,120
which subscription options are available

00:06:44,400 --> 00:06:47,680
how do i

00:06:45,120 --> 00:06:48,319
get the events delivered to to me and

00:06:47,680 --> 00:06:52,319
then

00:06:48,319 --> 00:06:55,360
where and how do i subscribe

00:06:52,319 --> 00:06:58,080
next um so

00:06:55,360 --> 00:06:59,680
what we've done here is we're not very

00:06:58,080 --> 00:07:01,840
prescriptive and that's a

00:06:59,680 --> 00:07:02,720
theme in cloud events overall as a

00:07:01,840 --> 00:07:05,199
principle

00:07:02,720 --> 00:07:06,880
that we're not prescriptive about how

00:07:05,199 --> 00:07:07,440
you really how you should implement your

00:07:06,880 --> 00:07:10,000
service

00:07:07,440 --> 00:07:11,360
and there's no there may be some

00:07:10,000 --> 00:07:12,960
reference implementations of these

00:07:11,360 --> 00:07:15,039
things down the road but ultimately what

00:07:12,960 --> 00:07:19,120
we're defining here are interfaces

00:07:15,039 --> 00:07:22,240
so we are defining this abstractly a

00:07:19,120 --> 00:07:24,560
data model that defines um for instance

00:07:22,240 --> 00:07:27,440
here in this in this way what a

00:07:24,560 --> 00:07:28,400
service is for discovery and also

00:07:27,440 --> 00:07:30,240
defines

00:07:28,400 --> 00:07:31,759
and that's of obviously leaning on the

00:07:30,240 --> 00:07:34,400
core specification that we have

00:07:31,759 --> 00:07:35,919
cloud events and that defines what a

00:07:34,400 --> 00:07:38,960
type is

00:07:35,919 --> 00:07:42,160
and then in based on this

00:07:38,960 --> 00:07:45,199
we then define a http

00:07:42,160 --> 00:07:46,160
and a grpc api that we have today in the

00:07:45,199 --> 00:07:49,360
drafts

00:07:46,160 --> 00:07:51,280
and we might have further protocols such

00:07:49,360 --> 00:07:54,000
as amqp

00:07:51,280 --> 00:07:54,319
later so we define an interface and when

00:07:54,000 --> 00:07:57,039
you

00:07:54,319 --> 00:07:57,759
implement that interface then you have a

00:07:57,039 --> 00:08:01,280
discovery

00:07:57,759 --> 00:08:02,960
service the the notion of service that's

00:08:01,280 --> 00:08:04,319
the concept inside of the discovery

00:08:02,960 --> 00:08:06,080
service

00:08:04,319 --> 00:08:07,599
is very simple it's just some software

00:08:06,080 --> 00:08:09,759
entity that emits events

00:08:07,599 --> 00:08:11,440
so that gets registered in the discovery

00:08:09,759 --> 00:08:14,639
service

00:08:11,440 --> 00:08:16,240
that service since it emits events uh

00:08:14,639 --> 00:08:17,840
maintains a subscription endpoint and

00:08:16,240 --> 00:08:18,479
really what the service description here

00:08:17,840 --> 00:08:20,960
does

00:08:18,479 --> 00:08:23,039
it just enumerates the types of events

00:08:20,960 --> 00:08:26,000
um that are available for subscription

00:08:23,039 --> 00:08:26,479
with um some further information and

00:08:26,000 --> 00:08:28,000
then

00:08:26,479 --> 00:08:30,080
we have a type collection type

00:08:28,000 --> 00:08:30,800
collections really for the reverse

00:08:30,080 --> 00:08:33,839
lookup

00:08:30,800 --> 00:08:36,000
of which services um are available and

00:08:33,839 --> 00:08:38,000
um this is an interface that can be

00:08:36,000 --> 00:08:40,320
implemented in one place or can be

00:08:38,000 --> 00:08:42,159
implemented in multiple places

00:08:40,320 --> 00:08:44,080
and it's obviously also allowed to

00:08:42,159 --> 00:08:45,760
federate those discovery services so you

00:08:44,080 --> 00:08:48,640
can really create a

00:08:45,760 --> 00:08:49,279
um a catalog of services and you can

00:08:48,640 --> 00:08:51,120
make those

00:08:49,279 --> 00:08:52,880
that catalog available everywhere with

00:08:51,120 --> 00:08:56,720
the same interface you can imagine

00:08:52,880 --> 00:08:59,519
having a local cache that exists

00:08:56,720 --> 00:09:01,360
somewhere near your consumers and makes

00:08:59,519 --> 00:09:04,560
those available and of course

00:09:01,360 --> 00:09:07,600
the discovery mechanism will also allow

00:09:04,560 --> 00:09:10,160
the the catalog to be adjusted to

00:09:07,600 --> 00:09:11,839
the circumstances that you have you know

00:09:10,160 --> 00:09:14,720
near your endpoint so if

00:09:11,839 --> 00:09:16,320
it's required to subscribe via a

00:09:14,720 --> 00:09:17,839
different subscription manager we're

00:09:16,320 --> 00:09:21,120
going to get to that in a second

00:09:17,839 --> 00:09:24,320
um to be able to deliver those

00:09:21,120 --> 00:09:25,760
events into your um into your respective

00:09:24,320 --> 00:09:28,720
endpoint that you have

00:09:25,760 --> 00:09:29,680
and then that sort of translation can

00:09:28,720 --> 00:09:31,279
also be done

00:09:29,680 --> 00:09:34,000
um in that discovery model it's not

00:09:31,279 --> 00:09:36,160
expressed it's not it's not expressed

00:09:34,000 --> 00:09:37,839
explicitly because the interface is kept

00:09:36,160 --> 00:09:40,399
very simple

00:09:37,839 --> 00:09:41,760
but the flexibility is there to allow

00:09:40,399 --> 00:09:44,800
this

00:09:41,760 --> 00:09:47,040
next um once you have discovered which

00:09:44,800 --> 00:09:49,920
events are available

00:09:47,040 --> 00:09:51,440
then you want to be able to subscribe to

00:09:49,920 --> 00:09:53,200
them and again today

00:09:51,440 --> 00:09:55,519
in cloud events in the base car event

00:09:53,200 --> 00:10:00,080
spec it's something that we've made

00:09:55,519 --> 00:10:00,080
a matter of um of out of bands

00:10:00,480 --> 00:10:04,000
agreements some protocols um for

00:10:03,680 --> 00:10:07,360
instance

00:10:04,000 --> 00:10:10,880
amqp or mqtt

00:10:07,360 --> 00:10:13,360
or kafka

00:10:10,880 --> 00:10:15,839
already have built-in facilities to

00:10:13,360 --> 00:10:19,200
subscribe so if you are designating a

00:10:15,839 --> 00:10:22,240
subscription manager that is a um

00:10:19,200 --> 00:10:25,120
a queue or sorry or a topic inside of an

00:10:22,240 --> 00:10:27,360
event a message broker then it's implied

00:10:25,120 --> 00:10:30,079
effectively what that subscription

00:10:27,360 --> 00:10:31,200
protocol is if you're using mqp for

00:10:30,079 --> 00:10:34,160
instance

00:10:31,200 --> 00:10:35,120
but for other for http for instance http

00:10:34,160 --> 00:10:38,399
doesn't have a

00:10:35,120 --> 00:10:40,560
built-in subscription notion so

00:10:38,399 --> 00:10:42,480
and even though those subscription

00:10:40,560 --> 00:10:44,320
services are fairly common or these

00:10:42,480 --> 00:10:44,800
construction patterns are fairly common

00:10:44,320 --> 00:10:47,839
with

00:10:44,800 --> 00:10:48,399
with web hooks um it's something that we

00:10:47,839 --> 00:10:51,760
have not

00:10:48,399 --> 00:10:55,519
seen uh being sufficiently standardized

00:10:51,760 --> 00:10:57,680
so we have to find a way to go and

00:10:55,519 --> 00:10:59,279
create a specification that acknowledges

00:10:57,680 --> 00:11:03,120
the existence of

00:10:59,279 --> 00:11:05,040
these existing protocols like mqp and

00:11:03,120 --> 00:11:06,000
mqtt which have built-in subscription

00:11:05,040 --> 00:11:08,800
notions

00:11:06,000 --> 00:11:09,680
and then at the same time add a ability

00:11:08,800 --> 00:11:12,320
for

00:11:09,680 --> 00:11:13,200
protocols that don't have that like http

00:11:12,320 --> 00:11:15,200
to also

00:11:13,200 --> 00:11:17,279
allow you to do a subscription gesture

00:11:15,200 --> 00:11:18,640
that's why we wrote the subscription api

00:11:17,279 --> 00:11:21,519
the subscription api

00:11:18,640 --> 00:11:22,640
specification acknowledges those or

00:11:21,519 --> 00:11:25,040
enumerates the

00:11:22,640 --> 00:11:27,360
subscription facilities that exist in

00:11:25,040 --> 00:11:30,399
those other protocols

00:11:27,360 --> 00:11:33,440
supported by cloud events and then

00:11:30,399 --> 00:11:35,680
explicitly introduces an api which

00:11:33,440 --> 00:11:37,839
can then be implemented using http or

00:11:35,680 --> 00:11:39,279
can be implemented using grpc or

00:11:37,839 --> 00:11:42,000
implemented any other

00:11:39,279 --> 00:11:42,320
protocol that specifically needs this to

00:11:42,000 --> 00:11:45,440
go

00:11:42,320 --> 00:11:47,680
and effectively manage subscriptions

00:11:45,440 --> 00:11:49,440
and for that we've introduced the notion

00:11:47,680 --> 00:11:54,079
of a subscription manager

00:11:49,440 --> 00:11:55,440
next so the subscription manager

00:11:54,079 --> 00:11:57,120
is the one that implements the

00:11:55,440 --> 00:11:58,399
subscription api and the subscription

00:11:57,120 --> 00:12:02,000
manager might act

00:11:58,399 --> 00:12:02,880
on behalf of itself so it may really be

00:12:02,000 --> 00:12:04,800
the

00:12:02,880 --> 00:12:07,040
the entity that emits those events but

00:12:04,800 --> 00:12:09,440
it also made may act on behalf of

00:12:07,040 --> 00:12:10,320
others and so you have that very often

00:12:09,440 --> 00:12:12,959
in

00:12:10,320 --> 00:12:14,639
larger setups where you are you have

00:12:12,959 --> 00:12:16,800
very very many producers

00:12:14,639 --> 00:12:17,920
and those many producers produce events

00:12:16,800 --> 00:12:20,000
into a

00:12:17,920 --> 00:12:21,680
middleware of sorts and then if you are

00:12:20,000 --> 00:12:24,000
interested in

00:12:21,680 --> 00:12:25,680
events from a particular publisher or a

00:12:24,000 --> 00:12:28,720
group of publishers then you are

00:12:25,680 --> 00:12:30,800
subscribing um on that middleware on

00:12:28,720 --> 00:12:33,040
behalf of those producers so

00:12:30,800 --> 00:12:34,320
one of the obvious examples here is

00:12:33,040 --> 00:12:37,120
versus iot

00:12:34,320 --> 00:12:38,959
where you have sometimes thousands and

00:12:37,120 --> 00:12:41,519
or hundreds of thousands of devices

00:12:38,959 --> 00:12:42,639
switching into a cloud endpoint and if

00:12:41,519 --> 00:12:46,160
you're interested in

00:12:42,639 --> 00:12:47,920
specific events um emitted by those

00:12:46,160 --> 00:12:49,600
devices you would not subscribe to every

00:12:47,920 --> 00:12:51,360
single device but you really would go

00:12:49,600 --> 00:12:53,440
and go to the subscription manager

00:12:51,360 --> 00:12:56,240
which has the pool of events to go and

00:12:53,440 --> 00:12:57,760
pull out the events that you need

00:12:56,240 --> 00:12:59,440
for those subscription for the

00:12:57,760 --> 00:13:01,600
subscription manager

00:12:59,440 --> 00:13:02,560
as said we're enumerating the existing

00:13:01,600 --> 00:13:04,480
mechanisms of

00:13:02,560 --> 00:13:06,240
existing protocols that we have defined

00:13:04,480 --> 00:13:09,360
this http api

00:13:06,240 --> 00:13:12,079
to help with the cases where more

00:13:09,360 --> 00:13:13,279
api and api abstraction to help with the

00:13:12,079 --> 00:13:16,320
cases where

00:13:13,279 --> 00:13:19,680
that is not available we also have two

00:13:16,320 --> 00:13:20,399
delivery styles and that is the push

00:13:19,680 --> 00:13:22,480
delivery

00:13:20,399 --> 00:13:25,120
and the pull delivery so we're we're

00:13:22,480 --> 00:13:27,920
just distinguishing between those two

00:13:25,120 --> 00:13:29,200
where typically for cloud events as

00:13:27,920 --> 00:13:32,399
we've defined it

00:13:29,200 --> 00:13:33,519
uh today most mostly the delivery is

00:13:32,399 --> 00:13:36,720
assumed to be push

00:13:33,519 --> 00:13:38,399
which means the producer or the

00:13:36,720 --> 00:13:40,560
subscription manager acting on its

00:13:38,399 --> 00:13:42,000
behalf pushes those events by

00:13:40,560 --> 00:13:46,000
establishing connection

00:13:42,000 --> 00:13:48,720
and sending the event along or

00:13:46,000 --> 00:13:50,560
this can also now the definition here

00:13:48,720 --> 00:13:51,199
allows for pull delivery style where you

00:13:50,560 --> 00:13:53,120
are

00:13:51,199 --> 00:13:55,279
effectively having the subscription

00:13:53,120 --> 00:13:58,160
manager uh maintaining

00:13:55,279 --> 00:13:59,760
a queue for instance on behalf of the

00:13:58,160 --> 00:14:01,600
producer so both of those things are

00:13:59,760 --> 00:14:04,320
possible

00:14:01,600 --> 00:14:05,360
uh next um so those were effectively

00:14:04,320 --> 00:14:08,000
complementing the

00:14:05,360 --> 00:14:09,360
the the mechanisms that we have today in

00:14:08,000 --> 00:14:11,120
uh cloud events by

00:14:09,360 --> 00:14:13,279
you know closing the loop we have

00:14:11,120 --> 00:14:14,399
delivery something that's defined now

00:14:13,279 --> 00:14:17,120
and now we have discovery and

00:14:14,399 --> 00:14:18,880
subscription that we're adding to it

00:14:17,120 --> 00:14:22,240
a really important further element is

00:14:18,880 --> 00:14:22,240
schema registry next

00:14:23,839 --> 00:14:28,320
every cloud event can carry a payload

00:14:26,399 --> 00:14:30,320
with event details mostly you form our

00:14:28,320 --> 00:14:32,800
structured data

00:14:30,320 --> 00:14:33,839
structured data if you're sending it or

00:14:32,800 --> 00:14:36,880
sending it

00:14:33,839 --> 00:14:37,279
to another party will require often for

00:14:36,880 --> 00:14:39,040
that

00:14:37,279 --> 00:14:41,760
other party to be able to validate

00:14:39,040 --> 00:14:45,040
whether that structured data is correct

00:14:41,760 --> 00:14:46,720
based on some syntactic rules that can

00:14:45,040 --> 00:14:49,760
be expressed in

00:14:46,720 --> 00:14:51,920
a schema and then there's

00:14:49,760 --> 00:14:52,959
often also a need for serialization

00:14:51,920 --> 00:14:54,639
where you want to have

00:14:52,959 --> 00:14:56,000
an in-memory data structure to be

00:14:54,639 --> 00:14:59,519
serialized out

00:14:56,000 --> 00:15:01,920
using an efficient um format

00:14:59,519 --> 00:15:04,079
and those efficient formats often leave

00:15:01,920 --> 00:15:06,480
the structural metadata out

00:15:04,079 --> 00:15:08,880
like you're familiar with with what json

00:15:06,480 --> 00:15:10,639
looks like json is very repetitive

00:15:08,880 --> 00:15:12,320
and puts all the metadata elements and

00:15:10,639 --> 00:15:14,560
the type information kind of

00:15:12,320 --> 00:15:15,519
into the document itself and there's a

00:15:14,560 --> 00:15:18,160
number of

00:15:15,519 --> 00:15:19,920
far more efficient serialization formats

00:15:18,160 --> 00:15:22,240
which don't do that and they keep

00:15:19,920 --> 00:15:24,240
that information outside in in schema

00:15:22,240 --> 00:15:26,160
documents but then once you use that

00:15:24,240 --> 00:15:28,160
the question is where do you put those

00:15:26,160 --> 00:15:30,560
documents so the goal

00:15:28,160 --> 00:15:32,480
of the schema registry is to allow you

00:15:30,560 --> 00:15:34,399
to store these documents and access

00:15:32,480 --> 00:15:36,320
access those documents in a consistent

00:15:34,399 --> 00:15:40,079
way so that you can go and pro

00:15:36,320 --> 00:15:41,360
and build software elements a serializer

00:15:40,079 --> 00:15:43,279
and a validator

00:15:41,360 --> 00:15:44,480
that can then lean on those schemas and

00:15:43,279 --> 00:15:48,000
on hints that come

00:15:44,480 --> 00:15:49,519
with the event and then can go and

00:15:48,000 --> 00:15:51,120
deserialize that structured data or

00:15:49,519 --> 00:15:54,399
serialize that structure data

00:15:51,120 --> 00:15:55,040
and the goal is for that to be project

00:15:54,399 --> 00:15:57,519
neutral

00:15:55,040 --> 00:15:58,480
and vendor neutral so that that works

00:15:57,519 --> 00:16:01,120
for

00:15:58,480 --> 00:16:02,320
cloud events but that also works for

00:16:01,120 --> 00:16:03,519
other messaging and inventing

00:16:02,320 --> 00:16:06,320
infrastructures because

00:16:03,519 --> 00:16:08,079
we often see that things get boring as

00:16:06,320 --> 00:16:09,759
cloud events but then get forwarded

00:16:08,079 --> 00:16:10,480
through other messaging infrastructures

00:16:09,759 --> 00:16:12,079
as well

00:16:10,480 --> 00:16:13,680
and so we don't want to constrain this

00:16:12,079 --> 00:16:14,959
to the case of cloud events and cloud

00:16:13,680 --> 00:16:18,240
events also

00:16:14,959 --> 00:16:21,120
is um just using in

00:16:18,240 --> 00:16:22,000
in the binary format is just using a

00:16:21,120 --> 00:16:24,560
message payload

00:16:22,000 --> 00:16:25,440
like any other message or eventing use

00:16:24,560 --> 00:16:27,040
case would

00:16:25,440 --> 00:16:29,360
so it would it doesn't simply doesn't

00:16:27,040 --> 00:16:32,480
make sense to constrain the registry

00:16:29,360 --> 00:16:34,560
just to cloud events uh use cases

00:16:32,480 --> 00:16:35,920
next so that's one of the principles

00:16:34,560 --> 00:16:37,600
that we have is

00:16:35,920 --> 00:16:39,360
at the bottom what i just said that it

00:16:37,600 --> 00:16:41,519
should be scenario neutral

00:16:39,360 --> 00:16:43,600
it should also be protocol neutral so

00:16:41,519 --> 00:16:44,399
the registry data model is abstractly

00:16:43,600 --> 00:16:47,920
defined and

00:16:44,399 --> 00:16:51,199
the http binding that we have so setting

00:16:47,920 --> 00:16:53,440
and receiving message schemas

00:16:51,199 --> 00:16:55,360
via http that's well defined right now

00:16:53,440 --> 00:16:58,399
with an open api document

00:16:55,360 --> 00:16:59,680
but the the registry per se the the data

00:16:58,399 --> 00:17:03,120
model is abstract

00:16:59,680 --> 00:17:04,000
find and we allow it allows protocol

00:17:03,120 --> 00:17:05,839
bindings and

00:17:04,000 --> 00:17:08,000
we certainly anticipate to have an amqp

00:17:05,839 --> 00:17:10,640
binding for this and

00:17:08,000 --> 00:17:12,240
hopefully more bindings that somewhat

00:17:10,640 --> 00:17:15,039
depends because it's a request

00:17:12,240 --> 00:17:16,559
response model and request depends on

00:17:15,039 --> 00:17:18,559
the capabilities of the respective

00:17:16,559 --> 00:17:20,079
protocols but grpc is also certainly in

00:17:18,559 --> 00:17:21,839
the cards

00:17:20,079 --> 00:17:23,520
um and of course we want to keep this as

00:17:21,839 --> 00:17:24,480
simple as possible we don't want to turn

00:17:23,520 --> 00:17:28,799
this into

00:17:24,480 --> 00:17:30,880
a massive metadata store with um

00:17:28,799 --> 00:17:32,320
super powerful capabilities so there's

00:17:30,880 --> 00:17:34,880
no um

00:17:32,320 --> 00:17:37,039
goal here to rival the capabilities of

00:17:34,880 --> 00:17:39,520
apache atlas or something like this

00:17:37,039 --> 00:17:40,480
but really is like you should be able to

00:17:39,520 --> 00:17:43,280
implement this

00:17:40,480 --> 00:17:44,799
registry api over a plain file system or

00:17:43,280 --> 00:17:48,400
a cloud blob store

00:17:44,799 --> 00:17:51,200
and it's just there to store

00:17:48,400 --> 00:17:52,720
those store those schemas and manage

00:17:51,200 --> 00:17:53,600
those schemas in the simplest possible

00:17:52,720 --> 00:17:56,000
way while

00:17:53,600 --> 00:17:58,240
while providing the core capabilities we

00:17:56,000 --> 00:18:00,080
need next

00:17:58,240 --> 00:18:02,799
so this complements the event delivery

00:18:00,080 --> 00:18:05,919
model that i just talked about

00:18:02,799 --> 00:18:08,480
um by allowing you the producers

00:18:05,919 --> 00:18:09,840
to manage and validate or someone on

00:18:08,480 --> 00:18:12,160
behalf of the producers to manage the

00:18:09,840 --> 00:18:14,720
value of the schemas

00:18:12,160 --> 00:18:16,559
and then really think about the data

00:18:14,720 --> 00:18:18,640
field in the cloud event and how

00:18:16,559 --> 00:18:21,039
that can be serialized and deserialized

00:18:18,640 --> 00:18:24,080
and that model here what's in the green

00:18:21,039 --> 00:18:26,160
um works for cloud events um as we have

00:18:24,080 --> 00:18:29,440
defined it but also works for

00:18:26,160 --> 00:18:31,760
um other uh eventing scenarios

00:18:29,440 --> 00:18:34,160
as well so this is kind of you for you

00:18:31,760 --> 00:18:35,440
to to get visualize what this is about

00:18:34,160 --> 00:18:37,280
it's really for serialization

00:18:35,440 --> 00:18:39,120
deserializing or validation

00:18:37,280 --> 00:18:40,320
on either side and it really pertains to

00:18:39,120 --> 00:18:44,960
the data element

00:18:40,320 --> 00:18:44,960
that sits inside of the cloud event next

00:18:45,120 --> 00:18:49,440
um finally the structure of the schemes

00:18:47,600 --> 00:18:50,960
of this schema registry

00:18:49,440 --> 00:18:53,120
we've structured this such that there is

00:18:50,960 --> 00:18:55,600
a notion of groups

00:18:53,120 --> 00:18:57,600
the group they can group so a schema

00:18:55,600 --> 00:18:58,720
registry is split up into groups those

00:18:57,600 --> 00:19:01,919
groups can be

00:18:58,720 --> 00:19:03,919
by application or by some other criteria

00:19:01,919 --> 00:19:05,919
they're really also there as an anchor

00:19:03,919 --> 00:19:06,480
for access control so you may want to go

00:19:05,919 --> 00:19:09,280
and

00:19:06,480 --> 00:19:11,200
limit access to schemas by groups

00:19:09,280 --> 00:19:13,360
because they may carry

00:19:11,200 --> 00:19:14,559
important secrets so you don't want to

00:19:13,360 --> 00:19:15,440
you know make them accessible to

00:19:14,559 --> 00:19:17,200
everybody

00:19:15,440 --> 00:19:19,280
then within that you have schemas which

00:19:17,200 --> 00:19:21,039
really are containers for

00:19:19,280 --> 00:19:22,720
sets of schema documents that represent

00:19:21,039 --> 00:19:25,600
the same data structures

00:19:22,720 --> 00:19:28,400
and then of course those those schemas

00:19:25,600 --> 00:19:31,039
evolve and so the documents are really

00:19:28,400 --> 00:19:32,559
the leaves of this we have various

00:19:31,039 --> 00:19:35,280
schema versions starting with

00:19:32,559 --> 00:19:37,679
schema version one um where if you're

00:19:35,280 --> 00:19:40,080
adding fields or if you're making feels

00:19:37,679 --> 00:19:41,919
obsolete but you don't remove them then

00:19:40,080 --> 00:19:43,840
you're still within the same bad words

00:19:41,919 --> 00:19:46,720
compatible schema

00:19:43,840 --> 00:19:47,600
of generate generations line of

00:19:46,720 --> 00:19:49,280
generations

00:19:47,600 --> 00:19:51,200
and that's why you simply add schema

00:19:49,280 --> 00:19:51,760
versions we have some rules for how to

00:19:51,200 --> 00:19:54,799
add

00:19:51,760 --> 00:19:57,280
and manage those

00:19:54,799 --> 00:19:59,760
schemas so it's a very simple structure

00:19:57,280 --> 00:20:02,080
to manage effectively schema documents

00:19:59,760 --> 00:20:02,080
next

00:20:02,799 --> 00:20:09,760
and that's where we are we will

00:20:06,320 --> 00:20:11,200
take some live questions um in

00:20:09,760 --> 00:20:13,679
at the end of this presentation

00:20:11,200 --> 00:20:15,120
following now um if you want to learn

00:20:13,679 --> 00:20:16,799
more about cloud events go to cloud

00:20:15,120 --> 00:20:19,520
events io

00:20:16,799 --> 00:20:20,000
our specification repository is on

00:20:19,520 --> 00:20:22,080
github

00:20:20,000 --> 00:20:23,679
on cloudevent spec that's where you also

00:20:22,080 --> 00:20:24,880
will find the latest versions of all of

00:20:23,679 --> 00:20:28,480
those things and we also have

00:20:24,880 --> 00:20:31,840
weekly calls thursdays at 12 p.m

00:20:28,480 --> 00:20:35,120
eastern time us or 1800

00:20:31,840 --> 00:20:35,840
central european time and in the repo is

00:20:35,120 --> 00:20:39,360
also

00:20:35,840 --> 00:20:41,679
the dial in information and then

00:20:39,360 --> 00:20:43,600
you can also follow doug and myself on

00:20:41,679 --> 00:20:46,240
twitter or send us email if you have any

00:20:43,600 --> 00:20:46,240
further questions

00:20:46,559 --> 00:20:49,280
all right cool thank you comments all

00:20:48,320 --> 00:20:50,960
right thank you everybody we'll stop

00:20:49,280 --> 00:20:55,039
recording here and take questions uh

00:20:50,960 --> 00:20:55,039

YouTube URL: https://www.youtube.com/watch?v=SrUR-XnnrHA


