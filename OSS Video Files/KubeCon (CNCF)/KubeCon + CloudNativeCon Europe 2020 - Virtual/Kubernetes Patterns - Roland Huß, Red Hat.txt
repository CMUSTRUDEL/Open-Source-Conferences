Title: Kubernetes Patterns - Roland Huß, Red Hat
Publication date: 2020-08-28
Playlist: KubeCon + CloudNativeCon Europe 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming events: EnvoyCon Virtual on October 15 and KubeCon + CloudNativeCon North America 2020 Virtual from November 17-20. Learn more at https://kubecon.io. The conferences feature presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.  

Kubernetes Patterns - Roland Huß, Red Hat 

The way developers design, build, and run software has changed significantly with the evolution of microservices, containers and Kubernetes. This talk dives into common, reusable patterns and principles for designing and implementing cloud-native applications on Kubernetes.  This talk focus on the most established patterns. It will revisit basic patterns like "Predictable Demands" or "Service Discovery" but also dive into prominent patterns "Sidecar", "Elastic Scale" or "Operator". Live demos back this presentation.  This presentation is ideal for developers and architects who want to learn more about a pattern-based approach to implementing common Kubernetes usage scenarios.

https://sched.co/ZerV
Captions: 
	00:00:00,080 --> 00:00:03,280
and welcome to this talk about

00:00:01,520 --> 00:00:04,880
kubernetes patterns my name is roland

00:00:03,280 --> 00:00:05,359
hills i'm a software engineer from red

00:00:04,880 --> 00:00:07,520
hat

00:00:05,359 --> 00:00:09,599
and currently i'm working on k native

00:00:07,520 --> 00:00:10,960
which is a serverless platform on top of

00:00:09,599 --> 00:00:12,480
kubernetes

00:00:10,960 --> 00:00:14,880
all the patterns i'm going to show you

00:00:12,480 --> 00:00:16,400
today are described in this book that i

00:00:14,880 --> 00:00:19,039
have written together with my friend

00:00:16,400 --> 00:00:20,720
belgium you can get a free copy of this

00:00:19,039 --> 00:00:23,519
book by following this link

00:00:20,720 --> 00:00:25,279
this copy has been sponsored by red hat

00:00:23,519 --> 00:00:26,800
so if you free download it it's a pdf

00:00:25,279 --> 00:00:27,920
file you find all the patterns i'm

00:00:26,800 --> 00:00:30,000
showing you today

00:00:27,920 --> 00:00:31,359
and many more also you find all the

00:00:30,000 --> 00:00:34,000
examples

00:00:31,359 --> 00:00:36,480
which you can try out just to illustrate

00:00:34,000 --> 00:00:39,920
how these patterns are working

00:00:36,480 --> 00:00:39,920
okay so let's get started

00:00:40,000 --> 00:00:44,320
first of all let's talk a little bit

00:00:42,160 --> 00:00:46,800
about what patterns are

00:00:44,320 --> 00:00:47,520
patterns are really a very very old

00:00:46,800 --> 00:00:49,920
concept

00:00:47,520 --> 00:00:50,559
they are older than 40 years and come

00:00:49,920 --> 00:00:52,719
from this

00:00:50,559 --> 00:00:54,960
original book by christopher alexander

00:00:52,719 --> 00:00:56,879
written in 1979.

00:00:54,960 --> 00:00:58,079
in this book christopher alexander and

00:00:56,879 --> 00:01:00,960
his co-workers

00:00:58,079 --> 00:01:02,640
are describing a pattern language which

00:01:00,960 --> 00:01:04,000
can be applied on the field of

00:01:02,640 --> 00:01:06,400
architecture

00:01:04,000 --> 00:01:08,320
so what is a pattern in that sense so

00:01:06,400 --> 00:01:10,080
this classical pattern always has a name

00:01:08,320 --> 00:01:10,960
a name is very important because

00:01:10,080 --> 00:01:13,360
patterns

00:01:10,960 --> 00:01:14,880
form a kind of a language which is

00:01:13,360 --> 00:01:16,560
interconnected so you have patterns

00:01:14,880 --> 00:01:19,920
which are related to other patterns

00:01:16,560 --> 00:01:22,240
and they form a repeatable solution

00:01:19,920 --> 00:01:23,680
to a certain set of problems so it's not

00:01:22,240 --> 00:01:26,560
a very concrete solution but

00:01:23,680 --> 00:01:28,080
kind of a solution pattern which you can

00:01:26,560 --> 00:01:29,920
apply in certain contexts

00:01:28,080 --> 00:01:31,439
here is an example of a pattern which is

00:01:29,920 --> 00:01:33,439
called city country fingers

00:01:31,439 --> 00:01:35,040
and it describes how you should plan for

00:01:33,439 --> 00:01:37,840
a city so that the

00:01:35,040 --> 00:01:38,400
people in the city don't have to walk a

00:01:37,840 --> 00:01:41,680
lot

00:01:38,400 --> 00:01:44,720
until they reach some green

00:01:41,680 --> 00:01:49,520
of course this idea has then been slept

00:01:44,720 --> 00:01:49,520
a while but in 1994

00:01:49,759 --> 00:01:54,880
the gang of four picked up that idea and

00:01:52,720 --> 00:01:57,119
transformed it on the field of software

00:01:54,880 --> 00:01:58,240
engineering so this was a very famous

00:01:57,119 --> 00:02:00,000
book i guess

00:01:58,240 --> 00:02:02,399
everybody of you already heard about it

00:02:00,000 --> 00:02:03,439
it's design patterns for object oriented

00:02:02,399 --> 00:02:06,399
software

00:02:03,439 --> 00:02:07,759
and it contains all this famous pattern

00:02:06,399 --> 00:02:10,080
that we all know and love

00:02:07,759 --> 00:02:13,120
like a singleton like a factory like a

00:02:10,080 --> 00:02:14,959
delegate and many many more

00:02:13,120 --> 00:02:16,800
again this pattern has a certain schema

00:02:14,959 --> 00:02:19,040
they are described they all have a name

00:02:16,800 --> 00:02:20,480
and they form an interconnected kind of

00:02:19,040 --> 00:02:22,560
mini language

00:02:20,480 --> 00:02:23,920
okay kubernetes um the other part of

00:02:22,560 --> 00:02:25,280
this uh presentation of course

00:02:23,920 --> 00:02:27,520
cleveland's patterns

00:02:25,280 --> 00:02:28,959
but uh i don't talk much about

00:02:27,520 --> 00:02:30,400
kubernetes here because i assume you

00:02:28,959 --> 00:02:31,360
already know quite a bit of kubernetes

00:02:30,400 --> 00:02:34,720
otherwise you wouldn't

00:02:31,360 --> 00:02:37,440
join the keep con but just for

00:02:34,720 --> 00:02:39,120
very super brief recap so the main

00:02:37,440 --> 00:02:42,080
ingredient for

00:02:39,120 --> 00:02:43,040
kubernetes is the pot it's the atom of

00:02:42,080 --> 00:02:46,560
kubernetes

00:02:43,040 --> 00:02:49,840
and the pot is kind of abstraction over

00:02:46,560 --> 00:02:52,080
the containers and there are

00:02:49,840 --> 00:02:54,239
really describe the runtime contract for

00:02:52,080 --> 00:02:56,080
a container so how containers can

00:02:54,239 --> 00:02:57,760
run within the project sometimes you

00:02:56,080 --> 00:02:58,480
only have one port one container in a

00:02:57,760 --> 00:02:59,920
port but

00:02:58,480 --> 00:03:01,680
often you also have more of them you

00:02:59,920 --> 00:03:02,400
will see a pattern which really use this

00:03:01,680 --> 00:03:04,959
concept

00:03:02,400 --> 00:03:08,480
in depth these containers can share

00:03:04,959 --> 00:03:10,879
certain data via network or real disk

00:03:08,480 --> 00:03:12,239
then your code live lives in such a port

00:03:10,879 --> 00:03:14,000
and is executed in the port

00:03:12,239 --> 00:03:15,840
and around that you have tons of other

00:03:14,000 --> 00:03:19,599
entities which allows you to

00:03:15,840 --> 00:03:22,800
to declare how the application

00:03:19,599 --> 00:03:24,319
is supposed to be running and you see

00:03:22,800 --> 00:03:25,920
here a whole bunch of them

00:03:24,319 --> 00:03:28,159
and this is important that you always

00:03:25,920 --> 00:03:29,840
declare what you want to have you do not

00:03:28,159 --> 00:03:31,840
tell communities do that and that and

00:03:29,840 --> 00:03:32,959
that step by step but you declare what

00:03:31,840 --> 00:03:34,799
kind of a target state

00:03:32,959 --> 00:03:37,120
we come to this concept in a little bit

00:03:34,799 --> 00:03:39,680
later

00:03:37,120 --> 00:03:40,319
so now let's dive into the patterns so

00:03:39,680 --> 00:03:41,920
we have

00:03:40,319 --> 00:03:44,000
different pattern categories so we

00:03:41,920 --> 00:03:44,799
organized the 24 patterns in different

00:03:44,000 --> 00:03:46,239
categories

00:03:44,799 --> 00:03:48,959
one of them are the foundational

00:03:46,239 --> 00:03:52,080
patterns these are more or less

00:03:48,959 --> 00:03:53,599
the intrinsic features of kubernetes

00:03:52,080 --> 00:03:55,360
the reason for that is that kubernetes

00:03:53,599 --> 00:03:57,120
itself as a platform

00:03:55,360 --> 00:03:59,439
is the implementation of certain

00:03:57,120 --> 00:04:01,680
patterns for distributed computing

00:03:59,439 --> 00:04:03,599
and we really find some core concept in

00:04:01,680 --> 00:04:05,519
the foundational category

00:04:03,599 --> 00:04:06,720
on top of that we have structural

00:04:05,519 --> 00:04:10,239
patterns which really

00:04:06,720 --> 00:04:13,280
take kind of the foundational primitives

00:04:10,239 --> 00:04:15,040
and combine them into something new

00:04:13,280 --> 00:04:16,639
on top of that or a little bit not

00:04:15,040 --> 00:04:17,519
really on top of that but a little bit

00:04:16,639 --> 00:04:18,959
on this side are the

00:04:17,519 --> 00:04:21,759
configuration patterns which is all

00:04:18,959 --> 00:04:23,600
about how you can configure applications

00:04:21,759 --> 00:04:25,440
um so there are different techniques for

00:04:23,600 --> 00:04:28,639
that

00:04:25,440 --> 00:04:31,120
um we have the behavioral patterns which

00:04:28,639 --> 00:04:32,479
is really describes the kind of

00:04:31,120 --> 00:04:33,759
application you're running so whether

00:04:32,479 --> 00:04:36,800
it's kind of a stateful

00:04:33,759 --> 00:04:40,000
service or a stateless uh

00:04:36,800 --> 00:04:41,680
application whether it's running in the

00:04:40,000 --> 00:04:43,759
with a batch job or something like that

00:04:41,680 --> 00:04:46,320
so this is all

00:04:43,759 --> 00:04:48,080
combined in the behavioral category and

00:04:46,320 --> 00:04:49,440
finally we have some kind of advanced

00:04:48,080 --> 00:04:51,280
patterns which do not really fit in the

00:04:49,440 --> 00:04:53,040
other categories but they have some more

00:04:51,280 --> 00:04:53,680
advanced concepts based on all of the

00:04:53,040 --> 00:04:56,080
other

00:04:53,680 --> 00:04:58,639
patterns i have an example for every of

00:04:56,080 --> 00:05:01,600
these categories

00:04:58,639 --> 00:05:02,400
so let's look let's start first with the

00:05:01,600 --> 00:05:06,720
foundational

00:05:02,400 --> 00:05:08,560
patterns so here we have

00:05:06,720 --> 00:05:10,320
as i mentioned core functionality of

00:05:08,560 --> 00:05:12,000
humanities like health probes which are

00:05:10,320 --> 00:05:13,440
readiness and liveness checks

00:05:12,000 --> 00:05:15,360
predictable amounts is about how you

00:05:13,440 --> 00:05:16,400
declare your dependencies like resource

00:05:15,360 --> 00:05:18,160
limits

00:05:16,400 --> 00:05:20,560
uh managed life cycle is how you can

00:05:18,160 --> 00:05:21,199
hook into the life cycle events for all

00:05:20,560 --> 00:05:23,039
your pot

00:05:21,199 --> 00:05:24,720
when so that you get notified when it

00:05:23,039 --> 00:05:26,639
starts or then stops

00:05:24,720 --> 00:05:29,360
and so on so but here we are looking at

00:05:26,639 --> 00:05:31,360
the declarative deployment

00:05:29,360 --> 00:05:33,120
declarative deployment is all about so

00:05:31,360 --> 00:05:34,560
the problem statement is here

00:05:33,120 --> 00:05:36,320
and the question is how to perform

00:05:34,560 --> 00:05:36,960
application installations and also

00:05:36,320 --> 00:05:40,160
upgrades

00:05:36,960 --> 00:05:43,440
by configuration only by declaring your

00:05:40,160 --> 00:05:45,039
strategy so we have a core

00:05:43,440 --> 00:05:47,680
entity in kubernetes which is called the

00:05:45,039 --> 00:05:49,680
deployment and this is really

00:05:47,680 --> 00:05:51,039
all about declarative rather imperative

00:05:49,680 --> 00:05:52,560
deployments before

00:05:51,039 --> 00:05:54,080
the deployment and the resource was

00:05:52,560 --> 00:05:56,160
introduced into qranius

00:05:54,080 --> 00:05:57,919
all you could do was kind of a

00:05:56,160 --> 00:06:00,080
imperative deployment with a client

00:05:57,919 --> 00:06:02,080
application so cube control

00:06:00,080 --> 00:06:04,639
which allows you to do certain things

00:06:02,080 --> 00:06:07,199
like rolling updates

00:06:04,639 --> 00:06:09,120
so in the relative deployment you really

00:06:07,199 --> 00:06:10,560
say step by step what should be done for

00:06:09,120 --> 00:06:10,880
rolling up that which means that you

00:06:10,560 --> 00:06:14,000
have

00:06:10,880 --> 00:06:15,600
a set of new copies of your set of old

00:06:14,000 --> 00:06:16,479
copies of your application a set of new

00:06:15,600 --> 00:06:20,080
copies

00:06:16,479 --> 00:06:22,720
and how you can really um

00:06:20,080 --> 00:06:23,440
scale the old ones down and scale up the

00:06:22,720 --> 00:06:26,639
old

00:06:23,440 --> 00:06:29,360
the new ones and um

00:06:26,639 --> 00:06:30,000
this is done step by step as mentioned

00:06:29,360 --> 00:06:32,479
however

00:06:30,000 --> 00:06:33,120
with deployment we introduced this has

00:06:32,479 --> 00:06:35,360
been

00:06:33,120 --> 00:06:36,880
a declarative way how you can declare

00:06:35,360 --> 00:06:38,800
your deployment strategy

00:06:36,880 --> 00:06:40,479
by just saying okay i want to have a

00:06:38,800 --> 00:06:41,360
rolling update i want to have this is my

00:06:40,479 --> 00:06:45,199
new image

00:06:41,360 --> 00:06:48,400
and now you please do this for me

00:06:45,199 --> 00:06:49,919
deployment kubernetes resource holds the

00:06:48,400 --> 00:06:50,400
template report so that the deployment

00:06:49,919 --> 00:06:52,560
can

00:06:50,400 --> 00:06:54,319
create new ports for you it creates

00:06:52,560 --> 00:06:57,039
replica sets on the fly so it's kind of

00:06:54,319 --> 00:06:59,039
a manager for your replica sets so

00:06:57,039 --> 00:07:00,720
we will see this in a second it allows

00:06:59,039 --> 00:07:02,000
also for rollbacks to an older version

00:07:00,720 --> 00:07:05,280
if you do an update

00:07:02,000 --> 00:07:06,880
and two several update strategies are

00:07:05,280 --> 00:07:09,039
declared within your deployment

00:07:06,880 --> 00:07:10,800
descriptor

00:07:09,039 --> 00:07:12,400
here we see now the different types of

00:07:10,800 --> 00:07:13,599
declarative deployments are one of the

00:07:12,400 --> 00:07:17,360
role deployment

00:07:13,599 --> 00:07:20,639
which is just about how you can

00:07:17,360 --> 00:07:23,360
create a zero downtime

00:07:20,639 --> 00:07:24,080
upgrade so you in this example you have

00:07:23,360 --> 00:07:27,440
a version

00:07:24,080 --> 00:07:29,520
1 0 which is your old versions you have

00:07:27,440 --> 00:07:31,840
three copies running in a replica set

00:07:29,520 --> 00:07:32,800
there which is managed by a deployment

00:07:31,840 --> 00:07:35,199
then you change

00:07:32,800 --> 00:07:36,479
the image reference within your

00:07:35,199 --> 00:07:38,160
deployment

00:07:36,479 --> 00:07:39,759
so that the target state which is now

00:07:38,160 --> 00:07:41,199
the new which is the change deployment

00:07:39,759 --> 00:07:42,560
is differs from the current state which

00:07:41,199 --> 00:07:43,599
is still the reference to the old

00:07:42,560 --> 00:07:46,240
version

00:07:43,599 --> 00:07:46,800
and then your deployment controller will

00:07:46,240 --> 00:07:48,400
then

00:07:46,800 --> 00:07:50,639
create a new replica set with this new

00:07:48,400 --> 00:07:54,240
reference let's say it's version 1.1

00:07:50,639 --> 00:07:56,720
and then scales down the old

00:07:54,240 --> 00:07:58,000
replica set so from three to two and

00:07:56,720 --> 00:08:00,240
scales up the new one

00:07:58,000 --> 00:08:02,080
from zero to one and then continues

00:08:00,240 --> 00:08:03,759
until everything is

00:08:02,080 --> 00:08:05,280
until you have three copies of your new

00:08:03,759 --> 00:08:08,639
applications version

00:08:05,280 --> 00:08:10,400
and zero of the old one in front of your

00:08:08,639 --> 00:08:12,000
ports you still have a service and the

00:08:10,400 --> 00:08:13,599
selector of the service should point

00:08:12,000 --> 00:08:17,759
really to both versions

00:08:13,599 --> 00:08:20,720
so that you always have the same

00:08:17,759 --> 00:08:21,520
um so that a user which goes over the

00:08:20,720 --> 00:08:24,639
service

00:08:21,520 --> 00:08:27,120
hits either version 1.0 or 1.1 so that

00:08:24,639 --> 00:08:28,639
there's no downtime for your application

00:08:27,120 --> 00:08:30,639
of course this kind of deployment

00:08:28,639 --> 00:08:34,399
doesn't work does it always work

00:08:30,639 --> 00:08:37,599
so your application really needs to be

00:08:34,399 --> 00:08:38,880
tailored for being able to

00:08:37,599 --> 00:08:40,560
being upgraded within a rolling

00:08:38,880 --> 00:08:42,080
deployment for example your back end

00:08:40,560 --> 00:08:43,519
state like our database

00:08:42,080 --> 00:08:48,000
need to be able to run with both

00:08:43,519 --> 00:08:48,000
versions so version 1.0 and 1.1

00:08:48,160 --> 00:08:51,760
so for if you have a schema upgrade

00:08:50,399 --> 00:08:53,680
between those versions you

00:08:51,760 --> 00:08:55,839
have to do this very carefully so that

00:08:53,680 --> 00:08:58,000
your database schema really can support

00:08:55,839 --> 00:08:59,519
both versions

00:08:58,000 --> 00:09:02,800
the next one would be a fixed deployment

00:08:59,519 --> 00:09:05,839
this is a little bit easier for from the

00:09:02,800 --> 00:09:08,160
so it's a bit easier from our

00:09:05,839 --> 00:09:10,160
implementation side it's because all

00:09:08,160 --> 00:09:11,920
your old versions are scaled down to

00:09:10,160 --> 00:09:13,440
zero immediately at once

00:09:11,920 --> 00:09:15,600
and as soon as they are down then your

00:09:13,440 --> 00:09:16,880
new ones gets be get been scaled up so

00:09:15,600 --> 00:09:18,880
then you have a kind of a

00:09:16,880 --> 00:09:20,480
little bit of a time gap between those

00:09:18,880 --> 00:09:22,959
versions so down time

00:09:20,480 --> 00:09:25,680
and the service actually really switched

00:09:22,959 --> 00:09:27,120
over to the new one after that

00:09:25,680 --> 00:09:28,880
then there are variation of both of

00:09:27,120 --> 00:09:30,399
those deployments so

00:09:28,880 --> 00:09:31,600
these two deployments like fixed

00:09:30,399 --> 00:09:32,399
deployment and a rolling update

00:09:31,600 --> 00:09:34,080
deployment

00:09:32,399 --> 00:09:36,080
are really supported directly by

00:09:34,080 --> 00:09:38,480
kubernetes via the deployment

00:09:36,080 --> 00:09:40,800
resource but if you want to have some

00:09:38,480 --> 00:09:43,680
more sophisticated deployment strategies

00:09:40,800 --> 00:09:44,880
then you can do that as well but then

00:09:43,680 --> 00:09:47,839
you have to do it manually by

00:09:44,880 --> 00:09:49,120
managing multiple deployments or you use

00:09:47,839 --> 00:09:52,080
a platform

00:09:49,120 --> 00:09:53,839
like k native which also supports which

00:09:52,080 --> 00:09:56,080
is kind of a has a

00:09:53,839 --> 00:09:57,440
concept of a service creative service

00:09:56,080 --> 00:09:58,000
which is a simplification of a

00:09:57,440 --> 00:10:00,320
deployment

00:09:58,000 --> 00:10:01,760
which also allows you to create these

00:10:00,320 --> 00:10:02,320
these strategies i'm going to show you

00:10:01,760 --> 00:10:04,959
now

00:10:02,320 --> 00:10:06,000
we are so called traffic splitting so

00:10:04,959 --> 00:10:07,920
for a

00:10:06,000 --> 00:10:09,279
release you still have you have your old

00:10:07,920 --> 00:10:11,760
version 1.

00:10:09,279 --> 00:10:13,839
1.0 covered by one deployment you create

00:10:11,760 --> 00:10:16,240
a new deployment with a new reference to

00:10:13,839 --> 00:10:17,519
1.1 and so you have both versions

00:10:16,240 --> 00:10:19,360
running at the same time

00:10:17,519 --> 00:10:21,120
however this also the service always

00:10:19,360 --> 00:10:22,640
look still points only to the old

00:10:21,120 --> 00:10:24,320
version

00:10:22,640 --> 00:10:27,040
then you have time to test your new

00:10:24,320 --> 00:10:29,360
versions and if you are fine with that

00:10:27,040 --> 00:10:31,360
you can just switch up with one called

00:10:29,360 --> 00:10:33,040
the service over to the newer version

00:10:31,360 --> 00:10:36,399
in the sense so in the sense you also

00:10:33,040 --> 00:10:38,880
have kind of a zero downtime

00:10:36,399 --> 00:10:41,600
and but you have an atomic switch also

00:10:38,880 --> 00:10:43,519
for this service

00:10:41,600 --> 00:10:44,959
another variation of the rolling update

00:10:43,519 --> 00:10:46,079
is the canary release where you say you

00:10:44,959 --> 00:10:48,000
make a rolling update

00:10:46,079 --> 00:10:49,279
but you stop in the middle so in this

00:10:48,000 --> 00:10:50,959
case you just

00:10:49,279 --> 00:10:52,720
maybe you have three replicas set

00:10:50,959 --> 00:10:54,640
replicas for your old

00:10:52,720 --> 00:10:56,560
uh and your old version but then you

00:10:54,640 --> 00:10:56,880
scale up one port with your new version

00:10:56,560 --> 00:10:58,560
and

00:10:56,880 --> 00:11:00,720
your server still goes to both of them

00:10:58,560 --> 00:11:02,160
but you have maybe ninety percent of

00:11:00,720 --> 00:11:02,720
your traffic then goes to the old

00:11:02,160 --> 00:11:04,959
version

00:11:02,720 --> 00:11:06,560
but only ten percent of the new one so

00:11:04,959 --> 00:11:09,200
you can try out some stuff

00:11:06,560 --> 00:11:10,240
and say okay i'm it's okay for me that

00:11:09,200 --> 00:11:12,079
you can

00:11:10,240 --> 00:11:13,440
scale up the new version make it a full

00:11:12,079 --> 00:11:16,079
rolling deployment

00:11:13,440 --> 00:11:16,880
or you say no that's not what i wanted

00:11:16,079 --> 00:11:19,680
to have

00:11:16,880 --> 00:11:20,320
let's go back to the old version this is

00:11:19,680 --> 00:11:22,399
easily done

00:11:20,320 --> 00:11:23,519
again using k native this is super

00:11:22,399 --> 00:11:25,120
simple to do

00:11:23,519 --> 00:11:28,560
if you don't use k native you can do

00:11:25,120 --> 00:11:29,279
this manually as well so here's a nice

00:11:28,560 --> 00:11:31,680
diagram

00:11:29,279 --> 00:11:33,519
also from the book where you see how

00:11:31,680 --> 00:11:36,880
these deployments

00:11:33,519 --> 00:11:38,399
are working over time so on the x-axis

00:11:36,880 --> 00:11:39,920
you have the time

00:11:38,399 --> 00:11:41,839
on the y-axis you have the number of

00:11:39,920 --> 00:11:43,040
instances running the blue one is the

00:11:41,839 --> 00:11:46,000
old version the green

00:11:43,040 --> 00:11:47,440
dotted curve is the new version for

00:11:46,000 --> 00:11:48,079
auric deployment you have a gradual

00:11:47,440 --> 00:11:49,600
degrees

00:11:48,079 --> 00:11:51,519
of the old version an increase of the

00:11:49,600 --> 00:11:53,120
newer version fixed deployment you have

00:11:51,519 --> 00:11:56,240
a kind of a little gap

00:11:53,120 --> 00:11:58,240
where nothing is running

00:11:56,240 --> 00:11:59,680
blue green release is you have a certain

00:11:58,240 --> 00:12:01,360
time where both versions are running and

00:11:59,680 --> 00:12:04,560
this is also important to note

00:12:01,360 --> 00:12:06,480
that uh for this case you need

00:12:04,560 --> 00:12:08,079
twice of the capacity for your

00:12:06,480 --> 00:12:09,839
application which means

00:12:08,079 --> 00:12:11,200
your cluster must be large enough that

00:12:09,839 --> 00:12:14,720
your application can

00:12:11,200 --> 00:12:17,519
run in two copies which can be on

00:12:14,720 --> 00:12:18,399
an issue or maybe not for canary release

00:12:17,519 --> 00:12:20,959
use the kind of

00:12:18,399 --> 00:12:22,000
a rolling update which which should just

00:12:20,959 --> 00:12:24,079
stop in the middle

00:12:22,000 --> 00:12:26,000
like that and then at the end you can

00:12:24,079 --> 00:12:28,079
decide what you want to do

00:12:26,000 --> 00:12:30,560
okay this is all about the declarative

00:12:28,079 --> 00:12:30,560
deployment

00:12:30,959 --> 00:12:36,480
let's move on to the structural patterns

00:12:34,000 --> 00:12:37,519
for structural patterns is structure

00:12:36,480 --> 00:12:39,680
patterns actually

00:12:37,519 --> 00:12:40,880
are something about how you can compose

00:12:39,680 --> 00:12:43,040
your application

00:12:40,880 --> 00:12:45,440
and can use the primitives of kubernetes

00:12:43,040 --> 00:12:46,959
to create different kinds of application

00:12:45,440 --> 00:12:48,959
we will look in the most famous one

00:12:46,959 --> 00:12:52,560
which is the sitecar

00:12:48,959 --> 00:12:56,720
and the sidecar container really is

00:12:52,560 --> 00:12:59,120
about how you can add functionality

00:12:56,720 --> 00:13:01,839
to an application without actually

00:12:59,120 --> 00:13:04,880
changing the application itself

00:13:01,839 --> 00:13:06,000
this is all about runtime collaboration

00:13:04,880 --> 00:13:08,079
of containers

00:13:06,000 --> 00:13:09,680
we have already seen in one of the

00:13:08,079 --> 00:13:11,680
slides at the beginning

00:13:09,680 --> 00:13:12,800
that in a pot you can have multiple

00:13:11,680 --> 00:13:14,959
containers

00:13:12,800 --> 00:13:16,160
in these pots these containers can

00:13:14,959 --> 00:13:18,560
communicate with

00:13:16,160 --> 00:13:19,279
each other either via the network so we

00:13:18,560 --> 00:13:22,399
are localhost

00:13:19,279 --> 00:13:24,880
in a certain port or if set up

00:13:22,399 --> 00:13:26,880
probably with a shared volume so that

00:13:24,880 --> 00:13:28,000
one container can write on this volume

00:13:26,880 --> 00:13:29,200
and the other one can read it for

00:13:28,000 --> 00:13:31,040
example

00:13:29,200 --> 00:13:33,360
it's a little bit similar to aop in the

00:13:31,040 --> 00:13:36,399
programming world where you have

00:13:33,360 --> 00:13:39,279
also this aspect-oriented programming

00:13:36,399 --> 00:13:42,079
and add autonomous concerns to your

00:13:39,279 --> 00:13:43,680
application like logging or security

00:13:42,079 --> 00:13:45,040
and as i mentioned it's all about

00:13:43,680 --> 00:13:46,720
separation of concerns so you can

00:13:45,040 --> 00:13:49,920
compose your stuff and

00:13:46,720 --> 00:13:53,360
and all the in this example for here

00:13:49,920 --> 00:13:55,279
you see that the main container

00:13:53,360 --> 00:13:56,720
is an http server which serves certain

00:13:55,279 --> 00:13:58,800
data from a disk

00:13:56,720 --> 00:14:00,160
and all the requests that come in just

00:13:58,800 --> 00:14:02,000
serve the disk so the main container

00:14:00,160 --> 00:14:04,000
just this is kind of a static http

00:14:02,000 --> 00:14:05,920
server but then you can add a cycle

00:14:04,000 --> 00:14:08,399
container which periodically pulls some

00:14:05,920 --> 00:14:10,480
external storage like a git repository

00:14:08,399 --> 00:14:13,120
and if there's any change update the

00:14:10,480 --> 00:14:15,040
local data so that the next request

00:14:13,120 --> 00:14:17,519
request that comes in for the http

00:14:15,040 --> 00:14:20,240
server gets the updated data

00:14:17,519 --> 00:14:22,480
so with this setup you do not have to

00:14:20,240 --> 00:14:24,880
touch the http server at all

00:14:22,480 --> 00:14:26,800
and can add a new functionality like

00:14:24,880 --> 00:14:28,959
updating when something changes

00:14:26,800 --> 00:14:30,320
directly by adding a sidecar container

00:14:28,959 --> 00:14:32,079
this is a good example how you can

00:14:30,320 --> 00:14:34,240
really enhance your application with

00:14:32,079 --> 00:14:35,760
without really touching it and one of

00:14:34,240 --> 00:14:36,480
the most prominent examples in this

00:14:35,760 --> 00:14:39,040
category

00:14:36,480 --> 00:14:40,959
are really service meshes which actually

00:14:39,040 --> 00:14:42,480
does this so inject some certain

00:14:40,959 --> 00:14:43,680
side containers into your main

00:14:42,480 --> 00:14:44,639
application and then add new

00:14:43,680 --> 00:14:47,440
functionality like

00:14:44,639 --> 00:14:48,959
tracing and other things circuit

00:14:47,440 --> 00:14:51,360
building and so on

00:14:48,959 --> 00:14:54,160
without actually really any change to

00:14:51,360 --> 00:14:54,160
your main container

00:14:54,240 --> 00:14:57,360
some let's have a quick look into two

00:14:56,560 --> 00:15:00,160
variations

00:14:57,360 --> 00:15:00,880
or specific variations of the site

00:15:00,160 --> 00:15:02,560
container

00:15:00,880 --> 00:15:05,040
so first of all the adapter this is all

00:15:02,560 --> 00:15:07,839
about how you can decouple

00:15:05,040 --> 00:15:09,120
the access to a container from the

00:15:07,839 --> 00:15:12,560
outside world

00:15:09,120 --> 00:15:13,839
which means that you can add adapters

00:15:12,560 --> 00:15:15,839
depending on the needs

00:15:13,839 --> 00:15:17,839
requirements for certain systems here in

00:15:15,839 --> 00:15:19,600
this example we have again our main

00:15:17,839 --> 00:15:21,199
container application let's assume

00:15:19,600 --> 00:15:23,199
you have certain metrics which you want

00:15:21,199 --> 00:15:24,720
to monitor these metrics are written

00:15:23,199 --> 00:15:26,079
down into a file system in kind of a

00:15:24,720 --> 00:15:27,760
proprietary format

00:15:26,079 --> 00:15:29,279
but you have a system like prometheus

00:15:27,760 --> 00:15:32,320
which wants to get

00:15:29,279 --> 00:15:34,320
query this metrics and

00:15:32,320 --> 00:15:35,680
for this you just add kind of an adapter

00:15:34,320 --> 00:15:39,519
which on the one

00:15:35,680 --> 00:15:42,320
side reads the matrix now the other side

00:15:39,519 --> 00:15:45,279
exposes these metrics to prometheus in

00:15:42,320 --> 00:15:47,440
the prometheus specific format

00:15:45,279 --> 00:15:48,959
and so the main application doesn't know

00:15:47,440 --> 00:15:50,480
anything about prompters but you can

00:15:48,959 --> 00:15:51,199
still connect to prometheus for

00:15:50,480 --> 00:15:53,120
monitoring

00:15:51,199 --> 00:15:55,279
and if you change your monitoring system

00:15:53,120 --> 00:15:57,360
like let's say you switch to

00:15:55,279 --> 00:15:59,360
nagios then you just exchange the

00:15:57,360 --> 00:16:01,279
adapter and still your application does

00:15:59,360 --> 00:16:03,040
not need anything to know about this

00:16:01,279 --> 00:16:04,720
this is about how you expose data in a

00:16:03,040 --> 00:16:06,000
uniform fashion to the outside

00:16:04,720 --> 00:16:08,240
and the ambassador is kind of the

00:16:06,000 --> 00:16:10,399
opposite it's just how to decouple

00:16:08,240 --> 00:16:11,279
the container access to the outside

00:16:10,399 --> 00:16:13,360
world so it

00:16:11,279 --> 00:16:14,320
describes how your container accesses

00:16:13,360 --> 00:16:17,040
the outside world

00:16:14,320 --> 00:16:18,480
from inside an example could be a cache

00:16:17,040 --> 00:16:20,560
which you have locally either

00:16:18,480 --> 00:16:22,000
or you want to have a distributed cache

00:16:20,560 --> 00:16:25,040
and depending on your needs

00:16:22,000 --> 00:16:26,000
you just offer kind of a unique api on

00:16:25,040 --> 00:16:28,639
localhost

00:16:26,000 --> 00:16:30,720
but exchange the sitecar container

00:16:28,639 --> 00:16:32,639
depending on their context

00:16:30,720 --> 00:16:34,000
so here you have in the upper picture

00:16:32,639 --> 00:16:35,600
you have a memcached

00:16:34,000 --> 00:16:37,199
which is running locally your main

00:16:35,600 --> 00:16:38,959
application just communicates overload

00:16:37,199 --> 00:16:40,399
close over certain port

00:16:38,959 --> 00:16:43,199
and does not really know what's happened

00:16:40,399 --> 00:16:43,199
behind this port

00:16:44,320 --> 00:16:48,800
next now let's jump

00:16:47,360 --> 00:16:50,720
now let's jump to the next category

00:16:48,800 --> 00:16:52,639
which is about configuration

00:16:50,720 --> 00:16:54,160
and we have already very good direct

00:16:52,639 --> 00:16:55,839
support for configuration within

00:16:54,160 --> 00:16:56,399
kubernetes for application developers

00:16:55,839 --> 00:16:59,279
you can use

00:16:56,399 --> 00:17:00,959
config maps and secrets but also

00:16:59,279 --> 00:17:02,079
environment variables to configure your

00:17:00,959 --> 00:17:04,160
applications

00:17:02,079 --> 00:17:06,000
sometimes you need a little bit more if

00:17:04,160 --> 00:17:06,640
you have a complex scenario and i want

00:17:06,000 --> 00:17:09,280
to show you

00:17:06,640 --> 00:17:11,120
now in this example our configuration

00:17:09,280 --> 00:17:13,199
template works

00:17:11,120 --> 00:17:15,439
this is also a pattern and it's here

00:17:13,199 --> 00:17:18,720
it's about how you can manage large and

00:17:15,439 --> 00:17:21,839
complex similar configuration data

00:17:18,720 --> 00:17:23,679
similar in the sense that you might have

00:17:21,839 --> 00:17:25,199
deployment scenarios where you have

00:17:23,679 --> 00:17:28,720
different

00:17:25,199 --> 00:17:30,160
stages like a development environment

00:17:28,720 --> 00:17:31,520
like a staging environment like a

00:17:30,160 --> 00:17:32,960
production environment

00:17:31,520 --> 00:17:34,720
and all of this has kind of similar

00:17:32,960 --> 00:17:36,640
configuration except for

00:17:34,720 --> 00:17:38,160
certain connection parameters for

00:17:36,640 --> 00:17:41,120
example like a database

00:17:38,160 --> 00:17:42,320
so you have the development environment

00:17:41,120 --> 00:17:43,120
needs to connect to the development

00:17:42,320 --> 00:17:44,400
database

00:17:43,120 --> 00:17:46,720
the production environment to the

00:17:44,400 --> 00:17:48,400
production database and

00:17:46,720 --> 00:17:49,760
of course you can copy over all this

00:17:48,400 --> 00:17:51,440
into your applications but

00:17:49,760 --> 00:17:53,120
if you do it naively you have to create

00:17:51,440 --> 00:17:54,160
different images container images for

00:17:53,120 --> 00:17:57,039
all of these

00:17:54,160 --> 00:17:58,960
applications which is not very very nice

00:17:57,039 --> 00:18:00,880
but

00:17:58,960 --> 00:18:02,720
this pattern actually tries to solve

00:18:00,880 --> 00:18:04,320
this problem by introducing an init

00:18:02,720 --> 00:18:05,039
container in that container is something

00:18:04,320 --> 00:18:08,240
which starts

00:18:05,039 --> 00:18:09,440
before your main container starts and

00:18:08,240 --> 00:18:11,360
let's assume this in the container

00:18:09,440 --> 00:18:14,160
contains a template processor

00:18:11,360 --> 00:18:16,080
you have in your image you have a

00:18:14,160 --> 00:18:18,640
configuration template which means

00:18:16,080 --> 00:18:19,200
all the shared parts are this are given

00:18:18,640 --> 00:18:20,960
there

00:18:19,200 --> 00:18:23,280
but you have placeholder for the

00:18:20,960 --> 00:18:24,320
variables like the database connection

00:18:23,280 --> 00:18:26,880
url

00:18:24,320 --> 00:18:27,360
and this template processor then would

00:18:26,880 --> 00:18:30,080
pick up

00:18:27,360 --> 00:18:30,880
all these configuration parameters from

00:18:30,080 --> 00:18:34,000
a config map

00:18:30,880 --> 00:18:35,679
for example and then puts it

00:18:34,000 --> 00:18:38,640
into the template processor the temple

00:18:35,679 --> 00:18:41,039
processor also picks up

00:18:38,640 --> 00:18:42,160
the template and then the final

00:18:41,039 --> 00:18:42,880
configuration is stored in the shared

00:18:42,160 --> 00:18:44,960
volume

00:18:42,880 --> 00:18:46,400
and what the main containers just does

00:18:44,960 --> 00:18:47,360
it picks up this already processed

00:18:46,400 --> 00:18:50,160
configuration data

00:18:47,360 --> 00:18:50,960
and serves it to or use it for for

00:18:50,160 --> 00:18:53,679
itself for here

00:18:50,960 --> 00:18:55,120
a good example could be jpos or whitefly

00:18:53,679 --> 00:18:58,160
which

00:18:55,120 --> 00:19:00,080
is in java e application server um

00:18:58,160 --> 00:19:01,200
and here you see it's a graphically so

00:19:00,080 --> 00:19:02,799
you have a template processor you have

00:19:01,200 --> 00:19:05,200
the configuration templates

00:19:02,799 --> 00:19:06,559
the temperature would mount your config

00:19:05,200 --> 00:19:08,080
map as a volume

00:19:06,559 --> 00:19:10,480
takes the templates which are coming

00:19:08,080 --> 00:19:12,720
directly from the init containers image

00:19:10,480 --> 00:19:13,840
processes it creates the processed

00:19:12,720 --> 00:19:16,000
images into the

00:19:13,840 --> 00:19:17,840
configuration file your main application

00:19:16,000 --> 00:19:18,960
charts just mount and reads the

00:19:17,840 --> 00:19:20,559
configuration

00:19:18,960 --> 00:19:22,000
and of course the only thing you have to

00:19:20,559 --> 00:19:23,760
change for different environments is

00:19:22,000 --> 00:19:25,039
just different config map volumes for

00:19:23,760 --> 00:19:26,960
different environments so

00:19:25,039 --> 00:19:28,880
you would put into the into the copic

00:19:26,960 --> 00:19:30,000
map only those parts which are different

00:19:28,880 --> 00:19:32,240
for these environments

00:19:30,000 --> 00:19:33,600
here's how it looks like in the resource

00:19:32,240 --> 00:19:34,480
descriptor so you would have here a

00:19:33,600 --> 00:19:36,400
deployment

00:19:34,480 --> 00:19:37,520
and you see the inner container just

00:19:36,400 --> 00:19:40,880
picks up a

00:19:37,520 --> 00:19:43,360
kind of a prepared

00:19:40,880 --> 00:19:44,720
image which contains the templates the

00:19:43,360 --> 00:19:46,960
parameters themselves come from a

00:19:44,720 --> 00:19:48,799
conflict map named wildfly parameters

00:19:46,960 --> 00:19:50,880
and the config itself is written into an

00:19:48,799 --> 00:19:53,440
empty directory which then later on

00:19:50,880 --> 00:19:55,120
is mounted by the main container like

00:19:53,440 --> 00:19:58,000
here the white fly

00:19:55,120 --> 00:19:59,120
and uh just re uses the configured

00:19:58,000 --> 00:20:02,480
parameters

00:19:59,120 --> 00:20:04,880
we have good example for this in the the

00:20:02,480 --> 00:20:06,320
for the source of the book has already

00:20:04,880 --> 00:20:08,880
prepared images which you can directly

00:20:06,320 --> 00:20:10,480
use for this kind of processing

00:20:08,880 --> 00:20:11,919
next let's talk about behavioral

00:20:10,480 --> 00:20:14,159
patterns

00:20:11,919 --> 00:20:16,159
here we are talking about patterns that

00:20:14,159 --> 00:20:17,600
are describing the characteristics of an

00:20:16,159 --> 00:20:20,320
application

00:20:17,600 --> 00:20:22,000
like a patch job or stateful services

00:20:20,320 --> 00:20:24,240
but also how

00:20:22,000 --> 00:20:26,000
servers can find each other via services

00:20:24,240 --> 00:20:27,360
coverage or how services can be exposed

00:20:26,000 --> 00:20:29,440
to the outside

00:20:27,360 --> 00:20:31,280
and this is what we are describing now

00:20:29,440 --> 00:20:33,360
with the service discovery pattern

00:20:31,280 --> 00:20:34,880
and this pattern is all about how you

00:20:33,360 --> 00:20:36,799
discover and use

00:20:34,880 --> 00:20:38,880
services with kubernetes different

00:20:36,799 --> 00:20:41,280
variations

00:20:38,880 --> 00:20:43,919
first of all let's have a quick look to

00:20:41,280 --> 00:20:46,480
the outside to the non-kubernetes world

00:20:43,919 --> 00:20:48,480
and how service discovery works there so

00:20:46,480 --> 00:20:50,320
typically you have a producer so this is

00:20:48,480 --> 00:20:53,520
the one who offers you a service

00:20:50,320 --> 00:20:55,840
the producers registers its service

00:20:53,520 --> 00:20:56,640
in the service registry like console for

00:20:55,840 --> 00:20:58,400
example

00:20:56,640 --> 00:21:01,280
and then you have a consumer who needs

00:20:58,400 --> 00:21:03,039
to do an active lookup to the registry

00:21:01,280 --> 00:21:04,640
for example the name gets back a

00:21:03,039 --> 00:21:06,080
reference to this to the service and

00:21:04,640 --> 00:21:07,440
then invokes the service in the third

00:21:06,080 --> 00:21:09,280
step

00:21:07,440 --> 00:21:10,960
sometimes there are hn involved which

00:21:09,280 --> 00:21:11,600
are just which you have to connect to

00:21:10,960 --> 00:21:14,960
your

00:21:11,600 --> 00:21:16,400
services with kubernetes it's a little

00:21:14,960 --> 00:21:19,039
bit different because the service

00:21:16,400 --> 00:21:20,880
register is really part of qrs itself

00:21:19,039 --> 00:21:23,840
it's all that the consumer already has a

00:21:20,880 --> 00:21:25,360
name as for the lookup and this lookup

00:21:23,840 --> 00:21:27,360
happens behind the scenes so this is

00:21:25,360 --> 00:21:29,440
done by kind of a proxy this is

00:21:27,360 --> 00:21:30,400
either a reproxy or kind of a virtual

00:21:29,440 --> 00:21:32,159
proxy

00:21:30,400 --> 00:21:33,840
and you can imagine this is this the

00:21:32,159 --> 00:21:36,880
kinetic the kubernetes service

00:21:33,840 --> 00:21:40,159
which uh is used here and uh

00:21:36,880 --> 00:21:42,840
so uh in that sense the proxy also

00:21:40,159 --> 00:21:44,080
selects the ports and evoke the service

00:21:42,840 --> 00:21:46,400
afterwards

00:21:44,080 --> 00:21:47,200
now let's have a look into the different

00:21:46,400 --> 00:21:48,880
kind of

00:21:47,200 --> 00:21:50,559
discoveries so first of all we have

00:21:48,880 --> 00:21:53,120
internal services covering

00:21:50,559 --> 00:21:54,880
which is used by services or by

00:21:53,120 --> 00:21:56,159
application ports which are running

00:21:54,880 --> 00:21:58,159
within the cluster

00:21:56,159 --> 00:21:59,200
so every application has kind of

00:21:58,159 --> 00:22:00,799
dependencies

00:21:59,200 --> 00:22:02,320
and these dependencies can be either

00:22:00,799 --> 00:22:03,120
within the cluster or outside the

00:22:02,320 --> 00:22:05,679
cluster

00:22:03,120 --> 00:22:07,440
if they are within the cluster you can

00:22:05,679 --> 00:22:08,960
can just call your dependencies via a

00:22:07,440 --> 00:22:10,480
kubernetes service

00:22:08,960 --> 00:22:12,240
and this service is kind of a mini load

00:22:10,480 --> 00:22:14,799
balancer for your pots

00:22:12,240 --> 00:22:15,760
and these pots are selected by label

00:22:14,799 --> 00:22:17,919
selectors

00:22:15,760 --> 00:22:18,960
you can have multiple service purpose

00:22:17,919 --> 00:22:20,880
there's also kind

00:22:18,960 --> 00:22:22,640
you can configure a session affinity on

00:22:20,880 --> 00:22:24,240
our p address of the client port

00:22:22,640 --> 00:22:26,720
so that the client port with certain

00:22:24,240 --> 00:22:30,000
appear address always lands at the other

00:22:26,720 --> 00:22:31,919
fixed port and

00:22:30,000 --> 00:22:33,440
readiness probes are really used to

00:22:31,919 --> 00:22:35,039
indicate that the service is ready so

00:22:33,440 --> 00:22:37,120
your if you call a service

00:22:35,039 --> 00:22:38,960
you only get through if the to you only

00:22:37,120 --> 00:22:40,720
get to a port that is ready

00:22:38,960 --> 00:22:42,320
and you get involved with a peer address

00:22:40,720 --> 00:22:43,679
for each service so you do an internal

00:22:42,320 --> 00:22:46,320
lookup via dns

00:22:43,679 --> 00:22:48,880
and then get back the internal return ip

00:22:46,320 --> 00:22:52,000
address of that service

00:22:48,880 --> 00:22:54,159
if you have to access services outside

00:22:52,000 --> 00:22:56,000
the cluster so like an external system

00:22:54,159 --> 00:22:58,559
you can do this also with the kubernetes

00:22:56,000 --> 00:23:00,720
service but in this case you don't

00:22:58,559 --> 00:23:02,000
enter a label selector into the service

00:23:00,720 --> 00:23:04,640
but just

00:23:02,000 --> 00:23:05,520
either create so called an endpoints

00:23:04,640 --> 00:23:07,679
resource

00:23:05,520 --> 00:23:09,760
which has a list of ip addresses that

00:23:07,679 --> 00:23:11,919
should be used and this endpoint

00:23:09,760 --> 00:23:14,000
has the same name as a service so in

00:23:11,919 --> 00:23:15,120
this case if a request comes from a port

00:23:14,000 --> 00:23:18,559
to this service

00:23:15,120 --> 00:23:21,280
then the endpoints are

00:23:18,559 --> 00:23:22,799
consulted and then just delegated to the

00:23:21,280 --> 00:23:25,280
external system

00:23:22,799 --> 00:23:27,760
or you use a service of type external

00:23:25,280 --> 00:23:31,039
name and there you can just put in a

00:23:27,760 --> 00:23:32,640
external dns name which then is used

00:23:31,039 --> 00:23:34,159
all the time if you access the server so

00:23:32,640 --> 00:23:37,760
this service is then kind of a proxy for

00:23:34,159 --> 00:23:39,600
this external name

00:23:37,760 --> 00:23:42,320
so this was all about how your internal

00:23:39,600 --> 00:23:44,080
ports can access services but of course

00:23:42,320 --> 00:23:46,320
sometimes you want to expose certain

00:23:44,080 --> 00:23:48,080
services to the outside so the user

00:23:46,320 --> 00:23:49,120
outside of the cluster can access your

00:23:48,080 --> 00:23:50,640
service

00:23:49,120 --> 00:23:52,880
and here you have different

00:23:50,640 --> 00:23:54,640
possibilities the simplest one to

00:23:52,880 --> 00:23:56,640
configure is the node port

00:23:54,640 --> 00:23:57,840
you just add a type notebook to your

00:23:56,640 --> 00:24:00,159
service and then

00:23:57,840 --> 00:24:01,600
every node in your cluster exposes this

00:24:00,159 --> 00:24:03,679
port to the outside world

00:24:01,600 --> 00:24:04,640
and directs you to this service and the

00:24:03,679 --> 00:24:08,559
service again

00:24:04,640 --> 00:24:08,559
just delegates to the ports

00:24:08,880 --> 00:24:12,720
yeah the benefit is of course it's easy

00:24:10,400 --> 00:24:15,760
to configure other the the

00:24:12,720 --> 00:24:16,559
drawback is that if of course you need

00:24:15,760 --> 00:24:19,039
to know

00:24:16,559 --> 00:24:20,159
that the port is available for for you

00:24:19,039 --> 00:24:22,080
to expose so you

00:24:20,159 --> 00:24:23,600
have to manage certain port ranges for

00:24:22,080 --> 00:24:25,200
your services which you want to expose

00:24:23,600 --> 00:24:26,880
on your cluster this is

00:24:25,200 --> 00:24:28,400
true for every service in the cluster

00:24:26,880 --> 00:24:31,600
that you want to expose over the

00:24:28,400 --> 00:24:34,480
node port and also this port is not

00:24:31,600 --> 00:24:35,840
always stable so sometimes typically you

00:24:34,480 --> 00:24:38,000
will get a random port

00:24:35,840 --> 00:24:38,880
you can also pin this port of course but

00:24:38,000 --> 00:24:41,760
this

00:24:38,880 --> 00:24:43,200
requires tons of management for you and

00:24:41,760 --> 00:24:44,799
also for a user running

00:24:43,200 --> 00:24:46,320
for example accessing your service via

00:24:44,799 --> 00:24:47,200
web browser it's not easy it's not so

00:24:46,320 --> 00:24:50,320
nice to

00:24:47,200 --> 00:24:51,200
to have to specify a port there then you

00:24:50,320 --> 00:24:53,200
have the other

00:24:51,200 --> 00:24:54,640
uh two possibilities to use a load

00:24:53,200 --> 00:24:56,240
balancer or an ingress

00:24:54,640 --> 00:24:57,840
for load balancer this is kind of from

00:24:56,240 --> 00:24:59,919
service offered by your

00:24:57,840 --> 00:25:00,960
kubernetes provider or typically also a

00:24:59,919 --> 00:25:04,400
cloud provider

00:25:00,960 --> 00:25:06,000
and this is different from provider to

00:25:04,400 --> 00:25:07,840
provider so load balancer

00:25:06,000 --> 00:25:09,200
is something which is outside of the

00:25:07,840 --> 00:25:11,039
cluster image out of the cluster they

00:25:09,200 --> 00:25:12,880
have different characteristics also

00:25:11,039 --> 00:25:14,400
but what you do for your servers you can

00:25:12,880 --> 00:25:16,080
define the time log balancer

00:25:14,400 --> 00:25:18,960
and then you have a kind of a one-to-one

00:25:16,080 --> 00:25:21,520
relationship from a load balancer

00:25:18,960 --> 00:25:23,520
ip2 your service there the alternative

00:25:21,520 --> 00:25:26,000
is to use an ingress which is a kind of

00:25:23,520 --> 00:25:27,600
an own resource entity which is managed

00:25:26,000 --> 00:25:29,440
within the kubernetes cluster you have

00:25:27,600 --> 00:25:31,120
ingress controller behind that and this

00:25:29,440 --> 00:25:32,480
increased controller also exposes the

00:25:31,120 --> 00:25:35,120
increase to the outside

00:25:32,480 --> 00:25:36,640
you can also dispatch to multiple

00:25:35,120 --> 00:25:40,559
services this is not

00:25:36,640 --> 00:25:42,400
not so easy with a load balancer

00:25:40,559 --> 00:25:43,600
here is the example how you specified

00:25:42,400 --> 00:25:46,080
ingress

00:25:43,600 --> 00:25:47,200
as as you see you can specify different

00:25:46,080 --> 00:25:49,600
context paths

00:25:47,200 --> 00:25:52,000
which is uh nice so that you can really

00:25:49,600 --> 00:25:54,159
dispatch to different services

00:25:52,000 --> 00:25:55,520
so this is all what i have about the

00:25:54,159 --> 00:25:56,000
service discovery what you see is

00:25:55,520 --> 00:25:58,320
actually

00:25:56,000 --> 00:26:00,159
a short summary how you specify this on

00:25:58,320 --> 00:26:01,679
the service so there are different types

00:26:00,159 --> 00:26:03,600
and different

00:26:01,679 --> 00:26:04,799
other specifications which you can use

00:26:03,600 --> 00:26:07,279
and which web to these different

00:26:04,799 --> 00:26:07,279
concepts

00:26:07,520 --> 00:26:11,200
so finally let's have a look into the

00:26:09,919 --> 00:26:12,880
advanced petals

00:26:11,200 --> 00:26:15,120
and these are patterns which are do not

00:26:12,880 --> 00:26:16,880
fit really well in the other categories

00:26:15,120 --> 00:26:18,640
but they are described more advanced

00:26:16,880 --> 00:26:19,200
concepts like elastic scale which is

00:26:18,640 --> 00:26:21,200
about

00:26:19,200 --> 00:26:23,360
horizontal ports and vertical put

00:26:21,200 --> 00:26:26,799
autoscaler based on current

00:26:23,360 --> 00:26:27,760
resource usage and also about image

00:26:26,799 --> 00:26:29,760
builder which is

00:26:27,760 --> 00:26:31,039
allows you to create container images

00:26:29,760 --> 00:26:33,120
within a cluster

00:26:31,039 --> 00:26:34,720
but for this talk we i've selected the

00:26:33,120 --> 00:26:37,039
controller operator which are very

00:26:34,720 --> 00:26:38,880
important concepts of kubernetes itself

00:26:37,039 --> 00:26:40,799
let's start with the controller the

00:26:38,880 --> 00:26:42,799
controller pattern is all about how you

00:26:40,799 --> 00:26:43,679
get from the current state to the target

00:26:42,799 --> 00:26:45,520
stack

00:26:43,679 --> 00:26:47,760
i already mentioned that kubernetes is

00:26:45,520 --> 00:26:51,200
all about state reconsolidation

00:26:47,760 --> 00:26:52,720
which means that that you declare your

00:26:51,200 --> 00:26:53,840
state what you want to do and it's up to

00:26:52,720 --> 00:26:55,840
kubernetes to

00:26:53,840 --> 00:26:57,120
perform certain actions to get to this

00:26:55,840 --> 00:26:59,919
state

00:26:57,120 --> 00:27:01,600
this works that it periodically observes

00:26:59,919 --> 00:27:04,240
the actual state

00:27:01,600 --> 00:27:05,360
and then analyzes the actual state makes

00:27:04,240 --> 00:27:07,039
it diff

00:27:05,360 --> 00:27:08,480
against the target state that you have

00:27:07,039 --> 00:27:10,799
declared in the cluster

00:27:08,480 --> 00:27:11,520
and if there's any difference then it

00:27:10,799 --> 00:27:14,480
acts

00:27:11,520 --> 00:27:16,720
on uh in that form that it tries to

00:27:14,480 --> 00:27:18,320
decrease the gap between the actual and

00:27:16,720 --> 00:27:20,000
the target set and of course ideally

00:27:18,320 --> 00:27:23,120
this gap gets zero so that it's

00:27:20,000 --> 00:27:24,880
that there's no difference anymore um

00:27:23,120 --> 00:27:26,559
yeah so this is how kubernetes works

00:27:24,880 --> 00:27:28,320
itself there are tons of controllers who

00:27:26,559 --> 00:27:29,760
are doing exactly this kind of loop all

00:27:28,320 --> 00:27:32,159
the time

00:27:29,760 --> 00:27:33,600
technically it works that it connects

00:27:32,159 --> 00:27:34,960
the controller connects to the api

00:27:33,600 --> 00:27:37,840
server the control

00:27:34,960 --> 00:27:39,840
controller is kind of in regular

00:27:37,840 --> 00:27:42,640
application running in the background

00:27:39,840 --> 00:27:44,399
and then observe the api server that

00:27:42,640 --> 00:27:46,640
this is by observing events which

00:27:44,399 --> 00:27:49,279
are emitted by the api server if when

00:27:46,640 --> 00:27:51,600
there is a change in the cluster

00:27:49,279 --> 00:27:53,039
depending on these events it analyzes

00:27:51,600 --> 00:27:55,120
whether it needs to act or not

00:27:53,039 --> 00:27:56,880
if there are some action required again

00:27:55,120 --> 00:27:59,520
contacts the api server

00:27:56,880 --> 00:28:00,960
and this api server then works on behalf

00:27:59,520 --> 00:28:02,960
of this action

00:28:00,960 --> 00:28:04,799
talks with the node components creates

00:28:02,960 --> 00:28:07,840
maybe new ports or does

00:28:04,799 --> 00:28:09,840
anything that the controller wants to do

00:28:07,840 --> 00:28:11,440
as mentioned quest safe has a tons of

00:28:09,840 --> 00:28:12,720
controller but you can leverage this

00:28:11,440 --> 00:28:14,960
concept as well for your own

00:28:12,720 --> 00:28:17,200
applications

00:28:14,960 --> 00:28:18,480
here is an example of such a controller

00:28:17,200 --> 00:28:19,840
you can write the controller of course

00:28:18,480 --> 00:28:22,320
in any language

00:28:19,840 --> 00:28:23,919
here we was uh we are using a shell

00:28:22,320 --> 00:28:26,080
script just to demonstrate that you can

00:28:23,919 --> 00:28:27,679
also use shell for that

00:28:26,080 --> 00:28:31,279
what you see here is kind of a curl

00:28:27,679 --> 00:28:32,320
which watches for events so it creates

00:28:31,279 --> 00:28:35,039
the

00:28:32,320 --> 00:28:36,720
api server and then it reads the event

00:28:35,039 --> 00:28:38,080
for every event it extracts the event

00:28:36,720 --> 00:28:39,200
and checks whether the event has been

00:28:38,080 --> 00:28:42,960
modified

00:28:39,200 --> 00:28:46,000
and for example it watches for certain

00:28:42,960 --> 00:28:47,760
config maps by name and if such such a

00:28:46,000 --> 00:28:49,760
conflict map has been modified

00:28:47,760 --> 00:28:51,919
it takes an action and this action in

00:28:49,760 --> 00:28:53,679
this example which is also part of the

00:28:51,919 --> 00:28:55,679
books example which you can download

00:28:53,679 --> 00:28:57,279
is to restart a port which has a certain

00:28:55,679 --> 00:28:59,520
label

00:28:57,279 --> 00:29:01,760
that points to this conflict map so with

00:28:59,520 --> 00:29:02,000
this simple controller you can implement

00:29:01,760 --> 00:29:03,840
a

00:29:02,000 --> 00:29:05,919
functionality which means to restart

00:29:03,840 --> 00:29:08,240
your ports as soon as this configuration

00:29:05,919 --> 00:29:10,840
changes

00:29:08,240 --> 00:29:12,240
coming now to our last pattern the

00:29:10,840 --> 00:29:14,399
operator

00:29:12,240 --> 00:29:16,559
the operator is all about how you can

00:29:14,399 --> 00:29:18,000
encapsulate operational knowledge into

00:29:16,559 --> 00:29:19,760
an executable software

00:29:18,000 --> 00:29:21,520
it's a little it's a little bit similar

00:29:19,760 --> 00:29:23,440
to the controller and in fact it is

00:29:21,520 --> 00:29:25,679
based on the controller

00:29:23,440 --> 00:29:27,679
so here's a definition of what this an

00:29:25,679 --> 00:29:28,559
operator is so first of all we have this

00:29:27,679 --> 00:29:30,799
very nice

00:29:28,559 --> 00:29:31,600
quote from jimmy zielinski which really

00:29:30,799 --> 00:29:34,480
i think

00:29:31,600 --> 00:29:36,559
brings it to the point an operator is a

00:29:34,480 --> 00:29:38,399
community controller so it's

00:29:36,559 --> 00:29:40,480
on top of our controller but it

00:29:38,399 --> 00:29:42,080
understands two domains one is the

00:29:40,480 --> 00:29:44,240
kubernetes domain itself

00:29:42,080 --> 00:29:45,919
like a controller does but also

00:29:44,240 --> 00:29:48,480
something else and this on

00:29:45,919 --> 00:29:50,000
by combining this knowledge between the

00:29:48,480 --> 00:29:51,679
co

00:29:50,000 --> 00:29:54,159
between kubernetes and this custom

00:29:51,679 --> 00:29:56,159
domain knowledge it can automate tasks

00:29:54,159 --> 00:29:56,559
the same way like a human operator would

00:29:56,159 --> 00:29:58,080
do

00:29:56,559 --> 00:29:59,840
when it would have to operate the

00:29:58,080 --> 00:30:01,360
software

00:29:59,840 --> 00:30:03,440
there is another definition which we

00:30:01,360 --> 00:30:06,000
also like quite a bit because it's very

00:30:03,440 --> 00:30:08,080
simple maybe it's too simplistic but

00:30:06,000 --> 00:30:09,600
it depends but actually you also see an

00:30:08,080 --> 00:30:12,000
operator often

00:30:09,600 --> 00:30:13,520
as in controller plus something a new

00:30:12,000 --> 00:30:15,039
concept which is called a custom

00:30:13,520 --> 00:30:17,840
resource definition

00:30:15,039 --> 00:30:18,559
and a custom resource definition or crd

00:30:17,840 --> 00:30:20,240
in short

00:30:18,559 --> 00:30:21,679
is something how you can extend

00:30:20,240 --> 00:30:24,320
preparedness with your own

00:30:21,679 --> 00:30:25,840
types and your own resource types so

00:30:24,320 --> 00:30:28,080
here you see an example of

00:30:25,840 --> 00:30:30,480
humanities resource definition which

00:30:28,080 --> 00:30:31,600
introduces a new type which is called

00:30:30,480 --> 00:30:33,360
config voucher

00:30:31,600 --> 00:30:35,039
and as soon as you have applied this

00:30:33,360 --> 00:30:37,600
custom resource definition

00:30:35,039 --> 00:30:38,080
to your kubernetes cluster you then can

00:30:37,600 --> 00:30:40,399
use

00:30:38,080 --> 00:30:41,279
a config watcher resource like in this

00:30:40,399 --> 00:30:43,840
example

00:30:41,279 --> 00:30:44,880
so you can use a config watcher kind of

00:30:43,840 --> 00:30:46,320
config watcher

00:30:44,880 --> 00:30:48,159
and then you have a specific

00:30:46,320 --> 00:30:50,399
specification spec field

00:30:48,159 --> 00:30:51,360
which is very specific to your own

00:30:50,399 --> 00:30:53,679
resource

00:30:51,360 --> 00:30:54,880
and this resource encapsulates the your

00:30:53,679 --> 00:30:57,200
domain knowledge

00:30:54,880 --> 00:30:59,039
so for this example which is based on

00:30:57,200 --> 00:30:59,840
the controller example that we just have

00:30:59,039 --> 00:31:01,919
seen

00:30:59,840 --> 00:31:04,159
it's about our operator running the

00:31:01,919 --> 00:31:05,679
background watching this custom resource

00:31:04,159 --> 00:31:07,919
is as soon as it sees

00:31:05,679 --> 00:31:09,279
such a custom resource it knows it has

00:31:07,919 --> 00:31:12,159
to watch the config map

00:31:09,279 --> 00:31:14,080
with the name web app config and then as

00:31:12,159 --> 00:31:16,240
soon as this config map changes

00:31:14,080 --> 00:31:19,039
restart all ports which match this

00:31:16,240 --> 00:31:21,600
selector here

00:31:19,039 --> 00:31:23,200
okay okay so we can now have now seen

00:31:21,600 --> 00:31:25,440
controllers and operators

00:31:23,200 --> 00:31:26,640
and how do they compare to each other

00:31:25,440 --> 00:31:28,799
this is a kind of also

00:31:26,640 --> 00:31:30,720
kind of a one view on how you can

00:31:28,799 --> 00:31:32,480
categorize controllers operators

00:31:30,720 --> 00:31:34,159
this is based on flexibility and

00:31:32,480 --> 00:31:36,159
complexity of this

00:31:34,159 --> 00:31:37,440
so for example controllers which is a

00:31:36,159 --> 00:31:39,679
more

00:31:37,440 --> 00:31:42,159
simpler concept than operators they

00:31:39,679 --> 00:31:46,000
typically operate on standard resources

00:31:42,159 --> 00:31:48,399
like labels or also on config maps

00:31:46,000 --> 00:31:49,200
and other stuff you can configure them

00:31:48,399 --> 00:31:52,240
with

00:31:49,200 --> 00:31:54,320
config maps as well but if you have more

00:31:52,240 --> 00:31:56,480
if you have a higher requirement for

00:31:54,320 --> 00:31:57,279
your domain then you probably move on to

00:31:56,480 --> 00:31:58,640
operators

00:31:57,279 --> 00:32:01,200
that are watching custom resource

00:31:58,640 --> 00:32:03,279
definitions or if you want it even

00:32:01,200 --> 00:32:04,640
have it more complex and more flexible

00:32:03,279 --> 00:32:06,720
you can create an own

00:32:04,640 --> 00:32:08,000
aggregate api which hooks directly to

00:32:06,720 --> 00:32:11,760
the api server

00:32:08,000 --> 00:32:14,240
and that so that you can

00:32:11,760 --> 00:32:17,200
be accessible via the rest api directly

00:32:14,240 --> 00:32:17,200
from the api server

00:32:17,760 --> 00:32:21,039
then there is another classification

00:32:20,080 --> 00:32:22,960
which you can

00:32:21,039 --> 00:32:24,320
put on custom resource definitions

00:32:22,960 --> 00:32:27,120
themselves so

00:32:24,320 --> 00:32:28,720
we distinguish between installation crds

00:32:27,120 --> 00:32:30,480
and applications here these

00:32:28,720 --> 00:32:32,720
installations here these are really

00:32:30,480 --> 00:32:35,679
about how you can operate an application

00:32:32,720 --> 00:32:37,440
like prometheus like kafka cluster like

00:32:35,679 --> 00:32:40,880
anything about which you want to run

00:32:37,440 --> 00:32:43,039
in your kubernetes cluster and how you

00:32:40,880 --> 00:32:44,480
and this installation here these

00:32:43,039 --> 00:32:46,399
describe the installation of the

00:32:44,480 --> 00:32:49,120
application itself it also is

00:32:46,399 --> 00:32:50,640
responsible uh for the update so the

00:32:49,120 --> 00:32:52,559
operator behind the crd

00:32:50,640 --> 00:32:54,480
is responsible for updates and other

00:32:52,559 --> 00:32:55,279
operational tasks like backup and

00:32:54,480 --> 00:32:56,720
restore

00:32:55,279 --> 00:32:59,039
a good example is for example is

00:32:56,720 --> 00:33:01,760
promethois so there is a crd which

00:32:59,039 --> 00:33:05,120
type with kind promethos and this is for

00:33:01,760 --> 00:33:05,120
installing a promethos

00:33:05,200 --> 00:33:10,399
monitoring system for you and all the

00:33:07,600 --> 00:33:12,240
dependent components to that then

00:33:10,399 --> 00:33:13,760
there are the applications here these

00:33:12,240 --> 00:33:15,840
and this is really

00:33:13,760 --> 00:33:17,679
about the application specific concept

00:33:15,840 --> 00:33:20,240
whereas the installation crd

00:33:17,679 --> 00:33:21,679
is really about installing something and

00:33:20,240 --> 00:33:23,360
taking care that it's really

00:33:21,679 --> 00:33:24,960
constantly running the application

00:33:23,360 --> 00:33:28,000
studio is more about insta

00:33:24,960 --> 00:33:29,919
configuring these applications yet

00:33:28,000 --> 00:33:30,559
another example is the service monitor

00:33:29,919 --> 00:33:32,559
which is

00:33:30,559 --> 00:33:35,039
there for registering kubernetes

00:33:32,559 --> 00:33:35,519
services with prometheus so that as soon

00:33:35,039 --> 00:33:38,159
as you

00:33:35,519 --> 00:33:39,120
install a service config sorry service

00:33:38,159 --> 00:33:42,880
monitor

00:33:39,120 --> 00:33:44,720
then your promethos server will monitor

00:33:42,880 --> 00:33:46,640
the service which is referenced within

00:33:44,720 --> 00:33:50,080
the service monitor

00:33:46,640 --> 00:33:52,320
other example could be a kafka topic

00:33:50,080 --> 00:33:53,679
which is also available if you use for

00:33:52,320 --> 00:33:55,279
example the sturenzio

00:33:53,679 --> 00:33:57,519
stream separator and this would

00:33:55,279 --> 00:33:59,360
introduce a kafka topic in your kafka

00:33:57,519 --> 00:34:01,760
cluster

00:33:59,360 --> 00:34:03,039
if you are looking for operators which

00:34:01,760 --> 00:34:05,279
are

00:34:03,039 --> 00:34:06,799
which are there you there the operator

00:34:05,279 --> 00:34:08,879
up is a very good starting point

00:34:06,799 --> 00:34:09,919
it contains a catalog of available

00:34:08,879 --> 00:34:12,320
operators it

00:34:09,919 --> 00:34:14,480
contains instructions how you can

00:34:12,320 --> 00:34:17,359
install these operators in your cluster

00:34:14,480 --> 00:34:19,639
and this catalog is constantly growing

00:34:17,359 --> 00:34:21,839
so i really recommend to go to

00:34:19,639 --> 00:34:24,320
operatedub.io

00:34:21,839 --> 00:34:26,079
if you want to create your own operators

00:34:24,320 --> 00:34:27,839
you have tons of possibilities

00:34:26,079 --> 00:34:29,599
there is you can of course write it in

00:34:27,839 --> 00:34:31,760
any language but

00:34:29,599 --> 00:34:33,440
there are some frameworks which can help

00:34:31,760 --> 00:34:36,560
you to create those

00:34:33,440 --> 00:34:39,679
the most famous one is the operator sdk

00:34:36,560 --> 00:34:41,760
which is also which you can find

00:34:39,679 --> 00:34:45,280
on github and this allows you to create

00:34:41,760 --> 00:34:45,280
operators in the golang language

00:34:45,359 --> 00:34:49,599
so this is all what i have for you thank

00:34:47,839 --> 00:34:51,359
you very much i hope you enjoyed

00:34:49,599 --> 00:34:52,960
the the session you have seen some of

00:34:51,359 --> 00:34:53,280
the operators you'll find more in the

00:34:52,960 --> 00:34:56,720
book

00:34:53,280 --> 00:34:59,920
that you can download um and uh

00:34:56,720 --> 00:35:02,560
yeah i hope and show you the the kubecon

00:34:59,920 --> 00:35:03,440
and hopefully next time we can meet us

00:35:02,560 --> 00:35:08,240
in person again

00:35:03,440 --> 00:35:08,240

YouTube URL: https://www.youtube.com/watch?v=eJmNSYvelSw


