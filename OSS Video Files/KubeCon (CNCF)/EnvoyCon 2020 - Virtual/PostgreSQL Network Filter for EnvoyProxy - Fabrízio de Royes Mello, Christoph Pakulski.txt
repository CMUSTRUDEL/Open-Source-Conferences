Title: PostgreSQL Network Filter for EnvoyProxy - Fabrízio de Royes Mello, Christoph Pakulski
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	PostgreSQL Network Filter for EnvoyProxy - Fabrízio de Royes Mello, Christoph Pakulski

How do you monitor Postgres? What information can you get out of it, and to what degree does this information help to troubleshoot operational issues? What if you want/need to log all the queries? That may bring heavy trafficked databases down. At OnGres we’re obsessed with improving PostgreSQL’s observability. So we worked together with Tetrate folks on an Envoy’s Network Filter extension for PostgreSQL, to provide and extend observability of the traffic inout a cluster infrastructure. This extension is public and open source. You can use it anywhere you use Envoy. It allows you to capture automated metrics and to debug network traffic. This talk will be a technical deep-dive into PostgreSQL’s protocol decoding, Envoy proxy filters and will cover all the capabilities of the tool and its usage and deployment in any environment.
Captions: 
	00:00:01,360 --> 00:00:07,040
all right welcome everyone and uh

00:00:04,319 --> 00:00:08,720
the subject of our talk is uh support

00:00:07,040 --> 00:00:12,160
for postgres protocol

00:00:08,720 --> 00:00:13,759
in in envoy proxy

00:00:12,160 --> 00:00:15,200
next slide please so my name is

00:00:13,759 --> 00:00:16,320
christophe pakulski i'm software

00:00:15,200 --> 00:00:19,920
engineer at tetrad

00:00:16,320 --> 00:00:22,320
and i also contribute to endovoy project

00:00:19,920 --> 00:00:22,960
hello everyone i'm fabrizio de veismelu

00:00:22,320 --> 00:00:25,920
i'm a

00:00:22,960 --> 00:00:27,119
postcards research and developer for

00:00:25,920 --> 00:00:29,359
congress company

00:00:27,119 --> 00:00:30,160
the longest companies means on top of

00:00:29,359 --> 00:00:32,640
postgres

00:00:30,160 --> 00:00:33,760
i'm also a postgres contributor for a

00:00:32,640 --> 00:00:37,040
long time

00:00:33,760 --> 00:00:39,920
and this is my first contribution to my

00:00:37,040 --> 00:00:41,840
project so let's start with uh you know

00:00:39,920 --> 00:00:43,280
for with android proxy this presentation

00:00:41,840 --> 00:00:45,600
will have several parts

00:00:43,280 --> 00:00:46,399
uh so in the first part we will look

00:00:45,600 --> 00:00:48,559
towards

00:00:46,399 --> 00:00:49,440
posgress protocol from envoy point of

00:00:48,559 --> 00:00:51,680
view so

00:00:49,440 --> 00:00:52,559
this is a simple connection model uh at

00:00:51,680 --> 00:00:55,039
the goal

00:00:52,559 --> 00:00:56,640
you know is connecting a client to the

00:00:55,039 --> 00:00:58,079
farm of this of server so

00:00:56,640 --> 00:01:00,000
on the left side we have a typical

00:00:58,079 --> 00:01:02,160
client there's the application

00:01:00,000 --> 00:01:04,640
and it really wants to connect to a

00:01:02,160 --> 00:01:06,720
databases and

00:01:04,640 --> 00:01:09,040
postgres requires a tcp connection

00:01:06,720 --> 00:01:10,799
between the client and the server so

00:01:09,040 --> 00:01:12,240
you know and that's what envoy does if

00:01:10,799 --> 00:01:14,400
you look here if you look at this

00:01:12,240 --> 00:01:18,000
picture it's really simple configuration

00:01:14,400 --> 00:01:19,680
it's just a tcp proxy and it provides

00:01:18,000 --> 00:01:20,799
the connectivity between the client and

00:01:19,680 --> 00:01:24,799
the server

00:01:20,799 --> 00:01:26,960
so we can use uh extensive

00:01:24,799 --> 00:01:28,960
backend features which are provided by

00:01:26,960 --> 00:01:30,640
by envoy so we can do a load balancing

00:01:28,960 --> 00:01:31,439
on the back and we can do a health

00:01:30,640 --> 00:01:33,439
checking

00:01:31,439 --> 00:01:35,680
we can detect that one of the nodes are

00:01:33,439 --> 00:01:36,560
behaving in a really weird way so this

00:01:35,680 --> 00:01:39,680
is something we call

00:01:36,560 --> 00:01:42,240
outlier detector and it works

00:01:39,680 --> 00:01:44,079
so clients we we achieved what do you

00:01:42,240 --> 00:01:46,479
want that we wanted to connect client

00:01:44,079 --> 00:01:47,280
and the server uh you can also get some

00:01:46,479 --> 00:01:50,479
statistics

00:01:47,280 --> 00:01:51,920
uh but on a very gross level so

00:01:50,479 --> 00:01:54,000
you will only see that the client

00:01:51,920 --> 00:01:56,320
connected to a database and and

00:01:54,000 --> 00:01:57,040
that's that's all i you won't be able to

00:01:56,320 --> 00:02:00,399
see

00:01:57,040 --> 00:02:01,680
what was going inside of the of that

00:02:00,399 --> 00:02:04,880
session so

00:02:01,680 --> 00:02:06,159
uh tcp tcp stats will tell you how many

00:02:04,880 --> 00:02:08,000
tcp were open

00:02:06,159 --> 00:02:09,280
tcp sessions were open how many bytes

00:02:08,000 --> 00:02:11,520
were exchanged

00:02:09,280 --> 00:02:13,440
but also an access log with retail that

00:02:11,520 --> 00:02:14,000
you know pretty much describes similar

00:02:13,440 --> 00:02:16,160
things

00:02:14,000 --> 00:02:18,080
so you you know that the client talked

00:02:16,160 --> 00:02:20,080
to database but you really know

00:02:18,080 --> 00:02:23,440
you don't really know what was talking

00:02:20,080 --> 00:02:25,200
about so in order to

00:02:23,440 --> 00:02:27,680
know what was going on inside of the

00:02:25,200 --> 00:02:29,120
session you need one extra component in

00:02:27,680 --> 00:02:32,400
this picture and this is

00:02:29,120 --> 00:02:35,040
uh this is a postgres

00:02:32,400 --> 00:02:36,879
filter uh one thing you have to mention

00:02:35,040 --> 00:02:38,720
right now that in order to achieve all

00:02:36,879 --> 00:02:42,000
these things we're talking about

00:02:38,720 --> 00:02:44,160
postgres filter needs access to a clear

00:02:42,000 --> 00:02:46,480
text protocol so it cannot be

00:02:44,160 --> 00:02:47,920
encrypted we'll talk about later on what

00:02:46,480 --> 00:02:49,280
we do when it's encrypted but when i

00:02:47,920 --> 00:02:52,560
talk about you know this

00:02:49,280 --> 00:02:54,800
assume that it has a clear text

00:02:52,560 --> 00:02:56,560
so from the connectivity point of view

00:02:54,800 --> 00:02:58,800
it's really nothing different so

00:02:56,560 --> 00:02:59,840
client can still connect using tcp to

00:02:58,800 --> 00:03:01,599
the server

00:02:59,840 --> 00:03:03,519
uh and we still use the extensive

00:03:01,599 --> 00:03:05,599
features of android on the back end so

00:03:03,519 --> 00:03:10,239
we can still use the load balancing

00:03:05,599 --> 00:03:12,319
outlier detector health checking

00:03:10,239 --> 00:03:14,319
but now all of the sudden android can

00:03:12,319 --> 00:03:16,239
tell us more about

00:03:14,319 --> 00:03:17,360
what's going on inside of the hpc

00:03:16,239 --> 00:03:19,440
session

00:03:17,360 --> 00:03:21,040
and this happens by introducing that

00:03:19,440 --> 00:03:23,840
extra filter

00:03:21,040 --> 00:03:25,920
which is able to read the packet just

00:03:23,840 --> 00:03:27,760
before sending either to a data

00:03:25,920 --> 00:03:30,000
to the back end or either sent back to

00:03:27,760 --> 00:03:33,840
the client

00:03:30,000 --> 00:03:34,879
so now we it's not only that there is a

00:03:33,840 --> 00:03:36,159
tcp session

00:03:34,879 --> 00:03:37,840
you know which extends between the

00:03:36,159 --> 00:03:39,519
client the server but we can also look

00:03:37,840 --> 00:03:42,080
inside what kind of messages

00:03:39,519 --> 00:03:43,200
are exchanged between those uh the

00:03:42,080 --> 00:03:44,959
client and the server

00:03:43,200 --> 00:03:47,519
so you're able to see how many selects

00:03:44,959 --> 00:03:50,400
there were how many updates and search

00:03:47,519 --> 00:03:51,920
errors so it's not as a one long-lived

00:03:50,400 --> 00:03:54,400
tcp session

00:03:51,920 --> 00:03:56,239
but uh postgres filter will know what

00:03:54,400 --> 00:03:58,000
was going on inside

00:03:56,239 --> 00:04:01,040
so one thing i have to mention here that

00:03:58,000 --> 00:04:03,439
the sequence of posgress filter and tcp

00:04:01,040 --> 00:04:04,959
proxy filter is established every time

00:04:03,439 --> 00:04:05,840
client establish a connection to a

00:04:04,959 --> 00:04:07,519
server

00:04:05,840 --> 00:04:09,200
so like i said it is a long lift and

00:04:07,519 --> 00:04:12,239
when it ends uh

00:04:09,200 --> 00:04:15,840
that two filters are destroyed that

00:04:12,239 --> 00:04:15,840
would be next slide please

00:04:16,079 --> 00:04:20,400
okay so let's see what's going on inside

00:04:18,799 --> 00:04:23,199
so on the tcp level and the

00:04:20,400 --> 00:04:25,759
data delivery they you know tcp

00:04:23,199 --> 00:04:27,280
windowing mechanism and also buffering

00:04:25,759 --> 00:04:29,520
on the network cars they really

00:04:27,280 --> 00:04:31,600
completely not aware what's in

00:04:29,520 --> 00:04:33,199
that their postgres messages pass on top

00:04:31,600 --> 00:04:35,759
of these so

00:04:33,199 --> 00:04:38,240
filter receives just chunks of data and

00:04:35,759 --> 00:04:40,720
it has to make sense of this so

00:04:38,240 --> 00:04:42,160
before we can before the filter can

00:04:40,720 --> 00:04:44,720
start processing it

00:04:42,160 --> 00:04:45,680
it needs to reassemble entire postgres

00:04:44,720 --> 00:04:49,199
message

00:04:45,680 --> 00:04:51,360
and when it receives the data you know

00:04:49,199 --> 00:04:53,440
which was sent by the client or the

00:04:51,360 --> 00:04:54,320
server it has to see whether there is

00:04:53,440 --> 00:04:56,800
enough

00:04:54,320 --> 00:04:57,919
whether the data contains one full uh

00:04:56,800 --> 00:05:00,000
message if it

00:04:57,919 --> 00:05:01,680
contains that's all good we can

00:05:00,000 --> 00:05:04,080
immediately start processing but in the

00:05:01,680 --> 00:05:07,520
other situation that can happen is that

00:05:04,080 --> 00:05:09,360
uh that the received the received data

00:05:07,520 --> 00:05:11,520
does not contain a message so it has to

00:05:09,360 --> 00:05:14,080
wait until the next data arrives

00:05:11,520 --> 00:05:14,960
in order to reassemble entire message

00:05:14,080 --> 00:05:19,120
and

00:05:14,960 --> 00:05:19,120
that requires some buffering between

00:05:19,280 --> 00:05:23,199
between the fragments as they arrived

00:05:21,520 --> 00:05:26,000
either from client or either from the

00:05:23,199 --> 00:05:29,039
server on the on the opposite direction

00:05:26,000 --> 00:05:29,039
so next slide please

00:05:29,360 --> 00:05:33,280
so here is a filter has a state

00:05:34,400 --> 00:05:39,440
so it always starts in the initial state

00:05:37,120 --> 00:05:42,080
initially and it stays in the state

00:05:39,440 --> 00:05:43,680
as long as the coder so-called likes the

00:05:42,080 --> 00:05:47,280
messages so i'm saying

00:05:43,680 --> 00:05:49,680
like so it's able to find the boundary

00:05:47,280 --> 00:05:51,520
when the one message ends and then when

00:05:49,680 --> 00:05:53,039
the next starts and it can kind of make

00:05:51,520 --> 00:05:55,919
sense what's passing between

00:05:53,039 --> 00:05:57,600
client and the server and as long as it

00:05:55,919 --> 00:06:01,360
the decoder likely stays

00:05:57,600 --> 00:06:02,319
in in sync state there are two states uh

00:06:01,360 --> 00:06:05,120
there are two

00:06:02,319 --> 00:06:06,080
situations when uh the encoder can leave

00:06:05,120 --> 00:06:08,800
that state

00:06:06,080 --> 00:06:10,400
so the first one state is normal state

00:06:08,800 --> 00:06:12,400
i'm saying there's no error and it's

00:06:10,400 --> 00:06:13,120
called an encrypted state and it happens

00:06:12,400 --> 00:06:15,120
when

00:06:13,120 --> 00:06:16,240
client and the server negotiate an

00:06:15,120 --> 00:06:19,759
encrypted session

00:06:16,240 --> 00:06:21,600
and basically it's encrypted and

00:06:19,759 --> 00:06:23,440
failed to say hey girls but it's nothing

00:06:21,600 --> 00:06:25,360
i can do i

00:06:23,440 --> 00:06:27,759
and it's that basically starts passing

00:06:25,360 --> 00:06:29,919
this without looking inside without

00:06:27,759 --> 00:06:32,720
doing any deep inspection

00:06:29,919 --> 00:06:34,240
so the other situation when the filter

00:06:32,720 --> 00:06:38,960
can live in sync state

00:06:34,240 --> 00:06:42,080
is when something unusual happens so

00:06:38,960 --> 00:06:43,759
uh either there was a corruption and the

00:06:42,080 --> 00:06:45,280
decoder says you know i don't really

00:06:43,759 --> 00:06:48,560
know what's going on here

00:06:45,280 --> 00:06:51,039
and and and say you know

00:06:48,560 --> 00:06:51,840
i better start ignoring those messages

00:06:51,039 --> 00:06:54,400
the other

00:06:51,840 --> 00:06:55,759
situation is when it can happen is that

00:06:54,400 --> 00:06:58,000
when administrator

00:06:55,759 --> 00:07:00,080
configures everything for postgres so

00:06:58,000 --> 00:07:02,160
there will be a postgres filter tcp

00:07:00,080 --> 00:07:04,639
filter configures everything but

00:07:02,160 --> 00:07:05,919
starts passing the traffic which is not

00:07:04,639 --> 00:07:08,000
really postgres

00:07:05,919 --> 00:07:09,919
and the biggest danger here is that the

00:07:08,000 --> 00:07:12,880
filter really looks inside

00:07:09,919 --> 00:07:14,560
of the postgres mesh that's header there

00:07:12,880 --> 00:07:16,639
is a four byte fields which is

00:07:14,560 --> 00:07:18,800
uh which indicates the length of the

00:07:16,639 --> 00:07:20,880
message and as i said before

00:07:18,800 --> 00:07:22,880
before we can start a filter can start

00:07:20,880 --> 00:07:24,080
acting upon that message it has to keep

00:07:22,880 --> 00:07:26,400
it in a memory

00:07:24,080 --> 00:07:27,759
if this is corrupted and tells you some

00:07:26,400 --> 00:07:30,160
you know outrageously

00:07:27,759 --> 00:07:31,840
large number filter may try to allocate

00:07:30,160 --> 00:07:34,319
that much memory

00:07:31,840 --> 00:07:36,720
and and can and can run out of memory

00:07:34,319 --> 00:07:39,199
and the process will be killed so

00:07:36,720 --> 00:07:41,039
by indicating and introducing out of

00:07:39,199 --> 00:07:42,479
sync state we're trying to prevent that

00:07:41,039 --> 00:07:45,840
situation

00:07:42,479 --> 00:07:45,840
next slide please fabrizio

00:07:46,319 --> 00:07:50,000
so in addition um the producing

00:07:49,120 --> 00:07:53,199
statistics the

00:07:50,000 --> 00:07:53,919
posgas filter can produce a metadata so

00:07:53,199 --> 00:07:56,240
let's

00:07:53,919 --> 00:07:58,479
try to explain here what the metadata is

00:07:56,240 --> 00:07:58,479
so

00:08:00,319 --> 00:08:06,560
this is sql database so you know it

00:08:03,360 --> 00:08:07,759
there is a an sql query passing in the

00:08:06,560 --> 00:08:10,879
messages could be

00:08:07,759 --> 00:08:13,520
quite complex and really only database

00:08:10,879 --> 00:08:16,560
and sql parser really understands this

00:08:13,520 --> 00:08:19,360
so metadata is the way of describing the

00:08:16,560 --> 00:08:20,240
quite complex sql query using just a few

00:08:19,360 --> 00:08:22,400
labels

00:08:20,240 --> 00:08:25,039
and those labels might be whether this

00:08:22,400 --> 00:08:27,280
sql you know query is read operation

00:08:25,039 --> 00:08:29,199
right operation on which database on

00:08:27,280 --> 00:08:31,360
which table just using

00:08:29,199 --> 00:08:33,200
three or four labels we able to describe

00:08:31,360 --> 00:08:36,240
it in a concise way

00:08:33,200 --> 00:08:38,240
what this operation is about and that

00:08:36,240 --> 00:08:41,279
metadata is attached to a

00:08:38,240 --> 00:08:44,240
request and it travels as

00:08:41,279 --> 00:08:46,000
data travel it travels with data as it

00:08:44,240 --> 00:08:48,640
passes different filters

00:08:46,000 --> 00:08:50,560
so if we put another filter like arbuck

00:08:48,640 --> 00:08:53,279
we can program our bug

00:08:50,560 --> 00:08:54,080
to reject or stop certain operations you

00:08:53,279 --> 00:08:57,040
know from being

00:08:54,080 --> 00:08:57,360
said so you may program it would be a

00:08:57,040 --> 00:08:59,440
good

00:08:57,360 --> 00:09:01,920
simple example would be you can program

00:08:59,440 --> 00:09:03,440
it that it only routes reads operation

00:09:01,920 --> 00:09:05,760
on a specific table

00:09:03,440 --> 00:09:06,800
and stop all the right operations right

00:09:05,760 --> 00:09:09,839
at this moment

00:09:06,800 --> 00:09:10,480
so you kind of the program access

00:09:09,839 --> 00:09:13,440
control

00:09:10,480 --> 00:09:15,120
right at the network level even before

00:09:13,440 --> 00:09:16,959
it reaches a database

00:09:15,120 --> 00:09:18,880
there probably might be other examples

00:09:16,959 --> 00:09:22,000
of using metadata that's

00:09:18,880 --> 00:09:24,320
this one is simple enough to understand

00:09:22,000 --> 00:09:26,720
so that would be it from envoy's point

00:09:24,320 --> 00:09:29,120
of view

00:09:26,720 --> 00:09:29,120
thank you

00:09:30,000 --> 00:09:37,279
so thank you christopher now let's talk

00:09:33,360 --> 00:09:39,760
a little bit about postgresql

00:09:37,279 --> 00:09:42,000
here the idea is not to talk about a lot

00:09:39,760 --> 00:09:45,040
of great features but uh

00:09:42,000 --> 00:09:47,920
give you a clear picture of cohen

00:09:45,040 --> 00:09:48,640
stats of development side of posters you

00:09:47,920 --> 00:09:52,320
know

00:09:48,640 --> 00:09:55,360
so postgres has more than

00:09:52,320 --> 00:09:56,720
30 years of development it's fully open

00:09:55,360 --> 00:09:59,040
sources since the beginning

00:09:56,720 --> 00:10:00,720
and we have a postgres license it's a

00:09:59,040 --> 00:10:04,160
specific license

00:10:00,720 --> 00:10:07,600
based on bsd license is

00:10:04,160 --> 00:10:10,800
totally driven by community i mean

00:10:07,600 --> 00:10:14,640
driven by postgresql global development

00:10:10,800 --> 00:10:18,320
group there are no single single company

00:10:14,640 --> 00:10:21,839
driving the development

00:10:18,320 --> 00:10:24,880
nowadays we have the 29 car committers

00:10:21,839 --> 00:10:27,519
working for different companies and

00:10:24,880 --> 00:10:28,560
nowadays we have a thousand of people's

00:10:27,519 --> 00:10:33,279
around the world

00:10:28,560 --> 00:10:36,959
testing and reporting issues of the day

00:10:33,279 --> 00:10:39,600
and this and here is the result of so

00:10:36,959 --> 00:10:42,079
many years of mature development

00:10:39,600 --> 00:10:44,480
if you see in this picture a lot of

00:10:42,079 --> 00:10:47,760
great use cases

00:10:44,480 --> 00:10:51,200
apple skype instagram twitch

00:10:47,760 --> 00:10:54,560
spotify imdb and there are a lot of

00:10:51,200 --> 00:10:58,200
uh missing other great missing

00:10:54,560 --> 00:11:02,000
user cases in these images like lifty

00:10:58,200 --> 00:11:05,680
tripadvisor ching git lab

00:11:02,000 --> 00:11:05,680
atlasian and

00:11:05,760 --> 00:11:12,800
a lot of government in different scales

00:11:09,120 --> 00:11:15,519
use posters today you know so

00:11:12,800 --> 00:11:16,720
it's a great great open source database

00:11:15,519 --> 00:11:19,279
uh

00:11:16,720 --> 00:11:21,120
we often call the most advanced open

00:11:19,279 --> 00:11:24,160
source database in the world

00:11:21,120 --> 00:11:24,800
uh on the postgres community society so

00:11:24,160 --> 00:11:28,160
let's talk

00:11:24,800 --> 00:11:32,160
more now about what he we did

00:11:28,160 --> 00:11:35,279
here for uh envoy network postgres

00:11:32,160 --> 00:11:35,920
network filter far and void let's start

00:11:35,279 --> 00:11:39,040
talking about

00:11:35,920 --> 00:11:39,040
the protocol versions

00:11:39,120 --> 00:11:43,120
today the postgres wireless format it's

00:11:42,800 --> 00:11:46,399
a

00:11:43,120 --> 00:11:49,680
very stable and mature protocol

00:11:46,399 --> 00:11:53,360
without major changes

00:11:49,680 --> 00:11:57,519
since 23

00:11:53,360 --> 00:12:01,519
lasted 17 years without any major change

00:11:57,519 --> 00:12:04,160
so since the 7.5 version

00:12:01,519 --> 00:12:04,720
it's the same version of the protocol

00:12:04,160 --> 00:12:07,360
and

00:12:04,720 --> 00:12:10,160
the server still supports the protocol

00:12:07,360 --> 00:12:13,680
the first version of the protocol now

00:12:10,160 --> 00:12:16,079
so there are a lot of other uh delivered

00:12:13,680 --> 00:12:16,720
projects delivered postgres projects

00:12:16,079 --> 00:12:19,920
that can

00:12:16,720 --> 00:12:23,120
benefit of this envoy network

00:12:19,920 --> 00:12:26,480
filter i can say

00:12:23,120 --> 00:12:29,600
uh head shift from amazon uh

00:12:26,480 --> 00:12:30,399
was built on top of postgres many years

00:12:29,600 --> 00:12:34,079
ago

00:12:30,399 --> 00:12:38,240
uh aurora rds

00:12:34,079 --> 00:12:42,639
yoga bites db cockroach db

00:12:38,240 --> 00:12:46,000
uh greenplan and there are a lot of uh

00:12:42,639 --> 00:12:48,079
projects uh out there that implement the

00:12:46,000 --> 00:12:51,839
postgresql format

00:12:48,079 --> 00:12:54,880
so you you can benefit for this

00:12:51,839 --> 00:12:57,920
envoy network filter

00:12:54,880 --> 00:13:01,040
so about the protocol

00:12:57,920 --> 00:13:03,680
uh there are a name

00:13:01,040 --> 00:13:04,800
called phoebe frame format phoebe is a

00:13:03,680 --> 00:13:07,760
common term

00:13:04,800 --> 00:13:09,120
in posters world that means front end

00:13:07,760 --> 00:13:12,240
and back-end

00:13:09,120 --> 00:13:13,839
it's same like a client and server are

00:13:12,240 --> 00:13:17,040
upstream downstream

00:13:13,839 --> 00:13:20,079
you know and basically we have

00:13:17,040 --> 00:13:22,240
two types of packages that traffic

00:13:20,079 --> 00:13:24,079
between the client and the server there

00:13:22,240 --> 00:13:27,120
are a startup package

00:13:24,079 --> 00:13:31,040
in the regular package package

00:13:27,120 --> 00:13:33,920
uh and there uh they start the package

00:13:31,040 --> 00:13:35,279
there are three fields the first field

00:13:33,920 --> 00:13:37,839
is the

00:13:35,279 --> 00:13:38,880
the length of the message the second

00:13:37,839 --> 00:13:41,279
field is the

00:13:38,880 --> 00:13:42,560
protocol version and there are a payload

00:13:41,279 --> 00:13:46,240
with other

00:13:42,560 --> 00:13:46,720
uh needed information with parameters

00:13:46,240 --> 00:13:49,040
for

00:13:46,720 --> 00:13:49,839
start the connection in the regular

00:13:49,040 --> 00:13:53,440
package

00:13:49,839 --> 00:13:56,800
we have uh first field is a tag which is

00:13:53,440 --> 00:14:00,240
one byte one character the length

00:13:56,800 --> 00:14:03,680
of the message and the payload with the

00:14:00,240 --> 00:14:06,800
necessary data about

00:14:03,680 --> 00:14:10,240
the the message and there are a

00:14:06,800 --> 00:14:11,680
special starter package called ssl

00:14:10,240 --> 00:14:14,240
negotiation

00:14:11,680 --> 00:14:15,279
that is the same as a startup package

00:14:14,240 --> 00:14:18,639
but the

00:14:15,279 --> 00:14:20,560
difference is when we start ssl

00:14:18,639 --> 00:14:23,600
negotiation we send

00:14:20,560 --> 00:14:27,279
to server a dummy uh

00:14:23,600 --> 00:14:31,680
protocol version so posters

00:14:27,279 --> 00:14:34,560
start the ssl negotiation

00:14:31,680 --> 00:14:35,519
using this special you start the package

00:14:34,560 --> 00:14:38,959
has

00:14:35,519 --> 00:14:42,959
we will see more in next slides

00:14:38,959 --> 00:14:47,199
so here we can see

00:14:42,959 --> 00:14:51,839
the message for for a new connection

00:14:47,199 --> 00:14:54,959
on the left side is for a unencrypted

00:14:51,839 --> 00:14:58,320
connection and the right side is

00:14:54,959 --> 00:15:00,800
for encrypted connection

00:14:58,320 --> 00:15:03,120
so here we send a startup package server

00:15:00,800 --> 00:15:06,639
response without a request

00:15:03,120 --> 00:15:08,959
it's okay and optionally you can send a

00:15:06,639 --> 00:15:10,639
password and server response with a lot

00:15:08,959 --> 00:15:13,680
of parameter status

00:15:10,639 --> 00:15:17,040
back-end key data and finish

00:15:13,680 --> 00:15:17,519
reading for query that is send say to

00:15:17,040 --> 00:15:20,480
client

00:15:17,519 --> 00:15:21,680
hey client i'm waiting for you and you

00:15:20,480 --> 00:15:24,480
can send the

00:15:21,680 --> 00:15:27,360
next command a query appears message

00:15:24,480 --> 00:15:30,560
depending of simple or extended protocol

00:15:27,360 --> 00:15:33,600
and the difference when we start uh in

00:15:30,560 --> 00:15:37,120
encrypted connection is because we

00:15:33,600 --> 00:15:40,320
send a ssl negotiation it's a

00:15:37,120 --> 00:15:42,800
dummy the package

00:15:40,320 --> 00:15:44,079
and the server will response yes or no

00:15:42,800 --> 00:15:47,360
if you

00:15:44,079 --> 00:15:50,720
if your server is able to start at ls

00:15:47,360 --> 00:15:51,920
if you have config if you have the

00:15:50,720 --> 00:15:55,199
enough configuration

00:15:51,920 --> 00:15:59,279
certificates and wherever and if

00:15:55,199 --> 00:16:02,399
we the response is s

00:15:59,279 --> 00:16:05,680
we will have we will start uh

00:16:02,399 --> 00:16:09,199
the ssl handshake and after that

00:16:05,680 --> 00:16:13,199
the message flow will be the same it has

00:16:09,199 --> 00:16:16,480
an encrypted connection you know

00:16:13,199 --> 00:16:18,639
and here uh it's other

00:16:16,480 --> 00:16:20,320
other parts of the protocol when we

00:16:18,639 --> 00:16:23,360
negotiate with the server

00:16:20,320 --> 00:16:26,560
to for example run a simple query

00:16:23,360 --> 00:16:28,720
okay in postgres wire protocol basically

00:16:26,560 --> 00:16:29,759
there are two different ways to interact

00:16:28,720 --> 00:16:32,240
with the server

00:16:29,759 --> 00:16:34,880
there are simple protocol and the

00:16:32,240 --> 00:16:38,399
extended protocol that was introduced

00:16:34,880 --> 00:16:41,360
introduced in version 3.0

00:16:38,399 --> 00:16:43,440
70 years ago okay here i will just

00:16:41,360 --> 00:16:45,440
explain the simple protocol because the

00:16:43,440 --> 00:16:48,480
idea will be the same

00:16:45,440 --> 00:16:52,079
for extended the only difference

00:16:48,480 --> 00:16:55,759
is on extended we process the

00:16:52,079 --> 00:16:58,160
pair sparse message and in simple we

00:16:55,759 --> 00:17:00,880
process the query message

00:16:58,160 --> 00:17:02,880
as you can see here the client send a

00:17:00,880 --> 00:17:06,640
query message to the server

00:17:02,880 --> 00:17:10,000
and the server get this message with the

00:17:06,640 --> 00:17:13,199
sql statement side and do

00:17:10,000 --> 00:17:16,640
all the processing i mean the

00:17:13,199 --> 00:17:20,160
parser he write query

00:17:16,640 --> 00:17:21,679
planning and execute and then start to

00:17:20,160 --> 00:17:25,280
respond to the client

00:17:21,679 --> 00:17:28,400
and the first first response will be the

00:17:25,280 --> 00:17:31,200
road description that contains

00:17:28,400 --> 00:17:32,160
our information about the data set i

00:17:31,200 --> 00:17:34,960
mean

00:17:32,160 --> 00:17:36,000
the name of the fields the length of the

00:17:34,960 --> 00:17:39,360
fields

00:17:36,000 --> 00:17:43,039
data type is type aligning

00:17:39,360 --> 00:17:46,559
for metadata about the result set

00:17:43,039 --> 00:17:50,160
and after that start streaming all

00:17:46,559 --> 00:17:53,919
rows fetched by

00:17:50,160 --> 00:17:57,760
by query you know and at the end

00:17:53,919 --> 00:18:01,120
of streaming data the

00:17:57,760 --> 00:18:04,400
server response sent back to the client

00:18:01,120 --> 00:18:09,120
a special message called command

00:18:04,400 --> 00:18:15,840
complete and the common complete

00:18:09,120 --> 00:18:15,840
the how in the code

00:18:16,000 --> 00:18:21,039
network filter the decoding part of the

00:18:18,960 --> 00:18:24,240
post network in future

00:18:21,039 --> 00:18:26,480
it's around of this this

00:18:24,240 --> 00:18:27,520
common completes of course there are a

00:18:26,480 --> 00:18:30,640
lot of different

00:18:27,520 --> 00:18:32,880
parts there to filter and uh whatever

00:18:30,640 --> 00:18:34,000
but here is the trick to the code the

00:18:32,880 --> 00:18:37,039
wired protocol

00:18:34,000 --> 00:18:40,480
because at the end of the execution of

00:18:37,039 --> 00:18:43,120
uh execution of the some sql statement

00:18:40,480 --> 00:18:43,679
postgres response the back end of the

00:18:43,120 --> 00:18:46,960
server

00:18:43,679 --> 00:18:50,160
response back to the client with a tag

00:18:46,960 --> 00:18:53,360
about what happens uh

00:18:50,160 --> 00:18:56,640
in the the query i mean

00:18:53,360 --> 00:19:00,000
i run a select insert delete and

00:18:56,640 --> 00:19:03,120
date uh explicit

00:19:00,000 --> 00:19:06,720
explicit transaction command

00:19:03,120 --> 00:19:07,840
begin community ddl screen table and

00:19:06,720 --> 00:19:11,039
whatever

00:19:07,840 --> 00:19:15,360
and uh here you can see

00:19:11,039 --> 00:19:17,919
from post source code there are long

00:19:15,360 --> 00:19:18,960
command tag lists there with all command

00:19:17,919 --> 00:19:22,400
tags

00:19:18,960 --> 00:19:24,799
okay oh so

00:19:22,400 --> 00:19:27,360
let's start with the demonstration part

00:19:24,799 --> 00:19:30,400
of the the presentation

00:19:27,360 --> 00:19:33,679
and you expect

00:19:30,400 --> 00:19:37,600
some result like this

00:19:33,679 --> 00:19:41,120
we are able to create to some dashboards

00:19:37,600 --> 00:19:44,080
in grapherna to get the metrics

00:19:41,120 --> 00:19:46,400
and this image you have several uh

00:19:44,080 --> 00:19:49,679
graphics interesting graphics without

00:19:46,400 --> 00:19:52,720
touch to the postgres i mean zero

00:19:49,679 --> 00:19:56,160
configuration on poster site

00:19:52,720 --> 00:19:59,120
just by decoding the wire format

00:19:56,160 --> 00:19:59,840
we can expose those metrics on voice

00:19:59,120 --> 00:20:02,880
side

00:19:59,840 --> 00:20:06,159
it will create

00:20:02,880 --> 00:20:09,679
will not create a lot of overhead on

00:20:06,159 --> 00:20:12,400
post the side because another way to

00:20:09,679 --> 00:20:13,840
to get this information running some

00:20:12,400 --> 00:20:15,760
queries to

00:20:13,840 --> 00:20:17,760
uh against the postgres server

00:20:15,760 --> 00:20:18,559
requirement is very simple for this

00:20:17,760 --> 00:20:21,760
demonstration

00:20:18,559 --> 00:20:22,320
just git darker and darker compost you

00:20:21,760 --> 00:20:24,720
know

00:20:22,320 --> 00:20:27,120
the architecture is very simple there

00:20:24,720 --> 00:20:29,919
are five containers here

00:20:27,120 --> 00:20:31,919
and there are a special container that

00:20:29,919 --> 00:20:35,440
generates some trafficking

00:20:31,919 --> 00:20:38,559
i mean create some dummy workload

00:20:35,440 --> 00:20:41,679
we are using here some

00:20:38,559 --> 00:20:45,039
house-made descripts and the pg bench

00:20:41,679 --> 00:20:48,159
it's up to postgres 2 for benchmark

00:20:45,039 --> 00:20:49,520
and those the this traffic is sent to

00:20:48,159 --> 00:20:52,000
envoy

00:20:49,520 --> 00:20:54,559
and then voice send the to another

00:20:52,000 --> 00:20:55,200
container with postgres and promoters to

00:20:54,559 --> 00:20:58,480
grab

00:20:55,200 --> 00:21:01,360
to scrap the metrics from envoy

00:20:58,480 --> 00:21:02,080
and graphene to collect to expose

00:21:01,360 --> 00:21:05,280
metrics

00:21:02,080 --> 00:21:08,880
in to create some dashboards

00:21:05,280 --> 00:21:12,080
so now i have all five containers

00:21:08,880 --> 00:21:13,600
the most important container in this

00:21:12,080 --> 00:21:18,320
case

00:21:13,600 --> 00:21:22,559
is and why for sure

00:21:18,320 --> 00:21:25,039
here we are in debugging debugging mode

00:21:22,559 --> 00:21:26,559
and here you can see some interesting

00:21:25,039 --> 00:21:30,080
information

00:21:26,559 --> 00:21:33,200
for example here

00:21:30,080 --> 00:21:36,640
here we have a front-end messaging query

00:21:33,200 --> 00:21:40,240
send a simple query to the back-end

00:21:36,640 --> 00:21:43,039
i mean this sql statement and

00:21:40,240 --> 00:21:44,159
the back-end response with the whole

00:21:43,039 --> 00:21:47,520
description

00:21:44,159 --> 00:21:48,640
and after that several data holes

00:21:47,520 --> 00:21:51,760
sending back

00:21:48,640 --> 00:21:55,600
the data to the client

00:21:51,760 --> 00:21:58,720
no and the here there are a lot of and

00:21:55,600 --> 00:22:02,320
another important important thing

00:21:58,720 --> 00:22:05,600
is common complete

00:22:02,320 --> 00:22:09,120
here this is the

00:22:05,600 --> 00:22:10,799
the the tricky that we did for exposing

00:22:09,120 --> 00:22:13,919
matrices

00:22:10,799 --> 00:22:15,679
drilling down select the different kind

00:22:13,919 --> 00:22:16,880
of statement drained off for different

00:22:15,679 --> 00:22:20,000
kind of statement

00:22:16,880 --> 00:22:21,120
because the postgres response at the end

00:22:20,000 --> 00:22:24,960
of the

00:22:21,120 --> 00:22:28,559
the data that data data row is streaming

00:22:24,960 --> 00:22:31,679
this tag for the command and here

00:22:28,559 --> 00:22:34,720
what we are doing on the invoice side is

00:22:31,679 --> 00:22:37,120
increase a specific metric about

00:22:34,720 --> 00:22:37,840
select statement when the command

00:22:37,120 --> 00:22:40,880
completes

00:22:37,840 --> 00:22:44,960
arrive pass

00:22:40,880 --> 00:22:48,640
through the the network filter you know

00:22:44,960 --> 00:22:52,640
the other important thing is here

00:22:48,640 --> 00:22:53,200
here we have a script to generate some

00:22:52,640 --> 00:22:56,320
traffic

00:22:53,200 --> 00:23:00,720
it's very very simple we do a lot of

00:22:56,320 --> 00:23:03,760
random to run some benchmarks

00:23:00,720 --> 00:23:06,840
and run within different

00:23:03,760 --> 00:23:08,400
protocols you know a simple extended

00:23:06,840 --> 00:23:10,480
prepared so

00:23:08,400 --> 00:23:12,799
we can generate a lot of different

00:23:10,480 --> 00:23:15,520
trafficking in this

00:23:12,799 --> 00:23:16,320
small demonstration to generate some

00:23:15,520 --> 00:23:19,440
graph

00:23:16,320 --> 00:23:22,799
here is our graphene

00:23:19,440 --> 00:23:25,840
running and we have a special dashboard

00:23:22,799 --> 00:23:28,799
with all uh graphs

00:23:25,840 --> 00:23:30,000
about the traffic tps transactions per

00:23:28,799 --> 00:23:32,960
seconds hidden

00:23:30,000 --> 00:23:36,720
and righteous uh different type of

00:23:32,960 --> 00:23:40,480
statements front end and back end

00:23:36,720 --> 00:23:43,679
messages and number of sessions

00:23:40,480 --> 00:23:44,799
per second so so let's let's let's talk

00:23:43,679 --> 00:23:48,400
about it what

00:23:44,799 --> 00:23:48,400
what we plan for the future so

00:23:48,559 --> 00:23:52,320
we want to do a few things and some of

00:23:50,240 --> 00:23:54,000
them are already under

00:23:52,320 --> 00:23:55,919
active developments the first one is a

00:23:54,000 --> 00:23:57,840
necessary termination and we said that

00:23:55,919 --> 00:24:00,159
in order to produce all those statistics

00:23:57,840 --> 00:24:02,480
we need an access to

00:24:00,159 --> 00:24:03,919
uh to clear text packet but what happens

00:24:02,480 --> 00:24:04,960
if you have a requirement that the

00:24:03,919 --> 00:24:07,200
client has to

00:24:04,960 --> 00:24:09,039
you know travel it traverse a certain

00:24:07,200 --> 00:24:09,840
portion of your network in an encrypted

00:24:09,039 --> 00:24:11,520
fashion

00:24:09,840 --> 00:24:12,960
so we want to terminate that's

00:24:11,520 --> 00:24:15,200
accelerated at the

00:24:12,960 --> 00:24:16,799
end level so traffic between the client

00:24:15,200 --> 00:24:18,720
and if it's going to be encrypt and then

00:24:16,799 --> 00:24:19,760
everyone can actually look what's inside

00:24:18,720 --> 00:24:22,720
of the packet so

00:24:19,760 --> 00:24:24,480
it's under active development we also

00:24:22,720 --> 00:24:26,640
want to have a better result parsing the

00:24:24,480 --> 00:24:28,080
current parts we use it's not sufficient

00:24:26,640 --> 00:24:31,600
in all cases so

00:24:28,080 --> 00:24:33,120
we want to switch to a better one

00:24:31,600 --> 00:24:34,720
like i said before in fabrizio was

00:24:33,120 --> 00:24:36,640
demonstrating here we

00:24:34,720 --> 00:24:37,919
can provide all different statistics in

00:24:36,640 --> 00:24:39,760
an aggregated way

00:24:37,919 --> 00:24:41,760
but they are also a requirement that if

00:24:39,760 --> 00:24:43,120
some clients are using one database

00:24:41,760 --> 00:24:46,159
and the other clients are using the

00:24:43,120 --> 00:24:48,159
other but they shall network we want to

00:24:46,159 --> 00:24:50,400
basically provide the statistics per

00:24:48,159 --> 00:24:52,000
database so when we talk to promiscuous

00:24:50,400 --> 00:24:53,679
and we extract data

00:24:52,000 --> 00:24:55,520
we just want to somehow divide it and

00:24:53,679 --> 00:24:57,520
say that's for database a that's what

00:24:55,520 --> 00:24:59,919
database b

00:24:57,520 --> 00:25:01,520
and you also want to maybe introduce a

00:24:59,919 --> 00:25:03,279
routing based on query and

00:25:01,520 --> 00:25:05,520
that's i said when i was talking about

00:25:03,279 --> 00:25:07,120
the metadata that metadata can be used

00:25:05,520 --> 00:25:09,039
later on during the processing

00:25:07,120 --> 00:25:10,159
maybe you want to route some queries to

00:25:09,039 --> 00:25:12,640
a certain

00:25:10,159 --> 00:25:13,360
host because it's a right operation and

00:25:12,640 --> 00:25:14,960
maybe

00:25:13,360 --> 00:25:16,799
a different host because it's a read

00:25:14,960 --> 00:25:19,120
operation so

00:25:16,799 --> 00:25:21,760
what's going on in a community so there

00:25:19,120 --> 00:25:23,120
is a dedicated envoy slack

00:25:21,760 --> 00:25:25,200
there is a bunch of channels for

00:25:23,120 --> 00:25:26,880
development users and there is one very

00:25:25,200 --> 00:25:29,279
specific

00:25:26,880 --> 00:25:29,919
dedicated to envoy uh sorry to postgres

00:25:29,279 --> 00:25:32,799
development

00:25:29,919 --> 00:25:35,039
uh so there is a hash here and all the

00:25:32,799 --> 00:25:35,840
issues which are raised by users so by

00:25:35,039 --> 00:25:39,520
developers

00:25:35,840 --> 00:25:42,640
they uh they labeled as a postgres issue

00:25:39,520 --> 00:25:42,880
and here is a link how you can find them

00:25:42,640 --> 00:25:46,000
in

00:25:42,880 --> 00:25:47,440
envoy project so i guess they would be

00:25:46,000 --> 00:25:50,960
all thank you

00:25:47,440 --> 00:25:57,840
on my site thank you everyone

00:25:50,960 --> 00:25:57,840
bye bye bye

00:25:58,080 --> 00:26:00,880
hello everyone

00:26:01,600 --> 00:26:05,760
no there's absolutely no question so i

00:26:04,720 --> 00:26:07,919
guess we

00:26:05,760 --> 00:26:10,480
and everything's super clear everybody

00:26:07,919 --> 00:26:10,480
is super

00:26:14,480 --> 00:26:20,960
is there any plan way to use this to

00:26:17,760 --> 00:26:25,039
support connection pooling

00:26:20,960 --> 00:26:25,039
yeah they would be on the back end there

00:26:26,580 --> 00:26:29,670
[Music]

00:26:36,720 --> 00:26:44,799
specific post was pulling because

00:26:40,799 --> 00:26:47,919
we have different pulling modes

00:26:44,799 --> 00:26:49,840
i mean we have the session buildings

00:26:47,919 --> 00:26:52,960
that the food pulling world

00:26:49,840 --> 00:26:56,799
that was shipped by the food

00:26:52,960 --> 00:26:59,919
and when uh you leave your session

00:26:56,799 --> 00:27:03,039
we can you use this session

00:26:59,919 --> 00:27:05,760
for another session but is is

00:27:03,039 --> 00:27:06,559
driven by sessions but we have two

00:27:05,760 --> 00:27:09,200
models

00:27:06,559 --> 00:27:11,200
specific pulling modes and more

00:27:09,200 --> 00:27:13,520
aggressive pulling modes

00:27:11,200 --> 00:27:15,279
we have a transaction move i mean when a

00:27:13,520 --> 00:27:18,080
transaction finish

00:27:15,279 --> 00:27:19,039
the connection is returned back to the

00:27:18,080 --> 00:27:23,440
pool

00:27:19,039 --> 00:27:23,440
and we can create a

00:27:23,679 --> 00:27:28,000
really funny between a lot of

00:27:26,640 --> 00:27:28,670
connections using just

00:27:28,000 --> 00:27:31,120
one session

00:27:28,670 --> 00:27:34,320
[Music]

00:27:31,120 --> 00:27:36,480
we didn't plan to do nothing about that

00:27:34,320 --> 00:27:39,600
on the invoice side yet

00:27:36,480 --> 00:27:42,960
i don't know if it's possible

00:27:39,600 --> 00:27:43,919
uh maybe yes i don't know chris you are

00:27:42,960 --> 00:27:47,919
the guy

00:27:43,919 --> 00:27:49,440
you are named my guy no okay so to

00:27:47,919 --> 00:27:50,799
answer the specifically the question

00:27:49,440 --> 00:27:53,840
whether there is any plan

00:27:50,799 --> 00:27:56,000
so actually no it's not in the plan

00:27:53,840 --> 00:27:56,960
it popped up a few times but we didn't

00:27:56,000 --> 00:28:00,080
make any find

00:27:56,960 --> 00:28:03,360
you know concrete decision and uh

00:28:00,080 --> 00:28:05,200
uh but but but but anyway maintains some

00:28:03,360 --> 00:28:07,120
you know open session on the back end so

00:28:05,200 --> 00:28:08,799
maybe we can leverage that definitely we

00:28:07,120 --> 00:28:09,760
have to look at the you know very

00:28:08,799 --> 00:28:11,919
technicalities

00:28:09,760 --> 00:28:12,960
uh how we can leverage things which

00:28:11,919 --> 00:28:16,080
already exist

00:28:12,960 --> 00:28:18,080
um yeah so there is a question uh about

00:28:16,080 --> 00:28:21,200
the cockroachdb so all the pro

00:28:18,080 --> 00:28:22,640
all the databases which support wire

00:28:21,200 --> 00:28:24,399
protocol which is compatible with

00:28:22,640 --> 00:28:25,520
postgres you can benefit from this

00:28:24,399 --> 00:28:27,600
filter so

00:28:25,520 --> 00:28:30,159
fabrizio mentioned a long list of them

00:28:27,600 --> 00:28:34,559
and i think cockroach was one of those

00:28:30,159 --> 00:28:34,559
uh yoga but it would be another one yeah

00:28:34,960 --> 00:28:41,520
yeah exactly even redshift

00:28:38,480 --> 00:28:45,279
we work every

00:28:41,520 --> 00:28:48,320
red shifty was beauty on top of postgres

00:28:45,279 --> 00:28:53,120
eighth version so at that time

00:28:48,320 --> 00:28:53,120
we already have the protocol version

00:28:53,440 --> 00:29:00,799
is this uh who have assembled no no it

00:28:57,600 --> 00:29:03,600
plus uh there is a directories if you go

00:29:00,799 --> 00:29:05,600
into the source code of uh you will see

00:29:03,600 --> 00:29:07,279
different extensions and network filters

00:29:05,600 --> 00:29:09,279
and you will find the postgres

00:29:07,279 --> 00:29:11,520
podcast filter over there there will be

00:29:09,279 --> 00:29:13,440
a bunch of others like mysql uh

00:29:11,520 --> 00:29:14,960
i think radius would be so it's easy to

00:29:13,440 --> 00:29:18,799
find

00:29:14,960 --> 00:29:22,720
yeah yeah

00:29:18,799 --> 00:29:26,220
this is the link

00:29:22,720 --> 00:29:29,420
thank you

00:29:26,220 --> 00:29:29,420
[Music]

00:29:30,480 --> 00:29:34,720
all right so all right great thank you

00:29:33,600 --> 00:29:37,039
very much for listening to our

00:29:34,720 --> 00:29:40,240
presentation

00:29:37,039 --> 00:29:43,520
yeah thank you guys thank you bye

00:29:40,240 --> 00:29:43,520

YouTube URL: https://www.youtube.com/watch?v=CbNc9HggyRA


