Title: Safely deploying a 100K line Envoy YAML configuration to production - Jyoti Mahapatra, Lisa Lu
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	Safely deploying a 100K line Envoy YAML configuration to production - Jyoti Mahapatra, Lisa Lu

Have you ever caused a production incident due to an Envoy misconfiguration? You’re not alone! This talk is about how Lyft has built guardrails to prevent such failures. The presenters will share their experience operating Envoy configurations at scale. They will explore the challenges around handling constantly changing cluster and routing configurations and the tools used to guarantee accuracy and consistency in those changes. These tools empower service owners less familiar with Envoy to make configuration changes independently and quickly without approval barriers. This talk will introduce the audience to various Envoy configuration testing strategies:

    Validating behavior for thousands of routes to avoid blackholing traffic 
    Auditing and safely removing unused routes and clusters 
    Safely deprecating fields between Envoy versions 
    Validating Envoy’s static and realtime configurations
Captions: 
	00:00:00,080 --> 00:00:05,200
hi everyone welcome to our talk on how

00:00:02,240 --> 00:00:06,879
to validate envoy configs at scale

00:00:05,200 --> 00:00:08,639
we'll be going over strategies for

00:00:06,879 --> 00:00:09,599
automating the config validation and

00:00:08,639 --> 00:00:11,440
testing process

00:00:09,599 --> 00:00:13,360
so that your service owners can iterate

00:00:11,440 --> 00:00:14,960
quickly and independently

00:00:13,360 --> 00:00:16,560
this will also prevent your envoy

00:00:14,960 --> 00:00:19,199
operators from being bogged down with

00:00:16,560 --> 00:00:19,199
code reviews

00:00:19,359 --> 00:00:22,480
my name is lisa and i'm speaking here

00:00:21,119 --> 00:00:24,640
today with got

00:00:22,480 --> 00:00:25,599
both of us have worked on the router

00:00:24,640 --> 00:00:26,960
check tool

00:00:25,599 --> 00:00:29,119
which is one of the main tools we'll

00:00:26,960 --> 00:00:30,960
discuss here as well as internal tooling

00:00:29,119 --> 00:00:33,600
for making

00:00:30,960 --> 00:00:35,120
testing and validating of envoy configs

00:00:33,600 --> 00:00:36,640
better while at lyft

00:00:35,120 --> 00:00:40,160
we're really excited to share our

00:00:36,640 --> 00:00:40,160
learnings with you all today

00:00:40,399 --> 00:00:44,079
to start off i'll describe lyft's

00:00:42,559 --> 00:00:46,399
infrastructure and how we

00:00:44,079 --> 00:00:48,879
generate and transport our many envoy

00:00:46,399 --> 00:00:51,039
configs

00:00:48,879 --> 00:00:52,960
our bootstrap envoy config and our route

00:00:51,039 --> 00:00:55,199
and cluster definitions are stored in a

00:00:52,960 --> 00:00:57,199
repository as yaml files which we

00:00:55,199 --> 00:00:59,359
template with jinja

00:00:57,199 --> 00:01:01,920
service teams can add their routes to a

00:00:59,359 --> 00:01:03,760
jinja and python based infrastructure

00:01:01,920 --> 00:01:06,000
which eventually is wired up with the

00:01:03,760 --> 00:01:08,799
control plane to deliver updates to the

00:01:06,000 --> 00:01:08,799
front proxy

00:01:09,600 --> 00:01:14,400
upon container startup the envoy binary

00:01:12,400 --> 00:01:16,400
and bootstrap config get pulled

00:01:14,400 --> 00:01:18,479
and the static bootstrap config is

00:01:16,400 --> 00:01:20,400
generated with jinja

00:01:18,479 --> 00:01:22,720
sidecars in the internal mesh on the

00:01:20,400 --> 00:01:26,960
front proxy and the egress proxy are

00:01:22,720 --> 00:01:29,200
started with this

00:01:26,960 --> 00:01:31,200
to avoid rolling envoy every time there

00:01:29,200 --> 00:01:33,360
is a new route that gets added we use

00:01:31,200 --> 00:01:35,439
rds or the route discovery service to

00:01:33,360 --> 00:01:37,119
serve routes from a go control plane

00:01:35,439 --> 00:01:39,119
based control plane

00:01:37,119 --> 00:01:41,920
the bootstrap config is configured to

00:01:39,119 --> 00:01:43,680
request xts from our control plane

00:01:41,920 --> 00:01:45,200
meanwhile the routes and clusters which

00:01:43,680 --> 00:01:46,799
are stored in s3

00:01:45,200 --> 00:01:48,079
are fetched by the control plane which

00:01:46,799 --> 00:01:49,920
creates the respective route

00:01:48,079 --> 00:01:52,640
configuration and cluster objects to

00:01:49,920 --> 00:01:54,399
send via xds to the sidecars

00:01:52,640 --> 00:01:56,079
as such there are two main points at

00:01:54,399 --> 00:01:57,920
which we have to validate the format and

00:01:56,079 --> 00:02:00,000
content the configs

00:01:57,920 --> 00:02:00,960
the first such place is in the bootstrap

00:02:00,000 --> 00:02:03,200
config which

00:02:00,960 --> 00:02:05,840
ensures that the sidecar is able to run

00:02:03,200 --> 00:02:07,520
properly and start up without crashing

00:02:05,840 --> 00:02:09,759
the other place we need to validate is

00:02:07,520 --> 00:02:11,599
in the route and cluster definitions

00:02:09,759 --> 00:02:13,200
we validate these before sending them to

00:02:11,599 --> 00:02:14,080
the control plane because we want to

00:02:13,200 --> 00:02:15,840
avoid

00:02:14,080 --> 00:02:17,760
the control plane needing to do any

00:02:15,840 --> 00:02:19,680
validation as it gets the route and

00:02:17,760 --> 00:02:22,080
cluster information in real time and

00:02:19,680 --> 00:02:23,680
rather frequently

00:02:22,080 --> 00:02:25,840
as the number of services and routes

00:02:23,680 --> 00:02:27,599
that lift has grown on some side cars we

00:02:25,840 --> 00:02:29,360
have configurations that are upwards of

00:02:27,599 --> 00:02:30,080
a hundred thousand lines of yaml which

00:02:29,360 --> 00:02:32,000
makes

00:02:30,080 --> 00:02:36,560
maintenance and modification extremely

00:02:32,000 --> 00:02:38,640
complex and risky

00:02:36,560 --> 00:02:40,480
i'll describe some of the issues in fact

00:02:38,640 --> 00:02:41,599
that we've encountered over the last

00:02:40,480 --> 00:02:43,680
year

00:02:41,599 --> 00:02:45,440
firstly as a growing company we have new

00:02:43,680 --> 00:02:47,440
developers joining every week

00:02:45,440 --> 00:02:49,599
and business expansion also means that

00:02:47,440 --> 00:02:52,080
new services are being spun up to cater

00:02:49,599 --> 00:02:54,080
to new scenarios quite frequently

00:02:52,080 --> 00:02:56,160
this means more code review requests

00:02:54,080 --> 00:02:58,000
from developers who aren't familiar with

00:02:56,160 --> 00:03:00,080
envoy and want to know if their change

00:02:58,000 --> 00:03:02,080
will do what they want it to do

00:03:00,080 --> 00:03:03,120
while it's great that we're having more

00:03:02,080 --> 00:03:04,720
and more development

00:03:03,120 --> 00:03:07,120
it's not so great that the on-call

00:03:04,720 --> 00:03:08,959
burden has increased

00:03:07,120 --> 00:03:11,360
it means the on-call spends more time

00:03:08,959 --> 00:03:14,720
triaging these tickets and

00:03:11,360 --> 00:03:14,720
having to stare at yaml

00:03:15,440 --> 00:03:20,879
another issue is human con human error

00:03:18,400 --> 00:03:23,519
in configs

00:03:20,879 --> 00:03:25,360
with such large yaml files it isn't

00:03:23,519 --> 00:03:28,720
feasible for catching everything

00:03:25,360 --> 00:03:31,120
for example one common source of bugs

00:03:28,720 --> 00:03:32,640
is how envoy does first order matching

00:03:31,120 --> 00:03:34,239
for its routes

00:03:32,640 --> 00:03:36,319
which means that in a huge list of

00:03:34,239 --> 00:03:37,920
routes it might be easy for a developer

00:03:36,319 --> 00:03:39,519
or a viewer to

00:03:37,920 --> 00:03:41,519
miss a route that captures all the

00:03:39,519 --> 00:03:42,720
traffic that is actually intended for a

00:03:41,519 --> 00:03:44,840
new route

00:03:42,720 --> 00:03:46,959
these can lead to outages in your

00:03:44,840 --> 00:03:49,440
services

00:03:46,959 --> 00:03:50,799
in response to such errors we actually

00:03:49,440 --> 00:03:52,799
mandated a code review from the

00:03:50,799 --> 00:03:53,519
networking team for all routes at one

00:03:52,799 --> 00:03:55,360
point

00:03:53,519 --> 00:03:56,720
this quickly became the bottleneck for

00:03:55,360 --> 00:03:59,280
iteration because

00:03:56,720 --> 00:04:01,680
our networking team is about six people

00:03:59,280 --> 00:04:03,280
and while we were the guardians of

00:04:01,680 --> 00:04:05,120
these route changes for a while and

00:04:03,280 --> 00:04:05,519
tried to eyeball every change going in

00:04:05,120 --> 00:04:07,920
this

00:04:05,519 --> 00:04:08,560
just wasn't proving to be sustainable

00:04:07,920 --> 00:04:10,480
and was

00:04:08,560 --> 00:04:15,519
slowing iteration and rollouts for the

00:04:10,480 --> 00:04:18,720
rest of the company

00:04:15,519 --> 00:04:20,720
next we have um

00:04:18,720 --> 00:04:22,400
this issue where we just saw a tech debt

00:04:20,720 --> 00:04:24,320
piling up um

00:04:22,400 --> 00:04:26,960
what dead rats and dead clusters refer

00:04:24,320 --> 00:04:28,800
to are unused routes and unused clusters

00:04:26,960 --> 00:04:30,720
for example clusters that are

00:04:28,800 --> 00:04:33,759
no longer necessary or can't be routed

00:04:30,720 --> 00:04:36,880
to or routes that point to services that

00:04:33,759 --> 00:04:39,280
no longer exist

00:04:36,880 --> 00:04:41,040
this is quite common with deprecation

00:04:39,280 --> 00:04:42,000
service owners might delete the cluster

00:04:41,040 --> 00:04:44,320
config and forget

00:04:42,000 --> 00:04:45,840
to delete the routes or vice versa

00:04:44,320 --> 00:04:47,840
leaving in clutter and causing the

00:04:45,840 --> 00:04:49,520
control plane to continue creating route

00:04:47,840 --> 00:04:52,720
and cluster definitions

00:04:49,520 --> 00:04:52,720
that are no longer needed

00:04:54,720 --> 00:04:58,000
next reason is that changes are hard to

00:04:57,360 --> 00:05:00,240
test

00:04:58,000 --> 00:05:01,840
um actually this was a main reason for

00:05:00,240 --> 00:05:03,520
the first issue that i highlighted which

00:05:01,840 --> 00:05:05,919
is that service owners weren't sure how

00:05:03,520 --> 00:05:07,600
to validate their changes which is why

00:05:05,919 --> 00:05:09,600
um they wanted to reach out to the

00:05:07,600 --> 00:05:12,160
networking team in the first place

00:05:09,600 --> 00:05:14,240
um prior to automating our testing it

00:05:12,160 --> 00:05:16,639
was really difficult to validate changes

00:05:14,240 --> 00:05:18,639
you had to have an end-to-end setup with

00:05:16,639 --> 00:05:20,479
setting up an envoy sidecar and sending

00:05:18,639 --> 00:05:22,800
requests to see if your config changes

00:05:20,479 --> 00:05:24,800
worked

00:05:22,800 --> 00:05:25,919
finally lyft recently switched to

00:05:24,800 --> 00:05:28,400
pulling in the latest

00:05:25,919 --> 00:05:30,240
envoy version on a weekly basis and

00:05:28,400 --> 00:05:31,120
while this is great for minimizing tech

00:05:30,240 --> 00:05:34,400
de as we are

00:05:31,120 --> 00:05:36,639
staying up to date quite frequently um

00:05:34,400 --> 00:05:38,560
it runs the risk of always dealing with

00:05:36,639 --> 00:05:42,160
incompatible config changes

00:05:38,560 --> 00:05:44,240
and internal stability um

00:05:42,160 --> 00:05:45,680
when we say config here we mean both the

00:05:44,240 --> 00:05:48,479
onboard bootstrap config

00:05:45,680 --> 00:05:50,240
and the xps configuration an error in

00:05:48,479 --> 00:05:52,000
either of these could cause an envoy

00:05:50,240 --> 00:05:54,880
sidecar to reject the config

00:05:52,000 --> 00:05:55,600
and fail to start up or fail to apply

00:05:54,880 --> 00:05:59,280
updated

00:05:55,600 --> 00:06:01,280
xds objects um and in order to maintain

00:05:59,280 --> 00:06:02,319
this high speed of iteration we knew we

00:06:01,280 --> 00:06:04,479
would have to

00:06:02,319 --> 00:06:06,960
automate our testing in order to make

00:06:04,479 --> 00:06:11,280
sure that our envoys wouldn't regress

00:06:06,960 --> 00:06:11,280
whenever we pulled in the latest version

00:06:12,479 --> 00:06:16,160
of all these issues in mind we set out

00:06:14,400 --> 00:06:17,680
to invest in tooling and tests that

00:06:16,160 --> 00:06:20,960
would make config deployments

00:06:17,680 --> 00:06:22,960
safe and self-service

00:06:20,960 --> 00:06:24,000
the first strategy i'll talk about here

00:06:22,960 --> 00:06:26,319
is how we

00:06:24,000 --> 00:06:28,400
addressed tech debt in particular the

00:06:26,319 --> 00:06:30,319
dead clusters and routes

00:06:28,400 --> 00:06:32,560
we wrote some in-house scripts that were

00:06:30,319 --> 00:06:36,240
that parse the route and cluster configs

00:06:32,560 --> 00:06:38,800
and remove the ones that were dead um

00:06:36,240 --> 00:06:39,280
so in this scenario ideally in the top

00:06:38,800 --> 00:06:41,919
row

00:06:39,280 --> 00:06:43,039
you would have rats pointing to your

00:06:41,919 --> 00:06:45,520
service or cluster

00:06:43,039 --> 00:06:48,560
but when it comes to new service

00:06:45,520 --> 00:06:51,599
launches or service deprecations

00:06:48,560 --> 00:06:52,960
sometimes developers only address the

00:06:51,599 --> 00:06:55,759
route definitions

00:06:52,960 --> 00:06:57,680
and forget the clusters or vice versa so

00:06:55,759 --> 00:06:59,919
for example in the second row

00:06:57,680 --> 00:07:01,280
you see that there's no route definition

00:06:59,919 --> 00:07:04,400
pointing to

00:07:01,280 --> 00:07:06,400
the service and this could mean that um

00:07:04,400 --> 00:07:08,160
the developer didn't leave any routes

00:07:06,400 --> 00:07:09,440
which means the cluster definition isn't

00:07:08,160 --> 00:07:12,479
being used

00:07:09,440 --> 00:07:15,440
or they deprecated the routes and forgot

00:07:12,479 --> 00:07:18,479
to remove the cluster

00:07:15,440 --> 00:07:21,440
while this cluster is not accessible

00:07:18,479 --> 00:07:22,560
by outside users um your control plane

00:07:21,440 --> 00:07:24,560
is still creating

00:07:22,560 --> 00:07:26,000
unnecessary resources here and sending

00:07:24,560 --> 00:07:28,560
them to side cars

00:07:26,000 --> 00:07:30,160
in addition um it just creates tech da

00:07:28,560 --> 00:07:32,400
and can make reading through

00:07:30,160 --> 00:07:33,280
configs confusing since the service is

00:07:32,400 --> 00:07:35,599
presumably

00:07:33,280 --> 00:07:36,880
no longer being used or isn't currently

00:07:35,599 --> 00:07:39,759
being used

00:07:36,880 --> 00:07:40,479
um and then in the third scenario you

00:07:39,759 --> 00:07:43,199
have

00:07:40,479 --> 00:07:45,360
accessible routes that are pointing to a

00:07:43,199 --> 00:07:46,479
cluster that isn't configured or doesn't

00:07:45,360 --> 00:07:50,000
exist

00:07:46,479 --> 00:07:52,560
um in this scenario envoy will return

00:07:50,000 --> 00:07:53,520
a 503 to request going to these routes

00:07:52,560 --> 00:07:55,680
because

00:07:53,520 --> 00:07:56,960
it doesn't see any healthy members for

00:07:55,680 --> 00:07:59,360
this cluster

00:07:56,960 --> 00:08:01,360
um and obviously you don't want your

00:07:59,360 --> 00:08:04,319
users to be hitting 503s

00:08:01,360 --> 00:08:04,800
for no reason so both checks here can

00:08:04,319 --> 00:08:06,720
prevent

00:08:04,800 --> 00:08:08,319
human error from derailing a service

00:08:06,720 --> 00:08:10,960
launch or deprecation

00:08:08,319 --> 00:08:14,240
um which usually happens when someone

00:08:10,960 --> 00:08:14,240
forgets one of the configs

00:08:15,280 --> 00:08:18,879
next to validate the bootstrap config we

00:08:17,759 --> 00:08:21,440
make use of

00:08:18,879 --> 00:08:22,400
a couple of open source tools the first

00:08:21,440 --> 00:08:25,199
one i'll discuss

00:08:22,400 --> 00:08:25,759
is the validation server this refers to

00:08:25,199 --> 00:08:27,919
running

00:08:25,759 --> 00:08:28,800
the envoy binary in validation mode

00:08:27,919 --> 00:08:32,320
which you can set

00:08:28,800 --> 00:08:34,000
via the command line flag mode um

00:08:32,320 --> 00:08:35,599
and what this does is it takes your

00:08:34,000 --> 00:08:36,320
binary and it takes your bootstrap

00:08:35,599 --> 00:08:39,599
config

00:08:36,320 --> 00:08:42,719
and it tries to boot up envoy without

00:08:39,599 --> 00:08:44,399
starting workers but it will

00:08:42,719 --> 00:08:46,160
go through the server initialization

00:08:44,399 --> 00:08:48,080
process as far as it can and if there

00:08:46,160 --> 00:08:51,600
are no errors it will exit

00:08:48,080 --> 00:08:51,600
it will exit successfully

00:08:51,760 --> 00:08:55,839
the next tool we use is the config load

00:08:54,240 --> 00:08:56,800
check tool and you can see the docs on

00:08:55,839 --> 00:08:59,440
the left

00:08:56,800 --> 00:09:00,160
this is a standalone binary which you

00:08:59,440 --> 00:09:03,120
can run

00:09:00,160 --> 00:09:05,600
on all of your bootstrap configs and it

00:09:03,120 --> 00:09:08,560
basically checks that

00:09:05,600 --> 00:09:10,000
all the values in the fields are valid

00:09:08,560 --> 00:09:12,800
as defined by the proto

00:09:10,000 --> 00:09:14,720
and that the schema is a valid envoy

00:09:12,800 --> 00:09:16,640
schema

00:09:14,720 --> 00:09:17,760
we run both of these checks on all of

00:09:16,640 --> 00:09:20,640
our pull requests

00:09:17,760 --> 00:09:22,000
in ci and that just makes reviewing

00:09:20,640 --> 00:09:23,839
these changes so much easier

00:09:22,000 --> 00:09:25,200
because as the reviewer you already know

00:09:23,839 --> 00:09:27,519
that the config

00:09:25,200 --> 00:09:28,720
is a valid envoy config and so you only

00:09:27,519 --> 00:09:32,240
need to

00:09:28,720 --> 00:09:36,880
um ensure that the change

00:09:32,240 --> 00:09:38,640
does what it should

00:09:36,880 --> 00:09:40,320
i'll now hand it over to jyoti to

00:09:38,640 --> 00:09:43,279
discuss the router check tool and its

00:09:40,320 --> 00:09:46,399
various functionalities

00:09:43,279 --> 00:09:46,880
thank you lisa next i'm going to talk

00:09:46,399 --> 00:09:49,200
about

00:09:46,880 --> 00:09:50,000
the router check tool the part of

00:09:49,200 --> 00:09:52,080
configuration

00:09:50,000 --> 00:09:54,480
in most flux over the last few years

00:09:52,080 --> 00:09:56,640
have been modifications to the routes

00:09:54,480 --> 00:09:58,959
routes work in a very sensitive way the

00:09:56,640 --> 00:10:00,800
routing engine runs an incoming request

00:09:58,959 --> 00:10:02,640
over a set of routing rules and the

00:10:00,800 --> 00:10:04,800
first one to match wins

00:10:02,640 --> 00:10:05,839
this becomes risky in a high flux change

00:10:04,800 --> 00:10:08,000
scenario

00:10:05,839 --> 00:10:09,360
a route mistakenly added at the top of

00:10:08,000 --> 00:10:11,360
the list

00:10:09,360 --> 00:10:13,040
can black hole all traffic can cause

00:10:11,360 --> 00:10:16,240
incidents

00:10:13,040 --> 00:10:18,880
envoy has a router check tool executable

00:10:16,240 --> 00:10:19,760
this exercises the routing engine and

00:10:18,880 --> 00:10:22,560
runs it

00:10:19,760 --> 00:10:23,360
over the routing configurations given it

00:10:22,560 --> 00:10:26,399
lets us add

00:10:23,360 --> 00:10:28,240
unit tests check field applications add

00:10:26,399 --> 00:10:30,079
code coverage constraints

00:10:28,240 --> 00:10:31,600
test complex routing configurations

00:10:30,079 --> 00:10:35,519
based on header match

00:10:31,600 --> 00:10:40,320
run time and weight cluster configs

00:10:35,519 --> 00:10:42,000
we'll look at how to write the tests

00:10:40,320 --> 00:10:43,839
and in test for code is a well-known

00:10:42,000 --> 00:10:46,079
pattern there's

00:10:43,839 --> 00:10:48,959
a subject under test defined by test

00:10:46,079 --> 00:10:51,839
name some setup and assertions

00:10:48,959 --> 00:10:53,839
similarly routing tests have it name a

00:10:51,839 --> 00:10:55,200
set of input conditions and a set of

00:10:53,839 --> 00:10:58,560
assertions

00:10:55,200 --> 00:11:00,640
the tests always run the input route

00:10:58,560 --> 00:11:03,600
through the routing engine and compares

00:11:00,640 --> 00:11:06,079
the assertions with the actual results

00:11:03,600 --> 00:11:07,040
let's follow an example imagine we have

00:11:06,079 --> 00:11:10,000
a routing table

00:11:07,040 --> 00:11:11,760
assured on the left picture imagine

00:11:10,000 --> 00:11:13,120
thousands of switch routes

00:11:11,760 --> 00:11:15,120
one can imagine the plight of the

00:11:13,120 --> 00:11:17,200
developer who is making changes to such

00:11:15,120 --> 00:11:19,120
a long conflict

00:11:17,200 --> 00:11:20,480
we need a way to prevent regressions and

00:11:19,120 --> 00:11:22,560
have the developer make

00:11:20,480 --> 00:11:24,480
change and find out any mistake in the

00:11:22,560 --> 00:11:26,240
pr

00:11:24,480 --> 00:11:28,000
on the right there are a few examples of

00:11:26,240 --> 00:11:30,160
how a test looks like

00:11:28,000 --> 00:11:31,200
it starts the test name there is an

00:11:30,160 --> 00:11:34,160
input section

00:11:31,200 --> 00:11:34,880
which works as a test setup it has the

00:11:34,160 --> 00:11:38,320
url

00:11:34,880 --> 00:11:40,320
the method headers etc the tool has a

00:11:38,320 --> 00:11:41,760
strict set of assistants

00:11:40,320 --> 00:11:44,160
the tool runs the config through the

00:11:41,760 --> 00:11:46,240
routing engine and matches the

00:11:44,160 --> 00:11:48,560
resulting cluster name path or host

00:11:46,240 --> 00:11:50,480
rewrites and redirects

00:11:48,560 --> 00:11:53,200
this was great and we took all our

00:11:50,480 --> 00:11:55,920
routes and added tests for all of them

00:11:53,200 --> 00:11:57,760
we used our telemetry and automated the

00:11:55,920 --> 00:12:00,000
test generation too

00:11:57,760 --> 00:12:02,160
this means an existing route can never

00:12:00,000 --> 00:12:06,399
regress anymore due to a bad change

00:12:02,160 --> 00:12:06,399
and we can detect them right in the pr

00:12:07,680 --> 00:12:11,519
let's run the test and see how it looks

00:12:09,279 --> 00:12:15,040
like the tool takes a routing

00:12:11,519 --> 00:12:15,040
configuration and a test file

00:12:17,279 --> 00:12:20,880
it shows a success and failure using

00:12:19,440 --> 00:12:23,360
exit code

00:12:20,880 --> 00:12:25,519
exit code 0 is success and anything else

00:12:23,360 --> 00:12:28,240
is a failure

00:12:25,519 --> 00:12:29,839
the tests aren't verbose by default you

00:12:28,240 --> 00:12:31,920
could add verbosity by adding

00:12:29,839 --> 00:12:33,920
the details flag on the command line and

00:12:31,920 --> 00:12:36,079
check the results using

00:12:33,920 --> 00:12:38,240
taller question mark which shows the

00:12:36,079 --> 00:12:40,399
last exit code

00:12:38,240 --> 00:12:42,240
when we have hundreds of routes adding

00:12:40,399 --> 00:12:43,360
verbosity cost more friction than we

00:12:42,240 --> 00:12:45,920
wanted

00:12:43,360 --> 00:12:48,000
the shift was new and developers did not

00:12:45,920 --> 00:12:50,560
understand the testing semantics

00:12:48,000 --> 00:12:51,680
we added another flag only show failures

00:12:50,560 --> 00:12:54,000
and the pr failure

00:12:51,680 --> 00:12:55,120
logs would have exactly the tests that

00:12:54,000 --> 00:12:57,440
failed

00:12:55,120 --> 00:12:58,720
making failures easier to understand it

00:12:57,440 --> 00:13:02,720
prints the test names

00:12:58,720 --> 00:13:02,720
and all the assertions that failed

00:13:04,240 --> 00:13:09,040
all this was exciting but the tool did

00:13:06,240 --> 00:13:10,880
not have a way of enforcing adding tests

00:13:09,040 --> 00:13:13,120
developers were able to work around the

00:13:10,880 --> 00:13:15,200
stop gap phase of test enforcement

00:13:13,120 --> 00:13:16,959
we decided we needed a way to add code

00:13:15,200 --> 00:13:18,959
coverage to the tool

00:13:16,959 --> 00:13:20,480
there are two ways of adding coverage

00:13:18,959 --> 00:13:22,720
first one is shallow

00:13:20,480 --> 00:13:24,639
and just checks that there is a test for

00:13:22,720 --> 00:13:26,320
every routing rule

00:13:24,639 --> 00:13:28,800
the second one is more strict and

00:13:26,320 --> 00:13:30,160
enforces writing all assertions for each

00:13:28,800 --> 00:13:31,760
test

00:13:30,160 --> 00:13:33,279
this gives us the comfort that all

00:13:31,760 --> 00:13:34,560
ascertains have been tested with a

00:13:33,279 --> 00:13:38,160
developer and they know

00:13:34,560 --> 00:13:40,800
what they intend to do in the example

00:13:38,160 --> 00:13:42,880
the third box shows an example of a

00:13:40,800 --> 00:13:45,040
failing test which is complaining about

00:13:42,880 --> 00:13:49,839
low code coverage and tells us which

00:13:45,040 --> 00:13:49,839
particular accessions are failing

00:13:52,720 --> 00:13:57,839
like any production system

00:13:55,839 --> 00:13:59,680
our infra is based on runtime configs

00:13:57,839 --> 00:14:01,279
for safe rollouts

00:13:59,680 --> 00:14:03,600
developers needed a way to flip the

00:14:01,279 --> 00:14:06,160
runtime in config and test how the

00:14:03,600 --> 00:14:07,839
routes behaved we added new fields in

00:14:06,160 --> 00:14:09,680
the input to crank the runtime

00:14:07,839 --> 00:14:11,519
using some random values and test the

00:14:09,680 --> 00:14:14,839
output we had now

00:14:11,519 --> 00:14:17,279
almost 100 question code coverage in our

00:14:14,839 --> 00:14:19,199
system

00:14:17,279 --> 00:14:22,000
routes behave differently based on

00:14:19,199 --> 00:14:24,079
headers if headers if you wish them to

00:14:22,000 --> 00:14:25,040
we needed a way to enforce testing on

00:14:24,079 --> 00:14:27,360
these routes

00:14:25,040 --> 00:14:28,560
we can supply you can supply headers in

00:14:27,360 --> 00:14:32,240
the test setup and

00:14:28,560 --> 00:14:32,240
test the behavior of the routes

00:14:36,320 --> 00:14:39,839
constantly updating the on-way binary

00:14:38,160 --> 00:14:41,519
comes at a cost

00:14:39,839 --> 00:14:43,279
there are fields getting deprecated all

00:14:41,519 --> 00:14:44,720
the time and having them in the system

00:14:43,279 --> 00:14:47,680
introduces spectate

00:14:44,720 --> 00:14:49,360
and a higher migration time later we

00:14:47,680 --> 00:14:49,920
added a deprecated field check in the

00:14:49,360 --> 00:14:52,160
tool

00:14:49,920 --> 00:14:53,839
so that it fails whenever it observes a

00:14:52,160 --> 00:14:55,680
deprecated field

00:14:53,839 --> 00:14:57,279
we quickly resolve it since usually it's

00:14:55,680 --> 00:14:59,920
one or two fields at a time

00:14:57,279 --> 00:15:02,399
and doesn't stay long enough to become

00:14:59,920 --> 00:15:02,399
risky

00:15:03,430 --> 00:15:06,639
[Music]

00:15:04,560 --> 00:15:08,560
adding tests for untested parts in the

00:15:06,639 --> 00:15:10,880
system is a culture shift

00:15:08,560 --> 00:15:11,680
it needs help from developers to test it

00:15:10,880 --> 00:15:14,160
and also

00:15:11,680 --> 00:15:15,600
a few curious ones to work around it so

00:15:14,160 --> 00:15:18,160
that we can be

00:15:15,600 --> 00:15:19,680
uh we can put in better enforcement we

00:15:18,160 --> 00:15:22,240
had a bumpy ride while putting it

00:15:19,680 --> 00:15:23,680
in our system but in the end it was a

00:15:22,240 --> 00:15:25,440
win-win for everyone

00:15:23,680 --> 00:15:27,199
the detouring team saved the time spent

00:15:25,440 --> 00:15:28,240
by on calls eyeballing routing

00:15:27,199 --> 00:15:31,680
configurations

00:15:28,240 --> 00:15:34,000
and help developers to ship stuff faster

00:15:31,680 --> 00:15:36,959
i'll give it away to lisa to talk about

00:15:34,000 --> 00:15:36,959
the future directions

00:15:37,440 --> 00:15:41,360
great thanks jody um so hopefully

00:15:40,079 --> 00:15:42,959
through this presentation

00:15:41,360 --> 00:15:45,279
you've seen the different ways you can

00:15:42,959 --> 00:15:46,959
utilize open source tooling or writing

00:15:45,279 --> 00:15:49,440
your own scripts to

00:15:46,959 --> 00:15:50,959
automate the testing and validation of

00:15:49,440 --> 00:15:52,880
envoy configs

00:15:50,959 --> 00:15:54,880
um and while this is really powerful i

00:15:52,880 --> 00:15:57,120
mean it certainly helped lift

00:15:54,880 --> 00:15:58,880
keep up with our huge ammo configs

00:15:57,120 --> 00:16:02,160
there's still a lot of room for

00:15:58,880 --> 00:16:05,519
improvement and how we

00:16:02,160 --> 00:16:05,519
build the tool and to test these

00:16:07,279 --> 00:16:11,600
so first off um envoy has a ton of

00:16:10,320 --> 00:16:13,680
different features

00:16:11,600 --> 00:16:15,120
but there's still not test support for

00:16:13,680 --> 00:16:18,560
all of these features

00:16:15,120 --> 00:16:20,000
um at least at lyft our contributions

00:16:18,560 --> 00:16:22,240
have mostly been spurred by

00:16:20,000 --> 00:16:24,240
demand from our developers so for

00:16:22,240 --> 00:16:26,240
example the router check tool didn't

00:16:24,240 --> 00:16:29,040
always have the capability to

00:16:26,240 --> 00:16:29,839
calculate coverage or have test support

00:16:29,040 --> 00:16:33,920
for

00:16:29,839 --> 00:16:33,920
runtime values and flags or

00:16:34,240 --> 00:16:37,360
header manipulation and checking header

00:16:36,320 --> 00:16:40,399
values

00:16:37,360 --> 00:16:42,480
uh and while those are supported now

00:16:40,399 --> 00:16:45,600
there's still a bunch of features that

00:16:42,480 --> 00:16:46,000
users want such as cores or checking

00:16:45,600 --> 00:16:48,000
that

00:16:46,000 --> 00:16:49,040
your direct response rate returns the

00:16:48,000 --> 00:16:52,160
expected

00:16:49,040 --> 00:16:53,519
status code and so there's definitely

00:16:52,160 --> 00:16:55,279
plenty of room to

00:16:53,519 --> 00:16:59,120
increase the kind of behavior that can

00:16:55,279 --> 00:16:59,120
be tested with the router check tool

00:16:59,360 --> 00:17:03,040
building off of this one major

00:17:01,680 --> 00:17:04,400
improvement would be utilizing

00:17:03,040 --> 00:17:07,439
production code

00:17:04,400 --> 00:17:10,240
um currently the router check tool uh

00:17:07,439 --> 00:17:12,160
uses the same routing function as you

00:17:10,240 --> 00:17:14,720
know on void production itself

00:17:12,160 --> 00:17:16,959
but when it comes to things like header

00:17:14,720 --> 00:17:19,520
validation it's more or less a copy of

00:17:16,959 --> 00:17:20,640
the code that runs in production

00:17:19,520 --> 00:17:22,400
and this is also one of the main

00:17:20,640 --> 00:17:23,520
roadblocks to implementing something

00:17:22,400 --> 00:17:26,240
like cores

00:17:23,520 --> 00:17:27,919
testing support because ideally you want

00:17:26,240 --> 00:17:30,799
to be able to use the same code as

00:17:27,919 --> 00:17:32,480
production so that

00:17:30,799 --> 00:17:33,919
testing support is consistent and

00:17:32,480 --> 00:17:35,760
doesn't diverge

00:17:33,919 --> 00:17:37,679
and also just makes adding test support

00:17:35,760 --> 00:17:40,160
a lot less brutal because

00:17:37,679 --> 00:17:42,160
um as you may know envoy open source

00:17:40,160 --> 00:17:45,200
envoy gets a lot of changes

00:17:42,160 --> 00:17:46,559
every day and so um

00:17:45,200 --> 00:17:49,919
just copying the code over from

00:17:46,559 --> 00:17:52,080
production is not very feasible

00:17:49,919 --> 00:17:53,039
and then finally i think the ideal state

00:17:52,080 --> 00:17:54,880
of

00:17:53,039 --> 00:17:56,160
uh the tooling would be having true

00:17:54,880 --> 00:17:58,559
black box testing

00:17:56,160 --> 00:18:00,640
what this would mean is just having to

00:17:58,559 --> 00:18:02,880
input a full envoy config

00:18:00,640 --> 00:18:04,720
versus knowing specific route inputs for

00:18:02,880 --> 00:18:06,480
your unit tests beforehand

00:18:04,720 --> 00:18:08,400
and this way users could simulate

00:18:06,480 --> 00:18:09,360
request behavior without having to come

00:18:08,400 --> 00:18:11,760
up with

00:18:09,360 --> 00:18:14,240
the certain test cases they want and

00:18:11,760 --> 00:18:15,840
just inspect the resultant response and

00:18:14,240 --> 00:18:18,559
you know this could be used hand-in-hand

00:18:15,840 --> 00:18:20,240
with the existing unit testing flow but

00:18:18,559 --> 00:18:22,400
i think this particular approach also

00:18:20,240 --> 00:18:24,000
lends itself well to a ui based way of

00:18:22,400 --> 00:18:25,760
testing the routing table

00:18:24,000 --> 00:18:27,280
in which you can just input some

00:18:25,760 --> 00:18:30,480
parameters and

00:18:27,280 --> 00:18:33,280
um see what the resultant behavior is

00:18:30,480 --> 00:18:34,640
and that might be um something that's

00:18:33,280 --> 00:18:36,960
more intuitive for

00:18:34,640 --> 00:18:37,760
service owners instead of having to fill

00:18:36,960 --> 00:18:40,799
out

00:18:37,760 --> 00:18:42,880
the values for very specific envoy route

00:18:40,799 --> 00:18:45,200
configuration fields

00:18:42,880 --> 00:18:46,720
um so yeah definitely a lot of room for

00:18:45,200 --> 00:18:48,720
improvement in the router check tool

00:18:46,720 --> 00:18:51,679
and we'd love to chat if you are

00:18:48,720 --> 00:18:55,120
interested in contributing

00:18:51,679 --> 00:18:56,240
with that um that concludes our talk and

00:18:55,120 --> 00:18:59,520
please let us know if you have any

00:18:56,240 --> 00:18:59,520
questions thank you

00:18:59,600 --> 00:19:01,760
hi

00:19:03,360 --> 00:19:10,000
there questions around uh

00:19:06,480 --> 00:19:12,240
yaml so yeah we have a lot of camels we

00:19:10,000 --> 00:19:15,600
are temperatized using jinja

00:19:12,240 --> 00:19:18,799
and we put together a part of our

00:19:15,600 --> 00:19:20,640
vr outputs or artifacts and they go land

00:19:18,799 --> 00:19:25,840
on the side cars

00:19:20,640 --> 00:19:25,840
yeah a lot of camels

00:19:45,120 --> 00:19:48,640
and the question about being a

00:19:47,200 --> 00:19:51,919
standalone tool

00:19:48,640 --> 00:19:55,600
so it's a part of a different folder

00:19:51,919 --> 00:19:58,799
test tools and you can use a different

00:19:55,600 --> 00:19:59,600
build target to build the exe and land

00:19:58,799 --> 00:20:02,640
in your

00:19:59,600 --> 00:20:06,000
pr flows and

00:20:02,640 --> 00:20:10,400
give it the files that will just exist

00:20:06,000 --> 00:20:10,400
the test bind is not only

00:20:13,520 --> 00:20:19,679
the deployment takes

00:20:16,559 --> 00:20:20,480
uh yeah so we do defer deeper ac

00:20:19,679 --> 00:20:23,520
deployments

00:20:20,480 --> 00:20:26,480
uh and

00:20:23,520 --> 00:20:27,600
the sidecar the the the gambles and

00:20:26,480 --> 00:20:29,840
templates are already

00:20:27,600 --> 00:20:30,880
predefined for production staging and

00:20:29,840 --> 00:20:34,720
development

00:20:30,880 --> 00:20:37,840
so that doesn't take our time um

00:20:34,720 --> 00:20:42,240
but yeah we do

00:20:37,840 --> 00:20:45,919
safe routes probably in the span of

00:20:42,240 --> 00:20:45,919
five to ten minutes for easy

00:20:50,000 --> 00:20:54,640
yeah i think around 10 minutes crazy

00:20:52,000 --> 00:20:54,640
sounds great

00:20:59,200 --> 00:21:02,320
do you know why we went with jinja or

00:21:00,960 --> 00:21:05,520
the historical contract

00:21:02,320 --> 00:21:06,799
for that it's probably an artifact of

00:21:05,520 --> 00:21:09,280
how it was written

00:21:06,799 --> 00:21:10,480
a few years back and we haven't moved it

00:21:09,280 --> 00:21:17,840
around yet

00:21:10,480 --> 00:21:17,840
but probably that

00:21:30,960 --> 00:21:34,799
um so our control plane will fetch the

00:21:33,760 --> 00:21:36,559
envoy routes

00:21:34,799 --> 00:21:39,280
there's like a file that we write the

00:21:36,559 --> 00:21:41,760
routes to s3 and i'll sync that

00:21:39,280 --> 00:21:43,520
um at a given time interval and then it

00:21:41,760 --> 00:21:45,039
will create the route configuration

00:21:43,520 --> 00:21:46,880
objects from that

00:21:45,039 --> 00:21:49,600
information and then send it down to

00:21:46,880 --> 00:21:49,600
assign cars

00:21:54,799 --> 00:21:58,080
and we also use a dipping mechanism

00:21:57,360 --> 00:22:00,960
based on

00:21:58,080 --> 00:22:01,360
a manifest version so only if there's a

00:22:00,960 --> 00:22:04,720
diff

00:22:01,360 --> 00:22:13,840
in the sd file only then

00:22:04,720 --> 00:22:13,840
it gets applied otherwise

00:22:28,240 --> 00:22:41,840
yeah it's uh on an interval

00:22:50,240 --> 00:22:55,760
yeah about the

00:22:53,760 --> 00:22:56,880
so i'm just not using latest vector

00:22:55,760 --> 00:23:00,000
versions we

00:22:56,880 --> 00:23:00,799
had trouble there we had to change

00:23:00,000 --> 00:23:02,320
services

00:23:00,799 --> 00:23:03,919
which were using an older site

00:23:02,320 --> 00:23:06,240
conversion

00:23:03,919 --> 00:23:06,960
um right now there are mechanisms in

00:23:06,240 --> 00:23:12,240
envoy

00:23:06,960 --> 00:23:15,360
we could use to serve both v2 and v3

00:23:12,240 --> 00:23:16,080
fields using a runtime it was landed

00:23:15,360 --> 00:23:18,799
last

00:23:16,080 --> 00:23:19,360
month i guess but uh it was not

00:23:18,799 --> 00:23:22,159
available

00:23:19,360 --> 00:23:22,880
two few months back so we ended up

00:23:22,159 --> 00:23:25,440
migrating

00:23:22,880 --> 00:23:27,440
all of our side cars to use the latest

00:23:25,440 --> 00:23:29,200
envoy and

00:23:27,440 --> 00:23:30,799
then it worked out but we make sure

00:23:29,200 --> 00:23:33,919
using the dedicated field check

00:23:30,799 --> 00:23:35,840
that there are no debate fields in our

00:23:33,919 --> 00:23:51,840
conflicts and they don't pass prs if

00:23:35,840 --> 00:23:51,840
they are

00:23:57,679 --> 00:24:04,720
uh why are the animals of the files so

00:24:00,480 --> 00:24:06,720
large lisa do you want to take that

00:24:04,720 --> 00:24:08,640
yeah so i mean there are some services

00:24:06,720 --> 00:24:10,720
at lyft that sort of need to

00:24:08,640 --> 00:24:12,000
communicate with the other services so

00:24:10,720 --> 00:24:15,279
as a result

00:24:12,000 --> 00:24:16,480
um like lots of clusters and route

00:24:15,279 --> 00:24:18,960
information for them

00:24:16,480 --> 00:24:20,000
but as a number of services has grown we

00:24:18,960 --> 00:24:23,120
just have a lot of

00:24:20,000 --> 00:24:23,919
user-defined routes um and a lot of sort

00:24:23,120 --> 00:24:27,760
of default

00:24:23,919 --> 00:24:30,960
config content that gets added to every

00:24:27,760 --> 00:24:35,039
services config so i think over time and

00:24:30,960 --> 00:24:35,039
it's just grown a lot in size

00:24:39,919 --> 00:24:44,240
um and i guess to be explicit the

00:24:42,000 --> 00:24:47,840
deprecation check is a flag that you can

00:24:44,240 --> 00:24:47,840
pass in for the router check tool

00:25:04,000 --> 00:25:07,440
yeah we struggle with v2 and v3 quite a

00:25:07,039 --> 00:25:10,080
bit

00:25:07,440 --> 00:25:11,440
but we're about the hump i guess the

00:25:10,080 --> 00:25:13,120
next question is about

00:25:11,440 --> 00:25:15,520
how are they stored in the guitar we

00:25:13,120 --> 00:25:17,039
have a different a separate repo

00:25:15,520 --> 00:25:18,559
just for storing the routes so that

00:25:17,039 --> 00:25:22,400
people can add and

00:25:18,559 --> 00:25:26,720
change routes as for their will

00:25:22,400 --> 00:25:30,400
um we have different mechanisms we

00:25:26,720 --> 00:25:33,760
have uh json-based conflicts that we

00:25:30,400 --> 00:25:37,200
parse and create xds requests out of

00:25:33,760 --> 00:25:39,279
we also have uh

00:25:37,200 --> 00:25:42,080
conflicts which replicate exactly the

00:25:39,279 --> 00:25:44,400
routes and we just

00:25:42,080 --> 00:25:45,200
deserialize them and pass it on to the

00:25:44,400 --> 00:25:48,320
side cars

00:25:45,200 --> 00:25:49,840
so we go both ways there sometimes

00:25:48,320 --> 00:25:51,360
in order to reduce the knobs that we

00:25:49,840 --> 00:25:54,240
expose to the developers

00:25:51,360 --> 00:25:54,880
uh we only allow a particular json

00:25:54,240 --> 00:25:57,279
format

00:25:54,880 --> 00:25:58,400
so that they can put specific fields

00:25:57,279 --> 00:26:01,600
they want to override

00:25:58,400 --> 00:26:04,080
and everything else is uh defaulted um

00:26:01,600 --> 00:26:05,840
but with routes it's probably not very

00:26:04,080 --> 00:26:08,159
useful because people can go

00:26:05,840 --> 00:26:09,520
anywhere and there'll be probably tens

00:26:08,159 --> 00:26:12,080
of 20s or not so

00:26:09,520 --> 00:26:24,240
we'll let that be as a round

00:26:12,080 --> 00:26:28,400
configuration itself

00:26:24,240 --> 00:26:31,520
yeah front proxy yes so we that

00:26:28,400 --> 00:26:39,840
covers a lot of our edge traffic so a

00:26:31,520 --> 00:26:39,840
lot of piano there

00:26:50,840 --> 00:26:53,840
so

00:27:18,840 --> 00:27:21,840
so

00:27:32,159 --> 00:27:36,559
so we have uh two ways of doing traffic

00:27:35,760 --> 00:27:39,760
one is

00:27:36,559 --> 00:27:41,600
through service manifest people can uh

00:27:39,760 --> 00:27:43,520
write configs on their own services

00:27:41,600 --> 00:27:43,840
manifest and the control plane has a way

00:27:43,520 --> 00:27:46,880
of

00:27:43,840 --> 00:27:48,399
picking that those from the s3 and when

00:27:46,880 --> 00:27:50,799
they deployed to development

00:27:48,399 --> 00:27:52,640
they can change only their services

00:27:50,799 --> 00:28:02,000
conflicts and the control plane

00:27:52,640 --> 00:28:03,279
in dev can pick it up

00:28:02,000 --> 00:28:05,120
like no they don't have to check in

00:28:03,279 --> 00:28:08,159
countries exclusively

00:28:05,120 --> 00:28:17,840
they can do a branch and work on top of

00:28:08,159 --> 00:28:17,840
it in development

00:28:28,840 --> 00:28:34,240
so

00:28:30,880 --> 00:28:36,880
i guess we are at time uh almost uh

00:28:34,240 --> 00:28:37,440
one minute so it was great talking about

00:28:36,880 --> 00:28:40,880
this

00:28:37,440 --> 00:28:42,840
uh and thank you guys for listening

00:28:40,880 --> 00:28:45,840
feel free to reach out to us if you have

00:28:42,840 --> 00:28:45,840

YouTube URL: https://www.youtube.com/watch?v=80I1SzsTmLg


