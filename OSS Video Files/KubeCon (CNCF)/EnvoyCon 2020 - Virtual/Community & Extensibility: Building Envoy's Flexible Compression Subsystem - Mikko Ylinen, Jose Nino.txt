Title: Community & Extensibility: Building Envoy's Flexible Compression Subsystem - Mikko Ylinen, Jose Nino
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	Community and Extensibility: Building Envoy's Flexible Compression Subsystem - Mikko Ylinen, Jose Nino

HTTP compression is used by web proxies to compress data before sending it out over the wire. This saves network bandwidth and speeds up transfers. Until its v1.15 release, Envoy implemented limited unidirectional Gzip compression. Through a cross-company (also cross-continent!) collaboration, compression was generalized to its own extension subsystem to make it possible to add new compression schemes, custom implementations of existing formats, and have fully bidirectional (de)decompression. This talk will walk the audience through the evolution of compression in Envoy, highlighting the flexibility of the extension system, and dive into two use cases now possible with compression subsystem: 0-touch bidirectional (de)compression between mobile clients and edge; and new compression implementations now possible, e.g., a compressor utilizing HW accelerators to optimize server compute.
Captions: 
	00:00:00,320 --> 00:00:04,880
all right hey good day good afternoon

00:00:02,960 --> 00:00:06,960
everybody welcome to listen

00:00:04,880 --> 00:00:07,919
to our talk about onward compression

00:00:06,960 --> 00:00:11,599
subsystem

00:00:07,919 --> 00:00:13,599
evolution uh in our talk

00:00:11,599 --> 00:00:14,639
we give a give the law you give the

00:00:13,599 --> 00:00:16,880
story of uh

00:00:14,639 --> 00:00:18,960
the kind of long but very successful

00:00:16,880 --> 00:00:20,720
project to redesign the new onboard

00:00:18,960 --> 00:00:22,960
compression subsystem with

00:00:20,720 --> 00:00:24,320
with some great community collaboration

00:00:22,960 --> 00:00:26,400
and then

00:00:24,320 --> 00:00:30,240
discuss some of its features and and

00:00:26,400 --> 00:00:33,200
future plans

00:00:30,240 --> 00:00:33,920
um but before getting started let us

00:00:33,200 --> 00:00:38,079
introduce

00:00:33,920 --> 00:00:38,079
uh ourselves first

00:00:39,280 --> 00:00:44,000
my name is mikko and i'm a software

00:00:42,000 --> 00:00:46,320
engineer at intel's open source

00:00:44,000 --> 00:00:47,200
cloud software engineering team working

00:00:46,320 --> 00:00:49,920
on

00:00:47,200 --> 00:00:51,520
device enabling for kubernetes and cloud

00:00:49,920 --> 00:00:53,280
native applications

00:00:51,520 --> 00:00:55,360
in in this project i've mostly been

00:00:53,280 --> 00:00:56,239
coaching dimitri who did all the heavy

00:00:55,360 --> 00:00:58,640
lifting but

00:00:56,239 --> 00:01:00,559
uh i've also if you have unavoid

00:00:58,640 --> 00:01:05,039
contributions myself

00:01:00,559 --> 00:01:05,039
mostly on the open ssl side of things

00:01:05,760 --> 00:01:10,479
my name is jose nino and i am an

00:01:08,720 --> 00:01:12,159
engineer at lyft

00:01:10,479 --> 00:01:14,479
where i have worked on networking

00:01:12,159 --> 00:01:15,360
relating related technologies for the

00:01:14,479 --> 00:01:18,080
past

00:01:15,360 --> 00:01:20,320
uh four years uh i was part of the

00:01:18,080 --> 00:01:22,799
initial open source team uh with envoy

00:01:20,320 --> 00:01:24,400
and worked on server-side technologies

00:01:22,799 --> 00:01:26,880
uh for the first two and a half years

00:01:24,400 --> 00:01:28,880
that um i was at lyft and then

00:01:26,880 --> 00:01:30,960
for the last year and a half i've been

00:01:28,880 --> 00:01:33,759
working on a related project

00:01:30,960 --> 00:01:36,479
called envoy mobile which we'll discuss

00:01:33,759 --> 00:01:36,479
a little bit today

00:01:36,560 --> 00:01:41,680
next i want to introduce you dmitry he

00:01:39,439 --> 00:01:44,720
is not in the presentation with us

00:01:41,680 --> 00:01:46,880
today but his contribution to

00:01:44,720 --> 00:01:49,920
the work that we are discussing today

00:01:46,880 --> 00:01:52,560
deserves a special recognition

00:01:49,920 --> 00:01:54,560
moving on to the story how how how the

00:01:52,560 --> 00:01:57,680
unvoiced compression rework

00:01:54,560 --> 00:02:00,640
got started and what we learned from

00:01:57,680 --> 00:02:00,640
from the process

00:02:03,280 --> 00:02:07,119
but let's get started with with some

00:02:05,280 --> 00:02:09,599
common terminology

00:02:07,119 --> 00:02:10,399
and there are lots of variations used

00:02:09,599 --> 00:02:13,200
are used

00:02:10,399 --> 00:02:14,080
across different code bases so we wanted

00:02:13,200 --> 00:02:16,319
to explain

00:02:14,080 --> 00:02:18,319
the ones used in in this presentation

00:02:16,319 --> 00:02:21,440
and in in the envoy

00:02:18,319 --> 00:02:22,239
onward code base um within the

00:02:21,440 --> 00:02:25,120
compression

00:02:22,239 --> 00:02:26,000
subsystem overall we have uh both

00:02:25,120 --> 00:02:29,440
compressors

00:02:26,000 --> 00:02:31,760
and decompressors and they

00:02:29,440 --> 00:02:36,959
compress and decompress data of course

00:02:31,760 --> 00:02:40,000
naturally so

00:02:36,959 --> 00:02:43,280
um and then let's uh next uh let's

00:02:40,000 --> 00:02:43,920
take a look what the http gzip filter in

00:02:43,280 --> 00:02:48,239
in on

00:02:43,920 --> 00:02:50,720
envoy does and uh on the request path

00:02:48,239 --> 00:02:52,480
on the left hand side that the client

00:02:50,720 --> 00:02:55,519
sends a request

00:02:52,480 --> 00:02:57,440
the filter on on android looks for

00:02:55,519 --> 00:03:01,120
matching and gzip

00:02:57,440 --> 00:03:01,120
accept encoding header

00:03:02,959 --> 00:03:07,920
and the filter deletes it and and

00:03:05,519 --> 00:03:11,680
forwards the requests

00:03:07,920 --> 00:03:11,680
to the upstream service

00:03:12,319 --> 00:03:16,159
and when the filter receives the

00:03:14,959 --> 00:03:18,959
response data

00:03:16,159 --> 00:03:20,319
it compresses the data using the gzip

00:03:18,959 --> 00:03:24,560
algorithm

00:03:20,319 --> 00:03:27,440
and finally then onward proxies the gzip

00:03:24,560 --> 00:03:30,799
gzip responds back back to the client so

00:03:27,440 --> 00:03:34,720
this is this is how it how it works and

00:03:30,799 --> 00:03:39,120
basically it is uh limited to only uh

00:03:34,720 --> 00:03:39,120
you know response compression

00:03:40,080 --> 00:03:44,000
uh this all works well if you are

00:03:41,920 --> 00:03:45,360
interested in providing compression

00:03:44,000 --> 00:03:48,400
based on just like

00:03:45,360 --> 00:03:48,799
one existing one one one implementation

00:03:48,400 --> 00:03:52,879
of

00:03:48,799 --> 00:03:54,959
of cheesy but then you might ask

00:03:52,879 --> 00:03:56,879
what if you want to modify that

00:03:54,959 --> 00:04:00,000
implementation say

00:03:56,879 --> 00:04:02,720
uh using hardware accelerated gzip for

00:04:00,000 --> 00:04:03,599
instance or what if you want to use a

00:04:02,720 --> 00:04:05,920
different

00:04:03,599 --> 00:04:06,640
compression algorithm altogether like

00:04:05,920 --> 00:04:09,680
broadly

00:04:06,640 --> 00:04:11,760
broadly compression algorithm or

00:04:09,680 --> 00:04:12,879
finally what if you may also want to

00:04:11,760 --> 00:04:17,199
decompress

00:04:12,879 --> 00:04:18,639
the data at the proxy proxy layer

00:04:17,199 --> 00:04:21,440
these were all the questions that

00:04:18,639 --> 00:04:24,720
remained uh

00:04:21,440 --> 00:04:28,240
and which we kind of asked ourselves

00:04:24,720 --> 00:04:31,280
and that's one of the reason why we got

00:04:28,240 --> 00:04:34,800
started with the work

00:04:31,280 --> 00:04:34,800
that we did here

00:04:36,639 --> 00:04:41,280
um well let's look at uh some of the

00:04:39,199 --> 00:04:44,880
existing advantages in in

00:04:41,280 --> 00:04:46,080
envoy um and these were kind of the

00:04:44,880 --> 00:04:48,960
things that allowed

00:04:46,080 --> 00:04:50,320
us to to start thinking uh the redesign

00:04:48,960 --> 00:04:53,360
a more comprehensive

00:04:50,320 --> 00:04:57,840
way and design the comprehensive

00:04:53,360 --> 00:04:57,840
compression subsystem for quarantine

00:04:58,400 --> 00:05:01,680
and first of all enroll is open source

00:05:01,039 --> 00:05:04,479
and

00:05:01,680 --> 00:05:05,600
in in our team basically our motto is uh

00:05:04,479 --> 00:05:08,000
upstream for us

00:05:05,600 --> 00:05:10,639
we wanted to propose changes to the

00:05:08,000 --> 00:05:12,000
upstream and and get them accepted and

00:05:10,639 --> 00:05:14,880
with open source

00:05:12,000 --> 00:05:17,280
this is easily they should be easily

00:05:14,880 --> 00:05:17,280
doable

00:05:17,919 --> 00:05:23,840
um second thing is envoy

00:05:20,960 --> 00:05:25,680
has very clear abstract interfaces for

00:05:23,840 --> 00:05:28,720
instance for compression

00:05:25,680 --> 00:05:30,240
we had these very basic uh basic

00:05:28,720 --> 00:05:33,199
interfaces for

00:05:30,240 --> 00:05:34,479
compressing and decompressing data and

00:05:33,199 --> 00:05:38,160
that

00:05:34,479 --> 00:05:40,639
is just uh provided through the data

00:05:38,160 --> 00:05:40,639
buffers

00:05:42,560 --> 00:05:48,000
and then third and perhaps the most

00:05:45,360 --> 00:05:49,199
important point envoy has a very mature

00:05:48,000 --> 00:05:51,280
extension

00:05:49,199 --> 00:05:53,360
system that allows people to implement

00:05:51,280 --> 00:05:56,319
their own own logic for

00:05:53,360 --> 00:05:56,960
for very well defined extension points

00:05:56,319 --> 00:05:58,720
and we can

00:05:56,960 --> 00:06:00,080
we thought that perhaps compression

00:05:58,720 --> 00:06:04,080
libraries could be the first

00:06:00,080 --> 00:06:04,080
class extension points for online

00:06:05,680 --> 00:06:10,960
uh so with that we just uh

00:06:09,120 --> 00:06:12,400
took the time to prepare the initial

00:06:10,960 --> 00:06:15,360
pull request uh

00:06:12,400 --> 00:06:17,199
to generalize the existing gc filter

00:06:15,360 --> 00:06:20,479
into a compression

00:06:17,199 --> 00:06:22,240
uh algorithm agnostic filter uh

00:06:20,479 --> 00:06:24,000
originally we were expect we were

00:06:22,240 --> 00:06:27,120
expecting very smooth

00:06:24,000 --> 00:06:28,080
process in in up streaming maybe with

00:06:27,120 --> 00:06:30,639
just uh

00:06:28,080 --> 00:06:32,080
a few comments review comments that we

00:06:30,639 --> 00:06:34,560
needed to to address

00:06:32,080 --> 00:06:35,840
and then we should be done and complete

00:06:34,560 --> 00:06:40,240
with this

00:06:35,840 --> 00:06:43,600
with this contribution but uh

00:06:40,240 --> 00:06:44,240
uh it did not go like that we everything

00:06:43,600 --> 00:06:47,759
did not

00:06:44,240 --> 00:06:50,800
go as as we expected and at some point

00:06:47,759 --> 00:06:53,039
as you can see a long time since we

00:06:50,800 --> 00:06:53,919
originally started the purple request to

00:06:53,039 --> 00:06:56,960
work

00:06:53,919 --> 00:06:57,840
simply simply cut the stalls and we did

00:06:56,960 --> 00:07:00,840
not see a

00:06:57,840 --> 00:07:02,160
path getting getting the contribution

00:07:00,840 --> 00:07:04,960
accepted

00:07:02,160 --> 00:07:06,639
and myself and dmitry were like pretty

00:07:04,960 --> 00:07:09,120
puzzled so why is it

00:07:06,639 --> 00:07:09,759
so hard to get this accepted especially

00:07:09,120 --> 00:07:12,800
because

00:07:09,759 --> 00:07:15,199
uh the contribution

00:07:12,800 --> 00:07:18,240
the implementation was meeting all the

00:07:15,199 --> 00:07:22,160
needs that many others also had asked in

00:07:18,240 --> 00:07:24,639
in the past and at this point we were

00:07:22,160 --> 00:07:25,360
we were even like considering going with

00:07:24,639 --> 00:07:28,080
with the plan

00:07:25,360 --> 00:07:30,479
plan b and uh in implementing what we

00:07:28,080 --> 00:07:32,560
wanted for the hardware accelerator

00:07:30,479 --> 00:07:33,599
you're just using custom external

00:07:32,560 --> 00:07:37,039
filters that

00:07:33,599 --> 00:07:37,039
meets meets our needs

00:07:38,800 --> 00:07:44,000
but then luckily the work was spotted by

00:07:42,639 --> 00:07:47,120
michael and jose from

00:07:44,000 --> 00:07:50,160
lyft somewhere um i think

00:07:47,120 --> 00:07:52,720
in february time frame this year and

00:07:50,160 --> 00:07:53,680
they had seen the work and they also had

00:07:52,720 --> 00:07:56,800
the need

00:07:53,680 --> 00:07:59,199
for envoy decompression in envoy mobile

00:07:56,800 --> 00:08:02,160
to to keep their public apis

00:07:59,199 --> 00:08:02,560
with with compressed responses and then

00:08:02,160 --> 00:08:05,039
do

00:08:02,560 --> 00:08:07,360
decompression in on the client client

00:08:05,039 --> 00:08:07,360
side

00:08:09,520 --> 00:08:14,319
so it's uh it's not always just open

00:08:12,400 --> 00:08:16,560
source that makes these contributions

00:08:14,319 --> 00:08:19,520
possible but especially for big

00:08:16,560 --> 00:08:20,319
features like this contribution that we

00:08:19,520 --> 00:08:23,120
had it's

00:08:20,319 --> 00:08:25,360
really about the community and how the

00:08:23,120 --> 00:08:28,879
community collaborates together

00:08:25,360 --> 00:08:29,759
to kind of complete the last mile and

00:08:28,879 --> 00:08:33,039
getting things

00:08:29,759 --> 00:08:33,039
accepted upstream

00:08:34,000 --> 00:08:40,320
and uh what what we learned from

00:08:37,200 --> 00:08:42,880
from all all these uh

00:08:40,320 --> 00:08:43,760
during the way to do while while getting

00:08:42,880 --> 00:08:48,240
this is

00:08:43,760 --> 00:08:52,560
accepted and uh merged in in upstream so

00:08:48,240 --> 00:08:55,839
um one observation is that uh

00:08:52,560 --> 00:08:58,399
sometimes it's best if you just share

00:08:55,839 --> 00:09:01,600
the big picture the kind of the bigger

00:08:58,399 --> 00:09:04,640
the design idea in in a shared

00:09:01,600 --> 00:09:06,240
document uh to make the conversation

00:09:04,640 --> 00:09:08,160
possible and then

00:09:06,240 --> 00:09:09,920
uh eventually create the kind of

00:09:08,160 --> 00:09:13,839
consensus uh

00:09:09,920 --> 00:09:16,959
about the changes and the way forward

00:09:13,839 --> 00:09:22,160
before before investing a lot of time

00:09:16,959 --> 00:09:24,000
in in in working on on pocs and then

00:09:22,160 --> 00:09:25,680
scratching the work and starting all

00:09:24,000 --> 00:09:27,680
over

00:09:25,680 --> 00:09:29,760
but this document it also helps to build

00:09:27,680 --> 00:09:32,560
the community behind the work which is

00:09:29,760 --> 00:09:34,320
uh super important as we just discussed

00:09:32,560 --> 00:09:36,720
previously

00:09:34,320 --> 00:09:37,519
uh and one other thing we also learned

00:09:36,720 --> 00:09:39,279
that uh

00:09:37,519 --> 00:09:41,360
sometimes all these open source

00:09:39,279 --> 00:09:44,959
contributions they they need

00:09:41,360 --> 00:09:46,080
a lot of patience and that don't give up

00:09:44,959 --> 00:09:49,760
too easily if

00:09:46,080 --> 00:09:54,399
if there's some delay in getting your

00:09:49,760 --> 00:09:54,399
changes reviewed and accepted

00:09:54,720 --> 00:10:01,839
good so um next

00:09:58,640 --> 00:10:04,320
i think we have jose

00:10:01,839 --> 00:10:07,200
going to talk about generalizing that

00:10:04,320 --> 00:10:09,519
the envoy onward compression

00:10:07,200 --> 00:10:10,320
all right thank you mikko so now that we

00:10:09,519 --> 00:10:13,839
have that

00:10:10,320 --> 00:10:16,160
background context of

00:10:13,839 --> 00:10:19,040
what existed in the android compression

00:10:16,160 --> 00:10:20,880
space with the specific gzip filter

00:10:19,040 --> 00:10:22,480
second what were some of the use cases

00:10:20,880 --> 00:10:25,440
that were not possible

00:10:22,480 --> 00:10:26,720
with that previous implementation and

00:10:25,440 --> 00:10:28,959
then

00:10:26,720 --> 00:10:30,160
what advantages existed that could make

00:10:28,959 --> 00:10:32,480
a general compression

00:10:30,160 --> 00:10:35,360
compression system possible in envoy and

00:10:32,480 --> 00:10:37,360
how all that work was possible thanks to

00:10:35,360 --> 00:10:39,200
not only a cross-company collaboration

00:10:37,360 --> 00:10:41,760
between us at lyft and

00:10:39,200 --> 00:10:43,279
the folks at intel but really across

00:10:41,760 --> 00:10:44,959
continent collaboration with

00:10:43,279 --> 00:10:46,320
people in the united states and in

00:10:44,959 --> 00:10:48,640
finland

00:10:46,320 --> 00:10:49,760
so let's dive into uh what we actually

00:10:48,640 --> 00:10:53,120
did in general

00:10:49,760 --> 00:10:54,880
generalizing this compression system so

00:10:53,120 --> 00:10:57,040
the first obvious thing when looking at

00:10:54,880 --> 00:10:59,200
the g-step filter is that

00:10:57,040 --> 00:11:00,320
um while this is what it looks from the

00:10:59,200 --> 00:11:02,640
outside

00:11:00,320 --> 00:11:04,560
if you look under the hood what you have

00:11:02,640 --> 00:11:06,800
is a filter in two parts

00:11:04,560 --> 00:11:08,800
the hdp filter part and then the

00:11:06,800 --> 00:11:12,160
compressor part

00:11:08,800 --> 00:11:13,040
so the if if we zoom in here the htp

00:11:12,160 --> 00:11:16,000
filter part

00:11:13,040 --> 00:11:18,320
deals with the http level concerns like

00:11:16,000 --> 00:11:20,000
looking for the accept encoding header

00:11:18,320 --> 00:11:22,720
like miko was saying or replacing the

00:11:20,000 --> 00:11:26,399
data frames with the compressed data

00:11:22,720 --> 00:11:27,279
and then the filter itself uses the gzip

00:11:26,399 --> 00:11:30,160
compressor

00:11:27,279 --> 00:11:31,440
compressor which it itself is the one

00:11:30,160 --> 00:11:33,600
that is compressing

00:11:31,440 --> 00:11:36,079
the data buffers using the gzip

00:11:33,600 --> 00:11:36,079
algorithm

00:11:36,240 --> 00:11:39,680
so uh going back to the existing

00:11:38,320 --> 00:11:42,560
advantages what became

00:11:39,680 --> 00:11:42,880
evident when looking at the filter this

00:11:42,560 --> 00:11:44,480
way

00:11:42,880 --> 00:11:47,360
is that there was nothing specific in

00:11:44,480 --> 00:11:50,240
the filter that required the compressor

00:11:47,360 --> 00:11:51,440
to behave in a certain way to use gzip

00:11:50,240 --> 00:11:53,040
to compress

00:11:51,440 --> 00:11:54,880
because he used this very simple

00:11:53,040 --> 00:11:57,519
interface that we had seen before

00:11:54,880 --> 00:12:00,079
a compressor only has one function it

00:11:57,519 --> 00:12:02,560
compresses

00:12:00,079 --> 00:12:06,160
so there was a very clear delineation of

00:12:02,560 --> 00:12:06,160
where we could divide the filter

00:12:06,720 --> 00:12:11,040
and then plug in a compressor library

00:12:09,600 --> 00:12:14,639
regardless of the

00:12:11,040 --> 00:12:16,720
compression algorithm that it used

00:12:14,639 --> 00:12:17,760
so now that we had this generic

00:12:16,720 --> 00:12:19,839
compressor

00:12:17,760 --> 00:12:21,440
working within the generic http

00:12:19,839 --> 00:12:23,839
compressor filter

00:12:21,440 --> 00:12:26,800
we could raise the compressor itself to

00:12:23,839 --> 00:12:28,959
be a first class extension in envoy

00:12:26,800 --> 00:12:30,480
and so this is done using the classes

00:12:28,959 --> 00:12:32,880
that we see here

00:12:30,480 --> 00:12:34,240
where we have a class that derives from

00:12:32,880 --> 00:12:36,800
the config

00:12:34,240 --> 00:12:39,120
type factory class and then every

00:12:36,800 --> 00:12:41,680
particular implementation

00:12:39,120 --> 00:12:42,720
of of a compressor library derives from

00:12:41,680 --> 00:12:45,760
that in turn

00:12:42,720 --> 00:12:47,680
so now our gzip compressor or perhaps

00:12:45,760 --> 00:12:49,920
our broadly compressor in the future

00:12:47,680 --> 00:12:51,760
derived from the name compressor library

00:12:49,920 --> 00:12:54,320
config class

00:12:51,760 --> 00:12:56,320
and then the compressor filter uses this

00:12:54,320 --> 00:12:58,240
compressor factory class the generic

00:12:56,320 --> 00:13:01,200
compressor factory class

00:12:58,240 --> 00:13:02,399
to create compressors with which to

00:13:01,200 --> 00:13:06,160
actually compress

00:13:02,399 --> 00:13:09,120
the data in other words

00:13:06,160 --> 00:13:09,680
we achieved the first of our goals we

00:13:09,120 --> 00:13:12,079
are now

00:13:09,680 --> 00:13:13,120
able to have any number of different

00:13:12,079 --> 00:13:15,839
compressor screen

00:13:13,120 --> 00:13:16,639
schemes in envoy without each having to

00:13:15,839 --> 00:13:19,680
implement

00:13:16,639 --> 00:13:20,000
an http filter themselves we can just

00:13:19,680 --> 00:13:22,079
plug

00:13:20,000 --> 00:13:23,839
in any of them into the generic

00:13:22,079 --> 00:13:26,399
compressor filter so whether it is a

00:13:23,839 --> 00:13:28,959
gzip compressor or a bradley compressor

00:13:26,399 --> 00:13:32,079
or like our friends at intel hardware

00:13:28,959 --> 00:13:32,079
accelerated gzip

00:13:32,800 --> 00:13:37,279
all right so on to our second goal what

00:13:35,120 --> 00:13:40,160
about a full compression system

00:13:37,279 --> 00:13:41,920
uh one that can both compress and

00:13:40,160 --> 00:13:43,920
decompress data

00:13:41,920 --> 00:13:45,839
well that was easier now that we had a

00:13:43,920 --> 00:13:47,680
generic implementation of a compressor

00:13:45,839 --> 00:13:49,279
filter

00:13:47,680 --> 00:13:51,120
we used the same principle of

00:13:49,279 --> 00:13:54,639
abstraction using the

00:13:51,120 --> 00:13:57,040
generic decompressor class

00:13:54,639 --> 00:13:58,320
and created a generic decompressor

00:13:57,040 --> 00:14:01,600
filter that used

00:13:58,320 --> 00:14:04,720
a portable generic decompressor

00:14:01,600 --> 00:14:07,839
thus creating a fully pluggable hdp

00:14:04,720 --> 00:14:07,839
decompressor filter

00:14:07,920 --> 00:14:11,680
so parallel to the compressors as first

00:14:11,199 --> 00:14:14,160
class

00:14:11,680 --> 00:14:15,279
extension points in android we created

00:14:14,160 --> 00:14:17,680
decompressors

00:14:15,279 --> 00:14:20,079
as first class extension points in

00:14:17,680 --> 00:14:20,079
android

00:14:20,160 --> 00:14:24,880
thus we pave the way for having not only

00:14:23,279 --> 00:14:27,360
a gcp compressor

00:14:24,880 --> 00:14:28,560
but also having any number of the

00:14:27,360 --> 00:14:30,880
compressors

00:14:28,560 --> 00:14:33,920
to parallel the com the compressors that

00:14:30,880 --> 00:14:33,920
we were adding

00:14:34,399 --> 00:14:40,240
so now we have a complete generic

00:14:37,519 --> 00:14:41,199
end-to-end compression solution powered

00:14:40,240 --> 00:14:45,600
by android

00:14:41,199 --> 00:14:48,320
where service b can send a response

00:14:45,600 --> 00:14:50,880
and then the http compressor filter can

00:14:48,320 --> 00:14:54,000
compress that response

00:14:50,880 --> 00:14:57,600
which arrives to service a

00:14:54,000 --> 00:14:58,720
and in turn its http decompressor filter

00:14:57,600 --> 00:15:01,279
can decompress

00:14:58,720 --> 00:15:02,720
the response before proxying it to the

00:15:01,279 --> 00:15:04,959
service itself

00:15:02,720 --> 00:15:06,000
so as you can see compression is

00:15:04,959 --> 00:15:08,079
completely done

00:15:06,000 --> 00:15:10,399
in the network layer without having to

00:15:08,079 --> 00:15:11,120
involve any product engineers owners of

00:15:10,399 --> 00:15:13,839
service a

00:15:11,120 --> 00:15:13,839
or service b

00:15:14,959 --> 00:15:18,560
all right so this is what the android

00:15:17,120 --> 00:15:21,360
compression extension tree

00:15:18,560 --> 00:15:23,120
looks like the common directory

00:15:21,360 --> 00:15:25,279
implements the generic compressor and

00:15:23,120 --> 00:15:27,360
decompressor factory base classes

00:15:25,279 --> 00:15:29,360
that all compressors and decompressors

00:15:27,360 --> 00:15:31,519
derive from

00:15:29,360 --> 00:15:33,120
and then each particular compression

00:15:31,519 --> 00:15:35,360
scheme has its own tree

00:15:33,120 --> 00:15:36,480
where they have a compressor and a

00:15:35,360 --> 00:15:39,120
decompressor

00:15:36,480 --> 00:15:40,000
and potentially a common base class that

00:15:39,120 --> 00:15:42,320
derive

00:15:40,000 --> 00:15:44,160
from you know some scheme specific

00:15:42,320 --> 00:15:47,600
functionality

00:15:44,160 --> 00:15:50,639
so in android currently we have the gzip

00:15:47,600 --> 00:15:52,320
compressor and decompressor but as we

00:15:50,639 --> 00:15:57,120
have been saying the beauty of this

00:15:52,320 --> 00:15:59,360
first class extension is that

00:15:57,120 --> 00:16:01,199
any number of compression schemes can be

00:15:59,360 --> 00:16:03,920
added whether

00:16:01,199 --> 00:16:04,639
added upstream to the the main envoy

00:16:03,920 --> 00:16:09,360
repo

00:16:04,639 --> 00:16:12,560
or in your private build of envoy

00:16:09,360 --> 00:16:15,360
all right so that's a whirlwind tour of

00:16:12,560 --> 00:16:17,360
uh how we generalize decompression uh

00:16:15,360 --> 00:16:18,959
but most exciting we want to present

00:16:17,360 --> 00:16:22,079
some of the case studies

00:16:18,959 --> 00:16:25,839
uh that were enabled thanks to the to

00:16:22,079 --> 00:16:25,839
this generalized compression scheme

00:16:26,800 --> 00:16:30,800
and uh the first one oh sorry we could

00:16:30,079 --> 00:16:33,040
go ahead

00:16:30,800 --> 00:16:34,639
yeah so just time thanks jose so i was

00:16:33,040 --> 00:16:36,480
about to say that our first uh

00:16:34,639 --> 00:16:38,000
case study talks about implementing

00:16:36,480 --> 00:16:42,399
hardware accelerated

00:16:38,000 --> 00:16:42,399
compression for for onward

00:16:44,639 --> 00:16:48,720
um so some a little bit about the

00:16:47,600 --> 00:16:50,959
rationale for

00:16:48,720 --> 00:16:52,240
why why doing hardware accelerated

00:16:50,959 --> 00:16:54,240
compression

00:16:52,240 --> 00:16:56,160
typically hardware acceleration can

00:16:54,240 --> 00:16:59,839
bring several benefits

00:16:56,160 --> 00:17:01,600
to to your application for instance um

00:16:59,839 --> 00:17:03,279
as you know being like very time

00:17:01,600 --> 00:17:05,919
consuming uh process

00:17:03,279 --> 00:17:08,319
it might make sense to overload all this

00:17:05,919 --> 00:17:12,319
compression processing to a dedicated

00:17:08,319 --> 00:17:15,039
co-processor sometimes even like a

00:17:12,319 --> 00:17:18,000
hardware that is completely optimized

00:17:15,039 --> 00:17:20,720
for this particular task

00:17:18,000 --> 00:17:21,760
and then the added benefit with that is

00:17:20,720 --> 00:17:24,640
that then you can

00:17:21,760 --> 00:17:26,720
free cpu cycles for for something more

00:17:24,640 --> 00:17:28,480
important that runs on on the main main

00:17:26,720 --> 00:17:31,760
cpu and then

00:17:28,480 --> 00:17:32,559
uh the co-processor the accelerated core

00:17:31,760 --> 00:17:36,559
processor

00:17:32,559 --> 00:17:36,559
doing all the all the all the work

00:17:41,600 --> 00:17:46,000
in our case we have implemented a

00:17:43,440 --> 00:17:48,559
reference implementation using this uh

00:17:46,000 --> 00:17:50,640
on onward compression subsystem for and

00:17:48,559 --> 00:17:51,840
for an intel quick assist technology

00:17:50,640 --> 00:17:53,840
card

00:17:51,840 --> 00:17:54,960
it's a it's got a dedicated card

00:17:53,840 --> 00:17:58,840
optimized for

00:17:54,960 --> 00:18:00,320
crypto and compression compression

00:17:58,840 --> 00:18:04,240
processing

00:18:00,320 --> 00:18:08,799
and this implementation

00:18:04,240 --> 00:18:11,760
adds a qat compression compressor

00:18:08,799 --> 00:18:12,799
we have it uh implemented in an external

00:18:11,760 --> 00:18:15,440
repository as

00:18:12,799 --> 00:18:18,160
also mentioned it is also with with the

00:18:15,440 --> 00:18:22,320
envoy extension mechanism possible to

00:18:18,160 --> 00:18:26,840
add your custom implementations

00:18:22,320 --> 00:18:30,080
easily living in in their own external

00:18:26,840 --> 00:18:30,480
repositories and the qat compressor we

00:18:30,080 --> 00:18:34,559
have

00:18:30,480 --> 00:18:37,360
uh implemented uses a framework

00:18:34,559 --> 00:18:40,000
what what we have called qat zip and

00:18:37,360 --> 00:18:40,480
then the q a d zip then directly uses

00:18:40,000 --> 00:18:43,600
the

00:18:40,480 --> 00:18:44,240
q a t hardware abstraction layer and the

00:18:43,600 --> 00:18:46,720
driver

00:18:44,240 --> 00:18:48,160
and sending out all the compression

00:18:46,720 --> 00:18:51,200
requests

00:18:48,160 --> 00:18:53,200
to uh to the dedicated co-cooperative

00:18:51,200 --> 00:18:56,480
co-processor

00:18:53,200 --> 00:18:59,440
we have it right now we have it only for

00:18:56,480 --> 00:19:01,520
compressors basically we are able to

00:18:59,440 --> 00:19:03,760
compress the data

00:19:01,520 --> 00:19:05,760
and what we what we are working on right

00:19:03,760 --> 00:19:09,039
now is that we're just

00:19:05,760 --> 00:19:12,640
adding looking to add almost there

00:19:09,039 --> 00:19:15,120
adding the decompressor piece

00:19:12,640 --> 00:19:15,840
for the hardware acceleration as well

00:19:15,120 --> 00:19:19,120
based on

00:19:15,840 --> 00:19:22,080
our our experiments this this piece of

00:19:19,120 --> 00:19:22,640
compression uh in in addition to the

00:19:22,080 --> 00:19:25,679
fact that

00:19:22,640 --> 00:19:28,480
we are also able to free cpu cycles for

00:19:25,679 --> 00:19:28,480
some kidneys

00:19:32,640 --> 00:19:36,000
all right so thank you for that case

00:19:34,960 --> 00:19:38,080
study uh

00:19:36,000 --> 00:19:39,600
there are some published results and we

00:19:38,080 --> 00:19:42,400
will share the link

00:19:39,600 --> 00:19:44,160
with the presentation slides so now

00:19:42,400 --> 00:19:45,360
let's talk about the envoy mobile use

00:19:44,160 --> 00:19:47,280
case

00:19:45,360 --> 00:19:49,280
i want to first give a quick overview of

00:19:47,280 --> 00:19:52,480
the goal of the android mobile project

00:19:49,280 --> 00:19:53,600
and what it is as a baseline context for

00:19:52,480 --> 00:19:55,679
this case study

00:19:53,600 --> 00:19:57,039
uh this diagram shows an increasingly

00:19:55,679 --> 00:19:58,799
common topology in

00:19:57,039 --> 00:20:01,039
network distributed systems these days

00:19:58,799 --> 00:20:03,520
i'm sure many of you at your companies

00:20:01,039 --> 00:20:06,159
uh have a setup similar to this where

00:20:03,520 --> 00:20:07,120
envoy is deployed as a universal network

00:20:06,159 --> 00:20:09,280
primitive

00:20:07,120 --> 00:20:11,200
where it deals with the majority if not

00:20:09,280 --> 00:20:13,200
all the network traffic in a company's

00:20:11,200 --> 00:20:15,760
architecture

00:20:13,200 --> 00:20:17,760
however my team at lyft recognized that

00:20:15,760 --> 00:20:18,640
we had left an important hop outside the

00:20:17,760 --> 00:20:20,400
ecosystem

00:20:18,640 --> 00:20:22,480
because traditionally we've treated

00:20:20,400 --> 00:20:24,480
mobile clients as independent

00:20:22,480 --> 00:20:26,000
from the backend infrastructure and we

00:20:24,480 --> 00:20:28,960
have built unique solutions

00:20:26,000 --> 00:20:31,280
to what was assumed to be a unique space

00:20:28,960 --> 00:20:32,880
so we identified a technology gap

00:20:31,280 --> 00:20:34,320
because in spite of all the work that we

00:20:32,880 --> 00:20:36,880
had done server side

00:20:34,320 --> 00:20:38,720
we saw that three nines of reliability

00:20:36,880 --> 00:20:40,400
at the server side is meaningless if the

00:20:38,720 --> 00:20:42,480
user of a mobile client is

00:20:40,400 --> 00:20:45,760
only able to complete the desired

00:20:42,480 --> 00:20:48,400
product flows a fraction of the time

00:20:45,760 --> 00:20:49,760
so what we want side are the same

00:20:48,400 --> 00:20:52,559
guarantees that we had

00:20:49,760 --> 00:20:54,640
server side so that is what we created

00:20:52,559 --> 00:20:56,480
android mobile we propose that we don't

00:20:54,640 --> 00:20:58,000
need to treat the mobile clients any

00:20:56,480 --> 00:20:59,120
different at least from the network

00:20:58,000 --> 00:21:01,360
perspective

00:20:59,120 --> 00:21:02,480
as we do with the server set

00:21:01,360 --> 00:21:04,960
infrastructure

00:21:02,480 --> 00:21:06,400
so this is what my this is why my team

00:21:04,960 --> 00:21:09,039
built this over the last year

00:21:06,400 --> 00:21:09,760
we have built bindings into envoy that

00:21:09,039 --> 00:21:12,480
allow us

00:21:09,760 --> 00:21:15,039
to run the code base as a native library

00:21:12,480 --> 00:21:16,960
in a mobile client application

00:21:15,039 --> 00:21:18,480
and so we have great documentation and a

00:21:16,960 --> 00:21:19,840
ton of material about the project so if

00:21:18,480 --> 00:21:20,480
you're interested in the project in

00:21:19,840 --> 00:21:22,799
itself

00:21:20,480 --> 00:21:25,440
uh please uh feel free to take a look

00:21:22,799 --> 00:21:26,960
it's also all open source

00:21:25,440 --> 00:21:28,720
but today we are here to talk about

00:21:26,960 --> 00:21:31,919
compression and in particular

00:21:28,720 --> 00:21:34,640
show you uh with how with android mobile

00:21:31,919 --> 00:21:36,000
in the client and with envoy at the edge

00:21:34,640 --> 00:21:37,919
of our infrastructure

00:21:36,000 --> 00:21:40,320
and with this new generic compression

00:21:37,919 --> 00:21:41,520
subsystem we were able to do some things

00:21:40,320 --> 00:21:44,880
that would have been too

00:21:41,520 --> 00:21:46,880
resource intensive in the past so

00:21:44,880 --> 00:21:49,120
compression at the edge is particularly

00:21:46,880 --> 00:21:50,799
important because payload sizes can lead

00:21:49,120 --> 00:21:53,120
to performance degradation

00:21:50,799 --> 00:21:54,480
under adverse network conditions which

00:21:53,120 --> 00:21:56,640
are usually experienced

00:21:54,480 --> 00:21:59,440
by mobile phones making public api

00:21:56,640 --> 00:22:02,159
requests to your infrastructure

00:21:59,440 --> 00:22:04,320
so as i mentioned before lyft compresses

00:22:02,159 --> 00:22:06,320
all responses at the edge

00:22:04,320 --> 00:22:07,360
and we wanted to have at least the same

00:22:06,320 --> 00:22:11,120
behavior

00:22:07,360 --> 00:22:14,320
when we migrated of our old

00:22:11,120 --> 00:22:17,200
client stacks to envoy mobile

00:22:14,320 --> 00:22:19,120
so in the past before android mobile

00:22:17,200 --> 00:22:21,760
implementing compression at the edge

00:22:19,120 --> 00:22:23,280
required three different code bases one

00:22:21,760 --> 00:22:25,760
for the edge proxy

00:22:23,280 --> 00:22:27,360
one for the android client and one for

00:22:25,760 --> 00:22:30,080
the ios client

00:22:27,360 --> 00:22:31,120
so this might be okay if we just wanted

00:22:30,080 --> 00:22:33,039
to put you know

00:22:31,120 --> 00:22:35,360
one compression algorithm in place and

00:22:33,039 --> 00:22:37,919
just leave it be

00:22:35,360 --> 00:22:38,720
but my team started asking questions

00:22:37,919 --> 00:22:41,360
very similar

00:22:38,720 --> 00:22:43,600
to our colleagues at intel what if we

00:22:41,360 --> 00:22:45,200
wanted to squeeze better compression and

00:22:43,600 --> 00:22:46,320
does better performance with different

00:22:45,200 --> 00:22:48,320
compression schemes

00:22:46,320 --> 00:22:50,400
what about bi-directional compression

00:22:48,320 --> 00:22:51,039
where we not only compress responses but

00:22:50,400 --> 00:22:54,080
also

00:22:51,039 --> 00:22:55,520
requests and these questions quickly

00:22:54,080 --> 00:22:58,320
become intractable

00:22:55,520 --> 00:22:58,880
if for every variation that we want to

00:22:58,320 --> 00:23:01,039
test

00:22:58,880 --> 00:23:02,320
we need to implement the same code three

00:23:01,039 --> 00:23:05,440
times server

00:23:02,320 --> 00:23:07,200
android and ios

00:23:05,440 --> 00:23:09,360
and that is really one of the main

00:23:07,200 --> 00:23:11,039
reasons we embarked on the anway mobile

00:23:09,360 --> 00:23:13,200
project to begin with

00:23:11,039 --> 00:23:14,960
because by using the same code base

00:23:13,200 --> 00:23:15,679
everywhere with envoy mobile in the

00:23:14,960 --> 00:23:18,080
client

00:23:15,679 --> 00:23:19,039
and envoy at the edge we are able to

00:23:18,080 --> 00:23:21,120
have only one

00:23:19,039 --> 00:23:22,880
implementation for every new technology

00:23:21,120 --> 00:23:25,520
we want to experiment with

00:23:22,880 --> 00:23:26,640
affording us on parallel consistency and

00:23:25,520 --> 00:23:28,559
extensibility

00:23:26,640 --> 00:23:30,960
at a fraction of the engineering hours

00:23:28,559 --> 00:23:34,159
required in the past

00:23:30,960 --> 00:23:35,840
so in other words now we do have truly a

00:23:34,159 --> 00:23:37,760
true universal

00:23:35,840 --> 00:23:39,840
network primitive that we can experiment

00:23:37,760 --> 00:23:41,840
with

00:23:39,840 --> 00:23:43,520
and why we became so interested in

00:23:41,840 --> 00:23:44,880
collaborating with our colleagues at

00:23:43,520 --> 00:23:48,559
intel in this

00:23:44,880 --> 00:23:51,200
compression subsystem all right

00:23:48,559 --> 00:23:51,600
so let's see how we brought compression

00:23:51,200 --> 00:23:53,679
back

00:23:51,600 --> 00:23:54,640
to the edge uh with only one

00:23:53,679 --> 00:23:57,039
implementation

00:23:54,640 --> 00:23:59,840
and without involving either our client

00:23:57,039 --> 00:24:01,919
or server engineers

00:23:59,840 --> 00:24:03,520
so before we go into compression let's

00:24:01,919 --> 00:24:05,919
look at the request flow

00:24:03,520 --> 00:24:07,679
using android mobile very similar to

00:24:05,919 --> 00:24:10,000
onboard on the server and we mobile

00:24:07,679 --> 00:24:12,960
proxies requests from the client

00:24:10,000 --> 00:24:14,240
to the edge proxy upstream and then the

00:24:12,960 --> 00:24:17,039
edge proxies

00:24:14,240 --> 00:24:18,480
the requests that receive that request

00:24:17,039 --> 00:24:22,000
further

00:24:18,480 --> 00:24:24,400
proxy that to the upstream service

00:24:22,000 --> 00:24:26,320
similarly on the response path the edge

00:24:24,400 --> 00:24:28,400
receives a response

00:24:26,320 --> 00:24:30,799
sent it to the client using android

00:24:28,400 --> 00:24:32,559
mobile which in turn surfaces that to

00:24:30,799 --> 00:24:34,320
the application via callbacks in the

00:24:32,559 --> 00:24:36,400
library

00:24:34,320 --> 00:24:37,840
all right so the first step in enabling

00:24:36,400 --> 00:24:39,760
compression is installing the new

00:24:37,840 --> 00:24:42,559
compressor filter with a particular

00:24:39,760 --> 00:24:44,320
compressor library on the edge nodes

00:24:42,559 --> 00:24:46,720
at this point nothing changes in the

00:24:44,320 --> 00:24:49,279
client the client sends a request

00:24:46,720 --> 00:24:49,919
which envoy mobile proxies to the edge

00:24:49,279 --> 00:24:52,000
but now

00:24:49,919 --> 00:24:53,840
the edges compressor filter searches for

00:24:52,000 --> 00:24:56,480
the accept encoding header

00:24:53,840 --> 00:24:58,840
which allows the filter to know if it

00:24:56,480 --> 00:25:01,520
should compress the response for this

00:24:58,840 --> 00:25:04,159
request but the header is missing

00:25:01,520 --> 00:25:05,039
so it simply forwards the request and

00:25:04,159 --> 00:25:07,279
then when the

00:25:05,039 --> 00:25:08,400
response comes back it does nothing with

00:25:07,279 --> 00:25:11,760
it and

00:25:08,400 --> 00:25:14,240
passes it back to android mobile

00:25:11,760 --> 00:25:14,799
but now we can install the decompressor

00:25:14,240 --> 00:25:16,960
filter

00:25:14,799 --> 00:25:18,880
in android mobile and here i want to

00:25:16,960 --> 00:25:20,960
highlight how easy that was

00:25:18,880 --> 00:25:23,279
we didn't have a help filter before and

00:25:20,960 --> 00:25:26,640
then boom we installed the filter

00:25:23,279 --> 00:25:28,000
so easy well jokes aside this is easy

00:25:26,640 --> 00:25:30,240
because android mobile

00:25:28,000 --> 00:25:32,159
is envoy so we can install the same

00:25:30,240 --> 00:25:32,799
filters that we use in envoy on the

00:25:32,159 --> 00:25:36,240
server

00:25:32,799 --> 00:25:38,159
including the decompressor filter

00:25:36,240 --> 00:25:40,799
all right so now that we have the

00:25:38,159 --> 00:25:43,360
decompressor the client sends a request

00:25:40,799 --> 00:25:44,960
and the decompressor adds the accept

00:25:43,360 --> 00:25:47,279
encoding header

00:25:44,960 --> 00:25:48,640
so when the compressor at the edge

00:25:47,279 --> 00:25:51,039
searches for that header

00:25:48,640 --> 00:25:51,760
it finds it so then the compress

00:25:51,039 --> 00:25:53,919
decompress

00:25:51,760 --> 00:25:55,279
the compressor strips the header and

00:25:53,919 --> 00:25:58,880
lets the envoy

00:25:55,279 --> 00:26:01,679
proxy the request but thanks to the

00:25:58,880 --> 00:26:02,000
accept encoding header the compressor is

00:26:01,679 --> 00:26:04,480
now

00:26:02,000 --> 00:26:06,320
primed to compress the response because

00:26:04,480 --> 00:26:07,919
it knows that the client

00:26:06,320 --> 00:26:10,799
is going to be able to handle this

00:26:07,919 --> 00:26:11,760
compressed response so when the response

00:26:10,799 --> 00:26:14,080
comes back

00:26:11,760 --> 00:26:16,400
the compressor compresses the response

00:26:14,080 --> 00:26:18,559
and in turn the decompressor filter

00:26:16,400 --> 00:26:20,159
decompresses it before sending it back

00:26:18,559 --> 00:26:22,640
to the application

00:26:20,159 --> 00:26:23,279
all without the client or the server

00:26:22,640 --> 00:26:26,960
engineer

00:26:23,279 --> 00:26:29,200
being involved at all nice

00:26:26,960 --> 00:26:31,120
so we were really excited with this

00:26:29,200 --> 00:26:32,960
first zero touch implementation and we

00:26:31,120 --> 00:26:35,200
started thinking what else could we do

00:26:32,960 --> 00:26:39,360
at the edge with envoy mobile in the

00:26:35,200 --> 00:26:40,640
client and with envoy in the server

00:26:39,360 --> 00:26:43,200
so potentially we could have

00:26:40,640 --> 00:26:44,080
bi-directional compression so instead of

00:26:43,200 --> 00:26:46,880
this setup

00:26:44,080 --> 00:26:49,039
where only the response gets compressed

00:26:46,880 --> 00:26:51,679
to be sent across the edge

00:26:49,039 --> 00:26:52,240
we could have a more complicated setup

00:26:51,679 --> 00:26:54,880
but

00:26:52,240 --> 00:26:55,840
it is a setup where both the client and

00:26:54,880 --> 00:26:57,919
the server

00:26:55,840 --> 00:27:00,320
have both a compressor and a

00:26:57,919 --> 00:27:03,440
decompressor filter

00:27:00,320 --> 00:27:07,360
allowing both requests and responses

00:27:03,440 --> 00:27:10,000
to be sent compressed across the wire

00:27:07,360 --> 00:27:11,039
but we could you know do more than that

00:27:10,000 --> 00:27:13,120
not only

00:27:11,039 --> 00:27:14,159
are we allowed to do bi-directional

00:27:13,120 --> 00:27:16,080
compression now

00:27:14,159 --> 00:27:17,600
but we could also run experiments with

00:27:16,080 --> 00:27:20,159
different compression schemes

00:27:17,600 --> 00:27:20,880
and fine-tune our compression settings

00:27:20,159 --> 00:27:22,799
to achieve

00:27:20,880 --> 00:27:25,039
less degradation at the edge and

00:27:22,799 --> 00:27:27,279
ultimately higher success with our

00:27:25,039 --> 00:27:29,760
public apis

00:27:27,279 --> 00:27:30,559
so this is the android mobile case study

00:27:29,760 --> 00:27:32,480
and

00:27:30,559 --> 00:27:34,000
this very very flexible compression

00:27:32,480 --> 00:27:36,960
system has really enabled

00:27:34,000 --> 00:27:38,480
us to pursue a lot of avenues that would

00:27:36,960 --> 00:27:41,600
have been intractable

00:27:38,480 --> 00:27:45,039
due to the engineering hours required

00:27:41,600 --> 00:27:48,320
beforehand so those two were the

00:27:45,039 --> 00:27:50,240
big use cases that drove compression uh

00:27:48,320 --> 00:27:52,159
forward with a cross-company

00:27:50,240 --> 00:27:53,279
cross-continent collaboration to thank

00:27:52,159 --> 00:27:55,360
for

00:27:53,279 --> 00:27:57,440
however we have many things planned for

00:27:55,360 --> 00:27:59,679
the compression space in envoy

00:27:57,440 --> 00:28:01,200
first even though the new compressor

00:27:59,679 --> 00:28:04,640
filter has been around

00:28:01,200 --> 00:28:05,919
since the 1.15 release the old gzip

00:28:04,640 --> 00:28:08,240
filter is still there

00:28:05,919 --> 00:28:08,960
we plan to remove it from envoy by the

00:28:08,240 --> 00:28:12,159
next release

00:28:08,960 --> 00:28:14,000
1.17 second

00:28:12,159 --> 00:28:17,279
is bradley support which is currently

00:28:14,000 --> 00:28:19,919
being worked on by dimitri at intel

00:28:17,279 --> 00:28:20,880
third is having a bi-directional

00:28:19,919 --> 00:28:23,039
compressor

00:28:20,880 --> 00:28:24,799
bi-directional decompressor has already

00:28:23,039 --> 00:28:26,880
been implemented by myself

00:28:24,799 --> 00:28:28,559
but to have a fully bi-directional

00:28:26,880 --> 00:28:31,039
end-to-end compression system

00:28:28,559 --> 00:28:32,559
we're missing request compression this

00:28:31,039 --> 00:28:34,559
is very easy to add

00:28:32,559 --> 00:28:37,679
in the compressor filter in case anyone

00:28:34,559 --> 00:28:39,279
in the audience is interested

00:28:37,679 --> 00:28:40,880
having this pluggable compression

00:28:39,279 --> 00:28:43,120
libraries enables us to apply

00:28:40,880 --> 00:28:45,520
compression to other parts of envoy

00:28:43,120 --> 00:28:48,559
your ideas are welcome on which parts

00:28:45,520 --> 00:28:51,120
exactly can benefit from it

00:28:48,559 --> 00:28:53,679
lastly it is worth mentioning that the

00:28:51,120 --> 00:28:55,679
performance of gzip compression in envoy

00:28:53,679 --> 00:28:57,440
still has room for improvement for

00:28:55,679 --> 00:29:00,080
example gc compression

00:28:57,440 --> 00:29:03,679
engine x works about 25 percent faster

00:29:00,080 --> 00:29:05,760
than an envoy when configured similarly

00:29:03,679 --> 00:29:08,159
these are just some of the items we have

00:29:05,760 --> 00:29:11,440
planned in the compression roadmap

00:29:08,159 --> 00:29:13,760
but we can't wait for seeing

00:29:11,440 --> 00:29:15,120
what other interests the community has

00:29:13,760 --> 00:29:18,240
for this new subsystem

00:29:15,120 --> 00:29:20,640
well uh that's uh that's all we had uh

00:29:18,240 --> 00:29:21,360
for today thanks for for listening and

00:29:20,640 --> 00:29:23,159
watching us

00:29:21,360 --> 00:29:26,159
and looking forward to see you in the

00:29:23,159 --> 00:29:26,159

YouTube URL: https://www.youtube.com/watch?v=02E2mNOLV_k


