Title: Hands-on WASM filters and singletons - Emmanuel Mayssat
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	Hands-on WASM filters and singletons - Emmanuel Mayssat

In this presentation, Emmanuel will start by introducing the basics of WASM extensions, but will quickly move on to his project of developing a custom authz/authn with WASM. He will talk about his decision making process and introduce his development environments on k8s and docker-compose. He will be covering his software architecture, such as the use of a singleton stack and chained WASM filters. Covered topics also includes WASM bytecode download (LDS), policy download, prometheus metrics, library integration, data sharing, hidden headers, code testing, debugging technics, performance measurements for a real project! This presentation will also touch on practical issues such as programming languages choice (C++, rust, assembly script, tinyGo), learning curves, build pipelines, and development velocity (carvel/ytt)
Captions: 
	00:00:02,080 --> 00:00:05,359
00:00:03,280 --> 00:00:07,279
was before web assembly and at that time

00:00:05,359 --> 00:00:08,320
i was working at vmware on what is known

00:00:07,279 --> 00:00:12,000
today as

00:00:08,320 --> 00:00:13,679
tenzu service mesh in the team i was in

00:00:12,000 --> 00:00:16,080
charge of everything devops

00:00:13,679 --> 00:00:18,480
as such i worked closely with a small

00:00:16,080 --> 00:00:21,119
group of developers

00:00:18,480 --> 00:00:22,400
one day one of them came to me and said

00:00:21,119 --> 00:00:25,599
emmanuel come over here

00:00:22,400 --> 00:00:28,080
i want to show you something i went

00:00:25,599 --> 00:00:29,679
when in front of me he demoed a custom

00:00:28,080 --> 00:00:32,239
filter

00:00:29,679 --> 00:00:35,200
in this demo i witnessed how is a filter

00:00:32,239 --> 00:00:37,520
sql queries can be introspected

00:00:35,200 --> 00:00:39,360
runtime statistics can be captured in a

00:00:37,520 --> 00:00:41,200
way that is completely transparent to

00:00:39,360 --> 00:00:44,559
the database server

00:00:41,200 --> 00:00:47,200
i was fascinated i asked the developer

00:00:44,559 --> 00:00:49,600
how he had done it he went on to

00:00:47,200 --> 00:00:52,079
describe this step by step

00:00:49,600 --> 00:00:53,360
first he said i forgot the android

00:00:52,079 --> 00:00:56,320
source code

00:00:53,360 --> 00:00:57,280
i build the extension in c plus plus

00:00:56,320 --> 00:01:00,079
rebuilds

00:00:57,280 --> 00:01:01,760
envoy to finally test the resulting

00:01:00,079 --> 00:01:04,080
binary

00:01:01,760 --> 00:01:05,199
he was a c plus plus expert and as a

00:01:04,080 --> 00:01:08,320
devops i thought

00:01:05,199 --> 00:01:09,920
there was no way i could write a custom

00:01:08,320 --> 00:01:12,320
filter

00:01:09,920 --> 00:01:13,119
but you know what you can do he said now

00:01:12,320 --> 00:01:14,880
that i'm done

00:01:13,119 --> 00:01:17,200
you can package my code in the docker

00:01:14,880 --> 00:01:18,000
image distribute the image in all of our

00:01:17,200 --> 00:01:20,080
environment

00:01:18,000 --> 00:01:21,439
update the version of envoy in all of

00:01:20,080 --> 00:01:23,520
our dev staging

00:01:21,439 --> 00:01:24,479
and port clusters and of course as a

00:01:23,520 --> 00:01:26,960
devsecops

00:01:24,479 --> 00:01:27,920
emanuel do not forget to incorporate

00:01:26,960 --> 00:01:33,040
patches

00:01:27,920 --> 00:01:35,280
and other improvements thanks

00:01:33,040 --> 00:01:36,320
it turns out that back then what we were

00:01:35,280 --> 00:01:39,600
working on

00:01:36,320 --> 00:01:43,119
is what is today the envoy native

00:01:39,600 --> 00:01:43,119
mysql filter

00:01:45,040 --> 00:01:48,960
fast forward to present days i joined

00:01:47,520 --> 00:01:52,320
another company

00:01:48,960 --> 00:01:53,920
three months ago i i was hired by

00:01:52,320 --> 00:01:55,360
american express where i joined the

00:01:53,920 --> 00:01:57,119
identity group

00:01:55,360 --> 00:01:58,399
as such once completed with the

00:01:57,119 --> 00:02:00,640
onboarding process

00:01:58,399 --> 00:02:01,520
i was immediately approached by the team

00:02:00,640 --> 00:02:04,960
that managed

00:02:01,520 --> 00:02:06,719
all of our ipi gateways we are migrating

00:02:04,960 --> 00:02:09,200
to android they said

00:02:06,719 --> 00:02:11,360
with the expected number of requests we

00:02:09,200 --> 00:02:13,840
need to squeeze as much performance from

00:02:11,360 --> 00:02:17,120
this proxy as we can get

00:02:13,840 --> 00:02:18,800
emmanuel can you help of course i

00:02:17,120 --> 00:02:22,080
immediately thought of using

00:02:18,800 --> 00:02:22,879
the open policy agent oppa but i quickly

00:02:22,080 --> 00:02:26,080
found out

00:02:22,879 --> 00:02:28,640
that with custom policies and required

00:02:26,080 --> 00:02:32,319
support for eight plus type of joe token

00:02:28,640 --> 00:02:35,680
oppa was useless what those people

00:02:32,319 --> 00:02:36,560
were really asking me was if i could

00:02:35,680 --> 00:02:39,599
write

00:02:36,560 --> 00:02:39,599
a custom filter

00:02:40,000 --> 00:02:45,599
thanks so

00:02:43,040 --> 00:02:46,959
i started reading the docs and this is

00:02:45,599 --> 00:02:49,920
when i learned about

00:02:46,959 --> 00:02:52,160
web assembly with wasm envoy doesn't

00:02:49,920 --> 00:02:54,400
need to be recompiled

00:02:52,160 --> 00:02:55,760
filters do not need to be written in c

00:02:54,400 --> 00:02:58,319
plus plus

00:02:55,760 --> 00:03:01,280
thanks to lds custom filters can now be

00:02:58,319 --> 00:03:01,280
dynamically loaded

00:03:03,440 --> 00:03:07,840
at american express we are currently

00:03:05,120 --> 00:03:09,440
evaluating the glue api gateway from

00:03:07,840 --> 00:03:11,280
solo.io

00:03:09,440 --> 00:03:12,480
there is an open source version with

00:03:11,280 --> 00:03:16,560
which anyone

00:03:12,480 --> 00:03:19,680
i you can get started

00:03:16,560 --> 00:03:21,760
i got started with web assembly simply

00:03:19,680 --> 00:03:23,599
by going through their web assembly hub

00:03:21,760 --> 00:03:25,920
tutorial

00:03:23,599 --> 00:03:27,760
during this tutorial you will just add a

00:03:25,920 --> 00:03:29,519
header to your request

00:03:27,760 --> 00:03:30,959
but also you will be introduced to the

00:03:29,519 --> 00:03:33,440
wasm cli

00:03:30,959 --> 00:03:34,799
was me in it to create a scaffold or

00:03:33,440 --> 00:03:37,519
bullet plate code

00:03:34,799 --> 00:03:39,200
was maybe to compile your code to was to

00:03:37,519 --> 00:03:42,319
wasn't file

00:03:39,200 --> 00:03:44,000
was me push to push it to a public

00:03:42,319 --> 00:03:45,760
registry called webassembly hub

00:03:44,000 --> 00:03:47,519
very similar to docker hub but for

00:03:45,760 --> 00:03:49,599
reason filter

00:03:47,519 --> 00:03:51,519
and finally once you're done publishing

00:03:49,599 --> 00:03:55,280
your filter to deploy it

00:03:51,519 --> 00:03:57,519
you can simply use usb deploy

00:03:55,280 --> 00:03:59,439
now if you are using sto to deploy a

00:03:57,519 --> 00:04:01,599
filter you are even given

00:03:59,439 --> 00:04:03,680
the alternative of using a custom

00:04:01,599 --> 00:04:06,879
resource definition

00:04:03,680 --> 00:04:09,200
as a devops i really love what solo.i o

00:04:06,879 --> 00:04:09,200
is doing

00:04:10,959 --> 00:04:15,439
now if like me you are curious and you

00:04:13,439 --> 00:04:17,040
want to find out how the configuration

00:04:15,439 --> 00:04:19,199
of your android has changed

00:04:17,040 --> 00:04:20,479
during the deployment of your filter you

00:04:19,199 --> 00:04:24,240
can simply connect

00:04:20,479 --> 00:04:27,199
to the device admin ui to do so

00:04:24,240 --> 00:04:28,000
keep control part forward to the pod

00:04:27,199 --> 00:04:30,960
with the proxy

00:04:28,000 --> 00:04:32,639
you won't transrospect select the

00:04:30,960 --> 00:04:35,199
android container

00:04:32,639 --> 00:04:37,680
and map the port of its admin interface

00:04:35,199 --> 00:04:39,680
to a port on your localhost

00:04:37,680 --> 00:04:41,199
after doing so you will be able to

00:04:39,680 --> 00:04:43,520
connect to envoy

00:04:41,199 --> 00:04:46,080
in particular to the admin interface

00:04:43,520 --> 00:04:48,880
using a web browser

00:04:46,080 --> 00:04:52,000
then select config dump to see your on

00:04:48,880 --> 00:04:55,120
voice active configuration

00:04:52,000 --> 00:04:59,360
the configuration snippet on this slide

00:04:55,120 --> 00:05:01,280
is what is added for resin filter

00:04:59,360 --> 00:05:02,800
this ml blob may seem a little bit

00:05:01,280 --> 00:05:03,759
complicated to those of you who are new

00:05:02,800 --> 00:05:06,560
to android

00:05:03,759 --> 00:05:08,320
but essentially to configure and filter

00:05:06,560 --> 00:05:12,240
you need to provide a runtime

00:05:08,320 --> 00:05:13,919
here it's runtime v8 and the location of

00:05:12,240 --> 00:05:17,600
usm by code

00:05:13,919 --> 00:05:17,600
here a local file

00:05:18,080 --> 00:05:22,639
now as described earlier to use your

00:05:20,800 --> 00:05:24,880
filter on kubernetes you need to compile

00:05:22,639 --> 00:05:27,120
your filter locally package it

00:05:24,880 --> 00:05:28,960
push it webassembly here deploy it with

00:05:27,120 --> 00:05:29,840
the crd and wait for the deployment to

00:05:28,960 --> 00:05:32,720
complete

00:05:29,840 --> 00:05:35,120
this workflow is awesome but is way too

00:05:32,720 --> 00:05:37,600
slow for development purpose

00:05:35,120 --> 00:05:39,840
for the development of your filter you

00:05:37,600 --> 00:05:42,880
need a much faster turnaround

00:05:39,840 --> 00:05:45,440
higher velocity to achieve this a

00:05:42,880 --> 00:05:47,199
solution is to use docker compose

00:05:45,440 --> 00:05:49,039
this diagram represents my first

00:05:47,199 --> 00:05:50,840
iteration in docker compose

00:05:49,039 --> 00:05:53,840
but ultimately i was left with a

00:05:50,840 --> 00:05:57,520
question with resume

00:05:53,840 --> 00:06:01,039
can you do more than just add remove

00:05:57,520 --> 00:06:01,039
update headers

00:06:04,400 --> 00:06:09,600
to find the answer to that question and

00:06:06,800 --> 00:06:13,120
develop my authorization filter

00:06:09,600 --> 00:06:15,680
i started iterating i iterated

00:06:13,120 --> 00:06:17,840
i experimented i read the available the

00:06:15,680 --> 00:06:20,960
available but limited documentation

00:06:17,840 --> 00:06:22,960
i went online trying to find examples

00:06:20,960 --> 00:06:24,400
i looked at the source code and

00:06:22,960 --> 00:06:27,840
occasionally reached out

00:06:24,400 --> 00:06:27,840
on slack to select people

00:06:28,160 --> 00:06:31,360
given the current lack of documentation

00:06:30,160 --> 00:06:32,840
for proxy wasn't

00:06:31,360 --> 00:06:35,840
you may think it's a bit early to get

00:06:32,840 --> 00:06:36,960
started but what i found is that if you

00:06:35,840 --> 00:06:40,000
know where to

00:06:36,960 --> 00:06:41,120
where to look the answers are already

00:06:40,000 --> 00:06:44,160
there

00:06:41,120 --> 00:06:45,919
now before you get started a couple of

00:06:44,160 --> 00:06:49,120
warning

00:06:45,919 --> 00:06:50,639
first today vanilla envoy does not

00:06:49,120 --> 00:06:53,120
support wesem

00:06:50,639 --> 00:06:55,039
to experiment with wesm like me you will

00:06:53,120 --> 00:06:56,000
have to use the recent version of glue

00:06:55,039 --> 00:06:59,919
envoy

00:06:56,000 --> 00:07:02,160
or eastern proxy in addition

00:06:59,919 --> 00:07:04,160
today the implementation of the

00:07:02,160 --> 00:07:07,520
application binary interface or

00:07:04,160 --> 00:07:10,639
api is near completion but is not 100

00:07:07,520 --> 00:07:12,479
completed as a result

00:07:10,639 --> 00:07:14,319
when you upgrade from one version of

00:07:12,479 --> 00:07:16,240
android to the next

00:07:14,319 --> 00:07:18,800
you may have to tweak the source code of

00:07:16,240 --> 00:07:18,800
your filter

00:07:20,560 --> 00:07:24,639
so you iterate you iterate until you

00:07:23,039 --> 00:07:26,560
finally arrive to something that looks

00:07:24,639 --> 00:07:28,639
like this

00:07:26,560 --> 00:07:31,360
don't tilt your head i'm not expecting

00:07:28,639 --> 00:07:33,840
you to understand the details just yet

00:07:31,360 --> 00:07:35,440
let me just say that i am now using

00:07:33,840 --> 00:07:37,280
several android proxies

00:07:35,440 --> 00:07:39,680
different versions and weather

00:07:37,280 --> 00:07:41,360
extensions are everywhere

00:07:39,680 --> 00:07:45,840
now let me share some of the key

00:07:41,360 --> 00:07:48,400
highlights on what i learned

00:07:45,840 --> 00:07:49,199
let me start by introducing to you ytt

00:07:48,400 --> 00:07:52,879
ytt

00:07:49,199 --> 00:07:55,599
the ml templating tool if you have ever

00:07:52,879 --> 00:07:57,599
dealt with the ml configuration file

00:07:55,599 --> 00:07:58,639
which i'm sure everyone everyone here

00:07:57,599 --> 00:08:01,520
has stop

00:07:58,639 --> 00:08:06,240
watching this video right now and

00:08:01,520 --> 00:08:09,360
immediately go to http

00:08:06,240 --> 00:08:11,919
this tool is fantastic

00:08:09,360 --> 00:08:12,960
to give you a preview the ytt cli text

00:08:11,919 --> 00:08:16,560
for input

00:08:12,960 --> 00:08:18,560
oml file passes its content

00:08:16,560 --> 00:08:20,879
look for the commands and replace the

00:08:18,560 --> 00:08:21,759
commands with the content of other ml

00:08:20,879 --> 00:08:24,560
files

00:08:21,759 --> 00:08:25,120
in short this allows for a ml file to

00:08:24,560 --> 00:08:28,479
import

00:08:25,120 --> 00:08:30,479
all the rml files on this slide i

00:08:28,479 --> 00:08:32,240
extracted the code snippet for my input

00:08:30,479 --> 00:08:35,039
configuration

00:08:32,240 --> 00:08:36,640
the transformation of this original ml

00:08:35,039 --> 00:08:37,599
file is possible thanks to a programming

00:08:36,640 --> 00:08:41,279
language

00:08:37,599 --> 00:08:43,599
very similar to python called starlark

00:08:41,279 --> 00:08:46,160
as a result now instead of having to

00:08:43,599 --> 00:08:47,360
deal with lengthy unending confusing ml

00:08:46,160 --> 00:08:50,959
files

00:08:47,360 --> 00:08:53,600
you can work at the level of components

00:08:50,959 --> 00:08:54,959
such as individual filters or even group

00:08:53,600 --> 00:08:58,320
of components

00:08:54,959 --> 00:08:59,440
such as group of filters by far in this

00:08:58,320 --> 00:09:02,320
project

00:08:59,440 --> 00:09:02,959
ytt is a common line utility that gave

00:09:02,320 --> 00:09:08,560
me

00:09:02,959 --> 00:09:10,399
the most productivity boost check it out

00:09:08,560 --> 00:09:12,320
a word about programming language you

00:09:10,399 --> 00:09:15,360
can use with proxy with them

00:09:12,320 --> 00:09:17,040
one of the promise of proxy wasm

00:09:15,360 --> 00:09:18,560
is to allow the programming of android

00:09:17,040 --> 00:09:20,720
extension with non-c plus plus

00:09:18,560 --> 00:09:22,640
programming languages

00:09:20,720 --> 00:09:24,240
if you want to write a proxy extension

00:09:22,640 --> 00:09:26,160
today there are four programming

00:09:24,240 --> 00:09:29,279
languages available

00:09:26,160 --> 00:09:33,040
they are c plus plus rest

00:09:29,279 --> 00:09:36,160
assembly script and go starting from

00:09:33,040 --> 00:09:38,080
the bottom go through tiny go is the

00:09:36,160 --> 00:09:40,880
latest addition to the list

00:09:38,080 --> 00:09:43,839
it's very new i have not personally

00:09:40,880 --> 00:09:45,680
tried an ego to write a western filter

00:09:43,839 --> 00:09:47,920
but based on my reading the main issue

00:09:45,680 --> 00:09:51,440
with go or similar programming language

00:09:47,920 --> 00:09:55,279
is that no asm vm or wasm sandbox

00:09:51,440 --> 00:09:55,279
can yet deal with garbage collection

00:09:55,360 --> 00:09:59,200
then you have a zombie script a strongly

00:09:57,680 --> 00:10:01,120
typed javascript

00:09:59,200 --> 00:10:03,360
which is promoted in our community by

00:10:01,120 --> 00:10:05,360
solo.io

00:10:03,360 --> 00:10:06,880
assembly script defined itself as a

00:10:05,360 --> 00:10:10,640
language made for

00:10:06,880 --> 00:10:12,959
wasm after experimenting with it

00:10:10,640 --> 00:10:14,880
i was immediately confronted with a

00:10:12,959 --> 00:10:16,480
limited number of library

00:10:14,880 --> 00:10:18,079
therefore it is my opinion that i

00:10:16,480 --> 00:10:23,279
assembly script is

00:10:18,079 --> 00:10:23,279
not yet made for proxy wizard just yet

00:10:23,600 --> 00:10:28,240
then you have rust like assembly script

00:10:26,640 --> 00:10:30,640
rust itself is relatively new

00:10:28,240 --> 00:10:33,760
programming language and i thought rust

00:10:30,640 --> 00:10:37,040
has very strong potential most of us

00:10:33,760 --> 00:10:40,240
most of us will have to learn it

00:10:37,040 --> 00:10:43,040
finally back to c plus plus

00:10:40,240 --> 00:10:43,839
certainly the core developers of envoy

00:10:43,040 --> 00:10:46,959
estio

00:10:43,839 --> 00:10:48,640
android wasm are all well-versed with c

00:10:46,959 --> 00:10:50,640
plus plus

00:10:48,640 --> 00:10:53,920
most examples of words and filters are

00:10:50,640 --> 00:10:57,839
found online were written in c plus plus

00:10:53,920 --> 00:11:00,320
additionally if like me in a past life

00:10:57,839 --> 00:11:01,120
you had to program it opposite c plus

00:11:00,320 --> 00:11:04,240
plus

00:11:01,120 --> 00:11:06,240
would clearly be the winning choice

00:11:04,240 --> 00:11:07,519
indeed compiling c plus plus code to

00:11:06,240 --> 00:11:10,560
javascript

00:11:07,519 --> 00:11:12,959
to run in llvm vm runtime

00:11:10,560 --> 00:11:15,200
is very similar to embedded system

00:11:12,959 --> 00:11:18,720
programming

00:11:15,200 --> 00:11:21,360
as such today it is my opinion

00:11:18,720 --> 00:11:23,839
that proxy wasn't failed on its promise

00:11:21,360 --> 00:11:24,800
of using a non-c plus plus programming

00:11:23,839 --> 00:11:27,839
language

00:11:24,800 --> 00:11:30,320
but thankfully the ecosystem is fast

00:11:27,839 --> 00:11:30,320
evolving

00:11:32,000 --> 00:11:35,680
regardless of the primary language you

00:11:33,680 --> 00:11:38,240
choose you will have to understand the

00:11:35,680 --> 00:11:40,320
application binary interface

00:11:38,240 --> 00:11:41,279
your compile code usm extension is

00:11:40,320 --> 00:11:44,399
running in

00:11:41,279 --> 00:11:45,040
a wasm sandbox an interface with android

00:11:44,399 --> 00:11:48,399
using

00:11:45,040 --> 00:11:49,440
this api you can find the description of

00:11:48,399 --> 00:11:51,040
the api

00:11:49,440 --> 00:11:53,360
in the software development kit of your

00:11:51,040 --> 00:11:55,680
chosen programming language

00:11:53,360 --> 00:11:56,800
you can think of your wealth extension

00:11:55,680 --> 00:11:58,880
as a library

00:11:56,800 --> 00:12:00,560
that needs to implement a given set of

00:11:58,880 --> 00:12:04,160
functions or methods

00:12:00,560 --> 00:12:06,639
that android thread recall for example

00:12:04,160 --> 00:12:07,279
when you bootstrap envoy the wasm

00:12:06,639 --> 00:12:10,480
sandbox

00:12:07,279 --> 00:12:13,839
also starts the onstart method

00:12:10,480 --> 00:12:15,839
is called likewise when request is

00:12:13,839 --> 00:12:17,519
processed by the listener to which your

00:12:15,839 --> 00:12:20,000
filter is attached

00:12:17,519 --> 00:12:20,800
the on request header on request body

00:12:20,000 --> 00:12:24,000
methods

00:12:20,800 --> 00:12:27,600
will trigger this is what is represented

00:12:24,000 --> 00:12:30,480
in blue on this slide as the envoy

00:12:27,600 --> 00:12:33,279
extension lifecycle

00:12:30,480 --> 00:12:35,519
but envoy must also be thought of as the

00:12:33,279 --> 00:12:39,279
operating system of the wesum sandbox

00:12:35,519 --> 00:12:43,200
indeed in usm filter if you want

00:12:39,279 --> 00:12:46,320
to introspect the request headers

00:12:43,200 --> 00:12:49,040
read write in memory execute

00:12:46,320 --> 00:12:51,680
an external http call you will need to

00:12:49,040 --> 00:12:53,680
call foreign functions

00:12:51,680 --> 00:12:54,800
to illustrate with my authorization

00:12:53,680 --> 00:12:58,560
project i

00:12:54,800 --> 00:13:01,120
use the get request header

00:12:58,560 --> 00:13:01,839
function on the authorization header to

00:13:01,120 --> 00:13:04,079
extract

00:13:01,839 --> 00:13:05,680
the authorization header to find out its

00:13:04,079 --> 00:13:08,480
content

00:13:05,680 --> 00:13:11,839
in my case the content of that header is

00:13:08,480 --> 00:13:11,839
a request perhaps token

00:13:14,160 --> 00:13:17,279
if like me you choose to build your

00:13:15,760 --> 00:13:20,720
extension in c plus plus

00:13:17,279 --> 00:13:22,000
you will need to understand bazel bezel

00:13:20,720 --> 00:13:24,399
is a build tool

00:13:22,000 --> 00:13:27,279
developed by google similar to cmec

00:13:24,399 --> 00:13:30,560
maven or even the sampler glumec

00:13:27,279 --> 00:13:34,000
it is used to compile c plus plus code

00:13:30,560 --> 00:13:37,120
of your filter

00:13:34,000 --> 00:13:38,880
i am sure several of you have had some

00:13:37,120 --> 00:13:41,920
exposure to bezel because

00:13:38,880 --> 00:13:43,120
better as it turns out is also used to

00:13:41,920 --> 00:13:46,639
build and compile

00:13:43,120 --> 00:13:48,079
envoy for those of you who are new to

00:13:46,639 --> 00:13:51,199
bazel there are two concepts

00:13:48,079 --> 00:13:53,519
or files that are important first

00:13:51,199 --> 00:13:55,600
the workspace file this is where you

00:13:53,519 --> 00:13:58,560
define all of your external dependencies

00:13:55,600 --> 00:14:01,120
and how to import them in the workspace

00:13:58,560 --> 00:14:04,160
file for uc plus plus resume extension

00:14:01,120 --> 00:14:05,600
you will need at the minimum to import

00:14:04,160 --> 00:14:07,680
the unscripted compiler

00:14:05,600 --> 00:14:10,160
and to chain require to compile c plus

00:14:07,680 --> 00:14:12,160
plus to run in the v8

00:14:10,160 --> 00:14:13,680
and two you will need to fetch a code

00:14:12,160 --> 00:14:14,959
that describes the application binary

00:14:13,680 --> 00:14:17,680
interface

00:14:14,959 --> 00:14:18,480
this can be done by importing the

00:14:17,680 --> 00:14:21,680
sources of

00:14:18,480 --> 00:14:21,680
istio proxy

00:14:21,839 --> 00:14:25,040
the second concept you understand with

00:14:23,920 --> 00:14:27,680
bezel is a build

00:14:25,040 --> 00:14:28,720
file this is where you define your

00:14:27,680 --> 00:14:31,040
targets

00:14:28,720 --> 00:14:33,440
what you want to build in bezel you

00:14:31,040 --> 00:14:36,959
define targets by using predefined

00:14:33,440 --> 00:14:41,839
by using predefined or custom macros

00:14:36,959 --> 00:14:46,959
written in starlark those macro

00:14:41,839 --> 00:14:49,279
in basel are called basel rules

00:14:46,959 --> 00:14:50,880
at the bottom left i show the bazel rule

00:14:49,279 --> 00:14:52,800
to build a custom library

00:14:50,880 --> 00:14:55,760
at the bottom right i show the basel

00:14:52,800 --> 00:14:55,760
command to build it

00:14:57,120 --> 00:15:01,040
now without altering too much in the

00:14:59,360 --> 00:15:02,399
details i would like to share some of

00:15:01,040 --> 00:15:06,000
the external dependencies

00:15:02,399 --> 00:15:08,959
i imported in my bezel workspace

00:15:06,000 --> 00:15:09,760
the google test framework very useful to

00:15:08,959 --> 00:15:13,360
test

00:15:09,760 --> 00:15:15,360
custom libraries boost yes

00:15:13,360 --> 00:15:17,440
the very popular c plus plus boost

00:15:15,360 --> 00:15:18,160
library a must have for c plus plus

00:15:17,440 --> 00:15:21,440
filters

00:15:18,160 --> 00:15:24,399
of medium to advanced complexity

00:15:21,440 --> 00:15:26,320
rapid json in my case that i used to

00:15:24,399 --> 00:15:28,000
manipulate json documents such as my

00:15:26,320 --> 00:15:31,440
authorization policy

00:15:28,000 --> 00:15:31,440
or my br token claims

00:15:32,480 --> 00:15:36,000
finally once all the dependencies are

00:15:34,639 --> 00:15:39,519
imported in your workspace

00:15:36,000 --> 00:15:41,920
the next thing is to build the wasm file

00:15:39,519 --> 00:15:44,320
this is done here with the wasam cc

00:15:41,920 --> 00:15:48,240
binary starlack macro

00:15:44,320 --> 00:15:51,040
in english what that bezel rule means is

00:15:48,240 --> 00:15:52,160
to build the binary file worker apptoken

00:15:51,040 --> 00:15:54,360
wasm

00:15:52,160 --> 00:15:56,320
compile the source file worker

00:15:54,360 --> 00:15:59,120
apptoken.cc

00:15:56,320 --> 00:15:59,920
and link the resulting object to the api

00:15:59,120 --> 00:16:04,079
boost

00:15:59,920 --> 00:16:04,079
rapid json and my custom library

00:16:05,920 --> 00:16:09,360
now let's get out of the width and go

00:16:07,600 --> 00:16:11,680
back to a higher level

00:16:09,360 --> 00:16:12,959
there are two types of wizard extension

00:16:11,680 --> 00:16:16,880
the first type

00:16:12,959 --> 00:16:19,839
are wasm filters attached to listener

00:16:16,880 --> 00:16:20,800
can therefore dynamically be configured

00:16:19,839 --> 00:16:23,680
with a listener

00:16:20,800 --> 00:16:24,639
discovery service or lds and are

00:16:23,680 --> 00:16:27,680
triggered

00:16:24,639 --> 00:16:29,680
by a request the second type of wasm

00:16:27,680 --> 00:16:31,600
extensions are singletons

00:16:29,680 --> 00:16:34,160
in the next few few slides i will

00:16:31,600 --> 00:16:36,959
introduce them but before i do so

00:16:34,160 --> 00:16:39,120
i'd like to share or convey that filters

00:16:36,959 --> 00:16:42,399
and singletons can communicate with

00:16:39,120 --> 00:16:46,160
each other this is done by using either

00:16:42,399 --> 00:16:49,680
a message queue or shared data

00:16:46,160 --> 00:16:52,720
or in a shared memory let me illustrate

00:16:49,680 --> 00:16:53,600
all of this with my filter and my

00:16:52,720 --> 00:16:57,519
singleton

00:16:53,600 --> 00:16:57,519
in my authorization project

00:16:58,480 --> 00:17:02,320
let's go back for this to the docker

00:17:00,959 --> 00:17:04,079
compose development environment i

00:17:02,320 --> 00:17:07,839
flashed earlier and let's zoom in

00:17:04,079 --> 00:17:07,839
on one of my envoy

00:17:08,400 --> 00:17:14,000
on this history envoy three listener and

00:17:11,120 --> 00:17:16,640
the admin interface have been configured

00:17:14,000 --> 00:17:18,720
at the top of your screen on port 8080

00:17:16,640 --> 00:17:21,760
is a listener i use to simulate

00:17:18,720 --> 00:17:24,880
an android sidecar to http

00:17:21,760 --> 00:17:26,799
just below on port 8007 7

00:17:24,880 --> 00:17:30,000
is a listener configured with a wasm

00:17:26,799 --> 00:17:32,080
filter and a simulated backend

00:17:30,000 --> 00:17:34,240
such a configuration is extremely useful

00:17:32,080 --> 00:17:37,280
for performance measurements

00:17:34,240 --> 00:17:38,400
for example using fortio a load

00:17:37,280 --> 00:17:40,880
generator

00:17:38,400 --> 00:17:41,520
you can send requests and measure the

00:17:40,880 --> 00:17:44,960
impacts

00:17:41,520 --> 00:17:48,480
of usm filter on latency

00:17:44,960 --> 00:17:50,640
finally on port 843

00:17:48,480 --> 00:17:52,960
is the listener of interest this

00:17:50,640 --> 00:17:56,080
listener user was a filter chain

00:17:52,960 --> 00:17:56,080
and a singleton stack

00:17:58,880 --> 00:18:02,640
now here is an is an early version of my

00:18:01,360 --> 00:18:05,600
singleton stack

00:18:02,640 --> 00:18:07,600
its purpose is to fetch and then refresh

00:18:05,600 --> 00:18:09,840
the local copy of american express

00:18:07,600 --> 00:18:12,880
authorization policy

00:18:09,840 --> 00:18:14,080
as you can see single terms are not on

00:18:12,880 --> 00:18:15,520
the request path

00:18:14,080 --> 00:18:17,200
and therefore their number and

00:18:15,520 --> 00:18:20,799
performance have no impact

00:18:17,200 --> 00:18:23,039
on request latency in my case

00:18:20,799 --> 00:18:26,160
the execution of my singleton is

00:18:23,039 --> 00:18:29,520
triggered at regular interval by a timer

00:18:26,160 --> 00:18:31,039
every 10 seconds the top one pulls from

00:18:29,520 --> 00:18:33,200
a remote location

00:18:31,039 --> 00:18:34,080
a document assumed to be the global

00:18:33,200 --> 00:18:36,960
authorization

00:18:34,080 --> 00:18:37,760
policy that documentation that document

00:18:36,960 --> 00:18:41,200
is fetched

00:18:37,760 --> 00:18:44,320
and then stored in shared memory

00:18:41,200 --> 00:18:45,360
the bottom one every 10 seconds read the

00:18:44,320 --> 00:18:47,600
document

00:18:45,360 --> 00:18:50,400
stored in shared memory and execute and

00:18:47,600 --> 00:18:50,400
put validation

00:18:50,960 --> 00:18:57,679
now you may wonder why we have several

00:18:54,160 --> 00:18:59,039
singleton instances instead of just one

00:18:57,679 --> 00:19:00,880
the short answer is that we are

00:18:59,039 --> 00:19:02,400
experimenting

00:19:00,880 --> 00:19:04,960
but one clear advantage with this

00:19:02,400 --> 00:19:06,720
approach is that we maximize we can

00:19:04,960 --> 00:19:08,640
maximize code reviews

00:19:06,720 --> 00:19:10,320
and additionally if we want to upgrade a

00:19:08,640 --> 00:19:13,840
diffidual component

00:19:10,320 --> 00:19:13,840
we minimize disruption

00:19:16,400 --> 00:19:20,320
as mentioned earlier at american express

00:19:18,559 --> 00:19:22,320
with your point we support different

00:19:20,320 --> 00:19:24,720
type of json web token

00:19:22,320 --> 00:19:25,520
depicted at the center of the slide are

00:19:24,720 --> 00:19:28,720
three

00:19:25,520 --> 00:19:32,080
filters for validating user application

00:19:28,720 --> 00:19:34,880
and spire web token at both extreme

00:19:32,080 --> 00:19:36,160
our two filters are called bookends

00:19:34,880 --> 00:19:38,000
indeed the purpose

00:19:36,160 --> 00:19:40,080
of the field the first filter at the

00:19:38,000 --> 00:19:41,919
extreme left is to do a deep

00:19:40,080 --> 00:19:44,160
introspection of our quest

00:19:41,919 --> 00:19:45,919
and to mark which upstream filter should

00:19:44,160 --> 00:19:49,520
process it

00:19:45,919 --> 00:19:51,679
meanwhile the purpose of the last filter

00:19:49,520 --> 00:19:53,360
at the extreme right is to make sure

00:19:51,679 --> 00:19:55,760
that the request has been properly

00:19:53,360 --> 00:19:58,480
processed

00:19:55,760 --> 00:20:00,160
it turns out that wasn't filters have

00:19:58,480 --> 00:20:01,760
another way to communicate with one

00:20:00,160 --> 00:20:05,039
another

00:20:01,760 --> 00:20:07,280
by using the request itself

00:20:05,039 --> 00:20:08,400
this can be done with metadata or with

00:20:07,280 --> 00:20:11,600
what i call

00:20:08,400 --> 00:20:16,720
hidden request header again

00:20:11,600 --> 00:20:18,320
we are just experimenting so what's next

00:20:16,720 --> 00:20:20,799
the end of this presentation is still to

00:20:18,320 --> 00:20:22,799
be written but besides

00:20:20,799 --> 00:20:23,840
some new additional requirement i was

00:20:22,799 --> 00:20:26,480
given

00:20:23,840 --> 00:20:27,760
last week solo released a new version of

00:20:26,480 --> 00:20:30,640
the api gateway

00:20:27,760 --> 00:20:32,720
with better resume support additionally

00:20:30,640 --> 00:20:34,640
i just found out that tetrads

00:20:32,720 --> 00:20:36,880
as you've graded that gear their get

00:20:34,640 --> 00:20:40,000
invoice eli to build in rust

00:20:36,880 --> 00:20:43,600
a filter scaffold so clearly

00:20:40,000 --> 00:20:43,600
i will continue exploring

00:20:43,760 --> 00:20:46,880
now let me turn the question around and

00:20:46,400 --> 00:20:50,559
ask

00:20:46,880 --> 00:20:51,840
what's next for you if on one end

00:20:50,559 --> 00:20:53,919
you're interested in better

00:20:51,840 --> 00:20:56,640
understanding and void i encourage you

00:20:53,919 --> 00:20:57,039
to play with weather if on the other

00:20:56,640 --> 00:20:58,640
hand

00:20:57,039 --> 00:21:00,159
you are contemplating getting serious

00:20:58,640 --> 00:21:02,559
with weatherman envoy

00:21:00,159 --> 00:21:05,440
i'd love to hear from you and

00:21:02,559 --> 00:21:05,440
potentially help

00:21:05,520 --> 00:21:08,880
i look forward to your questions

00:21:09,520 --> 00:21:13,919
hello hello everybody thank you for

00:21:12,000 --> 00:21:18,159
attending my presentation

00:21:13,919 --> 00:21:19,600
i i have this presentation was recorded

00:21:18,159 --> 00:21:22,559
a few days ago

00:21:19,600 --> 00:21:24,000
and i shared with the video with the

00:21:22,559 --> 00:21:26,000
meeting organizer and

00:21:24,000 --> 00:21:27,679
a few things happened in between and i

00:21:26,000 --> 00:21:30,000
have to say that a lot of

00:21:27,679 --> 00:21:31,200
innovation is being done with envoy in

00:21:30,000 --> 00:21:34,080
the western

00:21:31,200 --> 00:21:34,640
space the first thing that happened last

00:21:34,080 --> 00:21:38,159
weekend

00:21:34,640 --> 00:21:40,400
is that to date as i mentioned in the

00:21:38,159 --> 00:21:41,600
video you had to use a specific version

00:21:40,400 --> 00:21:46,000
of envoy

00:21:41,600 --> 00:21:49,039
to to to experiment with weather

00:21:46,000 --> 00:21:52,240
it turns out that the wasm envoy

00:21:49,039 --> 00:21:53,679
or the source code of the the the new

00:21:52,240 --> 00:21:56,400
addition has been no merge

00:21:53,679 --> 00:21:58,400
into into envoy into the upstream of

00:21:56,400 --> 00:22:01,679
anybody which means that soon

00:21:58,400 --> 00:22:03,919
i think it will start in version 117

00:22:01,679 --> 00:22:07,039
in the version 117 of envoy where them

00:22:03,919 --> 00:22:07,039
will be available everywhere

00:22:07,679 --> 00:22:11,120
something else i haven't talked about

00:22:10,480 --> 00:22:13,200
about

00:22:11,120 --> 00:22:15,360
uh in this presentation not too much

00:22:13,200 --> 00:22:19,280
because lack of time maybe

00:22:15,360 --> 00:22:22,960
was about uh matrix

00:22:19,280 --> 00:22:23,360
and and and logs as well it turns out

00:22:22,960 --> 00:22:25,679
that

00:22:23,360 --> 00:22:26,640
uh western filters just like native

00:22:25,679 --> 00:22:30,640
filters

00:22:26,640 --> 00:22:32,080
can also act with envoys and communicate

00:22:30,640 --> 00:22:34,799
with the outside world

00:22:32,080 --> 00:22:35,679
using prominent use matrix or matrix

00:22:34,799 --> 00:22:37,760
published

00:22:35,679 --> 00:22:39,280
those metrics will be published in the

00:22:37,760 --> 00:22:41,520
admin

00:22:39,280 --> 00:22:43,840
in the admin interface which is in the

00:22:41,520 --> 00:22:47,120
same ui i introduced earlier

00:22:43,840 --> 00:22:50,240
at the slash stats path so you can

00:22:47,120 --> 00:22:52,799
from usn filter you can add

00:22:50,240 --> 00:22:54,080
matrix that could be meaningful in my

00:22:52,799 --> 00:22:55,200
particular case for example in my

00:22:54,080 --> 00:22:59,120
singletons

00:22:55,200 --> 00:23:02,720
i'm looking into finding out why my

00:22:59,120 --> 00:23:04,400
filters uh would not behave correctly

00:23:02,720 --> 00:23:06,799
for example if i'm trying to reach out

00:23:04,400 --> 00:23:10,400
the policy and for some reason i cannot

00:23:06,799 --> 00:23:11,760
see we want to know that of course once

00:23:10,400 --> 00:23:14,000
your metrics are important mediums if

00:23:11,760 --> 00:23:18,240
you're interested you can also

00:23:14,000 --> 00:23:20,840
you can also highlight on some

00:23:18,240 --> 00:23:22,559
on some triggers which can be useful as

00:23:20,840 --> 00:23:25,760
well

00:23:22,559 --> 00:23:28,159
to develop my filter

00:23:25,760 --> 00:23:29,120
i'm using logs also actually that's my

00:23:28,159 --> 00:23:32,320
main source of

00:23:29,120 --> 00:23:35,760
troubleshooting and when you start

00:23:32,320 --> 00:23:37,679
envoys you can specify some command line

00:23:35,760 --> 00:23:40,000
parameters

00:23:37,679 --> 00:23:41,039
such as component logs so this is really

00:23:40,000 --> 00:23:42,640
on the command line of

00:23:41,039 --> 00:23:44,640
invoice so if you use the containers you

00:23:42,640 --> 00:23:46,240
will have to pass this as

00:23:44,640 --> 00:23:49,039
as the common parameters to the android

00:23:46,240 --> 00:23:50,320
process itself and you can specify the

00:23:49,039 --> 00:23:52,559
log level of

00:23:50,320 --> 00:23:54,400
components and in particular there is a

00:23:52,559 --> 00:23:55,600
component for always and filter which is

00:23:54,400 --> 00:23:58,960
called wasm

00:23:55,600 --> 00:23:59,600
and you can set this uh this android

00:23:58,960 --> 00:24:02,400
component

00:23:59,600 --> 00:24:02,799
called wasm to the level debug and then

00:24:02,400 --> 00:24:05,279
you will

00:24:02,799 --> 00:24:06,960
you will be able to see all the debug

00:24:05,279 --> 00:24:09,520
level messages

00:24:06,960 --> 00:24:10,559
which is quite useful when you are uh

00:24:09,520 --> 00:24:12,400
troubleshooting

00:24:10,559 --> 00:24:14,159
that being said when it's in pollution

00:24:12,400 --> 00:24:17,360
make sure that you do not

00:24:14,159 --> 00:24:20,559
uh run your android in debug level

00:24:17,360 --> 00:24:20,559
including forwards and features

00:24:21,760 --> 00:24:25,600
it turns out also that uh in the past

00:24:23,840 --> 00:24:28,320
few days i have been experimenting

00:24:25,600 --> 00:24:30,159
with get on voice clr catan voicilla

00:24:28,320 --> 00:24:33,760
which i just talked about

00:24:30,159 --> 00:24:36,640
which offers uh rust um

00:24:33,760 --> 00:24:38,480
first uh scaffold to develop filters i'm

00:24:36,640 --> 00:24:42,159
really getting started with this

00:24:38,480 --> 00:24:45,360
uh i'm very pleased by what

00:24:42,159 --> 00:24:48,559
rust provides in terms of the

00:24:45,360 --> 00:24:50,000
developer experience and

00:24:48,559 --> 00:24:51,600
i'm really looking forward to it so

00:24:50,000 --> 00:24:53,279
there are some you don't have to deal

00:24:51,600 --> 00:24:54,960
with bezel anymore because there is no

00:24:53,279 --> 00:24:55,600
there is cargo there is a concept of

00:24:54,960 --> 00:24:58,240
traits

00:24:55,600 --> 00:24:59,440
you have also tests that are integrated

00:24:58,240 --> 00:25:03,039
in language

00:24:59,440 --> 00:25:05,440
and i'm kind of experimenting again

00:25:03,039 --> 00:25:07,120
with this what i found is that if you

00:25:05,440 --> 00:25:07,919
put too many level too many libraries

00:25:07,120 --> 00:25:10,559
into

00:25:07,919 --> 00:25:11,840
usm filters you end up having the resin

00:25:10,559 --> 00:25:14,640
binary itself

00:25:11,840 --> 00:25:15,279
becomes larger and larger and i'm

00:25:14,640 --> 00:25:17,919
wondering

00:25:15,279 --> 00:25:19,120
if we should not be monitoring the size

00:25:17,919 --> 00:25:20,640
of the resin filter

00:25:19,120 --> 00:25:22,240
obviously in my case it's being fetched

00:25:20,640 --> 00:25:25,360
from almost location

00:25:22,240 --> 00:25:29,200
but you have also the concepts of

00:25:25,360 --> 00:25:30,640
concurrencies and i i do not know yet if

00:25:29,200 --> 00:25:31,679
the size of the filter is something that

00:25:30,640 --> 00:25:34,159
should be monitored

00:25:31,679 --> 00:25:35,919
in which case plus plus or even a zombie

00:25:34,159 --> 00:25:38,000
script which has the smallest size

00:25:35,919 --> 00:25:39,919
for what i've seen uh c plus plus you

00:25:38,000 --> 00:25:40,480
can really take only exactly what you

00:25:39,919 --> 00:25:41,919
need

00:25:40,480 --> 00:25:44,000
i'm not too sure if it's possible

00:25:41,919 --> 00:25:46,000
without assuming this but um

00:25:44,000 --> 00:25:47,120
so far the what i've been what i found

00:25:46,000 --> 00:25:50,880
with the rust is that

00:25:47,120 --> 00:25:52,559
my filter was just too hard or extracted

00:25:50,880 --> 00:25:54,799
was a little bit too big to my to my

00:25:52,559 --> 00:25:54,799
test

00:25:55,120 --> 00:25:58,799
another things i i want to talk about is

00:25:57,440 --> 00:26:01,760
about performance

00:25:58,799 --> 00:26:03,120
and it turns out that over an external

00:26:01,760 --> 00:26:06,240
authorization filter

00:26:03,120 --> 00:26:07,760
such as opal and compared to a wasm

00:26:06,240 --> 00:26:10,559
filter which is completely

00:26:07,760 --> 00:26:11,440
compiled you know running inside envoy i

00:26:10,559 --> 00:26:15,200
think you can have

00:26:11,440 --> 00:26:15,840
about 20 times unpromoting performance

00:26:15,200 --> 00:26:18,640
which is

00:26:15,840 --> 00:26:20,159
significant that being said uh with

00:26:18,640 --> 00:26:21,600
resume you have also the concept of

00:26:20,159 --> 00:26:22,960
runtime and i talked about

00:26:21,600 --> 00:26:26,080
the runtime the whole time that i've

00:26:22,960 --> 00:26:27,919
been using was mostly the v8 sandbox

00:26:26,080 --> 00:26:29,600
which i think is the most mature to date

00:26:27,919 --> 00:26:32,240
but there are other sandbox that are

00:26:29,600 --> 00:26:35,440
coming with the v8 sandbox

00:26:32,240 --> 00:26:36,400
really compared to native filters you

00:26:35,440 --> 00:26:38,720
can get

00:26:36,400 --> 00:26:40,400
you can reach approximately 40 of the

00:26:38,720 --> 00:26:43,919
performance of native filters

00:26:40,400 --> 00:26:46,880
which is quite significant

00:26:43,919 --> 00:26:48,080
but some new type of runtime are on the

00:26:46,880 --> 00:26:50,320
way

00:26:48,080 --> 00:26:51,120
where you will be able to get even

00:26:50,320 --> 00:26:54,880
closer to

00:26:51,120 --> 00:26:55,279
native performance there is a the webvm

00:26:54,880 --> 00:26:58,559
which

00:26:55,279 --> 00:27:00,240
with uh with uh uh

00:26:58,559 --> 00:27:02,159
which with which you are you will be

00:27:00,240 --> 00:27:04,480
expected to reach about ninety percent

00:27:02,159 --> 00:27:06,559
uh ninety percent the performance of

00:27:04,480 --> 00:27:10,080
native filters and new vmware

00:27:06,559 --> 00:27:13,360
basically you are using the wasa sdk

00:27:10,080 --> 00:27:16,559
but it's actually almost compiling into

00:27:13,360 --> 00:27:18,640
uh into one board so

00:27:16,559 --> 00:27:20,000
it's quite possible in the future that

00:27:18,640 --> 00:27:22,880
native features

00:27:20,000 --> 00:27:24,320
will be built into wasm to benefit from

00:27:22,880 --> 00:27:26,799
the fact that you can

00:27:24,320 --> 00:27:30,159
bring them in and out based on the

00:27:26,799 --> 00:27:30,159
configuration of the filter itself

00:27:32,159 --> 00:27:36,399
i looked at uh at performance of

00:27:35,279 --> 00:27:39,039
uh you know from aurora quest

00:27:36,399 --> 00:27:41,760
performance as i said uh filters was

00:27:39,039 --> 00:27:42,480
on the request path uh in my particular

00:27:41,760 --> 00:27:44,320
case right i

00:27:42,480 --> 00:27:45,760
i want to make sure i'm getting as much

00:27:44,320 --> 00:27:47,360
performance as possible

00:27:45,760 --> 00:27:49,200
as you have seen in the architecture i

00:27:47,360 --> 00:27:50,960
have right now i have several

00:27:49,200 --> 00:27:53,360
features i don't know if it's the right

00:27:50,960 --> 00:27:55,760
strategy on the request path at least

00:27:53,360 --> 00:27:57,279
uh but that's something i will have to

00:27:55,760 --> 00:28:00,000
to to find out and the way

00:27:57,279 --> 00:28:01,919
i i do it or anytime to do it is by

00:28:00,000 --> 00:28:02,799
using fortune i briefly talked about

00:28:01,919 --> 00:28:05,919
this

00:28:02,799 --> 00:28:09,279
and to try to um

00:28:05,919 --> 00:28:10,880
to experiment uh with the architecture

00:28:09,279 --> 00:28:13,679
of the system

00:28:10,880 --> 00:28:14,880
it turns out that right now instead of

00:28:13,679 --> 00:28:16,559
trying to improve the performance i've

00:28:14,880 --> 00:28:18,320
been trying to saturate

00:28:16,559 --> 00:28:19,840
my creator filter that slows down the

00:28:18,320 --> 00:28:20,799
request to see what would be the

00:28:19,840 --> 00:28:24,559
behavior

00:28:20,799 --> 00:28:26,159
of envoy when it's being saturated

00:28:24,559 --> 00:28:27,760
and that's something that is very

00:28:26,159 --> 00:28:29,840
interesting to me to see what

00:28:27,760 --> 00:28:32,559
what is the expected behavior of envoy

00:28:29,840 --> 00:28:32,960
itself with wasm with wasanthi working

00:28:32,559 --> 00:28:35,520
on

00:28:32,960 --> 00:28:36,960
on getting the highest performance as

00:28:35,520 --> 00:28:38,720
possible i've been trying actually to

00:28:36,960 --> 00:28:39,679
build a filter that literally slows down

00:28:38,720 --> 00:28:42,960
my request

00:28:39,679 --> 00:28:44,640
and sleeps uh and send the request you

00:28:42,960 --> 00:28:46,000
know alpha seven later and then i send a

00:28:44,640 --> 00:28:49,200
lot of requests and i look at

00:28:46,000 --> 00:28:50,799
what android does uh

00:28:49,200 --> 00:28:54,320
that's for me that's interesting that's

00:28:50,799 --> 00:28:58,640
something that i'm exploring as well

00:28:54,320 --> 00:29:00,480
i uh to conclude really i

00:28:58,640 --> 00:29:02,240
if you think about if you think about

00:29:00,480 --> 00:29:05,679
what web assembly is

00:29:02,240 --> 00:29:07,679
really um and if you have been working

00:29:05,679 --> 00:29:10,240
with uh

00:29:07,679 --> 00:29:13,200
with uh with containers for a while i

00:29:10,240 --> 00:29:15,600
think it has a potential to be

00:29:13,200 --> 00:29:16,720
to have a huge impact in the continent

00:29:15,600 --> 00:29:19,679
space

00:29:16,720 --> 00:29:21,440
um for example uh some people say you

00:29:19,679 --> 00:29:23,039
can replace containers themselves with

00:29:21,440 --> 00:29:24,799
a web assembly and actually that's

00:29:23,039 --> 00:29:26,960
something i looked at

00:29:24,799 --> 00:29:28,000
i wanted actually at some point to have

00:29:26,960 --> 00:29:30,720
a web assembly

00:29:28,000 --> 00:29:32,640
singleton that would read my policy

00:29:30,720 --> 00:29:34,080
transform it into regular policy and

00:29:32,640 --> 00:29:37,120
feed it to

00:29:34,080 --> 00:29:39,600
the oppa external filter

00:29:37,120 --> 00:29:40,960
uh i have not completed the work but i

00:29:39,600 --> 00:29:42,799
was thinking oh you know that would

00:29:40,960 --> 00:29:44,960
allow us to migrate from our custom

00:29:42,799 --> 00:29:47,760
policies to something that is more open

00:29:44,960 --> 00:29:49,039
which would be the open policy agent or

00:29:47,760 --> 00:29:50,880
rego policies

00:29:49,039 --> 00:29:53,760
and to try to see that's a way to do the

00:29:50,880 --> 00:29:55,840
transition but if you work also with a

00:29:53,760 --> 00:29:57,679
function as a service you can see that

00:29:55,840 --> 00:29:59,279
actually what android is it's really

00:29:57,679 --> 00:30:00,559
invoking functions

00:29:59,279 --> 00:30:02,320
and those functions are actually the

00:30:00,559 --> 00:30:03,840
function that's here that are in my in

00:30:02,320 --> 00:30:06,399
my wasm filter

00:30:03,840 --> 00:30:07,440
and uh in the space of uh functional

00:30:06,399 --> 00:30:09,840
service i'm

00:30:07,440 --> 00:30:11,520
you know where them can have a huge

00:30:09,840 --> 00:30:13,279
impact

00:30:11,520 --> 00:30:15,520
lots of work is being done there i

00:30:13,279 --> 00:30:18,960
encourage you to have a look at it

00:30:15,520 --> 00:30:22,240
and finally the last notes i think

00:30:18,960 --> 00:30:24,159
there is as i said envoy

00:30:22,240 --> 00:30:25,679
the wasm extension has been merged into

00:30:24,159 --> 00:30:27,279
the stream on envoy

00:30:25,679 --> 00:30:28,799
even so the code has been merged there

00:30:27,279 --> 00:30:30,159
is still a lot of work in terms of the

00:30:28,799 --> 00:30:31,600
documentation

00:30:30,159 --> 00:30:33,279
that needs to happen there is no

00:30:31,600 --> 00:30:35,600
documentation there i think it will be

00:30:33,279 --> 00:30:38,480
there in the 117

00:30:35,600 --> 00:30:40,240
version of envoy documentation so there

00:30:38,480 --> 00:30:42,720
are a lot of opportunities for some of

00:30:40,240 --> 00:30:45,360
you including myself for that matter to

00:30:42,720 --> 00:30:46,799
to contribute to the open source

00:30:45,360 --> 00:30:50,399
community

00:30:46,799 --> 00:30:52,000
that way and if you do not know how to

00:30:50,399 --> 00:30:54,880
do that feel free to reach out to me

00:30:52,000 --> 00:30:55,600
i'll be happy to to help you out in any

00:30:54,880 --> 00:30:57,519
way i can

00:30:55,600 --> 00:30:58,720
you can find me of course on the

00:30:57,519 --> 00:31:01,200
unvoiced channel

00:30:58,720 --> 00:31:02,640
and a few others as well so i look

00:31:01,200 --> 00:31:05,840
forward to hearing from you

00:31:02,640 --> 00:31:05,840

YouTube URL: https://www.youtube.com/watch?v=BZsyqYiD520


