Title: Building idiomatic Envoy SDKs for Rust and Go - Yaroslav Skopets, Takeshi Yoneda
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	Building idiomatic Envoy SDKs for Rust and Go - Yaroslav Skopets, Takeshi Yoneda

Support for WebAssembly is slowly coming into upstream Envoy.

Eager to get our hands dirty, we've embarked on a journey to develop our very first Envoy extensions in Rust and Go - languages beloved by the Cloud Native Community.

It's been a bumpy ride and we're happy we've made it :)

In this session we will share our learnings from building Envoy SDKs for Rust and Go:
* what challenges we've met
* what issues remain open
* what makes SDK ergonomic

We will give a demo of practical extensions that have been made possible so far and, most certainly, will beg Envoy folks to give us even more features we miss so much :)

Our goal is to raise awareness in the community about the current state of Wasm, and to invite everyone to collaborate on the SDK for the language of their choice.
Captions: 
	00:00:01,360 --> 00:00:03,439
hi my name is jaro i'm software engineer

00:00:03,199 --> 00:00:06,240
at

00:00:03,439 --> 00:00:07,279
trade and envy contributor my co-speaker

00:00:06,240 --> 00:00:09,280
today is takeshi

00:00:07,279 --> 00:00:11,280
who is author of the engineer at trade

00:00:09,280 --> 00:00:12,799
and contributed to proxy wasn't

00:00:11,280 --> 00:00:14,320
in this session we'll present you the

00:00:12,799 --> 00:00:17,440
work that we've been doing

00:00:14,320 --> 00:00:20,000
to enable new more accessible way to

00:00:17,440 --> 00:00:23,279
develop extensions for envoy

00:00:20,000 --> 00:00:25,279
so here is our our agenda for today

00:00:23,279 --> 00:00:26,560
first we will explain why webassembly

00:00:25,279 --> 00:00:28,800
out of all these things

00:00:26,560 --> 00:00:30,400
what is a problem then we'll talk

00:00:28,800 --> 00:00:33,200
specifically about webassembly in

00:00:30,400 --> 00:00:35,680
anyway and next we'll introduce you ando

00:00:33,200 --> 00:00:37,840
sdk for us that we've been working on

00:00:35,680 --> 00:00:39,120
and our primary focus will be on lessons

00:00:37,840 --> 00:00:41,200
learned because

00:00:39,120 --> 00:00:42,800
they are not limited to rust and go

00:00:41,200 --> 00:00:44,800
we've picked those items that are

00:00:42,800 --> 00:00:47,440
universal and with minor changes

00:00:44,800 --> 00:00:48,800
can apply to every language after that

00:00:47,440 --> 00:00:50,719
we'll demo a practical

00:00:48,800 --> 00:00:52,879
ready-to-use extension that has been

00:00:50,719 --> 00:00:55,600
developed using this sdk

00:00:52,879 --> 00:00:56,480
and then takeshi will take over to

00:00:55,600 --> 00:00:59,520
update you

00:00:56,480 --> 00:01:01,520
on almost any sdk for go

00:00:59,520 --> 00:01:04,159
we'll finish with key takeaways call to

00:01:01,520 --> 00:01:06,720
action and q a session

00:01:04,159 --> 00:01:07,680
let's be clear about the goals we set

00:01:06,720 --> 00:01:10,560
for this session

00:01:07,680 --> 00:01:11,760
for ourselves we want you to walk away

00:01:10,560 --> 00:01:14,240
out of the session

00:01:11,760 --> 00:01:15,119
knowing what web assembly in anyway is

00:01:14,240 --> 00:01:17,520
all about

00:01:15,119 --> 00:01:18,320
how to get the most out of it as of

00:01:17,520 --> 00:01:20,080
today

00:01:18,320 --> 00:01:21,759
and what are the lessons learned by the

00:01:20,080 --> 00:01:24,000
community so far

00:01:21,759 --> 00:01:26,320
so this is informational component but

00:01:24,000 --> 00:01:27,439
there is also inspirational one we want

00:01:26,320 --> 00:01:30,240
to inspire you

00:01:27,439 --> 00:01:31,439
to give up assembly a real try not in a

00:01:30,240 --> 00:01:33,040
year from now

00:01:31,439 --> 00:01:34,479
when you might think it will be finally

00:01:33,040 --> 00:01:37,759
production ready but

00:01:34,479 --> 00:01:39,200
today so give it a try to extensions

00:01:37,759 --> 00:01:41,360
that we've been developing

00:01:39,200 --> 00:01:42,320
and that will show you later in the demo

00:01:41,360 --> 00:01:44,079
section

00:01:42,320 --> 00:01:46,320
try to develop a new extension of your

00:01:44,079 --> 00:01:47,439
own try to develop nysdk for your

00:01:46,320 --> 00:01:50,159
favorite language

00:01:47,439 --> 00:01:50,720
and ultimately join the community and

00:01:50,159 --> 00:01:54,159
help us

00:01:50,720 --> 00:01:56,399
to develop all these things together

00:01:54,159 --> 00:01:58,000
so as attendee to this conference you're

00:01:56,399 --> 00:02:01,119
probably familiar with the status quo

00:01:58,000 --> 00:02:03,280
of invo extensibility you have to

00:02:01,119 --> 00:02:04,799
develop custom extensions in c plus plus

00:02:03,280 --> 00:02:07,600
statistically link them into invoice

00:02:04,799 --> 00:02:09,200
binary maintain a custom build of envoy

00:02:07,600 --> 00:02:11,520
keep up with upstream changes keep up

00:02:09,200 --> 00:02:12,640
with security releases overall there is

00:02:11,520 --> 00:02:15,120
a lot of burden

00:02:12,640 --> 00:02:16,959
involved when you decide to extend envoy

00:02:15,120 --> 00:02:18,959
in such a way

00:02:16,959 --> 00:02:20,720
that's why another community has been

00:02:18,959 --> 00:02:22,319
asking for a long way for different

00:02:20,720 --> 00:02:24,000
for a long time for a different

00:02:22,319 --> 00:02:25,680
extensibility model

00:02:24,000 --> 00:02:27,040
where extensions could be loaded into

00:02:25,680 --> 00:02:29,360
android dynamically

00:02:27,040 --> 00:02:30,319
and ideally it would be possible to

00:02:29,360 --> 00:02:32,879
develop extensions

00:02:30,319 --> 00:02:34,000
in languages other than cpus plus and

00:02:32,879 --> 00:02:36,480
webassembly is

00:02:34,000 --> 00:02:38,640
an answer is technology that makes it

00:02:36,480 --> 00:02:41,040
all possible

00:02:38,640 --> 00:02:42,720
so webassembly is a virtual machine and

00:02:41,040 --> 00:02:44,080
compilation target for general purpose

00:02:42,720 --> 00:02:46,000
programming languages

00:02:44,080 --> 00:02:47,200
what it means is that you can develop

00:02:46,000 --> 00:02:49,040
applications

00:02:47,200 --> 00:02:50,959
in programming languages like cpus plus

00:02:49,040 --> 00:02:51,760
or as to go but when it comes to

00:02:50,959 --> 00:02:53,920
compilation

00:02:51,760 --> 00:02:56,319
compile into webassembly code instead of

00:02:53,920 --> 00:02:59,040
machine code

00:02:56,319 --> 00:03:00,640
envoy plays a role of assembly host it's

00:02:59,040 --> 00:03:01,599
responsible for loading and loading

00:03:00,640 --> 00:03:04,000
webassembly

00:03:01,599 --> 00:03:05,680
based extensions at runtime for

00:03:04,000 --> 00:03:08,000
exporting apis

00:03:05,680 --> 00:03:09,760
that such extensions can use and

00:03:08,000 --> 00:03:13,599
integrating such extensions

00:03:09,760 --> 00:03:15,599
into its regular request processing flow

00:03:13,599 --> 00:03:18,159
the final piece of the puzzle that you

00:03:15,599 --> 00:03:20,239
need to know is proximation abi

00:03:18,159 --> 00:03:22,720
it's a specification of a low level

00:03:20,239 --> 00:03:24,400
interface between proxy and webassembly

00:03:22,720 --> 00:03:27,120
based extension

00:03:24,400 --> 00:03:28,159
as its name implies it's not limited to

00:03:27,120 --> 00:03:29,599
envoy

00:03:28,159 --> 00:03:31,519
and it's meant to allow the same

00:03:29,599 --> 00:03:33,440
extension to run inside

00:03:31,519 --> 00:03:34,799
various proxies compatible with this

00:03:33,440 --> 00:03:38,400
spec

00:03:34,799 --> 00:03:38,720
very ambitious goal so the next question

00:03:38,400 --> 00:03:41,840
is

00:03:38,720 --> 00:03:43,440
why rust as we mentioned you can develop

00:03:41,840 --> 00:03:45,120
webassembly-based extensions

00:03:43,440 --> 00:03:47,680
in any language that supports

00:03:45,120 --> 00:03:49,120
compilation into webassembly code

00:03:47,680 --> 00:03:51,280
so how do you choose one of these

00:03:49,120 --> 00:03:54,159
languages

00:03:51,280 --> 00:03:54,959
we prepared a table and we suggest you

00:03:54,159 --> 00:03:56,959
to try

00:03:54,959 --> 00:03:59,040
to make the decision to try to answer

00:03:56,959 --> 00:04:02,480
the phone questions

00:03:59,040 --> 00:04:04,879
can you use features of this language uh

00:04:02,480 --> 00:04:05,920
all feature source language and all its

00:04:04,879 --> 00:04:07,519
standard library

00:04:05,920 --> 00:04:09,280
if you're going to compile it into

00:04:07,519 --> 00:04:12,480
webassembly will you

00:04:09,280 --> 00:04:14,400
be able to reuse as a library ecosystem

00:04:12,480 --> 00:04:16,320
and will the language retain its

00:04:14,400 --> 00:04:18,400
original performance characteristics

00:04:16,320 --> 00:04:20,560
if compiled into webassembly instead of

00:04:18,400 --> 00:04:23,120
machine code

00:04:20,560 --> 00:04:25,199
well as you can see c plus plus and rust

00:04:23,120 --> 00:04:27,280
are the most obvious choices

00:04:25,199 --> 00:04:29,120
however don't be discouraged about

00:04:27,280 --> 00:04:31,680
assembly script in tiny go

00:04:29,120 --> 00:04:34,080
just set your expectations right in

00:04:31,680 --> 00:04:34,080
advance

00:04:34,960 --> 00:04:39,120
so to be fair there are sdks available

00:04:37,919 --> 00:04:41,440
for envoy

00:04:39,120 --> 00:04:42,960
simplesplash sdk assemblyscript sdk and

00:04:41,440 --> 00:04:46,000
even rust sdk

00:04:42,960 --> 00:04:48,720
so why do did we decide to develop

00:04:46,000 --> 00:04:49,360
yet another one so after looking into

00:04:48,720 --> 00:04:51,680
all the

00:04:49,360 --> 00:04:53,360
sdks we came up with a slightly

00:04:51,680 --> 00:04:55,360
different set of requirements

00:04:53,360 --> 00:04:57,520
first of all we want our extension model

00:04:55,360 --> 00:04:58,880
to be independent from work proximation

00:04:57,520 --> 00:05:01,919
ebi

00:04:58,880 --> 00:05:04,479
as we mentioned proxibus api tries to be

00:05:01,919 --> 00:05:05,520
compatible with all proxies out there

00:05:04,479 --> 00:05:09,759
which means

00:05:05,520 --> 00:05:12,960
that it's not really aligned with envoy

00:05:09,759 --> 00:05:14,800
so when we develop http filter often for

00:05:12,960 --> 00:05:16,240
and we want to call this to filter and

00:05:14,800 --> 00:05:18,479
not http context

00:05:16,240 --> 00:05:20,160
when we develop http filter factory we

00:05:18,479 --> 00:05:20,960
want to call it this way instead of root

00:05:20,160 --> 00:05:23,120
context

00:05:20,960 --> 00:05:24,000
and when we develop access logger we

00:05:23,120 --> 00:05:25,680
want to call it this way

00:05:24,000 --> 00:05:28,800
instead of well there is no even

00:05:25,680 --> 00:05:31,759
equivalent in proxy bus

00:05:28,800 --> 00:05:33,199
next we want to develop all types of

00:05:31,759 --> 00:05:35,759
android extensions

00:05:33,199 --> 00:05:36,240
and we want to use the same sdk for all

00:05:35,759 --> 00:05:39,039
of them

00:05:36,240 --> 00:05:39,520
and the same model for all of them next

00:05:39,039 --> 00:05:42,160
we

00:05:39,520 --> 00:05:44,880
want to have seamless migration paths

00:05:42,160 --> 00:05:48,000
for existing extensions from c plus plus

00:05:44,880 --> 00:05:50,320
into rust webassembly

00:05:48,000 --> 00:05:51,120
and finally we want source code of our

00:05:50,320 --> 00:05:54,080
extensions

00:05:51,120 --> 00:05:55,039
to be unit testable so here is a quick

00:05:54,080 --> 00:05:57,759
glimpse into

00:05:55,039 --> 00:06:00,240
nysdk for us to give you an idea how the

00:05:57,759 --> 00:06:03,440
source code looks like

00:06:00,240 --> 00:06:06,720
this is hello world http filter

00:06:03,440 --> 00:06:09,919
where we handle request headers next

00:06:06,720 --> 00:06:13,039
this is factory for this hp filter

00:06:09,919 --> 00:06:15,280
responsible for creating new instances

00:06:13,039 --> 00:06:16,800
and initialize them with some shared

00:06:15,280 --> 00:06:21,039
state

00:06:16,800 --> 00:06:23,600
this is an example of how to use

00:06:21,039 --> 00:06:24,080
apis provided by any host like in this

00:06:23,600 --> 00:06:27,039
case

00:06:24,080 --> 00:06:28,720
stream info api that you can use to find

00:06:27,039 --> 00:06:31,360
out more information about

00:06:28,720 --> 00:06:32,880
current request that is being processed

00:06:31,360 --> 00:06:35,759
and finally

00:06:32,880 --> 00:06:37,440
example of a unit test where we create

00:06:35,759 --> 00:06:40,560
something called fake envoy

00:06:37,440 --> 00:06:43,120
setup listener send request and a third

00:06:40,560 --> 00:06:43,120
response

00:06:43,280 --> 00:06:46,720
so the primary goal of the session is to

00:06:45,199 --> 00:06:48,960
share experience

00:06:46,720 --> 00:06:50,960
so let's work through the issues we've

00:06:48,960 --> 00:06:52,960
met while developing this sdk

00:06:50,960 --> 00:06:54,720
the lessons we learned and some random

00:06:52,960 --> 00:06:58,319
notes on the current status of

00:06:54,720 --> 00:07:01,039
proximation api and envoy

00:06:58,319 --> 00:07:02,160
error handing is a crucial to every

00:07:01,039 --> 00:07:03,840
application

00:07:02,160 --> 00:07:06,080
this is why the very first question you

00:07:03,840 --> 00:07:08,400
might want to ask is what happens

00:07:06,080 --> 00:07:11,039
when things go wrong so what happens

00:07:08,400 --> 00:07:13,919
when extension fails at runtime

00:07:11,039 --> 00:07:15,120
let's try to find out by introducing

00:07:13,919 --> 00:07:19,360
intentional error

00:07:15,120 --> 00:07:21,120
like index out of bounds error

00:07:19,360 --> 00:07:22,880
so what happens if you try to run this

00:07:21,120 --> 00:07:24,479
code

00:07:22,880 --> 00:07:26,720
you'll find out that until there is

00:07:24,479 --> 00:07:28,880
recently nowhere was completely crashing

00:07:26,720 --> 00:07:31,199
after such a bug in extension code

00:07:28,880 --> 00:07:32,800
so apparently webassembly sunbox wasn't

00:07:31,199 --> 00:07:34,800
a true sandbox

00:07:32,800 --> 00:07:36,560
right now android behavior has changed

00:07:34,800 --> 00:07:39,680
and it doesn't crash anymore

00:07:36,560 --> 00:07:40,960
but it doesn't work either once error

00:07:39,680 --> 00:07:43,360
like index out of

00:07:40,960 --> 00:07:46,240
bound happened this filter stops

00:07:43,360 --> 00:07:47,840
completely stops working

00:07:46,240 --> 00:07:50,479
so if we look into the cost of this

00:07:47,840 --> 00:07:52,879
error it happens that

00:07:50,479 --> 00:07:54,000
when panic is happening inside

00:07:52,879 --> 00:07:57,440
webassembly code

00:07:54,000 --> 00:08:00,000
its execution gets terminated abruptly

00:07:57,440 --> 00:08:02,160
without doing stack unwinding it means

00:08:00,000 --> 00:08:05,520
that memory and heap and locks

00:08:02,160 --> 00:08:05,840
are not released and consequently it's

00:08:05,520 --> 00:08:08,400
not

00:08:05,840 --> 00:08:11,759
longer it's no longer safe to use not

00:08:08,400 --> 00:08:14,000
only a single hdb filter instance

00:08:11,759 --> 00:08:16,000
the error has originally happened but

00:08:14,000 --> 00:08:18,479
zentai wasn't vm

00:08:16,000 --> 00:08:20,560
in other words when error happens it

00:08:18,479 --> 00:08:23,440
affects not only a single hp request

00:08:20,560 --> 00:08:27,039
but rather all requests that being

00:08:23,440 --> 00:08:31,199
processed by envoy in parallel

00:08:27,039 --> 00:08:35,039
so what solutions

00:08:31,199 --> 00:08:36,000
can be there first of all without proper

00:08:35,039 --> 00:08:37,440
support for

00:08:36,000 --> 00:08:39,120
stack unwinding that should be

00:08:37,440 --> 00:08:40,800
implemented by webassembly engine

00:08:39,120 --> 00:08:42,159
and your programming language it's not

00:08:40,800 --> 00:08:43,680
possible to handle this station

00:08:42,159 --> 00:08:46,080
gracefully

00:08:43,680 --> 00:08:47,120
until then until such support is

00:08:46,080 --> 00:08:49,680
implemented

00:08:47,120 --> 00:08:50,800
avoid panics in the source code of your

00:08:49,680 --> 00:08:54,720
extension and your

00:08:50,800 --> 00:08:55,760
sdk as an example we've designed envoy

00:08:54,720 --> 00:08:58,560
sdk for us

00:08:55,760 --> 00:09:00,800
to never panic there are no calls to

00:08:58,560 --> 00:09:03,440
panic and rape expect in our source code

00:09:00,800 --> 00:09:05,839
and all apis must return result type

00:09:03,440 --> 00:09:05,839
instead

00:09:07,279 --> 00:09:13,680
um this next question so once you

00:09:10,480 --> 00:09:13,680
eliminate all the panics

00:09:14,240 --> 00:09:18,480
the next question is how do you handle

00:09:16,880 --> 00:09:20,800
errors

00:09:18,480 --> 00:09:22,720
and here is an example of once again

00:09:20,800 --> 00:09:26,720
example of our source code

00:09:22,720 --> 00:09:30,399
this is a http filter and

00:09:26,720 --> 00:09:33,200
callback which allows extension to

00:09:30,399 --> 00:09:35,600
observe and manipulate request headers

00:09:33,200 --> 00:09:37,519
this method itself return result type

00:09:35,600 --> 00:09:38,800
instead of panicking and inside this

00:09:37,519 --> 00:09:42,480
method we called

00:09:38,800 --> 00:09:45,519
one of apis provided by anyway yeah like

00:09:42,480 --> 00:09:47,600
get request headers there's one thing

00:09:45,519 --> 00:09:50,800
that you need to know about

00:09:47,600 --> 00:09:53,279
calls from extension into an envoy

00:09:50,800 --> 00:09:54,480
is it all such calls can end up with an

00:09:53,279 --> 00:09:56,800
error and

00:09:54,480 --> 00:09:59,760
you need to handle them in some way

00:09:56,800 --> 00:10:02,399
however in most cases

00:09:59,760 --> 00:10:02,800
those errors are not recoverable and the

00:10:02,399 --> 00:10:04,720
only

00:10:02,800 --> 00:10:06,720
logical way that you can do just to

00:10:04,720 --> 00:10:08,480
propagate it up

00:10:06,720 --> 00:10:10,880
rust provides very convenient syntax

00:10:08,480 --> 00:10:13,200
here like this question mark

00:10:10,880 --> 00:10:15,680
operator that allows you just to

00:10:13,200 --> 00:10:18,000
propagate

00:10:15,680 --> 00:10:18,880
error up but in the end there must be

00:10:18,000 --> 00:10:21,279
some

00:10:18,880 --> 00:10:22,800
code somewhere that actually does error

00:10:21,279 --> 00:10:26,000
handling

00:10:22,800 --> 00:10:28,399
so our solution to that that we move all

00:10:26,000 --> 00:10:29,279
just error handy logic out of your

00:10:28,399 --> 00:10:32,800
extension

00:10:29,279 --> 00:10:33,680
into sdk itself so as long as your

00:10:32,800 --> 00:10:36,640
extension

00:10:33,680 --> 00:10:37,920
returns error and not panic we will be

00:10:36,640 --> 00:10:41,360
able to

00:10:37,920 --> 00:10:44,000
provide proper error handling logic

00:10:41,360 --> 00:10:44,720
so for hd filters we will reply with

00:10:44,000 --> 00:10:47,920
http

00:10:44,720 --> 00:10:48,800
status 500 internal service error and

00:10:47,920 --> 00:10:50,959
for network

00:10:48,800 --> 00:10:52,320
filters ideally we would close the

00:10:50,959 --> 00:10:53,920
connection entirely

00:10:52,320 --> 00:10:55,760
however it's not possible right now

00:10:53,920 --> 00:10:58,839
because proxy wasn't abi

00:10:55,760 --> 00:11:01,839
doesn't support closing connections just

00:10:58,839 --> 00:11:04,399
yet

00:11:01,839 --> 00:11:06,079
next about error handling you need to

00:11:04,399 --> 00:11:08,079
know that webassembly doesn't support

00:11:06,079 --> 00:11:10,800
taking a stack trace

00:11:08,079 --> 00:11:12,240
so if we take a look into our array

00:11:10,800 --> 00:11:15,440
index

00:11:12,240 --> 00:11:19,200
out of bounds error once again uh

00:11:15,440 --> 00:11:20,800
and the log uh and the line is low that

00:11:19,200 --> 00:11:23,920
it leaves

00:11:20,800 --> 00:11:24,560
it doesn't have the entire complete

00:11:23,920 --> 00:11:27,440
stack trace

00:11:24,560 --> 00:11:28,000
but rather only a single line and often

00:11:27,440 --> 00:11:29,600
one line

00:11:28,000 --> 00:11:31,040
is not enough to understand this entire

00:11:29,600 --> 00:11:34,160
context that led

00:11:31,040 --> 00:11:34,160
to this particular error

00:11:34,480 --> 00:11:37,680
so this is this issue is not unique to

00:11:36,720 --> 00:11:40,560
rust

00:11:37,680 --> 00:11:41,760
it's inherent to webassembly itself and

00:11:40,560 --> 00:11:44,399
in order to fix

00:11:41,760 --> 00:11:45,120
this there is a proposal in wasi which

00:11:44,399 --> 00:11:48,720
is

00:11:45,120 --> 00:11:50,639
a system interface for webassembly

00:11:48,720 --> 00:11:52,160
until it gets fixed properly in the meal

00:11:50,639 --> 00:11:54,240
time

00:11:52,160 --> 00:11:55,760
the only workaround is to enrich the

00:11:54,240 --> 00:11:58,720
context for your errors

00:11:55,760 --> 00:12:02,000
manually for example by wrapping them

00:11:58,720 --> 00:12:02,000
before propagating them up

00:12:04,000 --> 00:12:09,200
watch out for string type in your

00:12:06,639 --> 00:12:12,079
programming language

00:12:09,200 --> 00:12:12,720
c plus plus and in c plus plus and go

00:12:12,079 --> 00:12:15,360
string

00:12:12,720 --> 00:12:17,279
is an arbitrary byte array while in rust

00:12:15,360 --> 00:12:20,320
and assembly script

00:12:17,279 --> 00:12:23,120
string must be utf encoded

00:12:20,320 --> 00:12:25,680
so the problem is that when you uh with

00:12:23,120 --> 00:12:28,399
things like http header values

00:12:25,680 --> 00:12:30,480
are not required to be utf-8 encoded so

00:12:28,399 --> 00:12:32,480
anyway we'll happily pass these values

00:12:30,480 --> 00:12:34,880
into your extension

00:12:32,480 --> 00:12:36,399
and your extension will crash while

00:12:34,880 --> 00:12:40,560
trying to tube them

00:12:36,399 --> 00:12:40,560
as utf-8 encoded

00:12:40,800 --> 00:12:43,920
and the problem is it's security

00:12:42,560 --> 00:12:46,560
vulnerability

00:12:43,920 --> 00:12:48,240
attacker can crash your envoy or make

00:12:46,560 --> 00:12:52,000
extension non-operational

00:12:48,240 --> 00:12:54,560
by sending specific request data

00:12:52,000 --> 00:12:56,079
so as a solution in android sdk for us

00:12:54,560 --> 00:12:59,279
we're using a custom

00:12:56,079 --> 00:13:01,040
type bytestream to be very specific very

00:12:59,279 --> 00:13:03,839
explicit

00:13:01,040 --> 00:13:05,760
about those places where utf encoding is

00:13:03,839 --> 00:13:08,399
not guaranteed

00:13:05,760 --> 00:13:10,160
also we'd like to ask proximation spec

00:13:08,399 --> 00:13:11,040
to be more explicit about encoding of

00:13:10,160 --> 00:13:13,920
strings

00:13:11,040 --> 00:13:15,760
in its apis because using by streaming

00:13:13,920 --> 00:13:17,920
everywhere is not a solution

00:13:15,760 --> 00:13:19,760
it makes things more complicated when

00:13:17,920 --> 00:13:23,440
you need to pass such a value into

00:13:19,760 --> 00:13:23,440
next string scientific api

00:13:24,079 --> 00:13:27,440
let's move on to unit testing there are

00:13:26,480 --> 00:13:30,480
two approaches

00:13:27,440 --> 00:13:31,839
how to unit test code of your extension

00:13:30,480 --> 00:13:34,160
or sdk

00:13:31,839 --> 00:13:35,200
one of them is to compile into

00:13:34,160 --> 00:13:37,120
webassembly code

00:13:35,200 --> 00:13:38,800
and run it inside a real webassembly

00:13:37,120 --> 00:13:40,560
host

00:13:38,800 --> 00:13:42,160
a second option is to compile

00:13:40,560 --> 00:13:44,079
internative machine code

00:13:42,160 --> 00:13:45,519
and run it without any ties to

00:13:44,079 --> 00:13:48,320
webassembly

00:13:45,519 --> 00:13:48,880
and the problem here is that to be able

00:13:48,320 --> 00:13:51,199
to run

00:13:48,880 --> 00:13:52,160
gene test inside real web assembly host

00:13:51,199 --> 00:13:53,839
you need at least

00:13:52,160 --> 00:13:56,399
a voice support which is a system

00:13:53,839 --> 00:13:58,160
interface for the assembly

00:13:56,399 --> 00:14:00,000
however there is an issue in proximation

00:13:58,160 --> 00:14:02,160
api in particular

00:14:00,000 --> 00:14:03,839
function named emmalog that makes it

00:14:02,160 --> 00:14:05,440
impossible to use it with the rastal

00:14:03,839 --> 00:14:08,959
chain

00:14:05,440 --> 00:14:10,560
so at the new time we run our unit test

00:14:08,959 --> 00:14:11,040
by compiling them into native machine

00:14:10,560 --> 00:14:13,040
code

00:14:11,040 --> 00:14:14,959
and running them without any type of

00:14:13,040 --> 00:14:17,839
assembly which is not bad

00:14:14,959 --> 00:14:17,839
just not perfect

00:14:18,399 --> 00:14:22,240
um next we want to notice that we've

00:14:20,959 --> 00:14:26,079
gone a great length

00:14:22,240 --> 00:14:29,680
to support unit testing of extensions

00:14:26,079 --> 00:14:31,519
to test individual methods functions in

00:14:29,680 --> 00:14:33,839
isolation we provide some fake

00:14:31,519 --> 00:14:36,160
implementations like fake stats fake

00:14:33,839 --> 00:14:38,160
http client for extreme info

00:14:36,160 --> 00:14:39,839
on top of this we also provide test

00:14:38,160 --> 00:14:42,000
framework that simulates

00:14:39,839 --> 00:14:42,880
in a way request processing flow it

00:14:42,000 --> 00:14:45,600
might seem to

00:14:42,880 --> 00:14:46,800
too much and it probably is but it

00:14:45,600 --> 00:14:50,560
allowed us to catch

00:14:46,800 --> 00:14:53,040
some blanks in proxy wasn't spec

00:14:50,560 --> 00:14:55,760
and some bugs quirks in real and way

00:14:53,040 --> 00:14:55,760
implementation

00:14:56,959 --> 00:15:01,279
the next thing to watch out for is that

00:14:58,959 --> 00:15:02,160
proximation to be aware of is that proxy

00:15:01,279 --> 00:15:04,959
wasn't spec

00:15:02,160 --> 00:15:06,639
emits details in certain cases leaving

00:15:04,959 --> 00:15:09,360
no other choice

00:15:06,639 --> 00:15:10,320
but to learn how to use api by looking

00:15:09,360 --> 00:15:13,199
into

00:15:10,320 --> 00:15:14,880
invoice source code instead for example

00:15:13,199 --> 00:15:18,000
so-called mysterious yellow

00:15:14,880 --> 00:15:21,040
proxy get property api

00:15:18,000 --> 00:15:24,240
which under the hood uses some ad-hoc

00:15:21,040 --> 00:15:26,399
data encoding so after

00:15:24,240 --> 00:15:28,399
reverse engineering and resources we

00:15:26,399 --> 00:15:31,519
were finally able to

00:15:28,399 --> 00:15:34,240
offer much more friendly api for the

00:15:31,519 --> 00:15:36,720
users of our moa sdk for us

00:15:34,240 --> 00:15:37,839
yeah like like in this example uh when

00:15:36,720 --> 00:15:39,519
you

00:15:37,839 --> 00:15:41,440
we we are now able to provide strongly

00:15:39,519 --> 00:15:43,680
type api to

00:15:41,440 --> 00:15:44,880
get from android information about

00:15:43,680 --> 00:15:47,040
single request

00:15:44,880 --> 00:15:49,440
for example connection id request id

00:15:47,040 --> 00:15:52,000
plugin name

00:15:49,440 --> 00:15:54,639
and finally final thought about

00:15:52,000 --> 00:15:56,639
ergonomics of sdk

00:15:54,639 --> 00:15:57,839
the sdk should make a straightforward

00:15:56,639 --> 00:16:00,959
how to use

00:15:57,839 --> 00:16:03,279
apis correctly in other words

00:16:00,959 --> 00:16:04,399
proxy based on spec should not be on the

00:16:03,279 --> 00:16:07,920
learning paths of

00:16:04,399 --> 00:16:08,560
every extension developer so to make it

00:16:07,920 --> 00:16:11,040
possible

00:16:08,560 --> 00:16:12,240
we have to be very opinionated in our

00:16:11,040 --> 00:16:14,639
sdk

00:16:12,240 --> 00:16:15,279
we delivery deliberately abstract it

00:16:14,639 --> 00:16:18,320
away from

00:16:15,279 --> 00:16:21,040
the low level proximation api

00:16:18,320 --> 00:16:21,680
to make our apis more idiomatic to the

00:16:21,040 --> 00:16:25,199
language

00:16:21,680 --> 00:16:28,399
and more intuitive to the users

00:16:25,199 --> 00:16:31,759
and finally its demo time so i've been

00:16:28,399 --> 00:16:33,360
telling you how great rust is how great

00:16:31,759 --> 00:16:35,120
and why is the case but now you're

00:16:33,360 --> 00:16:37,279
probably wondering like okay

00:16:35,120 --> 00:16:38,880
show me the code yeah just are there any

00:16:37,279 --> 00:16:39,920
real extensions that has been developed

00:16:38,880 --> 00:16:42,160
this way

00:16:39,920 --> 00:16:43,519
and this is like proud moment where we

00:16:42,160 --> 00:16:44,880
can finally share with you

00:16:43,519 --> 00:16:47,519
some work that we've been doing at the

00:16:44,880 --> 00:16:49,680
trade so at a trade we care a lot about

00:16:47,519 --> 00:16:52,000
enterprise use case

00:16:49,680 --> 00:16:53,839
and so-called legacy software those

00:16:52,000 --> 00:16:54,480
legacy systems have been around for

00:16:53,839 --> 00:16:56,399
decades

00:16:54,480 --> 00:16:58,399
and will probably stay in the road

00:16:56,399 --> 00:17:00,560
around for another decades

00:16:58,399 --> 00:17:02,399
so instead of fighting them off we

00:17:00,560 --> 00:17:04,079
embrace them

00:17:02,399 --> 00:17:06,480
so we've been working on on something

00:17:04,079 --> 00:17:08,559
called can be called enterprise suite

00:17:06,480 --> 00:17:10,480
which consists of extensions and

00:17:08,559 --> 00:17:12,400
extensions that are not

00:17:10,480 --> 00:17:14,720
cloud native they're not hot

00:17:12,400 --> 00:17:17,039
technologies but still they can be quite

00:17:14,720 --> 00:17:18,880
useful in device environment as an

00:17:17,039 --> 00:17:21,679
example it's sncp filter

00:17:18,880 --> 00:17:22,480
and ldap filter and more will follow so

00:17:21,679 --> 00:17:24,720
in the demo

00:17:22,480 --> 00:17:25,760
i will show you a smtp filter but if you

00:17:24,720 --> 00:17:28,880
prefer ldap

00:17:25,760 --> 00:17:31,120
filter more you can check it out on your

00:17:28,880 --> 00:17:31,120
own

00:17:31,440 --> 00:17:35,600
the use case for android smtp filter is

00:17:33,760 --> 00:17:36,320
to bring visibility into how your

00:17:35,600 --> 00:17:39,440
applications

00:17:36,320 --> 00:17:41,520
make use of smtp

00:17:39,440 --> 00:17:43,600
so let's see how noi can help us with

00:17:41,520 --> 00:17:46,640
that

00:17:43,600 --> 00:17:50,640
we will first set up test environment

00:17:46,640 --> 00:17:51,039
we will run smgp server convenient for

00:17:50,640 --> 00:17:53,840
use

00:17:51,039 --> 00:17:54,799
in development it has some user

00:17:53,840 --> 00:17:57,600
interfaces

00:17:54,799 --> 00:17:58,640
we can use to make sure that messages

00:17:57,600 --> 00:18:01,840
indeed arriving

00:17:58,640 --> 00:18:01,840
at smtp server

00:18:02,160 --> 00:18:08,160
and we have example java application

00:18:06,080 --> 00:18:09,360
that will be every second we will be

00:18:08,160 --> 00:18:14,160
logging in error

00:18:09,360 --> 00:18:16,960
and every error will be sent by email

00:18:14,160 --> 00:18:18,480
so let's run this application and we

00:18:16,960 --> 00:18:21,760
should see

00:18:18,480 --> 00:18:21,760
messages start arriving

00:18:23,840 --> 00:18:29,840
so let's take a look next what's going

00:18:26,400 --> 00:18:29,840
on on the wire

00:18:37,679 --> 00:18:42,000
you can see that smtp is a simple

00:18:39,679 --> 00:18:45,200
text-based protocol

00:18:42,000 --> 00:18:47,760
where a client is sending commands and

00:18:45,200 --> 00:18:48,880
server response with replies so a

00:18:47,760 --> 00:18:52,240
typical email

00:18:48,880 --> 00:18:55,200
transaction consists of a client filling

00:18:52,240 --> 00:18:56,559
in fields like from and two and

00:18:55,200 --> 00:19:00,320
providing the message

00:18:56,559 --> 00:19:00,320
of email

00:19:00,400 --> 00:19:06,960
once a sncp client is finished sending

00:19:03,919 --> 00:19:08,160
a message body transaction

00:19:06,960 --> 00:19:10,080
email transaction is considered

00:19:08,160 --> 00:19:11,760
committed and now it's time for sarah to

00:19:10,080 --> 00:19:14,799
either accept it accept email for

00:19:11,760 --> 00:19:18,400
delivery or rejected

00:19:14,799 --> 00:19:21,760
in this case cntp server accepts

00:19:18,400 --> 00:19:25,840
email message and client can now quit

00:19:21,760 --> 00:19:25,840
and close session

00:19:36,960 --> 00:19:41,280
to envoy instead of sending them

00:19:38,559 --> 00:19:43,360
directly into sntp server

00:19:41,280 --> 00:19:46,160
and then we will start and avoid with

00:19:43,360 --> 00:19:46,160
our extension

00:19:46,559 --> 00:19:50,320
pre-configured so we're using get new

00:19:49,440 --> 00:19:52,559
tool

00:19:50,320 --> 00:19:54,559
to start and avoid with

00:19:52,559 --> 00:19:56,559
webassembly-based extension in it

00:19:54,559 --> 00:19:58,480
uh getting away is one of the tools open

00:19:56,559 --> 00:20:01,200
source tools we developed a titrate

00:19:58,480 --> 00:20:02,960
to help you getting started with uh

00:20:01,200 --> 00:20:05,520
developing webassembly based annual

00:20:02,960 --> 00:20:05,520
extensions

00:20:05,600 --> 00:20:13,520
so let's see matrix

00:20:09,520 --> 00:20:13,520
okay okay application's not started

00:20:19,440 --> 00:20:23,840
yeah we can see that envoy is now

00:20:22,559 --> 00:20:27,679
collecting metrics about

00:20:23,840 --> 00:20:28,880
sntp traffic at high level we see number

00:20:27,679 --> 00:20:31,280
of emails

00:20:28,880 --> 00:20:32,240
that and voice has been seen sent by

00:20:31,280 --> 00:20:34,720
client number of

00:20:32,240 --> 00:20:37,360
email accepted by cntp server for

00:20:34,720 --> 00:20:41,120
delivery and number of mail rejected

00:20:37,360 --> 00:20:43,440
we can also have coarse grained

00:20:41,120 --> 00:20:44,559
metrics about commands in general

00:20:43,440 --> 00:20:47,760
without going into

00:20:44,559 --> 00:20:50,880
details which exactly commands

00:20:47,760 --> 00:20:54,559
so this is another use case

00:20:50,880 --> 00:20:57,360
just to to demo like any other

00:20:54,559 --> 00:20:58,559
extension our sncp extension supports

00:20:57,360 --> 00:21:00,880
configuration

00:20:58,559 --> 00:21:02,159
and one of the options is how many

00:21:00,880 --> 00:21:04,960
metrics to expose

00:21:02,159 --> 00:21:07,120
so let's reconfigure and let's restart

00:21:04,960 --> 00:21:10,640
some way

00:21:07,120 --> 00:21:11,200
so we activated so we want to see more

00:21:10,640 --> 00:21:13,360
matrix

00:21:11,200 --> 00:21:14,400
in particular matrix for every single

00:21:13,360 --> 00:21:19,120
command

00:21:14,400 --> 00:21:19,120
we saw in this flow

00:21:20,559 --> 00:21:31,840
so for every single command like mail

00:21:22,799 --> 00:21:31,840
recipient data

00:21:32,640 --> 00:21:38,880
so yeah now you can see that we have

00:21:35,200 --> 00:21:38,880
this matrix for every single command

00:21:40,960 --> 00:21:44,400
so this was completely successful flow

00:21:43,200 --> 00:21:47,520
where all

00:21:44,400 --> 00:21:50,400
commands were successful let's

00:21:47,520 --> 00:21:51,360
do something different let's change

00:21:50,400 --> 00:21:54,400
configuration of

00:21:51,360 --> 00:21:57,760
sncp client to so that

00:21:54,400 --> 00:22:00,880
scientific transactions will

00:21:57,760 --> 00:22:00,880
end up with errors

00:22:01,120 --> 00:22:05,679
and see if and why we'll be able to

00:22:02,960 --> 00:22:05,679
catch this

00:22:09,840 --> 00:22:13,440
yeah you can see that this counter can't

00:22:11,600 --> 00:22:18,000
just start increasing

00:22:13,440 --> 00:22:22,000
its number of failed commands

00:22:18,000 --> 00:22:25,600
if we now go back to wireshark and

00:22:22,000 --> 00:22:30,080
capture traffic one more time we can see

00:22:25,600 --> 00:22:30,080
that the overall flow has changed

00:22:30,640 --> 00:22:34,559
so right now yeah just email

00:22:32,720 --> 00:22:37,679
transactions starts

00:22:34,559 --> 00:22:39,520
failing at a step where the cmtp client

00:22:37,679 --> 00:22:44,159
is trying to fill in

00:22:39,520 --> 00:22:44,159
two fields with invaded value

00:22:44,480 --> 00:22:48,400
finally let's take a look into the

00:22:45,760 --> 00:22:48,400
source code of

00:22:48,480 --> 00:22:54,960
invoice on cp filter itself as you can

00:22:51,600 --> 00:22:58,640
see it's indeed developed in rust

00:22:54,960 --> 00:23:01,600
and it has a structure hell

00:22:58,640 --> 00:23:02,480
well resembling structure of native

00:23:01,600 --> 00:23:07,039
extensions

00:23:02,480 --> 00:23:07,039
we have configuration we have stats

00:23:07,440 --> 00:23:10,480
we have filter itself and we have it

00:23:09,360 --> 00:23:13,280
it's factory

00:23:10,480 --> 00:23:14,000
and a filter it's a network filter and

00:23:13,280 --> 00:23:17,840
we

00:23:14,000 --> 00:23:20,799
uh override callbacks for to handle

00:23:17,840 --> 00:23:23,120
uh new connection downstream data data

00:23:20,799 --> 00:23:23,760
from ctp client and upstream data data

00:23:23,120 --> 00:23:28,480
from

00:23:23,760 --> 00:23:28,480
sncp server since

00:23:29,600 --> 00:23:33,360
sntp is simple text based protocol so we

00:23:32,559 --> 00:23:35,200
chose to

00:23:33,360 --> 00:23:37,360
implement protocol parsing completely

00:23:35,200 --> 00:23:41,360
ourselves

00:23:37,360 --> 00:23:44,559
but in case of ldap we would use

00:23:41,360 --> 00:23:47,520
uh surpass your library for parsing ldap

00:23:44,559 --> 00:23:47,520
which is binary protocol

00:23:48,000 --> 00:23:54,320
so that's concludes our overview of

00:23:51,840 --> 00:23:56,640
uh invoice ntp extension and now it's

00:23:54,320 --> 00:24:01,360
time to take action to update you

00:23:56,640 --> 00:24:01,360
on sdk for go link

00:24:02,480 --> 00:24:07,760
in this part i'm going to talk about go

00:24:04,720 --> 00:24:10,080
sdk for proximism and its current status

00:24:07,760 --> 00:24:13,120
and challenges in the future commands my

00:24:10,080 --> 00:24:17,200
name is takishi from tetrad

00:24:13,120 --> 00:24:20,400
so let's begin with why go for proximism

00:24:17,200 --> 00:24:22,720
go is the um one of the most widely used

00:24:20,400 --> 00:24:23,679
languages in the cloud native world

00:24:22,720 --> 00:24:25,760
right and

00:24:23,679 --> 00:24:27,360
uh being able to use existing gold

00:24:25,760 --> 00:24:30,080
libraries or packages

00:24:27,360 --> 00:24:32,720
is a very good developer experience for

00:24:30,080 --> 00:24:34,880
western extensions and also

00:24:32,720 --> 00:24:37,200
the number of developers writing onboard

00:24:34,880 --> 00:24:40,880
extension will increase dramatically

00:24:37,200 --> 00:24:43,039
which is really great for both for

00:24:40,880 --> 00:24:44,159
convoy community and the gold compiler

00:24:43,039 --> 00:24:46,640
community from

00:24:44,159 --> 00:24:48,400
western perspective that's why i started

00:24:46,640 --> 00:24:51,520
working on this project

00:24:48,400 --> 00:24:54,159
and so let's um talk about

00:24:51,520 --> 00:24:55,919
compilers there are two compilers out

00:24:54,159 --> 00:24:59,200
there which comply with

00:24:55,919 --> 00:25:00,960
go language specification and speaking

00:24:59,200 --> 00:25:03,440
about proximism

00:25:00,960 --> 00:25:05,279
it's not the official compilers cannot

00:25:03,440 --> 00:25:08,000
be used for producing

00:25:05,279 --> 00:25:08,960
proxy wasn't compatible wineries yet

00:25:08,000 --> 00:25:11,360
because um

00:25:08,960 --> 00:25:13,679
we cannot control export sections and

00:25:11,360 --> 00:25:15,760
also it assumes that the

00:25:13,679 --> 00:25:17,200
running hosting environment is kind of

00:25:15,760 --> 00:25:20,240
ghost specific

00:25:17,200 --> 00:25:23,440
javascript environment so that's why

00:25:20,240 --> 00:25:27,120
we choose tinyo as a compiler for

00:25:23,440 --> 00:25:28,159
our sdk and the tango supports wazi

00:25:27,120 --> 00:25:30,320
target and

00:25:28,159 --> 00:25:31,200
with this is my major contribution to

00:25:30,320 --> 00:25:33,279
taingo

00:25:31,200 --> 00:25:34,400
and also tanning will allow us to

00:25:33,279 --> 00:25:37,760
control import

00:25:34,400 --> 00:25:39,200
and export section so and also speaking

00:25:37,760 --> 00:25:42,080
about binary size

00:25:39,200 --> 00:25:43,360
hello world binary binary the official

00:25:42,080 --> 00:25:45,919
compiler's binary

00:25:43,360 --> 00:25:47,440
is much larger than turning as you see

00:25:45,919 --> 00:25:51,360
so this is why i think

00:25:47,440 --> 00:25:54,960
tiny o is the way to go speaking about

00:25:51,360 --> 00:25:58,159
proximation so

00:25:54,960 --> 00:26:01,200
go sdk there is some

00:25:58,159 --> 00:26:01,760
repository named proxy wasn't go sdk in

00:26:01,200 --> 00:26:04,480
patriot

00:26:01,760 --> 00:26:05,760
labs it started as my personal project

00:26:04,480 --> 00:26:08,320
and then moved to

00:26:05,760 --> 00:26:09,360
the detroit labs and it depends on

00:26:08,320 --> 00:26:12,880
tanego

00:26:09,360 --> 00:26:15,120
and also all the examples in c

00:26:12,880 --> 00:26:16,480
plus plus and the rust can be

00:26:15,120 --> 00:26:19,600
re-implemented so

00:26:16,480 --> 00:26:22,559
it's usable and so please give it a try

00:26:19,600 --> 00:26:24,640
and also it supports envoy host

00:26:22,559 --> 00:26:26,559
emulation for unit testing

00:26:24,640 --> 00:26:28,400
so which means you can use go test

00:26:26,559 --> 00:26:30,559
command for

00:26:28,400 --> 00:26:31,760
testing your filters or extensions

00:26:30,559 --> 00:26:34,159
without running

00:26:31,760 --> 00:26:35,760
onboard processes this is really great

00:26:34,159 --> 00:26:38,559
for developers because

00:26:35,760 --> 00:26:38,960
we can develop on our extension just

00:26:38,559 --> 00:26:43,200
like

00:26:38,960 --> 00:26:47,840
you do with the native applications

00:26:43,200 --> 00:26:50,000
so what are the challenges we are facing

00:26:47,840 --> 00:26:52,000
and the first is that our some of the

00:26:50,000 --> 00:26:55,600
existing libraries are not supported

00:26:52,000 --> 00:26:58,880
yet there is um several reasons but

00:26:55,600 --> 00:27:00,720
the um some of the system codes are not

00:26:58,880 --> 00:27:04,000
not available in tangio

00:27:00,720 --> 00:27:06,480
or proxy wasn't uh

00:27:04,000 --> 00:27:07,919
c plus plus host and for example you

00:27:06,480 --> 00:27:11,200
cannot use script run

00:27:07,919 --> 00:27:14,640
package or you cannot use os.getm

00:27:11,200 --> 00:27:17,200
and also time.now these are the

00:27:14,640 --> 00:27:19,120
they're not available currently but they

00:27:17,200 --> 00:27:22,159
will be supported

00:27:19,120 --> 00:27:25,200
and also reflection packages is not free

00:27:22,159 --> 00:27:28,080
it's not fully supported by tango so

00:27:25,200 --> 00:27:29,520
you cannot use json package but this is

00:27:28,080 --> 00:27:32,720
highly demanded so

00:27:29,520 --> 00:27:35,600
i'm going to work on this and also

00:27:32,720 --> 00:27:37,840
garbage collection is re-implemented in

00:27:35,600 --> 00:27:40,559
tanio which is totally different from

00:27:37,840 --> 00:27:43,440
the official garbage collection and it

00:27:40,559 --> 00:27:46,720
uses simple conservative merchant sweep

00:27:43,440 --> 00:27:48,480
and it needs to i think

00:27:46,720 --> 00:27:49,760
it's necessary for us to assess

00:27:48,480 --> 00:27:53,919
performance impacts

00:27:49,760 --> 00:27:56,640
on fluxivism maybe we gotta

00:27:53,919 --> 00:27:58,000
develop our own gc algorithm tailored

00:27:56,640 --> 00:28:01,039
for proxy version

00:27:58,000 --> 00:28:04,399
and also goroutine is almost

00:28:01,039 --> 00:28:05,520
unavailable taningo uses um another vm

00:28:04,399 --> 00:28:08,320
called routine but

00:28:05,520 --> 00:28:09,360
no schedulers runs by default in the

00:28:08,320 --> 00:28:12,640
event driven

00:28:09,360 --> 00:28:14,880
and the thread local vms in envoy so you

00:28:12,640 --> 00:28:17,360
could use um go keyword but

00:28:14,880 --> 00:28:18,480
no one can predict when this go routine

00:28:17,360 --> 00:28:21,840
will be

00:28:18,480 --> 00:28:25,360
run or things like that so

00:28:21,840 --> 00:28:26,960
what's next contributing back to tanigo

00:28:25,360 --> 00:28:28,399
and the reflection package

00:28:26,960 --> 00:28:31,600
implementation or

00:28:28,399 --> 00:28:34,960
other system core support in order to

00:28:31,600 --> 00:28:38,240
um in order to be able to uh use

00:28:34,960 --> 00:28:40,240
existing goal libraries and also

00:28:38,240 --> 00:28:42,720
we need to do some gc performance

00:28:40,240 --> 00:28:45,919
analysis have been working on this

00:28:42,720 --> 00:28:47,279
and also may we as i said we may be we

00:28:45,919 --> 00:28:50,320
have to

00:28:47,279 --> 00:28:52,320
uh have custom gc for proxy western

00:28:50,320 --> 00:28:55,200
and also google routine support in order

00:28:52,320 --> 00:28:57,360
to do that we must answer questions like

00:28:55,200 --> 00:28:59,919
how to deal with go routine and the

00:28:57,360 --> 00:29:01,760
thread local wasn't vm executed in the

00:28:59,919 --> 00:29:05,200
event driven manner

00:29:01,760 --> 00:29:08,480
so that's all that's all and

00:29:05,200 --> 00:29:10,960
let's wrap up so start with me today

00:29:08,480 --> 00:29:13,200
let's start developing resume extensions

00:29:10,960 --> 00:29:14,880
there are four languages out there

00:29:13,200 --> 00:29:16,880
and also you can contribute to the

00:29:14,880 --> 00:29:19,919
community by developing

00:29:16,880 --> 00:29:22,960
sdk for your own favorite languages

00:29:19,919 --> 00:29:23,919
and also there is get amber project that

00:29:22,960 --> 00:29:26,640
you can use

00:29:23,919 --> 00:29:27,679
that you can easily get started with

00:29:26,640 --> 00:29:31,039
wasm extension

00:29:27,679 --> 00:29:34,880
we accumulated lessons learned so

00:29:31,039 --> 00:29:36,880
please give it a shot and also

00:29:34,880 --> 00:29:38,559
join our community and give us your

00:29:36,880 --> 00:29:41,600
feedbacks

00:29:38,559 --> 00:29:42,480
thank you for coming today let's get on

00:29:41,600 --> 00:29:46,080
to

00:29:42,480 --> 00:29:46,080

YouTube URL: https://www.youtube.com/watch?v=bqIaAp4EIkg


