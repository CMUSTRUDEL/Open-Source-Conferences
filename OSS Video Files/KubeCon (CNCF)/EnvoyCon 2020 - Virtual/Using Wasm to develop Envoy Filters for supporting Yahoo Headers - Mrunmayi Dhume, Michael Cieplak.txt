Title: Using Wasm to develop Envoy Filters for supporting Yahoo Headers - Mrunmayi Dhume, Michael Cieplak
Publication date: 2020-10-21
Playlist: EnvoyCon 2020 - Virtual
Description: 
	Using Web Assembly to develop Envoy Filters for supporting Yahoo Headers - Mrunmayi Dhume, Michael Cieplak

Today at Verizon Media (formerly Yahoo), the on-prem Kubernetes platform spans 35 clusters across multiple data centers serving ~2500 apps. There are 2 ingress layers - Apache Traffic Server (ATS) serving 2M peak RPS and Istio Ingress based Envoy Proxy with a peak of 220K RPS. One of the key plugins of ATS is the verification/generation of Yahoo Headers, used by apps to obtain downstream client information such as the remote address/port, and a signature generated using a combination of base64, MD5, and a private key to ensure header integrity. To migrate all ATS traffic to Envoy, it is necessary to port all plugins from ATS with minimal changes. To achieve this, an Envoy Web Assembly (Wasm) filter was implemented using the Proxy Wasm standard, which is able to process these headers. This talk will provide an overview of the filter implementation and the learnings achieved along the way.
Captions: 
	00:00:00,719 --> 00:00:04,960
hello everyone thank you for joining our

00:00:02,960 --> 00:00:07,440
talk on envoy vasum filters

00:00:04,960 --> 00:00:09,200
for supporting yahoo headers my name is

00:00:07,440 --> 00:00:11,440
mirinmei dhume and i'm a principal

00:00:09,200 --> 00:00:14,080
software engineer at verizon media

00:00:11,440 --> 00:00:14,880
in the core infrastructure team hi

00:00:14,080 --> 00:00:17,119
everyone

00:00:14,880 --> 00:00:19,600
my name is michael cheflak and i'm a

00:00:17,119 --> 00:00:21,840
software engineer here at verizon media

00:00:19,600 --> 00:00:24,560
as well

00:00:21,840 --> 00:00:26,800
so today at verizon media formerly yahoo

00:00:24,560 --> 00:00:29,279
we have over 30 kubernetes clusters

00:00:26,800 --> 00:00:32,320
across multiple regions each of these

00:00:29,279 --> 00:00:34,640
has an istio service mesh deployed on it

00:00:32,320 --> 00:00:36,800
we have two parallel ingress layers

00:00:34,640 --> 00:00:39,280
fronting our kubernetes clusters

00:00:36,800 --> 00:00:40,399
one is powered by apache traffic server

00:00:39,280 --> 00:00:42,960
serving two million

00:00:40,399 --> 00:00:45,680
peak requests per second and the other

00:00:42,960 --> 00:00:46,800
by envoy which serves 230k requests per

00:00:45,680 --> 00:00:49,360
second

00:00:46,800 --> 00:00:51,360
by the beginning of 2021 our goal is to

00:00:49,360 --> 00:00:53,360
migrate all the traffic from our ats

00:00:51,360 --> 00:00:55,680
layer to envoy

00:00:53,360 --> 00:00:58,160
today our istio service mesh is running

00:00:55,680 --> 00:01:00,399
at a scale of 6700

00:00:58,160 --> 00:01:02,800
application pods all bundled with the

00:01:00,399 --> 00:01:04,720
envoy sidecar proxy

00:01:02,800 --> 00:01:07,119
some of the key features of envoy that

00:01:04,720 --> 00:01:09,200
we are utilizing today are as follows

00:01:07,119 --> 00:01:12,080
we make use of its multiple protocol

00:01:09,200 --> 00:01:15,200
support such as for http https

00:01:12,080 --> 00:01:16,400
grpc tcp including the sni pass through

00:01:15,200 --> 00:01:18,799
mode

00:01:16,400 --> 00:01:20,960
we allow our users to take advantage of

00:01:18,799 --> 00:01:22,799
the http request manipulation options

00:01:20,960 --> 00:01:24,960
that it provides

00:01:22,799 --> 00:01:27,439
in terms of security a majority of our

00:01:24,960 --> 00:01:29,360
applications delegate the mutual tls

00:01:27,439 --> 00:01:31,439
authentication and authorization to the

00:01:29,360 --> 00:01:33,520
envoy sidecar proxy

00:01:31,439 --> 00:01:35,200
and in terms of observability we make

00:01:33,520 --> 00:01:36,720
use of the tracing attributes

00:01:35,200 --> 00:01:40,000
and the prometheus metrics that are

00:01:36,720 --> 00:01:41,360
generated by envoy

00:01:40,000 --> 00:01:42,880
so now i'd like to talk a little bit

00:01:41,360 --> 00:01:44,640
about the request flow that we see

00:01:42,880 --> 00:01:46,880
through envoy proxy

00:01:44,640 --> 00:01:48,720
so as you can see in this diagram if a

00:01:46,880 --> 00:01:50,000
request originates from outside of the

00:01:48,720 --> 00:01:51,920
kubernetes cluster

00:01:50,000 --> 00:01:53,119
it must pass through our envoy ingress

00:01:51,920 --> 00:01:55,119
layer

00:01:53,119 --> 00:01:57,040
and the envoy layer is then responsible

00:01:55,119 --> 00:02:00,079
for sending the request to the target

00:01:57,040 --> 00:02:02,640
board of the appropriate application

00:02:00,079 --> 00:02:03,280
in addition if you have two services say

00:02:02,640 --> 00:02:04,719
a and b

00:02:03,280 --> 00:02:06,560
which need to communicate with each

00:02:04,719 --> 00:02:08,000
other and both of them are residing on

00:02:06,560 --> 00:02:09,599
our kubernetes cluster

00:02:08,000 --> 00:02:12,080
they are able to communicate directly

00:02:09,599 --> 00:02:13,599
with one another using the envoy sidecar

00:02:12,080 --> 00:02:15,440
so that the request will directly go

00:02:13,599 --> 00:02:16,319
from a board of service a to a port of

00:02:15,440 --> 00:02:17,840
service b

00:02:16,319 --> 00:02:20,560
and not have to go through our ingress

00:02:17,840 --> 00:02:21,440
layer another point that i would like to

00:02:20,560 --> 00:02:23,040
mention here

00:02:21,440 --> 00:02:24,560
is that the configuration that is

00:02:23,040 --> 00:02:27,440
provided to all of these

00:02:24,560 --> 00:02:28,239
envoy proxies is provided by our istio

00:02:27,440 --> 00:02:32,319
service mesh

00:02:28,239 --> 00:02:32,319
control plane component called stod

00:02:33,120 --> 00:02:36,239
so like i mentioned previously envoy is

00:02:35,200 --> 00:02:39,440
a rich featured

00:02:36,239 --> 00:02:41,040
powerful l3 l4 and l7 proxy and we

00:02:39,440 --> 00:02:42,640
utilize a number of the features that

00:02:41,040 --> 00:02:44,319
are available today

00:02:42,640 --> 00:02:46,160
however there are some custom features

00:02:44,319 --> 00:02:47,519
that we would like to add and extend

00:02:46,160 --> 00:02:49,519
envoy

00:02:47,519 --> 00:02:50,959
envoy provides a number of extension

00:02:49,519 --> 00:02:53,599
points such as through

00:02:50,959 --> 00:02:56,160
custom http filters network filters

00:02:53,599 --> 00:02:58,239
access loggers among others

00:02:56,160 --> 00:03:00,400
in order to implement these extensions

00:02:58,239 --> 00:03:02,959
there are a couple of options

00:03:00,400 --> 00:03:03,840
one option is to write a c plus native

00:03:02,959 --> 00:03:05,840
filter

00:03:03,840 --> 00:03:07,280
using the extensive api that envoy

00:03:05,840 --> 00:03:08,800
exposes

00:03:07,280 --> 00:03:10,560
in order to do this a developer would

00:03:08,800 --> 00:03:12,560
take the envoy source code

00:03:10,560 --> 00:03:14,159
add their own custom filter to it and

00:03:12,560 --> 00:03:16,319
then compile it together to form a

00:03:14,159 --> 00:03:18,159
custom envoy binary

00:03:16,319 --> 00:03:19,920
of course if this use case is generic

00:03:18,159 --> 00:03:21,920
enough they do have the option

00:03:19,920 --> 00:03:24,000
of merging it with the upstream envoy

00:03:21,920 --> 00:03:25,760
main source code

00:03:24,000 --> 00:03:27,760
the second option that we have is to

00:03:25,760 --> 00:03:29,920
write a lua based filter

00:03:27,760 --> 00:03:31,680
onward provides a lua api so that

00:03:29,920 --> 00:03:32,080
developers can write their custom lua

00:03:31,680 --> 00:03:35,280
script

00:03:32,080 --> 00:03:37,680
using it this api is intentionally

00:03:35,280 --> 00:03:39,280
small so that the lua scripts are simple

00:03:37,680 --> 00:03:41,519
and safe to use

00:03:39,280 --> 00:03:43,040
for more complex use cases developers

00:03:41,519 --> 00:03:44,640
are encouraged to use one of the other

00:03:43,040 --> 00:03:47,280
approaches

00:03:44,640 --> 00:03:49,360
the newest option available to extend

00:03:47,280 --> 00:03:50,480
envoy is to write a webassembly based

00:03:49,360 --> 00:03:52,319
filter

00:03:50,480 --> 00:03:55,120
i will talk more about this one in the

00:03:52,319 --> 00:03:57,680
upcoming slides

00:03:55,120 --> 00:03:59,760
so what is web assembly the official

00:03:57,680 --> 00:04:02,640
definition states that it is a safe

00:03:59,760 --> 00:04:04,640
portable low level code format designed

00:04:02,640 --> 00:04:06,400
for efficient execution and compact

00:04:04,640 --> 00:04:08,480
representation

00:04:06,400 --> 00:04:10,560
we chose webassembly as the mode of

00:04:08,480 --> 00:04:11,599
extension for envoy for a couple of

00:04:10,560 --> 00:04:14,080
reasons

00:04:11,599 --> 00:04:15,519
firstly it the binary that gets created

00:04:14,080 --> 00:04:18,000
has a small size

00:04:15,519 --> 00:04:19,040
and also this vason modules are loaded

00:04:18,000 --> 00:04:22,240
very fast which

00:04:19,040 --> 00:04:24,000
reduces the time required for startup

00:04:22,240 --> 00:04:26,080
vassam also has support for multiple

00:04:24,000 --> 00:04:27,440
languages so if you have any dependency

00:04:26,080 --> 00:04:29,120
on existing libraries

00:04:27,440 --> 00:04:30,639
you can continue to write your vassam

00:04:29,120 --> 00:04:32,160
filter in the same language

00:04:30,639 --> 00:04:34,720
and then together you can compile them

00:04:32,160 --> 00:04:36,880
to form a vassal module

00:04:34,720 --> 00:04:38,720
these passive modules run in a memory

00:04:36,880 --> 00:04:40,160
safe and sandboxed environment

00:04:38,720 --> 00:04:42,080
where the host environment is

00:04:40,160 --> 00:04:43,360
responsible for the memory allocation

00:04:42,080 --> 00:04:45,040
for the vessel module

00:04:43,360 --> 00:04:47,680
and also to define what are the

00:04:45,040 --> 00:04:50,080
functions that are available to it

00:04:47,680 --> 00:04:51,360
this binary format can be pretty printed

00:04:50,080 --> 00:04:53,199
in a textual format

00:04:51,360 --> 00:04:54,880
so that it is easy to debug and to

00:04:53,199 --> 00:04:57,280
optimize

00:04:54,880 --> 00:04:59,040
another advantage that we saw is that

00:04:57,280 --> 00:05:00,720
the vasom filter that we write

00:04:59,040 --> 00:05:02,320
does not have to be recompiled with the

00:05:00,720 --> 00:05:06,080
envoy source code

00:05:02,320 --> 00:05:08,320
so we can continue to consume the envoy

00:05:06,080 --> 00:05:10,240
open source versions and binaries and we

00:05:08,320 --> 00:05:11,759
can keep in sync with any new releases

00:05:10,240 --> 00:05:13,360
or new security fixes

00:05:11,759 --> 00:05:15,280
and once we have fetched the latest

00:05:13,360 --> 00:05:18,479
versions we can deploy our vassam

00:05:15,280 --> 00:05:18,479
filters on top of it

00:05:18,880 --> 00:05:22,080
so now that i've spoken a little bit

00:05:20,400 --> 00:05:23,919
about web assembly in general

00:05:22,080 --> 00:05:25,520
i would like to talk more about how

00:05:23,919 --> 00:05:26,800
envoy in particular implements

00:05:25,520 --> 00:05:31,840
webassembly

00:05:26,800 --> 00:05:33,520
so envoy embeds today a v8 vassam vm

00:05:31,840 --> 00:05:34,880
so if you take a look at this diagram

00:05:33,520 --> 00:05:35,919
you can see that when the request

00:05:34,880 --> 00:05:37,680
streams come in

00:05:35,919 --> 00:05:39,199
they are serviced by one of the envoy

00:05:37,680 --> 00:05:41,120
worker threads

00:05:39,199 --> 00:05:43,360
each of these worker threads embeds a

00:05:41,120 --> 00:05:45,520
thread local vasom vm

00:05:43,360 --> 00:05:47,360
so if you write a vasim filter that is

00:05:45,520 --> 00:05:48,720
required to perform some per request

00:05:47,360 --> 00:05:50,560
based manipulation

00:05:48,720 --> 00:05:53,199
that filter will be executed in one of

00:05:50,560 --> 00:05:55,520
these thread local vasim vms

00:05:53,199 --> 00:05:56,960
in addition you may also have a use case

00:05:55,520 --> 00:05:58,720
where you want to perform certain

00:05:56,960 --> 00:06:00,800
non-request specific

00:05:58,720 --> 00:06:02,720
functionality for example you may want

00:06:00,800 --> 00:06:03,759
to aggregate the metrics across multiple

00:06:02,720 --> 00:06:05,520
requests

00:06:03,759 --> 00:06:07,039
for such use cases you can write a

00:06:05,520 --> 00:06:09,039
singleton filter

00:06:07,039 --> 00:06:10,400
this filter then gets executed in the

00:06:09,039 --> 00:06:12,319
base wasm vm

00:06:10,400 --> 00:06:14,720
which is embedded as a part of the main

00:06:12,319 --> 00:06:16,560
envoy thread

00:06:14,720 --> 00:06:18,960
in general there is a number of api that

00:06:16,560 --> 00:06:21,280
are available for the vason module

00:06:18,960 --> 00:06:22,160
they can you make use of the stats and

00:06:21,280 --> 00:06:24,240
logs api

00:06:22,160 --> 00:06:25,680
in case they want to take the metrics

00:06:24,240 --> 00:06:27,280
and logs that are generated by the

00:06:25,680 --> 00:06:29,120
worker threads and then expose them to

00:06:27,280 --> 00:06:31,360
an external sync

00:06:29,120 --> 00:06:34,479
vaso modules can make use of http or

00:06:31,360 --> 00:06:38,000
grpc api in order to make external http

00:06:34,479 --> 00:06:39,680
or grpc calls the timer api can be used

00:06:38,000 --> 00:06:40,560
in case there is some functionality that

00:06:39,680 --> 00:06:43,280
needs to be

00:06:40,560 --> 00:06:45,280
performed at regular intervals there is

00:06:43,280 --> 00:06:46,639
also provision for a shared data which

00:06:45,280 --> 00:06:49,759
is basically a key value

00:06:46,639 --> 00:06:51,680
a pair store and a message queue so for

00:06:49,759 --> 00:06:52,720
any kind of operations that require the

00:06:51,680 --> 00:06:54,800
worker threads to

00:06:52,720 --> 00:06:56,000
store certain data which can then later

00:06:54,800 --> 00:06:58,560
on maybe be consumed

00:06:56,000 --> 00:07:02,000
consumed by your singleton filter these

00:06:58,560 --> 00:07:03,599
two are useful

00:07:02,000 --> 00:07:06,000
the api that i described in the

00:07:03,599 --> 00:07:06,880
preceding slide is defined by a proxy

00:07:06,000 --> 00:07:10,080
agnostic

00:07:06,880 --> 00:07:13,199
abi standard which is called proxy vasim

00:07:10,080 --> 00:07:15,199
so by proxy agnostic i mean that if once

00:07:13,199 --> 00:07:16,880
you write a vasiv module it can be

00:07:15,199 --> 00:07:17,759
executed in a number of different

00:07:16,880 --> 00:07:21,199
proxies such as

00:07:17,759 --> 00:07:23,520
envoy apache traffic server h.a proxy

00:07:21,199 --> 00:07:25,599
as long as these proxies implement the

00:07:23,520 --> 00:07:28,080
proxy vessel standard

00:07:25,599 --> 00:07:29,759
so proxy vasim defines a number of event

00:07:28,080 --> 00:07:31,680
driven streaming apis

00:07:29,759 --> 00:07:33,280
which govern the interaction between

00:07:31,680 --> 00:07:35,039
envoy and the vassar module that is

00:07:33,280 --> 00:07:36,800
being executed

00:07:35,039 --> 00:07:38,560
these interactions are in the form of

00:07:36,800 --> 00:07:40,560
functions and callbacks that are wrapped

00:07:38,560 --> 00:07:42,319
by a context object

00:07:40,560 --> 00:07:44,400
so as a developer if you want to write a

00:07:42,319 --> 00:07:47,759
vasim filter there are two context

00:07:44,400 --> 00:07:50,319
objects that you need to keep in mind

00:07:47,759 --> 00:07:52,319
the first one is the root context so the

00:07:50,319 --> 00:07:54,240
root context is created at bootstrap and

00:07:52,319 --> 00:07:56,080
has a lifetime which is equal to the vm

00:07:54,240 --> 00:07:57,599
in which it gets created

00:07:56,080 --> 00:07:59,280
there are a number of methods that you

00:07:57,599 --> 00:08:01,280
can override in the root context like

00:07:59,280 --> 00:08:03,039
onstart or onconfigure

00:08:01,280 --> 00:08:04,960
and it can be used to perform certain

00:08:03,039 --> 00:08:08,319
initial setup operations that may be

00:08:04,960 --> 00:08:10,319
required for your vassam filters

00:08:08,319 --> 00:08:12,080
additionally as the requests come in

00:08:10,319 --> 00:08:13,599
there is a new stream context that gets

00:08:12,080 --> 00:08:15,440
created for every request

00:08:13,599 --> 00:08:18,000
and similarly a new stream context

00:08:15,440 --> 00:08:19,840
object so this stream context object has

00:08:18,000 --> 00:08:20,479
a lifetime which is equal to the request

00:08:19,840 --> 00:08:22,960
stream

00:08:20,479 --> 00:08:24,160
in which it gets created again there are

00:08:22,960 --> 00:08:25,520
a number of methods that can be

00:08:24,160 --> 00:08:27,599
overridden here

00:08:25,520 --> 00:08:28,879
so for example if your wasm filter needs

00:08:27,599 --> 00:08:29,840
to make certain request header

00:08:28,879 --> 00:08:31,440
manipulation

00:08:29,840 --> 00:08:32,880
it would overwrite the on request

00:08:31,440 --> 00:08:34,640
headers function

00:08:32,880 --> 00:08:36,560
in case it wants to append certain data

00:08:34,640 --> 00:08:39,839
to the response body it would overwrite

00:08:36,560 --> 00:08:41,440
the on response body function

00:08:39,839 --> 00:08:43,200
as new requests come in there will be a

00:08:41,440 --> 00:08:44,880
new stream context created for each one

00:08:43,200 --> 00:08:46,000
of them and the stream context object

00:08:44,880 --> 00:08:49,120
also will be created

00:08:46,000 --> 00:08:49,920
independently so this describes a little

00:08:49,120 --> 00:08:52,160
bit about

00:08:49,920 --> 00:08:54,399
webassembly in general and also some

00:08:52,160 --> 00:08:56,160
specifics about how envoy has gone about

00:08:54,399 --> 00:08:58,240
implementing bassem

00:08:56,160 --> 00:09:02,000
we will now take a closer look at our

00:08:58,240 --> 00:09:04,959
specific use case of yahoo headers

00:09:02,000 --> 00:09:06,800
so what are yahoo headers so yahoo

00:09:04,959 --> 00:09:09,279
headers can be defined as a set of

00:09:06,800 --> 00:09:10,720
custom headers that are used to securely

00:09:09,279 --> 00:09:12,800
identify a request

00:09:10,720 --> 00:09:14,959
its remote source and the path that the

00:09:12,800 --> 00:09:16,640
request takes through the network

00:09:14,959 --> 00:09:19,440
so there are a couple of headers that we

00:09:16,640 --> 00:09:22,399
were considering the first one was rid

00:09:19,440 --> 00:09:24,080
or request identifier this is generated

00:09:22,399 --> 00:09:26,240
based on the unix timestamp and a

00:09:24,080 --> 00:09:28,480
randomly generated number

00:09:26,240 --> 00:09:30,640
this is similar to the x request id that

00:09:28,480 --> 00:09:32,800
is provided by envoy

00:09:30,640 --> 00:09:34,560
the primary purpose for this is to use

00:09:32,800 --> 00:09:35,120
is that it aids in debugging if you want

00:09:34,560 --> 00:09:36,560
to trace

00:09:35,120 --> 00:09:39,279
how the request has flown through your

00:09:36,560 --> 00:09:42,640
network an example for rid

00:09:39,279 --> 00:09:44,160
is shown here on the slide the next set

00:09:42,640 --> 00:09:44,480
of headers that we were concerned with

00:09:44,160 --> 00:09:47,519
were

00:09:44,480 --> 00:09:48,160
ra rp and rs which stand for remote

00:09:47,519 --> 00:09:49,920
address

00:09:48,160 --> 00:09:51,279
remote port and remote signature

00:09:49,920 --> 00:09:54,240
respectively

00:09:51,279 --> 00:09:54,640
so ra and rp are used to are used for

00:09:54,240 --> 00:09:56,640
the

00:09:54,640 --> 00:09:58,959
address and port of where this request

00:09:56,640 --> 00:10:02,160
actually originated from

00:09:58,959 --> 00:10:05,120
rs in turn is com is generated by

00:10:02,160 --> 00:10:05,680
making an md5 signature of the ra and rp

00:10:05,120 --> 00:10:08,160
values

00:10:05,680 --> 00:10:09,440
with a secret and then base64 encoding

00:10:08,160 --> 00:10:11,680
it

00:10:09,440 --> 00:10:13,920
the primary purpose for rs is to make

00:10:11,680 --> 00:10:15,839
sure that the array and rp values

00:10:13,920 --> 00:10:17,839
do not get tampered with as this request

00:10:15,839 --> 00:10:20,240
moves through the network

00:10:17,839 --> 00:10:22,320
sample ra rp and rs headers are shown

00:10:20,240 --> 00:10:24,000
here on the screen

00:10:22,320 --> 00:10:26,240
so in phase one of our filter

00:10:24,000 --> 00:10:27,360
development we focused on these set of

00:10:26,240 --> 00:10:29,120
headers

00:10:27,360 --> 00:10:31,279
in phase two we have a couple of other

00:10:29,120 --> 00:10:34,160
headers that we wish to implement

00:10:31,279 --> 00:10:36,000
the first one is the path header so the

00:10:34,160 --> 00:10:37,519
path header is used to track a request

00:10:36,000 --> 00:10:38,160
as it goes through multiple hops in the

00:10:37,519 --> 00:10:40,560
network

00:10:38,160 --> 00:10:42,480
so it represents an ordered list of hops

00:10:40,560 --> 00:10:44,000
so this is similar to the x forwarded

00:10:42,480 --> 00:10:45,839
for header but it includes some

00:10:44,000 --> 00:10:47,519
additional attributes

00:10:45,839 --> 00:10:49,040
some of the per hop attributes that are

00:10:47,519 --> 00:10:51,920
added are the address

00:10:49,040 --> 00:10:52,560
and port of where the request was sent

00:10:51,920 --> 00:10:54,000
from

00:10:52,560 --> 00:10:56,640
the address and port of where the

00:10:54,000 --> 00:10:59,040
request landed and whether that hop was

00:10:56,640 --> 00:11:00,959
ssl enabled or not

00:10:59,040 --> 00:11:02,480
in addition we also add a signature

00:11:00,959 --> 00:11:04,240
which is similar to the rs signature

00:11:02,480 --> 00:11:06,160
that we defined previously

00:11:04,240 --> 00:11:08,560
again this is used to ensure the

00:11:06,160 --> 00:11:10,399
integrity of this header

00:11:08,560 --> 00:11:13,200
in the example shown here you can see

00:11:10,399 --> 00:11:15,839
that there were two hops that took place

00:11:13,200 --> 00:11:17,040
the information or the attributes for

00:11:15,839 --> 00:11:19,519
every hop are

00:11:17,040 --> 00:11:20,480
separated by semicolons and each hop

00:11:19,519 --> 00:11:23,120
itself is

00:11:20,480 --> 00:11:23,920
separated by a comma in the example

00:11:23,120 --> 00:11:26,480
shown here

00:11:23,920 --> 00:11:27,519
the first hop has ssl enabled as is

00:11:26,480 --> 00:11:29,839
indicated by the s

00:11:27,519 --> 00:11:32,160
equal to one flag while the second hop

00:11:29,839 --> 00:11:33,760
does not have it

00:11:32,160 --> 00:11:35,519
the next header that we are concerned

00:11:33,760 --> 00:11:37,920
with is the wire header

00:11:35,519 --> 00:11:39,120
so there is a default uh implementation

00:11:37,920 --> 00:11:42,000
that envoy provides

00:11:39,120 --> 00:11:43,920
however it relies on a static value in

00:11:42,000 --> 00:11:45,519
our use case we want to have a dynamic

00:11:43,920 --> 00:11:47,839
value for the via header

00:11:45,519 --> 00:11:49,839
where we can specify attributes such as

00:11:47,839 --> 00:11:51,600
the protocol the protocol version

00:11:49,839 --> 00:11:53,600
and the specific proxy through which

00:11:51,600 --> 00:11:55,040
this request was passed

00:11:53,600 --> 00:11:56,560
so if you take a look at the example

00:11:55,040 --> 00:11:58,320
over here you can see that there is the

00:11:56,560 --> 00:12:00,480
protocol and the protocol version

00:11:58,320 --> 00:12:01,920
that is the actual pod through ingress

00:12:00,480 --> 00:12:03,279
pod through which this particular

00:12:01,920 --> 00:12:05,279
request was sent

00:12:03,279 --> 00:12:07,120
and then that's followed by a uuid so

00:12:05,279 --> 00:12:08,880
this is a unique identifier of

00:12:07,120 --> 00:12:10,720
the specific proxy that it passed

00:12:08,880 --> 00:12:12,560
through and this is followed by the

00:12:10,720 --> 00:12:14,959
proxy and the proxy version

00:12:12,560 --> 00:12:17,680
since we use sto it says envoy sto and

00:12:14,959 --> 00:12:20,320
the istio version that we use

00:12:17,680 --> 00:12:21,519
the uuid can be used to detect multi-hop

00:12:20,320 --> 00:12:23,279
cycles

00:12:21,519 --> 00:12:24,639
apart from this wire can also be used

00:12:23,279 --> 00:12:26,880
for general tracing

00:12:24,639 --> 00:12:29,360
of the request and also to identify the

00:12:26,880 --> 00:12:32,240
request and response protocols

00:12:29,360 --> 00:12:32,880
so this summarizes what yahoo headers

00:12:32,240 --> 00:12:34,560
are

00:12:32,880 --> 00:12:36,720
and now i would like to pass it to my

00:12:34,560 --> 00:12:38,800
co-presenter michael who will talk more

00:12:36,720 --> 00:12:40,880
about our design goals challenges and

00:12:38,800 --> 00:12:44,720
the architecture that we came up with

00:12:40,880 --> 00:12:46,880
thank you okay thank you mr mai

00:12:44,720 --> 00:12:47,839
so now let's talk a little bit about

00:12:46,880 --> 00:12:49,920
some of the design

00:12:47,839 --> 00:12:52,000
rules and challenges that we face

00:12:49,920 --> 00:12:54,720
throughout our implementation

00:12:52,000 --> 00:12:56,959
so the primary goal that we had is we

00:12:54,720 --> 00:12:57,680
wanted to implement support for yahoo

00:12:56,959 --> 00:13:00,160
headers

00:12:57,680 --> 00:13:01,120
while reusing the existing core yahoo

00:13:00,160 --> 00:13:04,320
c-plus plus

00:13:01,120 --> 00:13:06,000
libraries so we actually have a yahoo

00:13:04,320 --> 00:13:08,959
connection plugin

00:13:06,000 --> 00:13:09,360
for apache traffic server which does

00:13:08,959 --> 00:13:13,120
have

00:13:09,360 --> 00:13:15,920
the rs essentially header validation

00:13:13,120 --> 00:13:16,240
and generation flows in place so the

00:13:15,920 --> 00:13:19,120
main

00:13:16,240 --> 00:13:20,240
idea here is we wanted to reuse that

00:13:19,120 --> 00:13:23,040
functionality

00:13:20,240 --> 00:13:24,880
so we did not need to re-implement it

00:13:23,040 --> 00:13:27,839
and also to stay up to date

00:13:24,880 --> 00:13:30,079
in case there are any changes there and

00:13:27,839 --> 00:13:33,600
also if there are any security fixes

00:13:30,079 --> 00:13:34,079
as well okay so now let's talk a little

00:13:33,600 --> 00:13:36,880
bit about

00:13:34,079 --> 00:13:37,200
some of the challenges that we ran into

00:13:36,880 --> 00:13:40,480
so

00:13:37,200 --> 00:13:43,120
the existing rid generation depends on

00:13:40,480 --> 00:13:44,320
read access to dev random to generate a

00:13:43,120 --> 00:13:46,959
unique seed

00:13:44,320 --> 00:13:47,519
to actually be able to generate uh

00:13:46,959 --> 00:13:50,639
unique

00:13:47,519 --> 00:13:52,639
rid headers for user requests so the

00:13:50,639 --> 00:13:53,440
problem inside of our web assembly

00:13:52,639 --> 00:13:55,680
filter

00:13:53,440 --> 00:13:57,920
is that we do not have access to file

00:13:55,680 --> 00:14:01,279
reads here

00:13:57,920 --> 00:14:04,240
okay another challenge that we ran into

00:14:01,279 --> 00:14:06,000
is the rs secret is stored in the yahoo

00:14:04,240 --> 00:14:08,720
key management service

00:14:06,000 --> 00:14:09,920
so here we ran into a couple of problems

00:14:08,720 --> 00:14:12,560
as well

00:14:09,920 --> 00:14:14,399
so the first one being is the existing

00:14:12,560 --> 00:14:17,519
client for the key management

00:14:14,399 --> 00:14:18,320
service relies on the curl library which

00:14:17,519 --> 00:14:20,959
requires

00:14:18,320 --> 00:14:23,279
access to the underlying network socket

00:14:20,959 --> 00:14:24,959
which we do not have inside of our web

00:14:23,279 --> 00:14:28,160
assembly filter

00:14:24,959 --> 00:14:30,000
also we need to make multiple calls to

00:14:28,160 --> 00:14:32,560
this key management service to get

00:14:30,000 --> 00:14:34,160
the rs secret so every time we're

00:14:32,560 --> 00:14:37,040
waiting for a response

00:14:34,160 --> 00:14:38,720
we would essentially be blocking uh to

00:14:37,040 --> 00:14:41,680
wait for that response

00:14:38,720 --> 00:14:43,440
which is essentially a busy weight this

00:14:41,680 --> 00:14:45,760
blocks the envoy threads

00:14:43,440 --> 00:14:47,760
actually from executing and also from

00:14:45,760 --> 00:14:50,880
coming up

00:14:47,760 --> 00:14:52,079
another issue is that we cannot take the

00:14:50,880 --> 00:14:54,399
rs secret

00:14:52,079 --> 00:14:55,839
and write a file into the envoy

00:14:54,399 --> 00:14:58,240
container with it

00:14:55,839 --> 00:14:59,839
because once again as part of our

00:14:58,240 --> 00:15:03,519
webassembly filter

00:14:59,839 --> 00:15:05,560
we do not have access to file reads

00:15:03,519 --> 00:15:08,240
okay so let's take a look at the

00:15:05,560 --> 00:15:10,480
architecture that we came up with to get

00:15:08,240 --> 00:15:13,519
around some of these challenges

00:15:10,480 --> 00:15:15,600
so here we have an ingress node which is

00:15:13,519 --> 00:15:18,880
running a daemon set pod

00:15:15,600 --> 00:15:20,079
with the ingress util server which has a

00:15:18,880 --> 00:15:23,199
localhost server

00:15:20,079 --> 00:15:25,120
inside of it when this is coming up it's

00:15:23,199 --> 00:15:26,880
going to make a request to the key

00:15:25,120 --> 00:15:29,680
management server

00:15:26,880 --> 00:15:31,440
get the rs secret and put it inside of

00:15:29,680 --> 00:15:34,480
its own memory

00:15:31,440 --> 00:15:37,360
so because we have this localhost server

00:15:34,480 --> 00:15:39,600
basically the vm filters themselves do

00:15:37,360 --> 00:15:40,800
not need to make your request to the key

00:15:39,600 --> 00:15:44,480
management server

00:15:40,800 --> 00:15:47,279
as well so here we have the ingress

00:15:44,480 --> 00:15:48,079
pod with the envoy container when it is

00:15:47,279 --> 00:15:50,320
coming up

00:15:48,079 --> 00:15:52,720
it has a singleton vm which is running

00:15:50,320 --> 00:15:55,600
as part of the main envoy thread

00:15:52,720 --> 00:15:58,399
as previously described and this will go

00:15:55,600 --> 00:16:01,120
ahead and call this localhost service

00:15:58,399 --> 00:16:02,480
get the rs secret and then write it to

00:16:01,120 --> 00:16:04,560
the shared data

00:16:02,480 --> 00:16:06,959
which will then be available to be read

00:16:04,560 --> 00:16:09,040
by other vms inside of the envoy

00:16:06,959 --> 00:16:11,680
container

00:16:09,040 --> 00:16:14,079
okay so now when we have the envoy

00:16:11,680 --> 00:16:16,320
worker threads which are coming up

00:16:14,079 --> 00:16:18,720
initially what will happen is they will

00:16:16,320 --> 00:16:19,759
use their start time as a seed for the

00:16:18,720 --> 00:16:22,639
rid

00:16:19,759 --> 00:16:24,240
so that we can have unique rids for the

00:16:22,639 --> 00:16:26,639
user request

00:16:24,240 --> 00:16:27,680
and then they will go ahead and read the

00:16:26,639 --> 00:16:30,320
rs secret

00:16:27,680 --> 00:16:32,639
from the shared data and load it into

00:16:30,320 --> 00:16:35,279
its own memory

00:16:32,639 --> 00:16:36,000
okay so now let's go into the secret

00:16:35,279 --> 00:16:39,040
fetch flow

00:16:36,000 --> 00:16:40,320
itself so when the envoy main thread is

00:16:39,040 --> 00:16:43,680
being initialized

00:16:40,320 --> 00:16:46,480
it will call into our webassembly module

00:16:43,680 --> 00:16:48,399
which has a root context defined here we

00:16:46,480 --> 00:16:50,880
have two functions in place

00:16:48,399 --> 00:16:52,480
so the first one is the onstart which

00:16:50,880 --> 00:16:55,519
will go ahead and make an

00:16:52,480 --> 00:16:57,680
http call to the ingress util server for

00:16:55,519 --> 00:17:00,160
the secret

00:16:57,680 --> 00:17:01,040
and then we have the on http call

00:17:00,160 --> 00:17:03,360
response

00:17:01,040 --> 00:17:05,679
which will go ahead and get invoked when

00:17:03,360 --> 00:17:08,400
the ingress util server response

00:17:05,679 --> 00:17:10,559
actually comes back and here is where we

00:17:08,400 --> 00:17:12,559
actually write the secret to the shared

00:17:10,559 --> 00:17:15,199
data

00:17:12,559 --> 00:17:16,799
okay now let's talk about the user

00:17:15,199 --> 00:17:19,520
request flow itself

00:17:16,799 --> 00:17:21,520
so here we have the envoy worker thread

00:17:19,520 --> 00:17:22,160
on the right we have our web assembly

00:17:21,520 --> 00:17:24,720
filter

00:17:22,160 --> 00:17:26,480
which has a root context defined with an

00:17:24,720 --> 00:17:28,960
onstart function

00:17:26,480 --> 00:17:31,679
so here inside of the onstart we read

00:17:28,960 --> 00:17:35,039
the secret from the shared data

00:17:31,679 --> 00:17:37,039
populate an in-memory variable with the

00:17:35,039 --> 00:17:39,360
rs secret that we can use

00:17:37,039 --> 00:17:42,240
then to generate and validate the rs

00:17:39,360 --> 00:17:44,240
header which is coming in

00:17:42,240 --> 00:17:46,160
now when the user requests are coming

00:17:44,240 --> 00:17:49,120
the stream filter chain will call

00:17:46,160 --> 00:17:50,480
into our filter where a context object

00:17:49,120 --> 00:17:53,679
will be created

00:17:50,480 --> 00:17:55,840
so here inside of the constructor

00:17:53,679 --> 00:17:57,360
if the in-memory variable with the rs

00:17:55,840 --> 00:17:59,919
secret is not set

00:17:57,360 --> 00:18:02,000
we will actually go ahead and also read

00:17:59,919 --> 00:18:04,480
the secret from the shared data

00:18:02,000 --> 00:18:06,640
this is used as a backup just in case

00:18:04,480 --> 00:18:08,880
the ingress utils server took a little

00:18:06,640 --> 00:18:11,360
bit longer to respond

00:18:08,880 --> 00:18:13,840
and for the main functionality we have

00:18:11,360 --> 00:18:16,480
the on request headers implemented so

00:18:13,840 --> 00:18:19,280
here is where we generate the rid

00:18:16,480 --> 00:18:19,760
and also validate and generate the rate

00:18:19,280 --> 00:18:22,720
rp

00:18:19,760 --> 00:18:26,160
and rs and this will occur for every

00:18:22,720 --> 00:18:29,039
user request which is coming in

00:18:26,160 --> 00:18:30,320
okay so now let me show you the envoy

00:18:29,039 --> 00:18:33,520
configuration

00:18:30,320 --> 00:18:35,919
so we are running envoy 1.13.x with

00:18:33,520 --> 00:18:38,400
istio 1.5.x

00:18:35,919 --> 00:18:40,640
inside of the bootstrap configuration we

00:18:38,400 --> 00:18:41,200
have the ingress util server cluster

00:18:40,640 --> 00:18:44,480
defined

00:18:41,200 --> 00:18:46,400
and also the singleton filter in the

00:18:44,480 --> 00:18:48,799
filter chain configuration we have the

00:18:46,400 --> 00:18:50,720
yahoo headers filter defined

00:18:48,799 --> 00:18:52,080
so here this is the bootstrap

00:18:50,720 --> 00:18:54,640
configuration

00:18:52,080 --> 00:18:56,080
as you can see here we have a static

00:18:54,640 --> 00:18:58,559
cluster resource defined

00:18:56,080 --> 00:18:59,760
for the ingress util server pointing to

00:18:58,559 --> 00:19:01,679
localhost

00:18:59,760 --> 00:19:02,799
this will be used by the actual

00:19:01,679 --> 00:19:05,919
singleton vm

00:19:02,799 --> 00:19:07,600
to make a request into to fetch the rs

00:19:05,919 --> 00:19:10,240
secret

00:19:07,600 --> 00:19:12,559
down here we have our singleton filter

00:19:10,240 --> 00:19:14,480
definition with the singleton boolean

00:19:12,559 --> 00:19:17,360
set to true

00:19:14,480 --> 00:19:19,200
now inside of the filter chain we

00:19:17,360 --> 00:19:22,080
basically have our yahoo header

00:19:19,200 --> 00:19:22,080
configuration

00:19:22,480 --> 00:19:26,799
now let's go into demo to see how this

00:19:25,039 --> 00:19:29,039
functionality looks like

00:19:26,799 --> 00:19:30,000
so when a user request is actually

00:19:29,039 --> 00:19:32,160
coming in

00:19:30,000 --> 00:19:33,520
we will check if these three headers are

00:19:32,160 --> 00:19:36,000
actually defined

00:19:33,520 --> 00:19:36,880
if they are we will validate the rs

00:19:36,000 --> 00:19:38,960
signature

00:19:36,880 --> 00:19:42,240
if the signature is valid we will go

00:19:38,960 --> 00:19:45,200
ahead and continue the http request

00:19:42,240 --> 00:19:46,320
if it is invalid we will generate an

00:19:45,200 --> 00:19:49,039
rarp

00:19:46,320 --> 00:19:50,080
and rs from the incoming client

00:19:49,039 --> 00:19:52,799
connection

00:19:50,080 --> 00:19:53,600
we will get its address and port and

00:19:52,799 --> 00:19:58,320
generate an

00:19:53,600 --> 00:20:00,960
rs and then continue the http request

00:19:58,320 --> 00:20:03,360
now if the headers are not set what we

00:20:00,960 --> 00:20:07,679
will do is we will generate new ones

00:20:03,360 --> 00:20:10,720
and then continue the http request

00:20:07,679 --> 00:20:13,440
okay so now for the rid flow it's a

00:20:10,720 --> 00:20:16,400
little bit simpler so here if the rid

00:20:13,440 --> 00:20:17,440
is set we will just continue the http

00:20:16,400 --> 00:20:20,159
request

00:20:17,440 --> 00:20:21,039
if it is not set then we will generate a

00:20:20,159 --> 00:20:23,360
new one

00:20:21,039 --> 00:20:25,360
so now let me show you a demo of how

00:20:23,360 --> 00:20:28,240
this functionality looks like

00:20:25,360 --> 00:20:29,520
so i have an echo server which is behind

00:20:28,240 --> 00:20:32,320
an istio ingress

00:20:29,520 --> 00:20:33,039
pod so here i am not passing in any

00:20:32,320 --> 00:20:35,679
headers

00:20:33,039 --> 00:20:37,039
so what you will see is that basically a

00:20:35,679 --> 00:20:40,640
new set of headers

00:20:37,039 --> 00:20:44,159
will be defined here created so the rid

00:20:40,640 --> 00:20:46,840
rs rp and r8 are brand new which were

00:20:44,159 --> 00:20:48,000
generated from my incoming client

00:20:46,840 --> 00:20:51,120
information

00:20:48,000 --> 00:20:53,200
now if i go ahead and i pass in a set of

00:20:51,120 --> 00:20:55,360
headers inside of my curl

00:20:53,200 --> 00:20:57,120
since these are valid they will be

00:20:55,360 --> 00:21:00,080
persisted throughout the

00:20:57,120 --> 00:21:00,799
connection life cycle so here as you can

00:21:00,080 --> 00:21:02,799
see

00:21:00,799 --> 00:21:05,679
these headers persisted because the

00:21:02,799 --> 00:21:08,559
validation was successful

00:21:05,679 --> 00:21:10,240
now if i slightly modify the signature

00:21:08,559 --> 00:21:12,559
making it invalid

00:21:10,240 --> 00:21:13,280
what you will see is the validation will

00:21:12,559 --> 00:21:15,440
fail

00:21:13,280 --> 00:21:17,840
and then we will generate new ones from

00:21:15,440 --> 00:21:20,960
the incoming client connection

00:21:17,840 --> 00:21:21,440
so as you can see here basically these

00:21:20,960 --> 00:21:25,200
three

00:21:21,440 --> 00:21:27,919
are new the rsrp and ra from my incoming

00:21:25,200 --> 00:21:30,320
client connection

00:21:27,919 --> 00:21:32,080
okay so let's talk about some other

00:21:30,320 --> 00:21:35,200
functionality that we have

00:21:32,080 --> 00:21:37,280
so the proxy was some stats api allows

00:21:35,200 --> 00:21:40,159
you to have custom metrics

00:21:37,280 --> 00:21:40,720
so here we define essentially metrics

00:21:40,159 --> 00:21:44,240
for our

00:21:40,720 --> 00:21:45,039
filter to see how it's behaving and also

00:21:44,240 --> 00:21:46,960
to increment

00:21:45,039 --> 00:21:48,240
in case there are any failure scenarios

00:21:46,960 --> 00:21:51,440
so that we can alert

00:21:48,240 --> 00:21:54,880
upon them as well so as you can see here

00:21:51,440 --> 00:21:57,120
if you hit the envoy stats api

00:21:54,880 --> 00:21:59,760
you can access the metrics which you are

00:21:57,120 --> 00:22:02,240
setting

00:21:59,760 --> 00:22:04,320
okay now let's talk a little bit about

00:22:02,240 --> 00:22:06,480
some of the performance metrics

00:22:04,320 --> 00:22:09,360
so here we wanted to run a load test to

00:22:06,480 --> 00:22:12,400
see how our filter behaved under load

00:22:09,360 --> 00:22:13,360
so we have one istio ingress pod running

00:22:12,400 --> 00:22:16,480
with 24

00:22:13,360 --> 00:22:17,600
envoy worker threads meaning 24 cpu with

00:22:16,480 --> 00:22:21,039
our filter

00:22:17,600 --> 00:22:22,480
we run 4k rps for 10 minutes and we have

00:22:21,039 --> 00:22:25,200
vegetal load test

00:22:22,480 --> 00:22:26,080
pods generating the client load with an

00:22:25,200 --> 00:22:29,440
echo server

00:22:26,080 --> 00:22:31,760
upstream so as you can see here we have

00:22:29,440 --> 00:22:33,840
multiple scenarios which we are testing

00:22:31,760 --> 00:22:36,320
which is similar to the demo

00:22:33,840 --> 00:22:38,080
essentially the generation flow if there

00:22:36,320 --> 00:22:41,039
are no headers coming in

00:22:38,080 --> 00:22:41,840
the validation flow if headers are

00:22:41,039 --> 00:22:44,640
passed in

00:22:41,840 --> 00:22:47,120
and the validation and generation flow

00:22:44,640 --> 00:22:49,440
where the incoming headers were invalid

00:22:47,120 --> 00:22:51,840
and then regenerating new ones

00:22:49,440 --> 00:22:53,039
so here i pointing pointed out the worst

00:22:51,840 --> 00:22:55,840
case scenario

00:22:53,039 --> 00:22:58,000
where essentially when the incoming

00:22:55,840 --> 00:23:01,360
headers are invalid and we generate

00:22:58,000 --> 00:23:02,880
new ones so the p99 here increased by

00:23:01,360 --> 00:23:06,720
half a millisecond

00:23:02,880 --> 00:23:09,520
and the cpu increased by three percent

00:23:06,720 --> 00:23:11,280
and for the memory and rss it increased

00:23:09,520 --> 00:23:13,520
by 0.66

00:23:11,280 --> 00:23:14,640
here so this is a little bit to be

00:23:13,520 --> 00:23:16,799
expected

00:23:14,640 --> 00:23:19,840
because you are copying the requests

00:23:16,799 --> 00:23:21,840
into and out of the vm

00:23:19,840 --> 00:23:23,840
okay so now let's talk a little bit

00:23:21,840 --> 00:23:26,799
about some of our key learnings

00:23:23,840 --> 00:23:29,679
so the first one is we have that the web

00:23:26,799 --> 00:23:32,080
assembly eases the developer experience

00:23:29,679 --> 00:23:34,080
it allows you to implement a filter in

00:23:32,080 --> 00:23:35,360
your programming language of choice that

00:23:34,080 --> 00:23:37,520
you're comfortable with

00:23:35,360 --> 00:23:39,840
and then you can compile down into the

00:23:37,520 --> 00:23:43,200
web assembly filter

00:23:39,840 --> 00:23:45,919
also the envoy deployment itself

00:23:43,200 --> 00:23:48,000
is separate from the webassembly filter

00:23:45,919 --> 00:23:51,039
so this means that the teams can work

00:23:48,000 --> 00:23:53,039
independently to implement their logic

00:23:51,039 --> 00:23:54,880
okay so now let's talk a little bit

00:23:53,039 --> 00:23:57,960
about the wasan vm

00:23:54,880 --> 00:23:59,279
sandbox so first of all it ensures

00:23:57,960 --> 00:24:01,600
reliability

00:23:59,279 --> 00:24:02,400
so if there are any issues with your

00:24:01,600 --> 00:24:04,720
filter

00:24:02,400 --> 00:24:06,000
and it's crashing it will not bring down

00:24:04,720 --> 00:24:09,279
the envoy process

00:24:06,000 --> 00:24:10,320
itself also there's the security aspect

00:24:09,279 --> 00:24:13,360
here as well

00:24:10,320 --> 00:24:13,919
so essentially the vm filter cannot

00:24:13,360 --> 00:24:18,159
access

00:24:13,919 --> 00:24:20,559
anything on the envoy host as uh

00:24:18,159 --> 00:24:22,559
it does not have any access to it only

00:24:20,559 --> 00:24:24,400
what is defined through the proxy was

00:24:22,559 --> 00:24:27,120
some apis

00:24:24,400 --> 00:24:27,919
also there are a couple of restrictions

00:24:27,120 --> 00:24:30,240
in place

00:24:27,919 --> 00:24:31,520
so like i mentioned previously you do

00:24:30,240 --> 00:24:34,159
not have access to

00:24:31,520 --> 00:24:36,000
file reads you cannot do busy weights

00:24:34,159 --> 00:24:36,960
you don't have access to the network

00:24:36,000 --> 00:24:39,440
socket

00:24:36,960 --> 00:24:40,000
and also the threading and exception

00:24:39,440 --> 00:24:42,640
support

00:24:40,000 --> 00:24:44,720
is not there but those two will be there

00:24:42,640 --> 00:24:46,559
sometime in the future

00:24:44,720 --> 00:24:48,640
and also you do get a little bit of a

00:24:46,559 --> 00:24:50,320
performance overhead which i mentioned

00:24:48,640 --> 00:24:53,200
previously

00:24:50,320 --> 00:24:54,320
also one thing that i want to mention is

00:24:53,200 --> 00:24:56,320
that compiling with

00:24:54,320 --> 00:24:58,000
external libraries is also not

00:24:56,320 --> 00:25:00,159
straightforward

00:24:58,000 --> 00:25:01,279
so what we had to do is we needed to

00:25:00,159 --> 00:25:04,000
compile down

00:25:01,279 --> 00:25:04,320
with the core yaku c plus plus libraries

00:25:04,000 --> 00:25:07,760
and

00:25:04,320 --> 00:25:10,080
also open ssl for md5

00:25:07,760 --> 00:25:11,600
so due to this we you had to we had to

00:25:10,080 --> 00:25:14,640
essentially compile them down

00:25:11,600 --> 00:25:16,799
into what's known as llvm bitcode

00:25:14,640 --> 00:25:18,880
which then can be used to import and

00:25:16,799 --> 00:25:19,840
compile down with your webassembly

00:25:18,880 --> 00:25:21,760
module

00:25:19,840 --> 00:25:24,159
so that was a little bit of a learning

00:25:21,760 --> 00:25:27,200
curve and wasn't straightforward so that

00:25:24,159 --> 00:25:30,000
is something you should also be aware of

00:25:27,200 --> 00:25:31,279
and finally the envoy was sem is still

00:25:30,000 --> 00:25:32,960
an alpha stage

00:25:31,279 --> 00:25:35,360
so it is in the process of being

00:25:32,960 --> 00:25:37,679
upstream to envoy so not all of the

00:25:35,360 --> 00:25:40,159
functionality is in place

00:25:37,679 --> 00:25:41,039
also proxy was sam apis are still a work

00:25:40,159 --> 00:25:43,760
in progress

00:25:41,039 --> 00:25:45,440
so there are some things that they do

00:25:43,760 --> 00:25:48,799
not have yet for example

00:25:45,440 --> 00:25:50,400
sds support so one idea is we could have

00:25:48,799 --> 00:25:53,120
had our rs secret

00:25:50,400 --> 00:25:55,279
be inside of the sds and then we

00:25:53,120 --> 00:25:56,159
wouldn't have needed the ingress util

00:25:55,279 --> 00:25:58,000
server

00:25:56,159 --> 00:25:59,919
but unfortunately since this is not

00:25:58,000 --> 00:26:02,000
there yet we we didn't

00:25:59,919 --> 00:26:04,640
do that but it will be coming sometime

00:26:02,000 --> 00:26:06,320
in the future

00:26:04,640 --> 00:26:08,720
okay so we had a couple of

00:26:06,320 --> 00:26:11,600
acknowledgements so we wanted to thank

00:26:08,720 --> 00:26:14,080
the envoy was some community and also

00:26:11,600 --> 00:26:16,880
specifically john plebiac from there

00:26:14,080 --> 00:26:18,000
the istio team and also from the core

00:26:16,880 --> 00:26:22,400
infrastructure team

00:26:18,000 --> 00:26:24,880
suresh baskram and catherine as well

00:26:22,400 --> 00:26:25,679
okay so thank you so much for coming to

00:26:24,880 --> 00:26:29,039
our talk

00:26:25,679 --> 00:26:31,120
and listening to our experience for

00:26:29,039 --> 00:26:32,480
implementing yahoo headers using the web

00:26:31,120 --> 00:26:34,799
assembly filter

00:26:32,480 --> 00:26:36,960
if you have any questions then please

00:26:34,799 --> 00:26:37,360
let us know and we'd be happy to answer

00:26:36,960 --> 00:26:40,720
them

00:26:37,360 --> 00:26:43,760
thank you so much hello

00:26:40,720 --> 00:26:44,480
can you hear us hello there can you hear

00:26:43,760 --> 00:26:47,360
us

00:26:44,480 --> 00:26:48,640
i believe so um so i can take the first

00:26:47,360 --> 00:26:49,600
question which was regarding the

00:26:48,640 --> 00:26:51,520
performance

00:26:49,600 --> 00:26:52,880
so we did see some amount of performance

00:26:51,520 --> 00:26:55,039
improvement in general

00:26:52,880 --> 00:26:56,640
in terms of the throughput per box uh

00:26:55,039 --> 00:26:57,360
but it does require a little bit of

00:26:56,640 --> 00:26:58,960
tuning because

00:26:57,360 --> 00:27:01,120
we've been using apache traffic server

00:26:58,960 --> 00:27:02,880
for a while now at yahoo so

00:27:01,120 --> 00:27:04,400
a lot of those uh have already been

00:27:02,880 --> 00:27:05,679
tuned so with onboard that has been a

00:27:04,400 --> 00:27:06,400
bit of a learning curve we're learning

00:27:05,679 --> 00:27:07,919
how to tune

00:27:06,400 --> 00:27:09,679
some of the aspects like especially if

00:27:07,919 --> 00:27:11,919
there are large payloads we've had to

00:27:09,679 --> 00:27:13,520
tune some of the settings on envoy so

00:27:11,919 --> 00:27:14,720
there has been some performance

00:27:13,520 --> 00:27:16,720
improvements but there's also been a

00:27:14,720 --> 00:27:19,840
learning curve for us to get the maximum

00:27:16,720 --> 00:27:22,240
performance out of envoy

00:27:19,840 --> 00:27:23,760
and then yeah so in terms of the ssl

00:27:22,240 --> 00:27:25,200
libraries that we're using to actually

00:27:23,760 --> 00:27:28,720
generate the secret

00:27:25,200 --> 00:27:31,919
so we're using the openssl

00:27:28,720 --> 00:27:35,200
md5 library to generate the rs uh

00:27:31,919 --> 00:27:37,840
secret itself basically with the base64

00:27:35,200 --> 00:27:40,240
encoding and in terms of generating the

00:27:37,840 --> 00:27:42,080
secret that is used for the md5 that's

00:27:40,240 --> 00:27:44,000
actually part of the actual key

00:27:42,080 --> 00:27:47,600
management service so i don't think

00:27:44,000 --> 00:27:49,440
i can share too many details about that

00:27:47,600 --> 00:27:51,520
and then another thing that i wanted

00:27:49,440 --> 00:27:53,840
just to clarify because i know in one of

00:27:51,520 --> 00:27:56,240
the last slides i mentioned that

00:27:53,840 --> 00:27:58,159
basically the web assembly functionality

00:27:56,240 --> 00:28:01,120
is not fully merged yet into

00:27:58,159 --> 00:28:03,520
envoy so actually as of a few days ago

00:28:01,120 --> 00:28:06,320
it did get merged into the actual

00:28:03,520 --> 00:28:07,200
envoy upstream code base so the envoy

00:28:06,320 --> 00:28:09,760
was

00:28:07,200 --> 00:28:11,679
repo was basically archived and then

00:28:09,760 --> 00:28:13,600
everything was upstream to envoy so that

00:28:11,679 --> 00:28:17,840
functionality should be there now

00:28:13,600 --> 00:28:17,840
so just wanted to clarify that as well

00:28:18,000 --> 00:28:22,799
okay let's see yeah i think the last one

00:28:21,200 --> 00:28:23,360
was regarding the language so we

00:28:22,799 --> 00:28:25,520
actually

00:28:23,360 --> 00:28:26,960
uh chose c plus plus as the language

00:28:25,520 --> 00:28:28,480
because we had a lot of existing

00:28:26,960 --> 00:28:30,320
yahoo libraries that we wanted to

00:28:28,480 --> 00:28:31,919
compile with so that's the reason why we

00:28:30,320 --> 00:28:34,559
chose that

00:28:31,919 --> 00:28:36,559
yeah and yeah i mean in terms of

00:28:34,559 --> 00:28:38,000
compiling with open ssl

00:28:36,559 --> 00:28:39,919
yeah it was definitely a little bit

00:28:38,000 --> 00:28:42,880
painful basically i

00:28:39,919 --> 00:28:44,960
we had to compile the open ssl down into

00:28:42,880 --> 00:28:46,640
llvm bitcode first

00:28:44,960 --> 00:28:49,919
that we could then use to actually

00:28:46,640 --> 00:28:51,840
compile down with our webassembly filter

00:28:49,919 --> 00:28:53,679
so that was definitely of a learning

00:28:51,840 --> 00:28:55,760
curve for us basically figuring out how

00:28:53,679 --> 00:28:56,559
to do that compilation first before we

00:28:55,760 --> 00:28:58,720
could use it

00:28:56,559 --> 00:28:58,720
so

00:29:00,480 --> 00:29:03,440
itself we only had to compile it with

00:29:02,000 --> 00:29:05,200
like our filter so that definitely

00:29:03,440 --> 00:29:06,799
simplified things

00:29:05,200 --> 00:29:08,320
yeah that's like the biggest advantage

00:29:06,799 --> 00:29:10,080
that we see with vasim is that we don't

00:29:08,320 --> 00:29:10,559
have to recompile the convoy source code

00:29:10,080 --> 00:29:13,200
itself

00:29:10,559 --> 00:29:15,440
we can just you know build a filter

00:29:13,200 --> 00:29:20,240
independent of it

00:29:15,440 --> 00:29:20,240
exactly yeah definitely a large benefit

00:29:22,320 --> 00:29:26,799
cool yeah please let us know if you have

00:29:24,720 --> 00:29:28,799
any other questions in the chat

00:29:26,799 --> 00:29:29,840
um yeah and then also if you have any

00:29:28,799 --> 00:29:32,559
questions then

00:29:29,840 --> 00:29:34,960
feel free to reach out to us as well so

00:29:32,559 --> 00:29:37,120
uh basically our handles are mduma

00:29:34,960 --> 00:29:38,799
and i'm chet black on the on voicetack

00:29:37,120 --> 00:29:41,200
channel and also on github

00:29:38,799 --> 00:29:43,679
so feel free to reach out to us as well

00:29:41,200 --> 00:29:46,720
with any questions you have

00:29:43,679 --> 00:29:48,240
thank you cool thank you

00:29:46,720 --> 00:29:52,880
the next session is starting thank you

00:29:48,240 --> 00:29:52,880

YouTube URL: https://www.youtube.com/watch?v=CsrDtutkNcM


