Title: Next Level gRPC With Kotlin and Coroutines - Marco Ferrer, OfferUp
Publication date: 2020-08-01
Playlist: gRPC Conf 2020
Description: 
	Next Level gRPC With Kotlin and Coroutines - Marco Ferrer, OfferUp

When it comes to async programming on the JVM, Kotlin Coroutines are leading the pack in both versatility and performance. This session will cover how the usage of Coroutines improves the ergonomics of APIs from both a client and server perspective. It will also cover the key benefits gained by adopting the practice of structured concurrency. Attendees will learn how Coroutines enable clients and services to participate in cooperative cancellation across network boundaries. Improving overall resource utilization. See how Coroutine suspension maps naturally to gRPC's backpressure mechanisms. After which we will dive into the state of the gRPC ecosystem for Kotlin. Analyzing what the available options are for current users and what the future has in store for the ecosystem.
Captions: 
	00:00:00,320 --> 00:00:04,080
hi my name is marco ferreira and the

00:00:02,080 --> 00:00:05,759
title of this session is next level grpc

00:00:04,080 --> 00:00:06,960
with kotlin and co-routines

00:00:05,759 --> 00:00:08,880
in this session we're going to cover

00:00:06,960 --> 00:00:09,840
what the available options are for gft's

00:00:08,880 --> 00:00:12,639
development

00:00:09,840 --> 00:00:14,080
on the jvm using kotlin we're going to

00:00:12,639 --> 00:00:15,599
take a look at what the general api

00:00:14,080 --> 00:00:16,560
ergonomics look like for the available

00:00:15,599 --> 00:00:19,279
offerings

00:00:16,560 --> 00:00:20,400
as well as demonstrate how we can use

00:00:19,279 --> 00:00:21,920
some of the special features of

00:00:20,400 --> 00:00:25,840
coroutines to improve

00:00:21,920 --> 00:00:25,840
our grpc service implementations

00:00:28,160 --> 00:00:32,239
for those who aren't familiar kotlin

00:00:30,160 --> 00:00:33,680
started out as a jvm-based language

00:00:32,239 --> 00:00:35,040
developed and released by jetbrains in

00:00:33,680 --> 00:00:36,880
2011.

00:00:35,040 --> 00:00:39,040
it is that since then evolved to be a

00:00:36,880 --> 00:00:40,480
full multi-platform language allowing

00:00:39,040 --> 00:00:43,200
users to write and share codes

00:00:40,480 --> 00:00:44,239
across various runtimes what kotlin is

00:00:43,200 --> 00:00:46,320
most well known for

00:00:44,239 --> 00:00:47,680
is the fact that it's now an official

00:00:46,320 --> 00:00:48,800
preferred language for android

00:00:47,680 --> 00:00:51,120
development

00:00:48,800 --> 00:00:55,199
and this fact is what has caused it to

00:00:51,120 --> 00:00:55,199
gain so much popularity in recent years

00:00:55,760 --> 00:00:58,879
now co-routines coroutines aren't a new

00:00:58,079 --> 00:01:00,320
concept

00:00:58,879 --> 00:01:01,920
they've existed for quite some time and

00:01:00,320 --> 00:01:02,960
appeared in various flavors of various

00:01:01,920 --> 00:01:06,000
names

00:01:02,960 --> 00:01:07,600
some of the more recent examples include

00:01:06,000 --> 00:01:09,360
go routines

00:01:07,600 --> 00:01:12,880
in a few years time java will also have

00:01:09,360 --> 00:01:14,720
cover teams in the form of project loom

00:01:12,880 --> 00:01:16,880
one thing each current incarnation of

00:01:14,720 --> 00:01:18,880
core team sets out to accomplish is to

00:01:16,880 --> 00:01:20,640
simplify writing and reasoning about

00:01:18,880 --> 00:01:22,000
asynchronous software

00:01:20,640 --> 00:01:24,080
there are a few key characteristics that

00:01:22,000 --> 00:01:25,119
kotlin core teams embody

00:01:24,080 --> 00:01:26,560
which we're not going to cover in this

00:01:25,119 --> 00:01:28,159
session but i really do recommend

00:01:26,560 --> 00:01:29,119
checking out a talk given by roman

00:01:28,159 --> 00:01:30,960
elizorov

00:01:29,119 --> 00:01:32,640
uh the library lead at jet brains and

00:01:30,960 --> 00:01:33,360
it's called kotlin core routines in

00:01:32,640 --> 00:01:37,119
practice

00:01:33,360 --> 00:01:37,119
and it's from kotlin conf 2018.

00:01:38,159 --> 00:01:41,600
so to give a little bit of an example as

00:01:40,000 --> 00:01:43,119
to why we're going to be using

00:01:41,600 --> 00:01:45,520
co-routines or why we would want to use

00:01:43,119 --> 00:01:47,520
co-routines for our service development

00:01:45,520 --> 00:01:49,200
we are going to do a little toy problem

00:01:47,520 --> 00:01:49,759
and in this problem we're going to start

00:01:49,200 --> 00:01:54,079
off

00:01:49,759 --> 00:01:56,719
by executing 10 000 co-routines

00:01:54,079 --> 00:01:58,079
in parallel and each of those core

00:01:56,719 --> 00:02:00,719
routines are going to

00:01:58,079 --> 00:02:02,880
sleep for a second and print a period to

00:02:00,719 --> 00:02:05,920
the console

00:02:02,880 --> 00:02:07,040
the total execution time for this comes

00:02:05,920 --> 00:02:09,840
out to about

00:02:07,040 --> 00:02:12,239
one second or so if you take factor in

00:02:09,840 --> 00:02:14,000
the i o of printing out our string

00:02:12,239 --> 00:02:15,840
now if we look at what that example

00:02:14,000 --> 00:02:18,720
looks like using

00:02:15,840 --> 00:02:19,440
threads um we'll end up having to kill

00:02:18,720 --> 00:02:22,800
the process

00:02:19,440 --> 00:02:24,480
because of the fact that threads

00:02:22,800 --> 00:02:26,319
and it's specifically in this example

00:02:24,480 --> 00:02:28,640
when we're performing our sleep

00:02:26,319 --> 00:02:30,000
we're actually blocking that thread and

00:02:28,640 --> 00:02:31,519
no other

00:02:30,000 --> 00:02:33,519
computations can be performed that

00:02:31,519 --> 00:02:36,080
thread is locked until we're ready

00:02:33,519 --> 00:02:37,599
or in our sleep cont finishes whereas in

00:02:36,080 --> 00:02:39,120
the coroutines example

00:02:37,599 --> 00:02:41,440
we're not using thread.sleep but we're

00:02:39,120 --> 00:02:43,599
using a built-in function called delay

00:02:41,440 --> 00:02:44,959
and what delay does is suspend the

00:02:43,599 --> 00:02:47,440
execution of that method

00:02:44,959 --> 00:02:48,959
pauses it essentially and allows the

00:02:47,440 --> 00:02:53,120
resources

00:02:48,959 --> 00:02:55,280
that we're going to be blocked by that

00:02:53,120 --> 00:02:57,120
by that method that computation to be

00:02:55,280 --> 00:03:00,560
freed up and used for some other tasks

00:02:57,120 --> 00:03:00,560
that's been queued up in the background

00:03:03,040 --> 00:03:07,040
so without all the way we can take a

00:03:04,640 --> 00:03:09,519
look at what our grpc apis look like

00:03:07,040 --> 00:03:10,400
in kotlin we currently have a few

00:03:09,519 --> 00:03:12,319
options

00:03:10,400 --> 00:03:13,440
there's chrono plus a library and suite

00:03:12,319 --> 00:03:16,400
of protoc plugins

00:03:13,440 --> 00:03:16,879
i initially released a few years ago uh

00:03:16,400 --> 00:03:18,640
there's

00:03:16,879 --> 00:03:20,319
very recently the google official

00:03:18,640 --> 00:03:23,840
binaries or bindings

00:03:20,319 --> 00:03:25,120
sorry released um which is very exciting

00:03:23,840 --> 00:03:27,519
for the community

00:03:25,120 --> 00:03:29,440
and finally there is the wire grpc

00:03:27,519 --> 00:03:31,120
runtime developed by square

00:03:29,440 --> 00:03:32,640
for today's session though we're only

00:03:31,120 --> 00:03:34,799
going to focus on the examples

00:03:32,640 --> 00:03:37,040
written using stubs created by google

00:03:34,799 --> 00:03:39,280
and the quota plus compiler plugins

00:03:37,040 --> 00:03:42,319
uh and we'll actually start off by

00:03:39,280 --> 00:03:45,280
taking a look at unary apis

00:03:42,319 --> 00:03:47,360
so this should look somewhat familiar to

00:03:45,280 --> 00:03:49,040
developers that have used grpc java

00:03:47,360 --> 00:03:51,040
it's a service implementation for a

00:03:49,040 --> 00:03:52,799
unary method

00:03:51,040 --> 00:03:55,120
but with the key difference being that

00:03:52,799 --> 00:03:56,799
it's using kotlin syntax

00:03:55,120 --> 00:03:58,879
now if we take a look at what that looks

00:03:56,799 --> 00:04:00,879
like using co routines

00:03:58,879 --> 00:04:02,799
you'll see that first our signature no

00:04:00,879 --> 00:04:04,000
longer acceptance accepts an instance of

00:04:02,799 --> 00:04:05,680
stream observer

00:04:04,000 --> 00:04:07,519
we no longer have to worry about the

00:04:05,680 --> 00:04:10,080
song and dance of calling on next

00:04:07,519 --> 00:04:11,840
on complete or on there ah the method

00:04:10,080 --> 00:04:14,319
now has a return type defined that

00:04:11,840 --> 00:04:15,599
matches our api's response type

00:04:14,319 --> 00:04:17,359
you also notice that the method is

00:04:15,599 --> 00:04:18,880
marked with a suspend keyword meaning

00:04:17,359 --> 00:04:19,519
that its execution can be paused and

00:04:18,880 --> 00:04:21,120
resumed

00:04:19,519 --> 00:04:22,639
allowing us to free up resources for

00:04:21,120 --> 00:04:23,840
other methods that are or other code

00:04:22,639 --> 00:04:25,440
routines that are being executed in the

00:04:23,840 --> 00:04:27,919
background

00:04:25,440 --> 00:04:28,479
both proto plus and google's grpc kotlin

00:04:27,919 --> 00:04:30,479
use this

00:04:28,479 --> 00:04:31,840
this same syntax with one exception

00:04:30,479 --> 00:04:35,680
being that

00:04:31,840 --> 00:04:38,800
in kroto plus you can build your methods

00:04:35,680 --> 00:04:41,199
uh your response messages with

00:04:38,800 --> 00:04:44,800
a lambda that accepts and sets all these

00:04:41,199 --> 00:04:44,800
properties instead of the fluent builder

00:04:45,919 --> 00:04:49,680
when looking at the urinary client usage

00:04:47,759 --> 00:04:51,280
though you see that core team

00:04:49,680 --> 00:04:53,440
interface doesn't differ much from

00:04:51,280 --> 00:04:54,800
vanilla java blocking subs

00:04:53,440 --> 00:04:56,960
with the one exception being that the

00:04:54,800 --> 00:05:00,160
say hello method in this example

00:04:56,960 --> 00:05:01,600
is actually suspending method meaning

00:05:00,160 --> 00:05:03,440
that we're not blocking the current

00:05:01,600 --> 00:05:06,000
thread while we wait for a response from

00:05:03,440 --> 00:05:06,000
the server

00:05:06,639 --> 00:05:10,000
and then again if we're using chronoplus

00:05:08,240 --> 00:05:11,680
we actually have builder lambdas for

00:05:10,000 --> 00:05:13,120
creating and instantiating our protobuf

00:05:11,680 --> 00:05:16,080
messages to

00:05:13,120 --> 00:05:16,960
execute our requests but now one thing

00:05:16,080 --> 00:05:18,560
that you're probably going to ask

00:05:16,960 --> 00:05:21,600
yourself is like this works well

00:05:18,560 --> 00:05:23,440
for sequential operations but

00:05:21,600 --> 00:05:25,840
concurrency we need to be able to make

00:05:23,440 --> 00:05:27,600
calls in parallel call other things

00:05:25,840 --> 00:05:30,560
and aggregate the results of those calls

00:05:27,600 --> 00:05:34,240
all at once and

00:05:30,560 --> 00:05:36,880
we're going to basically show that

00:05:34,240 --> 00:05:38,320
although in core teens um in the core

00:05:36,880 --> 00:05:41,600
team api interfaces

00:05:38,320 --> 00:05:43,680
there are no future stubs concurrent

00:05:41,600 --> 00:05:46,560
execution is still made possible

00:05:43,680 --> 00:05:48,320
um but there's a few caveats one of the

00:05:46,560 --> 00:05:51,520
caveats means that we want to

00:05:48,320 --> 00:05:52,479
adopt co-routines practice of explicit

00:05:51,520 --> 00:05:53,759
concurrency

00:05:52,479 --> 00:05:56,160
and i'm not going to go into too much

00:05:53,759 --> 00:05:56,880
detail but in summary it means that by

00:05:56,160 --> 00:05:58,720
default

00:05:56,880 --> 00:06:00,080
apis and methods should behave and

00:05:58,720 --> 00:06:01,600
execute sequentially

00:06:00,080 --> 00:06:03,919
and when concurrency is needed you

00:06:01,600 --> 00:06:06,960
should explicitly opt into that

00:06:03,919 --> 00:06:07,759
so that there's no unknown or unexpected

00:06:06,960 --> 00:06:10,880
behavior

00:06:07,759 --> 00:06:13,039
or the risk of um

00:06:10,880 --> 00:06:14,800
orphaning resources and not closing out

00:06:13,039 --> 00:06:16,240
uh specific things

00:06:14,800 --> 00:06:18,400
so instead of needing a whole different

00:06:16,240 --> 00:06:21,199
stub we can actually make our

00:06:18,400 --> 00:06:22,240
code concurrent by wrapping our method

00:06:21,199 --> 00:06:26,000
calls within a

00:06:22,240 --> 00:06:27,680
core teams async block now

00:06:26,000 --> 00:06:29,199
we're going to take a look at streaming

00:06:27,680 --> 00:06:30,880
apis

00:06:29,199 --> 00:06:33,759
for the sake of brevity we're only going

00:06:30,880 --> 00:06:35,280
to cover bi-directional streaming

00:06:33,759 --> 00:06:37,199
simply because the client and server

00:06:35,280 --> 00:06:38,240
streaming apis or their implementations

00:06:37,199 --> 00:06:39,759
at least

00:06:38,240 --> 00:06:41,759
they can be inferred easily from these

00:06:39,759 --> 00:06:44,639
examples we'll start with

00:06:41,759 --> 00:06:45,520
a vanilla java bidirectional streaming

00:06:44,639 --> 00:06:49,039
method

00:06:45,520 --> 00:06:50,240
but written in kotlin syntax and its

00:06:49,039 --> 00:06:53,120
implementation

00:06:50,240 --> 00:06:54,160
is very basic in that we validate each

00:06:53,120 --> 00:06:56,000
request

00:06:54,160 --> 00:06:59,759
and we respond to the client and in the

00:06:56,000 --> 00:06:59,759
event of a client error we log the

00:07:00,840 --> 00:07:03,840
description

00:07:06,080 --> 00:07:09,199
so the first example we'll go over is

00:07:07,840 --> 00:07:10,960
using the proto plus api

00:07:09,199 --> 00:07:13,520
which exposes channels a coordinate

00:07:10,960 --> 00:07:15,280
primitive meant for hot streams of data

00:07:13,520 --> 00:07:17,120
we're then going to convert that channel

00:07:15,280 --> 00:07:20,720
into a reactive core team stream

00:07:17,120 --> 00:07:21,759
also known as a flow then we compose an

00:07:20,720 --> 00:07:24,479
operator for

00:07:21,759 --> 00:07:26,720
catching and logging client errors and

00:07:24,479 --> 00:07:28,880
then you'll notice here that

00:07:26,720 --> 00:07:30,639
we'll finally be able to consume the

00:07:28,880 --> 00:07:32,400
stream performing the same validation

00:07:30,639 --> 00:07:35,039
and response handling

00:07:32,400 --> 00:07:36,960
and throwing our status exception

00:07:35,039 --> 00:07:40,080
instead of invoking on error

00:07:36,960 --> 00:07:42,319
or stream observer callback handler

00:07:40,080 --> 00:07:44,080
um now we can look at what the equipment

00:07:42,319 --> 00:07:48,800
looks like using the grpc java

00:07:44,080 --> 00:07:48,800
grpc kotlin official findings

00:07:49,919 --> 00:07:54,319
the key thing to notice is that instead

00:07:52,720 --> 00:07:56,000
of accepting two channels

00:07:54,319 --> 00:07:58,400
the official bindings will actually

00:07:56,000 --> 00:08:00,720
accept a flow of requests and return

00:07:58,400 --> 00:08:01,759
a flow of responses and these are called

00:08:00,720 --> 00:08:03,919
streams of data

00:08:01,759 --> 00:08:05,599
that's the main difference but other

00:08:03,919 --> 00:08:07,919
than that the implementation remains

00:08:05,599 --> 00:08:09,840
largely the same

00:08:07,919 --> 00:08:11,680
we'll go ahead and catch and log our

00:08:09,840 --> 00:08:13,599
client errors and finally consume our

00:08:11,680 --> 00:08:15,919
requests

00:08:13,599 --> 00:08:17,520
and since this is the official bindings

00:08:15,919 --> 00:08:20,240
we're using the fluent builders to build

00:08:17,520 --> 00:08:20,240
out our messages

00:08:21,440 --> 00:08:26,879
now on the other side of streaming apis

00:08:24,720 --> 00:08:30,240
we're going to look at what the client

00:08:26,879 --> 00:08:31,199
implementation is like we create our

00:08:30,240 --> 00:08:33,360
stub

00:08:31,199 --> 00:08:34,640
and when using proto plus we're when

00:08:33,360 --> 00:08:35,680
invoking our streaming method we

00:08:34,640 --> 00:08:37,839
actually get returned

00:08:35,680 --> 00:08:40,320
a pair of two values our request and

00:08:37,839 --> 00:08:41,599
response channel

00:08:40,320 --> 00:08:43,200
in this example you'll see that we're

00:08:41,599 --> 00:08:44,399
actually destructing those two values

00:08:43,200 --> 00:08:45,760
into their own separate variables

00:08:44,399 --> 00:08:48,399
allowing us to perform operations

00:08:45,760 --> 00:08:48,399
independently

00:08:48,560 --> 00:08:52,640
but funny thing is that the square wire

00:08:50,800 --> 00:08:56,399
api also has a very similar design

00:08:52,640 --> 00:08:58,880
with one exception being that the square

00:08:56,399 --> 00:08:59,920
api actually uses a custom primitive

00:08:58,880 --> 00:09:03,839
that behaves

00:08:59,920 --> 00:09:03,839
that behaves sort of like a data stream

00:09:04,160 --> 00:09:07,040
for this example we're going to kick off

00:09:05,600 --> 00:09:09,360
our stream with a message that says

00:09:07,040 --> 00:09:10,800
start iterating

00:09:09,360 --> 00:09:12,640
afterwards we start consuming our

00:09:10,800 --> 00:09:13,920
responses we cancel the call if we

00:09:12,640 --> 00:09:15,839
receive an invalid

00:09:13,920 --> 00:09:17,040
response otherwise we send the next

00:09:15,839 --> 00:09:19,680
request

00:09:17,040 --> 00:09:20,320
and since we're using the kodo plus uh

00:09:19,680 --> 00:09:22,160
variant

00:09:20,320 --> 00:09:24,080
you see that we're using the lambda

00:09:22,160 --> 00:09:26,720
builder to instantiate our method

00:09:24,080 --> 00:09:29,839
to send our response or create an

00:09:26,720 --> 00:09:32,880
instance of our response method

00:09:29,839 --> 00:09:34,880
um when using the official grpc kotlin

00:09:32,880 --> 00:09:38,320
bindings the api is a little bit

00:09:34,880 --> 00:09:41,040
different you'll notice that

00:09:38,320 --> 00:09:43,120
we actually need to pass in a cold flow

00:09:41,040 --> 00:09:44,640
and we'll get a cold flow and response

00:09:43,120 --> 00:09:46,560
now this makes it difficult when we're

00:09:44,640 --> 00:09:49,680
trying to

00:09:46,560 --> 00:09:49,680
make changes or

00:09:50,080 --> 00:09:53,839
react to the responses that we're

00:09:52,160 --> 00:09:56,080
receiving from the stream

00:09:53,839 --> 00:09:58,160
like sending requests based off of

00:09:56,080 --> 00:10:01,839
responses that we've already received

00:09:58,160 --> 00:10:03,040
um but there's very easy ways to get

00:10:01,839 --> 00:10:06,160
around this limitation

00:10:03,040 --> 00:10:08,640
in this uh in this specific example

00:10:06,160 --> 00:10:10,560
we just instantiate a channel that lets

00:10:08,640 --> 00:10:11,360
us have a reference to our request

00:10:10,560 --> 00:10:14,240
stream

00:10:11,360 --> 00:10:16,800
and we'll send that into um our argument

00:10:14,240 --> 00:10:16,800
for our method

00:10:17,040 --> 00:10:20,800
the request channel we go ahead and we

00:10:19,360 --> 00:10:22,320
start iterating as well

00:10:20,800 --> 00:10:24,959
only difference is using our fluent

00:10:22,320 --> 00:10:26,240
builders and we collect our responses

00:10:24,959 --> 00:10:27,360
and

00:10:26,240 --> 00:10:29,920
close out our channel once we've

00:10:27,360 --> 00:10:32,240
completed or we cancel the call

00:10:29,920 --> 00:10:32,959
once we've encountered some kind of

00:10:32,240 --> 00:10:36,000
invalid

00:10:32,959 --> 00:10:36,000
uh response

00:10:36,560 --> 00:10:40,320
so going a little deeper we're gonna

00:10:38,640 --> 00:10:42,560
look past syntactical differences

00:10:40,320 --> 00:10:44,399
and we're gonna dive into the behavior

00:10:42,560 --> 00:10:48,079
of what's using co-routines

00:10:44,399 --> 00:10:50,000
with grpc um the behavior of

00:10:48,079 --> 00:10:51,920
our apis specifically we're going to

00:10:50,000 --> 00:10:54,000
look at how the concept of structured

00:10:51,920 --> 00:10:56,880
concurrency and cooperative cancellation

00:10:54,000 --> 00:10:57,839
affect our api implementations these

00:10:56,880 --> 00:10:59,600
concepts are

00:10:57,839 --> 00:11:01,680
first-class citizens in kotlin covered

00:10:59,600 --> 00:11:03,760
scenes they allow us to write safer more

00:11:01,680 --> 00:11:05,519
efficient concurrent code

00:11:03,760 --> 00:11:07,760
at a high level core routines are

00:11:05,519 --> 00:11:09,120
hierarchical their scopes are

00:11:07,760 --> 00:11:10,800
their scopes bear a parent-child

00:11:09,120 --> 00:11:11,440
relationship with scopes created within

00:11:10,800 --> 00:11:13,040
them

00:11:11,440 --> 00:11:16,399
and we'll see how that plays out when

00:11:13,040 --> 00:11:18,959
we're orchestrating multiple api calls

00:11:16,399 --> 00:11:21,200
cancellation cooperative cancellation is

00:11:18,959 --> 00:11:25,200
very beneficial because we're able to

00:11:21,200 --> 00:11:27,279
not only terminate unnecessary calls

00:11:25,200 --> 00:11:29,040
early but free up those resources so

00:11:27,279 --> 00:11:32,240
that we can continue processing

00:11:29,040 --> 00:11:35,360
actual requests that are

00:11:32,240 --> 00:11:35,360
not in an errored state

00:11:35,680 --> 00:11:39,839
so here's our small example we have a

00:11:38,160 --> 00:11:40,959
method in this method we're going to be

00:11:39,839 --> 00:11:44,640
making three

00:11:40,959 --> 00:11:47,760
uh concurrent requests to um

00:11:44,640 --> 00:11:49,600
to a service um each request we're

00:11:47,760 --> 00:11:52,720
actually going to do

00:11:49,600 --> 00:11:55,839
a fire off in an async block

00:11:52,720 --> 00:11:58,320
and the actual method will

00:11:55,839 --> 00:11:59,040
suspend until we receive the result from

00:11:58,320 --> 00:12:01,440
the service

00:11:59,040 --> 00:12:02,720
before finally we await the results of

00:12:01,440 --> 00:12:06,399
all three of those

00:12:02,720 --> 00:12:07,680
and print the message to the console

00:12:06,399 --> 00:12:09,440
unfortunately though look one of our

00:12:07,680 --> 00:12:10,959
calls has failed which threw an

00:12:09,440 --> 00:12:11,920
exception and terminated the child core

00:12:10,959 --> 00:12:12,880
routine

00:12:11,920 --> 00:12:14,480
now we're still waiting for the

00:12:12,880 --> 00:12:16,160
responses for the other two calls and

00:12:14,480 --> 00:12:17,440
then even though our method requires all

00:12:16,160 --> 00:12:18,639
the values in order to complete

00:12:17,440 --> 00:12:21,200
successfully

00:12:18,639 --> 00:12:22,800
we don't really need those values

00:12:21,200 --> 00:12:25,920
anymore but how do we

00:12:22,800 --> 00:12:29,360
cancel the other two calls because

00:12:25,920 --> 00:12:32,000
our method is now in an invalid state

00:12:29,360 --> 00:12:33,760
well since that child co-routine

00:12:32,000 --> 00:12:36,399
completed exceptionally it actually

00:12:33,760 --> 00:12:37,120
propagates its cancellation to its

00:12:36,399 --> 00:12:39,200
parent

00:12:37,120 --> 00:12:40,399
and in this case the parent begins to

00:12:39,200 --> 00:12:44,160
now cancel

00:12:40,399 --> 00:12:47,279
itself canceling itself uh

00:12:44,160 --> 00:12:50,399
essentially equates to notifying

00:12:47,279 --> 00:12:53,760
all of its children that

00:12:50,399 --> 00:12:56,800
they need to uh cease execution

00:12:53,760 --> 00:12:58,959
so if they were suspended go ahead

00:12:56,800 --> 00:13:00,399
uh run any cancellation callbacks that

00:12:58,959 --> 00:13:03,600
might be registered

00:13:00,399 --> 00:13:07,440
but go ahead and exit early

00:13:03,600 --> 00:13:10,720
and if we look in our case

00:13:07,440 --> 00:13:13,519
since we're using grpc kotlin

00:13:10,720 --> 00:13:15,040
we actually are able to hook into the

00:13:13,519 --> 00:13:18,720
cancellation of our scope

00:13:15,040 --> 00:13:19,600
of our co-routine scope and call the

00:13:18,720 --> 00:13:22,639
cancel method

00:13:19,600 --> 00:13:24,320
on the underlying grpc call that means

00:13:22,639 --> 00:13:26,720
that our scope cancellations are then

00:13:24,320 --> 00:13:29,200
propagated to the server

00:13:26,720 --> 00:13:30,000
via the underlying gpc call and allows

00:13:29,200 --> 00:13:33,200
us to

00:13:30,000 --> 00:13:34,720
do some cleanup or actually behave

00:13:33,200 --> 00:13:35,680
accordingly or react accordingly on the

00:13:34,720 --> 00:13:39,600
server side

00:13:35,680 --> 00:13:42,000
while exiting this method early

00:13:39,600 --> 00:13:43,040
so now that the children have cancelled

00:13:42,000 --> 00:13:45,279
inside of the uh

00:13:43,040 --> 00:13:47,040
parent core routine the parent can then

00:13:45,279 --> 00:13:50,880
be considered cancelled

00:13:47,040 --> 00:13:54,240
and once it's finished basically it

00:13:50,880 --> 00:13:55,199
terminates and what you want to find out

00:13:54,240 --> 00:13:57,680
though is

00:13:55,199 --> 00:13:59,120
like how does that cancellation signal

00:13:57,680 --> 00:14:02,880
that we sent to the server

00:13:59,120 --> 00:14:06,079
affect the execution of the server so

00:14:02,880 --> 00:14:08,160
if we take a look at service a

00:14:06,079 --> 00:14:10,399
one of the services we were calling and

00:14:08,160 --> 00:14:11,279
if our service is implemented using co

00:14:10,399 --> 00:14:12,639
routines

00:14:11,279 --> 00:14:15,040
then the core routine scope of our

00:14:12,639 --> 00:14:18,320
method handler is actually canceled

00:14:15,040 --> 00:14:21,440
and the flow will match

00:14:18,320 --> 00:14:24,560
what was done in uh in the client side

00:14:21,440 --> 00:14:25,440
essentially the cancellation will

00:14:24,560 --> 00:14:27,519
propagate to

00:14:25,440 --> 00:14:28,560
all of the calls being made to other

00:14:27,519 --> 00:14:30,320
resources

00:14:28,560 --> 00:14:32,240
and that cancellation will actually go

00:14:30,320 --> 00:14:34,880
all the way down the call graph

00:14:32,240 --> 00:14:35,839
um if there are other services that are

00:14:34,880 --> 00:14:37,600
implementing the

00:14:35,839 --> 00:14:39,040
the co-routines or at least hooked into

00:14:37,600 --> 00:14:41,199
the cancellation uh

00:14:39,040 --> 00:14:43,360
hook or the cancellation callback for

00:14:41,199 --> 00:14:44,880
the uh service calls

00:14:43,360 --> 00:14:46,480
so this is a cooperative cancellation

00:14:44,880 --> 00:14:48,240
across network boundaries

00:14:46,480 --> 00:14:50,480
and it helps prevent our services from

00:14:48,240 --> 00:14:54,399
from performing unnecessary operations

00:14:50,480 --> 00:14:56,160
and wasting resources but it's not

00:14:54,399 --> 00:14:58,320
something that it's not a behavior that

00:14:56,160 --> 00:14:59,199
we always want it's there are times

00:14:58,320 --> 00:15:01,279
where we want to

00:14:59,199 --> 00:15:02,399
opt out of consolation there are times

00:15:01,279 --> 00:15:05,600
where we want to

00:15:02,399 --> 00:15:06,000
basically ensure that whatever method or

00:15:05,600 --> 00:15:08,320
or

00:15:06,000 --> 00:15:10,079
logic that we're running that we either

00:15:08,320 --> 00:15:11,519
complete it successfully or that we wrap

00:15:10,079 --> 00:15:12,639
it in some kind of transaction and make

00:15:11,519 --> 00:15:15,279
sure we roll back

00:15:12,639 --> 00:15:15,839
there's hundreds of different uh cases

00:15:15,279 --> 00:15:17,519
where

00:15:15,839 --> 00:15:20,639
we actually don't want to terminate even

00:15:17,519 --> 00:15:23,680
though the client has finished something

00:15:20,639 --> 00:15:26,560
and that's very easy to

00:15:23,680 --> 00:15:27,760
that that's very easy to implement um

00:15:26,560 --> 00:15:29,519
there are plenty of

00:15:27,760 --> 00:15:31,120
ways and options on how you can

00:15:29,519 --> 00:15:33,519
implement like

00:15:31,120 --> 00:15:34,480
opting out of uh cooperative

00:15:33,519 --> 00:15:37,360
cancellation

00:15:34,480 --> 00:15:38,839
um the most the simplest option though

00:15:37,360 --> 00:15:40,639
is just wrapping your method

00:15:38,839 --> 00:15:42,720
implementation with

00:15:40,639 --> 00:15:44,160
with context non-cancelable and still

00:15:42,720 --> 00:15:46,880
perform your uh

00:15:44,160 --> 00:15:47,440
your logic and what this will do is just

00:15:46,880 --> 00:15:51,120
protect

00:15:47,440 --> 00:15:54,160
your that particular block of code from

00:15:51,120 --> 00:15:58,079
any receiving any signals that might

00:15:54,160 --> 00:15:58,079
try to cancel its execution

00:15:59,040 --> 00:16:06,240
so we've gone ahead and looked at

00:16:03,199 --> 00:16:08,320
the apis that are available the

00:16:06,240 --> 00:16:09,279
differences in those apis we've looked

00:16:08,320 --> 00:16:12,079
at

00:16:09,279 --> 00:16:14,240
how co-routines make our services better

00:16:12,079 --> 00:16:16,320
and we've looked at

00:16:14,240 --> 00:16:17,600
how they make our implementations more

00:16:16,320 --> 00:16:19,519
concise

00:16:17,600 --> 00:16:20,959
but that's not all that we have to

00:16:19,519 --> 00:16:22,959
really look forward to when it comes to

00:16:20,959 --> 00:16:26,639
this ecosystem

00:16:22,959 --> 00:16:29,120
and what's really exciting is the future

00:16:26,639 --> 00:16:29,759
the google grpc kotlin implementation is

00:16:29,120 --> 00:16:31,040
still new

00:16:29,759 --> 00:16:33,360
but it's already gaining a lot of

00:16:31,040 --> 00:16:34,560
traction and as optimizations and

00:16:33,360 --> 00:16:36,480
improvements are made

00:16:34,560 --> 00:16:38,880
it'll no doubt solidify kotlin as a

00:16:36,480 --> 00:16:40,880
first class grpc citizen

00:16:38,880 --> 00:16:42,959
separately there's exciting work being

00:16:40,880 --> 00:16:43,759
done to improve the protobuf message

00:16:42,959 --> 00:16:45,600
support

00:16:43,759 --> 00:16:47,360
so that we can get native first-class

00:16:45,600 --> 00:16:49,120
features of kotlin like

00:16:47,360 --> 00:16:51,120
data classes when we're building out our

00:16:49,120 --> 00:16:55,360
our messages

00:16:51,120 --> 00:17:00,079
um and thinking in the long term

00:16:55,360 --> 00:17:02,639
the the one feature or the one

00:17:00,079 --> 00:17:03,519
like thing that keeps coming up in the

00:17:02,639 --> 00:17:06,799
community

00:17:03,519 --> 00:17:08,480
is multi-platform grpc and what that

00:17:06,799 --> 00:17:11,600
means is that if we

00:17:08,480 --> 00:17:12,799
can work to build a multi-platform grpc

00:17:11,600 --> 00:17:15,839
implementation

00:17:12,799 --> 00:17:18,880
then we're able to use

00:17:15,839 --> 00:17:19,919
and share our grpc business logic across

00:17:18,880 --> 00:17:23,199
our platforms

00:17:19,919 --> 00:17:26,480
even more specifically ios and android

00:17:23,199 --> 00:17:28,559
letting us share that code letting us

00:17:26,480 --> 00:17:29,679
centralize it right at once run

00:17:28,559 --> 00:17:33,600
everywhere

00:17:29,679 --> 00:17:35,440
and actually uh minimize

00:17:33,600 --> 00:17:37,440
the work being done by teams that have

00:17:35,440 --> 00:17:41,520
to support multiple platforms

00:17:37,440 --> 00:17:43,200
um this is something that's

00:17:41,520 --> 00:17:44,720
been talked a lot about but there hasn't

00:17:43,200 --> 00:17:47,280
been a lot of

00:17:44,720 --> 00:17:49,200
um work in that field just because of

00:17:47,280 --> 00:17:52,720
the fact that grpc collin

00:17:49,200 --> 00:17:54,799
uh in general is still so young but

00:17:52,720 --> 00:17:56,400
there are implementations specifically

00:17:54,799 --> 00:17:57,280
square wire which is built from the

00:17:56,400 --> 00:18:00,000
ground up

00:17:57,280 --> 00:18:01,120
on kotlin multi-platform that have the

00:18:00,000 --> 00:18:04,799
potential to

00:18:01,120 --> 00:18:07,840
fill this niche in the future um

00:18:04,799 --> 00:18:11,280
so going over all of that it's uh

00:18:07,840 --> 00:18:14,640
it's easy to see how we have not just

00:18:11,280 --> 00:18:18,160
evolved but provided an api that

00:18:14,640 --> 00:18:22,080
is covered first class code routines api

00:18:18,160 --> 00:18:24,720
first class provided by the actual

00:18:22,080 --> 00:18:25,840
grpc team with all the exciting things

00:18:24,720 --> 00:18:29,520
coming

00:18:25,840 --> 00:18:31,840
it's easy to see how kotlin and grpc

00:18:29,520 --> 00:18:33,360
are really going to start growing much

00:18:31,840 --> 00:18:34,400
faster now than they've done in previous

00:18:33,360 --> 00:18:36,559
years

00:18:34,400 --> 00:18:37,840
i thank you all for taking the time to

00:18:36,559 --> 00:18:40,400
watch my talk

00:18:37,840 --> 00:18:42,559
and um i'm going to leave it up for

00:18:40,400 --> 00:18:43,919
questions and answers now on anything

00:18:42,559 --> 00:18:47,520
related to

00:18:43,919 --> 00:18:48,799
either the api designs or just

00:18:47,520 --> 00:18:54,480
implementations or cover teams in

00:18:48,799 --> 00:18:54,480

YouTube URL: https://www.youtube.com/watch?v=SfmdAA2kwWI


