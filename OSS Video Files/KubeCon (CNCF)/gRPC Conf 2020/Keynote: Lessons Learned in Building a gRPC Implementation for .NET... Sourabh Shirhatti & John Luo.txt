Title: Keynote: Lessons Learned in Building a gRPC Implementation for .NET... Sourabh Shirhatti & John Luo
Publication date: 2020-08-01
Playlist: gRPC Conf 2020
Description: 
	Keynote: Lessons Learned in Building a gRPC Implementation for .NET Core - Sourabh Shirhatti, Senior Program Manager & John Luo, Software Engineer, Microsoft 

John Luo and Sourabh Shirhatti are part of the ASP.NET team at Microsoft working on the .NET Core implementation of gRPC. In this talk, they'll cover their experience in building a new gRPC implementation. They'll start by covering the design and limitations imposed by the existing .NET gRPC library and how the library attempts to address these concerns. As part of this deep dive, they'll also cover some of the design decisions that made in designing an opinionated framework and showcase the productivity and performance benefits introduced by the new library.
Captions: 
	00:00:00,000 --> 00:00:05,040
hey folks my name is saurabh sidharthi

00:00:02,399 --> 00:00:07,440
i'm here with my co-presenter john luo

00:00:05,040 --> 00:00:09,519
and we're here to speak to you about

00:00:07,440 --> 00:00:10,880
lessons learned in building a grpc

00:00:09,519 --> 00:00:13,120
implementation for

00:00:10,880 --> 00:00:13,120
net

00:00:13,920 --> 00:00:20,320
just to get started john and i are

00:00:17,760 --> 00:00:23,279
members work in microsoft and we work on

00:00:20,320 --> 00:00:25,519
the.net application frameworks team

00:00:23,279 --> 00:00:28,240
at microsoft our team maintains the web

00:00:25,519 --> 00:00:29,760
framework asp.net core

00:00:28,240 --> 00:00:32,079
as part of the web framework we also

00:00:29,760 --> 00:00:34,800
ship an http application server

00:00:32,079 --> 00:00:35,200
called kestrel and in addition to that

00:00:34,800 --> 00:00:38,079
we

00:00:35,200 --> 00:00:39,600
ship a set of uh libraries for common

00:00:38,079 --> 00:00:41,680
cross-cutting concerns like

00:00:39,600 --> 00:00:43,280
logging and configuration these

00:00:41,680 --> 00:00:45,280
libraries are used

00:00:43,280 --> 00:00:46,800
as part of the asp.net library but they

00:00:45,280 --> 00:00:49,840
also serve a lot of

00:00:46,800 --> 00:00:50,960
non-web concerns and in addition to our

00:00:49,840 --> 00:00:53,680
role at microsoft

00:00:50,960 --> 00:00:54,480
we're contributors to jrpc.net which is

00:00:53,680 --> 00:00:57,600
a new

00:00:54,480 --> 00:01:01,840
jrpc implementation for dotnet

00:00:57,600 --> 00:01:04,960
so let's start out with what is.net

00:01:01,840 --> 00:01:08,240
net is a free cross-platform open source

00:01:04,960 --> 00:01:11,119
developer platform so dotnet encompasses

00:01:08,240 --> 00:01:11,840
a runtime it's a vm based runtime as

00:01:11,119 --> 00:01:14,320
well as

00:01:11,840 --> 00:01:15,600
a set of languages and compilers so

00:01:14,320 --> 00:01:18,240
today we have

00:01:15,600 --> 00:01:19,360
c sharp v b and f sharp that comprise

00:01:18,240 --> 00:01:20,799
the languages

00:01:19,360 --> 00:01:23,200
and then obviously with the associated

00:01:20,799 --> 00:01:24,240
compilers and in addition to the runtime

00:01:23,200 --> 00:01:26,880
and languages

00:01:24,240 --> 00:01:28,159
we have a set of rich standard libraries

00:01:26,880 --> 00:01:30,880
standard libraries you know

00:01:28,159 --> 00:01:33,280
solve concerns like file io right into

00:01:30,880 --> 00:01:35,439
the console make an http request

00:01:33,280 --> 00:01:37,600
so when we say net we're really

00:01:35,439 --> 00:01:40,560
referring to that collective

00:01:37,600 --> 00:01:42,640
and grpc.net the library that we're here

00:01:40,560 --> 00:01:47,200
to talk to you about today

00:01:42,640 --> 00:01:48,320
is a grpc implementation 4.net

00:01:47,200 --> 00:01:51,520
and if we were to get a little more

00:01:48,320 --> 00:01:54,479
specific it builds upon the

00:01:51,520 --> 00:01:55,920
http transport and the protocol parsing

00:01:54,479 --> 00:01:58,479
layout.net

00:01:55,920 --> 00:01:59,200
so if we look at the diagram to our

00:01:58,479 --> 00:02:02,159
right

00:01:59,200 --> 00:02:03,119
it it handles the dispatching of

00:02:02,159 --> 00:02:05,360
requests

00:02:03,119 --> 00:02:08,479
from the server layer to user author

00:02:05,360 --> 00:02:09,280
grpc service implementations so this is

00:02:08,479 --> 00:02:11,280
an ex

00:02:09,280 --> 00:02:12,760
this is an alternative implementation to

00:02:11,280 --> 00:02:16,560
the existing

00:02:12,760 --> 00:02:19,520
jrpc.core library this library

00:02:16,560 --> 00:02:20,720
uh exists side by side with the grpc

00:02:19,520 --> 00:02:23,040
core library

00:02:20,720 --> 00:02:25,920
and each has its own advantages instead

00:02:23,040 --> 00:02:28,000
of available features and integrations

00:02:25,920 --> 00:02:29,360
uh fortunately one of the things we've

00:02:28,000 --> 00:02:32,000
been able to achieve is

00:02:29,360 --> 00:02:33,360
share the same api for invoking and

00:02:32,000 --> 00:02:35,440
handling rpcs

00:02:33,360 --> 00:02:37,040
so we limit the lock-in and really the

00:02:35,440 --> 00:02:39,840
idea is to let users

00:02:37,040 --> 00:02:41,280
pick whatever implementations work best

00:02:39,840 --> 00:02:43,680
for them

00:02:41,280 --> 00:02:45,040
so now that i've spent a little time

00:02:43,680 --> 00:02:48,080
talking about

00:02:45,040 --> 00:02:51,040
what jrpc.net is i thought it'd be

00:02:48,080 --> 00:02:51,920
best to show you a demo of grpc.net in

00:02:51,040 --> 00:02:53,920
action

00:02:51,920 --> 00:02:55,360
and then after we look at the demo we

00:02:53,920 --> 00:02:57,040
could go into

00:02:55,360 --> 00:02:59,040
lessons we learned in building this

00:02:57,040 --> 00:03:02,879
implementation

00:02:59,040 --> 00:03:05,920
so right now i have my uh i'm using

00:03:02,879 --> 00:03:06,720
a project called tie it's an open source

00:03:05,920 --> 00:03:08,640
tool for

00:03:06,720 --> 00:03:10,560
orchestrating and running multiple.net

00:03:08,640 --> 00:03:12,000
applications so i've gone ahead and run

00:03:10,560 --> 00:03:14,239
my application if i

00:03:12,000 --> 00:03:15,920
head over here you can see my tie

00:03:14,239 --> 00:03:19,040
dashboard

00:03:15,920 --> 00:03:21,360
so what i'm going to show you today is

00:03:19,040 --> 00:03:22,560
uh john and i have built the game let me

00:03:21,360 --> 00:03:24,720
just go ahead and open

00:03:22,560 --> 00:03:26,879
two instances of this side by side so

00:03:24,720 --> 00:03:28,480
this is a trivia application

00:03:26,879 --> 00:03:30,480
all right so what i'm going to do is on

00:03:28,480 --> 00:03:33,440
the left i'm going to go ahead

00:03:30,480 --> 00:03:34,239
join this game and play as alice right

00:03:33,440 --> 00:03:36,480
and you can see

00:03:34,239 --> 00:03:37,920
when i hit start we make a grpc call and

00:03:36,480 --> 00:03:38,959
now we're waiting for other players to

00:03:37,920 --> 00:03:41,519
join before

00:03:38,959 --> 00:03:42,080
the game commences on the terminal

00:03:41,519 --> 00:03:43,680
window

00:03:42,080 --> 00:03:45,360
on my browser window on the right i'm

00:03:43,680 --> 00:03:48,000
going to join this game as bob

00:03:45,360 --> 00:03:50,080
and now once both players have joined

00:03:48,000 --> 00:03:53,040
i'm using a bi-directional

00:03:50,080 --> 00:03:53,680
uh streaming call and both players are

00:03:53,040 --> 00:03:57,120
streamed

00:03:53,680 --> 00:03:58,879
questions as i go ahead and

00:03:57,120 --> 00:04:00,480
answer the question as one of the

00:03:58,879 --> 00:04:04,159
participants in the game

00:04:00,480 --> 00:04:06,720
let me go ahead and answer let's say

00:04:04,159 --> 00:04:07,599
we let's answer it correctly for both

00:04:06,720 --> 00:04:09,599
alice

00:04:07,599 --> 00:04:10,799
and let's say bob in this case you can

00:04:09,599 --> 00:04:12,560
see as soon as

00:04:10,799 --> 00:04:14,640
both players have done answering i'm

00:04:12,560 --> 00:04:17,120
getting more calls uh

00:04:14,640 --> 00:04:18,239
obviously you'd be curious know how this

00:04:17,120 --> 00:04:19,919
is your pc

00:04:18,239 --> 00:04:22,800
so i could the other thing i could show

00:04:19,919 --> 00:04:26,000
you is i could hop over here

00:04:22,800 --> 00:04:27,120
uh into my actual server and i can show

00:04:26,000 --> 00:04:29,120
you like these are

00:04:27,120 --> 00:04:30,320
metrics being collected from the server

00:04:29,120 --> 00:04:32,240
at this point

00:04:30,320 --> 00:04:33,440
uh like obviously these numbers are

00:04:32,240 --> 00:04:35,199
static right now but you can see there

00:04:33,440 --> 00:04:36,880
are a couple of concurrent calls

00:04:35,199 --> 00:04:38,800
these are the two bi-directional

00:04:36,880 --> 00:04:39,360
streaming calls for both players in the

00:04:38,800 --> 00:04:40,960
game

00:04:39,360 --> 00:04:43,440
you can also see messages sent and

00:04:40,960 --> 00:04:44,800
received and now for example let's say i

00:04:43,440 --> 00:04:48,240
answered this question

00:04:44,800 --> 00:04:50,560
on behalf of bob you can see that

00:04:48,240 --> 00:04:51,280
as soon as i answer this question you

00:04:50,560 --> 00:04:54,800
see that the

00:04:51,280 --> 00:04:56,000
number of messages uh received have been

00:04:54,800 --> 00:04:58,080
updated as well as the server

00:04:56,000 --> 00:04:59,280
replied with an updated message and i

00:04:58,080 --> 00:05:02,080
can go ahead here

00:04:59,280 --> 00:05:03,440
uh finish playing as alice and then you

00:05:02,080 --> 00:05:04,880
know let's say

00:05:03,440 --> 00:05:07,199
finish this game and you can see i

00:05:04,880 --> 00:05:09,440
received the score

00:05:07,199 --> 00:05:11,199
so let me go ahead and close this i

00:05:09,440 --> 00:05:11,680
obviously at this point have told you

00:05:11,199 --> 00:05:14,080
that

00:05:11,680 --> 00:05:15,280
i've used your pc but if i could prove

00:05:14,080 --> 00:05:16,720
it out and you know

00:05:15,280 --> 00:05:19,199
show it to you in a better way that

00:05:16,720 --> 00:05:19,840
would be nice fortunately in this case i

00:05:19,199 --> 00:05:21,280
can

00:05:19,840 --> 00:05:22,800
so the other thing i've done is in

00:05:21,280 --> 00:05:24,240
addition to setting up both the server

00:05:22,800 --> 00:05:25,039
and the client if i help back over to my

00:05:24,240 --> 00:05:28,240
dashboard

00:05:25,039 --> 00:05:31,600
is i actually had an instance of zipkin

00:05:28,240 --> 00:05:33,360
running and zipkin has both uh

00:05:31,600 --> 00:05:34,960
both the clients as well as the server

00:05:33,360 --> 00:05:36,080
instance are sending their distributed

00:05:34,960 --> 00:05:39,039
traces to zipkin

00:05:36,080 --> 00:05:39,840
so i go over here hit the search button

00:05:39,039 --> 00:05:42,000
you can see

00:05:39,840 --> 00:05:43,120
we're able to see distributed traces for

00:05:42,000 --> 00:05:44,880
the game we just played

00:05:43,120 --> 00:05:47,039
i'm going to click on one of these

00:05:44,880 --> 00:05:50,000
distributed traces which has

00:05:47,039 --> 00:05:52,080
uh the client is the root and we're able

00:05:50,000 --> 00:05:54,720
to see this is the game we just played

00:05:52,080 --> 00:05:56,800
so we made a grpc call you can see it's

00:05:54,720 --> 00:05:58,000
an http post and you can see the grpc

00:05:56,800 --> 00:06:00,479
status code

00:05:58,000 --> 00:06:01,039
uh so this was you know the start game

00:06:00,479 --> 00:06:03,919
call

00:06:01,039 --> 00:06:04,639
and when both clients when both players

00:06:03,919 --> 00:06:06,400
were ready

00:06:04,639 --> 00:06:08,960
we started a streaming call you can see

00:06:06,400 --> 00:06:11,199
this went on for a long duration

00:06:08,960 --> 00:06:12,720
you can also see the path and status

00:06:11,199 --> 00:06:15,840
code

00:06:12,720 --> 00:06:18,240
uh i hope you enjoyed the demo but

00:06:15,840 --> 00:06:19,520
with that i'm gonna hand it over to my

00:06:18,240 --> 00:06:21,039
co-presenter john

00:06:19,520 --> 00:06:23,199
he's actually going to talk to you about

00:06:21,039 --> 00:06:25,440
some of the lessons we learned in

00:06:23,199 --> 00:06:28,000
building jpc.net as well as building

00:06:25,440 --> 00:06:28,000
this demo

00:06:30,080 --> 00:06:33,680
okay thanks so let's get started with

00:06:32,639 --> 00:06:36,759
the first lesson

00:06:33,680 --> 00:06:38,319
which is to take advantage of the

00:06:36,759 --> 00:06:39,440
platformprimitivesand.net whenever

00:06:38,319 --> 00:06:41,840
possible

00:06:39,440 --> 00:06:43,440
so as we worked on developing the new

00:06:41,840 --> 00:06:45,199
grpc library

00:06:43,440 --> 00:06:46,720
we noticed the theme in some of the

00:06:45,199 --> 00:06:49,680
concerns that users ran

00:06:46,720 --> 00:06:51,120
into for example folks mentioned that it

00:06:49,680 --> 00:06:54,800
wasn't trivial to set up

00:06:51,120 --> 00:06:56,880
tls for hbs it was also noted that you

00:06:54,800 --> 00:06:57,360
had to write additional instrumentation

00:06:56,880 --> 00:06:59,840
code

00:06:57,360 --> 00:07:00,720
in order to set up distributed tracing

00:06:59,840 --> 00:07:03,039
and finally

00:07:00,720 --> 00:07:04,240
it's difficult to obtain support on new

00:07:03,039 --> 00:07:06,840
architectures

00:07:04,240 --> 00:07:08,240
it turns out by leveraging the

00:07:06,840 --> 00:07:09,919
platformprimitivesin.net

00:07:08,240 --> 00:07:12,960
we can get the solution to these

00:07:09,919 --> 00:07:12,960
problems for free

00:07:13,199 --> 00:07:18,880
so let's jump into a concrete example

00:07:16,240 --> 00:07:21,039
in.net we made a conscious decision to

00:07:18,880 --> 00:07:21,759
rely on the native crypto stack of the

00:07:21,039 --> 00:07:24,080
os

00:07:21,759 --> 00:07:25,759
to handle our tls setup in our

00:07:24,080 --> 00:07:28,000
networking primitives

00:07:25,759 --> 00:07:28,880
this means that on windows we will be

00:07:28,000 --> 00:07:31,599
relying on

00:07:28,880 --> 00:07:32,080
s channel and on mac os we will be using

00:07:31,599 --> 00:07:35,599
secure

00:07:32,080 --> 00:07:38,560
transport the benefit here is that is to

00:07:35,599 --> 00:07:40,479
configure an hvs endpoint the app

00:07:38,560 --> 00:07:41,440
doesn't have to load a private key in

00:07:40,479 --> 00:07:43,520
memory

00:07:41,440 --> 00:07:45,759
it can rely on the cert being present in

00:07:43,520 --> 00:07:47,599
the certificate store

00:07:45,759 --> 00:07:50,080
on the client side we don't have to

00:07:47,599 --> 00:07:52,319
specify the public key of the hbes

00:07:50,080 --> 00:07:53,759
endpoint we can rely on the public key

00:07:52,319 --> 00:07:55,599
being present

00:07:53,759 --> 00:07:57,199
in the list of trusted routes in the

00:07:55,599 --> 00:08:00,319
certificate store

00:07:57,199 --> 00:08:03,360
as an additional bonus on

00:08:00,319 --> 00:08:05,520
uh we also get support for hsms and

00:08:03,360 --> 00:08:07,440
secure enclaves for free

00:08:05,520 --> 00:08:08,720
on the flip side though there are

00:08:07,440 --> 00:08:11,120
trade-offs with using

00:08:08,720 --> 00:08:13,120
the.net platform primitives namely we

00:08:11,120 --> 00:08:14,479
are tied to the support provided by the

00:08:13,120 --> 00:08:17,520
native crypto stack

00:08:14,479 --> 00:08:20,319
specifically secure transport on mac os

00:08:17,520 --> 00:08:23,360
doesn't support servers ilpn and hence

00:08:20,319 --> 00:08:24,400
no support for hdb as grpc endpoints on

00:08:23,360 --> 00:08:27,280
mac os

00:08:24,400 --> 00:08:28,960
when you use the grpc.net library so

00:08:27,280 --> 00:08:33,360
there's definitely a trade-off here as

00:08:28,960 --> 00:08:33,360
compared to the grpc dot core library

00:08:33,760 --> 00:08:38,399
let's take a quick look at how clients

00:08:35,760 --> 00:08:42,240
are configured in code

00:08:38,399 --> 00:08:45,040
as you can see in the jrpc core

00:08:42,240 --> 00:08:46,080
you you'll have to explicitly specify

00:08:45,040 --> 00:08:49,360
the public key

00:08:46,080 --> 00:08:52,399
of your endpoint you're connecting to

00:08:49,360 --> 00:08:56,720
in this case it's encapsulated uh

00:08:52,399 --> 00:09:00,560
via the pen file

00:08:56,720 --> 00:09:03,120
then you use that to construct a channel

00:09:00,560 --> 00:09:06,480
which is then used by the grpc client

00:09:03,120 --> 00:09:09,120
in contrast assuming the endpoint has a

00:09:06,480 --> 00:09:10,640
certificate issued by trusted root no

00:09:09,120 --> 00:09:11,519
additional configuration will be

00:09:10,640 --> 00:09:15,200
necessary

00:09:11,519 --> 00:09:15,200
with jrpc.net

00:09:16,640 --> 00:09:20,080
another common request we have heard is

00:09:18,640 --> 00:09:23,279
how do you configure

00:09:20,080 --> 00:09:25,200
monitoring of your grpc services

00:09:23,279 --> 00:09:27,200
for example maybe i would like to track

00:09:25,200 --> 00:09:28,000
my request through the different grpc

00:09:27,200 --> 00:09:30,320
endpoints

00:09:28,000 --> 00:09:32,240
since it's rare rarely the case that

00:09:30,320 --> 00:09:33,680
only one service is needed to serve a

00:09:32,240 --> 00:09:36,800
particular request

00:09:33,680 --> 00:09:38,959
this also includes figuring out which

00:09:36,800 --> 00:09:40,080
services are being called how long

00:09:38,959 --> 00:09:42,240
they're taking

00:09:40,080 --> 00:09:43,440
and what status or results they are

00:09:42,240 --> 00:09:45,360
returning

00:09:43,440 --> 00:09:46,480
with this in mind we leverage the

00:09:45,360 --> 00:09:48,839
distributing

00:09:46,480 --> 00:09:51,360
tracing primitives in.net in the

00:09:48,839 --> 00:09:53,279
grpc.net library itself

00:09:51,360 --> 00:09:55,440
this means that we are emitting trace

00:09:53,279 --> 00:09:57,600
information by default and no additional

00:09:55,440 --> 00:10:00,880
instrumentation code is necessary

00:09:57,600 --> 00:10:02,640
in the implementation of grpc services

00:10:00,880 --> 00:10:05,600
to complete the distributed tracing

00:10:02,640 --> 00:10:06,880
story the trace information we emit can

00:10:05,600 --> 00:10:09,279
then be egressed

00:10:06,880 --> 00:10:11,360
via distributed tracing libraries

00:10:09,279 --> 00:10:15,200
including open telemetry

00:10:11,360 --> 00:10:16,160
collectors so for example in the demo we

00:10:15,200 --> 00:10:18,160
showed earlier

00:10:16,160 --> 00:10:19,200
we use zipkin to collect and visualize

00:10:18,160 --> 00:10:21,040
our traces

00:10:19,200 --> 00:10:23,279
here we can see the traces that were

00:10:21,040 --> 00:10:25,760
collected for two trivia sessions

00:10:23,279 --> 00:10:26,480
each of which consisted of three grpc

00:10:25,760 --> 00:10:29,440
calls

00:10:26,480 --> 00:10:30,959
we can also see some of the metadata of

00:10:29,440 --> 00:10:33,200
these calls such as

00:10:30,959 --> 00:10:34,800
the status codes and the specific urls

00:10:33,200 --> 00:10:37,279
where the grpc call

00:10:34,800 --> 00:10:37,279
was made

00:10:38,160 --> 00:10:42,399
so the lesson here is that by leveraging

00:10:40,240 --> 00:10:43,920
the platform primitives provided by the

00:10:42,399 --> 00:10:44,880
standard library for the language

00:10:43,920 --> 00:10:47,680
ecosystem

00:10:44,880 --> 00:10:48,640
we benefit from the improvements in.net

00:10:47,680 --> 00:10:50,640
for free

00:10:48,640 --> 00:10:53,360
we saw how this simplifies configuring

00:10:50,640 --> 00:10:55,760
hvs and distributed tracing

00:10:53,360 --> 00:10:56,560
just to list a few more benefits we also

00:10:55,760 --> 00:10:58,720
get the

00:10:56,560 --> 00:11:00,399
benefit of performance improvements in

00:10:58,720 --> 00:11:02,640
the hp server and hp

00:11:00,399 --> 00:11:04,079
client which we'll discuss in more

00:11:02,640 --> 00:11:06,720
detail in a later

00:11:04,079 --> 00:11:08,959
section another benefit is support for

00:11:06,720 --> 00:11:11,279
additional architectures

00:11:08,959 --> 00:11:12,320
will get them as they're added for

00:11:11,279 --> 00:11:14,720
example we have

00:11:12,320 --> 00:11:16,640
recently seen an uptick in interest for

00:11:14,720 --> 00:11:21,120
supporting arm processors

00:11:16,640 --> 00:11:24,560
which grpc.net get for free by contrast

00:11:21,120 --> 00:11:26,240
because grpc.cor uses native components

00:11:24,560 --> 00:11:28,640
support for additional architectures

00:11:26,240 --> 00:11:31,600
will require more significant work

00:11:28,640 --> 00:11:33,680
of course there are plenty more benefits

00:11:31,600 --> 00:11:35,600
that we can't go into detail here such

00:11:33,680 --> 00:11:38,480
as support for hardware intrinsics

00:11:35,600 --> 00:11:40,720
or additional metrics for socket layer

00:11:38,480 --> 00:11:43,440
but the overall learning here is that

00:11:40,720 --> 00:11:44,000
by relying on the platform primitives we

00:11:43,440 --> 00:11:46,079
are not

00:11:44,000 --> 00:11:47,600
isolated on an island separate from the

00:11:46,079 --> 00:11:49,839
rest of the platform

00:11:47,600 --> 00:11:51,920
instead we can take advantage of the

00:11:49,839 --> 00:11:54,959
improvements in the platform for free

00:11:51,920 --> 00:11:55,279
and get access to a wider ecosystem and

00:11:54,959 --> 00:11:59,120
now

00:11:55,279 --> 00:12:02,240
back to you sarah thank you john

00:11:59,120 --> 00:12:03,680
uh what i want to do now is speak to the

00:12:02,240 --> 00:12:06,000
second lesson we learned

00:12:03,680 --> 00:12:07,120
this actually builds upon where john

00:12:06,000 --> 00:12:08,959
just spoke to

00:12:07,120 --> 00:12:10,000
so the other key lesson that we learned

00:12:08,959 --> 00:12:11,120
and we learned this while building

00:12:10,000 --> 00:12:12,880
asp.net core

00:12:11,120 --> 00:12:14,639
we were able to equally apply it while

00:12:12,880 --> 00:12:16,880
building jrpc.net

00:12:14,639 --> 00:12:18,079
is sharing abstractions makes everyone

00:12:16,880 --> 00:12:20,000
more productive

00:12:18,079 --> 00:12:22,160
let's take a concrete look at what is

00:12:20,000 --> 00:12:25,279
meant by this

00:12:22,160 --> 00:12:26,320
so the central hub of any jrpc.net

00:12:25,279 --> 00:12:29,600
application

00:12:26,320 --> 00:12:31,440
is the host the so the core of a hosted

00:12:29,600 --> 00:12:32,800
app is just a set of services that are

00:12:31,440 --> 00:12:35,200
started and stopped

00:12:32,800 --> 00:12:37,200
with the lifetime of your application

00:12:35,200 --> 00:12:39,040
one such example would be your http

00:12:37,200 --> 00:12:41,760
application server

00:12:39,040 --> 00:12:43,360
but what the host does in addition to

00:12:41,760 --> 00:12:45,040
managing service lifetime

00:12:43,360 --> 00:12:46,800
it allows you to configure it and

00:12:45,040 --> 00:12:48,399
register various components via

00:12:46,800 --> 00:12:51,040
dependency injection

00:12:48,399 --> 00:12:52,000
so in general everything is pluggable

00:12:51,040 --> 00:12:55,200
but you cannot have

00:12:52,000 --> 00:12:58,320
a host without di without logging in

00:12:55,200 --> 00:12:58,320
without configuration

00:12:58,639 --> 00:13:03,440
and while we're unopinionated about what

00:13:01,920 --> 00:13:06,000
libraries you use to solve these

00:13:03,440 --> 00:13:08,240
concerns we do build upon the

00:13:06,000 --> 00:13:11,120
common abstractions provided by the

00:13:08,240 --> 00:13:13,040
microsoft dot extensions libraries

00:13:11,120 --> 00:13:15,120
and since these are wildly popular in

00:13:13,040 --> 00:13:18,560
the dart net ecosystem

00:13:15,120 --> 00:13:21,040
you get access to a rich ecosystem of

00:13:18,560 --> 00:13:23,600
various providers so if we take a

00:13:21,040 --> 00:13:25,360
example if we look at logging

00:13:23,600 --> 00:13:26,959
both of the most popular logging

00:13:25,360 --> 00:13:29,360
libraries in.net both

00:13:26,959 --> 00:13:30,800
satalog and analog build upon these

00:13:29,360 --> 00:13:34,000
common abstractions

00:13:30,800 --> 00:13:36,320
so in the grpc hosted app model you're

00:13:34,000 --> 00:13:38,320
able to make use of these libraries

00:13:36,320 --> 00:13:40,000
and in addition to the you know

00:13:38,320 --> 00:13:41,120
previously mentioned concerns we also

00:13:40,000 --> 00:13:44,000
have things like

00:13:41,120 --> 00:13:45,360
health checks file providers caching for

00:13:44,000 --> 00:13:46,800
all these things we can use the

00:13:45,360 --> 00:13:49,839
ecosystem of

00:13:46,800 --> 00:13:49,839
libraries available

00:13:50,480 --> 00:13:54,079
an another benefit that we get is that

00:13:53,519 --> 00:13:58,079
there are

00:13:54,079 --> 00:14:00,639
other libraries in the dot net ecosystem

00:13:58,079 --> 00:14:02,560
that also use the hosted app model

00:14:00,639 --> 00:14:04,480
so for example if you were building an

00:14:02,560 --> 00:14:07,600
http api

00:14:04,480 --> 00:14:10,160
you'd likely be using asp.net core

00:14:07,600 --> 00:14:12,079
or if you were building an application

00:14:10,160 --> 00:14:14,639
that used web sockets for some

00:14:12,079 --> 00:14:16,880
some real-time display of information

00:14:14,639 --> 00:14:19,360
you'd probably be using signalr

00:14:16,880 --> 00:14:20,160
and since both asp.net core and signal

00:14:19,360 --> 00:14:23,360
are

00:14:20,160 --> 00:14:27,120
used the same hosted app model

00:14:23,360 --> 00:14:29,199
you're able to share services such as

00:14:27,120 --> 00:14:30,480
like the server and its bindings

00:14:29,199 --> 00:14:33,199
or something like the logging

00:14:30,480 --> 00:14:36,320
infrastructure across both the grpc

00:14:33,199 --> 00:14:38,480
and a non-grpc endpoint and this is

00:14:36,320 --> 00:14:40,399
important because a common theme that we

00:14:38,480 --> 00:14:43,519
hear from users of our library

00:14:40,399 --> 00:14:44,399
is like hey i'm interested in using jrpc

00:14:43,519 --> 00:14:47,600
but i can't just

00:14:44,399 --> 00:14:50,240
wholesale move to grpc just yet

00:14:47,600 --> 00:14:51,120
i need to expose the same business logic

00:14:50,240 --> 00:14:54,320
via both

00:14:51,120 --> 00:14:58,079
uh like a legacy http json api

00:14:54,320 --> 00:15:00,800
as well as the grpc endpoint and

00:14:58,079 --> 00:15:02,000
the shared hosted app model makes it

00:15:00,800 --> 00:15:04,399
possible

00:15:02,000 --> 00:15:05,600
so let's jump over to a more concrete

00:15:04,399 --> 00:15:08,160
example

00:15:05,600 --> 00:15:08,639
what i had what i showed you earlier

00:15:08,160 --> 00:15:11,440
today

00:15:08,639 --> 00:15:12,000
was uh a client a trivia client

00:15:11,440 --> 00:15:15,040
application

00:15:12,000 --> 00:15:17,760
that communicates with a server

00:15:15,040 --> 00:15:19,839
using jrpc but let's say we wanted to

00:15:17,760 --> 00:15:22,639
expand the scope of this example

00:15:19,839 --> 00:15:23,680
and we also wanted to create a web

00:15:22,639 --> 00:15:26,880
dashboard

00:15:23,680 --> 00:15:29,519
that exposes the score service

00:15:26,880 --> 00:15:31,279
and is updated in real time while this

00:15:29,519 --> 00:15:32,240
might have otherwise been difficult to

00:15:31,279 --> 00:15:34,399
achieve

00:15:32,240 --> 00:15:36,240
since we use the same hosted app model

00:15:34,399 --> 00:15:38,720
we were able to share the

00:15:36,240 --> 00:15:40,240
the business domain logic that kept

00:15:38,720 --> 00:15:42,959
track of a player's score

00:15:40,240 --> 00:15:43,839
and exposed it both via a grpc endpoint

00:15:42,959 --> 00:15:46,399
as well as

00:15:43,839 --> 00:15:47,360
a websocket application so what i'm

00:15:46,399 --> 00:15:48,720
going to do is i'm actually going to

00:15:47,360 --> 00:15:50,959
hand it back to john

00:15:48,720 --> 00:15:51,839
who has an instance of this updated

00:15:50,959 --> 00:15:53,440
application

00:15:51,839 --> 00:15:56,079
and can show you what the scoreboard

00:15:53,440 --> 00:15:56,079
might look like

00:15:58,800 --> 00:16:03,120
all right thank you all right so here

00:16:01,759 --> 00:16:06,240
i'm going to show

00:16:03,120 --> 00:16:08,000
a demonstration again using the same app

00:16:06,240 --> 00:16:10,560
that

00:16:08,000 --> 00:16:11,519
syrup has shown before with a few small

00:16:10,560 --> 00:16:14,399
tweaks

00:16:11,519 --> 00:16:15,759
so first i'll again open up a connection

00:16:14,399 --> 00:16:17,839
to the client

00:16:15,759 --> 00:16:20,079
which again is how i would play the

00:16:17,839 --> 00:16:22,000
trivia game

00:16:20,079 --> 00:16:24,160
this is very similar to before except

00:16:22,000 --> 00:16:27,759
there's one tweak which is i'm going to

00:16:24,160 --> 00:16:30,560
only play this as a single player uh

00:16:27,759 --> 00:16:32,639
also again this is uh similar to before

00:16:30,560 --> 00:16:33,759
where the client is using grpc to

00:16:32,639 --> 00:16:36,560
communicate

00:16:33,759 --> 00:16:37,519
with the server backend another

00:16:36,560 --> 00:16:41,040
difference though

00:16:37,519 --> 00:16:42,959
is now i've added a signalr endpoint to

00:16:41,040 --> 00:16:44,000
the server so let me connect to that as

00:16:42,959 --> 00:16:47,199
well

00:16:44,000 --> 00:16:50,320
and open it over here what

00:16:47,199 --> 00:16:51,279
signalr is is essentially using web

00:16:50,320 --> 00:16:54,320
sockets

00:16:51,279 --> 00:16:54,880
uh behind the scenes to allow the server

00:16:54,320 --> 00:16:56,959
to

00:16:54,880 --> 00:16:57,920
give you updates on the score in real

00:16:56,959 --> 00:17:01,440
time

00:16:57,920 --> 00:17:05,679
so let's get started with playing

00:17:01,440 --> 00:17:07,919
so i will play as jeff and i am going to

00:17:05,679 --> 00:17:09,520
answer the question and as you can see

00:17:07,919 --> 00:17:11,679
as soon as the

00:17:09,520 --> 00:17:13,760
score is updated on the server is

00:17:11,679 --> 00:17:17,600
pushing that information

00:17:13,760 --> 00:17:20,240
to my signalr endpoint in real time

00:17:17,600 --> 00:17:21,439
and let go let me go ahead and finish

00:17:20,240 --> 00:17:24,319
the game

00:17:21,439 --> 00:17:25,839
building a grpc implementation is the

00:17:24,319 --> 00:17:27,679
only one that's not hard

00:17:25,839 --> 00:17:29,919
and as you can see the score has changed

00:17:27,679 --> 00:17:32,559
again so this really shows

00:17:29,919 --> 00:17:34,480
how it's possible for the same server to

00:17:32,559 --> 00:17:37,919
deal with multiple workloads

00:17:34,480 --> 00:17:40,720
both grpc and non-jrpc and in

00:17:37,919 --> 00:17:42,799
this case it would be a websocket

00:17:40,720 --> 00:17:45,200
workload

00:17:42,799 --> 00:17:46,720
so for the next lesson let's take a look

00:17:45,200 --> 00:17:49,600
at our journey to improve

00:17:46,720 --> 00:17:51,679
performance in grpc.net what we learned

00:17:49,600 --> 00:17:52,799
here was that while everyone cares about

00:17:51,679 --> 00:17:55,679
performance and get

00:17:52,799 --> 00:17:58,840
captivated by specific benchmarks it's

00:17:55,679 --> 00:18:00,080
important to measure what actually

00:17:58,840 --> 00:18:02,000
matters

00:18:00,080 --> 00:18:04,320
let's start by taking a look at some of

00:18:02,000 --> 00:18:06,640
our current performance numbers

00:18:04,320 --> 00:18:09,120
after learning to measure what matters

00:18:06,640 --> 00:18:11,520
we were able to make grpc.net a

00:18:09,120 --> 00:18:14,160
competitive stack with grpc.core

00:18:11,520 --> 00:18:16,000
and go implementations across a variety

00:18:14,160 --> 00:18:18,400
of traffic patterns

00:18:16,000 --> 00:18:19,039
as you can see with the diagram on the

00:18:18,400 --> 00:18:21,360
left

00:18:19,039 --> 00:18:24,320
we are seeing roughly the same server

00:18:21,360 --> 00:18:27,360
rps numbers between grpc.net

00:18:24,320 --> 00:18:30,080
which is displayed in dark blue and go

00:18:27,360 --> 00:18:32,720
which is displayed in green

00:18:30,080 --> 00:18:34,000
in terms of client performance again

00:18:32,720 --> 00:18:36,640
we're also

00:18:34,000 --> 00:18:37,760
competitive with grpc.core and go

00:18:36,640 --> 00:18:39,360
implementations

00:18:37,760 --> 00:18:41,360
though the results will vary more

00:18:39,360 --> 00:18:42,000
significantly depending on the traffic

00:18:41,360 --> 00:18:44,480
pattern you're

00:18:42,000 --> 00:18:46,080
measuring for note that these are

00:18:44,480 --> 00:18:47,200
numbers we are getting with the latest

00:18:46,080 --> 00:18:49,120
preview builds

00:18:47,200 --> 00:18:52,640
so they will continue to change as we

00:18:49,120 --> 00:18:54,720
work on performance improvements

00:18:52,640 --> 00:18:57,120
now let's take a look at uh take a step

00:18:54,720 --> 00:18:59,919
back and see how we got here

00:18:57,120 --> 00:19:01,200
given our background on the asp.net team

00:18:59,919 --> 00:19:03,200
we were familiar with

00:19:01,200 --> 00:19:05,080
optimizing server performance which

00:19:03,200 --> 00:19:07,039
motivated a lot of work for our

00:19:05,080 --> 00:19:09,200
upcoming.net 5.0 release

00:19:07,039 --> 00:19:11,039
to improve kestrel which is our http

00:19:09,200 --> 00:19:12,960
server in.net

00:19:11,039 --> 00:19:15,120
we started with this since we knew there

00:19:12,960 --> 00:19:18,799
were major gains in terms of

00:19:15,120 --> 00:19:20,799
optimizations in hb2 stack

00:19:18,799 --> 00:19:23,039
but as we continued our push for server

00:19:20,799 --> 00:19:25,679
performance we learned the lesson that

00:19:23,039 --> 00:19:27,919
in a micro service environment client

00:19:25,679 --> 00:19:29,280
performance matters as much as server

00:19:27,919 --> 00:19:32,160
performance

00:19:29,280 --> 00:19:33,440
to address this we started to invest in

00:19:32,160 --> 00:19:36,240
improving the http

00:19:33,440 --> 00:19:39,520
2 performance of http client which is

00:19:36,240 --> 00:19:41,919
what grpc.net client library is based on

00:19:39,520 --> 00:19:42,799
from this improve of investment we are

00:19:41,919 --> 00:19:45,360
already seeing

00:19:42,799 --> 00:19:46,640
promising gains with a three times

00:19:45,360 --> 00:19:50,080
performance improvement

00:19:46,640 --> 00:19:52,799
in.net 5.0 over the previous release

00:19:50,080 --> 00:19:53,520
however we are still about 20 slower

00:19:52,799 --> 00:19:56,080
than go

00:19:53,520 --> 00:19:56,640
in the most common scenario which on our

00:19:56,080 --> 00:19:58,880
diagram

00:19:56,640 --> 00:20:00,480
on the previous slide was represented by

00:19:58,880 --> 00:20:02,960
a single connection with multiple

00:20:00,480 --> 00:20:02,960
streams

00:20:03,600 --> 00:20:06,720
but there's more work to be done

00:20:05,760 --> 00:20:09,440
currently there's an

00:20:06,720 --> 00:20:10,960
ongoing collaborative effort with grpc

00:20:09,440 --> 00:20:13,440
contributors from google

00:20:10,960 --> 00:20:15,400
and the protobuf team to reduce buffer

00:20:13,440 --> 00:20:17,360
copying in the serialization and

00:20:15,400 --> 00:20:19,600
deserialization logic

00:20:17,360 --> 00:20:22,240
specifically we want to reduce the

00:20:19,600 --> 00:20:23,039
amount of allocations by using the spam

00:20:22,240 --> 00:20:25,360
primitive

00:20:23,039 --> 00:20:26,880
that was introduced two years ago as

00:20:25,360 --> 00:20:30,720
part of the.net core

00:20:26,880 --> 00:20:32,960
2.0 2.1

00:20:30,720 --> 00:20:34,000
in a nutshell we are converting the

00:20:32,960 --> 00:20:36,480
protobuf logic

00:20:34,000 --> 00:20:37,840
from using streams to use buffer writers

00:20:36,480 --> 00:20:40,000
and buffer readers

00:20:37,840 --> 00:20:42,080
this means we are reducing string

00:20:40,000 --> 00:20:42,559
allocations and memory copies on the

00:20:42,080 --> 00:20:44,559
heap

00:20:42,559 --> 00:20:46,480
and converting the logic to use stack

00:20:44,559 --> 00:20:49,120
allocated memory instead

00:20:46,480 --> 00:20:50,400
as a result of reducing the overhead due

00:20:49,120 --> 00:20:52,480
to garbage collection

00:20:50,400 --> 00:20:55,280
we expect gains in both server and

00:20:52,480 --> 00:20:57,039
client performance

00:20:55,280 --> 00:20:58,559
and now for the last but probably the

00:20:57,039 --> 00:21:01,120
most important lesson i'll hand it back

00:20:58,559 --> 00:21:01,120
to saurop

00:21:01,520 --> 00:21:04,640
thanks john um like john said i think

00:21:04,159 --> 00:21:06,080
the

00:21:04,640 --> 00:21:08,720
most important lesson that i want to

00:21:06,080 --> 00:21:12,799
talk to about is that your pc

00:21:08,720 --> 00:21:15,039
is a welcoming community so um

00:21:12,799 --> 00:21:16,080
john i and all the folks at microsoft

00:21:15,039 --> 00:21:19,760
have been collaborating

00:21:16,080 --> 00:21:22,480
with you know multiple contributors

00:21:19,760 --> 00:21:25,600
since about november 2018 and have

00:21:22,480 --> 00:21:27,679
shipped multiple releases of jrpc.net

00:21:25,600 --> 00:21:29,440
over the course of almost two years of

00:21:27,679 --> 00:21:32,480
working together

00:21:29,440 --> 00:21:34,480
uh there a lot of folks have helped us

00:21:32,480 --> 00:21:36,640
realize our ambitions of making

00:21:34,480 --> 00:21:38,080
your pc a first class experience in dot

00:21:36,640 --> 00:21:39,919
net uh

00:21:38,080 --> 00:21:41,679
i have a special shout out to some names

00:21:39,919 --> 00:21:42,880
on the slide there are obviously more

00:21:41,679 --> 00:21:46,559
names that i had to leave

00:21:42,880 --> 00:21:49,039
off but i want to specifically call out

00:21:46,559 --> 00:21:50,559
jan and alex who helped us get this

00:21:49,039 --> 00:21:53,200
project off the ground

00:21:50,559 --> 00:21:55,919
they helped expose api surface in the

00:21:53,200 --> 00:21:57,919
existing grpc.core implementation

00:21:55,919 --> 00:21:58,960
that allowed us to share the same api

00:21:57,919 --> 00:22:01,679
service for

00:21:58,960 --> 00:22:02,480
invoking and handling rpcs across both

00:22:01,679 --> 00:22:04,159
the existing

00:22:02,480 --> 00:22:05,600
and the new implementation that was

00:22:04,159 --> 00:22:07,200
being built

00:22:05,600 --> 00:22:10,000
uh i also want to give a shout out to

00:22:07,200 --> 00:22:11,919
carol who who's

00:22:10,000 --> 00:22:14,559
perhaps single-handedly contributed the

00:22:11,919 --> 00:22:17,360
ms build integration for

00:22:14,559 --> 00:22:19,039
code generation which is you know hugely

00:22:17,360 --> 00:22:21,600
instrumental in making

00:22:19,039 --> 00:22:22,640
uh jpc feel like a first-class citizen

00:22:21,600 --> 00:22:25,600
none.net

00:22:22,640 --> 00:22:28,000
and like john also just spoke to uh the

00:22:25,600 --> 00:22:30,880
google protobuf team is helping us with

00:22:28,000 --> 00:22:31,919
changes in code generation to just

00:22:30,880 --> 00:22:35,600
reduce

00:22:31,919 --> 00:22:38,080
uh buffer allocations with that said

00:22:35,600 --> 00:22:39,200
i just want to recap some of the lessons

00:22:38,080 --> 00:22:42,000
we've learned

00:22:39,200 --> 00:22:43,360
as we come to the end of this talk the

00:22:42,000 --> 00:22:45,760
first one was

00:22:43,360 --> 00:22:48,159
using platform primal primitives can

00:22:45,760 --> 00:22:50,240
really bail us out in some circumstances

00:22:48,159 --> 00:22:52,880
the.net ecosystem has a richneck

00:22:50,240 --> 00:22:55,360
standard extensible standard library

00:22:52,880 --> 00:22:57,520
as well as a portable runtime that runs

00:22:55,360 --> 00:22:59,760
on many architectures and os's

00:22:57,520 --> 00:23:02,159
by building upon this we were able to

00:22:59,760 --> 00:23:03,600
make jpc accessible to more.net

00:23:02,159 --> 00:23:05,120
developers and in turn

00:23:03,600 --> 00:23:07,520
make them successful in building

00:23:05,120 --> 00:23:09,679
applications

00:23:07,520 --> 00:23:11,039
uh the second lesson we learned was

00:23:09,679 --> 00:23:14,000
sharing abstractions

00:23:11,039 --> 00:23:15,840
makes every developer more productive by

00:23:14,000 --> 00:23:17,919
using abstractions that were already

00:23:15,840 --> 00:23:20,559
popular in the dotnet ecosystem

00:23:17,919 --> 00:23:21,360
we didn't constrain developers into

00:23:20,559 --> 00:23:24,000
using

00:23:21,360 --> 00:23:25,280
our notion of our logger or only our di

00:23:24,000 --> 00:23:27,280
container

00:23:25,280 --> 00:23:29,679
people are able to plug and play

00:23:27,280 --> 00:23:34,240
different libraries from the ecosystem

00:23:29,679 --> 00:23:36,799
and really use what works best for them

00:23:34,240 --> 00:23:38,240
the third lesson we learned was measure

00:23:36,799 --> 00:23:40,640
what matters

00:23:38,240 --> 00:23:42,720
you know as john spoke to we have a

00:23:40,640 --> 00:23:44,640
background coming from a server team

00:23:42,720 --> 00:23:46,799
and argo we started working on server

00:23:44,640 --> 00:23:47,679
performance then we quickly realized

00:23:46,799 --> 00:23:50,720
that

00:23:47,679 --> 00:23:52,480
you know for us for jrpc.net to be a

00:23:50,720 --> 00:23:55,039
competitive stack

00:23:52,480 --> 00:23:56,159
client performance was also important

00:23:55,039 --> 00:23:58,480
and we started

00:23:56,159 --> 00:24:00,640
you know picking up and like addressing

00:23:58,480 --> 00:24:03,520
the low hanging fruit to be there

00:24:00,640 --> 00:24:06,240
uh grpc has in general served as a

00:24:03,520 --> 00:24:08,799
canonical example of an http

00:24:06,240 --> 00:24:10,720
uh of something that uses http 2 and has

00:24:08,799 --> 00:24:11,840
been the driving force on the.net

00:24:10,720 --> 00:24:15,600
platform team

00:24:11,840 --> 00:24:17,200
to improve performance across the stack

00:24:15,600 --> 00:24:19,120
and performance is really like peeling

00:24:17,200 --> 00:24:20,159
an onion so we've been starting with the

00:24:19,120 --> 00:24:22,240
outer layers

00:24:20,159 --> 00:24:24,000
uh and next up we're obviously working

00:24:22,240 --> 00:24:24,559
on performance of the serialization

00:24:24,000 --> 00:24:27,600
stack

00:24:24,559 --> 00:24:29,200
as we've spoken to and again the most

00:24:27,600 --> 00:24:32,320
important thing was

00:24:29,200 --> 00:24:34,400
jrpc has been a welcoming community we

00:24:32,320 --> 00:24:36,720
came in with the vision of making.net

00:24:34,400 --> 00:24:39,279
core a first-class citizen for dartmouth

00:24:36,720 --> 00:24:41,679
and along the way multiple folks across

00:24:39,279 --> 00:24:44,559
multiple teams have been instrumental in

00:24:41,679 --> 00:24:44,559
making this happen

00:24:45,760 --> 00:24:49,200
i mean all i can say is john and i are

00:24:47,760 --> 00:24:51,440
extremely grateful

00:24:49,200 --> 00:24:52,799
to have had the opportunity to present

00:24:51,440 --> 00:24:57,039
at grpc

00:24:52,799 --> 00:25:00,720
conf as a representative of the.net team

00:24:57,039 --> 00:25:03,440
we're excited to enable developers

00:25:00,720 --> 00:25:05,120
you know and when they consider building

00:25:03,440 --> 00:25:07,360
applications with grpc

00:25:05,120 --> 00:25:11,120
we want.net to be considered a first

00:25:07,360 --> 00:25:13,760
class and a high performance option

00:25:11,120 --> 00:25:15,600
uh at microsoft more broadly we're

00:25:13,760 --> 00:25:18,240
excited about your pc

00:25:15,600 --> 00:25:19,919
and we have a few teams that have spoken

00:25:18,240 --> 00:25:23,360
publicly in their roadmaps about

00:25:19,919 --> 00:25:23,360
adopting grpc as well

00:25:23,440 --> 00:25:27,840
we really hope you enjoyed our talk and

00:25:26,320 --> 00:25:28,880
thank you for taking the time out to

00:25:27,840 --> 00:25:30,720
listen to us

00:25:28,880 --> 00:25:32,080
uh we're looking forward to the rest of

00:25:30,720 --> 00:25:33,760
the rest of the conference and we hope

00:25:32,080 --> 00:25:37,520
you have a great conference as well

00:25:33,760 --> 00:25:37,520

YouTube URL: https://www.youtube.com/watch?v=Jz0OfhOqL3I


