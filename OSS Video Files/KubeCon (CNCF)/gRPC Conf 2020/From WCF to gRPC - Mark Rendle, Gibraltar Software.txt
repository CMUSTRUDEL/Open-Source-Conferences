Title: From WCF to gRPC - Mark Rendle, Gibraltar Software
Publication date: 2020-08-01
Playlist: gRPC Conf 2020
Description: 
	From WCF to gRPC - Mark Rendle, Gibraltar Software 

In 2006, distributed systems meant Service Oriented Architecture, and SOA meant SOAP. Microsoft created the closed-source, platform-specific Windows Communication Foundation (WCF) to enable .NET developers to build SOAP-based applications, services and clients using C# or VB.NET. 15 years later, .NET Core is open source and cross-platform, WCF is being retired, and Microsoft are recommending gRPC as the preferred solution. But can gRPC do everything that WCF did? In this session, Mark Rendle will look at the different modes and bindings of WCF, like two-way "duplex" bindings and server-side sessions, and show how similar functionality can be achieved in gRPC with ASP.NET Core 3.1, with all the performance and interoperability benefits of the gRPC protocol.
Captions: 
	00:00:00,160 --> 00:00:07,120
hi and welcome to from wcf

00:00:03,199 --> 00:00:09,679
to grpc uh my name is mark rendall

00:00:07,120 --> 00:00:12,080
and i was first exposed to the

00:00:09,679 --> 00:00:15,440
awesomeness that is grpc

00:00:12,080 --> 00:00:18,000
last year at the build conference

00:00:15,440 --> 00:00:19,199
microsoft announced that they were no

00:00:18,000 --> 00:00:21,680
longer going to be

00:00:19,199 --> 00:00:23,760
supporting the wcf framework for

00:00:21,680 --> 00:00:27,039
creating distributed applications

00:00:23,760 --> 00:00:29,519
in net core and beyond

00:00:27,039 --> 00:00:30,960
and they recommended that people migrate

00:00:29,519 --> 00:00:33,200
to grpc

00:00:30,960 --> 00:00:34,719
and they have built first class support

00:00:33,200 --> 00:00:38,640
for grpc

00:00:34,719 --> 00:00:42,000
into asp.net core to facilitate that

00:00:38,640 --> 00:00:44,960
so in this talk i'm going to talk about

00:00:42,000 --> 00:00:47,760
how that's going to work the differences

00:00:44,960 --> 00:00:51,120
between wcf and grpc

00:00:47,760 --> 00:00:53,840
and potential ways that

00:00:51,120 --> 00:00:55,039
customers who have big investments in

00:00:53,840 --> 00:00:59,199
wcf

00:00:55,039 --> 00:01:04,799
can migrate to grpc running on.net core

00:00:59,199 --> 00:01:07,760
with a minimum of effort and disruption

00:01:04,799 --> 00:01:08,320
so microsoft have been on a journey with

00:01:07,760 --> 00:01:11,159
net

00:01:08,320 --> 00:01:13,320
for a few years now they created

00:01:11,159 --> 00:01:16,560
created.net core back in

00:01:13,320 --> 00:01:19,360
2016 and unlike

00:01:16,560 --> 00:01:22,080
net which has been a windows only

00:01:19,360 --> 00:01:23,280
behemoth of a framework and proprietary

00:01:22,080 --> 00:01:26,159
closed source

00:01:23,280 --> 00:01:28,400
dot net core is fully open source

00:01:26,159 --> 00:01:31,200
developed in the open on github

00:01:28,400 --> 00:01:32,880
and it is cross-platform it runs on

00:01:31,200 --> 00:01:37,200
windows and linux and

00:01:32,880 --> 00:01:39,600
mac os and in the course of doing that

00:01:37,200 --> 00:01:40,880
some things from net have been brought

00:01:39,600 --> 00:01:43,280
along

00:01:40,880 --> 00:01:45,200
some things have been changed along the

00:01:43,280 --> 00:01:46,399
way and some things are just not being

00:01:45,200 --> 00:01:50,240
brought along at all

00:01:46,399 --> 00:01:53,600
and one of those is wcf

00:01:50,240 --> 00:01:56,560
wcf was created in 2006

00:01:53,600 --> 00:01:58,479
and at the time everybody who was doing

00:01:56,560 --> 00:02:00,560
distributed applications or service

00:01:58,479 --> 00:02:02,799
oriented architecture as we called it

00:02:00,560 --> 00:02:02,799
then

00:02:03,920 --> 00:02:10,239
soap was built into wcf it could do

00:02:07,119 --> 00:02:12,480
soap communications over http

00:02:10,239 --> 00:02:13,680
and when it was talking soap it could

00:02:12,480 --> 00:02:16,080
talk to

00:02:13,680 --> 00:02:19,760
servers and clients written in other

00:02:16,080 --> 00:02:22,879
languages like java or python

00:02:19,760 --> 00:02:26,239
it had a secondary mode which was called

00:02:22,879 --> 00:02:27,200
net tcp and this was a much more high

00:02:26,239 --> 00:02:30,400
performance

00:02:27,200 --> 00:02:33,680
much more powerful binding for

00:02:30,400 --> 00:02:37,120
wcf and it

00:02:33,680 --> 00:02:41,280
allowed used binary wire

00:02:37,120 --> 00:02:44,319
format and a raw tcp connection

00:02:41,280 --> 00:02:47,200
and so it was much faster than soap

00:02:44,319 --> 00:02:48,720
much more powerful but the problem was

00:02:47,200 --> 00:02:52,720
it was only implemented

00:02:48,720 --> 00:02:54,800
in wcfin.net and so wcf

00:02:52,720 --> 00:02:56,400
services and clients could communicate

00:02:54,800 --> 00:02:59,680
using net tcp

00:02:56,400 --> 00:03:03,360
but only with other.net wcf

00:02:59,680 --> 00:03:04,159
clients and so forth and then it was my

00:03:03,360 --> 00:03:06,560
favorite thing

00:03:04,159 --> 00:03:07,440
about wcf and the thing that caused me

00:03:06,560 --> 00:03:10,560
to fail the

00:03:07,440 --> 00:03:10,959
wcf uh microsoft certified developer

00:03:10,560 --> 00:03:14,159
exam

00:03:10,959 --> 00:03:17,200
twice which was the configuration

00:03:14,159 --> 00:03:19,200
so with wcf the

00:03:17,200 --> 00:03:20,640
implementation of your service was

00:03:19,200 --> 00:03:24,159
completely separate

00:03:20,640 --> 00:03:25,920
from the specification of what bindings

00:03:24,159 --> 00:03:27,760
and contracts and wire formats and

00:03:25,920 --> 00:03:29,760
everything else it should use

00:03:27,760 --> 00:03:31,519
to actually handle communication between

00:03:29,760 --> 00:03:34,000
client and server

00:03:31,519 --> 00:03:35,200
and all of this was done through the wcf

00:03:34,000 --> 00:03:38,640
configuration

00:03:35,200 --> 00:03:41,680
xml files and this

00:03:38,640 --> 00:03:43,280
really doesn't fit with microsoft's

00:03:41,680 --> 00:03:46,879
modern vision for

00:03:43,280 --> 00:03:50,080
net net core and moving forward

00:03:46,879 --> 00:03:52,959
to the end of this year.net five

00:03:50,080 --> 00:03:54,640
um a lot of what made wcf work was

00:03:52,959 --> 00:03:56,480
actually built into windows and not the

00:03:54,640 --> 00:04:00,159
dot-net framework itself

00:03:56,480 --> 00:04:02,959
and microsoft has finally embraced

00:04:00,159 --> 00:04:05,760
a cross-platform world and in particular

00:04:02,959 --> 00:04:09,120
a world where people are running

00:04:05,760 --> 00:04:12,799
dense clusters of linux containers

00:04:09,120 --> 00:04:16,160
in kubernetes in various cloud platforms

00:04:12,799 --> 00:04:18,479
and so supporting linux as a target

00:04:16,160 --> 00:04:20,160
host operating system has become

00:04:18,479 --> 00:04:23,199
increasingly important

00:04:20,160 --> 00:04:25,199
and re-implementing wcf to run on top of

00:04:23,199 --> 00:04:27,520
linux would require

00:04:25,199 --> 00:04:28,880
not just migrating the net framework

00:04:27,520 --> 00:04:32,080
parts but also

00:04:28,880 --> 00:04:34,639
the parts that are built into windows

00:04:32,080 --> 00:04:36,560
would have to be re-implemented to work

00:04:34,639 --> 00:04:40,720
properly on linux

00:04:36,560 --> 00:04:43,919
and so microsoft have decided it's 2020

00:04:40,720 --> 00:04:47,120
and people are generally not using soap

00:04:43,919 --> 00:04:48,880
anymore and net tcp is too closed off

00:04:47,120 --> 00:04:52,240
and two windows only

00:04:48,880 --> 00:04:57,120
and so they have embraced grpc

00:04:52,240 --> 00:05:00,320
and grpc uh compared to wcf

00:04:57,120 --> 00:05:03,680
really provides the best of both worlds

00:05:00,320 --> 00:05:07,280
because grpc is a binary

00:05:03,680 --> 00:05:08,720
protocol using protobuf it gets net tcp

00:05:07,280 --> 00:05:12,639
style performance

00:05:08,720 --> 00:05:15,039
but of course grpc is implemented on

00:05:12,639 --> 00:05:17,280
dozens of different platforms and so we

00:05:15,039 --> 00:05:19,360
get the soap interoperability

00:05:17,280 --> 00:05:20,320
and all of this is just out there and

00:05:19,360 --> 00:05:22,720
microsoft

00:05:20,320 --> 00:05:24,560
have embraced this and decided that they

00:05:22,720 --> 00:05:27,280
are going to become part of this

00:05:24,560 --> 00:05:28,000
grpc ecosystem which i'm sure we all

00:05:27,280 --> 00:05:31,680
agree

00:05:28,000 --> 00:05:34,960
is awesome grpc of course

00:05:31,680 --> 00:05:37,680
supports net and java and go and

00:05:34,960 --> 00:05:38,720
you know an endless list if it's a

00:05:37,680 --> 00:05:40,240
current

00:05:38,720 --> 00:05:42,479
programming language or a current

00:05:40,240 --> 00:05:44,400
development platform you can be pretty

00:05:42,479 --> 00:05:46,240
certain it supports grpc

00:05:44,400 --> 00:05:48,080
whether that's officially or through

00:05:46,240 --> 00:05:51,280
third-party implementations for things

00:05:48,080 --> 00:05:54,880
like rust and haskell and so forth

00:05:51,280 --> 00:05:57,919
one nice thing is that the grpc

00:05:54,880 --> 00:06:00,960
web proxy standard which

00:05:57,919 --> 00:06:02,960
is commonly used to allow browsers to

00:06:00,960 --> 00:06:05,600
access grpc services

00:06:02,960 --> 00:06:07,520
that normally requires running the grpc

00:06:05,600 --> 00:06:10,880
web proxy in a container

00:06:07,520 --> 00:06:12,560
or using an envoy proxy to provide the

00:06:10,880 --> 00:06:14,479
grpc web interface

00:06:12,560 --> 00:06:16,960
microsoft have actually created an

00:06:14,479 --> 00:06:20,400
implementation of the grpc web

00:06:16,960 --> 00:06:21,039
protocol and it's built into asp.net

00:06:20,400 --> 00:06:22,960
core

00:06:21,039 --> 00:06:24,080
so you can install it just as an

00:06:22,960 --> 00:06:26,960
additional package

00:06:24,080 --> 00:06:28,720
into your grpc application and with a

00:06:26,960 --> 00:06:32,240
couple of configuration points

00:06:28,720 --> 00:06:35,360
you can actually make your grpc service

00:06:32,240 --> 00:06:36,319
natively support grpc web and support

00:06:35,360 --> 00:06:39,759
browsers

00:06:36,319 --> 00:06:43,520
connecting to it without any

00:06:39,759 --> 00:06:46,840
need for proxies or other sidecar

00:06:43,520 --> 00:06:49,039
instances in production so that's pretty

00:06:46,840 --> 00:06:50,479
cool i think that's a good example of

00:06:49,039 --> 00:06:53,680
how microsoft are actually

00:06:50,479 --> 00:06:55,680
embracing and attempting to uh really

00:06:53,680 --> 00:06:58,960
make the most of the grpc

00:06:55,680 --> 00:07:01,680
ecosystem for um both for

00:06:58,960 --> 00:07:04,560
microsoft developers but for all other

00:07:01,680 --> 00:07:04,560
developers as well

00:07:04,639 --> 00:07:11,599
so dot net core grpc micro

00:07:08,319 --> 00:07:14,960
obviously the grpc project has provided

00:07:11,599 --> 00:07:17,840
uh nuget packages to implement grpc

00:07:14,960 --> 00:07:19,520
in net applications for some time now

00:07:17,840 --> 00:07:22,560
and those

00:07:19,520 --> 00:07:23,440
the libraries for net are wrappers

00:07:22,560 --> 00:07:26,960
around the

00:07:23,440 --> 00:07:30,000
native grpc implementation library

00:07:26,960 --> 00:07:33,360
dot net core grpc wanted to

00:07:30,000 --> 00:07:36,960
provide the grpc protocol but

00:07:33,360 --> 00:07:37,759
in a fully managed way that meshed well

00:07:36,960 --> 00:07:40,960
with

00:07:37,759 --> 00:07:44,639
net core and asp.net core applications

00:07:40,960 --> 00:07:48,080
and so they dedicated

00:07:44,639 --> 00:07:51,120
some developers working on.net core 3.0

00:07:48,080 --> 00:07:54,160
to create a.net core grpc implementation

00:07:51,120 --> 00:07:58,160
which is available alongside the

00:07:54,160 --> 00:08:01,599
original grpc4.net or grpc for c-sharp

00:07:58,160 --> 00:08:05,199
implementation so net core grpc is

00:08:01,599 --> 00:08:08,080
fully managed it doesn't use the grpc

00:08:05,199 --> 00:08:10,400
native client at all or native

00:08:08,080 --> 00:08:12,240
components at all

00:08:10,400 --> 00:08:14,240
it is part of the grpc project though

00:08:12,240 --> 00:08:15,199
it's under the grpc organization on

00:08:14,240 --> 00:08:17,840
github

00:08:15,199 --> 00:08:18,400
it's maintained by microsoft developers

00:08:17,840 --> 00:08:20,240
but it's

00:08:18,400 --> 00:08:22,000
uh open source and there are other

00:08:20,240 --> 00:08:25,199
contributors to it as well

00:08:22,000 --> 00:08:28,080
and uh it is

00:08:25,199 --> 00:08:29,039
playing very nicely in the grpc

00:08:28,080 --> 00:08:32,080
organization

00:08:29,039 --> 00:08:34,880
and ecosystem and it runs on the

00:08:32,080 --> 00:08:37,120
kestrel http server which is an

00:08:34,880 --> 00:08:37,599
incredibly high performance http server

00:08:37,120 --> 00:08:40,719
that's

00:08:37,599 --> 00:08:42,000
built into net core which is currently

00:08:40,719 --> 00:08:43,839
sitting somewhere near the top of the

00:08:42,000 --> 00:08:47,440
tech in power benchmarks

00:08:43,839 --> 00:08:51,760
and the clients that you generate

00:08:47,440 --> 00:08:52,880
for net core use the system.net.http

00:08:51,760 --> 00:08:54,720
client

00:08:52,880 --> 00:08:56,800
which again is a very high performance

00:08:54,720 --> 00:09:00,000
uh http

00:08:56,800 --> 00:09:03,600
client um that's natively implemented in

00:09:00,000 --> 00:09:06,320
net core so adding grpc

00:09:03,600 --> 00:09:08,000
to an asp.net core application looks

00:09:06,320 --> 00:09:10,160
much like adding anything else

00:09:08,000 --> 00:09:12,240
to an asp.net core application here you

00:09:10,160 --> 00:09:12,560
can see the startup class that you get

00:09:12,240 --> 00:09:15,200
in

00:09:12,560 --> 00:09:17,040
all your asb net core applications where

00:09:15,200 --> 00:09:20,080
we configure services which is

00:09:17,040 --> 00:09:23,760
the dependency injection and we just add

00:09:20,080 --> 00:09:26,080
grpc as uh dependency in there

00:09:23,760 --> 00:09:27,839
and then in our configure method which

00:09:26,080 --> 00:09:29,360
is where we set up our routing and

00:09:27,839 --> 00:09:30,000
endpoints and middleware and everything

00:09:29,360 --> 00:09:33,120
else

00:09:30,000 --> 00:09:35,360
we just map our grpc service

00:09:33,120 --> 00:09:38,240
and this will sit quite happily in an

00:09:35,360 --> 00:09:38,640
application that also has http endpoints

00:09:38,240 --> 00:09:42,080
or

00:09:38,640 --> 00:09:43,600
signalr endpoints that's serving static

00:09:42,080 --> 00:09:46,080
files

00:09:43,600 --> 00:09:48,240
it works with the built-in asb net core

00:09:46,080 --> 00:09:49,760
authentication libraries

00:09:48,240 --> 00:09:51,600
encryption libraries compression

00:09:49,760 --> 00:09:55,120
libraries it is a

00:09:51,600 --> 00:09:55,920
full-on first-class part of the asp.net

00:09:55,120 --> 00:10:00,080
core

00:09:55,920 --> 00:10:01,279
environment so it's clear that microsoft

00:10:00,080 --> 00:10:03,920
are all in on this

00:10:01,279 --> 00:10:04,640
and that this is where we should be

00:10:03,920 --> 00:10:07,360
going

00:10:04,640 --> 00:10:08,399
with our distributed applications from

00:10:07,360 --> 00:10:11,680
wcf

00:10:08,399 --> 00:10:14,880
so let's take a look at how wcf

00:10:11,680 --> 00:10:18,079
compares to grpc in terms of the actual

00:10:14,880 --> 00:10:18,640
implementation so the first thing we

00:10:18,079 --> 00:10:21,839
have

00:10:18,640 --> 00:10:22,640
uh as part of any rpc or distributed

00:10:21,839 --> 00:10:26,079
system

00:10:22,640 --> 00:10:27,920
is our services and in wcf

00:10:26,079 --> 00:10:29,839
these are defined using service

00:10:27,920 --> 00:10:32,079
contracts service contracts are

00:10:29,839 --> 00:10:35,760
typically a c-sharp interface

00:10:32,079 --> 00:10:39,279
decorated with some attributes and

00:10:35,760 --> 00:10:41,200
the attributes declare how the

00:10:39,279 --> 00:10:42,320
interface is going to be exposed as a

00:10:41,200 --> 00:10:44,320
service you can

00:10:42,320 --> 00:10:45,519
put things in there to control

00:10:44,320 --> 00:10:48,160
authentication

00:10:45,519 --> 00:10:48,720
and various other components but you

00:10:48,160 --> 00:10:51,680
define

00:10:48,720 --> 00:10:52,720
your service contract your your public

00:10:51,680 --> 00:10:56,160
interface

00:10:52,720 --> 00:10:58,720
using this c-sharp interface and then

00:10:56,160 --> 00:11:00,800
you would implement that interface in an

00:10:58,720 --> 00:11:02,160
actual class in order to

00:11:00,800 --> 00:11:04,720
create the implementation of your

00:11:02,160 --> 00:11:07,760
service in grpc

00:11:04,720 --> 00:11:11,600
we have a service definition and

00:11:07,760 --> 00:11:15,519
this is written in the protobuf language

00:11:11,600 --> 00:11:18,320
and it looks pretty much the same

00:11:15,519 --> 00:11:20,800
obviously it's a first-class dsl for

00:11:18,320 --> 00:11:23,680
defining services and messages

00:11:20,800 --> 00:11:24,800
there are a couple of key differences

00:11:23,680 --> 00:11:28,000
with

00:11:24,800 --> 00:11:31,920
wcf and grpc the primary

00:11:28,000 --> 00:11:34,800
one is that rpc methods in grpc

00:11:31,920 --> 00:11:36,240
can only take a single parameter whereas

00:11:34,800 --> 00:11:38,079
wcf methods

00:11:36,240 --> 00:11:39,600
in service contracts can take multiple

00:11:38,079 --> 00:11:43,279
parameters

00:11:39,600 --> 00:11:47,279
also wcf methods can return

00:11:43,279 --> 00:11:47,279
all kinds of types they can return

00:11:47,920 --> 00:11:52,079
plain old c-sharp objects but they can

00:11:50,079 --> 00:11:54,560
also return lists and arrays

00:11:52,079 --> 00:11:56,800
of c-sharp objects and they can also

00:11:54,560 --> 00:11:57,839
return lists and arrays of primitives so

00:11:56,800 --> 00:12:00,720
you could have

00:11:57,839 --> 00:12:02,560
a method that returned a list of strings

00:12:00,720 --> 00:12:04,399
whereas rpc

00:12:02,560 --> 00:12:05,600
really just supports returning some kind

00:12:04,399 --> 00:12:08,720
of message type

00:12:05,600 --> 00:12:12,720
and so the first part of

00:12:08,720 --> 00:12:16,000
migrating your wcf to grpc

00:12:12,720 --> 00:12:20,000
application is to

00:12:16,000 --> 00:12:23,519
wrap those parameters in request objects

00:12:20,000 --> 00:12:26,399
and potentially wrap the

00:12:23,519 --> 00:12:28,320
return type in a response object and

00:12:26,399 --> 00:12:30,720
when i'm working with customers who are

00:12:28,320 --> 00:12:33,440
looking to do this i always recommend

00:12:30,720 --> 00:12:34,320
creating a specific request and response

00:12:33,440 --> 00:12:37,279
object

00:12:34,320 --> 00:12:38,959
for each method in the service just

00:12:37,279 --> 00:12:40,880
because one of the great things about

00:12:38,959 --> 00:12:42,560
protobuf and grpc

00:12:40,880 --> 00:12:45,760
is the forwards and backwards

00:12:42,560 --> 00:12:48,240
compatibility that you get from protobuf

00:12:45,760 --> 00:12:50,399
and if we have separate request and

00:12:48,240 --> 00:12:53,360
response objects for each method

00:12:50,399 --> 00:12:54,560
it means less chance of breaking the

00:12:53,360 --> 00:12:57,839
contract

00:12:54,560 --> 00:13:01,760
with an irreconcilable change

00:12:57,839 --> 00:13:03,760
in the future speaking of

00:13:01,760 --> 00:13:05,920
contracts the next thing we want to look

00:13:03,760 --> 00:13:08,959
at is data contracts

00:13:05,920 --> 00:13:12,560
or what grpc calls messages so

00:13:08,959 --> 00:13:14,079
in wcf a data contract is simply a plain

00:13:12,560 --> 00:13:17,200
old c-sharp object

00:13:14,079 --> 00:13:18,959
with properties and again decorated with

00:13:17,200 --> 00:13:20,800
attributes you have the data contract to

00:13:18,959 --> 00:13:23,120
say this is a data contract

00:13:20,800 --> 00:13:25,600
and then use the data member attribute

00:13:23,120 --> 00:13:27,360
to decorate

00:13:25,600 --> 00:13:29,040
all the properties that should be

00:13:27,360 --> 00:13:33,600
serialized this

00:13:29,040 --> 00:13:36,880
matches fairly closely to a grpc message

00:13:33,600 --> 00:13:40,880
we have here the equivalent message

00:13:36,880 --> 00:13:43,839
for the room uh type

00:13:40,880 --> 00:13:45,519
obviously in grpc we're using the

00:13:43,839 --> 00:13:46,880
lowercase and underscores naming

00:13:45,519 --> 00:13:49,120
convention

00:13:46,880 --> 00:13:51,440
in the generated c sharp code that will

00:13:49,120 --> 00:13:52,880
become pascal case

00:13:51,440 --> 00:13:55,199
because that's the way the c sharp code

00:13:52,880 --> 00:13:56,880
generator works one thing

00:13:55,199 --> 00:13:58,480
that i ran into fairly quickly

00:13:56,880 --> 00:13:59,519
particularly working with enterprise

00:13:58,480 --> 00:14:02,880
customers

00:13:59,519 --> 00:14:04,320
is that protobuf does not provide a

00:14:02,880 --> 00:14:07,600
built-in

00:14:04,320 --> 00:14:11,120
type that matches to c-sharps decimal

00:14:07,600 --> 00:14:14,560
it has float and it has double and

00:14:11,120 --> 00:14:17,519
we know that actually if you

00:14:14,560 --> 00:14:19,360
set a a float on the protobuf object and

00:14:17,519 --> 00:14:20,880
send it over the wire and then extract

00:14:19,360 --> 00:14:22,399
that float at the other end

00:14:20,880 --> 00:14:24,720
it will still have exactly the same

00:14:22,399 --> 00:14:26,920
value and it's when you do maths with

00:14:24,720 --> 00:14:32,000
floats that you discover that

00:14:26,920 --> 00:14:32,000
4.99 times 5 is uh

00:14:33,240 --> 00:14:38,320
24.9444449

00:14:34,959 --> 00:14:39,920
but if you try and put floats and

00:14:38,320 --> 00:14:41,600
doubles into a lot of enterprise

00:14:39,920 --> 00:14:44,240
customers software they are just

00:14:41,600 --> 00:14:46,800
they're not happy they don't like it and

00:14:44,240 --> 00:14:49,920
so i had to find a way around this

00:14:46,800 --> 00:14:51,680
google within their api protobuf

00:14:49,920 --> 00:14:52,399
definitions actually provide a money

00:14:51,680 --> 00:14:56,000
type

00:14:52,399 --> 00:14:59,040
which works by having units and nanos

00:14:56,000 --> 00:15:02,160
and a currency field and so i

00:14:59,040 --> 00:15:05,680
just created a

00:15:02,160 --> 00:15:06,880
a copy of that money type and left off

00:15:05,680 --> 00:15:09,120
the currency

00:15:06,880 --> 00:15:10,160
and called that decimal so this is

00:15:09,120 --> 00:15:13,680
almost uh

00:15:10,160 --> 00:15:16,639
identical to google's money

00:15:13,680 --> 00:15:17,839
proto from their apis the only

00:15:16,639 --> 00:15:19,279
difference is it doesn't have the

00:15:17,839 --> 00:15:22,160
currency

00:15:19,279 --> 00:15:22,160
field on there

00:15:23,040 --> 00:15:31,040
so this builds quite nicely into a

00:15:27,279 --> 00:15:34,480
net core grpc application

00:15:31,040 --> 00:15:37,440
you just drop this proto in

00:15:34,480 --> 00:15:38,480
and to make it even nicer and to make it

00:15:37,440 --> 00:15:41,440
play nicely with

00:15:38,480 --> 00:15:42,240
the built-in decimals in c-sharp i use

00:15:41,440 --> 00:15:46,240
the fact

00:15:42,240 --> 00:15:50,000
that the classes generated by

00:15:46,240 --> 00:15:52,160
protobufs by grpc and protobufs

00:15:50,000 --> 00:15:53,279
c-sharp generator it declares all the

00:15:52,160 --> 00:15:56,000
classes as

00:15:53,279 --> 00:15:58,560
partial and that means that you can add

00:15:56,000 --> 00:16:00,880
additional properties and methods and

00:15:58,560 --> 00:16:02,480
and other things to them and in this

00:16:00,880 --> 00:16:05,199
instance it means that

00:16:02,480 --> 00:16:06,959
we can add some implicit operators to

00:16:05,199 --> 00:16:09,360
our decimal value class

00:16:06,959 --> 00:16:11,680
to allow it to be passed backwards and

00:16:09,360 --> 00:16:14,079
forwards with c-sharp decimals

00:16:11,680 --> 00:16:15,040
without any casting or overloads or

00:16:14,079 --> 00:16:16,639
methods or

00:16:15,040 --> 00:16:18,399
anything like that so this makes that

00:16:16,639 --> 00:16:23,680
decimal value

00:16:18,399 --> 00:16:26,079
type play nicely with c-sharp decimals

00:16:23,680 --> 00:16:28,959
as i tend to be working with people who

00:16:26,079 --> 00:16:31,839
are moving from wcf to grpc

00:16:28,959 --> 00:16:33,600
they usually already have a c-sharp

00:16:31,839 --> 00:16:35,360
equivalent of their

00:16:33,600 --> 00:16:37,120
data contract object their message

00:16:35,360 --> 00:16:39,680
object as well and so

00:16:37,120 --> 00:16:40,240
what we quite often do is build a

00:16:39,680 --> 00:16:42,800
similar

00:16:40,240 --> 00:16:44,560
implicit conversion in to go from the

00:16:42,800 --> 00:16:48,000
plain old c-sharp object

00:16:44,560 --> 00:16:52,399
to the grpc message as you can see here

00:16:48,000 --> 00:16:53,920
this converts the global colon colon

00:16:52,399 --> 00:16:56,399
hotel data room

00:16:53,920 --> 00:16:57,120
that would be the pre-existing class

00:16:56,399 --> 00:17:01,120
from

00:16:57,120 --> 00:17:04,079
their old wcf application and this

00:17:01,120 --> 00:17:04,959
partial declaration just cleanly

00:17:04,079 --> 00:17:08,079
converts

00:17:04,959 --> 00:17:11,600
between that type

00:17:08,079 --> 00:17:14,640
and the protobuf generated room message

00:17:11,600 --> 00:17:18,079
type okay so

00:17:14,640 --> 00:17:20,160
that makes migration a little bit easier

00:17:18,079 --> 00:17:21,520
then we get into the actual

00:17:20,160 --> 00:17:25,600
implementation

00:17:21,520 --> 00:17:28,240
in uh wcf versus grpc

00:17:25,600 --> 00:17:29,039
so with wcf you don't have a base class

00:17:28,240 --> 00:17:31,520
you

00:17:29,039 --> 00:17:33,840
inherit from the interface that you use

00:17:31,520 --> 00:17:35,840
to define your service contract

00:17:33,840 --> 00:17:37,919
and then you just have methods on there

00:17:35,840 --> 00:17:41,520
that are implemented however you want to

00:17:37,919 --> 00:17:44,559
implement them grpc implementations

00:17:41,520 --> 00:17:45,200
are different obviously you get a base

00:17:44,559 --> 00:17:48,160
class

00:17:45,200 --> 00:17:49,600
and you inherit from that base class and

00:17:48,160 --> 00:17:52,480
override

00:17:49,600 --> 00:17:54,559
the predefined methods to provide the

00:17:52,480 --> 00:17:56,880
implementation for your service

00:17:54,559 --> 00:17:57,679
and so that makes things a little bit

00:17:56,880 --> 00:18:01,200
different

00:17:57,679 --> 00:18:04,400
also because for date

00:18:01,200 --> 00:18:07,440
and times and durations there is no

00:18:04,400 --> 00:18:10,880
built-in implicit conversion between

00:18:07,440 --> 00:18:15,200
google's well-known timestamp and

00:18:10,880 --> 00:18:18,400
duration types to net's built-in

00:18:15,200 --> 00:18:20,880
date time offset and time span

00:18:18,400 --> 00:18:22,320
types we do actually have to do some

00:18:20,880 --> 00:18:24,960
manual conversion there

00:18:22,320 --> 00:18:26,840
so we have to turn the check-in date

00:18:24,960 --> 00:18:29,200
which is a time stamp to a date time

00:18:26,840 --> 00:18:31,520
offset

00:18:29,200 --> 00:18:32,880
then we create our room data class

00:18:31,520 --> 00:18:34,880
wherever that's coming from

00:18:32,880 --> 00:18:36,480
obviously normally in a net core

00:18:34,880 --> 00:18:38,880
application we'd be getting that from

00:18:36,480 --> 00:18:41,039
dependency injection but in this case

00:18:38,880 --> 00:18:44,559
this is just for some demo code

00:18:41,039 --> 00:18:47,520
and then we create our response

00:18:44,559 --> 00:18:48,640
from the protobuf message and in this

00:18:47,520 --> 00:18:50,799
instance because this is not

00:18:48,640 --> 00:18:52,640
asynchronous we just return a task from

00:18:50,799 --> 00:18:54,160
result response

00:18:52,640 --> 00:18:55,760
but normally obviously this would be

00:18:54,160 --> 00:18:57,760
talking to databases or upstream

00:18:55,760 --> 00:19:00,480
services or other microservices

00:18:57,760 --> 00:19:01,440
and so we would have various awaits in

00:19:00,480 --> 00:19:04,480
there

00:19:01,440 --> 00:19:08,640
so this

00:19:04,480 --> 00:19:09,360
essentially moves the functionality from

00:19:08,640 --> 00:19:13,280
the old

00:19:09,360 --> 00:19:13,840
hotel service directly into the grpc

00:19:13,280 --> 00:19:17,919
service

00:19:13,840 --> 00:19:21,200
in the new project

00:19:17,919 --> 00:19:22,320
however there is an easier way to do

00:19:21,200 --> 00:19:24,559
this

00:19:22,320 --> 00:19:26,640
obviously this hotel service there's not

00:19:24,559 --> 00:19:29,440
a lot going on in that implementation

00:19:26,640 --> 00:19:30,160
the majority of wcf services there will

00:19:29,440 --> 00:19:32,799
be

00:19:30,160 --> 00:19:34,320
quite a bit more logic in each of those

00:19:32,799 --> 00:19:37,440
implementation methods

00:19:34,320 --> 00:19:38,080
and there may also be uh other private

00:19:37,440 --> 00:19:40,400
methods

00:19:38,080 --> 00:19:41,120
in that hotel service class that are

00:19:40,400 --> 00:19:44,960
used

00:19:41,120 --> 00:19:47,039
to fulfill these requests and so

00:19:44,960 --> 00:19:48,160
there's a quick cheat mode that i like

00:19:47,039 --> 00:19:51,200
to recommend

00:19:48,160 --> 00:19:52,000
where if you can get your hotel service

00:19:51,200 --> 00:19:55,200
type

00:19:52,000 --> 00:19:58,400
to compile under net core

00:19:55,200 --> 00:20:00,960
which as long as you're not using

00:19:58,400 --> 00:20:02,000
particularly edge case libraries or new

00:20:00,960 --> 00:20:04,000
get packages

00:20:02,000 --> 00:20:05,200
you should be able to do dot net core

00:20:04,000 --> 00:20:08,559
3.1 and

00:20:05,200 --> 00:20:11,039
net 5 support ado.net

00:20:08,559 --> 00:20:12,880
for most of the databases out there they

00:20:11,039 --> 00:20:16,559
also support entity framework

00:20:12,880 --> 00:20:19,200
6.3 as well as entity framework core

00:20:16,559 --> 00:20:20,080
so if you can copy your hotel service

00:20:19,200 --> 00:20:22,240
class across

00:20:20,080 --> 00:20:23,919
into your new project then we can

00:20:22,240 --> 00:20:27,600
actually just inject

00:20:23,919 --> 00:20:29,200
that service contract type into our grpc

00:20:27,600 --> 00:20:32,320
service implementation

00:20:29,200 --> 00:20:33,760
and just call directly into it so all

00:20:32,320 --> 00:20:36,400
our old code

00:20:33,760 --> 00:20:37,520
stays in the same place and working the

00:20:36,400 --> 00:20:40,960
same way

00:20:37,520 --> 00:20:44,320
we just wrap grpc around it

00:20:40,960 --> 00:20:47,280
and then we find it much easier to

00:20:44,320 --> 00:20:48,559
bring complex data across and so you can

00:20:47,280 --> 00:20:50,880
see here

00:20:48,559 --> 00:20:51,760
hotel service is injected by dependency

00:20:50,880 --> 00:20:55,120
injection

00:20:51,760 --> 00:20:57,280
and then get available rooms just calls

00:20:55,120 --> 00:20:59,840
into that service contract get available

00:20:57,280 --> 00:21:03,440
room so whatever logic was in there

00:20:59,840 --> 00:21:05,840
is now uh being exposed over a grpc

00:21:03,440 --> 00:21:05,840
interface

00:21:06,159 --> 00:21:11,440
so that works really nicely and actually

00:21:09,200 --> 00:21:12,480
i make a tool which i'll mention briefly

00:21:11,440 --> 00:21:15,039
later on that

00:21:12,480 --> 00:21:17,120
automates as much of this process as

00:21:15,039 --> 00:21:17,919
possible and this is the pattern that it

00:21:17,120 --> 00:21:21,039
uses

00:21:17,919 --> 00:21:25,919
to migrate net 4 wcf code

00:21:21,039 --> 00:21:25,919
into a net core 3.1 grpc application

00:21:26,720 --> 00:21:34,480
so grpc has various modes and wcf has

00:21:31,200 --> 00:21:36,080
various different bindings and types of

00:21:34,480 --> 00:21:38,159
service that it supports

00:21:36,080 --> 00:21:39,679
and so i want to talk about those

00:21:38,159 --> 00:21:42,720
briefly

00:21:39,679 --> 00:21:44,240
wcf the

00:21:42,720 --> 00:21:45,520
the most straightforward mode and the

00:21:44,240 --> 00:21:47,039
mode that we've just been looking at

00:21:45,520 --> 00:21:49,200
with that hotel service

00:21:47,039 --> 00:21:50,320
is just simple request response the

00:21:49,200 --> 00:21:52,320
client sends a request

00:21:50,320 --> 00:21:53,840
the server sends a response and that's

00:21:52,320 --> 00:21:54,799
very straightforward and that maps

00:21:53,840 --> 00:21:59,120
perfectly

00:21:54,799 --> 00:22:02,960
to grpc's request response

00:21:59,120 --> 00:22:05,440
model and makes it very very easy to

00:22:02,960 --> 00:22:09,039
copy things over

00:22:05,440 --> 00:22:11,679
grpc also provides server streaming

00:22:09,039 --> 00:22:12,640
where the call from the client to the

00:22:11,679 --> 00:22:15,520
server

00:22:12,640 --> 00:22:16,240
opens a persistent stream and then

00:22:15,520 --> 00:22:19,760
objects

00:22:16,240 --> 00:22:20,720
are sent one at a time over that stream

00:22:19,760 --> 00:22:22,799
either until

00:22:20,720 --> 00:22:25,760
there are no more objects to send or

00:22:22,799 --> 00:22:26,720
until the client closes the stream again

00:22:25,760 --> 00:22:29,760
and

00:22:26,720 --> 00:22:32,640
wcf could do something like this

00:22:29,760 --> 00:22:34,400
in certain bindings in net tcp and i

00:22:32,640 --> 00:22:37,120
think a couple of other bindings

00:22:34,400 --> 00:22:40,240
if you returned an i innumerable from

00:22:37,120 --> 00:22:42,480
your wcf service it would actually send

00:22:40,240 --> 00:22:44,320
the objects over the wire

00:22:42,480 --> 00:22:46,159
as they became available and so you

00:22:44,320 --> 00:22:47,039
could get this server streaming kind of

00:22:46,159 --> 00:22:51,280
approach

00:22:47,039 --> 00:22:54,720
and so for wcf methods that return

00:22:51,280 --> 00:22:57,760
are innumerable of something you can

00:22:54,720 --> 00:23:01,600
map that very nicely to a grpc

00:22:57,760 --> 00:23:04,080
streaming service which

00:23:01,600 --> 00:23:04,720
in c looks like the code on the right

00:23:04,080 --> 00:23:06,880
here

00:23:04,720 --> 00:23:08,000
where we get our response stream passed

00:23:06,880 --> 00:23:10,880
in and then we

00:23:08,000 --> 00:23:12,480
just enumerate through all the rooms

00:23:10,880 --> 00:23:14,960
from our service contract

00:23:12,480 --> 00:23:16,640
and write those back to the response

00:23:14,960 --> 00:23:20,320
stream

00:23:16,640 --> 00:23:22,000
and this gives us uh if you were using

00:23:20,320 --> 00:23:23,919
net tcp binding and using that

00:23:22,000 --> 00:23:25,360
feature of via enumerable this gives you

00:23:23,919 --> 00:23:27,200
the same functionality

00:23:25,360 --> 00:23:28,720
if you weren't using a binding that

00:23:27,200 --> 00:23:30,480
supported it then

00:23:28,720 --> 00:23:32,640
in wcf this would actually build the

00:23:30,480 --> 00:23:33,200
entire result set on the server side and

00:23:32,640 --> 00:23:35,440
then

00:23:33,200 --> 00:23:38,240
send the whole thing over in one go and

00:23:35,440 --> 00:23:40,640
so moving to a grpc streaming approach

00:23:38,240 --> 00:23:41,600
gives you actually extra benefits over

00:23:40,640 --> 00:23:45,919
what you could do

00:23:41,600 --> 00:23:50,240
in wcf and then finally

00:23:45,919 --> 00:23:52,720
grpc i'm going the wrong way

00:23:50,240 --> 00:23:54,000
and then finally grpc supports

00:23:52,720 --> 00:23:55,919
bi-directional streaming

00:23:54,000 --> 00:23:57,440
where you have a stream open from the

00:23:55,919 --> 00:24:00,320
client to the server

00:23:57,440 --> 00:24:01,039
and a stream open from the server to the

00:24:00,320 --> 00:24:03,840
client

00:24:01,039 --> 00:24:05,039
and objects can just be asynchronously

00:24:03,840 --> 00:24:09,200
arbitrarily sent

00:24:05,039 --> 00:24:12,880
in both directions at the same time

00:24:09,200 --> 00:24:16,400
and this actually maps sort of

00:24:12,880 --> 00:24:19,440
to wcf uh full duplex

00:24:16,400 --> 00:24:22,960
bindings wcf had this concept of

00:24:19,440 --> 00:24:26,400
session so a full duplex

00:24:22,960 --> 00:24:28,960
binding in wcf would mean that the

00:24:26,400 --> 00:24:30,559
client had a stub which it could use to

00:24:28,960 --> 00:24:33,039
call methods on the server

00:24:30,559 --> 00:24:35,600
and the server had a stub which it could

00:24:33,039 --> 00:24:38,559
use to call methods on the client

00:24:35,600 --> 00:24:40,080
and this allowed for quite complicated

00:24:38,559 --> 00:24:42,640
services to be built

00:24:40,080 --> 00:24:43,200
um with asynchronous messaging between

00:24:42,640 --> 00:24:46,960
them

00:24:43,200 --> 00:24:48,960
it also meant that when a instance of

00:24:46,960 --> 00:24:50,240
the service contract type was created on

00:24:48,960 --> 00:24:52,080
the server

00:24:50,240 --> 00:24:54,080
it could be held in memory and it

00:24:52,080 --> 00:24:57,039
basically created a persistent

00:24:54,080 --> 00:24:58,000
session that the client was permanently

00:24:57,039 --> 00:25:00,480
connected to

00:24:58,000 --> 00:25:01,600
so if you had any fields for example on

00:25:00,480 --> 00:25:03,919
that

00:25:01,600 --> 00:25:05,679
class then those fields would keep their

00:25:03,919 --> 00:25:07,760
value for as long as that session stayed

00:25:05,679 --> 00:25:12,080
open for as long as the duplex

00:25:07,760 --> 00:25:16,080
binding was held a duplex binding

00:25:12,080 --> 00:25:19,200
in wcf looked something like this

00:25:16,080 --> 00:25:22,400
so we would have our calculator service

00:25:19,200 --> 00:25:22,640
um this is microsoft's canonical example

00:25:22,400 --> 00:25:25,279
of

00:25:22,640 --> 00:25:26,159
almost anything ever as a calculator and

00:25:25,279 --> 00:25:28,240
so they

00:25:26,159 --> 00:25:30,240
illustrated the duplex service with a

00:25:28,240 --> 00:25:31,200
calculator where the client just kept

00:25:30,240 --> 00:25:34,400
sending

00:25:31,200 --> 00:25:37,279
new um values and

00:25:34,400 --> 00:25:38,799
the server kept calling back a message

00:25:37,279 --> 00:25:39,279
on the client saying here's the current

00:25:38,799 --> 00:25:41,279
result

00:25:39,279 --> 00:25:42,480
here's the current result and so that

00:25:41,279 --> 00:25:45,200
was implemented

00:25:42,480 --> 00:25:46,080
something like this where you would get

00:25:45,200 --> 00:25:49,600
the

00:25:46,080 --> 00:25:52,640
callback interface which was a proxy

00:25:49,600 --> 00:25:55,360
obviously wrapped around the interface

00:25:52,640 --> 00:25:56,000
declaration and then you could use that

00:25:55,360 --> 00:25:58,000
to

00:25:56,000 --> 00:25:59,520
call methods on the client which

00:25:58,000 --> 00:26:01,200
obviously was something about sending a

00:25:59,520 --> 00:26:03,679
message and then invoking

00:26:01,200 --> 00:26:05,919
something on the client with that

00:26:03,679 --> 00:26:08,960
messages parameters

00:26:05,919 --> 00:26:12,799
and we can actually duplicate this

00:26:08,960 --> 00:26:15,520
in grpc with i like to call them

00:26:12,799 --> 00:26:18,640
action streams so if we have a

00:26:15,520 --> 00:26:20,880
bidirectional streaming service in grpc

00:26:18,640 --> 00:26:22,000
and we have a stream of actions from the

00:26:20,880 --> 00:26:24,080
client to the server

00:26:22,000 --> 00:26:25,840
and a stream of callbacks from the

00:26:24,080 --> 00:26:29,120
server to the client

00:26:25,840 --> 00:26:32,720
and the each of these

00:26:29,120 --> 00:26:35,760
message types has a one-off field

00:26:32,720 --> 00:26:36,320
and that one of is set to more message

00:26:35,760 --> 00:26:37,919
type so

00:26:36,320 --> 00:26:39,440
in this instance we have a clear action

00:26:37,919 --> 00:26:42,240
and an add to action

00:26:39,440 --> 00:26:43,200
and so on and the callback has a result

00:26:42,240 --> 00:26:46,559
callback and uh

00:26:43,200 --> 00:26:48,799
an equation callback and so rather than

00:26:46,559 --> 00:26:50,080
looking like it's calling a method on

00:26:48,799 --> 00:26:53,279
the server

00:26:50,080 --> 00:26:56,720
and the method on the client

00:26:53,279 --> 00:26:59,760
we send different messages between the

00:26:56,720 --> 00:27:02,080
server and the client and then respond

00:26:59,760 --> 00:27:04,840
to those accordingly

00:27:02,080 --> 00:27:06,080
which looks something like this in the

00:27:04,840 --> 00:27:09,600
implementation

00:27:06,080 --> 00:27:12,799
so this is our we have a start method

00:27:09,600 --> 00:27:16,400
there opens the streams and then

00:27:12,799 --> 00:27:19,039
uh runs them effectively

00:27:16,400 --> 00:27:19,520
it reads all the incoming messages off

00:27:19,039 --> 00:27:22,640
the

00:27:19,520 --> 00:27:25,440
request stream does a switch

00:27:22,640 --> 00:27:26,320
on the action case which is how the c

00:27:25,440 --> 00:27:29,679
sharp code gen

00:27:26,320 --> 00:27:31,840
in grpc and protobuf says this is the

00:27:29,679 --> 00:27:35,120
one-off field that was set

00:27:31,840 --> 00:27:37,279
and invokes the relevant method

00:27:35,120 --> 00:27:38,799
based on which one of those values was

00:27:37,279 --> 00:27:40,880
set this is a fairly

00:27:38,799 --> 00:27:42,960
simple implementation you can get

00:27:40,880 --> 00:27:46,480
yourself tied in knots with

00:27:42,960 --> 00:27:50,480
tasks and threading and so forth

00:27:46,480 --> 00:27:54,000
but again this does provide a way to map

00:27:50,480 --> 00:27:57,600
from uh a wcf duplex service to

00:27:54,000 --> 00:28:00,640
a grpc service and achieve the same

00:27:57,600 --> 00:28:03,919
end result we can even

00:28:00,640 --> 00:28:07,360
map wrap our

00:28:03,919 --> 00:28:09,919
response stream with a class that

00:28:07,360 --> 00:28:11,440
implements the old callback interface

00:28:09,919 --> 00:28:12,399
which would look something like this so

00:28:11,440 --> 00:28:15,679
here we have our

00:28:12,399 --> 00:28:17,919
calculator callback which

00:28:15,679 --> 00:28:18,960
is what the old wcf code would have been

00:28:17,919 --> 00:28:21,919
looking at

00:28:18,960 --> 00:28:22,240
to uh talk back to the client and we can

00:28:21,919 --> 00:28:24,799
just

00:28:22,240 --> 00:28:25,840
wrap the response stream and implement

00:28:24,799 --> 00:28:29,039
the same methods

00:28:25,840 --> 00:28:31,360
and just write these callback messages

00:28:29,039 --> 00:28:33,440
onto the response stream and do

00:28:31,360 --> 00:28:36,720
something similar on the client side

00:28:33,440 --> 00:28:39,679
to invoke those methods and again

00:28:36,720 --> 00:28:41,360
my tooling for doing this will

00:28:39,679 --> 00:28:42,880
automatically generate most of the code

00:28:41,360 --> 00:28:44,320
for doing that but it is possible to

00:28:42,880 --> 00:28:47,760
implement it

00:28:44,320 --> 00:28:49,600
manually as well so

00:28:47,760 --> 00:28:51,360
that basically covers most of the

00:28:49,600 --> 00:28:53,440
functionality

00:28:51,360 --> 00:28:54,960
there are a couple more points i want to

00:28:53,440 --> 00:28:58,000
mention there is the

00:28:54,960 --> 00:29:00,159
security aspect so with wcf

00:28:58,000 --> 00:29:01,600
because it was dot net only because it

00:29:00,159 --> 00:29:03,039
was windows only

00:29:01,600 --> 00:29:06,000
it meant you could use basic

00:29:03,039 --> 00:29:08,880
authentication uh you could use ntlm or

00:29:06,000 --> 00:29:11,600
kerberos or windows authentication

00:29:08,880 --> 00:29:13,360
also wcf didn't natively support

00:29:11,600 --> 00:29:14,799
encryption but there were the ws

00:29:13,360 --> 00:29:17,039
encryption standards

00:29:14,799 --> 00:29:18,720
and you could run it over an https

00:29:17,039 --> 00:29:20,480
connection if you were doing soap over

00:29:18,720 --> 00:29:24,000
http

00:29:20,480 --> 00:29:26,080
grpc because it uses http 2

00:29:24,000 --> 00:29:27,840
kerberos windows authentication is

00:29:26,080 --> 00:29:28,799
actually impossible you just can't do it

00:29:27,840 --> 00:29:32,320
http 2

00:29:28,799 --> 00:29:35,440
does not support it and so with grpc

00:29:32,320 --> 00:29:36,720
the standard authentication method is

00:29:35,440 --> 00:29:39,360
bearer tokens

00:29:36,720 --> 00:29:40,640
you can combine that with adfs you can

00:29:39,360 --> 00:29:42,640
get tokens

00:29:40,640 --> 00:29:43,840
from your active directory federation

00:29:42,640 --> 00:29:45,520
server

00:29:43,840 --> 00:29:47,440
and then you can use those as bearer

00:29:45,520 --> 00:29:49,880
tokens in your grpc

00:29:47,440 --> 00:29:52,159
application and then you can use the

00:29:49,880 --> 00:29:56,559
asp.net core

00:29:52,159 --> 00:29:58,640
built-in adfs authentication library

00:29:56,559 --> 00:30:01,679
to authenticate those calls on the

00:29:58,640 --> 00:30:04,880
server and obviously grpc also provides

00:30:01,679 --> 00:30:06,720
mutual tls where the client and server

00:30:04,880 --> 00:30:08,640
both provide a certificate

00:30:06,720 --> 00:30:10,399
and all communication is encrypted using

00:30:08,640 --> 00:30:11,520
that certificate and it also means that

00:30:10,399 --> 00:30:14,720
both sides

00:30:11,520 --> 00:30:16,960
can uh verify that the other

00:30:14,720 --> 00:30:20,240
party is the correct thing they are

00:30:16,960 --> 00:30:20,240
expecting to be connected to

00:30:20,399 --> 00:30:23,440
the final thing that i think is very

00:30:22,399 --> 00:30:26,480
interesting for

00:30:23,440 --> 00:30:28,960
all these.net shops who are finding

00:30:26,480 --> 00:30:31,760
their way in this new world of grpc

00:30:28,960 --> 00:30:32,240
is if they've been running on.net they

00:30:31,760 --> 00:30:34,720
are

00:30:32,240 --> 00:30:35,760
going to be used to a world of window

00:30:34,720 --> 00:30:38,960
servers

00:30:35,760 --> 00:30:40,720
just the net framework iis web farms and

00:30:38,960 --> 00:30:42,559
that sort of thing and i think there's a

00:30:40,720 --> 00:30:44,880
lot of

00:30:42,559 --> 00:30:45,760
companies out there who are going to be

00:30:44,880 --> 00:30:47,919
looking at

00:30:45,760 --> 00:30:49,039
things like docker and kubernetes and

00:30:47,919 --> 00:30:51,200
service meshes

00:30:49,039 --> 00:30:53,360
whether that's on premise or in

00:30:51,200 --> 00:30:54,399
different cloud environments

00:30:53,360 --> 00:30:57,600
and i think there's going to be some

00:30:54,399 --> 00:30:59,679
good opportunities for people to

00:30:57,600 --> 00:31:02,559
work with companies like that on a

00:30:59,679 --> 00:31:06,000
consulting or training basis

00:31:02,559 --> 00:31:08,720
to provide an introduction to the

00:31:06,000 --> 00:31:09,440
new ways of hosting applications now

00:31:08,720 --> 00:31:12,480
that

00:31:09,440 --> 00:31:15,840
dot net core runs nicely on uh

00:31:12,480 --> 00:31:18,799
linux platforms as well as windows

00:31:15,840 --> 00:31:19,679
if you'd like more detail on anything

00:31:18,799 --> 00:31:22,880
i've talked about

00:31:19,679 --> 00:31:23,279
in this presentation i have co-authored

00:31:22,880 --> 00:31:26,720
a book

00:31:23,279 --> 00:31:28,480
called grpc for wcf developers

00:31:26,720 --> 00:31:30,880
which is published for free on

00:31:28,480 --> 00:31:33,679
microsoft's website

00:31:30,880 --> 00:31:35,440
in their architecture and patterns area

00:31:33,679 --> 00:31:38,720
of their documentation website

00:31:35,440 --> 00:31:41,440
which you can find at that url

00:31:38,720 --> 00:31:43,440
i have spent much of the last 18 months

00:31:41,440 --> 00:31:45,679
working on visual recode

00:31:43,440 --> 00:31:47,200
which is a tool that will automatically

00:31:45,679 --> 00:31:50,080
take your wcf code

00:31:47,200 --> 00:31:52,480
and using some of the patterns that i've

00:31:50,080 --> 00:31:55,519
talked about here and some additional

00:31:52,480 --> 00:31:56,960
tricks automatically migrate it to

00:31:55,519 --> 00:32:00,320
asp.net core

00:31:56,960 --> 00:32:03,360
grpc it is a commercial project

00:32:00,320 --> 00:32:04,159
because it was too big to do as open

00:32:03,360 --> 00:32:07,120
source

00:32:04,159 --> 00:32:08,320
um and it's properly supported with

00:32:07,120 --> 00:32:11,679
support contracts

00:32:08,320 --> 00:32:13,760
and uh consulting and so forth but that

00:32:11,679 --> 00:32:14,880
is available if anybody is interested in

00:32:13,760 --> 00:32:17,840
that

00:32:14,880 --> 00:32:18,960
at the moment it does asp.net wcf to

00:32:17,840 --> 00:32:21,840
grpc

00:32:18,960 --> 00:32:24,159
it will be doing some additional types

00:32:21,840 --> 00:32:26,840
of conversion as well

00:32:24,159 --> 00:32:28,960
but that is available at

00:32:26,840 --> 00:32:32,159
visualrecode.com

00:32:28,960 --> 00:32:35,519
i hope that uh was helpful i hope it was

00:32:32,159 --> 00:32:38,159
informative um i hope you enjoyed it and

00:32:35,519 --> 00:32:40,159
i hope that if you are using wcf this

00:32:38,159 --> 00:32:42,559
has made you see that grpc

00:32:40,159 --> 00:32:44,880
can fulfill that need for you and if

00:32:42,559 --> 00:32:48,399
you're already using grpc

00:32:44,880 --> 00:32:51,039
then maybe reach out to some wcf

00:32:48,399 --> 00:32:53,279
uh teams if you know any and try and

00:32:51,039 --> 00:32:54,799
evangelize grpc to them and show them

00:32:53,279 --> 00:32:56,799
everything that it can do for them

00:32:54,799 --> 00:33:00,559
thank you very much and enjoy the rest

00:32:56,799 --> 00:33:00,559

YouTube URL: https://www.youtube.com/watch?v=l9p17yWaYsA


