Title: Stop Breaking the Proto! Designing for Change in an Microservices World - Ryan Michela, Salesforce
Publication date: 2020-08-01
Playlist: gRPC Conf 2020
Description: 
	Stop Breaking the Proto! Designing for Change in an Microservices World - Ryan Michela, Salesforce 

What's worse than having to deploy ten microservices? Having to deploy ten microservices at exactly the same time. When every change is a breaking API change, every deploy is a lockstep deploy. In this talk we explore techniques and best practices for evolving protobuf contracts without breaking downstream callers. We start by looking at what constitutes a breaking change, and then explore tactical ways to avoid breaking the service contract. Finally, we will dive into proto design patterns that can minimize the need to break our API contracts. Apply the techniques in this talk and never worry about breaking your downstream API callers again.
Captions: 
	00:00:00,080 --> 00:00:05,040
stop breaking the proto designing for

00:00:02,320 --> 00:00:07,359
change in a microservices world

00:00:05,040 --> 00:00:08,880
hello everybody my name is ryan michella

00:00:07,359 --> 00:00:10,960
and i work for salesforce building

00:00:08,880 --> 00:00:13,440
service meshes

00:00:10,960 --> 00:00:14,000
i've been building with grpc for four

00:00:13,440 --> 00:00:16,560
years now

00:00:14,000 --> 00:00:18,800
and started the reactive grpc project to

00:00:16,560 --> 00:00:22,240
bridge grpc and reactive programming

00:00:18,800 --> 00:00:22,240
technologies together in java

00:00:22,640 --> 00:00:27,439
this talk is about designing services

00:00:24,800 --> 00:00:28,640
using grpc to maximize the resiliency to

00:00:27,439 --> 00:00:31,359
change

00:00:28,640 --> 00:00:33,040
grpc services change all the time we

00:00:31,359 --> 00:00:35,360
learn more about our problem space and

00:00:33,040 --> 00:00:37,440
need to refactor our contracts

00:00:35,360 --> 00:00:40,160
we add new features to our services and

00:00:37,440 --> 00:00:42,079
need to expose them from within an api

00:00:40,160 --> 00:00:43,920
we discover our services have become too

00:00:42,079 --> 00:00:46,320
complicated and need to divide them into

00:00:43,920 --> 00:00:49,200
smaller independent parts

00:00:46,320 --> 00:00:51,120
changing our services is inevitable how

00:00:49,200 --> 00:00:52,800
we anticipate this change and prepare

00:00:51,120 --> 00:00:54,480
for it makes the difference between a

00:00:52,800 --> 00:00:56,879
small refactoring and a ground-up

00:00:54,480 --> 00:00:56,879
rewrite

00:00:57,039 --> 00:01:02,000
in this talk we'll look at techniques

00:00:59,359 --> 00:01:03,680
for accommodating change in our services

00:01:02,000 --> 00:01:06,479
we'll take advantage of the advantage of

00:01:03,680 --> 00:01:08,000
the capabilities afforded to us by grpc

00:01:06,479 --> 00:01:09,600
we'll look at how proto design

00:01:08,000 --> 00:01:11,200
techniques for keeping

00:01:09,600 --> 00:01:13,600
our service contracts healthy in the

00:01:11,200 --> 00:01:15,439
long term we'll look at project design

00:01:13,600 --> 00:01:16,960
techniques that help our code base adapt

00:01:15,439 --> 00:01:18,479
to changing requirements

00:01:16,960 --> 00:01:20,080
and finally we'll look at contract

00:01:18,479 --> 00:01:23,360
versioning techniques to help us stay

00:01:20,080 --> 00:01:25,439
sane as we upgrade our system

00:01:23,360 --> 00:01:27,360
before we dive in i find it helpful to

00:01:25,439 --> 00:01:30,079
review what makes a service

00:01:27,360 --> 00:01:32,000
here's my definition a service is a

00:01:30,079 --> 00:01:34,079
versionable bounded context of

00:01:32,000 --> 00:01:36,000
functionality exposing a well-defined

00:01:34,079 --> 00:01:37,680
public contract over standardized

00:01:36,000 --> 00:01:40,079
plumbing and encapsulating a single

00:01:37,680 --> 00:01:42,079
cohesive concept

00:01:40,079 --> 00:01:43,759
that's a lot but note how it doesn't say

00:01:42,079 --> 00:01:45,840
anything about deployment

00:01:43,759 --> 00:01:48,720
monoliths and microservices are just

00:01:45,840 --> 00:01:51,280
different ways to package services

00:01:48,720 --> 00:01:52,880
while this talk focuses on microservices

00:01:51,280 --> 00:01:55,840
the guidance applies equally well to

00:01:52,880 --> 00:01:55,840
monoliths

00:01:55,920 --> 00:02:00,799
three aspects of this definition pertain

00:01:58,079 --> 00:02:02,960
directly to grpc

00:02:00,799 --> 00:02:04,320
a service needs to have a well-defined

00:02:02,960 --> 00:02:06,000
explicit contract

00:02:04,320 --> 00:02:07,680
that defines all of the operations and

00:02:06,000 --> 00:02:08,959
data structures needed to interact with

00:02:07,680 --> 00:02:11,840
the service

00:02:08,959 --> 00:02:13,200
this car this contract serves as a

00:02:11,840 --> 00:02:15,200
separate

00:02:13,200 --> 00:02:17,599
the external api from the internal

00:02:15,200 --> 00:02:19,520
implementation details

00:02:17,599 --> 00:02:21,120
ideally no special knowledge should be

00:02:19,520 --> 00:02:23,200
needed to call the service

00:02:21,120 --> 00:02:25,280
outside of what's in the contract this

00:02:23,200 --> 00:02:26,959
means no mandatory metadata or magic

00:02:25,280 --> 00:02:28,800
request headers

00:02:26,959 --> 00:02:30,480
it's also important for a service to be

00:02:28,800 --> 00:02:32,959
independently versionable so it can

00:02:30,480 --> 00:02:35,760
evolve separately from its dependencies

00:02:32,959 --> 00:02:37,440
independent versioning means one service

00:02:35,760 --> 00:02:39,120
can expose multiple versions of its

00:02:37,440 --> 00:02:40,959
contract simultaneously

00:02:39,120 --> 00:02:42,640
for example a service might implement

00:02:40,959 --> 00:02:44,879
credit card processing v1

00:02:42,640 --> 00:02:47,760
and v2 contracts while having 15

00:02:44,879 --> 00:02:50,080
independent binary releases over time

00:02:47,760 --> 00:02:51,440
finally a service should embody a single

00:02:50,080 --> 00:02:54,080
cohesive concept

00:02:51,440 --> 00:02:55,840
cohesion is a common ideal in software

00:02:54,080 --> 00:02:57,360
and helps us prevent service contracts

00:02:55,840 --> 00:03:00,480
from turning into a dumping ground of

00:02:57,360 --> 00:03:00,480
unrelated operations

00:03:00,640 --> 00:03:04,560
grpc is an ideal fit to the service

00:03:03,200 --> 00:03:06,159
definition

00:03:04,560 --> 00:03:08,159
with many of its properties aligning

00:03:06,159 --> 00:03:11,280
nicely to what we want for example

00:03:08,159 --> 00:03:13,360
grpc is contract first protofiles

00:03:11,280 --> 00:03:15,120
are independently versionable and

00:03:13,360 --> 00:03:17,760
cleanly separate a services contract

00:03:15,120 --> 00:03:19,680
from its implementation details

00:03:17,760 --> 00:03:21,280
strongly typed with built-in backwards

00:03:19,680 --> 00:03:23,360
and forwards compatibility which makes

00:03:21,280 --> 00:03:26,080
versioning our contracts easier

00:03:23,360 --> 00:03:27,200
finally grpc is natively multiplexed

00:03:26,080 --> 00:03:29,040
which allows multiple

00:03:27,200 --> 00:03:31,360
allows us to host multiple versions of

00:03:29,040 --> 00:03:32,480
the same contract in the same process on

00:03:31,360 --> 00:03:34,319
the same port

00:03:32,480 --> 00:03:35,680
this lets us cleanly separate service

00:03:34,319 --> 00:03:39,200
discovery from version

00:03:35,680 --> 00:03:40,239
version selection now that we've

00:03:39,200 --> 00:03:42,400
identified

00:03:40,239 --> 00:03:43,360
what parts of alpha what we want from an

00:03:42,400 --> 00:03:44,879
ideal service

00:03:43,360 --> 00:03:46,799
let's look at some techniques to get

00:03:44,879 --> 00:03:49,599
ourselves there starting with protobuf

00:03:46,799 --> 00:03:49,599
design techniques

00:03:50,560 --> 00:03:53,840
the first thing we want to do is

00:03:51,840 --> 00:03:54,959
establish rules around proto-contract

00:03:53,840 --> 00:03:56,720
versioning

00:03:54,959 --> 00:03:58,080
semantic versioning is a great place to

00:03:56,720 --> 00:04:00,080
start when we apply

00:03:58,080 --> 00:04:01,680
semver to proto-contracts we can map

00:04:00,080 --> 00:04:04,080
different kinds of changes to each of

00:04:01,680 --> 00:04:06,319
the version components

00:04:04,080 --> 00:04:08,159
major versions of a contract are

00:04:06,319 --> 00:04:08,560
fundamentally incompatible with each

00:04:08,159 --> 00:04:12,560
other

00:04:08,560 --> 00:04:15,200
for example http 1 and 2. minor changes

00:04:12,560 --> 00:04:16,479
are interoperable within the same major

00:04:15,200 --> 00:04:18,160
version series

00:04:16,479 --> 00:04:20,400
minor changes are typically additive in

00:04:18,160 --> 00:04:23,440
nature such as adding new fields

00:04:20,400 --> 00:04:25,360
or operations to a contract finally

00:04:23,440 --> 00:04:29,840
patch versions are for non-functional

00:04:25,360 --> 00:04:29,840
changes like documentation improvements

00:04:30,400 --> 00:04:34,000
once you've established semver as a

00:04:32,479 --> 00:04:34,800
versioning system for your proto

00:04:34,000 --> 00:04:36,639
contracts

00:04:34,800 --> 00:04:39,040
you should put the major version in the

00:04:36,639 --> 00:04:41,199
contract and enter the protocol

00:04:39,040 --> 00:04:42,639
package doing so gives us three

00:04:41,199 --> 00:04:44,960
advantages

00:04:42,639 --> 00:04:45,680
first it's clear from looking at the

00:04:44,960 --> 00:04:47,680
contract

00:04:45,680 --> 00:04:49,600
which compatible series of versions the

00:04:47,680 --> 00:04:51,600
contract belongs to

00:04:49,600 --> 00:04:53,040
second putting the version of the packet

00:04:51,600 --> 00:04:54,880
in the version in the package

00:04:53,040 --> 00:04:56,080
makes it easy to multiplex multiple

00:04:54,880 --> 00:04:59,360
versions of the same contract

00:04:56,080 --> 00:04:59,840
in a service grpc uses the whole package

00:04:59,360 --> 00:05:01,680
name

00:04:59,840 --> 00:05:03,039
and operation name when routing requests

00:05:01,680 --> 00:05:04,560
to an implementation

00:05:03,039 --> 00:05:06,080
putting the version in the package name

00:05:04,560 --> 00:05:07,120
eliminates any conflict

00:05:06,080 --> 00:05:09,120
between different version

00:05:07,120 --> 00:05:10,560
implementations of an operation with the

00:05:09,120 --> 00:05:12,639
same name

00:05:10,560 --> 00:05:14,560
finally putting the major version in the

00:05:12,639 --> 00:05:16,000
package name prevents type conflicts and

00:05:14,560 --> 00:05:18,960
generated code

00:05:16,000 --> 00:05:19,680
protoc translates contact contract

00:05:18,960 --> 00:05:22,560
namespace

00:05:19,680 --> 00:05:24,080
into code namespace creating a unique

00:05:22,560 --> 00:05:25,680
namespace for each version

00:05:24,080 --> 00:05:29,280
allows similar types from different

00:05:25,680 --> 00:05:29,280
versions to co-exist peacefully

00:05:32,800 --> 00:05:36,960
with our contract version package sorted

00:05:34,880 --> 00:05:38,240
out the next thing we should look at is

00:05:36,960 --> 00:05:40,880
proto style

00:05:38,240 --> 00:05:41,520
google has published multiple grpc style

00:05:40,880 --> 00:05:43,120
guides

00:05:41,520 --> 00:05:45,280
sticking to the official style guides

00:05:43,120 --> 00:05:47,199
ensures consistencies between our protos

00:05:45,280 --> 00:05:48,639
helps avoid some language specific code

00:05:47,199 --> 00:05:50,479
generation quirks

00:05:48,639 --> 00:05:53,440
and prevents unintentionally breaking

00:05:50,479 --> 00:05:55,680
changes from entering the contract

00:05:53,440 --> 00:05:57,680
the open source community has some great

00:05:55,680 --> 00:05:59,360
automated tools you can use to enforce

00:05:57,680 --> 00:06:00,319
style and compatibility checks

00:05:59,360 --> 00:06:03,039
automatically

00:06:00,319 --> 00:06:06,720
the google aip linter and protoloc are

00:06:03,039 --> 00:06:08,880
two that first come to mind

00:06:06,720 --> 00:06:10,560
a common problem with service contracts

00:06:08,880 --> 00:06:11,520
is that they tend to grow organically

00:06:10,560 --> 00:06:13,759
over time

00:06:11,520 --> 00:06:16,479
they start cohesive but lose focus as

00:06:13,759 --> 00:06:19,120
new operations are added one at a time

00:06:16,479 --> 00:06:20,240
the contract is soon a mess it's

00:06:19,120 --> 00:06:21,840
important to recognize

00:06:20,240 --> 00:06:23,919
when this is happening and correct it by

00:06:21,840 --> 00:06:25,759
breaking an unfocused contract

00:06:23,919 --> 00:06:27,280
into separate cohesive contracts with a

00:06:25,759 --> 00:06:29,199
new version

00:06:27,280 --> 00:06:31,199
this is just like the interface

00:06:29,199 --> 00:06:34,479
segmentation principle

00:06:31,199 --> 00:06:37,280
of the solid oop principles for example

00:06:34,479 --> 00:06:39,520
we can split the complex v1 contracts

00:06:37,280 --> 00:06:40,479
seen here into three cohesive v2

00:06:39,520 --> 00:06:43,440
contracts

00:06:40,479 --> 00:06:45,280
for each for a facet of the service crud

00:06:43,440 --> 00:06:47,360
search and signing

00:06:45,280 --> 00:06:48,800
clients that need search but not signing

00:06:47,360 --> 00:06:52,800
no longer need to import

00:06:48,800 --> 00:06:54,639
unneeded apis applying isp to grpc

00:06:52,800 --> 00:06:56,319
contracts promotes cohesion

00:06:54,639 --> 00:06:58,720
amongst each service's contract

00:06:56,319 --> 00:07:00,080
operations furthermore consumers only

00:06:58,720 --> 00:07:04,080
reference the subset

00:07:00,080 --> 00:07:06,240
behavior that they need from a service

00:07:04,080 --> 00:07:07,120
this reduces client churn when contract

00:07:06,240 --> 00:07:10,319
changes happen

00:07:07,120 --> 00:07:14,160
because each so us because each smaller

00:07:10,319 --> 00:07:14,160
contract can be versioned independently

00:07:15,120 --> 00:07:18,720
ensuring our message types are cohesive

00:07:17,199 --> 00:07:20,560
is just as important as having a

00:07:18,720 --> 00:07:22,880
cohesive service

00:07:20,560 --> 00:07:25,199
a common mistake when defining services

00:07:22,880 --> 00:07:26,720
is to share requests and response types

00:07:25,199 --> 00:07:28,720
requests and response types should be

00:07:26,720 --> 00:07:31,120
exclusive to a grpc operation

00:07:28,720 --> 00:07:32,639
even if the contents look identical

00:07:31,120 --> 00:07:34,319
think of them as parameter lists for

00:07:32,639 --> 00:07:36,080
their respective functions

00:07:34,319 --> 00:07:37,680
even though two functions share a

00:07:36,080 --> 00:07:39,440
similar signature it doesn't mean that

00:07:37,680 --> 00:07:41,360
their parameter lists are literally the

00:07:39,440 --> 00:07:42,800
same construct

00:07:41,360 --> 00:07:44,639
keeping separate types gives you the

00:07:42,800 --> 00:07:46,560
flexibility to augment one operation in

00:07:44,639 --> 00:07:48,160
the future without impacting the api of

00:07:46,560 --> 00:07:50,479
other operations

00:07:48,160 --> 00:07:51,360
now this force duplication only goes one

00:07:50,479 --> 00:07:53,680
layer deep

00:07:51,360 --> 00:07:55,280
the type types used by request and

00:07:53,680 --> 00:07:56,000
response messages can be shared as

00:07:55,280 --> 00:07:58,560
needed

00:07:56,000 --> 00:08:00,720
for example a find cocktail response and

00:07:58,560 --> 00:08:01,840
a get cocktail response can both return

00:08:00,720 --> 00:08:03,840
a recipe object

00:08:01,840 --> 00:08:05,280
this sharing is okay because recipe is

00:08:03,840 --> 00:08:06,960
part of the domain model

00:08:05,280 --> 00:08:10,840
while request and response messages are

00:08:06,960 --> 00:08:12,319
tightly coupled to the rpc operations

00:08:10,840 --> 00:08:14,160
themselves

00:08:12,319 --> 00:08:16,080
so far we've focused on techniques for

00:08:14,160 --> 00:08:18,720
keeping individual proto contracts

00:08:16,080 --> 00:08:20,319
flexible and accommodating future change

00:08:18,720 --> 00:08:22,160
now let's look at ways we can structure

00:08:20,319 --> 00:08:23,440
our project to ensure we don't paint our

00:08:22,160 --> 00:08:27,840
code into a corner

00:08:23,440 --> 00:08:27,840
while our service contracts change

00:08:29,440 --> 00:08:32,640
the first and most important rule when

00:08:31,199 --> 00:08:34,800
coding against grpc

00:08:32,640 --> 00:08:36,399
is to never pass around proto-generated

00:08:34,800 --> 00:08:38,399
classes

00:08:36,399 --> 00:08:40,479
it seems like a convenient shortcut to

00:08:38,399 --> 00:08:42,719
use generated protoclasses as your

00:08:40,479 --> 00:08:46,000
domain objects for data transfer objects

00:08:42,719 --> 00:08:47,920
but resist this urge generated

00:08:46,000 --> 00:08:49,279
protoclasses will come back to haunt you

00:08:47,920 --> 00:08:51,760
in many ways

00:08:49,279 --> 00:08:52,880
first the generated just make terrible

00:08:51,760 --> 00:08:54,959
dtos

00:08:52,880 --> 00:08:56,720
in some languages their api is really

00:08:54,959 --> 00:08:57,600
unwieldy and the objects themselves are

00:08:56,720 --> 00:08:59,040
immutable

00:08:57,600 --> 00:09:00,720
this really clutters up the code that

00:08:59,040 --> 00:09:03,040
uses these types

00:09:00,720 --> 00:09:05,200
second generated protoclasses are not

00:09:03,040 --> 00:09:07,200
often open to expand extension

00:09:05,200 --> 00:09:09,120
adding behavior to these classes is

00:09:07,200 --> 00:09:10,800
either unnatural in your language or

00:09:09,120 --> 00:09:13,279
outright impossible

00:09:10,800 --> 00:09:15,200
and finally using generated protoclasses

00:09:13,279 --> 00:09:17,760
in your logic couples your code to a

00:09:15,200 --> 00:09:19,279
particular version of the contract

00:09:17,760 --> 00:09:20,959
this is a mistake that will bite you the

00:09:19,279 --> 00:09:23,440
hardest when major version changes

00:09:20,959 --> 00:09:25,519
needed if your business logic is defined

00:09:23,440 --> 00:09:27,120
in terms of v1 generated types

00:09:25,519 --> 00:09:29,760
you'll need to do a major rewrite to

00:09:27,120 --> 00:09:32,240
redefine in terms of v2 generated types

00:09:29,760 --> 00:09:36,480
and good luck supporting v1 and v2 types

00:09:32,240 --> 00:09:38,399
at the same time with the same code

00:09:36,480 --> 00:09:41,360
so how can we structure our code so that

00:09:38,399 --> 00:09:43,360
we never depend on generated protos

00:09:41,360 --> 00:09:44,959
i like to use a three module layout when

00:09:43,360 --> 00:09:47,519
building a service

00:09:44,959 --> 00:09:49,440
let's start with the middle module the

00:09:47,519 --> 00:09:51,760
implementation module

00:09:49,440 --> 00:09:54,240
the implementation module is pure it has

00:09:51,760 --> 00:09:55,760
zero proto or grpc dependencies

00:09:54,240 --> 00:09:58,240
it's also where all of our business

00:09:55,760 --> 00:10:00,399
logic goes business operations accept

00:09:58,240 --> 00:10:01,040
and return only dtos and primitive data

00:10:00,399 --> 00:10:03,040
types

00:10:01,040 --> 00:10:06,560
which allows it to be completely unit

00:10:03,040 --> 00:10:08,720
testable without any references to grpc

00:10:06,560 --> 00:10:10,640
upstream dependencies we call like other

00:10:08,720 --> 00:10:11,600
services or data stores are represented

00:10:10,640 --> 00:10:14,800
in this module

00:10:11,600 --> 00:10:16,560
using simple type interfaces unit tests

00:10:14,800 --> 00:10:17,600
can mock these interfaces so that the

00:10:16,560 --> 00:10:20,880
tests are

00:10:17,600 --> 00:10:23,600
completely self-contained above the

00:10:20,880 --> 00:10:25,760
implementation module is the api module

00:10:23,600 --> 00:10:28,000
this module is where grpc generated

00:10:25,760 --> 00:10:29,519
proto classes and the grpc server stub

00:10:28,000 --> 00:10:31,920
lives

00:10:29,519 --> 00:10:33,279
no business logic is in this layer all

00:10:31,920 --> 00:10:35,200
server stubs delegate to the

00:10:33,279 --> 00:10:37,680
implementation module below

00:10:35,200 --> 00:10:39,120
doing proto-dto object translation as

00:10:37,680 --> 00:10:41,440
needed

00:10:39,120 --> 00:10:43,360
if a contract has more than one version

00:10:41,440 --> 00:10:45,600
each version's generated stubs

00:10:43,360 --> 00:10:47,200
call down into the shared implementation

00:10:45,600 --> 00:10:48,880
we can implement the adapter pattern

00:10:47,200 --> 00:10:50,320
where necessary

00:10:48,880 --> 00:10:53,279
this way you don't have to duplicate

00:10:50,320 --> 00:10:54,880
your business logic between versions

00:10:53,279 --> 00:10:57,200
the bottom layer is our dependencies

00:10:54,880 --> 00:10:58,800
module this module provides concrete

00:10:57,200 --> 00:11:01,440
implementations for each upstream

00:10:58,800 --> 00:11:03,440
dependency used by the logic

00:11:01,440 --> 00:11:04,880
once again there's no business logic in

00:11:03,440 --> 00:11:06,880
this layer

00:11:04,880 --> 00:11:08,560
just implements the interfaces provided

00:11:06,880 --> 00:11:11,200
by the implementation module

00:11:08,560 --> 00:11:12,959
in terms of their upstream services if

00:11:11,200 --> 00:11:14,800
you want you can wrap all three layers

00:11:12,959 --> 00:11:18,160
in an ioc container to automatically

00:11:14,800 --> 00:11:18,160
wire them together at runtime

00:11:18,880 --> 00:11:22,959
let's recap we've looked at techniques

00:11:21,200 --> 00:11:25,200
for structuring our proto contracts to

00:11:22,959 --> 00:11:26,560
keep them flexible in the face of change

00:11:25,200 --> 00:11:28,560
and we've looked at project layout

00:11:26,560 --> 00:11:29,760
techniques to ensure our code stays just

00:11:28,560 --> 00:11:31,519
as adaptable

00:11:29,760 --> 00:11:32,880
but how do we best manage contract

00:11:31,519 --> 00:11:34,560
change itself

00:11:32,880 --> 00:11:36,240
to answer that question we have to look

00:11:34,560 --> 00:11:42,320
at some techniques for managing contract

00:11:36,240 --> 00:11:44,079
change over time

00:11:42,320 --> 00:11:45,600
the first step to managing contract

00:11:44,079 --> 00:11:47,360
change is accepting that breaking

00:11:45,600 --> 00:11:48,959
changes will happen

00:11:47,360 --> 00:11:50,880
i've worked on projects before that went

00:11:48,959 --> 00:11:52,880
on to unnatural lengths to avoid

00:11:50,880 --> 00:11:54,639
breaking changes

00:11:52,880 --> 00:11:57,040
the results were harder to work with and

00:11:54,639 --> 00:11:59,519
the breaking change would have been

00:11:57,040 --> 00:12:01,040
for example don't co-mingle versions of

00:11:59,519 --> 00:12:02,639
the same contract

00:12:01,040 --> 00:12:04,880
this would be like putting grpc

00:12:02,639 --> 00:12:07,839
operations called get cocktail v1

00:12:04,880 --> 00:12:09,519
and get cocktail v2 and get cocktail v3

00:12:07,839 --> 00:12:10,720
in the same proto each with different

00:12:09,519 --> 00:12:12,480
signatures

00:12:10,720 --> 00:12:14,560
not only does this bloat your contract

00:12:12,480 --> 00:12:16,480
and to decrease its cohesiveness

00:12:14,560 --> 00:12:18,480
but it also makes it nearly impossible

00:12:16,480 --> 00:12:20,560
to cleanly cut over from one new version

00:12:18,480 --> 00:12:22,720
to another

00:12:20,560 --> 00:12:24,240
another thing to avoid version is to ver

00:12:22,720 --> 00:12:25,519
another thing is to avoid versioning

00:12:24,240 --> 00:12:28,639
independent

00:12:25,519 --> 00:12:30,720
operations instead

00:12:28,639 --> 00:12:33,200
of the whole contract this would be like

00:12:30,720 --> 00:12:35,920
putting get cocktail v2 in a veto

00:12:33,200 --> 00:12:38,320
v2 contract all by itself and relying on

00:12:35,920 --> 00:12:40,079
the v1 contract for everything else

00:12:38,320 --> 00:12:41,600
new developers need to reference two

00:12:40,079 --> 00:12:43,279
different proto contracts

00:12:41,600 --> 00:12:45,279
to work with your service while also

00:12:43,279 --> 00:12:46,480
knowing which v1 operations have been

00:12:45,279 --> 00:12:48,480
deprecated

00:12:46,480 --> 00:12:50,560
instead version the entire contract

00:12:48,480 --> 00:12:53,279
anytime any operation

00:12:50,560 --> 00:12:54,560
experiences a breaking change

00:12:53,279 --> 00:12:57,040
unfortunately

00:12:54,560 --> 00:12:58,560
versioning a whole contract is painful

00:12:57,040 --> 00:13:00,480
there's a new proto to distribute

00:12:58,560 --> 00:13:02,079
new stubs to write more marshalling code

00:13:00,480 --> 00:13:04,800
is needed you need to integrate with

00:13:02,079 --> 00:13:07,040
your implementation layer

00:13:04,800 --> 00:13:08,800
this should be avoided whenever possible

00:13:07,040 --> 00:13:10,240
but not to the point of contorting your

00:13:08,800 --> 00:13:12,399
code base

00:13:10,240 --> 00:13:13,839
additive changes optional fields and

00:13:12,399 --> 00:13:15,120
flags can go a long way

00:13:13,839 --> 00:13:17,200
towards extending the life of your

00:13:15,120 --> 00:13:18,639
contract for example

00:13:17,200 --> 00:13:20,959
you want to introduce machine

00:13:18,639 --> 00:13:22,720
translation to your cocktail service

00:13:20,959 --> 00:13:24,720
instead of breaking the whole contract

00:13:22,720 --> 00:13:27,200
to introduce this capability you can add

00:13:24,720 --> 00:13:28,000
a translate to language field to get

00:13:27,200 --> 00:13:30,959
contract

00:13:28,000 --> 00:13:33,040
get cocktail operation old clients won't

00:13:30,959 --> 00:13:34,800
know about this field and won't send it

00:13:33,040 --> 00:13:36,240
new clients can request translation by

00:13:34,800 --> 00:13:39,199
setting the field while

00:13:36,240 --> 00:13:42,639
old clients continue to work just as is

00:13:39,199 --> 00:13:44,160
no breaking changes are necessary

00:13:42,639 --> 00:13:46,720
if however you decide to break a

00:13:44,160 --> 00:13:47,199
contract use it as an opportunity to do

00:13:46,720 --> 00:13:49,279
the right

00:13:47,199 --> 00:13:50,959
refactoring you've held off on

00:13:49,279 --> 00:13:51,760
frequently breaking a contract with

00:13:50,959 --> 00:13:53,440
small changes

00:13:51,760 --> 00:13:56,000
isn't really annoying to your downstream

00:13:53,440 --> 00:13:56,000
consumers

00:13:56,480 --> 00:14:00,800
as we've seen service contracts

00:13:58,480 --> 00:14:02,720
sometimes change in incompatible ways

00:14:00,800 --> 00:14:03,839
necessitating a breaking change to the

00:14:02,720 --> 00:14:06,320
contract

00:14:03,839 --> 00:14:07,600
luckily grpc has some built-in smarts to

00:14:06,320 --> 00:14:10,160
accommodating running

00:14:07,600 --> 00:14:10,639
multiple contract versions side by side

00:14:10,160 --> 00:14:13,680
remember

00:14:10,639 --> 00:14:15,519
grpc is natively multiplexing this means

00:14:13,680 --> 00:14:16,800
that multiple contract implementations

00:14:15,519 --> 00:14:18,720
can share the same port

00:14:16,800 --> 00:14:20,880
and the same process as long as they

00:14:18,720 --> 00:14:22,480
have different name spaces

00:14:20,880 --> 00:14:24,160
if you put the major contract version

00:14:22,480 --> 00:14:25,199
into the proto namespace this won't be a

00:14:24,160 --> 00:14:26,959
problem for you

00:14:25,199 --> 00:14:28,720
you just have to implement each server

00:14:26,959 --> 00:14:30,000
stub independently and wire them up

00:14:28,720 --> 00:14:32,079
against your shared business logic

00:14:30,000 --> 00:14:33,839
layer when working with multiple

00:14:32,079 --> 00:14:35,519
contract versions i like to keep

00:14:33,839 --> 00:14:37,040
three different versions active at the

00:14:35,519 --> 00:14:39,360
same time

00:14:37,040 --> 00:14:41,760
the v current version is what we want

00:14:39,360 --> 00:14:44,079
our current consumers to use today

00:14:41,760 --> 00:14:46,000
the previous version is what callers who

00:14:44,079 --> 00:14:47,760
haven't upgraded are still using

00:14:46,000 --> 00:14:49,199
you may need more than one of these if

00:14:47,760 --> 00:14:51,199
you have downstream callers who are

00:14:49,199 --> 00:14:52,720
really slow to upgrade

00:14:51,199 --> 00:14:54,480
when you start working on a new version

00:14:52,720 --> 00:14:56,560
of your contract you can publish it as a

00:14:54,480 --> 00:14:58,560
v-next version and only share the

00:14:56,560 --> 00:15:00,240
contract with select partners

00:14:58,560 --> 00:15:02,320
this way you can rapidly iterate on

00:15:00,240 --> 00:15:03,440
vnext without sacrificing the stability

00:15:02,320 --> 00:15:07,519
of v current or v

00:15:03,440 --> 00:15:08,959
previous i hope you've learned something

00:15:07,519 --> 00:15:11,040
today and feel more confident in

00:15:08,959 --> 00:15:12,720
managing change in your services

00:15:11,040 --> 00:15:14,959
we've covered proto design techniques

00:15:12,720 --> 00:15:16,959
for handling change within a contract

00:15:14,959 --> 00:15:18,880
we've covered the layout techniques for

00:15:16,959 --> 00:15:19,600
handling chain contract change within

00:15:18,880 --> 00:15:21,680
our code

00:15:19,600 --> 00:15:23,360
and finally we've covered contract

00:15:21,680 --> 00:15:25,199
versioning techniques for managing

00:15:23,360 --> 00:15:26,800
changes between contract versions over

00:15:25,199 --> 00:15:28,639
time

00:15:26,800 --> 00:15:30,480
if you take nothing else away remember

00:15:28,639 --> 00:15:32,880
this the contract version

00:15:30,480 --> 00:15:35,120
is not your implementation version don't

00:15:32,880 --> 00:15:37,120
couple the two together

00:15:35,120 --> 00:15:39,120
change is inevitable you can either

00:15:37,120 --> 00:15:40,800
anticipate it in your design or be run

00:15:39,120 --> 00:15:42,240
over by it when it comes

00:15:40,800 --> 00:15:44,720
and finally you need to practice

00:15:42,240 --> 00:15:46,160
deliberate design your proto contract is

00:15:44,720 --> 00:15:47,040
the most important interface to your

00:15:46,160 --> 00:15:48,639
service

00:15:47,040 --> 00:15:50,320
you can change an implementation all you

00:15:48,639 --> 00:15:53,040
want but if you break the contract your

00:15:50,320 --> 00:15:54,800
changes will affect everyone around you

00:15:53,040 --> 00:15:57,040
we've covered a lot i'm sure you have

00:15:54,800 --> 00:15:58,399
questions i'm available on twitter and

00:15:57,040 --> 00:16:02,480
on the stream to answer them

00:15:58,399 --> 00:16:02,480

YouTube URL: https://www.youtube.com/watch?v=hbxOO2wnA1Y


