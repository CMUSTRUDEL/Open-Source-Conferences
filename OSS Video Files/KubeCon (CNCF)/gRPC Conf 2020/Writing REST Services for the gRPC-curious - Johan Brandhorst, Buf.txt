Title: Writing REST Services for the gRPC-curious - Johan Brandhorst, Buf
Publication date: 2020-08-01
Playlist: gRPC Conf 2020
Description: 
	Writing REST Services for the gRPC-curious - Johan Brandhorst, Buf 

Introducing the gRPC-Gateway, which makes it possible to expose a JSON/REST interface while maintaining many of the benefits of using gRPC.

The first 10 or so minutes will be spent laying the technical ground for the talk by talking about JSON/REST, giving a quick intro into gRPC and [protocol buffers](https://developers.google.com/protocol-buffers/), then introducing the gRPC-Gateway as a way to integrate gRPC into existing architectures with strict JSON/REST interface requirements.

There will then be a live demo showing the power of this workflow by iterating on a simple design. The audience will be able to follow along on their own by cloning the [boilerplate repository](https://github.com/johanbrandhorst/grpc-gateway-boilerplate).

Gradually more complicated topics like PATCH requests, middleware, authentication, working with browser clients, cookies, WebSockets and more will be introduced.
Captions: 
	00:00:01,040 --> 00:00:05,279
hi everyone i'm johan

00:00:03,199 --> 00:00:08,000
i'm a maintainer of various open source

00:00:05,279 --> 00:00:11,120
projects including the grpc gateway and

00:00:08,000 --> 00:00:11,599
improbable grpc web i've contributed to

00:00:11,120 --> 00:00:14,000
go

00:00:11,599 --> 00:00:15,679
and i run a blog writing mainly about go

00:00:14,000 --> 00:00:17,920
and grpc

00:00:15,679 --> 00:00:20,960
this is my first grpc conf and it's

00:00:17,920 --> 00:00:20,960
great to be part of it

00:00:21,680 --> 00:00:26,400
i work at buff where we are working on

00:00:24,320 --> 00:00:26,960
api management tooling for protobuf

00:00:26,400 --> 00:00:29,439
users

00:00:26,960 --> 00:00:31,439
through schema-driven development we

00:00:29,439 --> 00:00:33,120
already support linting of protofiles

00:00:31,439 --> 00:00:34,559
and breaking change detection and we've

00:00:33,120 --> 00:00:35,120
got some really exciting products in the

00:00:34,559 --> 00:00:37,040
works

00:00:35,120 --> 00:00:39,200
including the buff schema registry and

00:00:37,040 --> 00:00:41,440
automated protobuf file generation

00:00:39,200 --> 00:00:43,680
and dependency management check out our

00:00:41,440 --> 00:00:46,640
website for more information

00:00:43,680 --> 00:00:46,640
let's dive into the talk

00:00:47,039 --> 00:00:51,039
today we're going to look at what we

00:00:49,120 --> 00:00:53,199
mean by http json

00:00:51,039 --> 00:00:55,520
what it's used for and explore some

00:00:53,199 --> 00:00:57,360
problems associated with it

00:00:55,520 --> 00:01:00,320
we're then going to learn about how we

00:00:57,360 --> 00:01:03,520
can get the best of both worlds

00:01:00,320 --> 00:01:06,320
but best of both grpc and http json

00:01:03,520 --> 00:01:06,880
with the grpc gateway we'll then have

00:01:06,320 --> 00:01:10,080
some dem

00:01:06,880 --> 00:01:14,960
live demo of it in action

00:01:10,080 --> 00:01:14,960
what do we mean when we say http json

00:01:15,119 --> 00:01:18,960
we mean a restful interface making use

00:01:17,360 --> 00:01:22,880
of the http verbs

00:01:18,960 --> 00:01:25,280
get post put patch delete

00:01:22,880 --> 00:01:26,400
and using json as the payload content

00:01:25,280 --> 00:01:28,479
type

00:01:26,400 --> 00:01:30,560
this is the de facto standard for most

00:01:28,479 --> 00:01:32,799
public apis today

00:01:30,560 --> 00:01:33,920
sometimes it's not entirely restful but

00:01:32,799 --> 00:01:37,200
it's almost always

00:01:33,920 --> 00:01:37,840
using json it's easy for humans to read

00:01:37,200 --> 00:01:40,159
and write

00:01:37,840 --> 00:01:42,399
it's got native javascript support all

00:01:40,159 --> 00:01:46,079
is well right

00:01:42,399 --> 00:01:47,119
is everything well as anyone who's ever

00:01:46,079 --> 00:01:49,280
had to quickly push

00:01:47,119 --> 00:01:50,880
a configuration fix to your json

00:01:49,280 --> 00:01:53,759
configured service notes

00:01:50,880 --> 00:01:54,720
trailing commas are forbidden in json i

00:01:53,759 --> 00:01:56,640
wish i was joking

00:01:54,720 --> 00:01:58,240
in saying that this is a big problem but

00:01:56,640 --> 00:02:00,240
entirely new formats have been developed

00:01:58,240 --> 00:02:02,560
to deal with this problem

00:02:00,240 --> 00:02:04,719
there's also no support for comments

00:02:02,560 --> 00:02:07,200
it's unnecessarily verbose on the wire

00:02:04,719 --> 00:02:08,720
but compression can help mitigate this

00:02:07,200 --> 00:02:10,959
in large deployments

00:02:08,720 --> 00:02:13,840
the marshalling and unmarshaling of json

00:02:10,959 --> 00:02:16,720
is a constant strain on response latency

00:02:13,840 --> 00:02:17,120
most importantly it's not well typed

00:02:16,720 --> 00:02:18,959
enough

00:02:17,120 --> 00:02:20,640
and there's no single way to define the

00:02:18,959 --> 00:02:22,800
interface types

00:02:20,640 --> 00:02:24,319
open api is an option but it's not

00:02:22,800 --> 00:02:25,680
globally adopted

00:02:24,319 --> 00:02:27,680
most of these problems stem from the

00:02:25,680 --> 00:02:29,840
fact that json was designed to be

00:02:27,680 --> 00:02:31,519
human readable but also effective for a

00:02:29,840 --> 00:02:34,840
machine to use

00:02:31,519 --> 00:02:37,840
these two properties are unfortunately

00:02:34,840 --> 00:02:37,840
incompatible

00:02:38,000 --> 00:02:42,560
protocol buffers ngrpc provides all the

00:02:40,319 --> 00:02:45,519
benefits we care about over http

00:02:42,560 --> 00:02:46,560
json such as speed type safety a single

00:02:45,519 --> 00:02:49,440
source of truth

00:02:46,560 --> 00:02:51,519
code generation and much more we know

00:02:49,440 --> 00:02:54,959
this which is why we're using

00:02:51,519 --> 00:02:58,800
grpc but why hasn't the whole world

00:02:54,959 --> 00:03:00,879
switched to protobuf and grpc

00:02:58,800 --> 00:03:03,040
unfortunately it's not always so easy to

00:03:00,879 --> 00:03:04,959
switch entire application stacks to new

00:03:03,040 --> 00:03:06,640
frameworks

00:03:04,959 --> 00:03:08,640
often there are a number of reasons why

00:03:06,640 --> 00:03:10,640
we keep using old standards when new

00:03:08,640 --> 00:03:12,000
better alternatives are available such

00:03:10,640 --> 00:03:14,879
as compatibility with

00:03:12,000 --> 00:03:16,000
existing systems management pressure and

00:03:14,879 --> 00:03:18,000
in this case

00:03:16,000 --> 00:03:19,519
the still prevalent expectation that a

00:03:18,000 --> 00:03:23,120
public asia api

00:03:19,519 --> 00:03:25,840
should be using http json

00:03:23,120 --> 00:03:27,760
what can we do when we want to use grpc

00:03:25,840 --> 00:03:32,239
but are forced to use http

00:03:27,760 --> 00:03:33,040
json the grpc gateway project allows you

00:03:32,239 --> 00:03:36,159
to design

00:03:33,040 --> 00:03:37,280
grpc and http json services at the same

00:03:36,159 --> 00:03:39,680
time

00:03:37,280 --> 00:03:41,519
it uses a custom protobuf generator that

00:03:39,680 --> 00:03:43,519
generates a simple reverse proxy that

00:03:41,519 --> 00:03:44,319
translates on the fly from json to

00:03:43,519 --> 00:03:47,120
protobuf

00:03:44,319 --> 00:03:48,080
and back again it allows you to define a

00:03:47,120 --> 00:03:51,280
url path

00:03:48,080 --> 00:03:51,840
and http verb to grpc service method

00:03:51,280 --> 00:03:53,599
mapping

00:03:51,840 --> 00:03:56,080
with a simple annotation scheme in the

00:03:53,599 --> 00:03:58,560
profiles as you can see here

00:03:56,080 --> 00:03:59,280
it also provides a swagger open api

00:03:58,560 --> 00:04:03,040
generator

00:03:59,280 --> 00:04:04,400
in which in case you have some generator

00:04:03,040 --> 00:04:07,599
in case you have some generator you want

00:04:04,400 --> 00:04:09,439
to use that requires the open api format

00:04:07,599 --> 00:04:11,200
i've added the http json annotations to

00:04:09,439 --> 00:04:12,159
the previously defined service methods

00:04:11,200 --> 00:04:14,720
above

00:04:12,159 --> 00:04:17,040
as you can see the http verb and url

00:04:14,720 --> 00:04:19,600
path mappings are defined within the rpc

00:04:17,040 --> 00:04:19,600
definitions

00:04:19,840 --> 00:04:24,960
so how does it work this image shows the

00:04:22,960 --> 00:04:26,960
basic building blocks of the gateway

00:04:24,960 --> 00:04:28,320
you generate a jrpc service as usual

00:04:26,960 --> 00:04:31,120
with product django

00:04:28,320 --> 00:04:31,840
or producee and then you use our custom

00:04:31,120 --> 00:04:34,400
generator

00:04:31,840 --> 00:04:35,759
prorock gen grpc gateway to generate a

00:04:34,400 --> 00:04:38,320
gateway handler file

00:04:35,759 --> 00:04:39,759
which registers the mapped http verbs

00:04:38,320 --> 00:04:42,160
and url paths

00:04:39,759 --> 00:04:43,759
to a central max which is then used to

00:04:42,160 --> 00:04:46,800
serve the external http

00:04:43,759 --> 00:04:49,120
json interface it's common to serve the

00:04:46,800 --> 00:04:50,800
grc gateway and the grc server on

00:04:49,120 --> 00:04:53,919
different ports of the same server

00:04:50,800 --> 00:04:54,479
to allow both http json clients and jfc

00:04:53,919 --> 00:04:57,280
clients

00:04:54,479 --> 00:04:59,440
but this is not mandatory the gateway

00:04:57,280 --> 00:05:00,240
can also be used with non-go grpc

00:04:59,440 --> 00:05:02,080
services

00:05:00,240 --> 00:05:03,840
you simply connect to an external grpc

00:05:02,080 --> 00:05:06,160
service in the setup

00:05:03,840 --> 00:05:07,759
you can even serve the gateway and grpc

00:05:06,160 --> 00:05:10,240
server on the same port

00:05:07,759 --> 00:05:13,199
and split traffic using http headers if

00:05:10,240 --> 00:05:13,199
you want to get fancy

00:05:15,039 --> 00:05:18,960
okay now we're going to go into a little

00:05:17,440 --> 00:05:22,639
bit of a live demo of

00:05:18,960 --> 00:05:24,880
the jrz gateway in action and

00:05:22,639 --> 00:05:27,120
you'll get a few seconds here to copy

00:05:24,880 --> 00:05:28,639
down the url for my open source

00:05:27,120 --> 00:05:30,160
boilerplate repo and then i'm going to

00:05:28,639 --> 00:05:34,240
switch the repo and

00:05:30,160 --> 00:05:34,240
we're going to do some live coding

00:05:36,840 --> 00:05:41,759
together

00:05:38,000 --> 00:05:41,759
okay let me change the presentation

00:05:51,680 --> 00:05:55,600
okay now we've switched to the

00:05:54,560 --> 00:05:56,880
boilerplate repo

00:05:55,600 --> 00:05:59,600
and the first thing we're going to look

00:05:56,880 --> 00:06:01,600
at is the profile so you're all probably

00:05:59,600 --> 00:06:04,800
familiar with how profiles look

00:06:01,600 --> 00:06:06,479
so this is not going to be strange and

00:06:04,800 --> 00:06:07,520
as you can see we've just got some a

00:06:06,479 --> 00:06:11,440
package declaration

00:06:07,520 --> 00:06:13,440
a syntax declaration and some imports

00:06:11,440 --> 00:06:14,800
we're then defining the go package which

00:06:13,440 --> 00:06:19,840
is naturally

00:06:14,800 --> 00:06:21,360
part of using a go grpc server

00:06:19,840 --> 00:06:24,080
then we've got some extra annotations

00:06:21,360 --> 00:06:27,520
here which are used for generating the

00:06:24,080 --> 00:06:30,800
open api aka swagger file

00:06:27,520 --> 00:06:33,039
that comes together with the rest api

00:06:30,800 --> 00:06:34,240
so if we continue down the file here

00:06:33,039 --> 00:06:37,360
we've got a normal

00:06:34,240 --> 00:06:39,360
service definition as anyone who's

00:06:37,360 --> 00:06:41,520
familiar with protobuff and jfc will

00:06:39,360 --> 00:06:44,720
know this is what maps to a

00:06:41,520 --> 00:06:46,080
grpc service and then

00:06:44,720 --> 00:06:48,880
it gets a little bit interesting here

00:06:46,080 --> 00:06:51,039
because under the add user

00:06:48,880 --> 00:06:53,520
we can see that we've got some extra

00:06:51,039 --> 00:06:55,759
annotations here

00:06:53,520 --> 00:06:58,479
and as you can see here we can declare

00:06:55,759 --> 00:07:02,160
that we want to map a certain url path

00:06:58,479 --> 00:07:05,680
to the add user grpc service method

00:07:02,160 --> 00:07:09,280
so we say that a post request to

00:07:05,680 --> 00:07:12,240
the api v1 users url path

00:07:09,280 --> 00:07:13,520
should map to the add user request on

00:07:12,240 --> 00:07:16,319
the grpc service

00:07:13,520 --> 00:07:16,880
this is how we say how we do the mapping

00:07:16,319 --> 00:07:21,199
between

00:07:16,880 --> 00:07:23,520
gfc http paths and gpc backend

00:07:21,199 --> 00:07:24,400
and we can also declare that we want the

00:07:23,520 --> 00:07:28,639
entire

00:07:24,400 --> 00:07:30,639
json body to map to the add user request

00:07:28,639 --> 00:07:32,160
so this simply says that the add user

00:07:30,639 --> 00:07:36,240
request json representation

00:07:32,160 --> 00:07:40,400
is what we expect to be provided on the

00:07:36,240 --> 00:07:42,080
http url and then we've got some more

00:07:40,400 --> 00:07:45,039
open api annotations here just to make

00:07:42,080 --> 00:07:46,720
the swagger file look a little bit nicer

00:07:45,039 --> 00:07:49,360
and then we've got another user here

00:07:46,720 --> 00:07:52,639
another method here called list users

00:07:49,360 --> 00:07:56,080
which in the same fashion contains a

00:07:52,639 --> 00:08:00,000
url mapping in this case

00:07:56,080 --> 00:08:00,240
to a get verb on api v1 users and this

00:08:00,000 --> 00:08:02,960
is

00:08:00,240 --> 00:08:03,680
of course the standard path for

00:08:02,960 --> 00:08:07,360
something that

00:08:03,680 --> 00:08:09,520
will list users so that makes sense

00:08:07,360 --> 00:08:11,599
to map to the list users method and

00:08:09,520 --> 00:08:13,759
again we've got some open api

00:08:11,599 --> 00:08:15,199
mappings down here annotations down here

00:08:13,759 --> 00:08:16,800
to add some extra tags and stuff and

00:08:15,199 --> 00:08:17,840
then we've got the message definitions

00:08:16,800 --> 00:08:19,680
as you can see there's nothing

00:08:17,840 --> 00:08:20,800
particularly interesting about these in

00:08:19,680 --> 00:08:23,759
fact there's

00:08:20,800 --> 00:08:24,240
it's a very minimal interface and then

00:08:23,759 --> 00:08:25,840
if we

00:08:24,240 --> 00:08:26,879
dive quickly into the main go file if

00:08:25,840 --> 00:08:28,879
you're not familiar with go this is

00:08:26,879 --> 00:08:30,400
going to be a little bit unfamiliar but

00:08:28,879 --> 00:08:32,479
just giving you an overview of what's

00:08:30,400 --> 00:08:35,680
happening here we start

00:08:32,479 --> 00:08:41,039
a http oh a tcp listener

00:08:35,680 --> 00:08:44,320
on port 1000 on the local that network

00:08:41,039 --> 00:08:47,200
we then start serving a code jbc server

00:08:44,320 --> 00:08:48,560
with uh our own um certificates here you

00:08:47,200 --> 00:08:49,839
would obviously replace these with your

00:08:48,560 --> 00:08:51,839
own certificates when

00:08:49,839 --> 00:08:52,880
you're working on your own server and

00:08:51,839 --> 00:08:56,959
then we register

00:08:52,880 --> 00:08:58,320
the generated server to the grpc server

00:08:56,959 --> 00:09:00,160
and then we start that in the gu routine

00:08:58,320 --> 00:09:04,399
and then here

00:09:00,160 --> 00:09:05,360
if we jump into the gateway package

00:09:04,399 --> 00:09:07,519
this is where it gets a little bit

00:09:05,360 --> 00:09:08,399
interesting because this is the grc

00:09:07,519 --> 00:09:12,240
gateway setup

00:09:08,399 --> 00:09:15,680
so this is where we perform a grpc

00:09:12,240 --> 00:09:17,120
client connection dial to the grpc

00:09:15,680 --> 00:09:19,360
server that we just started

00:09:17,120 --> 00:09:22,080
as you can see we've got the dial adder

00:09:19,360 --> 00:09:24,720
on on the

00:09:22,080 --> 00:09:26,640
um function as a function parameter

00:09:24,720 --> 00:09:29,760
setting up the gmc logger

00:09:26,640 --> 00:09:31,040
and uh we're using the same transport

00:09:29,760 --> 00:09:32,880
credentials that we were using the way

00:09:31,040 --> 00:09:33,600
we created the server so we're using tls

00:09:32,880 --> 00:09:36,640
between

00:09:33,600 --> 00:09:38,320
the gfc gateway grc client and the grc

00:09:36,640 --> 00:09:41,040
server

00:09:38,320 --> 00:09:42,000
and then we use this method that was

00:09:41,040 --> 00:09:44,399
generated by

00:09:42,000 --> 00:09:45,600
our product gen grpc gateway generator

00:09:44,399 --> 00:09:48,800
to register

00:09:45,600 --> 00:09:50,800
the server handler to

00:09:48,800 --> 00:09:53,200
this gpc client connection which means

00:09:50,800 --> 00:09:55,360
that now the gmc server

00:09:53,200 --> 00:09:57,360
uh the gpc gateway server can map all of

00:09:55,360 --> 00:09:59,360
the http methods properly down to the

00:09:57,360 --> 00:10:01,920
grc client that we declared up here

00:09:59,360 --> 00:10:02,959
so if you're using a java server or a c

00:10:01,920 --> 00:10:05,279
plus plus server

00:10:02,959 --> 00:10:06,399
again this part you can do exactly the

00:10:05,279 --> 00:10:08,000
same because

00:10:06,399 --> 00:10:09,760
you're just doing a gfc client

00:10:08,000 --> 00:10:11,519
connection dialing here so you just need

00:10:09,760 --> 00:10:14,880
to use a different

00:10:11,519 --> 00:10:18,000
dial address and then we're

00:10:14,880 --> 00:10:20,880
serving the http the the

00:10:18,000 --> 00:10:22,560
jeffsy gateway mux but we're also adding

00:10:20,880 --> 00:10:24,320
a little bit extra flair in this example

00:10:22,560 --> 00:10:27,279
which is that we want to serve the

00:10:24,320 --> 00:10:30,720
generated open api ui together with it

00:10:27,279 --> 00:10:31,440
so in port 11000 we serve both the grpc

00:10:30,720 --> 00:10:34,560
gateway

00:10:31,440 --> 00:10:36,880
and the open api handler and

00:10:34,560 --> 00:10:40,240
enough theory let's let's just take a

00:10:36,880 --> 00:10:40,240
quick look at what that looks like

00:10:41,920 --> 00:10:48,880
so if i do that i'm gonna

00:10:45,440 --> 00:10:51,839
open my browser

00:10:48,880 --> 00:10:53,040
okay so here you go i've loaded the uh

00:10:51,839 --> 00:10:55,120
open api server

00:10:53,040 --> 00:10:56,560
on my in my browser the first thing we

00:10:55,120 --> 00:10:58,720
notice is that we get a security warning

00:10:56,560 --> 00:11:00,800
of course because we're using a self's

00:10:58,720 --> 00:11:02,079
sign certificate in this case because

00:11:00,800 --> 00:11:03,519
i'm serving this on localhost i'm going

00:11:02,079 --> 00:11:04,959
to go ahead and accept the risk and

00:11:03,519 --> 00:11:06,720
continue because i

00:11:04,959 --> 00:11:09,440
am hopefully not being intercepted on

00:11:06,720 --> 00:11:11,680
the way from my computer to my computer

00:11:09,440 --> 00:11:13,360
and as you can see here we have the open

00:11:11,680 --> 00:11:16,480
api ui that's been

00:11:13,360 --> 00:11:16,959
generated from i'm going to enlarge this

00:11:16,480 --> 00:11:19,279
a little bit

00:11:16,959 --> 00:11:21,760
it's been generated together with the

00:11:19,279 --> 00:11:23,440
definitions that we had in the

00:11:21,760 --> 00:11:25,040
profile so as you can see this

00:11:23,440 --> 00:11:26,880
completely maps to

00:11:25,040 --> 00:11:28,399
the url paths that we had listed in the

00:11:26,880 --> 00:11:30,480
profile and

00:11:28,399 --> 00:11:31,440
this this totally works as well you can

00:11:30,480 --> 00:11:33,360
list users

00:11:31,440 --> 00:11:34,880
obviously now this actually gave a

00:11:33,360 --> 00:11:35,920
content length of zero response because

00:11:34,880 --> 00:11:39,440
we have no users

00:11:35,920 --> 00:11:40,720
but if we go ahead and add a user now

00:11:39,440 --> 00:11:42,800
this doesn't take your parameters so i'm

00:11:40,720 --> 00:11:46,079
just going to send it an empty

00:11:42,800 --> 00:11:47,839
json document that responds with okay

00:11:46,079 --> 00:11:50,399
we've got an id of a user here

00:11:47,839 --> 00:11:51,600
i think we added the user and if we

00:11:50,399 --> 00:11:56,399
execute this

00:11:51,600 --> 00:11:59,519
then you can see now we get back um

00:11:56,399 --> 00:12:00,800
a user so this is uh interactive you can

00:11:59,519 --> 00:12:03,920
use this

00:12:00,800 --> 00:12:07,040
for testing you can even use it for

00:12:03,920 --> 00:12:08,959
uh as a product in front of your own api

00:12:07,040 --> 00:12:12,160
or something like that

00:12:08,959 --> 00:12:15,600
but let's uh take another step back

00:12:12,160 --> 00:12:18,240
and see what happens if we want to

00:12:15,600 --> 00:12:20,240
make some changes to the code and just

00:12:18,240 --> 00:12:22,320
how quickly we can

00:12:20,240 --> 00:12:23,680
iterate on the code and regenerate

00:12:22,320 --> 00:12:26,880
everything and everything just works you

00:12:23,680 --> 00:12:26,880
know that the kind of powerful

00:12:27,680 --> 00:12:30,399
development workflow that we're used to

00:12:29,040 --> 00:12:31,120
with protobuf so i'm going to switch

00:12:30,399 --> 00:12:39,839
back to

00:12:31,120 --> 00:12:39,839
my boilerplate repo

00:12:40,160 --> 00:12:44,480
i'm gonna turn off the server now let's

00:12:43,120 --> 00:12:47,600
say we want to add

00:12:44,480 --> 00:12:52,079
a parameter to the user let's call

00:12:47,600 --> 00:12:53,839
say we want the user to have a name

00:12:52,079 --> 00:12:55,760
see this is what we do here we'll then

00:12:53,839 --> 00:13:00,240
need to add a user

00:12:55,760 --> 00:13:00,240
um a name to the user and user request

00:13:00,320 --> 00:13:07,120
name here we go

00:13:03,839 --> 00:13:09,839
then this is

00:13:07,120 --> 00:13:10,480
all we need now we can make generate

00:13:09,839 --> 00:13:15,040
which is

00:13:10,480 --> 00:13:17,839
um we created makefile command

00:13:15,040 --> 00:13:19,519
that will run privacy with all the

00:13:17,839 --> 00:13:22,800
generators that we have

00:13:19,519 --> 00:13:25,760
here and just recreate everything for us

00:13:22,800 --> 00:13:34,240
now if we run go run main go again and

00:13:25,760 --> 00:13:36,480
jump back to the browser window

00:13:34,240 --> 00:13:38,160
let's just make sure that we're

00:13:36,480 --> 00:13:40,160
disabling the cache memory of the window

00:13:38,160 --> 00:13:42,480
because we're downloading a new swagger

00:13:40,160 --> 00:13:42,480
file

00:13:44,320 --> 00:13:48,240
now if we want to add a user all of a

00:13:46,480 --> 00:13:51,040
sudden we have a name parameter here

00:13:48,240 --> 00:13:51,040
so let's do that

00:13:53,279 --> 00:13:57,279
there you can see the card request that

00:13:54,880 --> 00:13:59,839
was made here

00:13:57,279 --> 00:14:00,800
we forgot to update the uh the back end

00:13:59,839 --> 00:14:06,079
let's jump back

00:14:00,800 --> 00:14:06,079
quickly to the application

00:14:10,959 --> 00:14:15,440
at the backend server okay so here we

00:14:14,160 --> 00:14:16,560
have the go back in server which is

00:14:15,440 --> 00:14:18,800
implementing all this

00:14:16,560 --> 00:14:20,399
we'll take the request and now that

00:14:18,800 --> 00:14:21,040
we've regenerated this we have a name

00:14:20,399 --> 00:14:24,160
here

00:14:21,040 --> 00:14:24,959
so let's do rename when we're adding the

00:14:24,160 --> 00:14:28,160
user

00:14:24,959 --> 00:14:31,040
and as you can see here this is a

00:14:28,160 --> 00:14:32,880
just a mutex protected array that's

00:14:31,040 --> 00:14:35,040
being stored in memory

00:14:32,880 --> 00:14:36,959
and list users just reads back from that

00:14:35,040 --> 00:14:39,199
array so now we've updated the server as

00:14:36,959 --> 00:14:39,199
well

00:14:39,360 --> 00:14:45,839
run that and let's jump back to the

00:14:41,360 --> 00:14:45,839
browser window

00:14:49,120 --> 00:14:52,959
we don't even have to reload this

00:14:50,320 --> 00:14:56,160
pagerank if i try and execute it now

00:14:52,959 --> 00:14:57,120
yes okay we got the name back and if we

00:14:56,160 --> 00:14:59,839
try to do

00:14:57,120 --> 00:14:59,839
list users here

00:15:00,720 --> 00:15:05,120
yes we got that user back and the name

00:15:03,440 --> 00:15:08,720
has been stored

00:15:05,120 --> 00:15:12,079
so as you can see this the powerful

00:15:08,720 --> 00:15:12,720
protobuf workflow that we're used to

00:15:12,079 --> 00:15:14,880
where we just

00:15:12,720 --> 00:15:16,480
change the prototype files and

00:15:14,880 --> 00:15:20,079
regenerate and everything

00:15:16,480 --> 00:15:23,839
just works is completely unlocked by

00:15:20,079 --> 00:15:26,320
the jrc gateway as well you just have to

00:15:23,839 --> 00:15:26,880
use the product file as usual regenerate

00:15:26,320 --> 00:15:29,040
it and

00:15:26,880 --> 00:15:30,800
your rest api is updated automatically

00:15:29,040 --> 00:15:32,160
including the documentation as you can

00:15:30,800 --> 00:15:41,839
see

00:15:32,160 --> 00:15:41,839
so let's jump back into the presentation

00:15:52,839 --> 00:15:55,839
okay

00:15:55,920 --> 00:15:59,199
so let's talk a little bit more about

00:15:57,759 --> 00:16:02,399
specific product features that are

00:15:59,199 --> 00:16:05,759
supported by the grc gateway

00:16:02,399 --> 00:16:09,519
we start by the rich type support

00:16:05,759 --> 00:16:11,120
for the the problem of well known types

00:16:09,519 --> 00:16:12,959
these types are part of what you might

00:16:11,120 --> 00:16:14,560
call a protobuf standard library and

00:16:12,959 --> 00:16:15,360
they're always included with a proto-c

00:16:14,560 --> 00:16:16,639
compiler

00:16:15,360 --> 00:16:19,040
meaning that you don't have to manually

00:16:16,639 --> 00:16:20,680
manage their downloading and generation

00:16:19,040 --> 00:16:22,560
they use a special namespace

00:16:20,680 --> 00:16:23,759
google.protobuff which makes them easy

00:16:22,560 --> 00:16:26,160
to recognize

00:16:23,759 --> 00:16:28,079
these types are predefined messages and

00:16:26,160 --> 00:16:29,040
include messages for handling timestamps

00:16:28,079 --> 00:16:32,079
durations

00:16:29,040 --> 00:16:33,839
wrappers of primitive types and others

00:16:32,079 --> 00:16:35,440
all of these types have special cases

00:16:33,839 --> 00:16:37,040
built into them for the gateway so

00:16:35,440 --> 00:16:38,000
whenever for example you need a

00:16:37,040 --> 00:16:40,480
timestamp

00:16:38,000 --> 00:16:41,279
make use of the well-known type as you

00:16:40,480 --> 00:16:43,839
can see

00:16:41,279 --> 00:16:44,800
i've added some examples here the

00:16:43,839 --> 00:16:48,320
timestamp time

00:16:44,800 --> 00:16:51,360
marshalls to and from an rfc 3339

00:16:48,320 --> 00:16:54,560
timestamp string the uin32 value

00:16:51,360 --> 00:16:56,560
can be used to have nullable uin32s

00:16:54,560 --> 00:16:58,880
and the struct type can be used to store

00:16:56,560 --> 00:17:00,480
arbitrary json structures

00:16:58,880 --> 00:17:02,800
please use the last one carefully as the

00:17:00,480 --> 00:17:03,519
protobuf representation is a mess to

00:17:02,800 --> 00:17:07,360
work with

00:17:03,519 --> 00:17:07,360
and should only be a last resort

00:17:08,640 --> 00:17:13,280
there's another well-known type that has

00:17:10,079 --> 00:17:15,439
good support in the geopsy gateway

00:17:13,280 --> 00:17:17,600
most protobuf primitive fields such as

00:17:15,439 --> 00:17:19,600
strings and integers are non-nullable

00:17:17,600 --> 00:17:20,720
so in order to do partial updates the

00:17:19,600 --> 00:17:22,720
best practice is

00:17:20,720 --> 00:17:24,480
the use of a special message type called

00:17:22,720 --> 00:17:26,160
a field mask

00:17:24,480 --> 00:17:28,160
exposing this implementation detail to

00:17:26,160 --> 00:17:29,679
your users however is pretty nasty so

00:17:28,160 --> 00:17:32,000
the grc gateway supports

00:17:29,679 --> 00:17:33,840
translating json fields to a field mask

00:17:32,000 --> 00:17:36,000
and resource type

00:17:33,840 --> 00:17:37,600
fields that are found in the input json

00:17:36,000 --> 00:17:38,400
are used to populate the resource and

00:17:37,600 --> 00:17:41,280
field mask

00:17:38,400 --> 00:17:42,480
automatically this code shows an example

00:17:41,280 --> 00:17:45,039
structure

00:17:42,480 --> 00:17:47,039
with the server submitted the output

00:17:45,039 --> 00:17:47,840
only comment indicates that the field is

00:17:47,039 --> 00:17:49,760
not mutable

00:17:47,840 --> 00:17:50,880
via partial updates which is in line

00:17:49,760 --> 00:17:53,520
with the google api

00:17:50,880 --> 00:17:55,280
design docs recommendations this support

00:17:53,520 --> 00:17:56,240
was entirely the result of an open

00:17:55,280 --> 00:18:01,840
source contribution

00:17:56,240 --> 00:18:01,840
from roman azami and daniel mcdonald

00:18:02,480 --> 00:18:06,080
when working with grpc we use this

00:18:04,480 --> 00:18:08,720
status type for errors

00:18:06,080 --> 00:18:10,799
which includes a message and a code the

00:18:08,720 --> 00:18:12,960
geopsy gateway automatically translates

00:18:10,799 --> 00:18:13,679
the codes into appropriate http status

00:18:12,960 --> 00:18:16,160
codes

00:18:13,679 --> 00:18:17,600
according to the google.rpc.code

00:18:16,160 --> 00:18:19,440
definitions

00:18:17,600 --> 00:18:22,080
here we can see a sample of the error

00:18:19,440 --> 00:18:23,760
codes and their respective mappings

00:18:22,080 --> 00:18:25,919
if you have more specific needs for your

00:18:23,760 --> 00:18:26,880
error handling such as a custom error

00:18:25,919 --> 00:18:28,480
struct format

00:18:26,880 --> 00:18:30,320
you can create your own error handling

00:18:28,480 --> 00:18:32,000
function and configure the runtime mux

00:18:30,320 --> 00:18:33,440
with it on startup

00:18:32,000 --> 00:18:35,360
here we have an example of an error

00:18:33,440 --> 00:18:37,679
handler that sets the response code to

00:18:35,360 --> 00:18:39,679
one that is mapped from the grpc status

00:18:37,679 --> 00:18:41,360
and the response body to simply be the

00:18:39,679 --> 00:18:43,120
error message itself

00:18:41,360 --> 00:18:44,799
note that using custom errors like this

00:18:43,120 --> 00:18:47,840
will break the default open api

00:18:44,799 --> 00:18:47,840
generator definitions

00:18:48,320 --> 00:18:51,440
and wrapping it all up what have we done

00:18:50,480 --> 00:18:54,000
today

00:18:51,440 --> 00:18:56,640
we've created a http json service but

00:18:54,000 --> 00:18:58,400
used grpc and protobuf under the hood

00:18:56,640 --> 00:19:00,080
this allows us to get all the benefits

00:18:58,400 --> 00:19:02,080
of the protobuf idl

00:19:00,080 --> 00:19:03,440
while still exposing a json interface

00:19:02,080 --> 00:19:05,200
externally

00:19:03,440 --> 00:19:07,039
we've also managed to sneak a gpc

00:19:05,200 --> 00:19:08,960
service into our stack and now it's much

00:19:07,039 --> 00:19:10,720
easier to argue that upc might be

00:19:08,960 --> 00:19:13,120
something worth trying

00:19:10,720 --> 00:19:15,360
new clients can use grbc and old clients

00:19:13,120 --> 00:19:18,400
can keep using the json interface

00:19:15,360 --> 00:19:20,480
most importantly we found an easy robust

00:19:18,400 --> 00:19:22,480
way to write restful services

00:19:20,480 --> 00:19:24,960
and we've only explored a snapshot of

00:19:22,480 --> 00:19:26,799
all that the geopsy gateway has to offer

00:19:24,960 --> 00:19:28,880
other features include the ability to

00:19:26,799 --> 00:19:30,720
set cookies perform header-based

00:19:28,880 --> 00:19:34,320
authentication in interceptors

00:19:30,720 --> 00:19:36,240
and much more i hope you will as i do

00:19:34,320 --> 00:19:39,600
use the geopsy gateway for your next

00:19:36,240 --> 00:19:43,039
http json service

00:19:39,600 --> 00:19:43,039

YouTube URL: https://www.youtube.com/watch?v=AaqZvsrULi4


