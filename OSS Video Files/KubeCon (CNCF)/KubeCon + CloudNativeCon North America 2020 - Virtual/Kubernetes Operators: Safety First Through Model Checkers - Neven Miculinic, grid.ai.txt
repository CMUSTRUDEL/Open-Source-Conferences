Title: Kubernetes Operators: Safety First Through Model Checkers - Neven Miculinic, grid.ai
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4–7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Kubernetes Operators: Safety First Through Model Checkers - Neven Miculinic, grid.ai 

Today's Kubernetes Operators aren't just a fancy toy, but utilities managing critical infrastructure. Many best practices are already applied, increasing their safety: unit/e2e testing, code reviews and post mortem analysis. This talk introduces some more recent tooling for working developers toolbox: model checkers. The likes of TLA+ and alloy have already been used for helping design many real-world systems, from S3 all the way to RTOS (real-time operating system) with massive success. They allow us to design and model our systems in the abstract, state the system facts, assumptions and expected rules to hold, and finally, they analyze our model for inconsistencies or scenarios we haven't thought of - like code review for system design on steroids. This talk introduces model checkers, covers the motivation behind them, and finishes with a short example. 

https://sched.co/ekAp
Captions: 
	00:00:01,439 --> 00:00:07,120
hi i'm amit silinich

00:00:03,840 --> 00:00:08,720
and for the past four years i've done

00:00:07,120 --> 00:00:09,760
various jobs related to software

00:00:08,720 --> 00:00:12,080
engineering

00:00:09,760 --> 00:00:13,840
from being part of a blockchain startup

00:00:12,080 --> 00:00:16,560
developing deep learning models

00:00:13,840 --> 00:00:17,760
for master theaters all the way to being

00:00:16,560 --> 00:00:21,439
around kubernetes

00:00:17,760 --> 00:00:23,840
like creating operators managing them

00:00:21,439 --> 00:00:25,279
managing clusters converting clients

00:00:23,840 --> 00:00:27,119
together etc

00:00:25,279 --> 00:00:29,679
currently i'm employing a company called

00:00:27,119 --> 00:00:32,480
gri and today i'm going to present

00:00:29,679 --> 00:00:34,559
kubrick's operators safety first for

00:00:32,480 --> 00:00:37,040
model checkers

00:00:34,559 --> 00:00:37,680
let's begin slowly with some motivation

00:00:37,040 --> 00:00:39,680
i mean

00:00:37,680 --> 00:00:41,040
you have kubernetes handling everything

00:00:39,680 --> 00:00:44,239
for you his handles

00:00:41,040 --> 00:00:46,239
storage networking yeah so

00:00:44,239 --> 00:00:48,079
of course one would assume that with

00:00:46,239 --> 00:00:50,719
kubernetes

00:00:48,079 --> 00:00:51,920
building operators is easy right i mean

00:00:50,719 --> 00:00:54,079
you can google

00:00:51,920 --> 00:00:55,920
operator horror stories like radius

00:00:54,079 --> 00:01:00,239
operator crashing everything

00:00:55,920 --> 00:01:03,840
or known issues in mongodb operator

00:01:00,239 --> 00:01:05,519
i mean you would assume that naturally

00:01:03,840 --> 00:01:07,600
kubernetes operators are kind of simply

00:01:05,519 --> 00:01:09,760
that have a complex architecture

00:01:07,600 --> 00:01:12,080
something like a posies operator

00:01:09,760 --> 00:01:15,520
shouldn't be that complicated yet

00:01:12,080 --> 00:01:18,799
you need a whole chart to describe it

00:01:15,520 --> 00:01:20,799
therefore we established that kubernetes

00:01:18,799 --> 00:01:22,799
doesn't solve all our problems for us

00:01:20,799 --> 00:01:24,080
and building operators still has some

00:01:22,799 --> 00:01:27,360
kind of a learning curve

00:01:24,080 --> 00:01:29,280
and adds its own complexity

00:01:27,360 --> 00:01:30,479
so let's abstractly look how we build

00:01:29,280 --> 00:01:32,320
software

00:01:30,479 --> 00:01:34,400
we build a product which has some

00:01:32,320 --> 00:01:36,400
quality quality to our users to

00:01:34,400 --> 00:01:38,240
consumers to every stakeholder

00:01:36,400 --> 00:01:40,320
the more time we invest into our

00:01:38,240 --> 00:01:41,759
software and in turn pay the developers

00:01:40,320 --> 00:01:43,520
to build it

00:01:41,759 --> 00:01:46,479
the quality should monotonically

00:01:43,520 --> 00:01:49,600
increase up to some maximum value

00:01:46,479 --> 00:01:50,240
so this is the first graph as we gain

00:01:49,600 --> 00:01:53,520
more

00:01:50,240 --> 00:01:55,439
experience building software we can

00:01:53,520 --> 00:01:57,439
deliver a better quality software in

00:01:55,439 --> 00:01:59,680
shorter time

00:01:57,439 --> 00:02:01,360
we achieve this via better tools for

00:01:59,680 --> 00:02:05,040
example better idea support

00:02:01,360 --> 00:02:07,840
battle debuggers uh better observability

00:02:05,040 --> 00:02:09,360
we can have better processes for example

00:02:07,840 --> 00:02:11,920
how do you commit code

00:02:09,360 --> 00:02:15,680
what needs to be some checklist you need

00:02:11,920 --> 00:02:15,680
to fill in before you commit code

00:02:16,000 --> 00:02:20,000
code reviews etc or there could be some

00:02:18,720 --> 00:02:22,160
external stuff

00:02:20,000 --> 00:02:23,920
outside of the software which makes

00:02:22,160 --> 00:02:24,800
writing much more quality software

00:02:23,920 --> 00:02:26,879
easier

00:02:24,800 --> 00:02:30,239
for example some regulation was released

00:02:26,879 --> 00:02:30,239
you don't need to do it etc

00:02:31,280 --> 00:02:35,440
this brings us to typical conventional

00:02:33,120 --> 00:02:36,720
approach for improving the quality of

00:02:35,440 --> 00:02:39,920
our software

00:02:36,720 --> 00:02:41,440
so this is a typical things you would do

00:02:39,920 --> 00:02:43,280
when you build a distributed system on

00:02:41,440 --> 00:02:45,519
any kind of software

00:02:43,280 --> 00:02:46,959
first you have some design some informal

00:02:45,519 --> 00:02:49,599
design specification

00:02:46,959 --> 00:02:51,200
you talk with your core leaks and you

00:02:49,599 --> 00:02:54,239
have a deep designer view

00:02:51,200 --> 00:02:56,000
does this make sense in this context is

00:02:54,239 --> 00:02:57,599
there any obvious shortcomings to this

00:02:56,000 --> 00:03:00,159
design like you will just crash

00:02:57,599 --> 00:03:02,080
the minute you put it in production you

00:03:00,159 --> 00:03:03,599
try to catch as many of these design

00:03:02,080 --> 00:03:05,760
bugs early

00:03:03,599 --> 00:03:06,720
then you code it and you do static code

00:03:05,760 --> 00:03:08,080
analysis

00:03:06,720 --> 00:03:09,920
where you have some tools which you

00:03:08,080 --> 00:03:13,040
annotate somehow your code and

00:03:09,920 --> 00:03:15,200
things might or might not blow up you

00:03:13,040 --> 00:03:18,720
push it and you stress test it

00:03:15,200 --> 00:03:20,000
or even inject faults in places

00:03:18,720 --> 00:03:22,480
for example if you have a network

00:03:20,000 --> 00:03:23,280
service you ejected request to timeout

00:03:22,480 --> 00:03:26,080
or fail

00:03:23,280 --> 00:03:27,120
and see how your operators behave you

00:03:26,080 --> 00:03:30,159
write unit tests

00:03:27,120 --> 00:03:32,319
for much more smaller testing pieces and

00:03:30,159 --> 00:03:34,080
finally you do code reviews

00:03:32,319 --> 00:03:36,640
where the implementation is checked by

00:03:34,080 --> 00:03:38,400
your peers for any obvious defects and

00:03:36,640 --> 00:03:39,840
possible code improvements

00:03:38,400 --> 00:03:41,920
so this is all the conventional

00:03:39,840 --> 00:03:45,280
approaches we all know and love

00:03:41,920 --> 00:03:47,599
most of us have come across to them

00:03:45,280 --> 00:03:49,360
yet there aren't enough there is like

00:03:47,599 --> 00:03:51,200
more tools more approaches

00:03:49,360 --> 00:03:54,640
and this talk introduces one of these

00:03:51,200 --> 00:03:58,159
new approaches called model checkers

00:03:54,640 --> 00:04:00,799
in essence model checker is relatively

00:03:58,159 --> 00:04:01,439
straightforward like a brute force

00:04:00,799 --> 00:04:04,239
search

00:04:01,439 --> 00:04:05,439
over all possible system states so in

00:04:04,239 --> 00:04:07,840
some kind of

00:04:05,439 --> 00:04:08,720
formalish language you describe your

00:04:07,840 --> 00:04:10,640
design

00:04:08,720 --> 00:04:11,760
as a state machine you have a state of

00:04:10,640 --> 00:04:14,080
your system

00:04:11,760 --> 00:04:15,120
you define a traditional function which

00:04:14,080 --> 00:04:17,280
are valid

00:04:15,120 --> 00:04:19,919
so from which state of the system you

00:04:17,280 --> 00:04:22,880
can go next even on determining clip

00:04:19,919 --> 00:04:24,639
you define okay what are my assumptions

00:04:22,880 --> 00:04:27,440
for this design to be right

00:04:24,639 --> 00:04:28,000
what needs to hold those are invariants

00:04:27,440 --> 00:04:29,759
you want to

00:04:28,000 --> 00:04:31,759
check or rules you want to check and

00:04:29,759 --> 00:04:35,600
properties you want to check

00:04:31,759 --> 00:04:38,479
so all this is what you are checking

00:04:35,600 --> 00:04:40,400
when you have a model and the system

00:04:38,479 --> 00:04:41,120
performs more or less a brute force

00:04:40,400 --> 00:04:43,600
search

00:04:41,120 --> 00:04:44,320
over all possible states you is which

00:04:43,600 --> 00:04:46,639
are reachable

00:04:44,320 --> 00:04:49,280
from the initial state does those

00:04:46,639 --> 00:04:52,080
invariants thrown properties hold

00:04:49,280 --> 00:04:53,919
it's like that easy it's mostly based on

00:04:52,080 --> 00:04:56,160
set algebra you have a set of states

00:04:53,919 --> 00:04:57,199
set reachable states and brackets on

00:04:56,160 --> 00:04:59,360
those states

00:04:57,199 --> 00:05:01,600
part of the set of all states are the

00:04:59,360 --> 00:05:05,039
true or false

00:05:01,600 --> 00:05:07,360
so far so is good and

00:05:05,039 --> 00:05:09,120
if you take anything from this talk

00:05:07,360 --> 00:05:11,199
please read this paper

00:05:09,120 --> 00:05:13,919
use of formal methods and amazon web

00:05:11,199 --> 00:05:16,000
services from 2014.

00:05:13,919 --> 00:05:18,080
most of this talk is based on this white

00:05:16,000 --> 00:05:18,800
paper it's amazing it's immediately

00:05:18,080 --> 00:05:21,680
written

00:05:18,800 --> 00:05:22,560
it has both the pros and cons analysis

00:05:21,680 --> 00:05:25,600
in more depth

00:05:22,560 --> 00:05:28,240
as well as a cool story i'm going to

00:05:25,600 --> 00:05:29,199
read right and paraphrase so how did

00:05:28,240 --> 00:05:31,440
they come to this

00:05:29,199 --> 00:05:35,120
conclusion hey we need formal methods we

00:05:31,440 --> 00:05:35,120
need a moodle checklist this is amazing

00:05:35,199 --> 00:05:38,880
it's like a crime thriller so in the

00:05:38,320 --> 00:05:41,600
paper

00:05:38,880 --> 00:05:43,199
they actually shorten the author's

00:05:41,600 --> 00:05:44,080
initials when they talk about personal

00:05:43,199 --> 00:05:48,400
experience

00:05:44,080 --> 00:05:50,960
as just initial so cn and tr

00:05:48,400 --> 00:05:52,880
and the first one who came across this

00:05:50,960 --> 00:05:56,479
formal model checkers

00:05:52,880 --> 00:05:59,039
is somebody called chris newcombe

00:05:56,479 --> 00:06:00,240
so why is it building distributed system

00:05:59,039 --> 00:06:02,720
super hard

00:06:00,240 --> 00:06:03,280
well to first approximation we can say

00:06:02,720 --> 00:06:05,440
that

00:06:03,280 --> 00:06:07,199
accidents are almost always the result

00:06:05,440 --> 00:06:10,240
of incorrect estimates

00:06:07,199 --> 00:06:11,759
of the likelihood of one or more things

00:06:10,240 --> 00:06:13,600
so when we build some systems and

00:06:11,759 --> 00:06:16,560
program

00:06:13,600 --> 00:06:17,280
we have issues estimating how likely is

00:06:16,560 --> 00:06:20,000
some error

00:06:17,280 --> 00:06:22,240
that this like code is close to zero how

00:06:20,000 --> 00:06:24,560
likely could is some scenario to occur

00:06:22,240 --> 00:06:26,160
if it's one in the million that one in a

00:06:24,560 --> 00:06:28,800
million sounds like pretty

00:06:26,160 --> 00:06:30,240
rare but if your service lands a million

00:06:28,800 --> 00:06:33,520
requests per second

00:06:30,240 --> 00:06:36,240
it happens approximately every second

00:06:33,520 --> 00:06:37,759
or how many times would this happen over

00:06:36,240 --> 00:06:38,400
the lifetime of the your service or

00:06:37,759 --> 00:06:41,440
solution

00:06:38,400 --> 00:06:43,919
which can measure years or even decades

00:06:41,440 --> 00:06:45,360
i mean there are all gds global

00:06:43,919 --> 00:06:47,919
distribution systems

00:06:45,360 --> 00:06:49,440
being run on superb hardware or there

00:06:47,919 --> 00:06:51,280
are even mainframe pieces stirring

00:06:49,440 --> 00:06:53,919
around cool from the 80s or 60s

00:06:51,280 --> 00:06:56,479
like somebody maintains the fortran code

00:06:53,919 --> 00:07:00,560
or a cobalt code

00:06:56,479 --> 00:07:03,199
therefore likelihood just increases

00:07:00,560 --> 00:07:04,319
in the end cn our main actor and

00:07:03,199 --> 00:07:06,160
protagonist

00:07:04,319 --> 00:07:07,440
was dissatisfied with the quality of

00:07:06,160 --> 00:07:10,800
services he was written

00:07:07,440 --> 00:07:12,319
i mean despite all the best practices

00:07:10,800 --> 00:07:14,840
they had bugs they had production

00:07:12,319 --> 00:07:16,240
outages they had everything we know and

00:07:14,840 --> 00:07:18,400
hate

00:07:16,240 --> 00:07:20,240
so he dismissed foreign methods because

00:07:18,400 --> 00:07:22,160
there were two various myths about them

00:07:20,240 --> 00:07:23,840
because they he thought it takes long

00:07:22,160 --> 00:07:26,240
time to learn

00:07:23,840 --> 00:07:27,360
which is true for some of them i had a

00:07:26,240 --> 00:07:29,199
class in a

00:07:27,360 --> 00:07:31,280
university about formal methods and some

00:07:29,199 --> 00:07:33,120
of them probably pretty complicated

00:07:31,280 --> 00:07:35,759
and pretty less powerful in this one

00:07:33,120 --> 00:07:38,000
less applicable

00:07:35,759 --> 00:07:40,319
a second misconception is that only a

00:07:38,000 --> 00:07:43,599
small fraction of real-life problems

00:07:40,319 --> 00:07:45,520
fit this paradigm so if what his

00:07:43,599 --> 00:07:47,440
rate over investment for learning model

00:07:45,520 --> 00:07:51,199
checkers would be pretty small

00:07:47,440 --> 00:07:52,160
or insignificant this which begins to

00:07:51,199 --> 00:07:55,360
the third point

00:07:52,160 --> 00:07:57,680
like vx engineers have put limited time

00:07:55,360 --> 00:07:59,599
in our work schedules we start working

00:07:57,680 --> 00:08:02,960
at some age between

00:07:59,599 --> 00:08:04,160
10 15 or 25 we finish university most of

00:08:02,960 --> 00:08:05,840
us at least

00:08:04,160 --> 00:08:07,360
and finish working around time we are

00:08:05,840 --> 00:08:10,720
6017 retired

00:08:07,360 --> 00:08:13,840
hopefully happily retired so if you

00:08:10,720 --> 00:08:15,440
learn some method for two weeks if this

00:08:13,840 --> 00:08:16,240
is like opportunity costly maybe you

00:08:15,440 --> 00:08:19,840
could learn something

00:08:16,240 --> 00:08:22,560
else maybe haskell or whatever

00:08:19,840 --> 00:08:23,520
therefore return investment is important

00:08:22,560 --> 00:08:26,080
he also thought

00:08:23,520 --> 00:08:26,800
they are impractical that they are hard

00:08:26,080 --> 00:08:29,199
to use

00:08:26,800 --> 00:08:30,800
the tooling is horrible which isn't true

00:08:29,199 --> 00:08:35,120
at all

00:08:30,800 --> 00:08:38,080
it's fine actually not perfect but fine

00:08:35,120 --> 00:08:42,640
and he found some white paper a mystic

00:08:38,080 --> 00:08:45,440
paper appears it says a title

00:08:42,640 --> 00:08:46,240
using lightfat modeling to understand

00:08:45,440 --> 00:08:49,760
short

00:08:46,240 --> 00:08:52,560
chord short chord is a disability

00:08:49,760 --> 00:08:54,640
hashtable algorithm pretty famous one

00:08:52,560 --> 00:08:56,399
and therefore they had like design was

00:08:54,640 --> 00:08:57,440
super peer-reviewed everybody read the

00:08:56,399 --> 00:09:00,640
white papers

00:08:57,440 --> 00:09:04,080
everybody agreed this is like correct

00:09:00,640 --> 00:09:07,920
then some guy some woman actually pamela

00:09:04,080 --> 00:09:10,320
zave she decided to model it using alloy

00:09:07,920 --> 00:09:12,880
one of the model checkers

00:09:10,320 --> 00:09:14,160
and when she modeled using alloy she

00:09:12,880 --> 00:09:17,440
found that this design

00:09:14,160 --> 00:09:18,560
has a bug in it it actually doesn't have

00:09:17,440 --> 00:09:21,279
all the properties

00:09:18,560 --> 00:09:23,040
of safety she wanted from a disabled

00:09:21,279 --> 00:09:24,959
hash table

00:09:23,040 --> 00:09:27,200
in this paper stood the test of time it

00:09:24,959 --> 00:09:30,480
had a 10-year test of time award

00:09:27,200 --> 00:09:33,120
at segum 2011.

00:09:30,480 --> 00:09:34,160
so actor main protagonist cnn read it he

00:09:33,120 --> 00:09:37,680
was like

00:09:34,160 --> 00:09:40,000
oh this is cool like

00:09:37,680 --> 00:09:42,720
this can help me write better systems

00:09:40,000 --> 00:09:46,959
better software like this is super cool

00:09:42,720 --> 00:09:48,959
but when he a verified alloy

00:09:46,959 --> 00:09:50,000
and compare it like what he needs this

00:09:48,959 --> 00:09:53,440
logic to do

00:09:50,000 --> 00:09:54,560
on his problems he found it limited

00:09:53,440 --> 00:09:56,800
expressivity

00:09:54,560 --> 00:09:58,080
although he has a similar story still a

00:09:56,800 --> 00:10:01,440
plus but it's a bit more

00:09:58,080 --> 00:10:03,600
limited so he looked

00:10:01,440 --> 00:10:05,440
further and further and firm forum he

00:10:03,600 --> 00:10:08,560
found this finishing paper

00:10:05,440 --> 00:10:09,600
called fastboxes by none other than

00:10:08,560 --> 00:10:12,000
leslie lampert

00:10:09,600 --> 00:10:13,920
a turing global winner also the inventor

00:10:12,000 --> 00:10:15,839
of tl plus

00:10:13,920 --> 00:10:17,519
so paxos is the same no paper from

00:10:15,839 --> 00:10:20,399
disabled system architecture

00:10:17,519 --> 00:10:22,320
sdps systems history like super

00:10:20,399 --> 00:10:26,640
important paper

00:10:22,320 --> 00:10:29,600
and in the end there was a model boxes

00:10:26,640 --> 00:10:30,800
a tele-apple specification for paxos a

00:10:29,600 --> 00:10:33,120
design

00:10:30,800 --> 00:10:34,000
just more formal design you can actually

00:10:33,120 --> 00:10:37,200
check

00:10:34,000 --> 00:10:39,839
up to some state size

00:10:37,200 --> 00:10:41,519
okay this is good like this is something

00:10:39,839 --> 00:10:44,160
we can use

00:10:41,519 --> 00:10:44,800
and he was like yes we need to use this

00:10:44,160 --> 00:10:47,040
like

00:10:44,800 --> 00:10:48,959
this is a famous great tool like please

00:10:47,040 --> 00:10:50,720
guys use it it's like amazing please try

00:10:48,959 --> 00:10:53,600
it out let me know what you think

00:10:50,720 --> 00:10:54,000
and people were like okay i'm busy i

00:10:53,600 --> 00:10:55,760
have a

00:10:54,000 --> 00:10:57,200
request to review or something something

00:10:55,760 --> 00:10:59,040
something so

00:10:57,200 --> 00:11:00,560
remember those misconceptions from like

00:10:59,040 --> 00:11:03,600
five minutes ago

00:11:00,560 --> 00:11:05,680
other engineers hate it as well

00:11:03,600 --> 00:11:06,880
so he was like him yeah i need some

00:11:05,680 --> 00:11:09,120
really hard

00:11:06,880 --> 00:11:10,640
issue like for these algorithms to prove

00:11:09,120 --> 00:11:12,800
it and for somebody else to become

00:11:10,640 --> 00:11:13,600
interested in super enthusiastic like i

00:11:12,800 --> 00:11:16,800
am

00:11:13,600 --> 00:11:20,160
so he found a project called dynamodb

00:11:16,800 --> 00:11:23,120
which at the time it was in his infancy

00:11:20,160 --> 00:11:23,839
and here our second actor comes into

00:11:23,120 --> 00:11:26,480
play

00:11:23,839 --> 00:11:27,760
engineer tr he enters the story with

00:11:26,480 --> 00:11:29,200
dynamodb

00:11:27,760 --> 00:11:31,279
so he performed all the classical

00:11:29,200 --> 00:11:32,399
testing approaches but still had some

00:11:31,279 --> 00:11:34,160
issues and

00:11:32,399 --> 00:11:35,600
he wasn't like super happy how the thing

00:11:34,160 --> 00:11:38,720
went

00:11:35,600 --> 00:11:40,800
a couple of weeks with the laplace so

00:11:38,720 --> 00:11:41,760
just couple of weeks he learned it he

00:11:40,800 --> 00:11:44,000
tried tao

00:11:41,760 --> 00:11:45,760
he found a bug in his design requiring

00:11:44,000 --> 00:11:48,000
35 high level steps

00:11:45,760 --> 00:11:49,920
plus two more bugs he found just a

00:11:48,000 --> 00:11:52,639
couple of weeks of tie plus

00:11:49,920 --> 00:11:53,760
this box would surface in production in

00:11:52,639 --> 00:11:56,480
less than a few months

00:11:53,760 --> 00:11:57,040
under high load because 45 high-level

00:11:56,480 --> 00:11:58,959
taps

00:11:57,040 --> 00:12:00,720
sounds like a lot but when you're

00:11:58,959 --> 00:12:01,360
dealing with huge number of requests per

00:12:00,720 --> 00:12:03,360
second

00:12:01,360 --> 00:12:06,000
it actually isn't you know remember that

00:12:03,360 --> 00:12:09,120
nasa guy previously

00:12:06,000 --> 00:12:13,120
underestimated the likelihood of really

00:12:09,120 --> 00:12:15,040
bad bugs occurring in his uh

00:12:13,120 --> 00:12:16,320
retrospective memoir in this paper i

00:12:15,040 --> 00:12:18,639
mentioned

00:12:16,320 --> 00:12:20,320
he was like i wish i knew this sooner

00:12:18,639 --> 00:12:21,440
like this is amazing this would help me

00:12:20,320 --> 00:12:23,519
design better

00:12:21,440 --> 00:12:26,720
systems faster and quicker he was like

00:12:23,519 --> 00:12:26,720
yes please yes

00:12:27,279 --> 00:12:30,399
and it's spread like many other systems

00:12:29,440 --> 00:12:33,360
that yes

00:12:30,399 --> 00:12:34,560
are using this technique so they wanted

00:12:33,360 --> 00:12:36,800
to somehow

00:12:34,560 --> 00:12:38,320
present it to other engineers you know

00:12:36,800 --> 00:12:39,839
now it's a marketing problem we know we

00:12:38,320 --> 00:12:41,680
have a good product it's like amazing

00:12:39,839 --> 00:12:42,880
technique which can improve us to write

00:12:41,680 --> 00:12:45,279
more quality software

00:12:42,880 --> 00:12:46,480
in shorter time but marketing is like

00:12:45,279 --> 00:12:48,880
formal methods it's like

00:12:46,480 --> 00:12:50,160
do not touch it it's like no no don't go

00:12:48,880 --> 00:12:51,440
there this is like complicated this is

00:12:50,160 --> 00:12:54,959
what harvard people do

00:12:51,440 --> 00:12:58,399
not software so they called it the buggy

00:12:54,959 --> 00:12:59,920
designs it's much more friendly

00:12:58,399 --> 00:13:03,200
resigning term than

00:12:59,920 --> 00:13:04,880
formal methods it's debugging designs

00:13:03,200 --> 00:13:07,120
even to make it more clearer to the

00:13:04,880 --> 00:13:11,120
average programmer even a novice one

00:13:07,120 --> 00:13:13,200
it's exhaustively testable pseudocode

00:13:11,120 --> 00:13:14,959
which is exactly what it is you have

00:13:13,200 --> 00:13:16,000
some kind of slow code which is a formal

00:13:14,959 --> 00:13:18,000
language

00:13:16,000 --> 00:13:19,600
you can test whether your assumptions

00:13:18,000 --> 00:13:22,639
hold in this system

00:13:19,600 --> 00:13:25,519
you design amazing marketing

00:13:22,639 --> 00:13:27,760
and they use it in s3 dynamodb ebs

00:13:25,519 --> 00:13:30,240
internal local solution manager whatever

00:13:27,760 --> 00:13:31,920
if you have competitive systems use it

00:13:30,240 --> 00:13:34,399
it's amazing

00:13:31,920 --> 00:13:34,959
and they found multiple bugs they found

00:13:34,399 --> 00:13:37,839
some

00:13:34,959 --> 00:13:39,680
further bug improvements uh they found

00:13:37,839 --> 00:13:41,600
some performance improvements

00:13:39,680 --> 00:13:42,959
we will talk about the benefits later at

00:13:41,600 --> 00:13:45,040
the end of this section

00:13:42,959 --> 00:13:46,320
and end of this historic section so

00:13:45,040 --> 00:13:49,760
let's go

00:13:46,320 --> 00:13:50,800
to microsoft so remember the telia plus

00:13:49,760 --> 00:13:52,720
inventor

00:13:50,800 --> 00:13:53,920
he wrote a book specifying systems in

00:13:52,720 --> 00:13:55,839
00:13:53,920 --> 00:13:57,199
where he introduced this tool he wrote

00:13:55,839 --> 00:13:59,040
earlier plus

00:13:57,199 --> 00:14:00,959
around the same time he joined microsoft

00:13:59,040 --> 00:14:03,279
research did some things there

00:14:00,959 --> 00:14:05,199
but not that related to modular checkers

00:14:03,279 --> 00:14:08,399
or steel plus at least

00:14:05,199 --> 00:14:11,760
not that directed as in

00:14:08,399 --> 00:14:11,760
used in production systems

00:14:12,560 --> 00:14:17,440
and then aws was hey we are using feral

00:14:16,399 --> 00:14:20,560
metals look at us

00:14:17,440 --> 00:14:21,680
it was april 2015. so their internalized

00:14:20,560 --> 00:14:23,760
microsoft they were like

00:14:21,680 --> 00:14:25,120
hey we have this guy who admitted this

00:14:23,760 --> 00:14:26,480
stuff so maybe

00:14:25,120 --> 00:14:27,920
something something should happen and

00:14:26,480 --> 00:14:29,199
there was like back and forth back and

00:14:27,920 --> 00:14:32,959
forth

00:14:29,199 --> 00:14:36,079
at december 26 2015

00:14:32,959 --> 00:14:38,720
uh at least according to my research

00:14:36,079 --> 00:14:39,680
satya nadal ceo of microsoft at the time

00:14:38,720 --> 00:14:41,440
he sent an email

00:14:39,680 --> 00:14:43,040
like tila plus is awesome just do

00:14:41,440 --> 00:14:46,240
whatever you can with it

00:14:43,040 --> 00:14:48,240
which was okay let's do it

00:14:46,240 --> 00:14:50,230
so they had a bunch of eternal trainings

00:14:48,240 --> 00:14:51,760
a bunch of snowboard sharing bunch of

00:14:50,230 --> 00:14:54,320
[Music]

00:14:51,760 --> 00:14:55,440
dissemination of the knowledge and etc

00:14:54,320 --> 00:14:57,760
and they use it a lot

00:14:55,440 --> 00:14:59,279
like in service fabric in batch of azure

00:14:57,760 --> 00:15:02,639
from bachelorette working out

00:14:59,279 --> 00:15:05,040
hub and in all these instances tiller

00:15:02,639 --> 00:15:06,639
plus has uncovered a safety violation

00:15:05,040 --> 00:15:09,040
even in their most confident

00:15:06,639 --> 00:15:09,920
implementation so even after multiple

00:15:09,040 --> 00:15:12,399
seniors

00:15:09,920 --> 00:15:13,760
principal or super principal engineers

00:15:12,399 --> 00:15:15,279
like look at their code look at the

00:15:13,760 --> 00:15:17,519
designs

00:15:15,279 --> 00:15:19,440
they couldn't find this bug which this

00:15:17,519 --> 00:15:21,199
simple technique found

00:15:19,440 --> 00:15:22,720
i mean i sound like a snakehouse tell me

00:15:21,199 --> 00:15:25,120
like hey

00:15:22,720 --> 00:15:26,639
you only need this your doctors don't

00:15:25,120 --> 00:15:27,440
want you to know about this tool but

00:15:26,639 --> 00:15:29,360
it's like

00:15:27,440 --> 00:15:32,959
yeah they want to know you because it

00:15:29,360 --> 00:15:32,959
makes you write better software

00:15:33,040 --> 00:15:36,800
and previously other people used as well

00:15:35,920 --> 00:15:39,920
intel

00:15:36,800 --> 00:15:41,360
for hardware stuff microsoft for xbox

00:15:39,920 --> 00:15:44,399
and azure aws

00:15:41,360 --> 00:15:46,800
already mentioned there is an open com

00:15:44,399 --> 00:15:47,440
real-time operating system which is a

00:15:46,800 --> 00:15:50,800
real-time

00:15:47,440 --> 00:15:53,440
kernel which runs in the satellites

00:15:50,800 --> 00:15:55,680
like in space you need to have code

00:15:53,440 --> 00:15:57,360
which runs in space for a long time

00:15:55,680 --> 00:15:59,040
and they managed to reduce their code

00:15:57,360 --> 00:16:01,279
base by 10 times

00:15:59,040 --> 00:16:02,959
because telea plus helped them design

00:16:01,279 --> 00:16:05,680
this system better

00:16:02,959 --> 00:16:07,600
it's an elastic search for some 7.0

00:16:05,680 --> 00:16:09,040
onwards it's mongodb even has some

00:16:07,600 --> 00:16:12,880
specification for their

00:16:09,040 --> 00:16:15,680
distributed stuff so it's used

00:16:12,880 --> 00:16:16,160
now let's cover the benefits first one

00:16:15,680 --> 00:16:20,000
you have

00:16:16,160 --> 00:16:21,759
improved design quality well how

00:16:20,000 --> 00:16:24,240
you get improved design quality by just

00:16:21,759 --> 00:16:27,279
writing it down exactly that

00:16:24,240 --> 00:16:30,560
when we write stuff

00:16:27,279 --> 00:16:33,920
down usually we think more about them

00:16:30,560 --> 00:16:39,199
because we express our assumptions

00:16:33,920 --> 00:16:39,199
or etc so this is like

00:16:39,519 --> 00:16:43,680
writing what you mean so other people

00:16:41,680 --> 00:16:45,040
understand you need to be more explicit

00:16:43,680 --> 00:16:47,759
and then you recover assumptions you

00:16:45,040 --> 00:16:49,680
held which are not necessarily true

00:16:47,759 --> 00:16:52,240
because you have better design quality

00:16:49,680 --> 00:16:54,160
you have less bugs

00:16:52,240 --> 00:16:55,920
because you can verify some assumptions

00:16:54,160 --> 00:16:58,000
some invariants and rules

00:16:55,920 --> 00:17:00,000
you can perform optimizations you

00:16:58,000 --> 00:17:01,440
wouldn't necessarily dare to do

00:17:00,000 --> 00:17:04,400
because you would be scared of safety

00:17:01,440 --> 00:17:05,120
properties for example sometimes you

00:17:04,400 --> 00:17:07,679
don't need

00:17:05,120 --> 00:17:09,439
to fully synchronize some operations you

00:17:07,679 --> 00:17:10,480
can do it in a sickness manner

00:17:09,439 --> 00:17:12,559
which will lead to performance

00:17:10,480 --> 00:17:14,880
optimization because the

00:17:12,559 --> 00:17:17,039
cyclone synchronization stuff is

00:17:14,880 --> 00:17:18,400
expensive meetings are expensive

00:17:17,039 --> 00:17:20,319
but you need to have safety property of

00:17:18,400 --> 00:17:20,959
the whole system so you need to know

00:17:20,319 --> 00:17:22,880
whether

00:17:20,959 --> 00:17:26,559
it's safe to actually release some

00:17:22,880 --> 00:17:28,400
assumptions release some constraints

00:17:26,559 --> 00:17:30,559
by improving design quality having less

00:17:28,400 --> 00:17:31,120
bugs you can actually improve them to

00:17:30,559 --> 00:17:33,360
market

00:17:31,120 --> 00:17:35,039
because with this kind of tools you have

00:17:33,360 --> 00:17:35,679
a design you can quickly iterate on a

00:17:35,039 --> 00:17:38,799
new design

00:17:35,679 --> 00:17:42,880
design design and last

00:17:38,799 --> 00:17:46,000
but not least it's documentation

00:17:42,880 --> 00:17:48,960
as you can see in this next slide

00:17:46,000 --> 00:17:51,440
how do you explain your system design to

00:17:48,960 --> 00:17:52,320
another engineer or to yourself after a

00:17:51,440 --> 00:17:53,760
few beers and a

00:17:52,320 --> 00:17:55,360
couple of years later in a different

00:17:53,760 --> 00:17:59,520
team

00:17:55,360 --> 00:18:01,600
so we have three usual approaches

00:17:59,520 --> 00:18:02,559
so one is informal model where you can

00:18:01,600 --> 00:18:05,120
write prose

00:18:02,559 --> 00:18:06,640
like this is how it works you can do it

00:18:05,120 --> 00:18:09,120
like rfc with mass

00:18:06,640 --> 00:18:09,760
shouldn't etc but it's like writing

00:18:09,120 --> 00:18:13,440
prose

00:18:09,760 --> 00:18:15,440
not like philosophy code but

00:18:13,440 --> 00:18:16,799
this is how it should do this is what we

00:18:15,440 --> 00:18:18,799
do etc

00:18:16,799 --> 00:18:20,400
this isn't really complex it's not

00:18:18,799 --> 00:18:22,480
really super precise because there could

00:18:20,400 --> 00:18:24,799
be some ambiguities

00:18:22,480 --> 00:18:25,840
on the other end of the extremes there

00:18:24,799 --> 00:18:28,000
is code

00:18:25,840 --> 00:18:29,520
which is super precise this is exactly

00:18:28,000 --> 00:18:32,320
what your system is doing

00:18:29,520 --> 00:18:34,559
it's rupert written but it's like tens

00:18:32,320 --> 00:18:37,840
of thousands of thousands of lines of it

00:18:34,559 --> 00:18:39,919
and can be really complex to read model

00:18:37,840 --> 00:18:41,440
checkers this model specification this

00:18:39,919 --> 00:18:44,320
modular checker language

00:18:41,440 --> 00:18:45,679
falls in between it's a bit more complex

00:18:44,320 --> 00:18:48,480
than informal prose

00:18:45,679 --> 00:18:49,120
but it's precise because you can check

00:18:48,480 --> 00:18:51,280
it

00:18:49,120 --> 00:18:53,200
and when a new engineer joins the team

00:18:51,280 --> 00:18:54,320
you can look at this more precise mode

00:18:53,200 --> 00:18:55,679
specification

00:18:54,320 --> 00:18:58,240
and can he can figure out what

00:18:55,679 --> 00:19:00,559
assumptions does the system have

00:18:58,240 --> 00:19:02,000
and as the system evolves over time you

00:19:00,559 --> 00:19:04,799
update this model spec

00:19:02,000 --> 00:19:06,400
and keep everybody in sync and you can

00:19:04,799 --> 00:19:08,720
actually

00:19:06,400 --> 00:19:10,880
analyze whether you can do this

00:19:08,720 --> 00:19:14,160
improvement to the design

00:19:10,880 --> 00:19:16,160
so here is some example you have two

00:19:14,160 --> 00:19:17,280
kubernetes objects inspired by

00:19:16,160 --> 00:19:20,400
kubernetes

00:19:17,280 --> 00:19:22,559
on the left is an object named bar

00:19:20,400 --> 00:19:24,400
for which the kubernetes operator will

00:19:22,559 --> 00:19:26,880
create some object

00:19:24,400 --> 00:19:28,000
for via generate name it will create an

00:19:26,880 --> 00:19:30,320
object with the right name

00:19:28,000 --> 00:19:33,120
and kubernetes aps server will fill the

00:19:30,320 --> 00:19:34,880
name for something something for it

00:19:33,120 --> 00:19:37,200
if we want to a variety operator which

00:19:34,880 --> 00:19:39,520
does this for you

00:19:37,200 --> 00:19:42,559
we start by importing some stuff so

00:19:39,520 --> 00:19:46,080
typical programming language 101

00:19:42,559 --> 00:19:49,760
we define some variables this is

00:19:46,080 --> 00:19:52,799
totally like usual they work we define

00:19:49,760 --> 00:19:53,120
a bar object which has a name full and

00:19:52,799 --> 00:19:55,280
has

00:19:53,120 --> 00:19:56,799
it hasn't created the full object we

00:19:55,280 --> 00:19:58,640
want to remember that

00:19:56,799 --> 00:20:00,320
and we have a list of four objects which

00:19:58,640 --> 00:20:04,320
exist

00:20:00,320 --> 00:20:06,799
in the system as you can see it's a bit

00:20:04,320 --> 00:20:08,080
different syntax is most c or python

00:20:06,799 --> 00:20:10,080
like languages

00:20:08,080 --> 00:20:13,919
but it's nothing like you couldn't learn

00:20:10,080 --> 00:20:17,200
in a day or two it's not that difficult

00:20:13,919 --> 00:20:18,640
so usually when you want to

00:20:17,200 --> 00:20:20,799
check some proposition systems there are

00:20:18,640 --> 00:20:22,559
two types of properties you care about

00:20:20,799 --> 00:20:23,919
safety properties and liveness

00:20:22,559 --> 00:20:27,280
properties

00:20:23,919 --> 00:20:29,039
safety nothing bad will happen you won't

00:20:27,280 --> 00:20:32,720
lose data

00:20:29,039 --> 00:20:34,400
nobody will die etc lightness properties

00:20:32,720 --> 00:20:36,880
something good will happen your system

00:20:34,400 --> 00:20:38,720
will produce requests

00:20:36,880 --> 00:20:40,000
with all these methods usually you focus

00:20:38,720 --> 00:20:41,760
on safety properties

00:20:40,000 --> 00:20:43,280
because they are much easier to define

00:20:41,760 --> 00:20:45,039
and easier to test for

00:20:43,280 --> 00:20:46,720
liveness because usually you're not

00:20:45,039 --> 00:20:49,360
operating on some kind of

00:20:46,720 --> 00:20:50,559
hard real-time kernels or hardware time

00:20:49,360 --> 00:20:53,440
hard drives

00:20:50,559 --> 00:20:54,559
it's really icky peaky to test and to

00:20:53,440 --> 00:20:57,840
specify so

00:20:54,559 --> 00:20:58,799
focus on safety we want to define safety

00:20:57,840 --> 00:21:01,120
property

00:20:58,799 --> 00:21:02,960
no more than one full object will exist

00:21:01,120 --> 00:21:06,000
in this system

00:21:02,960 --> 00:21:10,159
it will be our system invariant

00:21:06,000 --> 00:21:13,679
so just one full object that's it

00:21:10,159 --> 00:21:16,480
and we start writing our algorithm

00:21:13,679 --> 00:21:17,520
so far so good we have atomic start we

00:21:16,480 --> 00:21:21,039
have vial

00:21:17,520 --> 00:21:23,600
not bar object was created do something

00:21:21,039 --> 00:21:25,600
a controller reconciliation loop at in

00:21:23,600 --> 00:21:28,799
the end of this consolidation loop

00:21:25,600 --> 00:21:31,440
we assert we have exactly one

00:21:28,799 --> 00:21:32,960
bar by four object only the one we

00:21:31,440 --> 00:21:34,559
created

00:21:32,960 --> 00:21:38,000
so let's see what's in those three

00:21:34,559 --> 00:21:42,240
little dots our main reconciliation loop

00:21:38,000 --> 00:21:45,280
we have uh determinism

00:21:42,240 --> 00:21:48,640
oh this is interesting

00:21:45,280 --> 00:21:52,320
so we have a create object

00:21:48,640 --> 00:21:54,480
atomic operation you can even create

00:21:52,320 --> 00:21:55,440
a full object by creating it and

00:21:54,480 --> 00:21:58,720
appending it to

00:21:55,440 --> 00:22:02,240
critical objects or you can

00:21:58,720 --> 00:22:04,880
reboot during creation so your operator

00:22:02,240 --> 00:22:05,679
can crash at any time and you call this

00:22:04,880 --> 00:22:10,400
knowledge

00:22:05,679 --> 00:22:10,400
into this design this model

00:22:10,799 --> 00:22:15,039
so solomon can be created or you can

00:22:13,039 --> 00:22:17,679
crash and burn

00:22:15,039 --> 00:22:19,120
then what happens you then mark creation

00:22:17,679 --> 00:22:22,320
of object true

00:22:19,120 --> 00:22:22,320
or you crash and burn

00:22:22,720 --> 00:22:30,400
and now let's run it this is

00:22:26,240 --> 00:22:31,200
a tele plus runner integrated into vs

00:22:30,400 --> 00:22:33,679
code

00:22:31,200 --> 00:22:36,320
by the way previously this isn't pure

00:22:33,679 --> 00:22:38,320
tla plus this is something called pascal

00:22:36,320 --> 00:22:39,440
which lesser lamp would throw decade

00:22:38,320 --> 00:22:43,039
early after

00:22:39,440 --> 00:22:44,880
talia plus it has a nice syntax sugar

00:22:43,039 --> 00:22:46,320
but in the end it's translated to pure

00:22:44,880 --> 00:22:49,919
tla plus

00:22:46,320 --> 00:22:53,600
so where was it we have our error traits

00:22:49,919 --> 00:22:55,840
okay we found sequential states

00:22:53,600 --> 00:22:56,640
which violate our invariance which we

00:22:55,840 --> 00:23:00,480
define as

00:22:56,640 --> 00:23:02,640
a maximum of one full objectives

00:23:00,480 --> 00:23:05,120
so let's investigate we have a bar

00:23:02,640 --> 00:23:07,919
object just one which created this false

00:23:05,120 --> 00:23:10,080
and name is full for objects no and our

00:23:07,919 --> 00:23:14,320
program counter is at start

00:23:10,080 --> 00:23:14,320
so remember this this was start

00:23:14,640 --> 00:23:19,600
a step happens we are at create object

00:23:17,760 --> 00:23:21,120
okay we are here and we want to create

00:23:19,600 --> 00:23:24,720
object nothing good

00:23:21,120 --> 00:23:25,440
so everything's fine and after creating

00:23:24,720 --> 00:23:29,919
an object

00:23:25,440 --> 00:23:32,240
we create it but then we crash and burn

00:23:29,919 --> 00:23:33,280
so instead of marking it creation we

00:23:32,240 --> 00:23:36,400
crash and burn

00:23:33,280 --> 00:23:39,600
and repeat this whole loop again

00:23:36,400 --> 00:23:41,919
we crash burn we start again the create

00:23:39,600 --> 00:23:45,600
object

00:23:41,919 --> 00:23:49,200
and we broke the invariant we have two

00:23:45,600 --> 00:23:51,840
observations why is that because in this

00:23:49,200 --> 00:23:54,240
code we first create an object

00:23:51,840 --> 00:23:56,080
then market is created which is

00:23:54,240 --> 00:24:00,080
obviously a design error

00:23:56,080 --> 00:24:01,279
it's a bug with this i finished my

00:24:00,080 --> 00:24:03,520
presentation

00:24:01,279 --> 00:24:05,520
and please ask me any questions you want

00:24:03,520 --> 00:24:08,640
like i love this discussion

00:24:05,520 --> 00:24:10,799
so let's start with q a session thank

00:24:08,640 --> 00:24:10,799

YouTube URL: https://www.youtube.com/watch?v=l5WU2CAmGXA


