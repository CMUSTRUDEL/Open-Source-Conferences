Title: Into the Deep Waters of API Machinery - Federico Bongiovanni & Daniel Smith, Google, & David Eads
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4–7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Into the Deep Waters of API Machinery - Federico Bongiovanni & Daniel Smith, Google, & David Eads, Stefan Schimanski, Red Hat 

We'll cover 3 common icebergs with lightning talks: 1) My namespace won't delete, help! Why does Kubernetes sometimes refuse to delete a namespace? How to diagnose and resolve the root cause. 2) What is REST mappinp? Ever wonder how you're supposed to go from singular to plural, why we did it, and how to deal with it? What happens when two CRDs choose the same name? 3) Taking out the trash: Garbage Collection in Kubernetes. We'll explain how OwnerRefs, BlockOwnerDeletion, Foreground, Background, and GracePeriod work. 

https://sched.co/ekGp
Captions: 
	00:00:01,439 --> 00:00:06,160
hello kubernetes community

00:00:03,280 --> 00:00:07,520
welcome to our sig api machinery deep

00:00:06,160 --> 00:00:09,519
dive session

00:00:07,520 --> 00:00:12,320
my name is federico von giovanni and i

00:00:09,519 --> 00:00:14,880
am the co-chair of seek api machinery

00:00:12,320 --> 00:00:16,160
our agenda today will have three topics

00:00:14,880 --> 00:00:18,640
and a small bonus information

00:00:16,160 --> 00:00:20,480
at the end our first topic is going to

00:00:18,640 --> 00:00:22,880
be namespace termination

00:00:20,480 --> 00:00:23,920
and daniel smith from google is going to

00:00:22,880 --> 00:00:25,519
walk us through it

00:00:23,920 --> 00:00:27,359
using his signature handmade

00:00:25,519 --> 00:00:29,519
presentation style

00:00:27,359 --> 00:00:32,399
our second topic is going to be rest

00:00:29,519 --> 00:00:32,800
mappings and stefan shimansky from red

00:00:32,399 --> 00:00:34,880
card

00:00:32,800 --> 00:00:36,719
is going to unveil all the secrets on

00:00:34,880 --> 00:00:38,719
how it works and how to deal with

00:00:36,719 --> 00:00:41,600
special situations

00:00:38,719 --> 00:00:43,440
in our third topic david is from red hat

00:00:41,600 --> 00:00:44,719
will explain for us the mysteries of

00:00:43,440 --> 00:00:46,640
garbage collection

00:00:44,719 --> 00:00:48,079
and how does it work in all the special

00:00:46,640 --> 00:00:50,480
cases

00:00:48,079 --> 00:00:52,000
finally i will give a farewell with some

00:00:50,480 --> 00:00:55,120
quick info about the sig

00:00:52,000 --> 00:00:55,840
and our meetings so without any further

00:00:55,120 --> 00:00:57,760
delay

00:00:55,840 --> 00:01:01,840
let's get to it and go to the deep

00:00:57,760 --> 00:01:01,840
waters of sig api machinery

00:01:05,119 --> 00:01:08,640
hi everyone today i'd like to tell you a

00:01:07,200 --> 00:01:12,080
story

00:01:08,640 --> 00:01:15,920
a story is called 60807

00:01:12,080 --> 00:01:18,960
i'm daniel smith i co-tl the

00:01:15,920 --> 00:01:18,960
api machinery sig

00:01:19,280 --> 00:01:23,680
we're working on kubernetes since before

00:01:21,040 --> 00:01:23,680
was open source

00:01:24,720 --> 00:01:30,560
so i'm wobbling up on github original

00:01:27,600 --> 00:01:30,560
lava lamp on twitter

00:01:30,640 --> 00:01:36,240
i work for google software engineer

00:01:34,560 --> 00:01:38,000
i'm not speaking on behalf of google

00:01:36,240 --> 00:01:41,840
other than they

00:01:38,000 --> 00:01:41,840
support my presence in open source

00:01:42,320 --> 00:01:49,280
um i wrote

00:01:45,920 --> 00:01:50,079
daniel drawing my slides today turns out

00:01:49,280 --> 00:01:52,479
i can't

00:01:50,079 --> 00:01:55,840
draw and talk at the same time so we're

00:01:52,479 --> 00:01:55,840
doing this in two steps

00:01:58,479 --> 00:02:01,520
story begins with a user

00:02:04,799 --> 00:02:09,840
you won't be surprised that there's also

00:02:06,240 --> 00:02:09,840
a kubernetes cluster in this story

00:02:10,479 --> 00:02:15,280
and every cluster needs an api server

00:02:20,959 --> 00:02:24,720
and of concern particular concern in our

00:02:23,440 --> 00:02:26,959
story today is the

00:02:24,720 --> 00:02:27,760
namespace which i'm going to draw in a

00:02:26,959 --> 00:02:32,800
big

00:02:27,760 --> 00:02:32,800
fat line okay

00:02:35,040 --> 00:02:38,560
to give this namespace some sort of name

00:02:40,000 --> 00:02:43,760
we'll call it s2020

00:02:45,200 --> 00:02:51,840
because this user would like to delete

00:02:47,680 --> 00:02:51,840
this namespace

00:02:52,879 --> 00:02:58,640
so here's the action user says delete

00:02:56,400 --> 00:03:02,480
api server says sure

00:02:58,640 --> 00:03:05,120
that's the technical http response code

00:03:02,480 --> 00:03:06,159
these are posts to recreate maybe ir

00:03:05,120 --> 00:03:11,280
server says

00:03:06,159 --> 00:03:11,280
no it still exists there's a conflict

00:03:11,519 --> 00:03:18,480
api server is a villain how could this

00:03:14,879 --> 00:03:23,280
happen to us

00:03:18,480 --> 00:03:26,560
this makes the user sad and angry

00:03:23,280 --> 00:03:26,560
how could we do this to the user

00:03:30,159 --> 00:03:34,640
let's talk a little bit about how

00:03:32,400 --> 00:03:36,480
resources in kubernetes are deleted

00:03:34,640 --> 00:03:39,040
all objects and kubernetes are deleted

00:03:36,480 --> 00:03:39,040
the same way

00:03:39,360 --> 00:03:42,480
so although we're talking about a

00:03:40,799 --> 00:03:45,200
namespace right now

00:03:42,480 --> 00:03:46,799
there's some background information

00:03:45,200 --> 00:03:50,640
about deletion

00:03:46,799 --> 00:03:51,840
that might be useful as with many of

00:03:50,640 --> 00:03:55,439
much of what i'm saying

00:03:51,840 --> 00:03:55,439
this is a simplification

00:03:56,319 --> 00:03:59,360
because there's more to it for some

00:03:57,599 --> 00:04:01,360
particular objects but

00:03:59,360 --> 00:04:03,360
roughly speaking all kubernetes objects

00:04:01,360 --> 00:04:05,920
have metadata

00:04:03,360 --> 00:04:08,000
and inside this metadata there's two

00:04:05,920 --> 00:04:11,120
fields relevant to deletion

00:04:08,000 --> 00:04:14,239
first one is deletion timestamp

00:04:11,120 --> 00:04:15,920
if that has a non-empty value then the

00:04:14,239 --> 00:04:18,880
deletion process has started

00:04:15,920 --> 00:04:20,720
for that resource and there's also a

00:04:18,880 --> 00:04:23,759
list of finalizers

00:04:20,720 --> 00:04:25,040
and the deletion is not final until

00:04:23,759 --> 00:04:27,040
all of those finalizers have been

00:04:25,040 --> 00:04:29,120
removed

00:04:27,040 --> 00:04:30,639
slightly confusing because the literal

00:04:29,120 --> 00:04:31,040
name of the finalizer that we care about

00:04:30,639 --> 00:04:34,320
today

00:04:31,040 --> 00:04:35,199
is kubernetes and this is the finalizer

00:04:34,320 --> 00:04:37,360
that the

00:04:35,199 --> 00:04:39,199
that is removed when the namespace

00:04:37,360 --> 00:04:40,880
object is empty

00:04:39,199 --> 00:04:44,160
okay so until that is removed the

00:04:40,880 --> 00:04:46,080
namespace is not deleted from the system

00:04:44,160 --> 00:04:47,919
i'm leaving out some details about

00:04:46,080 --> 00:04:49,120
namespaces have

00:04:47,919 --> 00:04:51,680
special places they keep their

00:04:49,120 --> 00:04:57,840
finalizers roughly speaking

00:04:51,680 --> 00:04:57,840
all objects work like this

00:04:58,720 --> 00:05:02,560
so let's look at our scenario again

00:05:03,520 --> 00:05:07,680
the component in kubernetes responsible

00:05:05,520 --> 00:05:09,520
for removing this finalizer

00:05:07,680 --> 00:05:13,199
is in controller manager it's the

00:05:09,520 --> 00:05:13,199
namespace lifecycle controller

00:05:22,960 --> 00:05:26,960
its job is to watch namespaces that have

00:05:25,199 --> 00:05:29,759
begun the deletion process

00:05:26,960 --> 00:05:32,880
ensure that they are empty that all the

00:05:29,759 --> 00:05:35,840
resources inside them have been deleted

00:05:32,880 --> 00:05:38,320
and then remove that finalizer the space

00:05:35,840 --> 00:05:39,919
lifecycle controller is the villain

00:05:38,320 --> 00:05:42,240
now to list the resources inside of a

00:05:39,919 --> 00:05:43,840
namespace you need to know which

00:05:42,240 --> 00:05:46,479
types of resources there are to be

00:05:43,840 --> 00:05:49,360
listed the process of figuring that out

00:05:46,479 --> 00:05:49,360
is called discovery

00:05:51,360 --> 00:05:55,120
and at this point you might be asking

00:05:53,759 --> 00:05:58,319
yourself

00:05:55,120 --> 00:05:58,319
how does discovery work

00:05:58,639 --> 00:06:02,240
well i'm about to tell you all api

00:06:01,600 --> 00:06:05,520
server

00:06:02,240 --> 00:06:08,000
all api requests in kubernetes uh have a

00:06:05,520 --> 00:06:10,400
url path this is this identifies what

00:06:08,000 --> 00:06:11,919
exactly you're making the request about

00:06:10,400 --> 00:06:13,440
right and again i'm this is a

00:06:11,919 --> 00:06:15,840
simplification but

00:06:13,440 --> 00:06:17,520
for our purposes all api requests start

00:06:15,840 --> 00:06:20,720
with the

00:06:17,520 --> 00:06:21,680
word apis and the next thing that comes

00:06:20,720 --> 00:06:24,479
is a group

00:06:21,680 --> 00:06:25,039
the api group the next thing is a

00:06:24,479 --> 00:06:29,919
version

00:06:25,039 --> 00:06:29,919
and after that is the resource

00:06:31,280 --> 00:06:34,880
the resource is the thing that goes in

00:06:32,720 --> 00:06:37,680
the url path the kind is the

00:06:34,880 --> 00:06:39,520
is the the the type right in a type

00:06:37,680 --> 00:06:43,199
system sense

00:06:39,520 --> 00:06:46,560
um so if you make an api request and you

00:06:43,199 --> 00:06:48,800
just say apis if you stop there then

00:06:46,560 --> 00:06:51,360
you get a list of group versions that

00:06:48,800 --> 00:06:54,720
api server knows about

00:06:51,360 --> 00:06:55,759
and if you list the group you get a list

00:06:54,720 --> 00:06:59,599
of versions

00:06:55,759 --> 00:06:59,599
that are inside that group

00:06:59,759 --> 00:07:03,840
right a list of versions and if you list

00:07:02,400 --> 00:07:06,479
a group and a version

00:07:03,840 --> 00:07:07,120
then api server will tell you which

00:07:06,479 --> 00:07:10,400
kinds

00:07:07,120 --> 00:07:10,400
are inside that group version

00:07:15,280 --> 00:07:19,520
and if you say more than that then

00:07:16,639 --> 00:07:22,720
you're making an actual api request

00:07:19,520 --> 00:07:26,000
which will do you some good like

00:07:22,720 --> 00:07:30,800
list objects or just

00:07:26,000 --> 00:07:35,120
you know something useful

00:07:30,800 --> 00:07:35,120
so how does the api server fulfill this

00:07:35,280 --> 00:07:40,080
contract to do that we should talk a

00:07:38,639 --> 00:07:42,639
little bit about api server

00:07:40,080 --> 00:07:44,560
api server is actually three api servers

00:07:42,639 --> 00:07:45,520
in a trench code the first one is the

00:07:44,560 --> 00:07:48,240
aggregator

00:07:45,520 --> 00:07:48,800
the second one is the built-ins it

00:07:48,240 --> 00:07:50,479
serves

00:07:48,800 --> 00:07:53,280
pods and services and stuff and the last

00:07:50,479 --> 00:07:56,000
one is the extensions api server

00:07:53,280 --> 00:07:57,120
more commonly known as crds and if a

00:07:56,000 --> 00:07:59,039
request can't be served by the

00:07:57,120 --> 00:08:00,800
aggregator it goes to the built-ins

00:07:59,039 --> 00:08:02,080
if that one doesn't want it it goes to

00:08:00,800 --> 00:08:02,960
the extensions and if that one doesn't

00:08:02,080 --> 00:08:05,919
want it

00:08:02,960 --> 00:08:07,360
it gets a 404 which i've conveniently

00:08:05,919 --> 00:08:09,599
drawn off the bottom of the screen for

00:08:07,360 --> 00:08:09,599
you

00:08:11,039 --> 00:08:15,520
now the aggregator may know what to do

00:08:14,400 --> 00:08:19,840
with the request

00:08:15,520 --> 00:08:21,440
and it may be for a external api server

00:08:19,840 --> 00:08:23,759
this means that that request must be

00:08:21,440 --> 00:08:25,919
proxied it is not

00:08:23,759 --> 00:08:28,000
served from the same process as the

00:08:25,919 --> 00:08:31,440
kubernetes api server

00:08:28,000 --> 00:08:31,440
the aggregator is the villain

00:08:31,599 --> 00:08:35,039
the canonical example is the metrics api

00:08:33,279 --> 00:08:38,320
server

00:08:35,039 --> 00:08:39,440
which kubernetes ships by default

00:08:38,320 --> 00:08:41,919
this means that there's various things

00:08:39,440 --> 00:08:45,040
that could go wrong maybe your

00:08:41,919 --> 00:08:48,640
network is not working

00:08:45,040 --> 00:08:51,600
um at least that link of your network

00:08:48,640 --> 00:08:52,839
or maybe the metrics api server is

00:08:51,600 --> 00:08:57,440
co-located with

00:08:52,839 --> 00:08:59,440
a process that's hogging the node or

00:08:57,440 --> 00:09:02,000
maybe it just has the wrong resource

00:08:59,440 --> 00:09:02,000
requirements

00:09:03,680 --> 00:09:09,839
in any case the

00:09:06,720 --> 00:09:11,760
aggregator needs to get the kinds from

00:09:09,839 --> 00:09:13,120
the target api server right only the

00:09:11,760 --> 00:09:14,640
groups and versions are registered with

00:09:13,120 --> 00:09:17,839
the system

00:09:14,640 --> 00:09:19,839
so uh if that

00:09:17,839 --> 00:09:21,040
network if that external api server

00:09:19,839 --> 00:09:23,040
can't be reached

00:09:21,040 --> 00:09:24,560
then there's no way for the aggregator

00:09:23,040 --> 00:09:25,839
to tell you which kinds

00:09:24,560 --> 00:09:28,320
are in the group version that you're

00:09:25,839 --> 00:09:32,080
asking about

00:09:28,320 --> 00:09:32,080
the metrics api server is the villain

00:09:32,880 --> 00:09:36,160
that's kind of unfortunate but it is

00:09:34,880 --> 00:09:39,519
also unavoidable

00:09:36,160 --> 00:09:40,640
because the extension api server

00:09:39,519 --> 00:09:43,600
is the only thing that knows what it

00:09:40,640 --> 00:09:47,760
serves aggregator cannot know that

00:09:43,600 --> 00:09:50,320
it would be very heavy-handed to require

00:09:47,760 --> 00:09:52,720
api authors to list that to pre-register

00:09:50,320 --> 00:09:52,720
that with the

00:09:53,360 --> 00:09:56,720
aggregator it also wouldn't help the

00:09:54,800 --> 00:09:58,480
problem because even if you know what

00:09:56,720 --> 00:09:59,839
kinds if you can't actually go out and

00:09:58,480 --> 00:10:01,519
list those things

00:09:59,839 --> 00:10:04,160
then you also can't confirm that they're

00:10:01,519 --> 00:10:05,279
deleted if the lifecycle controller

00:10:04,160 --> 00:10:07,760
can't discover the

00:10:05,279 --> 00:10:09,440
the kinds that it should be deleting it

00:10:07,760 --> 00:10:10,160
is never certain that the namespace is

00:10:09,440 --> 00:10:11,200
empty

00:10:10,160 --> 00:10:12,959
and if it's not certain that the

00:10:11,200 --> 00:10:15,440
namespace is empty then it can't remove

00:10:12,959 --> 00:10:17,519
that finalizer

00:10:15,440 --> 00:10:21,120
so whose job is it to make sure that

00:10:17,519 --> 00:10:22,640
this thing is working anyway

00:10:21,120 --> 00:10:24,160
i think it is the job of the system

00:10:22,640 --> 00:10:27,360
administrator

00:10:24,160 --> 00:10:28,720
the cluster administrator rather

00:10:27,360 --> 00:10:30,560
and i think the cluster administrator

00:10:28,720 --> 00:10:33,839
should be performing this job by using

00:10:30,560 --> 00:10:33,839
some monitoring

00:10:34,399 --> 00:10:37,839
the metrics api server is served by a

00:10:37,279 --> 00:10:40,240
regular

00:10:37,839 --> 00:10:41,040
kubernetes pod so it should be possible

00:10:40,240 --> 00:10:44,720
to

00:10:41,040 --> 00:10:46,079
monitor it another way you can monitor

00:10:44,720 --> 00:10:47,920
the overall health and

00:10:46,079 --> 00:10:50,079
like not just the specific metrics api

00:10:47,920 --> 00:10:52,160
server but if you just run the command

00:10:50,079 --> 00:10:53,279
cube control api resources once in a

00:10:52,160 --> 00:10:55,120
while

00:10:53,279 --> 00:10:56,399
it does this discovery process and it'll

00:10:55,120 --> 00:10:58,560
tell you if some group is

00:10:56,399 --> 00:10:59,600
not working and then you can look at the

00:10:58,560 --> 00:11:02,720
api service

00:10:59,600 --> 00:11:05,920
object for that group and figure out

00:11:02,720 --> 00:11:08,160
what component is not happy

00:11:05,920 --> 00:11:11,680
so thank you for listening to my talk

00:11:08,160 --> 00:11:14,560
and watching robo daniel draw these

00:11:11,680 --> 00:11:15,680
if you think that we could do better i'd

00:11:14,560 --> 00:11:18,480
encourage you to

00:11:15,680 --> 00:11:18,800
come help us improve our error messages

00:11:18,480 --> 00:11:23,600
or

00:11:18,800 --> 00:11:23,600
our design yeah

00:11:26,839 --> 00:11:29,839
thanks

00:11:31,200 --> 00:11:34,959
the system administrator is the villain

00:11:36,560 --> 00:11:40,959
welcome to the second part of the seek

00:11:39,120 --> 00:11:42,640
api machinery deep live today

00:11:40,959 --> 00:11:44,880
i want to talk about a concept which is

00:11:42,640 --> 00:11:47,120
pretty central in kubernetes but it's

00:11:44,880 --> 00:11:48,240
not well known to many people and maybe

00:11:47,120 --> 00:11:50,480
if they use client go

00:11:48,240 --> 00:11:52,000
and build some non-trivial controllers

00:11:50,480 --> 00:11:53,760
they have read it but they

00:11:52,000 --> 00:11:55,760
they might have question marks around

00:11:53,760 --> 00:11:57,600
that

00:11:55,760 --> 00:11:59,600
that mapping action is very simple just

00:11:57,600 --> 00:12:00,240
say cue cuddle get pots in your terminal

00:11:59,600 --> 00:12:02,240
and

00:12:00,240 --> 00:12:03,600
get parts is a command which is generic

00:12:02,240 --> 00:12:05,200
so generic means that

00:12:03,600 --> 00:12:06,959
it doesn't know anything about pots it

00:12:05,200 --> 00:12:08,959
has to work with any every resource that

00:12:06,959 --> 00:12:11,839
is available and known to the cluster

00:12:08,959 --> 00:12:13,839
and to make that uh happen it has to

00:12:11,839 --> 00:12:16,240
query the discovery information of the

00:12:13,839 --> 00:12:17,760
cube api server so it has to ask it um

00:12:16,240 --> 00:12:19,519
what is the part and to do that

00:12:17,760 --> 00:12:20,880
if you increase the velocity to at least

00:12:19,519 --> 00:12:23,279
six you will see what it does

00:12:20,880 --> 00:12:24,320
it can be slash api to get the versions

00:12:23,279 --> 00:12:27,120
of the legacy api

00:12:24,320 --> 00:12:28,000
is queries apis to get api groups and

00:12:27,120 --> 00:12:29,839
their versions

00:12:28,000 --> 00:12:32,240
and then it continues in queries like

00:12:29,839 --> 00:12:35,519
more than 30 api group versions so api

00:12:32,240 --> 00:12:36,399
slash v1 api slash apps search b1 and 30

00:12:35,519 --> 00:12:37,600
more

00:12:36,399 --> 00:12:39,120
and after doing that it has all this

00:12:37,600 --> 00:12:39,760
information too to find out what the

00:12:39,120 --> 00:12:42,480
port is

00:12:39,760 --> 00:12:43,120
and it sees a part this resource which

00:12:42,480 --> 00:12:45,920
shows up

00:12:43,120 --> 00:12:46,800
in the api slash v1 so it's a legacy

00:12:45,920 --> 00:12:49,279
core api

00:12:46,800 --> 00:12:50,480
version v1 resource and from this

00:12:49,279 --> 00:12:52,000
information it also knows that it's

00:12:50,480 --> 00:12:53,680
namespace so part is namespace

00:12:52,000 --> 00:12:55,839
resource and from this information it

00:12:53,680 --> 00:12:56,560
can construct the url to to actually

00:12:55,839 --> 00:12:58,320
list

00:12:56,560 --> 00:13:00,079
the ports in the system and it knows its

00:12:58,320 --> 00:13:01,920
name space so it adds the namespaces

00:13:00,079 --> 00:13:04,160
default default is code one the

00:13:01,920 --> 00:13:05,360
namespace so it knows the url just by

00:13:04,160 --> 00:13:07,120
discovering information how to get

00:13:05,360 --> 00:13:08,880
supports that's what it does

00:13:07,120 --> 00:13:10,240
in the types of kubernetes there are

00:13:08,880 --> 00:13:12,160
kinds and resources

00:13:10,240 --> 00:13:14,399
kinds are the upper case singular words

00:13:12,160 --> 00:13:17,279
which you find in manifest usually

00:13:14,399 --> 00:13:18,079
and the resources they are components of

00:13:17,279 --> 00:13:21,200
urls

00:13:18,079 --> 00:13:21,920
so the group version and the resource

00:13:21,200 --> 00:13:24,079
name

00:13:21,920 --> 00:13:25,440
plus information of the scope that's all

00:13:24,079 --> 00:13:26,959
needed to build a url

00:13:25,440 --> 00:13:28,639
and the mapping between those two worlds

00:13:26,959 --> 00:13:30,000
it's called rest mapping and that's our

00:13:28,639 --> 00:13:32,320
topic today

00:13:30,000 --> 00:13:34,800
google resources and google kind we call

00:13:32,320 --> 00:13:36,880
them fully qualified or complete

00:13:34,800 --> 00:13:37,920
if the group the version and the name

00:13:36,880 --> 00:13:39,600
are provided

00:13:37,920 --> 00:13:41,519
if the group is empty it's a legal

00:13:39,600 --> 00:13:43,519
secret black for pots

00:13:41,519 --> 00:13:45,519
we have the same for clients and we can

00:13:43,519 --> 00:13:47,120
also talk about partial

00:13:45,519 --> 00:13:48,560
resources and partial kinds so in the

00:13:47,120 --> 00:13:49,839
first case the version is missing so

00:13:48,560 --> 00:13:52,800
abstractica said

00:13:49,839 --> 00:13:53,519
it's a partial kind v1 replica sets

00:13:52,800 --> 00:13:54,959
lower case

00:13:53,519 --> 00:13:57,440
it's a partial resource a group is

00:13:54,959 --> 00:13:58,880
missing and if both information

00:13:57,440 --> 00:14:00,560
those kinds of information are missing

00:13:58,880 --> 00:14:01,279
it's also partial so replica sets the

00:14:00,560 --> 00:14:02,959
loan

00:14:01,279 --> 00:14:04,880
has no group has no version and that's

00:14:02,959 --> 00:14:06,000
what we know everybody knows from qatar

00:14:04,880 --> 00:14:06,560
and usually you do it on the command

00:14:06,000 --> 00:14:08,560
line you can

00:14:06,560 --> 00:14:09,920
get replica sets it's a partial resource

00:14:08,560 --> 00:14:11,680
and the last mapper is used

00:14:09,920 --> 00:14:13,600
to to fill the missing information and

00:14:11,680 --> 00:14:15,199
to get a fully qualified resource which

00:14:13,600 --> 00:14:17,680
then can be used to query

00:14:15,199 --> 00:14:18,880
the replica sets there's a syntax to

00:14:17,680 --> 00:14:21,040
couple syntax to

00:14:18,880 --> 00:14:22,240
say this is group apps so dot apps tell

00:14:21,040 --> 00:14:24,560
us q carter

00:14:22,240 --> 00:14:26,079
and the group is given you can even just

00:14:24,560 --> 00:14:27,680
use a prefix and this is completed by

00:14:26,079 --> 00:14:28,959
the last mapper so dot a is completed to

00:14:27,680 --> 00:14:30,160
x v1

00:14:28,959 --> 00:14:33,040
and of course you can have complete

00:14:30,160 --> 00:14:34,959
group version resources.v1 dot apps

00:14:33,040 --> 00:14:36,320
if you try this prefix matching if you

00:14:34,959 --> 00:14:37,839
have a version it will fail because the

00:14:36,320 --> 00:14:40,000
raspberry pi doesn't support that

00:14:37,839 --> 00:14:41,440
if you try dot v1 without a group two

00:14:40,000 --> 00:14:42,399
cutter parsing doesn't work so it's also

00:14:41,440 --> 00:14:44,079
rejected

00:14:42,399 --> 00:14:46,079
everything i talked about here works for

00:14:44,079 --> 00:14:47,680
singular and plural so you can give a

00:14:46,079 --> 00:14:49,279
singular word here a singular partial

00:14:47,680 --> 00:14:52,480
resource it's completed to a

00:14:49,279 --> 00:14:54,160
complete pure resource

00:14:52,480 --> 00:14:56,079
where are these members used so we saw

00:14:54,160 --> 00:14:57,839
two cattle that we have server itself

00:14:56,079 --> 00:14:58,639
has some use of rest mappers so there

00:14:57,839 --> 00:15:00,399
are some

00:14:58,639 --> 00:15:02,160
gc garbage collection related admission

00:15:00,399 --> 00:15:03,680
plugin here but the main

00:15:02,160 --> 00:15:05,519
consumer of those class mappers

00:15:03,680 --> 00:15:07,680
especially discovery based ones has

00:15:05,519 --> 00:15:09,600
controllers controller manager

00:15:07,680 --> 00:15:11,199
horizontal port auto scaling can work

00:15:09,600 --> 00:15:13,120
for all the resources that have a scale

00:15:11,199 --> 00:15:14,240
subresource so this is a polymorphic or

00:15:13,120 --> 00:15:16,240
generic use case

00:15:14,240 --> 00:15:18,560
that's why asthmatic is involved in port

00:15:16,240 --> 00:15:20,240
disruption budget is also involved and

00:15:18,560 --> 00:15:22,399
the garbage collectors may be the most

00:15:20,240 --> 00:15:24,959
interesting case here and then we will

00:15:22,399 --> 00:15:26,160
spend several slides talking about the

00:15:24,959 --> 00:15:28,480
garbage collector and this uses

00:15:26,160 --> 00:15:30,639
mapping at this core um quota doesn't

00:15:28,480 --> 00:15:32,320
use last map being surprisingly but

00:15:30,639 --> 00:15:33,920
it uses discovery so it's not that

00:15:32,320 --> 00:15:36,160
surprising because discovery and last

00:15:33,920 --> 00:15:37,839
nothing are deeply connected

00:15:36,160 --> 00:15:39,680
uh quick look on the respect interface

00:15:37,839 --> 00:15:41,040
and go

00:15:39,680 --> 00:15:43,120
there are three kinds the yellow

00:15:41,040 --> 00:15:43,920
functions here they map partial

00:15:43,120 --> 00:15:47,120
resources

00:15:43,920 --> 00:15:48,880
to kinds they map the right ones partial

00:15:47,120 --> 00:15:50,000
resources to complete resources for the

00:15:48,880 --> 00:15:52,000
qualified resources

00:15:50,000 --> 00:15:53,279
and the green ones take group kinds

00:15:52,000 --> 00:15:54,959
complete so who kind of cannot be

00:15:53,279 --> 00:15:55,759
admitted complete group clients and

00:15:54,959 --> 00:15:57,519
versions

00:15:55,759 --> 00:15:58,800
to rest mappings and last mappings if

00:15:57,519 --> 00:16:00,000
you look here what ransomware is is

00:15:58,800 --> 00:16:02,560
actually the resource

00:16:00,000 --> 00:16:03,759
the kind fully qualified and scope so

00:16:02,560 --> 00:16:04,399
basically the last one is kind to

00:16:03,759 --> 00:16:06,560
resource

00:16:04,399 --> 00:16:07,839
and the green one is most interesting in

00:16:06,560 --> 00:16:09,759
the context of garbage collection

00:16:07,839 --> 00:16:10,560
because garbage creation uses that owner

00:16:09,759 --> 00:16:13,279
perforances

00:16:10,560 --> 00:16:14,240
are group kinds and so everything which

00:16:13,279 --> 00:16:15,759
we talk about here

00:16:14,240 --> 00:16:17,440
makes a difference or has influence on

00:16:15,759 --> 00:16:18,880
coverage collision

00:16:17,440 --> 00:16:20,240
so take let's take a look on the yellow

00:16:18,880 --> 00:16:21,600
and the right ones where we can have

00:16:20,240 --> 00:16:23,759
partial input

00:16:21,600 --> 00:16:25,279
so partial input is completed if we

00:16:23,759 --> 00:16:27,040
already pass complete information so

00:16:25,279 --> 00:16:28,079
fully qualified resources of course we

00:16:27,040 --> 00:16:29,519
get back fully

00:16:28,079 --> 00:16:31,920
fully qualified resources again not

00:16:29,519 --> 00:16:33,279
surprising what especially here if you

00:16:31,920 --> 00:16:34,639
have all three components and they're

00:16:33,279 --> 00:16:37,199
not empty there's no

00:16:34,639 --> 00:16:38,880
prefix matching so if you have just a

00:16:37,199 --> 00:16:40,240
but you pass a version as well you get

00:16:38,880 --> 00:16:42,160
an error

00:16:40,240 --> 00:16:43,279
this prefix matching only works if the

00:16:42,160 --> 00:16:44,639
version is submitted so

00:16:43,279 --> 00:16:47,279
yeah for the case reversion submitted

00:16:44,639 --> 00:16:48,480
but the group is complete obviously it's

00:16:47,279 --> 00:16:50,639
it looks through its formation of group

00:16:48,480 --> 00:16:52,639
versions and finds replica sets here in

00:16:50,639 --> 00:16:54,480
this case mb1 and v1 beta1 of

00:16:52,639 --> 00:16:55,839
the apps group if you just have the a is

00:16:54,480 --> 00:16:56,720
the prefix matching which which you

00:16:55,839 --> 00:16:58,480
already have seen

00:16:56,720 --> 00:17:01,279
happen so absolute one replica set is

00:16:58,480 --> 00:17:02,480
found and f v one beta one replica sets

00:17:01,279 --> 00:17:04,720
the raspberry also looks an

00:17:02,480 --> 00:17:07,120
authentication k or s i o

00:17:04,720 --> 00:17:08,559
and probably some other groups with a

00:17:07,120 --> 00:17:09,039
but there is no replica set so those are

00:17:08,559 --> 00:17:11,360
not

00:17:09,039 --> 00:17:13,039
returned by the last number the last one

00:17:11,360 --> 00:17:13,919
the group the group is missing it's

00:17:13,039 --> 00:17:15,919
filled in

00:17:13,919 --> 00:17:17,600
as expected and if group and version are

00:17:15,919 --> 00:17:18,000
missing that's the usual case on the

00:17:17,600 --> 00:17:21,199
command

00:17:18,000 --> 00:17:23,199
line then group and version are added

00:17:21,199 --> 00:17:24,720
the order of the results depends on the

00:17:23,199 --> 00:17:26,000
preferred group version order you saw

00:17:24,720 --> 00:17:27,120
that in the discovery information

00:17:26,000 --> 00:17:29,120
already

00:17:27,120 --> 00:17:31,360
and other than that resource names are

00:17:29,120 --> 00:17:33,440
ordered alphabetically

00:17:31,360 --> 00:17:35,039
all right so discovery and rest mappings

00:17:33,440 --> 00:17:36,160
are connected let's take a quick look on

00:17:35,039 --> 00:17:38,559
discovery information

00:17:36,160 --> 00:17:40,400
on the slash api's endpoint you get all

00:17:38,559 --> 00:17:41,600
api groups and save versions and the

00:17:40,400 --> 00:17:44,160
preferred versions

00:17:41,600 --> 00:17:45,760
on slash apis apps you get basically the

00:17:44,160 --> 00:17:48,240
same but just for the apps scoop

00:17:45,760 --> 00:17:49,679
in both cases you don't get resources so

00:17:48,240 --> 00:17:51,679
if you want to know about resources you

00:17:49,679 --> 00:17:52,720
have to go to one level deeper apis apps

00:17:51,679 --> 00:17:54,720
you want and then you get everything

00:17:52,720 --> 00:17:57,039
about oil resources

00:17:54,720 --> 00:17:58,000
in the case replica sets lowercase

00:17:57,039 --> 00:18:00,160
prover is the name

00:17:58,000 --> 00:18:01,679
of the resource singular name it's empty

00:18:00,160 --> 00:18:02,799
so the rest method will fill in the

00:18:01,679 --> 00:18:05,200
lowercase kind

00:18:02,799 --> 00:18:06,640
the scope of this is the namespace so we

00:18:05,200 --> 00:18:09,919
have to add the namespace to the ul

00:18:06,640 --> 00:18:12,160
the kind skeptica set uppercase as

00:18:09,919 --> 00:18:13,520
we expected the verbs are given so we

00:18:12,160 --> 00:18:14,799
know what we can do with the resource

00:18:13,520 --> 00:18:17,039
short names are returned for crew

00:18:14,799 --> 00:18:18,960
cutters or aliases on the command line

00:18:17,039 --> 00:18:20,720
and cut categories so you can list all

00:18:18,960 --> 00:18:21,760
resources and replica sets are among

00:18:20,720 --> 00:18:23,280
that

00:18:21,760 --> 00:18:25,120
all right so keep in mind to get

00:18:23,280 --> 00:18:27,840
resources you have to

00:18:25,120 --> 00:18:28,559
have the third column as well from

00:18:27,840 --> 00:18:30,480
discovery

00:18:28,559 --> 00:18:32,240
info so you can use the discovery client

00:18:30,480 --> 00:18:33,840
and you can grab it with a caching layer

00:18:32,240 --> 00:18:36,000
so there's a disk cache and a memcache

00:18:33,840 --> 00:18:37,200
discovery wrapper memcaches for

00:18:36,000 --> 00:18:39,200
controllers because they are one

00:18:37,200 --> 00:18:40,559
long running and this cache is used by

00:18:39,200 --> 00:18:42,160
cubecutter for example

00:18:40,559 --> 00:18:43,520
and if you have a cached discovery

00:18:42,160 --> 00:18:45,440
client you can pass that to the

00:18:43,520 --> 00:18:46,640
constructor for a discovery rest mapper

00:18:45,440 --> 00:18:48,559
and you get the last mapper as you

00:18:46,640 --> 00:18:48,880
expect implementing the interface we

00:18:48,559 --> 00:18:51,679
have

00:18:48,880 --> 00:18:53,440
just seen there's a reset method on the

00:18:51,679 --> 00:18:54,720
lastmapper so you can evaluate the cache

00:18:53,440 --> 00:18:57,039
manually if you like

00:18:54,720 --> 00:18:57,760
this also happens when you have a typo

00:18:57,039 --> 00:19:00,559
and

00:18:57,760 --> 00:19:00,799
a typo means the cache is the cache miss

00:19:00,559 --> 00:19:02,880
and

00:19:00,799 --> 00:19:04,320
the cache is invalidated this means you

00:19:02,880 --> 00:19:06,880
get those 30 plus

00:19:04,320 --> 00:19:08,320
discovery calls again and again so

00:19:06,880 --> 00:19:10,000
depending on your use case if you have a

00:19:08,320 --> 00:19:11,520
controller there's a risk of hot looping

00:19:10,000 --> 00:19:14,080
so keep this in mind

00:19:11,520 --> 00:19:15,679
this might be important so where it's

00:19:14,080 --> 00:19:17,520
used for resources here what i want to

00:19:15,679 --> 00:19:19,919
highlight is that the controller manager

00:19:17,520 --> 00:19:21,760
calls reset every 30 seconds and

00:19:19,919 --> 00:19:23,600
this is a way it gets to know about new

00:19:21,760 --> 00:19:25,600
resources so if you create a cid in

00:19:23,600 --> 00:19:26,960
the cluster it takes max 30 seconds

00:19:25,600 --> 00:19:30,640
until garbage collection

00:19:26,960 --> 00:19:32,799
knows about the new cid we talked about

00:19:30,640 --> 00:19:33,840
that we need this versioned discovery

00:19:32,799 --> 00:19:35,919
endpoint to get

00:19:33,840 --> 00:19:37,600
resources the consequence is if you have

00:19:35,919 --> 00:19:39,919
aggregated api servers in the system

00:19:37,600 --> 00:19:41,840
you need this red arrow here to to know

00:19:39,919 --> 00:19:43,600
about the aggregated resources

00:19:41,840 --> 00:19:45,039
if this breaks down for networking

00:19:43,600 --> 00:19:47,120
issues or because

00:19:45,039 --> 00:19:48,799
api server redeploys or something like

00:19:47,120 --> 00:19:50,720
that discovery clients

00:19:48,799 --> 00:19:53,039
and rest members won't see the resources

00:19:50,720 --> 00:19:54,960
in aggregated vi everyone

00:19:53,039 --> 00:19:56,880
this means that the discovery cloud will

00:19:54,960 --> 00:19:59,679
have an error with return error

00:19:56,880 --> 00:20:00,720
and the rest mapper will have incomplete

00:19:59,679 --> 00:20:02,080
information

00:20:00,720 --> 00:20:04,240
and this might have consequences so keep

00:20:02,080 --> 00:20:06,640
this in mind the discovery client

00:20:04,240 --> 00:20:08,240
is kind of graceful so it it returns

00:20:06,640 --> 00:20:09,520
errors directly but it also gives you

00:20:08,240 --> 00:20:11,200
the partial information

00:20:09,520 --> 00:20:12,559
it was able to gather from the cluster

00:20:11,200 --> 00:20:15,200
so always expect

00:20:12,559 --> 00:20:16,559
a nominal first result even though the

00:20:15,200 --> 00:20:18,320
error is also bundled

00:20:16,559 --> 00:20:20,559
and co-present whatever this means in

00:20:18,320 --> 00:20:22,159
your use case the discovery rest mapper

00:20:20,559 --> 00:20:23,360
is very graceful so it just continues

00:20:22,159 --> 00:20:25,280
with partial results

00:20:23,360 --> 00:20:26,400
and ignores errors but obviously

00:20:25,280 --> 00:20:27,679
incomplete information

00:20:26,400 --> 00:20:29,600
might have consequences for your use

00:20:27,679 --> 00:20:30,960
case so think about your controller and

00:20:29,600 --> 00:20:32,559
where you use the last mapper

00:20:30,960 --> 00:20:34,159
try to fail gracefully because you have

00:20:32,559 --> 00:20:37,039
to expect errors they happen

00:20:34,159 --> 00:20:38,640
and stay consistent in a way which

00:20:37,039 --> 00:20:40,559
matches your use case so we saw a

00:20:38,640 --> 00:20:42,559
namespace controller which blocks

00:20:40,559 --> 00:20:44,159
rather than doing uh stupid things it

00:20:42,559 --> 00:20:45,600
blocks the the work

00:20:44,159 --> 00:20:47,039
maybe this is much more important to

00:20:45,600 --> 00:20:48,640
stay consistent like that than

00:20:47,039 --> 00:20:50,080
continuing working gracefully

00:20:48,640 --> 00:20:51,440
garbage collection david we'll talk

00:20:50,080 --> 00:20:53,200
about it in a second that's also

00:20:51,440 --> 00:20:54,320
important to cutter you can just print a

00:20:53,200 --> 00:20:55,600
warning or something like that that's

00:20:54,320 --> 00:20:56,240
completely fine but depending on use

00:20:55,600 --> 00:20:57,679
cases

00:20:56,240 --> 00:21:00,159
behavior must be different and with that

00:20:57,679 --> 00:21:01,919
i pass over to david

00:21:00,159 --> 00:21:05,520
now let's move on to garbage collection

00:21:01,919 --> 00:21:05,520
of kubernetes api resources

00:21:06,000 --> 00:21:10,240
the first thing to consider is which

00:21:07,679 --> 00:21:12,159
binaries are involved and we have a cube

00:21:10,240 --> 00:21:13,760
api server which does basic crud on the

00:21:12,159 --> 00:21:15,679
resource and tracks

00:21:13,760 --> 00:21:17,280
state like is the resource present has

00:21:15,679 --> 00:21:18,559
it been removed or does it have a

00:21:17,280 --> 00:21:20,400
deletion time stamp

00:21:18,559 --> 00:21:22,720
set but finalizers that prevent it from

00:21:20,400 --> 00:21:24,720
being removed and then we have the

00:21:22,720 --> 00:21:25,919
cube controller manager which runs a

00:21:24,720 --> 00:21:28,240
garbage collector

00:21:25,919 --> 00:21:30,000
garbage collector controller and it

00:21:28,240 --> 00:21:31,120
looks for resources with absentee or

00:21:30,000 --> 00:21:33,679
missing owners

00:21:31,120 --> 00:21:35,280
and takes action on them and we'll get

00:21:33,679 --> 00:21:37,200
to the particular actions later on in

00:21:35,280 --> 00:21:39,120
some examples

00:21:37,200 --> 00:21:40,880
to describe the relationship between the

00:21:39,120 --> 00:21:43,039
resources we have

00:21:40,880 --> 00:21:44,320
owner references on children children

00:21:43,039 --> 00:21:45,919
list their parents

00:21:44,320 --> 00:21:47,840
as an owner ref you can have more than

00:21:45,919 --> 00:21:50,320
one and

00:21:47,840 --> 00:21:52,320
a namespace child can only refer to

00:21:50,320 --> 00:21:54,720
parents in the same name space

00:21:52,320 --> 00:21:56,240
or in cluster scope name spaces having

00:21:54,720 --> 00:21:58,799
the owner references on the child

00:21:56,240 --> 00:21:59,440
allows permissions to be listed on the

00:21:58,799 --> 00:22:01,280
child

00:21:59,440 --> 00:22:02,799
and not on the parent which makes it

00:22:01,280 --> 00:22:06,080
safer to

00:22:02,799 --> 00:22:09,120
express them via the api

00:22:06,080 --> 00:22:09,679
looking at an owner reference here's an

00:22:09,120 --> 00:22:12,159
example

00:22:09,679 --> 00:22:13,919
in a resource manifest that shows a

00:22:12,159 --> 00:22:16,559
single owner reference

00:22:13,919 --> 00:22:18,559
there is a section that refers to

00:22:16,559 --> 00:22:20,720
coordinates where to find the parent

00:22:18,559 --> 00:22:22,960
in this case we're looking for a config

00:22:20,720 --> 00:22:25,440
map named i3

00:22:22,960 --> 00:22:26,720
you'll notice there is no namespace so

00:22:25,440 --> 00:22:27,360
this means that it has to be in the same

00:22:26,720 --> 00:22:30,720
namespace

00:22:27,360 --> 00:22:31,520
or clusterscope we have a block model

00:22:30,720 --> 00:22:33,520
deletion field

00:22:31,520 --> 00:22:35,520
that only does something with foreground

00:22:33,520 --> 00:22:38,320
deletion of parents

00:22:35,520 --> 00:22:40,159
it has no effect in the default case

00:22:38,320 --> 00:22:41,919
there is a controller field

00:22:40,159 --> 00:22:43,600
which doesn't actually affect gc

00:22:41,919 --> 00:22:44,400
behavior at all it's used by higher

00:22:43,600 --> 00:22:47,520
order logic

00:22:44,400 --> 00:22:50,720
to control ownership uh

00:22:47,520 --> 00:22:51,440
of items and then there's a euid the uid

00:22:50,720 --> 00:22:54,080
refers

00:22:51,440 --> 00:22:55,200
to the uid of the parent and it's

00:22:54,080 --> 00:22:57,200
necessary to handle

00:22:55,200 --> 00:22:58,960
name reuse of parents if you rapidly

00:22:57,200 --> 00:23:01,600
delete and recreate parents

00:22:58,960 --> 00:23:02,559
we need to know if it's the same parent

00:23:01,600 --> 00:23:05,600
in which case

00:23:02,559 --> 00:23:08,000
you need to be preserved or in a

00:23:05,600 --> 00:23:09,919
delete and recreate case it's different

00:23:08,000 --> 00:23:10,480
and the owner ref is now invalid and the

00:23:09,919 --> 00:23:13,679
resource

00:23:10,480 --> 00:23:15,760
needs to be collected it does mean that

00:23:13,679 --> 00:23:16,880
you can't hard code them into manifests

00:23:15,760 --> 00:23:18,799
which

00:23:16,880 --> 00:23:20,080
is a pain point but we don't know of

00:23:18,799 --> 00:23:23,440
another way to solve

00:23:20,080 --> 00:23:25,919
the delete and recreate use case

00:23:23,440 --> 00:23:27,360
so the mechanics of actual deletion

00:23:25,919 --> 00:23:29,200
there is an option to delete

00:23:27,360 --> 00:23:30,880
in the background this is the default

00:23:29,200 --> 00:23:33,120
case it means

00:23:30,880 --> 00:23:34,799
that resources are removed immediately

00:23:33,120 --> 00:23:36,640
assuming you have no finalizers

00:23:34,799 --> 00:23:38,559
and the garbage collection controller

00:23:36,640 --> 00:23:40,159
finds child resources

00:23:38,559 --> 00:23:41,760
that have no additional owners in the

00:23:40,159 --> 00:23:43,200
background and deletes them

00:23:41,760 --> 00:23:46,480
this is what happens when you run queue

00:23:43,200 --> 00:23:48,559
control delete a particular config map

00:23:46,480 --> 00:23:50,400
so in this example we are going to

00:23:48,559 --> 00:23:52,559
delete i3

00:23:50,400 --> 00:23:54,320
the delete command sends a propagation

00:23:52,559 --> 00:23:55,279
policy of background to the cube api

00:23:54,320 --> 00:23:58,400
server

00:23:55,279 --> 00:23:59,760
and i3 is immediately removed from the

00:23:58,400 --> 00:24:01,120
api

00:23:59,760 --> 00:24:03,360
the garbage collection controller

00:24:01,120 --> 00:24:05,440
notices and then deletes

00:24:03,360 --> 00:24:07,440
k3 because it no longer has a valid

00:24:05,440 --> 00:24:08,720
owner reference

00:24:07,440 --> 00:24:10,799
then the garbage collection controller

00:24:08,720 --> 00:24:12,400
notices that o2 and o3

00:24:10,799 --> 00:24:15,440
have no owner references and they get

00:24:12,400 --> 00:24:18,320
deleted in any order

00:24:15,440 --> 00:24:18,640
another option for deletion is to orphan

00:24:18,320 --> 00:24:21,679
it

00:24:18,640 --> 00:24:23,919
you might use this means that resources

00:24:21,679 --> 00:24:25,760
are going to be deleted but instead of

00:24:23,919 --> 00:24:27,360
cascading through garbage collection and

00:24:25,760 --> 00:24:29,360
deleting the children

00:24:27,360 --> 00:24:30,480
it'll simply remove the owner references

00:24:29,360 --> 00:24:32,400
to the children this is something you

00:24:30,480 --> 00:24:34,320
might do if you want to

00:24:32,400 --> 00:24:35,679
replace a parent for some reason like

00:24:34,320 --> 00:24:36,159
maybe there's an immutable field and you

00:24:35,679 --> 00:24:39,840
need to

00:24:36,159 --> 00:24:41,200
change what that immutable field is you

00:24:39,840 --> 00:24:43,120
have to delete and recreate but you

00:24:41,200 --> 00:24:45,120
don't want to cascade through everything

00:24:43,120 --> 00:24:46,880
to do this you would use a cue control

00:24:45,120 --> 00:24:48,320
delete with a cascade equals false

00:24:46,880 --> 00:24:50,480
and it would send a propagation policy

00:24:48,320 --> 00:24:51,840
of orphan so if we work through the same

00:24:50,480 --> 00:24:53,840
example only this time we're going to

00:24:51,840 --> 00:24:57,200
delete i3 with an orphan

00:24:53,840 --> 00:24:58,799
policy then i3 is

00:24:57,200 --> 00:25:01,120
march relations deletion timestamp is

00:24:58,799 --> 00:25:01,679
set and an orphan finalizer is added to

00:25:01,120 --> 00:25:03,279
the list

00:25:01,679 --> 00:25:04,880
the garbage collection controller

00:25:03,279 --> 00:25:08,000
notices this

00:25:04,880 --> 00:25:10,080
finds the children and removes their

00:25:08,000 --> 00:25:13,039
owner references

00:25:10,080 --> 00:25:15,520
once the owner reference is removed then

00:25:13,039 --> 00:25:18,320
the orphan finalizer is removed and i3

00:25:15,520 --> 00:25:20,320
is deleted so you can see here we end up

00:25:18,320 --> 00:25:22,159
k3 and the other owner references are

00:25:20,320 --> 00:25:26,400
still intact and now we can recreate

00:25:22,159 --> 00:25:26,400
i3 and re-link it if we wish

00:25:26,480 --> 00:25:30,240
foreground the deletion of the

00:25:28,000 --> 00:25:31,600
foreground is

00:25:30,240 --> 00:25:34,159
one of the more complicated ones and

00:25:31,600 --> 00:25:37,279
this is what block owner deletion is for

00:25:34,159 --> 00:25:40,159
it allows for more control

00:25:37,279 --> 00:25:41,520
over the ordering in which resources are

00:25:40,159 --> 00:25:45,200
deleted

00:25:41,520 --> 00:25:45,200
this means that we're able to

00:25:45,440 --> 00:25:49,039
have parents wait for children to be

00:25:48,159 --> 00:25:51,360
removed

00:25:49,039 --> 00:25:53,760
before they themselves are removed it's

00:25:51,360 --> 00:25:55,520
important to note that this only works

00:25:53,760 --> 00:25:56,960
if the parent is deleted with foreground

00:25:55,520 --> 00:25:58,799
deletion if it isn't

00:25:56,960 --> 00:26:00,400
then your block or deletion doesn't

00:25:58,799 --> 00:26:03,919
actually do anything

00:26:00,400 --> 00:26:05,760
so it's more of a hint

00:26:03,919 --> 00:26:06,960
there's actually no command to trigger

00:26:05,760 --> 00:26:10,559
this so

00:26:06,960 --> 00:26:13,360
instead we have an example of using a

00:26:10,559 --> 00:26:14,880
delete dash dash raw to send a

00:26:13,360 --> 00:26:16,320
propagation policy of foreground to the

00:26:14,880 --> 00:26:17,600
cube api server

00:26:16,320 --> 00:26:20,240
so you can see here we have our same

00:26:17,600 --> 00:26:21,679
example we have owner references with

00:26:20,240 --> 00:26:23,440
block owner deletion

00:26:21,679 --> 00:26:25,440
set for a couple of the cases and we're

00:26:23,440 --> 00:26:27,440
going to walk this through

00:26:25,440 --> 00:26:28,640
the first thing that happens is that i3

00:26:27,440 --> 00:26:30,400
is marked for deletion

00:26:28,640 --> 00:26:31,760
and a foreground deletion is added to

00:26:30,400 --> 00:26:33,039
finalizer s

00:26:31,760 --> 00:26:36,080
the garbage collection controller

00:26:33,039 --> 00:26:40,320
notices this and goes to the next level

00:26:36,080 --> 00:26:43,679
and marks k3 the same way

00:26:40,320 --> 00:26:44,640
but k3 cannot be removed from the api

00:26:43,679 --> 00:26:46,240
yet

00:26:44,640 --> 00:26:48,159
because there's a block owner deletion

00:26:46,240 --> 00:26:51,760
from o2 instead

00:26:48,159 --> 00:26:52,720
we actually have to go and remove o2 and

00:26:51,760 --> 00:26:56,480
o3

00:26:52,720 --> 00:26:59,520
first once o2 is removed it becomes

00:26:56,480 --> 00:27:01,120
possible to delete k3 and once k3 is

00:26:59,520 --> 00:27:02,799
removed we can delete i3

00:27:01,120 --> 00:27:04,840
you can see here that the ordering is

00:27:02,799 --> 00:27:08,320
actually the reverse of the background

00:27:04,840 --> 00:27:11,200
deletion but remember it's

00:27:08,320 --> 00:27:12,720
optional if you deleted i3 with

00:27:11,200 --> 00:27:13,600
background deletion you wouldn't get

00:27:12,720 --> 00:27:15,600
this order

00:27:13,600 --> 00:27:18,480
so if you need to preserve your resource

00:27:15,600 --> 00:27:22,000
you're going to want to set a finalizer

00:27:18,480 --> 00:27:24,159
so bugs we do have bugs

00:27:22,000 --> 00:27:25,120
one of them is with block under deletion

00:27:24,159 --> 00:27:28,640
if you have two

00:27:25,120 --> 00:27:32,399
parents of a child

00:27:28,640 --> 00:27:34,799
then it doesn't behave right

00:27:32,399 --> 00:27:36,000
in fact i'll if you delete i3 in this

00:27:34,799 --> 00:27:36,720
case i'll just skip through the pieces

00:27:36,000 --> 00:27:38,799
we already know

00:27:36,720 --> 00:27:39,760
we're marked relation and now we're at

00:27:38,799 --> 00:27:42,799
the point where

00:27:39,760 --> 00:27:44,880
k3 should not be deleted until o2 has

00:27:42,799 --> 00:27:50,320
been removed

00:27:44,880 --> 00:27:51,840
o2 should not be removed early but

00:27:50,320 --> 00:27:54,080
the garbage collection controller

00:27:51,840 --> 00:27:57,520
removes the owner reference

00:27:54,080 --> 00:27:59,520
from o2 to k3 by doing this it becomes a

00:27:57,520 --> 00:28:00,880
valid target for lesion and k3 can be

00:27:59,520 --> 00:28:04,159
deleted

00:28:00,880 --> 00:28:07,679
this is a bug we end up

00:28:04,159 --> 00:28:09,520
deleting i3 k3 and o3

00:28:07,679 --> 00:28:11,039
because the owner reference from o2 no

00:28:09,520 --> 00:28:13,440
longer exists

00:28:11,039 --> 00:28:15,039
we don't currently have a pr to fix this

00:28:13,440 --> 00:28:18,240
bug

00:28:15,039 --> 00:28:20,240
it is less than ideal but i hit it again

00:28:18,240 --> 00:28:21,520
while creating this demo figured i'd

00:28:20,240 --> 00:28:23,840
mention it

00:28:21,520 --> 00:28:25,360
there's another case where clustered

00:28:23,840 --> 00:28:29,120
namespace references

00:28:25,360 --> 00:28:31,520
can cause deletion of

00:28:29,120 --> 00:28:32,559
of resources with valid owners so in

00:28:31,520 --> 00:28:34,880
this case

00:28:32,559 --> 00:28:36,880
uh we have a cluster scope resource n2

00:28:34,880 --> 00:28:38,880
which has which has taken

00:28:36,880 --> 00:28:40,559
an owner ref against the name space

00:28:38,880 --> 00:28:42,840
resource and you recall i said

00:28:40,559 --> 00:28:45,679
you should never do this it's not

00:28:42,840 --> 00:28:47,520
allowed the api doesn't prevent it

00:28:45,679 --> 00:28:49,120
and sometimes it appears to work because

00:28:47,520 --> 00:28:49,919
what will happen is i3 exists in the

00:28:49,120 --> 00:28:52,320
cache

00:28:49,919 --> 00:28:53,440
in the garbage collector and n2 does an

00:28:52,320 --> 00:28:56,640
existence check

00:28:53,440 --> 00:28:58,320
uh with a ui and it matches i3 so it

00:28:56,640 --> 00:29:01,200
appears to have a valid owner

00:28:58,320 --> 00:29:01,840
but on every restart the cube controller

00:29:01,200 --> 00:29:04,320
manager

00:29:01,840 --> 00:29:05,360
effectively has a race it races to see

00:29:04,320 --> 00:29:08,720
whether it observes

00:29:05,360 --> 00:29:10,880
i3 before it observes n2

00:29:08,720 --> 00:29:11,840
if you lose the race n2 is observed

00:29:10,880 --> 00:29:13,840
first

00:29:11,840 --> 00:29:15,600
there's an i3 existence check but there

00:29:13,840 --> 00:29:17,039
is no i3 at the cluster scope remember

00:29:15,600 --> 00:29:19,760
there's no namespace

00:29:17,039 --> 00:29:21,520
so the cluster scoped resource can't

00:29:19,760 --> 00:29:23,440
depend on a namespace scoped one

00:29:21,520 --> 00:29:25,279
that causes n2 to be deleted and that's

00:29:23,440 --> 00:29:26,480
probably okay because it has an invalid

00:29:25,279 --> 00:29:28,320
owner reference

00:29:26,480 --> 00:29:30,000
but k3 was deleted as well even though

00:29:28,320 --> 00:29:32,080
it was well formed because we saw the

00:29:30,000 --> 00:29:35,360
uid disappear

00:29:32,080 --> 00:29:37,360
this is a bug we have a pr to fix it

00:29:35,360 --> 00:29:41,120
that we'll be looking at doing in

00:29:37,360 --> 00:29:42,480
120. in a related problem

00:29:41,120 --> 00:29:44,880
the same thing can happen across

00:29:42,480 --> 00:29:48,559
namespace where

00:29:44,880 --> 00:29:50,240
if you race and i3 exists before you see

00:29:48,559 --> 00:29:53,440
k2

00:29:50,240 --> 00:29:54,080
then k2 won't be deleted but if the race

00:29:53,440 --> 00:29:55,919
goes the other way

00:29:54,080 --> 00:29:58,159
the existence check fails because

00:29:55,919 --> 00:30:02,159
there's no i3 in namespace one

00:29:58,159 --> 00:30:03,840
and so k2 and k3 are both deleted

00:30:02,159 --> 00:30:06,159
there's one more common case of seeing

00:30:03,840 --> 00:30:08,080
this and it's inside of a single

00:30:06,159 --> 00:30:10,720
namespace where the kind is set

00:30:08,080 --> 00:30:12,320
incorrectly when this happens you end up

00:30:10,720 --> 00:30:15,440
with a deletion

00:30:12,320 --> 00:30:17,760
and it causes

00:30:15,440 --> 00:30:19,440
k2 and k3 in the namespace to be deleted

00:30:17,760 --> 00:30:20,480
as i said we have a pr fixing this in

00:30:19,440 --> 00:30:24,480
00:30:20,480 --> 00:30:26,080
and it will prevent the good

00:30:24,480 --> 00:30:28,399
owner references from having their

00:30:26,080 --> 00:30:30,799
resources removed

00:30:28,399 --> 00:30:32,480
it was a whirlwind tour through garbage

00:30:30,799 --> 00:30:35,919
collection

00:30:32,480 --> 00:30:37,200
and if you want to ask more questions

00:30:35,919 --> 00:30:37,840
about it and you don't get them in the

00:30:37,200 --> 00:30:41,039
session

00:30:37,840 --> 00:30:42,399
you can find us in slack and then

00:30:41,039 --> 00:30:45,120
in the community meeting and mailing

00:30:42,399 --> 00:30:48,960
list i've got links here

00:30:45,120 --> 00:30:50,960
all right hello again

00:30:48,960 --> 00:30:52,320
i hope you enjoyed our did that topics

00:30:50,960 --> 00:30:54,960
from our presenters

00:30:52,320 --> 00:30:56,799
personally i really did before ending

00:30:54,960 --> 00:30:58,559
this session i wanted to remind you

00:30:56,799 --> 00:31:01,360
that we have regular sick meetings every

00:30:58,559 --> 00:31:03,200
two weeks and twice a week we do our bag

00:31:01,360 --> 00:31:04,080
and pull request three ashes for 30

00:31:03,200 --> 00:31:06,720
minutes

00:31:04,080 --> 00:31:07,840
it's a great way to get involved join

00:31:06,720 --> 00:31:10,399
our mailing list

00:31:07,840 --> 00:31:11,679
to get the invites we also have cube

00:31:10,399 --> 00:31:13,840
builder and api

00:31:11,679 --> 00:31:15,760
expression working groups as part of our

00:31:13,840 --> 00:31:18,960
c and they have their own

00:31:15,760 --> 00:31:19,200
respective meetings twice a month we are

00:31:18,960 --> 00:31:22,399
all

00:31:19,200 --> 00:31:24,399
always in our slack channels finally

00:31:22,399 --> 00:31:25,919
i will leave you this slide with contact

00:31:24,399 --> 00:31:28,320
and material information

00:31:25,919 --> 00:31:30,080
in case you want to know more or do more

00:31:28,320 --> 00:31:31,679
with us

00:31:30,080 --> 00:31:33,200
in the name of the entire siege thank

00:31:31,679 --> 00:31:35,200
you for attending our session

00:31:33,200 --> 00:31:38,960
and we wish you a good and enjoyable

00:31:35,200 --> 00:31:38,960

YouTube URL: https://www.youtube.com/watch?v=0VWNWJktcHk


