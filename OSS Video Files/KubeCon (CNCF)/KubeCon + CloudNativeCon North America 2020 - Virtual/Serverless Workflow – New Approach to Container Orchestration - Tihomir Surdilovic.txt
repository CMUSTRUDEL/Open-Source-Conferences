Title: Serverless Workflow – New Approach to Container Orchestration - Tihomir Surdilovic
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4–7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Serverless Workflow – New Approach to Container Orchestration - Tihomir Surdilovic & Ricardo Zanini Fernandes, Red Hat 

With the rise of Serverless Architectures, Workflows have gained a renewed interest and usefulness. Typically thought of as centralized and monolithic, they now play a key role in service and events orchestration and coordination. With many different architecture approaches already in place, the Cloud Native Computing Foundation has started an initiative to specify Serverless Workflows Specification to ensure portability and vendor neutrality. In this talk, we introduce the CNCF Serverless Workflow specification and provide examples and demos running on Kubernetes and Kogito, Red Hat’s business automation toolkit. You will learn: * The what, why, and how of the CNCF Serverless Workflow specification * Why using the Serverless Workflow specification and orchestration can improve your serverless architecture * Define and deploy Serverless Workflow custom resources on Kubernetes 

https://sched.co/ekEn
Captions: 
	00:00:01,760 --> 00:00:06,240
hi welcome everyone

00:00:03,439 --> 00:00:07,839
my name is stikhomir and i have ricardo

00:00:06,240 --> 00:00:11,759
here with me

00:00:07,839 --> 00:00:13,200
hello guys yeah in this talk we will

00:00:11,759 --> 00:00:15,200
present to you guys the serverless

00:00:13,200 --> 00:00:16,960
workflow project we will give a

00:00:15,200 --> 00:00:18,320
introduction to the project look at some

00:00:16,960 --> 00:00:20,240
of its use cases

00:00:18,320 --> 00:00:21,840
and then ricardo is going to present us

00:00:20,240 --> 00:00:23,119
his really cool demo on how serverless

00:00:21,840 --> 00:00:25,039
workflow fits

00:00:23,119 --> 00:00:26,160
within a container orchestration

00:00:25,039 --> 00:00:30,320
environment

00:00:26,160 --> 00:00:33,440
uh using kubernetes and k native

00:00:30,320 --> 00:00:35,120
thanks all right so serverless workflow

00:00:33,440 --> 00:00:37,120
is a cloud native foundation

00:00:35,120 --> 00:00:38,640
sandbox project it is part of its

00:00:37,120 --> 00:00:41,680
serverless working group

00:00:38,640 --> 00:00:43,440
it is open source and apache 2.0 license

00:00:41,680 --> 00:00:44,960
it is a community project and here you

00:00:43,440 --> 00:00:48,079
can find our information

00:00:44,960 --> 00:00:52,160
for our github repository website and

00:00:48,079 --> 00:00:52,160
community chat and meeting information

00:00:53,920 --> 00:00:58,000
all right serverless workflow defines a

00:00:55,920 --> 00:01:00,800
declarative and domain specific

00:00:58,000 --> 00:01:02,719
workflow language declarative is not

00:01:00,800 --> 00:01:04,879
expressed in low-level code

00:01:02,719 --> 00:01:06,720
however defines an abstraction language

00:01:04,879 --> 00:01:08,080
which can be defined in both json and

00:01:06,720 --> 00:01:11,040
yaml formats

00:01:08,080 --> 00:01:13,200
domain specific as it does target

00:01:11,040 --> 00:01:15,920
specifically the domain of orchestration

00:01:13,200 --> 00:01:17,680
of event-driven and distributed services

00:01:15,920 --> 00:01:19,520
and to give an example of that here on

00:01:17,680 --> 00:01:21,119
the left-hand side we have two simple

00:01:19,520 --> 00:01:23,280
requirements written in a natural

00:01:21,119 --> 00:01:24,080
language the first one being when a

00:01:23,280 --> 00:01:25,759
patient has

00:01:24,080 --> 00:01:27,439
for example a bladder infection we want

00:01:25,759 --> 00:01:30,000
to notify uh

00:01:27,439 --> 00:01:30,799
a urologist so a doctor dealing with

00:01:30,000 --> 00:01:33,280
that type of

00:01:30,799 --> 00:01:35,040
uh issue and the same thing with the

00:01:33,280 --> 00:01:35,759
second one when a patient has a regular

00:01:35,040 --> 00:01:38,240
heartbeat

00:01:35,759 --> 00:01:39,439
we want to notify cardiologists for that

00:01:38,240 --> 00:01:41,680
type of

00:01:39,439 --> 00:01:43,759
issue on the right hand side we see that

00:01:41,680 --> 00:01:46,960
serverless workflow does not

00:01:43,759 --> 00:01:49,040
uh express its language

00:01:46,960 --> 00:01:51,200
in code or if else statements and things

00:01:49,040 --> 00:01:54,000
like that neither does it express it

00:01:51,200 --> 00:01:56,799
using terminology that does not fit the

00:01:54,000 --> 00:01:58,399
specific to me domain targets

00:01:56,799 --> 00:02:00,159
on the bottom right hand side you can

00:01:58,399 --> 00:02:02,640
see that these type of

00:02:00,159 --> 00:02:04,799
requirements we can translate directly

00:02:02,640 --> 00:02:05,759
into events and services for so for

00:02:04,799 --> 00:02:08,000
example

00:02:05,759 --> 00:02:09,360
a patient having a bladder infection or

00:02:08,000 --> 00:02:11,440
irregular heartbeat

00:02:09,360 --> 00:02:13,440
we can look at it and translate it into

00:02:11,440 --> 00:02:14,640
events that could be produced by for

00:02:13,440 --> 00:02:17,120
example in this

00:02:14,640 --> 00:02:19,200
case some different hospital systems and

00:02:17,120 --> 00:02:21,360
notifying a doctor in this case

00:02:19,200 --> 00:02:23,120
the particular doctor who deals with the

00:02:21,360 --> 00:02:28,000
patient issue can be translated

00:02:23,120 --> 00:02:28,000
into location of distributed services

00:02:29,920 --> 00:02:32,959
all right serverless workflow is based

00:02:31,599 --> 00:02:35,120
on standards

00:02:32,959 --> 00:02:37,200
for event definition we use the cloud

00:02:35,120 --> 00:02:38,959
event specification to define events

00:02:37,200 --> 00:02:41,840
events that can be produced

00:02:38,959 --> 00:02:43,680
or consumed and also define correlations

00:02:41,840 --> 00:02:45,519
between many different events that could

00:02:43,680 --> 00:02:47,920
be happening in your systems

00:02:45,519 --> 00:02:48,840
we use the open api specification to

00:02:47,920 --> 00:02:51,920
define

00:02:48,840 --> 00:02:54,160
operations and services that need to be

00:02:51,920 --> 00:02:56,080
invoked during workflow execution

00:02:54,160 --> 00:02:57,280
the serverless workflow specification

00:02:56,080 --> 00:03:00,720
then defines

00:02:57,280 --> 00:03:03,920
different workflow patterns or control

00:03:00,720 --> 00:03:04,640
patterns which then define execution

00:03:03,920 --> 00:03:06,879
order

00:03:04,640 --> 00:03:08,640
error handling and data management and

00:03:06,879 --> 00:03:11,120
those are all based on widely known and

00:03:08,640 --> 00:03:13,360
used workflow patterns

00:03:11,120 --> 00:03:13,360
thanks

00:03:14,560 --> 00:03:17,599
the overall project goals of the

00:03:16,159 --> 00:03:20,239
serverless workflow project

00:03:17,599 --> 00:03:22,319
are to define our language which again

00:03:20,239 --> 00:03:23,200
can be expressed in both json and yaml

00:03:22,319 --> 00:03:25,760
format

00:03:23,200 --> 00:03:26,799
and to focus on portability and vendor

00:03:25,760 --> 00:03:29,040
neutrality

00:03:26,799 --> 00:03:30,560
so we want to be able to define a

00:03:29,040 --> 00:03:33,519
language which you can then

00:03:30,560 --> 00:03:34,319
execute on many different runtime

00:03:33,519 --> 00:03:36,159
services

00:03:34,319 --> 00:03:38,080
and those runtime services can be

00:03:36,159 --> 00:03:39,440
deployed in many different environments

00:03:38,080 --> 00:03:42,879
including container

00:03:39,440 --> 00:03:42,879
and cloud platforms

00:03:45,440 --> 00:03:50,000
so in order to start using events within

00:03:48,000 --> 00:03:51,040
your workflows you have to first start

00:03:50,000 --> 00:03:52,640
defining them

00:03:51,040 --> 00:03:54,480
like we said events can be either

00:03:52,640 --> 00:03:55,439
consumed or produced during workflow

00:03:54,480 --> 00:03:57,200
execution

00:03:55,439 --> 00:03:58,480
with serverless workflow you can see

00:03:57,200 --> 00:04:01,200
here that we have a direct

00:03:58,480 --> 00:04:02,879
one-to-one mapping between how events

00:04:01,200 --> 00:04:06,080
are actually expressed

00:04:02,879 --> 00:04:06,799
within the cloud events specification

00:04:06,080 --> 00:04:08,720
format

00:04:06,799 --> 00:04:10,400
and how you're actually defining it

00:04:08,720 --> 00:04:13,120
within your workflows

00:04:10,400 --> 00:04:14,319
so here you also can see that for event

00:04:13,120 --> 00:04:16,400
correlation

00:04:14,319 --> 00:04:17,359
we also use the cloud events format

00:04:16,400 --> 00:04:20,880
specifically

00:04:17,359 --> 00:04:20,880
it's context attributes

00:04:23,520 --> 00:04:27,520
all right so how can you now now that

00:04:25,680 --> 00:04:28,080
you define your events how can you now

00:04:27,520 --> 00:04:30,000
interact

00:04:28,080 --> 00:04:32,320
with them so as we said events can

00:04:30,000 --> 00:04:34,479
either start workflow execution they can

00:04:32,320 --> 00:04:36,639
continue workflow execution at some

00:04:34,479 --> 00:04:38,000
way points they can be either consumed

00:04:36,639 --> 00:04:39,919
or produced

00:04:38,000 --> 00:04:41,600
and they can be used also to make

00:04:39,919 --> 00:04:43,280
logical decisions

00:04:41,600 --> 00:04:45,360
on the right hand side we see a very

00:04:43,280 --> 00:04:46,720
simple end definition of the serverless

00:04:45,360 --> 00:04:48,560
workflow language which

00:04:46,720 --> 00:04:50,639
says okay at this point we're going to

00:04:48,560 --> 00:04:52,800
end the workflow execution

00:04:50,639 --> 00:04:55,199
but before we end it we're actually

00:04:52,800 --> 00:04:57,840
going to produce an event of type

00:04:55,199 --> 00:04:59,600
workflow completed event now this event

00:04:57,840 --> 00:05:01,440
then can be consumed by other different

00:04:59,600 --> 00:05:02,560
services in your systems for example

00:05:01,440 --> 00:05:04,240
other workflows

00:05:02,560 --> 00:05:07,759
or pretty much anything else that is

00:05:04,240 --> 00:05:07,759
listening to this type of event

00:05:08,840 --> 00:05:14,880
thanks

00:05:11,600 --> 00:05:16,960
similar to events we have want to define

00:05:14,880 --> 00:05:18,479
services and the operation on this

00:05:16,960 --> 00:05:19,680
distributed service that we want to

00:05:18,479 --> 00:05:22,560
invoke during

00:05:19,680 --> 00:05:23,280
uh workflow execution and as we said for

00:05:22,560 --> 00:05:24,960
this

00:05:23,280 --> 00:05:28,320
serverless workforce project user

00:05:24,960 --> 00:05:30,320
utilizes this open api specification

00:05:28,320 --> 00:05:31,680
on the left hand side here in the box we

00:05:30,320 --> 00:05:34,160
see a simple

00:05:31,680 --> 00:05:35,120
open api definition in this case written

00:05:34,160 --> 00:05:38,080
in yaml

00:05:35,120 --> 00:05:38,800
and it shows one particular operation of

00:05:38,080 --> 00:05:41,120
this

00:05:38,800 --> 00:05:42,560
service that we want to invoke during

00:05:41,120 --> 00:05:44,639
workflow execution

00:05:42,560 --> 00:05:46,160
on the right hand side we see that there

00:05:44,639 --> 00:05:48,160
is again a one-to-one

00:05:46,160 --> 00:05:50,080
mapping so in order to define this

00:05:48,160 --> 00:05:52,000
particular

00:05:50,080 --> 00:05:54,320
operation and the service that you want

00:05:52,000 --> 00:05:56,000
to invoke during workflow execution

00:05:54,320 --> 00:05:57,759
you basically have an operation

00:05:56,000 --> 00:05:59,440
parameter which is a combination of the

00:05:57,759 --> 00:06:01,919
path or the uri

00:05:59,440 --> 00:06:03,120
to the open ipi definition of the

00:06:01,919 --> 00:06:06,000
service

00:06:03,120 --> 00:06:06,400
and the unique operation id which gives

00:06:06,000 --> 00:06:08,319
you

00:06:06,400 --> 00:06:10,160
unique one-to-one mapping so your

00:06:08,319 --> 00:06:12,880
runtime should exactly know

00:06:10,160 --> 00:06:13,680
what operation needs to be executed on

00:06:12,880 --> 00:06:20,800
the service

00:06:13,680 --> 00:06:22,720
whenever the workflow requests for it

00:06:20,800 --> 00:06:24,479
now that we have defined the services we

00:06:22,720 --> 00:06:26,720
want to be able to evoke it and we

00:06:24,479 --> 00:06:28,960
understand that there is many different

00:06:26,720 --> 00:06:31,120
types of services that you might want to

00:06:28,960 --> 00:06:32,880
invoke during workflow execution

00:06:31,120 --> 00:06:34,720
with serverless workflow you have the

00:06:32,880 --> 00:06:37,919
ability to define

00:06:34,720 --> 00:06:39,600
and invoke restful services

00:06:37,919 --> 00:06:41,039
that we see on the left-hand side an

00:06:39,600 --> 00:06:43,600
example but

00:06:41,039 --> 00:06:45,520
also your have the ability to define

00:06:43,600 --> 00:06:48,160
invocation of services they're

00:06:45,520 --> 00:06:49,360
not restful they're not probably exposed

00:06:48,160 --> 00:06:52,000
at some end points

00:06:49,360 --> 00:06:55,280
but how however are triggered by events

00:06:52,000 --> 00:06:55,280
so that is also possible

00:06:57,680 --> 00:07:02,479
the last part of defining the the

00:07:00,639 --> 00:07:04,080
workflow is actually the control flow

00:07:02,479 --> 00:07:07,120
logic here we want to define

00:07:04,080 --> 00:07:08,000
states and the order in which they're

00:07:07,120 --> 00:07:10,720
executed

00:07:08,000 --> 00:07:12,800
with serverless workflows uh states are

00:07:10,720 --> 00:07:15,360
kind of like a black box that does

00:07:12,800 --> 00:07:16,160
some particular control flow uh logic

00:07:15,360 --> 00:07:19,280
type

00:07:16,160 --> 00:07:22,240
states can receive either data inputs

00:07:19,280 --> 00:07:24,240
or can they inc receive events they

00:07:22,240 --> 00:07:26,400
perform their particular

00:07:24,240 --> 00:07:27,440
type of control for logic that they're

00:07:26,400 --> 00:07:30,400
supposed to do

00:07:27,440 --> 00:07:31,520
and then they produce data output or can

00:07:30,400 --> 00:07:34,960
produce events

00:07:31,520 --> 00:07:38,639
that can be consumed by other states

00:07:34,960 --> 00:07:38,639
within the control flow logic

00:07:40,560 --> 00:07:47,120
cyrillus workflow specifies

00:07:44,080 --> 00:07:47,440
explicit control flow logic which means

00:07:47,120 --> 00:07:50,400
that

00:07:47,440 --> 00:07:52,080
we want to clearly allow you to define

00:07:50,400 --> 00:07:54,240
what you want to build

00:07:52,080 --> 00:07:55,599
a lot of times control for logic can be

00:07:54,240 --> 00:07:58,639
very granule

00:07:55,599 --> 00:08:01,520
granular in which means that it becomes

00:07:58,639 --> 00:08:02,720
at some point ambiguous ambiguous and

00:08:01,520 --> 00:08:05,759
what we wanted to do

00:08:02,720 --> 00:08:06,800
is kind of try to eliminate that uh it

00:08:05,759 --> 00:08:09,199
is often very

00:08:06,800 --> 00:08:10,080
hard to see during control flow even

00:08:09,199 --> 00:08:12,160
visually

00:08:10,080 --> 00:08:13,440
what parts kind of fit together and

00:08:12,160 --> 00:08:16,639
which parts

00:08:13,440 --> 00:08:17,840
in combination uh define a control flow

00:08:16,639 --> 00:08:20,639
logic block

00:08:17,840 --> 00:08:22,160
that makes sense um on a domain specific

00:08:20,639 --> 00:08:25,120
or a logical level

00:08:22,160 --> 00:08:26,080
uh on the bottom we see that each state

00:08:25,120 --> 00:08:28,720
within serverless

00:08:26,080 --> 00:08:29,520
workflow has a specific type and this

00:08:28,720 --> 00:08:31,840
types are

00:08:29,520 --> 00:08:33,440
somewhat clear for example we have an

00:08:31,840 --> 00:08:35,680
event type or

00:08:33,440 --> 00:08:36,800
which basically okay at this point we're

00:08:35,680 --> 00:08:38,800
doing dealing with

00:08:36,800 --> 00:08:40,880
a control for logic that has to do with

00:08:38,800 --> 00:08:41,839
events the same thing for example a

00:08:40,880 --> 00:08:44,080
switch type

00:08:41,839 --> 00:08:46,880
it is clear that this particular state

00:08:44,080 --> 00:08:49,279
is going to deal with logical decisions

00:08:46,880 --> 00:08:51,200
uh based on either data input or the

00:08:49,279 --> 00:08:53,200
event payloads

00:08:51,200 --> 00:08:54,320
so that is what we mean by explicit

00:08:53,200 --> 00:08:56,000
control logic

00:08:54,320 --> 00:08:58,000
i'm not saying that one is better than

00:08:56,000 --> 00:08:59,600
the other however this is how we

00:08:58,000 --> 00:09:03,200
the approach that we have taken within

00:08:59,600 --> 00:09:05,440
the serverless work language

00:09:03,200 --> 00:09:05,440
next

00:09:07,120 --> 00:09:11,680
um you can express many different types

00:09:10,080 --> 00:09:13,279
of control flow patterns with

00:09:11,680 --> 00:09:15,760
serverless workflow you can define

00:09:13,279 --> 00:09:18,800
either sequences of execution

00:09:15,760 --> 00:09:19,920
uh you can do database looping parallel

00:09:18,800 --> 00:09:21,600
execution

00:09:19,920 --> 00:09:24,240
you can make decisions like we said

00:09:21,600 --> 00:09:26,560
based on either data or some sort events

00:09:24,240 --> 00:09:28,399
um you you can deal with error handling

00:09:26,560 --> 00:09:30,800
for example issue retries

00:09:28,399 --> 00:09:32,320
or define how errors are handled during

00:09:30,800 --> 00:09:34,640
your workflow execution

00:09:32,320 --> 00:09:36,000
in addition to that uh serverless work

00:09:34,640 --> 00:09:38,720
also allows you to deal

00:09:36,000 --> 00:09:40,800
with control flow that has to do with

00:09:38,720 --> 00:09:42,000
human interactions which is sometimes

00:09:40,800 --> 00:09:44,399
very important

00:09:42,000 --> 00:09:45,920
during execution of your workflows and

00:09:44,399 --> 00:09:48,839
there are some other things and they're

00:09:45,920 --> 00:09:50,160
all specified within our specification

00:09:48,839 --> 00:09:53,279
documents

00:09:50,160 --> 00:09:56,160
next now let's take a look at

00:09:53,279 --> 00:09:58,000
the overall project components or what

00:09:56,160 --> 00:09:59,120
is all included within the serverless

00:09:58,000 --> 00:10:01,920
workflow project

00:09:59,120 --> 00:10:03,519
so far we have been talking about the

00:10:01,920 --> 00:10:04,079
serverless workflow language which is

00:10:03,519 --> 00:10:06,240
described

00:10:04,079 --> 00:10:08,399
as a json schema and this json schema

00:10:06,240 --> 00:10:10,959
really defines all the rules

00:10:08,399 --> 00:10:12,959
and and the patterns that you can use

00:10:10,959 --> 00:10:15,040
when defining your language

00:10:12,959 --> 00:10:17,600
in addition to that the project also

00:10:15,040 --> 00:10:19,600
defines a set of language extensions

00:10:17,600 --> 00:10:22,000
and these extensions do not control

00:10:19,600 --> 00:10:24,160
execution or the control for logic or

00:10:22,000 --> 00:10:27,120
how what happens when the workflow is

00:10:24,160 --> 00:10:30,480
executed but provides more information

00:10:27,120 --> 00:10:31,920
uh about the the workflow that you write

00:10:30,480 --> 00:10:34,079
that can be consumed by different

00:10:31,920 --> 00:10:37,200
runtime systems in order to

00:10:34,079 --> 00:10:39,200
overall improve the performance of your

00:10:37,200 --> 00:10:41,120
workflows in terms of you'll see cost

00:10:39,200 --> 00:10:43,279
and things like that

00:10:41,120 --> 00:10:44,320
some of the language extensions that we

00:10:43,279 --> 00:10:46,640
provide are

00:10:44,320 --> 00:10:48,160
kpi or key performance indicators

00:10:46,640 --> 00:10:50,720
extensions for tracing

00:10:48,160 --> 00:10:51,760
simulations and and we're adding more as

00:10:50,720 --> 00:10:54,480
we go

00:10:51,760 --> 00:10:55,200
another part of the serverless workflow

00:10:54,480 --> 00:10:57,279
project

00:10:55,200 --> 00:10:59,279
is things like uh software development

00:10:57,279 --> 00:11:01,680
kits we have them currently in both

00:10:59,279 --> 00:11:02,640
for both the java and the go languages

00:11:01,680 --> 00:11:05,800
um

00:11:02,640 --> 00:11:07,680
testing com tck or this is a

00:11:05,800 --> 00:11:10,079
compatibility kit for runtime

00:11:07,680 --> 00:11:11,519
implementations where they can compare

00:11:10,079 --> 00:11:14,079
uh their implementation

00:11:11,519 --> 00:11:15,760
to to the requirements of the serverless

00:11:14,079 --> 00:11:19,360
workflow specification

00:11:15,760 --> 00:11:22,720
in addition we provide a set of plugins

00:11:19,360 --> 00:11:22,720
for widely used ides

00:11:25,839 --> 00:11:30,000
so let's take a look at some of these uh

00:11:28,640 --> 00:11:31,440
or one of this uh

00:11:30,000 --> 00:11:32,959
language extension the serverless

00:11:31,440 --> 00:11:34,959
workflow provides in this case let's

00:11:32,959 --> 00:11:37,040
take a look at the kpi

00:11:34,959 --> 00:11:38,959
extension and this particular language

00:11:37,040 --> 00:11:42,000
extension allows you to basically

00:11:38,959 --> 00:11:45,440
compare expected versus actual

00:11:42,000 --> 00:11:46,160
data of your uh runtimes or information

00:11:45,440 --> 00:11:48,480
produced

00:11:46,160 --> 00:11:49,760
uh during the runtime of your workflows

00:11:48,480 --> 00:11:51,839
and it helps you really

00:11:49,760 --> 00:11:53,360
try to improve your workflows in terms

00:11:51,839 --> 00:11:55,839
of performance

00:11:53,360 --> 00:11:57,600
cost and its effectiveness and on the

00:11:55,839 --> 00:11:58,720
right hand side you can see a small

00:11:57,600 --> 00:12:01,120
example

00:11:58,720 --> 00:12:02,079
uh of the definition of this kpi

00:12:01,120 --> 00:12:04,480
extension again

00:12:02,079 --> 00:12:06,320
all the extensions just like uh the

00:12:04,480 --> 00:12:08,480
actual servos workflow language can be

00:12:06,320 --> 00:12:10,240
expressed both in json or yaml so you

00:12:08,480 --> 00:12:12,480
have the choice to do that but here

00:12:10,240 --> 00:12:15,600
basically allows you to to define

00:12:12,480 --> 00:12:16,160
some expected metrics they have to deal

00:12:15,600 --> 00:12:19,279
with

00:12:16,160 --> 00:12:21,360
um what do you expect to

00:12:19,279 --> 00:12:24,320
happen how many times you think that

00:12:21,360 --> 00:12:26,639
some services should be invoked uh what

00:12:24,320 --> 00:12:30,000
is the overall cost that you expect

00:12:26,639 --> 00:12:31,760
um from from running your workflows

00:12:30,000 --> 00:12:34,079
during a certain period of time

00:12:31,760 --> 00:12:35,920
and then you can compare them uh with

00:12:34,079 --> 00:12:39,839
the actual results and see if

00:12:35,920 --> 00:12:39,839
uh those metrics are met or not

00:12:41,839 --> 00:12:45,600
the next thing we want to take a look at

00:12:43,600 --> 00:12:48,880
is the java sdk and this

00:12:45,600 --> 00:12:51,279
particular sdk provides features like

00:12:48,880 --> 00:12:53,200
parsing of json or yaml did a runtime

00:12:51,279 --> 00:12:54,480
implementations can easily use and don't

00:12:53,200 --> 00:12:56,639
have to deal with that

00:12:54,480 --> 00:12:57,600
it provides a fluent api so it allows

00:12:56,639 --> 00:13:00,000
you to define

00:12:57,600 --> 00:13:02,240
your workflow definitions just using

00:13:00,000 --> 00:13:05,519
programming language rather than dealing

00:13:02,240 --> 00:13:06,079
with with the json or yaml uh it

00:13:05,519 --> 00:13:08,800
provides

00:13:06,079 --> 00:13:11,519
validation so validation against uh the

00:13:08,800 --> 00:13:14,000
serverless workflow specification itself

00:13:11,519 --> 00:13:15,760
and it also provides diagram generation

00:13:14,000 --> 00:13:19,040
so as you're defining and

00:13:15,760 --> 00:13:21,040
and and your um workflow models

00:13:19,040 --> 00:13:23,519
you can go either from the json ammo

00:13:21,040 --> 00:13:26,000
that is parsed or the

00:13:23,519 --> 00:13:27,920
workflow models defined using the

00:13:26,000 --> 00:13:34,240
language itself into

00:13:27,920 --> 00:13:36,320
diagrams that you can then visualize

00:13:34,240 --> 00:13:37,279
um one more thing we're going to take a

00:13:36,320 --> 00:13:40,480
look at here

00:13:37,279 --> 00:13:42,079
is the um serverless workflow visual

00:13:40,480 --> 00:13:45,040
studio code plugin

00:13:42,079 --> 00:13:47,199
and this is a plugin that's available on

00:13:45,040 --> 00:13:48,000
the visual studio code marketplace you

00:13:47,199 --> 00:13:50,959
can download it

00:13:48,000 --> 00:13:53,279
now and start using it and its feature

00:13:50,959 --> 00:13:54,240
sorry provides code hints and code

00:13:53,279 --> 00:13:56,959
snippets

00:13:54,240 --> 00:13:57,839
for both json and yaml files again

00:13:56,959 --> 00:14:00,560
against the

00:13:57,839 --> 00:14:02,480
serverless workflow json schema it

00:14:00,560 --> 00:14:04,959
provides validation

00:14:02,480 --> 00:14:07,040
and at the same time it also provides

00:14:04,959 --> 00:14:09,519
diagram generation so as you're

00:14:07,040 --> 00:14:12,240
modeling your workflows uh in visual

00:14:09,519 --> 00:14:14,399
studio code you can easily preview

00:14:12,240 --> 00:14:15,680
uh the diagram of your particular

00:14:14,399 --> 00:14:18,959
workflow and make sure they

00:14:15,680 --> 00:14:18,959
visually also make sense

00:14:20,480 --> 00:14:25,600
uh all right so that's it for me uh so

00:14:23,360 --> 00:14:27,040
now we go to the cool part now ricardo

00:14:25,600 --> 00:14:27,839
is going to take over and do his cool

00:14:27,040 --> 00:14:30,560
demo

00:14:27,839 --> 00:14:32,560
yeah let's let's let's see uh what we

00:14:30,560 --> 00:14:35,760
have prepared for you guys today

00:14:32,560 --> 00:14:38,480
so uh first thing is just

00:14:35,760 --> 00:14:40,480
when we was was were thinking about the

00:14:38,480 --> 00:14:43,440
demo we started thinking of how

00:14:40,480 --> 00:14:44,079
are you supposed to fit uh a particular

00:14:43,440 --> 00:14:46,160
use case

00:14:44,079 --> 00:14:48,240
with the serverless workflow scenario

00:14:46,160 --> 00:14:51,040
and how that can help us so

00:14:48,240 --> 00:14:52,959
as developers uh we have this very uh

00:14:51,040 --> 00:14:56,560
particular use case that i

00:14:52,959 --> 00:14:58,399
uh i wish to open a pr against a project

00:14:56,560 --> 00:15:01,760
a github project and i wish to have

00:14:58,399 --> 00:15:03,920
my pr um being labeled exactly with

00:15:01,760 --> 00:15:06,240
what this is supposed to be labeled and

00:15:03,920 --> 00:15:07,279
i wish to have you know my pull request

00:15:06,240 --> 00:15:10,079
be reviewed

00:15:07,279 --> 00:15:11,120
by someone so would be nice to have like

00:15:10,079 --> 00:15:13,199
maybe a bot

00:15:11,120 --> 00:15:14,399
that could label my pull requests and

00:15:13,199 --> 00:15:17,360
maybe you know

00:15:14,399 --> 00:15:18,720
also add the correct reviewer uh from

00:15:17,360 --> 00:15:22,440
for michael request

00:15:18,720 --> 00:15:25,519
so having this in mind uh we draw

00:15:22,440 --> 00:15:29,040
a proposed workflow for that

00:15:25,519 --> 00:15:32,079
so um imagine that we could receive

00:15:29,040 --> 00:15:34,240
uh an event change like a

00:15:32,079 --> 00:15:35,600
pr has been open or changed so we

00:15:34,240 --> 00:15:39,279
received this event

00:15:35,600 --> 00:15:40,639
on our system and uh based on that event

00:15:39,279 --> 00:15:42,480
we can analyze

00:15:40,639 --> 00:15:43,759
the context of the pull request and

00:15:42,480 --> 00:15:46,639
understand what

00:15:43,759 --> 00:15:47,199
what have been changed so uh we can

00:15:46,639 --> 00:15:50,480
understand

00:15:47,199 --> 00:15:51,839
by based by the context by the files

00:15:50,480 --> 00:15:54,800
that have been changed and

00:15:51,839 --> 00:15:55,600
based on that we can call the github api

00:15:54,800 --> 00:15:58,480
to apply

00:15:55,600 --> 00:15:59,839
uh the correct labels and also to add

00:15:58,480 --> 00:16:03,120
the required reviewers

00:15:59,839 --> 00:16:05,519
and and the nd workflow we can uh create

00:16:03,120 --> 00:16:06,800
and publish a new event saying to the

00:16:05,519 --> 00:16:09,519
platform hey

00:16:06,800 --> 00:16:11,279
uh the pr has been verified and you can

00:16:09,519 --> 00:16:12,160
do whatever you want with this this

00:16:11,279 --> 00:16:15,440
event so

00:16:12,160 --> 00:16:17,839
having this uh workflow in mind

00:16:15,440 --> 00:16:18,800
we prepared uh implementation with some

00:16:17,839 --> 00:16:21,360
technology

00:16:18,800 --> 00:16:22,399
around kubernetes k native the surface

00:16:21,360 --> 00:16:23,759
workflow and some

00:16:22,399 --> 00:16:25,440
some runtimes implementation of the

00:16:23,759 --> 00:16:29,040
serverless reflow

00:16:25,440 --> 00:16:30,800
and the first thing is once we receive a

00:16:29,040 --> 00:16:32,639
pull request we'd like to you know to

00:16:30,800 --> 00:16:33,360
receive this event on a broker so in

00:16:32,639 --> 00:16:36,720
this case

00:16:33,360 --> 00:16:40,800
you know on a k native broker and then

00:16:36,720 --> 00:16:43,600
this broker will broadcast this event

00:16:40,800 --> 00:16:45,920
for anyone interested in in this case we

00:16:43,600 --> 00:16:48,000
have our serverless workflow runtime

00:16:45,920 --> 00:16:49,120
uh running in this platform and we'll

00:16:48,000 --> 00:16:51,040
listen to this event

00:16:49,120 --> 00:16:52,480
of this pull request event and we're

00:16:51,040 --> 00:16:54,639
going to do everything

00:16:52,480 --> 00:16:55,519
uh that we that we explained in the last

00:16:54,639 --> 00:16:57,440
slide like

00:16:55,519 --> 00:16:59,120
uh analyzing the pull requests what's

00:16:57,440 --> 00:16:59,839
going on with this pull request and one

00:16:59,120 --> 00:17:02,959
of the things

00:16:59,839 --> 00:17:05,039
is uh to query the github api for the

00:17:02,959 --> 00:17:08,400
files that have been changed in this vr

00:17:05,039 --> 00:17:10,400
and also uh apply the labels

00:17:08,400 --> 00:17:12,160
uh apply the reviewer so for that we

00:17:10,400 --> 00:17:15,600
need these github

00:17:12,160 --> 00:17:19,439
api functions also deployed on our

00:17:15,600 --> 00:17:22,319
platform on our kubernetes platform

00:17:19,439 --> 00:17:22,799
um that we are going to call like github

00:17:22,319 --> 00:17:24,959
api

00:17:22,799 --> 00:17:26,400
functions so uh we have all those k

00:17:24,959 --> 00:17:29,039
network server

00:17:26,400 --> 00:17:29,679
functions deployed in there that we can

00:17:29,039 --> 00:17:32,960
consume

00:17:29,679 --> 00:17:36,400
using our workflow engine and also is

00:17:32,960 --> 00:17:39,440
the the the workflow is finished we will

00:17:36,400 --> 00:17:42,960
uh publish a new

00:17:39,440 --> 00:17:45,039
uh a new uh event to the broker

00:17:42,960 --> 00:17:47,600
and the broker can also you know

00:17:45,039 --> 00:17:50,720
broadcast this event for any interested

00:17:47,600 --> 00:17:52,480
uh part of the this event and in this

00:17:50,720 --> 00:17:52,960
case the pull request verified event

00:17:52,480 --> 00:17:55,120
will be

00:17:52,960 --> 00:17:56,320
consumed by our notification service so

00:17:55,120 --> 00:17:57,520
this notification service can be

00:17:56,320 --> 00:18:00,720
anything you can

00:17:57,520 --> 00:18:03,200
uh not five yeah mail via slack telegram

00:18:00,720 --> 00:18:04,080
or whatever other you know channels that

00:18:03,200 --> 00:18:07,520
you have out there

00:18:04,080 --> 00:18:08,720
in your company so that's the

00:18:07,520 --> 00:18:10,559
the main architecture you know the

00:18:08,720 --> 00:18:12,320
implementation of what we have and then

00:18:10,559 --> 00:18:13,039
we basically have this broker

00:18:12,320 --> 00:18:15,679
implemented with

00:18:13,039 --> 00:18:16,559
native eventing system so uh kennedy

00:18:15,679 --> 00:18:19,360
painting will

00:18:16,559 --> 00:18:20,080
you know delegate the broadcast events

00:18:19,360 --> 00:18:22,559
around

00:18:20,080 --> 00:18:24,480
the kubernetes namespace we have this

00:18:22,559 --> 00:18:26,240
workflow runtime implemented with

00:18:24,480 --> 00:18:28,000
our own runtime implementation of the

00:18:26,240 --> 00:18:32,640
service workflow we have

00:18:28,000 --> 00:18:36,000
uh this notification service also uh

00:18:32,640 --> 00:18:38,720
aware of the of the server of the events

00:18:36,000 --> 00:18:39,280
that uh are published by our workflow

00:18:38,720 --> 00:18:41,200
runtime

00:18:39,280 --> 00:18:42,720
and we'll do you know the notification

00:18:41,200 --> 00:18:44,960
with that

00:18:42,720 --> 00:18:46,320
and uh what kind of technology that we

00:18:44,960 --> 00:18:48,160
use like that

00:18:46,320 --> 00:18:49,760
uh we have the serverless workflow

00:18:48,160 --> 00:18:51,280
implementation that we uh

00:18:49,760 --> 00:18:53,440
that we are working on that it's called

00:18:51,280 --> 00:18:56,160
coach the project

00:18:53,440 --> 00:18:58,000
we have k native to serve the platform

00:18:56,160 --> 00:19:00,640
to be the infrastructure for us

00:18:58,000 --> 00:19:01,200
for the serverless infrastructure um to

00:19:00,640 --> 00:19:03,200
handle

00:19:01,200 --> 00:19:05,200
uh cloud events for us in the in the

00:19:03,200 --> 00:19:08,240
kubernetes name space to handle

00:19:05,200 --> 00:19:10,480
our functions in there we also have

00:19:08,240 --> 00:19:12,160
some the java functions that you saw the

00:19:10,480 --> 00:19:14,559
github functions they are all

00:19:12,160 --> 00:19:15,919
implemented in java with quercus

00:19:14,559 --> 00:19:17,760
could be implemented in any language

00:19:15,919 --> 00:19:21,200
actually so you use java because

00:19:17,760 --> 00:19:22,960
we are users to that and

00:19:21,200 --> 00:19:25,039
we have came with the kremwell framework

00:19:22,960 --> 00:19:28,000
that is an integration framework

00:19:25,039 --> 00:19:28,000
for um

00:19:28,320 --> 00:19:34,000
communicate with this like api to make a

00:19:31,200 --> 00:19:35,039
a nice notification to a given like

00:19:34,000 --> 00:19:37,520
channel

00:19:35,039 --> 00:19:38,160
so um i'm going to change my screen now

00:19:37,520 --> 00:19:42,160
to the

00:19:38,160 --> 00:19:45,360
to the front part like uh j homie set

00:19:42,160 --> 00:19:48,240
so uh first of all we're going to just

00:19:45,360 --> 00:19:48,640
watch the pods on our namespace so for

00:19:48,240 --> 00:19:51,679
now

00:19:48,640 --> 00:19:54,640
you everything that we have here in this

00:19:51,679 --> 00:19:56,000
in the application space is the workflow

00:19:54,640 --> 00:19:58,160
engine running

00:19:56,000 --> 00:19:59,280
and uh our coached operator running

00:19:58,160 --> 00:20:03,200
there as well

00:19:59,280 --> 00:20:03,200
this operator will is

00:20:04,240 --> 00:20:07,520
deployed the service and is controlling

00:20:06,320 --> 00:20:10,240
the service and how

00:20:07,520 --> 00:20:10,640
uh things should be uh and the state of

00:20:10,240 --> 00:20:13,120
the

00:20:10,640 --> 00:20:15,440
the workflow should be so that's why uh

00:20:13,120 --> 00:20:18,559
there's a part of the operator in there

00:20:15,440 --> 00:20:21,039
and uh here in the bottom uh i'm in my

00:20:18,559 --> 00:20:23,440
project so i have this given

00:20:21,039 --> 00:20:26,720
you know cogito serverless workflow demo

00:20:23,440 --> 00:20:31,039
project in github so i'm going to

00:20:26,720 --> 00:20:35,039
uh start creating a new

00:20:31,039 --> 00:20:40,640
branch let's say cube call

00:20:35,039 --> 00:20:44,000
and let's create a superfast file here

00:20:40,640 --> 00:20:49,039
and put some information in here

00:20:44,000 --> 00:20:52,960
in here like hello world

00:20:49,039 --> 00:20:54,480
la mundo and whatever other things that

00:20:52,960 --> 00:20:58,400
you might have

00:20:54,480 --> 00:21:03,200
and uh you see that we have this file

00:20:58,400 --> 00:21:07,360
we're going to add and commit that

00:21:03,200 --> 00:21:07,360
like new test file

00:21:08,080 --> 00:21:10,880
hello demo

00:21:11,520 --> 00:21:14,400
commit message

00:21:15,280 --> 00:21:20,159
okay so i'm going to push that

00:21:20,559 --> 00:21:31,840
to my project

00:21:39,600 --> 00:21:45,120
okay i finished posting my service in

00:21:42,559 --> 00:21:45,919
there so um github is nice and he's

00:21:45,120 --> 00:21:48,559
saying oh hey

00:21:45,919 --> 00:21:49,280
you push a new uh branch here you like

00:21:48,559 --> 00:21:51,120
to open

00:21:49,280 --> 00:21:52,799
a pull request of course i want to let's

00:21:51,120 --> 00:21:56,080
open up a request

00:21:52,799 --> 00:22:00,400
so this is my new test file which um

00:21:56,080 --> 00:22:00,400
helpful demo and let's say cubecom

00:22:00,960 --> 00:22:06,559
hello demo hey

00:22:04,240 --> 00:22:07,280
onsen open a pull request uh you know a

00:22:06,559 --> 00:22:10,320
new event

00:22:07,280 --> 00:22:11,919
will come um to my to my kubernetes

00:22:10,320 --> 00:22:12,559
namespace and can canada will handle

00:22:11,919 --> 00:22:15,039
that

00:22:12,559 --> 00:22:16,320
and we'll start uh you know the

00:22:15,039 --> 00:22:18,159
operation of

00:22:16,320 --> 00:22:20,400
the overall operation inside the

00:22:18,159 --> 00:22:22,880
namespace so um

00:22:20,400 --> 00:22:23,919
the broker the broker will take this

00:22:22,880 --> 00:22:26,960
event

00:22:23,919 --> 00:22:30,320
and we broadcast to our cogito workflow

00:22:26,960 --> 00:22:34,400
to our runtime workflow engine

00:22:30,320 --> 00:22:34,400
so let's see how it goes

00:22:34,960 --> 00:22:40,159
after opening uh the request you can see

00:22:37,520 --> 00:22:40,880
that in the in the top of my screen that

00:22:40,159 --> 00:22:42,720
uh we are

00:22:40,880 --> 00:22:44,640
receiving the event so we have this

00:22:42,720 --> 00:22:47,600
github event listener that is a

00:22:44,640 --> 00:22:48,640
gain native source uh kind of uh

00:22:47,600 --> 00:22:51,919
component

00:22:48,640 --> 00:22:54,240
you also see the github service that has

00:22:51,919 --> 00:22:56,000
all the functions that we that are

00:22:54,240 --> 00:22:56,480
required to you know to interact with

00:22:56,000 --> 00:23:00,080
the

00:22:56,480 --> 00:23:03,760
the github uh api

00:23:00,080 --> 00:23:04,880
and uh onstagepod is uh scaling to one

00:23:03,760 --> 00:23:07,200
because now we

00:23:04,880 --> 00:23:08,080
we are using uh asteroids platform so

00:23:07,200 --> 00:23:11,600
you're supposed to

00:23:08,080 --> 00:23:14,960
to do other this kind of stuff you see

00:23:11,600 --> 00:23:17,760
that the the pull request just

00:23:14,960 --> 00:23:18,240
added the you know the the workflow

00:23:17,760 --> 00:23:20,640
added

00:23:18,240 --> 00:23:23,039
to the correct label and then did the

00:23:20,640 --> 00:23:26,960
correct guy here

00:23:23,039 --> 00:23:29,919
to reveal our pr and

00:23:26,960 --> 00:23:32,480
as well the notification service was no

00:23:29,919 --> 00:23:35,520
waking up

00:23:32,480 --> 00:23:37,120
to receive a notification in here so

00:23:35,520 --> 00:23:39,120
you'll see that we received some

00:23:37,120 --> 00:23:39,520
notifications about the changes that we

00:23:39,120 --> 00:23:42,880
made

00:23:39,520 --> 00:23:44,720
in in the pr so uh that's it for the

00:23:42,880 --> 00:23:48,559
demo

00:23:44,720 --> 00:23:50,080
let's go back to your presentation

00:23:48,559 --> 00:23:52,000
do you have any other things to say

00:23:50,080 --> 00:23:53,520
coach humber no

00:23:52,000 --> 00:23:55,279
this was really cool thanks for doing

00:23:53,520 --> 00:23:58,640
this looks great

00:23:55,279 --> 00:23:58,640
okay let's continue then

00:24:01,840 --> 00:24:08,720
okay so i guess that's it right homer

00:24:05,520 --> 00:24:11,039
we finished our presentation yeah and uh

00:24:08,720 --> 00:24:12,400
i don't know you do do do do you know to

00:24:11,039 --> 00:24:13,360
share some more information about the

00:24:12,400 --> 00:24:16,720
service workflow

00:24:13,360 --> 00:24:17,440
uh project or no we're good i think here

00:24:16,720 --> 00:24:19,679
you can find

00:24:17,440 --> 00:24:22,159
uh more information definitely our

00:24:19,679 --> 00:24:25,520
website the server's workflow.io

00:24:22,159 --> 00:24:27,440
um again like ricardo and i uh

00:24:25,520 --> 00:24:29,039
we're community members of the project

00:24:27,440 --> 00:24:29,919
and and we would like to also invite

00:24:29,039 --> 00:24:32,559
everybody

00:24:29,919 --> 00:24:34,080
that's watching to join uh we have uh

00:24:32,559 --> 00:24:35,039
like we said community bi-weekly

00:24:34,080 --> 00:24:38,080
meetings

00:24:35,039 --> 00:24:39,120
uh there you can just join them and see

00:24:38,080 --> 00:24:40,880
how it goes

00:24:39,120 --> 00:24:42,320
um and here you can also find their

00:24:40,880 --> 00:24:44,240
github repository with

00:24:42,320 --> 00:24:46,159
specification project in there has all

00:24:44,240 --> 00:24:48,960
the details and the information

00:24:46,159 --> 00:24:50,720
and documentation including examples use

00:24:48,960 --> 00:24:52,720
cases and things like that

00:24:50,720 --> 00:24:54,960
that you can go ahead and check out and

00:24:52,720 --> 00:24:57,760
and and learn more about the project

00:24:54,960 --> 00:24:59,600
um yeah yeah and and everything about

00:24:57,760 --> 00:25:02,000
the demo you can see uh

00:24:59,600 --> 00:25:02,960
in this world here uh you you reach the

00:25:02,000 --> 00:25:06,080
you know of the

00:25:02,960 --> 00:25:09,039
serverless workflow uh

00:25:06,080 --> 00:25:09,840
files that we used uh in this demo the

00:25:09,039 --> 00:25:13,039
how you can

00:25:09,840 --> 00:25:15,760
uh create your own namespace on

00:25:13,039 --> 00:25:17,520
on kubernetes and use all the scripts in

00:25:15,760 --> 00:25:18,000
there in there the the applications the

00:25:17,520 --> 00:25:20,080
service

00:25:18,000 --> 00:25:21,039
everything is in in this uh in this

00:25:20,080 --> 00:25:23,760
address

00:25:21,039 --> 00:25:25,360
and uh you will be able to run this

00:25:23,760 --> 00:25:28,480
actual demo

00:25:25,360 --> 00:25:33,279
in your laptop as well

00:25:28,480 --> 00:25:33,279
i think that's it yeah all right thanks

00:25:33,480 --> 00:25:36,480

YouTube URL: https://www.youtube.com/watch?v=noVf6qzyP1U


