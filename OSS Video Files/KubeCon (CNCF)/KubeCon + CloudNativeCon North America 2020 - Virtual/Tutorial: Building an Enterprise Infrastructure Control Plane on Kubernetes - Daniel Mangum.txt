Title: Tutorial: Building an Enterprise Infrastructure Control Plane on Kubernetes - Daniel Mangum
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4â€“7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Tutorial: Building an Enterprise Infrastructure Control Plane on Kubernetes - Daniel Mangum, Upbound & Steven Borrelli, Mastercard 

Enterprise infrastructure is diverse, complex, and difficult to automate. What if you could standardize on a single infrastructure control plane using the Kubernetes API? In this tutorial we will cover how to build Kubernetes controllers to manage infrastructure across enterprise infrastructure providers using the crossplane-runtime library, taking examples from the work that Mastercard has done to build a cohesive service catalog based on Kubernetes CRDs. Attendees will walk away with a functioning controller and building blocks for developing their own enterprise control plane. Topics covered will include: - Modeling Resources like Virtual Machines and Databases as Kubernetes CRDs - Sharing reconciler logic across controllers - Translating imperative API calls into declaratively managed Kubernetes objects Attendees should have Git, Go, and Docker installed prior to this session. 

https://sched.co/ekFT
Captions: 
	00:00:00,640 --> 00:00:06,319
well welcome to our session today i am

00:00:02,639 --> 00:00:09,200
uh stephen barely from mastercard

00:00:06,319 --> 00:00:10,240
and i'm daniel mangum from upbound yeah

00:00:09,200 --> 00:00:11,360
and today we're going to be talking

00:00:10,240 --> 00:00:12,639
about um

00:00:11,360 --> 00:00:13,840
a project that i think is really cool

00:00:12,639 --> 00:00:15,679
we're going to be talking about building

00:00:13,840 --> 00:00:17,039
your own enterprise control plane

00:00:15,679 --> 00:00:18,240
and basing that on kubernetes and we

00:00:17,039 --> 00:00:20,720
hope to show you that this is actually

00:00:18,240 --> 00:00:22,720
really powerful and really easy to do

00:00:20,720 --> 00:00:25,039
so really that's kind of our goals for

00:00:22,720 --> 00:00:26,320
this talk first we want to talk about

00:00:25,039 --> 00:00:27,840
this is really one of the fundamental

00:00:26,320 --> 00:00:29,359
concepts of kubernetes but we really

00:00:27,840 --> 00:00:30,800
want to talk about why controllers

00:00:29,359 --> 00:00:32,480
are really one of the best ways to

00:00:30,800 --> 00:00:34,960
manage your internal infrastructure

00:00:32,480 --> 00:00:36,079
and we want to kind of show just how

00:00:34,960 --> 00:00:37,520
easy it is given

00:00:36,079 --> 00:00:39,920
a lot of the tooling libraries around

00:00:37,520 --> 00:00:42,079
kubernetes right now

00:00:39,920 --> 00:00:44,320
so just really quick what our agenda is

00:00:42,079 --> 00:00:46,719
today this is an 85 minute session

00:00:44,320 --> 00:00:48,320
um i'm going to do a few minutes of an

00:00:46,719 --> 00:00:48,800
introduction just basically talking

00:00:48,320 --> 00:00:50,719
about

00:00:48,800 --> 00:00:51,920
what infrastructure is and how people

00:00:50,719 --> 00:00:54,079
are doing it today

00:00:51,920 --> 00:00:55,600
and then we'll really get into a lot of

00:00:54,079 --> 00:00:57,440
coding where we'll be talking about

00:00:55,600 --> 00:00:58,879
actually developing your own controller

00:00:57,440 --> 00:01:01,199
and during that we're basically going to

00:00:58,879 --> 00:01:02,559
walk through all the parts of doing that

00:01:01,199 --> 00:01:03,920
that's from defining your custom

00:01:02,559 --> 00:01:06,240
resource definitions

00:01:03,920 --> 00:01:07,360
um talking to the remote api that you

00:01:06,240 --> 00:01:08,720
want to manage

00:01:07,360 --> 00:01:10,560
actually how you get into the guts of a

00:01:08,720 --> 00:01:11,680
controller and do credit operations and

00:01:10,560 --> 00:01:12,960
then finally we're gonna do some more

00:01:11,680 --> 00:01:14,880
advanced things

00:01:12,960 --> 00:01:16,400
like packaging your controller up so you

00:01:14,880 --> 00:01:17,759
could deliver it to clusters and then

00:01:16,400 --> 00:01:19,119
finally there's some really cool

00:01:17,759 --> 00:01:20,799
higher level abstractions we could do

00:01:19,119 --> 00:01:21,840
where you could take other people's

00:01:20,799 --> 00:01:23,520
controllers and other people's

00:01:21,840 --> 00:01:25,280
kubernetes objects and combine them to

00:01:23,520 --> 00:01:26,479
make more complex infrastructure so

00:01:25,280 --> 00:01:28,240
there's really

00:01:26,479 --> 00:01:29,680
very powerful things so we hope to show

00:01:28,240 --> 00:01:30,000
you that this is actually fairly easy to

00:01:29,680 --> 00:01:32,560
do

00:01:30,000 --> 00:01:35,840
and that you can really make a very

00:01:32,560 --> 00:01:37,200
powerful platform on top of this

00:01:35,840 --> 00:01:39,439
so first when we talk about

00:01:37,200 --> 00:01:40,640
infrastructure what do we mean

00:01:39,439 --> 00:01:42,399
if you look at now what a lot of

00:01:40,640 --> 00:01:43,920
companies are provisioning what's in the

00:01:42,399 --> 00:01:45,680
scope of infrastructure teams it's

00:01:43,920 --> 00:01:47,759
usually things like storage

00:01:45,680 --> 00:01:49,840
and virtual machines and folks will be

00:01:47,759 --> 00:01:51,680
asking for firewall rules and networks

00:01:49,840 --> 00:01:53,360
and dns records so whenever

00:01:51,680 --> 00:01:54,880
someone wants you know an application

00:01:53,360 --> 00:01:56,479
team wants to deploy something they're

00:01:54,880 --> 00:01:59,119
usually asking for

00:01:56,479 --> 00:02:00,640
a lot of these things and if you look at

00:01:59,119 --> 00:02:02,240
how infrastructure teams they used to do

00:02:00,640 --> 00:02:02,880
these manually and then slowly they've

00:02:02,240 --> 00:02:04,799
been

00:02:02,880 --> 00:02:06,320
getting into automation so what you see

00:02:04,799 --> 00:02:07,520
is usually in most enterprises what

00:02:06,320 --> 00:02:08,959
companies are doing is they're writing

00:02:07,520 --> 00:02:09,440
these things in scripts they're doing

00:02:08,959 --> 00:02:12,800
some

00:02:09,440 --> 00:02:14,800
you know chef for python and ruby um

00:02:12,800 --> 00:02:16,000
and you know or you know some of the

00:02:14,800 --> 00:02:17,599
newer companies like

00:02:16,000 --> 00:02:20,160
newer efforts things a lot of these

00:02:17,599 --> 00:02:22,160
tools are migrating it to go

00:02:20,160 --> 00:02:24,160
and what folks usually do is build like

00:02:22,160 --> 00:02:24,480
custom scripting on top of devops tools

00:02:24,160 --> 00:02:26,800
like

00:02:24,480 --> 00:02:27,840
chef um ansible is very popular and

00:02:26,800 --> 00:02:29,360
probably one of the most popular

00:02:27,840 --> 00:02:30,879
provisioning tools recently has been

00:02:29,360 --> 00:02:33,040
something called terraform

00:02:30,879 --> 00:02:34,319
um which is really good for managing

00:02:33,040 --> 00:02:35,840
remote apis

00:02:34,319 --> 00:02:37,519
and then finally like the run time for

00:02:35,840 --> 00:02:39,680
these platforms is usually

00:02:37,519 --> 00:02:40,720
uh a ci system so what happens is

00:02:39,680 --> 00:02:43,200
somebody commits

00:02:40,720 --> 00:02:44,959
something into git the ci system sees it

00:02:43,200 --> 00:02:46,319
and you know fires off these scripts so

00:02:44,959 --> 00:02:47,120
this infrastructure that you're building

00:02:46,319 --> 00:02:48,959
on top of

00:02:47,120 --> 00:02:50,560
your custom scripting using some devops

00:02:48,959 --> 00:02:53,680
tools is usually fired off

00:02:50,560 --> 00:02:54,319
you know with a ci pipeline so you know

00:02:53,680 --> 00:02:56,080
and this is

00:02:54,319 --> 00:02:57,440
basically what it looks like kind of

00:02:56,080 --> 00:02:58,959
logically right so

00:02:57,440 --> 00:03:00,879
usually what happens is you'll define

00:02:58,959 --> 00:03:02,879
your own spec and um

00:03:00,879 --> 00:03:04,159
you know i've been on demo days where

00:03:02,879 --> 00:03:05,920
every single team

00:03:04,159 --> 00:03:07,280
defines their own specs so we'll have

00:03:05,920 --> 00:03:08,560
five different spec files introduced

00:03:07,280 --> 00:03:11,760
during one demo day

00:03:08,560 --> 00:03:13,760
so this is um you know

00:03:11,760 --> 00:03:15,519
we generate a lot of these next thing is

00:03:13,760 --> 00:03:17,440
in your pipeline

00:03:15,519 --> 00:03:18,800
you usually have some code especially

00:03:17,440 --> 00:03:19,599
systems like jenkins that allow you to

00:03:18,800 --> 00:03:22,800
do things like

00:03:19,599 --> 00:03:24,720
groovy code that you'll start seeing um

00:03:22,800 --> 00:03:26,480
running shell scripts in here uh doing

00:03:24,720 --> 00:03:28,239
some advanced logic

00:03:26,480 --> 00:03:29,599
and then finally it's the stuff you want

00:03:28,239 --> 00:03:31,440
to do right like you're

00:03:29,599 --> 00:03:33,360
you have to like compare you have to

00:03:31,440 --> 00:03:34,720
connect to the real remote api you have

00:03:33,360 --> 00:03:35,440
to compare what you have to that and you

00:03:34,720 --> 00:03:37,680
have to do something

00:03:35,440 --> 00:03:41,200
so that's usually what these

00:03:37,680 --> 00:03:41,200
infrastructure pipelines look like today

00:03:41,440 --> 00:03:44,720
so we're going to talk about some of the

00:03:43,280 --> 00:03:46,159
problems that we're hoping to solve with

00:03:44,720 --> 00:03:48,480
the controller approach just you know

00:03:46,159 --> 00:03:49,920
what we see is an existing

00:03:48,480 --> 00:03:51,599
the kind of the issues that are with

00:03:49,920 --> 00:03:52,959
these kind of ci-based deployments and

00:03:51,599 --> 00:03:54,480
the first thing is like when everyone

00:03:52,959 --> 00:03:56,480
has their own spec file there's usually

00:03:54,480 --> 00:03:58,480
validation is not done

00:03:56,480 --> 00:04:00,239
um you know it might be done at the json

00:03:58,480 --> 00:04:00,799
level but it's usually not a schema

00:04:00,239 --> 00:04:02,879
level

00:04:00,799 --> 00:04:04,239
a validation the next thing is a lot of

00:04:02,879 --> 00:04:06,480
these things are very

00:04:04,239 --> 00:04:07,360
uh command line driven and it's very

00:04:06,480 --> 00:04:09,120
hard to expand

00:04:07,360 --> 00:04:10,319
export these as an api to developers

00:04:09,120 --> 00:04:12,159
right so the developer experience

00:04:10,319 --> 00:04:12,879
usually involves opening up a ticket or

00:04:12,159 --> 00:04:16,079
committing something

00:04:12,879 --> 00:04:17,919
to get and then finally tooling is very

00:04:16,079 --> 00:04:19,600
basic you know you might be able to edit

00:04:17,919 --> 00:04:21,199
the files in json but

00:04:19,600 --> 00:04:23,600
there's not a lot of other dev tools

00:04:21,199 --> 00:04:26,960
that support it

00:04:23,600 --> 00:04:29,199
the ci pipeline is usually the

00:04:26,960 --> 00:04:30,240
the main thing running this and probably

00:04:29,199 --> 00:04:31,919
the most

00:04:30,240 --> 00:04:33,360
important thing about this is like these

00:04:31,919 --> 00:04:36,400
fire off on changes in git

00:04:33,360 --> 00:04:37,680
not in changes of desired state so you

00:04:36,400 --> 00:04:38,720
know it doesn't care whether you're

00:04:37,680 --> 00:04:39,919
adding a comment or whether you're

00:04:38,720 --> 00:04:41,120
making large changes

00:04:39,919 --> 00:04:42,479
it's still going to fire it off and

00:04:41,120 --> 00:04:43,520
usually what happens is it runs only

00:04:42,479 --> 00:04:45,600
once

00:04:43,520 --> 00:04:46,880
um so once you deploy this it doesn't go

00:04:45,600 --> 00:04:48,160
back and check it doesn't check if

00:04:46,880 --> 00:04:49,280
anything is drifted or anything like

00:04:48,160 --> 00:04:52,639
that

00:04:49,280 --> 00:04:53,840
and then finally there's a lot of

00:04:52,639 --> 00:04:55,280
you know especially with homegrown

00:04:53,840 --> 00:04:56,240
tooling there's a lot of issues around

00:04:55,280 --> 00:04:58,080
reconciliation

00:04:56,240 --> 00:04:59,759
and state management and usually

00:04:58,080 --> 00:05:01,440
operations is

00:04:59,759 --> 00:05:03,600
you know besides sending out an email to

00:05:01,440 --> 00:05:04,240
someone if a job fails is pretty much

00:05:03,600 --> 00:05:05,680
the

00:05:04,240 --> 00:05:07,680
most of the operational support that a

00:05:05,680 --> 00:05:08,320
lot of these tools have so that's kind

00:05:07,680 --> 00:05:09,759
of

00:05:08,320 --> 00:05:11,280
if you look at what the vast majority of

00:05:09,759 --> 00:05:12,400
like internal tools are right now it's

00:05:11,280 --> 00:05:13,520
pretty much like this

00:05:12,400 --> 00:05:14,560
so what we want to talk about since

00:05:13,520 --> 00:05:16,400
we're in kubernetes we want to talk

00:05:14,560 --> 00:05:18,880
about how do we do this in a way that

00:05:16,400 --> 00:05:19,919
you know is kubernetes centric and that

00:05:18,880 --> 00:05:21,919
you know takes advantage of the

00:05:19,919 --> 00:05:23,520
kubernetes platform so

00:05:21,919 --> 00:05:25,120
the first thing is that we talk about

00:05:23,520 --> 00:05:26,720
the controller approach right what if we

00:05:25,120 --> 00:05:28,400
could take all those things

00:05:26,720 --> 00:05:30,400
that we want to provision them and model

00:05:28,400 --> 00:05:32,560
them as kubernetes objects so

00:05:30,400 --> 00:05:34,639
you know we'll have a sql database kind

00:05:32,560 --> 00:05:36,240
we will have a storage bucket kind and

00:05:34,639 --> 00:05:39,600
you know for this demo we'll have like a

00:05:36,240 --> 00:05:41,440
github team time

00:05:39,600 --> 00:05:43,199
um and as part of that we can have a

00:05:41,440 --> 00:05:44,479
spec defined we could have metadata we

00:05:43,199 --> 00:05:45,919
could have annotations all the good

00:05:44,479 --> 00:05:47,600
things about kubernetes

00:05:45,919 --> 00:05:48,800
um we could have this in our files and

00:05:47,600 --> 00:05:50,320
we don't have to think about the spec

00:05:48,800 --> 00:05:51,759
file anymore because it's handled by

00:05:50,320 --> 00:05:52,960
somebody else

00:05:51,759 --> 00:05:54,479
then what we could do is we could put

00:05:52,960 --> 00:05:55,840
kubernetes there and then you know a lot

00:05:54,479 --> 00:05:57,199
of the great things about kubernetes it

00:05:55,840 --> 00:05:58,400
has an api that supports a lot of

00:05:57,199 --> 00:06:00,720
different tooling

00:05:58,400 --> 00:06:02,160
um it can watch for events for you it

00:06:00,720 --> 00:06:03,120
can look at changes and things like that

00:06:02,160 --> 00:06:05,680
and notify

00:06:03,120 --> 00:06:06,479
you know whatever back end you want so

00:06:05,680 --> 00:06:07,919
um

00:06:06,479 --> 00:06:09,680
that's kind of a powerful pattern and

00:06:07,919 --> 00:06:10,880
then finally what we want is that for

00:06:09,680 --> 00:06:12,240
each one of these things that we want to

00:06:10,880 --> 00:06:12,720
manage we'll probably have a controller

00:06:12,240 --> 00:06:15,840
running

00:06:12,720 --> 00:06:17,919
and this will be um

00:06:15,840 --> 00:06:19,840
constantly trying to reconcile whatever

00:06:17,919 --> 00:06:21,520
desired state you put into the system

00:06:19,840 --> 00:06:24,160
talking to the external api

00:06:21,520 --> 00:06:25,600
so things like observability failover um

00:06:24,160 --> 00:06:27,360
there's a whole bunch of features you

00:06:25,600 --> 00:06:29,120
get in a kubernetes controller

00:06:27,360 --> 00:06:30,400
that basically spending all its time

00:06:29,120 --> 00:06:31,840
trying to get to the state that you've

00:06:30,400 --> 00:06:35,840
asked for so it's a very powerful

00:06:31,840 --> 00:06:35,840
pattern in that way

00:06:36,319 --> 00:06:40,000
so what we're going to talk about in

00:06:37,759 --> 00:06:41,120
this tutorial today is basically how we

00:06:40,000 --> 00:06:42,319
build in all the layers of this

00:06:41,120 --> 00:06:44,400
controller so

00:06:42,319 --> 00:06:45,919
at the very bottom level you know we

00:06:44,400 --> 00:06:47,199
have kubernetes itself which will run

00:06:45,919 --> 00:06:48,639
our controllers which run adapter

00:06:47,199 --> 00:06:50,319
containers and it'll handle things like

00:06:48,639 --> 00:06:51,039
well-based access controls if you want

00:06:50,319 --> 00:06:52,960
to put

00:06:51,039 --> 00:06:54,720
a firewall in front of this or a load

00:06:52,960 --> 00:06:56,240
balancer the next thing is if you

00:06:54,720 --> 00:06:58,240
haven't worked with kubernetes before

00:06:56,240 --> 00:07:00,560
like done any programming there's this

00:06:58,240 --> 00:07:03,440
entire thing concept of machinery right

00:07:00,560 --> 00:07:04,720
this is how all the apis are composed

00:07:03,440 --> 00:07:05,840
and there's a lot of great things here

00:07:04,720 --> 00:07:07,520
but probably one of the most important

00:07:05,840 --> 00:07:08,560
things that's emerged recently is this

00:07:07,520 --> 00:07:10,560
idea of

00:07:08,560 --> 00:07:11,520
custom resource definitions or crds

00:07:10,560 --> 00:07:13,039
you're going to hear these a lot and

00:07:11,520 --> 00:07:14,880
this is how you can make

00:07:13,039 --> 00:07:16,560
custom objects look like native

00:07:14,880 --> 00:07:18,479
kubernetes so if you want to define your

00:07:16,560 --> 00:07:20,000
own type like a virtual machine type

00:07:18,479 --> 00:07:22,479
you can just apply it to kubernetes and

00:07:20,000 --> 00:07:24,639
it'll look like anything else

00:07:22,479 --> 00:07:26,880
on top of that is this library called

00:07:24,639 --> 00:07:29,360
controller runtime which is

00:07:26,880 --> 00:07:30,639
recently become probably one of the main

00:07:29,360 --> 00:07:32,080
libraries that almost everyone who

00:07:30,639 --> 00:07:34,479
writes kubernetes controllers

00:07:32,080 --> 00:07:36,720
at least uses the sum part um and this

00:07:34,479 --> 00:07:38,720
takes care of things like what happens

00:07:36,720 --> 00:07:40,479
um if someone applies a change to one of

00:07:38,720 --> 00:07:42,000
the kubernetes objects it watches it

00:07:40,479 --> 00:07:43,599
helps you do reconciliation on

00:07:42,000 --> 00:07:45,360
kubernetes so it makes it very easy to

00:07:43,599 --> 00:07:46,160
have these controllers that respond to

00:07:45,360 --> 00:07:48,479
changes

00:07:46,160 --> 00:07:49,520
when your customers you know want to ask

00:07:48,479 --> 00:07:52,000
for something different your

00:07:49,520 --> 00:07:54,000
infrastructure will automatically get

00:07:52,000 --> 00:07:55,360
notify whatever's watching it and then

00:07:54,000 --> 00:07:57,120
finally probably one of the

00:07:55,360 --> 00:07:58,720
most interesting things about this talk

00:07:57,120 --> 00:08:00,240
is across plain run time itself and

00:07:58,720 --> 00:08:03,280
crossplay makes it

00:08:00,240 --> 00:08:04,879
really easy to manage external apis

00:08:03,280 --> 00:08:06,879
most of the other kubernetes things make

00:08:04,879 --> 00:08:09,199
it easy to manage kubernetes objects but

00:08:06,879 --> 00:08:11,599
crossplane makes it really easy to say

00:08:09,199 --> 00:08:12,879
find any api out there and then do these

00:08:11,599 --> 00:08:13,840
operations and treat it like a

00:08:12,879 --> 00:08:15,520
kubernetes

00:08:13,840 --> 00:08:16,720
managed infrastructure so this is really

00:08:15,520 --> 00:08:17,680
one of the most exciting things that

00:08:16,720 --> 00:08:19,680
makes it

00:08:17,680 --> 00:08:21,280
um really good for building your own

00:08:19,680 --> 00:08:22,800
software because really

00:08:21,280 --> 00:08:25,759
the benefit of this approach is that

00:08:22,800 --> 00:08:27,440
basically you only have to focus on kind

00:08:25,759 --> 00:08:27,759
of the logic in your controller and you

00:08:27,440 --> 00:08:30,400
get

00:08:27,759 --> 00:08:31,840
extremely full-featured control planes

00:08:30,400 --> 00:08:33,599
just by building on the rest of this

00:08:31,840 --> 00:08:35,440
things that are constantly reconciling

00:08:33,599 --> 00:08:37,200
things that are validated via open api

00:08:35,440 --> 00:08:39,120
at the client level so

00:08:37,200 --> 00:08:40,560
um this is a very powerful platform and

00:08:39,120 --> 00:08:43,839
you can spend a lot of your time

00:08:40,560 --> 00:08:43,839
just focusing on your logic

00:08:44,080 --> 00:08:47,519
and finally um i you know it has to be

00:08:46,240 --> 00:08:48,640
said that you know when you have native

00:08:47,519 --> 00:08:50,080
kubernetes controllers for your

00:08:48,640 --> 00:08:52,720
infrastructure suddenly you could use

00:08:50,080 --> 00:08:54,240
all kinds of great tools i use customize

00:08:52,720 --> 00:08:57,360
a lot personally the amazon

00:08:54,240 --> 00:08:59,360
cdk is really interesting too

00:08:57,360 --> 00:09:01,040
i'm a big fan of argo cd for deploying

00:08:59,360 --> 00:09:03,600
things to any cluster it does zips

00:09:01,040 --> 00:09:05,200
valero could back it up um there's

00:09:03,600 --> 00:09:08,640
cross-plane demos using open

00:09:05,200 --> 00:09:10,480
policy agent so it's a lot of exciting

00:09:08,640 --> 00:09:12,160
things

00:09:10,480 --> 00:09:14,560
so finally summary there's a massive

00:09:12,160 --> 00:09:16,480
ecosystem support crds let you expose

00:09:14,560 --> 00:09:17,760
infrastructures kubernetes objects and

00:09:16,480 --> 00:09:19,360
really there's libraries that let you

00:09:17,760 --> 00:09:20,560
build really full featured powerful

00:09:19,360 --> 00:09:22,800
software so

00:09:20,560 --> 00:09:24,399
really in summary this is really um an

00:09:22,800 --> 00:09:25,920
ideal platform for managing about any

00:09:24,399 --> 00:09:28,080
infrastructure

00:09:25,920 --> 00:09:29,680
all right so before we get too far into

00:09:28,080 --> 00:09:31,680
the tutorial i just want to walk through

00:09:29,680 --> 00:09:33,040
taking a look at what crossplane is and

00:09:31,680 --> 00:09:34,480
how we can get it installed

00:09:33,040 --> 00:09:36,160
and start extending someone's

00:09:34,480 --> 00:09:38,160
functionality so

00:09:36,160 --> 00:09:39,600
i'm here on the crossplane website and

00:09:38,160 --> 00:09:41,519
you'll see the main thing that we're

00:09:39,600 --> 00:09:43,120
going to propose doing with crossplane

00:09:41,519 --> 00:09:44,399
is managing our infrastructure from

00:09:43,120 --> 00:09:46,000
kubernetes

00:09:44,399 --> 00:09:47,920
if we go over to our documentation we

00:09:46,000 --> 00:09:49,440
have a helpful getting started guide

00:09:47,920 --> 00:09:51,279
which we're going to run through uh

00:09:49,440 --> 00:09:52,959
shortly right here

00:09:51,279 --> 00:09:54,399
so i'll start off by going ahead and

00:09:52,959 --> 00:09:56,240
spinning up a kind cluster

00:09:54,399 --> 00:09:58,320
if you're not familiar with kind it's a

00:09:56,240 --> 00:09:58,959
great way to run a local kubernetes

00:09:58,320 --> 00:10:00,080
cluster

00:09:58,959 --> 00:10:02,640
so it's actually going to start a

00:10:00,080 --> 00:10:04,640
cluster running in docker for us

00:10:02,640 --> 00:10:05,680
so while that's coming up let's go ahead

00:10:04,640 --> 00:10:07,440
and take a look

00:10:05,680 --> 00:10:09,360
at what crossplaying kind of proposes it

00:10:07,440 --> 00:10:10,959
will do for you all right so the first

00:10:09,360 --> 00:10:11,760
thing is provisioning and managing your

00:10:10,959 --> 00:10:13,040
infrastructure

00:10:11,760 --> 00:10:15,200
and that's the primary thing we're going

00:10:13,040 --> 00:10:15,920
to be looking at today at the end of our

00:10:15,200 --> 00:10:17,920
tutorial

00:10:15,920 --> 00:10:18,959
we'll talk a little bit about how we can

00:10:17,920 --> 00:10:21,200
package that up and

00:10:18,959 --> 00:10:23,440
install it um into different cross-plane

00:10:21,200 --> 00:10:25,680
clusters to extend that functionality

00:10:23,440 --> 00:10:26,959
but the first thing we want to do is as

00:10:25,680 --> 00:10:29,120
a kubernetes add-on

00:10:26,959 --> 00:10:30,880
install crossplane into our kubernetes

00:10:29,120 --> 00:10:32,320
cluster so you'll see here we have the

00:10:30,880 --> 00:10:34,160
alpha and master channels

00:10:32,320 --> 00:10:36,000
um alpha just being the latest release

00:10:34,160 --> 00:10:38,240
which is 0.13

00:10:36,000 --> 00:10:40,079
as of this recording so we can go ahead

00:10:38,240 --> 00:10:42,480
and create a namespace and i've already

00:10:40,079 --> 00:10:44,480
added the crossplane alpha repo here

00:10:42,480 --> 00:10:47,839
so it's just going to be one command to

00:10:44,480 --> 00:10:47,839
helm install crossplane

00:10:48,079 --> 00:10:51,279
so let's see if our cluster has come up

00:10:49,920 --> 00:10:53,920
here it looks like it has

00:10:51,279 --> 00:10:56,240
so i'll create that namespace crossplane

00:10:53,920 --> 00:10:59,760
system which is where we like to

00:10:56,240 --> 00:11:02,240
install crossplane and then we can go

00:10:59,760 --> 00:11:03,760
ahead and do the helm installation

00:11:02,240 --> 00:11:05,279
so after a moment here you'll see that

00:11:03,760 --> 00:11:06,800
it gives us a little bit of information

00:11:05,279 --> 00:11:08,519
as well as a chart description

00:11:06,800 --> 00:11:10,240
and you'll see we're using chart version

00:11:08,519 --> 00:11:11,839
0.13

00:11:10,240 --> 00:11:13,279
if we look at the pods that are now

00:11:11,839 --> 00:11:15,040
running in our cluster

00:11:13,279 --> 00:11:16,720
we should see the crossplane pod which

00:11:15,040 --> 00:11:17,839
is kind of the core functionality of

00:11:16,720 --> 00:11:19,920
crossplane

00:11:17,839 --> 00:11:21,600
and then the rbac manager having these

00:11:19,920 --> 00:11:23,279
two separate processes allows us to

00:11:21,600 --> 00:11:25,120
really lock down security

00:11:23,279 --> 00:11:26,880
because managing our back is completely

00:11:25,120 --> 00:11:29,440
dedicated to the rbac manager

00:11:26,880 --> 00:11:31,360
which allows crossplane to run with

00:11:29,440 --> 00:11:32,480
lesser permissions than cluster admin

00:11:31,360 --> 00:11:34,000
if you'd like to manage those

00:11:32,480 --> 00:11:35,680
permissions yourself instead of having

00:11:34,000 --> 00:11:37,680
this automated workflow

00:11:35,680 --> 00:11:39,440
with the rbac manager you're welcome to

00:11:37,680 --> 00:11:42,959
just deploy the crossplane pod

00:11:39,440 --> 00:11:44,640
and let that handle all the work for you

00:11:42,959 --> 00:11:46,240
all right so now we have all of these

00:11:44,640 --> 00:11:48,560
pods running

00:11:46,240 --> 00:11:50,639
and if we look at our crds here we still

00:11:48,560 --> 00:11:51,440
haven't installed very much in the terms

00:11:50,639 --> 00:11:54,880
of new api

00:11:51,440 --> 00:11:57,360
types you'll see some kind of

00:11:54,880 --> 00:11:59,200
meta crd types like packaging for

00:11:57,360 --> 00:12:00,560
configurations and providers which we're

00:11:59,200 --> 00:12:02,399
going to look at momentarily

00:12:00,560 --> 00:12:03,680
but you don't see any external cloud

00:12:02,399 --> 00:12:05,360
infrastructure yet

00:12:03,680 --> 00:12:07,279
that's because crossplane comes out of

00:12:05,360 --> 00:12:09,200
the box without supporting any

00:12:07,279 --> 00:12:10,000
individual providers so it differs from

00:12:09,200 --> 00:12:12,160
other solutions

00:12:10,000 --> 00:12:13,839
in that regard that may be proprietary

00:12:12,160 --> 00:12:15,040
to a single cloud provider or something

00:12:13,839 --> 00:12:17,120
like that

00:12:15,040 --> 00:12:18,800
we have a provider model which is what

00:12:17,120 --> 00:12:20,720
we're going to be designing today

00:12:18,800 --> 00:12:22,560
but we also have a number of providers

00:12:20,720 --> 00:12:24,480
for common cloud infrastructure

00:12:22,560 --> 00:12:25,839
that cross-plane as a community

00:12:24,480 --> 00:12:27,680
maintains

00:12:25,839 --> 00:12:29,120
so we can go ahead and go into the

00:12:27,680 --> 00:12:31,040
documentation here and the first thing

00:12:29,120 --> 00:12:32,720
we do after installing crossplane

00:12:31,040 --> 00:12:35,040
and checking the status is install the

00:12:32,720 --> 00:12:36,959
crossplane cli this is a cube control

00:12:35,040 --> 00:12:38,720
plugin so you'll just be able to do cube

00:12:36,959 --> 00:12:39,519
control cross plane and a variety of

00:12:38,720 --> 00:12:41,360
commands

00:12:39,519 --> 00:12:42,639
and this makes it really easy to add new

00:12:41,360 --> 00:12:44,720
functionality

00:12:42,639 --> 00:12:46,480
so we have two types of packages in

00:12:44,720 --> 00:12:48,880
crossplane and we're particularly

00:12:46,480 --> 00:12:50,880
looking at provider today

00:12:48,880 --> 00:12:52,000
and so you'll see here we want to

00:12:50,880 --> 00:12:53,600
install a provider

00:12:52,000 --> 00:12:55,600
provider aws so this is actually

00:12:53,600 --> 00:12:57,040
packaged up in an oci image

00:12:55,600 --> 00:13:00,079
and we're going to use the latest stable

00:12:57,040 --> 00:13:02,000
version of provider aws which is 0.12

00:13:00,079 --> 00:13:04,480
so i'll go ahead and copy this over into

00:13:02,000 --> 00:13:05,839
my cluster

00:13:04,480 --> 00:13:07,440
and once again we see that we have these

00:13:05,839 --> 00:13:08,720
crds and just the cross plane pods

00:13:07,440 --> 00:13:10,320
running

00:13:08,720 --> 00:13:11,839
we're going to go ahead and install the

00:13:10,320 --> 00:13:13,760
provider what's happening behind the

00:13:11,839 --> 00:13:15,360
scenes is that crossplane is unpacking

00:13:13,760 --> 00:13:16,399
the contents of this provider that we

00:13:15,360 --> 00:13:18,560
created

00:13:16,399 --> 00:13:20,000
and it's going to install crds and also

00:13:18,560 --> 00:13:22,560
start controllers to watch

00:13:20,000 --> 00:13:25,360
those crds and take action uh based on

00:13:22,560 --> 00:13:26,720
events that take place in the cluster

00:13:25,360 --> 00:13:28,800
so let's go ahead and take a look at the

00:13:26,720 --> 00:13:30,480
crds you'll see we have far more now and

00:13:28,800 --> 00:13:32,880
if we actually scroll up

00:13:30,480 --> 00:13:34,240
you'll see that there are lots of aws

00:13:32,880 --> 00:13:37,440
specific ones

00:13:34,240 --> 00:13:38,639
such as repositories for ecr ec2

00:13:37,440 --> 00:13:42,000
security groups

00:13:38,639 --> 00:13:43,120
iam roles dynamo tables rds instances

00:13:42,000 --> 00:13:45,120
etc

00:13:43,120 --> 00:13:47,279
so we've just extended the functionality

00:13:45,120 --> 00:13:49,519
of our kubernetes cluster quite a bit

00:13:47,279 --> 00:13:51,440
by being able to right alongside our

00:13:49,519 --> 00:13:52,000
deployments and other native kubernetes

00:13:51,440 --> 00:13:54,880
types

00:13:52,000 --> 00:13:56,320
uh create external infrastructure which

00:13:54,880 --> 00:13:58,000
we can then use to manage our

00:13:56,320 --> 00:14:01,519
infrastructure on those cloud platforms

00:13:58,000 --> 00:14:04,639
and connect that to our cross plane

00:14:01,519 --> 00:14:05,360
instances and once we have provider aws

00:14:04,639 --> 00:14:07,839
installed

00:14:05,360 --> 00:14:09,519
we can see what crds it brought with it

00:14:07,839 --> 00:14:12,320
and we can also see

00:14:09,519 --> 00:14:13,680
that there is a controller running for

00:14:12,320 --> 00:14:14,959
provider aws that's going to be

00:14:13,680 --> 00:14:18,240
reconciling

00:14:14,959 --> 00:14:19,839
those resources all right so the next

00:14:18,240 --> 00:14:22,480
thing we want to do is to be able to

00:14:19,839 --> 00:14:25,040
actually provision resources on aws

00:14:22,480 --> 00:14:26,399
we need to create a secret with our

00:14:25,040 --> 00:14:27,839
account information

00:14:26,399 --> 00:14:30,079
which we have a helpful command here to

00:14:27,839 --> 00:14:31,040
use the aws cli to do

00:14:30,079 --> 00:14:33,120
and then we're going to create a

00:14:31,040 --> 00:14:34,880
provider config which basically

00:14:33,120 --> 00:14:36,720
informs crossplane how to reach out to

00:14:34,880 --> 00:14:38,880
the aws provider and here we're going to

00:14:36,720 --> 00:14:41,199
use the secret credential source

00:14:38,880 --> 00:14:42,079
to be able to do that so i'll just run

00:14:41,199 --> 00:14:45,199
these commands

00:14:42,079 --> 00:14:46,079
real quick and we can make sure that we

00:14:45,199 --> 00:14:49,760
get something

00:14:46,079 --> 00:14:50,480
installed all right so we created our

00:14:49,760 --> 00:14:52,160
file

00:14:50,480 --> 00:14:55,839
and then we're going to create a generic

00:14:52,160 --> 00:14:57,920
secret from it in our kubernetes cluster

00:14:55,839 --> 00:14:59,600
and the last thing we want to do is go

00:14:57,920 --> 00:15:00,880
ahead and use this provider config

00:14:59,600 --> 00:15:03,600
and we have this helpful command here

00:15:00,880 --> 00:15:05,519
where you can apply it from a remote url

00:15:03,600 --> 00:15:07,120
i would normally advise you to check the

00:15:05,519 --> 00:15:08,160
contents of something before you apply

00:15:07,120 --> 00:15:10,160
it against your cluster

00:15:08,160 --> 00:15:12,000
but since we have a local cluster here

00:15:10,160 --> 00:15:14,720
and i put this link here we'll go

00:15:12,000 --> 00:15:14,720
ahead and do it

00:15:15,440 --> 00:15:18,720
all right so we have our default

00:15:16,959 --> 00:15:21,600
provider config here

00:15:18,720 --> 00:15:23,040
and the next step is to actually

00:15:21,600 --> 00:15:24,720
provision some resources

00:15:23,040 --> 00:15:26,480
so let's go on to the next section and

00:15:24,720 --> 00:15:27,440
look at provision infrastructure

00:15:26,480 --> 00:15:30,639
and you'll see what we're going to

00:15:27,440 --> 00:15:31,920
provision is an rds instance on aws

00:15:30,639 --> 00:15:33,279
and we're going to tell it where to

00:15:31,920 --> 00:15:34,560
write our connection secret so that's

00:15:33,279 --> 00:15:35,839
another big part of cross plane which

00:15:34,560 --> 00:15:37,360
we're going to see later on we're

00:15:35,839 --> 00:15:39,839
designing our own

00:15:37,360 --> 00:15:41,360
provider is you know credential

00:15:39,839 --> 00:15:42,399
information so you can connect this to

00:15:41,360 --> 00:15:44,320
your workload so you can have a

00:15:42,399 --> 00:15:46,240
deployment that talks to the database

00:15:44,320 --> 00:15:48,240
we're going to show a simple example

00:15:46,240 --> 00:15:51,920
here um so we're just going to provision

00:15:48,240 --> 00:15:51,920
the database and see what happens

00:15:52,880 --> 00:15:57,199
all right we'll run this command it

00:15:55,440 --> 00:15:59,360
looks like our rds postgres

00:15:57,199 --> 00:16:01,199
instance was created and we have a

00:15:59,360 --> 00:16:02,880
couple of shortcuts that will help you

00:16:01,199 --> 00:16:05,120
get resources more quickly

00:16:02,880 --> 00:16:07,279
um so you could do something like kgit

00:16:05,120 --> 00:16:08,399
aws here to list all of your aws

00:16:07,279 --> 00:16:10,240
resources which

00:16:08,399 --> 00:16:12,320
this frequently has large gaps in it so

00:16:10,240 --> 00:16:15,680
let's do something more specific

00:16:12,320 --> 00:16:16,959
and just get an rds instance all right

00:16:15,680 --> 00:16:18,800
so we have our rds

00:16:16,959 --> 00:16:20,399
instance that we just created you'll see

00:16:18,800 --> 00:16:22,560
some information about that

00:16:20,399 --> 00:16:24,959
importantly we have our sync value which

00:16:22,560 --> 00:16:27,040
is saying is our cross plane controller

00:16:24,959 --> 00:16:28,000
and the spec that we've specified for

00:16:27,040 --> 00:16:31,040
this resource

00:16:28,000 --> 00:16:32,880
um consistent with what is happening um

00:16:31,040 --> 00:16:34,959
on the external infrastructure and then

00:16:32,880 --> 00:16:36,800
ready is indicating that it's false

00:16:34,959 --> 00:16:38,720
and that's basically just to let us know

00:16:36,800 --> 00:16:39,839
that this resource is not available for

00:16:38,720 --> 00:16:42,079
consumption yet

00:16:39,839 --> 00:16:43,920
and since we specified that the

00:16:42,079 --> 00:16:45,040
connection information should be written

00:16:43,920 --> 00:16:47,360
to this secret

00:16:45,040 --> 00:16:49,120
when the resource actually becomes ready

00:16:47,360 --> 00:16:49,680
we should be able to get secrets and in

00:16:49,120 --> 00:16:52,480
this case

00:16:49,680 --> 00:16:54,880
in the cross plane system namespace and

00:16:52,480 --> 00:16:56,959
see that it's there

00:16:54,880 --> 00:16:58,480
and we'll see here that we don't see the

00:16:56,959 --> 00:16:59,600
secret at this point or actually we do

00:16:58,480 --> 00:17:02,399
it's already present

00:16:59,600 --> 00:17:03,519
so that was given to us by the actual

00:17:02,399 --> 00:17:06,079
create operation

00:17:03,519 --> 00:17:06,720
when this is finished provisioning we're

00:17:06,079 --> 00:17:09,039
going to see

00:17:06,720 --> 00:17:10,640
more connection information in there and

00:17:09,039 --> 00:17:12,160
you can look up the documentation to

00:17:10,640 --> 00:17:14,880
actually see all the connection

00:17:12,160 --> 00:17:16,000
information then rds instance publishes

00:17:14,880 --> 00:17:17,919
to its secret

00:17:16,000 --> 00:17:20,400
and then you can specify via environment

00:17:17,919 --> 00:17:21,919
variables um or something of that nature

00:17:20,400 --> 00:17:23,520
how to get the secret into your

00:17:21,919 --> 00:17:26,079
deployment so your application

00:17:23,520 --> 00:17:27,839
can talk to it so that's kind of an

00:17:26,079 --> 00:17:29,039
overview of what you can do at the basic

00:17:27,839 --> 00:17:30,799
level with crossplane

00:17:29,039 --> 00:17:32,799
um and you can write whatever provider

00:17:30,799 --> 00:17:34,320
you'd like to fit into this ecosystem

00:17:32,799 --> 00:17:36,720
and crossplane will actually manage

00:17:34,320 --> 00:17:38,320
installing it and upgrading it

00:17:36,720 --> 00:17:40,240
and and managing all of its different

00:17:38,320 --> 00:17:42,000
resources

00:17:40,240 --> 00:17:44,480
and we're going to extend that today but

00:17:42,000 --> 00:17:46,080
you can also do things like packaging up

00:17:44,480 --> 00:17:47,600
your infrastructure abstractions which

00:17:46,080 --> 00:17:48,960
is another layer on top of these

00:17:47,600 --> 00:17:50,720
primitives which are these cloud

00:17:48,960 --> 00:17:51,840
provider resources that we've installed

00:17:50,720 --> 00:17:53,440
into the cluster

00:17:51,840 --> 00:17:55,280
at the end of our tutorial i'm going to

00:17:53,440 --> 00:17:56,640
circle back and show you how we can

00:17:55,280 --> 00:18:00,559
create some of these primitives

00:17:56,640 --> 00:18:02,080
and package them up

00:18:00,559 --> 00:18:04,160
all right so now that we've gotten a

00:18:02,080 --> 00:18:06,000
look at how crossplane works and how you

00:18:04,160 --> 00:18:06,799
can extend its functionality with

00:18:06,000 --> 00:18:08,880
providers

00:18:06,799 --> 00:18:10,160
uh let's look at take a look at one of

00:18:08,880 --> 00:18:11,120
the providers that we're going to work

00:18:10,160 --> 00:18:13,520
on today

00:18:11,120 --> 00:18:15,200
uh this provider github we're calling it

00:18:13,520 --> 00:18:16,960
kubecon provider github here

00:18:15,200 --> 00:18:18,160
and to kind of motivate the discussion

00:18:16,960 --> 00:18:19,679
we're going to have and the work that

00:18:18,160 --> 00:18:21,280
we're going to do today

00:18:19,679 --> 00:18:23,679
and hopefully inspire you to go write

00:18:21,280 --> 00:18:25,360
your own providers let's take a look at

00:18:23,679 --> 00:18:27,440
what this can do

00:18:25,360 --> 00:18:28,400
so if you take a look at the crds in our

00:18:27,440 --> 00:18:29,760
cluster

00:18:28,400 --> 00:18:31,679
you'll see that we have our provider

00:18:29,760 --> 00:18:32,880
config and provider config usage which

00:18:31,679 --> 00:18:34,480
are kind of the plumbing which we'll

00:18:32,880 --> 00:18:35,600
talk about in a little bit

00:18:34,480 --> 00:18:38,160
but the primary thing we're going to

00:18:35,600 --> 00:18:39,280
work on today is this teams resource

00:18:38,160 --> 00:18:41,840
here

00:18:39,280 --> 00:18:43,039
and this team basically represents a

00:18:41,840 --> 00:18:44,160
github team

00:18:43,039 --> 00:18:46,320
and we're going to want to be able to

00:18:44,160 --> 00:18:48,160
create and manage teams on github from

00:18:46,320 --> 00:18:50,400
our kubernetes cluster so

00:18:48,160 --> 00:18:52,000
just like you would with aws or gcp you

00:18:50,400 --> 00:18:53,360
go and create a database

00:18:52,000 --> 00:18:55,760
today we're going to look at creating

00:18:53,360 --> 00:18:57,919
you know cloud resources

00:18:55,760 --> 00:18:58,960
in a github organization so i'll go

00:18:57,919 --> 00:19:01,679
ahead and start off

00:18:58,960 --> 00:19:02,720
i actually have an example prepared here

00:19:01,679 --> 00:19:04,480
for us

00:19:02,720 --> 00:19:06,880
so let's look at the contents of that

00:19:04,480 --> 00:19:08,799
this is a pretty simple

00:19:06,880 --> 00:19:10,240
resource here you can see it's just of

00:19:08,799 --> 00:19:11,760
kind team in the org

00:19:10,240 --> 00:19:14,160
group and we're going to use the name

00:19:11,760 --> 00:19:16,720
which is going to represent the name

00:19:14,160 --> 00:19:18,559
on of the team in github and we have

00:19:16,720 --> 00:19:20,880
some fields to configure it specifically

00:19:18,559 --> 00:19:22,880
the org the description and the privacy

00:19:20,880 --> 00:19:24,480
we'll look at how those get set and how

00:19:22,880 --> 00:19:26,240
they can be modified later on

00:19:24,480 --> 00:19:28,320
but for now we just want to show that we

00:19:26,240 --> 00:19:32,240
can create one of these

00:19:28,320 --> 00:19:32,240
so i'll go ahead and apply

00:19:32,480 --> 00:19:36,320
that resource and you'll see over here

00:19:34,640 --> 00:19:37,840
that we've got some log messages coming

00:19:36,320 --> 00:19:40,240
from our controller which is running

00:19:37,840 --> 00:19:42,000
against a local kind cluster here

00:19:40,240 --> 00:19:43,679
and the important thing we want to see

00:19:42,000 --> 00:19:45,600
that our external resource

00:19:43,679 --> 00:19:47,039
is up to date so essentially that's

00:19:45,600 --> 00:19:49,039
saying is we

00:19:47,039 --> 00:19:50,640
went and first we created the resource

00:19:49,039 --> 00:19:52,320
and then we

00:19:50,640 --> 00:19:54,000
checked to make sure that it matches the

00:19:52,320 --> 00:19:55,600
configuration that we specified

00:19:54,000 --> 00:19:57,520
since we just created it it's likely

00:19:55,600 --> 00:19:59,280
that that happens on the first reconcile

00:19:57,520 --> 00:20:01,520
but this controller is going to go ahead

00:19:59,280 --> 00:20:04,880
and make sure that this stays in sync

00:20:01,520 --> 00:20:07,679
and if we look at our team we can say

00:20:04,880 --> 00:20:09,280
that we have a synced team here and if

00:20:07,679 --> 00:20:11,600
you looked at the status

00:20:09,280 --> 00:20:13,280
we can get a little more detail here you

00:20:11,600 --> 00:20:15,120
can see that there's some information

00:20:13,280 --> 00:20:16,880
about when it was last reconciled

00:20:15,120 --> 00:20:19,080
and we can customize this to give more

00:20:16,880 --> 00:20:20,320
information if we want

00:20:19,080 --> 00:20:22,480
[Music]

00:20:20,320 --> 00:20:24,240
i also want to show that this team

00:20:22,480 --> 00:20:25,360
actually does exist in our github

00:20:24,240 --> 00:20:27,280
account

00:20:25,360 --> 00:20:29,120
so if you look at the configuration we

00:20:27,280 --> 00:20:30,559
had we named it was crossplan and we

00:20:29,120 --> 00:20:33,120
have our description

00:20:30,559 --> 00:20:34,640
and then we've also seen that it's a

00:20:33,120 --> 00:20:36,640
secret um

00:20:34,640 --> 00:20:39,120
account uh so we'll show how you can

00:20:36,640 --> 00:20:41,280
maybe uh modify that in the future

00:20:39,120 --> 00:20:43,039
but before we jump into that too much

00:20:41,280 --> 00:20:44,400
we've seen how these resources and

00:20:43,039 --> 00:20:47,360
different apis

00:20:44,400 --> 00:20:48,960
uh get added to a cluster so stephen i

00:20:47,360 --> 00:20:51,440
wanted you to give us a little bit of

00:20:48,960 --> 00:20:52,240
insight onto what is a crd how are they

00:20:51,440 --> 00:20:54,240
structured

00:20:52,240 --> 00:20:56,559
and how does a controller kind of look

00:20:54,240 --> 00:20:59,760
at the two different main parts of a crd

00:20:56,559 --> 00:21:00,640
to drive its action yeah thank you dan

00:20:59,760 --> 00:21:02,000
yeah so

00:21:00,640 --> 00:21:03,679
this is one of the really interesting

00:21:02,000 --> 00:21:04,640
things about this pattern is that you're

00:21:03,679 --> 00:21:05,919
going to hear this term a lot if you

00:21:04,640 --> 00:21:07,679
haven't heard it before and this is a

00:21:05,919 --> 00:21:09,280
custom resource definition and this is

00:21:07,679 --> 00:21:11,919
basically taking

00:21:09,280 --> 00:21:13,600
um things that are outside of kubernetes

00:21:11,919 --> 00:21:14,720
and making them look like kubernetes and

00:21:13,600 --> 00:21:16,880
what we're going to show you right now

00:21:14,720 --> 00:21:19,520
is actually the code for doing that

00:21:16,880 --> 00:21:20,880
um so one of the most important things

00:21:19,520 --> 00:21:22,640
here is like when you

00:21:20,880 --> 00:21:24,240
and this is pretty much the pattern not

00:21:22,640 --> 00:21:24,720
only just for cross plane but pretty

00:21:24,240 --> 00:21:26,480
much

00:21:24,720 --> 00:21:27,679
almost any controller that you're going

00:21:26,480 --> 00:21:29,200
to be seeing that's written for

00:21:27,679 --> 00:21:30,000
kubernetes so you'll have this directory

00:21:29,200 --> 00:21:31,679
called

00:21:30,000 --> 00:21:33,360
apis and then that is usually where we

00:21:31,679 --> 00:21:34,640
have the definitions of where we define

00:21:33,360 --> 00:21:35,840
our crds

00:21:34,640 --> 00:21:38,320
um so what we're going to do is we're

00:21:35,840 --> 00:21:40,640
looking at a file here called types.go

00:21:38,320 --> 00:21:43,039
and there's just a few important fields

00:21:40,640 --> 00:21:46,080
here that we want to put out first

00:21:43,039 --> 00:21:46,480
um this is parameters and observations

00:21:46,080 --> 00:21:49,200
right

00:21:46,480 --> 00:21:50,000
so this here is if you looked at the

00:21:49,200 --> 00:21:52,720
example

00:21:50,000 --> 00:21:54,640
that um dan showed before we had the

00:21:52,720 --> 00:21:56,559
name of the organization the description

00:21:54,640 --> 00:21:59,120
and the privacy settings right so

00:21:56,559 --> 00:21:59,679
when you create a crd what the way it

00:21:59,120 --> 00:22:02,000
works

00:21:59,679 --> 00:22:03,760
with ku builder is that it looks at your

00:22:02,000 --> 00:22:05,679
go code and then the make files

00:22:03,760 --> 00:22:07,440
generate the crd the yaml for that but

00:22:05,679 --> 00:22:08,880
then you apply to your cluster

00:22:07,440 --> 00:22:10,159
so this is how everything gets mapped

00:22:08,880 --> 00:22:12,000
and this is how you create your own

00:22:10,159 --> 00:22:13,679
custom kubernetes objects then you could

00:22:12,000 --> 00:22:15,360
apply to a cluster and have controllers

00:22:13,679 --> 00:22:17,520
manage

00:22:15,360 --> 00:22:19,840
so you can see here we have work

00:22:17,520 --> 00:22:22,080
description and privacy the next thing

00:22:19,840 --> 00:22:23,520
is observations like what's an

00:22:22,080 --> 00:22:25,919
observation an observation

00:22:23,520 --> 00:22:26,960
is something that your controller is

00:22:25,919 --> 00:22:29,039
going to go

00:22:26,960 --> 00:22:30,159
talk to a remote api and observe the

00:22:29,039 --> 00:22:31,919
state of that

00:22:30,159 --> 00:22:33,280
and based on that it's going to decide

00:22:31,919 --> 00:22:34,880
you know what it needs to do in terms of

00:22:33,280 --> 00:22:36,320
reconciliation

00:22:34,880 --> 00:22:38,159
so those are kind of the key things in

00:22:36,320 --> 00:22:40,640
terms of uh

00:22:38,159 --> 00:22:41,840
what you store in terms of your settings

00:22:40,640 --> 00:22:43,360
and the value and

00:22:41,840 --> 00:22:44,640
there's another two important fields

00:22:43,360 --> 00:22:46,000
that you'll see and this is pretty much

00:22:44,640 --> 00:22:48,480
present in all

00:22:46,000 --> 00:22:49,120
coupe builder type controllers there's a

00:22:48,480 --> 00:22:52,960
spec

00:22:49,120 --> 00:22:53,760
and a status so the spec is the desired

00:22:52,960 --> 00:22:55,919
state

00:22:53,760 --> 00:22:57,760
that's what you provide to the cluster

00:22:55,919 --> 00:22:58,480
say this is what i want things to look

00:22:57,760 --> 00:23:00,640
like

00:22:58,480 --> 00:23:02,320
um and that's the thing that the user

00:23:00,640 --> 00:23:03,760
provides and then the status is the

00:23:02,320 --> 00:23:04,240
thing that the controller comes back

00:23:03,760 --> 00:23:07,360
with

00:23:04,240 --> 00:23:08,000
it goes talks to a remote resource and

00:23:07,360 --> 00:23:09,520
it comes back

00:23:08,000 --> 00:23:11,760
and gives to the state to it so these

00:23:09,520 --> 00:23:15,039
are two of the important concepts about

00:23:11,760 --> 00:23:16,880
building out a kubernetes api crd

00:23:15,039 --> 00:23:18,400
absolutely and and one of the things

00:23:16,880 --> 00:23:20,080
that stephen pointed out there is that

00:23:18,400 --> 00:23:21,600
we have the parameters and observation

00:23:20,080 --> 00:23:23,440
and we have the spec and status

00:23:21,600 --> 00:23:25,039
you can think of it as the parameters in

00:23:23,440 --> 00:23:28,080
observation being

00:23:25,039 --> 00:23:29,760
the uh provider specific fields

00:23:28,080 --> 00:23:31,520
and they kind of roll up into the spec

00:23:29,760 --> 00:23:33,360
so we have our parameters for the

00:23:31,520 --> 00:23:34,400
provider specific in this case it's

00:23:33,360 --> 00:23:36,400
github

00:23:34,400 --> 00:23:37,679
that's rolling up into our spec here and

00:23:36,400 --> 00:23:38,960
then the status we're going to have the

00:23:37,679 --> 00:23:40,400
at provider fields

00:23:38,960 --> 00:23:42,000
and this is just a cross playing pattern

00:23:40,400 --> 00:23:44,320
we have um and then

00:23:42,000 --> 00:23:46,640
within the crossplane ecosystem we also

00:23:44,320 --> 00:23:48,640
have these embedded structs that we put

00:23:46,640 --> 00:23:50,720
put in our spec in status and that just

00:23:48,640 --> 00:23:54,080
provides some uniform fields across

00:23:50,720 --> 00:23:56,240
all um of our resource types

00:23:54,080 --> 00:23:58,720
and they're used to do things like

00:23:56,240 --> 00:24:00,960
connect to the external

00:23:58,720 --> 00:24:03,039
provider via the provider config which

00:24:00,960 --> 00:24:04,080
is another type which we can look at uh

00:24:03,039 --> 00:24:05,919
quickly here

00:24:04,080 --> 00:24:07,200
if you saw earlier when i created the

00:24:05,919 --> 00:24:10,960
team

00:24:07,200 --> 00:24:11,520
we had a list of crds including provider

00:24:10,960 --> 00:24:13,840
config

00:24:11,520 --> 00:24:15,279
and provider config usage so once again

00:24:13,840 --> 00:24:16,559
we're seeing things that steven just

00:24:15,279 --> 00:24:18,400
mentioned

00:24:16,559 --> 00:24:20,320
this is kind of a special resource in

00:24:18,400 --> 00:24:22,400
the crossplane ecosystem

00:24:20,320 --> 00:24:23,919
um it tells you how to connect to the

00:24:22,400 --> 00:24:26,159
external provider so it has

00:24:23,919 --> 00:24:27,279
some credentials method in it and once

00:24:26,159 --> 00:24:29,039
again you're seeing we have this

00:24:27,279 --> 00:24:30,960
embedded struct

00:24:29,039 --> 00:24:32,080
and these embedded types these different

00:24:30,960 --> 00:24:34,000
things that we're going to

00:24:32,080 --> 00:24:36,000
kind of have abstractions presented for

00:24:34,000 --> 00:24:38,080
us are from cross plane runtime

00:24:36,000 --> 00:24:39,600
which we'll take a look at in a minute

00:24:38,080 --> 00:24:42,880
but the provider config spec

00:24:39,600 --> 00:24:44,320
is going to include usually a kubernetes

00:24:42,880 --> 00:24:44,720
secret but you can also provide

00:24:44,320 --> 00:24:47,120
different

00:24:44,720 --> 00:24:48,240
authentication methods and the status is

00:24:47,120 --> 00:24:49,760
basically just going to show you that

00:24:48,240 --> 00:24:52,240
it's able to connect

00:24:49,760 --> 00:24:55,200
so if we look at an example of what a

00:24:52,240 --> 00:24:56,640
provider config looks like

00:24:55,200 --> 00:24:58,799
here we're using a secret to

00:24:56,640 --> 00:25:00,640
authenticate so we're creating a secret

00:24:58,799 --> 00:25:02,640
and a cross plain system

00:25:00,640 --> 00:25:04,480
namespace and then you'll see that we'd

00:25:02,640 --> 00:25:06,400
have base64 encoded

00:25:04,480 --> 00:25:07,919
credentials in this case for github you

00:25:06,400 --> 00:25:10,400
provide an api

00:25:07,919 --> 00:25:12,000
access token so we create the secret and

00:25:10,400 --> 00:25:13,440
then we reference it in the provider

00:25:12,000 --> 00:25:15,039
config

00:25:13,440 --> 00:25:16,880
and then if we go back to this first

00:25:15,039 --> 00:25:18,400
type the team type that steven was

00:25:16,880 --> 00:25:20,480
talking about

00:25:18,400 --> 00:25:22,159
and we look at this embedded type you'll

00:25:20,480 --> 00:25:22,880
see that we have a provider config

00:25:22,159 --> 00:25:26,000
reference

00:25:22,880 --> 00:25:27,840
which basically builds in the fact that

00:25:26,000 --> 00:25:29,200
we know we're going to have to reach out

00:25:27,840 --> 00:25:31,919
to an external

00:25:29,200 --> 00:25:32,480
uh credential provider for every managed

00:25:31,919 --> 00:25:36,159
resource

00:25:32,480 --> 00:25:37,440
in a cross-plane provider

00:25:36,159 --> 00:25:39,039
and one of the nice things about the

00:25:37,440 --> 00:25:40,240
provider config is that you could have

00:25:39,039 --> 00:25:41,760
multiple providers

00:25:40,240 --> 00:25:43,840
right that you could be managing

00:25:41,760 --> 00:25:45,279
multiple back-ends um even if they're

00:25:43,840 --> 00:25:46,720
same platform they could have different

00:25:45,279 --> 00:25:48,960
credentials so

00:25:46,720 --> 00:25:50,480
um you could use the same resources and

00:25:48,960 --> 00:25:52,000
apply it you know using two different

00:25:50,480 --> 00:25:53,120
accounts if you want some kind of dr or

00:25:52,000 --> 00:25:55,200
something like that so

00:25:53,120 --> 00:25:56,159
what providers do is abstract out the

00:25:55,200 --> 00:25:57,679
connections

00:25:56,159 --> 00:25:59,360
and it gives you a lot of flexibility to

00:25:57,679 --> 00:26:01,600
separate out your

00:25:59,360 --> 00:26:03,919
resources from the backend provider so

00:26:01,600 --> 00:26:06,240
it's a very nice pattern to implement

00:26:03,919 --> 00:26:07,440
absolutely and in some of the other

00:26:06,240 --> 00:26:09,679
providers where they actually have

00:26:07,440 --> 00:26:12,000
kubernetes clusters themselves

00:26:09,679 --> 00:26:13,360
will have things like use iam roles for

00:26:12,000 --> 00:26:14,880
authentication and that sort of thing

00:26:13,360 --> 00:26:16,400
which can be really useful and some of

00:26:14,880 --> 00:26:18,400
that separation of concern

00:26:16,400 --> 00:26:20,000
that steve was mentioning in github you

00:26:18,400 --> 00:26:21,279
may have two different access tokens

00:26:20,000 --> 00:26:23,520
that you want used

00:26:21,279 --> 00:26:25,120
for different organizations and that

00:26:23,520 --> 00:26:26,559
kind of separates you

00:26:25,120 --> 00:26:28,080
from you know creating something in the

00:26:26,559 --> 00:26:29,120
wrong organization or something like

00:26:28,080 --> 00:26:30,720
that

00:26:29,120 --> 00:26:32,640
but if we look at an example actually

00:26:30,720 --> 00:26:35,200
here of our team resource so this is

00:26:32,640 --> 00:26:36,880
what we created just moments ago

00:26:35,200 --> 00:26:38,640
we actually don't have a reference to

00:26:36,880 --> 00:26:40,240
provider config

00:26:38,640 --> 00:26:42,080
and that's because crossplan also

00:26:40,240 --> 00:26:42,960
provides the ability to if you create a

00:26:42,080 --> 00:26:45,520
provider config

00:26:42,960 --> 00:26:47,520
with the name default um that provider

00:26:45,520 --> 00:26:48,799
is going to go ahead and use that one if

00:26:47,520 --> 00:26:50,320
none is provided

00:26:48,799 --> 00:26:52,000
so there's little goodies like that that

00:26:50,320 --> 00:26:54,720
are kind of sprinkled throughout

00:26:52,000 --> 00:26:57,760
the cross plain runtime ecosystem that

00:26:54,720 --> 00:26:59,279
make things a little bit easier for you

00:26:57,760 --> 00:27:01,200
all right so we've gotten a good look at

00:26:59,279 --> 00:27:02,720
these different api types

00:27:01,200 --> 00:27:05,200
but you may be wondering how those

00:27:02,720 --> 00:27:07,760
translate into actual crds

00:27:05,200 --> 00:27:09,679
existing in our kubernetes cluster so a

00:27:07,760 --> 00:27:11,520
crd is a resource in itself it's a

00:27:09,679 --> 00:27:13,360
custom resource definition

00:27:11,520 --> 00:27:15,120
and there's a controller running in

00:27:13,360 --> 00:27:16,480
kubernetes that watches for custom

00:27:15,120 --> 00:27:19,039
resource definitions

00:27:16,480 --> 00:27:20,640
and basically you're dynamically adding

00:27:19,039 --> 00:27:22,000
new api types

00:27:20,640 --> 00:27:23,760
so we have to create those custom

00:27:22,000 --> 00:27:24,640
resource definitions to then be able to

00:27:23,760 --> 00:27:27,840
create something

00:27:24,640 --> 00:27:29,760
like a team we have those custom

00:27:27,840 --> 00:27:31,120
resource definitions in this crds

00:27:29,760 --> 00:27:34,080
directory

00:27:31,120 --> 00:27:34,480
in our provider github here and you'll

00:27:34,080 --> 00:27:36,080
see

00:27:34,480 --> 00:27:37,840
that it's generated and looks like

00:27:36,080 --> 00:27:38,799
probably any other custom resource

00:27:37,840 --> 00:27:40,880
definition

00:27:38,799 --> 00:27:42,880
um that you would see you'll see that

00:27:40,880 --> 00:27:43,919
those different fields in the go struct

00:27:42,880 --> 00:27:46,640
were actually

00:27:43,919 --> 00:27:47,760
used to create this schema here that we

00:27:46,640 --> 00:27:49,600
have which allows

00:27:47,760 --> 00:27:50,880
us to have validation when we create

00:27:49,600 --> 00:27:53,520
instances

00:27:50,880 --> 00:27:54,159
of our team resource and we'll look a

00:27:53,520 --> 00:27:56,720
little bit

00:27:54,159 --> 00:27:58,159
more at that down the road but stephen

00:27:56,720 --> 00:27:59,200
did you want to talk a little bit about

00:27:58,159 --> 00:28:01,039
what some of these

00:27:59,200 --> 00:28:02,799
different annotations specifically the

00:28:01,039 --> 00:28:06,080
cube builder ones do for us

00:28:02,799 --> 00:28:07,679
in that generation process yeah if you

00:28:06,080 --> 00:28:09,200
look in the code before and this is a

00:28:07,679 --> 00:28:10,559
feature of q builder you can see here

00:28:09,200 --> 00:28:12,559
that there's

00:28:10,559 --> 00:28:14,559
there's validation fields in cue builder

00:28:12,559 --> 00:28:16,720
there's print columns there's

00:28:14,559 --> 00:28:18,880
objects so basically uh we're building

00:28:16,720 --> 00:28:20,799
upon a lot of the cube builder project

00:28:18,880 --> 00:28:23,760
here and what it does is you give these

00:28:20,799 --> 00:28:24,320
um annotations here and this instructs

00:28:23,760 --> 00:28:26,480
when you

00:28:24,320 --> 00:28:28,880
uh build out your crds exactly how to

00:28:26,480 --> 00:28:30,960
represent them so there's lots of things

00:28:28,880 --> 00:28:33,200
as we said you know it has uh recent

00:28:30,960 --> 00:28:34,000
versions of kubernetes with the crds are

00:28:33,200 --> 00:28:36,640
imposing

00:28:34,000 --> 00:28:38,000
uh open api validation on everything

00:28:36,640 --> 00:28:39,279
which suddenly means that

00:28:38,000 --> 00:28:41,279
now that you build this out suddenly you

00:28:39,279 --> 00:28:42,799
have validation not only at the server

00:28:41,279 --> 00:28:44,000
level but newer versions of kubernetes

00:28:42,799 --> 00:28:46,240
actually have the client doing

00:28:44,000 --> 00:28:47,600
validation now too so basically all that

00:28:46,240 --> 00:28:49,039
work is going to be handled for you and

00:28:47,600 --> 00:28:49,600
all the tooling we can automatically

00:28:49,039 --> 00:28:51,760
validate

00:28:49,600 --> 00:28:53,520
from these crds so that's something very

00:28:51,760 --> 00:28:55,200
powerful um

00:28:53,520 --> 00:28:56,799
yeah and that's basically it i think dan

00:28:55,200 --> 00:28:58,960
can show some code about how

00:28:56,799 --> 00:29:00,080
the there's when you run make and a lot

00:28:58,960 --> 00:29:01,679
of these clusters

00:29:00,080 --> 00:29:03,679
there's actually some hints of how to

00:29:01,679 --> 00:29:05,440
generate it um and

00:29:03,679 --> 00:29:07,360
we'll look right here at this controller

00:29:05,440 --> 00:29:09,200
gen and angry jet

00:29:07,360 --> 00:29:10,880
um and maybe we could show how to make

00:29:09,200 --> 00:29:13,520
and generate the crds

00:29:10,880 --> 00:29:14,960
yeah absolutely um so as steven pointed

00:29:13,520 --> 00:29:15,679
out there are some commands kind of

00:29:14,960 --> 00:29:17,520
built in

00:29:15,679 --> 00:29:18,960
uh this is probably an opportune time to

00:29:17,520 --> 00:29:20,720
mention that this

00:29:18,960 --> 00:29:22,480
uh entire repository right here and you

00:29:20,720 --> 00:29:26,399
can kind of still see my

00:29:22,480 --> 00:29:28,480
uh get diffs here um is generated from

00:29:26,399 --> 00:29:31,679
a project that we have in crossplane

00:29:28,480 --> 00:29:35,360
called the provider template

00:29:31,679 --> 00:29:38,720
so i'll go over to that real quickly and

00:29:35,360 --> 00:29:40,480
it basically has a mock provider

00:29:38,720 --> 00:29:41,760
for you here that you can just refactor

00:29:40,480 --> 00:29:43,919
for your own purposes

00:29:41,760 --> 00:29:45,520
and this is a template repository so to

00:29:43,919 --> 00:29:47,120
actually create this repository that we

00:29:45,520 --> 00:29:48,960
were looking at for provider github

00:29:47,120 --> 00:29:51,120
i just went ahead and clicked use this

00:29:48,960 --> 00:29:51,919
template and created a new repository in

00:29:51,120 --> 00:29:53,360
my account

00:29:51,919 --> 00:29:55,039
and then refactored some of this

00:29:53,360 --> 00:29:57,120
provider template stuff

00:29:55,039 --> 00:29:58,720
uh to be what we wanted for github

00:29:57,120 --> 00:30:00,799
you'll see that instead of having a team

00:29:58,720 --> 00:30:03,600
resource it has this sample

00:30:00,799 --> 00:30:06,240
my type resource so it just gives you

00:30:03,600 --> 00:30:08,159
kind of a boilerplate to get started

00:30:06,240 --> 00:30:10,799
but one of the things we do in that is

00:30:08,159 --> 00:30:12,559
we provide this generation code

00:30:10,799 --> 00:30:14,000
which you'll see just has go generate

00:30:12,559 --> 00:30:15,840
statements which will basically

00:30:14,000 --> 00:30:17,039
you know run for you when you run go

00:30:15,840 --> 00:30:18,799
generate

00:30:17,039 --> 00:30:21,039
and this is a convenient way to actually

00:30:18,799 --> 00:30:21,840
pin external binaries that you need to

00:30:21,039 --> 00:30:24,240
run

00:30:21,840 --> 00:30:25,760
generation methods so controller gen is

00:30:24,240 --> 00:30:26,640
kind of the cube builder flavored

00:30:25,760 --> 00:30:28,559
generation

00:30:26,640 --> 00:30:30,960
that's creating these deep copy methods

00:30:28,559 --> 00:30:32,399
for us as well as generating the crds

00:30:30,960 --> 00:30:34,240
according to those directives that we

00:30:32,399 --> 00:30:35,600
were just pointing out there and you'll

00:30:34,240 --> 00:30:38,000
see that we provide

00:30:35,600 --> 00:30:40,320
some information to controller gen here

00:30:38,000 --> 00:30:41,520
to tell it where we'd like those crds to

00:30:40,320 --> 00:30:44,080
go

00:30:41,520 --> 00:30:44,640
angry jet is our cross plane flavor of

00:30:44,080 --> 00:30:46,480
that

00:30:44,640 --> 00:30:47,679
and that does things like generate our

00:30:46,480 --> 00:30:49,919
manage.go here

00:30:47,679 --> 00:30:50,880
our pc.go which are basically helper

00:30:49,919 --> 00:30:53,600
methods to help us

00:30:50,880 --> 00:30:54,720
interact with these different classes of

00:30:53,600 --> 00:30:56,159
resource

00:30:54,720 --> 00:30:58,000
commonly called duct types in the

00:30:56,159 --> 00:30:59,440
kubernetes ecosystem

00:30:58,000 --> 00:31:00,640
you know resources that are different

00:30:59,440 --> 00:31:02,240
but they kind of follow the same

00:31:00,640 --> 00:31:04,960
patterns which we can treat

00:31:02,240 --> 00:31:06,640
similarly to how we treat go interfaces

00:31:04,960 --> 00:31:08,240
um so this is basically just generating

00:31:06,640 --> 00:31:10,640
methods to satisfy

00:31:08,240 --> 00:31:12,080
those interfaces so once we have these

00:31:10,640 --> 00:31:14,159
api types defined

00:31:12,080 --> 00:31:16,000
next thing to do is to define how we're

00:31:14,159 --> 00:31:18,799
actually going to talk to the external

00:31:16,000 --> 00:31:19,519
provider so frequently there's going to

00:31:18,799 --> 00:31:21,600
be a

00:31:19,519 --> 00:31:23,440
sdk for whatever provider you're talking

00:31:21,600 --> 00:31:25,440
to and you can just kind of look at the

00:31:23,440 --> 00:31:29,200
go types there and how to authenticate

00:31:25,440 --> 00:31:32,559
um and follow that pattern in your

00:31:29,200 --> 00:31:34,399
controllers in plane we generally like

00:31:32,559 --> 00:31:35,519
to separate our clients and controllers

00:31:34,399 --> 00:31:37,440
into two

00:31:35,519 --> 00:31:39,440
separate directories it's a little bit

00:31:37,440 --> 00:31:41,360
trivial in this case because our client

00:31:39,440 --> 00:31:44,559
is very small for github

00:31:41,360 --> 00:31:46,480
but you'll see in many other providers

00:31:44,559 --> 00:31:47,919
that will have all of our methods for

00:31:46,480 --> 00:31:50,640
translating between these

00:31:47,919 --> 00:31:51,360
ghost trucks that we define and the api

00:31:50,640 --> 00:31:53,760
type

00:31:51,360 --> 00:31:55,600
for the external provider also in this

00:31:53,760 --> 00:31:57,440
client directory

00:31:55,600 --> 00:31:59,679
so to generate this i basically just

00:31:57,440 --> 00:32:03,039
looked at the go github repo here

00:31:59,679 --> 00:32:03,039
so we'll go ahead and open that up

00:32:04,159 --> 00:32:07,840
and here's the go doc for it and it

00:32:05,840 --> 00:32:10,320
basically gives you a convenient way

00:32:07,840 --> 00:32:11,600
to authenticate and you'll see that it

00:32:10,320 --> 00:32:14,720
just uses

00:32:11,600 --> 00:32:16,240
the general http type to be able to

00:32:14,720 --> 00:32:18,559
authenticate and you just provide your

00:32:16,240 --> 00:32:20,480
access token

00:32:18,559 --> 00:32:22,559
so we've created this new client method

00:32:20,480 --> 00:32:24,240
here which essentially just accepts an

00:32:22,559 --> 00:32:24,640
access token and it's going to give us

00:32:24,240 --> 00:32:28,480
back

00:32:24,640 --> 00:32:30,799
a a type of github client here

00:32:28,480 --> 00:32:32,240
so after we've defined how to connect to

00:32:30,799 --> 00:32:33,760
the external api

00:32:32,240 --> 00:32:35,440
we actually want to use that in a

00:32:33,760 --> 00:32:37,760
controller so

00:32:35,440 --> 00:32:39,279
importantly we saw earlier and i believe

00:32:37,760 --> 00:32:41,840
it's still running over here that our

00:32:39,279 --> 00:32:43,760
controller basically continuously runs

00:32:41,840 --> 00:32:45,600
and outputs some information and what

00:32:43,760 --> 00:32:48,880
it's doing is watching these

00:32:45,600 --> 00:32:50,240
api types that we've defined and so we

00:32:48,880 --> 00:32:52,159
have a single entry point as you

00:32:50,240 --> 00:32:53,600
generally will for a go binary

00:32:52,159 --> 00:32:55,840
so let's take a minute to look at what

00:32:53,600 --> 00:32:57,360
we're doing here an important thing to

00:32:55,840 --> 00:32:58,559
realize is we're heavily relying on

00:32:57,360 --> 00:33:00,320
controller runtime

00:32:58,559 --> 00:33:01,919
which basically gives you a general

00:33:00,320 --> 00:33:03,279
framework for running a bunch of

00:33:01,919 --> 00:33:06,240
controllers together

00:33:03,279 --> 00:33:08,000
in what they call a manager so some

00:33:06,240 --> 00:33:09,120
different options that you can supply

00:33:08,000 --> 00:33:11,120
here to the manager

00:33:09,120 --> 00:33:12,880
we're just saying the sync period so

00:33:11,120 --> 00:33:14,159
we're not configuring it too much

00:33:12,880 --> 00:33:16,559
but the important thing to note here is

00:33:14,159 --> 00:33:18,640
that we have the controller manager

00:33:16,559 --> 00:33:19,760
and then we're adding our apis to the

00:33:18,640 --> 00:33:21,200
scheme so

00:33:19,760 --> 00:33:23,679
right now that would be our provider

00:33:21,200 --> 00:33:25,279
config and our team resource

00:33:23,679 --> 00:33:26,880
and then we're doing our controller

00:33:25,279 --> 00:33:28,480
setup and then we're starting our

00:33:26,880 --> 00:33:30,159
manager which is basically going to run

00:33:28,480 --> 00:33:32,960
all these controllers anything we

00:33:30,159 --> 00:33:34,799
provide in the setup here

00:33:32,960 --> 00:33:36,159
and keep those running and watching the

00:33:34,799 --> 00:33:37,919
resources

00:33:36,159 --> 00:33:40,159
and they'll it'll be notified by the

00:33:37,919 --> 00:33:43,120
kubernetes api server when events happen

00:33:40,159 --> 00:33:45,200
on those resources

00:33:43,120 --> 00:33:46,880
so the setup method this is just kind of

00:33:45,200 --> 00:33:48,159
a wrapper around some other setup

00:33:46,880 --> 00:33:50,559
methods

00:33:48,159 --> 00:33:52,080
and what it's doing is actually setting

00:33:50,559 --> 00:33:53,360
up these controllers and registering

00:33:52,080 --> 00:33:54,799
them with the manager

00:33:53,360 --> 00:33:56,399
so we're not going to look too much at

00:33:54,799 --> 00:33:58,559
the config setup today which basically

00:33:56,399 --> 00:34:00,000
just watches provider configs and takes

00:33:58,559 --> 00:34:02,240
some actions based on that

00:34:00,000 --> 00:34:03,600
essentially confirming that they're not

00:34:02,240 --> 00:34:04,960
in use when they're cleaned up

00:34:03,600 --> 00:34:06,559
because if you lost connection while

00:34:04,960 --> 00:34:08,399
you're still trying to reconcile a

00:34:06,559 --> 00:34:10,560
managed resource type like the team

00:34:08,399 --> 00:34:12,560
that would obviously be a bad experience

00:34:10,560 --> 00:34:13,760
we're primarily going to look at our org

00:34:12,560 --> 00:34:15,679
setup method here

00:34:13,760 --> 00:34:16,960
which is for our team and this is going

00:34:15,679 --> 00:34:20,320
to take us into

00:34:16,960 --> 00:34:22,800
our controller directory

00:34:20,320 --> 00:34:23,839
so in the setup method you'll frequently

00:34:22,800 --> 00:34:25,679
see

00:34:23,839 --> 00:34:27,919
in a queue builder project that someone

00:34:25,679 --> 00:34:30,079
has defined a reconciler

00:34:27,919 --> 00:34:31,359
and they're basically populating it with

00:34:30,079 --> 00:34:32,480
whatever fields they need

00:34:31,359 --> 00:34:34,639
and then they're doing this new

00:34:32,480 --> 00:34:36,800
controller managed by and specifying the

00:34:34,639 --> 00:34:39,599
resource they want to watch

00:34:36,800 --> 00:34:42,399
instead here we have a call to this

00:34:39,599 --> 00:34:44,399
manage.new reconciler method

00:34:42,399 --> 00:34:46,079
so when i talked earlier about these

00:34:44,399 --> 00:34:48,240
different methods that were generated

00:34:46,079 --> 00:34:48,560
for our managed resource types which are

00:34:48,240 --> 00:34:50,000
just

00:34:48,560 --> 00:34:51,679
all of our types that represent an

00:34:50,000 --> 00:34:53,599
external api

00:34:51,679 --> 00:34:55,599
having those methods allows us to use a

00:34:53,599 --> 00:34:58,079
generic manage reconciler

00:34:55,599 --> 00:34:59,599
which basically takes care of talking to

00:34:58,079 --> 00:35:00,640
the kubernetes components of your

00:34:59,599 --> 00:35:02,880
controller

00:35:00,640 --> 00:35:04,800
so obviously when a resource gets

00:35:02,880 --> 00:35:05,599
created you want to take action based on

00:35:04,800 --> 00:35:07,280
that

00:35:05,599 --> 00:35:09,680
and you may want to call different

00:35:07,280 --> 00:35:12,400
external methods based on the status

00:35:09,680 --> 00:35:13,359
of your or really the specification of

00:35:12,400 --> 00:35:15,119
your resource

00:35:13,359 --> 00:35:17,280
in your kubernetes cluster and then

00:35:15,119 --> 00:35:20,560
manage reconciler

00:35:17,280 --> 00:35:21,760
takes care of a lot of that for you so

00:35:20,560 --> 00:35:23,599
steven i know you have a lot of

00:35:21,760 --> 00:35:25,520
experience with writing kubernetes

00:35:23,599 --> 00:35:27,599
controllers

00:35:25,520 --> 00:35:29,680
we'll look especially into the different

00:35:27,599 --> 00:35:31,839
implementations of the different methods

00:35:29,680 --> 00:35:33,440
that uh are part of the manage

00:35:31,839 --> 00:35:34,079
reconciler that we define in cross plane

00:35:33,440 --> 00:35:35,440
runtime

00:35:34,079 --> 00:35:37,119
but you wanna do you wanna talk in

00:35:35,440 --> 00:35:38,079
general a little bit more about the

00:35:37,119 --> 00:35:40,079
difference between

00:35:38,079 --> 00:35:42,839
a generic kubernetes reconciler and

00:35:40,079 --> 00:35:44,000
maybe a managed resource reconciler in

00:35:42,839 --> 00:35:45,599
crossplane

00:35:44,000 --> 00:35:46,880
yeah actually one of the things that

00:35:45,599 --> 00:35:48,160
really attracted me to cross play in the

00:35:46,880 --> 00:35:49,280
beginning was that

00:35:48,160 --> 00:35:50,880
if you've ever written a controller

00:35:49,280 --> 00:35:51,599
yourself there's a lot of manual things

00:35:50,880 --> 00:35:55,200
you have to do

00:35:51,599 --> 00:35:58,240
in terms of reconciliation um logging

00:35:55,200 --> 00:36:00,240
creating events you know having written

00:35:58,240 --> 00:36:01,760
a lot of infrastructure software

00:36:00,240 --> 00:36:03,359
you kind of repeat the same patterns

00:36:01,760 --> 00:36:04,720
over and over again and actually as we

00:36:03,359 --> 00:36:06,240
walk through this we'll find out

00:36:04,720 --> 00:36:07,839
that there's a very structured way that

00:36:06,240 --> 00:36:08,160
crossplaying does it that layers on top

00:36:07,839 --> 00:36:09,680
of

00:36:08,160 --> 00:36:11,440
kubernetes controllers that makes it

00:36:09,680 --> 00:36:13,920
very easy um

00:36:11,440 --> 00:36:15,200
you know to understand the logic so i

00:36:13,920 --> 00:36:16,320
think that's good and the most important

00:36:15,200 --> 00:36:17,680
thing to understand is that this

00:36:16,320 --> 00:36:19,359
controller is basically

00:36:17,680 --> 00:36:20,720
a piece of software that's going to run

00:36:19,359 --> 00:36:23,680
in your cluster

00:36:20,720 --> 00:36:24,960
that when we look at that setup it

00:36:23,680 --> 00:36:27,280
basically

00:36:24,960 --> 00:36:28,160
um when you bring it up it registers and

00:36:27,280 --> 00:36:29,680
says

00:36:28,160 --> 00:36:31,359
i want to listen to anything that

00:36:29,680 --> 00:36:33,119
defines a team

00:36:31,359 --> 00:36:34,640
right that's what the setup does right

00:36:33,119 --> 00:36:35,359
here you know that's the most important

00:36:34,640 --> 00:36:36,960
thing because

00:36:35,359 --> 00:36:38,640
when you first look at this there's like

00:36:36,960 --> 00:36:40,160
15 different concepts that you have to

00:36:38,640 --> 00:36:41,520
understand the most important thing to

00:36:40,160 --> 00:36:43,119
understand is that

00:36:41,520 --> 00:36:45,359
you want to you see if you look at line

00:36:43,119 --> 00:36:47,440
55 you're looking

00:36:45,359 --> 00:36:49,280
and you'll see this group version kind

00:36:47,440 --> 00:36:50,000
here this is pretty common in kubernetes

00:36:49,280 --> 00:36:51,920
this is the

00:36:50,000 --> 00:36:54,000
you also see it like gvk in some of the

00:36:51,920 --> 00:36:56,640
source code and this is basically

00:36:54,000 --> 00:36:58,000
like a kind would be the team um you

00:36:56,640 --> 00:36:59,599
know the version would be

00:36:58,000 --> 00:37:01,040
um you know the group would be it would

00:36:59,599 --> 00:37:04,320
be a combination of

00:37:01,040 --> 00:37:07,760
you know hashtan you know github io

00:37:04,320 --> 00:37:12,160
and the version which is the api version

00:37:07,760 --> 00:37:13,680
yeah so you'll see this a lot

00:37:12,160 --> 00:37:15,200
yeah you'll see these terms you'll see

00:37:13,680 --> 00:37:16,320
these a lot in kubernetes i remember the

00:37:15,200 --> 00:37:18,240
first time i did

00:37:16,320 --> 00:37:20,320
like when i was playing with um

00:37:18,240 --> 00:37:23,200
customize that it kept giving me gvk

00:37:20,320 --> 00:37:25,760
errors and i had no idea what those were

00:37:23,200 --> 00:37:26,880
so to save you some pain that's this is

00:37:25,760 --> 00:37:29,200
what it comes from here

00:37:26,880 --> 00:37:30,880
um yeah so that's basically it this is

00:37:29,200 --> 00:37:32,079
the core of this setup there's a lot of

00:37:30,880 --> 00:37:33,599
things that have to be called here but

00:37:32,079 --> 00:37:36,079
if you look at it it says

00:37:33,599 --> 00:37:37,599
we're going to reconcile teams with an

00:37:36,079 --> 00:37:39,839
external connector which means

00:37:37,599 --> 00:37:41,119
we're gonna connect to the github api

00:37:39,839 --> 00:37:42,480
and then you say with logger and

00:37:41,119 --> 00:37:44,480
recorder and these are nice

00:37:42,480 --> 00:37:46,800
fields because basically this sets up

00:37:44,480 --> 00:37:48,800
all your logging and events

00:37:46,800 --> 00:37:50,240
yeah and that's basically yeah so

00:37:48,800 --> 00:37:51,839
there's a lot here but that's basically

00:37:50,240 --> 00:37:53,040
what this part is doing you know you're

00:37:51,839 --> 00:37:54,320
saying i want to subscribe to these

00:37:53,040 --> 00:37:57,280
events and then i'm going to use

00:37:54,320 --> 00:37:58,720
this external api to manage it and i

00:37:57,280 --> 00:37:59,760
like these different methods that we

00:37:58,720 --> 00:38:02,720
have here these with

00:37:59,760 --> 00:38:04,560
methods uh which are basically saying um

00:38:02,720 --> 00:38:06,480
i'd like to provide this kind of like

00:38:04,560 --> 00:38:08,800
customized option for this thing

00:38:06,480 --> 00:38:10,160
but if we actually look over to the new

00:38:08,800 --> 00:38:11,920
reconciler code here

00:38:10,160 --> 00:38:13,599
there's a lot of sane defaults that we

00:38:11,920 --> 00:38:15,119
provide for you

00:38:13,599 --> 00:38:17,599
one of those being things like

00:38:15,119 --> 00:38:19,440
defaulting to that provider config

00:38:17,599 --> 00:38:21,520
that has the default name if one is not

00:38:19,440 --> 00:38:24,800
specified so we have a lot of different

00:38:21,520 --> 00:38:26,480
hooks to customize this behavior um and

00:38:24,800 --> 00:38:27,280
if we scroll down here a bit this is

00:38:26,480 --> 00:38:29,119
actually the

00:38:27,280 --> 00:38:30,880
the reconciler that you'd see a little

00:38:29,119 --> 00:38:33,440
more traditionally

00:38:30,880 --> 00:38:34,240
in a q builder controller or something

00:38:33,440 --> 00:38:36,160
like that

00:38:34,240 --> 00:38:37,760
you'll see we have some default fields

00:38:36,160 --> 00:38:39,280
here things like setting

00:38:37,760 --> 00:38:40,320
finalizer which you don't have to worry

00:38:39,280 --> 00:38:41,680
about at all when you're writing a

00:38:40,320 --> 00:38:42,480
crossplane controller because we'll take

00:38:41,680 --> 00:38:45,280
care of that

00:38:42,480 --> 00:38:46,480
you can obviously provide your own api

00:38:45,280 --> 00:38:48,480
finalizer

00:38:46,480 --> 00:38:49,920
to do that another important one that i

00:38:48,480 --> 00:38:51,520
wanted to point out here

00:38:49,920 --> 00:38:52,560
which isn't going to be relevant for us

00:38:51,520 --> 00:38:53,200
today because there's not really

00:38:52,560 --> 00:38:55,599
connection

00:38:53,200 --> 00:38:57,119
information for a github team but if

00:38:55,599 --> 00:38:58,640
you're provisioning a database or

00:38:57,119 --> 00:38:59,040
kubernetes cluster or something like

00:38:58,640 --> 00:39:00,560
that

00:38:59,040 --> 00:39:02,480
there's some connection information that

00:39:00,560 --> 00:39:04,560
you want to get back into your cluster

00:39:02,480 --> 00:39:07,040
so you can reach out and communicate

00:39:04,560 --> 00:39:09,839
with that resource you've provisioned

00:39:07,040 --> 00:39:10,560
so we have a default api secret

00:39:09,839 --> 00:39:13,119
publisher

00:39:10,560 --> 00:39:14,079
which is going to publish those secrets

00:39:13,119 --> 00:39:15,920
into the kubernetes

00:39:14,079 --> 00:39:17,599
api and then you know you can run a

00:39:15,920 --> 00:39:19,040
deployment that consumes that either

00:39:17,599 --> 00:39:22,240
through an environment variable

00:39:19,040 --> 00:39:24,720
or by getting that resource directly

00:39:22,240 --> 00:39:26,240
or you could say i'd like to provide my

00:39:24,720 --> 00:39:28,160
own secret publisher

00:39:26,240 --> 00:39:30,320
which is going to you know send these

00:39:28,160 --> 00:39:31,839
secrets to vault or something like that

00:39:30,320 --> 00:39:32,960
um so you can override any of this

00:39:31,839 --> 00:39:34,720
behavior but you're going to get a

00:39:32,960 --> 00:39:36,400
really good working controller

00:39:34,720 --> 00:39:38,240
just by using the defaults here and then

00:39:36,400 --> 00:39:39,680
you can iterate on that so it's kind of

00:39:38,240 --> 00:39:42,560
zero to working controller

00:39:39,680 --> 00:39:44,160
as fast as possible yeah and the secret

00:39:42,560 --> 00:39:44,800
propagation is really a great feature

00:39:44,160 --> 00:39:46,800
because

00:39:44,800 --> 00:39:48,160
it's very underrated like when you

00:39:46,800 --> 00:39:49,200
deploy a new system and you get some

00:39:48,160 --> 00:39:50,960
credentials back

00:39:49,200 --> 00:39:52,720
how do you actually get that back to the

00:39:50,960 --> 00:39:54,800
user who requested you know like you

00:39:52,720 --> 00:39:55,839
give them a database and they're like

00:39:54,800 --> 00:39:57,440
well now i'd like to have the

00:39:55,839 --> 00:39:59,119
credentials and then usually somebody

00:39:57,440 --> 00:40:00,640
has to go log in somewhere and generate

00:39:59,119 --> 00:40:02,480
them or

00:40:00,640 --> 00:40:04,720
hook up you know some external systems

00:40:02,480 --> 00:40:06,800
so it's really a nice feature to have

00:40:04,720 --> 00:40:08,240
absolutely and you'll see here this is

00:40:06,800 --> 00:40:10,079
the new reconciler

00:40:08,240 --> 00:40:11,760
method that we're running um and we're

00:40:10,079 --> 00:40:13,680
passing in that controller manager and

00:40:11,760 --> 00:40:15,839
then our manage kind so that just maps

00:40:13,680 --> 00:40:18,240
directly to what we're looking at here

00:40:15,839 --> 00:40:19,839
our controller manager and our manage

00:40:18,240 --> 00:40:22,079
kind

00:40:19,839 --> 00:40:23,520
and this is yeah and an important thing

00:40:22,079 --> 00:40:25,680
about reconcile here and dan

00:40:23,520 --> 00:40:26,960
referred to it um slightly is that if

00:40:25,680 --> 00:40:28,400
you look at a classic

00:40:26,960 --> 00:40:30,000
you know kubernetes controller they

00:40:28,400 --> 00:40:31,839
usually have a pretty

00:40:30,000 --> 00:40:34,079
light reconciler and then expect you to

00:40:31,839 --> 00:40:36,400
put all the logic in there and there's

00:40:34,079 --> 00:40:37,839
a lot of corner cases and logic that you

00:40:36,400 --> 00:40:39,440
need to think about when writing your

00:40:37,839 --> 00:40:41,280
own reconciler

00:40:39,440 --> 00:40:43,280
especially for like infrastructure tasks

00:40:41,280 --> 00:40:44,079
so this actually makes it a lot easier

00:40:43,280 --> 00:40:46,160
to go through

00:40:44,079 --> 00:40:48,880
the common patterns of managing and

00:40:46,160 --> 00:40:51,599
provisioning infrastructure so

00:40:48,880 --> 00:40:52,240
the reconciler is actually very powerful

00:40:51,599 --> 00:40:54,400
definitely

00:40:52,240 --> 00:40:55,920
and if you want to dive into some of the

00:40:54,400 --> 00:40:57,440
actual work that's happening here in the

00:40:55,920 --> 00:40:57,839
reconcile loop which we're going to get

00:40:57,440 --> 00:41:00,000
into

00:40:57,839 --> 00:41:01,839
a little bit more in a moment but this

00:41:00,000 --> 00:41:03,760
is your generic reconcile loop that the

00:41:01,839 --> 00:41:05,599
controller manager is going to say

00:41:03,760 --> 00:41:07,119
okay this thing has registered for

00:41:05,599 --> 00:41:09,040
events that happen on teams

00:41:07,119 --> 00:41:10,319
every time i send an event i need to run

00:41:09,040 --> 00:41:12,400
this reconcile loop

00:41:10,319 --> 00:41:13,760
um so that's what's actually getting

00:41:12,400 --> 00:41:15,599
called and we're just basically

00:41:13,760 --> 00:41:18,720
configuring this reconcile loop

00:41:15,599 --> 00:41:18,720
in our controller

00:41:19,119 --> 00:41:22,480
so steven alluded to this a bit earlier

00:41:21,440 --> 00:41:24,240
but there's two

00:41:22,480 --> 00:41:25,839
main kind of types that you need to

00:41:24,240 --> 00:41:28,640
satisfy to be

00:41:25,839 --> 00:41:30,240
able to run a manage reconciler the

00:41:28,640 --> 00:41:32,640
first being the connector

00:41:30,240 --> 00:41:35,119
and the second being the external the

00:41:32,640 --> 00:41:37,280
connector basically has a single method

00:41:35,119 --> 00:41:39,839
which just is connect and this is

00:41:37,280 --> 00:41:41,440
telling me how do i get this external

00:41:39,839 --> 00:41:42,720
struct which has our crud

00:41:41,440 --> 00:41:44,800
methods on it that are going to be

00:41:42,720 --> 00:41:46,800
called by our manage reconciler

00:41:44,800 --> 00:41:48,240
and then the external obviously is

00:41:46,800 --> 00:41:50,319
what's returned by the kinect

00:41:48,240 --> 00:41:52,240
and has all those methods defined on it

00:41:50,319 --> 00:41:54,000
so before we get into external which is

00:41:52,240 --> 00:41:56,480
kind of the meat of how we talk

00:41:54,000 --> 00:41:58,720
to the external provider let's look a

00:41:56,480 --> 00:42:00,400
little bit about the connect method

00:41:58,720 --> 00:42:02,720
so we've already eluded a little bit

00:42:00,400 --> 00:42:04,640
when looking at the api types

00:42:02,720 --> 00:42:06,240
to the fact that we use this provider

00:42:04,640 --> 00:42:08,240
config to

00:42:06,240 --> 00:42:09,599
get credentials to talk to an external

00:42:08,240 --> 00:42:11,359
api

00:42:09,599 --> 00:42:13,440
so you'll see that we have our provider

00:42:11,359 --> 00:42:15,359
config type here so this is referencing

00:42:13,440 --> 00:42:16,560
our apis directory that stephen

00:42:15,359 --> 00:42:18,880
mentioned earlier

00:42:16,560 --> 00:42:21,440
and we're basically using our kubernetes

00:42:18,880 --> 00:42:22,160
client to be able to get that provider

00:42:21,440 --> 00:42:24,960
config

00:42:22,160 --> 00:42:26,319
so as i mentioned every manage resource

00:42:24,960 --> 00:42:29,119
has a provider config

00:42:26,319 --> 00:42:30,880
ref and we're using that here in the

00:42:29,119 --> 00:42:31,599
example we were showing that provider

00:42:30,880 --> 00:42:34,720
config ref

00:42:31,599 --> 00:42:36,400
is being set by default for us um so

00:42:34,720 --> 00:42:37,760
this would use name default

00:42:36,400 --> 00:42:39,599
and i had already created a provider

00:42:37,760 --> 00:42:42,079
config in that last example

00:42:39,599 --> 00:42:44,079
once it gets this provider config it's

00:42:42,079 --> 00:42:47,200
going to look at the secret reference

00:42:44,079 --> 00:42:48,720
on the provider config which if i can go

00:42:47,200 --> 00:42:50,400
back to an example here

00:42:48,720 --> 00:42:52,960
it's basically looking at this part of

00:42:50,400 --> 00:42:52,960
the struct

00:42:53,599 --> 00:42:59,440
and it's going to then get that secret

00:42:57,520 --> 00:43:02,240
from the kubernetes api

00:42:59,440 --> 00:43:03,599
our secret has our api token on it and

00:43:02,240 --> 00:43:05,040
this is a byte slice here that we're

00:43:03,599 --> 00:43:07,040
converting to a string

00:43:05,040 --> 00:43:08,160
and we're passing that to the new client

00:43:07,040 --> 00:43:11,359
method

00:43:08,160 --> 00:43:12,160
that we defined earlier that basically

00:43:11,359 --> 00:43:14,720
takes the string

00:43:12,160 --> 00:43:16,240
and gives us a github client in return

00:43:14,720 --> 00:43:17,680
one of the benefits of kind of moving

00:43:16,240 --> 00:43:19,599
some of this client

00:43:17,680 --> 00:43:21,200
logic which like i said is admittedly

00:43:19,599 --> 00:43:24,640
very small here out of

00:43:21,200 --> 00:43:26,400
our controller body is that

00:43:24,640 --> 00:43:28,079
it allows when you have many many

00:43:26,400 --> 00:43:30,720
controllers to not have to duplicate

00:43:28,079 --> 00:43:32,400
all that code um so basically we're just

00:43:30,720 --> 00:43:33,839
going to return from our connect method

00:43:32,400 --> 00:43:35,760
our external struct

00:43:33,839 --> 00:43:39,040
populated with our github client which

00:43:35,760 --> 00:43:39,040
is now authenticated

00:43:39,599 --> 00:43:44,240
so now's the the real kind of meat of

00:43:42,640 --> 00:43:45,599
what we're doing when we talk to the

00:43:44,240 --> 00:43:47,599
external api

00:43:45,599 --> 00:43:48,880
and that's our crud methods so we have

00:43:47,599 --> 00:43:51,280
observe

00:43:48,880 --> 00:43:52,319
create update and delete so i guess it's

00:43:51,280 --> 00:43:55,440
not really

00:43:52,319 --> 00:43:57,760
crud because we're using observe instead

00:43:55,440 --> 00:43:58,560
um yeah but they they basically get

00:43:57,760 --> 00:44:00,079
called in

00:43:58,560 --> 00:44:02,079
fairly sequential order that you'd

00:44:00,079 --> 00:44:04,240
imagine um and so

00:44:02,079 --> 00:44:07,599
when we return this external struct the

00:44:04,240 --> 00:44:09,839
manage reconciler is gonna say okay

00:44:07,599 --> 00:44:11,040
i see that you connected successfully

00:44:09,839 --> 00:44:13,599
and now i have this

00:44:11,040 --> 00:44:15,200
external type and i'm going to call

00:44:13,599 --> 00:44:17,040
these in a logical order

00:44:15,200 --> 00:44:18,640
so the first thing we're going to do is

00:44:17,040 --> 00:44:20,800
observe the resource

00:44:18,640 --> 00:44:22,960
and based on the result we get back from

00:44:20,800 --> 00:44:25,119
that we're going to take further action

00:44:22,960 --> 00:44:26,400
so if the resource was deleted in the

00:44:25,119 --> 00:44:27,920
kubernetes api

00:44:26,400 --> 00:44:30,000
then we're going to call the delete

00:44:27,920 --> 00:44:32,640
method on the external that was

00:44:30,000 --> 00:44:35,599
returned and we'll skip over some of

00:44:32,640 --> 00:44:37,680
this other logic for a moment

00:44:35,599 --> 00:44:39,280
if the resource does not exist so if we

00:44:37,680 --> 00:44:40,640
observed and said hey i couldn't find

00:44:39,280 --> 00:44:42,400
this in the external api

00:44:40,640 --> 00:44:46,400
we're going to call the external create

00:44:42,400 --> 00:44:47,760
method and do some operations

00:44:46,400 --> 00:44:50,319
and then the last thing that we're going

00:44:47,760 --> 00:44:52,079
to look at is is the resource up to date

00:44:50,319 --> 00:44:53,839
so if the observation says hey this

00:44:52,079 --> 00:44:55,280
resource exists but it doesn't match

00:44:53,839 --> 00:44:57,119
that spec that we were talking about

00:44:55,280 --> 00:44:58,240
earlier which is our desired state of

00:44:57,119 --> 00:45:01,040
the resource

00:44:58,240 --> 00:45:01,680
then we need to issue an update and it's

00:45:01,040 --> 00:45:04,400
going to call that

00:45:01,680 --> 00:45:05,760
update method that that you supplied so

00:45:04,400 --> 00:45:09,040
you saw that we skipped over

00:45:05,760 --> 00:45:11,440
quite a lot of the um other things that

00:45:09,040 --> 00:45:12,960
are happening throughout this reconciler

00:45:11,440 --> 00:45:14,319
and that's kind of the benefit right you

00:45:12,960 --> 00:45:15,839
don't have to worry about these until

00:45:14,319 --> 00:45:18,160
you get later down the line and maybe

00:45:15,839 --> 00:45:19,280
want some custom behavior and they're

00:45:18,160 --> 00:45:21,040
doing things like

00:45:19,280 --> 00:45:22,640
publishing the connection or cleaning up

00:45:21,040 --> 00:45:25,440
the connection secret

00:45:22,640 --> 00:45:28,560
um or doing things like initializing the

00:45:25,440 --> 00:45:30,400
resource and populating fields that

00:45:28,560 --> 00:45:32,400
you know are set by the external

00:45:30,400 --> 00:45:33,920
provider or updating the status of the

00:45:32,400 --> 00:45:34,640
resource like showing us that it's

00:45:33,920 --> 00:45:36,160
synced

00:45:34,640 --> 00:45:38,640
which we showed earlier when we were

00:45:36,160 --> 00:45:38,640
demoing

00:45:40,240 --> 00:45:44,240
all right so what do we actually put in

00:45:42,720 --> 00:45:45,359
these different methods that we were

00:45:44,240 --> 00:45:47,280
talking about

00:45:45,359 --> 00:45:49,760
so the first thing is our observe method

00:45:47,280 --> 00:45:52,240
here and we've defined our github client

00:45:49,760 --> 00:45:53,920
which has a team service which has all

00:45:52,240 --> 00:45:55,599
the different methods

00:45:53,920 --> 00:45:57,680
that we're going to want to call so

00:45:55,599 --> 00:45:59,599
within our observed method since we've

00:45:57,680 --> 00:46:00,800
embedded this github client in our

00:45:59,599 --> 00:46:03,040
external struct

00:46:00,800 --> 00:46:04,720
we're able to call any of these methods

00:46:03,040 --> 00:46:07,280
that we want

00:46:04,720 --> 00:46:08,480
so you'll always want to make sure that

00:46:07,280 --> 00:46:11,119
you have the information

00:46:08,480 --> 00:46:12,160
necessary to make all of the api

00:46:11,119 --> 00:46:14,480
operations

00:46:12,160 --> 00:46:16,800
that you're going to do present on the

00:46:14,480 --> 00:46:19,200
api type that you've defined

00:46:16,800 --> 00:46:20,480
so here we're going to get our team from

00:46:19,200 --> 00:46:22,000
the api

00:46:20,480 --> 00:46:24,480
so you'll see that we're providing that

00:46:22,000 --> 00:46:26,480
org and the name of the resource which

00:46:24,480 --> 00:46:28,720
we want to also represent the name of

00:46:26,480 --> 00:46:30,960
the team on github

00:46:28,720 --> 00:46:32,079
and if we get an error back from the

00:46:30,960 --> 00:46:34,079
github api

00:46:32,079 --> 00:46:35,119
we're going to go ahead and say we're

00:46:34,079 --> 00:46:36,400
going to go ahead and return our

00:46:35,119 --> 00:46:38,319
external observation

00:46:36,400 --> 00:46:40,000
which is that struct type that the

00:46:38,319 --> 00:46:41,599
manage reconciler is going to check

00:46:40,000 --> 00:46:43,440
and you'll see it has these three fields

00:46:41,599 --> 00:46:45,119
here resource exists

00:46:43,440 --> 00:46:47,280
resource up to date and connection

00:46:45,119 --> 00:46:47,920
details they do pretty much exactly what

00:46:47,280 --> 00:46:50,160
you think

00:46:47,920 --> 00:46:51,520
if the resource exists is false then

00:46:50,160 --> 00:46:53,280
it's going to call the create method

00:46:51,520 --> 00:46:54,560
if the resource up to date is false it's

00:46:53,280 --> 00:46:56,800
going to call the update method

00:46:54,560 --> 00:46:58,480
if connection details are populated then

00:46:56,800 --> 00:47:00,960
it's going to create a connection secret

00:46:58,480 --> 00:47:02,960
with those details

00:47:00,960 --> 00:47:05,440
so here we're saying it doesn't exist so

00:47:02,960 --> 00:47:06,960
we need to actually create it

00:47:05,440 --> 00:47:08,720
so let's go ahead and follow this branch

00:47:06,960 --> 00:47:10,720
a little more before we continue down

00:47:08,720 --> 00:47:13,280
the observe method

00:47:10,720 --> 00:47:14,640
so eventually the manage reconciler is

00:47:13,280 --> 00:47:15,920
going to get to the create method and

00:47:14,640 --> 00:47:18,079
say i need to call this because the

00:47:15,920 --> 00:47:19,599
resource doesn't exist yet

00:47:18,079 --> 00:47:21,520
and you'll see that we're once again

00:47:19,599 --> 00:47:22,160
using this team service from the github

00:47:21,520 --> 00:47:23,680
client

00:47:22,160 --> 00:47:25,760
to create our team with the

00:47:23,680 --> 00:47:29,599
configuration that we've defined

00:47:25,760 --> 00:47:30,640
in our api type and based on the result

00:47:29,599 --> 00:47:32,559
we get back from that

00:47:30,640 --> 00:47:34,160
we return an external creation which

00:47:32,559 --> 00:47:36,400
once again allows us to supply

00:47:34,160 --> 00:47:37,440
additional connection details if needed

00:47:36,400 --> 00:47:39,280
and we also return an

00:47:37,440 --> 00:47:40,480
error so if the manage reconciler gets

00:47:39,280 --> 00:47:42,160
an error back it's going to say

00:47:40,480 --> 00:47:43,520
okay i see that i tried to create this

00:47:42,160 --> 00:47:44,880
resource but it didn't work

00:47:43,520 --> 00:47:47,200
so i'm going to try again in a little

00:47:44,880 --> 00:47:48,720
bit and some of this timing

00:47:47,200 --> 00:47:50,720
and the delays that happens between

00:47:48,720 --> 00:47:52,559
reconciles those are also defaults that

00:47:50,720 --> 00:47:54,640
we set that seem to be

00:47:52,559 --> 00:47:57,359
common accepted patterns for the managed

00:47:54,640 --> 00:47:59,119
resources that crossplane provides

00:47:57,359 --> 00:48:00,559
but you can also override those just

00:47:59,119 --> 00:48:01,680
like any of the others with providing

00:48:00,559 --> 00:48:04,559
your default weight

00:48:01,680 --> 00:48:04,559
and that sort of thing

00:48:04,800 --> 00:48:07,680
and i want to comment something here

00:48:06,319 --> 00:48:08,800
this pattern here because usually when

00:48:07,680 --> 00:48:09,599
you write a lot of infrastructure

00:48:08,800 --> 00:48:11,520
software you

00:48:09,599 --> 00:48:13,280
usually have like if then statements

00:48:11,520 --> 00:48:15,280
here when you're comparing things

00:48:13,280 --> 00:48:16,960
um one of the nice things about this is

00:48:15,280 --> 00:48:18,000
that this returns immediately and puts

00:48:16,960 --> 00:48:19,760
it in the reconcile loop

00:48:18,000 --> 00:48:21,599
there's times if you're provisioning

00:48:19,760 --> 00:48:24,000
things like vms it might take

00:48:21,599 --> 00:48:25,200
you know 20 30 60 minutes to do

00:48:24,000 --> 00:48:26,800
something um

00:48:25,200 --> 00:48:28,640
this you could actually keep observing

00:48:26,800 --> 00:48:30,400
it you know and come back with different

00:48:28,640 --> 00:48:32,000
kinds of status like um

00:48:30,400 --> 00:48:34,240
other tools will just block a lot of

00:48:32,000 --> 00:48:35,119
times and not return whereas this um

00:48:34,240 --> 00:48:36,880
usually you have this like

00:48:35,119 --> 00:48:38,319
reconciliation loop thing where it could

00:48:36,880 --> 00:48:39,520
keep just checking in the background for

00:48:38,319 --> 00:48:41,920
you so

00:48:39,520 --> 00:48:43,200
um that's very nice so this is kind of a

00:48:41,920 --> 00:48:44,720
different pattern if you've you know

00:48:43,200 --> 00:48:48,240
spent a lot of your career doing

00:48:44,720 --> 00:48:49,920
if exist then this this is a slightly

00:48:48,240 --> 00:48:51,040
different but um

00:48:49,920 --> 00:48:53,040
it makes a lot of sense once you

00:48:51,040 --> 00:48:55,040
understand how crossplane works

00:48:53,040 --> 00:48:56,480
absolutely and one of the things you

00:48:55,040 --> 00:48:57,440
mentioned there is something i really

00:48:56,480 --> 00:49:00,319
like to point out

00:48:57,440 --> 00:49:01,839
the um the packet well i guess equinix

00:49:00,319 --> 00:49:04,160
metal now provider

00:49:01,839 --> 00:49:05,680
is maintained by the the packet equinix

00:49:04,160 --> 00:49:07,599
metal team

00:49:05,680 --> 00:49:09,280
their provisioning of their bare metal

00:49:07,599 --> 00:49:11,520
instances actually has

00:49:09,280 --> 00:49:13,040
different stages of provisioning and

00:49:11,520 --> 00:49:16,079
since we have the status

00:49:13,040 --> 00:49:17,280
portion of our api types um here we have

00:49:16,079 --> 00:49:18,800
the node id

00:49:17,280 --> 00:49:20,319
which we'll show actually populating in

00:49:18,800 --> 00:49:22,480
just a moment

00:49:20,319 --> 00:49:23,760
but in that status we have i think a

00:49:22,480 --> 00:49:25,920
stage field

00:49:23,760 --> 00:49:27,760
for their bare metal device type and we

00:49:25,920 --> 00:49:29,520
update that as you were saying

00:49:27,760 --> 00:49:30,960
as it goes along so you can kind of

00:49:29,520 --> 00:49:32,400
monitor the uh

00:49:30,960 --> 00:49:34,079
you know success of your resource

00:49:32,400 --> 00:49:34,720
provisioning and it actually provides

00:49:34,079 --> 00:49:37,440
you a

00:49:34,720 --> 00:49:39,280
percentage value um so it's really nice

00:49:37,440 --> 00:49:40,079
to do your cube control describe and see

00:49:39,280 --> 00:49:43,520
oh my

00:49:40,079 --> 00:49:46,000
vm is 77 you know

00:49:43,520 --> 00:49:47,599
provisioned and go from there not all

00:49:46,000 --> 00:49:48,720
api types are that generous with the

00:49:47,599 --> 00:49:50,079
information they give you

00:49:48,720 --> 00:49:52,480
but that's one of my particular

00:49:50,079 --> 00:49:52,480
favorites

00:49:52,640 --> 00:49:57,760
so one of the more tedious parts i'd say

00:49:55,760 --> 00:49:59,599
of the manage reconciler is checking

00:49:57,760 --> 00:50:01,200
whether the resource needs an update

00:49:59,599 --> 00:50:03,119
and there are a few tricks to get around

00:50:01,200 --> 00:50:04,480
this we've seen folks actually generate

00:50:03,119 --> 00:50:07,359
json structs and then use

00:50:04,480 --> 00:50:09,440
libraries to kind of diff them here

00:50:07,359 --> 00:50:10,240
we've only defined two fields in our

00:50:09,440 --> 00:50:12,160
spec

00:50:10,240 --> 00:50:13,839
besides the org which has to be up to

00:50:12,160 --> 00:50:16,000
date essentially because we're providing

00:50:13,839 --> 00:50:18,240
that as the way to call the methods

00:50:16,000 --> 00:50:19,040
um but here we're basically just saying

00:50:18,240 --> 00:50:21,440
uh if

00:50:19,040 --> 00:50:23,280
we have provided a description in our

00:50:21,440 --> 00:50:26,480
custom resource

00:50:23,280 --> 00:50:26,880
and uh if the team description which is

00:50:26,480 --> 00:50:28,319
the

00:50:26,880 --> 00:50:30,000
the representation we get back from

00:50:28,319 --> 00:50:32,640
github is uh

00:50:30,000 --> 00:50:33,839
nil or the team description does not

00:50:32,640 --> 00:50:36,800
equal the one that we

00:50:33,839 --> 00:50:38,319
have we want up to date to be false and

00:50:36,800 --> 00:50:41,200
then we do that same check for

00:50:38,319 --> 00:50:42,800
our privacy field here and then based on

00:50:41,200 --> 00:50:45,760
that we're going to return

00:50:42,800 --> 00:50:46,240
whether the resource is up to date if we

00:50:45,760 --> 00:50:47,920
return

00:50:46,240 --> 00:50:49,359
false there then we're once again going

00:50:47,920 --> 00:50:52,480
to call the update method

00:50:49,359 --> 00:50:55,440
which is going to use this edit

00:50:52,480 --> 00:50:57,520
call here to be able to edit our team

00:50:55,440 --> 00:50:59,040
and set it to the fields that we want

00:50:57,520 --> 00:51:00,880
once again you can provide your

00:50:59,040 --> 00:51:02,720
connection details we actually don't

00:51:00,880 --> 00:51:05,920
need to do that here because once again

00:51:02,720 --> 00:51:08,480
we don't have any connection details

00:51:05,920 --> 00:51:09,359
lastly when you delete a kubernetes

00:51:08,480 --> 00:51:11,599
resource

00:51:09,359 --> 00:51:13,440
if it has a finalizer on it which is

00:51:11,599 --> 00:51:15,760
kind of like an annotation or label up

00:51:13,440 --> 00:51:17,440
there at the top of the metadata

00:51:15,760 --> 00:51:19,359
it is going to hang around even though

00:51:17,440 --> 00:51:20,640
you've deleted it until that finalizer

00:51:19,359 --> 00:51:22,480
gets removed

00:51:20,640 --> 00:51:23,760
so crossplane is going to go ahead once

00:51:22,480 --> 00:51:25,119
again you can override this but it's

00:51:23,760 --> 00:51:27,599
going to go ahead and put a manage

00:51:25,119 --> 00:51:28,880
resource finalizer on your resources

00:51:27,599 --> 00:51:30,640
and when you delete them in the

00:51:28,880 --> 00:51:31,520
kubernetes api it's basically going to

00:51:30,640 --> 00:51:32,960
keep them around

00:51:31,520 --> 00:51:35,440
until it can guarantee that that

00:51:32,960 --> 00:51:36,720
resource was deleted externally

00:51:35,440 --> 00:51:38,000
and so what it's going to do is it's

00:51:36,720 --> 00:51:39,920
going to check for the deletion

00:51:38,000 --> 00:51:41,440
timestamp on your kubernetes resource

00:51:39,920 --> 00:51:43,839
which gets set when you issue

00:51:41,440 --> 00:51:45,359
your cube control delete command and

00:51:43,839 --> 00:51:46,640
then it's going to call the delete

00:51:45,359 --> 00:51:47,680
method that you've defined in your

00:51:46,640 --> 00:51:50,400
controller

00:51:47,680 --> 00:51:51,839
in this case delete team by slug and if

00:51:50,400 --> 00:51:54,000
that returns successfully

00:51:51,839 --> 00:51:56,480
then it's going to say okay i can now

00:51:54,000 --> 00:51:58,240
see that the resource no longer exists

00:51:56,480 --> 00:52:00,319
and i'm going to remove that finalizer

00:51:58,240 --> 00:52:03,280
which then allows kubernetes to garbage

00:52:00,319 --> 00:52:03,280
collect that resource

00:52:03,680 --> 00:52:07,440
so i think that was a pretty good

00:52:05,440 --> 00:52:09,920
overview of um

00:52:07,440 --> 00:52:11,839
of what you can do here with the

00:52:09,920 --> 00:52:13,599
controller and we've got a pretty full

00:52:11,839 --> 00:52:15,200
working controller here with not too

00:52:13,599 --> 00:52:16,640
many lines of code and a lot of it

00:52:15,200 --> 00:52:19,200
boilerplate that we just

00:52:16,640 --> 00:52:19,760
populated ourselves um so what do you

00:52:19,200 --> 00:52:21,520
say we

00:52:19,760 --> 00:52:23,520
actually maybe change a little bit of

00:52:21,520 --> 00:52:24,079
the behavior here um and try and rerun

00:52:23,520 --> 00:52:25,760
it again

00:52:24,079 --> 00:52:29,760
and and we can see how this helps us and

00:52:25,760 --> 00:52:29,760
how this continuous reconciliation works

00:52:30,880 --> 00:52:34,400
so one of the things that i pointed out

00:52:32,800 --> 00:52:36,160
earlier is we have this node id

00:52:34,400 --> 00:52:37,440
field but we don't actually set the node

00:52:36,160 --> 00:52:40,400
id

00:52:37,440 --> 00:52:41,520
anywhere in our controller and if we

00:52:40,400 --> 00:52:43,680
looked at the yaml

00:52:41,520 --> 00:52:45,440
output here you'll see that our at

00:52:43,680 --> 00:52:47,760
provider is just empty

00:52:45,440 --> 00:52:48,480
and i'd like to know the node id just

00:52:47,760 --> 00:52:51,040
because

00:52:48,480 --> 00:52:52,800
sounds interesting so you know to

00:52:51,040 --> 00:52:56,079
populate our status we usually

00:52:52,800 --> 00:53:00,160
do that in the observe method here

00:52:56,079 --> 00:53:01,680
so we can do that by just saying

00:53:00,160 --> 00:53:03,520
okay so if we got to here our team

00:53:01,680 --> 00:53:07,440
exists so we'll say

00:53:03,520 --> 00:53:10,800
cr dot spec

00:53:07,440 --> 00:53:14,319
dot provider

00:53:10,800 --> 00:53:18,000
sorry that's gonna be status at provider

00:53:14,319 --> 00:53:18,000
and our node id

00:53:18,480 --> 00:53:25,040
is equal to that of the team

00:53:21,599 --> 00:53:29,920
so i can actually hit caps lock there

00:53:25,040 --> 00:53:32,160
team dot node id

00:53:29,920 --> 00:53:34,000
all right so let's actually do a check

00:53:32,160 --> 00:53:37,359
on that make sure it's not

00:53:34,000 --> 00:53:39,359
nil does not

00:53:37,359 --> 00:53:40,400
equal nil then we'll go ahead and set

00:53:39,359 --> 00:53:42,319
that

00:53:40,400 --> 00:53:43,839
and i'm actually just going to go ahead

00:53:42,319 --> 00:53:45,200
and show some of the methods that we

00:53:43,839 --> 00:53:46,880
defined to also

00:53:45,200 --> 00:53:49,599
make this development experience really

00:53:46,880 --> 00:53:51,520
nice for you so when you clone from that

00:53:49,599 --> 00:53:51,839
provider template we have a make file in

00:53:51,520 --> 00:53:53,920
here

00:53:51,839 --> 00:53:55,520
just has some really simple targets i

00:53:53,920 --> 00:53:57,280
like to do this make run one which is

00:53:55,520 --> 00:53:59,119
going to regenerate your crds

00:53:57,280 --> 00:54:00,559
apply them to the cluster in this case

00:53:59,119 --> 00:54:03,440
we have no changes and it's going to

00:54:00,559 --> 00:54:03,440
start your controller

00:54:03,520 --> 00:54:07,359
so if i hop back over here i'll go ahead

00:54:05,680 --> 00:54:10,000
and stop my controller

00:54:07,359 --> 00:54:11,119
do make run again here we see it's using

00:54:10,000 --> 00:54:13,119
go generate

00:54:11,119 --> 00:54:14,160
and it's just using my cube config to be

00:54:13,119 --> 00:54:15,680
able to talk to the cluster so we

00:54:14,160 --> 00:54:16,800
actually have cluster admin here

00:54:15,680 --> 00:54:18,880
which is a little bit different than

00:54:16,800 --> 00:54:20,079
when we showed earlier uh installing a

00:54:18,880 --> 00:54:21,760
provider

00:54:20,079 --> 00:54:24,160
so it looks like our external resource

00:54:21,760 --> 00:54:26,720
is up to date which we would expect

00:54:24,160 --> 00:54:28,000
and let's see now we have that node id

00:54:26,720 --> 00:54:29,839
present

00:54:28,000 --> 00:54:31,680
in our app provider so you can provide

00:54:29,839 --> 00:54:32,640
any information that the api gives you

00:54:31,680 --> 00:54:35,040
back

00:54:32,640 --> 00:54:36,160
in this field but one of the things i

00:54:35,040 --> 00:54:39,520
want to do is

00:54:36,160 --> 00:54:41,920
show how when you modify

00:54:39,520 --> 00:54:42,960
a resource outside of your source of

00:54:41,920 --> 00:54:45,119
truth which in this case

00:54:42,960 --> 00:54:46,559
is your cross plane kubernetes cluster

00:54:45,119 --> 00:54:48,240
that crossplan is going to make sure it

00:54:46,559 --> 00:54:51,200
drives you back to the spec

00:54:48,240 --> 00:54:52,000
specification that you've defined so

00:54:51,200 --> 00:54:54,880
something we might

00:54:52,000 --> 00:54:55,280
see uh is someone going into a github

00:54:54,880 --> 00:54:58,000
team

00:54:55,280 --> 00:54:58,720
and taking the privacy from secret uh to

00:54:58,000 --> 00:55:00,319
closed

00:54:58,720 --> 00:55:02,720
which is the two different values they

00:55:00,319 --> 00:55:04,160
give you closed basically just means

00:55:02,720 --> 00:55:07,440
it's visible

00:55:04,160 --> 00:55:10,720
so let's go ahead and hop over to our

00:55:07,440 --> 00:55:10,720
kubecon in a

00:55:11,440 --> 00:55:14,160
org here

00:55:14,559 --> 00:55:19,440
and modify this a little bit and see how

00:55:16,559 --> 00:55:21,599
crossplane drives it back

00:55:19,440 --> 00:55:22,799
and this is a bit of a trivial example

00:55:21,599 --> 00:55:24,400
but stephen have you seen

00:55:22,799 --> 00:55:26,319
any kind of like different examples in

00:55:24,400 --> 00:55:27,839
your experience um that are a little

00:55:26,319 --> 00:55:29,280
more powerful in demonstrating this

00:55:27,839 --> 00:55:30,559
functionality

00:55:29,280 --> 00:55:34,160
well i think this is good just for

00:55:30,559 --> 00:55:35,520
compliance purposes right like the like

00:55:34,160 --> 00:55:36,960
immediately like one of the biggest

00:55:35,520 --> 00:55:38,400
concerns we have is that people are

00:55:36,960 --> 00:55:40,079
making changes

00:55:38,400 --> 00:55:41,440
manually like they're adding users

00:55:40,079 --> 00:55:44,319
they're changing permissions

00:55:41,440 --> 00:55:45,040
um and we want to make sure that if that

00:55:44,319 --> 00:55:47,760
happens

00:55:45,040 --> 00:55:49,119
um that gets corrected pretty quickly um

00:55:47,760 --> 00:55:50,880
and thanks to like having things like

00:55:49,119 --> 00:55:51,200
events and kubernetes you could actually

00:55:50,880 --> 00:55:52,720
see

00:55:51,200 --> 00:55:55,359
what's happening right you could be

00:55:52,720 --> 00:55:59,119
notified so i think that's probably

00:55:55,359 --> 00:56:00,880
one of the best use cases for it um

00:55:59,119 --> 00:56:02,319
you know this constant making sure that

00:56:00,880 --> 00:56:05,200
what your desired state is

00:56:02,319 --> 00:56:06,319
is actually out there for sure i i

00:56:05,200 --> 00:56:08,400
totally agree with that

00:56:06,319 --> 00:56:09,599
and a nice thing is um we're using the

00:56:08,400 --> 00:56:11,200
default weight here

00:56:09,599 --> 00:56:13,280
uh which basically checks every minute

00:56:11,200 --> 00:56:15,200
to make sure that things are up to date

00:56:13,280 --> 00:56:16,559
you can obviously configure that to what

00:56:15,200 --> 00:56:18,079
you see fit

00:56:16,559 --> 00:56:20,000
so if you said you know i need to be

00:56:18,079 --> 00:56:22,799
more stringent or i really only need to

00:56:20,000 --> 00:56:25,440
check this resource every so often

00:56:22,799 --> 00:56:26,960
you know once a day maybe and see if

00:56:25,440 --> 00:56:29,119
it's been updated

00:56:26,960 --> 00:56:30,000
that works for you as well obviously if

00:56:29,119 --> 00:56:32,000
you modify

00:56:30,000 --> 00:56:33,440
the resource in the kubernetes cluster

00:56:32,000 --> 00:56:34,960
then that's going to be an immediate

00:56:33,440 --> 00:56:36,240
action taken

00:56:34,960 --> 00:56:38,559
but i'm going to go ahead and set this

00:56:36,240 --> 00:56:40,400
to visible and save the changes

00:56:38,559 --> 00:56:43,200
and we should see that this is now

00:56:40,400 --> 00:56:44,480
visible you'll no longer see that secret

00:56:43,200 --> 00:56:47,680
and if we hop back over to our

00:56:44,480 --> 00:56:50,640
controller here our last status here was

00:56:47,680 --> 00:56:52,960
external resources up to date

00:56:50,640 --> 00:56:54,640
but if we actually wait a few minutes

00:56:52,960 --> 00:56:55,920
you can see our time here

00:56:54,640 --> 00:56:58,079
so we should be coming back on a

00:56:55,920 --> 00:56:58,640
reconcile again we'll actually set that

00:56:58,079 --> 00:57:01,520
field

00:56:58,640 --> 00:57:03,680
back to secret and we'll see that

00:57:01,520 --> 00:57:06,079
updated

00:57:03,680 --> 00:57:08,240
and while we're waiting on that we can

00:57:06,079 --> 00:57:09,040
also do the opposite right and modify

00:57:08,240 --> 00:57:11,839
these fields

00:57:09,040 --> 00:57:14,480
in our resource and then see that

00:57:11,839 --> 00:57:18,319
propagated to the external resource

00:57:14,480 --> 00:57:18,319
which will show momentarily

00:57:18,799 --> 00:57:23,920
all right so there we see that we got a

00:57:22,160 --> 00:57:25,359
successfully requested update of

00:57:23,920 --> 00:57:27,040
external resource

00:57:25,359 --> 00:57:28,880
this information is just because we're

00:57:27,040 --> 00:57:31,359
actually printing out the struct for

00:57:28,880 --> 00:57:32,160
you know a demo purpose here but we

00:57:31,359 --> 00:57:35,599
should see

00:57:32,160 --> 00:57:37,839
if we hop back over here to the org

00:57:35,599 --> 00:57:39,359
that it's once again in secret mode so

00:57:37,839 --> 00:57:40,160
it's basically making sure that you stay

00:57:39,359 --> 00:57:41,760
compliant

00:57:40,160 --> 00:57:43,359
and this gets really powerful and this

00:57:41,760 --> 00:57:45,040
is one of the benefits of standardizing

00:57:43,359 --> 00:57:47,119
on the kubernetes api

00:57:45,040 --> 00:57:48,960
when you leverage other projects as well

00:57:47,119 --> 00:57:50,960
so a demo we like to show a lot is

00:57:48,960 --> 00:57:52,400
integrating with opa

00:57:50,960 --> 00:57:54,720
and one of the examples we've shown

00:57:52,400 --> 00:57:56,480
there is creating a database

00:57:54,720 --> 00:57:58,079
that you know you want to have a limit

00:57:56,480 --> 00:57:59,440
on the size of a database someone can

00:57:58,079 --> 00:58:02,079
create so you don't have you know a

00:57:59,440 --> 00:58:03,119
gcp cloud sql instance that's 500 gigs

00:58:02,079 --> 00:58:04,240
or something like that

00:58:03,119 --> 00:58:06,319
costing you a lot of money in a

00:58:04,240 --> 00:58:06,960
development environment you could create

00:58:06,319 --> 00:58:09,440
a

00:58:06,960 --> 00:58:10,160
open policy agent policy that says you

00:58:09,440 --> 00:58:14,000
know

00:58:10,160 --> 00:58:16,480
only accept databases with a size of

00:58:14,000 --> 00:58:17,920
20 gigs or something like that and put

00:58:16,480 --> 00:58:19,920
limits and then have those

00:58:17,920 --> 00:58:21,440
checked in your resources because once

00:58:19,920 --> 00:58:22,079
you have everything defined as a

00:58:21,440 --> 00:58:24,799
kubernetes

00:58:22,079 --> 00:58:25,520
resource and you can integrate with any

00:58:24,799 --> 00:58:28,000
um

00:58:25,520 --> 00:58:28,960
project that uses kubernetes api another

00:58:28,000 --> 00:58:30,960
place we've seen this

00:58:28,960 --> 00:58:32,559
is backing up your infrastructure with a

00:58:30,960 --> 00:58:33,920
project like valero

00:58:32,559 --> 00:58:35,760
you can just save your infrastructure

00:58:33,920 --> 00:58:37,359
and restore it into a new cluster

00:58:35,760 --> 00:58:40,960
and get crossplane managing it

00:58:37,359 --> 00:58:40,960
continuously there as well

00:58:41,040 --> 00:58:46,880
so let's try one other change here i

00:58:44,160 --> 00:58:48,240
want to go into our team.yaml and let's

00:58:46,880 --> 00:58:50,319
just change our description

00:58:48,240 --> 00:58:51,440
so right now it's our description and

00:58:50,319 --> 00:58:55,599
we'll say some

00:58:51,440 --> 00:58:58,160
other description if i can type here

00:58:55,599 --> 00:58:59,280
and we'll save that and i'll go back to

00:58:58,160 --> 00:59:02,079
the terminal

00:58:59,280 --> 00:59:03,680
and like i said when you change the spec

00:59:02,079 --> 00:59:04,000
in your kubernetes resource we're going

00:59:03,680 --> 00:59:05,920
to see

00:59:04,000 --> 00:59:07,280
immediate action taken on that behalf

00:59:05,920 --> 00:59:08,000
because the controller is getting an

00:59:07,280 --> 00:59:11,119
event

00:59:08,000 --> 00:59:11,599
from the kubernetes api server so we'll

00:59:11,119 --> 00:59:14,720
say

00:59:11,599 --> 00:59:16,799
examples org team and we should see that

00:59:14,720 --> 00:59:18,880
that immediately requests an update of

00:59:16,799 --> 00:59:22,000
an external resource

00:59:18,880 --> 00:59:24,319
so we'll quickly see that propagated

00:59:22,000 --> 00:59:25,119
now it says some other description and

00:59:24,319 --> 00:59:27,680
we can also

00:59:25,119 --> 00:59:28,880
manage the deletion of our resource so

00:59:27,680 --> 00:59:32,160
i'll do

00:59:28,880 --> 00:59:34,799
k delete team

00:59:32,160 --> 00:59:36,400
all here and you'll see that we

00:59:34,799 --> 00:59:37,599
successfully requested deletion of

00:59:36,400 --> 00:59:38,880
external resource

00:59:37,599 --> 00:59:40,319
and it's actually going to reconcile

00:59:38,880 --> 00:59:40,880
again here in a moment and make sure

00:59:40,319 --> 00:59:43,280
that that's

00:59:40,880 --> 00:59:44,160
actually been deleted externally and

00:59:43,280 --> 00:59:47,440
then allow

00:59:44,160 --> 00:59:47,920
this resource to be cleaned up but if we

00:59:47,440 --> 00:59:49,760
go

00:59:47,920 --> 00:59:52,079
and refresh here we're going to find

00:59:49,760 --> 00:59:53,440
that this team no longer exists

00:59:52,079 --> 00:59:55,200
so you could really do a lot of

00:59:53,440 --> 00:59:56,640
management the

00:59:55,200 --> 00:59:58,640
github api has a lot of different

00:59:56,640 --> 01:00:00,160
endpoints one of the things that we've

00:59:58,640 --> 01:00:02,160
looked at doing for the cross plan

01:00:00,160 --> 01:00:03,760
organization where we frequently spin up

01:00:02,160 --> 01:00:04,799
new repositories with similar

01:00:03,760 --> 01:00:07,359
permissions

01:00:04,799 --> 01:00:08,799
um we've talked about having a

01:00:07,359 --> 01:00:09,599
cross-plane cluster basically manage

01:00:08,799 --> 01:00:11,440
those for us

01:00:09,599 --> 01:00:13,359
and then having a git ops pipeline that

01:00:11,440 --> 01:00:15,440
sends some of our

01:00:13,359 --> 01:00:16,960
you know cube control changes basically

01:00:15,440 --> 01:00:19,200
through it uh that create new

01:00:16,960 --> 01:00:22,079
repositories update teams update

01:00:19,200 --> 01:00:23,599
permissions etc if we go back over here

01:00:22,079 --> 01:00:26,160
you'll see that our team has been

01:00:23,599 --> 01:00:26,160
deleted

01:00:26,839 --> 01:00:33,760
and let's see

01:00:30,799 --> 01:00:34,559
no resources found um for our team so

01:00:33,760 --> 01:00:37,359
we've cleaned up

01:00:34,559 --> 01:00:39,040
all of our resources so i just wanted to

01:00:37,359 --> 01:00:39,520
summarize here we just wanted to show

01:00:39,040 --> 01:00:42,000
you that

01:00:39,520 --> 01:00:43,280
with not a lot of code you could have

01:00:42,000 --> 01:00:46,559
really full featured

01:00:43,280 --> 01:00:49,359
infrastructure software um first

01:00:46,559 --> 01:00:51,200
you know we define the apis that

01:00:49,359 --> 01:00:52,480
generate the crds that could be applied

01:00:51,200 --> 01:00:55,359
to your cluster so we take your

01:00:52,480 --> 01:00:56,960
infrastructure and we model it

01:00:55,359 --> 01:00:58,960
whatever features and parameters that

01:00:56,960 --> 01:01:00,480
you want to manage whatever things you

01:00:58,960 --> 01:01:02,480
want to look at

01:01:00,480 --> 01:01:05,200
and those automatically get generated

01:01:02,480 --> 01:01:07,040
into crds that you apply to your cluster

01:01:05,200 --> 01:01:08,640
you also have multiple providers that

01:01:07,040 --> 01:01:10,000
you can talk to on the back end with

01:01:08,640 --> 01:01:12,240
different kinds of credentials if you

01:01:10,000 --> 01:01:14,319
want to segregate out

01:01:12,240 --> 01:01:15,920
which accounts can do what on different

01:01:14,319 --> 01:01:17,920
parts of infrastructure so that's the

01:01:15,920 --> 01:01:20,160
first part defining our api

01:01:17,920 --> 01:01:22,240
then we define the controller and the

01:01:20,160 --> 01:01:23,440
controller has three main functions

01:01:22,240 --> 01:01:25,440
one of those is to talk to the

01:01:23,440 --> 01:01:28,480
kubernetes api

01:01:25,440 --> 01:01:29,520
um and look for events for our type our

01:01:28,480 --> 01:01:31,760
team

01:01:29,520 --> 01:01:33,119
the next thing is the connector where it

01:01:31,760 --> 01:01:35,119
actually talks

01:01:33,119 --> 01:01:36,799
and creates a connection a client

01:01:35,119 --> 01:01:39,839
connection to github

01:01:36,799 --> 01:01:42,480
where it's going to talk to the api

01:01:39,839 --> 01:01:43,280
and then finally we have our managed

01:01:42,480 --> 01:01:46,240
events right

01:01:43,280 --> 01:01:48,000
we observe the external resource and

01:01:46,240 --> 01:01:48,960
based on what happens in an external

01:01:48,000 --> 01:01:52,000
resource

01:01:48,960 --> 01:01:54,480
we either create update or delete

01:01:52,000 --> 01:01:55,920
the resource so these are the core parts

01:01:54,480 --> 01:01:57,680
of the controller

01:01:55,920 --> 01:01:59,440
um and you can see here this is about

01:01:57,680 --> 01:02:01,839
just a little over 200 lines and we have

01:01:59,440 --> 01:02:03,680
a controller that's basically managing

01:02:01,839 --> 01:02:05,119
the entire lifecycle of an external

01:02:03,680 --> 01:02:08,640
resource

01:02:05,119 --> 01:02:09,520
um pretty much within you know 60

01:02:08,640 --> 01:02:10,960
seconds of

01:02:09,520 --> 01:02:13,039
any change that it observes on the

01:02:10,960 --> 01:02:15,520
outside so um

01:02:13,039 --> 01:02:18,160
that's kind of the end of our deep dive

01:02:15,520 --> 01:02:20,240
into this controller

01:02:18,160 --> 01:02:22,960
and dan is going to talk about some

01:02:20,240 --> 01:02:24,960
other topics related to crossplane

01:02:22,960 --> 01:02:26,559
okay so now that we've built our

01:02:24,960 --> 01:02:28,640
provider out i'd like to show how we can

01:02:26,559 --> 01:02:29,839
package it up push it to a registry and

01:02:28,640 --> 01:02:31,039
install it just like we did with

01:02:29,839 --> 01:02:33,119
provider aws

01:02:31,039 --> 01:02:34,640
before we did this tutorial so we have

01:02:33,119 --> 01:02:36,799
some helpful commands here

01:02:34,640 --> 01:02:38,640
and to start off we need to build the

01:02:36,799 --> 01:02:41,359
controller binary which is what's going

01:02:38,640 --> 01:02:43,280
to run in our pod and manage our crds

01:02:41,359 --> 01:02:45,119
package that into an image and then push

01:02:43,280 --> 01:02:47,200
it then we're going to push our actual

01:02:45,119 --> 01:02:48,480
package image which has the metadata and

01:02:47,200 --> 01:02:51,039
instructs crossplane

01:02:48,480 --> 01:02:52,400
how to install the crds and how to start

01:02:51,039 --> 01:02:54,960
the controller

01:02:52,400 --> 01:02:56,680
so to start off let's go ahead and make

01:02:54,960 --> 01:02:59,359
this version

01:02:56,680 --> 01:03:01,119
0.0.1 and these are just some helpful

01:02:59,359 --> 01:03:02,960
make commands to

01:03:01,119 --> 01:03:04,160
make it easier for us to go through this

01:03:02,960 --> 01:03:05,920
process

01:03:04,160 --> 01:03:07,200
so we're going to build the go binary

01:03:05,920 --> 01:03:07,920
we're going to create the image and then

01:03:07,200 --> 01:03:09,200
push it

01:03:07,920 --> 01:03:11,280
and we're going to use the crossplane

01:03:09,200 --> 01:03:13,280
cli to actually push our specialized

01:03:11,280 --> 01:03:15,200
image for our provider here

01:03:13,280 --> 01:03:16,720
which has some information that

01:03:15,200 --> 01:03:19,200
crossplan is going to look at

01:03:16,720 --> 01:03:20,319
and then unpack the provider

01:03:19,200 --> 01:03:22,480
appropriately

01:03:20,319 --> 01:03:24,319
and so we're going to want to use this

01:03:22,480 --> 01:03:28,839
exact controller image that we've built

01:03:24,319 --> 01:03:31,920
so i'll specify here that we want

01:03:28,839 --> 01:03:32,640
v0.0.1 okay so switching over to our

01:03:31,920 --> 01:03:36,240
terminal

01:03:32,640 --> 01:03:38,240
first thing we need to do is make build

01:03:36,240 --> 01:03:39,760
and you'll see that we are running the

01:03:38,240 --> 01:03:40,880
build there

01:03:39,760 --> 01:03:42,720
and while we're doing that we can

01:03:40,880 --> 01:03:44,319
actually go ahead and go into the

01:03:42,720 --> 01:03:45,839
package directory and start the build of

01:03:44,319 --> 01:03:47,520
our other image since it's just going to

01:03:45,839 --> 01:03:47,920
have a reference to this one which will

01:03:47,520 --> 01:03:50,559
exist

01:03:47,920 --> 01:03:52,240
after we push it um so it looks like

01:03:50,559 --> 01:03:54,640
that build is still going so let's go

01:03:52,240 --> 01:03:57,119
ahead and build our package image

01:03:54,640 --> 01:03:58,880
so we have um some helpful commands in

01:03:57,119 --> 01:04:02,480
the cross plane cli here

01:03:58,880 --> 01:04:04,559
we can say create k cross plane build

01:04:02,480 --> 01:04:05,760
provider and since we're in this package

01:04:04,559 --> 01:04:08,079
directory it's going to go ahead and

01:04:05,760 --> 01:04:11,839
look at the crossplan.yaml

01:04:08,079 --> 01:04:13,440
and know how to produce a package

01:04:11,839 --> 01:04:15,039
all right so if we look we should see

01:04:13,440 --> 01:04:15,920
that we now have this x package

01:04:15,039 --> 01:04:17,760
directory

01:04:15,920 --> 01:04:20,319
which is basically a specialized tarball

01:04:17,760 --> 01:04:21,920
which is an oci image that can be pushed

01:04:20,319 --> 01:04:24,240
and the crossplan cli is going to know

01:04:21,920 --> 01:04:27,599
how to do that and format it correctly

01:04:24,240 --> 01:04:29,680
but before we do that let's go ahead and

01:04:27,599 --> 01:04:30,640
finish making our image here so that was

01:04:29,680 --> 01:04:32,559
a pretty quick

01:04:30,640 --> 01:04:34,240
image build um and i'll go ahead and

01:04:32,559 --> 01:04:36,319
make push that

01:04:34,240 --> 01:04:40,160
make uh image push i believe is the

01:04:36,319 --> 01:04:41,599
command we want

01:04:40,160 --> 01:04:43,440
all right so it looks like that's been

01:04:41,599 --> 01:04:44,240
pushed up with kc provider github

01:04:43,440 --> 01:04:46,640
controller

01:04:44,240 --> 01:04:47,599
we're referencing that in our provider

01:04:46,640 --> 01:04:50,880
package here

01:04:47,599 --> 01:04:53,839
so we can now k cross plane push

01:04:50,880 --> 01:04:55,599
provider and since we're in this package

01:04:53,839 --> 01:04:56,559
directory and there's only one x package

01:04:55,599 --> 01:04:58,240
present

01:04:56,559 --> 01:04:59,839
um it's going to know to use that one

01:04:58,240 --> 01:05:01,119
and we just need to give that the tag we

01:04:59,839 --> 01:05:04,720
want so hashtan

01:05:01,119 --> 01:05:08,000
kc provider

01:05:04,720 --> 01:05:11,440
github and

01:05:08,000 --> 01:05:13,760
we want that version and we should see

01:05:11,440 --> 01:05:16,319
that this is pushed successfully

01:05:13,760 --> 01:05:17,359
and we also have a con cluster already

01:05:16,319 --> 01:05:20,880
running here

01:05:17,359 --> 01:05:24,000
so let me scoot this over a bit and

01:05:20,880 --> 01:05:26,640
we can look at what we have

01:05:24,000 --> 01:05:28,559
i already installed crossplane um so we

01:05:26,640 --> 01:05:30,480
have the cross plane pods running

01:05:28,559 --> 01:05:31,760
and let me go ahead and just close out

01:05:30,480 --> 01:05:32,400
this window so it's a little easier to

01:05:31,760 --> 01:05:34,079
see

01:05:32,400 --> 01:05:36,160
so we have our cross plane pods running

01:05:34,079 --> 01:05:38,720
and just like we did before the tutorial

01:05:36,160 --> 01:05:40,240
to install uh provider aws we now want

01:05:38,720 --> 01:05:42,079
to do the same thing with provider

01:05:40,240 --> 01:05:45,119
github

01:05:42,079 --> 01:05:47,359
so we can do k crossplane

01:05:45,119 --> 01:05:49,119
install provider and i'll specify that

01:05:47,359 --> 01:05:52,240
image that i just pushed

01:05:49,119 --> 01:05:55,839
which was hashdan kc

01:05:52,240 --> 01:05:59,280
provider github

01:05:55,839 --> 01:06:00,319
and we want v0.0.1

01:05:59,280 --> 01:06:02,640
all right so it looks like that was

01:06:00,319 --> 01:06:04,640
created it will take it just a moment to

01:06:02,640 --> 01:06:05,760
get installed so you'll see it doesn't

01:06:04,640 --> 01:06:08,319
have a status yet

01:06:05,760 --> 01:06:09,839
but if we keep watching this we'll

01:06:08,319 --> 01:06:11,680
actually see that it does come available

01:06:09,839 --> 01:06:13,280
so it's installed it's not healthy yet

01:06:11,680 --> 01:06:15,280
if we check again it looks like it is

01:06:13,280 --> 01:06:17,200
healthy now and we can see that

01:06:15,280 --> 01:06:18,319
crossplane has looked into the contents

01:06:17,200 --> 01:06:21,440
of our package

01:06:18,319 --> 01:06:24,480
and it's gone ahead and started

01:06:21,440 --> 01:06:26,960
our controller for us so we see our kc

01:06:24,480 --> 01:06:30,559
provider github running here

01:06:26,960 --> 01:06:34,000
and we can also see that

01:06:30,559 --> 01:06:35,680
we've installed crds they were specified

01:06:34,000 --> 01:06:37,680
in our package so here we have our

01:06:35,680 --> 01:06:38,400
provider config provider config usage

01:06:37,680 --> 01:06:41,359
and our team

01:06:38,400 --> 01:06:43,039
crd if i go ahead and once again create

01:06:41,359 --> 01:06:46,640
my configuration

01:06:43,039 --> 01:06:51,680
um and let me go ahead and pull up

01:06:46,640 --> 01:06:51,680
our github org again

01:06:54,480 --> 01:06:57,920
i want to make sure that that team that

01:06:56,079 --> 01:06:59,680
we previously created has been cleaned

01:06:57,920 --> 01:07:02,000
up

01:06:59,680 --> 01:07:03,520
it looks like it has so we don't have

01:07:02,000 --> 01:07:05,599
any team here so once again i'm going to

01:07:03,520 --> 01:07:09,039
create my provider config

01:07:05,599 --> 01:07:12,079
which has my access token in it

01:07:09,039 --> 01:07:13,440
and so that's in secrets config.yaml

01:07:12,079 --> 01:07:15,440
all right so we've created my provider

01:07:13,440 --> 01:07:16,720
config and this is the same workflow we

01:07:15,440 --> 01:07:18,400
were going through with dev but now

01:07:16,720 --> 01:07:19,359
we've been able to install this kc

01:07:18,400 --> 01:07:20,960
provider github

01:07:19,359 --> 01:07:22,640
which also allows other folks to be able

01:07:20,960 --> 01:07:24,079
to consume this provider

01:07:22,640 --> 01:07:26,640
and us to be able to distribute it

01:07:24,079 --> 01:07:30,160
easily so i'm going to go ahead

01:07:26,640 --> 01:07:34,640
and create our team again

01:07:30,160 --> 01:07:38,160
that was in examples org team

01:07:34,640 --> 01:07:40,640
and we should be able to k get team

01:07:38,160 --> 01:07:44,640
and see that it is synced and if we go

01:07:40,640 --> 01:07:44,640
back over to our github org

01:07:44,720 --> 01:07:49,200
we now have our team here again so

01:07:47,359 --> 01:07:50,880
packaging things up as a provider makes

01:07:49,200 --> 01:07:53,680
them a lot easier to install and

01:07:50,880 --> 01:07:55,280
and you can also have specifications for

01:07:53,680 --> 01:07:56,160
how you want to reproduce whole

01:07:55,280 --> 01:07:57,440
environments

01:07:56,160 --> 01:08:00,000
so maybe you want environment with

01:07:57,440 --> 01:08:01,920
github aws and gcp installed

01:08:00,000 --> 01:08:03,280
and you can easily reproduce that across

01:08:01,920 --> 01:08:06,480
kubernetes clusters

01:08:03,280 --> 01:08:08,720
after you've installed crossplane

01:08:06,480 --> 01:08:10,079
all right so we have our team present we

01:08:08,720 --> 01:08:12,160
have our pods running

01:08:10,079 --> 01:08:14,319
and we have our crds installed in the

01:08:12,160 --> 01:08:16,799
cluster and now what we want to do is

01:08:14,319 --> 01:08:19,199
add more crds and update our controller

01:08:16,799 --> 01:08:21,120
push a new version of it to our registry

01:08:19,199 --> 01:08:22,000
install it and have cross plan updated

01:08:21,120 --> 01:08:23,920
in place

01:08:22,000 --> 01:08:25,359
without modifying our existing

01:08:23,920 --> 01:08:26,880
infrastructure so we want this team to

01:08:25,359 --> 01:08:28,799
stick around but we want to add new

01:08:26,880 --> 01:08:31,600
functionality as well

01:08:28,799 --> 01:08:33,839
so i've added a new type here a

01:08:31,600 --> 01:08:36,719
memberships type which basically allows

01:08:33,839 --> 01:08:38,000
us to specify an org a team and a user

01:08:36,719 --> 01:08:40,239
and associate a specific

01:08:38,000 --> 01:08:42,239
user with that team that we created in

01:08:40,239 --> 01:08:43,759
the last step for example

01:08:42,239 --> 01:08:45,679
and so what we want to do i've also

01:08:43,759 --> 01:08:48,319
added a new controller

01:08:45,679 --> 01:08:48,880
to manage this and what we want to do is

01:08:48,319 --> 01:08:52,719
publish

01:08:48,880 --> 01:08:54,719
a new controller image as well as a new

01:08:52,719 --> 01:08:57,199
package image so you'll see i've updated

01:08:54,719 --> 01:08:59,920
to v0.0.2 here

01:08:57,199 --> 01:09:01,040
and we'll also want to make sure that

01:08:59,920 --> 01:09:02,560
our

01:09:01,040 --> 01:09:05,120
makefile commands here are going to

01:09:02,560 --> 01:09:07,920
update as well

01:09:05,120 --> 01:09:10,719
so i'll go ahead and run those again we

01:09:07,920 --> 01:09:14,319
need to rebuild our binary

01:09:10,719 --> 01:09:14,319
and this will take just a moment here

01:09:14,640 --> 01:09:18,400
all right so it looks like that

01:09:15,839 --> 01:09:21,440
completed uh next thing we want to do

01:09:18,400 --> 01:09:23,759
is do our make image

01:09:21,440 --> 01:09:25,600
and that should go pretty fast since

01:09:23,759 --> 01:09:27,040
we're using a lot of the same layers

01:09:25,600 --> 01:09:28,719
here

01:09:27,040 --> 01:09:31,920
i do have a little bit of latency it

01:09:28,719 --> 01:09:34,799
looks like on my side

01:09:31,920 --> 01:09:35,839
but shouldn't take too long obviously it

01:09:34,799 --> 01:09:38,480
would be a good thing to

01:09:35,839 --> 01:09:41,440
cache some of these module dependencies

01:09:38,480 --> 01:09:41,440
here in the future

01:09:41,839 --> 01:09:45,120
and once our image finishes building we

01:09:44,319 --> 01:09:49,279
can go ahead

01:09:45,120 --> 01:09:50,640
and do make push make image push

01:09:49,279 --> 01:09:53,520
i think i've forgotten that one twice

01:09:50,640 --> 01:09:57,679
now alright so that's going to push that

01:09:53,520 --> 01:09:59,040
up to our registry with v0.0.2

01:09:57,679 --> 01:10:02,640
and the last thing we're going to want

01:09:59,040 --> 01:10:05,520
to do is rebuild our package image here

01:10:02,640 --> 01:10:05,520
to point to that

01:10:06,800 --> 01:10:10,000
and i wish my network was a little

01:10:08,960 --> 01:10:13,600
faster but

01:10:10,000 --> 01:10:13,600
it's almost done it looks like

01:10:15,280 --> 01:10:19,840
all right let's go into that package

01:10:17,040 --> 01:10:23,280
directory k cross plane

01:10:19,840 --> 01:10:24,640
build provider

01:10:23,280 --> 01:10:26,239
once again we see it here you'll see

01:10:24,640 --> 01:10:27,280
that the digest has changed and we're

01:10:26,239 --> 01:10:30,640
going to go ahead

01:10:27,280 --> 01:10:33,520
and push that up to the registry

01:10:30,640 --> 01:10:35,360
so push provider and this time it's

01:10:33,520 --> 01:10:39,040
going to be hashdan

01:10:35,360 --> 01:10:43,040
kc provider github

01:10:39,040 --> 01:10:46,080
and v0.0.2 so we're going to match that

01:10:43,040 --> 01:10:48,320
controller image and we should see that

01:10:46,080 --> 01:10:50,320
pushed up successfully

01:10:48,320 --> 01:10:52,080
and now what we want to do is actually

01:10:50,320 --> 01:10:55,440
update our provider

01:10:52,080 --> 01:10:58,960
that exists in the cluster so let's

01:10:55,440 --> 01:11:02,320
look at our provider so we have it here

01:10:58,960 --> 01:11:06,080
and we're using that 0.0.1

01:11:02,320 --> 01:11:09,760
image so let's go ahead and edit that

01:11:06,080 --> 01:11:09,760
and we'll bump it to

01:11:10,840 --> 01:11:13,840
0.0.2

01:11:18,000 --> 01:11:21,679
all right and we should see if we get

01:11:20,000 --> 01:11:22,960
that provider package again that it's

01:11:21,679 --> 01:11:24,800
healthy and true

01:11:22,960 --> 01:11:26,560
and we should actually see that the

01:11:24,800 --> 01:11:28,400
controller has been switched out here so

01:11:26,560 --> 01:11:30,239
you'll see the old one is terminating

01:11:28,400 --> 01:11:33,520
you'll see this new digest actually

01:11:30,239 --> 01:11:35,679
present so that matches our image digest

01:11:33,520 --> 01:11:36,719
and we should see that our new

01:11:35,679 --> 01:11:39,280
controller is running

01:11:36,719 --> 01:11:40,000
we should see that we have all the same

01:11:39,280 --> 01:11:43,760
crds

01:11:40,000 --> 01:11:46,080
plus our membership one

01:11:43,760 --> 01:11:47,040
so there we'll see our membership crd

01:11:46,080 --> 01:11:49,280
and we should also

01:11:47,040 --> 01:11:50,960
still see that our team exists and

01:11:49,280 --> 01:11:51,760
that's true so our team exists it's

01:11:50,960 --> 01:11:54,000
still synced

01:11:51,760 --> 01:11:55,840
uh we didn't delete that or clean it up

01:11:54,000 --> 01:11:56,800
and we've automatically upgraded our

01:11:55,840 --> 01:12:00,480
provider here

01:11:56,800 --> 01:12:00,480
to pick up our new versions

01:12:01,120 --> 01:12:05,199
okay so the last thing we want to look

01:12:03,199 --> 01:12:07,040
at today is how we can compose these

01:12:05,199 --> 01:12:08,480
manage resources that we've created for

01:12:07,040 --> 01:12:09,840
this provider we're going to show a

01:12:08,480 --> 01:12:12,159
pretty simple example

01:12:09,840 --> 01:12:14,159
but we have another type of package in

01:12:12,159 --> 01:12:16,159
cross plane other than provider

01:12:14,159 --> 01:12:17,199
and that would be the configuration

01:12:16,159 --> 01:12:18,640
package type

01:12:17,199 --> 01:12:20,320
you can see here you can declare

01:12:18,640 --> 01:12:22,159
dependencies on providers and what a

01:12:20,320 --> 01:12:24,159
configuration package does

01:12:22,159 --> 01:12:25,840
is it combines different infrastructure

01:12:24,159 --> 01:12:26,719
primitives in this case we're going to

01:12:25,840 --> 01:12:28,800
use our team

01:12:26,719 --> 01:12:31,199
and our membership into a higher level

01:12:28,800 --> 01:12:32,320
object this is kind of a trivial example

01:12:31,199 --> 01:12:36,000
but you can imagine

01:12:32,320 --> 01:12:38,640
that if you were using gcp or aws or

01:12:36,000 --> 01:12:39,280
azure and you wanted to define a vpc and

01:12:38,640 --> 01:12:42,480
then put

01:12:39,280 --> 01:12:44,400
an rds instance in that and also an eks

01:12:42,480 --> 01:12:46,640
cluster and have those all wired up

01:12:44,400 --> 01:12:47,920
and present that to users or developers

01:12:46,640 --> 01:12:49,920
within your organization

01:12:47,920 --> 01:12:51,360
as a simple abstraction this could be

01:12:49,920 --> 01:12:53,040
really useful

01:12:51,360 --> 01:12:54,719
the other nice thing about this is the

01:12:53,040 --> 01:12:55,360
ability to declare dependencies on

01:12:54,719 --> 01:12:56,960
providers

01:12:55,360 --> 01:12:59,040
so you can imagine if you were creating

01:12:56,960 --> 01:13:00,000
a networked database and cluster

01:12:59,040 --> 01:13:02,159
abstraction

01:13:00,000 --> 01:13:03,840
that you could declare dependencies on

01:13:02,159 --> 01:13:04,880
three different providers have them all

01:13:03,840 --> 01:13:06,159
installed

01:13:04,880 --> 01:13:08,320
then you could create what we call

01:13:06,159 --> 01:13:10,320
composite resource definition

01:13:08,320 --> 01:13:11,679
which declares the schema this looks a

01:13:10,320 --> 01:13:14,320
lot like a crd in fact

01:13:11,679 --> 01:13:16,080
actually renders out a crd that you

01:13:14,320 --> 01:13:17,679
declare the abstract schema

01:13:16,080 --> 01:13:19,440
so in this case we're just going to say

01:13:17,679 --> 01:13:21,040
give us the org and user

01:13:19,440 --> 01:13:22,800
and we're going to create a team and a

01:13:21,040 --> 01:13:23,520
membership for that user to the team on

01:13:22,800 --> 01:13:25,280
the back end

01:13:23,520 --> 01:13:26,960
you can imagine that we could say give

01:13:25,280 --> 01:13:29,920
us your database size and

01:13:26,960 --> 01:13:31,520
node pool size for your cluster um and

01:13:29,920 --> 01:13:33,199
create you know a more complex

01:13:31,520 --> 01:13:34,880
abstraction there

01:13:33,199 --> 01:13:36,640
and then we can have an arbitrary number

01:13:34,880 --> 01:13:40,000
of compositions

01:13:36,640 --> 01:13:42,080
um that satisfy a composite resource

01:13:40,000 --> 01:13:45,520
definition or xrd as we call it

01:13:42,080 --> 01:13:48,320
for short and these basically tell how

01:13:45,520 --> 01:13:48,960
a abstraction is satisfied so in this

01:13:48,320 --> 01:13:50,640
case

01:13:48,960 --> 01:13:53,440
we're going to satisfy it with a github

01:13:50,640 --> 01:13:56,080
team and a github membership

01:13:53,440 --> 01:13:56,960
you know in the in the more complex case

01:13:56,080 --> 01:13:59,280
you could have

01:13:56,960 --> 01:14:01,840
different cloud providers backing a

01:13:59,280 --> 01:14:03,280
single abstraction or you could have

01:14:01,840 --> 01:14:06,159
different configurations on a single

01:14:03,280 --> 01:14:08,080
cloud provider or on-prem and in cluster

01:14:06,159 --> 01:14:09,360
all these sorts of variations that can

01:14:08,080 --> 01:14:11,280
satisfy definition

01:14:09,360 --> 01:14:13,600
really allowing you to define your own

01:14:11,280 --> 01:14:16,400
platform and your own console

01:14:13,600 --> 01:14:17,920
for consuming resources so we can

01:14:16,400 --> 01:14:18,960
package these up just like we did a

01:14:17,920 --> 01:14:20,719
provider

01:14:18,960 --> 01:14:22,159
and push them to a registry and also be

01:14:20,719 --> 01:14:22,960
able to install them and when they're

01:14:22,159 --> 01:14:24,400
installed they're

01:14:22,960 --> 01:14:26,320
going to automatically do things like

01:14:24,400 --> 01:14:27,520
check the cross plane version make sure

01:14:26,320 --> 01:14:29,520
all dependencies are there

01:14:27,520 --> 01:14:30,960
install dependencies if they're missing

01:14:29,520 --> 01:14:32,880
etc

01:14:30,960 --> 01:14:34,880
so let's go ahead and do that um so i'll

01:14:32,880 --> 01:14:36,480
go into the configuration directory and

01:14:34,880 --> 01:14:37,840
you'll see this is a lot like how we

01:14:36,480 --> 01:14:41,280
package the provider

01:14:37,840 --> 01:14:45,679
so we'll do k cross plane

01:14:41,280 --> 01:14:48,880
build configuration

01:14:45,679 --> 01:14:51,280
and that'll build our configuration once

01:14:48,880 --> 01:14:52,960
again we see our x package here i call

01:14:51,280 --> 01:14:55,760
this our source control

01:14:52,960 --> 01:14:56,080
platform as a service so let's go ahead

01:14:55,760 --> 01:14:59,040
and

01:14:56,080 --> 01:14:59,679
also push that so we'll say k cross

01:14:59,040 --> 01:15:03,600
plane

01:14:59,679 --> 01:15:07,600
push configuration and

01:15:03,600 --> 01:15:07,600
we'll call it source control pass

01:15:07,920 --> 01:15:14,159
control has v0.0.1

01:15:12,880 --> 01:15:16,880
so once again this is going to put you

01:15:14,159 --> 01:15:16,880
to the registry

01:15:17,040 --> 01:15:22,480
and once that completes remember that we

01:15:20,480 --> 01:15:23,760
do have provider github already present

01:15:22,480 --> 01:15:25,679
here so it's going to see that that

01:15:23,760 --> 01:15:26,480
provider has already been installed and

01:15:25,679 --> 01:15:29,360
won't have to do

01:15:26,480 --> 01:15:30,960
any extra installation it'll just bring

01:15:29,360 --> 01:15:32,320
these composite types that we were

01:15:30,960 --> 01:15:36,239
talking about

01:15:32,320 --> 01:15:40,080
so we can go ahead and k crossplane

01:15:36,239 --> 01:15:43,920
install configuration

01:15:40,080 --> 01:15:43,920
and i'm just going to copy paste this in

01:15:45,280 --> 01:15:48,560
and now we can do things like look at

01:15:47,520 --> 01:15:50,080
our configuration

01:15:48,560 --> 01:15:52,000
see what version it's using it's already

01:15:50,080 --> 01:15:54,880
installed and healthy and what we should

01:15:52,000 --> 01:15:55,840
see is the xrd and composition we

01:15:54,880 --> 01:15:59,120
installed are now

01:15:55,840 --> 01:16:01,520
present in the cluster the xrd

01:15:59,120 --> 01:16:03,040
actually creates other crds for us to be

01:16:01,520 --> 01:16:04,800
able to actually create instances of

01:16:03,040 --> 01:16:09,679
this abstract type

01:16:04,800 --> 01:16:09,679
so we should see that there is a

01:16:10,560 --> 01:16:14,880
user teams crd here and i can now create

01:16:13,199 --> 01:16:17,120
instances of it so let's look at what an

01:16:14,880 --> 01:16:19,120
instance of that might look like

01:16:17,120 --> 01:16:20,719
if we go down i've created an example

01:16:19,120 --> 01:16:22,719
here so here we're going to create a

01:16:20,719 --> 01:16:23,600
user team we want it to be called user

01:16:22,719 --> 01:16:24,800
team

01:16:23,600 --> 01:16:26,880
and we're saying we want it in this

01:16:24,800 --> 01:16:29,120
cubecon n a org and we're going to say

01:16:26,880 --> 01:16:31,679
we want user stephen d barely

01:16:29,120 --> 01:16:33,199
in it so this is actually going to

01:16:31,679 --> 01:16:37,679
create a user team

01:16:33,199 --> 01:16:38,880
team as well as add steven to that team

01:16:37,679 --> 01:16:42,000
and behind the scenes it's going to

01:16:38,880 --> 01:16:44,320
render out a membership and team here

01:16:42,000 --> 01:16:46,840
so once again kind of a trivial example

01:16:44,320 --> 01:16:48,159
but it does show the power of this model

01:16:46,840 --> 01:16:50,960
here

01:16:48,159 --> 01:16:52,400
all right so examples i need to get out

01:16:50,960 --> 01:16:56,719
of this directory

01:16:52,400 --> 01:17:00,560
okay apply dash f examples

01:16:56,719 --> 01:17:02,640
org user team

01:17:00,560 --> 01:17:04,400
all right and if we actually look at the

01:17:02,640 --> 01:17:06,000
rendered out resources

01:17:04,400 --> 01:17:07,920
um this should take a minute for it to

01:17:06,000 --> 01:17:08,880
become ready but we can look at the user

01:17:07,920 --> 01:17:10,800
team itself

01:17:08,880 --> 01:17:12,800
which is what the the user is

01:17:10,800 --> 01:17:14,640
interacting with so a developer who just

01:17:12,800 --> 01:17:16,719
wants a team with the user so they don't

01:17:14,640 --> 01:17:19,760
only care about the status of this

01:17:16,719 --> 01:17:21,440
but being infrastructure aware we are

01:17:19,760 --> 01:17:22,320
going to look at the actual rendered out

01:17:21,440 --> 01:17:23,840
resources

01:17:22,320 --> 01:17:26,719
it looks like our team has now become

01:17:23,840 --> 01:17:29,120
ready and let's see if our membership

01:17:26,719 --> 01:17:32,400
has as well

01:17:29,120 --> 01:17:34,719
yep our membership is also ready um

01:17:32,400 --> 01:17:36,320
and that will result in the abstract

01:17:34,719 --> 01:17:38,239
resource also becoming ready

01:17:36,320 --> 01:17:41,520
and if we go over and look at our

01:17:38,239 --> 01:17:41,520
kubecon n a org

01:17:41,600 --> 01:17:45,280
we should see that our user team is

01:17:43,840 --> 01:17:47,520
present here

01:17:45,280 --> 01:17:48,400
and you'll see that both steven and i

01:17:47,520 --> 01:17:49,920
are in it

01:17:48,400 --> 01:17:52,400
and we have the description that we

01:17:49,920 --> 01:17:52,960
defined and that's a good thing to point

01:17:52,400 --> 01:17:54,800
out there

01:17:52,960 --> 01:17:56,320
is in the composition you can have

01:17:54,800 --> 01:17:58,640
arbitrary mappings from the

01:17:56,320 --> 01:18:00,560
abstraction to these base resources you

01:17:58,640 --> 01:18:02,159
can also have the resources reference

01:18:00,560 --> 01:18:04,719
each other so here we're saying

01:18:02,159 --> 01:18:05,840
please use the same team that's composed

01:18:04,719 --> 01:18:07,440
with me

01:18:05,840 --> 01:18:09,040
so you can kind of resolve those

01:18:07,440 --> 01:18:10,640
references automatically

01:18:09,040 --> 01:18:11,920
you can also set defaults so for

01:18:10,640 --> 01:18:13,040
instance we're not exposing the

01:18:11,920 --> 01:18:14,719
description

01:18:13,040 --> 01:18:16,400
and we're just saying please always set

01:18:14,719 --> 01:18:17,840
it to a composed team

01:18:16,400 --> 01:18:20,239
and you could decide if you wanted to

01:18:17,840 --> 01:18:22,800
expose more or less

01:18:20,239 --> 01:18:23,760
in the abstraction and also make parts

01:18:22,800 --> 01:18:27,199
of that optional

01:18:23,760 --> 01:18:27,760
or not all right so thanks for joining

01:18:27,199 --> 01:18:29,520
us today

01:18:27,760 --> 01:18:30,960
uh it's definitely a blast to go through

01:18:29,520 --> 01:18:33,440
actually implementing a

01:18:30,960 --> 01:18:35,280
kubernetes controller for crossplane uh

01:18:33,440 --> 01:18:37,719
please feel free to join us in the cross

01:18:35,280 --> 01:18:39,199
plane slack you can use this link here

01:18:37,719 --> 01:18:41,120
slack.crossplane.io

01:18:39,199 --> 01:18:43,360
set up an account and we'd love to chat

01:18:41,120 --> 01:18:45,040
with you and we'll also be in the chat

01:18:43,360 --> 01:18:47,120
here for the presentation

01:18:45,040 --> 01:18:48,560
um so if you have any questions or

01:18:47,120 --> 01:18:50,080
thoughts or want to talk to us

01:18:48,560 --> 01:18:51,679
afterwards please feel free to let us

01:18:50,080 --> 01:18:53,440
know and we'll stick around

01:18:51,679 --> 01:18:55,600
for any questions you may have thanks

01:18:53,440 --> 01:18:59,280
for joining us for today

01:18:55,600 --> 01:18:59,280

YouTube URL: https://www.youtube.com/watch?v=4ceaeaLYaPs


