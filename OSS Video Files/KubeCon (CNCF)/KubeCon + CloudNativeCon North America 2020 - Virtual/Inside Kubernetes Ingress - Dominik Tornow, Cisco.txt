Title: Inside Kubernetes Ingress - Dominik Tornow, Cisco
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4–7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Inside Kubernetes Ingress - Dominik Tornow, Cisco 

Kubernetes Ingress is a core abstraction of Kubernetes: K8s Ingress grants access to K8s HTTP Services from outside the K8s Cluster. In effect, K8s Ingress exposes your HTTP application to the outside world. However, even experienced K8s users struggle to reason about K8s Ingress end-to-end. Using a systems modeling approach, this presentation will explore K8s Ingress to connect the dots between K8s Nodes, K8s Services, K8s Endpoints, the Ingress Resource, and the Ingress Controller. You will leave with an accurate, concise, and holistic understanding of how Kubernetes Ingress - in concert with other core Kubernetes Resources - enables scalable and reliable applications hosted on Kubernetes. Walk away with a dependable mental model of every aspect of Kubernetes Ingress and comfortably contrast K8s Ingress with alternative abstractions like the Ambassador API Gateway. 

https://sched.co/ekAL
Captions: 
	00:00:01,680 --> 00:00:06,000
hello and welcome to

00:00:03,280 --> 00:00:07,040
inside kubernetes ingress a kubecon and

00:00:06,000 --> 00:00:11,440
cloud nativecon

00:00:07,040 --> 00:00:11,440
north america 2020 presentation

00:00:11,679 --> 00:00:15,519
i am dominic torno principal engineer at

00:00:14,400 --> 00:00:18,320
cisco

00:00:15,519 --> 00:00:20,240
i focus on systems modeling specifically

00:00:18,320 --> 00:00:22,080
conceptual and formal modeling

00:00:20,240 --> 00:00:23,920
to support the development and the

00:00:22,080 --> 00:00:25,439
documentation of complex software

00:00:23,920 --> 00:00:27,680
systems

00:00:25,439 --> 00:00:28,880
this presentation focuses on the

00:00:27,680 --> 00:00:31,679
concepts behind

00:00:28,880 --> 00:00:33,840
ingress for kubernetes it does not focus

00:00:31,679 --> 00:00:37,600
on its possible implementations

00:00:33,840 --> 00:00:37,600
or on its possible set of features

00:00:38,399 --> 00:00:42,559
kubernetes ingress is related to

00:00:40,559 --> 00:00:45,440
kubernetes services

00:00:42,559 --> 00:00:45,920
to deep dive into kubernetes services

00:00:45,440 --> 00:00:48,960
visit

00:00:45,920 --> 00:00:50,079
inside kubernetes services a kubecon and

00:00:48,960 --> 00:00:54,960
cloud nativecon

00:00:50,079 --> 00:00:54,960
north america 2019 presentation

00:00:55,199 --> 00:00:59,600
what problem does increase for

00:00:56,879 --> 00:01:02,079
kubernetes address

00:00:59,600 --> 00:01:03,600
ingress for kubernetes enables the

00:01:02,079 --> 00:01:07,119
external consumption

00:01:03,600 --> 00:01:10,159
of a set of kubernetes http services

00:01:07,119 --> 00:01:13,840
hosted on one cluster via one

00:01:10,159 --> 00:01:13,840
http endpoint

00:01:15,360 --> 00:01:19,280
how does ingress for kubernetes address

00:01:17,200 --> 00:01:21,600
this problem

00:01:19,280 --> 00:01:24,159
to enable the external consumption of a

00:01:21,600 --> 00:01:26,799
set of kubernetes http services

00:01:24,159 --> 00:01:28,000
hosted on one cluster via one http

00:01:26,799 --> 00:01:29,920
endpoint

00:01:28,000 --> 00:01:31,680
ingress for kubernetes addresses two

00:01:29,920 --> 00:01:33,920
different concerns

00:01:31,680 --> 00:01:35,680
network ingress as well as kubernetes

00:01:33,920 --> 00:01:38,479
ingress

00:01:35,680 --> 00:01:39,680
network ingress addresses the question

00:01:38,479 --> 00:01:42,560
of how to emit

00:01:39,680 --> 00:01:43,119
traffic into the cluster kubernetes

00:01:42,560 --> 00:01:45,840
ingress

00:01:43,119 --> 00:01:46,399
addresses a question of how to route

00:01:45,840 --> 00:01:50,159
traffic

00:01:46,399 --> 00:01:52,079
within the cluster a kubernetes cluster

00:01:50,159 --> 00:01:53,520
is typically defined as a set of

00:01:52,079 --> 00:01:56,240
kubernetes nodes

00:01:53,520 --> 00:01:57,119
a set of physical or virtual machines

00:01:56,240 --> 00:01:59,040
however

00:01:57,119 --> 00:02:02,000
this presentation is not concerned with

00:01:59,040 --> 00:02:05,439
nodes so we will reason about a cluster

00:02:02,000 --> 00:02:06,000
as a set of parts that run run or will

00:02:05,439 --> 00:02:09,920
run

00:02:06,000 --> 00:02:11,760
on the cluster's nodes the first topic

00:02:09,920 --> 00:02:13,200
of this presentation will discuss

00:02:11,760 --> 00:02:16,640
network ingress

00:02:13,200 --> 00:02:19,120
the admission of traffic however

00:02:16,640 --> 00:02:20,879
as kubernetes does not specify how to

00:02:19,120 --> 00:02:23,040
implement network ingress

00:02:20,879 --> 00:02:25,360
leaving the implementation up to the

00:02:23,040 --> 00:02:27,680
operator of a kubernetes cluster

00:02:25,360 --> 00:02:28,959
we will discuss only the what not the

00:02:27,680 --> 00:02:31,120
how

00:02:28,959 --> 00:02:32,000
the second topic of this presentation

00:02:31,120 --> 00:02:34,480
will discuss

00:02:32,000 --> 00:02:35,360
kubernetes ingress the routing of

00:02:34,480 --> 00:02:37,840
traffic

00:02:35,360 --> 00:02:40,080
we will discuss both the what and the

00:02:37,840 --> 00:02:42,319
how

00:02:40,080 --> 00:02:43,599
before we develop a definition of

00:02:42,319 --> 00:02:45,519
ingress for kubernetes

00:02:43,599 --> 00:02:48,840
we will spend the next few minutes to

00:02:45,519 --> 00:02:50,800
develop an intuition of ingress for

00:02:48,840 --> 00:02:52,879
kubernetes

00:02:50,800 --> 00:02:54,400
in order to develop an intuition of

00:02:52,879 --> 00:02:56,879
ingress for kubernetes

00:02:54,400 --> 00:02:57,920
we will develop an intuition of both

00:02:56,879 --> 00:03:01,280
network ingress

00:02:57,920 --> 00:03:05,840
and kubernetes ingress first up

00:03:01,280 --> 00:03:05,840
network ingress the admission of traffic

00:03:06,400 --> 00:03:10,400
let there be two communicating endpoints

00:03:08,879 --> 00:03:13,200
a service consumer

00:03:10,400 --> 00:03:15,680
and a service provider the service

00:03:13,200 --> 00:03:16,560
consumer is not hosted on the kubernetes

00:03:15,680 --> 00:03:19,599
cluster

00:03:16,560 --> 00:03:22,239
it is external the service provider

00:03:19,599 --> 00:03:24,319
is hosted on the kubernetes cluster it

00:03:22,239 --> 00:03:26,720
is internal

00:03:24,319 --> 00:03:28,720
network ingress denotes the point or

00:03:26,720 --> 00:03:31,599
means of admission

00:03:28,720 --> 00:03:33,040
furthermore network ingress implies

00:03:31,599 --> 00:03:36,959
directionality

00:03:33,040 --> 00:03:40,080
crossing from external to internal

00:03:36,959 --> 00:03:42,159
next up kubernetes ingress the routing

00:03:40,080 --> 00:03:44,840
of traffic

00:03:42,159 --> 00:03:46,159
previously there were two communicating

00:03:44,840 --> 00:03:48,319
endpoints

00:03:46,159 --> 00:03:49,760
a service consumer and a service

00:03:48,319 --> 00:03:51,680
provider

00:03:49,760 --> 00:03:53,920
the service consumer has to learn the

00:03:51,680 --> 00:03:57,120
address of the service provider

00:03:53,920 --> 00:04:00,400
to actually consume the provided service

00:03:57,120 --> 00:04:03,519
however a persistent trend complicates

00:04:00,400 --> 00:04:04,159
this picture one monolithic service

00:04:03,519 --> 00:04:06,959
provider

00:04:04,159 --> 00:04:09,120
is broken up into many service providers

00:04:06,959 --> 00:04:11,599
microservices

00:04:09,120 --> 00:04:14,159
now the service consumer has to learn

00:04:11,599 --> 00:04:17,439
the address of each service provider

00:04:14,159 --> 00:04:17,439
to consume the services

00:04:18,320 --> 00:04:22,240
kubernetes ingress is a proxy an api

00:04:21,280 --> 00:04:24,720
gateway

00:04:22,240 --> 00:04:26,479
that exposes multiple service providers

00:04:24,720 --> 00:04:28,880
as a single endpoint

00:04:26,479 --> 00:04:31,600
therefore greatly simplifying consuming

00:04:28,880 --> 00:04:31,600
the services

00:04:32,080 --> 00:04:36,800
putting both together ingress for

00:04:35,520 --> 00:04:38,800
kubernetes

00:04:36,800 --> 00:04:40,560
is the composition of network ingress

00:04:38,800 --> 00:04:42,560
and kubernetes ingress

00:04:40,560 --> 00:04:45,040
where network ingress is the admission

00:04:42,560 --> 00:04:47,280
of traffic into the kubernetes cluster

00:04:45,040 --> 00:04:50,000
and kubernetes ingress is the routing of

00:04:47,280 --> 00:04:53,120
traffic within the kubernetes cluster

00:04:50,000 --> 00:04:56,639
in effect kubernetes ingress

00:04:53,120 --> 00:04:58,560
is an api gateway

00:04:56,639 --> 00:05:00,880
with an intuition of ingress for

00:04:58,560 --> 00:05:01,680
kubernetes we will spend the rest of the

00:05:00,880 --> 00:05:04,240
presentation

00:05:01,680 --> 00:05:07,199
to develop a set of related definitions

00:05:04,240 --> 00:05:09,280
of ingress for kubernetes

00:05:07,199 --> 00:05:10,800
in order to develop definitions for

00:05:09,280 --> 00:05:13,039
ingress for kubernetes

00:05:10,800 --> 00:05:14,800
we will once again develop definitions

00:05:13,039 --> 00:05:18,800
for both network ingress

00:05:14,800 --> 00:05:24,080
and kubernetes ingress so first up

00:05:18,800 --> 00:05:26,400
network ingress the admission of traffic

00:05:24,080 --> 00:05:27,280
in software engineering a distributed

00:05:26,400 --> 00:05:29,840
system

00:05:27,280 --> 00:05:30,880
is an unbounded set of components from

00:05:29,840 --> 00:05:33,919
here on out called

00:05:30,880 --> 00:05:37,280
endpoints endpoints communicate

00:05:33,919 --> 00:05:40,240
by exchanging messages via a network

00:05:37,280 --> 00:05:42,160
the behavior of a distributed system is

00:05:40,240 --> 00:05:43,280
attributed to the behavior of its

00:05:42,160 --> 00:05:46,080
endpoints

00:05:43,280 --> 00:05:48,320
and the communication between them the

00:05:46,080 --> 00:05:50,479
complexity of a distributed system

00:05:48,320 --> 00:05:52,479
is attributed to the autonomy of its

00:05:50,479 --> 00:05:54,560
endpoints and the intricacy of the

00:05:52,479 --> 00:05:57,039
communication between them

00:05:54,560 --> 00:05:58,960
without loss of generality let's focus

00:05:57,039 --> 00:06:02,560
this discussion on two endpoints

00:05:58,960 --> 00:06:02,560
e1 and e2

00:06:03,840 --> 00:06:08,960
an endpoint is connected to the network

00:06:06,160 --> 00:06:11,360
via a channel

00:06:08,960 --> 00:06:15,360
the network maintains an association

00:06:11,360 --> 00:06:15,360
between endpoints and addresses

00:06:15,520 --> 00:06:19,199
from here on out we will graphically

00:06:17,360 --> 00:06:21,120
represent this association

00:06:19,199 --> 00:06:23,520
as if the address is a property of the

00:06:21,120 --> 00:06:23,520
channel

00:06:23,840 --> 00:06:27,680
we keep track of the sequence of send

00:06:26,080 --> 00:06:30,880
events and receive events

00:06:27,680 --> 00:06:32,639
in an endpoint's history if an endpoint

00:06:30,880 --> 00:06:34,960
wants to send a message

00:06:32,639 --> 00:06:37,199
it will place that message in its

00:06:34,960 --> 00:06:39,440
channel

00:06:37,199 --> 00:06:43,840
an endpoint placing a message in its

00:06:39,440 --> 00:06:46,080
channel is represented by a send event

00:06:43,840 --> 00:06:48,080
the network picks up the message from

00:06:46,080 --> 00:06:50,240
the sending endpoints channel

00:06:48,080 --> 00:06:52,000
and determines the receiving endpoints

00:06:50,240 --> 00:06:55,280
channel and places

00:06:52,000 --> 00:06:56,800
the message in that channel the network

00:06:55,280 --> 00:06:59,520
placing a message

00:06:56,800 --> 00:07:03,840
in an endpoints channel is represented

00:06:59,520 --> 00:07:03,840
by a receive event

00:07:03,919 --> 00:07:08,479
in this network model send events are

00:07:06,400 --> 00:07:10,639
tagged with a target address

00:07:08,479 --> 00:07:12,400
the network places a message in the

00:07:10,639 --> 00:07:15,199
channel of the endpoint

00:07:12,400 --> 00:07:17,440
whose address matches the message target

00:07:15,199 --> 00:07:20,080
address

00:07:17,440 --> 00:07:22,319
this can also be represented graphically

00:07:20,080 --> 00:07:24,639
as a time space diagram

00:07:22,319 --> 00:07:25,759
each timeline represents an endpoint's

00:07:24,639 --> 00:07:28,479
history

00:07:25,759 --> 00:07:29,440
empty circles represent send events

00:07:28,479 --> 00:07:32,960
filled circles

00:07:29,440 --> 00:07:32,960
represent receive events

00:07:33,199 --> 00:07:37,599
a pair or tuple of corresponding send

00:07:36,160 --> 00:07:40,960
and receive events

00:07:37,599 --> 00:07:43,440
is called a flow so far we have applied

00:07:40,960 --> 00:07:45,919
a global point of view

00:07:43,440 --> 00:07:46,720
in this model we are able to take the

00:07:45,919 --> 00:07:49,199
viewpoint

00:07:46,720 --> 00:07:49,840
of the all-knowing observer we can

00:07:49,199 --> 00:07:52,960
observe

00:07:49,840 --> 00:07:56,080
both the channels of e1 and e2

00:07:52,960 --> 00:07:59,840
at the same time conversely

00:07:56,080 --> 00:07:59,840
e1 or e2 cannot

00:08:01,919 --> 00:08:08,879
e1 can only observe its own channel

00:08:05,840 --> 00:08:11,520
and in our model its own address it

00:08:08,879 --> 00:08:14,960
simply cannot reach beyond

00:08:11,520 --> 00:08:18,240
the same is true for e2 e2

00:08:14,960 --> 00:08:18,639
can only observe its own channel and its

00:08:18,240 --> 00:08:22,400
own

00:08:18,639 --> 00:08:25,440
address so in order for e1

00:08:22,400 --> 00:08:29,199
to send a message to e2 1

00:08:25,440 --> 00:08:33,039
first has to learn the address of e2

00:08:29,199 --> 00:08:36,080
the same is true for e2 in order for e2

00:08:33,039 --> 00:08:38,959
to send a message to e1 e2

00:08:36,080 --> 00:08:42,959
first has to learn the address of e1 a

00:08:38,959 --> 00:08:42,959
process called endpoint discovery

00:08:43,919 --> 00:08:47,120
moving towards the kubernetes network

00:08:46,080 --> 00:08:49,680
model

00:08:47,120 --> 00:08:50,320
in kubernetes network addressable

00:08:49,680 --> 00:08:53,600
endpoints

00:08:50,320 --> 00:08:54,800
are parts the kubernetes network model

00:08:53,600 --> 00:08:57,680
specifies

00:08:54,800 --> 00:08:58,320
that any part can communicate with all

00:08:57,680 --> 00:09:02,080
parts

00:08:58,320 --> 00:09:02,080
without network address translation

00:09:02,320 --> 00:09:05,920
the kubernetes network model does not

00:09:04,720 --> 00:09:08,480
specify

00:09:05,920 --> 00:09:10,720
whether external endpoints can or cannot

00:09:08,480 --> 00:09:14,000
communicate with parts

00:09:10,720 --> 00:09:17,120
as a consequence depending on your

00:09:14,000 --> 00:09:20,480
cluster network ingress may be trivial

00:09:17,120 --> 00:09:20,480
or complex to implement

00:09:21,279 --> 00:09:24,959
as we discussed earlier we separate the

00:09:23,760 --> 00:09:27,200
set of endpoints

00:09:24,959 --> 00:09:29,040
into external endpoints and internal

00:09:27,200 --> 00:09:33,040
endpoints who communicate

00:09:29,040 --> 00:09:33,040
across that line of separation

00:09:33,200 --> 00:09:38,720
here we consider endpoints 1 through 4

00:09:36,240 --> 00:09:39,440
as being external endpoints and 5

00:09:38,720 --> 00:09:42,800
through 8

00:09:39,440 --> 00:09:45,200
as being internal endpoints in effect

00:09:42,800 --> 00:09:45,200
parts

00:09:46,399 --> 00:09:50,000
given the separation of endpoints into

00:09:48,880 --> 00:09:52,240
external and internal

00:09:50,000 --> 00:09:53,600
endpoints we can classify the

00:09:52,240 --> 00:09:55,839
communication between

00:09:53,600 --> 00:09:57,360
endpoints according to the membership of

00:09:55,839 --> 00:09:59,040
the source and target of the

00:09:57,360 --> 00:10:03,040
communication

00:09:59,040 --> 00:10:03,040
there are four possible combinations

00:10:03,279 --> 00:10:06,800
in the first combination source is a

00:10:06,240 --> 00:10:10,000
member

00:10:06,800 --> 00:10:11,440
of the set of external endpoints and

00:10:10,000 --> 00:10:15,120
target is a member

00:10:11,440 --> 00:10:18,000
of the set of external endpoints

00:10:15,120 --> 00:10:20,480
this particular type of flow does not

00:10:18,000 --> 00:10:23,279
have a name

00:10:20,480 --> 00:10:26,079
in the second combination source is a

00:10:23,279 --> 00:10:28,240
member of the set of external endpoints

00:10:26,079 --> 00:10:30,640
and target is a member of the set of

00:10:28,240 --> 00:10:33,279
internal endpoints

00:10:30,640 --> 00:10:33,680
this particular type of flow is called

00:10:33,279 --> 00:10:36,760
north

00:10:33,680 --> 00:10:38,320
south traffic in addition given the

00:10:36,760 --> 00:10:41,200
directionality

00:10:38,320 --> 00:10:43,120
this combination constitutes network

00:10:41,200 --> 00:10:46,320
ingress

00:10:43,120 --> 00:10:47,120
in the third combination source is a

00:10:46,320 --> 00:10:49,920
member

00:10:47,120 --> 00:10:50,480
of the set of internal endpoints and

00:10:49,920 --> 00:10:52,800
target

00:10:50,480 --> 00:10:54,720
is a member of the set of external

00:10:52,800 --> 00:10:57,600
endpoints

00:10:54,720 --> 00:10:58,160
this particular type of flow is again

00:10:57,600 --> 00:11:01,760
called

00:10:58,160 --> 00:11:04,079
north south traffic in addition

00:11:01,760 --> 00:11:05,200
given the directionality this

00:11:04,079 --> 00:11:09,360
combination

00:11:05,200 --> 00:11:09,360
constitutes network egress

00:11:09,600 --> 00:11:13,519
in the fourth and love combination

00:11:11,760 --> 00:11:14,000
source is a member of the set of

00:11:13,519 --> 00:11:16,640
internal

00:11:14,000 --> 00:11:19,360
endpoints and target is a member of the

00:11:16,640 --> 00:11:22,320
set of internal endpoints

00:11:19,360 --> 00:11:22,800
this particular type of flow is called

00:11:22,320 --> 00:11:26,880
west

00:11:22,800 --> 00:11:29,120
east traffic so in conclusion

00:11:26,880 --> 00:11:30,800
network ingress can be defined as the

00:11:29,120 --> 00:11:33,440
set of all flows

00:11:30,800 --> 00:11:34,240
that originate outside the cluster and

00:11:33,440 --> 00:11:37,200
terminate

00:11:34,240 --> 00:11:37,200
inside the cluster

00:11:37,519 --> 00:11:42,720
next up kubernetes ingress the routing

00:11:41,040 --> 00:11:45,040
of traffic

00:11:42,720 --> 00:11:46,160
kubernetes defines a kubernetes ingress

00:11:45,040 --> 00:11:48,800
object

00:11:46,160 --> 00:11:50,399
in effect the kubernetes ingress object

00:11:48,800 --> 00:11:54,160
defines a collection

00:11:50,399 --> 00:11:56,000
of http request level routing rules

00:11:54,160 --> 00:11:58,480
that determine the target of that

00:11:56,000 --> 00:12:01,760
request

00:11:58,480 --> 00:12:05,279
ingress matches an http requests

00:12:01,760 --> 00:12:06,000
path and host header against its routing

00:12:05,279 --> 00:12:08,720
rules

00:12:06,000 --> 00:12:09,440
to determine the target kubernetes

00:12:08,720 --> 00:12:12,800
service

00:12:09,440 --> 00:12:15,120
to proxy the request tool

00:12:12,800 --> 00:12:16,639
this example illustrates a kubernetes

00:12:15,120 --> 00:12:19,279
ingress object

00:12:16,639 --> 00:12:20,160
in effect this ingress object defines a

00:12:19,279 --> 00:12:23,680
collection

00:12:20,160 --> 00:12:26,160
of four request level routing rules

00:12:23,680 --> 00:12:27,120
in my personal opinion these are best

00:12:26,160 --> 00:12:30,160
represented

00:12:27,120 --> 00:12:30,160
as a decision table

00:12:30,240 --> 00:12:35,120
for example the first rule matches an

00:12:32,800 --> 00:12:36,160
http request with a host header of

00:12:35,120 --> 00:12:39,920
food.org

00:12:36,160 --> 00:12:42,800
and a path of slash a to proxy to a part

00:12:39,920 --> 00:12:43,279
that matches a service named foo a on

00:12:42,800 --> 00:12:47,440
port

00:12:43,279 --> 00:12:50,480
8080 again represented as a row

00:12:47,440 --> 00:12:50,480
in the decision table

00:12:51,200 --> 00:12:57,519
the third rule matches an http request

00:12:54,320 --> 00:13:01,120
with a host header of bar.org

00:12:57,519 --> 00:13:04,000
and a path of slash a to proxy to a pod

00:13:01,120 --> 00:13:04,839
that matches a service named bar a on

00:13:04,000 --> 00:13:08,560
port

00:13:04,839 --> 00:13:10,720
9090. and again

00:13:08,560 --> 00:13:13,040
represented as a row in the decision

00:13:10,720 --> 00:13:13,040
table

00:13:13,839 --> 00:13:19,440
represented as a time space diagram

00:13:17,440 --> 00:13:21,279
when the kubernetes ingress proxy

00:13:19,440 --> 00:13:23,680
receives a request

00:13:21,279 --> 00:13:25,120
it matches the request against the

00:13:23,680 --> 00:13:28,399
decision table

00:13:25,120 --> 00:13:30,959
and forwards the request so that a part

00:13:28,399 --> 00:13:33,440
that matches the target service receives

00:13:30,959 --> 00:13:36,560
the request

00:13:33,440 --> 00:13:36,880
why do i say forwards a request so that

00:13:36,560 --> 00:13:38,880
a

00:13:36,880 --> 00:13:40,560
part that matches the target service

00:13:38,880 --> 00:13:43,199
receives the request

00:13:40,560 --> 00:13:45,839
and not simply forwards the request to

00:13:43,199 --> 00:13:48,160
the target service

00:13:45,839 --> 00:13:49,279
because there are implementations that

00:13:48,160 --> 00:13:51,440
implement their own

00:13:49,279 --> 00:13:53,040
pod discovery in accordance with

00:13:51,440 --> 00:13:55,680
kubernetes services

00:13:53,040 --> 00:14:00,160
but do not rely on the discovery

00:13:55,680 --> 00:14:00,160
implemented by kubernetes and kubernetes

00:14:00,839 --> 00:14:05,920
services

00:14:02,959 --> 00:14:07,120
next up the kubernetes ingress

00:14:05,920 --> 00:14:10,639
controller

00:14:07,120 --> 00:14:10,639
the control plane component

00:14:10,959 --> 00:14:15,040
kubernetes centers around the notion of

00:14:13,600 --> 00:14:18,160
kubernetes controllers

00:14:15,040 --> 00:14:18,880
and kubernetes objects kubernetes

00:14:18,160 --> 00:14:21,279
controllers

00:14:18,880 --> 00:14:22,959
continuously read and write kubernetes

00:14:21,279 --> 00:14:26,240
objects

00:14:22,959 --> 00:14:28,880
core controllers interact exclusively

00:14:26,240 --> 00:14:31,440
with the api server to read and write a

00:14:28,880 --> 00:14:34,000
set of kubernetes objects

00:14:31,440 --> 00:14:34,800
edge controller interact with the api

00:14:34,000 --> 00:14:36,560
server

00:14:34,800 --> 00:14:38,240
to read and write a set of kubernetes

00:14:36,560 --> 00:14:40,560
objects but additionally

00:14:38,240 --> 00:14:42,000
communicate with other components in the

00:14:40,560 --> 00:14:45,519
data plane

00:14:42,000 --> 00:14:47,839
let's examine a few familiar examples

00:14:45,519 --> 00:14:49,199
the kubernetes replica set controller is

00:14:47,839 --> 00:14:51,920
a core controller

00:14:49,199 --> 00:14:53,440
it interacts exclusively with the api

00:14:51,920 --> 00:14:56,079
server

00:14:53,440 --> 00:14:57,120
the replica set controller reads replica

00:14:56,079 --> 00:15:01,120
set objects

00:14:57,120 --> 00:15:03,839
and writes port objects the cubelet

00:15:01,120 --> 00:15:05,360
is an edge controller it interacts with

00:15:03,839 --> 00:15:07,920
the api server

00:15:05,360 --> 00:15:08,800
and with the container run type the

00:15:07,920 --> 00:15:11,199
cubelet

00:15:08,800 --> 00:15:12,320
reads port objects and instructs the

00:15:11,199 --> 00:15:16,639
container runtime

00:15:12,320 --> 00:15:16,639
to execute containers accordingly

00:15:17,360 --> 00:15:22,160
similarly the kubernetes endpoints

00:15:19,760 --> 00:15:24,839
controller is a call controller

00:15:22,160 --> 00:15:27,440
it interacts exclusively with the api

00:15:24,839 --> 00:15:28,800
server the endpoints controller reads

00:15:27,440 --> 00:15:31,279
service objects

00:15:28,800 --> 00:15:33,360
and port objects and writes endpoints

00:15:31,279 --> 00:15:36,399
objects

00:15:33,360 --> 00:15:38,560
the queue proxy is an edge controller it

00:15:36,399 --> 00:15:41,680
interacts with the api server

00:15:38,560 --> 00:15:44,560
and with the linux net filter module

00:15:41,680 --> 00:15:44,800
the cube proxy reads endpoint objects

00:15:44,560 --> 00:15:47,120
and

00:15:44,800 --> 00:15:50,000
instructs the net filter module to

00:15:47,120 --> 00:15:53,040
create network address translation rules

00:15:50,000 --> 00:15:55,120
so that a message sent to a service ip

00:15:53,040 --> 00:15:58,320
address will be forwarded

00:15:55,120 --> 00:16:01,600
to a port ip address with the part being

00:15:58,320 --> 00:16:04,240
a member of the endpoints

00:16:01,600 --> 00:16:06,480
now on to the ingress controller an

00:16:04,240 --> 00:16:08,800
ingress controller is an edge controller

00:16:06,480 --> 00:16:10,959
it interacts with the api server and

00:16:08,800 --> 00:16:13,199
with an ingress proxy

00:16:10,959 --> 00:16:16,160
the ingress controller reads ingress

00:16:13,199 --> 00:16:18,480
objects and instructs the ingress proxy

00:16:16,160 --> 00:16:19,600
to create routing rules according to the

00:16:18,480 --> 00:16:23,839
decision table

00:16:19,600 --> 00:16:23,839
specified in the ingress object

00:16:25,360 --> 00:16:30,399
lastly next up the kubernetes ingress

00:16:29,600 --> 00:16:33,600
proxy

00:16:30,399 --> 00:16:33,600
the data plane component

00:16:33,759 --> 00:16:39,519
as discussed earlier network ingress

00:16:36,800 --> 00:16:40,720
may happen before or after kubernetes

00:16:39,519 --> 00:16:43,680
ingress

00:16:40,720 --> 00:16:44,720
so there are two possibilities the

00:16:43,680 --> 00:16:47,839
ingress proxy

00:16:44,720 --> 00:16:49,040
may be an external endpoint or the

00:16:47,839 --> 00:16:52,800
ingress proxy

00:16:49,040 --> 00:16:55,199
may be an internal endpoint a part

00:16:52,800 --> 00:16:55,920
but either way the task of the ingress

00:16:55,199 --> 00:16:58,399
proxy

00:16:55,920 --> 00:17:00,560
is to accept the request match the

00:16:58,399 --> 00:17:03,199
request against the decision table

00:17:00,560 --> 00:17:05,760
specified by the ingress object and

00:17:03,199 --> 00:17:08,799
installed by the ingress controller

00:17:05,760 --> 00:17:11,120
and forward the request so that a part

00:17:08,799 --> 00:17:13,439
that matches the target service receives

00:17:11,120 --> 00:17:16,640
the request

00:17:13,439 --> 00:17:17,679
so in conclusion kubernetes ingress can

00:17:16,640 --> 00:17:21,120
be defined

00:17:17,679 --> 00:17:22,480
as a set of all flow pairs so that the

00:17:21,120 --> 00:17:26,079
first flow

00:17:22,480 --> 00:17:29,360
terminates at the proxy the second flow

00:17:26,079 --> 00:17:31,679
terminates at a port and there exists a

00:17:29,360 --> 00:17:34,400
rule in the decision table

00:17:31,679 --> 00:17:36,960
so that the request of the first flow

00:17:34,400 --> 00:17:40,000
matches the conditions of the rule

00:17:36,960 --> 00:17:43,120
and the part matches the target service

00:17:40,000 --> 00:17:44,840
of the rule truly

00:17:43,120 --> 00:17:47,840
not as straightforward as the first

00:17:44,840 --> 00:17:47,840
formula

00:17:49,679 --> 00:17:58,000
let's conclude ingress for kubernetes

00:17:53,520 --> 00:17:59,919
encompasses two aspects network ingress

00:17:58,000 --> 00:18:01,840
the admission of traffic into the

00:17:59,919 --> 00:18:04,400
cluster

00:18:01,840 --> 00:18:05,039
and kubernetes ingress the routing of

00:18:04,400 --> 00:18:08,000
traffic

00:18:05,039 --> 00:18:08,000
within the cluster

00:18:08,720 --> 00:18:13,280
kubernetes ingress is composed of three

00:18:11,360 --> 00:18:16,080
building blocks

00:18:13,280 --> 00:18:18,400
the kubernetes ingress resource the

00:18:16,080 --> 00:18:22,400
kubernetes ingress controller

00:18:18,400 --> 00:18:22,400
and the kubernetes ingress proxy

00:18:22,640 --> 00:18:27,039
however kubernetes provides only the

00:18:25,600 --> 00:18:29,760
ingress object

00:18:27,039 --> 00:18:32,960
ingress controller and ingress proxy are

00:18:29,760 --> 00:18:32,960
third-party components

00:18:34,000 --> 00:18:39,919
in effect the kubernetes ingress object

00:18:37,200 --> 00:18:41,520
defines a collection of http request

00:18:39,919 --> 00:18:43,120
level routing rules

00:18:41,520 --> 00:18:45,600
that determine the target of that

00:18:43,120 --> 00:18:45,600
request

00:18:45,919 --> 00:18:49,360
the ingress controller reads ingress

00:18:48,559 --> 00:18:51,679
objects

00:18:49,360 --> 00:18:53,120
and instructs the ingress proxy to

00:18:51,679 --> 00:18:54,960
create routing rules

00:18:53,120 --> 00:18:59,039
according to the decision table

00:18:54,960 --> 00:19:02,320
specified in the english object

00:18:59,039 --> 00:19:04,240
the ingress proxy accepts the request

00:19:02,320 --> 00:19:06,720
match the request against the decision

00:19:04,240 --> 00:19:09,600
table specified by the ingress object

00:19:06,720 --> 00:19:11,440
and installed by the english controller

00:19:09,600 --> 00:19:13,520
and forward the request

00:19:11,440 --> 00:19:16,960
so that a part that matches the target

00:19:13,520 --> 00:19:20,960
service receives the request

00:19:16,960 --> 00:19:24,160
and finally what is the difference

00:19:20,960 --> 00:19:28,000
between kubernetes ingress and an api

00:19:24,160 --> 00:19:31,200
gateway like the ambassador api gateway

00:19:28,000 --> 00:19:32,080
that of course is a trick question in

00:19:31,200 --> 00:19:34,640
effect

00:19:32,080 --> 00:19:35,760
the concept of kubernetes ingress is the

00:19:34,640 --> 00:19:38,960
concept of an api

00:19:35,760 --> 00:19:40,320
gateway and in effect the kubernetes

00:19:38,960 --> 00:19:43,039
ingress object

00:19:40,320 --> 00:19:44,559
is a standardized configuration for api

00:19:43,039 --> 00:19:47,520
gateways

00:19:44,559 --> 00:19:48,960
popular api gateways like the ambassador

00:19:47,520 --> 00:19:51,200
api gateway

00:19:48,960 --> 00:19:52,160
can be installed to read the ingress

00:19:51,200 --> 00:19:55,200
object

00:19:52,160 --> 00:19:58,240
and act as the ingress controller and

00:19:55,200 --> 00:19:58,240
the ingress proxy

00:20:00,000 --> 00:20:03,120
if you are watching this presentation

00:20:01,919 --> 00:20:05,200
during the conference

00:20:03,120 --> 00:20:06,400
i will be happy to answer your questions

00:20:05,200 --> 00:20:08,240
online

00:20:06,400 --> 00:20:09,520
if you are watching this presentation

00:20:08,240 --> 00:20:11,280
after the conference

00:20:09,520 --> 00:20:13,679
i will be happy to answer your questions

00:20:11,280 --> 00:20:16,000
via email but either way

00:20:13,679 --> 00:20:18,559
thank you for watching inside kubernetes

00:20:16,000 --> 00:20:18,559

YouTube URL: https://www.youtube.com/watch?v=2fZrnx2FRMs


