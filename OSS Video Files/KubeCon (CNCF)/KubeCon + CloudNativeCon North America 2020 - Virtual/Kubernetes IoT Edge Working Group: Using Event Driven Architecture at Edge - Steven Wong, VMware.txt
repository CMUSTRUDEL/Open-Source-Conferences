Title: Kubernetes IoT Edge Working Group: Using Event Driven Architecture at Edge - Steven Wong, VMware
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4–7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Kubernetes IoT Edge Working Group: Using Event Driven Architecture at Edge - Steven Wong, VMware & Dejan Bosanac, RedHat 

Many use cases at edge face resource limits which challenge the deployment of full K8s clusters, or even single nodes, at the edge “leaf” nodes. We will introduce some techniques that can be used to process edge generated data and commands using Kubernetes hosted applications and services in a loosely coupled tiered distributed system. Agenda: - Characteristics and challenges of Edge Applications. - Introduction to event driven architecture - What is it? How do you deploy and manage it at edge. - Using open source based event driven tools to host data collection and IoT processing on small devices feeding into K8s hosted applications and services. - Demonstration using edge generated CloudEvents with a Kubernetes hosted application. - How to get involved in the K8s IoT Edge Working Group. 

https://sched.co/ekH1
Captions: 
	00:00:00,719 --> 00:00:05,839
hi this session is presented by the

00:00:02,800 --> 00:00:08,240
kubernetes iot edge working group

00:00:05,839 --> 00:00:09,519
this is about using kubernetes for edge

00:00:08,240 --> 00:00:11,599
applications

00:00:09,519 --> 00:00:13,840
i'm steve wong a tech lead of the

00:00:11,599 --> 00:00:15,759
working group i work on kubernetes and a

00:00:13,840 --> 00:00:18,960
few other open source projects

00:00:15,759 --> 00:00:21,600
as an employee of vmware hey

00:00:18,960 --> 00:00:22,560
my name is dan i'm an engineer at red

00:00:21,600 --> 00:00:24,480
hit

00:00:22,560 --> 00:00:26,000
been doing a lot of iot and edge

00:00:24,480 --> 00:00:26,400
computing in the last couple of years

00:00:26,000 --> 00:00:31,199
and

00:00:26,400 --> 00:00:33,360
also a lead of the this working group

00:00:31,199 --> 00:00:34,880
we'll give contact information and a

00:00:33,360 --> 00:00:36,880
link at the end

00:00:34,880 --> 00:00:38,000
but here's the agenda we're going to

00:00:36,880 --> 00:00:42,000
start with a quick

00:00:38,000 --> 00:00:44,399
overview of what the exact definition is

00:00:42,000 --> 00:00:45,520
of edge applications for the purposes of

00:00:44,399 --> 00:00:47,039
this talk

00:00:45,520 --> 00:00:49,520
then we're going to move on to an

00:00:47,039 --> 00:00:50,719
introduction to some techniques and open

00:00:49,520 --> 00:00:53,039
source tools

00:00:50,719 --> 00:00:55,760
that are really useful when using an

00:00:53,039 --> 00:00:57,680
event-driven architecture at edge

00:00:55,760 --> 00:01:00,000
hopefully you like this talk and if you

00:00:57,680 --> 00:01:02,160
do we'll wrap up with details

00:01:00,000 --> 00:01:04,879
on how you can become a member of the

00:01:02,160 --> 00:01:07,200
kubernetes iot edge working group

00:01:04,879 --> 00:01:10,240
where we host ongoing discussions on

00:01:07,200 --> 00:01:12,159
subjects like this talk

00:01:10,240 --> 00:01:13,600
for the scope of this talk when we say

00:01:12,159 --> 00:01:15,840
edge application

00:01:13,600 --> 00:01:16,799
we're not confining ourselves to just

00:01:15,840 --> 00:01:20,000
the software

00:01:16,799 --> 00:01:22,240
that runs on individual edge devices

00:01:20,000 --> 00:01:24,320
sure there's software there but if

00:01:22,240 --> 00:01:25,439
you're interested in getting kubernetes

00:01:24,320 --> 00:01:28,080
involved

00:01:25,439 --> 00:01:30,560
we're going to assume that you've got

00:01:28,080 --> 00:01:31,200
multiple devices involved but are also

00:01:30,560 --> 00:01:34,159
using

00:01:31,200 --> 00:01:36,880
containerized software at some location

00:01:34,159 --> 00:01:40,079
perhaps multiple locations that could be

00:01:36,880 --> 00:01:43,600
a high-level gateway regional tiers or

00:01:40,079 --> 00:01:46,000
even a global tier our definition of an

00:01:43,600 --> 00:01:49,759
edge application is the big picture

00:01:46,000 --> 00:01:53,040
where you've got software interacting

00:01:49,759 --> 00:01:55,439
from various locations simultaneously

00:01:53,040 --> 00:01:57,280
so if this is what you're setting out to

00:01:55,439 --> 00:01:59,840
deploy and manage

00:01:57,280 --> 00:02:02,960
you have a need for data and control

00:01:59,840 --> 00:02:06,000
plane communication from edge devices

00:02:02,960 --> 00:02:07,439
up to higher level tiers and you might

00:02:06,000 --> 00:02:09,759
also want support for

00:02:07,439 --> 00:02:12,000
edge node to edge node interaction as

00:02:09,759 --> 00:02:12,000
well

00:02:12,400 --> 00:02:15,520
a lot of people have fallen in love with

00:02:14,239 --> 00:02:18,080
kubernetes lately

00:02:15,520 --> 00:02:19,760
and it is a great tool for orchestrating

00:02:18,080 --> 00:02:23,040
containerized apps

00:02:19,760 --> 00:02:23,920
but it's also extensible as a control

00:02:23,040 --> 00:02:26,000
plane

00:02:23,920 --> 00:02:27,520
the fact is that when it comes to some

00:02:26,000 --> 00:02:29,680
edge use cases

00:02:27,520 --> 00:02:30,959
the devices simply have too little

00:02:29,680 --> 00:02:33,599
resource to run

00:02:30,959 --> 00:02:35,760
software in a container or as a

00:02:33,599 --> 00:02:38,800
kubernetes worker note

00:02:35,760 --> 00:02:41,680
yes if you've got pies with 4 gig

00:02:38,800 --> 00:02:44,000
or now 8 gig of memory these are quite

00:02:41,680 --> 00:02:45,840
capable and you could turn these into

00:02:44,000 --> 00:02:47,599
kubernetes worker nodes

00:02:45,840 --> 00:02:49,760
but there are a lot of far tinier

00:02:47,599 --> 00:02:52,160
devices like arduinos

00:02:49,760 --> 00:02:54,080
where memory is measured in low single

00:02:52,160 --> 00:02:56,000
digits of megabytes

00:02:54,080 --> 00:02:58,159
we're going to talk about a technique

00:02:56,000 --> 00:02:59,200
that can invite the little devices to

00:02:58,159 --> 00:03:02,080
the party

00:02:59,200 --> 00:03:03,920
while still supporting containerized

00:03:02,080 --> 00:03:06,280
software running

00:03:03,920 --> 00:03:09,280
in your higher level tiers

00:03:06,280 --> 00:03:09,280
simultaneously

00:03:09,599 --> 00:03:13,840
so in a simple form an event driven

00:03:12,159 --> 00:03:17,040
architecture looks like this

00:03:13,840 --> 00:03:18,239
an event is a piece of information often

00:03:17,040 --> 00:03:21,360
used to communicate

00:03:18,239 --> 00:03:23,760
facts like measurements or commands like

00:03:21,360 --> 00:03:26,319
statements of intent

00:03:23,760 --> 00:03:28,400
functions and services consume events

00:03:26,319 --> 00:03:30,560
and it's up to these applications to

00:03:28,400 --> 00:03:33,200
decide what to do with the event

00:03:30,560 --> 00:03:34,720
events can be ignored forwarded stored

00:03:33,200 --> 00:03:37,200
or transformed

00:03:34,720 --> 00:03:39,200
in a time series of events whether the

00:03:37,200 --> 00:03:41,120
events are measurements or commands

00:03:39,200 --> 00:03:44,000
a newer one might make an older one

00:03:41,120 --> 00:03:45,440
irrelevant if a buildup occurs somewhere

00:03:44,000 --> 00:03:48,159
in a queue

00:03:45,440 --> 00:03:51,599
analysis of events might emit new events

00:03:48,159 --> 00:03:51,599
based on a transformation

00:03:51,680 --> 00:03:56,319
in a distributed system an event stream

00:03:54,239 --> 00:03:58,959
is a communication fabric

00:03:56,319 --> 00:04:00,640
and when the apps and events flows are

00:03:58,959 --> 00:04:03,040
viewed together

00:04:00,640 --> 00:04:05,439
this is actually a programming model

00:04:03,040 --> 00:04:08,080
event driven architecture can be helpful

00:04:05,439 --> 00:04:09,439
because it encourages some good program

00:04:08,080 --> 00:04:11,599
development practices

00:04:09,439 --> 00:04:13,200
loose coupling independently

00:04:11,599 --> 00:04:15,799
maintainable components

00:04:13,200 --> 00:04:18,400
and separation of concerns a

00:04:15,799 --> 00:04:18,959
distribution layer can help organize

00:04:18,400 --> 00:04:21,040
things

00:04:18,959 --> 00:04:23,440
and maybe even offload things you might

00:04:21,040 --> 00:04:26,560
otherwise have to write yourself

00:04:23,440 --> 00:04:28,240
an example here is a pub sub broker

00:04:26,560 --> 00:04:29,919
eliminating the maintenance of a

00:04:28,240 --> 00:04:34,000
distribution list

00:04:29,919 --> 00:04:34,000
from the duty of an event publisher

00:04:36,720 --> 00:04:41,280
this is a metaphor this is how a

00:04:38,720 --> 00:04:43,360
restaurant often works in the real

00:04:41,280 --> 00:04:45,280
physical world there are various people

00:04:43,360 --> 00:04:47,520
involved shouting out

00:04:45,280 --> 00:04:50,240
combinations of desired state and

00:04:47,520 --> 00:04:52,240
notifications of state changes

00:04:50,240 --> 00:04:54,479
you listen to what concerns you you

00:04:52,240 --> 00:04:57,680
ignore the rest so in this example

00:04:54,479 --> 00:05:00,720
i've got a customer who shows up

00:04:57,680 --> 00:05:04,000
asking for a table for one for lunch

00:05:00,720 --> 00:05:06,880
eventually getting assigned to a table

00:05:04,000 --> 00:05:08,160
making an order and the waiter passing

00:05:06,880 --> 00:05:11,759
along

00:05:08,160 --> 00:05:14,800
details on that order into the kitchen

00:05:11,759 --> 00:05:16,560
let's take a look at an alternative

00:05:14,800 --> 00:05:20,080
flow of what a restaurant would look

00:05:16,560 --> 00:05:22,400
like with a microservice implementation

00:05:20,080 --> 00:05:24,639
yes i think you could get it to work but

00:05:22,400 --> 00:05:27,520
at what long-term cost

00:05:24,639 --> 00:05:28,880
what if the menu or table layout changes

00:05:27,520 --> 00:05:31,600
what things have to get

00:05:28,880 --> 00:05:34,479
touched now understand at many edge

00:05:31,600 --> 00:05:37,440
locations devices often have various

00:05:34,479 --> 00:05:39,039
uncoordinated life cycles and business

00:05:37,440 --> 00:05:41,919
operations might change

00:05:39,039 --> 00:05:42,560
maybe even seasonally the loose coupled

00:05:41,919 --> 00:05:45,039
nature

00:05:42,560 --> 00:05:47,360
of event-driven architecture with

00:05:45,039 --> 00:05:49,600
independently maintainable components

00:05:47,360 --> 00:05:52,240
and separation of concerns

00:05:49,600 --> 00:05:53,360
can really be attractive at edge by the

00:05:52,240 --> 00:05:56,800
way i want to shout

00:05:53,360 --> 00:05:58,400
shout out to simon aubry of thoughtworks

00:05:56,800 --> 00:06:01,600
for coming up with this

00:05:58,400 --> 00:06:07,120
nice restaurant metaphor for describing

00:06:01,600 --> 00:06:10,720
how event driven might work at edge

00:06:07,120 --> 00:06:13,440
so event driven can

00:06:10,720 --> 00:06:15,280
can originate on devices below what i'm

00:06:13,440 --> 00:06:17,680
calling the kubernetes uh

00:06:15,280 --> 00:06:20,319
water line there are some very simple

00:06:17,680 --> 00:06:22,800
protocols like mqtt

00:06:20,319 --> 00:06:23,919
that can be implemented on things like

00:06:22,800 --> 00:06:26,160
arduinos

00:06:23,919 --> 00:06:27,199
particularly if you can afford to skip

00:06:26,160 --> 00:06:30,639
tls

00:06:27,199 --> 00:06:32,720
i know skipping tls is risky sometimes

00:06:30,639 --> 00:06:34,560
but maybe you already live with

00:06:32,720 --> 00:06:36,960
unencrypted traffic

00:06:34,560 --> 00:06:39,039
operating on localhost with you know

00:06:36,960 --> 00:06:42,000
within an individual system

00:06:39,039 --> 00:06:44,400
so this concept is nothing new by

00:06:42,000 --> 00:06:46,800
skipping encryption there is risk

00:06:44,400 --> 00:06:48,080
but if you're connecting isolated

00:06:46,800 --> 00:06:50,400
devices that are not

00:06:48,080 --> 00:06:52,400
connected to the internet with some

00:06:50,400 --> 00:06:54,880
semblance of physical security

00:06:52,400 --> 00:06:57,039
maybe this is an affordable trade-off

00:06:54,880 --> 00:06:58,080
the bottom line here is that there are

00:06:57,039 --> 00:07:01,120
solutions

00:06:58,080 --> 00:07:03,360
for very low end devices and if you have

00:07:01,120 --> 00:07:05,039
larger devices there are solutions with

00:07:03,360 --> 00:07:07,280
bigger feature sets

00:07:05,039 --> 00:07:09,840
uh at gateway and higher tiers you're

00:07:07,280 --> 00:07:12,639
likely to have plug-ins to support

00:07:09,840 --> 00:07:13,360
uh all the various open source tooling

00:07:12,639 --> 00:07:16,479
availa

00:07:13,360 --> 00:07:19,120
available for eventing and

00:07:16,479 --> 00:07:21,759
you can probably afford to turn on full

00:07:19,120 --> 00:07:21,759
security

00:07:22,479 --> 00:07:29,360
so here are a few uh

00:07:26,560 --> 00:07:30,240
words of advice that i've discovered out

00:07:29,360 --> 00:07:32,639
there

00:07:30,240 --> 00:07:34,400
with regard to designing an open and

00:07:32,639 --> 00:07:38,240
event-driven architecture for

00:07:34,400 --> 00:07:41,199
edge view your

00:07:38,240 --> 00:07:42,319
when when you persist events view them

00:07:41,199 --> 00:07:44,479
as a

00:07:42,319 --> 00:07:45,440
persistence of a replayable stream

00:07:44,479 --> 00:07:47,759
history

00:07:45,440 --> 00:07:48,960
uh you don't want the event consumers

00:07:47,759 --> 00:07:51,840
tied to specific

00:07:48,960 --> 00:07:54,080
producers view your events as a record

00:07:51,840 --> 00:07:55,759
of something that has happened and so it

00:07:54,080 --> 00:07:57,759
can't be changed you can't change

00:07:55,759 --> 00:08:00,960
history

00:07:57,759 --> 00:08:03,599
messages on common delivery platforms

00:08:00,960 --> 00:08:05,520
often have certain characteristics

00:08:03,599 --> 00:08:07,599
and there are certain things you should

00:08:05,520 --> 00:08:10,160
do and shouldn't do

00:08:07,599 --> 00:08:11,199
rules can be different across latency

00:08:10,160 --> 00:08:14,160
boundaries

00:08:11,199 --> 00:08:15,919
so that if you've got a failure domain

00:08:14,160 --> 00:08:17,919
and a latency domain

00:08:15,919 --> 00:08:19,599
you can do things that maybe you should

00:08:17,919 --> 00:08:20,639
avoid when you're crossing those

00:08:19,599 --> 00:08:22,560
boundaries

00:08:20,639 --> 00:08:23,680
synchronous might be okay within a

00:08:22,560 --> 00:08:25,919
boundary but

00:08:23,680 --> 00:08:27,360
really that's an anti-pattern when

00:08:25,919 --> 00:08:30,800
you're crossing a big

00:08:27,360 --> 00:08:33,599
latency chasm thank you steve so

00:08:30,800 --> 00:08:34,479
uh one of the answers to to uh

00:08:33,599 --> 00:08:37,279
serverless

00:08:34,479 --> 00:08:38,479
rtos to event-driven architectures in in

00:08:37,279 --> 00:08:41,039
the kubernetes land

00:08:38,479 --> 00:08:42,399
is uh is uh k native inventing

00:08:41,039 --> 00:08:46,080
specifically

00:08:42,399 --> 00:08:49,360
uh k native eventing is is all about uh

00:08:46,080 --> 00:08:52,800
yeah uh uh hooking up our

00:08:49,360 --> 00:08:56,240
k native services with appropriate uh

00:08:52,800 --> 00:09:00,240
event sources so this diagram basically

00:08:56,240 --> 00:09:04,240
explains it in in a you know you know a

00:09:00,240 --> 00:09:06,480
most uh simple way so basically we

00:09:04,240 --> 00:09:07,680
have a source of our events which have a

00:09:06,480 --> 00:09:12,399
sync and that sync

00:09:07,680 --> 00:09:15,440
goes to uh to appropriate service

00:09:12,399 --> 00:09:18,959
uh also one more important detail here

00:09:15,440 --> 00:09:19,839
uh is our cloud events and and the cloud

00:09:18,959 --> 00:09:22,959
events

00:09:19,839 --> 00:09:25,519
provides us a structure

00:09:22,959 --> 00:09:27,120
to to our events so basically adding all

00:09:25,519 --> 00:09:30,240
the metadata

00:09:27,120 --> 00:09:33,519
that we need uh to to describe our

00:09:30,240 --> 00:09:36,640
events and and to have some consistency

00:09:33,519 --> 00:09:39,600
within our serverless applications

00:09:36,640 --> 00:09:40,480
uh and from that consistency uh comes

00:09:39,600 --> 00:09:43,360
accessibility

00:09:40,480 --> 00:09:44,720
because then we can uh create an apis in

00:09:43,360 --> 00:09:46,880
you know in a lot of different

00:09:44,720 --> 00:09:50,399
different languages and and you know

00:09:46,880 --> 00:09:52,000
port our our solutions and our services

00:09:50,399 --> 00:09:54,800
or our functions

00:09:52,000 --> 00:09:55,360
uh to different different environments

00:09:54,800 --> 00:09:58,399
uh

00:09:55,360 --> 00:10:01,760
here we can see see one of the example

00:09:58,399 --> 00:10:04,880
where where a cloud event basically adds

00:10:01,760 --> 00:10:05,279
it's uh some metadata and the data to

00:10:04,880 --> 00:10:08,399
the

00:10:05,279 --> 00:10:10,480
to the picture uh

00:10:08,399 --> 00:10:11,600
how this looks in practice is something

00:10:10,480 --> 00:10:14,079
that that will

00:10:11,600 --> 00:10:14,640
uh demo at the end at the end of this

00:10:14,079 --> 00:10:18,959
talk

00:10:14,640 --> 00:10:22,160
so basically uh what we have here is

00:10:18,959 --> 00:10:25,600
uh an edge location which run in

00:10:22,160 --> 00:10:28,000
uh steve's home which contains uh a

00:10:25,600 --> 00:10:29,839
apache mqtt broker and and the small

00:10:28,000 --> 00:10:31,120
devices that are connected to that

00:10:29,839 --> 00:10:34,000
broker

00:10:31,120 --> 00:10:34,720
and sending sending uh their telemetry

00:10:34,000 --> 00:10:38,959
using using

00:10:34,720 --> 00:10:39,839
nqtt what we will do we will use a comma

00:10:38,959 --> 00:10:43,279
k

00:10:39,839 --> 00:10:45,839
uh and and connect to that that broker

00:10:43,279 --> 00:10:46,880
basically uh getting all these mqtt

00:10:45,839 --> 00:10:49,440
messages

00:10:46,880 --> 00:10:49,920
uh converting them into the cloud events

00:10:49,440 --> 00:10:53,600
and

00:10:49,920 --> 00:10:56,079
and and and pushing them to our sync

00:10:53,600 --> 00:10:57,839
and in this demo the sync will be simple

00:10:56,079 --> 00:11:02,560
event display service which will

00:10:57,839 --> 00:11:06,560
log these cloud events to the console

00:11:02,560 --> 00:11:09,600
camel k originates from the

00:11:06,560 --> 00:11:12,800
apache camel project which provides

00:11:09,600 --> 00:11:15,279
a very rich framework for

00:11:12,800 --> 00:11:16,240
for doing enterprise integrations and

00:11:15,279 --> 00:11:19,279
the camera k

00:11:16,240 --> 00:11:23,519
is basically uh a k native uh

00:11:19,279 --> 00:11:25,839
uh implementation or adaptation of

00:11:23,519 --> 00:11:27,440
of all the camera components and as we

00:11:25,839 --> 00:11:29,760
can see here

00:11:27,440 --> 00:11:31,360
we can use any of the available uh

00:11:29,760 --> 00:11:33,839
hundreds of of camel

00:11:31,360 --> 00:11:36,480
uh uh connectors uh to connect to

00:11:33,839 --> 00:11:39,279
different external systems and and

00:11:36,480 --> 00:11:39,760
uh convert them automatically to to the

00:11:39,279 --> 00:11:43,040
uh

00:11:39,760 --> 00:11:45,120
native eventing sources

00:11:43,040 --> 00:11:46,399
uh if you go to the next slide we can

00:11:45,120 --> 00:11:50,240
see how

00:11:46,399 --> 00:11:53,760
the the k native uh uh

00:11:50,240 --> 00:11:56,880
okay native uh architecture evolves

00:11:53,760 --> 00:11:59,839
because you know hooking one source to

00:11:56,880 --> 00:12:01,519
to one service is easy enough but but

00:11:59,839 --> 00:12:04,560
but not enough to support

00:12:01,519 --> 00:12:08,079
all the use cases that's where we can

00:12:04,560 --> 00:12:10,880
uh bring in the the

00:12:08,079 --> 00:12:11,600
concept of channels and and with with

00:12:10,880 --> 00:12:13,519
sending

00:12:11,600 --> 00:12:16,160
uh an event from the source to the

00:12:13,519 --> 00:12:19,760
channel we can now have multiple

00:12:16,160 --> 00:12:21,839
multiple uh services subscribing

00:12:19,760 --> 00:12:23,360
uh to the channel and and receiving all

00:12:21,839 --> 00:12:26,560
these events

00:12:23,360 --> 00:12:28,720
channels can be backed by

00:12:26,560 --> 00:12:31,279
different uh source uh different

00:12:28,720 --> 00:12:31,279
persistence

00:12:32,320 --> 00:12:36,000
techniques so in in-memory channels we

00:12:34,880 --> 00:12:39,120
have uh

00:12:36,000 --> 00:12:43,120
traditionally often use kafka channels

00:12:39,120 --> 00:12:45,200
backed by by the uh the kafka broker

00:12:43,120 --> 00:12:46,720
which provides a a really really good

00:12:45,200 --> 00:12:49,920
solution uh

00:12:46,720 --> 00:12:53,360
uh for for

00:12:49,920 --> 00:12:56,800
uh implementing uh

00:12:53,360 --> 00:13:00,800
iot mqtt solutions on

00:12:56,800 --> 00:13:01,680
on serverless uh extending this concept

00:13:00,800 --> 00:13:05,200
even further

00:13:01,680 --> 00:13:08,560
uh on the next slide we can see

00:13:05,200 --> 00:13:12,240
the concept of of uh of uh

00:13:08,560 --> 00:13:15,360
uh uh k native inventing brokers

00:13:12,240 --> 00:13:15,839
which basically uh uh function in a

00:13:15,360 --> 00:13:19,200
similar

00:13:15,839 --> 00:13:21,839
way as as uh as a channels

00:13:19,200 --> 00:13:22,800
the only thing is that instead of the

00:13:21,839 --> 00:13:25,839
subscriptions

00:13:22,800 --> 00:13:26,880
uh now we are defining different

00:13:25,839 --> 00:13:30,079
triggers

00:13:26,880 --> 00:13:32,720
uh for the broker that will that will uh

00:13:30,079 --> 00:13:33,680
push events to different different

00:13:32,720 --> 00:13:35,360
services

00:13:33,680 --> 00:13:37,360
and the only difference is that for the

00:13:35,360 --> 00:13:39,920
triggers we can we can add

00:13:37,360 --> 00:13:41,760
a different kind of filters so that that

00:13:39,920 --> 00:13:45,199
we can say that that we are interested

00:13:41,760 --> 00:13:45,920
in only a certain type of of of cloud

00:13:45,199 --> 00:13:49,279
events

00:13:45,920 --> 00:13:53,120
while we're doing while we're doing this

00:13:49,279 --> 00:13:55,519
and finally if we take all this

00:13:53,120 --> 00:13:57,600
into the consideration on the next slide

00:13:55,519 --> 00:14:01,279
we can see

00:13:57,600 --> 00:14:04,720
a little bit uh evolved scenario

00:14:01,279 --> 00:14:07,519
where where we can with with this uh

00:14:04,720 --> 00:14:08,480
kind of architecture we can support

00:14:07,519 --> 00:14:11,680
multiple things

00:14:08,480 --> 00:14:14,639
so we can have a

00:14:11,680 --> 00:14:18,160
we can we can support scenario that that

00:14:14,639 --> 00:14:21,519
we will demo soon where we have a small

00:14:18,160 --> 00:14:23,920
uh small embedded uh devices connecting

00:14:21,519 --> 00:14:25,040
over non-tls to the local barco broker

00:14:23,920 --> 00:14:28,079
on the edge side

00:14:25,040 --> 00:14:31,120
and then having uh having a

00:14:28,079 --> 00:14:33,199
camel mqtt converting uh

00:14:31,120 --> 00:14:34,480
subscribing to the broker converting

00:14:33,199 --> 00:14:37,760
those to the

00:14:34,480 --> 00:14:39,279
to the to the services and uh to the

00:14:37,760 --> 00:14:41,440
cloud events and sending it to the

00:14:39,279 --> 00:14:44,320
channel but we can also

00:14:41,440 --> 00:14:46,160
imagine that we can provide a a new

00:14:44,320 --> 00:14:49,519
components

00:14:46,160 --> 00:14:52,079
naming mqtt broker source that that

00:14:49,519 --> 00:14:53,519
would act to the external systems as an

00:14:52,079 --> 00:14:56,880
mqtt broker

00:14:53,519 --> 00:14:58,240
and where we can allow more powerful

00:14:56,880 --> 00:15:00,480
devices which

00:14:58,240 --> 00:15:02,160
can support tls to connect directly to

00:15:00,480 --> 00:15:04,560
the cloud to to this

00:15:02,160 --> 00:15:05,440
to this source which will also uh

00:15:04,560 --> 00:15:08,399
transform these

00:15:05,440 --> 00:15:09,040
mqtt messages coming from the devices

00:15:08,399 --> 00:15:10,639
into into

00:15:09,040 --> 00:15:12,800
appropriate cloud events and sending

00:15:10,639 --> 00:15:16,240
them to the channel

00:15:12,800 --> 00:15:18,639
the channel could be backed by by kafka

00:15:16,240 --> 00:15:21,199
providing all the the the persistence

00:15:18,639 --> 00:15:23,440
and reliability that that we would need

00:15:21,199 --> 00:15:24,639
in such a solution and then push these

00:15:23,440 --> 00:15:27,600
two to different

00:15:24,639 --> 00:15:28,639
uh different services so event display

00:15:27,600 --> 00:15:30,880
service which is

00:15:28,639 --> 00:15:32,639
like most basic one that we can imagine

00:15:30,880 --> 00:15:35,279
that can be used just

00:15:32,639 --> 00:15:36,560
just for debugging purposes but most

00:15:35,279 --> 00:15:39,279
commonly you will

00:15:36,560 --> 00:15:41,040
push this to some kind of influx db or

00:15:39,279 --> 00:15:43,519
prometheus

00:15:41,040 --> 00:15:44,160
backed by a grafana dashboard to have

00:15:43,519 --> 00:15:46,800
more

00:15:44,160 --> 00:15:48,079
better of observability and and be able

00:15:46,800 --> 00:15:50,560
to create different

00:15:48,079 --> 00:15:51,519
dashboards where you can where you can

00:15:50,560 --> 00:15:55,120
see

00:15:51,519 --> 00:15:58,480
see all these data so

00:15:55,120 --> 00:16:00,959
this is uh a call for for

00:15:58,480 --> 00:16:02,240
action uh on on the next slide and

00:16:00,959 --> 00:16:06,160
something that

00:16:02,240 --> 00:16:09,440
we can we can

00:16:06,160 --> 00:16:12,000
try to solve uh uh in the in the in the

00:16:09,440 --> 00:16:15,360
working group and and trying to to

00:16:12,000 --> 00:16:17,920
make mqtt which is the default iot

00:16:15,360 --> 00:16:21,440
uh messaging protocol of a first-class

00:16:17,920 --> 00:16:24,000
citizen in the k-native inventing world

00:16:21,440 --> 00:16:25,759
this is you know all the examples shown

00:16:24,000 --> 00:16:29,120
here is is just a tip of the

00:16:25,759 --> 00:16:30,000
iceberg iceberg uh showing how things

00:16:29,120 --> 00:16:32,000
could work but

00:16:30,000 --> 00:16:33,680
there's a lot of things that that

00:16:32,000 --> 00:16:35,920
usually in this kind of systems needs to

00:16:33,680 --> 00:16:37,120
be solved like uh device security and

00:16:35,920 --> 00:16:39,759
and

00:16:37,120 --> 00:16:41,759
sending commands back to devices we can

00:16:39,759 --> 00:16:42,959
provide a lot of integration with the

00:16:41,759 --> 00:16:45,920
existing rtf

00:16:42,959 --> 00:16:47,040
platforms like eclipse honor or aws or

00:16:45,920 --> 00:16:50,160
azure offerings

00:16:47,040 --> 00:16:50,480
in this area uh provide an easy way to

00:16:50,160 --> 00:16:53,120
to

00:16:50,480 --> 00:16:53,680
to run all these using different clies

00:16:53,120 --> 00:16:57,040
and

00:16:53,680 --> 00:16:58,160
uis and and provide some of these

00:16:57,040 --> 00:17:00,880
services

00:16:58,160 --> 00:17:01,279
out of the box that you know people can

00:17:00,880 --> 00:17:03,279
get

00:17:01,279 --> 00:17:04,480
really really quickly to get started

00:17:03,279 --> 00:17:07,600
with with the

00:17:04,480 --> 00:17:08,559
with iot on on on a platform like like

00:17:07,600 --> 00:17:12,160
this

00:17:08,559 --> 00:17:15,839
and finally uh uh

00:17:12,160 --> 00:17:18,799
do something uh uh an extended extending

00:17:15,839 --> 00:17:19,839
uh a solution like this to to the multi

00:17:18,799 --> 00:17:23,280
cloud or or

00:17:19,839 --> 00:17:26,559
let's say edge edge nodes uh uh

00:17:23,280 --> 00:17:30,240
environments using using uh uh

00:17:26,559 --> 00:17:32,240
something like uh like a scupper

00:17:30,240 --> 00:17:33,840
and if if you're interested in in that

00:17:32,240 --> 00:17:35,679
topic i would suggest you to

00:17:33,840 --> 00:17:38,000
to take a look take a look at the

00:17:35,679 --> 00:17:40,480
recording of the video of of the

00:17:38,000 --> 00:17:41,919
of of another session by my colleague

00:17:40,480 --> 00:17:45,600
ted which is happening

00:17:41,919 --> 00:17:48,400
at the same time as as this one which

00:17:45,600 --> 00:17:49,200
explains a little bit more of of how how

00:17:48,400 --> 00:17:52,559
serverless

00:17:49,200 --> 00:17:55,520
uh uh workloads can can be pushed from

00:17:52,559 --> 00:17:57,360
from the edge to to the cloud to the

00:17:55,520 --> 00:18:01,200
different clouds

00:17:57,360 --> 00:18:04,240
and different serverless deployments

00:18:01,200 --> 00:18:05,120
so for the end i would like to do uh to

00:18:04,240 --> 00:18:08,320
to go back and

00:18:05,120 --> 00:18:09,600
and do a simple demo of of of all this

00:18:08,320 --> 00:18:12,799
so let me just quickly

00:18:09,600 --> 00:18:15,840
share my screen and and try to

00:18:12,799 --> 00:18:15,840
try to do that

00:18:15,919 --> 00:18:23,039
uh steve uh i'm not allowed to

00:18:19,679 --> 00:18:25,520
so here we are going going back uh

00:18:23,039 --> 00:18:26,799
to the to the original idea having one

00:18:25,520 --> 00:18:30,799
source and one sync

00:18:26,799 --> 00:18:33,840
and connecting them via

00:18:30,799 --> 00:18:37,440
cloud events as i said uh

00:18:33,840 --> 00:18:40,240
uh our service is

00:18:37,440 --> 00:18:40,799
is is a very simple i think the simplest

00:18:40,240 --> 00:18:43,200
possible

00:18:40,799 --> 00:18:44,160
k native series that that we could have

00:18:43,200 --> 00:18:47,600
it's named

00:18:44,160 --> 00:18:50,000
camel event display and and uh it uses

00:18:47,600 --> 00:18:51,919
the event display image so what will

00:18:50,000 --> 00:18:52,480
what this image will do it it will just

00:18:51,919 --> 00:18:56,240
receive

00:18:52,480 --> 00:18:59,520
events on its serving endpoint and and

00:18:56,240 --> 00:19:03,919
log them to the console uh

00:18:59,520 --> 00:19:03,919
and our source will be

00:19:06,720 --> 00:19:12,799
let me do this like this so it's it's a

00:19:10,160 --> 00:19:14,000
it's it's visible better so we're using

00:19:12,799 --> 00:19:17,760
camel source

00:19:14,000 --> 00:19:18,240
uh k native uh eventing uh come with a

00:19:17,760 --> 00:19:20,559
lot of

00:19:18,240 --> 00:19:22,880
uh out of shell shelf uh sources and

00:19:20,559 --> 00:19:26,400
camel source is is one of them

00:19:22,880 --> 00:19:28,480
and as i explained earlier once you have

00:19:26,400 --> 00:19:31,120
a camel source you you can use different

00:19:28,480 --> 00:19:32,320
different chemical components to to to

00:19:31,120 --> 00:19:35,200
connect to

00:19:32,320 --> 00:19:36,840
different external systems so right here

00:19:35,200 --> 00:19:40,400
we are using the pajo

00:19:36,840 --> 00:19:43,360
uh pajo uh component

00:19:40,400 --> 00:19:44,480
which will uh connect using the paco

00:19:43,360 --> 00:19:47,600
mqtt client

00:19:44,480 --> 00:19:48,799
to us a broker uh this is just a

00:19:47,600 --> 00:19:52,400
template because

00:19:48,799 --> 00:19:54,640
we don't want to give a

00:19:52,400 --> 00:19:55,440
steve's mqtt broker details to the

00:19:54,640 --> 00:19:57,840
public

00:19:55,440 --> 00:19:59,440
but uh it will connect to the steve's

00:19:57,840 --> 00:20:02,080
mqtt broker running it

00:19:59,440 --> 00:20:03,919
at his home uh using appropriate

00:20:02,080 --> 00:20:07,280
username and password and connect

00:20:03,919 --> 00:20:10,320
two to one mqtt topic in this case

00:20:07,280 --> 00:20:13,679
topic is a w date saturday at

00:20:10,320 --> 00:20:15,600
the slash temperature one f uh uh

00:20:13,679 --> 00:20:17,440
assuming it's a it's a temperature

00:20:15,600 --> 00:20:20,880
temperature sensor

00:20:17,440 --> 00:20:23,520
and uh that in in this camel source

00:20:20,880 --> 00:20:24,880
we can see that this is uh this is a

00:20:23,520 --> 00:20:28,240
definition of of

00:20:24,880 --> 00:20:31,120
of our source you know in in the

00:20:28,240 --> 00:20:33,120
down part here we we here we see how we

00:20:31,120 --> 00:20:36,320
can do a definition of the

00:20:33,120 --> 00:20:37,440
of the sink and for the thing we can see

00:20:36,320 --> 00:20:40,240
that we are

00:20:37,440 --> 00:20:41,760
directly calling the the service and and

00:20:40,240 --> 00:20:44,640
the service will be the

00:20:41,760 --> 00:20:46,159
the aforementioned camel event display

00:20:44,640 --> 00:20:49,760
display service

00:20:46,159 --> 00:20:50,480
so to not disturb demo gods i have all

00:20:49,760 --> 00:20:54,159
this

00:20:50,480 --> 00:20:57,919
uh running in in advance

00:20:54,159 --> 00:21:01,039
and what we can see

00:20:57,919 --> 00:21:04,080
in in this other other

00:21:01,039 --> 00:21:09,039
uh window is that uh

00:21:04,080 --> 00:21:12,880
we can pick up now the the

00:21:09,039 --> 00:21:13,360
the logs uh from the from uh coming from

00:21:12,880 --> 00:21:16,880
the

00:21:13,360 --> 00:21:20,000
from the uh from our

00:21:16,880 --> 00:21:21,120
from the pod uh serving serving this

00:21:20,000 --> 00:21:24,159
event

00:21:21,120 --> 00:21:27,919
and as we can see uh these events

00:21:24,159 --> 00:21:31,200
are uh mqtt messages

00:21:27,919 --> 00:21:34,720
are now uh uh changed to different

00:21:31,200 --> 00:21:38,080
uh to appropriate cloud events

00:21:34,720 --> 00:21:39,919
uh we can see uh some of the the

00:21:38,080 --> 00:21:41,120
the metadata the headers of the cloud

00:21:39,919 --> 00:21:44,080
events like type

00:21:41,120 --> 00:21:45,679
which meaning that it's generated by the

00:21:44,080 --> 00:21:48,159
camel component

00:21:45,679 --> 00:21:50,240
uh from which source is coming the the

00:21:48,159 --> 00:21:50,880
the time step of the event and then

00:21:50,240 --> 00:21:54,919
finally

00:21:50,880 --> 00:21:58,159
uh finally the data so the data now is

00:21:54,919 --> 00:22:02,799
74.12 fahrenheit degrees i

00:21:58,159 --> 00:22:02,799
i assume uh and

00:22:02,960 --> 00:22:08,400
if we go back to the to the definition

00:22:06,480 --> 00:22:11,280
of our source

00:22:08,400 --> 00:22:12,880
what else you can see here is that i

00:22:11,280 --> 00:22:15,760
have uh

00:22:12,880 --> 00:22:16,960
commented out a different thing so

00:22:15,760 --> 00:22:19,520
instead of going to

00:22:16,960 --> 00:22:21,039
directly to the service we could go to

00:22:19,520 --> 00:22:23,760
the in-memory channel or

00:22:21,039 --> 00:22:25,760
kafka channel or or or some kind of

00:22:23,760 --> 00:22:28,480
broker

00:22:25,760 --> 00:22:30,400
defined by the k-native infrastructure

00:22:28,480 --> 00:22:32,640
and implement all these other

00:22:30,400 --> 00:22:34,000
other architectures that that you saw on

00:22:32,640 --> 00:22:37,679
on the slides

00:22:34,000 --> 00:22:40,240
on the slides before so so

00:22:37,679 --> 00:22:40,880
this this is an example of of another

00:22:40,240 --> 00:22:44,720
service

00:22:40,880 --> 00:22:47,360
uh so uh basically reading

00:22:44,720 --> 00:22:48,559
the events coming from the steve's mqtt

00:22:47,360 --> 00:22:51,840
broker

00:22:48,559 --> 00:22:53,039
uh pushing them to the to the uh influx

00:22:51,840 --> 00:22:55,520
db

00:22:53,039 --> 00:22:57,679
and and then having a grafana dashboard

00:22:55,520 --> 00:23:01,200
connected to that input vp and

00:22:57,679 --> 00:23:04,559
showing this uh this temperature in the

00:23:01,200 --> 00:23:06,960
real time so

00:23:04,559 --> 00:23:09,039
if you find content like this useful we

00:23:06,960 --> 00:23:12,000
want to invite you to become a member of

00:23:09,039 --> 00:23:13,760
the kubernetes iot edge working group

00:23:12,000 --> 00:23:15,760
we're not really writing code on

00:23:13,760 --> 00:23:18,000
kubernetes but we are focused on

00:23:15,760 --> 00:23:19,760
applying kubernetes with open source

00:23:18,000 --> 00:23:23,200
tools to edge and iot

00:23:19,760 --> 00:23:25,760
use cases we have online zoom meetings

00:23:23,200 --> 00:23:27,600
every two weeks at alternating times to

00:23:25,760 --> 00:23:29,600
accommodate members in

00:23:27,600 --> 00:23:31,200
different time zones as shown here

00:23:29,600 --> 00:23:33,840
there's one series

00:23:31,200 --> 00:23:34,240
uh earmarked for north america the other

00:23:33,840 --> 00:23:37,280
one

00:23:34,240 --> 00:23:39,760
for eastern europe and china

00:23:37,280 --> 00:23:40,799
we encourage a member-driven agenda so

00:23:39,760 --> 00:23:43,200
once you join

00:23:40,799 --> 00:23:44,320
you can nominate topics for

00:23:43,200 --> 00:23:47,360
presentations or

00:23:44,320 --> 00:23:48,000
discussions we're also operating a group

00:23:47,360 --> 00:23:51,840
channel

00:23:48,000 --> 00:23:51,840
on the kubernetes slack

00:23:52,159 --> 00:23:56,799
so we can be contacted using our github

00:23:56,000 --> 00:23:59,840
ids

00:23:56,799 --> 00:24:02,799
that same id as my twitter handle it

00:23:59,840 --> 00:24:04,880
okay so these are our github candles and

00:24:02,799 --> 00:24:07,120
you can use that to reach out to us

00:24:04,880 --> 00:24:08,559
or we're also available on the

00:24:07,120 --> 00:24:11,039
kubernetes slack

00:24:08,559 --> 00:24:13,600
you see here on this slide the link uh

00:24:11,039 --> 00:24:16,720
in the sked site to get a copy of this

00:24:13,600 --> 00:24:16,720
presentation deck

00:24:17,360 --> 00:24:21,440
yeah thanks for joining us for this and

00:24:20,000 --> 00:24:22,080
we're going to hang around for a few

00:24:21,440 --> 00:24:24,799
minutes

00:24:22,080 --> 00:24:25,840
to for q a and at this point i'm going

00:24:24,799 --> 00:24:32,159
to turn it back

00:24:25,840 --> 00:24:34,240
over to the cncf administrative staff

00:24:32,159 --> 00:24:34,240

YouTube URL: https://www.youtube.com/watch?v=btaVSNduULk


