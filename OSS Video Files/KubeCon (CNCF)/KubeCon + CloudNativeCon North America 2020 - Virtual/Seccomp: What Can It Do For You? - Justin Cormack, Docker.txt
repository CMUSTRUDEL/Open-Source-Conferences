Title: Seccomp: What Can It Do For You? - Justin Cormack, Docker
Publication date: 2020-11-23
Playlist: KubeCon + CloudNativeCon North America 2020 - Virtual
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon Europe 2021 Virtual from May 4â€“7, 2021. Learn more at https://kubecon.io. The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Seccomp: What Can It Do For You? - Justin Cormack, Docker 

Seccomp is a system call filtering tool built into Linux. It has been used as a security layer in Docker for coming up to five years, and is working through a long path to become on by default in Kubernetes. We look at what seccomp can usefully do to improve real world security, and how best to use it. This talk also covers a reworking of the widely used Docker default seccomp policy, based on experience of security vulnerabilities in the last five years. Seccomp can both be used as a policy in a runtime, and also directly by applications, so both aspects are covered. The policy has also caused a number of usability issues over the years, so we look at the pitfalls involved in using it as syscalls change over time. 

https://sched.co/ekEJ
Captions: 
	00:00:00,560 --> 00:00:04,400
hello welcome to kubecon

00:00:03,199 --> 00:00:07,200
um today i'm going to be talking about

00:00:04,400 --> 00:00:08,960
setcomp what it can do for you

00:00:07,200 --> 00:00:10,240
um i'm going to talk all about what

00:00:08,960 --> 00:00:11,920
we've been doing in setcomp in the

00:00:10,240 --> 00:00:13,759
container ecosystem and

00:00:11,920 --> 00:00:15,839
what is it and why does it matter and

00:00:13,759 --> 00:00:18,560
what is there what work is there to do

00:00:15,839 --> 00:00:18,560
in the future

00:00:19,600 --> 00:00:26,720
um so um

00:00:24,160 --> 00:00:27,519
i i'm just in cormac i'm an engineer at

00:00:26,720 --> 00:00:29,519
docker

00:00:27,519 --> 00:00:32,079
in cambridge and i've i'm also on the

00:00:29,519 --> 00:00:34,320
cncftsc and a naturey maintainer so i'm

00:00:32,079 --> 00:00:38,160
and i'm very much involved in the

00:00:34,320 --> 00:00:38,160
container security ecosystem

00:00:41,120 --> 00:00:46,480
um so what what is setcomp anyway and

00:00:44,719 --> 00:00:48,879
why does it matter

00:00:46,480 --> 00:00:51,199
setcomp is a thing that stands for

00:00:48,879 --> 00:00:53,360
secure computing which sounds like a

00:00:51,199 --> 00:00:55,199
really great thing it's a bit of a

00:00:53,360 --> 00:00:58,000
ambitious name perhaps

00:00:55,199 --> 00:01:00,000
um back in 2005 when it was first

00:00:58,000 --> 00:01:01,680
created it was basically an extreme

00:01:00,000 --> 00:01:04,559
sandboxing method um

00:01:01,680 --> 00:01:06,240
when extreme sandboxing wasn't actually

00:01:04,559 --> 00:01:09,119
that common a thing

00:01:06,240 --> 00:01:09,600
um it was really just for code that just

00:01:09,119 --> 00:01:11,920
does

00:01:09,600 --> 00:01:14,240
computer operations and it could only

00:01:11,920 --> 00:01:17,840
read or write from existing files

00:01:14,240 --> 00:01:18,960
and basically exit it wasn't used very

00:01:17,840 --> 00:01:20,560
much because

00:01:18,960 --> 00:01:22,080
there actually aren't very many programs

00:01:20,560 --> 00:01:24,000
that literally just read and write from

00:01:22,080 --> 00:01:25,759
files and can't for example make new

00:01:24,000 --> 00:01:26,000
network connections or anything like

00:01:25,759 --> 00:01:30,159
that

00:01:26,000 --> 00:01:32,479
at all um so in 2013

00:01:30,159 --> 00:01:34,240
uh a more general version was introduced

00:01:32,479 --> 00:01:35,920
which is called second bpf but it's

00:01:34,240 --> 00:01:39,360
usually just called setcom because it's

00:01:35,920 --> 00:01:42,000
the most commonly used version

00:01:39,360 --> 00:01:43,200
and there's a small uh bpf program so

00:01:42,000 --> 00:01:45,040
bpf is a

00:01:43,200 --> 00:01:46,320
technique originally used for in the

00:01:45,040 --> 00:01:49,040
network stack

00:01:46,320 --> 00:01:50,079
um you've probably heard about recently

00:01:49,040 --> 00:01:53,040
about his grown-up

00:01:50,079 --> 00:01:54,880
ebpf extended version but bpf is the

00:01:53,040 --> 00:01:56,960
kind of original simple version lets you

00:01:54,880 --> 00:01:58,799
write very simple programs

00:01:56,960 --> 00:02:00,479
to decide if system calls should be

00:01:58,799 --> 00:02:01,840
allowed or not or

00:02:00,479 --> 00:02:04,240
if they're not allowed whether they

00:02:01,840 --> 00:02:07,280
should error or be logged or kill the

00:02:04,240 --> 00:02:09,599
processors running them so effectively

00:02:07,280 --> 00:02:11,039
because system calls are the interface

00:02:09,599 --> 00:02:13,520
between

00:02:11,039 --> 00:02:16,239
applications and the kernel this

00:02:13,520 --> 00:02:19,680
basically is a method of controlling

00:02:16,239 --> 00:02:22,480
what programs can actually um do

00:02:19,680 --> 00:02:24,160
outside just computing stuff so what

00:02:22,480 --> 00:02:25,760
kind of interaction they have with the

00:02:24,160 --> 00:02:28,879
outside world which sounds

00:02:25,760 --> 00:02:30,800
really useful so in theory you can take

00:02:28,879 --> 00:02:32,959
a look at what a program is doing

00:02:30,800 --> 00:02:34,400
system calls are shown by s trace i show

00:02:32,959 --> 00:02:37,440
in the s trace of um

00:02:34,400 --> 00:02:39,360
adjusting ls um and for each of these

00:02:37,440 --> 00:02:42,480
system calls you can basically say

00:02:39,360 --> 00:02:44,959
yeah that's fine no that's not fine you

00:02:42,480 --> 00:02:46,239
haven't got permission to do that

00:02:44,959 --> 00:02:48,720
you can pretend the system call doesn't

00:02:46,239 --> 00:02:52,000
exist at all which is enosis

00:02:48,720 --> 00:02:55,280
um or any other kind of operation

00:02:52,000 --> 00:02:56,319
so that's the theory in practice it's

00:02:55,280 --> 00:02:59,440
not quite like that

00:02:56,319 --> 00:03:00,959
for so for our examples there when you

00:02:59,440 --> 00:03:03,599
open a file

00:03:00,959 --> 00:03:05,120
um with setcomp you don't actually get

00:03:03,599 --> 00:03:06,720
your program doesn't actually get to see

00:03:05,120 --> 00:03:07,920
what the file name was

00:03:06,720 --> 00:03:10,319
unfortunately because it just sees the

00:03:07,920 --> 00:03:14,159
direct arguments of the system call

00:03:10,319 --> 00:03:16,879
and the argument for a open system call

00:03:14,159 --> 00:03:18,720
isn't directly a string it's actually

00:03:16,879 --> 00:03:20,239
just a pointer to a string and all you

00:03:18,720 --> 00:03:21,599
guess is the pointer and you can't

00:03:20,239 --> 00:03:22,159
follow the pointer to see what it

00:03:21,599 --> 00:03:26,080
pointed

00:03:22,159 --> 00:03:29,120
at which is the name so you have to make

00:03:26,080 --> 00:03:31,200
um decisions actually based on quite

00:03:29,120 --> 00:03:33,040
limited information compared to what you

00:03:31,200 --> 00:03:36,159
might want

00:03:33,040 --> 00:03:38,239
um and and so

00:03:36,159 --> 00:03:39,280
and yours this is kind of limiting you

00:03:38,239 --> 00:03:40,959
also you can't

00:03:39,280 --> 00:03:43,200
know what kind of file descriptor has

00:03:40,959 --> 00:03:44,879
been used if someone's doing a read

00:03:43,200 --> 00:03:46,560
it could be read from a network or read

00:03:44,879 --> 00:03:48,080
from a local file and you might want to

00:03:46,560 --> 00:03:50,760
allow one and not the other

00:03:48,080 --> 00:03:52,159
you can't do that there's also weird

00:03:50,760 --> 00:03:54,480
peculiarities

00:03:52,159 --> 00:03:56,159
um and you also didn't really get any

00:03:54,480 --> 00:03:57,760
context you're just called every time

00:03:56,159 --> 00:04:00,560
the system call and

00:03:57,760 --> 00:04:02,480
you can't actually keep state in between

00:04:00,560 --> 00:04:04,480
those so you can't say

00:04:02,480 --> 00:04:06,239
you can do this after you do that but

00:04:04,480 --> 00:04:07,280
not before or anything like that very

00:04:06,239 --> 00:04:09,760
easily

00:04:07,280 --> 00:04:12,480
so there's a bunch of real serious

00:04:09,760 --> 00:04:14,319
limitations

00:04:12,480 --> 00:04:16,079
um the history of it applied to the

00:04:14,319 --> 00:04:19,519
container ecosystem

00:04:16,079 --> 00:04:21,040
um back in early 2016 um

00:04:19,519 --> 00:04:22,479
one of the first things i worked on when

00:04:21,040 --> 00:04:24,400
i started talking with jesse frazelle

00:04:22,479 --> 00:04:27,120
was adding sitcom support for

00:04:24,400 --> 00:04:27,520
docker and it was enabled by default

00:04:27,120 --> 00:04:30,720
which

00:04:27,520 --> 00:04:32,800
was a nice um thing to have done

00:04:30,720 --> 00:04:34,160
and most people don't disable it so most

00:04:32,800 --> 00:04:35,759
people get it got

00:04:34,160 --> 00:04:37,360
you know had the benefit of using it

00:04:35,759 --> 00:04:40,639
since then

00:04:37,360 --> 00:04:42,720
kubernetes um spent a long time

00:04:40,639 --> 00:04:43,919
uh working out on its implementation and

00:04:42,720 --> 00:04:47,600
really only

00:04:43,919 --> 00:04:51,360
in 119 so not very long ago now

00:04:47,600 --> 00:04:54,560
um finalized the um api

00:04:51,360 --> 00:04:58,080
or um and

00:04:54,560 --> 00:05:00,400
it does not enable it by default um

00:04:58,080 --> 00:05:02,400
and it's still um somewhat complicated

00:05:00,400 --> 00:05:05,600
to manage in kubernetes is because

00:05:02,400 --> 00:05:07,919
um sitcom profiles tend to be

00:05:05,600 --> 00:05:10,000
at the moment very long files like the

00:05:07,919 --> 00:05:12,720
docker default one is 800 lines

00:05:10,000 --> 00:05:13,919
long and apparently 800 more lines of

00:05:12,720 --> 00:05:15,919
yaml was seen as

00:05:13,919 --> 00:05:17,039
too much so you have to work out how to

00:05:15,919 --> 00:05:18,720
distribute

00:05:17,039 --> 00:05:20,400
files with this configuration on if you

00:05:18,720 --> 00:05:23,520
want to customize the

00:05:20,400 --> 00:05:24,000
this or you can just use the runtime

00:05:23,520 --> 00:05:25,360
default

00:05:24,000 --> 00:05:28,160
setting which will give you something

00:05:25,360 --> 00:05:30,880
that's pretty much like the um

00:05:28,160 --> 00:05:31,440
like the docker setup basically as given

00:05:30,880 --> 00:05:32,960
you

00:05:31,440 --> 00:05:34,479
by the runtime it'll be the docker one

00:05:32,960 --> 00:05:35,199
if you're using docker if you're using

00:05:34,479 --> 00:05:38,320
container d

00:05:35,199 --> 00:05:40,479
it'll be or cryo it'll be similar

00:05:38,320 --> 00:05:43,759
but um due to kind of maintenance things

00:05:40,479 --> 00:05:43,759
not exactly the same

00:05:44,080 --> 00:05:49,680
um in the sort of oci

00:05:47,680 --> 00:05:51,120
um sort of structure of hierarchy we

00:05:49,680 --> 00:05:53,520
have in the container

00:05:51,120 --> 00:05:54,160
thing where we have kubernetes and then

00:05:53,520 --> 00:05:58,080
cri

00:05:54,160 --> 00:06:00,479
and then um we have um run times

00:05:58,080 --> 00:06:01,199
um it's kind of complicated set up

00:06:00,479 --> 00:06:02,880
because

00:06:01,199 --> 00:06:04,800
um and we'll talk about this a little

00:06:02,880 --> 00:06:06,479
bit more later but um

00:06:04,800 --> 00:06:07,919
there's a bunch of abstraction layers

00:06:06,479 --> 00:06:10,560
this goes through

00:06:07,919 --> 00:06:12,080
um effectively everything's just passed

00:06:10,560 --> 00:06:15,360
down all the way to run c

00:06:12,080 --> 00:06:19,280
which then um it calls the go binding

00:06:15,360 --> 00:06:20,639
to libset comp which is a simplified

00:06:19,280 --> 00:06:24,080
version of what

00:06:20,639 --> 00:06:25,919
the actual sitcom ppf looks like um

00:06:24,080 --> 00:06:28,160
and this and these simplified calls are

00:06:25,919 --> 00:06:33,120
generated from a json config

00:06:28,160 --> 00:06:34,880
that is slightly you know is basically

00:06:33,120 --> 00:06:36,479
abstract again the kind of rules that

00:06:34,880 --> 00:06:39,199
you can use with um

00:06:36,479 --> 00:06:40,800
with lipset comp so there's this weird

00:06:39,199 --> 00:06:42,560
um and then the runtime actually might

00:06:40,800 --> 00:06:43,759
have a different form of the json which

00:06:42,560 --> 00:06:46,160
has it has different

00:06:43,759 --> 00:06:48,000
runtime customizations it's a kind of

00:06:46,160 --> 00:06:50,400
messy kind of process of converting

00:06:48,000 --> 00:06:52,160
jason to jason to go to c to ppf to

00:06:50,400 --> 00:06:57,120
running the kernel

00:06:52,160 --> 00:06:58,800
um so it's it's a bit kind of messy

00:06:57,120 --> 00:07:00,240
what's the point of all this what are we

00:06:58,800 --> 00:07:03,840
actually trying to achieve i think it's

00:07:00,240 --> 00:07:03,840
very important to understand that

00:07:04,960 --> 00:07:11,360
there's some system calls in linux which

00:07:08,479 --> 00:07:14,639
are not really considered safe for

00:07:11,360 --> 00:07:16,319
isolated programs to use

00:07:14,639 --> 00:07:17,840
some of these have a very very large

00:07:16,319 --> 00:07:19,599
attack surface and they've been a lot of

00:07:17,840 --> 00:07:22,880
cves around them

00:07:19,599 --> 00:07:25,199
uh perfect open is one of those uh

00:07:22,880 --> 00:07:26,960
username spaces when bpf we'll talk

00:07:25,199 --> 00:07:27,919
about a bit later these are just very

00:07:26,960 --> 00:07:31,520
large

00:07:27,919 --> 00:07:32,880
subsystems that in general most

00:07:31,520 --> 00:07:36,080
containers

00:07:32,880 --> 00:07:37,280
don't actually need to use um often

00:07:36,080 --> 00:07:40,240
these are used by

00:07:37,280 --> 00:07:41,199
runtimes and and other sort of software

00:07:40,240 --> 00:07:45,039
rather than actually

00:07:41,199 --> 00:07:47,199
end user applications um

00:07:45,039 --> 00:07:48,720
and they've been a lot of cves that

00:07:47,199 --> 00:07:50,800
basically meant that you can escape from

00:07:48,720 --> 00:07:53,599
a container if you can access these

00:07:50,800 --> 00:07:54,960
cisco so blocking them is actually

00:07:53,599 --> 00:07:56,319
proven to be useful we'll talk about

00:07:54,960 --> 00:07:59,199
specific examples of

00:07:56,319 --> 00:08:01,280
where there's been a benefit later um

00:07:59,199 --> 00:08:01,919
some syscalls can disable security

00:08:01,280 --> 00:08:05,440
features

00:08:01,919 --> 00:08:07,039
such as um uh the pr cuddle

00:08:05,440 --> 00:08:08,639
adder no randomize which basically

00:08:07,039 --> 00:08:10,639
disables aslr

00:08:08,639 --> 00:08:12,240
address-based layout randomization which

00:08:10,639 --> 00:08:13,840
is a security feature that's been added

00:08:12,240 --> 00:08:17,360
for good reasons

00:08:13,840 --> 00:08:18,080
um so we applications can simply turn it

00:08:17,360 --> 00:08:20,479
off which is

00:08:18,080 --> 00:08:21,440
uh really unhelpful and some things are

00:08:20,479 --> 00:08:23,759
obsolete cis

00:08:21,440 --> 00:08:26,879
there's a cis kettle as opposed to using

00:08:23,759 --> 00:08:30,160
csfs which in linux has historically

00:08:26,879 --> 00:08:33,120
been generally has been deprecated for

00:08:30,160 --> 00:08:34,880
uh some decades now and has some attack

00:08:33,120 --> 00:08:35,839
surface and is not really maintained as

00:08:34,880 --> 00:08:37,839
some distress

00:08:35,839 --> 00:08:39,279
i think have removed this now but not

00:08:37,839 --> 00:08:41,039
all of them

00:08:39,279 --> 00:08:42,959
and then there's always been some things

00:08:41,039 --> 00:08:46,240
that have not been namespaced

00:08:42,959 --> 00:08:47,600
um time namespaces are very very new and

00:08:46,240 --> 00:08:49,760
it came out a few months ago

00:08:47,600 --> 00:08:51,680
and key ring namespaces don't exist yet

00:08:49,760 --> 00:08:53,600
so there's a bunch of stuff that

00:08:51,680 --> 00:08:55,680
in a container system it makes sense to

00:08:53,600 --> 00:08:58,320
just remove the ability of applications

00:08:55,680 --> 00:09:00,320
to use it

00:08:58,320 --> 00:09:01,360
so what have we succeeded in doing with

00:09:00,320 --> 00:09:04,480
the sepca

00:09:01,360 --> 00:09:07,440
sitcom subsystem um

00:09:04,480 --> 00:09:08,880
username spaces there's this quote from

00:09:07,440 --> 00:09:10,240
angela mursky is one of the kind of

00:09:08,880 --> 00:09:13,760
maintainers

00:09:10,240 --> 00:09:16,800
you know basically um saying that the

00:09:13,760 --> 00:09:18,160
huge attack surface from user namespaces

00:09:16,800 --> 00:09:20,959
is huge risk

00:09:18,160 --> 00:09:22,800
um and if unprivileged users can program

00:09:20,959 --> 00:09:24,640
ip tables they're bound to be some

00:09:22,800 --> 00:09:25,839
privilege escalations he said this was

00:09:24,640 --> 00:09:28,480
before

00:09:25,839 --> 00:09:29,839
um this was you know this was actually

00:09:28,480 --> 00:09:31,839
quite a few years ago before when this

00:09:29,839 --> 00:09:34,080
functionality was kind of new

00:09:31,839 --> 00:09:35,120
and shortly after that i think the same

00:09:34,080 --> 00:09:38,880
year we saw cv

00:09:35,120 --> 00:09:39,920
2016 33 134 and a bunch of related cvs

00:09:38,880 --> 00:09:43,040
here

00:09:39,920 --> 00:09:46,240
where indeed the iptables code

00:09:43,040 --> 00:09:47,200
had some bounce checks missing and you

00:09:46,240 --> 00:09:50,640
could basically

00:09:47,200 --> 00:09:54,480
exploit this to get full refull

00:09:50,640 --> 00:09:56,880
pros and container escape um

00:09:54,480 --> 00:09:58,720
normally this needs cap net admin which

00:09:56,880 --> 00:10:00,399
is not granted so normally it's safe but

00:09:58,720 --> 00:10:01,600
if you're using the namespaces you get

00:10:00,399 --> 00:10:03,839
capnet admin in

00:10:01,600 --> 00:10:06,000
your username space you can call these

00:10:03,839 --> 00:10:07,839
commands in your username space

00:10:06,000 --> 00:10:10,480
you can't change root ip tables

00:10:07,839 --> 00:10:12,160
functions but you can

00:10:10,480 --> 00:10:13,519
compromise the kernel so it doesn't

00:10:12,160 --> 00:10:16,320
really matter whether it's

00:10:13,519 --> 00:10:16,839
actually which namespace it's in um this

00:10:16,320 --> 00:10:20,079
was

00:10:16,839 --> 00:10:20,640
mitigated by docker's default um policy

00:10:20,079 --> 00:10:23,839
and so

00:10:20,640 --> 00:10:26,959
users using that were not affected

00:10:23,839 --> 00:10:30,160
um more recently um

00:10:26,959 --> 00:10:32,160
again the bpf verifier

00:10:30,160 --> 00:10:33,360
which again is is a is a new feature for

00:10:32,160 --> 00:10:36,800
extended bpf

00:10:33,360 --> 00:10:39,440
um i had some uh

00:10:36,800 --> 00:10:40,160
bounds checks on 32-bit operations that

00:10:39,440 --> 00:10:41,920
were

00:10:40,160 --> 00:10:43,680
not enforced and you could read and

00:10:41,920 --> 00:10:44,079
write kernel memory which basically

00:10:43,680 --> 00:10:47,519
means

00:10:44,079 --> 00:10:49,440
you can control the entire host um

00:10:47,519 --> 00:10:51,920
again an unprivileged user with access

00:10:49,440 --> 00:10:54,800
to ppf cisco could do this again

00:10:51,920 --> 00:10:55,760
the docker policy blocks use the bpf by

00:10:54,800 --> 00:10:58,480
default

00:10:55,760 --> 00:11:00,560
um unless you actually grant caps's

00:10:58,480 --> 00:11:03,440
admin which is basically a privilege to

00:11:00,560 --> 00:11:06,800
access anyway

00:11:03,440 --> 00:11:07,680
um so this sounds good uh what went

00:11:06,800 --> 00:11:11,040
wrong

00:11:07,680 --> 00:11:11,839
um actually we caused a lot of problems

00:11:11,040 --> 00:11:13,920
for users

00:11:11,839 --> 00:11:14,880
during the last five years with setcomp

00:11:13,920 --> 00:11:18,160
um

00:11:14,880 --> 00:11:20,240
i had a bit of a war on emacs

00:11:18,160 --> 00:11:23,120
i stopped people running emacs in

00:11:20,240 --> 00:11:24,399
containers with setcomp enabled for many

00:11:23,120 --> 00:11:26,800
years

00:11:24,399 --> 00:11:28,240
um this was a really strange story it

00:11:26,800 --> 00:11:30,160
really surprised me when

00:11:28,240 --> 00:11:32,000
this the complaints came in about this

00:11:30,160 --> 00:11:35,760
quite early on

00:11:32,000 --> 00:11:38,480
um emacs had this very very strange

00:11:35,760 --> 00:11:40,240
thing that um a lot of people didn't

00:11:38,480 --> 00:11:43,279
like for other reasons um

00:11:40,240 --> 00:11:44,560
the muscle lipsy maintainer was

00:11:43,279 --> 00:11:47,839
against it because it didn't work with

00:11:44,560 --> 00:11:50,800
muzzle lipsc as well but basically

00:11:47,839 --> 00:11:51,440
it in order to make startup of emacs

00:11:50,800 --> 00:11:54,560
faster

00:11:51,440 --> 00:11:57,120
it used to um during a build time

00:11:54,560 --> 00:11:59,120
it would start running the binary then

00:11:57,120 --> 00:12:01,760
dump the output and then

00:11:59,120 --> 00:12:02,720
instead of um re-running the code that

00:12:01,760 --> 00:12:05,440
generated this

00:12:02,720 --> 00:12:06,320
the initial setup it would just load the

00:12:05,440 --> 00:12:08,720
memory

00:12:06,320 --> 00:12:10,560
snapshot basically but the way it

00:12:08,720 --> 00:12:12,560
required to do this was very normal but

00:12:10,560 --> 00:12:14,399
it required memory locations to

00:12:12,560 --> 00:12:16,800
be loaded exactly the same way as they

00:12:14,399 --> 00:12:18,160
were before and if you had aslr

00:12:16,800 --> 00:12:20,079
this was not the case because memory

00:12:18,160 --> 00:12:21,279
locations would be randomized and so

00:12:20,079 --> 00:12:24,160
wouldn't work

00:12:21,279 --> 00:12:25,440
so it disabled it by disabling

00:12:24,160 --> 00:12:27,040
randomization

00:12:25,440 --> 00:12:28,639
but this was one of the things was

00:12:27,040 --> 00:12:29,920
explicitly blocked because this

00:12:28,639 --> 00:12:32,560
basically is

00:12:29,920 --> 00:12:33,279
allowing applications to bypass a

00:12:32,560 --> 00:12:36,639
security

00:12:33,279 --> 00:12:38,720
um mitigation eventually

00:12:36,639 --> 00:12:39,839
emacs realized that well computers were

00:12:38,720 --> 00:12:41,040
fast enough you could just run the

00:12:39,839 --> 00:12:42,959
startup code normally

00:12:41,040 --> 00:12:44,800
like a normal application and not stop

00:12:42,959 --> 00:12:48,320
being so good quite so

00:12:44,800 --> 00:12:50,160
weird um and so um

00:12:48,320 --> 00:12:52,399
this problem has gone away and now you

00:12:50,160 --> 00:12:56,399
can happily run emacs in containers

00:12:52,399 --> 00:12:58,399
um but really i just felt it was not

00:12:56,399 --> 00:12:59,680
worth changing the default policy to

00:12:58,399 --> 00:13:01,600
basically um

00:12:59,680 --> 00:13:02,959
reduce security for everyone just so

00:13:01,600 --> 00:13:05,440
that emacs could be run

00:13:02,959 --> 00:13:07,519
more effectively with its weird things

00:13:05,440 --> 00:13:09,200
in a container

00:13:07,519 --> 00:13:11,600
worse than that though worse than

00:13:09,200 --> 00:13:13,200
breaking emacs i also broke steam

00:13:11,600 --> 00:13:15,360
this was not on purpose and not

00:13:13,200 --> 00:13:18,880
something i wanted to do

00:13:15,360 --> 00:13:22,639
um linux has made a bunch of

00:13:18,880 --> 00:13:24,880
changes to 32-bit um this is called abi

00:13:22,639 --> 00:13:27,440
and steam happens to run 32-bit binaries

00:13:24,880 --> 00:13:28,720
and it's widely used in containers

00:13:27,440 --> 00:13:31,120
um and this was something that happened

00:13:28,720 --> 00:13:32,639
really quite early on that um

00:13:31,120 --> 00:13:35,200
debian i think has a habit of doing

00:13:32,639 --> 00:13:36,959
these things first they changed from

00:13:35,200 --> 00:13:38,959
the old socket call syscall that was

00:13:36,959 --> 00:13:39,600
some it was a weird multiplex syscall

00:13:38,959 --> 00:13:41,600
that does

00:13:39,600 --> 00:13:43,839
that could do socket or bind or connect

00:13:41,600 --> 00:13:46,079
or any of the other socket calls and

00:13:43,839 --> 00:13:49,680
switch to separate syscalls

00:13:46,079 --> 00:13:50,240
and we hadn't actually allowed for this

00:13:49,680 --> 00:13:53,440
change

00:13:50,240 --> 00:13:55,360
um and i think debian did it early

00:13:53,440 --> 00:13:57,360
um and they did the same thing with

00:13:55,360 --> 00:13:58,800
64-bit time support on those two-bit

00:13:57,360 --> 00:14:00,079
systems they again

00:13:58,800 --> 00:14:02,480
they switched early before it was

00:14:00,079 --> 00:14:04,240
officially upstream and um

00:14:02,480 --> 00:14:06,240
these were all temporarily blocked by

00:14:04,240 --> 00:14:10,079
said comp until we fixed this problem

00:14:06,240 --> 00:14:11,199
so it is a problem and a fragility issue

00:14:10,079 --> 00:14:13,279
with setcomp that

00:14:11,199 --> 00:14:15,279
because it requires exact cisco lists

00:14:13,279 --> 00:14:16,079
when some new set of syscalls that

00:14:15,279 --> 00:14:18,639
suddenly

00:14:16,079 --> 00:14:19,920
everyone starts using how to come along

00:14:18,639 --> 00:14:21,360
you really have to update the code

00:14:19,920 --> 00:14:23,360
quickly which is

00:14:21,360 --> 00:14:25,760
really problematic and apologies to the

00:14:23,360 --> 00:14:28,839
steam users

00:14:25,760 --> 00:14:32,079
um there's also a performance issue

00:14:28,839 --> 00:14:32,880
um there's actually a lot of rules

00:14:32,079 --> 00:14:34,959
because we

00:14:32,880 --> 00:14:36,560
list the cisco's you can use and not the

00:14:34,959 --> 00:14:39,920
ones you can't use

00:14:36,560 --> 00:14:41,600
and the list is very long um and it's

00:14:39,920 --> 00:14:44,800
not processed terribly efficiently

00:14:41,600 --> 00:14:46,720
for reasons that as mostly somewhat

00:14:44,800 --> 00:14:49,600
fixable but require a lot of work

00:14:46,720 --> 00:14:51,440
um only really i o intensive

00:14:49,600 --> 00:14:54,880
applications will notice this

00:14:51,440 --> 00:14:55,680
um and so actually very few people

00:14:54,880 --> 00:14:57,120
complain but

00:14:55,680 --> 00:14:58,720
a few people have and they've generally

00:14:57,120 --> 00:15:02,240
disabled sitcom rather than

00:14:58,720 --> 00:15:03,360
actually fixing it and then there's some

00:15:02,240 --> 00:15:05,519
interesting areas

00:15:03,360 --> 00:15:06,880
security issues where setcomp didn't

00:15:05,519 --> 00:15:11,279
actually help at all

00:15:06,880 --> 00:15:11,279
and we didn't do anything to help users

00:15:11,600 --> 00:15:15,040
one of which is probably my favorite

00:15:13,760 --> 00:15:18,880
kernel cve

00:15:15,040 --> 00:15:20,959
that jan horn found um this is a

00:15:18,880 --> 00:15:23,199
really interesting security issue in

00:15:20,959 --> 00:15:26,320
linux it's a cash invalidation bug

00:15:23,199 --> 00:15:29,680
um basically

00:15:26,320 --> 00:15:30,399
um there's a there was a a 32-bit

00:15:29,680 --> 00:15:32,560
counter

00:15:30,399 --> 00:15:34,079
and if you did the right thing at the

00:15:32,560 --> 00:15:34,880
point at which the counter wrapped

00:15:34,079 --> 00:15:37,839
around

00:15:34,880 --> 00:15:41,199
back to zero again um you could

00:15:37,839 --> 00:15:43,360
basically um

00:15:41,199 --> 00:15:45,120
exploit the kernel and escape your

00:15:43,360 --> 00:15:46,959
container

00:15:45,120 --> 00:15:49,519
and all you had to do to do this was

00:15:46,959 --> 00:15:53,120
some memory mapping and some cloning of

00:15:49,519 --> 00:15:54,480
processes which is all totally normal

00:15:53,120 --> 00:15:56,240
normal stuff that we couldn't possibly

00:15:54,480 --> 00:15:59,759
block with setcomp

00:15:56,240 --> 00:16:01,680
um so there was just no way we could

00:15:59,759 --> 00:16:04,720
protect against this kind of thing

00:16:01,680 --> 00:16:06,800
um it eventually was changed but

00:16:04,720 --> 00:16:08,880
fixed by changing a counter to b64 bits

00:16:06,800 --> 00:16:10,079
32 bits is too small for any kind of

00:16:08,880 --> 00:16:11,920
security

00:16:10,079 --> 00:16:14,160
um on anything you can always overflow a

00:16:11,920 --> 00:16:16,399
32-bit counter but over flying a 64-bit

00:16:14,160 --> 00:16:18,639
counter

00:16:16,399 --> 00:16:19,440
is pretty impossible because it's so

00:16:18,639 --> 00:16:22,160
huge

00:16:19,440 --> 00:16:23,600
um actually it was actually interesting

00:16:22,160 --> 00:16:25,120
that they were

00:16:23,600 --> 00:16:27,120
this was a this is still a really

00:16:25,120 --> 00:16:29,120
interesting cv and worth looking at but

00:16:27,120 --> 00:16:31,120
it was hard to exploit without having

00:16:29,120 --> 00:16:31,839
some additional source of information to

00:16:31,120 --> 00:16:35,440
know when

00:16:31,839 --> 00:16:36,959
exactly um you'd hit the conditions for

00:16:35,440 --> 00:16:40,880
the exploit

00:16:36,959 --> 00:16:44,000
um and so actually we

00:16:40,880 --> 00:16:46,720
fixed an information leak

00:16:44,000 --> 00:16:48,880
that made it actually made it actually

00:16:46,720 --> 00:16:50,720
relatively exploitable in containers

00:16:48,880 --> 00:16:52,720
uh because of the information leak

00:16:50,720 --> 00:16:56,079
rather than actually because of the um

00:16:52,720 --> 00:16:58,959
seg comp but um sitcom could definitely

00:16:56,079 --> 00:17:02,399
not protect you against that

00:16:58,959 --> 00:17:03,440
um the question is like should we be

00:17:02,399 --> 00:17:06,480
using setcomp

00:17:03,440 --> 00:17:09,360
in this way in the container ecosystem

00:17:06,480 --> 00:17:10,000
um why is the container platform

00:17:09,360 --> 00:17:12,480
basically

00:17:10,000 --> 00:17:14,000
responsible for the the poor kind of

00:17:12,480 --> 00:17:15,120
state of limits kernel security and the

00:17:14,000 --> 00:17:16,799
fact that there are

00:17:15,120 --> 00:17:18,319
container escape vulnerabilities in

00:17:16,799 --> 00:17:19,600
lurks and

00:17:18,319 --> 00:17:21,360
you know what why isn't that the

00:17:19,600 --> 00:17:25,039
kernel's problem

00:17:21,360 --> 00:17:25,839
um and generally i think the answer is

00:17:25,039 --> 00:17:29,840
that we do

00:17:25,839 --> 00:17:31,200
want um efficient isolation without

00:17:29,840 --> 00:17:34,080
going into using

00:17:31,200 --> 00:17:35,600
virtual machines for everything um it's

00:17:34,080 --> 00:17:38,720
actually

00:17:35,600 --> 00:17:40,480
relatively um the number of container

00:17:38,720 --> 00:17:44,160
escapes has bee

00:17:40,480 --> 00:17:45,360
exploits has been not too bad over the

00:17:44,160 --> 00:17:47,039
years

00:17:45,360 --> 00:17:49,440
for most people this level of security

00:17:47,039 --> 00:17:53,120
is actually kind of fine

00:17:49,440 --> 00:17:54,400
um and also most of our applications

00:17:53,120 --> 00:17:56,720
don't use a whole

00:17:54,400 --> 00:17:59,280
you know the whole linux is called space

00:17:56,720 --> 00:18:02,640
most applications use a kind of

00:17:59,280 --> 00:18:04,240
narrow a subset that doesn't include um

00:18:02,640 --> 00:18:05,840
you know the sort of specialized things

00:18:04,240 --> 00:18:08,720
you get in linux doesn't most

00:18:05,840 --> 00:18:11,120
people's code doesn't run most

00:18:08,720 --> 00:18:14,160
application code doesn't run bpf

00:18:11,120 --> 00:18:14,720
it doesn't um run username spaces those

00:18:14,160 --> 00:18:17,600
things

00:18:14,720 --> 00:18:19,600
are being used um for security critical

00:18:17,600 --> 00:18:21,360
applications and often for control plane

00:18:19,600 --> 00:18:23,919
applications but

00:18:21,360 --> 00:18:25,840
end user applications basically just use

00:18:23,919 --> 00:18:27,200
networking and storage and

00:18:25,840 --> 00:18:30,080
i mean some people would say they should

00:18:27,200 --> 00:18:32,720
just use the posix subset and

00:18:30,080 --> 00:18:33,120
um and linux the lens cisco space is

00:18:32,720 --> 00:18:34,960
just

00:18:33,120 --> 00:18:36,559
way too expensive i mean i think there's

00:18:34,960 --> 00:18:39,280
arguments about what the

00:18:36,559 --> 00:18:40,480
boundaries of um what normal

00:18:39,280 --> 00:18:44,000
applications should

00:18:40,480 --> 00:18:45,919
care about are but um

00:18:44,000 --> 00:18:47,360
and it this does change over time with

00:18:45,919 --> 00:18:49,520
kind of performance

00:18:47,360 --> 00:18:50,880
reasons for using different system calls

00:18:49,520 --> 00:18:54,320
and so on but

00:18:50,880 --> 00:18:56,080
um you know it's

00:18:54,320 --> 00:18:58,480
there is actually a kind of set of

00:18:56,080 --> 00:18:59,679
things that most applications don't use

00:18:58,480 --> 00:19:01,679
and it's

00:18:59,679 --> 00:19:03,039
sensible for us to isolate them off for

00:19:01,679 --> 00:19:04,880
security

00:19:03,039 --> 00:19:06,960
um because the common syscalls are

00:19:04,880 --> 00:19:09,520
basically mostly

00:19:06,960 --> 00:19:10,480
most of the time other than that cve i

00:19:09,520 --> 00:19:14,240
just pointed you out

00:19:10,480 --> 00:19:16,160
generally are actually safe um

00:19:14,240 --> 00:19:18,240
setcomp was designed that every

00:19:16,160 --> 00:19:18,880
application would write its own profile

00:19:18,240 --> 00:19:21,600
but

00:19:18,880 --> 00:19:23,280
this is really and right really really

00:19:21,600 --> 00:19:25,039
difficult for users to do

00:19:23,280 --> 00:19:26,880
it was not designed for kind of platform

00:19:25,039 --> 00:19:28,720
administrators and

00:19:26,880 --> 00:19:30,160
like if you read the documentation we're

00:19:28,720 --> 00:19:30,640
kind of doing it wrong in the container

00:19:30,160 --> 00:19:33,360
space

00:19:30,640 --> 00:19:34,640
but it's actually too difficult for end

00:19:33,360 --> 00:19:36,640
user applications

00:19:34,640 --> 00:19:38,480
to use and you only find very very

00:19:36,640 --> 00:19:41,600
specialist applications things like

00:19:38,480 --> 00:19:43,440
you know firecracker use it and um a few

00:19:41,600 --> 00:19:47,440
other things but the

00:19:43,440 --> 00:19:49,039
the number of um general applications

00:19:47,440 --> 00:19:50,720
that actually have set comp profiles is

00:19:49,039 --> 00:19:51,280
really really small and it's incredibly

00:19:50,720 --> 00:19:53,280
difficult

00:19:51,280 --> 00:19:56,320
to use for that function so i'm not

00:19:53,280 --> 00:19:56,320
really surprised

00:19:56,799 --> 00:20:00,640
um i'm going to go through the things

00:19:58,880 --> 00:20:01,520
that we could do choose your adventure

00:20:00,640 --> 00:20:04,000
what future

00:20:01,520 --> 00:20:06,400
paths could we take what what should we

00:20:04,000 --> 00:20:08,400
do in this space

00:20:06,400 --> 00:20:09,520
i think it's definitely the case that

00:20:08,400 --> 00:20:10,880
things need doing

00:20:09,520 --> 00:20:13,280
i'll talk about whether they will be

00:20:10,880 --> 00:20:15,360
done later um

00:20:13,280 --> 00:20:16,480
one option is almost the status quo

00:20:15,360 --> 00:20:18,640
really is that

00:20:16,480 --> 00:20:20,000
almost no one will use setcomp um

00:20:18,640 --> 00:20:23,760
especially with kubernetes it's

00:20:20,000 --> 00:20:24,080
optional there's a few large companies i

00:20:23,760 --> 00:20:25,360
know

00:20:24,080 --> 00:20:28,080
who take it very seriously and think

00:20:25,360 --> 00:20:28,080
it's important

00:20:28,240 --> 00:20:32,400
docker users got it by default but

00:20:30,799 --> 00:20:34,960
gradually

00:20:32,400 --> 00:20:36,480
as people shift over to using uh you

00:20:34,960 --> 00:20:37,120
know kubernetes directly and things like

00:20:36,480 --> 00:20:38,880
that where

00:20:37,120 --> 00:20:40,640
um even if you're using kubernetes with

00:20:38,880 --> 00:20:42,400
docker kubernetes disables the daca

00:20:40,640 --> 00:20:44,320
setcom policy

00:20:42,400 --> 00:20:45,919
um docker's mostly now a development

00:20:44,320 --> 00:20:49,760
platform so i'm not sure it makes sense

00:20:45,919 --> 00:20:51,200
for docker to enforce it anymore

00:20:49,760 --> 00:20:52,799
if you're not going to use it i

00:20:51,200 --> 00:20:56,240
recommend you update your kernel

00:20:52,799 --> 00:20:59,600
weekly that's a that's a burden

00:20:56,240 --> 00:21:01,440
maybe using setcomp means you can do it

00:20:59,600 --> 00:21:03,440
less often than that

00:21:01,440 --> 00:21:04,720
maybe you get a higher rate of zero days

00:21:03,440 --> 00:21:06,400
um but the rate's

00:21:04,720 --> 00:21:08,159
relatively low maybe you can live with

00:21:06,400 --> 00:21:09,520
it i i suspect that

00:21:08,159 --> 00:21:11,840
a lot of people are going to just

00:21:09,520 --> 00:21:15,280
continue to ignore it

00:21:11,840 --> 00:21:17,600
um and just live with those

00:21:15,280 --> 00:21:20,640
vulnerabilities

00:21:17,600 --> 00:21:24,080
um i don't think we could actually

00:21:20,640 --> 00:21:26,480
um rationalize the policy we

00:21:24,080 --> 00:21:28,320
we went for an allow this not a block

00:21:26,480 --> 00:21:30,000
list at the beginning because

00:21:28,320 --> 00:21:32,080
of the whole issue i mean it's the

00:21:30,000 --> 00:21:33,440
recommended thing with setcomp it's the

00:21:32,080 --> 00:21:34,480
recommended thing with most security

00:21:33,440 --> 00:21:36,960
things

00:21:34,480 --> 00:21:37,760
just uh you know you know what you

00:21:36,960 --> 00:21:39,760
what's safe

00:21:37,760 --> 00:21:42,000
you list what's safe and then everything

00:21:39,760 --> 00:21:45,120
else is blocked and so if there's a new

00:21:42,000 --> 00:21:47,919
dangerous syscall added and many

00:21:45,120 --> 00:21:49,840
arguably the new cisco's office often do

00:21:47,919 --> 00:21:50,799
have security issues more than the old

00:21:49,840 --> 00:21:54,799
ones

00:21:50,799 --> 00:21:57,679
um then you're safe however

00:21:54,799 --> 00:21:58,240
um the list of things we block is now

00:21:57,679 --> 00:22:02,960
quite

00:21:58,240 --> 00:22:06,640
small and writing the block policy

00:22:02,960 --> 00:22:08,640
is much easier and

00:22:06,640 --> 00:22:11,200
it's easier to understand it's less

00:22:08,640 --> 00:22:13,360
likely to break something when

00:22:11,200 --> 00:22:15,679
new safe syscalls are added like the the

00:22:13,360 --> 00:22:16,799
time 64 ones for those stupid systems

00:22:15,679 --> 00:22:18,799
which were

00:22:16,799 --> 00:22:20,000
you know these things it turns out that

00:22:18,799 --> 00:22:23,440
there's new

00:22:20,000 --> 00:22:25,280
safe cisco's added a lot of the time

00:22:23,440 --> 00:22:26,559
because probably because of stupid

00:22:25,280 --> 00:22:28,720
things like there weren't enough flags

00:22:26,559 --> 00:22:30,640
allocated on cisco's and there's now

00:22:28,720 --> 00:22:32,799
new cisco's with more flags being added

00:22:30,640 --> 00:22:35,600
for everything things like that

00:22:32,799 --> 00:22:37,360
um these block policies would be easier

00:22:35,600 --> 00:22:37,919
to understand because you can see what

00:22:37,360 --> 00:22:39,760
they do

00:22:37,919 --> 00:22:42,159
rather than try and re work out the

00:22:39,760 --> 00:22:44,720
negative of what they do

00:22:42,159 --> 00:22:45,679
um they wouldn't be 800 lines long they

00:22:44,720 --> 00:22:48,720
would be maybe

00:22:45,679 --> 00:22:50,240
10 lines long so we could actually

00:22:48,720 --> 00:22:52,080
inline them in the yaml we'd have to

00:22:50,240 --> 00:22:54,000
obviously change the kubernetes setcom

00:22:52,080 --> 00:22:56,640
format again to do this um

00:22:54,000 --> 00:22:58,320
but you know i think this would be kind

00:22:56,640 --> 00:23:02,799
of nice if you could say

00:22:58,320 --> 00:23:04,480
allow bpf to remove the default block

00:23:02,799 --> 00:23:06,480
list approach to bpf

00:23:04,480 --> 00:23:07,760
um and that would be the one line you

00:23:06,480 --> 00:23:11,600
need allow bpf allow

00:23:07,760 --> 00:23:12,559
open perf event um that kind of thing so

00:23:11,600 --> 00:23:15,120
i think that would be

00:23:12,559 --> 00:23:16,320
easier to understand there would be less

00:23:15,120 --> 00:23:18,000
maintenance work you

00:23:16,320 --> 00:23:19,679
wouldn't get people complaining things

00:23:18,000 --> 00:23:21,679
don't work and needing to suddenly fix

00:23:19,679 --> 00:23:23,440
them

00:23:21,679 --> 00:23:25,200
a lot of these problems have been like

00:23:23,440 --> 00:23:26,960
cross architecture problems with

00:23:25,200 --> 00:23:29,919
architectures have different syscalls

00:23:26,960 --> 00:23:32,480
and new changes and people running

00:23:29,919 --> 00:23:34,320
um you know a distro that expects one

00:23:32,480 --> 00:23:35,919
kernel on another and it behaves

00:23:34,320 --> 00:23:37,679
differently

00:23:35,919 --> 00:23:38,960
so those kind of issues could be

00:23:37,679 --> 00:23:42,400
improved

00:23:38,960 --> 00:23:42,960
um the error the error support would

00:23:42,400 --> 00:23:47,600
probably be

00:23:42,960 --> 00:23:50,080
better with um things like that so

00:23:47,600 --> 00:23:51,039
um the downside is there's potentially

00:23:50,080 --> 00:23:52,640
that blockless

00:23:51,039 --> 00:23:54,159
the default block list gets very small

00:23:52,640 --> 00:23:55,840
because everyone decides that these

00:23:54,159 --> 00:23:58,799
things are okay

00:23:55,840 --> 00:23:59,600
um so but i think this this is

00:23:58,799 --> 00:24:02,840
attractive

00:23:59,600 --> 00:24:04,159
and um i think it's definitely worth

00:24:02,840 --> 00:24:06,799
considering

00:24:04,159 --> 00:24:08,400
um we have a huge problem in the

00:24:06,799 --> 00:24:11,840
kubernetes ecosystem but

00:24:08,400 --> 00:24:14,080
whose problem is this should users

00:24:11,840 --> 00:24:17,200
really have to understand about setcomp

00:24:14,080 --> 00:24:18,960
no um should applications have to

00:24:17,200 --> 00:24:20,400
understand it too difficult

00:24:18,960 --> 00:24:22,000
is it but should it be done at the

00:24:20,400 --> 00:24:23,520
kubernetes level

00:24:22,000 --> 00:24:25,120
where you have to configure it now or

00:24:23,520 --> 00:24:29,120
should it be the responsibility of the

00:24:25,120 --> 00:24:30,960
cri or run or the sort of run c

00:24:29,120 --> 00:24:32,320
type layer of the actual container

00:24:30,960 --> 00:24:33,919
runtime

00:24:32,320 --> 00:24:36,720
currently we're pushing responsibility

00:24:33,919 --> 00:24:39,840
up to the user which is kind of terrible

00:24:36,720 --> 00:24:40,400
um we why don't we have runtimes that

00:24:39,840 --> 00:24:42,480
provide

00:24:40,400 --> 00:24:44,320
actual security guarantees instead of

00:24:42,480 --> 00:24:46,080
just letting you configure it and making

00:24:44,320 --> 00:24:47,440
it your choice

00:24:46,080 --> 00:24:49,440
we are starting to see some of these

00:24:47,440 --> 00:24:50,799
runtimes i mean arguably g visor which

00:24:49,440 --> 00:24:53,200
i'll talk about in a second

00:24:50,799 --> 00:24:55,520
and vm runtimes are basically trying to

00:24:53,200 --> 00:24:59,919
make better security guarantees

00:24:55,520 --> 00:25:00,559
um you know but why have we pushed down

00:24:59,919 --> 00:25:03,360
this whole

00:25:00,559 --> 00:25:04,640
idea that you list a bunch of syscalls

00:25:03,360 --> 00:25:06,080
in json which is

00:25:04,640 --> 00:25:07,520
what's this called handling rules and

00:25:06,080 --> 00:25:07,919
json which is what we're doing it's a

00:25:07,520 --> 00:25:10,320
it's

00:25:07,919 --> 00:25:12,640
not a good design and there's a

00:25:10,320 --> 00:25:15,600
definitely a layering and responsibility

00:25:12,640 --> 00:25:19,120
issue that we need to solve

00:25:15,600 --> 00:25:20,960
g visor g visas a really interesting

00:25:19,120 --> 00:25:24,559
response to this it basically

00:25:20,960 --> 00:25:28,640
um it basically reimplements

00:25:24,559 --> 00:25:30,799
large portions of works in go um

00:25:28,640 --> 00:25:32,880
basically it kind of um you know has a

00:25:30,799 --> 00:25:33,440
go tcp stack and everything it basically

00:25:32,880 --> 00:25:35,200
says well

00:25:33,440 --> 00:25:37,039
linux wasn't very secure we're going to

00:25:35,200 --> 00:25:39,200
re-implement it

00:25:37,039 --> 00:25:41,600
in go in user space in a memory safe

00:25:39,200 --> 00:25:42,720
language and

00:25:41,600 --> 00:25:44,720
then we're going to wrap this up we're

00:25:42,720 --> 00:25:46,240
going to use setcomp internally in it

00:25:44,720 --> 00:25:47,919
just to make because it doesn't actually

00:25:46,240 --> 00:25:49,600
use many syscalls

00:25:47,919 --> 00:25:51,200
it has a performance hit and it

00:25:49,600 --> 00:25:52,400
potentially has compatibility here but

00:25:51,200 --> 00:25:55,039
it's a

00:25:52,400 --> 00:25:56,240
just like cut out all this security

00:25:55,039 --> 00:25:57,760
issues from linux

00:25:56,240 --> 00:25:59,360
is as a solution it's a really

00:25:57,760 --> 00:26:00,240
interesting solution and definitely

00:25:59,360 --> 00:26:03,600
worth

00:26:00,240 --> 00:26:05,200
looking at um

00:26:03,600 --> 00:26:08,159
something that i call the lambda-like

00:26:05,200 --> 00:26:09,360
solution um i don't know is lambda

00:26:08,159 --> 00:26:11,200
kind of solved a lot of these problems

00:26:09,360 --> 00:26:14,240
by having a very restricted

00:26:11,200 --> 00:26:14,720
um i said container runtime it's strict

00:26:14,240 --> 00:26:16,000
i mean

00:26:14,720 --> 00:26:18,640
people don't think of it as a container

00:26:16,000 --> 00:26:21,760
but it's a very similar problem space

00:26:18,640 --> 00:26:23,279
um user said comp um

00:26:21,760 --> 00:26:24,799
i haven't actually probed this policy to

00:26:23,279 --> 00:26:25,760
see what exactly what it doesn't doesn't

00:26:24,799 --> 00:26:27,919
allow

00:26:25,760 --> 00:26:31,039
it has a custom learner's kernel with

00:26:27,919 --> 00:26:34,159
features removed which is what um

00:26:31,039 --> 00:26:35,520
a lot of people who run secure systems

00:26:34,159 --> 00:26:37,840
do is just disable

00:26:35,520 --> 00:26:39,120
a lot of parts of the linux kernel this

00:26:37,840 --> 00:26:40,320
has thousands and thousands of

00:26:39,120 --> 00:26:43,760
subsystems that

00:26:40,320 --> 00:26:46,240
are not generally very secure and

00:26:43,760 --> 00:26:46,960
you can often access them by from user

00:26:46,240 --> 00:26:49,440
space

00:26:46,960 --> 00:26:51,520
by opening weird kinds of sockets that

00:26:49,440 --> 00:26:53,120
you don't really use in practice much

00:26:51,520 --> 00:26:57,360
and things like that

00:26:53,120 --> 00:26:59,120
um but the linux distro is

00:26:57,360 --> 00:27:01,279
a very general purpose and they tend to

00:26:59,120 --> 00:27:02,880
ship with a kernel that does

00:27:01,279 --> 00:27:04,400
everything has everything as a module

00:27:02,880 --> 00:27:06,000
loads anything because you know

00:27:04,400 --> 00:27:08,400
the general purpose you might want to do

00:27:06,000 --> 00:27:10,559
anything um

00:27:08,400 --> 00:27:11,840
not many people have locked down those

00:27:10,559 --> 00:27:15,919
kernel configs

00:27:11,840 --> 00:27:19,360
um again you probably should consider

00:27:15,919 --> 00:27:21,760
doing this but everyone's kind of um

00:27:19,360 --> 00:27:23,520
lives with their vendor configs for

00:27:21,760 --> 00:27:25,360
support reasons and stuff like that and

00:27:23,520 --> 00:27:26,080
the vendors are not actually necessarily

00:27:25,360 --> 00:27:29,279
acting

00:27:26,080 --> 00:27:30,960
in your security interests all the time

00:27:29,279 --> 00:27:32,640
um also in lambda no applications can

00:27:30,960 --> 00:27:33,360
run as root full stop it just doesn't

00:27:32,640 --> 00:27:35,520
allow it

00:27:33,360 --> 00:27:37,039
um again in container space we haven't

00:27:35,520 --> 00:27:39,120
forced that again that's left to the

00:27:37,039 --> 00:27:41,919
user to enforce that

00:27:39,120 --> 00:27:42,720
um you know there's a restricted runtime

00:27:41,919 --> 00:27:44,480
api

00:27:42,720 --> 00:27:46,240
most of the file system is not writable

00:27:44,480 --> 00:27:47,840
and things like that in lambda

00:27:46,240 --> 00:27:49,600
we could do something very much like

00:27:47,840 --> 00:27:52,159
this we could have a

00:27:49,600 --> 00:27:53,679
you know a container runtime that made

00:27:52,159 --> 00:27:57,039
these choices

00:27:53,679 --> 00:28:00,000
um and had a clear delineation of

00:27:57,039 --> 00:28:01,919
what you can and can't do and a security

00:28:00,000 --> 00:28:02,720
model and testing and things like that

00:28:01,919 --> 00:28:05,840
in a way the

00:28:02,720 --> 00:28:07,919
um the sandboxed flag proposal for

00:28:05,840 --> 00:28:10,320
kubernetes is kind of like this but it

00:28:07,919 --> 00:28:12,640
doesn't define any kind of specification

00:28:10,320 --> 00:28:14,080
it's a bit kind of some things can be

00:28:12,640 --> 00:28:14,640
sandboxed and some things might not be

00:28:14,080 --> 00:28:16,559
but and

00:28:14,640 --> 00:28:18,720
they can decide what sandboxing is but

00:28:16,559 --> 00:28:21,919
there's no kind of linux

00:28:18,720 --> 00:28:24,559
um runtime that makes these decisions

00:28:21,919 --> 00:28:25,919
um in effect the things like the

00:28:24,559 --> 00:28:28,320
firecracker container to

00:28:25,919 --> 00:28:29,440
effectively kind of make those decisions

00:28:28,320 --> 00:28:33,279
for you

00:28:29,440 --> 00:28:34,799
um ish but um

00:28:33,279 --> 00:28:37,600
but there isn't a kind of normal

00:28:34,799 --> 00:28:40,640
container runtime that does that

00:28:37,600 --> 00:28:42,320
um as of linux 5.7 there's something

00:28:40,640 --> 00:28:43,919
that we've been talking about for a

00:28:42,320 --> 00:28:44,720
really really long time that got merged

00:28:43,919 --> 00:28:48,399
the ebf

00:28:44,720 --> 00:28:49,120
ebpf lsm lsm has done a security module

00:28:48,399 --> 00:28:50,799
module

00:28:49,120 --> 00:28:52,159
these are things like se linux and app

00:28:50,799 --> 00:28:55,840
armor

00:28:52,159 --> 00:28:58,720
but selenius and f armor give you um

00:28:55,840 --> 00:29:00,240
a kind of general purpose way of

00:28:58,720 --> 00:29:03,520
configuring these

00:29:00,240 --> 00:29:06,240
ls these security hooks in linux for

00:29:03,520 --> 00:29:07,520
general purpose systems the ebpf lsm

00:29:06,240 --> 00:29:10,159
basically says

00:29:07,520 --> 00:29:11,679
you can inject at each of the decision

00:29:10,159 --> 00:29:12,559
points in the kernel where it decides

00:29:11,679 --> 00:29:16,399
can a user

00:29:12,559 --> 00:29:18,080
do or not do something um

00:29:16,399 --> 00:29:19,520
and there are a lot of these points

00:29:18,080 --> 00:29:20,960
they're much more than just at the

00:29:19,520 --> 00:29:22,960
syscall there they're all sorts of

00:29:20,960 --> 00:29:25,120
places like um

00:29:22,960 --> 00:29:26,480
and there and you get much more specific

00:29:25,120 --> 00:29:28,159
information about what's going on at

00:29:26,480 --> 00:29:29,679
these places as well than you do at this

00:29:28,159 --> 00:29:32,720
this is called abi

00:29:29,679 --> 00:29:34,240
um you can basically run an ebpf program

00:29:32,720 --> 00:29:36,480
that can make real

00:29:34,240 --> 00:29:37,520
programmatic decisions about can this

00:29:36,480 --> 00:29:40,080
application

00:29:37,520 --> 00:29:41,760
do this at this point and it can

00:29:40,080 --> 00:29:44,480
maintain

00:29:41,760 --> 00:29:46,080
more state and um can make you know

00:29:44,480 --> 00:29:50,159
basically have much more information

00:29:46,080 --> 00:29:53,039
um to make these decisions this is

00:29:50,159 --> 00:29:54,159
not simple um i think as i said it's a

00:29:53,039 --> 00:29:56,880
start-up size

00:29:54,159 --> 00:29:59,120
problem potentially um or perhaps an nsa

00:29:56,880 --> 00:30:02,320
sized problem i think the nsa

00:29:59,120 --> 00:30:05,039
wrote sc linux in the first place um

00:30:02,320 --> 00:30:06,640
and basically defined the kind of shape

00:30:05,039 --> 00:30:09,600
of what it looks like

00:30:06,640 --> 00:30:11,200
um and you know the nsa is an

00:30:09,600 --> 00:30:14,799
organization that's interested in this

00:30:11,200 --> 00:30:16,480
type of problem um

00:30:14,799 --> 00:30:18,720
um but yeah it's the sort of thing that

00:30:16,480 --> 00:30:22,399
you could you could potentially

00:30:18,720 --> 00:30:24,720
do with a you know a medium-sized team

00:30:22,399 --> 00:30:27,200
and work on this problem for a few years

00:30:24,720 --> 00:30:28,720
um this is very much looking as a

00:30:27,200 --> 00:30:30,640
technical solution

00:30:28,720 --> 00:30:32,559
it doesn't solve the human problems of

00:30:30,640 --> 00:30:34,799
really what kind of

00:30:32,559 --> 00:30:36,559
um what kind of policies do you need to

00:30:34,799 --> 00:30:38,640
enforce and what kind of model

00:30:36,559 --> 00:30:41,039
you've actually got here and how does

00:30:38,640 --> 00:30:42,159
the human communicate intense over this

00:30:41,039 --> 00:30:44,399
problem things like that so there's

00:30:42,159 --> 00:30:47,440
still a lot of human problems that

00:30:44,399 --> 00:30:49,440
you have to solve there so what is going

00:30:47,440 --> 00:30:52,880
to happen with said comp

00:30:49,440 --> 00:30:54,559
um my prediction is that

00:30:52,880 --> 00:30:56,320
the if you look at the state of the

00:30:54,559 --> 00:30:57,519
container ecosystem now there's a

00:30:56,320 --> 00:30:59,120
continuing lack of

00:30:57,519 --> 00:31:01,279
investment in the low levels of the

00:30:59,120 --> 00:31:03,120
stack um

00:31:01,279 --> 00:31:04,399
there's really not many people working

00:31:03,120 --> 00:31:08,240
on these problems

00:31:04,399 --> 00:31:11,760
it's not clear who's um

00:31:08,240 --> 00:31:14,480
who's going to work on these problems

00:31:11,760 --> 00:31:15,679
um most people seem to expect someone

00:31:14,480 --> 00:31:18,880
else to do it and not

00:31:15,679 --> 00:31:18,880
get involved themselves

00:31:19,200 --> 00:31:23,919
um i think setting up an ebp flsm

00:31:22,080 --> 00:31:25,519
container security starts up is probably

00:31:23,919 --> 00:31:26,240
quite easy to get funded but the other

00:31:25,519 --> 00:31:29,360
options

00:31:26,240 --> 00:31:30,640
might not even happen um the serious

00:31:29,360 --> 00:31:32,000
service providers like the cloud

00:31:30,640 --> 00:31:35,200
providers are basically

00:31:32,000 --> 00:31:37,200
just using vms um

00:31:35,200 --> 00:31:38,399
and so that's why you're seeing quite

00:31:37,200 --> 00:31:41,679
mature things like

00:31:38,399 --> 00:31:44,799
firecracker the problem is that most no

00:31:41,679 --> 00:31:46,960
most other users of containers are

00:31:44,799 --> 00:31:47,600
running their containers in vms already

00:31:46,960 --> 00:31:49,600
they're

00:31:47,600 --> 00:31:52,000
either running vmware on prem or they're

00:31:49,600 --> 00:31:54,480
running in cloud provider vms

00:31:52,000 --> 00:31:55,679
and not cloud provider bare metal or

00:31:54,480 --> 00:31:57,919
other bare metal

00:31:55,679 --> 00:31:58,720
so most of them don't have the option of

00:31:57,919 --> 00:32:02,159
using vms

00:31:58,720 --> 00:32:04,080
for containers at this point um

00:32:02,159 --> 00:32:05,840
so even though their stack is becoming

00:32:04,080 --> 00:32:09,360
relatively mature

00:32:05,840 --> 00:32:14,000
most people are simply not using it um

00:32:09,360 --> 00:32:16,480
so um we'll probably see the split where

00:32:14,000 --> 00:32:17,440
more and more people are using you know

00:32:16,480 --> 00:32:19,039
provider

00:32:17,440 --> 00:32:21,279
services like you know cloud provider

00:32:19,039 --> 00:32:24,320
services and they will just use

00:32:21,279 --> 00:32:27,760
um vms vm based containers

00:32:24,320 --> 00:32:29,200
um via providers or or

00:32:27,760 --> 00:32:31,279
things like that like you know things

00:32:29,200 --> 00:32:33,200
like um you know

00:32:31,279 --> 00:32:34,720
this the fargate containers of

00:32:33,200 --> 00:32:36,320
kubernetes and aws things like that

00:32:34,720 --> 00:32:39,360
which are all vm based and

00:32:36,320 --> 00:32:42,559
um just scale as as

00:32:39,360 --> 00:32:44,159
containers rather than as hosts um

00:32:42,559 --> 00:32:46,000
we're not assuming security vendors

00:32:44,159 --> 00:32:49,279
solving this type of problem

00:32:46,000 --> 00:32:49,679
um there's a there's lots of reasons for

00:32:49,279 --> 00:32:52,640
this

00:32:49,679 --> 00:32:53,120
um uh thomas dallian's done a bunch of

00:32:52,640 --> 00:32:54,320
talks

00:32:53,120 --> 00:32:55,679
which are interesting talk to me if

00:32:54,320 --> 00:32:56,559
you're interested in the questions about

00:32:55,679 --> 00:32:58,399
why

00:32:56,559 --> 00:33:00,240
the security industry isn't interested

00:32:58,399 --> 00:33:03,279
in this kind of problem

00:33:00,240 --> 00:33:04,320
and end user as if kubernetes find it

00:33:03,279 --> 00:33:07,039
difficult to contribute

00:33:04,320 --> 00:33:08,720
back to this sort of problem because

00:33:07,039 --> 00:33:12,240
these problems are quite um

00:33:08,720 --> 00:33:15,919
technically difficult um there's

00:33:12,240 --> 00:33:16,320
um not a lot of people who have the

00:33:15,919 --> 00:33:18,720
right

00:33:16,320 --> 00:33:19,600
kind of expertise around um the

00:33:18,720 --> 00:33:21,200
learner's kernel

00:33:19,600 --> 00:33:23,200
and how things actually work in

00:33:21,200 --> 00:33:25,039
container runtimes and

00:33:23,200 --> 00:33:26,720
have time to work on these problems they

00:33:25,039 --> 00:33:30,399
have other pressing problems to work on

00:33:26,720 --> 00:33:33,200
it's kind of um um difficult i mean

00:33:30,399 --> 00:33:34,640
even very large end users have tend to

00:33:33,200 --> 00:33:35,600
have very little and it's kernel

00:33:34,640 --> 00:33:39,440
expertise

00:33:35,600 --> 00:33:40,480
um and um they tend to work much mostly

00:33:39,440 --> 00:33:42,399
higher up in the stack

00:33:40,480 --> 00:33:44,080
so we're not really seeing much at the

00:33:42,399 --> 00:33:45,679
moment much end user contribution to

00:33:44,080 --> 00:33:48,559
solving these problems so i'm

00:33:45,679 --> 00:33:50,000
actually not optimistic that a lot of

00:33:48,559 --> 00:33:52,799
this stuff will happen quickly it's

00:33:50,000 --> 00:33:54,640
taken a long time you know to get

00:33:52,799 --> 00:33:56,880
where we are and there's been little

00:33:54,640 --> 00:34:00,559
investment in it

00:33:56,880 --> 00:34:05,039
um so um thanks very much for that

00:34:00,559 --> 00:34:05,039
um and i'll be around to

00:34:05,279 --> 00:34:08,879
answer questions and um hope you enjoyed

00:34:08,079 --> 00:34:11,040
that talk

00:34:08,879 --> 00:34:12,560
and um it's been fun working on setcomp

00:34:11,040 --> 00:34:14,960
but i think you know there's a lot of

00:34:12,560 --> 00:34:17,760
interesting problems that

00:34:14,960 --> 00:34:18,879
could be solved and actually aren't

00:34:17,760 --> 00:34:20,800
being so

00:34:18,879 --> 00:34:22,480
uh if you're looking for a fun problem

00:34:20,800 --> 00:34:27,839
to work on it's

00:34:22,480 --> 00:34:27,839

YouTube URL: https://www.youtube.com/watch?v=Ro4QRx7VPsY


