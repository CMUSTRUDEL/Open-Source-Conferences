Title: Observability 101
Publication date: 2021-06-01
Playlist: KCD Africa
Description: 
	
Captions: 
	00:00:00,240 --> 00:00:05,359
awesome thank you very much everyone

00:00:03,600 --> 00:00:09,040
welcome back from the break

00:00:05,359 --> 00:00:12,240
and uh we'll be continuing with

00:00:09,040 --> 00:00:15,040
our next session from richard richard

00:00:12,240 --> 00:00:17,039
is very well known for personality

00:00:15,040 --> 00:00:19,439
within the open source industry

00:00:17,039 --> 00:00:20,520
and in this session he'll be speaking to

00:00:19,439 --> 00:00:24,080
us about

00:00:20,520 --> 00:00:26,240
observability when you are

00:00:24,080 --> 00:00:27,119
deploying your infrastructure or you are

00:00:26,240 --> 00:00:29,359
managing

00:00:27,119 --> 00:00:31,199
your services or whatever you have in

00:00:29,359 --> 00:00:35,760
your enterprise

00:00:31,199 --> 00:00:37,760
one thing that needs uh

00:00:35,760 --> 00:00:39,040
serious attention it's observability and

00:00:37,760 --> 00:00:40,480
he will be introduced in the stop

00:00:39,040 --> 00:00:43,840
stability 101

00:00:40,480 --> 00:00:47,280
we did some uh workshops

00:00:43,840 --> 00:00:48,480
did a workshop on graffana yesterday and

00:00:47,280 --> 00:00:50,160
last week

00:00:48,480 --> 00:00:52,320
so this will give more context to

00:00:50,160 --> 00:00:53,840
understand it better and other things

00:00:52,320 --> 00:00:57,280
around observability

00:00:53,840 --> 00:00:59,199
over to you rich thank you thank you

00:00:57,280 --> 00:01:00,800
um so yeah it seems you can see my

00:00:59,199 --> 00:01:02,719
screen perfect yes

00:01:00,800 --> 00:01:04,159
so yeah um let's get started

00:01:02,719 --> 00:01:06,400
observability 101

00:01:04,159 --> 00:01:08,479
uh with the focus focus on prometheus

00:01:06,400 --> 00:01:12,159
and beyond um

00:01:08,479 --> 00:01:15,040
let's start with the buzzwords

00:01:12,159 --> 00:01:16,479
because observability and also are

00:01:15,040 --> 00:01:19,920
absolute buzzwords um

00:01:16,479 --> 00:01:23,439
and as per usual um

00:01:19,920 --> 00:01:26,799
buzzwords um tend to have a

00:01:23,439 --> 00:01:30,000
core of of truth a core of meaning but

00:01:26,799 --> 00:01:33,200
often they're just applied

00:01:30,000 --> 00:01:35,840
to whatever you already have which is

00:01:33,200 --> 00:01:38,720
which is understandable but it is it is

00:01:35,840 --> 00:01:40,240
somewhat dangerous because um

00:01:38,720 --> 00:01:42,079
often you you need to actually

00:01:40,240 --> 00:01:44,240
understand why a term

00:01:42,079 --> 00:01:45,680
has become a buzzword and why there is

00:01:44,240 --> 00:01:48,720
so much industry attention

00:01:45,680 --> 00:01:51,600
onto that onto that term or that concept

00:01:48,720 --> 00:01:52,079
um there is a concept of cargo culting

00:01:51,600 --> 00:01:54,720
which

00:01:52,079 --> 00:01:56,719
is basically just replicating what what

00:01:54,720 --> 00:01:58,240
you perceive others to be doing

00:01:56,719 --> 00:01:59,920
without actually looking into the

00:01:58,240 --> 00:02:01,360
details of it and then not getting the

00:01:59,920 --> 00:02:02,399
outcome which you would actually like to

00:02:01,360 --> 00:02:05,360
be getting

00:02:02,399 --> 00:02:06,799
which is obviously not what you want so

00:02:05,360 --> 00:02:09,840
it's

00:02:06,799 --> 00:02:11,200
it's dangerous to just try and and and

00:02:09,840 --> 00:02:13,440
see what others do it's

00:02:11,200 --> 00:02:14,959
a lot about also thinking about why it

00:02:13,440 --> 00:02:16,959
works for certain people

00:02:14,959 --> 00:02:18,319
and and for certain situations and then

00:02:16,959 --> 00:02:20,800
to try

00:02:18,319 --> 00:02:23,599
and and adapt this to your own problems

00:02:20,800 --> 00:02:26,080
into your own space

00:02:23,599 --> 00:02:26,800
as i said this kernel of truth it is a

00:02:26,080 --> 00:02:28,800
lot

00:02:26,800 --> 00:02:29,920
in observability and necessary about

00:02:28,800 --> 00:02:32,080
changing the actual

00:02:29,920 --> 00:02:34,319
behavior and not just changing the name

00:02:32,080 --> 00:02:37,120
of whatever you have done before

00:02:34,319 --> 00:02:37,840
in this context monitoring is the old

00:02:37,120 --> 00:02:41,040
term

00:02:37,840 --> 00:02:43,840
more or less and it has more taken a

00:02:41,040 --> 00:02:44,879
meaning of collecting a lot of data but

00:02:43,840 --> 00:02:47,840
not necessarily

00:02:44,879 --> 00:02:49,519
using it um there are extremes where

00:02:47,840 --> 00:02:51,040
either you just toss everything into

00:02:49,519 --> 00:02:53,360
store

00:02:51,040 --> 00:02:54,319
data lake and you you don't really use

00:02:53,360 --> 00:02:55,920
it at least not

00:02:54,319 --> 00:02:57,920
in in monitoring and observability

00:02:55,920 --> 00:03:00,640
context or full text

00:02:57,920 --> 00:03:02,840
and all full indexing which is just

00:03:00,640 --> 00:03:06,400
hugely expensive

00:03:02,840 --> 00:03:09,200
so it's about finding out

00:03:06,400 --> 00:03:09,519
why something is the way it is and not

00:03:09,200 --> 00:03:13,040
just

00:03:09,519 --> 00:03:13,519
yes it is the way it is so observability

00:03:13,040 --> 00:03:16,080
to me

00:03:13,519 --> 00:03:18,000
is about enabling humans to understand

00:03:16,080 --> 00:03:20,640
complex systems and obviously

00:03:18,000 --> 00:03:22,720
with cloud and such you you get ever

00:03:20,640 --> 00:03:25,840
more complex systems

00:03:22,720 --> 00:03:27,680
and you don't want that you don't uh

00:03:25,840 --> 00:03:28,799
or i mean you want to have the complex

00:03:27,680 --> 00:03:30,799
systems and you want to have the

00:03:28,799 --> 00:03:32,959
benefits of those complex systems

00:03:30,799 --> 00:03:34,879
but you still want to enable humans to

00:03:32,959 --> 00:03:38,000
understand those systems

00:03:34,879 --> 00:03:40,319
and also at the same time you enable

00:03:38,000 --> 00:03:42,000
machines to understand complex systems

00:03:40,319 --> 00:03:44,239
which means you can automate a lot of

00:03:42,000 --> 00:03:47,120
things like for example alerting

00:03:44,239 --> 00:03:48,720
so again this is a lot more about the

00:03:47,120 --> 00:03:51,680
why is something broken

00:03:48,720 --> 00:03:53,920
and how can i fix it and not just well

00:03:51,680 --> 00:03:54,480
yes it's broken and and i start from

00:03:53,920 --> 00:03:58,319
scratch

00:03:54,480 --> 00:04:00,000
in in my debugging we need to look at a

00:03:58,319 --> 00:04:02,799
few more terms to to go

00:04:00,000 --> 00:04:05,680
to the depth of this complexity is one

00:04:02,799 --> 00:04:07,840
of the most important ones

00:04:05,680 --> 00:04:08,959
i i distinguish between two types of

00:04:07,840 --> 00:04:12,080
complexity one

00:04:08,959 --> 00:04:12,799
is fake complexity which is just bad

00:04:12,080 --> 00:04:15,120
design

00:04:12,799 --> 00:04:17,120
or legacy design or what have you maybe

00:04:15,120 --> 00:04:19,280
there were design constraints

00:04:17,120 --> 00:04:20,479
before which are not there anymore

00:04:19,280 --> 00:04:22,960
doesn't matter but

00:04:20,479 --> 00:04:23,840
often things which are complex in a

00:04:22,960 --> 00:04:27,040
system

00:04:23,840 --> 00:04:28,080
are not system inherent and they can be

00:04:27,040 --> 00:04:30,720
in that complexity

00:04:28,080 --> 00:04:31,120
can be reduced and it should be reduced

00:04:30,720 --> 00:04:33,120
because

00:04:31,120 --> 00:04:34,560
if if you just have complexity for

00:04:33,120 --> 00:04:37,440
complexity's sake

00:04:34,560 --> 00:04:38,960
um you're making your own life harder um

00:04:37,440 --> 00:04:40,160
and you're making it more expensive to

00:04:38,960 --> 00:04:42,560
run your service which is

00:04:40,160 --> 00:04:44,160
again not what you want on the other

00:04:42,560 --> 00:04:46,000
hand we have this real and system

00:04:44,160 --> 00:04:49,280
inherent complexity

00:04:46,000 --> 00:04:50,160
and that is complexity which is a

00:04:49,280 --> 00:04:51,759
necessity

00:04:50,160 --> 00:04:53,440
of actually doing what you want to

00:04:51,759 --> 00:04:56,479
achieve because

00:04:53,440 --> 00:04:58,240
obviously if if you do

00:04:56,479 --> 00:04:59,680
complex things and good things that if

00:04:58,240 --> 00:05:02,560
you have lots of moving

00:04:59,680 --> 00:05:04,479
bits and pieces there is some complexity

00:05:02,560 --> 00:05:06,720
which you cannot just reduce away

00:05:04,479 --> 00:05:08,160
you must actually deal with it because

00:05:06,720 --> 00:05:10,240
that is part of

00:05:08,160 --> 00:05:12,639
what makes your service a service which

00:05:10,240 --> 00:05:16,080
your users want to use

00:05:12,639 --> 00:05:19,440
so you can move this complexity around

00:05:16,080 --> 00:05:21,840
we have we had monolithic and mainframe

00:05:19,440 --> 00:05:23,680
designs we had client servers we have

00:05:21,840 --> 00:05:25,199
microservices for example premises

00:05:23,680 --> 00:05:27,759
itself is a monolith

00:05:25,199 --> 00:05:30,240
so you can see that you you can make

00:05:27,759 --> 00:05:32,800
different decisions and even within

00:05:30,240 --> 00:05:34,560
even within the cloud native context it

00:05:32,800 --> 00:05:37,199
can make sense to run monolithic

00:05:34,560 --> 00:05:38,880
services like prometheus

00:05:37,199 --> 00:05:40,560
but you cannot get this away you just

00:05:38,880 --> 00:05:43,759
move it um it

00:05:40,560 --> 00:05:45,039
must be comparison mentalized

00:05:43,759 --> 00:05:47,840
a different name for this is service

00:05:45,039 --> 00:05:51,520
boundaries like your hard drive

00:05:47,840 --> 00:05:53,919
is insanely complex but it

00:05:51,520 --> 00:05:55,600
it has a clearly defined interface and

00:05:53,919 --> 00:05:56,639
your operating system in your main board

00:05:55,600 --> 00:05:58,319
can just address

00:05:56,639 --> 00:06:00,880
your hard drive same for your cpu and

00:05:58,319 --> 00:06:03,120
such those are also super complex but

00:06:00,880 --> 00:06:06,240
it's compartmentalized away

00:06:03,120 --> 00:06:07,919
um so you don't have to deal with it on

00:06:06,240 --> 00:06:09,360
the level which you're dealing with with

00:06:07,919 --> 00:06:11,360
whatever service you have

00:06:09,360 --> 00:06:12,479
same for cloud instances and everything

00:06:11,360 --> 00:06:14,880
of course

00:06:12,479 --> 00:06:16,479
and ideally it should be distilled in a

00:06:14,880 --> 00:06:17,919
meaningful way that you can actually

00:06:16,479 --> 00:06:19,840
extract what you want from that

00:06:17,919 --> 00:06:20,560
complexity to to understand what is

00:06:19,840 --> 00:06:22,560
happening

00:06:20,560 --> 00:06:24,560
where you need to to understand it and

00:06:22,560 --> 00:06:26,720
else you can just more or less ignore it

00:06:24,560 --> 00:06:28,479
unless you're part of of the team which

00:06:26,720 --> 00:06:30,000
is actually responsible for running that

00:06:28,479 --> 00:06:31,919
one thing

00:06:30,000 --> 00:06:35,360
as there is another buzzword which often

00:06:31,919 --> 00:06:37,440
comes up in in the context of

00:06:35,360 --> 00:06:39,280
of observability another one would be

00:06:37,440 --> 00:06:41,120
devops which are

00:06:39,280 --> 00:06:43,039
again not precisely the same but they go

00:06:41,120 --> 00:06:45,199
in the same direction

00:06:43,039 --> 00:06:47,039
to me and there's other definitions but

00:06:45,199 --> 00:06:49,919
again to me

00:06:47,039 --> 00:06:51,520
the core meaning of sre is to align

00:06:49,919 --> 00:06:54,639
incentives

00:06:51,520 --> 00:06:56,080
um because you want different people

00:06:54,639 --> 00:06:57,840
different teams you want them to

00:06:56,080 --> 00:06:59,199
actually work together and not against

00:06:57,840 --> 00:07:01,520
each other

00:06:59,199 --> 00:07:02,960
and a lot of what you can see in the

00:07:01,520 --> 00:07:07,199
google asset ebook and such

00:07:02,960 --> 00:07:09,680
is if you just distill it to its essence

00:07:07,199 --> 00:07:10,800
it's basically about making people think

00:07:09,680 --> 00:07:12,960
about the same things

00:07:10,800 --> 00:07:14,880
and aligning your incentives so they

00:07:12,960 --> 00:07:16,400
automatically without having to discuss

00:07:14,880 --> 00:07:18,160
and fight about this

00:07:16,400 --> 00:07:20,800
do the same thing or go in the same

00:07:18,160 --> 00:07:23,039
direction hugely important here is sli

00:07:20,800 --> 00:07:24,720
slo sla which is service level indicator

00:07:23,039 --> 00:07:26,560
service level objective and service

00:07:24,720 --> 00:07:30,400
level agreement

00:07:26,560 --> 00:07:32,960
um the indicator is just

00:07:30,400 --> 00:07:34,880
what you measure the objective is what

00:07:32,960 --> 00:07:35,440
you do not want to go above and the

00:07:34,880 --> 00:07:37,120
agreement

00:07:35,440 --> 00:07:39,440
is where you go above you actually have

00:07:37,120 --> 00:07:41,599
to pay or you break a contract or

00:07:39,440 --> 00:07:42,960
whatever

00:07:41,599 --> 00:07:44,879
specific example if you have error

00:07:42,960 --> 00:07:46,400
budgets for your service this allows

00:07:44,879 --> 00:07:48,479
your developers your operation people

00:07:46,400 --> 00:07:50,960
your product manager your everyone

00:07:48,479 --> 00:07:52,879
to optimize for shared benefits if that

00:07:50,960 --> 00:07:53,599
service is super stable everyone gets to

00:07:52,879 --> 00:07:54,960
do their a b

00:07:53,599 --> 00:07:57,039
testing and their new features and

00:07:54,960 --> 00:07:57,599
everything but if that error budget goes

00:07:57,039 --> 00:07:59,280
away

00:07:57,599 --> 00:08:01,440
the operation people can say okay we

00:07:59,280 --> 00:08:02,639
cannot put any any updates unless it's

00:08:01,440 --> 00:08:04,400
super well tested which

00:08:02,639 --> 00:08:05,840
puts load on the developers and they

00:08:04,400 --> 00:08:07,120
can't put their new features in which

00:08:05,840 --> 00:08:09,759
they don't like

00:08:07,120 --> 00:08:11,440
so obviously they will try to to to use

00:08:09,759 --> 00:08:13,599
up the shared error budget which is

00:08:11,440 --> 00:08:15,840
shared between everyone

00:08:13,599 --> 00:08:17,199
as as well or as good as possible same

00:08:15,840 --> 00:08:18,800
as the operation same as the product

00:08:17,199 --> 00:08:21,680
manager same as everyone else

00:08:18,800 --> 00:08:24,319
that is aligning the incentives of of

00:08:21,680 --> 00:08:24,319
those people

00:08:25,039 --> 00:08:31,199
what can this mean in in in the specific

00:08:29,039 --> 00:08:32,240
everyone using the same tools and

00:08:31,199 --> 00:08:34,880
dashboards

00:08:32,240 --> 00:08:36,479
would be a good thing uh of course you

00:08:34,880 --> 00:08:38,479
have the shared

00:08:36,479 --> 00:08:39,599
incentive that everyone invests in the

00:08:38,479 --> 00:08:42,080
same tooling

00:08:39,599 --> 00:08:43,680
everyone works on the same dashboard so

00:08:42,080 --> 00:08:45,760
they share a language because

00:08:43,680 --> 00:08:47,279
the terminology is if you have only one

00:08:45,760 --> 00:08:49,040
dashboard or five

00:08:47,279 --> 00:08:50,959
the terminology is the same so they

00:08:49,040 --> 00:08:53,600
share this language automatically they

00:08:50,959 --> 00:08:55,120
share the understanding of how to look

00:08:53,600 --> 00:08:56,800
into the service of course again

00:08:55,120 --> 00:08:58,320
all their tools and such are working the

00:08:56,800 --> 00:09:00,320
same ways

00:08:58,320 --> 00:09:02,000
that also pulls your institution

00:09:00,320 --> 00:09:03,839
knowledge of course

00:09:02,000 --> 00:09:05,440
one improvement to that one dashboard

00:09:03,839 --> 00:09:06,640
from that one person or to the alert or

00:09:05,440 --> 00:09:10,000
doesn't matter

00:09:06,640 --> 00:09:10,720
benefits everyone else so you don't have

00:09:10,000 --> 00:09:12,880
those

00:09:10,720 --> 00:09:14,720
10 different islands of data no everyone

00:09:12,880 --> 00:09:18,320
is working on the same system

00:09:14,720 --> 00:09:20,720
and they share this system knowledge

00:09:18,320 --> 00:09:22,640
what is a service it's basically you

00:09:20,720 --> 00:09:24,880
commercialize your complexity

00:09:22,640 --> 00:09:26,720
have your interfaces they usually have

00:09:24,880 --> 00:09:29,040
different owners and or teams

00:09:26,720 --> 00:09:30,480
and contracts define the service

00:09:29,040 --> 00:09:33,760
interfaces

00:09:30,480 --> 00:09:35,920
why the term contract well

00:09:33,760 --> 00:09:36,880
i like this term because it is a shared

00:09:35,920 --> 00:09:40,160
agreement

00:09:36,880 --> 00:09:42,720
in writing which must not be broken

00:09:40,160 --> 00:09:44,000
if it's being broken you need to discuss

00:09:42,720 --> 00:09:46,560
this with with whoever

00:09:44,000 --> 00:09:48,000
is is invested in that service or in

00:09:46,560 --> 00:09:49,680
that contract

00:09:48,000 --> 00:09:51,120
so automatically you you have this

00:09:49,680 --> 00:09:52,320
control function in this forcing

00:09:51,120 --> 00:09:53,760
function

00:09:52,320 --> 00:09:55,360
it doesn't matter if those are external

00:09:53,760 --> 00:09:56,800
or internal customers

00:09:55,360 --> 00:09:58,640
some people in your org will care more

00:09:56,800 --> 00:10:00,560
about external customers but i would

00:09:58,640 --> 00:10:01,680
argue that internal customers within the

00:10:00,560 --> 00:10:03,440
org

00:10:01,680 --> 00:10:04,959
are just as important because they

00:10:03,440 --> 00:10:06,160
provide services to other external

00:10:04,959 --> 00:10:09,120
customers

00:10:06,160 --> 00:10:10,320
so treating yourself within the org as

00:10:09,120 --> 00:10:11,680
your own customers

00:10:10,320 --> 00:10:13,120
between different teams and service

00:10:11,680 --> 00:10:14,959
owners makes absolute sense in my

00:10:13,120 --> 00:10:17,120
opinion

00:10:14,959 --> 00:10:18,880
you could also call this layer and the

00:10:17,120 --> 00:10:19,440
internet wouldn't exist without proper

00:10:18,880 --> 00:10:21,040
layer

00:10:19,440 --> 00:10:23,440
layering where you can have your your

00:10:21,040 --> 00:10:26,480
layer 2 your layer 3d layer everything

00:10:23,440 --> 00:10:28,079
and you can you can actually fully

00:10:26,480 --> 00:10:28,640
paralyze the work on those different

00:10:28,079 --> 00:10:30,160
layers

00:10:28,640 --> 00:10:32,079
different innovations can happen

00:10:30,160 --> 00:10:34,079
everything as long as the interfaces are

00:10:32,079 --> 00:10:36,320
the same and are compatible you can do

00:10:34,079 --> 00:10:39,760
whatever wi-fi has been

00:10:36,320 --> 00:10:42,000
has been developed without tcp having to

00:10:39,760 --> 00:10:45,040
be or ip having to be

00:10:42,000 --> 00:10:46,640
adjusted for this of course it is a

00:10:45,040 --> 00:10:47,920
different layer with clean interfaces

00:10:46,640 --> 00:10:48,800
and so you could just do this on a

00:10:47,920 --> 00:10:51,120
different layer and

00:10:48,800 --> 00:10:52,560
no one had to think about could i ever

00:10:51,120 --> 00:10:55,279
have wireless at the time when they

00:10:52,560 --> 00:10:57,200
designed ip it's just still working

00:10:55,279 --> 00:10:58,560
and yeah i already talked about cpu hard

00:10:57,200 --> 00:11:00,800
disk and such um

00:10:58,560 --> 00:11:02,000
even your lunch you will not in common

00:11:00,800 --> 00:11:04,000
case be be

00:11:02,000 --> 00:11:06,399
doing everything like you won't be

00:11:04,000 --> 00:11:09,600
growing all your own wheat and and

00:11:06,399 --> 00:11:12,480
blacksmithing your own your own tools to

00:11:09,600 --> 00:11:13,279
to uh to actually grow that wheat and

00:11:12,480 --> 00:11:14,880
everything

00:11:13,279 --> 00:11:16,720
you will be buying certain bits and

00:11:14,880 --> 00:11:17,519
pieces so no matter how much you cook

00:11:16,720 --> 00:11:19,519
yourself

00:11:17,519 --> 00:11:22,640
still you have those service interfaces

00:11:19,519 --> 00:11:24,800
everywhere in your life

00:11:22,640 --> 00:11:27,519
your customers they don't really care

00:11:24,800 --> 00:11:30,079
about your internal

00:11:27,519 --> 00:11:30,640
things uh they don't care if if half of

00:11:30,079 --> 00:11:32,160
your

00:11:30,640 --> 00:11:33,920
database notes are down they care about

00:11:32,160 --> 00:11:34,800
their database service being up and

00:11:33,920 --> 00:11:36,480
quick

00:11:34,800 --> 00:11:38,160
and that is how you need to think about

00:11:36,480 --> 00:11:39,920
those services you need to think about

00:11:38,160 --> 00:11:41,440
them from the perspective of the paying

00:11:39,920 --> 00:11:42,079
customer who doesn't really care about

00:11:41,440 --> 00:11:44,160
any of your

00:11:42,079 --> 00:11:45,760
journals they just care to so that the

00:11:44,160 --> 00:11:47,600
service works

00:11:45,760 --> 00:11:49,440
um something which you will not see very

00:11:47,600 --> 00:11:50,800
often but which i think is hugely

00:11:49,440 --> 00:11:52,480
important

00:11:50,800 --> 00:11:54,560
uh you need to discern between between

00:11:52,480 --> 00:11:57,120
different types of slis

00:11:54,560 --> 00:11:58,959
usually the wisdom is that you only care

00:11:57,120 --> 00:12:01,279
about your own slis

00:11:58,959 --> 00:12:03,920
which i disagree with i think that you

00:12:01,279 --> 00:12:05,680
need to also care about the slis of your

00:12:03,920 --> 00:12:08,079
underlying services

00:12:05,680 --> 00:12:10,000
so basically what what your underlying

00:12:08,079 --> 00:12:12,720
services consider their primary and

00:12:10,000 --> 00:12:14,240
service relevant slis for alerting and

00:12:12,720 --> 00:12:16,320
such and for

00:12:14,240 --> 00:12:17,680
for seeing if the contract isn't all

00:12:16,320 --> 00:12:19,120
right and everything

00:12:17,680 --> 00:12:21,920
you should be treating those as

00:12:19,120 --> 00:12:23,839
informational slis

00:12:21,920 --> 00:12:25,839
to to help you debugging and to

00:12:23,839 --> 00:12:26,959
understand what might be happening in

00:12:25,839 --> 00:12:29,040
your underlying

00:12:26,959 --> 00:12:31,279
services or in this in the underlying

00:12:29,040 --> 00:12:33,760
services which you rely on

00:12:31,279 --> 00:12:35,120
as to alerting anything which is

00:12:33,760 --> 00:12:38,320
currently or imminent

00:12:35,120 --> 00:12:39,519
cause impacting a customer service must

00:12:38,320 --> 00:12:42,639
be alerted upon

00:12:39,519 --> 00:12:44,000
and nothing else should be if it's just

00:12:42,639 --> 00:12:46,560
a disk which is half full

00:12:44,000 --> 00:12:48,320
whatever raise a ticket do it during

00:12:46,560 --> 00:12:48,800
business hours don't wake someone up for

00:12:48,320 --> 00:12:50,720
this

00:12:48,800 --> 00:12:52,639
if your customers are not able to access

00:12:50,720 --> 00:12:54,639
the system course of that half fold is

00:12:52,639 --> 00:12:58,000
that is the reason why to alert but not

00:12:54,639 --> 00:12:59,839
just that a disk is full or something

00:12:58,000 --> 00:13:01,440
so let's look at tools first and

00:12:59,839 --> 00:13:02,720
foremost obviously prometheus many of

00:13:01,440 --> 00:13:03,920
you will know it but still let's walk

00:13:02,720 --> 00:13:05,760
through the 101.

00:13:03,920 --> 00:13:07,760
it's inspired by google sportsman it's a

00:13:05,760 --> 00:13:08,480
time series database which internally

00:13:07,760 --> 00:13:12,639
stores

00:13:08,480 --> 00:13:14,639
the values in 64-bit numbers

00:13:12,639 --> 00:13:17,360
it has concepts for instrumentation and

00:13:14,639 --> 00:13:19,360
exporters instrumentation being

00:13:17,360 --> 00:13:20,720
modifying your own source code or other

00:13:19,360 --> 00:13:22,959
people's source code

00:13:20,720 --> 00:13:24,959
to emit metrics directly from within the

00:13:22,959 --> 00:13:26,320
system and exporters are basically

00:13:24,959 --> 00:13:28,959
proxies where you can take

00:13:26,320 --> 00:13:30,639
snmp or a database or something and

00:13:28,959 --> 00:13:32,320
rewrite this into something which

00:13:30,639 --> 00:13:34,720
prometheus can understand

00:13:32,320 --> 00:13:36,959
it is not meant for event logging and

00:13:34,720 --> 00:13:39,199
dashboarding happens via grafana

00:13:36,959 --> 00:13:41,040
the main selling points of of prometheus

00:13:39,199 --> 00:13:42,720
are it has a highly dynamic built-in

00:13:41,040 --> 00:13:44,399
service discovery you can just

00:13:42,720 --> 00:13:46,720
point it at your kubernetes and

00:13:44,399 --> 00:13:48,240
everything will happen as if by magic

00:13:46,720 --> 00:13:49,920
you can have a zone transfer and just

00:13:48,240 --> 00:13:53,040
transfer that one zone and

00:13:49,920 --> 00:13:53,440
prometheus will just start um monitoring

00:13:53,040 --> 00:13:55,519
all

00:13:53,440 --> 00:13:58,480
what's in there and there's integration

00:13:55,519 --> 00:14:00,240
with pretty much every cloud provider or

00:13:58,480 --> 00:14:02,639
at least every major cloud provider and

00:14:00,240 --> 00:14:04,720
there's more coming all the time

00:14:02,639 --> 00:14:06,240
so you just point them at this end point

00:14:04,720 --> 00:14:07,920
of your of your cloud provider and

00:14:06,240 --> 00:14:09,600
prometheus knows about the services and

00:14:07,920 --> 00:14:11,600
start scraping them

00:14:09,600 --> 00:14:13,199
you don't have a hierarchical data model

00:14:11,600 --> 00:14:14,639
you have an n-dimensional label set you

00:14:13,199 --> 00:14:16,480
so you don't have your

00:14:14,639 --> 00:14:18,880
region country customer and then you

00:14:16,480 --> 00:14:20,560
want to to group by customer and you you

00:14:18,880 --> 00:14:21,199
kind of break this hierarchical tree

00:14:20,560 --> 00:14:23,360
model

00:14:21,199 --> 00:14:25,040
now you can just select by the label

00:14:23,360 --> 00:14:27,519
customer equals whatever

00:14:25,040 --> 00:14:28,240
and you're done there's a language um

00:14:27,519 --> 00:14:29,680
prom

00:14:28,240 --> 00:14:32,079
we used for everything processing

00:14:29,680 --> 00:14:33,760
graphing alerting exporting everything

00:14:32,079 --> 00:14:35,360
you need to learn it it's a new language

00:14:33,760 --> 00:14:39,199
but

00:14:35,360 --> 00:14:40,880
it is insanely powerful um permit itself

00:14:39,199 --> 00:14:42,399
is quite simple to operate and it's

00:14:40,880 --> 00:14:44,079
super efficient most likely more

00:14:42,399 --> 00:14:45,440
efficient than anything which

00:14:44,079 --> 00:14:47,519
which you saw which is older than

00:14:45,440 --> 00:14:50,240
prometheus which is not

00:14:47,519 --> 00:14:51,360
so common anymore but still uh there's

00:14:50,240 --> 00:14:54,560
there's still people who

00:14:51,360 --> 00:14:56,959
who see this as a new thing

00:14:54,560 --> 00:14:58,720
other selling points um it's pull based

00:14:56,959 --> 00:15:00,480
which gives you nicer properties about

00:14:58,720 --> 00:15:01,920
certain types of alerting and and

00:15:00,480 --> 00:15:04,240
consistency checks

00:15:01,920 --> 00:15:05,680
um we have the concept of black box

00:15:04,240 --> 00:15:07,680
monitoring where you look at stuff from

00:15:05,680 --> 00:15:08,160
the outside versus white box monitoring

00:15:07,680 --> 00:15:10,000
where the

00:15:08,160 --> 00:15:11,680
box is is completely open and you can

00:15:10,000 --> 00:15:15,040
look into the inside

00:15:11,680 --> 00:15:15,040
of of that box

00:15:15,600 --> 00:15:19,279
usually every service should have its

00:15:17,519 --> 00:15:21,600
own metrics endpoint

00:15:19,279 --> 00:15:23,120
which with the agent and such you can

00:15:21,600 --> 00:15:24,639
you can go against but

00:15:23,120 --> 00:15:26,720
usually in prometheus you should have

00:15:24,639 --> 00:15:28,560
that and we have super hard commitments

00:15:26,720 --> 00:15:29,279
within major versions about what we

00:15:28,560 --> 00:15:32,320
treat as

00:15:29,279 --> 00:15:34,240
stable so we don't just break stuff um

00:15:32,320 --> 00:15:36,160
what are time series time series are

00:15:34,240 --> 00:15:37,839
recorded values over time or which

00:15:36,160 --> 00:15:39,839
change over time

00:15:37,839 --> 00:15:41,199
um if you have individual events like a

00:15:39,839 --> 00:15:42,880
function being called

00:15:41,199 --> 00:15:45,519
those are merged usually into counters

00:15:42,880 --> 00:15:48,160
and or histograms like latency and such

00:15:45,519 --> 00:15:50,079
uh changing values like your temperature

00:15:48,160 --> 00:15:51,920
or your memory usage are as gorgeous and

00:15:50,079 --> 00:15:53,040
they can go up and they can they can go

00:15:51,920 --> 00:15:55,120
up and down

00:15:53,040 --> 00:15:56,079
typical excess examples you probably

00:15:55,120 --> 00:15:57,440
already read

00:15:56,079 --> 00:15:58,800
excess rates the web servers would be

00:15:57,440 --> 00:15:59,600
encountered temperatures would be a

00:15:58,800 --> 00:16:02,079
gorge

00:15:59,600 --> 00:16:04,000
service latency would be histogram it's

00:16:02,079 --> 00:16:05,920
super easy to admit in parse i know

00:16:04,000 --> 00:16:06,560
people who just print f in their c code

00:16:05,920 --> 00:16:08,240
and pos

00:16:06,560 --> 00:16:10,480
put this on a website and that's it

00:16:08,240 --> 00:16:11,839
that's how they emit data towards

00:16:10,480 --> 00:16:15,120
prometheus

00:16:11,839 --> 00:16:17,920
super easy scaling um kubernetes is

00:16:15,120 --> 00:16:20,079
equivalent to borg which is what google

00:16:17,920 --> 00:16:21,199
runs their their services with and

00:16:20,079 --> 00:16:23,920
prometheus is basically

00:16:21,199 --> 00:16:24,720
equivalent to pokemon but um the apis

00:16:23,920 --> 00:16:27,440
are more of

00:16:24,720 --> 00:16:28,160
monarch type and while kubernetes and

00:16:27,440 --> 00:16:30,959
prometheus

00:16:28,160 --> 00:16:32,560
were not started with each other in mind

00:16:30,959 --> 00:16:33,120
inherently they are designed for each

00:16:32,560 --> 00:16:35,759
other because

00:16:33,120 --> 00:16:36,880
of the heritage of their shared heritage

00:16:35,759 --> 00:16:39,279
and

00:16:36,880 --> 00:16:41,279
also if if kubernetes changes anything

00:16:39,279 --> 00:16:43,360
about their cubesat metrics and such

00:16:41,279 --> 00:16:45,040
that's always agreed with with

00:16:43,360 --> 00:16:48,399
prometheus team course we have people

00:16:45,040 --> 00:16:51,440
overlapped between those two projects

00:16:48,399 --> 00:16:55,120
raw numbers um the highest we know of

00:16:51,440 --> 00:16:57,680
um are uh 2.5 million samples per second

00:16:55,120 --> 00:16:59,120
and prometheus server

00:16:57,680 --> 00:17:02,720
which comes out depending on how you

00:16:59,120 --> 00:17:05,600
tune it a recent test i got 260k

00:17:02,720 --> 00:17:07,520
samples per second and core test before

00:17:05,600 --> 00:17:10,079
that we went to 100k

00:17:07,520 --> 00:17:11,199
um we can compress those 16 bytes per

00:17:10,079 --> 00:17:15,120
sample and second

00:17:11,199 --> 00:17:17,600
or per sample into into 1.36 bytes which

00:17:15,120 --> 00:17:19,839
speaks a little bit about the efficiency

00:17:17,600 --> 00:17:21,679
and the highest

00:17:19,839 --> 00:17:24,559
the largest prometheus we know of has

00:17:21,679 --> 00:17:27,199
125 million active series

00:17:24,559 --> 00:17:29,200
there's two long-term storage options

00:17:27,199 --> 00:17:32,080
one is thanos one is cortex

00:17:29,200 --> 00:17:33,280
historically thanos is easier to run and

00:17:32,080 --> 00:17:36,080
and was

00:17:33,280 --> 00:17:37,039
scaling storage horizontally whereas

00:17:36,080 --> 00:17:38,640
cortex

00:17:37,039 --> 00:17:40,480
was harder but it has become a lot

00:17:38,640 --> 00:17:43,520
easier and that started with

00:17:40,480 --> 00:17:44,640
scaling the ingester and the query

00:17:43,520 --> 00:17:46,880
horizontally

00:17:44,640 --> 00:17:47,760
cortex took in the code from thanos to

00:17:46,880 --> 00:17:49,360
also

00:17:47,760 --> 00:17:51,280
scale the storage horizontally and

00:17:49,360 --> 00:17:53,280
thanos is working on on

00:17:51,280 --> 00:17:54,960
taking the ingested inferior

00:17:53,280 --> 00:17:58,480
horizontally scalable code because those

00:17:54,960 --> 00:17:58,480
projects are super new to each other

00:17:58,720 --> 00:18:02,640
they experiment differently but still

00:18:00,400 --> 00:18:03,919
they are closed i hope that at some

00:18:02,640 --> 00:18:06,559
point they merge but

00:18:03,919 --> 00:18:07,600
probably not but i would hope so the

00:18:06,559 --> 00:18:10,880
official format

00:18:07,600 --> 00:18:13,120
for prometheus is called openmetrics um

00:18:10,880 --> 00:18:14,960
it's basically an independent standard

00:18:13,120 --> 00:18:18,080
of prometheus but permeated

00:18:14,960 --> 00:18:19,840
uses it as its official standard um that

00:18:18,080 --> 00:18:22,720
is mainly for compatibility

00:18:19,840 --> 00:18:24,400
reasons to to give people and projects

00:18:22,720 --> 00:18:27,679
and vendors something to support which

00:18:24,400 --> 00:18:30,400
is not called prometheus

00:18:27,679 --> 00:18:31,600
so for political reasons in in part that

00:18:30,400 --> 00:18:34,960
name was chosen

00:18:31,600 --> 00:18:36,160
um that's also about about putting all

00:18:34,960 --> 00:18:38,320
of this into itf

00:18:36,160 --> 00:18:39,440
so you have a real official independent

00:18:38,320 --> 00:18:44,080
standard

00:18:39,440 --> 00:18:47,919
um yeah there is a concept of

00:18:44,080 --> 00:18:50,480
three pillars um metrics logs and traces

00:18:47,919 --> 00:18:51,360
of course they usually have the metrics

00:18:50,480 --> 00:18:53,600
and logs are

00:18:51,360 --> 00:18:55,200
the easiest and cheapest in many ways

00:18:53,600 --> 00:18:57,360
and traces are just where you go with

00:18:55,200 --> 00:18:59,200
your application monitoring

00:18:57,360 --> 00:19:00,640
which is why which is why those are

00:18:59,200 --> 00:19:04,480
super tight

00:19:00,640 --> 00:19:08,000
super tightly coupled and in particular

00:19:04,480 --> 00:19:11,919
tying metrics to traces

00:19:08,000 --> 00:19:14,960
or lobster traces is super easy with

00:19:11,919 --> 00:19:15,919
with ex-employer this is a way to to

00:19:14,960 --> 00:19:19,840
attach

00:19:15,919 --> 00:19:20,960
ids of traces directly to your logs or

00:19:19,840 --> 00:19:22,880
your traces

00:19:20,960 --> 00:19:24,320
reason being you don't have to have the

00:19:22,880 --> 00:19:27,039
full label set

00:19:24,320 --> 00:19:28,400
um on your traces you can just use this

00:19:27,039 --> 00:19:30,400
one direct pointer

00:19:28,400 --> 00:19:31,679
which has a few nice other properties in

00:19:30,400 --> 00:19:33,440
particular you can just

00:19:31,679 --> 00:19:35,120
you already have all the context when

00:19:33,440 --> 00:19:37,600
you jump into your

00:19:35,120 --> 00:19:40,000
into your into your trace you already

00:19:37,600 --> 00:19:42,320
know what's wrong

00:19:40,000 --> 00:19:43,520
and yes i'm absolutely absolutely

00:19:42,320 --> 00:19:45,520
serious about that one

00:19:43,520 --> 00:19:47,200
i did start openmetrics to change how

00:19:45,520 --> 00:19:49,440
the world does observability where you

00:19:47,200 --> 00:19:52,160
have matrix logs and traces all with the

00:19:49,440 --> 00:19:53,919
same data model with the same underlying

00:19:52,160 --> 00:19:55,360
assumptions so it makes it easier to

00:19:53,919 --> 00:19:59,760
jump in between those

00:19:55,360 --> 00:20:01,840
those things speaking of which loki

00:19:59,760 --> 00:20:03,840
loki is basically like prometheus but

00:20:01,840 --> 00:20:05,280
for logs it has the same label based

00:20:03,840 --> 00:20:07,360
system like prometheus

00:20:05,280 --> 00:20:08,880
you don't need your full text index you

00:20:07,360 --> 00:20:10,559
just index your labels and everything

00:20:08,880 --> 00:20:13,679
else is an opaque string which makes it

00:20:10,559 --> 00:20:17,280
super quick and super cheap to run

00:20:13,679 --> 00:20:17,280
it works at insane scales

00:20:17,360 --> 00:20:22,080
your yeah your your logs would have the

00:20:20,720 --> 00:20:23,120
same label sets as your metrics i

00:20:22,080 --> 00:20:25,120
already said that

00:20:23,120 --> 00:20:26,320
um which makes it a lot easier to just

00:20:25,120 --> 00:20:28,480
jump between uh

00:20:26,320 --> 00:20:30,240
the two and you can also easily extract

00:20:28,480 --> 00:20:32,720
metrics from your logs

00:20:30,240 --> 00:20:33,520
if that looks familiar um that's because

00:20:32,720 --> 00:20:34,720
it is

00:20:33,520 --> 00:20:36,720
you have your timestamp which is

00:20:34,720 --> 00:20:38,240
mandatory in in logging but else

00:20:36,720 --> 00:20:41,120
you have the same label set and then you

00:20:38,240 --> 00:20:45,120
just have your your opaque string

00:20:41,120 --> 00:20:46,960
that leaves us with traces um

00:20:45,120 --> 00:20:49,600
tempo is is one of the implementations

00:20:46,960 --> 00:20:51,679
is designed precisely for this example

00:20:49,600 --> 00:20:53,440
based world

00:20:51,679 --> 00:20:55,039
it's only an object store you don't have

00:20:53,440 --> 00:20:56,720
to run any any

00:20:55,039 --> 00:20:58,400
expensive services in the backend you

00:20:56,720 --> 00:20:59,760
can just use an object store

00:20:58,400 --> 00:21:01,520
it's fully compatible with open

00:20:59,760 --> 00:21:02,640
telemetry tracing zipkin conjure all

00:21:01,520 --> 00:21:04,720
those things

00:21:02,640 --> 00:21:06,320
um because it is so efficient you don't

00:21:04,720 --> 00:21:08,000
need to sample your traces so if you

00:21:06,320 --> 00:21:09,200
have an interesting trace id you know

00:21:08,000 --> 00:21:09,600
you can actually jump to it and you

00:21:09,200 --> 00:21:12,880
don't

00:21:09,600 --> 00:21:15,200
just lose it and you can

00:21:12,880 --> 00:21:16,159
like prometheus cortex thanos loki they

00:21:15,200 --> 00:21:17,840
all support

00:21:16,159 --> 00:21:20,799
they all support ex-employers so you can

00:21:17,840 --> 00:21:24,000
do this jumping back and forth

00:21:20,799 --> 00:21:24,000
some numbers on scaling

00:21:24,080 --> 00:21:28,559
for what we run internally we have 1

00:21:26,720 --> 00:21:31,760
million samples per second

00:21:28,559 --> 00:21:33,679
retain 100 of those and if we go and as

00:21:31,760 --> 00:21:37,120
we go for 14 day retention

00:21:33,679 --> 00:21:37,760
with three copies stored uh we have a

00:21:37,120 --> 00:21:40,559
cost of

00:21:37,760 --> 00:21:43,440
roughly 200 cpu cores 300 gigs of ram

00:21:40,559 --> 00:21:46,559
and 40 terabyte of object storage

00:21:43,440 --> 00:21:49,600
for 1 million samples per second

00:21:46,559 --> 00:21:51,840
for 14 days and we

00:21:49,600 --> 00:21:53,039
did a 10x jump recently and we already

00:21:51,840 --> 00:21:55,200
have plans for the

00:21:53,039 --> 00:21:57,200
next 10x jump those numbers are already

00:21:55,200 --> 00:22:00,400
a few weeks old i think we already have

00:21:57,200 --> 00:22:01,679
better numbers now bringing all of this

00:22:00,400 --> 00:22:04,400
together

00:22:01,679 --> 00:22:05,760
this allows you to jump from your logs

00:22:04,400 --> 00:22:08,320
to your traces

00:22:05,760 --> 00:22:12,000
directly this allows you to jump from

00:22:08,320 --> 00:22:14,799
your metrics to your traces

00:22:12,000 --> 00:22:16,240
from your traces to your logs and all of

00:22:14,799 --> 00:22:16,880
this is open source you can run it

00:22:16,240 --> 00:22:18,480
yourself

00:22:16,880 --> 00:22:20,240
um we also have a cloud offering and

00:22:18,480 --> 00:22:21,120
such obviously but all of this is open

00:22:20,240 --> 00:22:23,679
source

00:22:21,120 --> 00:22:25,440
um so you can really run it yourself

00:22:23,679 --> 00:22:28,159
without having to pay anyone

00:22:25,440 --> 00:22:28,640
or so you can just take the software run

00:22:28,159 --> 00:22:31,679
it and

00:22:28,640 --> 00:22:41,840
done thank you

00:22:31,679 --> 00:22:41,840
and now for questions

00:22:45,600 --> 00:22:51,919
awesome thank you very much rich uh

00:22:48,720 --> 00:22:52,240
let me check the chats so far i've not

00:22:51,919 --> 00:22:56,799
seen

00:22:52,240 --> 00:22:56,799
any question yet um

00:22:58,320 --> 00:23:03,120
so but i would like to ask one for all

00:23:01,200 --> 00:23:06,159
benefits of juice that are not

00:23:03,120 --> 00:23:07,200
uh that are new to the climatic

00:23:06,159 --> 00:23:10,400
ecosystem

00:23:07,200 --> 00:23:10,400
yet now

00:23:10,640 --> 00:23:15,200
is observability a major concern or a

00:23:13,120 --> 00:23:18,480
major thing that someone who is

00:23:15,200 --> 00:23:20,000
new to everything

00:23:18,480 --> 00:23:22,000
that they should worry about or is

00:23:20,000 --> 00:23:25,840
killed they should pick up at very early

00:23:22,000 --> 00:23:28,880
stage um yeah absolutely

00:23:25,840 --> 00:23:30,559
it's a hard requirement in my opinion

00:23:28,880 --> 00:23:32,480
if you look at if you look at previous

00:23:30,559 --> 00:23:34,840
systems where you had one

00:23:32,480 --> 00:23:36,720
service running on one machine or some

00:23:34,840 --> 00:23:38,240
such a lot of

00:23:36,720 --> 00:23:40,159
you you basically have a lot of the same

00:23:38,240 --> 00:23:41,919
underlying complexity but this was

00:23:40,159 --> 00:23:43,840
uh well hidden behind the operating

00:23:41,919 --> 00:23:45,440
system and behind more traditional tools

00:23:43,840 --> 00:23:47,360
which allowed you to do all that

00:23:45,440 --> 00:23:50,400
debugging already

00:23:47,360 --> 00:23:52,640
that changed with cloud native of course

00:23:50,400 --> 00:23:54,880
the cost or part of the cost which you

00:23:52,640 --> 00:23:57,440
have to pay for being so flexible and so

00:23:54,880 --> 00:24:00,480
scalable in a cloud native world

00:23:57,440 --> 00:24:03,760
is that you that you redistribute

00:24:00,480 --> 00:24:06,159
the inherent complexity and

00:24:03,760 --> 00:24:08,320
if you have a previous you had maybe

00:24:06,159 --> 00:24:10,000
your server and then you had more users

00:24:08,320 --> 00:24:10,559
and you had to buy a bigger server and

00:24:10,000 --> 00:24:13,200
and you

00:24:10,559 --> 00:24:14,480
you contained a lot of this through the

00:24:13,200 --> 00:24:16,240
system but now

00:24:14,480 --> 00:24:18,720
if you run everything in the cloud and

00:24:16,240 --> 00:24:21,840
you you have a lot of users jump in

00:24:18,720 --> 00:24:24,400
um maybe you just scale out to two three

00:24:21,840 --> 00:24:26,000
ten times the amount of of whatever is

00:24:24,400 --> 00:24:29,200
your is your service uh

00:24:26,000 --> 00:24:31,840
thing um and you scale this out

00:24:29,200 --> 00:24:33,600
and this ex leads to an absolute

00:24:31,840 --> 00:24:36,400
explosion

00:24:33,600 --> 00:24:39,200
of the overall system information about

00:24:36,400 --> 00:24:42,080
your system as it is running

00:24:39,200 --> 00:24:43,440
and this immense amount of data you're

00:24:42,080 --> 00:24:46,320
not able to

00:24:43,440 --> 00:24:48,000
anymore to just as a human go through a

00:24:46,320 --> 00:24:50,240
few log lines and figure out what's

00:24:48,000 --> 00:24:52,640
happening it's just impossible

00:24:50,240 --> 00:24:54,159
because you have so much stuff going on

00:24:52,640 --> 00:24:57,919
at the same time

00:24:54,159 --> 00:24:59,440
so um you don't have a chance to to run

00:24:57,919 --> 00:25:02,080
a service properly

00:24:59,440 --> 00:25:04,320
unless you have a chance to understand

00:25:02,080 --> 00:25:07,600
how that service is run

00:25:04,320 --> 00:25:09,760
obviously yeah and observability in

00:25:07,600 --> 00:25:12,320
large part is just a code word for

00:25:09,760 --> 00:25:13,360
make it possible to to understand all of

00:25:12,320 --> 00:25:15,200
this

00:25:13,360 --> 00:25:18,320
and not only understand what is

00:25:15,200 --> 00:25:20,240
happening but in particular understand

00:25:18,320 --> 00:25:21,919
what and why is happening when something

00:25:20,240 --> 00:25:26,960
goes wrong

00:25:21,919 --> 00:25:29,279
okay how is it different to tracing

00:25:26,960 --> 00:25:30,480
not at all uh tracing is part of

00:25:29,279 --> 00:25:33,760
observability

00:25:30,480 --> 00:25:34,960
um there's like there are different

00:25:33,760 --> 00:25:37,360
there are different uh

00:25:34,960 --> 00:25:38,640
approaches to how you do tracing within

00:25:37,360 --> 00:25:40,720
uh within

00:25:38,640 --> 00:25:42,400
observability if if you want me to talk

00:25:40,720 --> 00:25:45,679
about this i can easily do it

00:25:42,400 --> 00:25:47,840
but the high level uh reply is just um

00:25:45,679 --> 00:25:49,200
it's one of the signals which you need

00:25:47,840 --> 00:25:52,159
to do for proper

00:25:49,200 --> 00:25:53,600
observability and at least if you have

00:25:52,159 --> 00:25:55,679
access into

00:25:53,600 --> 00:25:58,320
your software which is cloud native and

00:25:55,679 --> 00:26:01,120
such is is pretty common

00:25:58,320 --> 00:26:01,919
if you run more traditional uh services

00:26:01,120 --> 00:26:04,480
or even

00:26:01,919 --> 00:26:06,080
servers and machines and and network

00:26:04,480 --> 00:26:06,559
routers you usually don't even have

00:26:06,080 --> 00:26:10,080
access

00:26:06,559 --> 00:26:12,640
to those places yeah you just cannot

00:26:10,080 --> 00:26:14,559
but as soon as you have access to them

00:26:12,640 --> 00:26:16,720
you should absolutely make this part of

00:26:14,559 --> 00:26:19,679
your observability story

00:26:16,720 --> 00:26:21,120
okay awesome yeah thank you very much i

00:26:19,679 --> 00:26:23,200
think uh

00:26:21,120 --> 00:26:25,279
we still don't have any questions i've

00:26:23,200 --> 00:26:26,960
checked the live stream also there are

00:26:25,279 --> 00:26:30,159
no questions

00:26:26,960 --> 00:26:32,559
but i believe um the

00:26:30,159 --> 00:26:35,279
participants have seen your contact

00:26:32,559 --> 00:26:39,440
details you can reach

00:26:35,279 --> 00:26:40,960
richie on either twitter or

00:26:39,440 --> 00:26:42,559
send him an email if you have any

00:26:40,960 --> 00:26:44,960
questions or if you need

00:26:42,559 --> 00:26:46,880
more clarification on observability or

00:26:44,960 --> 00:26:48,720
tracing he's an expert in it and

00:26:46,880 --> 00:26:52,000
can definitely point you in the right

00:26:48,720 --> 00:26:56,880
direction thank you very much rich and

00:26:52,000 --> 00:26:56,880

YouTube URL: https://www.youtube.com/watch?v=OvyKsxWSAvs


