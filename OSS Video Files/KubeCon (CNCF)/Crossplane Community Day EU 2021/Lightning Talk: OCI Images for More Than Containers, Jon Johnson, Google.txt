Title: Lightning Talk: OCI Images for More Than Containers, Jon Johnson, Google
Publication date: 2021-05-04
Playlist: Crossplane Community Day EU 2021
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Lightning Talk: OCI Images for More Than Containers, Jon Johnson, Google

OCI images have become synonymous with containers, yet the fact that they are used for running containerized processes is nothing more than an implementation detail. In reality, OCI images are capable of packaging arbitrary data, and because of the wide proliferation of registry offerings, they are an attractive distribution mechanism for hosting and sharing standardized artifacts. In this talk, Jon and Dan will peel back the layers of the OCI image specification, exploring what components are required and which are optional, as well as how to build your own images by hand. The Crossplane package manager’s usage of the go-containerregistry library will serve as a reference for how these concepts can be used in practice. Attendees will leave with a greater knowledge of how Crossplane works under the hood, and how OCI images may be used to solve their own artifact distribution problems.
Captions: 
	00:00:00,240 --> 00:00:04,319
hello uh this is the oci images for more

00:00:02,800 --> 00:00:07,839
than containers lightning talk

00:00:04,319 --> 00:00:10,320
and i am john johnson a little about me

00:00:07,839 --> 00:00:11,280
i have been working at google for the

00:00:10,320 --> 00:00:13,360
last five years

00:00:11,280 --> 00:00:14,400
on various container things starting out

00:00:13,360 --> 00:00:17,039
on the gcr team

00:00:14,400 --> 00:00:18,240
and recently focusing on the generic

00:00:17,039 --> 00:00:21,119
artifact registry

00:00:18,240 --> 00:00:22,960
service since 2018 i've also served on

00:00:21,119 --> 00:00:23,439
the oci technical oversight board which

00:00:22,960 --> 00:00:25,680
is where

00:00:23,439 --> 00:00:26,480
i formally argue about semantics on the

00:00:25,680 --> 00:00:28,800
internet

00:00:26,480 --> 00:00:30,400
mostly around containers i also maintain

00:00:28,800 --> 00:00:32,559
a couple projects on github

00:00:30,400 --> 00:00:33,680
and on the right you can see our dog

00:00:32,559 --> 00:00:35,600
graceann

00:00:33,680 --> 00:00:37,680
grace.dog for more pictures of her if

00:00:35,600 --> 00:00:40,160
you're interested

00:00:37,680 --> 00:00:40,800
uh we will eventually get to crossplane

00:00:40,160 --> 00:00:42,960
but

00:00:40,800 --> 00:00:44,640
uh first we're going to go over some oci

00:00:42,960 --> 00:00:47,120
data structure background

00:00:44,640 --> 00:00:48,800
the registry and this go container

00:00:47,120 --> 00:00:49,760
registry library

00:00:48,800 --> 00:00:51,120
at the end we'll talk about how

00:00:49,760 --> 00:00:53,039
cross-plane ties all this together to

00:00:51,120 --> 00:00:54,719
manage packages

00:00:53,039 --> 00:00:56,079
and just as a disclaimer this was

00:00:54,719 --> 00:00:56,879
originally going to be a longer talk

00:00:56,079 --> 00:00:58,399
with both me

00:00:56,879 --> 00:01:00,239
and daniel mangum but it has been

00:00:58,399 --> 00:01:01,840
squished down into a lightning talk

00:01:00,239 --> 00:01:03,280
so i'm going to go really fast and i

00:01:01,840 --> 00:01:06,159
apologize

00:01:03,280 --> 00:01:08,080
also caveat i am not a cross plane

00:01:06,159 --> 00:01:09,920
expert so i will hand wave over

00:01:08,080 --> 00:01:13,360
some of those details while focusing

00:01:09,920 --> 00:01:17,280
more on the oci stuff

00:01:13,360 --> 00:01:18,799
moving on to the image specification so

00:01:17,280 --> 00:01:20,479
i would assume most people watching this

00:01:18,799 --> 00:01:20,799
are somewhat familiar with merkle dags

00:01:20,479 --> 00:01:24,640
but

00:01:20,799 --> 00:01:27,920
if not a dag here is a directed acyclic

00:01:24,640 --> 00:01:30,240
graph which means there are no cycles

00:01:27,920 --> 00:01:31,200
a merkle dag is a graph constructed out

00:01:30,240 --> 00:01:32,320
of hashes

00:01:31,200 --> 00:01:34,640
which means the entire thing is

00:01:32,320 --> 00:01:37,280
immutable and also enforces that acyclic

00:01:34,640 --> 00:01:38,320
bit this is a very nice property for a

00:01:37,280 --> 00:01:39,520
data structure

00:01:38,320 --> 00:01:41,280
you're probably familiar with things

00:01:39,520 --> 00:01:41,840
like git and bitcoin which use merkle

00:01:41,280 --> 00:01:43,600
dags

00:01:41,840 --> 00:01:46,079
but you may not be familiar with the

00:01:43,600 --> 00:01:47,759
fact that oci images also are built on

00:01:46,079 --> 00:01:49,840
top of merkle dax

00:01:47,759 --> 00:01:52,799
so on the right we have this example

00:01:49,840 --> 00:01:54,320
graph that represents an oci image

00:01:52,799 --> 00:01:56,479
the arrows between nodes represent

00:01:54,320 --> 00:01:57,680
hashes and so when i say digest i'm

00:01:56,479 --> 00:01:59,840
talking about these arrows

00:01:57,680 --> 00:02:02,240
pointing to content as the hash of

00:01:59,840 --> 00:02:02,240
content

00:02:02,640 --> 00:02:06,640
so the the fundamental primitive of oci

00:02:05,439 --> 00:02:09,039
data structures is

00:02:06,640 --> 00:02:10,399
called a content descriptor this is just

00:02:09,039 --> 00:02:12,879
a simple tuple of

00:02:10,399 --> 00:02:14,239
media type size and digest these

00:02:12,879 --> 00:02:17,599
properties together act as

00:02:14,239 --> 00:02:19,440
this strongly typed immutable pointer to

00:02:17,599 --> 00:02:20,959
arbitrary things right this is this

00:02:19,440 --> 00:02:22,000
generic data structure that's very

00:02:20,959 --> 00:02:24,480
useful

00:02:22,000 --> 00:02:25,120
so the media type tells us the format of

00:02:24,480 --> 00:02:27,440
some bytes

00:02:25,120 --> 00:02:29,599
and how we should interpret that the

00:02:27,440 --> 00:02:31,120
size tells us exactly how many bytes we

00:02:29,599 --> 00:02:33,120
should expect which is helpful mostly

00:02:31,120 --> 00:02:35,200
for safety reasons

00:02:33,120 --> 00:02:37,040
and the digest is that immutable content

00:02:35,200 --> 00:02:39,599
identifier from earlier

00:02:37,040 --> 00:02:40,080
and so for this example if you were to

00:02:39,599 --> 00:02:42,480
find

00:02:40,080 --> 00:02:43,599
this descriptor on the ground somewhere

00:02:42,480 --> 00:02:45,920
in isolation

00:02:43,599 --> 00:02:47,440
you would know that it is talking about

00:02:45,920 --> 00:02:49,760
an oci image manifest

00:02:47,440 --> 00:02:52,239
which is encoded as json that has

00:02:49,760 --> 00:02:55,040
exactly 7682 bytes

00:02:52,239 --> 00:02:56,480
and has this shot 56 blah blah blah

00:02:55,040 --> 00:02:57,680
right

00:02:56,480 --> 00:02:58,640
usually though we don't find these on

00:02:57,680 --> 00:03:00,319
the ground they're actually just

00:02:58,640 --> 00:03:01,200
embedded in other data structures for

00:03:00,319 --> 00:03:04,400
example

00:03:01,200 --> 00:03:05,680
the image manifest so the image manifest

00:03:04,400 --> 00:03:08,480
is what most people will be familiar

00:03:05,680 --> 00:03:10,159
with as say like a docker image

00:03:08,480 --> 00:03:12,000
and is equivalent to the docker v2

00:03:10,159 --> 00:03:15,360
schema 2 image format

00:03:12,000 --> 00:03:17,599
roughly simply put it is two things

00:03:15,360 --> 00:03:19,519
there is this config descriptor and that

00:03:17,599 --> 00:03:20,879
points to a json blob

00:03:19,519 --> 00:03:22,400
with various information about how to

00:03:20,879 --> 00:03:24,480
run the image for example what

00:03:22,400 --> 00:03:26,799
environment variables should be set

00:03:24,480 --> 00:03:28,159
the user that should run the process it

00:03:26,799 --> 00:03:30,239
also contains some other

00:03:28,159 --> 00:03:32,000
the metadata like the creation time and

00:03:30,239 --> 00:03:34,720
also how the image was

00:03:32,000 --> 00:03:35,120
built then there are also layers which

00:03:34,720 --> 00:03:38,080
are

00:03:35,120 --> 00:03:40,720
just a list of descriptors that describe

00:03:38,080 --> 00:03:42,799
the container images file system

00:03:40,720 --> 00:03:44,239
these are represented as a special

00:03:42,799 --> 00:03:46,560
change set tarballs

00:03:44,239 --> 00:03:49,200
they're usually gzipped but they are

00:03:46,560 --> 00:03:50,879
flattened into

00:03:49,200 --> 00:03:52,640
the representation of the file system

00:03:50,879 --> 00:03:56,080
using some union fs

00:03:52,640 --> 00:03:56,080
mechanism usually

00:03:56,239 --> 00:04:00,159
the last interesting data structure is

00:03:58,080 --> 00:04:00,959
an image index also known as a manifest

00:04:00,159 --> 00:04:02,720
list

00:04:00,959 --> 00:04:04,239
so this is just kind of like a meta

00:04:02,720 --> 00:04:07,040
manifest that references

00:04:04,239 --> 00:04:08,560
other manifests or really anything that

00:04:07,040 --> 00:04:10,319
you can describe with a content

00:04:08,560 --> 00:04:11,680
descriptor so

00:04:10,319 --> 00:04:13,519
in my head i think of this as like a

00:04:11,680 --> 00:04:16,160
folder right

00:04:13,519 --> 00:04:16,880
but the most common use by far for these

00:04:16,160 --> 00:04:18,799
is to

00:04:16,880 --> 00:04:19,919
distribute multi-platform images so in

00:04:18,799 --> 00:04:23,280
this case we have

00:04:19,919 --> 00:04:24,160
a manifest list that points to a powerpc

00:04:23,280 --> 00:04:26,560
image

00:04:24,160 --> 00:04:27,759
and an amd64 image and so clients when

00:04:26,560 --> 00:04:29,280
they encounter this they can look at

00:04:27,759 --> 00:04:30,960
those platforms and select

00:04:29,280 --> 00:04:33,440
an appropriate image for the target

00:04:30,960 --> 00:04:33,440
runtime

00:04:34,479 --> 00:04:39,120
now briefly onto registries so the

00:04:36,800 --> 00:04:41,600
registry protocol

00:04:39,120 --> 00:04:43,600
basically is just a protocol for

00:04:41,600 --> 00:04:45,280
uploading and downloading stuff via http

00:04:43,600 --> 00:04:47,520
and it is pretty similar to like the

00:04:45,280 --> 00:04:49,440
dumb and get protocol

00:04:47,520 --> 00:04:50,880
um we don't have too much time to get

00:04:49,440 --> 00:04:53,840
too deep into it but

00:04:50,880 --> 00:04:55,360
roughly there are two handlers the

00:04:53,840 --> 00:04:58,560
manifest handler which

00:04:55,360 --> 00:05:00,160
is for structured content like the data

00:04:58,560 --> 00:05:02,479
structures we just discussed

00:05:00,160 --> 00:05:04,560
and then there's the blobs handler which

00:05:02,479 --> 00:05:04,960
is for opaque content that registries

00:05:04,560 --> 00:05:06,960
don't

00:05:04,960 --> 00:05:08,320
try to understand things that are

00:05:06,960 --> 00:05:11,759
uploaded as blobs

00:05:08,320 --> 00:05:14,479
are usually leaves in a merkle dag

00:05:11,759 --> 00:05:14,880
and things uploaded as manifest usually

00:05:14,479 --> 00:05:17,039
have

00:05:14,880 --> 00:05:18,720
outward pointers to those leaves and so

00:05:17,039 --> 00:05:21,039
registries tend to

00:05:18,720 --> 00:05:23,039
parse things uploaded as manifests so

00:05:21,039 --> 00:05:25,120
that they can do

00:05:23,039 --> 00:05:26,639
ref counting and garbage collection and

00:05:25,120 --> 00:05:28,080
enforcement variants like you don't want

00:05:26,639 --> 00:05:30,880
to upload something that points to a

00:05:28,080 --> 00:05:32,400
blob that doesn't exist

00:05:30,880 --> 00:05:34,320
both manifest and blobs can be

00:05:32,400 --> 00:05:36,160
referenced by their digest

00:05:34,320 --> 00:05:38,560
but manifest can also be referenced by

00:05:36,160 --> 00:05:41,440
mutable tag identifiers

00:05:38,560 --> 00:05:42,240
which we'll get to later the reason

00:05:41,440 --> 00:05:43,520
we're talking about this is that

00:05:42,240 --> 00:05:46,160
registries are interesting

00:05:43,520 --> 00:05:47,759
to us if you're running say images on

00:05:46,160 --> 00:05:48,560
kubernetes you need to pull them from

00:05:47,759 --> 00:05:52,240
somewhere

00:05:48,560 --> 00:05:54,160
and so we have this service that stores

00:05:52,240 --> 00:05:55,680
artifacts already that we're already

00:05:54,160 --> 00:05:59,600
using from a cluster

00:05:55,680 --> 00:06:01,520
which we'll get to later um i can

00:05:59,600 --> 00:06:04,000
demonstrate with a tool i have built

00:06:01,520 --> 00:06:07,440
what these look like in an actual

00:06:04,000 --> 00:06:10,479
registry so um here i'm showing a

00:06:07,440 --> 00:06:12,880
manifest list on docker hub um we can

00:06:10,479 --> 00:06:15,759
look at this first one

00:06:12,880 --> 00:06:16,639
which is an amd64 linux image and this

00:06:15,759 --> 00:06:18,639
pulls up

00:06:16,639 --> 00:06:20,800
just the image manifest which again

00:06:18,639 --> 00:06:21,440
points to a bunch of layers and some

00:06:20,800 --> 00:06:23,680
config

00:06:21,440 --> 00:06:24,560
the config has various things for

00:06:23,680 --> 00:06:28,319
example here's the

00:06:24,560 --> 00:06:28,319
environment variable set via the path

00:06:29,360 --> 00:06:35,120
and then the file system again is just

00:06:33,199 --> 00:06:38,319
a tarble right so we can look at this

00:06:35,120 --> 00:06:38,319
just like any other file system

00:06:40,800 --> 00:06:46,240
uh moving on to my magnum opus which is

00:06:43,440 --> 00:06:47,600
the go container registry library so

00:06:46,240 --> 00:06:49,440
the reason i was asked to give this talk

00:06:47,600 --> 00:06:50,800
is that i maintain this go library and

00:06:49,440 --> 00:06:54,000
crossplane uses it

00:06:50,800 --> 00:06:55,599
um and more than that many other tools

00:06:54,000 --> 00:06:59,199
depend on this so for example

00:06:55,599 --> 00:07:01,039
my own cli called crane is a generic

00:06:59,199 --> 00:07:02,400
registry client which i have just

00:07:01,039 --> 00:07:05,280
shamelessly plugged

00:07:02,400 --> 00:07:05,680
more interesting for this uh kubecon

00:07:05,280 --> 00:07:07,520
talk

00:07:05,680 --> 00:07:08,880
though is that there are various

00:07:07,520 --> 00:07:11,520
kubernetes controllers

00:07:08,880 --> 00:07:13,520
that use go container registry so the

00:07:11,520 --> 00:07:16,240
first of those was the k native

00:07:13,520 --> 00:07:17,599
revision controller and that roughly

00:07:16,240 --> 00:07:20,080
just would resolve

00:07:17,599 --> 00:07:22,240
image tags to their immutable image

00:07:20,080 --> 00:07:23,599
digest references

00:07:22,240 --> 00:07:25,360
you can read more on this kubernetes

00:07:23,599 --> 00:07:26,960
issue about why that's a useful thing to

00:07:25,360 --> 00:07:30,080
do

00:07:26,960 --> 00:07:31,520
the second adopter of go container

00:07:30,080 --> 00:07:34,479
registry was techton and

00:07:31,520 --> 00:07:35,520
it used the library for basically

00:07:34,479 --> 00:07:38,319
rewriting

00:07:35,520 --> 00:07:39,280
a pod's entry point to enable

00:07:38,319 --> 00:07:41,120
interesting

00:07:39,280 --> 00:07:43,280
uh features that kubernetes doesn't

00:07:41,120 --> 00:07:44,800
allow like ordering tasks

00:07:43,280 --> 00:07:46,080
christy wilson and jason hall gave a

00:07:44,800 --> 00:07:46,720
really great talk on this already you

00:07:46,080 --> 00:07:49,360
can

00:07:46,720 --> 00:07:50,000
follow that youtube link but more

00:07:49,360 --> 00:07:52,319
recently

00:07:50,000 --> 00:07:53,759
is uh techton's use of go container

00:07:52,319 --> 00:07:56,000
registry for something called tekton

00:07:53,759 --> 00:07:57,759
bundles which are basically

00:07:56,000 --> 00:08:01,039
just oci images that contain a bunch of

00:07:57,759 --> 00:08:03,360
yaml describing tecton resources

00:08:01,039 --> 00:08:04,080
um that's very relevant to this talk

00:08:03,360 --> 00:08:05,280
because that's

00:08:04,080 --> 00:08:07,840
basically the exact same thing that

00:08:05,280 --> 00:08:10,400
crossplane does to manage packages so

00:08:07,840 --> 00:08:11,360
uh crossplane same thing right yaml and

00:08:10,400 --> 00:08:13,919
an sdi image

00:08:11,360 --> 00:08:14,560
across my packages so finally tying this

00:08:13,919 --> 00:08:15,840
together

00:08:14,560 --> 00:08:17,840
and this is where i will hand wave

00:08:15,840 --> 00:08:18,639
because i don't really understand it but

00:08:17,840 --> 00:08:20,319
basically

00:08:18,639 --> 00:08:22,000
packages come in a couple varieties

00:08:20,319 --> 00:08:23,919
there are providers and configurations

00:08:22,000 --> 00:08:25,360
i don't really know what those are but i

00:08:23,919 --> 00:08:26,800
do know it's a bunch of pml given that

00:08:25,360 --> 00:08:29,360
this is kubernetes

00:08:26,800 --> 00:08:30,720
um the cross plane controller has two

00:08:29,360 --> 00:08:33,200
reconcilers

00:08:30,720 --> 00:08:35,200
a revision reconciler and a manager so

00:08:33,200 --> 00:08:36,560
the revision reconciler is what actually

00:08:35,200 --> 00:08:37,519
talks to the registry it pulls down

00:08:36,560 --> 00:08:39,680
these images

00:08:37,519 --> 00:08:41,279
caches them extracts the animal and does

00:08:39,680 --> 00:08:43,279
all the actual work of like installing a

00:08:41,279 --> 00:08:45,120
package all the business logic

00:08:43,279 --> 00:08:47,120
the manager is quite literally a package

00:08:45,120 --> 00:08:48,720
manager it is responsible for

00:08:47,120 --> 00:08:51,120
pinging the registry to detect updates

00:08:48,720 --> 00:08:53,040
to images and also garbage collection

00:08:51,120 --> 00:08:54,560
old package images that are no longer

00:08:53,040 --> 00:08:56,880
needed again

00:08:54,560 --> 00:08:58,880
really hand waving over this uh but i do

00:08:56,880 --> 00:08:59,839
have a couple examples that i think make

00:08:58,880 --> 00:09:02,480
this clearer

00:08:59,839 --> 00:09:03,040
a little bit so here is the example gcp

00:09:02,480 --> 00:09:05,279
provider

00:09:03,040 --> 00:09:06,480
right there's this very special animal

00:09:05,279 --> 00:09:09,519
at the top

00:09:06,480 --> 00:09:13,360
and then there is also a

00:09:09,519 --> 00:09:15,519
folder of crds again or yaml um

00:09:13,360 --> 00:09:17,920
if we look at what this looks like in

00:09:15,519 --> 00:09:20,000
the upbound registry

00:09:17,920 --> 00:09:22,160
um you can see that there is this one

00:09:20,000 --> 00:09:22,560
layer it contains this one package.iamo

00:09:22,160 --> 00:09:23,839
file

00:09:22,560 --> 00:09:25,680
and this is just all of the aml

00:09:23,839 --> 00:09:27,200
concatenated together so

00:09:25,680 --> 00:09:29,200
the controller just pulls down that

00:09:27,200 --> 00:09:34,560
image extracts the ammo

00:09:29,200 --> 00:09:36,240
and processes it so to summarize

00:09:34,560 --> 00:09:38,399
you can use oci images for more things

00:09:36,240 --> 00:09:40,240
than just containers like camel

00:09:38,399 --> 00:09:42,000
go container registry is very cool it

00:09:40,240 --> 00:09:44,240
makes this easier and cross-plain

00:09:42,000 --> 00:09:45,920
packages are one example of that

00:09:44,240 --> 00:09:47,360
there are three other projects here that

00:09:45,920 --> 00:09:51,200
do similar things

00:09:47,360 --> 00:09:54,720
that you should check out as well

00:09:51,200 --> 00:09:54,720

YouTube URL: https://www.youtube.com/watch?v=ExyWAhS2zBA


