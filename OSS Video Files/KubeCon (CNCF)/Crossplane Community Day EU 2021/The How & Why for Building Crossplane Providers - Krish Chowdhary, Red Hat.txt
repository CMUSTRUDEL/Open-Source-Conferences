Title: The How & Why for Building Crossplane Providers - Krish Chowdhary, Red Hat
Publication date: 2021-05-04
Playlist: Crossplane Community Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

The How & Why for Building Crossplane Providers - Krish Chowdhary, Red Hat

Provisioning and managing cloud resources like infrastructure, services, and applications are one of the core features offered by Crossplane. We achieve this goal by creating independent Providers which expose Custom Resource Definitions in a Kubernetes cluster. Although the development of these Providers is community-driven, there are overarching design patterns that exist in all the Providers. In this talk, we will be going over the fundamentals of Crossplane Providers, the architecture, and how to contribute. Additionally, we will talk about the how and why for creating a Provider, what drives the use case, and when is it a good idea to create a Provider as opposed to other options like Helm Charts, Operators, or Kustomize resources. We will wrap up the talk by bootstrapping the development of a new Provider, as well as a small demo for creating a new resource.
Captions: 
	00:00:00,080 --> 00:00:03,760
the how and why for building crossplan

00:00:01,680 --> 00:00:05,359
providers hello everyone

00:00:03,760 --> 00:00:07,359
my name is krish and today we're going

00:00:05,359 --> 00:00:10,240
to be going over uh

00:00:07,359 --> 00:00:12,799
how and and why you might want to build

00:00:10,240 --> 00:00:14,080
your own crossland provider

00:00:12,799 --> 00:00:16,080
but first things first a little bit

00:00:14,080 --> 00:00:18,800
about me i'm a software engineer

00:00:16,080 --> 00:00:20,960
at red hat in the office of the cto and

00:00:18,800 --> 00:00:23,359
i'm a maintainer on the provider aws

00:00:20,960 --> 00:00:25,039
and provider in cluster projects under

00:00:23,359 --> 00:00:27,760
crossplane

00:00:25,039 --> 00:00:29,599
i'm also a member of the kubernetes 6

00:00:27,760 --> 00:00:31,439
storage where i actively contribute to a

00:00:29,599 --> 00:00:34,000
few projects

00:00:31,439 --> 00:00:37,280
my twitter is chris ciao underscore and

00:00:34,000 --> 00:00:40,079
my github is chris chow

00:00:37,280 --> 00:00:41,520
uh so in this talk we're going to go

00:00:40,079 --> 00:00:45,680
over the what where when

00:00:41,520 --> 00:00:49,200
why and who for crossplan providers

00:00:45,680 --> 00:00:51,760
as well as in the second part the

00:00:49,200 --> 00:00:53,280
how for how you can create a provider

00:00:51,760 --> 00:00:54,000
this will include talking about the main

00:00:53,280 --> 00:00:56,399
components

00:00:54,000 --> 00:00:59,199
and then eventually live coding a new

00:00:56,399 --> 00:01:01,359
feature for the provider in cluster

00:00:59,199 --> 00:01:02,960
so let's start with what so let's

00:01:01,359 --> 00:01:04,559
quickly go over what crossplane is

00:01:02,960 --> 00:01:06,080
so the crossband project allows you to

00:01:04,559 --> 00:01:08,479
provision cloud resources

00:01:06,080 --> 00:01:10,320
from within your kubernetes cluster

00:01:08,479 --> 00:01:13,040
cross button is responsible for managing

00:01:10,320 --> 00:01:15,759
the entire life cycle of these resources

00:01:13,040 --> 00:01:18,159
including update delete create and

00:01:15,759 --> 00:01:18,159
observe

00:01:18,240 --> 00:01:22,400
on the note observing cross plane

00:01:20,320 --> 00:01:23,280
providers expose information about these

00:01:22,400 --> 00:01:25,759
resources

00:01:23,280 --> 00:01:29,759
on an ongoing basis through kubernetes

00:01:25,759 --> 00:01:29,759
fields on the crs as well as events

00:01:30,079 --> 00:01:34,880
so from the cross plane docs we have

00:01:32,560 --> 00:01:36,400
that providers are packages that enable

00:01:34,880 --> 00:01:39,920
crossplane to provision

00:01:36,400 --> 00:01:43,520
infrastructure on an external service

00:01:39,920 --> 00:01:46,000
they bring in crds that map one to one

00:01:43,520 --> 00:01:46,880
with external infrastructure resources

00:01:46,000 --> 00:01:50,880
as well as the

00:01:46,880 --> 00:01:50,880
controllers to manage these resources

00:01:51,200 --> 00:01:55,040
so that's a good definition but what are

00:01:52,880 --> 00:01:57,040
providers really right so essentially

00:01:55,040 --> 00:01:59,280
providers are similar to operators

00:01:57,040 --> 00:02:01,439
but you utilize the cross plane operator

00:01:59,280 --> 00:02:04,399
for installation and management

00:02:01,439 --> 00:02:05,600
uh and later on abstraction uh providers

00:02:04,399 --> 00:02:07,280
use a lot of the same tooling as

00:02:05,600 --> 00:02:09,679
operators such as cube builder

00:02:07,280 --> 00:02:11,599
control runtime controller runtime and

00:02:09,679 --> 00:02:13,440
controller tools

00:02:11,599 --> 00:02:15,200
the main difference though is that

00:02:13,440 --> 00:02:18,239
providers are really designed

00:02:15,200 --> 00:02:19,520
to reference some external resource it's

00:02:18,239 --> 00:02:22,640
responsible for mapping

00:02:19,520 --> 00:02:25,920
one-to-one with some other resource

00:02:22,640 --> 00:02:27,520
and representing that resource well

00:02:25,920 --> 00:02:28,959
so for a developer the really nice thing

00:02:27,520 --> 00:02:30,959
about providers is that you don't have

00:02:28,959 --> 00:02:32,959
to worry about things like our back

00:02:30,959 --> 00:02:34,160
deployment and bootstrapping since

00:02:32,959 --> 00:02:35,920
there's already

00:02:34,160 --> 00:02:37,680
solid tooling that exists to handle

00:02:35,920 --> 00:02:39,920
those

00:02:37,680 --> 00:02:41,120
uh so the where so where are providers

00:02:39,920 --> 00:02:43,120
located

00:02:41,120 --> 00:02:44,400
all crossbend providers are open source

00:02:43,120 --> 00:02:46,720
and available on github

00:02:44,400 --> 00:02:49,840
under usually either the crossplane or

00:02:46,720 --> 00:02:52,080
crosspin control organizations

00:02:49,840 --> 00:02:53,920
examples are the provider sql which

00:02:52,080 --> 00:02:54,560
orchestrates sql servers by creating

00:02:53,920 --> 00:02:58,080
users

00:02:54,560 --> 00:02:58,640
grants and roles the provider helm is

00:02:58,080 --> 00:03:00,800
similar

00:02:58,640 --> 00:03:02,959
so that lets you manage and deploy helm

00:03:00,800 --> 00:03:06,480
charts using custom resources

00:03:02,959 --> 00:03:07,920
namely a release resource lastly the

00:03:06,480 --> 00:03:09,519
provider aws

00:03:07,920 --> 00:03:11,040
is responsible for provisioning

00:03:09,519 --> 00:03:14,239
resources on aws

00:03:11,040 --> 00:03:17,440
such as databases on rds or even

00:03:14,239 --> 00:03:19,440
kubernetes clusters using eks and it's

00:03:17,440 --> 00:03:22,319
really responsible for

00:03:19,440 --> 00:03:25,200
representing those infrastructure

00:03:22,319 --> 00:03:27,840
resources on aws

00:03:25,200 --> 00:03:29,040
so the when so when does it make sense

00:03:27,840 --> 00:03:32,000
to create a provider

00:03:29,040 --> 00:03:33,760
well as i mentioned providers are

00:03:32,000 --> 00:03:36,239
designed to interface with some

00:03:33,760 --> 00:03:38,720
external api and manage the crud

00:03:36,239 --> 00:03:40,560
lifecycle for those resources

00:03:38,720 --> 00:03:42,159
so the focus then is really on high

00:03:40,560 --> 00:03:44,080
fidelity resources

00:03:42,159 --> 00:03:46,159
right if you have some external

00:03:44,080 --> 00:03:48,720
resources that you can represent

00:03:46,159 --> 00:03:50,799
with high fidelity on a granular level

00:03:48,720 --> 00:03:51,920
it makes sense to create a provider

00:03:50,799 --> 00:03:53,680
if you're looking to create your own

00:03:51,920 --> 00:03:55,439
abstractions then you should probably

00:03:53,680 --> 00:03:56,879
opt to use an operator as opposed to a

00:03:55,439 --> 00:03:58,480
provider

00:03:56,879 --> 00:03:59,760
another reason why you might want to use

00:03:58,480 --> 00:04:00,799
a provider is if you want to use

00:03:59,760 --> 00:04:02,640
compositions

00:04:00,799 --> 00:04:04,959
so the so crossplan has a powerful

00:04:02,640 --> 00:04:07,200
composition engine that allows you to

00:04:04,959 --> 00:04:08,239
combine several resources and the best

00:04:07,200 --> 00:04:10,239
way right now

00:04:08,239 --> 00:04:13,360
to utilize this is to create a provider

00:04:10,239 --> 00:04:15,599
that manages your resources

00:04:13,360 --> 00:04:17,280
so why uh why should you creator

00:04:15,599 --> 00:04:20,560
contribute to provider

00:04:17,280 --> 00:04:22,479
uh crosspin is a cncf sandbox project

00:04:20,560 --> 00:04:24,080
hopefully soon will be incubating and

00:04:22,479 --> 00:04:26,080
many of the providers are open source

00:04:24,080 --> 00:04:27,919
and anybody can contribute

00:04:26,080 --> 00:04:30,400
their shared development and maintenance

00:04:27,919 --> 00:04:32,320
of common resources

00:04:30,400 --> 00:04:33,919
every organization shouldn't have to

00:04:32,320 --> 00:04:34,800
write their own version of the provider

00:04:33,919 --> 00:04:36,720
aws

00:04:34,800 --> 00:04:38,800
we should be able to all contribute as a

00:04:36,720 --> 00:04:40,800
community to one project that we can all

00:04:38,800 --> 00:04:43,199
benefit from

00:04:40,800 --> 00:04:45,520
cloud vendors can also expose their apis

00:04:43,199 --> 00:04:48,720
in kubernetes through a common interface

00:04:45,520 --> 00:04:50,479
of a cross plane provider

00:04:48,720 --> 00:04:52,320
and lastly you should contribute or

00:04:50,479 --> 00:04:53,919
create a provider

00:04:52,320 --> 00:04:55,840
because of the streamlined development

00:04:53,919 --> 00:04:56,639
and consumption process as i mentioned

00:04:55,840 --> 00:04:58,560
before

00:04:56,639 --> 00:05:01,440
crossfit helps a lot by handling a lot

00:04:58,560 --> 00:05:03,680
of the messy parts

00:05:01,440 --> 00:05:05,440
so who who is really creating and

00:05:03,680 --> 00:05:07,039
maintaining these providers today

00:05:05,440 --> 00:05:09,280
well there's three main groups from my

00:05:07,039 --> 00:05:12,479
perspective there's the community

00:05:09,280 --> 00:05:14,400
organizations and vendors so from the

00:05:12,479 --> 00:05:16,080
vendor side there's engineers from

00:05:14,400 --> 00:05:19,039
organizations like alibaba

00:05:16,080 --> 00:05:20,400
ibm aws and equinix that contribute to

00:05:19,039 --> 00:05:22,240
the development of their respective

00:05:20,400 --> 00:05:24,400
providers

00:05:22,240 --> 00:05:25,600
there's also contributors and engineers

00:05:24,400 --> 00:05:28,160
from organizations like

00:05:25,600 --> 00:05:29,600
upbound red hat squiz and accenture that

00:05:28,160 --> 00:05:31,759
are contributing to the active

00:05:29,600 --> 00:05:34,240
development and maintenance of providers

00:05:31,759 --> 00:05:35,840
and lastly with any open source project

00:05:34,240 --> 00:05:37,840
there's a lot of developers

00:05:35,840 --> 00:05:39,680
in the open source community who

00:05:37,840 --> 00:05:42,960
contribute code back to providers and

00:05:39,680 --> 00:05:42,960
the main crossplane project

00:05:43,039 --> 00:05:47,680
so let's get to the interesting part how

00:05:45,680 --> 00:05:49,680
how can we create a crossplan provider

00:05:47,680 --> 00:05:51,440
well the best way right now is to use

00:05:49,680 --> 00:05:52,800
the provider template

00:05:51,440 --> 00:05:54,479
which is a template that helps you

00:05:52,800 --> 00:05:56,240
bootstrap your development and it

00:05:54,479 --> 00:05:59,440
exposes some sample resources and the

00:05:56,240 --> 00:06:01,360
basic structure of a controller

00:05:59,440 --> 00:06:02,720
so the best way right now is to hit the

00:06:01,360 --> 00:06:04,800
little green button that you see

00:06:02,720 --> 00:06:06,240
called use this template and that'll

00:06:04,800 --> 00:06:07,759
take you to this screen

00:06:06,240 --> 00:06:09,440
which allows you to define the

00:06:07,759 --> 00:06:12,960
repository name and owner

00:06:09,440 --> 00:06:14,720
for your provider uh and just like that

00:06:12,960 --> 00:06:17,360
you have your provider

00:06:14,720 --> 00:06:18,560
and so now we're gonna go through a

00:06:17,360 --> 00:06:20,560
little bit more in depth

00:06:18,560 --> 00:06:21,840
into the provider in cluster that we

00:06:20,560 --> 00:06:25,039
just created

00:06:21,840 --> 00:06:25,680
uh followed by a live coding demo of us

00:06:25,039 --> 00:06:27,759
creating

00:06:25,680 --> 00:06:30,400
a redis managed resource in the provider

00:06:27,759 --> 00:06:30,400
written cluster

00:06:31,120 --> 00:06:34,639
so this is our freshly created and

00:06:33,440 --> 00:06:37,520
cloned version

00:06:34,639 --> 00:06:38,639
of the provider in cluster based on the

00:06:37,520 --> 00:06:41,440
current structure

00:06:38,639 --> 00:06:42,800
of the provider template so let's dig a

00:06:41,440 --> 00:06:43,680
little deeper into the various

00:06:42,800 --> 00:06:46,160
components

00:06:43,680 --> 00:06:47,280
of the provider and cluster and break

00:06:46,160 --> 00:06:50,639
down what they mean

00:06:47,280 --> 00:06:52,560
and and how they affect our development

00:06:50,639 --> 00:06:55,120
so from the top down let's take a look

00:06:52,560 --> 00:06:58,400
at the apis folder first

00:06:55,120 --> 00:07:01,120
the api folder contains first

00:06:58,400 --> 00:07:03,360
the generate.go file which describes the

00:07:01,120 --> 00:07:06,400
workflow for how we generate

00:07:03,360 --> 00:07:10,240
crds along with

00:07:06,400 --> 00:07:12,560
necessary files for kubernetes and

00:07:10,240 --> 00:07:16,400
crossplane

00:07:12,560 --> 00:07:19,199
the template.go is similar it describes

00:07:16,400 --> 00:07:20,000
uh all of the schemes which we want to

00:07:19,199 --> 00:07:23,440
add

00:07:20,000 --> 00:07:26,639
uh into our

00:07:23,440 --> 00:07:29,120
kubernetes runtime so in this example

00:07:26,639 --> 00:07:30,000
we have two schemes here first there's

00:07:29,120 --> 00:07:33,440
template v1

00:07:30,000 --> 00:07:35,360
alpha 1 and sample v1 alpha 1.

00:07:33,440 --> 00:07:37,759
so let's take a look at sample v1 alpha

00:07:35,360 --> 00:07:40,479
1. so within the sample folder there is

00:07:37,759 --> 00:07:43,039
another subfolder called view on alpha1

00:07:40,479 --> 00:07:44,560
and this contains a doc.go file which

00:07:43,039 --> 00:07:47,759
specifies the group name

00:07:44,560 --> 00:07:52,080
and version name for this api group

00:07:47,759 --> 00:07:55,360
within this we describe our uh

00:07:52,080 --> 00:07:58,319
we describe our sample resource which

00:07:55,360 --> 00:07:59,840
which is described in the types.go file

00:07:58,319 --> 00:08:02,240
the name of this file doesn't matter

00:07:59,840 --> 00:08:04,160
but more importantly it's important that

00:08:02,240 --> 00:08:06,879
we have the necessary annotations

00:08:04,160 --> 00:08:08,400
as well as the structs with our type

00:08:06,879 --> 00:08:11,199
meta and object meta

00:08:08,400 --> 00:08:13,680
this is the actual api api type that

00:08:11,199 --> 00:08:15,680
this provider exposes

00:08:13,680 --> 00:08:16,960
there's other generated files here along

00:08:15,680 --> 00:08:19,280
with the register.go

00:08:16,960 --> 00:08:20,160
which describes the type metadata as

00:08:19,280 --> 00:08:24,160
well as

00:08:20,160 --> 00:08:24,160
the initial scheme builder registration

00:08:24,800 --> 00:08:27,919
next up let's take a look at the command

00:08:26,720 --> 00:08:29,759
directory

00:08:27,919 --> 00:08:32,479
this is the main dot go file that's

00:08:29,759 --> 00:08:35,919
actually run inside of our docker image

00:08:32,479 --> 00:08:39,360
when the provider is created

00:08:35,919 --> 00:08:41,680
this includes uh all of the command line

00:08:39,360 --> 00:08:42,800
argument parsing as well as the initial

00:08:41,680 --> 00:08:46,160
setup

00:08:42,800 --> 00:08:49,360
so here we can see we initially run

00:08:46,160 --> 00:08:50,720
uh our apis when we add them all to the

00:08:49,360 --> 00:08:53,040
scheme

00:08:50,720 --> 00:08:55,760
and we also set up all of our

00:08:53,040 --> 00:08:57,920
controllers

00:08:55,760 --> 00:09:00,320
aside from that in here we describe our

00:08:57,920 --> 00:09:03,839
manager as well as

00:09:00,320 --> 00:09:04,480
the signal handler within the example

00:09:03,839 --> 00:09:06,959
directory

00:09:04,480 --> 00:09:09,600
we have examples of the different custom

00:09:06,959 --> 00:09:11,360
resources that our provider exposes

00:09:09,600 --> 00:09:13,120
this is a good practice because new

00:09:11,360 --> 00:09:14,640
users can then see

00:09:13,120 --> 00:09:18,320
what the different resources are as well

00:09:14,640 --> 00:09:18,320
as examples that they can run directly

00:09:19,760 --> 00:09:24,240
within the internal directory we're able

00:09:21,920 --> 00:09:27,680
to see the different controllers

00:09:24,240 --> 00:09:30,080
for our provider under some projects

00:09:27,680 --> 00:09:31,680
you may see that instead of internal

00:09:30,080 --> 00:09:34,959
this folder is called

00:09:31,680 --> 00:09:35,600
pkg for package but in the provider

00:09:34,959 --> 00:09:38,399
template

00:09:35,600 --> 00:09:39,360
it's currently referred to as internal

00:09:38,399 --> 00:09:42,800
so within this

00:09:39,360 --> 00:09:45,040
we have our template.go file which

00:09:42,800 --> 00:09:46,480
contains the main setup function for all

00:09:45,040 --> 00:09:48,800
of our controllers

00:09:46,480 --> 00:09:49,920
so for example we iterate over our

00:09:48,800 --> 00:09:52,480
config

00:09:49,920 --> 00:09:53,360
setup function and our my type setup

00:09:52,480 --> 00:09:55,279
function

00:09:53,360 --> 00:09:57,839
so this sets up both controllers as i

00:09:55,279 --> 00:10:00,080
previously mentioned

00:09:57,839 --> 00:10:02,079
within let's say the config one for

00:10:00,080 --> 00:10:04,800
example we'll see the setup function

00:10:02,079 --> 00:10:06,800
which describes how we initialize the

00:10:04,800 --> 00:10:08,000
controller that reconciles provider

00:10:06,800 --> 00:10:11,040
configs

00:10:08,000 --> 00:10:11,519
uh and so in this example there isn't

00:10:11,040 --> 00:10:14,959
much

00:10:11,519 --> 00:10:17,920
but if we take a look at uh my my type

00:10:14,959 --> 00:10:19,040
uh we'll see there is a setup function

00:10:17,920 --> 00:10:22,240
as well as

00:10:19,040 --> 00:10:25,279
a connector which describes how

00:10:22,240 --> 00:10:29,040
we produce an external client when we

00:10:25,279 --> 00:10:29,040
initially want to set up this controller

00:10:29,279 --> 00:10:32,640
and additionally we have our external

00:10:31,760 --> 00:10:36,240
struct

00:10:32,640 --> 00:10:37,040
which has the create update and delete

00:10:36,240 --> 00:10:40,160
methods

00:10:37,040 --> 00:10:42,399
uh for our external resource

00:10:40,160 --> 00:10:43,200
and the observe method is responsible

00:10:42,399 --> 00:10:45,120
for

00:10:43,200 --> 00:10:46,320
seeing the or examining the current

00:10:45,120 --> 00:10:49,200
state of our

00:10:46,320 --> 00:10:49,200
managed resource

00:10:50,560 --> 00:10:54,240
the observe function returns a managed

00:10:52,800 --> 00:10:55,600
to external observation

00:10:54,240 --> 00:10:57,519
which contains references if the

00:10:55,600 --> 00:10:59,680
resource exists if it's up to date

00:10:57,519 --> 00:11:00,880
as well as connection details this is

00:10:59,680 --> 00:11:02,800
vital because

00:11:00,880 --> 00:11:04,560
if at any point a resource no longer

00:11:02,800 --> 00:11:06,480
exists or it isn't up to date

00:11:04,560 --> 00:11:08,800
we'll run the create or update process

00:11:06,480 --> 00:11:12,240
as needed

00:11:08,800 --> 00:11:14,560
so for example for create we'll see that

00:11:12,240 --> 00:11:16,640
it creates our resource and returns

00:11:14,560 --> 00:11:18,720
successfully without an error if the if

00:11:16,640 --> 00:11:21,279
the resource was created

00:11:18,720 --> 00:11:23,200
uh the same goes for update and delete

00:11:21,279 --> 00:11:24,079
uh when a resource is deleted we'll call

00:11:23,200 --> 00:11:27,680
delete

00:11:24,079 --> 00:11:30,000
and um the reconciler will continue to

00:11:27,680 --> 00:11:32,560
repeat for the managed resource

00:11:30,000 --> 00:11:33,120
until the observe method returns

00:11:32,560 --> 00:11:36,640
resource

00:11:33,120 --> 00:11:38,560
exists equals false there's also a my

00:11:36,640 --> 00:11:41,360
type underscore test file which contains

00:11:38,560 --> 00:11:43,519
all of our tests for the observe

00:11:41,360 --> 00:11:45,920
connect create update and delete

00:11:43,519 --> 00:11:45,920
functions

00:11:47,440 --> 00:11:51,760
next up we have the package directory

00:11:49,360 --> 00:11:55,360
which contains our

00:11:51,760 --> 00:11:57,600
crds that our provider exposes so

00:11:55,360 --> 00:11:58,399
in this example there's not many crds

00:11:57,600 --> 00:12:00,720
but in

00:11:58,399 --> 00:12:01,839
another provider such as the aws

00:12:00,720 --> 00:12:03,360
provider that has

00:12:01,839 --> 00:12:05,680
dozens of resources you'll see quite a

00:12:03,360 --> 00:12:07,279
few crds here

00:12:05,680 --> 00:12:09,360
so that's all the main files that you

00:12:07,279 --> 00:12:11,519
really need to look at as a developer

00:12:09,360 --> 00:12:14,000
everything else is handled opaquely by

00:12:11,519 --> 00:12:15,279
crossplane for you

00:12:14,000 --> 00:12:17,680
and it's really that simple to get

00:12:15,279 --> 00:12:17,680
started

00:12:18,079 --> 00:12:22,000
in the first part of this talk we

00:12:19,760 --> 00:12:24,240
explored what crossplan providers are

00:12:22,000 --> 00:12:25,839
as well as when it makes sense to create

00:12:24,240 --> 00:12:28,959
a provider

00:12:25,839 --> 00:12:30,399
and how to actually create a provider in

00:12:28,959 --> 00:12:31,680
this part of the talk we're going to go

00:12:30,399 --> 00:12:34,000
through the process of actually

00:12:31,680 --> 00:12:35,920
defining a new managed resource for the

00:12:34,000 --> 00:12:37,760
provider and cluster

00:12:35,920 --> 00:12:39,760
at a high level the goal of the provider

00:12:37,760 --> 00:12:42,959
in cluster is to define

00:12:39,760 --> 00:12:43,839
resources in cluster that follow the

00:12:42,959 --> 00:12:46,399
same interface

00:12:43,839 --> 00:12:47,600
as other cross pin providers such as the

00:12:46,399 --> 00:12:50,959
provider aws

00:12:47,600 --> 00:12:52,399
gcp and azure so the first part of

00:12:50,959 --> 00:12:54,160
creating a new manage resource is

00:12:52,399 --> 00:12:56,240
defining the api

00:12:54,160 --> 00:12:57,760
we do this inside of the api's directory

00:12:56,240 --> 00:12:58,639
more specifically we're going to create

00:12:57,760 --> 00:13:02,079
a new

00:12:58,639 --> 00:13:02,639
folder for cache v1 alpha 1. inside of

00:13:02,079 --> 00:13:05,200
this

00:13:02,639 --> 00:13:08,320
we define a doc.go file which contains

00:13:05,200 --> 00:13:08,320
the group name which is

00:13:08,440 --> 00:13:11,040
cache.incluster.crossplain.io

00:13:09,600 --> 00:13:12,800
as well as the version which is the one

00:13:11,040 --> 00:13:14,399
alpha one

00:13:12,800 --> 00:13:16,639
we're also going to scaffold out an

00:13:14,399 --> 00:13:20,639
empty resource for redis

00:13:16,639 --> 00:13:22,000
which contains a spec and status struct

00:13:20,639 --> 00:13:23,120
at this point this is all empty but

00:13:22,000 --> 00:13:24,720
we're going to come back to this in a

00:13:23,120 --> 00:13:26,000
minute

00:13:24,720 --> 00:13:28,399
next up we're going to define our

00:13:26,000 --> 00:13:30,079
register.go function which defines all

00:13:28,399 --> 00:13:32,880
of our type metadata

00:13:30,079 --> 00:13:34,800
and it also has an init function which

00:13:32,880 --> 00:13:37,600
registers this resource our redis

00:13:34,800 --> 00:13:39,120
resource with the scheme builder

00:13:37,600 --> 00:13:40,800
this allows us to run our code

00:13:39,120 --> 00:13:43,199
generation which

00:13:40,800 --> 00:13:45,839
creates our deep copy managed and

00:13:43,199 --> 00:13:45,839
managed list

00:13:46,480 --> 00:13:52,320
files and so these are used internally

00:13:48,880 --> 00:13:54,240
by kubernetes and crossplane

00:13:52,320 --> 00:13:55,440
when we run our code generation it also

00:13:54,240 --> 00:13:58,639
creates our crd

00:13:55,440 --> 00:14:00,560
for the redis resource at this point

00:13:58,639 --> 00:14:02,320
there's something exciting here but as

00:14:00,560 --> 00:14:03,519
we build this out slowly this will get

00:14:02,320 --> 00:14:05,839
filled in with all of our different

00:14:03,519 --> 00:14:08,639
fields

00:14:05,839 --> 00:14:10,720
uh now let's actually build our uh

00:14:08,639 --> 00:14:13,120
controller out a little bit

00:14:10,720 --> 00:14:14,880
so at this point our controller doesn't

00:14:13,120 --> 00:14:18,079
really have any logic yet

00:14:14,880 --> 00:14:18,880
but we've set it up within this regis.go

00:14:18,079 --> 00:14:21,680
file

00:14:18,880 --> 00:14:22,399
and we can see that we have a connector

00:14:21,680 --> 00:14:24,880
struct here

00:14:22,399 --> 00:14:26,560
which describes how we connect to

00:14:24,880 --> 00:14:29,279
whatever api we're using

00:14:26,560 --> 00:14:30,000
in our case we're just connecting to the

00:14:29,279 --> 00:14:33,120
kubernetes

00:14:30,000 --> 00:14:35,760
api server and we also define

00:14:33,120 --> 00:14:37,199
our reconciler which has all of our crud

00:14:35,760 --> 00:14:41,120
operations such as

00:14:37,199 --> 00:14:43,519
observe create update and delete

00:14:41,120 --> 00:14:45,519
at this point we can also add the

00:14:43,519 --> 00:14:48,480
controller to the setup function

00:14:45,519 --> 00:14:50,480
and what this does is it sets up or

00:14:48,480 --> 00:14:54,800
creates all the controllers

00:14:50,480 --> 00:14:56,720
with the loggers and rate limiters when

00:14:54,800 --> 00:14:59,120
the the pod is started for the in

00:14:56,720 --> 00:15:01,040
cluster provider

00:14:59,120 --> 00:15:03,040
next we can start to scaffold out the

00:15:01,040 --> 00:15:04,720
controller so before you actually write

00:15:03,040 --> 00:15:06,880
your logic it's important to define

00:15:04,720 --> 00:15:09,040
you know the different uh functions that

00:15:06,880 --> 00:15:11,120
your client needs to have

00:15:09,040 --> 00:15:12,639
and so in our case our client will have

00:15:11,120 --> 00:15:15,920
a creator update function

00:15:12,639 --> 00:15:17,199
as well as parse input secret and

00:15:15,920 --> 00:15:20,620
two functions for deleting the

00:15:17,199 --> 00:15:23,199
deployment and redis service

00:15:20,620 --> 00:15:24,720
[Music]

00:15:23,199 --> 00:15:26,959
at this point these methods aren't

00:15:24,720 --> 00:15:28,399
defined yet but as we build this out

00:15:26,959 --> 00:15:30,240
we'll slowly see that things come

00:15:28,399 --> 00:15:31,519
together

00:15:30,240 --> 00:15:33,279
we're also going to define four

00:15:31,519 --> 00:15:35,759
functions here for

00:15:33,279 --> 00:15:37,040
creating our kubernetes resources for

00:15:35,759 --> 00:15:42,240
our redis deployment

00:15:37,040 --> 00:15:42,240
containers as well as the service itself

00:15:43,040 --> 00:15:47,120
so now we can head back to the api and

00:15:45,519 --> 00:15:48,399
we can see that we've added a few new

00:15:47,120 --> 00:15:50,560
fields here

00:15:48,399 --> 00:15:52,079
so at this point for simplicity's sake

00:15:50,560 --> 00:15:54,399
we have three fields

00:15:52,079 --> 00:15:56,399
namely password secret ref config

00:15:54,399 --> 00:15:58,240
variables and memory limit

00:15:56,399 --> 00:15:59,920
memory limit states the maximum amount

00:15:58,240 --> 00:16:02,399
of memory that we want to make available

00:15:59,920 --> 00:16:03,360
to the redis pod in our deployment a

00:16:02,399 --> 00:16:05,759
config variable

00:16:03,360 --> 00:16:07,040
allows the users to inject arbitrary

00:16:05,759 --> 00:16:09,279
environment variables

00:16:07,040 --> 00:16:10,399
into the redis instance and lastly

00:16:09,279 --> 00:16:12,959
password secret ref

00:16:10,399 --> 00:16:14,560
references the secret uh which will be

00:16:12,959 --> 00:16:15,759
which will contain the password for our

00:16:14,560 --> 00:16:18,880
redis instance

00:16:15,759 --> 00:16:19,920
uh if no reference is given here then we

00:16:18,880 --> 00:16:23,839
will

00:16:19,920 --> 00:16:26,880
expose redis without a password

00:16:23,839 --> 00:16:26,880
once we define these

00:16:27,040 --> 00:16:30,320
attributes we're going to run our code

00:16:29,360 --> 00:16:32,160
generation again

00:16:30,320 --> 00:16:35,040
and this will update deep copy as well

00:16:32,160 --> 00:16:35,040
as our crt

00:16:35,120 --> 00:16:39,120
now we can actually start the process of

00:16:36,880 --> 00:16:42,160
implementing our client

00:16:39,120 --> 00:16:44,800
so here uh we define

00:16:42,160 --> 00:16:45,519
parse input secret uh as a function

00:16:44,800 --> 00:16:48,320
which

00:16:45,519 --> 00:16:51,040
gets our secret and then extracts the

00:16:48,320 --> 00:16:54,000
password data from it

00:16:51,040 --> 00:16:54,320
delete redis deployment just validates

00:16:54,000 --> 00:16:55,680
that

00:16:54,320 --> 00:16:57,440
the deployment exists and then it

00:16:55,680 --> 00:16:58,560
deletes it the same thing exists the

00:16:57,440 --> 00:17:02,240
same thing happens for

00:16:58,560 --> 00:17:02,240
our delete redis service function

00:17:02,959 --> 00:17:06,720
next up uh inside of our insider make

00:17:05,679 --> 00:17:09,520
redis deployment

00:17:06,720 --> 00:17:10,319
we define our apps v1 deployment

00:17:09,520 --> 00:17:12,720
resource

00:17:10,319 --> 00:17:15,039
which contains the object meta and spec

00:17:12,720 --> 00:17:16,720
for our deployment

00:17:15,039 --> 00:17:19,120
the containers are defined in another

00:17:16,720 --> 00:17:20,799
function down below

00:17:19,120 --> 00:17:22,480
which first sets up all of our

00:17:20,799 --> 00:17:26,319
environment variables

00:17:22,480 --> 00:17:30,000
as well as our memory limit and then

00:17:26,319 --> 00:17:32,640
we define the pod as a having container

00:17:30,000 --> 00:17:33,919
which contains the bitnami redis image

00:17:32,640 --> 00:17:36,559
uh as well as

00:17:33,919 --> 00:17:37,400
which exp which exposes uh the default

00:17:36,559 --> 00:17:40,640
redis port

00:17:37,400 --> 00:17:42,160
6379 uh with the maximum memory and

00:17:40,640 --> 00:17:43,760
environment variables

00:17:42,160 --> 00:17:46,080
we also have a liveliness pope to

00:17:43,760 --> 00:17:50,080
validate when the

00:17:46,080 --> 00:17:52,160
pod or container is actually started

00:17:50,080 --> 00:17:53,280
with our client defined we can actually

00:17:52,160 --> 00:17:55,120
start the process

00:17:53,280 --> 00:17:56,799
of now building out the controller

00:17:55,120 --> 00:17:58,080
itself

00:17:56,799 --> 00:18:00,880
and so here we can see that we've

00:17:58,080 --> 00:18:04,480
defined our connector function as

00:18:00,880 --> 00:18:06,559
extracting the provider config reference

00:18:04,480 --> 00:18:08,000
getting the cube config from there and

00:18:06,559 --> 00:18:11,600
creating a new client

00:18:08,000 --> 00:18:13,760
with that specific cube config

00:18:11,600 --> 00:18:14,880
our reconciler then has a reference to

00:18:13,760 --> 00:18:17,520
the redis client

00:18:14,880 --> 00:18:18,480
and it's responsible for observing the

00:18:17,520 --> 00:18:20,960
current state

00:18:18,480 --> 00:18:22,880
of our managed resource so namely we

00:18:20,960 --> 00:18:25,200
check if the deployment exists

00:18:22,880 --> 00:18:27,440
if the deployment is ready if it's

00:18:25,200 --> 00:18:28,720
currently in the progress of scaling up

00:18:27,440 --> 00:18:30,720
and we also validate if the service

00:18:28,720 --> 00:18:32,400
exists and if any of these resources

00:18:30,720 --> 00:18:35,679
don't exist

00:18:32,400 --> 00:18:37,360
the controller will fail and and it'll

00:18:35,679 --> 00:18:39,760
get put back in the retry loop for our

00:18:37,360 --> 00:18:42,000
reconciler

00:18:39,760 --> 00:18:43,679
if everything exists and it looks good

00:18:42,000 --> 00:18:46,160
we'll return successfully that the

00:18:43,679 --> 00:18:48,720
resource exists and it's up to date

00:18:46,160 --> 00:18:50,240
we'll also expose the ip address of

00:18:48,720 --> 00:18:52,559
redis

00:18:50,240 --> 00:18:54,480
at a specific key in our secret namely

00:18:52,559 --> 00:18:57,679
the endpoint key

00:18:54,480 --> 00:18:58,799
the create function actually runs the

00:18:57,679 --> 00:19:01,280
process of

00:18:58,799 --> 00:19:02,240
creating our redis instance so this

00:19:01,280 --> 00:19:04,400
means

00:19:02,240 --> 00:19:06,320
deploying the deployment and service

00:19:04,400 --> 00:19:09,120
resources

00:19:06,320 --> 00:19:11,600
at the end once everything is created in

00:19:09,120 --> 00:19:14,080
our secret we will expose the port

00:19:11,600 --> 00:19:14,919
and password so in our case the port is

00:19:14,080 --> 00:19:17,520
always

00:19:14,919 --> 00:19:20,080
6379 and the password depends on the

00:19:17,520 --> 00:19:23,039
input secret if it exists

00:19:20,080 --> 00:19:24,000
uh update in in the redis resource at

00:19:23,039 --> 00:19:26,640
this point is a no

00:19:24,000 --> 00:19:29,200
up and delete simply just deletes the

00:19:26,640 --> 00:19:31,520
deployment in the service

00:19:29,200 --> 00:19:32,400
so with that our managed resource is

00:19:31,520 --> 00:19:35,360
implemented

00:19:32,400 --> 00:19:36,559
and we can define some examples in the

00:19:35,360 --> 00:19:39,679
examples cache

00:19:36,559 --> 00:19:41,520
folder and so this will have our

00:19:39,679 --> 00:19:43,360
sample readiness resource with the

00:19:41,520 --> 00:19:44,799
password reference as well as our

00:19:43,360 --> 00:19:47,039
provider config

00:19:44,799 --> 00:19:48,880
so just like that it was that easy to

00:19:47,039 --> 00:19:50,720
create a managed resource

00:19:48,880 --> 00:19:52,799
all in all this process took me about an

00:19:50,720 --> 00:19:56,160
hour or less than an hour

00:19:52,799 --> 00:19:57,280
and we have a v1 alpha 1 release of red

00:19:56,160 --> 00:19:59,440
sn cluster

00:19:57,280 --> 00:20:00,799
so we can add some additional features

00:19:59,440 --> 00:20:02,720
there's still quite a bit of work to do

00:20:00,799 --> 00:20:05,280
such as a redis cluster

00:20:02,720 --> 00:20:06,640
or additional testing for redis because

00:20:05,280 --> 00:20:07,760
at this point we haven't written any

00:20:06,640 --> 00:20:09,679
tests

00:20:07,760 --> 00:20:11,919
but we have enough now where somebody

00:20:09,679 --> 00:20:14,960
can you know provision redis and cluster

00:20:11,919 --> 00:20:16,799
using this provider so that concludes

00:20:14,960 --> 00:20:18,480
this presentation

00:20:16,799 --> 00:20:20,640
thank you for watching and if you have

00:20:18,480 --> 00:20:21,440
any questions feel free to ping me on

00:20:20,640 --> 00:20:24,480
slack

00:20:21,440 --> 00:20:26,159
or add me on any of their socials my

00:20:24,480 --> 00:20:28,240
linkedin is chris ciao

00:20:26,159 --> 00:20:30,799
which is the same as my github and my my

00:20:28,240 --> 00:20:33,039
twitter is chris chow underscore

00:20:30,799 --> 00:20:35,840
thank you for your time and uh have a

00:20:33,039 --> 00:20:35,840

YouTube URL: https://www.youtube.com/watch?v=dhuqH308Tc0


