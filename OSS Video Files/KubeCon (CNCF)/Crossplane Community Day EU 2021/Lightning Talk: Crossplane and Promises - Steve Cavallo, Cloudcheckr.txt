Title: Lightning Talk: Crossplane and Promises - Steve Cavallo, Cloudcheckr
Publication date: 2021-05-04
Playlist: Crossplane Community Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Lightning Talk: Crossplane and Promises - Steve Cavallo, Cloudcheckr

Configuration management has become virtually standard in every industry. As we have moved to infrastructure as code, and most recently serverless, the tools have changed but many of the principals for governing systems have remained the same. In this presentation I will talk about the Promise theory and how it applies to several of the most popular infrastructure-as-code solutions - Crossplane, terraform, cloudformation. https://www.linuxjournal.com/content/promise-theory%E2%80%94what-it Most notably, how Crossplane keeps promises and how this is fundamentally different than other existing toolsets, to quote Mark Burgess, "by shifting the attention away from what changes (or which algorithms to enact), onto what interfaces exist between components and what promises they keep and why." The approaches to describing systems will have different output and challenges when applied at scale.
Captions: 
	00:00:00,240 --> 00:00:05,920
hi i'm steve cavallo and i'm going to

00:00:02,320 --> 00:00:07,440
talk about cross plane and promises

00:00:05,920 --> 00:00:09,599
promise theory is a way we can think

00:00:07,440 --> 00:00:11,200
about interactions between agents within

00:00:09,599 --> 00:00:13,679
a system

00:00:11,200 --> 00:00:14,240
in promise theory we say get into the

00:00:13,679 --> 00:00:16,800
state

00:00:14,240 --> 00:00:18,480
instead of do this we're familiar with

00:00:16,800 --> 00:00:20,640
working the promise theory way

00:00:18,480 --> 00:00:22,080
maybe from using chef and puppet and

00:00:20,640 --> 00:00:25,599
other config management tools

00:00:22,080 --> 00:00:28,240
or most likely from using kubernetes

00:00:25,599 --> 00:00:30,240
in kubernetes we define and think in

00:00:28,240 --> 00:00:32,239
terms of end state

00:00:30,240 --> 00:00:33,440
in kubernetes you don't write a stateful

00:00:32,239 --> 00:00:35,600
set script

00:00:33,440 --> 00:00:36,559
you define and apply a stateful set

00:00:35,600 --> 00:00:38,640
manifest

00:00:36,559 --> 00:00:42,160
and kubernetes promises to attempt to

00:00:38,640 --> 00:00:44,719
get into your desired state

00:00:42,160 --> 00:00:46,559
kubernetes uses a very literal

00:00:44,719 --> 00:00:48,239
implementation of promise theory

00:00:46,559 --> 00:00:52,480
and many benefits can be realized at

00:00:48,239 --> 00:00:52,480
scale when promise theory is applied

00:00:52,800 --> 00:00:56,239
it's also best if we can break things up

00:00:54,719 --> 00:00:59,840
into small sets of primitives which can

00:00:56,239 --> 00:00:59,840
be applied independently

00:01:02,000 --> 00:01:06,080
how does it all stack up and how can we

00:01:04,239 --> 00:01:08,400
apply promise theory to some existing

00:01:06,080 --> 00:01:08,400
tools

00:01:08,560 --> 00:01:13,040
in terraform we define our model in hcl

00:01:11,439 --> 00:01:13,840
but the challenge in terms of promise

00:01:13,040 --> 00:01:15,920
theory is

00:01:13,840 --> 00:01:18,080
we don't know exactly what our model is

00:01:15,920 --> 00:01:19,200
until we run a plan or apply to generate

00:01:18,080 --> 00:01:22,960
it

00:01:19,200 --> 00:01:22,960
until then it's not a true promise

00:01:23,439 --> 00:01:26,479
in our first example we're creating a

00:01:26,080 --> 00:01:28,960
spot

00:01:26,479 --> 00:01:30,240
instance but we don't know what it will

00:01:28,960 --> 00:01:34,079
evaluate to

00:01:30,240 --> 00:01:36,320
until runtime and in fact we don't know

00:01:34,079 --> 00:01:37,280
what it will evaluate to in multiple

00:01:36,320 --> 00:01:41,200
different environments

00:01:37,280 --> 00:01:43,439
until runtime in our second example

00:01:41,200 --> 00:01:46,880
we didn't know that this terraform apply

00:01:43,439 --> 00:01:46,880
would destroy our resource

00:01:48,159 --> 00:01:55,840
any human invention required makes it

00:01:50,479 --> 00:01:55,840
difficult to support at scale

00:01:57,680 --> 00:02:01,520
with terraform there's also no control

00:01:59,520 --> 00:02:04,079
plane

00:02:01,520 --> 00:02:04,719
so there's no guarantee of system state

00:02:04,079 --> 00:02:07,759
and

00:02:04,719 --> 00:02:11,360
we have no way of knowing whether our

00:02:07,759 --> 00:02:12,959
existing promises are being kept

00:02:11,360 --> 00:02:14,640
where terraform is great though is

00:02:12,959 --> 00:02:15,920
determining what changes to enact to

00:02:14,640 --> 00:02:20,560
bring a system into the

00:02:15,920 --> 00:02:23,920
desired state however at scale

00:02:20,560 --> 00:02:25,760
managing anything is procedural

00:02:23,920 --> 00:02:27,120
and when terraform must be run in a

00:02:25,760 --> 00:02:30,239
specific order

00:02:27,120 --> 00:02:33,360
or has specific dependencies

00:02:30,239 --> 00:02:36,239
it gets very difficult to manage

00:02:33,360 --> 00:02:37,760
taking my previous examples if a human

00:02:36,239 --> 00:02:41,440
has to intervene

00:02:37,760 --> 00:02:43,519
to see if any resources will be changed

00:02:41,440 --> 00:02:44,720
as part of a deploy it gets very

00:02:43,519 --> 00:02:50,160
difficult to

00:02:44,720 --> 00:02:53,280
to maintain its skill

00:02:50,160 --> 00:02:57,040
formation allows definition in json yaml

00:02:53,280 --> 00:03:00,640
with very low interpolation it is much

00:02:57,040 --> 00:03:01,840
closer to a promise cloud formation also

00:03:00,640 --> 00:03:05,840
has a control plane

00:03:01,840 --> 00:03:05,840
so control theory can be applied

00:03:06,879 --> 00:03:12,400
we have much better idea of what the

00:03:09,280 --> 00:03:12,400
state of our system is

00:03:14,000 --> 00:03:17,860
so at scale with cloud formation we get

00:03:16,239 --> 00:03:19,440
high predictability of outcome

00:03:17,860 --> 00:03:22,640
[Music]

00:03:19,440 --> 00:03:24,799
we have a better model of our end states

00:03:22,640 --> 00:03:26,239
we have a control plane that can

00:03:24,799 --> 00:03:29,760
maintain drift

00:03:26,239 --> 00:03:30,799
in states we still have the challenge

00:03:29,760 --> 00:03:32,640
though when we have

00:03:30,799 --> 00:03:34,400
many cloud formation stacks with

00:03:32,640 --> 00:03:37,519
dependencies and specific orders

00:03:34,400 --> 00:03:37,519
that it becomes imperative

00:03:39,680 --> 00:03:43,840
cross plane allows definition in json

00:03:42,959 --> 00:03:45,599
yaml

00:03:43,840 --> 00:03:47,360
and by nature must be aligned with

00:03:45,599 --> 00:03:48,799
promise theory because it's a kubernetes

00:03:47,360 --> 00:03:50,799
operator

00:03:48,799 --> 00:03:54,159
very very close to the little literal

00:03:50,799 --> 00:03:54,159
interpretation of promise theory

00:03:54,400 --> 00:03:57,519
because it has a controller it can

00:03:56,159 --> 00:04:00,159
maintain our state

00:03:57,519 --> 00:04:01,760
so as you can see my example we have

00:04:00,159 --> 00:04:05,519
controllability

00:04:01,760 --> 00:04:09,040
observability and the controller ensures

00:04:05,519 --> 00:04:09,040
that we're in our expected state

00:04:09,599 --> 00:04:13,760
so at scale crossplane gives us high

00:04:11,599 --> 00:04:16,560
predictability of outcomes

00:04:13,760 --> 00:04:17,600
in fact all of its dependencies are

00:04:16,560 --> 00:04:20,239
promises

00:04:17,600 --> 00:04:22,079
you can see in my example i am role

00:04:20,239 --> 00:04:25,120
policy attachment

00:04:22,079 --> 00:04:28,080
policy r ref is a promise a roll ref

00:04:25,120 --> 00:04:29,120
is a promise we no longer have to worry

00:04:28,080 --> 00:04:31,520
about order

00:04:29,120 --> 00:04:34,960
crossplane will keep retrying until

00:04:31,520 --> 00:04:37,360
those promises are satisfied

00:04:34,960 --> 00:04:42,320
and versioning will allow us to verify

00:04:37,360 --> 00:04:45,840
which promises are deployed

00:04:42,320 --> 00:04:46,639
now in this screenshot i have all of my

00:04:45,840 --> 00:04:49,919
cross plane

00:04:46,639 --> 00:04:52,960
i am rolls inversions and visibilities

00:04:49,919 --> 00:04:53,520
into various environments so using your

00:04:52,960 --> 00:04:57,120
favorites

00:04:53,520 --> 00:04:59,680
flavor of cd you can get visibility into

00:04:57,120 --> 00:05:01,280
what versions of the promises exist and

00:04:59,680 --> 00:05:03,280
whether they're in the promised state or

00:05:01,280 --> 00:05:06,080
not

00:05:03,280 --> 00:05:07,360
in the promise theory we can think of

00:05:06,080 --> 00:05:09,280
many many resources

00:05:07,360 --> 00:05:10,800
each maintaining the promise date and

00:05:09,280 --> 00:05:13,919
trusting all the other

00:05:10,800 --> 00:05:16,080
actors in cooperation in harmony

00:05:13,919 --> 00:05:17,919
so at scale we can see cross planes

00:05:16,080 --> 00:05:20,960
maintaining all of its promises

00:05:17,919 --> 00:05:24,800
across multiple systems

00:05:20,960 --> 00:05:29,520
and much larger systems in conclusion

00:05:24,800 --> 00:05:29,520

YouTube URL: https://www.youtube.com/watch?v=2HaGBEhaz6g


