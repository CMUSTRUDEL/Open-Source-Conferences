Title: Magma a Cloud Native Converged Core, Use Cases and Architecture - Amar Padmanabhan, Facebook Conn...
Publication date: 2021-05-02
Playlist: Magma Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Magma a Cloud Native Converged Core, Use Cases and Architecture - Amar Padmanabhan, Facebook Connectivity

Magma is an open-source, enhanced packet core solution that connects people to a faster internet using LTE, 5G, Wi-Fi, and beyond. Magma brings learnings from the hyper cloud networks to deliver flexibility and openness for the next generation of service providers including MNOs, ISPs, MSOs, and satellite providers. In this talk, we will cover some of these architectural principles and highlight the main use cases for Magma.
Captions: 
	00:00:00,080 --> 00:00:04,160
hi everybody my name is amar padmanabhan

00:00:02,560 --> 00:00:05,040
i'm one of the maintainers on the magma

00:00:04,160 --> 00:00:07,759
project

00:00:05,040 --> 00:00:09,599
today i'm here to talk about magma a

00:00:07,759 --> 00:00:12,000
cloud native converge core

00:00:09,599 --> 00:00:13,599
with a specific emphasis on the use

00:00:12,000 --> 00:00:16,400
cases that we're seeing

00:00:13,599 --> 00:00:19,039
market traction on and its cloud native

00:00:16,400 --> 00:00:19,039
architecture

00:00:20,000 --> 00:00:23,279
first a brief introduction to what is

00:00:22,480 --> 00:00:25,599
magma

00:00:23,279 --> 00:00:28,080
magma is an open source packet core

00:00:25,599 --> 00:00:32,320
that's licensed under a permissive bsd

00:00:28,080 --> 00:00:34,719
v3 license is 3gpp generation agnostic

00:00:32,320 --> 00:00:36,719
in the sense that it can support both 4g

00:00:34,719 --> 00:00:39,040
and 5g architectures

00:00:36,719 --> 00:00:40,480
and its access network agnostic in the

00:00:39,040 --> 00:00:43,520
sense that it can support

00:00:40,480 --> 00:00:44,160
wi-fi deployments as well this can be

00:00:43,520 --> 00:00:46,079
conceived

00:00:44,160 --> 00:00:47,280
as something similar to a mobile data

00:00:46,079 --> 00:00:50,320
offload or a tv

00:00:47,280 --> 00:00:52,640
type architecture where a triple a and a

00:00:50,320 --> 00:00:54,879
pcrf and a pcef

00:00:52,640 --> 00:00:55,920
uh integration exists within the magma

00:00:54,879 --> 00:00:59,039
framework

00:00:55,920 --> 00:00:59,600
the distributed epc itself has a very

00:00:59,039 --> 00:01:02,640
small

00:00:59,600 --> 00:01:03,440
footprint what this allows us to do is

00:01:02,640 --> 00:01:06,479
we can run

00:01:03,440 --> 00:01:08,880
the entire epc all the way

00:01:06,479 --> 00:01:10,240
at the cell site or in slightly more

00:01:08,880 --> 00:01:13,520
centralized locations

00:01:10,240 --> 00:01:17,200
like edge pops or even in

00:01:13,520 --> 00:01:20,479
public clouds the entire deployment

00:01:17,200 --> 00:01:23,680
is managed through a single orchestrator

00:01:20,479 --> 00:01:25,759
this gives a single pane of glass

00:01:23,680 --> 00:01:27,119
that sort of abstracts away the

00:01:25,759 --> 00:01:30,560
distributed nature

00:01:27,119 --> 00:01:32,960
of magma this is what we call as moving

00:01:30,560 --> 00:01:34,880
the network from a device-centric way of

00:01:32,960 --> 00:01:37,040
managing things to a network-centric way

00:01:34,880 --> 00:01:39,840
of managing things

00:01:37,040 --> 00:01:41,360
the interfaces that magma implements our

00:01:39,840 --> 00:01:45,520
standard interfaces

00:01:41,360 --> 00:01:48,799
for example s1 for the 4g

00:01:45,520 --> 00:01:51,439
infrastructure n1n2 n3 for 5g

00:01:48,799 --> 00:01:54,240
infrastructure and standard radius and

00:01:51,439 --> 00:01:56,320
gre termination for wi-fi infrastructure

00:01:54,240 --> 00:01:57,520
this allows the magma core to

00:01:56,320 --> 00:02:01,759
interoperate with

00:01:57,520 --> 00:02:04,560
any ram that is based on standards

00:02:01,759 --> 00:02:05,840
most importantly for this talk at least

00:02:04,560 --> 00:02:09,039
is that magma

00:02:05,840 --> 00:02:11,599
is a scale out sort of a

00:02:09,039 --> 00:02:12,640
packet core as opposed to a scale up uh

00:02:11,599 --> 00:02:14,879
packet core

00:02:12,640 --> 00:02:17,120
and this is fundamental to what makes it

00:02:14,879 --> 00:02:20,239
cloud native

00:02:17,120 --> 00:02:24,319
for brownfield deployments magma

00:02:20,239 --> 00:02:27,760
also exposes rest apis these rest apis

00:02:24,319 --> 00:02:30,560
allow integration into existing

00:02:27,760 --> 00:02:31,840
oss infrastructure as well as a

00:02:30,560 --> 00:02:33,920
federation gateway

00:02:31,840 --> 00:02:34,959
which supports standard diameter

00:02:33,920 --> 00:02:38,080
interfaces

00:02:34,959 --> 00:02:42,480
that allows operators to integrate into

00:02:38,080 --> 00:02:45,760
existing pcrf ocs hss type

00:02:42,480 --> 00:02:45,760
traditional core elements

00:02:46,000 --> 00:02:50,080
so switching gears a little here are the

00:02:48,959 --> 00:02:52,640
following use cases

00:02:50,080 --> 00:02:53,840
that we've been seeing magma market

00:02:52,640 --> 00:02:56,720
traction on

00:02:53,840 --> 00:02:57,120
so primarily uh magma is a really good

00:02:56,720 --> 00:02:59,280
fit

00:02:57,120 --> 00:03:01,120
for fixed wireless access this is where

00:02:59,280 --> 00:03:03,519
we've been seeing commercial deployment

00:03:01,120 --> 00:03:06,480
over the last 12 to 18 months

00:03:03,519 --> 00:03:08,720
the big advantage with uh with magma and

00:03:06,480 --> 00:03:11,680
fixed wireless is because of its small

00:03:08,720 --> 00:03:14,239
form factor uh you can actually deploy

00:03:11,680 --> 00:03:16,440
the access gateway at the sales site

00:03:14,239 --> 00:03:18,239
by doing local breakout and network

00:03:16,440 --> 00:03:21,440
policy application

00:03:18,239 --> 00:03:25,040
at the edge uh we're sort of making

00:03:21,440 --> 00:03:27,920
um the lte deployments

00:03:25,040 --> 00:03:28,560
uh transport network agnostic so you

00:03:27,920 --> 00:03:32,080
know

00:03:28,560 --> 00:03:32,720
gtpc which is s1c is very sensitive to

00:03:32,080 --> 00:03:35,760
jitter

00:03:32,720 --> 00:03:38,959
and a lot of isp and rural deployments

00:03:35,760 --> 00:03:41,360
end up using microwave or

00:03:38,959 --> 00:03:43,599
in or unlicensed spectrum for backhaul

00:03:41,360 --> 00:03:45,440
or even satellite in some cases

00:03:43,599 --> 00:03:47,519
the local breakout aspect of fixed

00:03:45,440 --> 00:03:49,920
wireless allows us to

00:03:47,519 --> 00:03:51,200
terminate all of the s1 signaling and

00:03:49,920 --> 00:03:54,640
then use

00:03:51,200 --> 00:03:58,080
ip as the main transport over

00:03:54,640 --> 00:03:59,519
a unreliable backhoe the second use case

00:03:58,080 --> 00:04:02,080
where we are seeing some traction

00:03:59,519 --> 00:04:04,640
is the wi-fi access use case this is

00:04:02,080 --> 00:04:08,080
similar to a mobile data offload

00:04:04,640 --> 00:04:09,120
model so what this gives you uh that is

00:04:08,080 --> 00:04:11,040
slightly

00:04:09,120 --> 00:04:12,480
that's better than you know traditional

00:04:11,040 --> 00:04:16,160
t-bag type architectures

00:04:12,480 --> 00:04:20,239
is that because magma contains a pcef

00:04:16,160 --> 00:04:21,359
as well the wi-fi or mobile data offload

00:04:20,239 --> 00:04:24,560
traffic

00:04:21,359 --> 00:04:28,479
does not hit your expensive traditional

00:04:24,560 --> 00:04:31,440
p gateway also by using local breakout

00:04:28,479 --> 00:04:32,000
operators have the ability to transit of

00:04:31,440 --> 00:04:34,320
the

00:04:32,000 --> 00:04:36,320
existing infrastructure as early as

00:04:34,320 --> 00:04:38,400
possible

00:04:36,320 --> 00:04:40,000
the use case that we're seeing more

00:04:38,400 --> 00:04:43,040
traction recently

00:04:40,000 --> 00:04:44,400
is the private lte use case this is

00:04:43,040 --> 00:04:47,360
mostly driven by

00:04:44,400 --> 00:04:48,960
the cbrs sort of deployments that are

00:04:47,360 --> 00:04:50,960
happening in the u.s

00:04:48,960 --> 00:04:53,680
i have a specific slide around private

00:04:50,960 --> 00:04:55,680
lt so i'll skip the deep dive for now

00:04:53,680 --> 00:04:57,840
the two use cases that we're looking to

00:04:55,680 --> 00:05:00,400
prioritize uh in age two

00:04:57,840 --> 00:05:00,960
uh for which we're doing a few lab

00:05:00,400 --> 00:05:02,560
trials

00:05:00,960 --> 00:05:04,320
as well as you know hopefully a field

00:05:02,560 --> 00:05:06,960
trial in the july or

00:05:04,320 --> 00:05:07,680
august time frame are around network

00:05:06,960 --> 00:05:11,039
expansion

00:05:07,680 --> 00:05:14,000
and 5g so network expansion allows

00:05:11,039 --> 00:05:14,800
operators to use magma as a way to

00:05:14,000 --> 00:05:19,680
augment

00:05:14,800 --> 00:05:23,440
their traditional or the high high

00:05:19,680 --> 00:05:24,880
high value core networks by using magma

00:05:23,440 --> 00:05:28,479
to extend it into

00:05:24,880 --> 00:05:32,479
more remote and rural areas further

00:05:28,479 --> 00:05:35,840
the insulation that magma provides uh

00:05:32,479 --> 00:05:38,320
to the traditional mmep gateway and

00:05:35,840 --> 00:05:38,880
s gateway allows the operator to

00:05:38,320 --> 00:05:42,000
introduce

00:05:38,880 --> 00:05:44,000
new rams radio elements and

00:05:42,000 --> 00:05:45,440
iterate on on their evolution

00:05:44,000 --> 00:05:49,600
independent of their

00:05:45,440 --> 00:05:52,560
mainstay core on the 5g essay side

00:05:49,600 --> 00:05:54,240
we're looking to leverage magma's

00:05:52,560 --> 00:05:58,240
distributed architecture

00:05:54,240 --> 00:06:01,840
to pilot 5g fixed wireless use cases

00:05:58,240 --> 00:06:06,880
we also support nsa in in alpha form at

00:06:01,840 --> 00:06:09,840
this point

00:06:06,880 --> 00:06:11,199
uh a quick deep dive into magma the

00:06:09,840 --> 00:06:13,440
private solution

00:06:11,199 --> 00:06:14,319
so the big driver for why magma is a

00:06:13,440 --> 00:06:16,800
great fit for

00:06:14,319 --> 00:06:17,840
a private solution is its distributed

00:06:16,800 --> 00:06:20,479
form factor

00:06:17,840 --> 00:06:22,080
the local breakout at the edge allows

00:06:20,479 --> 00:06:24,639
enterprises to deploy

00:06:22,080 --> 00:06:25,600
their own workloads and this is ideal

00:06:24,639 --> 00:06:29,680
for iot

00:06:25,600 --> 00:06:32,479
and you know internet 4.0 type workloads

00:06:29,680 --> 00:06:33,840
magma also allows interconnect to

00:06:32,479 --> 00:06:35,600
existing

00:06:33,840 --> 00:06:38,080
infrastructure or service provider

00:06:35,600 --> 00:06:40,080
networks and this allows

00:06:38,080 --> 00:06:42,479
these sort of private networks to also

00:06:40,080 --> 00:06:44,880
double up as neutral host networks

00:06:42,479 --> 00:06:46,560
the support for multi-tenancy allows a

00:06:44,880 --> 00:06:49,599
single service

00:06:46,560 --> 00:06:52,479
provider or an si to offer service

00:06:49,599 --> 00:06:53,840
offer uh services to multiple

00:06:52,479 --> 00:06:56,479
enterprises

00:06:53,840 --> 00:06:58,560
using the same centralized cloud managed

00:06:56,479 --> 00:07:01,440
infrastructure

00:06:58,560 --> 00:07:03,120
further a big advantage of using magma

00:07:01,440 --> 00:07:05,919
for the private solution

00:07:03,120 --> 00:07:07,520
is that the upgrade from 4g to 5g is

00:07:05,919 --> 00:07:10,560
just a software upgrade

00:07:07,520 --> 00:07:11,440
in fact going forward most magma access

00:07:10,560 --> 00:07:15,840
gateways

00:07:11,440 --> 00:07:20,960
will support both the 4g and sa

00:07:15,840 --> 00:07:24,800
protocols s1 as well as the n interfaces

00:07:20,960 --> 00:07:27,440
lastly the cloud native scale out

00:07:24,800 --> 00:07:29,520
micro form factor where you know magma

00:07:27,440 --> 00:07:30,890
can fit into a box that's even

00:07:29,520 --> 00:07:33,199
just 2vcpu

00:07:30,890 --> 00:07:36,479
[Music]

00:07:33,199 --> 00:07:38,560
sort of very lightweight 2vcpu boxes

00:07:36,479 --> 00:07:40,160
allows magma to be deployed at the

00:07:38,560 --> 00:07:42,639
extreme edges

00:07:40,160 --> 00:07:43,599
and this is particularly useful for you

00:07:42,639 --> 00:07:46,560
know iot

00:07:43,599 --> 00:07:48,080
or like uh fairly remote um sort of use

00:07:46,560 --> 00:07:48,639
cases where you know there are probably

00:07:48,080 --> 00:07:51,759
a couple of

00:07:48,639 --> 00:07:54,800
node b's and you want uh

00:07:51,759 --> 00:07:59,840
a co-located sort of an epc

00:07:54,800 --> 00:07:59,840
in that deployment

00:07:59,919 --> 00:08:03,599
just to re-emphasize the point on the

00:08:02,720 --> 00:08:07,360
form factor

00:08:03,599 --> 00:08:09,280
uh this is a sample uh magma fwa

00:08:07,360 --> 00:08:10,400
bomb from one of our production

00:08:09,280 --> 00:08:13,599
deployments

00:08:10,400 --> 00:08:16,560
as you can see here uh the uh

00:08:13,599 --> 00:08:17,520
the uh the magma infrastructure is

00:08:16,560 --> 00:08:20,879
running on a

00:08:17,520 --> 00:08:24,240
four core atom box uh that's running

00:08:20,879 --> 00:08:27,280
uh a cpu at 2.5 gigahertz

00:08:24,240 --> 00:08:30,800
and with 4gb uh ram

00:08:27,280 --> 00:08:31,919
this box can support up to uh a thousand

00:08:30,800 --> 00:08:35,360
subscribers

00:08:31,919 --> 00:08:38,240
as well as uh you know 12 e note b's

00:08:35,360 --> 00:08:40,080
so depending on your need uh you know

00:08:38,240 --> 00:08:42,640
such a small form factor

00:08:40,080 --> 00:08:44,800
can be a great fit for a fixed wireless

00:08:42,640 --> 00:08:47,279
or a private lte or a 5g

00:08:44,800 --> 00:08:47,279
use case

00:08:50,320 --> 00:08:54,000
quickly a high level overview of the

00:08:53,680 --> 00:08:57,440
road

00:08:54,000 --> 00:08:59,600
map so we're almost at release 1.5

00:08:57,440 --> 00:09:01,680
release 1.5 should be available over the

00:08:59,600 --> 00:09:04,399
next couple of weeks

00:09:01,680 --> 00:09:05,440
the key features in 1.5 are inbound

00:09:04,399 --> 00:09:08,240
roaming

00:09:05,440 --> 00:09:10,080
s1 handover and a bunch of stability and

00:09:08,240 --> 00:09:13,360
usability improvements

00:09:10,080 --> 00:09:16,399
1.6 which we're targeting towards and

00:09:13,360 --> 00:09:20,399
for the end of june uh is going to add

00:09:16,399 --> 00:09:23,440
5g fwa support for sa

00:09:20,399 --> 00:09:25,519
enough to support lab trials as well as

00:09:23,440 --> 00:09:29,279
nsa support

00:09:25,519 --> 00:09:32,399
we're looking to extend the 5g sa

00:09:29,279 --> 00:09:35,440
support in q3 to introduce

00:09:32,399 --> 00:09:36,160
network slicing as a capability as well

00:09:35,440 --> 00:09:39,600
as you know

00:09:36,160 --> 00:09:42,880
harden the 5g fwa offering so

00:09:39,600 --> 00:09:46,720
so for folks who are planning to use uh

00:09:42,880 --> 00:09:49,440
5g essay of magma we'd recommend

00:09:46,720 --> 00:09:51,120
the september release for when you can

00:09:49,440 --> 00:09:54,000
take it out to field

00:09:51,120 --> 00:09:55,200
uh it would be lab ready by uh end of

00:09:54,000 --> 00:09:57,680
june for sure uh

00:09:55,200 --> 00:09:59,760
but for all the robustness improvements

00:09:57,680 --> 00:10:02,240
we are anticipating them to land

00:09:59,760 --> 00:10:04,160
by the end of september this is about a

00:10:02,240 --> 00:10:07,680
six to eight weeks

00:10:04,160 --> 00:10:10,000
delay from the road map that we had

00:10:07,680 --> 00:10:13,279
announced in february as part of the

00:10:10,000 --> 00:10:14,880
magma developer conference a couple of

00:10:13,279 --> 00:10:15,200
things that we've also learned along the

00:10:14,880 --> 00:10:19,120
way

00:10:15,200 --> 00:10:21,920
is that the 5g sa ecosystem is also

00:10:19,120 --> 00:10:22,640
a little bit immature and so having

00:10:21,920 --> 00:10:24,800
reliable

00:10:22,640 --> 00:10:26,959
end-to-end testing infrastructure has

00:10:24,800 --> 00:10:28,720
proven to be a bit of a challenge

00:10:26,959 --> 00:10:33,839
and this is sort of slowing down our

00:10:28,720 --> 00:10:33,839
ability to iterate fast

00:10:34,560 --> 00:10:39,519
cool switching gears again um so

00:10:37,600 --> 00:10:40,880
we're going to talk a little bit about

00:10:39,519 --> 00:10:46,399
magma under the hood

00:10:40,880 --> 00:10:48,959
and what makes it cloud native

00:10:46,399 --> 00:10:49,600
so the best definition that i've heard

00:10:48,959 --> 00:10:52,079
for

00:10:49,600 --> 00:10:52,640
what makes a workload cloud native or

00:10:52,079 --> 00:10:54,880
not

00:10:52,640 --> 00:10:56,000
is the difference between pets and

00:10:54,880 --> 00:10:58,959
cattle

00:10:56,000 --> 00:11:00,000
pets are unique they're hand raised and

00:10:58,959 --> 00:11:02,480
cared for

00:11:00,000 --> 00:11:03,279
when they get ill we nurse them back to

00:11:02,480 --> 00:11:05,519
health

00:11:03,279 --> 00:11:06,399
they're all distinct and this is a clear

00:11:05,519 --> 00:11:10,000
definition

00:11:06,399 --> 00:11:12,160
of a workload that is not cloud native

00:11:10,000 --> 00:11:14,160
a workload that is cloud native in turn

00:11:12,160 --> 00:11:16,640
looks a lot more like cattle

00:11:14,160 --> 00:11:17,519
cattle are almost identical to other

00:11:16,640 --> 00:11:19,760
cattle

00:11:17,519 --> 00:11:20,880
and when they get ill you get another

00:11:19,760 --> 00:11:22,800
one

00:11:20,880 --> 00:11:24,880
so the transition that we're trying to

00:11:22,800 --> 00:11:26,800
affect in the service network a service

00:11:24,880 --> 00:11:29,440
provider network with a

00:11:26,800 --> 00:11:30,160
magma converge core is that of a

00:11:29,440 --> 00:11:32,240
transition

00:11:30,160 --> 00:11:33,760
from a traditional core to a cloud

00:11:32,240 --> 00:11:36,079
native core

00:11:33,760 --> 00:11:38,399
or in other words the transition from

00:11:36,079 --> 00:11:40,000
pets to cattle

00:11:38,399 --> 00:11:41,600
there are many other definitions of

00:11:40,000 --> 00:11:43,839
cloud native workloads like you know

00:11:41,600 --> 00:11:47,120
stateless is it container deployable

00:11:43,839 --> 00:11:48,560
all of those are all attributes of a

00:11:47,120 --> 00:11:51,279
cloud native network

00:11:48,560 --> 00:11:53,279
the fundamental thing though we'd argue

00:11:51,279 --> 00:11:54,480
is the difference between pets and

00:11:53,279 --> 00:11:57,839
cattle where

00:11:54,480 --> 00:12:01,040
if you have a cloud native network

00:11:57,839 --> 00:12:03,200
you're much more tolerant to failure and

00:12:01,040 --> 00:12:05,200
almost all your nodes are fairly

00:12:03,200 --> 00:12:07,600
identical

00:12:05,200 --> 00:12:09,680
so with that framing in mind what are

00:12:07,600 --> 00:12:10,560
the key attributes that we think are

00:12:09,680 --> 00:12:13,200
important to

00:12:10,560 --> 00:12:15,839
create such a cloud native uh sort of

00:12:13,200 --> 00:12:15,839
core network

00:12:16,079 --> 00:12:19,360
so the first principle that we think is

00:12:18,240 --> 00:12:23,120
important is

00:12:19,360 --> 00:12:24,720
the need to allow for failure so a node

00:12:23,120 --> 00:12:27,760
failing should not

00:12:24,720 --> 00:12:28,560
have should not impact the overall

00:12:27,760 --> 00:12:31,920
network

00:12:28,560 --> 00:12:33,440
it should be a contained failure

00:12:31,920 --> 00:12:35,279
this is pretty similar to what you

00:12:33,440 --> 00:12:37,120
notice in the data centers

00:12:35,279 --> 00:12:38,800
workloads are fairly distributed so

00:12:37,120 --> 00:12:41,440
taking out a router

00:12:38,800 --> 00:12:42,959
only causes failure on a particular path

00:12:41,440 --> 00:12:46,399
and the ecmp fabric

00:12:42,959 --> 00:12:48,480
is comfortable recovering for that

00:12:46,399 --> 00:12:50,880
for that period of an outage so it's

00:12:48,480 --> 00:12:54,000
much more important solving for

00:12:50,880 --> 00:12:57,440
designing for a system where failure is

00:12:54,000 --> 00:12:59,040
a given the second one is given that

00:12:57,440 --> 00:13:00,560
failures are going to happen

00:12:59,040 --> 00:13:03,279
we need to simplify the failure

00:13:00,560 --> 00:13:04,880
semantics failures need to happen in a

00:13:03,279 --> 00:13:07,120
very well defined way

00:13:04,880 --> 00:13:08,000
and these need to map to clean state

00:13:07,120 --> 00:13:09,839
boundaries

00:13:08,000 --> 00:13:11,839
so this makes it easy for us to

00:13:09,839 --> 00:13:12,720
understand what state actually gets

00:13:11,839 --> 00:13:15,760
affected

00:13:12,720 --> 00:13:18,320
by a failure and the third one is that

00:13:15,760 --> 00:13:21,279
we need to simplify recovery

00:13:18,320 --> 00:13:22,079
so well-defined state and propagation of

00:13:21,279 --> 00:13:25,839
recovery

00:13:22,079 --> 00:13:28,720
is important uh to allow for

00:13:25,839 --> 00:13:30,880
a service to come back up so this uh

00:13:28,720 --> 00:13:33,600
goes back to principles like you know

00:13:30,880 --> 00:13:34,000
clear demarcation of who owns state and

00:13:33,600 --> 00:13:36,079
clear

00:13:34,000 --> 00:13:39,040
propagation principles for the state to

00:13:36,079 --> 00:13:39,040
be repopulated

00:13:40,560 --> 00:13:44,480
so allowing for failure uh this one is

00:13:43,440 --> 00:13:47,040
fairly obvious

00:13:44,480 --> 00:13:48,079
um so scale-up devices have a large

00:13:47,040 --> 00:13:49,760
fault domain

00:13:48,079 --> 00:13:51,199
and they fundamentally need to be

00:13:49,760 --> 00:13:54,560
treated like pets

00:13:51,199 --> 00:13:56,639
by distributing the epc or the 5gc

00:13:54,560 --> 00:13:59,040
what we're trying to achieve with magma

00:13:56,639 --> 00:14:01,199
is that the fault domain of each device

00:13:59,040 --> 00:14:04,320
is pretty small

00:14:01,199 --> 00:14:06,240
further the finer the fault domain the

00:14:04,320 --> 00:14:09,440
easier it is for us to upgrade

00:14:06,240 --> 00:14:12,560
these uh nodes implicitly this

00:14:09,440 --> 00:14:14,320
improves agility a great deal

00:14:12,560 --> 00:14:15,760
this is one of the key things that we

00:14:14,320 --> 00:14:18,000
are also learning

00:14:15,760 --> 00:14:20,399
at facebook in our data center is that

00:14:18,000 --> 00:14:23,199
by the by pushing

00:14:20,399 --> 00:14:24,399
network workloads to smaller distributed

00:14:23,199 --> 00:14:26,000
form factors

00:14:24,399 --> 00:14:27,680
we're able to upgrade them at an

00:14:26,000 --> 00:14:30,240
incredible

00:14:27,680 --> 00:14:33,519
incredible velocity and that helps us

00:14:30,240 --> 00:14:33,519
keep our competitive edge

00:14:35,600 --> 00:14:41,120
before i talk about the state failure

00:14:38,959 --> 00:14:43,760
domains as well as recovery model

00:14:41,120 --> 00:14:45,120
it is worth clarifying the two control

00:14:43,760 --> 00:14:47,760
planes that are in play

00:14:45,120 --> 00:14:49,920
in a 3gpp network the first control

00:14:47,760 --> 00:14:52,399
plane as defined by 3gpp

00:14:49,920 --> 00:14:54,720
is actually an inband signaling function

00:14:52,399 --> 00:14:56,320
that allows a user plane channel to be

00:14:54,720 --> 00:14:58,720
established for a wireless

00:14:56,320 --> 00:15:00,160
wireless device this is actually looking

00:14:58,720 --> 00:15:03,600
at the network

00:15:00,160 --> 00:15:03,600
from the ue standpoint

00:15:07,279 --> 00:15:12,800
but an sdn control plane

00:15:10,720 --> 00:15:14,959
is the function that makes changes to

00:15:12,800 --> 00:15:15,760
the data plane to ensure that a desired

00:15:14,959 --> 00:15:18,639
state

00:15:15,760 --> 00:15:19,040
is realized based on discovered state so

00:15:18,639 --> 00:15:23,279
take

00:15:19,040 --> 00:15:26,399
for example a upf node in a 3gpp

00:15:23,279 --> 00:15:29,680
sort of control plane view the upf node

00:15:26,399 --> 00:15:33,279
is purely a user plane element

00:15:29,680 --> 00:15:35,519
but from an sdn standpoint the upf

00:15:33,279 --> 00:15:38,560
is actually has a significant network

00:15:35,519 --> 00:15:40,959
control plane as well

00:15:38,560 --> 00:15:41,680
so magma at the end of the day

00:15:40,959 --> 00:15:44,560
implements

00:15:41,680 --> 00:15:47,040
a hierarchical control plane motivated

00:15:44,560 --> 00:15:49,440
by sdn principles

00:15:47,040 --> 00:15:50,240
even though the end architecture looks a

00:15:49,440 --> 00:15:53,360
bit like

00:15:50,240 --> 00:15:54,480
cups it is more than cups in the sense

00:15:53,360 --> 00:15:56,639
that magma

00:15:54,480 --> 00:15:58,240
implements a control plane at the edge

00:15:56,639 --> 00:16:00,720
and a control plane at the central

00:15:58,240 --> 00:16:00,720
location

00:16:03,360 --> 00:16:07,440
so to simplify failure semantics as i

00:16:06,399 --> 00:16:09,920
briefly described

00:16:07,440 --> 00:16:11,360
we have a two control plane model there

00:16:09,920 --> 00:16:14,399
is an edge control plane

00:16:11,360 --> 00:16:15,920
that encapsulates all edge state what do

00:16:14,399 --> 00:16:19,680
we mean by edge state

00:16:15,920 --> 00:16:22,000
it is the state associated with the ue

00:16:19,680 --> 00:16:23,120
that is maintained by the network this

00:16:22,000 --> 00:16:25,360
is sort of

00:16:23,120 --> 00:16:27,759
transient or runtime state that gets

00:16:25,360 --> 00:16:30,560
generated by the ue

00:16:27,759 --> 00:16:32,079
signaling and establishing a user plane

00:16:30,560 --> 00:16:34,880
with the network

00:16:32,079 --> 00:16:36,000
there is a central control plane which

00:16:34,880 --> 00:16:39,360
runs in a public

00:16:36,000 --> 00:16:42,480
cloud or in a more centralized location

00:16:39,360 --> 00:16:43,680
that is responsible for maintaining the

00:16:42,480 --> 00:16:45,680
global state

00:16:43,680 --> 00:16:46,880
it is the authoritative owner of this

00:16:45,680 --> 00:16:50,160
global state

00:16:46,880 --> 00:16:52,800
this is cons this is an always available

00:16:50,160 --> 00:16:53,839
application and today in magma it is

00:16:52,800 --> 00:16:57,839
just a

00:16:53,839 --> 00:17:00,000
pretty standard kubernetes application

00:16:57,839 --> 00:17:01,440
the advantage of this distinction of the

00:17:00,000 --> 00:17:02,399
edge control plane and the central

00:17:01,440 --> 00:17:04,480
control plane

00:17:02,399 --> 00:17:07,199
is that the edge control plane has a

00:17:04,480 --> 00:17:10,240
very clearly defined failure semantics

00:17:07,199 --> 00:17:13,280
it aggregates the runtime state of the

00:17:10,240 --> 00:17:16,799
network and and

00:17:13,280 --> 00:17:20,400
if a edge host machine goes down

00:17:16,799 --> 00:17:22,799
you have lost all of the control

00:17:20,400 --> 00:17:23,760
or the runtime state associated with the

00:17:22,799 --> 00:17:27,039
ue as

00:17:23,760 --> 00:17:27,839
maintained by the network by using

00:17:27,039 --> 00:17:30,400
standardized

00:17:27,839 --> 00:17:32,000
distributed systems techniques like you

00:17:30,400 --> 00:17:34,400
know persisting this runtime

00:17:32,000 --> 00:17:36,240
state to a key value stored like redis

00:17:34,400 --> 00:17:38,320
which is what we do in magma

00:17:36,240 --> 00:17:39,440
and replicating the state to the cloud

00:17:38,320 --> 00:17:42,320
or or through

00:17:39,440 --> 00:17:43,600
other uh distributed system um

00:17:42,320 --> 00:17:46,320
principles to uh

00:17:43,600 --> 00:17:48,320
to other redis nodes we have the ability

00:17:46,320 --> 00:17:49,120
to checkpoint and restore this runtime

00:17:48,320 --> 00:17:51,520
state

00:17:49,120 --> 00:17:52,160
this makes for a cleaner implementation

00:17:51,520 --> 00:17:56,720
of

00:17:52,160 --> 00:17:58,799
h a the role of a central control plane

00:17:56,720 --> 00:18:01,280
is to communicate with an edge control

00:17:58,799 --> 00:18:04,000
plane understand the discovered state

00:18:01,280 --> 00:18:04,400
say a ue came onto a network and then

00:18:04,000 --> 00:18:07,120
use

00:18:04,400 --> 00:18:09,520
the desired state as understood by the

00:18:07,120 --> 00:18:12,960
configuration of the network

00:18:09,520 --> 00:18:15,679
to push down a realized state

00:18:12,960 --> 00:18:17,440
model that then gets implemented by the

00:18:15,679 --> 00:18:18,720
edge control plane through forwarding

00:18:17,440 --> 00:18:21,840
rules

00:18:18,720 --> 00:18:23,840
at the upf or the gateway depending on

00:18:21,840 --> 00:18:26,000
which generation of 3gpp you're working

00:18:23,840 --> 00:18:26,000
with

00:18:27,120 --> 00:18:32,000
the next principle um around

00:18:32,160 --> 00:18:35,760
moving to a more of a cloud native sort

00:18:35,200 --> 00:18:38,720
of a

00:18:35,760 --> 00:18:40,080
core network is to simplify the recovery

00:18:38,720 --> 00:18:43,120
semantics

00:18:40,080 --> 00:18:47,360
so let's take an example of n4

00:18:43,120 --> 00:18:50,400
n4 in in 3gpp uh is defined

00:18:47,360 --> 00:18:51,120
roughly defined across two planes the

00:18:50,400 --> 00:18:53,360
first one

00:18:51,120 --> 00:18:54,320
what we call as node level procedures

00:18:53,360 --> 00:18:56,720
like things like

00:18:54,320 --> 00:18:57,679
load reporting and heartbeating and then

00:18:56,720 --> 00:19:00,000
the second one

00:18:57,679 --> 00:19:01,679
is around session level procedures which

00:19:00,000 --> 00:19:05,919
is the actual business logic

00:19:01,679 --> 00:19:09,039
of the um smf and the upf

00:19:05,919 --> 00:19:10,160
our assertion here is by is that to

00:19:09,039 --> 00:19:13,760
implement a cloud

00:19:10,160 --> 00:19:17,039
native sort of a a

00:19:13,760 --> 00:19:19,919
a converged core we need to remove the

00:19:17,039 --> 00:19:21,120
node level procedures out of the n4

00:19:19,919 --> 00:19:23,200
implementation

00:19:21,120 --> 00:19:25,280
and delegate it to a service control

00:19:23,200 --> 00:19:27,840
plane similar to

00:19:25,280 --> 00:19:29,760
like kubernetes and model that as

00:19:27,840 --> 00:19:32,559
kubernetes operators

00:19:29,760 --> 00:19:34,640
the advantage of doing this is that say

00:19:32,559 --> 00:19:35,440
if a node goes down or a node comes back

00:19:34,640 --> 00:19:37,760
up

00:19:35,440 --> 00:19:38,960
both your 3gpp point point-to-point

00:19:37,760 --> 00:19:40,960
control interfaces

00:19:38,960 --> 00:19:42,400
and your kubernetes are not trying to

00:19:40,960 --> 00:19:45,440
make independent decisions

00:19:42,400 --> 00:19:46,320
on how state needs to be restored so

00:19:45,440 --> 00:19:47,919
what we think

00:19:46,320 --> 00:19:50,240
we're trying to what we're trying to do

00:19:47,919 --> 00:19:52,320
with magma is to remove the

00:19:50,240 --> 00:19:53,600
sort of note to node interface

00:19:52,320 --> 00:19:56,640
procedures

00:19:53,600 --> 00:19:57,679
from the standard interfaces like n4 and

00:19:56,640 --> 00:20:00,880
only focus

00:19:57,679 --> 00:20:01,280
on the service level procedures uh like

00:20:00,880 --> 00:20:03,200
the

00:20:01,280 --> 00:20:05,200
session related procedures around

00:20:03,200 --> 00:20:06,000
session establishment modification and

00:20:05,200 --> 00:20:09,120
release

00:20:06,000 --> 00:20:11,440
which go from smf to upf and the session

00:20:09,120 --> 00:20:14,720
reporting which moves from the upf to

00:20:11,440 --> 00:20:17,200
smf so the key takeaway from this

00:20:14,720 --> 00:20:18,559
principle is to delegate point to point

00:20:17,200 --> 00:20:20,159
node interfaces

00:20:18,559 --> 00:20:22,480
to the service control plane where

00:20:20,159 --> 00:20:24,640
possible this allows the service control

00:20:22,480 --> 00:20:28,960
plane to make consistent decisions

00:20:24,640 --> 00:20:28,960
across all nodes in the network

00:20:31,919 --> 00:20:36,159
the second aspect is how do we propagate

00:20:35,120 --> 00:20:38,400
this state

00:20:36,159 --> 00:20:40,720
so taking a step back the interaction

00:20:38,400 --> 00:20:43,600
between the smf and the upf

00:20:40,720 --> 00:20:44,559
is mostly about state synchronization

00:20:43,600 --> 00:20:48,240
there is a clear

00:20:44,559 --> 00:20:48,720
owner for each substate the upf uh note

00:20:48,240 --> 00:20:51,440
state

00:20:48,720 --> 00:20:52,880
is owned by the upf the session rules

00:20:51,440 --> 00:20:54,799
are owned by the smf

00:20:52,880 --> 00:20:56,320
and the session stats are owned by the

00:20:54,799 --> 00:21:00,320
upf

00:20:56,320 --> 00:21:03,440
the existing uh 3gpp standards

00:21:00,320 --> 00:21:05,520
are edge interfaces so they model all of

00:21:03,440 --> 00:21:08,720
the state synchronization using

00:21:05,520 --> 00:21:11,360
crud what we assert is

00:21:08,720 --> 00:21:13,600
that for better reliability and to

00:21:11,360 --> 00:21:15,280
simplify recovery semantics especially

00:21:13,600 --> 00:21:17,679
given that we know

00:21:15,280 --> 00:21:19,280
uh state is uniquely owned by each of

00:21:17,679 --> 00:21:22,159
these uh

00:21:19,280 --> 00:21:22,799
each of these devices we we think

00:21:22,159 --> 00:21:26,159
modeling

00:21:22,799 --> 00:21:29,200
all of these all of this state

00:21:26,159 --> 00:21:30,640
as level interfaces is a much cleaner

00:21:29,200 --> 00:21:34,080
way of doing this

00:21:30,640 --> 00:21:37,120
so what level interfaces are are set

00:21:34,080 --> 00:21:38,320
based uh interfaces so at any point in

00:21:37,120 --> 00:21:41,840
time the upf

00:21:38,320 --> 00:21:45,280
and the smf interact over uh

00:21:41,840 --> 00:21:47,360
set interfaces this is very similar to

00:21:45,280 --> 00:21:48,640
the transition that has happened from

00:21:47,360 --> 00:21:50,640
soap to rest

00:21:48,640 --> 00:21:52,000
soap was much more of a crud and

00:21:50,640 --> 00:21:54,720
stateful model

00:21:52,000 --> 00:21:56,640
and rest is now much more of a

00:21:54,720 --> 00:21:59,840
resource-based model where

00:21:56,640 --> 00:22:03,120
you know we only use uh

00:21:59,840 --> 00:22:04,000
puts and gets uh there's a great talk by

00:22:03,120 --> 00:22:06,559
ullash

00:22:04,000 --> 00:22:08,080
that's available on youtube which talks

00:22:06,559 --> 00:22:11,520
about the abstractions

00:22:08,080 --> 00:22:12,240
in magma that further clarifies this

00:22:11,520 --> 00:22:15,120
point in

00:22:12,240 --> 00:22:15,120
in greater detail

00:22:17,440 --> 00:22:23,280
so summarizing um magma product

00:22:20,720 --> 00:22:24,640
focus verticals is currently we are

00:22:23,280 --> 00:22:27,280
focused around

00:22:24,640 --> 00:22:28,400
fixed wireless wi-fi core and private

00:22:27,280 --> 00:22:31,440
networks

00:22:28,400 --> 00:22:33,679
magma 5g essay support is in alpha

00:22:31,440 --> 00:22:35,600
we hope to be lab ready by the end of

00:22:33,679 --> 00:22:38,080
june and feel ready by

00:22:35,600 --> 00:22:39,760
september slicing support would be

00:22:38,080 --> 00:22:43,760
introduced in

00:22:39,760 --> 00:22:46,960
in the september release of 2021.

00:22:43,760 --> 00:22:49,840
the magma architecture is cloud native

00:22:46,960 --> 00:22:50,080
and the reason it is cloud native is it

00:22:49,840 --> 00:22:52,000
is

00:22:50,080 --> 00:22:53,760
an implementation that is focused on

00:22:52,000 --> 00:22:56,799
scaling out versus up

00:22:53,760 --> 00:23:00,480
similar to the pets versus

00:22:56,799 --> 00:23:02,240
cattle analogy magma adheres to the sdn

00:23:00,480 --> 00:23:04,080
principles of control plane

00:23:02,240 --> 00:23:06,559
and thus implements a hierarchical

00:23:04,080 --> 00:23:08,880
control plane this is slightly different

00:23:06,559 --> 00:23:10,880
from a 3gpp cups implementation which

00:23:08,880 --> 00:23:12,400
just talks about control and user plane

00:23:10,880 --> 00:23:15,200
separation

00:23:12,400 --> 00:23:16,000
it adds an additional slice in terms of

00:23:15,200 --> 00:23:20,240
the control

00:23:16,000 --> 00:23:20,240
plane being edge versus centralized

00:23:20,880 --> 00:23:24,240
thank you everybody um here is some

00:23:23,600 --> 00:23:26,880
additional

00:23:24,240 --> 00:23:28,559
information uh on how to uh plug into

00:23:26,880 --> 00:23:30,400
the project there's a website

00:23:28,559 --> 00:23:32,080
there's also all of this code is fully

00:23:30,400 --> 00:23:33,440
open source and all of our development

00:23:32,080 --> 00:23:36,960
happens in the open

00:23:33,440 --> 00:23:39,840
uh github.com magma there are two

00:23:36,960 --> 00:23:40,960
talks that give a much more detailed

00:23:39,840 --> 00:23:44,640
overview of

00:23:40,960 --> 00:23:46,320
um of the magma principles uh the first

00:23:44,640 --> 00:23:47,679
one is by me introduction to a

00:23:46,320 --> 00:23:50,080
distributed epc

00:23:47,679 --> 00:23:52,159
and then the second is by ullash on

00:23:50,080 --> 00:23:54,640
magma abstractions and interfaces

00:23:52,159 --> 00:23:55,919
both of which are available in on

00:23:54,640 --> 00:23:59,600
youtube

00:23:55,919 --> 00:23:59,600

YouTube URL: https://www.youtube.com/watch?v=BNrgihv9C5A


