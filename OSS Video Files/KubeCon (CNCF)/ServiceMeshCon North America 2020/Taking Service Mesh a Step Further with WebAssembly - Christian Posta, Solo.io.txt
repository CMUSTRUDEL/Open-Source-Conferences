Title: Taking Service Mesh a Step Further with WebAssembly - Christian Posta, Solo.io
Publication date: 2020-11-25
Playlist: ServiceMeshCon North America 2020
Description: 
	Taking Service Mesh a Step Further with WebAssembly - Christian Posta, Solo.io

WebAssembly (WASM) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications. Wasm support in Envoy means that that opens up new possibilities in customizing service meshes built on Envoy with modules that modify the behavior of the sidecar proxy in any language. The possibilities are endless and in this talk we will explain: - The state of Wasm in Envoy and how it works - Demonstrate the developer experience in building, sharing, and deploying modules - Demonstrate a range of modules types and the kind of behavior it can customize in the sidecar proxy
Captions: 
	00:00:00,160 --> 00:00:05,680
i do hope you've been enjoying the talks

00:00:02,800 --> 00:00:06,640
in the servicemeshcon 2020 track this

00:00:05,680 --> 00:00:09,519
year

00:00:06,640 --> 00:00:10,719
my session will be taking service mesh a

00:00:09,519 --> 00:00:14,799
step further

00:00:10,719 --> 00:00:17,520
with a technology called webassembly

00:00:14,799 --> 00:00:20,080
so my name is christian and i am the

00:00:17,520 --> 00:00:22,560
field cto here at solo.io

00:00:20,080 --> 00:00:24,320
i've been involved in helping

00:00:22,560 --> 00:00:25,279
organizations build large distributed

00:00:24,320 --> 00:00:28,800
systems for

00:00:25,279 --> 00:00:31,199
quite some time and most recently

00:00:28,800 --> 00:00:32,239
last three years or so in building

00:00:31,199 --> 00:00:33,840
architectures on top of

00:00:32,239 --> 00:00:36,160
kubernetes and cloud native

00:00:33,840 --> 00:00:39,520
infrastructure including

00:00:36,160 --> 00:00:42,000
things like service mesh

00:00:39,520 --> 00:00:43,360
so at solo real quick what we do is we

00:00:42,000 --> 00:00:45,200
help organizations

00:00:43,360 --> 00:00:46,879
after they've figured out how to

00:00:45,200 --> 00:00:49,280
automate their

00:00:46,879 --> 00:00:50,239
deployments with ci cd and deploying

00:00:49,280 --> 00:00:52,399
into containers

00:00:50,239 --> 00:00:54,399
and kind of breaking up some of their

00:00:52,399 --> 00:00:56,320
applications into microservices

00:00:54,399 --> 00:00:58,000
how do they get those systems to

00:00:56,320 --> 00:01:00,320
communicate with each other

00:00:58,000 --> 00:01:01,120
and the organizations that we typically

00:01:00,320 --> 00:01:03,600
deal with

00:01:01,120 --> 00:01:04,720
are trying to deploy redundant highly

00:01:03,600 --> 00:01:08,080
available

00:01:04,720 --> 00:01:10,159
systems that are capable of experiencing

00:01:08,080 --> 00:01:12,720
degradation and failover in a seamless

00:01:10,159 --> 00:01:13,680
way and at solo what we do is we help

00:01:12,720 --> 00:01:17,439
build

00:01:13,680 --> 00:01:20,479
api infrastructure on technology like

00:01:17,439 --> 00:01:23,439
envoy and service mesh to be able to

00:01:20,479 --> 00:01:24,840
span multiple clusters multiple zones

00:01:23,439 --> 00:01:28,159
multiple

00:01:24,840 --> 00:01:31,759
geographies and and use things like

00:01:28,159 --> 00:01:35,200
mesh and gateways to be able to get

00:01:31,759 --> 00:01:38,400
this transparent routing and secure

00:01:35,200 --> 00:01:42,000
communication observable network and

00:01:38,400 --> 00:01:44,320
and these types of things so

00:01:42,000 --> 00:01:45,360
in helping these organizations build

00:01:44,320 --> 00:01:48,880
these types of

00:01:45,360 --> 00:01:51,920
architectures we see a lot of

00:01:48,880 --> 00:01:53,119
what's happening on the ground and more

00:01:51,920 --> 00:01:55,360
importantly in practice

00:01:53,119 --> 00:01:56,479
and and what's what's really happening

00:01:55,360 --> 00:01:59,920
so what we do see

00:01:56,479 --> 00:02:02,560
is folks are adopting service mesh

00:01:59,920 --> 00:02:03,439
and they are taking it into production

00:02:02,560 --> 00:02:05,520
they do have

00:02:03,439 --> 00:02:07,040
some initial challenges around which one

00:02:05,520 --> 00:02:08,080
to use because as you're probably

00:02:07,040 --> 00:02:10,640
familiar with

00:02:08,080 --> 00:02:12,879
and as you see the talks in this track

00:02:10,640 --> 00:02:14,720
there are a lot of different options

00:02:12,879 --> 00:02:16,319
and then your next question especially

00:02:14,720 --> 00:02:17,840
as a large enterprise who's going to

00:02:16,319 --> 00:02:19,200
support you who's going to give you the

00:02:17,840 --> 00:02:21,280
level of support that

00:02:19,200 --> 00:02:22,640
you need and then there's always

00:02:21,280 --> 00:02:25,280
questions around

00:02:22,640 --> 00:02:27,520
um how does it fit within an existing

00:02:25,280 --> 00:02:30,400
organization

00:02:27,520 --> 00:02:31,760
how does it fit with existing

00:02:30,400 --> 00:02:36,640
applications

00:02:31,760 --> 00:02:40,319
that weren't very native to a cloud-like

00:02:36,640 --> 00:02:43,040
platform and

00:02:40,319 --> 00:02:44,640
one of the biggest that we see and that

00:02:43,040 --> 00:02:45,440
we've been able to help out with with

00:02:44,640 --> 00:02:48,879
our customers

00:02:45,440 --> 00:02:50,319
is how do we customize that last 10

00:02:48,879 --> 00:02:52,400
percent

00:02:50,319 --> 00:02:53,440
so we we've introduced let's say a

00:02:52,400 --> 00:02:56,480
gateway or we

00:02:53,440 --> 00:02:57,120
introduced a service mesh and either at

00:02:56,480 --> 00:02:58,480
the edge

00:02:57,120 --> 00:03:00,640
or sometimes even in between the

00:02:58,480 --> 00:03:03,760
applications there are

00:03:00,640 --> 00:03:04,640
needs around customizing the behavior of

00:03:03,760 --> 00:03:07,760
the network

00:03:04,640 --> 00:03:11,599
or customizing the behavior of the

00:03:07,760 --> 00:03:12,319
proxies so typical customizations look

00:03:11,599 --> 00:03:15,840
like

00:03:12,319 --> 00:03:17,599
supporting existing wire protocols maybe

00:03:15,840 --> 00:03:19,360
some of them are industry or vertical

00:03:17,599 --> 00:03:23,040
specific

00:03:19,360 --> 00:03:25,040
you'll see the need to add more specific

00:03:23,040 --> 00:03:26,319
customizations and telemetry that the

00:03:25,040 --> 00:03:30,239
proxy

00:03:26,319 --> 00:03:32,560
captures especially things like

00:03:30,239 --> 00:03:33,599
implementing security protocols things

00:03:32,560 --> 00:03:36,640
that might not be

00:03:33,599 --> 00:03:40,319
very industry standard but have existed

00:03:36,640 --> 00:03:42,480
in these organizations and if the mesh

00:03:40,319 --> 00:03:43,680
or this technology is going to be

00:03:42,480 --> 00:03:46,879
adopted

00:03:43,680 --> 00:03:49,760
then it needs to be backward compatible

00:03:46,879 --> 00:03:50,560
with these existing you know brownfield

00:03:49,760 --> 00:03:52,959
applications

00:03:50,560 --> 00:03:54,720
and you know the way they communicate on

00:03:52,959 --> 00:03:56,239
the network

00:03:54,720 --> 00:03:58,080
there's also going to be things like

00:03:56,239 --> 00:04:00,080
light transformations

00:03:58,080 --> 00:04:01,280
how do we take this header mangle it up

00:04:00,080 --> 00:04:02,159
a little bit put it over here in this

00:04:01,280 --> 00:04:04,000
header because

00:04:02,159 --> 00:04:05,599
that's what that's what the upstream

00:04:04,000 --> 00:04:08,879
applications expect

00:04:05,599 --> 00:04:09,439
and and so on so there's a really large

00:04:08,879 --> 00:04:12,840
almost

00:04:09,439 --> 00:04:15,519
um never-ending list of what

00:04:12,840 --> 00:04:18,959
customizations you might need

00:04:15,519 --> 00:04:22,639
to actually productionize and get a

00:04:18,959 --> 00:04:25,919
system like a service mesh into um

00:04:22,639 --> 00:04:28,400
into an organization now so

00:04:25,919 --> 00:04:30,240
at solo what we've been doing is a lot

00:04:28,400 --> 00:04:31,440
of the technology that we focus on is

00:04:30,240 --> 00:04:33,520
built on envoy

00:04:31,440 --> 00:04:34,720
so either our glue gateways built on

00:04:33,520 --> 00:04:37,840
envoy or

00:04:34,720 --> 00:04:39,120
um you know istio is is something that

00:04:37,840 --> 00:04:41,440
we've um

00:04:39,120 --> 00:04:42,960
we've been supporting for our customers

00:04:41,440 --> 00:04:46,080
is built on envoy and so

00:04:42,960 --> 00:04:48,479
we can we can build the customization

00:04:46,080 --> 00:04:49,840
customization directly into envoy but

00:04:48,479 --> 00:04:52,960
web assembly

00:04:49,840 --> 00:04:56,000
has kind of come to the forefront as

00:04:52,960 --> 00:04:57,840
the uh the right way to build these

00:04:56,000 --> 00:05:00,720
types of extensions and i can explain a

00:04:57,840 --> 00:05:02,400
little bit more about them

00:05:00,720 --> 00:05:04,800
so webassembly actually originated in

00:05:02,400 --> 00:05:07,840
the web browsers as a way to

00:05:04,800 --> 00:05:08,639
speed up the execution of code in the

00:05:07,840 --> 00:05:11,600
web browsers

00:05:08,639 --> 00:05:13,680
but also open up the opportunity for

00:05:11,600 --> 00:05:16,240
folks to write extensions to

00:05:13,680 --> 00:05:17,520
web applications in different languages

00:05:16,240 --> 00:05:21,280
than javascript

00:05:17,520 --> 00:05:24,560
so webassembly is a binary format

00:05:21,280 --> 00:05:27,759
that you write your length your your

00:05:24,560 --> 00:05:29,199
programs and your extensions in

00:05:27,759 --> 00:05:31,919
any language that you like high-level

00:05:29,199 --> 00:05:35,039
language like a c-plus plus or a rust or

00:05:31,919 --> 00:05:38,320
golang or whatever and then compile that

00:05:35,039 --> 00:05:41,680
into a binary module

00:05:38,320 --> 00:05:46,000
that can then be loaded into

00:05:41,680 --> 00:05:49,039
a a host vm a webassembly vm

00:05:46,000 --> 00:05:50,160
and this is something that uh you know

00:05:49,039 --> 00:05:52,720
is not a new idea

00:05:50,160 --> 00:05:53,440
right we've been building and taking

00:05:52,720 --> 00:05:55,360
high level

00:05:53,440 --> 00:05:57,520
uh languages and compiling them down

00:05:55,360 --> 00:05:59,680
into different portable formats

00:05:57,520 --> 00:06:02,240
and running them in either some some

00:05:59,680 --> 00:06:06,240
sort of vm or some sort of host

00:06:02,240 --> 00:06:06,880
this is this is the same idea so we can

00:06:06,240 --> 00:06:10,160
take this

00:06:06,880 --> 00:06:12,160
we can again we can take the a code in

00:06:10,160 --> 00:06:13,280
a language that you desire to write in

00:06:12,160 --> 00:06:15,840
or maybe code that you have

00:06:13,280 --> 00:06:16,960
already existing and try to compile that

00:06:15,840 --> 00:06:19,280
down into

00:06:16,960 --> 00:06:20,000
a format that can be embedded into a web

00:06:19,280 --> 00:06:22,160
browser

00:06:20,000 --> 00:06:23,120
or in this case as we see on this last

00:06:22,160 --> 00:06:26,479
line

00:06:23,120 --> 00:06:29,600
onboard proxy and as i mentioned

00:06:26,479 --> 00:06:32,400
envoy is one of the leading proxies for

00:06:29,600 --> 00:06:33,759
building this type of mesh or

00:06:32,400 --> 00:06:37,759
application networking

00:06:33,759 --> 00:06:40,319
technology so an important part of

00:06:37,759 --> 00:06:42,240
webassembly and running it in any of

00:06:40,319 --> 00:06:43,919
these these hosts is that you're kind of

00:06:42,240 --> 00:06:47,759
taking untrusted code

00:06:43,919 --> 00:06:50,720
and embedding it into an existing system

00:06:47,759 --> 00:06:52,160
now webassembly is built to be secure i

00:06:50,720 --> 00:06:52,880
mean if it's running in the browsers

00:06:52,160 --> 00:06:55,599
just like

00:06:52,880 --> 00:06:56,880
a javascript engine it needs to be

00:06:55,599 --> 00:06:58,960
secure

00:06:56,880 --> 00:07:00,960
and one of the things webassembly does

00:06:58,960 --> 00:07:03,440
is

00:07:00,960 --> 00:07:04,080
it it enforces a very tight memory

00:07:03,440 --> 00:07:06,960
boundary

00:07:04,080 --> 00:07:07,919
around that module the module can only

00:07:06,960 --> 00:07:11,039
use

00:07:07,919 --> 00:07:14,319
whatever memory um and

00:07:11,039 --> 00:07:17,360
and functions and

00:07:14,319 --> 00:07:20,000
variables that the host gives it so

00:07:17,360 --> 00:07:20,639
it can't just start calling out to uh

00:07:20,000 --> 00:07:24,240
either

00:07:20,639 --> 00:07:27,360
any other host functions or outside

00:07:24,240 --> 00:07:30,800
of that sandbox so it's very uh safe

00:07:27,360 --> 00:07:33,199
and and secure it's also

00:07:30,800 --> 00:07:34,800
extremely fast at least compared to

00:07:33,199 --> 00:07:37,120
alternatives right so if we

00:07:34,800 --> 00:07:40,000
look at in the browser we see that it's

00:07:37,120 --> 00:07:43,520
it's faster than a javascript

00:07:40,000 --> 00:07:46,080
implementation if we look at maybe

00:07:43,520 --> 00:07:47,680
envoy specifically is faster than some

00:07:46,080 --> 00:07:50,800
of the alternatives

00:07:47,680 --> 00:07:51,759
so some of the alternatives to extending

00:07:50,800 --> 00:07:55,199
the capabilities

00:07:51,759 --> 00:07:57,840
of envoy include things like calling out

00:07:55,199 --> 00:07:58,720
to an external service and having it

00:07:57,840 --> 00:08:01,199
process

00:07:58,720 --> 00:08:02,080
some logic like i don't know for example

00:08:01,199 --> 00:08:05,039
we have uh

00:08:02,080 --> 00:08:06,560
customers that do funky things with hmac

00:08:05,039 --> 00:08:08,240
on the request come in they have to do

00:08:06,560 --> 00:08:10,000
some hmac validation

00:08:08,240 --> 00:08:12,080
or they might reach out to an external

00:08:10,000 --> 00:08:15,039
auth service to do that out of

00:08:12,080 --> 00:08:16,319
uh out of the process of the proxy if we

00:08:15,039 --> 00:08:17,919
could do something like that inside the

00:08:16,319 --> 00:08:21,280
proxy now we don't have to take

00:08:17,919 --> 00:08:23,840
that additional hop and you know

00:08:21,280 --> 00:08:24,479
and that speed stinks up it's not as

00:08:23,840 --> 00:08:28,400
fast

00:08:24,479 --> 00:08:30,639
as writing the code directly into

00:08:28,400 --> 00:08:31,759
the onboard proxy itself so if you wrote

00:08:30,639 --> 00:08:36,080
it as

00:08:31,759 --> 00:08:37,680
a c plus plus extension to to enboy

00:08:36,080 --> 00:08:40,000
web assembly's not gonna be as fast as

00:08:37,680 --> 00:08:43,200
that but the downsides

00:08:40,000 --> 00:08:44,640
to baking it directly into the proxy

00:08:43,200 --> 00:08:45,040
itself is first of all you have to write

00:08:44,640 --> 00:08:47,200
it in c

00:08:45,040 --> 00:08:49,200
plus plus you have to compile it and

00:08:47,200 --> 00:08:51,920
statically link it into

00:08:49,200 --> 00:08:53,040
envoy itself so now the binary that

00:08:51,920 --> 00:08:56,320
you're running

00:08:53,040 --> 00:08:57,760
isn't upstream envoy anymore it's

00:08:56,320 --> 00:08:59,360
your own distribution that you just

00:08:57,760 --> 00:09:00,880
created

00:08:59,360 --> 00:09:02,480
and so that's a very important

00:09:00,880 --> 00:09:03,519
consideration especially when you start

00:09:02,480 --> 00:09:04,399
talking about

00:09:03,519 --> 00:09:06,480
all the different types of

00:09:04,399 --> 00:09:08,080
customizations that you might want so

00:09:06,480 --> 00:09:11,040
will you have one build of envoy

00:09:08,080 --> 00:09:12,080
that has all of the customizations or

00:09:11,040 --> 00:09:15,440
will you have

00:09:12,080 --> 00:09:16,959
you know 10 20 different distributions

00:09:15,440 --> 00:09:18,800
that you're going to try to support

00:09:16,959 --> 00:09:20,800
it'd be nice if you just had the one

00:09:18,800 --> 00:09:22,560
single distribution

00:09:20,800 --> 00:09:24,000
and dynamically load those

00:09:22,560 --> 00:09:28,399
customizations in

00:09:24,000 --> 00:09:30,959
as needed so as i said earlier

00:09:28,399 --> 00:09:32,240
with webassembly we can we can use

00:09:30,959 --> 00:09:33,680
ideally any language

00:09:32,240 --> 00:09:36,000
now in practice we'll see some are

00:09:33,680 --> 00:09:37,040
better suited today than than others but

00:09:36,000 --> 00:09:39,279
we can use

00:09:37,040 --> 00:09:40,480
uh any language which then gets compiled

00:09:39,279 --> 00:09:44,160
down into

00:09:40,480 --> 00:09:47,040
an intermediate representation of the of

00:09:44,160 --> 00:09:47,519
um the code and then eventually executed

00:09:47,040 --> 00:09:51,040
into

00:09:47,519 --> 00:09:54,000
the into the vm

00:09:51,040 --> 00:09:55,120
so here's where it gets interesting

00:09:54,000 --> 00:09:58,399
because for

00:09:55,120 --> 00:10:01,680
frameworks like like um service mesh

00:09:58,399 --> 00:10:05,760
especially those built on envoy

00:10:01,680 --> 00:10:08,000
we have this opportunity now to not only

00:10:05,760 --> 00:10:09,600
so the service mesh itself kind of

00:10:08,000 --> 00:10:11,680
organizes and programs

00:10:09,600 --> 00:10:14,079
the network at the l7 or the application

00:10:11,680 --> 00:10:17,120
layer now we can have

00:10:14,079 --> 00:10:18,880
very fine-grained customizations that

00:10:17,120 --> 00:10:20,480
are tailored toward

00:10:18,880 --> 00:10:22,480
the way you've written applications

00:10:20,480 --> 00:10:25,519
already and especially

00:10:22,480 --> 00:10:27,519
that might be organizational specific so

00:10:25,519 --> 00:10:31,360
if we take a look at

00:10:27,519 --> 00:10:33,839
envoy today and the mechanisms

00:10:31,360 --> 00:10:34,720
and how a request would flow through the

00:10:33,839 --> 00:10:37,120
filter chains

00:10:34,720 --> 00:10:38,480
in envoy so it envoy is built on this

00:10:37,120 --> 00:10:42,399
pipes and filtered type

00:10:38,480 --> 00:10:44,160
architecture um and request comes in

00:10:42,399 --> 00:10:46,240
goes through one of these first steps

00:10:44,160 --> 00:10:48,320
continues on to the next to the next

00:10:46,240 --> 00:10:49,760
uh and eventually gets routed either

00:10:48,320 --> 00:10:52,880
either sent back or

00:10:49,760 --> 00:10:54,240
or routed to an upstream service envoy

00:10:52,880 --> 00:10:55,120
is a proxy right so it's proxying the

00:10:54,240 --> 00:10:56,880
request it's

00:10:55,120 --> 00:11:00,079
adding some additional capabilities to

00:10:56,880 --> 00:11:01,440
the request once it gets on the wire now

00:11:00,079 --> 00:11:04,320
you can see the fourth

00:11:01,440 --> 00:11:04,880
box here going down as you flow through

00:11:04,320 --> 00:11:08,079
this

00:11:04,880 --> 00:11:09,600
this chain of filters you can add

00:11:08,079 --> 00:11:11,839
you can first of all you can configure

00:11:09,600 --> 00:11:13,120
any of the out-of-the-box filters that

00:11:11,839 --> 00:11:15,600
exist in envoy

00:11:13,120 --> 00:11:16,959
to live in this chain but you can also

00:11:15,600 --> 00:11:18,480
add your own custom

00:11:16,959 --> 00:11:20,640
filters and so that's something that

00:11:18,480 --> 00:11:24,079
we've done uh in the past

00:11:20,640 --> 00:11:25,200
you write this in in c plus but as i

00:11:24,079 --> 00:11:28,399
said

00:11:25,200 --> 00:11:30,800
with webassembly you can write this in

00:11:28,399 --> 00:11:32,640
a different language than c plus plus

00:11:30,800 --> 00:11:34,480
compile this down to a webassembly

00:11:32,640 --> 00:11:37,360
module

00:11:34,480 --> 00:11:37,760
and then run that piece run that module

00:11:37,360 --> 00:11:41,120
as

00:11:37,760 --> 00:11:44,880
a step in this filter chain

00:11:41,120 --> 00:11:47,519
so web assembly becomes this mechanism

00:11:44,880 --> 00:11:48,399
of extending the capabilities of an

00:11:47,519 --> 00:11:52,000
existing

00:11:48,399 --> 00:11:53,839
envoy proxy with you know the code

00:11:52,000 --> 00:11:56,079
of your choice in the language of your

00:11:53,839 --> 00:11:59,279
choice now how that happens

00:11:56,079 --> 00:12:02,079
is the the filter in

00:11:59,279 --> 00:12:02,720
envoy so the filtering envoy has an api

00:12:02,079 --> 00:12:06,959
right

00:12:02,720 --> 00:12:10,000
and how we translate that into

00:12:06,959 --> 00:12:12,399
um code that the

00:12:10,000 --> 00:12:13,440
webassembly module will be able to

00:12:12,399 --> 00:12:15,920
understand

00:12:13,440 --> 00:12:17,680
is we have so first of all we need a an

00:12:15,920 --> 00:12:20,959
execution engine to be able to run

00:12:17,680 --> 00:12:23,680
webassembly and then we need a

00:12:20,959 --> 00:12:25,680
interface between the envoy filter and

00:12:23,680 --> 00:12:29,519
what envoy understands natively

00:12:25,680 --> 00:12:32,800
and the sandboxed webassembly

00:12:29,519 --> 00:12:35,839
vm right and so that's called

00:12:32,800 --> 00:12:37,680
the the application binary interface so

00:12:35,839 --> 00:12:40,399
you might see this term and so i'm

00:12:37,680 --> 00:12:41,279
covering it you might see this term when

00:12:40,399 --> 00:12:45,600
you start looking

00:12:41,279 --> 00:12:48,720
at building webassembly modules for

00:12:45,600 --> 00:12:51,760
for envoy and all the abi

00:12:48,720 --> 00:12:54,240
does is specifies a set of

00:12:51,760 --> 00:12:56,160
functions that can be imported into your

00:12:54,240 --> 00:13:00,639
webassembly module

00:12:56,160 --> 00:13:04,240
and functions that are exported

00:13:00,639 --> 00:13:07,279
so in other words you're

00:13:04,240 --> 00:13:10,720
only allowed to use and see a certain

00:13:07,279 --> 00:13:12,399
handful of functions for example to make

00:13:10,720 --> 00:13:14,079
external calls or something that envoy

00:13:12,399 --> 00:13:16,320
will allow you to use

00:13:14,079 --> 00:13:18,560
and then your application can implement

00:13:16,320 --> 00:13:20,720
these callbacks

00:13:18,560 --> 00:13:23,040
that on the you know the abi and the

00:13:20,720 --> 00:13:24,959
filters will actually call into

00:13:23,040 --> 00:13:26,160
now all this stuff sounds a little bit

00:13:24,959 --> 00:13:27,600
complicated

00:13:26,160 --> 00:13:28,959
but you shouldn't worry too much about

00:13:27,600 --> 00:13:30,160
that because this is this is what's

00:13:28,959 --> 00:13:32,639
happening in the

00:13:30,160 --> 00:13:34,959
envoy side what you are more interested

00:13:32,639 --> 00:13:37,360
in as a developer let's say

00:13:34,959 --> 00:13:38,639
you're interested in the sdks to kind of

00:13:37,360 --> 00:13:40,639
wrap this api

00:13:38,639 --> 00:13:43,360
and abstract some of these details away

00:13:40,639 --> 00:13:46,639
from you so there are sdks for

00:13:43,360 --> 00:13:49,680
c plus assembly script rust

00:13:46,639 --> 00:13:50,720
and tinygo to be able to write your

00:13:49,680 --> 00:13:54,320
applications

00:13:50,720 --> 00:13:57,680
in these languages compile them down

00:13:54,320 --> 00:14:00,839
into a webassembly module

00:13:57,680 --> 00:14:03,040
and inject that and run that in in

00:14:00,839 --> 00:14:06,399
existing um

00:14:03,040 --> 00:14:09,600
existing envoy so again the the

00:14:06,399 --> 00:14:11,279
sdks that have been built around this to

00:14:09,600 --> 00:14:14,560
abstract some of this detail

00:14:11,279 --> 00:14:16,320
are your entryway into building

00:14:14,560 --> 00:14:19,440
webassembly modules for

00:14:16,320 --> 00:14:22,560
onward so

00:14:19,440 --> 00:14:25,040
then the question becomes how do you

00:14:22,560 --> 00:14:28,320
start using these sdks

00:14:25,040 --> 00:14:30,399
how do you build these modules pull the

00:14:28,320 --> 00:14:32,560
correct tool chains and all this stuff

00:14:30,399 --> 00:14:34,880
to be able to build the modules

00:14:32,560 --> 00:14:35,680
uh and then when you build the modules

00:14:34,880 --> 00:14:37,360
how do you what

00:14:35,680 --> 00:14:38,880
what do you do how do you install them

00:14:37,360 --> 00:14:42,000
how do you uh

00:14:38,880 --> 00:14:43,519
maybe share them publish them and

00:14:42,000 --> 00:14:46,560
there's some interesting parallels

00:14:43,519 --> 00:14:49,600
here between the experience

00:14:46,560 --> 00:14:50,880
that we saw crop up around linux

00:14:49,600 --> 00:14:54,160
containers

00:14:50,880 --> 00:14:57,360
and the experience that we want with

00:14:54,160 --> 00:14:58,880
something like webassembly and this is a

00:14:57,360 --> 00:15:03,199
very important distinction

00:14:58,880 --> 00:15:05,120
because with linux linux containers

00:15:03,199 --> 00:15:07,040
and you know setting up c groups and

00:15:05,120 --> 00:15:09,040
namespaces all that stuff

00:15:07,040 --> 00:15:10,160
even that even lxc and some of those

00:15:09,040 --> 00:15:12,320
apis that built

00:15:10,160 --> 00:15:13,519
up around it initially they weren't all

00:15:12,320 --> 00:15:16,399
that well suited

00:15:13,519 --> 00:15:16,800
for the developer experience let's say

00:15:16,399 --> 00:15:18,800
uh

00:15:16,800 --> 00:15:20,399
and so that's where docker came in and

00:15:18,800 --> 00:15:21,680
you know built a nice api and nice

00:15:20,399 --> 00:15:24,800
developer experience around

00:15:21,680 --> 00:15:26,480
using containers and so that's what

00:15:24,800 --> 00:15:29,440
this open source project web assembly

00:15:26,480 --> 00:15:32,880
hub is aiming and trying to do for

00:15:29,440 --> 00:15:37,120
webassembly so we have this

00:15:32,880 --> 00:15:40,480
simple cli that allows you to quickly

00:15:37,120 --> 00:15:41,839
bootstrap a new web assembly for envoy

00:15:40,480 --> 00:15:44,639
project

00:15:41,839 --> 00:15:45,920
in a handful of different languages that

00:15:44,639 --> 00:15:48,079
you can choose

00:15:45,920 --> 00:15:49,680
and then it automates a lot of the

00:15:48,079 --> 00:15:51,279
boilerplate

00:15:49,680 --> 00:15:53,040
you know lining up the abi versions

00:15:51,279 --> 00:15:54,399
lining up the sdks

00:15:53,040 --> 00:15:56,480
finding all the tool chains that you

00:15:54,399 --> 00:15:59,839
need to properly build

00:15:56,480 --> 00:16:03,120
the applica the webassembly module

00:15:59,839 --> 00:16:06,240
we've also have a oci style and

00:16:03,120 --> 00:16:07,360
spec that describes what a webassembly

00:16:06,240 --> 00:16:08,320
module would look like once it's

00:16:07,360 --> 00:16:10,240
packaged

00:16:08,320 --> 00:16:12,240
and then you can take that publish it

00:16:10,240 --> 00:16:15,600
into an oci registry

00:16:12,240 --> 00:16:19,279
and share it and ultimately pull it down

00:16:15,600 --> 00:16:23,279
and install it into a running envoy

00:16:19,279 --> 00:16:26,240
framework like a service mesh

00:16:23,279 --> 00:16:27,680
so uh webassembly hub and the wazomi

00:16:26,240 --> 00:16:32,560
tool allow us to

00:16:27,680 --> 00:16:35,680
to do that and to get started let's say

00:16:32,560 --> 00:16:37,839
we go to firefox and go to the assembly

00:16:35,680 --> 00:16:37,839
hub

00:16:38,160 --> 00:16:42,480
to get started you can do so first of

00:16:40,880 --> 00:16:44,480
all you can you can come take a look at

00:16:42,480 --> 00:16:46,399
the web assembly hub you can see

00:16:44,480 --> 00:16:47,519
some of the web assembly modules that

00:16:46,399 --> 00:16:50,800
folks have been

00:16:47,519 --> 00:16:52,560
kicking the tires on you can come over

00:16:50,800 --> 00:16:56,480
here to the docks

00:16:52,560 --> 00:16:57,199
and get started so install the wisely

00:16:56,480 --> 00:16:59,920
tool

00:16:57,199 --> 00:17:01,600
tutorials for for getting started and

00:16:59,920 --> 00:17:04,640
and starting to build your uh

00:17:01,600 --> 00:17:05,919
your own project and and so forth and

00:17:04,640 --> 00:17:09,120
what we're going to take a look at is a

00:17:05,919 --> 00:17:11,679
demo here of

00:17:09,120 --> 00:17:12,480
of of us building out a webassembly

00:17:11,679 --> 00:17:14,640
module

00:17:12,480 --> 00:17:15,839
and going through this developer

00:17:14,640 --> 00:17:17,760
workflow

00:17:15,839 --> 00:17:19,199
and figuring out how do you deploy this

00:17:17,760 --> 00:17:22,160
to a

00:17:19,199 --> 00:17:23,679
running envoy based framework so let's

00:17:22,160 --> 00:17:26,240
take a look at that so

00:17:23,679 --> 00:17:27,199
again the demo we will be taking a look

00:17:26,240 --> 00:17:30,320
at

00:17:27,199 --> 00:17:33,360
webassembly hub and specifically the

00:17:30,320 --> 00:17:34,640
the cli tooling around getting started

00:17:33,360 --> 00:17:36,400
with a project

00:17:34,640 --> 00:17:38,080
building it and the whole life cycle

00:17:36,400 --> 00:17:40,559
around that

00:17:38,080 --> 00:17:41,600
so if you come to the docs here you can

00:17:40,559 --> 00:17:43,120
look in the

00:17:41,600 --> 00:17:44,880
installation and getting started

00:17:43,120 --> 00:17:48,080
tutorials building

00:17:44,880 --> 00:17:50,080
our different uh webassembly modules

00:17:48,080 --> 00:17:52,720
just a little bit outdated we have more

00:17:50,080 --> 00:17:54,000
uh languages that we support here so

00:17:52,720 --> 00:17:57,520
let's take a look

00:17:54,000 --> 00:18:01,120
at the at the demo so the

00:17:57,520 --> 00:18:04,000
cli that we would use to

00:18:01,120 --> 00:18:05,280
start get started with our webassembly

00:18:04,000 --> 00:18:06,799
experience here for

00:18:05,280 --> 00:18:08,400
especially for building for envoy is

00:18:06,799 --> 00:18:10,640
this wise me tool

00:18:08,400 --> 00:18:12,400
and with what what was me what we can do

00:18:10,640 --> 00:18:14,960
is create new projects

00:18:12,400 --> 00:18:15,760
we can build them deploy them to

00:18:14,960 --> 00:18:18,400
existing

00:18:15,760 --> 00:18:19,120
envoy-based frameworks and then we can

00:18:18,400 --> 00:18:22,320
also

00:18:19,120 --> 00:18:26,480
there's a workflow around pushing them

00:18:22,320 --> 00:18:28,799
and pulling them from a registry

00:18:26,480 --> 00:18:31,120
so let's take a look at building a

00:18:28,799 --> 00:18:34,400
webassembly module for envoy using

00:18:31,120 --> 00:18:36,080
using this developer experience for a

00:18:34,400 --> 00:18:39,600
couple different languages

00:18:36,080 --> 00:18:42,720
so if we do demo let's do

00:18:39,600 --> 00:18:44,559
tiny go

00:18:42,720 --> 00:18:46,240
let's take a look at our existing

00:18:44,559 --> 00:18:47,039
deployment we're going to be using istio

00:18:46,240 --> 00:18:49,520
for this

00:18:47,039 --> 00:18:51,600
we have the seo control plan deployed we

00:18:49,520 --> 00:18:54,960
also have the book info

00:18:51,600 --> 00:18:57,840
application running now if we

00:18:54,960 --> 00:18:58,960
make a call between the product page and

00:18:57,840 --> 00:19:02,720
the details

00:18:58,960 --> 00:19:05,120
service we see the call completes it's a

00:19:02,720 --> 00:19:06,799
it's an http call we've also dumped some

00:19:05,120 --> 00:19:09,360
of the headers what we're going to do

00:19:06,799 --> 00:19:10,000
in this demo is just create a

00:19:09,360 --> 00:19:14,320
webassembly

00:19:10,000 --> 00:19:16,240
module that extends the capability of

00:19:14,320 --> 00:19:18,960
either transforming headers or

00:19:16,240 --> 00:19:21,360
or adding new headers to the request or

00:19:18,960 --> 00:19:22,799
the response

00:19:21,360 --> 00:19:24,559
so the first thing we're going to do is

00:19:22,799 --> 00:19:26,799
we're going to build

00:19:24,559 --> 00:19:29,440
we're going to bootstrap a new project

00:19:26,799 --> 00:19:33,440
and we're going to use wisely init

00:19:29,440 --> 00:19:34,400
and then we're going to put it in a new

00:19:33,440 --> 00:19:36,000
directory

00:19:34,400 --> 00:19:38,080
and we're going to pick a language that

00:19:36,000 --> 00:19:40,080
we want to we want to use for this

00:19:38,080 --> 00:19:42,080
webassembly module so if i click on

00:19:40,080 --> 00:19:43,760
tiny go which is what we're going to use

00:19:42,080 --> 00:19:46,960
a subset of the golang

00:19:43,760 --> 00:19:48,480
language we will pick the platform

00:19:46,960 --> 00:19:50,960
that we want to target in this case it's

00:19:48,480 --> 00:19:54,320
istio 1.7

00:19:50,960 --> 00:19:57,039
and then it creates it now if we go in

00:19:54,320 --> 00:20:01,039
and open our project

00:19:57,039 --> 00:20:04,080
we can see we have

00:20:01,039 --> 00:20:07,200
um some of the boilerplate code already

00:20:04,080 --> 00:20:12,000
set up for us so all we have to do now

00:20:07,200 --> 00:20:15,039
is either go in and edit existing

00:20:12,000 --> 00:20:16,960
uh functions that that override uh so

00:20:15,039 --> 00:20:18,880
the callbacks that envoy will be calling

00:20:16,960 --> 00:20:22,480
into or we can add

00:20:18,880 --> 00:20:24,640
new ones that align with the sdk

00:20:22,480 --> 00:20:25,600
if we look at this runtime config json

00:20:24,640 --> 00:20:29,120
file this

00:20:25,600 --> 00:20:31,520
is a metadata file that

00:20:29,120 --> 00:20:33,120
is used in the packaging of this

00:20:31,520 --> 00:20:37,039
webassembly module as a

00:20:33,120 --> 00:20:40,320
oci style package

00:20:37,039 --> 00:20:43,280
so that's all good now let's say we want

00:20:40,320 --> 00:20:46,640
to build our project and turn that into

00:20:43,280 --> 00:20:48,720
a webassembly module so what we're going

00:20:46,640 --> 00:20:51,600
to do is run wasmi build

00:20:48,720 --> 00:20:52,799
we'll tell it what type of language

00:20:51,600 --> 00:20:55,360
we're using here

00:20:52,799 --> 00:20:56,720
and then we're going to tag it using a

00:20:55,360 --> 00:20:59,840
format that's similar

00:20:56,720 --> 00:21:03,039
or familiar to what you would do with

00:20:59,840 --> 00:21:07,840
other oci images and so we'll give that

00:21:03,039 --> 00:21:07,840
a few moments to complete

00:21:09,919 --> 00:21:17,840
well it downloads

00:21:17,919 --> 00:21:21,840
while we wait what this is going to do

00:21:19,440 --> 00:21:24,240
is download the the

00:21:21,840 --> 00:21:25,840
docker image as you can see it provides

00:21:24,240 --> 00:21:28,960
all of the

00:21:25,840 --> 00:21:30,799
right versions of go um the right

00:21:28,960 --> 00:21:36,480
versions of the sdk

00:21:30,799 --> 00:21:36,480
and builds everything consistently

00:21:39,440 --> 00:21:47,760
now it's still going

00:21:45,280 --> 00:21:50,960
almost there apologies i should have

00:21:47,760 --> 00:21:50,960
downloaded this ahead of time

00:21:51,120 --> 00:21:55,120
and there we go now we've downloaded the

00:21:54,159 --> 00:21:58,240
builder

00:21:55,120 --> 00:21:59,760
and and now we're going to build it we

00:21:58,240 --> 00:22:03,039
shouldn't take too long

00:21:59,760 --> 00:22:06,240
we're going to tag it using the

00:22:03,039 --> 00:22:08,720
the tag that we specified here and

00:22:06,240 --> 00:22:10,400
now we built the image if we take a look

00:22:08,720 --> 00:22:14,080
and and list it locally

00:22:10,400 --> 00:22:14,880
we can see that 0.14 of this ad header

00:22:14,080 --> 00:22:19,520
demo

00:22:14,880 --> 00:22:22,799
was built and is packaged

00:22:19,520 --> 00:22:24,960
as a oci style

00:22:22,799 --> 00:22:26,000
container and then from there what we

00:22:24,960 --> 00:22:28,799
can do is we can push

00:22:26,000 --> 00:22:30,480
that to a registry so in this case we're

00:22:28,799 --> 00:22:33,919
going to push this to

00:22:30,480 --> 00:22:36,720
the webassemblyhub.io registry if we

00:22:33,919 --> 00:22:36,720
go take a look

00:22:36,960 --> 00:22:41,520
if we log in under my name

00:22:39,890 --> 00:22:45,600
[Music]

00:22:41,520 --> 00:22:48,400
you can see our demo ad header

00:22:45,600 --> 00:22:50,000
uh repo that's been added here 0.14 is

00:22:48,400 --> 00:22:52,159
the one we just created

00:22:50,000 --> 00:22:54,559
if i click on tags we should see that

00:22:52,159 --> 00:23:00,159
indeed 0.14

00:22:54,559 --> 00:23:02,880
is is available as of 21 seconds ago

00:23:00,159 --> 00:23:03,679
so that's awesome right now we just

00:23:02,880 --> 00:23:07,679
built a

00:23:03,679 --> 00:23:11,120
extension to envoy using

00:23:07,679 --> 00:23:11,440
go or or tinyco subset of go we packaged

00:23:11,120 --> 00:23:14,640
it

00:23:11,440 --> 00:23:16,720
as a webassembly module

00:23:14,640 --> 00:23:18,799
we pushed it to a registry now that

00:23:16,720 --> 00:23:22,240
other other folks can

00:23:18,799 --> 00:23:25,360
can come to this uh this

00:23:22,240 --> 00:23:28,000
repo and explore the various different

00:23:25,360 --> 00:23:28,400
webassembly modules that that are you

00:23:28,000 --> 00:23:30,559
know

00:23:28,400 --> 00:23:31,520
other folks have been have been uh

00:23:30,559 --> 00:23:34,840
working on

00:23:31,520 --> 00:23:36,240
and you know experimenting with and so

00:23:34,840 --> 00:23:39,440
on

00:23:36,240 --> 00:23:41,520
and we're not limited to just c

00:23:39,440 --> 00:23:44,559
plus which is what envoy's written and

00:23:41,520 --> 00:23:46,880
we're not statically building this into

00:23:44,559 --> 00:23:48,559
the proxy this is dynamically loaded or

00:23:46,880 --> 00:23:51,840
will be when i show you that part

00:23:48,559 --> 00:23:53,520
uh let's let's do it again let's um

00:23:51,840 --> 00:23:55,120
as we set this let's pick a different

00:23:53,520 --> 00:23:59,360
language

00:23:55,120 --> 00:24:00,559
let's do assembly script

00:23:59,360 --> 00:24:02,400
all right so we have the same thing we

00:24:00,559 --> 00:24:04,240
have this deal running we have our book

00:24:02,400 --> 00:24:06,159
info demo running

00:24:04,240 --> 00:24:07,679
and when we make a call what we're going

00:24:06,159 --> 00:24:10,640
to do is we're going to

00:24:07,679 --> 00:24:11,919
insert one of these webassembly modules

00:24:10,640 --> 00:24:14,799
into

00:24:11,919 --> 00:24:16,000
the envoy proxy so we see headers here

00:24:14,799 --> 00:24:17,760
we don't see any

00:24:16,000 --> 00:24:19,200
additional headers yet so what we're

00:24:17,760 --> 00:24:21,600
going to do is we're going to

00:24:19,200 --> 00:24:23,279
do osmo init do the same workflow but

00:24:21,600 --> 00:24:24,960
now we're going to do it with

00:24:23,279 --> 00:24:27,360
assemblyscript which is a variant of

00:24:24,960 --> 00:24:30,640
typescript and we're going to pick

00:24:27,360 --> 00:24:30,640
the platform we're targeting

00:24:30,799 --> 00:24:34,640
and now if we open our project we see

00:24:32,960 --> 00:24:38,159
something like this

00:24:34,640 --> 00:24:40,720
we see our assembly assembly script

00:24:38,159 --> 00:24:42,080
source here which was automatically

00:24:40,720 --> 00:24:44,640
bootstrapped by wazmi

00:24:42,080 --> 00:24:45,760
the wasme tool we see the same runtime

00:24:44,640 --> 00:24:50,559
config

00:24:45,760 --> 00:24:50,559
packaging here so

00:24:50,640 --> 00:24:53,679
now if we

00:24:54,159 --> 00:24:57,039
build our project

00:24:58,960 --> 00:25:03,600
it'll use the same build

00:25:02,240 --> 00:25:05,279
build container that we did but now it's

00:25:03,600 --> 00:25:08,000
going to do this using

00:25:05,279 --> 00:25:09,679
npm and using javascript style build

00:25:08,000 --> 00:25:11,039
tools

00:25:09,679 --> 00:25:13,120
so we'll give that a moment shouldn't

00:25:11,039 --> 00:25:16,240
take too long we see it tagged

00:25:13,120 --> 00:25:20,559
again as 0.15 in this case

00:25:16,240 --> 00:25:22,720
if i list it we see 0.15

00:25:20,559 --> 00:25:24,000
the assembly script was in modules a

00:25:22,720 --> 00:25:27,360
little bit smaller

00:25:24,000 --> 00:25:29,760
than the golang one and now

00:25:27,360 --> 00:25:31,360
we can also push that one to the

00:25:29,760 --> 00:25:33,760
webassembly hub

00:25:31,360 --> 00:25:33,760
repo

00:25:36,559 --> 00:25:41,200
now what we want to do is actually

00:25:39,360 --> 00:25:45,360
deploy this

00:25:41,200 --> 00:25:49,600
to an envoy based framework

00:25:45,360 --> 00:25:52,480
so let's take a look again we'll call

00:25:49,600 --> 00:25:53,760
between product page and details we

00:25:52,480 --> 00:25:56,799
don't see any

00:25:53,760 --> 00:26:00,240
any headers there yet we're going to do

00:25:56,799 --> 00:26:02,720
is why does me deploy istio

00:26:00,240 --> 00:26:02,720
let me

00:26:03,520 --> 00:26:07,600
give that a second here i'm going to

00:26:04,720 --> 00:26:08,000
pause the the output this is a live demo

00:26:07,600 --> 00:26:09,440
so

00:26:08,000 --> 00:26:11,200
and it is typing but in the output's

00:26:09,440 --> 00:26:14,320
still going i just pause the output

00:26:11,200 --> 00:26:16,559
uh whilst we deploy istio the specific

00:26:14,320 --> 00:26:17,760
tag that we want and then any

00:26:16,559 --> 00:26:20,559
configuration

00:26:17,760 --> 00:26:21,600
that we that we want to give to it now

00:26:20,559 --> 00:26:26,400
sometimes there is

00:26:21,600 --> 00:26:30,000
ah take it um there's still a race

00:26:26,400 --> 00:26:34,960
condition that we are aware of

00:26:30,000 --> 00:26:34,960
here i'll give it a second

00:26:36,840 --> 00:26:39,840
um

00:26:42,640 --> 00:26:46,400
that is not very nice all right well

00:26:46,000 --> 00:26:50,720
let's

00:26:46,400 --> 00:26:50,720
let's let's try this again

00:26:51,200 --> 00:26:57,440
i should cross our fingers here

00:26:54,320 --> 00:27:00,159
all right there we go now it looks like

00:26:57,440 --> 00:27:01,919
it has taken so what this has done is is

00:27:00,159 --> 00:27:05,039
injected the webassembly module

00:27:01,919 --> 00:27:08,320
into each of the pods running in

00:27:05,039 --> 00:27:10,559
the book info namespace so in the

00:27:08,320 --> 00:27:14,000
bookinfo namespace we should see

00:27:10,559 --> 00:27:15,200
the output of our webassembly module

00:27:14,000 --> 00:27:19,360
which in this case

00:27:15,200 --> 00:27:22,880
really didn't do too much we just added

00:27:19,360 --> 00:27:25,440
a uh a new header when when we get the

00:27:22,880 --> 00:27:25,440
response

00:27:25,520 --> 00:27:29,440
so if that's the case now that my demo

00:27:28,880 --> 00:27:32,159
is not

00:27:29,440 --> 00:27:33,360
uh automated anymore let's let's first

00:27:32,159 --> 00:27:35,679
take a look at

00:27:33,360 --> 00:27:37,679
what what we created under the covers

00:27:35,679 --> 00:27:41,279
for istio so if i do

00:27:37,679 --> 00:27:43,279
get envoy filter book info

00:27:41,279 --> 00:27:45,440
what we see is we've created these

00:27:43,279 --> 00:27:48,240
booking or these envelope filters to

00:27:45,440 --> 00:27:49,520
patch the envoy proxies to load the wasa

00:27:48,240 --> 00:27:51,679
module

00:27:49,520 --> 00:27:53,120
if we actually take a look at one of

00:27:51,679 --> 00:27:56,159
these

00:27:53,120 --> 00:27:56,159
let's take a look

00:27:56,640 --> 00:28:01,120
we can see that we are adding a the wasm

00:28:00,080 --> 00:28:04,159
filter

00:28:01,120 --> 00:28:08,480
and that is calling out to

00:28:04,159 --> 00:28:10,799
a was a module so if that's the case

00:28:08,480 --> 00:28:12,640
then what we should see is when we call

00:28:10,799 --> 00:28:14,960
between product page

00:28:12,640 --> 00:28:16,000
and details what we should see across

00:28:14,960 --> 00:28:18,720
our fingers

00:28:16,000 --> 00:28:20,159
is this new header that we that we added

00:28:18,720 --> 00:28:22,960
so let's run this

00:28:20,159 --> 00:28:24,000
and indeed we do see the the new header

00:28:22,960 --> 00:28:26,880
that we've added

00:28:24,000 --> 00:28:28,960
with the with the specific configuration

00:28:26,880 --> 00:28:32,880
uh let's come back here

00:28:28,960 --> 00:28:34,880
we're using hello instead of world we're

00:28:32,880 --> 00:28:36,000
saying hello tomorrow and that's what we

00:28:34,880 --> 00:28:39,279
see in the

00:28:36,000 --> 00:28:41,919
request pathway so that's

00:28:39,279 --> 00:28:43,120
the extent of my my demo here i do

00:28:41,919 --> 00:28:45,039
encourage you to take a look at the

00:28:43,120 --> 00:28:48,559
webassembly hub tooling

00:28:45,039 --> 00:28:51,200
go ahead and take a look at istio

00:28:48,559 --> 00:28:52,320
and some of the service meshes that are

00:28:51,200 --> 00:28:56,000
supporting

00:28:52,320 --> 00:28:56,559
webassembly the caveat that i should

00:28:56,000 --> 00:28:59,600
point out

00:28:56,559 --> 00:29:01,919
is that webassembly in envoy was just

00:28:59,600 --> 00:29:04,320
recently merged into upstream

00:29:01,919 --> 00:29:05,200
up until now it's been on its own fork

00:29:04,320 --> 00:29:08,960
but

00:29:05,200 --> 00:29:10,960
it's recently merged into upstream it um

00:29:08,960 --> 00:29:12,960
it's in a state of let's just say it's

00:29:10,960 --> 00:29:15,039
still settling out a little bit

00:29:12,960 --> 00:29:17,120
it will i believe it'll be available in

00:29:15,039 --> 00:29:19,039
in envoy 1.17

00:29:17,120 --> 00:29:20,159
even then i still caution that this is

00:29:19,039 --> 00:29:23,520
still kind of

00:29:20,159 --> 00:29:24,480
new technology that will need some soak

00:29:23,520 --> 00:29:26,720
time so

00:29:24,480 --> 00:29:27,840
definitely experiment with it push the

00:29:26,720 --> 00:29:30,480
boundaries of it

00:29:27,840 --> 00:29:32,080
and the limits of it um and you know

00:29:30,480 --> 00:29:33,840
jump in and contribute in the community

00:29:32,080 --> 00:29:35,760
in terms of issues and

00:29:33,840 --> 00:29:36,880
um you know whatever experience that you

00:29:35,760 --> 00:29:40,640
have with

00:29:36,880 --> 00:29:43,919
webassembly and definitely feel free to

00:29:40,640 --> 00:29:46,399
reach out to us um or

00:29:43,919 --> 00:29:47,120
the the broader web assembly community

00:29:46,399 --> 00:29:48,960
for

00:29:47,120 --> 00:29:50,159
any thoughts or questions so thanks

00:29:48,960 --> 00:29:54,240
again for

00:29:50,159 --> 00:29:54,240

YouTube URL: https://www.youtube.com/watch?v=1qX3TK5DNIQ


