Title: Service Mesh Security in a Nutshell - Venil Noronha & Manish Chugtu, VMware, Inc.
Publication date: 2020-11-25
Playlist: ServiceMeshCon North America 2020
Description: 
	Service Mesh Security in a Nutshell - Venil Noronha & Manish Chugtu, VMware, Inc.

Security is one of the greatest challenges in the cloud-native world today. Service meshes promise several benefits including better connectivity, and observability, and most importantly security. Securing a cloud-native service involves securing it at several levels i.e. at the perimeter (ingress/egress gateways), when accessing other services, when persisting data, when processing requests, etc., and using a service mesh one can address several of these issues in a consistent and maintainable manner.  In this talk, we will present some of the key patterns that one can use for securing cloud-native services when working with north-south and east-west traffic. We will talk about available TLS choices (passthrough, mTLS, etc.), AuthN/AuthZ constructs, JWT support, and extension mechanisms within Envoy/Istio that you can leverage for building customized policy frameworks. We will also discuss application security in the context of multi-cluster service mesh deployments. Come join us!
Captions: 
	00:00:00,080 --> 00:00:03,919
thank you all for joining us today my

00:00:01,599 --> 00:00:04,240
name is vanilla and i work with manish

00:00:03,919 --> 00:00:06,879
on

00:00:04,240 --> 00:00:08,800
transit service mesh at vmware and today

00:00:06,879 --> 00:00:09,599
we will be talking about some security

00:00:08,800 --> 00:00:12,639
patterns

00:00:09,599 --> 00:00:14,559
in the context topic service mesh to

00:00:12,639 --> 00:00:15,200
begin with here is a very simple system

00:00:14,559 --> 00:00:17,920
where

00:00:15,200 --> 00:00:19,520
a user is sending requests to a service

00:00:17,920 --> 00:00:21,600
and those are being routed into the

00:00:19,520 --> 00:00:24,000
cluster through the ingress gateway

00:00:21,600 --> 00:00:25,439
now the english gateway then forwards

00:00:24,000 --> 00:00:27,680
these requests

00:00:25,439 --> 00:00:30,080
to a destination service like the user

00:00:27,680 --> 00:00:32,399
service or the location service

00:00:30,080 --> 00:00:33,760
and these can in turn make requests to

00:00:32,399 --> 00:00:36,320
each other

00:00:33,760 --> 00:00:38,079
the user service here is also storing

00:00:36,320 --> 00:00:40,320
data in the database

00:00:38,079 --> 00:00:42,160
while the location service accesses a

00:00:40,320 --> 00:00:44,800
third party api

00:00:42,160 --> 00:00:46,719
and therefore those requests are being

00:00:44,800 --> 00:00:49,920
routed outside of the cluster

00:00:46,719 --> 00:00:52,320
through the iges gateway let's now look

00:00:49,920 --> 00:00:55,600
at how we can secure the ingress

00:00:52,320 --> 00:00:56,640
using some of these patterns the first

00:00:55,600 --> 00:00:58,399
pattern here is

00:00:56,640 --> 00:00:59,760
very simple it's called authentication

00:00:58,399 --> 00:01:01,840
with tls

00:00:59,760 --> 00:01:02,879
what we do here is that we provision a

00:01:01,840 --> 00:01:05,040
certificate

00:01:02,879 --> 00:01:06,960
for the english gateway and these are

00:01:05,040 --> 00:01:08,880
programmed into the ingress gateway by

00:01:06,960 --> 00:01:12,000
the cluster administrator

00:01:08,880 --> 00:01:15,360
or the managing mesh and the user

00:01:12,000 --> 00:01:18,159
can use these search to perform tls

00:01:15,360 --> 00:01:20,080
communication with the ingress a

00:01:18,159 --> 00:01:23,280
slightly enhanced version of this

00:01:20,080 --> 00:01:24,320
is authentication with mtls where we

00:01:23,280 --> 00:01:27,759
also have a

00:01:24,320 --> 00:01:29,520
certificate for the requesting user

00:01:27,759 --> 00:01:32,240
and you can think of this user as some

00:01:29,520 --> 00:01:34,960
sort of a mobile client or a

00:01:32,240 --> 00:01:35,840
service that we want to establish trust

00:01:34,960 --> 00:01:37,680
on

00:01:35,840 --> 00:01:39,360
and therefore we have search for both

00:01:37,680 --> 00:01:42,799
the

00:01:39,360 --> 00:01:46,159
user requesting a particular endpoint

00:01:42,799 --> 00:01:46,159
and the gateway itself

00:01:46,479 --> 00:01:49,759
the third pattern here is called

00:01:47,920 --> 00:01:52,320
passthrough at the ingress

00:01:49,759 --> 00:01:53,600
where the tls is not terminated at the

00:01:52,320 --> 00:01:55,759
ingress itself

00:01:53,600 --> 00:01:57,200
but it is forwarded to the destination

00:01:55,759 --> 00:02:00,320
service in this case

00:01:57,200 --> 00:02:01,280
the user service so the user is sending

00:02:00,320 --> 00:02:03,280
requests

00:02:01,280 --> 00:02:06,479
and the english is looking at the sni

00:02:03,280 --> 00:02:10,239
header and forwarding these

00:02:06,479 --> 00:02:12,239
requests to the destination service and

00:02:10,239 --> 00:02:14,480
the challenge here is that in this

00:02:12,239 --> 00:02:16,800
gateway cannot do path based

00:02:14,480 --> 00:02:20,560
routing because it only looks at the s

00:02:16,800 --> 00:02:20,560
header and not the request itself

00:02:21,599 --> 00:02:24,800
the fourth pattern here is external

00:02:23,440 --> 00:02:27,280
authentication

00:02:24,800 --> 00:02:29,280
here what we do is we embed certain

00:02:27,280 --> 00:02:30,640
tokens like a jaw token or some other

00:02:29,280 --> 00:02:32,879
kind of a token

00:02:30,640 --> 00:02:34,800
in the user's request and the ingress

00:02:32,879 --> 00:02:37,360
gateway can then forward these

00:02:34,800 --> 00:02:38,160
tokens to a third party identity

00:02:37,360 --> 00:02:41,280
provider

00:02:38,160 --> 00:02:43,760
which can then verify these tokens and

00:02:41,280 --> 00:02:45,920
return a response to the gateway and the

00:02:43,760 --> 00:02:48,640
gateway can then consume this response

00:02:45,920 --> 00:02:49,440
and forward or deny the request based on

00:02:48,640 --> 00:02:54,560
whatever the

00:02:49,440 --> 00:02:54,560
identity provider response pattern

00:02:55,360 --> 00:02:59,200
now that the request enters has entered

00:02:57,440 --> 00:03:00,879
the mesh we can look at

00:02:59,200 --> 00:03:02,319
some of these mesh workload patterns

00:03:00,879 --> 00:03:06,159
which we can use for

00:03:02,319 --> 00:03:08,239
securing the services within the mesh

00:03:06,159 --> 00:03:10,000
the first pattern here here is called

00:03:08,239 --> 00:03:12,640
permissive mtls

00:03:10,000 --> 00:03:14,480
what this means is that the location

00:03:12,640 --> 00:03:15,360
service here which has this setting

00:03:14,480 --> 00:03:17,920
enabled

00:03:15,360 --> 00:03:19,519
will accept both mtls traffic as well as

00:03:17,920 --> 00:03:21,680
plain text traffic

00:03:19,519 --> 00:03:23,599
so the user service in this case is

00:03:21,680 --> 00:03:25,840
sending plain text requests

00:03:23,599 --> 00:03:27,360
to the location service which is okay

00:03:25,840 --> 00:03:29,280
and it accepts those

00:03:27,360 --> 00:03:30,799
and it will also accept any requests

00:03:29,280 --> 00:03:34,480
coming from a

00:03:30,799 --> 00:03:36,799
source service that our mdl is encrypted

00:03:34,480 --> 00:03:39,120
and this pattern actually allows you to

00:03:36,799 --> 00:03:39,760
migrate your workloads from a plain text

00:03:39,120 --> 00:03:42,319
mode to

00:03:39,760 --> 00:03:42,319
mtls

00:03:42,799 --> 00:03:47,120
for example the user service here can

00:03:44,720 --> 00:03:49,120
now migrate into mtls

00:03:47,120 --> 00:03:51,519
by having its own cert provisioned by

00:03:49,120 --> 00:03:55,280
the ca in the mesh

00:03:51,519 --> 00:03:58,239
or some some other ca and now

00:03:55,280 --> 00:03:59,439
you can also have strict mtls between

00:03:58,239 --> 00:04:02,080
these two

00:03:59,439 --> 00:04:03,599
services this basically means that you

00:04:02,080 --> 00:04:05,200
cannot have plain text coming

00:04:03,599 --> 00:04:07,680
in communication between these two

00:04:05,200 --> 00:04:07,680
services

00:04:08,319 --> 00:04:11,680
the third pattern here is called

00:04:09,840 --> 00:04:13,599
workload authorization where you

00:04:11,680 --> 00:04:16,320
essentially perform r back

00:04:13,599 --> 00:04:17,919
so we want to prevent access on the

00:04:16,320 --> 00:04:20,880
database service

00:04:17,919 --> 00:04:22,800
from any service that's not really a

00:04:20,880 --> 00:04:25,520
verified source

00:04:22,800 --> 00:04:26,000
in this case we want the user service to

00:04:25,520 --> 00:04:27,919
access

00:04:26,000 --> 00:04:29,280
the database service but not the

00:04:27,919 --> 00:04:31,440
location service

00:04:29,280 --> 00:04:32,320
we can use the namespace or some service

00:04:31,440 --> 00:04:34,400
labels

00:04:32,320 --> 00:04:35,600
we can look at the ip address or we can

00:04:34,400 --> 00:04:37,840
even look at

00:04:35,600 --> 00:04:38,800
the the service account on these

00:04:37,840 --> 00:04:43,840
services

00:04:38,800 --> 00:04:43,840
and enable these are back policies

00:04:44,800 --> 00:04:47,919
the next pattern here is end user

00:04:46,720 --> 00:04:50,880
authorization

00:04:47,919 --> 00:04:51,840
here what we do is we again look at the

00:04:50,880 --> 00:04:54,160
jot token

00:04:51,840 --> 00:04:56,720
in the incoming request and the english

00:04:54,160 --> 00:05:00,160
gateway can validate and forward these

00:04:56,720 --> 00:05:03,199
tokens to the destination service

00:05:00,160 --> 00:05:03,919
and now the destination service can have

00:05:03,199 --> 00:05:06,960
certain

00:05:03,919 --> 00:05:08,720
rules for example in this case we want

00:05:06,960 --> 00:05:09,759
the claim in the job token to at least

00:05:08,720 --> 00:05:13,120
match

00:05:09,759 --> 00:05:14,960
principal user here and such requests

00:05:13,120 --> 00:05:16,800
coming from this particular user

00:05:14,960 --> 00:05:19,600
will be allowed at the location service

00:05:16,800 --> 00:05:21,759
because the principle here is matching

00:05:19,600 --> 00:05:23,440
but in the case of the user service we

00:05:21,759 --> 00:05:26,479
don't allow such requests

00:05:23,440 --> 00:05:29,520
because the user only has a claim of

00:05:26,479 --> 00:05:33,120
principal user but we require principal

00:05:29,520 --> 00:05:33,120
admin for the user service

00:05:33,759 --> 00:05:37,039
last but not the least this is a very

00:05:35,199 --> 00:05:37,680
interesting pattern where you can extend

00:05:37,039 --> 00:05:40,800
these

00:05:37,680 --> 00:05:42,479
sidecar proxies using web assembly

00:05:40,800 --> 00:05:44,560
and what this means is that you can

00:05:42,479 --> 00:05:46,800
create your own custom plugins

00:05:44,560 --> 00:05:48,560
or you can have custom policies built

00:05:46,800 --> 00:05:51,360
into these sidecars

00:05:48,560 --> 00:05:52,080
and the incoming traffic can then be

00:05:51,360 --> 00:05:54,000
validated

00:05:52,080 --> 00:05:56,639
and authorized based on custom

00:05:54,000 --> 00:05:56,639
attributes

00:05:57,680 --> 00:06:01,600
now that the traffic has entered the

00:05:59,199 --> 00:06:04,880
mesh it's time for us to look at some

00:06:01,600 --> 00:06:04,880
egress gateway patterns

00:06:05,440 --> 00:06:08,720
so as the requests are leaving this mesh

00:06:08,160 --> 00:06:12,000
you can

00:06:08,720 --> 00:06:12,960
totally deny such requests by just

00:06:12,000 --> 00:06:17,039
enabling

00:06:12,960 --> 00:06:19,199
a flag that says um registry only in

00:06:17,039 --> 00:06:21,039
in the case of istio where all the side

00:06:19,199 --> 00:06:24,639
cars will deny

00:06:21,039 --> 00:06:26,319
all end points outside of the mesh

00:06:24,639 --> 00:06:28,479
and only the ones that have been

00:06:26,319 --> 00:06:31,600
registered in the registry

00:06:28,479 --> 00:06:31,600
will be allowed access

00:06:33,600 --> 00:06:37,759
the next pattern here is called tls pass

00:06:35,600 --> 00:06:40,160
through what we do here is we

00:06:37,759 --> 00:06:41,759
have tls origination done at the

00:06:40,160 --> 00:06:43,759
location service

00:06:41,759 --> 00:06:46,240
and the egress gateway is simply doing a

00:06:43,759 --> 00:06:46,240
pass through

00:06:46,960 --> 00:06:50,240
the next pattern here is kind of

00:06:48,960 --> 00:06:53,120
interesting because

00:06:50,240 --> 00:06:54,800
security administrators can easily apply

00:06:53,120 --> 00:06:56,479
this on the egress gateway

00:06:54,800 --> 00:06:58,000
so even though the traffic within your

00:06:56,479 --> 00:07:00,080
meshes plain text

00:06:58,000 --> 00:07:01,039
all the traffic leaving the cluster can

00:07:00,080 --> 00:07:04,720
be

00:07:01,039 --> 00:07:07,919
encrypted using tls using this tls

00:07:04,720 --> 00:07:07,919
origination at the egress

00:07:08,479 --> 00:07:12,720
and the last pattern here is mtls

00:07:11,199 --> 00:07:14,319
origination at the igris

00:07:12,720 --> 00:07:16,560
which is very similar to the tls

00:07:14,319 --> 00:07:17,039
origination just that we will also

00:07:16,560 --> 00:07:20,800
verify

00:07:17,039 --> 00:07:20,800
verify the destination workload

00:07:21,599 --> 00:07:24,880
now i will hand it over to manish who

00:07:23,360 --> 00:07:28,240
will be talking about some advanced

00:07:24,880 --> 00:07:28,240
patterns in service mesh

00:07:29,120 --> 00:07:32,400
thanks reynold for going to an example

00:07:30,880 --> 00:07:34,720
to show how service mesh provides

00:07:32,400 --> 00:07:36,160
security at various levels

00:07:34,720 --> 00:07:39,120
whether it's to do with certificate

00:07:36,160 --> 00:07:40,880
management or authentication at an end

00:07:39,120 --> 00:07:42,080
user level or between two services

00:07:40,880 --> 00:07:44,080
within the mesh

00:07:42,080 --> 00:07:45,919
or authorization to control access to

00:07:44,080 --> 00:07:47,680
the services

00:07:45,919 --> 00:07:49,840
but what comprises of an application

00:07:47,680 --> 00:07:51,840
these days is a little complex than the

00:07:49,840 --> 00:07:54,560
example that we talked about

00:07:51,840 --> 00:07:55,680
usually it is a set of services which

00:07:54,560 --> 00:07:57,520
are not only deployed

00:07:55,680 --> 00:08:00,160
and communicating within a single

00:07:57,520 --> 00:08:00,879
cluster but across multiple clusters

00:08:00,160 --> 00:08:03,599
clouds

00:08:00,879 --> 00:08:04,960
or even infrastructures so how do we

00:08:03,599 --> 00:08:06,800
extend service mesh

00:08:04,960 --> 00:08:08,720
and how do we secure communications

00:08:06,800 --> 00:08:12,560
between services across clusters

00:08:08,720 --> 00:08:15,840
for example the two common patterns

00:08:12,560 --> 00:08:16,800
that we see are that ingress and egress

00:08:15,840 --> 00:08:18,240
gateways through which the

00:08:16,800 --> 00:08:20,560
communications happen

00:08:18,240 --> 00:08:22,720
are mutually authenticated and the

00:08:20,560 --> 00:08:24,960
traffic is encrypted between them

00:08:22,720 --> 00:08:26,800
the traffic between the services to the

00:08:24,960 --> 00:08:30,080
gateway within each of the clusters may

00:08:26,800 --> 00:08:30,080
or may not be encrypted

00:08:30,240 --> 00:08:33,839
the second pattern that we see is that

00:08:32,240 --> 00:08:35,760
services themselves are mutually

00:08:33,839 --> 00:08:37,360
authenticated across clusters

00:08:35,760 --> 00:08:39,599
in this case the gateways are configured

00:08:37,360 --> 00:08:40,320
in the pass-through mode and routing is

00:08:39,599 --> 00:08:44,159
done

00:08:40,320 --> 00:08:46,720
based on sni in both these cases though

00:08:44,159 --> 00:08:48,480
there is a requirement of a common group

00:08:46,720 --> 00:08:51,360
where the local cas on individual

00:08:48,480 --> 00:08:52,959
clusters now act as intermediates

00:08:51,360 --> 00:08:54,959
this is normally done by some kind of

00:08:52,959 --> 00:08:57,200
automation or an external global

00:08:54,959 --> 00:08:59,200
controller which manages and extends the

00:08:57,200 --> 00:09:01,120
service mesh

00:08:59,200 --> 00:09:03,200
now getting back to within the mesh when

00:09:01,120 --> 00:09:06,640
we talked about how we can define

00:09:03,200 --> 00:09:08,560
find vein our back day back by utilizing

00:09:06,640 --> 00:09:09,519
the workload identities provided by the

00:09:08,560 --> 00:09:11,360
mesh

00:09:09,519 --> 00:09:12,560
or the intrinsic attributes that have

00:09:11,360 --> 00:09:13,600
either been released through the

00:09:12,560 --> 00:09:15,519
transaction

00:09:13,600 --> 00:09:17,200
or gathered by inspecting the traffic at

00:09:15,519 --> 00:09:18,800
every hop

00:09:17,200 --> 00:09:20,320
we're also seeing a pattern where the

00:09:18,800 --> 00:09:21,680
service mesh capabilities are being

00:09:20,320 --> 00:09:24,080
extended to derive more

00:09:21,680 --> 00:09:25,839
intelligence using third party proxy

00:09:24,080 --> 00:09:28,240
filters or plugins

00:09:25,839 --> 00:09:29,360
or analysis tools which enable use cases

00:09:28,240 --> 00:09:31,519
like laugh

00:09:29,360 --> 00:09:32,720
thread detection or even compliance

00:09:31,519 --> 00:09:34,720
checks

00:09:32,720 --> 00:09:36,480
this helps in defining advanced

00:09:34,720 --> 00:09:38,160
authorization policies

00:09:36,480 --> 00:09:40,080
which not only take into consideration

00:09:38,160 --> 00:09:41,200
the intrinsic service attributes like we

00:09:40,080 --> 00:09:43,360
talked about

00:09:41,200 --> 00:09:45,200
but also take into consideration the

00:09:43,360 --> 00:09:47,440
whole security posture

00:09:45,200 --> 00:09:49,680
of the complete and doing transaction

00:09:47,440 --> 00:09:51,920
which is comprised of user attributes

00:09:49,680 --> 00:09:53,519
in the data that service is accessing

00:09:51,920 --> 00:09:56,000
view of the user

00:09:53,519 --> 00:09:57,040
threat and anomaly detection and in the

00:09:56,000 --> 00:09:58,640
compliance level

00:09:57,040 --> 00:10:00,399
of the resources that participate in

00:09:58,640 --> 00:10:02,640
this transaction

00:10:00,399 --> 00:10:05,680
this kind of enables service mesh to do

00:10:02,640 --> 00:10:07,920
dynamic and continuous risk assessment

00:10:05,680 --> 00:10:09,120
and we can see how it evolves security

00:10:07,920 --> 00:10:13,279
towards

00:10:09,120 --> 00:10:14,640
a continuous risk based zero trust model

00:10:13,279 --> 00:10:16,480
with that we come to the end of the

00:10:14,640 --> 00:10:18,240
presentation thank you so much for

00:10:16,480 --> 00:10:22,480
joining and for your attention

00:10:18,240 --> 00:10:22,480

YouTube URL: https://www.youtube.com/watch?v=liu51fCC3N4


