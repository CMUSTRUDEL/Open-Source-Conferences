Title: Lightning Talk: Towards supporting backward compatibility - Andrew Noyes , Snowflake Computing
Publication date: 2018-12-14
Playlist: FoundationDB Summit 2018
Description: 
	FoundationDB's serialization library provides an abstraction that allows it to be replaced with a new serialization format without changing (much) client code. In this talk, Andrew will describe a flatbuffers implementation that is nearly a drop-in replace for the current serialization, and how it allows rolling upgrades and backward compatibility. Andrew will also describe how this might be tested in the simulator.
Captions: 
	00:00:00,030 --> 00:00:04,799
hi everybody I'm Andrew from snowflake

00:00:02,460 --> 00:00:07,500
computing working on the foundation to

00:00:04,799 --> 00:00:11,040
be development team and I will be

00:00:07,500 --> 00:00:13,830
talking about so kind of the way that

00:00:11,040 --> 00:00:16,680
internal FDB types get serialized and

00:00:13,830 --> 00:00:18,060
sent across the wire or stored as values

00:00:16,680 --> 00:00:22,199
in the database itself or stored on

00:00:18,060 --> 00:00:25,470
files but for motivation

00:00:22,199 --> 00:00:29,099
availability of foundation DB DB is very

00:00:25,470 --> 00:00:30,570
important for snowflake if you know

00:00:29,099 --> 00:00:36,540
foundation DB is down that the snowflake

00:00:30,570 --> 00:00:38,070
is down and so sort of the reason I'm

00:00:36,540 --> 00:00:39,780
talking about this is that the the

00:00:38,070 --> 00:00:43,260
current serialization format does not

00:00:39,780 --> 00:00:44,820
support schema evolution kind of the way

00:00:43,260 --> 00:00:47,070
it works the way to think about it is if

00:00:44,820 --> 00:00:49,649
you have a message with two types or two

00:00:47,070 --> 00:00:53,579
fields a and B it serializes a and B and

00:00:49,649 --> 00:00:58,079
concatenates it currently so if you want

00:00:53,579 --> 00:00:59,430
to add a third field that's well really

00:00:58,079 --> 00:01:01,370
work it'll if you read it with something

00:00:59,430 --> 00:01:05,040
that expects only two fields it'll

00:01:01,370 --> 00:01:10,100
something lapin I don't you know you

00:01:05,040 --> 00:01:12,360
don't want that okay so yeah so

00:01:10,100 --> 00:01:14,869
currently what that means is that two

00:01:12,360 --> 00:01:17,369
foundation DB processes need to have the

00:01:14,869 --> 00:01:19,860
sort of same protocol version to talk to

00:01:17,369 --> 00:01:21,570
each other for introducing protocol

00:01:19,860 --> 00:01:23,189
versions this isn't such a big problem

00:01:21,570 --> 00:01:26,400
because you can have the new guy

00:01:23,189 --> 00:01:28,920
understand both protocol versions but

00:01:26,400 --> 00:01:30,869
for sort of downgrading back to the old

00:01:28,920 --> 00:01:33,990
guy if there's something say written to

00:01:30,869 --> 00:01:38,490
a file with the new protocol version the

00:01:33,990 --> 00:01:40,590
old binary won't be able to read it so

00:01:38,490 --> 00:01:44,540
that's why I downgrading a cluster is

00:01:40,590 --> 00:01:49,079
not supported one of the reasons okay so

00:01:44,540 --> 00:01:50,430
we implemented a serial is eight we have

00:01:49,079 --> 00:01:54,000
an implementation of flatbuffers that

00:01:50,430 --> 00:01:56,040
works with foundation DB types so here

00:01:54,000 --> 00:02:00,149
we kind of have this idiom used in

00:01:56,040 --> 00:02:04,110
foundation DB for serialization it's a

00:02:00,149 --> 00:02:08,190
lot like a visitor pattern and so our

00:02:04,110 --> 00:02:11,420
flatbuffers implantation sort of it also

00:02:08,190 --> 00:02:14,880
works with with this idiom

00:02:11,420 --> 00:02:17,700
so so flatbuffers what we're looking at

00:02:14,880 --> 00:02:21,090
it because it's um it's already

00:02:17,700 --> 00:02:23,280
documented for one so that's good and so

00:02:21,090 --> 00:02:25,290
we didn't want to design our own kind of

00:02:23,280 --> 00:02:27,690
custom thing to get schema evolution we

00:02:25,290 --> 00:02:33,750
wanted to sort of go with something

00:02:27,690 --> 00:02:35,940
that's has a lot of use right okay so

00:02:33,750 --> 00:02:39,690
where where would be good applications

00:02:35,940 --> 00:02:41,209
for flatbuffers so even if you don't

00:02:39,690 --> 00:02:44,940
want to do anything like online upgrade

00:02:41,209 --> 00:02:46,890
if you want to do just a normal upgrade

00:02:44,940 --> 00:02:49,769
where you read something say from the

00:02:46,890 --> 00:02:52,500
disk that was serialized by an older

00:02:49,769 --> 00:02:54,660
version this would be good there because

00:02:52,500 --> 00:02:57,989
then you could downgrade kind of like I

00:02:54,660 --> 00:02:59,849
was describing before also if you are

00:02:57,989 --> 00:03:03,950
writing something into the database

00:02:59,849 --> 00:03:06,450
itself as a value the same thing applies

00:03:03,950 --> 00:03:08,849
and this also could be useful for

00:03:06,450 --> 00:03:12,750
network messages if you want to support

00:03:08,849 --> 00:03:15,150
something like online upgrading and so

00:03:12,750 --> 00:03:18,420
kind of for an example here let's say

00:03:15,150 --> 00:03:19,829
you want to you have a new binary and

00:03:18,420 --> 00:03:23,400
you want to see what happens if you just

00:03:19,829 --> 00:03:27,120
enable it on one storage node if you

00:03:23,400 --> 00:03:30,049
were using flatbuffers and this won't

00:03:27,120 --> 00:03:32,430
cause a recovery right because if if you

00:03:30,049 --> 00:03:38,569
take down a storage node that won't

00:03:32,430 --> 00:03:38,569
cause a recovery so let's see

00:03:40,000 --> 00:03:47,420
right so so you can interoperate with

00:03:42,950 --> 00:03:52,940
the old okay let's say let's say let's

00:03:47,420 --> 00:03:57,890
say you do it and you you see a CPU

00:03:52,940 --> 00:03:59,930
regression you can you can kind of just

00:03:57,890 --> 00:04:01,370
try upgrading one storage at a time to

00:03:59,930 --> 00:04:03,410
and just see what happens and that's not

00:04:01,370 --> 00:04:06,680
really something supported with the

00:04:03,410 --> 00:04:09,440
current protocol okay so where is this

00:04:06,680 --> 00:04:10,790
where is this not a good idea okay so if

00:04:09,440 --> 00:04:13,070
you're going to write database Keys

00:04:10,790 --> 00:04:16,400
flatbuffers is not going to preserve the

00:04:13,070 --> 00:04:19,610
ordering of what you are reading and you

00:04:16,400 --> 00:04:21,560
often want to sort of have the

00:04:19,610 --> 00:04:26,510
serialized by it's maintain the ordering

00:04:21,560 --> 00:04:29,000
of the original type and for streaming

00:04:26,510 --> 00:04:31,790
messages the the current protocol has

00:04:29,000 --> 00:04:34,250
this property that if you know what the

00:04:31,790 --> 00:04:37,010
type is and you have the byte sequence

00:04:34,250 --> 00:04:39,410
and you and you serialize it it will

00:04:37,010 --> 00:04:41,210
consume the right number bytes and start

00:04:39,410 --> 00:04:46,010
right at the beginning of the next

00:04:41,210 --> 00:04:47,570
message flatbuffers also pop-up

00:04:46,010 --> 00:04:52,400
flatbuffers does not have this property

00:04:47,570 --> 00:04:57,050
so you need some some other protocol to

00:04:52,400 --> 00:04:58,790
encapsulate the flatbuffers message okay

00:04:57,050 --> 00:05:01,370
oh that's when I was going to talk about

00:04:58,790 --> 00:05:06,670
it sergeant okay so how does this prove

00:05:01,370 --> 00:05:13,370
availability what I described earlier

00:05:06,670 --> 00:05:15,500
basically you could do something less

00:05:13,370 --> 00:05:16,910
drastic than taking or like stopping

00:05:15,500 --> 00:05:18,710
with a cluster and bringing it up and

00:05:16,910 --> 00:05:22,760
seeing what happens you can do something

00:05:18,710 --> 00:05:26,810
with just one note at a time so if there

00:05:22,760 --> 00:05:33,950
is a CPU regression you won't cause an

00:05:26,810 --> 00:05:35,720
unavailability okay so so testing we've

00:05:33,950 --> 00:05:38,930
talked about testing in foundation to be

00:05:35,720 --> 00:05:42,440
a lot today what we have for testing

00:05:38,930 --> 00:05:46,600
this so far is we can test it on a live

00:05:42,440 --> 00:05:49,669
foundation DB cluster by kind of having

00:05:46,600 --> 00:05:52,940
you know one binary with one version of

00:05:49,669 --> 00:05:53,660
the message and another with an earlier

00:05:52,940 --> 00:05:55,850
version say

00:05:53,660 --> 00:05:57,530
and kind of upgrade one thing and see

00:05:55,850 --> 00:05:59,020
what happens but we really want those to

00:05:57,530 --> 00:06:03,200
be able to do this in the simulator and

00:05:59,020 --> 00:06:05,000
what we've been able to do and we've had

00:06:03,200 --> 00:06:07,820
some success with this is building FDB

00:06:05,000 --> 00:06:11,510
server as a shared library and then DL

00:06:07,820 --> 00:06:14,390
opening it so that a simulator can

00:06:11,510 --> 00:06:16,310
basically kind of start a new FDB server

00:06:14,390 --> 00:06:19,610
process in the simulator at either

00:06:16,310 --> 00:06:22,850
version but this gets a little tricky

00:06:19,610 --> 00:06:25,490
because the like if there's any changes

00:06:22,850 --> 00:06:32,060
to the simulator itself or any global

00:06:25,490 --> 00:06:33,320
used then it you know it's it's not it

00:06:32,060 --> 00:06:35,780
wasn't really set up like that so you

00:06:33,320 --> 00:06:42,440
need to be aware of that if you want to

00:06:35,780 --> 00:06:45,290
support this yeah I think that was all

00:06:42,440 --> 00:06:50,330
there okay cool so if you have any

00:06:45,290 --> 00:06:56,449
questions grab me after that's all

00:06:50,330 --> 00:06:56,449

YouTube URL: https://www.youtube.com/watch?v=Z1IbfjHGi78


