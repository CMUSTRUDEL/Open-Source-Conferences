Title: Autonomous Testing and the Future of Software Development - Will Wilson
Publication date: 2018-12-14
Playlist: FoundationDB Summit 2018
Description: 
	
Captions: 
	00:00:00,030 --> 00:00:09,599
ah there we go thank you

00:00:04,950 --> 00:00:11,730
sorry about that so yeah as Dave said my

00:00:09,599 --> 00:00:14,040
name's will I worked at Foundation DB

00:00:11,730 --> 00:00:16,740
way back in the ancient mists of time

00:00:14,040 --> 00:00:19,140
and I'm now doing something a little bit

00:00:16,740 --> 00:00:22,619
different I'm here to talk about the

00:00:19,140 --> 00:00:25,320
future of software development what on

00:00:22,619 --> 00:00:26,460
earth could I mean by that well as

00:00:25,320 --> 00:00:28,680
somebody who is asked to give a

00:00:26,460 --> 00:00:30,449
big-picture talk at a software

00:00:28,680 --> 00:00:32,880
conference I believe I'm contractually

00:00:30,449 --> 00:00:37,380
obligated to begin with a slide

00:00:32,880 --> 00:00:39,870
depicting Moore's law and also my

00:00:37,380 --> 00:00:42,090
pointer doesn't work okay there it is

00:00:39,870 --> 00:00:45,090
Moore's law clearly you can see here

00:00:42,090 --> 00:00:46,680
we've got years on the x-axis there and

00:00:45,090 --> 00:00:49,170
we've got clock speed on the y-axis

00:00:46,680 --> 00:00:50,940
right and as you can clearly see it's

00:00:49,170 --> 00:00:54,300
going up and to the right kind of

00:00:50,940 --> 00:00:56,910
exponentially and well hold on a second

00:00:54,300 --> 00:00:59,430
you sure that's the did we get the right

00:00:56,910 --> 00:01:02,070
slide is this is this the Moore's law is

00:00:59,430 --> 00:01:04,650
that is that clock speed or is that is

00:01:02,070 --> 00:01:06,570
that harddrive density or maybe oh my

00:01:04,650 --> 00:01:09,360
goodness it's weaving and spinning

00:01:06,570 --> 00:01:12,510
productivity that's I wasn't expecting

00:01:09,360 --> 00:01:14,070
that that's that's really weird there

00:01:12,510 --> 00:01:16,500
must have been some kind of mix-up okay

00:01:14,070 --> 00:01:17,130
let's let's try this again okay oh yeah

00:01:16,500 --> 00:01:18,659
yeah here we go

00:01:17,130 --> 00:01:20,700
that's that's totally the Moore's Law

00:01:18,659 --> 00:01:22,950
slide you've got that nice logarithmic

00:01:20,700 --> 00:01:27,060
y-axis there you see that yeah that's uh

00:01:22,950 --> 00:01:29,460
what it's steam engine efficiency what

00:01:27,060 --> 00:01:32,780
what is going on here all right let's

00:01:29,460 --> 00:01:36,920
let's try one more time okay all right

00:01:32,780 --> 00:01:36,920
anybody want to guess what this one is

00:01:37,220 --> 00:01:43,110
okay I'll give you a hint the x-axis

00:01:40,290 --> 00:01:48,390
here is the actual years along which

00:01:43,110 --> 00:01:51,770
Moore's Law actually did operate now all

00:01:48,390 --> 00:01:55,259
right it's actually industrial diamonds

00:01:51,770 --> 00:01:57,259
so why have I wasted your time with

00:01:55,259 --> 00:02:00,899
three different graphs all of which are

00:01:57,259 --> 00:02:02,909
not Moore's Law the reason is I think we

00:02:00,899 --> 00:02:04,979
in the software industry or in the

00:02:02,909 --> 00:02:06,659
computing industry more broadly have a

00:02:04,979 --> 00:02:09,360
little bit of a tendency to think that

00:02:06,659 --> 00:02:12,420
were special we think there were somehow

00:02:09,360 --> 00:02:13,360
different from every other technological

00:02:12,420 --> 00:02:16,030
endeavor that

00:02:13,360 --> 00:02:17,800
mankind has engaged in and something

00:02:16,030 --> 00:02:20,200
that people point out a lot is this

00:02:17,800 --> 00:02:22,090
Moore's law thing people say where else

00:02:20,200 --> 00:02:25,060
in human history has there ever been

00:02:22,090 --> 00:02:26,530
this exponential increase in the

00:02:25,060 --> 00:02:29,140
capabilities of the underlying hardware

00:02:26,530 --> 00:02:31,210
of what we're doing and the answer as

00:02:29,140 --> 00:02:33,580
I'm hope I've convinced you is actually

00:02:31,210 --> 00:02:37,420
everywhere it's incredibly incredibly

00:02:33,580 --> 00:02:40,000
common at first and the reason is that

00:02:37,420 --> 00:02:42,940
exponential growth is really really easy

00:02:40,000 --> 00:02:45,760
when what you have is really really

00:02:42,940 --> 00:02:48,490
primitive and so the fact that we

00:02:45,760 --> 00:02:52,450
observe this Moore's Law relationship

00:02:48,490 --> 00:02:54,670
maybe still is actually not telling us

00:02:52,450 --> 00:02:57,550
that software is special it's telling us

00:02:54,670 --> 00:02:58,840
that software is early right it's

00:02:57,550 --> 00:03:00,670
telling us that we're at the beginning

00:02:58,840 --> 00:03:02,350
that we haven't trailed off yet into a

00:03:00,670 --> 00:03:04,750
logistic curve which is what usually

00:03:02,350 --> 00:03:06,700
happens in technology and I actually

00:03:04,750 --> 00:03:10,720
find this fact to be incredibly

00:03:06,700 --> 00:03:13,030
empowering right it means it means we we

00:03:10,720 --> 00:03:14,760
get the chance to be pioneers too it

00:03:13,030 --> 00:03:17,350
means those guys in the 60s and the 70s

00:03:14,760 --> 00:03:19,930
didn't have all the fun it means there's

00:03:17,350 --> 00:03:22,269
a lot more to do and I think one

00:03:19,930 --> 00:03:24,610
implication of this is it also means

00:03:22,269 --> 00:03:27,820
that we should be looking for the

00:03:24,610 --> 00:03:30,280
possibilities of radical transformations

00:03:27,820 --> 00:03:33,790
in software engineering right things

00:03:30,280 --> 00:03:35,410
that will completely change how what it

00:03:33,790 --> 00:03:37,600
means to be a software engineer what it

00:03:35,410 --> 00:03:39,880
means to write programs there's a couple

00:03:37,600 --> 00:03:41,980
reasons for this one is because we're

00:03:39,880 --> 00:03:44,350
early in history and so therefore

00:03:41,980 --> 00:03:46,930
there's still low-hanging fruit another

00:03:44,350 --> 00:03:48,910
is that we're early in history and what

00:03:46,930 --> 00:03:51,010
that means is that the vast majority of

00:03:48,910 --> 00:03:52,690
software is not written yet it can be

00:03:51,010 --> 00:03:55,420
written in the future which means that

00:03:52,690 --> 00:03:57,430
if we make process improvements now they

00:03:55,420 --> 00:03:59,380
have a very long time horizon over which

00:03:57,430 --> 00:04:02,200
they can pay off I think both of those

00:03:59,380 --> 00:04:04,030
facts argue in favor of us taking a

00:04:02,200 --> 00:04:07,120
really serious and hard look and

00:04:04,030 --> 00:04:09,010
re-examining what it is we do and so

00:04:07,120 --> 00:04:10,570
that's meaning behind the title of my

00:04:09,010 --> 00:04:13,329
talk the future of software engineering

00:04:10,570 --> 00:04:15,790
I think the future is out there in front

00:04:13,329 --> 00:04:20,590
of us we're not there yet but maybe

00:04:15,790 --> 00:04:22,870
maybe we will help create it ok so right

00:04:20,590 --> 00:04:24,789
so the future there's a lot of different

00:04:22,870 --> 00:04:26,260
possible radical transformations I could

00:04:24,789 --> 00:04:28,530
talk about right I could

00:04:26,260 --> 00:04:31,270
about new programming languages and how

00:04:28,530 --> 00:04:33,370
something from category theory is gonna

00:04:31,270 --> 00:04:35,590
totally change how everybody does

00:04:33,370 --> 00:04:37,780
everything might be true that would be a

00:04:35,590 --> 00:04:40,240
radical transformation if it worked or I

00:04:37,780 --> 00:04:43,180
could talk about the sociology and

00:04:40,240 --> 00:04:45,250
economics of software how who becomes a

00:04:43,180 --> 00:04:47,410
software engineer might be changing

00:04:45,250 --> 00:04:48,940
drastically that could be a radical

00:04:47,410 --> 00:04:50,530
transformation of the software industry

00:04:48,940 --> 00:04:52,690
but I'm talking not going to talk about

00:04:50,530 --> 00:04:56,700
either of those things instead I'm gonna

00:04:52,690 --> 00:04:59,830
talk about testing yeah right because

00:04:56,700 --> 00:05:01,720
why because if you want to look for the

00:04:59,830 --> 00:05:03,670
potential for radical transformations

00:05:01,720 --> 00:05:06,100
one way of doing that one pretty good

00:05:03,670 --> 00:05:09,190
heuristic is to look at where things are

00:05:06,100 --> 00:05:12,850
currently the most absolutely awful and

00:05:09,190 --> 00:05:14,800
terrible and painstaking and brutal and

00:05:12,850 --> 00:05:18,790
I think testing kind of qualifies right

00:05:14,800 --> 00:05:22,510
I saw a report from some analysts it was

00:05:18,790 --> 00:05:26,680
like Gartner forced or somebody they

00:05:22,510 --> 00:05:29,080
estimated that 30% of all effort in

00:05:26,680 --> 00:05:32,740
software development was spent on

00:05:29,080 --> 00:05:34,360
testing or on QA more broadly and if

00:05:32,740 --> 00:05:37,240
you're like me you hear that number and

00:05:34,360 --> 00:05:40,060
you're like thirty percent that's way

00:05:37,240 --> 00:05:41,950
way way too low right well I guess like

00:05:40,060 --> 00:05:44,320
you add together the amount of time you

00:05:41,950 --> 00:05:46,120
spend writing tests the amount of time

00:05:44,320 --> 00:05:48,040
you spend fixing the bugs that your

00:05:46,120 --> 00:05:49,660
tests turn up the amount of time you

00:05:48,040 --> 00:05:52,150
spend fixing the bugs your tests don't

00:05:49,660 --> 00:05:54,450
turn up the amount of time you spend

00:05:52,150 --> 00:05:56,920
working around and dealing with and

00:05:54,450 --> 00:05:59,320
mitigating all the bugs in the layers

00:05:56,920 --> 00:06:03,100
below you that they haven't fixed those

00:05:59,320 --> 00:06:04,750
jerks all the time and effort that goes

00:06:03,100 --> 00:06:06,820
into dealing with the fallout of

00:06:04,750 --> 00:06:09,310
inadequate testing the outages the

00:06:06,820 --> 00:06:12,430
economic damage right like that's like

00:06:09,310 --> 00:06:14,980
we're talking at least 50% of my time

00:06:12,430 --> 00:06:17,410
and I don't think I'm extremely unusual

00:06:14,980 --> 00:06:19,270
and you multiply that by a lot of

00:06:17,410 --> 00:06:22,150
software engineers in the world we are

00:06:19,270 --> 00:06:26,370
talking about trillions and trillions of

00:06:22,150 --> 00:06:29,320
dollars of productivity going into this

00:06:26,370 --> 00:06:32,440
if you could take that and you could

00:06:29,320 --> 00:06:34,270
eliminate it or make it much more

00:06:32,440 --> 00:06:36,760
efficient much smaller fraction of what

00:06:34,270 --> 00:06:40,000
we do that would be a radical

00:06:36,760 --> 00:06:42,640
transformation of the software industry

00:06:40,000 --> 00:06:44,890
and so the reason that I'm giving this

00:06:42,640 --> 00:06:46,320
talk at this particular conference is as

00:06:44,890 --> 00:06:48,460
I think people are generally aware

00:06:46,320 --> 00:06:50,560
foundation DB had a different

00:06:48,460 --> 00:06:53,410
relationship with testing than many

00:06:50,560 --> 00:06:56,620
products did testing for us was not an

00:06:53,410 --> 00:07:00,070
ordeal it did not suck up in vast

00:06:56,620 --> 00:07:03,040
quantities of developer energy so I'm

00:07:00,070 --> 00:07:05,230
not actually gonna dive into this a

00:07:03,040 --> 00:07:07,780
whole lot both because I think a lot of

00:07:05,230 --> 00:07:10,270
people here already know how foundation

00:07:07,780 --> 00:07:12,190
DB did testing Evan and Ben both covered

00:07:10,270 --> 00:07:14,410
it and sort of gave you some information

00:07:12,190 --> 00:07:16,810
about it instead what I'm gonna do is

00:07:14,410 --> 00:07:20,410
I'm gonna try and take what we did at F

00:07:16,810 --> 00:07:22,270
DB and recontextualize it I'm gonna try

00:07:20,410 --> 00:07:26,260
and give you a different perspective on

00:07:22,270 --> 00:07:30,070
it situate it as one technique within a

00:07:26,260 --> 00:07:31,210
much broader class of approaches and you

00:07:30,070 --> 00:07:33,670
know talk about why you should be using

00:07:31,210 --> 00:07:35,740
them talk about why you might not be

00:07:33,670 --> 00:07:38,680
using them talk about why no really you

00:07:35,740 --> 00:07:41,440
actually should be using them and if I

00:07:38,680 --> 00:07:42,970
have time then I will close with like

00:07:41,440 --> 00:07:44,620
some slightly more speculative stuff

00:07:42,970 --> 00:07:47,260
okay

00:07:44,620 --> 00:07:50,020
but before I get to all that let's first

00:07:47,260 --> 00:07:52,510
talk about why testing is so miserable

00:07:50,020 --> 00:07:54,760
right now one reason that I think a lot

00:07:52,510 --> 00:07:56,830
of people are very familiar with is that

00:07:54,760 --> 00:08:00,310
your tests are usually non-deterministic

00:07:56,830 --> 00:08:02,290
right as soon as your test relies on any

00:08:00,310 --> 00:08:04,240
kind of external service or as soon as

00:08:02,290 --> 00:08:06,370
you run it in a even slightly noisy

00:08:04,240 --> 00:08:07,810
environment suddenly it fails one out of

00:08:06,370 --> 00:08:08,860
every hundred times or one out of every

00:08:07,810 --> 00:08:11,440
10,000 times

00:08:08,860 --> 00:08:13,600
either way it's a nightmare it's a

00:08:11,440 --> 00:08:15,640
maintainability nightmare

00:08:13,600 --> 00:08:17,200
it's a nightmare when you actually go to

00:08:15,640 --> 00:08:18,670
try and debug something you don't have

00:08:17,200 --> 00:08:21,040
confidence as to whether you've actually

00:08:18,670 --> 00:08:23,230
fixed it or not if the test does fail

00:08:21,040 --> 00:08:25,690
you're awfully tempted to say well

00:08:23,230 --> 00:08:28,180
that's that's a known flaky test right

00:08:25,690 --> 00:08:31,600
you ignore it and then it turns out no

00:08:28,180 --> 00:08:33,760
actually it really was a problem um I

00:08:31,600 --> 00:08:35,530
think people are also generally familiar

00:08:33,760 --> 00:08:39,610
with the way that the foundation DB team

00:08:35,530 --> 00:08:41,410
made heroic efforts to clawback this

00:08:39,610 --> 00:08:42,849
property in our testing using a

00:08:41,410 --> 00:08:45,580
technique called deterministic

00:08:42,849 --> 00:08:47,710
simulation Evan touched on that briefly

00:08:45,580 --> 00:08:49,510
there's tons of material online about it

00:08:47,710 --> 00:08:52,960
as Dave said I gave a talk about it

00:08:49,510 --> 00:08:53,779
years ago you can go read about that so

00:08:52,960 --> 00:08:57,259
I'm not gonna talk about

00:08:53,779 --> 00:09:00,949
but all that said I think we in this

00:08:57,259 --> 00:09:04,009
room should be aware that most of the

00:09:00,949 --> 00:09:05,180
world does not have this right most of

00:09:04,009 --> 00:09:08,569
the world is still in the dark ages

00:09:05,180 --> 00:09:10,759
can't do this and it's an ongoing source

00:09:08,569 --> 00:09:13,639
of pain and suffering and it's really

00:09:10,759 --> 00:09:15,050
bad okay but there are more reasons that

00:09:13,639 --> 00:09:17,240
testing is terrible

00:09:15,050 --> 00:09:19,370
another reason testing is terrible is

00:09:17,240 --> 00:09:21,949
that your tests are very very often

00:09:19,370 --> 00:09:24,050
fragile what do I mean by that I mean

00:09:21,949 --> 00:09:26,870
that your test comes to rely on

00:09:24,050 --> 00:09:29,029
properties of your system that are

00:09:26,870 --> 00:09:30,920
incidental in some way that are not the

00:09:29,029 --> 00:09:33,740
ones that you thought you were testing

00:09:30,920 --> 00:09:35,930
so a really simple example of this is

00:09:33,740 --> 00:09:37,879
suppose you're trying to test a computer

00:09:35,930 --> 00:09:39,559
game all right like a 2d platforming

00:09:37,879 --> 00:09:42,139
game one way you might do that is by

00:09:39,559 --> 00:09:44,689
recording an input right so you say if I

00:09:42,139 --> 00:09:46,910
hold down the right arrow for 6.7

00:09:44,689 --> 00:09:49,699
seconds and then I hit the jump key for

00:09:46,910 --> 00:09:52,189
3.2 seconds and then I shoot the bad guy

00:09:49,699 --> 00:09:55,129
you know assert that bla happens and

00:09:52,189 --> 00:09:57,050
that's a great test until you change

00:09:55,129 --> 00:09:58,910
literally anything at all about your

00:09:57,050 --> 00:10:00,769
program right you change the level

00:09:58,910 --> 00:10:02,569
layout you change the physics engine you

00:10:00,769 --> 00:10:03,860
change the input sampling rate you run

00:10:02,569 --> 00:10:06,350
that test on a different computer it's

00:10:03,860 --> 00:10:08,149
probably gonna fail this is not like

00:10:06,350 --> 00:10:10,069
some weirdness about testing computer

00:10:08,149 --> 00:10:11,899
games either this happens in all kinds

00:10:10,069 --> 00:10:13,550
of testing domains it happens in UI

00:10:11,899 --> 00:10:15,680
testing frequently it happens in

00:10:13,550 --> 00:10:17,059
distributed systems testing right like

00:10:15,680 --> 00:10:19,720
imagine you're trying to like play

00:10:17,059 --> 00:10:22,160
forward some series of events and

00:10:19,720 --> 00:10:24,439
something changes towards the beginning

00:10:22,160 --> 00:10:26,209
right the two tests histories are gonna

00:10:24,439 --> 00:10:27,769
diverge and you're gonna be off testing

00:10:26,209 --> 00:10:31,309
some totally different thing than you

00:10:27,769 --> 00:10:33,769
thought you were right so this is a

00:10:31,309 --> 00:10:35,509
really bad problem like like the flaky

00:10:33,769 --> 00:10:37,879
problem it's a maintainability nightmare

00:10:35,509 --> 00:10:40,279
like the flaky problem you're very very

00:10:37,879 --> 00:10:42,350
tempted to ignore the test because of

00:10:40,279 --> 00:10:44,839
this I heard about a post-mortem

00:10:42,350 --> 00:10:47,000
recently of some giant outage at some

00:10:44,839 --> 00:10:50,540
giant company that his name I shall not

00:10:47,000 --> 00:10:53,209
mention we're literally the same

00:10:50,540 --> 00:10:54,199
check-in that caused the bug that caused

00:10:53,209 --> 00:10:57,050
the giant outage

00:10:54,199 --> 00:10:58,670
also disabled the test that would have

00:10:57,050 --> 00:11:01,370
told them that they were about to have a

00:10:58,670 --> 00:11:02,779
giant outage why because everybody knew

00:11:01,370 --> 00:11:06,470
that test breaks every time you check

00:11:02,779 --> 00:11:07,459
something in so I course right that's

00:11:06,470 --> 00:11:09,170
really bad

00:11:07,459 --> 00:11:11,209
even more insidious failure mode for

00:11:09,170 --> 00:11:14,179
this by the way is sometimes your test

00:11:11,209 --> 00:11:16,790
can fail open in the sense that you make

00:11:14,179 --> 00:11:19,100
some change your test continues to pass

00:11:16,790 --> 00:11:20,839
but it's now passing for a totally

00:11:19,100 --> 00:11:23,899
different reason than you thought it was

00:11:20,839 --> 00:11:26,899
passing right and so now it's a source

00:11:23,899 --> 00:11:29,809
of false confidence and you yeah it's

00:11:26,899 --> 00:11:30,920
it's really really bad and I don't think

00:11:29,809 --> 00:11:31,399
people have a great answer to this

00:11:30,920 --> 00:11:33,589
problem

00:11:31,399 --> 00:11:35,899
okay but there's there's an even worse

00:11:33,589 --> 00:11:38,600
one which is even if you somehow make

00:11:35,899 --> 00:11:41,119
your test neither flaky nor fragile it's

00:11:38,600 --> 00:11:43,730
probably not testing the right stuff I

00:11:41,119 --> 00:11:46,759
think there's actually a really like a

00:11:43,730 --> 00:11:49,309
deep reason behind this almost like an

00:11:46,759 --> 00:11:49,579
analytic proof okay so it goes something

00:11:49,309 --> 00:11:51,829
like this

00:11:49,579 --> 00:11:55,399
the reason that people write tests is

00:11:51,829 --> 00:11:58,519
because human beings are astonishingly

00:11:55,399 --> 00:12:00,619
bad at thinking through all the possible

00:11:58,519 --> 00:12:03,470
branches of control flow that a program

00:12:00,619 --> 00:12:05,480
could take right we're astonishingly bad

00:12:03,470 --> 00:12:07,790
at thinking through all the possible

00:12:05,480 --> 00:12:09,350
orders in which two threads could

00:12:07,790 --> 00:12:10,759
interleave or some other asynchronous

00:12:09,350 --> 00:12:12,799
construct could interleave we're

00:12:10,759 --> 00:12:15,230
astonishingly bad at thinking through

00:12:12,799 --> 00:12:16,819
all the possible points in the execution

00:12:15,230 --> 00:12:18,740
of a distributed algorithm we're a

00:12:16,819 --> 00:12:22,519
failure might occur and what form that

00:12:18,740 --> 00:12:24,350
failure might take but that very fact

00:12:22,519 --> 00:12:26,540
right that's why we need tests but that

00:12:24,350 --> 00:12:28,699
very fact means that we're unable to

00:12:26,540 --> 00:12:30,110
write tests to cover all the things that

00:12:28,699 --> 00:12:31,730
we actually need to cover right like

00:12:30,110 --> 00:12:32,869
because if we could if we were smart

00:12:31,730 --> 00:12:34,759
enough or had the right kind of brains

00:12:32,869 --> 00:12:36,439
to write all the tests we needed to

00:12:34,759 --> 00:12:38,509
write then we would have just written

00:12:36,439 --> 00:12:42,709
the code correctly in the first place

00:12:38,509 --> 00:12:44,720
right and so I think this is like really

00:12:42,709 --> 00:12:47,329
scary and really true and the

00:12:44,720 --> 00:12:50,179
implication is that tests can be useful

00:12:47,329 --> 00:12:53,119
for turning up regressions but almost

00:12:50,179 --> 00:12:58,009
completely useless for telling you about

00:12:53,119 --> 00:13:00,230
unknown unknowns that's that's bad right

00:12:58,009 --> 00:13:01,549
the latter is I think the more important

00:13:00,230 --> 00:13:04,100
problem it's certainly the harder

00:13:01,549 --> 00:13:05,799
problem and people try and fight against

00:13:04,100 --> 00:13:08,209
this in a bunch of different ways people

00:13:05,799 --> 00:13:09,799
people try and use coverage metrics to

00:13:08,209 --> 00:13:12,379
fight against this which i think is a

00:13:09,799 --> 00:13:15,079
nice idea but ultimately kind of useless

00:13:12,379 --> 00:13:16,939
to like you know your distributed

00:13:15,079 --> 00:13:18,589
systems people imagine that you have a

00:13:16,939 --> 00:13:20,840
distributed system and your test suite

00:13:18,589 --> 00:13:24,650
gives you 100% branch coverage

00:13:20,840 --> 00:13:29,450
on it are you sure your system has no

00:13:24,650 --> 00:13:31,460
bugs yeah obviously not right you could

00:13:29,450 --> 00:13:34,100
have a bug that depended on whether some

00:13:31,460 --> 00:13:36,170
code executed on process a before or

00:13:34,100 --> 00:13:37,760
after it executes on process B you'd

00:13:36,170 --> 00:13:40,430
have 100% branch coverage either way

00:13:37,760 --> 00:13:43,190
this is not like a distributed systems

00:13:40,430 --> 00:13:44,840
thing either right like imagine you were

00:13:43,190 --> 00:13:47,660
writing a Python interpreter and you get

00:13:44,840 --> 00:13:49,310
100% branch coverage have you tested all

00:13:47,660 --> 00:13:51,470
the interesting behavior and that Python

00:13:49,310 --> 00:13:53,000
interpreter no Python is a

00:13:51,470 --> 00:13:54,650
turing-complete language there's an

00:13:53,000 --> 00:13:56,210
infinite mountain of interesting

00:13:54,650 --> 00:13:58,580
behavior that you could continue to

00:13:56,210 --> 00:14:01,070
exercise so branch coverage is a nice

00:13:58,580 --> 00:14:05,090
idea but it doesn't actually solve this

00:14:01,070 --> 00:14:06,770
problem at all um okay I actually think

00:14:05,090 --> 00:14:10,460
that all of these problems are just

00:14:06,770 --> 00:14:13,760
symptoms of a deeper underlying problem

00:14:10,460 --> 00:14:17,360
the real problem and the real problem is

00:14:13,760 --> 00:14:20,420
that testing is still totally manual

00:14:17,360 --> 00:14:22,970
right what we call automated testing is

00:14:20,420 --> 00:14:25,400
not automated in the slightest we've

00:14:22,970 --> 00:14:27,590
automated the absolute dumbest part of

00:14:25,400 --> 00:14:29,480
it which is executing the tests and

00:14:27,590 --> 00:14:31,280
running them automated testing to most

00:14:29,480 --> 00:14:34,100
people means having Jenkins run your

00:14:31,280 --> 00:14:36,350
tests and you know that's that's nice

00:14:34,100 --> 00:14:37,700
that's certainly better than not doing

00:14:36,350 --> 00:14:39,800
that right having sitting there and like

00:14:37,700 --> 00:14:43,010
typing who does that actually tons of

00:14:39,800 --> 00:14:47,150
industries do that so yeah good good

00:14:43,010 --> 00:14:49,670
start but still we have every one of

00:14:47,150 --> 00:14:51,380
those tests is painstakingly manually

00:14:49,670 --> 00:14:53,720
constructed by a human being in the

00:14:51,380 --> 00:14:55,850
first place imagine if this were any

00:14:53,720 --> 00:14:58,010
other industry right magic if I told you

00:14:55,850 --> 00:15:00,710
that there's an industry out there where

00:14:58,010 --> 00:15:02,960
you know scads of highly paid

00:15:00,710 --> 00:15:05,510
intelligent people are sitting doing

00:15:02,960 --> 00:15:09,020
mind-numbing rote repetitive predictable

00:15:05,510 --> 00:15:10,580
tasks with with no automation right what

00:15:09,020 --> 00:15:12,710
would you say what would your VC say

00:15:10,580 --> 00:15:15,080
they would say that's an industry that's

00:15:12,710 --> 00:15:16,310
ripe for disruption and you know welcome

00:15:15,080 --> 00:15:19,310
ladies and gentlemen to software

00:15:16,310 --> 00:15:23,060
engineering right for a disruption and I

00:15:19,310 --> 00:15:26,240
think this is the real secret sauce

00:15:23,060 --> 00:15:28,550
behind what foundation DB did it's not

00:15:26,240 --> 00:15:30,170
so much just the deterministic

00:15:28,550 --> 00:15:32,240
simulation although that was a very

00:15:30,170 --> 00:15:34,280
important part of it it was that we

00:15:32,240 --> 00:15:36,170
didn't go down this path

00:15:34,280 --> 00:15:38,750
it's that whenever we had a new piece of

00:15:36,170 --> 00:15:41,000
functionality we didn't say how can I

00:15:38,750 --> 00:15:43,640
write some tests to cover this it was

00:15:41,000 --> 00:15:46,400
more like how can I write a system that

00:15:43,640 --> 00:15:48,290
will forever be generating new and

00:15:46,400 --> 00:15:50,390
interesting tests that will exercise

00:15:48,290 --> 00:15:52,130
this it's like it's a different it's a

00:15:50,390 --> 00:15:55,190
shift of mindset it's a shift of

00:15:52,130 --> 00:15:58,610
philosophy and it's such a big change

00:15:55,190 --> 00:16:00,110
that I think it needs a new name and so

00:15:58,610 --> 00:16:02,840
for the rest of this talk I'm gonna talk

00:16:00,110 --> 00:16:05,510
about automated creation of tests in

00:16:02,840 --> 00:16:09,020
addition to merely automated execution

00:16:05,510 --> 00:16:10,670
of tests as autonomous testing which i

00:16:09,020 --> 00:16:13,970
think is a is a better word for the

00:16:10,670 --> 00:16:16,520
stuff and foundation DB is not like

00:16:13,970 --> 00:16:18,320
totally special right if you know where

00:16:16,520 --> 00:16:20,990
to look if you squint at the industry

00:16:18,320 --> 00:16:23,960
you can see glimmerings of autonomous

00:16:20,990 --> 00:16:26,420
testing everywhere actually a really

00:16:23,960 --> 00:16:28,220
simple example is just fuzzing suppose

00:16:26,420 --> 00:16:30,530
you're writing a parser that's parsing

00:16:28,220 --> 00:16:32,180
some untrusted bytes from the network do

00:16:30,530 --> 00:16:34,880
you sit there and say well I better

00:16:32,180 --> 00:16:37,370
write some unit tests for this know like

00:16:34,880 --> 00:16:40,490
if that's all you do your parser sucks I

00:16:37,370 --> 00:16:42,440
assure you it's wrong like what you do

00:16:40,490 --> 00:16:43,820
is you get a fuzzer to feed millions and

00:16:42,440 --> 00:16:45,740
millions and millions of random strings

00:16:43,820 --> 00:16:46,820
of input into it and see if any of them

00:16:45,740 --> 00:16:48,680
cause it to crash

00:16:46,820 --> 00:16:50,950
that's autonomous testing it's a

00:16:48,680 --> 00:16:53,330
primitive form of autonomous testing

00:16:50,950 --> 00:16:55,730
property based testing is an example

00:16:53,330 --> 00:16:57,500
from a totally different side of the

00:16:55,730 --> 00:16:58,820
software industry right this is signing

00:16:57,500 --> 00:17:00,770
the functional programming people came

00:16:58,820 --> 00:17:03,200
up with it's something that the Haskell

00:17:00,770 --> 00:17:04,490
people I think came up with the idea

00:17:03,200 --> 00:17:06,500
here is if you have a piece of your

00:17:04,490 --> 00:17:09,920
program or a data structure or something

00:17:06,500 --> 00:17:12,170
with a very easy to specify interface

00:17:09,920 --> 00:17:14,180
what you can do is construct a

00:17:12,170 --> 00:17:16,220
specification of its contract and its

00:17:14,180 --> 00:17:18,439
guarantees and then you tell the

00:17:16,220 --> 00:17:20,240
computer to sit there and try and come

00:17:18,439 --> 00:17:22,160
up with counter examples to that

00:17:20,240 --> 00:17:23,600
contract this is a form of autonomous

00:17:22,160 --> 00:17:26,689
testing this is actually something that

00:17:23,600 --> 00:17:28,610
was exhaustively used in the testing of

00:17:26,689 --> 00:17:30,440
the foundation DB document layer which

00:17:28,610 --> 00:17:33,830
as you heard was just open source Thank

00:17:30,440 --> 00:17:35,450
You Apple right so like the like it's

00:17:33,830 --> 00:17:37,640
not like at foundation DB we just had

00:17:35,450 --> 00:17:39,740
one magical tool the simulation stuff

00:17:37,640 --> 00:17:42,500
and we like hit everything with it it's

00:17:39,740 --> 00:17:44,390
that everybody every engineer was

00:17:42,500 --> 00:17:47,660
constantly there was a culture of

00:17:44,390 --> 00:17:50,510
constantly thinking about how to take

00:17:47,660 --> 00:17:54,380
testing problems and make them less

00:17:50,510 --> 00:17:56,660
human involved and so the question that

00:17:54,380 --> 00:17:59,210
I've been grappling with in my career

00:17:56,660 --> 00:18:01,970
since leaving foundation DB is why

00:17:59,210 --> 00:18:05,780
doesn't everybody do this all the time

00:18:01,970 --> 00:18:08,450
right because I've seen how good things

00:18:05,780 --> 00:18:10,730
are when you do it this way and I've

00:18:08,450 --> 00:18:12,710
also seen but I'm prohibited by NDA from

00:18:10,730 --> 00:18:14,630
telling you about how bad things can get

00:18:12,710 --> 00:18:17,600
when you don't do it this way the answer

00:18:14,630 --> 00:18:19,520
is really bad by the way so like so

00:18:17,600 --> 00:18:21,770
serious like why isn't everybody in the

00:18:19,520 --> 00:18:24,230
universe using this stuff it's like it's

00:18:21,770 --> 00:18:25,550
a real conundrum and it turns out that

00:18:24,230 --> 00:18:28,220
there are actually some really really

00:18:25,550 --> 00:18:30,740
good reasons why people don't do this

00:18:28,220 --> 00:18:32,270
stuff but before I tell you about the

00:18:30,740 --> 00:18:35,600
good reasons I'm gonna tell you about a

00:18:32,270 --> 00:18:37,790
really bad reason which is I hear this

00:18:35,600 --> 00:18:41,390
with surprising regularity that the

00:18:37,790 --> 00:18:43,970
turing halting theorem proves that

00:18:41,390 --> 00:18:48,410
software can never test software yeah

00:18:43,970 --> 00:18:50,030
that's right and you know it's it's it's

00:18:48,410 --> 00:18:52,340
kind of true you can come to me and be

00:18:50,030 --> 00:18:54,380
like will if your program can find bugs

00:18:52,340 --> 00:18:56,300
then surely I can write a program which

00:18:54,380 --> 00:18:58,790
will crash if and only if the Riemann

00:18:56,300 --> 00:19:00,980
hypothesis is true and then in order to

00:18:58,790 --> 00:19:02,750
tell me if it has a bug your program has

00:19:00,980 --> 00:19:06,650
to solve all of math are you saying you

00:19:02,750 --> 00:19:09,280
can do that and like you know fine like

00:19:06,650 --> 00:19:11,930
that's that's true but that's correct

00:19:09,280 --> 00:19:13,790
but to me this has a little bit of the

00:19:11,930 --> 00:19:16,370
feel of people who say that the cap

00:19:13,790 --> 00:19:18,770
theorem means you can't write a good

00:19:16,370 --> 00:19:20,830
distributed database right it's like

00:19:18,770 --> 00:19:22,970
it's like kind of an almost trivial

00:19:20,830 --> 00:19:26,570
impossibility result which nevertheless

00:19:22,970 --> 00:19:29,000
doesn't actually address the issue right

00:19:26,570 --> 00:19:33,290
humans debug software humans are not

00:19:29,000 --> 00:19:35,090
mystical Turing Oracle's like if humans

00:19:33,290 --> 00:19:37,190
can do it then so can computers we just

00:19:35,090 --> 00:19:38,600
and we don't need to be perfect right we

00:19:37,190 --> 00:19:39,950
don't need to find every single bug in

00:19:38,600 --> 00:19:42,080
every single program that could ever be

00:19:39,950 --> 00:19:44,510
written which indeed the turing theorem

00:19:42,080 --> 00:19:46,220
says you can't do all we have to do is

00:19:44,510 --> 00:19:48,260
be better than humans or faster than

00:19:46,220 --> 00:19:51,530
humans or more scalable than humans or

00:19:48,260 --> 00:19:53,500
you know different from humans so i

00:19:51,530 --> 00:19:56,300
think i think this is a dumb objection

00:19:53,500 --> 00:19:59,910
that said i think it's actually really

00:19:56,300 --> 00:20:01,799
closely tied to a smart objection

00:19:59,910 --> 00:20:04,410
the same as maybe arguably true of the

00:20:01,799 --> 00:20:06,330
cap theorem and the smart objection that

00:20:04,410 --> 00:20:11,190
this is tied to is that it's insanely

00:20:06,330 --> 00:20:13,710
difficult and that I think is true an

00:20:11,190 --> 00:20:16,320
easy way to sort of think about how

00:20:13,710 --> 00:20:17,669
difficult it is is just to imagine the

00:20:16,320 --> 00:20:20,130
size of the space you're trying to

00:20:17,669 --> 00:20:21,600
explore right so when you're trying to

00:20:20,130 --> 00:20:23,580
find a bug in a program you are

00:20:21,600 --> 00:20:26,190
implicitly trying to explore the space

00:20:23,580 --> 00:20:28,260
of all possible execution histories your

00:20:26,190 --> 00:20:31,679
program could have the size of that

00:20:28,260 --> 00:20:33,510
space is 256 raised to the power of the

00:20:31,679 --> 00:20:36,120
number of bytes of input your program

00:20:33,510 --> 00:20:38,190
has ever received that is a mind

00:20:36,120 --> 00:20:41,100
bogglingly large space that is

00:20:38,190 --> 00:20:44,400
inconceivably vast right you could you

00:20:41,100 --> 00:20:46,559
could stumble around in some tiny stupid

00:20:44,400 --> 00:20:48,570
corner of that space for the entire

00:20:46,559 --> 00:20:52,590
lifetime of the universe and never find

00:20:48,570 --> 00:20:55,770
anything and yet I'm up here saying that

00:20:52,590 --> 00:20:57,510
you can hit most of the interesting

00:20:55,770 --> 00:21:00,539
parts of that space in a very small

00:20:57,510 --> 00:21:03,690
amount of time how on earth can we do

00:21:00,539 --> 00:21:05,880
that the answer is that's insanely

00:21:03,690 --> 00:21:07,500
insanely hard and it's a challenge that

00:21:05,880 --> 00:21:09,480
people trying to use autonomous testing

00:21:07,500 --> 00:21:12,210
I think frequently like get shipwrecked

00:21:09,480 --> 00:21:14,070
on an foundation DB we put an insane

00:21:12,210 --> 00:21:16,320
amount of effort I should really say

00:21:14,070 --> 00:21:18,960
Evan put an insane amount of effort into

00:21:16,320 --> 00:21:21,630
into fighting this exact problem right

00:21:18,960 --> 00:21:24,169
tweaking and tuning all the knobs bugga

00:21:21,630 --> 00:21:26,610
fiying things to turn up bugs more often

00:21:24,169 --> 00:21:28,830
tweaking the random number generators so

00:21:26,610 --> 00:21:30,120
that you have processes crashing just

00:21:28,830 --> 00:21:32,820
often enough to turn up interesting

00:21:30,120 --> 00:21:35,610
behavior but not so often that you never

00:21:32,820 --> 00:21:37,049
make any progress this is a this is a

00:21:35,610 --> 00:21:38,909
really hard thing to do

00:21:37,049 --> 00:21:41,789
it takes somebody with deep knowledge of

00:21:38,909 --> 00:21:44,610
the system to do it it it's like it's

00:21:41,789 --> 00:21:47,640
really draining and tough work and if

00:21:44,610 --> 00:21:50,780
you get it wrong the failure mode is

00:21:47,640 --> 00:21:53,280
your tests say everything's good

00:21:50,780 --> 00:21:55,380
that's a really really scary failure

00:21:53,280 --> 00:21:57,500
mode right you need some kind of side

00:21:55,380 --> 00:22:00,360
channel to tell you that no actually

00:21:57,500 --> 00:22:03,630
everything is not good hopefully that

00:22:00,360 --> 00:22:05,490
side channel is not your customers so so

00:22:03,630 --> 00:22:07,679
I think that's super scary the next

00:22:05,490 --> 00:22:09,720
thing is like also super super scary and

00:22:07,679 --> 00:22:12,210
I think it's probably an even bigger

00:22:09,720 --> 00:22:13,440
barrier to adoption so all of the

00:22:12,210 --> 00:22:15,210
autonomous testing techniques

00:22:13,440 --> 00:22:17,429
listed and other ones besides which I

00:22:15,210 --> 00:22:18,720
haven't listed all depend in some way

00:22:17,429 --> 00:22:20,700
they're all a little different but in

00:22:18,720 --> 00:22:23,100
some way they all depend on your

00:22:20,700 --> 00:22:25,230
software being in the right form for

00:22:23,100 --> 00:22:27,389
them to test them and you can think of

00:22:25,230 --> 00:22:30,899
the whole foundation DB deterministic

00:22:27,389 --> 00:22:33,840
simulation system as having the job of

00:22:30,899 --> 00:22:36,149
wrangling a big hairy stateful

00:22:33,840 --> 00:22:38,340
distributed system into that form right

00:22:36,149 --> 00:22:41,250
like taking it and turning it into a box

00:22:38,340 --> 00:22:42,929
that took an input which was a random

00:22:41,250 --> 00:22:45,570
seed like pretending it was a pure

00:22:42,929 --> 00:22:48,269
function so that we could do that kind

00:22:45,570 --> 00:22:51,389
of thing the only reason that wasn't a

00:22:48,269 --> 00:22:53,220
complete and utter debacle was that

00:22:51,389 --> 00:22:55,470
foundation DB was constructed with

00:22:53,220 --> 00:22:58,559
tremendous tremendous foresight to

00:22:55,470 --> 00:23:00,029
enable that most people can't do that I

00:22:58,559 --> 00:23:01,320
mean start with the fact that most

00:23:00,029 --> 00:23:04,409
people aren't writing software from

00:23:01,320 --> 00:23:07,289
scratch right most people are working on

00:23:04,409 --> 00:23:09,870
some ginormous java monstrosity from the

00:23:07,289 --> 00:23:12,539
1990s even the people though who are

00:23:09,870 --> 00:23:15,720
writing something from scratch rarely

00:23:12,539 --> 00:23:17,610
have the foresight to say oh we're gonna

00:23:15,720 --> 00:23:19,980
write a distributed database first we're

00:23:17,610 --> 00:23:22,320
gonna spend a year writing a simulator

00:23:19,980 --> 00:23:24,899
like who does that that takes that takes

00:23:22,320 --> 00:23:27,179
a special kind of person to do that like

00:23:24,899 --> 00:23:28,559
and you know a lot of people even if

00:23:27,179 --> 00:23:31,049
they did have the inclination to do that

00:23:28,559 --> 00:23:33,120
just wouldn't have the time right they

00:23:31,049 --> 00:23:36,269
they need code now not in a year not in

00:23:33,120 --> 00:23:39,000
two years so I think this is this is

00:23:36,269 --> 00:23:40,860
like a huge huge problem and so long as

00:23:39,000 --> 00:23:43,320
it's almost impossible to apply these

00:23:40,860 --> 00:23:46,649
techniques after the fact it's gonna

00:23:43,320 --> 00:23:48,480
greatly limit their their use okay and

00:23:46,649 --> 00:23:50,940
the last thing here is what I'm calling

00:23:48,480 --> 00:23:53,549
test Oracle's which is just a fancy way

00:23:50,940 --> 00:23:55,139
of saying that you're you know even if

00:23:53,549 --> 00:23:57,240
your test like turns up all the bugs in

00:23:55,139 --> 00:23:58,919
the world it's useless if it doesn't

00:23:57,240 --> 00:24:01,470
know when to alert you that it's found a

00:23:58,919 --> 00:24:02,909
bug depending on the domain this can be

00:24:01,470 --> 00:24:05,159
either really really challenging or

00:24:02,909 --> 00:24:07,379
really really easy if you only care that

00:24:05,159 --> 00:24:08,970
your program doesn't crash good good

00:24:07,379 --> 00:24:10,379
news it's pretty easy to tell when a

00:24:08,970 --> 00:24:11,909
program is crashed it's pretty easy as

00:24:10,379 --> 00:24:13,529
hell when it's run out of memory it's

00:24:11,909 --> 00:24:16,169
pretty easy to tell when an assert has

00:24:13,529 --> 00:24:18,480
fired say but suppose you were working

00:24:16,169 --> 00:24:21,750
on a graphical application you know

00:24:18,480 --> 00:24:23,850
suppose that bugs come in the form this

00:24:21,750 --> 00:24:26,500
border was five pixels too far to the

00:24:23,850 --> 00:24:29,080
right or the bug is the screen

00:24:26,500 --> 00:24:31,570
turned purple right you might need a

00:24:29,080 --> 00:24:33,640
much more sophisticated system to tell

00:24:31,570 --> 00:24:36,340
you when you've actually found a bug

00:24:33,640 --> 00:24:38,020
this happened with foundation db2 there

00:24:36,340 --> 00:24:39,700
were a database invariants acid

00:24:38,020 --> 00:24:41,800
invariance which were too complex to

00:24:39,700 --> 00:24:44,230
check with a simple assert statement and

00:24:41,800 --> 00:24:46,210
so what we had to do was design entire

00:24:44,230 --> 00:24:47,560
workloads dedicated to setting up those

00:24:46,210 --> 00:24:49,720
invariants and then checking that they

00:24:47,560 --> 00:24:51,550
were true still at the end so again

00:24:49,720 --> 00:24:54,130
depending on your domain that can be

00:24:51,550 --> 00:24:56,830
that can be a real challenge ok but

00:24:54,130 --> 00:24:58,510
despite all that you should all still be

00:24:56,830 --> 00:24:59,830
using these techniques and you should

00:24:58,510 --> 00:25:01,660
this is this is what you should be doing

00:24:59,830 --> 00:25:04,420
and there's a bunch of reasons some

00:25:01,660 --> 00:25:07,480
obvious some not so obvious so first and

00:25:04,420 --> 00:25:09,190
most obviously computers are cheaper

00:25:07,480 --> 00:25:11,770
than people you might have heard this

00:25:09,190 --> 00:25:14,610
there especially cheaper than software

00:25:11,770 --> 00:25:17,860
engineers in the San Francisco Bay Area

00:25:14,610 --> 00:25:19,630
so when you have computers writing your

00:25:17,860 --> 00:25:22,000
tests instead of people writing your

00:25:19,630 --> 00:25:24,340
tests you can write many many many more

00:25:22,000 --> 00:25:26,290
tests and you will get a whole lot more

00:25:24,340 --> 00:25:29,530
testing done and that will probably be

00:25:26,290 --> 00:25:31,720
good almost more important than that

00:25:29,530 --> 00:25:33,580
though is not just that you're gonna do

00:25:31,720 --> 00:25:36,610
more testing it's that you're gonna do

00:25:33,580 --> 00:25:38,290
different testing sometimes when I talk

00:25:36,610 --> 00:25:39,940
about this stuff people asked me will

00:25:38,290 --> 00:25:42,940
are you saying that I should like throw

00:25:39,940 --> 00:25:44,710
away my my my lovingly crafted test

00:25:42,940 --> 00:25:47,470
suite and just use your crazy computer

00:25:44,710 --> 00:25:49,360
thing no don't do that right keep keep

00:25:47,470 --> 00:25:51,880
your test suite that will find certain

00:25:49,360 --> 00:25:53,620
kinds of bugs and the computers will

00:25:51,880 --> 00:25:56,530
find other kinds of bugs because

00:25:53,620 --> 00:25:58,330
computers and humans like human like

00:25:56,530 --> 00:26:00,160
weren't yet we're all you know unique

00:25:58,330 --> 00:26:02,920
and special snowflakes and different and

00:26:00,160 --> 00:26:05,770
that's wonderful but we're all humans a

00:26:02,920 --> 00:26:07,780
computer is a total alien all that stuff

00:26:05,770 --> 00:26:09,340
I said before about stuff humans are bad

00:26:07,780 --> 00:26:11,200
at thinking about computers are really

00:26:09,340 --> 00:26:14,110
good at thinking about that stuff right

00:26:11,200 --> 00:26:15,910
so humans will find some bugs computers

00:26:14,110 --> 00:26:18,340
will find others and this like beautiful

00:26:15,910 --> 00:26:21,270
synthesis of man and machine will come

00:26:18,340 --> 00:26:23,440
together and it's just it's awesome

00:26:21,270 --> 00:26:26,050
another cool thing about computers is

00:26:23,440 --> 00:26:28,600
you can turn them on and off very easily

00:26:26,050 --> 00:26:30,820
in fact I hear that you can even go to

00:26:28,600 --> 00:26:32,110
Amazon and ask for a computer for a

00:26:30,820 --> 00:26:35,200
limited amount of time and they will

00:26:32,110 --> 00:26:36,610
turn it on and off for you this is this

00:26:35,200 --> 00:26:37,929
is really great this is again something

00:26:36,610 --> 00:26:39,520
that's a little bit different from human

00:26:37,929 --> 00:26:40,269
beings if you want to hire more test

00:26:39,520 --> 00:26:42,369
engineers or

00:26:40,269 --> 00:26:43,359
software engineers that takes time you

00:26:42,369 --> 00:26:45,429
cannot hire and fire them

00:26:43,359 --> 00:26:47,559
instantaneously they take time to be

00:26:45,429 --> 00:26:51,190
trained they have to sleep they have to

00:26:47,559 --> 00:26:53,739
eat it's so annoying computers are not

00:26:51,190 --> 00:26:55,239
like that if you want to do a medium

00:26:53,739 --> 00:26:57,519
amount of testing or a small amount of

00:26:55,239 --> 00:26:58,899
testing all the time and then a really

00:26:57,519 --> 00:27:01,059
really really large amount of testing

00:26:58,899 --> 00:27:04,649
all at once you can do that very easily

00:27:01,059 --> 00:27:07,739
using autonomous testing that said

00:27:04,649 --> 00:27:10,389
despite that I actually think that

00:27:07,739 --> 00:27:12,549
that's not as important as people think

00:27:10,389 --> 00:27:15,070
it is because I think that most of you

00:27:12,549 --> 00:27:17,469
should be doing way more testing all the

00:27:15,070 --> 00:27:20,079
time then you think you should be doing

00:27:17,469 --> 00:27:22,119
and the reason has to do with the last

00:27:20,079 --> 00:27:24,609
of these reasons here which I think

00:27:22,119 --> 00:27:27,159
might be the most subtle which is

00:27:24,609 --> 00:27:30,309
latency and by that I don't mean the

00:27:27,159 --> 00:27:33,190
latency to running a single test I mean

00:27:30,309 --> 00:27:36,399
the latency to running enough tests that

00:27:33,190 --> 00:27:39,789
you find a single bug the reason is that

00:27:36,399 --> 00:27:43,629
the amount of effort it takes to fix a

00:27:39,789 --> 00:27:45,609
bug is extremely strongly tied to how

00:27:43,629 --> 00:27:48,129
long it's been since that bug was caused

00:27:45,609 --> 00:27:49,899
I think we all get this intuitively but

00:27:48,129 --> 00:27:52,479
just a hammer the point home right two

00:27:49,899 --> 00:27:55,149
situations one of them you know you're

00:27:52,479 --> 00:27:57,009
writing some code and you go hit submit

00:27:55,149 --> 00:27:59,559
to your repo and some pre submit hook

00:27:57,009 --> 00:28:01,709
runs and it says blah like you have a

00:27:59,559 --> 00:28:05,200
book you can't submit that right now

00:28:01,709 --> 00:28:06,789
that's great that's so awesome you have

00:28:05,200 --> 00:28:08,739
all the state of the problems still in

00:28:06,789 --> 00:28:10,690
your head you have a literal diff in

00:28:08,739 --> 00:28:12,339
front of you right you know probably the

00:28:10,690 --> 00:28:14,499
bug is in one of those lines of code

00:28:12,339 --> 00:28:17,589
this is about your best possible case

00:28:14,499 --> 00:28:19,959
for finding and fixing that bug compared

00:28:17,589 --> 00:28:23,079
to situation number two where your

00:28:19,959 --> 00:28:25,119
friend causes a bug and it slips through

00:28:23,079 --> 00:28:26,499
your testing and then it slips through

00:28:25,119 --> 00:28:28,779
your release testing it into a release

00:28:26,499 --> 00:28:30,909
and then some time goes by and slips

00:28:28,779 --> 00:28:33,399
into your next release and then six more

00:28:30,909 --> 00:28:35,979
months go by and your friend quits and

00:28:33,399 --> 00:28:37,989
then four more years go by and you're on

00:28:35,979 --> 00:28:39,969
call and your largest production

00:28:37,989 --> 00:28:42,969
customer calls you in the middle of the

00:28:39,969 --> 00:28:47,469
night and says hey something's not

00:28:42,969 --> 00:28:49,719
working what what do you do I mean like

00:28:47,469 --> 00:28:51,820
you're doomed right like it's it's gonna

00:28:49,719 --> 00:28:52,830
be so bad even if that were literally

00:28:51,820 --> 00:28:56,220
the

00:28:52,830 --> 00:28:58,830
right the amount of effort that will go

00:28:56,220 --> 00:29:01,710
into even determining if there was a bug

00:28:58,830 --> 00:29:03,300
in the second case is going to be orders

00:29:01,710 --> 00:29:04,760
of magnitude larger than it would have

00:29:03,300 --> 00:29:07,230
been to just fix it in the first place

00:29:04,760 --> 00:29:09,180
but the good news about testing or at

00:29:07,230 --> 00:29:11,760
least about autonomous testing is it's

00:29:09,180 --> 00:29:14,490
an embarrassingly parallel problem you

00:29:11,760 --> 00:29:16,920
can get a million CPU seconds of testing

00:29:14,490 --> 00:29:19,140
done in one second or five seconds I'm

00:29:16,920 --> 00:29:22,200
does law you know by running it on a

00:29:19,140 --> 00:29:23,730
million different CPU cores that's

00:29:22,200 --> 00:29:25,890
really cool it means if you're willing

00:29:23,730 --> 00:29:28,410
to spend the money you can drive down

00:29:25,890 --> 00:29:31,260
the latency between causing bugs and

00:29:28,410 --> 00:29:33,950
fixing bugs and that is going to repay

00:29:31,260 --> 00:29:38,100
you in money and productivity and

00:29:33,950 --> 00:29:40,170
frustration and everything so fast it's

00:29:38,100 --> 00:29:42,450
going to change your life it's going to

00:29:40,170 --> 00:29:44,220
change it's it's gonna qualitatively

00:29:42,450 --> 00:29:49,470
change the kinds of things your team can

00:29:44,220 --> 00:29:52,440
do yeah okay so I'm gonna wrap up now

00:29:49,470 --> 00:29:54,540
I'm running out of time and I want to

00:29:52,440 --> 00:29:58,280
wrap up by returning to that question I

00:29:54,540 --> 00:30:02,730
raised before which is why don't we have

00:29:58,280 --> 00:30:04,560
computers test all our software I mean I

00:30:02,730 --> 00:30:06,210
know I told you the reasons right there

00:30:04,560 --> 00:30:08,520
there were a ton of like really terrible

00:30:06,210 --> 00:30:10,320
reasons but but seriously what would it

00:30:08,520 --> 00:30:12,870
take what would it take to change that

00:30:10,320 --> 00:30:16,080
like how how can we bring about the kind

00:30:12,870 --> 00:30:18,330
of epochal transformation analogous to

00:30:16,080 --> 00:30:20,280
the invention of the compiler where only

00:30:18,330 --> 00:30:22,470
in really weird or exceptional

00:30:20,280 --> 00:30:25,620
situations do you go back to doing it

00:30:22,470 --> 00:30:27,150
the old way and the answer is I don't

00:30:25,620 --> 00:30:29,700
actually know the answer to that

00:30:27,150 --> 00:30:33,030
question but I'm currently trying to

00:30:29,700 --> 00:30:35,850
figure it out so Dave share over there

00:30:33,030 --> 00:30:39,240
and I have recently started a company

00:30:35,850 --> 00:30:41,370
and our goal is to try and figure out

00:30:39,240 --> 00:30:44,610
the answer to this question and then

00:30:41,370 --> 00:30:47,970
thereby making autonomous testing super

00:30:44,610 --> 00:30:49,770
easy thereby making it universal thereby

00:30:47,970 --> 00:30:52,200
radically transforming the software

00:30:49,770 --> 00:30:54,390
industry thereby assuring in a new

00:30:52,200 --> 00:30:58,440
golden age of peace and prosperity for

00:30:54,390 --> 00:31:03,090
all mankind it's it's pretty early days

00:30:58,440 --> 00:31:05,920
yet it's really early days but we have a

00:31:03,090 --> 00:31:08,050
vision and we have a technical roadmap

00:31:05,920 --> 00:31:10,360
that we think you know has a decent

00:31:08,050 --> 00:31:12,970
chance of getting us there okay

00:31:10,360 --> 00:31:14,590
so there's a bunch of different you know

00:31:12,970 --> 00:31:16,630
I would love to talk to you if you're

00:31:14,590 --> 00:31:18,820
interested in any of the stuff I've

00:31:16,630 --> 00:31:19,810
talked about here today there's two

00:31:18,820 --> 00:31:21,790
kinds of people I'm especially

00:31:19,810 --> 00:31:23,740
interested in talking to those would be

00:31:21,790 --> 00:31:27,370
people who might be interested in coming

00:31:23,740 --> 00:31:30,460
to work with us and people who might be

00:31:27,370 --> 00:31:32,350
good early customers you know the latter

00:31:30,460 --> 00:31:34,120
being like people who have really scary

00:31:32,350 --> 00:31:35,980
QA problems that they feel like they

00:31:34,120 --> 00:31:37,180
don't have a handle on and they think

00:31:35,980 --> 00:31:40,000
some of these techniques could maybe

00:31:37,180 --> 00:31:43,930
help because we have a prototype that

00:31:40,000 --> 00:31:45,250
might kind of work but that said like

00:31:43,930 --> 00:31:46,630
I'm also just interested in talking to

00:31:45,250 --> 00:31:49,510
anybody who's into this stuff because

00:31:46,630 --> 00:31:51,880
this is still a really small niche world

00:31:49,510 --> 00:31:53,890
and not a lot of people think about this

00:31:51,880 --> 00:31:54,760
stuff and so if you do I would love to

00:31:53,890 --> 00:31:56,620
meet you

00:31:54,760 --> 00:31:59,360
and I am definitely over time so I won't

00:31:56,620 --> 00:32:03,150
take questions thank you

00:31:59,360 --> 00:32:03,150

YouTube URL: https://www.youtube.com/watch?v=fFSPwJFXVlw


