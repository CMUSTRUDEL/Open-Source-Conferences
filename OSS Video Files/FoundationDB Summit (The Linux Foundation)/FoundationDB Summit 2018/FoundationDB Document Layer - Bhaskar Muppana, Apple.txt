Title: FoundationDB Document Layer - Bhaskar Muppana, Apple
Publication date: 2018-12-14
Playlist: FoundationDB Summit 2018
Description: 
	Document Layer is a stateless micro server on top of FoundationDB that allows management of JSON documents at large scale. It exposes the traits of FoundationDB through document data model, such as fully ordered documents, consistent indexes and serializable transactions. It does all this while maintaining wire compatibility with MongoDB® API. As the compatibility is done at wire level, existing MongoDB® tools and drivers work seem less. In this talk, we explore how FoundationDB core strengths play well together with Document data model to make it easier to use and reliable database.
Captions: 
	00:00:00,360 --> 00:00:05,400
trying to get large some American accent

00:00:03,389 --> 00:00:07,680
it didn't really work out it was too

00:00:05,400 --> 00:00:09,510
hard don't know how you guys learned it

00:00:07,680 --> 00:00:13,890
but anyway you had to deal with my

00:00:09,510 --> 00:00:16,650
Indian accent I am Baskar I work for

00:00:13,890 --> 00:00:18,750
Apple I am working on foundation DB

00:00:16,650 --> 00:00:22,140
layers for lost run out of years before

00:00:18,750 --> 00:00:25,020
that I worked on Cassandra I did in

00:00:22,140 --> 00:00:28,619
Cardinal Cassandra storage engine it was

00:00:25,020 --> 00:00:33,289
better area before that and they worked

00:00:28,619 --> 00:00:33,289
and also some workload improvements well

00:00:33,590 --> 00:00:39,660
before going into document layer I want

00:00:36,090 --> 00:00:41,880
to spend a little bit time on foundation

00:00:39,660 --> 00:00:44,430
to build layers concept well Ben already

00:00:41,880 --> 00:00:47,220
explained it I just want to I'll speed

00:00:44,430 --> 00:00:49,230
it up so if you look at a typical

00:00:47,220 --> 00:00:52,160
database stack it looks something like

00:00:49,230 --> 00:00:55,050
this it has three components core engine

00:00:52,160 --> 00:00:56,670
transactions module and stranger this is

00:00:55,050 --> 00:01:00,180
a very theoretical conceptual view

00:00:56,670 --> 00:01:04,110
usually the lines are blurry they

00:01:00,180 --> 00:01:06,659
overlap quite a bit the core engine is

00:01:04,110 --> 00:01:08,909
the one that decides the data model for

00:01:06,659 --> 00:01:11,459
any database whether it is a document

00:01:08,909 --> 00:01:14,670
data model document or sequel database

00:01:11,459 --> 00:01:17,069
coroner is the one or transactions of

00:01:14,670 --> 00:01:21,409
module and the storage engine these are

00:01:17,069 --> 00:01:21,409
easily independent of the data model

00:01:21,829 --> 00:01:27,929
well I guess I skipped it but query

00:01:25,170 --> 00:01:30,049
engine is known which implements quality

00:01:27,929 --> 00:01:33,209
planning at all and transaction module

00:01:30,049 --> 00:01:34,889
guarantees the issued properties and

00:01:33,209 --> 00:01:38,240
storage and is the one which guarantees

00:01:34,889 --> 00:01:41,689
replication durability guarantees

00:01:38,240 --> 00:01:44,219
so the problems that we usually solve in

00:01:41,689 --> 00:01:46,380
bottom two layers are independent of the

00:01:44,219 --> 00:01:48,270
data model they're usually same with

00:01:46,380 --> 00:01:49,859
your database you deal with it easily

00:01:48,270 --> 00:01:51,689
depends on what in a transactional

00:01:49,859 --> 00:01:54,899
guarantees it there are always providing

00:01:51,689 --> 00:01:58,829
not much on the what kind of that data

00:01:54,899 --> 00:02:01,439
model it supports so Foundation debate

00:01:58,829 --> 00:02:04,099
tries to solve the bottom 2/3 of the

00:02:01,439 --> 00:02:06,959
stack at scale Foundation DB has

00:02:04,099 --> 00:02:08,820
serializable transactions and it has

00:02:06,959 --> 00:02:12,540
very strong isolation guarantee is it

00:02:08,820 --> 00:02:13,210
supports well it has all the user base

00:02:12,540 --> 00:02:15,760
top it has

00:02:13,210 --> 00:02:17,020
synchronous backups multi-is in support

00:02:15,760 --> 00:02:19,120
we talked about what foundation to make

00:02:17,020 --> 00:02:21,970
good and so far let's look at the API

00:02:19,120 --> 00:02:24,310
the API for foundation DB is very

00:02:21,970 --> 00:02:27,580
minimalistic it has a rocky value shown

00:02:24,310 --> 00:02:30,010
API unlike the traditional unlike the

00:02:27,580 --> 00:02:33,430
sequel or document databases it doesn't

00:02:30,010 --> 00:02:36,580
have joins or aggregations or secondary

00:02:33,430 --> 00:02:39,610
nurses but the API is strong and

00:02:36,580 --> 00:02:41,830
realistic enough the idea is you can use

00:02:39,610 --> 00:02:43,960
this as a basic building block and you

00:02:41,830 --> 00:02:47,740
can build interesting and complex data

00:02:43,960 --> 00:02:51,790
models on top this is where the promise

00:02:47,740 --> 00:02:55,120
of layers comes into picture layer stays

00:02:51,790 --> 00:02:57,280
on top of foundation DB and it builds

00:02:55,120 --> 00:03:01,750
the data models on top of on top of the

00:02:57,280 --> 00:03:03,700
foundation to be API because formation

00:03:01,750 --> 00:03:06,220
to be sauce all the most of the data

00:03:03,700 --> 00:03:09,070
base problems layers can just worry

00:03:06,220 --> 00:03:11,680
about data model and only the only that

00:03:09,070 --> 00:03:15,160
petal problem not much of everything

00:03:11,680 --> 00:03:17,140
else solved by foundation DB and the act

00:03:15,160 --> 00:03:21,160
as the present state is stored on the

00:03:17,140 --> 00:03:24,130
foundation DB layers are usually

00:03:21,160 --> 00:03:25,959
stateless and layers can be either built

00:03:24,130 --> 00:03:31,090
as libraries or you can build them as

00:03:25,959 --> 00:03:33,310
stateless micro services as long as you

00:03:31,090 --> 00:03:36,390
use the transactions every language the

00:03:33,310 --> 00:03:38,830
layers list transactions properly

00:03:36,390 --> 00:03:43,090
concurrency is taken care of taking care

00:03:38,830 --> 00:03:45,459
by foundation DB so big because of that

00:03:43,090 --> 00:03:48,580
if you want to have a more throughput

00:03:45,459 --> 00:03:51,640
you can just run more instances without

00:03:48,580 --> 00:03:56,910
worrying about concurrency or scale so

00:03:51,640 --> 00:03:58,989
it's quite easy to scale as well well

00:03:56,910 --> 00:04:01,450
this goes without saying

00:03:58,989 --> 00:04:03,730
obviously layers inherit all the

00:04:01,450 --> 00:04:05,290
foundational features it you get the

00:04:03,730 --> 00:04:09,480
multi support we have the replication

00:04:05,290 --> 00:04:09,480
and everything just happens seamlessly

00:04:09,600 --> 00:04:16,120
well we already know the there are some

00:04:12,970 --> 00:04:18,430
utility layers they are so critical they

00:04:16,120 --> 00:04:20,890
actually shipped with for addition to B

00:04:18,430 --> 00:04:23,020
language bindings directory layer which

00:04:20,890 --> 00:04:25,720
is which provides us key space

00:04:23,020 --> 00:04:26,500
abstraction on top of foundation db-api

00:04:25,720 --> 00:04:29,500
and

00:04:26,500 --> 00:04:32,860
to put a layer gives us a sorted order

00:04:29,500 --> 00:04:34,720
data data type in recording and of

00:04:32,860 --> 00:04:37,210
course there are a couple of layers from

00:04:34,720 --> 00:04:40,180
community there is a linux NBD block

00:04:37,210 --> 00:04:43,240
layer and a generous growth layer I

00:04:40,180 --> 00:04:45,330
think we have talked after this in the

00:04:43,240 --> 00:04:47,470
same spirit we have document layer

00:04:45,330 --> 00:04:49,510
document layer we think this is the

00:04:47,470 --> 00:04:52,170
first step this is the first step from

00:04:49,510 --> 00:04:54,850
us towards the promise of foundation DB

00:04:52,170 --> 00:04:57,580
future in future we'll see more more

00:04:54,850 --> 00:05:06,010
layers from community and hopefully from

00:04:57,580 --> 00:05:08,500
as well well good well document layer it

00:05:06,010 --> 00:05:12,160
implements document database API on top

00:05:08,500 --> 00:05:14,200
of foundation DB it's not just any

00:05:12,160 --> 00:05:16,540
document of Sapa it is MongoDB quite

00:05:14,200 --> 00:05:19,810
compatible because it is very compatible

00:05:16,540 --> 00:05:21,940
you can just use any standard MongoDB

00:05:19,810 --> 00:05:25,180
drivers or framework to connect to

00:05:21,940 --> 00:05:28,540
document layer there is no you don't

00:05:25,180 --> 00:05:30,430
have to for all that matters for the

00:05:28,540 --> 00:05:33,460
application it looks like a MongoDB

00:05:30,430 --> 00:05:35,500
server it does their things better

00:05:33,460 --> 00:05:45,040
that's a different point but it is it

00:05:35,500 --> 00:05:47,020
looks like a motive server well whatever

00:05:45,040 --> 00:05:49,720
you can say out MongoDB people really

00:05:47,020 --> 00:05:55,750
love the MongoDB API it is very easy to

00:05:49,720 --> 00:05:57,910
use it is very quick to onboard the

00:05:55,750 --> 00:06:01,210
query language is very rich there are

00:05:57,910 --> 00:06:04,479
lots of different features on top then

00:06:01,210 --> 00:06:07,240
and also lots of frameworks out there so

00:06:04,479 --> 00:06:10,150
a company that with the strength of

00:06:07,240 --> 00:06:13,450
foundation DB we really think this is a

00:06:10,150 --> 00:06:19,540
very good way to very good and easy way

00:06:13,450 --> 00:06:21,850
to on guarantee foundation baby well the

00:06:19,540 --> 00:06:24,580
API there are no surprises here you

00:06:21,850 --> 00:06:28,090
wanna know MongoDB is it is MongoDB API

00:06:24,580 --> 00:06:31,419
it stores JSON documents and it is camel

00:06:28,090 --> 00:06:33,669
s that I'm not going to spend any time

00:06:31,419 --> 00:06:35,410
on API because there is huge

00:06:33,669 --> 00:06:41,970
documentation out there there are lots

00:06:35,410 --> 00:06:41,970
of tutorials and videos on MongoDB API

00:06:42,580 --> 00:06:49,550
let's look at the feature set document

00:06:45,680 --> 00:06:52,130
layer it is not a drop-in replacement

00:06:49,550 --> 00:06:55,810
for MongoDB for most like for every

00:06:52,130 --> 00:06:59,950
application out there we started as a

00:06:55,810 --> 00:07:02,660
the core set of documents it did

00:06:59,950 --> 00:07:05,780
document layers supports trade

00:07:02,660 --> 00:07:07,850
operations lot set of quarry or blade

00:07:05,780 --> 00:07:10,070
operators it supports secondary indices

00:07:07,850 --> 00:07:13,430
and transactions these transactions are

00:07:10,070 --> 00:07:18,860
foundation debit transactions expose

00:07:13,430 --> 00:07:22,070
throw definitely API you see that here

00:07:18,860 --> 00:07:24,530
you might not find the popular features

00:07:22,070 --> 00:07:27,530
like change trains or aggregations of

00:07:24,530 --> 00:07:30,830
MongoDB creations I guess these are two

00:07:27,530 --> 00:07:32,930
big ones and also we probably might not

00:07:30,830 --> 00:07:35,290
have all the second all like for

00:07:32,930 --> 00:07:38,420
attached indexes and stuff like that

00:07:35,290 --> 00:07:40,670
the we are this is the project this is

00:07:38,420 --> 00:07:46,940
just starting up we are working on it

00:07:40,670 --> 00:07:50,120
it's going to happen very soon what

00:07:46,940 --> 00:07:52,970
makes document layer very special well

00:07:50,120 --> 00:07:54,920
we keep hearing this morning anything to

00:07:52,970 --> 00:07:59,390
it foundation to be starts with strong

00:07:54,920 --> 00:08:01,550
consistency guarantees and document

00:07:59,390 --> 00:08:02,810
layer just inherits that the consistency

00:08:01,550 --> 00:08:05,780
it has very strong consistency

00:08:02,810 --> 00:08:07,130
guarantees and it happens seamlessly you

00:08:05,780 --> 00:08:10,400
do it application doesn't have to

00:08:07,130 --> 00:08:11,780
specify what kind of read concerned what

00:08:10,400 --> 00:08:13,460
kind what kind of read preference what

00:08:11,780 --> 00:08:14,660
kind of write concern what kind of

00:08:13,460 --> 00:08:16,550
consistency level they how to access

00:08:14,660 --> 00:08:19,370
later on how to carefully manage all

00:08:16,550 --> 00:08:22,280
that it is always consistent it is given

00:08:19,370 --> 00:08:23,630
out of the box and there are no logs it

00:08:22,280 --> 00:08:26,210
is optimistic concurrency control and

00:08:23,630 --> 00:08:31,600
also they are not database loss at all

00:08:26,210 --> 00:08:33,590
it is completely lock free the scaling

00:08:31,600 --> 00:08:36,080
foundation to be well it is a

00:08:33,590 --> 00:08:38,810
distributor base it is not just just it

00:08:36,080 --> 00:08:40,970
is distribu at the same time it does die

00:08:38,810 --> 00:08:43,670
the shortening and everything is dynamic

00:08:40,970 --> 00:08:45,770
there are no static short case is the

00:08:43,670 --> 00:08:48,580
again it is better at the same times

00:08:45,770 --> 00:08:51,440
simpler for application application

00:08:48,580 --> 00:08:54,000
anybody using static sharding database

00:08:51,440 --> 00:08:57,060
like or Cassandra peep

00:08:54,000 --> 00:09:00,660
applications easily it's quite often

00:08:57,060 --> 00:09:02,430
that you use a short key and after six

00:09:00,660 --> 00:09:04,920
months or one year once your data grows

00:09:02,430 --> 00:09:06,780
quite a lot you realize hey my short key

00:09:04,920 --> 00:09:09,150
is wrong now I have to chase my short

00:09:06,780 --> 00:09:11,480
key and guess what I had to remake it

00:09:09,150 --> 00:09:13,920
all my data or read it all my data again

00:09:11,480 --> 00:09:16,380
there is no short key so you don't have

00:09:13,920 --> 00:09:18,240
to worry about how to distribute your

00:09:16,380 --> 00:09:25,980
data database foreign TV takes care of

00:09:18,240 --> 00:09:27,840
it well I said so much about document

00:09:25,980 --> 00:09:30,240
layer is this good and that good I had

00:09:27,840 --> 00:09:32,240
to back up all those claims I think the

00:09:30,240 --> 00:09:34,530
best way to backup these clients is

00:09:32,240 --> 00:09:36,510
going little bit into into the design I

00:09:34,530 --> 00:09:38,580
want to talk a little bit about how the

00:09:36,510 --> 00:09:41,490
code execution model works and also how

00:09:38,580 --> 00:09:43,680
we how the storage model works these two

00:09:41,490 --> 00:09:50,160
things and highly will explain all the

00:09:43,680 --> 00:09:52,350
claims so in the book with with the

00:09:50,160 --> 00:09:54,630
single node sequel database like MySQL

00:09:52,350 --> 00:09:57,060
post rest we are used to the norm that

00:09:54,630 --> 00:09:59,520
everything is a transaction transactions

00:09:57,060 --> 00:10:01,350
are not some slow features which you

00:09:59,520 --> 00:10:03,839
have to use very carefully only when

00:10:01,350 --> 00:10:05,160
there is no other way around everything

00:10:03,839 --> 00:10:06,420
is a transaction with a like with

00:10:05,160 --> 00:10:10,080
something like Porsches or most my

00:10:06,420 --> 00:10:12,870
sequel even when you run a statement in

00:10:10,080 --> 00:10:14,850
Porsche res without starting a

00:10:12,870 --> 00:10:16,740
transaction Porsches automatically

00:10:14,850 --> 00:10:19,050
starts the transaction runs the

00:10:16,740 --> 00:10:20,970
statement commits immediately after so

00:10:19,050 --> 00:10:25,440
that statement runs at a separate

00:10:20,970 --> 00:10:29,480
transaction so document layer works more

00:10:25,440 --> 00:10:31,380
in the same in the same spirit

00:10:29,480 --> 00:10:32,339
everything is a transaction because

00:10:31,380 --> 00:10:36,570
foundation to be everything is a

00:10:32,339 --> 00:10:38,790
transaction so either application can

00:10:36,570 --> 00:10:39,960
explicitly go and say I want to start a

00:10:38,790 --> 00:10:42,180
transaction I want to run all these

00:10:39,960 --> 00:10:45,540
statements and commit this which grows

00:10:42,180 --> 00:10:47,490
all the statement are just like volt

00:10:45,540 --> 00:10:49,890
MongoDB applications you can just keep

00:10:47,490 --> 00:10:51,270
running I keep issuing the request

00:10:49,890 --> 00:10:53,070
separately and each request

00:10:51,270 --> 00:10:55,110
starts a separate foundation to be

00:10:53,070 --> 00:10:57,930
transaction and we call them impulsive

00:10:55,110 --> 00:11:02,540
transactions so let's see how they

00:10:57,930 --> 00:11:06,120
actually look like well the green kind

00:11:02,540 --> 00:11:08,400
green dot represents the MongoDB request

00:11:06,120 --> 00:11:10,440
let's say document layer receives Eric

00:11:08,400 --> 00:11:12,420
one singular question this is out of

00:11:10,440 --> 00:11:14,730
transaction context a single request and

00:11:12,420 --> 00:11:17,910
document layer sees this request it has

00:11:14,730 --> 00:11:19,830
to find based on the model it has to it

00:11:17,910 --> 00:11:22,350
has to do some operations on foundation

00:11:19,830 --> 00:11:25,500
DB if you take an example of let's say a

00:11:22,350 --> 00:11:29,040
simple MongoDB Riak MongoDB insert that

00:11:25,500 --> 00:11:31,530
might need to read the metadata on among

00:11:29,040 --> 00:11:34,290
a metadata from foundation DB and it

00:11:31,530 --> 00:11:36,650
might have to do a find out if there is

00:11:34,290 --> 00:11:39,810
a duplicate document it might have to

00:11:36,650 --> 00:11:41,640
insert the document and also update the

00:11:39,810 --> 00:11:44,970
secondary indices for the particular

00:11:41,640 --> 00:11:46,230
collection all these operations will go

00:11:44,970 --> 00:11:48,120
a separate foundation to be operations

00:11:46,230 --> 00:11:50,910
but all of them happen under a single

00:11:48,120 --> 00:11:53,010
transaction that gives sealless because

00:11:50,910 --> 00:11:58,790
that gives zeros the constancy

00:11:53,010 --> 00:11:58,790
for the whole for the request and well

00:12:00,350 --> 00:12:05,580
yeah and obviously if there are any

00:12:03,330 --> 00:12:07,140
conflicts document a takes care of

00:12:05,580 --> 00:12:10,950
retrying or not so this is how the

00:12:07,140 --> 00:12:14,160
transactions work but there is a catch

00:12:10,950 --> 00:12:16,920
foundation to be transactions are short

00:12:14,160 --> 00:12:18,840
or they have a limit of five seconds in

00:12:16,920 --> 00:12:21,110
five seconds they have high second

00:12:18,840 --> 00:12:21,110
limitation

00:12:22,250 --> 00:12:31,410
obviously we can't really feed

00:12:25,080 --> 00:12:33,090
everything you can you can imagine

00:12:31,410 --> 00:12:35,820
MongoDB you can imagine a MongoDB

00:12:33,090 --> 00:12:38,400
request which touches all documents in a

00:12:35,820 --> 00:12:41,390
collection I could be running a request

00:12:38,400 --> 00:12:43,590
to give 10% bonus to all my employees

00:12:41,390 --> 00:12:46,170
that has to touch each and every

00:12:43,590 --> 00:12:47,940
document and that may not depending on

00:12:46,170 --> 00:12:51,420
how big my company is it might not fit

00:12:47,940 --> 00:12:53,670
in a single transaction in it might not

00:12:51,420 --> 00:12:56,060
finish in five seconds so it might not

00:12:53,670 --> 00:12:57,900
fit in one transaction so obviously

00:12:56,060 --> 00:12:59,280
document layer does the obvious thing

00:12:57,900 --> 00:13:01,890
which is it slits into multiple

00:12:59,280 --> 00:13:04,110
transactions so the guarantees here are

00:13:01,890 --> 00:13:05,040
not as strong as short-lived

00:13:04,110 --> 00:13:10,260
transactions

00:13:05,040 --> 00:13:13,410
well shortly requires but it is it's

00:13:10,260 --> 00:13:18,090
still guarantees constancy at individual

00:13:13,410 --> 00:13:19,430
document level this is I think even for

00:13:18,090 --> 00:13:21,529
the the longer he comes

00:13:19,430 --> 00:13:23,420
for long-grain request may not be as

00:13:21,529 --> 00:13:25,760
good as for the short running ones I

00:13:23,420 --> 00:13:27,760
think it is still better than the

00:13:25,760 --> 00:13:30,860
competition

00:13:27,760 --> 00:13:33,380
then express it transactions application

00:13:30,860 --> 00:13:38,149
can go and say hey I want to try a

00:13:33,380 --> 00:13:41,630
transaction do this request this is

00:13:38,149 --> 00:13:43,070
actually best way to get even better

00:13:41,630 --> 00:13:45,680
performance than implicit transactions

00:13:43,070 --> 00:13:46,880
because whether you want it or not the

00:13:45,680 --> 00:13:50,390
document layer starts the transaction

00:13:46,880 --> 00:13:52,040
anyway so if it's going if it's if

00:13:50,390 --> 00:13:54,410
that's going to happen anyway then we're

00:13:52,040 --> 00:13:56,990
going to like amortize the cost by

00:13:54,410 --> 00:14:00,980
running multiple requests under one

00:13:56,990 --> 00:14:03,709
transaction so this is even though the

00:14:00,980 --> 00:14:05,899
data model is document data model lots

00:14:03,709 --> 00:14:08,810
of the design principles here really

00:14:05,899 --> 00:14:14,120
remind worlds equal days will not work

00:14:08,810 --> 00:14:15,649
but the sequel days for sequel times but

00:14:14,120 --> 00:14:18,190
when you are running XP transactions the

00:14:15,649 --> 00:14:20,300
same principles apply when you run a

00:14:18,190 --> 00:14:22,520
when you write application on top of

00:14:20,300 --> 00:14:25,040
foundation DB it is optimistic

00:14:22,520 --> 00:14:27,260
concurrency control so you have to worry

00:14:25,040 --> 00:14:30,500
about conflicts and you have to worry

00:14:27,260 --> 00:14:31,790
about retries the transaction the excuse

00:14:30,500 --> 00:14:34,490
the transaction the transactions we have

00:14:31,790 --> 00:14:37,610
right now are not yet compatible with v4

00:14:34,490 --> 00:14:39,890
MongoDB transactions this is something

00:14:37,610 --> 00:14:44,180
we are actually working on this gonna

00:14:39,890 --> 00:14:46,279
change very soon the implementation we

00:14:44,180 --> 00:14:47,900
have right now is kind of tied to client

00:14:46,279 --> 00:14:50,450
connection this is again to deal with

00:14:47,900 --> 00:14:52,010
not being compatible with a MongoDB

00:14:50,450 --> 00:14:54,950
transaction this is probably the only

00:14:52,010 --> 00:14:59,420
feature which is not compatible with the

00:14:54,950 --> 00:15:03,529
existing model MongoDB features then

00:14:59,420 --> 00:15:05,180
storage model well foundation DB is

00:15:03,529 --> 00:15:07,790
storing so we don't have to worry about

00:15:05,180 --> 00:15:09,500
the we don't have to worry about

00:15:07,790 --> 00:15:12,170
persistence or replications of like that

00:15:09,500 --> 00:15:15,829
but we have to worry about how do we map

00:15:12,170 --> 00:15:18,890
document on - they have to be keys that

00:15:15,829 --> 00:15:21,589
is quite important and actually well

00:15:18,890 --> 00:15:25,690
that is quite important let's say if you

00:15:21,589 --> 00:15:28,100
take a sample JSON document in MongoDB

00:15:25,690 --> 00:15:29,959
underscore ID if you underscore it is

00:15:28,100 --> 00:15:32,360
the primary key we have a sample

00:15:29,959 --> 00:15:34,600
employed document let's see how we store

00:15:32,360 --> 00:15:34,600
this

00:15:34,780 --> 00:15:43,580
we documented stores a single document

00:15:41,030 --> 00:15:46,130
across multiple activities this allows

00:15:43,580 --> 00:15:50,600
document layer to have support larger

00:15:46,130 --> 00:15:52,400
documents because each FDB key can't

00:15:50,600 --> 00:15:56,000
hold more than all the value can't hold

00:15:52,400 --> 00:15:58,190
more than 100 K bytes of data by

00:15:56,000 --> 00:15:59,690
spreading it across multiple keys you

00:15:58,190 --> 00:16:03,230
can have we can support larger documents

00:15:59,690 --> 00:16:06,020
and one number two you do if you want to

00:16:03,230 --> 00:16:07,190
update just one field in the document

00:16:06,020 --> 00:16:17,030
you don't have to read the entire

00:16:07,190 --> 00:16:20,440
document and write again wait a second I

00:16:17,030 --> 00:16:22,610
think I didn't cover everything here the

00:16:20,440 --> 00:16:27,170
the wiki is four but it is quite

00:16:22,610 --> 00:16:30,590
important so key is you can Kiki has a

00:16:27,170 --> 00:16:32,030
prefix of the collection name well it

00:16:30,590 --> 00:16:34,300
usually is the derivative it's but

00:16:32,030 --> 00:16:36,230
that's not important it has the

00:16:34,300 --> 00:16:38,150
collection name so that you can group

00:16:36,230 --> 00:16:40,550
all of your collection data under one

00:16:38,150 --> 00:16:42,800
key space and then key includes the

00:16:40,550 --> 00:16:46,280
primary key so that you can group all of

00:16:42,800 --> 00:16:47,120
your keys for the document together at

00:16:46,280 --> 00:16:50,150
the same time

00:16:47,120 --> 00:16:51,500
all the documents or the same time all

00:16:50,150 --> 00:16:56,420
the documents are ordered by the primary

00:16:51,500 --> 00:17:00,190
key so you can see here we have multiple

00:16:56,420 --> 00:17:02,390
employee documents here all of them are

00:17:00,190 --> 00:17:05,450
ordered by the primary key primary key

00:17:02,390 --> 00:17:08,089
here is the primary key if I want to

00:17:05,450 --> 00:17:11,600
treat you can think the decimal is a

00:17:08,089 --> 00:17:15,440
MongoDB c'mon if I want to read all

00:17:11,600 --> 00:17:17,780
employees in the collection that that

00:17:15,440 --> 00:17:23,990
boils down to doing a get range on

00:17:17,780 --> 00:17:26,120
employee prefix this is like well get

00:17:23,990 --> 00:17:28,070
registration to become one right yeah so

00:17:26,120 --> 00:17:30,170
the same way if I want to read if I want

00:17:28,070 --> 00:17:33,320
to access a employee document based on

00:17:30,170 --> 00:17:34,930
the ID because ID is the primary key ID

00:17:33,320 --> 00:17:39,290
is the private key that is part of the

00:17:34,930 --> 00:17:41,480
FTP key I can just prepare the prefix

00:17:39,290 --> 00:17:43,490
using the primary key and prefix which

00:17:41,480 --> 00:17:45,740
becomes employee to it taxes the

00:17:43,490 --> 00:17:49,220
employee record of Bob

00:17:45,740 --> 00:17:50,929
this is good as long as you only care

00:17:49,220 --> 00:17:53,179
about predicates that include primary

00:17:50,929 --> 00:17:55,610
key but we have predicates that include

00:17:53,179 --> 00:17:58,850
something like I want to access all

00:17:55,610 --> 00:18:00,350
employees with named Eric we have to

00:17:58,850 --> 00:18:04,400
have secondary nurses and we really have

00:18:00,350 --> 00:18:07,220
secondary nearest secondary nurses how

00:18:04,400 --> 00:18:09,170
to maintain mapping from index key to

00:18:07,220 --> 00:18:12,920
primary key index key here is named

00:18:09,170 --> 00:18:15,050
primary key ID so this how it looks like

00:18:12,920 --> 00:18:17,750
well it has the index prefix and after

00:18:15,050 --> 00:18:21,580
that the index key which stores the name

00:18:17,750 --> 00:18:26,530
and their primary key the primary key

00:18:21,580 --> 00:18:30,260
can be stored in the value but if you

00:18:26,530 --> 00:18:32,179
you don't want to because unlike primary

00:18:30,260 --> 00:18:34,190
index secondary unlike primary key is

00:18:32,179 --> 00:18:36,110
secondary keys are not unique you can

00:18:34,190 --> 00:18:38,780
have multiple eight value here we have

00:18:36,110 --> 00:18:40,250
multiple here X if you do if you keep if

00:18:38,780 --> 00:18:45,200
you don't keep the primary key part of

00:18:40,250 --> 00:18:46,940
the part of the key then many s or Eric

00:18:45,200 --> 00:18:50,780
I guess yeah he's gonna overwrite the

00:18:46,940 --> 00:18:53,179
developer which is not great then the

00:18:50,780 --> 00:18:56,990
value we really have to we don't restore

00:18:53,179 --> 00:18:59,660
anything if there is a query something

00:18:56,990 --> 00:19:02,210
like give me all documents with numeric

00:18:59,660 --> 00:19:06,020
it first goes to the index space asking

00:19:02,210 --> 00:19:08,090
how does it get range on Eric it gets

00:19:06,020 --> 00:19:10,280
all the primary documents goes back to

00:19:08,090 --> 00:19:15,920
the primary space and race all the

00:19:10,280 --> 00:19:20,390
documents we could avoid doing this to

00:19:15,920 --> 00:19:22,970
phase or like two sets of gets if we

00:19:20,390 --> 00:19:25,490
store the we can't be coached all the

00:19:22,970 --> 00:19:29,510
document or the fields of the document

00:19:25,490 --> 00:19:31,309
we care about as value well they are

00:19:29,510 --> 00:19:35,540
called index s we don't support them yet

00:19:31,309 --> 00:19:37,190
but that's something that we can do so

00:19:35,540 --> 00:19:40,580
what is this guy what is this kind of so

00:19:37,190 --> 00:19:42,860
as model giving us aspect of what we

00:19:40,580 --> 00:19:44,960
call primary key second rock n roll when

00:19:42,860 --> 00:19:46,340
it goes out the foundation DB they are

00:19:44,960 --> 00:19:48,620
all just normal case they are all

00:19:46,340 --> 00:19:51,050
treated the same way by primary index

00:19:48,620 --> 00:19:53,120
and secondary nurses they are shorted

00:19:51,050 --> 00:19:56,120
the same way this is a big difference

00:19:53,120 --> 00:19:57,590
from lots of from other no sequel

00:19:56,120 --> 00:19:59,170
databases where

00:19:57,590 --> 00:20:01,990
secondary nurses

00:19:59,170 --> 00:20:06,310
is very closely tied with the primary

00:20:01,990 --> 00:20:08,110
index so if you have to do a query on

00:20:06,310 --> 00:20:11,740
secondary index it usually has to go to

00:20:08,110 --> 00:20:14,260
each and every short you will familiar

00:20:11,740 --> 00:20:16,390
if you like see Cassandra MongoDB this

00:20:14,260 --> 00:20:17,800
how they is gonna do the any Korean

00:20:16,390 --> 00:20:20,200
second and it usually has to touch each

00:20:17,800 --> 00:20:24,070
and every shard that's not the case here

00:20:20,200 --> 00:20:29,320
because secondary starting is same as a

00:20:24,070 --> 00:20:32,100
primary next roaring and also you we are

00:20:29,320 --> 00:20:37,510
getting all these features without

00:20:32,100 --> 00:20:44,680
setting up any short case then the

00:20:37,510 --> 00:20:46,630
indices as explained before index

00:20:44,680 --> 00:20:49,540
updates always happen together with the

00:20:46,630 --> 00:20:53,920
actual document update so indices always

00:20:49,540 --> 00:20:56,620
always stay constant with the primary

00:20:53,920 --> 00:20:58,960
index or the document period there is no

00:20:56,620 --> 00:21:01,000
there are no exceptions and in this is

00:20:58,960 --> 00:21:03,250
all distributed as well that's good

00:21:01,000 --> 00:21:07,560
index rebuild this is some place where

00:21:03,250 --> 00:21:07,560
we are focusing on at the moment we

00:21:09,060 --> 00:21:16,660
MongoDB customers know how painful index

00:21:12,730 --> 00:21:18,400
tables can be I didn't believe until I I

00:21:16,660 --> 00:21:21,340
didn't even think that's possible to do

00:21:18,400 --> 00:21:22,900
a index rebuild from a if your

00:21:21,340 --> 00:21:24,310
application when students rebuild they

00:21:22,900 --> 00:21:26,880
actually has to go to the operations

00:21:24,310 --> 00:21:29,680
team and ask them carefully bounce

00:21:26,880 --> 00:21:31,480
replicas one by one so then I so that

00:21:29,680 --> 00:21:34,780
they can actually label indexes on each

00:21:31,480 --> 00:21:37,360
new repeatin separately well that's not

00:21:34,780 --> 00:21:38,740
the case here there are lots other

00:21:37,360 --> 00:21:40,500
documents we are doing but I guess I'm

00:21:38,740 --> 00:21:42,550
running out of time

00:21:40,500 --> 00:21:45,880
well building layers on top of

00:21:42,550 --> 00:21:47,350
foundation DB can be quite easy because

00:21:45,880 --> 00:21:48,820
of all the guarantees foundation DB is

00:21:47,350 --> 00:21:49,390
giving but the st. and there are lots of

00:21:48,820 --> 00:21:51,610
challenges

00:21:49,390 --> 00:21:52,750
it is autistic as currency control so

00:21:51,610 --> 00:21:55,360
you have to worry about avoiding

00:21:52,750 --> 00:21:58,270
contentions Alec from our team is giving

00:21:55,360 --> 00:22:00,100
a talk this afternoon I strongly suggest

00:21:58,270 --> 00:22:02,380
going for that super interesting one and

00:22:00,100 --> 00:22:06,400
caching because we want to run multiple

00:22:02,380 --> 00:22:08,800
instances of document layer any data we

00:22:06,400 --> 00:22:10,660
are caching is gonna work a ganaches

00:22:08,800 --> 00:22:11,620
because he have to now worry about

00:22:10,660 --> 00:22:13,929
concurrency

00:22:11,620 --> 00:22:18,159
because it's not part of the foundation

00:22:13,929 --> 00:22:19,330
to be translational guarantees and any

00:22:18,159 --> 00:22:21,279
code you're writing on top of foundation

00:22:19,330 --> 00:22:25,450
DB has to be higher burden because of

00:22:21,279 --> 00:22:27,399
unknown commit failures the last one

00:22:25,450 --> 00:22:29,019
this is very deceiving I put it in like

00:22:27,399 --> 00:22:32,259
one line query pairing optimization

00:22:29,019 --> 00:22:34,049
people spend decades making out making

00:22:32,259 --> 00:22:38,580
these things better

00:22:34,049 --> 00:22:41,740
well we have a basic model that works

00:22:38,580 --> 00:22:43,960
that kind of works we are working on

00:22:41,740 --> 00:22:45,879
making better and better future

00:22:43,960 --> 00:22:49,090
improvements these are the things coming

00:22:45,879 --> 00:22:50,619
very very soon we want to make our

00:22:49,090 --> 00:22:52,029
transactions compatible so they're so

00:22:50,619 --> 00:22:54,789
that they actually work in all kinds of

00:22:52,029 --> 00:22:56,980
deployments and mutual TLS shin from our

00:22:54,789 --> 00:23:01,119
team is working on it he's gonna

00:22:56,980 --> 00:23:02,619
probably commit APR like this week index

00:23:01,119 --> 00:23:05,999
rebuild improvements quite a few other

00:23:02,619 --> 00:23:09,360
were coming our metal metal table design

00:23:05,999 --> 00:23:12,789
could be improved quite a bit and

00:23:09,360 --> 00:23:14,710
features aggregations change streams lot

00:23:12,789 --> 00:23:17,610
of people ask me about chain streams I

00:23:14,710 --> 00:23:21,039
understand that is a very desert feature

00:23:17,610 --> 00:23:23,769
that is something we ought to work on

00:23:21,039 --> 00:23:25,710
like beginning of next year and a

00:23:23,769 --> 00:23:29,039
spatial index has stretched indexes

00:23:25,710 --> 00:23:31,539
special intersects probably very soon

00:23:29,039 --> 00:23:33,549
community now document layer is open

00:23:31,539 --> 00:23:35,440
source I should have put some link here

00:23:33,549 --> 00:23:39,879
but you here you have google you can

00:23:35,440 --> 00:23:41,679
google it is open source Apache butyl

00:23:39,879 --> 00:23:44,019
license it's not any there are no

00:23:41,679 --> 00:23:45,879
restrictions it's not you can't run a

00:23:44,019 --> 00:23:47,619
service if you want to I'm not pointing

00:23:45,879 --> 00:23:51,899
fingers but you can't run a service if

00:23:47,619 --> 00:23:54,669
you want to and give it a shot

00:23:51,899 --> 00:23:56,139
please give feedback and forums if you

00:23:54,669 --> 00:23:58,179
liked it let us know if you don't like

00:23:56,139 --> 00:24:00,999
it definitely let us know because we can

00:23:58,179 --> 00:24:03,249
improve on it and rise issues if you

00:24:00,999 --> 00:24:06,580
have some pictures that you really want

00:24:03,249 --> 00:24:08,289
to see soon and well compares we are

00:24:06,580 --> 00:24:11,799
really likes about this project we think

00:24:08,289 --> 00:24:13,749
we can we could really build community

00:24:11,799 --> 00:24:17,049
around this this is a best project and

00:24:13,749 --> 00:24:19,779
also this one is written in flow C++

00:24:17,049 --> 00:24:22,299
flow is a very fun language to work on

00:24:19,779 --> 00:24:23,260
brush me I did Java until two years

00:24:22,299 --> 00:24:26,380
backs

00:24:23,260 --> 00:24:29,370
and whereas a flow is good it's good

00:24:26,380 --> 00:24:29,370
that's all for me

00:24:29,430 --> 00:24:34,979

YouTube URL: https://www.youtube.com/watch?v=KPqmB13zI9c


