Title: Unlucky Simulation - Andrew Noyes, Snowflake Computing
Publication date: 2019-11-25
Playlist: FoundationDB Summit 2019
Description: 
	Unlucky Simulation - Andrew Noyes, Snowflake Computing 

Foundationdb's correctness testing involves using a fair PRNG in a simulation to make decisions that the application cannot control such as when messages get delivered, when machines reboot, and when processes crash. The idea is that with a sufficiently large number of simulations we achieve adequate code coverage. However, most of these simulations do not actually increase code coverage.

In this talk, we evaluate the use of a coverage-guided fuzzer as a "random" number generator for simulation and compare the compute resources required for catching rare bugs.
Captions: 
	00:00:00,030 --> 00:00:05,460
cool okay so I'm Andrew nice I'm from

00:00:03,149 --> 00:00:09,269
snowflake computing and I'm here to talk

00:00:05,460 --> 00:00:20,789
about simulation testing so first some

00:00:09,269 --> 00:00:24,180
background okay I'm to fire okay so for

00:00:20,789 --> 00:00:27,869
some background within the context of

00:00:24,180 --> 00:00:29,369
foundation to be a simulation test we're

00:00:27,869 --> 00:00:32,340
basically simulating a distributed

00:00:29,369 --> 00:00:34,050
system in a single process and the

00:00:32,340 --> 00:00:36,239
outcome of this test is going to be

00:00:34,050 --> 00:00:41,309
determined by the random number

00:00:36,239 --> 00:00:43,110
generator so and in particularly like

00:00:41,309 --> 00:00:45,510
this sequence of numbers returned by the

00:00:43,110 --> 00:00:47,879
random number generator and this is

00:00:45,510 --> 00:00:49,890
really nice because if we like say have

00:00:47,879 --> 00:00:52,649
a pseudo-random number generator with a

00:00:49,890 --> 00:00:55,140
particular seed and we want to reproduce

00:00:52,649 --> 00:01:02,579
our test failure we just run it again

00:00:55,140 --> 00:01:04,110
with that seed but having it so but

00:01:02,579 --> 00:01:07,080
having a pseudo-random number generator

00:01:04,110 --> 00:01:10,710
kind of constrains the possible outputs

00:01:07,080 --> 00:01:11,790
of your ear of this interface here and

00:01:10,710 --> 00:01:14,460
particularly if you want to get very

00:01:11,790 --> 00:01:16,350
unlucky for your for your test and you

00:01:14,460 --> 00:01:18,060
want to return zero like six times in a

00:01:16,350 --> 00:01:20,100
row or something like that that will

00:01:18,060 --> 00:01:23,159
never happen with the fair pseudo-random

00:01:20,100 --> 00:01:26,369
number generator so I'm going to talk

00:01:23,159 --> 00:01:29,070
about kind of an alternative idea where

00:01:26,369 --> 00:01:30,960
you make the input to the program just

00:01:29,070 --> 00:01:33,329
some sequence of numbers returned by

00:01:30,960 --> 00:01:37,259
this and so you you have more

00:01:33,329 --> 00:01:41,100
flexibility there and and let's kind of

00:01:37,259 --> 00:01:42,570
see how that how that goes okay so we're

00:01:41,100 --> 00:01:47,009
going to be using this example bug

00:01:42,570 --> 00:01:48,659
throughout basically we've got some

00:01:47,009 --> 00:01:50,880
integers here and we want to maintain

00:01:48,659 --> 00:01:55,020
this invariant that each one appears

00:01:50,880 --> 00:01:57,930
exactly once and so what we're going to

00:01:55,020 --> 00:02:01,380
allow plans to do is we're going to

00:01:57,930 --> 00:02:03,240
allow them to swap elements and this

00:02:01,380 --> 00:02:08,310
preserves the invariant so there's

00:02:03,240 --> 00:02:11,340
there's a swap and our implementation of

00:02:08,310 --> 00:02:15,340
this swap is going to have a bug

00:02:11,340 --> 00:02:18,220
so there's there's two tasks right so

00:02:15,340 --> 00:02:21,700
this guy can get executed separately

00:02:18,220 --> 00:02:23,500
from after the weights and and this

00:02:21,700 --> 00:02:26,590
looks really contrived but we do really

00:02:23,500 --> 00:02:28,360
insert weight statements here and there

00:02:26,590 --> 00:02:34,330
occasionally for things like trying to

00:02:28,360 --> 00:02:37,870
fix a slow task or you know lifetime

00:02:34,330 --> 00:02:42,070
issues various things and here's here's

00:02:37,870 --> 00:02:44,320
the bug okay and this is what our

00:02:42,070 --> 00:02:46,830
clients will be doing we'll have a

00:02:44,320 --> 00:02:49,570
couple of concurrent clients running

00:02:46,830 --> 00:02:54,010
they'll kind of waiter in the amount of

00:02:49,570 --> 00:02:56,800
time and then they'll some of the times

00:02:54,010 --> 00:02:59,020
they'll check our invariant and the rest

00:02:56,800 --> 00:03:04,510
of the time they will swap to random

00:02:59,020 --> 00:03:06,250
elements and this is what we're looking

00:03:04,510 --> 00:03:10,209
for here this is our minimal counter

00:03:06,250 --> 00:03:13,000
example so we've got two concurrent

00:03:10,209 --> 00:03:16,300
swaps and they're going to interleave

00:03:13,000 --> 00:03:19,120
and they're also going to swap the same

00:03:16,300 --> 00:03:21,190
element here they're swapping they're

00:03:19,120 --> 00:03:26,500
both swapping nine and then immediately

00:03:21,190 --> 00:03:28,540
after we'll check the invariant so so

00:03:26,500 --> 00:03:29,860
this is what happens so this kind of

00:03:28,540 --> 00:03:32,709
represents the first operation here

00:03:29,860 --> 00:03:35,530
we're reading zero and nine then we're

00:03:32,709 --> 00:03:38,410
reading eight and nine then we're

00:03:35,530 --> 00:03:40,780
writing zero and then and then writing

00:03:38,410 --> 00:03:44,769
eight than nine and what you see is that

00:03:40,780 --> 00:03:45,670
nine now appears twice so that's what

00:03:44,769 --> 00:03:50,080
we're looking for that's our minute

00:03:45,670 --> 00:03:52,660
Mobil counter example okay so if you're

00:03:50,080 --> 00:03:54,420
using so I'll kind of just describe the

00:03:52,660 --> 00:03:58,120
strategy Foundation DB

00:03:54,420 --> 00:03:59,680
currently uses for scheduling tasks so

00:03:58,120 --> 00:04:02,590
we've got a fair random number generator

00:03:59,680 --> 00:04:04,630
and some of the time we are going to

00:04:02,590 --> 00:04:07,330
delay for longer than requested

00:04:04,630 --> 00:04:13,260
basically and that's what's called a bug

00:04:07,330 --> 00:04:16,169
if I'd delay and this is kind of like

00:04:13,260 --> 00:04:18,280
kind of the probability distribution

00:04:16,169 --> 00:04:21,130
foundation to be is currently using and

00:04:18,280 --> 00:04:24,040
it's it's kind of skewed towards zero

00:04:21,130 --> 00:04:25,900
so most of the time it will either delay

00:04:24,040 --> 00:04:31,000
for exactly what you requested or

00:04:25,900 --> 00:04:32,650
slightly more and let's let's see what

00:04:31,000 --> 00:04:35,860
needs to happen here so to find the

00:04:32,650 --> 00:04:38,590
minimal counter example we need like

00:04:35,860 --> 00:04:40,120
what we need at least two clients one of

00:04:38,590 --> 00:04:43,030
them needs to get their delay bugga

00:04:40,120 --> 00:04:45,160
Fayed the client swaps need to intersect

00:04:43,030 --> 00:04:47,230
and check in variant needs to be called

00:04:45,160 --> 00:04:51,790
immediately after and the probability of

00:04:47,230 --> 00:04:54,730
all of these happening is pretty low so

00:04:51,790 --> 00:04:57,820
here's here's kind of how it how it did

00:04:54,730 --> 00:04:59,710
so I tried this one million seeds and

00:04:57,820 --> 00:05:02,170
this is the shortest counter example

00:04:59,710 --> 00:05:04,240
that came up with which is a little bit

00:05:02,170 --> 00:05:05,800
expensive to to fix in terms of like

00:05:04,240 --> 00:05:07,810
following what's going on because most

00:05:05,800 --> 00:05:09,940
of this isn't interesting there's

00:05:07,810 --> 00:05:11,440
there's kind of where it happens there

00:05:09,940 --> 00:05:19,330
and then you finally check the

00:05:11,440 --> 00:05:22,240
invariants eventually so so here's kind

00:05:19,330 --> 00:05:24,280
of the idea here is instead of a fair

00:05:22,240 --> 00:05:26,290
random number generator we'll just have

00:05:24,280 --> 00:05:28,780
the input to the program be the sequence

00:05:26,290 --> 00:05:32,530
of random numbers that we that were

00:05:28,780 --> 00:05:36,280
going to use here and so this kind of

00:05:32,530 --> 00:05:41,050
shows how unlucky we can get with this

00:05:36,280 --> 00:05:42,910
random number generator and this this

00:05:41,050 --> 00:05:45,330
replay random by its class implements

00:05:42,910 --> 00:05:48,810
the random interface I showed earlier

00:05:45,330 --> 00:05:51,670
and basically what can happen is you can

00:05:48,810 --> 00:05:53,290
request two random numbers and then if

00:05:51,670 --> 00:05:56,350
there you can crash if they're the same

00:05:53,290 --> 00:05:59,170
and with Lib buzzer it will actually

00:05:56,350 --> 00:06:03,370
find that input but the random number

00:05:59,170 --> 00:06:06,160
generator won't and then so here we

00:06:03,370 --> 00:06:10,690
compare kind of the quality of the

00:06:06,160 --> 00:06:13,810
simulation so this is the the shortest

00:06:10,690 --> 00:06:15,880
counter example we know about versus

00:06:13,810 --> 00:06:18,430
time so the fair random number generator

00:06:15,880 --> 00:06:20,170
finds a counter example and then slowly

00:06:18,430 --> 00:06:22,810
makes it slightly better but it never

00:06:20,170 --> 00:06:27,340
really gets to the minimal one whereas

00:06:22,810 --> 00:06:32,350
Lib buzzer finds the minimal one very

00:06:27,340 --> 00:06:35,140
quickly and then

00:06:32,350 --> 00:06:39,580
another kind of idea another way we can

00:06:35,140 --> 00:06:42,040
get unlucky is if we stop looking at if

00:06:39,580 --> 00:06:46,180
we stop trying so hard to execute things

00:06:42,040 --> 00:06:48,430
in order we just ignore time we notice a

00:06:46,180 --> 00:06:49,930
couple of things so this is kind of the

00:06:48,430 --> 00:06:52,870
current thing we've got a priority queue

00:06:49,930 --> 00:06:55,300
that execute tasks ordered by the time

00:06:52,870 --> 00:06:58,570
they're scheduled if we just pick a

00:06:55,300 --> 00:07:00,910
random task that also finds the minimal

00:06:58,570 --> 00:07:03,850
counter example really quickly for a

00:07:00,910 --> 00:07:06,910
couple of reasons one is that it's a lot

00:07:03,850 --> 00:07:09,880
faster so we can run more simulations

00:07:06,910 --> 00:07:13,360
and the other one is that we kind of

00:07:09,880 --> 00:07:17,490
took away the like it's the delay is

00:07:13,360 --> 00:07:21,700
unlikely to be bug if I'd part of it and

00:07:17,490 --> 00:07:24,730
so here's some takeaways so it's

00:07:21,700 --> 00:07:28,150
possible to write bugs that are kind of

00:07:24,730 --> 00:07:30,130
expensive to catch in simulation we can

00:07:28,150 --> 00:07:33,010
also apply existing tools for finding

00:07:30,130 --> 00:07:36,850
bugs to simulation by making this more

00:07:33,010 --> 00:07:39,580
general input instead of a seed and

00:07:36,850 --> 00:07:41,350
making your simulations not realistic

00:07:39,580 --> 00:07:43,690
isn't necessarily helpful we already do

00:07:41,350 --> 00:07:47,830
this with bug a file odd so don't worry

00:07:43,690 --> 00:07:50,290
about that too much in FDB server but

00:07:47,830 --> 00:07:57,210
yeah that's that's it Thanks

00:07:50,290 --> 00:07:57,210

YouTube URL: https://www.youtube.com/watch?v=0h9l6Ug_l5E


