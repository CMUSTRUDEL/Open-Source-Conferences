Title: FoundationDB as a Storage Engine for Irmin - Andreas Garnæs, Peakon
Publication date: 2019-11-25
Playlist: FoundationDB Summit 2019
Description: 
	FoundationDB as a Storage Engine for Irmin - Andreas Garnæs, Peakon

Irmin is an open-source distributed database built on the same principles as Git. Like Git, Irmin provides snapshotting, branching and merging operations over storage and can communicate via Git both on-disk and remotely.

Further, Irmin is highly configurable and offers pluggable storage engines. FoundationDB has proven to be a very attractive option in this regard, due to its reliability, strong atomicity guarantees and rich feature set, such as watches. This has resulted in `irmin-fdb`, a storage engine for Irmin based on FoundationDB. `irmin-fdb` can be perceived as a layer, that allows you to interact with FoundationDB in yet another mode.

Irmin is implemented in OCaml, a strongly typed functional language. Developing `irmin-fdb` thus required developing a FoundationCB client for OCaml.
Captions: 
	00:00:00,030 --> 00:00:06,270
all right I think we're on so hi

00:00:04,470 --> 00:00:08,730
everyone and welcome to this session

00:00:06,270 --> 00:00:10,170
my name's dress and for the next 20

00:00:08,730 --> 00:00:12,300
minutes I'll be talking about some work

00:00:10,170 --> 00:00:16,049
I've been doing on using foundation to

00:00:12,300 --> 00:00:18,240
be as a storage engine for Herman now I

00:00:16,049 --> 00:00:20,039
assume that most of you won't be

00:00:18,240 --> 00:00:21,960
familiar with Herman so I'll spend the

00:00:20,039 --> 00:00:24,180
first bit of time just providing some

00:00:21,960 --> 00:00:26,279
context about what Herman is and then

00:00:24,180 --> 00:00:28,769
afterwards all diving's moretz about how

00:00:26,279 --> 00:00:36,300
this sarge engine functions in insects

00:00:28,769 --> 00:00:38,010
with foundation DB so Herman is a

00:00:36,300 --> 00:00:39,920
distributed database library or you

00:00:38,010 --> 00:00:42,960
could also call a very configurable

00:00:39,920 --> 00:00:46,710
database it's an open source project

00:00:42,960 --> 00:00:47,489
that originates from the unicorn or

00:00:46,710 --> 00:00:50,160
ecosystem

00:00:47,489 --> 00:00:53,430
so that's applications that run directly

00:00:50,160 --> 00:00:55,020
on top of the hypervisor using a library

00:00:53,430 --> 00:00:58,230
operating system instead of the

00:00:55,020 --> 00:00:59,430
traditional software stack so that means

00:00:58,230 --> 00:01:01,500
that Herman makes very few assumptions

00:00:59,430 --> 00:01:04,710
about the host environment and it can

00:01:01,500 --> 00:01:07,080
run both as in a unit kernel as part of

00:01:04,710 --> 00:01:08,909
unit kernel it can run in a unix-like

00:01:07,080 --> 00:01:12,479
environment or it can even run in the

00:01:08,909 --> 00:01:16,200
browser the first version of Herman was

00:01:12,479 --> 00:01:19,229
co-developed while writing the next

00:01:16,200 --> 00:01:21,150
version of sense toady which is the data

00:01:19,229 --> 00:01:23,130
stalk responsible for storing

00:01:21,150 --> 00:01:26,909
configuration data for VMs running on

00:01:23,130 --> 00:01:32,420
top of the Zen hypervisor you may know

00:01:26,909 --> 00:01:34,650
sin as the kind of underpinning of many

00:01:32,420 --> 00:01:38,610
virtual private server offerings such as

00:01:34,650 --> 00:01:40,979
Amazon ec2 and since n is written in all

00:01:38,610 --> 00:01:45,450
camel Hermann this is also written in

00:01:40,979 --> 00:01:48,329
okay mo so the problem that Herman is

00:01:45,450 --> 00:01:50,759
trying to solve is allowing a network of

00:01:48,329 --> 00:01:55,200
nodes to share state while emphasizing

00:01:50,759 --> 00:01:57,060
that each node is autonomous and should

00:01:55,200 --> 00:01:59,840
be able to make progress independently

00:01:57,060 --> 00:02:02,850
without necessarily being able to to

00:01:59,840 --> 00:02:04,710
contact each other that there is

00:02:02,850 --> 00:02:07,110
fine-grained control of when to share

00:02:04,710 --> 00:02:10,770
state between the nodes and have that be

00:02:07,110 --> 00:02:13,380
quite explicit and auditing for the sake

00:02:10,770 --> 00:02:16,530
of monitoring and debugging the system

00:02:13,380 --> 00:02:19,150
with Herman every note has a local

00:02:16,530 --> 00:02:22,770
possibly partial replica of the database

00:02:19,150 --> 00:02:26,410
and rather than continuously agreeing on

00:02:22,770 --> 00:02:27,910
the shared state each node can can run

00:02:26,410 --> 00:02:29,590
independently and then it's up to the

00:02:27,910 --> 00:02:33,610
user berman to actually push in poor

00:02:29,590 --> 00:02:35,530
data between the nodes so compared to me

00:02:33,610 --> 00:02:37,390
compared to foundation we Herman has

00:02:35,530 --> 00:02:42,670
made a very different set of trade-offs

00:02:37,390 --> 00:02:43,900
to solve these problems

00:02:42,670 --> 00:02:48,670
Herman s take a lot of inspiration from

00:02:43,900 --> 00:02:51,640
get and get is super popular in the

00:02:48,670 --> 00:02:54,610
source control management world and many

00:02:51,640 --> 00:02:55,660
of you probably use it daily but I would

00:02:54,610 --> 00:02:57,880
also imagine that you don't really

00:02:55,660 --> 00:03:01,480
considered a data store a database right

00:02:57,880 --> 00:03:04,720
it's something used to measure code but

00:03:01,480 --> 00:03:07,090
to explain Erman it's actually easiest

00:03:04,720 --> 00:03:09,250
to go back to kid and just review the

00:03:07,090 --> 00:03:11,680
basics and then we'll kind of translate

00:03:09,250 --> 00:03:17,170
that back to what it means in terms of

00:03:11,680 --> 00:03:18,700
the database so on the surface the model

00:03:17,170 --> 00:03:21,430
that get provides is a mapping from

00:03:18,700 --> 00:03:25,030
paths to file contents so in this simple

00:03:21,430 --> 00:03:26,890
example dark slash readme dad empty maps

00:03:25,030 --> 00:03:30,040
to the contents of that file which is

00:03:26,890 --> 00:03:32,140
simply a blob of bytes so this is quite

00:03:30,040 --> 00:03:33,400
similar to a typical key value store but

00:03:32,140 --> 00:03:37,840
a little bit richer since you have the

00:03:33,400 --> 00:03:40,330
concept of folders right git does not

00:03:37,840 --> 00:03:42,400
only saw the current contents of files

00:03:40,330 --> 00:03:45,670
but also the full history of changes

00:03:42,400 --> 00:03:48,280
that list they led up to that point so

00:03:45,670 --> 00:03:50,290
we have this concept of commits where a

00:03:48,280 --> 00:03:53,850
set of changes is bundled into a single

00:03:50,290 --> 00:03:55,690
entity and also contains metadata about

00:03:53,850 --> 00:03:57,790
what happened there what is the

00:03:55,690 --> 00:04:01,780
description of the changes in author and

00:03:57,790 --> 00:04:04,060
so on and actually as you probably know

00:04:01,780 --> 00:04:06,580
it allows multiple versions of this

00:04:04,060 --> 00:04:09,160
perhaps true contents mappings to exist

00:04:06,580 --> 00:04:11,590
in the form of branches which branch

00:04:09,160 --> 00:04:14,350
originated from a particular commit and

00:04:11,590 --> 00:04:17,650
key later be merged into a branch to

00:04:14,350 --> 00:04:21,130
combine these two mappings so this means

00:04:17,650 --> 00:04:25,530
that the commits actually form a

00:04:21,130 --> 00:04:25,530
directed acyclic graph of changes

00:04:25,870 --> 00:04:31,580
under the covers get star state in these

00:04:29,420 --> 00:04:34,250
two separate stores and one is an

00:04:31,580 --> 00:04:37,610
append-only content-addressable store

00:04:34,250 --> 00:04:41,480
that where it contains all the file

00:04:37,610 --> 00:04:43,240
contents trees and commits and when

00:04:41,480 --> 00:04:46,370
modifying data

00:04:43,240 --> 00:04:48,200
you never override or touch any of the

00:04:46,370 --> 00:04:50,720
existing entries you always create new

00:04:48,200 --> 00:04:53,600
things so that's all how all the

00:04:50,720 --> 00:04:55,820
revisions of the stores preserved using

00:04:53,600 --> 00:04:57,740
content addressing you can lower this

00:04:55,820 --> 00:05:00,710
space overhead of this and you can also

00:04:57,740 --> 00:05:04,100
use dust compression to make this more

00:05:00,710 --> 00:05:06,020
efficient branches on the end are kept

00:05:04,100 --> 00:05:08,900
in the immutable store because those

00:05:06,020 --> 00:05:11,300
will actually continuously be updated to

00:05:08,900 --> 00:05:13,990
point to new revisions in the

00:05:11,300 --> 00:05:17,810
append-only storm so that's how the

00:05:13,990 --> 00:05:22,880
contents of a branch changes by a tree

00:05:17,810 --> 00:05:25,160
or commits never changes contents so how

00:05:22,880 --> 00:05:27,350
does this description of get fit with

00:05:25,160 --> 00:05:30,200
the problems that we set out to solve

00:05:27,350 --> 00:05:33,440
with ermine well you might consider a

00:05:30,200 --> 00:05:35,810
development team to be the set of nodes

00:05:33,440 --> 00:05:38,810
trying to collaborate on a code base

00:05:35,810 --> 00:05:40,040
which is this yet state each developer

00:05:38,810 --> 00:05:42,530
can work autonomously

00:05:40,040 --> 00:05:43,480
on the codebase even without a network

00:05:42,530 --> 00:05:45,710
connection

00:05:43,480 --> 00:05:47,630
synchronizing between developers is a

00:05:45,710 --> 00:05:50,840
matter of pushing and pulling data to

00:05:47,630 --> 00:05:52,910
each other and any file and the code

00:05:50,840 --> 00:05:56,419
base can be explained by a sequence of

00:05:52,910 --> 00:05:59,090
annotated changes so this is how git

00:05:56,419 --> 00:06:01,540
actually fits really well with the

00:05:59,090 --> 00:06:06,740
problems that Ormond set out to solve

00:06:01,540 --> 00:06:08,870
and in many ways this description of get

00:06:06,740 --> 00:06:11,330
carries over to ermine Herrmann is

00:06:08,870 --> 00:06:14,960
similar a mapping from pastevalues with

00:06:11,330 --> 00:06:16,580
commits branches merges at cetera this

00:06:14,960 --> 00:06:19,460
also means that all these benefits in

00:06:16,580 --> 00:06:22,340
characteristics we just described also

00:06:19,460 --> 00:06:24,890
fit for Foreman and erm is actually

00:06:22,340 --> 00:06:27,830
compatible with get to the point that

00:06:24,890 --> 00:06:31,100
the on disk format and the network

00:06:27,830 --> 00:06:34,240
protocol works with - well so you can

00:06:31,100 --> 00:06:37,169
clone a Herrmann database to your local

00:06:34,240 --> 00:06:43,860
laptop and you skid lock to inspire

00:06:37,169 --> 00:06:46,139
for example however airman diverges from

00:06:43,860 --> 00:06:47,759
guid in a couple of important ways to

00:06:46,139 --> 00:06:50,340
emphasize being a database not a source

00:06:47,759 --> 00:06:51,779
control management system so git is

00:06:50,340 --> 00:06:54,659
designed for storing sauce far as

00:06:51,779 --> 00:06:57,180
modified by humans at a low rate with

00:06:54,659 --> 00:06:59,159
semi-automatic merchants while

00:06:57,180 --> 00:07:01,680
Erman must or application specific

00:06:59,159 --> 00:07:04,469
values modified by applications at a

00:07:01,680 --> 00:07:07,740
much higher rate of change and you can't

00:07:04,469 --> 00:07:11,339
have a programmer to come in and fix it

00:07:07,740 --> 00:07:14,490
when there is a conflict and this idea

00:07:11,339 --> 00:07:16,620
around not just storing blobs of bytes

00:07:14,490 --> 00:07:19,080
but actually application specific values

00:07:16,620 --> 00:07:20,909
is is one of the the key features of

00:07:19,080 --> 00:07:23,430
vermin so we'll talk a little bit more

00:07:20,909 --> 00:07:25,729
more about that so I'm sure you've all

00:07:23,430 --> 00:07:28,439
experienced merge conflicts in git and

00:07:25,729 --> 00:07:30,479
merge conflicts can similarly happen in

00:07:28,439 --> 00:07:33,779
ermine when you merge two branches and

00:07:30,479 --> 00:07:35,870
since there's no programmer to to solve

00:07:33,779 --> 00:07:39,749
it it has to have been programmatically

00:07:35,870 --> 00:07:41,610
and in foundation DB a value is just a

00:07:39,749 --> 00:07:44,009
blob of bytes right we don't know

00:07:41,610 --> 00:07:47,879
anything about it but this is slightly

00:07:44,009 --> 00:07:49,800
different in you know min so as a user

00:07:47,879 --> 00:07:51,569
of M and you actually have to define a

00:07:49,800 --> 00:07:53,339
three-way merge function between the

00:07:51,569 --> 00:07:56,699
least common ancestor and the two

00:07:53,339 --> 00:08:00,479
conflicting values and this can either

00:07:56,699 --> 00:08:02,879
result in this being merged nicely into

00:08:00,479 --> 00:08:06,300
a new value or it can conflict and you

00:08:02,879 --> 00:08:09,330
can have an error message so to build a

00:08:06,300 --> 00:08:11,939
little bit of intuition here's a brief

00:08:09,330 --> 00:08:14,039
example where the application specific

00:08:11,939 --> 00:08:16,979
value is simply a number you can

00:08:14,039 --> 00:08:19,680
consider this a counter of some sorts

00:08:16,979 --> 00:08:21,719
and there are two branches that have

00:08:19,680 --> 00:08:24,029
been that have diverged on what the

00:08:21,719 --> 00:08:28,710
value should be and this is resulted in

00:08:24,029 --> 00:08:30,990
a conflict so maybe you're thinking

00:08:28,710 --> 00:08:33,419
what's the what's the proper way to

00:08:30,990 --> 00:08:36,959
address this here's at least one way

00:08:33,419 --> 00:08:39,300
that it could be solved which is summing

00:08:36,959 --> 00:08:43,019
the two new values and subtracting the

00:08:39,300 --> 00:08:45,149
old value and this will indeed give the

00:08:43,019 --> 00:08:47,010
result eight which agrees with our

00:08:45,149 --> 00:08:49,110
intuition that if six has been

00:08:47,010 --> 00:08:50,300
incremented four times and decremented

00:08:49,110 --> 00:08:53,570
two times then

00:08:50,300 --> 00:08:54,950
you get the number eight so this is a

00:08:53,570 --> 00:08:56,570
super simple example of an

00:08:54,950 --> 00:08:58,690
application-specific value but you can

00:08:56,570 --> 00:09:01,519
have something much more complex like

00:08:58,690 --> 00:09:03,380
Mercia book use much of a ropes or

00:09:01,519 --> 00:09:06,560
something else that fits whatever

00:09:03,380 --> 00:09:08,779
application you're writing a final

00:09:06,560 --> 00:09:11,570
observation here is that if you have a

00:09:08,779 --> 00:09:13,459
merge function that never conflicts then

00:09:11,570 --> 00:09:15,980
you have something that's equivalent of

00:09:13,459 --> 00:09:20,510
a CI DC contact free replicated data

00:09:15,980 --> 00:09:22,339
type so it's true if she mentioned

00:09:20,510 --> 00:09:24,680
Hermann makes very few assumptions about

00:09:22,339 --> 00:09:26,810
the host environment and one of the ways

00:09:24,680 --> 00:09:29,060
this shows is by having a pluggable

00:09:26,810 --> 00:09:32,149
storage engine so there's already a

00:09:29,060 --> 00:09:34,550
number of such engines for storing on

00:09:32,149 --> 00:09:37,250
disk in memory in Redis and even in

00:09:34,550 --> 00:09:40,310
index TV in the browser and this is

00:09:37,250 --> 00:09:42,589
where this work on with Foundation TV

00:09:40,310 --> 00:09:45,730
comes in so essentially what I've

00:09:42,589 --> 00:09:49,040
written is a search engine called

00:09:45,730 --> 00:09:52,430
Hermann FTB so let's let's look more

00:09:49,040 --> 00:09:54,019
closely at that so the first step of

00:09:52,430 --> 00:09:58,700
actually implementing the search engine

00:09:54,019 --> 00:10:00,860
was creating bindings for FTP in Okemo

00:09:58,700 --> 00:10:02,810
in case you're not familiar with ok mo

00:10:00,860 --> 00:10:04,459
it's sadly it's hype functional

00:10:02,810 --> 00:10:06,730
programming language quite similar to

00:10:04,459 --> 00:10:09,410
haskell but with strict evaluations

00:10:06,730 --> 00:10:13,010
strict evaluation and imperative

00:10:09,410 --> 00:10:15,680
features so despite being you know not

00:10:13,010 --> 00:10:18,440
that a little bit esoteric maybe for

00:10:15,680 --> 00:10:22,130
some people foundation DB and the api

00:10:18,440 --> 00:10:23,740
fit quite nicely using closures to kind

00:10:22,130 --> 00:10:27,890
of automatically reach five failed

00:10:23,740 --> 00:10:31,760
commits and a synchronicity fits really

00:10:27,890 --> 00:10:33,740
well with monads the trees part about

00:10:31,760 --> 00:10:35,240
and implementing these these bindings

00:10:33,740 --> 00:10:36,620
we've been about the interaction with

00:10:35,240 --> 00:10:39,410
the garbage collector which i think is

00:10:36,620 --> 00:10:46,579
an observation that many other bindings

00:10:39,410 --> 00:10:48,649
share so implementing a search engine

00:10:46,579 --> 00:10:51,500
for Foreman is for the most part quite

00:10:48,649 --> 00:10:54,560
simple this is kind of the first half of

00:10:51,500 --> 00:10:57,110
the signature that you must implement

00:10:54,560 --> 00:10:58,820
for search engine which is simply

00:10:57,110 --> 00:11:01,880
checking with a key is present in the

00:10:58,820 --> 00:11:03,470
store finding the value of the

00:11:01,880 --> 00:11:05,600
setting a key to particular value

00:11:03,470 --> 00:11:07,930
removing key listing the keys in the

00:11:05,600 --> 00:11:10,790
store and finally a test and celebration

00:11:07,930 --> 00:11:13,070
and most of these are quite straight

00:11:10,790 --> 00:11:15,350
forward to map to Foundation dB

00:11:13,070 --> 00:11:18,769
the most complex being test and said in

00:11:15,350 --> 00:11:21,170
particularly because kind of the quality

00:11:18,769 --> 00:11:23,300
function is not comparing the serialized

00:11:21,170 --> 00:11:26,060
versions of the data but it's actually a

00:11:23,300 --> 00:11:29,209
user provided a quality function over

00:11:26,060 --> 00:11:31,310
the application specific value but using

00:11:29,209 --> 00:11:33,920
transactions is it's fairly simple just

00:11:31,310 --> 00:11:36,200
start transaction get the get the value

00:11:33,920 --> 00:11:40,430
compare and otherwise said so yeah

00:11:36,200 --> 00:11:42,649
transactions save the day yet again the

00:11:40,430 --> 00:11:45,620
second part of implementing a search

00:11:42,649 --> 00:11:47,450
engine is around watches so signals the

00:11:45,620 --> 00:11:50,390
foundation DB airman has a notion of

00:11:47,450 --> 00:11:52,670
watches and you can actually both watch

00:11:50,390 --> 00:11:56,810
a single key and the entire key space

00:11:52,670 --> 00:11:58,700
and there's also the caveat that you

00:11:56,810 --> 00:12:02,089
need to be able to you need to provide

00:11:58,700 --> 00:12:05,390
the value at the time that this was

00:12:02,089 --> 00:12:06,920
triggered which is unlike the watches in

00:12:05,390 --> 00:12:09,500
foundation DB that just tells you

00:12:06,920 --> 00:12:14,570
something has changed but you don't know

00:12:09,500 --> 00:12:16,370
how the value changed so this is

00:12:14,570 --> 00:12:18,980
something that has to happen in the

00:12:16,370 --> 00:12:22,610
storage engine and it's not kind of

00:12:18,980 --> 00:12:26,060
easily handled by foundation DB so we'll

00:12:22,610 --> 00:12:27,800
look at in more Tisa at how to handle

00:12:26,060 --> 00:12:30,800
watching the entire key space which is

00:12:27,800 --> 00:12:33,230
the most tricky and this is a user case

00:12:30,800 --> 00:12:35,450
that's come up also a couple of other

00:12:33,230 --> 00:12:38,089
times today kind of how to handle these

00:12:35,450 --> 00:12:41,240
change feeds so it here's at least one

00:12:38,089 --> 00:12:45,290
take on it so this is special key code

00:12:41,240 --> 00:12:47,270
here okay watch aw which is used to

00:12:45,290 --> 00:12:49,339
notify changes and then there's the the

00:12:47,270 --> 00:12:52,910
range of keys here obvious one one in in

00:12:49,339 --> 00:12:57,199
vs - which is a log of the actual

00:12:52,910 --> 00:13:01,519
changes so here K 1 and is the key that

00:12:57,199 --> 00:13:05,720
changed and V 1 describes how it's

00:13:01,519 --> 00:13:09,589
changed so when creating a firm and

00:13:05,720 --> 00:13:13,000
watch the washer starts crazy and after

00:13:09,589 --> 00:13:15,430
we watch for the special key K watch saw

00:13:13,000 --> 00:13:20,439
finds the end of the log and maintains

00:13:15,430 --> 00:13:24,339
this internal cursor whenever a man then

00:13:20,439 --> 00:13:28,209
mutates data its atomically increment K

00:13:24,339 --> 00:13:30,279
what sha and adds a version stamp to the

00:13:28,209 --> 00:13:33,699
changelog with the description of what

00:13:30,279 --> 00:13:36,250
changed so this entire thing happens in

00:13:33,699 --> 00:13:39,120
a single transaction and the watcher

00:13:36,250 --> 00:13:42,430
will then be notified and can replay

00:13:39,120 --> 00:13:47,769
changes from its internal cursor until

00:13:42,430 --> 00:13:51,060
the end of the changelog so as described

00:13:47,769 --> 00:13:53,639
so far this solution will accumulate

00:13:51,060 --> 00:13:59,430
this chief lock will grow indefinitely

00:13:53,639 --> 00:14:02,279
so there is a time configurable interval

00:13:59,430 --> 00:14:06,339
after which the changelog will be

00:14:02,279 --> 00:14:08,319
cleaned up again this could be made more

00:14:06,339 --> 00:14:10,329
efficient if the washers actually kept

00:14:08,319 --> 00:14:13,720
state in foundation dB

00:14:10,329 --> 00:14:15,189
but that doesn't happen right now an

00:14:13,720 --> 00:14:18,790
entirely different approach to this

00:14:15,189 --> 00:14:21,579
which is made which is possible because

00:14:18,790 --> 00:14:24,550
the entire history of the store is

00:14:21,579 --> 00:14:27,990
actually already stored in foundation to

00:14:24,550 --> 00:14:30,699
be it would be to leverage that instead

00:14:27,990 --> 00:14:33,370
that I haven't explored that at this

00:14:30,699 --> 00:14:35,740
point this solution has a draw bag of

00:14:33,370 --> 00:14:39,610
amplifying right volume but on the other

00:14:35,740 --> 00:14:43,959
hand it makes watches really efficient

00:14:39,610 --> 00:14:47,290
so there's a bit of a trade-off there so

00:14:43,959 --> 00:14:49,629
right now the search engine passes kind

00:14:47,290 --> 00:14:52,329
of the very extensive remains-- test

00:14:49,629 --> 00:14:56,050
suite and there's preliminary benchmarks

00:14:52,329 --> 00:14:59,410
that show it's comparable to the other

00:14:56,050 --> 00:15:02,110
engines though the workloads that the

00:14:59,410 --> 00:15:04,300
current main benchmark suite contains is

00:15:02,110 --> 00:15:06,069
not really kind of exploit that the

00:15:04,300 --> 00:15:09,819
engine is horizontally scalable so it

00:15:06,069 --> 00:15:12,600
doesn't kind of shine in that sense but

00:15:09,819 --> 00:15:15,610
it's definitely showing promise and then

00:15:12,600 --> 00:15:19,180
also further work on the Okemah FTB

00:15:15,610 --> 00:15:20,709
bindings in particular i want them to

00:15:19,180 --> 00:15:22,660
pass the binding test at which they

00:15:20,709 --> 00:15:26,639
don't at this point but it's

00:15:22,660 --> 00:15:30,759
quite a lot of work to pass everything

00:15:26,639 --> 00:15:34,389
so from the perspective of foundation DB

00:15:30,759 --> 00:15:37,529
you can consider this to be like a kit

00:15:34,389 --> 00:15:42,100
layer that allows you to store it inside

00:15:37,529 --> 00:15:44,079
with data in your cluster via kit and

00:15:42,100 --> 00:15:46,689
actually we have a you know perfect

00:15:44,079 --> 00:15:48,759
inception opportunity here because the

00:15:46,689 --> 00:15:52,000
source code for foundation DB could be

00:15:48,759 --> 00:15:55,540
stored in foundation to be right seems

00:15:52,000 --> 00:15:57,430
like we we can't miss that one for

00:15:55,540 --> 00:15:59,860
airman there are some really interesting

00:15:57,430 --> 00:16:03,040
perspectives in having a horizontally

00:15:59,860 --> 00:16:04,930
scalable storage engine first of all it

00:16:03,040 --> 00:16:07,990
will allow and note in the in the

00:16:04,930 --> 00:16:10,029
network and the cluster to kind of play

00:16:07,990 --> 00:16:13,709
a high traffic role in the same sense

00:16:10,029 --> 00:16:15,939
that kid hubs replica of your kid Rocko

00:16:13,709 --> 00:16:17,319
serves a very different purpose through

00:16:15,939 --> 00:16:19,990
the kid ravu yet that you have on your

00:16:17,319 --> 00:16:23,439
local laptop and and this this really

00:16:19,990 --> 00:16:26,560
enables that use case secondly there's

00:16:23,439 --> 00:16:29,290
this idea to introduce tiered storage in

00:16:26,560 --> 00:16:32,620
ermine so I know it can have only a

00:16:29,290 --> 00:16:35,319
limited amount of the history locally on

00:16:32,620 --> 00:16:37,990
disk and then it can fail the rest fetch

00:16:35,319 --> 00:16:40,839
the rest of the history from a remote

00:16:37,990 --> 00:16:43,389
storage such as foundation DB but

00:16:40,839 --> 00:16:45,509
otherwise a great next step is to have

00:16:43,389 --> 00:16:48,430
one of the industry uses of ermine adopt

00:16:45,509 --> 00:16:52,360
M&F DB I think that what would really

00:16:48,430 --> 00:16:53,829
drive the project forward and with that

00:16:52,360 --> 00:16:56,870
thanks for listening you can find all

00:16:53,829 --> 00:17:00,249
this source code on github

00:16:56,870 --> 00:17:00,249

YouTube URL: https://www.youtube.com/watch?v=NArvw-9axeg


