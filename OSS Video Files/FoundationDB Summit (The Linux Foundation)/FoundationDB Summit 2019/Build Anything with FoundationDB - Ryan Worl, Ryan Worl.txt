Title: Build Anything with FoundationDB - Ryan Worl, Ryan Worl
Publication date: 2019-11-25
Playlist: FoundationDB Summit 2019
Description: 
	Build Anything with FoundationDB - Ryan Worl, Ryan Worl 

FoundationDB is like a database construction kit, which can be intimidating to new developers and those unfamiliar with database system design and internals. In this talk, Ryan will explain how to start from nothing but an empty key-value store and build anything you can dream up, all while retaining the safety and reliability you expect from FoundationDB.

The first example will focus on the components needed to build a database with a schema, non-blocking schema changes, secondary index construction, and a change data capture system for auditing and ETL.

The second example will show how to add strongly consistent object listing to an eventually consistent object storage system like Amazon S3, as well as adding the ability to append to existing objects, which Amazon S3 doesn't offer.

You'll leave with the ability to map your ideas into keys and values to build creative solutions.
Captions: 
	00:00:00,000 --> 00:00:05,130
so my name is Ren Worrell and I'm here

00:00:02,879 --> 00:00:09,420
to talk to you today about how to build

00:00:05,130 --> 00:00:12,330
anything with foundation TV I know that

00:00:09,420 --> 00:00:14,219
sounds a little nuts I can't it can't be

00:00:12,330 --> 00:00:18,119
literally everything because I'm only

00:00:14,219 --> 00:00:21,660
here for a far but I want to provide you

00:00:18,119 --> 00:00:23,550
with some ideas and some inspiration to

00:00:21,660 --> 00:00:26,400
tell you that even if you're not super

00:00:23,550 --> 00:00:29,519
familiar with foundation TV today that

00:00:26,400 --> 00:00:31,529
you can you know dream up things that

00:00:29,519 --> 00:00:33,570
you can do in the future and I want to

00:00:31,529 --> 00:00:36,000
give you the foundations of of just like

00:00:33,570 --> 00:00:39,559
how do you use keys and values to do

00:00:36,000 --> 00:00:42,660
stuff and we're gonna do that with two

00:00:39,559 --> 00:00:45,239
examples today the first one will be

00:00:42,660 --> 00:00:48,510
modeling what looks like a relational

00:00:45,239 --> 00:00:50,190
database schema which you are all very

00:00:48,510 --> 00:00:52,890
familiar with by now after all the talks

00:00:50,190 --> 00:00:56,430
about the record layer and some of the

00:00:52,890 --> 00:01:00,809
details were in the couch TV layer as

00:00:56,430 --> 00:01:04,290
well and the second problem is how to

00:01:00,809 --> 00:01:06,240
add features to an existing distributed

00:01:04,290 --> 00:01:08,700
system that doesn't provide super strong

00:01:06,240 --> 00:01:12,150
guarantees and we're gonna do that by

00:01:08,700 --> 00:01:14,070
adding consistent object listing

00:01:12,150 --> 00:01:20,280
basically removing some of the problems

00:01:14,070 --> 00:01:24,229
with Amazon s3 so when you when you

00:01:20,280 --> 00:01:24,229
start using foundation even you you get

00:01:24,860 --> 00:01:29,610
you're basically dropped into a world

00:01:27,299 --> 00:01:30,930
with nothing and you have to figure out

00:01:29,610 --> 00:01:32,250
what to do yourself it's now quite

00:01:30,930 --> 00:01:36,630
literally nothing because you have this

00:01:32,250 --> 00:01:38,610
tuple air but it's not a whole lot and I

00:01:36,630 --> 00:01:41,189
think this is a quote from Dave share

00:01:38,610 --> 00:01:43,380
I'm not entirely sure I think it's from

00:01:41,189 --> 00:01:44,759
the first open source thread on Hacker

00:01:43,380 --> 00:01:46,590
News when foundation you view is

00:01:44,759 --> 00:01:48,600
released and this is the best

00:01:46,590 --> 00:01:52,049
description I have ever seen of what it

00:01:48,600 --> 00:01:54,299
feels like to use foundation DB what I

00:01:52,049 --> 00:01:57,380
want to do today is give you the hammer

00:01:54,299 --> 00:02:01,619
and the nails with which to take those

00:01:57,380 --> 00:02:05,189
2x4 framing studs and build a house or a

00:02:01,619 --> 00:02:08,459
database an alternative way to look at

00:02:05,189 --> 00:02:10,020
it is you get some Lego which is a

00:02:08,459 --> 00:02:12,150
little bit more fun than building a

00:02:10,020 --> 00:02:15,659
house

00:02:12,150 --> 00:02:17,790
so when we're talking about databases I

00:02:15,659 --> 00:02:20,640
think we should you know I want to do

00:02:17,790 --> 00:02:23,879
some definitions first and and you know

00:02:20,640 --> 00:02:26,280
kind of map out where things fit and on

00:02:23,879 --> 00:02:29,340
that screen the D probably doesn't come

00:02:26,280 --> 00:02:33,090
across as vibrantly images on my screen

00:02:29,340 --> 00:02:35,940
but those are divided between blue and

00:02:33,090 --> 00:02:39,239
pink and what we're going to be talking

00:02:35,940 --> 00:02:41,730
about today is basically C in acid

00:02:39,239 --> 00:02:46,230
foundation EB does the other stuff for

00:02:41,730 --> 00:02:47,579
you so what is you know I you have to

00:02:46,230 --> 00:02:48,989
talk about this for a second I'm not

00:02:47,579 --> 00:02:50,579
talking about the C in the cap theorem

00:02:48,989 --> 00:02:52,470
that's not what I'm talking about you

00:02:50,579 --> 00:02:55,560
know this this is not what this talk is

00:02:52,470 --> 00:02:57,750
about this is really not relevant for

00:02:55,560 --> 00:02:58,859
the first half it'll be slightly more

00:02:57,750 --> 00:03:00,629
relevant for the second half but again

00:02:58,859 --> 00:03:02,909
really not really that's not the C I'm

00:03:00,629 --> 00:03:05,819
talking about this is the C I'm talking

00:03:02,909 --> 00:03:08,819
about your program brings the database

00:03:05,819 --> 00:03:13,739
from one valid state to another emphasis

00:03:08,819 --> 00:03:15,450
on your program this is your job so even

00:03:13,739 --> 00:03:18,000
you know even if you're just building a

00:03:15,450 --> 00:03:20,430
like a rails app on top of a sequel

00:03:18,000 --> 00:03:25,139
database it is still your job at least

00:03:20,430 --> 00:03:30,060
partially and you need the a I and D

00:03:25,139 --> 00:03:31,470
from acid in order to do this and my my

00:03:30,060 --> 00:03:35,459
experience in the real world this idea

00:03:31,470 --> 00:03:37,980
data corruption is is a combination of

00:03:35,459 --> 00:03:40,200
bad application code as in bugs that you

00:03:37,980 --> 00:03:41,669
all right in your programs and bad

00:03:40,200 --> 00:03:44,190
databases and I'm sure you've all

00:03:41,669 --> 00:03:45,419
experienced both some problems are a bit

00:03:44,190 --> 00:03:48,359
hard to track down whether it's one or

00:03:45,419 --> 00:03:49,819
the other but it's it's definitely a

00:03:48,359 --> 00:03:51,720
combination of the two and hopefully

00:03:49,819 --> 00:03:53,730
foundation EB gets rid of the bad

00:03:51,720 --> 00:03:54,959
databases part so it's just your bad

00:03:53,730 --> 00:04:00,000
code that's the problem that one gotta

00:03:54,959 --> 00:04:04,859
fix that so most databases provide you

00:04:00,000 --> 00:04:08,040
with a few things in the C realm other

00:04:04,859 --> 00:04:10,319
than a int which I already mentioned the

00:04:08,040 --> 00:04:12,150
most important one I would say is no

00:04:10,319 --> 00:04:14,400
false positives or negatives from index

00:04:12,150 --> 00:04:16,919
lookups that one you kind of need if you

00:04:14,400 --> 00:04:19,250
have indexes but again if this is your

00:04:16,919 --> 00:04:22,469
lair that's your job

00:04:19,250 --> 00:04:25,040
schema management like inserting and

00:04:22,469 --> 00:04:26,690
indexing records and

00:04:25,040 --> 00:04:28,580
some elements of type-checking not all

00:04:26,690 --> 00:04:33,020
databases do that but a lot of them do

00:04:28,580 --> 00:04:35,210
and foreign key like referential

00:04:33,020 --> 00:04:36,830
integrity constraints not all databases

00:04:35,210 --> 00:04:40,820
to support those either but if you're

00:04:36,830 --> 00:04:43,700
gonna add that it's it's useful for

00:04:40,820 --> 00:04:48,140
ensuring you know there are no bugs in

00:04:43,700 --> 00:04:50,090
your in your program logic so how do you

00:04:48,140 --> 00:04:53,000
create consistency and remember this is

00:04:50,090 --> 00:04:55,430
consistency and the acid cents not in

00:04:53,000 --> 00:04:58,430
the cap theorem sense so yeah you're

00:04:55,430 --> 00:05:01,730
you're provided with AI and D and C is

00:04:58,430 --> 00:05:02,770
your layers responsibility so how you do

00:05:01,730 --> 00:05:05,330
that

00:05:02,770 --> 00:05:08,090
so in the example today we're gonna talk

00:05:05,330 --> 00:05:09,800
about a simple sequel like schema it's

00:05:08,090 --> 00:05:13,280
not about any put it's not about any

00:05:09,800 --> 00:05:15,260
particular database it's just a logical

00:05:13,280 --> 00:05:16,910
model that we're gonna think about so

00:05:15,260 --> 00:05:19,610
it's it's a bit oversimplified but it's

00:05:16,910 --> 00:05:20,930
not too far off and I think the record

00:05:19,610 --> 00:05:22,730
layer talks gave you a lot of

00:05:20,930 --> 00:05:29,200
information about how to productionize

00:05:22,730 --> 00:05:31,430
that type of thing so more definitions

00:05:29,200 --> 00:05:33,290
because again there's these words are

00:05:31,430 --> 00:05:35,840
overloaded in a lot of domains so what

00:05:33,290 --> 00:05:38,480
do I mean by a database I mean a named

00:05:35,840 --> 00:05:39,620
container for tables and some other

00:05:38,480 --> 00:05:42,080
things that I'm not going to talk about

00:05:39,620 --> 00:05:44,960
but I'm just going to call talk about

00:05:42,080 --> 00:05:47,320
tables today - what is it table a table

00:05:44,960 --> 00:05:51,350
is a name container for indexes and

00:05:47,320 --> 00:05:53,090
attributes what is an index it's a

00:05:51,350 --> 00:05:56,090
description of how you transform a

00:05:53,090 --> 00:05:58,160
record into some type of key that you're

00:05:56,090 --> 00:06:03,380
going to index and what you're going to

00:05:58,160 --> 00:06:05,270
store in the value and an attribute I

00:06:03,380 --> 00:06:07,640
think you all kind of get that at some

00:06:05,270 --> 00:06:09,940
field on some record and that you're

00:06:07,640 --> 00:06:12,170
defining at the layer of the table

00:06:09,940 --> 00:06:14,120
what's foreign key I kind of talked

00:06:12,170 --> 00:06:16,520
about that before but but you you need a

00:06:14,120 --> 00:06:17,750
way to manage the lifecycle and the

00:06:16,520 --> 00:06:19,730
relationship between records across

00:06:17,750 --> 00:06:22,340
tables a lot of databases enforce that

00:06:19,730 --> 00:06:24,620
using enforce that using an index under

00:06:22,340 --> 00:06:26,570
the hood even if you don't have one not

00:06:24,620 --> 00:06:30,490
all I mean it's not in theory required

00:06:26,570 --> 00:06:32,750
but that's a common way to do it so

00:06:30,490 --> 00:06:35,720
using the tuple air which is basically

00:06:32,750 --> 00:06:37,470
the thing that you get in the bindings

00:06:35,720 --> 00:06:42,420
in order to structure your key

00:06:37,470 --> 00:06:44,130
is a good idea to use the you could

00:06:42,420 --> 00:06:46,560
think about modeling this as you've got

00:06:44,130 --> 00:06:49,110
a database called school it's got a

00:06:46,560 --> 00:06:53,760
table called students and an index that

00:06:49,110 --> 00:06:55,410
is the primary index and the the value

00:06:53,760 --> 00:06:56,520
that you store in this index key which

00:06:55,410 --> 00:07:01,410
I'm going to explain a little bit more

00:06:56,520 --> 00:07:04,140
is the value for that ID column and you

00:07:01,410 --> 00:07:06,570
you can see this structure over here I

00:07:04,140 --> 00:07:08,370
I'm gonna use this throughout the rest

00:07:06,570 --> 00:07:12,360
of this section of the talk each one of

00:07:08,370 --> 00:07:16,140
those blocks is some component in a in a

00:07:12,360 --> 00:07:18,630
tuple and the way that I've the the

00:07:16,140 --> 00:07:20,970
insight here that I think is may not be

00:07:18,630 --> 00:07:22,440
obvious is that if you're trying to

00:07:20,970 --> 00:07:24,570
think about how you model a sequel

00:07:22,440 --> 00:07:26,970
database is the primary index is an

00:07:24,570 --> 00:07:29,669
index like any other index and you can

00:07:26,970 --> 00:07:32,610
put data in there like any other index

00:07:29,669 --> 00:07:35,250
and it's not it's not necessarily some

00:07:32,610 --> 00:07:36,510
special thing this is the kind of

00:07:35,250 --> 00:07:37,890
creativity you have to have I'm thinking

00:07:36,510 --> 00:07:42,600
about how you're gonna how you're gonna

00:07:37,890 --> 00:07:46,440
model things so what about a non primary

00:07:42,600 --> 00:07:49,350
index that's another index too and as an

00:07:46,440 --> 00:07:51,690
aside here the the long names in the

00:07:49,350 --> 00:07:53,669
components of the the tuple are just for

00:07:51,690 --> 00:07:55,650
illustration purposes you're not gonna

00:07:53,669 --> 00:07:58,110
actually do that in a real layer until

00:07:55,650 --> 00:08:00,270
maybe you would with redwood prefix

00:07:58,110 --> 00:08:01,800
compression but today you'd probably use

00:08:00,270 --> 00:08:04,050
something like the directory layer to

00:08:01,800 --> 00:08:05,640
turn those into shorter prefix codes or

00:08:04,050 --> 00:08:06,900
something that you do yourself there's a

00:08:05,640 --> 00:08:08,910
benefit to doing this besides just

00:08:06,900 --> 00:08:12,630
prefix compression that I'll talk about

00:08:08,910 --> 00:08:14,669
later so remember when I said what an

00:08:12,630 --> 00:08:17,760
index is it's some rules for

00:08:14,669 --> 00:08:20,100
transforming a record into a key that

00:08:17,760 --> 00:08:24,090
you put in an index and a value that you

00:08:20,100 --> 00:08:27,300
store this index is a non unique index

00:08:24,090 --> 00:08:29,160
you can imagine some other person with

00:08:27,300 --> 00:08:31,789
my name and some zip code I used to live

00:08:29,160 --> 00:08:35,969
in that is also indexing in this table

00:08:31,789 --> 00:08:37,950
so you need to store the primary key for

00:08:35,969 --> 00:08:41,039
the record at the end so if you imagine

00:08:37,950 --> 00:08:43,289
there's another person named Brian that

00:08:41,039 --> 00:08:45,240
lived in zip code one zero zero seven

00:08:43,289 --> 00:08:46,830
five they could have primary key two and

00:08:45,240 --> 00:08:48,330
they could both live in the index so

00:08:46,830 --> 00:08:50,630
that when you do a range scan you get

00:08:48,330 --> 00:08:52,800
both records

00:08:50,630 --> 00:08:56,010
so this is the the difference between

00:08:52,800 --> 00:08:57,660
unique and a non unique index key on a

00:08:56,010 --> 00:09:01,080
unique index you wouldn't put the

00:08:57,660 --> 00:09:02,820
primary key necessarily in at the end of

00:09:01,080 --> 00:09:04,740
the key there's this is you know things

00:09:02,820 --> 00:09:06,690
that you can choose to do but it's a

00:09:04,740 --> 00:09:08,610
method of ensuring that your index is

00:09:06,690 --> 00:09:10,440
unique it's not about enforcing the rule

00:09:08,610 --> 00:09:12,360
that's something that you do in your

00:09:10,440 --> 00:09:14,790
code but this is just a way to structure

00:09:12,360 --> 00:09:16,080
the key you'd still presumably go read

00:09:14,790 --> 00:09:17,340
that key and make sure that it actually

00:09:16,080 --> 00:09:19,260
doesn't exist before you just blindly

00:09:17,340 --> 00:09:20,640
write to it that's not the point of what

00:09:19,260 --> 00:09:25,200
I'm trying to illustrate just just the

00:09:20,640 --> 00:09:29,190
key structure yeah so you you want to

00:09:25,200 --> 00:09:32,400
keep the the the last value in the key

00:09:29,190 --> 00:09:34,200
as the the primary key just again so

00:09:32,400 --> 00:09:35,670
that when you do a range scan you get

00:09:34,200 --> 00:09:42,360
them all back and you can dereference

00:09:35,670 --> 00:09:44,490
them on the base table this was covered

00:09:42,360 --> 00:09:47,400
in the couch TV talk today and it's it's

00:09:44,490 --> 00:09:51,030
very important if your users expect your

00:09:47,400 --> 00:09:54,330
data to come back in some some order

00:09:51,030 --> 00:09:56,220
that's like a sword order that's innate

00:09:54,330 --> 00:09:58,860
that's for their native language it's

00:09:56,220 --> 00:10:02,190
not just the bite order you need to

00:09:58,860 --> 00:10:04,650
support collation is what it's typically

00:10:02,190 --> 00:10:06,600
called where you would store some type

00:10:04,650 --> 00:10:09,720
of a representation that goes through

00:10:06,600 --> 00:10:12,240
something like ICU to turn it into a key

00:10:09,720 --> 00:10:13,140
that sorts well and for the database but

00:10:12,240 --> 00:10:14,840
then you need to also store the

00:10:13,140 --> 00:10:18,870
representation that the user would see

00:10:14,840 --> 00:10:20,040
that's important for basically if your

00:10:18,870 --> 00:10:21,600
if your app is going to be used by

00:10:20,040 --> 00:10:26,760
people that don't just speak English you

00:10:21,600 --> 00:10:28,950
need to you need to do that so cockroach

00:10:26,760 --> 00:10:31,340
TV which is a sequel database built on

00:10:28,950 --> 00:10:33,240
top of a key value store has some

00:10:31,340 --> 00:10:34,860
documentation about how they do this

00:10:33,240 --> 00:10:37,020
which is very good because it's like a

00:10:34,860 --> 00:10:38,850
real thing that works in the world and

00:10:37,020 --> 00:10:41,040
it has lots of details just like the

00:10:38,850 --> 00:10:43,950
record layer that you could that you

00:10:41,040 --> 00:10:45,450
could go check out and I'm gonna re

00:10:43,950 --> 00:10:47,610
upload a new version of the slides if

00:10:45,450 --> 00:10:50,880
you saw them doesn't have this in it but

00:10:47,610 --> 00:10:53,520
it will assume so you don't need to take

00:10:50,880 --> 00:10:55,260
a picture or whatever yeah so the I mean

00:10:53,520 --> 00:10:57,570
now I can explain to you why why you

00:10:55,260 --> 00:11:00,000
would necessarily not just for prefix

00:10:57,570 --> 00:11:01,770
compression benefits want to put some

00:11:00,000 --> 00:11:03,460
type of indirection between the name of

00:11:01,770 --> 00:11:07,210
a table for example in the

00:11:03,460 --> 00:11:09,790
the idea of a table so if you wanted to

00:11:07,210 --> 00:11:11,950
support renaming a table or any other

00:11:09,790 --> 00:11:13,240
logical schema object you don't want to

00:11:11,950 --> 00:11:14,320
have to rewrite the whole thing just

00:11:13,240 --> 00:11:16,630
because you stuck it in the key that

00:11:14,320 --> 00:11:19,630
would be annoying so there there are

00:11:16,630 --> 00:11:21,490
benefits as well to to being able to do

00:11:19,630 --> 00:11:24,040
that type of renaming and and you know

00:11:21,490 --> 00:11:28,960
remapping it to some some ID the scheme

00:11:24,040 --> 00:11:30,970
object another feature that you may want

00:11:28,960 --> 00:11:35,080
in your lair is non-blocking schema

00:11:30,970 --> 00:11:37,810
changes the consistent metadata

00:11:35,080 --> 00:11:40,810
management feature added in 6:1 makes

00:11:37,810 --> 00:11:43,060
this much easier than it would have been

00:11:40,810 --> 00:11:46,960
in the past so I can actually explain it

00:11:43,060 --> 00:11:48,820
in in 30 minutes so when I say

00:11:46,960 --> 00:11:49,840
consistent again moving the database

00:11:48,820 --> 00:11:51,610
from one valid state to the other

00:11:49,840 --> 00:11:53,800
consistent in terms of the metadata

00:11:51,610 --> 00:11:57,250
management is a that's the the cap

00:11:53,800 --> 00:11:59,260
theorem type of consistency but that's

00:11:57,250 --> 00:12:01,720
the one I'm talking about right now so

00:11:59,260 --> 00:12:03,160
an index must not return false negatives

00:12:01,720 --> 00:12:07,030
by allowing queries before it is fully

00:12:03,160 --> 00:12:10,000
built that is a rule how does the

00:12:07,030 --> 00:12:15,570
metadata version feature help so if you

00:12:10,000 --> 00:12:18,310
version stamp the metadata object that

00:12:15,570 --> 00:12:21,010
excuse me if you if you update the

00:12:18,310 --> 00:12:24,550
metadata object and update the metadata

00:12:21,010 --> 00:12:26,770
version key at the same time you can you

00:12:24,550 --> 00:12:29,080
know as was described in the lightning

00:12:26,770 --> 00:12:30,850
talk keep a keep the history of the

00:12:29,080 --> 00:12:32,410
metadata and cash it in your layer so

00:12:30,850 --> 00:12:35,770
you don't have to repeatedly read it out

00:12:32,410 --> 00:12:38,140
of the database and cause a hotspot it's

00:12:35,770 --> 00:12:41,260
stored at that key which everyone saw

00:12:38,140 --> 00:12:44,230
earlier today and you use this to signal

00:12:41,260 --> 00:12:46,690
that metadata has been changed in your

00:12:44,230 --> 00:12:49,750
layer again this is stuff that you've

00:12:46,690 --> 00:12:51,550
already seen you it's it's free to get

00:12:49,750 --> 00:12:52,930
this key that's another thing that I

00:12:51,550 --> 00:12:54,400
want to emphasize it's free to get this

00:12:52,930 --> 00:12:55,300
because it's it's sent to you

00:12:54,400 --> 00:13:00,400
automatically when you start a

00:12:55,300 --> 00:13:03,460
transaction in in starting in cyclone so

00:13:00,400 --> 00:13:07,240
the the paper that I think Alex referred

00:13:03,460 --> 00:13:10,060
me to originally about about how to do

00:13:07,240 --> 00:13:14,230
this is online asynchronous schema

00:13:10,060 --> 00:13:16,510
changes in f1 from from Google it's its

00:13:14,230 --> 00:13:17,230
f1 is there they're basically their

00:13:16,510 --> 00:13:19,480
sequel layer that

00:13:17,230 --> 00:13:21,850
works on top of spanner which you know

00:13:19,480 --> 00:13:24,250
it's roughly in a similar situation as

00:13:21,850 --> 00:13:25,480
you would be in foundation TV so it it

00:13:24,250 --> 00:13:26,560
makes sense it's a little bit tougher

00:13:25,480 --> 00:13:28,570
for them because they don't have that

00:13:26,560 --> 00:13:30,250
notion of a metadata version so the

00:13:28,570 --> 00:13:32,140
paper goes into lots of complicated

00:13:30,250 --> 00:13:34,210
rules about how to do this if you didn't

00:13:32,140 --> 00:13:35,500
have the meditative version luckily you

00:13:34,210 --> 00:13:38,860
can just implement the state machines in

00:13:35,500 --> 00:13:40,390
the paper and it's like easier so I'm

00:13:38,860 --> 00:13:42,100
gonna just describe adding an index

00:13:40,390 --> 00:13:43,890
there's a whole bunch of other ones that

00:13:42,100 --> 00:13:47,020
you can do that I'm not gonna describe

00:13:43,890 --> 00:13:48,550
but basically you you have to update the

00:13:47,020 --> 00:13:50,590
schema object and the meditative version

00:13:48,550 --> 00:13:53,770
in the same transaction to signal that

00:13:50,590 --> 00:13:55,900
the schema has changed you're doing this

00:13:53,770 --> 00:13:59,260
in a transaction it's atomic just like

00:13:55,900 --> 00:14:02,800
anything else so you set the initial

00:13:59,260 --> 00:14:04,660
state to write only and this means it's

00:14:02,800 --> 00:14:06,550
invisible to reads for other

00:14:04,660 --> 00:14:08,080
transactions that are going on why does

00:14:06,550 --> 00:14:10,300
it have to be invisible to reads because

00:14:08,080 --> 00:14:12,400
it's being built that means if you serve

00:14:10,300 --> 00:14:18,520
reads hermit it could serve false

00:14:12,400 --> 00:14:20,260
negatives so as as new transactions

00:14:18,520 --> 00:14:23,860
start after the metadata change happens

00:14:20,260 --> 00:14:27,310
they do write in to this index and again

00:14:23,860 --> 00:14:29,920
they don't read from it and same thing

00:14:27,310 --> 00:14:32,140
for for updates and deletes and in the

00:14:29,920 --> 00:14:35,350
background you you know you do a back

00:14:32,140 --> 00:14:37,780
some type of a backfill job to you add

00:14:35,350 --> 00:14:40,960
the new the new records and one way to

00:14:37,780 --> 00:14:42,850
fulfill this is to store the version of

00:14:40,960 --> 00:14:44,560
the metadata that an object was written

00:14:42,850 --> 00:14:45,940
with so that you know if it's like from

00:14:44,560 --> 00:14:48,940
the old or the new version of the schema

00:14:45,940 --> 00:14:52,320
and you can do a big scan in the

00:14:48,940 --> 00:14:52,320
background and and add it to the index

00:14:52,380 --> 00:14:57,630
yeah so you use that version to detect

00:14:55,000 --> 00:15:01,030
like if it's from before before after

00:14:57,630 --> 00:15:03,880
the the background scan that's something

00:15:01,030 --> 00:15:05,320
that Nicholas just mentioned is going to

00:15:03,880 --> 00:15:08,890
be more parallel in the future version

00:15:05,320 --> 00:15:10,240
of the record layer so again you can

00:15:08,890 --> 00:15:16,060
reference the record layer for how to

00:15:10,240 --> 00:15:17,020
implement these bits efficiently so when

00:15:16,060 --> 00:15:19,030
you're finished with that background

00:15:17,020 --> 00:15:21,910
scan and indexing all the records you

00:15:19,030 --> 00:15:23,380
can update that metadata again along

00:15:21,910 --> 00:15:25,600
with updating the metadata version to

00:15:23,380 --> 00:15:28,300
say the index is ready for readwrite

00:15:25,600 --> 00:15:30,220
traffic and then you're done and this is

00:15:28,300 --> 00:15:31,010
a lot more this is a lot simpler than

00:15:30,220 --> 00:15:34,250
what was just

00:15:31,010 --> 00:15:35,870
in the paper because you don't like you

00:15:34,250 --> 00:15:40,579
have access to that consistent metadata

00:15:35,870 --> 00:15:42,769
version another feature that you may

00:15:40,579 --> 00:15:44,990
want to implement because it's commonly

00:15:42,769 --> 00:15:46,670
requested by business people is to have

00:15:44,990 --> 00:15:50,389
change data capture so you can audit

00:15:46,670 --> 00:15:52,040
changes to your tables the goal of this

00:15:50,389 --> 00:15:54,620
is to log the before and after version

00:15:52,040 --> 00:15:57,139
of every record that's inserted into the

00:15:54,620 --> 00:15:58,970
database in the order that they were

00:15:57,139 --> 00:16:01,120
changed in some type of a log structure

00:15:58,970 --> 00:16:04,190
those of you who understand FTP you will

00:16:01,120 --> 00:16:07,089
understand that this is hard this is not

00:16:04,190 --> 00:16:09,470
a thing that you just get for free and

00:16:07,089 --> 00:16:11,240
that's why I'm giving you a warning that

00:16:09,470 --> 00:16:12,769
if you do this you really have to

00:16:11,240 --> 00:16:14,720
understand what you're doing and do some

00:16:12,769 --> 00:16:16,790
careful capacity planning because this

00:16:14,720 --> 00:16:20,149
is basically like append only type

00:16:16,790 --> 00:16:21,800
structure and if you fall behind while

00:16:20,149 --> 00:16:23,360
you're moving this around say you're

00:16:21,800 --> 00:16:24,769
gonna you know write it and then

00:16:23,360 --> 00:16:28,190
periodically move it in to some other

00:16:24,769 --> 00:16:31,459
system if you fall behind you will run

00:16:28,190 --> 00:16:34,370
out of disk space very rapidly so how

00:16:31,459 --> 00:16:36,139
could you implement this in FDB again

00:16:34,370 --> 00:16:38,630
this is this has performance

00:16:36,139 --> 00:16:40,010
implications but depending on how

00:16:38,630 --> 00:16:41,990
valuable it is to you this is a thing

00:16:40,010 --> 00:16:44,329
that you can do so before you write to a

00:16:41,990 --> 00:16:46,579
key which represents a record logically

00:16:44,329 --> 00:16:48,740
like in the primary index of the table

00:16:46,579 --> 00:16:49,970
you read it first so again this has

00:16:48,740 --> 00:16:51,529
performance implications because you

00:16:49,970 --> 00:16:53,630
have to do a read before you do write

00:16:51,529 --> 00:16:57,649
and it also has conflict implications

00:16:53,630 --> 00:16:58,940
potentially you store the new the new

00:16:57,649 --> 00:17:02,060
version of the record and the old

00:16:58,940 --> 00:17:06,049
version together in another value in

00:17:02,060 --> 00:17:08,870
some log looking thing using a version

00:17:06,049 --> 00:17:11,089
stamped operation and the reason that

00:17:08,870 --> 00:17:13,309
you can't do the read concurrently with

00:17:11,089 --> 00:17:15,679
the write or after is because of the

00:17:13,309 --> 00:17:16,850
read rights cache will like you'll just

00:17:15,679 --> 00:17:18,350
get back to value that you just wrote

00:17:16,850 --> 00:17:22,220
and you that will not that will be

00:17:18,350 --> 00:17:23,750
invalid for our goal here so when I when

00:17:22,220 --> 00:17:25,429
I say old and new I keep saying those

00:17:23,750 --> 00:17:27,890
words what do those mean old or new

00:17:25,429 --> 00:17:30,080
before and after this is basically the

00:17:27,890 --> 00:17:32,090
same the same thing for an insert before

00:17:30,080 --> 00:17:34,160
is null because it's a new record and

00:17:32,090 --> 00:17:37,700
the after is the inserted record if

00:17:34,160 --> 00:17:39,169
you've seen the my sequel bin log or any

00:17:37,700 --> 00:17:40,850
type of other database change log that's

00:17:39,169 --> 00:17:43,070
it it should be somewhat familiar to you

00:17:40,850 --> 00:17:44,100
but an update the before is the old

00:17:43,070 --> 00:17:45,750
value after

00:17:44,100 --> 00:17:49,470
the new value that one I think makes a

00:17:45,750 --> 00:17:52,500
lot of sense for a delete the old the

00:17:49,470 --> 00:17:54,510
old value of the before value excuse me

00:17:52,500 --> 00:17:57,000
the before is the old value and the

00:17:54,510 --> 00:18:00,510
after is null because the record no

00:17:57,000 --> 00:18:03,690
longer exists anymore so how would you

00:18:00,510 --> 00:18:07,620
implement something like this this is

00:18:03,690 --> 00:18:09,960
again a simplified key structure but the

00:18:07,620 --> 00:18:12,600
the primary index and the change data

00:18:09,960 --> 00:18:16,020
capture index are there again they're

00:18:12,600 --> 00:18:18,510
they're just indexes and you can take

00:18:16,020 --> 00:18:20,309
the old on the top you're imagining you

00:18:18,510 --> 00:18:22,380
you read out that old value you're gonna

00:18:20,309 --> 00:18:24,630
update it to the new value you would

00:18:22,380 --> 00:18:26,730
write into the change data capture index

00:18:24,630 --> 00:18:28,740
with a version stamp operation both the

00:18:26,730 --> 00:18:29,909
old and the new value such that you know

00:18:28,740 --> 00:18:34,169
in the future you can go back and read

00:18:29,909 --> 00:18:35,549
it out in order so another thing if

00:18:34,169 --> 00:18:37,860
you're familiar with foundation you have

00:18:35,549 --> 00:18:40,470
to try to avoid write hotspots you need

00:18:37,860 --> 00:18:41,789
to structure your your rights to write

00:18:40,470 --> 00:18:43,740
to multiple ranges at once

00:18:41,789 --> 00:18:46,110
so you don't over overload one storage

00:18:43,740 --> 00:18:47,880
server in order to read this log back

00:18:46,110 --> 00:18:50,100
out you have to read every one of the

00:18:47,880 --> 00:18:51,720
partitions starting between whatever

00:18:50,100 --> 00:18:54,990
version you're trying to read and up to

00:18:51,720 --> 00:18:56,970
that future version so this is a very

00:18:54,990 --> 00:18:58,919
naive way to to do that just sort of

00:18:56,970 --> 00:19:00,990
spread the data out pick a random number

00:18:58,919 --> 00:19:02,850
mod by the number of partitions there's

00:19:00,990 --> 00:19:04,740
many more fancier schemes that you could

00:19:02,850 --> 00:19:08,159
come up with especially if you wanted to

00:19:04,740 --> 00:19:10,049
keep records from the related records in

00:19:08,159 --> 00:19:12,570
the same in the same logical partition

00:19:10,049 --> 00:19:14,880
oh the reason why it should be a power

00:19:12,570 --> 00:19:18,030
two is because in theory you can split

00:19:14,880 --> 00:19:20,190
and merge the number of partitions you

00:19:18,030 --> 00:19:22,400
have basis based on based on that if you

00:19:20,190 --> 00:19:25,590
don't pick a power to that's partner do

00:19:22,400 --> 00:19:29,640
so a feature request that I have which

00:19:25,590 --> 00:19:31,549
may be it's it's somewhat related to

00:19:29,640 --> 00:19:34,740
things that are going on for backup but

00:19:31,549 --> 00:19:38,280
exposing the the data on the T logs to

00:19:34,740 --> 00:19:39,659
applications may be useful some people

00:19:38,280 --> 00:19:40,980
may find it easier than been

00:19:39,659 --> 00:19:43,559
implementing this thing it doesn't let

00:19:40,980 --> 00:19:45,390
you get the before images but it lets

00:19:43,559 --> 00:19:46,679
you get the after images which is maybe

00:19:45,390 --> 00:19:49,530
more valuable to some people than them

00:19:46,679 --> 00:19:50,970
before you could also implement this

00:19:49,530 --> 00:19:52,620
thing on the storage server all again

00:19:50,970 --> 00:19:56,130
and that's kind of crazy

00:19:52,620 --> 00:19:57,060
and it's it's not free but that's

00:19:56,130 --> 00:19:58,410
another spot that

00:19:57,060 --> 00:20:03,150
that can implement this for you as a

00:19:58,410 --> 00:20:04,770
change feeds type type feature this

00:20:03,150 --> 00:20:08,760
breaks the key value abstraction once

00:20:04,770 --> 00:20:11,040
again in favor of efficiency for for a

00:20:08,760 --> 00:20:13,050
high value use case it's arguable if

00:20:11,040 --> 00:20:14,880
this is high value for for you or not

00:20:13,050 --> 00:20:16,980
but that's just a common theme

00:20:14,880 --> 00:20:18,840
especially with the query pushdown

00:20:16,980 --> 00:20:21,570
feature that was that was talked about

00:20:18,840 --> 00:20:23,310
this morning by Evan it's it's breaking

00:20:21,570 --> 00:20:28,770
the abstraction in favor a little bit of

00:20:23,310 --> 00:20:31,440
efficiency so on to the the the second

00:20:28,770 --> 00:20:33,330
half or last third I guess however you

00:20:31,440 --> 00:20:36,150
want to call it but let me describe to

00:20:33,330 --> 00:20:38,520
you why Amazon s3 is not fun to work

00:20:36,150 --> 00:20:40,530
with and has a lot of limitations these

00:20:38,520 --> 00:20:42,900
are quotes from the documentation Amazon

00:20:40,530 --> 00:20:44,460
s3 offers eventual consistency for

00:20:42,900 --> 00:20:48,140
overwrite puts and deletes in all

00:20:44,460 --> 00:20:50,640
regions that doesn't sound good

00:20:48,140 --> 00:20:53,010
I'm not gonna read this one but but

00:20:50,640 --> 00:20:57,210
basically it just says that object

00:20:53,010 --> 00:20:58,350
listing is not consistent again not fun

00:20:57,210 --> 00:21:02,670
to work with if you want to work

00:20:58,350 --> 00:21:05,220
directly against s3 this one is not

00:21:02,670 --> 00:21:07,830
obvious at all and if you make a request

00:21:05,220 --> 00:21:10,560
s3 for an object that doesn't exist and

00:21:07,830 --> 00:21:12,540
then you write into that object so your

00:21:10,560 --> 00:21:13,730
speculatively hoping that an object will

00:21:12,540 --> 00:21:16,290
be there at some point

00:21:13,730 --> 00:21:18,750
future reads on that key will have

00:21:16,290 --> 00:21:21,360
eventual consistency I don't know why

00:21:18,750 --> 00:21:22,740
it's just a thing that it is maybe they

00:21:21,360 --> 00:21:26,760
fix it and don't update the

00:21:22,740 --> 00:21:29,120
documentation but yeah something gotta

00:21:26,760 --> 00:21:35,030
live with this is this is basically the

00:21:29,120 --> 00:21:38,040
the killer there's no conflict

00:21:35,030 --> 00:21:39,510
resolution that like it's not there's no

00:21:38,040 --> 00:21:40,830
locking basically if you're

00:21:39,510 --> 00:21:42,750
simultaneously try to write to the same

00:21:40,830 --> 00:21:44,250
key you better hope your timestamp is

00:21:42,750 --> 00:21:48,210
later for the thing that you wrote

00:21:44,250 --> 00:21:51,140
otherwise somebody else wins the thing

00:21:48,210 --> 00:21:54,570
I'm going to talk about is that that

00:21:51,140 --> 00:21:55,920
object locking mechanism that's somewhat

00:21:54,570 --> 00:21:58,620
of what we're we're gonna build but

00:21:55,920 --> 00:22:01,440
Foundation TV takes care of that that

00:21:58,620 --> 00:22:03,110
before you so what can you do with s3

00:22:01,440 --> 00:22:07,770
like what what actually does it give you

00:22:03,110 --> 00:22:09,600
assuming you read-only already written

00:22:07,770 --> 00:22:12,179
keys and you know for a fact that there

00:22:09,600 --> 00:22:14,940
right here and assuming you never update

00:22:12,179 --> 00:22:17,580
them you get consistent read after right

00:22:14,940 --> 00:22:20,309
that's basically the only thing you do

00:22:17,580 --> 00:22:23,940
not get consistent listing at all in any

00:22:20,309 --> 00:22:25,679
way so that's not a lot if you want to

00:22:23,940 --> 00:22:29,010
operate directly against s3 that's

00:22:25,679 --> 00:22:31,320
that's hard to deal with so how do we

00:22:29,010 --> 00:22:36,120
fix listing this one is kind of easy you

00:22:31,320 --> 00:22:37,470
just write all objects to s3 first I'll

00:22:36,120 --> 00:22:39,179
describe a little bit more about how you

00:22:37,470 --> 00:22:43,380
do that and then you write a pointer to

00:22:39,179 --> 00:22:45,720
that object into FTB so if you perform

00:22:43,380 --> 00:22:48,299
your your equivalent of s3 list

00:22:45,720 --> 00:22:50,850
operations using only foundation DB get

00:22:48,299 --> 00:22:53,309
range requests you get consistent object

00:22:50,850 --> 00:22:55,380
listing now there's there's lots of more

00:22:53,309 --> 00:22:57,240
details that you can go into about this

00:22:55,380 --> 00:23:00,059
to describe exactly the the semantics

00:22:57,240 --> 00:23:02,039
that you want but but that's the that's

00:23:00,059 --> 00:23:04,049
the gist but that's not the only thing

00:23:02,039 --> 00:23:08,100
we need me a little bit more to make

00:23:04,049 --> 00:23:09,330
this work so I'm not also assuming you

00:23:08,100 --> 00:23:12,780
don't care about garbage collecting

00:23:09,330 --> 00:23:14,909
failed puts s3 you can imagine some

00:23:12,780 --> 00:23:17,520
scenario in which you successfully write

00:23:14,909 --> 00:23:18,960
s3 and you're gonna go then write it to

00:23:17,520 --> 00:23:20,309
Foundation TV but Foundation TV is

00:23:18,960 --> 00:23:23,789
unavailable so you have like some

00:23:20,309 --> 00:23:26,220
garbage data in s3 now that's fixable

00:23:23,789 --> 00:23:28,590
but not that interesting so the way that

00:23:26,220 --> 00:23:31,140
you write objects now in s3 is you just

00:23:28,590 --> 00:23:35,880
pick some UID key that is you know

00:23:31,140 --> 00:23:37,169
random long unique and you wait for us

00:23:35,880 --> 00:23:39,450
three to acknowledge that requests and

00:23:37,169 --> 00:23:41,580
then you write that real key that you're

00:23:39,450 --> 00:23:45,809
trying to write your object to into FDB

00:23:41,580 --> 00:23:47,039
along with that pointer to s3 now you

00:23:45,809 --> 00:23:49,230
could do something like conditional

00:23:47,039 --> 00:23:51,960
writes like Google Cloud search can do

00:23:49,230 --> 00:23:53,490
based on the metadata and the reason

00:23:51,960 --> 00:23:54,720
Google Ad score storage can do that is

00:23:53,490 --> 00:23:58,350
because Google Cloud Storage is backed

00:23:54,720 --> 00:23:58,919
by spanner so how do you read out of

00:23:58,350 --> 00:24:01,500
this structure

00:23:58,919 --> 00:24:03,480
you just go to foundation DB first read

00:24:01,500 --> 00:24:06,000
the key and then you read the pointer

00:24:03,480 --> 00:24:08,070
out of s3 so it's a slightly slightly

00:24:06,000 --> 00:24:11,990
more latency but really not that much s3

00:24:08,070 --> 00:24:14,929
is not particularly fast to begin with

00:24:11,990 --> 00:24:18,690
so how do you delete data out of this

00:24:14,929 --> 00:24:20,250
you you add the pointer that was stored

00:24:18,690 --> 00:24:21,360
in that key and is some type of Q that

00:24:20,250 --> 00:24:22,620
will ensure that it is eventually

00:24:21,360 --> 00:24:24,860
deleted

00:24:22,620 --> 00:24:28,050
and then you delete the key from

00:24:24,860 --> 00:24:30,570
foundation v all of what I just

00:24:28,050 --> 00:24:35,400
described is basically how you can wrap

00:24:30,570 --> 00:24:37,470
some other system in a you know a shell

00:24:35,400 --> 00:24:39,660
of foundation DB that protects it from

00:24:37,470 --> 00:24:44,100
all of its bad you know bad spots and

00:24:39,660 --> 00:24:45,900
lets you get more features that make it

00:24:44,100 --> 00:24:47,280
easier to program against so if you you

00:24:45,900 --> 00:24:49,500
can imagine some type of analytics

00:24:47,280 --> 00:24:52,380
application that works against data in

00:24:49,500 --> 00:24:54,390
s3 that previously would have had to

00:24:52,380 --> 00:24:56,700
deal with these artifacts of eventual

00:24:54,390 --> 00:24:59,700
consistency by like retrying until it

00:24:56,700 --> 00:25:01,790
saw what it expected to see all kinds of

00:24:59,700 --> 00:25:09,570
other other tricks that now it could

00:25:01,790 --> 00:25:10,780
somewhat avoid so go build stuff thank

00:25:09,570 --> 00:25:17,150
you

00:25:10,780 --> 00:25:17,150

YouTube URL: https://www.youtube.com/watch?v=WK0kiJKEi60


