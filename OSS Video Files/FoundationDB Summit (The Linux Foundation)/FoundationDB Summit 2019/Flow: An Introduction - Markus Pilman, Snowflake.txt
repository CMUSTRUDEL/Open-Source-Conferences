Title: Flow: An Introduction - Markus Pilman, Snowflake
Publication date: 2019-11-25
Playlist: FoundationDB Summit 2019
Description: 
	Flow: An Introduction - Markus Pilman, Snowflake

Flow is the programming language FoundationDB is implemented in. It brings an actor-based concurrency model to C++. Flow is specifically optimized two write I/O heavy, highly concurrent software.

This talk is meant for people who either are interested in contributing code to core FoundationDB, want to be able to read FoundationDBâ€™s source code, are interested in distributed systems and want to evaluate whether Flow could be a good choice for them, or just want to learn a cool new language. You will learn how to write simple actors, how the underlying code works, and what the most common pitfalls are people encounter when writing in Flow.
Captions: 
	00:00:00,030 --> 00:00:07,710
perfect good morning everyone I'm my

00:00:05,160 --> 00:00:10,500
name is Marcus I'm a software engineer

00:00:07,710 --> 00:00:17,340
with a snowflake and I'm working on Co

00:00:10,500 --> 00:00:19,230
FDB for three and a half years now and I

00:00:17,340 --> 00:00:25,410
want to give you all an introduction

00:00:19,230 --> 00:00:27,750
into into flow so what is flow that's

00:00:25,410 --> 00:00:29,730
probably the most important thing to get

00:00:27,750 --> 00:00:32,070
like if you read the abstract you might

00:00:29,730 --> 00:00:35,610
already know so flow is a programming

00:00:32,070 --> 00:00:38,370
language that implements the actor based

00:00:35,610 --> 00:00:41,780
concurrency models so think of Erlang

00:00:38,370 --> 00:00:44,730
and you're not that far off

00:00:41,780 --> 00:00:47,420
so with flow you can write highly

00:00:44,730 --> 00:00:51,989
concurrent programs it doesn't support

00:00:47,420 --> 00:00:54,170
parallelism that's actually a feature it

00:00:51,989 --> 00:00:56,899
kind of shifts with an extensive library

00:00:54,170 --> 00:01:03,030
for platform-independent

00:00:56,899 --> 00:01:05,129
IO ships is in quotes because we don't

00:01:03,030 --> 00:01:08,840
really ship flow or you could say it

00:01:05,129 --> 00:01:12,689
also ships with a distributed database

00:01:08,840 --> 00:01:17,490
and it has exactly one implementation at

00:01:12,689 --> 00:01:19,650
least as far as I'm aware of and this

00:01:17,490 --> 00:01:21,540
inflammation implementation serves also

00:01:19,650 --> 00:01:23,970
as the specification because there's no

00:01:21,540 --> 00:01:27,869
specification and it's a c-sharp

00:01:23,970 --> 00:01:30,390
compiler that it made C++ code and it is

00:01:27,869 --> 00:01:32,759
one of the main building blocks of F DB

00:01:30,390 --> 00:01:36,780
because all of co f DB is written in

00:01:32,759 --> 00:01:39,299
float so there was a forum thread that

00:01:36,780 --> 00:01:42,840
was asking this question why was flo

00:01:39,299 --> 00:01:44,759
developed and i would encourage you to

00:01:42,840 --> 00:01:47,250
go to the forum and like check the

00:01:44,759 --> 00:01:49,829
answers this is kind of my take and I

00:01:47,250 --> 00:01:52,020
have to warn you that this might be

00:01:49,829 --> 00:01:55,619
wrong because it's just my impression

00:01:52,020 --> 00:01:58,979
and I'm not one of the original authors

00:01:55,619 --> 00:02:00,780
so they might also have had Auto strong

00:01:58,979 --> 00:02:03,329
reasons but basically the main

00:02:00,780 --> 00:02:05,969
motivation it seems was to better like

00:02:03,329 --> 00:02:08,039
to allow for this simulation type of

00:02:05,969 --> 00:02:12,480
testing that foundation DB implements

00:02:08,039 --> 00:02:13,830
which is like f DB secret sauce also

00:02:12,480 --> 00:02:16,140
resumable functions

00:02:13,830 --> 00:02:18,450
not available in C++ at the time they

00:02:16,140 --> 00:02:20,850
technically still are not but they might

00:02:18,450 --> 00:02:24,930
be in C++ 20 so we might be able to

00:02:20,850 --> 00:02:32,340
replace flow eventually and C++ was

00:02:24,930 --> 00:02:34,770
chosen si for performance reasons I like

00:02:32,340 --> 00:02:36,810
to understand stuff by looking at how it

00:02:34,770 --> 00:02:40,590
actually works so what I encourage you

00:02:36,810 --> 00:02:44,130
to do if you wanna learn flow is right a

00:02:40,590 --> 00:02:47,250
small actor of steel one from this one

00:02:44,130 --> 00:02:49,860
is stolen from the from from the library

00:02:47,250 --> 00:02:53,400
so this is like a help an actor that

00:02:49,860 --> 00:02:56,490
gets used all over the place take one of

00:02:53,400 --> 00:02:58,470
these short functions and run it through

00:02:56,490 --> 00:03:00,870
the actor compiler and look at the

00:02:58,470 --> 00:03:03,420
generated code it's very painful but

00:03:00,870 --> 00:03:06,750
it's a very helpful experience to do it

00:03:03,420 --> 00:03:10,650
at once so I won't go through all the

00:03:06,750 --> 00:03:14,220
generated code because it would fit on

00:03:10,650 --> 00:03:16,430
probably 15 slides and I don't think you

00:03:14,220 --> 00:03:18,570
would enjoy that

00:03:16,430 --> 00:03:23,700
but basically so what this thing is

00:03:18,570 --> 00:03:26,400
doing is it waits on some input and then

00:03:23,700 --> 00:03:29,250
takes the resulting value and sends it

00:03:26,400 --> 00:03:30,810
to a number of promises and so the two

00:03:29,250 --> 00:03:33,330
key words that you can see in here and

00:03:30,810 --> 00:03:36,030
these are language key words is actor

00:03:33,330 --> 00:03:38,280
and weight and they are just equivalent

00:03:36,030 --> 00:03:41,400
of a sink and the weight in like C shop

00:03:38,280 --> 00:03:46,170
or I think JavaScript has that is well

00:03:41,400 --> 00:03:48,390
and Python the order of fundamental

00:03:46,170 --> 00:03:52,080
building block is futures and promises

00:03:48,390 --> 00:03:54,270
so the future is can hold a value now or

00:03:52,080 --> 00:03:57,330
in the future and the promise can be

00:03:54,270 --> 00:04:01,320
used to sense that value to a number of

00:03:57,330 --> 00:04:04,080
futures the way this is implemented very

00:04:01,320 --> 00:04:06,180
rough so there's this SAV object which

00:04:04,080 --> 00:04:09,660
which will you will never encounter when

00:04:06,180 --> 00:04:12,510
you just use flow which is a single

00:04:09,660 --> 00:04:14,820
assignment variable I think it's means

00:04:12,510 --> 00:04:17,880
but it there's no code comment so I

00:04:14,820 --> 00:04:19,739
wouldn't know and this one stores a

00:04:17,880 --> 00:04:22,200
value and it's basically reference

00:04:19,739 --> 00:04:24,990
counted so their promises and future ref

00:04:22,200 --> 00:04:26,970
counts and the promises and futures are

00:04:24,990 --> 00:04:29,820
kind of like smart pointers

00:04:26,970 --> 00:04:32,130
to that object and it can also have it

00:04:29,820 --> 00:04:34,110
also points to a linked list of

00:04:32,130 --> 00:04:36,900
callbacks so whenever the value is set

00:04:34,110 --> 00:04:41,550
it will call into all the callbacks that

00:04:36,900 --> 00:04:45,240
have existed to a date so to generate a

00:04:41,550 --> 00:04:46,950
code very quickly like the the function

00:04:45,240 --> 00:04:48,960
itself will look like that not very

00:04:46,950 --> 00:04:52,230
interesting but basically we create a

00:04:48,960 --> 00:04:55,860
new future that gets this broadcast

00:04:52,230 --> 00:04:59,040
actor so that's how the generated class

00:04:55,860 --> 00:05:01,440
the generated actor is called as an

00:04:59,040 --> 00:05:04,260
argument and if we look at how that

00:05:01,440 --> 00:05:06,540
looks like I will like this might be a

00:05:04,260 --> 00:05:09,180
bit too much information for one slide

00:05:06,540 --> 00:05:12,900
but the basic idea here is that each

00:05:09,180 --> 00:05:14,970
actor is an SAV object in itself it has

00:05:12,900 --> 00:05:18,210
some additional states everything in

00:05:14,970 --> 00:05:20,040
blue here is part of the code and

00:05:18,210 --> 00:05:23,250
everything in red is generated by the

00:05:20,040 --> 00:05:25,800
actor compiler there's the active state

00:05:23,250 --> 00:05:27,990
so remember this is all callback paste

00:05:25,800 --> 00:05:31,080
to generate a code there's no stack for

00:05:27,990 --> 00:05:33,180
each actor and all the state that has to

00:05:31,080 --> 00:05:35,040
has to survive a weight statement is

00:05:33,180 --> 00:05:36,840
stored in that class and actually are

00:05:35,040 --> 00:05:39,180
the most of the logical almost all of

00:05:36,840 --> 00:05:41,340
the logic is in the in the state class

00:05:39,180 --> 00:05:44,100
and not in the broadcast active clause

00:05:41,340 --> 00:05:46,950
and the broadcast actor Clause is mostly

00:05:44,100 --> 00:05:49,590
there to bring everything together and

00:05:46,950 --> 00:05:51,570
so when you run a program this will just

00:05:49,590 --> 00:05:53,460
generate callbacks for you and it will

00:05:51,570 --> 00:05:55,350
take take the dirty book that you would

00:05:53,460 --> 00:05:57,419
usually do if you are familiar with like

00:05:55,350 --> 00:05:59,750
boost SEO where this can get pretty

00:05:57,419 --> 00:05:59,750
painful

00:06:00,200 --> 00:06:06,330
this is obviously not all so there are a

00:06:02,580 --> 00:06:08,400
few more language features so one

00:06:06,330 --> 00:06:13,590
problem is there's no stack and we have

00:06:08,400 --> 00:06:16,380
a compiler that is not very language

00:06:13,590 --> 00:06:18,000
well let's put it that way so if you

00:06:16,380 --> 00:06:20,160
write a function like this so this

00:06:18,000 --> 00:06:22,560
basically takes the current time and

00:06:20,160 --> 00:06:26,010
then it's just an endless loop it will

00:06:22,560 --> 00:06:27,750
sleep for one seconds and then gets

00:06:26,010 --> 00:06:31,080
woken up after that one second and it

00:06:27,750 --> 00:06:32,310
prints the time from now - the start

00:06:31,080 --> 00:06:36,309
time so it will tell you how many

00:06:32,310 --> 00:06:39,339
seconds it seconds it did run for

00:06:36,309 --> 00:06:41,169
and this loop Kiva is basically just the

00:06:39,339 --> 00:06:45,279
redefinition of right through so it's

00:06:41,169 --> 00:06:48,099
just an endless loop this will not

00:06:45,279 --> 00:06:50,589
compile and the reason for that is after

00:06:48,099 --> 00:06:53,409
like this weight keyword actually

00:06:50,589 --> 00:06:55,869
reaches as a callback and returns out of

00:06:53,409 --> 00:06:57,939
the function so you lose your stack

00:06:55,869 --> 00:07:00,189
which means that when you try to access

00:06:57,939 --> 00:07:01,809
the time in the line afterwards you will

00:07:00,189 --> 00:07:03,369
get a compilation error and the compiler

00:07:01,809 --> 00:07:08,799
will tell you that this variable doesn't

00:07:03,369 --> 00:07:13,649
exist in that context so to solve that

00:07:08,799 --> 00:07:18,369
as a state keyword which you can add to

00:07:13,649 --> 00:07:19,929
to your in front of that variable

00:07:18,369 --> 00:07:22,419
declaration and what that will do is it

00:07:19,929 --> 00:07:24,639
will tell the actor compiler hey I want

00:07:22,419 --> 00:07:25,659
to use this variable throughout the life

00:07:24,639 --> 00:07:27,819
of this actor

00:07:25,659 --> 00:07:30,969
please store it as part of the actor

00:07:27,819 --> 00:07:38,619
state and so it's a bit similar of like

00:07:30,969 --> 00:07:40,569
capturing variables in lambdas another

00:07:38,619 --> 00:07:42,939
feature is you can wait on multiple

00:07:40,569 --> 00:07:44,469
futures at once so you can I mean you

00:07:42,939 --> 00:07:46,059
can have as many callbacks as you want

00:07:44,469 --> 00:07:49,509
to write and this is basically what it

00:07:46,059 --> 00:07:51,729
does so the this is mostly presenting

00:07:49,509 --> 00:07:54,789
the same text example I chose he is not

00:07:51,729 --> 00:07:56,559
very meaningful but basically you can

00:07:54,789 --> 00:07:58,899
have this choose keyword and then a

00:07:56,559 --> 00:08:02,589
bunch of brand statements and you have

00:07:58,899 --> 00:08:07,569
to then call wait on some futures that

00:08:02,589 --> 00:08:09,819
you have there another very useful

00:08:07,569 --> 00:08:12,189
features is streams so if you're

00:08:09,819 --> 00:08:15,459
familiar with go that's used all over

00:08:12,189 --> 00:08:18,489
the place streams are unidirectional in

00:08:15,459 --> 00:08:21,129
flow and so there are future streams and

00:08:18,489 --> 00:08:23,409
promise streams and you can read from a

00:08:21,129 --> 00:08:29,079
future stream and you can write to a

00:08:23,409 --> 00:08:31,449
promise stream and you can pass these

00:08:29,079 --> 00:08:32,829
streams to other actors and therefore

00:08:31,449 --> 00:08:37,120
these two like two actors can

00:08:32,829 --> 00:08:40,800
communicate with each other so this is a

00:08:37,120 --> 00:08:44,559
very stupid example I have a small ad

00:08:40,800 --> 00:08:47,019
function here an actor that just waits

00:08:44,559 --> 00:08:48,240
on a value in a loop whenever it

00:08:47,019 --> 00:08:53,010
receives a value it

00:08:48,240 --> 00:08:55,860
we'll update its internal state by just

00:08:53,010 --> 00:08:59,580
a simple addition and then it will send

00:08:55,860 --> 00:09:03,899
it sent to complete some to to some from

00:08:59,580 --> 00:09:07,740
a stream and in order to use that in a

00:09:03,899 --> 00:09:09,660
very bad way so please don't try to make

00:09:07,740 --> 00:09:11,940
peels with code like that you probably

00:09:09,660 --> 00:09:14,399
won't get that much but basically what

00:09:11,940 --> 00:09:16,200
this is doing is does this loop that

00:09:14,399 --> 00:09:22,410
will sleep for a second then it will

00:09:16,200 --> 00:09:25,410
send one to this to this promise stream

00:09:22,410 --> 00:09:28,140
and then it will wait on a future stream

00:09:25,410 --> 00:09:30,029
to receive the result now one

00:09:28,140 --> 00:09:34,740
interesting thing here is we don't call

00:09:30,029 --> 00:09:36,480
wait we call wait next and this is sadly

00:09:34,740 --> 00:09:38,910
necessary because again the active

00:09:36,480 --> 00:09:40,920
compiler doesn't really understand C++

00:09:38,910 --> 00:09:43,110
correctly so it wouldn't know the type

00:09:40,920 --> 00:09:45,560
of whatever is in the parentheses it

00:09:43,110 --> 00:09:47,910
cannot do type deduction for us and

00:09:45,560 --> 00:09:49,920
because of that we need to tell it that

00:09:47,910 --> 00:09:52,380
this is actually a future stream and not

00:09:49,920 --> 00:09:56,760
a future because the generated code is

00:09:52,380 --> 00:09:59,610
slightly different in that case so

00:09:56,760 --> 00:10:01,860
that's basically then this is actually

00:09:59,610 --> 00:10:06,209
most of flow already there's not much

00:10:01,860 --> 00:10:08,040
more to it and there's one important

00:10:06,209 --> 00:10:10,350
library feature their remote futures

00:10:08,040 --> 00:10:12,810
these are technically probably not part

00:10:10,350 --> 00:10:15,450
of flow but of FTP RPC but this is

00:10:12,810 --> 00:10:17,250
basically how you can do remote

00:10:15,450 --> 00:10:20,640
procedure calls or basically you can

00:10:17,250 --> 00:10:22,170
have futures promises and future stream

00:10:20,640 --> 00:10:24,779
and promise streams having on two

00:10:22,170 --> 00:10:28,560
different machines are two different

00:10:24,779 --> 00:10:30,480
processes and the functions that

00:10:28,560 --> 00:10:34,579
implement edit the classes that

00:10:30,480 --> 00:10:36,870
implement that request streams which are

00:10:34,579 --> 00:10:39,240
the equivalent of a future stream

00:10:36,870 --> 00:10:40,829
there's a reply promise which is the

00:10:39,240 --> 00:10:42,690
equivalent of a promise which you can

00:10:40,829 --> 00:10:44,550
send to another machine and then that

00:10:42,690 --> 00:10:47,520
machine can set the promise and you will

00:10:44,550 --> 00:10:49,920
get the result and both of them have a

00:10:47,520 --> 00:10:52,709
get future method that you can call to

00:10:49,920 --> 00:10:55,589
to get the order reading object side of

00:10:52,709 --> 00:10:58,420
that a good example to look at in my

00:10:55,589 --> 00:11:01,139
opinion is the in the FDB code

00:10:58,420 --> 00:11:04,420
this storage server interface dot H

00:11:01,139 --> 00:11:06,940
which implements all the RPC calls that

00:11:04,420 --> 00:11:10,660
we use to communicate with storage nodes

00:11:06,940 --> 00:11:12,310
and it's pretty readable like it's one

00:11:10,660 --> 00:11:19,060
of the places that is actually pretty

00:11:12,310 --> 00:11:21,730
readable so I'm still doing ok with time

00:11:19,060 --> 00:11:23,410
so I want to go into a few of the common

00:11:21,730 --> 00:11:27,250
pitfalls so when you start programming

00:11:23,410 --> 00:11:29,860
inflow most people will have some of

00:11:27,250 --> 00:11:32,079
will may do some of the similar mistakes

00:11:29,860 --> 00:11:34,959
that we do just because sometimes flow

00:11:32,079 --> 00:11:41,980
doesn't quite work in the way we expect

00:11:34,959 --> 00:11:44,139
it to and most of these common problems

00:11:41,980 --> 00:11:46,510
we solved from the fact that the active

00:11:44,139 --> 00:11:48,519
compiler doesn't really understand C++ I

00:11:46,510 --> 00:11:50,800
mentioned this a bunch of times like for

00:11:48,519 --> 00:11:52,959
example one really annoying example is

00:11:50,800 --> 00:11:55,120
if you write lambdas and I love lambdas

00:11:52,959 --> 00:11:57,550
I write I tended to write them all the

00:11:55,120 --> 00:12:00,579
time and now in flow I use them less

00:11:57,550 --> 00:12:03,220
because of that you can't really capture

00:12:00,579 --> 00:12:05,470
state variables because in the generator

00:12:03,220 --> 00:12:11,110
code the state variable is actually a

00:12:05,470 --> 00:12:14,800
member of a class and so it gets a bit

00:12:11,110 --> 00:12:16,449
weird and then as I said before type

00:12:14,800 --> 00:12:18,070
deduction doesn't work so if you write

00:12:16,449 --> 00:12:20,620
the wait statement you always have to

00:12:18,070 --> 00:12:23,290
explicitly declare what type you are

00:12:20,620 --> 00:12:28,120
waiting on by I'm actually reading the

00:12:23,290 --> 00:12:30,220
result into a variable and unless it's

00:12:28,120 --> 00:12:33,610
it's a future voyage then you can omit

00:12:30,220 --> 00:12:37,720
that or actually you have to and then

00:12:33,610 --> 00:12:39,610
there's the memory management rules like

00:12:37,720 --> 00:12:41,230
the best practices how to do memory

00:12:39,610 --> 00:12:42,940
management or a bit different and I

00:12:41,230 --> 00:12:45,519
won't really go into that here because

00:12:42,940 --> 00:12:51,130
that's like its whole topic for itself

00:12:45,519 --> 00:12:53,769
so one common thing that people for trip

00:12:51,130 --> 00:12:55,889
over initially is that arguments to

00:12:53,769 --> 00:13:01,089
actors are getting copied into a state

00:12:55,889 --> 00:13:03,370
and so if you try to write code as the

00:13:01,089 --> 00:13:05,889
first line here right you try to pass a

00:13:03,370 --> 00:13:09,040
string as a constant reference then the

00:13:05,889 --> 00:13:11,680
actor compile because it is limited in

00:13:09,040 --> 00:13:12,110
its C++ knowledge will try to rewrite it

00:13:11,680 --> 00:13:13,640
as

00:13:12,110 --> 00:13:15,230
thing like that I didn't try whether

00:13:13,640 --> 00:13:17,690
that's the actual quote but it will

00:13:15,230 --> 00:13:21,290
probably look a bit like that because it

00:13:17,690 --> 00:13:23,990
will try to copy the reference and not

00:13:21,290 --> 00:13:26,510
the string which is not what you want to

00:13:23,990 --> 00:13:28,880
do in that case or you can't so this

00:13:26,510 --> 00:13:30,649
won't compile so if you want to pass

00:13:28,880 --> 00:13:32,420
something by reference what you have to

00:13:30,649 --> 00:13:34,880
do is you have to pass a pointer because

00:13:32,420 --> 00:13:39,829
you can copy pointers and then this will

00:13:34,880 --> 00:13:42,500
work another thing is that actors

00:13:39,829 --> 00:13:45,200
whenever they if the future count of an

00:13:42,500 --> 00:13:48,529
actor goes to zero it will get cancelled

00:13:45,200 --> 00:13:50,920
and it will stop working so this is the

00:13:48,529 --> 00:13:55,160
same stupid counter that I had before

00:13:50,920 --> 00:13:57,019
with one Bach that I introduced so those

00:13:55,160 --> 00:13:58,730
who like a che so that should probably

00:13:57,019 --> 00:14:01,930
see that pretty quickly what's wrong

00:13:58,730 --> 00:14:05,120
here but basically we create this add a

00:14:01,930 --> 00:14:09,350
actor in like the I don't know sixth

00:14:05,120 --> 00:14:11,589
line or something and it will run out of

00:14:09,350 --> 00:14:13,730
scope as soon as we call in to wait and

00:14:11,589 --> 00:14:16,430
therefore it will get cancelled because

00:14:13,730 --> 00:14:22,730
we didn't pass this future to any other

00:14:16,430 --> 00:14:24,290
location so this thing actually has to

00:14:22,730 --> 00:14:29,660
be a state variable so that it can

00:14:24,290 --> 00:14:33,050
survive this wait call there are also

00:14:29,660 --> 00:14:38,300
some weird scoping rules so this one

00:14:33,050 --> 00:14:43,010
here will actually compile this actor it

00:14:38,300 --> 00:14:46,130
shouldn't write but it does so what's

00:14:43,010 --> 00:14:48,170
the result of this actor it is it's not

00:14:46,130 --> 00:14:50,060
clear what it should do it should it be

00:14:48,170 --> 00:14:51,949
five tries should it be something else

00:14:50,060 --> 00:14:54,170
and actually if you run that what

00:14:51,949 --> 00:14:56,449
happens is that the first line is

00:14:54,170 --> 00:15:01,970
undefined behavior so that might give

00:14:56,449 --> 00:15:05,180
you whatever and then the second print

00:15:01,970 --> 00:15:07,040
will give you five and the reason if you

00:15:05,180 --> 00:15:09,260
understand how state variables work is

00:15:07,040 --> 00:15:11,660
pretty simple right the state variable

00:15:09,260 --> 00:15:13,930
is just part of the active State this

00:15:11,660 --> 00:15:16,399
one is available throughout the whole

00:15:13,930 --> 00:15:18,470
while the whole actor is running and

00:15:16,399 --> 00:15:20,270
there's no come like the compiler

00:15:18,470 --> 00:15:22,880
doesn't actually prevent you from

00:15:20,270 --> 00:15:26,020
writing code like that so this is

00:15:22,880 --> 00:15:26,020
something to be a bit careful

00:15:28,040 --> 00:15:33,899
another one is error handling is a bit

00:15:30,779 --> 00:15:36,990
weird so if you write a code like that

00:15:33,899 --> 00:15:39,389
and let's say s is like a future to an

00:15:36,990 --> 00:15:42,029
actor that throws some exception of the

00:15:39,389 --> 00:15:43,410
while you will not see that exception if

00:15:42,029 --> 00:15:45,420
you write the code like this

00:15:43,410 --> 00:15:49,470
the reason is exceptions are only

00:15:45,420 --> 00:15:51,240
propagated if you wait on them or if you

00:15:49,470 --> 00:15:56,279
explicitly check whether they are

00:15:51,240 --> 00:15:58,860
starring an error currently so yeah

00:15:56,279 --> 00:16:03,209
that's basically it won't be thrown up

00:15:58,860 --> 00:16:04,949
and so there multiple ways of how you

00:16:03,209 --> 00:16:07,139
can fix that you can additionally wait

00:16:04,949 --> 00:16:10,769
on that thing and just assert that it

00:16:07,139 --> 00:16:12,389
never actually returns anything if it's

00:16:10,769 --> 00:16:14,970
supposed to be an actor that should run

00:16:12,389 --> 00:16:17,430
forever and then you can also catch the

00:16:14,970 --> 00:16:21,389
exception by just putting everything

00:16:17,430 --> 00:16:23,010
into a try-catch block like as you can

00:16:21,389 --> 00:16:25,860
see here this can get awkward if you

00:16:23,010 --> 00:16:28,889
have many many actors so there's this

00:16:25,860 --> 00:16:31,920
library class called actor collection

00:16:28,889 --> 00:16:37,019
and you can just like pass all your

00:16:31,920 --> 00:16:39,750
futures into that and wait on that actor

00:16:37,019 --> 00:16:48,180
collection and this will we throw the

00:16:39,750 --> 00:16:51,680
error for you so this is it mostly from

00:16:48,180 --> 00:16:54,870
my site but I wanted to point out a few

00:16:51,680 --> 00:16:56,579
very useful resources or I believe

00:16:54,870 --> 00:16:58,470
useful resources the first one is

00:16:56,579 --> 00:17:03,240
there's a very short documentation on

00:16:58,470 --> 00:17:07,049
flow that you should look at if you're

00:17:03,240 --> 00:17:09,720
interested in that in in the codes

00:17:07,049 --> 00:17:12,000
there's this tutorial dot actor dot cpp

00:17:09,720 --> 00:17:13,890
and please like there should be a forum

00:17:12,000 --> 00:17:15,600
thread or whatever look at that if you

00:17:13,890 --> 00:17:17,549
see anything missing I'll see anything

00:17:15,600 --> 00:17:18,959
unclear like mention it and I will try

00:17:17,549 --> 00:17:21,329
to update it it should have code

00:17:18,959 --> 00:17:24,079
comments on like how stuff works it

00:17:21,329 --> 00:17:29,340
implements like a small key value store

00:17:24,079 --> 00:17:31,020
like not a good one and another thing

00:17:29,340 --> 00:17:33,480
that is pretty good to look at there's

00:17:31,020 --> 00:17:37,350
two versions of generic actors dot X 2

00:17:33,480 --> 00:17:39,630
dot H which files with like help

00:17:37,350 --> 00:17:41,340
the functions and it's good to have kind

00:17:39,630 --> 00:17:44,279
of a mental model what's in there it's

00:17:41,340 --> 00:17:45,480
basically like algorithm in C++ right do

00:17:44,279 --> 00:17:47,039
you want to know what's in there because

00:17:45,480 --> 00:17:49,169
otherwise you'll be implemented several

00:17:47,039 --> 00:17:51,090
times and you can find stuff like this

00:17:49,169 --> 00:17:53,460
broadcast function you can find a map

00:17:51,090 --> 00:17:57,090
function you can find operators for end

00:17:53,460 --> 00:17:58,980
and or you can do weight or error which

00:17:57,090 --> 00:18:00,870
is sometimes useful there's the flow log

00:17:58,980 --> 00:18:04,049
thingy so if you don't want to have two

00:18:00,870 --> 00:18:06,240
actors concurrently accessing some some

00:18:04,049 --> 00:18:08,970
data you can use that and there's many

00:18:06,240 --> 00:18:12,240
many other useful stuff and it also

00:18:08,970 --> 00:18:13,950
helps to understand the code style that

00:18:12,240 --> 00:18:15,690
you're supposed to use and how you can

00:18:13,950 --> 00:18:17,460
implement certain things that might not

00:18:15,690 --> 00:18:19,169
be completely obvious how it should be

00:18:17,460 --> 00:18:21,360
implemented like a lot of stuff is in

00:18:19,169 --> 00:18:23,700
there so to me this was actually one of

00:18:21,360 --> 00:18:27,840
the best learning resources to just look

00:18:23,700 --> 00:18:29,820
at that header file so please go to the

00:18:27,840 --> 00:18:32,940
forum if you have questions and I will

00:18:29,820 --> 00:18:35,549
try to answer as many of them as I can

00:18:32,940 --> 00:18:37,139
and all the people like AJ and Alex and

00:18:35,549 --> 00:18:39,840
whatever will also be there and we'll

00:18:37,139 --> 00:18:46,790
help thanks a lot

00:18:39,840 --> 00:18:46,790

YouTube URL: https://www.youtube.com/watch?v=8lgLNt0JA_w


