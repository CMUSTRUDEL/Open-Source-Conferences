Title: FoundationDB and Node.js: Year in Production - Steve Korshakov, Openland
Publication date: 2019-11-25
Playlist: FoundationDB Summit 2019
Description: 
	FoundationDB and Node.js: Year in Production - Steve Korshakov, OpenlandÂ 

About a year ago we moved all our stack to FoundationDB, in the last year we have built a multi-functional library (http://fdb.openland.com) to work with FDB in NodeJS that can: Distributed Locks, Work Queue, Entity Layer (very similar to Record Layer), Distributed Random ID generator, Singleton Workers and so on. I want to share my experience using FDB in production for building a messaging app and sharing this library to the community.
Captions: 
	00:00:00,030 --> 00:00:08,030
okay hello I'm Steve from open land I'm

00:00:04,290 --> 00:00:11,099
founder and CTO on we are doing a

00:00:08,030 --> 00:00:13,380
messenger for startups and for

00:00:11,099 --> 00:00:15,660
professional communities and we about a

00:00:13,380 --> 00:00:20,070
year ago started to use full HD beer as

00:00:15,660 --> 00:00:22,410
as the our only database for like

00:00:20,070 --> 00:00:28,170
everything and I here want to share our

00:00:22,410 --> 00:00:30,480
experience so in this year we heard a

00:00:28,170 --> 00:00:37,469
lot about like thirty percent or thirty

00:00:30,480 --> 00:00:39,930
seconds of downtime not that big cluster

00:00:37,469 --> 00:00:44,850
itself but it's not that small is about

00:00:39,930 --> 00:00:47,219
to 200 gigabytes about 30 processes that

00:00:44,850 --> 00:00:49,140
connected to the foundation GB and we

00:00:47,219 --> 00:00:50,940
don't have any kind of maintenance we

00:00:49,140 --> 00:00:53,940
don't have the develop team we don't

00:00:50,940 --> 00:00:57,690
have like anyone looking at our consoles

00:00:53,940 --> 00:01:02,579
it just works for like foot here we

00:00:57,690 --> 00:01:07,380
didn't touch it so what's our deployment

00:01:02,579 --> 00:01:09,630
is we we started from the very small

00:01:07,380 --> 00:01:13,850
deployment with five machines that

00:01:09,630 --> 00:01:16,320
basically was used for coordination for

00:01:13,850 --> 00:01:18,630
for the some issues with founder gdb we

00:01:16,320 --> 00:01:21,390
keep them as curve the nation's because

00:01:18,630 --> 00:01:25,920
it's too hard to configure for us if it

00:01:21,390 --> 00:01:28,710
just didn't have time so then we

00:01:25,920 --> 00:01:33,000
deployed about five machines for the

00:01:28,710 --> 00:01:35,700
storage unfortunately we were forced to

00:01:33,000 --> 00:01:38,280
deploy at a separate machine for backup

00:01:35,700 --> 00:01:42,119
system because phone HTTP doesn't

00:01:38,280 --> 00:01:45,840
support Google storage natively so we

00:01:42,119 --> 00:01:52,259
have to some kind of racket and in the

00:01:45,840 --> 00:01:56,070
end we just added locks locks machines

00:01:52,259 --> 00:02:02,549
every machine have about four processors

00:01:56,070 --> 00:02:04,680
so it's quite a big cluster yeah why not

00:02:02,549 --> 00:02:06,630
just because javascript is basically

00:02:04,680 --> 00:02:08,569
just like a toy language is not like

00:02:06,630 --> 00:02:14,129
suitable for production for most of us

00:02:08,569 --> 00:02:16,049
but but it have a lot of very nice

00:02:14,129 --> 00:02:18,959
properties the first one is it's very

00:02:16,049 --> 00:02:20,849
easy to use it have very high

00:02:18,959 --> 00:02:24,420
performance is like almost there like a

00:02:20,849 --> 00:02:26,430
goal line and the C++ performance but

00:02:24,420 --> 00:02:29,329
you just have to write it in correct way

00:02:26,430 --> 00:02:32,909
it's just not everything works fast and

00:02:29,329 --> 00:02:35,129
well it have very nice graph QL library

00:02:32,909 --> 00:02:39,780
that actually integrates very very

00:02:35,129 --> 00:02:42,810
easily - with Foundation GBM well it

00:02:39,780 --> 00:02:44,730
have now it have a decent language that

00:02:42,810 --> 00:02:48,359
type script that it actually can be

00:02:44,730 --> 00:02:52,199
considered like more production rated

00:02:48,359 --> 00:02:57,449
language I developer experience is

00:02:52,199 --> 00:03:01,469
insanely good so and now there are huge

00:02:57,449 --> 00:03:03,180
issues with no Jessica system it's not

00:03:01,469 --> 00:03:06,449
just just doesn't have any kind of

00:03:03,180 --> 00:03:09,000
decent distributed frameworks to build

00:03:06,449 --> 00:03:12,900
your apps it can it allows you to build

00:03:09,000 --> 00:03:16,469
like very simple apps so it's not you

00:03:12,900 --> 00:03:21,449
actually can build they know something

00:03:16,469 --> 00:03:25,019
like akka and whatever so all libraries

00:03:21,449 --> 00:03:28,379
that works with sequel is insanely slow

00:03:25,019 --> 00:03:31,319
is they are barely you can you can

00:03:28,379 --> 00:03:36,930
actually use them at any decent sized

00:03:31,319 --> 00:03:38,609
application so here and we decided to go

00:03:36,930 --> 00:03:42,269
into a foundation DB instead of

00:03:38,609 --> 00:03:45,269
rewriting our app to a new language well

00:03:42,269 --> 00:03:49,560
I already built three different backends

00:03:45,269 --> 00:03:51,569
from my streams and my two previous

00:03:49,560 --> 00:03:54,120
attempts was built on top of akka and

00:03:51,569 --> 00:03:59,150
Java Scala and all the stuff but it

00:03:54,120 --> 00:04:01,650
turns out that you you you wait too much

00:03:59,150 --> 00:04:04,169
weight you put too much weight on

00:04:01,650 --> 00:04:06,870
developers because they all of them have

00:04:04,169 --> 00:04:09,419
to know what is distributed computing

00:04:06,870 --> 00:04:11,370
how to implement this is it became

00:04:09,419 --> 00:04:14,639
almost impossible to implement Evan I

00:04:11,370 --> 00:04:19,400
don't have him like team of ten very

00:04:14,639 --> 00:04:23,940
smart people they still can handle it so

00:04:19,400 --> 00:04:28,230
and so with foundation DB we actually

00:04:23,940 --> 00:04:30,270
made a step back and now I have

00:04:28,230 --> 00:04:33,419
application server is basically just

00:04:30,270 --> 00:04:36,720
stateless that source request in the

00:04:33,419 --> 00:04:39,449
request response style and all this

00:04:36,720 --> 00:04:44,460
complexity is afforded to foundation DB

00:04:39,449 --> 00:04:46,800
and we use radius for just for message

00:04:44,460 --> 00:04:50,790
bus that's the solvent we are not using

00:04:46,800 --> 00:04:53,460
anything for caching so unfortunately

00:04:50,790 --> 00:04:56,870
there are no there were no any kind of

00:04:53,460 --> 00:04:59,699
libraries for foundation GB if not just

00:04:56,870 --> 00:05:03,000
heaven bindings are unofficial so we

00:04:59,699 --> 00:05:05,070
decided to roll our own it's support

00:05:03,000 --> 00:05:08,220
it's basically the same records layer

00:05:05,070 --> 00:05:12,810
that you probably hear today it's called

00:05:08,220 --> 00:05:17,040
get a keynote so we support like indexes

00:05:12,810 --> 00:05:22,139
streaming event sourcing we have some

00:05:17,040 --> 00:05:25,800
kind of sub layers inside of it it and

00:05:22,139 --> 00:05:28,979
we implement this like in a month I

00:05:25,800 --> 00:05:31,289
think maybe I'm into it was in

00:05:28,979 --> 00:05:39,750
production for more than one year it

00:05:31,289 --> 00:05:42,300
didn't failed failed us so yeah so this

00:05:39,750 --> 00:05:44,970
is how improvement over the sequel

00:05:42,300 --> 00:05:46,849
libraries and no dress looks like when

00:05:44,970 --> 00:05:50,280
we just replaced everything with

00:05:46,849 --> 00:05:53,430
foundation t-beam so we when you

00:05:50,280 --> 00:05:57,150
download like a big chunk of data yeah

00:05:53,430 --> 00:06:03,060
from sequel in not jazz it will spend

00:05:57,150 --> 00:06:06,419
about 800 milliseconds just to convert

00:06:03,060 --> 00:06:09,510
this data to an object it's not because

00:06:06,419 --> 00:06:12,090
of not just slow it's just a kind of a

00:06:09,510 --> 00:06:14,160
very old legacy from different libraries

00:06:12,090 --> 00:06:16,380
and all this libraries our benchmark

00:06:14,160 --> 00:06:19,460
against each other so they don't under

00:06:16,380 --> 00:06:23,280
see how fast they actually can be and

00:06:19,460 --> 00:06:25,560
this green star green bar it's not a

00:06:23,280 --> 00:06:27,930
parallel it's completely blocked backend

00:06:25,560 --> 00:06:31,500
so we basically got about ten requests

00:06:27,930 --> 00:06:33,930
per second per process so that's you

00:06:31,500 --> 00:06:36,300
know it's you can do like anything with

00:06:33,930 --> 00:06:38,520
this then we just return everything with

00:06:36,300 --> 00:06:41,210
foundation DB and you can see how small

00:06:38,520 --> 00:06:41,210
is this and

00:06:41,300 --> 00:06:47,910
like the small blue part actually can be

00:06:45,240 --> 00:06:51,180
parallel can be performed in parallel

00:06:47,910 --> 00:06:54,990
it's like you can do about like 40 K

00:06:51,180 --> 00:06:57,240
operations per second and our own

00:06:54,990 --> 00:07:03,030
address will so handle it without an

00:06:57,240 --> 00:07:05,370
issue yeah so and one of the nice

00:07:03,030 --> 00:07:09,360
features that we got with foundation DB

00:07:05,370 --> 00:07:12,630
is that basically we can allow our

00:07:09,360 --> 00:07:17,160
developers to make much more mistakes so

00:07:12,630 --> 00:07:20,480
basically we have a very small team so

00:07:17,160 --> 00:07:23,850
one of them is basically kind of in turn

00:07:20,480 --> 00:07:27,270
the second developer is mostly middle

00:07:23,850 --> 00:07:29,160
engineer and that's all I'm not involved

00:07:27,270 --> 00:07:33,510
in the back-end development anymore and

00:07:29,160 --> 00:07:37,490
we are still going strong and how

00:07:33,510 --> 00:07:42,450
foundation DB helps us because it's so

00:07:37,490 --> 00:07:49,680
you have so great performance it allows

00:07:42,450 --> 00:07:55,430
us to to deploy bugs safely they didn't

00:07:49,680 --> 00:07:55,430
affect our from like our front end

00:07:55,490 --> 00:08:00,930
without any impact on users actually we

00:07:58,440 --> 00:08:03,810
rarely loop take a look at the graphs

00:08:00,930 --> 00:08:06,630
graphs and on stats if you usually find

00:08:03,810 --> 00:08:09,150
this back slack after a month without

00:08:06,630 --> 00:08:12,240
like ever noticing anything you can see

00:08:09,150 --> 00:08:14,340
is like was I don't know like 10k per

00:08:12,240 --> 00:08:16,800
second right it's skyrocketing like

00:08:14,340 --> 00:08:18,270
through over the hundred just probably

00:08:16,800 --> 00:08:21,930
just sound

00:08:18,270 --> 00:08:24,630
misoo delay or whatever so it's like so

00:08:21,930 --> 00:08:28,530
we didn't feel anything big just this is

00:08:24,630 --> 00:08:31,410
a no because for the shin surface fast

00:08:28,530 --> 00:08:34,380
but the client design foundation to be

00:08:31,410 --> 00:08:37,200
client it can be it throttle very

00:08:34,380 --> 00:08:41,550
carefully and can schedule the work

00:08:37,200 --> 00:08:45,120
evenly across their clients so it won't

00:08:41,550 --> 00:08:49,290
interfere with between different workers

00:08:45,120 --> 00:08:51,870
let's say it was a huge issue on a

00:08:49,290 --> 00:08:54,749
sequel because sequel doesn't have any

00:08:51,870 --> 00:08:57,720
kind of such scheduling

00:08:54,749 --> 00:09:06,839
so them like little examples how it

00:08:57,720 --> 00:09:09,600
looks like so our our our stack our

00:09:06,839 --> 00:09:13,920
implementation is very very easy is to

00:09:09,600 --> 00:09:17,429
use and nothing nothing like no rocket

00:09:13,920 --> 00:09:18,990
science here so actually any junior

00:09:17,429 --> 00:09:25,079
developer can actually understand how to

00:09:18,990 --> 00:09:28,999
create object how to how to store how to

00:09:25,079 --> 00:09:32,579
find how to search and we opted not to

00:09:28,999 --> 00:09:36,389
do some kind of shady optimizations and

00:09:32,579 --> 00:09:38,999
not a lot like like sequel usually do

00:09:36,389 --> 00:09:41,279
like the query plane and all the stuff

00:09:38,999 --> 00:09:45,360
is easily can became unpredictable

00:09:41,279 --> 00:09:49,319
especially for newcomers so we opted not

00:09:45,360 --> 00:09:52,019
to use auto incrementing features or all

00:09:49,319 --> 00:09:54,179
other features that are can be slow to

00:09:52,019 --> 00:09:57,449
implement so you just have to implement

00:09:54,179 --> 00:09:59,730
them manually this saves us from a lot

00:09:57,449 --> 00:10:02,249
of issues when like engineers just put

00:09:59,730 --> 00:10:07,920
out to increment fields everywhere and

00:10:02,249 --> 00:10:12,209
everything became so slow so Aquarion

00:10:07,920 --> 00:10:15,749
like finding all the funding from the

00:10:12,209 --> 00:10:19,769
user collection is also basically very

00:10:15,749 --> 00:10:25,339
naive so you have two options so used

00:10:19,769 --> 00:10:25,339
like like if like a full search and not

00:10:25,850 --> 00:10:33,179
say you know its name its simplest you

00:10:30,319 --> 00:10:35,069
simplest way you can write to finds

00:10:33,179 --> 00:10:37,199
anything in your database but you

00:10:35,069 --> 00:10:39,059
everyone understands that find all is

00:10:37,199 --> 00:10:41,910
probably not a good solution for

00:10:39,059 --> 00:10:44,220
everything and like you can easily

00:10:41,910 --> 00:10:47,339
understand if this but a good decision

00:10:44,220 --> 00:10:50,639
in specific case it wasn't the true for

00:10:47,339 --> 00:10:52,949
sequel because when you try to convert

00:10:50,639 --> 00:10:56,299
this to sequel query you probably will

00:10:52,949 --> 00:11:00,029
he you will you will need to guess if

00:10:56,299 --> 00:11:02,519
there like an index right index or wrong

00:11:00,029 --> 00:11:04,529
hindrance so it's is it like is it a big

00:11:02,519 --> 00:11:08,030
table or small table it became very in

00:11:04,529 --> 00:11:11,090
predictable and I explained this through

00:11:08,030 --> 00:11:12,920
every engineer is little bit card we

00:11:11,090 --> 00:11:17,390
just I just don't want to manage

00:11:12,920 --> 00:11:20,000
development it's um it just it's my

00:11:17,390 --> 00:11:21,950
startups we found this usually doesn't

00:11:20,000 --> 00:11:24,860
have focus on everything we just doesn't

00:11:21,950 --> 00:11:31,690
have enough time so this system and team

00:11:24,860 --> 00:11:36,430
have to work by themselves so and what

00:11:31,690 --> 00:11:42,650
what this it we will need something more

00:11:36,430 --> 00:11:46,030
performant we can see that we we have

00:11:42,650 --> 00:11:49,280
support for indexes and like have much

00:11:46,030 --> 00:11:55,760
high performance and a version of search

00:11:49,280 --> 00:11:58,330
so yeah one of the biggest issues and

00:11:55,760 --> 00:12:00,890
for everyone it's probably the last one

00:11:58,330 --> 00:12:03,050
that the only one for work with

00:12:00,890 --> 00:12:05,870
foundation DB is the latency because

00:12:03,050 --> 00:12:08,300
like if you were working for simple apps

00:12:05,870 --> 00:12:11,720
you probably didn't think about this and

00:12:08,300 --> 00:12:15,710
working on a sequel you never actually

00:12:11,720 --> 00:12:19,040
hit the network latencies like never and

00:12:15,710 --> 00:12:24,470
the we for foundation GB is kind of an

00:12:19,040 --> 00:12:27,020
issue so for graph QL we have like for

00:12:24,470 --> 00:12:30,110
example this small query to fetch the

00:12:27,020 --> 00:12:32,570
user my current user and it's best it's

00:12:30,110 --> 00:12:35,600
like write write something next to his

00:12:32,570 --> 00:12:38,210
name so we basically have to do several

00:12:35,600 --> 00:12:42,800
queries the first one will read the

00:12:38,210 --> 00:12:48,440
version read version it will take maybe

00:12:42,800 --> 00:12:52,310
up to 10 milliseconds then we will query

00:12:48,440 --> 00:12:55,370
the the profile itself then we will read

00:12:52,310 --> 00:12:58,250
batch info and we will it this will all

00:12:55,370 --> 00:13:01,940
take about 16 milliseconds it sounds not

00:12:58,250 --> 00:13:05,600
very big but actually if we will try to

00:13:01,940 --> 00:13:07,580
read this for 20 users it became one

00:13:05,600 --> 00:13:13,880
third of the second and this became very

00:13:07,580 --> 00:13:14,810
slow so in sound but but thankfully for

00:13:13,880 --> 00:13:18,260
the graph QL

00:13:14,810 --> 00:13:21,140
is so it's also for us for free so it's

00:13:18,260 --> 00:13:21,690
actually can do parallel stuff but in

00:13:21,140 --> 00:13:24,630
some

00:13:21,690 --> 00:13:26,430
kind of mission critical parts you will

00:13:24,630 --> 00:13:28,410
just have to rewrite all the code and

00:13:26,430 --> 00:13:31,440
this is the only way where you can't use

00:13:28,410 --> 00:13:33,930
very naively primitive approach to build

00:13:31,440 --> 00:13:36,660
your app so you can just write and it

00:13:33,930 --> 00:13:40,260
will just work without learning sequel

00:13:36,660 --> 00:13:46,710
probably without indexes and all that

00:13:40,260 --> 00:13:50,730
stuff so yeah that that's about at all

00:13:46,710 --> 00:13:55,460
so in the end I can say that founders DB

00:13:50,730 --> 00:13:55,460
it turns out super fast very reliable

00:13:56,150 --> 00:14:01,860
founded and our platform it allows our

00:13:59,820 --> 00:14:04,020
developer Evan front-end developers to

00:14:01,860 --> 00:14:06,300
write features for our back-end without

00:14:04,020 --> 00:14:09,990
breaking anything and we don't have much

00:14:06,300 --> 00:14:12,930
test I can confess so it's it's miracle

00:14:09,990 --> 00:14:15,990
that we'd be work like I don't know we

00:14:12,930 --> 00:14:19,440
we have like 100 percent uptime and last

00:14:15,990 --> 00:14:22,130
half-year I think so it's like how

00:14:19,440 --> 00:14:22,130
impossible

00:14:22,280 --> 00:14:32,940
yeah and it's I don't know it's very

00:14:28,400 --> 00:14:37,020
it's really hard to shooting you in your

00:14:32,940 --> 00:14:39,720
food because you can see all the

00:14:37,020 --> 00:14:42,330
complexity of all operations and you

00:14:39,720 --> 00:14:44,640
basically use the same language for

00:14:42,330 --> 00:14:49,530
everything and it works just fast

00:14:44,640 --> 00:14:53,160
because we basically because how light

00:14:49,530 --> 00:14:56,040
of our libraries are we have a lot of

00:14:53,160 --> 00:14:59,310
room for draw all the shitty stuff that

00:14:56,040 --> 00:15:00,720
you can do on JavaScript so and we in

00:14:59,310 --> 00:15:03,120
the end we have basically zero

00:15:00,720 --> 00:15:05,310
maintenance it's mostly just experiments

00:15:03,120 --> 00:15:10,170
I do all my experiments on production

00:15:05,310 --> 00:15:12,360
system so yeah it actually worked so

00:15:10,170 --> 00:15:15,990
because of this we had like 30 seconds

00:15:12,360 --> 00:15:20,250
of downtime well it was just do during

00:15:15,990 --> 00:15:23,010
upgrade for a new version it's just the

00:15:20,250 --> 00:15:29,140
issue with unofficial and not just

00:15:23,010 --> 00:15:33,779
bindings yeah that's all thank you

00:15:29,140 --> 00:15:33,779

YouTube URL: https://www.youtube.com/watch?v=Tp-xeGR_fZ0


