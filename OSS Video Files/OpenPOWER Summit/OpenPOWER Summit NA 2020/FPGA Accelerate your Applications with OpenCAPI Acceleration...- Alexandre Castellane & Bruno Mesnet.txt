Title: FPGA Accelerate your Applications with OpenCAPI Acceleration...- Alexandre Castellane & Bruno Mesnet
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	FPGA Accelerate your Applications with OpenCAPI Acceleration Framework (OC-ACCEL) - Alexandre Castellane & Bruno Mesnet, IBM France

Speakers: Bruno Mesnet, Alexandre Castellane

OpenCAPI Acceleration Framework, abbreviated as OC-Accel, is a platform allowing programmers and computer engineers to quickly create FPGA-based acceleration solutions. Both acceleration action's software and hardware parts coherently share the server host memory data through OpenCAPI interface. Designers can thus quickly design an accelerator and benefit from the bandwidth, latency, coherency and programability advantages of OpenCAPI. Applications can be written in Python facilitating technology discovery.
Captions: 
	00:00:00,719 --> 00:00:06,560
i see people coming everybody

00:00:03,919 --> 00:00:06,560
hi everybody

00:00:08,480 --> 00:00:12,400
i guess we can start bruno where are we

00:00:13,040 --> 00:00:18,000
let's wait a minute maybe but yes you

00:00:15,200 --> 00:00:18,000
should be able to start

00:00:18,400 --> 00:00:23,119
okay welcome everybody

00:00:23,760 --> 00:00:27,760
my name is alexander castellan i am with

00:00:26,320 --> 00:00:31,039
bueno mesnay

00:00:27,760 --> 00:00:36,000
we both work for ibm

00:00:31,039 --> 00:00:39,440
and we are dedicated to capi opencapi

00:00:36,000 --> 00:00:41,520
team so we are based in nice while our

00:00:39,440 --> 00:00:43,200
team is based in montpellier south part

00:00:41,520 --> 00:00:46,239
of france

00:00:43,200 --> 00:00:48,800
i'm very glad today to uh speak

00:00:46,239 --> 00:00:49,600
in the name of our team to present you

00:00:48,800 --> 00:00:52,320
um

00:00:49,600 --> 00:00:55,120
opencapi ocxl which is a framework as

00:00:52,320 --> 00:00:55,120
we'll see in a minute

00:00:55,920 --> 00:01:00,079
so the first question we might raise is

00:00:59,120 --> 00:01:02,719
um

00:01:00,079 --> 00:01:03,840
why do we need the framework what it is

00:01:02,719 --> 00:01:06,960
where can we find it

00:01:03,840 --> 00:01:09,760
how can we use it so we'll try to um

00:01:06,960 --> 00:01:11,200
answer this question very briefly um we

00:01:09,760 --> 00:01:14,400
see actually the is a

00:01:11,200 --> 00:01:16,560
framework that eases acceleration on

00:01:14,400 --> 00:01:19,200
based on hardware acceleration using

00:01:16,560 --> 00:01:20,240
fpga we've seen immediate what an fpga

00:01:19,200 --> 00:01:23,119
is

00:01:20,240 --> 00:01:24,320
and we use through current access that

00:01:23,119 --> 00:01:28,320
opencap provides

00:01:24,320 --> 00:01:28,960
on polar systems what is an fpga we'll

00:01:28,320 --> 00:01:32,000
see how it

00:01:28,960 --> 00:01:33,920
can complete and not compete with gpu

00:01:32,000 --> 00:01:35,920
acceleration

00:01:33,920 --> 00:01:37,920
where can we start we'll see a brief

00:01:35,920 --> 00:01:42,079
introduction of the github

00:01:37,920 --> 00:01:44,320
structure and how to use it and

00:01:42,079 --> 00:01:45,280
in three steps we see how we can

00:01:44,320 --> 00:01:48,799
simulate

00:01:45,280 --> 00:01:54,880
and generate a configuration

00:01:48,799 --> 00:01:57,040
and deploy on power9 system

00:01:54,880 --> 00:01:59,040
at the end we'll see um if we can use

00:01:57,040 --> 00:02:02,799
speed python or not

00:01:59,040 --> 00:02:07,040
and we will have a

00:02:02,799 --> 00:02:10,160
brief um a brief view of a test case

00:02:07,040 --> 00:02:10,959
so first we'll cover open copy very

00:02:10,160 --> 00:02:12,720
briefly because

00:02:10,959 --> 00:02:14,640
alan canton has already made a

00:02:12,720 --> 00:02:16,400
presentation earlier today

00:02:14,640 --> 00:02:18,319
we will go through the fpga technology

00:02:16,400 --> 00:02:21,440
as we said we'll cover

00:02:18,319 --> 00:02:21,840
what it brings we'll see in details what

00:02:21,440 --> 00:02:25,680
oc

00:02:21,840 --> 00:02:26,160
excel can offer to you and i will go

00:02:25,680 --> 00:02:29,760
through

00:02:26,160 --> 00:02:32,879
a very interesting test case that

00:02:29,760 --> 00:02:34,840
philippe will be presenting in this open

00:02:32,879 --> 00:02:37,760
capy

00:02:34,840 --> 00:02:40,879
thread all right so

00:02:37,760 --> 00:02:41,360
um first a very brief introduction brief

00:02:40,879 --> 00:02:44,080
um

00:02:41,360 --> 00:02:45,680
speak about open copy consortium most of

00:02:44,080 --> 00:02:48,879
you have attended an alien cancel

00:02:45,680 --> 00:02:50,400
presentation or mendes presentation so

00:02:48,879 --> 00:02:52,239
most of you are aware that there is a

00:02:50,400 --> 00:02:53,040
site where you can find information

00:02:52,239 --> 00:02:56,959
there are many

00:02:53,040 --> 00:02:59,440
open opened open source uh information

00:02:56,959 --> 00:03:00,159
as far as the technology is uh usable

00:02:59,440 --> 00:03:03,760
directly

00:03:00,159 --> 00:03:07,120
and you can get different levels of

00:03:03,760 --> 00:03:10,159
hardware it stands for

00:03:07,120 --> 00:03:11,840
current accelerator processor interface

00:03:10,159 --> 00:03:15,280
so what you need to remind to have in

00:03:11,840 --> 00:03:17,920
mind is that the open cap is a unique

00:03:15,280 --> 00:03:18,480
technology that offers you to access to

00:03:17,920 --> 00:03:21,599
the

00:03:18,480 --> 00:03:22,560
host memory without any buffering so

00:03:21,599 --> 00:03:24,159
it's

00:03:22,560 --> 00:03:25,840
the only to my knowledge to see only

00:03:24,159 --> 00:03:28,879
direct and

00:03:25,840 --> 00:03:32,080
nice access to the host memory

00:03:28,879 --> 00:03:34,640
so let's begin with the fpga technology

00:03:32,080 --> 00:03:35,680
we'll go in details what what it brings

00:03:34,640 --> 00:03:38,799
first it's

00:03:35,680 --> 00:03:41,760
stands for field programmable gate array

00:03:38,799 --> 00:03:42,400
so think about a huge number of cells

00:03:41,760 --> 00:03:44,959
logic

00:03:42,400 --> 00:03:46,159
cells that have not been interconnected

00:03:44,959 --> 00:03:48,640
so the last layer

00:03:46,159 --> 00:03:50,080
of achieved design has not been made and

00:03:48,640 --> 00:03:52,560
it is left to you

00:03:50,080 --> 00:03:54,080
as a designer the capability to

00:03:52,560 --> 00:03:55,680
interconnect these further

00:03:54,080 --> 00:03:57,280
for to achieve that you will be helped

00:03:55,680 --> 00:03:58,879
by

00:03:57,280 --> 00:04:01,439
software which is dependent on the

00:03:58,879 --> 00:04:05,040
provider the main provider we work with

00:04:01,439 --> 00:04:07,760
is xilinx so we use the designing suit

00:04:05,040 --> 00:04:09,680
to prepare this last layer in order to

00:04:07,760 --> 00:04:11,040
configure the chip to do whatever we

00:04:09,680 --> 00:04:12,959
need

00:04:11,040 --> 00:04:14,400
the configuration is usually usually

00:04:12,959 --> 00:04:15,920
store in local

00:04:14,400 --> 00:04:18,079
flash memory on the board that you've

00:04:15,920 --> 00:04:19,759
bought usually from from the supplier or

00:04:18,079 --> 00:04:21,680
that you've made yourself

00:04:19,759 --> 00:04:23,199
and this flash memory at the power-up

00:04:21,680 --> 00:04:25,919
will configure the chip

00:04:23,199 --> 00:04:27,280
and finish the the last interconnection

00:04:25,919 --> 00:04:29,120
to do whatever function you have

00:04:27,280 --> 00:04:32,479
programmed

00:04:29,120 --> 00:04:34,240
uh think about the um lego so we'll see

00:04:32,479 --> 00:04:37,520
how um oc excel uses

00:04:34,240 --> 00:04:38,240
this lego i shouldn't tell you i should

00:04:37,520 --> 00:04:42,160
i should say

00:04:38,240 --> 00:04:43,040
think about cubes storable cubes the

00:04:42,160 --> 00:04:46,880
fpga

00:04:43,040 --> 00:04:47,199
is made of as we said a logic that can

00:04:46,880 --> 00:04:49,120
be

00:04:47,199 --> 00:04:50,639
reprogrammed so it's up to you to

00:04:49,120 --> 00:04:53,520
prepare the programmation

00:04:50,639 --> 00:04:54,240
it offers you configure configurable ios

00:04:53,520 --> 00:04:57,360
and high-speed

00:04:54,240 --> 00:05:00,639
serial links which we use in the open

00:04:57,360 --> 00:05:03,039
technology um it has

00:05:00,639 --> 00:05:04,880
advantages in terms of flexibility once

00:05:03,039 --> 00:05:08,000
you have bought a board containing

00:05:04,880 --> 00:05:10,479
fpga you can reprogram it for for

00:05:08,000 --> 00:05:11,440
almost forever maybe not forever but for

00:05:10,479 --> 00:05:14,720
for thousands of

00:05:11,440 --> 00:05:17,120
times it uh it offers you high

00:05:14,720 --> 00:05:19,680
capability in terms of parallelism

00:05:17,120 --> 00:05:20,400
you can create small function that do a

00:05:19,680 --> 00:05:21,759
small job

00:05:20,400 --> 00:05:24,080
and you can have many of them in

00:05:21,759 --> 00:05:26,560
parallel it allows you to have

00:05:24,080 --> 00:05:28,080
very deep pipelines so it can be very

00:05:26,560 --> 00:05:30,880
interesting in terms of

00:05:28,080 --> 00:05:31,440
for example compression or whatever and

00:05:30,880 --> 00:05:34,479
you have

00:05:31,440 --> 00:05:37,759
integrated hard ips which simplify a lot

00:05:34,479 --> 00:05:40,960
the the big functions like

00:05:37,759 --> 00:05:44,240
access to pci connection access to

00:05:40,960 --> 00:05:46,000
ethernet or access to memories

00:05:44,240 --> 00:05:47,759
so once you have understood that

00:05:46,000 --> 00:05:51,440
historically we have

00:05:47,759 --> 00:05:54,560
been using fpgas by programming them

00:05:51,440 --> 00:05:57,600
into a structured language

00:05:54,560 --> 00:06:01,759
or languages which are named hdl

00:05:57,600 --> 00:06:04,960
the two main known languages are verilog

00:06:01,759 --> 00:06:08,160
or vhdl both

00:06:04,960 --> 00:06:10,800
are a way to describe the logic so

00:06:08,160 --> 00:06:12,479
it's not code it's a way to describe

00:06:10,800 --> 00:06:16,080
what you want at the end to be

00:06:12,479 --> 00:06:18,319
interconnected it used to be um

00:06:16,080 --> 00:06:20,000
require it used to require specific

00:06:18,319 --> 00:06:22,800
skills and we will see

00:06:20,000 --> 00:06:24,479
how we can override these constraints

00:06:22,800 --> 00:06:26,080
that many people still have in mind

00:06:24,479 --> 00:06:28,720
today

00:06:26,080 --> 00:06:30,639
once you have synthesized software

00:06:28,720 --> 00:06:31,840
people will say compile but it's it's a

00:06:30,639 --> 00:06:34,400
synthesis

00:06:31,840 --> 00:06:35,039
uh think about the compilation then you

00:06:34,400 --> 00:06:37,120
can

00:06:35,039 --> 00:06:38,960
get a binary file that you store in the

00:06:37,120 --> 00:06:40,160
in the flash memory which allows you to

00:06:38,960 --> 00:06:42,639
program the board

00:06:40,160 --> 00:06:45,120
when you begin to power up your your

00:06:42,639 --> 00:06:45,120
circuit

00:06:45,199 --> 00:06:49,199
an example of large card which comes

00:06:47,520 --> 00:06:51,520
from a bit where there are many of them

00:06:49,199 --> 00:06:52,479
alpha data is also a big supplier of

00:06:51,520 --> 00:06:56,080
cards

00:06:52,479 --> 00:06:56,560
this integrates also a zinc circuitry

00:06:56,080 --> 00:06:59,680
which

00:06:56,560 --> 00:07:02,160
hosts the cortex

00:06:59,680 --> 00:07:03,840
and technology so it's not only an fpga

00:07:02,160 --> 00:07:07,440
but it also hosts

00:07:03,840 --> 00:07:09,840
a microcontroller that can host codes

00:07:07,440 --> 00:07:09,840
in turn

00:07:10,720 --> 00:07:15,360
right to the topic what can occl do with

00:07:13,680 --> 00:07:18,479
an fpga you can say okay

00:07:15,360 --> 00:07:20,319
how can i be helped to prepare my logic

00:07:18,479 --> 00:07:23,039
because it seems very complex to me

00:07:20,319 --> 00:07:24,479
so think about these cubes that we that

00:07:23,039 --> 00:07:27,840
are unorganized

00:07:24,479 --> 00:07:29,680
and we need to prepare some organization

00:07:27,840 --> 00:07:31,520
which we can duplicate eventually so

00:07:29,680 --> 00:07:34,720
this is why i have drawn

00:07:31,520 --> 00:07:37,360
the beginning of a castle and you can

00:07:34,720 --> 00:07:38,080
do according to the size of your spga

00:07:37,360 --> 00:07:40,000
you can

00:07:38,080 --> 00:07:41,680
consider multiplying and parallel

00:07:40,000 --> 00:07:44,720
parallelizing things

00:07:41,680 --> 00:07:45,680
so the goal with um the system we have

00:07:44,720 --> 00:07:47,840
in our hands

00:07:45,680 --> 00:07:49,520
is to be able to ease the preparation of

00:07:47,840 --> 00:07:52,080
this logic

00:07:49,520 --> 00:07:52,720
and the functions will be not run

00:07:52,080 --> 00:07:54,479
running

00:07:52,720 --> 00:07:56,800
like like code they will not be running

00:07:54,479 --> 00:07:57,599
sequentially but they will already be

00:07:56,800 --> 00:07:59,599
running

00:07:57,599 --> 00:08:03,199
in parallel if it's your desire because

00:07:59,599 --> 00:08:03,199
you are in front of logic

00:08:03,440 --> 00:08:09,199
so occl will help you to prepare these

00:08:06,560 --> 00:08:10,160
castles all these houses but it will

00:08:09,199 --> 00:08:12,960
also raise

00:08:10,160 --> 00:08:14,400
the interconnection of all this logic

00:08:12,960 --> 00:08:16,479
with your power or

00:08:14,400 --> 00:08:18,879
system thanks to the open capit

00:08:16,479 --> 00:08:21,840
technology so it will not be only

00:08:18,879 --> 00:08:22,800
a fast link which you can think about at

00:08:21,840 --> 00:08:25,680
first sight

00:08:22,800 --> 00:08:27,759
but it's also a way to exchange data

00:08:25,680 --> 00:08:29,759
from the fpga to the oauth memory as

00:08:27,759 --> 00:08:31,919
we'll see

00:08:29,759 --> 00:08:34,640
an example to fix ideas for people who

00:08:31,919 --> 00:08:37,479
are not knowledgeable in fpgas

00:08:34,640 --> 00:08:39,279
an example of integration into a large

00:08:37,479 --> 00:08:41,599
9h7

00:08:39,279 --> 00:08:43,279
alpha data card i forgot to mention the

00:08:41,599 --> 00:08:46,399
supplier of the card

00:08:43,279 --> 00:08:48,959
but it's usually uh

00:08:46,399 --> 00:08:49,440
achieved that we that we use on alpha

00:08:48,959 --> 00:08:51,040
card

00:08:49,440 --> 00:08:53,040
here we are just considering the chip

00:08:51,040 --> 00:08:57,200
itself which is provided by the links

00:08:53,040 --> 00:09:00,640
in this 9h7 card which hosts

00:08:57,200 --> 00:09:02,160
xu was it i don't remember the reference

00:09:00,640 --> 00:09:06,000
27 i think

00:09:02,160 --> 00:09:09,120
um michael bruno here he constrained

00:09:06,000 --> 00:09:10,560
the logic to be into a slice here so we

00:09:09,120 --> 00:09:12,320
can see different area

00:09:10,560 --> 00:09:13,680
this is the area in yellow that the

00:09:12,320 --> 00:09:15,279
action we'll see

00:09:13,680 --> 00:09:16,800
what it is this is what you have

00:09:15,279 --> 00:09:19,760
described what you wanted to

00:09:16,800 --> 00:09:21,920
prepare in tyler logic this is your your

00:09:19,760 --> 00:09:25,120
part which is yellow

00:09:21,920 --> 00:09:28,560
in in blue we see the remember this

00:09:25,120 --> 00:09:30,800
interconnection layer that ibm is or

00:09:28,560 --> 00:09:33,200
open open copy is taking care for you so

00:09:30,800 --> 00:09:34,880
we need to embed some logic here

00:09:33,200 --> 00:09:36,640
and then you have a snap call which is

00:09:34,880 --> 00:09:38,560
doing some functions to allow you

00:09:36,640 --> 00:09:41,040
to allow you your action to talk to the

00:09:38,560 --> 00:09:41,040
memory

00:09:42,240 --> 00:09:48,720
so coming once one step

00:09:45,519 --> 00:09:49,519
one step higher the question can be

00:09:48,720 --> 00:09:51,519
raised

00:09:49,519 --> 00:09:54,000
how can we choose between gpu and

00:09:51,519 --> 00:09:55,920
eventually an fpga acceleration

00:09:54,000 --> 00:09:57,600
so first of all they are not competing

00:09:55,920 --> 00:10:00,240
they are not on the same

00:09:57,600 --> 00:10:01,200
topics they are not doing the job in the

00:10:00,240 --> 00:10:03,600
same way

00:10:01,200 --> 00:10:05,279
so one solution can be better in one in

00:10:03,600 --> 00:10:06,800
one domain the other in another domain

00:10:05,279 --> 00:10:08,399
and sometimes we can be very happy to

00:10:06,800 --> 00:10:10,320
use both of them

00:10:08,399 --> 00:10:11,760
so first of all the gpu is known very

00:10:10,320 --> 00:10:14,320
well known it's uh

00:10:11,760 --> 00:10:16,480
it's aimed at dealing with computing

00:10:14,320 --> 00:10:17,600
intensive applications it's a it's a

00:10:16,480 --> 00:10:19,680
bunch of

00:10:17,600 --> 00:10:21,120
chinese cpus which are using

00:10:19,680 --> 00:10:24,399
polarization to do

00:10:21,120 --> 00:10:27,519
a huge number of tasks whether

00:10:24,399 --> 00:10:29,920
fpga is a bunch of logic as we said

00:10:27,519 --> 00:10:30,880
so it's very low latency and it's very

00:10:29,920 --> 00:10:32,959
predictable

00:10:30,880 --> 00:10:34,560
so we can know exactly how many clock

00:10:32,959 --> 00:10:36,880
ticks clock ticks means

00:10:34,560 --> 00:10:38,079
that the clocking system inside the fpga

00:10:36,880 --> 00:10:40,560
we can know exactly

00:10:38,079 --> 00:10:41,279
how long a function will take to up to

00:10:40,560 --> 00:10:45,279
be

00:10:41,279 --> 00:10:48,640
to be operating so it's more real time

00:10:45,279 --> 00:10:50,560
and it can be it's not sequential and

00:10:48,640 --> 00:10:51,920
can be used it can be using high

00:10:50,560 --> 00:10:55,440
parallelism

00:10:51,920 --> 00:10:57,839
so let's have a word on um what we have

00:10:55,440 --> 00:11:00,320
as advantages so we know that software

00:10:57,839 --> 00:11:01,279
is very quick to develop it can be

00:11:00,320 --> 00:11:04,160
reused

00:11:01,279 --> 00:11:06,000
it can be a patch the disadvantage is

00:11:04,160 --> 00:11:07,760
that it's very slow to run because most

00:11:06,000 --> 00:11:10,320
of the time it's a sequential

00:11:07,760 --> 00:11:12,959
uh operations sequential operation that

00:11:10,320 --> 00:11:14,800
we want to run

00:11:12,959 --> 00:11:16,399
hardware is known to be very fast it's

00:11:14,800 --> 00:11:19,600
going to be reduced

00:11:16,399 --> 00:11:20,640
consumption it is not to be very low

00:11:19,600 --> 00:11:22,959
latency because

00:11:20,640 --> 00:11:26,160
it's it's hand at doing the task so it

00:11:22,959 --> 00:11:29,279
it is really tuned for this task

00:11:26,160 --> 00:11:31,440
we can have also parallelism and high

00:11:29,279 --> 00:11:32,079
bandwidth to access to the memory as we

00:11:31,440 --> 00:11:34,720
see

00:11:32,079 --> 00:11:35,839
in an example with opencapi and we can

00:11:34,720 --> 00:11:38,079
also dedicate

00:11:35,839 --> 00:11:39,839
specific areas and optimize the error to

00:11:38,079 --> 00:11:42,959
do that the contract

00:11:39,839 --> 00:11:44,800
the the cone for that is that as we said

00:11:42,959 --> 00:11:46,000
we used to have for a long time very

00:11:44,800 --> 00:11:48,240
heavy um

00:11:46,000 --> 00:11:49,279
source code to define the logic and this

00:11:48,240 --> 00:11:51,920
was recurring

00:11:49,279 --> 00:11:52,639
high skills specific skills and it was

00:11:51,920 --> 00:11:55,920
known to be

00:11:52,639 --> 00:11:58,079
very costly because um the the the

00:11:55,920 --> 00:12:00,560
maturity of the technology was not

00:11:58,079 --> 00:12:02,240
developed enough and the cost was uh of

00:12:00,560 --> 00:12:03,200
course a little bit higher than it is

00:12:02,240 --> 00:12:05,600
today

00:12:03,200 --> 00:12:06,720
so it was leading to much longer time to

00:12:05,600 --> 00:12:08,720
market

00:12:06,720 --> 00:12:10,480
what if we could remove most of the

00:12:08,720 --> 00:12:15,040
disadvantages disadvantages

00:12:10,480 --> 00:12:18,399
of the software and the hardware sides

00:12:15,040 --> 00:12:20,000
so the goal of the combination of the

00:12:18,399 --> 00:12:23,279
fpga and open copy

00:12:20,000 --> 00:12:26,160
and the framework of cxl is to offer you

00:12:23,279 --> 00:12:26,800
reducing the disadvantage of not using

00:12:26,160 --> 00:12:29,440
software

00:12:26,800 --> 00:12:30,399
so we'll be using software to describe

00:12:29,440 --> 00:12:32,800
the logic

00:12:30,399 --> 00:12:36,160
and this is what makes xylex part

00:12:32,800 --> 00:12:39,040
particularly very interesting

00:12:36,160 --> 00:12:40,160
so we will describe the logic using c or

00:12:39,040 --> 00:12:42,959
c plus plus

00:12:40,160 --> 00:12:43,760
and we will use xi link's hls tool to

00:12:42,959 --> 00:12:47,440
convert

00:12:43,760 --> 00:12:49,440
our description into a die

00:12:47,440 --> 00:12:53,040
digestible that english something that

00:12:49,440 --> 00:12:55,760
the fpga can understand

00:12:53,040 --> 00:12:56,800
why the hardware was very long to

00:12:55,760 --> 00:13:00,399
develop

00:12:56,800 --> 00:13:01,200
now thanks to this hls and thanks to the

00:13:00,399 --> 00:13:02,800
open copy

00:13:01,200 --> 00:13:04,320
very fast access to the memory and

00:13:02,800 --> 00:13:09,440
direct access to the memory

00:13:04,320 --> 00:13:09,440
we can reduce a lot these disadvantages

00:13:09,760 --> 00:13:15,440
so let's go into russia excel

00:13:13,040 --> 00:13:16,079
um we know in my menu what time will be

00:13:15,440 --> 00:13:21,839
we we

00:13:16,079 --> 00:13:21,839
we left we leave the wait until five

00:13:24,720 --> 00:13:30,399
so we'll go um where the code is located

00:13:28,399 --> 00:13:31,680
so it's an open source development that

00:13:30,399 --> 00:13:33,760
is following the snap

00:13:31,680 --> 00:13:34,800
which was concerning cappy and kp2

00:13:33,760 --> 00:13:37,440
technology as

00:13:34,800 --> 00:13:39,279
alan mentioned it's now for years that

00:13:37,440 --> 00:13:42,160
this technology is existing

00:13:39,279 --> 00:13:42,720
we have taken the time to do the draft

00:13:42,160 --> 00:13:44,560
and now

00:13:42,720 --> 00:13:47,199
it is a third generation so it's pretty

00:13:44,560 --> 00:13:49,519
mature and very operational

00:13:47,199 --> 00:13:51,360
the code can be found here on github the

00:13:49,519 --> 00:13:54,800
documentation can be accessed

00:13:51,360 --> 00:13:57,920
here on github 2 and to setup a product

00:13:54,800 --> 00:13:59,920
process as a project we'll see how

00:13:57,920 --> 00:14:01,920
uh will not see but it's very easy to

00:13:59,920 --> 00:14:02,720
reuse a cappy one on campus to

00:14:01,920 --> 00:14:04,480
development

00:14:02,720 --> 00:14:06,480
in case you have done it already then

00:14:04,480 --> 00:14:09,440
it's very easy to exchange cards

00:14:06,480 --> 00:14:10,959
using existing cards or preparing a new

00:14:09,440 --> 00:14:12,880
card that you have in mind

00:14:10,959 --> 00:14:14,000
we'll see how we can semi simulate

00:14:12,880 --> 00:14:16,399
generate

00:14:14,000 --> 00:14:17,279
the binary content and see an example of

00:14:16,399 --> 00:14:18,959
our

00:14:17,279 --> 00:14:22,079
friend and colleague philippe that he

00:14:18,959 --> 00:14:25,199
has done with oc excel

00:14:22,079 --> 00:14:27,760
um what's he actually overview so

00:14:25,199 --> 00:14:29,120
the goal for you is to take a yellow

00:14:27,760 --> 00:14:31,199
program that you have that

00:14:29,120 --> 00:14:33,040
we're gonna have an application and you

00:14:31,199 --> 00:14:35,040
know that this application is taking

00:14:33,040 --> 00:14:37,199
time to do repetitive tasks that you

00:14:35,040 --> 00:14:40,720
think in talking with

00:14:37,199 --> 00:14:41,120
with um people using fpga you have a a

00:14:40,720 --> 00:14:44,160
guess

00:14:41,120 --> 00:14:47,040
and you would like to go deeper into

00:14:44,160 --> 00:14:47,760
subcontracting some of the actions that

00:14:47,040 --> 00:14:50,240
are in your

00:14:47,760 --> 00:14:52,079
application that you would like to put

00:14:50,240 --> 00:14:54,240
into another action

00:14:52,079 --> 00:14:56,160
so the goal is to get some of the

00:14:54,240 --> 00:14:59,199
application and transfer it

00:14:56,160 --> 00:15:01,360
into the fpga on the right left you have

00:14:59,199 --> 00:15:02,639
your server and on the right you have

00:15:01,360 --> 00:15:04,800
one card embedded into

00:15:02,639 --> 00:15:06,399
your server interconnected with the open

00:15:04,800 --> 00:15:08,639
copy technology

00:15:06,399 --> 00:15:10,639
coming with open copy we will come a

00:15:08,639 --> 00:15:10,959
bunch of hardware description that will

00:15:10,639 --> 00:15:13,680
go

00:15:10,959 --> 00:15:14,000
remember the blue area of the chip that

00:15:13,680 --> 00:15:16,160
will

00:15:14,000 --> 00:15:18,160
allow the intercommunication of the

00:15:16,160 --> 00:15:20,480
oauth memory and the fpga

00:15:18,160 --> 00:15:21,600
and on the software side very tiny and

00:15:20,480 --> 00:15:23,760
small libraries

00:15:21,600 --> 00:15:24,639
because most of the driver has been

00:15:23,760 --> 00:15:27,600
performed and

00:15:24,639 --> 00:15:28,160
and written in hardware inside the power

00:15:27,600 --> 00:15:31,199
00:15:28,160 --> 00:15:33,360
chips so this reduces a lot

00:15:31,199 --> 00:15:36,560
the software complexity on the software

00:15:33,360 --> 00:15:38,959
side which is a very good advantage

00:15:36,560 --> 00:15:40,079
on the right hand side we see the card

00:15:38,959 --> 00:15:43,519
is hosting different

00:15:40,079 --> 00:15:46,959
um hardware interconnected

00:15:43,519 --> 00:15:49,199
parts they can be a dram that can

00:15:46,959 --> 00:15:51,759
that can be hosted by the card they can

00:15:49,199 --> 00:15:53,600
be kgs that allows you

00:15:51,759 --> 00:15:55,040
that allow you to connect to the outside

00:15:53,600 --> 00:15:58,560
world with ethernet

00:15:55,040 --> 00:15:58,560
or anything you could think of

00:15:58,720 --> 00:16:04,320
it can be for example a a converter like

00:16:02,399 --> 00:16:05,759
very very high-speed converter to link

00:16:04,320 --> 00:16:08,720
to a 5g

00:16:05,759 --> 00:16:09,519
system that that collects and treats on

00:16:08,720 --> 00:16:11,759
the car

00:16:09,519 --> 00:16:13,519
a huge amount of bandwidths and data

00:16:11,759 --> 00:16:17,199
with your own designed

00:16:13,519 --> 00:16:18,880
uh dac or adc or that configurations

00:16:17,199 --> 00:16:20,399
that can directly talk to those memory

00:16:18,880 --> 00:16:24,480
of the server so you can

00:16:20,399 --> 00:16:27,360
embed also 5g type applications

00:16:24,480 --> 00:16:27,680
a word on the documentation according to

00:16:27,360 --> 00:16:31,199
us

00:16:27,680 --> 00:16:32,079
spend some time to make it i shouldn't

00:16:31,199 --> 00:16:34,639
say

00:16:32,079 --> 00:16:36,560
the adjective that comes to my mind but

00:16:34,639 --> 00:16:40,000
nice looking i should say

00:16:36,560 --> 00:16:42,480
and this this is written in a in a

00:16:40,000 --> 00:16:45,680
server like a

00:16:42,480 --> 00:16:49,279
system that so you can update

00:16:45,680 --> 00:16:52,240
suggest updates or modifications

00:16:49,279 --> 00:16:52,880
what we have basically inside the

00:16:52,240 --> 00:16:55,519
structure

00:16:52,880 --> 00:16:57,680
of the snap or the oc excel today is a

00:16:55,519 --> 00:16:59,759
bunch of examples that you should rely

00:16:57,680 --> 00:17:02,560
on to develop your own examples

00:16:59,759 --> 00:17:03,600
we will go briefly on the image filter

00:17:02,560 --> 00:17:06,400
and

00:17:03,600 --> 00:17:07,039
say a word about the example in python

00:17:06,400 --> 00:17:09,679
so

00:17:07,039 --> 00:17:10,720
in each egg in each action directory you

00:17:09,679 --> 00:17:13,760
see we are in oc

00:17:10,720 --> 00:17:15,600
excel actions directory you will find a

00:17:13,760 --> 00:17:18,400
software

00:17:15,600 --> 00:17:20,000
subdirectory which hosts the main

00:17:18,400 --> 00:17:23,360
so-called application

00:17:20,000 --> 00:17:26,799
that will be launching the hardware

00:17:23,360 --> 00:17:28,319
and we have a hardware subdirectory in

00:17:26,799 --> 00:17:30,720
which we have described

00:17:28,319 --> 00:17:31,760
in c most of the time but you can also

00:17:30,720 --> 00:17:34,320
still describe

00:17:31,760 --> 00:17:35,440
everything in hdl languages but we

00:17:34,320 --> 00:17:38,559
prefer using

00:17:35,440 --> 00:17:40,559
a more recent way to describe in cc

00:17:38,559 --> 00:17:41,840
directions you will see the examples of

00:17:40,559 --> 00:17:43,520
the description

00:17:41,840 --> 00:17:44,960
we will briefly explore a pixel

00:17:43,520 --> 00:17:48,080
manipulation example

00:17:44,960 --> 00:17:48,320
that we have taken from our colleagues

00:17:48,080 --> 00:17:51,360
and

00:17:48,320 --> 00:17:53,200
friends from hpi

00:17:51,360 --> 00:17:54,400
and we will see a bit bison example that

00:17:53,200 --> 00:17:57,520
has been developed by

00:17:54,400 --> 00:17:59,200
our research department so first thing

00:17:57,520 --> 00:18:00,799
you need to do is to set up your

00:17:59,200 --> 00:18:03,600
desiring stools

00:18:00,799 --> 00:18:04,400
most of the time people will use silence

00:18:03,600 --> 00:18:07,280
parts so

00:18:04,400 --> 00:18:07,600
most of the cards if not all the cards

00:18:07,280 --> 00:18:10,000
are

00:18:07,600 --> 00:18:11,520
hosting xilinx components which is a

00:18:10,000 --> 00:18:14,559
fpga provider

00:18:11,520 --> 00:18:15,520
so you need to set up some things to

00:18:14,559 --> 00:18:17,120
make sure that

00:18:15,520 --> 00:18:19,520
you access to your card i won't go into

00:18:17,120 --> 00:18:21,600
the details then while typing

00:18:19,520 --> 00:18:22,640
make snap config which is really the

00:18:21,600 --> 00:18:24,160
first thing sorry

00:18:22,640 --> 00:18:26,720
which is really the first thing you want

00:18:24,160 --> 00:18:28,080
to type you will get a very simple open

00:18:26,720 --> 00:18:31,440
source menu

00:18:28,080 --> 00:18:34,640
that is based on an open source

00:18:31,440 --> 00:18:38,000
configuration tool that will allow you

00:18:34,640 --> 00:18:39,360
to avoid make main mistakes that we have

00:18:38,000 --> 00:18:42,799
prevented you to do

00:18:39,360 --> 00:18:46,160
so so we we can analyze you to get

00:18:42,799 --> 00:18:46,960
into basic examples and we sub select

00:18:46,160 --> 00:18:49,440
for you

00:18:46,960 --> 00:18:51,200
the the the the possibilities according

00:18:49,440 --> 00:18:54,960
to what you have chosen so here i chose

00:18:51,200 --> 00:18:57,360
an alpha data 93 card hosting vu sweepy

00:18:54,960 --> 00:18:58,400
exiling spot and i selected the image

00:18:57,360 --> 00:19:00,799
filter

00:18:58,400 --> 00:19:01,520
once i've selected this the system will

00:19:00,799 --> 00:19:03,600
set up some

00:19:01,520 --> 00:19:05,039
environment variables and these

00:19:03,600 --> 00:19:07,520
variables will be

00:19:05,039 --> 00:19:09,440
a read and then i can make a simulation

00:19:07,520 --> 00:19:11,200
you see that in less than five minutes i

00:19:09,440 --> 00:19:13,360
can be ready to make a simulation

00:19:11,200 --> 00:19:14,960
then i can launch on a small image a

00:19:13,360 --> 00:19:16,400
transformation the goal is to transform

00:19:14,960 --> 00:19:18,799
an image into another

00:19:16,400 --> 00:19:21,280
and see the result is agreeing is

00:19:18,799 --> 00:19:24,160
agreeing to what i expect

00:19:21,280 --> 00:19:26,960
once i have sometimes i can encounter

00:19:24,160 --> 00:19:29,760
problems so i can enter into a debugger

00:19:26,960 --> 00:19:30,720
should i do so and for the first step i

00:19:29,760 --> 00:19:33,360
can make sure that

00:19:30,720 --> 00:19:34,160
every pixel this is a bitmap example

00:19:33,360 --> 00:19:38,160
every pixel

00:19:34,160 --> 00:19:41,280
is going into the sequence that i've

00:19:38,160 --> 00:19:43,440
prepared for them for the manipulation

00:19:41,280 --> 00:19:45,200
an example of the code so the

00:19:43,440 --> 00:19:46,960
manipulation of the pixel is really

00:19:45,200 --> 00:19:50,160
written in pure c

00:19:46,960 --> 00:19:53,360
we see here that we prepare pixels

00:19:50,160 --> 00:19:56,160
and if the pixel has not enough red

00:19:53,360 --> 00:19:56,880
inside its coding then we will replace

00:19:56,160 --> 00:19:59,919
each

00:19:56,880 --> 00:20:03,200
component of the pixel which with a gray

00:19:59,919 --> 00:20:05,120
gray um computed value

00:20:03,200 --> 00:20:07,360
otherwise we will reproduce the red

00:20:05,120 --> 00:20:09,039
value the the rate containing pixel

00:20:07,360 --> 00:20:10,720
so you see it's pretty easy the

00:20:09,039 --> 00:20:14,720
transformation if the pixel

00:20:10,720 --> 00:20:18,240
has not enough red

00:20:14,720 --> 00:20:21,840
then i replaced by a grayscale otherwise

00:20:18,240 --> 00:20:24,320
i just duplicate the pixel

00:20:21,840 --> 00:20:25,840
then we can deploy on the power system

00:20:24,320 --> 00:20:28,159
we need to prepare

00:20:25,840 --> 00:20:29,280
the image so we say make image this can

00:20:28,159 --> 00:20:31,840
take time

00:20:29,280 --> 00:20:33,280
and the binary file which we hopefully

00:20:31,840 --> 00:20:35,280
get after some time

00:20:33,280 --> 00:20:37,200
can be transferred to a boiler system

00:20:35,280 --> 00:20:37,600
and on the power system we can simply

00:20:37,200 --> 00:20:39,919
run

00:20:37,600 --> 00:20:41,760
check for that we have a card after the

00:20:39,919 --> 00:20:43,120
process of making image i check that i

00:20:41,760 --> 00:20:46,559
have an open copy card

00:20:43,120 --> 00:20:49,280
it's present i check that it contains

00:20:46,559 --> 00:20:50,000
my my my code i didn't go into the

00:20:49,280 --> 00:20:52,080
details

00:20:50,000 --> 00:20:53,200
and then i can run my code and transform

00:20:52,080 --> 00:20:56,480
the image

00:20:53,200 --> 00:20:57,600
to get what i expect okay so all pixels

00:20:56,480 --> 00:21:00,640
containing

00:20:57,600 --> 00:21:03,200
a big version of red is great

00:21:00,640 --> 00:21:05,440
and i can check my performance here we

00:21:03,200 --> 00:21:08,320
provide an example of performance

00:21:05,440 --> 00:21:09,440
and it's an example that we have just

00:21:08,320 --> 00:21:12,799
updated

00:21:09,440 --> 00:21:16,480
so we see that to transfer to 256

00:21:12,799 --> 00:21:18,559
megabyte file we you we

00:21:16,480 --> 00:21:19,679
we transferred that from the host to the

00:21:18,559 --> 00:21:21,840
fpga ram

00:21:19,679 --> 00:21:23,440
which is a ram that is hosted by the fpg

00:21:21,840 --> 00:21:26,720
car we transfer

00:21:23,440 --> 00:21:27,760
at a speed of almost 18 gigabytes per

00:21:26,720 --> 00:21:29,360
second

00:21:27,760 --> 00:21:30,880
while returning from the fpga to the

00:21:29,360 --> 00:21:33,919
host was transferred

00:21:30,880 --> 00:21:34,799
at a speed of almost 21 gigabytes and

00:21:33,919 --> 00:21:37,120
this is

00:21:34,799 --> 00:21:38,080
the let's say slow access to the local

00:21:37,120 --> 00:21:40,240
ram

00:21:38,080 --> 00:21:41,120
which is not the latest technology on

00:21:40,240 --> 00:21:44,960
this car

00:21:41,120 --> 00:21:46,559
and this is about 12 gigabytes

00:21:44,960 --> 00:21:48,880
make sure that you use the numeric

00:21:46,559 --> 00:21:50,000
control to make sure that the fpga is

00:21:48,880 --> 00:21:52,480
attached to the

00:21:50,000 --> 00:21:53,840
core to the to the yes to the code that

00:21:52,480 --> 00:21:57,200
is talking to the ram

00:21:53,840 --> 00:21:59,280
a python example is provided you need to

00:21:57,200 --> 00:22:00,799
set up your environment because as you

00:21:59,280 --> 00:22:02,400
know python is not that easy to

00:22:00,799 --> 00:22:03,280
manipulate if you are not the right

00:22:02,400 --> 00:22:04,880
version

00:22:03,280 --> 00:22:06,480
once you have set up your environment

00:22:04,880 --> 00:22:09,280
you can follow the guide

00:22:06,480 --> 00:22:10,320
that we have provided on this example

00:22:09,280 --> 00:22:12,320
that you will find here

00:22:10,320 --> 00:22:14,000
so yes we can define the application in

00:22:12,320 --> 00:22:16,320
python we will not define

00:22:14,000 --> 00:22:17,600
the action hardware action in python but

00:22:16,320 --> 00:22:20,320
we can exercise

00:22:17,600 --> 00:22:22,480
in a hardware action using python on the

00:22:20,320 --> 00:22:24,960
top of it

00:22:22,480 --> 00:22:26,799
and hopefully we will um speak a word

00:22:24,960 --> 00:22:28,640
but please attend the presentation of

00:22:26,799 --> 00:22:31,360
our

00:22:28,640 --> 00:22:32,799
partner and and friend philippe from

00:22:31,360 --> 00:22:35,200
paul scherrer institute

00:22:32,799 --> 00:22:35,840
based in switzerland who would really

00:22:35,200 --> 00:22:38,400
like you

00:22:35,840 --> 00:22:39,440
to follow this very interesting test

00:22:38,400 --> 00:22:42,320
case that

00:22:39,440 --> 00:22:43,520
he has produced is using currently or

00:22:42,320 --> 00:22:46,720
intending to use

00:22:43,520 --> 00:22:47,360
in 2018 they had an issue because the

00:22:46,720 --> 00:22:50,480
latest

00:22:47,360 --> 00:22:53,840
detector family is providing much

00:22:50,480 --> 00:22:54,799
larger bandwidths than the previous

00:22:53,840 --> 00:22:56,640
generation

00:22:54,799 --> 00:22:58,000
so they were limited to four megapixel

00:22:56,640 --> 00:23:01,039
transfer that won

00:22:58,000 --> 00:23:04,000
about one kilowatts um

00:23:01,039 --> 00:23:06,720
for for every image and this was

00:23:04,000 --> 00:23:10,159
achieved with a nine gigabyte per second

00:23:06,720 --> 00:23:12,480
transfer now using open capi

00:23:10,159 --> 00:23:13,200
in few less than few months in few

00:23:12,480 --> 00:23:14,480
months

00:23:13,200 --> 00:23:16,559
not less than two months but in few

00:23:14,480 --> 00:23:19,600
months they were able to program

00:23:16,559 --> 00:23:20,400
and acquire using the fpga and using the

00:23:19,600 --> 00:23:23,520
cages

00:23:20,400 --> 00:23:27,760
they were able to acquire the the pixels

00:23:23,520 --> 00:23:31,440
at the speed of 4 megapixels

00:23:27,760 --> 00:23:33,840
oh sorry 10 megapixels at 2.2 kilohertz

00:23:31,440 --> 00:23:34,799
so this is the ultimate goal but right

00:23:33,840 --> 00:23:37,440
now for today

00:23:34,799 --> 00:23:38,080
the goal is to multiply by five but very

00:23:37,440 --> 00:23:41,200
quickly

00:23:38,080 --> 00:23:43,600
they were able to make a times two

00:23:41,200 --> 00:23:44,799
uh multiplication of bandwidths and

00:23:43,600 --> 00:23:47,520
please attend

00:23:44,799 --> 00:23:49,760
psi presentation in this uh track i

00:23:47,520 --> 00:23:53,120
think we say opengb track

00:23:49,760 --> 00:23:55,919
so should you have any questions i would

00:23:53,120 --> 00:23:58,159
forward you to one of us either bruno or

00:23:55,919 --> 00:24:01,039
fabrice or myself and we'll be

00:23:58,159 --> 00:24:01,440
very glad to answer your questions we

00:24:01,039 --> 00:24:04,320
have

00:24:01,440 --> 00:24:06,000
i think only one minute for questions so

00:24:04,320 --> 00:24:07,760
please

00:24:06,000 --> 00:24:10,159
do so thank you very much for your

00:24:07,760 --> 00:24:10,159
attention

00:24:15,600 --> 00:24:21,919
so i see many people attending

00:24:19,279 --> 00:24:23,840
and for the moment i don't see any

00:24:21,919 --> 00:24:28,240
questions so please feel free to

00:24:23,840 --> 00:24:30,240
contact us we know i think we are uh

00:24:28,240 --> 00:24:33,840
you can raise your hand if you want to

00:24:30,240 --> 00:24:33,840
ask a question directly

00:24:47,440 --> 00:24:50,799
and i see philip is attending so philipp

00:24:49,360 --> 00:24:52,559
will correct me if i have

00:24:50,799 --> 00:24:54,480
said something wrong in his presentation

00:24:52,559 --> 00:24:56,080
that i would encourage everybody to

00:24:54,480 --> 00:24:57,840
attend please

00:24:56,080 --> 00:25:01,840
it's very impressive the job he has done

00:24:57,840 --> 00:25:01,840
with aussie accent

00:25:03,919 --> 00:25:11,520
all right i see no question

00:25:07,919 --> 00:25:13,039
there is one question i see no question

00:25:11,520 --> 00:25:16,240
at this moment

00:25:13,039 --> 00:25:17,520
okay oh somebody said thank you thank

00:25:16,240 --> 00:25:21,440
you very much

00:25:17,520 --> 00:25:22,960
one question if you can use ocxl with a

00:25:21,440 --> 00:25:25,360
core

00:25:22,960 --> 00:25:28,480
uh could you freestyle um could you

00:25:25,360 --> 00:25:30,880
precise the question can i allow

00:25:28,480 --> 00:25:30,880
likely

00:25:33,919 --> 00:25:37,919
peter if i did not make a mistake you

00:25:36,960 --> 00:25:43,840
are located it's like

00:25:37,919 --> 00:25:43,840
atr can we use ocxl with atria

00:25:45,679 --> 00:25:52,240
so today oc excel is using opencap

00:25:49,360 --> 00:25:55,679
interface all the

00:25:52,240 --> 00:25:58,880
internal design is open source it just

00:25:55,679 --> 00:26:02,799
i would say do a bridge between axi

00:25:58,880 --> 00:26:04,559
and open kp so as soon as you want to

00:26:02,799 --> 00:26:06,159
integrate something which can be

00:26:04,559 --> 00:26:10,960
attached to either of the

00:26:06,159 --> 00:26:15,200
the user interface i guess you you can

00:26:10,960 --> 00:26:18,640
hui there may be some well

00:26:15,200 --> 00:26:25,840
may not be obvious i think today it is

00:26:18,640 --> 00:26:25,840
ocxl is not designed for it

00:26:30,880 --> 00:26:38,720
okay so oc xl today has been

00:26:34,320 --> 00:26:43,200
developed as a master

00:26:38,720 --> 00:26:47,279
part of the design has been modified to

00:26:43,200 --> 00:26:50,559
be also a slave if you listen to

00:26:47,279 --> 00:26:50,559
chris and pentos's

00:26:51,120 --> 00:26:57,919
uh presentation later today

00:26:54,559 --> 00:27:00,480
uh you will be able to see how to uh

00:26:57,919 --> 00:27:02,240
to have a master and slave it's not

00:27:00,480 --> 00:27:05,679
built on ac excel

00:27:02,240 --> 00:27:09,279
but you could do it in a future

00:27:05,679 --> 00:27:13,600
release i will say so today

00:27:09,279 --> 00:27:16,320
ocxl is enabled only as a master

00:27:13,600 --> 00:27:17,279
and not as a slave but it should well

00:27:16,320 --> 00:27:21,840
just matter of

00:27:17,279 --> 00:27:21,840
finishing the design

00:27:37,200 --> 00:27:42,480
okay so feel free to ask any question

00:27:39,360 --> 00:27:42,480
you can find

00:27:42,559 --> 00:27:46,720
you can have feel free to send them in

00:27:44,240 --> 00:28:02,000
the snack we will uh

00:27:46,720 --> 00:28:03,279
try to answer as best as possible

00:28:02,000 --> 00:28:05,440
you have the time of philipp's

00:28:03,279 --> 00:28:07,760
presentation presentation uh

00:28:05,440 --> 00:28:10,480
i it's difficult for me to access my

00:28:07,760 --> 00:28:10,480
other screen

00:28:12,159 --> 00:28:20,799
so we can forward them to

00:28:16,480 --> 00:28:20,799
it is just after this one okay

00:28:21,039 --> 00:28:26,880

YouTube URL: https://www.youtube.com/watch?v=F29RXxy5tWc


