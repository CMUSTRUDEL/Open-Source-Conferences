Title: Microwatt and GHDL - An Open Hardware CPU written in VHDL... - Anton Blanchard & Tristan Gingold
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	Microwatt and GHDL - An Open Hardware CPU written in VHDL, Synthesized with Open Source Tools - Anton Blanchard, IBM & Tristan Gingold, CERN

Speakers: Anton Blanchard, Tristan Gingold

Microwatt is a 64 bit POWER OpenISA soft processor, written in VHDL. Over time it has grown from supporting Micropython, to Zephyr and most recently Linux.

From its original inception, Microwatt has relied heavily on GHDL, the Open Source VHDL simulator. GHDL has very recently added synthesis support and together with Yosys and Nextpnr allows for a completely open source toolchain for FPGAs.

This presentation will give an overview of the Microwatt core. It will also include an overview of GHDL and how it can be used for both simulation and synthesis of a medium complexity VHDL project.
Captions: 
	00:00:00,480 --> 00:00:03,600
good morning good afternoon good night

00:00:02,159 --> 00:00:06,480
i'm coming to you from uh

00:00:03,600 --> 00:00:07,680
sunny sydney uh it's a sunrise and a

00:00:06,480 --> 00:00:09,599
pretty nice morning here

00:00:07,680 --> 00:00:11,200
uh so i'm going to be talking about

00:00:09,599 --> 00:00:12,880
microwatt and tristan's going to be

00:00:11,200 --> 00:00:16,880
talking about ghdl microwatt

00:00:12,880 --> 00:00:20,000
is an open source uh open power

00:00:16,880 --> 00:00:23,199
architecture cpu and ghdl is the

00:00:20,000 --> 00:00:25,439
premier uh open source software for

00:00:23,199 --> 00:00:26,800
simulation and our synthesis of vhdl

00:00:25,439 --> 00:00:28,960
programs

00:00:26,800 --> 00:00:30,480
and so i'll start by setting the scene

00:00:28,960 --> 00:00:31,840
um power's been around forever

00:00:30,480 --> 00:00:34,239
uh it's an architecture that's been

00:00:31,840 --> 00:00:37,040
around for decades uh it's powered

00:00:34,239 --> 00:00:37,760
uh servers and supercomputers and

00:00:37,040 --> 00:00:41,120
embedded

00:00:37,760 --> 00:00:44,239
systems for for those decades uh

00:00:41,120 --> 00:00:44,879
some of our most recent uh things of

00:00:44,239 --> 00:00:47,360
note i guess

00:00:44,879 --> 00:00:49,200
is summit and sierra was number one and

00:00:47,360 --> 00:00:51,120
number two now number two number three

00:00:49,200 --> 00:00:52,559
uh huge supercomputers based on the

00:00:51,120 --> 00:00:54,559
power architecture

00:00:52,559 --> 00:00:55,600
open power has been another effort we

00:00:54,559 --> 00:00:58,559
put together

00:00:55,600 --> 00:00:59,760
where we basically have been opening up

00:00:58,559 --> 00:01:02,480
the architecture

00:00:59,760 --> 00:01:03,680
uh bit by bit uh and if you look at for

00:01:02,480 --> 00:01:05,680
example our

00:01:03,680 --> 00:01:06,880
firmware stack we have a completely open

00:01:05,680 --> 00:01:09,280
source firmware stack

00:01:06,880 --> 00:01:10,000
from power on through to uh booting

00:01:09,280 --> 00:01:11,840
linux and

00:01:10,000 --> 00:01:14,240
ultimately running a hypervisor in that

00:01:11,840 --> 00:01:14,640
kvm all those components there on that

00:01:14,240 --> 00:01:16,560
page

00:01:14,640 --> 00:01:18,240
are open source they're available on

00:01:16,560 --> 00:01:20,159
github and so

00:01:18,240 --> 00:01:21,520
you know that's an area where we've been

00:01:20,159 --> 00:01:24,640
pushing through and opening the

00:01:21,520 --> 00:01:26,080
the software stack one other thing of

00:01:24,640 --> 00:01:26,880
note and i'm sure a number of you know

00:01:26,080 --> 00:01:28,880
about

00:01:26,880 --> 00:01:30,960
the wrap door power 9 workstations

00:01:28,880 --> 00:01:34,079
that's a completely native

00:01:30,960 --> 00:01:37,040
power 9 system and it uses the same

00:01:34,079 --> 00:01:37,040
open source stack

00:01:37,119 --> 00:01:40,079
so the next logical step in that journey

00:01:38,799 --> 00:01:41,600
was to look at what we could do in the

00:01:40,079 --> 00:01:43,200
hardware side of things and so i'm a

00:01:41,600 --> 00:01:45,119
software person

00:01:43,200 --> 00:01:46,479
but you know we've worked with open

00:01:45,119 --> 00:01:48,560
source software for decades

00:01:46,479 --> 00:01:50,240
it's a great way of developing i think

00:01:48,560 --> 00:01:52,320
it's a better way of producing

00:01:50,240 --> 00:01:53,600
you know higher quality products and the

00:01:52,320 --> 00:01:55,360
question was can we look at

00:01:53,600 --> 00:01:56,719
open sourcing and affect the instruction

00:01:55,360 --> 00:01:58,560
set and looking to see

00:01:56,719 --> 00:02:00,159
you know openly open implementations

00:01:58,560 --> 00:02:01,040
other implementations of the power

00:02:00,159 --> 00:02:02,960
architecture

00:02:01,040 --> 00:02:04,719
and so obviously back in august uh we

00:02:02,960 --> 00:02:07,840
did that uh and

00:02:04,719 --> 00:02:09,759
the main sets of points here that

00:02:07,840 --> 00:02:11,520
i'm sure you've probably seen before is

00:02:09,759 --> 00:02:12,319
that the architecture is now open that's

00:02:11,520 --> 00:02:14,959
royalty free

00:02:12,319 --> 00:02:16,239
inclusive patents uh and some other

00:02:14,959 --> 00:02:17,360
logistics around the open power

00:02:16,239 --> 00:02:18,400
foundation moving to the linux

00:02:17,360 --> 00:02:19,760
foundation

00:02:18,400 --> 00:02:21,680
uh one other thing we did and this is

00:02:19,760 --> 00:02:22,720
microwave we reduced we sorry we

00:02:21,680 --> 00:02:25,200
released a

00:02:22,720 --> 00:02:26,640
simple implementation of the uh of a of

00:02:25,200 --> 00:02:28,959
an open power core

00:02:26,640 --> 00:02:31,440
called micro one so what is microwatt

00:02:28,959 --> 00:02:33,599
microwatts just a tiny power core

00:02:31,440 --> 00:02:34,720
it uses what we call the open iso scalar

00:02:33,599 --> 00:02:38,000
subset

00:02:34,720 --> 00:02:39,680
uh it's written in vhdl 2008 uh

00:02:38,000 --> 00:02:42,080
and so uh you know there's there's a

00:02:39,680 --> 00:02:44,000
number of languages that are used today

00:02:42,080 --> 00:02:45,599
uh verilog and the hdl are some of the

00:02:44,000 --> 00:02:49,120
more established ones

00:02:45,599 --> 00:02:50,239
uh on the vhdl side as i said uh we're

00:02:49,120 --> 00:02:52,720
using ghdl

00:02:50,239 --> 00:02:54,560
uh it's really the the best and the only

00:02:52,720 --> 00:02:56,560
open source implementation

00:02:54,560 --> 00:02:58,640
uh for doing synthesis and now sorry

00:02:56,560 --> 00:03:00,080
simulation and now synthesis just as of

00:02:58,640 --> 00:03:02,720
a number of months ago

00:03:00,080 --> 00:03:05,599
uh we're using the uh open source

00:03:02,720 --> 00:03:08,400
synthesis tools of yossis and next pnr

00:03:05,599 --> 00:03:08,959
for synthesis so now it's a completely

00:03:08,400 --> 00:03:11,680
end-to-end

00:03:08,959 --> 00:03:13,200
open source workflow uh to go from

00:03:11,680 --> 00:03:16,400
microwatt all the way through to

00:03:13,200 --> 00:03:17,840
producing an image for your fpga

00:03:16,400 --> 00:03:19,519
uh we're working on github it's

00:03:17,840 --> 00:03:24,159
available there uh

00:03:19,519 --> 00:03:26,400
it's uh some steps here of examples of

00:03:24,159 --> 00:03:27,760
exactly what it is it's very simple it's

00:03:26,400 --> 00:03:29,440
single issue it's in order

00:03:27,760 --> 00:03:30,959
uh the aim is for it to be easy to

00:03:29,440 --> 00:03:32,480
understand so the idea is is that

00:03:30,959 --> 00:03:33,200
perhaps someone in the software realm

00:03:32,480 --> 00:03:35,200
could come in

00:03:33,200 --> 00:03:36,799
have a bit of a look and maybe make a

00:03:35,200 --> 00:03:38,720
you know a small modification

00:03:36,799 --> 00:03:40,000
to the core uh and we've seen that over

00:03:38,720 --> 00:03:41,920
time a number of uh

00:03:40,000 --> 00:03:43,360
my um teammates from around the world

00:03:41,920 --> 00:03:45,599
inside ibm have

00:03:43,360 --> 00:03:46,959
uh added bits along the way we've also

00:03:45,599 --> 00:03:48,480
seen some people appear

00:03:46,959 --> 00:03:50,000
in the community that are the more

00:03:48,480 --> 00:03:50,959
software oriented people and have been

00:03:50,000 --> 00:03:53,280
able to add

00:03:50,959 --> 00:03:54,959
small features and the like so the hope

00:03:53,280 --> 00:03:56,640
is is it remains reasonably easy to

00:03:54,959 --> 00:03:59,200
understand and hackable by

00:03:56,640 --> 00:04:00,000
you know people that really aren't um in

00:03:59,200 --> 00:04:03,120
the in the hardware

00:04:00,000 --> 00:04:05,360
realm uh we do some reuse from the

00:04:03,120 --> 00:04:07,920
open hardware world uh one of the big

00:04:05,360 --> 00:04:10,400
areas is is dram and ethernet where we

00:04:07,920 --> 00:04:11,280
bring in um components from the lidex

00:04:10,400 --> 00:04:13,200
project so

00:04:11,280 --> 00:04:15,280
you know the idea of open source and and

00:04:13,200 --> 00:04:18,079
software development is to reuse

00:04:15,280 --> 00:04:18,720
reuse reuse uh and that was our idea

00:04:18,079 --> 00:04:20,560
here was

00:04:18,720 --> 00:04:22,479
you know we don't want to have to double

00:04:20,560 --> 00:04:23,600
up and implement ethernet and dram

00:04:22,479 --> 00:04:24,880
controllers

00:04:23,600 --> 00:04:27,120
so we'll talk a bit more about that

00:04:24,880 --> 00:04:28,560
later on the right is the pipeline it's

00:04:27,120 --> 00:04:29,919
a fairly standard pipeline where we have

00:04:28,560 --> 00:04:32,880
a number of stages

00:04:29,919 --> 00:04:34,479
uh through fetch decode and then execute

00:04:32,880 --> 00:04:37,440
them right back so it's a pretty

00:04:34,479 --> 00:04:39,520
a pretty simple um relatively you know

00:04:37,440 --> 00:04:43,759
easy to understand call

00:04:39,520 --> 00:04:45,759
here we can see the project on github

00:04:43,759 --> 00:04:47,680
so it's uh it's all done in the github

00:04:45,759 --> 00:04:49,440
workflow you can go on you can pull it

00:04:47,680 --> 00:04:52,639
you can build it

00:04:49,440 --> 00:04:54,720
you can raise issues you can

00:04:52,639 --> 00:04:56,720
fix issues you can raise pull requests

00:04:54,720 --> 00:04:58,160
all that kind of stuff

00:04:56,720 --> 00:05:00,560
and so there's a you know nice little

00:04:58,160 --> 00:05:02,560
community around that

00:05:00,560 --> 00:05:04,560
language support so uh you know the

00:05:02,560 --> 00:05:06,240
first thing we we realized is we were

00:05:04,560 --> 00:05:08,000
able to leverage the strength of

00:05:06,240 --> 00:05:10,320
the powerpc ecosystem you know a lot of

00:05:08,000 --> 00:05:12,080
stuff worked i'm using a district tool

00:05:10,320 --> 00:05:13,919
chain for my development work

00:05:12,080 --> 00:05:15,360
and we've been adding key languages

00:05:13,919 --> 00:05:16,479
along the way and there's a number of

00:05:15,360 --> 00:05:18,240
people there

00:05:16,479 --> 00:05:19,600
mikey jordan tom and paul that have

00:05:18,240 --> 00:05:21,199
helped along the way

00:05:19,600 --> 00:05:22,800
uh so what works the first thing we

00:05:21,199 --> 00:05:25,120
tried was micropythons i don't know if

00:05:22,800 --> 00:05:27,039
people have looked at micropython before

00:05:25,120 --> 00:05:28,880
but it's a really simple implementation

00:05:27,039 --> 00:05:30,720
of python and um

00:05:28,880 --> 00:05:32,080
really quite powerful um you know it

00:05:30,720 --> 00:05:33,440
runs on a whole bunch of different

00:05:32,080 --> 00:05:36,960
microcontrollers

00:05:33,440 --> 00:05:39,280
from you know tiny tiny little ones

00:05:36,960 --> 00:05:41,120
you know and up and it was a relatively

00:05:39,280 --> 00:05:42,479
easy port so we were able to take that

00:05:41,120 --> 00:05:44,000
and that was uh you know the first

00:05:42,479 --> 00:05:46,080
interesting workload outside of say

00:05:44,000 --> 00:05:48,320
hello world that ran on microwave

00:05:46,080 --> 00:05:49,520
uh zephyr was another one we did a port

00:05:48,320 --> 00:05:51,440
of zephyr

00:05:49,520 --> 00:05:52,800
uh and it was relatively easy it's a

00:05:51,440 --> 00:05:55,840
it's a really nice uh

00:05:52,800 --> 00:05:58,400
iot os coming from a linux background

00:05:55,840 --> 00:05:59,759
it feels a lot like linux in in maybe

00:05:58,400 --> 00:06:01,120
the way it's laid out and the

00:05:59,759 --> 00:06:01,759
development process all that kind of

00:06:01,120 --> 00:06:04,400
stuff

00:06:01,759 --> 00:06:06,560
uh and yeah again quite powerful um and

00:06:04,400 --> 00:06:08,639
real simple and and real tiny can be

00:06:06,560 --> 00:06:10,319
configured down to tiny amounts so

00:06:08,639 --> 00:06:12,240
this is an interesting space in the

00:06:10,319 --> 00:06:14,319
embedded world and again was a

00:06:12,240 --> 00:06:16,639
relatively easy port for us

00:06:14,319 --> 00:06:18,479
uh we had a community member tom come up

00:06:16,639 --> 00:06:19,039
uh and basically raise a pull request

00:06:18,479 --> 00:06:20,720
and and

00:06:19,039 --> 00:06:22,080
you know he's uh he's all we need for

00:06:20,720 --> 00:06:22,639
russ support and it was interesting in

00:06:22,080 --> 00:06:24,639
that

00:06:22,639 --> 00:06:26,000
it it required you know a couple of new

00:06:24,639 --> 00:06:28,319
instructions uh we

00:06:26,000 --> 00:06:29,120
hadn't quite got to full compliance yet

00:06:28,319 --> 00:06:31,199
and so he

00:06:29,120 --> 00:06:32,720
added the instructions we needed and he

00:06:31,199 --> 00:06:34,639
also added

00:06:32,720 --> 00:06:36,400
uh the you know the the infrastructure

00:06:34,639 --> 00:06:38,160
the the harness so that we can build

00:06:36,400 --> 00:06:40,319
embedded rust and so

00:06:38,160 --> 00:06:41,520
uh rust is an interesting language it's

00:06:40,319 --> 00:06:43,759
really up and coming

00:06:41,520 --> 00:06:45,360
uh it it's especially interesting in the

00:06:43,759 --> 00:06:47,520
systems programming world

00:06:45,360 --> 00:06:48,800
uh and uh you know we were quite happy

00:06:47,520 --> 00:06:51,199
to see that uh

00:06:48,800 --> 00:06:53,199
to see that come on board uh we took a

00:06:51,199 --> 00:06:54,880
bit of a walk on the wild side one of

00:06:53,199 --> 00:06:57,759
our people decided to port forth

00:06:54,880 --> 00:06:58,560
uh yeah okay i mean that was interesting

00:06:57,759 --> 00:07:01,599
i was again

00:06:58,560 --> 00:07:03,280
a relatively easy port jordan jordan did

00:07:01,599 --> 00:07:05,520
it it was pretty cool to see it

00:07:03,280 --> 00:07:06,639
uh it's not for me but maybe it's for

00:07:05,520 --> 00:07:10,479
someone else

00:07:06,639 --> 00:07:12,160
and finally linux so paul mcharris uh

00:07:10,479 --> 00:07:13,759
someone on our team in canberra did a

00:07:12,160 --> 00:07:14,240
fantastic job and basically did a bunch

00:07:13,759 --> 00:07:16,319
of work

00:07:14,240 --> 00:07:17,599
on both the linux side as well as the

00:07:16,319 --> 00:07:19,840
microwatt side

00:07:17,599 --> 00:07:21,360
to basically get all of the

00:07:19,840 --> 00:07:22,319
functionality we need to get linux

00:07:21,360 --> 00:07:23,599
running

00:07:22,319 --> 00:07:24,880
and what's that functionality well

00:07:23,599 --> 00:07:26,160
there's there's quite a lot you know we

00:07:24,880 --> 00:07:28,000
we took it from a

00:07:26,160 --> 00:07:29,840
core that ran micro python or paul took

00:07:28,000 --> 00:07:32,880
it from a core that ran

00:07:29,840 --> 00:07:34,880
and had to add all of the the

00:07:32,880 --> 00:07:36,240
the gorp that you have to to run a you

00:07:34,880 --> 00:07:38,880
know full operating system

00:07:36,240 --> 00:07:39,520
translation exceptions all these kind of

00:07:38,880 --> 00:07:41,440
things

00:07:39,520 --> 00:07:42,960
quite a lot of work uh huge effort and

00:07:41,440 --> 00:07:45,440
you know it's fantastic to see that go

00:07:42,960 --> 00:07:46,720
in and so now um you know microwatt runs

00:07:45,440 --> 00:07:49,599
linux

00:07:46,720 --> 00:07:50,560
um our resource consumption over time so

00:07:49,599 --> 00:07:52,639
these are

00:07:50,560 --> 00:07:54,479
these are luts lookup tables it's kind

00:07:52,639 --> 00:07:54,879
of a measure of resource utilization

00:07:54,479 --> 00:07:57,599
from

00:07:54,879 --> 00:07:58,240
an fpga uh you know the idea is is is

00:07:57,599 --> 00:08:00,560
the more

00:07:58,240 --> 00:08:02,000
uh let's you consume the more recent

00:08:00,560 --> 00:08:03,840
resources you'll consume

00:08:02,000 --> 00:08:05,599
and potentially the bigger fpgas more

00:08:03,840 --> 00:08:07,599
expensive fpgas you might need

00:08:05,599 --> 00:08:08,639
uh it also results in slower build times

00:08:07,599 --> 00:08:10,400
as well uh

00:08:08,639 --> 00:08:12,879
so as we went out the door it was

00:08:10,400 --> 00:08:16,160
horrendously uh

00:08:12,879 --> 00:08:18,000
overweight uh and we we cut it down uh

00:08:16,160 --> 00:08:19,680
and paul and mikey and a number of

00:08:18,000 --> 00:08:21,599
people worked on cutting it down

00:08:19,680 --> 00:08:22,639
uh the interesting thing was i guess you

00:08:21,599 --> 00:08:23,680
know a number of people looked at the

00:08:22,639 --> 00:08:25,039
code and said

00:08:23,680 --> 00:08:26,800
you know it looks like a software person

00:08:25,039 --> 00:08:27,440
wrote this and yes the software person

00:08:26,800 --> 00:08:29,440
did write

00:08:27,440 --> 00:08:30,560
write it originally i did most of the

00:08:29,440 --> 00:08:32,560
work uh but

00:08:30,560 --> 00:08:33,760
quickly as we realized you know more

00:08:32,560 --> 00:08:36,320
about how we should

00:08:33,760 --> 00:08:37,919
uh structure hardware we pretty quickly

00:08:36,320 --> 00:08:40,320
uh realized you know we had to

00:08:37,919 --> 00:08:41,680
do a few things and we got to cut down

00:08:40,320 --> 00:08:43,039
we took a bump there on the right and

00:08:41,680 --> 00:08:45,040
that's i think adding uh

00:08:43,039 --> 00:08:46,399
linux support and and a lot of the extra

00:08:45,040 --> 00:08:47,680
functionality we need to run all that

00:08:46,399 --> 00:08:50,000
kind of stuff

00:08:47,680 --> 00:08:50,720
uh so it is i mean it is it is still

00:08:50,000 --> 00:08:53,279
quite small

00:08:50,720 --> 00:08:56,080
it's not huge um and it fits on

00:08:53,279 --> 00:08:58,160
relatively small fpgas

00:08:56,080 --> 00:08:59,600
some recent developments uh ben herring

00:08:58,160 --> 00:09:01,279
schmidt did a bunch of work here around

00:08:59,600 --> 00:09:03,519
getting lidex integrated

00:09:01,279 --> 00:09:04,880
as well as florent uh and that's been

00:09:03,519 --> 00:09:06,959
really good because we pick up you know

00:09:04,880 --> 00:09:08,240
enormous functionality for for little to

00:09:06,959 --> 00:09:10,560
no work uh

00:09:08,240 --> 00:09:11,360
dram support ethernet support all that

00:09:10,560 --> 00:09:14,160
kind of stuff

00:09:11,360 --> 00:09:16,000
uh it comes basically because we have a

00:09:14,160 --> 00:09:18,720
standard bus that we connect to

00:09:16,000 --> 00:09:20,560
you know a standard interface uh i cache

00:09:18,720 --> 00:09:23,200
and dks been added as well we've had

00:09:20,560 --> 00:09:25,360
branch predictors from paul mccarus

00:09:23,200 --> 00:09:26,240
interrupts and exceptions come from

00:09:25,360 --> 00:09:28,800
mikey and

00:09:26,240 --> 00:09:29,279
ben a tlb and that's a translation look

00:09:28,800 --> 00:09:32,240
up

00:09:29,279 --> 00:09:33,680
buffer that's for the mmu for transl

00:09:32,240 --> 00:09:34,480
being able to translate addresses that

00:09:33,680 --> 00:09:36,240
linux needs

00:09:34,480 --> 00:09:38,240
and that was paul and then ultimately we

00:09:36,240 --> 00:09:39,680
got linux going thanks to paul

00:09:38,240 --> 00:09:41,760
uh one other interesting thing we've got

00:09:39,680 --> 00:09:42,800
is we've got a ci around it so we want

00:09:41,760 --> 00:09:45,279
to know when we break it

00:09:42,800 --> 00:09:46,560
and what we've done and quickly work out

00:09:45,279 --> 00:09:49,680
what we need to fix

00:09:46,560 --> 00:09:50,000
and mikey added that too and this is out

00:09:49,680 --> 00:09:52,959
of date

00:09:50,000 --> 00:09:54,160
we've we've bypassed uh 215 but uh about

00:09:52,959 --> 00:09:57,680
a month ago we were at

00:09:54,160 --> 00:09:58,080
you know 215 commits so it's it's moving

00:09:57,680 --> 00:10:00,640
along

00:09:58,080 --> 00:10:01,440
at a decent clip i mentioned before we

00:10:00,640 --> 00:10:03,920
have a ci

00:10:01,440 --> 00:10:05,040
and this has been really useful every

00:10:03,920 --> 00:10:06,640
pull request

00:10:05,040 --> 00:10:08,720
that goes in goes through a number of

00:10:06,640 --> 00:10:09,519
tests just to see if the call remains

00:10:08,720 --> 00:10:10,880
functional

00:10:09,519 --> 00:10:12,959
that allows us to make sure that we're

00:10:10,880 --> 00:10:14,240
not breaking things uh this is you know

00:10:12,959 --> 00:10:15,360
something from the obviously from the

00:10:14,240 --> 00:10:16,320
software world that we use pretty

00:10:15,360 --> 00:10:18,079
heavily

00:10:16,320 --> 00:10:20,800
and is you know just as useful in the

00:10:18,079 --> 00:10:22,720
hardware world

00:10:20,800 --> 00:10:24,079
i talked a bit about hardware reuse and

00:10:22,720 --> 00:10:26,160
that's been a big thing

00:10:24,079 --> 00:10:28,800
you know we've we've been pushing for we

00:10:26,160 --> 00:10:29,360
use the wishbone bus which is a standard

00:10:28,800 --> 00:10:32,160
open

00:10:29,360 --> 00:10:33,920
hardware bus it's simple it's open and

00:10:32,160 --> 00:10:34,160
it's widely used and the advantage there

00:10:33,920 --> 00:10:36,000
is

00:10:34,160 --> 00:10:37,600
that now we can take other components in

00:10:36,000 --> 00:10:40,560
the open hardware world

00:10:37,600 --> 00:10:41,200
and plug them together so uh one big

00:10:40,560 --> 00:10:43,440
area we

00:10:41,200 --> 00:10:45,200
uh interacted with was the lydex project

00:10:43,440 --> 00:10:46,240
and ben and florent have been fantastic

00:10:45,200 --> 00:10:47,839
on this front

00:10:46,240 --> 00:10:49,839
and we can pick up reasonably really

00:10:47,839 --> 00:10:52,079
complicated macros like drams and

00:10:49,839 --> 00:10:56,720
ethernets and they basically plug on the

00:10:52,079 --> 00:10:58,240
uh the um the um sorry the wishbone bus

00:10:56,720 --> 00:10:59,920
and you know we get all of that

00:10:58,240 --> 00:11:01,279
functionality without having to recode

00:10:59,920 --> 00:11:05,120
it ourselves

00:11:01,279 --> 00:11:05,120
and there's more to come in that space

00:11:06,160 --> 00:11:09,200
so that's the core itself let's talk

00:11:07,920 --> 00:11:10,160
about how you simulate and you

00:11:09,200 --> 00:11:12,160
synthesize

00:11:10,160 --> 00:11:13,440
and so there's two core things we have

00:11:12,160 --> 00:11:14,000
to do when we're building something for

00:11:13,440 --> 00:11:15,519
an fpga

00:11:14,000 --> 00:11:17,600
we have to simulate it does it work and

00:11:15,519 --> 00:11:19,519
we do that in a software simulation

00:11:17,600 --> 00:11:21,519
and ultimately does it synthesize can we

00:11:19,519 --> 00:11:25,040
build an image that goes on the fpga

00:11:21,519 --> 00:11:25,760
and runs simulation is done using ghdl

00:11:25,040 --> 00:11:27,440
which tristan

00:11:25,760 --> 00:11:29,519
is going to talk a bit about is the

00:11:27,440 --> 00:11:30,320
maintainer for it's fantastic for

00:11:29,519 --> 00:11:33,600
testing

00:11:30,320 --> 00:11:35,120
including cio it has i would say better

00:11:33,600 --> 00:11:37,360
language support than

00:11:35,120 --> 00:11:39,200
many of the vendor tools uh including

00:11:37,360 --> 00:11:40,959
vhdl 2008

00:11:39,200 --> 00:11:42,640
and you know i will say it's very

00:11:40,959 --> 00:11:44,320
responsive we've we've found bugs along

00:11:42,640 --> 00:11:45,680
the way and and he's you know been very

00:11:44,320 --> 00:11:48,079
quick to fix them so

00:11:45,680 --> 00:11:51,040
as far as uh simulation environments go

00:11:48,079 --> 00:11:53,200
ghdl is is pretty pretty great

00:11:51,040 --> 00:11:54,480
uh it's also added synthesis support

00:11:53,200 --> 00:11:56,240
recently so

00:11:54,480 --> 00:11:57,920
uh you know we we originally were using

00:11:56,240 --> 00:11:59,760
ghdl for simulation but then we'd have

00:11:57,920 --> 00:12:00,320
to go off to a vendor proprietary tool

00:11:59,760 --> 00:12:02,880
for

00:12:00,320 --> 00:12:04,079
synthesis and the vendor tools are you

00:12:02,880 --> 00:12:06,959
know swings and roundabouts

00:12:04,079 --> 00:12:07,760
there's some good parts some bad parts

00:12:06,959 --> 00:12:09,519
uh you know

00:12:07,760 --> 00:12:11,360
it's it's difficult to automate in a in

00:12:09,519 --> 00:12:13,200
a ci environment because you are

00:12:11,360 --> 00:12:15,760
licensed all that kind of stuff so

00:12:13,200 --> 00:12:16,720
there's a lot of problems with using

00:12:15,760 --> 00:12:19,120
vendor tools

00:12:16,720 --> 00:12:21,200
especially in an open source project

00:12:19,120 --> 00:12:23,279
ghdl recently added a completely open

00:12:21,200 --> 00:12:24,240
source flow now for fpga synthesis so

00:12:23,279 --> 00:12:26,560
you can go from

00:12:24,240 --> 00:12:28,000
the vhdl right through an image that'll

00:12:26,560 --> 00:12:29,200
you know that'll build and run on for

00:12:28,000 --> 00:12:32,720
example your lattice

00:12:29,200 --> 00:12:33,839
fpga and so that's been fantastic one

00:12:32,720 --> 00:12:35,920
other thing i'll point out it

00:12:33,839 --> 00:12:37,680
also allows which we haven't really had

00:12:35,920 --> 00:12:39,920
a good option of

00:12:37,680 --> 00:12:40,720
but being able to convert vhdl to

00:12:39,920 --> 00:12:42,800
verilog

00:12:40,720 --> 00:12:43,920
and that goes through yoses so it allows

00:12:42,800 --> 00:12:45,600
you to do mixed

00:12:43,920 --> 00:12:46,800
language simulation and synthesis all

00:12:45,600 --> 00:12:48,639
this kind of stuff that we haven't

00:12:46,800 --> 00:12:49,839
really had in the open hardware world so

00:12:48,639 --> 00:12:52,560
that's been another

00:12:49,839 --> 00:12:53,120
great development uh so one thing i will

00:12:52,560 --> 00:12:56,399
point out

00:12:53,120 --> 00:12:58,720
uh is that um as you get into this

00:12:56,399 --> 00:13:00,560
you start to accrue fpgas i started with

00:12:58,720 --> 00:13:02,720
the arty and then someone gave me

00:13:00,560 --> 00:13:03,760
one of these little um lattice boards

00:13:02,720 --> 00:13:06,959
and then i picked up

00:13:03,760 --> 00:13:08,480
i think a tiny fpga and and then someone

00:13:06,959 --> 00:13:10,320
at another conference said here's a few

00:13:08,480 --> 00:13:12,399
tomahs uh

00:13:10,320 --> 00:13:14,959
and then i picked up another silence

00:13:12,399 --> 00:13:18,240
fpga and then another

00:13:14,959 --> 00:13:19,839
fpga and uh and this little orange crab

00:13:18,240 --> 00:13:20,720
which is a fantastic little one done by

00:13:19,839 --> 00:13:22,800
a maker

00:13:20,720 --> 00:13:24,320
uh it goes on and on and on so we'll

00:13:22,800 --> 00:13:25,839
warn you that you know it's pretty

00:13:24,320 --> 00:13:26,959
addictive and you will pick up but my

00:13:25,839 --> 00:13:30,240
desk here is full of

00:13:26,959 --> 00:13:31,279
fpgas i can't really even have space to

00:13:30,240 --> 00:13:33,360
put my cup down

00:13:31,279 --> 00:13:34,399
but it's a lot of fun uh and and so you

00:13:33,360 --> 00:13:36,079
know if you

00:13:34,399 --> 00:13:38,000
aren't involved in harbor or haven't

00:13:36,079 --> 00:13:38,639
before um you know and you're a software

00:13:38,000 --> 00:13:40,000
person

00:13:38,639 --> 00:13:41,279
encourage you to go out have a bit of a

00:13:40,000 --> 00:13:43,120
play with some of these things there's a

00:13:41,279 --> 00:13:46,399
lot happening in the open hardware world

00:13:43,120 --> 00:13:47,360
a lot of uh you know interesting things

00:13:46,399 --> 00:13:48,800
going on

00:13:47,360 --> 00:13:51,040
and you know i'd encourage you all to

00:13:48,800 --> 00:13:54,399
play and so with that i'll

00:13:51,040 --> 00:13:59,120
um hand over to tristan

00:13:54,399 --> 00:13:59,120
hello good morning or good afternoon

00:14:00,839 --> 00:14:03,839
uh

00:14:08,480 --> 00:14:18,560
so my talk is about jhdl and how it

00:14:12,480 --> 00:14:18,560
fits into the inside the ada ecosystem

00:14:18,720 --> 00:14:22,399
and in particular about the free and

00:14:20,480 --> 00:14:25,040
open source software

00:14:22,399 --> 00:14:28,000
eda so eda is about electronic design

00:14:25,040 --> 00:14:30,959
automation which is

00:14:28,000 --> 00:14:32,880
all the tool set that are used to do

00:14:30,959 --> 00:14:35,920
electronic design

00:14:32,880 --> 00:14:37,839
uh and it's in fact a very vast

00:14:35,920 --> 00:14:39,199
domain maybe unknown by software

00:14:37,839 --> 00:14:43,360
developer but

00:14:39,199 --> 00:14:46,399
it's invest okay i can speed

00:14:43,360 --> 00:14:50,000
almost artificially into two points one

00:14:46,399 --> 00:14:53,680
about electronics so doing

00:14:50,000 --> 00:14:57,440
board pcbs designing a

00:14:53,680 --> 00:15:00,720
new card and the main

00:14:57,440 --> 00:15:04,399
tools many consoles tools are keycard

00:15:00,720 --> 00:15:04,399
and it would say pcb

00:15:05,440 --> 00:15:12,240
or the the other branch is about

00:15:08,639 --> 00:15:15,760
micro electronics so how to create

00:15:12,240 --> 00:15:19,680
integrated circuits or chips

00:15:15,760 --> 00:15:23,120
and you need many many tools

00:15:19,680 --> 00:15:26,270
to do that sanitizer

00:15:23,120 --> 00:15:29,279
we need similar we need

00:15:26,270 --> 00:15:33,279
[Music]

00:15:29,279 --> 00:15:36,160
and also you need pdk

00:15:33,279 --> 00:15:38,639
and between these two branch there are

00:15:36,160 --> 00:15:43,199
also tools

00:15:38,639 --> 00:15:46,639
for analog simulation and they are used

00:15:43,199 --> 00:15:47,839
either for while doing pcbs particularly

00:15:46,639 --> 00:15:50,959
if you do

00:15:47,839 --> 00:15:54,959
if you use high frequency signals and

00:15:50,959 --> 00:15:55,920
also while you design the integrated

00:15:54,959 --> 00:15:59,360
circuit

00:15:55,920 --> 00:16:03,120
if you design an analog

00:15:59,360 --> 00:16:04,240
circuit or a part of a part of a digital

00:16:03,120 --> 00:16:08,800
circuit

00:16:04,240 --> 00:16:11,360
and also they are also used to

00:16:08,800 --> 00:16:11,360
for very

00:16:12,000 --> 00:16:16,000
advanced process that have a lot of

00:16:14,880 --> 00:16:20,480
noise and

00:16:16,000 --> 00:16:20,480
weird behaviors that need

00:16:20,959 --> 00:16:26,160
tools to be investigated

00:16:27,440 --> 00:16:30,639
and i will most of mostly talk about

00:16:29,279 --> 00:16:33,920
integrated circuits

00:16:30,639 --> 00:16:38,320
in this plantation so

00:16:33,920 --> 00:16:38,320
what is integrated circuit well for

00:16:38,480 --> 00:16:44,800
high view we can say it's a set

00:16:41,680 --> 00:16:46,639
of gates okay gate which

00:16:44,800 --> 00:16:48,320
do some computation so there are

00:16:46,639 --> 00:16:51,519
elementary gates like

00:16:48,320 --> 00:16:52,959
nor and not and if you combine them

00:16:51,519 --> 00:16:56,160
together you can create

00:16:52,959 --> 00:17:00,079
additional or subtractor or

00:16:56,160 --> 00:17:04,480
multipliers or similar advanced

00:17:00,079 --> 00:17:07,679
computation and in addition to gates

00:17:04,480 --> 00:17:10,079
to logic gates you also have a

00:17:07,679 --> 00:17:10,720
memorizing element like flip flop and

00:17:10,079 --> 00:17:13,369
large

00:17:10,720 --> 00:17:15,120
or memories that are used to

00:17:13,369 --> 00:17:18,480
[Music]

00:17:15,120 --> 00:17:22,640
keep a result available for

00:17:18,480 --> 00:17:26,959
a longer time and all these gates and

00:17:22,640 --> 00:17:31,360
memories are created through with wires

00:17:26,959 --> 00:17:36,880
in addition to this digital element

00:17:31,360 --> 00:17:40,160
you almost always have analog components

00:17:36,880 --> 00:17:42,320
like parts which are allows to connect

00:17:40,160 --> 00:17:43,360
part of the circuit to the external

00:17:42,320 --> 00:17:46,320
world

00:17:43,360 --> 00:17:47,200
pll which are used to do high frequency

00:17:46,320 --> 00:17:50,000
clock

00:17:47,200 --> 00:17:52,480
and a lot of component to do power

00:17:50,000 --> 00:17:52,480
management

00:17:52,720 --> 00:17:56,320
and at some point the connection between

00:17:55,440 --> 00:18:01,840
these gates

00:17:56,320 --> 00:18:01,840
and wires are what we called in at least

00:18:02,170 --> 00:18:07,520
[Music]

00:18:04,000 --> 00:18:11,039
so how do we design integrative circuit

00:18:07,520 --> 00:18:15,039
initially you had to draw the mask

00:18:11,039 --> 00:18:15,039
manually and your they

00:18:15,200 --> 00:18:19,760
snoring was used to directly create a

00:18:18,080 --> 00:18:23,039
circuit

00:18:19,760 --> 00:18:26,320
uh okay it was due until the

00:18:23,039 --> 00:18:29,840
end of the seven days but

00:18:26,320 --> 00:18:29,840
obviously it doesn't scale

00:18:30,320 --> 00:18:38,960
because the number of transistors

00:18:34,400 --> 00:18:42,240
is now huge and it's very difficult to

00:18:38,960 --> 00:18:45,919
pack them together

00:18:42,240 --> 00:18:48,559
but we can still use uh hand drawing for

00:18:45,919 --> 00:18:49,919
some uh by force basically for the basic

00:18:48,559 --> 00:18:53,760
element

00:18:49,919 --> 00:18:57,120
and also for analog element

00:18:53,760 --> 00:18:58,240
and also sometimes for the global

00:18:57,120 --> 00:19:01,840
architecture

00:18:58,240 --> 00:19:04,960
but most of the design now are

00:19:01,840 --> 00:19:06,880
created using language right space a

00:19:04,960 --> 00:19:10,000
special branch of language which are

00:19:06,880 --> 00:19:12,559
called hardware description language hdl

00:19:10,000 --> 00:19:12,559
and the

00:19:14,720 --> 00:19:19,520
two the most too well known or widely

00:19:18,080 --> 00:19:25,039
used are battery log

00:19:19,520 --> 00:19:29,120
and now the system reload and vhdl

00:19:25,039 --> 00:19:31,840
so how do you design a circuit right

00:19:29,120 --> 00:19:32,799
i present a very very simplified flow so

00:19:31,840 --> 00:19:36,559
first

00:19:32,799 --> 00:19:39,760
once you have defined the sector you

00:19:36,559 --> 00:19:44,640
start to i would say code or design

00:19:39,760 --> 00:19:46,720
using hdl and you want to check the

00:19:44,640 --> 00:19:49,280
design before correcting the circuit

00:19:46,720 --> 00:19:52,000
because the question of a

00:19:49,280 --> 00:19:54,160
circuit is very expensive or very slow

00:19:52,000 --> 00:19:56,320
so you do simulation which allows you to

00:19:54,160 --> 00:19:59,520
check that the behavior is correct

00:19:56,320 --> 00:20:00,080
and also to debug the circuit if you

00:19:59,520 --> 00:20:02,400
have a

00:20:00,080 --> 00:20:04,320
problem and once your design is not too

00:20:02,400 --> 00:20:05,679
big is known to be correct you do a

00:20:04,320 --> 00:20:08,799
synthesis

00:20:05,679 --> 00:20:12,480
and at that point you create a net list

00:20:08,799 --> 00:20:15,280
which is often a generated list that you

00:20:12,480 --> 00:20:17,360
slightly adapt to your target using a

00:20:15,280 --> 00:20:19,039
map or two

00:20:17,360 --> 00:20:20,960
and once you have a space target

00:20:19,039 --> 00:20:24,960
specific at least you used to

00:20:20,960 --> 00:20:26,559
like placer router to do the

00:20:24,960 --> 00:20:29,039
final implementation the physical

00:20:26,559 --> 00:20:30,080
implementation and often you have to do

00:20:29,039 --> 00:20:32,000
is also

00:20:30,080 --> 00:20:34,400
to use also some tools to check the

00:20:32,000 --> 00:20:37,039
timing or to check the

00:20:34,400 --> 00:20:37,039
design rules

00:20:38,400 --> 00:20:45,200
okay we also artificially

00:20:41,679 --> 00:20:48,960
split ics into two branches so

00:20:45,200 --> 00:20:52,159
you have either the on one hand

00:20:48,960 --> 00:20:53,919
the asic which is application specific

00:20:52,159 --> 00:20:55,280
temperature which is let's say a rear

00:20:53,919 --> 00:20:58,640
circuit

00:20:55,280 --> 00:20:58,960
and at the other hand what we call fpga

00:20:58,640 --> 00:21:03,360
which

00:20:58,960 --> 00:21:06,799
are a circuit

00:21:03,360 --> 00:21:10,640
which can be programmed so you have in

00:21:06,799 --> 00:21:14,159
fpga you have a very generic behavior

00:21:10,640 --> 00:21:18,400
that you can change to fit what you

00:21:14,159 --> 00:21:20,480
what you want to do so there are

00:21:18,400 --> 00:21:22,320
what is shown there are cib which are

00:21:20,480 --> 00:21:26,080
the compute element

00:21:22,320 --> 00:21:26,080
and all the routing and

00:21:26,159 --> 00:21:32,080
switchbox to interconnect

00:21:29,440 --> 00:21:34,400
the computation element together and

00:21:32,080 --> 00:21:37,919
with the io so basically

00:21:34,400 --> 00:21:40,640
the routing represents the wires

00:21:37,919 --> 00:21:41,919
and the computation elements represent

00:21:40,640 --> 00:21:44,000
the gates

00:21:41,919 --> 00:21:45,600
so the main advantage of pga that you

00:21:44,000 --> 00:21:48,640
can program them

00:21:45,600 --> 00:21:50,960
uh many many times so you

00:21:48,640 --> 00:21:51,919
if you create you don't need you know

00:21:50,960 --> 00:21:54,159
and it's

00:21:51,919 --> 00:21:56,559
quite fast you don't need to do a

00:21:54,159 --> 00:22:00,400
circuit each time you want to change it

00:21:56,559 --> 00:22:00,400
as a drawback it's

00:22:01,039 --> 00:22:09,919
much much slower it needs much more

00:22:06,159 --> 00:22:13,039
energy to run and it might be

00:22:09,919 --> 00:22:13,840
much more expensive if you have a large

00:22:13,039 --> 00:22:18,080
number of

00:22:13,840 --> 00:22:18,080
circuit to to beat

00:22:18,720 --> 00:22:23,120
so when you use free and open source

00:22:24,840 --> 00:22:31,360
software

00:22:27,520 --> 00:22:34,480
these are the main

00:22:31,360 --> 00:22:36,799
actors in this world

00:22:34,480 --> 00:22:37,919
so if you look at the standard language

00:22:36,799 --> 00:22:40,799
at very log

00:22:37,919 --> 00:22:41,600
and vhdl so for very log you have the

00:22:40,799 --> 00:22:45,039
relator

00:22:41,600 --> 00:22:48,240
and icarus very low to handle and

00:22:45,039 --> 00:22:50,559
simulate uh reload so very later

00:22:48,240 --> 00:22:53,440
is a very fast but hundreds only a

00:22:50,559 --> 00:22:56,640
subset of a relay system reload

00:22:53,440 --> 00:22:58,559
encouragement is much lower but it

00:22:56,640 --> 00:23:01,760
handles

00:22:58,559 --> 00:23:05,039
i would say it targets holds

00:23:01,760 --> 00:23:07,360
the word language on today's daily part

00:23:05,039 --> 00:23:10,799
you have ghdh so the truth i have

00:23:07,360 --> 00:23:15,120
written and there's also

00:23:10,799 --> 00:23:15,120
other actors like ncb

00:23:15,280 --> 00:23:22,640
one way to what one output

00:23:18,880 --> 00:23:24,960
of simulation in the waveforms

00:23:22,640 --> 00:23:28,640
you can try to which is used to

00:23:24,960 --> 00:23:28,640
understand how your circuits uh

00:23:28,960 --> 00:23:35,850
or your circuit works and the menu

00:23:32,000 --> 00:23:38,940
is gtk wave and

00:23:35,850 --> 00:23:38,940
[Music]

00:23:39,280 --> 00:23:43,679
software designer also like to create

00:23:41,760 --> 00:23:44,400
new language because it's much easier

00:23:43,679 --> 00:23:48,159
when it's

00:23:44,400 --> 00:23:50,880
open source and here is a list of

00:23:48,159 --> 00:23:52,640
recent creative language like schreizer

00:23:50,880 --> 00:23:56,240
spinach hdl clash

00:23:52,640 --> 00:23:59,200
hdl which are often based on an existing

00:23:56,240 --> 00:23:59,919
language and most of the time they

00:23:59,200 --> 00:24:02,559
translate

00:23:59,919 --> 00:24:04,400
their input to a standalone grid like

00:24:02,559 --> 00:24:07,919
very love local phdl

00:24:04,400 --> 00:24:11,279
which can be used by synthetizers

00:24:07,919 --> 00:24:13,520
and to his simulation you have

00:24:11,279 --> 00:24:15,840
several verification framework like coco

00:24:13,520 --> 00:24:18,960
tv uvm uvm

00:24:15,840 --> 00:24:21,440
unit okay

00:24:18,960 --> 00:24:22,000
it's just meant to just allow you to

00:24:21,440 --> 00:24:25,520
create

00:24:22,000 --> 00:24:29,919
a large and quickly uh

00:24:25,520 --> 00:24:29,919
verification environment for your design

00:24:31,039 --> 00:24:34,480
okay advice for simulation now for

00:24:33,760 --> 00:24:38,559
physical

00:24:34,480 --> 00:24:41,520
uh synthesis so the design flow is

00:24:38,559 --> 00:24:42,400
first to do a generic synthesis then you

00:24:41,520 --> 00:24:44,720
adapt

00:24:42,400 --> 00:24:46,320
the necklace created by the cities to

00:24:44,720 --> 00:24:49,120
your target

00:24:46,320 --> 00:24:49,120
and then you

00:24:50,880 --> 00:24:55,919
once you have an at least

00:24:54,320 --> 00:24:59,200
you have to transform it into a big

00:24:55,919 --> 00:25:02,960
screen in order to in order

00:24:59,200 --> 00:25:05,520
to program the fpga

00:25:02,960 --> 00:25:06,960
for front end so what is what what i

00:25:05,520 --> 00:25:09,679
mean by fountain is the

00:25:06,960 --> 00:25:12,559
part of the tool that read your language

00:25:09,679 --> 00:25:16,159
and create the netlist

00:25:12,559 --> 00:25:16,640
most of them are based on uses and usda

00:25:16,159 --> 00:25:20,000
can

00:25:16,640 --> 00:25:23,279
be used as a fountain but for uh

00:25:20,000 --> 00:25:24,159
as a plugin of this and you always you

00:25:23,279 --> 00:25:28,159
also have

00:25:24,159 --> 00:25:31,840
all d2 for map

00:25:28,159 --> 00:25:35,840
uh the main tool is jose which uses

00:25:31,840 --> 00:25:38,640
abc from barclay to do the mapping

00:25:35,840 --> 00:25:39,679
and from placental it exists only for

00:25:38,640 --> 00:25:42,320
very few

00:25:39,679 --> 00:25:43,919
fpga and open source structurally exist

00:25:42,320 --> 00:25:46,799
only for very few fpga

00:25:43,919 --> 00:25:48,880
and the main ones are next pioneer and

00:25:46,799 --> 00:25:53,360
vpr

00:25:48,880 --> 00:25:53,360
so what is dhdl

00:25:53,679 --> 00:26:01,279
first it's a simulation tool

00:25:57,200 --> 00:26:03,679
and it's uh support uh the full language

00:26:01,279 --> 00:26:04,480
for the world vhdl language until

00:26:03,679 --> 00:26:08,840
version

00:26:04,480 --> 00:26:11,360
2002 and also most of the features of

00:26:08,840 --> 00:26:14,640
2008.

00:26:11,360 --> 00:26:17,200
it doesn't interpret your code but it's

00:26:14,640 --> 00:26:18,159
compiling so it directly creates at the

00:26:17,200 --> 00:26:19,679
end you

00:26:18,159 --> 00:26:23,279
most of the time you get an executable

00:26:19,679 --> 00:26:23,279
that can be run directly

00:26:23,360 --> 00:26:30,080
and it does use either llvm or gcc

00:26:26,799 --> 00:26:33,120
as a to generate object code

00:26:30,080 --> 00:26:34,400
or it has also an internal jit called

00:26:33,120 --> 00:26:36,720
import

00:26:34,400 --> 00:26:36,720
and

00:26:37,440 --> 00:26:40,640
created can also generate reforms and

00:26:39,760 --> 00:26:43,760
since

00:26:40,640 --> 00:26:44,320
since last year it also do synthesis and

00:26:43,760 --> 00:26:48,960
it can

00:26:44,320 --> 00:26:53,039
either output the generic net is created

00:26:48,960 --> 00:26:57,600
or it can also be used as a uses plugin

00:26:53,039 --> 00:26:57,600
and then fit into the design

00:26:59,440 --> 00:27:06,480
but yes if you have any question

00:27:02,559 --> 00:27:09,760
about jtn or about microwave it's

00:27:06,480 --> 00:27:09,760
time to ask a question

00:27:16,159 --> 00:27:19,039
thanks tristan we had a couple questions

00:27:17,600 --> 00:27:19,520
on the q a which i've been trying to

00:27:19,039 --> 00:27:22,320
answer

00:27:19,520 --> 00:27:23,039
i don't know if um for some strange

00:27:22,320 --> 00:27:25,200
reason

00:27:23,039 --> 00:27:26,240
my um my answers at least here seem to

00:27:25,200 --> 00:27:29,679
be

00:27:26,240 --> 00:27:30,880
line wrapped to like uh maybe a dozen

00:27:29,679 --> 00:27:33,120
characters so hopefully it's

00:27:30,880 --> 00:27:35,200
intelligible uh

00:27:33,120 --> 00:27:36,559
we'll see if there's any more so we had

00:27:35,200 --> 00:27:38,880
a set of questions from bill and

00:27:36,559 --> 00:27:40,399
and two leo around um gleepsie support

00:27:38,880 --> 00:27:42,000
so that's that's ongoing at the moment

00:27:40,399 --> 00:27:44,159
and i think as bill said

00:27:42,000 --> 00:27:45,840
uh it's the right time for us to just

00:27:44,159 --> 00:27:46,960
sit down and look to see

00:27:45,840 --> 00:27:49,360
if there's anything we can do in that

00:27:46,960 --> 00:27:54,320
space around uh allowing

00:27:49,360 --> 00:27:54,320
uh glypc uh in the le realm to be

00:27:54,960 --> 00:27:59,440
more to allow more of the subsets than

00:27:58,240 --> 00:28:00,720
it does today

00:27:59,440 --> 00:28:03,360
and so that's that's something ongoing

00:28:00,720 --> 00:28:05,279
that we'll um we'll start working on

00:28:03,360 --> 00:28:06,960
i don't know if there's any any other

00:28:05,279 --> 00:28:17,840
questions for either

00:28:06,960 --> 00:28:17,840
tristan or myself in the q a

00:28:18,000 --> 00:28:21,279
i've i think we've only got a couple

00:28:19,600 --> 00:28:22,640
minutes but that's wait a couple minutes

00:28:21,279 --> 00:28:26,240
left

00:28:22,640 --> 00:28:31,840
um so if not uh i guess

00:28:26,240 --> 00:28:31,840
uh i guess we're good

00:28:33,600 --> 00:28:37,520
i think in the chat there's there's a

00:28:35,120 --> 00:28:39,919
slack channel as well if people want to

00:28:37,520 --> 00:28:40,880
continue to engage later on uh the other

00:28:39,919 --> 00:28:44,799
thing i mentioned

00:28:40,880 --> 00:28:47,360
uh we do have a uh so there is a slack

00:28:44,799 --> 00:28:49,360
channel for microwatt there's a i think

00:28:47,360 --> 00:28:50,960
it's a gita channel for ghdl so you can

00:28:49,360 --> 00:28:51,840
find them pretty easily both them pretty

00:28:50,960 --> 00:28:55,120
easily

00:28:51,840 --> 00:28:57,200
if you uh if you google for them uh and

00:28:55,120 --> 00:28:59,520
you know there's both a community around

00:28:57,200 --> 00:29:00,720
that that that you can engage with if

00:28:59,520 --> 00:29:03,200
you want to talk about

00:29:00,720 --> 00:29:05,120
anything uh if you have another vhdl

00:29:03,200 --> 00:29:08,880
project give it a go on ghdl

00:29:05,120 --> 00:29:10,960
uh i i think i saw maybe bill

00:29:08,880 --> 00:29:12,559
on the the channel just there you know

00:29:10,960 --> 00:29:15,039
there's been some experimentation that

00:29:12,559 --> 00:29:17,520
tristan had with getting a2i

00:29:15,039 --> 00:29:19,360
to synthesis sorry to simulate with with

00:29:17,520 --> 00:29:21,840
ghdl i don't know if

00:29:19,360 --> 00:29:24,000
uh a20 has been done yet that might be

00:29:21,840 --> 00:29:25,919
something we can play with next but uh

00:29:24,000 --> 00:29:27,440
you know if you've got a vhdl project

00:29:25,919 --> 00:29:29,120
it's definitely worth playing with ghdl

00:29:27,440 --> 00:29:31,600
to see how it goes

00:29:29,120 --> 00:29:33,440
um yeah and that's i think that's all

00:29:31,600 --> 00:29:35,520
i've got so unless there's uh anything

00:29:33,440 --> 00:29:37,039
else i think uh

00:29:35,520 --> 00:29:38,720
i think we're good thank you for for

00:29:37,039 --> 00:29:40,000
turning up and uh you know hope to see

00:29:38,720 --> 00:29:41,520
you on

00:29:40,000 --> 00:29:45,760
on github maybe playing with microwave

00:29:41,520 --> 00:29:45,760

YouTube URL: https://www.youtube.com/watch?v=N-_9dWdvLBA


