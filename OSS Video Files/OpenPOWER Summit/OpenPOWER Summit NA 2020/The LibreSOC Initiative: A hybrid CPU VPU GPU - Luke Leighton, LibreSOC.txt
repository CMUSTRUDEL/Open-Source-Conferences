Title: The LibreSOC Initiative: A hybrid CPU VPU GPU - Luke Leighton, LibreSOC
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	The LibreSOC Initiative: A hybrid CPU/VPU/GPU - Luke Leighton, LibreSOC

Speakers: Luke Leighton

LibreSOC is a hybrid CPU, VPU and GPU that is to be free of DRM and spying backdoor coprocessors, and to be libre licensed to the bedrock. To engender business and end-user trust the design is being developed fully transparently following best Libre Development practices, aims for full coverage with Formal Correctness Proofs, first class documentation suitable for both educational engagement as well as customer and developer support, and to act as a Reference and experimental Platform for exploration of advanced 3D and Video extensions to the Power ISA, under the guidance and mentorship of the OpenPOWER Foundation. With EUR 350,000 funding from NLNet under their Privacy and Enhanced Trust Programme, LibreSOC's first target is a 180nm test ASIC, as a first step on a roadmap that includes a Quad Core SoC suitable for use in tablets, netbooks and the SBC Industrial markets.
Captions: 
	00:00:00,160 --> 00:00:04,000
hello and welcome to a presentation for

00:00:02,960 --> 00:00:07,200
openpower

00:00:04,000 --> 00:00:08,639
um by the farmer libresock project um

00:00:07,200 --> 00:00:11,280
with many thanks to

00:00:08,639 --> 00:00:12,000
uh openpower foundation and linux

00:00:11,280 --> 00:00:14,080
foundation

00:00:12,000 --> 00:00:17,920
and also to uh and on that first

00:00:14,080 --> 00:00:17,920
sponsorship of this project

00:00:18,640 --> 00:00:22,400
why are we doing another css monitor

00:00:20,960 --> 00:00:24,800
when there's plenty available in the

00:00:22,400 --> 00:00:28,160
market already

00:00:24,800 --> 00:00:30,320
well let's simplify that that

00:00:28,160 --> 00:00:31,840
we've got things like spectrum meltdown

00:00:30,320 --> 00:00:33,920
um we have uh

00:00:31,840 --> 00:00:35,040
intel management engine which provides

00:00:33,920 --> 00:00:36,640
us with um

00:00:35,040 --> 00:00:38,160
uh in back door kind of spine

00:00:36,640 --> 00:00:41,600
co-processors these are

00:00:38,160 --> 00:00:44,719
also in amd also has a similar

00:00:41,600 --> 00:00:48,800
issue um there's qa issues in

00:00:44,719 --> 00:00:52,239
uh intel's development which were

00:00:48,800 --> 00:00:55,360
recently highlighted by apple um

00:00:52,239 --> 00:00:58,800
and just wanted opportunities to

00:00:55,360 --> 00:01:00,000
do better another reason is that there

00:00:58,800 --> 00:01:02,399
are

00:01:00,000 --> 00:01:03,280
in system on chip world which is a fully

00:01:02,399 --> 00:01:06,080
integrated

00:01:03,280 --> 00:01:07,280
uh uh processor there are endless

00:01:06,080 --> 00:01:09,280
proprietary drivers

00:01:07,280 --> 00:01:11,040
um which ends up affecting the product

00:01:09,280 --> 00:01:15,200
development cost

00:01:11,040 --> 00:01:17,439
you'd license a uh a a hard macro for 3d

00:01:15,200 --> 00:01:18,799
and it comes with a proprietary software

00:01:17,439 --> 00:01:21,119
driver and you don't have any choice

00:01:18,799 --> 00:01:25,040
about that

00:01:21,119 --> 00:01:28,080
consequently you went back in when uh

00:01:25,040 --> 00:01:29,280
semiconductors you know design a

00:01:28,080 --> 00:01:33,119
particular chip

00:01:29,280 --> 00:01:36,159
to save on their development costs

00:01:33,119 --> 00:01:39,119
um they go for the easily solution

00:01:36,159 --> 00:01:40,560
and unfortunately our absolutely

00:01:39,119 --> 00:01:44,479
everybody has done that

00:01:40,560 --> 00:01:48,000
there are no entirely

00:01:44,479 --> 00:01:51,200
uh libra um system on a chip uh which

00:01:48,000 --> 00:01:53,360
for which the full software stack is uh

00:01:51,200 --> 00:01:56,320
available uh consequently that's a

00:01:53,360 --> 00:01:58,159
product opportunity for us

00:01:56,320 --> 00:02:00,560
um there's also an opportunity to

00:01:58,159 --> 00:02:04,159
drastically simplify driver development

00:02:00,560 --> 00:02:07,280
and engage in long-tail markets now um

00:02:04,159 --> 00:02:08,640
the typical way the gpu is developed is

00:02:07,280 --> 00:02:11,200
that um

00:02:08,640 --> 00:02:12,720
you have your user base uh code which

00:02:11,200 --> 00:02:15,040
then calls

00:02:12,720 --> 00:02:16,160
into a kernel driver the kernel driver

00:02:15,040 --> 00:02:18,879
then passes over

00:02:16,160 --> 00:02:20,080
a memory map system using shared memory

00:02:18,879 --> 00:02:22,720
pci express bus

00:02:20,080 --> 00:02:24,160
in the case of an external gpu and then

00:02:22,720 --> 00:02:25,840
unpacks the

00:02:24,160 --> 00:02:27,920
function call arguments for the opengl

00:02:25,840 --> 00:02:29,760
call whatever it is makes the

00:02:27,920 --> 00:02:31,280
functional call on the gpo in a foreign

00:02:29,760 --> 00:02:32,800
architecture and then

00:02:31,280 --> 00:02:34,400
passes the results all the way back to

00:02:32,800 --> 00:02:36,000
the to the

00:02:34,400 --> 00:02:39,360
user space application the 3d

00:02:36,000 --> 00:02:39,360
application uh

00:02:39,680 --> 00:02:42,160
we decided to take a different approach

00:02:41,120 --> 00:02:43,360
where to actually do a hybrid

00:02:42,160 --> 00:02:45,120
architecture which put it

00:02:43,360 --> 00:02:46,640
into the actual uh the instruction

00:02:45,120 --> 00:02:48,400
setting it gets executed by the power

00:02:46,640 --> 00:02:50,000
instruction set

00:02:48,400 --> 00:02:51,519
um the other reason this is good enough

00:02:50,000 --> 00:02:52,319
for its only is because for 30 years i

00:02:51,519 --> 00:02:56,400
always want

00:02:52,319 --> 00:02:59,120
cpu um

00:02:56,400 --> 00:03:00,480
why are chosen open power um well to

00:02:59,120 --> 00:03:01,599
answer that first we have to go over

00:03:00,480 --> 00:03:04,159
some evaluation

00:03:01,599 --> 00:03:05,440
criteria um a good ecosystem is

00:03:04,159 --> 00:03:08,000
absolutely essential

00:03:05,440 --> 00:03:08,800
um we need uh linux kernel update

00:03:08,000 --> 00:03:12,959
compilers

00:03:08,800 --> 00:03:14,959
os uh support uh bin new tools um

00:03:12,959 --> 00:03:16,400
everything um and we need reference

00:03:14,959 --> 00:03:17,360
implementations because otherwise if we

00:03:16,400 --> 00:03:18,640
don't have them

00:03:17,360 --> 00:03:20,800
available we're going to have to spend

00:03:18,640 --> 00:03:24,560
the time and effort creating them

00:03:20,800 --> 00:03:27,680
and then convincing people

00:03:24,560 --> 00:03:29,200
uh customers that um they should adopt

00:03:27,680 --> 00:03:30,480
it and that is an extraordinary hard

00:03:29,200 --> 00:03:33,440
sell

00:03:30,480 --> 00:03:35,680
when we don't need the hassle um so uh

00:03:33,440 --> 00:03:37,680
we're not going to do that

00:03:35,680 --> 00:03:38,799
uh the it needs an extremely supportive

00:03:37,680 --> 00:03:41,200
foundation and

00:03:38,799 --> 00:03:42,159
uh members and we need to be able to

00:03:41,200 --> 00:03:44,959
submit its

00:03:42,159 --> 00:03:46,720
isa augmentations which should be

00:03:44,959 --> 00:03:49,760
properly peer reviewed

00:03:46,720 --> 00:03:50,640
um before being allowed to become part

00:03:49,760 --> 00:03:54,159
of the

00:03:50,640 --> 00:03:56,239
um isa um

00:03:54,159 --> 00:03:57,280
the other thing that's critical for us

00:03:56,239 --> 00:04:00,159
under the uh

00:03:57,280 --> 00:04:00,879
nl nets privacy enhanced trust program

00:04:00,159 --> 00:04:04,159
and

00:04:00,879 --> 00:04:07,120
as a business justification um for

00:04:04,159 --> 00:04:07,599
full transparency and trust trustability

00:04:07,120 --> 00:04:10,480
no

00:04:07,599 --> 00:04:11,519
nda's signed and we need this full

00:04:10,480 --> 00:04:13,840
transparency

00:04:11,519 --> 00:04:14,959
we can't even engage in the working

00:04:13,840 --> 00:04:17,840
groups

00:04:14,959 --> 00:04:18,720
without um there being uh full order

00:04:17,840 --> 00:04:22,000
probability

00:04:18,720 --> 00:04:22,000
by our customers

00:04:22,560 --> 00:04:26,080
um so with those criteria in mind and we

00:04:25,759 --> 00:04:27,919
then

00:04:26,080 --> 00:04:30,160
looked at a very comprehensive review of

00:04:27,919 --> 00:04:33,280
all the available instruction sets

00:04:30,160 --> 00:04:35,600
um risk 5

00:04:33,280 --> 00:04:37,600
turned out to be total opposite of what

00:04:35,600 --> 00:04:41,199
it was is advertised as

00:04:37,600 --> 00:04:44,320
as close secretive mailing lists closed

00:04:41,199 --> 00:04:47,280
working groups they

00:04:44,320 --> 00:04:47,919
we tried really hard to um and very

00:04:47,280 --> 00:04:51,280
reasonable

00:04:47,919 --> 00:04:53,280
requests to uh be included

00:04:51,280 --> 00:04:54,320
um and there was absolutely no

00:04:53,280 --> 00:04:56,800
acceptance or response

00:04:54,320 --> 00:04:58,320
to our transparency requirements plus it

00:04:56,800 --> 00:04:59,360
does not have services established

00:04:58,320 --> 00:05:01,759
enough

00:04:59,360 --> 00:05:04,320
um at the time we looked the mips open

00:05:01,759 --> 00:05:07,039
industrial website was offline

00:05:04,320 --> 00:05:08,160
um blossom i would really like to have

00:05:07,039 --> 00:05:10,960
considered that

00:05:08,160 --> 00:05:10,960
more valuation

00:05:13,120 --> 00:05:17,840
um can't consider it um almond x86

00:05:16,400 --> 00:05:21,360
proprietary exercises is far too

00:05:17,840 --> 00:05:23,360
complicated um open rate 1200

00:05:21,360 --> 00:05:24,400
although extremely good there's just not

00:05:23,360 --> 00:05:27,759
enough adoption

00:05:24,400 --> 00:05:27,759
uh compared to

00:05:28,000 --> 00:05:32,160
arm open power and risk five now uses a

00:05:30,960 --> 00:05:35,039
gpu

00:05:32,160 --> 00:05:35,840
meow is also is not actually a gpu it's

00:05:35,039 --> 00:05:39,600
a

00:05:35,840 --> 00:05:41,520
amd of a compatible vector engine

00:05:39,600 --> 00:05:43,199
um rolling our own instruction set was

00:05:41,520 --> 00:05:44,400
just out of the question for a hybrid

00:05:43,199 --> 00:05:45,919
architecture because you actually have

00:05:44,400 --> 00:05:48,720
to do the full

00:05:45,919 --> 00:05:49,440
standard instruction set as well as just

00:05:48,720 --> 00:05:52,160
the

00:05:49,440 --> 00:05:52,639
uh and then add the gpu test on top of

00:05:52,160 --> 00:05:54,880
it

00:05:52,639 --> 00:05:57,280
um open our power has been stamped for

00:05:54,880 --> 00:05:59,919
decades has an excellent foundation

00:05:57,280 --> 00:06:00,800
um we've got microwaves as a reference

00:05:59,919 --> 00:06:03,600
platform

00:06:00,800 --> 00:06:05,120
um and uh with many many thanks to hugh

00:06:03,600 --> 00:06:08,639
for introducing us to

00:06:05,120 --> 00:06:08,960
people um uh we've found that they've

00:06:08,639 --> 00:06:10,240
been

00:06:08,960 --> 00:06:12,479
extraordinarily approachable and

00:06:10,240 --> 00:06:14,639
friendly and supportive of the

00:06:12,479 --> 00:06:16,880
of the strategy that we've um we've come

00:06:14,639 --> 00:06:16,880
up with

00:06:17,199 --> 00:06:21,840
so what goes into a typical

00:06:20,400 --> 00:06:23,759
system chip i have to explain this

00:06:21,840 --> 00:06:24,560
because many people think of processor

00:06:23,759 --> 00:06:26,880
and they think

00:06:24,560 --> 00:06:28,880
automatically intel north bridge south

00:06:26,880 --> 00:06:31,440
chip south bridge chip

00:06:28,880 --> 00:06:32,960
peripherals are totally separate um it's

00:06:31,440 --> 00:06:35,520
completely different

00:06:32,960 --> 00:06:36,880
um everything isn't not necessarily on

00:06:35,520 --> 00:06:38,639
the same diet because you sometimes get

00:06:36,880 --> 00:06:41,919
multi-chip modules

00:06:38,639 --> 00:06:43,759
but you basically have a built-in gpu

00:06:41,919 --> 00:06:45,199
a built-in vpu where it's a shared

00:06:43,759 --> 00:06:48,560
memory bus a

00:06:45,199 --> 00:06:50,080
third-party license so for example um uh

00:06:48,560 --> 00:06:52,400
vivand which is i think has been bought

00:06:50,080 --> 00:06:53,039
by synopsis um is a quarter of a million

00:06:52,400 --> 00:06:56,639
dollars

00:06:53,039 --> 00:06:59,680
licensing cost for gc 800

00:06:56,639 --> 00:07:03,039
the um the for low power embedded

00:06:59,680 --> 00:07:04,800
things and um most

00:07:03,039 --> 00:07:06,720
uh semiconductors i mentioned earlier

00:07:04,800 --> 00:07:09,840
would just go for that

00:07:06,720 --> 00:07:10,639
it is just simpler but um it's simpler

00:07:09,840 --> 00:07:12,000
to you know

00:07:10,639 --> 00:07:14,639
get your building blocks and put it

00:07:12,000 --> 00:07:17,680
together um but it means that the

00:07:14,639 --> 00:07:19,919
both the gpu and the vpu unless they've

00:07:17,680 --> 00:07:22,800
been reverse engineered

00:07:19,919 --> 00:07:23,759
um which is itself a um extraordinary

00:07:22,800 --> 00:07:25,280
high cost of

00:07:23,759 --> 00:07:27,199
time time and development and then you

00:07:25,280 --> 00:07:30,080
end up with the older version

00:07:27,199 --> 00:07:31,520
of whatever it is that you're doing that

00:07:30,080 --> 00:07:33,520
running your software on

00:07:31,520 --> 00:07:35,039
um you never you're always playing catch

00:07:33,520 --> 00:07:38,639
up with rest engineering

00:07:35,039 --> 00:07:40,160
and it's an a minimum three year delay

00:07:38,639 --> 00:07:42,479
from the time that the product would

00:07:40,160 --> 00:07:42,880
actually start it it's just commercially

00:07:42,479 --> 00:07:46,230
not

00:07:42,880 --> 00:07:47,280
viable um so um

00:07:46,230 --> 00:07:50,960
[Music]

00:07:47,280 --> 00:07:54,000
you you end up with this proprietary

00:07:50,960 --> 00:07:56,080
software for the video decode and

00:07:54,000 --> 00:07:57,280
privacy software for the gpu which

00:07:56,080 --> 00:07:59,199
impacts your

00:07:57,280 --> 00:08:00,639
um you've got these paid blogs and blogs

00:07:59,199 --> 00:08:01,520
and you can't do software development on

00:08:00,639 --> 00:08:02,720
them

00:08:01,520 --> 00:08:03,919
you get you know you single step

00:08:02,720 --> 00:08:06,479
interesting and it's been stripped of

00:08:03,919 --> 00:08:08,960
all all the debug symbols

00:08:06,479 --> 00:08:10,639
so um you can't work out if there's a

00:08:08,960 --> 00:08:10,960
bug in your software or it's a bug in

00:08:10,639 --> 00:08:14,319
the

00:08:10,960 --> 00:08:18,000
in the driver which really does happen

00:08:14,319 --> 00:08:19,840
um samsung's uh had that um power vr

00:08:18,000 --> 00:08:21,120
has just been hugely unstable and an

00:08:19,840 --> 00:08:23,759
absolute nuisance

00:08:21,120 --> 00:08:23,759
and so on

00:08:24,720 --> 00:08:29,360
excuse me um you also get these fully

00:08:27,599 --> 00:08:31,440
integrated peripherals so everything is

00:08:29,360 --> 00:08:34,399
on on the tip and your target price

00:08:31,440 --> 00:08:35,440
for your chip is typically between 2.50

00:08:34,399 --> 00:08:38,479
and 32

00:08:35,440 --> 00:08:40,800
30 depending on the market

00:08:38,479 --> 00:08:42,800
so overall it's radically different from

00:08:40,800 --> 00:08:45,519
the average intel processor

00:08:42,800 --> 00:08:47,360
or amd processor um and certainly

00:08:45,519 --> 00:08:50,080
different from the ibm power line core

00:08:47,360 --> 00:08:51,360
which is over 200 watt and focused on

00:08:50,080 --> 00:08:56,080
high performance

00:08:51,360 --> 00:08:56,800
i o so this is a quick illustration of

00:08:56,080 --> 00:08:58,480
uh

00:08:56,800 --> 00:09:00,720
the idea so those two blocks of video

00:08:58,480 --> 00:09:03,920
processing and the 3d instructions are

00:09:00,720 --> 00:09:07,040
inside here um as actual

00:09:03,920 --> 00:09:08,720
extensions to the open power instruction

00:09:07,040 --> 00:09:10,480
set um

00:09:08,720 --> 00:09:13,360
and we'll be doing an out-of-word design

00:09:10,480 --> 00:09:16,720
um and adding simple vectorization

00:09:13,360 --> 00:09:17,920
more on that in a in a in a way

00:09:16,720 --> 00:09:20,959
so here's your peripherals and you

00:09:17,920 --> 00:09:23,600
typically have a pin marks

00:09:20,959 --> 00:09:24,959
uh uh which maps all of these you know

00:09:23,600 --> 00:09:28,399
thousand pins down to

00:09:24,959 --> 00:09:31,600
only 200 uh uh uh or however many it is

00:09:28,399 --> 00:09:34,640
this is just a typical uh uh

00:09:31,600 --> 00:09:35,200
chip um two to two and a half to five

00:09:34,640 --> 00:09:38,640
watts

00:09:35,200 --> 00:09:40,240
so it's um it can be a ceramic package

00:09:38,640 --> 00:09:42,160
or a plastic package

00:09:40,240 --> 00:09:44,080
no heat stick heat sink needed and use

00:09:42,160 --> 00:09:47,200
extremely compact and

00:09:44,080 --> 00:09:47,200
you can typically get away with

00:09:47,839 --> 00:09:51,360
if you use miniature components you can

00:09:49,920 --> 00:09:54,560
get away with about a 30

00:09:51,360 --> 00:09:57,760
30 by 40 millimeter pcb

00:09:54,560 --> 00:10:01,120
for the entire design including

00:09:57,760 --> 00:10:04,160
power management the processor and

00:10:01,120 --> 00:10:06,800
flat nand flash and memory which will be

00:10:04,160 --> 00:10:06,800
3d stacked

00:10:07,360 --> 00:10:11,680
so where we're starting um the first

00:10:09,760 --> 00:10:14,399
thing was get a basic call working on

00:10:11,680 --> 00:10:16,560
simulation and then on fpga we're using

00:10:14,399 --> 00:10:18,320
microwave as a reference

00:10:16,560 --> 00:10:20,000
to do that and we've successfully

00:10:18,320 --> 00:10:23,120
managed to do that a couple of weeks ago

00:10:20,000 --> 00:10:25,440
um done on a versa ecb5 um

00:10:23,120 --> 00:10:26,880
which um it's a fully free software uh

00:10:25,440 --> 00:10:29,200
tool chain

00:10:26,880 --> 00:10:30,240
um next we're gonna do a low cost test

00:10:29,200 --> 00:10:33,839
chip um

00:10:30,240 --> 00:10:37,600
in 180 diameter this will allow us to

00:10:33,839 --> 00:10:39,680
uh iterate on uh

00:10:37,600 --> 00:10:41,040
and gain confidence in our ability to

00:10:39,680 --> 00:10:44,959
develop a chip

00:10:41,040 --> 00:10:48,320
um without wasting vast sums of money

00:10:44,959 --> 00:10:52,320
um uh uh on uh you know

00:10:48,320 --> 00:10:55,760
20 20 nanometer or whatever it is um

00:10:52,320 --> 00:11:00,320
um multi-vendor program costs

00:10:55,760 --> 00:11:03,279
um if we do this basically 880 nanometer

00:11:00,320 --> 00:11:03,680
it's only about 18 000 us a time which

00:11:03,279 --> 00:11:06,079
is

00:11:03,680 --> 00:11:07,440
um we can do a hell of a lot of

00:11:06,079 --> 00:11:09,920
iterations on that

00:11:07,440 --> 00:11:12,079
um before we move and get to get the

00:11:09,920 --> 00:11:15,200
core right first before we move

00:11:12,079 --> 00:11:17,200
on to faster designs

00:11:15,200 --> 00:11:18,800
so in parallel that under the watchful

00:11:17,200 --> 00:11:20,560
eye of the open power foundation we'll

00:11:18,800 --> 00:11:23,040
be developing a vector instruction set

00:11:20,560 --> 00:11:26,160
with 3d and video extensions

00:11:23,040 --> 00:11:27,200
um uh we're going to implement a vector

00:11:26,160 --> 00:11:30,560
instruction set a

00:11:27,200 --> 00:11:34,800
symbol v in a simulator that will allow

00:11:30,560 --> 00:11:39,600
development of bin utils um and

00:11:34,800 --> 00:11:43,040
the 3d gpu

00:11:39,600 --> 00:11:45,519
compiler the shader engine

00:11:43,040 --> 00:11:46,160
um then we'll implement in hdl run that

00:11:45,519 --> 00:11:49,200
under

00:11:46,160 --> 00:11:50,320
uh simulation uh thing and then put into

00:11:49,200 --> 00:11:52,000
fpga and finally

00:11:50,320 --> 00:11:53,600
only when it's been ratified by the open

00:11:52,000 --> 00:11:54,240
power foundation we've got permission to

00:11:53,600 --> 00:11:56,880
do so

00:11:54,240 --> 00:11:58,160
we'll put into silicon then we sold some

00:11:56,880 --> 00:12:01,920
lit chips make a lot of money

00:11:58,160 --> 00:12:01,920
and um repeat the process again

00:12:03,040 --> 00:12:06,320
so what's different about lubric it's

00:12:05,600 --> 00:12:09,360
what's called

00:12:06,320 --> 00:12:12,480
a hybrid integrated

00:12:09,360 --> 00:12:15,279
cpu so the cpu is the gpu

00:12:12,480 --> 00:12:16,639
the gpu is the cpu and likewise for the

00:12:15,279 --> 00:12:19,920
video processing

00:12:16,639 --> 00:12:23,360
there is no separate vpu

00:12:19,920 --> 00:12:25,839
gpu pipeline or core or instruction

00:12:23,360 --> 00:12:26,720
set so apologies for emphasizing that

00:12:25,839 --> 00:12:29,519
but it takes

00:12:26,720 --> 00:12:30,800
quite a long time we found from

00:12:29,519 --> 00:12:32,320
experience it takes quite a long time

00:12:30,800 --> 00:12:35,680
for that to sink in

00:12:32,320 --> 00:12:39,360
we are actually adding

00:12:35,680 --> 00:12:43,040
3d and video instructions two

00:12:39,360 --> 00:12:46,639
power instruction set not creating

00:12:43,040 --> 00:12:50,160
a separate gpu with its own

00:12:46,639 --> 00:12:53,440
utterly separate pipelines into

00:12:50,160 --> 00:12:56,959
cash etc it's literally inside

00:12:53,440 --> 00:13:00,000
the power iso core the main core

00:12:56,959 --> 00:13:01,519
all right um so

00:13:00,000 --> 00:13:03,040
it's also written in the medium which is

00:13:01,519 --> 00:13:05,600
a python based hdl

00:13:03,040 --> 00:13:06,639
not vhcl not very lagging definitely not

00:13:05,600 --> 00:13:09,360
chisel three

00:13:06,639 --> 00:13:10,720
um with scalar um we spent several

00:13:09,360 --> 00:13:13,839
months evaluating different

00:13:10,720 --> 00:13:15,440
um uh hdls and with this is

00:13:13,839 --> 00:13:18,720
extremely important it's extremely easy

00:13:15,440 --> 00:13:20,480
decision for us to make

00:13:18,720 --> 00:13:22,000
the thing that's different is simple v

00:13:20,480 --> 00:13:24,079
vector extension um

00:13:22,000 --> 00:13:28,639
if you look up uh simply considered

00:13:24,079 --> 00:13:32,240
harmful um which is on citrix.org

00:13:28,639 --> 00:13:35,440
we based uh um the simple v

00:13:32,240 --> 00:13:36,880
on the crave vector loop system which

00:13:35,440 --> 00:13:40,000
effectively

00:13:36,880 --> 00:13:42,480
but went a step further um

00:13:40,000 --> 00:13:44,399
and effectively it's like mmx

00:13:42,480 --> 00:13:46,839
instructions it's hardware for loop on

00:13:44,399 --> 00:13:50,560
the standard scalar instruction set

00:13:46,839 --> 00:13:53,519
um where it increments the

00:13:50,560 --> 00:13:55,440
program counter pauses the program

00:13:53,519 --> 00:13:57,920
counter and increments the register

00:13:55,440 --> 00:14:00,399
numbers on the scalar register numbers

00:13:57,920 --> 00:14:02,240
in from naught to vl minus one

00:14:00,399 --> 00:14:06,160
effectively so it's conceptually similar

00:14:02,240 --> 00:14:06,160
to zero overhead loops and dsps

00:14:08,000 --> 00:14:14,720
um we're doing a hybrid architecture

00:14:11,279 --> 00:14:18,000
um we're calling it augmented 6600

00:14:14,720 --> 00:14:20,160
so the cdc 6600 is designed from 1965

00:14:18,000 --> 00:14:22,720
but the augmentations are not

00:14:20,160 --> 00:14:23,440
and mitch helsop very kindly helped us

00:14:22,720 --> 00:14:25,680
um

00:14:23,440 --> 00:14:28,399
spent several months um explaining this

00:14:25,680 --> 00:14:30,639
to me uh on comp.arch

00:14:28,399 --> 00:14:31,440
how to add precise exceptions um

00:14:30,639 --> 00:14:34,880
multi-issue

00:14:31,440 --> 00:14:36,959
and much more um uh i won't go into

00:14:34,880 --> 00:14:39,199
a lot of detail but the basically

00:14:36,959 --> 00:14:40,720
academic literature on 600 100 is

00:14:39,199 --> 00:14:44,160
utterly misleading

00:14:40,720 --> 00:14:46,480
um simply because um seymour craig

00:14:44,160 --> 00:14:48,480
and james salton back in 1963 when they

00:14:46,480 --> 00:14:50,079
designed the 6600

00:14:48,480 --> 00:14:51,199
sold problems that they didn't realize

00:14:50,079 --> 00:14:52,480
and existed they were literally the

00:14:51,199 --> 00:14:54,880
first people to do

00:14:52,480 --> 00:14:56,000
an out about order superscalar

00:14:54,880 --> 00:15:01,120
architecture

00:14:56,000 --> 00:15:01,120
um and didn't realize that

00:15:01,680 --> 00:15:05,360
things were difficult consequently they

00:15:03,440 --> 00:15:06,480
didn't put it into the literature or the

00:15:05,360 --> 00:15:10,320
pattern which is

00:15:06,480 --> 00:15:12,880
yeah you get the idea um

00:15:10,320 --> 00:15:14,880
so uh we're doing a front-end vector

00:15:12,880 --> 00:15:16,480
instruction set uh this uh simple v

00:15:14,880 --> 00:15:17,920
but it's at the back end it will be a

00:15:16,480 --> 00:15:21,199
predicated or marked

00:15:17,920 --> 00:15:24,560
sim d um uh uh uh

00:15:21,199 --> 00:15:25,360
uh uh um pipelines um and the median

00:15:24,560 --> 00:15:27,040
which is pricing

00:15:25,360 --> 00:15:28,560
object-orientated was strategically

00:15:27,040 --> 00:15:29,440
critically important to for us to

00:15:28,560 --> 00:15:32,000
achieve this

00:15:29,440 --> 00:15:33,360
in a reasonable amount of maintainable

00:15:32,000 --> 00:15:36,160
code

00:15:33,360 --> 00:15:36,880
um we're doing out of order instruction

00:15:36,160 --> 00:15:39,279
set

00:15:36,880 --> 00:15:40,560
which when combined with simple v the

00:15:39,279 --> 00:15:42,560
that for loop

00:15:40,560 --> 00:15:44,240
hardware for loop issues scalar

00:15:42,560 --> 00:15:45,120
operations but it issues them all in the

00:15:44,240 --> 00:15:48,399
same

00:15:45,120 --> 00:15:51,040
um cycle and consequently um they can be

00:15:48,399 --> 00:15:53,680
turned into simply at the back end with

00:15:51,040 --> 00:15:55,279
without developer needing to know that

00:15:53,680 --> 00:15:58,880
it's simdi and that has a

00:15:55,279 --> 00:16:01,199
huge saving for the

00:15:58,880 --> 00:16:02,560
compiler writer on the complexity of

00:16:01,199 --> 00:16:03,759
thing you need to see that simply

00:16:02,560 --> 00:16:05,279
consistently harmful and

00:16:03,759 --> 00:16:08,160
i think it saves clock cycles say

00:16:05,279 --> 00:16:11,120
everything is a huge benefits to it

00:16:08,160 --> 00:16:15,199
um then what we'll do is we'll add ieee

00:16:11,120 --> 00:16:18,560
754 sine cosine a10 log 1p etc

00:16:15,199 --> 00:16:22,240
normalize um and things

00:16:18,560 --> 00:16:23,839
as scalar operations to the power

00:16:22,240 --> 00:16:27,199
instruction set

00:16:23,839 --> 00:16:31,040
and simple v will vectorize those

00:16:27,199 --> 00:16:31,040
automatically and inherently

00:16:32,480 --> 00:16:37,759
uh why why are we chosen the median uh

00:16:35,759 --> 00:16:40,000
so first thing we do is evaluate other

00:16:37,759 --> 00:16:41,040
hdl's and we get a sort of an idea of

00:16:40,000 --> 00:16:42,800
the criteria that

00:16:41,040 --> 00:16:44,079
we need the first thing you so

00:16:42,800 --> 00:16:45,759
appreciate is that our

00:16:44,079 --> 00:16:48,399
team is primarily software engineers not

00:16:45,759 --> 00:16:51,839
hardware engineers

00:16:48,399 --> 00:16:54,320
so uh verilog was designed in the 1990s

00:16:51,839 --> 00:16:56,079
for doing unit tests um when people

00:16:54,320 --> 00:16:57,040
starting doing heavily doing gate level

00:16:56,079 --> 00:17:00,720
design

00:16:57,040 --> 00:17:03,040
um vhdl again is a procedural language

00:17:00,720 --> 00:17:04,480
similar to basic and fortran it does

00:17:03,040 --> 00:17:05,839
however have records which is really

00:17:04,480 --> 00:17:08,880
nice

00:17:05,839 --> 00:17:11,520
um uh chisholm scalar is out of uh

00:17:08,880 --> 00:17:12,720
um is object-oriented but it's extremely

00:17:11,520 --> 00:17:14,400
obscure language um

00:17:12,720 --> 00:17:16,480
suitable really owned for research it's

00:17:14,400 --> 00:17:18,000
just not you can't intuitively

00:17:16,480 --> 00:17:21,520
you can't just obviously read the code

00:17:18,000 --> 00:17:24,480
and understand it um

00:17:21,520 --> 00:17:25,760
i've tried i've tried um pi rtl is a

00:17:24,480 --> 00:17:27,919
python based

00:17:25,760 --> 00:17:29,600
hdl um thing but the community is not

00:17:27,919 --> 00:17:32,799
large enough um

00:17:29,600 --> 00:17:33,840
behind it and my hdl is a subset of

00:17:32,799 --> 00:17:37,520
python only

00:17:33,840 --> 00:17:40,000
so it's basically verilog in

00:17:37,520 --> 00:17:41,200
a python syntax and consequently the

00:17:40,000 --> 00:17:44,799
only the subset

00:17:41,200 --> 00:17:47,520
of python which maps to

00:17:44,799 --> 00:17:48,880
verilog is supported so from this you

00:17:47,520 --> 00:17:49,679
can see we're slowly forming a set of

00:17:48,880 --> 00:17:52,000
criteria

00:17:49,679 --> 00:17:53,440
um which basically python is the only

00:17:52,000 --> 00:17:56,320
language which fits

00:17:53,440 --> 00:17:58,400
and we then decide to fly those same

00:17:56,320 --> 00:18:00,080
criteria to the hdl itself

00:17:58,400 --> 00:18:02,880
although that hdl is a much smaller

00:18:00,080 --> 00:18:04,880
community um

00:18:02,880 --> 00:18:06,160
and it turned out that nummy gem was the

00:18:04,880 --> 00:18:10,080
only one that actually

00:18:06,160 --> 00:18:10,080
meet those similar criteria

00:18:11,600 --> 00:18:14,799
so it uses python to build an abstract

00:18:13,280 --> 00:18:16,480
syntax tree in memory which is then

00:18:14,799 --> 00:18:18,559
handed over to yosis

00:18:16,480 --> 00:18:19,600
to generate an eyeline file and then you

00:18:18,559 --> 00:18:22,000
can use the

00:18:19,600 --> 00:18:23,039
read the right underscore verilog to

00:18:22,000 --> 00:18:26,799
output verilog

00:18:23,039 --> 00:18:30,160
if you want to um it has determinants

00:18:26,799 --> 00:18:31,520
determining deterministic synthesizable

00:18:30,160 --> 00:18:34,640
behavior

00:18:31,520 --> 00:18:37,039
um uh uh i think which was

00:18:34,640 --> 00:18:37,840
also quite important for simplifying um

00:18:37,039 --> 00:18:40,720
designs

00:18:37,840 --> 00:18:42,000
uh we can apply python programming of

00:18:40,720 --> 00:18:44,720
python objects other than

00:18:42,000 --> 00:18:46,480
programming techniques um so we can pass

00:18:44,720 --> 00:18:48,240
in parameters to

00:18:46,480 --> 00:18:51,039
python functions and classes which

00:18:48,240 --> 00:18:53,280
generate completely different hdl

00:18:51,039 --> 00:18:54,640
without having to duplicate that code

00:18:53,280 --> 00:18:57,720
which is extremely complex

00:18:54,640 --> 00:19:00,000
so it's a much better version of the

00:18:57,720 --> 00:19:03,280
parameterization of verilog

00:19:00,000 --> 00:19:05,520
which is not really um a

00:19:03,280 --> 00:19:07,200
mod neither very like normal vhdl a

00:19:05,520 --> 00:19:10,480
proper modern

00:19:07,200 --> 00:19:13,280
um two incomplete languages

00:19:10,480 --> 00:19:15,360
where you get the idea um so you can use

00:19:13,280 --> 00:19:18,640
python-based for loops to read cs5

00:19:15,360 --> 00:19:19,919
free files using the standard python csv

00:19:18,640 --> 00:19:20,480
module which has been written for 20

00:19:19,919 --> 00:19:23,360
years

00:19:20,480 --> 00:19:25,200
and generate a hierarchical suite of hdl

00:19:23,360 --> 00:19:25,760
switch statements and that's how we did

00:19:25,200 --> 00:19:27,520
the

00:19:25,760 --> 00:19:28,799
the power instruction decoder for for

00:19:27,520 --> 00:19:32,400
labels up

00:19:28,799 --> 00:19:34,240
um we also did some extreme

00:19:32,400 --> 00:19:35,919
uh abstraction for what's called a

00:19:34,240 --> 00:19:38,480
dynamic partition signal which

00:19:35,919 --> 00:19:40,640
um uh any questions about that i cannot

00:19:38,480 --> 00:19:43,919
answer about that later

00:19:40,640 --> 00:19:47,039
um so here you can see um uh

00:19:43,919 --> 00:19:47,679
here's some vhdl in microwatt for the

00:19:47,039 --> 00:19:51,520
decode

00:19:47,679 --> 00:19:55,200
uh record um and here is the equivalent

00:19:51,520 --> 00:19:58,880
in uh numetone which the only

00:19:55,200 --> 00:20:01,840
evidence of there being any um hdl

00:19:58,880 --> 00:20:03,280
at all in this is that signal and that's

00:20:01,840 --> 00:20:06,559
an amiga object

00:20:03,280 --> 00:20:08,960
which represents a signal

00:20:06,559 --> 00:20:11,520
so a signal of length one which is here

00:20:08,960 --> 00:20:14,559
is a standard ulogic but a signal of

00:20:11,520 --> 00:20:18,000
length something is a standard

00:20:14,559 --> 00:20:19,440
logic vector but um the median has the

00:20:18,000 --> 00:20:20,000
ability to support enums and all of

00:20:19,440 --> 00:20:23,280
these

00:20:20,000 --> 00:20:24,799
are python enums and it will

00:20:23,280 --> 00:20:27,440
automatically detect the lengths

00:20:24,799 --> 00:20:29,039
and things it's absolutely fantastic so

00:20:27,440 --> 00:20:31,120
you're back to python programming you're

00:20:29,039 --> 00:20:35,200
doing software engineering techniques

00:20:31,120 --> 00:20:36,640
to develop hardware and

00:20:35,200 --> 00:20:38,400
one important things here is you can see

00:20:36,640 --> 00:20:39,919
that this subsetter argument which is a

00:20:38,400 --> 00:20:43,840
python set

00:20:39,919 --> 00:20:48,000
um if you pass in that subset

00:20:43,840 --> 00:20:51,120
it will create a record

00:20:48,000 --> 00:20:52,960
which has a subset of the fields

00:20:51,120 --> 00:20:54,240
required and consequently we can use

00:20:52,960 --> 00:20:57,840
this in the decoder

00:20:54,240 --> 00:21:00,559
to create subsets of the decoder

00:20:57,840 --> 00:21:01,039
um for completely different purposes so

00:21:00,559 --> 00:21:04,799
we use

00:21:01,039 --> 00:21:07,679
one decoder which which

00:21:04,799 --> 00:21:08,640
we can use for getting the registers all

00:21:07,679 --> 00:21:10,080
right

00:21:08,640 --> 00:21:12,400
with that and this is all without having

00:21:10,080 --> 00:21:14,159
to write multiple versions of the same

00:21:12,400 --> 00:21:17,440
decoder because it is the same decoder

00:21:14,159 --> 00:21:20,960
you just pass in these parameters

00:21:17,440 --> 00:21:23,760
and then use the same code to ask it

00:21:20,960 --> 00:21:26,320
to generate something for load store or

00:21:23,760 --> 00:21:29,520
something for the alu pipeline

00:21:26,320 --> 00:21:30,159
right simply by passing in a subset

00:21:29,520 --> 00:21:33,120
parameter

00:21:30,159 --> 00:21:33,840
of which limits the columns that are

00:21:33,120 --> 00:21:37,120
needed for

00:21:33,840 --> 00:21:39,280
that you want to the code to generate so

00:21:37,120 --> 00:21:41,039
in that way we took um this again from

00:21:39,280 --> 00:21:43,440
micro micro what

00:21:41,039 --> 00:21:44,159
decode one dot vhdl you can see this is

00:21:43,440 --> 00:21:46,480
the

00:21:44,159 --> 00:21:47,520
declaration of that rom type uh no it's

00:21:46,480 --> 00:21:50,640
not it's uh

00:21:47,520 --> 00:21:55,200
you want subtype array but that array is

00:21:50,640 --> 00:21:58,960
of type decode wrong underscore t here

00:21:55,200 --> 00:22:00,000
um but in for in here we've done it as a

00:21:58,960 --> 00:22:01,760
csv file

00:22:00,000 --> 00:22:04,400
across currently you can use the same

00:22:01,760 --> 00:22:07,440
csv file to auto generate documentation

00:22:04,400 --> 00:22:10,720
tables um uh

00:22:07,440 --> 00:22:12,880
and many more purposes without having

00:22:10,720 --> 00:22:16,880
transcription errors and duplication

00:22:12,880 --> 00:22:19,280
errors in um in potential errors in our

00:22:16,880 --> 00:22:23,120
in our in the code

00:22:19,280 --> 00:22:26,159
so um again there's no hdl in this at

00:22:23,120 --> 00:22:29,360
all but it generates the hdl um

00:22:26,159 --> 00:22:31,840
here's the decoder i so you have um

00:22:29,360 --> 00:22:32,799
an array of things for dealing with my

00:22:31,840 --> 00:22:36,240
uh with the

00:22:32,799 --> 00:22:37,120
major op code 19. um here's the other

00:22:36,240 --> 00:22:40,960
ones

00:22:37,120 --> 00:22:44,240
um for 30 31 58 and 62.

00:22:40,960 --> 00:22:46,320
um and then that is passed as sub

00:22:44,240 --> 00:22:48,320
decoders to

00:22:46,320 --> 00:22:51,039
here and that creates your top level

00:22:48,320 --> 00:22:53,600
decoder of this major.csv specif

00:22:51,039 --> 00:22:54,159
similar to microart decoder one the

00:22:53,600 --> 00:22:56,480
major

00:22:54,159 --> 00:22:57,280
uh thing if you have a look at that um

00:22:56,480 --> 00:23:00,240
offline

00:22:57,280 --> 00:23:03,679
um uh that contains the major up codes

00:23:00,240 --> 00:23:07,039
and it's based on bits 2632

00:23:03,679 --> 00:23:10,799
in your power order anything

00:23:07,039 --> 00:23:13,679
you get the idea um so um

00:23:10,799 --> 00:23:14,080
and and um and then once that's decoded

00:23:13,679 --> 00:23:15,440
and

00:23:14,080 --> 00:23:17,360
one of the switch statements this thing

00:23:15,440 --> 00:23:19,360
it goes into the further into the

00:23:17,360 --> 00:23:22,880
hierarchy of further decoding and

00:23:19,360 --> 00:23:24,799
ultimately you end up with one of these

00:23:22,880 --> 00:23:29,120
one and only one of these lines being

00:23:24,799 --> 00:23:34,159
activated and you've decoded the operand

00:23:29,120 --> 00:23:34,159
decoded the instruction so

00:23:34,840 --> 00:23:37,280
um

00:23:36,159 --> 00:23:39,280
why we've done another vector

00:23:37,280 --> 00:23:41,440
instruction set well um well it's not

00:23:39,280 --> 00:23:42,480
exactly another thing it's it's called a

00:23:41,440 --> 00:23:45,120
tagging system

00:23:42,480 --> 00:23:46,559
so there are no op codes new op codes

00:23:45,120 --> 00:23:50,799
and consequently

00:23:46,559 --> 00:23:51,279
um we stand a reasonable chance of

00:23:50,799 --> 00:23:54,640
fitting

00:23:51,279 --> 00:23:57,120
um the uh simple vector um

00:23:54,640 --> 00:23:58,240
decoder into a single clock cycle which

00:23:57,120 --> 00:24:00,240
you just can't do

00:23:58,240 --> 00:24:01,440
with um the standard power instruction

00:24:00,240 --> 00:24:03,600
set

00:24:01,440 --> 00:24:06,559
um as i mentioned it's effectively a for

00:24:03,600 --> 00:24:09,600
a hardware sub-counter for loop

00:24:06,559 --> 00:24:12,080
um you end up with a vectorization of

00:24:09,600 --> 00:24:13,840
not just the current instructions but

00:24:12,080 --> 00:24:17,760
future scalar instructions

00:24:13,840 --> 00:24:21,039
as well and so the element

00:24:17,760 --> 00:24:24,480
with polymorphism as part of the tagging

00:24:21,039 --> 00:24:28,640
allows without adding

00:24:24,480 --> 00:24:32,240
uh floating point 16 80 or 128 you get

00:24:28,640 --> 00:24:35,360
the ability to change the meaning of

00:24:32,240 --> 00:24:36,880
the scalar instructions for floating

00:24:35,360 --> 00:24:40,400
point 32 and 64

00:24:36,880 --> 00:24:42,000
to actually mean 1680 or 128 without

00:24:40,400 --> 00:24:43,520
modifying the instruction of the

00:24:42,000 --> 00:24:45,279
instruction set itself

00:24:43,520 --> 00:24:47,120
so it's like an overwatch override

00:24:45,279 --> 00:24:50,159
system on top of what's the instruction

00:24:47,120 --> 00:24:53,279
instructions so

00:24:50,159 --> 00:24:56,000
um this slide illustrates how that

00:24:53,279 --> 00:24:56,320
loop of that thing is note this is add

00:24:56,000 --> 00:24:58,480
not

00:24:56,320 --> 00:25:01,039
vector ad this is a scalar ad which just

00:24:58,480 --> 00:25:04,240
happens to have simple v vectorization

00:25:01,039 --> 00:25:06,720
um added to it looping around

00:25:04,240 --> 00:25:07,600
uh here's the for loop here's where

00:25:06,720 --> 00:25:12,000
predication

00:25:07,600 --> 00:25:16,799
is applied to uh if it's enabled

00:25:12,000 --> 00:25:16,799
and here you add on these increments

00:25:17,520 --> 00:25:20,880
depending on whether register a register

00:25:20,559 --> 00:25:24,720
b

00:25:20,880 --> 00:25:25,440
or around the rt is detected in the tag

00:25:24,720 --> 00:25:28,320
table as

00:25:25,440 --> 00:25:29,440
vectorized that's usually simplified but

00:25:28,320 --> 00:25:33,039
it's basically that

00:25:29,440 --> 00:25:36,240
in a nutshell so um

00:25:33,039 --> 00:25:38,400
i apologize for rushing for road time

00:25:36,240 --> 00:25:39,919
room for questions uh our goal is to

00:25:38,400 --> 00:25:42,159
create a mass volume low power

00:25:39,919 --> 00:25:44,240
embedded system on chipset for networks

00:25:42,159 --> 00:25:48,000
chromebooks tablets and smartphones

00:25:44,240 --> 00:25:49,760
um it has to be trustable um uh

00:25:48,000 --> 00:25:51,679
this is our business objective it is

00:25:49,760 --> 00:25:55,200
despite the fact that it's libra the

00:25:51,679 --> 00:25:58,000
labour licensed lgblv3 this is that is

00:25:55,200 --> 00:25:59,200
part of the transparency of our business

00:25:58,000 --> 00:26:02,240
objectives

00:25:59,200 --> 00:26:04,960
not because we just thought maybe it

00:26:02,240 --> 00:26:07,360
would be a good idea to be open

00:26:04,960 --> 00:26:08,640
um uh collaboration with the open power

00:26:07,360 --> 00:26:10,240
foundation members is absolutely

00:26:08,640 --> 00:26:12,960
essential there are no

00:26:10,240 --> 00:26:13,760
shortcuts here we are fully connecting

00:26:12,960 --> 00:26:16,240
and

00:26:13,760 --> 00:26:16,880
understand the um the implications of

00:26:16,240 --> 00:26:20,080
the um

00:26:16,880 --> 00:26:21,679
open power um end user license agreement

00:26:20,080 --> 00:26:23,120
um so we're working on the back of

00:26:21,679 --> 00:26:24,159
houston with the ability of power

00:26:23,120 --> 00:26:26,480
ecosystem

00:26:24,159 --> 00:26:28,400
and the combination of that means that

00:26:26,480 --> 00:26:32,159
our board support package can be

00:26:28,400 --> 00:26:34,960
100 upstream right across the board

00:26:32,159 --> 00:26:36,320
um and this means that app application

00:26:34,960 --> 00:26:36,960
and product development for our

00:26:36,320 --> 00:26:40,080
customers

00:26:36,960 --> 00:26:41,360
is greatly simplified um and much more

00:26:40,080 --> 00:26:44,400
attractive

00:26:41,360 --> 00:26:46,559
so thank you very much um tough

00:26:44,400 --> 00:26:50,080
questions

00:26:46,559 --> 00:26:52,960
um thank you it was just uh um

00:26:50,080 --> 00:26:53,600
that's uh we're on um i'll be on free

00:26:52,960 --> 00:26:56,960
node

00:26:53,600 --> 00:26:59,360
um ircfreno.net on librasoc

00:26:56,960 --> 00:27:01,200
um libra dash sock um if anybody would

00:26:59,360 --> 00:27:02,320
like to chat or remember scotland

00:27:01,200 --> 00:27:07,200
mailing lists

00:27:02,320 --> 00:27:10,320
um the website is libra dashboard.org

00:27:07,200 --> 00:27:15,679
so if anyone has any uh

00:27:10,320 --> 00:27:19,440
questions please do oh it's a q a

00:27:15,679 --> 00:27:21,039
good question man uh

00:27:19,440 --> 00:27:22,720
what is time frame for completion

00:27:21,039 --> 00:27:27,600
availability from paul

00:27:22,720 --> 00:27:27,600
um uh uh we're good um

00:27:28,000 --> 00:27:35,760
we've uh we've got an end of october

00:27:32,159 --> 00:27:39,039
okay so it's working now um with

00:27:35,760 --> 00:27:43,840
uh microwatts uh compatibility

00:27:39,039 --> 00:27:47,440
um uh is functional um so that's in fpga

00:27:43,840 --> 00:27:50,240
um the test chip will be the end of

00:27:47,440 --> 00:27:52,480
october um going to the foundry so this

00:27:50,240 --> 00:27:53,840
is 180 nanometer but that's a test ship

00:27:52,480 --> 00:27:55,760
so we need special permission from the

00:27:53,840 --> 00:27:56,720
open power foundation to

00:27:55,760 --> 00:27:58,880
do that but it's not going to be

00:27:56,720 --> 00:28:02,000
publicly available um

00:27:58,880 --> 00:28:03,679
then realistically

00:28:02,000 --> 00:28:05,919
we're looking at about 18 months for

00:28:03,679 --> 00:28:10,720
something like a 28

00:28:05,919 --> 00:28:10,720
or nanometer or below asic

00:28:11,200 --> 00:28:17,840
i hope that uh

00:28:24,880 --> 00:28:31,840
any any other any other questions and

00:28:28,840 --> 00:28:31,840
thoughts

00:28:32,480 --> 00:28:36,960
so as um one thing um as of this is a

00:28:35,600 --> 00:28:40,320
legal project

00:28:36,960 --> 00:28:43,600
um uh we actually do have funding

00:28:40,320 --> 00:28:44,000
um from n on that so if anybody wants to

00:28:43,600 --> 00:28:46,640
help

00:28:44,000 --> 00:28:48,399
they're more than welcome to do so and

00:28:46,640 --> 00:28:51,919
we've actually received

00:28:48,399 --> 00:28:56,399
donations for doing so um so

00:28:51,919 --> 00:28:56,399
um yeah um

00:28:56,840 --> 00:29:02,080
let's

00:28:59,039 --> 00:29:05,440
we've also got um we're doing the

00:29:02,080 --> 00:29:05,919
we're doing two drivers two 3d drivers

00:29:05,440 --> 00:29:08,159
and

00:29:05,919 --> 00:29:10,880
and some video drivers video drivers

00:29:08,159 --> 00:29:15,840
being done in assembler

00:29:10,880 --> 00:29:19,039
um uh for inclusion in ffmpeg

00:29:15,840 --> 00:29:20,720
and um there's two 3d drivers one of

00:29:19,039 --> 00:29:22,000
them moves in rust

00:29:20,720 --> 00:29:25,360
both of them are vulcan compliant and

00:29:22,000 --> 00:29:28,880
the other one is mesa driver

00:29:25,360 --> 00:29:30,720
and that's um that mesa one

00:29:28,880 --> 00:29:33,440
is actually going to be a sort of a

00:29:30,720 --> 00:29:37,360
software one which then ends up being

00:29:33,440 --> 00:29:40,320
hyperx um a hardware accelerated

00:29:37,360 --> 00:29:41,679
so it's it's a huge scope in this

00:29:40,320 --> 00:29:43,919
project

00:29:41,679 --> 00:29:46,000
actually fantastic i'm just absolutely

00:29:43,919 --> 00:29:47,200
amazed that i can consider it

00:29:46,000 --> 00:29:49,039
even be possible and it wouldn't be

00:29:47,200 --> 00:29:54,000
possible without the um

00:29:49,039 --> 00:29:56,880
huge uh ecosystem that's available know

00:29:54,000 --> 00:29:56,880
open source software

00:29:58,240 --> 00:30:02,000
if any any any other questions yeah feel

00:30:00,240 --> 00:30:04,720
free to um

00:30:02,000 --> 00:30:06,640
uh get in touch on on the irc channel um

00:30:04,720 --> 00:30:11,440
or join our mailing lists

00:30:06,640 --> 00:30:11,440

YouTube URL: https://www.youtube.com/watch?v=RjA_WdeuMJw


