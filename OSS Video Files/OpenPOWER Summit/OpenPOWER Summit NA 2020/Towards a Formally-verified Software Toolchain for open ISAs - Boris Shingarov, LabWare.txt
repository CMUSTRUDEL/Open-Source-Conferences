Title: Towards a Formally-verified Software Toolchain for open ISAs - Boris Shingarov, LabWare
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	Towards a Formally-verified Software Toolchain for open ISAs - Boris Shingarov, LabWare

Speakers: Boris Shingarov

This talk summarizes lessons from several years of experimenting with automatic generation of compiler toolchains from processor description languages (PDL), using approaches ranging from superoptimization via logic programming to SMT-based binary analysis, and presents a new experimental system which builds on these lessons. The new approach takes ISA specifications written in the Sail PDL, as the starting point for software-tools synthesis and verification. Sail is used by practicing engineers to create full-scale formalizations of real ISAs; on the other hand, Sail is based on Lem and is mathematically rigorous. This talk demonstrates how the tool transforms a short sequence of POWER instructions into a proof of an invariant of the final state holding universally over the space of allowed behaviors.
Captions: 
	00:00:00,640 --> 00:00:06,560
hi my name is boris shingrov

00:00:03,199 --> 00:00:08,400
i work at labware i make vms virtual

00:00:06,560 --> 00:00:11,519
machines

00:00:08,400 --> 00:00:15,360
now to exclude any confusion

00:00:11,519 --> 00:00:19,359
i'm talking about dynamic language vms

00:00:15,360 --> 00:00:23,840
you know for interpretive languages with

00:00:19,359 --> 00:00:26,640
jit compilers dynamic garbage collection

00:00:23,840 --> 00:00:26,640
that kind of stuff

00:00:29,359 --> 00:00:32,800
today i'll talk about formal

00:00:31,679 --> 00:00:35,600
specifically

00:00:32,800 --> 00:00:36,480
in the context of open source compiler

00:00:35,600 --> 00:00:39,840
toolchains

00:00:36,480 --> 00:00:42,000
for open source isas now

00:00:39,840 --> 00:00:43,120
a couple of people over the past few

00:00:42,000 --> 00:00:46,320
days

00:00:43,120 --> 00:00:50,480
been asking why this talk uh

00:00:46,320 --> 00:00:53,760
why concentrate on this um

00:00:50,480 --> 00:00:54,879
they were like hey boris you are usually

00:00:53,760 --> 00:00:59,520
more associated

00:00:54,879 --> 00:01:02,559
with your being one of the originators

00:00:59,520 --> 00:01:06,320
of the eclipse project so they

00:01:02,559 --> 00:01:09,840
they wanted me to talk about uh building

00:01:06,320 --> 00:01:13,520
open source software ecosystems

00:01:09,840 --> 00:01:18,960
and um here's the thing

00:01:13,520 --> 00:01:22,560
back in 2001 the important question was

00:01:18,960 --> 00:01:26,400
the top-of-the-art idea

00:01:22,560 --> 00:01:28,640
can open source have

00:01:26,400 --> 00:01:31,200
that kind of best programming

00:01:28,640 --> 00:01:31,200
environment

00:01:31,759 --> 00:01:38,560
so today if you ask me today

00:01:34,960 --> 00:01:40,400
what an equivalent driving issue is well

00:01:38,560 --> 00:01:42,479
as far as i'm concerned we're talking

00:01:40,400 --> 00:01:46,240
about software tools here

00:01:42,479 --> 00:01:49,600
uh today uh an equivalent issue would be

00:01:46,240 --> 00:01:52,479
rigorous engineering

00:01:49,600 --> 00:01:54,240
so let's talk about the way programmers

00:01:52,479 --> 00:01:57,439
write software

00:01:54,240 --> 00:02:00,719
we write code we write tests

00:01:57,439 --> 00:02:01,920
we run the test if the test passes we're

00:02:00,719 --> 00:02:08,080
happy

00:02:01,920 --> 00:02:10,560
it appears to work

00:02:08,080 --> 00:02:11,440
so for example imagine we are

00:02:10,560 --> 00:02:14,720
implementing

00:02:11,440 --> 00:02:17,920
addition and we want to see

00:02:14,720 --> 00:02:22,640
whether 3 plus 4 indeed

00:02:17,920 --> 00:02:25,680
computes 7. we run it

00:02:22,640 --> 00:02:29,280
voila indeed it does

00:02:25,680 --> 00:02:32,959
we're laughing well what about

00:02:29,280 --> 00:02:36,319
10 plus 15 does that work i don't know

00:02:32,959 --> 00:02:38,239
not from this test what about corner

00:02:36,319 --> 00:02:41,360
cases

00:02:38,239 --> 00:02:44,560
this doesn't tell me so

00:02:41,360 --> 00:02:48,000
we have potential latent

00:02:44,560 --> 00:02:48,840
bugs and these are exceptionally

00:02:48,000 --> 00:02:51,760
difficult

00:02:48,840 --> 00:02:55,040
especially in something like an

00:02:51,760 --> 00:02:55,040
optimizing compiler

00:02:55,920 --> 00:03:04,720
now it's not like i'm trying to diminish

00:03:00,560 --> 00:03:07,760
there is a whole exciting art of tdd

00:03:04,720 --> 00:03:09,360
uh and that's not

00:03:07,760 --> 00:03:11,440
going anywhere that's that's not

00:03:09,360 --> 00:03:15,360
disappearing because

00:03:11,440 --> 00:03:15,920
ultimately the the process of cognition

00:03:15,360 --> 00:03:19,360
is

00:03:15,920 --> 00:03:23,040
when you're watching the computer work

00:03:19,360 --> 00:03:25,440
through a concrete example that's

00:03:23,040 --> 00:03:27,920
how you develop an intuition of what's

00:03:25,440 --> 00:03:27,920
going on

00:03:28,319 --> 00:03:35,760
and yet at the same time

00:03:32,400 --> 00:03:38,080
there is this altogether different

00:03:35,760 --> 00:03:39,120
way of thinking going back to the

00:03:38,080 --> 00:03:42,159
ancient

00:03:39,120 --> 00:03:45,360
greek geometers which asks

00:03:42,159 --> 00:03:50,400
can i prove that this is computing

00:03:45,360 --> 00:03:50,400
x plus y for all x and all y

00:03:51,040 --> 00:03:57,840
and the second idea due to hilbert

00:03:54,640 --> 00:03:59,040
is that proof is just another

00:03:57,840 --> 00:04:02,000
mathematical object

00:03:59,040 --> 00:04:04,400
and in a computer you can compute it

00:04:02,000 --> 00:04:08,640
just the same way as you do with ins

00:04:04,400 --> 00:04:11,120
strings lists whatever

00:04:08,640 --> 00:04:15,120
so programming becomes all about

00:04:11,120 --> 00:04:19,120
computing proofs there are many factors

00:04:15,120 --> 00:04:19,759
why you see when i first encountered

00:04:19,120 --> 00:04:22,400
this

00:04:19,759 --> 00:04:23,120
30 years ago i basically it's in nuclear

00:04:22,400 --> 00:04:26,240
physics

00:04:23,120 --> 00:04:30,240
institute in moscow uh

00:04:26,240 --> 00:04:33,440
it was about things like nuclear safety

00:04:30,240 --> 00:04:34,160
uh the project i was working on we did

00:04:33,440 --> 00:04:36,800
the

00:04:34,160 --> 00:04:39,120
instruments for cardiovascular surgery

00:04:36,800 --> 00:04:43,680
you see all stuff

00:04:39,120 --> 00:04:47,520
where human lives critically depend on

00:04:43,680 --> 00:04:49,840
and back then it was a very specialized

00:04:47,520 --> 00:04:49,840
niche

00:04:50,240 --> 00:04:57,759
today's growth happens in

00:04:53,680 --> 00:05:01,840
directions into fields that require

00:04:57,759 --> 00:05:04,880
this level of assurance applications

00:05:01,840 --> 00:05:07,919
where if you tell them

00:05:04,880 --> 00:05:11,840
it appears to work

00:05:07,919 --> 00:05:11,840
they'll simply not talk to you

00:05:12,000 --> 00:05:16,479
this is one very general factor

00:05:17,919 --> 00:05:25,280
another is that it's becoming so

00:05:21,440 --> 00:05:29,680
difficult to track all the logic

00:05:25,280 --> 00:05:33,440
as to cross into impossible

00:05:29,680 --> 00:05:36,639
and there are more non-trivial reasons

00:05:33,440 --> 00:05:39,919
than just complexity

00:05:36,639 --> 00:05:40,720
some are specifically caused by what the

00:05:39,919 --> 00:05:45,360
term

00:05:40,720 --> 00:05:48,560
computer architecture means today

00:05:45,360 --> 00:05:52,560
see when you write a compiler for

00:05:48,560 --> 00:05:55,680
something like the classical system 360

00:05:52,560 --> 00:05:58,639
or x86 you

00:05:55,680 --> 00:06:00,080
test it on the chip you happen to have

00:05:58,639 --> 00:06:03,039
in your shop

00:06:00,080 --> 00:06:04,080
and chances are it's going to work on

00:06:03,039 --> 00:06:07,280
your customers

00:06:04,080 --> 00:06:10,479
chips of that isa

00:06:07,280 --> 00:06:11,520
with something like power you cannot do

00:06:10,479 --> 00:06:14,639
that

00:06:11,520 --> 00:06:18,840
because the standard only defines

00:06:14,639 --> 00:06:20,639
behavior up to subtle details about

00:06:18,840 --> 00:06:24,720
concurrency

00:06:20,639 --> 00:06:26,960
this is called weak consistency

00:06:24,720 --> 00:06:29,680
there's an envelope of allowable

00:06:26,960 --> 00:06:29,680
behaviors

00:06:30,400 --> 00:06:35,919
you test your compiler on one processor

00:06:33,840 --> 00:06:39,440
and it works

00:06:35,919 --> 00:06:43,680
your customer in production has

00:06:39,440 --> 00:06:46,080
a processor with out of order that

00:06:43,680 --> 00:06:48,240
interacts slightly differently with the

00:06:46,080 --> 00:06:52,880
store buffer

00:06:48,240 --> 00:06:57,280
and you get weird race condition bugs

00:06:52,880 --> 00:07:00,560
good luck debugging those

00:06:57,280 --> 00:07:03,840
i mean in theory

00:07:00,560 --> 00:07:07,599
you could try to be careful and separate

00:07:03,840 --> 00:07:11,840
what you see the chip is doing

00:07:07,599 --> 00:07:14,880
from what the book actually promises

00:07:11,840 --> 00:07:18,400
but good luck tracking

00:07:14,880 --> 00:07:20,720
all those details as a compiler writer

00:07:18,400 --> 00:07:20,720
human

00:07:22,160 --> 00:07:28,000
the third factor is that when trying to

00:07:25,759 --> 00:07:31,199
bring up a new processor

00:07:28,000 --> 00:07:33,360
the software tool chain is what anchors

00:07:31,199 --> 00:07:36,639
you down

00:07:33,360 --> 00:07:40,080
you want to be flexible about what you

00:07:36,639 --> 00:07:40,080
can do in the processor

00:07:40,319 --> 00:07:48,479
in reality you change something

00:07:44,160 --> 00:07:52,240
and gcc breaks and it takes a year

00:07:48,479 --> 00:07:56,840
to find that subtle cause

00:07:52,240 --> 00:08:02,000
that's why all that aura retargetable

00:07:56,840 --> 00:08:02,000
cj and all that target agnostic stuff

00:08:03,120 --> 00:08:07,520
so how do we begin to have something

00:08:06,160 --> 00:08:10,639
better

00:08:07,520 --> 00:08:13,759
i'll go by examples

00:08:10,639 --> 00:08:16,800
one general idea is to build

00:08:13,759 --> 00:08:20,560
an abstract cpu with

00:08:16,800 --> 00:08:20,560
two distinguishing characteristics

00:08:20,639 --> 00:08:27,520
one i want it to be symbolic

00:08:24,319 --> 00:08:30,720
that means its state

00:08:27,520 --> 00:08:33,440
of the contents of its storage basis

00:08:30,720 --> 00:08:36,240
is algebraic formula as opposed to

00:08:33,440 --> 00:08:39,760
concrete numbers

00:08:36,240 --> 00:08:43,519
two i wanna infer it

00:08:39,760 --> 00:08:43,519
from a machine readable spec

00:08:43,839 --> 00:08:50,800
once i have this abstract cpu

00:08:47,440 --> 00:08:55,519
i proceed with tests as if i were just

00:08:50,800 --> 00:08:59,279
programming normally remember 3 plus 4

00:08:55,519 --> 00:09:04,800
but i give it x and y instead of

00:08:59,279 --> 00:09:04,800
3 and 4 and watch what comes out

00:09:05,279 --> 00:09:09,040
now let's formalize what i want what i'm

00:09:08,000 --> 00:09:13,360
gonna do

00:09:09,040 --> 00:09:15,920
is i'm gonna ask a satisfiability solver

00:09:13,360 --> 00:09:16,560
to search for a case where the result is

00:09:15,920 --> 00:09:20,320
actually

00:09:16,560 --> 00:09:22,160
wrong well that means output is not x

00:09:20,320 --> 00:09:26,080
plus y

00:09:22,160 --> 00:09:28,959
and if it finds such a case

00:09:26,080 --> 00:09:31,600
then well here is here's a bug right

00:09:28,959 --> 00:09:35,959
that that's a really bad report

00:09:31,600 --> 00:09:39,680
and if it says unsat

00:09:35,959 --> 00:09:40,320
unsatisfiable that means that i have

00:09:39,680 --> 00:09:42,959
proven

00:09:40,320 --> 00:09:43,760
that all the cases are actually correct

00:09:42,959 --> 00:09:47,519
because

00:09:43,760 --> 00:09:49,200
well it exhausted all the combinatorial

00:09:47,519 --> 00:09:52,800
space of all the different

00:09:49,200 --> 00:09:52,800
combinations of possibilities

00:09:53,839 --> 00:10:01,839
all right very good

00:09:57,200 --> 00:10:06,640
so we've gone from tests to model checks

00:10:01,839 --> 00:10:10,640
is there a problem here turns out yes

00:10:06,640 --> 00:10:14,000
and that problem is the unbounded case

00:10:10,640 --> 00:10:17,839
you see programs have loops

00:10:14,000 --> 00:10:18,320
and as the result when we try to decide

00:10:17,839 --> 00:10:22,480
whether

00:10:18,320 --> 00:10:24,800
behavior a is equivalent to behavior b

00:10:22,480 --> 00:10:28,320
we bump into a fundamental problem

00:10:24,800 --> 00:10:28,320
called the halting theorem

00:10:28,480 --> 00:10:33,680
and the root cause of that turns out

00:10:31,519 --> 00:10:36,000
to have actually nothing to do with

00:10:33,680 --> 00:10:38,399
programming or computers

00:10:36,000 --> 00:10:40,959
it's a fundamental problem that has been

00:10:38,399 --> 00:10:44,399
disturbing the smartest mathematicians

00:10:40,959 --> 00:10:47,120
for at least 2500 years

00:10:44,399 --> 00:10:49,440
going back to plato and to pitagora

00:10:47,120 --> 00:10:49,440
school

00:10:50,079 --> 00:10:57,760
the good news is that very recently

00:10:54,640 --> 00:11:01,440
i'm talking just a few decades

00:10:57,760 --> 00:11:03,839
we've seen some real progress

00:11:01,440 --> 00:11:05,519
there are now things like intuitionistic

00:11:03,839 --> 00:11:09,120
type theory

00:11:05,519 --> 00:11:12,839
and these are applied in practice

00:11:09,120 --> 00:11:16,560
to build systems like kami and

00:11:12,839 --> 00:11:20,000
concert the bad news

00:11:16,560 --> 00:11:24,160
is that today in 2020 this is

00:11:20,000 --> 00:11:27,200
still remaining very science intensive

00:11:24,160 --> 00:11:31,279
takes tremendous r d investment to

00:11:27,200 --> 00:11:35,600
prove relatively modest software

00:11:31,279 --> 00:11:38,959
and for cases like dynamic languages

00:11:35,600 --> 00:11:42,320
we're still not there there's a lot of

00:11:38,959 --> 00:11:46,959
very interesting research going on

00:11:42,320 --> 00:11:50,000
people trying to prove jvms and etc

00:11:46,959 --> 00:11:52,720
i attempted to build an intuitionistic

00:11:50,000 --> 00:11:56,720
small talk vm

00:11:52,720 --> 00:11:57,519
but a final engineering science for this

00:11:56,720 --> 00:12:01,120
kind of thing

00:11:57,519 --> 00:12:07,440
doesn't appear within reach out

00:12:01,120 --> 00:12:07,440
then what does appear within reach

00:12:07,839 --> 00:12:13,279
so let me show you the system for tool

00:12:11,360 --> 00:12:14,240
chain synthesis we've got here at

00:12:13,279 --> 00:12:18,240
lovewear

00:12:14,240 --> 00:12:20,320
it's all open source under mit

00:12:18,240 --> 00:12:22,000
this is all written in small talk

00:12:20,320 --> 00:12:24,320
because small talk

00:12:22,000 --> 00:12:26,800
still remains the best tool for

00:12:24,320 --> 00:12:30,000
conceptual exploration

00:12:26,800 --> 00:12:33,279
in the spirit of allen k's dynavog

00:12:30,000 --> 00:12:34,639
where instead of drawing shadows on the

00:12:33,279 --> 00:12:37,040
wall

00:12:34,639 --> 00:12:38,720
and trying to back project things into

00:12:37,040 --> 00:12:42,320
your imagination

00:12:38,720 --> 00:12:45,040
you can just directly experience them

00:12:42,320 --> 00:12:47,440
computational mathematics some people

00:12:45,040 --> 00:12:47,440
call it

00:12:48,480 --> 00:12:52,959
before we dive in i must explain

00:12:51,839 --> 00:12:56,800
something

00:12:52,959 --> 00:13:00,160
this has been an evolving system that

00:12:56,800 --> 00:13:03,360
grew over several generations

00:13:00,160 --> 00:13:06,399
so i personally find when i

00:13:03,360 --> 00:13:09,600
try to explain how it works

00:13:06,399 --> 00:13:13,279
i find it unavoidable to touch upon some

00:13:09,600 --> 00:13:16,320
historical points how i develop

00:13:13,279 --> 00:13:18,880
it over the years

00:13:16,320 --> 00:13:20,079
when we first decided we wanted to

00:13:18,880 --> 00:13:23,680
synthesize the tool

00:13:20,079 --> 00:13:26,160
chain from a spec in a processor

00:13:23,680 --> 00:13:30,880
description language

00:13:26,160 --> 00:13:34,560
for a number of years our pdl was rc

00:13:30,880 --> 00:13:39,279
rhc is a system

00:13:34,560 --> 00:13:42,800
c-ish tlm level modeling language

00:13:39,279 --> 00:13:46,560
you describe structure for example

00:13:42,800 --> 00:13:50,959
what your registers are like this here

00:13:46,560 --> 00:13:55,279
is from the model of 32-bit power pc

00:13:50,959 --> 00:13:58,320
uh you describe in a very natural dsl

00:13:55,279 --> 00:14:02,000
your binary encoding

00:13:58,320 --> 00:14:05,839
this is naturally split into

00:14:02,000 --> 00:14:05,839
you've got instruction formats

00:14:06,000 --> 00:14:09,440
and then you've got individual

00:14:07,839 --> 00:14:12,399
instructions

00:14:09,440 --> 00:14:12,399
these are like so

00:14:12,959 --> 00:14:19,920
then you've got specification for the

00:14:17,040 --> 00:14:24,160
grammar of your assembly

00:14:19,920 --> 00:14:26,959
like so and obviously this is invertible

00:14:24,160 --> 00:14:27,440
in the sense that you can recover an

00:14:26,959 --> 00:14:29,920
actual

00:14:27,440 --> 00:14:32,079
working assembler and disassembler from

00:14:29,920 --> 00:14:35,519
this

00:14:32,079 --> 00:14:38,800
so at the bin utils level

00:14:35,519 --> 00:14:43,040
this has served us very well

00:14:38,800 --> 00:14:44,560
obviously rc has been around for a while

00:14:43,040 --> 00:14:47,199
uh

00:14:44,560 --> 00:14:49,040
many people have synthesized being utils

00:14:47,199 --> 00:14:52,639
from these specs

00:14:49,040 --> 00:14:55,199
so there's nothing unusual about this

00:14:52,639 --> 00:14:56,839
the approach itself is even more well

00:14:55,199 --> 00:14:59,600
understood

00:14:56,839 --> 00:15:02,880
cjn the lisp system

00:14:59,600 --> 00:15:06,320
for uh doing this kind of things

00:15:02,880 --> 00:15:09,519
has been there for decades

00:15:06,320 --> 00:15:14,800
where things become difficult

00:15:09,519 --> 00:15:18,000
is semantics at first we were encouraged

00:15:14,800 --> 00:15:21,600
obviously for the symbolic cpu we need

00:15:18,000 --> 00:15:24,320
a special kind of being utils that will

00:15:21,600 --> 00:15:25,199
propagate algebraic expressions down to

00:15:24,320 --> 00:15:29,360
what i call

00:15:25,199 --> 00:15:32,240
holes in instruction memory

00:15:29,360 --> 00:15:33,440
you see when i try to prove something

00:15:32,240 --> 00:15:36,639
about behavior

00:15:33,440 --> 00:15:40,079
i don't have the code set in stone

00:15:36,639 --> 00:15:43,839
in a jit it's all self-modifying

00:15:40,079 --> 00:15:46,720
code which is okay uh

00:15:43,839 --> 00:15:47,680
it just means the instructions the cpu

00:15:46,720 --> 00:15:52,079
is executing

00:15:47,680 --> 00:15:55,519
are themselves algebraic instructions

00:15:52,079 --> 00:15:56,800
so here is open small talk jit on power

00:15:55,519 --> 00:15:59,920
pc

00:15:56,800 --> 00:16:02,880
this is not actual cog this

00:15:59,920 --> 00:16:02,880
is our jit

00:16:03,120 --> 00:16:09,279
this assembler syntax here

00:16:06,720 --> 00:16:11,519
the grammar for this gets automatically

00:16:09,279 --> 00:16:15,360
embedded into the compiler

00:16:11,519 --> 00:16:19,440
from processing the isa spec

00:16:15,360 --> 00:16:23,440
so this comes from here

00:16:19,440 --> 00:16:26,560
and this other one is

00:16:23,440 --> 00:16:29,759
because of parsing this here

00:16:26,560 --> 00:16:32,959
okay but what's much much

00:16:29,759 --> 00:16:37,440
more non-trivial is that we have

00:16:32,959 --> 00:16:41,040
two levels of variableness

00:16:37,440 --> 00:16:45,120
this emits the code to put a 32-bit

00:16:41,040 --> 00:16:45,120
immediate into a register

00:16:45,279 --> 00:16:50,240
so the immediate is an argument to the

00:16:49,199 --> 00:16:54,399
jet

00:16:50,240 --> 00:16:58,240
that's the first level of variability

00:16:54,399 --> 00:17:02,000
the jit will know imm

00:16:58,240 --> 00:17:05,280
when it's called to generate the code

00:17:02,000 --> 00:17:05,600
but because we are trying to prove that

00:17:05,280 --> 00:17:09,280
this

00:17:05,600 --> 00:17:10,559
works for any imm we symbolically

00:17:09,280 --> 00:17:14,720
execute this with

00:17:10,559 --> 00:17:14,720
imm equals x

00:17:14,959 --> 00:17:20,160
here is the byte code that this source

00:17:17,760 --> 00:17:24,079
gets compiled to

00:17:20,160 --> 00:17:27,439
this here is a bit vector ast

00:17:24,079 --> 00:17:29,600
in the microsoft z3 prover

00:17:27,439 --> 00:17:31,280
so these are ready-made instruction

00:17:29,600 --> 00:17:34,400
encodings

00:17:31,280 --> 00:17:38,799
at runtime the jit just

00:17:34,400 --> 00:17:41,919
spills them onto the instruction stream

00:17:38,799 --> 00:17:44,840
once again how does this work

00:17:41,919 --> 00:17:46,080
here is an explanation of the same

00:17:44,840 --> 00:17:48,960
instructions

00:17:46,080 --> 00:17:49,679
in the context of omr that's the

00:17:48,960 --> 00:17:53,600
universal

00:17:49,679 --> 00:17:57,360
vm substrate underneath j9

00:17:53,600 --> 00:18:00,960
this is from last year's splash

00:17:57,360 --> 00:18:05,039
so we're trying to put x

00:18:00,960 --> 00:18:10,400
which is a bit vector length 32

00:18:05,039 --> 00:18:13,840
into gpr3 this is power pc again

00:18:10,400 --> 00:18:17,200
omr is just the c plus plus program so

00:18:13,840 --> 00:18:20,960
we execute this function symbolically

00:18:17,200 --> 00:18:25,600
and as the output this is what it puts

00:18:20,960 --> 00:18:25,600
into the code cache this

00:18:26,160 --> 00:18:32,160
then we jump to this and then we execute

00:18:30,000 --> 00:18:32,160
it

00:18:32,960 --> 00:18:43,280
and then we'll look at what's in gpr3

00:18:38,559 --> 00:18:45,840
it's going to be some bit vector 32 asd

00:18:43,280 --> 00:18:47,039
we're trying to prove that the value of

00:18:45,840 --> 00:18:51,840
that ast

00:18:47,039 --> 00:18:55,760
equals x for all values of x

00:18:51,840 --> 00:18:57,120
well that's easy we just ask the smt

00:18:55,760 --> 00:19:00,400
solver to find

00:18:57,120 --> 00:19:03,440
one that doesn't uh

00:19:00,400 --> 00:19:04,480
the solder goes over all four billion

00:19:03,440 --> 00:19:08,480
values

00:19:04,480 --> 00:19:12,240
because it's 32 bits right uh comes back

00:19:08,480 --> 00:19:16,080
saying i cannot find any

00:19:12,240 --> 00:19:16,080
voila there is your proof

00:19:16,720 --> 00:19:24,559
i mean it goes over values conceptually

00:19:20,400 --> 00:19:27,120
these days solvers grew a lot smarter

00:19:24,559 --> 00:19:29,600
than to literally iterate over all

00:19:27,120 --> 00:19:32,000
combinatorial cases

00:19:29,600 --> 00:19:34,559
which is why this kind of analysis is

00:19:32,000 --> 00:19:34,559
practical

00:19:35,679 --> 00:19:42,640
now let's go back to this slide

00:19:39,200 --> 00:19:46,160
what's the difficulty the difficulty

00:19:42,640 --> 00:19:49,440
is semantics how to recover

00:19:46,160 --> 00:19:53,840
from the pdl information about what to

00:19:49,440 --> 00:19:53,840
put into gpr3

00:19:54,720 --> 00:19:58,080
this is where we got stuck regarding

00:19:56,720 --> 00:20:01,679
arch c

00:19:58,080 --> 00:20:05,120
in arch c how they synthesize simulators

00:20:01,679 --> 00:20:07,679
is they attach a fragment of c plus plus

00:20:05,120 --> 00:20:10,240
to each instruction

00:20:07,679 --> 00:20:11,679
that's really not suitable for automated

00:20:10,240 --> 00:20:15,520
reasoning

00:20:11,679 --> 00:20:18,799
however what we had high hopes for

00:20:15,520 --> 00:20:22,080
was an rc extension called

00:20:18,799 --> 00:20:26,000
acc gen what it is

00:20:22,080 --> 00:20:30,799
is a kind of rtl

00:20:26,000 --> 00:20:33,760
for declarative instruction semantics

00:20:30,799 --> 00:20:36,080
they have a super optimizer that

00:20:33,760 --> 00:20:39,760
transforms this rtl

00:20:36,080 --> 00:20:39,760
into a llvm back end

00:20:40,000 --> 00:20:46,320
i wrote my own acc gen processor

00:20:43,120 --> 00:20:49,760
which i call the prologue instruction

00:20:46,320 --> 00:20:52,480
generator or pig

00:20:49,760 --> 00:20:54,559
which is based on equational logic

00:20:52,480 --> 00:20:57,919
programming

00:20:54,559 --> 00:21:01,440
it's the van m then equational

00:20:57,919 --> 00:21:05,280
conditional rewrite engine and

00:21:01,440 --> 00:21:05,280
the rules are the rtls

00:21:06,240 --> 00:21:12,799
this does work as a proof of concept

00:21:09,600 --> 00:21:15,280
but we found that to practical

00:21:12,799 --> 00:21:20,559
applicability

00:21:15,280 --> 00:21:20,559
acc gen is rather limiting

00:21:20,799 --> 00:21:24,240
therefore there was the question what

00:21:23,760 --> 00:21:27,840
else

00:21:24,240 --> 00:21:30,640
can we use for the semantics part

00:21:27,840 --> 00:21:32,400
we investigated some other analysis

00:21:30,640 --> 00:21:36,240
systems

00:21:32,400 --> 00:21:40,000
alive is used by llvm

00:21:36,240 --> 00:21:44,000
to prove correctness of optimizations

00:21:40,000 --> 00:21:47,840
anger is a binary analysis system

00:21:44,000 --> 00:21:51,760
which is used actually for many things

00:21:47,840 --> 00:21:55,520
such as security vulnerability analysis

00:21:51,760 --> 00:21:56,720
you throw a power or arm or mips binary

00:21:55,520 --> 00:22:00,080
at it

00:21:56,720 --> 00:22:02,559
and it automatically finds buffer

00:22:00,080 --> 00:22:06,480
overflow exploits

00:22:02,559 --> 00:22:10,159
uh that's one thing you can use it for

00:22:06,480 --> 00:22:12,320
we have used that to analyze behavior of

00:22:10,159 --> 00:22:15,919
dynamic compilers

00:22:12,320 --> 00:22:19,039
that work is all open source but

00:22:15,919 --> 00:22:22,320
there is a number of challenges that

00:22:19,039 --> 00:22:23,520
all bump against the same fundamental

00:22:22,320 --> 00:22:27,120
fact

00:22:23,520 --> 00:22:30,320
that for cpu binary code this goes

00:22:27,120 --> 00:22:34,720
through this vel grind

00:22:30,320 --> 00:22:37,520
lifter library which

00:22:34,720 --> 00:22:39,200
apart from being a monster lamp of c

00:22:37,520 --> 00:22:43,840
plus plus

00:22:39,200 --> 00:22:48,320
is itself a non-symbolic beast

00:22:43,840 --> 00:22:51,039
which on self-modifying code ends up

00:22:48,320 --> 00:22:51,039
not useful

00:22:51,360 --> 00:22:57,679
vel grind just plain doesn't

00:22:54,640 --> 00:22:59,760
know about certain things

00:22:57,679 --> 00:23:00,720
we talked at the beginning of this

00:22:59,760 --> 00:23:03,120
lecture

00:23:00,720 --> 00:23:04,240
about race conditions due to weak

00:23:03,120 --> 00:23:08,080
consistency

00:23:04,240 --> 00:23:12,000
on power and on risk five

00:23:08,080 --> 00:23:14,640
it's not gonna help you there well

00:23:12,000 --> 00:23:16,480
risk five it doesn't know about risk

00:23:14,640 --> 00:23:22,080
five period

00:23:16,480 --> 00:23:25,039
uh which brings us to sale

00:23:22,080 --> 00:23:27,840
sail is a language for rigorous

00:23:25,039 --> 00:23:30,799
specification of isas

00:23:27,840 --> 00:23:32,640
it's designed to be accessible to

00:23:30,799 --> 00:23:36,080
engineers

00:23:32,640 --> 00:23:39,280
without a killing learning curve

00:23:36,080 --> 00:23:42,559
it's real in the sense that those

00:23:39,280 --> 00:23:45,279
models are precise

00:23:42,559 --> 00:23:45,279
and complete

00:23:46,000 --> 00:23:51,919
it's the language the risk five folks

00:23:49,200 --> 00:23:52,640
write the normative definition of their

00:23:51,919 --> 00:23:56,080
isa

00:23:52,640 --> 00:23:58,720
in now that being aside

00:23:56,080 --> 00:24:00,320
the argument here is about availability

00:23:58,720 --> 00:24:03,679
of tools

00:24:00,320 --> 00:24:04,320
so you want enough precision to reason

00:24:03,679 --> 00:24:08,159
about

00:24:04,320 --> 00:24:11,360
cache race conditions the truth is

00:24:08,159 --> 00:24:14,640
all this vendor work is closed and

00:24:11,360 --> 00:24:18,000
even a farm published a rigorous

00:24:14,640 --> 00:24:21,279
spec in the around language there's no

00:24:18,000 --> 00:24:24,320
open tools for

00:24:21,279 --> 00:24:27,440
processing that language so there is

00:24:24,320 --> 00:24:30,720
really only one contender

00:24:27,440 --> 00:24:31,200
because of this the latest generation of

00:24:30,720 --> 00:24:33,760
our

00:24:31,200 --> 00:24:34,799
synthetic tool chain which we're working

00:24:33,760 --> 00:24:38,559
on

00:24:34,799 --> 00:24:39,919
takes sale for defining instruction

00:24:38,559 --> 00:24:43,039
behaviors

00:24:39,919 --> 00:24:44,000
at this point i don't know if we want to

00:24:43,039 --> 00:24:46,720
migrate

00:24:44,000 --> 00:24:48,080
there completely and synthesize

00:24:46,720 --> 00:24:51,279
everything from sale

00:24:48,080 --> 00:24:52,400
because some things are not naturally

00:24:51,279 --> 00:24:56,720
expressible

00:24:52,400 --> 00:24:58,880
uh it's a functional chain and

00:24:56,720 --> 00:25:00,159
in the source you have functions like

00:24:58,880 --> 00:25:03,679
the the code

00:25:00,159 --> 00:25:07,360
and the execute but in the end

00:25:03,679 --> 00:25:09,200
it's just function composition and

00:25:07,360 --> 00:25:10,880
after that's done you end up with a

00:25:09,200 --> 00:25:13,520
monolith without

00:25:10,880 --> 00:25:15,039
separate concepts of you know

00:25:13,520 --> 00:25:19,600
instruction format

00:25:15,039 --> 00:25:22,799
instruction assembly syntax etc

00:25:19,600 --> 00:25:28,080
so for now uh

00:25:22,799 --> 00:25:31,600
my bin utils stay there with arch c

00:25:28,080 --> 00:25:32,320
uh we just invoke sale with the smt back

00:25:31,600 --> 00:25:35,279
end

00:25:32,320 --> 00:25:36,799
and it turns out these smt leave

00:25:35,279 --> 00:25:40,320
definitions

00:25:36,799 --> 00:25:44,400
are similar enough or pretty similar

00:25:40,320 --> 00:25:44,400
to what we added to the vex engine

00:25:44,559 --> 00:25:50,320
let's summarize what we've got here is

00:25:48,000 --> 00:25:53,600
an open source system for automated

00:25:50,320 --> 00:25:56,960
reasoning about isas

00:25:53,600 --> 00:26:00,159
it's got a symbolic execution engine

00:25:56,960 --> 00:26:03,919
which works by combining smt

00:26:00,159 --> 00:26:07,200
and logic programming it reasons

00:26:03,919 --> 00:26:08,080
about behavior of machine code and it

00:26:07,200 --> 00:26:11,679
infers

00:26:08,080 --> 00:26:15,679
components of the compiler toolchain

00:26:11,679 --> 00:26:20,559
from machine readable isa spec

00:26:15,679 --> 00:26:23,039
it reads rgc and it reads sale

00:26:20,559 --> 00:26:25,679
we use this for construction of jit

00:26:23,039 --> 00:26:29,279
compilers

00:26:25,679 --> 00:26:32,559
which i says we did

00:26:29,279 --> 00:26:35,760
almost all of our validation on power

00:26:32,559 --> 00:26:38,799
and on risk 5 essays

00:26:35,760 --> 00:26:43,039
and we have had some limited success

00:26:38,799 --> 00:26:43,039
uh with autumn and with mix

00:26:43,360 --> 00:26:50,400
okay i hope there is still time for q a

00:26:48,559 --> 00:26:53,120
i'm trying to press the button to unmute

00:26:50,400 --> 00:26:56,480
can you hear me yes now i can hear you

00:26:53,120 --> 00:26:59,760
great yeah um thank you for that

00:26:56,480 --> 00:27:02,799
um we looked at

00:26:59,760 --> 00:27:03,679
uh rems because um for libresock we were

00:27:02,799 --> 00:27:06,960
looking for formal

00:27:03,679 --> 00:27:11,039
verification and

00:27:06,960 --> 00:27:14,880
we couldn't actually find the um

00:27:11,039 --> 00:27:18,240
the document that had generated the

00:27:14,880 --> 00:27:20,880
um the the formal specification or so it

00:27:18,240 --> 00:27:25,039
says it's also generated

00:27:20,880 --> 00:27:28,080
um but also um uh we found a bug

00:27:25,039 --> 00:27:31,440
in the uh uh divide uh

00:27:28,080 --> 00:27:36,000
overflow i think um

00:27:31,440 --> 00:27:37,600
he is he i i just wanted to

00:27:36,000 --> 00:27:40,960
ask you if you're aware of these these

00:27:37,600 --> 00:27:44,159
things where did you get the um

00:27:40,960 --> 00:27:47,840
the the actual xml document

00:27:44,159 --> 00:27:49,760
that generated the formal proofs in the

00:27:47,840 --> 00:27:53,279
first place

00:27:49,760 --> 00:27:56,960
uh that's a question for alistair raid

00:27:53,279 --> 00:27:58,080
not for me okay yeah because that's

00:27:56,960 --> 00:28:00,799
that's them i mean

00:27:58,080 --> 00:28:02,480
we are not the the rems group i just

00:28:00,799 --> 00:28:07,200
take the sale

00:28:02,480 --> 00:28:11,120
and run sale with uh minus smt

00:28:07,200 --> 00:28:13,679
uh and that just produces

00:28:11,120 --> 00:28:15,679
uh you know or we've done some

00:28:13,679 --> 00:28:18,399
experiments with with a uh

00:28:15,679 --> 00:28:20,080
backhand and and if i go minus you

00:28:18,399 --> 00:28:23,360
know that that will give me some

00:28:20,080 --> 00:28:27,279
some call definitions

00:28:23,360 --> 00:28:30,480
uh uh you know so so we we just process

00:28:27,279 --> 00:28:33,840
the the sale so it's it's like way

00:28:30,480 --> 00:28:35,440
down the line and what happens between

00:28:33,840 --> 00:28:37,440
the xml it's it's

00:28:35,440 --> 00:28:38,720
i mean it's it's really interest it's

00:28:37,440 --> 00:28:41,600
it's it's it's a really

00:28:38,720 --> 00:28:41,840
interesting question and i was like can

00:28:41,600 --> 00:28:44,640
i

00:28:41,840 --> 00:28:45,200
get to to that xml source myself just to

00:28:44,640 --> 00:28:48,159
look at it

00:28:45,200 --> 00:28:49,200
out of curiosity but i never got around

00:28:48,159 --> 00:28:52,480
to actually

00:28:49,200 --> 00:28:54,799
you know to actually ask because

00:28:52,480 --> 00:28:55,760
it's an interesting thing because we had

00:28:54,799 --> 00:28:59,120
to extract

00:28:55,760 --> 00:29:02,240
the um the pseudo code from

00:28:59,120 --> 00:29:03,600
the pdf specifications ourselves and

00:29:02,240 --> 00:29:06,320
found there were actually errors in it

00:29:03,600 --> 00:29:07,840
or ambiguity so i'm i was wondering how

00:29:06,320 --> 00:29:10,240
it sort of breaks the question of course

00:29:07,840 --> 00:29:11,039
if the if your source material your your

00:29:10,240 --> 00:29:13,200
specification

00:29:11,039 --> 00:29:15,360
is wrong you then the formal proofs are

00:29:13,200 --> 00:29:19,200
going to be wrong oh absolutely

00:29:15,360 --> 00:29:22,640
absolutely this is why the this is why i

00:29:19,200 --> 00:29:25,600
i think and this is where i'm going with

00:29:22,640 --> 00:29:26,480
with this whole presentation is that

00:29:25,600 --> 00:29:28,559
maybe

00:29:26,480 --> 00:29:30,080
we should raise the question of what we

00:29:28,559 --> 00:29:33,039
should do like

00:29:30,080 --> 00:29:35,039
whether we should we should go the route

00:29:33,039 --> 00:29:35,679
similar to what the risk five people

00:29:35,039 --> 00:29:38,720
have done

00:29:35,679 --> 00:29:40,240
right so so they've got they they

00:29:38,720 --> 00:29:43,919
started

00:29:40,240 --> 00:29:47,200
from a massive simplification

00:29:43,919 --> 00:29:50,559
of uh the isa spec

00:29:47,200 --> 00:29:54,080
written in like human english

00:29:50,559 --> 00:29:57,760
right and uh they got it uh

00:29:54,080 --> 00:30:01,200
you know from six thousand pages of uh

00:29:57,760 --> 00:30:05,039
the arm i say they are like user level

00:30:01,200 --> 00:30:06,000
spec is like what it is 26 or 28 pages

00:30:05,039 --> 00:30:08,960
of english

00:30:06,000 --> 00:30:13,039
something like that so it's like eight

00:30:08,960 --> 00:30:15,840
binary orders of magnitude the

00:30:13,039 --> 00:30:16,480
gain right but then they said okay no no

00:30:15,840 --> 00:30:21,360
no no

00:30:16,480 --> 00:30:21,360
we have this uh simulator

00:30:21,440 --> 00:30:27,039
the spike uh which is uh

00:30:24,720 --> 00:30:28,640
written in c and that's the normative

00:30:27,039 --> 00:30:32,240
thing you know that's that's

00:30:28,640 --> 00:30:33,679
if if the if that simulated model

00:30:32,240 --> 00:30:36,880
behaves like this

00:30:33,679 --> 00:30:38,399
then it takes precedence and uh the

00:30:36,880 --> 00:30:41,039
english specification is

00:30:38,399 --> 00:30:41,679
is actually not the normative thing it's

00:30:41,039 --> 00:30:44,240
it's just

00:30:41,679 --> 00:30:46,399
and then they started putting in you

00:30:44,240 --> 00:30:48,880
know explanation of history and

00:30:46,399 --> 00:30:50,399
like background of why certain things

00:30:48,880 --> 00:30:54,480
are done and and

00:30:50,399 --> 00:30:57,120
the normative part is is the actual um

00:30:54,480 --> 00:30:57,840
simulated model and then i said no no no

00:30:57,120 --> 00:31:00,880
no no no

00:30:57,840 --> 00:31:04,559
well now this is outdated because now

00:31:00,880 --> 00:31:06,960
we have everything written in sale

00:31:04,559 --> 00:31:08,320
so that is the actual definition of the

00:31:06,960 --> 00:31:11,360
isa

00:31:08,320 --> 00:31:13,519
so maybe in the open power space we

00:31:11,360 --> 00:31:16,640
should say okay well

00:31:13,519 --> 00:31:19,679
maybe we should we should actually have

00:31:16,640 --> 00:31:20,880
uh a formal specification and and then

00:31:19,679 --> 00:31:23,919
everything else is

00:31:20,880 --> 00:31:25,840
is not normative because um

00:31:23,919 --> 00:31:27,039
in the book it's uh right like in the

00:31:25,840 --> 00:31:30,320
green um

00:31:27,039 --> 00:31:33,519
cloth book itself it just doesn't say

00:31:30,320 --> 00:31:36,320
certain things no no it doesn't

00:31:33,519 --> 00:31:39,039
you know like especially when you're

00:31:36,320 --> 00:31:42,000
talking cash coherence

00:31:39,039 --> 00:31:44,799
it just it's just totally totally silent

00:31:42,000 --> 00:31:47,519
what will happen

00:31:44,799 --> 00:31:48,000
you know when when you have out of order

00:31:47,519 --> 00:31:51,440
right

00:31:48,000 --> 00:31:52,000
like this is this is this is not x86

00:31:51,440 --> 00:31:54,320
where

00:31:52,000 --> 00:31:56,480
everything is just consistent with

00:31:54,320 --> 00:31:59,279
purely sequential execution

00:31:56,480 --> 00:32:00,399
right you you have software visible

00:31:59,279 --> 00:32:03,120
effects of of

00:32:00,399 --> 00:32:05,200
out of order and and how the out of

00:32:03,120 --> 00:32:07,440
order pipeline how it

00:32:05,200 --> 00:32:09,120
you know how it is connected to the to

00:32:07,440 --> 00:32:12,159
the uh

00:32:09,120 --> 00:32:15,279
store buffers for example right and d

00:32:12,159 --> 00:32:15,600
d cash b d d c b z which is for clearing

00:32:15,279 --> 00:32:18,960
uh

00:32:15,600 --> 00:32:22,000
uh uh a cash row yeah

00:32:18,960 --> 00:32:23,200
yeah yeah yeah yeah yeah yeah it's it's

00:32:22,000 --> 00:32:26,640
just ambiguous

00:32:23,200 --> 00:32:27,679
it doesn't like like that that pseudo

00:32:26,640 --> 00:32:32,080
code

00:32:27,679 --> 00:32:35,039
uh i mean it's very detailed compared to

00:32:32,080 --> 00:32:35,679
i don't know that the amd manual for

00:32:35,039 --> 00:32:39,600
example

00:32:35,679 --> 00:32:43,440
for for for the the x86 is

00:32:39,600 --> 00:32:45,840
is is just that there isn't really

00:32:43,440 --> 00:32:47,440
anything to to start with it's just

00:32:45,840 --> 00:32:50,559
plain english

00:32:47,440 --> 00:32:53,600
um but still it it just

00:32:50,559 --> 00:32:55,440
doesn't clarify uh and and

00:32:53,600 --> 00:32:57,120
if you if you want to have i've been

00:32:55,440 --> 00:32:58,080
asking quite lots of questions of paul

00:32:57,120 --> 00:33:00,399
and paul has been

00:32:58,080 --> 00:33:01,279
fight for clarifying things for for us

00:33:00,399 --> 00:33:04,320
on the uh

00:33:01,279 --> 00:33:07,440
open power hdl uh course mailing list

00:33:04,320 --> 00:33:10,880
um yeah which is there's just stuff that

00:33:07,440 --> 00:33:13,279
the the normative reference is the ibm

00:33:10,880 --> 00:33:14,960
power 9 implementation from which the

00:33:13,279 --> 00:33:16,960
spec sort of written

00:33:14,960 --> 00:33:19,039
behind behind things so they and the

00:33:16,960 --> 00:33:20,399
fact that there's not been very many

00:33:19,039 --> 00:33:22,720
implementers outside of that until

00:33:20,399 --> 00:33:25,440
michael rotten liebersock

00:33:22,720 --> 00:33:25,760
these questions have just not been asked

00:33:25,440 --> 00:33:29,200
so

00:33:25,760 --> 00:33:32,320
um yeah yeah but that's

00:33:29,200 --> 00:33:35,840
that's uh apparently that that is

00:33:32,320 --> 00:33:36,840
all um this is exactly the thing that

00:33:35,840 --> 00:33:40,240
started the

00:33:36,840 --> 00:33:42,399
rem's work right because that that these

00:33:40,240 --> 00:33:45,840
are exactly the questions like well

00:33:42,399 --> 00:33:48,320
what is the allow oil behavior here if i

00:33:45,840 --> 00:33:49,519
you know and and that's for compilers

00:33:48,320 --> 00:33:52,320
too right because

00:33:49,519 --> 00:33:53,360
you cannot just just uh use the

00:33:52,320 --> 00:33:55,840
traditional

00:33:53,360 --> 00:33:58,320
way of of testing a compiler right like

00:33:55,840 --> 00:34:03,120
oh okay well i just run it on this and

00:33:58,320 --> 00:34:03,120
and it works well yeah

00:34:03,440 --> 00:34:05,600
then

00:34:06,480 --> 00:34:09,679
run the same code on a different

00:34:08,399 --> 00:34:13,200
processor and

00:34:09,679 --> 00:34:16,800
and it is it still behaves within

00:34:13,200 --> 00:34:20,639
what the what the spec allows and it

00:34:16,800 --> 00:34:23,760
just is buggy yeah i remembered um

00:34:20,639 --> 00:34:25,679
um there's an example with uh pico risk

00:34:23,760 --> 00:34:29,119
with their rv formal written by

00:34:25,679 --> 00:34:31,520
uh clifford wolf the one person who

00:34:29,119 --> 00:34:34,560
tested it they tested for a customer

00:34:31,520 --> 00:34:34,800
and they did something where there was

00:34:34,560 --> 00:34:37,359
an

00:34:34,800 --> 00:34:37,919
interaction between two finite state

00:34:37,359 --> 00:34:42,399
machines

00:34:37,919 --> 00:34:44,720
so when a div unit finished it corrupted

00:34:42,399 --> 00:34:48,000
one specific instruction afterwards but

00:34:44,720 --> 00:34:50,560
only in one particular pipeline

00:34:48,000 --> 00:34:51,760
because there were the the the div unit

00:34:50,560 --> 00:34:53,520
had left something

00:34:51,760 --> 00:34:55,520
some state in their implementation had

00:34:53,520 --> 00:34:58,960
been left which

00:34:55,520 --> 00:35:03,359
corrupted a a completely different

00:34:58,960 --> 00:35:06,400
um unit not not related to div at all

00:35:03,359 --> 00:35:08,640
oh yes yes yes yes yes yes i remember

00:35:06,400 --> 00:35:11,760
that one yeah clifford

00:35:08,640 --> 00:35:14,599
likes to yeah yeah yeah yeah yeah yeah

00:35:11,760 --> 00:35:16,079
and it's like and it's like you you have

00:35:14,599 --> 00:35:19,359
absolutely no

00:35:16,079 --> 00:35:21,200
idea like it you know

00:35:19,359 --> 00:35:24,640
you look at it and it appears like well

00:35:21,200 --> 00:35:24,640
what is the connection here

00:35:24,880 --> 00:35:29,040
yeah yeah you get really surprising bugs

00:35:28,560 --> 00:35:32,960
and

00:35:29,040 --> 00:35:34,800
good luck debugging them when it only

00:35:32,960 --> 00:35:37,040
i mean we're we're talking about race

00:35:34,800 --> 00:35:40,560
conditions right and very

00:35:37,040 --> 00:35:43,839
rare corner cases so it's only under

00:35:40,560 --> 00:35:45,760
load when you have actual you know 100

00:35:43,839 --> 00:35:50,560
cores

00:35:45,760 --> 00:35:50,560
under production load and like once in

00:35:51,280 --> 00:35:54,320
10 billion

00:35:55,680 --> 00:36:01,599
you know the executions of a path it

00:35:58,800 --> 00:36:05,280
actually breaks and and you try to

00:36:01,599 --> 00:36:09,119
to reproduce this breaking case and and

00:36:05,280 --> 00:36:09,119
you cannot right because it's just so

00:36:10,839 --> 00:36:14,480
rare um

00:36:12,800 --> 00:36:17,839
no i totally get the importance of the

00:36:14,480 --> 00:36:17,839
formal verification stuff

00:36:20,400 --> 00:36:24,320

YouTube URL: https://www.youtube.com/watch?v=Rse2n9zGx5w


