Title: Building Cache Coherent, Heterogeneous-ISA Processors Using P-Mesh - Jonathan Balkind
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	Building Cache Coherent, Heterogeneous-ISA Processors Using P-Mesh - Jonathan Balkind, University of California, Santa Barbara

Speakers: Jonathan Balkind

P-Mesh is the manycore cache coherence system underlying the OpenPiton research platform, which originally used the SPARCv9 ISA. A number of extensions to P-Mesh were needed to build the Bring Your Own Core (BYOC) platform, which added support for building heterogeneous-ISA processors made of cores of new, open ISAs like OpenPOWER. In this talk, Jonathan will introduce P-Mesh and the changes made to turn it into an ISA-agnostic memory system. Jonathan will detail the specific changes needed to support different ISAs, the new Transaction-Response Interface (TRI) for connecting cores, and initial efforts to support cores using the OpenPOWER ISA. Jonathan will also discuss efforts to connect multiple cores of different ISAs to build a single heterogeneous-ISA system.
Captions: 
	00:00:01,120 --> 00:00:05,680
all right i'm going to go ahead

00:00:03,439 --> 00:00:07,359
and get started and thank you for coming

00:00:05,680 --> 00:00:08,240
to the session my name is jonathan

00:00:07,359 --> 00:00:10,639
balkin

00:00:08,240 --> 00:00:12,719
i am a new assistant professor at the

00:00:10,639 --> 00:00:14,880
university of california santa barbara

00:00:12,719 --> 00:00:17,520
um i'm a professor of computer science

00:00:14,880 --> 00:00:19,600
i'm in particular computer architecture

00:00:17,520 --> 00:00:20,720
i'm going to be presenting today on an

00:00:19,600 --> 00:00:23,600
aspect of

00:00:20,720 --> 00:00:24,480
our system open piton which we have been

00:00:23,600 --> 00:00:26,720
developing

00:00:24,480 --> 00:00:28,800
um throughout my phd at princeton um i

00:00:26,720 --> 00:00:32,320
was the lead architect of piton

00:00:28,800 --> 00:00:34,399
over a period of about six years

00:00:32,320 --> 00:00:35,440
um and we started on the project back in

00:00:34,399 --> 00:00:36,559
00:00:35,440 --> 00:00:38,320
so there's been a large number of people

00:00:36,559 --> 00:00:39,280
who worked on this and so this is a big

00:00:38,320 --> 00:00:40,960
collaboration

00:00:39,280 --> 00:00:42,719
uh presenting work done by a lot of

00:00:40,960 --> 00:00:46,480
people and

00:00:42,719 --> 00:00:49,680
openpton is a minicore research platform

00:00:46,480 --> 00:00:51,440
and underlying openpton is a scalable

00:00:49,680 --> 00:00:51,840
cache coherent memory system that we

00:00:51,440 --> 00:00:54,320
call

00:00:51,840 --> 00:00:55,360
pmesh um and so i'm gonna be talking

00:00:54,320 --> 00:00:58,239
about today

00:00:55,360 --> 00:00:59,120
is pmesh itself and how to use pmesh to

00:00:58,239 --> 00:01:01,359
build

00:00:59,120 --> 00:01:03,199
cache coherent heterogeneous isa

00:01:01,359 --> 00:01:08,159
processors

00:01:03,199 --> 00:01:10,159
so my clicker isn't working just yet

00:01:08,159 --> 00:01:12,000
so pnesh as i said is the cache

00:01:10,159 --> 00:01:12,960
coherence system which underlies open

00:01:12,000 --> 00:01:14,960
piton

00:01:12,960 --> 00:01:16,159
and openvitan is a system for building

00:01:14,960 --> 00:01:17,920
many core socs

00:01:16,159 --> 00:01:19,520
and it started out as a platform to

00:01:17,920 --> 00:01:20,880
enable our research ideas

00:01:19,520 --> 00:01:23,439
and has kind of grown and become more

00:01:20,880 --> 00:01:25,200
mature and usable and so you know now if

00:01:23,439 --> 00:01:26,560
you're interested in building a

00:01:25,200 --> 00:01:28,640
coherent soc then you might be

00:01:26,560 --> 00:01:29,360
interested in using pmesh as a coherent

00:01:28,640 --> 00:01:32,159
system

00:01:29,360 --> 00:01:33,200
um for that um now you'll notice i

00:01:32,159 --> 00:01:33,920
mentioned many core rather than

00:01:33,200 --> 00:01:35,759
multi-core

00:01:33,920 --> 00:01:37,759
um our research in general has focused

00:01:35,759 --> 00:01:40,720
on extreme scalability

00:01:37,759 --> 00:01:42,320
and so we have designed the pmesh

00:01:40,720 --> 00:01:44,000
coherence system to have scalability and

00:01:42,320 --> 00:01:45,119
addressing up to half a billion cores

00:01:44,000 --> 00:01:46,799
you might never want to build that

00:01:45,119 --> 00:01:47,119
system but the idea is that this enables

00:01:46,799 --> 00:01:49,520
us

00:01:47,119 --> 00:01:51,040
to test out the you know problems that

00:01:49,520 --> 00:01:54,880
come when you try to

00:01:51,040 --> 00:01:57,600
scale to very large scale um and

00:01:54,880 --> 00:01:58,719
the uh picture on the right here is kind

00:01:57,600 --> 00:02:00,719
of like ap mesh

00:01:58,719 --> 00:02:02,159
system like a system with you know some

00:02:00,719 --> 00:02:04,000
cores and and so on

00:02:02,159 --> 00:02:06,240
and then the orange box is the p mesh

00:02:04,000 --> 00:02:08,000
part and so

00:02:06,240 --> 00:02:09,520
you've got kind of some layers of cache

00:02:08,000 --> 00:02:11,440
to provide you with your coherence

00:02:09,520 --> 00:02:13,120
and we have three physical networks on

00:02:11,440 --> 00:02:15,120
chip which enable kind of deadlock

00:02:13,120 --> 00:02:17,920
freedom and data movement efficiently

00:02:15,120 --> 00:02:18,959
um and the idea is that you can kind of

00:02:17,920 --> 00:02:20,400
connect a variety of different things

00:02:18,959 --> 00:02:21,280
and build a really large system around

00:02:20,400 --> 00:02:22,879
this

00:02:21,280 --> 00:02:24,319
and so you'll notice these kind of red

00:02:22,879 --> 00:02:26,239
boxes at the bottom the different

00:02:24,319 --> 00:02:27,440
cores that can connect into the system

00:02:26,239 --> 00:02:28,640
and the way that we connect these is

00:02:27,440 --> 00:02:30,959
using an interface that we call the

00:02:28,640 --> 00:02:33,120
transaction response interface

00:02:30,959 --> 00:02:34,560
and the idea here is that we can be kind

00:02:33,120 --> 00:02:36,160
of configurable and connect new types of

00:02:34,560 --> 00:02:37,920
cores that we've never seen before by

00:02:36,160 --> 00:02:39,519
building this interface

00:02:37,920 --> 00:02:41,760
and so far we've connected more than 10

00:02:39,519 --> 00:02:44,800
different cores with five different isas

00:02:41,760 --> 00:02:46,959
into pmesh and we specifically have

00:02:44,800 --> 00:02:48,160
support for heterogeneous isa systems

00:02:46,959 --> 00:02:50,080
i'll be talking about today

00:02:48,160 --> 00:02:51,920
so you can actually have the cores that

00:02:50,080 --> 00:02:53,280
i note here living together in a single

00:02:51,920 --> 00:02:54,720
system

00:02:53,280 --> 00:02:56,160
on top of that we support a variety of

00:02:54,720 --> 00:02:57,920
different peripherals and accelerators

00:02:56,160 --> 00:02:59,680
using standard interfaces

00:02:57,920 --> 00:03:01,840
and that you can connect into pmesh as

00:02:59,680 --> 00:03:03,680
well

00:03:01,840 --> 00:03:06,000
so why would you want to build

00:03:03,680 --> 00:03:08,159
heterogeneous isa systems at all

00:03:06,000 --> 00:03:09,519
you know the norm is that you build a

00:03:08,159 --> 00:03:12,000
chip with multiple cores and those have

00:03:09,519 --> 00:03:13,680
a single isa single micro architecture

00:03:12,000 --> 00:03:15,280
um and you know that's easy to do in

00:03:13,680 --> 00:03:17,200
some sense you can stamp down the same

00:03:15,280 --> 00:03:18,879
block multiple times in your chip

00:03:17,200 --> 00:03:20,720
um and you know you know the behaviors

00:03:18,879 --> 00:03:22,800
and then it's easier to validate

00:03:20,720 --> 00:03:24,319
um but you know within the last roughly

00:03:22,800 --> 00:03:25,680
10 years it's become more common to

00:03:24,319 --> 00:03:27,040
build single isa heterogeneous

00:03:25,680 --> 00:03:28,560
microarchitecture

00:03:27,040 --> 00:03:30,640
processors so things like arms big

00:03:28,560 --> 00:03:32,640
little um where you can kind of

00:03:30,640 --> 00:03:33,840
extend your dvfs curve that you see on

00:03:32,640 --> 00:03:35,519
the right here

00:03:33,840 --> 00:03:37,440
to get more performance or power

00:03:35,519 --> 00:03:39,760
benefits based on what your application

00:03:37,440 --> 00:03:40,959
in particular needs so if at the moment

00:03:39,760 --> 00:03:42,319
you really care about performance you

00:03:40,959 --> 00:03:42,879
can get a crank up move to the bigger

00:03:42,319 --> 00:03:44,480
core

00:03:42,879 --> 00:03:45,920
you know move your dpfs all the way up

00:03:44,480 --> 00:03:47,120
and if you want to save power you can

00:03:45,920 --> 00:03:48,640
you can move down to the smaller cores

00:03:47,120 --> 00:03:51,280
and take advantage of those

00:03:48,640 --> 00:03:52,560
uh heterogeneous microarchitectures um

00:03:51,280 --> 00:03:53,280
but the big question is what about the

00:03:52,560 --> 00:03:54,959
isa

00:03:53,280 --> 00:03:57,120
are there particular features to

00:03:54,959 --> 00:03:58,720
particular isas which have

00:03:57,120 --> 00:04:00,080
uh you know benefits that we could also

00:03:58,720 --> 00:04:01,840
take advantage of you know we're in the

00:04:00,080 --> 00:04:03,360
post mirror world we want to try and get

00:04:01,840 --> 00:04:04,959
you know the the small benefits that we

00:04:03,360 --> 00:04:07,280
can get where we can get them

00:04:04,959 --> 00:04:08,640
and so and there's been prior work in

00:04:07,280 --> 00:04:10,720
the architecture realm

00:04:08,640 --> 00:04:13,519
um which is shown in particular this

00:04:10,720 --> 00:04:14,959
chart here is from ashish vanca and dean

00:04:13,519 --> 00:04:16,560
which has shown that you can get

00:04:14,959 --> 00:04:17,359
performance and energy efficiency

00:04:16,560 --> 00:04:19,359
benefits

00:04:17,359 --> 00:04:21,040
by migrating your application between

00:04:19,359 --> 00:04:24,000
cores of different isas

00:04:21,040 --> 00:04:25,600
so it turns out that applications and

00:04:24,000 --> 00:04:28,160
phases of applications

00:04:25,600 --> 00:04:28,800
have affinities to particular isas and

00:04:28,160 --> 00:04:31,040
so if you

00:04:28,800 --> 00:04:32,160
care about you know getting your

00:04:31,040 --> 00:04:34,880
performance then

00:04:32,160 --> 00:04:36,880
you will want to have your application

00:04:34,880 --> 00:04:38,560
run on a particular isa for

00:04:36,880 --> 00:04:39,919
you know a certain period of time so you

00:04:38,560 --> 00:04:40,639
can see this chart on the right here

00:04:39,919 --> 00:04:43,199
showing

00:04:40,639 --> 00:04:44,960
which isa will you get the maximum

00:04:43,199 --> 00:04:47,759
performance for for which proportion of

00:04:44,960 --> 00:04:49,840
the execution time of the application

00:04:47,759 --> 00:04:51,120
and then they also said well it turns

00:04:49,840 --> 00:04:51,919
out that these differ depending on your

00:04:51,120 --> 00:04:53,440
goal

00:04:51,919 --> 00:04:55,440
so if you care a lot about energy

00:04:53,440 --> 00:04:57,280
efficiency then the

00:04:55,440 --> 00:04:58,720
isas that you want to make use of might

00:04:57,280 --> 00:05:01,360
be different from

00:04:58,720 --> 00:05:02,560
uh the if you care about performance um

00:05:01,360 --> 00:05:03,919
and you know you can imagine that you

00:05:02,560 --> 00:05:05,440
know there's particular issues that have

00:05:03,919 --> 00:05:07,600
high code and state there's particular

00:05:05,440 --> 00:05:09,600
iss that have you know vector extensions

00:05:07,600 --> 00:05:10,800
different features that would be you

00:05:09,600 --> 00:05:12,000
know advantageous for different

00:05:10,800 --> 00:05:14,160
applications

00:05:12,000 --> 00:05:15,600
and so and we want to try and take

00:05:14,160 --> 00:05:17,039
advantage of that

00:05:15,600 --> 00:05:20,160
and move our applications around for the

00:05:17,039 --> 00:05:21,600
best performance and energy efficiency

00:05:20,160 --> 00:05:22,960
now the issue here is that in terms of

00:05:21,600 --> 00:05:24,240
architecture research the work was done

00:05:22,960 --> 00:05:25,440
in simulation because there isn't

00:05:24,240 --> 00:05:26,000
actually any hardware out there that can

00:05:25,440 --> 00:05:29,440
give you

00:05:26,000 --> 00:05:31,919
kind of a fine grain you know high uh

00:05:29,440 --> 00:05:33,360
high performance low latency uh cash

00:05:31,919 --> 00:05:36,560
coherent fabric

00:05:33,360 --> 00:05:39,199
for quarter different isas and so

00:05:36,560 --> 00:05:40,479
um in instead you know systems people

00:05:39,199 --> 00:05:41,039
saw these kinds of results and said why

00:05:40,479 --> 00:05:43,280
don't we

00:05:41,039 --> 00:05:44,479
try and build uh heterogeneous isa

00:05:43,280 --> 00:05:46,000
operating systems with the hardware that

00:05:44,479 --> 00:05:47,919
we do have available

00:05:46,000 --> 00:05:49,600
um and so there's a couple of different

00:05:47,919 --> 00:05:51,360
a couple of different examples here

00:05:49,600 --> 00:05:52,639
one of them is popcorn linux and in

00:05:51,360 --> 00:05:52,960
general that's been kind of you take a

00:05:52,639 --> 00:05:55,280
big

00:05:52,960 --> 00:05:56,800
xeon server and you plug in an arm pcie

00:05:55,280 --> 00:05:58,240
card and then you try and build an

00:05:56,800 --> 00:05:59,440
operating system will let you transition

00:05:58,240 --> 00:06:03,039
applications between

00:05:59,440 --> 00:06:05,440
the two isas using pcie message passing

00:06:03,039 --> 00:06:07,840
and software-based coherence

00:06:05,440 --> 00:06:08,639
another one is k2 which can run on arm

00:06:07,840 --> 00:06:10,880
and thumb

00:06:08,639 --> 00:06:12,639
and um it would also use software

00:06:10,880 --> 00:06:14,160
coherence and so these are relatively

00:06:12,639 --> 00:06:15,199
heavy weight mechanisms for

00:06:14,160 --> 00:06:17,759
uh providing coherence for your

00:06:15,199 --> 00:06:19,840
application um and

00:06:17,759 --> 00:06:21,280
you know we kind of asked is there a way

00:06:19,840 --> 00:06:22,639
that we could build a cache coherent

00:06:21,280 --> 00:06:23,600
heterogeneous is a system

00:06:22,639 --> 00:06:25,680
so that we could realize the

00:06:23,600 --> 00:06:26,720
architectural benefits and improve the

00:06:25,680 --> 00:06:28,720
os's

00:06:26,720 --> 00:06:30,960
um to be able to kind of have this

00:06:28,720 --> 00:06:33,120
capability um so that we could actually

00:06:30,960 --> 00:06:34,080
eek the most gains that we can of the

00:06:33,120 --> 00:06:37,039
hardware that we have available

00:06:34,080 --> 00:06:38,240
to us um and so we built a system that

00:06:37,039 --> 00:06:39,520
we call byoc

00:06:38,240 --> 00:06:41,600
for bring your own core because that's

00:06:39,520 --> 00:06:43,199
what we want people to do um

00:06:41,600 --> 00:06:44,880
and this was really kind of like a an

00:06:43,199 --> 00:06:45,919
extension to open piton an improvement

00:06:44,880 --> 00:06:47,440
to pmesh kind of

00:06:45,919 --> 00:06:49,599
you know new version of pmesh in some

00:06:47,440 --> 00:06:51,039
sense um and the reason that you might

00:06:49,599 --> 00:06:52,479
want to build this in terms of kind of

00:06:51,039 --> 00:06:54,639
an end user's needs

00:06:52,479 --> 00:06:56,160
um are the your you might have a

00:06:54,639 --> 00:06:57,120
particular application or a particular

00:06:56,160 --> 00:06:58,400
design need

00:06:57,120 --> 00:06:59,759
that can only be met if you bring

00:06:58,400 --> 00:07:00,479
together a course of different audiences

00:06:59,759 --> 00:07:03,680
so

00:07:00,479 --> 00:07:04,400
maybe you are you know in need of the

00:07:03,680 --> 00:07:05,680
the most

00:07:04,400 --> 00:07:06,960
performance you can get and you want to

00:07:05,680 --> 00:07:07,599
like really squeeze that or the energy

00:07:06,960 --> 00:07:09,759
efficiency

00:07:07,599 --> 00:07:10,800
but there are other needs so maybe you

00:07:09,759 --> 00:07:12,560
are in

00:07:10,800 --> 00:07:14,000
aerospace for example and you need to

00:07:12,560 --> 00:07:14,639
make use of an application which is high

00:07:14,000 --> 00:07:16,240
assurance

00:07:14,639 --> 00:07:18,080
it's been validated for particular

00:07:16,240 --> 00:07:19,440
purposes but you

00:07:18,080 --> 00:07:21,599
want to have some other cores that you

00:07:19,440 --> 00:07:24,240
know do some other function can you

00:07:21,599 --> 00:07:24,720
bring those together or maybe you want

00:07:24,240 --> 00:07:27,039
to

00:07:24,720 --> 00:07:28,479
um save as much money as possible and

00:07:27,039 --> 00:07:29,919
you want to you know you have particular

00:07:28,479 --> 00:07:31,360
course available to you you want to

00:07:29,919 --> 00:07:33,039
exploit

00:07:31,360 --> 00:07:34,880
the ones that you have available and as

00:07:33,039 --> 00:07:36,160
best you can and so the idea here is

00:07:34,880 --> 00:07:37,599
that we can build a system where you can

00:07:36,160 --> 00:07:40,160
bring together all those cores

00:07:37,599 --> 00:07:40,960
all together at once um and have them

00:07:40,160 --> 00:07:42,960
coexist

00:07:40,960 --> 00:07:44,479
and you know previously there was kind

00:07:42,960 --> 00:07:45,840
of only the capability to do this

00:07:44,479 --> 00:07:47,840
and for course of a single isa or a

00:07:45,840 --> 00:07:49,280
single microarchitecture um

00:07:47,840 --> 00:07:50,879
you know it's it's much easier for you

00:07:49,280 --> 00:07:51,440
to just kind of stamp out many of the

00:07:50,879 --> 00:07:54,080
same core

00:07:51,440 --> 00:07:55,599
many cores of the same isa um but we

00:07:54,080 --> 00:07:56,479
were building an open source cache clear

00:07:55,599 --> 00:08:00,000
memory system p

00:07:56,479 --> 00:08:02,240
mesh explicitly for heterogeneous ise

00:08:00,000 --> 00:08:03,759
on top of this we built this new core

00:08:02,240 --> 00:08:07,039
interface to cache currents we call it

00:08:03,759 --> 00:08:09,039
transaction response interface or tree

00:08:07,039 --> 00:08:10,800
and we actually built what we believe is

00:08:09,039 --> 00:08:12,560
the world's first open source

00:08:10,800 --> 00:08:14,800
general purpose heterogeneous is a

00:08:12,560 --> 00:08:16,639
processor and that's called juxtapeton

00:08:14,800 --> 00:08:18,879
and i'll talk a bit more about that

00:08:16,639 --> 00:08:20,479
shortly so the system that we were

00:08:18,879 --> 00:08:21,840
building office on top of is called

00:08:20,479 --> 00:08:24,240
openpton

00:08:21,840 --> 00:08:25,520
and openpton is an open source manicore

00:08:24,240 --> 00:08:26,720
research platform

00:08:25,520 --> 00:08:28,319
we've been it's been open source since

00:08:26,720 --> 00:08:30,160
2015 we've been doing development for

00:08:28,319 --> 00:08:33,039
about seven years at this point

00:08:30,160 --> 00:08:35,279
um and the idea is that we wanted to

00:08:33,039 --> 00:08:36,959
test our research ideas at princeton

00:08:35,279 --> 00:08:38,240
and once we got to certain point we said

00:08:36,959 --> 00:08:38,880
we have a great system that other people

00:08:38,240 --> 00:08:40,959
could use

00:08:38,880 --> 00:08:42,080
why don't we make this available um you

00:08:40,959 --> 00:08:43,760
know we validated

00:08:42,080 --> 00:08:45,760
at this point you know that we did the

00:08:43,760 --> 00:08:47,839
release we taped out the real chip

00:08:45,760 --> 00:08:50,640
um and so you know we actually have like

00:08:47,839 --> 00:08:52,560
a highly functioning system

00:08:50,640 --> 00:08:54,320
the uh platform itself is written in

00:08:52,560 --> 00:08:55,600
verlog rtl so you need to learn a new

00:08:54,320 --> 00:08:56,560
hardware description language to make

00:08:55,600 --> 00:08:58,000
use of it

00:08:56,560 --> 00:09:01,040
and as i mentioned the coherence system

00:08:58,000 --> 00:09:02,160
is designed to scale to extreme scale

00:09:01,040 --> 00:09:03,760
we try to provide a lot of

00:09:02,160 --> 00:09:04,800
configurability both in the cores that

00:09:03,760 --> 00:09:06,720
we provide

00:09:04,800 --> 00:09:09,040
and in the encore so that you can find

00:09:06,720 --> 00:09:12,320
the right design point for your idea

00:09:09,040 --> 00:09:13,519
and test out um you know at the design

00:09:12,320 --> 00:09:14,880
point you care about or just

00:09:13,519 --> 00:09:16,080
find you know the one that's going to be

00:09:14,880 --> 00:09:17,040
optimal for the metrics that you care

00:09:16,080 --> 00:09:20,160
about

00:09:17,040 --> 00:09:21,600
um we provided our validation suite so

00:09:20,160 --> 00:09:22,320
that you can you know go and modify

00:09:21,600 --> 00:09:23,600
pmesh

00:09:22,320 --> 00:09:25,360
and then check that you didn't break

00:09:23,600 --> 00:09:26,560
anything and we're making active use of

00:09:25,360 --> 00:09:27,440
that just now as we work on our new

00:09:26,560 --> 00:09:29,040
chips

00:09:27,440 --> 00:09:30,640
um and we also provide simulation with

00:09:29,040 --> 00:09:31,519
all of the major rolex simulators

00:09:30,640 --> 00:09:34,320
essentially

00:09:31,519 --> 00:09:35,360
um and we have the uh the companies who

00:09:34,320 --> 00:09:36,880
build these tools

00:09:35,360 --> 00:09:38,959
are coming along and using the openpton

00:09:36,880 --> 00:09:40,959
rtl and to test their tools

00:09:38,959 --> 00:09:42,240
and to test their tools at scale um

00:09:40,959 --> 00:09:44,000
because there aren't a lot of other

00:09:42,240 --> 00:09:45,279
examples of you know really highly

00:09:44,000 --> 00:09:47,600
scalable open source

00:09:45,279 --> 00:09:48,560
rtl designs out there and so you know

00:09:47,600 --> 00:09:49,680
people are coming along and adding

00:09:48,560 --> 00:09:50,080
support for their tools into the

00:09:49,680 --> 00:09:51,519
platform

00:09:50,080 --> 00:09:54,000
because they want to to test them out

00:09:51,519 --> 00:09:55,600
that way we also provide a census and

00:09:54,000 --> 00:09:57,920
back-end flow based on the

00:09:55,600 --> 00:10:00,080
piton chip that we taped out in ibm 32

00:09:57,920 --> 00:10:01,839
nanometer process back in 2015

00:10:00,080 --> 00:10:03,440
um which is a relatively unique thing to

00:10:01,839 --> 00:10:04,720
provide and that chip itself

00:10:03,440 --> 00:10:06,480
as i mentioned has been verified we have

00:10:04,720 --> 00:10:08,480
that that real trip in the lab

00:10:06,480 --> 00:10:10,160
and it works um we did a very thorough

00:10:08,480 --> 00:10:12,800
power and energy characterization

00:10:10,160 --> 00:10:14,480
that was published in hpca 2018 um and

00:10:12,800 --> 00:10:16,399
so you can get really good ground truth

00:10:14,480 --> 00:10:17,519
about the design you're trying to use

00:10:16,399 --> 00:10:19,519
in order to understand the power and

00:10:17,519 --> 00:10:21,920
energy behavior should have

00:10:19,519 --> 00:10:23,200
um we also provide the same platform on

00:10:21,920 --> 00:10:25,200
fpga

00:10:23,200 --> 00:10:27,440
and in both async and fpga we can run

00:10:25,200 --> 00:10:28,720
full stack multi-user deviant linux

00:10:27,440 --> 00:10:31,440
and you know that's that's on multiple

00:10:28,720 --> 00:10:31,440
isas too

00:10:31,600 --> 00:10:35,120
so openpton itself uh the pmesh system

00:10:34,240 --> 00:10:37,839
started out

00:10:35,120 --> 00:10:38,880
just with the opensport q1 core um and

00:10:37,839 --> 00:10:40,000
as you may know spark

00:10:38,880 --> 00:10:42,320
you know wasn't an active development

00:10:40,000 --> 00:10:43,279
anymore and we were interested in

00:10:42,320 --> 00:10:45,200
branching out and looking at this

00:10:43,279 --> 00:10:46,720
heterogeneous isa problem

00:10:45,200 --> 00:10:48,560
but the system we design had kind of a

00:10:46,720 --> 00:10:49,600
number of spark specific specializations

00:10:48,560 --> 00:10:51,680
it had certain kind of

00:10:49,600 --> 00:10:52,640
core specific microarchitecture specific

00:10:51,680 --> 00:10:54,000
specializations

00:10:52,640 --> 00:10:55,120
and so the big question was how do we

00:10:54,000 --> 00:10:56,320
connect other cores and how do we

00:10:55,120 --> 00:10:58,079
support other isas

00:10:56,320 --> 00:11:00,959
in a way that's flexible and allows kind

00:10:58,079 --> 00:11:03,120
of anybody to bring any cores

00:11:00,959 --> 00:11:04,959
now when we started this project we

00:11:03,120 --> 00:11:06,240
started open piton as a project

00:11:04,959 --> 00:11:08,320
we only really had the cores in the

00:11:06,240 --> 00:11:10,079
first two columns available to us

00:11:08,320 --> 00:11:11,360
that open source that you know we could

00:11:10,079 --> 00:11:13,279
potentially work from

00:11:11,360 --> 00:11:14,560
um and based on our needs you know there

00:11:13,279 --> 00:11:15,760
was only really one that kind of met

00:11:14,560 --> 00:11:17,519
what we wanted

00:11:15,760 --> 00:11:18,959
but today there are far more cores and

00:11:17,519 --> 00:11:20,240
so we really you know want to

00:11:18,959 --> 00:11:21,920
take advantage of this re-emergence of

00:11:20,240 --> 00:11:23,839
open source hardware i mean we're kind

00:11:21,920 --> 00:11:25,920
of part of this vanguard is pushing this

00:11:23,839 --> 00:11:27,279
um and be able to support as many cores

00:11:25,920 --> 00:11:29,680
as we can and try and build something

00:11:27,279 --> 00:11:32,880
that is you know usable by many people

00:11:29,680 --> 00:11:35,440
um and is very flexible

00:11:32,880 --> 00:11:37,120
and so there were several ways that we

00:11:35,440 --> 00:11:38,320
you know could conceive of connecting

00:11:37,120 --> 00:11:39,279
new cores and they have different

00:11:38,320 --> 00:11:40,800
trade-offs

00:11:39,279 --> 00:11:42,160
um and the really important thing was

00:11:40,800 --> 00:11:43,680
minimizing this effort so you can come

00:11:42,160 --> 00:11:45,839
along modify your core minimally in

00:11:43,680 --> 00:11:48,079
order to connect it to the system

00:11:45,839 --> 00:11:49,519
so the first option we had we call

00:11:48,079 --> 00:11:50,639
option a is that we would provide three

00:11:49,519 --> 00:11:52,320
levels of cache

00:11:50,639 --> 00:11:53,760
and the end user would kind of connect

00:11:52,320 --> 00:11:55,360
their core to an l1 cache that we

00:11:53,760 --> 00:11:57,680
provide

00:11:55,360 --> 00:12:00,079
now this isn't necessarily a very uh

00:11:57,680 --> 00:12:01,680
desirable design point in terms of a

00:12:00,079 --> 00:12:03,600
category memory system to provide and

00:12:01,680 --> 00:12:05,519
that the l1 is generally very tightly

00:12:03,600 --> 00:12:08,560
coupled with the core micro architecture

00:12:05,519 --> 00:12:10,240
um the you know it's typed the isa

00:12:08,560 --> 00:12:11,680
specifically it's a very high

00:12:10,240 --> 00:12:12,880
performance point very you know you want

00:12:11,680 --> 00:12:14,160
to have low latency you don't have high

00:12:12,880 --> 00:12:15,680
bandwidth to your l1

00:12:14,160 --> 00:12:17,680
and so it would be difficult to build

00:12:15,680 --> 00:12:19,920
something like this so we

00:12:17,680 --> 00:12:21,440
then considered an option b and option b

00:12:19,920 --> 00:12:22,000
we would provide just the last level of

00:12:21,440 --> 00:12:23,120
cache

00:12:22,000 --> 00:12:24,240
the end user would come along and they

00:12:23,120 --> 00:12:25,279
would implement the rest of the cache

00:12:24,240 --> 00:12:26,880
clearance protocol

00:12:25,279 --> 00:12:29,040
to talk to the last level cache and keep

00:12:26,880 --> 00:12:29,279
things good here the problem here is

00:12:29,040 --> 00:12:30,240
that

00:12:29,279 --> 00:12:32,720
cache camera's puts calls are

00:12:30,240 --> 00:12:34,800
notoriously hard to validate the pmesh

00:12:32,720 --> 00:12:35,920
commands protocol has 30 something

00:12:34,800 --> 00:12:37,600
different message types

00:12:35,920 --> 00:12:39,760
it'd be highly likely that the end user

00:12:37,600 --> 00:12:41,680
would come along and

00:12:39,760 --> 00:12:44,079
implement their their re-implementation

00:12:41,680 --> 00:12:45,680
and have it be subtly incompatible with

00:12:44,079 --> 00:12:47,120
the ones provided by other cores

00:12:45,680 --> 00:12:48,800
and so we were not really very excited

00:12:47,120 --> 00:12:50,160
about this option either so we set for

00:12:48,800 --> 00:12:51,839
an option c

00:12:50,160 --> 00:12:53,600
option c is that we provide a last level

00:12:51,839 --> 00:12:54,720
cache and a layer of private cache and

00:12:53,600 --> 00:12:56,240
we try to encapsulate

00:12:54,720 --> 00:12:58,720
as much of the cache current protocol as

00:12:56,240 --> 00:12:59,760
possible then the end user comes along

00:12:58,720 --> 00:13:01,440
with their existing core

00:12:59,760 --> 00:13:03,839
and might make modifications to their l1

00:13:01,440 --> 00:13:05,760
to speak to earlier private cache

00:13:03,839 --> 00:13:07,680
but that's after the l1 and so it's a

00:13:05,760 --> 00:13:10,240
kind of lower performance

00:13:07,680 --> 00:13:10,720
lower bandwidth and latency requirement

00:13:10,240 --> 00:13:13,839
than

00:13:10,720 --> 00:13:15,440
uh the option a um but also we have the

00:13:13,839 --> 00:13:19,760
more thorough validation

00:13:15,440 --> 00:13:22,399
uh opportunity of option b over option

00:13:19,760 --> 00:13:24,000
so uh we defined in this new interface

00:13:22,399 --> 00:13:25,279
the black dotted line you can see here

00:13:24,000 --> 00:13:27,920
um called the transaction response

00:13:25,279 --> 00:13:28,800
interface or tree um and the idea is the

00:13:27,920 --> 00:13:31,360
tree should be

00:13:28,800 --> 00:13:32,160
simple you can see there's a relatively

00:13:31,360 --> 00:13:34,560
small number

00:13:32,160 --> 00:13:35,519
of message types and that are needed to

00:13:34,560 --> 00:13:37,200
implement tree

00:13:35,519 --> 00:13:38,560
um it's extensible you can choose which

00:13:37,200 --> 00:13:39,760
ones you want to implement so you can

00:13:38,560 --> 00:13:41,040
start out with just kind of four

00:13:39,760 --> 00:13:42,000
different message types do some loads

00:13:41,040 --> 00:13:43,839
and stores

00:13:42,000 --> 00:13:45,839
um even fetch your instructions using

00:13:43,839 --> 00:13:47,760
the wood store interface

00:13:45,839 --> 00:13:50,079
and it's low overhead in terms of number

00:13:47,760 --> 00:13:50,399
of wires and needed to kind of connect

00:13:50,079 --> 00:13:52,079
up

00:13:50,399 --> 00:13:53,920
the complexity the state machine that

00:13:52,079 --> 00:13:54,959
sort of thing um and so to see a little

00:13:53,920 --> 00:13:56,320
bit more about that i'll show you some

00:13:54,959 --> 00:13:57,839
of the cores we've connected

00:13:56,320 --> 00:13:59,360
and the different subsets that we

00:13:57,839 --> 00:14:01,279
implemented so

00:13:59,360 --> 00:14:02,959
and open for t1 that was you know the

00:14:01,279 --> 00:14:04,240
core that came with openpton and so the

00:14:02,959 --> 00:14:05,920
first thing we were doing was trying to

00:14:04,240 --> 00:14:07,680
you know bring this forward advances to

00:14:05,920 --> 00:14:10,240
the new interface i mean so it's

00:14:07,680 --> 00:14:11,680
it's of course all the subsets um then

00:14:10,240 --> 00:14:12,880
we worked with ether to connect

00:14:11,680 --> 00:14:14,639
the aria encore we'll talk a little bit

00:14:12,880 --> 00:14:16,480
more about that in a moment and they can

00:14:14,639 --> 00:14:18,000
have kind of smp linux booting in the

00:14:16,480 --> 00:14:20,000
system

00:14:18,000 --> 00:14:22,000
uh working with uh the university of

00:14:20,000 --> 00:14:23,040
washington team uh the bespoke silicon

00:14:22,000 --> 00:14:24,399
group to develop

00:14:23,040 --> 00:14:25,920
uh black pirates so they've been

00:14:24,399 --> 00:14:26,880
developing by pirate um for the last

00:14:25,920 --> 00:14:28,320
couple of years

00:14:26,880 --> 00:14:30,000
and they had a couple of master's

00:14:28,320 --> 00:14:32,000
students uh come and work

00:14:30,000 --> 00:14:34,160
for a quarters about 10 weeks seven

00:14:32,000 --> 00:14:34,880
weeks and they were able within that

00:14:34,160 --> 00:14:36,560
time to

00:14:34,880 --> 00:14:38,160
connect the core implement all the

00:14:36,560 --> 00:14:40,880
subsets and

00:14:38,160 --> 00:14:41,519
get it to run many core simulations um

00:14:40,880 --> 00:14:42,720
and so

00:14:41,519 --> 00:14:44,160
you know this is where we're the point

00:14:42,720 --> 00:14:44,959
now trying to do linux spring up on this

00:14:44,160 --> 00:14:47,360
is very um

00:14:44,959 --> 00:14:48,800
high productivity um we have other cores

00:14:47,360 --> 00:14:50,480
implement fewer subsets so you know

00:14:48,800 --> 00:14:51,279
there's a pcor v32 core that was the

00:14:50,480 --> 00:14:53,360
first core

00:14:51,279 --> 00:14:54,560
and that we connected on the spark core

00:14:53,360 --> 00:14:57,079
um we have the

00:14:54,560 --> 00:14:58,560
ao486s in a re-implementation of intel's

00:14:57,079 --> 00:15:01,360
486sx

00:14:58,560 --> 00:15:02,480
um from you know back in the 80s um and

00:15:01,360 --> 00:15:04,560
and you know we have

00:15:02,480 --> 00:15:05,920
other other options here in particular

00:15:04,560 --> 00:15:07,839
we have micro watts so this is the first

00:15:05,920 --> 00:15:10,959
open power core that we've tried to

00:15:07,839 --> 00:15:11,279
connect so far and so far we implement

00:15:10,959 --> 00:15:13,199
the

00:15:11,279 --> 00:15:14,720
instruction subset um so you can

00:15:13,199 --> 00:15:15,440
actually you know fetch and exit

00:15:14,720 --> 00:15:18,800
instructions

00:15:15,440 --> 00:15:20,079
um the icash um via tree and the load

00:15:18,800 --> 00:15:21,040
store subset as well so you can perform

00:15:20,079 --> 00:15:23,360
those in stores

00:15:21,040 --> 00:15:24,560
and all of that part needs some work um

00:15:23,360 --> 00:15:25,920
now to support more

00:15:24,560 --> 00:15:27,360
you you are going to want to implement

00:15:25,920 --> 00:15:28,320
the rest of subsets right so just now

00:15:27,360 --> 00:15:29,120
you can go and run some simple

00:15:28,320 --> 00:15:30,560
applications

00:15:29,120 --> 00:15:33,040
but if you want to have multi-core you

00:15:30,560 --> 00:15:34,480
want to be able to put in os um

00:15:33,040 --> 00:15:36,720
you're going to have to go and implement

00:15:34,480 --> 00:15:37,920
more stuff there but i was able to do

00:15:36,720 --> 00:15:40,480
this in you know

00:15:37,920 --> 00:15:41,519
the very short period of weeks and to

00:15:40,480 --> 00:15:43,680
kind of get the initial

00:15:41,519 --> 00:15:45,759
um support and i've never touched vhdl

00:15:43,680 --> 00:15:47,440
before

00:15:45,759 --> 00:15:48,480
so the first proof of concept that we

00:15:47,440 --> 00:15:49,680
built um i mentioned is called

00:15:48,480 --> 00:15:51,920
juxtapeton

00:15:49,680 --> 00:15:53,199
and juxtapeton um as we believe the

00:15:51,920 --> 00:15:54,160
world's first open source general

00:15:53,199 --> 00:15:57,519
purpose heterogeneous

00:15:54,160 --> 00:15:58,800
ic processor um so the idea here is that

00:15:57,519 --> 00:16:00,480
we bring together an application class

00:15:58,800 --> 00:16:01,680
core that can be real operating system

00:16:00,480 --> 00:16:03,440
in our case linux

00:16:01,680 --> 00:16:05,680
with a kind of microcontroller class

00:16:03,440 --> 00:16:07,279
core and have them coherently share

00:16:05,680 --> 00:16:10,079
memory under the hood

00:16:07,279 --> 00:16:11,279
so we actually boot linux on the spark

00:16:10,079 --> 00:16:13,519
core

00:16:11,279 --> 00:16:15,600
and we can transparently offload

00:16:13,519 --> 00:16:17,199
binaries of a completely different isa

00:16:15,600 --> 00:16:20,399
that the main core really knows nothing

00:16:17,199 --> 00:16:22,880
about um to the microcontroller core

00:16:20,399 --> 00:16:24,480
and so it can also even you know have

00:16:22,880 --> 00:16:28,079
cisco's proxy back

00:16:24,480 --> 00:16:29,680
um to the t1 core um to be able to you

00:16:28,079 --> 00:16:30,720
know reach its goals so this is a really

00:16:29,680 --> 00:16:32,560
tantalizing

00:16:30,720 --> 00:16:34,560
hint at what we would be enabling right

00:16:32,560 --> 00:16:36,480
if we have heterogeneous isa we can say

00:16:34,560 --> 00:16:37,920
have application needs that mean that i

00:16:36,480 --> 00:16:38,959
want to run my application on a

00:16:37,920 --> 00:16:41,120
different isa

00:16:38,959 --> 00:16:42,320
um or i know that i will get better

00:16:41,120 --> 00:16:43,839
energy efficiency let me

00:16:42,320 --> 00:16:44,959
you know transition this application

00:16:43,839 --> 00:16:45,600
onto the core where i'll get energy

00:16:44,959 --> 00:16:47,440
efficiency

00:16:45,600 --> 00:16:48,959
and the core doesn't even need to have

00:16:47,440 --> 00:16:49,199
you know a full operating system to do

00:16:48,959 --> 00:16:50,880
that

00:16:49,199 --> 00:16:52,399
it can still give you um you know the

00:16:50,880 --> 00:16:54,240
capabilities that you need

00:16:52,399 --> 00:16:55,519
um and so all this is is open source

00:16:54,240 --> 00:16:55,839
today is part of the ketone you can go

00:16:55,519 --> 00:16:57,519
and

00:16:55,839 --> 00:17:00,079
um you know just pass some extra files

00:16:57,519 --> 00:17:02,720
the tools and generate um a version of

00:17:00,079 --> 00:17:04,000
juxtapeton um that you know meets your

00:17:02,720 --> 00:17:06,640
wants or desires

00:17:04,000 --> 00:17:08,559
i mean so at this point we wanted to say

00:17:06,640 --> 00:17:11,760
okay what if we could go further can we

00:17:08,559 --> 00:17:13,679
um connect other cores can we go to

00:17:11,760 --> 00:17:15,280
more capability right can we start to

00:17:13,679 --> 00:17:15,760
look at having operating systems of both

00:17:15,280 --> 00:17:17,919
cores

00:17:15,760 --> 00:17:19,760
and do something more interesting um and

00:17:17,919 --> 00:17:20,400
so you know this was during my phd

00:17:19,760 --> 00:17:21,919
princeton

00:17:20,400 --> 00:17:24,319
and they set up a collaboration with eth

00:17:21,919 --> 00:17:27,039
zurich they have their aaron and core

00:17:24,319 --> 00:17:28,480
um and we wanted to connect together the

00:17:27,039 --> 00:17:30,480
uh harry and core with

00:17:28,480 --> 00:17:31,679
uh keynes with the with open piton and

00:17:30,480 --> 00:17:34,080
kind of build a new permissively

00:17:31,679 --> 00:17:35,840
licensed manuka research platform

00:17:34,080 --> 00:17:37,120
um now because we're bringing together

00:17:35,840 --> 00:17:37,919
kind of maturing sensible designs you

00:17:37,120 --> 00:17:39,360
would hope

00:17:37,919 --> 00:17:40,960
that we would be able to you know do

00:17:39,360 --> 00:17:42,720
this very quickly

00:17:40,960 --> 00:17:44,000
in general that isn't a really an

00:17:42,720 --> 00:17:45,679
assumption that we would have had before

00:17:44,000 --> 00:17:47,120
we started this project right it's

00:17:45,679 --> 00:17:48,160
these are complex systems we're talking

00:17:47,120 --> 00:17:50,080
about cache coherence we're talking

00:17:48,160 --> 00:17:51,919
about you know running through less

00:17:50,080 --> 00:17:53,360
um but it turns out that with the way

00:17:51,919 --> 00:17:54,559
that we cut the system we built this

00:17:53,360 --> 00:17:56,880
tree interface

00:17:54,559 --> 00:17:57,760
um we were actually able to work very

00:17:56,880 --> 00:18:01,120
productively

00:17:57,760 --> 00:18:02,000
and exploit the thorough validation of

00:18:01,120 --> 00:18:03,520
pmesh

00:18:02,000 --> 00:18:05,120
in terms of its isa agnostic

00:18:03,520 --> 00:18:06,640
functionality um

00:18:05,120 --> 00:18:08,559
and you know this is the core realistic

00:18:06,640 --> 00:18:09,919
complexity and so we were able to come

00:18:08,559 --> 00:18:11,200
together within six months we were

00:18:09,919 --> 00:18:12,880
booting smp linux

00:18:11,200 --> 00:18:14,320
um it was it was even last time just to

00:18:12,880 --> 00:18:15,280
get kind of many core simulations

00:18:14,320 --> 00:18:17,360
running

00:18:15,280 --> 00:18:19,200
um and so to do this i'll say a little

00:18:17,360 --> 00:18:20,960
bit about the design itself so

00:18:19,200 --> 00:18:22,080
um i showed you the title before of open

00:18:20,960 --> 00:18:23,840
piton this is a slightly different

00:18:22,080 --> 00:18:25,760
rendering of it and we have the arian

00:18:23,840 --> 00:18:27,840
core on the left we have the the p mesh

00:18:25,760 --> 00:18:28,880
part the right and so we had to make

00:18:27,840 --> 00:18:30,320
some modifications

00:18:28,880 --> 00:18:32,480
of course to do this and so in the

00:18:30,320 --> 00:18:34,000
ariane side they kind of built a new uh

00:18:32,480 --> 00:18:35,200
right through cache sub system with

00:18:34,000 --> 00:18:37,280
the invalidation so they could do the

00:18:35,200 --> 00:18:40,640
multi-core um and the

00:18:37,280 --> 00:18:42,480
the speaking tree to zero 1.5 cache

00:18:40,640 --> 00:18:44,160
on our side we were adding the new

00:18:42,480 --> 00:18:45,440
capabilities to say okay let's support

00:18:44,160 --> 00:18:46,880
other isas and so

00:18:45,440 --> 00:18:48,559
we needed to support those resources for

00:18:46,880 --> 00:18:49,919
conditional atomics those are

00:18:48,559 --> 00:18:51,840
you know used in universe 5. they're

00:18:49,919 --> 00:18:52,640
using open power they're used in open

00:18:51,840 --> 00:18:54,480
risk they're used in

00:18:52,640 --> 00:18:56,000
a variety of different isas and that's

00:18:54,480 --> 00:18:58,240
something that we didn't have

00:18:56,000 --> 00:18:59,120
um on top of that we wanted the fetching

00:18:58,240 --> 00:19:00,640
of atomics

00:18:59,120 --> 00:19:02,400
and so we implemented those in our l2

00:19:00,640 --> 00:19:05,840
cache as well um because

00:19:02,400 --> 00:19:07,120
those were demanded by the isa at the

00:19:05,840 --> 00:19:09,200
platform level there were also some

00:19:07,120 --> 00:19:10,400
further modifications this is something

00:19:09,200 --> 00:19:11,440
to think about if you want to bring your

00:19:10,400 --> 00:19:12,480
core and plug it in

00:19:11,440 --> 00:19:13,520
you know this is going to tell you in

00:19:12,480 --> 00:19:14,799
general a little bit about what you

00:19:13,520 --> 00:19:16,400
might need to think about

00:19:14,799 --> 00:19:17,919
so one of the things we did was we also

00:19:16,400 --> 00:19:19,919
generate the boot rom

00:19:17,919 --> 00:19:21,440
uh based on the configuration of the

00:19:19,919 --> 00:19:24,080
system that we built

00:19:21,440 --> 00:19:25,600
and so if you have you know this

00:19:24,080 --> 00:19:26,080
particular ur you have this number of

00:19:25,600 --> 00:19:28,080
cores

00:19:26,080 --> 00:19:29,520
we specify all that and build the the

00:19:28,080 --> 00:19:30,960
device tree into the boot rom

00:19:29,520 --> 00:19:32,640
so you can then take the same linux

00:19:30,960 --> 00:19:34,320
image and boot it across multiple

00:19:32,640 --> 00:19:36,799
different configurations of the system

00:19:34,320 --> 00:19:38,960
and it will still work um there's things

00:19:36,799 --> 00:19:41,360
like debug and interrupt controllers

00:19:38,960 --> 00:19:43,120
once somebody has connected one core of

00:19:41,360 --> 00:19:45,039
a particular ism platform

00:19:43,120 --> 00:19:46,720
other people can exploit this so when we

00:19:45,039 --> 00:19:47,840
brought along the black parrot core he

00:19:46,720 --> 00:19:49,520
was able to exploit

00:19:47,840 --> 00:19:50,960
the boot rom and the interrupt

00:19:49,520 --> 00:19:52,640
controllers from

00:19:50,960 --> 00:19:54,320
our connection varian and that was able

00:19:52,640 --> 00:19:54,799
to save us a lot of time in terms of

00:19:54,320 --> 00:19:56,080
like

00:19:54,799 --> 00:19:58,480
you know trying to transduce between

00:19:56,080 --> 00:19:59,760
different uh protocols or um you know

00:19:58,480 --> 00:20:03,280
trying to trying to make things work in

00:19:59,760 --> 00:20:05,520
ways that they hadn't before

00:20:03,280 --> 00:20:07,200
so from this uh we were able to get back

00:20:05,520 --> 00:20:10,559
to our goal of building you know

00:20:07,200 --> 00:20:12,400
complex heterogeneous isa socs and so

00:20:10,559 --> 00:20:13,760
um the next one that we built had a t1

00:20:12,400 --> 00:20:15,600
and an ariane core

00:20:13,760 --> 00:20:16,960
um and both of them are application

00:20:15,600 --> 00:20:17,760
class courses can be a real operating

00:20:16,960 --> 00:20:19,760
system

00:20:17,760 --> 00:20:21,679
and under the hood they have philly

00:20:19,760 --> 00:20:24,000
hardware coherent shared memory

00:20:21,679 --> 00:20:24,720
including all the isa specific atomics

00:20:24,000 --> 00:20:26,799
and so

00:20:24,720 --> 00:20:28,880
the uh cores each bit an independent

00:20:26,799 --> 00:20:30,720
sonic 1x kernel one for each isa

00:20:28,880 --> 00:20:32,080
and then user mode applications on top

00:20:30,720 --> 00:20:33,440
can share memory across the two cores

00:20:32,080 --> 00:20:34,960
and the two isas and they don't even

00:20:33,440 --> 00:20:36,000
necessarily need to have any idea

00:20:34,960 --> 00:20:37,440
that the other person that they're

00:20:36,000 --> 00:20:38,880
synchronizing with isn't running the

00:20:37,440 --> 00:20:41,280
same isa they are

00:20:38,880 --> 00:20:42,559
so we can use the isa specific atomics

00:20:41,280 --> 00:20:44,720
and those will work correctly

00:20:42,559 --> 00:20:46,080
even when they're mixed together so you

00:20:44,720 --> 00:20:47,600
might use a wood reserve

00:20:46,080 --> 00:20:49,600
store conditional on one side but use a

00:20:47,600 --> 00:20:50,960
compare and swap um on the other

00:20:49,600 --> 00:20:52,559
and then one of the cool things here is

00:20:50,960 --> 00:20:53,200
that this this means that you can even

00:20:52,559 --> 00:20:55,600
have

00:20:53,200 --> 00:20:56,240
um cores using atomics beyond what their

00:20:55,600 --> 00:20:58,080
isa

00:20:56,240 --> 00:20:59,679
is specified to support and so you could

00:20:58,080 --> 00:21:02,320
you know enhance the chord have a

00:20:59,679 --> 00:21:03,760
broader isa potential

00:21:02,320 --> 00:21:05,840
um now because we hear a little bit

00:21:03,760 --> 00:21:07,360
about open source uh we actually did a

00:21:05,840 --> 00:21:08,720
full artifact valuation

00:21:07,360 --> 00:21:10,480
and for this for our paper announcements

00:21:08,720 --> 00:21:11,200
2020 so you can go online and grab the

00:21:10,480 --> 00:21:14,320
artifact

00:21:11,200 --> 00:21:15,679
reproduce what we did and the prototype

00:21:14,320 --> 00:21:17,280
code is all available on github as well

00:21:15,679 --> 00:21:18,320
so you can rebuild it in whatever way

00:21:17,280 --> 00:21:20,640
you want

00:21:18,320 --> 00:21:22,480
um and so the next thing i'm going to

00:21:20,640 --> 00:21:24,880
show you is a quick video

00:21:22,480 --> 00:21:26,320
of uh the the kind of proof of content

00:21:24,880 --> 00:21:30,320
demo that we built

00:21:26,320 --> 00:21:34,080
so here we are going to put linux on

00:21:30,320 --> 00:21:36,880
both of the cores and uh

00:21:34,080 --> 00:21:38,159
on the left is the t1 the razarian and

00:21:36,880 --> 00:21:38,640
the t1 is kind of in charge it's going

00:21:38,159 --> 00:21:43,120
to map

00:21:38,640 --> 00:21:44,880
a contiguous region of physical memory

00:21:43,120 --> 00:21:46,320
and then create virtual memory mappings

00:21:44,880 --> 00:21:48,080
for that region

00:21:46,320 --> 00:21:49,600
um that's going to be the first

00:21:48,080 --> 00:21:51,360
application that gets run

00:21:49,600 --> 00:21:52,880
um and there isn't really anything

00:21:51,360 --> 00:21:54,000
special there's going to kind of

00:21:52,880 --> 00:21:56,240
you know get a contiguous region from

00:21:54,000 --> 00:21:57,840
the kernel and then map it on the right

00:21:56,240 --> 00:21:59,280
the iran core isn't going to run its

00:21:57,840 --> 00:22:01,120
application it's going to read from a

00:21:59,280 --> 00:22:02,640
shared location what the base pointer of

00:22:01,120 --> 00:22:03,840
that contiguous region is and then it's

00:22:02,640 --> 00:22:05,760
going to build its own virtual memory

00:22:03,840 --> 00:22:07,520
mappings for the same region

00:22:05,760 --> 00:22:08,799
then the two cores are going to run kind

00:22:07,520 --> 00:22:10,559
of a simple token passing

00:22:08,799 --> 00:22:12,559
application through a queue in the

00:22:10,559 --> 00:22:13,679
shared memory and we have two versions

00:22:12,559 --> 00:22:16,240
the one we're going to show here

00:22:13,679 --> 00:22:17,679
uses the atomics of the two isas but you

00:22:16,240 --> 00:22:18,480
can also do it just using regular loads

00:22:17,679 --> 00:22:20,159
and stores

00:22:18,480 --> 00:22:21,760
um and so we kind of are able to measure

00:22:20,159 --> 00:22:22,799
out what the retro latency is we have

00:22:21,760 --> 00:22:23,600
other experiments where measured

00:22:22,799 --> 00:22:24,799
throughput

00:22:23,600 --> 00:22:26,559
and we can see there's a very low

00:22:24,799 --> 00:22:27,600
latency compared to especially compared

00:22:26,559 --> 00:22:29,679
to something like

00:22:27,600 --> 00:22:31,039
you know pcie message passing or you

00:22:29,679 --> 00:22:33,440
know software uh

00:22:31,039 --> 00:22:35,440
software controlled uh coherence and so

00:22:33,440 --> 00:22:37,039
uh we're able to realize kind of the

00:22:35,440 --> 00:22:39,280
benefits that the architects

00:22:37,039 --> 00:22:40,880
had wanted but the hardware wasn't there

00:22:39,280 --> 00:22:41,520
for and so you know os people could go

00:22:40,880 --> 00:22:43,440
from here

00:22:41,520 --> 00:22:45,440
and start to build uh more complex more

00:22:43,440 --> 00:22:48,159
interesting operating systems on top

00:22:45,440 --> 00:22:50,000
that uh can actually take advantage of

00:22:48,159 --> 00:22:54,080
this you know low latency

00:22:50,000 --> 00:22:57,200
um uh hardware supported cash coherence

00:22:54,080 --> 00:22:59,120
um so another uh system that we built

00:22:57,200 --> 00:23:00,880
was i worked with the

00:22:59,120 --> 00:23:02,960
developers at xilinx of a system called

00:23:00,880 --> 00:23:06,720
lib system ctlm soc

00:23:02,960 --> 00:23:08,400
um to connect uh qemu to pmesh

00:23:06,720 --> 00:23:10,480
so they their their system can connect

00:23:08,400 --> 00:23:13,200
qmu to rtl simulation

00:23:10,480 --> 00:23:14,880
um and at the qemu will do loads and

00:23:13,200 --> 00:23:16,080
stores into the rtl simulation and you

00:23:14,880 --> 00:23:17,200
can handle those how you want so they

00:23:16,080 --> 00:23:18,960
had an l1 cache

00:23:17,200 --> 00:23:20,320
we transduced that to tree and then we

00:23:18,960 --> 00:23:23,840
had that able to speak

00:23:20,320 --> 00:23:25,039
to a coherent pmh fabric um and so then

00:23:23,840 --> 00:23:26,960
there's a lot of potential here

00:23:25,039 --> 00:23:29,840
you could bring together cores of isa

00:23:26,960 --> 00:23:32,799
that don't have uh open source

00:23:29,840 --> 00:23:33,600
implementations you could bring together

00:23:32,799 --> 00:23:36,240
core

00:23:33,600 --> 00:23:38,080
kind of qemu with simulated cores of the

00:23:36,240 --> 00:23:39,200
same isa but kind of

00:23:38,080 --> 00:23:40,400
functionally from different

00:23:39,200 --> 00:23:41,520
microarchitectures in some in some

00:23:40,400 --> 00:23:43,039
conceptual sense

00:23:41,520 --> 00:23:44,640
um and then build some really

00:23:43,039 --> 00:23:45,120
interesting systems you know maybe you

00:23:44,640 --> 00:23:48,320
have

00:23:45,120 --> 00:23:50,080
implementation of an isa

00:23:48,320 --> 00:23:51,200
um and you're building a new core and

00:23:50,080 --> 00:23:52,880
you want to kind of be able to work

00:23:51,200 --> 00:23:55,039
alongside an existing core

00:23:52,880 --> 00:23:56,640
um and see what the behavior should be

00:23:55,039 --> 00:23:59,760
and so so this is also a really

00:23:56,640 --> 00:24:02,880
interesting setup that we built um

00:23:59,760 --> 00:24:05,679
so really the goal um overall is

00:24:02,880 --> 00:24:06,960
to uh have open piton or you know can

00:24:05,679 --> 00:24:08,960
the extension by oc

00:24:06,960 --> 00:24:10,240
give the features of p mesh to all cores

00:24:08,960 --> 00:24:12,159
regardless of their isa

00:24:10,240 --> 00:24:14,080
we want to provide a set of features

00:24:12,159 --> 00:24:15,919
that is rich and sufficient

00:24:14,080 --> 00:24:17,360
for a variety of different iss mic

00:24:15,919 --> 00:24:20,240
architectures

00:24:17,360 --> 00:24:21,200
and have that be kind of agnostic to the

00:24:20,240 --> 00:24:23,039
to the core

00:24:21,200 --> 00:24:24,480
and so on top of the what i've already

00:24:23,039 --> 00:24:26,400
shown we also built

00:24:24,480 --> 00:24:28,559
a prototype of an isa agnostic hardware

00:24:26,400 --> 00:24:30,240
transactional memory system inside pmesh

00:24:28,559 --> 00:24:31,279
so you can imagine if you don't want to

00:24:30,240 --> 00:24:32,640
have to add a lot of support in your

00:24:31,279 --> 00:24:33,200
core for transactional memory then you

00:24:32,640 --> 00:24:35,520
can

00:24:33,200 --> 00:24:36,400
take advantage of one that we build into

00:24:35,520 --> 00:24:38,880
pmesh

00:24:36,400 --> 00:24:40,320
um or you could you know uh be able to

00:24:38,880 --> 00:24:41,360
enhance your isa to support

00:24:40,320 --> 00:24:42,400
transactional memory if it doesn't

00:24:41,360 --> 00:24:44,000
already

00:24:42,400 --> 00:24:45,440
um there are other things that we're

00:24:44,000 --> 00:24:46,720
still working on so we have

00:24:45,440 --> 00:24:49,039
a couple of tape outs that are coming

00:24:46,720 --> 00:24:50,799
soon in particular next month it's going

00:24:49,039 --> 00:24:53,279
to have a really kind of complex

00:24:50,799 --> 00:24:55,039
interesting heterogeneous soc that we'll

00:24:53,279 --> 00:24:56,480
be happy to talk about in the future

00:24:55,039 --> 00:24:57,760
um but other improvements you know i'm

00:24:56,480 --> 00:24:59,600
really interested in adding fuel system

00:24:57,760 --> 00:25:02,640
micro support support for the new

00:24:59,600 --> 00:25:02,960
other open power cores um trying to

00:25:02,640 --> 00:25:04,480
build

00:25:02,960 --> 00:25:05,919
distributed interrupt controllers that

00:25:04,480 --> 00:25:06,320
can scale to the skill that we care

00:25:05,919 --> 00:25:08,880
about

00:25:06,320 --> 00:25:09,360
with the potential to be able to have a

00:25:08,880 --> 00:25:11,200
kind of

00:25:09,360 --> 00:25:12,880
platform that could be common across

00:25:11,200 --> 00:25:14,799
multiple isas

00:25:12,880 --> 00:25:16,400
um more center bridges we can connect

00:25:14,799 --> 00:25:16,880
more different types of accelerators so

00:25:16,400 --> 00:25:18,640
we can

00:25:16,880 --> 00:25:20,080
you know talk to other kind of coherent

00:25:18,640 --> 00:25:21,600
fabrics that sort of thing

00:25:20,080 --> 00:25:24,000
um and then also trying to support

00:25:21,600 --> 00:25:25,520
things like uh core clusters per tile

00:25:24,000 --> 00:25:27,360
and so that you could you know if you

00:25:25,520 --> 00:25:29,279
have a design point that cares about

00:25:27,360 --> 00:25:31,120
sharing um that local cache that we

00:25:29,279 --> 00:25:32,559
provide then you would be able to build

00:25:31,120 --> 00:25:34,400
that kind of thing as well

00:25:32,559 --> 00:25:36,400
um and so really you're just trying to

00:25:34,400 --> 00:25:37,840
build you know a complex heterogeneous

00:25:36,400 --> 00:25:39,120
swc environment where other people can

00:25:37,840 --> 00:25:40,720
bring their cores and plug them in or

00:25:39,120 --> 00:25:42,000
they can take the clearance system he

00:25:40,720 --> 00:25:44,400
mesh that we provide

00:25:42,000 --> 00:25:45,520
and connect their own cores and so maybe

00:25:44,400 --> 00:25:46,480
you don't care about the heterogeneous

00:25:45,520 --> 00:25:48,400
isa features

00:25:46,480 --> 00:25:50,320
um themselves but you want something's

00:25:48,400 --> 00:25:51,679
well validated and having been validated

00:25:50,320 --> 00:25:53,440
across multiple isas

00:25:51,679 --> 00:25:55,840
um you know what will help demonstrate

00:25:53,440 --> 00:25:56,720
that um so with that i'm going to stop

00:25:55,840 --> 00:25:58,720
here

00:25:56,720 --> 00:26:00,000
and i'm happy to take any questions that

00:25:58,720 --> 00:26:03,679
you in the audience may have

00:26:00,000 --> 00:26:03,679

YouTube URL: https://www.youtube.com/watch?v=DkcvXciAKa0


