Title: LinuxKI on POWER: The kernel Performance Toolkit Porting Experience and Challenges - Sergey Kachkin
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	LinuxKI on POWER: The kernel Performance Toolkit Porting Experience and Challenges - Sergey Kachkin, YADRO

Speakers: Sergey Kachkin

There are a lot of Linux performance tools. Some of them are already working on the OpenPOWER platform, while some are not properly ported yet. The LinuxKI Toolset is an open source performance troubleshooting tool for Linux. It is designed to identify performance issues beyond the typical performance metrics and results in faster root cause identification for many performance issues. In this presentation, I'll share the porting experience of this kernel performance tool on OpenPOWER, as well as address challenges and techniques that can be used to port modules if you are a performance engineer and not a professional programmer.
Captions: 
	00:00:00,300 --> 00:00:03,199
[Music]

00:00:00,640 --> 00:00:04,880
hello everyone my name is sergey kashkin

00:00:03,199 --> 00:00:05,279
and in this presentation i'm going to

00:00:04,880 --> 00:00:07,359
share

00:00:05,279 --> 00:00:09,519
our experience with sporting linux

00:00:07,359 --> 00:00:11,280
kernel tracing tool called linux k to

00:00:09,519 --> 00:00:13,519
open power platform

00:00:11,280 --> 00:00:15,440
we'll cover the motivation so why you

00:00:13,519 --> 00:00:16,960
may want to port something to open

00:00:15,440 --> 00:00:19,680
power especially if you are not a

00:00:16,960 --> 00:00:22,080
professional programmer like i am

00:00:19,680 --> 00:00:23,119
what things you need to do during

00:00:22,080 --> 00:00:25,359
porting

00:00:23,119 --> 00:00:26,240
how to deal with platform dependent

00:00:25,359 --> 00:00:28,880
components

00:00:26,240 --> 00:00:30,000
and how to fix kernel panics because

00:00:28,880 --> 00:00:33,280
this tool contains

00:00:30,000 --> 00:00:33,840
kernel module and when you port a kernel

00:00:33,280 --> 00:00:37,360
module

00:00:33,840 --> 00:00:38,879
panics happens very often there are many

00:00:37,360 --> 00:00:40,559
linux performance tools already

00:00:38,879 --> 00:00:41,760
available on open power so you can

00:00:40,559 --> 00:00:44,239
simply take them

00:00:41,760 --> 00:00:46,320
and use for your performance problem why

00:00:44,239 --> 00:00:49,120
you may want to invest your time

00:00:46,320 --> 00:00:50,960
into porting one module well for me the

00:00:49,120 --> 00:00:52,719
answer is that with linux ki

00:00:50,960 --> 00:00:54,079
i can resolve performance problems

00:00:52,719 --> 00:00:56,320
faster and easier

00:00:54,079 --> 00:00:58,480
my colleagues and myself who have good

00:00:56,320 --> 00:01:00,160
experience of using linux k on other

00:00:58,480 --> 00:01:01,440
platforms and want to have the same on

00:01:00,160 --> 00:01:03,520
open power

00:01:01,440 --> 00:01:05,360
most of other performance tools they

00:01:03,520 --> 00:01:08,000
cover some specific subsystem

00:01:05,360 --> 00:01:09,520
and you can run different tools with

00:01:08,000 --> 00:01:12,000
different parameters

00:01:09,520 --> 00:01:13,680
uh several times and then correlate one

00:01:12,000 --> 00:01:16,320
tool with another two

00:01:13,680 --> 00:01:17,680
with linux car you can collect data once

00:01:16,320 --> 00:01:21,280
build static reports

00:01:17,680 --> 00:01:24,080
and then get good understanding of

00:01:21,280 --> 00:01:26,159
what happens on the system and often it

00:01:24,080 --> 00:01:27,200
helps to better understand what is the

00:01:26,159 --> 00:01:30,400
root cause of

00:01:27,200 --> 00:01:31,040
performance problem the linux ki has two

00:01:30,400 --> 00:01:32,960
parts

00:01:31,040 --> 00:01:34,960
the kernel module is responsible for

00:01:32,960 --> 00:01:36,000
capturing traces and sending them to

00:01:34,960 --> 00:01:39,040
user space

00:01:36,000 --> 00:01:40,799
it use default linux tracing mechanisms

00:01:39,040 --> 00:01:43,759
like static trace points and k

00:01:40,799 --> 00:01:46,159
probes this module needs to be loaded

00:01:43,759 --> 00:01:48,479
only for a short period of time

00:01:46,159 --> 00:01:50,000
while the tracing is enabled you don't

00:01:48,479 --> 00:01:53,040
need to have it loaded

00:01:50,000 --> 00:01:55,280
all the time the user space part

00:01:53,040 --> 00:01:56,079
reads data from the kernel and then it

00:01:55,280 --> 00:01:59,040
can store

00:01:56,079 --> 00:02:00,240
data to disk for offline analysis and

00:01:59,040 --> 00:02:02,719
building reports

00:02:00,240 --> 00:02:04,560
or it can build reports online so you

00:02:02,719 --> 00:02:07,920
can use linux sky

00:02:04,560 --> 00:02:09,360
as observability tool please visit

00:02:07,920 --> 00:02:11,599
github

00:02:09,360 --> 00:02:12,879
you can find their master class and

00:02:11,599 --> 00:02:15,840
video tutorials

00:02:12,879 --> 00:02:18,160
actually this is a very well documented

00:02:15,840 --> 00:02:18,160
tool

00:02:18,480 --> 00:02:22,080
let's talk a bit about possible

00:02:20,080 --> 00:02:24,000
challenges we may have during porting

00:02:22,080 --> 00:02:26,560
linux kite open power

00:02:24,000 --> 00:02:27,840
first of all it contains a kernel module

00:02:26,560 --> 00:02:30,160
with some portion of

00:02:27,840 --> 00:02:32,080
low-level platform-dependent code it

00:02:30,160 --> 00:02:34,720
needs to be ported

00:02:32,080 --> 00:02:37,680
i am not writing kernel code every day

00:02:34,720 --> 00:02:39,920
and this part can be challenging

00:02:37,680 --> 00:02:40,959
on the other hand limit scale already

00:02:39,920 --> 00:02:44,480
available on

00:02:40,959 --> 00:02:47,840
x86 and arm so i can use this code

00:02:44,480 --> 00:02:50,080
as a reference additionally

00:02:47,840 --> 00:02:52,560
most of the code especially user space

00:02:50,080 --> 00:02:53,840
part built successfully on open power

00:02:52,560 --> 00:02:56,400
with no changes

00:02:53,840 --> 00:02:57,280
and i just need to make sure that it

00:02:56,400 --> 00:03:00,080
provides

00:02:57,280 --> 00:03:00,080
right data

00:03:00,959 --> 00:03:05,920
so during porting we have an easy part

00:03:04,080 --> 00:03:08,480
and more challenging part

00:03:05,920 --> 00:03:08,959
this part will contain adding some if

00:03:08,480 --> 00:03:12,480
depths

00:03:08,959 --> 00:03:16,000
to a line includes and swap some

00:03:12,480 --> 00:03:16,560
x86 and arm functions into open power

00:03:16,000 --> 00:03:19,599
ones

00:03:16,560 --> 00:03:20,640
and also we need to align a system

00:03:19,599 --> 00:03:23,599
called numbers

00:03:20,640 --> 00:03:26,000
because on different platforms the same

00:03:23,599 --> 00:03:27,120
system calls may be presented from the

00:03:26,000 --> 00:03:30,640
kernel space

00:03:27,120 --> 00:03:34,400
into user space with different numbers

00:03:30,640 --> 00:03:36,959
a more challenging part will contain

00:03:34,400 --> 00:03:38,400
porting stack and wind code which is

00:03:36,959 --> 00:03:41,760
platform dependent

00:03:38,400 --> 00:03:44,879
and also we need to debug panics

00:03:41,760 --> 00:03:50,000
because we are porting kernel module

00:03:44,879 --> 00:03:50,000
and we need to be ready to meet them

00:03:50,319 --> 00:03:53,760
most challenging part of our reporting

00:03:52,640 --> 00:03:56,080
is a

00:03:53,760 --> 00:03:56,959
low level platform dependent code in

00:03:56,080 --> 00:03:59,120
linux ki

00:03:56,959 --> 00:04:00,400
we have a portion of such code

00:03:59,120 --> 00:04:03,840
unfortunately

00:04:00,400 --> 00:04:05,760
this is a stack and wind or backtracing

00:04:03,840 --> 00:04:08,879
code

00:04:05,760 --> 00:04:10,480
the question why we can't just drop this

00:04:08,879 --> 00:04:14,400
and use linuxcare without

00:04:10,480 --> 00:04:17,680
this feature let's talk a bit about this

00:04:14,400 --> 00:04:21,040
stack and winding is used for on cpu

00:04:17,680 --> 00:04:22,639
and of cpu profiling it allows us to do

00:04:21,040 --> 00:04:25,360
analysis similar to

00:04:22,639 --> 00:04:26,479
flame graphs everybody love flame graphs

00:04:25,360 --> 00:04:28,800
and definitely we

00:04:26,479 --> 00:04:29,759
want to have this feature in the tool

00:04:28,800 --> 00:04:33,360
we're parting

00:04:29,759 --> 00:04:36,560
so what options we have to

00:04:33,360 --> 00:04:37,440
get it we can write the code from

00:04:36,560 --> 00:04:40,639
scratch

00:04:37,440 --> 00:04:44,080
it can be difficult we can grab

00:04:40,639 --> 00:04:48,080
the code somewhere in linux kernel from

00:04:44,080 --> 00:04:51,680
openpower and we can use

00:04:48,080 --> 00:04:57,840
arm or x86 code as reference

00:04:51,680 --> 00:04:57,840
and use it

00:04:59,040 --> 00:05:02,560
let's have a look at stack and wind

00:05:00,639 --> 00:05:04,240
algorithm more detail to get a better

00:05:02,560 --> 00:05:07,280
understanding how to port it

00:05:04,240 --> 00:05:09,360
easier the result of stack and winding

00:05:07,280 --> 00:05:11,199
back tracing is a call stack of

00:05:09,360 --> 00:05:13,199
functions

00:05:11,199 --> 00:05:15,360
this call stack is used for on cpu

00:05:13,199 --> 00:05:18,240
profiling and it helps to understand

00:05:15,360 --> 00:05:20,880
what the system is doing when it's busy

00:05:18,240 --> 00:05:23,199
and also it's used for off cpu profiling

00:05:20,880 --> 00:05:24,320
it helps to find out what the system is

00:05:23,199 --> 00:05:27,120
waiting for

00:05:24,320 --> 00:05:29,360
when it's idling actually these two

00:05:27,120 --> 00:05:31,759
questions are the main questions of

00:05:29,360 --> 00:05:34,400
each and every performance analysis the

00:05:31,759 --> 00:05:37,520
basic idea of stack and winding or

00:05:34,400 --> 00:05:38,160
back tracing is to it's actually quite

00:05:37,520 --> 00:05:40,320
easy

00:05:38,160 --> 00:05:41,199
we need to find the current stack frame

00:05:40,320 --> 00:05:43,840
where we are

00:05:41,199 --> 00:05:45,600
we store instruction pointer then we

00:05:43,840 --> 00:05:46,400
follow the pointer to find the previous

00:05:45,600 --> 00:05:48,639
stack frame

00:05:46,400 --> 00:05:50,560
store instruction pointer and again and

00:05:48,639 --> 00:05:55,199
again while we can get something

00:05:50,560 --> 00:05:58,400
useful the requirements for unwinding is

00:05:55,199 --> 00:05:59,360
we need to do it very fast at the same

00:05:58,400 --> 00:06:01,600
time we can

00:05:59,360 --> 00:06:02,400
lose some stacked races because we

00:06:01,600 --> 00:06:04,479
collect

00:06:02,400 --> 00:06:05,600
hundreds and thousands of stacks races

00:06:04,479 --> 00:06:08,960
during profiling

00:06:05,600 --> 00:06:10,639
if we fail this one hopefully we will be

00:06:08,960 --> 00:06:13,759
successful next time

00:06:10,639 --> 00:06:17,840
and the result of profiling

00:06:13,759 --> 00:06:17,840
will give us what we need

00:06:18,400 --> 00:06:25,039
initially i reviewed

00:06:21,759 --> 00:06:28,400
the linux kernel for open power

00:06:25,039 --> 00:06:32,400
and built my own version of

00:06:28,400 --> 00:06:33,520
stack and winding and then i compared

00:06:32,400 --> 00:06:36,800
what i got

00:06:33,520 --> 00:06:40,080
with ex with arm code

00:06:36,800 --> 00:06:42,960
arm and win code which already exists in

00:06:40,080 --> 00:06:44,240
linux ki and found that the code is very

00:06:42,960 --> 00:06:47,600
similar

00:06:44,240 --> 00:06:50,319
and then i compared the tail of stack

00:06:47,600 --> 00:06:53,840
frame for arm and for power pc

00:06:50,319 --> 00:06:57,440
and noted that

00:06:53,840 --> 00:07:00,960
they are very close to each other so

00:06:57,440 --> 00:07:05,120
i dropped my code and reused

00:07:00,960 --> 00:07:08,000
the code for arm with very small changes

00:07:05,120 --> 00:07:09,360
the lesson i learned is that so well

00:07:08,000 --> 00:07:11,919
it's obvious

00:07:09,360 --> 00:07:14,000
before writing something look at

00:07:11,919 --> 00:07:16,160
existing code

00:07:14,000 --> 00:07:17,199
it may save your time and you do not

00:07:16,160 --> 00:07:21,599
need to run

00:07:17,199 --> 00:07:23,759
extra miles now let's move to the next

00:07:21,599 --> 00:07:25,440
part of the presentation is

00:07:23,759 --> 00:07:28,400
troubleshooting panics

00:07:25,440 --> 00:07:29,120
actually uh this part took i don't know

00:07:28,400 --> 00:07:31,680
maybe

00:07:29,120 --> 00:07:34,880
85 percent of the whole time needed to

00:07:31,680 --> 00:07:34,880
get a working code

00:07:35,520 --> 00:07:41,680
i decided to show three different panics

00:07:38,800 --> 00:07:43,680
one of them is uh relatively easy

00:07:41,680 --> 00:07:47,280
another one i called intermediate

00:07:43,680 --> 00:07:50,879
and the third one is i called it crazy

00:07:47,280 --> 00:07:54,800
because it was really difficult to find

00:07:50,879 --> 00:07:57,440
the root cause troubleshooting the first

00:07:54,800 --> 00:08:01,039
panic was relatively easy

00:07:57,440 --> 00:08:04,560
the reason is that the panic happens

00:08:01,039 --> 00:08:07,599
in linux k code we can see it in the

00:08:04,560 --> 00:08:10,800
stack trace the very top function point

00:08:07,599 --> 00:08:12,000
to liquid module which is linux ki

00:08:10,800 --> 00:08:15,840
kernel model so

00:08:12,000 --> 00:08:18,879
we know where the root cause is located

00:08:15,840 --> 00:08:23,120
so it means that linux k is doing

00:08:18,879 --> 00:08:25,520
something wrong uh and on the other hand

00:08:23,120 --> 00:08:26,639
veeam core which is generated during

00:08:25,520 --> 00:08:29,360
crash contains

00:08:26,639 --> 00:08:30,400
some useful data which can be used for

00:08:29,360 --> 00:08:33,279
troubleshooting

00:08:30,400 --> 00:08:34,719
so we have at least two options to find

00:08:33,279 --> 00:08:37,279
the root cause of the panic

00:08:34,719 --> 00:08:38,000
we can review the vm core with crash

00:08:37,279 --> 00:08:41,519
tool or

00:08:38,000 --> 00:08:42,959
any other tool or i don't know for me

00:08:41,519 --> 00:08:46,240
it's harder because i don't

00:08:42,959 --> 00:08:49,600
do it every day and another option

00:08:46,240 --> 00:08:53,120
we can add some print case to our code

00:08:49,600 --> 00:08:56,880
we know the function which is

00:08:53,120 --> 00:08:56,880
where panic happens and

00:08:57,680 --> 00:09:03,360
generate the panic and look at linux log

00:09:00,720 --> 00:09:05,040
and it gives us very good understanding

00:09:03,360 --> 00:09:07,440
what was the root cause

00:09:05,040 --> 00:09:08,560
i decided to take an easy way i added

00:09:07,440 --> 00:09:11,120
some print case

00:09:08,560 --> 00:09:12,480
to the function where the panic happens

00:09:11,120 --> 00:09:14,240
i generated the crash

00:09:12,480 --> 00:09:17,279
i reviewed the logs and found the root

00:09:14,240 --> 00:09:19,760
cause that was quite easy

00:09:17,279 --> 00:09:20,640
the root cause is that we have regs

00:09:19,760 --> 00:09:23,920
structure

00:09:20,640 --> 00:09:27,279
we try to fill it and then we

00:09:23,920 --> 00:09:30,800
dereference it if the structure is empty

00:09:27,279 --> 00:09:33,440
during the reference we're getting crash

00:09:30,800 --> 00:09:35,200
we try to fill the structure from a task

00:09:33,440 --> 00:09:36,399
underscore pt underscore x kernel

00:09:35,200 --> 00:09:40,000
function

00:09:36,399 --> 00:09:42,560
somehow on x86

00:09:40,000 --> 00:09:43,120
this kernel function always return

00:09:42,560 --> 00:09:46,480
something

00:09:43,120 --> 00:09:48,560
valuable for power pc

00:09:46,480 --> 00:09:50,080
it may generate nothing and we get in

00:09:48,560 --> 00:09:52,480
panic i don't know

00:09:50,080 --> 00:09:53,760
why why it happens but it worked like

00:09:52,480 --> 00:09:55,839
this

00:09:53,760 --> 00:09:58,080
the solution is quite easy we just need

00:09:55,839 --> 00:10:01,360
to handle that return value

00:09:58,080 --> 00:10:02,640
uh maybe nothing what i've learned from

00:10:01,360 --> 00:10:05,120
here that

00:10:02,640 --> 00:10:05,839
the same kernel functions may behave

00:10:05,120 --> 00:10:09,519
differently

00:10:05,839 --> 00:10:11,760
on power pc and other platforms

00:10:09,519 --> 00:10:12,800
let's move to the next panic i call that

00:10:11,760 --> 00:10:14,959
intermediate

00:10:12,800 --> 00:10:15,920
it's more difficult than the previous

00:10:14,959 --> 00:10:19,040
one because

00:10:15,920 --> 00:10:21,279
the panic happens not in linux k code so

00:10:19,040 --> 00:10:22,399
it happens somewhere else in the linux

00:10:21,279 --> 00:10:25,920
kernel

00:10:22,399 --> 00:10:29,440
it means that the module we're porting

00:10:25,920 --> 00:10:32,800
breaks something in the kernel and then

00:10:29,440 --> 00:10:36,640
some kernel subsystem hits

00:10:32,800 --> 00:10:36,640
the problem and we get the crash

00:10:36,880 --> 00:10:43,120
if we are lucky vm core which

00:10:40,399 --> 00:10:43,760
is generated during the crash can be

00:10:43,120 --> 00:10:47,279
helpful

00:10:43,760 --> 00:10:50,560
and we can open it with crash tool or

00:10:47,279 --> 00:10:53,600
any other tool and get

00:10:50,560 --> 00:10:57,440
the root cause of the problem

00:10:53,600 --> 00:10:59,760
if we look at back trace

00:10:57,440 --> 00:11:00,800
i don't know for me it's meaningless so

00:10:59,760 --> 00:11:04,880
i can't get

00:11:00,800 --> 00:11:07,920
any conclusions from this and

00:11:04,880 --> 00:11:11,200
need to go deeper into the vm core and

00:11:07,920 --> 00:11:12,880
open it with a crash tool i opened the

00:11:11,200 --> 00:11:15,600
dreamcore with debugger

00:11:12,880 --> 00:11:16,320
and i was lucky because crash tool does

00:11:15,600 --> 00:11:18,800
some basic

00:11:16,320 --> 00:11:19,760
verification of the kernel structures in

00:11:18,800 --> 00:11:23,360
the vm core

00:11:19,760 --> 00:11:26,240
it opens and it printed some errors

00:11:23,360 --> 00:11:28,560
these earth looked like a kernel

00:11:26,240 --> 00:11:33,120
corruption to me and i

00:11:28,560 --> 00:11:36,480
got this traction names

00:11:33,120 --> 00:11:39,519
and their location what i can do

00:11:36,480 --> 00:11:43,360
as the next step i can print

00:11:39,519 --> 00:11:46,480
the structures that looks corrupted and

00:11:43,360 --> 00:11:49,120
see the pattern of the corruption

00:11:46,480 --> 00:11:50,800
in this case i was lucky because the

00:11:49,120 --> 00:11:54,959
corrupted memory

00:11:50,800 --> 00:11:55,519
pages contained instruction pointers i

00:11:54,959 --> 00:11:58,880
mean

00:11:55,519 --> 00:12:01,920
pointers to text it

00:11:58,880 --> 00:12:04,720
gave me hint that somehow stack

00:12:01,920 --> 00:12:06,000
and wind algorithm corrupts memory

00:12:04,720 --> 00:12:08,639
because only

00:12:06,000 --> 00:12:10,959
stack and winding or back tracing deals

00:12:08,639 --> 00:12:14,160
with instruction pointers

00:12:10,959 --> 00:12:17,839
somehow we store them to

00:12:14,160 --> 00:12:21,200
the wrong address and i

00:12:17,839 --> 00:12:24,079
reviewed the

00:12:21,200 --> 00:12:26,399
unwind algorithm in greater details and

00:12:24,079 --> 00:12:28,160
found the root cause

00:12:26,399 --> 00:12:30,399
it was found that there was a code

00:12:28,160 --> 00:12:34,320
change in linux kernel

00:12:30,399 --> 00:12:36,320
4.7 the structure called

00:12:34,320 --> 00:12:38,240
perth underscore called chain underscore

00:12:36,320 --> 00:12:38,880
entry which is used for storing

00:12:38,240 --> 00:12:42,720
instruction

00:12:38,880 --> 00:12:46,800
pointers have been changed before

00:12:42,720 --> 00:12:49,839
linux kernel 4.7 it had a pre-allocated

00:12:46,800 --> 00:12:51,279
array for 127 elements for storing

00:12:49,839 --> 00:12:55,279
instruction pointers

00:12:51,279 --> 00:12:58,560
starting version 4.7 it has zero size

00:12:55,279 --> 00:13:00,639
so linux ki uh tries to

00:12:58,560 --> 00:13:02,079
write instruction pointers into the

00:13:00,639 --> 00:13:06,240
array and corrupts

00:13:02,079 --> 00:13:09,040
the memory uh beyond the structure

00:13:06,240 --> 00:13:10,399
the problem happens on all platforms but

00:13:09,040 --> 00:13:14,399
somehow

00:13:10,399 --> 00:13:17,760
only power pc panics

00:13:14,399 --> 00:13:20,399
so x86 was just lucky that

00:13:17,760 --> 00:13:22,800
corruption doesn't affect anything

00:13:20,399 --> 00:13:25,279
important

00:13:22,800 --> 00:13:26,000
the fix was well actually i just

00:13:25,279 --> 00:13:29,680
reported

00:13:26,000 --> 00:13:32,800
uh the problem to the maintainer and

00:13:29,680 --> 00:13:36,959
he provided the fix for all

00:13:32,800 --> 00:13:39,120
platforms including power pc

00:13:36,959 --> 00:13:40,959
what i've learned from these we live in

00:13:39,120 --> 00:13:42,800
in wonderful linux world

00:13:40,959 --> 00:13:44,720
when kernel structures may be changed

00:13:42,800 --> 00:13:46,639
silently anytime

00:13:44,720 --> 00:13:49,600
and you may know this only when get a

00:13:46,639 --> 00:13:50,480
kernel crash the only way to avoid such

00:13:49,600 --> 00:13:53,600
panics

00:13:50,480 --> 00:13:55,120
is to test your software against each

00:13:53,600 --> 00:13:58,160
and every

00:13:55,120 --> 00:14:01,199
kernel version and be extremely careful

00:13:58,160 --> 00:14:04,560
when send your code to

00:14:01,199 --> 00:14:08,320
customers or run on

00:14:04,560 --> 00:14:11,040
some critical systems

00:14:08,320 --> 00:14:13,120
all these things may be obvious to

00:14:11,040 --> 00:14:16,320
professional programmers who write code

00:14:13,120 --> 00:14:19,519
every day and now all these details

00:14:16,320 --> 00:14:22,959
about linux kernel development

00:14:19,519 --> 00:14:26,399
but for me that was

00:14:22,959 --> 00:14:27,040
something new and if you are in similar

00:14:26,399 --> 00:14:30,240
position

00:14:27,040 --> 00:14:31,600
you need to take such things into

00:14:30,240 --> 00:14:34,399
account when you port

00:14:31,600 --> 00:14:35,279
something to open power let's move to

00:14:34,399 --> 00:14:37,519
third panic

00:14:35,279 --> 00:14:39,040
i called it crazy because it happens

00:14:37,519 --> 00:14:41,600
outside of linux k

00:14:39,040 --> 00:14:43,199
code so we can't instrument our code

00:14:41,600 --> 00:14:47,519
with print case and

00:14:43,199 --> 00:14:47,519
debug the problem on the other hand

00:14:47,680 --> 00:14:51,040
the veeam core seemed useless i spent

00:14:50,560 --> 00:14:53,839
many

00:14:51,040 --> 00:14:54,560
hours looking into vm core with debugger

00:14:53,839 --> 00:14:57,680
and

00:14:54,560 --> 00:14:59,680
it didn't help to reach the root code i

00:14:57,680 --> 00:15:02,880
don't know probably i did something

00:14:59,680 --> 00:15:04,959
incorrectly and

00:15:02,880 --> 00:15:06,160
the panic happens in the interrupt

00:15:04,959 --> 00:15:09,680
processing code

00:15:06,160 --> 00:15:12,560
somehow interrupts were enabled

00:15:09,680 --> 00:15:13,279
at point where they should be disabled

00:15:12,560 --> 00:15:16,320
it means

00:15:13,279 --> 00:15:19,839
that a linux k module

00:15:16,320 --> 00:15:22,959
uh have been called it did something

00:15:19,839 --> 00:15:26,320
left interrupt in a wrong state

00:15:22,959 --> 00:15:28,959
and later some kernel code

00:15:26,320 --> 00:15:29,680
checked the interrupt state and got a

00:15:28,959 --> 00:15:32,880
panic

00:15:29,680 --> 00:15:36,000
so at moment of the panic

00:15:32,880 --> 00:15:37,759
the initial event which caused the

00:15:36,000 --> 00:15:42,160
problem is gone

00:15:37,759 --> 00:15:42,160
i spent long time in

00:15:42,240 --> 00:15:46,160
with looking into the code discussions

00:15:45,519 --> 00:15:50,240
with my

00:15:46,160 --> 00:15:52,959
colleagues with linux sky maintainer

00:15:50,240 --> 00:15:54,560
it didn't help because panics happens

00:15:52,959 --> 00:15:59,279
only on power pc

00:15:54,560 --> 00:16:01,600
and never seen on x86 or

00:15:59,279 --> 00:16:01,600
arm

00:16:02,320 --> 00:16:06,320
finally the only way to get the root

00:16:05,839 --> 00:16:09,680
cause

00:16:06,320 --> 00:16:12,720
was to disable everything or

00:16:09,680 --> 00:16:13,360
kernel module functions and then enable

00:16:12,720 --> 00:16:17,440
them

00:16:13,360 --> 00:16:23,040
one by one until we get a panic

00:16:17,440 --> 00:16:25,759
so that helped to isolate the root cause

00:16:23,040 --> 00:16:26,320
finally it was found that j probes are

00:16:25,759 --> 00:16:29,120
causing

00:16:26,320 --> 00:16:30,720
panic with such strange symptoms jprox

00:16:29,120 --> 00:16:34,560
are used in linux ki for

00:16:30,720 --> 00:16:37,440
on cpu profiling they are deprecated

00:16:34,560 --> 00:16:38,320
in the latest linux kernel but still

00:16:37,440 --> 00:16:41,759
exist

00:16:38,320 --> 00:16:45,839
in kernel 4.12

00:16:41,759 --> 00:16:49,199
where the panic was seen

00:16:45,839 --> 00:16:52,880
somehow jprobs work on x86

00:16:49,199 --> 00:16:56,560
but do not work on power pc and

00:16:52,880 --> 00:16:59,759
the solution was quite easy

00:16:56,560 --> 00:17:00,560
we just moved from jprobes to a new

00:16:59,759 --> 00:17:04,319
mechanism

00:17:00,560 --> 00:17:07,120
for recent linux kernel

00:17:04,319 --> 00:17:07,919
where they are deprecated i don't know

00:17:07,120 --> 00:17:09,839
one i've

00:17:07,919 --> 00:17:13,520
what i've learned from this experience i

00:17:09,839 --> 00:17:13,520
don't know maybe just improved

00:17:13,919 --> 00:17:21,600
my debugging skills and unfortunately

00:17:17,679 --> 00:17:24,160
when porting tools to open power you

00:17:21,600 --> 00:17:25,120
may hit such problems and need to deal

00:17:24,160 --> 00:17:27,600
with them

00:17:25,120 --> 00:17:28,880
and better to be informed about this in

00:17:27,600 --> 00:17:31,360
advance

00:17:28,880 --> 00:17:32,080
finally we made linux k working on

00:17:31,360 --> 00:17:35,200
openpower

00:17:32,080 --> 00:17:37,280
platform and hopefully it will be merged

00:17:35,200 --> 00:17:38,320
with upstream soon at the end available

00:17:37,280 --> 00:17:40,160
at github

00:17:38,320 --> 00:17:41,440
at the same location with other

00:17:40,160 --> 00:17:44,720
platforms

00:17:41,440 --> 00:17:46,960
arm and x86

00:17:44,720 --> 00:17:48,640
we did some amount of testing and

00:17:46,960 --> 00:17:52,080
verification

00:17:48,640 --> 00:17:54,960
uh the fix at some panics but

00:17:52,080 --> 00:17:56,080
definitely there is a wide area for

00:17:54,960 --> 00:18:00,640
further testing

00:17:56,080 --> 00:18:04,640
and code improvements

00:18:00,640 --> 00:18:07,919
this work showed that porting such tools

00:18:04,640 --> 00:18:11,120
which includes kernel

00:18:07,919 --> 00:18:14,080
low level components

00:18:11,120 --> 00:18:17,360
to open power is doable even if you are

00:18:14,080 --> 00:18:20,080
not professional programmer

00:18:17,360 --> 00:18:21,600
it can be challenging but it's doable

00:18:20,080 --> 00:18:25,120
and

00:18:21,600 --> 00:18:28,799
in this presentation i showed possible

00:18:25,120 --> 00:18:33,120
problems that you may hit and some ways

00:18:28,799 --> 00:18:36,160
how to approach them and

00:18:33,120 --> 00:18:36,799
so thank you very much for watching and

00:18:36,160 --> 00:18:40,520
i'm

00:18:36,799 --> 00:18:43,520
ready to answer your quench questions

00:18:40,520 --> 00:18:43,520

YouTube URL: https://www.youtube.com/watch?v=uyjJldK9iu0


