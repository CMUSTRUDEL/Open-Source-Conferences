Title: IBM open sources the A2O Core! - Bill Flynn, IBM
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	IBM open sources the A2O Core! - Bill Flynn, IBM

Speakers: Bill Flynn

An out of order, single thread optimized core derived from the highly scalable in order commercially proven A2I core will be described.  The design leverages the same tightly coupled AXU accelerator interface as A2I.  An overview of key microarchitecture and features and a brief description of cost/power benefits when implemented in the 7nm technology will be offered.  Finally, a description of the associated FPGA environment and simple how to video will be shown.
Captions: 
	00:00:00,640 --> 00:00:05,200
so what's a2 uh oh a2o was the follow-on

00:00:03,919 --> 00:00:06,640
to a2i

00:00:05,200 --> 00:00:10,800
but it was really meant to be a

00:00:06,640 --> 00:00:12,799
companion rather than a replacement

00:00:10,800 --> 00:00:14,080
so by targeting different applications

00:00:12,799 --> 00:00:16,320
the cores were meant to be able to

00:00:14,080 --> 00:00:19,680
coexist in a single system to meet

00:00:16,320 --> 00:00:20,640
customer requirements and the big

00:00:19,680 --> 00:00:23,439
difference is it

00:00:20,640 --> 00:00:24,640
targets workloads requiring high single

00:00:23,439 --> 00:00:28,400
thread performance

00:00:24,640 --> 00:00:31,679
versus a2i was a

00:00:28,400 --> 00:00:34,880
more of a streaming overall throughput

00:00:31,679 --> 00:00:37,360
design and

00:00:34,880 --> 00:00:39,040
the tool core largely retains

00:00:37,360 --> 00:00:42,320
compatibility with a2i

00:00:39,040 --> 00:00:42,320
external interfaces

00:00:42,399 --> 00:00:47,520
um to the memory and uh interrupt and

00:00:45,920 --> 00:00:49,760
other logic

00:00:47,520 --> 00:00:52,000
but the big difference especially for us

00:00:49,760 --> 00:00:55,360
at ibm is it's written in verilog

00:00:52,000 --> 00:00:57,520
rather than vhdl so um

00:00:55,360 --> 00:01:00,160
it's taken a little while for us to get

00:00:57,520 --> 00:01:00,160
used to that

00:01:06,560 --> 00:01:13,840
as soon as i find my slide i'll advance

00:01:10,840 --> 00:01:13,840
it

00:01:14,960 --> 00:01:19,920
so i discussed a lot of the a2 history

00:01:17,680 --> 00:01:23,360
in the a2i talk and i won't go into

00:01:19,920 --> 00:01:25,360
many details here but um a2i was the

00:01:23,360 --> 00:01:28,400
processor used in blue gmq

00:01:25,360 --> 00:01:31,280
and this is the picture of them

00:01:28,400 --> 00:01:32,799
the mirror mirror system at argonne that

00:01:31,280 --> 00:01:36,720
was retired at the end of

00:01:32,799 --> 00:01:40,240
2019 but it lasted seven years um

00:01:36,720 --> 00:01:40,560
so it had quite a long life of uh use

00:01:40,240 --> 00:01:45,200
and

00:01:40,560 --> 00:01:48,399
high reliability um this highlights

00:01:45,200 --> 00:01:48,960
some of the features of the cores and as

00:01:48,399 --> 00:01:50,960
i said

00:01:48,960 --> 00:01:53,119
the big difference obviously is the i

00:01:50,960 --> 00:01:56,799
versus o which is inorder

00:01:53,119 --> 00:02:02,320
versus out of order

00:01:56,799 --> 00:02:04,240
and uh smt4 for a2i whereas a2o

00:02:02,320 --> 00:02:05,680
at least in the original design it was

00:02:04,240 --> 00:02:10,080
only expected to be

00:02:05,680 --> 00:02:10,080
at most two two threads per core

00:02:18,319 --> 00:02:23,840
uh okay let me

00:02:21,440 --> 00:02:23,840
i got

00:02:24,640 --> 00:02:37,840
i must not be sharing shirts let me uh

00:02:28,080 --> 00:02:37,840
figure that out

00:02:41,840 --> 00:02:51,840
okay so here's the picture amira

00:03:02,080 --> 00:03:08,800
so here's a high level chart of

00:03:05,200 --> 00:03:10,319
the a20 processor core as mentioned it

00:03:08,800 --> 00:03:11,120
was designed for single thread

00:03:10,319 --> 00:03:14,159
performance

00:03:11,120 --> 00:03:17,760
rather than throughput but

00:03:14,159 --> 00:03:19,120
the same over overall goals of balancing

00:03:17,760 --> 00:03:23,040
performance and

00:03:19,120 --> 00:03:26,799
power and keeping the modularity

00:03:23,040 --> 00:03:30,080
um that a2i had designed in with

00:03:26,799 --> 00:03:31,680
uh configurable accelerator mmu

00:03:30,080 --> 00:03:35,680
microcode and such on

00:03:31,680 --> 00:03:40,239
interfaces um as i said

00:03:35,680 --> 00:03:44,480
the verilog rtl is the big difference

00:03:40,239 --> 00:03:46,080
for us and i think some people

00:03:44,480 --> 00:03:49,680
will for sure obviously be more

00:03:46,080 --> 00:03:51,760
comfortable with that than vhdl

00:03:49,680 --> 00:03:53,760
this shows some of the kind of

00:03:51,760 --> 00:03:56,319
differences of applications you would

00:03:53,760 --> 00:04:00,480
expect for a2i streaming and

00:03:56,319 --> 00:04:03,200
network processing versus

00:04:00,480 --> 00:04:03,840
more intense single thread things like

00:04:03,200 --> 00:04:07,519
ai

00:04:03,840 --> 00:04:11,360
and uh autonomous driving

00:04:07,519 --> 00:04:14,239
so 820 design features

00:04:11,360 --> 00:04:16,239
another difference is that it was 207

00:04:14,239 --> 00:04:19,519
versus 206

00:04:16,239 --> 00:04:25,040
for the isa so

00:04:19,519 --> 00:04:25,040
a small step forward but still book 3e

00:04:25,520 --> 00:04:32,720
two-way smt four-way fetch

00:04:29,120 --> 00:04:35,520
two-way dispatch and four-way issue

00:04:32,720 --> 00:04:36,720
out of order dispatch execution and g6

00:04:35,520 --> 00:04:40,000
g-share

00:04:36,720 --> 00:04:40,000
uh branch prediction

00:04:40,160 --> 00:04:49,040
the caches were doubled in size so 32

00:04:43,840 --> 00:04:51,759
ki cash 32k d cash uh same 64 byte line

00:04:49,040 --> 00:04:52,800
uh single cycle access and they also had

00:04:51,759 --> 00:04:56,080
a

00:04:52,800 --> 00:04:59,199
special prefetcher built into the data

00:04:56,080 --> 00:05:01,440
side to handle

00:04:59,199 --> 00:05:03,440
out of order it has a 32 entry

00:05:01,440 --> 00:05:06,000
completion buffer

00:05:03,440 --> 00:05:07,759
and then it has a 16 entry load store

00:05:06,000 --> 00:05:10,240
queue

00:05:07,759 --> 00:05:11,360
the modular design is very similar to

00:05:10,240 --> 00:05:15,600
a2i

00:05:11,360 --> 00:05:15,600
with these interfaces being

00:05:17,840 --> 00:05:23,039
selectable as to whether a certain core

00:05:20,639 --> 00:05:26,639
would implement the features or not

00:05:23,039 --> 00:05:39,840
and same as a2i also supported

00:05:26,639 --> 00:05:39,840
big endian and little ending

00:05:44,400 --> 00:05:49,120
so here we have a block diagram of the

00:05:46,400 --> 00:05:51,360
tool core

00:05:49,120 --> 00:05:52,720
as i said the ind cache are double the

00:05:51,360 --> 00:05:55,600
size of

00:05:52,720 --> 00:05:55,600
a2is

00:05:55,919 --> 00:06:00,800
the instruction buffer microcode engines

00:05:58,800 --> 00:06:03,759
renamers and completion logic

00:06:00,800 --> 00:06:04,560
are all duplicated for thread and

00:06:03,759 --> 00:06:07,840
reservation

00:06:04,560 --> 00:06:12,400
stations sit on top of all the uh

00:06:07,840 --> 00:06:14,319
the pipes and

00:06:12,400 --> 00:06:15,840
i think on the yeah the bottom right

00:06:14,319 --> 00:06:21,120
shows that there's a

00:06:15,840 --> 00:06:24,639
also a prefetcher for the d cash

00:06:21,120 --> 00:06:26,960
and same as a2i the ras

00:06:24,639 --> 00:06:27,840
test debug performance monitor type

00:06:26,960 --> 00:06:35,840
logic is

00:06:27,840 --> 00:06:35,840
all built in already

00:06:38,960 --> 00:06:43,600
um this slide lists a lot of the same

00:06:41,280 --> 00:06:49,039
features as the original

00:06:43,600 --> 00:06:52,639
uh slide i showed um

00:06:49,039 --> 00:06:52,639
not much more to say about it

00:06:53,520 --> 00:06:57,360
like i mentioned it was also designed

00:06:56,400 --> 00:07:02,800
for

00:06:57,360 --> 00:07:02,800
uh 27f04 as a 2i had been

00:07:03,919 --> 00:07:08,000
so we could run at the same clock

00:07:05,440 --> 00:07:08,000
frequency

00:07:12,560 --> 00:07:19,759
some of the details of the

00:07:16,160 --> 00:07:25,280
top of the pipe uh as mentioned

00:07:19,759 --> 00:07:30,000
64 byte i cash 16 entry e-rat

00:07:25,280 --> 00:07:33,280
which is a

00:07:30,000 --> 00:07:36,800
uh piece of the tlb it's local

00:07:33,280 --> 00:07:41,440
uh 16 entry instruction buffer

00:07:36,800 --> 00:07:45,039
18k bit um hybrid branch prediction

00:07:41,440 --> 00:07:47,360
8 entry link stack and rename

00:07:45,039 --> 00:07:49,360
dispatch and retire two instructions per

00:07:47,360 --> 00:07:52,879
cycle

00:07:49,360 --> 00:07:52,879
the reservation stations

00:07:53,440 --> 00:07:58,080
had a unified scorecard a separate

00:07:56,879 --> 00:08:01,520
reservation

00:07:58,080 --> 00:08:02,240
station per execution unit and each

00:08:01,520 --> 00:08:03,759
reservation

00:08:02,240 --> 00:08:06,960
station can accept up to two

00:08:03,759 --> 00:08:06,960
instructions per cycle

00:08:07,039 --> 00:08:10,840
the oldest instruction issues when

00:08:09,840 --> 00:08:13,840
available

00:08:10,840 --> 00:08:13,840
sources

00:08:14,160 --> 00:08:21,120
includes restart support for flushing

00:08:17,680 --> 00:08:21,120
16 entries per queue

00:08:21,440 --> 00:08:25,759
and data forwarding between pipelines

00:08:23,840 --> 00:08:27,360
adds one cycle of latency for all

00:08:25,759 --> 00:08:30,960
operations

00:08:27,360 --> 00:08:34,959
and for the special

00:08:30,960 --> 00:08:36,880
for gprs and the various special purpose

00:08:34,959 --> 00:08:38,399
condition code type registers and link

00:08:36,880 --> 00:08:41,839
register and count on

00:08:38,399 --> 00:08:41,839
full bypass

00:08:45,680 --> 00:08:52,720
on the back end the load store

00:08:48,959 --> 00:08:54,800
unit had a 32 entry e-rat

00:08:52,720 --> 00:08:56,560
it's stored through cache which is same

00:08:54,800 --> 00:08:59,760
as a2i was

00:08:56,560 --> 00:09:02,640
non-blocking hit under miss um

00:08:59,760 --> 00:09:03,519
had the same uh back and validate

00:09:02,640 --> 00:09:06,720
support

00:09:03,519 --> 00:09:10,800
as a2i also did for snooping so

00:09:06,720 --> 00:09:13,040
it was ready to be attached to a smp

00:09:10,800 --> 00:09:17,600
type environment

00:09:13,040 --> 00:09:21,040
uh l1 hit was a four cycle load to use

00:09:17,600 --> 00:09:24,800
uh 16 byte load storage support for the

00:09:21,040 --> 00:09:28,240
accelerators d cash uh

00:09:24,800 --> 00:09:31,040
software line locking and weight locking

00:09:28,240 --> 00:09:32,399
with an eight entry load miscue and a 12

00:09:31,040 --> 00:09:35,680
entry store queue

00:09:32,399 --> 00:09:37,600
um the store cues a big difference from

00:09:35,680 --> 00:09:41,040
a2i since that did not even

00:09:37,600 --> 00:09:44,640
have a store queue it sent everything

00:09:41,040 --> 00:09:48,320
right out to the a2l2 bus

00:09:44,640 --> 00:09:53,680
um intelligent data prefetching

00:09:48,320 --> 00:09:53,680
learning strides for specific loads

00:09:53,920 --> 00:10:00,640
with a claim 95 accuracy

00:09:57,680 --> 00:10:05,839
the fixed point units one cycle latency

00:10:00,640 --> 00:10:05,839
for simple ads and subtracts

00:10:06,959 --> 00:10:10,959
all other ad subtracts logicals or two

00:10:09,360 --> 00:10:13,120
cycles

00:10:10,959 --> 00:10:15,440
multiplies and divides only to fixed

00:10:13,120 --> 00:10:17,200
point unit zero

00:10:15,440 --> 00:10:19,839
with a multiplied latency of three to

00:10:17,200 --> 00:10:19,839
six cycles

00:10:19,920 --> 00:10:27,519
uh a two bit per cycle divider

00:10:24,480 --> 00:10:27,519
that could end early

00:10:28,000 --> 00:10:32,399
and then the branch unit also shared

00:10:29,760 --> 00:10:34,320
with fx0

00:10:32,399 --> 00:10:37,519
to resolve one branch per cycle and

00:10:34,320 --> 00:10:41,519
handle zero logicals

00:10:37,519 --> 00:10:45,360
and then the double precision flow

00:10:41,519 --> 00:10:48,240
i imagine was very similar to a2i um

00:10:45,360 --> 00:10:50,959
not 100 sure but besides the conversion

00:10:48,240 --> 00:11:01,839
of airlock i would expect it to be

00:10:50,959 --> 00:11:01,839
quite similar

00:11:04,240 --> 00:11:11,279
so this is the card design that we did

00:11:07,680 --> 00:11:13,440
uh very similar to what was on a2i we

00:11:11,279 --> 00:11:16,720
used the same card

00:11:13,440 --> 00:11:18,320
uh you can see from the utilization that

00:11:16,720 --> 00:11:21,600
we were way up there

00:11:18,320 --> 00:11:24,959
this is smt one

00:11:21,600 --> 00:11:26,800
generation the verilog has a lot of

00:11:24,959 --> 00:11:30,399
knobs to turn

00:11:26,800 --> 00:11:33,040
as far as controlling generation and um

00:11:30,399 --> 00:11:34,959
smt versus single thread or single

00:11:33,040 --> 00:11:37,120
thread versus smt2 is

00:11:34,959 --> 00:11:39,200
one of those so we didn't even get far

00:11:37,120 --> 00:11:43,279
enough obviously with this

00:11:39,200 --> 00:11:45,920
to be able to attempt smt2 so

00:11:43,279 --> 00:11:47,839
even with putting the b rams in you ram

00:11:45,920 --> 00:11:50,399
which we hadn't done for a2i we were

00:11:47,839 --> 00:11:53,920
still way up there on

00:11:50,399 --> 00:11:57,519
lux and vram utilization but

00:11:53,920 --> 00:12:00,720
besides that the overall layouts

00:11:57,519 --> 00:12:05,680
very similar we did not uh

00:12:00,720 --> 00:12:06,399
combine the 20 core with the a2l2 axi

00:12:05,680 --> 00:12:10,079
logic

00:12:06,399 --> 00:12:12,079
um not for any real reason just as it

00:12:10,079 --> 00:12:13,440
had started to be built that way at the

00:12:12,079 --> 00:12:16,639
top level we just

00:12:13,440 --> 00:12:21,440
created those ips separately

00:12:16,639 --> 00:12:24,639
the b ram and regs are identical

00:12:21,440 --> 00:12:29,839
i think most of the axilla

00:12:24,639 --> 00:12:33,519
things are the same on the vios again we

00:12:29,839 --> 00:12:35,200
mostly were using to connect up uh

00:12:33,519 --> 00:12:36,639
make sure that there was no one

00:12:35,200 --> 00:12:39,120
connected logic and

00:12:36,639 --> 00:12:40,240
but also some basic control stuff for

00:12:39,120 --> 00:12:44,959
running

00:12:40,240 --> 00:12:47,200
the core on the fpga and again we had no

00:12:44,959 --> 00:12:48,240
external interface except for the

00:12:47,200 --> 00:12:51,680
differential clock

00:12:48,240 --> 00:12:54,240
so pretty simple design

00:12:51,680 --> 00:12:55,680
and we definitely like to expand it a

00:12:54,240 --> 00:13:00,399
little

00:12:55,680 --> 00:13:00,399
at least at on ddr same as a2i

00:13:05,279 --> 00:13:13,440
um this is a scaling that we did again

00:13:09,360 --> 00:13:16,639
similar to a2i uh pretty much the same

00:13:13,440 --> 00:13:20,000
conclusion it gets pretty small

00:13:16,639 --> 00:13:20,240
in seven nanometer and still can run at

00:13:20,000 --> 00:13:23,519
a

00:13:20,240 --> 00:13:24,959
high frequency so um we still we think

00:13:23,519 --> 00:13:28,320
it's still definitely relevant

00:13:24,959 --> 00:13:30,880
for uh some designs today

00:13:28,320 --> 00:13:33,760
and for the same reasons of potentially

00:13:30,880 --> 00:13:36,720
mixing a2is with a2os and

00:13:33,760 --> 00:13:38,880
balancing uh different application loads

00:13:36,720 --> 00:13:38,880
to

00:13:39,440 --> 00:13:52,079
to certain threads etc

00:13:48,639 --> 00:13:53,360
and this summary is also a lot of what i

00:13:52,079 --> 00:13:55,839
said on a2i

00:13:53,360 --> 00:13:56,639
the big difference for a2o is that it

00:13:55,839 --> 00:13:59,440
never

00:13:56,639 --> 00:14:00,399
became an official product so

00:13:59,440 --> 00:14:03,519
unfortunately

00:14:00,399 --> 00:14:05,839
as designers we usually don't do all the

00:14:03,519 --> 00:14:08,639
documentation until the

00:14:05,839 --> 00:14:09,839
the uh tape out is happened and we're

00:14:08,639 --> 00:14:14,480
sitting around so

00:14:09,839 --> 00:14:16,800
um the documentation a lot of it

00:14:14,480 --> 00:14:18,320
is obviously derived from a2i there's

00:14:16,800 --> 00:14:21,920
been some updates but

00:14:18,320 --> 00:14:23,839
um there's definitely need for work

00:14:21,920 --> 00:14:25,839
especially on

00:14:23,839 --> 00:14:30,240
looking through the sprs and a lot of

00:14:25,839 --> 00:14:33,440
the implementation dependent logic to um

00:14:30,240 --> 00:14:34,320
uh verify that bits and all and fields

00:14:33,440 --> 00:14:37,760
and things are

00:14:34,320 --> 00:14:40,720
accurate to the rtl um

00:14:37,760 --> 00:14:42,720
so we'll be hopefully doing that with

00:14:40,720 --> 00:14:46,720
the community on the repo

00:14:42,720 --> 00:14:46,720
along the way the next few months

00:14:47,920 --> 00:14:51,760
the other thing is there's not a huge

00:14:50,320 --> 00:14:54,959
amount of description

00:14:51,760 --> 00:14:56,320
of the interesting part of a20 in the

00:14:54,959 --> 00:14:59,199
user manual which is

00:14:56,320 --> 00:15:01,279
the uh obviously the renaming issue

00:14:59,199 --> 00:15:04,560
tagging instructions and

00:15:01,279 --> 00:15:05,360
all that completion buffer all that kind

00:15:04,560 --> 00:15:07,199
of uh

00:15:05,360 --> 00:15:10,000
information is somewhat lacking in the

00:15:07,199 --> 00:15:12,720
document so hopefully we can

00:15:10,000 --> 00:15:13,760
work to get a better understanding of

00:15:12,720 --> 00:15:17,760
what's happening

00:15:13,760 --> 00:15:20,079
in that logic um as far as adding

00:15:17,760 --> 00:15:21,279
things to the design they're all kind of

00:15:20,079 --> 00:15:24,959
the same list as

00:15:21,279 --> 00:15:29,040
i mentioned for a2i of uh

00:15:24,959 --> 00:15:29,040
some obvious things just to help debug

00:15:29,839 --> 00:15:34,560
and do some stuff on the software side

00:15:33,040 --> 00:15:38,399
to get some better testing

00:15:34,560 --> 00:15:41,120
and uh validation as

00:15:38,399 --> 00:15:42,720
as we do make changes to the logic we

00:15:41,120 --> 00:15:46,160
really need something

00:15:42,720 --> 00:15:47,759
to be able to test against to

00:15:46,160 --> 00:15:50,000
prove we're not breaking anything too

00:15:47,759 --> 00:15:50,000
bad

00:15:53,600 --> 00:15:59,360
so i didn't mention but

00:15:56,720 --> 00:16:00,480
um part of this project was also to work

00:15:59,360 --> 00:16:03,440
with

00:16:00,480 --> 00:16:04,320
a group of extreme blue interns which is

00:16:03,440 --> 00:16:07,759
a special

00:16:04,320 --> 00:16:11,519
internship that ibm has and

00:16:07,759 --> 00:16:13,600
wanted to thank them for their help

00:16:11,519 --> 00:16:14,880
did a lot of hard work and we were able

00:16:13,600 --> 00:16:17,839
to

00:16:14,880 --> 00:16:17,839
get through the whole

00:16:18,079 --> 00:16:22,880
find the verilog update it to work with

00:16:21,519 --> 00:16:24,720
xilinx

00:16:22,880 --> 00:16:27,279
go through the documentation at least

00:16:24,720 --> 00:16:27,839
one time and uh get the card up and

00:16:27,279 --> 00:16:31,199
running

00:16:27,839 --> 00:16:32,800
in 12 weeks so um

00:16:31,199 --> 00:16:34,399
as i said there was a lot of things to

00:16:32,800 --> 00:16:37,680
get all that working and

00:16:34,399 --> 00:16:39,839
thanks to chester and harsh and adida

00:16:37,680 --> 00:16:41,040
for all their work and hopefully they'll

00:16:39,839 --> 00:16:44,639
join us on

00:16:41,040 --> 00:16:46,160
the forums to um spread some of the

00:16:44,639 --> 00:16:51,839
knowledge they gained over

00:16:46,160 --> 00:16:51,839
over these past few months

00:16:52,399 --> 00:16:59,680
and just enclosing again

00:16:56,399 --> 00:17:04,880
um everything is now open

00:16:59,680 --> 00:17:08,240
at open power cores a200 and uh

00:17:04,880 --> 00:17:09,919
we hopefully will see a bunch of people

00:17:08,240 --> 00:17:13,120
out there and make some

00:17:09,919 --> 00:17:14,799
uh progress on using this core for

00:17:13,120 --> 00:17:18,079
any kind of interesting things in the

00:17:14,799 --> 00:17:20,959
future so

00:17:18,079 --> 00:17:22,959
thanks for joining the presentation and

00:17:20,959 --> 00:17:32,240
any questions

00:17:22,959 --> 00:17:34,720
can go ahead

00:17:32,240 --> 00:17:37,760
so i see one question why is it a big

00:17:34,720 --> 00:17:42,640
deal to use verilog instead of vhdl well

00:17:37,760 --> 00:17:44,880
i'm not sure it is but um at least

00:17:42,640 --> 00:17:46,960
i believe some people think it is um

00:17:44,880 --> 00:17:50,400
obviously in ibm

00:17:46,960 --> 00:17:52,240
we've used vhdl almost exclusively

00:17:50,400 --> 00:17:53,760
um it kind of depends where you are in

00:17:52,240 --> 00:17:56,880
the world i think as to

00:17:53,760 --> 00:18:00,000
what your main uh design language is

00:17:56,880 --> 00:18:03,440
but there definitely seems to be

00:18:00,000 --> 00:18:15,840
a fair amount of interest in

00:18:03,440 --> 00:18:15,840
verilog designs versus vhdl

00:18:42,880 --> 00:18:57,840
so there's a question from florin

00:19:05,200 --> 00:19:09,440
on how to position an a2o design versus

00:19:08,880 --> 00:19:12,160
arm

00:19:09,440 --> 00:19:12,160
for edge

00:19:12,799 --> 00:19:21,120
i think that depends on on your

00:19:16,080 --> 00:19:23,360
eventual application of it obviously

00:19:21,120 --> 00:19:24,880
the big thing we would say would be the

00:19:23,360 --> 00:19:29,520
full power

00:19:24,880 --> 00:19:31,440
compliancy at the 3.1 level would be a

00:19:29,520 --> 00:19:34,240
big difference

00:19:31,440 --> 00:19:36,720
for the software stack and other things

00:19:34,240 --> 00:19:36,720
like that

00:19:37,280 --> 00:19:41,520
but again it's going to depend on your

00:19:39,520 --> 00:19:44,000
application

00:19:41,520 --> 00:19:44,000
for sure

00:19:48,080 --> 00:19:51,520
and luke asked what algorithm was used

00:19:50,240 --> 00:19:54,480
for out of order

00:19:51,520 --> 00:19:56,720
um i probably can't even answer that

00:19:54,480 --> 00:19:59,280
right now

00:19:56,720 --> 00:20:00,400
i have not been able to look too much in

00:19:59,280 --> 00:20:04,240
detail into

00:20:00,400 --> 00:20:04,960
that whole uh section of the pipe even

00:20:04,240 --> 00:20:08,000
though

00:20:04,960 --> 00:20:10,080
i thought i would it was one of the most

00:20:08,000 --> 00:20:11,840
interesting parts for me for sure i had

00:20:10,080 --> 00:20:15,200
worked uh

00:20:11,840 --> 00:20:18,240
the last two years on p10 and

00:20:15,200 --> 00:20:20,720
i was doing one half of the renaming and

00:20:18,240 --> 00:20:22,320
history buffer logic so i would also

00:20:20,720 --> 00:20:25,360
like to look at that but

00:20:22,320 --> 00:20:26,559
um there's no way i can describe the

00:20:25,360 --> 00:20:28,880
tagging in

00:20:26,559 --> 00:20:29,840
things like that right now um just

00:20:28,880 --> 00:20:32,720
haven't gotten that

00:20:29,840 --> 00:20:35,200
deep into the digging into the logic and

00:20:32,720 --> 00:20:37,760
that's why i said the documentation was

00:20:35,200 --> 00:20:39,200
lacking unfortunately so um it would be

00:20:37,760 --> 00:20:40,960
nice if we could

00:20:39,200 --> 00:20:45,280
try to understand that on the repo and

00:20:40,960 --> 00:20:45,280
add some useful information to the

00:20:46,840 --> 00:20:49,840
documentation

00:21:05,679 --> 00:21:17,840
so we have a question from jay

00:21:21,600 --> 00:21:29,360
asking about will it run linux ppc

00:21:24,640 --> 00:21:32,799
64 le today um if that's the

00:21:29,360 --> 00:21:35,280
current level of

00:21:32,799 --> 00:21:37,280
linux distro then i believe the answer

00:21:35,280 --> 00:21:42,159
is no

00:21:37,280 --> 00:21:45,360
um i think it's been discussed that the

00:21:42,159 --> 00:21:49,280
latest linux distros require

00:21:45,360 --> 00:21:52,320
uh at least some vector support and

00:21:49,280 --> 00:21:54,400
the a2i and a2o core both don't

00:21:52,320 --> 00:21:56,159
have that even though it can be attached

00:21:54,400 --> 00:22:13,840
to the accelerator interface

00:21:56,159 --> 00:22:13,840
um it's not in the logic right now

00:22:17,919 --> 00:22:23,120
by many other ones um looks like

00:22:21,039 --> 00:22:24,840
luke asks how many instructions per

00:22:23,120 --> 00:22:28,400
clock

00:22:24,840 --> 00:22:41,840
um if that means how much it can

00:22:28,400 --> 00:22:41,840
complete per cycle it was two

00:23:32,880 --> 00:23:37,039
so it looks like we're running out of

00:23:34,320 --> 00:23:38,720
time um we can meet on slack for any

00:23:37,039 --> 00:23:40,960
further questions

00:23:38,720 --> 00:23:40,960
um

00:23:45,520 --> 00:23:51,840
oh it looks like there's a few more that

00:23:47,919 --> 00:23:51,840
have shown up

00:23:53,919 --> 00:23:57,919
does the value of the co-processor

00:23:56,000 --> 00:23:59,120
interface change now that we have open

00:23:57,919 --> 00:24:02,960
source rtl

00:23:59,120 --> 00:24:04,480
um i think so um obviously if you can

00:24:02,960 --> 00:24:07,200
come

00:24:04,480 --> 00:24:08,159
come up with a somewhat standardized

00:24:07,200 --> 00:24:11,360
interface

00:24:08,159 --> 00:24:13,919
then you now have something to hook to

00:24:11,360 --> 00:24:15,440
um any kind of special purpose

00:24:13,919 --> 00:24:18,960
accelerators you want to do

00:24:15,440 --> 00:24:22,880
that are tightly coupled so uh yes

00:24:18,960 --> 00:24:25,679
it would be i think a big benefit um

00:24:22,880 --> 00:24:26,960
and also give you a test platform as

00:24:25,679 --> 00:24:28,720
long as you meet the interface

00:24:26,960 --> 00:24:33,840
obviously you'll be able to test out

00:24:28,720 --> 00:24:33,840
your accelerator pretty easily

00:24:39,200 --> 00:24:47,440
how does the core compare to microwatt

00:24:43,120 --> 00:24:50,720
um quite different um

00:24:47,440 --> 00:24:55,440
the fact that it was designed

00:24:50,720 --> 00:24:59,520
as a2i was and as a 27f04

00:24:55,440 --> 00:25:02,799
uh pipeline

00:24:59,520 --> 00:25:07,039
as was mentioned in the a2i

00:25:02,799 --> 00:25:10,880
presentation the logic potentially is

00:25:07,039 --> 00:25:13,440
somewhat ugly because it had to meet the

00:25:10,880 --> 00:25:16,080
timing requirements

00:25:13,440 --> 00:25:18,559
i believe microwatts i don't know how

00:25:16,080 --> 00:25:21,360
many stages of pipeline it's doing right

00:25:18,559 --> 00:25:24,880
now but it's obviously written

00:25:21,360 --> 00:25:29,440
at a much higher level uh

00:25:24,880 --> 00:25:32,880
than a2i or a2o was

00:25:29,440 --> 00:25:35,120
microwatt though will be ahead of these

00:25:32,880 --> 00:25:38,400
cores for sure i think

00:25:35,120 --> 00:25:41,520
in its ability to fully implement

00:25:38,400 --> 00:25:42,320
a compliant core just because it'll be a

00:25:41,520 --> 00:25:44,559
little easier

00:25:42,320 --> 00:25:46,880
anything obviously added to do

00:25:44,559 --> 00:25:48,000
compliancy for these cores has to fit

00:25:46,880 --> 00:25:50,159
into the whole

00:25:48,000 --> 00:25:51,360
control structure and pipeline that

00:25:50,159 --> 00:25:54,880
exists so

00:25:51,360 --> 00:25:58,000
that's uh that's a big difference

00:25:54,880 --> 00:25:58,720
for uh even understanding the the core

00:25:58,000 --> 00:26:01,360
itself

00:25:58,720 --> 00:26:02,159
let alone trying to implement uh

00:26:01,360 --> 00:26:04,960
anything

00:26:02,159 --> 00:26:06,720
fairly compliment complicated uh

00:26:04,960 --> 00:26:08,080
replacing instructions and things like

00:26:06,720 --> 00:26:10,720
that would be pretty easy

00:26:08,080 --> 00:26:13,200
um that'll all be in some decoded tables

00:26:10,720 --> 00:26:13,200
but um

00:26:13,279 --> 00:26:16,480
the farther you try to get into the

00:26:15,279 --> 00:26:19,360
pipeline

00:26:16,480 --> 00:26:22,080
the harder things obviously get as far

00:26:19,360 --> 00:26:22,080
as implementing

00:26:22,960 --> 00:26:27,200
some of the bigger things radix though

00:26:25,200 --> 00:26:30,000
should be fairly easy to attach

00:26:27,200 --> 00:26:33,200
because it should it should drop in

00:26:30,000 --> 00:26:35,919
basically on the mmu interface so

00:26:33,200 --> 00:26:38,320
that would be one one place to start for

00:26:35,919 --> 00:26:38,320
sure

00:26:38,480 --> 00:26:43,840
and it could potentially be done

00:26:41,919 --> 00:26:45,039
kind of without as many restrictions

00:26:43,840 --> 00:26:47,039
since it's not

00:26:45,039 --> 00:26:48,799
tied completely to the pipeline and

00:26:47,039 --> 00:26:49,600
there's obviously some signals that'll

00:26:48,799 --> 00:26:53,760
have to

00:26:49,600 --> 00:26:55,919
match up correctly but um a lot of it

00:26:53,760 --> 00:26:59,679
um that's how long you take to do the

00:26:55,919 --> 00:27:01,600
translate stuff like that could be

00:26:59,679 --> 00:27:04,880
probably delayed or whatever to make the

00:27:01,600 --> 00:27:04,880

YouTube URL: https://www.youtube.com/watch?v=2IshMgIGCR4


