Title: The Open Power ISA: Architecture Compliancy and Future Foundations - Brian W. Thompto, IBM
Publication date: 2020-09-21
Playlist: OpenPOWER Summit NA 2020
Description: 
	The Open Power ISA: Architecture Compliancy and Future Foundations - Brian W. Thompto, IBM

Speakers: Brian W. Thompto

The Open Power ISA enables access to unencumbered open innovation and a mature software ecosystem developed over the last 30 years.  In this talk, we will review the major options for architectural compliancy that provide freedom of choice in design, including four recently specified compliancy subsets, separate optional features, and custom extensions. IBM has also recently contributed the Power ISA Version 3.1 to the OpenPOWER Foundation. This latest architectural version includes a number of new features developed for the POWER10 server including a new foundation for future expansion via the introduction of an instruction prefix. New capabilities and compliancy implications will be summarized.
Captions: 
	00:00:00,080 --> 00:00:04,000
hello thanks for joining i'm going to be

00:00:02,399 --> 00:00:08,320
talking to you today about

00:00:04,000 --> 00:00:11,200
the open power open isa

00:00:08,320 --> 00:00:12,080
which is new as of last year we have

00:00:11,200 --> 00:00:14,960
contributed

00:00:12,080 --> 00:00:16,080
that is ibm has contributed the isa to

00:00:14,960 --> 00:00:18,880
the open power foundation

00:00:16,080 --> 00:00:20,320
and it's now being managed there and

00:00:18,880 --> 00:00:21,439
i'll take you first through a little bit

00:00:20,320 --> 00:00:23,199
of history

00:00:21,439 --> 00:00:25,199
you know about power give you some

00:00:23,199 --> 00:00:26,800
background and then we'll talk about the

00:00:25,199 --> 00:00:28,560
compliancy subsets

00:00:26,800 --> 00:00:30,080
that allow you to make a compliant

00:00:28,560 --> 00:00:33,280
hardware design

00:00:30,080 --> 00:00:35,600
compliant with the power architecture

00:00:33,280 --> 00:00:37,520
royalty free and you know able to do

00:00:35,600 --> 00:00:39,280
that in a very open way

00:00:37,520 --> 00:00:41,600
and then we'll talk a little bit after

00:00:39,280 --> 00:00:43,360
that about you know some of the optional

00:00:41,600 --> 00:00:44,719
features and other characteristics of

00:00:43,360 --> 00:00:47,120
the open isa

00:00:44,719 --> 00:00:48,079
followed by a quick discussion of some

00:00:47,120 --> 00:00:51,760
of the latest

00:00:48,079 --> 00:00:54,559
additions to the power isa in the 3.1

00:00:51,760 --> 00:00:54,559
architecture

00:00:54,800 --> 00:00:58,000
so first of all the power isa was

00:00:57,520 --> 00:01:00,960
announced

00:00:58,000 --> 00:01:02,480
last year in august as being contributed

00:01:00,960 --> 00:01:04,640
uh to the open community

00:01:02,480 --> 00:01:05,920
so we are very excited about that and

00:01:04,640 --> 00:01:07,520
looking forward to

00:01:05,920 --> 00:01:10,000
all the collaboration that happens

00:01:07,520 --> 00:01:11,520
around open hardware architectures

00:01:10,000 --> 00:01:13,439
as well as evolving the power

00:01:11,520 --> 00:01:15,360
architecture as we move forward and face

00:01:13,439 --> 00:01:17,040
new challenges in computing

00:01:15,360 --> 00:01:18,960
and find ways to do it together as an

00:01:17,040 --> 00:01:21,680
open community

00:01:18,960 --> 00:01:23,360
we've actually also put out with that

00:01:21,680 --> 00:01:24,880
openness you know we have a set of

00:01:23,360 --> 00:01:26,400
guidelines a set of rules

00:01:24,880 --> 00:01:28,320
those are out there as an end user

00:01:26,400 --> 00:01:30,400
license agreement and of course the

00:01:28,320 --> 00:01:31,680
basic nature of this is that you get all

00:01:30,400 --> 00:01:34,640
the architecture

00:01:31,680 --> 00:01:35,119
rights and abilities to make a compliant

00:01:34,640 --> 00:01:37,520
design

00:01:35,119 --> 00:01:39,119
royalty free and and that's part of the

00:01:37,520 --> 00:01:41,360
objective here is to make this this

00:01:39,119 --> 00:01:43,439
architecture accessible to everyone

00:01:41,360 --> 00:01:45,360
and at the same time it's very important

00:01:43,439 --> 00:01:47,280
that when we do that we do it in a very

00:01:45,360 --> 00:01:48,399
compliant way to make it so that the

00:01:47,280 --> 00:01:50,479
benefits

00:01:48,399 --> 00:01:51,680
of the cohesive power in architecture

00:01:50,479 --> 00:01:54,320
today are

00:01:51,680 --> 00:01:55,280
last for many more generations to come

00:01:54,320 --> 00:01:56,479
so

00:01:55,280 --> 00:01:58,399
today i'll take you through that a

00:01:56,479 --> 00:02:00,320
little bit and you know

00:01:58,399 --> 00:02:01,920
how did we define that those compliancy

00:02:00,320 --> 00:02:02,640
subsets well they're actually in a new

00:02:01,920 --> 00:02:04,320
preface

00:02:02,640 --> 00:02:05,600
they're spelled out in a very detailed

00:02:04,320 --> 00:02:06,799
manner i'll be going through things at a

00:02:05,600 --> 00:02:09,360
very high level

00:02:06,799 --> 00:02:10,560
but i encourage you to follow up by

00:02:09,360 --> 00:02:13,040
actually looking at

00:02:10,560 --> 00:02:15,040
the latest version of the architecture

00:02:13,040 --> 00:02:17,599
and the preface that actually describes

00:02:15,040 --> 00:02:19,200
the compliancy in in more detail

00:02:17,599 --> 00:02:21,360
so you can answer any of your detailed

00:02:19,200 --> 00:02:22,000
questions there i'll encourage you also

00:02:21,360 --> 00:02:24,000
at the end of this

00:02:22,000 --> 00:02:25,360
talk if you want to continue to chat

00:02:24,000 --> 00:02:27,200
find me on slack

00:02:25,360 --> 00:02:28,560
in the slack channel and if you have

00:02:27,200 --> 00:02:29,040
questions that accumulate during the

00:02:28,560 --> 00:02:31,680
talk

00:02:29,040 --> 00:02:33,280
please post them in the q a tab on zoom

00:02:31,680 --> 00:02:35,760
and i'll try to answer them at the end

00:02:33,280 --> 00:02:38,640
time allowing

00:02:35,760 --> 00:02:40,080
so then just in this recent may uh we

00:02:38,640 --> 00:02:42,080
were excited to add

00:02:40,080 --> 00:02:43,920
the 3.1 version of the architecture this

00:02:42,080 --> 00:02:45,599
is the version that's in our power 10

00:02:43,920 --> 00:02:47,680
processor for those that were

00:02:45,599 --> 00:02:50,239
listening to the previous presentation

00:02:47,680 --> 00:02:52,400
uh you know bill starkey and i presented

00:02:50,239 --> 00:02:53,599
on power 10 and some of its capabilities

00:02:52,400 --> 00:02:56,800
it's ibm's

00:02:53,599 --> 00:02:58,480
server class processor uh and it is

00:02:56,800 --> 00:03:00,000
got a lot of great capabilities and a

00:02:58,480 --> 00:03:01,599
number of those come and

00:03:00,000 --> 00:03:04,159
are embedded right there in that 3.1

00:03:01,599 --> 00:03:07,280
architecture so very excited about that

00:03:04,159 --> 00:03:08,000
uh also i'll point out that the power

00:03:07,280 --> 00:03:10,400
isa

00:03:08,000 --> 00:03:11,040
work group was chartered and and work

00:03:10,400 --> 00:03:12,560
has begun

00:03:11,040 --> 00:03:15,040
there as part of the open power

00:03:12,560 --> 00:03:16,480
foundation which is you know run with

00:03:15,040 --> 00:03:18,720
the linux foundation

00:03:16,480 --> 00:03:20,480
so very excited to see how that matures

00:03:18,720 --> 00:03:21,120
looking forward to a lot of vibrant uh

00:03:20,480 --> 00:03:24,400
dialogue

00:03:21,120 --> 00:03:25,680
moving forward around power so as i

00:03:24,400 --> 00:03:27,680
promised let's start with a little bit

00:03:25,680 --> 00:03:30,000
of history here we'll look back

00:03:27,680 --> 00:03:32,159
at power now you know key here is that

00:03:30,000 --> 00:03:34,560
power already has a very vibrant

00:03:32,159 --> 00:03:36,159
ecosystem you can find you know source

00:03:34,560 --> 00:03:38,239
code and power support

00:03:36,159 --> 00:03:39,599
in many open source projects you know

00:03:38,239 --> 00:03:42,480
from over the years

00:03:39,599 --> 00:03:44,080
and power has a very rich legacy you

00:03:42,480 --> 00:03:46,560
know for those not aware

00:03:44,080 --> 00:03:48,799
power actually started with risk with

00:03:46,560 --> 00:03:51,760
researcher john and his team

00:03:48,799 --> 00:03:53,760
back in the 1970s they were actually

00:03:51,760 --> 00:03:55,360
exploring a risk architecture they

00:03:53,760 --> 00:03:57,040
really wanted to change things up they

00:03:55,360 --> 00:03:59,040
thought there was a lot of value

00:03:57,040 --> 00:04:01,280
in having instructions focused around

00:03:59,040 --> 00:04:02,560
the most common the most basic the most

00:04:01,280 --> 00:04:04,080
important functions

00:04:02,560 --> 00:04:05,360
and be able to do pipelining and other

00:04:04,080 --> 00:04:06,879
capabilities like that and they actually

00:04:05,360 --> 00:04:08,720
developed a risk prototype

00:04:06,879 --> 00:04:10,159
the first risk prototype in the in the

00:04:08,720 --> 00:04:11,840
mid 70s

00:04:10,159 --> 00:04:14,159
and of course then moving to

00:04:11,840 --> 00:04:15,760
productization you know ibm looked at

00:04:14,159 --> 00:04:17,199
productizing risk products and there

00:04:15,760 --> 00:04:19,280
were also efforts

00:04:17,199 --> 00:04:20,479
underway at berkeley and stanford around

00:04:19,280 --> 00:04:22,720
risk you know at

00:04:20,479 --> 00:04:24,639
you know in the around 1980 and

00:04:22,720 --> 00:04:26,880
eventually what that turned into for ibm

00:04:24,639 --> 00:04:27,280
was in 1985 focusing on the upper right

00:04:26,880 --> 00:04:29,440
there

00:04:27,280 --> 00:04:30,479
was the america project and ibm began to

00:04:29,440 --> 00:04:32,880
make products

00:04:30,479 --> 00:04:35,120
around this risk architecture that john

00:04:32,880 --> 00:04:37,759
 and his team had come up with

00:04:35,120 --> 00:04:38,960
and by 1990 that that was the beginning

00:04:37,759 --> 00:04:42,720
of power

00:04:38,960 --> 00:04:44,320
performance optimized architecture

00:04:42,720 --> 00:04:46,320
with enhanced risk that's what the

00:04:44,320 --> 00:04:48,160
acronym stands for and so the power

00:04:46,320 --> 00:04:49,759
story really began there

00:04:48,160 --> 00:04:51,520
and taking you through that lineage

00:04:49,759 --> 00:04:54,080
there depicted on the right side

00:04:51,520 --> 00:04:55,199
you know very shortly after ibm first

00:04:54,080 --> 00:04:58,479
launched its power

00:04:55,199 --> 00:05:01,440
server line uh you know ibm

00:04:58,479 --> 00:05:03,280
apple uh and motorola formed the aim

00:05:01,440 --> 00:05:04,400
alliance and they actually began working

00:05:03,280 --> 00:05:06,639
on the power pc

00:05:04,400 --> 00:05:08,000
architecture which was the platform used

00:05:06,639 --> 00:05:10,960
in the macintosh

00:05:08,000 --> 00:05:12,880
in the early 1990s and power pc went

00:05:10,960 --> 00:05:15,440
through several generations there

00:05:12,880 --> 00:05:17,199
and actually in parallel you know the

00:05:15,440 --> 00:05:19,759
the server architecture continued on the

00:05:17,199 --> 00:05:23,840
ibm side and those actually reconverged

00:05:19,759 --> 00:05:26,240
into a 64-bit architecture around

00:05:23,840 --> 00:05:28,400
and then in at this around the same time

00:05:26,240 --> 00:05:30,960
uh the architecture also was spun

00:05:28,400 --> 00:05:31,600
off into an embedded uh portion of its

00:05:30,960 --> 00:05:33,120
lineage

00:05:31,600 --> 00:05:35,360
and so that embedded portion of its

00:05:33,120 --> 00:05:38,000
lineage was began to take

00:05:35,360 --> 00:05:39,919
take form and you find many ibm power

00:05:38,000 --> 00:05:40,720
embedded processors really all over the

00:05:39,919 --> 00:05:42,479
world

00:05:40,720 --> 00:05:43,840
power in many forms all over the world

00:05:42,479 --> 00:05:44,880
and of course even in other planets

00:05:43,840 --> 00:05:47,120
right so we've got

00:05:44,880 --> 00:05:49,039
mars rovers up there we've got a space

00:05:47,120 --> 00:05:51,360
you know other space elements up there

00:05:49,039 --> 00:05:53,039
running power processors and power

00:05:51,360 --> 00:05:54,000
processors can be found all across the

00:05:53,039 --> 00:05:55,600
world

00:05:54,000 --> 00:05:57,280
automotive everything from automotives

00:05:55,600 --> 00:05:59,919
to super computers

00:05:57,280 --> 00:06:01,520
so a very rich legacy there and and if

00:05:59,919 --> 00:06:04,479
you look at that lineage

00:06:01,520 --> 00:06:06,080
what we ultimately did is back in there

00:06:04,479 --> 00:06:07,759
about the early 2000s

00:06:06,080 --> 00:06:09,280
the goal was well let's try to get those

00:06:07,759 --> 00:06:10,560
converged back together under one

00:06:09,280 --> 00:06:11,840
umbrella to really manage the

00:06:10,560 --> 00:06:14,319
architecture so

00:06:11,840 --> 00:06:16,800
there is an entity called power.org and

00:06:14,319 --> 00:06:17,280
an alliance was formed with motorola ibm

00:06:16,800 --> 00:06:19,440
and many

00:06:17,280 --> 00:06:20,800
others to bring that power architecture

00:06:19,440 --> 00:06:22,479
back under one roof

00:06:20,800 --> 00:06:24,720
but it was a closed group at the time it

00:06:22,479 --> 00:06:26,639
certainly wasn't an open architecture

00:06:24,720 --> 00:06:29,039
and so with that the embedded features

00:06:26,639 --> 00:06:31,520
did continue and at the same time

00:06:29,039 --> 00:06:33,199
power you know and and the ibm server

00:06:31,520 --> 00:06:35,120
line continued to build on

00:06:33,199 --> 00:06:37,199
those characteristics building in

00:06:35,120 --> 00:06:39,039
through the early 2000s

00:06:37,199 --> 00:06:41,360
and so what that ultimately resulted in

00:06:39,039 --> 00:06:44,160
is a 2.07 architecture

00:06:41,360 --> 00:06:45,919
that officially 2.07 b was the last of

00:06:44,160 --> 00:06:48,080
the embedded architectures

00:06:45,919 --> 00:06:50,000
and then now continuing on in recent

00:06:48,080 --> 00:06:51,680
years going from 2.07

00:06:50,000 --> 00:06:53,120
up to three point all the way up through

00:06:51,680 --> 00:06:55,759
to 3.0

00:06:53,120 --> 00:06:56,639
uh with power nine and then now this you

00:06:55,759 --> 00:06:58,639
know latest

00:06:56,639 --> 00:07:00,560
development which is really now

00:06:58,639 --> 00:07:02,800
launching this open isa

00:07:00,560 --> 00:07:04,880
will be bringing back in flexibility to

00:07:02,800 --> 00:07:05,199
make the power architecture again you

00:07:04,880 --> 00:07:07,919
know

00:07:05,199 --> 00:07:09,039
very primed for having a consistent

00:07:07,919 --> 00:07:10,880
ecosystem

00:07:09,039 --> 00:07:12,880
and at the software ecosystem while at

00:07:10,880 --> 00:07:14,880
the same time allowing for custom

00:07:12,880 --> 00:07:17,759
extensions again allowing for

00:07:14,880 --> 00:07:19,120
innovation in many different spaces and

00:07:17,759 --> 00:07:20,880
so that's the power isa

00:07:19,120 --> 00:07:22,400
lineage that we just just wanted to take

00:07:20,880 --> 00:07:23,759
you through there and then on the left

00:07:22,400 --> 00:07:25,919
side you see some of the

00:07:23,759 --> 00:07:27,520
the highlights here from a power

00:07:25,919 --> 00:07:29,199
architecture perspective

00:07:27,520 --> 00:07:31,280
really walking down the ibm server

00:07:29,199 --> 00:07:33,360
lineage uh view of it

00:07:31,280 --> 00:07:35,759
but as as that architecture advanced

00:07:33,360 --> 00:07:36,960
forward a lot of notable additions over

00:07:35,759 --> 00:07:38,960
time right starting with the base

00:07:36,960 --> 00:07:39,599
architecture as i mentioned adding 64

00:07:38,960 --> 00:07:43,039
bits

00:07:39,599 --> 00:07:45,360
adding the cmd vsx capabilities um

00:07:43,039 --> 00:07:47,039
you know over time and then some of the

00:07:45,360 --> 00:07:48,240
most recent architecture i'll take you

00:07:47,039 --> 00:07:50,080
through later actually had some really

00:07:48,240 --> 00:07:51,759
cool capability called prefixing

00:07:50,080 --> 00:07:53,599
so that's really opening up the op code

00:07:51,759 --> 00:07:54,879
space for the future giving even more

00:07:53,599 --> 00:07:56,000
flexibility

00:07:54,879 --> 00:07:58,000
the other thing you see there in the

00:07:56,000 --> 00:08:00,160
table on the left side is the

00:07:58,000 --> 00:08:02,160
number of instructions that were added

00:08:00,160 --> 00:08:03,759
over time and the nice thing about the

00:08:02,160 --> 00:08:04,879
compliancy sets we'll talk in a few

00:08:03,759 --> 00:08:05,919
moments is that

00:08:04,879 --> 00:08:07,280
you don't have to do all the

00:08:05,919 --> 00:08:08,800
instructions there's a lot of

00:08:07,280 --> 00:08:10,240
flexibility here so you can do

00:08:08,800 --> 00:08:11,440
everything from a fairly small set of

00:08:10,240 --> 00:08:13,280
instructions

00:08:11,440 --> 00:08:15,120
up to the full robust set of you know

00:08:13,280 --> 00:08:16,560
over 1400 instructions

00:08:15,120 --> 00:08:18,240
and capabilities that the power

00:08:16,560 --> 00:08:20,319
architecture allows so a great amount of

00:08:18,240 --> 00:08:23,360
flexibility provided

00:08:20,319 --> 00:08:25,039
here in this architecture so moving

00:08:23,360 --> 00:08:26,639
forward for those not familiar

00:08:25,039 --> 00:08:28,479
just a quick overview of how the

00:08:26,639 --> 00:08:30,080
architecture itself is organized when

00:08:28,479 --> 00:08:32,479
you're looking at those documents

00:08:30,080 --> 00:08:33,279
it's really organized into three books

00:08:32,479 --> 00:08:35,760
book one

00:08:33,279 --> 00:08:36,479
is the user instruction set architecture

00:08:35,760 --> 00:08:38,080
these are

00:08:36,479 --> 00:08:39,919
the architectures that are typically

00:08:38,080 --> 00:08:41,039
used in a compiled application

00:08:39,919 --> 00:08:43,440
environment

00:08:41,039 --> 00:08:44,480
and so you know the a typical program

00:08:43,440 --> 00:08:46,320
would be written

00:08:44,480 --> 00:08:48,800
exploiting the different load and store

00:08:46,320 --> 00:08:51,440
capabilities arithmetic computational

00:08:48,800 --> 00:08:52,959
capabilities and so forth and then you

00:08:51,440 --> 00:08:54,000
move on to book two and there you're

00:08:52,959 --> 00:08:55,440
dealing with you know

00:08:54,000 --> 00:08:57,200
specific interactions whether it's

00:08:55,440 --> 00:08:59,200
threat interactions or interacting with

00:08:57,200 --> 00:09:01,040
time or interacting with storage or

00:08:59,200 --> 00:09:02,160
persistent memories or other features of

00:09:01,040 --> 00:09:03,839
that nature

00:09:02,160 --> 00:09:05,519
a lot of these capabilities tend to be

00:09:03,839 --> 00:09:08,080
embedded in drivers

00:09:05,519 --> 00:09:09,920
or in specific libraries and sometimes

00:09:08,080 --> 00:09:12,399
often even in an assembly language

00:09:09,920 --> 00:09:13,680
but sometimes compiled so kind of moving

00:09:12,399 --> 00:09:15,760
through

00:09:13,680 --> 00:09:18,000
the books here the third book is really

00:09:15,760 --> 00:09:19,760
for the the controlling layers of

00:09:18,000 --> 00:09:20,880
software it's book three

00:09:19,760 --> 00:09:22,399
it's the operating environment

00:09:20,880 --> 00:09:24,560
architecture that defines how

00:09:22,399 --> 00:09:27,279
supervisors and hypervisors

00:09:24,560 --> 00:09:28,800
can address the architecture interrupts

00:09:27,279 --> 00:09:31,200
memory management

00:09:28,800 --> 00:09:33,519
other facilities of that debug and so

00:09:31,200 --> 00:09:34,959
forth are all defined in book three

00:09:33,519 --> 00:09:36,959
so that's how the power architecture is

00:09:34,959 --> 00:09:37,760
laid out now let's take a look at what

00:09:36,959 --> 00:09:40,800
compliancy

00:09:37,760 --> 00:09:42,959
is really all about so of course the

00:09:40,800 --> 00:09:45,279
purpose of compliancy is to make sure

00:09:42,959 --> 00:09:47,440
that contributions in the software

00:09:45,279 --> 00:09:49,440
ecosystem are very durable

00:09:47,440 --> 00:09:51,600
and that we have a nice architecture

00:09:49,440 --> 00:09:53,279
that doesn't get fragmented that really

00:09:51,600 --> 00:09:55,680
allows for compatibility

00:09:53,279 --> 00:09:57,279
and reuse and power has done very well

00:09:55,680 --> 00:09:58,880
at this historically and we want to make

00:09:57,279 --> 00:10:01,519
sure that that continues

00:09:58,880 --> 00:10:02,240
uh and and to do that we really had to

00:10:01,519 --> 00:10:04,320
you know do

00:10:02,240 --> 00:10:05,600
to define what what does it mean to be

00:10:04,320 --> 00:10:07,279
compliant

00:10:05,600 --> 00:10:09,440
the whole purpose of being compliant

00:10:07,279 --> 00:10:10,800
means that you have access to those

00:10:09,440 --> 00:10:12,959
royalty-free rights to use the

00:10:10,800 --> 00:10:14,880
architecture if you make a design that's

00:10:12,959 --> 00:10:16,320
not compliant you don't get those rights

00:10:14,880 --> 00:10:18,560
and so that's really cementing

00:10:16,320 --> 00:10:20,320
in for everyone's benefit that ability

00:10:18,560 --> 00:10:22,959
to have a durable architecture

00:10:20,320 --> 00:10:25,279
and the compliancy is defined by meeting

00:10:22,959 --> 00:10:27,600
one of the four compliancy subsets

00:10:25,279 --> 00:10:28,480
in addition being able to have a number

00:10:27,600 --> 00:10:31,440
of optional

00:10:28,480 --> 00:10:33,360
features and custom features as well so

00:10:31,440 --> 00:10:34,720
from a base compliancy perspective

00:10:33,360 --> 00:10:37,040
there's four sets

00:10:34,720 --> 00:10:38,560
the top one the most robust is aix

00:10:37,040 --> 00:10:40,320
compliancy set

00:10:38,560 --> 00:10:42,079
that allows you to run the ibm ax

00:10:40,320 --> 00:10:43,200
operating system then the linux

00:10:42,079 --> 00:10:45,200
compliancy set

00:10:43,200 --> 00:10:46,560
really geared towards running a linux

00:10:45,200 --> 00:10:48,320
server architecture

00:10:46,560 --> 00:10:49,839
so being able to fully run the same

00:10:48,320 --> 00:10:52,079
architecture for example that's running

00:10:49,839 --> 00:10:54,880
in the summit in sierra supercomputers

00:10:52,079 --> 00:10:56,880
or that ibm uses today to underpin its

00:10:54,880 --> 00:10:58,560
enterprise linux offerings

00:10:56,880 --> 00:11:00,399
and then we've got the scalar fixed and

00:10:58,560 --> 00:11:02,079
floating point subset as well as the

00:11:00,399 --> 00:11:03,920
scalar fixed point subset

00:11:02,079 --> 00:11:06,160
these are slimmer subsets of the

00:11:03,920 --> 00:11:06,959
architecture with many less instructions

00:11:06,160 --> 00:11:10,000
required

00:11:06,959 --> 00:11:12,240
that allow for making simpler designs

00:11:10,000 --> 00:11:14,320
or even advanced designs but without

00:11:12,240 --> 00:11:16,160
taking on all of those features needed

00:11:14,320 --> 00:11:17,279
to support those more server class

00:11:16,160 --> 00:11:18,959
architectures

00:11:17,279 --> 00:11:20,640
it doesn't mean you can't support linux

00:11:18,959 --> 00:11:21,839
there are versions of linux that can be

00:11:20,640 --> 00:11:23,279
compatible here

00:11:21,839 --> 00:11:26,880
just not the server class linux

00:11:23,279 --> 00:11:28,720
supported by the lcs subset

00:11:26,880 --> 00:11:31,200
and then of course in for all of these

00:11:28,720 --> 00:11:32,959
classes of compliance you have a number

00:11:31,200 --> 00:11:34,320
of optional features so the architecture

00:11:32,959 --> 00:11:36,800
contains a number of features that are

00:11:34,320 --> 00:11:38,480
always optional and can always be added

00:11:36,800 --> 00:11:40,480
an important point here is that when you

00:11:38,480 --> 00:11:42,160
add a feature it really has to be

00:11:40,480 --> 00:11:44,160
supported in its entirety so if a

00:11:42,160 --> 00:11:46,399
feature is made up of a set of registers

00:11:44,160 --> 00:11:48,000
and a set of instructions for example

00:11:46,399 --> 00:11:49,279
you can't pick and choose i want you

00:11:48,000 --> 00:11:50,720
know a couple of the registers and a

00:11:49,279 --> 00:11:52,079
couple of the instructions

00:11:50,720 --> 00:11:53,920
if you did that it would actually make a

00:11:52,079 --> 00:11:55,279
design non-compliant that's very

00:11:53,920 --> 00:11:56,639
important because as we're managing

00:11:55,279 --> 00:11:57,760
features features get managed in the

00:11:56,639 --> 00:11:59,279
ecosystem

00:11:57,760 --> 00:12:01,200
and if a feature is enabled it needs to

00:11:59,279 --> 00:12:02,399
be fully enabled and if it's not enabled

00:12:01,200 --> 00:12:04,160
then it needs to be

00:12:02,399 --> 00:12:07,680
not not there so that that really

00:12:04,160 --> 00:12:09,360
promotes binary compatibility

00:12:07,680 --> 00:12:10,160
in addition to these optional features

00:12:09,360 --> 00:12:11,120
that are already part of the

00:12:10,160 --> 00:12:12,800
architecture

00:12:11,120 --> 00:12:15,360
one of the recent changes we made was to

00:12:12,800 --> 00:12:17,200
define a set of custom extensions

00:12:15,360 --> 00:12:18,639
really an architecture sandbox and i'll

00:12:17,200 --> 00:12:20,720
go through that a bit later

00:12:18,639 --> 00:12:21,680
giving flexibility so that when you're

00:12:20,720 --> 00:12:23,760
making a design

00:12:21,680 --> 00:12:25,040
a proprietary design and you need to do

00:12:23,760 --> 00:12:26,959
some special things

00:12:25,040 --> 00:12:28,480
maybe talk to an accelerator that's very

00:12:26,959 --> 00:12:30,240
specific to your machine

00:12:28,480 --> 00:12:31,680
maybe adding some other hooks just to

00:12:30,240 --> 00:12:33,760
hold your glue glue your machine

00:12:31,680 --> 00:12:35,680
together the right way

00:12:33,760 --> 00:12:38,240
that's allowed right we've carved out

00:12:35,680 --> 00:12:41,279
some fairly robust set of architecture

00:12:38,240 --> 00:12:43,519
uh to be available for you to do that

00:12:41,279 --> 00:12:45,440
and then um you know the other thing

00:12:43,519 --> 00:12:47,600
that is allowed here is leveraging

00:12:45,440 --> 00:12:49,200
firmware in addition to hardware there

00:12:47,600 --> 00:12:50,560
are some rules on this there's a set of

00:12:49,200 --> 00:12:52,639
things that can't be

00:12:50,560 --> 00:12:54,480
you know done or emulated with firmware

00:12:52,639 --> 00:12:56,560
but in general it is allowed to use

00:12:54,480 --> 00:12:59,200
firmware plus hardware to accomplish

00:12:56,560 --> 00:13:00,480
architectural compatibility

00:12:59,200 --> 00:13:02,480
okay so that was a little bit of the

00:13:00,480 --> 00:13:04,000
basics about compliance now it's like

00:13:02,480 --> 00:13:05,279
take another you know look at this

00:13:04,000 --> 00:13:07,120
compliancy subset

00:13:05,279 --> 00:13:08,480
here's shown as a pyramid and at the top

00:13:07,120 --> 00:13:10,160
of the pyramid

00:13:08,480 --> 00:13:12,160
is really the the base it's the

00:13:10,160 --> 00:13:13,839
foundation it's the set the minimum set

00:13:12,160 --> 00:13:15,680
that you need to be compliant

00:13:13,839 --> 00:13:17,200
which which actually is that scalar

00:13:15,680 --> 00:13:17,600
fixed point subset the scalar fixed

00:13:17,200 --> 00:13:19,360
point

00:13:17,600 --> 00:13:21,360
subset ultimately makes up the

00:13:19,360 --> 00:13:22,880
foundational layer of the architecture

00:13:21,360 --> 00:13:24,959
from a compliancy perspective and

00:13:22,880 --> 00:13:26,880
there's 129 instructions

00:13:24,959 --> 00:13:28,560
supported to get there and then if you

00:13:26,880 --> 00:13:30,240
look at the bottom of the pyramid

00:13:28,560 --> 00:13:32,320
that's the foundation of the entire

00:13:30,240 --> 00:13:33,120
architecture so that's all the features

00:13:32,320 --> 00:13:35,120
including all the

00:13:33,120 --> 00:13:37,680
optional features and you can see that

00:13:35,120 --> 00:13:39,839
that's 1419 instructions

00:13:37,680 --> 00:13:41,199
and this is referencing the 3.1 isa for

00:13:39,839 --> 00:13:42,240
the instruction counts

00:13:41,199 --> 00:13:43,680
and then you've got of course the

00:13:42,240 --> 00:13:45,199
options in between that we just talked

00:13:43,680 --> 00:13:45,600
to talked through right and you can see

00:13:45,199 --> 00:13:47,440
that

00:13:45,600 --> 00:13:49,600
moving down from the scalar fixed point

00:13:47,440 --> 00:13:51,600
adding the floating point capability

00:13:49,600 --> 00:13:53,040
you know adds another you know 90 some

00:13:51,600 --> 00:13:55,279
odd instructions and then the linux

00:13:53,040 --> 00:13:57,199
subset adds many hundreds more

00:13:55,279 --> 00:13:59,279
instructions and other capabilities and

00:13:57,199 --> 00:14:00,800
then the aix you know rounding out with

00:13:59,279 --> 00:14:02,240
with with yet another

00:14:00,800 --> 00:14:04,480
set of instructions capabilities

00:14:02,240 --> 00:14:06,240
required and so you can actually choose

00:14:04,480 --> 00:14:08,800
to be compliant at any of these

00:14:06,240 --> 00:14:10,720
tiers and let's say that i chose to be

00:14:08,800 --> 00:14:12,320
compliant with the scalar fixed and

00:14:10,720 --> 00:14:13,199
floating point subset they're shown in

00:14:12,320 --> 00:14:15,920
yellow

00:14:13,199 --> 00:14:16,639
i could always choose other optional

00:14:15,920 --> 00:14:18,480
features

00:14:16,639 --> 00:14:19,680
that were added in at lower levels of

00:14:18,480 --> 00:14:21,120
the pyramid in other words

00:14:19,680 --> 00:14:23,519
as long as i grab it and feature in its

00:14:21,120 --> 00:14:24,800
entirety i can implement and be

00:14:23,519 --> 00:14:28,320
compliant

00:14:24,800 --> 00:14:30,720
with that sffs subset and then pull in

00:14:28,320 --> 00:14:32,320
additional features from below

00:14:30,720 --> 00:14:34,000
i don't have to pull in an entire

00:14:32,320 --> 00:14:37,040
compliancy subset but i do have to pull

00:14:34,000 --> 00:14:38,959
in features in their entirety

00:14:37,040 --> 00:14:40,320
so that's a lot of flexibility right you

00:14:38,959 --> 00:14:41,760
have the flexibility to have only a

00:14:40,320 --> 00:14:42,800
couple hundred instructions all the way

00:14:41,760 --> 00:14:44,880
up to you know

00:14:42,800 --> 00:14:46,160
over a thousand instructions it's

00:14:44,880 --> 00:14:47,839
important to understand what these are

00:14:46,160 --> 00:14:49,440
all about and of course the architecture

00:14:47,839 --> 00:14:50,720
itself is the best reference

00:14:49,440 --> 00:14:52,480
but i'll try to take you through a

00:14:50,720 --> 00:14:54,079
little bit of it just to give a good

00:14:52,480 --> 00:14:56,000
idea of what's really happening at each

00:14:54,079 --> 00:14:57,680
of these layers of compliancy

00:14:56,000 --> 00:14:59,760
so this is the pyramid inverted that

00:14:57,680 --> 00:15:00,160
we're showing here so at the bottom of

00:14:59,760 --> 00:15:01,680
the

00:15:00,160 --> 00:15:03,040
of the pier now at the what used to be

00:15:01,680 --> 00:15:04,720
the top of the pyramid shown here at the

00:15:03,040 --> 00:15:06,160
bottom and that's the foundation of the

00:15:04,720 --> 00:15:08,639
architecture as i mentioned

00:15:06,160 --> 00:15:10,000
that's the scalar fixed point subset 129

00:15:08,639 --> 00:15:13,519
instructions a lot of fixed

00:15:10,000 --> 00:15:15,519
float or no float fixed point alu

00:15:13,519 --> 00:15:16,800
loads and stores then we're moving up

00:15:15,519 --> 00:15:19,199
and picking up the floating point

00:15:16,800 --> 00:15:21,279
instructions there in the next box

00:15:19,199 --> 00:15:22,800
in the fixed and float subset and then

00:15:21,279 --> 00:15:24,320
we move up from there when we get to the

00:15:22,800 --> 00:15:26,959
linux server subset

00:15:24,320 --> 00:15:28,320
we've now got cmd including both flavors

00:15:26,959 --> 00:15:32,959
of sim d

00:15:28,320 --> 00:15:34,320
vmx and vsx 64 128 bit registers come

00:15:32,959 --> 00:15:36,560
along for the ride with that

00:15:34,320 --> 00:15:38,480
along with requirement to support 64-bit

00:15:36,560 --> 00:15:41,759
mode little indian mode

00:15:38,480 --> 00:15:43,839
logical partitions as well as a handful

00:15:41,759 --> 00:15:46,160
of ops that weren't required lower sets

00:15:43,839 --> 00:15:47,199
involving the overflow bit in the xcr

00:15:46,160 --> 00:15:48,959
register

00:15:47,199 --> 00:15:51,680
and then the full nested radix

00:15:48,959 --> 00:15:53,519
translation so that allows for you know

00:15:51,680 --> 00:15:55,759
again that robust server

00:15:53,519 --> 00:15:57,440
architecture that enterprise class

00:15:55,759 --> 00:15:59,759
architecture of linux

00:15:57,440 --> 00:16:01,440
and then moving up one aix picks up a

00:15:59,759 --> 00:16:02,399
number of other capabilities that are

00:16:01,440 --> 00:16:04,399
required

00:16:02,399 --> 00:16:05,519
um you know relating to interrupts

00:16:04,399 --> 00:16:07,519
relating to

00:16:05,519 --> 00:16:09,199
certain operations like atomic memory

00:16:07,519 --> 00:16:11,680
ops also

00:16:09,199 --> 00:16:13,360
supporting big endian mode okay so

00:16:11,680 --> 00:16:15,040
supporting big indian in addition to

00:16:13,360 --> 00:16:16,480
supporting little endian

00:16:15,040 --> 00:16:18,560
number of other capabilities like the

00:16:16,480 --> 00:16:19,920
branch history buffer event based branch

00:16:18,560 --> 00:16:22,399
for debug

00:16:19,920 --> 00:16:24,800
compatibility register you know

00:16:22,399 --> 00:16:27,040
broadcast tlbie instructions which are

00:16:24,800 --> 00:16:28,240
which are critical for an smp multi-core

00:16:27,040 --> 00:16:29,759
environment

00:16:28,240 --> 00:16:31,839
control register a number of other

00:16:29,759 --> 00:16:33,759
floating point classes like quad

00:16:31,839 --> 00:16:35,040
precision and decimal float

00:16:33,759 --> 00:16:36,000
as well as some instructions that are

00:16:35,040 --> 00:16:37,199
actually deprecated from the

00:16:36,000 --> 00:16:38,959
architecture

00:16:37,199 --> 00:16:40,880
in the long run but required for aix

00:16:38,959 --> 00:16:44,399
which is the load store multiple

00:16:40,880 --> 00:16:45,839
and the load store string finally smt

00:16:44,399 --> 00:16:47,040
capabilities so simultaneous

00:16:45,839 --> 00:16:48,800
multi-threading so that's

00:16:47,040 --> 00:16:50,079
that's the set that's there needed there

00:16:48,800 --> 00:16:52,000
to get to aix

00:16:50,079 --> 00:16:54,079
and also kind of listing then what are

00:16:52,000 --> 00:16:55,759
ultimately optional features that can be

00:16:54,079 --> 00:16:57,199
picked up at lower levels so if you

00:16:55,759 --> 00:16:58,720
wanted to for example as i mentioned

00:16:57,199 --> 00:17:00,000
earlier implement the scalar fixed and

00:16:58,720 --> 00:17:01,920
floating point subset

00:17:00,000 --> 00:17:04,000
but you wanted to pick up support for

00:17:01,920 --> 00:17:04,319
big endian you can certainly do that you

00:17:04,000 --> 00:17:06,559
can

00:17:04,319 --> 00:17:07,760
pick up support for you know branch

00:17:06,559 --> 00:17:09,839
history buffer

00:17:07,760 --> 00:17:11,520
or events based branch any of those

00:17:09,839 --> 00:17:13,120
debug capabilities those are the that's

00:17:11,520 --> 00:17:14,079
the kind of flexibility you have here to

00:17:13,120 --> 00:17:17,199
pick and choose

00:17:14,079 --> 00:17:20,079
discrete features uh and then bring them

00:17:17,199 --> 00:17:21,679
in to complement your compliancy subset

00:17:20,079 --> 00:17:23,039
and then there's the always optional

00:17:21,679 --> 00:17:24,640
features and those are shown there in

00:17:23,039 --> 00:17:26,640
the white box at the top

00:17:24,640 --> 00:17:27,760
copy paste for accelerators secure

00:17:26,640 --> 00:17:29,280
memory facility

00:17:27,760 --> 00:17:31,120
data streaming prefetch you have to

00:17:29,280 --> 00:17:32,000
implement always the the control

00:17:31,120 --> 00:17:33,520
register

00:17:32,000 --> 00:17:35,840
but not the cape necessarily the

00:17:33,520 --> 00:17:38,640
capabilities

00:17:35,840 --> 00:17:39,440
non-coherent memory um with m equals

00:17:38,640 --> 00:17:42,240
zero

00:17:39,440 --> 00:17:42,880
uh right through memory required uh

00:17:42,240 --> 00:17:45,280
memory

00:17:42,880 --> 00:17:46,240
with w equals one um those are so called

00:17:45,280 --> 00:17:49,440
whim g bits

00:17:46,240 --> 00:17:50,240
and then power management capabilities

00:17:49,440 --> 00:17:52,000
as well

00:17:50,240 --> 00:17:53,520
and then matrix math assist which i'll

00:17:52,000 --> 00:17:55,840
talk a little bit later is a new set of

00:17:53,520 --> 00:17:56,960
capabilities introduced in the iso 3.1

00:17:55,840 --> 00:17:59,120
so those are always

00:17:56,960 --> 00:18:00,160
optional at any layer can pick those

00:17:59,120 --> 00:18:03,039
capabilities up

00:18:00,160 --> 00:18:04,880
you know one or the other so that really

00:18:03,039 --> 00:18:07,120
describes the set of you know basic

00:18:04,880 --> 00:18:08,640
compliancy layers and all those features

00:18:07,120 --> 00:18:09,919
that you have to pick and choose from

00:18:08,640 --> 00:18:12,799
and how they've been

00:18:09,919 --> 00:18:15,280
kind of modularized here and then you've

00:18:12,799 --> 00:18:17,039
got a set of sandbox capabilities

00:18:15,280 --> 00:18:18,960
so here we're really looking at the fact

00:18:17,039 --> 00:18:19,840
that you know in the architecture

00:18:18,960 --> 00:18:21,840
sandbox

00:18:19,840 --> 00:18:23,440
you've got customization that's allowed

00:18:21,840 --> 00:18:25,120
and that customization that i mentioned

00:18:23,440 --> 00:18:26,480
earlier is it can be very important when

00:18:25,120 --> 00:18:27,919
you're building a proprietary machine

00:18:26,480 --> 00:18:29,679
you want to have some capability that

00:18:27,919 --> 00:18:31,039
you're building in your soc

00:18:29,679 --> 00:18:32,880
or into your system maybe you need a

00:18:31,039 --> 00:18:36,080
unique interrupt vector that's there

00:18:32,880 --> 00:18:37,280
unique opcode is available for you sprs

00:18:36,080 --> 00:18:39,280
and then some of the key control

00:18:37,280 --> 00:18:40,720
registers each have bits defined whether

00:18:39,280 --> 00:18:42,160
it's the fixed point or floating point

00:18:40,720 --> 00:18:44,640
control registers

00:18:42,160 --> 00:18:46,559
those all capabilities are all reserved

00:18:44,640 --> 00:18:49,039
for this architectural sandbox this one

00:18:46,559 --> 00:18:51,280
off sandbox

00:18:49,039 --> 00:18:52,640
so while that's all very important um

00:18:51,280 --> 00:18:54,240
you know these custom extensions give

00:18:52,640 --> 00:18:55,919
you a lot of this flexibility and we

00:18:54,240 --> 00:18:57,600
want that right we want that flexibility

00:18:55,919 --> 00:18:58,400
if you see any limitations you don't see

00:18:57,600 --> 00:18:59,600
that there's enough

00:18:58,400 --> 00:19:01,600
this is the perfect kind of thing to

00:18:59,600 --> 00:19:03,440
bring to the working group but it's also

00:19:01,600 --> 00:19:05,600
very important that we don't put in the

00:19:03,440 --> 00:19:06,799
long run things into custom extensions

00:19:05,600 --> 00:19:08,320
that really want to be part of the

00:19:06,799 --> 00:19:09,360
broader architecture so if something

00:19:08,320 --> 00:19:10,400
really belongs in the broader

00:19:09,360 --> 00:19:12,480
architecture

00:19:10,400 --> 00:19:14,000
the path forward is for developers to

00:19:12,480 --> 00:19:16,240
are encouraged to bring those forward

00:19:14,000 --> 00:19:17,679
and submit a proposal for adoption

00:19:16,240 --> 00:19:18,880
and then the adopted proposals will

00:19:17,679 --> 00:19:20,000
become part of the the broader

00:19:18,880 --> 00:19:21,679
architecture you don't really want to

00:19:20,000 --> 00:19:23,679
tie up those proprietary extensions with

00:19:21,679 --> 00:19:25,919
something that has broad applicability

00:19:23,679 --> 00:19:27,360
and that's really for everyone's benefit

00:19:25,919 --> 00:19:28,960
you want to put it in let it become part

00:19:27,360 --> 00:19:32,160
of the base architecture let it become a

00:19:28,960 --> 00:19:34,000
part of the broader ecosystem of support

00:19:32,160 --> 00:19:35,440
at the same time you know if you do

00:19:34,000 --> 00:19:37,200
things that are in that custom

00:19:35,440 --> 00:19:39,440
part that you're not going to get in

00:19:37,200 --> 00:19:41,120
general as much tool chain support

00:19:39,440 --> 00:19:42,559
because you know there's not as much

00:19:41,120 --> 00:19:43,760
focus from the broader community there

00:19:42,559 --> 00:19:44,880
they're really things that will have to

00:19:43,760 --> 00:19:48,080
be supported by you

00:19:44,880 --> 00:19:49,360
since they're custom and then quickly i

00:19:48,080 --> 00:19:52,000
wanted to highlight some of those

00:19:49,360 --> 00:19:53,600
capabilities of the 3.1 architecture

00:19:52,000 --> 00:19:55,039
for those that were in a previous

00:19:53,600 --> 00:19:56,080
discussion around power 10 you might

00:19:55,039 --> 00:19:57,600
have seen some of these

00:19:56,080 --> 00:19:59,280
so i won't go into much detail but

00:19:57,600 --> 00:20:00,240
really a host of new instructions

00:19:59,280 --> 00:20:03,360
rounding up

00:20:00,240 --> 00:20:05,919
you know more of this md versus scalar

00:20:03,360 --> 00:20:07,919
symmetry plus adding new capabilities

00:20:05,919 --> 00:20:11,039
there for 128 bit binary

00:20:07,919 --> 00:20:12,799
and a number of other new new hooks and

00:20:11,039 --> 00:20:15,039
capabilities as well

00:20:12,799 --> 00:20:16,080
especially around cmd where we've added

00:20:15,039 --> 00:20:18,320
32 byte

00:20:16,080 --> 00:20:20,320
loads in stores loading into and storing

00:20:18,320 --> 00:20:22,559
from pairs of vsx registers

00:20:20,320 --> 00:20:24,080
bit manipulation and a host of other

00:20:22,559 --> 00:20:26,799
capabilities here

00:20:24,080 --> 00:20:27,520
you know in in the architecture and then

00:20:26,799 --> 00:20:29,360
as well

00:20:27,520 --> 00:20:30,720
new translation management extensions

00:20:29,360 --> 00:20:33,919
copy paste

00:20:30,720 --> 00:20:35,840
and i'll highlight at the bottom there

00:20:33,919 --> 00:20:38,240
the instruction prefix support

00:20:35,840 --> 00:20:39,200
so i'll say a few few few more words

00:20:38,240 --> 00:20:40,960
about that

00:20:39,200 --> 00:20:42,720
instruction prefix is really about the

00:20:40,960 --> 00:20:44,400
future for the architecture it's about

00:20:42,720 --> 00:20:46,720
opening up the op code space

00:20:44,400 --> 00:20:48,400
but in a very risk-friendly way so we

00:20:46,720 --> 00:20:49,760
did it so that you're really moving from

00:20:48,400 --> 00:20:51,520
a four byte instruction you're also

00:20:49,760 --> 00:20:53,200
allowing for eight byte instructions

00:20:51,520 --> 00:20:55,760
but always with up primary app code

00:20:53,200 --> 00:20:57,520
equals one for that first four bytes

00:20:55,760 --> 00:20:59,440
and then a very limited set of of

00:20:57,520 --> 00:21:00,799
capabilities uh defined presently in the

00:20:59,440 --> 00:21:02,640
3.1 architecture

00:21:00,799 --> 00:21:05,600
those come in two flavors either

00:21:02,640 --> 00:21:08,240
modifying or eight byte architecture

00:21:05,600 --> 00:21:09,919
the modifying form allows you to take an

00:21:08,240 --> 00:21:11,520
existing instruction of the suffix and

00:21:09,919 --> 00:21:13,120
modify its capability and the best

00:21:11,520 --> 00:21:16,159
example there is we add

00:21:13,120 --> 00:21:16,799
added pc relative addressing for loads

00:21:16,159 --> 00:21:18,320
and stores

00:21:16,799 --> 00:21:20,240
into the 3.1 architecture so you can

00:21:18,320 --> 00:21:22,159
take existing load and store instruction

00:21:20,240 --> 00:21:24,000
by putting a prefix in front you have a

00:21:22,159 --> 00:21:26,400
long 34-bit displacement

00:21:24,000 --> 00:21:28,000
and you can be pc relative the other

00:21:26,400 --> 00:21:30,000
flavor is eight byte op codes

00:21:28,000 --> 00:21:32,400
and so this means a whole new rich op

00:21:30,000 --> 00:21:34,720
code space for growth in the future

00:21:32,400 --> 00:21:35,919
and and capabilities moving forward and

00:21:34,720 --> 00:21:38,159
so this allows for

00:21:35,919 --> 00:21:40,960
you know as we look at uh you know the

00:21:38,159 --> 00:21:43,600
needs and demands of of new capabilities

00:21:40,960 --> 00:21:45,520
uh like whether it's masking or whether

00:21:43,600 --> 00:21:46,480
it's a predication or other capabilities

00:21:45,520 --> 00:21:48,240
of this nature

00:21:46,480 --> 00:21:50,240
the prefix provides a great foundation

00:21:48,240 --> 00:21:52,640
for doing that in fact for the optional

00:21:50,240 --> 00:21:54,880
mma facility which is matrix multiply

00:21:52,640 --> 00:21:56,880
which is the matrix multiply accumulate

00:21:54,880 --> 00:21:58,960
instructions that are in there

00:21:56,880 --> 00:21:59,919
those actually allow for lane masking in

00:21:58,960 --> 00:22:01,840
the prefix

00:21:59,919 --> 00:22:04,080
so the prefix itself can spend i can

00:22:01,840 --> 00:22:06,159
specify the masking to give you an idea

00:22:04,080 --> 00:22:08,080
and to give you a little more idea this

00:22:06,159 --> 00:22:10,240
op code space here is shown

00:22:08,080 --> 00:22:11,760
tons of space open for the future so

00:22:10,240 --> 00:22:13,520
kind of focus on the bottom there

00:22:11,760 --> 00:22:15,840
this is the opcode space that's defined

00:22:13,520 --> 00:22:16,640
in the prefix entire ranges of bits

00:22:15,840 --> 00:22:18,640
available

00:22:16,640 --> 00:22:19,840
lots of growth lots of flexibility for

00:22:18,640 --> 00:22:21,440
the long run and really

00:22:19,840 --> 00:22:23,760
making you know giving us that leg for

00:22:21,440 --> 00:22:25,360
the durable long duration of this power

00:22:23,760 --> 00:22:27,760
architecture and the flexibility we need

00:22:25,360 --> 00:22:29,600
to tackle future challenges

00:22:27,760 --> 00:22:32,159
so that's really what i had to present

00:22:29,600 --> 00:22:34,320
today i hope you found it informative

00:22:32,159 --> 00:22:35,760
i'll take a glance at the q a see if

00:22:34,320 --> 00:22:37,600
anything has come in

00:22:35,760 --> 00:22:41,840
and if not i thank you very much for

00:22:37,600 --> 00:22:41,840
listening today

00:22:45,280 --> 00:22:48,559
i think we're also at right about at the

00:22:47,520 --> 00:22:52,320
time

00:22:48,559 --> 00:22:55,600
um any anyone have any questions

00:22:52,320 --> 00:22:57,039
please feel free to follow up on slack

00:22:55,600 --> 00:23:00,559
in the slack channel

00:22:57,039 --> 00:23:00,559

YouTube URL: https://www.youtube.com/watch?v=ZGvEpd4vNK0


