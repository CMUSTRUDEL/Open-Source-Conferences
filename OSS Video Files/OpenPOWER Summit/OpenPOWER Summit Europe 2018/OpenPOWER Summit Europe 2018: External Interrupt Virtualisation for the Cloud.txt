Title: OpenPOWER Summit Europe 2018: External Interrupt Virtualisation for the Cloud
Publication date: 2019-02-07
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Florian Auernhammer, IBM, speaks at OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,030 --> 00:00:05,100
so my name is Florian our number I'm a

00:00:03,000 --> 00:00:08,189
research staff member in the IBM

00:00:05,100 --> 00:00:10,380
Research Latin in Zurich and I'm gonna

00:00:08,189 --> 00:00:11,969
give an overview of the new XIV

00:00:10,380 --> 00:00:15,570
architecture that we introduced for the

00:00:11,969 --> 00:00:19,470
power 9 processor so XIV is our new

00:00:15,570 --> 00:00:22,320
interrupt virtualization architecture so

00:00:19,470 --> 00:00:24,920
as a background as everyone almost has

00:00:22,320 --> 00:00:27,660
already pointed out in their talks

00:00:24,920 --> 00:00:29,689
basically the the ease of use for open

00:00:27,660 --> 00:00:32,579
Cappy and so on is also because you're

00:00:29,689 --> 00:00:35,579
able to use it directly out of your user

00:00:32,579 --> 00:00:40,920
space and over time we really have

00:00:35,579 --> 00:00:43,170
introduced iommu or adopted the memory

00:00:40,920 --> 00:00:45,239
virtualization all pieces of our

00:00:43,170 --> 00:00:47,610
microprocessor so we have introduced

00:00:45,239 --> 00:00:50,610
first the PCI Express IO and amused and

00:00:47,610 --> 00:00:53,190
we had nest mm use for our network

00:00:50,610 --> 00:00:56,070
interface and the torrent chip that was

00:00:53,190 --> 00:00:58,350
used for power 7 and then power AIDS or

00:00:56,070 --> 00:01:01,859
the coherent attached accelerator

00:00:58,350 --> 00:01:04,129
interfaces with cap and that made it

00:01:01,859 --> 00:01:07,170
easy to really move data from devices

00:01:04,129 --> 00:01:10,409
into our space into user space I mean

00:01:07,170 --> 00:01:11,670
wherever you want it and this is also

00:01:10,409 --> 00:01:13,970
critical because you want to have the

00:01:11,670 --> 00:01:17,040
isolation that it provides for

00:01:13,970 --> 00:01:18,479
enterprise consolidated enterprise data

00:01:17,040 --> 00:01:19,920
centers as well as the cloud

00:01:18,479 --> 00:01:21,540
infrastructure so that you can run

00:01:19,920 --> 00:01:24,150
multiple virtual machines they are

00:01:21,540 --> 00:01:26,880
isolated from each other and you don't

00:01:24,150 --> 00:01:30,329
have to worry about data getting into

00:01:26,880 --> 00:01:33,030
the wrong places and so on the problem

00:01:30,329 --> 00:01:34,829
with it that is that most data that

00:01:33,030 --> 00:01:36,689
you're moving in the system also at some

00:01:34,829 --> 00:01:39,600
point needs to have a notification

00:01:36,689 --> 00:01:41,610
because you want to tell the receiver of

00:01:39,600 --> 00:01:43,380
the data that hey there are some new

00:01:41,610 --> 00:01:45,930
data that you have to process which is

00:01:43,380 --> 00:01:47,579
true both for i/o data that is coming

00:01:45,930 --> 00:01:49,619
and barony to process a network packet

00:01:47,579 --> 00:01:52,890
but it's also true for IP eyes or some

00:01:49,619 --> 00:01:54,750
other process or posted somewhere some

00:01:52,890 --> 00:01:56,729
work that needs to be done and then he

00:01:54,750 --> 00:01:58,200
wants to do an IP I inter notify the

00:01:56,729 --> 00:02:02,969
other processor that you know has to

00:01:58,200 --> 00:02:05,460
work on it but so far the the interrupt

00:02:02,969 --> 00:02:07,380
subsystem that was the only piece in the

00:02:05,460 --> 00:02:09,509
microprocessor that basically did not

00:02:07,380 --> 00:02:11,489
have any virtualization support so

00:02:09,509 --> 00:02:13,770
everything basically went through the

00:02:11,489 --> 00:02:16,920
hypervisor in the power architect

00:02:13,770 --> 00:02:19,410
sure we were using what we call the

00:02:16,920 --> 00:02:22,020
power V to interrupt architecture so it

00:02:19,410 --> 00:02:24,660
was introduced with power five back then

00:02:22,020 --> 00:02:29,220
we had a maximum system size of 256

00:02:24,660 --> 00:02:32,430
threats so coming to power 8 we had six

00:02:29,220 --> 00:02:34,950
times more threats and basically at this

00:02:32,430 --> 00:02:37,650
time we really had full adoption of i/o

00:02:34,950 --> 00:02:40,230
virtualization and this led to the fact

00:02:37,650 --> 00:02:43,830
that we really ran into the capacity

00:02:40,230 --> 00:02:46,140
limit of the v-2 architecture for power

00:02:43,830 --> 00:02:48,750
9 there was then the desire to also have

00:02:46,140 --> 00:02:51,120
the on chip accelerators like the annex

00:02:48,750 --> 00:02:54,960
unit that we provide and introduced on

00:02:51,120 --> 00:02:57,810
power 8 plus s or even power 7 plus and

00:02:54,960 --> 00:03:00,960
as well as open cap e adapters being

00:02:57,810 --> 00:03:05,520
able to use a lot of additional

00:03:00,960 --> 00:03:07,560
interrupt resources at the same time in

00:03:05,520 --> 00:03:10,800
the interpreter architecture because it

00:03:07,560 --> 00:03:13,320
was already a bit dated there is two

00:03:10,800 --> 00:03:15,870
restrictions I would say which is that

00:03:13,320 --> 00:03:17,790
on the one hand from an from hardware

00:03:15,870 --> 00:03:21,090
perspective if you create an interrupt

00:03:17,790 --> 00:03:22,890
request you actually need to represent

00:03:21,090 --> 00:03:25,920
the interrupt if it cannot be presented

00:03:22,890 --> 00:03:27,660
to a core right away basically if all

00:03:25,920 --> 00:03:29,610
the cores in the system are already

00:03:27,660 --> 00:03:31,140
working for an interrupt or if they are

00:03:29,610 --> 00:03:33,240
running at higher for it is it that you

00:03:31,140 --> 00:03:35,250
cannot deliver the interrupt it was up

00:03:33,240 --> 00:03:38,700
to the source to represent the interrupt

00:03:35,250 --> 00:03:41,910
so that it could got it accepted and

00:03:38,700 --> 00:03:45,030
being processed so that added complexity

00:03:41,910 --> 00:03:46,470
to the individual interrupt sources also

00:03:45,030 --> 00:03:47,910
all the interrupts were delivered

00:03:46,470 --> 00:03:51,000
through the hypervisor and the

00:03:47,910 --> 00:03:53,340
hypervisor was then also doing reroute a

00:03:51,000 --> 00:03:55,320
if required so if the hypervisor

00:03:53,340 --> 00:03:56,790
determined it's better to serve that

00:03:55,320 --> 00:03:58,260
interrupt somewhere else or it needs to

00:03:56,790 --> 00:04:00,450
be served somewhere else it was up to

00:03:58,260 --> 00:04:02,430
the hypervisor to reroute it which has

00:04:00,450 --> 00:04:04,560
the advantage that you can utilize the

00:04:02,430 --> 00:04:07,110
interrupt so you can hand virtualized

00:04:04,560 --> 00:04:10,080
interrupt information to the operating

00:04:07,110 --> 00:04:12,560
system but at the same time it of course

00:04:10,080 --> 00:04:15,090
at significant overhead because you have

00:04:12,560 --> 00:04:17,130
at the context switches to branch into

00:04:15,090 --> 00:04:22,470
the hypervisor and then back into the

00:04:17,130 --> 00:04:24,060
operating system so the the number of

00:04:22,470 --> 00:04:26,820
sources we could have extended rather

00:04:24,060 --> 00:04:27,720
easily just increasing the source IDs

00:04:26,820 --> 00:04:30,330
and so on

00:04:27,720 --> 00:04:35,390
throughout our system but really as we

00:04:30,330 --> 00:04:39,270
saw the trend towards full and basically

00:04:35,390 --> 00:04:40,620
in I mean virtualization been being

00:04:39,270 --> 00:04:42,890
adopted in all parts of the

00:04:40,620 --> 00:04:46,500
microprocessor especially also in our

00:04:42,890 --> 00:04:50,310
accelerators we thought that the v2

00:04:46,500 --> 00:04:53,310
architecture is not adequate to support

00:04:50,310 --> 00:04:55,590
all of that and your longer so we

00:04:53,310 --> 00:04:57,600
introduced an entirely new external

00:04:55,590 --> 00:04:59,220
direct architecture which is called the

00:04:57,600 --> 00:05:02,760
external interrupt water cessation

00:04:59,220 --> 00:05:05,970
engine architecture XIV and the main

00:05:02,760 --> 00:05:07,620
characteristics are really addressing

00:05:05,970 --> 00:05:11,010
the issues that I just presented so we

00:05:07,620 --> 00:05:13,100
wanted to have the support for a very

00:05:11,010 --> 00:05:16,190
large number of interrupt sources and

00:05:13,100 --> 00:05:19,620
very simply attach of those sources so

00:05:16,190 --> 00:05:22,050
the requester of of an interrupt he

00:05:19,620 --> 00:05:24,150
shouldn't have to care about candy and

00:05:22,050 --> 00:05:25,710
to currently be presented or whatever he

00:05:24,150 --> 00:05:28,440
should just make the interrupt request

00:05:25,710 --> 00:05:31,430
and being done with it at the same time

00:05:28,440 --> 00:05:34,320
we really wanted to to enable the

00:05:31,430 --> 00:05:36,360
interrupt delivery to the full whittles

00:05:34,320 --> 00:05:38,280
to all the virtualization layers so that

00:05:36,360 --> 00:05:40,940
you could really send the interrupts

00:05:38,280 --> 00:05:43,440
directly to an OS or even to a user and

00:05:40,940 --> 00:05:45,390
avoid all those context switches that

00:05:43,440 --> 00:05:46,410
were associated before with branching

00:05:45,390 --> 00:05:49,800
into the hypervisor

00:05:46,410 --> 00:05:52,200
which actually implies that you have to

00:05:49,800 --> 00:05:54,180
root your interrupt correctly because if

00:05:52,200 --> 00:05:58,700
you want to avoid the context switch and

00:05:54,180 --> 00:06:00,810
you don't route it correctly there

00:05:58,700 --> 00:06:04,169
you're sending it potentially to the

00:06:00,810 --> 00:06:06,120
wrong target so some key concepts that

00:06:04,169 --> 00:06:08,880
we introduced for the XIV architecture

00:06:06,120 --> 00:06:10,590
were that on the one hand we introduced

00:06:08,880 --> 00:06:12,840
multiple levels of coalescing so you

00:06:10,590 --> 00:06:15,120
have configuration freedoms so that you

00:06:12,840 --> 00:06:17,430
can call us in a lot of places the

00:06:15,120 --> 00:06:21,690
interrupt presentation so that you can

00:06:17,430 --> 00:06:24,540
optimize really the available processing

00:06:21,690 --> 00:06:26,220
resources and that you minimize the

00:06:24,540 --> 00:06:29,490
context switches that you need for

00:06:26,220 --> 00:06:31,230
serving the interrupts we lock the

00:06:29,490 --> 00:06:33,540
interrupts on event queues which is a

00:06:31,230 --> 00:06:37,380
very proven content and basically all I

00:06:33,540 --> 00:06:39,930
over tool is ation and this basically

00:06:37,380 --> 00:06:42,000
allows us to have really

00:06:39,930 --> 00:06:45,090
large amount of interrupts sources the

00:06:42,000 --> 00:06:47,040
target a single server so basically with

00:06:45,090 --> 00:06:49,530
this architecture we can handle more

00:06:47,040 --> 00:06:53,970
interrupts than on an entire p8 system

00:06:49,530 --> 00:06:55,620
by a single server and priority we can

00:06:53,970 --> 00:06:59,130
enable the virtualization down to the

00:06:55,620 --> 00:07:02,880
user level because the queuing concept

00:06:59,130 --> 00:07:05,310
basically is proven proven and has been

00:07:02,880 --> 00:07:08,580
the enabler to really do full by over

00:07:05,310 --> 00:07:10,560
Toulouse ation and actually it also

00:07:08,580 --> 00:07:13,110
removes then you need to retry

00:07:10,560 --> 00:07:16,050
interrupts for the sources because we

00:07:13,110 --> 00:07:18,510
can always lock interrupt information on

00:07:16,050 --> 00:07:21,030
to the event queues and basically then

00:07:18,510 --> 00:07:24,780
process it when a process processing

00:07:21,030 --> 00:07:28,440
occurs resource becomes available a key

00:07:24,780 --> 00:07:30,419
concept for that is for the inter

00:07:28,440 --> 00:07:32,729
delivery to the different virtualization

00:07:30,419 --> 00:07:35,220
layers is that we are now routing the

00:07:32,729 --> 00:07:37,080
interrupts to virtual processors or

00:07:35,220 --> 00:07:40,590
group of virtual processors and no

00:07:37,080 --> 00:07:47,940
longer to specific logical course or

00:07:40,590 --> 00:07:49,740
physical course and yeah actual and

00:07:47,940 --> 00:07:51,990
therefore by routing to virtual

00:07:49,740 --> 00:07:54,419
processors we take into account the

00:07:51,990 --> 00:07:56,220
actual scheduling state in the system so

00:07:54,419 --> 00:07:59,310
if a virtual processor is currently not

00:07:56,220 --> 00:08:01,380
running we are not presenting the

00:07:59,310 --> 00:08:03,120
interrupts but if a virtual processor is

00:08:01,380 --> 00:08:04,590
changing its location in the system

00:08:03,120 --> 00:08:07,080
because it's scheduled on a different

00:08:04,590 --> 00:08:10,050
logical core we will basically follow

00:08:07,080 --> 00:08:12,300
with the inter presentation just by

00:08:10,050 --> 00:08:17,430
targeting always diverted process or and

00:08:12,300 --> 00:08:20,130
not a physical a physical core we memory

00:08:17,430 --> 00:08:23,460
that the hardware software interface as

00:08:20,130 --> 00:08:26,570
a MMO use into the MMO space and that

00:08:23,460 --> 00:08:30,870
allows actually to have a flexible

00:08:26,570 --> 00:08:32,820
implementation if you have pending

00:08:30,870 --> 00:08:35,580
interrupts which means that there are

00:08:32,820 --> 00:08:37,529
event queues with interrupts locked on

00:08:35,580 --> 00:08:39,539
it that haven't been processed and we

00:08:37,529 --> 00:08:41,789
can't find a processor to serve them

00:08:39,539 --> 00:08:43,979
right now we have a backlog structure to

00:08:41,789 --> 00:08:45,860
remember later on that we still have to

00:08:43,979 --> 00:08:48,660
process a certain event queues and

00:08:45,860 --> 00:08:52,160
actually what we introduced also is that

00:08:48,660 --> 00:08:53,610
there is no possibility to create

00:08:52,160 --> 00:08:55,350
escalation interrupts

00:08:53,610 --> 00:08:58,230
what we call it so if we don't find a

00:08:55,350 --> 00:09:01,350
server we basically have the option to

00:08:58,230 --> 00:09:04,320
let the hypervisor define if he wants to

00:09:01,350 --> 00:09:06,060
get an interrupt created that will tell

00:09:04,320 --> 00:09:07,440
the hypervisor that there was an

00:09:06,060 --> 00:09:10,200
interrupt that couldn't be delivered so

00:09:07,440 --> 00:09:13,250
that he can actually take care of

00:09:10,200 --> 00:09:15,990
scheduling the virtual process or that

00:09:13,250 --> 00:09:19,440
that wasn't found at the at the point

00:09:15,990 --> 00:09:22,890
that interpret a min so this is the

00:09:19,440 --> 00:09:24,870
high-level picture of the interrupt

00:09:22,890 --> 00:09:27,720
architecture and actually we divide it

00:09:24,870 --> 00:09:31,260
in into a virtualization layer and into

00:09:27,720 --> 00:09:33,630
a presentation layer so on the

00:09:31,260 --> 00:09:35,519
individual interrupt sources speed IPI

00:09:33,630 --> 00:09:39,360
interrupts graphics cards network

00:09:35,519 --> 00:09:41,220
adapters or your network they trigger

00:09:39,360 --> 00:09:43,200
their individual interrupt sources and

00:09:41,220 --> 00:09:45,839
in the source layer we acquire less the

00:09:43,200 --> 00:09:49,500
interrupts so that we only present one

00:09:45,839 --> 00:09:53,730
specific interrupt source at a time in

00:09:49,500 --> 00:09:55,649
the system then we route lookup routing

00:09:53,730 --> 00:09:58,529
information and we vert alized

00:09:55,649 --> 00:10:00,750
interrupt information so we replaced the

00:09:58,529 --> 00:10:02,190
physical source information by a virtual

00:10:00,750 --> 00:10:05,820
source information that we can give to

00:10:02,190 --> 00:10:09,360
the OS which can which we can then keep

00:10:05,820 --> 00:10:11,730
constant independent whether we do live

00:10:09,360 --> 00:10:13,620
migration or whatever the operating will

00:10:11,730 --> 00:10:15,720
always operating system will always see

00:10:13,620 --> 00:10:18,149
the exact same information for for the

00:10:15,720 --> 00:10:21,420
interrupt even if the physical source is

00:10:18,149 --> 00:10:22,800
completely different and using the

00:10:21,420 --> 00:10:25,680
routing information we go into the

00:10:22,800 --> 00:10:27,839
report layer the report layer locks the

00:10:25,680 --> 00:10:30,329
the interrupts on to M in event queue

00:10:27,839 --> 00:10:33,000
and then doesn't notification and the

00:10:30,329 --> 00:10:35,519
notification uses this brutal process so

00:10:33,000 --> 00:10:37,620
based interrupts routing so it really

00:10:35,519 --> 00:10:39,390
gives just the information I want to

00:10:37,620 --> 00:10:40,890
target that virtual processor or that

00:10:39,390 --> 00:10:44,310
group of virtual processors with the

00:10:40,890 --> 00:10:46,410
interrupts so that we are able to now

00:10:44,310 --> 00:10:48,570
route the interrupt we have in the

00:10:46,410 --> 00:10:51,269
presentation layer these threat

00:10:48,570 --> 00:10:54,269
interrupt management areas and there is

00:10:51,269 --> 00:10:58,350
one threat interrupt management area for

00:10:54,269 --> 00:11:00,720
logical core and in this area the

00:10:58,350 --> 00:11:02,970
software always keeps the hardware

00:11:00,720 --> 00:11:04,740
up-to-date with which virtual processor

00:11:02,970 --> 00:11:07,010
is currently running so if they change

00:11:04,740 --> 00:11:08,990
operating systems or if the this

00:11:07,010 --> 00:11:12,260
the hypervisor on the core they

00:11:08,990 --> 00:11:12,830
basically tell this through this tima to

00:11:12,260 --> 00:11:15,290
the hardware

00:11:12,830 --> 00:11:18,620
so therefore when we route an interrupt

00:11:15,290 --> 00:11:20,930
we get the the target information from

00:11:18,620 --> 00:11:23,030
the notification information and the

00:11:20,930 --> 00:11:25,130
routing layer and then we check can we

00:11:23,030 --> 00:11:27,020
deliver it and do we find the target or

00:11:25,130 --> 00:11:27,560
do we not find the target if we find the

00:11:27,020 --> 00:11:30,950
target

00:11:27,560 --> 00:11:33,350
we have registers here that will present

00:11:30,950 --> 00:11:36,200
the interrupt to the core and if we

00:11:33,350 --> 00:11:37,640
don't find the target we have the option

00:11:36,200 --> 00:11:39,680
to back lock the interrupt so we have a

00:11:37,640 --> 00:11:42,440
backlog structure so that later on when

00:11:39,680 --> 00:11:44,030
the VP is rescheduled we will bring it

00:11:42,440 --> 00:11:45,860
back the information that we lower that

00:11:44,030 --> 00:11:48,080
we couldn't present interrupts and

00:11:45,860 --> 00:11:51,470
present them later on and we have the

00:11:48,080 --> 00:11:56,330
option to escalate so to notify the next

00:11:51,470 --> 00:11:58,700
higher virtualization layer and the good

00:11:56,330 --> 00:12:00,740
thing about this new routing concept is

00:11:58,700 --> 00:12:03,050
that basically this side here

00:12:00,740 --> 00:12:05,060
once you have set up your interrupt

00:12:03,050 --> 00:12:07,570
sources and you have set up your virtual

00:12:05,060 --> 00:12:10,280
processors that you're running this and

00:12:07,570 --> 00:12:12,140
all of those structures involved in this

00:12:10,280 --> 00:12:13,400
process here or static they are not

00:12:12,140 --> 00:12:16,220
changing the only thing that is changing

00:12:13,400 --> 00:12:18,830
is the information about which virtual

00:12:16,220 --> 00:12:24,080
processors are currently running so

00:12:18,830 --> 00:12:26,360
there is really only the information in

00:12:24,080 --> 00:12:31,280
in the demos that needs to be changed to

00:12:26,360 --> 00:12:35,210
adapt the routing dynamically so for the

00:12:31,280 --> 00:12:40,840
virtual processors this is also commonly

00:12:35,210 --> 00:12:43,700
known as V CPUs we have a range of

00:12:40,840 --> 00:12:46,250
indexes that we can use and basically

00:12:43,700 --> 00:12:48,980
for the hypervisor so that he still has

00:12:46,250 --> 00:12:52,430
the capability to route interrupts based

00:12:48,980 --> 00:12:54,770
on their physical location we predefined

00:12:52,430 --> 00:12:57,830
a certain range what we call the heart

00:12:54,770 --> 00:13:00,470
range which is a small range of route or

00:12:57,830 --> 00:13:04,580
processes that are really tied to the

00:13:00,470 --> 00:13:06,440
specific logical core in the with its

00:13:04,580 --> 00:13:08,510
position and the system so on which chip

00:13:06,440 --> 00:13:11,990
is it running rich logical core on that

00:13:08,510 --> 00:13:14,360
ship and all of the rest of this range

00:13:11,990 --> 00:13:17,720
can then be freely distributed to vertol

00:13:14,360 --> 00:13:19,790
processors which can be attached to the

00:13:17,720 --> 00:13:20,630
hypervisor what we call the hypervisor

00:13:19,790 --> 00:13:23,240
pool or

00:13:20,630 --> 00:13:26,000
the operating system so you can kind of

00:13:23,240 --> 00:13:29,890
create additional routines for the

00:13:26,000 --> 00:13:32,870
hypervisor using these pools or you can

00:13:29,890 --> 00:13:34,910
for each virtual processor of an

00:13:32,870 --> 00:13:36,650
operating system you hand out a virtual

00:13:34,910 --> 00:13:40,220
processor there in one group and

00:13:36,650 --> 00:13:42,260
basically all the virtual processors in

00:13:40,220 --> 00:13:46,370
such a group would then be tied to the

00:13:42,260 --> 00:13:49,520
same virtual machine and then we can

00:13:46,370 --> 00:13:51,500
target either a specific word processor

00:13:49,520 --> 00:13:54,050
which is commonly done in the Linux case

00:13:51,500 --> 00:13:56,030
or typically there you and the routing

00:13:54,050 --> 00:13:58,280
is typically just routing interrupts to

00:13:56,030 --> 00:14:00,260
one dedicated verdure processor but you

00:13:58,280 --> 00:14:01,970
can also route interrupts to group of

00:14:00,260 --> 00:14:05,950
virtual processors you can so you can

00:14:01,970 --> 00:14:08,690
say for example here I don't care which

00:14:05,950 --> 00:14:10,310
physical threat and the system services

00:14:08,690 --> 00:14:12,380
the interrupts I just want to get one

00:14:10,310 --> 00:14:13,990
and then the hardware it will some load

00:14:12,380 --> 00:14:15,830
balancing and find the one that

00:14:13,990 --> 00:14:16,790
currently is running at the lowest

00:14:15,830 --> 00:14:19,190
priority and so on

00:14:16,790 --> 00:14:22,220
so this is really then allowing load

00:14:19,190 --> 00:14:27,880
balancing for interrupts that don't have

00:14:22,220 --> 00:14:30,860
strict affinity and yeah as I mentioned

00:14:27,880 --> 00:14:33,920
for one virtual machine the the virtual

00:14:30,860 --> 00:14:36,470
processors need to be consecutive and in

00:14:33,920 --> 00:14:39,080
a power of two range so that we can more

00:14:36,470 --> 00:14:41,060
easily do the grouping mechanism but

00:14:39,080 --> 00:14:42,950
basically the the number of virtual

00:14:41,060 --> 00:14:44,540
processors in such a range can use pairs

00:14:42,950 --> 00:14:46,130
you don't need to use all better

00:14:44,540 --> 00:14:47,990
processors you just need to make sure

00:14:46,130 --> 00:14:50,150
that all of those VPS and one range

00:14:47,990 --> 00:14:52,910
really belong to the same virtual

00:14:50,150 --> 00:14:54,710
machine and actually what you can also

00:14:52,910 --> 00:14:56,510
do is that your nest interrupt so for

00:14:54,710 --> 00:14:58,640
example on the hypervisor heart level

00:14:56,510 --> 00:15:01,790
you could say I have one group that

00:14:58,640 --> 00:15:04,360
targets any physical threat on one chip

00:15:01,790 --> 00:15:07,220
and then if I don't find anyone that can

00:15:04,360 --> 00:15:10,460
currently service my interrupt I can

00:15:07,220 --> 00:15:13,670
escalate and interrupt all the physical

00:15:10,460 --> 00:15:17,060
threats in the system so just to be able

00:15:13,670 --> 00:15:26,890
to more more quickly adapt to to

00:15:17,060 --> 00:15:26,890
scheduling it in addition to that ok

00:15:34,490 --> 00:15:39,410
we can we extend the mechanism to

00:15:37,580 --> 00:15:41,840
actually also be able to deliver

00:15:39,410 --> 00:15:43,430
interrupts to a user and a user can be

00:15:41,840 --> 00:15:45,530
scheduled by the operating system so

00:15:43,430 --> 00:15:47,390
it's up to the operating system where it

00:15:45,530 --> 00:15:51,440
wants to use a scheduler user process

00:15:47,390 --> 00:15:53,750
therefore when we target an interrupt at

00:15:51,440 --> 00:15:56,570
a user level typically what we do is we

00:15:53,750 --> 00:15:58,370
basically check across all the virtual

00:15:56,570 --> 00:16:00,620
processors belonging to the operating

00:15:58,370 --> 00:16:06,410
system is if we can find this specific

00:16:00,620 --> 00:16:08,450
user process currently running so now as

00:16:06,410 --> 00:16:10,490
this is the main hardware software

00:16:08,450 --> 00:16:12,920
interface I want to dive a bit deeper

00:16:10,490 --> 00:16:15,790
into the thread interrupt management

00:16:12,920 --> 00:16:18,740
area so this is really the main

00:16:15,790 --> 00:16:20,510
interface where the software tells the

00:16:18,740 --> 00:16:22,040
hardware what is currently running so

00:16:20,510 --> 00:16:24,170
that we can do the routine correctly and

00:16:22,040 --> 00:16:26,180
it's also the interface from the

00:16:24,170 --> 00:16:27,950
hardware to the software where the

00:16:26,180 --> 00:16:31,760
hardware can present the interrupts to

00:16:27,950 --> 00:16:35,150
the software so therefore we have for

00:16:31,760 --> 00:16:37,790
what words so one for user context one

00:16:35,150 --> 00:16:42,500
for OS and then one for hypervisor pool

00:16:37,790 --> 00:16:45,170
and hypervisor heart and these registers

00:16:42,500 --> 00:16:47,870
are mapped into three different pages

00:16:45,170 --> 00:16:50,000
and the MMO space so one page is used

00:16:47,870 --> 00:16:52,700
for mapping it into user space which

00:16:50,000 --> 00:16:55,040
really just contains the the first

00:16:52,700 --> 00:16:58,070
double word so that the user can accept

00:16:55,040 --> 00:17:01,280
an interrupt the next page is used for

00:16:58,070 --> 00:17:03,920
mapping the double word zero to two into

00:17:01,280 --> 00:17:06,530
the OS space so that the OS can handle

00:17:03,920 --> 00:17:09,320
OS interrupts and manage a user running

00:17:06,530 --> 00:17:11,660
and potentially put in a interrupt for

00:17:09,320 --> 00:17:12,560
the user and then the third page is used

00:17:11,660 --> 00:17:15,920
for the hypervisor

00:17:12,560 --> 00:17:20,530
and he has access to everything and to

00:17:15,920 --> 00:17:24,050
facilitate the the mechanism actually

00:17:20,530 --> 00:17:26,560
those three MMO pages are exactly the

00:17:24,050 --> 00:17:29,360
same in terms of real addresses

00:17:26,560 --> 00:17:32,260
independent of on which core you're

00:17:29,360 --> 00:17:36,650
making the exes so the hardware will map

00:17:32,260 --> 00:17:39,740
the access to the team are based on the

00:17:36,650 --> 00:17:42,170
location of the logical core that is

00:17:39,740 --> 00:17:45,380
doing the exes so if I have an operating

00:17:42,170 --> 00:17:47,930
system that is was running on one core

00:17:45,380 --> 00:17:48,409
here and was making was accepting and

00:17:47,930 --> 00:17:51,470
Inter

00:17:48,409 --> 00:17:54,470
if it's running now here it needs to

00:17:51,470 --> 00:17:57,230
target the exact same real address which

00:17:54,470 --> 00:17:59,870
means that we don't need to remap the

00:17:57,230 --> 00:18:01,360
pages that we gave out into OS your user

00:17:59,870 --> 00:18:04,820
space

00:18:01,360 --> 00:18:07,159
so this basically means that we don't

00:18:04,820 --> 00:18:08,990
have any overhead independent of where

00:18:07,159 --> 00:18:12,519
we are scheduled in the virtual process

00:18:08,990 --> 00:18:15,679
so we never have to remap the pages and

00:18:12,519 --> 00:18:17,179
actually it also simplifies or gives us

00:18:15,679 --> 00:18:20,360
the implementation options to either

00:18:17,179 --> 00:18:23,230
implement this team are within the core

00:18:20,360 --> 00:18:25,760
or also in a central unit on the chip

00:18:23,230 --> 00:18:29,210
because it's up to the hardware to

00:18:25,760 --> 00:18:30,919
really take in the take in the requests

00:18:29,210 --> 00:18:37,039
and just map it to the right team a

00:18:30,919 --> 00:18:42,010
location so for setting up the virtual

00:18:37,039 --> 00:18:44,419
processors basically we have here the

00:18:42,010 --> 00:18:47,539
audible words where we have valid bits

00:18:44,419 --> 00:18:50,149
which enable the routing for the

00:18:47,539 --> 00:18:51,649
different type of context so you can you

00:18:50,149 --> 00:18:53,570
have a valid bit here on the hypervisor

00:18:51,649 --> 00:18:55,700
heart level which doesn Able's the the

00:18:53,570 --> 00:18:57,830
heart virtual processor then you have

00:18:55,700 --> 00:19:00,710
little Vella bits on the OS and

00:18:57,830 --> 00:19:02,389
hypervisor pool level with a value where

00:19:00,710 --> 00:19:04,480
you can specify which little processor

00:19:02,389 --> 00:19:08,269
is currently running and then you have a

00:19:04,480 --> 00:19:10,250
valid bit with a user index that where

00:19:08,269 --> 00:19:15,919
you can specify which user is currently

00:19:10,250 --> 00:19:18,769
running under the OS and when context is

00:19:15,919 --> 00:19:20,960
scheduled you basically put first put in

00:19:18,769 --> 00:19:23,320
the even W word information which

00:19:20,960 --> 00:19:26,120
contains the state the scheduling state

00:19:23,320 --> 00:19:29,210
from the last time it was running and

00:19:26,120 --> 00:19:30,950
then you enable develop it which means

00:19:29,210 --> 00:19:32,389
that at this point you're now accepting

00:19:30,950 --> 00:19:35,059
new interrupts and when you're

00:19:32,389 --> 00:19:37,610
unschedule a context you're doing it in

00:19:35,059 --> 00:19:39,559
the inverse ways wait so you've first

00:19:37,610 --> 00:19:42,049
disabled develop it so that you're not

00:19:39,559 --> 00:19:44,419
no longer accepting interrupts and then

00:19:42,049 --> 00:19:48,289
you're reading the even double word to

00:19:44,419 --> 00:19:50,000
take out the current state of the

00:19:48,289 --> 00:19:51,830
interrupts of which at which priority

00:19:50,000 --> 00:19:54,860
it's running and so on so that you can

00:19:51,830 --> 00:19:58,580
then put it later in again when you

00:19:54,860 --> 00:20:01,010
reschedule so like this you don't lose

00:19:58,580 --> 00:20:01,670
any scheduling state and its really the

00:20:01,010 --> 00:20:04,340
pre

00:20:01,670 --> 00:20:10,160
is really seamless from the operating

00:20:04,340 --> 00:20:11,750
system perspective now when we receive

00:20:10,160 --> 00:20:14,360
an interrupt request basically in

00:20:11,750 --> 00:20:17,300
Hardware check if a valid bit is on and

00:20:14,360 --> 00:20:20,240
then we compare the virtual processor

00:20:17,300 --> 00:20:22,070
information with the interrupt request

00:20:20,240 --> 00:20:25,160
that comes in and for the user level

00:20:22,070 --> 00:20:26,690
actually we are comparing the operating

00:20:25,160 --> 00:20:29,690
system virtual processor information

00:20:26,690 --> 00:20:31,580
plus the user information if both match

00:20:29,690 --> 00:20:35,360
so that we can determine if we're really

00:20:31,580 --> 00:20:39,650
having a match for that OS for that user

00:20:35,360 --> 00:20:41,810
thread within the operating system so

00:20:39,650 --> 00:20:45,680
now the presentation of the interrupts

00:20:41,810 --> 00:20:47,540
in the XIV architecture is similar to

00:20:45,680 --> 00:20:50,870
what we had in the previous architecture

00:20:47,540 --> 00:20:54,710
so we have a set of registers that the

00:20:50,870 --> 00:20:56,270
software reads and we can present the

00:20:54,710 --> 00:20:57,980
interrupts on on the three levels

00:20:56,270 --> 00:20:59,780
basically the hypervisor which is

00:20:57,980 --> 00:21:02,840
merging interrupts that are pending for

00:20:59,780 --> 00:21:04,970
the pool or for the heart we have OS

00:21:02,840 --> 00:21:07,070
level interrupts and then we can target

00:21:04,970 --> 00:21:09,440
user level in terms using the event

00:21:07,070 --> 00:21:11,300
based branch facility and the power

00:21:09,440 --> 00:21:13,760
processor so that really allows us to

00:21:11,300 --> 00:21:18,590
make a branch into a user level

00:21:13,760 --> 00:21:21,920
interrupt routine and an impending and

00:21:18,590 --> 00:21:23,990
appending interrupts really means in

00:21:21,920 --> 00:21:27,410
this case that there is a valid element

00:21:23,990 --> 00:21:28,940
on an event queue so therefore when we

00:21:27,410 --> 00:21:31,670
have an interrupt and the interpret is

00:21:28,940 --> 00:21:34,160
accepted the software will go to an

00:21:31,670 --> 00:21:35,990
event you read an element from there to

00:21:34,160 --> 00:21:38,630
understand which source triggered an

00:21:35,990 --> 00:21:40,640
interrupt and therefore there is

00:21:38,630 --> 00:21:43,220
information that the hardware provides

00:21:40,640 --> 00:21:46,910
to the software to doing that so we have

00:21:43,220 --> 00:21:50,420
here our main interrupt state bits which

00:21:46,910 --> 00:21:52,910
are the NS our CPP are in P I PR so CPP

00:21:50,420 --> 00:21:54,770
R that's what we already had before

00:21:52,910 --> 00:21:58,550
that's the current processor priority

00:21:54,770 --> 00:22:00,620
the P I PR is also known from before

00:21:58,550 --> 00:22:02,240
that's the pending interrupt priority

00:22:00,620 --> 00:22:05,300
and now in addition we have the NS r

00:22:02,240 --> 00:22:08,330
which basically tells us on which level

00:22:05,300 --> 00:22:10,010
is the the interrupts or is it a VP

00:22:08,330 --> 00:22:12,590
directed interrupt or is it a group

00:22:10,010 --> 00:22:14,750
directed interrupt and at which level is

00:22:12,590 --> 00:22:15,710
the group so if I have multiple group

00:22:14,750 --> 00:22:19,190
sizes it also

00:22:15,710 --> 00:22:21,320
indicates to which kind of group it was

00:22:19,190 --> 00:22:23,630
the intercourse end so that the software

00:22:21,320 --> 00:22:29,299
can determine from that which event

00:22:23,630 --> 00:22:31,789
queue does it have to go to so from a

00:22:29,299 --> 00:22:34,820
kheema perspective when we get an

00:22:31,789 --> 00:22:36,409
interrupt and we determined by the the

00:22:34,820 --> 00:22:38,809
virtual processor information that we

00:22:36,409 --> 00:22:40,429
have an interrupt that is targeting the

00:22:38,809 --> 00:22:42,620
one specific context

00:22:40,429 --> 00:22:44,539
we're basically checking the priority of

00:22:42,620 --> 00:22:47,899
the new interrupt against the priority

00:22:44,539 --> 00:22:49,460
of the currently pending interrupt so if

00:22:47,899 --> 00:22:50,419
there is a pending interrupt otherwise

00:22:49,460 --> 00:22:53,570
the paprs

00:22:50,419 --> 00:22:54,919
equivalent to the cpr and if we

00:22:53,570 --> 00:22:56,409
determine that the new interrupt has

00:22:54,919 --> 00:22:59,809
higher priorities then we basically

00:22:56,409 --> 00:23:03,200
accept the new interrupt we update the

00:22:59,809 --> 00:23:05,029
NSR information and we update the TI PR

00:23:03,200 --> 00:23:08,299
information to reflect the the

00:23:05,029 --> 00:23:09,860
enterprise-e of the new interrupt it

00:23:08,299 --> 00:23:13,059
could happen that there is already a

00:23:09,860 --> 00:23:16,669
inter pending and in that case we then

00:23:13,059 --> 00:23:18,620
send the or backlog the information that

00:23:16,669 --> 00:23:21,620
there was currently an inter pending and

00:23:18,620 --> 00:23:24,140
the the priority at which that was if

00:23:21,620 --> 00:23:25,520
you have a hit but the new entropy does

00:23:24,140 --> 00:23:27,529
not have higher priority than the

00:23:25,520 --> 00:23:29,419
current interrupt then we directly

00:23:27,529 --> 00:23:32,899
return the information that this

00:23:29,419 --> 00:23:35,059
interrupt has to be backlogged from a

00:23:32,899 --> 00:23:36,919
software perspective so once we have

00:23:35,059 --> 00:23:38,929
accepted an interrupt there's a wire

00:23:36,919 --> 00:23:41,899
basically to the core that goes up and

00:23:38,929 --> 00:23:44,419
it will trigger the core to branch into

00:23:41,899 --> 00:23:47,120
the interrupt handler routine and then

00:23:44,419 --> 00:23:52,100
the software will come back and read the

00:23:47,120 --> 00:23:54,620
NSR plus the CPP our registers so the NS

00:23:52,100 --> 00:23:56,480
are as a set for determining which is it

00:23:54,620 --> 00:23:59,090
a VP based interrupt or is it a group

00:23:56,480 --> 00:24:01,370
interrupt and actually for the CPP R

00:23:59,090 --> 00:24:04,340
when we receive such a load operation we

00:24:01,370 --> 00:24:07,340
atomically move the p IP R value into

00:24:04,340 --> 00:24:09,649
the CPP R which means that we are

00:24:07,340 --> 00:24:11,419
increasing the prior priority the core

00:24:09,649 --> 00:24:13,309
is running at and to return that

00:24:11,419 --> 00:24:15,230
information which means this is the new

00:24:13,309 --> 00:24:17,710
information the new priority that the

00:24:15,230 --> 00:24:19,880
core is running at and the prior

00:24:17,710 --> 00:24:23,480
inter-party literature it was actually

00:24:19,880 --> 00:24:25,700
the same the inverse but it didn't it

00:24:23,480 --> 00:24:27,080
wasn't necessary to do it and like this

00:24:25,700 --> 00:24:28,490
we can just provide all the information

00:24:27,080 --> 00:24:31,640
that you need in one

00:24:28,490 --> 00:24:33,740
operation and then the handler will

00:24:31,640 --> 00:24:35,750
process a process the interrupt and once

00:24:33,740 --> 00:24:38,330
it's done it basically comes back and

00:24:35,750 --> 00:24:41,240
signal into done operation just by

00:24:38,330 --> 00:24:45,679
resetting the CPR to the old value and

00:24:41,240 --> 00:24:47,960
then the the interrupt logic and get in

00:24:45,679 --> 00:24:50,120
new interrupts at higher priorities and

00:24:47,960 --> 00:24:55,370
also process the year the interrupts

00:24:50,120 --> 00:25:00,520
that is sent to the backlog so really

00:24:55,370 --> 00:25:03,890
relating back to the initial layered

00:25:00,520 --> 00:25:06,080
structure of the the architecture so we

00:25:03,890 --> 00:25:08,780
have main three main memory structures

00:25:06,080 --> 00:25:11,240
for delivering entrÃ³ interrupts which

00:25:08,780 --> 00:25:13,340
are called the event state buffer the

00:25:11,240 --> 00:25:16,309
event assignment structure and the event

00:25:13,340 --> 00:25:18,980
notification descriptor so on a per

00:25:16,309 --> 00:25:20,540
source basis we have a state buffer

00:25:18,980 --> 00:25:22,550
which is a two bit state machine that

00:25:20,540 --> 00:25:24,679
corliss is interrupt just for that

00:25:22,550 --> 00:25:27,500
specific source and we have an event

00:25:24,679 --> 00:25:29,809
assignment structure which takes the

00:25:27,500 --> 00:25:31,160
which translates the the physical source

00:25:29,809 --> 00:25:33,559
information into virtual source

00:25:31,160 --> 00:25:36,350
information and points to an event

00:25:33,559 --> 00:25:38,330
notification descriptor and the event

00:25:36,350 --> 00:25:40,340
notification descriptor and that one is

00:25:38,330 --> 00:25:42,920
really containing the information about

00:25:40,340 --> 00:25:44,570
where is the event key in memory where I

00:25:42,920 --> 00:25:46,450
need to lock the information about the

00:25:44,570 --> 00:25:49,010
interrupts so it's you're gonna write

00:25:46,450 --> 00:25:51,140
the virtualized interrupt source

00:25:49,010 --> 00:25:53,780
information from the EAS onto the event

00:25:51,140 --> 00:25:56,360
queue we do a notification and try to

00:25:53,780 --> 00:26:00,580
find the virtual processor running in a

00:25:56,360 --> 00:26:02,150
in a team or somewhere when we find the

00:26:00,580 --> 00:26:04,580
potential target

00:26:02,150 --> 00:26:07,340
we erase the interrupts wire to the core

00:26:04,580 --> 00:26:09,320
and basically that involves the

00:26:07,340 --> 00:26:10,940
interrupt handler the interrupt handler

00:26:09,320 --> 00:26:13,390
does the interrupt acknowledge to get

00:26:10,940 --> 00:26:17,230
the information about the the interrupts

00:26:13,390 --> 00:26:20,510
handles the interrupt and does an UI an

00:26:17,230 --> 00:26:22,970
event of interoperation to the state

00:26:20,510 --> 00:26:25,820
buffer to rearm the inter presentation

00:26:22,970 --> 00:26:27,620
for that source and there's a done

00:26:25,820 --> 00:26:29,000
operation to the key mode to re-enable

00:26:27,620 --> 00:26:31,990
the presentation of lower priority

00:26:29,000 --> 00:26:34,760
interrupt so that's the basic

00:26:31,990 --> 00:26:37,700
presentation flow if we find the source

00:26:34,760 --> 00:26:39,650
and everything is nice so what can

00:26:37,700 --> 00:26:41,720
happen is we don't find the source so

00:26:39,650 --> 00:26:42,380
then we have a fourth structure here

00:26:41,720 --> 00:26:44,690
which is

00:26:42,380 --> 00:26:48,020
notification virtual target structure

00:26:44,690 --> 00:26:50,120
which has backlog information so they

00:26:48,020 --> 00:26:53,120
are we then lock the information that we

00:26:50,120 --> 00:26:55,309
couldn't deliver a specific interim

00:26:53,120 --> 00:26:58,010
priority so there is actually one

00:26:55,309 --> 00:27:01,789
structure of that for each virtual

00:26:58,010 --> 00:27:03,799
processor in the system and then it is

00:27:01,789 --> 00:27:05,900
configurable if we want to escalate and

00:27:03,799 --> 00:27:07,669
that one has also a state buffer

00:27:05,900 --> 00:27:10,700
associated with it so that we just

00:27:07,669 --> 00:27:13,190
escalate once even if you get multiple

00:27:10,700 --> 00:27:15,260
interrupts that have multiple misses in

00:27:13,190 --> 00:27:17,539
the system and then this is just a

00:27:15,260 --> 00:27:23,120
pointer to another India on another

00:27:17,539 --> 00:27:25,250
level as I already said when the when

00:27:23,120 --> 00:27:28,370
context is scheduled we push the

00:27:25,250 --> 00:27:31,250
information into the tema we first put

00:27:28,370 --> 00:27:34,909
in we re-enable the escalation so this

00:27:31,250 --> 00:27:36,679
state machine here that coalesce is the

00:27:34,909 --> 00:27:38,929
escalation is reset so that we have a

00:27:36,679 --> 00:27:41,530
seamless transition when we unscheduled

00:27:38,929 --> 00:27:44,419
so that when we run schedule basically

00:27:41,530 --> 00:27:47,870
immediately have the escalation path

00:27:44,419 --> 00:27:49,460
enabled so there's a seamless take over

00:27:47,870 --> 00:27:53,539
between scheduling and on scheduling

00:27:49,460 --> 00:27:56,090
phase and actually then the hardware

00:27:53,539 --> 00:27:58,250
pulls pending interrupts out of the

00:27:56,090 --> 00:28:00,110
backlog structure so this is done in

00:27:58,250 --> 00:28:01,549
hardware so if there was an interrupt in

00:28:00,110 --> 00:28:02,900
the meantime that came in and that was

00:28:01,549 --> 00:28:05,720
backlog we're pulling that information

00:28:02,900 --> 00:28:08,690
out of the NV key wants the virtual

00:28:05,720 --> 00:28:10,610
process we scheduled for group

00:28:08,690 --> 00:28:12,830
interrupts as we're presenting them one

00:28:10,610 --> 00:28:16,400
by one this is basically a constant

00:28:12,830 --> 00:28:18,530
mechanism so as long as there is an

00:28:16,400 --> 00:28:20,570
interrupt in the backlog so there we're

00:28:18,530 --> 00:28:22,669
really keeping count of how many group

00:28:20,570 --> 00:28:24,770
interrupts are still outstanding we're

00:28:22,669 --> 00:28:26,330
pulling them out of the backlog one by

00:28:24,770 --> 00:28:27,919
one because we have can have multiple

00:28:26,330 --> 00:28:29,510
threats that pull them out of the

00:28:27,919 --> 00:28:32,030
backlog so we can't really distribute

00:28:29,510 --> 00:28:36,260
them then to all the threats at the same

00:28:32,030 --> 00:28:37,760
time and on unschedule we basically pull

00:28:36,260 --> 00:28:41,480
out the information out of the team ax

00:28:37,760 --> 00:28:43,159
and there was a special case when as

00:28:41,480 --> 00:28:45,620
already mentioned an interrupt was

00:28:43,159 --> 00:28:47,120
pending and it needs to be reduced it

00:28:45,620 --> 00:28:48,110
needs to be pushed out and it's a group

00:28:47,120 --> 00:28:50,540
interrupt we actually do a

00:28:48,110 --> 00:28:53,090
redistribution which means that we try

00:28:50,540 --> 00:28:54,860
to right away find another server that

00:28:53,090 --> 00:28:55,879
can take it just because that server

00:28:54,860 --> 00:28:57,259
couldn't

00:28:55,879 --> 00:28:59,649
process it anymore it might be that

00:28:57,259 --> 00:29:03,469
there's another server available and

00:28:59,649 --> 00:29:06,319
this really then goes into this holistic

00:29:03,469 --> 00:29:08,179
interrupt delivery picture and basically

00:29:06,319 --> 00:29:11,149
we have the same flow on the user always

00:29:08,179 --> 00:29:13,849
and hypervisor level and the EAS that

00:29:11,149 --> 00:29:16,190
one has the routing information and

00:29:13,849 --> 00:29:20,359
really allows us to root any interrupt

00:29:16,190 --> 00:29:22,759
in the system to any level of of the

00:29:20,359 --> 00:29:27,889
virtualization layer and we can route

00:29:22,759 --> 00:29:29,959
any interrupt to any any target because

00:29:27,889 --> 00:29:33,379
the event state buffers they are mapped

00:29:29,959 --> 00:29:36,169
with one dedicated page into the the MM

00:29:33,379 --> 00:29:38,449
i/o space so we can't really have a

00:29:36,169 --> 00:29:41,719
fully virtualized acceptance of anyone

00:29:38,449 --> 00:29:44,199
using any interrupt source the Indies

00:29:41,719 --> 00:29:45,889
are fully configurable so there's no

00:29:44,199 --> 00:29:49,999
tying interrupt

00:29:45,889 --> 00:29:51,739
in these two to certain levels the user

00:29:49,999 --> 00:29:53,929
level actually does not have a backlog

00:29:51,739 --> 00:29:56,419
that's mainly for scalability because

00:29:53,929 --> 00:29:58,459
it's difficult to scale something on the

00:29:56,419 --> 00:30:01,399
user level where we don't know how many

00:29:58,459 --> 00:30:03,379
users does one or one virtual machine

00:30:01,399 --> 00:30:05,809
have goes another one so that's

00:30:03,379 --> 00:30:08,809
difficult in hardware but basically the

00:30:05,809 --> 00:30:10,940
escalation element serves the better the

00:30:08,809 --> 00:30:13,339
same purpose in this case and then you

00:30:10,940 --> 00:30:16,099
can also have different configurations

00:30:13,339 --> 00:30:19,549
here between the escalation of the OS to

00:30:16,099 --> 00:30:21,349
the hypervisor risk can say skip the

00:30:19,549 --> 00:30:24,069
escalation at all and we don't influence

00:30:21,349 --> 00:30:27,769
our scheduling on the hypervisor level

00:30:24,069 --> 00:30:29,899
you can escalate with an without a

00:30:27,769 --> 00:30:31,699
notification so basically just tell the

00:30:29,899 --> 00:30:33,469
hypervisor so that during the next

00:30:31,699 --> 00:30:37,309
scheduling face he takes into account

00:30:33,469 --> 00:30:39,679
that an OS missed an interrupt or does

00:30:37,309 --> 00:30:41,539
do the notification ed with a

00:30:39,679 --> 00:30:43,369
notification to the hypervisor so that

00:30:41,539 --> 00:30:45,709
he can take immediate action to

00:30:43,369 --> 00:30:51,319
reschedule an operating system that had

00:30:45,709 --> 00:30:52,879
miss so to summarize we have introduced

00:30:51,319 --> 00:30:54,679
the new external interrupt

00:30:52,879 --> 00:30:57,409
virtualization engine architecture for

00:30:54,679 --> 00:30:59,119
the powerline processor and that's the

00:30:57,409 --> 00:31:01,879
first implementation that we have there

00:30:59,119 --> 00:31:04,069
it's the first interrupt architecture in

00:31:01,879 --> 00:31:07,789
the industry that provides full

00:31:04,069 --> 00:31:09,370
virtualization support and thereby we

00:31:07,789 --> 00:31:11,260
eliminate

00:31:09,370 --> 00:31:13,240
of context switches that are associated

00:31:11,260 --> 00:31:16,080
with a typically interrupt delivery in

00:31:13,240 --> 00:31:19,390
the previous interrupted architectures

00:31:16,080 --> 00:31:21,450
we also minimize the overhead of the

00:31:19,390 --> 00:31:24,760
hardware software interaction and

00:31:21,450 --> 00:31:27,340
especially by also routing correctly in

00:31:24,760 --> 00:31:30,190
the first place so there is on the one

00:31:27,340 --> 00:31:32,530
hand little overhead in moving virtual

00:31:30,190 --> 00:31:34,600
processors but we also don't generate

00:31:32,530 --> 00:31:36,370
additional work because we had reroute

00:31:34,600 --> 00:31:39,820
at the interrupt wrongly in the first

00:31:36,370 --> 00:31:41,470
place and finally there's a high degree

00:31:39,820 --> 00:31:45,340
of configuration for you and that we

00:31:41,470 --> 00:31:47,140
provide to the hypervisor in terms of

00:31:45,340 --> 00:31:49,630
how he wants to routes interrupt how he

00:31:47,140 --> 00:31:54,210
wants to coalescing and how he wants to

00:31:49,630 --> 00:31:56,790
set up the escalation and with that I'm

00:31:54,210 --> 00:32:02,450
finishing my talk thank you

00:31:56,790 --> 00:32:02,450

YouTube URL: https://www.youtube.com/watch?v=s88beMQWkks


