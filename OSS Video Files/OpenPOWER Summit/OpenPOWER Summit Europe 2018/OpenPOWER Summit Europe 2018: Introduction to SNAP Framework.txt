Title: OpenPOWER Summit Europe 2018: Introduction to SNAP Framework
Publication date: 2019-02-07
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Bruno Mesmet, CAPI / OpenCAPI enablement, IBM Systems, speaks at OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,050 --> 00:00:07,770
okay good afternoon hope I will keep you

00:00:04,110 --> 00:00:09,870
awakened I know after lunch is always

00:00:07,770 --> 00:00:12,660
difficult Alex on the river Castle and

00:00:09,870 --> 00:00:15,360
Alex on castor on the French guys with

00:00:12,660 --> 00:00:17,100
the French accent and brewmeister we are

00:00:15,360 --> 00:00:19,460
working on all Cappy open kept in

00:00:17,100 --> 00:00:22,109
element we are going to speak about snap

00:00:19,460 --> 00:00:25,949
snap is a framework and open source

00:00:22,109 --> 00:00:31,140
framework we have the bÃ¶blingen team in

00:00:25,949 --> 00:00:32,550
IBM has designed and well this is all

00:00:31,140 --> 00:00:35,880
about it

00:00:32,550 --> 00:00:40,920
this is - do you have something usable

00:00:35,880 --> 00:00:43,530
by easily usable by anybody so you

00:00:40,920 --> 00:00:45,480
understood you have a rocket in hand you

00:00:43,530 --> 00:00:48,149
have fpga open KP you have everything in

00:00:45,480 --> 00:00:50,640
together but well there's no driver okay

00:00:48,149 --> 00:00:52,620
so we need to put a driver on that and

00:00:50,640 --> 00:00:56,699
this is normally the user the coder so

00:00:52,620 --> 00:01:00,920
we know that everybody is not VHDL or

00:00:56,699 --> 00:01:05,309
very very dog compatible this is

00:01:00,920 --> 00:01:09,210
hardened Hardware minded guys well very

00:01:05,309 --> 00:01:11,880
very specific world we want to we wanted

00:01:09,210 --> 00:01:16,490
to bring to build a tool which could be

00:01:11,880 --> 00:01:20,820
usable by I would say a basic C C++ guy

00:01:16,490 --> 00:01:24,869
okay so very often we hear about yes I

00:01:20,820 --> 00:01:27,750
know GPU but well okay so let's go and

00:01:24,869 --> 00:01:30,979
try to find the reasons why to try this

00:01:27,750 --> 00:01:35,310
they snap framework so three reasons

00:01:30,979 --> 00:01:39,150
this is open for everybody any CEO I was

00:01:35,310 --> 00:01:41,310
a software code or can use it you just

00:01:39,150 --> 00:01:44,790
need one hour or two to discover it to

00:01:41,310 --> 00:01:48,720
understand how it works and we have a

00:01:44,790 --> 00:01:52,259
partnership with the name bik's who

00:01:48,720 --> 00:01:56,040
allows you to Detroit that it's for a

00:01:52,259 --> 00:01:59,670
couple of cents per hour and you can

00:01:56,040 --> 00:02:02,340
just try discover even develop on their

00:01:59,670 --> 00:02:05,399
system without investing anything and

00:02:02,340 --> 00:02:07,740
one who get you are done you have

00:02:05,399 --> 00:02:12,150
something you can bring home and put on

00:02:07,740 --> 00:02:15,269
your on your server

00:02:12,150 --> 00:02:18,060
okay so just to remember to recall a bit

00:02:15,269 --> 00:02:21,090
what we can do or not with the CPU or

00:02:18,060 --> 00:02:24,690
GPU well hardware acceleration in

00:02:21,090 --> 00:02:27,930
general that's the the simplest thing

00:02:24,690 --> 00:02:30,360
GPU and f ej can do that so it's a

00:02:27,930 --> 00:02:33,329
question of offloading maybe

00:02:30,360 --> 00:02:36,930
accelerating but very often we are not

00:02:33,329 --> 00:02:39,780
speaking about offloading things GPU

00:02:36,930 --> 00:02:43,230
will accelerate things vgi can do it

00:02:39,780 --> 00:02:46,799
also the second thing is something that

00:02:43,230 --> 00:02:51,030
GPU cannot do being able to access the

00:02:46,799 --> 00:02:56,329
outside the real world the storage the

00:02:51,030 --> 00:02:59,549
network FPGA has the ability to access

00:02:56,329 --> 00:03:01,640
directly to the data where they are okay

00:02:59,549 --> 00:03:04,230
so in one way or the other

00:03:01,640 --> 00:03:06,959
compressing decompressing filtering

00:03:04,230 --> 00:03:10,409
anything we have seen that in the

00:03:06,959 --> 00:03:12,900
previous presentations okay so today we

00:03:10,409 --> 00:03:20,010
have three options one is the GPU which

00:03:12,900 --> 00:03:23,579
is a wind blower okay so it's well it's

00:03:20,010 --> 00:03:31,049
a thousands of tiny CPUs well that's

00:03:23,579 --> 00:03:34,200
great okay it's about 200 300 Watts all

00:03:31,049 --> 00:03:34,950
you have the very light options this is

00:03:34,200 --> 00:03:39,209
one option

00:03:34,950 --> 00:03:41,940
yeah I have no specific manufacturer or

00:03:39,209 --> 00:03:44,840
provider so this is the last nine eight

00:03:41,940 --> 00:03:44,840
seven leaf I'm right

00:03:45,540 --> 00:03:51,239
Fe jcots so if you have a look to disk

00:03:47,609 --> 00:03:54,419
on you have FPGA you don't have any CPU

00:03:51,239 --> 00:03:56,310
in it you have I would say an engine

00:03:54,419 --> 00:04:00,329
built for your application

00:03:56,310 --> 00:04:02,400
no I was a bottleneck trying to push and

00:04:00,329 --> 00:04:06,540
trucks instructions into the into these

00:04:02,400 --> 00:04:09,660
CPUs the other thing is you have

00:04:06,540 --> 00:04:13,190
multiple connectors which allows you to

00:04:09,660 --> 00:04:18,840
go directly where the data are okay so

00:04:13,190 --> 00:04:21,719
good thing FPGA is really fast but FPGA

00:04:18,840 --> 00:04:23,940
is real-time and this is I think a very

00:04:21,719 --> 00:04:26,040
very big difference as soon as you are

00:04:23,940 --> 00:04:27,570
getting the data from outside

00:04:26,040 --> 00:04:32,940
you can process them in real time and

00:04:27,570 --> 00:04:38,040
get obviously a real known time to to

00:04:32,940 --> 00:04:40,380
process them so very often the question

00:04:38,040 --> 00:04:43,470
is well okay that's great harbour

00:04:40,380 --> 00:04:45,600
accelerator but for which use what can I

00:04:43,470 --> 00:04:49,380
use them for so I just pick you some

00:04:45,600 --> 00:04:53,790
some nine examples we are working on

00:04:49,380 --> 00:04:56,550
these today I don't have the results yes

00:04:53,790 --> 00:04:58,230
because it's not development it's not

00:04:56,550 --> 00:05:02,400
finished but these are examples we are

00:04:58,230 --> 00:05:06,240
working on I just bring also I

00:05:02,400 --> 00:05:08,760
highlighted the the key factor of

00:05:06,240 --> 00:05:11,610
success so if you are for example or

00:05:08,760 --> 00:05:15,410
bottom low a bottom left a reg X

00:05:11,610 --> 00:05:15,410
matching you are able to have multiple

00:05:15,710 --> 00:05:22,620
say processing such processing engines

00:05:20,010 --> 00:05:28,530
in parallel you can even dedicate them

00:05:22,620 --> 00:05:33,150
to a specific area x string you can have

00:05:28,530 --> 00:05:35,370
well these FPGA will be good because you

00:05:33,150 --> 00:05:38,850
have real parallel computing abilities

00:05:35,370 --> 00:05:44,250
if you go on the right you will see that

00:05:38,850 --> 00:05:48,870
well fitting inserting a FPGA between

00:05:44,250 --> 00:05:50,790
the CPU and the near memory the arm you

00:05:48,870 --> 00:05:53,730
can do that because you have open

00:05:50,790 --> 00:05:58,080
capi which has a very very low latency

00:05:53,730 --> 00:06:04,320
okay don't image into the GPU there well

00:05:58,080 --> 00:06:06,750
so I try to find outside to do to

00:06:04,320 --> 00:06:10,380
highlight the the key factor of success

00:06:06,750 --> 00:06:14,220
of these ok other things

00:06:10,380 --> 00:06:18,000
these are inference things things we are

00:06:14,220 --> 00:06:21,210
working on so here on the top left you

00:06:18,000 --> 00:06:24,180
have FPGA has a very good thing Lola a

00:06:21,210 --> 00:06:28,740
low consumption meaning that you can put

00:06:24,180 --> 00:06:32,570
that in a very well in a in a camera and

00:06:28,740 --> 00:06:36,810
you don't have to do you have 200 watts

00:06:32,570 --> 00:06:38,910
to to power this FPGA you you have also

00:06:36,810 --> 00:06:40,919
well I will leave you all that these are

00:06:38,910 --> 00:06:44,009
examples we are working

00:06:40,919 --> 00:06:47,400
it's not all about paralleling a

00:06:44,009 --> 00:06:50,940
paralyzing computer it's also about ease

00:06:47,400 --> 00:06:53,699
of integration how much it will take do

00:06:50,940 --> 00:06:56,460
you have good results okay we will go

00:06:53,699 --> 00:06:58,470
deeper tomorrow on some of these

00:06:56,460 --> 00:07:01,560
examples why they are really interesting

00:06:58,470 --> 00:07:06,470
so just to summarize things deed these

00:07:01,560 --> 00:07:13,050
are the different as a use case that can

00:07:06,470 --> 00:07:16,650
be answered by FPGAs compression

00:07:13,050 --> 00:07:20,699
encryption or this are really good good

00:07:16,650 --> 00:07:24,330
examples okay so just to to clarify

00:07:20,699 --> 00:07:26,570
things let's imagine that you have two

00:07:24,330 --> 00:07:30,900
tables okay you want to take the common

00:07:26,570 --> 00:07:35,310
intersection of these two tables and one

00:07:30,900 --> 00:07:38,160
terabyte tables one is in the server

00:07:35,310 --> 00:07:41,430
memory and the other is in the somewhere

00:07:38,160 --> 00:07:44,669
okay in the storage on the disk think

00:07:41,430 --> 00:07:47,669
about how you do that in a CPU I was a

00:07:44,669 --> 00:07:51,270
classic way of doing things well that's

00:07:47,669 --> 00:07:53,310
good you are going to the application is

00:07:51,270 --> 00:07:56,130
going to call a function it's going to

00:07:53,310 --> 00:07:59,370
do this intersection the function will

00:07:56,130 --> 00:08:04,130
use the table one data okay there are

00:07:59,370 --> 00:08:08,010
very easy to access but if they need to

00:08:04,130 --> 00:08:10,740
use the table to data they need to

00:08:08,010 --> 00:08:14,370
upload one terabyte of data through the

00:08:10,740 --> 00:08:18,030
network interface to the hosts memory

00:08:14,370 --> 00:08:21,630
and then be able to do the work okay so

00:08:18,030 --> 00:08:25,919
well good so you are just taking one

00:08:21,630 --> 00:08:28,979
terabytes of data just to put the data

00:08:25,919 --> 00:08:32,490
and then you will extract few bytes or

00:08:28,979 --> 00:08:38,010
few kilobytes of data at the end so very

00:08:32,490 --> 00:08:40,860
often I hear about well FPGA is really

00:08:38,010 --> 00:08:44,490
good to upload but does it really

00:08:40,860 --> 00:08:47,010
accelerate thing so yes I know

00:08:44,490 --> 00:08:53,070
just consider where are the data if

00:08:47,010 --> 00:08:55,170
there are in the inner disk

00:08:53,070 --> 00:08:56,130
think about that it will take one two am

00:08:55,170 --> 00:08:58,709
i to load it

00:08:56,130 --> 00:09:02,399
oh it sorry it will take 20 seconds to

00:08:58,709 --> 00:09:05,850
load these data so accelerating your

00:09:02,399 --> 00:09:07,670
function between 50 microseconds or 100

00:09:05,850 --> 00:09:10,529
microseconds is it

00:09:07,670 --> 00:09:15,810
really where the problem is just think

00:09:10,529 --> 00:09:18,120
about that okay so we we have some

00:09:15,810 --> 00:09:18,750
solutions that's the classic PCI Express

00:09:18,120 --> 00:09:21,600
solution

00:09:18,750 --> 00:09:23,819
you bring a f ej card and that's great

00:09:21,600 --> 00:09:25,380
okay you put the function it in it you

00:09:23,819 --> 00:09:27,480
access directly to the network so you

00:09:25,380 --> 00:09:30,509
free all the network resource of the

00:09:27,480 --> 00:09:34,790
server so well you have solved the

00:09:30,509 --> 00:09:38,160
problem yes you've moved the problem

00:09:34,790 --> 00:09:42,300
that they take the table one is still in

00:09:38,160 --> 00:09:46,769
the server memory so you still have a

00:09:42,300 --> 00:09:49,800
driver who will copy the data in the

00:09:46,769 --> 00:09:53,069
driver area and then move the data to

00:09:49,800 --> 00:09:59,120
the function three copies of your data

00:09:53,069 --> 00:10:02,040
mmm that's great okay three copies FPGA

00:09:59,120 --> 00:10:08,750
is a slave so you need an application

00:10:02,040 --> 00:10:08,750
working on the CPU being moving things

00:10:09,079 --> 00:10:14,040
well you just move the problem you

00:10:11,850 --> 00:10:19,620
didn't serve the problem so here is

00:10:14,040 --> 00:10:22,260
where kepi is coming kepi is we have

00:10:19,620 --> 00:10:26,610
designed what we call the CA PP that's

00:10:22,260 --> 00:10:29,670
four for the p8 this is the driver which

00:10:26,610 --> 00:10:33,240
is not a hardware driver Cappy that's a

00:10:29,670 --> 00:10:36,569
proxy driver so we put the driver in the

00:10:33,240 --> 00:10:38,760
CP in the chip and this allows the

00:10:36,569 --> 00:10:44,069
function to directly access to the data

00:10:38,760 --> 00:10:46,500
he needs okay so now with Cappy open

00:10:44,069 --> 00:10:49,529
Cappy okay it shouldn't change a lot for

00:10:46,500 --> 00:10:51,420
that the function has access directly to

00:10:49,529 --> 00:10:55,920
the network and also dodge the drive

00:10:51,420 --> 00:10:58,470
directly to the Hosmer FPGA is master

00:10:55,920 --> 00:11:02,130
meaning that the application would just

00:10:58,470 --> 00:11:05,329
say hey here are the data now do your

00:11:02,130 --> 00:11:05,329
work I'm doing something else

00:11:07,610 --> 00:11:14,300
we have also we are able to have

00:11:11,580 --> 00:11:16,560
multiple functions in the FPGA and

00:11:14,300 --> 00:11:19,100
assign them to multiple threads

00:11:16,560 --> 00:11:24,060
applications

00:11:19,100 --> 00:11:26,580
well we added some some bonus with open

00:11:24,060 --> 00:11:29,190
Cappy you have much smaller latency high

00:11:26,580 --> 00:11:31,440
bandwidth and so on you know that we

00:11:29,190 --> 00:11:35,970
heard about it already

00:11:31,440 --> 00:11:39,240
during the last presentations ok so well

00:11:35,970 --> 00:11:43,470
with all that yes you have also the

00:11:39,240 --> 00:11:47,400
performance okay so forget the bother

00:11:43,470 --> 00:11:51,620
the p8 will copy 1.0 this was really to

00:11:47,400 --> 00:11:55,170
try things now we have kept 2.0

00:11:51,620 --> 00:11:57,600
accessing directly to the memory don't

00:11:55,170 --> 00:12:01,710
consider it's the CPU it's the accessing

00:11:57,600 --> 00:12:07,850
to the memory and we have also open kepi

00:12:01,710 --> 00:12:10,230
cards still on p9 which has a real good

00:12:07,850 --> 00:12:11,900
numbers followed for latency and for for

00:12:10,230 --> 00:12:16,620
bandwidth

00:12:11,900 --> 00:12:19,160
ok ok so just to summarize a bit a

00:12:16,620 --> 00:12:23,850
little bit what we did you have a server

00:12:19,160 --> 00:12:26,670
memory storage and network so what we

00:12:23,850 --> 00:12:28,670
did is ok let's consider that you are

00:12:26,670 --> 00:12:33,000
moving your function with your action

00:12:28,670 --> 00:12:36,660
somewhere outside in an FPGA how do we

00:12:33,000 --> 00:12:39,060
access it so we have used FPGA which is

00:12:36,660 --> 00:12:41,460
good to access the network or the

00:12:39,060 --> 00:12:46,560
storage or you can also consider having

00:12:41,460 --> 00:12:49,380
the storage on the on the card ok so the

00:12:46,560 --> 00:12:51,240
second thing is you add the kepi which

00:12:49,380 --> 00:12:55,920
gives you access directly to the server

00:12:51,240 --> 00:12:58,440
memory and to be able to to help you

00:12:55,920 --> 00:13:02,580
having everything transference we have

00:12:58,440 --> 00:13:05,790
developed the snap-snap is the framework

00:13:02,580 --> 00:13:09,260
you don't need to know if it's PCI

00:13:05,790 --> 00:13:11,310
Express kappawarmth kappa to open kepi

00:13:09,260 --> 00:13:13,410
everything will be transparent for you

00:13:11,310 --> 00:13:17,250
so you have some firm orders on my open

00:13:13,410 --> 00:13:19,260
some some some cap your PCI Express link

00:13:17,250 --> 00:13:22,350
that's not a problem for you

00:13:19,260 --> 00:13:25,820
everything is transparent for you and

00:13:22,350 --> 00:13:30,300
the last thing last but not least well

00:13:25,820 --> 00:13:33,990
to be able to desire to use this

00:13:30,300 --> 00:13:39,270
framework and killed it you can now do

00:13:33,990 --> 00:13:42,630
that with C C++ code we use the vivid

00:13:39,270 --> 00:13:44,670
HLS HLS stands for high level synthesis

00:13:42,630 --> 00:13:45,510
we use this one because this one is very

00:13:44,670 --> 00:13:50,340
very simple

00:13:45,510 --> 00:13:55,140
okay you have plenty of other HLS today

00:13:50,340 --> 00:13:58,230
cadence or mentor or other HLS tools

00:13:55,140 --> 00:14:02,850
which will converge OC to very log and

00:13:58,230 --> 00:14:06,180
their tail but this one is really the

00:14:02,850 --> 00:14:09,120
simplest meaning that a software guy can

00:14:06,180 --> 00:14:12,570
use it you just need to put a frequency

00:14:09,120 --> 00:14:14,220
a period a clock period and the FPGA you

00:14:12,570 --> 00:14:20,340
are targeting that's all you need to put

00:14:14,220 --> 00:14:24,180
in it okay so for different bricks if

00:14:20,340 --> 00:14:26,550
you miss one it will work what you will

00:14:24,180 --> 00:14:28,380
go into the I would say into low

00:14:26,550 --> 00:14:32,520
configuration old configuration

00:14:28,380 --> 00:14:34,560
configuration sorry if you don't have

00:14:32,520 --> 00:14:36,360
the Cappy well you will be able to have

00:14:34,560 --> 00:14:39,030
an FPGA working with your networking

00:14:36,360 --> 00:14:42,720
with network and coding with C but you

00:14:39,030 --> 00:14:45,630
will not have all this

00:14:42,720 --> 00:14:48,360
are they your FPGA will become slave and

00:14:45,630 --> 00:14:52,110
not anymore master if you miss the FPGA

00:14:48,360 --> 00:14:55,380
well what makes things okay so one brick

00:14:52,110 --> 00:15:07,160
missing you will it's it's not magic

00:14:55,380 --> 00:15:10,050
anymore right so this is a next charge

00:15:07,160 --> 00:15:13,170
hls is really something which will help

00:15:10,050 --> 00:15:15,630
you to write in C C++ but you can still

00:15:13,170 --> 00:15:18,080
use the framework using VHDL on very log

00:15:15,630 --> 00:15:18,080
correct

00:15:24,170 --> 00:15:31,830
okay so well that's where we are exactly

00:15:28,380 --> 00:15:34,380
so that's now say the the way you can

00:15:31,830 --> 00:15:36,570
use this is what Brian I explained you

00:15:34,380 --> 00:15:40,560
you can use very long very very tail

00:15:36,570 --> 00:15:48,269
very close to the iPad PSL but it's PS l

00:15:40,560 --> 00:15:50,279
or TL AG tlv1 so this is the way to to

00:15:48,269 --> 00:15:52,170
work so you are going to bit of hot

00:15:50,279 --> 00:15:55,110
software program on the on the left on

00:15:52,170 --> 00:15:56,910
the software side and you can put all

00:15:55,110 --> 00:16:00,480
the glue you need or the logic you need

00:15:56,910 --> 00:16:03,180
on the hardware side well it works

00:16:00,480 --> 00:16:07,709
perfectly it will be the the most maybe

00:16:03,180 --> 00:16:12,839
the most optimized way to do things but

00:16:07,709 --> 00:16:18,180
it may take month to do it okay we have

00:16:12,839 --> 00:16:21,630
worked to be able to simplify things we

00:16:18,180 --> 00:16:24,209
did the snap and snap has I would say

00:16:21,630 --> 00:16:29,070
true three great points one it's open

00:16:24,209 --> 00:16:32,820
source so meaning free hey I BM is able

00:16:29,070 --> 00:16:34,890
to provide three things yes

00:16:32,820 --> 00:16:38,209
the second thing is portable so you can

00:16:34,890 --> 00:16:43,079
go from capi one to open kappa 3.0

00:16:38,209 --> 00:16:46,560
without changing a line in your code the

00:16:43,079 --> 00:16:49,110
snap will change will will will will

00:16:46,560 --> 00:16:51,149
have new release what you just recompile

00:16:49,110 --> 00:16:53,970
it and you have not no change to do in

00:16:51,149 --> 00:16:59,360
your function over your application and

00:16:53,970 --> 00:17:06,809
the third thing is security so as you

00:16:59,360 --> 00:17:10,110
may have heard we are providing a block

00:17:06,809 --> 00:17:15,059
in the FPGA and we are we have the the

00:17:10,110 --> 00:17:17,339
other block in the chip which allows you

00:17:15,059 --> 00:17:20,280
which which I would say which which

00:17:17,339 --> 00:17:22,709
ensure that you are not killing the

00:17:20,280 --> 00:17:25,020
system with the some some problems in

00:17:22,709 --> 00:17:28,350
the FPGA okay so if you are badly coding

00:17:25,020 --> 00:17:29,940
away for your on purpose trying to kill

00:17:28,350 --> 00:17:32,690
the the server you should mean it

00:17:29,940 --> 00:17:32,690
shouldn't be able to do

00:17:33,890 --> 00:17:40,920
so framework what we have built with

00:17:38,310 --> 00:17:45,450
snap is a bunch of library which gives

00:17:40,920 --> 00:17:48,810
you some api's to hel old code very very

00:17:45,450 --> 00:17:54,630
quickly and the other side we built all

00:17:48,810 --> 00:17:57,570
the stuff to to handle all the the

00:17:54,630 --> 00:17:59,820
resource you you can you can access to

00:17:57,570 --> 00:18:03,690
so it can be on the right all the

00:17:59,820 --> 00:18:06,360
resource on card such as the the DRAM

00:18:03,690 --> 00:18:08,760
the envy me what the flash or the

00:18:06,360 --> 00:18:12,360
Internet

00:18:08,760 --> 00:18:14,970
and we also put all the job queue

00:18:12,360 --> 00:18:17,310
managers to be able to handle multiple

00:18:14,970 --> 00:18:20,520
actions or multiple threads on the other

00:18:17,310 --> 00:18:22,980
on the left or multiple thread or

00:18:20,520 --> 00:18:26,070
process on the on the left okay so today

00:18:22,980 --> 00:18:28,890
this is an open source I told you so

00:18:26,070 --> 00:18:33,060
today we have handling only one action

00:18:28,890 --> 00:18:36,390
and one process but if you want to

00:18:33,060 --> 00:18:39,000
contribute do to handle everything it's

00:18:36,390 --> 00:18:44,340
prepared for so you're very welcome to

00:18:39,000 --> 00:18:47,130
you to contribute and to help so what's

00:18:44,340 --> 00:18:52,130
left for the user you just need to write

00:18:47,130 --> 00:18:55,530
a program on the Left who is going to

00:18:52,130 --> 00:19:00,470
tell yes I'd like to use this FPGA card

00:18:55,530 --> 00:19:04,610
which with with with this action and

00:19:00,470 --> 00:19:07,770
just say well here the data in memory

00:19:04,610 --> 00:19:09,930
you are allowed to access and here you

00:19:07,770 --> 00:19:13,590
will where you will put your result and

00:19:09,930 --> 00:19:16,860
that's all he the application does after

00:19:13,590 --> 00:19:20,130
that the FPGA knows where all the data

00:19:16,860 --> 00:19:22,410
and can access them by its own know what

00:19:20,130 --> 00:19:26,700
he has to do so there's no need for the

00:19:22,410 --> 00:19:28,590
application to wait for it okay on the

00:19:26,700 --> 00:19:32,040
right the action although function can

00:19:28,590 --> 00:19:34,140
be written in C C++ or very long VHDL if

00:19:32,040 --> 00:19:36,360
you if you really love the LDL test no

00:19:34,140 --> 00:19:39,780
problem or very log it's no problem to

00:19:36,360 --> 00:19:43,140
write it we try to do some some tests a

00:19:39,780 --> 00:19:47,100
few weeks ago building an application

00:19:43,140 --> 00:19:52,919
for a customer and we write it with a

00:19:47,100 --> 00:19:54,780
as in see and compiled with HLS and we

00:19:52,919 --> 00:19:58,740
found that it was not very efficient so

00:19:54,780 --> 00:20:02,120
we part of it was rewritten in VA very

00:19:58,740 --> 00:20:05,970
log and we say ok so very log is much

00:20:02,120 --> 00:20:08,640
much more efficient well I just added

00:20:05,970 --> 00:20:12,570
one or two instructions in the HLS coded

00:20:08,640 --> 00:20:14,820
and in I'd say half a day we were able

00:20:12,570 --> 00:20:16,980
to see that we were getting the same

00:20:14,820 --> 00:20:19,260
performance than the Vario dog so just

00:20:16,980 --> 00:20:24,840
adding one or two pragmas to to explain

00:20:19,260 --> 00:20:31,200
the compiler why we were how to optimize

00:20:24,840 --> 00:20:37,140
things to interesting things so I

00:20:31,200 --> 00:20:39,630
already tell to talk about it first

00:20:37,140 --> 00:20:42,330
surreal mode so this is very often the

00:20:39,630 --> 00:20:45,600
mode everybody have in mind because it's

00:20:42,330 --> 00:20:49,970
like a software so you are doing the

00:20:45,600 --> 00:20:53,299
software is asking a function to be

00:20:49,970 --> 00:20:56,700
executed wait for the result and

00:20:53,299 --> 00:20:59,370
continue just think about that you can

00:20:56,700 --> 00:21:02,330
also use that another way saying well

00:20:59,370 --> 00:21:06,950
the software program is just setting

00:21:02,330 --> 00:21:09,809
everything for the FPGA but has no

00:21:06,950 --> 00:21:13,679
reason to wait for him all the data are

00:21:09,809 --> 00:21:15,360
going directly into the server memory so

00:21:13,679 --> 00:21:17,039
this as soon as the application is

00:21:15,360 --> 00:21:21,200
working the application is just a

00:21:17,039 --> 00:21:21,200
question of shared memory that's one

00:21:21,409 --> 00:21:29,100
okay so just to keep that again and

00:21:26,370 --> 00:21:34,320
again in mind you can now consider that

00:21:29,100 --> 00:21:36,179
you FPGA card is just a new core as all

00:21:34,320 --> 00:21:38,309
the other ones he has access to the

00:21:36,179 --> 00:21:43,530
husband or he's able to work by its own

00:21:38,309 --> 00:21:48,960
he it is really a new core that changed

00:21:43,530 --> 00:21:52,740
the way of seeing things so let's take a

00:21:48,960 --> 00:21:54,960
very simple example that's the the basic

00:21:52,740 --> 00:21:59,250
example you will find in the snap kick

00:21:54,960 --> 00:22:00,659
it up so let's think about an

00:21:59,250 --> 00:22:04,529
application

00:22:00,659 --> 00:22:09,450
which takes some data into a file so

00:22:04,529 --> 00:22:12,269
here you just like characters if you

00:22:09,450 --> 00:22:13,830
want to put that in lowercase or

00:22:12,269 --> 00:22:16,109
uppercase if you want to change the case

00:22:13,830 --> 00:22:18,599
of the of the text what will what you

00:22:16,109 --> 00:22:21,570
will do is you put that in memory well

00:22:18,599 --> 00:22:24,269
you read it from the from the from the

00:22:21,570 --> 00:22:26,849
disk you put that in a in memory then

00:22:24,269 --> 00:22:28,379
you ask the CPU to process it and back

00:22:26,849 --> 00:22:31,139
to the memory and back to the file

00:22:28,379 --> 00:22:34,080
that's the this the simplest way to do

00:22:31,139 --> 00:22:37,080
with things and you're just calling your

00:22:34,080 --> 00:22:39,659
your function snap snap play world with

00:22:37,080 --> 00:22:42,059
the - well with two arguments where all

00:22:39,659 --> 00:22:45,989
the date data are and where you want to

00:22:42,059 --> 00:22:51,139
put data the data so all the snap is

00:22:45,989 --> 00:22:54,690
built to keep this exactly the same way

00:22:51,139 --> 00:22:59,070
we are just going to implement the

00:22:54,690 --> 00:23:01,619
switch into the code into the C code so

00:22:59,070 --> 00:23:04,919
that we can switch from the CPU to the

00:23:01,619 --> 00:23:08,700
FPGA if you see the the blue line

00:23:04,919 --> 00:23:11,399
comment we are just adding a mode okay

00:23:08,700 --> 00:23:14,460
to explain that it is now anymore on CPU

00:23:11,399 --> 00:23:16,349
but on an FPGA that's not the right

00:23:14,460 --> 00:23:20,820
command but well it's just you to show

00:23:16,349 --> 00:23:23,999
you things so the first thing we are

00:23:20,820 --> 00:23:25,499
going to change in code is implementing

00:23:23,999 --> 00:23:29,489
this switch and the second thing we need

00:23:25,499 --> 00:23:31,259
is well now with the FPGA you have

00:23:29,489 --> 00:23:35,009
access to plenty of new resources

00:23:31,259 --> 00:23:39,749
totally unknown by the server ok so you

00:23:35,009 --> 00:23:42,690
just have to add in the code well when

00:23:39,749 --> 00:23:45,330
the FPGA will access some memory which

00:23:42,690 --> 00:23:48,149
memory I do you want to access is it the

00:23:45,330 --> 00:23:53,989
hot memory is it storage is it did you

00:23:48,149 --> 00:23:53,989
that's just some flags you need to add

00:23:54,259 --> 00:23:59,220
so just do - do I have a little bit in

00:23:57,059 --> 00:24:03,419
the code just to show you you that's

00:23:59,220 --> 00:24:07,999
typical see no magic things is just

00:24:03,419 --> 00:24:12,479
calling a api's but this is a real code

00:24:07,999 --> 00:24:14,610
so first thing you do in the in a

00:24:12,479 --> 00:24:16,650
program you just feel data

00:24:14,610 --> 00:24:20,340
into the house memory okay you have data

00:24:16,650 --> 00:24:22,560
to do things and when you are dealing in

00:24:20,340 --> 00:24:24,840
the implication so in the in the CPU

00:24:22,560 --> 00:24:25,710
program you are dealing with pointers

00:24:24,840 --> 00:24:29,490
okay

00:24:25,710 --> 00:24:31,740
address of where the data are so here we

00:24:29,490 --> 00:24:35,160
are just we have just put two pointers

00:24:31,740 --> 00:24:37,310
what is address in an address out where

00:24:35,160 --> 00:24:42,900
the doctor are and where we want the

00:24:37,310 --> 00:24:45,590
results to be stored the second thing is

00:24:42,900 --> 00:24:51,210
we are just going to send these pointers

00:24:45,590 --> 00:24:54,240
into a register and this register mmio

00:24:51,210 --> 00:24:55,560
reduces this will be shared with the

00:24:54,240 --> 00:24:58,050
FPGA that's the only thing we are

00:24:55,560 --> 00:25:01,760
sharing okay we are sharing the address

00:24:58,050 --> 00:25:01,760
we are not moving data

00:25:01,790 --> 00:25:08,340
the third thing before doing anything is

00:25:04,890 --> 00:25:11,580
well we can have multiple cards which

00:25:08,340 --> 00:25:14,970
one are we going to work with you may

00:25:11,580 --> 00:25:17,670
have a call with big memory you will may

00:25:14,970 --> 00:25:19,290
have caught with Ethernet access well

00:25:17,670 --> 00:25:22,590
just choose the card you want to work

00:25:19,290 --> 00:25:24,990
with and choose the function which is in

00:25:22,590 --> 00:25:27,870
it that you want to work with okay so

00:25:24,990 --> 00:25:32,130
here we will use the hello world action

00:25:27,870 --> 00:25:36,270
on the card and on this card okay so

00:25:32,130 --> 00:25:38,370
this is preparation we have not we

00:25:36,270 --> 00:25:42,030
didn't move data we don't wrote anything

00:25:38,370 --> 00:25:46,380
to the FPGA it's just a way of preparing

00:25:42,030 --> 00:25:50,550
things now okay this has can be done

00:25:46,380 --> 00:25:55,320
just at the initialization before you

00:25:50,550 --> 00:26:00,690
enter your real application now okay so

00:25:55,320 --> 00:26:04,380
you have just one thing to add first

00:26:00,690 --> 00:26:06,420
thing you are going to call an API which

00:26:04,380 --> 00:26:09,180
name here is a snap action syncing is a

00:26:06,420 --> 00:26:11,370
good job this is that was a complete

00:26:09,180 --> 00:26:15,780
action of which doing everything you can

00:26:11,370 --> 00:26:20,970
find also the same api's standing

00:26:15,780 --> 00:26:23,400
waiting moving everything can be fine so

00:26:20,970 --> 00:26:27,200
first thing we are going to see is to do

00:26:23,400 --> 00:26:30,150
is move these registers to the FPGA

00:26:27,200 --> 00:26:31,250
okay you prepared it this will be done

00:26:30,150 --> 00:26:34,890
by this command

00:26:31,250 --> 00:26:41,070
second thing is well in your FPGA you

00:26:34,890 --> 00:26:45,690
just want to to to get the data from the

00:26:41,070 --> 00:26:48,680
hot memory well just do a mem copy sorry

00:26:45,690 --> 00:26:52,110
oh let's start the function first and

00:26:48,680 --> 00:26:54,510
this will do mem copy this means that

00:26:52,110 --> 00:26:58,470
the FPGA will go and fetch the data in

00:26:54,510 --> 00:27:03,150
hosmer on DDR whether wherever you have

00:26:58,470 --> 00:27:05,190
put the data you do the processing this

00:27:03,150 --> 00:27:07,770
is the lower case processing or upper

00:27:05,190 --> 00:27:10,500
case processing sorry so it's typical

00:27:07,770 --> 00:27:12,660
see and then you move the diesels back

00:27:10,500 --> 00:27:15,780
to the determiner to the hot system

00:27:12,660 --> 00:27:17,730
that's all you do there's nothing magic

00:27:15,780 --> 00:27:21,540
you don't need to know OpenCL you don't

00:27:17,730 --> 00:27:26,340
need to know I'll say a specific

00:27:21,540 --> 00:27:28,320
language it's really basic C and then

00:27:26,340 --> 00:27:31,490
you say well okay I finished my work

00:27:28,320 --> 00:27:35,280
let's put the result in the register and

00:27:31,490 --> 00:27:37,320
that's them okay that's the serial way

00:27:35,280 --> 00:27:40,170
of doing things you can also do imagine

00:27:37,320 --> 00:27:42,420
that you have a flow of a video flow you

00:27:40,170 --> 00:27:44,760
are just processing things and there's

00:27:42,420 --> 00:27:47,130
no end of the action okay you're just

00:27:44,760 --> 00:27:52,680
processing and sending the result

00:27:47,130 --> 00:27:56,190
directly to the hospital memory and once

00:27:52,680 --> 00:27:59,550
you are done well just write the data to

00:27:56,190 --> 00:28:02,760
a file and free the action and freida

00:27:59,550 --> 00:28:05,360
memory every there the the code so that

00:28:02,760 --> 00:28:08,250
somebody else can use it

00:28:05,360 --> 00:28:12,360
okay so that's a typical example you can

00:28:08,250 --> 00:28:16,200
find in the snap get up there plenty of

00:28:12,360 --> 00:28:21,800
other examples much more complex

00:28:16,200 --> 00:28:21,800
hopefully okay so now yes

00:28:28,100 --> 00:28:48,230
yes yes I'm coming in yeah correct so my

00:28:45,450 --> 00:28:50,549
default that's right your FPGA is empty

00:28:48,230 --> 00:28:54,690
okay you get it something empty you need

00:28:50,549 --> 00:29:00,840
to put something in it so here's the way

00:28:54,690 --> 00:29:02,759
to do things you have a program which is

00:29:00,840 --> 00:29:04,889
an application and a function which we

00:29:02,759 --> 00:29:07,769
call an action here you just have to

00:29:04,889 --> 00:29:09,960
separate them add the different switch

00:29:07,769 --> 00:29:14,580
to be able to switch from the FPGA to

00:29:09,960 --> 00:29:17,450
the CPU and that's all you do so the

00:29:14,580 --> 00:29:20,879
common is just to make like all the

00:29:17,450 --> 00:29:24,149
software guys use just do you make this

00:29:20,879 --> 00:29:27,720
will compile the action and you can test

00:29:24,149 --> 00:29:29,879
that everything works the second thing

00:29:27,720 --> 00:29:32,970
is well now we want to have this

00:29:29,879 --> 00:29:37,230
function move to a VGA so we are going

00:29:32,970 --> 00:29:40,590
to to add a little bit of I was a

00:29:37,230 --> 00:29:42,389
complexity meaning we need to access to

00:29:40,590 --> 00:29:46,500
do the mem copy to do to access to the

00:29:42,389 --> 00:29:50,759
data directly in the FPGA in this memory

00:29:46,500 --> 00:29:54,480
sorry so what we are going to do is we

00:29:50,759 --> 00:29:56,250
are adding some we are moving this what

00:29:54,480 --> 00:29:58,980
we will call this software function to

00:29:56,250 --> 00:30:03,240
the hardware function and we keep the

00:29:58,980 --> 00:30:06,149
both so we are able to every time to to

00:30:03,240 --> 00:30:11,250
compare things we're going to move this

00:30:06,149 --> 00:30:16,019
action to a hardware action and we are

00:30:11,250 --> 00:30:21,720
going to test this action with a very

00:30:16,019 --> 00:30:24,840
smart model which is PS la se PS l which

00:30:21,720 --> 00:30:27,750
is the physical service layer simulation

00:30:24,840 --> 00:30:29,730
engine this is very important to

00:30:27,750 --> 00:30:31,889
understand because this means that you

00:30:29,730 --> 00:30:35,129
are able with an application and an

00:30:31,889 --> 00:30:39,110
action to test things exactly as if it

00:30:35,129 --> 00:30:39,110
was in software to source software

00:30:41,880 --> 00:30:54,820
okay yes you have the open Cappy

00:30:45,640 --> 00:30:59,740
simulation engine correct yeah and this

00:30:54,820 --> 00:31:02,410
is a huge huge thing to be able to

00:30:59,740 --> 00:31:05,740
develop and debug much quicker you don't

00:31:02,410 --> 00:31:08,200
need to create unit test you get you

00:31:05,740 --> 00:31:10,090
just use the data you are you using in

00:31:08,200 --> 00:31:14,530
normal application and you just send

00:31:10,090 --> 00:31:18,520
them to it it's this model will emulate

00:31:14,530 --> 00:31:20,260
the power 8 and the FPGA card with the

00:31:18,520 --> 00:31:23,320
PSL and all the stuff you need in it

00:31:20,260 --> 00:31:28,210
without any specific tests to bring

00:31:23,320 --> 00:31:31,840
activity to build for that so to to

00:31:28,210 --> 00:31:36,130
build this simulator simulation model

00:31:31,840 --> 00:31:39,700
you just do maxima or make model these

00:31:36,130 --> 00:31:43,290
are the actions to bring that you will

00:31:39,700 --> 00:31:47,410
see that I'm have put x86 server these

00:31:43,290 --> 00:31:50,020
run on x86 server because vibha do is

00:31:47,410 --> 00:31:52,840
working on x86 server that's the unique

00:31:50,020 --> 00:31:55,150
reason okay we are trying to push

00:31:52,840 --> 00:31:59,950
guidance to to have that on power also

00:31:55,150 --> 00:32:05,620
well today we are we have only on x86

00:31:59,950 --> 00:32:07,120
server so this is something which the

00:32:05,620 --> 00:32:09,820
compilation of that is quite quick

00:32:07,120 --> 00:32:13,330
meaning a couple of minutes one or two

00:32:09,820 --> 00:32:15,250
minutes to do you that well it's long

00:32:13,330 --> 00:32:18,790
for a software I know but it's very

00:32:15,250 --> 00:32:23,890
quick for a hard work like so this will

00:32:18,790 --> 00:32:26,260
build the this will be able to show you

00:32:23,890 --> 00:32:28,800
that your logic works that all the

00:32:26,260 --> 00:32:31,780
excess of the data the conversion

00:32:28,800 --> 00:32:35,110
getting something in memory which is a

00:32:31,780 --> 00:32:39,340
unsigned or double or float well you can

00:32:35,110 --> 00:32:46,870
just pick it and try it with the real

00:32:39,340 --> 00:32:50,710
code once everything is done well you

00:32:46,870 --> 00:32:52,669
just move you will create an image make

00:32:50,710 --> 00:32:57,139
image we try to do two things

00:32:52,669 --> 00:33:01,100
simple the image is the binary file that

00:32:57,139 --> 00:33:03,889
will contain all the the action code the

00:33:01,100 --> 00:33:06,529
snap code and the PSL or the GL GL code

00:33:03,889 --> 00:33:09,320
this is all your program and that will

00:33:06,529 --> 00:33:14,899
be put in a binary file and you then

00:33:09,320 --> 00:33:20,840
send it on the FPGA card which is in a

00:33:14,899 --> 00:33:24,889
power server get it okay so and the very

00:33:20,840 --> 00:33:28,129
very good thing if you see something if

00:33:24,889 --> 00:33:30,739
you see a bug on the real hardware you

00:33:28,129 --> 00:33:32,690
will see it in the simulation that's

00:33:30,739 --> 00:33:36,440
very good to understand because when you

00:33:32,690 --> 00:33:38,600
try to to find a problem you can find it

00:33:36,440 --> 00:33:40,940
in simulation ok

00:33:38,600 --> 00:33:44,529
meaning the simulator are really

00:33:40,940 --> 00:33:46,700
accurate to be able to to find things

00:33:44,529 --> 00:33:54,220
well that's all you you need

00:33:46,700 --> 00:33:57,259
so just five minutes five minutes good

00:33:54,220 --> 00:34:03,679
just to show you that we are able to do

00:33:57,259 --> 00:34:06,460
things quick and efficiently I tried to

00:34:03,679 --> 00:34:09,230
to use a this possible for a customer I

00:34:06,460 --> 00:34:11,960
try to you know maybe a short three

00:34:09,230 --> 00:34:14,419
short three is the sort of key

00:34:11,960 --> 00:34:16,159
calculation like Bitcoin Bitcoin doesn't

00:34:14,419 --> 00:34:20,200
use it short three butters very year

00:34:16,159 --> 00:34:25,609
similar to this one so it's a matter of

00:34:20,200 --> 00:34:27,530
processing keys okay and this is what we

00:34:25,609 --> 00:34:31,129
call the catch a key here on the on the

00:34:27,530 --> 00:34:33,559
Left I don't know what's in it okay you

00:34:31,129 --> 00:34:35,000
have plenty of rotation of matrix and I

00:34:33,559 --> 00:34:37,299
don't want you to do it you know what's

00:34:35,000 --> 00:34:40,639
in it I just got this code from a

00:34:37,299 --> 00:34:42,919
customer is saying okay hey we have a

00:34:40,639 --> 00:34:45,230
meeting in three weeks just show me what

00:34:42,919 --> 00:34:49,909
you are able to do well three weeks in

00:34:45,230 --> 00:34:55,149
FPGA normally it's you say no well here

00:34:49,909 --> 00:35:00,049
we tried so we had we took the C code I

00:34:55,149 --> 00:35:04,220
just removed some system variables or

00:35:00,049 --> 00:35:06,080
system calls as we were here trying to

00:35:04,220 --> 00:35:08,930
do the maximum of

00:35:06,080 --> 00:35:10,670
processing keep processing it was

00:35:08,930 --> 00:35:12,440
calculating here and the number of

00:35:10,670 --> 00:35:18,440
processing stopping after a certain

00:35:12,440 --> 00:35:20,060
amount of time of time sorry here if on

00:35:18,440 --> 00:35:22,340
a typical example like that you have

00:35:20,060 --> 00:35:27,950
three different ways of seeing things

00:35:22,340 --> 00:35:30,860
one is a math math function and it can

00:35:27,950 --> 00:35:32,630
be multiple loops doing something and

00:35:30,860 --> 00:35:34,820
you have parallel loops and recursive

00:35:32,630 --> 00:35:37,550
loops recursive loops is waiting for the

00:35:34,820 --> 00:35:40,100
result before calling the new thing so

00:35:37,550 --> 00:35:41,930
you have nothing to do with that you

00:35:40,100 --> 00:35:43,460
need to wait for the e result to go

00:35:41,930 --> 00:35:46,730
further so you will not be able to

00:35:43,460 --> 00:35:50,930
optimize this but parallel loops like

00:35:46,730 --> 00:35:54,730
this one means that you may be able to

00:35:50,930 --> 00:35:58,070
duplicate the logic you used and just

00:35:54,730 --> 00:36:01,730
compute the result here is XOR with the

00:35:58,070 --> 00:36:03,830
checksum so having the first and before

00:36:01,730 --> 00:36:06,770
the second is not a problem you can do

00:36:03,830 --> 00:36:09,230
things in parallel so just to show you

00:36:06,770 --> 00:36:12,770
things and we will go tomorrow more in

00:36:09,230 --> 00:36:16,820
details if you want we have three types

00:36:12,770 --> 00:36:22,280
of of things we we could be able to

00:36:16,820 --> 00:36:26,840
optimize so just to show you this is the

00:36:22,280 --> 00:36:31,430
decoder I got this is three four loops

00:36:26,840 --> 00:36:34,310
on the Left I just added a pragma which

00:36:31,430 --> 00:36:35,870
is HLS pipeline you will see tomorrow

00:36:34,310 --> 00:36:40,280
the effect of this one if you want I

00:36:35,870 --> 00:36:42,890
have been able to to shrink the well

00:36:40,280 --> 00:36:46,670
when I first compiled that I had a three

00:36:42,890 --> 00:36:50,330
hundred cycles whatever it means three

00:36:46,670 --> 00:36:53,390
hundred cycles of to do all that I just

00:36:50,330 --> 00:36:56,450
added this line modified two things to

00:36:53,390 --> 00:37:00,110
separate the input and the output and

00:36:56,450 --> 00:37:04,270
automatically HH LS was able to do it

00:37:00,110 --> 00:37:07,310
two cycles two cycles of four

00:37:04,270 --> 00:37:09,890
nanoseconds here so in eight nanoseconds

00:37:07,310 --> 00:37:11,930
is able to do all that and once more I

00:37:09,890 --> 00:37:13,610
don't know what's what's in it I didn't

00:37:11,930 --> 00:37:16,250
want to do every to understand if I

00:37:13,610 --> 00:37:18,620
could optimize it by myself just for

00:37:16,250 --> 00:37:20,000
your information we had somebody in the

00:37:18,620 --> 00:37:23,420
same team doing the same

00:37:20,000 --> 00:37:26,270
work with GPU and CUDA that's just for

00:37:23,420 --> 00:37:29,360
fun they had to rewrite things so they

00:37:26,270 --> 00:37:31,940
had quite the same result than me a bit

00:37:29,360 --> 00:37:36,710
bit better with the Minsky but all the

00:37:31,940 --> 00:37:39,140
other CPU at this time I was better than

00:37:36,710 --> 00:37:41,500
them they had to rewrite everything I

00:37:39,140 --> 00:37:45,620
didn't touch it long so that's

00:37:41,500 --> 00:37:49,180
interesting just to show you how things

00:37:45,620 --> 00:37:52,370
are internal I was speaking about

00:37:49,180 --> 00:37:54,890
duplicating things because I had

00:37:52,370 --> 00:37:58,130
parallel loops so I tried first deplete

00:37:54,890 --> 00:38:02,150
duplicating that by 16 ok I have place

00:37:58,130 --> 00:38:04,790
to put 16 things in it let's try 32 well

00:38:02,150 --> 00:38:09,160
I was able to do that also to put 32 I

00:38:04,790 --> 00:38:12,680
guess I can't put anything more in it

00:38:09,160 --> 00:38:17,720
that's a good interesting view PSL is

00:38:12,680 --> 00:38:19,520
the p8 PSL processor service like so if

00:38:17,720 --> 00:38:22,780
you look to that it was taking quite a

00:38:19,520 --> 00:38:27,530
lot of place the TLD a list now much

00:38:22,780 --> 00:38:31,040
much smaller snap is the logic we are

00:38:27,530 --> 00:38:33,980
using for the whole thing you don't have

00:38:31,040 --> 00:38:36,860
any driver of ddr because you didn't

00:38:33,980 --> 00:38:39,290
need it so snap is removing removing it

00:38:36,860 --> 00:38:48,020
if you don't need it you don't have

00:38:39,290 --> 00:38:50,330
anything else okay the results well two

00:38:48,020 --> 00:38:55,100
lines on two columns on the left are the

00:38:50,330 --> 00:38:57,260
number of processing per second two on

00:38:55,100 --> 00:38:58,970
the right at the time it takes so

00:38:57,260 --> 00:39:02,330
interesting to see that well we have

00:38:58,970 --> 00:39:08,150
been here able to duplicate by 32 so

00:39:02,330 --> 00:39:12,830
from 100 to 3 Millions this means 1 to

00:39:08,150 --> 00:39:15,260
32 channels we have no additional time

00:39:12,830 --> 00:39:19,340
everything is processed in parallel why

00:39:15,260 --> 00:39:24,740
the CPU is adding numbers ok increasing

00:39:19,340 --> 00:39:26,870
the time exactly the same thing on the

00:39:24,740 --> 00:39:29,110
left if you look to the number of

00:39:26,870 --> 00:39:32,890
processing by seconds the more you are

00:39:29,110 --> 00:39:32,890
doing calls

00:39:32,900 --> 00:39:43,310
the CPU is increasing things while we

00:39:37,160 --> 00:39:45,620
are still at the same number of of a

00:39:43,310 --> 00:39:49,210
check per seconds okay

00:39:45,620 --> 00:39:53,960
so just and just to show you we are

00:39:49,210 --> 00:39:56,630
better than 35 X and this was what we

00:39:53,960 --> 00:40:00,290
showed you the customer and in the three

00:39:56,630 --> 00:40:02,570
weeks time frame so in 35 X without

00:40:00,290 --> 00:40:10,160
doing anything without changing things

00:40:02,570 --> 00:40:12,170
okay in his code with all the snapshots

00:40:10,160 --> 00:40:17,500
of all the things we took her two weeks

00:40:12,170 --> 00:40:20,270
yeah and this was the very first

00:40:17,500 --> 00:40:22,130
experience we had doing things so with

00:40:20,270 --> 00:40:26,570
somebody who doesn't know a lot about

00:40:22,130 --> 00:40:29,660
nothing that's all so morally

00:40:26,570 --> 00:40:33,110
summarizing things just to keep you keep

00:40:29,660 --> 00:40:36,350
that in mind so you got this one three

00:40:33,110 --> 00:40:40,160
reasons why to do that how to implement

00:40:36,350 --> 00:40:44,450
that three steps and if you want to try

00:40:40,160 --> 00:40:46,730
you go to new mix you get an account and

00:40:44,450 --> 00:40:49,580
you can in a half an hour you have an

00:40:46,730 --> 00:40:53,840
example on the desktop you can just try

00:40:49,580 --> 00:40:57,200
things from the examples you want to a

00:40:53,840 --> 00:41:00,970
real FPGA and it will cost you a few few

00:40:57,200 --> 00:41:00,970
sheds okay

00:41:01,370 --> 00:41:07,830

YouTube URL: https://www.youtube.com/watch?v=W0rnX8ZqNoA


