Title: OpenPOWER Summit Europe 2018: Introduction to the OpenCAPI Interface
Publication date: 2019-02-07
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Brian Allison, IBM, speaks at OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,080 --> 00:00:05,300
yeah my name is Brian Allison I'm

00:00:02,840 --> 00:00:09,200
actually out of the IBM Rochester

00:00:05,300 --> 00:00:11,780
development site I'm actually part of

00:00:09,200 --> 00:00:14,870
the open Cappy technology and

00:00:11,780 --> 00:00:17,900
development team right so most of that

00:00:14,870 --> 00:00:20,060
is done primarily in Rochester

00:00:17,900 --> 00:00:24,339
I spend a significant amount of my time

00:00:20,060 --> 00:00:27,439
these days talking with researchers

00:00:24,339 --> 00:00:29,619
partners others you know folks like that

00:00:27,439 --> 00:00:34,750
that are interested in acceleration and

00:00:29,619 --> 00:00:38,109
then primarily about open Cappy right so

00:00:34,750 --> 00:00:41,539
my job is to get them kind of oriented

00:00:38,109 --> 00:00:43,730
around the technology and then actually

00:00:41,539 --> 00:00:45,530
get them unable get them started right

00:00:43,730 --> 00:00:48,649
and then we kind of just have this

00:00:45,530 --> 00:00:50,750
process where we've got FLAC channels

00:00:48,649 --> 00:00:52,460
and other means to kind of help them as

00:00:50,750 --> 00:00:55,609
they go along the way so what I'm gonna

00:00:52,460 --> 00:00:57,289
trying to describe today is kind of an

00:00:55,609 --> 00:00:59,149
introduction to open Cappy it's going to

00:00:57,289 --> 00:01:02,870
go a lower you know lower level than

00:00:59,149 --> 00:01:04,400
Myron did this morning and talked about

00:01:02,870 --> 00:01:06,620
the interfaces and things of that nature

00:01:04,400 --> 00:01:08,510
I always like to kind of know my

00:01:06,620 --> 00:01:10,940
audience a little bit first so how many

00:01:08,510 --> 00:01:15,470
folks are familiar with either Capuano

00:01:10,940 --> 00:01:17,180
Cappy - dado open Cappy 3-dot oh that's

00:01:15,470 --> 00:01:22,390
pretty good how many folks have actually

00:01:17,180 --> 00:01:22,390
done development with one of those

00:01:23,909 --> 00:01:27,210
okay that's still pretty decent okay

00:01:26,340 --> 00:01:29,640
that's that's okay

00:01:27,210 --> 00:01:31,289
that's good I'm Aaron Kenny went over

00:01:29,640 --> 00:01:33,840
that so yeah here are the things I'm

00:01:31,289 --> 00:01:35,189
gonna try and cover this afternoon first

00:01:33,840 --> 00:01:38,070
thing we're to go over is just the

00:01:35,189 --> 00:01:40,320
protocol stack itself just familiarize

00:01:38,070 --> 00:01:43,679
yourself with the acronyms that that we

00:01:40,320 --> 00:01:45,539
use what those mean we're going to go

00:01:43,679 --> 00:01:46,920
over the reference design overviews

00:01:45,539 --> 00:01:48,960
we're talk a little bit about the

00:01:46,920 --> 00:01:50,369
reference code itself we're going to

00:01:48,960 --> 00:01:51,899
talk a little bit about the interface

00:01:50,369 --> 00:01:53,340
I'm not going to go into too much detail

00:01:51,899 --> 00:01:56,390
but I'm gonna give you a flavor for what

00:01:53,340 --> 00:01:58,679
the interfaces look like we'll give you

00:01:56,390 --> 00:02:00,689
some information about the reference

00:01:58,679 --> 00:02:03,319
design cards where we're at today what

00:02:00,689 --> 00:02:06,569
we've tested so far we're kind of going

00:02:03,319 --> 00:02:07,860
we'll go over the reference AF use right

00:02:06,569 --> 00:02:09,599
and this is kind of all the things that

00:02:07,860 --> 00:02:10,739
are kind of like in our toolbox I guess

00:02:09,599 --> 00:02:13,049
you could say when you once you start

00:02:10,739 --> 00:02:15,209
enablement we'll talk a little bit a

00:02:13,049 --> 00:02:16,920
little bit about performance you know

00:02:15,209 --> 00:02:21,319
things that we've observed in the lab

00:02:16,920 --> 00:02:21,319
and then our roadmap moving forward

00:02:21,410 --> 00:02:25,680
alright so this is a slide that if

00:02:24,060 --> 00:02:27,269
you've attended any of our open Cappy

00:02:25,680 --> 00:02:30,060
sessions right this is a slide that we

00:02:27,269 --> 00:02:32,130
like to throw up there just to kind of

00:02:30,060 --> 00:02:36,299
give you a feel for what what the

00:02:32,130 --> 00:02:37,829
different layers are of the stack so the

00:02:36,299 --> 00:02:40,139
top layer right it's called the

00:02:37,829 --> 00:02:42,150
transaction layer it's TL there's a

00:02:40,139 --> 00:02:44,459
framer and a purse or associated with

00:02:42,150 --> 00:02:47,340
that right and it specifies all the

00:02:44,459 --> 00:02:49,440
control and response packets between the

00:02:47,340 --> 00:02:52,350
hosts so it's on the host fabric bus

00:02:49,440 --> 00:02:54,530
right Myron mentioned that this morning

00:02:52,350 --> 00:02:57,630
if you look at the architecture

00:02:54,530 --> 00:02:59,760
specifications themselves right it's

00:02:57,630 --> 00:03:02,519
meant to really be host agnostic there's

00:02:59,760 --> 00:03:03,959
nothing that's power bus centric right

00:03:02,519 --> 00:03:06,209
now you might actually have to write

00:03:03,959 --> 00:03:08,340
some glue logic to have it adhere to a

00:03:06,209 --> 00:03:10,290
different protocol like let's say an AMD

00:03:08,340 --> 00:03:11,730
or an arm or something like that but if

00:03:10,290 --> 00:03:14,100
you look at the specification you'll

00:03:11,730 --> 00:03:15,989
never see the word power in there

00:03:14,100 --> 00:03:22,260
anywhere and it's written specifically

00:03:15,989 --> 00:03:24,299
for that now on the host side right it

00:03:22,260 --> 00:03:26,099
converts any kind of host initiated

00:03:24,299 --> 00:03:29,639
protocol requests into the transaction

00:03:26,099 --> 00:03:31,380
layer right and then that's the down

00:03:29,639 --> 00:03:33,449
bound side and then on the up bound side

00:03:31,380 --> 00:03:35,609
it takes any of the TLX initiated

00:03:33,449 --> 00:03:37,620
commands from the accelerator and puts

00:03:35,609 --> 00:03:38,849
them into onto the fabric bus

00:03:37,620 --> 00:03:41,610
and then it also does any other

00:03:38,849 --> 00:03:43,319
responses to any endpoint initiate

00:03:41,610 --> 00:03:46,379
commands so if there is something like a

00:03:43,319 --> 00:03:48,470
DMA request write a read with no intent

00:03:46,379 --> 00:03:51,390
to cache right that would actually go

00:03:48,470 --> 00:03:52,680
you know the up bound interface and then

00:03:51,390 --> 00:03:54,780
it would actually take a response to

00:03:52,680 --> 00:03:56,519
send it back down to the AF you so

00:03:54,780 --> 00:03:59,480
that's that's the part of the logic

00:03:56,519 --> 00:04:02,010
that's actually in that black circle box

00:03:59,480 --> 00:04:05,849
then we have the Associated data link

00:04:02,010 --> 00:04:08,160
layer for open copy we support twenty

00:04:05,849 --> 00:04:11,549
five point seven eight one two five is

00:04:08,160 --> 00:04:15,209
what we use right as our serial data

00:04:11,549 --> 00:04:17,459
link rate for lab debug we actually do

00:04:15,209 --> 00:04:19,799
have a backup mechanism to run at twenty

00:04:17,459 --> 00:04:22,280
gigabit so if you actually have a server

00:04:19,799 --> 00:04:24,120
at your disposal we do have a patch

00:04:22,280 --> 00:04:27,750
associated with that to let you run

00:04:24,120 --> 00:04:29,639
slower the reason that we do that is you

00:04:27,750 --> 00:04:32,250
know we're we realized that you know

00:04:29,639 --> 00:04:34,919
with that type of serial data rate the

00:04:32,250 --> 00:04:37,139
internal timing closure for the fpga is

00:04:34,919 --> 00:04:39,650
that four hundred megahertz right which

00:04:37,139 --> 00:04:41,760
sometimes can be very challenging right

00:04:39,650 --> 00:04:43,440
so what we do is we give you something

00:04:41,760 --> 00:04:44,789
that's a little bit easier to close on

00:04:43,440 --> 00:04:47,450
timing lets you focus on your

00:04:44,789 --> 00:04:50,639
accelerator let you focus on your

00:04:47,450 --> 00:04:52,080
simulation and get it working right and

00:04:50,639 --> 00:04:54,030
then when you feel like you're ready to

00:04:52,080 --> 00:04:55,950
do something and deploy then you can

00:04:54,030 --> 00:04:57,510
actually jack up the transceiver rates

00:04:55,950 --> 00:04:59,789
and run it twenty five point seven eight

00:04:57,510 --> 00:05:02,940
one through five so that whole black box

00:04:59,789 --> 00:05:06,000
right on the host side with the dl the

00:05:02,940 --> 00:05:09,570
Phi the Phi X and the DL X are what we

00:05:06,000 --> 00:05:11,190
call the data link layer on the endpoint

00:05:09,570 --> 00:05:14,370
side of the device so you'll you'll hear

00:05:11,190 --> 00:05:16,020
me say that a lot right an endpoint is

00:05:14,370 --> 00:05:18,479
basically it can be anything right it

00:05:16,020 --> 00:05:20,639
could be a Knick it could be a GPU it

00:05:18,479 --> 00:05:22,770
could be an FPGA it could be an ASIC

00:05:20,639 --> 00:05:24,810
right that terminology has just met for

00:05:22,770 --> 00:05:25,860
the guy on the other end right we

00:05:24,810 --> 00:05:28,979
mentioned it this morning

00:05:25,860 --> 00:05:30,660
open Cappy is a point-to-point bus right

00:05:28,979 --> 00:05:33,919
it doesn't support a switch or fabric

00:05:30,660 --> 00:05:36,330
type topology it is truly point-to-point

00:05:33,919 --> 00:05:38,010
on the endpoint side of the equation

00:05:36,330 --> 00:05:40,710
right it's going to take your a if you

00:05:38,010 --> 00:05:42,599
initiated transaction layer commands

00:05:40,710 --> 00:05:44,430
which is that green horizontal line

00:05:42,599 --> 00:05:46,050
right there right and it's going to

00:05:44,430 --> 00:05:48,659
basically take those packets and it's

00:05:46,050 --> 00:05:51,390
going to packetize those things right

00:05:48,659 --> 00:05:53,310
and put it into a format that it can be

00:05:51,390 --> 00:05:54,810
understood at the transaction layer then

00:05:53,310 --> 00:06:01,530
across the data link layer then turns

00:05:54,810 --> 00:06:03,270
into the host what I wanted to try and

00:06:01,530 --> 00:06:05,520
describe to you this is kind of another

00:06:03,270 --> 00:06:07,560
way of looking at that same stack prior

00:06:05,520 --> 00:06:10,590
but there's another important

00:06:07,560 --> 00:06:12,180
distinction on this animal so everything

00:06:10,590 --> 00:06:15,630
that's on the right hand side of the

00:06:12,180 --> 00:06:18,660
equation right is what we call our FPGA

00:06:15,630 --> 00:06:21,240
reference design right and you're gonna

00:06:18,660 --> 00:06:23,430
see the Phi X the DL x2 the TLX right we

00:06:21,240 --> 00:06:26,090
described all that stuff earlier but we

00:06:23,430 --> 00:06:28,230
also give you a config block as well and

00:06:26,090 --> 00:06:30,360
there's an important distinction for

00:06:28,230 --> 00:06:32,580
that so historically you know we've

00:06:30,360 --> 00:06:34,080
actually had some partners and some

00:06:32,580 --> 00:06:37,530
customers that have bricks some cards

00:06:34,080 --> 00:06:39,360
right which is never a good thing so

00:06:37,530 --> 00:06:41,940
what we've done is is we want to

00:06:39,360 --> 00:06:44,370
abstract all of that config logic out of

00:06:41,940 --> 00:06:46,860
the AF you development and provide it as

00:06:44,370 --> 00:06:49,260
a piece of IP for you to consume right

00:06:46,860 --> 00:06:52,170
so all of the config reads and writes so

00:06:49,260 --> 00:06:54,000
the things that are necessary for config

00:06:52,170 --> 00:06:56,010
and discovery and all that other kind of

00:06:54,000 --> 00:06:57,720
good stuff right that all passes from

00:06:56,010 --> 00:06:59,400
the transaction layer right into the

00:06:57,720 --> 00:07:02,280
config space and then there's some

00:06:59,400 --> 00:07:04,200
outputs from from the config block into

00:07:02,280 --> 00:07:06,330
the AF you for to for you to kind of

00:07:04,200 --> 00:07:08,160
observe but the actual registers

00:07:06,330 --> 00:07:10,170
themselves are actually in this piece of

00:07:08,160 --> 00:07:16,830
IP that we put as part of our reference

00:07:10,170 --> 00:07:19,800
design make sense so far all right all

00:07:16,830 --> 00:07:22,140
right so far you know we've done

00:07:19,800 --> 00:07:24,270
everything on a Xilinx based Verilog

00:07:22,140 --> 00:07:28,770
design right it's been on the ultra

00:07:24,270 --> 00:07:30,660
scale plus family it's only those family

00:07:28,770 --> 00:07:32,850
of devices that support the transceiver

00:07:30,660 --> 00:07:35,210
rates that we're talking about right so

00:07:32,850 --> 00:07:37,500
everything is usually a gty transceiver

00:07:35,210 --> 00:07:40,350
right we run it like I said a little bit

00:07:37,500 --> 00:07:42,210
north of 25 gigabyte or gigabit right so

00:07:40,350 --> 00:07:45,450
if you use the GT HS right that wouldn't

00:07:42,210 --> 00:07:48,690
support that kind of serial data rate so

00:07:45,450 --> 00:07:51,330
we use ultra scale pluses for that the

00:07:48,690 --> 00:07:53,700
reference design itself right like I

00:07:51,330 --> 00:07:57,210
said it encompasses the Phi X the TLX

00:07:53,700 --> 00:08:00,540
the DL X and it config core one thing

00:07:57,210 --> 00:08:02,850
about it is it's not separated into

00:08:00,540 --> 00:08:05,430
something like PCI Express there's not

00:08:02,850 --> 00:08:08,250
like a PCs and

00:08:05,430 --> 00:08:15,060
right it's not structured like that all

00:08:08,250 --> 00:08:17,130
of the all of the CRC replay all of that

00:08:15,060 --> 00:08:19,410
stuff is all kind of embedded into the

00:08:17,130 --> 00:08:22,410
DLX logic itself so it's it's very

00:08:19,410 --> 00:08:24,150
tightly integrated right between the Phi

00:08:22,410 --> 00:08:25,500
X and the DL X it's kind of tough to

00:08:24,150 --> 00:08:27,480
tell the distinction because it's all

00:08:25,500 --> 00:08:31,680
kind of bunched together you won't see

00:08:27,480 --> 00:08:33,120
it form formulated that way like I

00:08:31,680 --> 00:08:35,520
mentioned earlier everything runs at a

00:08:33,120 --> 00:08:38,250
64 byte flip flow

00:08:35,520 --> 00:08:40,020
400 megahertz you know we've we've

00:08:38,250 --> 00:08:41,850
actually had some challenges internally

00:08:40,020 --> 00:08:43,890
I'll be honest with you to close at 400

00:08:41,850 --> 00:08:46,470
we've actually made some some very good

00:08:43,890 --> 00:08:49,110
discoveries over the last couple of

00:08:46,470 --> 00:08:50,550
weeks to quote to make it easier to

00:08:49,110 --> 00:08:53,190
close timing it actually turned out to

00:08:50,550 --> 00:08:54,780
be a CRC path believe it or not that

00:08:53,190 --> 00:08:57,300
because it's causing us some heartburn

00:08:54,780 --> 00:09:00,900
so we've actually made some some good

00:08:57,300 --> 00:09:02,820
discoveries over the last week the other

00:09:00,900 --> 00:09:05,370
thing that we're trying to do is we're

00:09:02,820 --> 00:09:07,920
trying to be make everything tickle

00:09:05,370 --> 00:09:09,660
script generated right going through the

00:09:07,920 --> 00:09:12,090
GUI you mean obviously you can always do

00:09:09,660 --> 00:09:13,290
it that way but we're also doing

00:09:12,090 --> 00:09:15,600
everything with tickle scripts as well

00:09:13,290 --> 00:09:18,720
right and that's part of the reference

00:09:15,600 --> 00:09:20,730
design we don't want folks to basically

00:09:18,720 --> 00:09:22,560
invent the wheel right when somebody

00:09:20,730 --> 00:09:24,690
actually is part of the consortium

00:09:22,560 --> 00:09:28,380
they're part of the enablement workgroup

00:09:24,690 --> 00:09:30,180
you know that lavato project flow here

00:09:28,380 --> 00:09:32,520
you go right we're gonna give you the

00:09:30,180 --> 00:09:34,200
whole project flow we'll give you the

00:09:32,520 --> 00:09:36,060
like I said the reference design will

00:09:34,200 --> 00:09:37,740
actually give you all the exercisers as

00:09:36,060 --> 00:09:39,570
part of that and the bit images

00:09:37,740 --> 00:09:41,220
associated with that so once you procure

00:09:39,570 --> 00:09:43,500
a server you've got a server in your

00:09:41,220 --> 00:09:44,970
hand you got a card your hand you could

00:09:43,500 --> 00:09:46,770
actually burn the image that same day

00:09:44,970 --> 00:09:49,080
and get it up and running that's the

00:09:46,770 --> 00:09:50,880
spirit of it right and that's what we

00:09:49,080 --> 00:09:52,110
want to happen right we don't want you

00:09:50,880 --> 00:09:53,640
guys following around and figure out

00:09:52,110 --> 00:09:55,830
well gee is that my image is that the

00:09:53,640 --> 00:09:57,750
server whatever we'll give you exactly

00:09:55,830 --> 00:10:00,090
the images that we used in our lab to do

00:09:57,750 --> 00:10:04,290
our processor validation right as as

00:10:00,090 --> 00:10:06,510
part of our avato project today we're

00:10:04,290 --> 00:10:08,700
using an internal github for that kind

00:10:06,510 --> 00:10:10,370
of dissemination process I guess you

00:10:08,700 --> 00:10:14,870
could call it that

00:10:10,370 --> 00:10:17,040
we're also making it available under NDA

00:10:14,870 --> 00:10:18,480
for customers and the reason that we're

00:10:17,040 --> 00:10:20,150
doing that is is what

00:10:18,480 --> 00:10:23,310
there's an important distinction that

00:10:20,150 --> 00:10:25,410
has to be remembered this has actually

00:10:23,310 --> 00:10:26,130
been contributed to the open Cappy

00:10:25,410 --> 00:10:28,860
consortium

00:10:26,130 --> 00:10:31,800
now obviously IBM still has the rights

00:10:28,860 --> 00:10:35,550
alternately to the source but we want it

00:10:31,800 --> 00:10:37,470
to be like actual you know disbursement

00:10:35,550 --> 00:10:39,660
of it we actually want to be done in a

00:10:37,470 --> 00:10:41,400
public domain through github but there's

00:10:39,660 --> 00:10:42,720
a lot of licensing things that kind of

00:10:41,400 --> 00:10:44,910
go with that you got to do it all you

00:10:42,720 --> 00:10:46,740
know apache licenses and certificates of

00:10:44,910 --> 00:10:49,110
originality z' and things like that and

00:10:46,740 --> 00:10:50,610
they'll take time to get through the

00:10:49,110 --> 00:10:52,440
technical steering committee and then

00:10:50,610 --> 00:10:53,910
the board of directors to make sure

00:10:52,440 --> 00:10:55,560
everything's on the up-and-up we just

00:10:53,910 --> 00:10:57,600
don't want to throw it out there and get

00:10:55,560 --> 00:10:59,670
into some sort of legality problems but

00:10:57,600 --> 00:11:01,080
it's been all approved right we're very

00:10:59,670 --> 00:11:03,870
close to actually having it on that

00:11:01,080 --> 00:11:06,950
public domain for github now what we'll

00:11:03,870 --> 00:11:06,950
do I'm sorry good

00:11:15,670 --> 00:11:21,180
very good very good question so one of

00:11:18,730 --> 00:11:23,850
the things that we're doing is is that

00:11:21,180 --> 00:11:26,440
if you look at the Vivaro

00:11:23,850 --> 00:11:31,570
stuff that gets generated they put all

00:11:26,440 --> 00:11:34,600
sorts of Xilinx copyright and other

00:11:31,570 --> 00:11:37,030
legal statements into there's disclaimer

00:11:34,600 --> 00:11:39,220
is all that stuff we're working with

00:11:37,030 --> 00:11:41,170
Xilinx now to figure out the best way to

00:11:39,220 --> 00:11:42,340
kind of handle that one of the things

00:11:41,170 --> 00:11:45,310
that we've been doing is thinking about

00:11:42,340 --> 00:11:47,230
putting patch files on top of that zÃ i

00:11:45,310 --> 00:11:48,880
links has been pretty receptive to that

00:11:47,230 --> 00:11:50,740
but we're still kind of working out

00:11:48,880 --> 00:11:53,170
because that is that is something that

00:11:50,740 --> 00:11:54,670
we don't want to just willy-nilly throw

00:11:53,170 --> 00:11:57,550
it out there and then have Xilinx come

00:11:54,670 --> 00:11:59,380
back so under NDA I mean there's no

00:11:57,550 --> 00:12:02,010
problems with those kinds of things

00:11:59,380 --> 00:12:04,180
right that's all copacetic under NDA

00:12:02,010 --> 00:12:06,100
when you put it on in to the github

00:12:04,180 --> 00:12:07,780
mechanism that's where you got to be

00:12:06,100 --> 00:12:09,850
kind of careful you're right making sure

00:12:07,780 --> 00:12:12,700
that you know what's yours is yours and

00:12:09,850 --> 00:12:14,620
what's theirs is theirs and so we really

00:12:12,700 --> 00:12:17,470
making some good progress with that but

00:12:14,620 --> 00:12:21,700
we're working on that so does that

00:12:17,470 --> 00:12:23,110
answer your question yeah okay okay I

00:12:21,700 --> 00:12:25,150
mentioned this a little bit earlier

00:12:23,110 --> 00:12:26,770
right the config axis are all hidden

00:12:25,150 --> 00:12:28,480
from the AF you we want we don't want

00:12:26,770 --> 00:12:30,550
you to worry about that kind of stuff

00:12:28,480 --> 00:12:32,650
right we want you to focus on your

00:12:30,550 --> 00:12:42,190
accelerator not on the base building

00:12:32,650 --> 00:12:44,110
blocks no not not that part of it right

00:12:42,190 --> 00:12:46,870
it's just all the device discovery that

00:12:44,110 --> 00:12:48,610
the kernel actually has to do right that

00:12:46,870 --> 00:12:52,180
part of the mechanisms you still have to

00:12:48,610 --> 00:12:54,010
burn it that part of it but not not

00:12:52,180 --> 00:12:56,050
through like I program or once I

00:12:54,010 --> 00:12:58,240
programmed it right my config space is

00:12:56,050 --> 00:12:59,680
out of line it doesn't recognize it and

00:12:58,240 --> 00:13:04,570
then it just goes off into the weeds and

00:12:59,680 --> 00:13:05,950
you never get out of that loop we I mean

00:13:04,570 --> 00:13:07,360
there's a couple of different ways you

00:13:05,950 --> 00:13:10,390
can attack this but we're going to talk

00:13:07,360 --> 00:13:13,240
about actual the TLX to a fu interface

00:13:10,390 --> 00:13:14,740
right and that particular interface if

00:13:13,240 --> 00:13:16,930
you're familiar with what we did on cap

00:13:14,740 --> 00:13:18,490
you on dot o and cap e 2 dot o right

00:13:16,930 --> 00:13:20,380
it's a parallel there's a number of

00:13:18,490 --> 00:13:22,570
parallel interfaces there's four of them

00:13:20,380 --> 00:13:23,860
right how many people have actually

00:13:22,570 --> 00:13:25,270
downloaded the architecture

00:13:23,860 --> 00:13:28,360
specifications and started to look

00:13:25,270 --> 00:13:30,520
through them that's pretty good

00:13:28,360 --> 00:13:32,350
you know if you go through not so much

00:13:30,520 --> 00:13:34,600
that the DL specification but if you

00:13:32,350 --> 00:13:37,480
look at the TL specification there's a

00:13:34,600 --> 00:13:39,160
lot of I don't want to use the word

00:13:37,480 --> 00:13:41,200
complexity but you actually have to have

00:13:39,160 --> 00:13:44,260
to have an awareness of like virtual

00:13:41,200 --> 00:13:46,690
channels and templates and data credit

00:13:44,260 --> 00:13:48,520
pools and all this other stuff right

00:13:46,690 --> 00:13:50,770
well that's all fine and dandy if you're

00:13:48,520 --> 00:13:52,779
working in the bowels of what this what

00:13:50,770 --> 00:13:54,760
this animal is but we don't want the a

00:13:52,779 --> 00:13:57,220
fu developer to worry about that kind of

00:13:54,760 --> 00:14:01,660
stuff that's way too much detail right

00:13:57,220 --> 00:14:04,060
the idea is you know we want the TLX

00:14:01,660 --> 00:14:06,370
parser right to take the commands that

00:14:04,060 --> 00:14:08,770
are coming from the AFU and put it into

00:14:06,370 --> 00:14:10,270
the right fields right so the a fu

00:14:08,770 --> 00:14:12,459
developer doesn't have to worry about it

00:14:10,270 --> 00:14:14,770
he doesn't know about templates he

00:14:12,459 --> 00:14:16,750
doesn't know about virtual channels he

00:14:14,770 --> 00:14:18,910
doesn't worry about data credit pools in

00:14:16,750 --> 00:14:20,800
the intrinsic sense of looking at it

00:14:18,910 --> 00:14:21,880
from the specification he doesn't have

00:14:20,800 --> 00:14:23,680
to worry about that

00:14:21,880 --> 00:14:25,870
so there's separate command and response

00:14:23,680 --> 00:14:28,990
interfaces for those virtual channels

00:14:25,870 --> 00:14:30,820
right you can actually send one command

00:14:28,990 --> 00:14:33,279
per cycle on each interface to the a of

00:14:30,820 --> 00:14:36,040
you and then there's a separate data

00:14:33,279 --> 00:14:37,959
interface as well when you actually get

00:14:36,040 --> 00:14:39,520
to the point for doing implementation in

00:14:37,959 --> 00:14:41,740
the reference design and I've heard this

00:14:39,520 --> 00:14:43,120
feedback multiple times one of the

00:14:41,740 --> 00:14:45,310
things that you actually have to there's

00:14:43,120 --> 00:14:46,720
a couple of things to be aware of so

00:14:45,310 --> 00:14:49,570
when a command comes down like a mem

00:14:46,720 --> 00:14:51,910
right for instance right the memory

00:14:49,570 --> 00:14:54,160
won't actually be initiated to the AFU

00:14:51,910 --> 00:14:56,770
until the data is actually in the TLX as

00:14:54,160 --> 00:14:58,089
well right but the thing you have to

00:14:56,770 --> 00:15:01,029
remember is you actually have to pull

00:14:58,089 --> 00:15:03,250
the data and it doesn't get pushed right

00:15:01,029 --> 00:15:04,690
that's that's a subtlety that so people

00:15:03,250 --> 00:15:06,339
are they kind of scratch their head

00:15:04,690 --> 00:15:07,810
about well why'd you do it that way well

00:15:06,339 --> 00:15:09,610
it turned out to be a simple

00:15:07,810 --> 00:15:13,089
simplification when we did it for

00:15:09,610 --> 00:15:14,170
ourselves the other thing to kind of

00:15:13,089 --> 00:15:16,810
keep in mind and I'm not sure if I

00:15:14,170 --> 00:15:18,760
necessarily mentioned this earlier when

00:15:16,810 --> 00:15:21,430
somebody joins the consortium and then

00:15:18,760 --> 00:15:24,990
joins the enablement workgroup this

00:15:21,430 --> 00:15:28,870
reference design and the exercisers

00:15:24,990 --> 00:15:30,640
that's you get a license to use them but

00:15:28,870 --> 00:15:33,010
that doesn't mean you can't like change

00:15:30,640 --> 00:15:35,140
them right so if there's something that

00:15:33,010 --> 00:15:37,000
you don't like you want to enhance it

00:15:35,140 --> 00:15:39,699
you want to add additional buffers if

00:15:37,000 --> 00:15:42,190
you don't like our pipelining whatever

00:15:39,699 --> 00:15:45,700
you're free to make those changes

00:15:42,190 --> 00:15:48,460
it's yours right if you like our DMA

00:15:45,700 --> 00:15:50,170
engines inside of our memcache sizer and

00:15:48,460 --> 00:15:51,580
you want to steal it for lack of a

00:15:50,170 --> 00:15:54,670
better word and use it in your own

00:15:51,580 --> 00:15:56,830
design by all means it's yours right all

00:15:54,670 --> 00:15:58,780
the design is yours so you have a

00:15:56,830 --> 00:16:01,000
license to not only productize behind it

00:15:58,780 --> 00:16:03,460
but you also have the ability to take it

00:16:01,000 --> 00:16:05,710
and use it at your disposal so we want

00:16:03,460 --> 00:16:08,350
to treat this as kind of an open open

00:16:05,710 --> 00:16:14,140
source kind of format right so use our

00:16:08,350 --> 00:16:16,750
wisdom if you want right um let's see

00:16:14,140 --> 00:16:19,120
here yeah again this is kind of just a

00:16:16,750 --> 00:16:21,760
reaffirmation of what I said earlier you

00:16:19,120 --> 00:16:23,860
know the the transaction layer the data

00:16:21,760 --> 00:16:26,050
link layer right it does all the packet

00:16:23,860 --> 00:16:28,720
icing right it does the most efficient

00:16:26,050 --> 00:16:30,160
packet izing of the format of Flitz that

00:16:28,720 --> 00:16:32,080
your the formatted commands that you're

00:16:30,160 --> 00:16:36,640
sending it so yeah alright it supports

00:16:32,080 --> 00:16:38,770
templates I think zero one and three

00:16:36,640 --> 00:16:40,210
right and it's based on what the slots

00:16:38,770 --> 00:16:42,070
of commands that you're using right

00:16:40,210 --> 00:16:43,540
there's two slot there's four slot right

00:16:42,070 --> 00:16:44,800
it's gonna pick the template that's the

00:16:43,540 --> 00:16:46,570
most efficient for what you're doing

00:16:44,800 --> 00:16:48,250
right but then you actually don't have

00:16:46,570 --> 00:16:50,710
to worry about the other complexities of

00:16:48,250 --> 00:16:51,790
doing sending bookend Searcy's and all

00:16:50,710 --> 00:16:53,650
that other stuff you're worried about

00:16:51,790 --> 00:16:55,090
your accelerator you don't want to worry

00:16:53,650 --> 00:17:01,450
about all this pipelining and all this

00:16:55,090 --> 00:17:02,920
plumbing that's underneath it all right

00:17:01,450 --> 00:17:05,050
I kind of mentioned a lot of this

00:17:02,920 --> 00:17:08,709
earlier so what I did here was I just

00:17:05,050 --> 00:17:11,380
took some snippets and bi and where this

00:17:08,709 --> 00:17:13,449
is that there's actually a as part of

00:17:11,380 --> 00:17:15,790
what we deliver the in the enablement

00:17:13,449 --> 00:17:17,620
workgroup or under NDA there's something

00:17:15,790 --> 00:17:20,410
called the TLX 3.0 reference

00:17:17,620 --> 00:17:22,390
specification right it does a very nice

00:17:20,410 --> 00:17:23,949
job of kind of showing the different

00:17:22,390 --> 00:17:27,640
components it shows you the different

00:17:23,949 --> 00:17:29,860
levels it'll show you the data flow and

00:17:27,640 --> 00:17:31,300
then it also gives you all of the

00:17:29,860 --> 00:17:34,030
different interfaces that your

00:17:31,300 --> 00:17:35,650
accelerator has to bolt on to and as you

00:17:34,030 --> 00:17:38,680
can see for this one this is like a host

00:17:35,650 --> 00:17:40,990
to accelerator command interface I mean

00:17:38,680 --> 00:17:43,240
this is very very simplistic parallel

00:17:40,990 --> 00:17:47,350
interface there's a valid there's an

00:17:43,240 --> 00:17:48,790
opcode what the cap tag looks like if

00:17:47,350 --> 00:17:51,970
there's a physical address if you're

00:17:48,790 --> 00:17:54,370
doing home agent or LPC mode what the

00:17:51,970 --> 00:17:55,960
size of it is what the size of it if

00:17:54,370 --> 00:17:58,000
it's a partial

00:17:55,960 --> 00:18:00,250
I mean if you're an HDL designer right

00:17:58,000 --> 00:18:01,720
and Brunel our next talk all right he's

00:18:00,250 --> 00:18:05,290
guys she got a framework that he's going

00:18:01,720 --> 00:18:07,750
to talk about you know at the next talk

00:18:05,290 --> 00:18:09,760
here and another half-hour or so or 15

00:18:07,750 --> 00:18:12,030
minutes or so right this is meant for

00:18:09,760 --> 00:18:15,790
guys that are writing at the HDL level

00:18:12,030 --> 00:18:16,930
right guys are doing very larger VHDL oh

00:18:15,790 --> 00:18:18,940
by the way I didn't even mention this

00:18:16,930 --> 00:18:22,480
before all of our reference design is

00:18:18,940 --> 00:18:24,730
written in Vera log okay

00:18:22,480 --> 00:18:27,250
the host date the host to a a few data

00:18:24,730 --> 00:18:30,280
snippet right we got a data valid and

00:18:27,250 --> 00:18:31,930
this is again why I mention it and most

00:18:30,280 --> 00:18:34,780
people get a little confused by this the

00:18:31,930 --> 00:18:37,390
AF you actually has to pull the data

00:18:34,780 --> 00:18:40,360
down so he sends a request up and then

00:18:37,390 --> 00:18:42,640
the AF you will come back with a valid

00:18:40,360 --> 00:18:44,860
the bus well there's a bad day to enter

00:18:42,640 --> 00:18:48,340
key indicator things of that nature you

00:18:44,860 --> 00:18:50,430
know very simplistic and then on the AF

00:18:48,340 --> 00:18:54,670
you initiate a command and data snippets

00:18:50,430 --> 00:18:56,800
valid opcode AC tag object handles a fu

00:18:54,670 --> 00:18:59,260
tag I mean things that are very

00:18:56,800 --> 00:19:01,510
simplistic in nature right like I said

00:18:59,260 --> 00:19:03,490
you can do one command per cycle so you

00:19:01,510 --> 00:19:05,560
can brick-like or pipeline to thing

00:19:03,490 --> 00:19:08,230
right so it could all be back to back to

00:19:05,560 --> 00:19:09,790
back back obviously there's a credit

00:19:08,230 --> 00:19:11,410
interface associated with that so you

00:19:09,790 --> 00:19:13,810
only can go as fast as the credits will

00:19:11,410 --> 00:19:15,490
allow you so between the TLX nei if you

00:19:13,810 --> 00:19:17,170
there's a credit-based interface to love

00:19:15,490 --> 00:19:19,690
to let you know how many credits you

00:19:17,170 --> 00:19:23,260
have outstanding so you can kind of

00:19:19,690 --> 00:19:26,680
manage what your pipelines look like any

00:19:23,260 --> 00:19:29,860
questions so far too fast too slow right

00:19:26,680 --> 00:19:32,050
pace right I'm kind of fired hosing you

00:19:29,860 --> 00:19:33,670
with information but you know obviously

00:19:32,050 --> 00:19:39,910
this is just a first level introduction

00:19:33,670 --> 00:19:41,650
and okay so initially when we started

00:19:39,910 --> 00:19:43,330
with this in a lab our our friends from

00:19:41,650 --> 00:19:45,880
alpha data in the back of the room right

00:19:43,330 --> 00:19:47,860
we started with their 9b3 card they're

00:19:45,880 --> 00:19:51,520
the first ones to basically put the open

00:19:47,860 --> 00:19:53,950
capi connector on their FPGA card it was

00:19:51,520 --> 00:19:56,830
a vertex ultra scale plus series 3

00:19:53,950 --> 00:19:58,660
device right and that's what we did all

00:19:56,830 --> 00:20:00,820
of our processor validation on so if you

00:19:58,660 --> 00:20:02,800
look at the exercisers that we actually

00:20:00,820 --> 00:20:04,570
give to the consortium there are the

00:20:02,800 --> 00:20:07,360
same exercisers that we used in our

00:20:04,570 --> 00:20:09,820
processor validation exactly right so

00:20:07,360 --> 00:20:11,620
when we run grub in the lab right

00:20:09,820 --> 00:20:13,840
which is one of our main exercisers we

00:20:11,620 --> 00:20:16,720
run it against these exercisers for its

00:20:13,840 --> 00:20:20,020
same ones you know we're using the

00:20:16,720 --> 00:20:22,990
latest Roboto 20 18.2 if you look at

00:20:20,020 --> 00:20:24,970
this particular diagram was done with 20

00:20:22,990 --> 00:20:25,830
17.1 but you get the spirit of what

00:20:24,970 --> 00:20:27,760
we're doing

00:20:25,830 --> 00:20:30,100
miron kind of mentioned this earlier

00:20:27,760 --> 00:20:32,980
this morning one of the reasons that we

00:20:30,100 --> 00:20:35,470
got off of PCI Express was whether we

00:20:32,980 --> 00:20:38,860
like it or not the big animal in the

00:20:35,470 --> 00:20:40,270
room with PCI Express is Intel the

00:20:38,860 --> 00:20:43,240
industry's only going to go as fast as

00:20:40,270 --> 00:20:46,390
Intel wants it to go right if you really

00:20:43,240 --> 00:20:48,160
want to target AI which I consider it's

00:20:46,390 --> 00:20:49,780
actionable intelligence not necessarily

00:20:48,160 --> 00:20:53,020
artificial intelligence but actionable

00:20:49,780 --> 00:20:54,610
intelligence if you want to target to

00:20:53,020 --> 00:20:58,450
the networking speeds that are going up

00:20:54,610 --> 00:21:01,060
like crazy 100 200 400 right we're still

00:20:58,450 --> 00:21:02,230
sitting on Gen 3 right 13 years later

00:21:01,060 --> 00:21:04,090
right

00:21:02,230 --> 00:21:06,130
so most of the industry is still

00:21:04,090 --> 00:21:08,500
studying at Gen 3 where the first ones

00:21:06,130 --> 00:21:10,480
to go to Gen 4 but we we basically said

00:21:08,500 --> 00:21:13,270
we need to take our own path if you look

00:21:10,480 --> 00:21:14,950
at open Cappy the Phi is actually the

00:21:13,270 --> 00:21:17,560
same thighs that we use for env link

00:21:14,950 --> 00:21:20,680
exact same Phi it's a 28 gig short reach

00:21:17,560 --> 00:21:22,390
standard same exact Phi the protocols

00:21:20,680 --> 00:21:25,000
are obviously different right because

00:21:22,390 --> 00:21:27,250
the env link protocol is proprietary

00:21:25,000 --> 00:21:28,750
between the two companies but what we

00:21:27,250 --> 00:21:29,890
did like myron mentioned was as we

00:21:28,750 --> 00:21:32,230
started with a clean sheet of paper

00:21:29,890 --> 00:21:33,460
clean sheet of paper we want to make

00:21:32,230 --> 00:21:35,890
sure that we could hit you know

00:21:33,460 --> 00:21:37,570
bandwidth of 25 gigabytes

00:21:35,890 --> 00:21:40,420
we wanted to make sure that could be the

00:21:37,570 --> 00:21:42,850
lowest latency possible the problem with

00:21:40,420 --> 00:21:44,260
PCIe and granted it's it's the main

00:21:42,850 --> 00:21:46,330
installation out in the world they owned

00:21:44,260 --> 00:21:50,890
probably 95% of the market as far as a

00:21:46,330 --> 00:21:52,570
connection media is that it's it's a

00:21:50,890 --> 00:21:54,400
little bloated right it's got a lot of

00:21:52,570 --> 00:21:57,820
backwards compatibility it's got support

00:21:54,400 --> 00:21:59,800
Gen 1 Jen - Jen 3x1 love 2 by 16 it's

00:21:57,820 --> 00:22:01,330
got all this power management stuff but

00:21:59,800 --> 00:22:04,180
if you look at you know what a

00:22:01,330 --> 00:22:06,460
transceiver looks like right with PCI

00:22:04,180 --> 00:22:09,010
Express and FPGA let's say for like 400

00:22:06,460 --> 00:22:11,050
mega or 400 nano seconds these that

00:22:09,010 --> 00:22:12,790
latency is it's a hard starting point

00:22:11,050 --> 00:22:13,840
right what you're gonna find out and

00:22:12,790 --> 00:22:15,160
we'll show it here in a few minutes is

00:22:13,840 --> 00:22:20,140
some of whatever our performance numbers

00:22:15,160 --> 00:22:23,800
look like so our reference design right

00:22:20,140 --> 00:22:28,810
for open cap e 3.0 right this is our

00:22:23,800 --> 00:22:31,510
design 43.0 not 3.1 what's 3.0 we use

00:22:28,810 --> 00:22:34,780
around 5% of the resources so it's very

00:22:31,510 --> 00:22:37,840
thin right the other 95% is for you to

00:22:34,780 --> 00:22:39,490
do your accelerator development on right

00:22:37,840 --> 00:22:41,740
obviously as we add some more

00:22:39,490 --> 00:22:43,380
complexities into 4.0 and some other

00:22:41,740 --> 00:22:46,600
things like that those sizes will grow

00:22:43,380 --> 00:22:49,660
but it's about 5% of the resources now

00:22:46,600 --> 00:22:52,390
we've used to FPGAs primarily in the lab

00:22:49,660 --> 00:22:54,280
today the one is the vertex ultra scale

00:22:52,390 --> 00:22:58,270
series 3 family and then the Kintex

00:22:54,280 --> 00:23:00,610
ultra scale 15 series but we're also

00:22:58,270 --> 00:23:03,490
working on the zinc ultra scale 19th

00:23:00,610 --> 00:23:05,350
we've got a program that we're working

00:23:03,490 --> 00:23:07,600
on with storage class memories that are

00:23:05,350 --> 00:23:09,310
using that particular part and then

00:23:07,600 --> 00:23:11,590
there's some new pretty exciting cards

00:23:09,310 --> 00:23:14,650
coming out very soon from alpha data and

00:23:11,590 --> 00:23:16,420
a low tech alpha data has got there 9 8

00:23:14,650 --> 00:23:18,190
7 if you go out to the open Cappy booth

00:23:16,420 --> 00:23:20,020
there's there's a version out there

00:23:18,190 --> 00:23:23,140
underneath some plexiglass it's got the

00:23:20,020 --> 00:23:25,570
vu 37 P on it with HB m right that's the

00:23:23,140 --> 00:23:29,500
biggest baddest FPGA you can find it's

00:23:25,570 --> 00:23:32,290
got 4 Q SFP ports HB m 4 gig right

00:23:29,500 --> 00:23:34,420
that's the biggest I mean a4 HPC space

00:23:32,290 --> 00:23:35,980
that that guy is a killer and then

00:23:34,420 --> 00:23:38,890
they're gonna have a 9 h3 board or the

00:23:35,980 --> 00:23:41,020
vu 33 on it and then ala Tech has

00:23:38,890 --> 00:23:43,540
another implementation out there called

00:23:41,020 --> 00:23:46,120
a 250 SOC which as a zinc part as well

00:23:43,540 --> 00:23:48,760
right right and there's some really cool

00:23:46,120 --> 00:23:51,370
idea so if you come to the booth we've

00:23:48,760 --> 00:23:54,610
got a card plugged into the system into

00:23:51,370 --> 00:23:56,440
a mihawk from West Ron and what that

00:23:54,610 --> 00:23:59,500
does is there's some really cool ideas

00:23:56,440 --> 00:24:01,360
about having dense nvm ease in servers

00:23:59,500 --> 00:24:05,200
using that particular card so come out

00:24:01,360 --> 00:24:08,230
and take a look like I said we've got

00:24:05,200 --> 00:24:11,650
three particular exerciser examples that

00:24:08,230 --> 00:24:13,390
you're free to use at your disposal mem

00:24:11,650 --> 00:24:15,490
copy is one of them it's just basically

00:24:13,390 --> 00:24:16,990
a data mover if you give it a sort

00:24:15,490 --> 00:24:19,690
there's a source address a destination

00:24:16,990 --> 00:24:24,160
address there's a work queue for each

00:24:19,690 --> 00:24:27,090
context we support 512 contexts in this

00:24:24,160 --> 00:24:29,260
particular example it's got 32 engines

00:24:27,090 --> 00:24:31,300
which is configurable you can go

00:24:29,260 --> 00:24:33,310
anywhere I think from 4 engines the 32

00:24:31,300 --> 00:24:36,370
engines the hope timing closure go

00:24:33,310 --> 00:24:37,700
easier you know it supports up to 2k

00:24:36,370 --> 00:24:41,539
transfers using these

00:24:37,700 --> 00:24:43,460
particular payload sizes up to 256 bytes

00:24:41,539 --> 00:24:46,789
which is our maximum payload size for

00:24:43,460 --> 00:24:48,230
open Cappy it's got an AC tag table for

00:24:46,789 --> 00:24:50,320
folks that are familiar with what you

00:24:48,230 --> 00:24:52,580
have to do with an AC assigned AC tag

00:24:50,320 --> 00:24:54,769
and it's got to config block and the

00:24:52,580 --> 00:24:57,019
register space right which is you know

00:24:54,769 --> 00:24:59,690
what we have for all of them we've got a

00:24:57,019 --> 00:25:01,730
memory home agent exerciser for folks

00:24:59,690 --> 00:25:03,320
we've kind of used the vernacular back

00:25:01,730 --> 00:25:05,059
and forth sometimes you'll hear people

00:25:03,320 --> 00:25:07,519
call call it memory home agents some

00:25:05,059 --> 00:25:11,600
people call LPC lowest point of

00:25:07,519 --> 00:25:16,100
coherency again it does sparse address

00:25:11,600 --> 00:25:18,409
mapping it only uses the memory elements

00:25:16,100 --> 00:25:22,010
internal to the FPGA it doesn't use any

00:25:18,409 --> 00:25:24,019
ddr in this particular example but it

00:25:22,010 --> 00:25:25,789
allows you to do you know one mega of

00:25:24,019 --> 00:25:27,649
real address space to four terabytes a

00:25:25,789 --> 00:25:29,360
real address space and it takes

00:25:27,649 --> 00:25:31,429
advantage of what we call memory home

00:25:29,360 --> 00:25:33,080
agent so what that what that does is the

00:25:31,429 --> 00:25:35,059
memory home agent that's off of the

00:25:33,080 --> 00:25:38,179
accelerator is now coherent with the

00:25:35,059 --> 00:25:40,039
rest of the memory within the caches and

00:25:38,179 --> 00:25:42,980
system memory right because it's all one

00:25:40,039 --> 00:25:43,990
unified virtual address space Myron

00:25:42,980 --> 00:25:48,139
mentioned it this morning

00:25:43,990 --> 00:25:51,529
capi 1.0 2.0 open copy it's all running

00:25:48,139 --> 00:25:53,450
in userspace right there's no copying

00:25:51,529 --> 00:25:56,659
back and forth between kernel space and

00:25:53,450 --> 00:25:59,480
user space right so the the software

00:25:56,659 --> 00:26:01,250
path length is very minimal compared if

00:25:59,480 --> 00:26:02,929
you're using a traditional device driver

00:26:01,250 --> 00:26:05,659
right that's one of the big advantages

00:26:02,929 --> 00:26:09,470
of our what we do with our coherent

00:26:05,659 --> 00:26:11,779
accelerator versus others and then we

00:26:09,470 --> 00:26:13,820
also provide an AFP exerciser this is

00:26:11,779 --> 00:26:15,769
the one where we basically say okay

00:26:13,820 --> 00:26:18,230
what's the maximum bandwidth that we can

00:26:15,769 --> 00:26:20,450
achieve on this particular bus right so

00:26:18,230 --> 00:26:23,090
we'll streamed EMA's stores and loads

00:26:20,450 --> 00:26:24,529
and then measure the bandwidth and then

00:26:23,090 --> 00:26:26,360
we actually give you the ability to

00:26:24,529 --> 00:26:27,669
actually measure those those types of

00:26:26,360 --> 00:26:31,090
things

00:26:27,669 --> 00:26:35,470
any questions so far

00:26:31,090 --> 00:26:35,470
all right how am i doing that thing

00:26:38,830 --> 00:26:42,710
temperament okay all right so I want to

00:26:41,330 --> 00:26:44,900
kind of give you a historical and

00:26:42,710 --> 00:26:48,140
current level of perspective of where we

00:26:44,900 --> 00:26:50,990
started with Capuano 2.0 and 3.0 you

00:26:48,140 --> 00:26:52,610
know we started doing acceleration

00:26:50,990 --> 00:26:56,540
coherent acceleration with power rate

00:26:52,610 --> 00:26:59,150
with capi 1.0 used to be kind of very

00:26:56,540 --> 00:27:01,280
transparent we actually had a problem

00:26:59,150 --> 00:27:03,200
with Capuano we didn't have enough

00:27:01,280 --> 00:27:05,480
engines cap engines within our

00:27:03,200 --> 00:27:07,310
microprocessor to achieve the bandwidth

00:27:05,480 --> 00:27:08,960
that we should have right if we were

00:27:07,310 --> 00:27:10,760
running at gen 3 by eight at eight

00:27:08,960 --> 00:27:12,530
gigabit we should have been seeing

00:27:10,760 --> 00:27:14,300
probably a little bit north of seven

00:27:12,530 --> 00:27:17,780
gigabytes and that particular

00:27:14,300 --> 00:27:20,120
implementation we only had 32 engines in

00:27:17,780 --> 00:27:21,530
the microprocessor design so that's why

00:27:20,120 --> 00:27:23,690
you see the bandwidth so our maximum

00:27:21,530 --> 00:27:26,510
cache line or a maximum payload size

00:27:23,690 --> 00:27:28,430
back then was 128 bytes and those are

00:27:26,510 --> 00:27:31,010
the band widths that we achieved we

00:27:28,430 --> 00:27:33,710
learned from that made a number of

00:27:31,010 --> 00:27:36,260
significant changes for capi 2.0 and

00:27:33,710 --> 00:27:38,420
power 9 which runs at Gen 4 by 8 which

00:27:36,260 --> 00:27:42,590
is 16 gigabit and so now I think there's

00:27:38,420 --> 00:27:45,350
a hundred and ninety-two engines and now

00:27:42,590 --> 00:27:47,540
we're seeing anywhere from let's call it

00:27:45,350 --> 00:27:50,810
twelve and a half to fourteen gigabytes

00:27:47,540 --> 00:27:52,220
per second so not 100% on par but a hell

00:27:50,810 --> 00:27:54,470
of a lot better than it was before so

00:27:52,220 --> 00:27:57,560
that's that's very intriguing well we

00:27:54,470 --> 00:27:59,240
want to open cap III dot o running at a

00:27:57,560 --> 00:28:00,890
twenty five gigabit signaling rate right

00:27:59,240 --> 00:28:02,930
we're we're achieving a little bit north

00:28:00,890 --> 00:28:04,490
of twenty two gigabytes per second which

00:28:02,930 --> 00:28:07,970
is exactly where we want to be if you

00:28:04,490 --> 00:28:10,280
look at the number of payload bus versus

00:28:07,970 --> 00:28:12,500
header and CRC it's eight nine

00:28:10,280 --> 00:28:13,730
sufficient right so we're basically on

00:28:12,500 --> 00:28:16,160
target where we want to be and we've

00:28:13,730 --> 00:28:18,950
seen this on both of those devices the

00:28:16,160 --> 00:28:24,620
vertex ultra scale three and the context

00:28:18,950 --> 00:28:27,950
sixty so you know it's it's been doing

00:28:24,620 --> 00:28:30,800
very well the next one I want to kind of

00:28:27,950 --> 00:28:34,040
show you is we did a targeted test case

00:28:30,800 --> 00:28:36,590
this actually came from an HF T type you

00:28:34,040 --> 00:28:37,760
know partner they wanted to try and

00:28:36,590 --> 00:28:41,240
understand because these guys are very

00:28:37,760 --> 00:28:46,240
latency sensitive if they did a copy of

00:28:41,240 --> 00:28:50,360
a 512 byte mm IO from the cash into FPGA

00:28:46,240 --> 00:28:51,410
right and then did an l3 cache injection

00:28:50,360 --> 00:28:54,470
of 100

00:28:51,410 --> 00:28:56,240
28 bytes right and then just repeated

00:28:54,470 --> 00:28:59,660
that a thousand times

00:28:56,240 --> 00:29:01,760
what would your latency be right this is

00:28:59,660 --> 00:29:03,710
an H ft test case this is how they kind

00:29:01,760 --> 00:29:06,710
of benchmark people is this is something

00:29:03,710 --> 00:29:09,650
that they're very interested in we did a

00:29:06,710 --> 00:29:11,990
comparison between p9 open copy and just

00:29:09,650 --> 00:29:14,210
to be transparent with ourselves we did

00:29:11,990 --> 00:29:17,480
something we did the same thing with PCI

00:29:14,210 --> 00:29:19,790
Express Gen 4 power 9 is PCI Express

00:29:17,480 --> 00:29:23,470
gen3 and then we took a cab u leik

00:29:19,790 --> 00:29:25,880
processor from Intel running at Gen 3

00:29:23,470 --> 00:29:27,680
now there's a couple of interesting

00:29:25,880 --> 00:29:30,320
things to kind of be aware of we're

00:29:27,680 --> 00:29:32,990
start at the bottom now if you look at

00:29:30,320 --> 00:29:35,660
the TLX DLX phi turnaround time in that

00:29:32,990 --> 00:29:37,760
use case it's 80 nanoseconds in an FPGA

00:29:35,660 --> 00:29:40,250
right you can do significantly better

00:29:37,760 --> 00:29:43,000
than ASIC but it's 80 nanoseconds at an

00:29:40,250 --> 00:29:45,590
FPGA that's pretty pretty outstanding

00:29:43,000 --> 00:29:47,660
now when you start to get into things

00:29:45,590 --> 00:29:49,610
where you're counting on Xilinx is hard

00:29:47,660 --> 00:29:51,170
IP things get a little bit more

00:29:49,610 --> 00:29:53,120
challenging right it makes it very

00:29:51,170 --> 00:29:56,090
convenient to use but it's not

00:29:53,120 --> 00:29:57,470
necessarily optimized for latency so

00:29:56,090 --> 00:30:00,020
what you're going to find out is the

00:29:57,470 --> 00:30:03,470
Xilinx PCI Express hard IP for Gen 4 is

00:30:00,020 --> 00:30:06,710
218 and then for Gen 3 whether it's in

00:30:03,470 --> 00:30:09,590
El Terra or this one's altaira it's 400

00:30:06,710 --> 00:30:11,210
nanoseconds right so you get a lot of

00:30:09,590 --> 00:30:13,820
bang for your buck when you start to

00:30:11,210 --> 00:30:16,070
take all of those five layers right and

00:30:13,820 --> 00:30:18,320
use it at the transceiver level versus

00:30:16,070 --> 00:30:21,770
County on hardened IP that actually has

00:30:18,320 --> 00:30:23,510
a you know some bloat to it if you look

00:30:21,770 --> 00:30:25,460
at the latency comparisons between what

00:30:23,510 --> 00:30:28,520
we got with open capya on p9 versus a

00:30:25,460 --> 00:30:32,870
cab you Lake running at Gen 3 we're at

00:30:28,520 --> 00:30:36,890
378 nanoseconds vs. 776 nanoseconds on

00:30:32,870 --> 00:30:38,960
an Intel processor right when the hft

00:30:36,890 --> 00:30:41,420
guys see things like that that starts to

00:30:38,960 --> 00:30:43,400
grab their attention because nanoseconds

00:30:41,420 --> 00:30:45,470
to an hft guy means dollars and cents

00:30:43,400 --> 00:30:48,050
right because every time you make a

00:30:45,470 --> 00:30:50,900
decision you wait like this the dollars

00:30:48,050 --> 00:30:54,910
change or the cents change right the

00:30:50,900 --> 00:30:57,710
other thing that's I think is also very

00:30:54,910 --> 00:31:00,170
important is jitter right if your

00:30:57,710 --> 00:31:02,900
answers aren't very deterministic right

00:31:00,170 --> 00:31:04,820
that's not the greatest thing either so

00:31:02,900 --> 00:31:05,240
well in this same test case we actually

00:31:04,820 --> 00:31:07,610
when we

00:31:05,240 --> 00:31:10,130
a thousand times right there's two

00:31:07,610 --> 00:31:12,140
nanoseconds of jitter associated with

00:31:10,130 --> 00:31:14,750
this test case right so you basically

00:31:12,140 --> 00:31:17,150
get the same answer you know every time

00:31:14,750 --> 00:31:18,740
within two nanoseconds when you're when

00:31:17,150 --> 00:31:20,300
you ran the same test case on an Intel

00:31:18,740 --> 00:31:22,970
processor it turned out to be 31

00:31:20,300 --> 00:31:25,120
nanoseconds that's kind of a long time

00:31:22,970 --> 00:31:27,170
right but it's something to consider

00:31:25,120 --> 00:31:32,060
right those are the metrics that people

00:31:27,170 --> 00:31:34,790
are very interested in okay we talked a

00:31:32,060 --> 00:31:37,280
little bit about this this morning

00:31:34,790 --> 00:31:40,370
you know we've got power nine that were

00:31:37,280 --> 00:31:42,970
GA today we're working get it we're

00:31:40,370 --> 00:31:45,160
working on our p9 prime system or

00:31:42,970 --> 00:31:48,500
processor development right now

00:31:45,160 --> 00:31:50,270
sometimes you'll hear it called axon

00:31:48,500 --> 00:31:53,390
you know that's with open Kappa for dot

00:31:50,270 --> 00:31:55,340
oh you know I encourage you right I mean

00:31:53,390 --> 00:31:57,710
you can actually just go out there and

00:31:55,340 --> 00:31:59,900
just register on the open Cappy website

00:31:57,710 --> 00:32:02,270
and download the specifications to get

00:31:59,900 --> 00:32:03,950
familiar with them the three dot o and

00:32:02,270 --> 00:32:07,070
three dot ones were our initial

00:32:03,950 --> 00:32:09,110
contributions obviously the work groups

00:32:07,070 --> 00:32:11,300
are doing reviews all those

00:32:09,110 --> 00:32:13,640
specifications and making updates when

00:32:11,300 --> 00:32:15,740
they get finalized then the academia

00:32:13,640 --> 00:32:17,030
work group gets the final specifications

00:32:15,740 --> 00:32:20,210
they don't get the interim ones but they

00:32:17,030 --> 00:32:22,040
get the final ones but the four dot o

00:32:20,210 --> 00:32:24,980
that we've also posted is pretty far

00:32:22,040 --> 00:32:28,940
along it's very mature right and we and

00:32:24,980 --> 00:32:30,410
we basically got a lot of influence from

00:32:28,940 --> 00:32:32,570
our partners to say you need to get this

00:32:30,410 --> 00:32:34,190
out there because there's a lot of folks

00:32:32,570 --> 00:32:37,040
that are very interested in four dot Oh

00:32:34,190 --> 00:32:38,750
a couple of different reasons

00:32:37,040 --> 00:32:42,890
oops I'm sorry one of the reasons is

00:32:38,750 --> 00:32:45,650
that we support posted transactions just

00:32:42,890 --> 00:32:47,780
like you do in PCI Express and open

00:32:45,650 --> 00:32:49,310
Cappy for dot o and so we're working

00:32:47,780 --> 00:32:51,020
with a number of different partners

00:32:49,310 --> 00:32:52,610
we're posted transactions are very

00:32:51,020 --> 00:32:55,820
important so they're going to take

00:32:52,610 --> 00:32:57,530
advantage of that we're also having a

00:32:55,820 --> 00:33:00,110
lot of dialogues with folks doing

00:32:57,530 --> 00:33:01,640
storage class memories and there's some

00:33:00,110 --> 00:33:06,590
technology previews with some good

00:33:01,640 --> 00:33:08,390
partners like RAM buses here Ken writes

00:33:06,590 --> 00:33:09,830
here so you know we've got a number of

00:33:08,390 --> 00:33:11,570
partners you know if you want to talk

00:33:09,830 --> 00:33:13,430
about some storage class memory type of

00:33:11,570 --> 00:33:14,450
things on open Cappy Ken would be more

00:33:13,430 --> 00:33:18,200
than willing to have that discussion

00:33:14,450 --> 00:33:19,130
with you all right table men of

00:33:18,200 --> 00:33:20,780
enablement or

00:33:19,130 --> 00:33:22,940
yeah in a moment deliveries so this is

00:33:20,780 --> 00:33:25,910
everything that you get when you become

00:33:22,940 --> 00:33:28,130
a part of the enablement workgroup so

00:33:25,910 --> 00:33:29,630
it's the items the delivery name where

00:33:28,130 --> 00:33:31,040
to obtain it and when it's available

00:33:29,630 --> 00:33:34,210
you're going to see everything is

00:33:31,040 --> 00:33:39,140
available today right

00:33:34,210 --> 00:33:41,090
not 3.1 reference design okay but we're

00:33:39,140 --> 00:33:44,090
having discussions about making that

00:33:41,090 --> 00:33:47,330
happen it's just a little too early yeah

00:33:44,090 --> 00:33:49,430
huh not even under a idea yet it's not

00:33:47,330 --> 00:33:52,270
because of that because we're actively

00:33:49,430 --> 00:33:55,130
working it ourselves to be transparent

00:33:52,270 --> 00:33:57,260
the reference design right which we

00:33:55,130 --> 00:33:57,530
basically tarball up in gzip and deliver

00:33:57,260 --> 00:34:00,050
it

00:33:57,530 --> 00:34:02,750
the Vlado project flow that we exactly

00:34:00,050 --> 00:34:04,460
use it's a mirror of what we got the

00:34:02,750 --> 00:34:07,370
device discovery and configuration

00:34:04,460 --> 00:34:10,429
specification RTL the AF you interface

00:34:07,370 --> 00:34:11,960
specification the five signaling

00:34:10,429 --> 00:34:14,179
specification which comes out of the

00:34:11,960 --> 00:34:15,590
five signaling workgroup the mechanical

00:34:14,179 --> 00:34:18,379
specification which comes out of the

00:34:15,590 --> 00:34:20,720
other mechanical or yeah the mechanical

00:34:18,379 --> 00:34:21,860
work group we have a simulation

00:34:20,720 --> 00:34:23,960
environment that allows you to

00:34:21,860 --> 00:34:26,510
co-simulation between your application

00:34:23,960 --> 00:34:28,310
and your accelerator it's just to make

00:34:26,510 --> 00:34:30,139
sure that you don't do anything what's

00:34:28,310 --> 00:34:34,879
called uncombed copacetic with the

00:34:30,139 --> 00:34:36,320
interface and allows you to do your your

00:34:34,879 --> 00:34:38,090
application development and your

00:34:36,320 --> 00:34:40,190
accelerative element in simulation

00:34:38,090 --> 00:34:41,750
before you hit the lab because you don't

00:34:40,190 --> 00:34:43,159
like to discover those things in the lab

00:34:41,750 --> 00:34:44,919
we actually have a simulation

00:34:43,159 --> 00:34:47,060
environment that allows you to do Co sim

00:34:44,919 --> 00:34:49,040
Myron al mentioned this morning we have

00:34:47,060 --> 00:34:52,250
a partnership with smart DB it's

00:34:49,040 --> 00:34:54,139
analogous to like a cadence PCI Express

00:34:52,250 --> 00:34:55,820
bus functional model that's what smart

00:34:54,139 --> 00:34:58,220
Divi did they actually did something

00:34:55,820 --> 00:35:01,310
where it's called an open Cappy VIP they

00:34:58,220 --> 00:35:03,830
licensed it for a pretty my mind nominal

00:35:01,310 --> 00:35:07,010
amount so as you're doing your testing

00:35:03,830 --> 00:35:10,160
they actually test 3.0 and 3.1

00:35:07,010 --> 00:35:12,170
compliance and so they're the ones that

00:35:10,160 --> 00:35:14,420
are providing that service the

00:35:12,170 --> 00:35:16,340
exercisers and then there are the

00:35:14,420 --> 00:35:19,220
reference driver which is available on

00:35:16,340 --> 00:35:22,700
github today it's on a boot to 1804 and

00:35:19,220 --> 00:35:26,030
1804 dot one so that's available as well

00:35:22,700 --> 00:35:29,330
and that's actually all I have

00:35:26,030 --> 00:35:31,390
that was well good timing let's look

00:35:29,330 --> 00:35:31,390

YouTube URL: https://www.youtube.com/watch?v=h3pLBDCqY-I


