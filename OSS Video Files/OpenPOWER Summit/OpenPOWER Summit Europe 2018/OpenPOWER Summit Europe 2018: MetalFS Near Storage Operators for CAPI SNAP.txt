Title: OpenPOWER Summit Europe 2018: MetalFS Near Storage Operators for CAPI SNAP
Publication date: 2018-11-14
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Max Plauth, PhD Student, Hasso Plattner Institute for Digital Engineering, University of Potsdam, speaks at OpenPOWER Foundation's OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,940 --> 00:00:05,260
good morning everyone so I'm glad so

00:00:03,489 --> 00:00:07,720
many people are here despite of the

00:00:05,260 --> 00:00:10,749
bulky title that we had in the agenda so

00:00:07,720 --> 00:00:13,209
apologies for that mix-up so

00:00:10,749 --> 00:00:16,209
now mayor actually present a little bit

00:00:13,209 --> 00:00:18,519
more of a shorter title so I would like

00:00:16,209 --> 00:00:21,970
to introduce a project that we did are

00:00:18,519 --> 00:00:26,080
at our university corporation with many

00:00:21,970 --> 00:00:30,160
people at IBM babbling but also other

00:00:26,080 --> 00:00:34,510
people from IBM working on snap so the

00:00:30,160 --> 00:00:36,610
project has the title metal FS near

00:00:34,510 --> 00:00:38,920
storage operators for copy snap and

00:00:36,610 --> 00:00:44,350
before I'm going to dive into all

00:00:38,920 --> 00:00:47,079
details I would like to pre show who

00:00:44,350 --> 00:00:50,980
actually what people are behind metal FS

00:00:47,079 --> 00:00:55,440
so first of our Hobart Schmidt and Lukas

00:00:50,980 --> 00:00:59,980
Venter who did the main work of this and

00:00:55,440 --> 00:01:02,140
Felix ever had a colleague of mine we

00:00:59,980 --> 00:01:05,439
super average the supervisors in this

00:01:02,140 --> 00:01:07,869
role and then of course I would like to

00:01:05,439 --> 00:01:10,240
thank our professor Andrea sponsor for

00:01:07,869 --> 00:01:13,960
supporting this project and and many

00:01:10,240 --> 00:01:18,100
colleagues at IBM babbling and also

00:01:13,960 --> 00:01:20,380
other IBM locations so without all these

00:01:18,100 --> 00:01:23,799
people metal FS would never have been

00:01:20,380 --> 00:01:28,600
here in the first place so big things at

00:01:23,799 --> 00:01:32,799
this point so let me start with how we

00:01:28,600 --> 00:01:36,070
ended up with metal FS so we started a

00:01:32,799 --> 00:01:40,810
collaboration with both IBM Germany to

00:01:36,070 --> 00:01:43,360
find out new ways to leverage power8

00:01:40,810 --> 00:01:45,450
hardware at that point in time and also

00:01:43,360 --> 00:01:49,090
the heterogeneous computing capabilities

00:01:45,450 --> 00:01:52,630
that are enabled by copy so for that

00:01:49,090 --> 00:01:56,549
purpose we bought a nanotech 250s card

00:01:52,630 --> 00:01:59,710
with two terabyte of Indiana flash

00:01:56,549 --> 00:02:02,340
because well that's at that point of

00:01:59,710 --> 00:02:06,570
time was one of the best setups for

00:02:02,340 --> 00:02:10,150
getting started with coffee and snap so

00:02:06,570 --> 00:02:13,090
after some initial playing around and

00:02:10,150 --> 00:02:15,720
getting used the framework and how this

00:02:13,090 --> 00:02:15,720
card can be

00:02:16,160 --> 00:02:23,099
we were asking ourselves can the

00:02:20,160 --> 00:02:24,989
filesystem metaphor in UNIX and Linux be

00:02:23,099 --> 00:02:27,540
used to expose these near storage

00:02:24,989 --> 00:02:31,260
computing resources so we have two

00:02:27,540 --> 00:02:33,750
terabyte of flash memory was the quite

00:02:31,260 --> 00:02:38,340
decent FPGA next to it or at least it

00:02:33,750 --> 00:02:40,860
used to be a FPGA so we already heard in

00:02:38,340 --> 00:02:43,049
an earlier talk in UNIX everything's a

00:02:40,860 --> 00:02:48,180
file and we wanted to extend this

00:02:43,049 --> 00:02:50,580
metaphor so the idea was that we wanted

00:02:48,180 --> 00:02:53,640
to expose on one hand the storage

00:02:50,580 --> 00:02:55,700
available on this device in a regular

00:02:53,640 --> 00:03:00,390
Linux file system that can be mounted

00:02:55,700 --> 00:03:04,019
but then also to provide a way to expose

00:03:00,390 --> 00:03:07,769
operators that reside on this FPGA

00:03:04,019 --> 00:03:11,900
how can they be interacted with in the

00:03:07,769 --> 00:03:16,980
file system metaphor and this project

00:03:11,900 --> 00:03:18,989
yeah is built on top of copy snap which

00:03:16,980 --> 00:03:24,780
is yeah providing a very helpful

00:03:18,989 --> 00:03:27,060
foundation here so this is just the

00:03:24,780 --> 00:03:29,760
inter so the initial vision that we

00:03:27,060 --> 00:03:32,010
started out with so we were getting a

00:03:29,760 --> 00:03:36,900
little bit into details so what would be

00:03:32,010 --> 00:03:40,200
the requirements well ideally we thought

00:03:36,900 --> 00:03:43,829
it would be nice to deploy multiple AF

00:03:40,200 --> 00:03:45,810
use operators on such a card such as

00:03:43,829 --> 00:03:48,569
encryption compression or filter

00:03:45,810 --> 00:03:51,780
algorithms that can operate as close to

00:03:48,569 --> 00:03:54,180
storage as possible and what all such

00:03:51,780 --> 00:03:57,420
kinds of operators have in common is

00:03:54,180 --> 00:04:03,780
that they require a lot of input data

00:03:57,420 --> 00:04:07,049
they generate output data and it would

00:04:03,780 --> 00:04:09,269
be nice to dynamically chain these

00:04:07,049 --> 00:04:11,359
operators together to build a more

00:04:09,269 --> 00:04:13,769
complex use case from it than just

00:04:11,359 --> 00:04:19,019
encryption on itself compression on

00:04:13,769 --> 00:04:21,840
itself without having to burn new bit

00:04:19,019 --> 00:04:25,050
streams to the FPGA so that really the

00:04:21,840 --> 00:04:27,120
user of application developer can decide

00:04:25,050 --> 00:04:27,510
at runtime what they want to do with the

00:04:27,120 --> 00:04:31,680
avail

00:04:27,510 --> 00:04:34,170
new storage computing resources so the

00:04:31,680 --> 00:04:37,440
idea was in addition to exposing the

00:04:34,170 --> 00:04:41,160
storage of this device in a file system

00:04:37,440 --> 00:04:45,750
why we would want to expose the

00:04:41,160 --> 00:04:51,060
operators s sudo executables and the

00:04:45,750 --> 00:04:55,230
file system as well so we were wondering

00:04:51,060 --> 00:04:59,250
how should these operators work well

00:04:55,230 --> 00:05:03,180
pretty much like what you used to when

00:04:59,250 --> 00:05:06,020
you when you're accustomed to doing some

00:05:03,180 --> 00:05:10,110
shell magic and linking together some

00:05:06,020 --> 00:05:12,600
piping together some operators so this

00:05:10,110 --> 00:05:15,000
is just a simple example when we want to

00:05:12,600 --> 00:05:20,100
use the FPGA resources to verify a hash

00:05:15,000 --> 00:05:22,170
of an I so then of course it should

00:05:20,100 --> 00:05:24,840
behave right like regular command-line

00:05:22,170 --> 00:05:29,580
utilities that you can interact with std

00:05:24,840 --> 00:05:32,670
in and STD out but then most importantly

00:05:29,580 --> 00:05:36,270
it should also be possible to use these

00:05:32,670 --> 00:05:38,750
well-known semantics without having to

00:05:36,270 --> 00:05:41,970
transfer data forth and back between

00:05:38,750 --> 00:05:44,340
FPGA in CPU all the time so whenever

00:05:41,970 --> 00:05:47,130
we're operating on data that resides on

00:05:44,340 --> 00:05:51,230
the FPGA flash and when we're using

00:05:47,130 --> 00:05:53,520
operators available on the FPGA

00:05:51,230 --> 00:05:55,800
everything should stay within the cart

00:05:53,520 --> 00:06:01,650
and only some commands should be

00:05:55,800 --> 00:06:04,200
exchanged with the CPU so with these

00:06:01,650 --> 00:06:06,780
plans ahead of us we set up a number of

00:06:04,200 --> 00:06:10,710
goals that we had to achieve so first of

00:06:06,780 --> 00:06:12,780
all we needed some kind of file system

00:06:10,710 --> 00:06:14,720
abstraction for the SSD storage on this

00:06:12,780 --> 00:06:18,290
card

00:06:14,720 --> 00:06:22,260
we need programming interfaces for that

00:06:18,290 --> 00:06:24,240
once this is available we would need to

00:06:22,260 --> 00:06:28,100
make the files accessible through the

00:06:24,240 --> 00:06:32,490
Linux file system and mountable there

00:06:28,100 --> 00:06:37,010
next would be to find an strategy to

00:06:32,490 --> 00:06:40,759
build these chainable operators and

00:06:37,010 --> 00:06:43,509
lastly to implement these

00:06:40,759 --> 00:06:47,150
orchestration mechanism via standard

00:06:43,509 --> 00:06:53,689
shell pipes and all the operators that

00:06:47,150 --> 00:06:55,879
are available there so I've been using

00:06:53,689 --> 00:06:59,659
the term file system a couple of times

00:06:55,879 --> 00:07:02,300
so you shouldn't think of full-blown

00:06:59,659 --> 00:07:06,889
file system like x4 or something like

00:07:02,300 --> 00:07:12,050
this so this should be optimized for for

00:07:06,889 --> 00:07:14,990
this FPGA use case and be optimized for

00:07:12,050 --> 00:07:17,930
for minimum resource required em yet

00:07:14,990 --> 00:07:21,499
resource requirements there so we set up

00:07:17,930 --> 00:07:24,680
a couple of assumptions that a metal FS

00:07:21,499 --> 00:07:28,219
should support so first of all we assume

00:07:24,680 --> 00:07:31,879
that we want to work mostly with large

00:07:28,219 --> 00:07:35,360
files that only rarely change in length

00:07:31,879 --> 00:07:42,589
so there is not too much fragmentation

00:07:35,360 --> 00:07:46,430
to be expected coming from database and

00:07:42,589 --> 00:07:49,610
operating system context a little bit of

00:07:46,430 --> 00:07:51,289
mixture from both we were mostly

00:07:49,610 --> 00:07:55,939
interested in throughput rather than

00:07:51,289 --> 00:07:58,129
latency and then of course we didn't

00:07:55,939 --> 00:08:03,050
want to have the overhead of a full file

00:07:58,129 --> 00:08:06,379
system in order not to waste the very

00:08:03,050 --> 00:08:08,870
valuable FPGA resources well they should

00:08:06,379 --> 00:08:12,610
be used to implement actual operators

00:08:08,870 --> 00:08:16,279
and our file system abstraction on top

00:08:12,610 --> 00:08:17,959
should just be an abstraction layer to

00:08:16,279 --> 00:08:20,029
make it even easier for software

00:08:17,959 --> 00:08:26,020
developers to getting to get started

00:08:20,029 --> 00:08:29,959
with a few development so the thin

00:08:26,020 --> 00:08:32,089
abstraction layer that we had in mind as

00:08:29,959 --> 00:08:34,880
the idea that files are a collection of

00:08:32,089 --> 00:08:38,360
storage blocks and that all metadata

00:08:34,880 --> 00:08:41,990
like file names are managed by the hosts

00:08:38,360 --> 00:08:47,329
so host loading off certain complexity

00:08:41,990 --> 00:08:50,540
to the hostess okay so with these

00:08:47,329 --> 00:08:53,450
requirements in mind the first thing

00:08:50,540 --> 00:08:58,730
that we have to take care

00:08:53,450 --> 00:09:04,760
in methyl FS is extent so the idea here

00:08:58,730 --> 00:09:09,139
is to map multiple files to a linear

00:09:04,760 --> 00:09:12,889
block storage device and that we wanted

00:09:09,139 --> 00:09:19,459
to have a compact representation for

00:09:12,889 --> 00:09:24,019
that so the idea here was to use a

00:09:19,459 --> 00:09:27,260
contiguous list of extent that identify

00:09:24,019 --> 00:09:30,889
the first block and the length of a

00:09:27,260 --> 00:09:35,029
block and by the order of these extents

00:09:30,889 --> 00:09:36,889
when these are reassembled it gives the

00:09:35,029 --> 00:09:39,470
content of the file it yields the

00:09:36,889 --> 00:09:45,709
content of the file and logical address

00:09:39,470 --> 00:09:53,600
order so the first thing we had to build

00:09:45,709 --> 00:09:56,269
is this mapping logic in hardware so we

00:09:53,600 --> 00:10:00,290
were asking ourselves so we want to

00:09:56,269 --> 00:10:03,500
support a support a lot of parallelism

00:10:00,290 --> 00:10:06,380
so that as much data as possible can be

00:10:03,500 --> 00:10:10,070
fetched from storage in parallel and be

00:10:06,380 --> 00:10:12,589
processed on the FPGA so the first thing

00:10:10,070 --> 00:10:15,019
was that we were wondering how can we do

00:10:12,589 --> 00:10:19,779
this translation from logical box to

00:10:15,019 --> 00:10:19,779
physical blocks in a very efficient way

00:10:20,260 --> 00:10:28,970
so we came up with this idea that we can

00:10:24,350 --> 00:10:36,620
do this in parallel by simple mapping

00:10:28,970 --> 00:10:40,160
logic presented here so using the length

00:10:36,620 --> 00:10:43,899
information and the indication of the

00:10:40,160 --> 00:10:49,430
initial address we can efficiently

00:10:43,899 --> 00:10:53,750
compute the offsets of the extents in a

00:10:49,430 --> 00:10:56,540
quiet parallelized way so here we have

00:10:53,750 --> 00:11:00,199
this done four times parallel but it can

00:10:56,540 --> 00:11:05,089
be done even with more instances in

00:11:00,199 --> 00:11:07,220
parallel if required and so coming more

00:11:05,089 --> 00:11:11,290
from a software engineering background

00:11:07,220 --> 00:11:17,000
it was very nice that snap and HLS

00:11:11,290 --> 00:11:19,970
enabled us to implement this in a quite

00:11:17,000 --> 00:11:22,940
nice and compact way without having to

00:11:19,970 --> 00:11:29,000
dig into all the details of very log or

00:11:22,940 --> 00:11:34,819
VHDL so this is how we implemented the

00:11:29,000 --> 00:11:37,629
mapping logic next I mentioned that the

00:11:34,819 --> 00:11:42,680
responsibility for managing metadata is

00:11:37,629 --> 00:11:47,300
offloaded to the hosts so here the idea

00:11:42,680 --> 00:11:50,930
is that the extent list is stored in an

00:11:47,300 --> 00:11:53,990
LM DB instance on the host and that the

00:11:50,930 --> 00:12:00,170
extent lists are fetched from the FPGA

00:11:53,990 --> 00:12:02,170
via the PSL whenever a file is opened we

00:12:00,170 --> 00:12:05,269
also thought a little bit about

00:12:02,170 --> 00:12:08,199
strategies what happens so we assume

00:12:05,269 --> 00:12:10,699
that changes should rarely happen but

00:12:08,199 --> 00:12:14,149
how should we react when changes

00:12:10,699 --> 00:12:17,170
actually happen so we laid out some

00:12:14,149 --> 00:12:20,870
strategies for that as well

00:12:17,170 --> 00:12:26,120
so now we were at the point where we

00:12:20,870 --> 00:12:31,850
have the host side of this meta data

00:12:26,120 --> 00:12:36,709
store and the fp8 FPGA sided mapping

00:12:31,850 --> 00:12:40,790
logic that yields us the physical blocks

00:12:36,709 --> 00:12:45,170
from from an extent list so the next

00:12:40,790 --> 00:12:47,959
component that we needed is to build a

00:12:45,170 --> 00:12:50,959
multiple file system driver to make

00:12:47,959 --> 00:12:53,559
these storage resources accessible to

00:12:50,959 --> 00:12:59,360
the host of system

00:12:53,559 --> 00:13:05,420
so since snap consumers ran in user

00:12:59,360 --> 00:13:10,959
space we build this host sided file

00:13:05,420 --> 00:13:14,360
system view in lip views because its

00:13:10,959 --> 00:13:18,040
first of all user space solution it's

00:13:14,360 --> 00:13:20,509
quite easy and lightweight to implement

00:13:18,040 --> 00:13:21,020
however it comes with a certain context

00:13:20,509 --> 00:13:24,440
switching

00:13:21,020 --> 00:13:31,250
overhead but that's fine at the moment

00:13:24,440 --> 00:13:36,170
and also wondering well what if multiple

00:13:31,250 --> 00:13:39,430
users are accessing VGA well with the

00:13:36,170 --> 00:13:42,620
views running as a single threaded

00:13:39,430 --> 00:13:43,910
application or edit process we have the

00:13:42,620 --> 00:13:46,520
advantage that here we have a

00:13:43,910 --> 00:13:49,850
serialization point that we don't have

00:13:46,520 --> 00:13:52,790
to worry about interfering accesses to

00:13:49,850 --> 00:13:57,440
the hardware at the current point in

00:13:52,790 --> 00:14:00,680
time and another thing that was very

00:13:57,440 --> 00:14:03,820
nice about creating this multiple file

00:14:00,680 --> 00:14:07,970
system driver is that we were able to

00:14:03,820 --> 00:14:13,640
decouple it a lot from the actual metal

00:14:07,970 --> 00:14:15,860
FS core logic so the next component that

00:14:13,640 --> 00:14:20,630
we needed were these stand-in

00:14:15,860 --> 00:14:26,360
executables for operators to make AF use

00:14:20,630 --> 00:14:32,860
or operators up here as binaries on yeah

00:14:26,360 --> 00:14:36,080
and the hosts mounted filesystem yeah so

00:14:32,860 --> 00:14:40,610
the thing that I'm really mentioned is

00:14:36,080 --> 00:14:42,290
already there was only one process at a

00:14:40,610 --> 00:14:45,580
time being able to interact with the

00:14:42,290 --> 00:14:53,480
snap action we used the fuse for that

00:14:45,580 --> 00:14:57,430
and all the communication and live fuses

00:14:53,480 --> 00:15:01,720
done via UNIX sockets and payload data

00:14:57,430 --> 00:15:08,330
is transferred via memory mapped files

00:15:01,720 --> 00:15:10,940
so major major challenge here was that

00:15:08,330 --> 00:15:14,710
these standing executables need to

00:15:10,940 --> 00:15:17,150
collect the arguments and process

00:15:14,710 --> 00:15:22,190
processes or files connected to standard

00:15:17,150 --> 00:15:23,840
in or standard out to assemble these it

00:15:22,190 --> 00:15:27,800
as independent as possible

00:15:23,840 --> 00:15:30,530
processing chains and then forward the

00:15:27,800 --> 00:15:32,840
inputs to the file system driver and

00:15:30,530 --> 00:15:37,910
also receive outputs

00:15:32,840 --> 00:15:41,350
they're so of all the architecture he

00:15:37,910 --> 00:15:46,370
looks like this so if we're taking this

00:15:41,350 --> 00:15:48,110
example that we want to run the hello

00:15:46,370 --> 00:15:52,510
world string through a change case

00:15:48,110 --> 00:15:56,080
operator on the FPGA and encrypt it and

00:15:52,510 --> 00:15:59,120
in the next step decrypted at once again

00:15:56,080 --> 00:16:03,320
we have this data flow that of course

00:15:59,120 --> 00:16:06,650
coming from the host hello world has to

00:16:03,320 --> 00:16:11,780
be transferred to the FPGA there the

00:16:06,650 --> 00:16:15,350
change case operator is executed but

00:16:11,780 --> 00:16:18,440
then the output of that is redirected to

00:16:15,350 --> 00:16:30,890
the encrypt operator and after that the

00:16:18,440 --> 00:16:33,590
decrypt operator so so that has coming

00:16:30,890 --> 00:16:38,240
in here from the host it stays on the

00:16:33,590 --> 00:16:45,170
FPGA and then only leaves it after the

00:16:38,240 --> 00:16:50,110
final processing step so that is the

00:16:45,170 --> 00:16:54,140
idea here and to implement these

00:16:50,110 --> 00:16:56,720
stand-in executables we implemented

00:16:54,140 --> 00:16:58,840
metal FS in a way that the file system

00:16:56,720 --> 00:17:02,510
driver has a list of all available

00:16:58,840 --> 00:17:06,880
operators on available in the current

00:17:02,510 --> 00:17:09,800
bit stream on the FPGA and that it

00:17:06,880 --> 00:17:14,650
handles all the i/o requests for these

00:17:09,800 --> 00:17:17,600
virtual stand-in executables all these

00:17:14,650 --> 00:17:22,700
standing executables actually point to

00:17:17,600 --> 00:17:28,940
the same binary and based on the name of

00:17:22,700 --> 00:17:31,120
the binary and the program arguments the

00:17:28,940 --> 00:17:34,220
file system driver driver knows how to

00:17:31,120 --> 00:17:36,410
what what operators on the FPGA are

00:17:34,220 --> 00:17:39,280
intended and how to build up this

00:17:36,410 --> 00:17:39,280
processing chain

00:17:40,650 --> 00:17:48,510
all right so how does one of these

00:17:45,450 --> 00:17:52,700
operators look like if we're looking at

00:17:48,510 --> 00:17:57,290
the FPGA sided implementation here's a

00:17:52,700 --> 00:18:00,300
little example of this change case

00:17:57,290 --> 00:18:05,010
example in hls where we have an input

00:18:00,300 --> 00:18:07,940
stream and an output stream and we're

00:18:05,010 --> 00:18:12,809
just adding a certain offset here to

00:18:07,940 --> 00:18:14,550
change the case of from yeah well it's

00:18:12,809 --> 00:18:19,050
not exactly the change case but we're

00:18:14,550 --> 00:18:21,870
adding an offset here so this is a very

00:18:19,050 --> 00:18:25,190
simple operator the question or the big

00:18:21,870 --> 00:18:27,380
question now was how can we actually

00:18:25,190 --> 00:18:29,610
[Music]

00:18:27,380 --> 00:18:32,610
orchestrate these different operators

00:18:29,610 --> 00:18:35,370
how can we move the output of one

00:18:32,610 --> 00:18:36,500
operator to the input of another and

00:18:35,370 --> 00:18:39,270
[Music]

00:18:36,500 --> 00:18:41,010
magic technology that we also heard a

00:18:39,270 --> 00:18:45,990
couple of times in the last times that

00:18:41,010 --> 00:18:50,240
is the best common denominator is oxy so

00:18:45,990 --> 00:18:54,990
we came up with an architecture where

00:18:50,240 --> 00:19:00,090
the job interface configures an oxy

00:18:54,990 --> 00:19:03,270
stream switch based on the actual chain

00:19:00,090 --> 00:19:06,210
of operators that that we configured or

00:19:03,270 --> 00:19:09,120
that we issued on the command line and

00:19:06,210 --> 00:19:12,510
based on this chain it configures the

00:19:09,120 --> 00:19:15,120
access stream switch to fetch data from

00:19:12,510 --> 00:19:18,750
hosts memory and the output of that is

00:19:15,120 --> 00:19:22,800
redirected to the change case operator

00:19:18,750 --> 00:19:24,750
the output of that is streamed to the

00:19:22,800 --> 00:19:28,910
Blowfish encrypt and the Blowfish

00:19:24,750 --> 00:19:31,950
decrypt and the output of that is again

00:19:28,910 --> 00:19:37,670
stream back to hosts memory so when

00:19:31,950 --> 00:19:37,670
we're looking back at this example here

00:19:37,940 --> 00:19:49,410
so one thing that I haven't mentioned so

00:19:45,600 --> 00:19:53,950
far so thus far we've mainly built our

00:19:49,410 --> 00:19:56,680
operators in HLS but

00:19:53,950 --> 00:19:58,750
if you're interested in squeezing the

00:19:56,680 --> 00:20:01,140
most possible performance out of an

00:19:58,750 --> 00:20:04,660
operator it's of course also possible to

00:20:01,140 --> 00:20:10,450
easily adapt metal FS that you can

00:20:04,660 --> 00:20:13,930
integrate every lock or operators that

00:20:10,450 --> 00:20:16,480
is one thing and being at this

00:20:13,930 --> 00:20:18,100
architecture perhaps we might wonder

00:20:16,480 --> 00:20:22,390
what what use case is what we have in

00:20:18,100 --> 00:20:24,520
mind so I mentioned that we're

00:20:22,390 --> 00:20:27,910
interested in both operating systems and

00:20:24,520 --> 00:20:34,960
in-memory processing of large data sets

00:20:27,910 --> 00:20:38,980
so ideally in a long term on the long

00:20:34,960 --> 00:20:41,890
term would like to implement some kind

00:20:38,980 --> 00:20:44,050
of data base operators like scans or

00:20:41,890 --> 00:20:47,860
filters or rather filters probably in

00:20:44,050 --> 00:20:51,340
year as close as possible to the storage

00:20:47,860 --> 00:20:53,020
here on the FPGA in order to reduce the

00:20:51,340 --> 00:20:56,290
amount of data that needs to be moved to

00:20:53,020 --> 00:20:58,900
the host so I mean even though we have

00:20:56,290 --> 00:21:01,810
very nice and fast interconnect with

00:20:58,900 --> 00:21:06,690
open copy available in the meanwhile but

00:21:01,810 --> 00:21:09,790
we also want to use these resources as

00:21:06,690 --> 00:21:13,540
best as possible so that's why we want

00:21:09,790 --> 00:21:16,230
to go and to give you an impression how

00:21:13,540 --> 00:21:21,960
metal FS looks like in practice

00:21:16,230 --> 00:21:25,990
we've prepared a little screencast so

00:21:21,960 --> 00:21:30,430
first of all this is the direct - mm T

00:21:25,990 --> 00:21:34,240
metal FS we've mounted metal FS so there

00:21:30,430 --> 00:21:37,630
are two directories files this basically

00:21:34,240 --> 00:21:39,580
just gives you access to the storage so

00:21:37,630 --> 00:21:42,660
you can interact from the house with the

00:21:39,580 --> 00:21:47,230
storage residing on the FPGA a card

00:21:42,660 --> 00:21:51,190
however you like and then there's the

00:21:47,230 --> 00:21:53,890
operators directory that holds all the

00:21:51,190 --> 00:22:01,330
standard executables for the operators

00:21:53,890 --> 00:22:04,360
available on the FPGA so coming back to

00:22:01,330 --> 00:22:07,120
this example that we showed earlier we

00:22:04,360 --> 00:22:10,150
want to chain together change

00:22:07,120 --> 00:22:17,350
case encrypt and decrypt and see how it

00:22:10,150 --> 00:22:21,280
works so we're putting in hello open

00:22:17,350 --> 00:22:24,490
power summit Europe 2018 first was a

00:22:21,280 --> 00:22:26,920
change case example that works fine I

00:22:24,490 --> 00:22:30,130
mean now that has moving moved from the

00:22:26,920 --> 00:22:32,830
host to the FPGA and it's moved back

00:22:30,130 --> 00:22:37,000
this would represent the typical offload

00:22:32,830 --> 00:22:39,490
case so just imagine a more sensible use

00:22:37,000 --> 00:22:41,530
case than change case here so in the

00:22:39,490 --> 00:22:44,020
next step we want to demonstrate that

00:22:41,530 --> 00:22:51,850
can also make use of data residing on

00:22:44,020 --> 00:22:55,179
the FPGA so so again we're taking the

00:22:51,850 --> 00:22:57,820
string and encrypting it and the

00:22:55,179 --> 00:23:05,980
encrypted string is thought on the FPGA

00:22:57,820 --> 00:23:09,040
storage so next we want to decrypt this

00:23:05,980 --> 00:23:11,679
encrypted string change the message

00:23:09,040 --> 00:23:15,370
change the catch and change the case to

00:23:11,679 --> 00:23:19,840
uppercase re-encrypt it again and store

00:23:15,370 --> 00:23:23,550
it on the FPGA attached nvme storage so

00:23:19,840 --> 00:23:25,690
you cannot see any result here but to

00:23:23,550 --> 00:23:29,679
demonstrate that it's actually doing

00:23:25,690 --> 00:23:32,380
something we're messing around a little

00:23:29,679 --> 00:23:35,800
bit with it so first of all we're trying

00:23:32,380 --> 00:23:39,340
to decrypt this uppercase string with

00:23:35,800 --> 00:23:42,760
another key to see that garbage is

00:23:39,340 --> 00:23:48,100
coming out so it doesn't just return a

00:23:42,760 --> 00:23:50,910
static string and now we're also using

00:23:48,100 --> 00:23:57,130
correct key to decrypt the data again

00:23:50,910 --> 00:23:59,170
and as you can see it is the output that

00:23:57,130 --> 00:24:02,770
we would expect so it's now a lower

00:23:59,170 --> 00:24:10,900
cased hello open power submit Europe

00:24:02,770 --> 00:24:13,410
2018 so now of course this this the

00:24:10,900 --> 00:24:16,210
available operators that we have here

00:24:13,410 --> 00:24:19,840
are more of academic nature to

00:24:16,210 --> 00:24:21,190
demonstrate the overall concept of metal

00:24:19,840 --> 00:24:23,800
FS the next steps

00:24:21,190 --> 00:24:26,830
we'll be to implement additional

00:24:23,800 --> 00:24:29,860
operators here and build use cases from

00:24:26,830 --> 00:24:35,010
this so what should metal FS be used for

00:24:29,860 --> 00:24:39,310
either for really end users who want to

00:24:35,010 --> 00:24:42,610
define workflows at hawk without having

00:24:39,310 --> 00:24:44,140
to alter the FPGA bitstream perhaps they

00:24:42,610 --> 00:24:48,220
don't even know what an FPGA bitstream

00:24:44,140 --> 00:24:50,980
is so it's more of targeting domain

00:24:48,220 --> 00:24:56,160
experts that want to build some logic

00:24:50,980 --> 00:24:58,840
from exist building blocks and another

00:24:56,160 --> 00:25:03,070
option would be application developers

00:24:58,840 --> 00:25:08,140
that want to use this interface to use

00:25:03,070 --> 00:25:09,840
FPGA accelerated functions to accelerate

00:25:08,140 --> 00:25:16,360
their use case at hands

00:25:09,840 --> 00:25:18,280
so of course metal FS is open source

00:25:16,360 --> 00:25:19,930
because we heard also yesterday in the

00:25:18,280 --> 00:25:23,200
discussion that it's very important to

00:25:19,930 --> 00:25:25,510
make all the world all the work around

00:25:23,200 --> 00:25:28,660
copy and snap available to as many

00:25:25,510 --> 00:25:33,100
people as possible so you can find it on

00:25:28,660 --> 00:25:35,050
github and we would be very happy to to

00:25:33,100 --> 00:25:40,590
get feedback from you if you're

00:25:35,050 --> 00:25:43,560
interested in the general idea yeah and

00:25:40,590 --> 00:25:46,690
we're thinking very much in this

00:25:43,560 --> 00:25:50,800
database and in-memory processing style

00:25:46,690 --> 00:25:53,350
use cases so if you have other use cases

00:25:50,800 --> 00:25:56,410
that you can think of that that are very

00:25:53,350 --> 00:26:00,760
interesting for such a workflow talk to

00:25:56,410 --> 00:26:05,470
us so input and feedback of all kind is

00:26:00,760 --> 00:26:08,020
always welcome so I would like to thank

00:26:05,470 --> 00:26:10,600
you for your attention and if you have

00:26:08,020 --> 00:26:12,270
any questions we'll be happy to answer

00:26:10,600 --> 00:26:14,580
them

00:26:12,270 --> 00:26:16,640
[Applause]

00:26:14,580 --> 00:26:16,640

YouTube URL: https://www.youtube.com/watch?v=tkBXc47u8eE


