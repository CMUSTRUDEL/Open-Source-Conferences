Title: OpenPOWER Summit Europe 2018: A Software Developer's Introduction to OpenCAPI
Publication date: 2018-11-14
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Andrew Donnellan, Software Engineer, IBM Linux Technology Centre, speaks at OpenPOWER Foundation's OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:01,949 --> 00:00:05,910
well good morning everyone my name's

00:00:04,140 --> 00:00:07,560
Andrew Donnellan I'm an open power

00:00:05,910 --> 00:00:09,389
firmware and kernel engineer working for

00:00:07,560 --> 00:00:11,970
the IBM Linux Technology Center in

00:00:09,389 --> 00:00:13,559
Canberra Australia I have a very

00:00:11,970 --> 00:00:15,870
exciting disclaimer slide to show you as

00:00:13,559 --> 00:00:17,310
IBM takes no responsibility for the next

00:00:15,870 --> 00:00:22,529
20 minutes of life in falsehoods that

00:00:17,310 --> 00:00:25,140
I'll be sharing with you today so open

00:00:22,529 --> 00:00:27,060
Kathy I expect a lot of people in this

00:00:25,140 --> 00:00:30,930
room will have already heard about open

00:00:27,060 --> 00:00:32,820
Cappy there was an entire fpga stream

00:00:30,930 --> 00:00:35,819
yesterday with a lot of open Cappy talks

00:00:32,820 --> 00:00:40,289
so I will kind of skip over the

00:00:35,819 --> 00:00:41,969
marketing spiel but the open coherent

00:00:40,289 --> 00:00:43,530
accelerator process or interface it's

00:00:41,969 --> 00:00:45,659
high bandwidth twenty five gigabit

00:00:43,530 --> 00:00:48,319
gigabytes per second it's also low

00:00:45,659 --> 00:00:53,909
latency it's designed specifically with

00:00:48,319 --> 00:00:57,059
FPGA implementations in mind and very

00:00:53,909 --> 00:00:59,999
importantly most distinctively it is

00:00:57,059 --> 00:01:02,190
coherent it's an evolution of the

00:00:59,999 --> 00:01:04,610
pcie-based capi protocol that was

00:01:02,190 --> 00:01:07,259
launched with power8

00:01:04,610 --> 00:01:08,909
except with a new physical link layer

00:01:07,259 --> 00:01:13,859
that's higher performance and lower

00:01:08,909 --> 00:01:16,649
latency but open capi devices can

00:01:13,859 --> 00:01:19,079
operate natively within an applications

00:01:16,649 --> 00:01:21,140
virtual address space they have autumn

00:01:19,079 --> 00:01:22,979
it has automatic address translation

00:01:21,140 --> 00:01:25,380
maintains coherence with the host

00:01:22,979 --> 00:01:28,109
processor and this essentially means

00:01:25,380 --> 00:01:29,460
that you can you know treat your open

00:01:28,109 --> 00:01:30,840
Kathy accelerator as if it's just

00:01:29,460 --> 00:01:32,820
another thread of a multi-threaded

00:01:30,840 --> 00:01:34,799
application so this has a massive impact

00:01:32,820 --> 00:01:37,609
on the way that you do software

00:01:34,799 --> 00:01:40,289
development for open Kathy applications

00:01:37,609 --> 00:01:42,539
it makes the programming model for open

00:01:40,289 --> 00:01:44,579
Kathy accelerators much lower overhead

00:01:42,539 --> 00:01:46,679
and simpler you can just pass your

00:01:44,579 --> 00:01:48,299
standard C pointers between your

00:01:46,679 --> 00:01:51,569
application and your device and things

00:01:48,299 --> 00:01:54,659
just magically work so in this talk I

00:01:51,569 --> 00:01:57,090
will be showing you the open capping

00:01:54,659 --> 00:01:59,100
software stack going through how we

00:01:57,090 --> 00:02:02,369
actually get from plugging in and open

00:01:59,100 --> 00:02:05,539
copy card to running applications that

00:02:02,369 --> 00:02:08,970
make use of open copies memory coherence

00:02:05,539 --> 00:02:11,549
I should note that for those of you who

00:02:08,970 --> 00:02:13,770
weren't at the FPGA stream yesterday

00:02:11,549 --> 00:02:17,550
there's a couple of really good talks

00:02:13,770 --> 00:02:21,500
that were given particularly by Bruno

00:02:17,550 --> 00:02:24,780
and Brian yesterday on the open Cappy

00:02:21,500 --> 00:02:26,070
protocol and also the snap framework

00:02:24,780 --> 00:02:29,010
which is also something that's

00:02:26,070 --> 00:02:31,950
definitely worth looking into if you're

00:02:29,010 --> 00:02:33,210
interested in Cappy programming so if

00:02:31,950 --> 00:02:34,620
you didn't go to those talks yesterday I

00:02:33,210 --> 00:02:38,880
would definitely recommend you go get

00:02:34,620 --> 00:02:40,800
the recordings afterwards so we're gonna

00:02:38,880 --> 00:02:43,050
work ourselves up from the basics

00:02:40,800 --> 00:02:46,050
we've bought our very tiny new powerline

00:02:43,050 --> 00:02:48,030
box and bought a wonderful open Cappy

00:02:46,050 --> 00:02:51,380
FPGA from one of our partners like alpha

00:02:48,030 --> 00:02:54,210
data and plugged it in and powered it on

00:02:51,380 --> 00:02:56,010
so what actually happens when you boot a

00:02:54,210 --> 00:02:59,040
machine with an open Cappy card

00:02:56,010 --> 00:03:01,650
installed so the first part of our open

00:02:59,040 --> 00:03:03,600
Cappy software adventure is ski boot ski

00:03:01,650 --> 00:03:06,870
boot is part of the open Cappy at the

00:03:03,600 --> 00:03:07,080
open power firmware stack it implements

00:03:06,870 --> 00:03:10,080
the

00:03:07,080 --> 00:03:11,820
open power abstraction layer or opal and

00:03:10,080 --> 00:03:13,710
if you're not familiar with that

00:03:11,820 --> 00:03:15,540
definitely go watch the recording of

00:03:13,710 --> 00:03:18,150
stuart-smith talk which is going on in

00:03:15,540 --> 00:03:21,090
the next room where he explains a lot of

00:03:18,150 --> 00:03:23,070
that ski boot is responsible for a lot

00:03:21,090 --> 00:03:24,690
of hardware initialization before we get

00:03:23,070 --> 00:03:26,910
to the point of loading the Linux kernel

00:03:24,690 --> 00:03:30,840
and it also provides a bunch of runtime

00:03:26,910 --> 00:03:34,709
api's to Linux that Linux users for

00:03:30,840 --> 00:03:40,500
various machine dependent you know very

00:03:34,709 --> 00:03:42,660
bare metal hardware management so when

00:03:40,500 --> 00:03:44,790
it comes to open Caffey ski boot does a

00:03:42,660 --> 00:03:47,070
bunch of things that are needed to

00:03:44,790 --> 00:03:50,520
initialize open Caffey devices and

00:03:47,070 --> 00:03:52,770
provide runtime support for Linux as you

00:03:50,520 --> 00:03:54,930
can see here you know I've got a machine

00:03:52,770 --> 00:03:56,610
I've booted it it's running an extremely

00:03:54,930 --> 00:03:58,080
legitimate released version of opal that

00:03:56,610 --> 00:04:01,610
was definitely not a random get branch I

00:03:58,080 --> 00:04:05,190
had lying around when I made the slide

00:04:01,610 --> 00:04:07,530
it's detecting that there's an NP you

00:04:05,190 --> 00:04:08,880
and in V link processing unit that's the

00:04:07,530 --> 00:04:11,489
part of the power 9 chip that it's

00:04:08,880 --> 00:04:14,430
responsible for env link and open Cappy

00:04:11,489 --> 00:04:17,010
devices and V link and open Cappy are

00:04:14,430 --> 00:04:18,720
serviced by the by the same hardware on

00:04:17,010 --> 00:04:23,520
power 9 they use the same physical link

00:04:18,720 --> 00:04:25,950
layer so it's detected an NP you it's

00:04:23,520 --> 00:04:27,540
initialized that it's detecting the

00:04:25,950 --> 00:04:29,690
presence of an

00:04:27,540 --> 00:04:32,060
and Cappy device in a in a flight and

00:04:29,690 --> 00:04:34,320
configuring that appropriately and it's

00:04:32,060 --> 00:04:38,880
kicked off the hardware link training

00:04:34,320 --> 00:04:41,130
process which trains our 25g link so

00:04:38,880 --> 00:04:43,200
we've detected our open Cappy card we've

00:04:41,130 --> 00:04:48,300
trained the link and as you can see down

00:04:43,200 --> 00:04:51,450
here we've now registered a PHP a PHP is

00:04:48,300 --> 00:04:56,010
a PCI host bridge for those of you who

00:04:51,450 --> 00:04:58,350
are unfamiliar and through this PHP we

00:04:56,010 --> 00:05:01,470
have actually probed two PCI devices as

00:04:58,350 --> 00:05:03,990
you can see they show up just like a PCI

00:05:01,470 --> 00:05:07,140
device would they've got a IBM vendor ID

00:05:03,990 --> 00:05:11,840
and there's two PCI functions on this

00:05:07,140 --> 00:05:13,830
device so what am I talking about PCI

00:05:11,840 --> 00:05:16,830
this is the first thing you'll notice

00:05:13,830 --> 00:05:19,980
about how open Cappy devices appear to

00:05:16,830 --> 00:05:21,960
software open Cappy devices look like

00:05:19,980 --> 00:05:25,260
PCI device it's a presenter just like

00:05:21,960 --> 00:05:29,100
PCI devices they're connected to a PCI

00:05:25,260 --> 00:05:30,900
host bridge that you know a vendor ID

00:05:29,100 --> 00:05:32,940
and a device ID and all the other things

00:05:30,900 --> 00:05:36,630
that you typically see when you probe

00:05:32,940 --> 00:05:39,330
for a PCI device and the reason that we

00:05:36,630 --> 00:05:42,620
chose to implement open Kathy like this

00:05:39,330 --> 00:05:46,350
is like many other protocols that have

00:05:42,620 --> 00:05:47,880
disguised and also as if they're PCI it

00:05:46,350 --> 00:05:49,650
means that we can leverage all the

00:05:47,880 --> 00:05:52,710
existing infrastructure all the support

00:05:49,650 --> 00:05:54,770
for PCI devices that exists within the

00:05:52,710 --> 00:05:57,210
operating system within the Linux kernel

00:05:54,770 --> 00:06:00,080
without needing to implement our own bus

00:05:57,210 --> 00:06:00,080
completely from scratch

00:06:00,510 --> 00:06:07,410
and so you know if we boot into Linux

00:06:02,730 --> 00:06:09,810
and we run LS PCI as you do with reg PCI

00:06:07,410 --> 00:06:13,350
devices and as you can see we've got

00:06:09,810 --> 00:06:15,240
devices that look just like PCI we've

00:06:13,350 --> 00:06:17,100
got two functions they advertise

00:06:15,240 --> 00:06:20,550
themselves as processing accelerators a

00:06:17,100 --> 00:06:23,640
PCI class 12 device

00:06:20,550 --> 00:06:27,150
there's driver down to it OC excel which

00:06:23,640 --> 00:06:29,850
we'll get to in a minute we've got two

00:06:27,150 --> 00:06:31,590
functions and each of them has a PCI

00:06:29,850 --> 00:06:33,210
configuration space for retrieving

00:06:31,590 --> 00:06:36,090
device metadata which is where all this

00:06:33,210 --> 00:06:38,490
information is coming from you can see

00:06:36,090 --> 00:06:40,800
that we've got memory base address

00:06:38,490 --> 00:06:43,470
registers for memory mapped i/o

00:06:40,800 --> 00:06:47,099
just like you would with regular PCI

00:06:43,470 --> 00:06:48,270
device and it's got PCI tape abilities

00:06:47,099 --> 00:06:51,960
and all the other things that come with

00:06:48,270 --> 00:06:54,090
being PCI so a Linux driver can just

00:06:51,960 --> 00:06:55,949
bind to this device it can retrieve

00:06:54,090 --> 00:06:59,190
device information and do configuration

00:06:55,949 --> 00:07:03,060
in the way that you expect using

00:06:59,190 --> 00:07:05,639
standard PCI access methods provided by

00:07:03,060 --> 00:07:07,470
the Linux kernel so there's some open

00:07:05,639 --> 00:07:10,370
capi specific configuration stuff as

00:07:07,470 --> 00:07:12,479
well some of that is done through

00:07:10,370 --> 00:07:15,990
extended capabilities which you can't

00:07:12,479 --> 00:07:17,849
see here through PCI config space and

00:07:15,990 --> 00:07:20,849
there's also some stuff that needs to go

00:07:17,849 --> 00:07:25,610
through the Opel API to ski boot but I

00:07:20,849 --> 00:07:27,539
won't go into that here so so far

00:07:25,610 --> 00:07:30,330
everything looks good it all looks like

00:07:27,539 --> 00:07:32,430
PCI we've got a device it can present up

00:07:30,330 --> 00:07:34,789
to eight functions just like a PCI

00:07:32,430 --> 00:07:36,629
device can present up to eight functions

00:07:34,789 --> 00:07:39,750
but this is where things get a little

00:07:36,629 --> 00:07:42,300
more complicated so each function can

00:07:39,750 --> 00:07:44,610
have multiple attached functional units

00:07:42,300 --> 00:07:47,520
or AF use which you may have heard about

00:07:44,610 --> 00:07:51,090
if you've been to the other open Cappy

00:07:47,520 --> 00:07:53,610
talks so far at this conference and on

00:07:51,090 --> 00:07:58,710
each AF you we can open multiple

00:07:53,610 --> 00:08:01,440
contexts so what's an AF you so an

00:07:58,710 --> 00:08:03,539
attached functional unit is an

00:08:01,440 --> 00:08:05,550
individual block of accellerate of

00:08:03,539 --> 00:08:07,740
functionality it can be something like a

00:08:05,550 --> 00:08:10,259
compression engine or a data acquisition

00:08:07,740 --> 00:08:13,710
engine or you know whatever it is that

00:08:10,259 --> 00:08:16,289
you're accelerating you can have

00:08:13,710 --> 00:08:18,150
multiple AF use on a card or on a

00:08:16,289 --> 00:08:19,560
particular function each being a

00:08:18,150 --> 00:08:21,779
completely different type of accellerate

00:08:19,560 --> 00:08:24,900
err obviously that's you know the number

00:08:21,779 --> 00:08:26,940
of ASU you can have is fundamentally

00:08:24,900 --> 00:08:31,349
concerned by how much silicon you have

00:08:26,940 --> 00:08:33,599
on your FPGA or your asset but as far as

00:08:31,349 --> 00:08:36,539
the protocol is concerned as far as the

00:08:33,599 --> 00:08:38,690
configuration specification is concerned

00:08:36,539 --> 00:08:42,360
you can advertise as many different

00:08:38,690 --> 00:08:44,310
you're all up to some limit like 64 or

00:08:42,360 --> 00:08:46,250
whatever it is but you can advertise

00:08:44,310 --> 00:08:50,579
multiple different types of

00:08:46,250 --> 00:08:51,870
functionality which do completely

00:08:50,579 --> 00:08:53,740
different things and completely

00:08:51,870 --> 00:08:58,870
different acelerate engines

00:08:53,740 --> 00:09:01,810
your FPGA hardware and I also mentioned

00:08:58,870 --> 00:09:03,940
context contexts and passage process

00:09:01,810 --> 00:09:07,120
address space IDs so that's how we

00:09:03,940 --> 00:09:08,260
associate in AF you with the virtual

00:09:07,120 --> 00:09:11,380
address space of a particular

00:09:08,260 --> 00:09:13,360
application so whenever an application

00:09:11,380 --> 00:09:16,360
wants to make use of an AF you it needs

00:09:13,360 --> 00:09:18,450
to acquire a context the maximum number

00:09:16,360 --> 00:09:20,470
of contexts that you have that's

00:09:18,450 --> 00:09:22,209
dependent on the hardware design and

00:09:20,470 --> 00:09:23,860
obviously the resources that you have in

00:09:22,209 --> 00:09:27,160
your hardware to keep track of the state

00:09:23,860 --> 00:09:29,260
of multiple different applications so

00:09:27,160 --> 00:09:33,760
the AF you can declare how many contacts

00:09:29,260 --> 00:09:35,820
it supports and when you when an

00:09:33,760 --> 00:09:39,640
application opens a context the

00:09:35,820 --> 00:09:41,890
operating system allocates app acid to

00:09:39,640 --> 00:09:44,350
represent it and through various layers

00:09:41,890 --> 00:09:47,649
of indirection that's actually used to

00:09:44,350 --> 00:09:49,510
generate a handle which is used you know

00:09:47,649 --> 00:09:51,520
which is actually included in the open

00:09:49,510 --> 00:09:54,250
Kathy the packets on the open Kathy bus

00:09:51,520 --> 00:09:56,649
to associate a particular you know read

00:09:54,250 --> 00:09:59,290
or write or memory access with a

00:09:56,649 --> 00:10:03,459
particular process ID and thread ID

00:09:59,290 --> 00:10:08,050
which can be used to manage the virtual

00:10:03,459 --> 00:10:10,510
memory so yeah if you want your entire

00:10:08,050 --> 00:10:12,339
AFU to be dedicated to one application

00:10:10,510 --> 00:10:14,500
you can restrict it to just having a

00:10:12,339 --> 00:10:17,560
maximum of one context but otherwise

00:10:14,500 --> 00:10:20,320
this is how we share an AFU between

00:10:17,560 --> 00:10:22,240
multiple applications concurrently we

00:10:20,320 --> 00:10:25,180
open multiple contexts and with each

00:10:22,240 --> 00:10:26,709
transaction over the bus that each

00:10:25,180 --> 00:10:29,770
transaction is associated with the

00:10:26,709 --> 00:10:34,390
specific application that registered

00:10:29,770 --> 00:10:37,540
that context so just like with PCI we

00:10:34,390 --> 00:10:39,430
have memory mapped i/o we use mm io to

00:10:37,540 --> 00:10:41,980
communicate with our seller ater wit and

00:10:39,430 --> 00:10:44,680
you know tell it what to do so you don't

00:10:41,980 --> 00:10:47,320
use mm i/o to do the you know

00:10:44,680 --> 00:10:49,839
large-scale data transfer that you're

00:10:47,320 --> 00:10:52,149
meant to be doing through the fact that

00:10:49,839 --> 00:10:55,630
you've got coherent coherent access to

00:10:52,149 --> 00:10:57,579
hosts memory but you do need mm io to be

00:10:55,630 --> 00:10:59,680
our initialize and set up the device and

00:10:57,579 --> 00:11:03,940
tell it you know what it is that it

00:10:59,680 --> 00:11:05,529
needs to needs to do so an open copy

00:11:03,940 --> 00:11:07,690
device advertised has two different

00:11:05,529 --> 00:11:10,870
types of mm i/o region

00:11:07,690 --> 00:11:15,100
the first is an a Fu global mm IO space

00:11:10,870 --> 00:11:18,490
which is per for each one for each a fu

00:11:15,100 --> 00:11:21,400
on on your device so that's used for a

00:11:18,490 --> 00:11:24,880
fu wide global configuration and you

00:11:21,400 --> 00:11:26,650
also have a perp acid mm IO space which

00:11:24,880 --> 00:11:29,740
is configuration for each individual

00:11:26,650 --> 00:11:30,850
context that you open so I just

00:11:29,740 --> 00:11:34,990
mentioned this here because this will

00:11:30,850 --> 00:11:35,470
come up a bit later so we booted our

00:11:34,990 --> 00:11:39,130
system

00:11:35,470 --> 00:11:43,240
we're in Linux we have a PCI device now

00:11:39,130 --> 00:11:45,670
what enter the OC excel driver which can

00:11:43,240 --> 00:11:48,880
be found in your Linux kernel tree at

00:11:45,670 --> 00:11:50,890
drivers slash miss flash OC excel it's

00:11:48,880 --> 00:11:52,690
named OC excel because it's the open

00:11:50,890 --> 00:11:55,840
successor to the previous driver for

00:11:52,690 --> 00:11:59,350
capi which is called C excel for reasons

00:11:55,840 --> 00:12:03,070
I won't go into there are two different

00:11:59,350 --> 00:12:05,410
ways of using OC excel so firstly you

00:12:03,070 --> 00:12:07,270
can use it as a standard driver for the

00:12:05,410 --> 00:12:08,650
most common category of open kappa use

00:12:07,270 --> 00:12:10,600
case so that's where you have an

00:12:08,650 --> 00:12:11,830
accelerator which you want to pass

00:12:10,600 --> 00:12:14,170
through to your user space application

00:12:11,830 --> 00:12:17,680
so that a user space application can use

00:12:14,170 --> 00:12:19,750
it directly so in this case the you have

00:12:17,680 --> 00:12:22,960
the OC excel driver bind directly to

00:12:19,750 --> 00:12:25,240
your PCI device and it will expose a

00:12:22,960 --> 00:12:28,120
user space API which we'll discuss a

00:12:25,240 --> 00:12:29,460
little bit more in a minute but secondly

00:12:28,120 --> 00:12:33,640
there are some other use cases

00:12:29,460 --> 00:12:36,820
particularly stuff like storage devices

00:12:33,640 --> 00:12:38,500
or network cards where you may actually

00:12:36,820 --> 00:12:41,770
want to implement a driver within the

00:12:38,500 --> 00:12:44,680
kernel and so for this case OC Excel

00:12:41,770 --> 00:12:48,940
provides an internal API that you can

00:12:44,680 --> 00:12:50,440
use to write a standard Linux driver but

00:12:48,940 --> 00:12:52,420
without having to deal with any of the

00:12:50,440 --> 00:12:54,220
you know open copy device setup and

00:12:52,420 --> 00:12:56,200
configuration it provides an API that

00:12:54,220 --> 00:12:59,620
allows you to do stuff like setting up

00:12:56,200 --> 00:13:00,970
contexts and destroying contexts and all

00:12:59,620 --> 00:13:03,670
the other stuff that we would typically

00:13:00,970 --> 00:13:06,880
expose to user space so I'm not going to

00:13:03,670 --> 00:13:08,650
go into that case in this talk but you

00:13:06,880 --> 00:13:11,410
know just be aware that that's that's an

00:13:08,650 --> 00:13:13,390
option and as various open cafe

00:13:11,410 --> 00:13:15,700
accelerators come out we expect to see

00:13:13,390 --> 00:13:19,700
there will be kernel drivers also using

00:13:15,700 --> 00:13:22,650
OC excel for those types of devices

00:13:19,700 --> 00:13:25,200
um so how do I open cafe Fu is get

00:13:22,650 --> 00:13:27,990
exposed to user space

00:13:25,200 --> 00:13:29,520
this is UNIX everything is a file we

00:13:27,990 --> 00:13:33,840
have a directory it's called flash dev

00:13:29,520 --> 00:13:35,490
slash OC excel and we create a file we

00:13:33,840 --> 00:13:38,580
have a character device one for every

00:13:35,490 --> 00:13:40,250
AFU that we detect on a card so as you

00:13:38,580 --> 00:13:43,380
can see here we have a character device

00:13:40,250 --> 00:13:47,100
it's called IBM mem copy three and then

00:13:43,380 --> 00:13:52,530
the PCI device bus device and function

00:13:47,100 --> 00:13:55,260
number associated with it so the EJ of

00:13:52,530 --> 00:13:57,840
you has a name that's retrieved via

00:13:55,260 --> 00:14:01,530
config space and then placed into the

00:13:57,840 --> 00:14:04,290
file name there and applications

00:14:01,530 --> 00:14:06,450
interact with the AF you basically how

00:14:04,290 --> 00:14:09,690
you would expect in a unix-style

00:14:06,450 --> 00:14:14,880
everything's a file approach to allocate

00:14:09,690 --> 00:14:16,560
a context you call open and to attach

00:14:14,880 --> 00:14:19,740
the context so actually enable that

00:14:16,560 --> 00:14:21,720
context you use an I octal to retrieve

00:14:19,740 --> 00:14:23,910
device metadata you use an iocked also

00:14:21,720 --> 00:14:25,680
manage interrupts you use an i octal and

00:14:23,910 --> 00:14:28,980
when you're done with it all you close

00:14:25,680 --> 00:14:31,740
the file and it releases the context so

00:14:28,980 --> 00:14:32,970
OC excel also handles events that are

00:14:31,740 --> 00:14:34,860
coming from the device that includes

00:14:32,970 --> 00:14:38,640
interrupts as well as translation fault

00:14:34,860 --> 00:14:41,130
harrods and so that's done that's also

00:14:38,640 --> 00:14:43,500
managed through this through a file

00:14:41,130 --> 00:14:47,520
descriptor interface using the event FD

00:14:43,500 --> 00:14:49,230
subsystem forum event queue management

00:14:47,520 --> 00:14:54,390
and so that's also done through

00:14:49,230 --> 00:14:55,920
accessing this file um so to make all

00:14:54,390 --> 00:14:59,670
this easier

00:14:55,920 --> 00:15:01,440
we have Lib OC excel libo see excel is a

00:14:59,670 --> 00:15:03,180
very thin library that provides wrappers

00:15:01,440 --> 00:15:06,150
for all the AF humanik management

00:15:03,180 --> 00:15:10,200
functionality that is exposed by the OC

00:15:06,150 --> 00:15:12,330
excel driver again this is a the open

00:15:10,200 --> 00:15:14,670
capping successor to lid cxl which you

00:15:12,330 --> 00:15:18,270
may have used if you've used copy one or

00:15:14,670 --> 00:15:19,580
copy to and again it follows the same

00:15:18,270 --> 00:15:22,400
approach have been a very thin wrapper

00:15:19,580 --> 00:15:25,950
around that management functionality

00:15:22,400 --> 00:15:30,450
it's packaged in every cool distribution

00:15:25,950 --> 00:15:32,760
near you just up install it it's written

00:15:30,450 --> 00:15:35,090
in plain old c99 it has a gran

00:15:32,760 --> 00:15:37,950
total of one dependency which is woodsy

00:15:35,090 --> 00:15:39,420
it's designed to be really easy to

00:15:37,950 --> 00:15:41,370
integrate in a wide variety of

00:15:39,420 --> 00:15:43,890
applications so it's not a comprehensive

00:15:41,370 --> 00:15:45,540
framework or anything like that this is

00:15:43,890 --> 00:15:47,810
a lot lower level than the snap

00:15:45,540 --> 00:15:51,450
framework which you may have heard about

00:15:47,810 --> 00:15:53,430
it's it's really just a bear yeah the

00:15:51,450 --> 00:15:56,090
minimum you need to make it easy to

00:15:53,430 --> 00:15:58,770
access and manage an open capping device

00:15:56,090 --> 00:16:01,110
it's also available under the Apache

00:15:58,770 --> 00:16:03,600
License so it you know should be good to

00:16:01,110 --> 00:16:09,210
include in pretty much any application

00:16:03,600 --> 00:16:13,080
you want so in a moment I'm going to

00:16:09,210 --> 00:16:15,270
discuss the libo cxl api but before I go

00:16:13,080 --> 00:16:17,490
on it's probably just a good chance to

00:16:15,270 --> 00:16:21,300
mention the open copy simulation engine

00:16:17,490 --> 00:16:26,100
OCSE OCSE is a framework that allows

00:16:21,300 --> 00:16:28,920
developers to test their AFU you know

00:16:26,100 --> 00:16:31,440
very log or VHDL along with the their

00:16:28,920 --> 00:16:35,010
user space code so it's available

00:16:31,440 --> 00:16:36,780
through the open copy consortium and it

00:16:35,010 --> 00:16:40,440
essentially simulates everything that

00:16:36,780 --> 00:16:43,980
you can see in this red rectangle here

00:16:40,440 --> 00:16:45,540
so you have your AFU logic your HDL

00:16:43,980 --> 00:16:49,560
which you simulate using a simulator

00:16:45,540 --> 00:16:52,560
like NCCM or similar that exposes a

00:16:49,560 --> 00:16:55,380
socket to the simulation engine and on

00:16:52,560 --> 00:16:57,330
the other side it presents a alternative

00:16:55,380 --> 00:16:59,400
implementation of Lib OC excel which

00:16:57,330 --> 00:17:00,690
your application can use so I won't go

00:16:59,400 --> 00:17:02,010
into more detail but the point is you

00:17:00,690 --> 00:17:04,050
can simulate your a of you and you can

00:17:02,010 --> 00:17:07,320
test it using exactly the same code as

00:17:04,050 --> 00:17:11,190
you would on a real device so back to

00:17:07,320 --> 00:17:12,480
Lubo cxl let's go through an example now

00:17:11,190 --> 00:17:14,610
you may have noticed cafú i've got

00:17:12,480 --> 00:17:17,040
installed it's called mem copy mem copy

00:17:14,610 --> 00:17:18,630
is a sample AF you design made available

00:17:17,040 --> 00:17:20,220
through the open copy consortium to

00:17:18,630 --> 00:17:22,740
members and probably guess what it does

00:17:20,220 --> 00:17:24,180
you pass it the address of the effective

00:17:22,740 --> 00:17:25,920
addresses of two buffers in memory and

00:17:24,180 --> 00:17:27,710
it copies from one to the other it's

00:17:25,920 --> 00:17:30,090
very exciting

00:17:27,710 --> 00:17:32,940
Lib OC excel chips with a sample

00:17:30,090 --> 00:17:36,450
application that shows off all the key

00:17:32,940 --> 00:17:39,810
API functionality so we'll take a quick

00:17:36,450 --> 00:17:40,860
look through the sample source code the

00:17:39,810 --> 00:17:42,270
full example is quite long and

00:17:40,860 --> 00:17:45,660
comprehensive it shows off a lot more of

00:17:42,270 --> 00:17:46,770
the function the functionality of the

00:17:45,660 --> 00:17:48,150
library so what

00:17:46,770 --> 00:17:50,700
I'll show you here is a cup down sample

00:17:48,150 --> 00:17:52,110
it skips over the more advanced stuff or

00:17:50,700 --> 00:17:55,020
you know useless things like error

00:17:52,110 --> 00:17:56,730
handling I highly recommend you read the

00:17:55,020 --> 00:17:58,830
full thing you can find it in the libo

00:17:56,730 --> 00:18:00,330
CX or git repository and the samples

00:17:58,830 --> 00:18:04,440
directory

00:18:00,330 --> 00:18:07,110
so here's main we first call you know

00:18:04,440 --> 00:18:08,760
cxl AF you open that searches dev OC

00:18:07,110 --> 00:18:10,620
excel for an AF you that matches the

00:18:08,760 --> 00:18:13,500
right name and it opens it which sets up

00:18:10,620 --> 00:18:14,730
it allocates a context we allocate a

00:18:13,500 --> 00:18:18,840
couple of buffers source and destination

00:18:14,730 --> 00:18:20,970
we fill source we clear destination and

00:18:18,840 --> 00:18:24,390
then we do the mem copy we check the

00:18:20,970 --> 00:18:28,260
result and close CA a few so how do we

00:18:24,390 --> 00:18:29,400
actually do the mem copy well first we

00:18:28,260 --> 00:18:30,870
need to figure out how it is that we

00:18:29,400 --> 00:18:33,540
actually tell the AF you what it needs

00:18:30,870 --> 00:18:35,070
to do so obviously this is completely

00:18:33,540 --> 00:18:36,720
dependent on your particular application

00:18:35,070 --> 00:18:38,970
your accelerator and your hardware

00:18:36,720 --> 00:18:41,670
design but the approach to the mem copy

00:18:38,970 --> 00:18:44,190
a of you takes is defining a queue of

00:18:41,670 --> 00:18:45,960
work elements each work element

00:18:44,190 --> 00:18:50,460
represents a command or a particular job

00:18:45,960 --> 00:18:52,290
and the work element here you know as

00:18:50,460 --> 00:18:54,690
you can see it's a struct that's packed

00:18:52,290 --> 00:18:56,430
and laid out according to the hardware

00:18:54,690 --> 00:18:58,290
specification for this particular a of

00:18:56,430 --> 00:19:00,210
you it's got the kinds of fields you

00:18:58,290 --> 00:19:02,160
would expect it specifies a command it

00:19:00,210 --> 00:19:03,870
specifies a status it's got a pointer to

00:19:02,160 --> 00:19:07,590
the source and the destination and the

00:19:03,870 --> 00:19:10,530
links and we wrap that in a you know a

00:19:07,590 --> 00:19:12,120
pretty standard list so the way you

00:19:10,530 --> 00:19:13,350
manage workloads on your accellerate err

00:19:12,120 --> 00:19:15,090
is going to be completely dependent on

00:19:13,350 --> 00:19:17,430
exactly what it is that you are doing

00:19:15,090 --> 00:19:18,960
and the approach you choose to take you

00:19:17,430 --> 00:19:20,580
don't have to do this but this

00:19:18,960 --> 00:19:22,530
particular model of defining a queue of

00:19:20,580 --> 00:19:25,380
jobs you know it's kind of generally

00:19:22,530 --> 00:19:27,270
fairly common and an approach which will

00:19:25,380 --> 00:19:30,930
work for a lot of different types of

00:19:27,270 --> 00:19:32,820
accelerator workloads so this is the

00:19:30,930 --> 00:19:36,570
function where all the action happens so

00:19:32,820 --> 00:19:41,220
first we initialize a an empty work to

00:19:36,570 --> 00:19:43,140
you we prepare a work element descriptor

00:19:41,220 --> 00:19:45,570
that's basically just a pointer to the

00:19:43,140 --> 00:19:46,860
work to you so the fu knows where it is

00:19:45,570 --> 00:19:49,320
we do a little bit of bit twiddling

00:19:46,860 --> 00:19:51,450
there to tell it where the UM to embed

00:19:49,320 --> 00:19:54,300
the size of the work queue into that

00:19:51,450 --> 00:19:57,990
pointer as well we set up a work element

00:19:54,300 --> 00:20:00,940
with a copy command and a size and a

00:19:57,990 --> 00:20:02,710
source and destination pointer

00:20:00,940 --> 00:20:04,420
and note that we don't do anything

00:20:02,710 --> 00:20:06,820
special here to allocate any of this in

00:20:04,420 --> 00:20:09,250
a special memory region or anything like

00:20:06,820 --> 00:20:10,600
that the only things that we do when we

00:20:09,250 --> 00:20:13,060
allocate a work queue we make sure it's

00:20:10,600 --> 00:20:15,550
on a page aligned to boundary I'm not

00:20:13,060 --> 00:20:17,230
exactly sure why we do that but that's a

00:20:15,550 --> 00:20:20,290
requirement of this particular a if you

00:20:17,230 --> 00:20:21,700
design and we just make sure that the

00:20:20,290 --> 00:20:23,920
pointers are in the correct Indian this

00:20:21,700 --> 00:20:25,570
but we don't do anything special to put

00:20:23,920 --> 00:20:27,490
it in a you know there's no mm IO or

00:20:25,570 --> 00:20:29,230
anything involved at this point by the

00:20:27,490 --> 00:20:34,930
magic of address translation everything

00:20:29,230 --> 00:20:36,580
just magically works so we call OC excel

00:20:34,930 --> 00:20:40,090
a if you attach so that actually

00:20:36,580 --> 00:20:41,620
attaches the context which puts it you

00:20:40,090 --> 00:20:43,930
know that means that we write the the

00:20:41,620 --> 00:20:46,480
process element into the shared process

00:20:43,930 --> 00:20:48,870
area which causes the hardware to

00:20:46,480 --> 00:20:52,510
actually start doing address translation

00:20:48,870 --> 00:20:55,240
we map the password mm IO space that I

00:20:52,510 --> 00:20:57,370
mentioned earlier and so OC excel gives

00:20:55,240 --> 00:21:00,970
us a handle and it gives us a some

00:20:57,370 --> 00:21:03,100
access of functions to wrap that we

00:21:00,970 --> 00:21:06,870
allocate an interrupt for handling

00:21:03,100 --> 00:21:10,170
errors so the library and the driver

00:21:06,870 --> 00:21:12,490
provide a mechanism for allocating that

00:21:10,170 --> 00:21:14,710
so on power we actually allocate a

00:21:12,490 --> 00:21:16,090
trigger page for each interrupt and the

00:21:14,710 --> 00:21:17,700
interrupt handle is actually the

00:21:16,090 --> 00:21:20,170
effective address of that trigger page

00:21:17,700 --> 00:21:22,030
and when the open capping device sends

00:21:20,170 --> 00:21:24,730
an interrupt request with that

00:21:22,030 --> 00:21:26,470
particular effective address in it the

00:21:24,730 --> 00:21:27,940
hardware magically turns out into an

00:21:26,470 --> 00:21:30,640
interrupt that hits that trigger page

00:21:27,940 --> 00:21:33,070
and rises up through the kernel and so

00:21:30,640 --> 00:21:34,800
the OC excel driver exposes those

00:21:33,070 --> 00:21:37,680
interrupt events as I mentioned through

00:21:34,800 --> 00:21:41,440
event FD through a file descriptor and

00:21:37,680 --> 00:21:43,090
libo cxl provides wrappers to access

00:21:41,440 --> 00:21:44,380
that event queue and see and process

00:21:43,090 --> 00:21:48,070
events as they're coming in like a

00:21:44,380 --> 00:21:50,380
select style on a pole style api i won't

00:21:48,070 --> 00:21:55,690
go into that here but you can see that

00:21:50,380 --> 00:21:59,140
in the source code if you look at it so

00:21:55,690 --> 00:22:02,080
we give the work element descriptor to

00:21:59,140 --> 00:22:04,570
the AF you by again by using an mm I oh

00:22:02,080 --> 00:22:07,060
right to the particular offset where we

00:22:04,570 --> 00:22:09,430
write the word and at this point now

00:22:07,060 --> 00:22:12,940
that the web has been said the AF you

00:22:09,430 --> 00:22:14,170
use continually polling that that queue

00:22:12,940 --> 00:22:16,300
for incoming

00:22:14,170 --> 00:22:23,350
that's the way this particular a few was

00:22:16,300 --> 00:22:24,610
designed so we then add the the copy

00:22:23,350 --> 00:22:26,590
work element that we were defining

00:22:24,610 --> 00:22:29,110
earlier into the work queue as our first

00:22:26,590 --> 00:22:30,610
work element we then add a stop work

00:22:29,110 --> 00:22:32,950
element as well

00:22:30,610 --> 00:22:34,870
which tells cafú that this is the end of

00:22:32,950 --> 00:22:38,740
the queue and it can stop trying to

00:22:34,870 --> 00:22:40,060
process anything so we've added all that

00:22:38,740 --> 00:22:41,710
we've now got a complete work queue

00:22:40,060 --> 00:22:43,540
we've now got a work element descriptor

00:22:41,710 --> 00:22:46,990
which has now been the queue is now

00:22:43,540 --> 00:22:51,010
being polled again the word is just an

00:22:46,990 --> 00:22:52,600
effective address and the AFU is reading

00:22:51,010 --> 00:22:54,640
that through its effective address and

00:22:52,600 --> 00:22:58,470
address translation is happening to

00:22:54,640 --> 00:23:00,940
return that data from main system memory

00:22:58,470 --> 00:23:02,440
so in order to kick everything off we

00:23:00,940 --> 00:23:04,390
first do a memory barrier to make sure

00:23:02,440 --> 00:23:07,800
everything's written and then we just

00:23:04,390 --> 00:23:11,410
set a valid bit on the first mem copy

00:23:07,800 --> 00:23:13,000
work element to tell the AFU that that

00:23:11,410 --> 00:23:14,380
every all the details have now been

00:23:13,000 --> 00:23:17,050
written out and it can now start to

00:23:14,380 --> 00:23:19,540
process it and just remember this is

00:23:17,050 --> 00:23:22,290
just flipping a bit in main system Ram

00:23:19,540 --> 00:23:25,890
it's not mm IO or anything like that

00:23:22,290 --> 00:23:29,380
it's just a regular old store

00:23:25,890 --> 00:23:31,600
instruction and the AF you will see that

00:23:29,380 --> 00:23:33,460
the the next time it pulls the cue and

00:23:31,600 --> 00:23:35,530
sees that there's now a valid command

00:23:33,460 --> 00:23:37,720
for it to execute so at this point the

00:23:35,530 --> 00:23:40,660
AFU is picked that up it will commence a

00:23:37,720 --> 00:23:42,010
copy and now all we need to do is wait

00:23:40,660 --> 00:23:43,510
for it to complete obviously it's

00:23:42,010 --> 00:23:45,010
asynchronous so you know in the real

00:23:43,510 --> 00:23:46,810
world application you may not want to

00:23:45,010 --> 00:23:50,080
wait for it to complete but in this case

00:23:46,810 --> 00:23:51,430
this example is a benchmark so we want

00:23:50,080 --> 00:23:54,430
to wait for it to complete and then do

00:23:51,430 --> 00:23:56,710
our own timing so I won't go into

00:23:54,430 --> 00:23:59,440
exactly and what this function does here

00:23:56,710 --> 00:24:01,450
but you know the simplest way obviously

00:23:59,440 --> 00:24:02,740
is to just have a loop that continually

00:24:01,450 --> 00:24:04,980
pulls the status field of the work

00:24:02,740 --> 00:24:08,470
element until it sees a complete bit

00:24:04,980 --> 00:24:10,990
which you know that's the naive approach

00:24:08,470 --> 00:24:13,450
it's not particularly efficient but the

00:24:10,990 --> 00:24:15,040
a if you also supports setting up an

00:24:13,450 --> 00:24:17,680
interrupt and waiting for an interrupt

00:24:15,040 --> 00:24:20,320
event and it also supports the wake host

00:24:17,680 --> 00:24:22,750
thread feature which is where a hardware

00:24:20,320 --> 00:24:25,870
thread can go directly to sleep

00:24:22,750 --> 00:24:26,980
using the power is a 3.0 wait

00:24:25,870 --> 00:24:30,460
instruction

00:24:26,980 --> 00:24:32,559
and then the device can send a wake host

00:24:30,460 --> 00:24:34,840
thread command that immediately causes

00:24:32,559 --> 00:24:35,980
that thread to to wake up and it can

00:24:34,840 --> 00:24:37,929
then check the queue to find out that

00:24:35,980 --> 00:24:39,549
it's complete so I'm gonna go into that

00:24:37,929 --> 00:24:40,900
here but again it's available in the

00:24:39,549 --> 00:24:42,580
source code you can see how it's how we

00:24:40,900 --> 00:24:47,169
do it it's not particularly interesting

00:24:42,580 --> 00:24:48,400
it's very very simple so if you take all

00:24:47,169 --> 00:24:50,230
that code and then add in all the

00:24:48,400 --> 00:24:51,610
logging and error handling and all the

00:24:50,230 --> 00:24:52,840
other stuff I've skipped over it ends up

00:24:51,610 --> 00:24:55,210
being about six hundred lines of code

00:24:52,840 --> 00:24:57,490
altogether this is a sample program

00:24:55,210 --> 00:24:59,350
actually running we set up a two

00:24:57,490 --> 00:25:01,480
kilobytes source buffer and destination

00:24:59,350 --> 00:25:03,970
buffer we set up a work element cube

00:25:01,480 --> 00:25:07,330
memory gets copied and it gets copied

00:25:03,970 --> 00:25:09,730
correctly so obviously this is a very

00:25:07,330 --> 00:25:11,500
simple example but I hope this shows you

00:25:09,730 --> 00:25:13,179
that these are all the main things that

00:25:11,500 --> 00:25:16,929
you need to start building an open copy

00:25:13,179 --> 00:25:18,340
application using libo cxl one of the

00:25:16,929 --> 00:25:20,350
main advantages of the open copy

00:25:18,340 --> 00:25:22,030
programming model is that with coherence

00:25:20,350 --> 00:25:23,559
and with address translation it's really

00:25:22,030 --> 00:25:25,210
low overhead it's really easy to get

00:25:23,559 --> 00:25:28,000
started and it's really easy to just

00:25:25,210 --> 00:25:30,760
integrate this into you know into

00:25:28,000 --> 00:25:33,940
existing applications without you know

00:25:30,760 --> 00:25:36,790
needing to intrude too much on the way

00:25:33,940 --> 00:25:39,370
that you currently write your code and

00:25:36,790 --> 00:25:41,049
so with the OC x or kernel driver and

00:25:39,370 --> 00:25:43,840
the Lib OC Excel library doing all the

00:25:41,049 --> 00:25:46,960
heavy lifting of AFU management and

00:25:43,840 --> 00:25:50,679
device management for you it's really

00:25:46,960 --> 00:25:51,910
quite easy to get started so there's

00:25:50,679 --> 00:25:54,280
more stuff which I haven't got the time

00:25:51,910 --> 00:25:56,320
to go into here so firstly I would

00:25:54,280 --> 00:25:58,720
recommend that you check out the rest of

00:25:56,320 --> 00:26:03,250
the libo cxl api documentation so that's

00:25:58,720 --> 00:26:04,390
available at open copy github do and of

00:26:03,250 --> 00:26:06,010
course there's also more information

00:26:04,390 --> 00:26:07,750
about open Cappy more generally

00:26:06,010 --> 00:26:11,919
available on the open Cappy consortium

00:26:07,750 --> 00:26:14,280
website at open copy dog um so yeah

00:26:11,919 --> 00:26:14,280
thank you

00:26:15,230 --> 00:26:19,259
you

00:26:15,940 --> 00:26:19,259

YouTube URL: https://www.youtube.com/watch?v=zCIMHbZDRS0


