Title: OpenPOWER Summit Europe 2018: OpenCAPI Memory Interface
Publication date: 2018-11-14
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Jeff Steucheli speaks at OpenPOWER Foundation's OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:01,110 --> 00:00:06,540
so this is a session on open Cappy

00:00:04,479 --> 00:00:08,949
memory interface there was just one

00:00:06,540 --> 00:00:12,250
previously your slides were a little

00:00:08,949 --> 00:00:13,480
better than mine but talk a little bit

00:00:12,250 --> 00:00:16,119
about what we're doing here

00:00:13,480 --> 00:00:18,310
my conglomerated slides from several

00:00:16,119 --> 00:00:20,590
different sources so hopefully kind of

00:00:18,310 --> 00:00:22,780
present a reasonably consistent view of

00:00:20,590 --> 00:00:27,430
what we're doing but just trying to give

00:00:22,780 --> 00:00:28,840
a basic overview of of that so I stole

00:00:27,430 --> 00:00:30,460
this slide I think everybody needs to

00:00:28,840 --> 00:00:32,770
acknowledge who they stole their slides

00:00:30,460 --> 00:00:36,930
from this was from Brian Allison thank

00:00:32,770 --> 00:00:40,390
you so the industry landscape here is

00:00:36,930 --> 00:00:41,920
essentially we have and this is I think

00:00:40,390 --> 00:00:44,200
the next I have a couple slides that all

00:00:41,920 --> 00:00:46,750
kind of work around the same topic here

00:00:44,200 --> 00:00:49,329
but we have heterogeneous computing

00:00:46,750 --> 00:00:51,969
which means we need to attach you know

00:00:49,329 --> 00:00:54,640
network offload GPUs other types of

00:00:51,969 --> 00:00:57,820
accelerators close to the processor we

00:00:54,640 --> 00:01:00,370
have new emerging memory types right so

00:00:57,820 --> 00:01:03,129
before pretty much DRAM was all that was

00:01:00,370 --> 00:01:05,950
on the horizon forever and now we have a

00:01:03,129 --> 00:01:08,319
variety of new technologies sort of on

00:01:05,950 --> 00:01:11,259
various horizons we'll see which ones

00:01:08,319 --> 00:01:13,329
win first we've got Ken with his hybrid

00:01:11,259 --> 00:01:16,299
one which I actually like quite a bit

00:01:13,329 --> 00:01:17,799
there's Rahl phase change memory devices

00:01:16,299 --> 00:01:19,380
and there's actually a pretty long list

00:01:17,799 --> 00:01:22,179
of things that we're looking at

00:01:19,380 --> 00:01:26,049
internally you know different DRAM

00:01:22,179 --> 00:01:27,759
targetting points different types of if

00:01:26,049 --> 00:01:29,499
somebody was presenting a few weeks ago

00:01:27,759 --> 00:01:31,450
at hot chips on you know carbon

00:01:29,499 --> 00:01:33,670
nanotubes memory all right which was

00:01:31,450 --> 00:01:36,179
actually a good presentation if we

00:01:33,670 --> 00:01:38,229
should all be buying it by now right

00:01:36,179 --> 00:01:41,289
it was it I don't know who was at that

00:01:38,229 --> 00:01:43,359
talk but he basically said I made a ddr4

00:01:41,289 --> 00:01:45,849
compliant device it's like cheaper

00:01:43,359 --> 00:01:47,409
faster better but there's a whole bunch

00:01:45,849 --> 00:01:49,749
of new memory technology some are more

00:01:47,409 --> 00:01:50,889
vaporware than others but we have to be

00:01:49,749 --> 00:01:52,929
able to quickly adapt to those and

00:01:50,889 --> 00:01:55,689
that's a big part of what open copy

00:01:52,929 --> 00:01:58,139
memory is is the ability to plug in

00:01:55,689 --> 00:02:00,880
different types of memory into your box

00:01:58,139 --> 00:02:04,149
so let's look at this one this I think I

00:02:00,880 --> 00:02:07,179
took from Macready from Brad so here we

00:02:04,149 --> 00:02:09,009
have and and I like this in some regards

00:02:07,179 --> 00:02:11,830
but on the other sides there's things I

00:02:09,009 --> 00:02:14,110
miss so yesterday's plumbing is

00:02:11,830 --> 00:02:14,470
tomorrow's differentiation definitely

00:02:14,110 --> 00:02:17,890
think that

00:02:14,470 --> 00:02:20,040
true you'd used to just be DDR memory no

00:02:17,890 --> 00:02:22,570
real way to differentiate though we did

00:02:20,040 --> 00:02:24,040
historically IBM has differentiated on

00:02:22,570 --> 00:02:25,420
memory with our buffered memory

00:02:24,040 --> 00:02:27,640
solutions if you look at what we've been

00:02:25,420 --> 00:02:29,410
doing we've always had we've been doing

00:02:27,640 --> 00:02:32,230
buffered memory for a long time to give

00:02:29,410 --> 00:02:34,510
us capacity and reliability out of

00:02:32,230 --> 00:02:36,490
really what is a commodity DRAM chip

00:02:34,510 --> 00:02:37,720
that goes across a broad range of

00:02:36,490 --> 00:02:39,910
computers and so if you're trying to

00:02:37,720 --> 00:02:42,910
build a high scalability Enterprise

00:02:39,910 --> 00:02:44,380
Server a mainframe whatnot in here all

00:02:42,910 --> 00:02:45,850
you have to work with is these commodity

00:02:44,380 --> 00:02:47,620
DRAM chips you kind of got to do

00:02:45,850 --> 00:02:49,360
something special to make them resilient

00:02:47,620 --> 00:02:50,740
enough for your usage so we've been

00:02:49,360 --> 00:02:52,510
doing that forever and that's part of

00:02:50,740 --> 00:02:55,810
what we're providing to the overall

00:02:52,510 --> 00:02:58,450
ecosystem here is taking our experience

00:02:55,810 --> 00:02:59,950
in that space and conveying that into an

00:02:58,450 --> 00:03:01,959
open standard which is what the open

00:02:59,950 --> 00:03:05,320
Cappy thing is the other side of things

00:03:01,959 --> 00:03:08,050
is i/o PCIe I actually think is a pretty

00:03:05,320 --> 00:03:11,020
good standard compared to even previous

00:03:08,050 --> 00:03:12,850
PCIe the switches have pretty good you

00:03:11,020 --> 00:03:13,570
know that high frequency Surtees right

00:03:12,850 --> 00:03:16,360
there are actually pretty good

00:03:13,570 --> 00:03:17,980
interfaces for connectivity especially

00:03:16,360 --> 00:03:20,320
of lower latency or higher latency

00:03:17,980 --> 00:03:22,360
devices if your device is in the mini

00:03:20,320 --> 00:03:25,180
you know 100 microseconds 10

00:03:22,360 --> 00:03:28,180
microseconds PCIe is reasonably good at

00:03:25,180 --> 00:03:31,209
transferring to those but PCIe is really

00:03:28,180 --> 00:03:32,650
centric around you know DMA transfers

00:03:31,209 --> 00:03:34,660
there's quite a bit of latency in the

00:03:32,650 --> 00:03:36,940
path and it's not really designed to be

00:03:34,660 --> 00:03:38,500
tightly coupled to the device so how we

00:03:36,940 --> 00:03:41,790
like to differentiate is doing things

00:03:38,500 --> 00:03:45,250
better than PCIe what we have today is

00:03:41,790 --> 00:03:49,420
Nvidia and V link which makes our AC

00:03:45,250 --> 00:03:51,760
9:22 computer our summit systems very

00:03:49,420 --> 00:03:54,370
differentiated but this is a proprietary

00:03:51,760 --> 00:03:56,590
standard so right and V links

00:03:54,370 --> 00:03:58,150
proprietary a big part of what open copy

00:03:56,590 --> 00:04:01,180
in general is is building an open

00:03:58,150 --> 00:04:03,010
interface on that right so but yesterday

00:04:01,180 --> 00:04:04,570
is plumbing the thing I somewhat don't

00:04:03,010 --> 00:04:06,940
like about this is it sort of you know

00:04:04,570 --> 00:04:08,920
cores and caches those aren't a

00:04:06,940 --> 00:04:11,170
commodity device yet I'm a big part of

00:04:08,920 --> 00:04:13,330
my job at IBM is designing the cores and

00:04:11,170 --> 00:04:15,580
caches and so we're still continuing to

00:04:13,330 --> 00:04:17,049
differentiate and build better cores in

00:04:15,580 --> 00:04:19,180
caches but it is becoming more

00:04:17,049 --> 00:04:22,330
challenging with the whole Moore's Law

00:04:19,180 --> 00:04:25,960
thing on the you know happening anyway

00:04:22,330 --> 00:04:28,360
let's keep going so we're back to want

00:04:25,960 --> 00:04:30,699
to brine sides so

00:04:28,360 --> 00:04:33,419
when we look at what open Cappy has to

00:04:30,699 --> 00:04:36,430
do it has to manage these new memory

00:04:33,419 --> 00:04:39,819
storage kind of hybrid devices is it a

00:04:36,430 --> 00:04:41,020
storage device is it a memory device we

00:04:39,819 --> 00:04:42,400
also have to be able to deal with

00:04:41,020 --> 00:04:44,620
Network offload that's what the last

00:04:42,400 --> 00:04:45,699
session this room was about and so we've

00:04:44,620 --> 00:04:46,960
got to do all these different things

00:04:45,699 --> 00:04:48,610
right

00:04:46,960 --> 00:04:50,860
there's nothing today that really lets

00:04:48,610 --> 00:04:53,590
us do that especially in a hybrid way

00:04:50,860 --> 00:04:55,000
right if it's a sort of a memory and a

00:04:53,590 --> 00:04:57,969
storage device it might need to do

00:04:55,000 --> 00:05:00,099
things that memory it may need to master

00:04:57,969 --> 00:05:02,400
commands maybe just to go tell the

00:05:00,099 --> 00:05:04,509
processor hey I've run out of

00:05:02,400 --> 00:05:06,099
decompressed memory or I need some kind

00:05:04,509 --> 00:05:07,090
of maintenance on my structures you

00:05:06,099 --> 00:05:11,289
can't really do that very efficiently

00:05:07,090 --> 00:05:13,840
across a DDR interface today we also

00:05:11,289 --> 00:05:16,479
have yeah you know deep learning

00:05:13,840 --> 00:05:17,860
obviously there's the computational

00:05:16,479 --> 00:05:19,629
demands have grown beyond what they used

00:05:17,860 --> 00:05:22,029
to be as well historically when we made

00:05:19,629 --> 00:05:24,370
servers they all ran you know much of

00:05:22,029 --> 00:05:27,099
them ran OLTP right as a big database

00:05:24,370 --> 00:05:29,319
server now we've got people are actually

00:05:27,099 --> 00:05:36,370
deploying machine learning deep learning

00:05:29,319 --> 00:05:37,479
into actually ecosystems and so we got a

00:05:36,370 --> 00:05:38,860
bunch of different things we need to

00:05:37,479 --> 00:05:41,469
build into our boss we need to be

00:05:38,860 --> 00:05:42,639
coherence I need to have that for the

00:05:41,469 --> 00:05:44,680
acceleration tightly coupled

00:05:42,639 --> 00:05:47,889
accelerators tightly covered net coupled

00:05:44,680 --> 00:05:50,020
network offload but really the one we're

00:05:47,889 --> 00:05:52,029
talking here about is we need to be able

00:05:50,020 --> 00:05:54,849
to take different memory technologies

00:05:52,029 --> 00:05:57,580
and plug those into our processor right

00:05:54,849 --> 00:06:00,219
so how do we do this we got to have open

00:05:57,580 --> 00:06:01,569
ecosystem we have to you couldn't do

00:06:00,219 --> 00:06:03,520
this as a PCIe right so if we're looking

00:06:01,569 --> 00:06:05,979
at where we're at today we've got DDR

00:06:03,520 --> 00:06:08,680
ddr2 I'd to one memory technology

00:06:05,979 --> 00:06:10,900
deterministic latency pretty much zero

00:06:08,680 --> 00:06:13,479
flexibility and then you've got PCIe

00:06:10,900 --> 00:06:15,370
which has much too high latency and no

00:06:13,479 --> 00:06:16,719
way to build coherence across it and so

00:06:15,370 --> 00:06:20,610
we're really merging those two things

00:06:16,719 --> 00:06:23,409
together into one performance solution

00:06:20,610 --> 00:06:25,839
so that's our you know that's how kind

00:06:23,409 --> 00:06:28,449
of open Kathy was born right is to take

00:06:25,839 --> 00:06:30,279
something new and then build it better

00:06:28,449 --> 00:06:31,689
now that's said a big part of what we're

00:06:30,279 --> 00:06:34,419
doing let's talk a little bit about

00:06:31,689 --> 00:06:36,729
what's not in open Cappy

00:06:34,419 --> 00:06:40,120
part of the reason PCIe has higher

00:06:36,729 --> 00:06:41,770
latency is it's very strict packets so

00:06:40,120 --> 00:06:42,160
it has packets the packet you can go

00:06:41,770 --> 00:06:43,870
through peace

00:06:42,160 --> 00:06:46,360
switches everything's sort of

00:06:43,870 --> 00:06:48,610
self-contained within one CRC code open

00:06:46,360 --> 00:06:51,970
copy based around our experience with

00:06:48,610 --> 00:06:54,490
copy and the DMI memory interface has a

00:06:51,970 --> 00:06:56,650
very a naked interface the the

00:06:54,490 --> 00:06:58,510
complexity of it it's very tightly

00:06:56,650 --> 00:07:00,070
coupled to the processor which in some

00:06:58,510 --> 00:07:04,360
senses means it doesn't encapsulate

00:07:00,070 --> 00:07:06,130
things as well as PCIe or Gen Z does so

00:07:04,360 --> 00:07:09,190
what we have is essentially a way to put

00:07:06,130 --> 00:07:10,390
logic on an accelerator or memory and be

00:07:09,190 --> 00:07:12,790
able to get back and forth to the

00:07:10,390 --> 00:07:15,190
processor with very small packets and

00:07:12,790 --> 00:07:17,170
very specifically formatted packets I

00:07:15,190 --> 00:07:20,590
don't talk about this in the session

00:07:17,170 --> 00:07:23,320
here but the packets are strictly

00:07:20,590 --> 00:07:25,840
aligned to a specific cycle ratio in the

00:07:23,320 --> 00:07:27,400
processor so when we send a 64 byte

00:07:25,840 --> 00:07:29,620
chunk of data between the processor and

00:07:27,400 --> 00:07:31,270
the device we know that that will land

00:07:29,620 --> 00:07:33,400
on a specific clock boundary on the

00:07:31,270 --> 00:07:34,960
touch device because of that that means

00:07:33,400 --> 00:07:36,820
we can start to interpret the data very

00:07:34,960 --> 00:07:38,380
quickly right so everything's very

00:07:36,820 --> 00:07:40,840
specific packet formats where you

00:07:38,380 --> 00:07:42,880
basically taking logic from the CPU and

00:07:40,840 --> 00:07:44,260
sticking it right in the middle as if it

00:07:42,880 --> 00:07:46,360
was in the same pipeline as the

00:07:44,260 --> 00:07:48,190
processor in the accelerator or the

00:07:46,360 --> 00:07:50,110
memory device so because of that they're

00:07:48,190 --> 00:07:52,600
very tightly coupled it's not very

00:07:50,110 --> 00:07:53,710
amenable to switch topologies because

00:07:52,600 --> 00:07:55,810
you're not you know it's it's really

00:07:53,710 --> 00:07:58,090
designed to talk to one device as if it

00:07:55,810 --> 00:08:00,460
was on the processor not to go talk to a

00:07:58,090 --> 00:08:02,620
network so you got to keep that in mind

00:08:00,460 --> 00:08:05,350
for these devices it's really putting

00:08:02,620 --> 00:08:07,690
accelerators on the CPU but in a sort of

00:08:05,350 --> 00:08:09,490
a one-to-one way but that's what we're

00:08:07,690 --> 00:08:11,290
that's the target here and we want to do

00:08:09,490 --> 00:08:13,090
the same thing with being memory or

00:08:11,290 --> 00:08:17,380
accelerators who both want them to be as

00:08:13,090 --> 00:08:19,690
if they were on the processor day so

00:08:17,380 --> 00:08:22,060
here is a chart this one from did Bruce

00:08:19,690 --> 00:08:23,260
do this did Brian do this Brian thanks

00:08:22,060 --> 00:08:28,000
everybody raise your hand about your

00:08:23,260 --> 00:08:30,550
chart and so here it shows the continuum

00:08:28,000 --> 00:08:33,280
right so the open Kathy interface we

00:08:30,550 --> 00:08:36,190
want to be able to have you plug in one

00:08:33,280 --> 00:08:38,800
of these which is memory all right so

00:08:36,190 --> 00:08:41,560
just DDR buffered memory goes into a

00:08:38,800 --> 00:08:44,310
slot maybe instead of memory you want to

00:08:41,560 --> 00:08:46,930
plug in something that has

00:08:44,310 --> 00:08:49,900
non-deterministic latency right this one

00:08:46,930 --> 00:08:51,310
the latency goes out here DDR is pretty

00:08:49,900 --> 00:08:52,839
deterministic it's pretty short

00:08:51,310 --> 00:08:55,390
but what if you want to go to something

00:08:52,839 --> 00:08:56,430
that's SCM that may have really long

00:08:55,390 --> 00:08:59,020
right Layton's

00:08:56,430 --> 00:09:02,740
another thing to talk about especially

00:08:59,020 --> 00:09:06,130
relative to DDR is rights on this

00:09:02,740 --> 00:09:08,650
interface are explicitly acknowledged so

00:09:06,130 --> 00:09:11,200
when you do a right to DDR you just

00:09:08,650 --> 00:09:13,690
shove the bits across and then you

00:09:11,200 --> 00:09:15,310
assume it completed which is a bit of a

00:09:13,690 --> 00:09:17,830
problem when you're looking at power

00:09:15,310 --> 00:09:20,320
failure transitions so if your box power

00:09:17,830 --> 00:09:22,870
goes out and you're in the middle of

00:09:20,320 --> 00:09:24,280
doing a DDR right did it complete or did

00:09:22,870 --> 00:09:27,700
it not complete right you don't really

00:09:24,280 --> 00:09:30,640
know so what we can do here with open

00:09:27,700 --> 00:09:32,770
copy is the controller here can say oh

00:09:30,640 --> 00:09:35,110
this right completed that can then let

00:09:32,770 --> 00:09:37,270
the fence and the CPU say yes software

00:09:35,110 --> 00:09:38,410
or the right did definitely complete and

00:09:37,270 --> 00:09:40,900
so we can do things that we can start to

00:09:38,410 --> 00:09:43,000
get to SCM and other types of devices we

00:09:40,900 --> 00:09:44,770
can buffer up rights maybe they are not

00:09:43,000 --> 00:09:46,360
yet persistent but they've been

00:09:44,770 --> 00:09:47,830
acknowledged by the controller and we

00:09:46,360 --> 00:09:50,230
could put some amount of capacitance on

00:09:47,830 --> 00:09:52,570
the controller or maybe it's in it's in

00:09:50,230 --> 00:09:55,810
its own power domain right so this is a

00:09:52,570 --> 00:09:57,340
connector or it could be a cable so the

00:09:55,810 --> 00:09:59,740
memory device here could actually be in

00:09:57,340 --> 00:10:01,540
some other appliance sitting next to the

00:09:59,740 --> 00:10:03,880
processor that you're doing loads and

00:10:01,540 --> 00:10:05,920
stores to write so that other box has

00:10:03,880 --> 00:10:07,900
its own power domain and so as soon as

00:10:05,920 --> 00:10:10,030
the right makes it across the other box

00:10:07,900 --> 00:10:12,040
can acknowledge it the processor could

00:10:10,030 --> 00:10:14,200
fail and we've had a very clean hand off

00:10:12,040 --> 00:10:16,540
of the right across the interface so

00:10:14,200 --> 00:10:19,540
that's like a storage class memory other

00:10:16,540 --> 00:10:22,900
things we could do is you know this is

00:10:19,540 --> 00:10:25,390
showing it as you know sort of cascaded

00:10:22,900 --> 00:10:26,410
open Kathy interfaces but really the

00:10:25,390 --> 00:10:28,270
device here that's probably more

00:10:26,410 --> 00:10:30,850
relevant is possibly a device that has

00:10:28,270 --> 00:10:32,080
both DDR in it and other types of memory

00:10:30,850 --> 00:10:33,670
and this is really what Ken's

00:10:32,080 --> 00:10:36,160
would you say this this is close enough

00:10:33,670 --> 00:10:39,100
match to what kins thing was doing right

00:10:36,160 --> 00:10:40,780
so we got DDR which is frequently

00:10:39,100 --> 00:10:43,360
accessed and then you have some other

00:10:40,780 --> 00:10:45,160
larger pool of memory that you use as

00:10:43,360 --> 00:10:47,110
sort of a second level tiered memory

00:10:45,160 --> 00:10:49,720
solution and so the goal here in these

00:10:47,110 --> 00:10:51,640
cases it's maybe SCM but maybe it's

00:10:49,720 --> 00:10:53,920
really just cheap memory all right DRAM

00:10:51,640 --> 00:10:55,480
is quite expensive some of your data

00:10:53,920 --> 00:10:56,980
needs to be in DRAM because it's

00:10:55,480 --> 00:10:59,740
frequently accessed but some of your

00:10:56,980 --> 00:11:01,180
data is pretty cold but that said you

00:10:59,740 --> 00:11:02,620
still need to be able to load to it

00:11:01,180 --> 00:11:05,380
without having you know you can't do a

00:11:02,620 --> 00:11:08,020
load to it spinning disk for example

00:11:05,380 --> 00:11:10,060
really even in nvme unless you can make

00:11:08,020 --> 00:11:12,880
it infrequent right so we got to have

00:11:10,060 --> 00:11:14,260
reasonable latency here but not hanging

00:11:12,880 --> 00:11:15,370
the processor and so that's kind of what

00:11:14,260 --> 00:11:19,570
we're doing with these two scenarios

00:11:15,370 --> 00:11:21,750
here it's mixing those two so that

00:11:19,570 --> 00:11:25,240
brings us into this form factor

00:11:21,750 --> 00:11:28,000
discussion so we have a variety of form

00:11:25,240 --> 00:11:30,910
factors these plug into a connector that

00:11:28,000 --> 00:11:32,980
we actually co-developed through jeddak

00:11:30,910 --> 00:11:34,960
we didn't start with this connector

00:11:32,980 --> 00:11:36,820
right we started with more of a DDR like

00:11:34,960 --> 00:11:38,320
looking connector and we had a little

00:11:36,820 --> 00:11:40,600
bit of arm twisting to get to this

00:11:38,320 --> 00:11:42,670
connector you know if you went to like a

00:11:40,600 --> 00:11:45,610
gin Z presentation you will see this is

00:11:42,670 --> 00:11:47,710
the exact same connector as Gen Z so we

00:11:45,610 --> 00:11:49,960
are working with other companies we are

00:11:47,710 --> 00:11:52,060
moving our standard that's probably a

00:11:49,960 --> 00:11:54,670
good thing to state is this isn't just

00:11:52,060 --> 00:11:56,800
IBM saying okay world here is open copy

00:11:54,670 --> 00:11:58,300
it's an open standard but we dictated it

00:11:56,800 --> 00:11:59,710
we actually moved our standard quite a

00:11:58,300 --> 00:12:03,040
bit to match what other organizations

00:11:59,710 --> 00:12:05,980
were trying to do and so gen Z which is

00:12:03,040 --> 00:12:08,500
a switched memory fabric not as low

00:12:05,980 --> 00:12:10,450
latency is open copy but it does use the

00:12:08,500 --> 00:12:12,700
same differential signaling on the same

00:12:10,450 --> 00:12:14,230
connector and so somebody could build a

00:12:12,700 --> 00:12:15,910
system that you could plug a gin z

00:12:14,230 --> 00:12:18,610
device in or you can plug an open cap

00:12:15,910 --> 00:12:20,590
you device in and that connector is this

00:12:18,610 --> 00:12:22,930
is showing a dim like just to be a dim

00:12:20,590 --> 00:12:24,460
form factor but there could be a cable

00:12:22,930 --> 00:12:28,120
that goes on here and that cable could

00:12:24,460 --> 00:12:30,820
run out to to an i/o drawer or you could

00:12:28,120 --> 00:12:33,520
put your SCM memory you know directly on

00:12:30,820 --> 00:12:36,490
in the and the slot itself but this

00:12:33,520 --> 00:12:38,710
gives us composable systems right we

00:12:36,490 --> 00:12:42,310
could build high bandwidth low capacity

00:12:38,710 --> 00:12:44,860
for HPC type systems for something like

00:12:42,310 --> 00:12:47,410
an SI p hanno we could do SCM to give it

00:12:44,860 --> 00:12:49,750
lots of capacity and a higher form

00:12:47,410 --> 00:12:52,960
factor the other nice thing I'll mention

00:12:49,750 --> 00:12:55,300
that memory cards today are pretty short

00:12:52,960 --> 00:12:57,820
which works in a 1u server but if you're

00:12:55,300 --> 00:12:59,470
in a to you or a 4u server you'd really

00:12:57,820 --> 00:13:00,640
like to just keep going up right so

00:12:59,470 --> 00:13:03,640
that's how we can get the high volume

00:13:00,640 --> 00:13:07,680
capacities of memory bigger server same

00:13:03,640 --> 00:13:11,380
motherboard but taller dim capability

00:13:07,680 --> 00:13:14,320
okay so lots and this is also you'll see

00:13:11,380 --> 00:13:16,570
this is sort of our our higher

00:13:14,320 --> 00:13:18,990
reliability dam it has redundant voltage

00:13:16,570 --> 00:13:22,810
regulators on it so we can still build

00:13:18,990 --> 00:13:23,889
enterprise class memory on the same

00:13:22,810 --> 00:13:26,319
interface here it's

00:13:23,889 --> 00:13:29,489
it's a question of do you put big or

00:13:26,319 --> 00:13:33,459
small so let's talk a little bit about

00:13:29,489 --> 00:13:35,709
how we've taken next slides next a

00:13:33,459 --> 00:13:38,529
little bit here is what do we have today

00:13:35,709 --> 00:13:40,059
and power 9 how does it work well how

00:13:38,529 --> 00:13:43,350
does it not work well and how does that

00:13:40,059 --> 00:13:47,079
transition into what open copy is today

00:13:43,350 --> 00:13:49,779
memory in particular so today we have on

00:13:47,079 --> 00:13:52,899
our memory subsystem and power 9 we have

00:13:49,779 --> 00:13:55,239
our this is our industry standard cost

00:13:52,899 --> 00:13:56,679
density optimized solution the only

00:13:55,239 --> 00:14:00,429
thing that was available when we started

00:13:56,679 --> 00:14:03,040
power 9 was DDR memory we hadn't built

00:14:00,429 --> 00:14:05,619
open Cathi memory yet so we needed a

00:14:03,040 --> 00:14:07,569
dense solution why do we need a dense

00:14:05,619 --> 00:14:10,109
solution a low-cost solution the

00:14:07,569 --> 00:14:13,389
buffered memory solution we had which is

00:14:10,109 --> 00:14:15,429
great is this Centaur memory buffer the

00:14:13,389 --> 00:14:19,449
Centaur memory buffer is a pretty big

00:14:15,429 --> 00:14:20,439
chip this has a 128 megabytes of Idi Ram

00:14:19,449 --> 00:14:23,589
cache on it

00:14:20,439 --> 00:14:27,970
each of these buffer chips has 4 DDR

00:14:23,589 --> 00:14:29,919
ports we have 32 ports of DDR all funnel

00:14:27,970 --> 00:14:32,139
into one processor chip right this is

00:14:29,919 --> 00:14:34,600
compared with you know Intel's at 6 or

00:14:32,139 --> 00:14:36,819
at 8 here we've got obscene amounts of

00:14:34,600 --> 00:14:39,189
ddr ports here right obscene amounts of

00:14:36,819 --> 00:14:42,009
ddr ports though means big dim cards

00:14:39,189 --> 00:14:44,399
that just simply can't fit in a 1u box

00:14:42,009 --> 00:14:47,799
with much ease I mean we did put these

00:14:44,399 --> 00:14:50,319
you see in power 8 open cap open power

00:14:47,799 --> 00:14:51,879
systems they all had these these buffer

00:14:50,319 --> 00:14:53,559
chips the buffer chips ended up going on

00:14:51,879 --> 00:14:55,329
the motherboards so when you see a

00:14:53,559 --> 00:14:57,489
standard dim plugged into a power eat

00:14:55,329 --> 00:15:00,730
box you had to go off and buy one of

00:14:57,489 --> 00:15:02,049
these Center chips and they're somewhat

00:15:00,730 --> 00:15:03,399
expensive they take up space on the

00:15:02,049 --> 00:15:05,230
motherboard so if you're trying to do a

00:15:03,399 --> 00:15:07,480
dense server in the same form factor as

00:15:05,230 --> 00:15:08,949
x86 you got to stick a bunch of these

00:15:07,480 --> 00:15:11,459
chips down on the motherboard you got to

00:15:08,949 --> 00:15:14,889
pay for them it's really a cost problem

00:15:11,459 --> 00:15:16,839
that said this has this agnostic

00:15:14,889 --> 00:15:19,360
interface so I was just saying how great

00:15:16,839 --> 00:15:20,980
it is right it also has very high

00:15:19,360 --> 00:15:22,959
bandwidth interfaces there's a lot of

00:15:20,980 --> 00:15:25,389
really good things about this the

00:15:22,959 --> 00:15:28,149
problem really was be it being open and

00:15:25,389 --> 00:15:29,889
the particular buffer we built was

00:15:28,149 --> 00:15:32,649
optimized around large enterprise

00:15:29,889 --> 00:15:34,209
servers not around dense servers but

00:15:32,649 --> 00:15:36,309
lots of good stuff here especially the

00:15:34,209 --> 00:15:37,840
agnostic interface and we've been doing

00:15:36,309 --> 00:15:39,910
work here with this right so there's

00:15:37,840 --> 00:15:42,640
recent micro paper that I guess got best

00:15:39,910 --> 00:15:43,450
paper with an FPGA based solution here

00:15:42,640 --> 00:15:45,790
where they're evaluating different

00:15:43,450 --> 00:15:48,370
Layton sees so lots of good work is

00:15:45,790 --> 00:15:50,110
happening in this form factor but it's

00:15:48,370 --> 00:15:51,940
not really a shippable case right it's

00:15:50,110 --> 00:15:54,340
too big too expensive

00:15:51,940 --> 00:15:57,460
I guess that card actually sticks out of

00:15:54,340 --> 00:16:01,150
the top of a 4u box right so it's a test

00:15:57,460 --> 00:16:02,620
vehicle not a production vehicle so I

00:16:01,150 --> 00:16:07,360
think this has come up a few times but

00:16:02,620 --> 00:16:09,370
this is this is our 2 power 9 chips with

00:16:07,360 --> 00:16:11,920
the 2 different memory subsystems try

00:16:09,370 --> 00:16:16,180
and inject some humor here so power 9

00:16:11,920 --> 00:16:17,830
has a family of processors and right

00:16:16,180 --> 00:16:19,870
it's a family what do I do we have a

00:16:17,830 --> 00:16:22,810
family of processors is because we're

00:16:19,870 --> 00:16:24,550
trying to target different spaces right

00:16:22,810 --> 00:16:26,650
we're trying to do well and then

00:16:24,550 --> 00:16:30,850
supercomputers that requires a different

00:16:26,650 --> 00:16:33,040
chip than the enterprise class system so

00:16:30,850 --> 00:16:35,170
at the start of a project we plan out

00:16:33,040 --> 00:16:38,440
our family right so we planned our

00:16:35,170 --> 00:16:40,240
family to have this type of memory in

00:16:38,440 --> 00:16:42,580
this type of memory and then we said ok

00:16:40,240 --> 00:16:44,800
here's our children so how do we do that

00:16:42,580 --> 00:16:46,510
though we take all the other stuff here

00:16:44,800 --> 00:16:48,460
all this complicated difficult to design

00:16:46,510 --> 00:16:52,210
stuff in the middle we keep it the same

00:16:48,460 --> 00:16:53,710
and then we change out components so in

00:16:52,210 --> 00:16:58,540
this case the components we change out

00:16:53,710 --> 00:17:01,060
are this is 4 channels of DDR 5 and this

00:16:58,540 --> 00:17:03,700
is 4 channels of DDR schedulers and

00:17:01,060 --> 00:17:06,670
controllers and then you have another 4

00:17:03,700 --> 00:17:08,290
channels of DDR fly down here this takes

00:17:06,670 --> 00:17:10,330
up quite a bit of perimeter area though

00:17:08,290 --> 00:17:12,160
right we've taken up nearly half of our

00:17:10,330 --> 00:17:15,580
chip perimeter and this is a very large

00:17:12,160 --> 00:17:16,690
chip just to drive 8 channels of DDR so

00:17:15,580 --> 00:17:19,090
you can see if we wanted to get 2 more

00:17:16,690 --> 00:17:22,209
channels of DDR it's really not possible

00:17:19,090 --> 00:17:24,280
right we could maybe we could go to 16

00:17:22,209 --> 00:17:25,630
channels of DDR if we had nothing else

00:17:24,280 --> 00:17:27,850
coming off of our chip other than a

00:17:25,630 --> 00:17:30,160
little bit of PCIe this is really

00:17:27,850 --> 00:17:33,300
highlighting how sort of end of the line

00:17:30,160 --> 00:17:37,330
DDR Phi's are they're simply very large

00:17:33,300 --> 00:17:41,800
this is the Centaur DMI based power 9

00:17:37,330 --> 00:17:44,140
ship this is 4 channels of DMI right

00:17:41,800 --> 00:17:48,460
it's smaller it's about half the size of

00:17:44,140 --> 00:17:52,150
that right so per wire this is running

00:17:48,460 --> 00:17:55,480
at 9.6 gig right this is running it

00:17:52,150 --> 00:17:57,960
you know 2666 that said this isn't even

00:17:55,480 --> 00:18:00,940
as fast as we can go if you look at our

00:17:57,960 --> 00:18:04,150
open Cappy and vlink these are running a

00:18:00,940 --> 00:18:08,740
25 gig right but the key point here is

00:18:04,150 --> 00:18:10,450
that this is much smaller than DD RFI so

00:18:08,740 --> 00:18:13,600
what did that let us do in the power

00:18:10,450 --> 00:18:14,980
nine big chip family since we didn't

00:18:13,600 --> 00:18:17,350
have to put as much space on for the

00:18:14,980 --> 00:18:22,270
memory interface we have twice as many

00:18:17,350 --> 00:18:23,980
25 gig wires for SNP and open copy we

00:18:22,270 --> 00:18:26,520
also are able to fill up this whole edge

00:18:23,980 --> 00:18:28,810
of the chip with our other SNP Connect

00:18:26,520 --> 00:18:31,360
it's kind of unfortunate you'll see

00:18:28,810 --> 00:18:33,280
there's some missing space here this is

00:18:31,360 --> 00:18:35,890
exactly three interfaces we had to cut

00:18:33,280 --> 00:18:38,590
it down to two interfaces because the

00:18:35,890 --> 00:18:41,650
DDR if I went over the edge there but

00:18:38,590 --> 00:18:43,630
you can see here so now we have I don't

00:18:41,650 --> 00:18:45,250
have a picture for this but we have an

00:18:43,630 --> 00:18:46,690
unplanned family member this is where

00:18:45,250 --> 00:18:48,490
things get a little funny right so you

00:18:46,690 --> 00:18:50,260
can't always plan your family sometimes

00:18:48,490 --> 00:18:57,310
things happen and you end up with

00:18:50,260 --> 00:19:02,800
another child same yeah yeah it's the

00:18:57,310 --> 00:19:04,360
same mother those same parents so we had

00:19:02,800 --> 00:19:06,700
this with Powerade it kind of works well

00:19:04,360 --> 00:19:08,740
because in power8 we built two chips and

00:19:06,700 --> 00:19:10,120
then our unplanned child was in vlink

00:19:08,740 --> 00:19:12,670
and we loved it just like our other

00:19:10,120 --> 00:19:14,470
children right the thing you get to do

00:19:12,670 --> 00:19:16,990
though is whenever you have a new family

00:19:14,470 --> 00:19:18,490
you get to remember what happened in

00:19:16,990 --> 00:19:21,670
your last family and you plan better

00:19:18,490 --> 00:19:23,260
so in power 9nv link is in all the chips

00:19:21,670 --> 00:19:24,550
right we knew about it at the start we

00:19:23,260 --> 00:19:28,020
always have been be linked so the new

00:19:24,550 --> 00:19:30,790
unplanned child is open Caffey memory in

00:19:28,020 --> 00:19:32,860
improving open copy in general open copy

00:19:30,790 --> 00:19:34,870
was a relatively late addition to power

00:19:32,860 --> 00:19:36,520
9 we're able to get it in but not

00:19:34,870 --> 00:19:38,110
everything we wanted to and so we get

00:19:36,520 --> 00:19:40,510
the rest of it which is open copy for oh

00:19:38,110 --> 00:19:43,030
but also open cafe memory so what is

00:19:40,510 --> 00:19:45,070
power 9 derivative chip look like I

00:19:43,030 --> 00:19:47,830
don't need a new picture because it's

00:19:45,070 --> 00:19:50,770
just whatever was here with our 9.6 gig

00:19:47,830 --> 00:19:52,780
differential is now 25 gig differential

00:19:50,770 --> 00:19:54,340
and the memory controller that talked to

00:19:52,780 --> 00:19:55,600
centaur we swapped that one out and we

00:19:54,340 --> 00:19:58,570
put on a memory controller that talks to

00:19:55,600 --> 00:20:01,780
open Caffey memory so power 9 same chip

00:19:58,570 --> 00:20:04,150
quickly deploying open copy memory

00:20:01,780 --> 00:20:05,620
before a new process technology comes

00:20:04,150 --> 00:20:07,690
out so it pretty much looks like

00:20:05,620 --> 00:20:10,840
Nicolle except for here you've got 25

00:20:07,690 --> 00:20:13,600
gigs signaling talked a little bit about

00:20:10,840 --> 00:20:16,659
different versions of open copy here's

00:20:13,600 --> 00:20:19,179
our power 9 that has our version 3.0 of

00:20:16,659 --> 00:20:22,710
open copy you know the first generation

00:20:19,179 --> 00:20:25,270
of open copy is 3.0 that makes sense

00:20:22,710 --> 00:20:26,980
well because we had one into right we

00:20:25,270 --> 00:20:30,700
can't yeah anyway most three is better

00:20:26,980 --> 00:20:33,370
than one right so and this does 25 gigs

00:20:30,700 --> 00:20:36,309
signaling you will notice here though we

00:20:33,370 --> 00:20:39,370
don't have caching capability on 3.0

00:20:36,309 --> 00:20:41,440
it's strictly a DMA agent we didn't have

00:20:39,370 --> 00:20:42,909
time in the schedule because we did add

00:20:41,440 --> 00:20:45,490
open copy somewhat late in the design

00:20:42,909 --> 00:20:48,309
process to power 9 so you'll see when we

00:20:45,490 --> 00:20:52,659
go to the follow-on power 9 our next

00:20:48,309 --> 00:20:54,700
child that will love we have the open

00:20:52,659 --> 00:20:57,460
capi 3.1 which is the memory interface

00:20:54,700 --> 00:21:01,720
we're talking about and we also extended

00:20:57,460 --> 00:21:03,429
the 4.0 open copy which contains caching

00:21:01,720 --> 00:21:05,529
capability now there are some

00:21:03,429 --> 00:21:08,020
improvements in this isn't the session

00:21:05,529 --> 00:21:10,090
on this but the caching that was done in

00:21:08,020 --> 00:21:11,919
copy 1 into 0 we learned quite a bit

00:21:10,090 --> 00:21:14,590
from that there's a pretty big chunk of

00:21:11,919 --> 00:21:17,350
logic on the FPGA called the PSL we

00:21:14,590 --> 00:21:19,210
moved nearly all of that logic onto the

00:21:17,350 --> 00:21:20,320
processor chip for this next version and

00:21:19,210 --> 00:21:22,870
so if you look at the way we're doing

00:21:20,320 --> 00:21:24,760
caching and 4.0 it was definitely

00:21:22,870 --> 00:21:27,010
learning from the way we did it in these

00:21:24,760 --> 00:21:29,380
previous generations to enable a more

00:21:27,010 --> 00:21:31,450
efficient caching solution so yeah here

00:21:29,380 --> 00:21:35,470
we have but it's all 25 gig right we got

00:21:31,450 --> 00:21:39,549
25 kids signaling essentially 8 6 will

00:21:35,470 --> 00:21:41,590
have 16 connectors for 4 memory so

00:21:39,549 --> 00:21:43,690
here's some pictures obviously this is a

00:21:41,590 --> 00:21:45,190
completed picture of centaur just to

00:21:43,690 --> 00:21:47,140
give you a perspective on what we're

00:21:45,190 --> 00:21:50,350
doing different so centaur was big old

00:21:47,140 --> 00:21:51,909
chip it had four DDR interfaces they're

00:21:50,350 --> 00:21:53,919
quite large on the buffer chip just like

00:21:51,909 --> 00:21:56,200
they are on the processor and then here

00:21:53,919 --> 00:21:58,630
is our differential signaling link this

00:21:56,200 --> 00:22:00,580
is a 16 megabyte cache we put eight of

00:21:58,630 --> 00:22:03,130
them in the box that's how we get 128

00:22:00,580 --> 00:22:04,600
Meg's and here's our scheduler the

00:22:03,130 --> 00:22:07,000
scheduler and the management for the

00:22:04,600 --> 00:22:07,919
cache itself so our new buffer chip

00:22:07,000 --> 00:22:11,169
these are not to scale

00:22:07,919 --> 00:22:12,460
this one's similar it's it's smaller

00:22:11,169 --> 00:22:14,559
than this but this is how they got that

00:22:12,460 --> 00:22:17,169
on the chart to make the text work this

00:22:14,559 --> 00:22:19,450
is our new buffer chip you can see that

00:22:17,169 --> 00:22:21,519
this is the OMI

00:22:19,450 --> 00:22:24,100
this is the dhih dhih RFI and here is

00:22:21,519 --> 00:22:26,860
the scheduler it's a very short distance

00:22:24,100 --> 00:22:28,860
from here to here and so the latency

00:22:26,860 --> 00:22:31,450
through this buffer chip is quite low

00:22:28,860 --> 00:22:32,620
our target is on the order of 5

00:22:31,450 --> 00:22:35,019
nanosecond so we might be a little

00:22:32,620 --> 00:22:36,279
higher than that but the amount of time

00:22:35,019 --> 00:22:37,899
you spend in the buffer trip is very

00:22:36,279 --> 00:22:39,490
small compared to here where you had to

00:22:37,899 --> 00:22:41,380
go across the scheduler and out to these

00:22:39,490 --> 00:22:42,970
bigger DDR files

00:22:41,380 --> 00:22:47,139
I don't have a picture of the Centaur

00:22:42,970 --> 00:22:49,149
Tim but the distance from the Centaur to

00:22:47,139 --> 00:22:54,250
the memory devices is also longer when

00:22:49,149 --> 00:22:55,960
you see the the the DMI sorry that the

00:22:54,250 --> 00:22:57,460
OMI dam in a second you'll see it's very

00:22:55,960 --> 00:22:59,919
small and we can run these a very high

00:22:57,460 --> 00:23:01,510
frequency I think that's coming up in a

00:22:59,919 --> 00:23:03,700
few slides but yeah so this is what our

00:23:01,510 --> 00:23:05,350
buffer looks like and this is the first

00:23:03,700 --> 00:23:07,510
one we really like more buffers out in

00:23:05,350 --> 00:23:09,299
the world that's where I think a lot of

00:23:07,510 --> 00:23:12,190
people in the community come in here

00:23:09,299 --> 00:23:15,309
we're building one buffer straightaway

00:23:12,190 --> 00:23:16,510
which supports ddr4 memory but we'd

00:23:15,309 --> 00:23:18,490
actually like to be able to support

00:23:16,510 --> 00:23:21,190
smaller memory capacities at high

00:23:18,490 --> 00:23:22,889
bandwidth tiered memory right there's a

00:23:21,190 --> 00:23:25,480
lot of different memory interfaces

00:23:22,889 --> 00:23:28,059
memory devices possible just do a quick

00:23:25,480 --> 00:23:32,110
roadmap picture here what we got is

00:23:28,059 --> 00:23:33,789
here's our power 9 family that is this

00:23:32,110 --> 00:23:36,340
is the two power lines we have today our

00:23:33,789 --> 00:23:38,740
first ones and then this is our open

00:23:36,340 --> 00:23:40,929
copy enabled one but you'll see here on

00:23:38,740 --> 00:23:43,570
the memory interface we have 350

00:23:40,929 --> 00:23:46,389
gigabytes of sustained bandwidth into a

00:23:43,570 --> 00:23:48,370
socket that's obscenely higher than

00:23:46,389 --> 00:23:51,159
anything else you'll be able to get how

00:23:48,370 --> 00:23:53,769
do we get there we were able to connect

00:23:51,159 --> 00:23:55,299
16 channels of DDR memory but we're also

00:23:53,769 --> 00:23:57,340
able to run the memory at higher

00:23:55,299 --> 00:23:59,110
frequency because it's a very short net

00:23:57,340 --> 00:24:04,000
from the DDR controller to the DDR

00:23:59,110 --> 00:24:06,490
device so we're talking 3200 ddr4 16

00:24:04,000 --> 00:24:08,860
channels of that so very much a high

00:24:06,490 --> 00:24:12,279
performance memory subsystem next on the

00:24:08,860 --> 00:24:14,169
horizon is power 10 power 10 we have a

00:24:12,279 --> 00:24:16,269
whole new chip right it's a new process

00:24:14,169 --> 00:24:18,730
technology a whole new chip but that

00:24:16,269 --> 00:24:20,559
said it will have the similar types of

00:24:18,730 --> 00:24:21,850
open copy and memory interfaces we have

00:24:20,559 --> 00:24:23,710
in this new power 9

00:24:21,850 --> 00:24:26,169
we essentially didn't want to wait till

00:24:23,710 --> 00:24:28,360
power 10 came out to deliver this new

00:24:26,169 --> 00:24:31,870
technology and that's why we put it into

00:24:28,360 --> 00:24:33,370
a power 9 based solution but same basic

00:24:31,870 --> 00:24:35,920
core design

00:24:33,370 --> 00:24:43,090
but essentially whole new memory

00:24:35,920 --> 00:24:43,990
subsystem and let's call it 20/20 I had

00:24:43,090 --> 00:24:45,700
one more slide in here

00:24:43,990 --> 00:24:46,720
anyway I was gonna maybe already blew

00:24:45,700 --> 00:24:48,340
through it real quick let's look yeah

00:24:46,720 --> 00:24:49,300
yeah let's go back to this one real

00:24:48,340 --> 00:24:53,200
quick just because I wanted to talk

00:24:49,300 --> 00:24:55,780
about that this is our little tiny

00:24:53,200 --> 00:24:58,810
buffer chip right and so we're able to

00:24:55,780 --> 00:25:01,480
run this very short interface at 3200

00:24:58,810 --> 00:25:03,070
quite easily and when we get to ddr5

00:25:01,480 --> 00:25:06,040
when people are trying to run extremely

00:25:03,070 --> 00:25:08,350
high frequency ddr's we'll be able to do

00:25:06,040 --> 00:25:10,540
that right so compare Drive and a signal

00:25:08,350 --> 00:25:11,800
from here to here right or I guess we'll

00:25:10,540 --> 00:25:14,230
talk about the longest one just to be

00:25:11,800 --> 00:25:15,850
fair or even from up here to large you

00:25:14,230 --> 00:25:16,960
know the higher distances but that's

00:25:15,850 --> 00:25:19,030
that the high bandwidth solutions are

00:25:16,960 --> 00:25:21,880
probably a little dim anyway so imagine

00:25:19,030 --> 00:25:23,890
trying to drive high frequency signals

00:25:21,880 --> 00:25:25,540
from there to there versus from a

00:25:23,890 --> 00:25:27,820
processor chip through the processor

00:25:25,540 --> 00:25:29,590
package through the motherboard through

00:25:27,820 --> 00:25:31,660
a dim connector and up across the

00:25:29,590 --> 00:25:33,040
motherboard to the buffer buffer chip

00:25:31,660 --> 00:25:35,080
you would never go directly from the

00:25:33,040 --> 00:25:37,120
processor all the way to the data device

00:25:35,080 --> 00:25:39,010
I guess that there's ddr5 frequencies

00:25:37,120 --> 00:25:40,840
anyway so you got to have some kind of

00:25:39,010 --> 00:25:43,120
buffer on the DIMM you might as well

00:25:40,840 --> 00:25:46,150
make that high frequency Surtees that

00:25:43,120 --> 00:25:47,950
run it 25 32 gig instead of something

00:25:46,150 --> 00:25:50,440
that's running down in the you know yeah

00:25:47,950 --> 00:25:52,480
low you know three to four or five gigs

00:25:50,440 --> 00:25:54,040
so definitely the right way to do memory

00:25:52,480 --> 00:25:56,620
devices and it lets us take that

00:25:54,040 --> 00:25:58,360
commodity ddr device and scale it to

00:25:56,620 --> 00:25:59,950
much higher bandwidth and you could if

00:25:58,360 --> 00:26:02,560
you drove it really all the way from the

00:25:59,950 --> 00:26:03,300
CPU chip so I think that's all I have

00:26:02,560 --> 00:26:06,700
yep

00:26:03,300 --> 00:26:06,700

YouTube URL: https://www.youtube.com/watch?v=__uo35MapPE


