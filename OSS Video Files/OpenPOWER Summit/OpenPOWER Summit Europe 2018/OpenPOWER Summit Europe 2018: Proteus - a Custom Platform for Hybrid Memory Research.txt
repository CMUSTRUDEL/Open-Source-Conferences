Title: OpenPOWER Summit Europe 2018: Proteus - a Custom Platform for Hybrid Memory Research
Publication date: 2018-11-14
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Kenneth Wright, Sr. Director, Rambus Labs, speaks at OpenPOWER Foundation's OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,260 --> 00:00:05,069
so this is a set of research that we've

00:00:03,210 --> 00:00:07,440
done it Rambis we started this research

00:00:05,069 --> 00:00:10,380
about three years ago and the pie bird

00:00:07,440 --> 00:00:14,429
memory subsystems and it's a particular

00:00:10,380 --> 00:00:16,680
passion of mine and so we've done this

00:00:14,429 --> 00:00:18,750
research in collaboration with IBM and

00:00:16,680 --> 00:00:20,720
many others that I'll thank toward the

00:00:18,750 --> 00:00:23,279
end of the talk

00:00:20,720 --> 00:00:27,590
so future memory subsystems that's

00:00:23,279 --> 00:00:30,240
really the motivation for the work in

00:00:27,590 --> 00:00:31,710
hybrid memory subsystems and then I'm

00:00:30,240 --> 00:00:34,380
going to talk a little bit about the

00:00:31,710 --> 00:00:35,489
Proteus platform and so we have a few

00:00:34,380 --> 00:00:37,260
people in the audience so I'm go ahead

00:00:35,489 --> 00:00:39,300
and start this around this is the

00:00:37,260 --> 00:00:43,680
Proteus platform that will upsets upside

00:00:39,300 --> 00:00:45,870
down that we'll be discussing

00:00:43,680 --> 00:00:46,920
for a good section of the talk and then

00:00:45,870 --> 00:00:49,200
I would like to talk about collaboration

00:00:46,920 --> 00:00:51,239
especially collaboration with other

00:00:49,200 --> 00:00:53,520
industry partners and we're going to be

00:00:51,239 --> 00:00:54,680
very soon in a position to collaborate

00:00:53,520 --> 00:00:59,219
with it

00:00:54,680 --> 00:01:01,199
academia on this so I've got to start

00:00:59,219 --> 00:01:03,570
all these kind of talks with the

00:01:01,199 --> 00:01:06,270
obligatory more law Moore's law and

00:01:03,570 --> 00:01:08,250
Dennard scaling graph right because

00:01:06,270 --> 00:01:09,869
that's the motivation for most of what

00:01:08,250 --> 00:01:11,360
we're doing nowadays in computer

00:01:09,869 --> 00:01:14,850
architecture and Computer Engineering

00:01:11,360 --> 00:01:17,880
right you you know this is a pretty

00:01:14,850 --> 00:01:20,729
standard one from Intel press and you

00:01:17,880 --> 00:01:25,530
know the first kind of wall we hit was

00:01:20,729 --> 00:01:28,020
the power wall right and then get my

00:01:25,530 --> 00:01:30,810
bearings then we get kind of the clock

00:01:28,020 --> 00:01:32,909
speed wall where things kind of have you

00:01:30,810 --> 00:01:34,530
know tailed off from clock speed and now

00:01:32,909 --> 00:01:37,530
we're starting to see a transistors per

00:01:34,530 --> 00:01:39,240
chip wall coming along and each one of

00:01:37,530 --> 00:01:41,040
these walls just becomes a design

00:01:39,240 --> 00:01:43,200
constraint that we have to work with it

00:01:41,040 --> 00:01:45,240
everybody's pretty much seen this in

00:01:43,200 --> 00:01:47,820
standard computer architecture fair this

00:01:45,240 --> 00:01:49,770
is why we don't have chips running at 30

00:01:47,820 --> 00:01:51,439
gigahertz right now which is what the

00:01:49,770 --> 00:01:54,990
original projections would have been and

00:01:51,439 --> 00:01:58,439
consuming you know a thousand watts on

00:01:54,990 --> 00:02:00,810
for a single chip because of these walls

00:01:58,439 --> 00:02:03,450
we found ways around them the thing that

00:02:00,810 --> 00:02:05,719
most people haven't seen as much is the

00:02:03,450 --> 00:02:08,220
equivalent graph for memory subsystems

00:02:05,719 --> 00:02:12,090
this is the equivalent Dennard scaling

00:02:08,220 --> 00:02:13,950
kind of graph for memory subsystems so

00:02:12,090 --> 00:02:17,220
I'm a memory subsystem geek I've been in

00:02:13,950 --> 00:02:20,489
memory subsystems for 20 years now

00:02:17,220 --> 00:02:22,950
I can remember when II do was the big

00:02:20,489 --> 00:02:24,450
new memory technology and if raise your

00:02:22,950 --> 00:02:29,600
hands if you even know what that means

00:02:24,450 --> 00:02:32,730
okay we all know our ages now right okay

00:02:29,600 --> 00:02:36,800
so in my first research project which

00:02:32,730 --> 00:02:39,660
with fast page Modi RAM on the Intel

00:02:36,800 --> 00:02:42,870
i860 which once again everybody now

00:02:39,660 --> 00:02:44,970
knows my age but the bottom line between

00:02:42,870 --> 00:02:47,459
the what's been driving the memory

00:02:44,970 --> 00:02:50,100
industry forever has been cost per bit

00:02:47,459 --> 00:02:53,549
that's the bottom line that's sheer fact

00:02:50,100 --> 00:02:57,120
that bits today will cost more than bits

00:02:53,549 --> 00:03:00,959
tomorrow so you can buy bits in the

00:02:57,120 --> 00:03:02,940
future that will cost less than the bits

00:03:00,959 --> 00:03:05,700
you have today so your algorithms can

00:03:02,940 --> 00:03:07,709
increase in size and complexity the data

00:03:05,700 --> 00:03:10,350
you're managing can increase and it

00:03:07,709 --> 00:03:13,470
won't astronomically affect your cost

00:03:10,350 --> 00:03:16,319
equation so this is what DRAM has done

00:03:13,470 --> 00:03:18,989
and I could continue this all the way

00:03:16,319 --> 00:03:22,500
back through SRAM and back to the abacus

00:03:18,989 --> 00:03:25,590
and the slight slide rule and abacus and

00:03:22,500 --> 00:03:27,299
stone tablets this graph has continued

00:03:25,590 --> 00:03:29,700
as a bunch of s curves and we're on the

00:03:27,299 --> 00:03:33,060
dbms curve right now and we're starting

00:03:29,700 --> 00:03:35,850
to flatten out the pointer working I've

00:03:33,060 --> 00:03:38,280
taken a really bright one so we're

00:03:35,850 --> 00:03:40,890
starting to flatten out all technologies

00:03:38,280 --> 00:03:43,470
tend to do this they flatten out over

00:03:40,890 --> 00:03:46,560
time this okay they they flatten out

00:03:43,470 --> 00:03:48,900
over time here's the DRAM one so we

00:03:46,560 --> 00:03:52,079
start with something that's reducing at

00:03:48,900 --> 00:03:58,260
a thirty percent annual rate and now

00:03:52,079 --> 00:03:59,850
we're at 12:10 maybe going up so price

00:03:58,260 --> 00:04:02,760
of four bits in the future actually got

00:03:59,850 --> 00:04:04,319
more expensive for a while some people

00:04:02,760 --> 00:04:06,299
think we're going down some people think

00:04:04,319 --> 00:04:08,519
we're flat this all has to do with the

00:04:06,299 --> 00:04:11,819
scaling of the transistor and the

00:04:08,519 --> 00:04:15,620
capacitors that make up DRAM so here is

00:04:11,819 --> 00:04:19,829
another graph this is the graph for

00:04:15,620 --> 00:04:22,470
flash memory right notice notice that

00:04:19,829 --> 00:04:24,990
this was about similar and it's

00:04:22,470 --> 00:04:27,360
continuing to accelerate and continuing

00:04:24,990 --> 00:04:29,250
to stay on the curve going down

00:04:27,360 --> 00:04:31,650
so we have memory technologies that are

00:04:29,250 --> 00:04:35,580
coming along that are continuing on the

00:04:31,650 --> 00:04:38,939
graph of reducing the cost per bit but

00:04:35,580 --> 00:04:40,530
not necessarily DRAM right so all these

00:04:38,939 --> 00:04:42,120
new memory technologies I have a whole

00:04:40,530 --> 00:04:43,800
talk about different new memory

00:04:42,120 --> 00:04:45,960
technologies they all have some

00:04:43,800 --> 00:04:47,939
attributes that are not what we want

00:04:45,960 --> 00:04:50,310
and so those attributes have to be

00:04:47,939 --> 00:04:54,270
managed to get an effective memory

00:04:50,310 --> 00:04:55,770
subsystem what we really want to do is

00:04:54,270 --> 00:04:58,020
be able to move from one of these curves

00:04:55,770 --> 00:05:00,569
to an other eventually for our main

00:04:58,020 --> 00:05:03,840
store not just our storage but for our

00:05:00,569 --> 00:05:05,729
load store memory so we started the

00:05:03,840 --> 00:05:07,190
research project with the goal of

00:05:05,729 --> 00:05:09,629
investigating memory subsystem

00:05:07,190 --> 00:05:12,030
architectures an attachment strategy

00:05:09,629 --> 00:05:15,530
specifically around multiple memory

00:05:12,030 --> 00:05:17,789
types and multiple archit a CH Manan

00:05:15,530 --> 00:05:20,909
different software and hardware schemes

00:05:17,789 --> 00:05:22,199
to manage this now interestingly enough

00:05:20,909 --> 00:05:24,509
this is not the first time in history

00:05:22,199 --> 00:05:26,250
that this has happened you can go back

00:05:24,509 --> 00:05:28,439
into the 60s and read papers about

00:05:26,250 --> 00:05:31,289
people arguing about whether SRAM's

00:05:28,439 --> 00:05:33,930
would be in computers forever or whether

00:05:31,289 --> 00:05:35,729
it should be D Rams and Cray has a very

00:05:33,930 --> 00:05:38,750
famous paper I really suggest you go to

00:05:35,729 --> 00:05:41,400
look at it he's kind of a curmudgeon and

00:05:38,750 --> 00:05:43,319
he was arguing that you'd never won't

00:05:41,400 --> 00:05:46,250
dear amps in your system that they're

00:05:43,319 --> 00:05:48,539
completely an incredibly bad technology

00:05:46,250 --> 00:05:50,819
but so we've done these transitions

00:05:48,539 --> 00:05:53,490
before and today we do have a hybrid

00:05:50,819 --> 00:05:56,849
memory subsystem a memory subsystem in

00:05:53,490 --> 00:05:59,039
which a user code does a load request

00:05:56,849 --> 00:06:01,680
and it doesn't know if it came out of

00:05:59,039 --> 00:06:03,629
SRAM which we happen to call cache or if

00:06:01,680 --> 00:06:05,279
it came out of DRAM that's managed by

00:06:03,629 --> 00:06:06,750
the hardware in the operating system and

00:06:05,279 --> 00:06:09,389
everything else and the user program

00:06:06,750 --> 00:06:11,460
doesn't even know care it manages the

00:06:09,389 --> 00:06:14,490
latency and bandwidth for it but now

00:06:11,460 --> 00:06:17,819
it's becoming more complex as we have

00:06:14,490 --> 00:06:20,759
things like our RAM and M Ram PCM in

00:06:17,819 --> 00:06:25,139
very fast flash these all have

00:06:20,759 --> 00:06:27,270
attributes wear out erase cycles disturb

00:06:25,139 --> 00:06:28,949
patterns that you have to manage if you

00:06:27,270 --> 00:06:31,229
really would like them to be used as a

00:06:28,949 --> 00:06:35,039
memory subsystem instead of a storage

00:06:31,229 --> 00:06:37,020
subsystem so we started the research we

00:06:35,039 --> 00:06:39,539
had three main pillars of our research

00:06:37,020 --> 00:06:41,129
the first pillar was performance

00:06:39,539 --> 00:06:44,409
modeling using Jim five

00:06:41,129 --> 00:06:47,169
now we've done extensive modeling of

00:06:44,409 --> 00:06:48,280
various memory subsystems and I'm going

00:06:47,169 --> 00:06:50,740
to show you a little bit of results a

00:06:48,280 --> 00:06:53,229
little bit further on the second pillar

00:06:50,740 --> 00:06:55,599
was a hardware prototyping and then the

00:06:53,229 --> 00:06:57,639
initial results of that are being passed

00:06:55,599 --> 00:06:58,870
around the room right now and that's

00:06:57,639 --> 00:07:01,090
mainly what I want to talk to you

00:06:58,870 --> 00:07:03,340
because you guys are seeing that memory

00:07:01,090 --> 00:07:05,620
subsystem for the first time there's

00:07:03,340 --> 00:07:08,439
been a handful of people who have seen

00:07:05,620 --> 00:07:12,009
that before this talk and then we have a

00:07:08,439 --> 00:07:14,889
software management scheme that I'd love

00:07:12,009 --> 00:07:18,310
to go into more about that uses a little

00:07:14,889 --> 00:07:21,370
bit of AI continuous learning to give

00:07:18,310 --> 00:07:25,870
hints to the hardware at allocation time

00:07:21,370 --> 00:07:28,449
they use context in the call stack in

00:07:25,870 --> 00:07:33,430
other places when the malloc is called

00:07:28,449 --> 00:07:35,050
to guess or predict what that malloc is

00:07:33,430 --> 00:07:37,180
going to be used for and give hints to

00:07:35,050 --> 00:07:39,370
the hardware that's kind of this secret

00:07:37,180 --> 00:07:41,349
sauce and magic here but we'll go into

00:07:39,370 --> 00:07:44,139
that'll not as much because this is more

00:07:41,349 --> 00:07:46,240
of a hardware or talk so here's our card

00:07:44,139 --> 00:07:50,409
as I said it's passing around the room

00:07:46,240 --> 00:07:53,740
this is the Proteus board this is the

00:07:50,409 --> 00:07:55,389
first in our platform of experimental

00:07:53,740 --> 00:07:57,159
Hardware I want to make sure that's very

00:07:55,389 --> 00:08:00,159
clear I'm not selling this this isn't a

00:07:57,159 --> 00:08:03,129
product this is a research platform for

00:08:00,159 --> 00:08:04,930
us as a community to find a way forward

00:08:03,129 --> 00:08:07,779
into these hybrid memory technologies

00:08:04,930 --> 00:08:10,509
how can we get these new sell

00:08:07,779 --> 00:08:12,639
architectures in combination with DRM

00:08:10,509 --> 00:08:14,469
and SRAM into our memory subsystem and

00:08:12,639 --> 00:08:16,930
still provide performance as we go

00:08:14,469 --> 00:08:19,330
forward so this is a platform I'm

00:08:16,930 --> 00:08:21,430
looking for collaboration own not

00:08:19,330 --> 00:08:24,940
necessarily to sell to anyone at this

00:08:21,430 --> 00:08:27,520
point so let's go over what we did here

00:08:24,940 --> 00:08:32,070
so you can see what some of the

00:08:27,520 --> 00:08:37,300
capabilities are so we take the Xilinx

00:08:32,070 --> 00:08:40,630
vu 9p very large scale fpga you can

00:08:37,300 --> 00:08:43,870
actually build the card with a V u7p or

00:08:40,630 --> 00:08:46,420
vu 11 P they have the same footprints

00:08:43,870 --> 00:08:49,029
depending on how complicated you want

00:08:46,420 --> 00:08:50,860
some algorithms there some interesting

00:08:49,029 --> 00:08:54,279
parts about the card and then we'll go

00:08:50,860 --> 00:08:54,940
on to how you use those things going

00:08:54,279 --> 00:08:58,810
forward

00:08:54,940 --> 00:09:00,760
you'll notice that that card has 5 288

00:08:58,810 --> 00:09:03,400
pen dem connectors on it this is what

00:09:00,760 --> 00:09:06,160
you'd standardly see as a ddr4 dimm and

00:09:03,400 --> 00:09:08,380
in actuality four of those can be used

00:09:06,160 --> 00:09:11,500
for ddr memory you can buy a standard

00:09:08,380 --> 00:09:13,570
DDR Dem and put in them but unlike most

00:09:11,500 --> 00:09:16,090
cards this is made for experimentation

00:09:13,570 --> 00:09:19,380
so each one of those slots has

00:09:16,090 --> 00:09:23,970
independent clocking independent power

00:09:19,380 --> 00:09:27,670
independent grounds so I can provide

00:09:23,970 --> 00:09:28,410
through the OBC and the power generation

00:09:27,670 --> 00:09:33,160
on the card

00:09:28,410 --> 00:09:37,150
anything from 48 volts down to 0.9 volts

00:09:33,160 --> 00:09:40,540
to any pin on that card so I can create

00:09:37,150 --> 00:09:43,300
a or any power pin on that card I can

00:09:40,540 --> 00:09:48,160
create specialized Dems for any

00:09:43,300 --> 00:09:50,740
technology so we have partners with

00:09:48,160 --> 00:09:52,930
various people so for instance you could

00:09:50,740 --> 00:09:55,690
set this card up in which you chose one

00:09:52,930 --> 00:09:58,480
of the slots to put DRAM in you could

00:09:55,690 --> 00:10:00,700
put in another slot you could put two

00:09:58,480 --> 00:10:03,310
Sheba's excel flash using a toggle

00:10:00,700 --> 00:10:06,730
protocol and another slot you could put

00:10:03,310 --> 00:10:09,310
samsung z nand flash in another slot you

00:10:06,730 --> 00:10:12,730
could put the in Ram from ever spin

00:10:09,310 --> 00:10:15,150
another slot you can put a ram from Sony

00:10:12,730 --> 00:10:18,550
they would all work on this card

00:10:15,150 --> 00:10:20,950
together and the FPGA would have that

00:10:18,550 --> 00:10:25,540
resource to it on the right side of the

00:10:20,950 --> 00:10:27,850
card we have 325 gigabyte per second

00:10:25,540 --> 00:10:29,950
open capi connections that will connect

00:10:27,850 --> 00:10:32,080
to a power 9 system so it's a hundred

00:10:29,950 --> 00:10:33,850
and 50 gigabytes of cross-sectional

00:10:32,080 --> 00:10:37,750
bandwidth going into this card on that

00:10:33,850 --> 00:10:40,570
side on the left side we have two Gen Z

00:10:37,750 --> 00:10:42,580
ports that as soon as there's a gin Z

00:10:40,570 --> 00:10:46,450
processor out there you'll be able to

00:10:42,580 --> 00:10:50,470
connect at 50 gigabytes per second so

00:10:46,450 --> 00:10:53,740
and just in case you want to go slow we

00:10:50,470 --> 00:10:55,750
put a PCIe on the bottom eight lanes of

00:10:53,740 --> 00:10:59,200
PCI heed if you want to get started that

00:10:55,750 --> 00:11:01,030
way we have a complete onboard

00:10:59,200 --> 00:11:02,860
controller that handles power own

00:11:01,030 --> 00:11:04,330
sequences you can imagine if you start

00:11:02,860 --> 00:11:06,250
mixing and matching all these memory

00:11:04,330 --> 00:11:08,620
types that how you power it on and how

00:11:06,250 --> 00:11:12,610
you power it off is not

00:11:08,620 --> 00:11:14,530
Sara Lee obvious so we put a full

00:11:12,610 --> 00:11:17,050
controller on there that can control all

00:11:14,530 --> 00:11:20,110
that we also have the capability for

00:11:17,050 --> 00:11:22,210
external clocking so if any by default

00:11:20,110 --> 00:11:24,220
the FPGA gets its major clocks from the

00:11:22,210 --> 00:11:26,260
open copy or Gen Z but if you have a

00:11:24,220 --> 00:11:27,610
memory device that has specific clocking

00:11:26,260 --> 00:11:30,520
requirements you can bring in external

00:11:27,610 --> 00:11:32,740
clocks so this is a platform this is

00:11:30,520 --> 00:11:34,840
like Legos right now you have a platform

00:11:32,740 --> 00:11:39,220
that you can mix and match whatever you

00:11:34,840 --> 00:11:41,740
want to experiment with so what about

00:11:39,220 --> 00:11:43,210
the insights because you're like okay so

00:11:41,740 --> 00:11:44,260
this card I can connect anything to

00:11:43,210 --> 00:11:48,160
anything got it

00:11:44,260 --> 00:11:51,670
now the insights must be immensely

00:11:48,160 --> 00:11:53,920
complex right how do I program this to

00:11:51,670 --> 00:11:58,560
handle the different memory types well

00:11:53,920 --> 00:12:02,110
we've also tried to develop some

00:11:58,560 --> 00:12:05,200
information isolation techniques in the

00:12:02,110 --> 00:12:07,750
Vera log so that it's not a daunting

00:12:05,200 --> 00:12:10,510
task to do experimentation on this card

00:12:07,750 --> 00:12:14,170
so this is our standard module or

00:12:10,510 --> 00:12:17,080
flexible format that we're that we're

00:12:14,170 --> 00:12:20,550
giving away to our collaborators so

00:12:17,080 --> 00:12:23,920
first of all there's two major blocks

00:12:20,550 --> 00:12:26,100
the software hybrid heterogeneous tier

00:12:23,920 --> 00:12:28,660
manager and the hardware hybrid

00:12:26,100 --> 00:12:32,590
heterogeneous tier manager basically

00:12:28,660 --> 00:12:34,630
this is what manages the different

00:12:32,590 --> 00:12:37,300
memory layers this is where we're hoping

00:12:34,630 --> 00:12:40,510
to innovate this is where we hope that

00:12:37,300 --> 00:12:43,000
all of us can try our secret sauce in

00:12:40,510 --> 00:12:45,520
there and compare so this is not

00:12:43,000 --> 00:12:47,350
something we distribute this Rambis has

00:12:45,520 --> 00:12:48,910
some secret sauce that they put in here

00:12:47,350 --> 00:12:50,320
they have some software that talks to

00:12:48,910 --> 00:12:52,390
the hardware to give it hints they have

00:12:50,320 --> 00:12:56,440
some hardware algorithms that manages

00:12:52,390 --> 00:12:57,550
the different types of memory and I'll

00:12:56,440 --> 00:12:59,470
show you in a few minutes some pretty

00:12:57,550 --> 00:13:01,270
good same results on this and hopefully

00:12:59,470 --> 00:13:03,640
the next time you see me you'll see some

00:13:01,270 --> 00:13:06,310
hardware results on this but that is

00:13:03,640 --> 00:13:09,010
where I want people to have bake-offs

00:13:06,310 --> 00:13:11,920
okay is your algorithm better than my

00:13:09,010 --> 00:13:16,030
algorithm for managing disparate types

00:13:11,920 --> 00:13:18,160
of memory but because of that that's

00:13:16,030 --> 00:13:20,560
where my research is that's what I want

00:13:18,160 --> 00:13:21,950
to work on I had to create all the rest

00:13:20,560 --> 00:13:23,930
of the things around it

00:13:21,950 --> 00:13:26,840
but those aren't really what I'm wanting

00:13:23,930 --> 00:13:29,930
to get done so I'm wanting to help the

00:13:26,840 --> 00:13:33,740
community with these parts we have a

00:13:29,930 --> 00:13:37,490
processor interface module here where we

00:13:33,740 --> 00:13:39,650
take the TLX and LX you get from IBM we

00:13:37,490 --> 00:13:42,290
put a special interface controller on

00:13:39,650 --> 00:13:45,260
front in front of that and we present a

00:13:42,290 --> 00:13:47,770
master interface to the hardware tier

00:13:45,260 --> 00:13:52,100
manager that interface we're hoping to

00:13:47,770 --> 00:13:54,770
standardize and you know work with the

00:13:52,100 --> 00:13:56,210
community on and what it does you're

00:13:54,770 --> 00:13:58,010
like okay that's interesting why don't

00:13:56,210 --> 00:14:00,170
you just use the IBM interface because

00:13:58,010 --> 00:14:02,540
the IBM ear face is open can't be

00:14:00,170 --> 00:14:04,550
specific the interface once it makes it

00:14:02,540 --> 00:14:06,500
to this master interface the hardware

00:14:04,550 --> 00:14:08,930
tier manager can no longer tell whether

00:14:06,500 --> 00:14:12,380
it's hooked up to an open capya Gen Z or

00:14:08,930 --> 00:14:13,910
CCI X those parts can be interchanged

00:14:12,380 --> 00:14:16,670
without the hardware tier manager ever

00:14:13,910 --> 00:14:18,590
knowing it happened we also have a

00:14:16,670 --> 00:14:21,320
config and control this is where

00:14:18,590 --> 00:14:24,680
software has a sideband access to give

00:14:21,320 --> 00:14:27,200
hints out-of-band to the hardware tier

00:14:24,680 --> 00:14:30,140
manager that once again has an interface

00:14:27,200 --> 00:14:32,660
such as that you don't know which

00:14:30,140 --> 00:14:35,900
processor a processor interface so now

00:14:32,660 --> 00:14:37,910
we've isolated this from the processor

00:14:35,900 --> 00:14:40,160
so all he knows is he gets loads and

00:14:37,910 --> 00:14:43,280
stores maybe some flushes and a few

00:14:40,160 --> 00:14:46,280
other cache commands if necessary you

00:14:43,280 --> 00:14:48,320
implement those and you don't care what

00:14:46,280 --> 00:14:51,680
processor your own anymore the memory

00:14:48,320 --> 00:14:54,830
subsystem at this point now right now

00:14:51,680 --> 00:14:57,650
the only server grade processor you can

00:14:54,830 --> 00:14:59,510
connect to however is an IBM Power 9

00:14:57,650 --> 00:15:01,490
because the only thing on the market so

00:14:59,510 --> 00:15:03,350
we really appreciate all the help we've

00:15:01,490 --> 00:15:05,480
gotten from IBM to get this off the

00:15:03,350 --> 00:15:07,790
ground this type of research would not

00:15:05,480 --> 00:15:10,700
have been able to be done otherwise on

00:15:07,790 --> 00:15:13,910
the other side we've just find a couple

00:15:10,700 --> 00:15:15,650
of protocols around a line interface

00:15:13,910 --> 00:15:17,690
which is a type of memory that's

00:15:15,650 --> 00:15:20,840
relatively fast and you can get to on a

00:15:17,690 --> 00:15:23,450
line basis and a block interface or

00:15:20,840 --> 00:15:27,260
emerging controller the line interface

00:15:23,450 --> 00:15:28,760
is basic axion about FPGA development

00:15:27,260 --> 00:15:31,390
people should be comfortable with that

00:15:28,760 --> 00:15:34,580
the block interface is a work queue and

00:15:31,390 --> 00:15:35,600
this is work that you would expect to do

00:15:34,580 --> 00:15:38,750
if your prefab

00:15:35,600 --> 00:15:40,550
cheating we're leveling you're moving

00:15:38,750 --> 00:15:42,889
data from a fast interface to a slow

00:15:40,550 --> 00:15:45,740
interface we've created a command set

00:15:42,889 --> 00:15:47,769
there that you can put any kind of block

00:15:45,740 --> 00:15:50,569
controller you want on the other side

00:15:47,769 --> 00:15:54,709
now we've developed at least one block

00:15:50,569 --> 00:15:58,459
controller that interfaces to this block

00:15:54,709 --> 00:16:01,399
interface and also interfaces to an

00:15:58,459 --> 00:16:02,930
outbound interface such as toggle or on

00:16:01,399 --> 00:16:05,149
fie some of the standard flash

00:16:02,930 --> 00:16:07,009
interfaces now the interesting thing

00:16:05,149 --> 00:16:08,449
about the block controller is the block

00:16:07,009 --> 00:16:11,839
controller doesn't know which interface

00:16:08,449 --> 00:16:13,910
it's using it manages where it manages

00:16:11,839 --> 00:16:16,009
erase cycles things like that but it

00:16:13,910 --> 00:16:17,930
doesn't know what technology it's using

00:16:16,009 --> 00:16:19,519
to transmit that data to the eventual

00:16:17,930 --> 00:16:22,880
media we've made sure to keep that

00:16:19,519 --> 00:16:25,670
isolated so this block controller for

00:16:22,880 --> 00:16:27,230
instance before we have the emerging

00:16:25,670 --> 00:16:29,509
memory what we'll do is we'll take the

00:16:27,230 --> 00:16:32,509
card and we'll put multiple ddr's in it

00:16:29,509 --> 00:16:35,899
and block controller can actually speak

00:16:32,509 --> 00:16:38,180
out a ddr4 bus to a dram doesn't care

00:16:35,899 --> 00:16:40,040
and it'll do we're leveling on a dram

00:16:38,180 --> 00:16:43,130
it'll do all those kinds of things it'll

00:16:40,040 --> 00:16:47,000
treat it with it with the latency that a

00:16:43,130 --> 00:16:49,130
flash has so you can even take a memory

00:16:47,000 --> 00:16:53,720
that hasn't been devised yet and see

00:16:49,130 --> 00:16:57,439
what it would do okay so this is the

00:16:53,720 --> 00:17:00,199
other part of the experiment so whatever

00:16:57,439 --> 00:17:02,899
interface you need to talk to the memory

00:17:00,199 --> 00:17:05,900
technology a block interface a line

00:17:02,899 --> 00:17:08,530
interface a processor interface and a

00:17:05,900 --> 00:17:11,839
software control config and control

00:17:08,530 --> 00:17:14,419
therefore we isolate the part that we

00:17:11,839 --> 00:17:16,220
really want to do a research on and get

00:17:14,419 --> 00:17:20,659
all the other extraneous bits out of the

00:17:16,220 --> 00:17:24,610
way and so we can say what is the best

00:17:20,659 --> 00:17:29,809
way to mix an emerging memory with a

00:17:24,610 --> 00:17:31,640
existing memory like the rim okay so

00:17:29,809 --> 00:17:34,820
this goes into it a little bit deeper as

00:17:31,640 --> 00:17:37,789
I said it's so this is a next level down

00:17:34,820 --> 00:17:39,590
as you see here is the TLX and dialects

00:17:37,789 --> 00:17:42,350
in the adaptation logic that we've

00:17:39,590 --> 00:17:46,400
developed that'll go into an ax I cross

00:17:42,350 --> 00:17:48,140
bar from the X I cross bar you talk to

00:17:46,400 --> 00:17:49,670
the hybrid controller as I was saying

00:17:48,140 --> 00:17:53,090
that adapt a

00:17:49,670 --> 00:17:56,360
logic also talks to the custom configure

00:17:53,090 --> 00:18:00,560
jesters and the custom config sets

00:17:56,360 --> 00:18:05,030
policies hints and the hybrid control

00:18:00,560 --> 00:18:10,130
and in the merging memory policy okay

00:18:05,030 --> 00:18:13,280
the block device controller and the DRM

00:18:10,130 --> 00:18:16,400
controller the ax I crossbar switches

00:18:13,280 --> 00:18:21,620
those all come from third parties and as

00:18:16,400 --> 00:18:23,990
does the open copy or Gen Z interface so

00:18:21,620 --> 00:18:26,390
you're part of the open copy consortium

00:18:23,990 --> 00:18:28,670
you can get this portion from the

00:18:26,390 --> 00:18:30,920
consortium this you can get from Xilinx

00:18:28,670 --> 00:18:34,640
this you can get from Xilinx line

00:18:30,920 --> 00:18:39,530
controllers northwest logic has one so

00:18:34,640 --> 00:18:42,710
does Xilinx themselves that can handle

00:18:39,530 --> 00:18:44,570
dram for instance if you want to use

00:18:42,710 --> 00:18:46,520
ever spence MRAM they'll give you the

00:18:44,570 --> 00:18:49,130
controller for that that plugs into this

00:18:46,520 --> 00:18:50,960
environment and the block interface

00:18:49,130 --> 00:18:54,020
controller there's several people who

00:18:50,960 --> 00:18:57,110
can do that and teleprompt a few others

00:18:54,020 --> 00:18:58,850
that you can get those devices from so

00:18:57,110 --> 00:19:00,860
it's a little bit of a still of a

00:18:58,850 --> 00:19:03,440
mix-and-match kind of thing the hardware

00:19:00,860 --> 00:19:04,880
guys are not quite as advanced as some

00:19:03,440 --> 00:19:09,050
of the software team where you can just

00:19:04,880 --> 00:19:11,930
go download and install things for debut

00:19:09,050 --> 00:19:14,000
nor whatever in like your sleep this you

00:19:11,930 --> 00:19:16,220
have to do a little bit of okay let me

00:19:14,000 --> 00:19:17,900
talk to you and get an NDA sign with you

00:19:16,220 --> 00:19:21,170
okay now you'll give me that and let me

00:19:17,900 --> 00:19:22,640
go talk to you it's a little bit uh our

00:19:21,170 --> 00:19:25,280
licensing we need to work on that

00:19:22,640 --> 00:19:27,260
section in the hardware guys so that

00:19:25,280 --> 00:19:30,080
makes this a little easier to distribute

00:19:27,260 --> 00:19:32,450
but it's definitely workable now it

00:19:30,080 --> 00:19:36,500
reminds me of open source software from

00:19:32,450 --> 00:19:39,740
about two decades ago this data here is

00:19:36,500 --> 00:19:42,170
for enhanced flash this is a three

00:19:39,740 --> 00:19:44,060
microsecond hundred micro second flash

00:19:42,170 --> 00:19:46,820
device this is not the standard flash

00:19:44,060 --> 00:19:48,680
device that you would use in an SSD or

00:19:46,820 --> 00:19:51,920
something like this this is the

00:19:48,680 --> 00:20:00,070
equivalent of Zenon from Samsung or

00:19:51,920 --> 00:20:02,330
excel flash from Toshiba that is about

00:20:00,070 --> 00:20:03,640
depending on what you look at it's about

00:20:02,330 --> 00:20:09,070
thirty at

00:20:03,640 --> 00:20:12,529
less the cost of DRAM okay so it's not

00:20:09,070 --> 00:20:16,100
30% less you take the price and you

00:20:12,529 --> 00:20:21,830
divide it by 30 okay the price of DRAM

00:20:16,100 --> 00:20:24,830
per bit okay so in this performance run

00:20:21,830 --> 00:20:27,440
what we did is we said okay let's assume

00:20:24,830 --> 00:20:30,890
that we need a terabyte memory subsystem

00:20:27,440 --> 00:20:33,140
for our workload that's a good size

00:20:30,890 --> 00:20:35,140
memory subsystem and let's build that

00:20:33,140 --> 00:20:39,159
terabyte memory subsystem out of DRAM

00:20:35,140 --> 00:20:42,740
okay we'll run a set of benchmarks

00:20:39,159 --> 00:20:46,309
across that and this is more or less

00:20:42,740 --> 00:20:48,230
wall clock time so we call that one but

00:20:46,309 --> 00:20:51,169
that would have a certain cost and power

00:20:48,230 --> 00:20:52,909
associated with it anyone who's done

00:20:51,169 --> 00:20:55,659
memory subsystem design is looking at me

00:20:52,909 --> 00:21:00,409
right now ongoing a terabyte really of

00:20:55,659 --> 00:21:03,710
DRAM that would have a certain cost and

00:21:00,409 --> 00:21:06,200
power profile then if we just took this

00:21:03,710 --> 00:21:09,980
emerging memory and put it on the memory

00:21:06,200 --> 00:21:12,610
bus and said here you go use this as

00:21:09,980 --> 00:21:15,320
your main store it's 30 times cheaper

00:21:12,610 --> 00:21:17,899
this would be your performance so

00:21:15,320 --> 00:21:19,370
suddenly your graph analytics run if it

00:21:17,899 --> 00:21:22,789
took one hour to run would take a

00:21:19,370 --> 00:21:27,590
hundred and one hours to run but it's

00:21:22,789 --> 00:21:29,149
30x cheaper well then we apply the

00:21:27,590 --> 00:21:31,730
software techniques and hardware

00:21:29,149 --> 00:21:34,390
techniques that we were discussing in

00:21:31,730 --> 00:21:37,730
the hybrid controller and then this

00:21:34,390 --> 00:21:40,549
becomes what happens so if you manage it

00:21:37,730 --> 00:21:42,620
so if you take that one terabyte and you

00:21:40,549 --> 00:21:47,559
create it out of excel flash let's say

00:21:42,620 --> 00:21:52,850
and you put a small amount of DRAM 1/64

00:21:47,559 --> 00:21:54,919
let's say of DRAM and you manage it

00:21:52,850 --> 00:21:56,360
appropriately this is the performance

00:21:54,919 --> 00:22:01,220
you get so now you have a memory

00:21:56,360 --> 00:22:04,610
subsystem that is around 1/8 to 1/16 of

00:22:01,220 --> 00:22:08,000
cost of the memory subsystem that was

00:22:04,610 --> 00:22:10,100
all DRAM and for instance if you're

00:22:08,000 --> 00:22:13,039
running certain types of media streaming

00:22:10,100 --> 00:22:15,870
applications you have lost about 13%

00:22:13,039 --> 00:22:20,100
performance

00:22:15,870 --> 00:22:22,919
that's the motivation and that is the

00:22:20,100 --> 00:22:24,320
one of the first examples of what you

00:22:22,919 --> 00:22:26,970
can do with this card

00:22:24,320 --> 00:22:29,640
so obviously you could take this card

00:22:26,970 --> 00:22:33,750
and you could populate all the four

00:22:29,640 --> 00:22:37,260
slots with DRAM and then this becomes

00:22:33,750 --> 00:22:41,789
host agent memory I get the new term

00:22:37,260 --> 00:22:43,830
right thanks also called LPC at the host

00:22:41,789 --> 00:22:47,429
agent memory was a term I just heard at

00:22:43,830 --> 00:22:49,590
this conference so this would become

00:22:47,429 --> 00:22:52,620
host agent memory that you put on the

00:22:49,590 --> 00:22:54,870
open copy bus and you can run this card

00:22:52,620 --> 00:22:57,570
in that mode to debug whatever kind of

00:22:54,870 --> 00:22:59,880
host agent things you'd like to do but

00:22:57,570 --> 00:23:02,460
the more interesting example is when you

00:22:59,880 --> 00:23:05,279
take a small amount of the slots on this

00:23:02,460 --> 00:23:08,039
card and allocated to DRAM now you're

00:23:05,279 --> 00:23:11,460
going to use the DRAM for wear leveling

00:23:08,039 --> 00:23:14,010
for prefetching for caching for whatever

00:23:11,460 --> 00:23:16,529
you need to do to manage the emerging

00:23:14,010 --> 00:23:21,090
memory you take an emerging memory like

00:23:16,529 --> 00:23:23,789
excel flash or Ram bus nan and you place

00:23:21,090 --> 00:23:27,270
that on the card that memory per bit is

00:23:23,789 --> 00:23:30,990
substantially less than DRAM it it will

00:23:27,270 --> 00:23:33,570
use over a third less the power of DRAM

00:23:30,990 --> 00:23:35,159
but as I said if you don't manage it and

00:23:33,570 --> 00:23:36,090
you just let your program run against it

00:23:35,159 --> 00:23:38,700
you're not going to be happy with the

00:23:36,090 --> 00:23:40,649
performance this is also one of the

00:23:38,700 --> 00:23:43,110
platforms that you this platform is

00:23:40,649 --> 00:23:44,909
fully wired for NB BMP for instance

00:23:43,110 --> 00:23:47,610
smart modular and several other people

00:23:44,909 --> 00:23:51,510
have M BMP dims but right now there is

00:23:47,610 --> 00:23:54,149
no server grade processor that will use

00:23:51,510 --> 00:23:56,640
those so this will allow you to use nvm

00:23:54,149 --> 00:23:59,210
P and run server benchmarks against it

00:23:56,640 --> 00:24:02,130
because the cards fully wired for that

00:23:59,210 --> 00:24:03,809
so what am I here

00:24:02,130 --> 00:24:06,960
why am I here why am I talking to you

00:24:03,809 --> 00:24:09,809
about this because I want to do this in

00:24:06,960 --> 00:24:12,120
collaboration I understand that we

00:24:09,809 --> 00:24:14,100
probably at Rambis do not have all the

00:24:12,120 --> 00:24:18,179
best ideas in the world just you know a

00:24:14,100 --> 00:24:19,740
majority of them so I'm looking for

00:24:18,179 --> 00:24:22,200
processor leaders to collaborate with

00:24:19,740 --> 00:24:25,110
IBM was very gracious to be one of our

00:24:22,200 --> 00:24:28,520
first and a very good processor leading

00:24:25,110 --> 00:24:29,610
partner we're looking for memory vendors

00:24:28,520 --> 00:24:31,710
people

00:24:29,610 --> 00:24:33,450
who have innovative new memory

00:24:31,710 --> 00:24:35,760
technology I knew a lot of research is

00:24:33,450 --> 00:24:38,309
going on in universities around our RAM

00:24:35,760 --> 00:24:40,500
and I'm looking for system leaders like

00:24:38,309 --> 00:24:41,070
West Ron who's also been a very good

00:24:40,500 --> 00:24:43,080
partner

00:24:41,070 --> 00:24:46,650
matter of fact I want to thank all the

00:24:43,080 --> 00:24:51,360
people who have already collaborated on

00:24:46,650 --> 00:24:52,920
this project and like I said in the

00:24:51,360 --> 00:24:54,690
early next year time frame we're going

00:24:52,920 --> 00:24:58,770
to be looking for academics to also

00:24:54,690 --> 00:25:00,450
collaborate on this project thank you

00:24:58,770 --> 00:25:03,290
very much I know I'm now standing

00:25:00,450 --> 00:25:03,290
between you and lunch

00:25:03,500 --> 00:25:08,710

YouTube URL: https://www.youtube.com/watch?v=A1-rgyhM0vU


