Title: OpenPOWER Summit Europe 2018: Booting: From Power on to a Login Prompt
Publication date: 2019-02-07
Playlist: OpenPOWER Summit Europe 2018
Description: 
	Stewart Smith, OPAL Architect at IBM, speaks at OpenPOWER Summit Europe 2018.

For more information, please visit: https://openpowerfoundation.org/summit-2018-10-eu/
Captions: 
	00:00:00,669 --> 00:00:07,600
I'm Stuart I am the opal architect at

00:00:04,600 --> 00:00:10,540
IBM which basically means I do a whole

00:00:07,600 --> 00:00:14,080
lot of firmware things and today I'm

00:00:10,540 --> 00:00:15,940
talking about what happens when you plug

00:00:14,080 --> 00:00:17,529
in a system up to the point where you

00:00:15,940 --> 00:00:19,929
get a login prompt that you care about

00:00:17,529 --> 00:00:22,839
so this is going from box sitting on a

00:00:19,929 --> 00:00:24,519
desk power cord goes in how do you get

00:00:22,839 --> 00:00:27,070
to then being a computer that you want

00:00:24,519 --> 00:00:29,980
to use and I'm going to talk about a

00:00:27,070 --> 00:00:31,509
system that's roughly similar to our IBM

00:00:29,980 --> 00:00:35,530
with a spoon model or I believe the

00:00:31,509 --> 00:00:38,500
commercial name is IBM AC 9 to 2 which

00:00:35,530 --> 00:00:40,059
is a name that apparently you sell the

00:00:38,500 --> 00:00:41,079
Machine adds but not that everyone knows

00:00:40,059 --> 00:00:43,899
that when you're doing the years of

00:00:41,079 --> 00:00:45,399
bring up before hand it's a power 9

00:00:43,899 --> 00:00:48,640
system it's one of the first power 9

00:00:45,399 --> 00:00:50,530
systems to ship it's part of the kora

00:00:48,640 --> 00:00:53,920
labs supercomputers like at Lawrence

00:00:50,530 --> 00:00:56,339
Livermore and Oak Ridge so number one

00:00:53,920 --> 00:01:00,370
and three on the top 500 supercomputers

00:00:56,339 --> 00:01:02,579
that's this it's based on power 9 which

00:01:00,370 --> 00:01:05,820
looks like that

00:01:02,579 --> 00:01:08,110
but our story doesn't start with power 9

00:01:05,820 --> 00:01:09,549
the system we're talking about here is

00:01:08,110 --> 00:01:11,530
similar to like the towel systems as

00:01:09,549 --> 00:01:14,590
well functionally equivalent different

00:01:11,530 --> 00:01:17,710
price points similar architecture it

00:01:14,590 --> 00:01:20,920
starts with the BMC this is a service

00:01:17,710 --> 00:01:22,720
processor and one of its jobs is to turn

00:01:20,920 --> 00:01:24,250
on the main processor so you have a

00:01:22,720 --> 00:01:26,560
service processor out to the side that

00:01:24,250 --> 00:01:29,409
does out-of-band management so it does

00:01:26,560 --> 00:01:31,420
things like it allow you to use IPMI to

00:01:29,409 --> 00:01:34,090
power on the computer to get a serial

00:01:31,420 --> 00:01:37,509
console to power off the computer to see

00:01:34,090 --> 00:01:40,899
what's the status of fans and it's a

00:01:37,509 --> 00:01:42,130
pretty much standard arm environment if

00:01:40,899 --> 00:01:44,380
you're at all familiar with sort of

00:01:42,130 --> 00:01:46,450
embedded arm Linux systems or as I like

00:01:44,380 --> 00:01:49,119
to call whatever random computing device

00:01:46,450 --> 00:01:51,070
I get at home yet another embedded arm

00:01:49,119 --> 00:01:52,360
Linux device that's gonna sit on a shelf

00:01:51,070 --> 00:01:54,729
for a little while and then migrate to

00:01:52,360 --> 00:01:58,299
my garage and be found five years later

00:01:54,729 --> 00:02:00,399
and go oh look it's yet another arm

00:01:58,299 --> 00:02:04,060
embedded Linux device so we have a

00:02:00,399 --> 00:02:06,640
computer inside your computer it's got

00:02:04,060 --> 00:02:09,580
you boot it's got you know Linux on nor

00:02:06,640 --> 00:02:13,780
flash usually using you know something

00:02:09,580 --> 00:02:14,200
like jmf s2 or ubi FS it has you know

00:02:13,780 --> 00:02:16,300
user

00:02:14,200 --> 00:02:19,150
space stack running on top of a standard

00:02:16,300 --> 00:02:20,950
Linux kernel and there's various

00:02:19,150 --> 00:02:23,890
configurations that will happen on

00:02:20,950 --> 00:02:25,239
different systems so like on the the

00:02:23,890 --> 00:02:26,950
Witherspoon system has some

00:02:25,239 --> 00:02:28,660
configurations option set that's

00:02:26,950 --> 00:02:32,680
different than like a teller system and

00:02:28,660 --> 00:02:34,540
something like like what do we call

00:02:32,680 --> 00:02:36,040
Boston that we release it anyway

00:02:34,540 --> 00:02:37,750
the other systems we have may have a

00:02:36,040 --> 00:02:39,819
different DMC stack but it's still

00:02:37,750 --> 00:02:41,860
essentially an embedded arm Linux

00:02:39,819 --> 00:02:44,170
computer and what is the other thing

00:02:41,860 --> 00:02:46,810
that these things operate the power

00:02:44,170 --> 00:02:48,610
button so like if you're using this more

00:02:46,810 --> 00:02:53,410
of the desktop like more of a talisman

00:02:48,610 --> 00:02:55,599
and a server like a Witherspoon once it

00:02:53,410 --> 00:02:57,910
is up it can look for the GPO that the

00:02:55,599 --> 00:02:59,920
physical power button because it turns

00:02:57,910 --> 00:03:03,940
out that some people want a physical

00:02:59,920 --> 00:03:05,349
power button on the computers I don't

00:03:03,940 --> 00:03:06,910
know why don't you all just remote

00:03:05,349 --> 00:03:08,380
manage all your servers why would you

00:03:06,910 --> 00:03:09,940
walk up to one and press a physical

00:03:08,380 --> 00:03:12,010
power button there's a remote one you

00:03:09,940 --> 00:03:13,630
don't have to get up you can sit at your

00:03:12,010 --> 00:03:17,560
desk and press the power button like why

00:03:13,630 --> 00:03:18,970
would you have to go to a data center it

00:03:17,560 --> 00:03:22,420
can also be a virtual power button right

00:03:18,970 --> 00:03:26,260
so it could be over IPMI or redfish or

00:03:22,420 --> 00:03:28,720
any kind of interface and what does the

00:03:26,260 --> 00:03:31,930
power button do well it has to kick off

00:03:28,720 --> 00:03:34,060
booting the main computer the power 9

00:03:31,930 --> 00:03:36,190
but what does the BMC booting look like

00:03:34,060 --> 00:03:39,100
luckily we have a simulation environment

00:03:36,190 --> 00:03:41,410
that it's nicely documented and it looks

00:03:39,100 --> 00:03:44,440
exactly like you know an embedded arm

00:03:41,410 --> 00:03:46,989
computer if you've ever used any kind of

00:03:44,440 --> 00:03:50,889
thing that looks like arm and Linux it

00:03:46,989 --> 00:03:55,739
looks like this right you vote loads of

00:03:50,889 --> 00:03:55,739
kernel loads Ram disk boots

00:03:59,270 --> 00:04:05,640
No so this is what you get on the serial

00:04:02,849 --> 00:04:07,410
port that's directly to the BMC so

00:04:05,640 --> 00:04:10,650
there's usually a header on the board

00:04:07,410 --> 00:04:16,440
that has a UART that's a BMC serial port

00:04:10,650 --> 00:04:18,269
and then you can see the BMC boot yeah

00:04:16,440 --> 00:04:20,639
this is physically next to the machine

00:04:18,269 --> 00:04:23,130
but this is what's happening before the

00:04:20,639 --> 00:04:25,110
power button works so like on a Telesis

00:04:23,130 --> 00:04:26,639
tum' when it's flashing a light getting

00:04:25,110 --> 00:04:29,310
ready after you plug in the power cord

00:04:26,639 --> 00:04:32,430
it's doing this and the same on like a

00:04:29,310 --> 00:04:34,530
Witherspoon on the minute or two after

00:04:32,430 --> 00:04:36,300
you plug in the power cord as in roughly

00:04:34,530 --> 00:04:38,070
about this long from when you plug in

00:04:36,300 --> 00:04:40,350
the power cord to when you can press the

00:04:38,070 --> 00:04:49,350
power button and power on the system its

00:04:40,350 --> 00:04:51,930
booting yeah I think it's physically

00:04:49,350 --> 00:04:53,220
flashing I mostly use them remotely so

00:04:51,930 --> 00:04:55,260
I'm not sure in the physical lights

00:04:53,220 --> 00:04:57,990
I'm pretty sure we need some webcams and

00:04:55,260 --> 00:05:00,000
some data centers looking at lights and

00:04:57,990 --> 00:05:02,190
some recognition to test this because

00:05:00,000 --> 00:05:14,660
all of us use the machines over in the

00:05:02,190 --> 00:05:14,660
other room yep that is true yeah

00:05:25,080 --> 00:05:30,099
[Laughter]

00:05:27,449 --> 00:05:31,419
there we go so that the the comet there

00:05:30,099 --> 00:05:33,400
is that the light won't flash until the

00:05:31,419 --> 00:05:34,900
BMC is running on a bunch of system so

00:05:33,400 --> 00:05:37,500
it depends on what system went worthy of

00:05:34,900 --> 00:05:39,819
a physical life that flashes or not

00:05:37,500 --> 00:05:41,979
where is the thing there but yeah the

00:05:39,819 --> 00:05:45,280
BMC is now booted so we were up to the

00:05:41,979 --> 00:05:50,219
point now which I have in slides which

00:05:45,280 --> 00:05:52,780
is what does the power button do well

00:05:50,219 --> 00:05:55,539
runs a little piece of software on on

00:05:52,780 --> 00:05:58,810
the BMC and its job is to little some

00:05:55,539 --> 00:06:00,940
bits to tell the p9 ship that it's time

00:05:58,810 --> 00:06:04,240
to boot right it's a simple little

00:06:00,940 --> 00:06:06,849
twiddle some GPIO s and then we engage

00:06:04,240 --> 00:06:09,639
what's known as the self boot engine so

00:06:06,849 --> 00:06:11,800
inside the power 9 chip there is all of

00:06:09,639 --> 00:06:13,270
your power 9 cause that do you know your

00:06:11,800 --> 00:06:15,370
real computer but there's another

00:06:13,270 --> 00:06:17,080
embedded processor actually there are

00:06:15,370 --> 00:06:18,430
many embedded processors because not

00:06:17,080 --> 00:06:20,590
only is there a computer inside your

00:06:18,430 --> 00:06:23,439
computer there are processors inside

00:06:20,590 --> 00:06:26,740
your processor because it is in fact

00:06:23,439 --> 00:06:32,069
Turtles all of the way down completely

00:06:26,740 --> 00:06:32,069
all the way down and a lot of computers

00:06:33,000 --> 00:06:38,620
can we see only Sol yeah yeah we're not

00:06:36,699 --> 00:06:41,729
up to Sol yet so at this point you've

00:06:38,620 --> 00:06:44,259
not gotten anything over a serial port

00:06:41,729 --> 00:06:47,940
you you've just pushed your button and

00:06:44,259 --> 00:06:50,139
we are now starting the self boot engine

00:06:47,940 --> 00:06:53,229
the question of pushing the power button

00:06:50,139 --> 00:06:55,779
remotely this could be IPMI tool power

00:06:53,229 --> 00:06:58,150
on it could be going to the web UI and

00:06:55,779 --> 00:07:00,550
clicking power on it could be over

00:06:58,150 --> 00:07:02,560
redfish if it was for thread fish or

00:07:00,550 --> 00:07:06,009
could be over the rest api or it could

00:07:02,560 --> 00:07:08,589
be SSH into the BMC and typing o BMC

00:07:06,009 --> 00:07:10,990
util power on any of those is

00:07:08,589 --> 00:07:12,729
functionally equivalent you've all

00:07:10,990 --> 00:07:15,180
you've done is told the BMC that somehow

00:07:12,729 --> 00:07:19,690
you want to twiddle the GPIO is to say

00:07:15,180 --> 00:07:22,990
hey go boot the SVA and what does the

00:07:19,690 --> 00:07:25,360
SBE do well its job is really simple

00:07:22,990 --> 00:07:28,509
it's a tiny little processor and its job

00:07:25,360 --> 00:07:30,430
is to get one core that's a power 9 core

00:07:28,509 --> 00:07:34,360
up to a state where it can run

00:07:30,430 --> 00:07:35,889
instructions out of l3 cache and to put

00:07:34,360 --> 00:07:38,199
something in that cache that it can

00:07:35,889 --> 00:07:42,550
execute to load the next bit of firmware

00:07:38,199 --> 00:07:44,860
so there's a tiny bit of ROM or C prom

00:07:42,550 --> 00:07:46,689
inside the painting inside the p9 ship

00:07:44,860 --> 00:07:49,090
that contains the self boot engine

00:07:46,689 --> 00:07:50,949
firmware and this is the the core root

00:07:49,090 --> 00:07:52,479
of trust for your system as well so it's

00:07:50,949 --> 00:07:54,550
going to do the first bit of load of

00:07:52,479 --> 00:07:57,580
firmware the first bit of verification

00:07:54,550 --> 00:08:00,879
I'm gonna go from there and the job it's

00:07:57,580 --> 00:08:03,430
going to start is sort of the left-hand

00:08:00,879 --> 00:08:07,060
side here so this is a flowchart that's

00:08:03,430 --> 00:08:09,969
in open powered github organization for

00:08:07,060 --> 00:08:12,909
p9 at the old flow and we have the very

00:08:09,969 --> 00:08:14,050
first stages of SPE boot and we don't

00:08:12,909 --> 00:08:16,029
really need to go through the details

00:08:14,050 --> 00:08:18,729
you can go and read the boring details

00:08:16,029 --> 00:08:22,990
or the exciting details of how your

00:08:18,729 --> 00:08:24,759
computer boots a bit later but the

00:08:22,990 --> 00:08:26,860
initial program load or IPL as I'd

00:08:24,759 --> 00:08:29,349
probably keep calling it is probably a

00:08:26,860 --> 00:08:31,120
uniquely IBM term and it probably dates

00:08:29,349 --> 00:08:33,219
because IBM's done computers for a very

00:08:31,120 --> 00:08:35,969
very long time and therefore came up

00:08:33,219 --> 00:08:38,709
with it before people called it booting

00:08:35,969 --> 00:08:40,719
so if I say IPL it means booting and

00:08:38,709 --> 00:08:44,350
I've just been assimilated into the IBM

00:08:40,719 --> 00:08:46,690
hivemind of terminology and so what does

00:08:44,350 --> 00:08:49,570
this sort of tell us well CPUs don't

00:08:46,690 --> 00:08:52,449
just work right you don't just it's not

00:08:49,570 --> 00:08:54,640
like the good old days of the z80 or the

00:08:52,449 --> 00:08:56,500
6502 where you just apply some current

00:08:54,640 --> 00:08:59,649
and it starts executing instructions

00:08:56,500 --> 00:09:03,279
right we have a computer inside the

00:08:59,649 --> 00:09:05,320
computer that is roughly that right but

00:09:03,279 --> 00:09:10,029
we do actually have a lot of setup to do

00:09:05,320 --> 00:09:12,100
right to get things going in the dim

00:09:10,029 --> 00:09:13,959
dark past we didn't have a self boot

00:09:12,100 --> 00:09:16,990
engine what happened was the service

00:09:13,959 --> 00:09:19,269
processor would do all of its work right

00:09:16,990 --> 00:09:20,829
so with power eight we had the start of

00:09:19,269 --> 00:09:22,899
having an engine inside the chip that

00:09:20,829 --> 00:09:24,760
could boot the chip and it's called a

00:09:22,899 --> 00:09:28,360
self boot engine because the chip is

00:09:24,760 --> 00:09:31,000
booting itself right and this isn't how

00:09:28,360 --> 00:09:32,860
most modern processors work the reason

00:09:31,000 --> 00:09:35,290
we didn't need one previously is that

00:09:32,860 --> 00:09:37,360
there was always a sophisticated service

00:09:35,290 --> 00:09:38,699
processor with a lot of intimate

00:09:37,360 --> 00:09:41,800
knowledge about how to boot the computer

00:09:38,699 --> 00:09:44,620
right and with a BMC stack on open power

00:09:41,800 --> 00:09:46,120
systems we decouple them right it does

00:09:44,620 --> 00:09:47,829
it needs some knowledge of the system

00:09:46,120 --> 00:09:49,899
but it doesn't need in-depth knowledge

00:09:47,829 --> 00:09:52,080
of the inside of the chip and that's a

00:09:49,899 --> 00:09:56,080
feature for ease of development

00:09:52,080 --> 00:09:57,850
so what do we mean by security there are

00:09:56,080 --> 00:10:00,700
two separate security domains in an open

00:09:57,850 --> 00:10:02,950
tower system right we try and have it so

00:10:00,700 --> 00:10:05,350
the BMC doesn't have to trust the host

00:10:02,950 --> 00:10:07,540
and the host doesn't have to trust the

00:10:05,350 --> 00:10:09,840
BMC that is the secure boot

00:10:07,540 --> 00:10:13,420
implementation on the host processor

00:10:09,840 --> 00:10:15,970
only concentrates with itself and

00:10:13,420 --> 00:10:18,220
doesn't assume that the BMC is trusted

00:10:15,970 --> 00:10:21,580
and so you could have you know separate

00:10:18,220 --> 00:10:23,620
entities going and the SPE engine itself

00:10:21,580 --> 00:10:26,920
is the core root of trust so it has

00:10:23,620 --> 00:10:29,680
inside that see prom a hash of the core

00:10:26,920 --> 00:10:31,240
firmware secure boot keys and so as it

00:10:29,680 --> 00:10:33,850
loads the next bit of firmware a flash

00:10:31,240 --> 00:10:36,400
it verifies that those hashes match and

00:10:33,850 --> 00:10:38,920
if it does it continues to boot and if

00:10:36,400 --> 00:10:41,710
it doesn't you don't boot if it doesn't

00:10:38,920 --> 00:10:44,170
this is actually before we have serial

00:10:41,710 --> 00:10:45,760
Overland console so what you have is in

00:10:44,170 --> 00:10:48,610
a computer that says powered on and you

00:10:45,760 --> 00:10:50,080
get no printout which isn't ideal but if

00:10:48,610 --> 00:10:52,510
you've got to that problem you've got

00:10:50,080 --> 00:10:57,010
like you've got bigger firmware problems

00:10:52,510 --> 00:10:58,510
but this is the core root of trust to

00:10:57,010 --> 00:11:00,430
make that obviously so that you can't

00:10:58,510 --> 00:11:02,710
just overwrite that at runtime there is

00:11:00,430 --> 00:11:04,030
a flag that gets set early in boot that

00:11:02,710 --> 00:11:06,490
says you can no longer update that

00:11:04,030 --> 00:11:08,320
that's EEPROM until you re I PL so you

00:11:06,490 --> 00:11:10,540
can do a firmware update of the see prom

00:11:08,320 --> 00:11:13,630
it happens really early in boot after

00:11:10,540 --> 00:11:15,730
there's been signature verification and

00:11:13,630 --> 00:11:17,350
you can also if you have the secure boot

00:11:15,730 --> 00:11:19,120
jumper set so you're not doing secure

00:11:17,350 --> 00:11:23,320
boot you can then write it from the BMC

00:11:19,120 --> 00:11:27,430
as well to unbreak a chip so we're we up

00:11:23,320 --> 00:11:29,650
to getting a call going basically what

00:11:27,430 --> 00:11:33,220
happens is that we have to do a thing

00:11:29,650 --> 00:11:35,230
called scan in the scan rings which is

00:11:33,220 --> 00:11:36,760
basically there's a giant shift register

00:11:35,230 --> 00:11:38,170
inside the chip that sets a bunch of

00:11:36,760 --> 00:11:40,240
settings which are the magic settings

00:11:38,170 --> 00:11:42,670
that means the chip will start executing

00:11:40,240 --> 00:11:44,590
instructions with these things set right

00:11:42,670 --> 00:11:45,850
so you design a chip you don't know all

00:11:44,590 --> 00:11:47,620
of the details for the physical

00:11:45,850 --> 00:11:49,090
properties of it and you might not know

00:11:47,620 --> 00:11:50,680
whether certain functionality is going

00:11:49,090 --> 00:11:52,000
to work when you actually fab it

00:11:50,680 --> 00:11:54,130
obviously have a bunch of little

00:11:52,000 --> 00:11:55,990
switches and so we scan that in we do a

00:11:54,130 --> 00:11:57,910
bunch of other init's going on really

00:11:55,990 --> 00:12:01,110
early on to get the CPU core up and

00:11:57,910 --> 00:12:03,670
running so what did the SPE does is it

00:12:01,110 --> 00:12:05,300
writes all these values in and sets it

00:12:03,670 --> 00:12:07,850
up and then

00:12:05,300 --> 00:12:11,840
it gets what we call the host boot boot

00:12:07,850 --> 00:12:14,030
loader from that see prom and puts it

00:12:11,840 --> 00:12:16,730
into l3 cache and it's a tiny bit of

00:12:14,030 --> 00:12:18,770
code whose only job executing the power

00:12:16,730 --> 00:12:20,480
9 chip and read the next stage of

00:12:18,770 --> 00:12:23,180
firmware right because we don't have

00:12:20,480 --> 00:12:24,970
much room inside that's SBAC from so we

00:12:23,180 --> 00:12:29,150
go and load the host boot boot loader

00:12:24,970 --> 00:12:30,650
and it's job is to be the very first

00:12:29,150 --> 00:12:33,200
instructions that are executed on the

00:12:30,650 --> 00:12:34,820
power 9 so we still don't have anything

00:12:33,200 --> 00:12:36,560
over serial over LAN but we are now

00:12:34,820 --> 00:12:38,900
executing instructions on the power 9

00:12:36,560 --> 00:12:41,570
chip as opposed to the self boot engine

00:12:38,900 --> 00:12:42,950
or the service processor and its job

00:12:41,570 --> 00:12:44,900
here is to load the host boot based

00:12:42,950 --> 00:12:47,900
image which is the very first sort of

00:12:44,900 --> 00:12:50,090
large bit of firmware so remember at

00:12:47,900 --> 00:12:52,430
this point we don't have ram we're just

00:12:50,090 --> 00:12:55,910
in l3 cache we don't have any other

00:12:52,430 --> 00:12:58,430
cause we don't have any SMP we don't

00:12:55,910 --> 00:13:00,440
have PCI we don't have any power saving

00:12:58,430 --> 00:13:04,850
so we're running the core clock at a

00:13:00,440 --> 00:13:06,770
pretty low value and we don't have all

00:13:04,850 --> 00:13:09,590
those fancy things right we just have

00:13:06,770 --> 00:13:11,210
one little core executing some code that

00:13:09,590 --> 00:13:13,910
is more powerful than any computer we

00:13:11,210 --> 00:13:15,530
had in the 80s but it's still like

00:13:13,910 --> 00:13:17,420
actually probably even more than 10

00:13:15,530 --> 00:13:19,610
years ago like crazy amount of computing

00:13:17,420 --> 00:13:22,760
power but relatively simple and slow

00:13:19,610 --> 00:13:25,310
compared to a fall you know to socket +

00:13:22,760 --> 00:13:27,560
power 9 system so up to the host boot

00:13:25,310 --> 00:13:29,600
boot boot boot loader loading the host

00:13:27,560 --> 00:13:32,090
boot base image so in this giant IPL

00:13:29,600 --> 00:13:33,890
firm that thing there we're a start

00:13:32,090 --> 00:13:37,790
bootloader here and guess what we have

00:13:33,890 --> 00:13:39,820
now the next steps right and so the next

00:13:37,790 --> 00:13:41,990
steps are all these various IPL steps

00:13:39,820 --> 00:13:44,360
and what do we have to do during all of

00:13:41,990 --> 00:13:45,740
that that's setup so this is when you

00:13:44,360 --> 00:13:47,570
see the banner the first thing you'll

00:13:45,740 --> 00:13:49,910
see on a serial over LAN connection

00:13:47,570 --> 00:13:53,330
welcome to host boot right and you'll

00:13:49,910 --> 00:13:59,570
see I step 6 dot something see if I can

00:13:53,330 --> 00:14:02,000
very quickly show this reboot so this is

00:13:59,570 --> 00:14:05,390
a machine rebooting so it's gonna start

00:14:02,000 --> 00:14:07,610
reboot and take a second but that'll

00:14:05,390 --> 00:14:10,190
show in a second so what do we need to

00:14:07,610 --> 00:14:12,020
do inside these in these ice steps well

00:14:10,190 --> 00:14:17,800
we have to bring up the other cause we

00:14:12,020 --> 00:14:17,800
have to bring up DRAM we have to

00:14:19,129 --> 00:14:23,839
in former service processor about our

00:14:21,290 --> 00:14:25,459
machine inventory and stuff like that we

00:14:23,839 --> 00:14:28,670
need to find what dims are there we need

00:14:25,459 --> 00:14:30,740
to set up SMP links we need to make sure

00:14:28,670 --> 00:14:35,179
that everyone thinks the right time is

00:14:30,740 --> 00:14:36,379
the right time for example and so

00:14:35,179 --> 00:14:40,429
there's a whole bunch of in it that goes

00:14:36,379 --> 00:14:42,949
on we might have you know different sort

00:14:40,429 --> 00:14:44,300
of peripherals we need to train so on

00:14:42,949 --> 00:14:45,319
some systems there might be like memory

00:14:44,300 --> 00:14:47,059
buffers or something like that

00:14:45,319 --> 00:14:48,379
there will be a whole bunch of registers

00:14:47,059 --> 00:14:52,550
that we need to set to some default

00:14:48,379 --> 00:14:54,529
values all sorts of little steps along

00:14:52,550 --> 00:14:56,990
the way there is welcome to host boot

00:14:54,529 --> 00:14:59,389
secure um valid so now we are out of the

00:14:56,990 --> 00:15:01,490
SP a we are into host alerts or in the

00:14:59,389 --> 00:15:03,230
host boot base image and what it does is

00:15:01,490 --> 00:15:04,670
actually has a lot of code in it so it's

00:15:03,230 --> 00:15:07,009
not just the base image that gets loaded

00:15:04,670 --> 00:15:11,629
it has an extended image and actually

00:15:07,009 --> 00:15:14,420
pages in pages of memory from flash so

00:15:11,629 --> 00:15:18,019
it's like a tiny operating system with a

00:15:14,420 --> 00:15:21,319
memory management and swap in order to

00:15:18,019 --> 00:15:23,269
get enough code running in l3 before you

00:15:21,319 --> 00:15:25,939
get up to D Ram so when we get into DRAM

00:15:23,269 --> 00:15:26,360
in it like it's 1314 you see this dear a

00:15:25,939 --> 00:15:29,029
minute

00:15:26,360 --> 00:15:30,709
remember we're now zeroing our memory

00:15:29,029 --> 00:15:32,480
because they have ECC memory so we need

00:15:30,709 --> 00:15:34,339
to set all the flag stuff there and now

00:15:32,480 --> 00:15:36,049
we're sort of exited cache contained and

00:15:34,339 --> 00:15:38,509
now we're onto the next IPL step which

00:15:36,049 --> 00:15:42,639
goes of course faster than moment a my

00:15:38,509 --> 00:15:42,639
my slides will do so

00:15:44,679 --> 00:15:49,519
cousin tomorrow but one of the stages

00:15:48,230 --> 00:15:52,999
that happens in here is we have to set

00:15:49,519 --> 00:15:55,999
up for power saving States so what we

00:15:52,999 --> 00:15:58,399
call is we have a stop image and part of

00:15:55,999 --> 00:16:01,610
this image is to be able to have a CPU

00:15:58,399 --> 00:16:02,899
cord that we turn off right it's really

00:16:01,610 --> 00:16:04,339
low power saving if you turn something

00:16:02,899 --> 00:16:07,220
off but we need to be able to turn it

00:16:04,339 --> 00:16:09,230
back on again so we have a stop

00:16:07,220 --> 00:16:11,360
instruction which is hey stop the CPU

00:16:09,230 --> 00:16:13,069
and then we have a method to resume it

00:16:11,360 --> 00:16:15,649
so it really should be like a resume

00:16:13,069 --> 00:16:18,709
image rather than stop but they will

00:16:15,649 --> 00:16:21,410
help that's how we go we have another

00:16:18,709 --> 00:16:23,089
bit of firmware called H code which is

00:16:21,410 --> 00:16:25,339
the code that runs on this tiny little

00:16:23,089 --> 00:16:27,740
other embedded processor inside your

00:16:25,339 --> 00:16:30,640
processor next to the core and it's job

00:16:27,740 --> 00:16:32,170
is to turn the core back on

00:16:30,640 --> 00:16:34,600
its main job so as you go into a

00:16:32,170 --> 00:16:36,010
low-power state at runtime its job is to

00:16:34,600 --> 00:16:37,900
be a to turn that core back on and

00:16:36,010 --> 00:16:39,600
restore some register state enough so

00:16:37,900 --> 00:16:41,770
that Lennox can get back up and running

00:16:39,600 --> 00:16:43,030
so the idea is if you have bursty

00:16:41,770 --> 00:16:45,130
workloads or something running at

00:16:43,030 --> 00:16:47,350
runtime we can turn off some cause to

00:16:45,130 --> 00:16:49,030
save some power and we can also turn off

00:16:47,350 --> 00:16:51,870
some cause to save some power so we can

00:16:49,030 --> 00:16:55,030
clock other cause at a higher frequency

00:16:51,870 --> 00:16:57,130
so part of the job in this hole in it is

00:16:55,030 --> 00:16:59,650
to set up the stop image and load the H

00:16:57,130 --> 00:17:02,620
code firmware up and get that going it's

00:16:59,650 --> 00:17:04,660
also a job is to get the OCC running so

00:17:02,620 --> 00:17:07,150
the OCC is the on chip controller which

00:17:04,660 --> 00:17:09,730
is another embedded processor inside

00:17:07,150 --> 00:17:11,410
your processor and it's a 32-bit PowerPC

00:17:09,730 --> 00:17:13,839
system with a bunch of little helpers of

00:17:11,410 --> 00:17:17,380
Pepe engines so more processors to help

00:17:13,839 --> 00:17:19,480
it and it has a couple of jobs its main

00:17:17,380 --> 00:17:22,390
job as we say is CPU frequency scaling

00:17:19,480 --> 00:17:24,579
and to enforce our hard power limits so

00:17:22,390 --> 00:17:25,600
it's job is basically you know keep

00:17:24,579 --> 00:17:28,329
within a certain amount of power

00:17:25,600 --> 00:17:29,950
consumption be out of scale frequency up

00:17:28,329 --> 00:17:32,260
to do bursts and sort of ultra turbo

00:17:29,950 --> 00:17:33,760
frequencies as well as it does some

00:17:32,260 --> 00:17:35,500
things to help get some debug data out

00:17:33,760 --> 00:17:37,630
like in the case of a check stop the

00:17:35,500 --> 00:17:39,730
checks off is when the processor hits a

00:17:37,630 --> 00:17:41,590
condition that it can no longer continue

00:17:39,730 --> 00:17:44,350
to execute without possibly acting on

00:17:41,590 --> 00:17:47,560
bad data so we stop the world the logic

00:17:44,350 --> 00:17:49,720
being that we will not possibly execute

00:17:47,560 --> 00:17:51,310
instructions based on bad data so that

00:17:49,720 --> 00:17:53,440
chip will stop itself rather than

00:17:51,310 --> 00:17:54,640
possibly acting on bad data and there

00:17:53,440 --> 00:17:56,500
are some error conditions you can have

00:17:54,640 --> 00:17:58,300
in the chip either due to your hardware

00:17:56,500 --> 00:18:01,600
faults or software faults that have

00:17:58,300 --> 00:18:03,520
basically trigger that condition so the

00:18:01,600 --> 00:18:05,140
OCC gets set up and started it has its

00:18:03,520 --> 00:18:07,810
own bit of firmware that's loaded into

00:18:05,140 --> 00:18:09,100
the OCC and then it does its boot

00:18:07,810 --> 00:18:11,260
process and it has a little bit of

00:18:09,100 --> 00:18:14,290
shared memory that we communicate with

00:18:11,260 --> 00:18:17,440
the rest of a runtime firmware as well

00:18:14,290 --> 00:18:19,630
as a boot time to go to say here are the

00:18:17,440 --> 00:18:20,980
CPU frequencies you can do and control

00:18:19,630 --> 00:18:23,110
it as well as it does some sensor

00:18:20,980 --> 00:18:24,400
management and stuff like that we also

00:18:23,110 --> 00:18:26,670
have what we refer to as host bit

00:18:24,400 --> 00:18:30,940
runtime which is a bunch of runtime

00:18:26,670 --> 00:18:32,650
diagnostics and repair code oh this is

00:18:30,940 --> 00:18:34,300
run through the opal PRD application

00:18:32,650 --> 00:18:37,030
this is actually a bit of firmware that

00:18:34,300 --> 00:18:38,530
we run in userspace right so when you

00:18:37,030 --> 00:18:40,960
start the opal peyote application from

00:18:38,530 --> 00:18:43,570
Linux it will call it will do host boot

00:18:40,960 --> 00:18:44,260
runtime code to do specific diagnostics

00:18:43,570 --> 00:18:46,600
and repair

00:18:44,260 --> 00:18:48,610
at runtime based on that actual machine

00:18:46,600 --> 00:18:50,260
so it's like we run it in user space

00:18:48,610 --> 00:18:50,770
because then if there's any bugs in that

00:18:50,260 --> 00:18:52,210
code

00:18:50,770 --> 00:18:54,820
guess what you get a seg fault not a

00:18:52,210 --> 00:18:58,060
giant crash or scribbling over in memory

00:18:54,820 --> 00:19:00,280
data and it can also process our logs do

00:18:58,060 --> 00:19:01,600
some yeah the around repair and other

00:19:00,280 --> 00:19:03,460
preventative maintenance and stuff like

00:19:01,600 --> 00:19:07,000
that as well but we also set up post bit

00:19:03,460 --> 00:19:08,680
runtime and host boot and now we get to

00:19:07,000 --> 00:19:10,320
the next stage of firmware which is ski

00:19:08,680 --> 00:19:13,480
boot which is what I primarily work on

00:19:10,320 --> 00:19:15,490
so host boot at this point has verified

00:19:13,480 --> 00:19:16,930
less and done secure boot signature

00:19:15,490 --> 00:19:19,030
verification on all the previous

00:19:16,930 --> 00:19:20,830
components and then it goes and loads

00:19:19,030 --> 00:19:22,060
ski boot which is also verified so we're

00:19:20,830 --> 00:19:25,720
still doing that firmware secure boot

00:19:22,060 --> 00:19:28,150
stuff ski boot does boot and runtime

00:19:25,720 --> 00:19:29,530
firmware as well so it has you know some

00:19:28,150 --> 00:19:31,270
of the job of booting the machine as

00:19:29,530 --> 00:19:32,740
well as the job of being the bit of

00:19:31,270 --> 00:19:35,470
firmware that stays resident at runtime

00:19:32,740 --> 00:19:37,150
so opal calls is what ski boot

00:19:35,470 --> 00:19:38,950
implements and that is what the Linux

00:19:37,150 --> 00:19:40,630
kernel uses to make firmware calls at

00:19:38,950 --> 00:19:42,760
runtime and this means that we don't

00:19:40,630 --> 00:19:45,640
have to have intimate knowledge of each

00:19:42,760 --> 00:19:47,110
bit of hardware in Linux we can abstract

00:19:45,640 --> 00:19:49,090
that away through opal so the idea is

00:19:47,110 --> 00:19:52,330
that skooby provides the absolute

00:19:49,090 --> 00:19:54,070
minimal layer of runtime firmware to do

00:19:52,330 --> 00:19:56,230
that job and not anymore

00:19:54,070 --> 00:19:58,570
it's design choice is that Linux is

00:19:56,230 --> 00:20:00,280
always in charge so opal never receives

00:19:58,570 --> 00:20:02,260
interrupts by itself it's always Linux

00:20:00,280 --> 00:20:04,120
gets it first and passes it through the

00:20:02,260 --> 00:20:06,190
ideas Linux is in charge well

00:20:04,120 --> 00:20:07,990
essentially a shared library we're in

00:20:06,190 --> 00:20:09,250
the same address space and it's just

00:20:07,990 --> 00:20:12,730
here is the calling convention to make

00:20:09,250 --> 00:20:15,670
function calls that's it really really

00:20:12,730 --> 00:20:17,380
simple stuff so it we unit things like

00:20:15,670 --> 00:20:20,770
the chip Todd so that's the time base

00:20:17,380 --> 00:20:22,210
register we use the SBE for like runtime

00:20:20,770 --> 00:20:25,060
stuff we do a bunch of I squid sea

00:20:22,210 --> 00:20:26,590
sensors nvram stop states and frequency

00:20:25,060 --> 00:20:28,720
scaling and mapping that to what Linux

00:20:26,590 --> 00:20:31,180
can understand we have the NX unit we

00:20:28,720 --> 00:20:33,370
set up we scan PCI we set up in V link

00:20:31,180 --> 00:20:35,950
like caffeine open Cappy and then we

00:20:33,370 --> 00:20:42,220
load and boot a Linux kernel so from

00:20:35,950 --> 00:20:45,640
flash we have we have the last step of

00:20:42,220 --> 00:20:49,660
ski boot is to load from flash and

00:20:45,640 --> 00:20:53,290
embedded Linux kernel so we have a Linux

00:20:49,660 --> 00:20:54,850
kernel and user space in flash that runs

00:20:53,290 --> 00:20:57,700
a user space application called petty

00:20:54,850 --> 00:21:00,220
boot because we needed a menu option to

00:20:57,700 --> 00:21:01,840
like what OS you want to boot and it

00:21:00,220 --> 00:21:04,990
turns out that we had drivers for allow

00:21:01,840 --> 00:21:07,059
IO devices and Linux already and it's

00:21:04,990 --> 00:21:09,340
quite nice to write a UI in user space

00:21:07,059 --> 00:21:10,510
rather than kernel space so to save

00:21:09,340 --> 00:21:13,480
ourselves having to re-implement

00:21:10,510 --> 00:21:16,539
everything again we just used Linux and

00:21:13,480 --> 00:21:19,889
store it in flash so we boot an embedded

00:21:16,539 --> 00:21:22,539
Linux system and all this does is

00:21:19,889 --> 00:21:25,630
provide a nice user interface around Kay

00:21:22,539 --> 00:21:27,340
exec so you're running a kernel it finds

00:21:25,630 --> 00:21:29,889
what kernels you can boot and what OS is

00:21:27,340 --> 00:21:31,570
you hit hey please boot it so we do the

00:21:29,889 --> 00:21:33,700
Finder OS stage you know we've

00:21:31,570 --> 00:21:40,000
discovered block devices network devices

00:21:33,700 --> 00:21:41,470
get DHCP and then we KX and our job is

00:21:40,000 --> 00:21:44,139
to make sure K exec of course always

00:21:41,470 --> 00:21:45,490
work and at this point we leave that

00:21:44,139 --> 00:21:47,440
boot environment so we leave that

00:21:45,490 --> 00:21:49,750
embedded Linux environment it's gone and

00:21:47,440 --> 00:21:52,480
now we actually have your standard Linux

00:21:49,750 --> 00:22:01,960
as in Europe unto your Red Hat or Debian

00:21:52,480 --> 00:22:03,250
or Fedora or your own district yeah yeah

00:22:01,960 --> 00:22:04,990
that's how it looks like the computers

00:22:03,250 --> 00:22:06,460
shutting down just before we don't yeah

00:22:04,990 --> 00:22:11,260
we should really we should really change

00:22:06,460 --> 00:22:12,370
that message yeah but but yes that's the

00:22:11,260 --> 00:22:14,289
last bit where you have the petty boot

00:22:12,370 --> 00:22:17,019
menu and when it's booting that it goes

00:22:14,289 --> 00:22:19,120
off shutting down starting starting

00:22:17,019 --> 00:22:22,269
things again so at this point we're now

00:22:19,120 --> 00:22:23,830
booting standard Linux and this is the

00:22:22,269 --> 00:22:25,809
point where firmware job is to just be

00:22:23,830 --> 00:22:28,389
the runtime component and we're now into

00:22:25,809 --> 00:22:29,769
your normal OS apparently the FreeBSD

00:22:28,389 --> 00:22:32,169
guys have got things running as well so

00:22:29,769 --> 00:22:40,320
you could also k exec previous date just

00:22:32,169 --> 00:22:42,610
kind of nice to see a second thing and

00:22:40,320 --> 00:22:46,200
here's one I prepared earlier hey look

00:22:42,610 --> 00:22:46,200
it's a login prompt yay

00:22:46,620 --> 00:22:53,529
very exciting so what do we also have

00:22:51,940 --> 00:22:55,840
that that can be do there as firmware

00:22:53,529 --> 00:22:59,799
well we also have a feature called fast

00:22:55,840 --> 00:23:02,830
reboot which is a way to reboot in a

00:22:59,799 --> 00:23:06,340
handful of seconds rather than a couple

00:23:02,830 --> 00:23:08,980
of minutes and we do this by not

00:23:06,340 --> 00:23:10,809
reinitializing everything right we only

00:23:08,980 --> 00:23:11,140
riu know a subset of hardware that we

00:23:10,809 --> 00:23:13,420
don't

00:23:11,140 --> 00:23:16,780
we trained d ram and we don't you know

00:23:13,420 --> 00:23:18,790
reset up the OCC or H Co but we do you

00:23:16,780 --> 00:23:21,550
know rescan PCI we reset a bunch of

00:23:18,790 --> 00:23:23,440
course date we clear nvram we clear a

00:23:21,550 --> 00:23:28,630
bunch of registers and we reload petty

00:23:23,440 --> 00:23:30,160
boot so the the downside of fast reboot

00:23:28,630 --> 00:23:32,920
is of course you don't get the same

00:23:30,160 --> 00:23:35,170
secure boot or sorry trusted boot state

00:23:32,920 --> 00:23:37,150
and the TPM right and there's always a

00:23:35,170 --> 00:23:40,090
chance that we you know we have a bug

00:23:37,150 --> 00:23:41,560
and that doesn't work as well but it

00:23:40,090 --> 00:23:44,080
does mean that you can tight reboot and

00:23:41,560 --> 00:23:45,250
get your next OS up in a handful of

00:23:44,080 --> 00:23:48,130
seconds so if you're doing a security

00:23:45,250 --> 00:23:52,290
update on OS it means you're sort of

00:23:48,130 --> 00:23:52,290
downtime and reboot cycle is a lot less

00:23:53,790 --> 00:23:58,450
that works on a bunch of machines not

00:23:56,440 --> 00:23:59,830
all of them because we don't have the

00:23:58,450 --> 00:24:01,720
code there to let Reena and feeling

00:23:59,830 --> 00:24:03,820
hardware so for the witherspoon system

00:24:01,720 --> 00:24:06,430
that doesn't work but for you know other

00:24:03,820 --> 00:24:08,290
systems it does and the other time of

00:24:06,430 --> 00:24:10,960
boot that we have I just wanted to put

00:24:08,290 --> 00:24:13,420
in and one more thing because it aims

00:24:10,960 --> 00:24:16,180
scrambling to get our demo to do this

00:24:13,420 --> 00:24:18,730
and they're like who you are we have a

00:24:16,180 --> 00:24:21,460
thing called MPI PL so this is memory

00:24:18,730 --> 00:24:23,110
preserving IPL the idea and this is

00:24:21,460 --> 00:24:26,380
currently in development the idea is

00:24:23,110 --> 00:24:28,540
when you crash the OS or certain air

00:24:26,380 --> 00:24:30,250
conditions inside the chip what you do

00:24:28,540 --> 00:24:32,830
is instead of doing a full reboot which

00:24:30,250 --> 00:24:35,650
clears memory is you do a reboot in a

00:24:32,830 --> 00:24:38,620
subset of RAM that you've reserved re in

00:24:35,650 --> 00:24:40,300
a whole bunch of stuff and then copy the

00:24:38,620 --> 00:24:43,150
contents of the memory from the crashed

00:24:40,300 --> 00:24:44,800
instance into a core file and now you

00:24:43,150 --> 00:24:47,110
have the ability to do a crash dump

00:24:44,800 --> 00:24:49,150
analysis because you get a core but of

00:24:47,110 --> 00:24:50,770
your computer and of your firmware so

00:24:49,150 --> 00:24:53,500
you use all the standard like kdump

00:24:50,770 --> 00:24:55,300
tools that come with linux to trace what

00:24:53,500 --> 00:24:56,620
might have gone wrong and firmware what

00:24:55,300 --> 00:25:00,460
might have gone wrong in the kernel and

00:24:56,620 --> 00:25:02,260
so this is the absolute fast-forward

00:25:00,460 --> 00:25:05,410
demo that's right at the end as I'm

00:25:02,260 --> 00:25:06,970
running out of time so I will play it

00:25:05,410 --> 00:25:08,860
fast an attempt to say here's the magic

00:25:06,970 --> 00:25:11,920
since our cue trigger to trigger a crash

00:25:08,860 --> 00:25:14,800
it goes hey look yep where we crashed

00:25:11,920 --> 00:25:16,120
and it will now attempt to to reboot and

00:25:14,800 --> 00:25:18,400
we'll do a memory because everything

00:25:16,120 --> 00:25:19,900
I've yellow so that I think I'm right at

00:25:18,400 --> 00:25:21,820
the end of the time as well with one

00:25:19,900 --> 00:25:24,110
minute to go and we'll see how fast this

00:25:21,820 --> 00:25:27,600
can possibly play

00:25:24,110 --> 00:25:29,880
but this is sort of something that's

00:25:27,600 --> 00:25:32,130
coming as sort of a nearby firmware

00:25:29,880 --> 00:25:34,920
feature just kind of neat and so

00:25:32,130 --> 00:25:36,870
hopefully we will get that going it

00:25:34,920 --> 00:25:39,720
takes a bit of time to get some dumping

00:25:36,870 --> 00:25:41,790
so this is like the status of the debug

00:25:39,720 --> 00:25:44,730
bits of firmware to make sure that it

00:25:41,790 --> 00:25:47,370
happens but at this point it should

00:25:44,730 --> 00:25:49,830
actually start sort of booting again in

00:25:47,370 --> 00:25:51,120
a second and we'll go back and we'll be

00:25:49,830 --> 00:25:53,010
able to take a crash dump and it does a

00:25:51,120 --> 00:25:55,590
little bit of analysis but is there any

00:25:53,010 --> 00:25:57,960
sort of final questions as the the magic

00:25:55,590 --> 00:26:00,390
demo of how to debug your system better

00:25:57,960 --> 00:26:03,030
than probably any other development

00:26:00,390 --> 00:26:05,280
workstation in the world I could do so

00:26:03,030 --> 00:26:06,240
in the background of this this is the

00:26:05,280 --> 00:26:07,770
point where you're now going to dump

00:26:06,240 --> 00:26:09,240
file so you've never a core dump of your

00:26:07,770 --> 00:26:11,100
entire memory content whether you had a

00:26:09,240 --> 00:26:13,440
kernel bug or firmware bug and you can

00:26:11,100 --> 00:26:15,210
now like use like the crash tool to get

00:26:13,440 --> 00:26:16,320
back traces on what happened and cause

00:26:15,210 --> 00:26:18,780
your machine to crash so if you're doing

00:26:16,320 --> 00:26:21,240
low-level kernel development or driver

00:26:18,780 --> 00:26:22,679
development or firmware development this

00:26:21,240 --> 00:26:25,380
one over you to sort of much better

00:26:22,679 --> 00:26:28,110
diagnose things in band without having

00:26:25,380 --> 00:26:31,450
to attach an external debug box and I

00:26:28,110 --> 00:26:34,989
think I'm well out of time

00:26:31,450 --> 00:26:34,989

YouTube URL: https://www.youtube.com/watch?v=hcLhKjxa-40


