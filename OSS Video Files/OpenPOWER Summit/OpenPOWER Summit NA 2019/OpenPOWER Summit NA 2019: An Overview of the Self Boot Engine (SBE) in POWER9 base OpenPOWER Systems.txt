Title: OpenPOWER Summit NA 2019: An Overview of the Self Boot Engine (SBE) in POWER9 base OpenPOWER Systems
Publication date: 2019-08-28
Playlist: OpenPOWER Summit NA 2019
Description: 
	Presented by Amit Tendolkar, IBM India Pvt. Ltd. 

This talk will provide an overview of the on-chip Self Boot Engine (SBE) hardware and firmware first shipped on POWER9 based systems. This talk will further give an understanding of how the SBE plays a key role in enabling several significant and futuristic architectural imperatives in OpenPOWER systems like hardware abstraction, secure boot, RAS and host offloads that enable key features. The talk will finally conclude with examples of system-level use-cases and flows that highlight the role and significance of the SBE as critical and futuristic architectural element in OpenPOWER systems, starting POWER9.
Captions: 
	00:00:00,030 --> 00:00:05,069
yeah so good afternoon everybody this is

00:00:02,159 --> 00:00:08,309
a I'm at I work with the power for my

00:00:05,069 --> 00:00:09,809
team in Bangalore and this is like going

00:00:08,309 --> 00:00:13,290
to be an overview of what the self boot

00:00:09,809 --> 00:00:15,059
engine does in power 9 kind of

00:00:13,290 --> 00:00:17,640
high-level overview of the hardware and

00:00:15,059 --> 00:00:19,590
the firmware architecture and what are

00:00:17,640 --> 00:00:24,570
the high level use cases kind of with

00:00:19,590 --> 00:00:26,480
supports in the system a little bit of

00:00:24,570 --> 00:00:28,830
history over here is like in power eight

00:00:26,480 --> 00:00:33,030
was the first generation of power chips

00:00:28,830 --> 00:00:36,750
that introduced the sell food engine it

00:00:33,030 --> 00:00:38,579
was not a standard microprocessor and I

00:00:36,750 --> 00:00:40,500
did something really less like it it

00:00:38,579 --> 00:00:43,020
basically just enabled host food and

00:00:40,500 --> 00:00:45,300
that was the that was all it did but

00:00:43,020 --> 00:00:47,280
starting power line I think there have

00:00:45,300 --> 00:00:49,710
been major enhancements and there's be

00:00:47,280 --> 00:00:53,750
and I think going forward in power 10 we

00:00:49,710 --> 00:00:55,680
will see more enhancements and SP 2 so I

00:00:53,750 --> 00:01:03,300
think I'll get started

00:00:55,680 --> 00:01:05,790
probably and so what is this B so it's

00:01:03,300 --> 00:01:08,700
basically a self boot engine initially

00:01:05,790 --> 00:01:12,720
before power ate the entire boot

00:01:08,700 --> 00:01:14,490
firmware to power up the chip and and

00:01:12,720 --> 00:01:15,990
get it get the hypervisor loaded was

00:01:14,490 --> 00:01:17,939
done on the self on the service

00:01:15,990 --> 00:01:19,890
processor which kind of sack off chip

00:01:17,939 --> 00:01:24,930
and which had to connect to the main

00:01:19,890 --> 00:01:28,799
ship via the FSI bus and going going as

00:01:24,930 --> 00:01:31,560
a baby step and the open power I can say

00:01:28,799 --> 00:01:34,590
strategy we wanted to get rid we wanted

00:01:31,560 --> 00:01:36,060
to abstract the BMC from nitty gritties

00:01:34,590 --> 00:01:39,060
of the hardware so that's when the cell

00:01:36,060 --> 00:01:41,189
would engine was first like I think

00:01:39,060 --> 00:01:44,180
pioneered and power it as a baby step

00:01:41,189 --> 00:01:48,600
and then power line really took off

00:01:44,180 --> 00:01:49,409
it's a PPE 42 based 32-bit

00:01:48,600 --> 00:01:51,990
microprocessor

00:01:49,409 --> 00:01:53,549
so what PB stands for is basically I

00:01:51,990 --> 00:01:55,259
have a glossary chart at the end of the

00:01:53,549 --> 00:01:57,840
deck which I won't go through but it's

00:01:55,259 --> 00:02:01,290
basically a power power is a light

00:01:57,840 --> 00:02:03,450
processing engine model 42 of the

00:02:01,290 --> 00:02:05,700
hardware so it's a 32-bit embedded

00:02:03,450 --> 00:02:07,770
processor and basically it's

00:02:05,700 --> 00:02:12,360
implementing an extended subset of the

00:02:07,770 --> 00:02:13,860
power is a version 2.7 0 7 here because

00:02:12,360 --> 00:02:17,250
it's an extension

00:02:13,860 --> 00:02:20,600
it's not directly compatible to the ISA

00:02:17,250 --> 00:02:23,670
and the compiler has slight extensions

00:02:20,600 --> 00:02:25,460
there so what it does beyond the normal

00:02:23,670 --> 00:02:27,870
is f of power is basically it does

00:02:25,460 --> 00:02:30,450
autonomic loads and stores of 64-bit

00:02:27,870 --> 00:02:34,680
data which were not supported by default

00:02:30,450 --> 00:02:39,360
and it has about 16 32 bit programmable

00:02:34,680 --> 00:02:43,080
GPS visibility GPRS and I think about 18

00:02:39,360 --> 00:02:45,360
32 bits SP ours there there is a version

00:02:43,080 --> 00:02:45,810
of this of the compiler out there on

00:02:45,360 --> 00:02:50,220
github

00:02:45,810 --> 00:02:53,670
it's basically GCC for dot 9.2 based one

00:02:50,220 --> 00:02:56,340
so you would see it if you google it so

00:02:53,670 --> 00:02:58,250
that's the core microprocessor that

00:02:56,340 --> 00:03:01,200
constitutes there's B but that's not all

00:02:58,250 --> 00:03:04,740
there is a dedicate dedicated 96

00:03:01,200 --> 00:03:07,590
kilobyte of SRAM which is the primary

00:03:04,740 --> 00:03:11,220
and the fastest way there is beacon

00:03:07,590 --> 00:03:13,770
execute instructions it has customized

00:03:11,220 --> 00:03:16,080
peripherals around it to do specific

00:03:13,770 --> 00:03:18,780
functions and in general we call them

00:03:16,080 --> 00:03:20,760
bolt ons the next chart shall go into

00:03:18,780 --> 00:03:23,130
details of what those bolt bolt ons are

00:03:20,760 --> 00:03:27,270
and the associate firmware that actually

00:03:23,130 --> 00:03:30,060
runs on the SBE hardware itself so it's

00:03:27,270 --> 00:03:31,680
a term that's interchangeably used in

00:03:30,060 --> 00:03:33,330
hardware and firmware like this whole

00:03:31,680 --> 00:03:34,560
block of hardware along with the

00:03:33,330 --> 00:03:36,870
firmware running is called the self boot

00:03:34,560 --> 00:03:39,120
engine where does it sit and how many

00:03:36,870 --> 00:03:41,160
instances we have per ship so every

00:03:39,120 --> 00:03:44,730
power line ship has one instance of the

00:03:41,160 --> 00:03:45,990
self boot engine so Nimbus and cumulus

00:03:44,730 --> 00:03:50,940
both of them support the self boot

00:03:45,990 --> 00:03:52,770
engine the recently announced latest

00:03:50,940 --> 00:03:54,270
variants of the power 9 ship as well as

00:03:52,770 --> 00:03:57,360
the power 10 ships will also continue to

00:03:54,270 --> 00:04:00,060
have the self boot engines power 10 will

00:03:57,360 --> 00:04:02,130
have more enhancements what does it do

00:04:00,060 --> 00:04:04,560
at a high level it basically does the

00:04:02,130 --> 00:04:07,620
base initialization of all the power

00:04:04,560 --> 00:04:10,740
line ships so this is what was done in

00:04:07,620 --> 00:04:12,510
power in as well but you can see the

00:04:10,740 --> 00:04:15,870
bullets that have come up after power it

00:04:12,510 --> 00:04:17,640
in power line so I think with the first

00:04:15,870 --> 00:04:18,930
two bullets like loading host boot also

00:04:17,640 --> 00:04:21,450
has something called self boot and that

00:04:18,930 --> 00:04:23,220
does that's only on the master chip the

00:04:21,450 --> 00:04:26,100
first two bullets have what more or less

00:04:23,220 --> 00:04:27,630
there's we did on a p8 box but on the p9

00:04:26,100 --> 00:04:30,510
box it actually abstracts

00:04:27,630 --> 00:04:31,920
BMC from low-level chip details so we've

00:04:30,510 --> 00:04:34,670
come up with the concept of something

00:04:31,920 --> 00:04:37,740
called chip operations

00:04:34,670 --> 00:04:40,680
nicknamed as chip ops and there are two

00:04:37,740 --> 00:04:43,350
primary interfaces that can actually

00:04:40,680 --> 00:04:47,360
talk to the SP one is called the FIFO

00:04:43,350 --> 00:04:49,980
base interface so if you if you look at

00:04:47,360 --> 00:04:52,710
the the legacy one the legacy hardware

00:04:49,980 --> 00:04:55,050
axis the BMC had to have all the

00:04:52,710 --> 00:04:57,660
integrate knowledge of the hardware here

00:04:55,050 --> 00:04:59,130
and it had to sense comps comm commands

00:04:57,660 --> 00:05:01,350
which are basically register reads and

00:04:59,130 --> 00:05:03,660
writes into the hardware over the FSM

00:05:01,350 --> 00:05:06,930
bus to do any meaningful Hardware

00:05:03,660 --> 00:05:09,720
initialization or operations so it

00:05:06,930 --> 00:05:11,150
clearly was not abstracting the BMC from

00:05:09,720 --> 00:05:14,910
the details of the power nine chip

00:05:11,150 --> 00:05:17,070
starting power nine we came up with

00:05:14,910 --> 00:05:19,920
something called a five-four interface

00:05:17,070 --> 00:05:22,140
here so the BMC actually sends a

00:05:19,920 --> 00:05:25,440
software protocol command over the FSI

00:05:22,140 --> 00:05:27,080
and internally the SB is aware of the

00:05:25,440 --> 00:05:29,790
power line architecture and handles

00:05:27,080 --> 00:05:32,150
logical logically which registers to go

00:05:29,790 --> 00:05:35,760
and what to do directly inside the chip

00:05:32,150 --> 00:05:38,160
so that's abstraction here if you see

00:05:35,760 --> 00:05:40,560
secure Hardware access it's not just

00:05:38,160 --> 00:05:42,960
like we can send any commands from the

00:05:40,560 --> 00:05:45,030
BMC and things will get done like you

00:05:42,960 --> 00:05:47,670
can access memory main store memory you

00:05:45,030 --> 00:05:51,830
can access some registers but the SB

00:05:47,670 --> 00:05:54,420
provides a software owned blacklist and

00:05:51,830 --> 00:05:56,610
white list of what registers can be

00:05:54,420 --> 00:06:00,090
accessed and what memory regions can be

00:05:56,610 --> 00:06:03,600
accessed by the BMC so it actually is an

00:06:00,090 --> 00:06:07,230
active I can say gate keeping agent for

00:06:03,600 --> 00:06:08,730
secure access of the hardware and the

00:06:07,230 --> 00:06:10,170
last one is the offload engine for the

00:06:08,730 --> 00:06:13,230
host software so there's also an

00:06:10,170 --> 00:06:15,030
interface that we provide here which is

00:06:13,230 --> 00:06:17,720
called the PSU or the pervasive service

00:06:15,030 --> 00:06:19,980
interface pervasive service unit and

00:06:17,720 --> 00:06:22,800
entities that are running on the main

00:06:19,980 --> 00:06:25,410
processor like the host boot or opal or

00:06:22,800 --> 00:06:27,680
Linux can actually send these two pop

00:06:25,410 --> 00:06:30,270
commands over the PSU to the SPE and

00:06:27,680 --> 00:06:33,270
that kind of enables some more use cases

00:06:30,270 --> 00:06:37,650
in the system will come to the details

00:06:33,270 --> 00:06:40,200
of these use cases later so I think that

00:06:37,650 --> 00:06:41,279
was an introduction of the SB and wanted

00:06:40,200 --> 00:06:43,499
to what scope it

00:06:41,279 --> 00:06:46,649
and power 9 I'll go to the details in

00:06:43,499 --> 00:06:48,749
the next chart so this is kind of a

00:06:46,649 --> 00:06:50,399
hardware block diagram we don't want to

00:06:48,749 --> 00:06:53,189
get into details it's an overloaded

00:06:50,399 --> 00:06:57,449
chart here but what I wanted to say is

00:06:53,189 --> 00:06:59,939
the SB has since it's a secure it's not

00:06:57,449 --> 00:07:02,369
just a secure access mechanism it's also

00:06:59,939 --> 00:07:03,989
the core root of trust for secure boot

00:07:02,369 --> 00:07:07,889
and trusted boot and powerline systems

00:07:03,989 --> 00:07:10,349
so if you see the OT prom OD prom chips

00:07:07,889 --> 00:07:14,419
right here these are fuses which are one

00:07:10,349 --> 00:07:16,860
sorry the SE problem these are basically

00:07:14,419 --> 00:07:18,809
one-time programmable chips and once you

00:07:16,860 --> 00:07:20,879
blow those fuses you nobody can go and

00:07:18,809 --> 00:07:24,449
change that code anymore so that's

00:07:20,879 --> 00:07:26,159
that's where an OS b will reset to when

00:07:24,449 --> 00:07:29,039
it started first so it starts executing

00:07:26,159 --> 00:07:31,229
from the hood EEPROM control gets

00:07:29,039 --> 00:07:33,029
shifted to the C prom and then it

00:07:31,229 --> 00:07:33,389
actually starts executing from something

00:07:33,029 --> 00:07:35,669
called

00:07:33,389 --> 00:07:37,409
its SRAM so the previous chart had

00:07:35,669 --> 00:07:40,589
something called the 96 kilobytes of

00:07:37,409 --> 00:07:43,259
SRAM which is a dedicated a memory given

00:07:40,589 --> 00:07:45,179
for the self boot engine so it's boot

00:07:43,259 --> 00:07:46,979
processes 3 stage and we have a chat

00:07:45,179 --> 00:07:51,719
which kind of delves into the into the

00:07:46,979 --> 00:07:55,409
details of that this is the PPE 42 main

00:07:51,719 --> 00:07:56,849
chip itself which I talked about and you

00:07:55,409 --> 00:07:59,129
can see these boxes there are multiple

00:07:56,849 --> 00:08:02,119
boxes around these puppies around the

00:07:59,129 --> 00:08:06,360
Pepi which up the boltons so that's like

00:08:02,119 --> 00:08:09,029
specific targeted hardware logic which

00:08:06,360 --> 00:08:11,369
kind of abstracts the Pepi from what it

00:08:09,029 --> 00:08:13,229
needs to do for example it can execute

00:08:11,369 --> 00:08:14,909
instructions directly from the OT prom

00:08:13,229 --> 00:08:18,209
it can execute instructions from the C

00:08:14,909 --> 00:08:20,459
prom as well as from the from the RAM

00:08:18,209 --> 00:08:22,199
itself and all this is like a memory

00:08:20,459 --> 00:08:23,429
mapped or executable because of

00:08:22,199 --> 00:08:29,339
something called the memory bolt on

00:08:23,429 --> 00:08:30,689
which you can see right here I guess so

00:08:29,339 --> 00:08:32,189
there's a fast track to see one and

00:08:30,689 --> 00:08:33,389
there's a memory interface bolt Anya

00:08:32,189 --> 00:08:35,579
this is the first ID to see one which

00:08:33,389 --> 00:08:37,469
goes for C prom as well as what he

00:08:35,579 --> 00:08:39,539
prompts similarly you have interrupt

00:08:37,469 --> 00:08:41,879
Bolton's to various interrupts in

00:08:39,539 --> 00:08:44,939
hardware that the SB needs to cater to

00:08:41,879 --> 00:08:47,670
are mapped Y at the pervasive logic into

00:08:44,939 --> 00:08:51,269
an interface Bolton and so on and so

00:08:47,670 --> 00:08:54,810
forth so another key concept here is the

00:08:51,269 --> 00:08:57,029
SB itself

00:08:54,810 --> 00:09:00,180
is a trusted protected master in the

00:08:57,029 --> 00:09:03,120
purpose in the pub architecture so any

00:09:00,180 --> 00:09:05,730
any scores or a hardware access done by

00:09:03,120 --> 00:09:10,590
the SP is good doesn't matter whether

00:09:05,730 --> 00:09:12,570
the chip is in secure mode or not in

00:09:10,590 --> 00:09:14,820
legacy all the hardware requests would

00:09:12,570 --> 00:09:17,400
come over the FSA bus and they would go

00:09:14,820 --> 00:09:19,380
either to the FSIA scarm engine or the

00:09:17,400 --> 00:09:21,240
scan engines and these engines will be

00:09:19,380 --> 00:09:24,450
blocked or when the chip is in secure

00:09:21,240 --> 00:09:26,550
mode so external entities like the BMC

00:09:24,450 --> 00:09:28,710
can no longer jump on the FSI bus and do

00:09:26,550 --> 00:09:30,510
anything from these engines so they have

00:09:28,710 --> 00:09:32,790
to go into this new interface called the

00:09:30,510 --> 00:09:34,290
SB FIFO and this is one of the external

00:09:32,790 --> 00:09:36,450
interfaces I was talking about

00:09:34,290 --> 00:09:39,150
similarly the host has interfaces over

00:09:36,450 --> 00:09:42,240
the PSU which is a set of eight

00:09:39,150 --> 00:09:45,600
registers we'll go into the details of

00:09:42,240 --> 00:09:47,339
this protocol later and this chart so

00:09:45,600 --> 00:09:49,589
that's a high-level overview of the s

00:09:47,339 --> 00:09:54,029
B's hardware capabilities and what it's

00:09:49,589 --> 00:09:58,680
build on the next chart will kind of dig

00:09:54,029 --> 00:10:00,150
deeper into the FIFO itself so to give

00:09:58,680 --> 00:10:02,460
you a context of that we are talking

00:10:00,150 --> 00:10:04,580
about this new block that came which

00:10:02,460 --> 00:10:07,050
sits in the c-fam domain of the chip

00:10:04,580 --> 00:10:09,660
this domain is up and running even in

00:10:07,050 --> 00:10:13,010
standby voltages the rest of the chip

00:10:09,660 --> 00:10:16,470
gets powered on later in the IPL steps

00:10:13,010 --> 00:10:19,620
so this is like a blow up any access

00:10:16,470 --> 00:10:21,570
from the BMC comes from outside and goes

00:10:19,620 --> 00:10:24,510
over the local bus and the local bus

00:10:21,570 --> 00:10:27,600
caters to multiple c5 engines so c-fam

00:10:24,510 --> 00:10:29,190
stands for common flu access macros they

00:10:27,600 --> 00:10:31,260
do dedicated functions of actually

00:10:29,190 --> 00:10:33,360
sending requests from the external

00:10:31,260 --> 00:10:35,280
entities to the specific elements and

00:10:33,360 --> 00:10:36,540
the pervasive side of the chip so you

00:10:35,280 --> 00:10:39,350
can see there's a new one here called

00:10:36,540 --> 00:10:42,120
the SB 5 4 which came in to power 9 and

00:10:39,350 --> 00:10:45,750
we have specific drivers on the BMC side

00:10:42,120 --> 00:10:47,520
which target this c-fam device and using

00:10:45,750 --> 00:10:52,140
the protocol defined they actually send

00:10:47,520 --> 00:10:53,880
up send commands onto the PIP bus this

00:10:52,140 --> 00:10:55,950
is a blow-up of the SB pfeiffer device

00:10:53,880 --> 00:10:58,170
itself we have one upstream five four

00:10:55,950 --> 00:10:59,520
which is eight entries on a dime on a

00:10:58,170 --> 00:11:01,410
downstream five four which is another

00:10:59,520 --> 00:11:04,080
eight entries so upstream is any

00:11:01,410 --> 00:11:05,520
commands going from from the FSI local

00:11:04,080 --> 00:11:08,360
bus site from the service processor

00:11:05,520 --> 00:11:11,120
inside the chip go and wire the

00:11:08,360 --> 00:11:12,950
steam phi4 and the hardware maintains

00:11:11,120 --> 00:11:15,709
its a circularbuffer a hardware

00:11:12,950 --> 00:11:17,779
maintains a rollovers and any response

00:11:15,709 --> 00:11:20,089
is coming back from inside the chip from

00:11:17,779 --> 00:11:22,430
the SB come back over the PIP bus into

00:11:20,089 --> 00:11:25,100
the into the downstream FIFO and they

00:11:22,430 --> 00:11:26,810
get sent back over the local bus back to

00:11:25,100 --> 00:11:29,600
the service processor so this is the

00:11:26,810 --> 00:11:31,880
intrinsic hardware mechanism the moment

00:11:29,600 --> 00:11:33,200
there is an entry here the SB would get

00:11:31,880 --> 00:11:35,149
interrupted saying hey you have a new

00:11:33,200 --> 00:11:37,160
data in your in your FIFO and go start

00:11:35,149 --> 00:11:39,230
processing it and there's another

00:11:37,160 --> 00:11:41,450
interrupt provisioned in hardware which

00:11:39,230 --> 00:11:43,850
says like the command can actually be

00:11:41,450 --> 00:11:45,980
more than eight entries 832 pedantry so

00:11:43,850 --> 00:11:48,500
though the other provisioning is to say

00:11:45,980 --> 00:11:50,630
I am done with my transfer like let's

00:11:48,500 --> 00:11:52,610
say you have multiples of eight eight

00:11:50,630 --> 00:11:54,380
entries to be transferred so once your

00:11:52,610 --> 00:11:56,690
logical command is done you would get an

00:11:54,380 --> 00:11:59,089
end of transfer bit set and that sends

00:11:56,690 --> 00:12:00,560
another interrupt to the SB and it

00:11:59,089 --> 00:12:02,630
logically starts interrupting the

00:12:00,560 --> 00:12:05,320
commands it got and a similar

00:12:02,630 --> 00:12:09,380
provisioning is on the downstream side

00:12:05,320 --> 00:12:10,910
so based on this hardware mechanism

00:12:09,380 --> 00:12:13,209
there is a software protocol that has

00:12:10,910 --> 00:12:17,410
been defined which uses this FIFO and

00:12:13,209 --> 00:12:21,740
the command format is very generic like

00:12:17,410 --> 00:12:23,660
we basically have the command class and

00:12:21,740 --> 00:12:25,190
the command itself and the length of

00:12:23,660 --> 00:12:28,250
this command that's expected to come

00:12:25,190 --> 00:12:29,899
down on the FIFO and the data could be

00:12:28,250 --> 00:12:32,660
formatted based on what commands you've

00:12:29,899 --> 00:12:34,550
been defining in the interface spec the

00:12:32,660 --> 00:12:36,290
moment all the data is sent over the

00:12:34,550 --> 00:12:38,209
command FIFO you would get an end of

00:12:36,290 --> 00:12:40,160
transfer and SB starts interpreting this

00:12:38,209 --> 00:12:41,839
command and the parameter is coming and

00:12:40,160 --> 00:12:46,579
actually does the execution inside the

00:12:41,839 --> 00:12:49,699
chip similarly on the response side we

00:12:46,579 --> 00:12:52,250
have basically the response the SB is

00:12:49,699 --> 00:12:55,910
the main challenge on the SB is it's got

00:12:52,250 --> 00:12:57,290
really tiny memory it was 96 km and it

00:12:55,910 --> 00:13:00,760
had to handle a lot of functions like

00:12:57,290 --> 00:13:03,440
suppose it's streaming out like 1k

00:13:00,760 --> 00:13:05,390
memory main store memory so that won't

00:13:03,440 --> 00:13:08,029
fit in these eight bytes in this 8

00:13:05,390 --> 00:13:10,100
entries in the response format so we

00:13:08,029 --> 00:13:12,500
start sending the response and if any

00:13:10,100 --> 00:13:14,240
hardware function fails that's when they

00:13:12,500 --> 00:13:16,579
actually go in and plug in the status of

00:13:14,240 --> 00:13:18,860
this command so it could also be success

00:13:16,579 --> 00:13:21,580
or it could be failure and then if it's

00:13:18,860 --> 00:13:24,250
a failure they end up appending ffd C

00:13:21,580 --> 00:13:27,070
packages ffd see is nothing but the

00:13:24,250 --> 00:13:28,570
first failure data capture which kind of

00:13:27,070 --> 00:13:31,420
gives debug information of what's going

00:13:28,570 --> 00:13:33,220
wrong inside the chip and the last entry

00:13:31,420 --> 00:13:37,180
in the in the response always says

00:13:33,220 --> 00:13:39,790
what's my default offset to my status so

00:13:37,180 --> 00:13:42,190
this is kind of a flexible response

00:13:39,790 --> 00:13:46,840
you never know the length until the

00:13:42,190 --> 00:13:48,130
command is completed so and each FF DC

00:13:46,840 --> 00:13:49,600
package itself would blow up into

00:13:48,130 --> 00:13:51,430
something like this so you have unique

00:13:49,600 --> 00:13:52,960
codes coming back you have a primary

00:13:51,430 --> 00:13:56,050
response code and secondary response

00:13:52,960 --> 00:13:59,020
code and specific data so this is like a

00:13:56,050 --> 00:14:00,340
template protocol and based on the

00:13:59,020 --> 00:14:02,860
commands to be supported it gets

00:14:00,340 --> 00:14:05,140
architected so I think there is a spec

00:14:02,860 --> 00:14:06,850
of FIFO spec as we said by perspect

00:14:05,140 --> 00:14:09,220
which kind of details each and every

00:14:06,850 --> 00:14:11,740
command supported and that's going to be

00:14:09,220 --> 00:14:16,810
available in the open source of pretty

00:14:11,740 --> 00:14:19,030
shortly so what are the commands coming

00:14:16,810 --> 00:14:21,430
in on the FIFO sight from the from the

00:14:19,030 --> 00:14:23,980
BMC and before the power bus is

00:14:21,430 --> 00:14:26,320
initialized even host boot ends up using

00:14:23,980 --> 00:14:29,830
some of these so some of them are just

00:14:26,320 --> 00:14:31,270
boot an initialization command the whole

00:14:29,830 --> 00:14:33,520
idea flow could be broken down into

00:14:31,270 --> 00:14:36,280
steps and you could actually ask this V

00:14:33,520 --> 00:14:38,230
to go a step at a time

00:14:36,280 --> 00:14:40,540
if you see the ones here the general

00:14:38,230 --> 00:14:42,940
debug commands so so if something goes

00:14:40,540 --> 00:14:45,780
bad you can actually pull out the the FF

00:14:42,940 --> 00:14:48,010
DC from this be using a specific chip op

00:14:45,780 --> 00:14:49,540
to know what commands this has me

00:14:48,010 --> 00:14:51,550
supports especially when you start

00:14:49,540 --> 00:14:53,440
upgrading the firmware and the field and

00:14:51,550 --> 00:14:54,880
start adding new functions there's a

00:14:53,440 --> 00:14:56,170
capabilities command which gives you a

00:14:54,880 --> 00:14:58,660
bit field of what are the supported

00:14:56,170 --> 00:15:00,550
operations thread control is basically

00:14:58,660 --> 00:15:03,760
like you can start instructions stop

00:15:00,550 --> 00:15:05,200
instructions reset thread or you can

00:15:03,760 --> 00:15:07,630
step instructions in the processor

00:15:05,200 --> 00:15:12,040
typically it's useful for debug

00:15:07,630 --> 00:15:14,020
facilities of the host like P gdb and

00:15:12,040 --> 00:15:15,370
stuff like that so you have debuggers

00:15:14,020 --> 00:15:17,860
which want to actually give a host boot

00:15:15,370 --> 00:15:19,900
or p hype can make use of this in the

00:15:17,860 --> 00:15:22,050
lab there's a host pass-through

00:15:19,900 --> 00:15:24,250
mechanism command which actually helps

00:15:22,050 --> 00:15:27,090
health monitoring and stuff in the

00:15:24,250 --> 00:15:30,580
manufacturing lab to actually facilitate

00:15:27,090 --> 00:15:33,190
communication between the BMC and the

00:15:30,580 --> 00:15:34,750
OCC indirectly but it involves many

00:15:33,190 --> 00:15:36,950
other subsystems and the form

00:15:34,750 --> 00:15:38,779
then there's a register access to

00:15:36,950 --> 00:15:40,700
actually dump out the architected

00:15:38,779 --> 00:15:43,070
registers inside inside the power 9 ship

00:15:40,700 --> 00:15:45,740
so if something goes bad you have a

00:15:43,070 --> 00:15:48,260
check stop or you have a TI kind of

00:15:45,740 --> 00:15:50,870
condition in the system you can use this

00:15:48,260 --> 00:15:52,550
chip up and pull out information to

00:15:50,870 --> 00:15:55,850
understand the state of what's going

00:15:52,550 --> 00:15:59,029
wrong and again is used in debuggers in

00:15:55,850 --> 00:16:02,180
general secure hardware access so the

00:15:59,029 --> 00:16:04,070
basic access is comm registers serial

00:16:02,180 --> 00:16:05,930
communication registers which are 64-bit

00:16:04,070 --> 00:16:08,149
address registers and data registers and

00:16:05,930 --> 00:16:10,550
the Rings which are used when there is

00:16:08,149 --> 00:16:13,070
no clocks in the system the very initial

00:16:10,550 --> 00:16:16,430
initial steps of the system so both of

00:16:13,070 --> 00:16:18,529
these are basic access commands but you

00:16:16,430 --> 00:16:21,529
can't simply go and access any register

00:16:18,529 --> 00:16:24,260
on the chip so the security team the

00:16:21,529 --> 00:16:26,360
security architects actually defined

00:16:24,260 --> 00:16:28,640
what registers can be read and what

00:16:26,360 --> 00:16:30,170
registers can't be read and the read

00:16:28,640 --> 00:16:32,240
access versus write access for these

00:16:30,170 --> 00:16:34,790
registers and as we does a

00:16:32,240 --> 00:16:37,880
software-based gatekeeping of this

00:16:34,790 --> 00:16:41,000
blacklist of registers here same holds

00:16:37,880 --> 00:16:42,620
good for memory access by default no

00:16:41,000 --> 00:16:45,680
memory can be read or written from the

00:16:42,620 --> 00:16:47,660
main store but by design to enable the

00:16:45,680 --> 00:16:49,910
boot flow or to enable mechanisms like

00:16:47,660 --> 00:16:52,579
host boot tracing we want to open up the

00:16:49,910 --> 00:16:54,620
memory windows for a fixed time in the

00:16:52,579 --> 00:16:56,690
in the boot flow and then close them and

00:16:54,620 --> 00:16:58,850
again the opening could be done for read

00:16:56,690 --> 00:17:00,529
access write access so who's good

00:16:58,850 --> 00:17:03,320
controls what chunks of the memory

00:17:00,529 --> 00:17:07,069
actually get opened for what what pieces

00:17:03,320 --> 00:17:08,660
of the boot flow and that's where SB is

00:17:07,069 --> 00:17:11,209
again doing the plumbing of maintaining

00:17:08,660 --> 00:17:19,480
and making sure no random memory can be

00:17:11,209 --> 00:17:19,480
accessed from the FSA sorry

00:17:20,160 --> 00:17:25,839
so there's a hardware facility there's

00:17:23,800 --> 00:17:28,690
something called the secure access bit

00:17:25,839 --> 00:17:35,440
by default if the security there are

00:17:28,690 --> 00:17:37,510
fuses on the in the hardware no no it's

00:17:35,440 --> 00:17:41,020
there's a separate pervasive bit in the

00:17:37,510 --> 00:17:43,810
SP complex there's a complete security

00:17:41,020 --> 00:17:46,300
switch OTP kind of chip land on chip in

00:17:43,810 --> 00:17:51,190
the pervasive hardware architecture and

00:17:46,300 --> 00:17:53,470
it actually samples this fuse on a power

00:17:51,190 --> 00:17:55,540
on and based on whether is blown or not

00:17:53,470 --> 00:17:57,880
it says that my chip is in a secure mode

00:17:55,540 --> 00:17:59,980
or it's not in a secure mode and if it

00:17:57,880 --> 00:18:01,960
is in a secure mode all this active

00:17:59,980 --> 00:18:05,110
gatekeeping would happen and all the

00:18:01,960 --> 00:18:07,060
hardware paths like I showed the FSI

00:18:05,110 --> 00:18:09,460
SCORM accesses and the scan accesses

00:18:07,060 --> 00:18:11,800
they get blocked automatically and only

00:18:09,460 --> 00:18:20,410
the FIFO is open and SP does active

00:18:11,800 --> 00:18:23,080
filtering of the commands that come yes

00:18:20,410 --> 00:18:25,120
by default all systems would be like in

00:18:23,080 --> 00:18:27,310
the lab we keep some of them open for

00:18:25,120 --> 00:18:35,760
debug but I think manufacturing

00:18:27,310 --> 00:18:35,760
everything is always secure yes yes

00:18:37,290 --> 00:18:39,320
I

00:18:52,059 --> 00:18:55,210
that's right

00:18:58,130 --> 00:19:03,420
okay so I'm switching to the other side

00:19:01,440 --> 00:19:05,010
other interface now because we have

00:19:03,420 --> 00:19:06,900
really short time so this is the

00:19:05,010 --> 00:19:09,299
interface which comes from the host down

00:19:06,900 --> 00:19:12,740
to the SP and used for offloading

00:19:09,299 --> 00:19:15,960
commands to the SB so in the pervasive

00:19:12,740 --> 00:19:18,570
service unit we have there's a provision

00:19:15,960 --> 00:19:20,520
for eight registers four of them have

00:19:18,570 --> 00:19:23,340
been used for commands coming from the

00:19:20,520 --> 00:19:25,530
host down to the SP and four of them are

00:19:23,340 --> 00:19:28,260
used for the responses going from the SB

00:19:25,530 --> 00:19:29,940
back to the host so the the typical

00:19:28,260 --> 00:19:34,679
sequences the host writes its command

00:19:29,940 --> 00:19:35,940
and these registers and once it's done

00:19:34,679 --> 00:19:37,590
writing the command it will send

00:19:35,940 --> 00:19:39,390
adorable register which interrupts the

00:19:37,590 --> 00:19:40,950
self boot engine and the said boot

00:19:39,390 --> 00:19:43,590
engine goes and starts interpreting this

00:19:40,950 --> 00:19:45,870
command and based on what it needs to do

00:19:43,590 --> 00:19:48,059
it executes stuff and writes back the

00:19:45,870 --> 00:19:49,590
response here and then again notifies

00:19:48,059 --> 00:19:54,240
back the host wire the host or bill

00:19:49,590 --> 00:19:55,410
which goes to the psi host bridge which

00:19:54,240 --> 00:19:57,360
kind of interrupts the host saying I

00:19:55,410 --> 00:19:59,280
have a sponsor pending now the obvious

00:19:57,360 --> 00:20:03,860
question is if my commands our responses

00:19:59,280 --> 00:20:06,570
are greater than these for 64-bit

00:20:03,860 --> 00:20:08,850
registers so we actually have a memory

00:20:06,570 --> 00:20:11,340
memory mechanism so in case the command

00:20:08,850 --> 00:20:13,110
or the response is going to be big one

00:20:11,340 --> 00:20:14,580
of these fields actually holds the

00:20:13,110 --> 00:20:16,590
address of where the rest of the command

00:20:14,580 --> 00:20:18,510
would would reside or the rest of the

00:20:16,590 --> 00:20:20,400
response would decide and this beam

00:20:18,510 --> 00:20:22,470
actually will so the host writes the

00:20:20,400 --> 00:20:24,120
rest of the command there write the

00:20:22,470 --> 00:20:27,780
command header ER and sends an interrupt

00:20:24,120 --> 00:20:31,020
SB reads the affluent command from that

00:20:27,780 --> 00:20:33,090
piece in memory so I think that this one

00:20:31,020 --> 00:20:34,650
is a pretty simple protocol I won't go

00:20:33,090 --> 00:20:38,210
through the through the actual steps

00:20:34,650 --> 00:20:42,090
right now and then we have a similar

00:20:38,210 --> 00:20:44,790
software protocol over this over the PSU

00:20:42,090 --> 00:20:46,730
mailbox registers so we have a command

00:20:44,790 --> 00:20:48,929
command class just like the FIFO and

00:20:46,730 --> 00:20:51,900
this is a general template of what the

00:20:48,929 --> 00:20:53,280
command can contain and a response with

00:20:51,900 --> 00:20:56,490
the same thing we have a sequence ID

00:20:53,280 --> 00:20:58,169
which needs to match and there's a FF DC

00:20:56,490 --> 00:21:01,049
package that was defined in the FIFO

00:20:58,169 --> 00:21:03,630
side has kept exactly the same on the on

00:21:01,049 --> 00:21:05,760
the host side so that it assists debug

00:21:03,630 --> 00:21:08,890
and it's common code across the host and

00:21:05,760 --> 00:21:12,110
the PMC

00:21:08,890 --> 00:21:14,990
so what commands are supported from the

00:21:12,110 --> 00:21:18,080
host to the SB side we have something

00:21:14,990 --> 00:21:20,330
called a Deadman control loop so I think

00:21:18,080 --> 00:21:21,890
the net in subsequence charts I'm going

00:21:20,330 --> 00:21:24,230
to be talking about the boot flow for

00:21:21,890 --> 00:21:27,110
the power nine ship and at one point on

00:21:24,230 --> 00:21:29,000
the chip the hope the host actually goes

00:21:27,110 --> 00:21:31,460
down and it needs to reboot all the

00:21:29,000 --> 00:21:34,190
codes in the system with runtime

00:21:31,460 --> 00:21:35,840
configuration of the hardware and to

00:21:34,190 --> 00:21:38,300
assist that we have the SP which is

00:21:35,840 --> 00:21:41,450
coming in and that's called the Deadman

00:21:38,300 --> 00:21:43,220
loop I step 16 we need to initialize

00:21:41,450 --> 00:21:46,760
host bootys to initialize some of the

00:21:43,220 --> 00:21:48,830
chip chip rings we need when host boot

00:21:46,760 --> 00:21:51,050
wants to go and update the SBI magic

00:21:48,830 --> 00:21:54,260
needs to quiet there's B so that the SB

00:21:51,050 --> 00:21:56,930
itself doesn't go and read the C prom so

00:21:54,260 --> 00:22:01,070
these are some of the initial IPL kind

00:21:56,930 --> 00:22:03,590
of commands here secure access so I was

00:22:01,070 --> 00:22:06,020
talking earlier that not all memory is

00:22:03,590 --> 00:22:08,990
readable by the service processor so

00:22:06,020 --> 00:22:11,510
host boot selectively sets and resets

00:22:08,990 --> 00:22:14,810
these windows of memory using these chip

00:22:11,510 --> 00:22:15,170
ops from the host if you look at this

00:22:14,810 --> 00:22:17,330
one

00:22:15,170 --> 00:22:20,210
this is basically if there's bad failure

00:22:17,330 --> 00:22:22,460
on the SP the FF DC would be written at

00:22:20,210 --> 00:22:23,740
a known place and host the host code

00:22:22,460 --> 00:22:25,730
could go and read it up from their

00:22:23,740 --> 00:22:27,950
capabilities and everything else is the

00:22:25,730 --> 00:22:30,290
same this is a new thing which was asked

00:22:27,950 --> 00:22:33,140
by Linux team so they wanted to offload

00:22:30,290 --> 00:22:35,330
some specific timers which are above a

00:22:33,140 --> 00:22:38,930
certain granularity so we've given them

00:22:35,330 --> 00:22:41,630
a time mature pop so Linux can

00:22:38,930 --> 00:22:44,120
potentially offload some of the timers

00:22:41,630 --> 00:22:48,020
to the SB it's up and running but I

00:22:44,120 --> 00:22:50,300
don't think Linux is using it as yet the

00:22:48,020 --> 00:22:51,850
last one is the memory preserving IPL so

00:22:50,300 --> 00:22:55,730
I think in one of the earlier

00:22:51,850 --> 00:22:58,010
discussions yesterday we were talking

00:22:55,730 --> 00:22:59,870
about the FA dump though if we assisted

00:22:58,010 --> 00:23:03,980
the firmware assisted dump for Linux

00:22:59,870 --> 00:23:05,990
so that is kind of completely managed by

00:23:03,980 --> 00:23:07,640
the self boot engine at runtime so if

00:23:05,990 --> 00:23:10,370
there's a terminated or the next

00:23:07,640 --> 00:23:13,340
goes down it can choose to do an MPI PL

00:23:10,370 --> 00:23:17,270
and as part of booting back from from

00:23:13,340 --> 00:23:18,950
this memory preserving IPL the SB

00:23:17,270 --> 00:23:21,799
actually caches the architected states

00:23:18,950 --> 00:23:24,320
of the registers of the core and threads

00:23:21,799 --> 00:23:26,299
and pushes it back when the system

00:23:24,320 --> 00:23:30,850
reaiiy peels so the Knux can actually

00:23:26,299 --> 00:23:33,259
get a state of things when it failed and

00:23:30,850 --> 00:23:35,929
and on larger systems where you have

00:23:33,259 --> 00:23:38,269
like two sockets for sockets SB needs to

00:23:35,929 --> 00:23:40,249
understand basically how many chips are

00:23:38,269 --> 00:23:44,330
there on them on the machine because

00:23:40,249 --> 00:23:46,279
when the system is going down we want to

00:23:44,330 --> 00:23:47,210
quash all the units in the hardware and

00:23:46,279 --> 00:23:50,090
when we do that

00:23:47,210 --> 00:23:51,440
each SB kind of monitors other SB to

00:23:50,090 --> 00:23:52,909
make sure that everybody is down and

00:23:51,440 --> 00:23:55,850
that's when the reai peel sequence

00:23:52,909 --> 00:23:57,679
happens so whose boot sets this

00:23:55,850 --> 00:24:01,009
configuration why are this this

00:23:57,679 --> 00:24:02,299
interface I think that's that's more or

00:24:01,009 --> 00:24:06,109
less I think we are in discussions with

00:24:02,299 --> 00:24:08,869
the Linux team on how to enhance and as

00:24:06,109 --> 00:24:11,179
this so this is like going to be a quick

00:24:08,869 --> 00:24:13,730
run of the firmware architecture on the

00:24:11,179 --> 00:24:16,639
cell boot engine so that's the SB

00:24:13,730 --> 00:24:17,960
hardware which I kind of touched upon we

00:24:16,639 --> 00:24:19,730
have certain functions which are

00:24:17,960 --> 00:24:22,820
specific based on the Pepe 42

00:24:19,730 --> 00:24:24,919
architecture so we have like a targeting

00:24:22,820 --> 00:24:28,220
mechanism where the different hardware

00:24:24,919 --> 00:24:30,559
triplets and their associated properties

00:24:28,220 --> 00:24:33,649
are captured your like a device mini

00:24:30,559 --> 00:24:36,950
device c4 the SP we have a SCORM service

00:24:33,649 --> 00:24:38,179
which is just like a load of virtual

00:24:36,950 --> 00:24:39,769
double-word and store virtual

00:24:38,179 --> 00:24:42,409
double-double what kind of instructions

00:24:39,769 --> 00:24:45,440
added in this architecture we have

00:24:42,409 --> 00:24:46,940
random scan utility scan code so this is

00:24:45,440 --> 00:24:48,440
like your low-level Hardware access

00:24:46,940 --> 00:24:51,769
based on what you're trying to access in

00:24:48,440 --> 00:24:53,690
the chip typically since the SB does

00:24:51,769 --> 00:24:57,259
Hardware initialization during the boot

00:24:53,690 --> 00:24:59,809
flow we get a lot of procedures written

00:24:57,259 --> 00:25:03,019
by the hardware team which get compiled

00:24:59,809 --> 00:25:05,919
into the SB stack and all of these are

00:25:03,019 --> 00:25:07,820
basically they need to follow a certain

00:25:05,919 --> 00:25:10,639
interface format which is called the

00:25:07,820 --> 00:25:12,169
firmware the framework API so the same

00:25:10,639 --> 00:25:14,720
procedure could actually be recompiled

00:25:12,169 --> 00:25:16,999
on to host boot or on to the OCC or any

00:25:14,720 --> 00:25:19,249
other form by components that implement

00:25:16,999 --> 00:25:22,850
this layer so these procedures actually

00:25:19,249 --> 00:25:25,309
end up using the standard layer and the

00:25:22,850 --> 00:25:26,989
platform code implements this layer we

00:25:25,309 --> 00:25:30,379
have a small kernel which is kind of

00:25:26,989 --> 00:25:32,090
inherited from the OCC 4:05 the OCC used

00:25:30,379 --> 00:25:34,130
the SSX kernel but this is a much more

00:25:32,090 --> 00:25:35,929
stripped-down version of that

00:25:34,130 --> 00:25:39,340
it gives very primitive facilities like

00:25:35,929 --> 00:25:42,049
threads semaphores critical sections

00:25:39,340 --> 00:25:44,870
timers and stuff like that so it also

00:25:42,049 --> 00:25:48,559
gives the basic tracing support for the

00:25:44,870 --> 00:25:51,650
system we have bootloader curse so when

00:25:48,559 --> 00:25:54,020
when the SP is asked to boot up it has

00:25:51,650 --> 00:25:56,410
two levels of boot booting I will touch

00:25:54,020 --> 00:25:59,210
upon that and one of the recent charts

00:25:56,410 --> 00:26:00,830
and the control loop is basically the

00:25:59,210 --> 00:26:02,450
business logic of understanding the

00:26:00,830 --> 00:26:04,780
protocols from the external interfaces

00:26:02,450 --> 00:26:06,799
and how you're going to actually

00:26:04,780 --> 00:26:09,110
interpret the command and the different

00:26:06,799 --> 00:26:12,559
services required at one time and I peel

00:26:09,110 --> 00:26:15,860
time so that's a high level of the foam

00:26:12,559 --> 00:26:18,789
base track the boot sequence is pretty

00:26:15,860 --> 00:26:21,740
simple we have to start booting from the

00:26:18,789 --> 00:26:23,750
from the ot prompt code which which is

00:26:21,740 --> 00:26:25,490
once it's once the fuses are born nobody

00:26:23,750 --> 00:26:28,820
can tamper this code this is the core

00:26:25,490 --> 00:26:30,710
root of trust if the system is in is in

00:26:28,820 --> 00:26:32,870
secure mode as I said earlier the serum

00:26:30,710 --> 00:26:35,840
also cannot be meddled with by an

00:26:32,870 --> 00:26:37,490
external entity somewhere during the

00:26:35,840 --> 00:26:40,130
boot flow host boot can actually go and

00:26:37,490 --> 00:26:42,140
choose to update the C problem in case

00:26:40,130 --> 00:26:45,200
the SB has a new firmware coming in the

00:26:42,140 --> 00:26:47,440
pic in the pinna or images you can see

00:26:45,200 --> 00:26:50,929
that C prom is really tiny is less than

00:26:47,440 --> 00:26:53,600
1k C prom is just 256 and then we have

00:26:50,929 --> 00:26:55,640
error ECC's so that reduces this

00:26:53,600 --> 00:27:00,080
capability even more and the SRAM is

00:26:55,640 --> 00:27:02,240
just 96 so the moment we reset the SB it

00:27:00,080 --> 00:27:04,220
lands up in the OT prom and that's where

00:27:02,240 --> 00:27:06,650
it actually sets up the ITC access to

00:27:04,220 --> 00:27:08,240
the C prom devices and starts booting

00:27:06,650 --> 00:27:10,190
from there it makes sure the magic

00:27:08,240 --> 00:27:12,620
numbers and the images are good and then

00:27:10,190 --> 00:27:14,150
branches to the l1 loader which is in

00:27:12,620 --> 00:27:16,730
the C prom so see prom is made up of

00:27:14,150 --> 00:27:19,880
different sections it's not exactly elf

00:27:16,730 --> 00:27:22,370
but it's it's a native IBM format called

00:27:19,880 --> 00:27:24,470
ex IP and likely to change in the future

00:27:22,370 --> 00:27:25,909
so we have the loader sections it

00:27:24,470 --> 00:27:28,580
branches here and the element loader

00:27:25,909 --> 00:27:31,490
takes over it repairs any hardware

00:27:28,580 --> 00:27:33,320
issues in the Ram itself and then it

00:27:31,490 --> 00:27:35,840
would actually copy the l2 loader back

00:27:33,320 --> 00:27:38,450
to the RAM so that is execute way faster

00:27:35,840 --> 00:27:40,640
than the C prime axis remember the see

00:27:38,450 --> 00:27:42,500
prom goes over i2c it's slow whether

00:27:40,640 --> 00:27:47,090
this goes over a parallel pit bus it's

00:27:42,500 --> 00:27:47,660
way faster once the l2 loader takes over

00:27:47,090 --> 00:27:49,940
it base

00:27:47,660 --> 00:27:52,820
he has a compressed base image in the

00:27:49,940 --> 00:27:54,320
serum here we had to compress the image

00:27:52,820 --> 00:27:56,210
because the amount of function going in

00:27:54,320 --> 00:27:58,390
was not fitting in memory so we have

00:27:56,210 --> 00:28:01,520
used a native compression algorithm here

00:27:58,390 --> 00:28:03,080
it's a dictionary based algorithm which

00:28:01,520 --> 00:28:06,710
kind of does a histogram of the number

00:28:03,080 --> 00:28:08,750
of instructions so the compression is

00:28:06,710 --> 00:28:12,260
done at Build time and the decompression

00:28:08,750 --> 00:28:14,870
is done during boot so the l2 loaded

00:28:12,260 --> 00:28:16,370
boots copy is this image decompresses

00:28:14,870 --> 00:28:19,250
are on the fly and copies it in the ram

00:28:16,370 --> 00:28:21,500
and then just vectors to that address

00:28:19,250 --> 00:28:23,600
and starts so that's where the kernel

00:28:21,500 --> 00:28:26,860
starts booting and once the kernel boots

00:28:23,600 --> 00:28:29,660
and initializes the rest of the hardware

00:28:26,860 --> 00:28:31,820
data structures that's why you get the

00:28:29,660 --> 00:28:33,640
application gets control and there's

00:28:31,820 --> 00:28:36,080
bees ready for the control loop business

00:28:33,640 --> 00:28:42,200
accepting chip hops over the 500 or the

00:28:36,080 --> 00:28:43,760
PSU moving to the whoops I need to

00:28:42,200 --> 00:28:46,970
really accelerate here so move into the

00:28:43,760 --> 00:28:50,090
boot flow so you it's apparent like the

00:28:46,970 --> 00:28:52,370
yellow stars are the external aides that

00:28:50,090 --> 00:28:54,380
the SB requires during in during a boot

00:28:52,370 --> 00:28:56,870
flow but the blue stars are the ones

00:28:54,380 --> 00:28:58,880
where the SB is actually involved and a

00:28:56,870 --> 00:29:01,700
critical component of the boot flow so

00:28:58,880 --> 00:29:04,730
the step one is basically when the SB

00:29:01,700 --> 00:29:06,560
itself is booting and we just showed the

00:29:04,730 --> 00:29:08,600
boot from the previous chart and then

00:29:06,560 --> 00:29:10,610
here it's actually ready for going

00:29:08,600 --> 00:29:12,920
through different steps to initialize

00:29:10,610 --> 00:29:15,830
the chip so we initialize the pervasive

00:29:12,920 --> 00:29:18,590
register here we start the clocks so the

00:29:15,830 --> 00:29:21,590
steps 1 2 & 3 are common for all chips

00:29:18,590 --> 00:29:22,850
in a multi chip system but the master

00:29:21,590 --> 00:29:25,250
chip would execute

00:29:22,850 --> 00:29:27,620
additionally the step 4 & 5 which is

00:29:25,250 --> 00:29:29,330
kind of required to load host boot so

00:29:27,620 --> 00:29:30,590
the master code and the master core gets

00:29:29,330 --> 00:29:33,080
initialized in step 4

00:29:30,590 --> 00:29:37,070
and then we load the host boot boot

00:29:33,080 --> 00:29:39,740
loader image from the C problem into the

00:29:37,070 --> 00:29:41,510
l3 cache and that's where we start

00:29:39,740 --> 00:29:43,490
running the instructions on the host so

00:29:41,510 --> 00:29:45,350
at this point SB gives control to the

00:29:43,490 --> 00:29:47,960
host and is ready to accept chip pops on

00:29:45,350 --> 00:29:49,910
a master chip but on the slave ship it

00:29:47,960 --> 00:29:53,300
just stops and is ready for chip ops and

00:29:49,910 --> 00:29:56,210
then if if you see here and the step 8

00:29:53,300 --> 00:29:57,920
is when the host boot is running on the

00:29:56,210 --> 00:29:59,960
master chip and it can actually trigger

00:29:57,920 --> 00:30:01,610
the slave as B's the other chips in the

00:29:59,960 --> 00:30:04,700
system to start booting and they

00:30:01,610 --> 00:30:07,010
start from here again and if if the host

00:30:04,700 --> 00:30:09,530
mood finds a new code update and the PNR

00:30:07,010 --> 00:30:11,900
weathers sba images changed it would

00:30:09,530 --> 00:30:15,620
trigger an SB update and I step in the

00:30:11,900 --> 00:30:17,270
step ten that you see or later on which

00:30:15,620 --> 00:30:18,799
we end up initializing memory and

00:30:17,270 --> 00:30:20,240
everything and when the system is ready

00:30:18,799 --> 00:30:22,160
for business with all the base had been

00:30:20,240 --> 00:30:24,559
initialized it goes to the core

00:30:22,160 --> 00:30:26,150
initialization and this is a place where

00:30:24,559 --> 00:30:28,010
the dead man timer loop happens in the

00:30:26,150 --> 00:30:31,309
sell boot engine where the host boot

00:30:28,010 --> 00:30:33,170
will actually go to a very low-power

00:30:31,309 --> 00:30:37,040
state it's called the Winkle Winkle mode

00:30:33,170 --> 00:30:38,929
cycle and it would start a timer and

00:30:37,040 --> 00:30:41,270
tell that it expects the SB don't

00:30:38,929 --> 00:30:42,860
maintain a timer basically and then the

00:30:41,270 --> 00:30:45,500
SB he will wait for the system to have

00:30:42,860 --> 00:30:48,770
reached that really low state and then

00:30:45,500 --> 00:30:52,100
it reapplies the hardware initialization

00:30:48,770 --> 00:30:55,549
states when it comes back up and I step

00:30:52,100 --> 00:30:56,750
16 so it again sends an IP I kind of

00:30:55,549 --> 00:31:00,169
think to the host boot and I was booed

00:30:56,750 --> 00:31:04,150
wakes up there so I think that's that's

00:31:00,169 --> 00:31:06,559
the contribution of SB in the ISTEP I

00:31:04,150 --> 00:31:08,929
think I'll skip this chart because we

00:31:06,559 --> 00:31:11,419
kind of covered this but in in addition

00:31:08,929 --> 00:31:13,370
to the basic or boot steps we provide

00:31:11,419 --> 00:31:16,400
secure Hardware access blacklisting

00:31:13,370 --> 00:31:19,370
memory access and the chip ops which we

00:31:16,400 --> 00:31:21,650
spoke about the scan access to host boot

00:31:19,370 --> 00:31:24,020
by a FIFO so before the power bus is

00:31:21,650 --> 00:31:26,450
initialized it goes by the FIFO scum

00:31:24,020 --> 00:31:28,970
services to host boot for fabric setup

00:31:26,450 --> 00:31:30,799
and then the debug services to BMC like

00:31:28,970 --> 00:31:33,620
in the lab you want to grab the host

00:31:30,799 --> 00:31:36,860
boot traces or the host boot dump you

00:31:33,620 --> 00:31:38,720
can get it from the SB runtime services

00:31:36,860 --> 00:31:42,080
are the timer ones which we have given

00:31:38,720 --> 00:31:43,970
for Linux we could end up accessing OCC

00:31:42,080 --> 00:31:47,210
SRAM from the BMC but we don't have the

00:31:43,970 --> 00:31:49,340
use case yet host pass-through commands

00:31:47,210 --> 00:31:53,090
for the help Hardware monitoring between

00:31:49,340 --> 00:31:55,669
OCC and BMC SBS at at kernel dump which

00:31:53,090 --> 00:31:57,770
was the FA dump we spoke about and then

00:31:55,669 --> 00:31:59,419
debug debugging a hung machine I think

00:31:57,770 --> 00:32:01,640
the nmi request which was put up on the

00:31:59,419 --> 00:32:03,350
chat yesterday so that also is supported

00:32:01,640 --> 00:32:05,990
by the SP so there's a chip op which

00:32:03,350 --> 00:32:07,850
just thread control and if you do a SV

00:32:05,990 --> 00:32:12,260
said it would actually go and get the

00:32:07,850 --> 00:32:15,020
chip out of a hung mode for Linux the

00:32:12,260 --> 00:32:17,570
announcements coming in the next systems

00:32:15,020 --> 00:32:19,250
so basically we have figured out okay

00:32:17,570 --> 00:32:21,770
there's one FSI bus and there are two

00:32:19,250 --> 00:32:23,150
masters the host boot could be trying to

00:32:21,770 --> 00:32:25,760
talk to the self put engine at the same

00:32:23,150 --> 00:32:27,470
time that the BMC is going to talk so we

00:32:25,760 --> 00:32:30,080
have introduced a new SB five for

00:32:27,470 --> 00:32:31,790
exclusively for the host and for

00:32:30,080 --> 00:32:34,460
security reasons no one else can access

00:32:31,790 --> 00:32:36,250
this except the host we're going to have

00:32:34,460 --> 00:32:38,960
a larger SRAM because a lot of

00:32:36,250 --> 00:32:42,500
functionality is coming back into the SB

00:32:38,960 --> 00:32:44,180
so we are moving the other the hardware

00:32:42,500 --> 00:32:46,430
is getting more and more abstracted from

00:32:44,180 --> 00:32:48,320
the BMC so all that is getting sucked

00:32:46,430 --> 00:32:50,390
into the SB so we need more space to

00:32:48,320 --> 00:32:53,030
grab all those functions we're gonna

00:32:50,390 --> 00:32:54,980
have dumps and check stop analysis in

00:32:53,030 --> 00:32:57,410
the in the SB it's going to assist that

00:32:54,980 --> 00:33:00,170
overall firmware function improved

00:32:57,410 --> 00:33:03,050
security so there were discussions about

00:33:00,170 --> 00:33:04,490
the SVC prompt being compromised so to

00:33:03,050 --> 00:33:06,410
do that we're gonna actually have an

00:33:04,490 --> 00:33:08,440
immutable measurements EEPROM in the

00:33:06,410 --> 00:33:11,210
future which improves the secure boot

00:33:08,440 --> 00:33:13,160
debug access of the open Cappy memory

00:33:11,210 --> 00:33:15,770
buffer I think some of our hardware

00:33:13,160 --> 00:33:17,510
architects just poke about that so we

00:33:15,770 --> 00:33:18,860
should be able to dump out stuff from

00:33:17,510 --> 00:33:21,650
this memory buffer if things don't work

00:33:18,860 --> 00:33:23,240
and tell him e3 something which TARDIS

00:33:21,650 --> 00:33:28,670
asked for and we're trying to support

00:33:23,240 --> 00:33:31,820
that on the OC MB as well so to conclude

00:33:28,670 --> 00:33:33,890
my talk the SP Hardware firmware core

00:33:31,820 --> 00:33:36,230
design has been significantly and raised

00:33:33,890 --> 00:33:39,080
in power 9 compared to just booting the

00:33:36,230 --> 00:33:41,030
host boot and power eight and we have

00:33:39,080 --> 00:33:43,640
major architectural directions first is

00:33:41,030 --> 00:33:45,380
hardware abstraction to the BMC second

00:33:43,640 --> 00:33:48,410
was enhanced platform trust and security

00:33:45,380 --> 00:33:50,030
so secure and trusted boot and baked in

00:33:48,410 --> 00:33:52,280
capabilities for the advanced security

00:33:50,030 --> 00:33:54,290
features like di TMS this is something

00:33:52,280 --> 00:33:56,060
which you're not using right now the

00:33:54,290 --> 00:33:58,040
digital or the dynamic root of trust

00:33:56,060 --> 00:34:01,490
management but we have the plumbing in

00:33:58,040 --> 00:34:03,080
place so that need ever comes up the SP

00:34:01,490 --> 00:34:05,390
was right there to help with this one

00:34:03,080 --> 00:34:07,310
improved Rass functions so we talked

00:34:05,390 --> 00:34:10,130
about the EM the memory preserving boot

00:34:07,310 --> 00:34:14,210
and the FA dump the check stop analysis

00:34:10,130 --> 00:34:16,520
hardware dumps and the SD sets for the

00:34:14,210 --> 00:34:19,130
enemies we are also proposing built in

00:34:16,520 --> 00:34:22,220
self-test and the future generations for

00:34:19,130 --> 00:34:24,880
improved rass support host hypervisor

00:34:22,220 --> 00:34:27,560
offload tasks for improved performance

00:34:24,880 --> 00:34:28,920
so we are we are in discussions with the

00:34:27,560 --> 00:34:32,850
next team on how to leave

00:34:28,920 --> 00:34:34,380
this off-chip engine I mean off uncor

00:34:32,850 --> 00:34:37,020
engine is what they call it because it's

00:34:34,380 --> 00:34:38,760
not used by the customers so timers and

00:34:37,020 --> 00:34:41,130
wells combs are some use cases which we

00:34:38,760 --> 00:34:43,320
have right now and the source is all

00:34:41,130 --> 00:34:47,130
open the code is all open source right

00:34:43,320 --> 00:34:52,590
here so please feel free to go and make

00:34:47,130 --> 00:34:54,000
changes or get help on this this is some

00:34:52,590 --> 00:34:56,190
of the glossary for the hardware items

00:34:54,000 --> 00:35:01,310
that I had on the charts and I think

00:34:56,190 --> 00:35:01,310
that's all I had any questions

00:35:04,750 --> 00:35:10,660
what bus so it's basically goes from the

00:35:09,069 --> 00:35:12,550
host boot right so you just need to go

00:35:10,660 --> 00:35:19,450
and is the pervasive interface bus which

00:35:12,550 --> 00:35:20,859
is internal to the chip so it's the

00:35:19,450 --> 00:35:23,380
slave as bees are sitting on a separate

00:35:20,859 --> 00:35:24,970
chip itself so eventually you would get

00:35:23,380 --> 00:35:26,920
a pip interrupt into the slave as B's

00:35:24,970 --> 00:35:28,540
but when the host sends an interrupt it

00:35:26,920 --> 00:35:30,760
would go over the FSI to the other chip

00:35:28,540 --> 00:35:31,210
so there's a cascade of FSI between

00:35:30,760 --> 00:35:33,190
chips

00:35:31,210 --> 00:35:34,540
so when host sends an interrupt host

00:35:33,190 --> 00:35:37,060
tries to do that it would go over the

00:35:34,540 --> 00:35:42,970
FSI on to the big bus of that specific

00:35:37,060 --> 00:35:44,560
chip so we just need to go to the C

00:35:42,970 --> 00:35:48,310
family right at the moment you have a

00:35:44,560 --> 00:35:50,560
CFM reset the SV starts booting so that

00:35:48,310 --> 00:35:53,579
map's internally to the pit mem and that

00:35:50,560 --> 00:35:53,579
to the interrupt Bolton

00:36:01,589 --> 00:36:15,599
sorry could you elaborate a bit on that

00:36:16,670 --> 00:36:28,109
no I think no nothing from the be a

00:36:20,130 --> 00:36:30,599
friend that I know of not on the SP yeah

00:36:28,109 --> 00:36:33,480
I mean by default you choose the system

00:36:30,599 --> 00:36:38,460
will be secure and you're not going to

00:36:33,480 --> 00:36:39,990
be able to access the memory so the

00:36:38,460 --> 00:36:41,940
security algorithms are like all

00:36:39,990 --> 00:36:44,700
software defined and which hardware

00:36:41,940 --> 00:36:46,410
facilities or registers to access or not

00:36:44,700 --> 00:36:48,980
access there's a there's a

00:36:46,410 --> 00:36:51,960
comma-separated file available in github

00:36:48,980 --> 00:36:54,210
so every scam registers base address

00:36:51,960 --> 00:36:57,540
which unit it goes to and whether it

00:36:54,210 --> 00:36:58,710
should be right accessible or not and

00:36:57,540 --> 00:37:00,930
whether it's I think by default

00:36:58,710 --> 00:37:03,839
everything is read accessible so there's

00:37:00,930 --> 00:37:05,849
a there's a read blacklist there's a

00:37:03,839 --> 00:37:08,549
write blacklist by default nothing can

00:37:05,849 --> 00:37:10,200
be written so you need a whitelist if

00:37:08,549 --> 00:37:11,660
you want to write to a register and that

00:37:10,200 --> 00:37:14,430
goes through the security architecture

00:37:11,660 --> 00:37:15,869
discussions to know whether it's that

00:37:14,430 --> 00:37:17,640
particular hardware register can be

00:37:15,869 --> 00:37:20,400
accessed or not so if it's found to be

00:37:17,640 --> 00:37:25,520
safe that can be added to the to that

00:37:20,400 --> 00:37:25,520
CSV file and the SPS works as it is

00:37:51,790 --> 00:37:55,880
okay I'm just trying to understand the

00:37:54,020 --> 00:37:58,310
question so you're saying it's about the

00:37:55,880 --> 00:38:01,000
SB update or it's about a different

00:37:58,310 --> 00:38:01,000
configuration of

00:38:15,460 --> 00:38:21,220
yes

00:38:17,740 --> 00:38:22,750
so I think typically in open power

00:38:21,220 --> 00:38:25,119
systems you have two images one is the

00:38:22,750 --> 00:38:27,640
EB MC and the second one is the P nor

00:38:25,119 --> 00:38:30,400
image so the SB M it actually gets

00:38:27,640 --> 00:38:31,930
packed into the P na and when whose boot

00:38:30,400 --> 00:38:34,150
boots up it actually goes and reaches up

00:38:31,930 --> 00:38:36,640
in R and and tries to compare with what

00:38:34,150 --> 00:38:38,050
it sees in the C prom and if it finds a

00:38:36,640 --> 00:38:47,500
difference there that's when it could go

00:38:38,050 --> 00:38:50,200
for an update and no it would actually

00:38:47,500 --> 00:38:50,589
it will actually go and reprogram the C

00:38:50,200 --> 00:38:52,210
prom

00:38:50,589 --> 00:38:54,130
it would quest there's B the D program

00:38:52,210 --> 00:38:57,160
the C prom and ask for a reappear

00:38:54,130 --> 00:38:58,900
I mean reboot and then on the next

00:38:57,160 --> 00:39:07,810
reboot it actually finds them matching

00:38:58,900 --> 00:39:09,610
and it's good to go any other questions

00:39:07,810 --> 00:39:14,519
Thanks thank you

00:39:09,610 --> 00:39:14,519

YouTube URL: https://www.youtube.com/watch?v=EEHYPB8WgNw


