Title: OpenPOWER Summit NA 2019: Linux on POWER Driver Porting, Optimization, and Test
Publication date: 2019-08-28
Playlist: OpenPOWER Summit NA 2019
Description: 
	Presented by Brian King, IBM

This session will provide an overview of what is involved in porting an I/O device driver to the POWER processor. It will cover both high-level architectural content as well as diving deep into the code. It will include an overview of various architectural differences between POWER and other architectures. Specific examples of issues discovered in the past will be reviewed. The scope of this session will encompass functional porting, optimization, as well as test tools and methodologies.
Captions: 
	00:00:00,060 --> 00:00:07,440
so I'm breaking open power I worker

00:00:02,909 --> 00:00:09,750
chair and also work at IBM working on IO

00:00:07,440 --> 00:00:13,080
and amongst other things so I'm here to

00:00:09,750 --> 00:00:15,960
talk a little bit about some of my

00:00:13,080 --> 00:00:18,270
experience porting drivers to the power

00:00:15,960 --> 00:00:20,430
platform from other architectures and

00:00:18,270 --> 00:00:22,710
some of the issues that we tend to see

00:00:20,430 --> 00:00:26,939
both in the initial port and then also

00:00:22,710 --> 00:00:29,550
just regressions that that creep in for

00:00:26,939 --> 00:00:32,149
drivers that already have imported so

00:00:29,550 --> 00:00:34,890
I'm gonna start out today by covering

00:00:32,149 --> 00:00:38,730
just some basics of the power

00:00:34,890 --> 00:00:42,140
architecture that relate to i/o areas

00:00:38,730 --> 00:00:47,219
like cache coherency synchronization

00:00:42,140 --> 00:00:50,010
memory barriers load store ordering PCI

00:00:47,219 --> 00:00:53,300
addressing and extended error handling

00:00:50,010 --> 00:00:56,160
things like that talk a little bit about

00:00:53,300 --> 00:00:58,320
boot on open power system which a lot of

00:00:56,160 --> 00:01:02,280
you already you're gonna know but just

00:00:58,320 --> 00:01:06,270
some of the nuances that means for for

00:01:02,280 --> 00:01:08,250
i/o device drivers and and such touch a

00:01:06,270 --> 00:01:10,470
little bit on test we got follow-up

00:01:08,250 --> 00:01:12,770
session on contest so I'm not gonna

00:01:10,470 --> 00:01:15,750
dwell on that too much I'll let Sasha

00:01:12,770 --> 00:01:18,810
give all the details there but and then

00:01:15,750 --> 00:01:21,330
I'll kind of close out with just a

00:01:18,810 --> 00:01:24,930
little bit on open power Eddy and IO

00:01:21,330 --> 00:01:31,380
worker at this moment so to start out

00:01:24,930 --> 00:01:34,840
with byte order so this is not quite

00:01:31,380 --> 00:01:37,720
it's still an issue for it for some

00:01:34,840 --> 00:01:41,140
for some folks but from a linux

00:01:37,720 --> 00:01:45,490
perspective we're rapidly racing towards

00:01:41,140 --> 00:01:46,900
little-endian as the the prime focus if

00:01:45,490 --> 00:01:49,900
we look at all the open power systems

00:01:46,900 --> 00:01:52,180
that are out there today the vast

00:01:49,900 --> 00:01:53,430
majority of them are all running little

00:01:52,180 --> 00:01:55,660
Indiana

00:01:53,430 --> 00:01:57,850
you know this reduces one of those but

00:01:55,660 --> 00:01:59,050
one of the barriers to portability you

00:01:57,850 --> 00:02:01,060
know that's that obviously if you're

00:01:59,050 --> 00:02:04,780
writing a driver from scratch there's

00:02:01,060 --> 00:02:11,110
there's macros to make sure that drivers

00:02:04,780 --> 00:02:14,320
are our portable so you know continue

00:02:11,110 --> 00:02:17,590
know just continue to to use the byte

00:02:14,320 --> 00:02:19,120
swapping api's that I have there the

00:02:17,590 --> 00:02:22,690
other thing power little-endian

00:02:19,120 --> 00:02:24,220
is 64-bit only so no 32-bit user space

00:02:22,690 --> 00:02:26,440
and the only reason I bring that up is

00:02:24,220 --> 00:02:29,020
with a lot of i/o devices sometimes they

00:02:26,440 --> 00:02:32,200
have management tools that have existed

00:02:29,020 --> 00:02:35,200
for years and years and years and some

00:02:32,200 --> 00:02:36,880
of them are still 32-bit only that

00:02:35,200 --> 00:02:39,519
doesn't seem to be too much of a problem

00:02:36,880 --> 00:02:42,910
anymore these days but just wanted to

00:02:39,519 --> 00:02:45,519
mention that and then the last item is

00:02:42,910 --> 00:02:50,080
just cache line size get 128 byte cache

00:02:45,519 --> 00:02:52,360
line size on power if you're doing micro

00:02:50,080 --> 00:02:55,540
optimizations of performance you know

00:02:52,360 --> 00:03:00,670
that's helpful to know we do have cache

00:02:55,540 --> 00:03:03,190
inject on p9 so doing smaller than cache

00:03:00,670 --> 00:03:06,100
line size DNA's aren't as painful as

00:03:03,190 --> 00:03:07,480
that used to be but you know the 128

00:03:06,100 --> 00:03:11,739
byte DMAs are going to give you the best

00:03:07,480 --> 00:03:14,670
performance so let's talk about cache

00:03:11,739 --> 00:03:14,670
coherency little bit so

00:03:15,049 --> 00:03:20,340
if you want it so one of the main one of

00:03:18,719 --> 00:03:23,519
the big things in a in a device driver

00:03:20,340 --> 00:03:24,900
is dealing with both hashable memory and

00:03:23,519 --> 00:03:27,120
non cash flow memory in the cache in my

00:03:24,900 --> 00:03:29,250
memory is typically your memory and your

00:03:27,120 --> 00:03:31,950
host DMA buffers things like that and

00:03:29,250 --> 00:03:34,049
the non cashable memory is typically

00:03:31,950 --> 00:03:38,790
your mm i/o space your bar space your

00:03:34,049 --> 00:03:41,970
registers and so you need to make sure

00:03:38,790 --> 00:03:44,310
that you're using the right api's when

00:03:41,970 --> 00:03:47,069
you're accessing that non cashable

00:03:44,310 --> 00:03:50,220
storage and if and you also need to be

00:03:47,069 --> 00:03:52,379
cognizant of ensuring synchronization

00:03:50,220 --> 00:03:53,819
between those those things and so we're

00:03:52,379 --> 00:04:01,290
gonna go dive into a little bit a little

00:03:53,819 --> 00:04:04,169
bit here kind of first basic macro is

00:04:01,290 --> 00:04:06,599
when you're doing mm i/o stores you know

00:04:04,169 --> 00:04:08,819
typically if you're going to you know a

00:04:06,599 --> 00:04:11,099
typical operation that device driver

00:04:08,819 --> 00:04:14,340
does is they have a command block and in

00:04:11,099 --> 00:04:16,709
the host memory that you're gonna fill

00:04:14,340 --> 00:04:18,329
out to tell heat after to do something

00:04:16,709 --> 00:04:19,889
you fill it out and then you go in you

00:04:18,329 --> 00:04:21,690
poke a doorbell and the in the adapter

00:04:19,889 --> 00:04:25,770
the adapter DMA is now in that control

00:04:21,690 --> 00:04:28,919
block and execute sit on power you need

00:04:25,770 --> 00:04:31,650
to make sure that that is that all the

00:04:28,919 --> 00:04:33,240
rights to that DMA buffer are actually

00:04:31,650 --> 00:04:36,090
in memory and not sitting in a cache

00:04:33,240 --> 00:04:39,960
somewhere we if you as long as you're

00:04:36,090 --> 00:04:42,090
using the mm i/o macros like write l2 do

00:04:39,960 --> 00:04:44,639
that mm IO store we have a built-in

00:04:42,090 --> 00:04:46,949
macro our built-in hardware sync

00:04:44,639 --> 00:04:51,780
instruction in there to ensure that

00:04:46,949 --> 00:04:54,960
coherency there is not too long ago the

00:04:51,780 --> 00:04:58,530
kernel community added relaxed variants

00:04:54,960 --> 00:05:00,419
of read and write today those do the

00:04:58,530 --> 00:05:02,669
same thing on power there's some people

00:05:00,419 --> 00:05:04,560
that are going off and and trying to

00:05:02,669 --> 00:05:05,909
optimize their drivers and putting in

00:05:04,560 --> 00:05:08,190
the real experience where they think

00:05:05,909 --> 00:05:11,159
they can today that it's not going to

00:05:08,190 --> 00:05:12,120
buy anything at power but not to say

00:05:11,159 --> 00:05:16,050
that it couldn't change in the future

00:05:12,120 --> 00:05:18,630
but the raw variants there's raw read

00:05:16,050 --> 00:05:20,130
and write as well those have no bite

00:05:18,630 --> 00:05:23,070
swapping in them and also have no

00:05:20,130 --> 00:05:24,659
built-in barriers so if you are using

00:05:23,070 --> 00:05:27,170
those you need to be very careful about

00:05:24,659 --> 00:05:29,060
making sure that you're using the right

00:05:27,170 --> 00:05:30,800
synchronization barriers and we'll get

00:05:29,060 --> 00:05:35,720
into those some of it some more details

00:05:30,800 --> 00:05:39,770
of those in a bit there's a whole bunch

00:05:35,720 --> 00:05:41,450
of different ways to synchronize code in

00:05:39,770 --> 00:05:44,210
the kernel spin locks

00:05:41,450 --> 00:05:48,380
we have mutex to semaphores atomic

00:05:44,210 --> 00:05:50,930
variables in the memory barriers RC you

00:05:48,380 --> 00:05:52,880
read copy update all for different use

00:05:50,930 --> 00:05:55,880
cases some of them can be used in

00:05:52,880 --> 00:05:58,100
interrupt context some can't some of

00:05:55,880 --> 00:06:01,370
them are very lightweight some of them

00:05:58,100 --> 00:06:03,170
are more heavyweight for the most part

00:06:01,370 --> 00:06:05,030
imma spend most of the time on on

00:06:03,170 --> 00:06:06,500
barriers just because that's an area

00:06:05,030 --> 00:06:09,560
that we run into a lot of problems with

00:06:06,500 --> 00:06:12,920
in in power a lot of the other semantics

00:06:09,560 --> 00:06:15,530
are generally as long as we're coding to

00:06:12,920 --> 00:06:18,200
those api's and using those locks you

00:06:15,530 --> 00:06:20,480
know spin locks and mutexes and such we

00:06:18,200 --> 00:06:25,790
don't necessarily see as much problem in

00:06:20,480 --> 00:06:27,820
there in that area on power so I kind of

00:06:25,790 --> 00:06:30,250
broke out three different classes of

00:06:27,820 --> 00:06:32,900
memory barriers in the Linux kernel so

00:06:30,250 --> 00:06:37,520
the first one is mandatory barriers and

00:06:32,900 --> 00:06:40,730
these are are always enforced today

00:06:37,520 --> 00:06:43,790
these all translate to a hardware sync

00:06:40,730 --> 00:06:47,270
instruction on power which is a pretty

00:06:43,790 --> 00:06:48,890
heavyweight instruction you don't want

00:06:47,270 --> 00:06:50,540
to just sprinkle these into your code in

00:06:48,890 --> 00:06:55,510
the performance path unless you really

00:06:50,540 --> 00:06:57,770
need one but they do allow for

00:06:55,510 --> 00:06:59,840
synchronization not only between CPUs

00:06:57,770 --> 00:07:03,530
but also between cashable and not

00:06:59,840 --> 00:07:07,070
cashflow stores there's a lighter-weight

00:07:03,530 --> 00:07:09,980
version of it which is SMP conditional

00:07:07,070 --> 00:07:14,090
and those are typically only used for

00:07:09,980 --> 00:07:17,410
CPU to CPU synchronization those

00:07:14,090 --> 00:07:22,730
translate to a lightweight sync today on

00:07:17,410 --> 00:07:24,650
power but those can't be used to order

00:07:22,730 --> 00:07:26,370
to ensure consistency beekeeping

00:07:24,650 --> 00:07:28,979
cashable and non-cash

00:07:26,370 --> 00:07:34,290
and others the DMA variants these are

00:07:28,979 --> 00:07:36,030
still relatively new in Linux these can

00:07:34,290 --> 00:07:39,720
be used when your so they don't get

00:07:36,030 --> 00:07:40,710
compiled up on a uniprocessor kernel but

00:07:39,720 --> 00:07:43,500
they are lighter weight they are

00:07:40,710 --> 00:07:45,479
lightweight sync and so you can use them

00:07:43,500 --> 00:07:49,110
if you're meeting to order

00:07:45,479 --> 00:07:52,470
loads within a DMA buffer so if you have

00:07:49,110 --> 00:07:55,320
a valid if the adapter is DM aying

00:07:52,470 --> 00:07:58,020
you know data and a valid bit and you're

00:07:55,320 --> 00:07:59,789
you're reading those two values you can

00:07:58,020 --> 00:08:02,220
use the DMA variant to ensure that

00:07:59,789 --> 00:08:04,410
you're checking the valid bit before you

00:08:02,220 --> 00:08:08,370
start loading something that's dependent

00:08:04,410 --> 00:08:09,479
on that valid bit and then there's a

00:08:08,370 --> 00:08:11,550
link in the bottom of the year I've

00:08:09,479 --> 00:08:14,729
tried to put a lot of links throughout

00:08:11,550 --> 00:08:16,020
this PDF to other documentation that

00:08:14,729 --> 00:08:19,199
goes into a lot more detail

00:08:16,020 --> 00:08:21,449
there's kernel documentation in the

00:08:19,199 --> 00:08:26,270
kernel that goes into a lot of depth and

00:08:21,449 --> 00:08:30,300
a lot of examples about barriers and

00:08:26,270 --> 00:08:32,640
what you can and can't do and is very

00:08:30,300 --> 00:08:35,490
platform agnostic so there's some

00:08:32,640 --> 00:08:38,250
barriers that only apply to like alpha

00:08:35,490 --> 00:08:42,870
or SPARC and so this tries to be

00:08:38,250 --> 00:08:44,880
agnostic and cover everything so I

00:08:42,870 --> 00:08:47,520
wanted to look just kind of give you a

00:08:44,880 --> 00:08:49,050
couple of examples of some of the

00:08:47,520 --> 00:08:52,230
defects some of the bugs that we found

00:08:49,050 --> 00:08:54,029
in device drivers having to do with

00:08:52,230 --> 00:08:59,400
memory barriers so this is the first

00:08:54,029 --> 00:09:01,290
example so here we have at the top this

00:08:59,400 --> 00:09:04,140
is essentially you know isn't a ethernet

00:09:01,290 --> 00:09:06,480
device driver we're processing the

00:09:04,140 --> 00:09:10,080
completion and takin interrupt and we're

00:09:06,480 --> 00:09:12,770
processing the completion so at the top

00:09:10,080 --> 00:09:15,830
you know we check to see whether or not

00:09:12,770 --> 00:09:18,540
the command is completed there's a

00:09:15,830 --> 00:09:22,080
essentially a valid bit that gets

00:09:18,540 --> 00:09:23,790
checked there and then we reload both

00:09:22,080 --> 00:09:26,339
the producer index and the consumer

00:09:23,790 --> 00:09:29,930
index you know typically in a network

00:09:26,339 --> 00:09:32,279
driver the producer in the index is

00:09:29,930 --> 00:09:34,139
managed by the adapter and the consumer

00:09:32,279 --> 00:09:37,199
index is managed by the

00:09:34,139 --> 00:09:39,989
by the device driver and they just kind

00:09:37,199 --> 00:09:42,749
of keep track of in a ring buffer what

00:09:39,989 --> 00:09:45,389
commands have completed and so what we

00:09:42,749 --> 00:09:48,389
had what what is needed there is this

00:09:45,389 --> 00:09:50,429
this read memory barrier at the bottom

00:09:48,389 --> 00:09:53,540
because in what's that's attempting to

00:09:50,429 --> 00:09:57,839
order is making sure that the load from

00:09:53,540 --> 00:10:00,660
the of the completed bit up there at the

00:09:57,839 --> 00:10:02,970
top happens prior to starting to check

00:10:00,660 --> 00:10:05,189
the flags the the issue that we're

00:10:02,970 --> 00:10:06,959
finding was that the the load of the

00:10:05,189 --> 00:10:10,579
flags at the bottom there was happening

00:10:06,959 --> 00:10:15,619
prior to the load of the completed day

00:10:10,579 --> 00:10:18,199
and which was then causing stale or

00:10:15,619 --> 00:10:21,839
invalid data to be used and it was

00:10:18,199 --> 00:10:26,579
confusing there the state engine and the

00:10:21,839 --> 00:10:30,389
in the driver if I can interrupt how did

00:10:26,579 --> 00:10:32,249
you find that problem this one well this

00:10:30,389 --> 00:10:34,769
so this one has been around I did not

00:10:32,249 --> 00:10:36,509
find this one this one has been his

00:10:34,769 --> 00:10:39,059
wasn't around as an example for a long

00:10:36,509 --> 00:10:41,459
time the next to where are ones that I

00:10:39,059 --> 00:10:48,449
thought I did find so I'll provide some

00:10:41,459 --> 00:10:51,389
background on those so this is one that

00:10:48,449 --> 00:10:56,670
was found within the last month actually

00:10:51,389 --> 00:11:00,089
it's a but that was around for a while I

00:10:56,670 --> 00:11:02,220
don't know how long and we just happened

00:11:00,089 --> 00:11:04,170
to stumble across it on a very large

00:11:02,220 --> 00:11:07,980
system with about a dozen of these

00:11:04,170 --> 00:11:11,309
adapters with a you know as a four node

00:11:07,980 --> 00:11:13,980
machine so Numa effects were very

00:11:11,309 --> 00:11:16,470
exaggerated lots of memory and so a

00:11:13,980 --> 00:11:19,379
synchronization a hardware sync command

00:11:16,470 --> 00:11:22,350
takes a long time to happen and so it

00:11:19,379 --> 00:11:25,350
was really extending and exaggerating a

00:11:22,350 --> 00:11:28,999
lot of the the new effects and and the

00:11:25,350 --> 00:11:35,339
load/store yard range so on the top is

00:11:28,999 --> 00:11:37,709
cpu 0 it's doing a transmit buffer in

00:11:35,339 --> 00:11:39,629
you know I tried that I pulled out a lot

00:11:37,709 --> 00:11:42,449
of the code here obviously but what it's

00:11:39,629 --> 00:11:44,960
doing is it's taking an sk buff which is

00:11:42,449 --> 00:11:48,110
a network packet buffer essentially

00:11:44,960 --> 00:11:52,130
and storing a pointer to that in a in a

00:11:48,110 --> 00:11:54,890
local buffer that it managed for the

00:11:52,130 --> 00:11:57,860
transmitted packet does the right memory

00:11:54,890 --> 00:11:59,960
berry to ensure that the whole packet

00:11:57,860 --> 00:12:02,120
data and and all the metadata that's

00:11:59,960 --> 00:12:04,730
associated with that that the NIC needs

00:12:02,120 --> 00:12:07,580
to know about is synchronized does a

00:12:04,730 --> 00:12:10,310
doorbell which is just the non cashable

00:12:07,580 --> 00:12:13,070
store to the adapter and then the

00:12:10,310 --> 00:12:15,080
adapter goes off and and starts

00:12:13,070 --> 00:12:19,130
processing that on the bottom is the

00:12:15,080 --> 00:12:20,390
interrupt path and here I pulled out a

00:12:19,130 --> 00:12:22,850
lot of the code here to there's a

00:12:20,390 --> 00:12:25,940
surprising amount of code that happens

00:12:22,850 --> 00:12:27,830
and it really boggled my mind when when

00:12:25,940 --> 00:12:29,780
we actually can't stumble across this

00:12:27,830 --> 00:12:31,580
one because what we were hitting was

00:12:29,780 --> 00:12:34,790
line fourteen down there

00:12:31,580 --> 00:12:37,180
we had a null SKB pointer in the

00:12:34,790 --> 00:12:40,760
transmitted path and if you roll back

00:12:37,180 --> 00:12:43,550
what in order for that to happen what

00:12:40,760 --> 00:12:46,580
was what was happening was that the the

00:12:43,550 --> 00:12:50,500
hardware consumer index that load is a

00:12:46,580 --> 00:12:53,780
load that was being delayed

00:12:50,500 --> 00:13:00,290
we were speculatively walking through

00:12:53,780 --> 00:13:02,930
down into the wild loop and loading in

00:13:00,290 --> 00:13:06,590
and falling down and loading the skb on

00:13:02,930 --> 00:13:10,790
line eleven there before we loaded the

00:13:06,590 --> 00:13:13,340
hardware consumer index to see that you

00:13:10,790 --> 00:13:15,770
know we should be processing and so we

00:13:13,340 --> 00:13:18,920
were we're getting down to the line

00:13:15,770 --> 00:13:21,290
eleven with a null pointer and one of

00:13:18,920 --> 00:13:22,760
the questions that came up when when we

00:13:21,290 --> 00:13:27,380
were looking at this was well lighted in

00:13:22,760 --> 00:13:31,460
that line twelve oops or never hit uh

00:13:27,380 --> 00:13:33,020
you know a null pointer there and so I

00:13:31,460 --> 00:13:34,810
had to write a little bit of a test code

00:13:33,020 --> 00:13:37,090
on this one and

00:13:34,810 --> 00:13:39,880
the prefetch macro and power is

00:13:37,090 --> 00:13:41,950
essentially just a data cache block

00:13:39,880 --> 00:13:44,620
touch command and so all that's

00:13:41,950 --> 00:13:48,750
happening on that and that line 12 is

00:13:44,620 --> 00:13:52,300
this taken the skb had us which is no

00:13:48,750 --> 00:13:54,460
adding the offset of end into that and

00:13:52,300 --> 00:13:57,190
then taking that the taking that as the

00:13:54,460 --> 00:13:59,980
address passing which is some you know

00:13:57,190 --> 00:14:02,560
integer value you know let's just say

00:13:59,980 --> 00:14:06,610
200 or something like that and passing

00:14:02,560 --> 00:14:08,890
that to prefetch well that that

00:14:06,610 --> 00:14:11,830
instruction is essentially just a it's

00:14:08,890 --> 00:14:13,650
just a hint to the processor that hey we

00:14:11,830 --> 00:14:15,670
might be pulling this cache line in

00:14:13,650 --> 00:14:16,830
perfectly valid to give it an invalid

00:14:15,670 --> 00:14:22,780
address and it just doesn't do anything

00:14:16,830 --> 00:14:27,340
and so the fix here was between lines 6

00:14:22,780 --> 00:14:29,920
and 7 to insert a SP read memory barrier

00:14:27,340 --> 00:14:32,230
and to make sure that we load the

00:14:29,920 --> 00:14:36,610
hardware consumer index before we start

00:14:32,230 --> 00:14:40,560
marching down and loading any you know

00:14:36,610 --> 00:14:40,560
the SK P pointer and and other things

00:14:43,020 --> 00:14:48,870
we're still trying to reproduce this one

00:14:44,700 --> 00:14:52,470
in our lab but but we did confirm that

00:14:48,870 --> 00:14:54,810
we were hitting this problem just left

00:14:52,470 --> 00:14:56,760
and right on this one machine and with

00:14:54,810 --> 00:15:00,390
the fix every thought the problems went

00:14:56,760 --> 00:15:18,390
away it was an interesting case the

00:15:00,390 --> 00:15:20,459
third so this is a third and final case

00:15:18,390 --> 00:15:23,520
that I'll describe this is one that we

00:15:20,459 --> 00:15:25,980
found early when we were bringing up

00:15:23,520 --> 00:15:27,930
power line and you know this is a device

00:15:25,980 --> 00:15:29,130
driver that we're used we used on power

00:15:27,930 --> 00:15:32,360
eight no problem

00:15:29,130 --> 00:15:35,279
power 9 it was just a aggressive enough

00:15:32,360 --> 00:15:38,580
that we we encountered it and it's

00:15:35,279 --> 00:15:40,860
somewhat similar on CPU one here we have

00:15:38,580 --> 00:15:43,620
sending it as once again transcending a

00:15:40,860 --> 00:15:48,180
transmit packet save away the skv

00:15:43,620 --> 00:15:52,020
pointer into our our buffer do a write

00:15:48,180 --> 00:15:54,899
memory barrier to ensure all their

00:15:52,020 --> 00:15:58,290
stores are coherent across until we get

00:15:54,899 --> 00:16:00,810
to five and then we do this this it's

00:15:58,290 --> 00:16:03,089
next to watch pointer which points to

00:16:00,810 --> 00:16:05,670
the essentially the next transmit

00:16:03,089 --> 00:16:07,500
descriptor to do process and then we

00:16:05,670 --> 00:16:10,140
bring the doorbell and what was

00:16:07,500 --> 00:16:13,200
happening on the right hand side was

00:16:10,140 --> 00:16:14,550
something somewhat similar the Intel

00:16:13,200 --> 00:16:16,649
driver had this read merit barrier

00:16:14,550 --> 00:16:19,399
depends and that's what they were going

00:16:16,649 --> 00:16:24,029
to they were trying to use that to

00:16:19,399 --> 00:16:26,850
ensure that the the load for that

00:16:24,029 --> 00:16:28,380
ELP descriptor happens you know loading

00:16:26,850 --> 00:16:32,570
from that next to watch happened before

00:16:28,380 --> 00:16:35,670
we went off and check the status fit but

00:16:32,570 --> 00:16:37,560
that is not sufficient on power that

00:16:35,670 --> 00:16:40,410
barrier does nothing on power it's a no

00:16:37,560 --> 00:16:42,430
op it does nothing on any architecture

00:16:40,410 --> 00:16:44,500
except for alpha

00:16:42,430 --> 00:16:48,310
and so we were what we ended up having

00:16:44,500 --> 00:16:51,220
and this one was we came down and it

00:16:48,310 --> 00:16:54,970
manifested itself as calling nappy

00:16:51,220 --> 00:16:56,770
consume skb on a stale SKB and so we

00:16:54,970 --> 00:16:59,760
were having random crashes we were

00:16:56,770 --> 00:17:03,690
having you know it was it looked like a

00:16:59,760 --> 00:17:06,250
you know an issue of you know we were

00:17:03,690 --> 00:17:08,830
blowing up in just very strange places

00:17:06,250 --> 00:17:12,700
and so we turned on you know memory

00:17:08,830 --> 00:17:15,160
debugging and you know found that we

00:17:12,700 --> 00:17:17,080
were indeed accessing memory that had

00:17:15,160 --> 00:17:20,050
already been freed and we you know

00:17:17,080 --> 00:17:21,910
narrowed it back to this this skb and we

00:17:20,050 --> 00:17:24,850
you know stared at the code for a while

00:17:21,910 --> 00:17:27,480
and came to the conclusion that we

00:17:24,850 --> 00:17:27,480
needed to bury her there

00:17:34,690 --> 00:17:41,330
static code analysis students I'm not

00:17:38,809 --> 00:17:46,090
aware of any static code analysis tools

00:17:41,330 --> 00:17:46,090
that exists today that would do this I

00:17:46,690 --> 00:17:52,220
don't know that it would necessarily be

00:17:48,950 --> 00:17:54,830
impossible but so for example you said

00:17:52,220 --> 00:17:58,309
you know the read variant that doesn't

00:17:54,830 --> 00:18:00,950
do anything on power so it's generally

00:17:58,309 --> 00:18:05,240
you know maybe through some tools we can

00:18:00,950 --> 00:18:07,520
inspect that and find that out I think

00:18:05,240 --> 00:18:09,740
the challenge would be for the static

00:18:07,520 --> 00:18:12,080
analysis tool to understand enough about

00:18:09,740 --> 00:18:15,260
the interactions with the hardware and

00:18:12,080 --> 00:18:18,710
what those different loads were doing to

00:18:15,260 --> 00:18:20,870
to be able to detect it not I'm not an

00:18:18,710 --> 00:18:22,370
expert on static analysis tools so I

00:18:20,870 --> 00:18:26,320
don't know how how difficult that would

00:18:22,370 --> 00:18:26,320
be to do but it's a good question oh

00:18:28,570 --> 00:18:33,089
yeah

00:18:29,970 --> 00:18:33,089
[Music]

00:18:33,980 --> 00:18:39,830
isolate the problem have you been using

00:18:36,180 --> 00:18:43,200
a caramel facilities for this or just

00:18:39,830 --> 00:18:44,730
printed up in kennel prints because I

00:18:43,200 --> 00:18:49,500
don't know if the print K is actually

00:18:44,730 --> 00:18:51,420
going to affect the yeah so we were very

00:18:49,500 --> 00:18:54,570
dependent on on getting a K down from

00:18:51,420 --> 00:18:57,690
this to actually do the deep analysis

00:18:54,570 --> 00:19:00,260
and understand that and then once we and

00:18:57,690 --> 00:19:02,310
like I said we also turned on some

00:19:00,260 --> 00:19:07,820
memory debugging in the kernel that

00:19:02,310 --> 00:19:07,820
would check for using using freed memory

00:19:10,910 --> 00:19:16,890
of course nuts gonna ask us in your

00:19:14,040 --> 00:19:21,170
experience what's more common a missing

00:19:16,890 --> 00:19:23,910
barrier or a barrier of the wrong type

00:19:21,170 --> 00:19:26,580
timing because the second one is they

00:19:23,910 --> 00:19:28,260
had they had the right idea right they

00:19:26,580 --> 00:19:30,690
just I would say it's the missing

00:19:28,260 --> 00:19:34,980
barrier that's okay that's usually the

00:19:30,690 --> 00:19:36,930
problem and of course this bug was not

00:19:34,980 --> 00:19:39,240
only in IX GB he was in every Intel

00:19:36,930 --> 00:19:41,250
driver that exists in the tree because

00:19:39,240 --> 00:19:43,080
they seem to copy take one copy it and

00:19:41,250 --> 00:19:45,290
copy the same bug and so we went and fix

00:19:43,080 --> 00:19:45,290
them all

00:19:46,920 --> 00:19:56,440
all right we're gonna lighten it up a

00:19:52,540 --> 00:19:58,390
little after diving in deep there I want

00:19:56,440 --> 00:20:03,490
to talk a little bit about pci address

00:19:58,390 --> 00:20:07,000
translation on on power we have you know

00:20:03,490 --> 00:20:09,940
in a KVM environment we used cc's so any

00:20:07,000 --> 00:20:13,510
PCI pass-through device SRV device it

00:20:09,940 --> 00:20:17,350
gets passed back to a guess the all the

00:20:13,510 --> 00:20:20,410
the DMA buffers that get mapped and used

00:20:17,350 --> 00:20:22,060
by that adapter have used these

00:20:20,410 --> 00:20:26,740
translation control entries and it's

00:20:22,060 --> 00:20:29,740
essentially just just a map that you

00:20:26,740 --> 00:20:31,810
know translates the you know the address

00:20:29,740 --> 00:20:33,790
that you can give on the PCI bus to a

00:20:31,810 --> 00:20:36,460
physical memory address and they have

00:20:33,790 --> 00:20:39,130
permissions associated with them whether

00:20:36,460 --> 00:20:44,140
that be read only write only or read

00:20:39,130 --> 00:20:45,850
write and we tend to now and again

00:20:44,140 --> 00:20:48,700
encounter especially usually when we're

00:20:45,850 --> 00:20:50,860
bringing up a new adapter device

00:20:48,700 --> 00:20:54,430
sometimes two devices will behave oddly

00:20:50,860 --> 00:20:57,010
because they'll go off and DM a read

00:20:54,430 --> 00:21:04,390
request for some random address you seen

00:20:57,010 --> 00:21:07,570
that happened before and so the IMU has

00:21:04,390 --> 00:21:10,300
different EC sizes it supports 4k is the

00:21:07,570 --> 00:21:11,620
default there's 64 K and then depending

00:21:10,300 --> 00:21:16,720
on the processor generation there's

00:21:11,620 --> 00:21:18,370
other sizes as well you know so there

00:21:16,720 --> 00:21:20,050
obviously with the TCS there's a certain

00:21:18,370 --> 00:21:21,870
overhead involved in mapping them and on

00:21:20,050 --> 00:21:27,240
mapping them and we try to mitigate that

00:21:21,870 --> 00:21:30,100
when we can so on a KTM PCI pass-through

00:21:27,240 --> 00:21:34,690
environment typically what we'll do is

00:21:30,100 --> 00:21:36,340
we'll take when the drivers sets its DMA

00:21:34,690 --> 00:21:40,450
mask to say how many bits of the address

00:21:36,340 --> 00:21:44,370
ability it has on the DMA bus if it

00:21:40,450 --> 00:21:47,350
supports 64-bit DMA will go off and

00:21:44,370 --> 00:21:50,740
basically try to allocate enough T C's

00:21:47,350 --> 00:21:52,750
for the entire VMs memory map them all

00:21:50,740 --> 00:21:54,960
and then we just do a simple lookup and

00:21:52,750 --> 00:21:57,450
don't have to do any H calls to to map

00:21:54,960 --> 00:22:02,429
now that improves performance quite a

00:21:57,450 --> 00:22:05,190
bit if the device doesn't have support

00:22:02,429 --> 00:22:08,940
for 64-bit TCS then we fall back to like

00:22:05,190 --> 00:22:12,870
a 32-bit the default 32-bit window and

00:22:08,940 --> 00:22:14,399
and we put some and I'll talk about it

00:22:12,870 --> 00:22:15,809
on the next chart a little bit and some

00:22:14,399 --> 00:22:19,020
of the hacks we put in for bare metal to

00:22:15,809 --> 00:22:21,860
try to make life a little better for the

00:22:19,020 --> 00:22:24,090
devices that don't support full 64-bit

00:22:21,860 --> 00:22:25,860
and then for the smaller DMA windows

00:22:24,090 --> 00:22:29,399
when we do have to do maps and on maps

00:22:25,860 --> 00:22:31,020
we've we've done we basically take taken

00:22:29,399 --> 00:22:34,020
the DMA window and then hashed it across

00:22:31,020 --> 00:22:36,809
the CPUs so that we don't have one lock

00:22:34,020 --> 00:22:38,039
that we're contending for when we do

00:22:36,809 --> 00:22:45,059
maps in the maps and we can do more in

00:22:38,039 --> 00:22:47,250
parallel for bare metal as long as the

00:22:45,059 --> 00:22:51,480
device is for 64-bit DMA we don't use TC

00:22:47,250 --> 00:22:54,630
so we will use what's called this no

00:22:51,480 --> 00:22:58,080
translate and direct addressing and

00:22:54,630 --> 00:22:59,850
bypassed the the TC e now however this

00:22:58,080 --> 00:23:05,279
doesn't mean that the DMA address equals

00:22:59,850 --> 00:23:07,080
the physical address but 59 is on but

00:23:05,279 --> 00:23:08,940
you basically you just you need to make

00:23:07,080 --> 00:23:10,559
sure that you're still using the you

00:23:08,940 --> 00:23:14,309
know the proper API is mapping and on

00:23:10,559 --> 00:23:15,779
mapping the DMA is you know this is also

00:23:14,309 --> 00:23:17,669
one of the things that we come in come

00:23:15,779 --> 00:23:20,730
across sometimes on bringing up new

00:23:17,669 --> 00:23:24,690
adapters they just have the assumption

00:23:20,730 --> 00:23:27,059
that hey I you know on Intel they

00:23:24,690 --> 00:23:31,320
typically start at address 0 and go up

00:23:27,059 --> 00:23:33,779
to how much memory they have and with us

00:23:31,320 --> 00:23:36,929
it's different in the fact that all our

00:23:33,779 --> 00:23:42,779
DMA addresses start with bit 59 on and

00:23:36,929 --> 00:23:46,110
higher at least in bare metal I power

00:23:42,779 --> 00:23:48,720
eight we put in some support for TCC

00:23:46,110 --> 00:23:53,669
bypass window and so if the device

00:23:48,720 --> 00:23:56,960
supports less than 64 bit DMA will

00:23:53,669 --> 00:24:00,919
essentially allocate some a big

00:23:56,960 --> 00:24:04,169
dma window with 256 Meg TCS and

00:24:00,919 --> 00:24:06,809
essentially allowed to address all

00:24:04,169 --> 00:24:10,250
assistant memory with that one window

00:24:06,809 --> 00:24:14,070
and it doesn't have to you know address

00:24:10,250 --> 00:24:15,510
you know the high bits of the DNA we're

00:24:14,070 --> 00:24:17,070
trying to implement something like that

00:24:15,510 --> 00:24:20,970
on power 9 but the architecture is

00:24:17,070 --> 00:24:23,190
different the PHP is different and so

00:24:20,970 --> 00:24:26,070
we're there's kind of a work in progress

00:24:23,190 --> 00:24:29,820
there it's looking like we might have a

00:24:26,070 --> 00:24:35,850
way to do up to if it device supports 48

00:24:29,820 --> 00:24:38,940
bits then we can do that but I put this

00:24:35,850 --> 00:24:40,500
in as an example just because I

00:24:38,940 --> 00:24:42,630
occasionally get asked questions about

00:24:40,500 --> 00:24:45,600
write combining if you you know if you

00:24:42,630 --> 00:24:46,950
have a big bar the Mellanox driver has a

00:24:45,600 --> 00:24:50,100
good I just pulled this out of the

00:24:46,950 --> 00:24:53,280
Mellanox Analects floor driver they've

00:24:50,100 --> 00:24:55,530
got a essentially a bar window a large

00:24:53,280 --> 00:24:57,600
bar window that they can use to send

00:24:55,530 --> 00:25:00,059
really small packets and so they'll just

00:24:57,600 --> 00:25:01,530
they'll send them with right combined mm

00:25:00,059 --> 00:25:03,750
IO rights rather than trying to do a

00:25:01,530 --> 00:25:07,799
whole handshake with a right a doorbell

00:25:03,750 --> 00:25:09,660
through the DMA and so if you want to do

00:25:07,799 --> 00:25:12,179
something like that this is you know a

00:25:09,660 --> 00:25:14,540
rough outline of the steps involved in

00:25:12,179 --> 00:25:14,540
doing them

00:25:16,620 --> 00:25:24,600
okay yeah eh so obviously this is a big

00:25:22,289 --> 00:25:26,850
platform difference with other

00:25:24,600 --> 00:25:30,779
architectures this is something that's

00:25:26,850 --> 00:25:35,549
unique to power there's a feature of the

00:25:30,779 --> 00:25:38,130
PCI controller you know if we hit a

00:25:35,549 --> 00:25:39,960
parry there or if we hit a you know DMA

00:25:38,130 --> 00:25:41,100
to anneal an invalid address or there's

00:25:39,960 --> 00:25:43,200
there's a lot of different errors that

00:25:41,100 --> 00:25:45,330
can cause in eeh and so when this

00:25:43,200 --> 00:25:48,450
happens the device goes into what's

00:25:45,330 --> 00:25:50,700
called a frozen state any writes just go

00:25:48,450 --> 00:25:54,029
to a bit bucket and he reads you get an

00:25:50,700 --> 00:25:57,510
all ones response in the note and dmas

00:25:54,029 --> 00:26:01,549
are essentially shut down there's code

00:25:57,510 --> 00:26:04,529
in the platform layer at the kernel to

00:26:01,549 --> 00:26:08,460
filter that that all ones load response

00:26:04,529 --> 00:26:09,870
and and then if it sees that it goes off

00:26:08,460 --> 00:26:12,090
makes another call to check well it's a

00:26:09,870 --> 00:26:17,610
slot and eeh and if it is then it'll go

00:26:12,090 --> 00:26:19,679
and kick off some eeh recovery and

00:26:17,610 --> 00:26:22,740
there's kind of two different paths that

00:26:19,679 --> 00:26:25,289
you can go down either either your

00:26:22,740 --> 00:26:28,169
driver is eeh aware or it's not and we

00:26:25,289 --> 00:26:29,909
try to recover in both scenarios so it's

00:26:28,169 --> 00:26:32,250
not aware this means that there's been

00:26:29,909 --> 00:26:35,010
no code written specific to each

00:26:32,250 --> 00:26:39,000
recovering the driver and we use

00:26:35,010 --> 00:26:41,909
simulate a hot plug event so we do a hot

00:26:39,000 --> 00:26:43,740
plug remove to detach the device recover

00:26:41,909 --> 00:26:48,059
the slot and then hot plug out the

00:26:43,740 --> 00:26:50,010
device back this works ok in some

00:26:48,059 --> 00:26:53,700
scenarios if it's an Ethernet drive or

00:26:50,010 --> 00:26:56,580
if it's a driver that you're not booting

00:26:53,700 --> 00:27:00,649
from maybe storage drivers don't really

00:26:56,580 --> 00:27:03,980
work too well with this recovery model

00:27:00,649 --> 00:27:06,950
then it can then it can pick and work

00:27:03,980 --> 00:27:09,540
there is

00:27:06,950 --> 00:27:11,700
we've we this is certainly in another

00:27:09,540 --> 00:27:15,480
area that we do find expose issues in

00:27:11,700 --> 00:27:17,430
device drivers as well some drivers try

00:27:15,480 --> 00:27:19,620
to hot-plug remove them and they can't

00:27:17,430 --> 00:27:21,660
talk to their adapter and get reasonable

00:27:19,620 --> 00:27:23,460
responses back because their rights are

00:27:21,660 --> 00:27:24,950
going into a bit bucket and their loads

00:27:23,460 --> 00:27:27,120
throughout coming back all ones

00:27:24,950 --> 00:27:32,580
sometimes they just blow up and it

00:27:27,120 --> 00:27:34,320
spectacular ways so the answer obviously

00:27:32,580 --> 00:27:37,170
is the other to fix those packs or to

00:27:34,320 --> 00:27:42,120
put any eh antlers and the ladder is

00:27:37,170 --> 00:27:45,060
preferred clearly so to implement eh

00:27:42,120 --> 00:27:48,000
recovery in a driver is not that much

00:27:45,060 --> 00:27:51,120
work there's essentially and the PCI

00:27:48,000 --> 00:27:52,830
driver struct there's a few handlers

00:27:51,120 --> 00:27:58,200
that you a few function pointers that

00:27:52,830 --> 00:28:00,600
you can implement to allow your driver

00:27:58,200 --> 00:28:03,390
to participate in the EH recovery

00:28:00,600 --> 00:28:05,250
process the first one gets called error

00:28:03,390 --> 00:28:09,030
detected gets called when an eh gets

00:28:05,250 --> 00:28:12,000
detected and and then the driver can

00:28:09,030 --> 00:28:13,680
influence whether what happens as part

00:28:12,000 --> 00:28:16,800
of the rest of with the recovery whether

00:28:13,680 --> 00:28:18,660
it needs the reset to recover or no it

00:28:16,800 --> 00:28:20,880
was able to recover it all on its own or

00:28:18,660 --> 00:28:24,120
whether it's just you know it doesn't

00:28:20,880 --> 00:28:27,960
think it can recover at all there's an

00:28:24,120 --> 00:28:31,050
optional mm i/o enabled one so not many

00:28:27,960 --> 00:28:33,720
drivers use this if you want to try to

00:28:31,050 --> 00:28:36,030
extract failure data out of your device

00:28:33,720 --> 00:28:41,310
you know when it's before it's been

00:28:36,030 --> 00:28:44,130
reset and cleaned up the eh driver will

00:28:41,310 --> 00:28:46,130
read reenable MMI OS so you can go and

00:28:44,130 --> 00:28:50,700
try to pull some of that information out

00:28:46,130 --> 00:28:52,740
and that's that's called next and then

00:28:50,700 --> 00:28:56,070
the slot reset one gets called after the

00:28:52,740 --> 00:28:59,490
eh recovery has completed but prior to

00:28:56,070 --> 00:29:01,950
resuming normal operations so you know

00:28:59,490 --> 00:29:03,900
typically the air detected and this lot

00:29:01,950 --> 00:29:06,200
reset are the ones that you know

00:29:03,900 --> 00:29:09,020
typically get it implemented the most

00:29:06,200 --> 00:29:12,060
and then the resume gets called after

00:29:09,020 --> 00:29:13,940
your recovery is all done and everything

00:29:12,060 --> 00:29:18,700
is back and you know

00:29:13,940 --> 00:29:18,700
and Anaya was able to get sent again

00:29:21,050 --> 00:29:31,730
impressive yeah do we have or do we

00:29:28,130 --> 00:29:34,670
publish a template for or best practices

00:29:31,730 --> 00:29:37,070
for what these various routines would do

00:29:34,670 --> 00:29:39,470
or are there drivers we can point to

00:29:37,070 --> 00:29:42,590
that say you know do the right thing or

00:29:39,470 --> 00:29:45,350
nice in this area which seemed like this

00:29:42,590 --> 00:29:50,870
might smack for at least some starting

00:29:45,350 --> 00:29:52,810
code in an area yeah so there's in the

00:29:50,870 --> 00:29:57,260
references section of the presentation

00:29:52,810 --> 00:29:59,240
there's a link a couple links on one of

00:29:57,260 --> 00:30:01,400
them is there's couple in the kernel

00:29:59,240 --> 00:30:03,380
documentation or they go into quite a

00:30:01,400 --> 00:30:05,690
bit of even more detail about all the

00:30:03,380 --> 00:30:08,480
API is how they get used and when they

00:30:05,690 --> 00:30:09,710
get used and what you know how do what

00:30:08,480 --> 00:30:17,800
to do with them how to implement them

00:30:09,710 --> 00:30:20,960
cool thanks a little bit about reset so

00:30:17,800 --> 00:30:23,780
the eh recovery code uses hot reset to

00:30:20,960 --> 00:30:26,840
recover the slot there are some devices

00:30:23,780 --> 00:30:29,900
that doesn't always work for one reason

00:30:26,840 --> 00:30:31,730
or another and if your device is one of

00:30:29,900 --> 00:30:33,620
those there's a workaround that was put

00:30:31,730 --> 00:30:35,710
into place there's a flag that you can

00:30:33,620 --> 00:30:37,640
set in your in the PCI device structure

00:30:35,710 --> 00:30:42,410
and to say that you need a fundamental

00:30:37,640 --> 00:30:47,810
reset in order to recover and so if if

00:30:42,410 --> 00:30:50,030
any devices within a pH B that encounter

00:30:47,810 --> 00:30:51,680
any eh have that flag set then that

00:30:50,030 --> 00:30:56,000
whole PHP gets up on and that'll reset

00:30:51,680 --> 00:30:58,160
it's part of recovery and then I put a

00:30:56,000 --> 00:31:00,110
couple more tips in here if you ever

00:30:58,160 --> 00:31:02,780
want to disable eeh for some reason that

00:31:00,110 --> 00:31:05,030
can be done through debug FS

00:31:02,780 --> 00:31:09,430
if you disable it what happens is

00:31:05,030 --> 00:31:11,960
essentially the card goes into eeh state

00:31:09,430 --> 00:31:13,430
it's just not going to come out you're

00:31:11,960 --> 00:31:15,850
just gonna be stuck with that slot

00:31:13,430 --> 00:31:15,850
frozen

00:31:16,920 --> 00:31:21,580
but if it's choosing between that or

00:31:19,480 --> 00:31:28,120
your driver blowing up then maybe that's

00:31:21,580 --> 00:31:31,780
okay option two other comments any eh

00:31:28,120 --> 00:31:33,550
one if you want to inject two actually

00:31:31,780 --> 00:31:35,710
if you implement this you want to test

00:31:33,550 --> 00:31:41,770
this this is how you test it it's in

00:31:35,710 --> 00:31:44,140
debug FS there's there's more details on

00:31:41,770 --> 00:31:46,210
this also in the kernel tree and the

00:31:44,140 --> 00:31:47,950
kernel kernel source tree which I have a

00:31:46,210 --> 00:31:50,980
link to later in the presentation but

00:31:47,950 --> 00:31:53,350
this is you know at a high level there's

00:31:50,980 --> 00:31:57,460
you know Sisyphus parameters that you

00:31:53,350 --> 00:31:59,890
just toggle the air inject bit and

00:31:57,460 --> 00:32:01,960
toggle it off and there's different

00:31:59,890 --> 00:32:05,860
flavors of air inject that you can

00:32:01,960 --> 00:32:09,090
actually do whether that be you know

00:32:05,860 --> 00:32:13,870
there's different causes for eh

00:32:09,090 --> 00:32:15,790
generally speaking this is you know this

00:32:13,870 --> 00:32:20,110
is sufficient to validate most device

00:32:15,790 --> 00:32:22,090
drivers and then we do have recovery

00:32:20,110 --> 00:32:23,710
limits associated with eeh if you hit

00:32:22,090 --> 00:32:26,230
five in an hour we disable the device

00:32:23,710 --> 00:32:28,960
and don't and it doesn't come back so if

00:32:26,230 --> 00:32:32,890
you're testing eeh you can work around

00:32:28,960 --> 00:32:35,190
that by increasing not Indy back debug

00:32:32,890 --> 00:32:35,190
have us

00:32:37,910 --> 00:32:40,480
all right

00:32:41,100 --> 00:32:43,960
mostly probably know most of this

00:32:42,910 --> 00:32:46,000
already

00:32:43,960 --> 00:32:48,640
in paddy boot actually there's a little

00:32:46,000 --> 00:32:53,230
bit with Linux kernel booting there does

00:32:48,640 --> 00:32:56,830
auto detection of the boot devices for

00:32:53,230 --> 00:32:58,870
IO devices if they have specific tools

00:32:56,830 --> 00:33:00,940
for managing them if they're open source

00:32:58,870 --> 00:33:04,960
and they're sufficiently small we can

00:33:00,940 --> 00:33:06,580
pull those into the petty boot image and

00:33:04,960 --> 00:33:09,250
so they're just available there you can

00:33:06,580 --> 00:33:12,250
exit to a rescue shell and access them

00:33:09,250 --> 00:33:15,220
we did that with the IPR RAID controller

00:33:12,250 --> 00:33:17,560
for example and you know and we have

00:33:15,220 --> 00:33:20,830
other tools in there too so and then

00:33:17,560 --> 00:33:22,270
there's the plug-in architecture if you

00:33:20,830 --> 00:33:25,960
have a tool that doesn't meet those

00:33:22,270 --> 00:33:28,480
those scenarios but you wanted easily

00:33:25,960 --> 00:33:31,660
consumable I put a link down there at

00:33:28,480 --> 00:33:33,190
the bottom for how to port create a plot

00:33:31,660 --> 00:33:37,060
using the plug-in architecture and port

00:33:33,190 --> 00:33:38,920
your tool to that and that just makes it

00:33:37,060 --> 00:33:41,590
just easy to to kind of pull the tool

00:33:38,920 --> 00:33:45,250
and use it in the rescue image before

00:33:41,590 --> 00:33:48,640
you boot your system and there's that

00:33:45,250 --> 00:33:50,980
even which I'm sure you've all seen so

00:33:48,640 --> 00:33:53,590
one of the key things that affects

00:33:50,980 --> 00:33:55,690
drivers as part of this whole boot

00:33:53,590 --> 00:33:58,570
process which is different than x86 is

00:33:55,690 --> 00:34:02,080
we are heavily reliant on K exact which

00:33:58,570 --> 00:34:04,120
is a kernel feature that allows you to

00:34:02,080 --> 00:34:07,780
have a one running kernel here load

00:34:04,120 --> 00:34:09,820
another one in memory and essentially

00:34:07,780 --> 00:34:11,950
simulate a shutdown on the old kernel

00:34:09,820 --> 00:34:16,420
and jump to the new kernel in memory

00:34:11,950 --> 00:34:20,290
with no no real hard resets or anything

00:34:16,420 --> 00:34:23,710
going on so to a device driver not all

00:34:20,290 --> 00:34:26,220
of them are all that they're not used to

00:34:23,710 --> 00:34:28,950
handling that transition all the time

00:34:26,220 --> 00:34:30,870
because there's no PCI device reset and

00:34:28,950 --> 00:34:33,570
so

00:34:30,870 --> 00:34:36,560
bringing up new devices in in that sort

00:34:33,570 --> 00:34:39,330
of environment this is something that

00:34:36,560 --> 00:34:42,090
you know devices typically need testing

00:34:39,330 --> 00:34:43,679
on and hardening yen and this isn't

00:34:42,090 --> 00:34:46,050
power specific this is a feature that

00:34:43,679 --> 00:34:47,909
exists in the existing Linux kernel you

00:34:46,050 --> 00:34:49,560
can run it on x86 you can find all these

00:34:47,909 --> 00:34:52,530
same bugs there it's just that it

00:34:49,560 --> 00:35:00,180
doesn't necessarily get tons of testing

00:34:52,530 --> 00:35:03,870
on x86 you know in this like within a

00:35:00,180 --> 00:35:06,570
shutdown path you know if you are trying

00:35:03,870 --> 00:35:09,540
to get a driver working well in this

00:35:06,570 --> 00:35:12,420
environment you know and some drivers

00:35:09,540 --> 00:35:16,190
we've tried to optimize it so that it's

00:35:12,420 --> 00:35:19,230
aware of this whole flow and so it's

00:35:16,190 --> 00:35:21,510
because the the more heavyweight that

00:35:19,230 --> 00:35:23,850
shutdown is in the K exec the more it's

00:35:21,510 --> 00:35:25,650
gonna slow down the whole boot you know

00:35:23,850 --> 00:35:27,450
if you're if you're aware of that

00:35:25,650 --> 00:35:29,340
transition you can just kind of pause

00:35:27,450 --> 00:35:33,840
the adapter and bring it back to life on

00:35:29,340 --> 00:35:37,920
the other side but this needs more

00:35:33,840 --> 00:35:42,360
testing across the board which leads me

00:35:37,920 --> 00:35:43,830
into my next topic tests so some of the

00:35:42,360 --> 00:35:45,270
areas these are some of the just I just

00:35:43,830 --> 00:35:48,110
tried to list out some of the areas that

00:35:45,270 --> 00:35:51,330
we see problems in on a regular basis

00:35:48,110 --> 00:35:53,070
with IO drivers on power ok exactly we

00:35:51,330 --> 00:35:59,910
already talked about kdump is another

00:35:53,070 --> 00:36:02,690
one eth is another one which we already

00:35:59,910 --> 00:36:06,360
went through pci hot plug add and remove

00:36:02,690 --> 00:36:08,790
surprisingly we still see issues in this

00:36:06,360 --> 00:36:13,620
area I think we just exercise it more

00:36:08,790 --> 00:36:16,500
than others do on other platforms CPU

00:36:13,620 --> 00:36:20,070
online offline I think that our biggest

00:36:16,500 --> 00:36:22,530
pain here has just been in in Linux

00:36:20,070 --> 00:36:23,970
block mq they've with envy the nvme

00:36:22,530 --> 00:36:25,710
driver and they have all these threads

00:36:23,970 --> 00:36:28,450
and all these interrupts and you start

00:36:25,710 --> 00:36:32,109
off lining CPUs and the

00:36:28,450 --> 00:36:34,119
start moving things around and you know

00:36:32,109 --> 00:36:37,359
and a lot of that code is just under

00:36:34,119 --> 00:36:40,210
such heavy development it's it's been a

00:36:37,359 --> 00:36:43,539
little bit of a problematic area the

00:36:40,210 --> 00:36:45,789
community is definitely well aware of it

00:36:43,539 --> 00:36:49,920
there's patches that go in all the time

00:36:45,789 --> 00:36:49,920
hardening this and trying to optimize it

00:36:50,099 --> 00:36:55,710
KVM direct IO assignments this is your

00:36:52,750 --> 00:36:58,390
PCI pass through in a KVM environment

00:36:55,710 --> 00:37:00,039
functional reset is really highly

00:36:58,390 --> 00:37:02,170
desirable if you're gonna if you want a

00:37:00,039 --> 00:37:06,640
device that's well supported in this

00:37:02,170 --> 00:37:08,920
sort of environment if you and please

00:37:06,640 --> 00:37:10,480
don't make a device that's advertised as

00:37:08,920 --> 00:37:11,920
support for functional level reset but

00:37:10,480 --> 00:37:14,740
actually doesn't do the right thing when

00:37:11,920 --> 00:37:19,349
you do it that's probably the worst of

00:37:14,740 --> 00:37:21,579
all scenarios and we see it too often

00:37:19,349 --> 00:37:23,529
the stress testing with data integrity

00:37:21,579 --> 00:37:26,289
checking and then you know just

00:37:23,529 --> 00:37:29,230
continues upstream testing that's

00:37:26,289 --> 00:37:32,440
something that we need to figure out a

00:37:29,230 --> 00:37:35,470
better way to do that as a as a you know

00:37:32,440 --> 00:37:37,180
open power ecosystem once we have a

00:37:35,470 --> 00:37:38,500
driver working on power how do we make

00:37:37,180 --> 00:37:42,670
sure it stays working on power and

00:37:38,500 --> 00:37:45,069
doesn't regress all right I got two more

00:37:42,670 --> 00:37:46,599
charts and then we'll open it up to

00:37:45,069 --> 00:37:48,220
questions so one is open power already

00:37:46,599 --> 00:37:50,740
there's a whole nother session on that

00:37:48,220 --> 00:37:52,930
earlier I just wanted to put a couple

00:37:50,740 --> 00:37:54,430
links on here we got about 82 i/o

00:37:52,930 --> 00:37:57,670
devices that are open power already

00:37:54,430 --> 00:38:00,039
today and there's the link if you want

00:37:57,670 --> 00:38:01,269
to resource catalogs on the bottom if

00:38:00,039 --> 00:38:03,279
you want to look to see what those

00:38:01,269 --> 00:38:04,720
devices are and if you've got a new

00:38:03,279 --> 00:38:07,500
device to try to get through the process

00:38:04,720 --> 00:38:07,500
there's the link there

00:38:09,270 --> 00:38:13,310
and then I just wanted to have a

00:38:10,830 --> 00:38:16,650
shout-out to that the eyewear group I

00:38:13,310 --> 00:38:17,970
just put the Charter in here along with

00:38:16,650 --> 00:38:21,240
the link to the work group and a link to

00:38:17,970 --> 00:38:24,690
join the work group if you're interested

00:38:21,240 --> 00:38:27,920
in enabling IO devices on power or any

00:38:24,690 --> 00:38:31,950
of these topics encourage you to to join

00:38:27,920 --> 00:38:36,330
we meet monthly and and talk through all

00:38:31,950 --> 00:38:39,540
these sorts of issues so and then this

00:38:36,330 --> 00:38:44,700
is the all the links that I collected as

00:38:39,540 --> 00:38:46,020
well so that might be want to see if

00:38:44,700 --> 00:38:49,350
there's any questions but I do have one

00:38:46,020 --> 00:38:52,020
for you I didn't see page sighs yeah has

00:38:49,350 --> 00:38:56,040
a and that's a good one listed item on

00:38:52,020 --> 00:38:59,310
your list yes yes we're different we are

00:38:56,040 --> 00:39:01,770
does that filter into drivers it does

00:38:59,310 --> 00:39:04,230
filter into drivers on occasion you know

00:39:01,770 --> 00:39:07,380
our base page size 64k as a ports to 4k

00:39:04,230 --> 00:39:11,700
there's often times device drivers that

00:39:07,380 --> 00:39:13,140
make bad assumptions there's one Intel

00:39:11,700 --> 00:39:15,690
Ethernet driver I can think of that

00:39:13,140 --> 00:39:17,970
allocates way more memory than it should

00:39:15,690 --> 00:39:24,330
because it's allocating a page for each

00:39:17,970 --> 00:39:27,109
skb and that's a lot of memory okay any

00:39:24,330 --> 00:39:27,109
other questions for Brian

00:39:28,309 --> 00:39:33,690
every month I would like to ask you

00:39:30,960 --> 00:39:37,440
something regarding AVM will they use

00:39:33,690 --> 00:39:39,270
the memory so imagine in the context of

00:39:37,440 --> 00:39:42,869
open copy for instance now what we're

00:39:39,270 --> 00:39:45,210
doing we need to create memory address

00:39:42,869 --> 00:39:47,099
range physical address range then create

00:39:45,210 --> 00:39:49,799
pages on top of that using a lipophilic

00:39:47,099 --> 00:39:50,460
cell and then we create a memory back

00:39:49,799 --> 00:39:53,910
continuum

00:39:50,460 --> 00:39:57,059
passing a pointer to KVM to actually map

00:39:53,910 --> 00:39:59,039
this memory as normal as the memory and

00:39:57,059 --> 00:40:01,559
they gave him not well it was

00:39:59,039 --> 00:40:03,329
investigating what happens but kayvyun

00:40:01,559 --> 00:40:06,510
doesn't like that empower who have done

00:40:03,329 --> 00:40:09,380
to learn if it works and it considers I

00:40:06,510 --> 00:40:12,119
think that the memory has device memory

00:40:09,380 --> 00:40:20,039
is that I mean we have any idea and

00:40:12,119 --> 00:40:23,990
insight or should be looking let me take

00:40:20,039 --> 00:40:23,990
your name and I will connect you with

00:40:24,380 --> 00:40:41,670
Thanks so the question is I was trying

00:40:37,589 --> 00:40:44,279
to do some like K exact inceptions

00:40:41,670 --> 00:40:46,230
K exactly after K exact yeah and every

00:40:44,279 --> 00:40:48,900
time either like the first case that

00:40:46,230 --> 00:40:53,430
happens after PT boot and after I do

00:40:48,900 --> 00:40:57,480
next one the use be free like X HCI

00:40:53,430 --> 00:40:59,460
driver always falls apart any pointers

00:40:57,480 --> 00:41:00,180
hard to start debugging it just like

00:40:59,460 --> 00:41:03,000
where the luke

00:41:00,180 --> 00:41:07,109
key words anything it happens all the

00:41:03,000 --> 00:41:09,930
time the kernel is like 5.22 like recent

00:41:07,109 --> 00:41:12,329
one right so there's there's there's

00:41:09,930 --> 00:41:14,220
clearly something in the heavy boot

00:41:12,329 --> 00:41:16,049
kernel that's not in the kernel your

00:41:14,220 --> 00:41:19,289
booting or a difference there right

00:41:16,049 --> 00:41:20,109
because the petty boot boot works but

00:41:19,289 --> 00:41:22,089
then

00:41:20,109 --> 00:41:24,880
that following that does not work yeah

00:41:22,089 --> 00:41:28,059
it works it's easy use be do Isis the

00:41:24,880 --> 00:41:29,680
colonel that it boots also works but if

00:41:28,059 --> 00:41:31,749
I put the same Colonel I would it once

00:41:29,680 --> 00:41:33,969
more fruit K exact like for five

00:41:31,749 --> 00:41:37,299
straight boots no longer works right so

00:41:33,969 --> 00:41:40,509
it all right so if I play the back the

00:41:37,299 --> 00:41:42,430
booting from petty boot to the five Oh

00:41:40,509 --> 00:41:44,019
Colonel works the five uh colonel to the

00:41:42,430 --> 00:41:47,289
five Oh colonel does not work right yes

00:41:44,019 --> 00:41:50,769
so that there's food works just that use

00:41:47,289 --> 00:41:55,809
be free driver just blows up right right

00:41:50,769 --> 00:41:58,619
so it's likely in the shutdown path of

00:41:55,809 --> 00:42:03,729
the XX HCI

00:41:58,619 --> 00:42:07,539
host controller be my guess and so if

00:42:03,729 --> 00:42:09,009
you can compare you know that shutdown

00:42:07,539 --> 00:42:12,160
path with a shutdown Pat the five Oh

00:42:09,009 --> 00:42:14,079
Colonel you know there's there's likely

00:42:12,160 --> 00:42:17,349
some some difference there that that's

00:42:14,079 --> 00:42:20,549
you're tripping out over thank you

00:42:17,349 --> 00:42:24,069
that's a good pointer and another one

00:42:20,549 --> 00:42:27,699
yeah my use case may sound strange to

00:42:24,069 --> 00:42:30,430
you because I use like open power as a

00:42:27,699 --> 00:42:33,940
workstation as a development fund so

00:42:30,430 --> 00:42:35,079
it's like my desktop I was trying to get

00:42:33,940 --> 00:42:38,800
some sound on it

00:42:35,079 --> 00:42:40,010
it was emote NK one card and basically

00:42:38,800 --> 00:42:43,130
[Music]

00:42:40,010 --> 00:42:45,740
mm now requires some certain kernel

00:42:43,130 --> 00:42:49,400
options I couldn't enable on

00:42:45,740 --> 00:42:51,920
little-endian 64-bit kernel it refers to

00:42:49,400 --> 00:42:53,540
one thing I don't really understand what

00:42:51,920 --> 00:42:58,760
it is maybe you can shed some light it's

00:42:53,540 --> 00:43:01,190
called zone underscore DMA it's it's to

00:42:58,760 --> 00:43:03,950
enable this it you have to configure a

00:43:01,190 --> 00:43:06,859
kernel for like small books or like

00:43:03,950 --> 00:43:10,600
embedded processors and I think it has

00:43:06,859 --> 00:43:13,520
to be big big engine pretty much okay

00:43:10,600 --> 00:43:18,740
what's the behavior when the when the

00:43:13,520 --> 00:43:21,770
driver loads on recent kernel you can

00:43:18,740 --> 00:43:26,390
even select it in many you config

00:43:21,770 --> 00:43:28,820
but unlike 4.14 kernel he just could

00:43:26,390 --> 00:43:31,460
cannot talk to device it's a old device

00:43:28,820 --> 00:43:33,920
whole chip from early two-thousands and

00:43:31,460 --> 00:43:42,290
I think it has 31 bit DMA something like

00:43:33,920 --> 00:43:45,020
that so the real question is what is on

00:43:42,290 --> 00:43:48,740
DMA if you can like explain like I'm

00:43:45,020 --> 00:43:51,710
five sounds like two emails so yeah so

00:43:48,740 --> 00:43:53,390
there there should be no zone DMA I mean

00:43:51,710 --> 00:43:55,130
that's kind of a legacy thing for for

00:43:53,390 --> 00:43:56,630
x86 with you know when there's DMA

00:43:55,130 --> 00:43:59,030
restrictions so they're not on a power

00:43:56,630 --> 00:44:03,560
box all the memories DMA of all there is

00:43:59,030 --> 00:44:05,480
no unique sort of zone DMA so we have to

00:44:03,560 --> 00:44:08,270
dig in a little bit more to understand

00:44:05,480 --> 00:44:10,190
what what you're running into you know

00:44:08,270 --> 00:44:11,780
one of the things that this is this is

00:44:10,190 --> 00:44:13,400
an old adapter this isn't probably the

00:44:11,780 --> 00:44:18,290
case but another thing that we tend to

00:44:13,400 --> 00:44:20,000
run into we've hit on a couple of we ran

00:44:18,290 --> 00:44:23,480
into on some graphics adapters some of

00:44:20,000 --> 00:44:26,420
the AMD ones they support up to 40 odd

00:44:23,480 --> 00:44:28,130
bytes of DMA and also on the same thing

00:44:26,420 --> 00:44:30,320
on the audio function and that also

00:44:28,130 --> 00:44:32,670
applies to their MSI factors for

00:44:30,320 --> 00:44:36,239
interrupts and so

00:44:32,670 --> 00:44:38,219
there are some workarounds that are put

00:44:36,239 --> 00:44:42,179
in place in the kernel to to handle that

00:44:38,219 --> 00:44:43,019
too but I don't think that's I think if

00:44:42,179 --> 00:44:45,199
you're hitting nap you would have

00:44:43,019 --> 00:44:48,509
probably your kernel would have crashed

00:44:45,199 --> 00:44:57,839
but so I think we need yeah I'll take

00:44:48,509 --> 00:45:01,049
your name sorry I'm just started doing

00:44:57,839 --> 00:45:05,099
this the person who probably can shed

00:45:01,049 --> 00:45:08,880
some light on it so on the i/o side of

00:45:05,099 --> 00:45:11,309
things like connectivity USB 3.1 is

00:45:08,880 --> 00:45:13,829
non-existent currently on power for us

00:45:11,309 --> 00:45:17,699
because pretty much all the controllers

00:45:13,829 --> 00:45:19,949
based on that s media chipset and it

00:45:17,699 --> 00:45:22,769
always gets shut down because of its

00:45:19,949 --> 00:45:26,819
like errant DMA access trying to do this

00:45:22,769 --> 00:45:29,759
it just kept taking off the system are

00:45:26,819 --> 00:45:34,799
any workarounds even possible or it just

00:45:29,759 --> 00:45:38,400
like broken by design so I don't know

00:45:34,799 --> 00:45:40,289
that we yeah I don't know that it would

00:45:38,400 --> 00:45:43,859
go so far to say broken by design I

00:45:40,289 --> 00:45:46,259
would say that you probably at the

00:45:43,859 --> 00:45:48,809
forefront of trying to get USB 3.1

00:45:46,259 --> 00:45:51,900
working on power it's not something that

00:45:48,809 --> 00:45:55,799
you know that my team or anything is

00:45:51,900 --> 00:46:00,599
really trying to do so but Brian we do

00:45:55,799 --> 00:46:05,069
know the Red Hat USB maintainer a former

00:46:00,599 --> 00:46:07,859
IBM now recovering as she's come back

00:46:05,069 --> 00:46:10,019
into IBM so we may be able to get some

00:46:07,859 --> 00:46:11,189
help on this sort of problem so once you

00:46:10,019 --> 00:46:14,929
get his email address we should probably

00:46:11,189 --> 00:46:14,929
talk to Tourette's and see yeah

00:46:18,170 --> 00:46:23,990
thank you for your support all right any

00:46:22,220 --> 00:46:25,519
other questions for Brian if not I think

00:46:23,990 --> 00:46:28,930
we've run over a little bit thank you

00:46:25,519 --> 00:46:28,930

YouTube URL: https://www.youtube.com/watch?v=-r0E5ssQc8w


