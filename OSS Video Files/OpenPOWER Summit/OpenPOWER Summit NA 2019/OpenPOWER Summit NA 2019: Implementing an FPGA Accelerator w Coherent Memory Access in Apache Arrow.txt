Title: OpenPOWER Summit NA 2019: Implementing an FPGA Accelerator w Coherent Memory Access in Apache Arrow
Publication date: 2019-08-20
Playlist: OpenPOWER Summit NA 2019
Description: 
	Presented by Noushin Azami, Texas State University

We aim to implement a fully homomorphic encryption algorithm using an FPGA accelerator in a way that eliminates the overhead produced by the device driver and memory format transitions. Fletcher is a framework that integrates FPGA accelerators with Apache Arrow, an in-memory format that reduces overhead when transferring data between platforms by creating tabular memory blocks.

Fletcher is programmed to function on top of IBMâ€™s CAPI SNAP which eliminates the need for a device driver in an FPGA accelerator, reducing the overhead of exchanging data between FPGA and CPU and giving the FPGA coherent access to data in the main memory.
Captions: 
	00:00:00,060 --> 00:00:03,350
hello everyone sorry for the technical

00:00:01,860 --> 00:00:06,359
difficulties

00:00:03,350 --> 00:00:08,400
my name is Nisha Nozomi

00:00:06,359 --> 00:00:09,929
today I'm gonna talk about this project

00:00:08,400 --> 00:00:11,340
that we started working on a few months

00:00:09,929 --> 00:00:13,559
back

00:00:11,340 --> 00:00:15,900
it's a new implementation of home Orphic

00:00:13,559 --> 00:00:19,560
encryption using capi Apache Aero and

00:00:15,900 --> 00:00:22,500
Fletcher so feel free to ask any

00:00:19,560 --> 00:00:25,470
questions during this presentation I'll

00:00:22,500 --> 00:00:29,580
take any questions and a lot about me

00:00:25,470 --> 00:00:31,500
that I'm starting my PhD in computer

00:00:29,580 --> 00:00:34,290
science at Texas State University in a

00:00:31,500 --> 00:00:36,149
week I graduated if we could go for my

00:00:34,290 --> 00:00:39,719
master's in electrical engineering again

00:00:36,149 --> 00:00:42,510
at Texas State I finished my bachelor's

00:00:39,719 --> 00:00:44,520
in computer engineering in Iran and you

00:00:42,510 --> 00:00:51,180
can find all sorts of information about

00:00:44,520 --> 00:00:53,640
me on my LinkedIn page so the list of

00:00:51,180 --> 00:00:56,070
collaborators for this project my

00:00:53,640 --> 00:00:58,770
advisor dr. upon Qasim at Texas State is

00:00:56,070 --> 00:01:00,690
dr. Peter Hoff see here at IBM and

00:00:58,770 --> 00:01:06,170
Geoffrey Killington which probably knows

00:01:00,690 --> 00:01:06,170
so you know as JT at IBM

00:01:07,049 --> 00:01:11,010
a little bit of introduction we know

00:01:09,030 --> 00:01:14,010
there is more data every every way every

00:01:11,010 --> 00:01:16,080
day and so data servers need more

00:01:14,010 --> 00:01:18,509
processing powers so we know that a lot

00:01:16,080 --> 00:01:21,689
of proper ation and processing on data

00:01:18,509 --> 00:01:24,150
is not being done locally no and being

00:01:21,689 --> 00:01:26,939
done on servers so there are people

00:01:24,150 --> 00:01:28,740
clients who are giving out their data to

00:01:26,939 --> 00:01:32,070
the servers and they need to trust in

00:01:28,740 --> 00:01:34,170
the system and there is there is a need

00:01:32,070 --> 00:01:36,420
for some kind of security that they can

00:01:34,170 --> 00:01:40,200
trust in their servers having their data

00:01:36,420 --> 00:01:44,460
and that a solution in that area would

00:01:40,200 --> 00:01:46,380
be a home Orphic encryption so how a

00:01:44,460 --> 00:01:48,659
morphic encryption is basically the

00:01:46,380 --> 00:01:51,810
ability to perform operations on

00:01:48,659 --> 00:01:54,990
encrypted data without having the key to

00:01:51,810 --> 00:01:58,950
decrypt it which is like a client there

00:01:54,990 --> 00:02:02,340
is a client holding an input X and she

00:01:58,950 --> 00:02:03,930
wants the value of FX from a server but

00:02:02,340 --> 00:02:06,930
doesn't want the server to know what X

00:02:03,930 --> 00:02:10,259
is an example in cloud computing would

00:02:06,930 --> 00:02:13,440
be a driver wanting to find directions

00:02:10,259 --> 00:02:14,220
without giving out her location and the

00:02:13,440 --> 00:02:18,230
location would be

00:02:14,220 --> 00:02:20,670
input that is important for the

00:02:18,230 --> 00:02:23,180
important for the client not to give out

00:02:20,670 --> 00:02:26,760
to the server

00:02:23,180 --> 00:02:28,800
there have been solutions proposed over

00:02:26,760 --> 00:02:31,800
the past 40 years under different names

00:02:28,800 --> 00:02:34,850
like computing unencrypted data privacy

00:02:31,800 --> 00:02:40,410
homomorphism and homomorphic encryption

00:02:34,850 --> 00:02:41,970
so here is the simplest way to talk

00:02:40,410 --> 00:02:45,090
about the main idea of home Orphic

00:02:41,970 --> 00:02:46,740
encryption there is a function f in that

00:02:45,090 --> 00:02:49,800
example that would be finding the

00:02:46,740 --> 00:02:52,560
directions to somewhere and there is the

00:02:49,800 --> 00:02:55,110
input X and in the past example that

00:02:52,560 --> 00:02:57,660
will be the drivers location and there

00:02:55,110 --> 00:03:00,390
is a cipher text which will call C from

00:02:57,660 --> 00:03:02,970
now on it is an encryption of the

00:03:00,390 --> 00:03:08,190
drivers location isn't an encryption of

00:03:02,970 --> 00:03:11,220
your input so if you look at this table

00:03:08,190 --> 00:03:13,070
you'll see you'll get some kind of an

00:03:11,220 --> 00:03:15,060
idea about homomorphic encryption

00:03:13,070 --> 00:03:18,420
there's a client side and the server

00:03:15,060 --> 00:03:22,310
side again the client knows the input X

00:03:18,420 --> 00:03:25,860
knows knows what F is the function and

00:03:22,310 --> 00:03:28,440
doesn't want to reveal X and doesn't

00:03:25,860 --> 00:03:30,650
want to know the details of F but wants

00:03:28,440 --> 00:03:34,650
to know what F X is which is our output

00:03:30,650 --> 00:03:37,260
giving to the output of function f given

00:03:34,650 --> 00:03:40,320
that their input is X there is a server

00:03:37,260 --> 00:03:42,810
side that does not know what X is there

00:03:40,320 --> 00:03:46,380
is no input given to it but there knows

00:03:42,810 --> 00:03:49,500
a encryption of that X which is which we

00:03:46,380 --> 00:03:52,049
call C and knows in details of F and

00:03:49,500 --> 00:03:57,840
does not want to reveal the details of F

00:03:52,049 --> 00:03:59,970
to the client and there is an important

00:03:57,840 --> 00:04:02,340
concept called evaluation procedure

00:03:59,970 --> 00:04:05,760
which is a procedure that giving the

00:04:02,340 --> 00:04:09,690
input of a Cyprus cipher text encrypting

00:04:05,760 --> 00:04:13,320
X and a description of function f gives

00:04:09,690 --> 00:04:16,799
out and evaluate itself cipher text that

00:04:13,320 --> 00:04:18,690
can be decrypt decrypted later to F X by

00:04:16,799 --> 00:04:20,790
anyone who has the key to decrypt it

00:04:18,690 --> 00:04:23,430
which is not the client the client

00:04:20,790 --> 00:04:25,260
doesn't which is not the server the

00:04:23,430 --> 00:04:27,500
server does not have the key to decrypt

00:04:25,260 --> 00:04:27,500
this

00:04:29,160 --> 00:04:35,290
there is the concept of compactness

00:04:32,170 --> 00:04:37,570
which is which means that the complexity

00:04:35,290 --> 00:04:41,530
of decrypting and evaluated function

00:04:37,570 --> 00:04:43,930
does not depend on the function and what

00:04:41,530 --> 00:04:45,660
that comes with comes the concept of

00:04:43,930 --> 00:04:48,880
compact fully homomorphic encryption

00:04:45,660 --> 00:04:51,280
which is a compact scheme that can

00:04:48,880 --> 00:04:52,690
evaluate all functions there are

00:04:51,280 --> 00:04:55,030
different levels in homomorphic

00:04:52,690 --> 00:04:57,700
encryption there are home Orphic

00:04:55,030 --> 00:04:59,650
encryption schemes that can evaluate

00:04:57,700 --> 00:05:02,470
some functions we'll we're going to look

00:04:59,650 --> 00:05:04,780
into that later but for a scheme to have

00:05:02,470 --> 00:05:06,550
the ability to evaluate all functions

00:05:04,780 --> 00:05:08,290
giving to it makes it a fully

00:05:06,550 --> 00:05:20,020
homomorphic encryption fully homomorphic

00:05:08,290 --> 00:05:29,290
scheme this is not do you have any

00:05:20,020 --> 00:05:32,110
questions I don't know at this point we

00:05:29,290 --> 00:05:34,830
don't have that so sorry I'm afraid

00:05:32,110 --> 00:05:38,920
that's no no go to I've lost it again

00:05:34,830 --> 00:05:41,550
but at least I still have my hope that

00:05:38,920 --> 00:05:41,550
it come back

00:05:50,320 --> 00:05:53,389
[Music]

00:05:56,850 --> 00:06:02,070
I have no idea why it why it stopped

00:06:00,510 --> 00:06:08,730
just like that back yes this is where

00:06:02,070 --> 00:06:12,300
you work right thank you okay we're

00:06:08,730 --> 00:06:14,730
going to talk about some gentry

00:06:12,300 --> 00:06:18,180
Gentry's blueprint that has been that

00:06:14,730 --> 00:06:23,160
been proposed in 209 which is basically

00:06:18,180 --> 00:06:26,250
somehow recently and before that there

00:06:23,160 --> 00:06:28,740
was no blueprint to that can construct a

00:06:26,250 --> 00:06:32,670
fully homomorphic scheme but gentry came

00:06:28,740 --> 00:06:34,950
up with a blueprint to do so so I'm

00:06:32,670 --> 00:06:36,930
gonna explain this there's a little bit

00:06:34,950 --> 00:06:38,870
of math and that I'm sorry in advance

00:06:36,930 --> 00:06:41,220
for it

00:06:38,870 --> 00:06:43,950
selling Gentry's blueprint there is a

00:06:41,220 --> 00:06:47,070
secret key we'll call it key which is a

00:06:43,950 --> 00:06:49,890
large odd number and how the scheme

00:06:47,070 --> 00:06:53,250
works is the encryption and encryption

00:06:49,890 --> 00:06:55,800
of a bit B is an integer whose residue

00:06:53,250 --> 00:06:58,920
model of P has the same parity as bit B

00:06:55,800 --> 00:07:02,310
okay that sounds a little complex I know

00:06:58,920 --> 00:07:04,500
but so there is our input X that we call

00:07:02,310 --> 00:07:07,140
before X we'll call it B here which is a

00:07:04,500 --> 00:07:11,040
bit that can be 0 or 1 there is a

00:07:07,140 --> 00:07:13,050
ciphertext C X which this is basically

00:07:11,040 --> 00:07:18,450
our scheme this is how we're encrypting

00:07:13,050 --> 00:07:21,620
our data and the sense here equal equal

00:07:18,450 --> 00:07:25,560
to this formula PQ plus 2 R plus B

00:07:21,620 --> 00:07:29,370
remember our P was our secret key Q and

00:07:25,560 --> 00:07:33,420
R or random and we know that the value

00:07:29,370 --> 00:07:39,540
of R is a lot less than P so how it

00:07:33,420 --> 00:07:41,580
works is okay so we see we saw how the

00:07:39,540 --> 00:07:43,770
encryption works now how the decryption

00:07:41,580 --> 00:07:49,560
works is that the client having the key

00:07:43,770 --> 00:07:53,160
P can do this formula here having the

00:07:49,560 --> 00:07:55,680
cipher text mod p Matoo gives it the bit

00:07:53,160 --> 00:07:57,780
B this is how the decryption works and

00:07:55,680 --> 00:08:03,200
it's important to notice that only the

00:07:57,780 --> 00:08:03,200
client has the secret key not the server

00:08:04,130 --> 00:08:10,150
again a

00:08:07,060 --> 00:08:12,640
graft kind of show you how works there

00:08:10,150 --> 00:08:14,980
is the client side and the server side

00:08:12,640 --> 00:08:18,250
client giving this is in country's

00:08:14,980 --> 00:08:20,530
blueprint where our Q are produced

00:08:18,250 --> 00:08:22,780
randomly there's the bead which is our

00:08:20,530 --> 00:08:25,150
input there's the P which is the secret

00:08:22,780 --> 00:08:27,550
key and there's the function f we assume

00:08:25,150 --> 00:08:31,360
here we want to do an addition of two

00:08:27,550 --> 00:08:33,909
integers and given out the scheme to the

00:08:31,360 --> 00:08:36,580
client it will give out the ciphertext

00:08:33,909 --> 00:08:39,190
and the function to the server the

00:08:36,580 --> 00:08:42,219
server evaluates the function and gives

00:08:39,190 --> 00:08:44,800
it back to the client for it and client

00:08:42,219 --> 00:08:48,070
having clients having to pee the secret

00:08:44,800 --> 00:08:58,030
key which is P can decrypt this to the

00:08:48,070 --> 00:09:02,170
function f c/f be alright okay so let's

00:08:58,030 --> 00:09:04,930
look at one evaluation function there is

00:09:02,170 --> 00:09:08,680
the the client wants to know what FB is

00:09:04,930 --> 00:09:11,830
which is b1 plus b2 but doesn't want the

00:09:08,680 --> 00:09:15,510
server to know what b1 and b2 are are so

00:09:11,830 --> 00:09:18,820
it will give out c1 and c2 to the server

00:09:15,510 --> 00:09:24,130
so giving this scheme we can encrypt our

00:09:18,820 --> 00:09:27,700
b1 2 c1 like Q P plus 2r plus B that's

00:09:24,130 --> 00:09:31,200
what we saw earlier so we encrypt both

00:09:27,700 --> 00:09:36,460
these inputs and we produce c1 and c2

00:09:31,200 --> 00:09:39,160
what is important here is that the

00:09:36,460 --> 00:09:43,000
function of addition gives out the same

00:09:39,160 --> 00:09:48,450
format as our encryption before so it

00:09:43,000 --> 00:09:48,450
can be decrypted to the right values and

00:09:50,160 --> 00:09:57,640
but it is important also to notice that

00:09:53,170 --> 00:10:00,280
r1 and r2 to small the small values that

00:09:57,640 --> 00:10:03,820
we have seen before need to be small

00:10:00,280 --> 00:10:06,760
enough so that the noise actually they

00:10:03,820 --> 00:10:10,510
have to be smaller than P over 2 so that

00:10:06,760 --> 00:10:11,890
the noise doesn't ruin the function so

00:10:10,510 --> 00:10:13,980
if they're small enough they're still

00:10:11,890 --> 00:10:19,450
decrypt all to the right value and

00:10:13,980 --> 00:10:20,590
generally speaking just this function

00:10:19,450 --> 00:10:22,450
can be done on at this

00:10:20,590 --> 00:10:26,440
on multiplication and generally speaking

00:10:22,450 --> 00:10:29,140
to all low degree polynomials on

00:10:26,440 --> 00:10:32,200
ciphertext given out that the noise is

00:10:29,140 --> 00:10:37,450
small enough it would be decrypted to

00:10:32,200 --> 00:10:41,230
the right value so here is an example to

00:10:37,450 --> 00:10:43,650
see it in integers we P was our secret

00:10:41,230 --> 00:10:47,200
key which was an a large odd number as

00:10:43,650 --> 00:10:50,140
51 there are inputs b1 and b2 we give

00:10:47,200 --> 00:10:53,650
them 0 & 1 what desert what the client

00:10:50,140 --> 00:10:56,560
wants to know is 0 plus 1 so the server

00:10:53,650 --> 00:10:59,050
should give it a evaluated search

00:10:56,560 --> 00:11:03,430
ciphertext that can later be decrypted

00:10:59,050 --> 00:11:06,490
to 1 we all agree on that right great I

00:11:03,430 --> 00:11:11,140
just want to know that you're following

00:11:06,490 --> 00:11:14,110
this so we produce our queue and our

00:11:11,140 --> 00:11:18,790
random numbers and we encrypt our b1 and

00:11:14,110 --> 00:11:21,130
b2 and send them to the server so b1

00:11:18,790 --> 00:11:24,070
plus b2 equals 1 is what we are hoping

00:11:21,130 --> 00:11:28,720
to get from this so let's see what the

00:11:24,070 --> 00:11:32,980
server does so our encrypted values are

00:11:28,720 --> 00:11:34,780
going to be 4,400 63 and 364 these are

00:11:32,980 --> 00:11:38,440
the values that the server is getting

00:11:34,780 --> 00:11:41,230
not 1 and 0 so the server knows to add

00:11:38,440 --> 00:11:44,020
these through so it gives out a 27 and

00:11:41,230 --> 00:11:46,480
gives it back to the client so now what

00:11:44,020 --> 00:11:49,330
the client has to do is to decrypt it to

00:11:46,480 --> 00:11:53,290
the value wants to and if the client

00:11:49,330 --> 00:11:59,080
steel is still going to use the key 51

00:11:53,290 --> 00:12:01,810
to do so so let's see 8802 7 mod 51

00:11:59,080 --> 00:12:03,420
month 2 gives that one which is the

00:12:01,810 --> 00:12:06,490
exact result that we were hoping for

00:12:03,420 --> 00:12:10,690
shows that the scheme works for an

00:12:06,490 --> 00:12:11,770
addition function evaluation and trust

00:12:10,690 --> 00:12:13,030
me and this is going to work on

00:12:11,770 --> 00:12:18,910
multiplication and I leave any

00:12:13,030 --> 00:12:21,220
polynomial also but well this scheme is

00:12:18,910 --> 00:12:23,290
not compact because the bit size of the

00:12:21,220 --> 00:12:27,100
ciphertext grows with the degree of the

00:12:23,290 --> 00:12:29,800
polynomial and their noise magnitude

00:12:27,100 --> 00:12:31,600
grows with the degree and at some point

00:12:29,800 --> 00:12:34,010
it's going to fail and doubt will be

00:12:31,600 --> 00:12:37,220
wendell noise hits P over 2

00:12:34,010 --> 00:12:38,420
and so Gantry solve this by

00:12:37,220 --> 00:12:42,920
bootstrapping

00:12:38,420 --> 00:12:44,890
which is again another complex concept

00:12:42,920 --> 00:12:48,580
but I'm just going to give you an a

00:12:44,890 --> 00:12:51,770
sense to describing it

00:12:48,580 --> 00:12:54,140
he realized that any homomorphic scheme

00:12:51,770 --> 00:12:58,190
which is capable of evaluating its own

00:12:54,140 --> 00:13:00,830
decryption and a NAND gate can be turned

00:12:58,190 --> 00:13:02,810
into a fully homomorphic scheme I'm not

00:13:00,830 --> 00:13:06,130
going to get into how it's done but I'm

00:13:02,810 --> 00:13:09,470
just telling you it's a complex and it's

00:13:06,130 --> 00:13:12,230
it's going to be power-hungry it's going

00:13:09,470 --> 00:13:15,290
to be very slow because there are a lot

00:13:12,230 --> 00:13:18,260
of operations that has to be done with

00:13:15,290 --> 00:13:19,910
that we're gonna talk about how we can

00:13:18,260 --> 00:13:22,010
improve this wholly whole morphic

00:13:19,910 --> 00:13:23,950
encryption is not not right now it's

00:13:22,010 --> 00:13:27,290
something we can do on real time

00:13:23,950 --> 00:13:31,550
processing and because it's slow and

00:13:27,290 --> 00:13:33,080
it's not fast enough so we can we can

00:13:31,550 --> 00:13:36,130
make it faster using hard for

00:13:33,080 --> 00:13:39,530
acceleration and which is basically

00:13:36,130 --> 00:13:42,020
offloading parts of your system that are

00:13:39,530 --> 00:13:44,750
computationally intensive to a hardware

00:13:42,020 --> 00:13:47,180
in this case a good hardware would be an

00:13:44,750 --> 00:13:49,400
FPGA because it can be reprogrammed and

00:13:47,180 --> 00:13:54,040
because it offers high degrees of

00:13:49,400 --> 00:13:58,310
parallelism there has been work done on

00:13:54,040 --> 00:14:01,790
boosting the speed of home Orphic

00:13:58,310 --> 00:14:04,010
encryption schemes with FPGAs there has

00:14:01,790 --> 00:14:05,780
been FPGA coprocessors FPGA based

00:14:04,010 --> 00:14:11,420
high-performance parallel architecture

00:14:05,780 --> 00:14:15,290
so in the second one in specific they

00:14:11,420 --> 00:14:19,190
they optimized their design and the arm

00:14:15,290 --> 00:14:21,050
they proposed a hardware accelerator for

00:14:19,190 --> 00:14:23,750
the for home morphic encryption scheme

00:14:21,050 --> 00:14:27,380
that works and they were working on but

00:14:23,750 --> 00:14:31,870
they they were faced with a large data

00:14:27,380 --> 00:14:34,330
transfer overhead and in some cases even

00:14:31,870 --> 00:14:37,850
the function evaluation of

00:14:34,330 --> 00:14:40,640
multiplication there the hardware side

00:14:37,850 --> 00:14:43,490
could do a good job of a lot faster of

00:14:40,640 --> 00:14:45,410
processing that multiplication but still

00:14:43,490 --> 00:14:48,500
the overall timing didn't change at all

00:14:45,410 --> 00:14:50,870
because there was a lot of data overhead

00:14:48,500 --> 00:14:54,890
cross produced because data has to be

00:14:50,870 --> 00:14:57,950
sent back and forth between platforms so

00:14:54,890 --> 00:15:00,710
they came up with solutions for that

00:14:57,950 --> 00:15:02,900
they tried assigning more memory to the

00:15:00,710 --> 00:15:04,490
fpga so that the data can be permanent

00:15:02,900 --> 00:15:07,010
process locally

00:15:04,490 --> 00:15:10,190
and they tried finding the most

00:15:07,010 --> 00:15:13,790
efficient data set size so that having

00:15:10,190 --> 00:15:17,120
to send data back and forth doesn't

00:15:13,790 --> 00:15:19,790
produce that much of an overhead but we

00:15:17,120 --> 00:15:23,240
know that there are better ways to fix

00:15:19,790 --> 00:15:26,120
those so what we came up with was by

00:15:23,240 --> 00:15:30,680
using capi and apache arrow capi giving

00:15:26,120 --> 00:15:34,640
the open copy a copy giving the fpga a

00:15:30,680 --> 00:15:39,110
coherent memory axis and apache arrow

00:15:34,640 --> 00:15:42,800
being a being an in-memory tabular

00:15:39,110 --> 00:15:49,820
format they both reduce data copy

00:15:42,800 --> 00:15:52,700
overhead and so here is some information

00:15:49,820 --> 00:15:57,290
on open Cappy Cappy but this is actually

00:15:52,700 --> 00:15:59,720
for Cappy power 8 I guess and so it

00:15:57,290 --> 00:16:03,260
creates virtual access memory gel memory

00:15:59,720 --> 00:16:05,750
for FPGA giving the FPGA coherent access

00:16:03,260 --> 00:16:08,990
to the memory and eliminating the need

00:16:05,750 --> 00:16:15,080
to copy data back and forth to send it

00:16:08,990 --> 00:16:17,150
from CPU to the FPGA and Apache arrow is

00:16:15,080 --> 00:16:19,400
a cross language development performant

00:16:17,150 --> 00:16:23,150
platform for in-memory data there are

00:16:19,400 --> 00:16:25,010
many languages to support it C C++ list

00:16:23,150 --> 00:16:30,710
goes on this is only some of the

00:16:25,010 --> 00:16:32,930
languages and so Apache arrow by

00:16:30,710 --> 00:16:35,180
eliminating the need for civilization

00:16:32,930 --> 00:16:38,060
can reduce the data overhead transfer

00:16:35,180 --> 00:16:40,190
when data needs to be sent back and

00:16:38,060 --> 00:16:44,440
forth between platforms in our case from

00:16:40,190 --> 00:16:47,480
CPU to FPGA and from FPGA to CPU and

00:16:44,440 --> 00:16:50,300
there's Fletcher which is a framework

00:16:47,480 --> 00:16:53,720
that integrates FPGA accelerators but

00:16:50,300 --> 00:16:55,520
after bit Apache aero I'm not gonna go

00:16:53,720 --> 00:16:57,230
into detail about this because the folks

00:16:55,520 --> 00:16:59,150
that created a Fletcher are here and

00:16:57,230 --> 00:16:59,720
going to going to talk about this after

00:16:59,150 --> 00:17:02,600
this

00:16:59,720 --> 00:17:05,059
and all I say it's that it's open source

00:17:02,600 --> 00:17:09,770
and you can find information on it in

00:17:05,059 --> 00:17:12,860
this website on github so where we are

00:17:09,770 --> 00:17:16,309
now with this project is that we are

00:17:12,860 --> 00:17:18,559
testing and learning to run simple codes

00:17:16,309 --> 00:17:21,970
using Fletcher we're kind of following

00:17:18,559 --> 00:17:24,199
what the folks at delft are doing and

00:17:21,970 --> 00:17:26,750
we're researching on homomorphic

00:17:24,199 --> 00:17:29,570
encryption finding the best best schemes

00:17:26,750 --> 00:17:33,559
that can benefit most from this kind of

00:17:29,570 --> 00:17:36,799
implementation and so we're kind of at

00:17:33,559 --> 00:17:39,140
an at a starting phase with this project

00:17:36,799 --> 00:17:42,409
so any ideas or recommendation that you

00:17:39,140 --> 00:17:57,070
have is very well accepted thank you so

00:17:42,409 --> 00:17:57,070
much okay

00:18:02,640 --> 00:18:08,310
[Music]

00:18:05,310 --> 00:18:08,310
whatever

00:18:13,409 --> 00:18:22,450
the specific functions I mean okay so

00:18:18,960 --> 00:18:26,350
the fully homomorphic note so we saw how

00:18:22,450 --> 00:18:28,120
the function could be about could be

00:18:26,350 --> 00:18:31,690
decrypted to the right value right in

00:18:28,120 --> 00:18:34,090
the Edition but with that scheme so the

00:18:31,690 --> 00:18:36,309
that scheme provides the ability for

00:18:34,090 --> 00:18:39,130
that function to be decrypted to the

00:18:36,309 --> 00:18:40,840
same to the right value but not all not

00:18:39,130 --> 00:18:42,100
all functions can be decrypted to the

00:18:40,840 --> 00:18:44,789
right value because there is noise

00:18:42,100 --> 00:18:48,250
created and maybe the scheme is not

00:18:44,789 --> 00:18:51,220
mathematically correct so we have to

00:18:48,250 --> 00:18:53,710
come up with new schemes that can make

00:18:51,220 --> 00:18:59,529
this happen for all functions not just

00:18:53,710 --> 00:19:05,890
like low degree polynomials do you have

00:18:59,529 --> 00:19:14,620
a question yeah I think that's the

00:19:05,890 --> 00:19:17,559
that's the machine that we have yes well

00:19:14,620 --> 00:19:20,350
the thing is we're not really platform

00:19:17,559 --> 00:19:21,850
dependent at this point so of what were

00:19:20,350 --> 00:19:23,679
you doing is trying to figure out our

00:19:21,850 --> 00:19:25,690
side of this and then we're figure out

00:19:23,679 --> 00:19:28,149
which machine we're going to upload this

00:19:25,690 --> 00:19:30,190
on probably I think will be talk to JT

00:19:28,149 --> 00:19:31,899
about this work they're gonna give us

00:19:30,190 --> 00:19:36,760
the open copy machine so that we can

00:19:31,899 --> 00:19:41,789
work on that one yeah mm-hmm those are

00:19:36,760 --> 00:19:41,789
any other questions thank you

00:19:43,770 --> 00:19:45,990

YouTube URL: https://www.youtube.com/watch?v=xw5gG6I0NDU


