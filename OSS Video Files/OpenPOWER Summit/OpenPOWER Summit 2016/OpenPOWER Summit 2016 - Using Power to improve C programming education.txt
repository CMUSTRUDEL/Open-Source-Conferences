Title: OpenPOWER Summit 2016 - Using Power to improve C programming education
Publication date: 2016-04-29
Playlist: OpenPOWER Summit 2016
Description: 
	Presented by Dr. Jonas Skeppstedt of Lund University
Captions: 
	00:00:00,000 --> 00:00:04,620
my name is Jana scripted and I'm from

00:00:02,280 --> 00:00:07,859
learned University in Sweden it's close

00:00:04,620 --> 00:00:10,950
to Copenhagen and i will make a case for

00:00:07,859 --> 00:00:14,190
using power machines in computer science

00:00:10,950 --> 00:00:19,170
education in particular for c

00:00:14,190 --> 00:00:22,310
programming courses ok this is the

00:00:19,170 --> 00:00:26,220
outline essentially i will explain how

00:00:22,310 --> 00:00:29,849
using an automatic grader and power

00:00:26,220 --> 00:00:34,350
assembler code can improve the learning

00:00:29,849 --> 00:00:36,540
outcome for students and i will also

00:00:34,350 --> 00:00:40,770
mention what we will do in the future in

00:00:36,540 --> 00:00:45,090
the near future so there are two courses

00:00:40,770 --> 00:00:48,180
on C and C programming language in

00:00:45,090 --> 00:00:50,670
adland University the first one which is

00:00:48,180 --> 00:00:54,840
the focus today is about writing clean

00:00:50,670 --> 00:00:59,160
code and it has also a lot of focus on

00:00:54,840 --> 00:01:01,710
the iso ceased artist from c11 ok and

00:00:59,160 --> 00:01:03,690
the other one is called algorithm

00:01:01,710 --> 00:01:06,990
implementation it had NASA focus on

00:01:03,690 --> 00:01:10,020
writing efficiency this code SRA this

00:01:06,990 --> 00:01:14,790
course was actually inspired by a course

00:01:10,020 --> 00:01:19,670
from IBM or actually at IBM by Alpern

00:01:14,790 --> 00:01:24,060
several years ago ok there is another

00:01:19,670 --> 00:01:27,090
part where we also teach the c11 atomic

00:01:24,060 --> 00:01:33,890
types and multithreading in the course

00:01:27,090 --> 00:01:36,570
multi core programming so previously the

00:01:33,890 --> 00:01:40,110
programming assignments they were graded

00:01:36,570 --> 00:01:43,290
manually by teaching assistants during

00:01:40,110 --> 00:01:49,590
weekends so this resulted in a latency

00:01:43,290 --> 00:01:52,920
of 72 hours from handing to reject with

00:01:49,590 --> 00:01:57,380
occasional pause ok these assignments

00:01:52,920 --> 00:02:00,299
they were or actually are required for

00:01:57,380 --> 00:02:03,750
writing the exam so this pickup makes it

00:02:00,299 --> 00:02:05,909
stressful for several students who might

00:02:03,750 --> 00:02:08,479
not finish them in type and another

00:02:05,909 --> 00:02:12,080
issue is that teaching assistants they

00:02:08,479 --> 00:02:12,080
cost money so

00:02:12,420 --> 00:02:21,900
a different approach is to have

00:02:15,930 --> 00:02:25,080
automatic grading so I have written a

00:02:21,900 --> 00:02:28,670
program to do degrading automatically

00:02:25,080 --> 00:02:32,520
and then we can reduce the latency from

00:02:28,670 --> 00:02:36,750
72 hours 25 minutes approximately but

00:02:32,520 --> 00:02:39,840
now there is no human being looking at

00:02:36,750 --> 00:02:43,230
the source code so we need a new method

00:02:39,840 --> 00:02:49,140
to motivate the students to do their

00:02:43,230 --> 00:02:54,269
best okay so this method is to have a

00:02:49,140 --> 00:02:57,380
competition and there is the competition

00:02:54,269 --> 00:02:59,940
is about writing memory efficient C code

00:02:57,380 --> 00:03:01,830
okay so there is a score for each

00:02:59,940 --> 00:03:05,060
assignment first it must pass all the

00:03:01,830 --> 00:03:08,970
tests and then it's the size of the

00:03:05,060 --> 00:03:11,880
instructions and our static data not the

00:03:08,970 --> 00:03:15,090
hip and not the stack but static data

00:03:11,880 --> 00:03:17,820
okay and there are three assignments one

00:03:15,090 --> 00:03:20,910
per week an RPM calculator finding

00:03:17,820 --> 00:03:24,420
longest word in input and polynomial

00:03:20,910 --> 00:03:30,390
multiplication with the increasing level

00:03:24,420 --> 00:03:34,140
of difficulties okay so this is what the

00:03:30,390 --> 00:03:39,120
winner got and it motivated them quite a

00:03:34,140 --> 00:03:41,220
lot ok so this is the automatic grader

00:03:39,120 --> 00:03:45,150
it's called for set them and for theta

00:03:41,220 --> 00:03:49,730
is a viking age judge who is always fair

00:03:45,150 --> 00:03:52,620
and this program is also very fair

00:03:49,730 --> 00:03:56,720
actually you so what it does it runs as

00:03:52,620 --> 00:04:00,380
wrote a fetches males gives the score

00:03:56,720 --> 00:04:04,739
pass/fail and the number and then

00:04:00,380 --> 00:04:06,989
returns the power machine code for their

00:04:04,739 --> 00:04:10,019
assignment actually you can try it

00:04:06,989 --> 00:04:12,900
yourself by sending email to see book at

00:04:10,019 --> 00:04:17,039
four state a.net and when you can find

00:04:12,900 --> 00:04:21,560
more details at the web page yet that

00:04:17,039 --> 00:04:25,430
you can see below okay

00:04:21,560 --> 00:04:29,900
so yeah what this program first does is

00:04:25,430 --> 00:04:32,510
to check the source code if it is valid

00:04:29,900 --> 00:04:35,780
according to the linux kernel code stud

00:04:32,510 --> 00:04:40,550
and then it generates random input and

00:04:35,780 --> 00:04:43,430
runs a reference implementation to and

00:04:40,550 --> 00:04:46,550
then checks there I mean to generate

00:04:43,430 --> 00:04:49,220
input for checking their code so then it

00:04:46,550 --> 00:04:54,560
Forks and compile their code Forks again

00:04:49,220 --> 00:04:59,080
limits stack size and changes yandex

00:04:54,560 --> 00:05:02,600
user ID is I mean we are executing

00:04:59,080 --> 00:05:06,260
completely untrusted code so we must

00:05:02,600 --> 00:05:10,880
change the UNIX like a user ID and we do

00:05:06,260 --> 00:05:15,979
some other things as well to to have

00:05:10,880 --> 00:05:18,530
such as timeouts and so forth so hope

00:05:15,979 --> 00:05:21,139
sorry how can we then encourage

00:05:18,530 --> 00:05:25,040
simplicity and elegance actually it

00:05:21,139 --> 00:05:29,800
turns out that elegant code it is

00:05:25,040 --> 00:05:34,610
usually memory efficient as well ok and

00:05:29,800 --> 00:05:37,280
this scores and the high score list they

00:05:34,610 --> 00:05:40,130
give them the give students very

00:05:37,280 --> 00:05:42,770
important feedback for instance in the

00:05:40,130 --> 00:05:52,090
longest word assignment the scores

00:05:42,770 --> 00:05:54,400
ranged from 189 bytes to almost 800 and

00:05:52,090 --> 00:05:58,400
the student of course have different

00:05:54,400 --> 00:06:01,190
competence and but they realize that

00:05:58,400 --> 00:06:05,270
there is room for making the code

00:06:01,190 --> 00:06:07,460
simpler ok so this is very important

00:06:05,270 --> 00:06:10,820
understanding for the students and

00:06:07,460 --> 00:06:12,979
without this high score and automatic

00:06:10,820 --> 00:06:19,010
grading they they don't see that they

00:06:12,979 --> 00:06:20,690
just get marks on the coke ok so where

00:06:19,010 --> 00:06:27,160
does the power of fit into this that

00:06:20,690 --> 00:06:30,740
well to win the competition it's

00:06:27,160 --> 00:06:32,810
required I mean to score well to read

00:06:30,740 --> 00:06:34,969
the assembler code so that they can

00:06:32,810 --> 00:06:38,619
reduce the size of their program

00:06:34,969 --> 00:06:40,699
and that excludes memory several

00:06:38,619 --> 00:06:43,789
instruction set architectures I won't

00:06:40,699 --> 00:06:46,819
mention in in particular but the

00:06:43,789 --> 00:06:49,339
advantage of power is that the code it

00:06:46,819 --> 00:06:52,999
becomes predicted predictable and easy

00:06:49,339 --> 00:06:55,369
to read okay another thing is that there

00:06:52,999 --> 00:06:58,159
are available mature optimizing

00:06:55,369 --> 00:07:01,429
compilers for ko Sai's we use the GCC

00:06:58,159 --> 00:07:06,409
with well that option as you can see

00:07:01,429 --> 00:07:10,819
okay and remark from the winner Anton

00:07:06,409 --> 00:07:13,339
Clarion his name is that Jesus did sorry

00:07:10,819 --> 00:07:15,409
the GCC compiler for power does not

00:07:13,339 --> 00:07:18,619
generate any instruction that you don't

00:07:15,409 --> 00:07:25,339
understand what it does or why it is

00:07:18,619 --> 00:07:29,089
there okay so this makes it easy to

00:07:25,339 --> 00:07:33,099
reason about the source code that you

00:07:29,089 --> 00:07:38,689
write and the object code that you get

00:07:33,099 --> 00:07:41,719
okay other advantages with power include

00:07:38,689 --> 00:07:44,809
that there is a very detailed online

00:07:41,719 --> 00:07:48,909
documentation not only on this

00:07:44,809 --> 00:07:48,909
instruction set of course but also on

00:07:50,289 --> 00:07:54,769
several different pipeline

00:07:52,399 --> 00:07:56,599
implementations okay and there are of

00:07:54,769 --> 00:07:59,029
course very good development platforms

00:07:56,599 --> 00:08:02,959
either if you have a power 8 server or

00:07:59,029 --> 00:08:06,639
as in learned several multiprocessors

00:08:02,959 --> 00:08:10,599
based on the on older power machines

00:08:06,639 --> 00:08:13,419
okay so we use the power also for other

00:08:10,599 --> 00:08:15,919
courses multi core programming and

00:08:13,419 --> 00:08:18,819
algorithm implementation and then

00:08:15,919 --> 00:08:25,399
development platforms good massage are

00:08:18,819 --> 00:08:28,699
essential okay and for the multi core

00:08:25,399 --> 00:08:32,779
programming it's important to get

00:08:28,699 --> 00:08:40,159
exposed to the advanced relaxed memory

00:08:32,779 --> 00:08:44,000
model which power has okay and also very

00:08:40,159 --> 00:08:45,769
important that you get by using the

00:08:44,000 --> 00:08:48,529
power of architecture in the cs

00:08:45,769 --> 00:08:52,209
education is that there are available

00:08:48,529 --> 00:08:54,829
a very detailed pipeline simulators and

00:08:52,209 --> 00:08:56,860
below you can see where you can fetch

00:08:54,829 --> 00:09:00,889
them it's they are part of the app

00:08:56,860 --> 00:09:04,279
powerful Linux sdk for instance there is

00:09:00,889 --> 00:09:07,910
a pipeline viewer it's called scroll TV

00:09:04,279 --> 00:09:13,579
which comes from idea most in and it has

00:09:07,910 --> 00:09:16,100
been invaluable to make for instance

00:09:13,579 --> 00:09:19,480
engineering math students understand the

00:09:16,100 --> 00:09:24,230
performance of superscalar processors

00:09:19,480 --> 00:09:26,420
okay now that the students are exposed

00:09:24,230 --> 00:09:29,540
to the Power Architecture they get a

00:09:26,420 --> 00:09:34,209
head start to write interesting master

00:09:29,540 --> 00:09:36,139
thesis and two recent example is

00:09:34,209 --> 00:09:38,899
instruction scheduling you've seen

00:09:36,139 --> 00:09:41,420
constraint programming in the LLVM

00:09:38,899 --> 00:09:44,240
compiler this is actually the first work

00:09:41,420 --> 00:09:48,559
ever that made the performance

00:09:44,240 --> 00:09:52,459
measurements on a real machine in other

00:09:48,559 --> 00:09:56,600
work for instance done together with IBM

00:09:52,459 --> 00:09:59,600
Research the performance the estimated

00:09:56,600 --> 00:10:02,500
performance speed ups they come from the

00:09:59,600 --> 00:10:05,720
constraint model so the quality of these

00:10:02,500 --> 00:10:07,339
speedups is dependent on how detailed

00:10:05,720 --> 00:10:11,209
the model is but this is on the real

00:10:07,339 --> 00:10:13,779
machine okay another one is performance

00:10:11,209 --> 00:10:18,980
evaluation of the C key word restrict

00:10:13,779 --> 00:10:21,709
which is to expose expose information to

00:10:18,980 --> 00:10:28,809
the compiler that certain pointers

00:10:21,709 --> 00:10:31,399
cannot be aliased okay and yeah you can

00:10:28,809 --> 00:10:35,000
understand that the to do these things

00:10:31,399 --> 00:10:38,000
it was of course militaria to have a

00:10:35,000 --> 00:10:40,519
detailed pipeline model both of the

00:10:38,000 --> 00:10:43,490
machine that they measured on and to see

00:10:40,519 --> 00:10:47,679
in detail what what actually happened so

00:10:43,490 --> 00:10:52,189
okay so that was very important for for

00:10:47,679 --> 00:10:56,509
these courses okay so conclusion and the

00:10:52,189 --> 00:11:01,069
near future also for universities using

00:10:56,509 --> 00:11:01,580
power machines is a very good idea okay

00:11:01,069 --> 00:11:03,920
and

00:11:01,580 --> 00:11:07,280
in the near future actually in September

00:11:03,920 --> 00:11:10,910
we will use power also for a course on

00:11:07,280 --> 00:11:14,560
optimizing compilers okay and we will

00:11:10,910 --> 00:11:18,860
use this book which will come in August

00:11:14,560 --> 00:11:21,940
which has will have performance

00:11:18,860 --> 00:11:27,260
measurements on several different

00:11:21,940 --> 00:11:31,550
compilers for power a clang GCC possibly

00:11:27,260 --> 00:11:34,940
X and see if I am allowed to use it for

00:11:31,550 --> 00:11:37,880
this I am contact with the staff there

00:11:34,940 --> 00:11:43,790
and also my own c compiler which was

00:11:37,880 --> 00:11:47,060
validated 4c 99 13 years ago okay you

00:11:43,790 --> 00:11:51,140
can if you wish you can download these

00:11:47,060 --> 00:11:55,190
multi thesis from my personal webpage

00:11:51,140 --> 00:11:56,750
that you can see that okay yeah thank

00:11:55,190 --> 00:12:05,170
you very much for listening and I'm

00:11:56,750 --> 00:12:05,170

YouTube URL: https://www.youtube.com/watch?v=-RE39sqqHE8


