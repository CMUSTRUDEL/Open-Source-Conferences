Title: OpenPOWER Summit 2016 - Linux on OpenPOWER: internals, interfaces and integration
Publication date: 2016-04-29
Playlist: OpenPOWER Summit 2016
Description: 
	Presented by: Jeremy Kerr of IBM
Captions: 
	00:00:00,030 --> 00:00:04,740
so I as betters mentioned my name is

00:00:02,820 --> 00:00:09,269
Jeremy Coe I'm from Perth in Australia

00:00:04,740 --> 00:00:12,179
and that's that's why I talk funny I as

00:00:09,269 --> 00:00:16,199
as I said I work in the Linux Technology

00:00:12,179 --> 00:00:18,359
Center my my mania is Linux Linux and

00:00:16,199 --> 00:00:20,670
firmware on on open power machines so

00:00:18,359 --> 00:00:22,170
one today give a bit of a background on

00:00:20,670 --> 00:00:24,689
some of the key areas or some of the

00:00:22,170 --> 00:00:26,880
interesting areas that that we've

00:00:24,689 --> 00:00:29,189
developed for for open power platforms

00:00:26,880 --> 00:00:31,399
and what they mean for for someone who's

00:00:29,189 --> 00:00:36,030
looking to integrate all or to implement

00:00:31,399 --> 00:00:37,890
machine so those areas that I want to

00:00:36,030 --> 00:00:40,230
talk about firstly a bit about our

00:00:37,890 --> 00:00:41,610
runtime Linux implementation as much as

00:00:40,230 --> 00:00:44,190
we can sort of squeeze into ten minutes

00:00:41,610 --> 00:00:46,710
of a talk today good about the way we

00:00:44,190 --> 00:00:49,020
boots so the way we boot your your

00:00:46,710 --> 00:00:50,879
actual host OS like the thing that you

00:00:49,020 --> 00:00:52,140
want to use is your workload and a

00:00:50,879 --> 00:00:55,110
little bit about the the management

00:00:52,140 --> 00:00:58,140
process or implementation on our machine

00:00:55,110 --> 00:01:00,809
so first up about the runtime Linux

00:00:58,140 --> 00:01:02,399
interface of course everything here is

00:01:00,809 --> 00:01:06,840
open-source we have everything in our

00:01:02,399 --> 00:01:10,560
tree in the standard Linux tree using

00:01:06,840 --> 00:01:14,640
the standard open Linux PowerPC platform

00:01:10,560 --> 00:01:17,970
support so the the open power code lives

00:01:14,640 --> 00:01:19,799
in a platform directory so I'm the under

00:01:17,970 --> 00:01:22,049
the PowerPC tree we have we have a set

00:01:19,799 --> 00:01:23,250
of different platforms we can build them

00:01:22,049 --> 00:01:26,250
into what we call a multi platform

00:01:23,250 --> 00:01:28,770
kernel so a single build can boot on on

00:01:26,250 --> 00:01:31,619
a power machine or an IBM power machine

00:01:28,770 --> 00:01:34,439
or a g5 so we have this concept of

00:01:31,619 --> 00:01:36,570
platforms and we use this power in the

00:01:34,439 --> 00:01:38,759
platform definition for frozen power

00:01:36,570 --> 00:01:41,579
machines now that provides a couple of

00:01:38,759 --> 00:01:43,200
things firstly a method of the hardware

00:01:41,579 --> 00:01:45,740
to describe itself to the operating

00:01:43,200 --> 00:01:48,600
system and that is by a device tree

00:01:45,740 --> 00:01:50,880
these little sample of what goes into a

00:01:48,600 --> 00:01:52,979
device tree it's a it is a tree

00:01:50,880 --> 00:01:55,380
structure it has nodes those nodes may

00:01:52,979 --> 00:01:58,079
have sub nodes with key value pairs in

00:01:55,380 --> 00:02:00,240
it and we use that to describe how the

00:01:58,079 --> 00:02:01,950
platform is is laid out in Hardware

00:02:00,240 --> 00:02:03,810
things like how many CPUs the present

00:02:01,950 --> 00:02:07,399
how much memory is prison how

00:02:03,810 --> 00:02:07,399
everything's connected up so that the

00:02:07,740 --> 00:02:12,989
colonel can can prove that and construct

00:02:10,530 --> 00:02:14,069
a running running operating system to to

00:02:12,989 --> 00:02:15,180
work in that platform and that all

00:02:14,069 --> 00:02:17,130
happens at runtime so it's all

00:02:15,180 --> 00:02:18,569
discovered at runtime the platform

00:02:17,130 --> 00:02:20,819
configures at the platform code

00:02:18,569 --> 00:02:24,750
configures itself based on this device

00:02:20,819 --> 00:02:25,920
tree description of the machine yeah the

00:02:24,750 --> 00:02:28,349
second part that this platform

00:02:25,920 --> 00:02:31,519
description provides is some

00:02:28,349 --> 00:02:33,900
abstractions for for the runtime

00:02:31,519 --> 00:02:36,630
interfaces anything anything that needs

00:02:33,900 --> 00:02:39,480
to happen at runtime to perform some

00:02:36,630 --> 00:02:41,700
sort of action that the kernel I want to

00:02:39,480 --> 00:02:44,580
do so we have what we call a the open

00:02:41,700 --> 00:02:47,819
power abstraction layer or opal and that

00:02:44,580 --> 00:02:50,420
provides some some runtime callbacks for

00:02:47,819 --> 00:02:52,980
the kernel kernel platform code to call

00:02:50,420 --> 00:02:56,790
now this exists on the machine as

00:02:52,980 --> 00:02:59,069
firmware and it means that we we don't

00:02:56,790 --> 00:03:01,560
need to have a lot of low-level code in

00:02:59,069 --> 00:03:04,560
that platform code in the kernel we can

00:03:01,560 --> 00:03:06,390
we can rely on that opal opal layer to

00:03:04,560 --> 00:03:08,130
provide some of the hardware specific

00:03:06,390 --> 00:03:10,170
methods of doing things so it's a little

00:03:08,130 --> 00:03:12,239
layer in the kernel Schippers machine

00:03:10,170 --> 00:03:13,950
firmware and of course all open source

00:03:12,239 --> 00:03:17,700
so we have our repository on the the

00:03:13,950 --> 00:03:20,220
open power project on github the the API

00:03:17,700 --> 00:03:21,859
for this is in a single header file it's

00:03:20,220 --> 00:03:25,320
it's quite a straightforward sort of

00:03:21,859 --> 00:03:27,750
interface and we actually have a whole

00:03:25,320 --> 00:03:30,570
set of functions that that the platform

00:03:27,750 --> 00:03:33,090
code in the kernel can call in to to do

00:03:30,570 --> 00:03:34,769
some similar level things so this is

00:03:33,090 --> 00:03:38,220
this is from the header file is as a few

00:03:34,769 --> 00:03:40,739
of the definitions of the callbacks that

00:03:38,220 --> 00:03:42,630
opal provides in this case we have for

00:03:40,739 --> 00:03:45,030
example a console right console read

00:03:42,630 --> 00:03:46,940
real-time clock read right and then all

00:03:45,030 --> 00:03:50,480
just tokens you know in our header file

00:03:46,940 --> 00:03:52,799
each one of these is described by a

00:03:50,480 --> 00:03:56,519
little document little text document

00:03:52,799 --> 00:03:58,530
that says fort so in this case the the

00:03:56,519 --> 00:04:00,540
console right call it takes a few

00:03:58,530 --> 00:04:02,549
parameters returns some different values

00:04:00,540 --> 00:04:05,100
that has a bit of description so we have

00:04:02,549 --> 00:04:09,450
most of this opal API documented in in a

00:04:05,100 --> 00:04:12,450
similar sort of format for for the for

00:04:09,450 --> 00:04:15,150
that lower level opal firmware now I say

00:04:12,450 --> 00:04:16,260
lower level but it's more of a library

00:04:15,150 --> 00:04:19,709
design it

00:04:16,260 --> 00:04:20,609
there's unlike x86 firmware opal doesn't

00:04:19,709 --> 00:04:22,289
have any

00:04:20,609 --> 00:04:24,509
doesn't handle any interrupts directly

00:04:22,289 --> 00:04:27,060
itself there's no hidden system

00:04:24,509 --> 00:04:30,000
management mode the only entry point

00:04:27,060 --> 00:04:31,650
that Opel has is when the the Linux

00:04:30,000 --> 00:04:34,949
kernel calls into it so it's not stolen

00:04:31,650 --> 00:04:37,919
time there's no there's no missing

00:04:34,949 --> 00:04:40,169
cycles everything that opal does is on

00:04:37,919 --> 00:04:42,689
behalf of the kernel so in that regard

00:04:40,169 --> 00:04:45,000
it's more like a library that the kernel

00:04:42,689 --> 00:04:46,830
uses rather than a separate layer of

00:04:45,000 --> 00:04:51,509
firmware that the kernel sits underneath

00:04:46,830 --> 00:04:54,240
ago so it always always a invokes on

00:04:51,509 --> 00:04:56,580
behalf of Linux and we have a fixed

00:04:54,240 --> 00:04:57,150
calling convention there it is 64-bit

00:04:56,580 --> 00:04:59,490
big endian

00:04:57,150 --> 00:05:01,770
that has no effect on on the actual

00:04:59,490 --> 00:05:04,289
kernel itself we actually we run little

00:05:01,770 --> 00:05:06,060
endian kernels with this opal firmware

00:05:04,289 --> 00:05:09,659
it would simply switch endian as we

00:05:06,060 --> 00:05:12,509
enter enter into this library family so

00:05:09,659 --> 00:05:14,520
into a diagram here for our our standard

00:05:12,509 --> 00:05:17,279
machine here we have a Loomis kernel and

00:05:14,520 --> 00:05:19,529
a workload on top we have as a power in

00:05:17,279 --> 00:05:22,110
the platform code which is responsible

00:05:19,529 --> 00:05:24,569
for configuring the platform configuring

00:05:22,110 --> 00:05:26,849
the kernel for that platform we have our

00:05:24,569 --> 00:05:28,860
little opal layer that does all the

00:05:26,849 --> 00:05:31,729
hardware abstraction and the interface

00:05:28,860 --> 00:05:35,460
between these two is described by a

00:05:31,729 --> 00:05:37,800
specified API and that's kind of how our

00:05:35,460 --> 00:05:41,879
our caring laws include there's a few

00:05:37,800 --> 00:05:45,900
extra bits involved we have open power

00:05:41,879 --> 00:05:47,969
specific drivers now there's a standard

00:05:45,900 --> 00:05:50,759
Linux device drivers that provide

00:05:47,969 --> 00:05:53,490
standard Linux devices on top of that

00:05:50,759 --> 00:05:56,189
opal layer so using that example before

00:05:53,490 --> 00:05:58,919
we have the the console rights opal opal

00:05:56,189 --> 00:06:01,139
call we use that to provide a console

00:05:58,919 --> 00:06:02,460
device driver in Linux so nothing

00:06:01,139 --> 00:06:03,870
nothing really special there it's a

00:06:02,460 --> 00:06:06,150
standard Leena's controller device it

00:06:03,870 --> 00:06:09,779
just happens to back onto onto the opal

00:06:06,150 --> 00:06:11,099
firmware and again the the functionality

00:06:09,779 --> 00:06:13,889
that I provides it's just a light layer

00:06:11,099 --> 00:06:15,930
above above the hardware so if we update

00:06:13,889 --> 00:06:18,150
our diagram from earlier we have the

00:06:15,930 --> 00:06:20,039
power of a kernel port you go for but

00:06:18,150 --> 00:06:23,129
then we have a few extra drivers that

00:06:20,039 --> 00:06:25,139
that talk into that opal API and that

00:06:23,129 --> 00:06:27,360
that's kind of the core of it now as I

00:06:25,139 --> 00:06:30,360
mentioned before opal is is fairly small

00:06:27,360 --> 00:06:32,789
very library like interface one thing

00:06:30,360 --> 00:06:34,380
that is miss always is absent from it in

00:06:32,789 --> 00:06:36,630
comparison to ox 86 firmware

00:06:34,380 --> 00:06:38,520
is the way to boot your your host

00:06:36,630 --> 00:06:41,160
colonel so there's none of that support

00:06:38,520 --> 00:06:43,170
is present in in the open pal firmware

00:06:41,160 --> 00:06:45,240
now rather than writing all of that

00:06:43,170 --> 00:06:49,320
infrastructure ourselves we thought that

00:06:45,240 --> 00:06:51,920
we use is a good thing so we have a what

00:06:49,320 --> 00:06:54,000
we call pity boot this is our booting UI

00:06:51,920 --> 00:06:56,550
this is what happens when you boot your

00:06:54,000 --> 00:06:59,940
machine you get this is this dialog

00:06:56,550 --> 00:07:00,960
coming up on the on the console with

00:06:59,940 --> 00:07:02,490
some options to boot

00:07:00,960 --> 00:07:06,590
now we can actually exit out of that

00:07:02,490 --> 00:07:09,180
that UI and enter a standard linux shell

00:07:06,590 --> 00:07:11,040
so this is all still running from

00:07:09,180 --> 00:07:12,150
firmware we haven't loaded any code off

00:07:11,040 --> 00:07:15,420
disk or anything like that we have a

00:07:12,150 --> 00:07:18,180
little embedded Linux system that exists

00:07:15,420 --> 00:07:19,800
in in firmware that is responsible for

00:07:18,180 --> 00:07:21,510
the boot services of the machine so it

00:07:19,800 --> 00:07:24,300
does things like look for the discs that

00:07:21,510 --> 00:07:27,330
are present and and find bootable

00:07:24,300 --> 00:07:28,950
options like we see here and then is

00:07:27,330 --> 00:07:32,100
responsible for booting into those after

00:07:28,950 --> 00:07:34,830
after reading configuration so by using

00:07:32,100 --> 00:07:36,540
Linux here we can we can reuse all of

00:07:34,830 --> 00:07:37,800
that existing core code that is already

00:07:36,540 --> 00:07:39,120
out there in the community we don't need

00:07:37,800 --> 00:07:41,490
to rewrite that for our specific

00:07:39,120 --> 00:07:42,990
firmware so for example here we have the

00:07:41,490 --> 00:07:45,060
open firmware support we have the device

00:07:42,990 --> 00:07:46,380
drivers we have the network stack we

00:07:45,060 --> 00:07:47,970
have all in network protocols we have

00:07:46,380 --> 00:07:49,980
all the disk drivers and all that all

00:07:47,970 --> 00:07:52,020
the bits that that we would need to

00:07:49,980 --> 00:07:54,120
write proof services rather than writing

00:07:52,020 --> 00:07:59,850
it we just borrow them from Linux and

00:07:54,120 --> 00:08:02,490
have that as our so as I said we have a

00:07:59,850 --> 00:08:05,430
wasn't one of the benefits of doing this

00:08:02,490 --> 00:08:07,890
it means that rather than having fairly

00:08:05,430 --> 00:08:09,960
hard to debug firmware code as your boot

00:08:07,890 --> 00:08:11,730
services it's now just all user space

00:08:09,960 --> 00:08:14,370
code so anyone who's familiar with

00:08:11,730 --> 00:08:18,390
developing a Linux user space

00:08:14,370 --> 00:08:20,040
application is now enabled to to alter

00:08:18,390 --> 00:08:21,930
the bootloader or to do anything without

00:08:20,040 --> 00:08:24,990
our firmware man it's our boot

00:08:21,930 --> 00:08:26,400
management process simply by working on

00:08:24,990 --> 00:08:29,640
this this petty boot project which is a

00:08:26,400 --> 00:08:31,290
standard user space application again

00:08:29,640 --> 00:08:34,050
open source it's in our github

00:08:31,290 --> 00:08:37,620
repository for

00:08:34,050 --> 00:08:40,839
now a few feed little quick items on our

00:08:37,620 --> 00:08:42,339
under management controllers for for the

00:08:40,839 --> 00:08:46,149
existing open power platforms out there

00:08:42,339 --> 00:08:48,550
at the moment so the the concept here is

00:08:46,149 --> 00:08:50,860
is we want to go the path of fewer

00:08:48,550 --> 00:08:53,079
surprises so we have a an industry

00:08:50,860 --> 00:08:55,300
standard placement management controller

00:08:53,079 --> 00:08:58,600
on these machines which uses all the

00:08:55,300 --> 00:09:00,639
usual methods of power control of the

00:08:58,600 --> 00:09:03,999
logs of error collection that sort of

00:09:00,639 --> 00:09:06,519
thing so we have again a piece of

00:09:03,999 --> 00:09:09,999
hardware running firmware that you're

00:09:06,519 --> 00:09:13,079
familiar with for a BMC without with the

00:09:09,999 --> 00:09:15,129
few surprises we have we do have a few

00:09:13,079 --> 00:09:18,100
additions to that firmware that's

00:09:15,129 --> 00:09:19,779
specific to having power machines but if

00:09:18,100 --> 00:09:22,600
you're doing a deployment of an open

00:09:19,779 --> 00:09:24,100
power cluster you often will not need to

00:09:22,600 --> 00:09:26,079
use any of these at all but but we are

00:09:24,100 --> 00:09:29,889
we are documenting those and watch this

00:09:26,079 --> 00:09:32,199
space for for that list of om commands

00:09:29,889 --> 00:09:33,759
that might be specific power now Chris

00:09:32,199 --> 00:09:34,779
Austin is going to disrupt all this and

00:09:33,759 --> 00:09:38,170
he's going to give to talk about that

00:09:34,779 --> 00:09:39,250
soon so that'll be quite coordination

00:09:38,170 --> 00:09:42,309
see what we're sort of bringing this

00:09:39,250 --> 00:09:45,370
into the open source space that's a tip

00:09:42,309 --> 00:09:47,410
today thank you very much and some

00:09:45,370 --> 00:09:50,230
resources for for following up on this

00:09:47,410 --> 00:09:53,309
or have a chat after the after the

00:09:50,230 --> 00:09:53,309

YouTube URL: https://www.youtube.com/watch?v=2TroT3ORw0s


