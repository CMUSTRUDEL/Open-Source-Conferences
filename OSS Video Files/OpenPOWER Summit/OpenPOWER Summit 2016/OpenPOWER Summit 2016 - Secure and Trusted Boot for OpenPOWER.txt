Title: OpenPOWER Summit 2016 - Secure and Trusted Boot for OpenPOWER
Publication date: 2016-04-29
Playlist: OpenPOWER Summit 2016
Description: 
	Presented by Dean Sanner of  IBM
Captions: 
	00:00:00,290 --> 00:00:07,740
hello well thank you I'm Dean Sandra

00:00:03,120 --> 00:00:10,950
from IBM and I do most of the firmware

00:00:07,740 --> 00:00:13,650
architecture for booting up the PAP

00:00:10,950 --> 00:00:16,350
processors and what I'm going to be

00:00:13,650 --> 00:00:20,130
talking about today is the hooks that

00:00:16,350 --> 00:00:22,380
the team has put into the p8 processor

00:00:20,130 --> 00:00:24,330
that we plan to take advantage of to

00:00:22,380 --> 00:00:31,679
create the core root of trust for secure

00:00:24,330 --> 00:00:34,410
and trusted boot so first of all a few

00:00:31,679 --> 00:00:36,120
principles on what we want to do so one

00:00:34,410 --> 00:00:38,430
of the guiding principles we have is

00:00:36,120 --> 00:00:41,520
that all the flash all the code in the

00:00:38,430 --> 00:00:43,649
flash is by definition validated prior

00:00:41,520 --> 00:00:45,870
to execution so we never execute

00:00:43,649 --> 00:00:48,690
directly from flash we always bring it

00:00:45,870 --> 00:00:51,480
into secure memory validated and then

00:00:48,690 --> 00:00:54,660
executed so that kind of bases our

00:00:51,480 --> 00:00:57,570
design point the design is also built

00:00:54,660 --> 00:01:00,120
around various layers of trust each boot

00:00:57,570 --> 00:01:02,010
starts from a clean State so everything

00:01:00,120 --> 00:01:04,049
is wiped when you go through a boot

00:01:02,010 --> 00:01:07,020
cycle and then we established the core

00:01:04,049 --> 00:01:09,000
root of trust so that involves the sell

00:01:07,020 --> 00:01:10,860
food engine and I've got some follow-on

00:01:09,000 --> 00:01:12,119
charts that explain that in more detail

00:01:10,860 --> 00:01:13,979
and I'll walk through each individual

00:01:12,119 --> 00:01:15,150
step and then the host boot base image

00:01:13,979 --> 00:01:17,900
which is the first thing that gets

00:01:15,150 --> 00:01:21,930
loaded into the PA processors memory

00:01:17,900 --> 00:01:23,700
after that the lower layers verify the

00:01:21,930 --> 00:01:26,700
subsequent layers so as you can kind of

00:01:23,700 --> 00:01:30,799
see we build up that chain of trust as

00:01:26,700 --> 00:01:33,570
we continue to boot the processor up the

00:01:30,799 --> 00:01:35,790
very lowest layer of the core root of

00:01:33,570 --> 00:01:39,540
trust resides and what we call the

00:01:35,790 --> 00:01:41,490
processor prom assy prom which has this

00:01:39,540 --> 00:01:44,369
health food engine the espy's code that

00:01:41,490 --> 00:01:47,130
resides in it now this code is updatable

00:01:44,369 --> 00:01:49,439
only by a verified host boot so we kind

00:01:47,130 --> 00:01:50,490
of only can update the see prom by

00:01:49,439 --> 00:01:53,970
something that's already been passed

00:01:50,490 --> 00:01:57,719
through the chain of trust so you may

00:01:53,970 --> 00:01:59,549
ask how do we when we or one of the key

00:01:57,719 --> 00:02:02,880
points that we've been asked many times

00:01:59,549 --> 00:02:05,610
is do you have to have the IBM keys to

00:02:02,880 --> 00:02:07,910
boot the actual processor and know what

00:02:05,610 --> 00:02:10,349
we want to do is we want to have a very

00:02:07,910 --> 00:02:11,910
private public key what we're calling

00:02:10,349 --> 00:02:13,950
the imprint key that

00:02:11,910 --> 00:02:16,080
all the processors will ship with that

00:02:13,950 --> 00:02:18,350
you can then customize and replace with

00:02:16,080 --> 00:02:21,480
your own set of keys so all the code

00:02:18,350 --> 00:02:23,310
from with all the host code up is open

00:02:21,480 --> 00:02:24,750
source so you can download that you can

00:02:23,310 --> 00:02:26,790
compile it you can look at it you can

00:02:24,750 --> 00:02:30,090
touch it you can check it out see if

00:02:26,790 --> 00:02:32,310
there's any bugs security holes and you

00:02:30,090 --> 00:02:36,390
can then sign it with your own key that

00:02:32,310 --> 00:02:37,740
you can pass up from your manufacturing

00:02:36,390 --> 00:02:41,190
standpoint or if you want to allow you

00:02:37,740 --> 00:02:44,640
your customers to be able to sign with

00:02:41,190 --> 00:02:46,950
their own key so what I'm going to do

00:02:44,640 --> 00:02:52,130
now is I'm going to walk through the

00:02:46,950 --> 00:02:54,750
basic flow of how we plan to use the

00:02:52,130 --> 00:02:56,610
hooks in the processor to establish a

00:02:54,750 --> 00:03:00,090
chain of trust so a couple of points the

00:02:56,610 --> 00:03:01,410
actual chart the read of things and

00:03:00,090 --> 00:03:02,940
there's this Pino right here is the

00:03:01,410 --> 00:03:05,460
processor Noor that's the flash that we

00:03:02,940 --> 00:03:07,110
use to do off of the red things are all

00:03:05,460 --> 00:03:09,390
the untrusted stuff so when it's read

00:03:07,110 --> 00:03:11,100
it's not not trusted if you look at the

00:03:09,390 --> 00:03:13,530
green areas those are the things that

00:03:11,100 --> 00:03:15,720
are we call trusted entities in the

00:03:13,530 --> 00:03:17,550
system so from a hardware standpoint are

00:03:15,720 --> 00:03:20,430
the things that are in green are trusted

00:03:17,550 --> 00:03:23,790
and if you notice the prom right here is

00:03:20,430 --> 00:03:26,100
actually inside the p8 module so by

00:03:23,790 --> 00:03:28,170
definition you can't walk up to it and

00:03:26,100 --> 00:03:30,450
program it you actually have to pull the

00:03:28,170 --> 00:03:32,580
socket off of the system in order to

00:03:30,450 --> 00:03:35,820
update that prom so when you start the

00:03:32,580 --> 00:03:38,070
boot on a PA chip the first thing that

00:03:35,820 --> 00:03:40,920
executes is this SPE code right here

00:03:38,070 --> 00:03:42,959
go fetches the instructions from the

00:03:40,920 --> 00:03:45,030
prom out there and in what it does is it

00:03:42,959 --> 00:03:47,760
does the basic initialization of the

00:03:45,030 --> 00:03:49,890
hardware goes through and does the basic

00:03:47,760 --> 00:03:51,870
chip initialization gets the core to the

00:03:49,890 --> 00:03:54,959
point where the core is ready to execute

00:03:51,870 --> 00:03:57,450
instructions it also resets the TPM

00:03:54,959 --> 00:03:59,100
right down there and then the other key

00:03:57,450 --> 00:04:01,050
thing that it does is it takes the key

00:03:59,100 --> 00:04:03,330
which resides in this C prom right there

00:04:01,050 --> 00:04:05,670
which is which can be updated by a

00:04:03,330 --> 00:04:08,070
validated host and moves it into what we

00:04:05,670 --> 00:04:10,709
call the pip mem pervasive interface bus

00:04:08,070 --> 00:04:12,630
memory it's just a little storage space

00:04:10,709 --> 00:04:16,709
inside the chip that can be used as

00:04:12,630 --> 00:04:19,770
temporary storage and we do that to make

00:04:16,709 --> 00:04:21,419
it accessible to the next step

00:04:19,770 --> 00:04:24,400
later on when we actually going to use

00:04:21,419 --> 00:04:26,710
this ROM secure veil validation code

00:04:24,400 --> 00:04:28,600
so after that is done the SP will then

00:04:26,710 --> 00:04:30,850
reach out into Pienaar will pull in the

00:04:28,600 --> 00:04:33,490
host boot base image it'll move the

00:04:30,850 --> 00:04:36,370
untrusted host boot base image into the

00:04:33,490 --> 00:04:38,560
l3 cache now at this point in time the

00:04:36,370 --> 00:04:40,030
processor hasn't anything executed or

00:04:38,560 --> 00:04:42,780
has started instructions on that cache

00:04:40,030 --> 00:04:46,030
it's just sitting out there

00:04:42,780 --> 00:04:49,500
after that the SPE will then issue the

00:04:46,030 --> 00:04:51,490
command to start the core the core will

00:04:49,500 --> 00:04:53,770
part of the part of the hardware design

00:04:51,490 --> 00:04:55,960
in pH is that when you issue these start

00:04:53,770 --> 00:04:58,449
instructions on a core it will then

00:04:55,960 --> 00:04:59,650
automatically jump to the ROM so even if

00:04:58,449 --> 00:05:01,720
the next instruction pointer is pointing

00:04:59,650 --> 00:05:03,669
in somewhere in memory the first time

00:05:01,720 --> 00:05:06,820
you start it it goes immediately to the

00:05:03,669 --> 00:05:09,760
rom code which is a built-in security

00:05:06,820 --> 00:05:11,169
hash algorithm so that ROM code will

00:05:09,760 --> 00:05:13,930
actually use a couple of pieces

00:05:11,169 --> 00:05:16,600
information from the SPE that's been

00:05:13,930 --> 00:05:18,820
placed into some of the registers in the

00:05:16,600 --> 00:05:21,400
core to find the host boot date base

00:05:18,820 --> 00:05:24,039
image find the the key that it should be

00:05:21,400 --> 00:05:26,800
validated against and that and verify

00:05:24,039 --> 00:05:29,800
that that image that was placed in the

00:05:26,800 --> 00:05:32,740
memory is okay per the key if that is

00:05:29,800 --> 00:05:34,900
true then it'll move it to I'll call it

00:05:32,740 --> 00:05:38,200
a secure location or a trusted location

00:05:34,900 --> 00:05:40,539
and that changes the code from untrusted

00:05:38,200 --> 00:05:43,539
to trust it so at this point in time we

00:05:40,539 --> 00:05:45,130
verify the host base image and we're

00:05:43,539 --> 00:05:46,840
ready to start actually executing that

00:05:45,130 --> 00:05:49,120
so after the round finishes its

00:05:46,840 --> 00:05:53,020
execution it then jumps to the entry

00:05:49,120 --> 00:05:55,830
point of the base image then what

00:05:53,020 --> 00:05:59,110
happens is the host boot base image will

00:05:55,830 --> 00:06:01,449
load in and use the host food extended

00:05:59,110 --> 00:06:04,750
image so the hospital is just 512

00:06:01,449 --> 00:06:07,389
kilobytes of code if there's a lot more

00:06:04,750 --> 00:06:08,940
code that's needed to validate and

00:06:07,389 --> 00:06:10,960
actually boot up the rest of the system

00:06:08,940 --> 00:06:15,699
so the host boot base image will

00:06:10,960 --> 00:06:18,580
actually contain pages or a hash of each

00:06:15,699 --> 00:06:21,010
page that resides in the hospita at

00:06:18,580 --> 00:06:22,930
image so the for when we pull in a host

00:06:21,010 --> 00:06:25,330
page to room the host boot extended

00:06:22,930 --> 00:06:28,419
giman image into the cache we will

00:06:25,330 --> 00:06:29,740
validate that that hash key matches what

00:06:28,419 --> 00:06:31,270
it's supposed to match what's already

00:06:29,740 --> 00:06:33,219
been verified by the host boot base

00:06:31,270 --> 00:06:35,349
image so this way we can guarantee as we

00:06:33,219 --> 00:06:37,450
page things in and out of the cache that

00:06:35,349 --> 00:06:37,750
the code we are executing is actually

00:06:37,450 --> 00:06:39,130
true

00:06:37,750 --> 00:06:42,940
before we go and actually do anything

00:06:39,130 --> 00:06:43,960
with it at this point in time the host

00:06:42,940 --> 00:06:46,330
boot code will then place the

00:06:43,960 --> 00:06:48,760
measurements of all the code that it's

00:06:46,330 --> 00:06:51,310
going to run into the TPM so it just

00:06:48,760 --> 00:06:56,440
this is for attestation later on in the

00:06:51,310 --> 00:06:59,050
in the process at this point in time

00:06:56,440 --> 00:07:01,390
remember I mentioned about the ability

00:06:59,050 --> 00:07:03,280
to actually update the prom code so at

00:07:01,390 --> 00:07:05,440
this point in time the host has the

00:07:03,280 --> 00:07:08,050
ability to update the the see prom code

00:07:05,440 --> 00:07:09,790
that resides in the module this is kind

00:07:08,050 --> 00:07:12,550
of like a fail-safe if something changes

00:07:09,790 --> 00:07:14,080
in the processor initialization or if

00:07:12,550 --> 00:07:17,590
there's a bug somewhere in the processor

00:07:14,080 --> 00:07:20,010
that needs updating it can take the SBE

00:07:17,590 --> 00:07:22,240
code image that resides in the nor

00:07:20,010 --> 00:07:24,430
validate that yeah okay it matches the

00:07:22,240 --> 00:07:26,710
key that I currently expect and if that

00:07:24,430 --> 00:07:28,960
passes then it can actually write new

00:07:26,710 --> 00:07:31,390
code out into the prom and this is also

00:07:28,960 --> 00:07:32,740
how you can update the key if you need

00:07:31,390 --> 00:07:34,270
to update the key so when I talk about

00:07:32,740 --> 00:07:37,270
the imprint key since the well-known

00:07:34,270 --> 00:07:39,820
private public private you can sign an

00:07:37,270 --> 00:07:42,490
SPE image that contains your own key

00:07:39,820 --> 00:07:45,850
into the Pienaar and have it push it up

00:07:42,490 --> 00:07:48,010
into the the c prom and then when you

00:07:45,850 --> 00:07:51,820
reboot that new key will be used to

00:07:48,010 --> 00:07:54,930
verify the next version of the of the

00:07:51,820 --> 00:07:57,310
penal code after this is done

00:07:54,930 --> 00:08:01,360
what will happen is host boot will then

00:07:57,310 --> 00:08:03,160
lock down the prom code after that point

00:08:01,360 --> 00:08:05,410
nothing in the system can update that

00:08:03,160 --> 00:08:07,900
that C prom and you have to go through a

00:08:05,410 --> 00:08:09,310
complete full reboot to re-establish

00:08:07,900 --> 00:08:13,810
your chain of trust before that prom

00:08:09,310 --> 00:08:15,910
code can be updated after that the host

00:08:13,810 --> 00:08:18,760
boot will go off and train the power bus

00:08:15,910 --> 00:08:20,830
and the the memory controller and starts

00:08:18,760 --> 00:08:23,229
the other micro engines in the system so

00:08:20,830 --> 00:08:25,720
the sleep sleep Winkle and the OCC each

00:08:23,229 --> 00:08:26,770
of those have their own code image they

00:08:25,720 --> 00:08:29,530
will all be verified and validated

00:08:26,770 --> 00:08:32,320
before each of those is released to

00:08:29,530 --> 00:08:33,909
actually start executing then what

00:08:32,320 --> 00:08:36,940
happens the same process keeps on

00:08:33,909 --> 00:08:38,409
happening as as they've get validated

00:08:36,940 --> 00:08:40,780
all the measurements get placed into the

00:08:38,409 --> 00:08:42,700
TPM I just didn't show that then what we

00:08:40,780 --> 00:08:44,890
will do is we will load in the opal code

00:08:42,700 --> 00:08:47,470
we'll verify it

00:08:44,890 --> 00:08:49,180
bring it up and you can also have the

00:08:47,470 --> 00:08:49,839
processor open up an untrusted window if

00:08:49,180 --> 00:08:51,160
you want to do

00:08:49,839 --> 00:08:53,230
BMC or some

00:08:51,160 --> 00:08:54,970
to communication but the host has

00:08:53,230 --> 00:08:56,310
control over where that window is and

00:08:54,970 --> 00:08:58,990
how big it is

00:08:56,310 --> 00:09:00,129
so at base this gets us up to the point

00:08:58,990 --> 00:09:02,170
where Opel is loaded

00:09:00,129 --> 00:09:04,269
they will then verify petty boot and

00:09:02,170 --> 00:09:06,100
continue on as you can see I don't go

00:09:04,269 --> 00:09:08,199
into any of the Linux implementation

00:09:06,100 --> 00:09:13,329
just as to how the core root of trust is

00:09:08,199 --> 00:09:15,490
established and then Linux takes over so

00:09:13,329 --> 00:09:17,170
future secure boot plans so what I just

00:09:15,490 --> 00:09:20,290
went through was a p8 version of that

00:09:17,170 --> 00:09:23,740
for p9 we've got some changes in flight

00:09:20,290 --> 00:09:26,740
one is is that right now the on p8 the

00:09:23,740 --> 00:09:29,439
SBE is just a binary image out in github

00:09:26,740 --> 00:09:31,930
for p9 we are planning on open sourcing

00:09:29,439 --> 00:09:33,370
that SBE image so you'll actually be

00:09:31,930 --> 00:09:35,790
able to compile it and change it and

00:09:33,370 --> 00:09:38,019
modify it and it gives more transparent

00:09:35,790 --> 00:09:41,500
transparence transparency from a

00:09:38,019 --> 00:09:44,649
security standpoint we're also planning

00:09:41,500 --> 00:09:46,779
on eliminating the on chip ROM so for p8

00:09:44,649 --> 00:09:48,579
the security algorithm was burned into

00:09:46,779 --> 00:09:51,100
the actual hardware while we are

00:09:48,579 --> 00:09:54,639
planning on doing for p9 is that

00:09:51,100 --> 00:09:56,439
security algorithm will now be loaded

00:09:54,639 --> 00:09:58,689
will be placed in the actual c-prime

00:09:56,439 --> 00:10:00,189
itself so it's kind of got the same idea

00:09:58,689 --> 00:10:02,170
that you can place the key and the

00:10:00,189 --> 00:10:04,750
security you go over algorithm into the

00:10:02,170 --> 00:10:06,279
seat pram and keep it keep it secure

00:10:04,750 --> 00:10:09,009
with the same chain of trust as we did

00:10:06,279 --> 00:10:12,399
for p8 this allows for a customization

00:10:09,009 --> 00:10:13,870
of security code once again only only

00:10:12,399 --> 00:10:16,630
the chain of trust can update the prom

00:10:13,870 --> 00:10:18,519
the loader and the actual algorithm then

00:10:16,630 --> 00:10:21,519
run on the host processor kind of in the

00:10:18,519 --> 00:10:23,380
same same mentality or flow firmware

00:10:21,519 --> 00:10:28,209
headin on p9 also has better control

00:10:23,380 --> 00:10:29,769
over the unsecured window so when are we

00:10:28,209 --> 00:10:34,230
planning on getting all this implemented

00:10:29,769 --> 00:10:36,610
so for p8 we are targeting a limited p8

00:10:34,230 --> 00:10:39,970
trusted boot functionality by the end of

00:10:36,610 --> 00:10:41,769
this year what we plan on doing is once

00:10:39,970 --> 00:10:44,350
we enable that out and github will start

00:10:41,769 --> 00:10:46,360
shipping the p8 modules with imprint

00:10:44,350 --> 00:10:49,439
keys I haven't worked out all the exact

00:10:46,360 --> 00:10:52,240
details but we are in the process of

00:10:49,439 --> 00:10:54,160
putting to that code together so if you

00:10:52,240 --> 00:10:55,990
have any ideas or questions or concerns

00:10:54,160 --> 00:10:58,389
please let me know please contact me

00:10:55,990 --> 00:10:59,709
after after I'm done talking I'll be in

00:10:58,389 --> 00:11:02,649
the back you can ask any questions that

00:10:59,709 --> 00:11:04,390
you want I also should note that our

00:11:02,649 --> 00:11:06,400
current implementation

00:11:04,390 --> 00:11:08,290
we're compliant with the TPM 2.0

00:11:06,400 --> 00:11:11,140
architecture measurement and logging

00:11:08,290 --> 00:11:13,360
it's specific to an i2c bus I know

00:11:11,140 --> 00:11:19,110
there's some other interest in doing the

00:11:13,360 --> 00:11:19,110

YouTube URL: https://www.youtube.com/watch?v=43Mg-GoVMT8


