Title: Enabling instrumentation using programmable on-chip components to monitor sensors
Publication date: 2016-04-29
Playlist: OpenPOWER Summit 2016
Description: 
	OpenPOWER Summit 2016
Presented by Shilpasri G Bhat of IBM
Captions: 
	00:00:00,000 --> 00:00:04,380
so this this talk I'm filling in for my

00:00:02,399 --> 00:00:06,089
colleagues your party talking about

00:00:04,380 --> 00:00:08,490
programming on ship components to

00:00:06,089 --> 00:00:11,429
retrieve sensor data which is lovely

00:00:08,490 --> 00:00:14,009
low-level stuff and is a really good

00:00:11,429 --> 00:00:16,680
example of sort of how an open ecosystem

00:00:14,009 --> 00:00:18,869
and you know open power itself can

00:00:16,680 --> 00:00:21,090
enable sort of innovation and thinking

00:00:18,869 --> 00:00:28,050
outside the box even within a company

00:00:21,090 --> 00:00:29,279
like IBM but let's go it's a bit of a

00:00:28,050 --> 00:00:32,309
gender what will go through talking

00:00:29,279 --> 00:00:34,050
about getting senses through here and in

00:00:32,309 --> 00:00:35,670
and out of the OCC and how he can

00:00:34,050 --> 00:00:38,670
actually take something that is

00:00:35,670 --> 00:00:39,809
currently a higher latency way of

00:00:38,670 --> 00:00:43,620
getting measurements and turning into

00:00:39,809 --> 00:00:46,079
something as much lower latency on a

00:00:43,620 --> 00:00:48,390
basic level sort of open power provides

00:00:46,079 --> 00:00:50,940
us a platform to program on chip

00:00:48,390 --> 00:00:53,520
components right I mean a power a chip

00:00:50,940 --> 00:00:55,920
has many many many different parts of it

00:00:53,520 --> 00:00:58,739
that can execute instructions so there's

00:00:55,920 --> 00:01:01,170
everything from the on-chip controller

00:00:58,739 --> 00:01:03,960
which is an embedded PowerPC 405 chip

00:01:01,170 --> 00:01:06,060
which does the hard thermal limits and

00:01:03,960 --> 00:01:08,520
hard power usage limits there's general

00:01:06,060 --> 00:01:09,840
purpose engines at the OCC use to do

00:01:08,520 --> 00:01:13,170
some real-time stuff there's the sleep

00:01:09,840 --> 00:01:16,290
Winkle engine which is used to turn on

00:01:13,170 --> 00:01:18,090
and off cause so when you have low power

00:01:16,290 --> 00:01:19,740
modes that Linux will say hey I'm not

00:01:18,090 --> 00:01:21,600
using that cork and power it down and

00:01:19,740 --> 00:01:23,820
then power it back up there's a self

00:01:21,600 --> 00:01:27,270
boot engine which is a tiny little micro

00:01:23,820 --> 00:01:29,340
controller that starts the chip up and

00:01:27,270 --> 00:01:31,079
of course you have the power processes

00:01:29,340 --> 00:01:33,930
themselves which is what everyone

00:01:31,079 --> 00:01:35,640
recognizes as your CPU so within your

00:01:33,930 --> 00:01:37,500
CPU you have a bunch of other things

00:01:35,640 --> 00:01:40,079
that look remarkably like CPUs but

00:01:37,500 --> 00:01:41,939
aren't in fact your CPU in fact it is

00:01:40,079 --> 00:01:45,270
Turtles all the way down as you may

00:01:41,939 --> 00:01:47,490
imagine or if you're a Pratchett fan or

00:01:45,270 --> 00:01:50,880
otherwise you will recognize the

00:01:47,490 --> 00:01:54,689
reference so as part of the open power

00:01:50,880 --> 00:01:56,610
firm where we have the OCC code and

00:01:54,689 --> 00:01:58,860
those facilities there to provide

00:01:56,610 --> 00:02:01,140
interfaces to certain sensors right

00:01:58,860 --> 00:02:02,310
there's sensors inside the box that

00:02:01,140 --> 00:02:04,979
measure things everything from

00:02:02,310 --> 00:02:07,560
temperature to voltage to how much

00:02:04,979 --> 00:02:10,349
bandwidth is being used on what bus the

00:02:07,560 --> 00:02:13,920
existing mechanism for reading sensors

00:02:10,349 --> 00:02:16,170
you can do so via ipmi so I PMI is

00:02:13,920 --> 00:02:19,230
standard protocol for talking to BMC's

00:02:16,170 --> 00:02:21,330
the baseband management controller on

00:02:19,230 --> 00:02:24,239
servers and this has been a spec that's

00:02:21,330 --> 00:02:27,510
been around for you know nearly long

00:02:24,239 --> 00:02:29,190
enough to drink in bars but it's quite

00:02:27,510 --> 00:02:31,230
watery but it exists and it's a standard

00:02:29,190 --> 00:02:32,670
that's cross-platform so there's ipmi

00:02:31,230 --> 00:02:36,450
tool you can run from another machine

00:02:32,670 --> 00:02:38,239
and interrogate the power system or any

00:02:36,450 --> 00:02:41,040
other system and you can use this

00:02:38,239 --> 00:02:42,660
wonderful interface and wonderful I mean

00:02:41,040 --> 00:02:44,940
absolutely awful and not user friendly

00:02:42,660 --> 00:02:47,519
at all called ipmi tool drawer where you

00:02:44,940 --> 00:02:49,350
jump in a bunch of magic hex values that

00:02:47,519 --> 00:02:51,360
looks oddly like having to make a

00:02:49,350 --> 00:02:53,489
sacrifice to get data out but you you

00:02:51,360 --> 00:02:55,260
get something back from it and what

00:02:53,489 --> 00:02:57,030
that's doing is asking the BMC to get a

00:02:55,260 --> 00:02:59,519
sense of value out and the way it works

00:02:57,030 --> 00:03:01,260
is this so outbound opium eyes you have

00:02:59,519 --> 00:03:02,670
an external node so like you know your

00:03:01,260 --> 00:03:06,269
laptop or your management computer

00:03:02,670 --> 00:03:07,890
talking over a network to the BMC inside

00:03:06,269 --> 00:03:10,950
the computer and then there's a direct

00:03:07,890 --> 00:03:12,810
interaction with the OCC so the OCC will

00:03:10,950 --> 00:03:15,090
get data from a bunch of sensors and

00:03:12,810 --> 00:03:16,830
then tell the BMC about it and then you

00:03:15,090 --> 00:03:18,840
can ask the BMC for those sensors and

00:03:16,830 --> 00:03:20,430
this is sort of out of band getting

00:03:18,840 --> 00:03:22,799
sensor data so you could ask you know

00:03:20,430 --> 00:03:29,100
what's the temperature of the processor

00:03:22,799 --> 00:03:31,560
and it would tell you there's also the

00:03:29,100 --> 00:03:34,680
ability to read they sent some of these

00:03:31,560 --> 00:03:39,120
sensors in band there is in band ipmi so

00:03:34,680 --> 00:03:42,840
that's directly talking from the host to

00:03:39,120 --> 00:03:44,579
it himself so here you have running on

00:03:42,840 --> 00:03:46,230
this on an OS that's running on the

00:03:44,579 --> 00:03:48,540
power 8 chip so you could be on a bun to

00:03:46,230 --> 00:03:51,480
on the ship on the machine rather than

00:03:48,540 --> 00:03:53,310
using a remote machine and say hey what

00:03:51,480 --> 00:03:55,470
is the current temperature on this

00:03:53,310 --> 00:03:57,209
machine so that's sort of an in-band

00:03:55,470 --> 00:03:59,190
rather than out-of-band so we say in

00:03:57,209 --> 00:04:01,859
band it's running on the machine you're

00:03:59,190 --> 00:04:05,130
looking at out of band is getting it a

00:04:01,859 --> 00:04:07,019
different machine so this way you would

00:04:05,130 --> 00:04:09,299
do it you know SSH to the box and find

00:04:07,019 --> 00:04:11,160
the information there and in this case

00:04:09,299 --> 00:04:13,079
the current sort of in band method for

00:04:11,160 --> 00:04:16,079
getting these these sensors would be

00:04:13,079 --> 00:04:18,539
that you'd run ipmi tool which would

00:04:16,079 --> 00:04:20,880
talk to the host linux kernel which

00:04:18,539 --> 00:04:23,340
would then call a firmware routine which

00:04:20,880 --> 00:04:26,099
then asked the BMC for the sensor data

00:04:23,340 --> 00:04:27,690
so as you can imagine with this sort of

00:04:26,099 --> 00:04:29,430
round trip there are seven

00:04:27,690 --> 00:04:30,810
well round trips in several layers

00:04:29,430 --> 00:04:33,060
you're going through and in fact you're

00:04:30,810 --> 00:04:35,010
asking for a property of you know the PA

00:04:33,060 --> 00:04:37,440
chip and you're going out to a separate

00:04:35,010 --> 00:04:38,580
processor inside the box to find out

00:04:37,440 --> 00:04:40,850
what's going on so you can imagine

00:04:38,580 --> 00:04:43,140
there's a large amount of latency there

00:04:40,850 --> 00:04:44,670
so well this gives you the joy of being

00:04:43,140 --> 00:04:47,340
out at the same sense of data as you can

00:04:44,670 --> 00:04:52,160
get out of band it does have a higher

00:04:47,340 --> 00:04:56,070
latency costs and the way this works is

00:04:52,160 --> 00:04:57,990
that the occ will use scom sitcoms are

00:04:56,070 --> 00:04:59,640
simply just a way of talking to

00:04:57,990 --> 00:05:03,650
different components inside the PA chip

00:04:59,640 --> 00:05:03,650
that's largely an implementation detail

00:05:04,220 --> 00:05:09,420
inside inside the the PA of course you

00:05:07,980 --> 00:05:10,950
have to have ways to communicate with

00:05:09,420 --> 00:05:15,390
different components inside the chip

00:05:10,950 --> 00:05:17,460
this is ours does anyone want a large

00:05:15,390 --> 00:05:18,900
long detailed version of what's coms

00:05:17,460 --> 00:05:21,390
doing what everything is there because

00:05:18,900 --> 00:05:25,530
if so there's a bar and we should talk

00:05:21,390 --> 00:05:29,790
there it doesn't fit into 15 minutes at

00:05:25,530 --> 00:05:31,830
all and the main thing here is you have

00:05:29,790 --> 00:05:33,960
like the digital sensors or analog

00:05:31,830 --> 00:05:35,880
sensors inside the system and through

00:05:33,960 --> 00:05:38,880
scrums you can have code that reads that

00:05:35,880 --> 00:05:41,010
so the OCC can use this method to then

00:05:38,880 --> 00:05:42,720
get the data and then they can export it

00:05:41,010 --> 00:05:44,820
through some method and we want to

00:05:42,720 --> 00:05:46,890
export this internet that's lower

00:05:44,820 --> 00:05:48,419
latency than just going all the way

00:05:46,890 --> 00:05:49,800
through the BMC so instead of just

00:05:48,419 --> 00:05:53,880
sending it to the BMC we could do

00:05:49,800 --> 00:06:00,660
something else for reading sensors in

00:05:53,880 --> 00:06:02,250
band we want to provide an interface to

00:06:00,660 --> 00:06:04,890
read the values of this through

00:06:02,250 --> 00:06:07,440
something that's standard right so for

00:06:04,890 --> 00:06:09,570
out of band monitoring ipmi is the

00:06:07,440 --> 00:06:11,340
current industry standard for in band

00:06:09,570 --> 00:06:12,750
like if you're on a Linux system and

00:06:11,340 --> 00:06:14,880
you're wanting to know what's going on

00:06:12,750 --> 00:06:17,730
on it there are existing Linux kernel

00:06:14,880 --> 00:06:19,800
interfaces for how to do that you can

00:06:17,730 --> 00:06:21,570
get some sensor data through perf so

00:06:19,800 --> 00:06:23,280
perf is very much performance counter

00:06:21,570 --> 00:06:25,050
oriented as and you want to know you

00:06:23,280 --> 00:06:26,669
know how many instructions per cycle are

00:06:25,050 --> 00:06:29,100
being executed on a core let's say or

00:06:26,669 --> 00:06:31,110
how many l2 cache misses mrs. have been

00:06:29,100 --> 00:06:32,730
occurring perf has a standard interface

00:06:31,110 --> 00:06:35,280
for this so you type down in your system

00:06:32,730 --> 00:06:37,919
perf and then magic happens and you get

00:06:35,280 --> 00:06:40,569
sensors right there is also the hardware

00:06:37,919 --> 00:06:42,039
mon / LMK sensors interface

00:06:40,569 --> 00:06:43,960
and this is a way of getting other

00:06:42,039 --> 00:06:45,729
sensor information from a running Linux

00:06:43,960 --> 00:06:48,339
system and you can run this like on your

00:06:45,729 --> 00:06:50,529
x86 laptop and this is just the exact

00:06:48,339 --> 00:06:52,869
same kernel interface so you can run /

00:06:50,529 --> 00:06:55,539
on your laptop and I run / f on my

00:06:52,869 --> 00:06:57,580
laptop and I run / 4 on my power systems

00:06:55,539 --> 00:06:59,469
and it uses the same kernel interfaces

00:06:57,580 --> 00:07:01,779
so it's just standard and we don't have

00:06:59,469 --> 00:07:03,610
anything you know power specific on the

00:07:01,779 --> 00:07:06,879
user space side or from a user point of

00:07:03,610 --> 00:07:09,339
view it just works and what we want to

00:07:06,879 --> 00:07:11,169
do is have these other senses that we

00:07:09,339 --> 00:07:15,459
have in the system available through

00:07:11,169 --> 00:07:18,729
these same interfaces so why would we

00:07:15,459 --> 00:07:20,289
want to do this the big key is that we

00:07:18,729 --> 00:07:22,300
want to profile workloads that are

00:07:20,289 --> 00:07:24,009
running on a system for many reasons you

00:07:22,300 --> 00:07:25,479
might want to profile a workload you

00:07:24,009 --> 00:07:27,879
might want to profile it for performance

00:07:25,479 --> 00:07:29,680
as in are you using the hardware to its

00:07:27,879 --> 00:07:31,959
full capability or you may want to

00:07:29,680 --> 00:07:34,509
profile at full power consumption as in

00:07:31,959 --> 00:07:37,449
are we doing a workload in a certain

00:07:34,509 --> 00:07:38,769
power envelope and you may want to use

00:07:37,449 --> 00:07:42,490
this to feed back in to make your code

00:07:38,769 --> 00:07:44,499
better or two then iterate on hardware

00:07:42,490 --> 00:07:46,539
designs and go well this workload isn't

00:07:44,499 --> 00:07:49,689
using the chip to its full potential how

00:07:46,539 --> 00:07:51,550
can we change the chip so it does so you

00:07:49,689 --> 00:07:53,830
can have that from a perspective of an

00:07:51,550 --> 00:07:56,019
application developer why do you need to

00:07:53,830 --> 00:07:58,990
profile it or from you know chip

00:07:56,019 --> 00:08:00,969
designers and go back to them and go

00:07:58,990 --> 00:08:04,959
well if you change the chip this way

00:08:00,969 --> 00:08:08,829
we'll use more of it and the other issue

00:08:04,959 --> 00:08:10,899
of course is that there's this small

00:08:08,829 --> 00:08:13,749
issue of when you observe a system you

00:08:10,899 --> 00:08:15,699
may change what's going on so you want

00:08:13,749 --> 00:08:19,289
to do this in the minimal impact way

00:08:15,699 --> 00:08:21,519
possible and so we don't want to have

00:08:19,289 --> 00:08:22,899
large amounts of changing to how the

00:08:21,519 --> 00:08:26,709
system operates just to measure what

00:08:22,899 --> 00:08:28,269
it's doing so we do want to reduce the

00:08:26,709 --> 00:08:30,129
latency involved in reading the platform

00:08:28,269 --> 00:08:32,409
sensor data and this also it means we

00:08:30,129 --> 00:08:34,180
get much finer grained information right

00:08:32,409 --> 00:08:35,620
if it takes a second to read a value

00:08:34,180 --> 00:08:37,870
then you only have per second

00:08:35,620 --> 00:08:40,659
granularity and on a modern system you

00:08:37,870 --> 00:08:42,699
know on a PA chip 10 cores 4 gigahertz 8

00:08:40,659 --> 00:08:46,000
threads per core a lot happens in a

00:08:42,699 --> 00:08:47,560
second right like billions of things

00:08:46,000 --> 00:08:50,280
happen in a second so that's obviously

00:08:47,560 --> 00:08:53,800
the smaller

00:08:50,280 --> 00:08:55,420
late see we have lower overhead the more

00:08:53,800 --> 00:08:59,320
data points we can gather and make

00:08:55,420 --> 00:09:01,720
intelligent decisions we can also then

00:08:59,320 --> 00:09:03,310
export that data out to the world right

00:09:01,720 --> 00:09:05,910
if we have standard Linux interfaces

00:09:03,310 --> 00:09:07,960
this means that other software such as

00:09:05,910 --> 00:09:10,990
OpenStack can use standard Linux

00:09:07,960 --> 00:09:13,600
interfaces to get a platform-specific

00:09:10,990 --> 00:09:16,900
sensor data and callate that across a

00:09:13,600 --> 00:09:18,610
cloud which may be not just power chips

00:09:16,900 --> 00:09:20,350
it could be x86 chips could be armed

00:09:18,610 --> 00:09:23,790
ships it could be any other kind of chip

00:09:20,350 --> 00:09:23,790
that also had fences

00:09:24,570 --> 00:09:30,910
yeah there's a preference for power

00:09:26,560 --> 00:09:33,310
chips but like mate may not be let yet

00:09:30,910 --> 00:09:35,920
on on on all situations we'll see how we

00:09:33,310 --> 00:09:37,810
go but having the standard interfaces

00:09:35,920 --> 00:09:39,700
means that someone developing this

00:09:37,810 --> 00:09:42,160
tooling for OpenStack doesn't have to

00:09:39,700 --> 00:09:44,010
care about any specific of a power CPU

00:09:42,160 --> 00:09:46,420
they just get standard interfaces that

00:09:44,010 --> 00:09:47,590
are accurate and don't affect

00:09:46,420 --> 00:09:49,570
performance the last thing you want to

00:09:47,590 --> 00:09:51,550
do is go I'm going to monitor my cloud

00:09:49,570 --> 00:09:55,840
and suddenly your performance drops by

00:09:51,550 --> 00:09:57,900
half that's not what you want so what is

00:09:55,840 --> 00:10:01,000
the actual latency we're talking about

00:09:57,900 --> 00:10:03,340
so if we look at in band occ sensor so

00:10:01,000 --> 00:10:05,500
if we run code directly on the occ to

00:10:03,340 --> 00:10:07,840
pull data from the sensor about 90 90

00:10:05,500 --> 00:10:10,030
seconds to read something if we're doing

00:10:07,840 --> 00:10:11,830
ass come and go we're going to read the

00:10:10,030 --> 00:10:14,800
sensor directly from the host that's

00:10:11,830 --> 00:10:16,960
like 1100 nanoseconds which you may

00:10:14,800 --> 00:10:19,750
notice due to basic maths is a much

00:10:16,960 --> 00:10:21,820
larger number if we're going in band

00:10:19,750 --> 00:10:23,650
ipmi so that means on the command line

00:10:21,820 --> 00:10:27,520
we like we were in a no PMI tool and it

00:10:23,650 --> 00:10:29,560
goes by the BMC to get the sensor 80

00:10:27,520 --> 00:10:32,890
milliseconds you may notice a change in

00:10:29,560 --> 00:10:34,900
units there which is again much longer

00:10:32,890 --> 00:10:38,140
and if we're doing out of band ipmi it's

00:10:34,900 --> 00:10:41,070
even longer again so obviously this

00:10:38,140 --> 00:10:42,850
would take a big effect of what kind of

00:10:41,070 --> 00:10:44,770
timing you can get for reading

00:10:42,850 --> 00:10:46,270
everything as well as how much you're

00:10:44,770 --> 00:10:47,920
affecting the system right if it's going

00:10:46,270 --> 00:10:49,870
to take you're going to run something at

00:10:47,920 --> 00:10:52,150
120 milliseconds and you get to run that

00:10:49,870 --> 00:10:54,250
you know 10 times a second obviously

00:10:52,150 --> 00:10:55,630
instructions and processor resources are

00:10:54,250 --> 00:10:56,980
being used there so you're getting less

00:10:55,630 --> 00:11:02,440
accurate information and you're

00:10:56,980 --> 00:11:05,110
affecting the work load more so the occ

00:11:02,440 --> 00:11:06,940
we've been talking about and that Todd

00:11:05,110 --> 00:11:10,420
and others have spoken about is a tiny

00:11:06,940 --> 00:11:13,780
little pal PC 405 embedded chip so it's

00:11:10,420 --> 00:11:16,210
a CPU in its own right it has 512 k of

00:11:13,780 --> 00:11:18,640
static Ram for those of us who grew up

00:11:16,210 --> 00:11:20,800
on systems that had much less than 512k

00:11:18,640 --> 00:11:22,630
Ram you'll go this is a luxury

00:11:20,800 --> 00:11:25,660
programming environment and now it's

00:11:22,630 --> 00:11:27,670
considered an embedded chip and it takes

00:11:25,660 --> 00:11:30,910
care of power management is its primary

00:11:27,670 --> 00:11:32,590
use it has co processes that are offered

00:11:30,910 --> 00:11:35,290
some work too

00:11:32,590 --> 00:11:39,070
and what it does already is periodically

00:11:35,290 --> 00:11:40,780
read and store many platform sensor data

00:11:39,070 --> 00:11:43,120
and it does this to achieve its core

00:11:40,780 --> 00:11:46,060
goal which is to do hard thermal limits

00:11:43,120 --> 00:11:47,500
and hard power consumption limits so it

00:11:46,060 --> 00:11:49,360
reads you know what is the temperature

00:11:47,500 --> 00:11:51,370
of everything in the system do we have

00:11:49,360 --> 00:11:53,470
to throttle anything so make linux may

00:11:51,370 --> 00:11:55,600
say I want to run at this frequency and

00:11:53,470 --> 00:11:58,120
the occ may read all of the temperatures

00:11:55,600 --> 00:11:59,590
and go we are too hot so we're not going

00:11:58,120 --> 00:12:01,540
to run it that frequency will run at a

00:11:59,590 --> 00:12:03,340
lower frequency that will mean we keep

00:12:01,540 --> 00:12:04,960
within those thermal limits because it

00:12:03,340 --> 00:12:07,090
turns out that you shouldn't get too hot

00:12:04,960 --> 00:12:08,800
machines don't like that and you

00:12:07,090 --> 00:12:10,840
shouldn't chew up too much power because

00:12:08,800 --> 00:12:15,070
it turns out that data centers don't

00:12:10,840 --> 00:12:17,530
like that and this does this at various

00:12:15,070 --> 00:12:19,300
iterations and it has you know hard kind

00:12:17,530 --> 00:12:22,840
of real-time code running there to read

00:12:19,300 --> 00:12:24,490
everything as you go and this is sort of

00:12:22,840 --> 00:12:27,970
how it looks like as a simplified

00:12:24,490 --> 00:12:30,460
diagram the occ itself has its own

00:12:27,970 --> 00:12:33,190
static Ram but it can also talk to main

00:12:30,460 --> 00:12:34,450
memory as well and it will indeed do

00:12:33,190 --> 00:12:40,570
this as an interface to the hosts

00:12:34,450 --> 00:12:42,160
firmware so what can we do well instead

00:12:40,570 --> 00:12:45,130
of having these sensors be out of band

00:12:42,160 --> 00:12:49,240
we can program the occ to copy the other

00:12:45,130 --> 00:12:50,980
sensors we want from the LCC SRAM and

00:12:49,240 --> 00:12:53,050
into main memory at a regular interval

00:12:50,980 --> 00:12:55,300
because the OCC has access to main

00:12:53,050 --> 00:12:57,130
memory we can do that and we can in fact

00:12:55,300 --> 00:12:59,620
add to that list of sensors that goes

00:12:57,130 --> 00:13:02,680
through that we can then Q work on a

00:12:59,620 --> 00:13:04,690
block copy update engine which is a

00:13:02,680 --> 00:13:07,900
little thread that will copy data from

00:13:04,690 --> 00:13:09,640
SRAM to main memory and main memory is

00:13:07,900 --> 00:13:13,000
something that of course the host Linux

00:13:09,640 --> 00:13:14,440
system can access and of course we can

00:13:13,000 --> 00:13:15,520
pre-allocate this because there's a

00:13:14,440 --> 00:13:16,990
whole bunch of other things that happen

00:13:15,520 --> 00:13:19,330
with the OCC so it's using existing

00:13:16,990 --> 00:13:20,920
infrastructure and so this in band

00:13:19,330 --> 00:13:22,960
sensor data would then work if we

00:13:20,920 --> 00:13:25,180
program the OCC to extract those senses

00:13:22,960 --> 00:13:27,730
and copy that to main memory we have

00:13:25,180 --> 00:13:30,040
this lovely little workflow where our

00:13:27,730 --> 00:13:31,780
Linux user space application uses the

00:13:30,040 --> 00:13:33,580
standard Linux interfaces to talk to a

00:13:31,780 --> 00:13:35,440
Linux kernel and inside that we have a

00:13:33,580 --> 00:13:38,380
tiny little driver that simply reads

00:13:35,440 --> 00:13:40,810
from main memory and periodically in the

00:13:38,380 --> 00:13:42,940
background the OCC grabs those sensors

00:13:40,810 --> 00:13:44,710
and writes them into main memory so when

00:13:42,940 --> 00:13:47,290
we're reading these sensors in band on

00:13:44,710 --> 00:13:49,540
is just reading from memory addresses

00:13:47,290 --> 00:13:50,950
which is really really quick while we

00:13:49,540 --> 00:13:53,080
have the OCC doing the hard work of

00:13:50,950 --> 00:13:56,080
pulling them from outside that we're not

00:13:53,080 --> 00:13:59,740
using resources there so how do we

00:13:56,080 --> 00:14:02,260
consume it memory mapped all in memory

00:13:59,740 --> 00:14:05,430
reading memory sensors that's how we do

00:14:02,260 --> 00:14:08,230
it / f and I'm sensors sisyphus finals

00:14:05,430 --> 00:14:09,640
so how could we use this what

00:14:08,230 --> 00:14:12,400
information could this be useful for

00:14:09,640 --> 00:14:13,630
well one is just saying an openstack

00:14:12,400 --> 00:14:15,940
cloud environment you could then

00:14:13,630 --> 00:14:17,890
provision your virtual machines based on

00:14:15,940 --> 00:14:21,700
memory bandwidth usage on each node

00:14:17,890 --> 00:14:23,230
right so if you have a known memory if

00:14:21,700 --> 00:14:25,600
you have a machine that's all its memory

00:14:23,230 --> 00:14:28,270
bandwidth is consumed maybe you want to

00:14:25,600 --> 00:14:29,950
provision a new vm on a machine that has

00:14:28,270 --> 00:14:31,960
less of its memory bandwidth being used

00:14:29,950 --> 00:14:33,490
so it can be another metric to go you

00:14:31,960 --> 00:14:36,610
know I know what I ops are being used on

00:14:33,490 --> 00:14:38,560
each node I know what you know network

00:14:36,610 --> 00:14:39,700
usage is being used on each node now I

00:14:38,560 --> 00:14:41,380
can also know things like memory

00:14:39,700 --> 00:14:45,330
bandwidth and temperature and then more

00:14:41,380 --> 00:14:50,650
evenly balanced things my my cloud

00:14:45,330 --> 00:14:53,050
that's also possible with HPC schedulers

00:14:50,650 --> 00:14:55,090
so HP schedulers have all sorts of input

00:14:53,050 --> 00:14:57,190
on like what era would I schedule a job

00:14:55,090 --> 00:14:59,650
and so we're having more smarts in there

00:14:57,190 --> 00:15:01,450
to go well if I'm scheduling a memory

00:14:59,650 --> 00:15:02,770
intensive job guess what I probably want

00:15:01,450 --> 00:15:06,220
to run that on a node that is not

00:15:02,770 --> 00:15:07,450
currently out of memory bandwidth there

00:15:06,220 --> 00:15:10,480
is the IBM tradition of having backup

00:15:07,450 --> 00:15:12,850
slides at the end but through this you

00:15:10,480 --> 00:15:16,690
will be able to see where you get sort

00:15:12,850 --> 00:15:18,190
of linux / f interface be able to run a

00:15:16,690 --> 00:15:20,500
whole bunch of interesting workloads and

00:15:18,190 --> 00:15:21,930
then see some of these senses and this

00:15:20,500 --> 00:15:24,340
is a bunch of work that's come through

00:15:21,930 --> 00:15:26,170
that's actually patches on top of what's

00:15:24,340 --> 00:15:27,940
in the current firmware so this is

00:15:26,170 --> 00:15:30,940
actually sort of something that has been

00:15:27,940 --> 00:15:32,710
noticed would be useful inside you know

00:15:30,940 --> 00:15:34,300
the Linux Technology Center and we're

00:15:32,710 --> 00:15:36,160
now feeding back to the FCC teams going

00:15:34,300 --> 00:15:37,720
hey hey we've made this useful thing

00:15:36,160 --> 00:15:38,950
with it with your firmware so if you

00:15:37,720 --> 00:15:41,890
want to go and grab and play with this

00:15:38,950 --> 00:15:44,560
there is a patches for ski boot and

00:15:41,890 --> 00:15:46,180
there's patches for OCC and the beauty

00:15:44,560 --> 00:15:48,550
of open power of course is like here is

00:15:46,180 --> 00:15:50,320
patches to your hostess and firmware go

00:15:48,550 --> 00:15:51,550
compile and have fun with it and that's

00:15:50,320 --> 00:15:53,140
what you can do and we'll probably see

00:15:51,550 --> 00:15:53,760
this in sort of future generations of

00:15:53,140 --> 00:15:57,630
firmware

00:15:53,760 --> 00:16:00,000
and and chips as well and see this is an

00:15:57,630 --> 00:16:01,980
influence of future design so with that

00:16:00,000 --> 00:16:03,990
that's how you build a kernel to do it

00:16:01,980 --> 00:16:06,030
how do you build a beam or with it and

00:16:03,990 --> 00:16:07,950
thanks to all of these people who had a

00:16:06,030 --> 00:16:10,290
lot of a lot of involvement listen

00:16:07,950 --> 00:16:12,860
especially shall pass you let it so

00:16:10,290 --> 00:16:12,860

YouTube URL: https://www.youtube.com/watch?v=3YAIT795ik4


