Title: OpenPOWER Summit US 2018: 15 Porting and Tuning Tools in 30 Minutes
Publication date: 2018-04-04
Playlist: OpenPOWER Summit US 2018
Description: 
	Paul Clarke, Software Architect / Developer, IBM, discusses 15 tools for porting and tuning in 30 minutes at OpenPOWER Summit 2018.

For more information, please visit: http://www.openpowerfoundation.org
Captions: 
	00:00:00,640 --> 00:00:04,520
[Music]

00:00:06,319 --> 00:00:14,309
so given time constraints maybe I should

00:00:08,820 --> 00:00:19,050
go ahead and start that okay get in the

00:00:14,309 --> 00:00:19,800
back all right well thank you all for

00:00:19,050 --> 00:00:21,960
coming

00:00:19,800 --> 00:00:24,990
my name is Paul Clark I work in the

00:00:21,960 --> 00:00:27,240
Linux Technology Center at IBM my role

00:00:24,990 --> 00:00:29,340
there is as a Software Architect and

00:00:27,240 --> 00:00:33,059
software developer I work on things like

00:00:29,340 --> 00:00:35,010
performance tools portability tools core

00:00:33,059 --> 00:00:37,469
libraries I touch a little bit on the

00:00:35,010 --> 00:00:38,730
compiler things like that I've been in

00:00:37,469 --> 00:00:40,920
IBM for a long time had a number of

00:00:38,730 --> 00:00:42,840
different roles I've been a consultant

00:00:40,920 --> 00:00:44,910
I've been a performance analyst I've

00:00:42,840 --> 00:00:47,879
been in AIX development all kinds of

00:00:44,910 --> 00:00:50,610
things I really appreciate you all

00:00:47,879 --> 00:00:51,780
coming there's a lot to cover part of

00:00:50,610 --> 00:00:54,539
the motivation for putting us together

00:00:51,780 --> 00:00:56,610
is if you are in the business where you

00:00:54,539 --> 00:00:59,760
might need to port or tune applications

00:00:56,610 --> 00:01:02,309
for Linux on power there's a neuro tools

00:00:59,760 --> 00:01:05,460
that IBM has helped contribute to or

00:01:02,309 --> 00:01:08,189
make available to make that effort a

00:01:05,460 --> 00:01:10,650
more of a success and the awareness of

00:01:08,189 --> 00:01:12,659
those tools may be lower than what what

00:01:10,650 --> 00:01:14,250
we hope for and we want to make sure

00:01:12,659 --> 00:01:16,979
that we get the best results we can as

00:01:14,250 --> 00:01:19,200
quickly as we can there's been many

00:01:16,979 --> 00:01:20,369
cases where as a consultant you get into

00:01:19,200 --> 00:01:21,689
a porting effort and it just takes a

00:01:20,369 --> 00:01:23,460
little too long the customer gets a

00:01:21,689 --> 00:01:24,630
little antsy and you really want to get

00:01:23,460 --> 00:01:25,290
those best results as quickly as

00:01:24,630 --> 00:01:29,610
possible

00:01:25,290 --> 00:01:32,070
I really appreciate Chris from OSU doing

00:01:29,610 --> 00:01:34,590
his presentation earlier I was very

00:01:32,070 --> 00:01:37,500
interesting that they were able to port

00:01:34,590 --> 00:01:38,759
you know 2,000 applications in a short

00:01:37,500 --> 00:01:41,850
amount of time with a relatively

00:01:38,759 --> 00:01:45,149
inexperienced resource porting is

00:01:41,850 --> 00:01:47,189
generally a very easy process and you

00:01:45,149 --> 00:01:50,119
know probably I think you said 70% maybe

00:01:47,189 --> 00:01:53,610
even higher or just recompiling go

00:01:50,119 --> 00:01:55,799
interpreted languages are portable by

00:01:53,610 --> 00:01:57,689
nature so this really talks about the

00:01:55,799 --> 00:01:59,670
times when you try to port something in

00:01:57,689 --> 00:02:01,649
isn't an easy process where you run into

00:01:59,670 --> 00:02:03,030
some difficulties so let me go through

00:02:01,649 --> 00:02:05,670
because I don't have that much time to

00:02:03,030 --> 00:02:07,380
cover a lot of material I like I saying

00:02:05,670 --> 00:02:08,640
one of the points of putting this

00:02:07,380 --> 00:02:10,200
presentation together is to get all

00:02:08,640 --> 00:02:12,569
these these tools kind of in one place

00:02:10,200 --> 00:02:12,970
so you can take what I'm saying because

00:02:12,569 --> 00:02:15,100
I'm going

00:02:12,970 --> 00:02:16,630
talk fairly quickly in the reference

00:02:15,100 --> 00:02:19,660
material look at it later maybe go

00:02:16,630 --> 00:02:21,010
through it and digest it a little better

00:02:19,660 --> 00:02:23,980
than maybe what you're gonna be able to

00:02:21,010 --> 00:02:24,820
do today those are listed here I'm not

00:02:23,980 --> 00:02:27,700
going to go through them because I'm

00:02:24,820 --> 00:02:30,090
gonna talk about them I do kind of

00:02:27,700 --> 00:02:32,820
divide the tools into different scopes

00:02:30,090 --> 00:02:36,040
in in terms of where they're applicable

00:02:32,820 --> 00:02:39,280
white box gray box and black box white

00:02:36,040 --> 00:02:41,350
box tools are tools where I were the the

00:02:39,280 --> 00:02:43,660
user the tool basically is expected to

00:02:41,350 --> 00:02:45,459
have the source code and the willingness

00:02:43,660 --> 00:02:47,500
and the ability to change the source

00:02:45,459 --> 00:02:50,890
code for portability reasons or for

00:02:47,500 --> 00:02:52,690
performance advantage gray box is where

00:02:50,890 --> 00:02:54,370
you have the source code but you may not

00:02:52,690 --> 00:02:55,959
be willing to or able to change the

00:02:54,370 --> 00:02:58,600
source codes you want to look at it from

00:02:55,959 --> 00:03:00,490
a performance standpoint so you can be

00:02:58,600 --> 00:03:02,620
able to recompile relink things like

00:03:00,490 --> 00:03:04,120
that black box is where you may not even

00:03:02,620 --> 00:03:05,530
have the source code but you want to do

00:03:04,120 --> 00:03:06,790
some analysis you want to look at the

00:03:05,530 --> 00:03:09,250
code see if you can make it perform

00:03:06,790 --> 00:03:11,410
better let's move on

00:03:09,250 --> 00:03:18,190
who here has heard of the advance tool

00:03:11,410 --> 00:03:20,590
chain a few so advance tool chain so the

00:03:18,190 --> 00:03:22,290
advance tool chain is a suite of some of

00:03:20,590 --> 00:03:25,120
the latest and greatest compilers

00:03:22,290 --> 00:03:28,840
libraries performance tools analysis

00:03:25,120 --> 00:03:30,550
tools things like that built in an

00:03:28,840 --> 00:03:33,250
optimized fashion and made available for

00:03:30,550 --> 00:03:35,489
your use and the reason that exists is

00:03:33,250 --> 00:03:37,269
most of the time when we're working on a

00:03:35,489 --> 00:03:40,540
distribution the distributions

00:03:37,269 --> 00:03:41,799
motivation is often stability so years

00:03:40,540 --> 00:03:43,390
ago they've settled on a certain

00:03:41,799 --> 00:03:45,340
compiler a certain level with the

00:03:43,390 --> 00:03:46,570
libraries and they stay with those for

00:03:45,340 --> 00:03:48,790
stability reasons and there's really

00:03:46,570 --> 00:03:51,040
nothing wrong with that but from a

00:03:48,790 --> 00:03:53,290
performance standpoint performance

00:03:51,040 --> 00:03:55,540
standpoint iBM is trying to carry the

00:03:53,290 --> 00:03:57,220
ball forward new processor architectures

00:03:55,540 --> 00:03:59,430
are being announced power eight power

00:03:57,220 --> 00:04:02,530
nine all these things may have come out

00:03:59,430 --> 00:04:06,519
excuse me after the distribution has

00:04:02,530 --> 00:04:09,269
settled on its library level but we want

00:04:06,519 --> 00:04:12,580
to make sure I didn't invest a

00:04:09,269 --> 00:04:13,750
significant amount of effort in new of

00:04:12,580 --> 00:04:15,239
taking advantage of new features and

00:04:13,750 --> 00:04:17,769
functionality in the new processors

00:04:15,239 --> 00:04:20,530
processors as well as incorporating new

00:04:17,769 --> 00:04:22,300
optimization algorithms and whatnot so

00:04:20,530 --> 00:04:24,430
if you don't use the new compilers and

00:04:22,300 --> 00:04:26,500
libraries you won't take advantage and

00:04:24,430 --> 00:04:28,900
exploit the new capabilities

00:04:26,500 --> 00:04:30,640
sir as efficiently so advanced role

00:04:28,900 --> 00:04:33,640
change is really designed to fill that

00:04:30,640 --> 00:04:36,450
gap to give you those new compilers new

00:04:33,640 --> 00:04:39,220
libraries on the existing distributions

00:04:36,450 --> 00:04:42,010
it is updated regularly with security

00:04:39,220 --> 00:04:44,170
fixes and feature updates it is

00:04:42,010 --> 00:04:46,630
supportable through the IBM support line

00:04:44,170 --> 00:04:50,620
it's all open sources available at that

00:04:46,630 --> 00:04:54,430
link there the advanced tool chain the

00:04:50,620 --> 00:04:57,940
most recent version is 80 11.0 - 3

00:04:54,430 --> 00:05:00,700
it has GCC 7 and you'll see why that's

00:04:57,940 --> 00:05:03,520
important and the next chart G life

00:05:00,700 --> 00:05:05,200
cbenni tools boost updated versions to

00:05:03,520 --> 00:05:07,080
that compared to the distributions as

00:05:05,200 --> 00:05:10,120
well as a host of other tools libraries

00:05:07,080 --> 00:05:13,030
and compilers as you can see at the

00:05:10,120 --> 00:05:15,790
bottom there I wanted to give you an

00:05:13,030 --> 00:05:17,260
idea of what the real value of the

00:05:15,790 --> 00:05:19,030
advanced tool chain is compared to a

00:05:17,260 --> 00:05:21,610
distribution this is not to pick on

00:05:19,030 --> 00:05:23,169
RedHat all the distributions kind of

00:05:21,610 --> 00:05:26,620
tend to settle on older versions of the

00:05:23,169 --> 00:05:28,750
byberry but here you can see the distro

00:05:26,620 --> 00:05:30,940
has is settled in 4.8 for the GCC

00:05:28,750 --> 00:05:33,510
version the advanced tool chain has 7

00:05:30,940 --> 00:05:37,180
not 3 this is the latest release of 7

00:05:33,510 --> 00:05:39,520
GCC 7 has a lot more power 8 and power 9

00:05:37,180 --> 00:05:40,990
performance advantage and then the

00:05:39,520 --> 00:05:44,110
center column you can see that Red Hat

00:05:40,990 --> 00:05:46,600
has made strides in a similar area they

00:05:44,110 --> 00:05:48,910
provide a developer toolset which makes

00:05:46,600 --> 00:05:51,540
advantage makes available to developers

00:05:48,910 --> 00:05:55,960
the latest one of the latest releases of

00:05:51,540 --> 00:06:00,010
compiler version 7.2 so it's very close

00:05:55,960 --> 00:06:01,690
to latest and latest version of the new

00:06:00,010 --> 00:06:03,820
tools but one of the things that I

00:06:01,690 --> 00:06:05,410
wanted to draw into is the advanced tool

00:06:03,820 --> 00:06:06,610
chain makes the libraries available so

00:06:05,410 --> 00:06:08,740
not only are you getting the latest

00:06:06,610 --> 00:06:11,530
libraries of value available for like

00:06:08,740 --> 00:06:14,710
live C live in for you know malloc and

00:06:11,530 --> 00:06:16,600
the math routines and whatnot you also

00:06:14,710 --> 00:06:18,580
get those libraries built with the

00:06:16,600 --> 00:06:20,770
advanced tool chains so you get better

00:06:18,580 --> 00:06:23,020
code generation in those libraries as

00:06:20,770 --> 00:06:24,669
well one thing I wanted to note on this

00:06:23,020 --> 00:06:26,800
chart is when you build with the

00:06:24,669 --> 00:06:30,700
advanced tool chain the application

00:06:26,800 --> 00:06:32,320
result has a tie to the runtime of the

00:06:30,700 --> 00:06:33,820
advanced tool chain so if you want to

00:06:32,320 --> 00:06:34,840
deploy that application elsewhere you

00:06:33,820 --> 00:06:37,060
have to bring the advanced tool chain

00:06:34,840 --> 00:06:39,050
runtime with you this is just something

00:06:37,060 --> 00:06:41,370
to be aware of it is a free

00:06:39,050 --> 00:06:42,780
offering so it should be a significant

00:06:41,370 --> 00:06:46,680
problem but definitely something to be

00:06:42,780 --> 00:06:48,120
aware of if you've worked on AIX I know

00:06:46,680 --> 00:06:51,870
some at least some of the audience are

00:06:48,120 --> 00:06:54,260
familiar with ax the the proprietary and

00:06:51,870 --> 00:06:57,060
flagship compiler that appears on AIX

00:06:54,260 --> 00:07:00,090
the Excel compiler suite is also

00:06:57,060 --> 00:07:01,980
available on Linux this is the compiler

00:07:00,090 --> 00:07:05,490
that's used on the spec publishes that

00:07:01,980 --> 00:07:07,350
IBM makes so it is expected to provide

00:07:05,490 --> 00:07:12,270
some of the better optimization

00:07:07,350 --> 00:07:13,920
techniques it is the version most people

00:07:12,270 --> 00:07:16,950
familiar with the license and supported

00:07:13,920 --> 00:07:19,470
version but very importantly to a

00:07:16,950 --> 00:07:22,640
porting effort as there is a community

00:07:19,470 --> 00:07:24,690
edition which is free and full function

00:07:22,640 --> 00:07:29,460
previous editions of the community

00:07:24,690 --> 00:07:31,200
edition we're slightly handicapped from

00:07:29,460 --> 00:07:32,610
with respect to the optimization levels

00:07:31,200 --> 00:07:35,190
that were supported but the most recent

00:07:32,610 --> 00:07:36,540
versions are full function so basically

00:07:35,190 --> 00:07:42,030
the only difference between the two is

00:07:36,540 --> 00:07:44,280
the support another interesting aspect

00:07:42,030 --> 00:07:46,760
is newer versions of the Excel compiler

00:07:44,280 --> 00:07:48,390
also use a new front end based on clang

00:07:46,760 --> 00:07:54,900
which will make the source code

00:07:48,390 --> 00:07:56,910
compatibility between GCC and Excel much

00:07:54,900 --> 00:07:59,180
more better so so it should be an easier

00:07:56,910 --> 00:08:01,560
effort to adopt the excel tool chain

00:07:59,180 --> 00:08:04,230
another nice feature that allows for

00:08:01,560 --> 00:08:06,000
collaboration between the Excel compiler

00:08:04,230 --> 00:08:07,830
offering and the advanced tool chain is

00:08:06,000 --> 00:08:10,190
the optimized libraries that come with a

00:08:07,830 --> 00:08:13,140
advanced tool chain can also be used by

00:08:10,190 --> 00:08:14,580
the Excel compiler so you may get kind

00:08:13,140 --> 00:08:17,060
of the best of both worlds the flagship

00:08:14,580 --> 00:08:19,050
lab Street flagship compiler and

00:08:17,060 --> 00:08:22,500
pre-built system libraries that are

00:08:19,050 --> 00:08:24,240
fully optimized for the architecture in

00:08:22,500 --> 00:08:25,860
addition going beyond just basic

00:08:24,240 --> 00:08:28,800
compilation Excel offers some neat

00:08:25,860 --> 00:08:30,750
advantages where with compiler flags

00:08:28,800 --> 00:08:33,240
certain compiler Flags you can generate

00:08:30,750 --> 00:08:34,860
automatically parallelized code which is

00:08:33,240 --> 00:08:39,420
really neat for the power platform due

00:08:34,860 --> 00:08:43,080
to its broad throughput capabilities in

00:08:39,420 --> 00:08:47,010
addition they have added partial support

00:08:43,080 --> 00:08:48,529
for open OpenMP 4.5 and utilize the

00:08:47,010 --> 00:08:50,350
utilization of those open

00:08:48,529 --> 00:08:52,699
P four point five primitives allows

00:08:50,350 --> 00:08:54,949
transparent exploitation of the GPU

00:08:52,699 --> 00:08:58,279
resources on the system so that's a

00:08:54,949 --> 00:09:00,800
really nice really nice function in

00:08:58,279 --> 00:09:03,079
addition the Excel compiler brings along

00:09:00,800 --> 00:09:05,600
optimized math libraries mass and blas

00:09:03,079 --> 00:09:08,870
and these libraries can actually be used

00:09:05,600 --> 00:09:12,350
again with the advanced tool chain so

00:09:08,870 --> 00:09:14,509
you know some customers have been found

00:09:12,350 --> 00:09:16,069
not to be real excited about using a

00:09:14,509 --> 00:09:18,379
proprietary compiler so in this case you

00:09:16,069 --> 00:09:20,569
can use some nice libraries with the

00:09:18,379 --> 00:09:22,999
advanced tool chain if Excel compilation

00:09:20,569 --> 00:09:25,089
is not an option a neat feature that

00:09:22,999 --> 00:09:30,439
also is available with Excel is

00:09:25,089 --> 00:09:31,759
optimization reports we're running the

00:09:30,439 --> 00:09:33,110
compilation with a certain option will

00:09:31,759 --> 00:09:35,089
produce these reports and you actually

00:09:33,110 --> 00:09:37,879
analyze through these reports and find

00:09:35,089 --> 00:09:39,769
areas where the compiler was not able to

00:09:37,879 --> 00:09:40,850
do certain optimizations because of

00:09:39,769 --> 00:09:42,220
restrictions that have found on the

00:09:40,850 --> 00:09:44,569
codes you may be able to go back

00:09:42,220 --> 00:09:46,639
reanalyze the code may be restructured a

00:09:44,569 --> 00:09:53,180
bit for performance advantage by making

00:09:46,639 --> 00:09:56,750
some changes FDP are this is a offering

00:09:53,180 --> 00:09:59,089
out of IBM Research this is a it's a

00:09:56,750 --> 00:10:00,980
neat post link binary optimization tool

00:09:59,089 --> 00:10:03,439
so it doesn't require any recompiling or

00:10:00,980 --> 00:10:07,370
real inking it basically takes a linked

00:10:03,439 --> 00:10:09,319
executable instruments the code runs a

00:10:07,370 --> 00:10:11,990
representative performance scenario and

00:10:09,319 --> 00:10:14,300
then can go in and restructure and

00:10:11,990 --> 00:10:16,689
optimize those binaries basically in

00:10:14,300 --> 00:10:20,509
place to give you a better performing

00:10:16,689 --> 00:10:22,490
binary program the reason there's a gray

00:10:20,509 --> 00:10:23,899
box here instead of a black box because

00:10:22,490 --> 00:10:25,910
you really don't need source code is

00:10:23,899 --> 00:10:28,220
that you will probably need to relink

00:10:25,910 --> 00:10:30,649
there is a requirement in FTP are to

00:10:28,220 --> 00:10:32,389
preserve relocation information so in

00:10:30,649 --> 00:10:35,480
the link step you have to add a flag to

00:10:32,389 --> 00:10:37,660
do that so real inking is often required

00:10:35,480 --> 00:10:40,129
because that is not the default behavior

00:10:37,660 --> 00:10:42,230
FTP are is a free download and there are

00:10:40,129 --> 00:10:44,480
some ease of use wrappers which allow

00:10:42,230 --> 00:10:46,189
kind of one step to handle that

00:10:44,480 --> 00:10:49,370
three-step process and I'll show you a

00:10:46,189 --> 00:10:51,110
run-through of that scenario here here

00:10:49,370 --> 00:10:53,959
you can see we we build the code with

00:10:51,110 --> 00:10:55,790
that pre preserving the relocation

00:10:53,959 --> 00:10:57,319
information in the first step and the

00:10:55,790 --> 00:10:58,490
second step does all three of the

00:10:57,319 --> 00:10:59,900
three-step process it does

00:10:58,490 --> 00:11:02,690
instrumentation of the

00:10:59,900 --> 00:11:04,670
of the executable they will do a run a

00:11:02,690 --> 00:11:06,620
profiling run and then it will optimize

00:11:04,670 --> 00:11:10,210
the executable producing a new

00:11:06,620 --> 00:11:12,260
executable in its place and you can see

00:11:10,210 --> 00:11:15,260
down at the bottom there's a couple of

00:11:12,260 --> 00:11:17,240
runs there you can see we've improved

00:11:15,260 --> 00:11:19,640
the performance here about what six or

00:11:17,240 --> 00:11:21,530
eight percent this is a bit of a silly

00:11:19,640 --> 00:11:22,940
test because if you can see at the top I

00:11:21,530 --> 00:11:25,730
didn't even optimize the code going in

00:11:22,940 --> 00:11:30,280
but yeah it is an example of a case

00:11:25,730 --> 00:11:30,280
where you can see if DPR has an impact

00:11:30,550 --> 00:11:34,550
I've moved to a white box here because

00:11:33,080 --> 00:11:37,250
FDB are so it provides the opportunity

00:11:34,550 --> 00:11:40,130
to produce a journal once it's done it's

00:11:37,250 --> 00:11:41,690
optimization instrumentation and data

00:11:40,130 --> 00:11:44,930
collection phases it can analyze the

00:11:41,690 --> 00:11:46,880
results and write in a journal out which

00:11:44,930 --> 00:11:49,370
will give some indication of changes

00:11:46,880 --> 00:11:50,660
that can be made to the source code such

00:11:49,370 --> 00:11:52,280
that you can actually go back and change

00:11:50,660 --> 00:11:54,020
the source code maybe not even need FTP

00:11:52,280 --> 00:11:55,220
our performance magic you can actually

00:11:54,020 --> 00:11:59,650
change the source code which will

00:11:55,220 --> 00:12:01,910
benefit the code ad nauseum you can

00:11:59,650 --> 00:12:05,350
change the code permanently so you don't

00:12:01,910 --> 00:12:08,030
have to keep doing FTP or over and over

00:12:05,350 --> 00:12:10,600
what appears in that journal is an

00:12:08,030 --> 00:12:12,980
example maybe a little too small to read

00:12:10,600 --> 00:12:15,470
but if I can interpret for you

00:12:12,980 --> 00:12:18,200
this is a case where FTP I found an

00:12:15,470 --> 00:12:19,580
example where an in function was being

00:12:18,200 --> 00:12:21,650
called over and over this function was

00:12:19,580 --> 00:12:23,780
small enough so that the call overhead

00:12:21,650 --> 00:12:26,420
was high and in lining that function

00:12:23,780 --> 00:12:28,690
would be advantageous excuse me from a

00:12:26,420 --> 00:12:32,030
performance perspective so you get the

00:12:28,690 --> 00:12:33,170
the file line number and you can go

00:12:32,030 --> 00:12:35,540
right into the source code and analyze

00:12:33,170 --> 00:12:38,200
to see if there's a ways of getting that

00:12:35,540 --> 00:12:38,200
function in mind

00:12:39,170 --> 00:12:44,870
IBM SDK for lifetime power who's heard

00:12:41,480 --> 00:12:47,270
of the IBM SDK for Linux on power ok so

00:12:44,870 --> 00:12:50,210
this is an OP this is a an offering from

00:12:47,270 --> 00:12:52,610
IBM it's a fairly substantive offering

00:12:50,210 --> 00:12:55,190
as an IDE so integrated development

00:12:52,610 --> 00:12:56,720
environment it is based on Eclipse so it

00:12:55,190 --> 00:12:58,580
has all the features and functions that

00:12:56,720 --> 00:13:01,640
if your Eclipse user if you're familiar

00:12:58,580 --> 00:13:04,880
with are comfortable with eclipse it is

00:13:01,640 --> 00:13:07,220
that with IBM plug-ins targeted at

00:13:04,880 --> 00:13:09,329
porting and tuning C and C++

00:13:07,220 --> 00:13:13,389
applications for learning some power

00:13:09,329 --> 00:13:17,199
it is built to run on Linux both on x86

00:13:13,389 --> 00:13:19,209
and power if your Windows or Mac user

00:13:17,199 --> 00:13:21,540
you can run it on those systems but you

00:13:19,209 --> 00:13:24,490
have to do it through a virtual machine

00:13:21,540 --> 00:13:26,199
it runs in three different modes you can

00:13:24,490 --> 00:13:28,060
run it obviously on that power system

00:13:26,199 --> 00:13:31,029
and remote display back with various

00:13:28,060 --> 00:13:33,850
techniques you can run it entirely on

00:13:31,029 --> 00:13:35,470
x86 if you're comfortable with using

00:13:33,850 --> 00:13:37,569
cross compilers and emulation

00:13:35,470 --> 00:13:40,149
technologies one of the examples that

00:13:37,569 --> 00:13:41,860
came up with on the way here is if

00:13:40,149 --> 00:13:43,240
you're on an airplane and you don't have

00:13:41,860 --> 00:13:44,769
your power system sitting under your

00:13:43,240 --> 00:13:46,569
seat - plugged in and ready to go you

00:13:44,769 --> 00:13:49,060
can do some basic power development

00:13:46,569 --> 00:13:51,670
right on your laptop without even access

00:13:49,060 --> 00:13:54,430
to a power system you can also run the

00:13:51,670 --> 00:13:57,339
sdk in a hybrid environment where the ID

00:13:54,430 --> 00:13:59,199
itself runs on your laptop and the

00:13:57,339 --> 00:14:01,930
development environment is seamlessly

00:13:59,199 --> 00:14:03,579
accessed to a remote power system so you

00:14:01,930 --> 00:14:05,649
kind of get the best of both worlds the

00:14:03,579 --> 00:14:08,079
interactivity of a locally running IDE

00:14:05,649 --> 00:14:10,839
and the power development environment

00:14:08,079 --> 00:14:11,379
that you really want to use it is a free

00:14:10,839 --> 00:14:13,750
download

00:14:11,379 --> 00:14:16,329
I've written a tutorial that kind of

00:14:13,750 --> 00:14:19,060
walks through a very typical use case

00:14:16,329 --> 00:14:21,670
scenario where you can bring up the SDK

00:14:19,060 --> 00:14:24,880
use the most valuable and frequently

00:14:21,670 --> 00:14:26,470
used tools and get the most value out of

00:14:24,880 --> 00:14:28,689
the SDK with the least amount of effort

00:14:26,470 --> 00:14:30,399
there are also some videos available if

00:14:28,689 --> 00:14:33,550
you want to watch some walkthroughs of

00:14:30,399 --> 00:14:36,040
those tools being used basic operation

00:14:33,550 --> 00:14:38,380
of the SDK you basically want to import

00:14:36,040 --> 00:14:39,880
your source code then there's a series

00:14:38,380 --> 00:14:41,170
of plugins they may want to run this is

00:14:39,880 --> 00:14:44,949
in rough order that you might want to

00:14:41,170 --> 00:14:46,540
run them not mandated and I'll talk

00:14:44,949 --> 00:14:48,310
about each of these plugins and in later

00:14:46,540 --> 00:14:50,470
charts the migration advisor is a

00:14:48,310 --> 00:14:52,079
portability advisor to source code

00:14:50,470 --> 00:14:54,759
scanner and talk about that a bit

00:14:52,079 --> 00:14:56,949
after you've ported the code that it

00:14:54,759 --> 00:14:59,290
built successfully the build advisor in

00:14:56,949 --> 00:15:02,380
the SDK will look for things like are

00:14:59,290 --> 00:15:05,129
you using the best compiler or using the

00:15:02,380 --> 00:15:07,269
best compiler flags things like that

00:15:05,129 --> 00:15:10,779
school advisors or runtime performance

00:15:07,269 --> 00:15:12,309
analysis and then people that are doing

00:15:10,779 --> 00:15:14,920
performance analysis probably familiar

00:15:12,309 --> 00:15:16,970
with peripheral profile already and then

00:15:14,920 --> 00:15:20,470
I'll talk about CPU breakdown

00:15:16,970 --> 00:15:22,610
and power performance advisor later

00:15:20,470 --> 00:15:25,010
migration advisor so one of the first

00:15:22,610 --> 00:15:27,500
things that needs to be done in porting

00:15:25,010 --> 00:15:30,170
is to get the thing ported and like we

00:15:27,500 --> 00:15:32,000
said earlier that's often no effort at

00:15:30,170 --> 00:15:34,340
all but sometimes it does take some

00:15:32,000 --> 00:15:36,380
effort so the migration of Iser is a

00:15:34,340 --> 00:15:38,080
plug-in in the SDK that does source code

00:15:36,380 --> 00:15:41,180
scanning looks for a lot of these

00:15:38,080 --> 00:15:43,430
different portability issues and

00:15:41,180 --> 00:15:44,780
concerns and will display a report for

00:15:43,430 --> 00:15:48,020
you directly in the GUI which I'll show

00:15:44,780 --> 00:15:51,230
you in a second and allow you to analyze

00:15:48,020 --> 00:15:53,420
to see whether that is in D to perform a

00:15:51,230 --> 00:15:55,430
portability issue and something that

00:15:53,420 --> 00:15:57,110
needs to be dressed or not the nice

00:15:55,430 --> 00:15:59,300
thing is it's very easy to run that

00:15:57,110 --> 00:16:01,820
simply import the code and then click on

00:15:59,300 --> 00:16:04,610
the project's context menu and click run

00:16:01,820 --> 00:16:06,530
migration advisor so a very easy thing

00:16:04,610 --> 00:16:08,300
to do there's also some neat features

00:16:06,530 --> 00:16:10,940
about quick fixes and I'll describe that

00:16:08,300 --> 00:16:13,070
in a little bit but the essentially that

00:16:10,940 --> 00:16:14,930
is the way for the SDK to actually go in

00:16:13,070 --> 00:16:19,280
and if it has high confidence it can

00:16:14,930 --> 00:16:20,870
actually fix the code for you so and you

00:16:19,280 --> 00:16:22,340
know with a large project the going

00:16:20,870 --> 00:16:23,600
through each one and fixing it for you

00:16:22,340 --> 00:16:25,010
is going to be tedious so there's a way

00:16:23,600 --> 00:16:28,340
to do that automatically for high

00:16:25,010 --> 00:16:30,800
confidence issues here's a picture the

00:16:28,340 --> 00:16:33,620
SDK in action so we've just run the

00:16:30,800 --> 00:16:36,410
migration advisor the report is at the

00:16:33,620 --> 00:16:38,180
bottom in the bottom frame and you can

00:16:36,410 --> 00:16:40,310
see it's found here I guess seven

00:16:38,180 --> 00:16:43,160
different issues displayed put my

00:16:40,310 --> 00:16:45,440
glasses on so I can read the there's a

00:16:43,160 --> 00:16:48,260
couple of cases where the process out a

00:16:45,440 --> 00:16:50,270
preprocessor macro oftentimes if you're

00:16:48,260 --> 00:16:53,390
familiar with porting exercises you will

00:16:50,270 --> 00:16:56,210
often find code with legacy x86 bias

00:16:53,390 --> 00:16:59,390
where they'll have if Dex X if def x86

00:16:56,210 --> 00:17:00,530
run some fast path else slow path so

00:16:59,390 --> 00:17:02,120
these are the kinds of things that the

00:17:00,530 --> 00:17:03,560
migration advisory wants to fly for use

00:17:02,120 --> 00:17:05,720
of these things you want to look at

00:17:03,560 --> 00:17:09,439
earlier just to so you don't stumble

00:17:05,720 --> 00:17:10,970
into them later also another of the

00:17:09,439 --> 00:17:12,290
other issues it founds were confusing

00:17:10,970 --> 00:17:16,130
compiler built-ins and I'll talk a

00:17:12,290 --> 00:17:17,750
little bit about that a bit I talked

00:17:16,130 --> 00:17:22,370
about the quick fixes this is an example

00:17:17,750 --> 00:17:24,380
of a an x86 built in using MMX sse type

00:17:22,370 --> 00:17:26,280
compiler built-ins these are not

00:17:24,380 --> 00:17:30,210
compatible

00:17:26,280 --> 00:17:31,380
with power but if you get that report

00:17:30,210 --> 00:17:34,200
you find these things you can actually

00:17:31,380 --> 00:17:35,910
hover over that code you get a pop-up

00:17:34,200 --> 00:17:38,460
that kind of describes what's going on

00:17:35,910 --> 00:17:39,960
and then the blue hyperlink if you click

00:17:38,460 --> 00:17:41,640
on that what it'll do it'll actually go

00:17:39,960 --> 00:17:43,980
in the code and fix the code for you in

00:17:41,640 --> 00:17:45,480
a portable fashion so the code will not

00:17:43,980 --> 00:17:47,880
change semantically from what it was

00:17:45,480 --> 00:17:50,330
before but it will now be portable to

00:17:47,880 --> 00:17:54,200
the Power Platform all with one click

00:17:50,330 --> 00:17:56,780
it's pretty nice so here's even better

00:17:54,200 --> 00:18:00,390
nice segue

00:17:56,780 --> 00:18:02,700
so the SDK if you when you initially set

00:18:00,390 --> 00:18:03,810
it up to run you can click another box

00:18:02,700 --> 00:18:05,340
that says apply these fixes

00:18:03,810 --> 00:18:07,020
automatically so if the SDK has high

00:18:05,340 --> 00:18:09,060
confidence that what it's about to do is

00:18:07,020 --> 00:18:10,260
correct it will go through scan the

00:18:09,060 --> 00:18:12,810
source code and implement all these

00:18:10,260 --> 00:18:14,850
fixes automatically so if you have a lot

00:18:12,810 --> 00:18:20,580
of code this is going to save you a lot

00:18:14,850 --> 00:18:22,560
of time so excuse me

00:18:20,580 --> 00:18:25,530
source code advisor there's another plug

00:18:22,560 --> 00:18:27,000
in the SDK this basically if you recall

00:18:25,530 --> 00:18:30,150
I talked about FTP are a little bit

00:18:27,000 --> 00:18:32,340
earlier this is a GUI plug-in that's

00:18:30,150 --> 00:18:34,130
based on FTP are they will do the same

00:18:32,340 --> 00:18:36,810
runtime performance analysis it'll

00:18:34,130 --> 00:18:38,970
generate that journal import that back

00:18:36,810 --> 00:18:41,010
into the sdk automatically and then

00:18:38,970 --> 00:18:44,100
display those areas of the code where

00:18:41,010 --> 00:18:45,540
these issues were found similarly to the

00:18:44,100 --> 00:18:49,200
way that migration advisor works it will

00:18:45,540 --> 00:18:50,940
also offer quick fixes here's an example

00:18:49,200 --> 00:18:52,290
of source code advisor output where it

00:18:50,940 --> 00:18:56,190
found a couple different issues where

00:18:52,290 --> 00:18:58,290
they were inline function possibilities

00:18:56,190 --> 00:18:59,430
for performance advantage it describes

00:18:58,290 --> 00:19:01,890
the problem gives you a potential

00:18:59,430 --> 00:19:03,150
solution in textual form the other thing

00:19:01,890 --> 00:19:04,560
you can do is double click on those line

00:19:03,150 --> 00:19:06,330
descriptions there and you'll go

00:19:04,560 --> 00:19:08,700
straight to the source code hover over

00:19:06,330 --> 00:19:10,350
that get a description of the problem as

00:19:08,700 --> 00:19:10,890
it was found and you click on this

00:19:10,350 --> 00:19:12,870
hyperlink

00:19:10,890 --> 00:19:14,970
it'll again implement that fix directly

00:19:12,870 --> 00:19:18,060
in your code here you can see on the

00:19:14,970 --> 00:19:21,270
bottom right there is an attribute

00:19:18,060 --> 00:19:24,590
applied on line 24 to force the compiler

00:19:21,270 --> 00:19:24,590
to always inline this function

00:19:26,190 --> 00:19:30,940
CPI breakdown so CPI cycles per

00:19:29,380 --> 00:19:34,200
instruction that's a metric often used

00:19:30,940 --> 00:19:37,240
in in performance analysis that is a

00:19:34,200 --> 00:19:39,910
measure of a processor efficiency how

00:19:37,240 --> 00:19:42,340
well is your program executing on the

00:19:39,910 --> 00:19:44,200
system how many cycles does it take to

00:19:42,340 --> 00:19:48,490
execute a typical instruction in your

00:19:44,200 --> 00:19:49,960
program obviously lower is better but

00:19:48,490 --> 00:19:51,640
that measurement in itself doesn't

00:19:49,960 --> 00:19:52,960
really tell you what's going on what

00:19:51,640 --> 00:19:54,940
makes it high what makes it

00:19:52,960 --> 00:19:58,330
how can you address trying to get it to

00:19:54,940 --> 00:20:02,260
not be so high so the breakdown tries to

00:19:58,330 --> 00:20:04,870
will break down that single metric in a

00:20:02,260 --> 00:20:06,910
hierarchy of hardware events where you

00:20:04,870 --> 00:20:08,800
can do further detailed analysis based

00:20:06,910 --> 00:20:12,310
on the characteristics of the processor

00:20:08,800 --> 00:20:13,810
under load one thing to note here that

00:20:12,310 --> 00:20:15,550
sad little note at the bottom is that

00:20:13,810 --> 00:20:17,230
this plug-in doesn't currently have

00:20:15,550 --> 00:20:19,600
support for power 9 does have full

00:20:17,230 --> 00:20:21,340
support for power 8 which is a perfectly

00:20:19,600 --> 00:20:23,530
valid platform for doing some similar

00:20:21,340 --> 00:20:25,480
performance analysis and improvements

00:20:23,530 --> 00:20:30,430
for power will translate fairly well to

00:20:25,480 --> 00:20:33,010
power 9 this is probably too hard to

00:20:30,430 --> 00:20:36,010
read and that's okay this is the an

00:20:33,010 --> 00:20:38,200
example of CPI breakdown has just

00:20:36,010 --> 00:20:40,210
finished and this is a display the

00:20:38,200 --> 00:20:41,950
hierarchy so going left to right we're

00:20:40,210 --> 00:20:44,380
going to get more and more specific in

00:20:41,950 --> 00:20:46,360
terms of the hardware events the events

00:20:44,380 --> 00:20:50,020
on the right are folded into the events

00:20:46,360 --> 00:20:53,650
and there as you go towards the left the

00:20:50,020 --> 00:20:57,970
highest most frequent events encountered

00:20:53,650 --> 00:20:58,540
are highlighted red sort of a pink and

00:20:57,970 --> 00:21:01,930
then orange

00:20:58,540 --> 00:21:04,600
I did not pick those colors so you can

00:21:01,930 --> 00:21:07,240
kind of visually zero in on the most

00:21:04,600 --> 00:21:11,070
important events for more detailed

00:21:07,240 --> 00:21:14,350
analysis now these boxes aren't to scale

00:21:11,070 --> 00:21:16,390
so we added something called a radar

00:21:14,350 --> 00:21:19,810
chart which kind of gives you an idea of

00:21:16,390 --> 00:21:21,220
which areas to look at more closely the

00:21:19,810 --> 00:21:25,030
other thing I want to go back a chart

00:21:21,220 --> 00:21:27,130
and you can't see it but each of these

00:21:25,030 --> 00:21:28,900
boxes is filled with a hardware event a

00:21:27,130 --> 00:21:30,580
mnemonic so they're not really readable

00:21:28,900 --> 00:21:31,900
if you hover over these you can get a

00:21:30,580 --> 00:21:33,940
nice description of what that mnemonic

00:21:31,900 --> 00:21:36,640
really stands for the other really cool

00:21:33,940 --> 00:21:38,029
thing is if you double click on these

00:21:36,640 --> 00:21:40,070
boxes

00:21:38,029 --> 00:21:42,049
the SDK will automatically launch a new

00:21:40,070 --> 00:21:43,700
run of the perf command for the

00:21:42,049 --> 00:21:45,440
representative performance scenario and

00:21:43,700 --> 00:21:49,220
pull file in that specific event and

00:21:45,440 --> 00:21:50,870
then you'll get the same output I

00:21:49,220 --> 00:21:52,580
already talked about that you'll get the

00:21:50,870 --> 00:21:54,769
same output you did before with perf

00:21:52,580 --> 00:21:56,179
where you get information based on which

00:21:54,769 --> 00:21:58,220
lines these events are occurring but

00:21:56,179 --> 00:22:00,500
it's for that specific event that was

00:21:58,220 --> 00:22:03,139
happening in your code so you can really

00:22:00,500 --> 00:22:04,789
do some really detailed analysis based

00:22:03,139 --> 00:22:07,730
on specific Hardware events not just

00:22:04,789 --> 00:22:09,380
cycles in addition you can break down

00:22:07,730 --> 00:22:10,970
further not only by the line in the

00:22:09,380 --> 00:22:13,190
source code you can go into the assembly

00:22:10,970 --> 00:22:14,510
and find some really detailed

00:22:13,190 --> 00:22:19,250
information about where Hardware events

00:22:14,510 --> 00:22:20,659
are occurring so gooeys are very

00:22:19,250 --> 00:22:22,700
powerful we just walk through a bunch of

00:22:20,659 --> 00:22:25,100
exercises where that's useful they're

00:22:22,700 --> 00:22:27,860
not useful in every case for every

00:22:25,100 --> 00:22:29,539
customer some you know it's difficult to

00:22:27,860 --> 00:22:32,779
apply in an automated fashion if you

00:22:29,539 --> 00:22:34,039
have thousands of projects you want to

00:22:32,779 --> 00:22:36,950
pour it it's difficult to run them all

00:22:34,039 --> 00:22:38,120
through a GUI from an IBM perspective

00:22:36,950 --> 00:22:39,679
it's expensive develop and it's

00:22:38,120 --> 00:22:42,350
expensive to get right usability is

00:22:39,679 --> 00:22:44,630
always a concern and some customers just

00:22:42,350 --> 00:22:46,610
don't want to use gooeys so what we've

00:22:44,630 --> 00:22:48,889
done over the last year or so is you

00:22:46,610 --> 00:22:51,950
tried to migrate some of the more used

00:22:48,889 --> 00:22:53,779
and more valuable tools from a GUI to a

00:22:51,950 --> 00:22:55,039
command line implementation so I'll talk

00:22:53,779 --> 00:22:57,289
about those a little bit they're all

00:22:55,039 --> 00:23:00,740
open source they become part of your

00:22:57,289 --> 00:23:04,760
cafeteria of tools and they are part of

00:23:00,740 --> 00:23:06,769
this github organization that we're

00:23:04,760 --> 00:23:09,980
gonna keep adding tools to over time and

00:23:06,769 --> 00:23:11,510
improving migration Weiser talked about

00:23:09,980 --> 00:23:13,730
the GUI version migration advisor for

00:23:11,510 --> 00:23:17,090
before this is the command line version

00:23:13,730 --> 00:23:21,799
of that it's very similar in technique

00:23:17,090 --> 00:23:23,899
it scans the code it reports portability

00:23:21,799 --> 00:23:25,970
portability issues and concerns it has a

00:23:23,899 --> 00:23:29,000
thing basically the same list of

00:23:25,970 --> 00:23:31,070
checkers that I showed under the the

00:23:29,000 --> 00:23:33,740
earlier GUI version the migration

00:23:31,070 --> 00:23:35,870
advisor it does not have the quick fix

00:23:33,740 --> 00:23:38,470
capability so this is basically a report

00:23:35,870 --> 00:23:40,669
that you could review and manually

00:23:38,470 --> 00:23:42,769
remediate

00:23:40,669 --> 00:23:44,720
keep moving here's an example of the

00:23:42,769 --> 00:23:47,690
report or it found a couple of instances

00:23:44,720 --> 00:23:48,509
where an on portable API call was being

00:23:47,690 --> 00:23:51,479
a

00:23:48,509 --> 00:23:53,789
vocht and then a similar example to

00:23:51,479 --> 00:23:55,409
before where an if def was found so that

00:23:53,789 --> 00:23:56,969
might need some visual inspection to

00:23:55,409 --> 00:24:00,239
find out if there's a slow path for

00:23:56,969 --> 00:24:02,099
power their source code advisor I talked

00:24:00,239 --> 00:24:05,129
earlier about the GUI version the source

00:24:02,099 --> 00:24:06,599
code advisor this command line version

00:24:05,129 --> 00:24:09,869
of source code visor again the very same

00:24:06,599 --> 00:24:12,329
technique leverages FTB are collects

00:24:09,869 --> 00:24:15,899
that journal generates a very visual and

00:24:12,329 --> 00:24:17,039
very readable report the command line

00:24:15,899 --> 00:24:18,449
version does not have the quick fix

00:24:17,039 --> 00:24:19,649
capability again so again this is a

00:24:18,449 --> 00:24:26,509
manual effort

00:24:19,649 --> 00:24:28,769
these things are work in progress I

00:24:26,509 --> 00:24:29,879
believe it should work with Fortran I'll

00:24:28,769 --> 00:24:32,159
if we done a lot of testing with that

00:24:29,879 --> 00:24:34,309
but anything where the the correct debug

00:24:32,159 --> 00:24:39,440
information is emitted should be good

00:24:34,309 --> 00:24:41,819
yes yeah that won't be the case for the

00:24:39,440 --> 00:24:44,940
migration advisor migration visor really

00:24:41,819 --> 00:24:46,529
works with seasons all right

00:24:44,940 --> 00:24:49,649
here's an example the output from the

00:24:46,529 --> 00:24:51,719
source code advisor this is a case where

00:24:49,649 --> 00:24:53,459
in the code it found an issue where a

00:24:51,719 --> 00:24:55,499
store was followed very quickly by a

00:24:53,459 --> 00:24:58,469
load which forces some flushes and it's

00:24:55,499 --> 00:25:00,029
performance disadvantage gives you a

00:24:58,469 --> 00:25:01,979
description gives you an idea of what

00:25:00,029 --> 00:25:04,309
something like it might look like

00:25:01,979 --> 00:25:08,579
including a potential remediation

00:25:04,309 --> 00:25:12,109
another case where an opportunity for

00:25:08,579 --> 00:25:14,789
inlining a function is recommended I

00:25:12,109 --> 00:25:16,649
talked earlier about the CPI breakdown

00:25:14,789 --> 00:25:17,789
tool this is a command line version of

00:25:16,649 --> 00:25:21,389
that basically admits the same

00:25:17,789 --> 00:25:23,669
information a two step process it will

00:25:21,389 --> 00:25:25,259
do a perf it will run per and gather all

00:25:23,669 --> 00:25:27,719
the performance information that it

00:25:25,259 --> 00:25:29,759
needs to display the CPI breakdown and

00:25:27,719 --> 00:25:32,549
then the CPI display command will

00:25:29,759 --> 00:25:34,559
display that let me show you output here

00:25:32,549 --> 00:25:39,659
this is edited because otherwise you get

00:25:34,559 --> 00:25:40,889
a very deep output so this allows you to

00:25:39,659 --> 00:25:42,479
kind of really see what what hardware

00:25:40,889 --> 00:25:45,419
events should should you focus on for

00:25:42,479 --> 00:25:46,829
further analysis and speaking of which

00:25:45,419 --> 00:25:48,479
see okay

00:25:46,829 --> 00:25:49,739
so another thing you can do is kind of

00:25:48,479 --> 00:25:52,289
filter the event so you can eliminate

00:25:49,739 --> 00:25:54,929
some of the very small and less current

00:25:52,289 --> 00:25:57,299
events the other thing that's not in the

00:25:54,929 --> 00:26:00,269
charts here that was just added within

00:25:57,299 --> 00:26:01,860
the last few days is an automatic drill

00:26:00,269 --> 00:26:04,170
down capability

00:26:01,860 --> 00:26:06,059
so that will run through some of these

00:26:04,170 --> 00:26:07,890
more frequently occurring Hardware

00:26:06,059 --> 00:26:10,380
events and automatically run another

00:26:07,890 --> 00:26:12,679
profiling round for you drilling down on

00:26:10,380 --> 00:26:15,330
those specific events and give you

00:26:12,679 --> 00:26:17,670
source code level information so you can

00:26:15,330 --> 00:26:19,290
actually look at which specific events

00:26:17,670 --> 00:26:22,230
are happening where they're happening so

00:26:19,290 --> 00:26:23,790
you can manually do some analysis and

00:26:22,230 --> 00:26:26,030
see if you can find ways to mitigate

00:26:23,790 --> 00:26:26,030
that

00:26:26,330 --> 00:26:30,480
so speaking of tools that were released

00:26:28,920 --> 00:26:32,610
in the last few days this tool was also

00:26:30,480 --> 00:26:36,660
released in the last few days also at

00:26:32,610 --> 00:26:39,570
that github organization if you're

00:26:36,660 --> 00:26:41,990
familiar with AIX AIX has a command

00:26:39,570 --> 00:26:46,520
called Kurt it is a utilization

00:26:41,990 --> 00:26:50,730
reporting tool we took that idea and

00:26:46,520 --> 00:26:54,390
re-implemented it in Python for to run

00:26:50,730 --> 00:26:56,340
under the perf command so you can

00:26:54,390 --> 00:27:00,600
collect a series of per five ants and

00:26:56,340 --> 00:27:02,910
then run that the script command against

00:27:00,600 --> 00:27:04,640
that with this Python script and getting

00:27:02,910 --> 00:27:07,380
all kinds of information about use

00:27:04,640 --> 00:27:09,960
utilization you can get it for a

00:27:07,380 --> 00:27:12,299
system-wide per process per task you can

00:27:09,960 --> 00:27:14,669
get users user tired kernel time idle

00:27:12,299 --> 00:27:16,620
time system call time hypervisor call

00:27:14,669 --> 00:27:18,870
times all kinds of information tasks

00:27:16,620 --> 00:27:22,080
migrations how much time is being sent

00:27:18,870 --> 00:27:26,220
by is being spent by in interrupts for

00:27:22,080 --> 00:27:28,530
each task etc so this can be a nice nice

00:27:26,220 --> 00:27:30,900
tool for situations where your

00:27:28,530 --> 00:27:33,240
utilization is this isn't it as high as

00:27:30,900 --> 00:27:35,010
you would like and the power systems are

00:27:33,240 --> 00:27:38,790
quite capable so you really want to get

00:27:35,010 --> 00:27:41,190
that utilization up high here's an

00:27:38,790 --> 00:27:44,549
example the output possibly difficult to

00:27:41,190 --> 00:27:47,730
read but it does show you a particular

00:27:44,549 --> 00:27:51,179
task this is a curl command that I was

00:27:47,730 --> 00:27:53,520
running you can see off to the right the

00:27:51,179 --> 00:27:55,710
utilization for this task is only three

00:27:53,520 --> 00:27:57,030
percent very low but that might be

00:27:55,710 --> 00:27:59,130
expected for a task that's gonna be

00:27:57,030 --> 00:28:00,809
waiting a lot for a network input gives

00:27:59,130 --> 00:28:02,850
you all the system calls how many times

00:28:00,809 --> 00:28:05,070
they were invoked how much time total

00:28:02,850 --> 00:28:07,860
was spent in those his calls average

00:28:05,070 --> 00:28:09,419
minimum maximum per syscall hypervisor

00:28:07,860 --> 00:28:11,160
calls that were invoked some very nice

00:28:09,419 --> 00:28:12,200
information detailed information about

00:28:11,160 --> 00:28:14,480
each task

00:28:12,200 --> 00:28:16,460
also a system-wide information what's

00:28:14,480 --> 00:28:18,350
your system doing how much time is it

00:28:16,460 --> 00:28:19,970
spending this system was nine percent

00:28:18,350 --> 00:28:23,539
utilized as you can see on the far right

00:28:19,970 --> 00:28:27,499
there so pretty low utilization in this

00:28:23,539 --> 00:28:29,210
case it was expected but anyway so

00:28:27,499 --> 00:28:30,139
hypervisor calls all the things that

00:28:29,210 --> 00:28:31,249
might give you some information about

00:28:30,139 --> 00:28:34,749
where you might want to look if your

00:28:31,249 --> 00:28:34,749
utilization is lower than it should be

00:28:35,590 --> 00:28:43,879
power functional simulators this is a

00:28:38,059 --> 00:28:46,009
full system simulation capability it

00:28:43,879 --> 00:28:48,350
basically simulates an entire power

00:28:46,009 --> 00:28:50,869
system on you or for example your your

00:28:48,350 --> 00:28:52,879
laptop you can get access to a power

00:28:50,869 --> 00:28:55,249
system without having the need for the

00:28:52,879 --> 00:28:56,600
actual power system great for basic

00:28:55,249 --> 00:28:58,879
development I talked a little bit about

00:28:56,600 --> 00:29:00,559
earlier about if you want to run an

00:28:58,879 --> 00:29:01,789
entire power development on your x86

00:29:00,559 --> 00:29:04,220
system this is one of the things that

00:29:01,789 --> 00:29:05,899
allow you to do that it will provide a

00:29:04,220 --> 00:29:09,049
single core single thread so the

00:29:05,899 --> 00:29:12,139
environment is fairly limited although

00:29:09,049 --> 00:29:13,399
it does have a power eight and a power

00:29:12,139 --> 00:29:16,129
nine system so you can do some early

00:29:13,399 --> 00:29:17,929
power mind about development and there's

00:29:16,129 --> 00:29:21,009
some ease of youth rapper scripts at the

00:29:17,929 --> 00:29:24,830
open power sdk organization and github

00:29:21,009 --> 00:29:26,659
so what does that allow you to do so you

00:29:24,830 --> 00:29:28,429
can take your X eighty-six laptop or on

00:29:26,659 --> 00:29:30,889
a single command it runs through

00:29:28,429 --> 00:29:32,389
firmware boot it runs through operating

00:29:30,889 --> 00:29:36,049
system boot you get all the way down to

00:29:32,389 --> 00:29:37,340
a PowerPC 64 le login prompt and from

00:29:36,049 --> 00:29:41,389
there you can do whatever you want this

00:29:37,340 --> 00:29:43,340
one and is a Debian image I believe so

00:29:41,389 --> 00:29:46,100
you can actually install packages you

00:29:43,340 --> 00:29:48,950
can install the advanced tool chain the

00:29:46,100 --> 00:29:51,769
performance will not be like a power

00:29:48,950 --> 00:29:54,259
system probably not surprisingly but it

00:29:51,769 --> 00:29:57,200
is pretty good it's certainly

00:29:54,259 --> 00:30:01,340
interactive and usable so might be

00:29:57,200 --> 00:30:05,269
something to check out performance

00:30:01,340 --> 00:30:07,759
simulator this is a tool that takes

00:30:05,269 --> 00:30:11,570
instruction traces and then we'll run it

00:30:07,759 --> 00:30:13,669
through a cycle accurate power cycle

00:30:11,570 --> 00:30:14,809
simulator so now I'd be interested if

00:30:13,669 --> 00:30:18,139
you're going to do some really fine

00:30:14,809 --> 00:30:20,989
grain analysis it's basically a tool

00:30:18,139 --> 00:30:23,179
that feeds output into other tools the

00:30:20,989 --> 00:30:24,490
actual output can be viewed directly

00:30:23,179 --> 00:30:27,700
with some included

00:30:24,490 --> 00:30:28,300
viewers just a quick note that it uses

00:30:27,700 --> 00:30:30,550
valgrind

00:30:28,300 --> 00:30:32,890
I trace command and that I trace command

00:30:30,550 --> 00:30:35,500
is not normally part of algorithm but it

00:30:32,890 --> 00:30:36,790
does come in the valgrind that comes

00:30:35,500 --> 00:30:41,620
with the advanced tool chain which is

00:30:36,790 --> 00:30:43,360
the first tool i mentioned way back just

00:30:41,620 --> 00:30:45,490
a quick run through how to use it you

00:30:43,360 --> 00:30:47,020
take the trace of your scenario there's

00:30:45,490 --> 00:30:49,270
some ways of kind of limiting and

00:30:47,020 --> 00:30:51,130
filtering the trace that it collects you

00:30:49,270 --> 00:30:53,500
do we have to do one conversion step and

00:30:51,130 --> 00:30:55,900
then you can run the instruction trace

00:30:53,500 --> 00:30:57,400
through the timer and then you can run

00:30:55,900 --> 00:31:00,700
the viewers what are the viewers look

00:30:57,400 --> 00:31:02,710
like so here's a viewer you see all the

00:31:00,700 --> 00:31:05,380
instructions laid out on the right and

00:31:02,710 --> 00:31:06,640
on the left are all of the cycles being

00:31:05,380 --> 00:31:09,220
spent for the instruction in every

00:31:06,640 --> 00:31:12,700
different phase of its existence from

00:31:09,220 --> 00:31:15,700
fetch to completion and then each of

00:31:12,700 --> 00:31:17,020
those cycles is annotated you can hover

00:31:15,700 --> 00:31:19,720
over those to get some information about

00:31:17,020 --> 00:31:21,190
what it's why is it delayed for example

00:31:19,720 --> 00:31:22,630
here the the cursor kind of in the

00:31:21,190 --> 00:31:25,420
middle of the screen is hovering over

00:31:22,630 --> 00:31:27,910
one of the lowercase s's and you can see

00:31:25,420 --> 00:31:29,830
at the top you can there's a description

00:31:27,910 --> 00:31:31,780
that says that it cannot issue because

00:31:29,830 --> 00:31:33,190
the sources are not ready so this is an

00:31:31,780 --> 00:31:35,980
example of an instruction that's waiting

00:31:33,190 --> 00:31:39,370
for one of its operands to come from a

00:31:35,980 --> 00:31:41,230
previous instruction another viewer

00:31:39,370 --> 00:31:42,340
that's included called J viewer is very

00:31:41,230 --> 00:31:45,100
very similar

00:31:42,340 --> 00:31:47,350
just a slight subtly different output

00:31:45,100 --> 00:31:50,080
here I've picked a different instruction

00:31:47,350 --> 00:31:53,200
that seems to have a long delay this one

00:31:50,080 --> 00:31:55,630
is delayed for example so hovered over a

00:31:53,200 --> 00:31:57,190
u that's because the unit is not free so

00:31:55,630 --> 00:31:59,230
you have some contention of processor

00:31:57,190 --> 00:32:01,510
resources there so again this is really

00:31:59,230 --> 00:32:06,610
low-level analysis if you want to get to

00:32:01,510 --> 00:32:08,020
that level again speaking of tools have

00:32:06,610 --> 00:32:11,230
been released recently this is also

00:32:08,020 --> 00:32:14,260
released in the last couple days so this

00:32:11,230 --> 00:32:16,660
takes those psycho accurate reports and

00:32:14,260 --> 00:32:19,090
we'll go through and generate an

00:32:16,660 --> 00:32:22,150
enormous amount of statistics frankly

00:32:19,090 --> 00:32:24,130
for the data that's included in those

00:32:22,150 --> 00:32:26,860
reports and you know tell you where were

00:32:24,130 --> 00:32:29,820
the most executed loops where the most

00:32:26,860 --> 00:32:32,110
executed misaligned short loops

00:32:29,820 --> 00:32:32,970
incorrectly hinted branch instructions

00:32:32,110 --> 00:32:35,820
all kind

00:32:32,970 --> 00:32:37,650
of things so if you really want to get

00:32:35,820 --> 00:32:39,750
down to this level this thing's very

00:32:37,650 --> 00:32:41,039
handy for compiler writers but it if you

00:32:39,750 --> 00:32:44,039
want to do some really fine grain

00:32:41,039 --> 00:32:47,870
analysis on your completion code on your

00:32:44,039 --> 00:32:50,010
power systems this is a fantastic tool

00:32:47,870 --> 00:32:51,780
here's an example of the output I'm not

00:32:50,010 --> 00:32:53,340
going to go through that the typeset to

00:32:51,780 --> 00:32:56,220
watch it comes with some very good

00:32:53,340 --> 00:32:57,830
documentation which explains what it's

00:32:56,220 --> 00:33:00,480
doing and what it what all this

00:32:57,830 --> 00:33:04,020
information means one thing I do want to

00:33:00,480 --> 00:33:04,919
highlight just as a example is there you

00:33:04,020 --> 00:33:06,630
can see in the middle I've kind of

00:33:04,919 --> 00:33:08,880
highlighted it this is a branch

00:33:06,630 --> 00:33:10,860
instruction that had a bad hint right so

00:33:08,880 --> 00:33:13,799
it's only taken you can see off to the

00:33:10,860 --> 00:33:16,740
right the prob flag says it's taken

00:33:13,799 --> 00:33:19,080
about 35% of the time where the hint

00:33:16,740 --> 00:33:23,549
said take it all the time or nearly all

00:33:19,080 --> 00:33:25,799
the time so this is this is a bad branch

00:33:23,549 --> 00:33:28,770
instruction the modern processors do a

00:33:25,799 --> 00:33:31,289
very good job of predicting branches and

00:33:28,770 --> 00:33:34,200
in fact most modern compilers don't even

00:33:31,289 --> 00:33:35,909
issue code that has branch instructions

00:33:34,200 --> 00:33:37,799
anymore so this may be a case of where

00:33:35,909 --> 00:33:40,200
you're running code that was built with

00:33:37,799 --> 00:33:42,659
earlier versions of GCC so that might

00:33:40,200 --> 00:33:44,400
tell you you need to maybe use the

00:33:42,659 --> 00:33:47,480
advanced tool chain to get the newer

00:33:44,400 --> 00:33:47,480
libraries on your system

00:33:47,690 --> 00:33:58,260
TV Guide this is a suite of vector

00:33:54,320 --> 00:33:59,940
intrinsics that are not in not part of

00:33:58,260 --> 00:34:05,299
the power is a but are likely to be

00:33:59,940 --> 00:34:07,740
useful to the users of vector code

00:34:05,299 --> 00:34:09,839
higher-order functions not directly

00:34:07,740 --> 00:34:12,359
implemented in the ISA it is open source

00:34:09,839 --> 00:34:14,280
in the form of header files I'm not

00:34:12,359 --> 00:34:16,349
going to go into a great amount of

00:34:14,280 --> 00:34:19,230
detail here here's a list of some of the

00:34:16,349 --> 00:34:25,440
functions that are included there this

00:34:19,230 --> 00:34:29,389
is C yeah yep and then think I'm almost

00:34:25,440 --> 00:34:33,000
done I think how much note of time

00:34:29,389 --> 00:34:35,330
speedy is a another toolkit that sets up

00:34:33,000 --> 00:34:37,349
some neat capabilities for inter-process

00:34:35,330 --> 00:34:40,169
communication where you have a shared

00:34:37,349 --> 00:34:41,429
address space between processes so you

00:34:40,169 --> 00:34:43,919
can actually pass pointers back and

00:34:41,429 --> 00:34:45,330
forth between processes it can make

00:34:43,919 --> 00:34:46,290
inter-process communication more

00:34:45,330 --> 00:34:48,330
efficiently

00:34:46,290 --> 00:34:49,740
more efficient built on that basic

00:34:48,330 --> 00:34:52,050
infrastructure or a couple of neat

00:34:49,740 --> 00:34:55,050
capabilities like lock less logging so

00:34:52,050 --> 00:34:56,400
you can have multi process logging which

00:34:55,050 --> 00:34:58,230
is attack you really want to kind of

00:34:56,400 --> 00:34:59,460
it's kind of a necessary evil but you'd

00:34:58,230 --> 00:35:00,780
like it to get out of the way so if you

00:34:59,460 --> 00:35:04,220
could do it lock Leslie so much the

00:35:00,780 --> 00:35:05,940
better on top of that is a multi-process

00:35:04,220 --> 00:35:08,820
producer-consumer queue that our lock

00:35:05,940 --> 00:35:10,350
lists and also there has another thing

00:35:08,820 --> 00:35:11,820
where you do fast time stamps instead of

00:35:10,350 --> 00:35:14,430
calling get time of day which is going

00:35:11,820 --> 00:35:15,990
to be a system call you can do with the

00:35:14,430 --> 00:35:19,440
single instruction move from special

00:35:15,990 --> 00:35:22,230
purpose register last thing I want to

00:35:19,440 --> 00:35:26,340
talk about take a breath

00:35:22,230 --> 00:35:27,870
LP CPU is a tool kit we use to collect

00:35:26,340 --> 00:35:29,820
data on a customer system if the

00:35:27,870 --> 00:35:31,200
reporting performance issue we've made

00:35:29,820 --> 00:35:33,300
that available to the public that's been

00:35:31,200 --> 00:35:36,210
out for a while now there's not that

00:35:33,300 --> 00:35:38,820
much awareness of it though it doesn't

00:35:36,210 --> 00:35:40,620
really need stuff that I use it's a

00:35:38,820 --> 00:35:41,940
two-step process where you collect the

00:35:40,620 --> 00:35:44,010
data on the system and then you can

00:35:41,940 --> 00:35:46,230
offload it all in a big giant tar ball

00:35:44,010 --> 00:35:48,770
and then post-process it somewhere else

00:35:46,230 --> 00:35:50,880
and it generates some nice graphs and

00:35:48,770 --> 00:35:54,020
collects a lot of really useful data

00:35:50,880 --> 00:35:56,850
using the the suite of tools here and

00:35:54,020 --> 00:35:58,770
can provide oh here's here's a

00:35:56,850 --> 00:36:01,380
run-through of how to use it basically

00:35:58,770 --> 00:36:03,510
just on tar it and run it and then pull

00:36:01,380 --> 00:36:06,210
the data back off and post-process it

00:36:03,510 --> 00:36:08,070
and an included script you can generate

00:36:06,210 --> 00:36:11,430
some really nice graphs that are

00:36:08,070 --> 00:36:12,980
interactive you can zoom in zoom out for

00:36:11,430 --> 00:36:18,150
you know processor utilization

00:36:12,980 --> 00:36:21,630
instruction counts dirty memory things

00:36:18,150 --> 00:36:23,850
like that last thing when I was talking

00:36:21,630 --> 00:36:24,990
about talk about is support only a

00:36:23,850 --> 00:36:26,760
couple of these tools are really

00:36:24,990 --> 00:36:28,170
officially supportable through the IBM

00:36:26,760 --> 00:36:30,780
support line that's the advanced tool

00:36:28,170 --> 00:36:32,100
tuning the X del compilers but what we'd

00:36:30,780 --> 00:36:33,750
really like to do from an IBM

00:36:32,100 --> 00:36:35,280
perspective from a community perspective

00:36:33,750 --> 00:36:38,550
has developed a lot more than

00:36:35,280 --> 00:36:40,740
knowledgebase in the in the community to

00:36:38,550 --> 00:36:42,420
get the internal communications more

00:36:40,740 --> 00:36:44,400
external so that people that are

00:36:42,420 --> 00:36:46,620
countering issues on the power platform

00:36:44,400 --> 00:36:48,660
know where to go to talk about those

00:36:46,620 --> 00:36:50,370
things to solve kind of what I might

00:36:48,660 --> 00:36:52,020
call the Google problem if you find a

00:36:50,370 --> 00:36:54,810
problem on power can you google for it

00:36:52,020 --> 00:36:56,340
and find the answer so there's a linux

00:36:54,810 --> 00:36:58,360
empower developer portal what's new

00:36:56,340 --> 00:37:00,790
within the last year or so

00:36:58,360 --> 00:37:03,840
it replaces the Linux on Linux sorry the

00:37:00,790 --> 00:37:07,180
developerworks Linux empower community

00:37:03,840 --> 00:37:08,950
within the powered developer portal

00:37:07,180 --> 00:37:11,320
there's a DW answers forum so you can

00:37:08,950 --> 00:37:14,050
ask a question experts in IBM and

00:37:11,320 --> 00:37:15,360
elsewhere are monitoring those forums so

00:37:14,050 --> 00:37:17,950
if you'll get an answer fairly quickly

00:37:15,360 --> 00:37:19,900
as well the general forms we want to

00:37:17,950 --> 00:37:22,600
encourage discussion there so stack

00:37:19,900 --> 00:37:24,610
overflow server fall etc and then if you

00:37:22,600 --> 00:37:26,230
want to fear one tolerate the Layton

00:37:24,610 --> 00:37:29,500
sees in IRC you can talk on the IRC

00:37:26,230 --> 00:37:31,120
channels as well I think that's about it

00:37:29,500 --> 00:37:32,260
I put some random clipart up here so you

00:37:31,120 --> 00:37:33,940
can have something to look at but

00:37:32,260 --> 00:37:37,090
there's no significance to it

00:37:33,940 --> 00:37:40,860
I thank you for your time and enjoy the

00:37:37,090 --> 00:37:43,939
rest of the conference yes

00:37:40,860 --> 00:37:43,939
[Music]

00:37:46,769 --> 00:37:49,769
yeah

00:37:56,340 --> 00:38:01,300
right right so the question was

00:37:59,020 --> 00:38:05,380
concerned about lock-in if you're using

00:38:01,300 --> 00:38:06,670
the the supported version of the Excel

00:38:05,380 --> 00:38:08,140
compilers having the Community Edition

00:38:06,670 --> 00:38:10,570
kind of makes that lock-in less of a

00:38:08,140 --> 00:38:13,120
concern yeah thank you yeah that's a

00:38:10,570 --> 00:38:14,920
good comment yeah I'm glad they they I'm

00:38:13,120 --> 00:38:16,510
rather to remove some of the feature

00:38:14,920 --> 00:38:17,620
limitations too so now it's basically

00:38:16,510 --> 00:38:21,550
you get what you get

00:38:17,620 --> 00:38:23,670
no limitation of support so yeah good

00:38:21,550 --> 00:38:26,300
comment thank you any other questions

00:38:23,670 --> 00:38:31,109
thank you

00:38:26,300 --> 00:38:31,109

YouTube URL: https://www.youtube.com/watch?v=PJwnfDSHOLI


