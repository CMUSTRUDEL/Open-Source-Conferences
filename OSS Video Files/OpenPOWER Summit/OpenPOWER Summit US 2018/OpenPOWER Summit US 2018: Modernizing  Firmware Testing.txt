Title: OpenPOWER Summit US 2018: Modernizing  Firmware Testing
Publication date: 2018-04-03
Playlist: OpenPOWER Summit US 2018
Description: 
	OpenPOWER member from IBM discusses modernizing firmware testing on POWER with Python at the OpenPOWER Summit 2018.

Presenter:
- Stewart Smith, OPAL Architect, IBM

For more information, please visit: http://www.openpowerfoundation.org
Captions: 
	00:00:00,000 --> 00:00:08,550
cool I'm Stuart I'm currently at IBM

00:00:04,700 --> 00:00:10,380
working on open pal firmware and I'm

00:00:08,550 --> 00:00:14,070
gonna talk about modernizing firmware

00:00:10,380 --> 00:00:15,750
testing so you may be familiar with this

00:00:14,070 --> 00:00:20,539
power CPU architecture which hopefully

00:00:15,750 --> 00:00:22,289
you are and paranoia itself and

00:00:20,539 --> 00:00:24,539
specifically I'm going to focus on a

00:00:22,289 --> 00:00:27,990
system that's known internally as with

00:00:24,539 --> 00:00:30,750
the spoon but is publicly known as AC 9

00:00:27,990 --> 00:00:33,660
to 2 because you get product names and

00:00:30,750 --> 00:00:36,090
numbers rather than big long names there

00:00:33,660 --> 00:00:39,090
and it's all about talking about

00:00:36,090 --> 00:00:41,520
firmware with pre-release everything so

00:00:39,090 --> 00:00:44,489
when we look at problems during machine

00:00:41,520 --> 00:00:47,219
bring up and and and getting things

00:00:44,489 --> 00:00:49,649
ready to release bugs can pretty much

00:00:47,219 --> 00:00:52,739
live anywhere so the case itself at the

00:00:49,649 --> 00:00:54,360
bottom layer is probably usually ok we

00:00:52,739 --> 00:00:56,100
haven't actually had to rework cases

00:00:54,360 --> 00:00:57,360
except for that one time on one system

00:00:56,100 --> 00:00:58,530
where you couldn't press the power

00:00:57,360 --> 00:01:00,770
button with the front of it on it was

00:00:58,530 --> 00:01:03,030
hilarious but usually the cases bug free

00:01:00,770 --> 00:01:04,199
the planer itself so the motherboard

00:01:03,030 --> 00:01:06,510
there there's definitely going to be

00:01:04,199 --> 00:01:08,640
revisions of that so a bug in in a

00:01:06,510 --> 00:01:09,840
system that a problem could be because

00:01:08,640 --> 00:01:11,400
the component was missed off the

00:01:09,840 --> 00:01:12,630
motherboard so literally been a problem

00:01:11,400 --> 00:01:14,640
you have to go in and sold her a

00:01:12,630 --> 00:01:16,350
resistor onto there because it was

00:01:14,640 --> 00:01:18,990
missing in the original design so the

00:01:16,350 --> 00:01:21,330
bug could be in the planer the BMC we've

00:01:18,990 --> 00:01:24,270
got a little BMC card off the side so

00:01:21,330 --> 00:01:26,220
it's on board on the on the Zayas left

00:01:24,270 --> 00:01:29,159
paralyzed e2 but other systems it's plug

00:01:26,220 --> 00:01:32,820
in one and we had new hardware on the

00:01:29,159 --> 00:01:36,299
BMC so a new AST 2500 as well as open

00:01:32,820 --> 00:01:38,939
BMC so a new BMC firmware stack on p8 we

00:01:36,299 --> 00:01:42,240
had an ami or Super Micro base BMC stack

00:01:38,939 --> 00:01:45,299
depending on a machine and in p9 it's

00:01:42,240 --> 00:01:48,630
now open BMC on Witherspoon and we still

00:01:45,299 --> 00:01:50,790
have a Mayan Super Micro based BMC's as

00:01:48,630 --> 00:01:52,710
well but with an open source BMC stack

00:01:50,790 --> 00:01:54,149
things going to be different right it's

00:01:52,710 --> 00:01:56,100
not exactly the same it was dealt with

00:01:54,149 --> 00:01:58,049
before so bugs could exist between

00:01:56,100 --> 00:01:59,729
interacting with the BMC from host

00:01:58,049 --> 00:02:02,340
firmware or could exist on the BMC

00:01:59,729 --> 00:02:04,079
themselves or indeed you could run into

00:02:02,340 --> 00:02:07,409
interesting things related to the

00:02:04,079 --> 00:02:08,729
hardware their RAM the memory modules

00:02:07,409 --> 00:02:10,979
themselves usually glf all we do

00:02:08,729 --> 00:02:12,900
actually have yeah really pre-release

00:02:10,979 --> 00:02:13,510
memory which is probably good so you can

00:02:12,900 --> 00:02:14,739
usually trust

00:02:13,510 --> 00:02:16,269
around to work that could of course be

00:02:14,739 --> 00:02:19,510
bugs in the memory controller talking to

00:02:16,269 --> 00:02:22,120
the RAM but we can definitely mostly

00:02:19,510 --> 00:02:24,010
counting them to work the fans believe

00:02:22,120 --> 00:02:25,569
it or not we have revisions in fam fan

00:02:24,010 --> 00:02:27,939
assemblies and how we interact with them

00:02:25,569 --> 00:02:29,890
from the BMC and of course you know if

00:02:27,939 --> 00:02:31,299
you can't pump enough air out of it

00:02:29,890 --> 00:02:32,680
you're not calling things is now much

00:02:31,299 --> 00:02:34,930
they're not gonna get high CPU

00:02:32,680 --> 00:02:36,159
frequencies so a performance problem on

00:02:34,930 --> 00:02:37,360
the host that you think could be a

00:02:36,159 --> 00:02:39,310
firmware problem of all you're not

00:02:37,360 --> 00:02:41,170
setting the CPU frequency could actually

00:02:39,310 --> 00:02:43,659
be because the BMC isn't controlling the

00:02:41,170 --> 00:02:46,209
fans correctly so we've had revisions in

00:02:43,659 --> 00:02:50,890
fans one of the things of course we have

00:02:46,209 --> 00:02:54,459
is CPUs so new CPU new power 9 we get

00:02:50,890 --> 00:02:56,920
first silicon right so we watch intently

00:02:54,459 --> 00:02:58,959
as the first wafer comes off the

00:02:56,920 --> 00:03:01,090
production line and it's cut up and put

00:02:58,959 --> 00:03:02,829
into modules and we put it in a system

00:03:01,090 --> 00:03:05,159
and then the job is to make it boot and

00:03:02,829 --> 00:03:08,530
they're not just boot but like you know

00:03:05,159 --> 00:03:09,879
work something like a computer we not

00:03:08,530 --> 00:03:12,670
only get up to a login prompt but you

00:03:09,879 --> 00:03:14,620
have IR going and there's certainly bugs

00:03:12,670 --> 00:03:16,659
in first silicon as anything comes off

00:03:14,620 --> 00:03:18,340
first like just like software you know

00:03:16,659 --> 00:03:20,530
it compiles doesn't mean it's gonna work

00:03:18,340 --> 00:03:21,849
properly first time with silicon of

00:03:20,530 --> 00:03:23,889
course you get a whole bunch of pre

00:03:21,849 --> 00:03:26,709
validation checks and and that kind of

00:03:23,889 --> 00:03:28,569
buzz but problems can certainly be bugs

00:03:26,709 --> 00:03:30,519
in silicon and that can be bugs that can

00:03:28,569 --> 00:03:33,760
be worked around it can be bugs that of

00:03:30,519 --> 00:03:35,530
course require another silicon rev or it

00:03:33,760 --> 00:03:36,879
can be you know subtle firmware changes

00:03:35,530 --> 00:03:38,620
in some ways of the family to work

00:03:36,879 --> 00:03:41,260
around those kind of problems and

00:03:38,620 --> 00:03:42,639
certainly you know we find CPU bugs and

00:03:41,260 --> 00:03:45,459
they get fixed or we work around them

00:03:42,639 --> 00:03:48,819
and that means that you know got another

00:03:45,459 --> 00:03:51,010
nice layer of uncertainty we have PCIe

00:03:48,819 --> 00:03:54,190
cards believenot with power line stuff

00:03:51,010 --> 00:03:56,409
not only do we have new PCIe gen 4 we

00:03:54,190 --> 00:03:58,419
have new PCI cards as well so there can

00:03:56,409 --> 00:04:00,459
be legitimate problems related to PCIe

00:03:58,419 --> 00:04:01,930
Gen 4 stuff on the chip that we could

00:04:00,459 --> 00:04:03,400
have bugs with we want to make sure we

00:04:01,930 --> 00:04:05,139
find and eliminate there could be

00:04:03,400 --> 00:04:06,699
interactions with the cards themselves

00:04:05,139 --> 00:04:08,590
that are new or the firmware that runs

00:04:06,699 --> 00:04:11,049
on the cards so we've had issues that

00:04:08,590 --> 00:04:13,510
are actually fixed simply by updating

00:04:11,049 --> 00:04:15,519
the firmware on a pre-release PCI a Gen

00:04:13,510 --> 00:04:17,320
4 card that then make everything work

00:04:15,519 --> 00:04:19,150
right from a host of firmware

00:04:17,320 --> 00:04:20,349
perspective and that's kind of an

00:04:19,150 --> 00:04:21,549
interesting thing there and of course

00:04:20,349 --> 00:04:23,320
you know not everyone considers

00:04:21,549 --> 00:04:24,940
upgrading their firmware on the PCIe

00:04:23,320 --> 00:04:27,070
cards this includes when you're doing a

00:04:24,940 --> 00:04:29,470
pre-release machines

00:04:27,070 --> 00:04:31,660
we even have GPUs in this system which

00:04:29,470 --> 00:04:33,820
of course we worked with Nvidia so they

00:04:31,660 --> 00:04:35,320
got first silicon on their GPUs so at

00:04:33,820 --> 00:04:37,300
one point you literally had you know

00:04:35,320 --> 00:04:39,460
first silicon of the power nine on the

00:04:37,300 --> 00:04:42,490
first roof of motherboard with you know

00:04:39,460 --> 00:04:45,040
first Rev of BMC firmware with first Rev

00:04:42,490 --> 00:04:46,540
of brand-new GPUs and it was pre-release

00:04:45,040 --> 00:04:48,340
like everything first out the bat and

00:04:46,540 --> 00:04:49,930
the miracle is that you know that ever

00:04:48,340 --> 00:04:51,610
you know booted let alone actually

00:04:49,930 --> 00:04:53,770
worked and be functional it's a real

00:04:51,610 --> 00:04:55,630
credit to engineering resources going on

00:04:53,770 --> 00:04:57,460
there and of course then the process and

00:04:55,630 --> 00:04:59,530
coming up to you know around about now

00:04:57,460 --> 00:05:01,330
is to find the big problems and

00:04:59,530 --> 00:05:02,950
eliminate them so that was really sort

00:05:01,330 --> 00:05:05,890
of yeah where we started with was

00:05:02,950 --> 00:05:09,310
pre-release absolute everything and go

00:05:05,890 --> 00:05:11,830
from there and you know my subset of

00:05:09,310 --> 00:05:13,360
firmware that that I maintain interacts

00:05:11,830 --> 00:05:14,830
with a lot of these components there are

00:05:13,360 --> 00:05:15,820
a lot of components of firmware and I'll

00:05:14,830 --> 00:05:17,380
talk about that in a bit

00:05:15,820 --> 00:05:19,690
but the real purpose of firmware is to

00:05:17,380 --> 00:05:20,620
never be noticed right the whole purpose

00:05:19,690 --> 00:05:22,150
is if you're ever thinking about

00:05:20,620 --> 00:05:23,919
firmware someone's messed up somewhere

00:05:22,150 --> 00:05:25,450
it should be something that just works

00:05:23,919 --> 00:05:28,570
because after all you want the computer

00:05:25,450 --> 00:05:29,890
to boot and this is the video recording

00:05:28,570 --> 00:05:31,900
of the p8 booting because I didn't

00:05:29,890 --> 00:05:34,540
record a p9 in time so I use the old one

00:05:31,900 --> 00:05:35,740
but no one notices right don't look at

00:05:34,540 --> 00:05:37,750
the magic behind the curve but the idea

00:05:35,740 --> 00:05:39,730
is you boot up and you can you know boot

00:05:37,750 --> 00:05:41,440
in OS and then you're done right and

00:05:39,730 --> 00:05:44,919
that's a bit faster than reality but

00:05:41,440 --> 00:05:46,720
we're getting quicker on on on p9 as

00:05:44,919 --> 00:05:47,800
well and of course especially with

00:05:46,720 --> 00:05:49,600
things like the choral lab

00:05:47,800 --> 00:05:51,010
supercomputers in like they really do

00:05:49,600 --> 00:05:52,510
expect their computers to boot as in

00:05:51,010 --> 00:05:54,400
anyone who's going to get one I want it

00:05:52,510 --> 00:05:55,750
to boot they want it to be reliably you

00:05:54,400 --> 00:05:58,450
want to always detect that the hardware

00:05:55,750 --> 00:06:00,850
is there and that means you also want it

00:05:58,450 --> 00:06:02,229
to work all the time the hardware there

00:06:00,850 --> 00:06:04,840
and it's always going to work with that

00:06:02,229 --> 00:06:07,720
hardware and always show up and not have

00:06:04,840 --> 00:06:09,280
random problems as well we also want it

00:06:07,720 --> 00:06:11,470
to perform well so we have to do things

00:06:09,280 --> 00:06:13,300
like set up CPU frequency scaling and

00:06:11,470 --> 00:06:15,130
all that kind of jazz as well and the

00:06:13,300 --> 00:06:17,860
firmware stack for p9 of course comes

00:06:15,130 --> 00:06:20,290
under open power so open power side with

00:06:17,860 --> 00:06:22,900
power right all under the open power

00:06:20,290 --> 00:06:23,860
foundation and para nine had people

00:06:22,900 --> 00:06:27,250
involved in firming would bring up

00:06:23,860 --> 00:06:29,560
really early so with p8 the open power

00:06:27,250 --> 00:06:31,090
machine sort of came along sort of just

00:06:29,560 --> 00:06:33,040
as wordy Ang's of the IBM enterprise

00:06:31,090 --> 00:06:35,349
machines then there was to focus on the

00:06:33,040 --> 00:06:37,210
open pal machines p9 stuff like partners

00:06:35,349 --> 00:06:40,120
hat also had like first drive silicon

00:06:37,210 --> 00:06:43,360
like we're coming out the door working

00:06:40,120 --> 00:06:45,130
hand-in-hand on on firmware bring up and

00:06:43,360 --> 00:06:46,840
so testing was not just you know for us

00:06:45,130 --> 00:06:49,090
but to reproduce problems that partners

00:06:46,840 --> 00:06:51,880
saw and to find all the problems there

00:06:49,090 --> 00:06:53,229
and so when does firmware start so you

00:06:51,880 --> 00:06:57,180
might know what date it is now or at

00:06:53,229 --> 00:06:59,949
least approximately what date it is but

00:06:57,180 --> 00:07:02,830
this is when we first added support for

00:06:59,949 --> 00:07:05,620
the Witherspoon system so that AC 92 in

00:07:02,830 --> 00:07:06,699
the upstream host firmware so this was

00:07:05,620 --> 00:07:08,020
you know the first thing started

00:07:06,699 --> 00:07:09,880
shipping around you in December we've

00:07:08,020 --> 00:07:12,460
got like big geo stuff coming up now and

00:07:09,880 --> 00:07:15,820
about a year prior was where we actually

00:07:12,460 --> 00:07:17,320
had the code upstream so we're talking

00:07:15,820 --> 00:07:18,789
about you know talk about open it's like

00:07:17,320 --> 00:07:21,130
not many systems you get the firmware a

00:07:18,789 --> 00:07:24,039
year before the box ships and this is

00:07:21,130 --> 00:07:25,630
you know possibly to the point where we

00:07:24,039 --> 00:07:26,830
had you know one system somewhere with

00:07:25,630 --> 00:07:29,199
enough things in it to boot I can't

00:07:26,830 --> 00:07:30,639
remember actually Zayas was even earlier

00:07:29,199 --> 00:07:32,740
so the partner machine isn't that one

00:07:30,639 --> 00:07:35,229
there its firmware was up like a month

00:07:32,740 --> 00:07:36,490
beforehand right so we're talking about

00:07:35,229 --> 00:07:38,350
you know working with partners really

00:07:36,490 --> 00:07:41,020
early on and having a real you know open

00:07:38,350 --> 00:07:44,260
power environment the Google / Rackspace

00:07:41,020 --> 00:07:46,450
box was was upstream a lot earlier or a

00:07:44,260 --> 00:07:48,130
lot is a month and this was like the

00:07:46,450 --> 00:07:49,090
start of it this would get you enough to

00:07:48,130 --> 00:07:50,800
sort of do the rest of firmware

00:07:49,090 --> 00:07:52,720
development to basically say let's find

00:07:50,800 --> 00:07:55,000
all the rest of the bugs and fix that we

00:07:52,720 --> 00:07:57,220
also had open BMC say goodbye to

00:07:55,000 --> 00:07:59,800
proprietary BMC's all fully open source

00:07:57,220 --> 00:08:01,810
firmware stack on the BMC is great and I

00:07:59,800 --> 00:08:04,500
looked back and said when did the open

00:08:01,810 --> 00:08:09,849
BMC work go upstream so for with a spoon

00:08:04,500 --> 00:08:12,190
as an AC 92 it turns out June 2016 is

00:08:09,849 --> 00:08:15,550
when the support for that went in and

00:08:12,190 --> 00:08:16,690
that was pre even like I believe we

00:08:15,550 --> 00:08:19,300
didn't even have like motherboards for

00:08:16,690 --> 00:08:20,860
that yet it was just the BMC card itself

00:08:19,300 --> 00:08:23,110
so it's a removable card if you're look

00:08:20,860 --> 00:08:24,910
at the AC 92 there's a card with a BMC

00:08:23,110 --> 00:08:27,220
that comes out so there's literally one

00:08:24,910 --> 00:08:29,020
of these on a desk with alligator clips

00:08:27,220 --> 00:08:30,190
into the power supply and a couple of

00:08:29,020 --> 00:08:32,140
other things off there and you got the

00:08:30,190 --> 00:08:33,250
BMC running on that and then it was

00:08:32,140 --> 00:08:35,200
you've course could twiddle the right

00:08:33,250 --> 00:08:36,729
GPIO s to see whether the thing was

00:08:35,200 --> 00:08:38,200
booting and get all the initial bring up

00:08:36,729 --> 00:08:40,539
Darden because once we got actual power

00:08:38,200 --> 00:08:41,589
9 silicon of course the BMC has to be

00:08:40,539 --> 00:08:43,450
able to turn the computer on all we

00:08:41,589 --> 00:08:46,000
can't do any development and so that was

00:08:43,450 --> 00:08:47,200
when things started there and I'm not

00:08:46,000 --> 00:08:49,480
really gonna talk about from BMC

00:08:47,200 --> 00:08:51,940
but the host firmware code is pretty

00:08:49,480 --> 00:08:54,010
interesting so there's about 1.1 million

00:08:51,940 --> 00:08:56,470
lines of power specific

00:08:54,010 --> 00:08:58,690
code on the host firmware so on the

00:08:56,470 --> 00:09:00,760
firmware that runs on the p9 chip it's

00:08:58,690 --> 00:09:03,610
about a million on custom minds and if

00:09:00,760 --> 00:09:05,889
you add up the entirety of the rest of

00:09:03,610 --> 00:09:06,820
the firmware components as in your build

00:09:05,889 --> 00:09:08,529
route that we use to build the

00:09:06,820 --> 00:09:10,389
environment you know Linux that we use a

00:09:08,529 --> 00:09:12,399
Linux kernel as part of our firmware to

00:09:10,389 --> 00:09:14,410
you know talk to all the i/o devices

00:09:12,399 --> 00:09:15,850
because well I write a separate device

00:09:14,410 --> 00:09:17,050
driver for firmware to be able to boot

00:09:15,850 --> 00:09:18,279
off a disk when we could just use the

00:09:17,050 --> 00:09:20,380
one in Linux and be done with it

00:09:18,279 --> 00:09:21,670
so we do that we're using a busy box in

00:09:20,380 --> 00:09:24,100
their petty boot which does the little

00:09:21,670 --> 00:09:25,000
UI to select what kernel to boot boot if

00:09:24,100 --> 00:09:26,709
you add up all that it's like

00:09:25,000 --> 00:09:28,300
30-something million lines of code and

00:09:26,709 --> 00:09:29,829
there's only about a million lines of

00:09:28,300 --> 00:09:31,180
power specific and this is sort of an

00:09:29,829 --> 00:09:33,339
advantage of sort of a very open

00:09:31,180 --> 00:09:35,529
ecosystem as we just reuse open source

00:09:33,339 --> 00:09:38,199
code contribute a whole bunch of it back

00:09:35,529 --> 00:09:39,880
and be really smart about where we're

00:09:38,199 --> 00:09:42,040
spending our engineering resources and

00:09:39,880 --> 00:09:44,260
of course this million lines of code is

00:09:42,040 --> 00:09:46,480
interacting with a lot of hardware the

00:09:44,260 --> 00:09:49,600
Pennine chip which goes into a server

00:09:46,480 --> 00:09:51,339
which is a lot of hardware and then they

00:09:49,600 --> 00:09:55,120
have more hardware than not just the

00:09:51,339 --> 00:09:56,769
chip but how do we go from there so what

00:09:55,120 --> 00:09:58,360
do you do how do you test it how do you

00:09:56,769 --> 00:10:01,529
test this whole host of firmware thing

00:09:58,360 --> 00:10:05,380
combining with a bit of stuff there well

00:10:01,529 --> 00:10:07,779
boots ship it right yeah now we can't

00:10:05,380 --> 00:10:08,860
really rely on now on just that it turns

00:10:07,779 --> 00:10:11,230
out you can have a lot of things still

00:10:08,860 --> 00:10:13,269
broken and still boot if it reboots then

00:10:11,230 --> 00:10:14,860
you should totally ship it like if you

00:10:13,269 --> 00:10:17,860
can not only boot the machine but reboot

00:10:14,860 --> 00:10:19,389
it like that's perfect and that's

00:10:17,860 --> 00:10:21,130
definitely you know not the standard

00:10:19,389 --> 00:10:22,990
that we hold ourselves to when shipping

00:10:21,130 --> 00:10:25,389
as an open source project getting

00:10:22,990 --> 00:10:28,420
getting firmer out there it is

00:10:25,389 --> 00:10:31,630
definitely a standard that is a joke and

00:10:28,420 --> 00:10:33,760
should only ever be a joke but we also

00:10:31,630 --> 00:10:35,170
wanted to make sure that partners who

00:10:33,760 --> 00:10:36,880
are producing machines or other people

00:10:35,170 --> 00:10:37,540
who are producing machines don't think

00:10:36,880 --> 00:10:40,329
that's sufficient

00:10:37,540 --> 00:10:41,709
so tales from some other architectures

00:10:40,329 --> 00:10:43,240
is that you know people got to that

00:10:41,709 --> 00:10:44,889
stage where all are kaput so that's it

00:10:43,240 --> 00:10:46,420
with finder ship the computer and then

00:10:44,889 --> 00:10:48,910
you're stuck as operating system

00:10:46,420 --> 00:10:50,529
engineers deciphering what random bugs

00:10:48,910 --> 00:10:51,819
and faults were in firmware and having

00:10:50,529 --> 00:10:53,199
to work around them and we don't want

00:10:51,819 --> 00:10:55,240
that for power we don't want to have to

00:10:53,199 --> 00:10:58,300
have a million and one firmware

00:10:55,240 --> 00:10:59,500
workarounds in Linux we want to be able

00:10:58,300 --> 00:11:01,690
to have something that is you know a

00:10:59,500 --> 00:11:03,459
healthy open ecosystem that is well

00:11:01,690 --> 00:11:05,800
tested and has a good test suite behind

00:11:03,459 --> 00:11:07,360
it and so going back what was testing

00:11:05,800 --> 00:11:08,769
for power eight so

00:11:07,360 --> 00:11:10,779
is different as I mentioned because

00:11:08,769 --> 00:11:12,010
partners are involved early on and you

00:11:10,779 --> 00:11:14,470
know the open power ecosystems a lot

00:11:12,010 --> 00:11:16,630
larger than it was way back at the start

00:11:14,470 --> 00:11:17,050
so what did we do for testing for power

00:11:16,630 --> 00:11:19,329
eight

00:11:17,050 --> 00:11:20,740
well parrot was much more started as

00:11:19,329 --> 00:11:22,450
sort of the monolithic development

00:11:20,740 --> 00:11:24,279
effort that you'd think of if it was you

00:11:22,450 --> 00:11:26,290
know IBM producing a power CPU for

00:11:24,279 --> 00:11:29,050
enterprise systems right so this is like

00:11:26,290 --> 00:11:30,490
a water flow of developed test ship and

00:11:29,050 --> 00:11:33,279
you sort of loop around in the flow of

00:11:30,490 --> 00:11:36,040
development and test using you know

00:11:33,279 --> 00:11:37,839
large test teams of people with anything

00:11:36,040 --> 00:11:39,700
that was automated you know have it a

00:11:37,839 --> 00:11:41,829
lot more tied into very specific

00:11:39,700 --> 00:11:45,940
internal IBM environments and not really

00:11:41,829 --> 00:11:47,440
something you could ship so I found a

00:11:45,940 --> 00:11:48,790
number of problems with this as how it

00:11:47,440 --> 00:11:50,170
would be for an open source project and

00:11:48,790 --> 00:11:51,490
especially how it would be for something

00:11:50,170 --> 00:11:53,620
where we're delivering it delivering it

00:11:51,490 --> 00:11:55,930
to others we're having people involved

00:11:53,620 --> 00:11:57,490
in systems design and bring up really

00:11:55,930 --> 00:11:59,140
early on we want to get them something

00:11:57,490 --> 00:12:00,940
that is here run this that's a test

00:11:59,140 --> 00:12:02,920
suite you know not only here is your

00:12:00,940 --> 00:12:04,180
code but also here as a test suite so I

00:12:02,920 --> 00:12:05,920
mapped out the firmware development

00:12:04,180 --> 00:12:07,600
process to try and go how does this all

00:12:05,920 --> 00:12:09,490
work and fit together and here's a

00:12:07,600 --> 00:12:12,610
simplified view of open power firmware

00:12:09,490 --> 00:12:13,959
development and have fits together this

00:12:12,610 --> 00:12:15,459
is so simple that there's a little

00:12:13,959 --> 00:12:18,190
yellow box that just says Linux

00:12:15,459 --> 00:12:20,260
magically comes from this place the blue

00:12:18,190 --> 00:12:22,149
bits are all our power specific bits

00:12:20,260 --> 00:12:23,529
yellow is reused from open source stuff

00:12:22,149 --> 00:12:25,690
and down the bottom and the little pink

00:12:23,529 --> 00:12:27,490
circles is the firmware releases that

00:12:25,690 --> 00:12:29,470
someone would download off your

00:12:27,490 --> 00:12:31,660
manufacturers website to install on your

00:12:29,470 --> 00:12:33,790
system right so we have a whole bunch of

00:12:31,660 --> 00:12:37,230
different firmware development processes

00:12:33,790 --> 00:12:40,120
and components coming together that form

00:12:37,230 --> 00:12:44,860
one firmware image from a whole bunch of

00:12:40,120 --> 00:12:46,240
little components and the bugs can

00:12:44,860 --> 00:12:47,680
literally be anywhere in the stack and

00:12:46,240 --> 00:12:49,089
flow down right just because you see

00:12:47,680 --> 00:12:50,860
something visible from an OS down the

00:12:49,089 --> 00:12:52,810
bottom it could be way back and you know

00:12:50,860 --> 00:12:55,120
a component up here it could be a kernel

00:12:52,810 --> 00:12:57,040
bug over there anywhere about fit so

00:12:55,120 --> 00:12:59,709
what existing test that we have so we

00:12:57,040 --> 00:13:02,290
have HDX which is a hardware exerciser

00:12:59,709 --> 00:13:04,000
and its job is to basically find bugs in

00:13:02,290 --> 00:13:05,829
really low-level firmware which we call

00:13:04,000 --> 00:13:08,050
like scan in it so setting up of the

00:13:05,829 --> 00:13:10,390
chip as well as the hardware itself as

00:13:08,050 --> 00:13:12,250
well as some problems with like putting

00:13:10,390 --> 00:13:13,750
machines under load so it's a it's a

00:13:12,250 --> 00:13:16,750
hardware exerciser that's specifically

00:13:13,750 --> 00:13:18,279
targeted for certain use cases we have

00:13:16,750 --> 00:13:19,600
unit tests for firmware so a bunch of

00:13:18,279 --> 00:13:21,340
our firmware stack does of course do

00:13:19,600 --> 00:13:22,960
unit test some part of it

00:13:21,340 --> 00:13:24,550
we have the Linux kernel it we ship in

00:13:22,960 --> 00:13:26,830
there of course has some self tests in

00:13:24,550 --> 00:13:28,720
there and we have KVM tests to test that

00:13:26,830 --> 00:13:30,370
actually test a lot of the hardware as

00:13:28,720 --> 00:13:32,380
well and so we had a lot of sort of

00:13:30,370 --> 00:13:33,670
incidental firmware testing at this

00:13:32,380 --> 00:13:35,080
stage you may see there it's like okay

00:13:33,670 --> 00:13:36,490
we're testing the hardware we're testing

00:13:35,080 --> 00:13:38,470
you know Linux itself but are we

00:13:36,490 --> 00:13:39,910
explicitly testing a bunch of the

00:13:38,470 --> 00:13:41,830
firmware functionality and narrowing it

00:13:39,910 --> 00:13:43,210
down and I found that we didn't really

00:13:41,830 --> 00:13:45,130
have something that brought this nicely

00:13:43,210 --> 00:13:46,870
together we had things like you know

00:13:45,130 --> 00:13:48,370
Travis sea ice this is like our Travis

00:13:46,870 --> 00:13:50,230
CI for a ski boot which is one of the

00:13:48,370 --> 00:13:51,670
firmware components there's builds and

00:13:50,230 --> 00:13:53,200
tests on a whole bunch of different

00:13:51,670 --> 00:13:55,330
distro so we can say yeah we've got a

00:13:53,200 --> 00:13:57,010
wide variety of compatibility between

00:13:55,330 --> 00:13:58,960
GCC versions we run a bunch of

00:13:57,010 --> 00:14:02,380
simulators in here and all kinds of nice

00:13:58,960 --> 00:14:04,210
jazz we get code coverage testing this

00:14:02,380 --> 00:14:05,440
is something I was a been repeatedly

00:14:04,210 --> 00:14:07,450
returning to hack on and have just

00:14:05,440 --> 00:14:09,330
improved a whole bunch recently so we

00:14:07,450 --> 00:14:12,580
can run our firmware a test suite which

00:14:09,330 --> 00:14:14,410
the big reveal will come later but we

00:14:12,580 --> 00:14:15,940
can run our firmware a boot and runtime

00:14:14,410 --> 00:14:17,950
testing as well as a unit test and get

00:14:15,940 --> 00:14:19,420
code coverage reportage out it's not

00:14:17,950 --> 00:14:21,010
only do you have an open source firmware

00:14:19,420 --> 00:14:22,660
stack and we'll have an open source

00:14:21,010 --> 00:14:23,920
Tesla but you can then go and look at

00:14:22,660 --> 00:14:26,200
the code coverage of running this

00:14:23,920 --> 00:14:27,910
against actual hardware and work out are

00:14:26,200 --> 00:14:29,410
we actually testing all the things we

00:14:27,910 --> 00:14:31,330
want to test and we're thinking we're

00:14:29,410 --> 00:14:33,220
testing and have good targets of where

00:14:31,330 --> 00:14:35,380
to add extra functionality interestingly

00:14:33,220 --> 00:14:37,900
enough there's a bunch of yeah really

00:14:35,380 --> 00:14:39,790
rare or never hit error conditions that

00:14:37,900 --> 00:14:41,530
are hard to test right specific crashed

00:14:39,790 --> 00:14:43,720
memory corruption stuff so we're never

00:14:41,530 --> 00:14:45,130
gonna get to 100% code coverage but it's

00:14:43,720 --> 00:14:46,870
very interesting to go back and dive

00:14:45,130 --> 00:14:48,940
into the details and go are we actually

00:14:46,870 --> 00:14:51,310
testing the large chunks that we want to

00:14:48,940 --> 00:14:52,240
and as a firmware maintainer I want to

00:14:51,310 --> 00:14:54,550
answer the question of will I regret

00:14:52,240 --> 00:14:56,410
merging this patch right we want to

00:14:54,550 --> 00:14:58,960
improve things not ever regress

00:14:56,410 --> 00:15:00,970
functionality or performance so my big

00:14:58,960 --> 00:15:02,590
question is should we merge this code

00:15:00,970 --> 00:15:03,730
now as an is it high enough quality that

00:15:02,590 --> 00:15:05,380
it won't break other people doing

00:15:03,730 --> 00:15:06,910
development work because when we're

00:15:05,380 --> 00:15:08,710
doing systems bring up you know we have

00:15:06,910 --> 00:15:10,240
distro teams using it for destroy

00:15:08,710 --> 00:15:12,280
development we've got red hat using it

00:15:10,240 --> 00:15:13,900
for Red Hat development right we've got

00:15:12,280 --> 00:15:16,300
people doing it for uh you know

00:15:13,900 --> 00:15:17,560
performance work trying to get a whole

00:15:16,300 --> 00:15:19,510
bunch of performance characteristics and

00:15:17,560 --> 00:15:21,010
optimization going on as well so it's

00:15:19,510 --> 00:15:22,330
all pretty interesting and we don't want

00:15:21,010 --> 00:15:24,790
to break other teams we want people to

00:15:22,330 --> 00:15:26,770
run latest firmware possible so we find

00:15:24,790 --> 00:15:28,960
out what's going on the whole idea of

00:15:26,770 --> 00:15:30,220
catch bugs early and often and we

00:15:28,960 --> 00:15:31,450
definitely want to do that in firmware

00:15:30,220 --> 00:15:33,100
we want to make sure that we've caught

00:15:31,450 --> 00:15:34,160
the bugs as early as possible so we can

00:15:33,100 --> 00:15:36,230
fix them as close to file

00:15:34,160 --> 00:15:40,430
preferably never merged anything with a

00:15:36,230 --> 00:15:42,170
bug there's a lot of people have been

00:15:40,430 --> 00:15:43,790
thinking like this and as I mentioned

00:15:42,170 --> 00:15:46,160
before we had partly automated testing

00:15:43,790 --> 00:15:48,139
out there inside IBM but very much

00:15:46,160 --> 00:15:51,439
geared to an inside IBM environment and

00:15:48,139 --> 00:15:53,240
we didn't we didn't have sort of really

00:15:51,439 --> 00:15:55,399
the ability to export you know internal

00:15:53,240 --> 00:15:56,810
IBM machine that has go everyone just

00:15:55,399 --> 00:15:58,399
log on to this specific machine in

00:15:56,810 --> 00:16:00,259
Austin with everything set up just right

00:15:58,399 --> 00:16:01,759
and run it against a machine that's not

00:16:00,259 --> 00:16:04,579
gonna scale for something like open

00:16:01,759 --> 00:16:06,019
power there were test frameworks plural

00:16:04,579 --> 00:16:07,790
right people who've gone in written a

00:16:06,019 --> 00:16:09,139
test and started I'll generalize it and

00:16:07,790 --> 00:16:11,360
convert it into a framework for writing

00:16:09,139 --> 00:16:12,980
other tests the problem is four or five

00:16:11,360 --> 00:16:15,350
people had done that and there hadn't

00:16:12,980 --> 00:16:17,410
been sort of a real overarching thing

00:16:15,350 --> 00:16:20,629
internally for that so we had the whole

00:16:17,410 --> 00:16:23,899
X 97 problem as a friend gleefully puts

00:16:20,629 --> 00:16:25,790
it which is the xkcd 97 comic which is

00:16:23,899 --> 00:16:27,500
you know there are 14 competing

00:16:25,790 --> 00:16:29,420
standards I know I'll create something

00:16:27,500 --> 00:16:31,129
that unifies them all now there are 15

00:16:29,420 --> 00:16:32,720
competing standards so we didn't want

00:16:31,129 --> 00:16:34,490
that we didn't want to just have yet

00:16:32,720 --> 00:16:36,350
another testing framework and not bring

00:16:34,490 --> 00:16:39,079
anyone internally along because one

00:16:36,350 --> 00:16:41,000
thing of yeah that open power is a bunch

00:16:39,079 --> 00:16:42,620
of you know IBM culture needs to change

00:16:41,000 --> 00:16:43,490
and be thinking of as an open

00:16:42,620 --> 00:16:45,079
environment in a collaborative

00:16:43,490 --> 00:16:48,290
environment not just something that

00:16:45,079 --> 00:16:50,420
produces an enterprise machine so back

00:16:48,290 --> 00:16:52,970
in 2015

00:16:50,420 --> 00:16:54,589
Andrew Guster did the champion thing of

00:16:52,970 --> 00:16:56,689
grabbing a whole bunch of the internal

00:16:54,589 --> 00:16:58,939
code and getting it to a situation where

00:16:56,689 --> 00:17:00,800
you could run it you know on a computer

00:16:58,939 --> 00:17:02,930
outside IBM without the specific set up

00:17:00,800 --> 00:17:04,429
environment right without the custom

00:17:02,930 --> 00:17:06,770
file systems mattered all over the place

00:17:04,429 --> 00:17:08,510
and no yeah and if it shows exactly the

00:17:06,770 --> 00:17:09,740
right way so this is the initial test

00:17:08,510 --> 00:17:11,569
and so this was the thing that we're

00:17:09,740 --> 00:17:13,549
gonna start up as a base off and the

00:17:11,569 --> 00:17:14,270
whole goal is having testing for an open

00:17:13,549 --> 00:17:17,000
source project

00:17:14,270 --> 00:17:20,329
as an open power firmware should be an

00:17:17,000 --> 00:17:22,159
open source project because we have not

00:17:20,329 --> 00:17:24,319
only us discovering bugs as firmware

00:17:22,159 --> 00:17:26,179
developers and OS developers but we have

00:17:24,319 --> 00:17:27,679
partners doing it right you've got you

00:17:26,179 --> 00:17:29,659
know Rackspace don't bring up on their

00:17:27,679 --> 00:17:31,460
box and finding issues we've got you

00:17:29,659 --> 00:17:33,289
know Google bringing doing bring up on

00:17:31,460 --> 00:17:35,210
their issues and what is the best way to

00:17:33,289 --> 00:17:38,690
report a bug it is a here is an

00:17:35,210 --> 00:17:41,299
automated test that reproduces it in a

00:17:38,690 --> 00:17:43,159
wonderful way now the initial state of

00:17:41,299 --> 00:17:45,260
this this test suite from the rescued

00:17:43,159 --> 00:17:47,299
internal code was possibly not ideal I

00:17:45,260 --> 00:17:48,020
worked it out and there was a perl

00:17:47,299 --> 00:17:50,360
script of course

00:17:48,020 --> 00:17:51,800
the Millat pausing xml with grep which

00:17:50,360 --> 00:17:53,090
calls another perl script file system

00:17:51,800 --> 00:17:54,410
passing date of our environment

00:17:53,090 --> 00:17:56,210
variables 2 which caused another perl

00:17:54,410 --> 00:17:57,410
script to parse xml to work out what to

00:17:56,210 --> 00:17:59,030
pass to a shell script which then

00:17:57,410 --> 00:18:01,220
constructs a python script which the

00:17:59,030 --> 00:18:02,720
runs a test for example power on and

00:18:01,220 --> 00:18:04,640
this was there a whole bunch of like

00:18:02,720 --> 00:18:06,260
trying to grab things internally to get

00:18:04,640 --> 00:18:08,360
as much of test coverage as possible and

00:18:06,260 --> 00:18:09,470
have something that worked so we wanted

00:18:08,360 --> 00:18:10,400
something that was a bit closer to this

00:18:09,470 --> 00:18:12,230
if you're familiar with Python

00:18:10,400 --> 00:18:14,570
development it's like you just run a

00:18:12,230 --> 00:18:15,920
unit test method simply right we want to

00:18:14,570 --> 00:18:17,840
say you know if I've been working on one

00:18:15,920 --> 00:18:19,430
bug I want to reproduce that one bug and

00:18:17,840 --> 00:18:21,710
run it easily and have code that that's

00:18:19,430 --> 00:18:23,270
really simple to to reproduce it right

00:18:21,710 --> 00:18:25,100
you want to hand this to your hardware

00:18:23,270 --> 00:18:26,570
engineer who's job isn't you know

00:18:25,100 --> 00:18:28,340
writing Python code or writing firmware

00:18:26,570 --> 00:18:29,540
code it is to find out what's going on

00:18:28,340 --> 00:18:32,420
the hardware and we want to say here's a

00:18:29,540 --> 00:18:34,280
nice nice reproducible test case and you

00:18:32,420 --> 00:18:35,810
can read it just because you know part

00:18:34,280 --> 00:18:37,610
that's pretty obvious we're all

00:18:35,810 --> 00:18:39,680
something like make a check for C code

00:18:37,610 --> 00:18:41,000
right and so from going from this

00:18:39,680 --> 00:18:42,740
initial code dump it was not just

00:18:41,000 --> 00:18:44,660
organizational change but also a bunch

00:18:42,740 --> 00:18:46,100
of engineering work right we had test

00:18:44,660 --> 00:18:47,570
teams who still had to deliver products

00:18:46,100 --> 00:18:49,460
and do a whole bunch of test cycles that

00:18:47,570 --> 00:18:51,200
had their bits of automation around

00:18:49,460 --> 00:18:53,450
these things as well so the you know

00:18:51,200 --> 00:18:55,250
running like htx and KVM tests and

00:18:53,450 --> 00:18:58,520
kernel self tests all these kind of

00:18:55,250 --> 00:19:01,940
disjointed things we had you know people

00:18:58,520 --> 00:19:03,950
working on the CI stuff we had some

00:19:01,940 --> 00:19:05,450
people working on this old testing on

00:19:03,950 --> 00:19:07,250
actually really ancient distro so a

00:19:05,450 --> 00:19:10,730
whole bunch of stuff like only runs on

00:19:07,250 --> 00:19:13,580
rl6 and of course i wanted to do

00:19:10,730 --> 00:19:15,140
something that was runnable by anyone so

00:19:13,580 --> 00:19:17,930
I have this theory about innovation

00:19:15,140 --> 00:19:18,980
tokens and spoon theory spoon theory is

00:19:17,930 --> 00:19:20,630
that you only have a certain number of

00:19:18,980 --> 00:19:22,280
spoons and everything you do in a day

00:19:20,630 --> 00:19:24,950
costs a spoon and at some point you've

00:19:22,280 --> 00:19:25,940
got no spoons left and innovation tokens

00:19:24,950 --> 00:19:28,010
I say is like you know when you're

00:19:25,940 --> 00:19:29,840
working on a giant engineering project

00:19:28,010 --> 00:19:31,580
for example you know shipping a power 9

00:19:29,840 --> 00:19:33,350
system you have certain number of

00:19:31,580 --> 00:19:34,820
innovation tokens you can spend and if

00:19:33,350 --> 00:19:37,160
you overspend your innovation tokens

00:19:34,820 --> 00:19:38,570
think things go severely wrong when you

00:19:37,160 --> 00:19:40,130
try and out innovate instead of just

00:19:38,570 --> 00:19:43,520
focusing on one or two solid areas

00:19:40,130 --> 00:19:45,680
didn't want to do huge amounts of random

00:19:43,520 --> 00:19:47,240
innovation going on here I wanted to do

00:19:45,680 --> 00:19:49,850
something that was really well known

00:19:47,240 --> 00:19:51,740
technology really easy to run anyone

00:19:49,850 --> 00:19:53,390
could use you know it wasn't what you

00:19:51,740 --> 00:19:55,400
need is like the latest version of this

00:19:53,390 --> 00:19:57,230
language compiler to then compile custom

00:19:55,400 --> 00:19:59,210
things and do that no we didn't want any

00:19:57,230 --> 00:20:01,310
of that so we did a really really really

00:19:59,210 --> 00:20:01,639
simple stuff it's just a bunch of Python

00:20:01,310 --> 00:20:03,129
to

00:20:01,639 --> 00:20:05,209
seven because that's like everywhere

00:20:03,129 --> 00:20:07,219
Python three is wonderful but not

00:20:05,209 --> 00:20:09,289
everywhere yet I pee my two let's do as

00:20:07,219 --> 00:20:10,789
much over using the binary I've whom I

00:20:09,289 --> 00:20:12,499
told everyone is gonna use to interact

00:20:10,789 --> 00:20:13,940
with these machines even though it

00:20:12,499 --> 00:20:16,279
arguably been more efficient to have a

00:20:13,940 --> 00:20:18,589
pure Python I view my implementation no

00:20:16,279 --> 00:20:20,299
let's use the actual binary on the

00:20:18,589 --> 00:20:22,579
system's being tested that she's a bunch

00:20:20,299 --> 00:20:25,729
of standard destroy tools let's poke

00:20:22,579 --> 00:20:27,259
using a normal FW TS which is from

00:20:25,729 --> 00:20:29,809
canonical they use for firmware tests we

00:20:27,259 --> 00:20:31,820
use the you know PCI utils and I squared

00:20:29,809 --> 00:20:34,070
C utils and standard sensor utils and

00:20:31,820 --> 00:20:36,349
have this vision of the tests are

00:20:34,070 --> 00:20:38,539
deliverable still we deliver it not only

00:20:36,349 --> 00:20:39,799
is you know here a version 2.0 of open

00:20:38,539 --> 00:20:42,190
power firmware that supports power nine

00:20:39,799 --> 00:20:44,749
we want to say at the same time here is

00:20:42,190 --> 00:20:46,070
opie test version one dot R and this is

00:20:44,749 --> 00:20:48,200
the test suite that goes along with it

00:20:46,070 --> 00:20:49,309
so you have a release which is the CPU

00:20:48,200 --> 00:20:50,989
you have a release which is the phone

00:20:49,309 --> 00:20:52,369
waveform and you have a release which is

00:20:50,989 --> 00:20:54,709
the test suite and then we could use

00:20:52,369 --> 00:20:56,299
that as a deliverable to also going to

00:20:54,709 --> 00:20:58,429
open power foundation have here's a

00:20:56,299 --> 00:20:59,869
specification for firmware and a test

00:20:58,429 --> 00:21:02,029
suite to go with it and codify that

00:20:59,869 --> 00:21:04,429
through code right that's the that's the

00:21:02,029 --> 00:21:06,919
vision and the strategy that we pursued

00:21:04,429 --> 00:21:09,109
for this is to slowly boil the frog so I

00:21:06,919 --> 00:21:11,149
so none of the people who end up working

00:21:09,109 --> 00:21:13,369
on this realize that have just co-opted

00:21:11,149 --> 00:21:16,129
them to delivering an open source

00:21:13,369 --> 00:21:18,289
firmware test suite and that was the

00:21:16,129 --> 00:21:19,999
idea being to very incrementally add

00:21:18,289 --> 00:21:21,619
things to the test wait stop getting

00:21:19,999 --> 00:21:24,919
people to run it make it be the obvious

00:21:21,619 --> 00:21:27,169
choice to do things and then we totally

00:21:24,919 --> 00:21:30,769
just have this sudden open power open

00:21:27,169 --> 00:21:33,440
source open firmware test suite so short

00:21:30,769 --> 00:21:35,359
term wins add tests and run them so we

00:21:33,440 --> 00:21:36,559
had myself and others starting to add

00:21:35,359 --> 00:21:39,109
little tests for things that we found

00:21:36,559 --> 00:21:40,879
along the way and we started to run them

00:21:39,109 --> 00:21:42,829
and see when things would break or

00:21:40,879 --> 00:21:44,509
regress and sort of indeed when someone

00:21:42,829 --> 00:21:46,159
reported by we just try and write small

00:21:44,509 --> 00:21:47,690
tests so a bunch of an early engineering

00:21:46,159 --> 00:21:49,940
work was just to set up some basic

00:21:47,690 --> 00:21:51,739
framework around it so what do we test

00:21:49,940 --> 00:21:53,899
you know on off

00:21:51,739 --> 00:21:55,219
do we still boot in OS you know if I run

00:21:53,899 --> 00:21:57,049
various commands do we get the various

00:21:55,219 --> 00:21:58,070
output like LS PCI do you get the same

00:21:57,049 --> 00:22:00,469
output each boot

00:21:58,070 --> 00:22:02,089
do we detect the same PCI devices each

00:22:00,469 --> 00:22:04,219
boot that kind of stuff could checks

00:22:02,089 --> 00:22:06,440
basic functionality change CPU frequency

00:22:04,219 --> 00:22:07,909
intentionally check and actually measure

00:22:06,440 --> 00:22:10,190
that we're running the right frequency

00:22:07,909 --> 00:22:12,979
all that basic functionality and then

00:22:10,190 --> 00:22:15,210
add on extended functionality but do

00:22:12,979 --> 00:22:17,220
each things in a nice little module

00:22:15,210 --> 00:22:18,899
starting off from that sort of rickety

00:22:17,220 --> 00:22:20,789
spaghetti code going off one major

00:22:18,899 --> 00:22:22,440
refactor later we had something that

00:22:20,789 --> 00:22:24,120
completely looks like Python unit tests

00:22:22,440 --> 00:22:26,490
except they're not unit tests they test

00:22:24,120 --> 00:22:28,350
the machine so it's sort of abusing the

00:22:26,490 --> 00:22:29,460
Python unit test framework but it does

00:22:28,350 --> 00:22:31,799
end up looking like really familiar

00:22:29,460 --> 00:22:33,960
Python code a whole bunch of other stuff

00:22:31,799 --> 00:22:36,570
let us take certain tests our time runs

00:22:33,960 --> 00:22:38,789
from 12 hours to 20 minutes which was a

00:22:36,570 --> 00:22:41,610
nice thing when I did that refactor and

00:22:38,789 --> 00:22:42,690
showed our one of our test teams they're

00:22:41,610 --> 00:22:44,490
like well that's really useful we can

00:22:42,690 --> 00:22:45,750
run a lot more tests now and so we can

00:22:44,490 --> 00:22:46,830
break a lot more things I'm like yup

00:22:45,750 --> 00:22:48,720
that's the goal

00:22:46,830 --> 00:22:51,299
and they've proceeded to file a lot of

00:22:48,720 --> 00:22:52,919
bugs afterwards and also when we're in

00:22:51,299 --> 00:22:54,270
limited hardware like we're doing you

00:22:52,919 --> 00:22:55,529
know early bring up in p9 you'd get a

00:22:54,270 --> 00:22:57,210
lot of them out the gate right this

00:22:55,529 --> 00:22:58,950
isn't yet mass production you know

00:22:57,210 --> 00:23:00,539
manufacturing still sorting out how to

00:22:58,950 --> 00:23:02,520
make the thing so you get a limited

00:23:00,539 --> 00:23:04,500
amount of chips and you will be grateful

00:23:02,520 --> 00:23:05,909
for that thank you very much so

00:23:04,500 --> 00:23:07,740
unlimited hardware running things as

00:23:05,909 --> 00:23:09,480
quick as possible is perfect so we do

00:23:07,740 --> 00:23:10,890
some wonderful state machines internally

00:23:09,480 --> 00:23:12,690
to track the state of the computer and

00:23:10,890 --> 00:23:14,399
try and quickly detect when it's crashed

00:23:12,690 --> 00:23:17,360
and reboot it and continue running tests

00:23:14,399 --> 00:23:19,559
and all that kind of kind of jazz the

00:23:17,360 --> 00:23:21,840
desired workflow which is literally what

00:23:19,559 --> 00:23:24,480
it is is you clone the repository from

00:23:21,840 --> 00:23:25,830
github into the directory run it and

00:23:24,480 --> 00:23:29,490
point it to the firmware you want tested

00:23:25,830 --> 00:23:32,789
so this is what I run dozens of times

00:23:29,490 --> 00:23:35,100
per day now which is please log on to

00:23:32,789 --> 00:23:37,500
that host flash that firmware on it that

00:23:35,100 --> 00:23:39,240
BMC firmware and run my test suite

00:23:37,500 --> 00:23:40,649
so I have a script that will very

00:23:39,240 --> 00:23:43,710
quickly turn your computer into

00:23:40,649 --> 00:23:45,299
completely my computer and so I'm one

00:23:43,710 --> 00:23:46,980
typos a way of making someone else's

00:23:45,299 --> 00:23:47,789
Dave really miserable or run none of

00:23:46,980 --> 00:23:51,270
their code anymore

00:23:47,789 --> 00:23:53,250
my BNC code my host firmware code my OS

00:23:51,270 --> 00:23:56,220
with all my stuff there it's remarkably

00:23:53,250 --> 00:23:58,169
efficient a little bit scared but we've

00:23:56,220 --> 00:24:00,419
got it to that stage where basically

00:23:58,169 --> 00:24:01,919
every opal finger developer now uses

00:24:00,419 --> 00:24:03,210
this just to flash the code even they're

00:24:01,919 --> 00:24:04,710
doing something else because just

00:24:03,210 --> 00:24:06,120
simpler and it works quicker it knows

00:24:04,710 --> 00:24:07,799
all of the intricacies of the different

00:24:06,120 --> 00:24:09,179
machines and the you know the

00:24:07,799 --> 00:24:11,610
workarounds for various firmware

00:24:09,179 --> 00:24:12,630
versions to flash it it's fantastic and

00:24:11,610 --> 00:24:13,860
we have a lot of machines to test

00:24:12,630 --> 00:24:15,390
against we wanted to run against power

00:24:13,860 --> 00:24:16,950
eight machines as well we only run

00:24:15,390 --> 00:24:19,289
against all the p9 ones and we wanted to

00:24:16,950 --> 00:24:20,940
run on simulators so that we come and do

00:24:19,289 --> 00:24:22,860
the next chip we can start running all

00:24:20,940 --> 00:24:25,020
of these tests as early in simulation as

00:24:22,860 --> 00:24:26,610
possible and indeed debug things in

00:24:25,020 --> 00:24:28,139
simulators because sometimes debugging

00:24:26,610 --> 00:24:28,890
thing in a simulator is a lot easier

00:24:28,139 --> 00:24:31,110
than doing

00:24:28,890 --> 00:24:32,160
hardware so that would be really neat so

00:24:31,110 --> 00:24:34,740
what a test look like let's show you

00:24:32,160 --> 00:24:37,380
some code so as I said it looks

00:24:34,740 --> 00:24:40,410
remarkably like a Python unit test and

00:24:37,380 --> 00:24:42,360
this test is a very simple one it says

00:24:40,410 --> 00:24:44,460
make sure the machine is off as in go to

00:24:42,360 --> 00:24:46,140
state off and then it says boot to the

00:24:44,460 --> 00:24:47,850
petty boot shell so petty boot you can

00:24:46,140 --> 00:24:49,890
exit to a shell that's a good way to

00:24:47,850 --> 00:24:52,610
stop automatic boot and if this fails

00:24:49,890 --> 00:24:55,560
it'll fail the test this will simply do

00:24:52,610 --> 00:24:56,460
do you boot and if you boot of course

00:24:55,560 --> 00:24:57,900
you ship the Machine because that's

00:24:56,460 --> 00:25:00,360
obviously all you need to do but that's

00:24:57,900 --> 00:25:03,480
the start of the test the next test here

00:25:00,360 --> 00:25:06,540
is pretty interesting because this one

00:25:03,480 --> 00:25:09,330
believe it or not is if you can boot a

00:25:06,540 --> 00:25:10,800
thousand and twenty four times so it

00:25:09,330 --> 00:25:13,380
will just turn the Machine off turn it

00:25:10,800 --> 00:25:15,510
on see that you put check if you get any

00:25:13,380 --> 00:25:17,820
errors in the kernel or firmware logs

00:25:15,510 --> 00:25:19,560
and then boot the whole thing again and

00:25:17,820 --> 00:25:21,750
when it gets to 1,024 times it says your

00:25:19,560 --> 00:25:23,820
test is complete typically we don't run

00:25:21,750 --> 00:25:25,230
to a thousand 24 because if boot takes

00:25:23,820 --> 00:25:26,910
five to ten minutes you can work out how

00:25:25,230 --> 00:25:28,530
long that takes but even just getting to

00:25:26,910 --> 00:25:29,880
ten or a hundred is a pretty good thing

00:25:28,530 --> 00:25:31,710
if that consistently works especially

00:25:29,880 --> 00:25:34,050
during the bring up so that's pretty

00:25:31,710 --> 00:25:35,850
interesting we also have one a new

00:25:34,050 --> 00:25:37,800
function called fast reboot which takes

00:25:35,850 --> 00:25:39,690
reboot time for about five to ten

00:25:37,800 --> 00:25:42,540
minutes to around twenty four seconds

00:25:39,690 --> 00:25:44,250
and that you can do so we've had a power

00:25:42,540 --> 00:25:47,280
nine system reboot a thousand twenty

00:25:44,250 --> 00:25:49,500
four times in a row in actually not much

00:25:47,280 --> 00:25:51,390
time so it will reboot fast to the next

00:25:49,500 --> 00:25:52,740
eight six desktop systems like using

00:25:51,390 --> 00:25:54,420
fast reboot so we're trying to make sure

00:25:52,740 --> 00:25:56,220
that's also really stable and we can

00:25:54,420 --> 00:25:57,780
ship it as well so that's exciting stuff

00:25:56,220 --> 00:25:59,790
but this is the kind of test that looks

00:25:57,780 --> 00:26:02,970
like you can see is normal code and

00:25:59,790 --> 00:26:04,530
anyone who's like a user of a power

00:26:02,970 --> 00:26:05,940
system could probably write this if they

00:26:04,530 --> 00:26:08,220
found a problem and wanted to work out

00:26:05,940 --> 00:26:11,430
what is this and hand it to us to help

00:26:08,220 --> 00:26:13,110
debug stuff this checks that we didn't

00:26:11,430 --> 00:26:15,810
do something silly like enable an SSH

00:26:13,110 --> 00:26:17,730
server in paddy boot turns help we miss

00:26:15,810 --> 00:26:19,590
that once in early development and it's

00:26:17,730 --> 00:26:20,910
like whoops pretty weak shouldn't be

00:26:19,590 --> 00:26:23,340
running an SSH server you shouldn't go

00:26:20,910 --> 00:26:26,850
to SSH into your bootloader so this

00:26:23,340 --> 00:26:28,950
takes checks it by just running ps4 drop

00:26:26,850 --> 00:26:30,420
there on the Betty Boop shell it's kind

00:26:28,950 --> 00:26:32,520
of nice

00:26:30,420 --> 00:26:34,740
this test is one to do CPU frequency

00:26:32,520 --> 00:26:36,870
scaling testing so basically what we do

00:26:34,740 --> 00:26:39,240
is we boot the machine check what CPU

00:26:36,870 --> 00:26:41,730
frequencies are enabled then for each of

00:26:39,240 --> 00:26:42,840
them go and set them explicitly by

00:26:41,730 --> 00:26:44,700
disabling all the others

00:26:42,840 --> 00:26:47,240
and setting userspace to our governor

00:26:44,700 --> 00:26:50,790
and then we want to check that we

00:26:47,240 --> 00:26:53,190
actually verify it so we run PPC 64 CPU

00:26:50,790 --> 00:26:55,080
- - frequency we want to test that what

00:26:53,190 --> 00:26:56,910
we've actually running at because it

00:26:55,080 --> 00:26:59,310
measures based on counting clock cycles

00:26:56,910 --> 00:27:00,990
is roughly equivalent to the CPU

00:26:59,310 --> 00:27:02,670
frequency we set it to within a margin

00:27:00,990 --> 00:27:04,050
of error so this does that and we

00:27:02,670 --> 00:27:05,880
actually catch bugs with this where it's

00:27:04,050 --> 00:27:06,900
like if you set a CPU frequency it

00:27:05,880 --> 00:27:08,970
should be within that between this

00:27:06,900 --> 00:27:09,990
amount of time so when we measure it it

00:27:08,970 --> 00:27:11,550
should definitely be running at that

00:27:09,990 --> 00:27:13,470
frequency and if not there is a bug

00:27:11,550 --> 00:27:14,730
somewhere and this is actually even

00:27:13,470 --> 00:27:16,920
currently actually there's a bug that

00:27:14,730 --> 00:27:18,660
this test found which is great we also

00:27:16,920 --> 00:27:20,880
have the idea of creating torture tests

00:27:18,660 --> 00:27:23,520
which is don't just be nice to firmware

00:27:20,880 --> 00:27:25,650
a by doing one thing at a time do a lot

00:27:23,520 --> 00:27:27,780
of things at once and just see when it

00:27:25,650 --> 00:27:29,370
explodes and in the middle of all this

00:27:27,780 --> 00:27:31,230
work to start getting this going we

00:27:29,370 --> 00:27:33,030
actually had a bug report on one of the

00:27:31,230 --> 00:27:34,890
enterprise systems that initially looked

00:27:33,030 --> 00:27:36,540
like a host firmware bug it turned out

00:27:34,890 --> 00:27:39,540
not to be turned out to be a bug in the

00:27:36,540 --> 00:27:41,790
IPMI implementation on IBM's proprietary

00:27:39,540 --> 00:27:43,380
FSP stuff but the way we actually found

00:27:41,790 --> 00:27:46,020
this and handed it to the appropriate

00:27:43,380 --> 00:27:48,870
team was one of our test developers

00:27:46,020 --> 00:27:50,910
wrote sort of this is a cut off version

00:27:48,870 --> 00:27:53,670
of it but it's a multi-threaded test

00:27:50,910 --> 00:27:56,100
that starts a whole bunch of harmless

00:27:53,670 --> 00:27:58,530
IPMI commands from about ten different

00:27:56,100 --> 00:28:00,390
threads running them in a loop against

00:27:58,530 --> 00:28:02,100
the one machine at the same time as

00:28:00,390 --> 00:28:04,050
spewing a whole bunch of data out the

00:28:02,100 --> 00:28:06,420
console on the host right

00:28:04,050 --> 00:28:08,610
and then after that about 10 minutes

00:28:06,420 --> 00:28:11,070
later or 20 minutes later everything

00:28:08,610 --> 00:28:13,050
goes very very poorly and you can't talk

00:28:11,070 --> 00:28:14,490
to the service processor anymore and so

00:28:13,050 --> 00:28:16,110
we handed that to that engineering team

00:28:14,490 --> 00:28:17,580
and that was that was what they needed

00:28:16,110 --> 00:28:19,170
because they could actually then you

00:28:17,580 --> 00:28:21,150
know put on a debug version of the the

00:28:19,170 --> 00:28:22,740
code on the if it's pay fine where it

00:28:21,150 --> 00:28:24,450
was crashing and fix the bug so we

00:28:22,740 --> 00:28:25,740
actually be more sophisticated tests now

00:28:24,450 --> 00:28:27,450
we're looking at bringing this they're

00:28:25,740 --> 00:28:30,000
actually using this now as to also test

00:28:27,450 --> 00:28:31,410
the open BMC IPMI implementation that's

00:28:30,000 --> 00:28:33,870
being brought up so it's pretty cool

00:28:31,410 --> 00:28:35,310
we're seeing a lot of value here on that

00:28:33,870 --> 00:28:36,810
one we're gonna use it for for open

00:28:35,310 --> 00:28:39,180
power stuff as well so we want to have

00:28:36,810 --> 00:28:41,640
the power if ganna do like full Python

00:28:39,180 --> 00:28:43,620
stuff - got to do like powerful tests

00:28:41,640 --> 00:28:45,900
where it's not just run command check

00:28:43,620 --> 00:28:47,220
result but 100 commands at once and

00:28:45,900 --> 00:28:49,170
check that things don't explode and have

00:28:47,220 --> 00:28:50,580
a way to bisect that down to simpler

00:28:49,170 --> 00:28:55,380
things and have variables in there so

00:28:50,580 --> 00:28:56,820
it's kind of cool close by BMC familiar

00:28:55,380 --> 00:28:58,470
with some BMC implementation

00:28:56,820 --> 00:29:00,389
you will cry every time you see this but

00:28:58,470 --> 00:29:02,070
basically we get to work around a whole

00:29:00,389 --> 00:29:04,590
bunch of BMC bugs especially during

00:29:02,070 --> 00:29:06,179
bring up an early BMC code so we have a

00:29:04,590 --> 00:29:09,630
bunch of code in our test suite to work

00:29:06,179 --> 00:29:11,070
around and this is if you ever have to

00:29:09,630 --> 00:29:12,570
understand what this code does something

00:29:11,070 --> 00:29:16,049
has gone terribly wrong in your life and

00:29:12,570 --> 00:29:18,389
I'll be there drinking with you but we

00:29:16,049 --> 00:29:19,590
work around a bunch of BMC bugs so that

00:29:18,389 --> 00:29:20,880
we can continue with our host firmware

00:29:19,590 --> 00:29:22,559
testing and we do this in a bunch of

00:29:20,880 --> 00:29:24,450
places and then we can also give it to

00:29:22,559 --> 00:29:26,159
the BMC development folk and go here's

00:29:24,450 --> 00:29:28,440
your bug you might want to fix it and

00:29:26,159 --> 00:29:30,419
the good news is that with open BMC

00:29:28,440 --> 00:29:32,820
that's a much more realistic prospect we

00:29:30,419 --> 00:29:36,120
can go and fix things there is a great

00:29:32,820 --> 00:29:38,039
bug that we have which is a 20 megabits

00:29:36,120 --> 00:29:39,960
serial port versus the Linux TTY layer

00:29:38,039 --> 00:29:41,309
it turns out that the Linux TTY layer

00:29:39,960 --> 00:29:43,919
was never built to deal with the 20

00:29:41,309 --> 00:29:46,409
megabits serial for it and with we use a

00:29:43,919 --> 00:29:49,860
vu art so a virtual serial port on p9

00:29:46,409 --> 00:29:51,779
systems and that can run at about 20

00:29:49,860 --> 00:29:53,279
megabit and it turns out that we

00:29:51,779 --> 00:29:55,259
definitely hit some old kernel bugs that

00:29:53,279 --> 00:29:58,019
have been there since I know some time

00:29:55,259 --> 00:29:59,159
in the early 90s but that's been kind of

00:29:58,019 --> 00:30:01,350
fun as well

00:29:59,159 --> 00:30:03,840
so we can literally do that I've handed

00:30:01,350 --> 00:30:06,000
that to the BMC developers test coverage

00:30:03,840 --> 00:30:07,799
looking pretty good current state of

00:30:06,000 --> 00:30:09,809
adoption is also pretty good because

00:30:07,799 --> 00:30:11,879
like developer is he using it test teams

00:30:09,809 --> 00:30:13,769
are using it open BMC is using it

00:30:11,879 --> 00:30:16,200
talking to a whole bunch of open power

00:30:13,769 --> 00:30:17,909
partners who are like really excited and

00:30:16,200 --> 00:30:20,340
this will probably this will form the

00:30:17,909 --> 00:30:21,990
basis of sort of firmer certification

00:30:20,340 --> 00:30:22,980
stuff for a whole bunch of open power

00:30:21,990 --> 00:30:25,139
stuff so we're looking at doing that

00:30:22,980 --> 00:30:27,240
through the foundation through you know

00:30:25,139 --> 00:30:28,950
not only open power ready which is

00:30:27,240 --> 00:30:30,450
already mentioned in so we're getting

00:30:28,950 --> 00:30:32,009
that in advance but sort of an actual

00:30:30,450 --> 00:30:33,629
certification suite as well would be

00:30:32,009 --> 00:30:35,730
sort of the output of this test tool

00:30:33,629 --> 00:30:37,470
which will be what developers run which

00:30:35,730 --> 00:30:39,539
is the fantastic thing of like basically

00:30:37,470 --> 00:30:41,279
if I want something to work on

00:30:39,539 --> 00:30:42,659
production machines as a developer I put

00:30:41,279 --> 00:30:46,950
it in this and it's instantly part of

00:30:42,659 --> 00:30:49,830
certification suite so pretty easy to

00:30:46,950 --> 00:30:51,000
run there's documentation even but you

00:30:49,830 --> 00:30:52,620
know you can see that that's not a

00:30:51,000 --> 00:30:55,379
complex command to run it's just some

00:30:52,620 --> 00:30:56,610
stuff there it's up on github so you can

00:30:55,379 --> 00:30:58,019
write your own tests so you can run it

00:30:56,610 --> 00:31:00,059
in a simulator even if you don't have

00:30:58,019 --> 00:31:01,710
real power 9 hardware yet you can still

00:31:00,059 --> 00:31:02,970
write firmware tests which is

00:31:01,710 --> 00:31:04,320
fascinating I should really blog the

00:31:02,970 --> 00:31:07,260
intricacies of getting that set up but

00:31:04,320 --> 00:31:08,760
the write qmu branch and thank you

00:31:07,260 --> 00:31:11,480
there's any quick questions there I

00:31:08,760 --> 00:31:11,480

YouTube URL: https://www.youtube.com/watch?v=GHmx0JvZG1w


