Title: Base64 is not encryption A better story for Kubernetes Secrets
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Seth Vargo

At: FOSDEM 2019
https://video.fosdem.org/2019/UD2.218A/base64_not_encryption.webm


Secrets are a key pillar of Kubernetes' security model, used internally (e.g. service accounts) and by users (e.g. API keys), but did you know they are stored in plaintext? That's right, by default all Kubernetes secrets are base64 encoded and stored as plaintext in etcd. Anyone with access to the etcd cluster has access to all your Kubernetes secrets. 

Thankfully there are better ways. This lecture provides an overview of different techniques for more securely managing secrets in Kubernetes including secrets encryption, KMS plugins, and tools like HashiCorp Vault. Attendees will learn the tradeoffs of each approach to make better decisions on how to secure their Kubernetes clusters. This lecture and discussion outlines the current state of Kubernetes' security with respect to managing and securing Kubernetes Secrets. 

First, attendees will learn the current state of the world: a default Kubernetes cluster has secrets pretty widely exposed. We will talk briefly about how some cloud providers add additional layers of security, but the default is insecure. 

Next, attendees will learn about features released in Kubernetes 1.7 to allow for application-layer encryption of secrets. We will discuss the pros and cons of this approach, and walk through same code/live demo of it working in action. 

Next, attendees will learn about features released in Kubernetes 1.10 to allow for delegated application-layer encryption of secrets to a KMS provider. We will again discuss the pros and cons of this approach, show some code and live demos. 

Finally, attendees will see an example of a full secrets management on Kubernetes, using the open source HashiCorp Vault tool. 

Importantly, this talk is not a general security talk - it is specific to Kubernetes secrets. Specifically, there are no plans to discuss cluster-level security, firewall security, ACLs, or RBAC. 

Room: UD2.218A
Scheduled start: 2019-02-03 14:30:00+01
Captions: 
	00:00:09,740 --> 00:00:12,980
from where

00:00:28,560 --> 00:00:31,610
yep Oh

00:00:37,160 --> 00:00:44,270
so Paraiba

00:00:40,750 --> 00:00:47,750
the next talk is about best local best

00:00:44,270 --> 00:00:52,540
64 is not the encryption by this bar go

00:00:47,750 --> 00:00:52,540
will come hi everyone

00:00:55,630 --> 00:01:00,890
can everyone hear me I'm a little sick

00:00:58,040 --> 00:01:01,430
so awesome I see a thumbs up in the back

00:01:00,890 --> 00:01:04,489
of the room

00:01:01,430 --> 00:01:06,740
welcome to base64 is not encryption or a

00:01:04,489 --> 00:01:08,479
better story for kubernetes and secrets

00:01:06,740 --> 00:01:11,270
my name is Seth Fargo I'm a developer

00:01:08,479 --> 00:01:13,150
relations engineer at Google small

00:01:11,270 --> 00:01:16,490
company probably haven't heard of them

00:01:13,150 --> 00:01:17,690
and I only have 30 minutes so I'm kind

00:01:16,490 --> 00:01:19,100
of going to run through this quickly but

00:01:17,690 --> 00:01:20,509
if you have questions or if I say a word

00:01:19,100 --> 00:01:22,729
and you're not sure what it means please

00:01:20,509 --> 00:01:24,320
come up to me afterwards and ask me or

00:01:22,729 --> 00:01:26,509
feel free to tweet me that's my twitter

00:01:24,320 --> 00:01:28,040
handle my direct messages are also open

00:01:26,509 --> 00:01:29,540
so if you don't feel comfortable saying

00:01:28,040 --> 00:01:31,700
something publicly you can always send

00:01:29,540 --> 00:01:34,400
me a private message even if I don't

00:01:31,700 --> 00:01:36,820
follow you alright so let's set some

00:01:34,400 --> 00:01:38,330
ground rules here what is a secret

00:01:36,820 --> 00:01:39,830
everyone kind of has their own

00:01:38,330 --> 00:01:42,440
definition for the purpose of this talk

00:01:39,830 --> 00:01:45,350
I'm gonna define a secret as credentials

00:01:42,440 --> 00:01:47,539
configurations API keys or other stuff

00:01:45,350 --> 00:01:50,240
that an application or service needs to

00:01:47,539 --> 00:01:52,280
run either a build time or at runtime so

00:01:50,240 --> 00:01:54,170
when you compile the application or when

00:01:52,280 --> 00:01:55,850
it's running and we're specifically

00:01:54,170 --> 00:01:57,170
talking about secrets in the context of

00:01:55,850 --> 00:01:59,179
kubernetes right there have been a lot

00:01:57,170 --> 00:02:02,119
of other security talks we're really

00:01:59,179 --> 00:02:04,220
just narrowing in on kubernetes here and

00:02:02,119 --> 00:02:06,530
then we kind of have to ask ourselves a

00:02:04,220 --> 00:02:09,440
really obvious question why should we

00:02:06,530 --> 00:02:11,330
protect that like why not just use a

00:02:09,440 --> 00:02:13,550
config map for everything why do we even

00:02:11,330 --> 00:02:16,819
have secrets how do we separate secrets

00:02:13,550 --> 00:02:18,770
from configuration well first secrets

00:02:16,819 --> 00:02:22,010
are a really attractive target for

00:02:18,770 --> 00:02:25,760
attackers they often are leaked in

00:02:22,010 --> 00:02:27,560
public repositories or open buckets on

00:02:25,760 --> 00:02:29,660
s3 or Google Cloud storage

00:02:27,560 --> 00:02:31,819
and they often include overly broad

00:02:29,660 --> 00:02:32,900
permissions and they're often given to

00:02:31,819 --> 00:02:34,730
people who shouldn't have those

00:02:32,900 --> 00:02:36,650
permissions like the CEO of the company

00:02:34,730 --> 00:02:39,440
should not have pseudo access to all of

00:02:36,650 --> 00:02:41,390
the machines yet that's what happens and

00:02:39,440 --> 00:02:43,910
these users tend to leak these

00:02:41,390 --> 00:02:45,260
credentials everywhere so we need a

00:02:43,910 --> 00:02:49,490
really strong strategy for protecting

00:02:45,260 --> 00:02:50,660
secrets there are really four ways in

00:02:49,490 --> 00:02:53,000
which we can protect the

00:02:50,660 --> 00:02:55,430
we can audit them so this is kind of

00:02:53,000 --> 00:02:56,960
retroactive Lee let's log every use of a

00:02:55,430 --> 00:02:59,480
secret let's make sure that we can trace

00:02:56,960 --> 00:03:01,540
who's using a secret and when encryption

00:02:59,480 --> 00:03:03,890
encryption in transit and at rest

00:03:01,540 --> 00:03:05,390
rotation we know that it's not enough

00:03:03,890 --> 00:03:07,100
just to have a secret that secret also

00:03:05,390 --> 00:03:09,290
has to have a lifetime I can only live

00:03:07,100 --> 00:03:12,020
for you know a couple hours or a couple

00:03:09,290 --> 00:03:13,550
years and isolation right that's kind of

00:03:12,020 --> 00:03:14,960
principle at least privilege making sure

00:03:13,550 --> 00:03:16,310
that the the place where secrets are

00:03:14,960 --> 00:03:18,500
accessed is not the same place that

00:03:16,310 --> 00:03:20,690
they're stored this talk is really

00:03:18,500 --> 00:03:22,370
focusing on the encryption bit and

00:03:20,690 --> 00:03:24,260
that's really all we're gonna talk about

00:03:22,370 --> 00:03:25,700
today there are a lot of things that we

00:03:24,260 --> 00:03:29,050
can talk about but we're kind of limited

00:03:25,700 --> 00:03:33,800
by time so let's talk about encryption

00:03:29,050 --> 00:03:37,160
there are four layers of encryption that

00:03:33,800 --> 00:03:39,040
are kind of common the first is what we

00:03:37,160 --> 00:03:40,910
call application layer encryption

00:03:39,040 --> 00:03:42,110
application layer encryption I'll talk

00:03:40,910 --> 00:03:44,770
about in more detail in the next slide

00:03:42,110 --> 00:03:46,790
then we have service level encryption

00:03:44,770 --> 00:03:48,470
filesystem encryption and machine level

00:03:46,790 --> 00:03:49,760
encryption so machine level encryption

00:03:48,470 --> 00:03:50,710
is like where you have a hardware device

00:03:49,760 --> 00:03:52,640
like a TPU

00:03:50,710 --> 00:03:54,410
operating system encryption something

00:03:52,640 --> 00:03:56,930
like BitLocker or File Vault

00:03:54,410 --> 00:03:58,370
on Mac or Windows and then service level

00:03:56,930 --> 00:03:59,510
encryption is where you have some kind

00:03:58,370 --> 00:04:02,690
of like operating system level

00:03:59,510 --> 00:04:04,790
encryption application layer encryption

00:04:02,690 --> 00:04:06,500
is kind of the highest level of

00:04:04,790 --> 00:04:08,120
encryption that we have today because

00:04:06,500 --> 00:04:11,390
it's applied at the earliest possible

00:04:08,120 --> 00:04:12,800
step in the encryption process and it

00:04:11,390 --> 00:04:14,450
provides encryption at a very granular

00:04:12,800 --> 00:04:16,400
level so when you think about something

00:04:14,450 --> 00:04:18,590
like file vault on OSX or BitLocker on

00:04:16,400 --> 00:04:20,780
Windows that's a key that protects an

00:04:18,590 --> 00:04:22,130
entire file system and if an attacker is

00:04:20,780 --> 00:04:23,690
able to get that key either through

00:04:22,130 --> 00:04:25,220
brute force or social engineering

00:04:23,690 --> 00:04:26,810
they've decrypted the entire file system

00:04:25,220 --> 00:04:29,750
and all of the data is now available to

00:04:26,810 --> 00:04:31,430
them whereas if you imagine each file in

00:04:29,750 --> 00:04:33,380
that operating system is encrypted with

00:04:31,430 --> 00:04:35,720
a unique key even if they're able to

00:04:33,380 --> 00:04:37,280
brute force the the high level operating

00:04:35,720 --> 00:04:38,780
system level key they still need the

00:04:37,280 --> 00:04:41,300
lower level encryption keys in order to

00:04:38,780 --> 00:04:42,890
access individual files right and this

00:04:41,300 --> 00:04:46,160
is really the context of application

00:04:42,890 --> 00:04:47,930
layer encryption is that it doesn't just

00:04:46,160 --> 00:04:49,520
protect the data at rest it also

00:04:47,930 --> 00:04:52,070
protects the data as it moves for the

00:04:49,520 --> 00:04:53,720
system so again taking that same example

00:04:52,070 --> 00:04:55,580
if I have some file system level

00:04:53,720 --> 00:04:58,580
security like BitLocker or file bolts if

00:04:55,580 --> 00:05:01,640
I take that file and move it to an NFS

00:04:58,580 --> 00:05:03,050
share it's now available for anyone it

00:05:01,640 --> 00:05:03,920
doesn't matter how secure my local file

00:05:03,050 --> 00:05:06,500
system is I've

00:05:03,920 --> 00:05:07,700
moved it to an insecure store however if

00:05:06,500 --> 00:05:10,130
we were applying application layer

00:05:07,700 --> 00:05:11,900
encryption i've instead moved a bunch of

00:05:10,130 --> 00:05:13,610
encrypted bytes from one file system

00:05:11,900 --> 00:05:17,470
onto another and it still has the same

00:05:13,610 --> 00:05:19,520
level of security that it had before so

00:05:17,470 --> 00:05:21,200
application layer encryption is just one

00:05:19,520 --> 00:05:23,000
level of encryption and generally we

00:05:21,200 --> 00:05:24,230
recommend using at least two layers of

00:05:23,000 --> 00:05:25,820
encryption so you want to use

00:05:24,230 --> 00:05:27,800
application layer encryption to protect

00:05:25,820 --> 00:05:29,090
things at the most granular level but

00:05:27,800 --> 00:05:31,250
then you also want to use filesystem

00:05:29,090 --> 00:05:32,420
encryption encrypted backups or even

00:05:31,250 --> 00:05:35,840
Hardware level encryption with something

00:05:32,420 --> 00:05:38,120
like TP use and secure boot so all of

00:05:35,840 --> 00:05:40,160
this background was to introduce you to

00:05:38,120 --> 00:05:42,710
kubernetes defaults so how many people

00:05:40,160 --> 00:05:44,330
here are familiar with kubernetes cool

00:05:42,710 --> 00:05:47,330
you're in the right room how many people

00:05:44,330 --> 00:05:50,660
know I have four frowning faces cool

00:05:47,330 --> 00:05:52,550
you're about to learn so kubernetes is

00:05:50,660 --> 00:05:54,500
insecure by default and there's a star

00:05:52,550 --> 00:05:56,300
there which I'll explain in a second but

00:05:54,500 --> 00:05:57,710
by defaults when you spin up a new

00:05:56,300 --> 00:06:00,380
kubernetes cluster whether it's Mini

00:05:57,710 --> 00:06:02,600
Cooper COO Badman or local cube all of

00:06:00,380 --> 00:06:04,670
the secrets are stored in plain text and

00:06:02,600 --> 00:06:05,960
NCD SED is kind of you can think of it

00:06:04,670 --> 00:06:08,870
as like the database that backs

00:06:05,960 --> 00:06:10,790
kubernetes it's a storage engine where

00:06:08,870 --> 00:06:13,370
most of the data stored in memory but

00:06:10,790 --> 00:06:16,610
they're only basics t4 encoded they're

00:06:13,370 --> 00:06:19,370
not encrypted meaning anyone with access

00:06:16,610 --> 00:06:21,590
to n CD or a backup of s CD or the

00:06:19,370 --> 00:06:23,630
master node can actually retrieve every

00:06:21,590 --> 00:06:26,480
single kubernetes secret and service

00:06:23,630 --> 00:06:28,940
account with a single request now

00:06:26,480 --> 00:06:31,580
there's a star here which is that a lot

00:06:28,940 --> 00:06:33,740
of providers like cloud providers will

00:06:31,580 --> 00:06:35,750
alter this default behavior so if you're

00:06:33,740 --> 00:06:38,660
using like google kubernetes engine or a

00:06:35,750 --> 00:06:39,590
KS or eks they don't do this by default

00:06:38,660 --> 00:06:41,390
but if you're running your own

00:06:39,590 --> 00:06:42,530
kubernetes cluster on your own bare

00:06:41,390 --> 00:06:43,730
metal or you're using some type of

00:06:42,530 --> 00:06:45,560
virtualization where you're managing

00:06:43,730 --> 00:06:48,140
this yourself if you haven't configured

00:06:45,560 --> 00:06:50,180
it anyone with access to your SED

00:06:48,140 --> 00:06:52,640
cluster or your master nodes has access

00:06:50,180 --> 00:06:55,220
to all of your secrets so what does this

00:06:52,640 --> 00:06:58,280
actually look like so here we have a

00:06:55,220 --> 00:06:59,990
piece of data a credit card and let's

00:06:58,280 --> 00:07:01,190
say I'm going to create the secret so

00:06:59,990 --> 00:07:03,050
I'm going to run coupe cuddle create

00:07:01,190 --> 00:07:05,150
secret with the contents of this

00:07:03,050 --> 00:07:07,070
particular credit card that's gonna hit

00:07:05,150 --> 00:07:09,680
the Kubb API server and the Kuby api

00:07:07,070 --> 00:07:12,680
server is going to encode but not

00:07:09,680 --> 00:07:14,150
encrypt that data see it's encoded it's

00:07:12,680 --> 00:07:15,500
just upside down with two equal signs at

00:07:14,150 --> 00:07:17,870
the end

00:07:15,500 --> 00:07:20,240
I'm glad some of you got that joke right

00:07:17,870 --> 00:07:22,370
so if an attacker which is represented

00:07:20,240 --> 00:07:25,190
by this raccoon on all of the slides has

00:07:22,370 --> 00:07:26,509
access to that at CD cluster all they

00:07:25,190 --> 00:07:27,770
have to do is turn that upside down and

00:07:26,509 --> 00:07:30,020
remove some equal signs and they have

00:07:27,770 --> 00:07:31,430
your credit card data right and it can

00:07:30,020 --> 00:07:32,870
be a credit card it can be a service

00:07:31,430 --> 00:07:35,509
account a passport a social security

00:07:32,870 --> 00:07:37,639
number any type of secret right an API

00:07:35,509 --> 00:07:45,530
key whatever it might be I like to call

00:07:37,639 --> 00:07:46,039
this encryption and I know what you're

00:07:45,530 --> 00:07:48,770
thinking

00:07:46,039 --> 00:07:49,880
right number one I'm not here to like

00:07:48,770 --> 00:07:52,099
talk badly about the kubernetes

00:07:49,880 --> 00:07:53,810
developers right secrets were an

00:07:52,099 --> 00:07:54,380
afterthought and that's okay and we're

00:07:53,810 --> 00:07:56,900
working on it

00:07:54,380 --> 00:07:58,490
number two you're probably thinking no

00:07:56,900 --> 00:08:02,300
one is gonna like leave their NCD

00:07:58,490 --> 00:08:03,590
cluster publicly exposed and I work for

00:08:02,300 --> 00:08:07,400
a company that doesn't let me show you

00:08:03,590 --> 00:08:09,560
this by there's a URL and I highly

00:08:07,400 --> 00:08:11,300
recommend that after this talk you go

00:08:09,560 --> 00:08:12,919
ahead and take a look at how many NCD

00:08:11,300 --> 00:08:16,880
clusters are publicly accessible with no

00:08:12,919 --> 00:08:18,080
authentication so instead of just

00:08:16,880 --> 00:08:19,580
talking about it I figured I'd show you

00:08:18,080 --> 00:08:27,470
this so let me jump out of the slides

00:08:19,580 --> 00:08:31,400
real quick and enter mirror mode all

00:08:27,470 --> 00:08:32,779
right so what I have here is I have a

00:08:31,400 --> 00:08:34,159
mini coop cluster because I wasn't sure

00:08:32,779 --> 00:08:35,779
how the internet was gonna work but this

00:08:34,159 --> 00:08:41,659
could also work on a big kubernetes

00:08:35,779 --> 00:08:44,240
cluster so I'm gonna use the secrets

00:08:41,659 --> 00:08:45,620
default context here and now I'm gonna

00:08:44,240 --> 00:08:49,760
create a secret so I'm gonna say a coop

00:08:45,620 --> 00:08:53,270
cuddle create secret generic what should

00:08:49,760 --> 00:08:58,360
our secret be called demo okay cool

00:08:53,270 --> 00:09:00,860
y'all are real exciting here and our our

00:08:58,360 --> 00:09:06,080
secret will be I don't know password

00:09:00,860 --> 00:09:08,420
equals log encryption okay

00:09:06,080 --> 00:09:12,170
I type encryption so much it's hard to

00:09:08,420 --> 00:09:18,860
type in crap ssin I can't tie a coupe

00:09:12,170 --> 00:09:28,010
cuddle create secret generic oh I spelt

00:09:18,860 --> 00:09:32,060
little wrong I like what you're right

00:09:28,010 --> 00:09:34,010
I can type there we go cool so I've now

00:09:32,060 --> 00:09:36,529
created this secret and how many people

00:09:34,010 --> 00:09:38,750
feel secure Cole I'm gonna make you feel

00:09:36,529 --> 00:09:42,940
even more insecure so I'm gonna cheat

00:09:38,750 --> 00:09:44,779
and exact right into the CD cluster but

00:09:42,940 --> 00:09:47,170
there's a number of different ways you

00:09:44,779 --> 00:09:47,170
could do this

00:09:49,480 --> 00:09:55,640
so I'm now on the NCD node this could be

00:09:53,870 --> 00:09:57,410
publicly exposed this could be a backup

00:09:55,640 --> 00:09:58,820
that you have restored because someone

00:09:57,410 --> 00:10:03,190
accidentally uploaded it to an s3 bucket

00:09:58,820 --> 00:10:03,190
fun fact that's what happened with Tesla

00:10:03,339 --> 00:10:08,420
just restore it point it to it and

00:10:05,810 --> 00:10:15,440
you're good to go so I'm gonna run a CD

00:10:08,420 --> 00:10:17,089
cuddle get registry secrets it's in the

00:10:15,440 --> 00:10:19,940
default namespace and we called it demo

00:10:17,089 --> 00:10:22,700
and look at that and crap Shin is just

00:10:19,940 --> 00:10:24,200
like right there just in plain text you

00:10:22,700 --> 00:10:26,029
don't even need to use NCD cuddle like

00:10:24,200 --> 00:10:27,020
you could just search the filesystem for

00:10:26,029 --> 00:10:31,149
this if you knew what you were looking

00:10:27,020 --> 00:10:35,329
for so you all should be real scared now

00:10:31,149 --> 00:10:37,160
all right so what can we do to fix this

00:10:35,329 --> 00:10:39,050
well the first thing we can do is

00:10:37,160 --> 00:10:40,339
explain envelope encryption to you

00:10:39,050 --> 00:10:41,570
because the rest of this talk won't make

00:10:40,339 --> 00:10:43,880
sense without talking about envelope

00:10:41,570 --> 00:10:46,339
encryption so what is envelope

00:10:43,880 --> 00:10:49,310
encryption well normally we have two

00:10:46,339 --> 00:10:52,310
pieces of data secret like a piece of

00:10:49,310 --> 00:10:54,410
data and a key with envelope encryption

00:10:52,310 --> 00:10:56,029
we introduce another kind of key so we

00:10:54,410 --> 00:10:57,949
have two keys we have a data encryption

00:10:56,029 --> 00:10:59,779
key the thing that encrypts our data and

00:10:57,949 --> 00:11:00,980
a key encryption key the thing that

00:10:59,779 --> 00:11:04,250
encrypts the key that encrypts our data

00:11:00,980 --> 00:11:05,540
it's very meta so I've prepared some

00:11:04,250 --> 00:11:07,830
animations for you and I hope you're

00:11:05,540 --> 00:11:11,220
impressed so

00:11:07,830 --> 00:11:13,230
seriously this took forever so we use

00:11:11,220 --> 00:11:15,390
our data encryption key which is the red

00:11:13,230 --> 00:11:16,680
key on the slide and we use it to

00:11:15,390 --> 00:11:18,390
encrypt our data and that gives us some

00:11:16,680 --> 00:11:21,420
bytes you can see that's denoted by the

00:11:18,390 --> 00:11:22,890
little red lock icon then we take our

00:11:21,420 --> 00:11:24,750
key encryption key which is the green

00:11:22,890 --> 00:11:26,760
one over there on the right and we

00:11:24,750 --> 00:11:28,649
encrypt our key with that key so the

00:11:26,760 --> 00:11:30,750
actual bytes that encrypted our credit

00:11:28,649 --> 00:11:33,570
card are now encrypted using this other

00:11:30,750 --> 00:11:34,980
key we then concatenate those two pieces

00:11:33,570 --> 00:11:36,149
of data together and we store them

00:11:34,980 --> 00:11:38,010
side-by-side using some type of

00:11:36,149 --> 00:11:39,709
separator in our storage system whether

00:11:38,010 --> 00:11:41,910
that's a database or a file system

00:11:39,709 --> 00:11:44,610
mobile phone whatever it might be

00:11:41,910 --> 00:11:46,860
this is envelope encryption at a very

00:11:44,610 --> 00:11:50,070
very high level when we want the

00:11:46,860 --> 00:11:52,230
plaintext data back we reverse this

00:11:50,070 --> 00:11:54,570
whole process so we separate the pieces

00:11:52,230 --> 00:11:57,149
based on our separator we then use the

00:11:54,570 --> 00:11:59,399
key encryption key to decrypt the data

00:11:57,149 --> 00:12:02,399
encryption key which we then use to

00:11:59,399 --> 00:12:05,220
decrypt the encrypted data to give us

00:12:02,399 --> 00:12:12,450
back the original plaintext data I hope

00:12:05,220 --> 00:12:15,120
you like my animations every time we

00:12:12,450 --> 00:12:17,070
encrypt a new piece of data we generate

00:12:15,120 --> 00:12:18,720
a data encryption key that's usually the

00:12:17,070 --> 00:12:20,250
responsibility of the operating system

00:12:18,720 --> 00:12:22,110
or the software to generate this

00:12:20,250 --> 00:12:24,209
one-time key so you generate some

00:12:22,110 --> 00:12:27,270
entropy you generate a 32-bit key or a

00:12:24,209 --> 00:12:28,709
32 byte key you encrypt the data the key

00:12:27,270 --> 00:12:30,329
encryption key the things over here on

00:12:28,709 --> 00:12:32,670
the right they tend to live a little bit

00:12:30,329 --> 00:12:34,529
longer so a key encryption key might

00:12:32,670 --> 00:12:36,630
encrypt five or six or a hundred

00:12:34,529 --> 00:12:38,850
different data encryption keys or decks

00:12:36,630 --> 00:12:41,940
as we call them and we rotate them

00:12:38,850 --> 00:12:43,290
periodically and we store the version

00:12:41,940 --> 00:12:47,209
number inside of here so we can easily

00:12:43,290 --> 00:12:50,040
decrypt them so all the loop encryption

00:12:47,209 --> 00:12:52,440
we generally generate a unique deck for

00:12:50,040 --> 00:12:53,430
each new data entry we can crypto

00:12:52,440 --> 00:12:53,880
stradun if you don't know what that

00:12:53,430 --> 00:12:56,579
means

00:12:53,880 --> 00:12:58,199
Thank You DPR I have a bunch of data and

00:12:56,579 --> 00:12:59,970
I need it revoked immediately instead of

00:12:58,199 --> 00:13:01,620
zeroing out a bunch of data we can just

00:12:59,970 --> 00:13:02,670
revoke the top-level key encryption key

00:13:01,620 --> 00:13:04,350
and now all of that data is

00:13:02,670 --> 00:13:05,160
irrecoverable except for a brute-force

00:13:04,350 --> 00:13:09,990
operations

00:13:05,160 --> 00:13:11,820
oops and it provides easy version and

00:13:09,990 --> 00:13:13,560
easy versioning and rotation we can

00:13:11,820 --> 00:13:15,779
rotate the key encryption keys and the

00:13:13,560 --> 00:13:17,459
data encryption keys separately so we

00:13:15,779 --> 00:13:20,850
don't have to maintain all of these kind

00:13:17,459 --> 00:13:23,160
of keys running around so kubernetes 1.7

00:13:20,850 --> 00:13:25,560
introduced envelope encryption to try to

00:13:23,160 --> 00:13:28,889
solve this problem so there's this

00:13:25,560 --> 00:13:30,509
top-level thing that you pass to the

00:13:28,889 --> 00:13:31,829
kubernetes api server when you start it

00:13:30,509 --> 00:13:34,769
called an encryption and i mean an

00:13:31,829 --> 00:13:36,540
encryption configuration you give it the

00:13:34,769 --> 00:13:39,000
different providers you want and there's

00:13:36,540 --> 00:13:42,089
a number of different providers a CBC

00:13:39,000 --> 00:13:45,779
256 GCM CB 256 secret box

00:13:42,089 --> 00:13:47,610
etc you put the keys in this file and

00:13:45,779 --> 00:13:50,130
then you restart the kubernetes api

00:13:47,610 --> 00:13:53,779
server with this - - encryption -

00:13:50,130 --> 00:13:55,380
provider - config flag and all as well

00:13:53,779 --> 00:13:57,509
so it goes like this

00:13:55,380 --> 00:14:00,149
so the data comes in to the cube API

00:13:57,509 --> 00:14:02,009
server the data then goes to this

00:14:00,149 --> 00:14:04,259
encryption config first before it goes

00:14:02,009 --> 00:14:06,389
to Etsy D the encryption config encrypts

00:14:04,259 --> 00:14:08,279
it and then puts it a net CD right so

00:14:06,389 --> 00:14:11,670
we're secure yay this talk is over

00:14:08,279 --> 00:14:13,529
except I have 15 minutes left so what

00:14:11,670 --> 00:14:15,959
happens if an attacker has accessed at

00:14:13,529 --> 00:14:17,910
CD well they have some encrypted data

00:14:15,959 --> 00:14:19,500
that's great like they can't really do

00:14:17,910 --> 00:14:21,360
anything they can brute-force decrypt it

00:14:19,500 --> 00:14:23,759
maybe but hopefully we've rotated our

00:14:21,360 --> 00:14:25,439
secrets by then but what happens enough

00:14:23,759 --> 00:14:29,519
attacker has access to our master node

00:14:25,439 --> 00:14:32,880
so that encryption config lives in

00:14:29,519 --> 00:14:36,420
plaintext on the master node where the

00:14:32,880 --> 00:14:39,649
keys are so any attacker worth their

00:14:36,420 --> 00:14:42,240
salt no pun intended

00:14:39,649 --> 00:14:44,069
congrat grab access to that encryption

00:14:42,240 --> 00:14:47,009
config file which if you remember from

00:14:44,069 --> 00:14:49,680
back here has the keys in it

00:14:47,009 --> 00:14:51,660
so all we've done is given a really

00:14:49,680 --> 00:14:54,750
really big lull to a skilled attacker

00:14:51,660 --> 00:14:56,399
because they're thinking oh wow you went

00:14:54,750 --> 00:14:58,889
to all of this effort and complicated

00:14:56,399 --> 00:15:00,959
your setup and add it overhead only for

00:14:58,889 --> 00:15:03,269
me to just decrypt it with an open SSL

00:15:00,959 --> 00:15:05,220
command because the encryption keys and

00:15:03,269 --> 00:15:07,259
the encrypted data are stored in the

00:15:05,220 --> 00:15:09,630
same threat model we haven't actually

00:15:07,259 --> 00:15:14,670
improved our security for anything other

00:15:09,630 --> 00:15:15,930
than a script Kitty so there are a

00:15:14,670 --> 00:15:17,699
number of drawbacks to this approach

00:15:15,930 --> 00:15:21,060
number one you have to generate those

00:15:17,699 --> 00:15:22,350
keys yourself so anytime you want to

00:15:21,060 --> 00:15:24,000
rotate or manage keys you have to

00:15:22,350 --> 00:15:27,240
generate them yourselves so you need

00:15:24,000 --> 00:15:29,130
some type of entropy source key

00:15:27,240 --> 00:15:30,660
management is your responsibility if

00:15:29,130 --> 00:15:31,860
you've ever actually done this it's

00:15:30,660 --> 00:15:33,809
really a pain in the butt you have to

00:15:31,860 --> 00:15:34,320
restart the Kubb api server every time

00:15:33,809 --> 00:15:36,420
you add a new

00:15:34,320 --> 00:15:39,270
encryption key which causes downtime or

00:15:36,420 --> 00:15:41,010
potential loss of service rotation is a

00:15:39,270 --> 00:15:42,360
manual process so you have to decide

00:15:41,010 --> 00:15:44,150
when you rotate how frequently you

00:15:42,360 --> 00:15:46,740
rotate it for both the decks and the qex

00:15:44,150 --> 00:15:48,060
and there's no HSM integration so if you

00:15:46,740 --> 00:15:49,590
work in a large enterprise where you

00:15:48,060 --> 00:15:51,420
process credit cards or a personal

00:15:49,590 --> 00:15:53,670
identifiable information you can't

00:15:51,420 --> 00:15:55,950
integrate with an HSM this way hardware

00:15:53,670 --> 00:15:57,900
security module but kind of as we talked

00:15:55,950 --> 00:15:59,460
about the biggest drawback is that it

00:15:57,900 --> 00:16:01,890
doesn't actually improve your security

00:15:59,460 --> 00:16:03,090
standpoint the plaint the the plaintext

00:16:01,890 --> 00:16:07,740
encryption keys are sitting right

00:16:03,090 --> 00:16:10,650
alongside the encrypted data so Kurban

00:16:07,740 --> 00:16:12,480
Annie's 110 at one 113 now for those

00:16:10,650 --> 00:16:14,310
playing along at home he introduced some

00:16:12,480 --> 00:16:17,120
happy faces so let me tell you how

00:16:14,310 --> 00:16:19,350
kubernetes 1.10 makes this really great

00:16:17,120 --> 00:16:22,770
kubernetes 1.10 introduces this concept

00:16:19,350 --> 00:16:24,660
of a plugin for encryption particularly

00:16:22,770 --> 00:16:26,550
it uses kms plugins or key management

00:16:24,660 --> 00:16:29,310
service or key management provider

00:16:26,550 --> 00:16:30,630
plugins they operate on a UNIX socket so

00:16:29,310 --> 00:16:32,910
you can leverage UNIX file permissions

00:16:30,630 --> 00:16:35,310
to control access and they delegate

00:16:32,910 --> 00:16:37,500
access to a key management service

00:16:35,310 --> 00:16:39,870
outside the management layer of

00:16:37,500 --> 00:16:41,460
kubernetes so it looks like this the

00:16:39,870 --> 00:16:43,140
data comes in hits the cube API server

00:16:41,460 --> 00:16:45,240
it hits the encryption config and then

00:16:43,140 --> 00:16:47,070
instead of hitting a local key the

00:16:45,240 --> 00:16:48,900
encryption config uses that socket and

00:16:47,070 --> 00:16:51,690
some type of authentication to talk to

00:16:48,900 --> 00:16:54,540
an external kms provider then encrypts

00:16:51,690 --> 00:16:56,220
the data in NCD so if an attacker oh and

00:16:54,540 --> 00:16:58,980
then to reverse the process it has to go

00:16:56,220 --> 00:17:01,620
back to kms to get you the plaintext

00:16:58,980 --> 00:17:05,459
data to go back so if an attacker has

00:17:01,620 --> 00:17:06,839
access to the master node or at CD they

00:17:05,459 --> 00:17:08,370
still won't have access to the keys

00:17:06,839 --> 00:17:10,470
because those are stored in a separate

00:17:08,370 --> 00:17:12,120
system for example that system might be

00:17:10,470 --> 00:17:13,920
something like Google Cloud kms or

00:17:12,120 --> 00:17:17,850
Amazon kms or even something like Hasek

00:17:13,920 --> 00:17:20,250
or vaults and there are existing plugins

00:17:17,850 --> 00:17:21,839
KMS plug-ins for kubernetes that do this

00:17:20,250 --> 00:17:24,120
for you so if you want to take a picture

00:17:21,839 --> 00:17:25,920
of a slide this is a good one so there's

00:17:24,120 --> 00:17:27,060
one that will integrate with Google

00:17:25,920 --> 00:17:27,870
Cloud kms there's one that will

00:17:27,060 --> 00:17:29,580
integrate with Azure

00:17:27,870 --> 00:17:31,500
I actually think Rita Zhang is here

00:17:29,580 --> 00:17:33,140
she's done a ton of work on that and a

00:17:31,500 --> 00:17:35,100
bunch of other stuff with flex volumes

00:17:33,140 --> 00:17:36,990
there's a neat obidos encryption

00:17:35,100 --> 00:17:38,040
provider and there's one that I'll demo

00:17:36,990 --> 00:17:42,390
in a second which is the Oracle

00:17:38,040 --> 00:17:44,820
kubernetes vault kms plugin if you're on

00:17:42,390 --> 00:17:46,740
Google Cloud so if you're running on gke

00:17:44,820 --> 00:17:47,410
google kubernetes hundred we actually

00:17:46,740 --> 00:17:49,179
have

00:17:47,410 --> 00:17:50,860
an option that will go into beta on

00:17:49,179 --> 00:17:52,900
Tuesday it's an alpha right now but you

00:17:50,860 --> 00:17:54,580
can still use it that does this for you

00:17:52,900 --> 00:17:57,400
so when you spin up a cluster or in the

00:17:54,580 --> 00:17:59,320
UI you can specify a KMS key and we'll

00:17:57,400 --> 00:18:01,299
set up all this for you and so this is

00:17:59,320 --> 00:18:02,740
automatically done we already do a bunch

00:18:01,299 --> 00:18:04,299
of stuff to protect the cluster this

00:18:02,740 --> 00:18:05,799
gives you full control over the key and

00:18:04,299 --> 00:18:10,210
the rotation and we'll do auto rotation

00:18:05,799 --> 00:18:11,679
of those keys for you but it introduces

00:18:10,210 --> 00:18:13,900
a new problem which is how do you

00:18:11,679 --> 00:18:15,880
authenticate your kubernetes nodes to

00:18:13,900 --> 00:18:17,049
talk to the kms provider how do you and

00:18:15,880 --> 00:18:19,750
it's called the initial secret problem

00:18:17,049 --> 00:18:21,490
or the first secret problem and a

00:18:19,750 --> 00:18:22,720
general eim is the way that you do this

00:18:21,490 --> 00:18:24,940
if you're on a cloud provider so

00:18:22,720 --> 00:18:26,530
identity and access management on GCP

00:18:24,940 --> 00:18:29,200
that service accounts on AWS that's

00:18:26,530 --> 00:18:31,150
either a RNs or access tokens but

00:18:29,200 --> 00:18:32,650
generally you give the master node

00:18:31,150 --> 00:18:34,630
either a service account credential and

00:18:32,650 --> 00:18:36,580
access token or you grant the machine

00:18:34,630 --> 00:18:38,380
that it's running on permission to talk

00:18:36,580 --> 00:18:40,840
to the API and you could revoke that at

00:18:38,380 --> 00:18:43,179
any time so you delegate Pam to the

00:18:40,840 --> 00:18:45,520
cloud provider through I am and then you

00:18:43,179 --> 00:18:47,590
separate concerns so the sed nodes the

00:18:45,520 --> 00:18:51,039
the physical VMs that xyg is running on

00:18:47,590 --> 00:18:53,380
does not get permission to talk to the

00:18:51,039 --> 00:18:55,360
kms provider you only give that to the

00:18:53,380 --> 00:18:56,740
API server nodes and this separates

00:18:55,360 --> 00:18:58,390
concerns so that an attacker has to

00:18:56,740 --> 00:19:01,210
compromise multiple systems in order to

00:18:58,390 --> 00:19:05,289
decrypt these values and you can revoke

00:19:01,210 --> 00:19:07,090
access to the kms keys at any time so

00:19:05,289 --> 00:19:09,490
what if you're not on a cloud provider

00:19:07,090 --> 00:19:11,650
or what if you already have a custom

00:19:09,490 --> 00:19:12,640
managed you know kubernetes setup and

00:19:11,650 --> 00:19:13,659
you're not ready to move to a cloud

00:19:12,640 --> 00:19:15,669
provider managed phone where these

00:19:13,659 --> 00:19:17,700
plugins already exist well this is where

00:19:15,669 --> 00:19:20,679
something like volt can come in so

00:19:17,700 --> 00:19:22,720
instead of the kms provider being a

00:19:20,679 --> 00:19:25,630
third-party kms provider like Google

00:19:22,720 --> 00:19:27,820
Cloud kms instead we can delegate this

00:19:25,630 --> 00:19:29,380
to vault and our friends over at Oracle

00:19:27,820 --> 00:19:31,030
have built a really helpful plugin that

00:19:29,380 --> 00:19:33,280
runs in kubernetes that helps us

00:19:31,030 --> 00:19:35,380
delegate this encryption and decryption

00:19:33,280 --> 00:19:37,030
to vault again this is envelope

00:19:35,380 --> 00:19:38,260
encryption so in volt there's this thing

00:19:37,030 --> 00:19:39,690
called the transit back-end it's

00:19:38,260 --> 00:19:43,150
basically key management as a service

00:19:39,690 --> 00:19:44,980
vault generates a key kubernetes then

00:19:43,150 --> 00:19:46,690
encrypts uses that key to encrypt

00:19:44,980 --> 00:19:49,150
another key the data encryption key

00:19:46,690 --> 00:19:52,419
which it uses to encrypt data at rest so

00:19:49,150 --> 00:19:56,710
what does that look like so let me jump

00:19:52,419 --> 00:20:03,360
back over here my cheat sheet

00:19:56,710 --> 00:20:05,230
all right coop cuddle config use context

00:20:03,360 --> 00:20:07,779
so I'll switch to a new kubernetes

00:20:05,230 --> 00:20:10,419
cluster this kubernetes cluster has the

00:20:07,779 --> 00:20:12,129
vault KMS encryption already set up and

00:20:10,419 --> 00:20:14,559
ready to go and that encryption config

00:20:12,129 --> 00:20:21,809
so I'm going to go ahead and create that

00:20:14,559 --> 00:20:28,259
same secret and now when we exact into

00:20:21,809 --> 00:20:33,009
sed hopefully at CD cuddle get

00:20:28,259 --> 00:20:35,369
registries secrets default demo you'll

00:20:33,009 --> 00:20:38,200
notice that that's not plaintext anymore

00:20:35,369 --> 00:20:40,090
that's a bunch of gargling goop

00:20:38,200 --> 00:20:42,009
but that's encrypted and it's encrypted

00:20:40,090 --> 00:20:45,970
in transit with TLS but it's encrypted

00:20:42,009 --> 00:20:47,980
at rest with this AES 256-bit CBC key

00:20:45,970 --> 00:20:49,720
that vault is managing and vault is

00:20:47,980 --> 00:20:51,429
being run outside of kubernetes right

00:20:49,720 --> 00:20:53,529
now so even if you were to compromise

00:20:51,429 --> 00:20:55,360
this sed cluster you can't actually

00:20:53,529 --> 00:20:58,029
decrypt this data by anything other than

00:20:55,360 --> 00:20:59,980
a brute-force attack and all of this is

00:20:58,029 --> 00:21:01,450
open source and there's a ton of guys

00:20:59,980 --> 00:21:02,980
and documentation and blog posts out

00:21:01,450 --> 00:21:05,740
there including these slides which will

00:21:02,980 --> 00:21:09,070
be up on the internet shortly that'll

00:21:05,740 --> 00:21:12,429
help you get this stuff set up so to

00:21:09,070 --> 00:21:14,379
conclude kubernetes can take us from sad

00:21:12,429 --> 00:21:17,200
to happy with respect to coop secrets

00:21:14,379 --> 00:21:18,519
management use at least two layers of

00:21:17,200 --> 00:21:20,499
encryption application layer encryption

00:21:18,519 --> 00:21:23,169
and hardware layer encryption rotate

00:21:20,499 --> 00:21:25,029
your keys regularly leverage envelope

00:21:23,169 --> 00:21:27,490
encryption it's the fastest and most

00:21:25,029 --> 00:21:30,070
scalable way to doing data encryption

00:21:27,490 --> 00:21:31,869
that we have today and protect

00:21:30,070 --> 00:21:33,009
kubernetes secrets using an external kms

00:21:31,869 --> 00:21:36,309
provider whether that's a cloud provider

00:21:33,009 --> 00:21:38,019
or something like Hashi core vault thank

00:21:36,309 --> 00:21:40,889
you I'll go back because there are

00:21:38,019 --> 00:21:40,889
people taking pictures of this slide

00:21:47,440 --> 00:21:59,210
so are there any questions hello

00:21:55,820 --> 00:22:01,700
so what if I run etcd

00:21:59,210 --> 00:22:04,070
on the masternodes that means that I

00:22:01,700 --> 00:22:05,840
basically need to provide I am

00:22:04,070 --> 00:22:08,270
permissions for the masternodes

00:22:05,840 --> 00:22:10,970
and then if I compromise the master

00:22:08,270 --> 00:22:14,570
basically I can decrypt anything by

00:22:10,970 --> 00:22:17,180
knowing the key ID if it's kms for

00:22:14,570 --> 00:22:19,670
example right right so the question is

00:22:17,180 --> 00:22:22,130
if I run a TD on the same nodes that I

00:22:19,670 --> 00:22:24,830
run the community this model like

00:22:22,130 --> 00:22:27,320
suggests us not to run etcd on the same

00:22:24,830 --> 00:22:29,450
nodes like on the master nodes right so

00:22:27,320 --> 00:22:32,030
we need to decouple that we have like

00:22:29,450 --> 00:22:34,070
maximum security yes that would increase

00:22:32,030 --> 00:22:38,240
your security much more than running

00:22:34,070 --> 00:22:40,070
them side-by-side okay but do you have

00:22:38,240 --> 00:22:42,559
like any suggestions what to do if I

00:22:40,070 --> 00:22:45,559
have etcd running on my master nodes and

00:22:42,559 --> 00:22:47,690
basically to use like Amazon kms or

00:22:45,559 --> 00:22:50,390
Google kms I need to provide like a

00:22:47,690 --> 00:22:53,360
service account integrated into machines

00:22:50,390 --> 00:22:55,280
metadata right or I am role integrated

00:22:53,360 --> 00:22:58,490
and Inter machines metadata what can I

00:22:55,280 --> 00:23:01,040
do to increase my security so even if

00:22:58,490 --> 00:23:02,900
you use an external kms provider when

00:23:01,040 --> 00:23:03,890
sed is on the master node with the

00:23:02,900 --> 00:23:05,390
cuvette API server

00:23:03,890 --> 00:23:07,730
you've still increased your security

00:23:05,390 --> 00:23:10,309
from when the keys live in plaintext

00:23:07,730 --> 00:23:12,170
because you can revoke that service

00:23:10,309 --> 00:23:14,000
account and those credentials without

00:23:12,170 --> 00:23:16,250
taking down all of your production

00:23:14,000 --> 00:23:19,160
infrastructure and also an attacker

00:23:16,250 --> 00:23:20,929
can't decrypt your data offline so

00:23:19,160 --> 00:23:22,580
you've increased your security posture a

00:23:20,929 --> 00:23:23,750
little bit because in the in the

00:23:22,580 --> 00:23:25,400
previous model where the keys are just

00:23:23,750 --> 00:23:27,920
stored in plain text and attacker can

00:23:25,400 --> 00:23:29,480
just do a full file system dump and now

00:23:27,920 --> 00:23:31,520
they can like run away with your data

00:23:29,480 --> 00:23:33,170
and decrypt it offline whereas with the

00:23:31,520 --> 00:23:34,730
kms provider if you have some audit

00:23:33,170 --> 00:23:36,770
logging and those things set up by

00:23:34,730 --> 00:23:39,230
default if you detect some anomalies you

00:23:36,770 --> 00:23:40,880
can revoke access to that key and now an

00:23:39,230 --> 00:23:42,770
attacker can't decrypt that data because

00:23:40,880 --> 00:23:44,030
you've broken the link to canvas so

00:23:42,770 --> 00:23:45,890
that's really the only thing if you

00:23:44,030 --> 00:23:46,880
haven't separated @cd from the master

00:23:45,890 --> 00:23:48,620
nodes that's the only thing you've

00:23:46,880 --> 00:23:51,380
improved is the ability to revoke access

00:23:48,620 --> 00:23:55,810
and prevent offline decryption okay

00:23:51,380 --> 00:23:55,810
things other questions

00:23:56,560 --> 00:24:02,930
there's no other questions okay hey

00:24:00,050 --> 00:24:04,880
thank you for a dog okay so for example

00:24:02,930 --> 00:24:07,760
I have a huge kubernetes cluster for

00:24:04,880 --> 00:24:09,890
1,000 nodes and have a lot of data on

00:24:07,760 --> 00:24:13,010
ITC denotes but if I want to change my

00:24:09,890 --> 00:24:16,400
KMS key or wherever so should I

00:24:13,010 --> 00:24:19,160
Riaan crypt OS is a data house this is

00:24:16,400 --> 00:24:20,540
process going on yeah so in the question

00:24:19,160 --> 00:24:21,920
is what should I do with my existing

00:24:20,540 --> 00:24:24,290
data that may or may not be encrypted

00:24:21,920 --> 00:24:26,510
and SCD when you generate that

00:24:24,290 --> 00:24:29,930
encryption provider config let me pull

00:24:26,510 --> 00:24:33,440
up a slide that has one on it so

00:24:29,930 --> 00:24:35,240
providers is an array the first item in

00:24:33,440 --> 00:24:36,190
that array is what is used to encrypt

00:24:35,240 --> 00:24:38,780
all data

00:24:36,190 --> 00:24:41,720
everything else is try it tries to

00:24:38,780 --> 00:24:43,550
decrypt the data so there's one of them

00:24:41,720 --> 00:24:45,620
called identity which just takes an

00:24:43,550 --> 00:24:47,840
empty object that will allow you to

00:24:45,620 --> 00:24:49,790
decrypt all of the plaintext objects

00:24:47,840 --> 00:24:51,800
that you currently have a net CD then

00:24:49,790 --> 00:24:54,080
you can do like a coop cuddle replace

00:24:51,800 --> 00:24:55,370
all on all of your secrets and it'll

00:24:54,080 --> 00:24:56,570
take a little bit if you have a thousand

00:24:55,370 --> 00:24:58,490
nodes but it'll go through and encrypt

00:24:56,570 --> 00:25:02,300
them all alternatively you can just

00:24:58,490 --> 00:25:04,310
choose to just choose to encrypt things

00:25:02,300 --> 00:25:07,030
going forward and however you know if

00:25:04,310 --> 00:25:07,030

YouTube URL: https://www.youtube.com/watch?v=f4Ru6CPG1z4


