Title: "Enlightening" KVM Hyper-V emulation
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Vitaly Kuznetsov

At: FOSDEM 2019
https://video.fosdem.org/2019/H.2213/vai_enlightening_kvm.webm


Is running a Windows guest any different from Linux from KVM's perspective?
KVM can pretend being Hyper-V and this is actively used for running Windows
guests. Following Hyper-V naming convention, individual features are named
"enlightenments": some of them are already mature, some of them were just
added to KVM and some are still waiting to be implemented. What are these
features and how Windows guests use them? How is it different from Linux? Attendees of the talk will get to know the current status and the ongoing
work for Hyper-V emulation in KVM, how this impacts Windows guests. Some
benchmarks won't be missing too.
The talk is intended for virtualization development engineers as well as
system administration running KVM in production. In the talk both the internals
of Hyper-V emulation in KVM and practical advises on how to run Windows guests
on KVM will be discussed. 

Room: H.2213
Scheduled start: 2019-02-02 10:30:00+01
Captions: 
	00:00:04,590 --> 00:00:17,369
oh okay so hello everyone let me welcome

00:00:15,809 --> 00:00:19,890
you to post them and to our

00:00:17,369 --> 00:00:22,830
virtualization and it reflected the

00:00:19,890 --> 00:00:24,920
server's dev room and I'm the first

00:00:22,830 --> 00:00:27,090
speaker of the day and in my

00:00:24,920 --> 00:00:29,570
presentation I'm gonna talk about how

00:00:27,090 --> 00:00:34,470
you can run Windows guests on KVM

00:00:29,570 --> 00:00:36,600
efficiently so in your infrastructure

00:00:34,470 --> 00:00:39,180
you are running virtual machines and

00:00:36,600 --> 00:00:41,700
some of these virtual machines are Linux

00:00:39,180 --> 00:00:42,450
VMs some of them are probably Windows

00:00:41,700 --> 00:00:45,899
VMs

00:00:42,450 --> 00:00:47,969
so does make any difference from as a

00:00:45,899 --> 00:00:49,800
virtualization to stack point of view

00:00:47,969 --> 00:00:52,800
like which operating system you are

00:00:49,800 --> 00:00:55,770
running in your guest and dancer well it

00:00:52,800 --> 00:00:58,260
depends so in theory it doesn't because

00:00:55,770 --> 00:01:00,870
with ki-moon and KB and we are actually

00:00:58,260 --> 00:01:03,180
trying to emulate some existing physical

00:01:00,870 --> 00:01:05,940
hardware by building the virtual machine

00:01:03,180 --> 00:01:08,160
right but then our if you boot your

00:01:05,940 --> 00:01:09,899
innards get on k vm and take a look in

00:01:08,160 --> 00:01:13,289
the log you will see something like this

00:01:09,899 --> 00:01:17,970
right and you will realize that your

00:01:13,289 --> 00:01:19,619
guest knows pretty like much everything

00:01:17,970 --> 00:01:22,259
about the fact that it's running

00:01:19,619 --> 00:01:24,390
virtualized it knows that it's running

00:01:22,259 --> 00:01:29,340
on k vm and it's actually using some

00:01:24,390 --> 00:01:32,310
features so why do we do that well the

00:01:29,340 --> 00:01:34,920
thing is that when we are trying to

00:01:32,310 --> 00:01:37,679
emulate physical Hardware in software

00:01:34,920 --> 00:01:40,860
that some interfaces were not designed

00:01:37,679 --> 00:01:44,190
for that and it can actually be slow in

00:01:40,860 --> 00:01:46,110
some cases so how do we solve these

00:01:44,190 --> 00:01:48,390
problems usually well if the hardware

00:01:46,110 --> 00:01:50,610
interface we need to emulate is slow and

00:01:48,390 --> 00:01:53,000
we cannot make it fast we come up with

00:01:50,610 --> 00:01:54,239
our own solution and we invent so called

00:01:53,000 --> 00:01:57,360
paravirtualized

00:01:54,239 --> 00:02:00,239
interface which is fast and which is

00:01:57,360 --> 00:02:03,330
software friendly right but then when we

00:02:00,239 --> 00:02:05,489
have our own interface we have to put

00:02:03,330 --> 00:02:07,770
support for this interface in the guest

00:02:05,489 --> 00:02:10,470
operating system right because it does

00:02:07,770 --> 00:02:13,260
not anything about it but the question

00:02:10,470 --> 00:02:15,510
is what do we do about proprietary

00:02:13,260 --> 00:02:17,489
operating systems like Windows how do we

00:02:15,510 --> 00:02:20,519
put these interfaces there right

00:02:17,489 --> 00:02:23,219
we don't have the source code and well

00:02:20,519 --> 00:02:24,989
we can probably write try writing

00:02:23,219 --> 00:02:27,680
drivers and that's actually what we do

00:02:24,989 --> 00:02:31,680
for example with rear tire devices right

00:02:27,680 --> 00:02:33,689
but the thing is that not everything is

00:02:31,680 --> 00:02:36,090
a device from like windows point of view

00:02:33,689 --> 00:02:38,670
and somewhere it core features with like

00:02:36,090 --> 00:02:41,250
interrupt handling or clock source are

00:02:38,670 --> 00:02:43,469
actually not device is not driver there

00:02:41,250 --> 00:02:46,739
in the core of the operating system so

00:02:43,469 --> 00:02:48,359
you may have hard times right in this

00:02:46,739 --> 00:02:51,120
driver for your proprietary operating

00:02:48,359 --> 00:02:52,560
systems and moreover there are multiple

00:02:51,120 --> 00:02:54,299
different Windows versions and you

00:02:52,560 --> 00:02:57,709
basically have to check that this

00:02:54,299 --> 00:03:01,169
solution works for every of these so

00:02:57,709 --> 00:03:03,469
what else can we do well we know that

00:03:01,169 --> 00:03:06,120
KBM is not the only hypervisor out there

00:03:03,469 --> 00:03:08,489
there are other like proprietary

00:03:06,120 --> 00:03:11,280
hypervisors and the thing is that these

00:03:08,489 --> 00:03:14,280
hypervisors have to solve the exact same

00:03:11,280 --> 00:03:16,139
issues because well for them this

00:03:14,280 --> 00:03:18,480
hardware interfaces are also slow and

00:03:16,139 --> 00:03:21,359
they also have to come up with their own

00:03:18,480 --> 00:03:25,859
interface so in Windows world this

00:03:21,359 --> 00:03:29,400
hypervisor is called hyper-v and we do

00:03:25,859 --> 00:03:33,209
emulate hyper-v in both like KVM and

00:03:29,400 --> 00:03:37,650
ki-moon and this that are basically like

00:03:33,209 --> 00:03:40,560
two different types of emulation there

00:03:37,650 --> 00:03:42,180
we emulate these core features which in

00:03:40,560 --> 00:03:43,889
hyper-v world are --court

00:03:42,180 --> 00:03:46,109
Enlightenment's and that's why my talk

00:03:43,889 --> 00:03:48,659
is called enlightening hyper-v I'm going

00:03:46,109 --> 00:03:52,889
to talk about the first part device

00:03:48,659 --> 00:03:54,870
drivers is something which would make it

00:03:52,889 --> 00:03:57,239
possible to replace for example ver tayo

00:03:54,870 --> 00:03:59,669
so if we write V ambass device drivers

00:03:57,239 --> 00:04:02,099
then we won't need volatile drivers for

00:03:59,669 --> 00:04:04,109
windows and the research effort and

00:04:02,099 --> 00:04:06,090
worth of the companies currently working

00:04:04,109 --> 00:04:08,250
on it but it's not currently upstream

00:04:06,090 --> 00:04:14,879
and I'm not going to talk much about it

00:04:08,250 --> 00:04:18,419
in my presentation so hyper-v features

00:04:14,879 --> 00:04:20,759
which we emulate where can you read some

00:04:18,419 --> 00:04:25,740
documentation about that there is no in

00:04:20,759 --> 00:04:29,319
kimu and KVM for you as a user and in

00:04:25,740 --> 00:04:33,149
libvirt you get this that's basically it

00:04:29,319 --> 00:04:36,369
probably not much you may or may not

00:04:33,149 --> 00:04:40,869
understand what these features are and

00:04:36,369 --> 00:04:42,729
if you want to know more you can go and

00:04:40,869 --> 00:04:44,979
basically read the specification

00:04:42,729 --> 00:04:47,439
hyper-real folks were generous enough to

00:04:44,979 --> 00:04:50,860
publish their spec it there on

00:04:47,439 --> 00:04:55,749
Microsoft's website or you can listen to

00:04:50,860 --> 00:05:01,059
me now so what features do we have in

00:04:55,749 --> 00:05:03,009
KVM and what are they needed for so I'll

00:05:01,059 --> 00:05:04,779
be showing you both like human syntax

00:05:03,009 --> 00:05:06,669
and liberal syntax how you can enable

00:05:04,779 --> 00:05:09,819
the feature and I will tell you a few

00:05:06,669 --> 00:05:11,439
words what this feature does so let's

00:05:09,819 --> 00:05:13,899
start with this one it's called like

00:05:11,439 --> 00:05:16,659
relaxed timing it's enabled by like HP

00:05:13,899 --> 00:05:19,020
relaxed in chemo and like these features

00:05:16,659 --> 00:05:22,149
hyper resumption in live bird and mostly

00:05:19,020 --> 00:05:24,580
these hyper V Enlightenment's in Liberty

00:05:22,149 --> 00:05:26,110
I enabled like that in features but

00:05:24,580 --> 00:05:30,219
there are some notable exceptions I will

00:05:26,110 --> 00:05:32,169
show you them and this feature basically

00:05:30,219 --> 00:05:34,330
tells your windows that it's running

00:05:32,169 --> 00:05:38,499
virtualized so it should disable all

00:05:34,330 --> 00:05:41,860
card watchdogs on different events

00:05:38,499 --> 00:05:42,999
because different operations can take

00:05:41,860 --> 00:05:45,339
different time when you're running

00:05:42,999 --> 00:05:47,259
virtualized right so if you put some

00:05:45,339 --> 00:05:48,969
hard watchdog there your windows can

00:05:47,259 --> 00:05:51,279
crash and actually more than Windows

00:05:48,969 --> 00:05:54,039
versions they don't require these they

00:05:51,279 --> 00:05:56,499
will detect a hypervisor CPU flag and

00:05:54,039 --> 00:05:58,149
enable this automatically but for all

00:05:56,499 --> 00:06:03,969
the Windows versions it makes sense to

00:05:58,149 --> 00:06:09,309
enable it Barbarella's I paravirtualized

00:06:03,969 --> 00:06:11,469
epic so it's enabled by HP epic and it

00:06:09,309 --> 00:06:16,229
basically provides a third page for each

00:06:11,469 --> 00:06:21,999
CPU to assist dealing with a peak and

00:06:16,229 --> 00:06:24,759
the notable feature here is per

00:06:21,999 --> 00:06:27,490
virtualized and of interrupt so here is

00:06:24,759 --> 00:06:29,559
a good example when like emulating

00:06:27,490 --> 00:06:31,659
Hardware interface is slow when you

00:06:29,559 --> 00:06:33,729
haven't interrupts right and like a

00:06:31,659 --> 00:06:36,249
level triggered interrupts are pending

00:06:33,729 --> 00:06:38,860
your hypervisor will stop your guest

00:06:36,249 --> 00:06:40,569
inject interrupt there and resume your

00:06:38,860 --> 00:06:43,090
guests your guests will notice the

00:06:40,569 --> 00:06:45,130
interrupt and probably will start doing

00:06:43,090 --> 00:06:47,230
and about it like launch like an

00:06:45,130 --> 00:06:49,570
interrupt service routine but when it's

00:06:47,230 --> 00:06:51,190
done it needs to somehow signal the fact

00:06:49,570 --> 00:06:53,139
that it's done with the interrupt and

00:06:51,190 --> 00:06:56,590
it's ready to receive the next one right

00:06:53,139 --> 00:06:58,990
and in hardware like in physical epic

00:06:56,590 --> 00:07:01,990
you basically write to a register and

00:06:58,990 --> 00:07:03,880
it's separation is like put you fast

00:07:01,990 --> 00:07:05,800
right so you write to the register it

00:07:03,880 --> 00:07:07,870
receives a bit and then you can receive

00:07:05,800 --> 00:07:10,360
a next interrupt but if you do it under

00:07:07,870 --> 00:07:12,010
the hypervisor you will get a VM exit

00:07:10,360 --> 00:07:13,449
right so your guest will be stopped you

00:07:12,010 --> 00:07:17,470
will drop in the hypervisor and

00:07:13,449 --> 00:07:19,750
hypervisor rule basically mark that the

00:07:17,470 --> 00:07:22,410
interrupts is not painting anymore and

00:07:19,750 --> 00:07:27,880
resume where guest it takes time so

00:07:22,410 --> 00:07:30,310
so-called pv end of interrupts was

00:07:27,880 --> 00:07:32,950
invented it's basically like the guest

00:07:30,310 --> 00:07:35,200
is just clearing one bit in the third

00:07:32,950 --> 00:07:38,080
page and the hypervisor will

00:07:35,200 --> 00:07:39,610
periodically look at this bit and when

00:07:38,080 --> 00:07:41,500
it's not pending anymore we are ready to

00:07:39,610 --> 00:07:45,180
inject next interrupt we don't need to

00:07:41,500 --> 00:07:47,680
do synchronously most of the time and

00:07:45,180 --> 00:07:50,800
there is a side effect that this feature

00:07:47,680 --> 00:07:52,120
is also required for enlightened vm CS

00:07:50,800 --> 00:07:57,070
feature I will tell you about this

00:07:52,120 --> 00:07:59,229
feature later paravirtualized spin locks

00:07:57,070 --> 00:08:02,800
labeled by SV spin locks and you can

00:07:59,229 --> 00:08:05,530
take tell it like T mu how many attempts

00:08:02,800 --> 00:08:08,979
to do before like giving up the thing is

00:08:05,530 --> 00:08:11,320
like there is the core concept of a spin

00:08:08,979 --> 00:08:13,360
lock right when two CPUs are trying to

00:08:11,320 --> 00:08:15,250
get the same resource they may do this

00:08:13,360 --> 00:08:16,690
like cheapest possible lock units

00:08:15,250 --> 00:08:19,300
basically they're checking a variable in

00:08:16,690 --> 00:08:21,039
memory and seeing if somebody else is

00:08:19,300 --> 00:08:23,229
doing something with the shared resource

00:08:21,039 --> 00:08:24,820
and you said like but if you want their

00:08:23,229 --> 00:08:26,050
you do something you reset it try the

00:08:24,820 --> 00:08:28,690
other CPU looks at it

00:08:26,050 --> 00:08:30,430
oh it's busy by someone else is doing

00:08:28,690 --> 00:08:32,409
the job and it just just spins it

00:08:30,430 --> 00:08:35,830
doesn't Janus it constantly check the

00:08:32,409 --> 00:08:38,560
state of this indicator to see if it can

00:08:35,830 --> 00:08:40,570
do something in virtualized world it can

00:08:38,560 --> 00:08:42,370
take significantly longer because your

00:08:40,570 --> 00:08:45,010
virtual CPU which actually took the

00:08:42,370 --> 00:08:46,870
resuit resource may not be running at

00:08:45,010 --> 00:08:49,510
this moment right it can happen that it

00:08:46,870 --> 00:08:51,190
took the resource and then it was out of

00:08:49,510 --> 00:08:53,530
loaded right and some other guest is

00:08:51,190 --> 00:08:56,050
running there so your CPU which is

00:08:53,530 --> 00:08:56,889
trying to get the look will have to wait

00:08:56,050 --> 00:09:00,129
for quite

00:08:56,889 --> 00:09:03,249
sometimes instead we can basically give

00:09:00,129 --> 00:09:04,989
up and give a chance for other recipes

00:09:03,249 --> 00:09:08,439
or other guests on the same physical

00:09:04,989 --> 00:09:10,660
CPUs to run right and that's what the

00:09:08,439 --> 00:09:13,660
feature does we also have a counterpart

00:09:10,660 --> 00:09:16,059
in KVM but windows cannot use this KVM

00:09:13,660 --> 00:09:20,109
feature so we can enable this hyper we

00:09:16,059 --> 00:09:22,119
feature next one is a simple one it's

00:09:20,109 --> 00:09:24,999
like whipping a virtual processor index

00:09:22,119 --> 00:09:27,910
it basically tells creates a virtual

00:09:24,999 --> 00:09:30,189
model specific register where each CPU

00:09:27,910 --> 00:09:34,149
can read its own number and in chemo

00:09:30,189 --> 00:09:35,859
they almost always match like the order

00:09:34,149 --> 00:09:37,779
in which they were created CPU one will

00:09:35,859 --> 00:09:39,489
get once if you two will get two but the

00:09:37,779 --> 00:09:41,949
thing is that we need this model

00:09:39,489 --> 00:09:45,279
specific register for some features I'm

00:09:41,949 --> 00:09:47,829
gonna tell you about and Windows if it

00:09:45,279 --> 00:09:49,929
won't see this feature it won't use the

00:09:47,829 --> 00:09:52,809
spiritual be flush and P VIP is for

00:09:49,929 --> 00:09:54,879
example because in this hyper calls CPUs

00:09:52,809 --> 00:10:00,879
are actually specified and this VP index

00:09:54,879 --> 00:10:03,489
terms runtime information right so you

00:10:00,879 --> 00:10:05,649
have a virtual CPU and sometimes it runs

00:10:03,489 --> 00:10:07,929
sometimes it doesn't and some other

00:10:05,649 --> 00:10:10,629
virtual CPU or the host is doing

00:10:07,929 --> 00:10:12,249
something on this physical CPU and if

00:10:10,629 --> 00:10:15,309
you want to do some like fair scheduling

00:10:12,249 --> 00:10:19,149
for example you may want to give your

00:10:15,309 --> 00:10:21,549
tasks same slices of time to run but the

00:10:19,149 --> 00:10:23,919
thing is you think that your task is

00:10:21,549 --> 00:10:27,429
running but actually it's not and

00:10:23,919 --> 00:10:28,509
something else is running there and how

00:10:27,429 --> 00:10:31,029
can you know that right

00:10:28,509 --> 00:10:33,610
so there's the protocol basically again

00:10:31,029 --> 00:10:36,129
like a shared like a register model

00:10:33,610 --> 00:10:39,759
specific register where Windows can read

00:10:36,129 --> 00:10:41,799
the information for how long the vcp was

00:10:39,759 --> 00:10:44,169
running and for how long something else

00:10:41,799 --> 00:10:46,419
was running there but the thing is how

00:10:44,169 --> 00:10:47,949
it's done in hyper-v it's done through a

00:10:46,419 --> 00:10:50,470
model specific register it's not a

00:10:47,949 --> 00:10:52,389
shared memory page so reading it will

00:10:50,470 --> 00:10:54,489
trap in the hypervisor so it's kind of

00:10:52,389 --> 00:10:57,249
slow and Windows as far as I know

00:10:54,489 --> 00:10:58,899
doesn't do that for scheduling by

00:10:57,249 --> 00:11:01,449
default because it would be really slow

00:10:58,899 --> 00:11:03,459
to switch between tasks and I'm not

00:11:01,449 --> 00:11:07,860
exactly sure when it actually does use

00:11:03,459 --> 00:11:10,270
the feature but maybe sometimes it does

00:11:07,860 --> 00:11:13,000
Kersh information that's quite in

00:11:10,270 --> 00:11:15,370
Tristan so your windows crashes

00:11:13,000 --> 00:11:17,050
everybody knows that right so you will

00:11:15,370 --> 00:11:20,770
get a blue screen of death but the thing

00:11:17,050 --> 00:11:22,420
is that not all of them are the same

00:11:20,770 --> 00:11:24,340
right so you may want to know especially

00:11:22,420 --> 00:11:27,190
if you are running VMs on a larger scale

00:11:24,340 --> 00:11:29,560
you may want to know like if you're

00:11:27,190 --> 00:11:31,000
actually seen saying crashes on like

00:11:29,560 --> 00:11:32,590
different hosts or these are like

00:11:31,000 --> 00:11:34,840
different crashes or like how many

00:11:32,590 --> 00:11:37,030
different crashes do you have so you can

00:11:34,840 --> 00:11:40,740
analyze them and windows can provide

00:11:37,030 --> 00:11:43,420
some information basically like five

00:11:40,740 --> 00:11:46,870
registers or I don't know yeah I think

00:11:43,420 --> 00:11:48,610
it's five on crash and you can get this

00:11:46,870 --> 00:11:50,590
information if you enable the feature

00:11:48,610 --> 00:11:52,600
then in labert log if you are running

00:11:50,590 --> 00:11:54,220
through live birth in chemo you can get

00:11:52,600 --> 00:11:56,640
this information too but I think you

00:11:54,220 --> 00:11:59,740
need to do like a dream peak common so

00:11:56,640 --> 00:12:02,050
not easy to get to this information from

00:11:59,740 --> 00:12:05,170
libvirt you will get it by default in

00:12:02,050 --> 00:12:07,030
the log I think Windows will tell you

00:12:05,170 --> 00:12:09,670
basically where it crashed and some

00:12:07,030 --> 00:12:13,060
parameters like registers so by

00:12:09,670 --> 00:12:14,770
comparing these in the logs you can see

00:12:13,060 --> 00:12:16,810
like if you are seeing same crashes or

00:12:14,770 --> 00:12:21,820
different crashes it can come handy in

00:12:16,810 --> 00:12:23,500
some situations clock source it's

00:12:21,820 --> 00:12:28,240
actually one of the most important

00:12:23,500 --> 00:12:32,740
entitlements and the thing is that in

00:12:28,240 --> 00:12:36,760
some workloads we need to get time

00:12:32,740 --> 00:12:38,410
stamps or pretty frequently you know for

00:12:36,760 --> 00:12:40,990
example they are trying to timestamp

00:12:38,410 --> 00:12:43,630
records in the database or network

00:12:40,990 --> 00:12:45,070
packets so your operating system will

00:12:43,630 --> 00:12:47,260
constantly be written from the clock

00:12:45,070 --> 00:12:49,540
source it has right but the thing is

00:12:47,260 --> 00:12:52,420
what is the clock source it's trying to

00:12:49,540 --> 00:12:55,510
access and on physical hardware it's

00:12:52,420 --> 00:12:58,270
usually nowadays it's TSC it's a

00:12:55,510 --> 00:13:01,990
register in your CPU which is usually

00:12:58,270 --> 00:13:03,850
good but in virtualized environment you

00:13:01,990 --> 00:13:05,710
cannot do that because your VM can

00:13:03,850 --> 00:13:07,930
actually for example migrate and there

00:13:05,710 --> 00:13:10,770
is gonna be like a jump in TC value and

00:13:07,930 --> 00:13:15,400
the jump can actually be backwards so

00:13:10,770 --> 00:13:17,770
not nice and virtual machines came with

00:13:15,400 --> 00:13:21,070
this concept of a paralyzed clock source

00:13:17,770 --> 00:13:22,750
and in t vm world it's called k vm clock

00:13:21,070 --> 00:13:23,950
but windows is not going to use your k

00:13:22,750 --> 00:13:26,800
vm clock right bye

00:13:23,950 --> 00:13:28,990
itself so we ambulate hyper-v clock

00:13:26,800 --> 00:13:32,290
which is basically the same concept it's

00:13:28,990 --> 00:13:34,870
a shared memory page with two values and

00:13:32,290 --> 00:13:37,810
to get the timestamp it reads the TC

00:13:34,870 --> 00:13:40,149
creditor from processor x like scale and

00:13:37,810 --> 00:13:42,339
adsorption if you're wearing my grades

00:13:40,149 --> 00:13:45,010
hypervisor will update these values and

00:13:42,339 --> 00:13:48,160
the region will stay like persistent so

00:13:45,010 --> 00:13:50,620
it won't jump anywhere so it's quite

00:13:48,160 --> 00:13:52,389
useful and it speeds up windows a lot so

00:13:50,620 --> 00:13:54,010
we'll have some time I will show you

00:13:52,389 --> 00:13:58,750
some benchmark at the very end of the

00:13:54,010 --> 00:14:02,709
talk so synthetic interrupt controller

00:13:58,750 --> 00:14:06,610
so that's the core component of building

00:14:02,709 --> 00:14:11,040
V emboss we emboss as a comp is the key

00:14:06,610 --> 00:14:13,120
component how you can create these PV

00:14:11,040 --> 00:14:15,579
devices which I'm not going to talk

00:14:13,120 --> 00:14:20,199
about but let's go how you can create PV

00:14:15,579 --> 00:14:22,120
devices in hyper-v so it allows you

00:14:20,199 --> 00:14:23,829
basically to it's somewhere like a

00:14:22,120 --> 00:14:26,139
communication protocol between the guest

00:14:23,829 --> 00:14:30,279
and the host you can like basically post

00:14:26,139 --> 00:14:32,529
messages and signal events and it's not

00:14:30,279 --> 00:14:33,970
interesting by itself unless you have

00:14:32,529 --> 00:14:37,060
some viewing bus devices which are not

00:14:33,970 --> 00:14:39,040
yet implemented but this enlightenment

00:14:37,060 --> 00:14:47,970
is required for Windows to use synthetic

00:14:39,040 --> 00:14:50,350
timers and synthetic timers yeah so

00:14:47,970 --> 00:14:52,420
synthetic timers is something like a

00:14:50,350 --> 00:14:54,880
like an alarm clock right you want to

00:14:52,420 --> 00:14:56,740
get in event in like one second say

00:14:54,880 --> 00:15:00,459
right so you set a timer you get an

00:14:56,740 --> 00:15:03,490
event and windows does is pretty

00:15:00,459 --> 00:15:06,370
frequently so again in hardware world

00:15:03,490 --> 00:15:09,250
you can use something like TC deadline

00:15:06,370 --> 00:15:10,839
timer now right so you see set next TC

00:15:09,250 --> 00:15:13,540
value and you will get an interrupt when

00:15:10,839 --> 00:15:16,480
it happens it's gonna be quite slow

00:15:13,540 --> 00:15:21,639
because you will have to program this or

00:15:16,480 --> 00:15:23,139
every time there is an event and again

00:15:21,639 --> 00:15:26,740
it means that he will be exiting to the

00:15:23,139 --> 00:15:29,829
hypervisor for each event you can set a

00:15:26,740 --> 00:15:31,930
periodic timer with this enlightenment

00:15:29,829 --> 00:15:34,870
and actually there was an update of

00:15:31,930 --> 00:15:37,330
Windows 10 and window 2016 last year

00:15:34,870 --> 00:15:39,400
when they change the frequency of

00:15:37,330 --> 00:15:41,830
basically setting up these timers and

00:15:39,400 --> 00:15:44,340
there was like a huge performance

00:15:41,830 --> 00:15:47,610
regression for Windows guests under KVM

00:15:44,340 --> 00:15:49,600
users were seeing their guests

00:15:47,610 --> 00:15:51,730
constantly spinning like assuming

00:15:49,600 --> 00:15:54,370
consuming 30% of the CPU even when

00:15:51,730 --> 00:15:55,960
they're idle you enable this and this

00:15:54,370 --> 00:15:57,820
goes away because Windows says this

00:15:55,960 --> 00:16:01,870
timer once and get this even when it

00:15:57,820 --> 00:16:06,370
needs it without any hassle he'll be

00:16:01,870 --> 00:16:08,350
shut down again if you know like when

00:16:06,370 --> 00:16:11,770
you map something in memory you may want

00:16:08,350 --> 00:16:13,240
to flash a teal buffer which is like a

00:16:11,770 --> 00:16:15,220
fast translation from one to another

00:16:13,240 --> 00:16:19,120
from physical from will filter physical

00:16:15,220 --> 00:16:21,550
and in x86 world if you want to flash

00:16:19,120 --> 00:16:23,440
this buffer on other CPUs you send IP is

00:16:21,550 --> 00:16:25,180
there so it's basically interrupts and

00:16:23,440 --> 00:16:27,850
you wait for them to perform the session

00:16:25,180 --> 00:16:29,980
down in virtualized world it may happen

00:16:27,850 --> 00:16:32,170
that this beast OCP usually want to

00:16:29,980 --> 00:16:34,450
flush are not actually running so it's

00:16:32,170 --> 00:16:36,010
kind of pointless to flush buffers there

00:16:34,450 --> 00:16:39,180
on the Pearl in the first place and

00:16:36,010 --> 00:16:43,930
second you will spend quite some time

00:16:39,180 --> 00:16:46,000
waiting for this to happen so they came

00:16:43,930 --> 00:16:47,710
up with this concept of Perpetual a

00:16:46,000 --> 00:16:49,540
shutdown so you tell the hypervisor to

00:16:47,710 --> 00:16:52,060
position the operation on your behalf

00:16:49,540 --> 00:16:54,100
and hypervisor actually knows which we

00:16:52,060 --> 00:16:55,450
should use it needs to flush and which

00:16:54,100 --> 00:16:58,540
are not running and they don't require

00:16:55,450 --> 00:17:00,280
flushing so this speeds up some

00:16:58,540 --> 00:17:01,810
overcommitted environment significantly

00:17:00,280 --> 00:17:06,100
when you have like more virtual CPUs

00:17:01,810 --> 00:17:08,880
than your physical CPUs pretty similar

00:17:06,100 --> 00:17:12,360
concept with para virtualized IP I but

00:17:08,880 --> 00:17:15,130
it cannot just drop the IP I because

00:17:12,360 --> 00:17:18,190
this interpreter interrupts they have to

00:17:15,130 --> 00:17:20,650
happen the only thing that we can flush

00:17:18,190 --> 00:17:24,610
first and IP is to for example more than

00:17:20,650 --> 00:17:27,400
64 CPUs at a time with this and in

00:17:24,610 --> 00:17:30,610
hardware you'll have to do a VM exit for

00:17:27,400 --> 00:17:34,810
every 64 cpus you want to send so it

00:17:30,610 --> 00:17:38,710
becomes like cheaper yeah a couple of

00:17:34,810 --> 00:17:42,220
like useless things you can do like you

00:17:38,710 --> 00:17:43,660
can set hyper-v vendor ID Microsoft

00:17:42,220 --> 00:17:46,300
Windows doesn't care about what you put

00:17:43,660 --> 00:17:48,160
there you can put a hyper-v TV here

00:17:46,300 --> 00:17:49,770
Microsoft hyper-v it doesn't really

00:17:48,160 --> 00:17:52,640
matter

00:17:49,770 --> 00:17:55,409
the other one is paravirtualized reset

00:17:52,640 --> 00:17:57,299
say another model specific register

00:17:55,409 --> 00:17:59,399
which allows your guests to reset itself

00:17:57,299 --> 00:18:01,500
and the thing is that even genuine

00:17:59,399 --> 00:18:04,320
hyper-v doesn't recommend using it so

00:18:01,500 --> 00:18:06,270
the future is there but for no

00:18:04,320 --> 00:18:08,730
particular reason at this moment but

00:18:06,270 --> 00:18:11,039
maybe for some very old windows guests

00:18:08,730 --> 00:18:14,250
it was required for modern guests is not

00:18:11,039 --> 00:18:16,230
required so there are also a couple

00:18:14,250 --> 00:18:18,120
features which are required if you are

00:18:16,230 --> 00:18:20,850
running nested guests if you are running

00:18:18,120 --> 00:18:22,950
like hyper beam on TEM or if you are

00:18:20,850 --> 00:18:25,110
enabling some security features in

00:18:22,950 --> 00:18:26,490
Windows which actually enable hyper-v

00:18:25,110 --> 00:18:30,600
and granese there are such features

00:18:26,490 --> 00:18:32,460
there and first is if you want to get

00:18:30,600 --> 00:18:34,799
stable clock souls and I just told you

00:18:32,460 --> 00:18:36,659
how important is to have a stable clock

00:18:34,799 --> 00:18:37,919
source if you are running nested you

00:18:36,659 --> 00:18:41,480
will need a couple of additional

00:18:37,919 --> 00:18:44,190
Enlightenment's one of them tells your

00:18:41,480 --> 00:18:46,830
level 1 hypervisor about your epic

00:18:44,190 --> 00:18:48,510
frequency the other one tells it when it

00:18:46,830 --> 00:18:50,610
changes for example when you migrate

00:18:48,510 --> 00:18:51,510
your level 1 guest with all its guests

00:18:50,610 --> 00:18:53,460
somewhere else

00:18:51,510 --> 00:18:55,590
so it actually needs to know that the

00:18:53,460 --> 00:18:58,080
frequency changed and that's how you do

00:18:55,590 --> 00:19:00,980
that it's not currently fully support in

00:18:58,080 --> 00:19:04,230
KVM so actually it doesn't send these

00:19:00,980 --> 00:19:05,789
rain lightning events so if your CPU is

00:19:04,230 --> 00:19:07,740
more than enough and you have to see

00:19:05,789 --> 00:19:10,620
scaling it's not an issue but if you're

00:19:07,740 --> 00:19:12,809
running on older CPUs your clock may

00:19:10,620 --> 00:19:16,140
start ticking at the wrong frequency it

00:19:12,809 --> 00:19:21,419
can happen so we know about it enlighten

00:19:16,140 --> 00:19:24,809
3 MCS I was telling ya giving a talk

00:19:21,419 --> 00:19:27,000
about it like last year it's that pretty

00:19:24,809 --> 00:19:30,179
complex feature but the thing is that to

00:19:27,000 --> 00:19:33,330
run virtualized guests you're dealing

00:19:30,179 --> 00:19:36,419
with such such called VM CS state on

00:19:33,330 --> 00:19:38,490
Intel and you're using specific CPU

00:19:36,419 --> 00:19:42,299
common specific instructions which are

00:19:38,490 --> 00:19:44,130
first not very fast and second I mean if

00:19:42,299 --> 00:19:46,890
your level 1 guest is built in this

00:19:44,130 --> 00:19:48,480
state for its level 2 guest you don't

00:19:46,890 --> 00:19:51,000
know what it's actually doing there

00:19:48,480 --> 00:19:52,500
because it runs on the CPU natively so

00:19:51,000 --> 00:19:54,960
you'll basically have to read the whole

00:19:52,500 --> 00:20:00,360
state there is a PV protocol for that

00:19:54,960 --> 00:20:03,120
which speeds things up for that so we

00:20:00,360 --> 00:20:04,050
have more features and works and this

00:20:03,120 --> 00:20:06,480
one is already on

00:20:04,050 --> 00:20:09,510
mailing list and that's why I put it on

00:20:06,480 --> 00:20:13,230
the slides if you are running hyper-v on

00:20:09,510 --> 00:20:16,770
KBM it will also like it would also like

00:20:13,230 --> 00:20:20,280
to see synthetic timers there but it

00:20:16,770 --> 00:20:23,370
cannot use synthetic timers in their

00:20:20,280 --> 00:20:26,550
current shape in the shape we in which

00:20:23,370 --> 00:20:29,790
Windows uses them so because it doesn't

00:20:26,550 --> 00:20:31,500
set up like full this infrastructure the

00:20:29,790 --> 00:20:34,380
hyper-v is like a very minimal

00:20:31,500 --> 00:20:36,690
hypervisor there it once like a

00:20:34,380 --> 00:20:38,790
simplified modern simplified node is

00:20:36,690 --> 00:20:43,160
getting an interrupt instead of a VM bus

00:20:38,790 --> 00:20:46,530
message and for that there is a dimer

00:20:43,160 --> 00:20:49,200
direct enlightenment which is already

00:20:46,530 --> 00:20:54,060
implemented and KVM in which will land

00:20:49,200 --> 00:20:55,980
in ki-moon shortly I believe so as I

00:20:54,060 --> 00:20:58,140
promised some benchmark so you

00:20:55,980 --> 00:21:01,350
understand how important these are

00:20:58,140 --> 00:21:03,930
Enlightenment's are so this is hyper-v

00:21:01,350 --> 00:21:06,990
clock source what we do in the test will

00:21:03,930 --> 00:21:09,240
basically spin and we do clog at times

00:21:06,990 --> 00:21:11,310
like basically what's what's the time

00:21:09,240 --> 00:21:14,070
right now right in the operating system

00:21:11,310 --> 00:21:15,570
so if you run it with and without HP

00:21:14,070 --> 00:21:18,600
time you will see the tremendous

00:21:15,570 --> 00:21:20,700
difference between because with HP time

00:21:18,600 --> 00:21:22,950
is basically written from memory so it's

00:21:20,700 --> 00:21:25,140
not very very different from are

00:21:22,950 --> 00:21:28,320
actually like reading like TC register

00:21:25,140 --> 00:21:30,480
from processor on bare hardware without

00:21:28,320 --> 00:21:34,490
extra time it means wium exit to the

00:21:30,480 --> 00:21:39,360
hypervisor every time so the speed-up is

00:21:34,490 --> 00:21:41,640
great here enlightened vm CS if you're

00:21:39,360 --> 00:21:43,740
running nested guest and you will do

00:21:41,640 --> 00:21:46,980
some operation which actually traps in

00:21:43,740 --> 00:21:49,080
the hypervisor and cpuid is as you know

00:21:46,980 --> 00:21:51,120
like gives you this like cpu features

00:21:49,080 --> 00:21:55,370
you have but it always needs to trap on

00:21:51,120 --> 00:22:01,220
the hypervisor so you will see that with

00:21:55,370 --> 00:22:04,140
HTV MCS we see like 10% difference here

00:22:01,220 --> 00:22:07,020
we still be shut down the test case is

00:22:04,140 --> 00:22:09,210
quite complex here and this one is like

00:22:07,020 --> 00:22:12,390
part of it but I think is we are doing M

00:22:09,210 --> 00:22:15,180
map and M on map of some like big file

00:22:12,390 --> 00:22:17,280
in chunks and this operation is known to

00:22:15,180 --> 00:22:20,850
cause TLB flushes on other

00:22:17,280 --> 00:22:23,309
and then what we do we are running the

00:22:20,850 --> 00:22:25,559
same test on the same host but we are

00:22:23,309 --> 00:22:28,169
just edging more and more weird so CPUs

00:22:25,559 --> 00:22:31,049
to our guests and as you can see when

00:22:28,169 --> 00:22:33,419
the number of like virtual CPUs matches

00:22:31,049 --> 00:22:35,220
there is almost no benefit in the

00:22:33,419 --> 00:22:37,950
feature it's the same right as sending

00:22:35,220 --> 00:22:40,169
this IP I isn't doing flash natively but

00:22:37,950 --> 00:22:42,929
as we go overcome it it's like more and

00:22:40,169 --> 00:22:45,150
more CPUs we have this PV T will be

00:22:42,929 --> 00:22:47,250
flash on the right the number stays more

00:22:45,150 --> 00:22:49,260
or less the same because we don't really

00:22:47,250 --> 00:22:50,820
need to flash this V CPUs which are not

00:22:49,260 --> 00:22:53,669
running and they cannot be running at

00:22:50,820 --> 00:22:56,640
the same time and but with physical

00:22:53,669 --> 00:22:59,460
pivot will be flash you will see the

00:22:56,640 --> 00:23:03,480
slowdown of the same test case on the

00:22:59,460 --> 00:23:08,809
same physical host so that was it from

00:23:03,480 --> 00:23:08,809
me thank you for listening any questions

00:23:20,870 --> 00:23:28,409
the question is on which versions we

00:23:24,750 --> 00:23:30,120
expect to see these features I guessing

00:23:28,409 --> 00:23:32,340
that you're asking about both like KVM

00:23:30,120 --> 00:23:34,860
versions and chemo versions Yeah right

00:23:32,340 --> 00:23:37,919
so everything I was telling you about

00:23:34,860 --> 00:23:40,650
today is already upstream in KVM

00:23:37,919 --> 00:23:46,289
including the synthetic timers direct

00:23:40,650 --> 00:23:50,419
mode in kimu I don't actually remember

00:23:46,289 --> 00:23:53,880
like a top of my head but I think that

00:23:50,419 --> 00:23:57,750
everson except for like PvE Tilby floppy

00:23:53,880 --> 00:24:01,110
VIP eye and enlightenment we MCS is

00:23:57,750 --> 00:24:04,860
there in like 2 dot like 12 or something

00:24:01,110 --> 00:24:09,000
in 3.0 we were editing like Pvt lb flash

00:24:04,860 --> 00:24:11,400
and through and enlightened v mcs

00:24:09,000 --> 00:24:13,860
something like that so if you grab

00:24:11,400 --> 00:24:15,750
current ki-moon it has ever seen but

00:24:13,860 --> 00:24:18,360
this synthetic time with direct mode

00:24:15,750 --> 00:24:20,929
there are see is on the mailing list I'm

00:24:18,360 --> 00:24:22,679
also trying to come up with a

00:24:20,929 --> 00:24:25,710
simplification which would be called

00:24:22,679 --> 00:24:27,690
like HV all which will enable all hyper

00:24:25,710 --> 00:24:29,760
rate features for you it's like a little

00:24:27,690 --> 00:24:31,050
bit controversial because the question

00:24:29,760 --> 00:24:33,690
is what happens when you Mike

00:24:31,050 --> 00:24:35,460
CVM right your other host may have

00:24:33,690 --> 00:24:37,050
different hyper enlightenment support

00:24:35,460 --> 00:24:40,320
like you have different Aryan versions

00:24:37,050 --> 00:24:42,450
so like liberal folks prefer to have all

00:24:40,320 --> 00:24:44,760
these Enlightenment's listed there so

00:24:42,450 --> 00:24:48,330
prefer to keep them like fine-grained

00:24:44,760 --> 00:24:50,670
and they may not support it but in chemo

00:24:48,330 --> 00:24:53,220
it may actually come handy for like

00:24:50,670 --> 00:24:56,490
development test cases for a single host

00:24:53,220 --> 00:25:00,170
you suggest stuff like that so expect to

00:24:56,490 --> 00:25:05,070
see this feature in near future

00:25:00,170 --> 00:25:06,690
more questions yes oh so many at the

00:25:05,070 --> 00:25:09,800
back you were the first to raise your

00:25:06,690 --> 00:25:09,800
hand so please go ahead

00:25:22,040 --> 00:25:26,880
yeah the question is why are these

00:25:24,630 --> 00:25:29,370
features not enabling not enabled by

00:25:26,880 --> 00:25:31,490
default and what's the cost for enabling

00:25:29,370 --> 00:25:35,820
them or for the guest operating system

00:25:31,490 --> 00:25:37,920
so the cost is basically zero except the

00:25:35,820 --> 00:25:40,140
notable exception is enlightened VMC s

00:25:37,920 --> 00:25:42,360
because enlightened three MCS comes with

00:25:40,140 --> 00:25:45,390
a penalty for example you will have your

00:25:42,360 --> 00:25:47,880
posting drugs disabled and for some

00:25:45,390 --> 00:25:49,680
workloads when you have for example some

00:25:47,880 --> 00:25:51,360
physical hardware which is actually able

00:25:49,680 --> 00:25:53,430
to deliver posted interrupts that's

00:25:51,360 --> 00:25:55,200
going to be a slowdown in other cases

00:25:53,430 --> 00:25:57,810
when you don't have such hardware it

00:25:55,200 --> 00:26:00,780
will be a speed-up so this feature we

00:25:57,810 --> 00:26:02,040
cannot enable by default the rest the

00:26:00,780 --> 00:26:03,900
cost is zero

00:26:02,040 --> 00:26:06,000
even if you're guest operating system is

00:26:03,900 --> 00:26:07,920
not using them you can enable them for a

00:26:06,000 --> 00:26:11,270
KVM guest and you won't notice anything

00:26:07,920 --> 00:26:14,730
why we don't enable them by default

00:26:11,270 --> 00:26:16,890
probably because of how the

00:26:14,730 --> 00:26:18,750
virtualization stack is designed and the

00:26:16,890 --> 00:26:21,240
most important thing there is migration

00:26:18,750 --> 00:26:24,120
right so if you don't need these

00:26:21,240 --> 00:26:24,630
features but you enable all them that

00:26:24,120 --> 00:26:26,670
later

00:26:24,630 --> 00:26:28,440
you cannot migrate this VM to some host

00:26:26,670 --> 00:26:30,390
which doesn't have this feature because

00:26:28,440 --> 00:26:32,070
from the hypervisor point of view we

00:26:30,390 --> 00:26:34,290
don't know if the guest is using the

00:26:32,070 --> 00:26:36,120
feature or not or we will have to come

00:26:34,290 --> 00:26:38,160
up with an interface Oh what the guest

00:26:36,120 --> 00:26:40,920
using this feature or not can we disable

00:26:38,160 --> 00:26:44,580
it we don't have this in either cream or

00:26:40,920 --> 00:26:45,000
team TM so yeah so thank you guys very

00:26:44,580 --> 00:26:48,090
much

00:26:45,000 --> 00:26:52,520
we're out of time so I will take your

00:26:48,090 --> 00:26:52,520
questions here in the corridor

00:26:54,360 --> 00:26:56,420

YouTube URL: https://www.youtube.com/watch?v=5l6fO6Smn50


