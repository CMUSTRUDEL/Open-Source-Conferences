Title: Lessons in TableGen
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Nicolai HÃ¤hnle

At: FOSDEM 2019
https://video.fosdem.org/2019/K.4.201/llvm_tablegen.webm


TableGen is LLVM's DSL for describing intrinsics, backends' machine instructions, physical registers, machine scheduling models, and a bunch of other things. It is extremely flexible and powerful, but can also be rather aggravating. Most people who spend a significant amount of time working on an LLVM backend probably develop a love/hate-relationship with it. 

The goal of this talk is to give a brief overview of what TableGen offers -- frontend, application-specific backends, generic table emission backend, idiosyncratic type system, and these days even limited functional-style programming -- and a brief introduction on how to use it. The focus will be mostly on the frontend -- that is, syntax and semantics of the TableGen DSL itself -- rather than on specific backends. 

Along the way, I want to share some lessons learned and decisions made during a major refactoring of the TableGen frontend that I undertook in early 2018 to iron out many of TableGen's quirks and shortcomings that had accumulated over the years, as well as some glimpses of the advanced TableGen uses in the AMDGPU backend that motivated that refactoring. 

Room: K.4.201
Scheduled start: 2019-02-03 12:00:00+01
Captions: 
	00:00:05,240 --> 00:00:12,540
all right hello everybody my name is

00:00:08,760 --> 00:00:15,269
Nicola Hanley I work at AMD on the GPU

00:00:12,540 --> 00:00:18,689
side of the company where we developed

00:00:15,269 --> 00:00:22,320
the AMD GPU target in LLVM which is

00:00:18,689 --> 00:00:24,449
upstream and we use to compile compute

00:00:22,320 --> 00:00:26,820
kernels and graphics traders directly

00:00:24,449 --> 00:00:28,619
into binary that runs on the GPU but

00:00:26,820 --> 00:00:31,199
this talk is not about that this talk is

00:00:28,619 --> 00:00:34,110
about table gen which is the

00:00:31,199 --> 00:00:37,590
domain-specific language that is used in

00:00:34,110 --> 00:00:39,660
part to build LLVM itself now my own

00:00:37,590 --> 00:00:41,550
personal history with table gen is

00:00:39,660 --> 00:00:43,680
probably fairly standard initially I

00:00:41,550 --> 00:00:45,899
mean I started working on the back end

00:00:43,680 --> 00:00:48,719
and you just have to use it at some

00:00:45,899 --> 00:00:51,540
point I copied and pasted stuff and then

00:00:48,719 --> 00:00:53,610
last year there was something that I

00:00:51,540 --> 00:00:55,800
worked on in our back end that really

00:00:53,610 --> 00:00:58,579
ran into the limitations of the table

00:00:55,800 --> 00:01:01,590
ten front end like ran into weird errors

00:00:58,579 --> 00:01:05,970
crashes and so on so I dug in more

00:01:01,590 --> 00:01:08,460
deeply and in part this talk is my

00:01:05,970 --> 00:01:10,679
attempt to you know spread some of the

00:01:08,460 --> 00:01:12,479
knowledge that I gained while looking

00:01:10,679 --> 00:01:16,350
deeply into tables and fixing some of

00:01:12,479 --> 00:01:18,539
these problems that I encountered so the

00:01:16,350 --> 00:01:20,640
agenda is you know brief overview of

00:01:18,539 --> 00:01:24,090
what is table gen where it is used very

00:01:20,640 --> 00:01:25,800
roughly and then really look at what are

00:01:24,090 --> 00:01:28,289
the features of the tables in language

00:01:25,800 --> 00:01:29,700
what can you do with it maybe you'll

00:01:28,289 --> 00:01:31,649
learn about some interesting patterns

00:01:29,700 --> 00:01:34,229
that you can use in your own tables and

00:01:31,649 --> 00:01:37,410
sources and depending on how time

00:01:34,229 --> 00:01:40,020
permits at the end I want to take a bit

00:01:37,410 --> 00:01:42,720
of a more deep dive into one of the more

00:01:40,020 --> 00:01:46,080
advanced uses of tables and language

00:01:42,720 --> 00:01:47,819
features in our backend the nature of

00:01:46,080 --> 00:01:49,590
this talk is such that you may have

00:01:47,819 --> 00:01:51,959
questions that it makes sense to ask

00:01:49,590 --> 00:01:56,610
right then and there so don't hesitate

00:01:51,959 --> 00:02:01,289
to do that when it makes sense all right

00:01:56,610 --> 00:02:04,800
so what is table Jen so table Jen is a

00:02:01,289 --> 00:02:06,959
tool LLVM - table general into which you

00:02:04,800 --> 00:02:08,459
can feed table Jen source like the

00:02:06,959 --> 00:02:11,340
examples you see on the left hand side

00:02:08,459 --> 00:02:13,829
and it spits you out some automatically

00:02:11,340 --> 00:02:17,819
generated C++ code that you then include

00:02:13,829 --> 00:02:18,300
in your handwritten C++ code it is used

00:02:17,819 --> 00:02:20,670
for also

00:02:18,300 --> 00:02:22,700
lots of things in in backends so for

00:02:20,670 --> 00:02:26,010
example machine instruction descriptions

00:02:22,700 --> 00:02:28,770
register descriptions scheduling

00:02:26,010 --> 00:02:31,530
properties of the microarchitectures of

00:02:28,770 --> 00:02:34,410
the machines that you're targeting it

00:02:31,530 --> 00:02:37,500
automatically generates you know byte

00:02:34,410 --> 00:02:40,050
code for instruction selection assembly

00:02:37,500 --> 00:02:44,130
parsers and emitters disassemblers etc

00:02:40,050 --> 00:02:45,750
and it all does this based on on these

00:02:44,130 --> 00:02:47,940
kind of sources that you see here in

00:02:45,750 --> 00:02:49,500
this example it's just the definition of

00:02:47,940 --> 00:02:51,600
four machine instructions that we have

00:02:49,500 --> 00:03:00,210
in our back ends you know scaler a

00:02:51,600 --> 00:03:02,580
bitwise and an or in 32 and 64 bits so I

00:03:00,210 --> 00:03:04,260
said that's one tool LLVM - table gen

00:03:02,580 --> 00:03:06,150
that's a bit of a lie I know actually of

00:03:04,260 --> 00:03:08,820
two tables and tools one in LLVM and one

00:03:06,150 --> 00:03:11,190
in clang they use the same front end

00:03:08,820 --> 00:03:14,310
which is just a library that is reusable

00:03:11,190 --> 00:03:16,200
part of LLVM and they have different

00:03:14,310 --> 00:03:19,350
backends you know for different purposes

00:03:16,200 --> 00:03:23,120
so in general the flow of what table gen

00:03:19,350 --> 00:03:27,540
does is it reads your table gen sources

00:03:23,120 --> 00:03:30,780
the front end parses it does some

00:03:27,540 --> 00:03:33,630
evaluation on it and produces a big list

00:03:30,780 --> 00:03:36,930
of record definitions which I'll show

00:03:33,630 --> 00:03:38,160
you later and then the back ends they

00:03:36,930 --> 00:03:40,260
don't care about the original source

00:03:38,160 --> 00:03:42,989
anymore they just look at this set of

00:03:40,260 --> 00:03:44,100
records they maybe filter them to look

00:03:42,989 --> 00:03:46,170
at only the records that they are

00:03:44,100 --> 00:03:48,720
interested in which depends on the back

00:03:46,170 --> 00:03:51,540
end interpret what is in those records

00:03:48,720 --> 00:03:56,250
and then use that to generate the

00:03:51,540 --> 00:03:57,660
purpose specific auto-generated C++ you

00:03:56,250 --> 00:03:59,489
specify the back end that you want to

00:03:57,660 --> 00:04:02,070
use on a table gen command line and if

00:03:59,489 --> 00:04:04,260
you don't specify any then it'll just

00:04:02,070 --> 00:04:06,120
dump all the record definitions that's

00:04:04,260 --> 00:04:08,370
extremely verbose but it's also

00:04:06,120 --> 00:04:10,440
extremely helpful sometimes if you want

00:04:08,370 --> 00:04:11,760
to kind of debug some gnarly problem

00:04:10,440 --> 00:04:14,640
that you have with your table gen source

00:04:11,760 --> 00:04:16,169
so if there is one lesson only one

00:04:14,640 --> 00:04:17,880
lesson to take away from this talk it

00:04:16,169 --> 00:04:19,260
should actually be this that if you're

00:04:17,880 --> 00:04:21,330
running into problems with table gen

00:04:19,260 --> 00:04:23,250
don't be afraid to just dump all the

00:04:21,330 --> 00:04:25,500
records and use you know record searches

00:04:23,250 --> 00:04:28,440
in what you get to figure out in detail

00:04:25,500 --> 00:04:30,660
what's going on but usually you don't

00:04:28,440 --> 00:04:33,260
invoke tables and yourself you let see

00:04:30,660 --> 00:04:35,340
make to it it's all integrate

00:04:33,260 --> 00:04:36,960
usually you don't have to worry about it

00:04:35,340 --> 00:04:39,360
too much there's some snippet of how it

00:04:36,960 --> 00:04:41,430
is integrated as an example the one

00:04:39,360 --> 00:04:44,340
lesson that you should take away from

00:04:41,430 --> 00:04:45,570
this is that there is this setting LLVM

00:04:44,340 --> 00:04:47,790
up to my stable gender which you should

00:04:45,570 --> 00:04:49,980
absolutely use in debug builds because

00:04:47,790 --> 00:04:52,110
even if you do a debug build of LVM

00:04:49,980 --> 00:04:54,510
usually you don't want a debug build of

00:04:52,110 --> 00:04:57,320
table Jen right so optimize that it

00:04:54,510 --> 00:04:57,320
helps you build times

00:04:57,540 --> 00:05:01,950
okay so records so what are what are

00:04:59,610 --> 00:05:03,690
records well they're basically just key

00:05:01,950 --> 00:05:07,560
value dictionaries usually with a name

00:05:03,690 --> 00:05:09,710
so on the right hand side you see at the

00:05:07,560 --> 00:05:12,420
top this little snippet that I showed

00:05:09,710 --> 00:05:14,610
two slides earlier and this little

00:05:12,420 --> 00:05:17,190
snippet actually gets expanded into this

00:05:14,610 --> 00:05:18,900
you know big record definition and this

00:05:17,190 --> 00:05:23,970
is actually only just a small excerpt of

00:05:18,900 --> 00:05:27,600
it and the way that this this expansion

00:05:23,970 --> 00:05:29,520
happens is table Jen has a notion of

00:05:27,600 --> 00:05:32,880
classes which are basically templates

00:05:29,520 --> 00:05:36,600
for records so at the top you see this

00:05:32,880 --> 00:05:39,690
you know s and B 32 colon stop 232 stop

00:05:36,600 --> 00:05:42,180
232 is a class table join class which is

00:05:39,690 --> 00:05:44,880
defined in our back ends table Jen

00:05:42,180 --> 00:05:48,060
sources which then itself you know

00:05:44,880 --> 00:05:50,550
derives from other classes and and once

00:05:48,060 --> 00:05:54,990
all the transitive inheritance is done

00:05:50,550 --> 00:05:56,460
you get this this big record you have at

00:05:54,990 --> 00:05:58,410
the top this is something that the

00:05:56,460 --> 00:06:02,070
record dumping prints out in these

00:05:58,410 --> 00:06:04,380
double slash comments a list of all the

00:06:02,070 --> 00:06:07,770
classes that were transitively inherited

00:06:04,380 --> 00:06:09,510
so most of these are target specific but

00:06:07,770 --> 00:06:12,150
in particular there is this class called

00:06:09,510 --> 00:06:14,460
instruction so instruction is a target

00:06:12,150 --> 00:06:15,840
independent class which all the back

00:06:14,460 --> 00:06:18,240
ends that are interested in machine

00:06:15,840 --> 00:06:20,190
instructions use to filter out the

00:06:18,240 --> 00:06:22,380
record definitions so they look at all

00:06:20,190 --> 00:06:24,419
the record definitions that somehow

00:06:22,380 --> 00:06:27,270
directly or indirectly inherit from

00:06:24,419 --> 00:06:30,410
instruction and then they they work with

00:06:27,270 --> 00:06:32,700
those and yeah like I said usually

00:06:30,410 --> 00:06:34,680
records are named so in this case we

00:06:32,700 --> 00:06:37,260
have a name that actually appears as you

00:06:34,680 --> 00:06:39,419
know the the enum in C++ to refer to

00:06:37,260 --> 00:06:41,250
that machine instructions not all of

00:06:39,419 --> 00:06:42,930
them have to be named like if you have

00:06:41,250 --> 00:06:44,760
standalone instruction selection

00:06:42,930 --> 00:06:46,020
patterns they don't need a name although

00:06:44,760 --> 00:06:51,180
just giving them a name kind

00:06:46,020 --> 00:06:52,949
helpful for debugging issues yeah and so

00:06:51,180 --> 00:06:55,500
table Jen is not just a tool it's also

00:06:52,949 --> 00:06:57,840
this domain-specific language and it has

00:06:55,500 --> 00:06:59,849
a kind of a core language which is used

00:06:57,840 --> 00:07:03,780
to write down record definitions and

00:06:59,849 --> 00:07:07,319
then a larger set of features around it

00:07:03,780 --> 00:07:09,419
that allow you to generate kind of

00:07:07,319 --> 00:07:12,449
regular sets of records fairly easily

00:07:09,419 --> 00:07:14,129
right like you saw before in the example

00:07:12,449 --> 00:07:15,479
we have this you know scalar and and

00:07:14,129 --> 00:07:16,710
scalar or and obviously these

00:07:15,479 --> 00:07:19,830
instructions are going to be very

00:07:16,710 --> 00:07:21,599
similar so we have tools to generate

00:07:19,830 --> 00:07:28,069
these big records that are mostly the

00:07:21,599 --> 00:07:30,960
same in an easy way so this is kind of a

00:07:28,069 --> 00:07:33,509
sketch of the kind of tables and source

00:07:30,960 --> 00:07:37,440
files that live in LLVM and how they

00:07:33,509 --> 00:07:40,139
include each other so the main bulk is

00:07:37,440 --> 00:07:41,909
typically in interest targets back end

00:07:40,139 --> 00:07:44,069
definitions and you usually have one

00:07:41,909 --> 00:07:45,930
top-level file that includes everything

00:07:44,069 --> 00:07:50,219
else because you can have textual

00:07:45,930 --> 00:07:53,639
inclusion but not really include guards

00:07:50,219 --> 00:07:55,440
and also yeah there were some editions

00:07:53,639 --> 00:07:58,639
fairly recently but that's the way

00:07:55,440 --> 00:08:00,810
things work you include all the various

00:07:58,639 --> 00:08:03,180
files in your in your back-end that

00:08:00,810 --> 00:08:05,490
define instruction scheduling and etc

00:08:03,180 --> 00:08:07,889
and you include the target independent

00:08:05,490 --> 00:08:11,159
stuff and the other big chunk is is the

00:08:07,889 --> 00:08:17,330
intrinsic definitions and there is some

00:08:11,159 --> 00:08:19,860
random other things as well all right so

00:08:17,330 --> 00:08:23,219
so much for the very brief overview and

00:08:19,860 --> 00:08:26,250
now I want to go into this tables in

00:08:23,219 --> 00:08:32,430
language features and there is a list of

00:08:26,250 --> 00:08:34,159
them that I want to cover okay so very

00:08:32,430 --> 00:08:36,839
brief look at the types of cements

00:08:34,159 --> 00:08:40,169
fairly standard although I mean a bit

00:08:36,839 --> 00:08:42,570
quirky you have bits and integer types

00:08:40,169 --> 00:08:45,510
the integers are 64 bit only your bit

00:08:42,570 --> 00:08:49,529
sequences you can cast between them you

00:08:45,510 --> 00:08:52,079
can slice bit sequences there is a

00:08:49,529 --> 00:08:54,779
string type there is also a code type

00:08:52,079 --> 00:08:56,970
which is a bit strange but you know

00:08:54,779 --> 00:08:58,829
there is this notation with the square

00:08:56,970 --> 00:08:59,970
and curly brackets to have like a

00:08:58,829 --> 00:09:02,610
convenient way

00:08:59,970 --> 00:09:05,089
to have C++ fragments in your table Jen

00:09:02,610 --> 00:09:09,089
source which then gets pasted into some

00:09:05,089 --> 00:09:10,589
auto-generated larger function really

00:09:09,089 --> 00:09:13,079
you'd only need one time for that but

00:09:10,589 --> 00:09:16,769
whatever there is a list type which is

00:09:13,079 --> 00:09:20,069
you know just a homogeneous list table

00:09:16,769 --> 00:09:22,019
Jen does some some type inference but

00:09:20,069 --> 00:09:25,439
the tables in front end is basically one

00:09:22,019 --> 00:09:27,660
single pass through the source so there

00:09:25,439 --> 00:09:29,250
is no you know like type inferencing

00:09:27,660 --> 00:09:32,459
pass or anything so there are some cases

00:09:29,250 --> 00:09:36,240
where you need to help out and put the

00:09:32,459 --> 00:09:38,730
type in in these angle brackets as the

00:09:36,240 --> 00:09:41,069
second example shows we don't need that

00:09:38,730 --> 00:09:43,500
often but sometimes you need it you can

00:09:41,069 --> 00:09:45,899
index into lists but only with literal

00:09:43,500 --> 00:09:48,720
constants at the moment and then there

00:09:45,899 --> 00:09:51,209
are some other unset tag and and class

00:09:48,720 --> 00:09:54,019
record types that have will explain in

00:09:51,209 --> 00:09:54,019
the next few slides

00:09:55,579 --> 00:10:01,079
okay so unset values this is an

00:09:59,790 --> 00:10:03,209
interesting thing because of course

00:10:01,079 --> 00:10:04,829
usually all the key values like the

00:10:03,209 --> 00:10:07,439
values in your dictionaries in your

00:10:04,829 --> 00:10:09,029
records should be defined right but

00:10:07,439 --> 00:10:11,550
sometimes they're not and there is

00:10:09,029 --> 00:10:14,399
actually one so at the top right you see

00:10:11,550 --> 00:10:18,689
an example of how these variables or

00:10:14,399 --> 00:10:20,579
values can end up and unset both of them

00:10:18,689 --> 00:10:21,689
are unset in the same way one explicitly

00:10:20,579 --> 00:10:24,720
with the question mark the other

00:10:21,689 --> 00:10:26,490
implicitly but there is one nice

00:10:24,720 --> 00:10:29,579
application having to do with

00:10:26,490 --> 00:10:33,029
instruction encoding for having unset

00:10:29,579 --> 00:10:35,220
values on purpose so what you see on the

00:10:33,029 --> 00:10:37,680
left hand side is just a short extract

00:10:35,220 --> 00:10:41,189
of the table gent source of our back end

00:10:37,680 --> 00:10:43,110
which defines one encoding type

00:10:41,189 --> 00:10:46,110
alright so 32-bit instructions and the

00:10:43,110 --> 00:10:47,910
egg 32 it has this instable which is a

00:10:46,110 --> 00:10:50,300
placeholder for the 32 bits of the

00:10:47,910 --> 00:10:54,420
instruction and then there is a an

00:10:50,300 --> 00:10:56,670
encoding called v interp which defines

00:10:54,420 --> 00:10:59,610
the fields of the encoding alright you

00:10:56,670 --> 00:11:01,410
see that the top so the bits 31 to 26

00:10:59,610 --> 00:11:04,589
they're assigned to a constant value

00:11:01,410 --> 00:11:08,040
right that's what defines this encoding

00:11:04,589 --> 00:11:11,370
class and then other bits out of these

00:11:08,040 --> 00:11:12,870
32 are parceled out to variables that

00:11:11,370 --> 00:11:13,410
are they're defined at the top like the

00:11:12,870 --> 00:11:16,110
VDS

00:11:13,410 --> 00:11:18,209
which is just undefined or the the up

00:11:16,110 --> 00:11:19,740
which is the opcode which is actually

00:11:18,209 --> 00:11:24,360
passed in as a kind of a template

00:11:19,740 --> 00:11:26,850
argument to this we interrupt class and

00:11:24,360 --> 00:11:28,680
on the right hand side you see one of

00:11:26,850 --> 00:11:30,629
the machine instructions or the record

00:11:28,680 --> 00:11:34,230
corresponding to it that uses this

00:11:30,629 --> 00:11:36,089
encoding and you see that now this in

00:11:34,230 --> 00:11:38,579
steeled with its 32 bits has been

00:11:36,089 --> 00:11:42,000
expanded so there are there should be

00:11:38,579 --> 00:11:44,220
eight entries in each row there and you

00:11:42,000 --> 00:11:45,839
see that for example in blue the two

00:11:44,220 --> 00:11:48,449
bits that correspond to the opcode have

00:11:45,839 --> 00:11:52,019
been filled in to 0-0 but a lot of the

00:11:48,449 --> 00:11:55,199
other bits actually still refer to these

00:11:52,019 --> 00:12:00,360
fields like Vedas resource etc which are

00:11:55,199 --> 00:12:02,810
just unset bit sequences and the whole

00:12:00,360 --> 00:12:06,600
machinery for instruction encoding and

00:12:02,810 --> 00:12:08,310
disassembly is built based on these

00:12:06,600 --> 00:12:12,029
relations so the relations of which

00:12:08,310 --> 00:12:14,160
fields that defining registers etc are

00:12:12,029 --> 00:12:16,920
where is read out of this and it's also

00:12:14,160 --> 00:12:19,680
tied to you see there the dag out

00:12:16,920 --> 00:12:23,329
operand list for example it mentions the

00:12:19,680 --> 00:12:26,910
name B test which is matched to the

00:12:23,329 --> 00:12:29,550
variable name B test to tie the

00:12:26,910 --> 00:12:36,990
representation of operands in your

00:12:29,550 --> 00:12:39,720
machine instruction to be encoding then

00:12:36,990 --> 00:12:42,240
there is the back type so it's called

00:12:39,720 --> 00:12:43,920
dag like directed as a cyclic graph

00:12:42,240 --> 00:12:45,750
because it's used in instruction

00:12:43,920 --> 00:12:47,459
selection but I think the best way to

00:12:45,750 --> 00:12:50,250
think about it is really that's the kind

00:12:47,459 --> 00:12:52,850
of s expression where you have in an

00:12:50,250 --> 00:12:55,110
operator and then a list of arguments

00:12:52,850 --> 00:12:58,649
except that each of the arguments can

00:12:55,110 --> 00:13:00,930
optionally also be assigned a name it's

00:12:58,649 --> 00:13:01,889
a convenient way of having you know

00:13:00,930 --> 00:13:06,209
heterogenous

00:13:01,889 --> 00:13:07,649
nested structures and like I said most

00:13:06,209 --> 00:13:09,180
it's used for instruction selection

00:13:07,649 --> 00:13:11,550
patterns so there is an example down

00:13:09,180 --> 00:13:15,899
here also from our back end the first

00:13:11,550 --> 00:13:18,870
row in there describes a pattern that is

00:13:15,899 --> 00:13:21,149
looked for in the selection dag and the

00:13:18,870 --> 00:13:23,180
row below is the machine instruction

00:13:21,149 --> 00:13:26,910
that should be generated for that

00:13:23,180 --> 00:13:29,100
pattern and so on the top row you see

00:13:26,910 --> 00:13:32,190
in a thing is an bitwise xor that is

00:13:29,100 --> 00:13:36,300
used once XOR is something that is named

00:13:32,190 --> 00:13:38,760
store 0 with a constant this is then

00:13:36,300 --> 00:13:40,910
converted or interpreted as a 16-bit

00:13:38,760 --> 00:13:44,370
float and convert it to a 32-bit float

00:13:40,910 --> 00:13:46,830
and it so happens if you XOR that value

00:13:44,370 --> 00:13:50,730
to a 16-bit float well it flips the sign

00:13:46,830 --> 00:13:54,060
bit right and in our I saw many

00:13:50,730 --> 00:13:56,490
instructions have the ability to aside

00:13:54,060 --> 00:13:58,140
from whatever else they're doing to flip

00:13:56,490 --> 00:13:59,490
the sign bit right and so we just

00:13:58,140 --> 00:14:02,250
replace it by this conversion

00:13:59,490 --> 00:14:12,000
instruction with the modifier that says

00:14:02,250 --> 00:14:13,500
negate the source right yeah yeah even

00:14:12,000 --> 00:14:15,660
though the name is tag it really more

00:14:13,500 --> 00:14:17,300
represents a tree than a dag so that's

00:14:15,660 --> 00:14:22,020
why I said the name is a bit misleading

00:14:17,300 --> 00:14:23,460
yeah I mean you can't really express the

00:14:22,020 --> 00:14:31,770
dag in the source language with this

00:14:23,460 --> 00:14:33,600
with this syntax alright and and then of

00:14:31,770 --> 00:14:35,340
course there's there's classes right as

00:14:33,600 --> 00:14:39,290
I already said classes are basically

00:14:35,340 --> 00:14:41,400
templates for records they have

00:14:39,290 --> 00:14:43,860
inheritance although I actually don't

00:14:41,400 --> 00:14:45,510
have an example of that here on the

00:14:43,860 --> 00:14:49,290
slide but the syntax is basically the

00:14:45,510 --> 00:14:53,490
same as C++ for the for the inheritance

00:14:49,290 --> 00:14:56,160
and so on the right-hand side right in

00:14:53,490 --> 00:14:58,380
the example above you see some source

00:14:56,160 --> 00:15:01,260
that's not taken from anything real

00:14:58,380 --> 00:15:03,260
that's just a random example and at the

00:15:01,260 --> 00:15:06,540
bottom you have what it's expanded to

00:15:03,260 --> 00:15:08,370
okay so so there are two records that

00:15:06,540 --> 00:15:10,020
are explicitly defined right my record

00:15:08,370 --> 00:15:16,170
derives from both of these classes that

00:15:10,020 --> 00:15:17,940
are defined and I think the main thing

00:15:16,170 --> 00:15:19,320
to point out here is an interesting

00:15:17,940 --> 00:15:22,920
feature which is in the other record

00:15:19,320 --> 00:15:25,110
which has this be angle bracket 3 which

00:15:22,920 --> 00:15:27,180
is actually an anonymous instantiation

00:15:25,110 --> 00:15:29,640
of the class so you see here this you

00:15:27,180 --> 00:15:32,010
know anonymous 0 record which is

00:15:29,640 --> 00:15:34,020
generated automatically which is quite a

00:15:32,010 --> 00:15:35,550
useful feature and the the other thing

00:15:34,020 --> 00:15:37,650
that's interesting to notice that every

00:15:35,550 --> 00:15:39,450
class has an implicit template argument

00:15:37,650 --> 00:15:40,610
called name which is replaced by the

00:15:39,450 --> 00:15:47,720
name of the record that

00:15:40,610 --> 00:15:50,329
being instantiated alright so when you

00:15:47,720 --> 00:15:52,700
know about classes and records it's very

00:15:50,329 --> 00:15:54,649
tempting to try to define all the

00:15:52,700 --> 00:15:56,690
variables in your records as functions

00:15:54,649 --> 00:15:59,750
of template arguments class template

00:15:56,690 --> 00:16:02,570
arguments this works but it tends to

00:15:59,750 --> 00:16:04,100
lead to a design of your tables and

00:16:02,570 --> 00:16:06,019
classes where they have lots and lots of

00:16:04,100 --> 00:16:10,550
template arguments and it becomes a bit

00:16:06,019 --> 00:16:12,890
of a mess for these things it's better

00:16:10,550 --> 00:16:16,760
to use let statements so let statements

00:16:12,890 --> 00:16:18,950
are a way to override values that are

00:16:16,760 --> 00:16:23,120
defined in the classes that you're

00:16:18,950 --> 00:16:24,620
inherit from for example and one very

00:16:23,120 --> 00:16:28,250
interesting thing about this is that

00:16:24,620 --> 00:16:30,320
actually expressions are evaluated late

00:16:28,250 --> 00:16:33,320
so if you have here the class a again on

00:16:30,320 --> 00:16:35,660
the left is an example source it has a

00:16:33,320 --> 00:16:37,550
template P a template are go P is

00:16:35,660 --> 00:16:39,680
assigned to a variable X and then X is

00:16:37,550 --> 00:16:42,019
assigned to Y this assignment doesn't

00:16:39,680 --> 00:16:44,810
happen immediately it's delayed and as

00:16:42,019 --> 00:16:47,600
late as possible which means that below

00:16:44,810 --> 00:16:53,000
when you instantiate a two for example

00:16:47,600 --> 00:16:54,500
and then say let X equal 17 in the fully

00:16:53,000 --> 00:16:57,980
evaluated instantiation on the right

00:16:54,500 --> 00:17:02,240
hand side you see that Y both x and y I

00:16:57,980 --> 00:17:06,020
get this value 17 okay rather than you

00:17:02,240 --> 00:17:07,220
know having you know the value 2 that

00:17:06,020 --> 00:17:10,610
would be implied by the template

00:17:07,220 --> 00:17:11,929
parameter that you passed in it's

00:17:10,610 --> 00:17:13,429
important to remember that the last

00:17:11,929 --> 00:17:15,260
statement is not the one that you know

00:17:13,429 --> 00:17:17,660
from an arrest or functional languages

00:17:15,260 --> 00:17:21,280
it doesn't define a new variable it just

00:17:17,660 --> 00:17:21,280
allows you to override an existing one

00:17:22,089 --> 00:17:29,720
so classes I said are basically

00:17:26,660 --> 00:17:33,590
templates for records multi classes are

00:17:29,720 --> 00:17:35,750
templates for sets of records okay so

00:17:33,590 --> 00:17:38,780
maybe best to look at an example there

00:17:35,750 --> 00:17:41,600
on the on the bottom left this is part

00:17:38,780 --> 00:17:44,570
of a definition of intrinsics we have a

00:17:41,600 --> 00:17:47,690
def M so def M is used to instantiate

00:17:44,570 --> 00:17:49,460
multi classes which is given a name

00:17:47,690 --> 00:17:50,150
which is kind of a base name for

00:17:49,460 --> 00:17:54,020
intrinsics

00:17:50,150 --> 00:17:54,410
am DDC n work group ID it instantiates

00:17:54,020 --> 00:17:56,000
this

00:17:54,410 --> 00:17:57,770
multi-class that is defined above and

00:17:56,000 --> 00:17:59,360
this multi-class defines three records

00:17:57,770 --> 00:18:01,460
with names you know underscore X

00:17:59,360 --> 00:18:04,280
underscore Y underscore Z which are

00:18:01,460 --> 00:18:08,390
concatenated with the base name and each

00:18:04,280 --> 00:18:10,490
of those then inherits from you know

00:18:08,390 --> 00:18:12,950
some class helper class that we defined

00:18:10,490 --> 00:18:14,840
which in turn derives from a target

00:18:12,950 --> 00:18:16,700
independent intrinsic class which means

00:18:14,840 --> 00:18:21,220
that we're defining intrinsics here so

00:18:16,700 --> 00:18:23,990
we're defining three records and at once

00:18:21,220 --> 00:18:26,780
like classes multi classes have this

00:18:23,990 --> 00:18:28,370
implicit name argument so by default the

00:18:26,780 --> 00:18:29,780
names that are instantiated are just

00:18:28,370 --> 00:18:32,510
like the base name that comes from the

00:18:29,780 --> 00:18:34,100
DEF in the FM concatenated from the name

00:18:32,510 --> 00:18:36,110
that the record has inside the multi

00:18:34,100 --> 00:18:37,460
class but you can play around with this

00:18:36,110 --> 00:18:39,740
like the example on the right hand side

00:18:37,460 --> 00:18:42,890
shows if you look at this def of the rec

00:18:39,740 --> 00:18:44,780
3 the rectory is actually prefixed to

00:18:42,890 --> 00:18:47,210
the base name so the rule is that if you

00:18:44,780 --> 00:18:50,540
explicitly mention the name template

00:18:47,210 --> 00:18:53,950
argument then that overrides the default

00:18:50,540 --> 00:18:56,960
concatenation that can be useful in some

00:18:53,950 --> 00:18:59,600
in some Isis where you have like

00:18:56,960 --> 00:19:03,130
instruction families where some of the

00:18:59,600 --> 00:19:05,510
instructions are prefixed with something

00:19:03,130 --> 00:19:07,220
there's some interesting corner cases so

00:19:05,510 --> 00:19:09,080
interestingly multi classes also support

00:19:07,220 --> 00:19:12,320
inheritance from other multi classes

00:19:09,080 --> 00:19:14,750
which is really basically the same as

00:19:12,320 --> 00:19:16,220
just putting a def m of the base multi

00:19:14,750 --> 00:19:17,840
class as I've shown there while

00:19:16,220 --> 00:19:21,620
preparing the slides I noticed that

00:19:17,840 --> 00:19:26,240
that's not entirely true and maybe that

00:19:21,620 --> 00:19:29,180
should be changed but yeah if you have a

00:19:26,240 --> 00:19:31,100
def M so the DEF M instance is a multi

00:19:29,180 --> 00:19:33,380
class right but it can also actually

00:19:31,100 --> 00:19:34,880
inherit from classes which can be useful

00:19:33,380 --> 00:19:36,350
for tagging the records that you're

00:19:34,880 --> 00:19:39,070
instantiated with something like

00:19:36,350 --> 00:19:41,540
instruction mappings and stuff like that

00:19:39,070 --> 00:19:46,490
but it cannot have a body so if you want

00:19:41,540 --> 00:19:49,160
to override anything that that is you

00:19:46,490 --> 00:19:50,540
know any variable that is defined in the

00:19:49,160 --> 00:19:54,770
records that you instantiate you need to

00:19:50,540 --> 00:19:58,250
use global edge statements okay so multi

00:19:54,770 --> 00:19:59,990
class is one way of generating many

00:19:58,250 --> 00:20:02,300
regular records there is another way of

00:19:59,990 --> 00:20:04,220
doing that which is for each and for

00:20:02,300 --> 00:20:05,690
each is yeah is it's it's a for each

00:20:04,220 --> 00:20:07,670
loop like you loop over a list or a

00:20:05,690 --> 00:20:09,240
range of integers so there is nothing

00:20:07,670 --> 00:20:10,800
too special

00:20:09,240 --> 00:20:12,390
in case I haven't mentioned it here in

00:20:10,800 --> 00:20:15,060
the example at the top you know that the

00:20:12,390 --> 00:20:17,490
hash is a concatenation operator string

00:20:15,060 --> 00:20:19,650
concatenation just good to know and

00:20:17,490 --> 00:20:21,750
there is also this exclamation mark ad

00:20:19,650 --> 00:20:24,510
which is a built-in function to add

00:20:21,750 --> 00:20:26,250
integers this is just part of the

00:20:24,510 --> 00:20:26,640
encoding of the register in the in the

00:20:26,250 --> 00:20:29,160
eisah

00:20:26,640 --> 00:20:30,920
one interesting thing about for each is

00:20:29,160 --> 00:20:35,520
that you can use it as an if statement

00:20:30,920 --> 00:20:38,880
so this is an example from from our

00:20:35,520 --> 00:20:40,350
back-end as well so we have a family of

00:20:38,880 --> 00:20:42,540
instructions I recall just one

00:20:40,350 --> 00:20:44,760
instructions and they have multiple

00:20:42,540 --> 00:20:48,290
incarnations right they have the basic

00:20:44,760 --> 00:20:50,790
ether T to pop one there is an extended

00:20:48,290 --> 00:20:52,590
64-bit encoding there's something that

00:20:50,790 --> 00:20:54,840
has a feature called SDWA

00:20:52,590 --> 00:20:57,060
for all of them but then for some of

00:20:54,840 --> 00:21:00,570
them there is also an incarnation that

00:20:57,060 --> 00:21:02,790
uses a feature called DPP and now if you

00:21:00,570 --> 00:21:04,380
have a class of instructions that is

00:21:02,790 --> 00:21:06,540
regular in that way except for this one

00:21:04,380 --> 00:21:09,090
thing you have multiple options for

00:21:06,540 --> 00:21:10,890
realizing that in table generate one way

00:21:09,090 --> 00:21:12,660
would be to just have different multi

00:21:10,890 --> 00:21:14,340
classes right multi class for what one

00:21:12,660 --> 00:21:17,250
width and multi class for what one

00:21:14,340 --> 00:21:18,660
without the problem is with this kind of

00:21:17,250 --> 00:21:20,700
approach that you can easily get a

00:21:18,660 --> 00:21:25,260
combinatorial explosion of multi classes

00:21:20,700 --> 00:21:28,860
so what we do here instead is this this

00:21:25,260 --> 00:21:30,990
if statement basically so we have this

00:21:28,860 --> 00:21:32,940
notion of a bob profile which is passed

00:21:30,990 --> 00:21:36,810
as a template argument to the multi

00:21:32,940 --> 00:21:38,040
class and it has a bit that tells us

00:21:36,810 --> 00:21:40,380
whether the instruction should have this

00:21:38,040 --> 00:21:41,670
TPP or not and then there is an

00:21:40,380 --> 00:21:44,490
interesting pattern here which is

00:21:41,670 --> 00:21:46,950
basically using table gen classes as

00:21:44,490 --> 00:21:50,490
functions right this bool to list class

00:21:46,950 --> 00:21:53,550
it takes this bit value as a as an

00:21:50,490 --> 00:21:55,860
argument and then it has a variable

00:21:53,550 --> 00:21:59,220
called ret which is the return value of

00:21:55,860 --> 00:22:00,870
the function that we're defining and you

00:21:59,220 --> 00:22:03,750
know if the bit is 0 then it will return

00:22:00,870 --> 00:22:05,880
an empty list which means that the for

00:22:03,750 --> 00:22:08,340
each will not do nothing or we return a

00:22:05,880 --> 00:22:10,500
one element list and the for each will

00:22:08,340 --> 00:22:12,870
do something so that's that's a pattern

00:22:10,500 --> 00:22:18,600
that we use quite extensively and it's

00:22:12,870 --> 00:22:21,090
quite useful yeah for each versus multi

00:22:18,600 --> 00:22:22,140
class both of them serve kind of similar

00:22:21,090 --> 00:22:23,760
purposes

00:22:22,140 --> 00:22:26,160
I would say that multi class is more

00:22:23,760 --> 00:22:28,590
idiomatic for table Jen and it's often

00:22:26,160 --> 00:22:31,320
easier to reuse but for each has some

00:22:28,590 --> 00:22:33,630
programmability advantages so both have

00:22:31,320 --> 00:22:39,930
their place and use them as it makes

00:22:33,630 --> 00:22:42,420
sense another kind of nice feature is a

00:22:39,930 --> 00:22:45,330
deaf set which as the example on the top

00:22:42,420 --> 00:22:49,800
right shows you allows you to capture

00:22:45,330 --> 00:22:52,290
all the records that are defined inside

00:22:49,800 --> 00:22:54,780
you know the outer curly braces into a

00:22:52,290 --> 00:22:57,420
list that you can then later reference

00:22:54,780 --> 00:23:05,150
and use in a for each for example to

00:22:57,420 --> 00:23:07,980
iterate over them we use this in AMD GPU

00:23:05,150 --> 00:23:11,610
to define for these intrinsics that are

00:23:07,980 --> 00:23:15,270
up there a generic table so generic

00:23:11,610 --> 00:23:20,130
table is generic searchable tables is

00:23:15,270 --> 00:23:23,310
one back-end that is a fairly versatile

00:23:20,130 --> 00:23:25,050
way of exporting data out of tables and

00:23:23,310 --> 00:23:27,210
without writing your own custom back-end

00:23:25,050 --> 00:23:28,800
so what's happening here is that we just

00:23:27,210 --> 00:23:30,270
define a generic table and you really

00:23:28,800 --> 00:23:34,110
should think of it as like a database

00:23:30,270 --> 00:23:37,080
table which is called resource

00:23:34,110 --> 00:23:40,650
intrinsics the fields are listed there

00:23:37,080 --> 00:23:44,490
you know three fields the rows of the

00:23:40,650 --> 00:23:49,350
table come from records that are derived

00:23:44,490 --> 00:23:51,900
from the given filter class and a table

00:23:49,350 --> 00:23:56,670
gen the the searchable tables back-end

00:23:51,900 --> 00:23:59,760
will give you a function which you pass

00:23:56,670 --> 00:24:02,720
in a a key of your choice and it will

00:23:59,760 --> 00:24:05,880
search the table and produce the

00:24:02,720 --> 00:24:08,100
corresponding struct if it exists and

00:24:05,880 --> 00:24:10,530
you can actually also define multiple

00:24:08,100 --> 00:24:13,440
keys over generic tables which is nice

00:24:10,530 --> 00:24:17,070
for mapping from between two things back

00:24:13,440 --> 00:24:20,130
and forth in both directions so so here

00:24:17,070 --> 00:24:22,980
we use the for each based on lists that

00:24:20,130 --> 00:24:26,130
we previously captured to define the

00:24:22,980 --> 00:24:27,990
rows of this table and now again you

00:24:26,130 --> 00:24:29,220
might ask so def set is really it's

00:24:27,990 --> 00:24:31,020
really an issue Peter and even though I

00:24:29,220 --> 00:24:33,450
added in myself I have to say that it's

00:24:31,020 --> 00:24:35,549
not very idiomatic for table Jen in most

00:24:33,450 --> 00:24:39,090
cases you'll probably want to

00:24:35,549 --> 00:24:40,860
instead use like multi classes or

00:24:39,090 --> 00:24:43,519
possibly heterogeneous multi classes

00:24:40,860 --> 00:24:45,840
where you define maybe some intrinsic

00:24:43,519 --> 00:24:48,929
sorry some instruct machine instructions

00:24:45,840 --> 00:24:51,629
and then some other class maybe for

00:24:48,929 --> 00:24:53,340
those tables at the same time but in

00:24:51,629 --> 00:24:54,929
this particular case so something

00:24:53,340 --> 00:24:57,239
interesting happens right because the

00:24:54,929 --> 00:24:59,879
intrinsics are defined in target

00:24:57,239 --> 00:25:02,210
independent tables and sources which are

00:24:59,879 --> 00:25:05,450
included by all backends by all targets

00:25:02,210 --> 00:25:07,889
right and they have to be defined there

00:25:05,450 --> 00:25:09,809
because it's a global enum that is the

00:25:07,889 --> 00:25:14,249
same for all targets it's not target

00:25:09,809 --> 00:25:15,720
specific but the table like if we were

00:25:14,249 --> 00:25:17,940
to define the table in the same place

00:25:15,720 --> 00:25:19,559
then every target would get this this

00:25:17,940 --> 00:25:21,720
table which is really specific to our

00:25:19,559 --> 00:25:25,649
back-end right that that doesn't make

00:25:21,720 --> 00:25:30,659
sense so instead we do this separation

00:25:25,649 --> 00:25:32,730
using the deficit feature we already saw

00:25:30,659 --> 00:25:34,109
one built-in function this exclamation

00:25:32,730 --> 00:25:38,700
mark ad there are a whole bunch of

00:25:34,109 --> 00:25:40,859
others the the most interesting ones are

00:25:38,700 --> 00:25:42,899
probably the castes so you are able to

00:25:40,859 --> 00:25:45,749
cast between strings and records

00:25:42,899 --> 00:25:46,950
actually which means that if you cast a

00:25:45,749 --> 00:25:49,409
record to a string it gives you the name

00:25:46,950 --> 00:25:50,970
if you cast a string to a record then it

00:25:49,409 --> 00:25:52,409
looks for a record of that name and

00:25:50,970 --> 00:25:55,850
gives it back to you if it has been

00:25:52,409 --> 00:26:00,299
defined previously in the source file

00:25:55,850 --> 00:26:03,299
and and then so there is for each which

00:26:00,299 --> 00:26:04,529
is basically a map function is what it

00:26:03,299 --> 00:26:06,480
would be called in like Haskell or

00:26:04,529 --> 00:26:12,269
something and there is a left fold which

00:26:06,480 --> 00:26:14,879
is also nice to have alright so this is

00:26:12,269 --> 00:26:19,019
what we went over we went over most of

00:26:14,879 --> 00:26:21,350
the stuff now I said we could maybe do a

00:26:19,019 --> 00:26:24,389
deep dive into some more advanced

00:26:21,350 --> 00:26:25,769
application of table Jen if we have the

00:26:24,389 --> 00:26:33,960
time we don't have that much time

00:26:25,769 --> 00:26:36,330
anymore so I wonder which part might be

00:26:33,960 --> 00:26:38,429
best to fit so we have this very complex

00:26:36,330 --> 00:26:42,929
family of intrinsic for image operations

00:26:38,429 --> 00:26:45,210
in our back end right there is a lot of

00:26:42,929 --> 00:26:46,679
orthogonality here where part of these

00:26:45,210 --> 00:26:48,720
image instructions is the dimensionality

00:26:46,679 --> 00:26:52,230
of the image right if it's 1d to the

00:26:48,720 --> 00:26:54,120
to D and then the arguments of the

00:26:52,230 --> 00:26:55,890
intrinsic depends on that dimensionality

00:26:54,120 --> 00:26:58,020
of course it's either only an S

00:26:55,890 --> 00:26:59,789
coordinate or it's an S and a tea and a

00:26:58,020 --> 00:27:03,150
slice in the array or it's just an SMT

00:26:59,789 --> 00:27:04,890
etc you may have this dot D which stands

00:27:03,150 --> 00:27:06,659
for partial derivatives in which case

00:27:04,890 --> 00:27:09,270
you have all this green you know D s

00:27:06,659 --> 00:27:10,559
over d HD T over the H which are partial

00:27:09,270 --> 00:27:16,100
derivatives of coordinates with respect

00:27:10,559 --> 00:27:18,330
to screen coordinates and and this this

00:27:16,100 --> 00:27:21,570
really large number of intrinsics we

00:27:18,330 --> 00:27:27,960
want to define some way and and we do

00:27:21,570 --> 00:27:31,500
all of this in in table gen so you get

00:27:27,960 --> 00:27:34,230
code like this which at the bottom left

00:27:31,500 --> 00:27:38,520
you see it defines the notion of a 2d

00:27:34,230 --> 00:27:40,620
array dimensionality of an image gives

00:27:38,520 --> 00:27:42,210
it a name to the array and says okay

00:27:40,620 --> 00:27:44,159
there are two coordinates that are

00:27:42,210 --> 00:27:47,220
relevant for derivatives namely s and T

00:27:44,159 --> 00:27:51,150
and one coordinate which isn't and then

00:27:47,220 --> 00:27:53,820
in this this class that we define above

00:27:51,150 --> 00:27:55,830
we define a variable gradient args which

00:27:53,820 --> 00:27:58,590
is the list of gradient arguments for

00:27:55,830 --> 00:28:00,780
intrinsics that need them which are

00:27:58,590 --> 00:28:02,549
defined basically using function calls

00:28:00,780 --> 00:28:04,679
right we first iterate over the given

00:28:02,549 --> 00:28:06,780
coordinate names and use string

00:28:04,679 --> 00:28:10,890
concatenation to define these names the

00:28:06,780 --> 00:28:12,720
sdh etc and then we pass that to that

00:28:10,890 --> 00:28:14,640
class which has really a roll of a

00:28:12,720 --> 00:28:17,220
function which is defined above make

00:28:14,640 --> 00:28:20,370
argument list and it produces what is

00:28:17,220 --> 00:28:21,990
there on the right in the box so why do

00:28:20,370 --> 00:28:25,190
we want so what is that that we have on

00:28:21,990 --> 00:28:27,600
the right and why do we want it well

00:28:25,190 --> 00:28:30,299
when we define intrinsics we have to

00:28:27,600 --> 00:28:33,570
define the types of the arguments of the

00:28:30,299 --> 00:28:36,000
intrinsics right and there are we can

00:28:33,570 --> 00:28:39,659
give a type explicitly such as 32-bit

00:28:36,000 --> 00:28:42,030
float but we actually want to be able to

00:28:39,659 --> 00:28:45,539
pass not just 32-bit floats but also

00:28:42,030 --> 00:28:49,429
half precision floats so we need an any

00:28:45,539 --> 00:28:51,809
float type for the D sdh argument and

00:28:49,429 --> 00:28:55,530
then the arguments that come after that

00:28:51,809 --> 00:28:57,690
should be constrained by the IR verifier

00:28:55,530 --> 00:29:00,909
to be of the same type so that's what

00:28:57,690 --> 00:29:02,649
the LLVM match type is for

00:29:00,909 --> 00:29:04,809
and what this make argument list

00:29:02,649 --> 00:29:07,239
function does is is precisely generate

00:29:04,809 --> 00:29:08,919
an array of this form by taking you know

00:29:07,239 --> 00:29:10,629
the first name combining it with the

00:29:08,919 --> 00:29:12,940
base type and then doing a mapping which

00:29:10,629 --> 00:29:18,059
maps all the names to this AMD GPU are

00:29:12,940 --> 00:29:20,769
care of match type and an argument name

00:29:18,059 --> 00:29:26,590
okay and any questions about this this

00:29:20,769 --> 00:29:28,210
is a lot of - oh those are things that

00:29:26,590 --> 00:29:29,799
we use it we don't use them for much

00:29:28,210 --> 00:29:31,419
internally they're convenient for

00:29:29,799 --> 00:29:35,580
debugging and I've plans for other

00:29:31,419 --> 00:29:35,580
things that we can do with them but yeah

00:29:36,869 --> 00:29:44,950
all right other other questions about

00:29:42,070 --> 00:29:50,349
this I will upload the slides of course

00:29:44,950 --> 00:29:52,269
you can look at it later we do more

00:29:50,349 --> 00:29:53,889
stuff like this so for example if you

00:29:52,269 --> 00:29:56,229
have if you have two of these arrays of

00:29:53,889 --> 00:29:58,389
arguments you need to and all of them

00:29:56,229 --> 00:30:00,009
use oliviere match types you need to

00:29:58,389 --> 00:30:01,869
adjust the index that the match type

00:30:00,009 --> 00:30:03,729
refers to that's what that stuff is

00:30:01,869 --> 00:30:05,440
about especially that stuff on that

00:30:03,729 --> 00:30:09,549
slide but that we don't really have the

00:30:05,440 --> 00:30:11,830
time to look at it in detail all right

00:30:09,549 --> 00:30:13,869
so I just want to close with some final

00:30:11,830 --> 00:30:15,549
thoughts maybe a brief look at what we

00:30:13,869 --> 00:30:15,909
covered you know a brief overview table

00:30:15,549 --> 00:30:18,609
Jen

00:30:15,909 --> 00:30:20,759
quick run-through of pretty much all the

00:30:18,609 --> 00:30:22,809
features of the front end language

00:30:20,759 --> 00:30:26,739
except the built-in functions not in

00:30:22,809 --> 00:30:30,789
detail and and a brief example of of

00:30:26,739 --> 00:30:32,859
what you can use what you can do with it

00:30:30,789 --> 00:30:34,359
you know some some things to keep in

00:30:32,859 --> 00:30:37,599
mind you know multi class versus for

00:30:34,359 --> 00:30:38,889
each calling table table Jen directly if

00:30:37,599 --> 00:30:41,559
you have problems to dump all the

00:30:38,889 --> 00:30:46,359
records these are kind of things that I

00:30:41,559 --> 00:30:48,159
think you should take home some possible

00:30:46,359 --> 00:30:49,749
things to improve in tables and in the

00:30:48,159 --> 00:30:52,539
future I'm not going to work on them

00:30:49,749 --> 00:30:54,309
because well priorities just aren't like

00:30:52,539 --> 00:30:55,749
that but there are still some cleanups

00:30:54,309 --> 00:30:59,649
that could be done in the in the type

00:30:55,749 --> 00:31:02,499
system right to smooth some of these

00:30:59,649 --> 00:31:04,749
corner cases it will be convenient to

00:31:02,499 --> 00:31:06,789
have the the hash operator not just work

00:31:04,749 --> 00:31:09,940
for Strings but also for lists and and

00:31:06,789 --> 00:31:11,529
tags that would be a convenient the

00:31:09,940 --> 00:31:14,410
thing with multi class inheritance that

00:31:11,529 --> 00:31:16,510
I mentioned and then you know

00:31:14,410 --> 00:31:18,850
backends I mean it used to be like last

00:31:16,510 --> 00:31:20,230
year when I when I started diving deep

00:31:18,850 --> 00:31:21,730
into tables and my problem was that I

00:31:20,230 --> 00:31:23,980
always ran into crashes and errors in

00:31:21,730 --> 00:31:25,510
the front end this at least for me this

00:31:23,980 --> 00:31:28,630
doesn't happen anymore if it happens for

00:31:25,510 --> 00:31:31,900
you to talk to me but now the problem is

00:31:28,630 --> 00:31:33,820
that the main problem is that I do

00:31:31,900 --> 00:31:35,560
something with selection bag you know

00:31:33,820 --> 00:31:37,000
the I sales patterns and I just get

00:31:35,560 --> 00:31:38,410
weird error messages that are super

00:31:37,000 --> 00:31:40,090
difficult to understand at least for me

00:31:38,410 --> 00:31:42,490
and I think there are some things there

00:31:40,090 --> 00:31:45,250
that are also in the feature set that

00:31:42,490 --> 00:31:47,530
could maybe be more orthogonal but yeah

00:31:45,250 --> 00:31:49,450
that's that would be something probably

00:31:47,530 --> 00:31:53,510
another big project and not for this

00:31:49,450 --> 00:32:02,089
talk so with that thank you very much

00:31:53,510 --> 00:32:02,089
[Applause]

00:32:19,680 --> 00:32:26,050
okay so the question is can you I said

00:32:22,660 --> 00:32:28,900
you can run tabled in itself too so you

00:32:26,050 --> 00:32:36,550
can dump the records can you then go

00:32:28,900 --> 00:32:38,380
from there to the to the generating so

00:32:36,550 --> 00:32:39,790
of course you can go to the generated

00:32:38,380 --> 00:32:42,070
include files directly by just invoking

00:32:39,790 --> 00:32:43,620
the backend directly but if you want to

00:32:42,070 --> 00:32:49,660
like edit the stuff that's in between

00:32:43,620 --> 00:32:51,400
that's currently not possible because so

00:32:49,660 --> 00:32:53,680
you could just cut out the record

00:32:51,400 --> 00:32:56,920
definitions and feed them back into

00:32:53,680 --> 00:32:58,570
table Jen as input I think there there

00:32:56,920 --> 00:33:00,850
are two problems that you run into one

00:32:58,570 --> 00:33:03,850
problem is that I don't think the output

00:33:00,850 --> 00:33:06,580
of the dump is is in like you have to

00:33:03,850 --> 00:33:08,500
define a variable before you refer to it

00:33:06,580 --> 00:33:10,360
and I don't think the dumping makes sure

00:33:08,500 --> 00:33:12,730
to preserve that order I think it just

00:33:10,360 --> 00:33:14,620
dumps alphabetically that's one thing

00:33:12,730 --> 00:33:16,360
the other thing is that the backends

00:33:14,620 --> 00:33:18,280
filter the records out based on the

00:33:16,360 --> 00:33:19,810
classes that they inherit and the way

00:33:18,280 --> 00:33:21,760
that the records are done currently you

00:33:19,810 --> 00:33:24,100
get the information of the the

00:33:21,760 --> 00:33:26,770
inheritance in a comment and not as

00:33:24,100 --> 00:33:27,820
actual you know inheritance in the

00:33:26,770 --> 00:33:29,080
tables in language

00:33:27,820 --> 00:33:40,059
so I think those would be the two major

00:33:29,080 --> 00:33:41,799
hurdles to enable that yeah so you

00:33:40,059 --> 00:33:44,350
obviously can generate other stuff than

00:33:41,799 --> 00:33:46,720
C++ from a back-end and in fact somebody

00:33:44,350 --> 00:33:50,529
not so long ago added a back-end that

00:33:46,720 --> 00:33:53,919
dumps the records in JSON format so you

00:33:50,529 --> 00:33:57,519
know you could then use some other some

00:33:53,919 --> 00:34:00,759
other tool but yeah you could dump other

00:33:57,519 --> 00:34:03,029
things then other things and suppose

00:34:00,759 --> 00:34:05,320
plus if you wanted to yeah yeah

00:34:03,029 --> 00:34:22,960
but the backends are written in C++ you

00:34:05,320 --> 00:34:25,990
can do whatever the question was I out

00:34:22,960 --> 00:34:27,849
how you can kind of abuse classes as as

00:34:25,990 --> 00:34:30,879
functions and wouldn't it be better to

00:34:27,849 --> 00:34:33,190
have a dedicated syntax for that I been

00:34:30,879 --> 00:34:36,040
I've thought about this myself

00:34:33,190 --> 00:34:38,649
I didn't back when I did all this work I

00:34:36,040 --> 00:34:44,230
didn't find a solution to it that I was

00:34:38,649 --> 00:34:45,549
completely convinced off but it's it's

00:34:44,230 --> 00:34:50,230
certainly something to think about you

00:34:45,549 --> 00:34:52,659
know maybe maybe there maybe keep keep

00:34:50,230 --> 00:34:56,290
it as classes but allow invoking it with

00:34:52,659 --> 00:34:58,319
the exclamation mark syntax to make it

00:34:56,290 --> 00:35:02,760
at least a little bit more approachable

00:34:58,319 --> 00:35:02,760
I mean

00:35:18,540 --> 00:35:26,320
yeah it might it might help the

00:35:22,210 --> 00:35:28,920
understandability but yeah to have a

00:35:26,320 --> 00:35:34,120
like a dedicated defined function syntax

00:35:28,920 --> 00:35:36,730
you it's it's it's a thought that I was

00:35:34,120 --> 00:35:38,800
also thinking about this but it would

00:35:36,730 --> 00:35:42,250
have to be because because this pattern

00:35:38,800 --> 00:35:43,720
isn't so isn't used that often today so

00:35:42,250 --> 00:35:46,090
so it would have to be something that's

00:35:43,720 --> 00:35:50,460
very intuitive but also fit well with

00:35:46,090 --> 00:35:50,460
the other stuff in table Jensen I mean

00:36:10,680 --> 00:36:15,100
yeah so the question was is there scope

00:36:13,180 --> 00:36:18,880
to to add better documentation or

00:36:15,100 --> 00:36:21,370
tutorial to LVN I wish I had the time

00:36:18,880 --> 00:36:23,560
you know I started a series of blog

00:36:21,370 --> 00:36:25,360
posts on my blog where the idea was that

00:36:23,560 --> 00:36:27,790
maybe that could one day lead to

00:36:25,360 --> 00:36:34,710
something like that but then I just like

00:36:27,790 --> 00:36:37,930
yeah it's the problem of time yeah yeah

00:36:34,710 --> 00:36:41,460
this tables and turing-complete not

00:36:37,930 --> 00:36:43,990
intentionally I don't know I don't know

00:36:41,460 --> 00:36:45,640
so so there are some places like you

00:36:43,990 --> 00:36:47,410
know with the with these function calls

00:36:45,640 --> 00:36:50,200
and everything where the question

00:36:47,410 --> 00:36:51,850
actually arises but at least last year

00:36:50,200 --> 00:36:55,210
whenever I was at a point where I

00:36:51,850 --> 00:36:56,980
thought well maybe it would be nice to

00:36:55,210 --> 00:36:59,710
have arbitrary recursion or something in

00:36:56,980 --> 00:37:02,980
there I went the way of not adding it so

00:36:59,710 --> 00:37:08,350
I don't think it is but maybe you will

00:37:02,980 --> 00:37:12,730
prove me wrong so you can there is a

00:37:08,350 --> 00:37:16,330
very limited scope for self references

00:37:12,730 --> 00:37:21,580
in that when you define a record you can

00:37:16,330 --> 00:37:23,440
define a variable which you assign a

00:37:21,580 --> 00:37:23,900
cast from the name of the record and

00:37:23,440 --> 00:37:25,640
then

00:37:23,900 --> 00:37:30,380
record will contain a reference to

00:37:25,640 --> 00:37:32,539
itself that is the only way like that

00:37:30,380 --> 00:37:34,670
was stuff like that was actually being

00:37:32,539 --> 00:37:44,890
used in existing table Jen when I

00:37:34,670 --> 00:37:48,859
started looking yeah I mean go ahead

00:37:44,890 --> 00:37:52,970
next next for them you present table

00:37:48,859 --> 00:37:55,069
Dennis turing-complete yeah yeah I don't

00:37:52,970 --> 00:38:01,299
think so but I would not be super

00:37:55,069 --> 00:38:12,619
surprised if it were other questions

00:38:01,299 --> 00:38:14,660
yeah yeah because I was lazy and there

00:38:12,619 --> 00:38:16,250
were at the time that I first thought

00:38:14,660 --> 00:38:18,650
about it there was like one place where

00:38:16,250 --> 00:38:20,779
I wanted to use it by now I think there

00:38:18,650 --> 00:38:24,140
are a few more places where it's used so

00:38:20,779 --> 00:38:27,890
maybe maybe yeah oh sorry the question

00:38:24,140 --> 00:38:29,089
was I I showed how to abuse for each as

00:38:27,890 --> 00:38:30,650
an if statement and the question was

00:38:29,089 --> 00:38:32,779
whether maybe there should be an

00:38:30,650 --> 00:38:41,000
actually statement in the table in

00:38:32,779 --> 00:38:45,619
foreign language or for textual

00:38:41,000 --> 00:38:47,180
conditional parsing yeah yeah I don't

00:38:45,619 --> 00:38:49,099
think that would know that that's very

00:38:47,180 --> 00:38:51,520
far away from from the kind of thing

00:38:49,099 --> 00:38:51,520
that I don't

00:38:54,770 --> 00:39:00,449

YouTube URL: https://www.youtube.com/watch?v=45gmF77JFBY


