Title: HWallet: The simplest Bitcoin hardware wallet
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Nemanja Nikodijevic

At: FOSDEM 2019
https://video.fosdem.org/2019/H.1302/hwallet.webm


All major cryptocurrency hardware wallets on the market either use general purpose microcontrollers that are never meant to be used as secure devices or break the Kerckhoffs's principle by using chips that require an NDA, thus making it impossible to completely release the source code. HWallet (https://gitlab.com/nemanjan/hwallet) is a project developed as a proof of concept to show that it is possible to have a very secure microcontroller, signing Bitcoin transactions in hardware and still be completely open source. The code is released under GPLv3 and is meant to serve as the basis for some future devices or projects aiming to connect the real world to blockchain. This talk will give a brief introduction to the project and describe ways for it's customization. 

Room: H.1302 (Depage)
Scheduled start: 2019-02-03 13:00:00+01
Captions: 
	00:00:15,259 --> 00:00:24,660
all right so next talk is from pneumonia

00:00:19,259 --> 00:00:26,520
Nico de vich sorry famous for its about

00:00:24,660 --> 00:00:34,020
H wallet was simply a Bitcoin how about

00:00:26,520 --> 00:00:36,149
it thank you yeah okay so contrary to

00:00:34,020 --> 00:00:38,160
what you expect it's probably not going

00:00:36,149 --> 00:00:39,989
to be a talk about blockchain it's more

00:00:38,160 --> 00:00:53,699
going to be talk about secure hardware

00:00:39,989 --> 00:00:56,309
so okay yeah so it's gonna be talk about

00:00:53,699 --> 00:00:57,960
secure hardware and I already since I

00:00:56,309 --> 00:00:59,940
already gave a talk with the same slides

00:00:57,960 --> 00:01:01,379
I didn't change the rap these slides you

00:00:59,940 --> 00:01:05,070
can already find this talk on youtube so

00:01:01,379 --> 00:01:06,690
I want to to move it a bit to to in a

00:01:05,070 --> 00:01:10,050
bit other direction I will go through

00:01:06,690 --> 00:01:12,750
slides of course but first I want to say

00:01:10,050 --> 00:01:14,460
that from all the promises that we got

00:01:12,750 --> 00:01:16,470
from blockchain I know some people are

00:01:14,460 --> 00:01:19,290
gonna throw tomatoes at me but save it

00:01:16,470 --> 00:01:21,090
please for later from all the promises

00:01:19,290 --> 00:01:22,440
we we heard about what chain if it's

00:01:21,090 --> 00:01:24,780
going to save the world it's got a pure

00:01:22,440 --> 00:01:28,800
cancer and everything I believe that

00:01:24,780 --> 00:01:31,170
there are only two visible benefits for

00:01:28,800 --> 00:01:32,400
the whole community for the for the

00:01:31,170 --> 00:01:35,850
general public

00:01:32,400 --> 00:01:39,930
first of all mining hardware can be

00:01:35,850 --> 00:01:42,240
reused for AI and second advancement in

00:01:39,930 --> 00:01:48,000
open source secure hardware will

00:01:42,240 --> 00:01:51,780
probably lead to growth in usage of u2f

00:01:48,000 --> 00:01:55,140
tokens which will increase security of

00:01:51,780 --> 00:01:58,860
your accounts on various online services

00:01:55,140 --> 00:02:02,070
but let's move on with the talk and then

00:01:58,860 --> 00:02:04,500
later I would also like to hear your

00:02:02,070 --> 00:02:07,410
opinion about what is a Hardware wallet

00:02:04,500 --> 00:02:09,090
because when I gave this talk at other

00:02:07,410 --> 00:02:11,519
places some people approached me later

00:02:09,090 --> 00:02:13,379
asking me telling me actually they did

00:02:11,519 --> 00:02:16,409
they disagree with me and then Hardware

00:02:13,379 --> 00:02:17,969
wallet is not the just something that I

00:02:16,409 --> 00:02:18,510
believe the hard wallet is some people

00:02:17,969 --> 00:02:20,700
told me why

00:02:18,510 --> 00:02:22,500
yeah but it's also you know saying

00:02:20,700 --> 00:02:26,370
harder wallet is kind of for pleonasm

00:02:22,500 --> 00:02:30,360
because wallet itself is hardware right

00:02:26,370 --> 00:02:31,800
so they say yeah also like using a smart

00:02:30,360 --> 00:02:34,680
card would be a harder wallet for

00:02:31,800 --> 00:02:37,050
bitcoins and so yeah true but you don't

00:02:34,680 --> 00:02:39,480
have a screen so you don't have you are

00:02:37,050 --> 00:02:43,170
not sure what is actually being signed

00:02:39,480 --> 00:02:44,549
on that hardware and I would I would

00:02:43,170 --> 00:02:46,650
really like to hear later if anyone else

00:02:44,549 --> 00:02:48,360
has has other opinions what actually

00:02:46,650 --> 00:02:52,319
hardware wallet is and what it should be

00:02:48,360 --> 00:02:55,760
but let's move on with with five noun so

00:02:52,319 --> 00:02:59,190
there were vulnerabilities in almost all

00:02:55,760 --> 00:03:02,099
widely used hardware wallets so there

00:02:59,190 --> 00:03:06,750
was a really interesting talk at the

00:03:02,099 --> 00:03:10,650
last ccc the where security researchers

00:03:06,750 --> 00:03:13,170
gave really broad array of attacks

00:03:10,650 --> 00:03:15,930
showed a really broad array of attacks

00:03:13,170 --> 00:03:17,430
on these horrible it's so that for

00:03:15,930 --> 00:03:21,660
example that everyone with the physical

00:03:17,430 --> 00:03:23,609
access to that hardware can run any can

00:03:21,660 --> 00:03:29,280
execute any arbitrary code because due

00:03:23,609 --> 00:03:34,500
to the flaw in the in the in the in the

00:03:29,280 --> 00:03:35,819
bootloader so that's that's the kind of

00:03:34,500 --> 00:03:38,269
the construction of a fletcher

00:03:35,819 --> 00:03:40,470
so there is an oled there is a

00:03:38,269 --> 00:03:42,060
microcontroller which is an insecure

00:03:40,470 --> 00:03:45,359
microcontroller and just off-the-shelf

00:03:42,060 --> 00:03:47,700
stm32 and there is a secure MCU so

00:03:45,359 --> 00:03:50,549
secure and see you does he tours all the

00:03:47,700 --> 00:03:53,010
keys and does all the signing but if you

00:03:50,549 --> 00:03:55,590
in fact the this microcontroller it

00:03:53,010 --> 00:03:58,680
actually shows on the OLED what you are

00:03:55,590 --> 00:04:01,260
signing then this is kind of pointless

00:03:58,680 --> 00:04:03,030
scenario and this converges to some to

00:04:01,260 --> 00:04:05,760
the security of that you can have for

00:04:03,030 --> 00:04:08,220
example on a smart card so you don't

00:04:05,760 --> 00:04:10,170
need the wallet for this on the other

00:04:08,220 --> 00:04:14,370
hand yeah there was also an interesting

00:04:10,170 --> 00:04:16,500
blog post from roughly a year ago which

00:04:14,370 --> 00:04:19,829
basically came come to the same

00:04:16,500 --> 00:04:23,430
conclusion with with physical access you

00:04:19,829 --> 00:04:25,229
can if you have access you can have a

00:04:23,430 --> 00:04:27,599
supply chain attack on these on these

00:04:25,229 --> 00:04:30,240
wallets where you can actually replace

00:04:27,599 --> 00:04:31,620
the firmer even though but but firmer is

00:04:30,240 --> 00:04:32,020
actually supposed to be verified by the

00:04:31,620 --> 00:04:33,580
secure

00:04:32,020 --> 00:04:36,340
microcontroller but if you have some

00:04:33,580 --> 00:04:38,830
redundant parts of the firmware on the

00:04:36,340 --> 00:04:41,560
on the general-purpose microcontroller

00:04:38,830 --> 00:04:43,810
this can actually you can just resend

00:04:41,560 --> 00:04:46,060
the same part and then put your

00:04:43,810 --> 00:04:49,539
malicious code in the redundant parts of

00:04:46,060 --> 00:04:51,009
the code for treasurer there was there

00:04:49,539 --> 00:04:54,250
were actually because I believe that

00:04:51,009 --> 00:04:57,370
harder wallet should be actually should

00:04:54,250 --> 00:05:01,030
be resistant to remote attacks so it

00:04:57,370 --> 00:05:02,620
means that no nobody like even if we

00:05:01,030 --> 00:05:07,150
consider a threat model that your

00:05:02,620 --> 00:05:11,409
computer your laptop is compromised your

00:05:07,150 --> 00:05:13,810
cold storage should be should be safe

00:05:11,409 --> 00:05:16,270
well that wasn't let's say that that's

00:05:13,810 --> 00:05:17,889
not 100% the case with good treasurer

00:05:16,270 --> 00:05:19,870
because they had actually wrote a really

00:05:17,889 --> 00:05:22,180
nice blog post about it they have they

00:05:19,870 --> 00:05:28,000
have a really good security blog for

00:05:22,180 --> 00:05:30,550
that for these purposes but yeah so this

00:05:28,000 --> 00:05:34,389
in in in this theoretical attack because

00:05:30,550 --> 00:05:36,750
of the for in the USB software stack

00:05:34,389 --> 00:05:40,750
which was which is the third-party code

00:05:36,750 --> 00:05:43,509
actually that that can lead to if you if

00:05:40,750 --> 00:05:46,150
your computer's compromised you can send

00:05:43,509 --> 00:05:48,759
malicious packet to to the wallet and

00:05:46,150 --> 00:05:50,440
then you can write up to 60 bytes of

00:05:48,759 --> 00:05:54,159
data into the protected part of the

00:05:50,440 --> 00:05:56,080
memory which is definitely not good and

00:05:54,159 --> 00:05:59,400
also of course like with physical access

00:05:56,080 --> 00:06:02,469
bla bla you can do the same thing so

00:05:59,400 --> 00:06:05,800
let's see how are they constructed which

00:06:02,469 --> 00:06:07,960
hardware is used there so for treasurer

00:06:05,800 --> 00:06:10,750
and Philippe key which is kind of a

00:06:07,960 --> 00:06:14,289
ripoff of Tresor they use the same

00:06:10,750 --> 00:06:15,719
microcontroller stm32 f2 0 5 which is as

00:06:14,289 --> 00:06:18,819
I said general-purpose microcontroller

00:06:15,719 --> 00:06:20,770
it doesn't have any true random number

00:06:18,819 --> 00:06:24,430
generator it doesn't have any

00:06:20,770 --> 00:06:27,490
acceleration for for any cryptographic

00:06:24,430 --> 00:06:30,719
primitives but because you don't need to

00:06:27,490 --> 00:06:32,979
sign an NDA to to publish this software

00:06:30,719 --> 00:06:37,120
it's completely open source which is

00:06:32,979 --> 00:06:39,159
awesome on the other hand ledger has

00:06:37,120 --> 00:06:41,320
this secure mark controller which is

00:06:39,159 --> 00:06:44,259
under an NDA so that that's why I

00:06:41,320 --> 00:06:45,970
couldn't conclude whether it has or it

00:06:44,259 --> 00:06:49,120
doesn't have

00:06:45,970 --> 00:06:49,980
the support hardware support hardware

00:06:49,120 --> 00:06:52,900
acceleration for

00:06:49,980 --> 00:06:57,120
sha-256 but it definitely cannot be

00:06:52,900 --> 00:06:59,320
open-source though the software for the

00:06:57,120 --> 00:07:06,370
for the general purpose microcontroller

00:06:59,320 --> 00:07:09,370
can be open sourced and there is also

00:07:06,370 --> 00:07:11,950
another harder wallet called a cold card

00:07:09,370 --> 00:07:14,610
which has an interesting construction so

00:07:11,950 --> 00:07:17,530
it has this secure element which is

00:07:14,610 --> 00:07:20,470
supposed to store keys but on the other

00:07:17,530 --> 00:07:21,820
hand even though it's a Tec see even

00:07:20,470 --> 00:07:24,850
though we will assume that it has

00:07:21,820 --> 00:07:27,250
support it does support elliptic curve

00:07:24,850 --> 00:07:28,360
cryptography but it doesn't support the

00:07:27,250 --> 00:07:31,450
elliptic curve that is needed for

00:07:28,360 --> 00:07:33,100
signing Bitcoin transactions so the

00:07:31,450 --> 00:07:35,020
actual signing has to be done on the

00:07:33,100 --> 00:07:38,920
insecure microcontroller but of course

00:07:35,020 --> 00:07:42,400
this can be also open source and the

00:07:38,920 --> 00:07:44,350
construction that that I just hope

00:07:42,400 --> 00:07:48,610
because I wasn't I wasn't happy really

00:07:44,350 --> 00:07:52,210
with with the existing approach was that

00:07:48,610 --> 00:07:55,360
I si to move the OLED and then put the

00:07:52,210 --> 00:07:56,650
microcontroller in between the computer

00:07:55,360 --> 00:07:59,260
like the communication micro neutral

00:07:56,650 --> 00:08:02,770
because you usually USB software stack

00:07:59,260 --> 00:08:04,270
is really heavy and you know going

00:08:02,770 --> 00:08:07,120
through and and it's also dependent and

00:08:04,270 --> 00:08:10,390
interrupts more in most cases and that

00:08:07,120 --> 00:08:14,580
leads to two that can lead to too many

00:08:10,390 --> 00:08:17,590
different cases where you can actually

00:08:14,580 --> 00:08:20,919
compromise the so the whole so this way

00:08:17,590 --> 00:08:24,850
you maintain the same threat model as if

00:08:20,919 --> 00:08:26,980
your laptop was compromised but you you

00:08:24,850 --> 00:08:31,270
minimize you close the door close the

00:08:26,980 --> 00:08:34,120
gap by only using like simple you are

00:08:31,270 --> 00:08:35,740
stupid UART communication with the my

00:08:34,120 --> 00:08:40,289
controller that is actually kind of

00:08:35,740 --> 00:08:45,010
secure and it's available without an NDA

00:08:40,289 --> 00:08:47,170
so and it has hardware acceleration for

00:08:45,010 --> 00:08:49,470
two it has like to run or arm generator

00:08:47,170 --> 00:08:53,380
hardware acceleration for sha-256 and

00:08:49,470 --> 00:08:55,870
also supports in Hardware elliptic curve

00:08:53,380 --> 00:08:58,660
sack be 256k one which is needed for

00:08:55,870 --> 00:09:02,230
signing Bitcoin transactions and

00:08:58,660 --> 00:09:04,329
theorem also and that thus it can be

00:09:02,230 --> 00:09:06,730
completed the whole setup can be

00:09:04,329 --> 00:09:10,959
completely open sourced so checking the

00:09:06,730 --> 00:09:12,430
library dependencies well I tried to be

00:09:10,959 --> 00:09:15,279
independent completely from from from

00:09:12,430 --> 00:09:17,529
any library in H wallet so I didn't even

00:09:15,279 --> 00:09:22,329
use the standard c library that

00:09:17,529 --> 00:09:26,199
therefore i actually had to do some some

00:09:22,329 --> 00:09:29,279
tricks to do even division with like big

00:09:26,199 --> 00:09:30,699
numbers but we will see that later so

00:09:29,279 --> 00:09:32,670
for treasure

00:09:30,699 --> 00:09:36,730
basically it's completely open source

00:09:32,670 --> 00:09:38,560
well whereas ledger is using these has

00:09:36,730 --> 00:09:42,130
these like closed source components that

00:09:38,560 --> 00:09:46,269
were that they were unable to to publish

00:09:42,130 --> 00:09:48,430
because of the NBA with with SD so if

00:09:46,269 --> 00:09:50,949
and if you see treasure and both Reznor

00:09:48,430 --> 00:09:53,889
and lighter they depend also on lots of

00:09:50,949 --> 00:09:57,430
third party libs so that that's how

00:09:53,889 --> 00:09:59,259
actually this the this buffer overflow

00:09:57,430 --> 00:10:01,930
happened in in in treasure because it

00:09:59,259 --> 00:10:04,959
was part of these third-party libraries

00:10:01,930 --> 00:10:06,279
that were actually just used as they are

00:10:04,959 --> 00:10:09,220
they were never actually meant to be

00:10:06,279 --> 00:10:11,910
used in secure devices they thought that

00:10:09,220 --> 00:10:13,800
there was a proper security all it

00:10:11,910 --> 00:10:16,930
carried out on them

00:10:13,800 --> 00:10:20,709
so keep key as a report as I said it

00:10:16,930 --> 00:10:24,850
just adds some some code on that and

00:10:20,709 --> 00:10:26,290
called card issues is like it has has

00:10:24,850 --> 00:10:29,649
common code with all of these projects

00:10:26,290 --> 00:10:32,620
and it's it has huge code base because

00:10:29,649 --> 00:10:34,060
of the usage of micro Python I know what

00:10:32,620 --> 00:10:36,670
you're saying like you probably think

00:10:34,060 --> 00:10:39,550
I'm crazy I'm rolling my own crypto well

00:10:36,670 --> 00:10:42,250
I would disagree because I'm actually

00:10:39,550 --> 00:10:45,370
just interfacing Hardware primitives in

00:10:42,250 --> 00:10:47,589
the microcontroller so that's why my

00:10:45,370 --> 00:10:50,259
code base can actually be really small

00:10:47,589 --> 00:10:54,670
that's why that's why the eighth wallet

00:10:50,259 --> 00:10:58,060
has really really really small code base

00:10:54,670 --> 00:11:01,600
compared to so I actually pulled each of

00:10:58,060 --> 00:11:03,449
these projects from from github and also

00:11:01,600 --> 00:11:07,510
including their sub modules and then

00:11:03,449 --> 00:11:10,889
counted the number of lines of code in C

00:11:07,510 --> 00:11:10,889
and got eight files

00:11:11,480 --> 00:11:15,500
and as you can see 2.5 million lines of

00:11:13,670 --> 00:11:18,350
code for a coal card because of micro

00:11:15,500 --> 00:11:20,120
Python like it actually pulls the code

00:11:18,350 --> 00:11:22,310
for different platforms for different

00:11:20,120 --> 00:11:23,690
microcontrollers it's just a bunch of

00:11:22,310 --> 00:11:26,450
everything

00:11:23,690 --> 00:11:29,060
whereas ledger has around the three

00:11:26,450 --> 00:11:30,620
hundred forty six thousand lines of code

00:11:29,060 --> 00:11:33,320
which is the only on the open source

00:11:30,620 --> 00:11:35,600
part and treasuring keep key expectedly

00:11:33,320 --> 00:11:38,390
they have around the same number of

00:11:35,600 --> 00:11:40,190
lines of code whereas the v8 wallet it

00:11:38,390 --> 00:11:41,930
was written from scratch only has like

00:11:40,190 --> 00:11:44,290
around four thousand lines of code and

00:11:41,930 --> 00:11:46,730
of these lines of code like only

00:11:44,290 --> 00:11:49,670
slightly above two thousand lines of

00:11:46,730 --> 00:11:51,680
code is the actual meet the rest is the

00:11:49,670 --> 00:11:55,130
deformed for displaying like you don't

00:11:51,680 --> 00:11:58,930
even have to order that code and license

00:11:55,130 --> 00:12:01,010
headers which don't even get compiled so

00:11:58,930 --> 00:12:04,940
regarding code lace yeah you can find it

00:12:01,010 --> 00:12:07,220
find the code on this link it hasn't

00:12:04,940 --> 00:12:09,220
been updated for a while but yeah I

00:12:07,220 --> 00:12:13,130
don't have enough time to work on that

00:12:09,220 --> 00:12:14,690
at the moment but if you see this is the

00:12:13,130 --> 00:12:17,240
basic layer these are the basic the

00:12:14,690 --> 00:12:20,840
drivers that the call it actually

00:12:17,240 --> 00:12:23,960
interfaces the hardware then the methyl

00:12:20,840 --> 00:12:26,420
so if the construction looks like this

00:12:23,960 --> 00:12:28,070
there isn't this microcontroller that

00:12:26,420 --> 00:12:30,760
communicates to another communication

00:12:28,070 --> 00:12:33,770
microcontroller and talks with the OLED

00:12:30,760 --> 00:12:37,880
so this part is I actually fixed the

00:12:33,770 --> 00:12:41,390
speed to 215 point to kill the board

00:12:37,880 --> 00:12:43,250
because that helped me optimize the

00:12:41,390 --> 00:12:45,560
whole code I didn't have to calculate

00:12:43,250 --> 00:12:47,840
values for certain registers that

00:12:45,560 --> 00:12:49,580
therefore I made the code much easier

00:12:47,840 --> 00:12:51,800
told it like you can audit it in in a

00:12:49,580 --> 00:12:54,260
couple of days for like you can perform

00:12:51,800 --> 00:12:59,300
proper security on it on the source code

00:12:54,260 --> 00:13:01,730
and also yeah spi bus is caught and one

00:12:59,300 --> 00:13:06,070
many heard the same actually applied the

00:13:01,730 --> 00:13:09,080
same approach as with as with you earth

00:13:06,070 --> 00:13:12,860
and the other part the crypto part over

00:13:09,080 --> 00:13:14,780
there so basically I have the building

00:13:12,860 --> 00:13:18,440
block building blocks for for all of

00:13:14,780 --> 00:13:20,330
these so LTC is making sure that that

00:13:18,440 --> 00:13:23,200
part that peripheral is making sure that

00:13:20,330 --> 00:13:27,730
I can sign the transaction

00:13:23,200 --> 00:13:34,770
mm cau gives me the hash and I got a

00:13:27,730 --> 00:13:38,260
nonce from trng and LTC supports 256-bit

00:13:34,770 --> 00:13:41,050
operation arithmetic for for this

00:13:38,260 --> 00:13:43,420
elliptical and also for generating the

00:13:41,050 --> 00:13:47,520
signature these are some operations that

00:13:43,420 --> 00:13:52,800
that I used to implement the ECDSA

00:13:47,520 --> 00:13:57,790
algorithm here and the upper layer is

00:13:52,800 --> 00:14:02,170
kind of split in 3 parts so there is the

00:13:57,790 --> 00:14:06,280
this packet part where which is used for

00:14:02,170 --> 00:14:08,830
communication let's say like upstream to

00:14:06,280 --> 00:14:11,410
to the communication and see you and

00:14:08,830 --> 00:14:14,320
further to the computer into the network

00:14:11,410 --> 00:14:17,380
to the OLED which is basically interface

00:14:14,320 --> 00:14:18,790
that you get ok it includes also GPIO

00:14:17,380 --> 00:14:21,600
that is used for buttons but I didn't

00:14:18,790 --> 00:14:25,090
have to show it here it's obvious and

00:14:21,600 --> 00:14:26,560
critical part which is covering these

00:14:25,090 --> 00:14:30,730
three peripherals that I already

00:14:26,560 --> 00:14:32,490
mentioned so yeah packet there is really

00:14:30,730 --> 00:14:37,780
simple interface we'd send and receive

00:14:32,490 --> 00:14:40,930
packet structure is like TLB NCRC super

00:14:37,780 --> 00:14:44,320
simple not complicated easy to audit all

00:14:40,930 --> 00:14:47,950
a part basically just cleared you all

00:14:44,320 --> 00:14:53,610
read and write the row with with certain

00:14:47,950 --> 00:14:56,140
certain string by SPI and this is a bit

00:14:53,610 --> 00:14:59,200
more complicated part where we're

00:14:56,140 --> 00:15:02,590
actually actual signing takes place and

00:14:59,200 --> 00:15:06,310
hashing and it's the trickiest part was

00:15:02,590 --> 00:15:10,420
to actually implement the division

00:15:06,310 --> 00:15:14,320
because does anyone know why I would

00:15:10,420 --> 00:15:18,280
need big number division for signing

00:15:14,320 --> 00:15:19,930
Bitcoin transactions anyone ok it's

00:15:18,280 --> 00:15:23,320
because when you when you want to

00:15:19,930 --> 00:15:25,000
populate the the the the string for some

00:15:23,320 --> 00:15:28,570
one of the the foreign address you need

00:15:25,000 --> 00:15:30,670
to to use base 58 and in order to get

00:15:28,570 --> 00:15:33,650
base 58 you need to divide that number

00:15:30,670 --> 00:15:37,420
with you need to divide the

00:15:33,650 --> 00:15:39,950
address with with 58 and then get these

00:15:37,420 --> 00:15:42,380
human readable characters and in order

00:15:39,950 --> 00:15:44,750
to do that I had to implement this

00:15:42,380 --> 00:15:46,520
division which was not supported in

00:15:44,750 --> 00:15:53,680
hardware so the way I did actually

00:15:46,520 --> 00:15:58,820
abused the existing stuff so I first

00:15:53,680 --> 00:16:02,240
used the inversion so modular

00:15:58,820 --> 00:16:07,250
multiplicative inverse modulo number B

00:16:02,240 --> 00:16:11,330
so I get a B Prime and then I deduct the

00:16:07,250 --> 00:16:15,080
the module a module B from from a to get

00:16:11,330 --> 00:16:18,710
the the round number for for the result

00:16:15,080 --> 00:16:21,320
and what I do then is I basically

00:16:18,710 --> 00:16:23,600
multiply these two numbers and in order

00:16:21,320 --> 00:16:27,130
for this to work I have to make sure

00:16:23,600 --> 00:16:30,890
that I can get the multiple module

00:16:27,130 --> 00:16:33,410
multiplicative inverse modulo N and for

00:16:30,890 --> 00:16:36,440
that to work and has to be a large prime

00:16:33,410 --> 00:16:38,480
and larger than any a and B so I looked

00:16:36,440 --> 00:16:42,080
at the code that I already had and I

00:16:38,480 --> 00:16:43,700
found yeah there is a P from SEC P 256 K

00:16:42,080 --> 00:16:46,959
1 which is a large prime number and

00:16:43,700 --> 00:16:50,110
that's how it this was implemented in

00:16:46,959 --> 00:16:53,750
these number of lines of code possible

00:16:50,110 --> 00:16:57,140
main loop is a stupid main loop that

00:16:53,750 --> 00:16:59,360
just reads packets via via you are so no

00:16:57,140 --> 00:17:02,060
interrupts it's it's just waiting for

00:16:59,360 --> 00:17:03,709
these packets and depending on the on

00:17:02,060 --> 00:17:07,189
the packet after it its verify this here

00:17:03,709 --> 00:17:10,069
see it sends it further up the stack to

00:17:07,189 --> 00:17:13,390
two different modules so for example if

00:17:10,069 --> 00:17:18,050
it's intended to be used for Bitcoin

00:17:13,390 --> 00:17:19,730
module it's just sending it to to that

00:17:18,050 --> 00:17:23,689
part of the of the upper layer of the

00:17:19,730 --> 00:17:26,270
code and then so the the the type field

00:17:23,689 --> 00:17:28,910
is actually divided into so packet type

00:17:26,270 --> 00:17:31,160
can be either module or actually can be

00:17:28,910 --> 00:17:32,630
like the module part defines the module

00:17:31,160 --> 00:17:34,850
and function defines a function within

00:17:32,630 --> 00:17:38,260
that module on the upper layer so far I

00:17:34,850 --> 00:17:40,700
only implemented the Bitcoin module and

00:17:38,260 --> 00:17:43,070
this is how the process function looks

00:17:40,700 --> 00:17:46,280
like basically it just has a switch case

00:17:43,070 --> 00:17:48,290
for for the function and then if it's

00:17:46,280 --> 00:17:49,760
like if the computer says yeah if the

00:17:48,290 --> 00:17:52,370
communication chip actually sounds like

00:17:49,760 --> 00:17:54,580
now initialize the transaction these are

00:17:52,370 --> 00:17:57,680
the this is the stuff that the

00:17:54,580 --> 00:18:01,730
transaction is consisted of and then

00:17:57,680 --> 00:18:03,710
okay now ask the user to sign it and

00:18:01,730 --> 00:18:07,130
then something like this shows up on the

00:18:03,710 --> 00:18:10,100
screen and if you say yes you're gonna

00:18:07,130 --> 00:18:16,610
send point zero zero one bitcoins to

00:18:10,100 --> 00:18:19,880
this address so what next I don't

00:18:16,610 --> 00:18:22,070
actually plan to build it because this

00:18:19,880 --> 00:18:23,570
microcontroller has a super crazy lead

00:18:22,070 --> 00:18:26,090
time like last time I checked it was

00:18:23,570 --> 00:18:31,130
almost a year so it's it's kind of I

00:18:26,090 --> 00:18:34,190
guess pointless to start but if you if

00:18:31,130 --> 00:18:36,290
you want to to test it yourself you can

00:18:34,190 --> 00:18:39,730
buy these boards are easily available

00:18:36,290 --> 00:18:40,880
online from from various websites so

00:18:39,730 --> 00:18:42,620
yeah

00:18:40,880 --> 00:18:45,890
I plan to - probably at some point

00:18:42,620 --> 00:18:49,400
implement or anyone of you welcome to

00:18:45,890 --> 00:18:54,230
commit the code it's completely released

00:18:49,400 --> 00:18:59,960
under GPL v3 so for some future plans

00:18:54,230 --> 00:19:03,770
maybe implementing the u2f and also yeah

00:18:59,960 --> 00:19:06,320
there is another microcontroller in in

00:19:03,770 --> 00:19:08,720
these series which is if you want to go

00:19:06,320 --> 00:19:11,000
and be a more secure anti-tamper

00:19:08,720 --> 00:19:13,910
you can use that one and reuse the same

00:19:11,000 --> 00:19:16,850
code but that yeah then you need to sign

00:19:13,910 --> 00:19:20,240
an NDA with with this chip vendor which

00:19:16,850 --> 00:19:23,060
is not really friendly for a foreign

00:19:20,240 --> 00:19:25,070
event like for them right and you can

00:19:23,060 --> 00:19:26,870
also put some other communication by

00:19:25,070 --> 00:19:28,670
control the one that I that I used was

00:19:26,870 --> 00:19:30,560
already on the board which it was used

00:19:28,670 --> 00:19:35,000
actually for debugging purposes but I

00:19:30,560 --> 00:19:37,700
kind of abused it too to communicate but

00:19:35,000 --> 00:19:41,180
if you put some other for example one of

00:19:37,700 --> 00:19:45,020
these Nordic kids that they support also

00:19:41,180 --> 00:19:47,840
like Bluetooth NFC and USB so you can

00:19:45,020 --> 00:19:50,750
actually connect your your wallet to

00:19:47,840 --> 00:19:53,300
anything and you don't you don't care if

00:19:50,750 --> 00:19:55,220
there is a vulnerability in that

00:19:53,300 --> 00:19:59,180
communication stack because all you care

00:19:55,220 --> 00:20:01,880
about is that this software runs as

00:19:59,180 --> 00:20:04,310
intended because in again you are the

00:20:01,880 --> 00:20:06,980
one who has the the last word

00:20:04,310 --> 00:20:09,560
she wants to sign a transaction maybe

00:20:06,980 --> 00:20:12,170
one of the next things to implement

00:20:09,560 --> 00:20:14,150
would be also the recovery seed - to

00:20:12,170 --> 00:20:16,100
implement these three bit coding

00:20:14,150 --> 00:20:17,780
fermentation proposals and any more

00:20:16,100 --> 00:20:22,280
cryptocurrencies but yeah you're welcome

00:20:17,780 --> 00:20:41,990
to commit codes for that and any

00:20:22,280 --> 00:20:45,770
questions any questions yeah very nice

00:20:41,990 --> 00:20:47,390
so there KL 82 chip and there's 81 and

00:20:45,770 --> 00:20:50,540
anti tampering I believe there are two

00:20:47,390 --> 00:20:53,320
separate chips how do they differ do

00:20:50,540 --> 00:20:57,290
they require NDA's and do they support

00:20:53,320 --> 00:20:59,900
other than the SEC k2 fifty sixty one

00:20:57,290 --> 00:21:02,180
yeah so first yeah I didn't sorry I

00:20:59,900 --> 00:21:05,720
didn't I didn't elaborate that further

00:21:02,180 --> 00:21:10,190
there is K 82 and there is KL 82 so okay

00:21:05,720 --> 00:21:12,920
82 is based on cortex m4 and KL 82 is

00:21:10,190 --> 00:21:15,800
based on cortex m0 and it's I think the

00:21:12,920 --> 00:21:18,800
board price is like twice two times

00:21:15,800 --> 00:21:21,080
smaller so it's it's 50% cheaper and

00:21:18,800 --> 00:21:23,960
therefore it's maybe better if you want

00:21:21,080 --> 00:21:26,420
to if you want us to give it a shot to

00:21:23,960 --> 00:21:30,320
try this code yourself but the only

00:21:26,420 --> 00:21:35,900
difference between these K 80/20 KL 82

00:21:30,320 --> 00:21:37,940
is and k & KL 81 is because they have

00:21:35,900 --> 00:21:40,670
another peripheral that is responsible

00:21:37,940 --> 00:21:43,280
for like if we need to write the code

00:21:40,670 --> 00:21:45,860
for for like anti-tamper for probable

00:21:43,280 --> 00:21:48,320
activity they support I think mesh

00:21:45,860 --> 00:21:49,940
protection and stuff like that but you

00:21:48,320 --> 00:21:51,830
need to sign an NDA for that I didn't

00:21:49,940 --> 00:21:55,250
sign an NDA I didn't even get in get in

00:21:51,830 --> 00:21:58,070
touch with the chip vendor so yeah I am

00:21:55,250 --> 00:21:59,720
just expressing my opinion here or are

00:21:58,070 --> 00:22:01,880
they useful at all without an NDA do

00:21:59,720 --> 00:22:04,130
they support the Copeland's curves do

00:22:01,880 --> 00:22:04,610
they support exactly editors yeah

00:22:04,130 --> 00:22:06,410
exactly

00:22:04,610 --> 00:22:08,930
everything is supported except for this

00:22:06,410 --> 00:22:11,510
anti-tamper part yeah I use them for a

00:22:08,930 --> 00:22:12,830
further for this purpose and they have

00:22:11,510 --> 00:22:14,240
Edwards and Montgomery curves

00:22:12,830 --> 00:22:15,649
as well thank you five five one nine oh

00:22:14,240 --> 00:22:16,850
that's very nice yeah yeah it's like

00:22:15,649 --> 00:22:20,419
that that's why I use this one because

00:22:16,850 --> 00:22:23,899
I've actually checked many different

00:22:20,419 --> 00:22:28,789
microcontrollers and this one was by far

00:22:23,899 --> 00:22:34,130
the most advanced I could find so thank

00:22:28,789 --> 00:22:35,160
you any other questions okay thank you

00:22:34,130 --> 00:22:42,189
very much

00:22:35,160 --> 00:22:42,189
[Applause]

00:23:02,590 --> 00:23:05,590
well

00:25:38,070 --> 00:25:41,070
wait

00:28:29,710 --> 00:28:32,839

YouTube URL: https://www.youtube.com/watch?v=ZwVF3xZ9q-g


