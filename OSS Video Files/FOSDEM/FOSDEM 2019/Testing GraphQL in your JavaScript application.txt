Title: Testing GraphQL in your JavaScript application
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Roy Derks (@gethackteam)

At: FOSDEM 2019
https://video.fosdem.org/2019/H.1308/testing_graphql_javascript.webm


Test GraphQL in your JavaScript application. This talk will show how you can test GraphQL in your JavaScript application using available open-source packages. It will describe how to get started, best practices and a real-world example. 

Room: H.1308 (Rolin)
Scheduled start: 2019-02-03 15:00:00+01
Captions: 
	00:00:05,070 --> 00:00:11,490
we start is somebody here and not

00:00:06,900 --> 00:00:13,799
familiar ready to cook well that's like

00:00:11,490 --> 00:00:16,200
half of you okay

00:00:13,799 --> 00:00:18,510
I will tell maybe a little bit about

00:00:16,200 --> 00:00:21,359
Groff grill so Groff quails a query

00:00:18,510 --> 00:00:23,550
language for your data collections it's

00:00:21,359 --> 00:00:25,769
a little bit different from like

00:00:23,550 --> 00:00:27,689
collecting data from rest IPRs rest api

00:00:25,769 --> 00:00:29,580
is usually of a single endpoint with

00:00:27,689 --> 00:00:31,679
like fixed data structures so if you

00:00:29,580 --> 00:00:33,780
want to get like a collection of your

00:00:31,679 --> 00:00:37,410
products or your users you're going to

00:00:33,780 --> 00:00:39,930
access one REST API endpoint and in the

00:00:37,410 --> 00:00:41,460
case of Kafka well you can combine all

00:00:39,930 --> 00:00:44,039
those collections into one single

00:00:41,460 --> 00:00:46,230
endpoints that there's flexible data

00:00:44,039 --> 00:00:47,789
structures so we're going to look at

00:00:46,230 --> 00:00:49,550
some graph coil queries later for the

00:00:47,789 --> 00:00:52,199
people that aren't familiar with this

00:00:49,550 --> 00:00:57,120
throughout these slides I will use an

00:00:52,199 --> 00:01:01,230
example with react people are using he

00:00:57,120 --> 00:01:05,570
react or okay that's better okay so I

00:01:01,230 --> 00:01:08,310
will use reactor most in code examples

00:01:05,570 --> 00:01:10,259
so it's always an important thing to add

00:01:08,310 --> 00:01:11,610
testing to your to your code especially

00:01:10,259 --> 00:01:14,580
when you have a JavaScript application

00:01:11,610 --> 00:01:16,170
without a dynamic with a dynamic type

00:01:14,580 --> 00:01:18,450
system not like something like

00:01:16,170 --> 00:01:20,939
typescript then it's really important to

00:01:18,450 --> 00:01:23,759
have testing scale testing scheduled

00:01:20,939 --> 00:01:26,579
into your development process so this is

00:01:23,759 --> 00:01:28,280
a meme about a guy from Futurama was

00:01:26,579 --> 00:01:30,930
wondering if its code is working or just

00:01:28,280 --> 00:01:32,820
his tester broken like the people in

00:01:30,930 --> 00:01:35,640
here that are using they're having like

00:01:32,820 --> 00:01:38,130
test coverage levels inside the

00:01:35,640 --> 00:01:40,020
deployment phase we'll probably know you

00:01:38,130 --> 00:01:42,119
need to have working tests and tests

00:01:40,020 --> 00:01:45,090
above a certain coverage to make sure

00:01:42,119 --> 00:01:48,840
your code is working or just your tests

00:01:45,090 --> 00:01:51,990
are really wrong so boom I my name is

00:01:48,840 --> 00:01:55,619
Rory I I'm from Amsterdam I work with

00:01:51,990 --> 00:01:57,840
JavaScript a lot both professionally at

00:01:55,619 --> 00:01:59,939
the city of Amsterdam but also as

00:01:57,840 --> 00:02:03,060
conferences and meetups or workshops a

00:01:59,939 --> 00:02:06,659
house about react you can find me on

00:02:03,060 --> 00:02:09,360
Twitter as well it's epic a tech team

00:02:06,659 --> 00:02:12,210
and then I tweet a lot about JavaScript

00:02:09,360 --> 00:02:15,120
or react react native and growth well as

00:02:12,210 --> 00:02:17,430
well this presentation is about for

00:02:15,120 --> 00:02:18,450
everyone that's using react applications

00:02:17,430 --> 00:02:21,750
JavaScript

00:02:18,450 --> 00:02:25,020
or maybe broth well I will show both how

00:02:21,750 --> 00:02:27,209
to test you have script applications the

00:02:25,020 --> 00:02:30,209
juice graph quail and graph quail

00:02:27,209 --> 00:02:32,810
queries invitations out of the box so if

00:02:30,209 --> 00:02:35,069
we small look at this testing pyramid

00:02:32,810 --> 00:02:37,319
this is like the traditional testing

00:02:35,069 --> 00:02:40,260
pyramid with the unit tests on the

00:02:37,319 --> 00:02:41,550
bottom the integration tests in the

00:02:40,260 --> 00:02:44,790
middle and end-to-end tests in the end

00:02:41,550 --> 00:02:47,370
and this also like in level of

00:02:44,790 --> 00:02:49,590
complexity unit tests are fairly easy to

00:02:47,370 --> 00:02:51,090
create integration tests are a bit

00:02:49,590 --> 00:02:53,670
harder because you're not testing single

00:02:51,090 --> 00:02:55,680
components or single pieces of code but

00:02:53,670 --> 00:02:57,660
how code connects with each other and

00:02:55,680 --> 00:02:59,970
end-to-end test is usually the most

00:02:57,660 --> 00:03:02,580
difficult one as you would usually mark

00:02:59,970 --> 00:03:05,400
a browser or use something like Cyprus

00:03:02,580 --> 00:03:07,470
to do it and really see how user will

00:03:05,400 --> 00:03:10,830
interact with your application from page

00:03:07,470 --> 00:03:12,360
to page and so this will focus mostly on

00:03:10,830 --> 00:03:13,799
unit tests because it's a bit hard to

00:03:12,360 --> 00:03:17,120
explain integration and end-to-end

00:03:13,799 --> 00:03:19,920
testing one one single presentation

00:03:17,120 --> 00:03:21,989
before to have some criticals before we

00:03:19,920 --> 00:03:24,060
have some criticals there's a new

00:03:21,989 --> 00:03:25,890
approach for testing is usually

00:03:24,060 --> 00:03:30,690
something like this

00:03:25,890 --> 00:03:34,140
it's like upside-down diamonds or what

00:03:30,690 --> 00:03:35,310
is it a five-point polygon and as you

00:03:34,140 --> 00:03:37,410
can see unit tests are on the bottom

00:03:35,310 --> 00:03:40,049
integration tests are in the middle

00:03:37,410 --> 00:03:42,329
end-to-end tests are on top making enter

00:03:40,049 --> 00:03:44,790
in tests and integrations tests much

00:03:42,329 --> 00:03:47,070
more important but like I said we will

00:03:44,790 --> 00:03:48,510
focus on unit tests for now and maybe if

00:03:47,070 --> 00:03:51,030
we have time for questions we can

00:03:48,510 --> 00:03:55,530
discuss how to do integration tests as

00:03:51,030 --> 00:03:58,140
well so why is we to write tests like I

00:03:55,530 --> 00:04:01,049
said before tests are important to see

00:03:58,140 --> 00:04:02,579
if your code is stable and usually it's

00:04:01,049 --> 00:04:06,750
an indication if your code is working as

00:04:02,579 --> 00:04:09,359
well so you will test if your code will

00:04:06,750 --> 00:04:11,940
work as expected so usually when you

00:04:09,359 --> 00:04:13,799
have a project with good with good

00:04:11,940 --> 00:04:16,289
testing sides you can see all the

00:04:13,799 --> 00:04:18,870
functions from the project by just

00:04:16,289 --> 00:04:21,030
looking at descriptions of the tests and

00:04:18,870 --> 00:04:23,580
you would also see if you can even

00:04:21,030 --> 00:04:27,150
handle errors and educators correctly

00:04:23,580 --> 00:04:29,789
and this all is also something I will

00:04:27,150 --> 00:04:31,260
show an example and you will also test

00:04:29,789 --> 00:04:33,120
your syntax a single correct

00:04:31,260 --> 00:04:35,940
especially with JavaScript as we have a

00:04:33,120 --> 00:04:37,890
dynamic type system unless you use

00:04:35,940 --> 00:04:40,380
typescript or maybe flow if you're using

00:04:37,890 --> 00:04:41,970
react you're not always sure if a

00:04:40,380 --> 00:04:44,460
variable you're pulsing always is

00:04:41,970 --> 00:04:47,730
integral or a float or abilene it could

00:04:44,460 --> 00:04:49,770
be the case that your integer is instead

00:04:47,730 --> 00:04:52,110
of float or you're expecting a string

00:04:49,770 --> 00:04:54,450
and sending an object so usually if you

00:04:52,110 --> 00:04:56,880
have unit tests in place you will notice

00:04:54,450 --> 00:04:58,950
when you're testing that your code isn't

00:04:56,880 --> 00:05:02,310
working as predicted because one of your

00:04:58,950 --> 00:05:03,680
variables has a different syntax for

00:05:02,310 --> 00:05:06,030
testing JavaScript there are a lot of

00:05:03,680 --> 00:05:07,920
frameworks or applications that are

00:05:06,030 --> 00:05:11,340
available already I will mention some

00:05:07,920 --> 00:05:14,280
and maybe if some people will recognize

00:05:11,340 --> 00:05:17,520
them at first we have mojo which is a

00:05:14,280 --> 00:05:19,020
JavaScript test framework people use the

00:05:17,520 --> 00:05:21,450
lot when they are running nodejs

00:05:19,020 --> 00:05:25,550
applications or want to test something

00:05:21,450 --> 00:05:28,140
right in the browser we also have enzyme

00:05:25,550 --> 00:05:30,480
which is a JavaScript testing utility

00:05:28,140 --> 00:05:34,380
usually for react and simulates the

00:05:30,480 --> 00:05:36,950
react demand react components and this

00:05:34,380 --> 00:05:39,300
is a much more advanced version of the

00:05:36,950 --> 00:05:41,880
code level using our using the react

00:05:39,300 --> 00:05:45,270
test to tails whenever in examples and

00:05:41,880 --> 00:05:47,880
enzyme is a more advanced version of

00:05:45,270 --> 00:05:50,190
this one iosef jar which is in a certain

00:05:47,880 --> 00:05:53,310
library so if you expect stuff to be

00:05:50,190 --> 00:05:55,770
equal to each other or not equal or you

00:05:53,310 --> 00:05:57,480
want to know if one of your actions has

00:05:55,770 --> 00:05:59,780
been called over an API has been called

00:05:57,480 --> 00:06:02,640
then you can use junctions for that and

00:05:59,780 --> 00:06:05,280
in the end we have just which is sort of

00:06:02,640 --> 00:06:07,980
into the box with react and it was

00:06:05,280 --> 00:06:10,350
created by Facebook and the examples are

00:06:07,980 --> 00:06:11,670
will show our using just now you also

00:06:10,350 --> 00:06:14,580
have stuff like I mentioned before like

00:06:11,670 --> 00:06:16,680
Cypress and Cypress it runs in the

00:06:14,580 --> 00:06:18,750
browser and is it mocks the browser

00:06:16,680 --> 00:06:20,430
behavioral puppeteer and then you can

00:06:18,750 --> 00:06:22,830
see how people click to the application

00:06:20,430 --> 00:06:24,810
and that is far beyond unit testing we

00:06:22,830 --> 00:06:26,940
will discuss today it might be good to

00:06:24,810 --> 00:06:29,310
know if your I want to integrate testing

00:06:26,940 --> 00:06:33,150
in your project so we're going to look

00:06:29,310 --> 00:06:35,760
at an example that uses graph QL and I'm

00:06:33,150 --> 00:06:37,800
gonna show the schema first so we have

00:06:35,760 --> 00:06:40,610
the schema with a product review and

00:06:37,800 --> 00:06:44,390
offer and as you can see the review and

00:06:40,610 --> 00:06:46,040
offer our dependence of products

00:06:44,390 --> 00:06:48,050
for people that aren't familiar with

00:06:46,040 --> 00:06:50,240
golf quell this scheme has the basis of

00:06:48,050 --> 00:06:52,210
your application and we're going to find

00:06:50,240 --> 00:06:55,190
each type like we would define our

00:06:52,210 --> 00:06:57,650
database scheme in example so all the

00:06:55,190 --> 00:07:00,110
variables will have this format although

00:06:57,650 --> 00:07:01,690
the IDS who always be integral tied as

00:07:00,110 --> 00:07:05,420
well as with strings and so forth and

00:07:01,690 --> 00:07:07,370
the review and offer types are also

00:07:05,420 --> 00:07:10,490
described and linked to the product type

00:07:07,370 --> 00:07:13,130
so throughout the entire application we

00:07:10,490 --> 00:07:14,900
have a real clear idea and what

00:07:13,130 --> 00:07:16,670
structure data will be so we don't

00:07:14,900 --> 00:07:19,340
really have to test anymore

00:07:16,670 --> 00:07:23,000
if we're thumbnail really is a string or

00:07:19,340 --> 00:07:24,800
it actually could be like object and the

00:07:23,000 --> 00:07:27,800
right you see two other types I've

00:07:24,800 --> 00:07:29,570
defined in the schema one is query we're

00:07:27,800 --> 00:07:32,180
gonna query two things like the products

00:07:29,570 --> 00:07:34,550
altogether and a product separately and

00:07:32,180 --> 00:07:37,550
we also have a mutation where we will

00:07:34,550 --> 00:07:39,740
add an offer to a product so this is if

00:07:37,550 --> 00:07:41,270
we for example like an Amazon sort of

00:07:39,740 --> 00:07:43,720
application where your products and

00:07:41,270 --> 00:07:49,330
products are offered by multiple people

00:07:43,720 --> 00:07:49,330
so I'm going to see if I can switch that

00:07:49,990 --> 00:07:55,570
yes so you will have to code for our

00:07:52,880 --> 00:07:55,570
projects

00:08:21,130 --> 00:08:25,480
yes so the application we're going to

00:08:22,900 --> 00:08:27,640
test is this one so we have an offer

00:08:25,480 --> 00:08:30,070
that's way for product it's this guy's a

00:08:27,640 --> 00:08:33,160
blue t-shirts and it's offered by three

00:08:30,070 --> 00:08:37,960
companies and we can add offers to this

00:08:33,160 --> 00:08:41,830
one so if we want to add a reseller with

00:08:37,960 --> 00:08:45,040
a prize we can add it like this and we

00:08:41,830 --> 00:08:46,750
see the new resellers edit with the

00:08:45,040 --> 00:08:49,900
prize and this all works through our

00:08:46,750 --> 00:08:52,540
graphic we have schema that we have

00:08:49,900 --> 00:08:57,010
described here so this is the entry

00:08:52,540 --> 00:08:58,810
point of replication and the page you

00:08:57,010 --> 00:09:00,990
just saw was the products page showing

00:08:58,810 --> 00:09:04,060
an overview the products we have and

00:09:00,990 --> 00:09:06,880
below you can see there's a form

00:09:04,060 --> 00:09:09,970
component right here and of lettuce at

00:09:06,880 --> 00:09:13,260
the offer to the to the product and the

00:09:09,970 --> 00:09:13,260
form component is right here

00:09:20,090 --> 00:09:24,560
yes like I said before we have a query

00:09:23,240 --> 00:09:26,900
where we get to the product so the

00:09:24,560 --> 00:09:29,660
overview just saw of all the products

00:09:26,900 --> 00:09:31,880
with the forms we could retrieve it by

00:09:29,660 --> 00:09:34,630
querying all the products and in

00:09:31,880 --> 00:09:38,590
mutation so adding another offer to form

00:09:34,630 --> 00:09:41,210
was done by this graph coiled mutation

00:09:38,590 --> 00:09:43,580
if we want to test this component then

00:09:41,210 --> 00:09:44,870
there are there multiple options like I

00:09:43,580 --> 00:09:46,400
said before we can you have the

00:09:44,870 --> 00:09:48,200
integration test the unit test or the

00:09:46,400 --> 00:09:51,050
end-to-end test and we're going to see

00:09:48,200 --> 00:09:52,910
how the in 20s will work testing

00:09:51,050 --> 00:09:56,330
Rothwell is a little bit different than

00:09:52,910 --> 00:09:57,860
just testing react components so as you

00:09:56,330 --> 00:09:59,780
could see if we just want to test the

00:09:57,860 --> 00:10:01,820
product compile the products component

00:09:59,780 --> 00:10:04,880
then we would have done something like

00:10:01,820 --> 00:10:08,240
this we use the react test renderer to

00:10:04,880 --> 00:10:10,640
see if the component renders however

00:10:08,240 --> 00:10:14,540
this will give you an error as we were

00:10:10,640 --> 00:10:16,340
missing the whole graph quelle set up so

00:10:14,540 --> 00:10:23,540
we somehow we have to include to graph

00:10:16,340 --> 00:10:25,430
coil setup as you can see here yes

00:10:23,540 --> 00:10:28,100
you're in our index file with a pull up

00:10:25,430 --> 00:10:31,430
provider and Apollo lets you edit graph

00:10:28,100 --> 00:10:33,800
quell to your project and we have a

00:10:31,430 --> 00:10:36,980
Apollo client setup which is our glove

00:10:33,800 --> 00:10:39,140
quell server and we're also we wrapped

00:10:36,980 --> 00:10:41,180
our products component inside this

00:10:39,140 --> 00:10:43,400
Apollo provider with Apollo client

00:10:41,180 --> 00:10:45,500
attached to it so when we're testing the

00:10:43,400 --> 00:10:48,230
products component we also need to

00:10:45,500 --> 00:10:49,760
include that graph quell Apollo provided

00:10:48,230 --> 00:10:57,500
component otherwise our test will fail

00:10:49,760 --> 00:10:58,850
obviously so this is something we we can

00:10:57,500 --> 00:11:00,920
also mock it entirely

00:10:58,850 --> 00:11:03,350
so I have a small example where you can

00:11:00,920 --> 00:11:05,210
see that we reading or Apollo client in

00:11:03,350 --> 00:11:08,630
our test file as well although this

00:11:05,210 --> 00:11:11,120
isn't really maintainable and also cause

00:11:08,630 --> 00:11:13,370
we're directly including Apollo client

00:11:11,120 --> 00:11:16,190
inside our disk files we will also test

00:11:13,370 --> 00:11:17,810
against real life data so for server is

00:11:16,190 --> 00:11:19,400
we're not running or don't have network

00:11:17,810 --> 00:11:21,490
connection then your test will

00:11:19,400 --> 00:11:24,020
automatically fail because you can't

00:11:21,490 --> 00:11:27,470
check your ski mask and your queries

00:11:24,020 --> 00:11:30,260
against the real data from the server so

00:11:27,470 --> 00:11:32,740
this is something we also contest with

00:11:30,260 --> 00:11:34,810
this behavior so that's why Apple

00:11:32,740 --> 00:11:37,390
created the teamwork provider it's

00:11:34,810 --> 00:11:40,690
especially for react components and it

00:11:37,390 --> 00:11:43,810
lets you that you add your schema and

00:11:40,690 --> 00:11:45,250
your more queries and mutations directly

00:11:43,810 --> 00:11:48,970
to the components so you can use them

00:11:45,250 --> 00:11:50,470
and this way you can you can test

00:11:48,970 --> 00:11:52,810
against mock data as you can see we

00:11:50,470 --> 00:11:55,750
insert the mock data to see if our

00:11:52,810 --> 00:11:58,390
project is working fine and you can see

00:11:55,750 --> 00:12:00,970
or products component is wrapped inside

00:11:58,390 --> 00:12:03,700
the mock provider which is basically the

00:12:00,970 --> 00:12:08,530
mock version of the Apollo provider we

00:12:03,700 --> 00:12:11,080
saw before and that way we will test

00:12:08,530 --> 00:12:12,610
against the mock data so if you have

00:12:11,080 --> 00:12:14,710
your graphical query and you want to

00:12:12,610 --> 00:12:16,660
turn products and we don't need to real

00:12:14,710 --> 00:12:19,600
data you can just insert data in the

00:12:16,660 --> 00:12:21,820
mocks and it will also have the same

00:12:19,600 --> 00:12:26,890
JSON format as your real data but then

00:12:21,820 --> 00:12:28,810
with with mocks fair values another

00:12:26,890 --> 00:12:31,500
thing we can do is test schemas but I

00:12:28,810 --> 00:12:43,420
will show you the mock files for the

00:12:31,500 --> 00:12:46,680
components first yes yes so at first we

00:12:43,420 --> 00:12:49,120
can test our or query against the

00:12:46,680 --> 00:12:51,490
against the components as you can see

00:12:49,120 --> 00:12:53,700
this is our actual component fall on via

00:12:51,490 --> 00:12:56,110
for graph well query defined here and

00:12:53,700 --> 00:12:58,420
your going to query all the products

00:12:56,110 --> 00:13:00,760
with the variables and also their

00:12:58,420 --> 00:13:03,340
related collections which are refused

00:13:00,760 --> 00:13:06,430
offers and as you can see we do nothing

00:13:03,340 --> 00:13:08,530
more than just mapping out the data we

00:13:06,430 --> 00:13:10,540
could pick from Guelph guell and we get

00:13:08,530 --> 00:13:13,750
us data back from this query component

00:13:10,540 --> 00:13:15,340
from below and people just map it out

00:13:13,750 --> 00:13:18,070
here and as you can see we have the

00:13:15,340 --> 00:13:22,030
title and the offers and it offers all

00:13:18,070 --> 00:13:24,430
have their own variables and we also

00:13:22,030 --> 00:13:26,650
have the form component if you look at

00:13:24,430 --> 00:13:28,870
the testing for the products component

00:13:26,650 --> 00:13:31,720
you can see if you can see instantly

00:13:28,870 --> 00:13:34,210
from how we describe their tests what

00:13:31,720 --> 00:13:35,890
the components you do so the component

00:13:34,210 --> 00:13:37,420
should render without an error that's

00:13:35,890 --> 00:13:39,760
something we can test really easy we

00:13:37,420 --> 00:13:41,530
don't need to add any mock data because

00:13:39,760 --> 00:13:43,540
we don't need to move data at first

00:13:41,530 --> 00:13:45,070
because the component does need any data

00:13:43,540 --> 00:13:47,139
to render

00:13:45,070 --> 00:13:49,870
and as you can see we wrapped it inside

00:13:47,139 --> 00:13:51,970
the this trailer from react we have a

00:13:49,870 --> 00:13:54,699
mock provider and our produce component

00:13:51,970 --> 00:13:55,990
and this test should work we also have a

00:13:54,699 --> 00:13:59,380
test where we would test the loading

00:13:55,990 --> 00:14:01,300
States we're gonna see if or component

00:13:59,380 --> 00:14:03,160
actually shows a loading indicator or a

00:14:01,300 --> 00:14:05,319
loading text I've ever retrieving data

00:14:03,160 --> 00:14:09,190
from Kafka well for this we still don't

00:14:05,319 --> 00:14:11,050
need to mock any data because this is

00:14:09,190 --> 00:14:14,139
just testing the connection with the

00:14:11,050 --> 00:14:16,300
prety provider and for the third one we

00:14:14,139 --> 00:14:18,639
need to actually insert any mocks so as

00:14:16,300 --> 00:14:20,800
you can see we mock the entire work well

00:14:18,639 --> 00:14:22,930
request by adding the query and the

00:14:20,800 --> 00:14:26,019
query is the same one we use an actual

00:14:22,930 --> 00:14:28,389
component and we just imported and we're

00:14:26,019 --> 00:14:30,550
going to check if the result data

00:14:28,389 --> 00:14:32,560
matches our schema and matches your

00:14:30,550 --> 00:14:34,839
query something that we have to find on

00:14:32,560 --> 00:14:36,430
the front-end and this is a test that

00:14:34,839 --> 00:14:40,440
also should work and we're going to test

00:14:36,430 --> 00:14:43,839
that by seeing if there actually is

00:14:40,440 --> 00:14:46,680
product that has the name test that

00:14:43,839 --> 00:14:50,230
matches with the name test in our result

00:14:46,680 --> 00:14:52,870
and last but not least we can also test

00:14:50,230 --> 00:15:00,670
for our message and as you can see from

00:14:52,870 --> 00:15:05,620
the running example it just disappear

00:15:00,670 --> 00:15:07,540
see for tests are working as you can see

00:15:05,620 --> 00:15:10,839
they all the test from products

00:15:07,540 --> 00:15:12,819
components passed and we also test the

00:15:10,839 --> 00:15:16,720
form component which is basically tested

00:15:12,819 --> 00:15:18,970
on the same way as we tested or produced

00:15:16,720 --> 00:15:21,279
component as you can see we have

00:15:18,970 --> 00:15:22,540
described the mutation in the form and

00:15:21,279 --> 00:15:25,449
as you can see it's a mutation with

00:15:22,540 --> 00:15:29,230
variables that we sent our graph quail

00:15:25,449 --> 00:15:32,589
server and which returns data if we edit

00:15:29,230 --> 00:15:35,380
our product successfully and it can see

00:15:32,589 --> 00:15:40,240
use the form submit that uses the react

00:15:35,380 --> 00:15:45,220
create ref future which we can also test

00:15:40,240 --> 00:15:46,689
by mocking mocking those reps as you can

00:15:45,220 --> 00:15:49,269
see I mocked those webs right here

00:15:46,689 --> 00:15:51,670
inside the testing of her firm component

00:15:49,269 --> 00:15:54,370
and we do it basically the same way so

00:15:51,670 --> 00:15:57,339
we wrapped our firm component inside the

00:15:54,370 --> 00:15:58,280
provider component from Apollo to test

00:15:57,339 --> 00:16:00,380
if it's working

00:15:58,280 --> 00:16:03,110
do the same for the loading state we're

00:16:00,380 --> 00:16:05,180
gonna see four components the loading

00:16:03,110 --> 00:16:07,850
indicator when we're sending the

00:16:05,180 --> 00:16:11,030
mutation to the cough quelle server and

00:16:07,850 --> 00:16:13,940
lots from the least gonna check if we

00:16:11,030 --> 00:16:16,100
get a success message after our product

00:16:13,940 --> 00:16:18,380
or offer is added to the product and

00:16:16,100 --> 00:16:21,020
this is how you can test components and

00:16:18,380 --> 00:16:22,840
if it all went too fast it's on get up

00:16:21,020 --> 00:16:25,370
as well of a show the link later

00:16:22,840 --> 00:16:28,460
something else we can do with graph

00:16:25,370 --> 00:16:30,710
Corral is testing or schemas directly so

00:16:28,460 --> 00:16:33,080
if you're familiar with redux for

00:16:30,710 --> 00:16:34,670
example you can test Redux action

00:16:33,080 --> 00:16:37,570
creators directly and see if that

00:16:34,670 --> 00:16:40,070
mutates your reducer correctly and

00:16:37,570 --> 00:16:41,980
schemas we can test with a small upper

00:16:40,070 --> 00:16:44,990
source premier package that is called

00:16:41,980 --> 00:16:47,510
easy graft well tester and with easy

00:16:44,990 --> 00:16:49,490
graph QL tester we can directly test or

00:16:47,510 --> 00:16:51,860
graph well queries imitations against

00:16:49,490 --> 00:16:53,630
the graph guell server as you can see

00:16:51,860 --> 00:16:56,090
it's a small example how we should do

00:16:53,630 --> 00:16:59,930
that so you could just gonna impair the

00:16:56,090 --> 00:17:01,820
easy graph QL tester and you can define

00:16:59,930 --> 00:17:03,290
your schema so either up to nature if

00:17:01,820 --> 00:17:06,050
you scheme on the front end to test on

00:17:03,290 --> 00:17:09,140
the front end or use easy graphical test

00:17:06,050 --> 00:17:11,090
directly on your graph QL server and

00:17:09,140 --> 00:17:12,500
you're just gonna input the schema in

00:17:11,090 --> 00:17:15,400
there and then you can test if your

00:17:12,500 --> 00:17:19,510
query will work and this last exemption

00:17:15,400 --> 00:17:22,120
now you can test directly to the schema

00:17:19,510 --> 00:17:25,370
so this will mean you get the real

00:17:22,120 --> 00:17:27,020
situation because in this case I'm

00:17:25,370 --> 00:17:29,450
importing the schema from my back-end

00:17:27,020 --> 00:17:32,390
graph QL server survivor always need to

00:17:29,450 --> 00:17:34,520
have to serve laughs and you can also

00:17:32,390 --> 00:17:36,470
test with invalid values so in this case

00:17:34,520 --> 00:17:38,810
we're going to test if our mutation

00:17:36,470 --> 00:17:41,090
should return a success message or an

00:17:38,810 --> 00:17:43,910
error message so par example if I would

00:17:41,090 --> 00:17:46,580
insert a wrongfully variable I would

00:17:43,910 --> 00:17:48,290
insert and float my integer then I

00:17:46,580 --> 00:17:51,440
should let you know that my test case

00:17:48,290 --> 00:17:55,160
should fail because the format's of the

00:17:51,440 --> 00:17:59,480
variable isn't a correct one and you can

00:17:55,160 --> 00:18:01,910
do the same for mutation for ya to test

00:17:59,480 --> 00:18:03,470
if it returns you can also use mock

00:18:01,910 --> 00:18:05,840
schemas so instead of your real scheme

00:18:03,470 --> 00:18:07,550
as you can mock them to see if your the

00:18:05,840 --> 00:18:11,000
queries you've defined are really

00:18:07,550 --> 00:18:11,539
working and you can test both stuff in

00:18:11,000 --> 00:18:15,289
this case

00:18:11,539 --> 00:18:16,789
to test if our products yeah for

00:18:15,289 --> 00:18:18,649
products query will return products

00:18:16,789 --> 00:18:21,470
informative array and we're going to

00:18:18,649 --> 00:18:23,929
test it to be true so if you're

00:18:21,470 --> 00:18:26,389
interesting to see more about this this

00:18:23,929 --> 00:18:29,470
project you can find it on my my get up

00:18:26,389 --> 00:18:32,059
here and you will need the actual Apollo

00:18:29,470 --> 00:18:34,399
graphical server running but the link to

00:18:32,059 --> 00:18:37,070
that one is also in the index file I

00:18:34,399 --> 00:18:39,259
believe so you can just go and start to

00:18:37,070 --> 00:18:46,909
cough quell and start testing it in your

00:18:39,259 --> 00:18:50,720
browser yes so if we look at the code

00:18:46,909 --> 00:18:54,799
example again thank you see I've editing

00:18:50,720 --> 00:18:56,809
schema testing a Verity schema testing

00:18:54,799 --> 00:18:58,669
into a different directory because we're

00:18:56,809 --> 00:19:00,229
testing we're not really testing

00:18:58,669 --> 00:19:04,099
components we're just gonna test the for

00:19:00,229 --> 00:19:06,080
queries work so in the component fall so

00:19:04,099 --> 00:19:07,489
this is the form component and we're

00:19:06,080 --> 00:19:10,309
going to test it for actual components

00:19:07,489 --> 00:19:12,440
will render already mock data and inside

00:19:10,309 --> 00:19:16,369
the other file I'm going to test the

00:19:12,440 --> 00:19:18,349
schemas so that's inside this fall at

00:19:16,369 --> 00:19:21,379
first I retrieve the schema from my

00:19:18,349 --> 00:19:23,989
graph QL server which is hosted on code

00:19:21,379 --> 00:19:25,460
sandbox so if you would find the project

00:19:23,989 --> 00:19:28,369
can get up and go to this store this

00:19:25,460 --> 00:19:31,999
link you will find actual polar graph QL

00:19:28,369 --> 00:19:33,499
server I'm using and so important this

00:19:31,999 --> 00:19:38,629
schema and testing against the real-life

00:19:33,499 --> 00:19:39,919
data in this fall where I'm yes where

00:19:38,629 --> 00:19:41,899
I'm import the schema right here or

00:19:39,919 --> 00:19:45,109
input my queries from the components and

00:19:41,899 --> 00:19:47,629
I'm testing against the real data to see

00:19:45,109 --> 00:19:51,710
if it works so my third test would see

00:19:47,629 --> 00:19:53,479
if my query matches everything that I've

00:19:51,710 --> 00:19:55,609
defined my schema which is basically the

00:19:53,479 --> 00:19:57,679
quorum call quell the Keystone makes the

00:19:55,609 --> 00:19:58,820
schema you won't get any results so

00:19:57,679 --> 00:19:59,889
that's something we need to test it

00:19:58,820 --> 00:20:03,109
first

00:19:59,889 --> 00:20:06,710
secondly I will return if the corrected

00:20:03,109 --> 00:20:09,080
data is in right format so product

00:20:06,710 --> 00:20:10,879
should be an array and we can test if it

00:20:09,080 --> 00:20:14,330
really should be an array by having

00:20:10,879 --> 00:20:17,509
these Shia sump shins we want to know if

00:20:14,330 --> 00:20:19,879
the result actually is a result we are

00:20:17,509 --> 00:20:24,440
expecting and in the last one I'm

00:20:19,879 --> 00:20:25,610
testing the actual mutation so I

00:20:24,440 --> 00:20:27,770
described your test

00:20:25,610 --> 00:20:29,780
in the forum component at first I'm

00:20:27,770 --> 00:20:33,530
going to test if my mutation would

00:20:29,780 --> 00:20:35,510
actually return me the offer I just

00:20:33,530 --> 00:20:38,960
inserted we're going to see if the

00:20:35,510 --> 00:20:41,030
violation is true we import our mutation

00:20:38,960 --> 00:20:43,820
and we test it and we're going to see if

00:20:41,030 --> 00:20:45,770
we to turn to this data and it's the

00:20:43,820 --> 00:20:48,380
case is we just saw the test works and

00:20:45,770 --> 00:20:50,720
in a final version I'm going to see if

00:20:48,380 --> 00:20:53,120
our mutation would feel if we insert

00:20:50,720 --> 00:20:55,280
something order for products so you can

00:20:53,120 --> 00:20:59,419
see we've found product Eddie it's to

00:20:55,280 --> 00:21:01,070
find an or schema as a as an integer and

00:20:59,419 --> 00:21:08,059
we've defined it the year as a string so

00:21:01,070 --> 00:21:10,010
this should feel obviously yes so again

00:21:08,059 --> 00:21:12,080
you can find more information on this

00:21:10,010 --> 00:21:16,130
get a purple story to actually have this

00:21:12,080 --> 00:21:17,540
product running and if you want to know

00:21:16,130 --> 00:21:20,419
more about this you can also go to

00:21:17,540 --> 00:21:23,150
Twitter and just ask me a question if

00:21:20,419 --> 00:21:30,679
you would like so thank you very much

00:21:23,150 --> 00:21:33,980
for your time thank you so if you have a

00:21:30,679 --> 00:21:35,720
question raise your hand I mean you have

00:21:33,980 --> 00:21:42,980
a question that was the first we're

00:21:35,720 --> 00:21:45,610
going to ask it just want to look at me

00:21:42,980 --> 00:21:45,610
looking strange

00:21:46,050 --> 00:21:53,370
maybe they understood everything right

00:21:50,600 --> 00:21:55,890
no no questions well if you little bit

00:21:53,370 --> 00:21:57,960
shy maybe you'll be outside of the room

00:21:55,890 --> 00:21:59,910
yeah I will be outside the room and you

00:21:57,960 --> 00:22:01,950
can just go to Twitter or my handle is

00:21:59,910 --> 00:22:04,550
right there in the bottom and you can

00:22:01,950 --> 00:22:08,420
send me a message or just an 8-week

00:22:04,550 --> 00:22:08,420

YouTube URL: https://www.youtube.com/watch?v=IJV1IwIejM0


