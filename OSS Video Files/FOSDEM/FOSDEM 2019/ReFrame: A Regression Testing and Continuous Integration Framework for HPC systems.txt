Title: ReFrame: A Regression Testing and Continuous Integration Framework for HPC systems
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	by Victor Holanda

At: FOSDEM 2019
https://video.fosdem.org/2019/UA2.118/reframe.webm


Regression testing of HPC systems is of crucial importance when it comes to ensure the quality of service offered to the end users. At the same time, it poses a great challenge to the systems and application engineers to continuously maintain regression tests that cover as many aspects as possible of the user experience. In this presentation, we present ReFrame, a new framework for writing regression tests for HPC systems. ReFrame is designed to abstract away the complexity of the interactions with the system and separate the logic of a regression test from the low-level details, which pertain to the system configuration and setup. Regression tests in ReFrame are simple Python classes that specify the basic parameters of the test plus any additional logic. The framework will load the test and send it down a wel-defined pipeline which will take care of its execution. All the system interaction details, such as programming environment switching, compilation, job submission, job status query, sanity checking and performance assessment, are performed by the different pipeline stages. Thanks to its high-level abstractions and modular design, ReFrame can also serve as a tool for continuous integration (CI) of scientific software, complementary to other well-known CI solutions. Finally, we present the use cases of two large HPC centers that have adopted or are now adopting ReFrame for regression testing of their computing facilities. 

Room: UA2.118 (Henriot)
Scheduled start: 2019-02-03 11:15:00+01
Captions: 
	00:00:04,620 --> 00:00:11,100
so welcome everyone before I go into

00:00:08,309 --> 00:00:13,709
what's exactly we frame is and while we

00:00:11,100 --> 00:00:16,440
use it at CSCS I want to give you some

00:00:13,709 --> 00:00:20,150
some idea what what was the background

00:00:16,440 --> 00:00:22,949
that we had and why you use reframe so

00:00:20,150 --> 00:00:25,169
we use we do regression testing a lot

00:00:22,949 --> 00:00:28,410
the CSCS to guarantee quality of service

00:00:25,169 --> 00:00:30,089
so it was really nice to have just a

00:00:28,410 --> 00:00:31,980
precise talk and he was talking about

00:00:30,089 --> 00:00:33,329
the difficulties they have to go into

00:00:31,980 --> 00:00:35,310
the quality of the performance of the

00:00:33,329 --> 00:00:36,900
software and the sanity of the software

00:00:35,310 --> 00:00:39,450
is getting to that correct so that's

00:00:36,900 --> 00:00:41,700
exactly the open-source tool that we can

00:00:39,450 --> 00:00:44,520
provide not only to precise about the

00:00:41,700 --> 00:00:47,880
entire community on how actually solve

00:00:44,520 --> 00:00:50,250
this problem so at the SES because we

00:00:47,880 --> 00:00:53,180
invest a lot on guaranteeing quality of

00:00:50,250 --> 00:00:57,180
service of our computer services we test

00:00:53,180 --> 00:01:02,490
every single computer every day

00:00:57,180 --> 00:01:05,610
we test everything so how you used to do

00:01:02,490 --> 00:01:07,860
that we used to write this big shell

00:01:05,610 --> 00:01:10,109
script that would go into everything and

00:01:07,860 --> 00:01:12,869
test see if the performance was being

00:01:10,109 --> 00:01:14,850
correct its if the numbers that we

00:01:12,869 --> 00:01:17,789
produced correctly and what's really

00:01:14,850 --> 00:01:22,399
tough to maintain because we were doing

00:01:17,789 --> 00:01:23,789
a nice thing but using a not very nice

00:01:22,399 --> 00:01:27,899
soft

00:01:23,789 --> 00:01:30,240
methodology so for that we started to

00:01:27,899 --> 00:01:32,100
develop in a better framework that's

00:01:30,240 --> 00:01:34,109
called reframe that we can actually do

00:01:32,100 --> 00:01:38,520
the testing reframe is actually written

00:01:34,109 --> 00:01:40,700
in Python in Python 3 and we try to make

00:01:38,520 --> 00:01:43,439
it easy for anyone to use it from

00:01:40,700 --> 00:01:46,829
software developers to seasoned

00:01:43,439 --> 00:01:49,170
expressions to any normal user who wants

00:01:46,829 --> 00:01:52,229
you just run our cluster and can test

00:01:49,170 --> 00:01:53,969
their software so we the way that we try

00:01:52,229 --> 00:01:56,459
to do that is basically abstracting away

00:01:53,969 --> 00:01:58,350
our computing systems or the internals

00:01:56,459 --> 00:02:02,819
of the computing systems some things

00:01:58,350 --> 00:02:04,979
that we are difficult to for some users

00:02:02,819 --> 00:02:08,550
to run an HPC systems because we do have

00:02:04,979 --> 00:02:10,470
modules we have different MPI and the

00:02:08,550 --> 00:02:12,569
implement eyes are highly customized for

00:02:10,470 --> 00:02:14,700
that computer know we like that computer

00:02:12,569 --> 00:02:16,709
system and when she change the cluster

00:02:14,700 --> 00:02:17,370
you have to use another MPI because they

00:02:16,709 --> 00:02:19,590
all MPI

00:02:17,370 --> 00:02:21,510
is highly customized for that one so you

00:02:19,590 --> 00:02:25,920
have to be keeping tracking up all these

00:02:21,510 --> 00:02:29,340
things so we try to try to simplify the

00:02:25,920 --> 00:02:32,549
usage of the of the regression testing

00:02:29,340 --> 00:02:34,769
of our testing only frame by abstracting

00:02:32,549 --> 00:02:38,099
away these concepts so that way

00:02:34,769 --> 00:02:39,959
basically the person who is writing the

00:02:38,099 --> 00:02:41,909
checks or if I want to write for

00:02:39,959 --> 00:02:43,349
instance I precise check I don't need to

00:02:41,909 --> 00:02:46,319
think about it I just have to think

00:02:43,349 --> 00:02:49,230
about the logics how will my what will

00:02:46,319 --> 00:02:51,569
my program will need as input what will

00:02:49,230 --> 00:02:53,760
my program leaders output hwacha give it

00:02:51,569 --> 00:02:56,609
an output and how can I measure the

00:02:53,760 --> 00:02:59,819
performance so we have been developing

00:02:56,609 --> 00:03:03,569
with frames internally CSCS since 2016

00:02:59,819 --> 00:03:05,250
we went public and now in 2019 we

00:03:03,569 --> 00:03:09,000
basically have 18 Forks and tell it

00:03:05,250 --> 00:03:10,950
you've got 35 stargazers right last week

00:03:09,000 --> 00:03:12,930
was 32 let's use my sight touch with you

00:03:10,950 --> 00:03:15,060
it's a bit tough to count these things

00:03:12,930 --> 00:03:17,280
because it's all the time being updated

00:03:15,060 --> 00:03:18,629
because people are actually using it and

00:03:17,280 --> 00:03:21,510
one of the reason why people are using

00:03:18,629 --> 00:03:23,250
reframe is because we have a very nice

00:03:21,510 --> 00:03:25,260
design goals one of the design goals we

00:03:23,250 --> 00:03:27,299
have productivity so which means that

00:03:25,260 --> 00:03:29,910
whenever we have a user we report the

00:03:27,299 --> 00:03:32,340
bug and the user the disease bug we can

00:03:29,910 --> 00:03:34,560
test it later what we do we write a test

00:03:32,340 --> 00:03:38,269
so it allows us reframe allow us to

00:03:34,560 --> 00:03:42,060
actually on the fly easily write tests

00:03:38,269 --> 00:03:44,910
because we do have systems from basic

00:03:42,060 --> 00:03:47,250
Linux box with red head installed sent

00:03:44,910 --> 00:03:49,949
to us installed as a sli's installed

00:03:47,250 --> 00:03:52,139
from highly customized Linux like Cray

00:03:49,949 --> 00:03:55,560
systems we want our tests also to be

00:03:52,139 --> 00:03:57,150
portable so we we think a lot about

00:03:55,560 --> 00:04:00,000
portability we don't want to write on

00:03:57,150 --> 00:04:02,579
test on one system and have to rewrite

00:04:00,000 --> 00:04:04,440
it to another system one one thing that

00:04:02,579 --> 00:04:06,810
I like about reframe is that we have

00:04:04,440 --> 00:04:09,299
been running these daily in our systems

00:04:06,810 --> 00:04:11,790
and we have never seen a stack trace of

00:04:09,299 --> 00:04:16,380
Python why because we are real robust so

00:04:11,790 --> 00:04:18,359
we do a highly testing not only of the

00:04:16,380 --> 00:04:20,459
systems but also of refrain so usually

00:04:18,359 --> 00:04:22,949
frame to test we frame one of the key

00:04:20,459 --> 00:04:24,449
features of reframe is actually as I

00:04:22,949 --> 00:04:26,310
said before separation of the program

00:04:24,449 --> 00:04:27,659
environment the system right so you

00:04:26,310 --> 00:04:30,020
don't really have to care much about

00:04:27,659 --> 00:04:31,970
that one thing

00:04:30,020 --> 00:04:36,080
that for those who actually have

00:04:31,970 --> 00:04:38,300
experience with HPC you always have to

00:04:36,080 --> 00:04:40,460
run jobs HPC you don't really logging

00:04:38,300 --> 00:04:42,680
into the compute node you do to a

00:04:40,460 --> 00:04:44,659
scheduler so in general they do what's

00:04:42,680 --> 00:04:46,729
called workload manager so you can ask

00:04:44,659 --> 00:04:48,470
to say I want a thousand compute nodes

00:04:46,729 --> 00:04:50,300
then you get tons of compute nodes and

00:04:48,470 --> 00:04:52,879
then how you run your simulation there

00:04:50,300 --> 00:04:54,590
become a launcher as found in our case

00:04:52,879 --> 00:04:56,569
because users learn and then you're

00:04:54,590 --> 00:05:01,539
gonna run MPI calculations across this

00:04:56,569 --> 00:05:04,699
entire a thousand thousand machines

00:05:01,539 --> 00:05:06,409
compute nodes and some of these a

00:05:04,699 --> 00:05:08,900
thousand compute nodes may be GPU

00:05:06,409 --> 00:05:12,919
enabled we have a pretty big system with

00:05:08,900 --> 00:05:14,750
5300 GPUs and the same system has a

00:05:12,919 --> 00:05:18,319
thousand nine hundred more or less CPU

00:05:14,750 --> 00:05:19,789
only machines so you actually to run in

00:05:18,319 --> 00:05:21,800
one case on the other case you actually

00:05:19,789 --> 00:05:23,240
cycle what's called a partition so you

00:05:21,800 --> 00:05:25,669
have to go to the heap you partition or

00:05:23,240 --> 00:05:27,770
no chip you partition so on roof frame

00:05:25,669 --> 00:05:29,419
we also want to abstract out this

00:05:27,770 --> 00:05:31,789
concept so we don't really want the

00:05:29,419 --> 00:05:33,889
users to be freaking about hey I have to

00:05:31,789 --> 00:05:35,960
be here I have to be there I have to run

00:05:33,889 --> 00:05:40,400
this way this way we just abstract out a

00:05:35,960 --> 00:05:41,960
lot of things one of the the the concept

00:05:40,400 --> 00:05:44,830
that we have also reframes we want to

00:05:41,960 --> 00:05:47,180
guarantee that we have a very complete

00:05:44,830 --> 00:05:49,990
documentation so if you go to a website

00:05:47,180 --> 00:05:52,370
you're gonna see the the reader dogs and

00:05:49,990 --> 00:05:53,870
you're gonna be able to see our

00:05:52,370 --> 00:05:57,830
documentation start to using it so we're

00:05:53,870 --> 00:06:02,060
gonna have tutorials and on computing

00:05:57,830 --> 00:06:03,500
systems on HPC systems we have a lot of

00:06:02,060 --> 00:06:05,870
different people working on them

00:06:03,500 --> 00:06:08,509
for instance I work in the user support

00:06:05,870 --> 00:06:11,240
team and I PhD in chemistry I am NOT a

00:06:08,509 --> 00:06:14,560
computer scientist and how can I be

00:06:11,240 --> 00:06:17,090
developing how can I be using reframe

00:06:14,560 --> 00:06:18,259
the the reason we can do that because we

00:06:17,090 --> 00:06:20,330
abstract out the people who actually

00:06:18,259 --> 00:06:23,719
using reframe from the people who

00:06:20,330 --> 00:06:26,539
actually developing tests we try to make

00:06:23,719 --> 00:06:29,360
easy for everyone who doesn't have a PhD

00:06:26,539 --> 00:06:32,240
in computer science let's say to someone

00:06:29,360 --> 00:06:34,699
who has a minimal knowledge of bash to

00:06:32,240 --> 00:06:36,469
be using it so we have two different

00:06:34,699 --> 00:06:38,240
api's one's called the front end API

00:06:36,469 --> 00:06:39,860
they actually you call how to run

00:06:38,240 --> 00:06:42,289
reframe and we want it to be as simple

00:06:39,860 --> 00:06:44,839
as possible so we only have we

00:06:42,289 --> 00:06:47,539
have some flags but if you want to write

00:06:44,839 --> 00:06:52,099
the Nemo flag you have to do is mine R -

00:06:47,539 --> 00:06:54,409
R and we like the reaming face guy is

00:06:52,099 --> 00:06:57,289
actually in general user wants to run

00:06:54,409 --> 00:07:01,249
refrain or see some straighter but we

00:06:57,289 --> 00:07:04,669
also have a service at the SES that you

00:07:01,249 --> 00:07:06,649
can run refrain to us Jenkins so you can

00:07:04,669 --> 00:07:08,360
have a robot running your code and

00:07:06,649 --> 00:07:10,729
taking precise and checking the

00:07:08,360 --> 00:07:14,360
performance of precise whenever you make

00:07:10,729 --> 00:07:16,330
a pull request for instance we also for

00:07:14,360 --> 00:07:19,129
those who actually are developing

00:07:16,330 --> 00:07:22,279
refrained tests that's not so difficult

00:07:19,129 --> 00:07:25,249
also so what you have to do is basically

00:07:22,279 --> 00:07:28,909
write a Python class and he hair it from

00:07:25,249 --> 00:07:31,939
regression test and decorated with a

00:07:28,909 --> 00:07:34,639
small the critical simple test the

00:07:31,939 --> 00:07:36,439
simple test allows us to basically go

00:07:34,639 --> 00:07:37,430
through what's called the pipeline that

00:07:36,439 --> 00:07:40,069
you show you later

00:07:37,430 --> 00:07:42,229
and also enables you all the

00:07:40,069 --> 00:07:43,759
functionalities internal to the API like

00:07:42,229 --> 00:07:45,949
the sixties abstraction and the

00:07:43,759 --> 00:07:49,759
environment abstraction the environment

00:07:45,949 --> 00:07:51,529
abstraction is in in HPC is not only

00:07:49,759 --> 00:07:53,569
about the variables that you have but

00:07:51,529 --> 00:07:56,629
also about the modules system that you

00:07:53,569 --> 00:08:00,199
have so some some systems have team mode

00:07:56,629 --> 00:08:01,159
some system have l l mod T mode for if

00:08:00,199 --> 00:08:05,569
you don't know what I'm talking about

00:08:01,159 --> 00:08:07,430
that environment environment managers

00:08:05,569 --> 00:08:09,860
module managers where you can actually

00:08:07,430 --> 00:08:11,899
load different versions of software and

00:08:09,860 --> 00:08:13,550
you don't need to have you don't have to

00:08:11,899 --> 00:08:16,039
care about it when you're running a TS

00:08:13,550 --> 00:08:19,490
yes what's the type of of modules you're

00:08:16,039 --> 00:08:21,879
using one thing that we can we say okay

00:08:19,490 --> 00:08:24,050
take these guys are really doing

00:08:21,879 --> 00:08:26,029
abstracting and so this thing must be

00:08:24,050 --> 00:08:28,519
really difficult to use in practice is

00:08:26,029 --> 00:08:30,769
not the simplest I'm talking about in

00:08:28,519 --> 00:08:32,539
general looks like that so okay I'm

00:08:30,769 --> 00:08:34,760
cramping the lines because it I have to

00:08:32,539 --> 00:08:36,589
fit into a slide but as you can see you

00:08:34,760 --> 00:08:39,349
just need to put like a descriptor if

00:08:36,589 --> 00:08:41,389
you want to give a nice name you have

00:08:39,349 --> 00:08:44,050
your class like this we can do this so

00:08:41,389 --> 00:08:46,250
have your class you basically need

00:08:44,050 --> 00:08:48,050
function inheriting from the regression

00:08:46,250 --> 00:08:49,880
test you write the description names

00:08:48,050 --> 00:08:52,579
just to give you a nice description or

00:08:49,880 --> 00:08:53,340
your test - you say I want to run on

00:08:52,579 --> 00:08:55,320
Pete

00:08:53,340 --> 00:08:58,110
ix which is how this because I told you

00:08:55,320 --> 00:09:00,120
we 5300 peas on the GPU part of the

00:08:58,110 --> 00:09:03,540
cluster and then you can say I want to

00:09:00,120 --> 00:09:06,450
test the G the G new compiler the Cray

00:09:03,540 --> 00:09:09,900
compiler and the PGI compiler I can say

00:09:06,450 --> 00:09:12,690
my they put fire of my practices dots

00:09:09,900 --> 00:09:15,990
you fire so it's gonna be like a Nvidia

00:09:12,690 --> 00:09:18,030
CUDA source so we frame identified that

00:09:15,990 --> 00:09:21,360
when you say single source and we call

00:09:18,030 --> 00:09:23,460
the nvcc compiler so I'd advise the

00:09:21,360 --> 00:09:25,590
ending of your single sources encode

00:09:23,460 --> 00:09:27,500
appropriate compiler and we will

00:09:25,590 --> 00:09:31,230
probably compiling these these

00:09:27,500 --> 00:09:33,300
application using the basic flags this -

00:09:31,230 --> 00:09:36,540
all three and use you can give like

00:09:33,300 --> 00:09:38,130
executable options on our systems you

00:09:36,540 --> 00:09:40,770
need to know basically what's the mode

00:09:38,130 --> 00:09:42,690
you have to load for CUDA so but you can

00:09:40,770 --> 00:09:46,800
do a mapping you can always say who the

00:09:42,690 --> 00:09:49,350
toolkit means these module use or that

00:09:46,800 --> 00:09:52,680
or module load that specific module you

00:09:49,350 --> 00:09:54,000
can do mappings and on this big closet

00:09:52,680 --> 00:09:56,010
that I told you that we have just one

00:09:54,000 --> 00:09:58,260
GPU per node so you can do the test with

00:09:56,010 --> 00:10:01,530
one GPU but you can do say you can say

00:09:58,260 --> 00:10:04,620
here like if I am on test on system a do

00:10:01,530 --> 00:10:07,710
two GPUs I'm system B do four GPUs and

00:10:04,620 --> 00:10:09,810
so the way we do much guarantee that we

00:10:07,710 --> 00:10:12,240
have a sanity check guarantee if you

00:10:09,810 --> 00:10:14,460
have like the values that correct we do

00:10:12,240 --> 00:10:17,340
this what's called 70 patterns and you

00:10:14,460 --> 00:10:20,310
strike out extract information from your

00:10:17,340 --> 00:10:22,740
test so in this case if the line time

00:10:20,310 --> 00:10:24,540
for single matrix is found in this TD

00:10:22,740 --> 00:10:27,150
out you're gonna guarantee that was

00:10:24,540 --> 00:10:30,750
passed because actually this is the last

00:10:27,150 --> 00:10:32,160
line of your of your output and then we

00:10:30,750 --> 00:10:33,930
can look at the output and it will say

00:10:32,160 --> 00:10:37,140
that something like performance that was

00:10:33,930 --> 00:10:39,090
in gigaflops per second and then if you

00:10:37,140 --> 00:10:41,340
look for this for this for this line is

00:10:39,090 --> 00:10:43,380
track start out these this pattern

00:10:41,340 --> 00:10:45,120
convert it to a float and then we're

00:10:43,380 --> 00:10:47,310
going to be able to compare so this

00:10:45,120 --> 00:10:50,730
number here 50 is just a dummy number so

00:10:47,310 --> 00:10:54,090
if this number is between 10 percent of

00:10:50,730 --> 00:10:55,680
this 50 we're gonna pass performance so

00:10:54,090 --> 00:10:58,440
as you can see we're just trying to

00:10:55,680 --> 00:11:00,750
abstract away when all the logics are

00:10:58,440 --> 00:11:03,810
doing grab or getting the fringe

00:11:00,750 --> 00:11:05,820
comparing converting to numbers a entry

00:11:03,810 --> 00:11:10,050
frame

00:11:05,820 --> 00:11:12,630
I can say that yes nice this tax is weak

00:11:10,050 --> 00:11:15,180
we came right but do you really use it

00:11:12,630 --> 00:11:16,380
in like anybody will use from a precise

00:11:15,180 --> 00:11:20,310
can I really use for my scientific

00:11:16,380 --> 00:11:22,589
applications yes so we have like a Nazi

00:11:20,310 --> 00:11:25,470
SES that's actually been developed every

00:11:22,589 --> 00:11:28,230
day and they test it and they usually

00:11:25,470 --> 00:11:30,149
make in this case and this is how

00:11:28,230 --> 00:11:34,649
complexity is for them to write a test

00:11:30,149 --> 00:11:36,149
so they say I need see make and I need

00:11:34,649 --> 00:11:38,550
this version of GCC because they were

00:11:36,149 --> 00:11:40,800
specific for this version and I need to

00:11:38,550 --> 00:11:44,310
comply with these options these compile

00:11:40,800 --> 00:11:47,940
options my code and voila they get the

00:11:44,310 --> 00:11:50,880
cold because we are using Python and now

00:11:47,940 --> 00:11:52,500
we can use the amazing computer science

00:11:50,880 --> 00:11:55,410
concepts that we could not use in shell

00:11:52,500 --> 00:11:58,079
one of them is oh oh so I can inherit I

00:11:55,410 --> 00:12:00,630
can say you know what now I have my MPI

00:11:58,079 --> 00:12:03,029
version of the test or my MPI version of

00:12:00,630 --> 00:12:05,670
the test to comply with MPI I need this

00:12:03,029 --> 00:12:08,730
flag so now I have two tests I have the

00:12:05,670 --> 00:12:11,699
previous test that was the basic one

00:12:08,730 --> 00:12:13,800
that was only company for set on and I

00:12:11,699 --> 00:12:16,350
have now a second test that is basically

00:12:13,800 --> 00:12:18,930
doing the MPI version and beginning go

00:12:16,350 --> 00:12:20,880
on we can actually not only a simple

00:12:18,930 --> 00:12:24,000
test on top but we can also have this

00:12:20,880 --> 00:12:25,410
parametric test then I have a factory so

00:12:24,000 --> 00:12:27,810
instead of having actually to write a

00:12:25,410 --> 00:12:29,519
factory class or a factory function to

00:12:27,810 --> 00:12:32,130
spawn several tests I can parametrize

00:12:29,519 --> 00:12:34,319
them so in this case I will

00:12:32,130 --> 00:12:37,350
parameterizing a different test that we

00:12:34,319 --> 00:12:39,000
compile for has well broad architecture

00:12:37,350 --> 00:12:40,769
and a native architecture that can be

00:12:39,000 --> 00:12:44,730
the current one that you are using can

00:12:40,769 --> 00:12:48,149
be any any other architecture right so

00:12:44,730 --> 00:12:50,699
you can see it's really simple to to

00:12:48,149 --> 00:12:53,399
write tests on reframe and the pipeline

00:12:50,699 --> 00:12:56,459
that you get by adding these simple test

00:12:53,399 --> 00:12:59,069
and this parametrize is a very fixed one

00:12:56,459 --> 00:13:01,290
and this this pipeline is is more or

00:12:59,069 --> 00:13:03,779
less the following you start the front

00:13:01,290 --> 00:13:05,970
end you can say reframe - are what we

00:13:03,779 --> 00:13:08,100
frame you do you go into a folder that

00:13:05,970 --> 00:13:11,100
you that you say and then you look at

00:13:08,100 --> 00:13:14,670
all the Python files inside import all

00:13:11,100 --> 00:13:16,439
of them that are reframed tests and then

00:13:14,670 --> 00:13:19,400
it will start running I'm so you're

00:13:16,439 --> 00:13:21,290
going to pick a test and you check hey

00:13:19,400 --> 00:13:23,990
if this stuff meant to be run on this

00:13:21,290 --> 00:13:26,030
system if yes we continue if you know we

00:13:23,990 --> 00:13:27,740
just skip the test and then with the

00:13:26,030 --> 00:13:30,680
same applies to every single every

00:13:27,740 --> 00:13:32,320
single conditions that you can pose we

00:13:30,680 --> 00:13:34,970
can say is this is this that

00:13:32,320 --> 00:13:36,860
proof-positive program environment so in

00:13:34,970 --> 00:13:38,960
my laptop do I have a cray compiler or

00:13:36,860 --> 00:13:40,580
not if I say no I don't have a Cray

00:13:38,960 --> 00:13:41,270
compiler on my laptop I'm gonna skip the

00:13:40,580 --> 00:13:43,250
great test

00:13:41,270 --> 00:13:44,930
I wouldn't go continue to that all to

00:13:43,250 --> 00:13:47,300
the green new test what I have we can go

00:13:44,930 --> 00:13:50,420
to the client test that I have my laptop

00:13:47,300 --> 00:13:51,890
and then this step we actually run on

00:13:50,420 --> 00:13:53,420
the machine that you actually have

00:13:51,890 --> 00:13:55,790
executed on now

00:13:53,420 --> 00:13:58,430
when I walk through the computing Center

00:13:55,790 --> 00:14:01,460
what we have is actually we also have

00:13:58,430 --> 00:14:05,000
these compute nodes right that you spawn

00:14:01,460 --> 00:14:08,510
with that to the scheduler there is a

00:14:05,000 --> 00:14:10,610
cushion so we can so we do the we do

00:14:08,510 --> 00:14:13,160
this odds analysis in a compute node and

00:14:10,610 --> 00:14:14,660
you can run the test or sorry on the

00:14:13,160 --> 00:14:17,150
local node then we can run the test on

00:14:14,660 --> 00:14:20,510
the compute nodes so we take your test

00:14:17,150 --> 00:14:21,950
we verified it's valid we set up the

00:14:20,510 --> 00:14:24,260
environment so you clone will guarantee

00:14:21,950 --> 00:14:27,590
that you run in a sane environment

00:14:24,260 --> 00:14:28,880
that's always equal to the test that you

00:14:27,590 --> 00:14:30,650
have exist at the environment that you

00:14:28,880 --> 00:14:32,480
have is equal to refrain you compile

00:14:30,650 --> 00:14:35,750
your test if it's necessary and response

00:14:32,480 --> 00:14:38,810
test okay my laptop does not have a

00:14:35,750 --> 00:14:41,210
workload manager right my laptop is just

00:14:38,810 --> 00:14:43,370
my laptop I don't want to be installing

00:14:41,210 --> 00:14:44,450
things that they don't mean so one of

00:14:43,370 --> 00:14:47,240
the things that we don't need a workload

00:14:44,450 --> 00:14:49,220
manager at least I don't need it so what

00:14:47,240 --> 00:14:52,400
I do is basically on my laptop I can say

00:14:49,220 --> 00:14:55,070
my workload manager said local scheduler

00:14:52,400 --> 00:14:57,560
so you actually just emit a batch script

00:14:55,070 --> 00:15:00,860
and runs on my local laptop so this way

00:14:57,560 --> 00:15:04,490
we can run from a laptop to Travis to

00:15:00,860 --> 00:15:05,810
our HPC systems one thing that we talked

00:15:04,490 --> 00:15:08,300
when we talk to the people from

00:15:05,810 --> 00:15:10,700
operations they say Sicily means they

00:15:08,300 --> 00:15:13,670
say oh the system is saying for the

00:15:10,700 --> 00:15:16,130
insane means the system is getting the

00:15:13,670 --> 00:15:17,990
correct numbers and getting the quite

00:15:16,130 --> 00:15:20,060
performance on reframe the metrics we

00:15:17,990 --> 00:15:21,260
are be different same for us means that

00:15:20,060 --> 00:15:23,120
we are actually giving the correct

00:15:21,260 --> 00:15:24,890
science which means that I'm given the

00:15:23,120 --> 00:15:26,480
correct number and performance means

00:15:24,890 --> 00:15:28,460
that you actually performing in that

00:15:26,480 --> 00:15:30,650
given range of value that we're

00:15:28,460 --> 00:15:33,059
expecting that bigger flops of that time

00:15:30,650 --> 00:15:35,399
frame so we do

00:15:33,059 --> 00:15:36,989
different steps for checking the

00:15:35,399 --> 00:15:39,719
performance and in check in the same

00:15:36,989 --> 00:15:41,819
vicinity and after if your test has

00:15:39,719 --> 00:15:44,839
passed or not we clean up the stage and

00:15:41,819 --> 00:15:47,309
continue and then report at the end well

00:15:44,839 --> 00:15:49,349
one way that you can do what one type of

00:15:47,309 --> 00:15:51,239
test that you can do is that you can

00:15:49,349 --> 00:15:53,339
compile own tests if you don't want to

00:15:51,239 --> 00:15:55,979
be running anything if I want to compile

00:15:53,339 --> 00:15:57,479
a library you can compile it if you want

00:15:55,979 --> 00:15:58,739
to run on it test it because you have

00:15:57,479 --> 00:16:00,659
already compiled I don't know an

00:15:58,739 --> 00:16:04,019
application your computer can run it

00:16:00,659 --> 00:16:06,329
only and you can so we have helped the

00:16:04,019 --> 00:16:10,079
user we have already predefined places

00:16:06,329 --> 00:16:12,569
that you can do that the way that you

00:16:10,079 --> 00:16:17,129
can actually define what's the the paths

00:16:12,569 --> 00:16:19,379
that you have where sex is - II come

00:16:17,129 --> 00:16:21,989
online but you can also define different

00:16:19,379 --> 00:16:25,199
configuration files to actually define

00:16:21,989 --> 00:16:27,749
what is your laptop what is HPC Center

00:16:25,199 --> 00:16:29,369
and what is the other edge pieces that

00:16:27,749 --> 00:16:32,609
you are running so this configuration

00:16:29,369 --> 00:16:34,469
file allows us to map different systems

00:16:32,609 --> 00:16:36,659
I run the same test on different systems

00:16:34,469 --> 00:16:39,149
so how does it look like when you run

00:16:36,659 --> 00:16:40,799
your frame it looked like this basically

00:16:39,149 --> 00:16:43,919
if you have passed all the tests and you

00:16:40,799 --> 00:16:46,319
just say run ok past run ok passed so I

00:16:43,919 --> 00:16:48,389
can run on prey I can run you know like

00:16:46,319 --> 00:16:50,669
example test for instance if something

00:16:48,389 --> 00:16:53,789
doesn't doesn't pass what happens that

00:16:50,669 --> 00:16:55,529
if you run you say failed and at the end

00:16:53,789 --> 00:16:57,809
you say the entire regression failed

00:16:55,529 --> 00:16:59,609
with one test case and then you could

00:16:57,809 --> 00:17:01,859
say report a failure in this case I just

00:16:59,609 --> 00:17:03,779
run one test one check so you only see

00:17:01,859 --> 00:17:05,220
one failure here but you can still see

00:17:03,779 --> 00:17:08,579
the reason why it was very much

00:17:05,220 --> 00:17:10,439
performance so it passionately and the

00:17:08,579 --> 00:17:13,049
reason is because these number here is

00:17:10,439 --> 00:17:16,439
beyond the range that we have defined

00:17:13,049 --> 00:17:19,589
the reference range right one of the

00:17:16,439 --> 00:17:22,769
nice things for HPC centers is that we

00:17:19,589 --> 00:17:24,990
care about the users a lot and by caring

00:17:22,769 --> 00:17:27,480
about the users we need to guarantee

00:17:24,990 --> 00:17:30,059
that we never use the report an error we

00:17:27,480 --> 00:17:32,549
can identify the reason why that means

00:17:30,059 --> 00:17:34,740
that we save a lot of logs so at CSI

00:17:32,549 --> 00:17:36,710
specifically we have a centralized login

00:17:34,740 --> 00:17:39,179
service that we save our seas logs and

00:17:36,710 --> 00:17:41,909
reframe can also send to that syslog

00:17:39,179 --> 00:17:42,960
so we can send all the performance of

00:17:41,909 --> 00:17:46,440
our applications that we are running

00:17:42,960 --> 00:17:48,659
daily at CSS to this

00:17:46,440 --> 00:17:50,850
lies and plot graphs for instance like

00:17:48,659 --> 00:17:54,690
as you can see this is basically the

00:17:50,850 --> 00:17:56,340
logs of refrain execution of one

00:17:54,690 --> 00:17:58,320
application it's called Amber running

00:17:56,340 --> 00:18:00,389
the GPU and is the sepia version they

00:17:58,320 --> 00:18:02,759
see a bit fruit weights then we can

00:18:00,389 --> 00:18:04,950
stand why and we can report why it was a

00:18:02,759 --> 00:18:08,039
smaller or why it was higher that we can

00:18:04,950 --> 00:18:10,529
understand the usage that we have for

00:18:08,039 --> 00:18:12,809
referring inside CSCS now's national

00:18:10,529 --> 00:18:14,580
computer center is basically we run

00:18:12,809 --> 00:18:15,960
throughout the three majors collisions

00:18:14,580 --> 00:18:18,259
that we have that app it's time good

00:18:15,960 --> 00:18:21,899
sketch and Leoni pitch deities way

00:18:18,259 --> 00:18:24,149
anyone can access to project bits cache

00:18:21,899 --> 00:18:28,350
is the one that we do the climate

00:18:24,149 --> 00:18:29,789
calculation so the militias that say if

00:18:28,350 --> 00:18:32,129
there are really not rain they are done

00:18:29,789 --> 00:18:34,350
now center and the Leone is a private

00:18:32,129 --> 00:18:36,690
question from a custom from the customer

00:18:34,350 --> 00:18:38,759
so they're on the street quest we run

00:18:36,690 --> 00:18:40,620
what's called production test that told

00:18:38,759 --> 00:18:43,200
you that we run daily maintenance tests

00:18:40,620 --> 00:18:45,149
that we basically run before doing an

00:18:43,200 --> 00:18:46,919
applicator in the system and after doing

00:18:45,149 --> 00:18:49,950
have to get the system and what you call

00:18:46,919 --> 00:18:52,139
diagnostics when a note goes bad we run

00:18:49,950 --> 00:18:53,970
some tests to bring it back before and

00:18:52,139 --> 00:18:55,799
why you do that because we have seen

00:18:53,970 --> 00:18:58,230
really nice things with reframe that

00:18:55,799 --> 00:19:01,169
allows us to probe and improve the

00:18:58,230 --> 00:19:02,820
quality of services sometimes we before

00:19:01,169 --> 00:19:04,590
the upgrade the application is running

00:19:02,820 --> 00:19:06,809
over given performance after the upgrade

00:19:04,590 --> 00:19:09,269
the application drops performance or

00:19:06,809 --> 00:19:10,889
increase performance so then we go

00:19:09,269 --> 00:19:12,330
investigate what the reason why and by

00:19:10,889 --> 00:19:14,370
short of the case we can bring the

00:19:12,330 --> 00:19:16,110
performance up back to the original and

00:19:14,370 --> 00:19:17,850
if we didn't have reframe to actually

00:19:16,110 --> 00:19:19,500
monitor that the performance will be bad

00:19:17,850 --> 00:19:22,289
and we wouldn't know this on the user

00:19:19,500 --> 00:19:24,539
will be complaining so the way we do

00:19:22,289 --> 00:19:26,580
that you stole janky so reframes is

00:19:24,539 --> 00:19:28,679
taking from Jenkins and then we can see

00:19:26,580 --> 00:19:30,509
that the nice thing about jank is that

00:19:28,679 --> 00:19:32,940
you have all these nice

00:19:30,509 --> 00:19:35,159
interfaces that we can we don't need to

00:19:32,940 --> 00:19:39,240
we don't need to care about login to the

00:19:35,159 --> 00:19:43,740
system we can just look to the web

00:19:39,240 --> 00:19:45,929
browser so we like it very much because

00:19:43,740 --> 00:19:48,360
it guarantees the quality of services of

00:19:45,929 --> 00:19:51,690
our systems and now the application that

00:19:48,360 --> 00:19:55,590
we support but we also want to empower

00:19:51,690 --> 00:19:57,659
users so at CSS we have a CI service so

00:19:55,590 --> 00:19:58,740
you can apply for computers computer

00:19:57,659 --> 00:20:01,289
time at CSC

00:19:58,740 --> 00:20:02,039
apply for our CI service there and then

00:20:01,289 --> 00:20:04,890
be running

00:20:02,039 --> 00:20:08,309
let's give example precise every day and

00:20:04,890 --> 00:20:11,850
test if it was performing and at our at

00:20:08,309 --> 00:20:14,070
a real supercomputing Center for that we

00:20:11,850 --> 00:20:16,049
have actually integrated tested

00:20:14,070 --> 00:20:20,070
reframing integrations not only in our

00:20:16,049 --> 00:20:21,990
in our CI service but also on public

00:20:20,070 --> 00:20:24,000
services like Travis for instance this

00:20:21,990 --> 00:20:26,130
way we allow you to be developing on

00:20:24,000 --> 00:20:28,679
your laptop texting reframe on your

00:20:26,130 --> 00:20:31,380
local laptop making the pull request to

00:20:28,679 --> 00:20:33,270
get her working on Travis the same test

00:20:31,380 --> 00:20:35,400
that you have written for your laptop

00:20:33,270 --> 00:20:37,020
and bring in the same test to our

00:20:35,400 --> 00:20:41,460
computing center so your cross

00:20:37,020 --> 00:20:44,100
boundaries passionate and internally we

00:20:41,460 --> 00:20:49,679
use Jenkins so the usage is the same

00:20:44,100 --> 00:20:51,630
that we have for all for all on test

00:20:49,679 --> 00:20:54,059
right so for us it's really nice because

00:20:51,630 --> 00:20:55,980
we can debug in the same interface so

00:20:54,059 --> 00:20:58,049
this is how it looks like internally at

00:20:55,980 --> 00:21:00,330
CSS and as you know this is how it

00:20:58,049 --> 00:21:02,400
looked like on Travis right so we can

00:21:00,330 --> 00:21:05,280
actually have a nice integration and in

00:21:02,400 --> 00:21:06,840
all these cases so just to conclude I

00:21:05,280 --> 00:21:09,870
know I speak very fast and I have a

00:21:06,840 --> 00:21:12,120
spoken very fast but just to summarize

00:21:09,870 --> 00:21:16,020
the take home message about what refrain

00:21:12,120 --> 00:21:18,570
refrain is a regression test framework

00:21:16,020 --> 00:21:24,510
that allows us to guarantee quality of

00:21:18,570 --> 00:21:26,940
our software and written in Python 3 it

00:21:24,510 --> 00:21:29,880
can be portable across different

00:21:26,940 --> 00:21:33,000
computing systems from your laptop to

00:21:29,880 --> 00:21:36,890
HPC systems can be used in different HPC

00:21:33,000 --> 00:21:39,750
systems and gives you a nice way to

00:21:36,890 --> 00:21:42,809
verify where you have failed right to

00:21:39,750 --> 00:21:45,330
get compressive reports one more thing

00:21:42,809 --> 00:21:47,760
that we are missing or reframe is the

00:21:45,330 --> 00:21:50,250
pendency of tests so you can say test a

00:21:47,760 --> 00:21:52,919
dependent SB which depends on taxi

00:21:50,250 --> 00:21:56,690
setsuna it's on our future directional

00:21:52,919 --> 00:22:00,419
world map and we have support to run any

00:21:56,690 --> 00:22:02,700
common line inside we frame but we only

00:22:00,419 --> 00:22:04,980
say that we support something if the

00:22:02,700 --> 00:22:08,730
usage of that thing is really simple so

00:22:04,980 --> 00:22:10,649
today we do support container CSS we run

00:22:08,730 --> 00:22:12,220
container testers yes yes but we don't

00:22:10,649 --> 00:22:15,640
say we support containers

00:22:12,220 --> 00:22:17,409
the users you write too much commands we

00:22:15,640 --> 00:22:19,240
want we are working on simplified

00:22:17,409 --> 00:22:21,280
interface so you can say this is my

00:22:19,240 --> 00:22:23,770
container this is what I want to run and

00:22:21,280 --> 00:22:26,230
run it to make to make everybody's life

00:22:23,770 --> 00:22:27,669
easy and we have been asked by one

00:22:26,230 --> 00:22:30,549
computing Center to have what's called

00:22:27,669 --> 00:22:33,059
benchmarking mode so we can stress the

00:22:30,549 --> 00:22:35,230
system and get different reports only

00:22:33,059 --> 00:22:36,909
but this is very specific to

00:22:35,230 --> 00:22:38,980
supercomputing where you want to take

00:22:36,909 --> 00:22:43,570
you a machine want to stress to the

00:22:38,980 --> 00:22:45,820
limits so we have some partners that we

00:22:43,570 --> 00:22:47,470
have been using me frame as you can see

00:22:45,820 --> 00:22:48,880
and the majority of the non

00:22:47,470 --> 00:22:51,429
supercomputing centers but you have some

00:22:48,880 --> 00:22:53,919
companies involved and if you using me

00:22:51,429 --> 00:22:55,960
framing any haven't told us please tell

00:22:53,919 --> 00:22:59,260
us because we have many people using it

00:22:55,960 --> 00:23:00,940
and we that we didn't we didn't know so

00:22:59,260 --> 00:23:02,530
we I want to acknowledge the team that

00:23:00,940 --> 00:23:04,840
has been developed reframe in telling

00:23:02,530 --> 00:23:07,450
yourself yes as you can see we have a

00:23:04,840 --> 00:23:08,950
lot of people so with because we frame

00:23:07,450 --> 00:23:11,919
in regression test is very important for

00:23:08,950 --> 00:23:14,080
us so this is a project I was not going

00:23:11,919 --> 00:23:17,190
to go away in the near future for sure

00:23:14,080 --> 00:23:19,600
because HPC centers they do require

00:23:17,190 --> 00:23:21,520
regression testing with that I want to

00:23:19,600 --> 00:23:22,710
thank you for your attention and any

00:23:21,520 --> 00:23:29,890
questions

00:23:22,710 --> 00:23:29,890
[Applause]

00:23:33,490 --> 00:23:36,490
yep

00:23:38,190 --> 00:23:41,390
[Music]

00:23:49,050 --> 00:23:54,100
yeah so the question was is it fairly

00:23:51,700 --> 00:23:57,460
stood you can only write tests in Python

00:23:54,100 --> 00:24:00,160
actually no I mean this test is listed

00:23:57,460 --> 00:24:02,380
actually in the the the - itself in

00:24:00,160 --> 00:24:03,910
reframes it in Python but these

00:24:02,380 --> 00:24:05,830
applications that is our any video

00:24:03,910 --> 00:24:07,420
application right so you can say I wanna

00:24:05,830 --> 00:24:12,190
run this script just put the script

00:24:07,420 --> 00:24:14,710
there and you gonna run the script yeah

00:24:12,190 --> 00:24:17,630
yeah you still have to write rap these

00:24:14,710 --> 00:24:22,670
these interface yes

00:24:17,630 --> 00:24:22,670
[Music]

00:24:25,470 --> 00:24:28,589
[Music]

00:24:41,360 --> 00:24:46,100
so the comment was basically that by

00:24:44,150 --> 00:24:48,080
adding DZ step of writing the class may

00:24:46,100 --> 00:24:50,270
add some complexity right because you

00:24:48,080 --> 00:24:53,000
just had the circuit before and now you

00:24:50,270 --> 00:24:56,720
don't have it yeah this is true in the

00:24:53,000 --> 00:24:58,370
beginning of reframe by 2016 we we share

00:24:56,720 --> 00:25:00,500
the reframe a bit with operations and I

00:24:58,370 --> 00:25:02,930
said though this is very very difficult

00:25:00,500 --> 00:25:04,880
to use this is like we don't have to

00:25:02,930 --> 00:25:06,800
have a PhD in computer science to use it

00:25:04,880 --> 00:25:09,530
because what's very difficult to use so

00:25:06,800 --> 00:25:11,560
we are slowly and incremental in the

00:25:09,530 --> 00:25:14,870
interface to make it as easy as possible

00:25:11,560 --> 00:25:16,910
right so we have some some internal

00:25:14,870 --> 00:25:19,990
ideas that I don't know if I can share

00:25:16,910 --> 00:25:24,350
about simplify these and using different

00:25:19,990 --> 00:25:26,930
input methods but it's not there yet

00:25:24,350 --> 00:25:30,140
it's down roadmap but it's not in the

00:25:26,930 --> 00:25:32,390
near future and roadmap so yes today's

00:25:30,140 --> 00:25:35,540
do you have to do some Python to have it

00:25:32,390 --> 00:25:40,030
yeah you have this layer pipe right in

00:25:35,540 --> 00:25:40,030
there yeah yeah

00:25:41,890 --> 00:25:47,720
so just one comment from vassilis Delhi

00:25:44,390 --> 00:25:52,309
developer briefing so yeah I mean as you

00:25:47,720 --> 00:25:54,350
said it's it's it seems like like extra

00:25:52,309 --> 00:25:57,350
complexity to write Python class around

00:25:54,350 --> 00:25:59,570
your test but if you just have a single

00:25:57,350 --> 00:26:02,690
type of system to test then that's fine

00:25:59,570 --> 00:26:05,299
go for a shell script but imagine you

00:26:02,690 --> 00:26:07,640
have to test different on different HP

00:26:05,299 --> 00:26:12,049
systems then the complexity really

00:26:07,640 --> 00:26:14,270
becomes much higher and you want to

00:26:12,049 --> 00:26:15,860
abstract this away for example you don't

00:26:14,270 --> 00:26:19,250
we're going to have in your script the

00:26:15,860 --> 00:26:22,610
logic of did my job finished

00:26:19,250 --> 00:26:25,130
when did they finish we have examples of

00:26:22,610 --> 00:26:27,110
people developing software and they have

00:26:25,130 --> 00:26:31,039
ended up writing a thousands of line of

00:26:27,110 --> 00:26:32,720
bar script just doing stuff that we're

00:26:31,039 --> 00:26:35,030
handling by the framework and they could

00:26:32,720 --> 00:26:37,820
do the same stuff with plenty lines of

00:26:35,030 --> 00:26:40,100
Python code because we have supported

00:26:37,820 --> 00:26:42,740
the system part versus the logic of the

00:26:40,100 --> 00:26:44,570
test that's the key advantage yes I

00:26:42,740 --> 00:26:46,460
agree you have to learn a bit of Python

00:26:44,570 --> 00:26:48,620
write something with in the longer term

00:26:46,460 --> 00:26:53,350
and depending on what you want to do

00:26:48,620 --> 00:26:53,350
then it's it can really untie your hands

00:26:53,890 --> 00:26:57,460
any other questions

00:26:58,500 --> 00:27:05,829
No thank you very much

00:27:02,190 --> 00:27:05,829

YouTube URL: https://www.youtube.com/watch?v=L5eKHCAcPHI


