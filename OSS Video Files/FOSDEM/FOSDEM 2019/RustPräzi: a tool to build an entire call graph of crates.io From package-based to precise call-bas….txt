Title: RustPräzi: a tool to build an entire call graph of crates.io From package-based to precise call-bas…
Publication date: 2019-02-08
Playlist: FOSDEM 2019
Description: 
	RustPräzi: a tool to build an entire call graph of crates.io From package-based to precise call-based dependency network analysis
by Joseph Hejderup

At: FOSDEM 2019
https://video.fosdem.org/2019/UD2.208/rust_praezi.webm


Which crates call a vulnerable function? Which deprecated functions are central to crates.io and should not be deleted? Am I breaking important clients and their dependencies with my new release? These are questions that package publishers and owners of package repositories crave for answers to. To solve this problem, we created RustPräzi: a call-based dependency network that represents a gigantic single large versioned call graph of all crates.io packages. 

In this talk, I will describe how RustPräzi is developed, the challenges we faced while compiling the entire crates.io and the future directions. Our goal is to make RustPräzi a community effort that can help in maintaining the stability of crates.io. For example, bad releases which may negatively impact crates.io can be detected and avoided. 

Room: UD2.208 (Decroly)
Scheduled start: 2019-02-03 10:20:00+01
Captions: 
	00:00:04,640 --> 00:00:10,670
and so we are gonna start this is like

00:00:07,550 --> 00:00:13,309
our third poll cover today Joseph is

00:00:10,670 --> 00:00:17,090
going to introduce himself first and

00:00:13,309 --> 00:00:25,250
then is to call us crazy so a large

00:00:17,090 --> 00:00:26,900
Plaza Warren applause - all right so

00:00:25,250 --> 00:00:29,689
today I'm going to talk about how to

00:00:26,900 --> 00:00:32,150
actually be like gigantic global cool

00:00:29,689 --> 00:00:33,800
drop of Chris Rio so my name is Joseph

00:00:32,150 --> 00:00:36,470
hey drew and this is work that I've done

00:00:33,800 --> 00:00:38,059
together with George's buzios and more

00:00:36,470 --> 00:00:40,040
speller so they are also sitting here in

00:00:38,059 --> 00:00:42,280
the audience you can identify them by

00:00:40,040 --> 00:00:44,239
the shirt that I'm wearing

00:00:42,280 --> 00:00:46,790
so well just wondering what does

00:00:44,239 --> 00:00:49,519
actually rust-red C stand for it comes

00:00:46,790 --> 00:00:52,250
from the word classy only in German

00:00:49,519 --> 00:00:54,440
which is in English precision and I

00:00:52,250 --> 00:00:56,629
myself know German but more Systrom so

00:00:54,440 --> 00:01:01,339
when he helped me get you'd be supported

00:00:56,629 --> 00:01:03,379
the wonderful name so - totally by

00:01:01,339 --> 00:01:06,650
myself so I'm when I'm not here actually

00:01:03,379 --> 00:01:08,660
had forced them I'm a PhD student at tu

00:01:06,650 --> 00:01:10,910
Delft which is a Technical University at

00:01:08,660 --> 00:01:14,510
in Netherlands it's actually in a small

00:01:10,910 --> 00:01:16,340
town and and what I actually do day to

00:01:14,510 --> 00:01:18,980
day basis that I work on dependency

00:01:16,340 --> 00:01:21,740
management problems so I so one of the

00:01:18,980 --> 00:01:23,660
products of course is raw spritzee but I

00:01:21,740 --> 00:01:25,790
mostly into under siding practices and

00:01:23,660 --> 00:01:29,200
where we can actually do the Paris event

00:01:25,790 --> 00:01:31,850
more pleasant than better for developers

00:01:29,200 --> 00:01:34,520
and if I was a PhD student I actually

00:01:31,850 --> 00:01:37,220
worked on pull request fertilization and

00:01:34,520 --> 00:01:40,640
that was a Lee developer startup don't

00:01:37,220 --> 00:01:42,770
conduct so before we dive into actually

00:01:40,640 --> 00:01:44,480
the idea of building a gigantic

00:01:42,770 --> 00:01:47,360
autograph I was thinking we can actually

00:01:44,480 --> 00:01:49,760
revisit a bit what dependency checkers

00:01:47,360 --> 00:01:52,220
or dependency man is or how defense the

00:01:49,760 --> 00:01:54,080
checker works as just a question how

00:01:52,220 --> 00:01:57,830
many of you do use a dependency checker

00:01:54,080 --> 00:02:00,200
in general any hats okay so there are

00:01:57,830 --> 00:02:02,390
quite a few but I just gave up its

00:02:00,200 --> 00:02:05,900
introduction on how it actually works so

00:02:02,390 --> 00:02:07,989
over here I have a cargo dot Tamil file

00:02:05,900 --> 00:02:10,099
with some dependencies specified and

00:02:07,989 --> 00:02:12,260
over here you can see that some of them

00:02:10,099 --> 00:02:15,770
actually have a version range to it by

00:02:12,260 --> 00:02:17,830
the tilde or caret symbol and when we

00:02:15,770 --> 00:02:19,750
let's say like want to

00:02:17,830 --> 00:02:22,060
do some type of security checking or

00:02:19,750 --> 00:02:25,600
find out whether dependencies were noble

00:02:22,060 --> 00:02:29,200
or has some license conflict we first

00:02:25,600 --> 00:02:32,940
resolve this diversion and after that we

00:02:29,200 --> 00:02:34,990
actually build a dependency tree and

00:02:32,940 --> 00:02:37,780
this is basically like the top level

00:02:34,990 --> 00:02:39,730
dependencies but actually we do have

00:02:37,780 --> 00:02:41,740
more dependencies that actually depend

00:02:39,730 --> 00:02:45,400
on those packages that are specified in

00:02:41,740 --> 00:02:47,770
the cargo door table file and as you can

00:02:45,400 --> 00:02:49,450
see I didn't go further but this is

00:02:47,770 --> 00:02:53,380
generally how our dependency tree looked

00:02:49,450 --> 00:02:56,890
like and in let's say like academia we

00:02:53,380 --> 00:03:00,040
usually will depends in that to actually

00:02:56,890 --> 00:03:01,870
understand how package repositories work

00:03:00,040 --> 00:03:04,360
like and maybe also understand problems

00:03:01,870 --> 00:03:07,240
like the left had incident so over here

00:03:04,360 --> 00:03:10,840
I have three packages so one is package

00:03:07,240 --> 00:03:14,350
a B and C and what we do is that we join

00:03:10,840 --> 00:03:16,030
them based on the same package version

00:03:14,350 --> 00:03:18,459
name and this way for instance you can

00:03:16,030 --> 00:03:19,870
ask like for those who depend on left

00:03:18,459 --> 00:03:23,730
package how many of them would be

00:03:19,870 --> 00:03:26,530
affected if that one will be removed and

00:03:23,730 --> 00:03:31,800
as I said we will bring those basically

00:03:26,530 --> 00:03:31,800
version together into a single Network

00:03:32,100 --> 00:03:40,690
and then we have coal graphs and here I

00:03:36,820 --> 00:03:42,970
have a sample code probably pseudo not

00:03:40,690 --> 00:03:46,420
exactly versatile maybe and that

00:03:42,970 --> 00:03:50,080
actually looks into what is sorry that

00:03:46,420 --> 00:03:52,320
actually takes it receives notifications

00:03:50,080 --> 00:03:54,760
but we don't actually do nothing with it

00:03:52,320 --> 00:03:57,370
so how do we build a coal graph in this

00:03:54,760 --> 00:03:59,560
code well the first thing that we do is

00:03:57,370 --> 00:04:01,720
we identify all the function calls and

00:03:59,560 --> 00:04:06,010
also the function definitions so we have

00:04:01,720 --> 00:04:09,370
like is like the main function and also

00:04:06,010 --> 00:04:13,750
like is ready and from this we look at

00:04:09,370 --> 00:04:17,590
who calls each other and then we get a

00:04:13,750 --> 00:04:19,930
call graph like this and in rust we can

00:04:17,590 --> 00:04:22,960
actually do this using for instance like

00:04:19,930 --> 00:04:25,900
the LLVM iron core which was mentioned

00:04:22,960 --> 00:04:28,030
in the previous talk and so you can

00:04:25,900 --> 00:04:32,370
first use the LLVM opt opt

00:04:28,030 --> 00:04:32,370
tool to actually generate a whole graph

00:04:33,129 --> 00:04:36,970
but then all right least likely so when

00:04:35,560 --> 00:04:39,220
the so one problem is that when you

00:04:36,970 --> 00:04:41,439
analyze programs you only get partial of

00:04:39,220 --> 00:04:42,909
it and no idea is to actually go beyond

00:04:41,439 --> 00:04:45,340
a single program actually into the

00:04:42,909 --> 00:04:47,340
dependencies and get the full picture of

00:04:45,340 --> 00:04:50,919
actually how all functions are called

00:04:47,340 --> 00:04:53,020
so air of course we have example with

00:04:50,919 --> 00:04:55,360
the connection in your own app but we

00:04:53,020 --> 00:04:57,370
can also look at what - what functions

00:04:55,360 --> 00:04:59,909
do they also call there a connection

00:04:57,370 --> 00:05:02,199
function so we see every like it goes

00:04:59,909 --> 00:05:07,810
something like request and that one is

00:05:02,199 --> 00:05:10,270
like Network link freezes and yeah and

00:05:07,810 --> 00:05:12,639
then the second part that we do it these

00:05:10,270 --> 00:05:14,669
days that not only do we only capture

00:05:12,639 --> 00:05:19,000
the functions of it but we also

00:05:14,669 --> 00:05:21,490
annotated 50 versions and by doing so we

00:05:19,000 --> 00:05:24,699
can merge two concepts together which is

00:05:21,490 --> 00:05:26,500
the dependency network and the

00:05:24,699 --> 00:05:28,870
colegrove's and together we get

00:05:26,500 --> 00:05:33,490
something called a coal-based dependency

00:05:28,870 --> 00:05:36,219
network so you might wondering why

00:05:33,490 --> 00:05:40,629
should we do all of this in the

00:05:36,219 --> 00:05:42,490
beginning well as library maintainer or

00:05:40,629 --> 00:05:44,159
even if you own something like crazy

00:05:42,490 --> 00:05:47,500
diode you might be interested to know

00:05:44,159 --> 00:05:52,330
sort of things what's happening in the

00:05:47,500 --> 00:05:53,889
community and so for instance like this

00:05:52,330 --> 00:05:57,370
is of course this doesn't really exist

00:05:53,889 --> 00:05:58,990
this is just a vision so you might let's

00:05:57,370 --> 00:06:00,580
say like it's - lets see and then

00:05:58,990 --> 00:06:02,949
everyone might want to publish a new

00:06:00,580 --> 00:06:08,319
version but then when you run it you get

00:06:02,949 --> 00:06:09,789
the faint and yeah so that I gotta

00:06:08,319 --> 00:06:11,409
forget would you remove the deprecated

00:06:09,789 --> 00:06:15,009
function but then when we look at it why

00:06:11,409 --> 00:06:17,589
did it get failed well it's because you

00:06:15,009 --> 00:06:20,440
wanted to publish something that will

00:06:17,589 --> 00:06:22,690
affect 15% of personnel and a good idea

00:06:20,440 --> 00:06:24,669
here could be that instead of making

00:06:22,690 --> 00:06:27,099
this as a problem photos would depend on

00:06:24,669 --> 00:06:28,870
your library it can be put on a let's

00:06:27,099 --> 00:06:31,960
say like on hold and maybe some further

00:06:28,870 --> 00:06:33,129
analysis can be made on this and then as

00:06:31,960 --> 00:06:35,289
an ex-officer like there may be

00:06:33,129 --> 00:06:39,520
delimited threshold is 2% that you're

00:06:35,289 --> 00:06:40,810
allowed to break in Chris that IO and I

00:06:39,520 --> 00:06:43,000
free so you can also like analyze

00:06:40,810 --> 00:06:44,740
adoption so here I had like two versions

00:06:43,000 --> 00:06:47,740
so you can see for instance when you

00:06:44,740 --> 00:06:49,720
your new version that from today and

00:06:47,740 --> 00:06:53,020
looking back one week you can see that

00:06:49,720 --> 00:06:56,680
there are my 5% less that are using your

00:06:53,020 --> 00:07:02,740
version of Xero 5.0 and there are 12%

00:06:56,680 --> 00:07:04,810
model to using 0.18 and they also many

00:07:02,740 --> 00:07:07,110
more applications like for you select

00:07:04,810 --> 00:07:09,190
health aspects maybe also licensing

00:07:07,110 --> 00:07:11,320
security and also maybe we can learn

00:07:09,190 --> 00:07:17,290
coal patents in general that can be for

00:07:11,320 --> 00:07:19,420
education purposes or other aspects so

00:07:17,290 --> 00:07:20,980
the other question is like okay this may

00:07:19,420 --> 00:07:24,220
be looks really cool but how do we

00:07:20,980 --> 00:07:27,220
actually turn crazy oil into a gigantic

00:07:24,220 --> 00:07:29,020
goal graph it might sound simple on

00:07:27,220 --> 00:07:32,160
paper but actually is much more

00:07:29,020 --> 00:07:35,860
difficult than that so the first thing

00:07:32,160 --> 00:07:38,620
how do we actually first compile 22,000

00:07:35,860 --> 00:07:41,050
packages because in the corridor

00:07:38,620 --> 00:07:43,060
zombified you don't really know what

00:07:41,050 --> 00:07:45,010
compiler version is compatible but also

00:07:43,060 --> 00:07:47,260
which architecture freezes because some

00:07:45,010 --> 00:07:50,260
packages of Windows some are for OSX

00:07:47,260 --> 00:07:52,660
somewhere for embedded devices so it's

00:07:50,260 --> 00:07:54,070
not all a trivial and then also the

00:07:52,660 --> 00:07:56,410
other part is what is actually their

00:07:54,070 --> 00:07:58,440
entry point what is what represents a

00:07:56,410 --> 00:08:00,550
package should it be the library

00:07:58,440 --> 00:08:05,490
component should it also be the binary

00:08:00,550 --> 00:08:08,710
etc so is not that simple and the other

00:08:05,490 --> 00:08:10,540
aspect is the version resolution as you

00:08:08,710 --> 00:08:14,110
can see with the version range there are

00:08:10,540 --> 00:08:16,840
time dependent if you solve a package

00:08:14,110 --> 00:08:19,090
today and you do it one week later it

00:08:16,840 --> 00:08:21,100
might be completely different and this

00:08:19,090 --> 00:08:25,000
is not an this is also a problem that

00:08:21,100 --> 00:08:27,550
affects how the the complete graph looks

00:08:25,000 --> 00:08:29,440
like in the end and then with coal per

00:08:27,550 --> 00:08:33,270
week all graphs a congress or an

00:08:29,440 --> 00:08:35,890
approximation of how a program is called

00:08:33,270 --> 00:08:38,680
but there are two important aspect a 1

00:08:35,890 --> 00:08:40,990
is to 1 is to be related to precision so

00:08:38,680 --> 00:08:42,850
if precision is that you want to be sure

00:08:40,990 --> 00:08:44,730
that the call graph that you derived

00:08:42,850 --> 00:08:47,770
from the source code is exact and

00:08:44,730 --> 00:08:49,480
complete and the other one is to do with

00:08:47,770 --> 00:08:51,880
sadness because there are aspects for

00:08:49,480 --> 00:08:56,440
uses like dynamic dispatch it's not easy

00:08:51,880 --> 00:08:58,030
to handle and to sort of give an

00:08:56,440 --> 00:08:59,560
approximation of

00:08:58,030 --> 00:09:01,570
how with this weekend princess-like ad

00:08:59,560 --> 00:09:05,110
unlikely calls for you like you might

00:09:01,570 --> 00:09:07,000
have multiple implications of a call you

00:09:05,110 --> 00:09:08,770
basically create edges to all of them

00:09:07,000 --> 00:09:14,170
money not sure exactly which one it will

00:09:08,770 --> 00:09:17,560
do at runtime so spiders aspects I still

00:09:14,170 --> 00:09:19,990
went ahead and did this and to give an

00:09:17,560 --> 00:09:22,990
aura of the port so the first thing that

00:09:19,990 --> 00:09:25,660
I do is to retrieve and build the

00:09:22,990 --> 00:09:28,110
packages so that means like downloaded

00:09:25,660 --> 00:09:30,160
packages and then I need also some like

00:09:28,110 --> 00:09:32,080
cleaning in the core normal files

00:09:30,160 --> 00:09:34,900
because in some of the versions you

00:09:32,080 --> 00:09:37,090
actually on Twitter you actually specify

00:09:34,900 --> 00:09:40,350
path dependencies which does not exist

00:09:37,090 --> 00:09:44,920
when you use it then I validate them and

00:09:40,350 --> 00:09:46,930
build it in the second step I generated

00:09:44,920 --> 00:09:49,060
Colegrove and as I mentioned earlier I

00:09:46,930 --> 00:09:52,000
actually did this with using the 1100

00:09:49,060 --> 00:09:53,110
graph generator I know from discussions

00:09:52,000 --> 00:09:55,030
on the restaurants that there are

00:09:53,110 --> 00:09:58,420
different ways to do it but this was the

00:09:55,030 --> 00:10:01,600
way that I saw it initially so the first

00:09:58,420 --> 00:10:04,510
thing is that you get the call graph you

00:10:01,600 --> 00:10:05,830
get like this very mystic function call

00:10:04,510 --> 00:10:09,430
identifier that's not really realistic

00:10:05,830 --> 00:10:11,680
but that's Ross mangled function and

00:10:09,430 --> 00:10:13,150
fires and then you d mangle it in this

00:10:11,680 --> 00:10:18,700
case I actually use the Ross field

00:10:13,150 --> 00:10:22,030
tool to do it and then in the third step

00:10:18,700 --> 00:10:23,950
I build unique identifiers which are so

00:10:22,030 --> 00:10:26,380
like in the earlier call graph with the

00:10:23,950 --> 00:10:31,020
versioning and then similar to

00:10:26,380 --> 00:10:34,360
dependency Network I merge them together

00:10:31,020 --> 00:10:36,700
and then finally once you have annotated

00:10:34,360 --> 00:10:38,800
and given all functional files they're a

00:10:36,700 --> 00:10:41,050
unique name you can merge them together

00:10:38,800 --> 00:10:45,240
and then you have your code base

00:10:41,050 --> 00:10:48,280
dependency Network so the first step is

00:10:45,240 --> 00:10:49,450
also I gonna talk to mines challenging

00:10:48,280 --> 00:10:51,730
search the one is of course is the

00:10:49,450 --> 00:10:53,980
compiling and then the other one is with

00:10:51,730 --> 00:10:55,780
the function at the virus they of course

00:10:53,980 --> 00:11:01,630
mean other challenges but I won't have

00:10:55,780 --> 00:11:04,030
time to do that so I did this packet 16

00:11:01,630 --> 00:11:07,810
February 2018 so it's almost one year

00:11:04,030 --> 00:11:10,150
ago since I did that and when I first

00:11:07,810 --> 00:11:11,650
tried to attempt building it I got

00:11:10,150 --> 00:11:14,740
quite a few errors which is of course

00:11:11,650 --> 00:11:15,910
expected and didn't make me so happy so

00:11:14,740 --> 00:11:19,080
one of them was for instance like

00:11:15,910 --> 00:11:21,280
couldn't load like the source dependency

00:11:19,080 --> 00:11:24,040
another one was for instance like it

00:11:21,280 --> 00:11:26,020
could not run nightly features and then

00:11:24,040 --> 00:11:27,460
there was also cases where there's a

00:11:26,020 --> 00:11:30,580
custom-built commas that I could not

00:11:27,460 --> 00:11:32,620
execute and I was able to mitigate some

00:11:30,580 --> 00:11:35,830
of them so free so like the first case

00:11:32,620 --> 00:11:39,670
that I show over here is MIDI basically

00:11:35,830 --> 00:11:41,620
by using a rewrite command in cargo that

00:11:39,670 --> 00:11:44,380
basically gets the published version of

00:11:41,620 --> 00:11:45,540
the cargo terminal and not the one that

00:11:44,380 --> 00:11:47,860
you actually download from the API

00:11:45,540 --> 00:11:49,300
because sometimes I have half dependency

00:11:47,860 --> 00:11:51,640
say you don't I mean they shouldn't

00:11:49,300 --> 00:11:54,130
really be there but yeah so that was an

00:11:51,640 --> 00:11:56,110
issue and then with nightly features

00:11:54,130 --> 00:11:59,440
what I did is that I run a couple of

00:11:56,110 --> 00:12:01,180
nightly compilers to get it working but

00:11:59,440 --> 00:12:03,040
then that the problem is that you don't

00:12:01,180 --> 00:12:05,470
always know what this again exactly is

00:12:03,040 --> 00:12:09,370
the right nightly version to run for our

00:12:05,470 --> 00:12:11,230
trait and then the last we've custom

00:12:09,370 --> 00:12:13,930
build scripts so one way we mitigate

00:12:11,230 --> 00:12:16,360
that is by installing a lot of system

00:12:13,930 --> 00:12:18,340
packages I learned recently there is

00:12:16,360 --> 00:12:20,830
actually one docker file that actually

00:12:18,340 --> 00:12:23,170
does have always system dependencies I

00:12:20,830 --> 00:12:26,470
haven't tried that myself but there is a

00:12:23,170 --> 00:12:27,970
solution to it and I think one upon a

00:12:26,470 --> 00:12:30,250
finger which I would like to see in

00:12:27,970 --> 00:12:32,740
coral is that you can actually actually

00:12:30,250 --> 00:12:35,170
evaluate that the package can compile

00:12:32,740 --> 00:12:37,210
but also that there are features that

00:12:35,170 --> 00:12:38,890
check whether you know which version of

00:12:37,210 --> 00:12:44,800
the compiler you use what and why I

00:12:38,890 --> 00:12:46,870
meant etc being taken into account yet

00:12:44,800 --> 00:12:48,790
it's one of uh skip out there some other

00:12:46,870 --> 00:12:51,460
errors related to it which is races like

00:12:48,790 --> 00:12:57,100
when I was trying to build that many of

00:12:51,460 --> 00:12:59,830
the packages actually use a trait but

00:12:57,100 --> 00:13:02,140
incorrectly so there's a lot of of this

00:12:59,830 --> 00:13:06,220
type of error so I find quite a few of

00:13:02,140 --> 00:13:08,950
them and what was like the final

00:13:06,220 --> 00:13:11,560
compilation statistics so after removing

00:13:08,950 --> 00:13:13,300
invalid manifests that exists over there

00:13:11,560 --> 00:13:16,120
I had until two twelve thousand packages

00:13:13,300 --> 00:13:20,770
and then that went down to 72,000

00:13:16,120 --> 00:13:21,970
releases in total of those packages and

00:13:20,770 --> 00:13:26,560
then

00:13:21,970 --> 00:13:30,360
out of those I managed to build 40 9800

00:13:26,560 --> 00:13:33,910
for coal graphs which is in total 11,000

00:13:30,360 --> 00:13:34,780
packages or crates it took me six to

00:13:33,910 --> 00:13:36,340
nine hours to do it

00:13:34,780 --> 00:13:38,140
of course I didn't do in the MacBook we

00:13:36,340 --> 00:13:42,280
actually use the cluster at the

00:13:38,140 --> 00:13:44,410
University for it and in total I could

00:13:42,280 --> 00:13:47,020
build at that point of time 70% of

00:13:44,410 --> 00:13:48,760
crazier so we chose that there are some

00:13:47,020 --> 00:13:50,530
actually really good guarantees with

00:13:48,760 --> 00:13:55,720
cargo and creaser to actually build

00:13:50,530 --> 00:13:59,050
packages all right then the other part

00:13:55,720 --> 00:14:01,540
is with the rust symbols so I wanted to

00:13:59,050 --> 00:14:03,040
annotate version numbers to it but then

00:14:01,540 --> 00:14:06,340
a problem here is that I cannot use

00:14:03,040 --> 00:14:10,570
simple radix to do it unfortunately so I

00:14:06,340 --> 00:14:13,660
had to actually build a parser on top of

00:14:10,570 --> 00:14:16,510
it so luckily sorry so you can see for

00:14:13,660 --> 00:14:18,670
instance like it has this assembler as

00:14:16,510 --> 00:14:20,380
cool and here's basically like the

00:14:18,670 --> 00:14:24,430
server version rec implementing the

00:14:20,380 --> 00:14:27,190
trait partial ordering and the soleus I

00:14:24,430 --> 00:14:29,410
used let's say like a build on top of

00:14:27,190 --> 00:14:33,390
scene which actually parses rusts code

00:14:29,410 --> 00:14:36,820
and added this specific Russy LLVM

00:14:33,390 --> 00:14:41,320
symbols to do it and by doing this I was

00:14:36,820 --> 00:14:42,820
able to annotate version numbers and you

00:14:41,320 --> 00:14:46,810
know me to add append the version

00:14:42,820 --> 00:14:48,370
numbers I basically let's look at the

00:14:46,810 --> 00:14:51,490
card log file of the package of the

00:14:48,370 --> 00:14:54,610
building it extracting the information

00:14:51,490 --> 00:14:56,890
and then appending it to it so at first

00:14:54,610 --> 00:14:58,840
like the ecosystem that I use in the

00:14:56,890 --> 00:15:00,490
library version the module and the

00:14:58,840 --> 00:15:05,500
function ma this is the way I create the

00:15:00,490 --> 00:15:07,240
unique function identifier so I'm not

00:15:05,500 --> 00:15:09,870
going to a live demo but I gonna show a

00:15:07,240 --> 00:15:12,670
little bit what you can do with it and

00:15:09,870 --> 00:15:15,130
the I did actually two applications with

00:15:12,670 --> 00:15:21,100
it one is of course the popular security

00:15:15,130 --> 00:15:22,690
and I also did one with deprecation I

00:15:21,100 --> 00:15:24,970
think many of you probably have seen

00:15:22,690 --> 00:15:28,030
this of course not with Rosco but

00:15:24,970 --> 00:15:31,230
probably with JavaScript and I think

00:15:28,030 --> 00:15:31,230
also probably rubygems

00:15:31,290 --> 00:15:39,509
rubygems code so I tried this using the

00:15:35,699 --> 00:15:42,180
rust shake database so at that point of

00:15:39,509 --> 00:15:44,399
time they had six advisories from those

00:15:42,180 --> 00:15:46,649
advices I could extract 13 functions

00:15:44,399 --> 00:15:51,269
that were affected by some form of

00:15:46,649 --> 00:15:53,699
vulnerability and I did this using both

00:15:51,269 --> 00:15:55,589
a regular dependency checker that means

00:15:53,699 --> 00:15:57,720
a look just at the package informations

00:15:55,589 --> 00:16:00,360
which I showed before with dependency to

00:15:57,720 --> 00:16:01,440
a checker and then I used with my raw

00:16:00,360 --> 00:16:03,839
spreadsheet to see the number of

00:16:01,440 --> 00:16:06,540
packages and here we can clearly see the

00:16:03,839 --> 00:16:08,190
advantage of having doing it on the

00:16:06,540 --> 00:16:10,860
corporate level because we get more

00:16:08,190 --> 00:16:12,870
precision and avoid false positives and

00:16:10,860 --> 00:16:15,990
as you can see like the numbers are much

00:16:12,870 --> 00:16:17,639
less which means that I as a developer

00:16:15,990 --> 00:16:21,690
don't have to actually really go through

00:16:17,639 --> 00:16:25,019
too many packages when I have to see

00:16:21,690 --> 00:16:27,930
what we were false positives and to see

00:16:25,019 --> 00:16:30,120
it like this result actually accurate at

00:16:27,930 --> 00:16:32,790
some point resistors lot of false

00:16:30,120 --> 00:16:35,819
positives so I looked only at the direct

00:16:32,790 --> 00:16:38,579
dependencies and analyze that and I

00:16:35,819 --> 00:16:40,680
found that using raw spread see that

00:16:38,579 --> 00:16:43,440
it's actually three times more accurate

00:16:40,680 --> 00:16:46,050
than using the regular dependency based

00:16:43,440 --> 00:16:48,149
approach something that I didn't mention

00:16:46,050 --> 00:16:49,649
here slide is that there are some

00:16:48,149 --> 00:16:52,500
problems with respect to the

00:16:49,649 --> 00:16:55,170
completeness of reciprocity because I do

00:16:52,500 --> 00:16:57,420
not get freezes like dynamically display

00:16:55,170 --> 00:17:00,690
functions also there's some problems

00:16:57,420 --> 00:17:03,329
with conditional compilation etc but in

00:17:00,690 --> 00:17:05,909
principle by doing it on the culture

00:17:03,329 --> 00:17:08,790
that way we can actually have high

00:17:05,909 --> 00:17:13,470
precision we do such type of analysis

00:17:08,790 --> 00:17:14,909
and also really cool thing is that I was

00:17:13,470 --> 00:17:18,140
of course posting this on the russ

00:17:14,909 --> 00:17:22,409
forums i'm sure if you have seen it but

00:17:18,140 --> 00:17:25,079
yeah so tony from the rust sake a

00:17:22,409 --> 00:17:26,880
community he added this feature with

00:17:25,079 --> 00:17:28,380
effective function so that's very nice

00:17:26,880 --> 00:17:31,200
thing for me later on that i can

00:17:28,380 --> 00:17:33,330
actually easily just import data from

00:17:31,200 --> 00:17:35,659
the raw security database get the

00:17:33,330 --> 00:17:39,840
function to fire a dank query on the

00:17:35,659 --> 00:17:42,210
respite c graph so the other case i

00:17:39,840 --> 00:17:44,500
looked at was add application so did a

00:17:42,210 --> 00:17:46,179
very small study

00:17:44,500 --> 00:17:47,950
so I looked at their so for instance

00:17:46,179 --> 00:17:50,740
like the the questionnaires like how

00:17:47,950 --> 00:17:52,929
many will be affected by a removal of a

00:17:50,740 --> 00:17:56,950
deprecated function so this was the main

00:17:52,929 --> 00:17:59,770
reason why I wanted to do this and so I

00:17:56,950 --> 00:18:02,110
looked at functions like using my data

00:17:59,770 --> 00:18:04,630
set of all packages I looked at how many

00:18:02,110 --> 00:18:10,330
of them actually had a deprecated

00:18:04,630 --> 00:18:12,340
function by using this annotation and I

00:18:10,330 --> 00:18:14,500
didn't find too many of them I found

00:18:12,340 --> 00:18:17,409
from eleven releases through six

00:18:14,500 --> 00:18:18,760
packages so with this one so basically

00:18:17,409 --> 00:18:23,440
once they were actually used by other

00:18:18,760 --> 00:18:25,780
people there of course many more and I

00:18:23,440 --> 00:18:27,669
found out in total those were actually

00:18:25,780 --> 00:18:32,169
using those eleven functions were 300

00:18:27,669 --> 00:18:34,390
level and they say packages and those

00:18:32,169 --> 00:18:39,250
are not only top-level packages but also

00:18:34,390 --> 00:18:41,950
transitive packages and if I would try

00:18:39,250 --> 00:18:45,490
to remove those functions 52 of them

00:18:41,950 --> 00:18:46,630
would actually be affected of course

00:18:45,490 --> 00:18:48,580
where they're actually removed or not

00:18:46,630 --> 00:18:50,470
that's a different discussion but this

00:18:48,580 --> 00:18:57,159
is some form of analysis that you can do

00:18:50,470 --> 00:19:01,030
with respect C and yeah so I really want

00:18:57,159 --> 00:19:04,240
this to be a community effort so the way

00:19:01,030 --> 00:19:06,429
I envisioned with raw spritzy is that I

00:19:04,240 --> 00:19:09,370
would like to do analysis and do

00:19:06,429 --> 00:19:12,760
data-driven decisions for Princeton they

00:19:09,370 --> 00:19:16,539
a crater project which runs like a

00:19:12,760 --> 00:19:18,700
regression on Chris at i/o using the

00:19:16,539 --> 00:19:20,020
compiler but also for instance like the

00:19:18,700 --> 00:19:23,740
ecosystem work group where they actually

00:19:20,020 --> 00:19:25,299
try to find a crates that have phrases

00:19:23,740 --> 00:19:27,370
like in not been maintained for a long

00:19:25,299 --> 00:19:30,250
time or some other problems in which it

00:19:27,370 --> 00:19:32,440
actually needs some attention and also

00:19:30,250 --> 00:19:36,760
their security work repressor show me

00:19:32,440 --> 00:19:39,340
one slide and yeah this is a bit like

00:19:36,760 --> 00:19:42,490
maybe what I really would like to serve

00:19:39,340 --> 00:19:44,980
this is real what what I want to go

00:19:42,490 --> 00:19:47,710
forward with and there are of course

00:19:44,980 --> 00:19:49,990
many open problems so this is actually a

00:19:47,710 --> 00:19:51,159
prototype and as a researcher is of

00:19:49,990 --> 00:19:52,899
course difficult to find time with

00:19:51,159 --> 00:19:56,679
researcher doing development but I

00:19:52,899 --> 00:19:57,549
really hope to make this something that

00:19:56,679 --> 00:20:00,879
actual

00:19:57,549 --> 00:20:07,149
we can benefit the community as a

00:20:00,879 --> 00:20:08,679
divided community and yeah so as you

00:20:07,149 --> 00:20:10,480
probably seen on t-shirt and also many

00:20:08,679 --> 00:20:13,360
posters

00:20:10,480 --> 00:20:15,730
one way to actually help me to do was

00:20:13,360 --> 00:20:20,499
press the battery is to actually take my

00:20:15,730 --> 00:20:21,700
survey so a for this time is long but I

00:20:20,499 --> 00:20:23,409
would really appreciate if you could

00:20:21,700 --> 00:20:25,619
fill out some problems that you

00:20:23,409 --> 00:20:28,360
experienced with dependency management

00:20:25,619 --> 00:20:30,039
or other things a lot of point of

00:20:28,360 --> 00:20:33,100
suggestions you have with dependency

00:20:30,039 --> 00:20:36,390
management in general so thank you very

00:20:33,100 --> 00:20:39,459
much I'm ready for questions

00:20:36,390 --> 00:20:39,459
[Applause]

00:20:41,550 --> 00:20:48,030
[Applause]

00:20:45,030 --> 00:20:48,030
yes

00:21:07,929 --> 00:21:13,249
that's so your question is about what is

00:21:10,940 --> 00:21:16,220
the number of false positives in general

00:21:13,249 --> 00:21:18,049
with using raw spritzee but also like

00:21:16,220 --> 00:21:22,580
with control flow graphs why I don't

00:21:18,049 --> 00:21:24,919
include that so with respect to control

00:21:22,580 --> 00:21:27,769
flow graph so because I wanted to build

00:21:24,919 --> 00:21:29,570
this one ecosystem and the first level

00:21:27,769 --> 00:21:30,919
of granularity that I wanted to look is

00:21:29,570 --> 00:21:34,309
at at the Colegrove

00:21:30,919 --> 00:21:36,259
level the other days that reasons I can

00:21:34,309 --> 00:21:38,119
like slice part of the Colegrove

00:21:36,259 --> 00:21:40,519
I mean let's say like all those affected

00:21:38,119 --> 00:21:42,830
paths throughout the ecosystem and do

00:21:40,519 --> 00:21:44,480
more fine-grained analysis by actually

00:21:42,830 --> 00:21:47,330
extracting the called control flow graph

00:21:44,480 --> 00:21:49,850
for that part of functions of going one

00:21:47,330 --> 00:21:52,759
step level level down and with respect

00:21:49,850 --> 00:21:55,309
to false positives so because I'm using

00:21:52,759 --> 00:21:59,059
the LLVM Cole go via narrator it is

00:21:55,309 --> 00:22:02,600
precise but it is not sound so it is

00:21:59,059 --> 00:22:04,279
missing the dynamic function invocations

00:22:02,600 --> 00:22:07,639
it cannot handle for instance like

00:22:04,279 --> 00:22:10,389
generic functions so this is a big

00:22:07,639 --> 00:22:12,950
problem in using this and of course I'm

00:22:10,389 --> 00:22:15,200
trying to look for but the Colegrove

00:22:12,950 --> 00:22:18,139
alternative so I would really like some

00:22:15,200 --> 00:22:19,580
help here and actually how to do it

00:22:18,139 --> 00:22:22,759
better but also do something that is

00:22:19,580 --> 00:22:25,220
more Rossella complete a phrase like in

00:22:22,759 --> 00:22:27,259
Java you have suit of Allah which covers

00:22:25,220 --> 00:22:29,649
a lot of features it would also be very

00:22:27,259 --> 00:22:38,200
nice if there is something similar for

00:22:29,649 --> 00:22:38,200
rust as well any more questions

00:22:43,040 --> 00:22:46,610
yeah I guess

00:22:47,300 --> 00:22:50,450

YouTube URL: https://www.youtube.com/watch?v=sntqr-akNkI


