Title: Starting the sysadmin tools renaissance: Flapjack + cucumber-nagios
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Lindsay Holmwood

Monitoring software is ripe for a renaissance. Now is the time to for building new tools and rethinking our problems. Leading the charge are two projects: cucumber-nagios, and Flapjack.

A systems administrator's role in today's technology landscape has never been so important. It's our responsibility to manage provisioning and maintenance of massive infrastructures, to anticipate ahead of time when capacity must be grown or shrunk, and increasingly, to make sure our applications scale.

While developer tools have improved tremendously, we sysadmins are still living in the dark ages, other than a few shining beacons of hope such as Puppet. We're still trying to make Nagios scale. We're still writing the same old monitoring checks. Getting statistics out of our applications is tedious and difficult, but increasingly important to scaling.

cucumber-nagios lets you describe how a website should work in natural language, and outputs whether it does in the Nagios plugin format. It includes a standard library of website interactions, so you don't have to rewrite the same Nagios checks over and over.

cucumber-nagios can also be used to check SSH logins, filesystem interactions, mail delivery, and Asterisk dialplans. By lowering the barrier of entry to writing fully featured checks, there's no reason not to start testing all of your infrastructure. But as you start adding more checks to your monitoring system you're going to notice slowdowns and reliability problems - enter Flapjack

Flapjack is a scalable and distributed monitoring system. It natively talks the Nagios plugin format (so you can use all your existing Nagios checks), and can easily be scaled from 1 server to 1000.

Flapjack breaks the monitoring lifecycle into several distinct chunks: workers that execute checks, notifiers that notify when checks fail, and an admin interface to manage checks and events.

By breaking the monitoring lifecycle up, it becomes incredibly easy to scale your monitoring system with your infrastructure. Need to monitor more servers? Just add another server to the pool of workers. Need to take down your workers for maintenance? Just spin up another pool, and turn off the old one.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:06,500 --> 00:00:11,460
and I'm from Sydney Australia I flew all

00:00:09,630 --> 00:00:13,080
the way here for falls down and today

00:00:11,460 --> 00:00:18,390
I'm going to be talking about making

00:00:13,080 --> 00:00:19,350
monitoring delicious again so obviously

00:00:18,390 --> 00:00:22,320
this talk is going to be about

00:00:19,350 --> 00:00:24,210
monitoring right but first things first

00:00:22,320 --> 00:00:26,480
we need to get some terminology out of

00:00:24,210 --> 00:00:29,580
the way so we're all on the same page so

00:00:26,480 --> 00:00:32,070
we have the concept of a check and a

00:00:29,580 --> 00:00:34,260
checks purpose is to perform some sort

00:00:32,070 --> 00:00:36,149
of verification or validation that

00:00:34,260 --> 00:00:40,320
something is working the way that you

00:00:36,149 --> 00:00:43,590
expect it to developers also know these

00:00:40,320 --> 00:00:45,360
things as unit tests and this is an

00:00:43,590 --> 00:00:48,030
example check very simple where does

00:00:45,360 --> 00:00:49,710
pinging four times and generally what

00:00:48,030 --> 00:00:52,309
happens at the end of that is it will

00:00:49,710 --> 00:00:54,960
return good or bad or ugly weather it

00:00:52,309 --> 00:00:58,980
weather what you were testing was with

00:00:54,960 --> 00:01:02,070
the parameters that you're expecting and

00:00:58,980 --> 00:01:04,290
a monitoring system is constantly

00:01:02,070 --> 00:01:05,820
monitoring for failing checks so

00:01:04,290 --> 00:01:07,500
basically it's running through this

00:01:05,820 --> 00:01:09,689
gigantic list of things that you want to

00:01:07,500 --> 00:01:11,670
check and it's going to notify if

00:01:09,689 --> 00:01:13,260
something is amiss something is that

00:01:11,670 --> 00:01:16,740
there's not the way that you expected it

00:01:13,260 --> 00:01:18,630
to be so monitoring systems then are

00:01:16,740 --> 00:01:20,340
essentially asking three questions

00:01:18,630 --> 00:01:23,100
they're asking what is the next check

00:01:20,340 --> 00:01:26,189
that I need to perform was the check

00:01:23,100 --> 00:01:27,840
okay after I executed it and who do we

00:01:26,189 --> 00:01:31,020
need to notify or do we need to notify

00:01:27,840 --> 00:01:33,329
anybody at all so we take these three

00:01:31,020 --> 00:01:35,520
questions and they actually map into

00:01:33,329 --> 00:01:37,979
these these three distinct phases to

00:01:35,520 --> 00:01:41,100
fetch the test and the notify phase so

00:01:37,979 --> 00:01:42,810
if we represent that in a diagram it's

00:01:41,100 --> 00:01:44,340
basically this gigantic circle that's

00:01:42,810 --> 00:01:45,720
going around and around around right the

00:01:44,340 --> 00:01:48,240
fetching of the testing of the notifying

00:01:45,720 --> 00:01:49,740
and within those phases there are

00:01:48,240 --> 00:01:51,600
actually some sub phases and fetching

00:01:49,740 --> 00:01:53,729
phase we're doing some sort of look up

00:01:51,600 --> 00:01:56,369
maybe from a database or from the flat

00:01:53,729 --> 00:01:58,200
file or wherever then in the testing

00:01:56,369 --> 00:02:01,020
phase you've got the execution of the

00:01:58,200 --> 00:02:02,549
check and then verifying the result and

00:02:01,020 --> 00:02:03,930
then in the notification phase you're

00:02:02,549 --> 00:02:05,909
deciding whether you need to notify

00:02:03,930 --> 00:02:08,280
anybody and if you do need to notify

00:02:05,909 --> 00:02:10,140
then we need to call out to some other

00:02:08,280 --> 00:02:12,110
system to do that whether that be by you

00:02:10,140 --> 00:02:14,650
know smtp your XMPP you

00:02:12,110 --> 00:02:16,700
whatever the protocol is and

00:02:14,650 --> 00:02:19,280
traditionally monitoring systems have

00:02:16,700 --> 00:02:23,150
done this within within a single process

00:02:19,280 --> 00:02:24,380
so as a microphone still gotten great so

00:02:23,150 --> 00:02:26,090
traditionally monitoring systems have

00:02:24,380 --> 00:02:27,860
done this within a single process and

00:02:26,090 --> 00:02:29,870
it's been treated quite monolithically

00:02:27,860 --> 00:02:31,820
you might be using threads or whatnot

00:02:29,870 --> 00:02:33,350
within that single process but generally

00:02:31,820 --> 00:02:35,810
this is all happening on the same

00:02:33,350 --> 00:02:37,400
machine and if you look at other things

00:02:35,810 --> 00:02:38,690
like you know clustered nagi office and

00:02:37,400 --> 00:02:40,190
whatnot generally they're just

00:02:38,690 --> 00:02:41,990
replicating this across a bunch of

00:02:40,190 --> 00:02:43,370
different machines but all these

00:02:41,990 --> 00:02:46,250
different processes are just happening

00:02:43,370 --> 00:02:48,830
in one place and the thing that you

00:02:46,250 --> 00:02:50,090
realize about monitoring when you look

00:02:48,830 --> 00:02:52,280
at it in these terms is that it's

00:02:50,090 --> 00:02:54,739
actually what's called an embarrassingly

00:02:52,280 --> 00:02:55,850
parallel problem and that's for one one

00:02:54,739 --> 00:02:57,170
for which little or no effort is

00:02:55,850 --> 00:02:59,660
required to separate the problem into a

00:02:57,170 --> 00:03:01,160
number of parallel tasks and this is the

00:02:59,660 --> 00:03:02,480
case when there are no dependencies

00:03:01,160 --> 00:03:05,900
between the things that are actually

00:03:02,480 --> 00:03:09,020
happening within the system right so if

00:03:05,900 --> 00:03:11,150
we recognize that it's a embarrassingly

00:03:09,020 --> 00:03:12,830
parallel task you can start thinking

00:03:11,150 --> 00:03:14,300
about common data that needs to be sent

00:03:12,830 --> 00:03:17,900
between all these different components

00:03:14,300 --> 00:03:19,580
so in this particular case in the fetch

00:03:17,900 --> 00:03:21,650
and the and the test and the notify

00:03:19,580 --> 00:03:23,360
phase we're sending around an ID of a

00:03:21,650 --> 00:03:25,340
particular check and the command that we

00:03:23,360 --> 00:03:26,540
need to execute so that's being sent

00:03:25,340 --> 00:03:29,209
here between the fetch and the test

00:03:26,540 --> 00:03:31,280
phase and then on the notify phase we're

00:03:29,209 --> 00:03:34,010
sending the same ID and the result that

00:03:31,280 --> 00:03:36,920
we that we got after after executing

00:03:34,010 --> 00:03:40,010
that test so we can actually collapse

00:03:36,920 --> 00:03:41,330
these into into single phases themselves

00:03:40,010 --> 00:03:43,489
like you can't perform a test without

00:03:41,330 --> 00:03:45,470
having a fetch right and the same way

00:03:43,489 --> 00:03:47,180
that you can't actually perform a fetch

00:03:45,470 --> 00:03:48,709
without so you can't perform and notify

00:03:47,180 --> 00:03:51,680
without fetching some data of some

00:03:48,709 --> 00:03:53,480
description so this cycle itself can

00:03:51,680 --> 00:03:55,940
actually be broken out into two distinct

00:03:53,480 --> 00:03:59,090
cycles we've got the testing cycle and

00:03:55,940 --> 00:04:00,650
the notifying cycle and then you have

00:03:59,090 --> 00:04:03,500
some sort of transport mechanism in

00:04:00,650 --> 00:04:07,040
between to send the data backwards and

00:04:03,500 --> 00:04:08,120
forwards and once we've done that we can

00:04:07,040 --> 00:04:09,799
actually start making some other

00:04:08,120 --> 00:04:11,959
assumptions like pre compiling the

00:04:09,799 --> 00:04:14,959
checks that the that the testing phase

00:04:11,959 --> 00:04:17,989
needs to do so we can make that a very

00:04:14,959 --> 00:04:19,280
computational it expensive operation

00:04:17,989 --> 00:04:21,140
right it doesn't doesn't cost a lot to

00:04:19,280 --> 00:04:21,840
actually look up the check so we need to

00:04:21,140 --> 00:04:24,330
perform

00:04:21,840 --> 00:04:27,150
we can do other fancy things like making

00:04:24,330 --> 00:04:29,370
the transporters the scheduler so the

00:04:27,150 --> 00:04:32,729
the test phase doesn't actually care

00:04:29,370 --> 00:04:33,900
about when things need to be executed

00:04:32,729 --> 00:04:35,850
they just know that they need to execute

00:04:33,900 --> 00:04:37,470
something now and the transport is

00:04:35,850 --> 00:04:39,900
actually doing all that scheduling stuff

00:04:37,470 --> 00:04:42,449
for us the other thing that we can do is

00:04:39,900 --> 00:04:44,850
we can remove the data collection from

00:04:42,449 --> 00:04:47,130
the monitoring setup entirely we can use

00:04:44,850 --> 00:04:49,590
other tools like like ganglia or collect

00:04:47,130 --> 00:04:52,650
d2 to do that for us and we can just

00:04:49,590 --> 00:04:56,370
focus on doing the monitoring itself the

00:04:52,650 --> 00:04:58,530
actual notification so we've got these

00:04:56,370 --> 00:05:00,000
distinct cycles here and the data going

00:04:58,530 --> 00:05:01,800
backwards and forwards and this is where

00:05:00,000 --> 00:05:03,330
flapjack comes in flapjack is a tool

00:05:01,800 --> 00:05:06,780
that I've been writing for the last year

00:05:03,330 --> 00:05:08,729
or so and it follows exactly the same

00:05:06,780 --> 00:05:10,260
principle you have a workers which are

00:05:08,729 --> 00:05:12,030
doing the testing phase and the the

00:05:10,260 --> 00:05:14,100
notifier which is doing the notifying

00:05:12,030 --> 00:05:15,840
fees and you have been stalked d which

00:05:14,100 --> 00:05:17,580
is in the middle that is doing the

00:05:15,840 --> 00:05:21,060
communication between all the different

00:05:17,580 --> 00:05:22,470
bits and then for the pre pre

00:05:21,060 --> 00:05:24,539
compilation that I was talking about a

00:05:22,470 --> 00:05:25,979
second ago we have a populated which is

00:05:24,539 --> 00:05:27,570
just getting some data out of a database

00:05:25,979 --> 00:05:29,940
or however you want to represent your

00:05:27,570 --> 00:05:32,610
checks and injecting it onto the

00:05:29,940 --> 00:05:33,870
Beanstalk so a worker just means to go

00:05:32,610 --> 00:05:36,780
okay give me the next check and the

00:05:33,870 --> 00:05:38,130
Beanstalk makes it available to it the

00:05:36,780 --> 00:05:39,720
nice thing about that is then we can

00:05:38,130 --> 00:05:41,430
start paralyzing the number of workers

00:05:39,720 --> 00:05:42,780
that are actually executing those checks

00:05:41,430 --> 00:05:44,340
it doesn't just have to be a single work

00:05:42,780 --> 00:05:46,200
you can spin up as many workers as you

00:05:44,340 --> 00:05:48,780
want to deal with whatever workload you

00:05:46,200 --> 00:05:51,330
have so if we look at flapjack flapjack

00:05:48,780 --> 00:05:54,510
is written in Ruby it aims to be

00:05:51,330 --> 00:05:56,070
distributed scalable and it talks than

00:05:54,510 --> 00:05:58,610
our jaws plug-in format because there is

00:05:56,070 --> 00:06:02,220
a lot of point in reinventing the wheel

00:05:58,610 --> 00:06:04,889
it aims to be easy to install easy to

00:06:02,220 --> 00:06:07,080
configure easy to maintain and easy to

00:06:04,889 --> 00:06:10,229
scale and it should be just as easy to

00:06:07,080 --> 00:06:12,300
scale your flapjack instance from one

00:06:10,229 --> 00:06:14,280
machine to many machines to execute the

00:06:12,300 --> 00:06:15,510
checks across many machines so instead

00:06:14,280 --> 00:06:16,620
of just keeping it on like a single

00:06:15,510 --> 00:06:18,479
machine and running it you can

00:06:16,620 --> 00:06:22,650
distribute the execution of that across

00:06:18,479 --> 00:06:24,810
as many machines as you want so now that

00:06:22,650 --> 00:06:25,919
we split up the monitoring lifecycle we

00:06:24,810 --> 00:06:28,770
only look at the individual components

00:06:25,919 --> 00:06:31,020
that flapjack users to you know of this

00:06:28,770 --> 00:06:33,419
goal before that we actually need to

00:06:31,020 --> 00:06:35,520
look at Beanstalk which is the notify

00:06:33,419 --> 00:06:38,370
other the the messaging transports

00:06:35,520 --> 00:06:40,680
them that makes all this possible so Ben

00:06:38,370 --> 00:06:42,419
stop D is a simple fast work to service

00:06:40,680 --> 00:06:45,000
that lets you run time-consuming tasks

00:06:42,419 --> 00:06:47,370
asynchronously certain and see it's

00:06:45,000 --> 00:06:49,620
based on the memcached protocol so it's

00:06:47,370 --> 00:06:50,819
very very lightweight you install it on

00:06:49,620 --> 00:06:53,009
your operating system using your

00:06:50,819 --> 00:06:54,419
distributions package manager and you

00:06:53,009 --> 00:06:56,940
start up a daemon here generally your

00:06:54,419 --> 00:07:00,659
distribution will provide a an init

00:06:56,940 --> 00:07:03,389
script for doing that for you so within

00:07:00,659 --> 00:07:04,830
Beanstalk it's just like a lot of other

00:07:03,389 --> 00:07:07,080
messaging systems where you have this

00:07:04,830 --> 00:07:09,180
whole idea of producers and consumers so

00:07:07,080 --> 00:07:10,680
a producer if we look at the first three

00:07:09,180 --> 00:07:11,880
lines here is connecting into this

00:07:10,680 --> 00:07:14,159
Beanstalk and it's putting some

00:07:11,880 --> 00:07:16,289
information on the Beanstalk and then

00:07:14,159 --> 00:07:18,240
the the consumer here is connecting into

00:07:16,289 --> 00:07:20,340
the same Beanstalk and it's just looping

00:07:18,240 --> 00:07:23,280
forever and what it's doing down here on

00:07:20,340 --> 00:07:25,110
this Beanstalk reserve method here is

00:07:23,280 --> 00:07:27,150
it's just blocking until a job is made

00:07:25,110 --> 00:07:29,729
it made available to it there once

00:07:27,150 --> 00:07:32,219
there's got the job it will just put out

00:07:29,729 --> 00:07:34,770
the job body and then it deletes the job

00:07:32,219 --> 00:07:36,960
off the queue once it's done and this is

00:07:34,770 --> 00:07:38,550
essentially the way that the flapjack

00:07:36,960 --> 00:07:41,219
itself works the workers in the

00:07:38,550 --> 00:07:44,819
notifiers are consumers and the admin

00:07:41,219 --> 00:07:46,199
populate our the producers and bina

00:07:44,819 --> 00:07:47,789
sophie has a couple of useful features

00:07:46,199 --> 00:07:50,880
that make this whole thing really easy

00:07:47,789 --> 00:07:53,159
to do so by default when you connect

00:07:50,880 --> 00:07:58,139
into a beanstalk d it just connects to a

00:07:53,159 --> 00:08:01,949
named names thank you called default but

00:07:58,139 --> 00:08:04,289
basic has the concept of tubes which are

00:08:01,949 --> 00:08:05,669
basically named named Q's right so we

00:08:04,289 --> 00:08:08,969
have a in this particular case we have

00:08:05,669 --> 00:08:10,770
hxtube and a results tube and so that

00:08:08,969 --> 00:08:12,240
means that we can put the workloads on

00:08:10,770 --> 00:08:14,729
the individual tubes and they don't ever

00:08:12,240 --> 00:08:16,380
have to touch one another so the workers

00:08:14,729 --> 00:08:18,990
are just connecting into the checks tube

00:08:16,380 --> 00:08:22,289
and the the notifies are connecting into

00:08:18,990 --> 00:08:24,300
the results tube the other nice thing

00:08:22,289 --> 00:08:28,110
that the Ruby bindings for been sloppy

00:08:24,300 --> 00:08:31,500
provide are a yam all an easy way to

00:08:28,110 --> 00:08:33,329
serialize and deserialize actual Ruby

00:08:31,500 --> 00:08:35,070
objects when you put them onto onto the

00:08:33,329 --> 00:08:37,789
tube so that means that you can deal

00:08:35,070 --> 00:08:40,349
with with Ruby objects at either side of

00:08:37,789 --> 00:08:43,919
the of the message queue and everything

00:08:40,349 --> 00:08:47,070
is nice so we look at these components

00:08:43,919 --> 00:08:48,840
again we've got the flapjack work up and

00:08:47,070 --> 00:08:51,240
I like to describe the work

00:08:48,840 --> 00:08:54,150
using sort of like this little story of

00:08:51,240 --> 00:08:55,800
the eternally forgetful shopper so

00:08:54,150 --> 00:08:57,690
there's the shopper right and he goes

00:08:55,800 --> 00:08:59,220
into the shop and he wants to buy

00:08:57,690 --> 00:09:00,450
something and he's looking around and he

00:08:59,220 --> 00:09:02,700
finds the thing that he wants and he

00:09:00,450 --> 00:09:04,350
goes to the checkout and pays for it and

00:09:02,700 --> 00:09:06,180
going back to his car and he's thinking

00:09:04,350 --> 00:09:08,220
oh crap I forgot something I have to go

00:09:06,180 --> 00:09:09,750
back into the store so he goes back into

00:09:08,220 --> 00:09:12,120
the store and searches for the next

00:09:09,750 --> 00:09:14,910
thing and finds it and checks out and

00:09:12,120 --> 00:09:18,690
blah and does it again anyway and again

00:09:14,910 --> 00:09:21,630
so this is the way that the flapjack

00:09:18,690 --> 00:09:23,370
workers themselves work so the worker is

00:09:21,630 --> 00:09:25,530
basically in this gigantic loop that's

00:09:23,370 --> 00:09:27,810
saying give you the next check that I

00:09:25,530 --> 00:09:30,000
need to that I need to do something with

00:09:27,810 --> 00:09:32,730
then it will execute that check and

00:09:30,000 --> 00:09:36,000
capture the output take the return code

00:09:32,730 --> 00:09:39,540
from that and store it and then it takes

00:09:36,000 --> 00:09:41,070
this R it takes the the output of all of

00:09:39,540 --> 00:09:42,630
this and it puts it onto the results

00:09:41,070 --> 00:09:44,670
queue as a result and it sets the check

00:09:42,630 --> 00:09:47,220
ID here puts the output on there and

00:09:44,670 --> 00:09:49,260
also puts the return value but the fancy

00:09:47,220 --> 00:09:51,330
thing that it does is then it takes the

00:09:49,260 --> 00:09:53,540
same check and it recreates it on the

00:09:51,330 --> 00:09:55,710
tube or sorry on the on the Beanstalk

00:09:53,540 --> 00:09:57,990
but at the very very end of it and it

00:09:55,710 --> 00:10:00,090
says a delay on it and Beanstalk d won't

00:09:57,990 --> 00:10:02,310
make that but will make that check

00:10:00,090 --> 00:10:05,880
available to other workers until that

00:10:02,310 --> 00:10:07,170
time out has has has happened so for

00:10:05,880 --> 00:10:11,010
instance of frequencies here might be

00:10:07,170 --> 00:10:13,020
set to 30 seconds so the Beanstalk won't

00:10:11,010 --> 00:10:15,450
make that job available for 30 seconds

00:10:13,020 --> 00:10:18,960
and then when it does is it deletes the

00:10:15,450 --> 00:10:21,780
the check off the queue and and just

00:10:18,960 --> 00:10:23,760
goes and it does the next thing so the

00:10:21,780 --> 00:10:25,380
worker is very very simple it just

00:10:23,760 --> 00:10:26,970
starts up attaches to the console by

00:10:25,380 --> 00:10:28,890
default and you can pass it a bunch of

00:10:26,970 --> 00:10:31,110
options generally you're using it with

00:10:28,890 --> 00:10:32,580
the worker manager though so by default

00:10:31,110 --> 00:10:34,680
when you run the work and manager here

00:10:32,580 --> 00:10:36,510
on the first line that will start up

00:10:34,680 --> 00:10:37,950
five workers and you run it with the

00:10:36,510 --> 00:10:39,210
workers option pass to it and that will

00:10:37,950 --> 00:10:41,370
start up another ten so that means you

00:10:39,210 --> 00:10:42,900
have 15 running and then you run stop

00:10:41,370 --> 00:10:46,440
and that will stop all the workers that

00:10:42,900 --> 00:10:47,520
are currently running on the system the

00:10:46,440 --> 00:10:49,860
nice thing about this approach is that

00:10:47,520 --> 00:10:51,210
you can do near linear scaling so it

00:10:49,860 --> 00:10:52,620
means that the more texture you have in

00:10:51,210 --> 00:10:55,710
your system the more workers you spin on

00:10:52,620 --> 00:10:58,920
and flat Jack copes with that extra load

00:10:55,710 --> 00:11:00,900
quite well it also lends quite well to

00:10:58,920 --> 00:11:01,710
failover scenarios where you have part

00:11:00,900 --> 00:11:03,960
of your

00:11:01,710 --> 00:11:05,340
your you're working class to go down and

00:11:03,960 --> 00:11:08,130
you just want to be able to get back up

00:11:05,340 --> 00:11:09,390
and running so say so you have some sort

00:11:08,130 --> 00:11:10,950
of maintenance window that you need to

00:11:09,390 --> 00:11:12,240
have where you need to take down half of

00:11:10,950 --> 00:11:14,400
your cluster but you want your

00:11:12,240 --> 00:11:16,560
monitoring system to keep on running to

00:11:14,400 --> 00:11:18,000
be keep on running so you spin up a

00:11:16,560 --> 00:11:19,200
whole bunch of new workers you take down

00:11:18,000 --> 00:11:20,520
the part of the cluster that you don't

00:11:19,200 --> 00:11:21,780
care about also really do care about

00:11:20,520 --> 00:11:23,670
that you want to do your maintenance on

00:11:21,780 --> 00:11:25,620
do whatever work you need to do then

00:11:23,670 --> 00:11:27,210
bring them back up and everything is

00:11:25,620 --> 00:11:28,650
fine and the monitoring system keeps

00:11:27,210 --> 00:11:29,970
ticking over like there aren't any

00:11:28,650 --> 00:11:34,290
problems like like everything is

00:11:29,970 --> 00:11:35,730
completely normal so the next part of

00:11:34,290 --> 00:11:39,570
the system and probably the coolest part

00:11:35,730 --> 00:11:41,700
is the notifier itself so notify works

00:11:39,570 --> 00:11:43,620
just like the workers in that it starts

00:11:41,700 --> 00:11:45,060
up attaches to the console there are a

00:11:43,620 --> 00:11:47,850
few more options that you can pass to it

00:11:45,060 --> 00:11:49,140
for configuration and whatnot so and you

00:11:47,850 --> 00:11:50,130
also have the manager as well and that's

00:11:49,140 --> 00:11:52,380
generally the way that you're starting

00:11:50,130 --> 00:11:54,480
it but for debugging starting and

00:11:52,380 --> 00:11:57,630
interactively and seeing a work works

00:11:54,480 --> 00:11:59,880
quite well so we have this recipients

00:11:57,630 --> 00:12:01,140
configuration file here which eventually

00:11:59,880 --> 00:12:03,090
will probably be moved out into a

00:12:01,140 --> 00:12:04,980
database but it's very very simple

00:12:03,090 --> 00:12:06,390
assist at any file you specify a bunch

00:12:04,980 --> 00:12:09,090
of stuff here and all this information

00:12:06,390 --> 00:12:11,850
is made available to the notifiers when

00:12:09,090 --> 00:12:13,440
they decide that they need to notify and

00:12:11,850 --> 00:12:15,510
we have the notifier configuration which

00:12:13,440 --> 00:12:18,090
sets up all sort of deep dark mystic

00:12:15,510 --> 00:12:19,740
stuff inside flap jack but i'll talk

00:12:18,090 --> 00:12:24,360
about that all these different sections

00:12:19,740 --> 00:12:26,310
here in a bit in a second so probably

00:12:24,360 --> 00:12:29,160
the coolest thing about flat jack is the

00:12:26,310 --> 00:12:31,560
AP is and I truly believe that all parts

00:12:29,160 --> 00:12:33,000
of the monitoring lifecycle should have

00:12:31,560 --> 00:12:35,610
as many hooks in it as possible so that

00:12:33,000 --> 00:12:38,160
you can customize flapjack to make it as

00:12:35,610 --> 00:12:41,790
easy as possible to to make it fit your

00:12:38,160 --> 00:12:44,580
environment basically so there are three

00:12:41,790 --> 00:12:46,110
AP is that the flapjack exposes that

00:12:44,580 --> 00:12:48,780
make it really easy to customize we have

00:12:46,110 --> 00:12:53,010
the notifies API the filters API and the

00:12:48,780 --> 00:12:54,990
persistence API so the notifies API is

00:12:53,010 --> 00:12:58,710
very very simple you just create a ruby

00:12:54,990 --> 00:13:00,450
object and in the constructor you get

00:12:58,710 --> 00:13:02,600
past a list of a list of options that

00:13:00,450 --> 00:13:05,520
you can do what with as you please and

00:13:02,600 --> 00:13:07,800
and then implement a notify method and

00:13:05,520 --> 00:13:10,470
when when the notify method is called it

00:13:07,800 --> 00:13:12,660
will be passed a who to the hoop the

00:13:10,470 --> 00:13:13,170
person that we need to notify and the

00:13:12,660 --> 00:13:15,990
result that

00:13:13,170 --> 00:13:17,339
need to know to fight Bell so this lends

00:13:15,990 --> 00:13:19,740
to some really interesting things like

00:13:17,339 --> 00:13:23,399
say a mock nrpe instance where you could

00:13:19,740 --> 00:13:25,560
use flapjack to execute do all the

00:13:23,399 --> 00:13:27,720
execution of your checks like with your

00:13:25,560 --> 00:13:29,760
existing knowledge eos monitoring system

00:13:27,720 --> 00:13:31,019
but it doesn't actually do any of the

00:13:29,760 --> 00:13:32,699
notification it just feeds the

00:13:31,019 --> 00:13:35,430
information back to nagios so you can

00:13:32,699 --> 00:13:37,920
use knowledge yours in at the same time

00:13:35,430 --> 00:13:40,800
as using as using flapjack they're wrong

00:13:37,920 --> 00:13:44,190
in parallel the next thing is an elastic

00:13:40,800 --> 00:13:46,560
motor fire r.i.p male down here he

00:13:44,190 --> 00:13:48,360
brought a fantastic tool called end

00:13:46,560 --> 00:13:50,730
collective and what that allows you to

00:13:48,360 --> 00:13:54,570
do is do large girl system

00:13:50,730 --> 00:13:56,399
orchestrations so in simple terms what

00:13:54,570 --> 00:13:59,310
you could do with an elastic notify is

00:13:56,399 --> 00:14:02,100
say flapjack is telling you flight deck

00:13:59,310 --> 00:14:03,449
is telling itself that that it's not

00:14:02,100 --> 00:14:04,860
able to keep up with a number of checks

00:14:03,449 --> 00:14:07,529
in the system because you've loaded in a

00:14:04,860 --> 00:14:10,290
hole at holy bit of extra checks so an

00:14:07,529 --> 00:14:14,339
elastic notifier would then send out

00:14:10,290 --> 00:14:15,870
stuff to machines that are running that

00:14:14,339 --> 00:14:17,880
are ready to run flapjack worker and say

00:14:15,870 --> 00:14:19,620
okay spin up and create a whole bunch of

00:14:17,880 --> 00:14:22,380
workers they will deal with the extra

00:14:19,620 --> 00:14:24,660
load and the system basically sort of

00:14:22,380 --> 00:14:26,670
self heels and and and looks after

00:14:24,660 --> 00:14:28,470
itself and close of the load and it also

00:14:26,670 --> 00:14:30,990
works in the other direction as well

00:14:28,470 --> 00:14:33,060
where you have too many machines running

00:14:30,990 --> 00:14:34,529
the workers and you know you say say

00:14:33,060 --> 00:14:36,390
you're running this on ec2 or something

00:14:34,529 --> 00:14:37,709
like that and you don't want to be

00:14:36,390 --> 00:14:39,390
paying for all this extra machines the

00:14:37,709 --> 00:14:40,709
elastic notifier could do the opposite

00:14:39,390 --> 00:14:42,240
where it goes okay shut down all these

00:14:40,709 --> 00:14:46,769
machines until you know we've reached

00:14:42,240 --> 00:14:49,350
the optimal load for the system the next

00:14:46,769 --> 00:14:51,000
API is the distance API and there's a

00:14:49,350 --> 00:14:52,560
whole bunch of methods here and if you

00:14:51,000 --> 00:14:54,720
look through the documentation there's a

00:14:52,560 --> 00:14:56,370
lot of information about how to how to

00:14:54,720 --> 00:14:58,050
build different persistence API is

00:14:56,370 --> 00:14:59,940
everything is very well tested as well

00:14:58,050 --> 00:15:00,930
so the tests are a fantastic source for

00:14:59,940 --> 00:15:03,120
working out how to write your own

00:15:00,930 --> 00:15:05,640
persistence API is right now there are

00:15:03,120 --> 00:15:07,410
two persistence backends that are

00:15:05,640 --> 00:15:09,630
provided with flapjack there's a sequel

00:15:07,410 --> 00:15:12,529
light and a CouchDB i also have a my

00:15:09,630 --> 00:15:14,850
sequel one in the works as well the

00:15:12,529 --> 00:15:17,130
positions API gives you a whole bunch of

00:15:14,850 --> 00:15:19,170
advantages such as subclassing so let's

00:15:17,130 --> 00:15:21,149
say hypothetically you have a my sequel

00:15:19,170 --> 00:15:22,890
back-end and you're using that on on

00:15:21,149 --> 00:15:25,079
your flapjack instance in your business

00:15:22,890 --> 00:15:27,089
and you find that there are particular

00:15:25,079 --> 00:15:29,910
workloads that you need to optimize for

00:15:27,089 --> 00:15:31,740
or two to make a run faster so if we

00:15:29,910 --> 00:15:33,389
take this my sequel back in and we

00:15:31,740 --> 00:15:35,850
subclass it when we call it a my sequel

00:15:33,389 --> 00:15:37,980
with memcache back in and we say take

00:15:35,850 --> 00:15:40,620
the get check method and what we do is

00:15:37,980 --> 00:15:42,689
we make a call out to memcache first to

00:15:40,620 --> 00:15:43,860
see whether we can get get a copy of the

00:15:42,689 --> 00:15:44,970
check from M case which is obviously

00:15:43,860 --> 00:15:47,309
going to be faster than hitting the

00:15:44,970 --> 00:15:49,410
database right so if we don't get

00:15:47,309 --> 00:15:51,089
something back from M caged then we just

00:15:49,410 --> 00:15:52,829
call the original method which is the

00:15:51,089 --> 00:15:55,860
original get check method on the my

00:15:52,829 --> 00:15:57,209
sequel plus and that will do the that

00:15:55,860 --> 00:15:58,379
will do the lookup in the database and

00:15:57,209 --> 00:15:59,970
get that and then we store that in the

00:15:58,379 --> 00:16:01,350
mem case so the next time somebody needs

00:15:59,970 --> 00:16:04,470
to get that particular check they can

00:16:01,350 --> 00:16:06,269
just get it out of the medication the

00:16:04,470 --> 00:16:09,149
other nice thing about the persistence

00:16:06,269 --> 00:16:10,680
API is is it represents all the

00:16:09,149 --> 00:16:12,540
information in the system just using

00:16:10,680 --> 00:16:14,550
standard Ruby objects just the hashes

00:16:12,540 --> 00:16:16,949
and arrays and that sort of thing which

00:16:14,550 --> 00:16:19,170
lets you do a lot of nifty things like

00:16:16,949 --> 00:16:21,629
migrations so if we have say some

00:16:19,170 --> 00:16:24,029
testing here you want to say ok i'm

00:16:21,629 --> 00:16:26,490
using the sequel light persistence back

00:16:24,029 --> 00:16:29,160
end and then I run the standard set of

00:16:26,490 --> 00:16:31,559
persistence tests and then I migrated to

00:16:29,160 --> 00:16:33,959
the couch DB back end here and then I

00:16:31,559 --> 00:16:36,120
run the same test again then the results

00:16:33,959 --> 00:16:38,040
should be the same this is a great way

00:16:36,120 --> 00:16:40,019
to verify that if you migrate your

00:16:38,040 --> 00:16:42,540
monitoring system from one configuration

00:16:40,019 --> 00:16:43,920
back end to another that everything

00:16:42,540 --> 00:16:46,199
works in the same way that it was

00:16:43,920 --> 00:16:47,670
working previously you can also do all

00:16:46,199 --> 00:16:49,410
the things like benchmarking you can

00:16:47,670 --> 00:16:51,779
build different loads in the system that

00:16:49,410 --> 00:16:53,249
go ok let's say I have thirty percent of

00:16:51,779 --> 00:16:54,600
my checks that are failing all the time

00:16:53,249 --> 00:16:56,399
and then I have twenty percent that are

00:16:54,600 --> 00:16:58,980
sort of warning and then the other fifty

00:16:56,399 --> 00:17:00,089
percent are working all the time and we

00:16:58,980 --> 00:17:02,100
run all these different benchmarks

00:17:00,089 --> 00:17:03,329
across all the different backends in

00:17:02,100 --> 00:17:06,029
different configuration options and you

00:17:03,329 --> 00:17:07,260
can see for your environment what what

00:17:06,029 --> 00:17:10,049
what different backends are going to

00:17:07,260 --> 00:17:11,909
work best for you and finally web

00:17:10,049 --> 00:17:13,829
interfaces as well this isn't say P I

00:17:11,909 --> 00:17:15,630
makes it very easy to build a single web

00:17:13,829 --> 00:17:17,730
interface that doesn't care about how

00:17:15,630 --> 00:17:20,490
you're storing data in the back end it's

00:17:17,730 --> 00:17:21,720
it's just talking over this API so it

00:17:20,490 --> 00:17:23,699
means you write the web interface once

00:17:21,720 --> 00:17:25,799
and then you never have to you know have

00:17:23,699 --> 00:17:29,370
to customize it for each each back-end

00:17:25,799 --> 00:17:31,230
that you're dealing with and the final

00:17:29,370 --> 00:17:32,789
set of AP is and the notifier are the

00:17:31,230 --> 00:17:35,789
filter AP is and these are probably the

00:17:32,789 --> 00:17:37,530
coolest feature of flapjack so flight

00:17:35,789 --> 00:17:39,600
jack takes the approach that we should

00:17:37,530 --> 00:17:40,690
always be notifying unless there's

00:17:39,600 --> 00:17:43,450
something that's blocking us from

00:17:40,690 --> 00:17:45,009
notifying so we have this this filters

00:17:43,450 --> 00:17:46,809
chain here and what this particular

00:17:45,009 --> 00:17:48,549
method does is it's going through all

00:17:46,809 --> 00:17:50,919
the filters and it passes in the result

00:17:48,549 --> 00:17:54,879
and if any of those filters block then

00:17:50,919 --> 00:17:56,919
we don't notify so let us take an

00:17:54,879 --> 00:17:58,960
example filter here we have an ok filter

00:17:56,919 --> 00:18:01,059
and what the ok filter does is it says

00:17:58,960 --> 00:18:04,259
ok if the result is not warning or is

00:18:01,059 --> 00:18:06,519
not critical then we do need to notify

00:18:04,259 --> 00:18:08,139
and then you can couple that very easily

00:18:06,519 --> 00:18:09,820
with other things like you know any

00:18:08,139 --> 00:18:10,899
parents failed so you know in a

00:18:09,820 --> 00:18:12,789
monitoring system rate you're going to

00:18:10,899 --> 00:18:13,929
have hierarchies of checks where some

00:18:12,789 --> 00:18:15,909
checks depend on other checks which

00:18:13,929 --> 00:18:19,240
depend on other checks and whatnot so if

00:18:15,909 --> 00:18:20,740
a child check is failing and its parent

00:18:19,240 --> 00:18:22,120
is failing you obviously don't want to

00:18:20,740 --> 00:18:24,429
notify that because the parent check is

00:18:22,120 --> 00:18:27,250
more important so this is really easy to

00:18:24,429 --> 00:18:30,519
do you can go here with the persistence

00:18:27,250 --> 00:18:32,500
API you pass in if the any any parents

00:18:30,519 --> 00:18:34,299
failing of the particular check that

00:18:32,500 --> 00:18:37,000
we're dealing with right now and if they

00:18:34,299 --> 00:18:38,679
are then we block and that means that we

00:18:37,000 --> 00:18:40,690
don't need to notify so it handles that

00:18:38,679 --> 00:18:43,750
problem quite quite elegantly you can

00:18:40,690 --> 00:18:46,149
also do other things like like filters

00:18:43,750 --> 00:18:48,070
for downtime or for acknowledged or

00:18:46,149 --> 00:18:49,899
acknowledged alerts or anything like

00:18:48,070 --> 00:18:54,129
that the sky's the limit basically when

00:18:49,899 --> 00:18:56,110
it comes to writing filters the final

00:18:54,129 --> 00:18:57,370
component of flapjack is the admin

00:18:56,110 --> 00:18:58,480
interface and I wouldn't really talk

00:18:57,370 --> 00:19:00,309
about that all that much because

00:18:58,480 --> 00:19:02,889
basically I've thrown out all the codes

00:19:00,309 --> 00:19:08,139
that I wrote because it was crap and I'm

00:19:02,889 --> 00:19:09,789
working on new stuff that's fantastic so

00:19:08,139 --> 00:19:11,950
the next important thing about flapjack

00:19:09,789 --> 00:19:13,629
is that it talks in our jaws plug-in

00:19:11,950 --> 00:19:15,370
format and and this is really important

00:19:13,629 --> 00:19:16,659
for a couple of reasons mainly because

00:19:15,370 --> 00:19:18,370
there's not a lot of point in

00:19:16,659 --> 00:19:21,220
reinventing the wheel because you're

00:19:18,370 --> 00:19:23,019
just going to do a run the fantastic

00:19:21,220 --> 00:19:24,789
thing about nagios and the nodules

00:19:23,019 --> 00:19:27,669
plug-in format is that it provides a

00:19:24,789 --> 00:19:31,120
formal interface for writing plugins and

00:19:27,669 --> 00:19:34,149
consumers so the interface being in exit

00:19:31,120 --> 00:19:36,610
0 exit 10 exit to translates a good bad

00:19:34,149 --> 00:19:38,769
or ugly and you can provide extra

00:19:36,610 --> 00:19:41,559
information in there as well with with

00:19:38,769 --> 00:19:43,269
with the extra reporting stuff and the

00:19:41,559 --> 00:19:45,730
great thing about this is that it's so

00:19:43,269 --> 00:19:47,230
easy to implement that that's why there

00:19:45,730 --> 00:19:49,119
are tens of thousands of Nigel's plugins

00:19:47,230 --> 00:19:50,200
out there right why why ignore all of

00:19:49,119 --> 00:19:52,030
them in

00:19:50,200 --> 00:19:53,290
and switches something new when they all

00:19:52,030 --> 00:19:55,720
do a fantastic job of what they do

00:19:53,290 --> 00:19:57,940
already and the other great thing is

00:19:55,720 --> 00:20:00,120
that it's it's the industry standard in

00:19:57,940 --> 00:20:02,290
the monitoring world right everybody

00:20:00,120 --> 00:20:03,640
understands and talks than our jaws plug

00:20:02,290 --> 00:20:04,960
in format so there's not a lot of point

00:20:03,640 --> 00:20:06,250
in switching away and trying to convince

00:20:04,960 --> 00:20:12,670
people to use something that's better

00:20:06,250 --> 00:20:14,950
because it works quite well so the other

00:20:12,670 --> 00:20:16,600
thing about flapjack is that it really

00:20:14,950 --> 00:20:18,850
strives to not do any sort of data

00:20:16,600 --> 00:20:21,160
collection at all it is essentially a

00:20:18,850 --> 00:20:24,100
notification system that things are bad

00:20:21,160 --> 00:20:26,230
whatever those things may be and it

00:20:24,100 --> 00:20:28,780
leaves the data collection problems and

00:20:26,230 --> 00:20:30,070
the actual writing checks themselves up

00:20:28,780 --> 00:20:32,560
to other projects that do that much

00:20:30,070 --> 00:20:34,150
better and I really subscribe to the

00:20:32,560 --> 00:20:36,790
UNIX philosophy of doing one thing and

00:20:34,150 --> 00:20:38,410
doing it well so there are three

00:20:36,790 --> 00:20:40,570
different i posit that there are three

00:20:38,410 --> 00:20:42,910
different types of checks I think that

00:20:40,570 --> 00:20:44,200
there are gauges which are for you know

00:20:42,910 --> 00:20:46,120
getting sort of lower level statistics

00:20:44,200 --> 00:20:48,550
like things like things that like

00:20:46,120 --> 00:20:51,940
ganglia would would provide information

00:20:48,550 --> 00:20:54,130
on or other things like collecti so low

00:20:51,940 --> 00:20:57,100
level stats about CPU usage and network

00:20:54,130 --> 00:21:00,280
usage and all that sort of thing then

00:20:57,100 --> 00:21:01,660
you have behavioral checks saying you

00:21:00,280 --> 00:21:04,210
know when I interact with the system in

00:21:01,660 --> 00:21:06,520
this way am I getting the result that I

00:21:04,210 --> 00:21:08,050
expect from it and things like to come

00:21:06,520 --> 00:21:10,270
and IG else do that quite well and I'm

00:21:08,050 --> 00:21:11,710
going to talk about that in a minute and

00:21:10,270 --> 00:21:14,050
then finally trending and there's

00:21:11,710 --> 00:21:16,510
nothing really that does that all that

00:21:14,050 --> 00:21:18,610
well at the moment the training is more

00:21:16,510 --> 00:21:20,710
of a more a function of the monitoring

00:21:18,610 --> 00:21:22,450
system itself and eventually the filters

00:21:20,710 --> 00:21:24,610
will probably implement some sort of

00:21:22,450 --> 00:21:26,080
trending in some way there's this

00:21:24,610 --> 00:21:28,030
recognizer as well which is another

00:21:26,080 --> 00:21:30,160
monitoring system that is doing some

00:21:28,030 --> 00:21:31,450
interesting software trending so that if

00:21:30,160 --> 00:21:33,040
you're interesting if you're interested

00:21:31,450 --> 00:21:37,090
in trending monitoring systems that's

00:21:33,040 --> 00:21:39,090
definitely worth checking out so we're

00:21:37,090 --> 00:21:41,260
going to segue for a tiny bit on to

00:21:39,090 --> 00:21:43,900
Keuka Minaj eos which is another tool

00:21:41,260 --> 00:21:46,000
that i wrote and chew gum and arduous is

00:21:43,900 --> 00:21:47,620
all about wed testing and behavior

00:21:46,000 --> 00:21:48,970
driven infrastructure i'll talk about

00:21:47,620 --> 00:21:49,900
behavior of an infrastructure in a

00:21:48,970 --> 00:21:55,270
minute because it's sort of an out-there

00:21:49,900 --> 00:21:57,040
term so very simply cucumber allows you

00:21:55,270 --> 00:21:59,020
is basically an executable

00:21:57,040 --> 00:22:00,790
specifications so you right in plain

00:21:59,020 --> 00:22:02,990
human understandable language how you

00:22:00,790 --> 00:22:05,270
expect the system to be behaving

00:22:02,990 --> 00:22:06,679
so in this particular example here we're

00:22:05,270 --> 00:22:09,890
saying that when I visit this particular

00:22:06,679 --> 00:22:11,690
URL so cool in New Zealand and I fill in

00:22:09,890 --> 00:22:13,460
the query with Wikipedia and I press the

00:22:11,690 --> 00:22:16,130
Google search button then I should see

00:22:13,460 --> 00:22:19,460
this particular string on the page right

00:22:16,130 --> 00:22:22,790
and entirely what cucumber does is it

00:22:19,460 --> 00:22:25,280
maps each of those steps over here to to

00:22:22,790 --> 00:22:28,190
these little Ruby dsl fragments and

00:22:25,280 --> 00:22:29,900
water will do is will call out to to

00:22:28,190 --> 00:22:31,640
some other system to do the interaction

00:22:29,900 --> 00:22:32,960
with the web sites and cucumber no gos

00:22:31,640 --> 00:22:36,620
makes all this stuff really really easy

00:22:32,960 --> 00:22:38,540
to do so normally when you run cucumber

00:22:36,620 --> 00:22:40,760
just by itself which is a traditionally

00:22:38,540 --> 00:22:42,400
a web testing project but it works quite

00:22:40,760 --> 00:22:44,990
well and all these other cases as well

00:22:42,400 --> 00:22:47,030
the all the all these features exist in

00:22:44,990 --> 00:22:49,460
a single file so less to say this is the

00:22:47,030 --> 00:22:51,410
search feature here and when you run

00:22:49,460 --> 00:22:52,700
that you'll get a bunch of pretty output

00:22:51,410 --> 00:22:54,110
that says you know I ran through all the

00:22:52,700 --> 00:22:57,140
steps and they all worked and it was

00:22:54,110 --> 00:22:58,610
fantastic cool so what Q common agios

00:22:57,140 --> 00:23:00,980
does is it does exactly the same thing I

00:22:58,610 --> 00:23:03,140
once through all those steps and then if

00:23:00,980 --> 00:23:04,580
it works then it will output in the NAR

00:23:03,140 --> 00:23:06,500
just plug in format whether it worked or

00:23:04,580 --> 00:23:09,740
not and it means that you can write

00:23:06,500 --> 00:23:11,660
these high level tests in plain human

00:23:09,740 --> 00:23:15,830
language and plug them into your

00:23:11,660 --> 00:23:18,170
monitoring system so let's have a very

00:23:15,830 --> 00:23:20,690
quick look at how it works so the idea

00:23:18,170 --> 00:23:24,410
is that you install kyouko Minaj eos gem

00:23:20,690 --> 00:23:26,690
distributed is a ruby gem and you run

00:23:24,410 --> 00:23:28,130
coup comme adagios gin to generate a

00:23:26,690 --> 00:23:31,040
project and this particular case of

00:23:28,130 --> 00:23:32,540
potsdam 10 and then we CD in 2010 and

00:23:31,040 --> 00:23:34,940
then we run this gem bundle command and

00:23:32,540 --> 00:23:36,230
this gem bundle command takes all the

00:23:34,940 --> 00:23:39,260
different dependencies the Q common

00:23:36,230 --> 00:23:40,610
agios requires for it to run and freezes

00:23:39,260 --> 00:23:41,870
them into the single application so that

00:23:40,610 --> 00:23:43,700
means you can just tear up that

00:23:41,870 --> 00:23:45,320
directory and then distributor on your

00:23:43,700 --> 00:23:49,460
on your production monitoring

00:23:45,320 --> 00:23:51,770
environment and and that's it so we

00:23:49,460 --> 00:23:54,920
actually look at the way that it works

00:23:51,770 --> 00:23:58,130
so here's one I prepared earlier so

00:23:54,920 --> 00:24:04,790
within that if we go to come burn agios

00:23:58,130 --> 00:24:08,600
gin feature safe was damn dog and we're

00:24:04,790 --> 00:24:10,460
going to look at the navigation right so

00:24:08,600 --> 00:24:13,400
this goes and it generates a bunch of

00:24:10,460 --> 00:24:16,720
stuff for us you guys can see that ok up

00:24:13,400 --> 00:24:20,000
the back great

00:24:16,720 --> 00:24:21,590
so if we look here it's generated

00:24:20,000 --> 00:24:24,260
justice to get a bit of scaffolding for

00:24:21,590 --> 00:24:26,120
us and if we run that right now then

00:24:24,260 --> 00:24:31,030
hopefully that should work assuming that

00:24:26,120 --> 00:24:31,030
Faust m dot org hasn't just gone down so

00:24:31,150 --> 00:24:36,430
Chico Minaj eos provides a bunch of

00:24:34,700 --> 00:24:39,560
built-in steps for doing things like

00:24:36,430 --> 00:24:41,000
interacting with websites so this is

00:24:39,560 --> 00:24:42,890
built-in library saying you know when I

00:24:41,000 --> 00:24:44,750
go to here or when i press this button

00:24:42,890 --> 00:24:46,610
or when I fill in or all these different

00:24:44,750 --> 00:24:50,240
things right it also has other things

00:24:46,610 --> 00:24:51,890
like SSH steps which I'll talk about in

00:24:50,240 --> 00:24:54,080
a minute for interacting with machines

00:24:51,890 --> 00:24:57,380
over recitation why not but I'll get to

00:24:54,080 --> 00:25:06,860
that in a second anyway if we go back

00:24:57,380 --> 00:25:11,320
here and we go okay when I follow when I

00:25:06,860 --> 00:25:20,630
follow say cracks my follower tracks

00:25:11,320 --> 00:25:28,400
then I should see I should see lightning

00:25:20,630 --> 00:25:31,850
talks okay so if we run so if we run

00:25:28,400 --> 00:25:34,340
that right so you can see here that

00:25:31,850 --> 00:25:37,250
there were four steps the past and that

00:25:34,340 --> 00:25:42,020
was all great and say if we said we

00:25:37,250 --> 00:25:47,480
modify that to be and then and I should

00:25:42,020 --> 00:25:50,990
see spoons of hopefully that isn't on

00:25:47,480 --> 00:25:53,240
the page great so we've got a critical

00:25:50,990 --> 00:25:54,290
here of one so obviously that string

00:25:53,240 --> 00:25:56,030
wasn't there so the cool thing about

00:25:54,290 --> 00:25:59,200
this is you can actually pass a bunch of

00:25:56,030 --> 00:26:02,170
other options so if we pass pudding

00:25:59,200 --> 00:26:05,030
it'll run through and it shows here that

00:26:02,170 --> 00:26:08,300
this particular thing failed and if we

00:26:05,030 --> 00:26:09,860
go up we see here and I should see

00:26:08,300 --> 00:26:15,950
spoons of doom expected spoons of doom

00:26:09,860 --> 00:26:18,529
didn't see spoons of doom great ok

00:26:15,950 --> 00:26:19,429
so yeah that's true comentarios and you

00:26:18,529 --> 00:26:21,710
can do a bunch of other interesting

00:26:19,429 --> 00:26:24,470
stuff like this new term called

00:26:21,710 --> 00:26:27,220
behavior-driven infrastructure so just

00:26:24,470 --> 00:26:30,889
after I presented to come and agios in

00:26:27,220 --> 00:26:32,840
October last year Martin in England from

00:26:30,889 --> 00:26:35,360
Sun piped up on the puppet users mailing

00:26:32,840 --> 00:26:36,740
list saying you know hey I've played

00:26:35,360 --> 00:26:38,570
around with this cucumber stuff before

00:26:36,740 --> 00:26:40,190
and wouldn't it be sort of cool if we

00:26:38,570 --> 00:26:42,740
could take all this cucumber stuff and

00:26:40,190 --> 00:26:44,960
apply it to the idea of configuration

00:26:42,740 --> 00:26:46,700
management or build management and he

00:26:44,960 --> 00:26:49,519
basically put together this blog post

00:26:46,700 --> 00:26:53,139
describing out he was using cucumber to

00:26:49,519 --> 00:26:55,580
to verify the the builds of his system

00:26:53,139 --> 00:26:57,799
so the interesting thing that came out

00:26:55,580 --> 00:26:59,690
of the discussion from this was that you

00:26:57,799 --> 00:27:01,730
can actually think of puppet as being a

00:26:59,690 --> 00:27:03,590
build tool for configuring systems right

00:27:01,730 --> 00:27:05,809
so the bill tool or like a programming

00:27:03,590 --> 00:27:07,460
language and then cucumber itself being

00:27:05,809 --> 00:27:08,630
a testing tool to verify that your

00:27:07,460 --> 00:27:10,690
systems are configured it in the way

00:27:08,630 --> 00:27:12,740
that you expect them to be configured

00:27:10,690 --> 00:27:14,990
the other interesting thing about this

00:27:12,740 --> 00:27:17,299
is that it's not Papa centric right you

00:27:14,990 --> 00:27:18,710
could you see if engine or chef or do

00:27:17,299 --> 00:27:20,389
you all do your own hand role

00:27:18,710 --> 00:27:21,649
configuration and the hand role

00:27:20,389 --> 00:27:23,149
configuration thing is actually quite

00:27:21,649 --> 00:27:24,529
interesting because let's just say

00:27:23,149 --> 00:27:27,139
hypothetically you have a bunch of

00:27:24,529 --> 00:27:29,510
machines that aren't Papa tised and that

00:27:27,139 --> 00:27:31,370
have been sort of crafted over the years

00:27:29,510 --> 00:27:33,279
and nobody really knows what's going on

00:27:31,370 --> 00:27:35,840
with them but you want to migrate to a

00:27:33,279 --> 00:27:37,789
configuration managed environment so you

00:27:35,840 --> 00:27:39,710
could use cucumber and cucumber nagios

00:27:37,789 --> 00:27:42,169
to describe how the system is currently

00:27:39,710 --> 00:27:43,970
working testing that that all these

00:27:42,169 --> 00:27:46,250
different behaviors and interactions

00:27:43,970 --> 00:27:48,919
work the way that you expect and then

00:27:46,250 --> 00:27:50,929
once you've done that you can build a

00:27:48,919 --> 00:27:53,659
bunch of stuff with puppet or chef or CF

00:27:50,929 --> 00:27:56,240
engine or whatever and you basically

00:27:53,659 --> 00:28:01,519
iterate in your configuration management

00:27:56,240 --> 00:28:03,019
tool until all your tests are passing so

00:28:01,519 --> 00:28:05,179
there are a bunch of other things that

00:28:03,019 --> 00:28:07,789
are in the works likes a mail server

00:28:05,179 --> 00:28:09,679
tests so let's say I want to have a

00:28:07,789 --> 00:28:11,120
bunch of local logins for mail service

00:28:09,679 --> 00:28:13,610
so say that when I had don't have any

00:28:11,120 --> 00:28:15,230
public key set and is sh t this machine

00:28:13,610 --> 00:28:17,179
with this user name and password all

00:28:15,230 --> 00:28:18,860
this stuff should work and also works

00:28:17,179 --> 00:28:20,590
for elder blog ins or whatever sort of

00:28:18,860 --> 00:28:23,510
authentication system that you're using

00:28:20,590 --> 00:28:24,950
and then other things like mail right so

00:28:23,510 --> 00:28:26,899
you're saying that when I am using this

00:28:24,950 --> 00:28:28,580
mail server and I login with this user

00:28:26,899 --> 00:28:29,630
name and password and I send this mail

00:28:28,580 --> 00:28:31,220
to this person

00:28:29,630 --> 00:28:33,110
then it should sound correctly and

00:28:31,220 --> 00:28:35,330
obviously the next step of this is the

00:28:33,110 --> 00:28:37,070
the receiver the receiving at the other

00:28:35,330 --> 00:28:38,630
end right you know we can take week we

00:28:37,070 --> 00:28:40,490
can check that the delivery works okay

00:28:38,630 --> 00:28:41,900
but if the user isn't receiving mail the

00:28:40,490 --> 00:28:46,700
other and it isn't isn't really all that

00:28:41,900 --> 00:28:49,130
useful so the question is then why would

00:28:46,700 --> 00:28:51,560
I want to do this the thing about

00:28:49,130 --> 00:28:53,180
monitoring right now is that most checks

00:28:51,560 --> 00:28:55,550
are actually asking the wrong questions

00:28:53,180 --> 00:28:58,430
most checks are doing some sort of ping

00:28:55,550 --> 00:28:59,720
or a TCP connect to verify that

00:28:58,430 --> 00:29:01,970
something is the way that you expect it

00:28:59,720 --> 00:29:04,640
to be and those things are basically

00:29:01,970 --> 00:29:07,490
asking is my server up or can I see my

00:29:04,640 --> 00:29:09,860
application right that doesn't deal with

00:29:07,490 --> 00:29:11,330
a bunch of edge cases like a vm going

00:29:09,860 --> 00:29:13,100
down and the network stack being up

00:29:11,330 --> 00:29:15,560
obviously it's still going to respond to

00:29:13,100 --> 00:29:18,050
ping right or it doesn't matter if your

00:29:15,560 --> 00:29:20,630
web server is up if you're serving 404s

00:29:18,050 --> 00:29:23,030
all the time or five hundreds it doesn't

00:29:20,630 --> 00:29:24,710
really matter right and that basically

00:29:23,030 --> 00:29:28,340
means you're monitoring system is dead

00:29:24,710 --> 00:29:30,140
in the water so you comin agios allows

00:29:28,340 --> 00:29:32,150
you to ask the right questions a lot

00:29:30,140 --> 00:29:33,770
more easily things like is my appt

00:29:32,150 --> 00:29:35,990
behaving you know can i navigate around

00:29:33,770 --> 00:29:37,850
my website you know can I place an order

00:29:35,990 --> 00:29:40,580
can I sign in all these different things

00:29:37,850 --> 00:29:43,490
and we can actually start thinking of

00:29:40,580 --> 00:29:46,790
monitoring to be sort of like continuous

00:29:43,490 --> 00:29:48,050
integration so a traditional CI life

00:29:46,790 --> 00:29:49,370
cycle is something like this where you

00:29:48,050 --> 00:29:52,550
have to check out the build the tests

00:29:49,370 --> 00:29:54,800
and the notify phase right so if we

00:29:52,550 --> 00:29:57,530
think of monitoring as being continuous

00:29:54,800 --> 00:29:59,090
integration for production apps this is

00:29:57,530 --> 00:30:00,740
actually an interesting idea because we

00:29:59,090 --> 00:30:02,330
can actually take the CI lifecycle

00:30:00,740 --> 00:30:03,740
strike out the check out in the build

00:30:02,330 --> 00:30:05,570
phase because somebody's already built

00:30:03,740 --> 00:30:08,180
the software for us and we're just doing

00:30:05,570 --> 00:30:09,920
the testing and the notification the

00:30:08,180 --> 00:30:11,480
funny thing about this is that this also

00:30:09,920 --> 00:30:12,920
looks really similar to those diagrams

00:30:11,480 --> 00:30:17,420
that I had earlier about while flapjack

00:30:12,920 --> 00:30:19,490
is doing so let's just think okay so in

00:30:17,420 --> 00:30:20,750
your monitoring system what your checks

00:30:19,490 --> 00:30:22,460
are currently doing or saying you know

00:30:20,750 --> 00:30:23,960
can I see my app can I do some sort of

00:30:22,460 --> 00:30:26,540
TCP connect and you're checking for a

00:30:23,960 --> 00:30:29,570
string or whatever and let's think about

00:30:26,540 --> 00:30:31,040
that check that you're doing in in a

00:30:29,570 --> 00:30:33,410
continuous integration life cycle so

00:30:31,040 --> 00:30:34,760
let's think about the the checks that

00:30:33,410 --> 00:30:35,960
you've written sorry that the tests that

00:30:34,760 --> 00:30:38,360
you've written for your code when you're

00:30:35,960 --> 00:30:41,000
developing and thinking about asking can

00:30:38,360 --> 00:30:42,740
I see my app it doesn't make any sense

00:30:41,000 --> 00:30:43,160
at all that when you're developing the

00:30:42,740 --> 00:30:44,540
applique

00:30:43,160 --> 00:30:47,390
the only question that you're actually

00:30:44,540 --> 00:30:48,890
asking is can I see my app right because

00:30:47,390 --> 00:30:50,090
yes of course you can see you're at but

00:30:48,890 --> 00:30:50,990
it doesn't mean that it's functioning it

00:30:50,090 --> 00:30:58,700
doesn't mean that you're making any

00:30:50,990 --> 00:31:01,670
money right oops the other thing to keep

00:30:58,700 --> 00:31:03,020
in mind is this is not new other people

00:31:01,670 --> 00:31:04,400
have done this before you can already do

00:31:03,020 --> 00:31:06,560
this with a bunch of different checks

00:31:04,400 --> 00:31:08,440
you know if you're using you know check

00:31:06,560 --> 00:31:10,430
X to check why we check said you can get

00:31:08,440 --> 00:31:12,530
just the same the same sort of

00:31:10,430 --> 00:31:14,060
functionality but the thing about you

00:31:12,530 --> 00:31:17,090
come and add yours is that it makes all

00:31:14,060 --> 00:31:19,010
of this reuse really really trivial so

00:31:17,090 --> 00:31:21,440
it means that instead of having to write

00:31:19,010 --> 00:31:23,510
the same checks again and again you can

00:31:21,440 --> 00:31:25,400
reuse an existing library of checks that

00:31:23,510 --> 00:31:27,230
other people have that other people have

00:31:25,400 --> 00:31:28,640
written and this is great because it

00:31:27,230 --> 00:31:29,600
means that you're writing wesco which

00:31:28,640 --> 00:31:32,660
means that there will be less bugs

00:31:29,600 --> 00:31:34,310
unless bugs mean less alerts and less

00:31:32,660 --> 00:31:36,290
alerts at 3am in the morning which is

00:31:34,310 --> 00:31:41,780
obviously what we're all optimizing for

00:31:36,290 --> 00:31:45,680
right so this is a great quote that

00:31:41,780 --> 00:31:48,170
Bradley Taylor wrote and obviously it's

00:31:45,680 --> 00:31:51,050
a bit of a job but it's actually quite

00:31:48,170 --> 00:31:52,610
it's quite apt right it's really too

00:31:51,050 --> 00:31:55,250
common are just is really about building

00:31:52,610 --> 00:31:56,990
bridges between between sis admins and

00:31:55,250 --> 00:31:59,060
developers and increasing the

00:31:56,990 --> 00:32:01,360
collaboration between the two camps so

00:31:59,060 --> 00:32:04,580
that we can we can learn from each other

00:32:01,360 --> 00:32:06,410
so if we take another step back out from

00:32:04,580 --> 00:32:09,680
Chico Minaj us when we go to collect d

00:32:06,410 --> 00:32:11,750
as I finish up so collect D is a

00:32:09,680 --> 00:32:13,970
lightweight statistic collection Damon

00:32:11,750 --> 00:32:16,370
with an emphasis on collection sort of

00:32:13,970 --> 00:32:19,640
analogous to to ganglia if anybody was

00:32:16,370 --> 00:32:21,620
in the previous session it's network

00:32:19,640 --> 00:32:23,180
aware which means that you could collect

00:32:21,620 --> 00:32:25,100
statistic locally and send them upstream

00:32:23,180 --> 00:32:28,220
someplace else it has a plug-in

00:32:25,100 --> 00:32:29,600
interface and it also talks then i-gos

00:32:28,220 --> 00:32:31,280
protocol so that means that any of the

00:32:29,600 --> 00:32:33,920
statistics that you collect with collect

00:32:31,280 --> 00:32:35,420
d you can poke out with collecting our

00:32:33,920 --> 00:32:37,660
Geoff's which means you can plug it very

00:32:35,420 --> 00:32:39,890
easily into your monetary system and

00:32:37,660 --> 00:32:41,900
there's a huge list of plugins available

00:32:39,890 --> 00:32:44,390
for it and this is expanding with every

00:32:41,900 --> 00:32:46,550
release it's actually really really cool

00:32:44,390 --> 00:32:47,810
so you should if you're interested any

00:32:46,550 --> 00:32:49,670
of these plugins you should check them

00:32:47,810 --> 00:32:53,570
out only collect your website there is a

00:32:49,670 --> 00:32:54,940
bucket load of information there so if

00:32:53,570 --> 00:32:57,030
we look at some example configuration

00:32:54,940 --> 00:32:58,500
very quickly here

00:32:57,030 --> 00:33:00,360
having a collector client you can think

00:32:58,500 --> 00:33:01,980
of a collector client as being like a

00:33:00,360 --> 00:33:04,380
nigeria sagent that you're running on a

00:33:01,980 --> 00:33:05,640
machine right so we're loading up a

00:33:04,380 --> 00:33:07,050
bunch of plugins and most of these

00:33:05,640 --> 00:33:09,390
plugins don't actually need any

00:33:07,050 --> 00:33:11,100
configuration and we're saying up here

00:33:09,390 --> 00:33:14,220
that we want to collect these statistics

00:33:11,100 --> 00:33:15,600
every 20 seconds and then we have this

00:33:14,220 --> 00:33:17,190
network plugin and we're saying that all

00:33:15,600 --> 00:33:19,080
statistics that we collect locally we

00:33:17,190 --> 00:33:20,630
want to send up to this monitoring got

00:33:19,080 --> 00:33:23,100
my domain that org or you can do

00:33:20,630 --> 00:33:26,970
multicast stuff or you can specify IP

00:33:23,100 --> 00:33:29,130
addresses or whatever so then on the

00:33:26,970 --> 00:33:30,300
server at the monitoring of my domain at

00:33:29,130 --> 00:33:32,460
all we're saying we're collecting status

00:33:30,300 --> 00:33:34,380
every 20 seconds and we're using the

00:33:32,460 --> 00:33:36,660
network plugin and not as many not as

00:33:34,380 --> 00:33:38,310
many of the other plugins and we're

00:33:36,660 --> 00:33:40,140
saying up here that we're listening on

00:33:38,310 --> 00:33:42,510
this particular address and all

00:33:40,140 --> 00:33:43,890
statistics that come in oops all

00:33:42,510 --> 00:33:45,510
statistics are come in we're going to

00:33:43,890 --> 00:33:47,280
write them out using our ID tool to this

00:33:45,510 --> 00:33:48,930
particular directory here and we're

00:33:47,280 --> 00:33:50,160
doing where we're holding on to those

00:33:48,930 --> 00:33:52,020
statistics for nine hundred seconds

00:33:50,160 --> 00:33:54,000
before we flush them out to disk and you

00:33:52,020 --> 00:33:55,740
can also use other things like our IDK

00:33:54,000 --> 00:33:57,990
CD which was mentioned in the last talk

00:33:55,740 --> 00:33:59,220
as well if you have like 20 limits of

00:33:57,990 --> 00:34:03,020
statistics that you want to log out to

00:33:59,220 --> 00:34:05,160
disk the other awesome thing about

00:34:03,020 --> 00:34:07,800
collecting is that there are language

00:34:05,160 --> 00:34:10,110
bindings for the network protocol so it

00:34:07,800 --> 00:34:13,110
means that within your applications you

00:34:10,110 --> 00:34:15,060
can instrument statistics from like

00:34:13,110 --> 00:34:18,030
within your web app or within your tom

00:34:15,060 --> 00:34:19,770
cat app or whatever and send them over

00:34:18,030 --> 00:34:21,090
the network to a running collecting

00:34:19,770 --> 00:34:22,800
instance which is a great way if you

00:34:21,090 --> 00:34:25,050
need to instrument statistics within

00:34:22,800 --> 00:34:26,730
your applications without having to

00:34:25,050 --> 00:34:31,110
build all sorts of extra crazy stuff on

00:34:26,730 --> 00:34:33,330
top of it so finally going back to

00:34:31,110 --> 00:34:35,460
flapjack some stuff about what's

00:34:33,330 --> 00:34:38,040
happening in the next few months so

00:34:35,460 --> 00:34:40,350
right now flapjack is distributed as a

00:34:38,040 --> 00:34:42,030
ruby gem which is really ghetto and

00:34:40,350 --> 00:34:44,340
inappropriate for a system

00:34:42,030 --> 00:34:45,990
administration tool there are a bunch of

00:34:44,340 --> 00:34:48,120
people some of whom are here in the

00:34:45,990 --> 00:34:49,980
audience who are building packages for

00:34:48,120 --> 00:34:53,130
different distributions and to those of

00:34:49,980 --> 00:34:55,110
you who are here I thank you the other

00:34:53,130 --> 00:34:57,030
nice thing about flood Jack in the next

00:34:55,110 --> 00:34:59,400
few months we'll be implementing nice

00:34:57,030 --> 00:35:01,170
graphs in the admin interface it will

00:34:59,400 --> 00:35:03,450
make it a lot easier to sell to your

00:35:01,170 --> 00:35:05,730
boss or whoever when they've got nice

00:35:03,450 --> 00:35:06,870
pretty stuff to click on so there's

00:35:05,730 --> 00:35:09,180
another project that I've been working

00:35:06,870 --> 00:35:13,819
on called village

00:35:09,180 --> 00:35:13,819
and oops apparently this link is working

00:35:15,770 --> 00:35:18,770
sorry

00:35:24,839 --> 00:35:31,769
okay two ago so what Vistage does is it

00:35:28,829 --> 00:35:33,960
renders the raw statistics that that our

00:35:31,769 --> 00:35:35,759
ID sorry the collective rights out our

00:35:33,960 --> 00:35:37,979
IDs and it renders them in the browser

00:35:35,759 --> 00:35:39,210
and not just rendering them in the

00:35:37,979 --> 00:35:41,910
browser but it means that everything

00:35:39,210 --> 00:35:44,039
that you see here on on on the screen is

00:35:41,910 --> 00:35:46,499
actually a Dom element so it means that

00:35:44,039 --> 00:35:48,239
you can do funky things like if I put my

00:35:46,499 --> 00:35:49,529
mouse over this particular thing here I

00:35:48,239 --> 00:35:51,960
don't know whether you can see up the

00:35:49,529 --> 00:35:53,219
back but sort of fading in or not that's

00:35:51,960 --> 00:35:55,200
sort of cute and you can toggle them in

00:35:53,219 --> 00:35:59,269
and out and all that sort of thing and

00:35:55,200 --> 00:36:05,160
you can also do other things like that

00:35:59,269 --> 00:36:06,869
right sort of me which the other thing

00:36:05,160 --> 00:36:08,880
that the Timbers inches that I haven't

00:36:06,869 --> 00:36:11,009
publicly released yet is all this stuff

00:36:08,880 --> 00:36:12,960
is embeddable so all these graphs that

00:36:11,009 --> 00:36:15,119
you see here on the village dashboard

00:36:12,960 --> 00:36:16,410
there's there this some code that I've

00:36:15,119 --> 00:36:17,940
written that you click on this embed

00:36:16,410 --> 00:36:20,339
link and it spits out a bunch of HTML

00:36:17,940 --> 00:36:22,109
you just pasted into a page which is

00:36:20,339 --> 00:36:23,369
fantastic if you want to create you know

00:36:22,109 --> 00:36:24,660
dashboards of all your different

00:36:23,369 --> 00:36:29,430
statistics that are flying around in

00:36:24,660 --> 00:36:31,589
your system the last thing is a job

00:36:29,430 --> 00:36:32,579
insertion API which if you're interested

00:36:31,589 --> 00:36:36,229
in hacking on flood track you should

00:36:32,579 --> 00:36:38,519
come and talk to me about a later so

00:36:36,229 --> 00:36:41,509
thank you very much for listening who

00:36:38,519 --> 00:36:41,509
here has questions

00:36:53,050 --> 00:36:59,350
do we have any questions at all over I

00:36:55,480 --> 00:36:59,350
dazzled you all with my brilliance

00:37:05,250 --> 00:37:11,460
about flapjack whoops sorry can we use

00:37:08,220 --> 00:37:13,590
it in production I have a older version

00:37:11,460 --> 00:37:16,230
of a running in production I've done a

00:37:13,590 --> 00:37:18,390
fairly heavy amount of brain surgery to

00:37:16,230 --> 00:37:20,850
it recently where it's not really in a

00:37:18,390 --> 00:37:22,140
production-ready state but that's

00:37:20,850 --> 00:37:26,390
certainly changing you know I'm hacking

00:37:22,140 --> 00:37:26,390
on a quite vigorously thank you

00:37:31,099 --> 00:37:37,210
any more questions does anybody want to

00:37:33,499 --> 00:37:37,210
see demos with stuff I don't know

00:37:40,049 --> 00:37:44,569
no more questions yes over there

00:37:54,230 --> 00:38:00,590
you have a few components who talk

00:37:57,619 --> 00:38:04,220
nagios but where does it leave now gives

00:38:00,590 --> 00:38:05,180
itself in the picture Italy so the

00:38:04,220 --> 00:38:06,770
question was where does it leave now

00:38:05,180 --> 00:38:09,400
girls in the picture and the answer is

00:38:06,770 --> 00:38:13,700
it leaves nine years out of the picture

00:38:09,400 --> 00:38:16,490
i I don't I don't see like blackjack is

00:38:13,700 --> 00:38:18,020
essentially a replacement for nagios and

00:38:16,490 --> 00:38:19,730
that's that's what I Jamie to try and be

00:38:18,020 --> 00:38:21,980
right now you can think of flapjack as

00:38:19,730 --> 00:38:24,230
being the infrastructure for building a

00:38:21,980 --> 00:38:26,720
monitoring system but as I'm rounding

00:38:24,230 --> 00:38:28,880
off the rough edges eventually PD aims

00:38:26,720 --> 00:38:32,410
to be like the de facto standard for

00:38:28,880 --> 00:38:32,410
monitoring in the open source world

00:38:38,340 --> 00:38:43,940

YouTube URL: https://www.youtube.com/watch?v=hpHml0QwDhg


