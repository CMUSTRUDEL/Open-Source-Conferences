Title: GPU Userspace - kernel interface & Radeon kernel modesetting status
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Jerome Glisse

The GPU is one of the most complex piece of hardware in modern computer. With kernel modesetting, more part of the driver move from userspace to the kernel allowing a cleaner support for suspend/resume and others GPU specific handling. The complexity of OpenGL driver, and also driver for new API such as OpenCL, are in userspace and will more than likely stay there.

This presentation will look at the unique problem of GPU kernel API to userspace. How userspace can interface with the kernel to submit GPU command in an as efficient as possible way. A brief review of what have been done and what is done now for various GPU, and insight on what might be better solution in the future will be given. Last part of the presentation will devolve to the status of radeon kernel modesetting which is now the largest driver inside the linux kernel with more the 70 000 lines of code and supporting more than 7 different GPU families.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:03,929
who made this possible that for example

00:00:01,740 --> 00:00:08,880
with this apparently outside still doing

00:00:03,929 --> 00:00:11,400
this organization thing preferred about

00:00:08,880 --> 00:00:13,410
myself I'm a PhD student by day and then

00:00:11,400 --> 00:00:15,960
by night I occasionally do some shader

00:00:13,410 --> 00:00:18,350
compiler hacking and that's what I'm

00:00:15,960 --> 00:00:21,779
going to talk about okay so here's a

00:00:18,350 --> 00:00:23,939
user plan for my part first of all very

00:00:21,779 --> 00:00:25,800
quickly what's glsl it probably most

00:00:23,939 --> 00:00:29,519
people know who that just very briefly

00:00:25,800 --> 00:00:32,250
then I'm going to talk about the radiant

00:00:29,519 --> 00:00:35,969
hardware r300 car 500 from a compiler

00:00:32,250 --> 00:00:38,100
writers point of view then kind of the

00:00:35,969 --> 00:00:40,230
main part will be some overview of what

00:00:38,100 --> 00:00:44,219
the compiler looks like right now and

00:00:40,230 --> 00:00:46,050
some thoughts and how we got there there

00:00:44,219 --> 00:00:49,770
will be a part on what is missing for

00:00:46,050 --> 00:00:53,190
glsl and how can we get there and some

00:00:49,770 --> 00:00:55,289
final thoughts as well okay so would you

00:00:53,190 --> 00:01:00,329
please all raise your hands for me for a

00:00:55,289 --> 00:01:03,239
moment okay those please don't raise

00:01:00,329 --> 00:01:06,000
your hands okay those of you who have

00:01:03,239 --> 00:01:10,439
worked with glsl or the tedious I

00:01:06,000 --> 00:01:13,140
assembly please put your hand down okay

00:01:10,439 --> 00:01:15,119
so most people actually actually have

00:01:13,140 --> 00:01:16,680
but there are some will happen but

00:01:15,119 --> 00:01:19,580
that's a nice trick you know to get

00:01:16,680 --> 00:01:19,580
everybody conspiration

00:01:20,070 --> 00:01:24,910
okay so here that are very rough

00:01:22,800 --> 00:01:27,580
overview of what the OpenGL pipeline

00:01:24,910 --> 00:01:29,500
looks like you know vertex fetching from

00:01:27,580 --> 00:01:31,840
with its arrays you have transformations

00:01:29,500 --> 00:01:33,730
that are applied then in the latest

00:01:31,840 --> 00:01:36,430
versions you have a geometry shader

00:01:33,730 --> 00:01:37,690
which can again modify that output but

00:01:36,430 --> 00:01:40,390
the hardware I'm going to talk about

00:01:37,690 --> 00:01:42,250
doesn't have it so it together then

00:01:40,390 --> 00:01:44,979
protests are assembled and rest your

00:01:42,250 --> 00:01:48,130
eyes the resulting pixels or fragments

00:01:44,979 --> 00:01:50,259
are again shaded and it all ends up in

00:01:48,130 --> 00:01:52,259
the framework for eventually and the

00:01:50,259 --> 00:01:55,450
point is that these yellow boxes are

00:01:52,259 --> 00:01:57,640
programmable so you can as you see on

00:01:55,450 --> 00:01:59,560
the right hand side there is some sea

00:01:57,640 --> 00:02:01,300
like language that you can use to modify

00:01:59,560 --> 00:02:06,970
the functionality of these yellow blocks

00:02:01,300 --> 00:02:08,800
and what we need to do as driver writers

00:02:06,970 --> 00:02:11,950
is to get from this textual

00:02:08,800 --> 00:02:15,459
representation of sensi code well see

00:02:11,950 --> 00:02:17,680
like code to fill in a structure like

00:02:15,459 --> 00:02:19,150
here which just contains the binary

00:02:17,680 --> 00:02:22,540
machine code that the hardware

00:02:19,150 --> 00:02:24,640
understands and this population step is

00:02:22,540 --> 00:02:26,500
what I'm going to talk about and then

00:02:24,640 --> 00:02:28,300
once this is once compiled then every

00:02:26,500 --> 00:02:30,580
time we do rendering using their data we

00:02:28,300 --> 00:02:33,510
just use these storage binary values and

00:02:30,580 --> 00:02:33,510
send them off to the other

00:02:34,940 --> 00:02:40,680
actually the glsl for the first step of

00:02:38,610 --> 00:02:44,220
compilation is in mesa entirely

00:02:40,680 --> 00:02:47,400
independent of the hardware it generates

00:02:44,220 --> 00:02:49,860
a intermediate assembly language which

00:02:47,400 --> 00:02:52,920
is also used for fixed function

00:02:49,860 --> 00:02:55,680
old-school opengl for the a or e

00:02:52,920 --> 00:02:57,420
extensions assembly extensions and in

00:02:55,680 --> 00:02:59,760
the case of gallium if you have some

00:02:57,420 --> 00:03:02,880
other stage better like maybe the xorg

00:02:59,760 --> 00:03:04,380
state tracker which is being hacked on

00:03:02,880 --> 00:03:05,970
then this also ends up in this assembly

00:03:04,380 --> 00:03:09,240
language form so what we need to do is

00:03:05,970 --> 00:03:11,250
we need to take this assembly language

00:03:09,240 --> 00:03:12,660
and put it into machine code and the

00:03:11,250 --> 00:03:15,090
thing is that we also need to do some

00:03:12,660 --> 00:03:17,040
optimization steps because each hardware

00:03:15,090 --> 00:03:18,570
is a little different and the assembly

00:03:17,040 --> 00:03:21,770
that is generated by the compiler may

00:03:18,570 --> 00:03:24,540
not be optimal for what we need to do

00:03:21,770 --> 00:03:26,340
and here's just some example of what

00:03:24,540 --> 00:03:28,350
this assembly language looks like so

00:03:26,340 --> 00:03:30,540
it's very self-explanatory you have some

00:03:28,350 --> 00:03:34,650
instructions like move subtract multiply

00:03:30,540 --> 00:03:36,300
and business daily Sanderson okay by the

00:03:34,650 --> 00:03:40,770
way if there are any questions of course

00:03:36,300 --> 00:03:43,590
feel free to interrupt me and okay so

00:03:40,770 --> 00:03:45,540
about the hardware I'm going to talk

00:03:43,590 --> 00:03:47,610
about our 302 our 500 which are

00:03:45,540 --> 00:03:50,100
supported in nature by a single driver

00:03:47,610 --> 00:03:51,480
or actually there is a single classic

00:03:50,100 --> 00:03:55,680
driver and there is missing a gallium

00:03:51,480 --> 00:03:57,510
driver but ok here's what this marketing

00:03:55,680 --> 00:03:59,700
terms that this roughly corresponds to

00:03:57,510 --> 00:04:01,710
in case you haven't seen it yet and if

00:03:59,700 --> 00:04:04,470
not just let me say that the newer chips

00:04:01,710 --> 00:04:05,970
librarian HD and onwards are very

00:04:04,470 --> 00:04:08,010
different in terms of programmability

00:04:05,970 --> 00:04:12,830
and i'm only going to mention it in

00:04:08,010 --> 00:04:15,870
shortly at the very end ok so we have a

00:04:12,830 --> 00:04:19,859
programmable vertex shader that's the

00:04:15,870 --> 00:04:21,540
first yellow box you've seen and the

00:04:19,859 --> 00:04:23,610
hardware there is very close to this

00:04:21,540 --> 00:04:26,640
assembly that we use intermediately

00:04:23,610 --> 00:04:28,380
which is quite nice another nice thing

00:04:26,640 --> 00:04:29,580
is that there aren't many differences

00:04:28,380 --> 00:04:32,419
across the harbor

00:04:29,580 --> 00:04:34,439
from our 300 to our 500 and the

00:04:32,419 --> 00:04:36,000
differences that are there are all in

00:04:34,439 --> 00:04:38,719
terms of new features to their backwards

00:04:36,000 --> 00:04:42,030
compatible which makes life easy for us

00:04:38,719 --> 00:04:45,719
let me give you an idea of what a PDF

00:04:42,030 --> 00:04:47,699
instruction looks like so first of all

00:04:45,719 --> 00:04:49,889
you have a bunch of of register files

00:04:47,699 --> 00:04:52,979
here indicated on the right hand side in

00:04:49,889 --> 00:04:54,719
which well you see it most of them are

00:04:52,979 --> 00:04:58,969
pretty standard except for this strange

00:04:54,719 --> 00:05:01,740
alternative temporary register file here

00:04:58,969 --> 00:05:03,449
this is just a second register file

00:05:01,740 --> 00:05:05,849
which you can store temporary values

00:05:03,449 --> 00:05:08,030
which has some different restrictions

00:05:05,849 --> 00:05:10,650
than the other temporary register file

00:05:08,030 --> 00:05:14,219
and then instructions go basically in

00:05:10,650 --> 00:05:16,199
three steps the first step is to select

00:05:14,219 --> 00:05:18,060
the up to three operands for the

00:05:16,199 --> 00:05:19,379
instruction that you want to use most of

00:05:18,060 --> 00:05:24,509
them have to but multiply and add

00:05:19,379 --> 00:05:27,419
history we can select first which

00:05:24,509 --> 00:05:29,879
register we want to use we can then take

00:05:27,419 --> 00:05:31,500
absolute values we can do Swiss link

00:05:29,879 --> 00:05:34,740
which means exchanging components or

00:05:31,500 --> 00:05:38,479
replacing components are 0 or 1 and then

00:05:34,740 --> 00:05:40,529
you can do component by its negation and

00:05:38,479 --> 00:05:43,259
this is very nice because it's very

00:05:40,529 --> 00:05:45,029
flexible in fact together the exquisite

00:05:43,259 --> 00:05:47,729
instruction that we have in the assembly

00:05:45,029 --> 00:05:50,659
you get it for free then the instruction

00:05:47,729 --> 00:05:54,330
is executed and then you have some some

00:05:50,659 --> 00:05:56,159
post processing as well our 500 is a bit

00:05:54,330 --> 00:05:58,440
more powerful here to understand to

00:05:56,159 --> 00:06:01,349
support flow control if else endif

00:05:58,440 --> 00:06:04,710
particularly in in a nicer way then we

00:06:01,349 --> 00:06:07,379
can do it on our 300 and then things are

00:06:04,710 --> 00:06:14,370
stored of person in the registers okay

00:06:07,379 --> 00:06:16,199
and okay the the machine code is just a

00:06:14,370 --> 00:06:18,089
bunch of bit fields and basically each

00:06:16,199 --> 00:06:20,520
box that have gone to on the left hand

00:06:18,089 --> 00:06:22,560
side corresponds to one bit field in

00:06:20,520 --> 00:06:25,139
this machine code so this really

00:06:22,560 --> 00:06:27,589
corresponds to our view of what the

00:06:25,139 --> 00:06:27,589
hardware does

00:06:27,610 --> 00:06:31,700
okay so from my point of view what's

00:06:30,200 --> 00:06:35,450
good about it i've already said they're

00:06:31,700 --> 00:06:36,950
very flexible it'll support most

00:06:35,450 --> 00:06:40,130
instructions that we want to implement

00:06:36,950 --> 00:06:41,720
are supported natively by this hardware

00:06:40,130 --> 00:06:43,880
which is not the case for a fragment

00:06:41,720 --> 00:06:45,530
programs especially older hardware where

00:06:43,880 --> 00:06:49,460
you have to emulate instructions like

00:06:45,530 --> 00:06:51,169
sine cosine and so on there are some

00:06:49,460 --> 00:06:53,180
not-so-nice things that the worst thing

00:06:51,169 --> 00:06:56,720
is that there are some operand

00:06:53,180 --> 00:07:01,160
restrictions so if i go back here one

00:06:56,720 --> 00:07:03,530
slide you have up to three operands but

00:07:01,160 --> 00:07:05,000
you can only use one integrate just at a

00:07:03,530 --> 00:07:07,220
time you can only use one constant

00:07:05,000 --> 00:07:09,260
register at a time and if you want to do

00:07:07,220 --> 00:07:13,280
to use more than you have to use some

00:07:09,260 --> 00:07:16,190
kind of spilling news you can also only

00:07:13,280 --> 00:07:20,810
use two temporaries at a time which

00:07:16,190 --> 00:07:22,850
means that it would be nicer to have 850

00:07:20,810 --> 00:07:24,290
a month i add would be cool if we could

00:07:22,850 --> 00:07:25,850
put two of the operands into the

00:07:24,290 --> 00:07:28,430
temporary file and the other one into

00:07:25,850 --> 00:07:29,960
the ultimate temporary because then we

00:07:28,430 --> 00:07:32,150
could do it in one cycle instead of

00:07:29,960 --> 00:07:34,340
using a micro instruction that takes two

00:07:32,150 --> 00:07:37,729
cycles but this is an optimization that

00:07:34,340 --> 00:07:40,610
we don't be yet because well lack of

00:07:37,729 --> 00:07:42,979
manpower basically also a nice feature

00:07:40,610 --> 00:07:45,800
that this processor has is that you can

00:07:42,979 --> 00:07:47,570
under certain limitations you can

00:07:45,800 --> 00:07:51,830
combine a vector instruction with a

00:07:47,570 --> 00:07:53,630
scalar or Drake instruction but the

00:07:51,830 --> 00:07:55,130
limitations are kind of nasty and again

00:07:53,630 --> 00:07:57,620
because of the lack of manpower I mean

00:07:55,130 --> 00:08:02,450
nobody has have designed to really make

00:07:57,620 --> 00:08:05,180
use of that so far the fragment

00:08:02,450 --> 00:08:06,620
processor it's called us and the mg

00:08:05,180 --> 00:08:09,979
documentation for some reason I'm not

00:08:06,620 --> 00:08:12,470
entirely sure the the weirdest thing

00:08:09,979 --> 00:08:14,720
about this piece is that the arithmetic

00:08:12,470 --> 00:08:16,460
unit is split into a three vector part

00:08:14,720 --> 00:08:19,340
for the ether three component part sorry

00:08:16,460 --> 00:08:22,750
for RGB components and one scale apart

00:08:19,340 --> 00:08:27,169
for the alpha component what's a bit

00:08:22,750 --> 00:08:28,550
well tricky but we got used to it is

00:08:27,169 --> 00:08:33,050
that there are many changes especially

00:08:28,550 --> 00:08:34,860
going to our 500 in terms of how extra

00:08:33,050 --> 00:08:38,099
instructions are scheduled

00:08:34,860 --> 00:08:40,320
additional features flow control but the

00:08:38,099 --> 00:08:42,149
nice thing is that the alley let's say

00:08:40,320 --> 00:08:44,970
philosophy of having this are to be and

00:08:42,149 --> 00:08:47,940
a slit has stayed pretty much the same

00:08:44,970 --> 00:08:50,310
which makes it easier for us to share a

00:08:47,940 --> 00:08:52,890
lot of code and again I'll show you a

00:08:50,310 --> 00:08:55,200
similar picture one before no wait

00:08:52,890 --> 00:08:56,610
there's another thing first text texture

00:08:55,200 --> 00:08:59,579
instruction schedule is an interesting

00:08:56,610 --> 00:09:02,579
problem as well because in our 300 you

00:08:59,579 --> 00:09:03,959
don't have a sequence of texture and and

00:09:02,579 --> 00:09:05,700
auto instructions that are intermixed

00:09:03,959 --> 00:09:07,290
instead you have one set of registers

00:09:05,700 --> 00:09:08,850
into which you can ride texture

00:09:07,290 --> 00:09:09,750
instructions one set of registers in

00:09:08,850 --> 00:09:12,120
which you can write arithmetic

00:09:09,750 --> 00:09:13,829
instructions and then there is our

00:09:12,120 --> 00:09:16,019
additional bit fields that tell the

00:09:13,829 --> 00:09:18,149
hardware that okay please execute first

00:09:16,019 --> 00:09:19,620
the first for texture instructions and

00:09:18,149 --> 00:09:22,589
then please execute the first ten

00:09:19,620 --> 00:09:25,110
arithmetic instructions and so on line I

00:09:22,589 --> 00:09:27,149
try to visualize here you have one block

00:09:25,110 --> 00:09:30,300
attention instructions that and they

00:09:27,149 --> 00:09:32,040
alternate and the problematic thing is

00:09:30,300 --> 00:09:33,690
that you have a very limited number of

00:09:32,040 --> 00:09:35,730
blocks on the r300 there are only four

00:09:33,690 --> 00:09:37,170
blocks of texture instructions and four

00:09:35,730 --> 00:09:39,420
blocks of arithmetic instruction fetch

00:09:37,170 --> 00:09:41,070
can use so you have to be careful to try

00:09:39,420 --> 00:09:43,829
to prove texture instructions so that

00:09:41,070 --> 00:09:46,110
they run at the same time otherwise you

00:09:43,829 --> 00:09:49,500
might not be able to support even rather

00:09:46,110 --> 00:09:51,510
simple shaders I think there was one but

00:09:49,500 --> 00:09:53,910
one's about a compass plugin that used

00:09:51,510 --> 00:09:56,279
five directly in the textures and the

00:09:53,910 --> 00:09:58,440
thing is that text rectangle textures

00:09:56,279 --> 00:10:00,660
need to be you to get caught in scaling

00:09:58,440 --> 00:10:01,649
we are referencing construction and then

00:10:00,660 --> 00:10:03,660
you have the written take checks

00:10:01,649 --> 00:10:06,300
original take text and run out of blocks

00:10:03,660 --> 00:10:08,279
so while optimizations have to do was to

00:10:06,300 --> 00:10:12,000
move all these sexy instructions

00:10:08,279 --> 00:10:13,829
together the r500 is nicer in that

00:10:12,000 --> 00:10:17,550
respect their you really have a normal

00:10:13,829 --> 00:10:19,019
sequence of instructions the sucker for

00:10:17,550 --> 00:10:21,930
that is unified five words for

00:10:19,019 --> 00:10:23,940
instructions very nice there is some

00:10:21,930 --> 00:10:25,470
potential optimizations doing manual

00:10:23,940 --> 00:10:27,360
synchronization between texture and

00:10:25,470 --> 00:10:31,440
arithmetic which should be rather simple

00:10:27,360 --> 00:10:33,800
but nobody has bothered so far yeah this

00:10:31,440 --> 00:10:33,800
is still

00:10:36,530 --> 00:10:40,920
that's an interesting question and I

00:10:39,000 --> 00:10:43,260
suspect that it does matter because you

00:10:40,920 --> 00:10:45,240
have the you have a synchronization flag

00:10:43,260 --> 00:10:47,730
in the arithmetic instructions which

00:10:45,240 --> 00:10:49,560
tells the the processor please wait

00:10:47,730 --> 00:10:51,300
until all the texture instructions are

00:10:49,560 --> 00:10:52,980
finished so if you can do some clever

00:10:51,300 --> 00:10:54,300
grouping and maybe move the arithmetic

00:10:52,980 --> 00:10:57,030
instructions that need to use the

00:10:54,300 --> 00:10:59,250
texture result as far down as possible

00:10:57,030 --> 00:11:01,590
then you could have maybe better

00:10:59,250 --> 00:11:03,870
throughput so so yeah it's a good point

00:11:01,590 --> 00:11:10,200
it's still somehow matters probably but

00:11:03,870 --> 00:11:12,600
we haven't done okay now here's what the

00:11:10,200 --> 00:11:14,640
instructions look like the the most

00:11:12,600 --> 00:11:16,650
important message is that you have this

00:11:14,640 --> 00:11:19,380
big vertical split between the three

00:11:16,650 --> 00:11:23,190
component vector hard over here and a

00:11:19,380 --> 00:11:25,590
scalar part over there even the register

00:11:23,190 --> 00:11:29,550
files are you can think of them as

00:11:25,590 --> 00:11:31,980
completely separate and as similar as

00:11:29,550 --> 00:11:33,840
before well this time you only have a

00:11:31,980 --> 00:11:36,390
constant and a pic suspect register file

00:11:33,840 --> 00:11:38,220
because the pixel stack contains both

00:11:36,390 --> 00:11:39,900
the temporary variables and is also

00:11:38,220 --> 00:11:45,150
initialized by the input into minor

00:11:39,900 --> 00:11:47,880
difference you have slightly more

00:11:45,150 --> 00:11:49,620
flexibility how you control your sources

00:11:47,880 --> 00:11:52,770
and operant so what you first do is you

00:11:49,620 --> 00:11:55,500
select source fields where registers are

00:11:52,770 --> 00:11:58,380
loaded and then you have the ability to

00:11:55,500 --> 00:12:01,200
reduce visiting across across all the

00:11:58,380 --> 00:12:04,230
units which allow us in theory for some

00:12:01,200 --> 00:12:07,110
nice hacks because you could have an

00:12:04,230 --> 00:12:09,420
operand here that uses the are component

00:12:07,110 --> 00:12:14,610
of registers 0 and the alpha component

00:12:09,420 --> 00:12:16,740
of register 10 in theory but I don't

00:12:14,610 --> 00:12:18,630
know if that's particularly useful and

00:12:16,740 --> 00:12:20,430
you can do the usual modifications then

00:12:18,630 --> 00:12:22,170
you have the instructions which are in

00:12:20,430 --> 00:12:26,010
principle separate accept that some

00:12:22,170 --> 00:12:28,680
stuff like dot product needs some

00:12:26,010 --> 00:12:30,330
crosslink also you have the ability to

00:12:28,680 --> 00:12:32,580
take the output is similar in structure

00:12:30,330 --> 00:12:34,380
and replicate over there if you want to

00:12:32,580 --> 00:12:36,630
do that that means it can't use the RGB

00:12:34,380 --> 00:12:42,060
instruction slot for that instruction

00:12:36,630 --> 00:12:45,210
and well you use of output modifications

00:12:42,060 --> 00:12:47,130
and then you can write it to the frame

00:12:45,210 --> 00:12:48,210
buffer or is it not directly to the

00:12:47,130 --> 00:12:49,770
frame buffer that works but to the

00:12:48,210 --> 00:12:53,750
output which is then put into blending

00:12:49,770 --> 00:12:58,530
or you go back to the temporary register

00:12:53,750 --> 00:13:00,360
okay so some challenges here is I've

00:12:58,530 --> 00:13:01,590
mentioned this quickly before you there

00:13:00,360 --> 00:13:03,840
are many instructions that need to be

00:13:01,590 --> 00:13:06,900
emulated but this is pretty simple and

00:13:03,840 --> 00:13:08,790
to do that works well and there is this

00:13:06,900 --> 00:13:11,010
split which is a challenge in terms of

00:13:08,790 --> 00:13:12,900
instruction scheduling we have some code

00:13:11,010 --> 00:13:14,970
that does it and I think it does it

00:13:12,900 --> 00:13:16,680
actually fairly well except for one

00:13:14,970 --> 00:13:18,840
problem I've seen a lot of shaders that

00:13:16,680 --> 00:13:21,600
do something like compute the reciprocal

00:13:18,840 --> 00:13:23,550
of a scalar that is in the X register

00:13:21,600 --> 00:13:24,900
and write the output again to the X

00:13:23,550 --> 00:13:27,420
register the problem with that is that

00:13:24,900 --> 00:13:28,950
the RGB unit can't do reciprocals so

00:13:27,420 --> 00:13:30,750
what we have to do is we load the X

00:13:28,950 --> 00:13:32,700
component into the into the Alpha and

00:13:30,750 --> 00:13:35,490
then replicate the result to the RGB

00:13:32,700 --> 00:13:38,010
which wastes the RGB vector is locked in

00:13:35,490 --> 00:13:40,080
that instruction and there's a question

00:13:38,010 --> 00:13:42,990
of maybe we can move these components

00:13:40,080 --> 00:13:45,030
around in a clever way but that's a more

00:13:42,990 --> 00:13:47,880
difficult subject I guess I'd be we're

00:13:45,030 --> 00:13:49,350
not doing again limited manpower on the

00:13:47,880 --> 00:13:51,540
older chips you have to do some Swizzle

00:13:49,350 --> 00:13:54,030
emulation that that has been pretty

00:13:51,540 --> 00:13:55,590
stable for two years now so and of

00:13:54,030 --> 00:13:57,650
course there are some sand little bonus

00:13:55,590 --> 00:14:00,570
features that would be like to use

00:13:57,650 --> 00:14:03,480
optimally like what I didn't explain is

00:14:00,570 --> 00:14:05,670
this presa thing it allows you to do

00:14:03,480 --> 00:14:08,780
something like subtract source 0 from

00:14:05,670 --> 00:14:11,310
source one before doing the actual

00:14:08,780 --> 00:14:13,260
instruction this allows you to do

00:14:11,310 --> 00:14:14,970
something like linear interpolation in a

00:14:13,260 --> 00:14:17,010
single instruction instead of using a

00:14:14,970 --> 00:14:21,390
multiplication in the multiplication

00:14:17,010 --> 00:14:22,750
addition would be nice to have there are

00:14:21,390 --> 00:14:26,230
some limitations there because you

00:14:22,750 --> 00:14:28,270
this flexible with whistling when you

00:14:26,230 --> 00:14:33,930
want to do that which is the main reason

00:14:28,270 --> 00:14:33,930
why it lazy so far and supporting that

00:14:34,770 --> 00:14:40,900
okay there's a picture about flow

00:14:38,590 --> 00:14:43,450
control you have the issue that when

00:14:40,900 --> 00:14:45,550
pixels when all pixels want to jump in a

00:14:43,450 --> 00:14:47,860
branch instructions then is fine because

00:14:45,550 --> 00:14:49,960
it's operated many pixels separately if

00:14:47,860 --> 00:14:51,940
none of them want to jump it's also fine

00:14:49,960 --> 00:14:54,270
if someone to jump in some don't then

00:14:51,940 --> 00:14:56,530
you actually have to twiddle with some

00:14:54,270 --> 00:14:58,180
deactivating some pixels temporarily and

00:14:56,530 --> 00:15:00,610
use both branches and anything else

00:14:58,180 --> 00:15:02,590
under but I'm not going to elaborate on

00:15:00,610 --> 00:15:05,110
that too much the nice thing about your

00:15:02,590 --> 00:15:09,130
control support in the r500 is is one

00:15:05,110 --> 00:15:11,320
very flexible and it's very easy to map

00:15:09,130 --> 00:15:12,430
jit glsl to the hardware actually there

00:15:11,320 --> 00:15:16,300
are some other challenges which I'm

00:15:12,430 --> 00:15:18,190
going to mention later there are lots of

00:15:16,300 --> 00:15:23,290
possibilities for optimization there but

00:15:18,190 --> 00:15:27,430
we can think about that later okay so

00:15:23,290 --> 00:15:30,070
far for the hardware details and now I

00:15:27,430 --> 00:15:31,810
want to give you an overview of well

00:15:30,070 --> 00:15:37,420
high-level overview of how the compiler

00:15:31,810 --> 00:15:39,640
works right now and how we got there ok

00:15:37,420 --> 00:15:41,170
so in the beginning we were young and

00:15:39,640 --> 00:15:43,030
needed a driver and we didn't know too

00:15:41,170 --> 00:15:45,010
much we have no documentation and so

00:15:43,030 --> 00:15:47,830
what we did was just loop over all the

00:15:45,010 --> 00:15:49,450
instructions and try to convert them

00:15:47,830 --> 00:15:52,240
into machine code as well as we could

00:15:49,450 --> 00:15:54,970
then as we learn more about how the

00:15:52,240 --> 00:15:56,620
hardware really works and so on we

00:15:54,970 --> 00:15:58,600
wanted to use new features we wanted to

00:15:56,620 --> 00:16:00,040
fix bugs that cause in complexity

00:15:58,600 --> 00:16:02,080
because you have interactions between

00:16:00,040 --> 00:16:03,730
emulating instruction and doing this

00:16:02,080 --> 00:16:06,130
whistling emulation on the older chips

00:16:03,730 --> 00:16:08,500
for example there was also the issue

00:16:06,130 --> 00:16:10,780
that initially we did the art 300 and

00:16:08,500 --> 00:16:12,550
500 fragment program entirely separately

00:16:10,780 --> 00:16:14,560
which was not a good way to live with

00:16:12,550 --> 00:16:16,600
that so we wanted to do pro chair and

00:16:14,560 --> 00:16:18,550
there and so what ended up happening

00:16:16,600 --> 00:16:23,710
from a very high level point of view is

00:16:18,550 --> 00:16:26,170
that often there was a decision to take

00:16:23,710 --> 00:16:28,750
a single pass in this in this compiler

00:16:26,170 --> 00:16:31,340
and split it into simpler multiple

00:16:28,750 --> 00:16:33,350
passes that communicate using some

00:16:31,340 --> 00:16:35,570
representation will change over the time

00:16:33,350 --> 00:16:38,210
and I guess that's that's actually the

00:16:35,570 --> 00:16:40,220
main philosophical change that took me

00:16:38,210 --> 00:16:43,450
personally quite some time to embrace is

00:16:40,220 --> 00:16:46,460
that to really embrace multiple passes

00:16:43,450 --> 00:16:49,250
also since last year when the growling

00:16:46,460 --> 00:16:51,710
driver started to pick up to eat there

00:16:49,250 --> 00:16:53,570
was a decision to share the compiler

00:16:51,710 --> 00:16:55,490
between the two to try to make it as

00:16:53,570 --> 00:16:59,510
independent as possible from from the

00:16:55,490 --> 00:17:01,640
other things and just gently so I talked

00:16:59,510 --> 00:17:03,890
about multipass and if there is an

00:17:01,640 --> 00:17:05,480
explosion going on and this is the one

00:17:03,890 --> 00:17:06,860
you had initially this is roughly what

00:17:05,480 --> 00:17:09,230
we had at the end of two thousand eight

00:17:06,860 --> 00:17:12,290
and this is more or less what it looks

00:17:09,230 --> 00:17:14,300
like master right now so you see that

00:17:12,290 --> 00:17:16,490
first a single pass is going to split up

00:17:14,300 --> 00:17:18,110
and first we do the EP emulate

00:17:16,490 --> 00:17:19,640
instructions and just replacement by

00:17:18,110 --> 00:17:22,700
native instructions in the assembly

00:17:19,640 --> 00:17:24,950
format then there was a strange renamed

00:17:22,700 --> 00:17:27,770
not quite static single assignment in

00:17:24,950 --> 00:17:29,630
that code elimination pass which also

00:17:27,770 --> 00:17:31,760
took care of gluings whistle emulation

00:17:29,630 --> 00:17:33,800
because there's a tricky thing about

00:17:31,760 --> 00:17:36,350
Swizzle emulation the way Mesa generates

00:17:33,800 --> 00:17:38,270
assembly is that you often have swizzles

00:17:36,350 --> 00:17:40,340
if you use only two components in an

00:17:38,270 --> 00:17:43,700
instruction you tend to gets whistles

00:17:40,340 --> 00:17:45,950
like X yyy that's not a native s'mizza

00:17:43,700 --> 00:17:47,600
lon our 300 but actually you don't need

00:17:45,950 --> 00:17:49,880
to use the third and fourth component

00:17:47,600 --> 00:17:51,950
you can just ignore that and so what

00:17:49,880 --> 00:17:55,490
this pass for the first time did was to

00:17:51,950 --> 00:17:57,230
analyze which components of the input

00:17:55,490 --> 00:17:59,630
operands are actually used and then mark

00:17:57,230 --> 00:18:02,240
the unused ones and take care of that

00:17:59,630 --> 00:18:06,680
innocent election and then there was a

00:18:02,240 --> 00:18:09,230
separate scheduling in the fragment

00:18:06,680 --> 00:18:12,500
program scheduling these pairs of RGB

00:18:09,230 --> 00:18:14,390
and a as well as we could and then amid

00:18:12,500 --> 00:18:15,920
and at that stage actually only the

00:18:14,390 --> 00:18:18,140
final image was different between our

00:18:15,920 --> 00:18:20,330
300 or 500 all the rest is pretty much

00:18:18,140 --> 00:18:22,550
hair except for some instruction

00:18:20,330 --> 00:18:23,940
emulation details and then again its

00:18:22,550 --> 00:18:27,899
glitz to make things

00:18:23,940 --> 00:18:33,570
slightly easier and there is even a new

00:18:27,899 --> 00:18:35,669
password up here we use pretty much this

00:18:33,570 --> 00:18:38,940
assembly format as intermediate

00:18:35,669 --> 00:18:40,409
representation down here there is a new

00:18:38,940 --> 00:18:43,019
instruction format which is modeled

00:18:40,409 --> 00:18:45,509
after what they have achieved us this is

00:18:43,019 --> 00:18:49,470
lit really is represented informative

00:18:45,509 --> 00:18:51,059
obviously structure there well what are

00:18:49,470 --> 00:18:53,340
the trade-offs of single pass vs

00:18:51,059 --> 00:18:55,470
multipass in principle most parts can be

00:18:53,340 --> 00:18:56,820
slower because there might be some

00:18:55,470 --> 00:19:00,389
information that you have to recompute

00:18:56,820 --> 00:19:02,549
several times however the advantages are

00:19:00,389 --> 00:19:04,590
really overwhelming because it's easier

00:19:02,549 --> 00:19:06,120
to wrap your head around one pastor does

00:19:04,590 --> 00:19:08,340
only a single thing instead of trying to

00:19:06,120 --> 00:19:10,289
do anything that once so it's hopefully

00:19:08,340 --> 00:19:13,710
lot more understandable and maintainable

00:19:10,289 --> 00:19:15,840
now it's easier to share code because if

00:19:13,710 --> 00:19:17,730
you have a single pass that does does

00:19:15,840 --> 00:19:21,029
something then maybe it applies to some

00:19:17,730 --> 00:19:23,519
other hardware as well and the

00:19:21,029 --> 00:19:26,039
compilation time doesn't matter that

00:19:23,519 --> 00:19:27,980
much because we only compile shaders at

00:19:26,039 --> 00:19:30,269
the start of an application usually and

00:19:27,980 --> 00:19:31,320
of course the slows down the start of

00:19:30,269 --> 00:19:35,070
the applications and we shouldn't

00:19:31,320 --> 00:19:37,080
completely ignore it but it may be worth

00:19:35,070 --> 00:19:39,389
it because we just we don't have enough

00:19:37,080 --> 00:19:41,490
people working on this thing and having

00:19:39,389 --> 00:19:43,940
it easily maintainable is just much more

00:19:41,490 --> 00:19:43,940
important

00:19:45,000 --> 00:19:50,710
okay here's an example of how we can

00:19:47,320 --> 00:19:52,179
share passes right now between fragment

00:19:50,710 --> 00:19:54,340
program computation and vertex program

00:19:52,179 --> 00:19:56,710
compilation of course the final image

00:19:54,340 --> 00:19:59,470
can't be shared but dead code

00:19:56,710 --> 00:20:01,210
elimination is shared this is a past

00:19:59,470 --> 00:20:02,920
that only is important for vertex

00:20:01,210 --> 00:20:04,450
program so time to share this is

00:20:02,920 --> 00:20:06,070
something that we should share register

00:20:04,450 --> 00:20:08,200
allocation but you don't but we don't do

00:20:06,070 --> 00:20:10,360
it right now which is a bit sad we'll

00:20:08,200 --> 00:20:12,400
get there and instruction emulation

00:20:10,360 --> 00:20:14,620
everything that can be shared there is

00:20:12,400 --> 00:20:17,020
shared I mean neither is a subset of the

00:20:14,620 --> 00:20:20,440
other so it can't be shared and highly

00:20:17,020 --> 00:20:23,260
but whatever we can tell you care well

00:20:20,440 --> 00:20:25,690
that's very nice from a maintenance for

00:20:23,260 --> 00:20:28,059
now I think that to understand some

00:20:25,690 --> 00:20:30,340
program the best way to go is to try to

00:20:28,059 --> 00:20:31,809
understand the data structures and the

00:20:30,340 --> 00:20:34,630
most important data structure here is

00:20:31,809 --> 00:20:38,559
how do we represent the programs in the

00:20:34,630 --> 00:20:40,360
intermediate steps and that's actually a

00:20:38,559 --> 00:20:41,740
very simple representation it's just a

00:20:40,360 --> 00:20:44,770
doubly linked list of instruction

00:20:41,740 --> 00:20:46,360
structures and then instruction formats

00:20:44,770 --> 00:20:48,250
come in come in two flavors there's the

00:20:46,360 --> 00:20:49,600
assembly style and the one that is

00:20:48,250 --> 00:20:51,669
sitting closer to the fragment program

00:20:49,600 --> 00:20:53,290
hardware as I've already said we

00:20:51,669 --> 00:20:55,120
maintain a list of constants used

00:20:53,290 --> 00:20:59,890
because we need to add constants when we

00:20:55,120 --> 00:21:02,530
will emulate to sine and cosine but

00:20:59,890 --> 00:21:05,020
that's it about this intermediate

00:21:02,530 --> 00:21:06,730
representation I really personally like

00:21:05,020 --> 00:21:08,710
the doubly linked list because it's very

00:21:06,730 --> 00:21:10,030
easy to insert modify remove

00:21:08,710 --> 00:21:13,450
instructions which is something that we

00:21:10,030 --> 00:21:17,710
do a lot it's also it's also easily

00:21:13,450 --> 00:21:20,049
understandable I think I really don't

00:21:17,710 --> 00:21:23,020
like to gsi so for this kind of stuff

00:21:20,049 --> 00:21:25,000
there is one downside which is that to

00:21:23,020 --> 00:21:28,450
really do optimization like people or

00:21:25,000 --> 00:21:30,070
whatever we want to to look at an

00:21:28,450 --> 00:21:32,770
instruction say okay this instruction

00:21:30,070 --> 00:21:35,110
what writes some value now we want to

00:21:32,770 --> 00:21:37,240
know which other instructions use this

00:21:35,110 --> 00:21:38,950
rhythm value and this is a query that

00:21:37,240 --> 00:21:40,799
with this representation in the worst

00:21:38,950 --> 00:21:44,440
case has to look at the entire program

00:21:40,799 --> 00:21:46,600
which is slow unfortunately I did

00:21:44,440 --> 00:21:48,190
experiment a little with trying to do a

00:21:46,600 --> 00:21:50,220
bit more clever data structures here

00:21:48,190 --> 00:21:51,419
which can you know you

00:21:50,220 --> 00:21:54,450
the National expedia which will be very

00:21:51,419 --> 00:21:55,950
nice the problem is that to make sure

00:21:54,450 --> 00:21:59,130
that all the invariants that you want to

00:21:55,950 --> 00:22:03,230
have that they are maintained is tricky

00:21:59,130 --> 00:22:05,610
and and can easily lead to bugs because

00:22:03,230 --> 00:22:07,530
well I mean theory you can do all the

00:22:05,610 --> 00:22:09,210
abstractions you wanted see right but

00:22:07,530 --> 00:22:11,000
but somehow it's not very nice to

00:22:09,210 --> 00:22:14,730
express them this is something where

00:22:11,000 --> 00:22:16,380
where C++ tempts me because there you

00:22:14,730 --> 00:22:26,360
can express some expected extractions

00:22:16,380 --> 00:22:26,360
more easily yeah it modifies in place

00:22:29,330 --> 00:22:36,270
yes yes that's the problem now yeah

00:22:34,950 --> 00:22:38,600
there are several different approaches

00:22:36,270 --> 00:22:42,320
you could try to try to fix it but

00:22:38,600 --> 00:22:50,570
that's what happens right now

00:22:42,320 --> 00:22:52,730
I thought about this the kind of problem

00:22:50,570 --> 00:22:54,320
is that you often have instructions they

00:22:52,730 --> 00:22:57,019
don't I mean your registers are vectors

00:22:54,320 --> 00:22:58,159
right and they don't actually there are

00:22:57,019 --> 00:22:59,960
many instructions that don't actually

00:22:58,159 --> 00:23:02,809
replace the whole vector but they kind

00:22:59,960 --> 00:23:04,490
of mix the original value with with some

00:23:02,809 --> 00:23:08,419
new component that gets overwritten and

00:23:04,490 --> 00:23:09,679
I didn't really find a good way to deal

00:23:08,419 --> 00:23:13,120
with it I don't know if there are some

00:23:09,679 --> 00:23:13,120
literature on this kind of stuff but

00:23:21,549 --> 00:23:27,610
I I did look at lvm it didn't seem like

00:23:25,210 --> 00:23:29,259
it was really I mean it was rather

00:23:27,610 --> 00:23:30,820
geared towards what you have been a

00:23:29,259 --> 00:23:34,269
usual CPU so it seemed rather

00:23:30,820 --> 00:23:36,070
problematic although for some of the

00:23:34,269 --> 00:23:42,210
newer GPUs it might be worth looking at

00:23:36,070 --> 00:23:42,210
it again I'm not sure if there is a

00:23:45,929 --> 00:23:51,429
talking about this is able to the

00:23:48,039 --> 00:23:55,139
patient stuff like that you don't go

00:23:51,429 --> 00:23:55,139
against the fact we can use

00:24:00,850 --> 00:24:02,910
Oh

00:24:03,929 --> 00:24:18,720
well I guess in SS e that these vector

00:24:07,499 --> 00:24:22,730
stable conditions but on the other hand

00:24:18,720 --> 00:24:22,730
you will have some niceties like

00:24:30,520 --> 00:24:38,930
their implicit so yeah I don't know

00:24:37,460 --> 00:24:40,790
maybe maybe one can talk about this

00:24:38,930 --> 00:24:42,230
later about how you do with this kind of

00:24:40,790 --> 00:24:47,690
thing in an essay that would be

00:24:42,230 --> 00:24:49,340
interesting okay another little detail

00:24:47,690 --> 00:24:50,900
is that at some point we want to do

00:24:49,340 --> 00:24:53,920
dynamic allocation so that you don't

00:24:50,900 --> 00:24:55,880
need to think about fixed size Ares and

00:24:53,920 --> 00:24:57,470
maintaining that as a bit painful so

00:24:55,880 --> 00:24:58,970
what we do is we have a memory pool

00:24:57,470 --> 00:25:01,100
structure which only has an allocation

00:24:58,970 --> 00:25:02,330
function delicate so that we need at the

00:25:01,100 --> 00:25:08,710
end of compilation everything is thrown

00:25:02,330 --> 00:25:08,710
away like okay

00:25:13,590 --> 00:25:18,539
yeah this is all already kind of my

00:25:16,710 --> 00:25:23,400
overview of the of the compiler and now

00:25:18,539 --> 00:25:25,470
I want to talk a little bit about what

00:25:23,400 --> 00:25:27,210
we need to do for glsl and what are the

00:25:25,470 --> 00:25:32,789
kind of the remaining things to get

00:25:27,210 --> 00:25:35,039
really get really good support here what

00:25:32,789 --> 00:25:37,770
is worth mentioning at this point

00:25:35,039 --> 00:25:40,440
explicitly is that actually most glsl

00:25:37,770 --> 00:25:42,150
shaders today work just fine there are

00:25:40,440 --> 00:25:45,029
some features which are missing which is

00:25:42,150 --> 00:25:48,480
why it's a bit dodgy to claim to support

00:25:45,029 --> 00:25:51,710
glsl flow control supporting vertex

00:25:48,480 --> 00:25:54,630
programs in the area supporting loose

00:25:51,710 --> 00:25:56,970
isn't there yet and there are some

00:25:54,630 --> 00:25:58,860
additional instructions I think that we

00:25:56,970 --> 00:26:00,210
would still need to emulate but I mean

00:25:58,860 --> 00:26:03,570
that's a small thing the other two

00:26:00,210 --> 00:26:05,909
things are a bit more a bit bigger and a

00:26:03,570 --> 00:26:11,700
person would be nice to have remember to

00:26:05,909 --> 00:26:14,730
my pigeons okay how could we go about

00:26:11,700 --> 00:26:16,860
implementing nuke support mapping the

00:26:14,730 --> 00:26:18,559
instructions on to the until the harder

00:26:16,860 --> 00:26:21,990
machine code is actually pretty simple

00:26:18,559 --> 00:26:23,669
the the real problem is that again it

00:26:21,990 --> 00:26:26,340
comes down to this to this data flow

00:26:23,669 --> 00:26:29,820
stuff because if you right now compile a

00:26:26,340 --> 00:26:31,710
a program which has loops then the stuff

00:26:29,820 --> 00:26:33,600
like dead code elimination just doesn't

00:26:31,710 --> 00:26:35,159
understand that if you write a register

00:26:33,600 --> 00:26:36,600
here at the end of the loop and then

00:26:35,159 --> 00:26:38,159
read from it again at the top of the

00:26:36,600 --> 00:26:40,470
booth that there is a dependency which

00:26:38,159 --> 00:26:42,470
goes backwards there is code to support

00:26:40,470 --> 00:26:45,870
branches so that works fine I think

00:26:42,470 --> 00:26:48,179
salutes aren't supported yet and this is

00:26:45,870 --> 00:26:49,500
the harder part because some of the code

00:26:48,179 --> 00:26:53,899
is rather subtle and you have to be

00:26:49,500 --> 00:26:59,120
careful about got to modify where but I

00:26:53,899 --> 00:26:59,120
hope to get around to that soon

00:27:00,830 --> 00:27:06,870
optimizations are also an interesting

00:27:02,970 --> 00:27:08,280
problem so here is this glsl program

00:27:06,870 --> 00:27:10,740
that are shown at the very beginning and

00:27:08,280 --> 00:27:12,720
here is the assembly that the Mesa glsl

00:27:10,740 --> 00:27:15,620
compiler produces which has 32

00:27:12,720 --> 00:27:17,340
instructions if you do some very clever

00:27:15,620 --> 00:27:20,670
transformations you can get it down to

00:27:17,340 --> 00:27:22,200
eight a bit more realistic goal which

00:27:20,670 --> 00:27:24,180
could still be manageable I think would

00:27:22,200 --> 00:27:27,300
be to go at least down to 16 or

00:27:24,180 --> 00:27:29,490
something here is an interesting kind of

00:27:27,300 --> 00:27:31,430
philosophical problem about how how you

00:27:29,490 --> 00:27:37,320
do structure things on a high level

00:27:31,430 --> 00:27:40,800
because yeah it would be nice to if the

00:27:37,320 --> 00:27:43,170
the hardware independent glsl compiler

00:27:40,800 --> 00:27:44,610
already did some optimizations there are

00:27:43,170 --> 00:27:48,360
there are some optimizations that it

00:27:44,610 --> 00:27:51,960
could just do like that the problem is

00:27:48,360 --> 00:27:53,970
that actually well you don't know about

00:27:51,960 --> 00:27:55,230
the final hardware that this compiler

00:27:53,970 --> 00:27:57,720
doesn't know about the final hardware

00:27:55,230 --> 00:28:03,090
especially in gallium which is a bit not

00:27:57,720 --> 00:28:04,770
nice so we can't well the thing is that

00:28:03,090 --> 00:28:08,400
for example as far as I understand be

00:28:04,770 --> 00:28:10,680
the Intel hardware they are is probably

00:28:08,400 --> 00:28:12,660
actually quite happy about about this

00:28:10,680 --> 00:28:15,900
kind of stuff but we are less happy

00:28:12,660 --> 00:28:18,390
because scalars are placed pretty much

00:28:15,900 --> 00:28:22,950
randomly ignoring this rgba versus alpha

00:28:18,390 --> 00:28:24,930
split so so what do you do I mean do you

00:28:22,950 --> 00:28:26,580
go into the glsl compiler do some

00:28:24,930 --> 00:28:28,200
optimizations which would be nice to us

00:28:26,580 --> 00:28:30,180
but then piss off maybe some other

00:28:28,200 --> 00:28:34,680
hardware I don't know about move over

00:28:30,180 --> 00:28:36,360
there huh buildings like or Intel so

00:28:34,680 --> 00:28:38,070
right now we try to do everything in the

00:28:36,360 --> 00:28:40,140
Indy driver which doesn't have the

00:28:38,070 --> 00:28:42,060
original gle so it just has the assembly

00:28:40,140 --> 00:28:46,700
and tries to understand as well as it

00:28:42,060 --> 00:28:46,700
can one question yeah

00:28:50,030 --> 00:28:58,890
for example when it comes to actually

00:28:56,070 --> 00:29:01,100
having that individual home instead of

00:28:58,890 --> 00:29:03,929
having to analyze it the second time I

00:29:01,100 --> 00:29:05,700
guess it would be nice but it mean we

00:29:03,929 --> 00:29:09,410
already do this unused component

00:29:05,700 --> 00:29:09,410
analysis which is not very complicated

00:29:11,750 --> 00:29:18,419
yeah provide you that I mean everybody

00:29:16,190 --> 00:29:20,220
will need that information that's that's

00:29:18,419 --> 00:29:22,169
true yeah I guess they're there is a

00:29:20,220 --> 00:29:24,330
there would be value in pushing this

00:29:22,169 --> 00:29:28,380
unused marker into what Mesa does and

00:29:24,330 --> 00:29:30,780
also about TGS I does yeah is anyone

00:29:28,380 --> 00:29:33,510
looking at that hmm is anyone working on

00:29:30,780 --> 00:29:35,460
something like that I don't think so I

00:29:33,510 --> 00:29:37,260
don't think so I don't think anybody

00:29:35,460 --> 00:29:50,100
does anybody really have this this

00:29:37,260 --> 00:29:52,080
really high level view but still they're

00:29:50,100 --> 00:29:55,520
not even in translation to there is a

00:29:52,080 --> 00:29:55,520
lot of extra stuff

00:30:01,979 --> 00:30:11,159
this intermediate classes but if we

00:30:06,159 --> 00:30:11,159
could have a viable

00:30:31,670 --> 00:30:38,120
yeah that's a ivory lifting some of this

00:30:35,730 --> 00:30:40,320
optimization stuff into Mesa and then

00:30:38,120 --> 00:30:42,390
maybe I'll menteng the teachers I

00:30:40,320 --> 00:30:46,530
representation will be very very useful

00:30:42,390 --> 00:30:49,410
thing here are just some examples of the

00:30:46,530 --> 00:30:52,560
kind of thing you can do something that

00:30:49,410 --> 00:30:55,710
is a bit magic maybe but actually works

00:30:52,560 --> 00:30:57,960
that are 500 is here you have something

00:30:55,710 --> 00:31:00,600
that first multiplies two scalars and

00:30:57,960 --> 00:31:03,030
then subtract them that's this kind of

00:31:00,600 --> 00:31:05,700
if you go back to the glsl that's the

00:31:03,030 --> 00:31:07,980
CRS function here which does a kind of

00:31:05,700 --> 00:31:12,920
well it's a modified dot product really

00:31:07,980 --> 00:31:16,020
and maybe we could can recognize that

00:31:12,920 --> 00:31:19,710
and do some magic which actually works

00:31:16,020 --> 00:31:23,310
in Hardware on our 502 to save some

00:31:19,710 --> 00:31:26,160
instructions this by the way is a is an

00:31:23,310 --> 00:31:28,440
example of why doing some of these

00:31:26,160 --> 00:31:31,140
optimizations in the device independent

00:31:28,440 --> 00:31:32,880
code is maybe not a good idea because if

00:31:31,140 --> 00:31:35,190
I get code like this on the r300

00:31:32,880 --> 00:31:37,140
fragment program then I'll be pissed off

00:31:35,190 --> 00:31:38,700
because then I have to worry about all

00:31:37,140 --> 00:31:40,590
this whistling here which is not

00:31:38,700 --> 00:31:42,830
supported on RT on it that our 500 can

00:31:40,590 --> 00:31:42,830
do it

00:31:50,540 --> 00:31:59,880
yes that's true that's true the

00:31:58,200 --> 00:32:01,980
connection yeah I think the question is

00:31:59,880 --> 00:32:04,070
the question is do you want to do this

00:32:01,980 --> 00:32:08,010
before the Galleon state tracker

00:32:04,070 --> 00:32:13,860
produces tjs I or and you can still

00:32:08,010 --> 00:32:15,360
share that's Google some I mean there

00:32:13,860 --> 00:32:18,360
are some optimizations that might be

00:32:15,360 --> 00:32:20,220
easier to do before the state tracker

00:32:18,360 --> 00:32:22,260
gets its hand on it because you might

00:32:20,220 --> 00:32:24,180
have still more information about where

00:32:22,260 --> 00:32:26,430
the code comes from from the glsl I

00:32:24,180 --> 00:32:32,190
don't know how feasible with us i mean

00:32:26,430 --> 00:32:37,770
the glsl compiler is soon I'm afraid of

00:32:32,190 --> 00:32:39,180
that special instead of compiler yeah

00:32:37,770 --> 00:32:40,950
then been there is some stuff that you

00:32:39,180 --> 00:32:43,020
can do with constant folding like here

00:32:40,950 --> 00:32:45,420
this is the great report comparison from

00:32:43,020 --> 00:32:47,130
from the glsl which has a zero constant

00:32:45,420 --> 00:32:49,530
there and we can do that more

00:32:47,130 --> 00:32:51,180
efficiently in the in the archive on a

00:32:49,530 --> 00:32:53,280
program program by using some of the

00:32:51,180 --> 00:33:01,470
some of the flow control features that

00:32:53,280 --> 00:33:03,540
it has yeah how do we implement such

00:33:01,470 --> 00:33:05,130
data flow optimizations well one

00:33:03,540 --> 00:33:07,200
approach that wouldn't change this

00:33:05,130 --> 00:33:08,850
intermediate representation would be to

00:33:07,200 --> 00:33:10,560
have helper functions that help you

00:33:08,850 --> 00:33:13,740
figure out where values are used and

00:33:10,560 --> 00:33:15,300
where they come from and then add the

00:33:13,740 --> 00:33:16,980
optimization just as an additional

00:33:15,300 --> 00:33:18,900
compiler pass that just because there's

00:33:16,980 --> 00:33:20,220
one thing that you can know if you have

00:33:18,900 --> 00:33:22,410
some miss compilation you can just

00:33:20,220 --> 00:33:25,190
disable that compiler pass and see if it

00:33:22,410 --> 00:33:27,030
helps which is useful for debugging and

00:33:25,190 --> 00:33:28,500
then hopefully with the help of

00:33:27,030 --> 00:33:32,220
functions in place doing the actual

00:33:28,500 --> 00:33:34,350
optimization it's not too tricky if we

00:33:32,220 --> 00:33:37,110
have an essay based

00:33:34,350 --> 00:33:38,250
some representation then I guess this

00:33:37,110 --> 00:33:39,419
would look different that this is

00:33:38,250 --> 00:33:41,100
something that that would work in the

00:33:39,419 --> 00:33:48,360
current intermediate representation or

00:33:41,100 --> 00:33:51,210
let me use okay and with that I go to

00:33:48,360 --> 00:33:55,289
the last part about Pro tearing our

00:33:51,210 --> 00:33:57,179
satendra and some other stuff as far as

00:33:55,289 --> 00:33:58,860
code-sharing is concerned well we've

00:33:57,179 --> 00:34:00,660
already seen a lot of examples that are

00:33:58,860 --> 00:34:02,789
rather hardware-specific that you just

00:34:00,660 --> 00:34:04,860
cannot share but I think there are still

00:34:02,789 --> 00:34:06,840
many things that could be shared and it

00:34:04,860 --> 00:34:09,419
would be nice if you could share them

00:34:06,840 --> 00:34:11,909
the the real problem which I think also

00:34:09,419 --> 00:34:14,609
already appeared in the discussion is

00:34:11,909 --> 00:34:17,250
that to be able to share code we need to

00:34:14,609 --> 00:34:19,109
share data structures and we have to

00:34:17,250 --> 00:34:22,649
somehow agree on something that works

00:34:19,109 --> 00:34:28,830
well there and it's maybe for some

00:34:22,649 --> 00:34:31,109
future discussions are 600 is

00:34:28,830 --> 00:34:33,450
interesting because it has the same

00:34:31,109 --> 00:34:36,149
processor for for vertex pregnant and

00:34:33,450 --> 00:34:38,790
geometry shaders there already is an

00:34:36,149 --> 00:34:41,450
assembler that I think works fairly well

00:34:38,790 --> 00:34:44,730
it doesn't do any optimizations however

00:34:41,450 --> 00:34:49,260
the processor is quite interesting

00:34:44,730 --> 00:34:51,990
because it has four separates I lose

00:34:49,260 --> 00:34:53,490
that that our photo well for the vector

00:34:51,990 --> 00:34:55,770
instructions but you can actually do

00:34:53,490 --> 00:34:58,430
different instructions on each component

00:34:55,770 --> 00:35:01,740
and then there is an additional fifth

00:34:58,430 --> 00:35:04,320
unit that can also support these in a

00:35:01,740 --> 00:35:08,910
reciprocal sine cosine these more

00:35:04,320 --> 00:35:11,250
esoteric instructions I think that you

00:35:08,910 --> 00:35:13,710
know glsl that use a lot of scalars max

00:35:11,250 --> 00:35:16,830
very well on to this model but there are

00:35:13,710 --> 00:35:18,990
some problematic operant selection

00:35:16,830 --> 00:35:20,369
restrictions that you if you really want

00:35:18,990 --> 00:35:22,830
to use the Hobby to its full potential

00:35:20,369 --> 00:35:24,480
you have again now how do you do the

00:35:22,830 --> 00:35:27,000
instruction scheduling exactly do you

00:35:24,480 --> 00:35:30,390
maybe move some components from the X to

00:35:27,000 --> 00:35:32,160
the Y or somehow of course we can't

00:35:30,390 --> 00:35:34,410
reuse anything that we did for

00:35:32,160 --> 00:35:37,530
300 because the split is just too

00:35:34,410 --> 00:35:43,530
different but again optimization passes

00:35:37,530 --> 00:35:45,329
would be nice to share okay now there is

00:35:43,530 --> 00:35:51,180
one slide on how to get involved in

00:35:45,329 --> 00:35:55,369
shaler compilation stuff it is a bit

00:35:51,180 --> 00:35:58,859
scary i have to admit and here's what

00:35:55,369 --> 00:36:00,630
you need to have before is you do need

00:35:58,859 --> 00:36:02,329
to have some understanding of glsl and

00:36:00,630 --> 00:36:06,569
of these assembly instructions otherwise

00:36:02,329 --> 00:36:09,030
there's no way to really wrap your head

00:36:06,569 --> 00:36:10,980
around this the best way to get this i

00:36:09,030 --> 00:36:13,380
think is to just take on some toyota k

00:36:10,980 --> 00:36:15,059
shins or maybe if you want to have some

00:36:13,380 --> 00:36:16,530
new conference plug-in or whatever that

00:36:15,059 --> 00:36:18,210
you want to work on that would be a nice

00:36:16,530 --> 00:36:20,280
way to learn it you definitely don't

00:36:18,210 --> 00:36:22,109
need to be a 3d expert you just need to

00:36:20,280 --> 00:36:25,680
understand how to do I sell works and

00:36:22,109 --> 00:36:27,180
the SMP and of course as for for all

00:36:25,680 --> 00:36:29,280
open source projects I mean pick

00:36:27,180 --> 00:36:31,049
something small as a first project maybe

00:36:29,280 --> 00:36:33,210
it's something nice would be if you have

00:36:31,049 --> 00:36:35,250
some really used changer from some open

00:36:33,210 --> 00:36:37,309
source game or some or from compass and

00:36:35,250 --> 00:36:39,450
you just look at what does the

00:36:37,309 --> 00:36:41,490
combination result look like right now

00:36:39,450 --> 00:36:45,839
there are some debug flags that you can

00:36:41,490 --> 00:36:47,220
toggle to enable this output then you

00:36:45,839 --> 00:36:48,720
could look at the assembly that it

00:36:47,220 --> 00:36:51,809
generates and maybe you notice something

00:36:48,720 --> 00:36:53,910
that doesn't look look good that could

00:36:51,809 --> 00:36:56,190
be easily optimize them and try to

00:36:53,910 --> 00:36:57,930
optimize that and of course it's I think

00:36:56,190 --> 00:36:59,880
it's a learning by doing thing because

00:36:57,930 --> 00:37:01,650
there's really no book on the subject I

00:36:59,880 --> 00:37:04,410
think I mean there are some books on a

00:37:01,650 --> 00:37:05,700
general compiler design of course but I

00:37:04,410 --> 00:37:08,869
don't think there's anything from of

00:37:05,700 --> 00:37:12,779
shade of compliance and specifically

00:37:08,869 --> 00:37:15,990
okay and one more thing about maybe

00:37:12,779 --> 00:37:19,799
thinking about how do we improve the way

00:37:15,990 --> 00:37:21,480
that we work because if you have better

00:37:19,799 --> 00:37:22,859
tools for your development and of course

00:37:21,480 --> 00:37:25,829
you don't have to worry about the small

00:37:22,859 --> 00:37:27,569
stuff as much one important thing is to

00:37:25,829 --> 00:37:29,339
keep the source document maintainable I

00:37:27,569 --> 00:37:31,079
mean everybody knows this and preaching

00:37:29,339 --> 00:37:32,880
to the choir here probably but i think

00:37:31,079 --> 00:37:35,180
the things that we did in the compiler

00:37:32,880 --> 00:37:37,190
by doing going to multi pass and so

00:37:35,180 --> 00:37:39,170
they helped a lot in that respect there

00:37:37,190 --> 00:37:41,059
is a question of maybe programming at a

00:37:39,170 --> 00:37:43,040
high level I know C++ is a touchy

00:37:41,059 --> 00:37:47,030
subject but sometimes I feel like it

00:37:43,040 --> 00:37:50,059
would be nice to have i I've heard that

00:37:47,030 --> 00:37:52,010
some compilers they use some patent

00:37:50,059 --> 00:37:53,599
based optimization stuff where you just

00:37:52,010 --> 00:37:55,490
you know you have something if you have

00:37:53,599 --> 00:37:58,099
a multiply followed by add then just

00:37:55,490 --> 00:38:00,109
combine it to one instruction and lots

00:37:58,099 --> 00:38:02,930
of patterns like that and maybe instead

00:38:00,109 --> 00:38:05,960
of writing a specific C code for each of

00:38:02,930 --> 00:38:07,160
these replacements maybe we could find

00:38:05,960 --> 00:38:08,900
something higher level that just

00:38:07,160 --> 00:38:10,670
describes these patterns and these

00:38:08,900 --> 00:38:13,490
transformations in some very high level

00:38:10,670 --> 00:38:16,640
language and then use some generation

00:38:13,490 --> 00:38:19,579
that produces code to do that there's

00:38:16,640 --> 00:38:21,470
some theory then when you modify

00:38:19,579 --> 00:38:23,569
something in the compiler it's very easy

00:38:21,470 --> 00:38:26,300
to break stuff especially some shuttles

00:38:23,569 --> 00:38:28,460
whistling combinations and so on so it's

00:38:26,300 --> 00:38:33,230
good to have automated testing so test

00:38:28,460 --> 00:38:35,380
test test right nice Arista kiss that if

00:38:33,230 --> 00:38:37,309
there are no quickly restrictor

00:38:35,380 --> 00:38:39,740
regressions after you changed something

00:38:37,309 --> 00:38:41,960
then probably you're fine I mean it's no

00:38:39,740 --> 00:38:44,240
guarantee of course but I think the test

00:38:41,960 --> 00:38:45,740
two right now covers a lot of things

00:38:44,240 --> 00:38:47,630
that are typical bugs that are

00:38:45,740 --> 00:38:51,140
reintroduced again and again when you

00:38:47,630 --> 00:38:52,849
work on the compile kind of crazy idea

00:38:51,140 --> 00:38:56,809
here to make the thing even more robust

00:38:52,849 --> 00:38:59,180
maybe we could you know generate shaders

00:38:56,809 --> 00:39:00,530
randomly and then just render using them

00:38:59,180 --> 00:39:02,119
and compare it to some software rest

00:39:00,530 --> 00:39:05,359
result but maybe that would be an

00:39:02,119 --> 00:39:07,790
approach that helps us find more

00:39:05,359 --> 00:39:10,250
compilation bugs I haven't tried it too

00:39:07,790 --> 00:39:12,020
maybe something to to hack on and I mean

00:39:10,250 --> 00:39:15,940
if you have some ideas of course it's

00:39:12,020 --> 00:39:18,079
always nice to share these insights and

00:39:15,940 --> 00:39:20,299
yeah I think there was fast me when I

00:39:18,079 --> 00:39:22,809
thought I would be and I'm down so thank

00:39:20,299 --> 00:39:22,809
you for attention

00:39:27,840 --> 00:39:33,390
so this means that there is no time for

00:39:30,250 --> 00:39:33,390

YouTube URL: https://www.youtube.com/watch?v=a_JsODkbeps


