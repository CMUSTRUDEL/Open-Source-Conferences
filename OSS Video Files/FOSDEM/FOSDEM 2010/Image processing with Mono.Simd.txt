Title: Image processing with Mono.Simd
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Stephane Delcroix

This talk will focus on putting Mono.Simd -- the layer for enabling SIMD processing in mono -- to work in the field of image processing. All code, no slides. 

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:01,100 --> 00:00:10,320
okay so yeah step and we talked about

00:00:07,259 --> 00:00:12,120
image manipulation using Cindy music

00:00:10,320 --> 00:00:14,460
mother Cindy I'm doing this laptop

00:00:12,120 --> 00:00:18,380
because the subject is very interesting

00:00:14,460 --> 00:00:23,039
because processing images using Cindy is

00:00:18,380 --> 00:00:25,199
quite obvious but Cindy was modest

00:00:23,039 --> 00:00:28,890
Timothy was done something like in 2007

00:00:25,199 --> 00:00:31,859
and I figured out that a few months ago

00:00:28,890 --> 00:00:34,140
there was no application at all or no

00:00:31,859 --> 00:00:39,570
big application at all leveraging on it

00:00:34,140 --> 00:00:43,260
I issue by the deviant package or asking

00:00:39,570 --> 00:00:45,090
me what I thought is using my

00:00:43,260 --> 00:00:48,930
opportunity that that's the only

00:00:45,090 --> 00:00:51,230
application I know of and baby I wasn't

00:00:48,930 --> 00:00:54,420
checking the right version of new motor

00:00:51,230 --> 00:01:01,760
inside F spot and nobody noticed you

00:00:54,420 --> 00:01:01,760
should oh yeah or is it yeah

00:01:08,190 --> 00:01:16,080
so no one noticed that in fact mother

00:01:11,409 --> 00:01:22,000
Cindy was great but was not used at all

00:01:16,080 --> 00:01:25,000
so sorry this talk is about using mono

00:01:22,000 --> 00:01:27,340
simdi in your application for example

00:01:25,000 --> 00:01:30,310
for doing image manipulation but you can

00:01:27,340 --> 00:01:34,960
do a lot more than this so Melissa midi

00:01:30,310 --> 00:01:38,080
was developed in 2000's 7 lighting

00:01:34,960 --> 00:01:42,160
because it's not to correct me and it

00:01:38,080 --> 00:01:46,240
was done by rodrigo para massey can be

00:01:42,160 --> 00:01:52,330
it was 2007 yeah i think so it was for

00:01:46,240 --> 00:01:57,340
PDC 107 bigger lungs yeah so basically

00:01:52,330 --> 00:02:00,580
it's a set of latest and method of those

00:01:57,340 --> 00:02:02,850
places that are or that could be if the

00:02:00,580 --> 00:02:07,690
jit for the runtime permitted

00:02:02,850 --> 00:02:11,709
accelerated using using the SSC engine

00:02:07,690 --> 00:02:14,730
of your aunt El platform so basically

00:02:11,709 --> 00:02:19,780
for the one who doesn't know about it

00:02:14,730 --> 00:02:22,930
sse allows you to process unwritten 28

00:02:19,780 --> 00:02:25,930
bits of information at a time instead of

00:02:22,930 --> 00:02:28,660
just working on the float and then to

00:02:25,930 --> 00:02:31,630
bite or whatever you want is it

00:02:28,660 --> 00:02:36,010
available yeah as the technology is

00:02:31,630 --> 00:02:37,450
quite old it's probably available right

00:02:36,010 --> 00:02:43,810
now on you're on the machine you're

00:02:37,450 --> 00:02:48,430
using if you're using model it was

00:02:43,810 --> 00:02:50,590
packaged with mono 222 i'd say if you

00:02:48,430 --> 00:02:53,560
can you'd better use to that for because

00:02:50,590 --> 00:02:58,150
there was there's some issue in 22 with

00:02:53,560 --> 00:03:01,660
the simdi and it works it will see that

00:02:58,150 --> 00:03:07,870
in a second i will show you how much we

00:03:01,660 --> 00:03:14,680
can we can enhance or application and/or

00:03:07,870 --> 00:03:17,260
image manipulation using a Syndic so we

00:03:14,680 --> 00:03:20,019
take a sip the simplest case possible

00:03:17,260 --> 00:03:21,450
will compose an image from two images

00:03:20,019 --> 00:03:24,780
and basically

00:03:21,450 --> 00:03:30,170
we just take the two pixel and add them

00:03:24,780 --> 00:03:35,069
oh we won't ship them at all because

00:03:30,170 --> 00:03:37,290
just I I to simplify the sample because

00:03:35,069 --> 00:03:40,140
otherwise it would imply a lot of

00:03:37,290 --> 00:03:43,920
packing and unpacking so we will just

00:03:40,140 --> 00:03:49,230
add the different component of the pixel

00:03:43,920 --> 00:03:50,580
one by one and it was if it overflow we

00:03:49,230 --> 00:03:53,430
don't care we don't care about the

00:03:50,580 --> 00:03:58,340
result it's just about showing something

00:03:53,430 --> 00:03:58,340
that works so if

00:04:00,180 --> 00:04:10,450
that's the code for it we everybody can

00:04:05,079 --> 00:04:14,920
see it so basically we are loading we're

00:04:10,450 --> 00:04:18,419
loading 22 pics buff we creating a

00:04:14,920 --> 00:04:22,330
destination and then we are mixing both

00:04:18,419 --> 00:04:28,680
sauce into a destination and saving it

00:04:22,330 --> 00:04:31,840
to a jpeg so the non CD version of that

00:04:28,680 --> 00:04:34,660
is the key if I make this the font a bit

00:04:31,840 --> 00:04:45,760
smaller so we can see a bit more at the

00:04:34,660 --> 00:04:47,650
back like this okay yeah the bottom is

00:04:45,760 --> 00:04:51,669
not important what's important is the

00:04:47,650 --> 00:04:55,449
loop that that's the version without any

00:04:51,669 --> 00:04:57,430
simdi so basically you pay you you you

00:04:55,449 --> 00:05:00,099
take all the components of each of

00:04:57,430 --> 00:05:02,440
pixels and you add them and you stole

00:05:00,099 --> 00:05:05,680
into the to your destination you have to

00:05:02,440 --> 00:05:09,400
do that for every line from and for

00:05:05,680 --> 00:05:14,860
every pixel of every line all the rest

00:05:09,400 --> 00:05:17,020
just boilerplate to just boilerplate to

00:05:14,860 --> 00:05:22,240
to make the loop works so that's the

00:05:17,020 --> 00:05:25,659
version using managed see shop as you

00:05:22,240 --> 00:05:32,229
know it and leveraging model as you know

00:05:25,659 --> 00:05:35,080
it that's do you might think that doing

00:05:32,229 --> 00:05:37,180
that just this way in c-sharp on mono

00:05:35,080 --> 00:05:41,130
would be 10 times rather than doing the

00:05:37,180 --> 00:05:44,940
same than see it's not true it's just

00:05:41,130 --> 00:05:48,729
something like 10 or 15 person less

00:05:44,940 --> 00:05:52,240
effective than doing to eat see so I'm

00:05:48,729 --> 00:05:54,340
not even sure it's it's if you don't

00:05:52,240 --> 00:05:56,620
want to use simply but you want to do it

00:05:54,340 --> 00:05:59,650
I met for a thing it's not even worth it

00:05:56,620 --> 00:06:05,070
to do it it see for the 10 of 15 person

00:05:59,650 --> 00:06:11,729
again so we will compile that that code

00:06:05,070 --> 00:06:18,479
GMC s simple cs8 leverage on

00:06:11,729 --> 00:06:21,749
gee DK pigs buff so we don't have to

00:06:18,479 --> 00:06:25,439
create our own memory presentation of

00:06:21,749 --> 00:06:28,729
the image if you want to compile

00:06:25,439 --> 00:06:32,819
something with mother simdi you just

00:06:28,729 --> 00:06:35,219
reference it from the command line and

00:06:32,819 --> 00:06:37,499
we using in some unsafe context we'll

00:06:35,219 --> 00:06:46,669
come back to that later and it should

00:06:37,499 --> 00:06:52,580
compile yeah execute it if it is it took

00:06:46,669 --> 00:06:58,050
it right one it's really fast but I

00:06:52,580 --> 00:07:03,330
tellez it on the battery so yeah took

00:06:58,050 --> 00:07:07,830
like one and the original image is that

00:07:03,330 --> 00:07:11,580
one that one and the output was that one

00:07:07,830 --> 00:07:14,639
so that's one of the origin does the

00:07:11,580 --> 00:07:18,149
result it does the other origin so the

00:07:14,639 --> 00:07:21,659
result looks like this it's it doesn't

00:07:18,149 --> 00:07:23,249
do anything important it's not a known

00:07:21,659 --> 00:07:27,949
transformation or whatever it just show

00:07:23,249 --> 00:07:34,759
that we can add pixel and go ahead so

00:07:27,949 --> 00:07:34,759
what will it take to move that code to

00:07:36,169 --> 00:07:52,550
tamura code 22 simdi take that sample

00:07:45,569 --> 00:07:56,330
and up there is no version of the same

00:07:52,550 --> 00:08:03,529
the same method I developed using Cindy

00:07:56,330 --> 00:08:08,009
here it is yeah so what changed

00:08:03,529 --> 00:08:11,639
basically still boilerplate like change

00:08:08,009 --> 00:08:15,990
instead of doing a G+ plus a I'm doing

00:08:11,639 --> 00:08:19,680
it I'm reading I'm iterating over for

00:08:15,990 --> 00:08:23,159
pixel at time each pixel is for

00:08:19,680 --> 00:08:25,019
component it's for component because I I

00:08:23,159 --> 00:08:25,320
checked on the very first line of the

00:08:25,019 --> 00:08:27,840
poor

00:08:25,320 --> 00:08:29,880
them that I had an alpha channel on

00:08:27,840 --> 00:08:31,830
everything so it's easier for the for

00:08:29,880 --> 00:08:35,610
the sake of this tool to have every

00:08:31,830 --> 00:08:38,190
images with with an alpha channel so

00:08:35,610 --> 00:08:42,860
each pixel is for component for each

00:08:38,190 --> 00:08:46,650
component is a bite aight aight bit and

00:08:42,860 --> 00:08:49,530
so if i read four of them at a time I

00:08:46,650 --> 00:08:54,570
got my register for my religious offer

00:08:49,530 --> 00:08:57,570
of 128 bits so I'm reading for what time

00:08:54,570 --> 00:09:01,350
although I read them instead of doing

00:08:57,570 --> 00:09:05,640
instead of storing my pixel component

00:09:01,350 --> 00:09:09,150
I'm loading that in a vector 16b so

00:09:05,640 --> 00:09:16,190
that's that's one of the type in mono

00:09:09,150 --> 00:09:22,950
simdi on Cindy got types for vector 16

00:09:16,190 --> 00:09:26,130
be signed by it so for integer for short

00:09:22,950 --> 00:09:29,340
float for double for integral and for

00:09:26,130 --> 00:09:34,950
long basically and the lines of the type

00:09:29,340 --> 00:09:36,960
define the number of the number of a man

00:09:34,950 --> 00:09:41,010
you can pack in a vector 0 basically a

00:09:36,960 --> 00:09:46,760
bite is a bit so you can pack a 16 of

00:09:41,010 --> 00:09:49,760
faith in a vector of Elua 1020 a bit

00:09:46,760 --> 00:09:58,850
that's pretty common in image processing

00:09:49,760 --> 00:10:02,520
leaving 8 bits per pixel component we

00:09:58,850 --> 00:10:04,500
could pour that two 16-bit path per

00:10:02,520 --> 00:10:08,390
pixel component and we would just at the

00:10:04,500 --> 00:10:17,940
time use a vector 8 unsigned short

00:10:08,390 --> 00:10:21,770
instead of 16 byte so here we are those

00:10:17,940 --> 00:10:24,840
are strict as we are in a non-safe

00:10:21,770 --> 00:10:27,270
context we'll come back to that later we

00:10:24,840 --> 00:10:31,770
can just cast it and use pointer like

00:10:27,270 --> 00:10:33,980
like you did when you on your when you

00:10:31,770 --> 00:10:37,470
were young and doing see you can just

00:10:33,980 --> 00:10:41,010
cast your bite

00:10:37,470 --> 00:10:44,730
in your bite re because my pixel is the

00:10:41,010 --> 00:10:48,660
battery a bite pointer to a vector and

00:10:44,730 --> 00:10:52,430
get the content of it so those one that

00:10:48,660 --> 00:10:56,310
does the trick I use to load to load

00:10:52,430 --> 00:10:59,940
pixel from from my pixel array and store

00:10:56,310 --> 00:11:06,510
them as vector and I can just add them

00:10:59,940 --> 00:11:12,230
and at runtime as I'm running them on a

00:11:06,510 --> 00:11:19,700
recent model as Cindy seen error as my

00:11:12,230 --> 00:11:24,600
laptop as an SSC capability and that

00:11:19,700 --> 00:11:28,350
operate operator + on vectors is

00:11:24,600 --> 00:11:35,820
accelerated on my machine that line is

00:11:28,350 --> 00:11:38,190
automatically at runtime not that that

00:11:35,820 --> 00:11:41,490
addition is not down on the stroke by

00:11:38,190 --> 00:11:45,500
adding every element one by one but that

00:11:41,490 --> 00:11:54,570
addition is done directed by D a SSC

00:11:45,500 --> 00:12:02,130
processor so that's my out and i'm using

00:11:54,570 --> 00:12:05,700
store line to store it back to my to my

00:12:02,130 --> 00:12:07,940
array you're still using some casting

00:12:05,700 --> 00:12:07,940
magic

00:12:10,010 --> 00:12:17,690
so basically at a time you had work

00:12:14,990 --> 00:12:20,930
tools you can just add them or use any

00:12:17,690 --> 00:12:23,510
operator or that is defined on CD or

00:12:20,930 --> 00:12:27,140
animated that is that is you that is

00:12:23,510 --> 00:12:30,800
defined on the simdi and if by chance

00:12:27,140 --> 00:12:34,570
that meter is actually is accelerated on

00:12:30,800 --> 00:12:40,760
your machine dodge it will run the

00:12:34,570 --> 00:12:54,430
accelerated version of it so we compile

00:12:40,760 --> 00:12:54,430
it GM CS okay run it nice it's slower

00:12:54,460 --> 00:13:03,880
exelon Oswin fine an hour ago

00:13:07,870 --> 00:13:11,520
you will have to trust me on this

00:13:15,100 --> 00:13:17,880
that's like

00:13:21,740 --> 00:13:24,610
the euro version

00:13:47,800 --> 00:13:54,050
come on when you can what're your right

00:13:50,840 --> 00:13:57,380
with dash 0 equals minus Cindy to make

00:13:54,050 --> 00:13:59,270
sure that it doesn't use it sorry money

00:13:57,380 --> 00:14:01,040
we have seen the optimizations from the

00:13:59,270 --> 00:14:04,450
command line yeah because maybe it's

00:14:01,040 --> 00:14:04,450
detecting that you don't have it right

00:14:06,240 --> 00:14:09,930
because there's a fallback if your

00:14:07,860 --> 00:14:12,540
machine have seen the people like this

00:14:09,930 --> 00:14:14,310
orientation yeah I know so what I'm

00:14:12,540 --> 00:14:16,170
thinking is why do you try to see if

00:14:14,310 --> 00:14:19,350
that's what's happening yeah i would

00:14:16,170 --> 00:14:22,310
just at the detection at runtime if the

00:14:19,350 --> 00:14:25,740
addition is available from a father oh

00:14:22,310 --> 00:14:37,500
do we have another one man override for

00:14:25,740 --> 00:14:41,820
this yes my life which is oh yeah over 4

00:14:37,500 --> 00:14:44,000
equals minus sandy by this yeah but

00:14:41,820 --> 00:14:44,000
lower

00:14:45,990 --> 00:14:50,899
yeah so basically what's happening is

00:14:47,760 --> 00:14:54,680
yeah i'm not using cardboard it's oh

00:14:50,899 --> 00:14:54,680
it's easy i'm using

00:14:56,579 --> 00:15:16,839
too late for and a i'm using thank you

00:15:03,540 --> 00:15:28,860
yeah so GMC s mana simdi a package gtk

00:15:16,839 --> 00:15:32,339
sharp got 0 cember yes and safe yeah

00:15:28,860 --> 00:15:32,339
which one is it

00:15:35,100 --> 00:15:39,450
yeah so

00:15:45,389 --> 00:15:56,560
okay but its own power is the other one

00:15:48,639 --> 00:16:00,310
and it shouldn't be but anyway the the

00:15:56,560 --> 00:16:04,000
output is the same that's important let

00:16:00,310 --> 00:16:10,029
me show you real results on more complex

00:16:04,000 --> 00:16:13,060
case in a sec that was just that that

00:16:10,029 --> 00:16:15,690
was done to to show you a faster to us

00:16:13,060 --> 00:16:21,910
but just to show you all you could

00:16:15,690 --> 00:16:28,740
easily do it so I think L said we can

00:16:21,910 --> 00:16:28,740
check for disability at runtime so

00:16:29,130 --> 00:16:36,250
meaning that it was proven in this case

00:16:33,339 --> 00:16:42,730
that the fall back that was implemented

00:16:36,250 --> 00:16:48,639
in simdi was less efficient than my that

00:16:42,730 --> 00:16:52,569
my simple addition using a regular

00:16:48,639 --> 00:16:54,699
arrays so if you want to avoid this and

00:16:52,569 --> 00:16:59,050
fall back in your code to one or the

00:16:54,699 --> 00:17:04,900
other you can you can easily check if a

00:16:59,050 --> 00:17:08,410
metal is accelerated at runtime so

00:17:04,900 --> 00:17:11,829
basically in the second sample I'm just

00:17:08,410 --> 00:17:16,319
checking for acceleration on every I

00:17:11,829 --> 00:17:18,790
will left to make this bit smaller

00:17:16,319 --> 00:17:24,010
basically that's another example we show

00:17:18,790 --> 00:17:27,790
you in a second and for every problem

00:17:24,010 --> 00:17:30,870
meter that will use bit later I'm just

00:17:27,790 --> 00:17:33,940
printing accelerated or not accelerated

00:17:30,870 --> 00:17:36,910
that interpreted up to run time and not

00:17:33,940 --> 00:17:42,700
at compile time so you can you could

00:17:36,910 --> 00:17:45,880
decide you could decide at the time you

00:17:42,700 --> 00:17:49,510
write your code okay if i do if i do at

00:17:45,880 --> 00:17:52,570
ssa for instruction i will do it that

00:17:49,510 --> 00:17:55,990
way if i only ac3 i will do it that way

00:17:52,570 --> 00:17:58,920
and otherwise i will do it

00:17:55,990 --> 00:18:04,390
yet another way maybe by leveraging some

00:17:58,920 --> 00:18:06,940
some some other net native library or

00:18:04,390 --> 00:18:10,840
whatever or you can even fall back to

00:18:06,940 --> 00:18:13,170
the 22 to the default implementation of

00:18:10,840 --> 00:18:16,420
mono simdi but as we just showed is

00:18:13,170 --> 00:18:19,480
basically quite slow it's it do the

00:18:16,420 --> 00:18:22,330
thing it should but not much so

00:18:19,480 --> 00:18:27,990
basically you check you you you check

00:18:22,330 --> 00:18:32,470
the you ask the runtime which is a

00:18:27,990 --> 00:18:37,500
static class if a meter is accelerated

00:18:32,470 --> 00:18:41,740
and basically cindy is mostly except for

00:18:37,500 --> 00:18:46,179
those those that does the multiply i was

00:18:41,740 --> 00:18:51,130
studying but it's on for f a vector

00:18:46,179 --> 00:18:53,380
containing for float that that's all I I

00:18:51,130 --> 00:18:57,309
would have checked if the addition was

00:18:53,380 --> 00:19:02,170
available on that machine and as most of

00:18:57,309 --> 00:19:05,350
the methods of granted at extension

00:19:02,170 --> 00:19:09,270
method that's the way you checked for

00:19:05,350 --> 00:19:12,400
that the code is a bit cryptic i will

00:19:09,270 --> 00:19:18,330
post it on my blog on monday or next

00:19:12,400 --> 00:19:21,250
week no it's not cryptic with on that

00:19:18,330 --> 00:19:23,950
small number of currents it's not easy

00:19:21,250 --> 00:19:26,260
to see so basically you can ask the

00:19:23,950 --> 00:19:28,600
runtime if a method is accelerating if

00:19:26,260 --> 00:19:31,210
the middle x accelerated the one time

00:19:28,600 --> 00:19:33,550
will accelerate it otherwise it will

00:19:31,210 --> 00:19:35,380
fall back but as you can check at

00:19:33,550 --> 00:19:38,320
runtime it fits away where you can

00:19:35,380 --> 00:19:42,059
program a tree decide to pick a fullback

00:19:38,320 --> 00:19:42,059
or an order

00:19:45,640 --> 00:19:57,740
yeah where were you so basically if you

00:19:52,549 --> 00:20:01,400
want to do that that doesn't apply to 22

00:19:57,740 --> 00:20:06,049
simdi but basically if you want to to

00:20:01,400 --> 00:20:13,909
make some image manipulation on model or

00:20:06,049 --> 00:20:18,850
net you can't just use the the image as

00:20:13,909 --> 00:20:21,710
a bite re or whatever it is because the

00:20:18,850 --> 00:20:25,669
boundary check of the URI will slow

00:20:21,710 --> 00:20:33,169
things down so you you most of the time

00:20:25,669 --> 00:20:37,990
you just have to just have to put your

00:20:33,169 --> 00:20:41,649
the part of the code that matters in an

00:20:37,990 --> 00:20:41,649
unsafe context

00:20:42,870 --> 00:20:48,090
in unsafe context saying that you're

00:20:45,600 --> 00:20:54,780
allowed to use that see like

00:20:48,090 --> 00:20:58,200
construction using pointers doing notice

00:20:54,780 --> 00:21:02,210
in the other case doing conversion and

00:20:58,200 --> 00:21:04,500
cast that are unchecked by the runtime

00:21:02,210 --> 00:21:13,280
so you have to do that if you want to do

00:21:04,500 --> 00:21:19,170
some efficient image manipulation on.net

00:21:13,280 --> 00:21:23,580
following that so you have to either

00:21:19,170 --> 00:21:26,610
declare all your method and save or just

00:21:23,580 --> 00:21:29,850
a block of it and fast and save to the

00:21:26,610 --> 00:21:36,240
come online or to the compiler so so it

00:21:29,850 --> 00:21:44,270
goes true let's move to more complex to

00:21:36,240 --> 00:21:50,220
more complex five minutes okay yeah I

00:21:44,270 --> 00:21:54,059
will just show you how I'm doing yeah so

00:21:50,220 --> 00:21:59,210
some general advice if you're doing if

00:21:54,059 --> 00:22:03,120
you're doing a simply pressing on mono

00:21:59,210 --> 00:22:05,940
try to avoid computing it float because

00:22:03,120 --> 00:22:11,220
even if for a live image manipulation

00:22:05,940 --> 00:22:14,720
because even if there is some float

00:22:11,220 --> 00:22:17,910
operation using simdi we don't have any

00:22:14,720 --> 00:22:22,260
accelerated way of converting a short to

00:22:17,910 --> 00:22:27,450
float and a float back to a show except

00:22:22,260 --> 00:22:31,140
using.net casting and that's quite

00:22:27,450 --> 00:22:35,610
expensive if we were able but that's not

00:22:31,140 --> 00:22:37,350
the case to use the MMX CVG operation

00:22:35,610 --> 00:22:43,980
that that's a possible because there is

00:22:37,350 --> 00:22:46,740
no mix acceleration on on mono simdi it

00:22:43,980 --> 00:22:49,309
would be possible so but it's not

00:22:46,740 --> 00:22:52,290
impossible if if you if you just want to

00:22:49,309 --> 00:22:56,190
some more precision you just unpack your

00:22:52,290 --> 00:22:58,470
floor by to a short or to an integer you

00:22:56,190 --> 00:23:03,679
do your computation using your integral

00:22:58,470 --> 00:23:07,860
computation and you you then repack it

00:23:03,679 --> 00:23:13,020
too short to a battery a 2-byte vector

00:23:07,860 --> 00:23:16,770
before putting it to your bring it to

00:23:13,020 --> 00:23:19,620
your pixel read to your image though so

00:23:16,770 --> 00:23:22,140
that's quite important and if you do

00:23:19,620 --> 00:23:24,120
that it will be accelerated but the

00:23:22,140 --> 00:23:26,220
casting will just kill the performance

00:23:24,120 --> 00:23:32,700
Oh the performance will be just on par

00:23:26,220 --> 00:23:36,210
with with native implementation not

00:23:32,700 --> 00:23:41,310
accelerate so that that's one thing I

00:23:36,210 --> 00:23:44,100
heard that SSC 5 would have some

00:23:41,310 --> 00:23:47,460
operation accelerated for converting

00:23:44,100 --> 00:23:50,580
float back to end of I i I've I've read

00:23:47,460 --> 00:23:53,760
something about it but I didn't see

00:23:50,580 --> 00:23:55,800
anything I don't have deadlines or

00:23:53,760 --> 00:23:58,590
whatever and anyway for the machine you

00:23:55,800 --> 00:24:04,200
have right now it doesn't have sec 5 so

00:23:58,590 --> 00:24:06,300
for faux pas no just avoid it so the

00:24:04,200 --> 00:24:15,890
other example is the example I showed on

00:24:06,300 --> 00:24:24,330
my blog some some weeks ago and that's

00:24:15,890 --> 00:24:27,840
that's an application that just a port

00:24:24,330 --> 00:24:33,760
of the GDK pigs bath saturate and

00:24:27,840 --> 00:24:36,670
pixelate operation saturated pixelate is

00:24:33,760 --> 00:24:39,070
a metered of GDK pics but that basically

00:24:36,670 --> 00:24:40,960
you can either pixelate or disappear it

00:24:39,070 --> 00:24:43,510
i only implemented this data to it case

00:24:40,960 --> 00:24:45,820
and you don't have to disagree eight

00:24:43,510 --> 00:24:48,610
hundred percent of it you can just this

00:24:45,820 --> 00:24:54,630
rate this it created a bit so basically

00:24:48,610 --> 00:24:59,440
the the the mat for this is UF your

00:24:54,630 --> 00:25:02,320
saturated image you desaturate it

00:24:59,440 --> 00:25:05,140
completely each so this desaturating is

00:25:02,320 --> 00:25:07,510
taking something like eighteen percent

00:25:05,140 --> 00:25:10,420
eighty percent of the green channel and

00:25:07,510 --> 00:25:14,590
ten of the the two other one or the

00:25:10,420 --> 00:25:17,800
number will we will be shown a bit later

00:25:14,590 --> 00:25:21,180
and you take the mean and the weighted

00:25:17,800 --> 00:25:23,980
mean depending if you want a fully

00:25:21,180 --> 00:25:27,070
saturated or fully and saturated one so

00:25:23,980 --> 00:25:32,800
you add both it's quite are to do it

00:25:27,070 --> 00:25:38,170
using simdi i will go fast because i'm

00:25:32,800 --> 00:25:50,140
almost off tough sign wrapped up which

00:25:38,170 --> 00:25:52,860
one is it so that's the up up up okay so

00:25:50,140 --> 00:25:52,860
that's the one

00:25:56,100 --> 00:26:05,530
i'm using a child multiplier so she

00:25:58,600 --> 00:26:08,400
knows its not 80s basics yeah it's

00:26:05,530 --> 00:26:13,870
thirty percent of Fred sixty percent of

00:26:08,400 --> 00:26:16,270
green and tan person of off of blue and

00:26:13,870 --> 00:26:20,770
that makes it the white and black guy

00:26:16,270 --> 00:26:25,920
image that that looks great so basically

00:26:20,770 --> 00:26:30,000
what i'm doing here as I'm working on a

00:26:25,920 --> 00:26:34,920
vector containing eight in science short

00:26:30,000 --> 00:26:37,690
and there is no horizontal add on

00:26:34,920 --> 00:26:40,510
basically if you want if you want to

00:26:37,690 --> 00:26:43,690
decorate an image you just multiply all

00:26:40,510 --> 00:26:45,580
the component by some magic numbers and

00:26:43,690 --> 00:26:49,060
then you add all the components together

00:26:45,580 --> 00:26:50,500
and you divide by 3 there is there is

00:26:49,060 --> 00:26:52,090
something nice if you are working on

00:26:50,500 --> 00:26:54,370
float you can find you can do an

00:26:52,090 --> 00:26:56,200
horizontal ad and it will add for the

00:26:54,370 --> 00:27:00,100
components together but there is no

00:26:56,200 --> 00:27:03,580
original Adam vector H us so you can I

00:27:00,100 --> 00:27:08,560
you can use a shiver and shuffle is it's

00:27:03,580 --> 00:27:12,100
a way it's a way to to mix your the

00:27:08,560 --> 00:27:15,010
component of your of your vector and

00:27:12,100 --> 00:27:18,430
what I'm doing I'm shuffling twice I'm

00:27:15,010 --> 00:27:21,700
doing to shuffle version so I all the

00:27:18,430 --> 00:27:26,460
the variation of it and I cannot date I

00:27:21,700 --> 00:27:30,160
can edit at the end and have a vector

00:27:26,460 --> 00:27:34,120
containing the same value on the three

00:27:30,160 --> 00:27:36,520
main component and that's it that's

00:27:34,120 --> 00:27:43,210
that's all I'm doing the deceleration

00:27:36,520 --> 00:27:48,460
and then yeah so yeah up up up up up so

00:27:43,210 --> 00:27:50,970
I'm cheeky I'm shuffling shuffling and

00:27:48,460 --> 00:27:56,160
adding so I'm having the intensity and

00:27:50,970 --> 00:27:56,160
then what I'm doing

00:27:56,870 --> 00:28:05,490
at the time and should be okay I will

00:28:03,539 --> 00:28:08,850
sure you put the block a bit later I can

00:28:05,490 --> 00:28:12,260
show you how it works GMS oh it's

00:28:08,850 --> 00:28:20,220
already compiled okay I'll disagree

00:28:12,260 --> 00:28:23,789
eggsy simdi okay and that acceleration

00:28:20,220 --> 00:28:26,669
so that's the check I told you about a

00:28:23,789 --> 00:28:28,529
bit earlier I'm not doing any any

00:28:26,669 --> 00:28:33,230
treatment of the check I'm just printing

00:28:28,529 --> 00:28:33,230
its accelerated or not oh yeah

00:28:37,040 --> 00:28:42,030
so basically I'm checking yeah i'm i'm

00:28:40,140 --> 00:28:44,730
checking the middle i accelerated i'm

00:28:42,030 --> 00:28:46,620
not doing any treatment of it because i

00:28:44,730 --> 00:28:49,730
know they are on my machine that the

00:28:46,620 --> 00:28:55,190
time it took to make a distillation of

00:28:49,730 --> 00:28:58,560
my mage okay here it is it's a partial

00:28:55,190 --> 00:29:07,890
distillation and i can just show you how

00:28:58,560 --> 00:29:14,400
slow it is using GD g GD k 1 up up up up

00:29:07,890 --> 00:29:22,590
up what's my argument yeah it's no

00:29:14,400 --> 00:29:25,770
argument ok that's GD k you're using it

00:29:22,590 --> 00:29:29,430
you're using it every day and it's not

00:29:25,770 --> 00:29:32,340
accelerated adore so that code to it it

00:29:29,430 --> 00:29:37,620
just it provides an extension method to

00:29:32,340 --> 00:29:42,780
GD GD k pigs bath and that's really

00:29:37,620 --> 00:29:47,040
worth it its 87 no yeah it seven times

00:29:42,780 --> 00:29:49,650
the better and that's very worth it yeah

00:29:47,040 --> 00:29:52,170
so I'm out of time i don't know if i

00:29:49,650 --> 00:29:54,990
will have time for questions but one one

00:29:52,170 --> 00:29:58,290
more thing this the kiddies i showed you

00:29:54,990 --> 00:30:03,540
are oversimplified because I was always

00:29:58,290 --> 00:30:06,690
assuming i had an alpha channel i doing

00:30:03,540 --> 00:30:10,260
that on some special images that that

00:30:06,690 --> 00:30:12,240
are number a multiple of 16 on each side

00:30:10,260 --> 00:30:17,280
so i don't have to to check for the

00:30:12,240 --> 00:30:18,900
remaining bits at the end so it is it

00:30:17,280 --> 00:30:23,370
just for the matter of simplifying the

00:30:18,900 --> 00:30:25,710
loop but so a real implementation of it

00:30:23,370 --> 00:30:29,450
would take something like 20 lights more

00:30:25,710 --> 00:30:32,990
but that that wasn't

00:30:29,450 --> 00:30:37,840
doesn't necessarily needed for that that

00:30:32,990 --> 00:30:37,840

YouTube URL: https://www.youtube.com/watch?v=0va-cWZgI70


