Title: Coreboot and PC technical details
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Peter Stuge

A modern PC is quite different from the 1980s original, and while the BIOS still lingers after 30 years it must now solve many tricky problems.

When the original PC with it's pre-ISA expansion bus was powered on, it was almost immediately ready to run an application. Today's PC can have several multicore CPUs interconnected by HyperTransport, Front Side Bus or QuickPath, DDR3 RAM on each CPU, and a large number of buses and peripherals. Many components require increasingly complex initialization to be implemented in software. This talk describes the technical challenges encountered by coreboot developers and their solutions.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:05,790
this the second demo and please be quiet

00:00:02,250 --> 00:00:08,779
everyone some that we might fail to hear

00:00:05,790 --> 00:00:08,779
what's actually going on

00:00:21,340 --> 00:00:27,220
no no wait to hear what's going on I'll

00:00:23,620 --> 00:00:30,070
just have to sort of narrate again the

00:00:27,220 --> 00:00:33,910
serial console this is a one of the deal

00:00:30,070 --> 00:00:37,720
dell exports an AMD cpu the embedded aim

00:00:33,910 --> 00:00:43,480
the embedded cpu with 256 megabytes of

00:00:37,720 --> 00:00:47,410
ram and let's see when i reset reset

00:00:43,480 --> 00:00:49,000
there we are for book-running and there

00:00:47,410 --> 00:00:51,970
it's already starting to the Linux

00:00:49,000 --> 00:00:54,040
kernel and that's the final prompt of

00:00:51,970 --> 00:00:57,280
the Linux system which is full up at

00:00:54,040 --> 00:00:59,739
that time so this this shows that if you

00:00:57,280 --> 00:01:01,300
disable all the debugging stuff and you

00:00:59,739 --> 00:01:04,089
have a really trimmed down colonel you

00:01:01,300 --> 00:01:13,380
can get a very nice very nice start up

00:01:04,089 --> 00:01:15,280
time yeah i'm talking about boot time

00:01:13,380 --> 00:01:19,090
measurements i think it's important to

00:01:15,280 --> 00:01:21,250
to be careful with the numbers here or

00:01:19,090 --> 00:01:22,840
just be careful about what the numbers

00:01:21,250 --> 00:01:25,539
actually are saying because different

00:01:22,840 --> 00:01:27,910
people will use different metrics to for

00:01:25,539 --> 00:01:30,340
boots time measurements and of course

00:01:27,910 --> 00:01:32,560
everyone wants their numbers to to be

00:01:30,340 --> 00:01:37,119
the best so they're going to use what is

00:01:32,560 --> 00:01:38,979
best for them what is the this this time

00:01:37,119 --> 00:01:43,149
measurement actually saying is it saying

00:01:38,979 --> 00:01:45,429
from power supply connected to windows

00:01:43,149 --> 00:01:47,890
running with a full desktop whatever

00:01:45,429 --> 00:01:51,700
login user or linux or whatever you have

00:01:47,890 --> 00:01:53,979
or is it from after the mainboard

00:01:51,700 --> 00:01:56,590
power-up sequence which might make a

00:01:53,979 --> 00:01:57,990
difference it sounds silly but but it

00:01:56,590 --> 00:02:01,720
might actually make a big difference

00:01:57,990 --> 00:02:04,330
there are about 30 voltages in a pc

00:02:01,720 --> 00:02:06,640
system so and these only to start in a

00:02:04,330 --> 00:02:08,830
special sequence and that takes time of

00:02:06,640 --> 00:02:10,869
course or is it from the first

00:02:08,830 --> 00:02:14,170
instruction fetch which might be a lot

00:02:10,869 --> 00:02:16,120
later then after all the voltages are up

00:02:14,170 --> 00:02:19,390
who knows what's what's going on

00:02:16,120 --> 00:02:21,610
the system so the guy who has been

00:02:19,390 --> 00:02:23,650
developing see BIOS his name is Kevin

00:02:21,610 --> 00:02:28,480
O'Connor he did some optimizations for

00:02:23,650 --> 00:02:32,890
his particular board he has an an epi

00:02:28,480 --> 00:02:37,150
aboard of the epi scn with a c7 CPU and

00:02:32,890 --> 00:02:39,579
the CN 700 chipset he put coreboot MC

00:02:37,150 --> 00:02:42,760
BIOS in flash used C bars of the payload

00:02:39,579 --> 00:02:48,940
and he has he had robbed on a SATA SSD

00:02:42,760 --> 00:02:52,690
and this is this is the results he got

00:02:48,940 --> 00:02:54,609
he had to spend 350 milliseconds just

00:02:52,690 --> 00:02:57,220
waiting for what seemed to be power

00:02:54,609 --> 00:03:00,190
sequencing from he presses from from the

00:02:57,220 --> 00:03:04,030
time he presses the button to some

00:03:00,190 --> 00:03:06,700
software actually running is this almost

00:03:04,030 --> 00:03:09,209
half a second then he measured that it

00:03:06,700 --> 00:03:11,200
takes about 50 milliseconds to wait for

00:03:09,209 --> 00:03:14,470
communications with us on the main board

00:03:11,200 --> 00:03:18,010
to stabilize another 20 milliseconds to

00:03:14,470 --> 00:03:22,209
configure the memory controller 10

00:03:18,010 --> 00:03:24,370
milliseconds running core boobs 200

00:03:22,209 --> 00:03:27,579
milliseconds waiting for the vga BIOS to

00:03:24,370 --> 00:03:30,190
initialize the graphics and another 10

00:03:27,579 --> 00:03:33,430
milliseconds in in grub and the Graham

00:03:30,190 --> 00:03:35,139
tofu is that it takes seven hundred 50

00:03:33,430 --> 00:03:37,060
milliseconds from the time he presses

00:03:35,139 --> 00:03:39,780
the power button to when Linux is

00:03:37,060 --> 00:03:39,780
already starting

00:03:42,730 --> 00:03:47,760
security slide i don't know i think i'm

00:03:45,790 --> 00:03:49,930
going to skip this well maybe just

00:03:47,760 --> 00:03:53,760
mention it quickly cold boot attack

00:03:49,930 --> 00:03:56,950
there was a attack made public I guess

00:03:53,760 --> 00:03:59,080
the year before last year so 2008 where

00:03:56,950 --> 00:04:01,629
even though you power down your computer

00:03:59,080 --> 00:04:03,430
the RAM might not still might not be

00:04:01,629 --> 00:04:06,190
completely empty and if someone can

00:04:03,430 --> 00:04:08,280
steal your laptop or well desktop for

00:04:06,190 --> 00:04:11,470
that matter they can check out the ram

00:04:08,280 --> 00:04:13,120
the dim and extract all the contents of

00:04:11,470 --> 00:04:16,810
the data and it's really easy to find

00:04:13,120 --> 00:04:20,049
cryptic keys and so on so coreboot can

00:04:16,810 --> 00:04:22,000
be used both in the attack and for

00:04:20,049 --> 00:04:24,460
defense here because Corps boot has Ram

00:04:22,000 --> 00:04:26,020
initialization it can start their memory

00:04:24,460 --> 00:04:27,880
controller and then have a special dump

00:04:26,020 --> 00:04:29,889
routine inside forward to read out all

00:04:27,880 --> 00:04:33,850
the contents without changing anything

00:04:29,889 --> 00:04:35,770
in RAM but you could also use it so that

00:04:33,850 --> 00:04:37,870
when you're shutting down there's a part

00:04:35,770 --> 00:04:39,880
of cord which which which runs and make

00:04:37,870 --> 00:04:45,850
sure to clear all the memory before it

00:04:39,880 --> 00:04:48,270
covers off code injection into the

00:04:45,850 --> 00:04:52,660
operating system there was a exploit

00:04:48,270 --> 00:04:56,889
published we're part of the virus was

00:04:52,660 --> 00:04:59,110
changed to always rewrite permissions on

00:04:56,889 --> 00:05:01,840
a particular file in the file in the

00:04:59,110 --> 00:05:05,349
root filesystem so whenever you rebooted

00:05:01,840 --> 00:05:08,349
this file became world executable with

00:05:05,349 --> 00:05:11,860
the plus s and everyone had a root shell

00:05:08,349 --> 00:05:13,870
on the system that's that's not

00:05:11,860 --> 00:05:19,810
something you want in your your firmware

00:05:13,870 --> 00:05:23,340
so it might be worthwhile to to look

00:05:19,810 --> 00:05:23,340
carefully at the firmware your running

00:05:23,460 --> 00:05:28,060
there's a lot of good stuff about poor

00:05:25,599 --> 00:05:31,210
boots you can get really fast startup

00:05:28,060 --> 00:05:33,639
times it's open source see how the GPL

00:05:31,210 --> 00:05:38,860
you can audit you can read it it's you

00:05:33,639 --> 00:05:41,770
don't have to study assembly assembly

00:05:38,860 --> 00:05:44,289
sources a day on end to go through the

00:05:41,770 --> 00:05:47,740
code we have one tree for all the boards

00:05:44,289 --> 00:05:51,219
so there's a fair chance of reusability

00:05:47,740 --> 00:05:52,930
and extensibility there there's there's

00:05:51,219 --> 00:05:55,000
some challenges we need more testing

00:05:52,930 --> 00:05:56,860
that would be great there's a testing

00:05:55,000 --> 00:06:00,340
infrastructure but it's it's kind of

00:05:56,860 --> 00:06:02,050
difficult to hook up boards to be tested

00:06:00,340 --> 00:06:06,340
to this infrastructure so even though we

00:06:02,050 --> 00:06:08,469
have really nice really nice way in this

00:06:06,340 --> 00:06:11,979
infrastructure to test each commits on

00:06:08,469 --> 00:06:14,919
actual hardware because it's the fact

00:06:11,979 --> 00:06:16,539
that it's too difficult to connect

00:06:14,919 --> 00:06:18,330
boards to this infrastructure means that

00:06:16,539 --> 00:06:20,710
there's little testing actually done

00:06:18,330 --> 00:06:22,870
everything is built on each commits and

00:06:20,710 --> 00:06:24,880
that's a good good good start of course

00:06:22,870 --> 00:06:27,250
but it would be very nice also to see

00:06:24,880 --> 00:06:29,770
boots boots testing because stuff can

00:06:27,250 --> 00:06:34,060
break even though it compiles it it

00:06:29,770 --> 00:06:36,159
might not run and it would be very nice

00:06:34,060 --> 00:06:38,080
to have all the boards really one

00:06:36,159 --> 00:06:40,750
hundred percent supported most of the

00:06:38,080 --> 00:06:42,280
boards are implemented by one single

00:06:40,750 --> 00:06:44,560
developer or a small group of developers

00:06:42,280 --> 00:06:46,780
and they were really happy when all the

00:06:44,560 --> 00:06:50,159
stuff they need is working but that

00:06:46,780 --> 00:06:52,870
might not be enough for everyone else so

00:06:50,159 --> 00:06:56,440
little things on the main board might

00:06:52,870 --> 00:06:58,030
still need some code to to work most

00:06:56,440 --> 00:07:01,860
boards are not really far away there's

00:06:58,030 --> 00:07:04,990
only very small very small stuff missing

00:07:01,860 --> 00:07:06,909
acpi we need to get better at acpi but

00:07:04,990 --> 00:07:09,669
we already have a lot of good progress

00:07:06,909 --> 00:07:11,740
there and thanks to load up was going to

00:07:09,669 --> 00:07:17,889
talk about it a bit later and

00:07:11,740 --> 00:07:21,490
and who would is great fun so come come

00:07:17,889 --> 00:07:25,750
into the project please thanks to Luke

00:07:21,490 --> 00:07:28,210
for organizing this dev room and some

00:07:25,750 --> 00:07:32,050
some links for ganna mailing list and

00:07:28,210 --> 00:07:35,020
we're on our sea and the wiki you can

00:07:32,050 --> 00:07:40,289
just add anything after the URL and you

00:07:35,020 --> 00:07:45,630
should get an informative page questions

00:07:40,289 --> 00:07:48,789
Kristen M what you use in your question

00:07:45,630 --> 00:07:54,270
what you use for flashing your flash

00:07:48,789 --> 00:07:54,270
chip if it is completely screwed sorry

00:07:56,340 --> 00:08:02,139
you can yeah sure that's one way you can

00:07:59,560 --> 00:08:07,060
have a flash flash programmer or flash

00:08:02,139 --> 00:08:10,509
writers down below that helps but you

00:08:07,060 --> 00:08:15,099
don't always have access to that one

00:08:10,509 --> 00:08:18,400
thing you can do is to have a use

00:08:15,099 --> 00:08:21,460
another mainboard it there and hot swap

00:08:18,400 --> 00:08:25,690
the flash chips flash cubes programmer

00:08:21,460 --> 00:08:28,599
good to have but the you can also use

00:08:25,690 --> 00:08:30,940
another main board yeah what's what

00:08:28,599 --> 00:08:32,620
that's fine I think her Daniel will talk

00:08:30,940 --> 00:08:38,700
more about that also in the flash room

00:08:32,620 --> 00:08:38,700
talk another question yeah

00:08:41,460 --> 00:09:16,270
what are the implications yeah sure so

00:09:11,130 --> 00:09:21,460
is minimalistic a TI opponent is what

00:09:16,270 --> 00:09:25,270
the standard is that nothing more so we

00:09:21,460 --> 00:09:27,810
don't have much of the bike only very

00:09:25,270 --> 00:09:31,600
very routine is required by

00:09:27,810 --> 00:09:34,870
accreditation so in this in this case

00:09:31,600 --> 00:09:38,680
everything with the real wide variety

00:09:34,870 --> 00:09:43,440
system these is power there but there is

00:09:38,680 --> 00:09:43,440
no fancy stuff by the zone

00:09:47,600 --> 00:09:59,760
the three full-grown when and there are

00:09:56,310 --> 00:10:01,470
so that I guess I could add there that

00:09:59,760 --> 00:10:03,450
one implication would be that there

00:10:01,470 --> 00:10:06,440
needs to be a driver to handle some

00:10:03,450 --> 00:10:09,750
tasks that might otherwise be handled

00:10:06,440 --> 00:10:13,980
using a CPI on another operating system

00:10:09,750 --> 00:10:16,380
or sorry another firmware but again if

00:10:13,980 --> 00:10:22,920
linux has that driver then and you want

00:10:16,380 --> 00:10:29,010
to run linux then it's fine come work

00:10:22,920 --> 00:10:31,700
gap okay another question first

00:10:29,010 --> 00:10:31,700
instruction

00:10:34,630 --> 00:10:50,260
yes you have to yeah things like that

00:10:47,890 --> 00:10:52,570
yes yeah that's part of the build and

00:10:50,260 --> 00:10:55,420
there are also some variables that are

00:10:52,570 --> 00:10:58,090
set or some settings that you can change

00:10:55,420 --> 00:11:00,730
runtime well not run time that are read

00:10:58,090 --> 00:11:02,500
from ND romics so you if you boot up

00:11:00,730 --> 00:11:04,060
your operating system you use nvram

00:11:02,500 --> 00:11:06,610
tools to change the settings and the

00:11:04,060 --> 00:11:15,730
next time you reboot they will take

00:11:06,610 --> 00:11:22,750
effect for example as a new version I

00:11:15,730 --> 00:11:26,110
put version us track the exact Remy's so

00:11:22,750 --> 00:11:30,270
a new main board with higher clock ram

00:11:26,110 --> 00:11:34,780
or a different type of ram would be

00:11:30,270 --> 00:11:36,670
small to medium effort Rufus is also

00:11:34,780 --> 00:11:39,070
going to talk about porting coreboot to

00:11:36,670 --> 00:11:41,980
a new board and it would really be like

00:11:39,070 --> 00:11:46,120
adding a new main board if it's if it's

00:11:41,980 --> 00:11:48,190
say an upgrade from ddr2 to ddr3 not all

00:11:46,120 --> 00:11:50,110
of the work needs to be done as if it

00:11:48,190 --> 00:11:54,180
was a completely new main board but

00:11:50,110 --> 00:11:54,180
still some things have to be changed and

00:11:59,670 --> 00:12:04,630
so high I'm going to talk about that in

00:12:02,830 --> 00:12:09,160
the next presentation of RAM

00:12:04,630 --> 00:12:11,280
initialisation depends if you're are you

00:12:09,160 --> 00:12:14,350
staying for that as well then maybe okay

00:12:11,280 --> 00:12:19,110
all right well if you have then maybe we

00:12:14,350 --> 00:12:19,110
can come back to the question all right

00:12:20,190 --> 00:12:26,950
yes there's one laptop supported at the

00:12:23,380 --> 00:12:28,810
moment two if you count the OLPC so the

00:12:26,950 --> 00:12:30,460
laptop that is supported is is I

00:12:28,810 --> 00:12:34,210
mentioned that in the presentation it's

00:12:30,460 --> 00:12:38,410
the development was funded by the German

00:12:34,210 --> 00:12:39,970
BSI and it's a rugged rugged laptop but

00:12:38,410 --> 00:12:42,460
the components in it are a fairly

00:12:39,970 --> 00:12:44,110
standard so that code and that effort

00:12:42,460 --> 00:12:48,940
can be reused for supporting other

00:12:44,110 --> 00:12:52,150
laptops as well and i also have one

00:12:48,940 --> 00:12:59,170
board that i'm sort of working on a

00:12:52,150 --> 00:13:01,990
laptop they call it a netbook but I hit

00:12:59,170 --> 00:13:04,450
the 12 inch it has a 12 inch screen so i

00:13:01,990 --> 00:13:06,670
don't know if i think it's the metal but

00:13:04,450 --> 00:13:08,440
this is this is the board anyway this is

00:13:06,670 --> 00:13:09,970
all that it's really in the laptop

00:13:08,440 --> 00:13:12,970
except for the screen and the harddrive

00:13:09,970 --> 00:13:17,860
it's a VI bi platform it's with Samsung

00:13:12,970 --> 00:13:22,060
and see 20 so hopefully that will work

00:13:17,860 --> 00:13:24,480
at some point as well does that answer

00:13:22,060 --> 00:13:24,480
your question

00:13:26,110 --> 00:13:34,600
I please do but it it might be a lot of

00:13:31,480 --> 00:13:37,200
work and especially it depends a lot on

00:13:34,600 --> 00:13:39,730
the which components are in your laptop

00:13:37,200 --> 00:13:41,380
Rudolph we'll talk about that morals in

00:13:39,730 --> 00:13:42,550
his presentation it can be really

00:13:41,380 --> 00:13:47,529
difficult to find out all the

00:13:42,550 --> 00:13:48,820
information that is necessary right so

00:13:47,529 --> 00:13:52,290
no more question thank you very much for

00:13:48,820 --> 00:13:54,490
coming sorry i went over time a bit but

00:13:52,290 --> 00:13:56,640
yeah I hope you thought it was

00:13:54,490 --> 00:13:56,640
interesting

00:14:18,529 --> 00:14:25,230
do we need a few minutes of a break

00:14:23,310 --> 00:14:26,940
between presentations before I start the

00:14:25,230 --> 00:14:32,760
next one or should I just go straight

00:14:26,940 --> 00:14:35,240
away all right i'll continue that okay

00:14:32,760 --> 00:14:35,240
yeah

00:14:43,600 --> 00:14:49,720
so poor boot and PC technical details is

00:14:47,019 --> 00:14:53,230
is the title of this presentation this

00:14:49,720 --> 00:14:58,389
is what I hope to be able to talk about

00:14:53,230 --> 00:15:01,899
here yeah we were mine again I guess

00:14:58,389 --> 00:15:06,459
that's the same as before I look at the

00:15:01,899 --> 00:15:08,800
30 years of PCs the pc has been wrong

00:15:06,459 --> 00:15:14,230
for a long time and it's changed quite a

00:15:08,800 --> 00:15:17,259
lot I were to have a look at the ice

00:15:14,230 --> 00:15:19,779
above the the first well actually the

00:15:17,259 --> 00:15:21,940
second extension bus in the PC but the

00:15:19,779 --> 00:15:23,259
it worked the same way as the first one

00:15:21,940 --> 00:15:26,440
so we're going to look at that in order

00:15:23,259 --> 00:15:29,620
to learn some things that are very

00:15:26,440 --> 00:15:35,009
important and still applied it to a lot

00:15:29,620 --> 00:15:37,300
of other buses and devices in modern PC

00:15:35,009 --> 00:15:41,709
some thing about Hardware registers

00:15:37,300 --> 00:15:45,699
various on various buses I sub pci and

00:15:41,709 --> 00:15:47,350
Emmas or i'm going to talk a bit about

00:15:45,699 --> 00:15:52,930
nvram i'm going to talk a bit about

00:15:47,350 --> 00:15:55,269
interrupts ram initialization caches ram

00:15:52,930 --> 00:15:59,860
is a trick that is used by many farmers

00:15:55,269 --> 00:16:02,380
today GCC and rom CC rumson see is

00:15:59,860 --> 00:16:06,910
something that came out of court route

00:16:02,380 --> 00:16:08,500
as well the different x86 execution

00:16:06,910 --> 00:16:10,660
notes real no protective mode to

00:16:08,500 --> 00:16:14,380
management mode may be embedded

00:16:10,660 --> 00:16:17,410
controllers at this time and the tanks

00:16:14,380 --> 00:16:19,240
this is the same as the last slide I've

00:16:17,410 --> 00:16:25,380
been doing coreboot for a while I

00:16:19,240 --> 00:16:28,149
started in Hamburg do stuff the pc in

00:16:25,380 --> 00:16:31,149
the 1980s it might have looked like this

00:16:28,149 --> 00:16:33,339
there was a cpu and there was a booth

00:16:31,149 --> 00:16:36,360
wrong and there was some ram connected

00:16:33,339 --> 00:16:38,850
and who's a cassette player and the key

00:16:36,360 --> 00:16:41,329
and an expansion port now that this was

00:16:38,850 --> 00:16:45,149
really connected to the same sort of

00:16:41,329 --> 00:16:49,079
same communications buses so we went

00:16:45,149 --> 00:16:51,810
from cassette to ddr3 and this is what a

00:16:49,079 --> 00:16:58,370
PC might look like today and there's a

00:16:51,810 --> 00:17:04,020
lot of stuff in here we can have four or

00:16:58,370 --> 00:17:05,790
however many 816 CPUs maybe every cpu

00:17:04,020 --> 00:17:08,790
who might have its own memory controller

00:17:05,790 --> 00:17:11,520
and the roundest connect is the memory

00:17:08,790 --> 00:17:13,169
controller and that's one bus and the

00:17:11,520 --> 00:17:16,410
different CPUs might be connected

00:17:13,169 --> 00:17:17,370
together in one special bus and then

00:17:16,410 --> 00:17:21,299
there's some connection to the

00:17:17,370 --> 00:17:24,000
Northbridge and some io io stuff there's

00:17:21,299 --> 00:17:26,640
a whole graphics block which is either

00:17:24,000 --> 00:17:29,790
in the North Bridge or might be on a pci

00:17:26,640 --> 00:17:31,830
express bus off somewhere there's

00:17:29,790 --> 00:17:35,400
another bus down here to something south

00:17:31,830 --> 00:17:41,910
ridge which has a slower the old pci bus

00:17:35,400 --> 00:17:44,100
there's some USB and i ee PST who may be

00:17:41,910 --> 00:17:48,840
there or might be over here in the super

00:17:44,100 --> 00:17:53,940
i/o LPC is a replacement bus for the old

00:17:48,840 --> 00:17:56,179
i sub us and it's i would say that it's

00:17:53,940 --> 00:18:00,210
really on every mainboard these days

00:17:56,179 --> 00:18:02,400
there's an LPC bus somewhere it can

00:18:00,210 --> 00:18:05,520
connect to was it rio it can also

00:18:02,400 --> 00:18:08,429
connect to look / or there could be an

00:18:05,520 --> 00:18:12,000
SPI bus which connects from the

00:18:08,429 --> 00:18:13,980
Southbridge to the loop / or there could

00:18:12,000 --> 00:18:16,740
be an spi in the super i oh so it goes

00:18:13,980 --> 00:18:18,929
be able to see over to the trial spi and

00:18:16,740 --> 00:18:20,970
then to the route flash and this is Rio

00:18:18,929 --> 00:18:24,630
has lots of lots of other suck also

00:18:20,970 --> 00:18:26,549
floppy and it could be ps2 as i

00:18:24,630 --> 00:18:29,910
mentioned say real caramel gpios

00:18:26,549 --> 00:18:32,040
watchdog terminal measuring lots of

00:18:29,910 --> 00:18:35,010
temperatures on the board and there

00:18:32,040 --> 00:18:38,520
might also be microcontroller so another

00:18:35,010 --> 00:18:38,850
cpu inside the i/o chip down here that's

00:18:38,520 --> 00:18:43,620
the

00:18:38,850 --> 00:18:47,220
medical folder that I hope to to rent a

00:18:43,620 --> 00:18:49,230
bit about also oh yeah and there's the

00:18:47,220 --> 00:18:51,240
sm bus i mentioned in the previous

00:18:49,230 --> 00:18:54,620
presentation that Kevin had some issues

00:18:51,240 --> 00:18:57,270
waiting for the sm bus to stabilize

00:18:54,620 --> 00:18:59,640
welcome back to that when we're talking

00:18:57,270 --> 00:19:04,230
about Ram initialization because it's

00:18:59,640 --> 00:19:06,480
connected to to the ram so this is a

00:19:04,230 --> 00:19:08,570
look at how it might be and it can of

00:19:06,480 --> 00:19:11,550
course be even more complex you can have

00:19:08,570 --> 00:19:14,430
this might not be a single core cpu but

00:19:11,550 --> 00:19:18,360
it might be a 4 core cpu so you have 4

00:19:14,430 --> 00:19:20,400
cpu cores behind that one connected to

00:19:18,360 --> 00:19:23,550
one memory controller but connected also

00:19:20,400 --> 00:19:26,730
to all the other cpus and the app it can

00:19:23,550 --> 00:19:30,660
be pretty complicated so HT is hyper

00:19:26,730 --> 00:19:33,090
transport that's AMD's bus for

00:19:30,660 --> 00:19:37,770
interconnects or Amy's interconnect

00:19:33,090 --> 00:19:39,440
between CPUs and IO IO note in child

00:19:37,770 --> 00:19:44,120
develop their own it's both quick path

00:19:39,440 --> 00:19:47,060
interface i think the radiation the QPI

00:19:44,120 --> 00:19:50,550
does the same thing connection between

00:19:47,060 --> 00:19:54,720
many cpus in

00:19:50,550 --> 00:19:54,720
system has many CPUs

00:19:56,780 --> 00:20:07,730
so what about this I sub us the way I

00:20:01,490 --> 00:20:13,000
look back back when there is I oh and

00:20:07,730 --> 00:20:16,580
memory access in the x86 CPU there's an

00:20:13,000 --> 00:20:19,990
eight or 16 bits data communication path

00:20:16,580 --> 00:20:22,730
and depending on if you're doing io

00:20:19,990 --> 00:20:26,420
access or you're doing memory access the

00:20:22,730 --> 00:20:29,480
address space has a different size so

00:20:26,420 --> 00:20:33,500
for I oh there's it's always 16-bit so

00:20:29,480 --> 00:20:35,570
we have 64 K addresses these addresses

00:20:33,500 --> 00:20:38,000
they're usually called ports I'm not

00:20:35,570 --> 00:20:43,340
really sure why but it's that's if you

00:20:38,000 --> 00:20:47,180
see port somewhere it's about an i/o the

00:20:43,340 --> 00:20:51,770
CPU instructions used for for i/o is in

00:20:47,180 --> 00:20:55,390
be in w out be out w and the newer cpus

00:20:51,770 --> 00:20:58,010
you have the NL and i'll tell

00:20:55,390 --> 00:21:01,060
instructions also these also are

00:20:58,010 --> 00:21:04,460
available as function calls in in Linux

00:21:01,060 --> 00:21:07,040
you can do the wrecked io from from

00:21:04,460 --> 00:21:10,790
linux user space if you do some some

00:21:07,040 --> 00:21:12,860
preparations first I think my poor lamb

00:21:10,790 --> 00:21:15,110
who might talk about that also yeah and

00:21:12,860 --> 00:21:19,520
well that knows I am the lightning talk

00:21:15,110 --> 00:21:24,140
I guess for the port porting on the alto

00:21:19,520 --> 00:21:27,250
s room yes well anyway it's possible to

00:21:24,140 --> 00:21:29,390
do this direct this this i owe

00:21:27,250 --> 00:21:32,720
communication this io access is from

00:21:29,390 --> 00:21:34,670
linux and even if there's no I sub us in

00:21:32,720 --> 00:21:37,310
the system anymore it's still possible

00:21:34,670 --> 00:21:39,230
to do these operations and where are

00:21:37,310 --> 00:21:41,870
they going to end up well they will end

00:21:39,230 --> 00:21:43,940
up on LPC usually and there might be

00:21:41,870 --> 00:21:45,950
something listening they're typically

00:21:43,940 --> 00:21:50,300
the super i/o is what you want to talk

00:21:45,950 --> 00:21:52,250
to in that case if you are doing memory

00:21:50,300 --> 00:21:56,390
accesses then you have 20 bits of

00:21:52,250 --> 00:21:59,120
address and we'll have a look at how

00:21:56,390 --> 00:22:03,140
those 20 bit addresses are created in a

00:21:59,120 --> 00:22:05,800
bit an execution mode

00:22:03,140 --> 00:22:08,630
and the memory accesses their own use

00:22:05,800 --> 00:22:11,060
move instructions so it's just memory

00:22:08,630 --> 00:22:12,950
read and memory writes if you're

00:22:11,060 --> 00:22:16,640
programming in C you're reading from a

00:22:12,950 --> 00:22:19,070
variable types of memory memory read in

00:22:16,640 --> 00:22:21,410
the really early pieces that could that

00:22:19,070 --> 00:22:23,180
memory was external in the new pc the

00:22:21,410 --> 00:22:27,010
memory is actually connected to the CPU

00:22:23,180 --> 00:22:32,050
itself and of course has a lot longer

00:22:27,010 --> 00:22:32,050
address space than then 20 20 bits

00:22:33,220 --> 00:22:40,850
there's a whole bunch of of registers in

00:22:37,820 --> 00:22:43,850
all the hardware components that we

00:22:40,850 --> 00:22:48,200
looked at and in every ad on component

00:22:43,850 --> 00:22:51,040
that you can connect to a pc and these

00:22:48,200 --> 00:22:54,320
register accesses they will be either io

00:22:51,040 --> 00:22:57,220
or the registers they will be either vio

00:22:54,320 --> 00:23:00,140
mapped or they will be memorable on

00:22:57,220 --> 00:23:03,230
isohunt where it was kind of common on

00:23:00,140 --> 00:23:05,720
the really old for example really old

00:23:03,230 --> 00:23:07,310
networking parts you had a whole bunch

00:23:05,720 --> 00:23:12,290
of jumpers how many people remember

00:23:07,310 --> 00:23:14,450
those yeah you had to choose the base io

00:23:12,290 --> 00:23:15,890
portage is the interrupt and then you

00:23:14,450 --> 00:23:21,620
had to make sure they were no context

00:23:15,890 --> 00:23:23,570
and never work they invented this plug

00:23:21,620 --> 00:23:28,040
and play stuff which was supposed to be

00:23:23,570 --> 00:23:31,310
clever but I don't know it in theory it

00:23:28,040 --> 00:23:35,870
was good but I think the implementations

00:23:31,310 --> 00:23:37,610
weren't really that that awesome pci is

00:23:35,870 --> 00:23:41,540
very different there are no jumpers

00:23:37,610 --> 00:23:43,580
there's no conflicts the firmware

00:23:41,540 --> 00:23:46,190
handles all the configuration so Corps

00:23:43,580 --> 00:23:49,600
boot covers all the long printouts that

00:23:46,190 --> 00:23:52,580
we saw from the the first demo is

00:23:49,600 --> 00:23:54,560
checking all the PCI devices connected

00:23:52,580 --> 00:23:57,620
to the system and making sure that they

00:23:54,560 --> 00:24:01,610
can co-exist and

00:23:57,620 --> 00:24:03,559
be accessible at the same time PCI

00:24:01,610 --> 00:24:06,800
devices they have what's called

00:24:03,559 --> 00:24:12,700
configuration space 256 bytes of

00:24:06,800 --> 00:24:15,320
registers they are always reachable I

00:24:12,700 --> 00:24:17,540
think the standard says that it's not

00:24:15,320 --> 00:24:21,590
necessarily always but in practice it

00:24:17,540 --> 00:24:25,550
really is always they are reachable on

00:24:21,590 --> 00:24:29,540
aisle two ports cf8 hexadecimal and CFC

00:24:25,550 --> 00:24:33,200
this is an index data combination so you

00:24:29,540 --> 00:24:34,790
first write the address of the

00:24:33,200 --> 00:24:37,840
registered you want to access to CF

00:24:34,790 --> 00:24:42,830
eight and then you do the actual value

00:24:37,840 --> 00:24:44,540
axis on CFC so say you want to access no

00:24:42,830 --> 00:24:47,330
I'm not going to give you an example

00:24:44,540 --> 00:24:51,740
because you have to encode the PCI

00:24:47,330 --> 00:24:53,360
address and the pci device address and

00:24:51,740 --> 00:24:56,390
that something was called a function

00:24:53,360 --> 00:24:58,730
number and the register number into this

00:24:56,390 --> 00:25:02,500
access to CF eight and I can do that in

00:24:58,730 --> 00:25:06,559
my head so well we'll have to skip that

00:25:02,500 --> 00:25:09,440
that example but anyway first specify

00:25:06,559 --> 00:25:10,760
where you want to where you want what

00:25:09,440 --> 00:25:12,710
you want to access and then do the

00:25:10,760 --> 00:25:15,320
actual access on a different IR port

00:25:12,710 --> 00:25:17,660
this is this typically always available

00:25:15,320 --> 00:25:19,700
if the system has pci then this this is

00:25:17,660 --> 00:25:23,990
going to be there this is called the

00:25:19,700 --> 00:25:25,400
type one configuration interface and

00:25:23,990 --> 00:25:27,440
maybe you've seen that in the linux

00:25:25,400 --> 00:25:30,650
kernel sources you can choose what type

00:25:27,440 --> 00:25:32,990
of configuration access method that's

00:25:30,650 --> 00:25:34,790
going to be used this is also what for

00:25:32,990 --> 00:25:36,530
would uses core would use to support

00:25:34,790 --> 00:25:41,660
another access method but it was never

00:25:36,530 --> 00:25:44,120
used so we threw that out configuration

00:25:41,660 --> 00:25:47,210
space can also be reached via memory

00:25:44,120 --> 00:25:49,880
mapped registers and that's called mm

00:25:47,210 --> 00:25:52,910
config not every system supports it but

00:25:49,880 --> 00:25:56,510
if they do it's it's more convenient

00:25:52,910 --> 00:25:59,660
because you just access what could be a

00:25:56,510 --> 00:26:00,250
memory address that looks just like any

00:25:59,660 --> 00:26:02,620
other

00:26:00,250 --> 00:26:05,050
address in memory but there's no memory

00:26:02,620 --> 00:26:07,500
there is that you're reading and writing

00:26:05,050 --> 00:26:10,750
well there is memory but the memory is

00:26:07,500 --> 00:26:14,110
small registers on some pci device and

00:26:10,750 --> 00:26:17,350
it's not the the dim the main ram in the

00:26:14,110 --> 00:26:19,420
system so that's that's handy and it's

00:26:17,350 --> 00:26:23,800
also faster these io accesses tend to be

00:26:19,420 --> 00:26:27,670
pretty slow because there are so so old

00:26:23,800 --> 00:26:32,590
and legacy compatibility stuff on the

00:26:27,670 --> 00:26:35,980
bus the 16 first lights out of these 256

00:26:32,590 --> 00:26:38,560
are standardized by the pci pci standard

00:26:35,980 --> 00:26:40,980
so every single pci device is going to

00:26:38,560 --> 00:26:43,810
have the first 16 bytes exactly the same

00:26:40,980 --> 00:26:46,990
well not identical contents but

00:26:43,810 --> 00:26:49,360
identical structure and the first four

00:26:46,990 --> 00:26:51,490
bytes show the vendor and the device ID

00:26:49,360 --> 00:26:54,430
for example there's also information

00:26:51,490 --> 00:26:57,100
about which interrupts is going to be

00:26:54,430 --> 00:27:01,590
used for this device and a couple of

00:26:57,100 --> 00:27:05,530
other things interrupts bladder polarity

00:27:01,590 --> 00:27:07,720
detected errors on the communication on

00:27:05,530 --> 00:27:13,360
the PCI bus by this device if this

00:27:07,720 --> 00:27:16,810
device is a bus master and much a whole

00:27:13,360 --> 00:27:19,750
bunch of other settings as well and

00:27:16,810 --> 00:27:25,300
there are base address registers or bars

00:27:19,750 --> 00:27:28,990
of their call so maybe these 256 minus

00:27:25,300 --> 00:27:32,290
16 bytes these 240 points maybe that's

00:27:28,990 --> 00:27:34,000
not enough for for being able to for for

00:27:32,290 --> 00:27:37,930
doing everything that this pci device

00:27:34,000 --> 00:27:39,640
can do maybe you need a lot more if it's

00:27:37,930 --> 00:27:43,810
a graphics card for example you want to

00:27:39,640 --> 00:27:45,370
access to the graphics memory and 240

00:27:43,810 --> 00:27:48,580
bytes isn't really a lot of graphics

00:27:45,370 --> 00:27:50,980
memory today so you need some way to

00:27:48,580 --> 00:27:53,830
create a window into the graphics memory

00:27:50,980 --> 00:27:55,990
that is on the graphics card so then you

00:27:53,830 --> 00:27:58,630
will configure a bar or when the

00:27:55,990 --> 00:28:01,210
firmware will configure a bar a base

00:27:58,630 --> 00:28:04,800
address register saying to the pci

00:28:01,210 --> 00:28:07,510
device that when a pci when the pci bus

00:28:04,800 --> 00:28:11,160
sees an access to this particular

00:28:07,510 --> 00:28:15,390
address then that is meant for you

00:28:11,160 --> 00:28:18,750
so every every pci device looks at the

00:28:15,390 --> 00:28:22,380
traffic on the bus and only the one that

00:28:18,750 --> 00:28:24,450
has been configured to access accesses

00:28:22,380 --> 00:28:26,610
to this particular address is going to

00:28:24,450 --> 00:28:29,760
accept them and you kill them and

00:28:26,610 --> 00:28:33,390
process them so in case the firmware

00:28:29,760 --> 00:28:35,280
does a a half-assed job and sets up base

00:28:33,390 --> 00:28:36,600
address registers which conflict then

00:28:35,280 --> 00:28:40,050
you're going to have more than one

00:28:36,600 --> 00:28:41,370
device react to stuff going on on the

00:28:40,050 --> 00:28:45,630
pci bus and nothing is going to be

00:28:41,370 --> 00:28:48,570
working so in the example of a graphics

00:28:45,630 --> 00:28:51,480
card the base address register would set

00:28:48,570 --> 00:28:53,340
up a memory mapping because you want the

00:28:51,480 --> 00:28:56,430
graphics memory to be accessible as

00:28:53,340 --> 00:28:59,460
memory but base address registers can

00:28:56,430 --> 00:29:02,100
also be used for i/o mapping in that

00:28:59,460 --> 00:29:05,970
case you have some number of i/o ports

00:29:02,100 --> 00:29:10,380
that you want to end up on this

00:29:05,970 --> 00:29:13,980
particular pci device and then you you

00:29:10,380 --> 00:29:16,680
the firmware set a base address register

00:29:13,980 --> 00:29:20,430
in the same way which tells the pci

00:29:16,680 --> 00:29:22,590
device to decode axises io axis is to

00:29:20,430 --> 00:29:25,770
this particular report this is really

00:29:22,590 --> 00:29:31,140
common before for PCI devices to have

00:29:25,770 --> 00:29:34,580
one or both memory and i/o bars it could

00:29:31,140 --> 00:29:37,950
even be several I think in the 200 and

00:29:34,580 --> 00:29:40,470
sorry and the 16 by its 16 standard bias

00:29:37,950 --> 00:29:44,280
I think there's room for four base

00:29:40,470 --> 00:29:47,070
address registers I don't know now it

00:29:44,280 --> 00:29:50,040
was sorry it's in the full 256 it'sit's

00:29:47,070 --> 00:29:51,840
room for four or maybe even more base

00:29:50,040 --> 00:29:54,230
address registers so you can have one

00:29:51,840 --> 00:29:58,290
pci device that has several different

00:29:54,230 --> 00:30:03,299
memory regions or i/o regions that it's

00:29:58,290 --> 00:30:05,940
it's decoding there are also the amaz RS

00:30:03,299 --> 00:30:09,360
almost almost can see model-specific

00:30:05,940 --> 00:30:13,289
registers that's low level registers in

00:30:09,360 --> 00:30:18,090
the CPU itself in the North Bridge in

00:30:13,289 --> 00:30:22,820
the i/o controller stuff like that I'm

00:30:18,090 --> 00:30:22,820
going to come back to to some of those

00:30:23,539 --> 00:30:31,200
nvram I mentioned that it's also called

00:30:26,850 --> 00:30:33,679
CMOS I don't know if it I probably

00:30:31,200 --> 00:30:40,799
doesn't use CMOS technology in more but

00:30:33,679 --> 00:30:43,190
the name has has has stuck it's in its

00:30:40,799 --> 00:30:48,379
simplest form with the basic form it's

00:30:43,190 --> 00:30:51,239
128 bytes of the battery backed ram and

00:30:48,379 --> 00:30:54,269
it's stored in the real time clock chip

00:30:51,239 --> 00:30:56,730
and the real time clock chip in turn is

00:30:54,269 --> 00:30:59,159
usually part of another chip in a modern

00:30:56,730 --> 00:31:03,929
PC but in the original PC that was one

00:30:59,159 --> 00:31:05,909
motorola ship on its own now it's

00:31:03,929 --> 00:31:10,529
usually in the super I Oh or maybe in

00:31:05,909 --> 00:31:12,749
the chipset so these 100 100 0 bytes

00:31:10,529 --> 00:31:15,119
they survive power down you can have the

00:31:12,749 --> 00:31:17,429
system disconnected forever and or not

00:31:15,119 --> 00:31:20,330
forever but for a long time and the

00:31:17,429 --> 00:31:23,730
contents is still going to be the same

00:31:20,330 --> 00:31:25,619
also the clock keeps ticking of course

00:31:23,730 --> 00:31:29,249
when the system is shut down that

00:31:25,619 --> 00:31:33,119
happens there the standard way to access

00:31:29,249 --> 00:31:38,039
these registers is again one of these

00:31:33,119 --> 00:31:41,789
index index value io sequences you write

00:31:38,039 --> 00:31:45,119
the address you want to access to port

00:31:41,789 --> 00:31:48,450
70 and then you read or write 471

00:31:45,119 --> 00:31:51,629
hexadecimal to to read or write that

00:31:48,450 --> 00:31:53,940
value and this is where all the bios

00:31:51,629 --> 00:31:58,350
settings are stored typically and this

00:31:53,940 --> 00:32:00,509
is also what mb ram tool mrs. with so

00:31:58,350 --> 00:32:02,179
you give it the layout file of which

00:32:00,509 --> 00:32:04,730
bits are or which

00:32:02,179 --> 00:32:07,669
and it will do all the translation and

00:32:04,730 --> 00:32:13,159
make sure you don't overwrite any wrong

00:32:07,669 --> 00:32:16,820
bits and accesses the supports 70 and 71

00:32:13,159 --> 00:32:19,460
and if it works out well there was 0

00:32:16,820 --> 00:32:22,490
extended registers another 128 bytes and

00:32:19,460 --> 00:32:24,590
there can also be another 256 bytes in

00:32:22,490 --> 00:32:30,440
other places but that work just the same

00:32:24,590 --> 00:32:31,850
way ports 72 and 73 are really common if

00:32:30,440 --> 00:32:34,279
you want to have a look at the driver

00:32:31,850 --> 00:32:38,360
for this in Linux its rivals car and we

00:32:34,279 --> 00:32:40,220
rounded see and somewhere in arc x86

00:32:38,360 --> 00:32:43,220
they're the couple of macros which

00:32:40,220 --> 00:32:45,409
translate to the out out be and in B

00:32:43,220 --> 00:32:52,840
which will do the actual actual port

00:32:45,409 --> 00:32:52,840
axises interrupts

00:32:53,220 --> 00:33:00,270
how many recognize this picture all

00:32:57,030 --> 00:33:08,760
right excellent about eight nine ten or

00:33:00,270 --> 00:33:12,539
so so this is a the legacy legacy picked

00:33:08,760 --> 00:33:15,679
programmable interrupt controller the

00:33:12,539 --> 00:33:20,010
way interrupts works in the beginning

00:33:15,679 --> 00:33:23,940
synchronous CPU systems I guess all the

00:33:20,010 --> 00:33:27,690
way back to 8088 the original PC there

00:33:23,940 --> 00:33:31,500
were 15 usable interrupt signals

00:33:27,690 --> 00:33:33,120
interrupt inputs to these two interrupt

00:33:31,500 --> 00:33:38,100
controllers that are connected together

00:33:33,120 --> 00:33:41,280
and the chain of events is as described

00:33:38,100 --> 00:33:43,230
here a device each well typically each

00:33:41,280 --> 00:33:47,669
device would one device will connect to

00:33:43,230 --> 00:33:49,919
each of these inputs 0 through 15 the

00:33:47,669 --> 00:33:51,419
device wants attention from the cpu

00:33:49,919 --> 00:33:55,740
because something has happened maybe

00:33:51,419 --> 00:33:58,559
there's a bite coming in from the modem

00:33:55,740 --> 00:34:01,950
or from the keyboard or maybe it's

00:33:58,559 --> 00:34:05,190
possible now to send a bite out to the

00:34:01,950 --> 00:34:08,070
modem or to the keyboard or wherever the

00:34:05,190 --> 00:34:12,480
network card for that matter so the

00:34:08,070 --> 00:34:16,619
device signals an interrupt pulls one of

00:34:12,480 --> 00:34:19,830
these this spring's the cliq notice is

00:34:16,619 --> 00:34:23,280
this the interrupt controller and it's

00:34:19,830 --> 00:34:25,379
well if it's one of these these hi wats

00:34:23,280 --> 00:34:29,129
it's going to trickle through to the

00:34:25,379 --> 00:34:31,470
master and the only the only

00:34:29,129 --> 00:34:40,160
interrupting although into the cpu is

00:34:31,470 --> 00:34:44,130
the actual in that one

00:34:40,160 --> 00:34:46,760
yeah so the one interrupt signal from

00:34:44,130 --> 00:34:50,130
the master pic is on that is going to

00:34:46,760 --> 00:34:54,210
the CPU only accept one single interrupt

00:34:50,130 --> 00:34:56,910
signal but what about all these devices

00:34:54,210 --> 00:34:58,350
how does that work out well so when

00:34:56,910 --> 00:35:00,630
there's an interrupt the CPU will

00:34:58,350 --> 00:35:05,610
acknowledge that it received this

00:35:00,630 --> 00:35:10,080
interrupt signal by pulling on the disks

00:35:05,610 --> 00:35:13,650
in a signal to the interrupt controller

00:35:10,080 --> 00:35:16,500
and then it's going to wiggle the

00:35:13,650 --> 00:35:20,310
interrupt acknowledge signal a little

00:35:16,500 --> 00:35:24,770
bit more which causes then the program

00:35:20,310 --> 00:35:29,610
has racked up over to write an address

00:35:24,770 --> 00:35:37,650
for the interrupt handler or the

00:35:29,610 --> 00:35:39,900
interrupts vector to the data bus so the

00:35:37,650 --> 00:35:43,980
CPU says okay I got the interrupt the

00:35:39,900 --> 00:35:46,040
CPU says okay what should I do now the

00:35:43,980 --> 00:35:49,010
interrupt controller has been programmed

00:35:46,040 --> 00:35:51,660
hence programmable interrupt controller

00:35:49,010 --> 00:35:54,540
has been programmed to know that

00:35:51,660 --> 00:35:56,490
interrupt this and that should be

00:35:54,540 --> 00:35:59,190
handled by code running at this

00:35:56,490 --> 00:36:01,260
particular address in memory so this

00:35:59,190 --> 00:36:02,280
accuses okay what should I do now the

00:36:01,260 --> 00:36:04,860
programmable interrupt controller

00:36:02,280 --> 00:36:06,900
replies you should go to this address in

00:36:04,860 --> 00:36:10,110
memory where they interrupt handler

00:36:06,900 --> 00:36:13,230
lives so it writes that out to the data

00:36:10,110 --> 00:36:17,400
bus the CPU reads the address and jumps

00:36:13,230 --> 00:36:22,099
to the address and there's an interrupt

00:36:17,400 --> 00:36:25,940
handler running in this abuse

00:36:22,099 --> 00:36:28,369
so there was was this was with just one

00:36:25,940 --> 00:36:32,150
cpu then there's only one interrupt

00:36:28,369 --> 00:36:36,140
signal even though we can have many

00:36:32,150 --> 00:36:37,819
interrupt sources and yeah hopefully

00:36:36,140 --> 00:36:40,220
this explains all the interrupt problems

00:36:37,819 --> 00:36:42,920
that were with all these Accords little

00:36:40,220 --> 00:36:47,079
bit okay what about when there are

00:36:42,920 --> 00:36:50,269
multiple CPUs then it gets fun again

00:36:47,079 --> 00:36:52,989
there's always one bootstrap processor

00:36:50,269 --> 00:36:55,220
that's the the first processor that

00:36:52,989 --> 00:36:57,410
comes up running when the system is

00:36:55,220 --> 00:37:00,049
starting that is all arranged in

00:36:57,410 --> 00:37:02,390
hardware which which processor will be

00:37:00,049 --> 00:37:04,670
running when the power comes on then any

00:37:02,390 --> 00:37:07,640
any other cpus are going to be

00:37:04,670 --> 00:37:09,739
application processors so there's always

00:37:07,640 --> 00:37:13,970
only one running in the beginning and it

00:37:09,739 --> 00:37:16,069
has to well actually that's not true

00:37:13,970 --> 00:37:18,319
that depends on if it's aimed irritant

00:37:16,069 --> 00:37:20,329
and I think one of them everyone comes

00:37:18,319 --> 00:37:23,299
out running and they have to agree to

00:37:20,329 --> 00:37:24,829
stop if they're not the BSP but there

00:37:23,299 --> 00:37:26,809
has already been a decision made in

00:37:24,829 --> 00:37:29,329
hardware so that there's only one which

00:37:26,809 --> 00:37:31,309
is designated to be SP and it should

00:37:29,329 --> 00:37:34,339
check if it's the BSP and the other one

00:37:31,309 --> 00:37:38,869
should stop and the bees p will continue

00:37:34,339 --> 00:37:42,200
anyway inside of these cpus there's a

00:37:38,869 --> 00:37:45,910
local a pic so ap is I guess advanced

00:37:42,200 --> 00:37:49,339
programmable interrupt controller and

00:37:45,910 --> 00:37:51,859
the eight picks the local ethics there's

00:37:49,339 --> 00:37:53,930
one in each CPU and then they

00:37:51,859 --> 00:37:56,180
communicate with each other but this

00:37:53,930 --> 00:37:59,210
this for example hypertransport or it

00:37:56,180 --> 00:38:02,690
could be some front side bus tour for

00:37:59,210 --> 00:38:06,380
such system bus whatever they also

00:38:02,690 --> 00:38:10,039
connect with this I owe a pic which is

00:38:06,380 --> 00:38:12,859
the one dealing with them well this

00:38:10,039 --> 00:38:15,019
looks familiar this is the the same the

00:38:12,859 --> 00:38:17,420
legacy pic arrangement which is still

00:38:15,019 --> 00:38:22,160
there even if you have an a pic it might

00:38:17,420 --> 00:38:24,090
not be used it is it if you so then a

00:38:22,160 --> 00:38:26,790
pic situation it needs

00:38:24,090 --> 00:38:29,040
be configured before it's being used and

00:38:26,790 --> 00:38:31,770
if it's not configured then the system

00:38:29,040 --> 00:38:36,840
is still going to be using this legacy

00:38:31,770 --> 00:38:43,760
pick set up but if you configure the

00:38:36,840 --> 00:38:46,050
full on a fake situation then you get

00:38:43,760 --> 00:38:48,390
the local epics talking to each other

00:38:46,050 --> 00:38:50,220
and stop the IO epic and you can do

00:38:48,390 --> 00:38:52,590
really flexible mapping of all the

00:38:50,220 --> 00:38:54,990
interrupts coming into the IOA epic and

00:38:52,590 --> 00:38:57,770
all of the drugs that can be generated

00:38:54,990 --> 00:39:00,510
by the local ethics also because these

00:38:57,770 --> 00:39:02,670
by the time we have multiple cpus the

00:39:00,510 --> 00:39:04,590
cpus also have a lot of more

00:39:02,670 --> 00:39:08,780
functionality included that maybe the

00:39:04,590 --> 00:39:08,780
older ones did so for example we have

00:39:08,960 --> 00:39:15,450
dimension already machine check

00:39:11,160 --> 00:39:19,200
exceptions mces if if the cpu detects

00:39:15,450 --> 00:39:22,680
that it has broken it can trigger an a

00:39:19,200 --> 00:39:25,020
pic interrupt and that can call into an

00:39:22,680 --> 00:39:27,120
interrupt vector somewhere so the

00:39:25,020 --> 00:39:30,090
interrupt vectoring part is still the

00:39:27,120 --> 00:39:33,000
same the local epic will make sure that

00:39:30,090 --> 00:39:35,700
the cpu runs those often run some

00:39:33,000 --> 00:39:38,400
configured interrupt handler the

00:39:35,700 --> 00:39:40,590
difference is that the difference from

00:39:38,400 --> 00:39:42,930
the legacy big situation is that well

00:39:40,590 --> 00:39:45,330
first of all the IO IO stuff which is

00:39:42,930 --> 00:39:47,730
connected to all the peripherals and pci

00:39:45,330 --> 00:39:50,880
bus down here that's that's separated

00:39:47,730 --> 00:39:53,910
out and the local ethics they also they

00:39:50,880 --> 00:39:57,270
have support for I think 256 interrupt

00:39:53,910 --> 00:39:59,370
sources instead of the 15 so there's

00:39:57,270 --> 00:40:03,030
there's plenty of interrupt signals

00:39:59,370 --> 00:40:04,980
available they can come from interrupts

00:40:03,030 --> 00:40:07,440
can come from as i mentioned from within

00:40:04,980 --> 00:40:10,530
the epic itself from within the CPU

00:40:07,440 --> 00:40:17,180
itself they pick has also a timer which

00:40:10,530 --> 00:40:17,180
can generate interrupts and yes

00:40:20,680 --> 00:40:29,200
and of course the AP enabled there it

00:40:23,380 --> 00:40:30,819
has to be enabled as I mentioned well

00:40:29,200 --> 00:40:33,760
here's also the system management

00:40:30,819 --> 00:40:40,200
interrupt signal which goes into the CPU

00:40:33,760 --> 00:40:40,200
and not a pic in this wrong

00:40:41,460 --> 00:40:46,430
so a lot more complicated but basically

00:40:43,700 --> 00:40:49,140
still the same principle you have

00:40:46,430 --> 00:40:52,380
programmed the pic the interrupt

00:40:49,140 --> 00:40:55,020
controller too with all the drug vectors

00:40:52,380 --> 00:40:57,480
and when the interrupts happens it will

00:40:55,020 --> 00:40:59,310
send the CPU to run the code that it

00:40:57,480 --> 00:41:00,869
should but there are a lot of

00:40:59,310 --> 00:41:02,640
possibilities with many different

00:41:00,869 --> 00:41:08,280
interrupts here I think Rudolph will

00:41:02,640 --> 00:41:09,960
also come back to this for RAM

00:41:08,280 --> 00:41:15,270
initialization how are we doing more

00:41:09,960 --> 00:41:20,670
time ok for RAM initialization what do

00:41:15,270 --> 00:41:23,580
we have to do there well the our goal in

00:41:20,670 --> 00:41:26,970
RAM initialization is to configure this

00:41:23,580 --> 00:41:29,250
this thick red connection over here it

00:41:26,970 --> 00:41:32,460
could be ddr2 it could be DD or it could

00:41:29,250 --> 00:41:39,900
be ddr3 in any case it's it's a lot of

00:41:32,460 --> 00:41:42,630
work we need to know we need to know

00:41:39,900 --> 00:41:45,270
exactly what kind of RAM is is connected

00:41:42,630 --> 00:41:50,040
here upon on this item the same for all

00:41:45,270 --> 00:41:53,970
of the CPUs and or memory controllers

00:41:50,040 --> 00:41:55,530
which have ram connected and well since

00:41:53,970 --> 00:41:59,040
this communication link isn't working

00:41:55,530 --> 00:42:02,970
what do we do we don't have to use this

00:41:59,040 --> 00:42:04,589
sm bus so from the cpu we're doing

00:42:02,970 --> 00:42:06,900
memory configuration we go through the

00:42:04,589 --> 00:42:10,170
North Korean southbridge out one to the

00:42:06,900 --> 00:42:12,780
SL bus and follow this ring line and

00:42:10,170 --> 00:42:18,450
talk to this this little green guy which

00:42:12,780 --> 00:42:21,089
is an e square prom on each dim it's a

00:42:18,450 --> 00:42:24,300
small serial eeprom it stores a couple

00:42:21,089 --> 00:42:29,040
of parameters what sizes of this memory

00:42:24,300 --> 00:42:31,320
but how fast is it is it registered is

00:42:29,040 --> 00:42:33,720
it not registered etc etc all the

00:42:31,320 --> 00:42:35,940
parameters that timings supported by

00:42:33,720 --> 00:42:37,680
this memory module of the stuff that is

00:42:35,940 --> 00:42:41,220
needed to configure the memory

00:42:37,680 --> 00:42:42,960
controller correctly and I'm not going

00:42:41,220 --> 00:42:44,750
to go into great detail with a memory

00:42:42,960 --> 00:42:49,100
controller configuration

00:42:44,750 --> 00:42:53,450
it's so complicated but I'm going to say

00:42:49,100 --> 00:42:57,410
that ddr2 at least it requires some

00:42:53,450 --> 00:43:01,430
brute force searching for finding the

00:42:57,410 --> 00:43:02,990
correct the tuning of the time in

00:43:01,430 --> 00:43:06,110
between the memory controller and the

00:43:02,990 --> 00:43:08,870
actual in so the farmer has to search

00:43:06,110 --> 00:43:11,450
through all possible settings or many

00:43:08,870 --> 00:43:13,370
possible settings for the tuning

00:43:11,450 --> 00:43:16,310
parameters in order to find the one that

00:43:13,370 --> 00:43:18,560
is working really well and worst case

00:43:16,310 --> 00:43:20,570
that that parameter could actually

00:43:18,560 --> 00:43:22,790
change with the temperature in the room

00:43:20,570 --> 00:43:24,800
depending on how the board is is laid

00:43:22,790 --> 00:43:29,410
out of the traces on the other the main

00:43:24,800 --> 00:43:29,410
work so it's a longer

00:43:36,440 --> 00:43:45,180
cassius ram is is used in coreboot this

00:43:40,890 --> 00:43:47,309
Ram initialization stuff so when the RAM

00:43:45,180 --> 00:43:50,520
initialization is running there is no

00:43:47,309 --> 00:43:53,730
Ram available right that means it's not

00:43:50,520 --> 00:43:56,160
possible to run seat code because C

00:43:53,730 --> 00:43:59,190
compilers they assume that there is

00:43:56,160 --> 00:44:02,520
random available and RAM is used for the

00:43:59,190 --> 00:44:06,779
stack which is used to call functions so

00:44:02,520 --> 00:44:10,680
we can't use cheat code when we're doing

00:44:06,779 --> 00:44:14,069
this Ram initialization and back when

00:44:10,680 --> 00:44:16,380
memory technology were was was simpler

00:44:14,069 --> 00:44:18,480
or the memory buses were simpler it was

00:44:16,380 --> 00:44:20,910
kind of okay to do i guess the memory

00:44:18,480 --> 00:44:22,680
initialization the RAM initialization in

00:44:20,910 --> 00:44:24,690
assembly we could do it in assembly

00:44:22,680 --> 00:44:28,410
language and it it wasn't all that bad

00:44:24,690 --> 00:44:30,270
it wasn't too long it it was ok but with

00:44:28,410 --> 00:44:33,029
this for example with this brute force

00:44:30,270 --> 00:44:35,220
search stuff that is in ddr2 and which I

00:44:33,029 --> 00:44:37,950
can only assume is even more complex in

00:44:35,220 --> 00:44:42,000
ddr3 it's really not something that we

00:44:37,950 --> 00:44:47,400
want to do in assembly anymore so one

00:44:42,000 --> 00:44:52,470
way around it is to use caches ram which

00:44:47,400 --> 00:44:56,130
means that part of the CPU cache is used

00:44:52,470 --> 00:44:58,740
as memory and in fact it is memory it's

00:44:56,130 --> 00:45:02,099
really fast memory but normally it isn't

00:44:58,740 --> 00:45:04,680
addressable but it's there's a way it's

00:45:02,099 --> 00:45:07,020
documented by Intel evil you just it

00:45:04,680 --> 00:45:10,520
doesn't exactly they doesn't they don't

00:45:07,020 --> 00:45:15,299
exactly describe why you would do it or

00:45:10,520 --> 00:45:17,970
I guess well they say how you do it but

00:45:15,299 --> 00:45:19,319
not exactly that the result is caches

00:45:17,970 --> 00:45:20,730
around and let you can run stuff without

00:45:19,319 --> 00:45:22,980
having RAM you have to read this one

00:45:20,730 --> 00:45:24,720
between the lines of it but the

00:45:22,980 --> 00:45:27,119
information is there you set up packing

00:45:24,720 --> 00:45:28,740
and then you make sure that you load all

00:45:27,119 --> 00:45:31,619
the code that you want to run into the

00:45:28,740 --> 00:45:34,140
cache and then you make sure that you

00:45:31,619 --> 00:45:36,359
don't run anything else and that you

00:45:34,140 --> 00:45:39,599
don't access any code outside that and

00:45:36,359 --> 00:45:44,819
if you do as it's possible to to have C

00:45:39,599 --> 00:45:45,930
code running without any ram acting so

00:45:44,819 --> 00:45:49,470
that's

00:45:45,930 --> 00:45:53,700
used parkour boots for many mainboards

00:45:49,470 --> 00:45:55,890
but not for all yet our ambition is to

00:45:53,700 --> 00:45:58,740
have to have this for every main board

00:45:55,890 --> 00:46:01,950
we have the caches ramp support for a

00:45:58,740 --> 00:46:05,040
lot of different CPUs and platforms for

00:46:01,950 --> 00:46:07,829
amd64 and Forgione LX and I think also

00:46:05,040 --> 00:46:10,470
for the vsc 7 but all the boards aren't

00:46:07,829 --> 00:46:13,109
really using it yet it can be tricky to

00:46:10,470 --> 00:46:14,790
do this in a general manner we want we

00:46:13,109 --> 00:46:17,369
want to catch this Ram support for for

00:46:14,790 --> 00:46:19,700
everything of course but different

00:46:17,369 --> 00:46:23,670
platforms different systems they have

00:46:19,700 --> 00:46:25,829
restrictions on how big areas you can

00:46:23,670 --> 00:46:29,280
use for caches ramp and where they need

00:46:25,829 --> 00:46:33,349
to live in which addresses you can use

00:46:29,280 --> 00:46:38,569
for this so it's it's not really easy to

00:46:33,349 --> 00:46:38,569
to do this casual surround setup always

00:46:40,700 --> 00:46:47,369
another option so that's that's GCC if

00:46:45,660 --> 00:46:49,619
you have caches around you can use GCC

00:46:47,369 --> 00:46:55,290
compiled code Jesus es usted there's

00:46:49,619 --> 00:46:58,770
memory but before we we started using

00:46:55,290 --> 00:47:04,650
caches Ram we we had another thing

00:46:58,770 --> 00:47:07,349
another solution rom CC was was created

00:47:04,650 --> 00:47:10,319
by one of the core boots developers it's

00:47:07,349 --> 00:47:13,049
a Z compiler custom custom made one big

00:47:10,319 --> 00:47:17,000
source file it's really not generates

00:47:13,049 --> 00:47:22,440
machine code which doesn't need any ram

00:47:17,000 --> 00:47:23,760
it cannot of course the x86 is is sort

00:47:22,440 --> 00:47:26,490
of limited when it comes to the number

00:47:23,760 --> 00:47:28,980
of registers it has so the c code cannot

00:47:26,490 --> 00:47:33,630
be infinitely complex because every

00:47:28,980 --> 00:47:37,410
every time you call a function this e

00:47:33,630 --> 00:47:39,180
compiler has to reserve one register so

00:47:37,410 --> 00:47:42,000
eventually you run out of registers and

00:47:39,180 --> 00:47:42,779
then the compiler River will complain

00:47:42,000 --> 00:47:44,579
and

00:47:42,779 --> 00:47:46,619
is not going to be able to compile the

00:47:44,579 --> 00:47:49,619
source code you have but if you have

00:47:46,619 --> 00:47:53,699
simple simple source code and if you if

00:47:49,619 --> 00:47:56,479
you write it in a in a certain way in

00:47:53,699 --> 00:47:59,459
lines for example can can help then

00:47:56,479 --> 00:48:01,229
roxas ii does does a fairly good job

00:47:59,459 --> 00:48:04,259
there has been a couple of marks in

00:48:01,229 --> 00:48:06,779
there which have been a bit difficult to

00:48:04,259 --> 00:48:09,449
track down but i think the wrong chassis

00:48:06,779 --> 00:48:15,509
code base is this is pretty good quite

00:48:09,449 --> 00:48:19,229
on question how can the grumps is you

00:48:15,509 --> 00:48:25,469
combine those in any there's going to be

00:48:19,229 --> 00:48:29,130
not that much he bathe in kennel so the

00:48:25,469 --> 00:48:32,369
question is how does rom CC know at

00:48:29,130 --> 00:48:35,429
compile time when it runs out of storage

00:48:32,369 --> 00:48:39,659
anything yes well it has a model of the

00:48:35,429 --> 00:48:42,919
CPU that is going to run on and it's at

00:48:39,659 --> 00:48:46,469
compile time its fills up that modeled

00:48:42,919 --> 00:48:48,179
it fills up the registers and eventually

00:48:46,469 --> 00:48:50,130
if it runs out of registers and it's

00:48:48,179 --> 00:48:54,299
it's impossible for the compiler to

00:48:50,130 --> 00:48:57,119
store the previous location then then

00:48:54,299 --> 00:49:00,029
it's going to fail then you can't do

00:48:57,119 --> 00:49:02,999
that function hall at at I guess level

00:49:00,029 --> 00:49:05,549
eight or nine the combined knows about

00:49:02,999 --> 00:49:06,940
this yes he probably doesn't know of is

00:49:05,549 --> 00:49:10,569
that what if I'm

00:49:06,940 --> 00:49:13,300
further the command surely knows about

00:49:10,569 --> 00:49:16,839
the CPU and the dance and we can think

00:49:13,300 --> 00:49:20,290
of it as we cannot know about some by

00:49:16,839 --> 00:49:31,900
creating artificial calls in artificial

00:49:20,290 --> 00:49:35,520
calls no dynamic falls I think function

00:49:31,900 --> 00:49:38,710
pointers are not support the African

00:49:35,520 --> 00:49:41,500
well it could be supported as long as

00:49:38,710 --> 00:49:45,910
there's a register free but then you

00:49:41,500 --> 00:49:48,640
have anything on your own well it would

00:49:45,910 --> 00:49:51,630
be it would it would require one extra

00:49:48,640 --> 00:49:53,770
register i guess for saving the return

00:49:51,630 --> 00:49:57,280
or saving the function pointers

00:49:53,770 --> 00:49:59,500
somewhere I think these are fine yep

00:49:57,280 --> 00:50:02,980
yeah okay sure well another explanation

00:49:59,500 --> 00:50:09,490
for this and every function hall is in

00:50:02,980 --> 00:50:13,109
life no CC so if there is partial which

00:50:09,490 --> 00:50:19,359
calls itself a rock CC will

00:50:13,109 --> 00:50:23,530
naturally so recursion or something like

00:50:19,359 --> 00:50:26,710
that faction wanders forget to count and

00:50:23,530 --> 00:50:37,270
do it in a fully lined assembly goat

00:50:26,710 --> 00:50:41,050
with no balls at all that's okay right

00:50:37,270 --> 00:50:46,450
now to unload Yeah right it unrolls the

00:50:41,050 --> 00:50:48,310
source code completely right I think it

00:50:46,450 --> 00:50:50,910
should be possible to implement function

00:50:48,310 --> 00:50:58,180
pointer stuff but it might not be in the

00:50:50,910 --> 00:51:00,430
variance okay all right still roam CC is

00:50:58,180 --> 00:51:03,550
is even though you're moving away from

00:51:00,430 --> 00:51:05,710
Rome CC coat it's I think it's still

00:51:03,550 --> 00:51:07,720
useful for example serialize I believe

00:51:05,710 --> 00:51:12,450
is that the rom shell for sale realize

00:51:07,720 --> 00:51:16,359
is compared with Roxy see and it's it's

00:51:12,450 --> 00:51:22,780
really an amazing effort that went into

00:51:16,359 --> 00:51:25,300
it execution modes in the x86 there's

00:51:22,780 --> 00:51:29,109
the the go down real mode the classic

00:51:25,300 --> 00:51:33,339
execution mode that every modern CPU

00:51:29,109 --> 00:51:36,280
still starts up in you have a bunch of

00:51:33,339 --> 00:51:38,380
16-bit registers the ones up there I

00:51:36,280 --> 00:51:43,810
hope I don't throw up I didn't forget

00:51:38,380 --> 00:51:48,540
one the first four or segment registers

00:51:43,810 --> 00:51:51,040
and the rest are they have sort of

00:51:48,540 --> 00:51:54,280
intended purposes but you can mix and

00:51:51,040 --> 00:51:58,300
match almost breathing not quite but you

00:51:54,280 --> 00:52:02,050
can make some much of it and every every

00:51:58,300 --> 00:52:05,800
memory address as I said in real mode is

00:52:02,050 --> 00:52:12,010
20 bits so two of these 16-bit registers

00:52:05,800 --> 00:52:14,170
need to be combined and I've always seen

00:52:12,010 --> 00:52:16,960
that being called segmented addressing

00:52:14,170 --> 00:52:19,700
and it's written in the form segment

00:52:16,960 --> 00:52:21,680
register colon offset register

00:52:19,700 --> 00:52:24,859
they're both 16 bits and the address

00:52:21,680 --> 00:52:29,839
ends up being the segment register

00:52:24,859 --> 00:52:32,599
shifted left by 4 or x 16 and then add

00:52:29,839 --> 00:52:38,780
on the offset register so for an example

00:52:32,599 --> 00:52:43,510
if d s equals f 000 hexadecimal and s i

00:52:38,780 --> 00:52:46,940
equals 6000 hexadecimal then the dss I

00:52:43,510 --> 00:52:53,839
segmented address would be a physical

00:52:46,940 --> 00:52:57,619
address of F 6000 so yeah that way you

00:52:53,839 --> 00:53:04,670
can reach a full megabyte of address

00:52:57,619 --> 00:53:07,970
space then and this was in 8086 8088 186

00:53:04,670 --> 00:53:09,950
and 286 and then another 386 there was

00:53:07,970 --> 00:53:11,750
the protected mode actually there was

00:53:09,950 --> 00:53:13,460
one protected mode in the 286 as well

00:53:11,750 --> 00:53:16,820
but it was so so different that I'm not

00:53:13,460 --> 00:53:21,920
going to bother I don't remember even

00:53:16,820 --> 00:53:24,349
all the details but the protected mode

00:53:21,920 --> 00:53:27,800
as we know it and usually call it is the

00:53:24,349 --> 00:53:33,079
one that came in 386 it has a concept of

00:53:27,800 --> 00:53:36,950
privilege levels where you can specify

00:53:33,079 --> 00:53:39,440
that some some parts of boat is allowed

00:53:36,950 --> 00:53:43,460
to do something and and not some other

00:53:39,440 --> 00:53:45,140
things and this is also this is of

00:53:43,460 --> 00:53:47,020
course but every modern operating system

00:53:45,140 --> 00:53:50,210
relies on in order to do security

00:53:47,020 --> 00:53:55,220
properly otherwise you would be able to

00:53:50,210 --> 00:53:57,980
do anything even as a user in Linux for

00:53:55,220 --> 00:54:00,230
example books only the root user is is

00:53:57,980 --> 00:54:03,200
really allowed or the colonel is really

00:54:00,230 --> 00:54:07,579
allowed to do to do anything in the

00:54:03,200 --> 00:54:09,680
system when one of these privileges

00:54:07,579 --> 00:54:11,000
directions or when you're trying to do

00:54:09,680 --> 00:54:13,220
if you're trying to do something that

00:54:11,000 --> 00:54:17,680
they're not allowed to do then the 386

00:54:13,220 --> 00:54:21,440
or protected mode CPU is despaired to is

00:54:17,680 --> 00:54:23,660
going to throw an exception and this can

00:54:21,440 --> 00:54:26,930
be handled by an interrupt handler and

00:54:23,660 --> 00:54:28,970
then all the big stuff comes comes into

00:54:26,930 --> 00:54:30,570
play and you end up running some other

00:54:28,970 --> 00:54:34,860
piece of software which can

00:54:30,570 --> 00:54:36,780
sort of detect what happened and then it

00:54:34,860 --> 00:54:38,850
goes all the way back and tells the user

00:54:36,780 --> 00:54:42,870
that oops you did something that you're

00:54:38,850 --> 00:54:45,810
not supposed to do instead of crashing

00:54:42,870 --> 00:54:48,800
or whatever also included in the

00:54:45,810 --> 00:54:52,830
protective mode is paging this is a

00:54:48,800 --> 00:54:56,040
reference table or a lookup table for

00:54:52,830 --> 00:54:59,370
addresses so you're using an address but

00:54:56,040 --> 00:55:01,290
it's not like up here if you say you

00:54:59,370 --> 00:55:04,070
want this address it might actually be a

00:55:01,290 --> 00:55:07,020
completely different address so there's

00:55:04,070 --> 00:55:08,940
there's a translation layer in between

00:55:07,020 --> 00:55:11,370
the address you're using the virtual

00:55:08,940 --> 00:55:17,220
address and the address that I actually

00:55:11,370 --> 00:55:19,860
seen on the bus the physical address the

00:55:17,220 --> 00:55:21,480
protected or the well protected mode not

00:55:19,860 --> 00:55:24,770
actually protected mode this is more

00:55:21,480 --> 00:55:28,890
than 386 the 386 added 32-bit registers

00:55:24,770 --> 00:55:34,260
so they're the versions of all the ones

00:55:28,890 --> 00:55:38,520
from ax out to HP that are 32-bit the

00:55:34,260 --> 00:55:40,500
lower 16-bit are the same and some of

00:55:38,520 --> 00:55:45,090
those can be divided into 83 this review

00:55:40,500 --> 00:55:48,240
and then the set segment registers

00:55:45,090 --> 00:55:51,570
they've changed into what is called

00:55:48,240 --> 00:55:54,450
selectors it's the same register name

00:55:51,570 --> 00:55:59,780
just has a different function in

00:55:54,450 --> 00:55:59,780
protecting out the selector will look a

00:56:00,380 --> 00:56:07,470
look up a data structure which has

00:56:03,660 --> 00:56:14,370
information about paging and privileged

00:56:07,470 --> 00:56:16,610
instructions and also base and limit so

00:56:14,370 --> 00:56:19,320
this is all part of the translation

00:56:16,610 --> 00:56:21,810
depending on what you put in in CS if

00:56:19,320 --> 00:56:23,490
you say put for example 0 then you're

00:56:21,810 --> 00:56:25,750
going to get the first entry in this

00:56:23,490 --> 00:56:29,170
lookup table of selectors or

00:56:25,750 --> 00:56:31,930
descriptors and that means if you

00:56:29,170 --> 00:56:34,300
address if you access address zero it's

00:56:31,930 --> 00:56:36,430
actually going to be somewhere somewhere

00:56:34,300 --> 00:56:38,920
completely different but if you then

00:56:36,430 --> 00:56:41,970
change CS to be eight in step and you

00:56:38,920 --> 00:56:44,290
move one step forward in this table the

00:56:41,970 --> 00:56:47,680
global descriptor table or the local

00:56:44,290 --> 00:56:51,870
descriptor table as they're called and

00:56:47,680 --> 00:56:54,690
then you mean if you're accessing zero

00:56:51,870 --> 00:56:58,360
it gets a completely different meaning

00:56:54,690 --> 00:57:04,300
the limit specifies how big memory block

00:56:58,360 --> 00:57:07,210
you can access starting from from the

00:57:04,300 --> 00:57:09,520
base address so system management mode I

00:57:07,210 --> 00:57:13,570
mentioned it's triggered by system

00:57:09,520 --> 00:57:14,920
management interrupt when the processor

00:57:13,570 --> 00:57:17,290
enters system management mode it's

00:57:14,920 --> 00:57:18,580
always running a real mode but it's free

00:57:17,290 --> 00:57:20,980
to switch to protect the milled if it

00:57:18,580 --> 00:57:22,870
wants to interrupts are almost disabled

00:57:20,980 --> 00:57:24,730
and the debug traps are always disabled

00:57:22,870 --> 00:57:27,010
so when you're running in in system

00:57:24,730 --> 00:57:29,770
management mode you're really you're

00:57:27,010 --> 00:57:32,860
really isolated it's the machine is all

00:57:29,770 --> 00:57:35,560
yours since the management mode can be

00:57:32,860 --> 00:57:38,560
entered by as I mentioned I all traps or

00:57:35,560 --> 00:57:42,070
even mmio traps so the memory maps

00:57:38,560 --> 00:57:44,500
register accesses machine checked

00:57:42,070 --> 00:57:47,980
exceptions when the cpu detects that

00:57:44,500 --> 00:57:51,060
it's broken and I pick anything in the

00:57:47,980 --> 00:57:54,850
HIPAA can also generate or result in

00:57:51,060 --> 00:57:56,800
systemic with node execution embedded

00:57:54,850 --> 00:57:59,770
controllers I'm out of time so

00:57:56,800 --> 00:58:02,050
unfortunately no rant about embedded

00:57:59,770 --> 00:58:04,630
controllers since 51 in the super I oh

00:58:02,050 --> 00:58:06,820
it can do a whole lot of stuff which

00:58:04,630 --> 00:58:10,570
jordan messes up the system because it's

00:58:06,820 --> 00:58:17,420
transparent and it might also be very

00:58:10,570 --> 00:58:21,740
difficult to to detect but ya know

00:58:17,420 --> 00:58:27,140
thanks to Luke and questions this is the

00:58:21,740 --> 00:58:29,450
first time yep our loss for all CC a

00:58:27,140 --> 00:58:33,829
storm rolled through variables and rye

00:58:29,450 --> 00:58:38,859
almost positive factors in registers so

00:58:33,829 --> 00:58:38,859
you kind of only a few yes yes

00:58:40,380 --> 00:58:43,009
yep

00:58:46,180 --> 00:58:53,390
good question so it depends on sometimes

00:58:50,900 --> 00:58:56,270
the 8051 there it can be a standalone

00:58:53,390 --> 00:58:59,240
chip and if it's a standalone ship it

00:58:56,270 --> 00:59:04,760
can have built-in firmware but it could

00:58:59,240 --> 00:59:06,560
also be sharing with the main share me

00:59:04,760 --> 00:59:10,130
the boot flash with the main firmer in

00:59:06,560 --> 00:59:12,560
the system so they say the first the

00:59:10,130 --> 00:59:14,510
first fifty fifty six kilobytes is the

00:59:12,560 --> 00:59:16,940
firmware for the for the microcontroller

00:59:14,510 --> 00:59:22,550
the embedded controller that's it's

00:59:16,940 --> 00:59:24,500
fairly common one good as its own budget

00:59:22,550 --> 00:59:28,750
yeah they can has it it can definitely

00:59:24,500 --> 00:59:28,750
has its own flash which is on yep

00:59:35,179 --> 00:59:38,689
sister management role

00:59:39,440 --> 00:59:42,440
it

00:59:43,240 --> 00:59:47,319
yes yes

00:59:48,130 --> 00:59:56,150
yes definitely yes definitely and

00:59:53,620 --> 00:59:58,880
someone also earlier asked the question

00:59:56,150 --> 01:00:00,800
if so the question was where the system

00:59:58,880 --> 01:00:02,000
management code that is running chord

01:00:00,800 --> 01:00:04,310
with where doesn't come from and the

01:00:02,000 --> 01:00:06,530
answer is it is also in core group we

01:00:04,310 --> 01:00:08,570
have two separates implementations of

01:00:06,530 --> 01:00:11,090
system management pro handlers and core

01:00:08,570 --> 01:00:13,700
boots one is from AMD that's the one for

01:00:11,090 --> 01:00:15,710
the geo dialects but they open source

01:00:13,700 --> 01:00:17,750
that and then there's the code that

01:00:15,710 --> 01:00:20,030
second behind our rope or the Intel

01:00:17,750 --> 01:00:22,670
Intel platforms and I think well maybe

01:00:20,030 --> 01:00:25,430
rule of you also wrote some small system

01:00:22,670 --> 01:00:27,050
management mode code for the env 64 yeah

01:00:25,430 --> 01:00:29,150
but it's all the included in the

01:00:27,050 --> 01:00:31,250
corporate source and there's full

01:00:29,150 --> 01:00:34,420
control and it does really very little

01:00:31,250 --> 01:00:39,250
because it wants to get out of the way

01:00:34,420 --> 01:00:39,250

YouTube URL: https://www.youtube.com/watch?v=gRwEZis7Z6A


