Title: The Evolution of MonoTorrent
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Alan McGovern

MonoTorrent is an implementation of the BitTorrent protocol written in C# for the .NET platform.

This talk will have two parts. The first part will revolve around the Piece Picking algorithm and how it evolved 
from a simplistic and inextensible initital implementation to its current highly extensible form as more complex behaviours were required.

The second part will be about the different strategies used to manage the multi-threaded workload. A typical bittorrent download will open about 100 connections so it is critical that the syncronisation strategy used to access any shared state does not prevent the sockets from sending/receiving data, otherwise performance will suffer.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,030 --> 00:00:22,650
okay ready hi Colin my name is this is

00:00:18,600 --> 00:00:25,880
an intro Alan McGovern was this guy

00:00:22,650 --> 00:00:25,880
we're doing Google Summer of Code

00:00:30,529 --> 00:00:35,130
so Alan McGovern

00:00:32,899 --> 00:00:36,750
we had a good or Summer of Code and I

00:00:35,130 --> 00:00:38,910
really wanted to have a Victorian

00:00:36,750 --> 00:00:40,110
library in c-sharp and the reason I

00:00:38,910 --> 00:00:40,440
wanted this is because I figured you

00:00:40,110 --> 00:00:43,129
know what

00:00:40,440 --> 00:00:46,739
instead of doing HTTP fetches and

00:00:43,129 --> 00:00:49,980
downloading files like that we should be

00:00:46,739 --> 00:00:52,079
using BitTorrent we torrent should be

00:00:49,980 --> 00:00:53,760
you know a fundamental component on

00:00:52,079 --> 00:00:56,520
every application that needs to transfer

00:00:53,760 --> 00:00:58,620
spots instead of FTP or fetching files

00:00:56,520 --> 00:01:01,109
synchronistic but we do need a library

00:00:58,620 --> 00:01:03,030
for that so in the summer of code we

00:01:01,109 --> 00:01:04,229
said all right we need a student that

00:01:03,030 --> 00:01:07,799
over the summer writes a BitTorrent

00:01:04,229 --> 00:01:11,280
library how hard can it be very and good

00:01:07,799 --> 00:01:14,909
year we received three applications I

00:01:11,280 --> 00:01:16,530
think there's three I think so yeah but

00:01:14,909 --> 00:01:18,030
Alan was the first one that I submitted

00:01:16,530 --> 00:01:19,500
an application and he immediately

00:01:18,030 --> 00:01:21,090
contacted me and I are since that's it

00:01:19,500 --> 00:01:22,380
well I've been thinking about this I

00:01:21,090 --> 00:01:25,619
think this is how we build data etcetera

00:01:22,380 --> 00:01:27,119
etcetera so we basically said well Alan

00:01:25,619 --> 00:01:29,009
seems to be like the most excited guy

00:01:27,119 --> 00:01:31,320
for the Victorian library so we got the

00:01:29,009 --> 00:01:34,200
Alan on board and he did an amazing job

00:01:31,320 --> 00:01:35,670
of her two months unbelievable work but

00:01:34,200 --> 00:01:38,369
not only that I like kept working on

00:01:35,670 --> 00:01:40,470
this in his spare time so next year we

00:01:38,369 --> 00:01:43,290
brought him to Boston to work on other

00:01:40,470 --> 00:01:45,840
stuff that was not be torrent yeah so

00:01:43,290 --> 00:01:47,520
him he's an amazing hacker and one year

00:01:45,840 --> 00:01:49,740
after when he graduated which said you

00:01:47,520 --> 00:01:52,850
need to work for us so that is the

00:01:49,740 --> 00:01:52,850
amazing Allen McGovern

00:01:55,900 --> 00:02:01,280
so the idea of this talk isn't really

00:01:59,390 --> 00:02:03,470
talk about how montar devolved it's

00:02:01,280 --> 00:02:04,640
basically there are a few problems that

00:02:03,470 --> 00:02:05,870
I encountered volume preventing the

00:02:04,640 --> 00:02:07,400
BitTorrent specification

00:02:05,870 --> 00:02:09,679
I'm just want to show people how I

00:02:07,400 --> 00:02:13,040
worked around them or how I came up over

00:02:09,679 --> 00:02:28,700
the solution so basically what is one

00:02:13,040 --> 00:02:30,560
what is one okay so and what is my

00:02:28,700 --> 00:02:32,840
returned it's just a dotnet based

00:02:30,560 --> 00:02:35,900
BitTorrent library it's just a bit of

00:02:32,840 --> 00:02:38,540
background info here so it started out

00:02:35,900 --> 00:02:41,150
in the 2006 google Summer of Code

00:02:38,540 --> 00:02:43,820
so as mikela said like it was three

00:02:41,150 --> 00:02:45,350
months I think ten weeks and of course I

00:02:43,820 --> 00:02:46,280
didn't have everything but it wasn't

00:02:45,350 --> 00:02:49,040
thirty-eight thousand lines of code

00:02:46,280 --> 00:02:50,810
written then but I'm these days it's

00:02:49,040 --> 00:02:53,720
about thirty thousand lines of code it

00:02:50,810 --> 00:02:56,720
supports pretty much everything you want

00:02:53,720 --> 00:02:59,930
from bit on library like multi-threading

00:02:56,720 --> 00:03:02,870
view DP trackers HTTP trackers all the

00:02:59,930 --> 00:03:04,280
different extensions like DHT which is

00:03:02,870 --> 00:03:05,840
like an alternative to normal bit

00:03:04,280 --> 00:03:07,549
torrent trackers so basically you can

00:03:05,840 --> 00:03:09,860
find other peers without having a

00:03:07,549 --> 00:03:12,470
centralized server so basically making

00:03:09,860 --> 00:03:16,190
BitTorrent decentralized so everything

00:03:12,470 --> 00:03:19,340
is supported so M as I was saying the

00:03:16,190 --> 00:03:23,060
idea behind this talk is two areas one

00:03:19,340 --> 00:03:24,799
the threading how how do you implement

00:03:23,060 --> 00:03:27,769
the threading so as you can imagine

00:03:24,799 --> 00:03:30,110
there's sixty connections or 60 sockets

00:03:27,769 --> 00:03:32,570
you have to a lot of like disk disk i/o

00:03:30,110 --> 00:03:34,730
reading and writing to disk they have to

00:03:32,570 --> 00:03:37,250
contact trackers it's all a synchronous

00:03:34,730 --> 00:03:38,750
you can't afford to do blocking

00:03:37,250 --> 00:03:40,250
operations because it'll just kill the

00:03:38,750 --> 00:03:41,840
performance of the library you won't be

00:03:40,250 --> 00:03:43,370
able to download at ten megabits a

00:03:41,840 --> 00:03:46,430
second or a hundred megabits a second

00:03:43,370 --> 00:03:48,560
you can't do blocking api's and the

00:03:46,430 --> 00:03:50,900
other bit I want to talk about the

00:03:48,560 --> 00:03:52,820
algorithm I am which allows you to

00:03:50,900 --> 00:03:56,329
choose who you download a piece off as

00:03:52,820 --> 00:03:58,190
in maybe piece one off this guy piss you

00:03:56,329 --> 00:03:59,660
off this guy or maybe you split it

00:03:58,190 --> 00:04:01,970
between different people to get a single

00:03:59,660 --> 00:04:02,630
piece faster so that's that's kind of

00:04:01,970 --> 00:04:05,010
interesting

00:04:02,630 --> 00:04:08,250
just how it all works

00:04:05,010 --> 00:04:11,849
so em that's what I'm going to talk

00:04:08,250 --> 00:04:13,620
about so the common thing I see a like a

00:04:11,849 --> 00:04:15,480
lot on the inside is people want to do

00:04:13,620 --> 00:04:17,280
use treads and like oh I have to

00:04:15,480 --> 00:04:19,769
download this file I want to use a

00:04:17,280 --> 00:04:21,660
thread and then I want to update my my

00:04:19,769 --> 00:04:23,810
my UI from the thread and then I want to

00:04:21,660 --> 00:04:26,430
do this from the thread it's all wrong

00:04:23,810 --> 00:04:28,229
like you shouldn't that's the wrong way

00:04:26,430 --> 00:04:30,180
to you thread threads aren't a way of

00:04:28,229 --> 00:04:33,090
obtaining a GU your GUI and doing this

00:04:30,180 --> 00:04:34,620
and doing this it just won't work you're

00:04:33,090 --> 00:04:38,010
gonna end up with deadlocks things are

00:04:34,620 --> 00:04:40,200
going to break so what's the ideal

00:04:38,010 --> 00:04:41,550
number of threads in an application say

00:04:40,200 --> 00:04:44,220
you have a lot of work to do and you can

00:04:41,550 --> 00:04:55,200
you can make a parallel and we want it

00:04:44,220 --> 00:04:56,850
how's it I guess one way but you can

00:04:55,200 --> 00:05:01,350
deadlock which is better doing the work

00:04:56,850 --> 00:05:02,820
slowly or not doing any work so I'll

00:05:01,350 --> 00:05:05,550
come I'll come back I'll come back to

00:05:02,820 --> 00:05:07,139
this later the idea is with one thread

00:05:05,550 --> 00:05:08,910
you will always complete your work

00:05:07,139 --> 00:05:11,280
it could be slow but it will always be

00:05:08,910 --> 00:05:14,490
completed you because otherwise if you

00:05:11,280 --> 00:05:16,260
have two threads you can deadlock so

00:05:14,490 --> 00:05:18,630
this this is I'm going to come back to

00:05:16,260 --> 00:05:20,250
these questions now later so how many

00:05:18,630 --> 00:05:24,990
other threads should one thread know

00:05:20,250 --> 00:05:26,400
about yeah exactly zero because if if

00:05:24,990 --> 00:05:26,760
your thread is waiting on another try to

00:05:26,400 --> 00:05:29,130
finish

00:05:26,760 --> 00:05:31,169
you don't need treads it needs to be

00:05:29,130 --> 00:05:32,340
like it that's serial threads in serial

00:05:31,169 --> 00:05:38,669
don't work together it should be

00:05:32,340 --> 00:05:40,620
parallel so yeah just zero and how many

00:05:38,669 --> 00:05:43,460
locks or mutexes should you need to

00:05:40,620 --> 00:05:43,460
access shared data

00:05:43,479 --> 00:05:53,050
like how many layers of Lux I ideally

00:05:50,050 --> 00:05:55,360
zero because there should be no shared

00:05:53,050 --> 00:05:56,969
data because otherwise you can't make it

00:05:55,360 --> 00:05:59,740
fully parallel if you're sharing data

00:05:56,969 --> 00:06:01,809
but of course we don't we live in the

00:05:59,740 --> 00:06:03,550
real world so we do actually need locks

00:06:01,809 --> 00:06:07,150
because we will have shared data in some

00:06:03,550 --> 00:06:08,830
cases so in that case one because if you

00:06:07,150 --> 00:06:10,809
have more than one lock if you have two

00:06:08,830 --> 00:06:12,339
locks different threads can require the

00:06:10,809 --> 00:06:13,930
locks in different orders and you'll end

00:06:12,339 --> 00:06:15,759
up with a deadlock so that's what I was

00:06:13,930 --> 00:06:17,469
saying about the one thread you don't

00:06:15,759 --> 00:06:19,509
want to lock sir if you have five locks

00:06:17,469 --> 00:06:21,550
then it's going to break there's no way

00:06:19,509 --> 00:06:23,620
you can guarantee that your application

00:06:21,550 --> 00:06:26,409
is always going to take the locks in the

00:06:23,620 --> 00:06:28,529
correct order well if you can guarantee

00:06:26,409 --> 00:06:33,189
that then while you're using five locks

00:06:28,529 --> 00:06:36,399
so really you want one lock so just to

00:06:33,189 --> 00:06:38,680
remind you if you're trying to use

00:06:36,399 --> 00:06:40,180
threads to do too much stuff like I'm

00:06:38,680 --> 00:06:41,620
using lots of locks you're doing it

00:06:40,180 --> 00:06:45,460
wrong it's the wrong way to use

00:06:41,620 --> 00:06:48,909
threading so from monitoring what we

00:06:45,460 --> 00:06:50,439
have in the typical case is maybe 60 60

00:06:48,909 --> 00:06:53,229
connections each of those is

00:06:50,439 --> 00:06:55,389
transferring data then you have lots of

00:06:53,229 --> 00:06:57,189
very slow disk access so if you're

00:06:55,389 --> 00:06:59,439
downloading data you can be writing 16

00:06:57,189 --> 00:07:01,060
kilobytes at a time so you're

00:06:59,439 --> 00:07:03,509
downloading at a mega by the second that

00:07:01,060 --> 00:07:06,129
could be 30 or 40 right calls a second

00:07:03,509 --> 00:07:09,639
you have web requests because you need

00:07:06,129 --> 00:07:12,479
to contact servers and you have the DHT

00:07:09,639 --> 00:07:16,149
requests which is like they did the

00:07:12,479 --> 00:07:17,139
decentralized peer selection so all of

00:07:16,149 --> 00:07:19,209
this is very slow

00:07:17,139 --> 00:07:22,360
you can't afford to use one thread per

00:07:19,209 --> 00:07:24,789
per per socket or one thread for disk

00:07:22,360 --> 00:07:26,289
i/o or one thread for each web request

00:07:24,789 --> 00:07:28,899
because it's too many threads you're

00:07:26,289 --> 00:07:32,979
gonna end up with 200 threads 300 shreds

00:07:28,899 --> 00:07:34,959
it doesn't scale and you can't use

00:07:32,979 --> 00:07:36,969
blocking calls because you can't just go

00:07:34,959 --> 00:07:38,680
socket dot read and then wait for the

00:07:36,969 --> 00:07:40,270
data to arrive because whatever your

00:07:38,680 --> 00:07:42,069
sockets going to do they're going to sit

00:07:40,270 --> 00:07:43,209
there with data pending and you can't

00:07:42,069 --> 00:07:45,819
read it because you're waiting for the

00:07:43,209 --> 00:07:50,469
first sock to give you data so blocking

00:07:45,819 --> 00:07:52,750
calls don't scale so the original

00:07:50,469 --> 00:07:55,090
architecture that mono torrent used was

00:07:52,750 --> 00:07:57,100
basically locks and

00:07:55,090 --> 00:08:00,790
friends what I said it's very bad and

00:07:57,100 --> 00:08:02,710
this is why when appear like a peer

00:08:00,790 --> 00:08:05,050
connection starts they receive some data

00:08:02,710 --> 00:08:08,320
of course we don't we just received this

00:08:05,050 --> 00:08:11,710
block of information we what it then did

00:08:08,320 --> 00:08:13,660
is I took a lock so on the peer I took a

00:08:11,710 --> 00:08:17,199
lock so then I could use this data I

00:08:13,660 --> 00:08:18,790
could decode it into proper data and

00:08:17,199 --> 00:08:21,310
then I could update that peer state

00:08:18,790 --> 00:08:23,680
because sometimes I just had to change a

00:08:21,310 --> 00:08:25,990
flag like make it a boolean true instead

00:08:23,680 --> 00:08:28,900
of false so in that case I don't need to

00:08:25,990 --> 00:08:31,000
uh to access the actual core so you

00:08:28,900 --> 00:08:32,890
think okay this is good I'm using a very

00:08:31,000 --> 00:08:34,570
small bit of information I just need to

00:08:32,890 --> 00:08:37,270
update the peer so I just lock on the

00:08:34,570 --> 00:08:39,460
pier but sometimes you also need to

00:08:37,270 --> 00:08:41,560
update the core like the actual the

00:08:39,460 --> 00:08:44,350
engine so you take a lock on the engine

00:08:41,560 --> 00:08:46,600
and then you update it so that's that's

00:08:44,350 --> 00:08:48,100
good we have you have two docs it's very

00:08:46,600 --> 00:08:50,440
simple sometimes you just need to update

00:08:48,100 --> 00:08:53,320
the peer sometimes the peer and the

00:08:50,440 --> 00:08:55,029
engine then of course you have sixty

00:08:53,320 --> 00:08:57,520
people doing that so this this makes

00:08:55,029 --> 00:08:58,960
sense you're always guaranteed that the

00:08:57,520 --> 00:09:01,620
peer will be locked and then the engine

00:08:58,960 --> 00:09:03,970
that's the order so luck eh then luck be

00:09:01,620 --> 00:09:05,529
but there's this problems with that and

00:09:03,970 --> 00:09:07,779
this is this is one of the problems that

00:09:05,529 --> 00:09:11,260
I was fighting with for maybe a year is

00:09:07,779 --> 00:09:13,900
that essentially the engine will always

00:09:11,260 --> 00:09:15,900
like you need a loop like the engine

00:09:13,900 --> 00:09:18,600
sometimes needs to just do an operation

00:09:15,900 --> 00:09:21,400
so the engine will lock on itself and

00:09:18,600 --> 00:09:23,529
then the engine will realize oh there's

00:09:21,400 --> 00:09:25,810
a pier and this person hasn't sent me

00:09:23,529 --> 00:09:30,670
data in two minutes so I need to close

00:09:25,810 --> 00:09:32,830
that connection so I can move it wrong

00:09:30,670 --> 00:09:36,190
so then the engine is now locking on the

00:09:32,830 --> 00:09:37,959
pier but that's backwards so what

00:09:36,190 --> 00:09:40,330
basically happens is that the engine

00:09:37,959 --> 00:09:42,940
would deadlock and there's no way around

00:09:40,330 --> 00:09:45,040
there's no way no easy way to fix this

00:09:42,940 --> 00:09:46,330
I'd fix one case and it would break

00:09:45,040 --> 00:09:49,300
somewhere else when I implement a new

00:09:46,330 --> 00:09:51,820
feature so basically two locks was too

00:09:49,300 --> 00:09:53,040
hard like I can't do two locks it just

00:09:51,820 --> 00:09:56,680
blew up

00:09:53,040 --> 00:09:59,170
so that's what I'm saying two locks you

00:09:56,680 --> 00:10:00,730
think it's easy but then the curve

00:09:59,170 --> 00:10:04,950
actually comes to a case where you can't

00:10:00,730 --> 00:10:06,700
do it with two locks it's too hard so I

00:10:04,950 --> 00:10:08,140
decided what I need is a new

00:10:06,700 --> 00:10:11,620
architecture one without

00:10:08,140 --> 00:10:14,110
knocks I need a new API so basically it

00:10:11,620 --> 00:10:16,270
uses one thread there is like basically

00:10:14,110 --> 00:10:18,190
like a main loop in a GTA application or

00:10:16,270 --> 00:10:20,680
a WinForms application everything

00:10:18,190 --> 00:10:24,520
happens on the main loop so what happens

00:10:20,680 --> 00:10:26,590
is I have one thread which which am

00:10:24,520 --> 00:10:29,290
excuse all the engine logic which does

00:10:26,590 --> 00:10:31,990
all that the data decoding the data like

00:10:29,290 --> 00:10:33,550
the updating of the peers and every call

00:10:31,990 --> 00:10:35,500
is asynchronous so you're thinking okay

00:10:33,550 --> 00:10:38,410
one thread how are you gonna handle

00:10:35,500 --> 00:10:40,030
sixty sockets well each socket just use

00:10:38,410 --> 00:10:42,880
the normal asynchronous API is like

00:10:40,030 --> 00:10:45,640
begin begin receive and receive but

00:10:42,880 --> 00:10:48,580
instead of instead of actually doing

00:10:45,640 --> 00:10:50,920
processing on the thread it always

00:10:48,580 --> 00:10:52,750
proxies back to the main loop so this is

00:10:50,920 --> 00:10:55,210
essentially what the code looks like I

00:10:52,750 --> 00:11:05,620
just call a standard socket up again

00:10:55,210 --> 00:11:07,330
connect then so if you're familiar with

00:11:05,620 --> 00:11:09,430
the with the socket API is beginning

00:11:07,330 --> 00:11:11,830
connect is the regular it's a regular

00:11:09,430 --> 00:11:14,110
call so once this was the connection

00:11:11,830 --> 00:11:17,350
attempt is finished dotnet will invoke

00:11:14,110 --> 00:11:20,400
this callback which is here and all I do

00:11:17,350 --> 00:11:23,110
is I queue that up on the main loop and

00:11:20,400 --> 00:11:25,080
then do the normal stuff here so as you

00:11:23,110 --> 00:11:27,250
see I'm using like a lambda like just

00:11:25,080 --> 00:11:30,340
non-anonymous delegates because it's a

00:11:27,250 --> 00:11:33,610
very easy way to proxy objects and code

00:11:30,340 --> 00:11:36,130
onto the main loop so every asynchronous

00:11:33,610 --> 00:11:37,420
call essentially just does this so

00:11:36,130 --> 00:11:39,400
rather than having to worry about oh I

00:11:37,420 --> 00:11:42,490
have to lock on this and then lock on

00:11:39,400 --> 00:11:45,610
this and then do my updates everything

00:11:42,490 --> 00:11:47,110
goes to the main loop so the long the

00:11:45,610 --> 00:11:49,540
slow processing is actually receiving

00:11:47,110 --> 00:11:52,210
the data or writing the data so all of

00:11:49,540 --> 00:11:53,860
that is asynchronous but for my

00:11:52,210 --> 00:11:57,280
applications point of view there's only

00:11:53,860 --> 00:12:00,730
one thread this so sure mana torrent is

00:11:57,280 --> 00:12:03,340
using maybe 10 12 10 or 12 threads but

00:12:00,730 --> 00:12:05,440
all I really work with is one so because

00:12:03,340 --> 00:12:08,290
I only have one thread that I actually

00:12:05,440 --> 00:12:09,850
work with I can't deadlock and I can I

00:12:08,290 --> 00:12:12,580
can never do like I can never take a

00:12:09,850 --> 00:12:15,070
lock in the wrong order and all the slow

00:12:12,580 --> 00:12:18,140
work isn't done no slow work happens

00:12:15,070 --> 00:12:21,320
here so the performance is really high

00:12:18,140 --> 00:12:22,400
and I some people use the library and

00:12:21,320 --> 00:12:24,020
they've reported that they can saturate

00:12:22,400 --> 00:12:26,450
I want you to make a big connection like

00:12:24,020 --> 00:12:28,760
underline using monitoring which is

00:12:26,450 --> 00:12:31,310
quite nice because you think okay one

00:12:28,760 --> 00:12:34,850
thread it must be really slow but it's

00:12:31,310 --> 00:12:37,400
just one your core logic so everything

00:12:34,850 --> 00:12:39,020
is still fast you can't deadlock because

00:12:37,400 --> 00:12:42,710
there's no locks I don't use a lock

00:12:39,020 --> 00:12:45,550
except for small parts and in that case

00:12:42,710 --> 00:12:48,500
there is there is only one block because

00:12:45,550 --> 00:12:50,450
here when you're queuing it up this has

00:12:48,500 --> 00:12:52,280
to be protected by a lock but only the

00:12:50,450 --> 00:12:54,440
queuing and D queuing from the main loop

00:12:52,280 --> 00:13:02,750
is protected I don't need to protect

00:12:54,440 --> 00:13:06,140
anything else well if your CPU banned

00:13:02,750 --> 00:13:10,220
yet it's a different story so it just it

00:13:06,140 --> 00:13:12,350
yeah it just depends well yes or no if

00:13:10,220 --> 00:13:14,870
your CPU banned you can still use this

00:13:12,350 --> 00:13:17,120
you just go instead of in queueing

00:13:14,870 --> 00:13:20,240
instead of sock about pink begin connect

00:13:17,120 --> 00:13:21,080
you go my big long operation that takes

00:13:20,240 --> 00:13:23,690
ten seconds

00:13:21,080 --> 00:13:24,980
doc begin on your ten second operation

00:13:23,690 --> 00:13:26,660
will be in the background thread from

00:13:24,980 --> 00:13:28,970
the thread pool and then once that

00:13:26,660 --> 00:13:30,710
ten-second operation is finished you go

00:13:28,970 --> 00:13:33,440
back to your main loop and you do a a

00:13:30,710 --> 00:13:35,890
microsecond of work so that's that

00:13:33,440 --> 00:13:35,890
something

00:13:40,760 --> 00:13:46,070
so it but then again you back down into

00:13:44,360 --> 00:13:48,529
your operations is like come come my

00:13:46,070 --> 00:13:49,790
operation be paralyzed I'm if so well

00:13:48,529 --> 00:13:51,500
actually is another talk about that kind

00:13:49,790 --> 00:13:53,570
of stuff later by Jeremy Laval who's

00:13:51,500 --> 00:13:55,760
around there so he's going to talk about

00:13:53,570 --> 00:13:57,800
how to do that kind of work without

00:13:55,760 --> 00:13:59,570
using threads you know like I said

00:13:57,800 --> 00:14:01,880
without explicitly starting I need four

00:13:59,570 --> 00:14:03,730
threads here to do this work he'll show

00:14:01,880 --> 00:14:07,880
you how to do it but I'm using threads

00:14:03,730 --> 00:14:12,860
explicitly you're not you're not

00:14:07,880 --> 00:14:29,870
explicitly using threads yes and that's

00:14:12,860 --> 00:14:32,649
that's the point it's it's it's all in

00:14:29,870 --> 00:14:32,649
the background yeah

00:14:47,639 --> 00:14:54,040
yeah so it's just basically a way of

00:14:51,899 --> 00:14:56,709
using threads without worrying about

00:14:54,040 --> 00:14:58,209
locking or any race conditions because

00:14:56,709 --> 00:14:59,920
all the important stuff happens on one

00:14:58,209 --> 00:15:02,050
like all the important non-blocking

00:14:59,920 --> 00:15:06,399
really short-lived tasks happen on one

00:15:02,050 --> 00:15:09,220
thread so em that's basically how

00:15:06,399 --> 00:15:11,529
monitoring works on threads and so it's

00:15:09,220 --> 00:15:14,139
quite I like to think it's a lot simpler

00:15:11,529 --> 00:15:16,029
than before because before you six a

00:15:14,139 --> 00:15:17,470
book with a deadlock and now I don't

00:15:16,029 --> 00:15:20,519
have to I haven't had a deadlock in more

00:15:17,470 --> 00:15:23,470
than a year so it is working much better

00:15:20,519 --> 00:15:24,730
but yeah as you were saying different

00:15:23,470 --> 00:15:26,949
applications do need different

00:15:24,730 --> 00:15:29,170
approaches for this kind of application

00:15:26,949 --> 00:15:31,870
I think it's perfect because the only

00:15:29,170 --> 00:15:34,420
slow stuff is disk access is socket

00:15:31,870 --> 00:15:36,040
access is web web web access and that

00:15:34,420 --> 00:15:37,959
can all be done handled with the normal

00:15:36,040 --> 00:15:42,730
cause I never have to explicitly use

00:15:37,959 --> 00:15:44,410
threads or worry about it so the second

00:15:42,730 --> 00:15:49,120
half of the talk is about the piece

00:15:44,410 --> 00:15:50,529
picking and basically in BitTorrent when

00:15:49,120 --> 00:15:53,170
you download a file it will be split up

00:15:50,529 --> 00:15:56,649
into small chunks maybe 32 kilobytes up

00:15:53,170 --> 00:15:59,559
to 2 megabytes per chunk so like we'll

00:15:56,649 --> 00:16:02,199
say into pieces of 32 kilobytes to 2

00:15:59,559 --> 00:16:03,910
megabytes and then each piece is in

00:16:02,199 --> 00:16:06,879
chunks of 16 kilobytes which is

00:16:03,910 --> 00:16:09,189
specified in the protocol so if this if

00:16:06,879 --> 00:16:12,819
there's 32 kilobytes a 3-2 kilobyte

00:16:09,189 --> 00:16:17,350
piece has 2 chunks 2 megabyte piece

00:16:12,819 --> 00:16:18,790
would have lots of chunks so the idea is

00:16:17,350 --> 00:16:20,529
that sometimes if you have really big

00:16:18,790 --> 00:16:22,959
pieces like 2 megabytes or 4 megabytes

00:16:20,529 --> 00:16:25,360
you don't want to have to download that

00:16:22,959 --> 00:16:27,189
off one person because if you're

00:16:25,360 --> 00:16:30,069
downloading 2 megabytes off one person

00:16:27,189 --> 00:16:31,389
and they're really slow then you're

00:16:30,069 --> 00:16:31,899
going to wait forever for that piece to

00:16:31,389 --> 00:16:35,559
arrive

00:16:31,899 --> 00:16:39,579
what do you don't want to there are also

00:16:35,559 --> 00:16:41,559
some other things sorry but there we go

00:16:39,579 --> 00:16:43,660
there are other conditions as well

00:16:41,559 --> 00:16:45,249
because you don't want everyone to start

00:16:43,660 --> 00:16:47,499
downloading from the very start of the

00:16:45,249 --> 00:16:49,990
file and download in order because then

00:16:47,499 --> 00:16:52,329
if if someone goes offline you'll find

00:16:49,990 --> 00:16:55,029
that everyone has pieces 1 to 50 no-one

00:16:52,329 --> 00:16:56,679
has pieces 51 to 100 so you have to be

00:16:55,029 --> 00:16:57,890
kind of you have to choose the rare

00:16:56,679 --> 00:17:00,090
pieces

00:16:57,890 --> 00:17:01,890
also you don't everyone choosing the

00:17:00,090 --> 00:17:03,750
same rare pieces because there's no

00:17:01,890 --> 00:17:06,660
point in everyone going Oh only one

00:17:03,750 --> 00:17:08,640
person has p7 so everyone downloads p7

00:17:06,660 --> 00:17:11,630
that's bad so it has to be kind of

00:17:08,640 --> 00:17:14,490
random so you go ok I have 10 pieces

00:17:11,630 --> 00:17:17,040
they're all kind of rare I'll download

00:17:14,490 --> 00:17:18,120
one of those and then of course

00:17:17,040 --> 00:17:19,709
sometimes you don't want to download

00:17:18,120 --> 00:17:20,850
files there could be a hundred files in

00:17:19,709 --> 00:17:23,400
the tyrant you want one

00:17:20,850 --> 00:17:25,110
so all these make it more complex to

00:17:23,400 --> 00:17:27,209
pick a piece because you have to follow

00:17:25,110 --> 00:17:28,890
all these rules and then there are some

00:17:27,209 --> 00:17:30,900
extensions to the protocol would say

00:17:28,890 --> 00:17:33,870
under certain conditions you're allowed

00:17:30,900 --> 00:17:37,050
to use this otherwise you're not so I

00:17:33,870 --> 00:17:39,840
needed a way of solving this which was

00:17:37,050 --> 00:17:41,310
one I could test because like I do have

00:17:39,840 --> 00:17:43,530
a lot of n unit tests because without

00:17:41,310 --> 00:17:45,810
them I'd never get anywhere I'd fix a

00:17:43,530 --> 00:17:48,690
bug I'd break something so what I

00:17:45,810 --> 00:17:50,250
originally started with was one class so

00:17:48,690 --> 00:17:53,070
I just have a class and it's called P

00:17:50,250 --> 00:17:55,320
speaker and it just picked a piece at

00:17:53,070 --> 00:17:58,080
random and then I made another method in

00:17:55,320 --> 00:18:00,990
this class which which made it choose

00:17:58,080 --> 00:18:02,640
rare pieces at random and then I made

00:18:00,990 --> 00:18:05,130
another method in this class I made it

00:18:02,640 --> 00:18:07,260
more complex and it's like now it can

00:18:05,130 --> 00:18:09,660
ignore some pieces and then I had to add

00:18:07,260 --> 00:18:11,790
more code and more code and as time went

00:18:09,660 --> 00:18:14,160
on I couldn't test it it was impossible

00:18:11,790 --> 00:18:15,960
for me to write a test and verify that

00:18:14,160 --> 00:18:18,210
under every condition I will actually

00:18:15,960 --> 00:18:19,890
choose a piece randomly or under every

00:18:18,210 --> 00:18:22,950
condition I'll choose one of the rare

00:18:19,890 --> 00:18:25,710
pieces it was too hard and there's too

00:18:22,950 --> 00:18:28,890
much code too many branches there's no

00:18:25,710 --> 00:18:33,480
way I could test everything so what I

00:18:28,890 --> 00:18:36,000
really wanted was one class to which was

00:18:33,480 --> 00:18:39,180
select at random well this is no this

00:18:36,000 --> 00:18:42,020
isn't working at all one class which

00:18:39,180 --> 00:18:44,850
will choose rare pieces sorry about that

00:18:42,020 --> 00:18:49,230
one class which would be able to let me

00:18:44,850 --> 00:18:52,620
ignore pieces or so you ignore files and

00:18:49,230 --> 00:18:54,690
then other classes then for specific

00:18:52,620 --> 00:18:56,760
behaviors so I wanted one class to

00:18:54,690 --> 00:18:58,560
handle each kind of picking behavior and

00:18:56,760 --> 00:19:04,470
then I wanted to chain them into a

00:18:58,560 --> 00:19:07,500
pipeline so code time um give me a

00:19:04,470 --> 00:19:10,820
second now to

00:19:07,500 --> 00:19:10,820
see if this will work again

00:19:19,450 --> 00:19:22,170
yes

00:19:22,330 --> 00:19:28,720
okay so as I was saying I really started

00:19:26,530 --> 00:19:31,180
with just one class P speaker which had

00:19:28,720 --> 00:19:35,590
everything I figured that couldn't work

00:19:31,180 --> 00:19:37,930
I need different subclasses so this is

00:19:35,590 --> 00:19:44,790
the standard class there are basically

00:19:37,930 --> 00:19:48,030
two important methods so this one here

00:19:44,790 --> 00:19:48,030
big piece

00:19:50,350 --> 00:19:57,340
yeah okay

00:20:04,780 --> 00:20:10,840
what today keep that okay so the two

00:20:09,640 --> 00:20:14,310
important methods I'm going to talk

00:20:10,840 --> 00:20:17,500
about our pick piece and is interesting

00:20:14,310 --> 00:20:19,930
so pick piece as it says is just a way

00:20:17,500 --> 00:20:22,210
of that's the methods called when I want

00:20:19,930 --> 00:20:24,490
to choose a piece from someone and then

00:20:22,210 --> 00:20:27,730
is interesting is the method that tells

00:20:24,490 --> 00:20:29,590
me if a particular person has a piece I

00:20:27,730 --> 00:20:31,360
want so are they interesting to me do I

00:20:29,590 --> 00:20:34,860
want to go to all this complex

00:20:31,360 --> 00:20:34,860
calculation and choose a piece from them

00:20:35,670 --> 00:20:40,660
so the idea behind the class was when

00:20:39,280 --> 00:20:42,730
you're implementing a subclass for

00:20:40,660 --> 00:20:44,050
specific behaviors you don't want to

00:20:42,730 --> 00:20:46,000
implement you see all these virtual

00:20:44,050 --> 00:20:47,920
methods you don't want to implement all

00:20:46,000 --> 00:20:52,330
of those you only want to implement one

00:20:47,920 --> 00:20:54,060
maybe two so what the way it works is

00:20:52,330 --> 00:20:57,040
when you when you create a piece picker

00:20:54,060 --> 00:20:58,570
you basically it's a pipeline so you you

00:20:57,040 --> 00:21:00,670
make a piece picker which wraps another

00:20:58,570 --> 00:21:02,920
one which wraps another one which wraps

00:21:00,670 --> 00:21:04,890
another one and the default

00:21:02,920 --> 00:21:11,920
implementations of all these methods

00:21:04,890 --> 00:21:15,850
just the tutor sorry here we go all it

00:21:11,920 --> 00:21:19,060
does is it returns the I have to pick

00:21:15,850 --> 00:21:20,830
her up here and I just returned I just

00:21:19,060 --> 00:21:23,230
call a method on that picker if it's not

00:21:20,830 --> 00:21:24,820
no so it's really simple by default I

00:21:23,230 --> 00:21:29,470
will always call it the base the base

00:21:24,820 --> 00:21:31,390
implementation the class I'm wrapping so

00:21:29,470 --> 00:21:35,950
what it means is you can write code like

00:21:31,390 --> 00:21:38,710
this this is an entire subclass which

00:21:35,950 --> 00:21:40,810
does randomized picking that's all just

00:21:38,710 --> 00:21:43,180
one method because every other method

00:21:40,810 --> 00:21:45,520
will automatically call the one I've

00:21:43,180 --> 00:21:47,560
wrapped so basically there must be one

00:21:45,520 --> 00:21:49,420
class which implements everything but

00:21:47,560 --> 00:21:52,000
everything else just has to change one

00:21:49,420 --> 00:21:57,910
specific piece of behavior so for random

00:21:52,000 --> 00:22:01,960
picking all you do is you is it's that

00:21:57,910 --> 00:22:03,480
fun big enough or is it only to make the

00:22:01,960 --> 00:22:07,470
font bigger

00:22:03,480 --> 00:22:10,169
it's the font-size okay okay so for

00:22:07,470 --> 00:22:12,600
random picking all I do is I choose an

00:22:10,169 --> 00:22:14,909
index between the start and end of the

00:22:12,600 --> 00:22:17,669
of the interesting range and then try

00:22:14,909 --> 00:22:19,320
and pick a piece there if I can't pick a

00:22:17,669 --> 00:22:21,210
piece between the midpoint and ending

00:22:19,320 --> 00:22:23,669
index I choose it between the start and

00:22:21,210 --> 00:22:25,350
mid point so it's very simple that's how

00:22:23,669 --> 00:22:28,500
you do random picking this is very easy

00:22:25,350 --> 00:22:32,220
to test it's just five lines of code you

00:22:28,500 --> 00:22:34,019
could test that in your head so that's

00:22:32,220 --> 00:22:35,370
this is the advantage of this this new

00:22:34,019 --> 00:22:41,070
method no because I can test things

00:22:35,370 --> 00:22:47,549
really easily or if you want to ignore

00:22:41,070 --> 00:22:50,789
something suppose like you never want to

00:22:47,549 --> 00:22:53,159
download you never want to download a

00:22:50,789 --> 00:22:54,510
piece you already have so one of the

00:22:53,159 --> 00:22:57,769
things is I need to be able to ignore

00:22:54,510 --> 00:23:01,409
the pieces I already have so all I do is

00:22:57,769 --> 00:23:04,740
this bit field is the pieces that I'm

00:23:01,409 --> 00:23:06,600
that the remote peer has like this that

00:23:04,740 --> 00:23:09,840
one is and all the pieces I want to get

00:23:06,600 --> 00:23:12,269
and this is all the pieces I already

00:23:09,840 --> 00:23:15,960
have so it's just a bit field operation

00:23:12,269 --> 00:23:18,990
like a man like not and so it's just one

00:23:15,960 --> 00:23:23,010
operation to remove all the pieces I

00:23:18,990 --> 00:23:26,429
already have from this list so if if I

00:23:23,010 --> 00:23:28,230
have if what I have is one I have these

00:23:26,429 --> 00:23:33,210
pieces so it's just a normal pet field

00:23:28,230 --> 00:23:40,019
and the remote pair has this all I end

00:23:33,210 --> 00:23:44,130
up with is zero one one zero zero yeah I

00:23:40,019 --> 00:23:46,200
think so I'll have two pieces left so

00:23:44,130 --> 00:23:49,559
this is really easy to test again it's

00:23:46,200 --> 00:23:51,840
two lines of code so before it was very

00:23:49,559 --> 00:23:55,440
complex because I had one class trying

00:23:51,840 --> 00:23:59,090
to do everything but now I have a much

00:23:55,440 --> 00:24:05,560
simpler method of doing everything and

00:23:59,090 --> 00:24:10,650
that is mostly my talk so back to here

00:24:05,560 --> 00:24:14,080
and alas come back to start so basically

00:24:10,650 --> 00:24:27,250
does anyone have questions on anything

00:24:14,080 --> 00:24:28,930
I've spoken about questions I'm going to

00:24:27,250 --> 00:24:32,290
say yes because you'll forget about it

00:24:28,930 --> 00:24:33,820
by the time you leave I'm going to say

00:24:32,290 --> 00:24:36,580
yes because you'll have forgotten by the

00:24:33,820 --> 00:24:38,560
time you leave so you will check I don't

00:24:36,580 --> 00:24:40,420
I don't think I think it still works but

00:24:38,560 --> 00:24:45,430
I don't use it like I haven't used it in

00:24:40,420 --> 00:24:54,430
a while so sorry I use monsoon it's

00:24:45,430 --> 00:24:57,370
better there are a few like there's a

00:24:54,430 --> 00:24:59,890
few open source ones and this this

00:24:57,370 --> 00:25:02,200
monsoon there's another one Paris Hart

00:24:59,890 --> 00:25:05,350
BitTorrent or something and there's a

00:25:02,200 --> 00:25:07,060
guy who's made it's a little application

00:25:05,350 --> 00:25:09,250
that he was on the IRC channel awhile

00:25:07,060 --> 00:25:11,530
ago it's basically it will take a video

00:25:09,250 --> 00:25:13,360
file like it's suppose you you make a

00:25:11,530 --> 00:25:15,280
game you can record a screen capital

00:25:13,360 --> 00:25:16,660
from it and he basically has a little

00:25:15,280 --> 00:25:19,660
application which will generate a

00:25:16,660 --> 00:25:21,340
torrent like strip information from it

00:25:19,660 --> 00:25:23,350
added to deterrent and then distributed

00:25:21,340 --> 00:25:25,110
all automatically so you select a file

00:25:23,350 --> 00:25:27,310
you just hit upload to the internet and

00:25:25,110 --> 00:25:29,260
what he uses monitoring to generate

00:25:27,310 --> 00:25:32,770
everything and then put the file on the

00:25:29,260 --> 00:25:34,060
internet and publish it there there is

00:25:32,770 --> 00:25:36,100
an extension for bunchy

00:25:34,060 --> 00:25:38,440
and because monitor has like this

00:25:36,100 --> 00:25:41,170
library has been exposed over d-bus well

00:25:38,440 --> 00:25:42,940
it there is a library which looks like

00:25:41,170 --> 00:25:44,410
an application which exposes the server

00:25:42,940 --> 00:25:47,590
d-bus so banks you can then download

00:25:44,410 --> 00:25:49,150
podcasts which are via torrent ok that

00:25:47,590 --> 00:25:51,250
that extension isn't really maintained

00:25:49,150 --> 00:25:52,480
because i don't have the time for it but

00:25:51,250 --> 00:25:55,360
there is an extension out there which

00:25:52,480 --> 00:25:58,060
lighter than the podcast arts and there

00:25:55,360 --> 00:25:59,400
are a few like commercial companies

00:25:58,060 --> 00:26:01,960
which have contact me in the past and

00:25:59,400 --> 00:26:05,230
which use monitoring to distribute files

00:26:01,960 --> 00:26:07,780
like updaters for games or one

00:26:05,230 --> 00:26:09,880
particular company and they do v like

00:26:07,780 --> 00:26:12,010
it's basically VM image migration and

00:26:09,880 --> 00:26:14,050
they want to be able to have one VM

00:26:12,010 --> 00:26:15,820
image and then migrate that to 200

00:26:14,050 --> 00:26:17,440
servers and they're using monitor like

00:26:15,820 --> 00:26:18,940
bit monitored for that because it allows

00:26:17,440 --> 00:26:21,340
them to have one

00:26:18,940 --> 00:26:22,690
centralized location and then every

00:26:21,340 --> 00:26:24,250
every computer can transfer the data

00:26:22,690 --> 00:26:26,200
between themselves so there's no single

00:26:24,250 --> 00:26:28,060
bottleneck it's not like two hundred

00:26:26,200 --> 00:26:30,120
computers trying to get all the data off

00:26:28,060 --> 00:26:32,800
one server they have normal bit turned

00:26:30,120 --> 00:26:37,960
so it makes their deployment much much

00:26:32,800 --> 00:26:49,470
faster its MIT x11 so as open as you

00:26:37,960 --> 00:26:49,470
want and

00:26:49,950 --> 00:26:55,390
it's funny you should say that and

00:26:53,460 --> 00:26:59,170
because we have the sliding window

00:26:55,390 --> 00:27:00,580
picker which basically a guy came in got

00:26:59,170 --> 00:27:03,070
in touch with me was like I want to use

00:27:00,580 --> 00:27:04,990
BitTorrent for streaming I every two

00:27:03,070 --> 00:27:06,670
months someone emails me goes can I talk

00:27:04,990 --> 00:27:08,050
to you I wanted I want a stream video

00:27:06,670 --> 00:27:10,330
with returned and I want to use

00:27:08,050 --> 00:27:13,930
monitoring for this so the idea behind

00:27:10,330 --> 00:27:15,160
the starting window picker is that when

00:27:13,930 --> 00:27:17,020
you when you're streaming something

00:27:15,160 --> 00:27:18,910
there's you want a buffer of maybe a

00:27:17,020 --> 00:27:21,430
minute so you want to download these

00:27:18,910 --> 00:27:22,900
specific pieces very quickly and then

00:27:21,430 --> 00:27:24,490
there's another bit we say from one

00:27:22,900 --> 00:27:27,460
minutes to three minutes where you you

00:27:24,490 --> 00:27:29,470
want them but it's not urgent and then

00:27:27,460 --> 00:27:30,550
finally anything else you can choose

00:27:29,470 --> 00:27:32,770
whenever you want

00:27:30,550 --> 00:27:34,030
so if if you have all the high priority

00:27:32,770 --> 00:27:37,030
pieces and all the medium priority

00:27:34,030 --> 00:27:38,830
pieces everything from where you are in

00:27:37,030 --> 00:27:42,520
the video file onwards is low priority

00:27:38,830 --> 00:27:44,290
so you just choose it whenever so all

00:27:42,520 --> 00:27:46,570
you really need to do what monitoring is

00:27:44,290 --> 00:27:48,580
keep the high priority start index

00:27:46,570 --> 00:27:51,190
updated so as your video player plays

00:27:48,580 --> 00:27:53,860
the file you go okay I've played the

00:27:51,190 --> 00:27:55,480
first 10 kilobytes you you increase the

00:27:53,860 --> 00:27:58,840
index by one you've played a hundred

00:27:55,480 --> 00:28:01,030
kilobytes increase the index by 10 and a

00:27:58,840 --> 00:28:02,410
monitor will then automatically only

00:28:01,030 --> 00:28:04,780
select the pieces from that point

00:28:02,410 --> 00:28:08,260
onwards and will always keep a buffer of

00:28:04,780 --> 00:28:10,150
a minute so it is possible to stream via

00:28:08,260 --> 00:28:14,560
BitTorrent but it isn't it isn't ideal

00:28:10,150 --> 00:28:16,090
but it can be made better because the

00:28:14,560 --> 00:28:17,920
advantage of of BitTorrent is that

00:28:16,090 --> 00:28:20,290
anyone can choose a piece of anyone else

00:28:17,920 --> 00:28:21,670
but if you're streaming maybe two or

00:28:20,290 --> 00:28:23,410
three people have the piece and then

00:28:21,670 --> 00:28:25,390
you'll need it and then nobody needs it

00:28:23,410 --> 00:28:28,180
because it's in the past people just

00:28:25,390 --> 00:28:30,160
want new files so it's not it's not

00:28:28,180 --> 00:28:32,080
ideal because you don't get the same

00:28:30,160 --> 00:28:33,750
kind of bandwidth sharing that you

00:28:32,080 --> 00:28:45,040
wouldn't know

00:28:33,750 --> 00:28:47,890
but yeah it is possible so yeah so okay

00:28:45,040 --> 00:28:49,630
so yeah this this is the fully managed

00:28:47,890 --> 00:28:51,220
library it's our C sharp so it's fully

00:28:49,630 --> 00:28:53,290
compatible like it can be run inside the

00:28:51,220 --> 00:28:56,170
server light sandbox so if you really

00:28:53,290 --> 00:28:57,940
want you can you can develop a little

00:28:56,170 --> 00:28:59,500
bit torrent client which will publish

00:28:57,940 --> 00:29:01,210
the silver lights like several I can

00:28:59,500 --> 00:29:03,820
only access a limited set of ports and

00:29:01,210 --> 00:29:06,610
in those limited set of ports there's a

00:29:03,820 --> 00:29:09,970
kind of there's an authentication but

00:29:06,610 --> 00:29:11,350
some I can't remember the words now but

00:29:09,970 --> 00:29:12,820
basically you have to respond with a

00:29:11,350 --> 00:29:15,309
certain bit of data before you're

00:29:12,820 --> 00:29:16,900
allowed make a connection so you can't

00:29:15,309 --> 00:29:18,700
just connect to anything you have to

00:29:16,900 --> 00:29:20,980
connect to a proper service like a serve

00:29:18,700 --> 00:29:23,860
light service so you could write a quick

00:29:20,980 --> 00:29:26,020
application using mana torrent to expose

00:29:23,860 --> 00:29:29,350
bit turned over the Silverlight service

00:29:26,020 --> 00:29:31,750
and you can then just use this to stream

00:29:29,350 --> 00:29:32,740
video in your Silverlight application so

00:29:31,750 --> 00:29:34,360
if you want video streaming and

00:29:32,740 --> 00:29:45,340
Silverlight you could use you could do

00:29:34,360 --> 00:29:52,210
this just as easily will have banned

00:29:45,340 --> 00:29:55,360
BitTorrent from the app store so if you

00:29:52,210 --> 00:29:57,580
if you implemented a downloading program

00:29:55,360 --> 00:29:58,870
that didn't explicitly say BitTorrent

00:29:57,580 --> 00:30:00,240
that would be okay but as soon as you

00:29:58,870 --> 00:30:03,280
use the word BitTorrent to say no

00:30:00,240 --> 00:30:04,840
because BitTorrent is illegal and you

00:30:03,280 --> 00:30:08,980
know people only use it to turn out

00:30:04,840 --> 00:30:12,330
illegal things completely different it

00:30:08,980 --> 00:30:12,330
only downloads Linux ISOs

00:30:13,710 --> 00:30:18,980
because well a long story

00:30:17,010 --> 00:30:21,330
it was originally called bit sharp

00:30:18,980 --> 00:30:23,310
because no one was using a name like

00:30:21,330 --> 00:30:26,280
that I figured you know bit R and C

00:30:23,310 --> 00:30:27,660
sharp bit sharp its grace but there was

00:30:26,280 --> 00:30:29,790
another library then which had been

00:30:27,660 --> 00:30:31,440
inactive for two years and then the guy

00:30:29,790 --> 00:30:32,700
activated again and he started he made a

00:30:31,440 --> 00:30:35,760
commercial product out of his library

00:30:32,700 --> 00:30:39,240
and that was called BT sharp so bit

00:30:35,760 --> 00:30:47,430
sharp and BT shop it's too similar so it

00:30:39,240 --> 00:30:49,490
just was called mono tart thanks for

00:30:47,430 --> 00:30:49,490

YouTube URL: https://www.youtube.com/watch?v=TbhKpeqIy8o


