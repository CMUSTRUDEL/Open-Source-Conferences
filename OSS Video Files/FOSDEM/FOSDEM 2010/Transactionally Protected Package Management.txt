Title: Transactionally Protected Package Management
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:08,069
i'm jeff johnson and i'm the lead

00:00:02,939 --> 00:00:10,889
developer at rpm 5 org and also part of

00:00:08,069 --> 00:00:13,009
the Mancusi project you just saw me meet

00:00:10,889 --> 00:00:15,929
many of the other members you know

00:00:13,009 --> 00:00:18,420
essentially for the first time I'm a

00:00:15,929 --> 00:00:23,010
remote II since i live in the US but

00:00:18,420 --> 00:00:26,789
Mancusi is the best research i've seen

00:00:23,010 --> 00:00:30,920
on package management you know since

00:00:26,789 --> 00:00:34,800
forever okay with actually analyzing and

00:00:30,920 --> 00:00:37,700
modeling and looking at the details of

00:00:34,800 --> 00:00:42,300
package management and trying to scale

00:00:37,700 --> 00:00:46,440
package management into you know

00:00:42,300 --> 00:00:50,640
hundreds of repositories and thousands

00:00:46,440 --> 00:00:52,949
of or of packages and trying to make

00:00:50,640 --> 00:00:54,420
sure that the fundamental goal of

00:00:52,949 --> 00:00:57,180
package management of software

00:00:54,420 --> 00:01:00,270
installation is actually functional okay

00:00:57,180 --> 00:01:02,579
so i recommend Mancusi not just because

00:01:00,270 --> 00:01:05,070
you know I'm part of it but it's the

00:01:02,579 --> 00:01:08,460
best research I'm aware of and the only

00:01:05,070 --> 00:01:12,450
attempt that I know to approach debian

00:01:08,460 --> 00:01:15,720
and RPM packaging you know neutrally

00:01:12,450 --> 00:01:19,650
alright for the last decade there's been

00:01:15,720 --> 00:01:22,619
an insane amount of effort wasted just

00:01:19,650 --> 00:01:26,130
because of packaging war differences

00:01:22,619 --> 00:01:29,040
okay both of them are successful RPM and

00:01:26,130 --> 00:01:31,170
D package and there's they're just

00:01:29,040 --> 00:01:34,259
different okay and they're more alike

00:01:31,170 --> 00:01:36,240
than different these days you know the

00:01:34,259 --> 00:01:38,759
same problems are being solved it's just

00:01:36,240 --> 00:01:41,090
one person says banana and the other

00:01:38,759 --> 00:01:47,399
person says tomato but it's the same

00:01:41,090 --> 00:01:49,619
intrinsic problem in any case my talk is

00:01:47,399 --> 00:01:53,399
pretty much ad hoc you know I have no

00:01:49,619 --> 00:01:56,430
slides and so on you know as a developer

00:01:53,399 --> 00:01:59,250
I tend to have too many notes and not

00:01:56,430 --> 00:02:04,170
enough music and I promise certain

00:01:59,250 --> 00:02:07,350
members that I wouldn't be boring this

00:02:04,170 --> 00:02:08,429
is my third talk here at fosston my

00:02:07,350 --> 00:02:10,319
first one I made the mistake of

00:02:08,429 --> 00:02:11,760
providing too many details I put a whole

00:02:10,319 --> 00:02:15,450
room to sleep all right

00:02:11,760 --> 00:02:18,000
but my second talk I found that it was

00:02:15,450 --> 00:02:21,799
easier to find essentially three to five

00:02:18,000 --> 00:02:26,010
talking points and try and convey an

00:02:21,799 --> 00:02:28,409
overview of a very complex subject the

00:02:26,010 --> 00:02:32,069
subject here is transactionally

00:02:28,409 --> 00:02:34,079
protected package management and those

00:02:32,069 --> 00:02:37,590
highfalutin words basically just mean

00:02:34,079 --> 00:02:42,299
trying to add acid behavior to make

00:02:37,590 --> 00:02:45,840
packaging more reliable acid is well

00:02:42,299 --> 00:02:48,900
known and if you are adding transactions

00:02:45,840 --> 00:02:52,139
to a database the essential components

00:02:48,900 --> 00:02:54,720
are well analyzed acid for those who

00:02:52,139 --> 00:03:00,349
don't know stands for atomicity

00:02:54,720 --> 00:03:04,709
consistency isolation and durability

00:03:00,349 --> 00:03:07,760
alright and ethnicities usually achieved

00:03:04,709 --> 00:03:10,290
by locks almost everything hasn't

00:03:07,760 --> 00:03:13,200
consistency if you're inconsistent well

00:03:10,290 --> 00:03:16,919
you die fairly quickly so those are the

00:03:13,200 --> 00:03:19,049
rather easy aspects of acid the parts

00:03:16,919 --> 00:03:23,750
that need to be added to package

00:03:19,049 --> 00:03:27,019
management our isolation and durability

00:03:23,750 --> 00:03:30,480
durability is perhaps the easier one

00:03:27,019 --> 00:03:34,560
because it just adds persistence and a

00:03:30,480 --> 00:03:37,230
persistent state machine on beyond just

00:03:34,560 --> 00:03:39,389
the action of an install package

00:03:37,230 --> 00:03:42,900
management is different from archivers

00:03:39,389 --> 00:03:46,109
because it had tries to manage software

00:03:42,900 --> 00:03:49,879
over its entire life cycle okay from

00:03:46,109 --> 00:03:53,609
building into distribution into

00:03:49,879 --> 00:03:57,299
installation into you know retiring it

00:03:53,609 --> 00:04:00,620
and legacy compatibility and so

00:03:57,299 --> 00:04:06,060
durability is trying to add a

00:04:00,620 --> 00:04:08,699
persistence to the store of a the

00:04:06,060 --> 00:04:13,739
metadata on the installed machine so

00:04:08,699 --> 00:04:17,359
that it's no one reliable and it can be

00:04:13,739 --> 00:04:21,530
maintained in a consistent fashion so

00:04:17,359 --> 00:04:24,440
isolation is rather more complicated

00:04:21,530 --> 00:04:30,020
because of

00:04:24,440 --> 00:04:33,020
the mixed problem case of that a package

00:04:30,020 --> 00:04:37,070
manager has there are basically three

00:04:33,020 --> 00:04:43,460
different types of information that need

00:04:37,070 --> 00:04:46,220
to be preserved when a package is

00:04:43,460 --> 00:04:48,740
installed the easiest one because it's

00:04:46,220 --> 00:04:52,100
an already solved problem is the

00:04:48,740 --> 00:04:56,240
database acid databases have acid we all

00:04:52,100 --> 00:04:59,030
know this the second one is file systems

00:04:56,240 --> 00:05:01,910
and file systems is where isolation

00:04:59,030 --> 00:05:04,760
becomes very tricking a file system by

00:05:01,910 --> 00:05:09,760
its nature is shared I mean there is no

00:05:04,760 --> 00:05:13,610
file system that really has any credible

00:05:09,760 --> 00:05:16,630
approach to isolation but isolation is

00:05:13,610 --> 00:05:20,930
two processes shall not know you know

00:05:16,630 --> 00:05:22,670
that they're both about each other there

00:05:20,930 --> 00:05:26,240
shall be no side effects that are shared

00:05:22,670 --> 00:05:29,150
but that isn't how file systems work

00:05:26,240 --> 00:05:34,990
alright file systems try and provide a

00:05:29,150 --> 00:05:41,360
consistent viewpoint on to a data store

00:05:34,990 --> 00:05:44,260
on a file system and so another entity

00:05:41,360 --> 00:05:47,510
will see a file as soon as it's created

00:05:44,260 --> 00:05:51,320
since a package manager is installing on

00:05:47,510 --> 00:05:55,310
a file system isolation is rather tricky

00:05:51,320 --> 00:05:58,520
to achieve their been several attempts

00:05:55,310 --> 00:06:02,800
to do this with let's say file

00:05:58,520 --> 00:06:08,050
snapshotting or copy-on-write and

00:06:02,800 --> 00:06:11,540
aspects like this but acid will never be

00:06:08,050 --> 00:06:14,270
fully achieved on a file system until

00:06:11,540 --> 00:06:17,230
the file systems themselves start

00:06:14,270 --> 00:06:21,650
providing some sort of transactional

00:06:17,230 --> 00:06:23,390
protection actually parked and this is

00:06:21,650 --> 00:06:27,110
probably an appropriate place to point

00:06:23,390 --> 00:06:30,200
it out as part of doing due diligence on

00:06:27,110 --> 00:06:32,660
whether trans actually protected package

00:06:30,200 --> 00:06:36,580
management was feasible one of the

00:06:32,660 --> 00:06:38,669
things I looked at is the two attempts

00:06:36,580 --> 00:06:42,330
I'm aware of to try and do

00:06:38,669 --> 00:06:46,629
transactionally protected system calls

00:06:42,330 --> 00:06:51,509
and one of them is the Valor file system

00:06:46,629 --> 00:06:51,509
and this is the third implementation

00:06:51,629 --> 00:06:58,629
that is starting to perform nearly as

00:06:55,060 --> 00:07:03,520
well as ext3 it's only three times

00:06:58,629 --> 00:07:05,969
slower but when you add the logging

00:07:03,520 --> 00:07:09,520
necessary for transactions and

00:07:05,969 --> 00:07:11,949
transactional rollbacks and two-phase

00:07:09,520 --> 00:07:15,099
commits you know you're going to write

00:07:11,949 --> 00:07:17,620
more information and so actually a

00:07:15,099 --> 00:07:25,409
factor of three slower is not too bad

00:07:17,620 --> 00:07:25,409
all right but the valor file system has

00:07:25,979 --> 00:07:33,039
transactions built within a kernel

00:07:28,719 --> 00:07:36,430
driver to and the benefit for a file

00:07:33,039 --> 00:07:40,270
system is all sorts of race conditions

00:07:36,430 --> 00:07:44,349
are avoided if you can provide the eye

00:07:40,270 --> 00:07:46,569
and acid isolation all right the other

00:07:44,349 --> 00:07:49,000
approach which I'll just mention offhand

00:07:46,569 --> 00:07:54,550
is I think it's out of the University of

00:07:49,000 --> 00:07:57,789
Texas and it's tries to provide a begin

00:07:54,550 --> 00:08:02,830
and commit on a transaction around sets

00:07:57,789 --> 00:08:06,759
of operations I that's a second approach

00:08:02,830 --> 00:08:12,419
to essentially the same thing unlike a

00:08:06,759 --> 00:08:16,089
file system okay a package manager can

00:08:12,419 --> 00:08:18,940
speed is not as critical RPM is not

00:08:16,089 --> 00:08:22,750
going to be compared to ext3 it will be

00:08:18,940 --> 00:08:26,259
compared to D package okay but D package

00:08:22,750 --> 00:08:32,079
is slow enough that it's possible to try

00:08:26,259 --> 00:08:35,289
and provide some isolation that on file

00:08:32,079 --> 00:08:38,469
system operations all right which is the

00:08:35,289 --> 00:08:41,440
second component if I recover all my

00:08:38,469 --> 00:08:43,959
parentheticals you know there's acid for

00:08:41,440 --> 00:08:47,740
databases there's acid for file systems

00:08:43,959 --> 00:08:49,910
and the third part is the part that John

00:08:47,740 --> 00:08:52,550
Thompson talked about this morning we

00:08:49,910 --> 00:08:55,280
is acid for scriptlets and that's a

00:08:52,550 --> 00:08:57,860
really hard problem to solve but the

00:08:55,280 --> 00:09:02,810
second component where isolation is is

00:08:57,860 --> 00:09:05,960
very tricky is how do you preserve all

00:09:02,810 --> 00:09:09,340
the system calls that are done by a

00:09:05,960 --> 00:09:14,420
package manager as its installing

00:09:09,340 --> 00:09:17,360
content on a file system all right and

00:09:14,420 --> 00:09:20,500
it just summarize you know rather

00:09:17,360 --> 00:09:24,350
complicated and roundabout way of

00:09:20,500 --> 00:09:28,610
talking about it until file system

00:09:24,350 --> 00:09:31,700
provides isolation I are packed rpm camp

00:09:28,610 --> 00:09:36,710
all right but our p.m. does do things

00:09:31,700 --> 00:09:39,890
like installing files in a tent name and

00:09:36,710 --> 00:09:42,080
then renaming them in place if the temp

00:09:39,890 --> 00:09:45,250
name is unique enough it's unlikely that

00:09:42,080 --> 00:09:47,420
it will be that there will be a

00:09:45,250 --> 00:09:49,430
interaction between two interacting

00:09:47,420 --> 00:09:52,280
processes but that's about the best you

00:09:49,430 --> 00:09:54,920
can do you know with transactionally

00:09:52,280 --> 00:09:57,470
protected package management is install

00:09:54,920 --> 00:10:01,550
into a unique name and then try and move

00:09:57,470 --> 00:10:04,520
it into place as easily as possible so

00:10:01,550 --> 00:10:06,140
the three components for transactionally

00:10:04,520 --> 00:10:11,320
protected package management our

00:10:06,140 --> 00:10:17,630
database acid system call acid and a

00:10:11,320 --> 00:10:21,950
script lead acid the underlying

00:10:17,630 --> 00:10:24,650
mechanism is quite complicated but it's

00:10:21,950 --> 00:10:26,510
not hard to understand if you want a

00:10:24,650 --> 00:10:28,640
transactional log you have to write a

00:10:26,510 --> 00:10:32,750
log record before you perform any

00:10:28,640 --> 00:10:34,940
operation and if you have a log record

00:10:32,750 --> 00:10:40,550
then you can also put a marker in the

00:10:34,940 --> 00:10:42,830
log that indicates that you completed

00:10:40,550 --> 00:10:45,140
successfully and if there is no marker

00:10:42,830 --> 00:10:47,240
you can infer go back to previous one

00:10:45,140 --> 00:10:50,270
and that's essentially what happens with

00:10:47,240 --> 00:10:54,440
a rollback once you have that basic

00:10:50,270 --> 00:10:58,910
state machine for transactional logging

00:10:54,440 --> 00:11:01,000
than the rest of it's rather easy it's

00:10:58,910 --> 00:11:04,420
just moving between different

00:11:01,000 --> 00:11:08,890
you know consistent points and anything

00:11:04,420 --> 00:11:14,550
in between if I can be inverted and

00:11:08,890 --> 00:11:18,280
discarded which removes side effects

00:11:14,550 --> 00:11:19,840
this will be one of the major benefits I

00:11:18,280 --> 00:11:23,020
know it was one of the very first things

00:11:19,840 --> 00:11:24,700
i was asked can RPM five truly if

00:11:23,020 --> 00:11:27,790
there's two headers in there will the

00:11:24,700 --> 00:11:29,140
other one disappear okay and this is one

00:11:27,790 --> 00:11:32,080
of the side effects if there's an

00:11:29,140 --> 00:11:34,510
abnormal exit in the package manager

00:11:32,080 --> 00:11:36,850
then there will be residual state that's

00:11:34,510 --> 00:11:39,190
left and this alfin shows up if you do a

00:11:36,850 --> 00:11:41,440
query you'll have both the old and the

00:11:39,190 --> 00:11:45,370
new because you failed before the old

00:11:41,440 --> 00:11:48,760
could be removed all right that you know

00:11:45,370 --> 00:11:52,930
will now be transactionally protected

00:11:48,760 --> 00:11:56,230
and if that install a race pair okay

00:11:52,930 --> 00:11:59,110
does not achieve a commit then the

00:11:56,230 --> 00:12:02,560
intervening information can be discarded

00:11:59,110 --> 00:12:06,430
reliably so that the underlying store

00:12:02,560 --> 00:12:10,960
okay is known to be moving through time

00:12:06,430 --> 00:12:16,180
by definite checkpoints all right with

00:12:10,960 --> 00:12:18,070
known good behavior most of the rest of

00:12:16,180 --> 00:12:21,430
what we'll talk about in the part that's

00:12:18,070 --> 00:12:23,320
complete now I believe although the

00:12:21,430 --> 00:12:26,770
really hard part about transactionally

00:12:23,320 --> 00:12:28,930
protected package management is to know

00:12:26,770 --> 00:12:31,480
that you have full coverage over all

00:12:28,930 --> 00:12:35,080
possible cases that will only come with

00:12:31,480 --> 00:12:38,110
sufficient testing and usage but what is

00:12:35,080 --> 00:12:41,950
there now is using Berkeley DB all right

00:12:38,110 --> 00:12:44,500
our p.m. already uses Berkeley DB since

00:12:41,950 --> 00:12:47,500
all that transactionally protected

00:12:44,500 --> 00:12:50,440
package management relies on is acid

00:12:47,500 --> 00:12:54,550
behavior any database would do but

00:12:50,440 --> 00:12:57,460
Berkeley DB already has all this the I

00:12:54,550 --> 00:13:00,490
am so there's no reason to look at

00:12:57,460 --> 00:13:03,040
alternative forms but any SQL database

00:13:00,490 --> 00:13:08,980
these days provide some form of acid

00:13:03,040 --> 00:13:11,740
behavior the choice at rpm five was to

00:13:08,980 --> 00:13:13,889
use Berkeley DB the underlying reason

00:13:11,740 --> 00:13:18,019
for this was there

00:13:13,889 --> 00:13:22,259
the DB already has sample code that

00:13:18,019 --> 00:13:25,949
shows how to extend the database logs

00:13:22,259 --> 00:13:28,589
into other abstract events other

00:13:25,949 --> 00:13:31,049
abstract events with the sample case

00:13:28,589 --> 00:13:33,329
that's in there is if you have two

00:13:31,049 --> 00:13:37,290
system calls make door and remove their

00:13:33,329 --> 00:13:39,109
they form an invertible pair okay if you

00:13:37,290 --> 00:13:41,759
while you're installing you make a

00:13:39,109 --> 00:13:45,540
directory but if you want to roll it

00:13:41,759 --> 00:13:47,730
back you remove a directory and so it's

00:13:45,540 --> 00:13:51,869
very important that every action has its

00:13:47,730 --> 00:13:54,540
own inverse but with sample code and an

00:13:51,869 --> 00:13:56,970
awk script that generates all the glue

00:13:54,540 --> 00:14:02,579
layers it's possible to extend Berkeley

00:13:56,970 --> 00:14:06,299
DB to handle system calls RPM itself

00:14:02,579 --> 00:14:09,929
during package installation performs

00:14:06,299 --> 00:14:12,059
about 20 system call operations and

00:14:09,929 --> 00:14:16,259
their things like make door and remove

00:14:12,059 --> 00:14:23,360
dirt and of course writing a file to

00:14:16,259 --> 00:14:27,869
extend berkeley DB acid to file system

00:14:23,360 --> 00:14:31,589
acid when if you're going to remove a

00:14:27,869 --> 00:14:35,399
file as part of installing a package

00:14:31,589 --> 00:14:39,389
what needs to be done is to write the

00:14:35,399 --> 00:14:41,699
previous content into the log and then

00:14:39,389 --> 00:14:44,249
remove the file so if you have to put it

00:14:41,699 --> 00:14:46,709
back the content can be put directly

00:14:44,249 --> 00:14:48,929
back out of the log nothing else is

00:14:46,709 --> 00:14:52,439
needed except the log and something

00:14:48,929 --> 00:14:54,149
which can read the log so my goal with

00:14:52,439 --> 00:14:56,189
transactionally protected package

00:14:54,149 --> 00:14:57,959
management and I'm not there yet because

00:14:56,189 --> 00:15:03,419
there's a large number of pieces that

00:14:57,959 --> 00:15:09,749
still need to be implemented and tested

00:15:03,419 --> 00:15:13,350
is to take a machine take the log off it

00:15:09,749 --> 00:15:15,389
take the executable which reads the log

00:15:13,350 --> 00:15:18,179
remove everything else and put the

00:15:15,389 --> 00:15:20,669
machine the entire machine allstate on

00:15:18,179 --> 00:15:24,869
the machine every single file exactly

00:15:20,669 --> 00:15:27,390
the same using only the log all right

00:15:24,869 --> 00:15:30,600
that's the goal of this all right

00:15:27,390 --> 00:15:34,710
because RPM is expected to run in empty

00:15:30,600 --> 00:15:39,090
change routes and on bare metal machines

00:15:34,710 --> 00:15:42,300
and there is no stronger test of it a

00:15:39,090 --> 00:15:44,970
test of any implementation then can you

00:15:42,300 --> 00:15:48,870
recreate anything everything that's on

00:15:44,970 --> 00:15:51,830
the system and pass a dip test to make

00:15:48,870 --> 00:15:55,920
sure all the information is identical I

00:15:51,830 --> 00:15:57,570
think that that is feasible and but I

00:15:55,920 --> 00:16:03,200
won't know until I actually get there

00:15:57,570 --> 00:16:03,200
yes sure

00:16:09,810 --> 00:16:14,880
for the camera the goal is remarkable

00:16:12,510 --> 00:16:16,620
there is a lot of good behind what you

00:16:14,880 --> 00:16:18,900
are everything you're saying but in

00:16:16,620 --> 00:16:20,970
order to do all these production are

00:16:18,900 --> 00:16:23,520
much overhead to a good over my file

00:16:20,970 --> 00:16:26,640
system if I'm installing 20,000 packages

00:16:23,520 --> 00:16:28,320
that takes 40 G a bite and then I need

00:16:26,640 --> 00:16:30,600
to go and start from the logs it means

00:16:28,320 --> 00:16:32,100
they need to have at least 40 g a bite

00:16:30,600 --> 00:16:34,770
of logs depending on how many times have

00:16:32,100 --> 00:16:36,839
been updating in between so there must

00:16:34,770 --> 00:16:38,400
be some some kind of optimization you

00:16:36,839 --> 00:16:40,380
have in mind to avoid that kind of

00:16:38,400 --> 00:16:43,529
overhead on the log of machine you give

00:16:40,380 --> 00:16:44,910
me a perfect entry point to describe you

00:16:43,529 --> 00:16:47,279
know what I've been working on for the

00:16:44,910 --> 00:16:50,190
last six months there's a number of

00:16:47,279 --> 00:16:54,830
problems with the schema that has been

00:16:50,190 --> 00:16:59,029
used by RPM for years all right and I

00:16:54,830 --> 00:17:02,430
I've never really been able to tune

00:16:59,029 --> 00:17:04,620
berkeley DB performance to try and

00:17:02,430 --> 00:17:09,329
minimize the overhead that you're

00:17:04,620 --> 00:17:13,530
mentioning I so a large part of the work

00:17:09,329 --> 00:17:18,650
was preparing the infrastructure to take

00:17:13,530 --> 00:17:23,819
in a Berkeley DB transactional machine

00:17:18,650 --> 00:17:28,560
but in order to succeed at that I have

00:17:23,819 --> 00:17:33,960
to be no slower than I was before so I

00:17:28,560 --> 00:17:36,929
had to fix a lot of the flaws in the

00:17:33,960 --> 00:17:41,060
current schema I've achieved at least a

00:17:36,929 --> 00:17:45,840
tenfold improvement in performance which

00:17:41,060 --> 00:17:47,520
since for logging operate operations you

00:17:45,840 --> 00:17:49,800
essentially you know have to do

00:17:47,520 --> 00:17:54,000
everything twice right once the log and

00:17:49,800 --> 00:17:58,140
one son of the file system I well tens

00:17:54,000 --> 00:18:04,040
bigger than two I the way that this has

00:17:58,140 --> 00:18:08,940
been done is to berkeley DB will use an

00:18:04,040 --> 00:18:12,860
nmap to move information from the

00:18:08,940 --> 00:18:17,840
database our p.m. also does a mapped i/o

00:18:12,860 --> 00:18:21,230
so the second copy is not that expensive

00:18:17,840 --> 00:18:21,230
all right I

00:18:21,270 --> 00:18:29,570
almost all of the overhead of reading a

00:18:24,630 --> 00:18:32,550
database once the resource cap is

00:18:29,570 --> 00:18:36,030
changed to permit you know up to let's

00:18:32,550 --> 00:18:41,370
say a quarter of the machine to be

00:18:36,030 --> 00:18:47,310
memory map the i/o overhead on a

00:18:41,370 --> 00:18:54,560
database largely disappears I writing to

00:18:47,310 --> 00:19:00,110
a second location from a memory map is

00:18:54,560 --> 00:19:03,120
also not that significant in overhead

00:19:00,110 --> 00:19:07,560
there is still the cost of the log

00:19:03,120 --> 00:19:11,850
itself and writing content in the log

00:19:07,560 --> 00:19:17,160
you know if you actually try and

00:19:11,850 --> 00:19:25,050
preserve those logs over time it becomes

00:19:17,160 --> 00:19:27,510
quite significant the at the moment what

00:19:25,050 --> 00:19:31,710
I'm doing is every successful rpm

00:19:27,510 --> 00:19:34,410
operation creates a checkpoint by

00:19:31,710 --> 00:19:40,290
creating a checkpoint I'm establishing a

00:19:34,410 --> 00:19:42,240
base that you know determines you know

00:19:40,290 --> 00:19:46,230
how far back in history do I want to go

00:19:42,240 --> 00:19:48,360
and clearly nobody cares what was done

00:19:46,230 --> 00:19:51,240
on a machine one year ago I mean people

00:19:48,360 --> 00:19:54,930
care but not most users all right and

00:19:51,240 --> 00:19:57,350
you don't need gigabytes of logs you

00:19:54,930 --> 00:20:00,720
know going back forever in most cases

00:19:57,350 --> 00:20:02,640
okay the cases where you do care I mean

00:20:00,720 --> 00:20:05,910
it's important and you'll allocate

00:20:02,640 --> 00:20:11,670
resources to maintain those logs but not

00:20:05,910 --> 00:20:15,840
for an end user machine I what I'm

00:20:11,670 --> 00:20:18,120
seeing is that by paying attention and

00:20:15,840 --> 00:20:20,130
changing the schema and I'll describe

00:20:18,120 --> 00:20:21,960
some of the details in a moment because

00:20:20,130 --> 00:20:25,380
that is the most important point and

00:20:21,960 --> 00:20:26,970
things like rebuild DB I are not the

00:20:25,380 --> 00:20:29,430
right thing to do if you have a

00:20:26,970 --> 00:20:33,150
transactionally protected database and

00:20:29,430 --> 00:20:34,890
are no longer necessary either I what

00:20:33,150 --> 00:20:41,130
I'm actually measuring

00:20:34,890 --> 00:20:44,340
is that I is quite feasible to switch

00:20:41,130 --> 00:20:46,980
from the concurrent access model that

00:20:44,340 --> 00:20:50,550
our p.m. is using now to a

00:20:46,980 --> 00:20:54,080
transactionally protected module if the

00:20:50,550 --> 00:20:57,570
schema changes at the same time and

00:20:54,080 --> 00:21:00,690
there's measurable increase lock over

00:20:57,570 --> 00:21:04,050
hood over head but you know the overall

00:21:00,690 --> 00:21:07,170
wall clock measurements are about the

00:21:04,050 --> 00:21:10,980
same and the saving the previous

00:21:07,170 --> 00:21:13,170
transaction is probably a tolerable you

00:21:10,980 --> 00:21:16,280
know saving so that if you have an

00:21:13,170 --> 00:21:20,370
interrupted action that you can restore

00:21:16,280 --> 00:21:24,060
the metadata store and take out the side

00:21:20,370 --> 00:21:26,250
effects of a broken install is probably

00:21:24,060 --> 00:21:29,430
worth the effort but that's not for me

00:21:26,250 --> 00:21:35,270
to say this is my opinion okay I mean

00:21:29,430 --> 00:21:35,270
and I do have deep mixed feelings about

00:21:36,890 --> 00:21:41,100
about logging and transactional

00:21:39,180 --> 00:21:47,490
protection there's basically two

00:21:41,100 --> 00:21:51,180
approaches to trying to improve

00:21:47,490 --> 00:21:52,920
reliability I one of them is what I'm

00:21:51,180 --> 00:21:55,440
talking about where you have a log on

00:21:52,920 --> 00:21:59,550
the local machine the other one is

00:21:55,440 --> 00:22:01,860
called i call it provisioning and that's

00:21:59,550 --> 00:22:04,140
basically you take the state off the

00:22:01,860 --> 00:22:07,410
machine and put it someplace this is

00:22:04,140 --> 00:22:09,570
basically what redhead network does this

00:22:07,410 --> 00:22:11,700
is the sort of google model you know and

00:22:09,570 --> 00:22:14,120
I call it provisioning because you can

00:22:11,700 --> 00:22:16,740
always recreate the machine and

00:22:14,120 --> 00:22:21,900
provisioning as an approach to the same

00:22:16,740 --> 00:22:23,760
problem has two major benefits first of

00:22:21,900 --> 00:22:24,960
all it's always off the machine so you

00:22:23,760 --> 00:22:28,530
never have to worry about hardware

00:22:24,960 --> 00:22:32,570
failures and things like that and second

00:22:28,530 --> 00:22:38,250
it's usually centrally located which

00:22:32,570 --> 00:22:40,620
minimizes the maintenance cost of it the

00:22:38,250 --> 00:22:43,470
disadvantages of a provisioning approach

00:22:40,620 --> 00:22:47,690
is you often don't have the sufficient

00:22:43,470 --> 00:22:49,759
number of details to track all this

00:22:47,690 --> 00:22:53,840
the detailed state this is better done

00:22:49,759 --> 00:22:57,799
on a target machine on a client machine

00:22:53,840 --> 00:23:00,350
and with a log there's a balance point

00:22:57,799 --> 00:23:03,409
someplace between those two all right

00:23:00,350 --> 00:23:06,860
but rpm and package management in

00:23:03,409 --> 00:23:10,070
general is is a client only it's not

00:23:06,860 --> 00:23:12,200
tied to a server so I'm solving that

00:23:10,070 --> 00:23:14,419
problem but the other one exists and

00:23:12,200 --> 00:23:17,509
there's nothing you know better or worse

00:23:14,419 --> 00:23:24,860
with it that answered the question yes

00:23:17,509 --> 00:23:27,500
absolutely okay since I just described

00:23:24,860 --> 00:23:30,590
the two sort of general alternatives

00:23:27,500 --> 00:23:33,470
provisioning versus transactional

00:23:30,590 --> 00:23:36,850
protection I probably should say I

00:23:33,470 --> 00:23:40,429
described some of the other approaches I

00:23:36,850 --> 00:23:46,610
one of the approaches has been from

00:23:40,429 --> 00:23:51,740
nexenta with ZFS and young in fedora is

00:23:46,610 --> 00:23:58,279
attempting to use bitter FS and file

00:23:51,740 --> 00:24:02,330
system snapshots I these are definitely

00:23:58,279 --> 00:24:04,370
viable approaches I the problem is is

00:24:02,330 --> 00:24:12,500
that if you're going to use something

00:24:04,370 --> 00:24:15,350
like a ZFS or bitter FS a snapshot you

00:24:12,500 --> 00:24:19,669
first are stuck with some of the

00:24:15,350 --> 00:24:22,509
artifacts of being a filesystem ZFS you

00:24:19,669 --> 00:24:25,669
know can perform snapshots / mount point

00:24:22,509 --> 00:24:27,470
okay a package can install and several

00:24:25,669 --> 00:24:30,860
mount points and so you have the snarl

00:24:27,470 --> 00:24:34,519
of package side effects across multiple

00:24:30,860 --> 00:24:38,480
mount points that makes it more complex

00:24:34,519 --> 00:24:39,559
than otherwise the intrinsic flaw is if

00:24:38,480 --> 00:24:42,289
you're going to use a file system

00:24:39,559 --> 00:24:43,970
approach you know to let's say minimize

00:24:42,289 --> 00:24:46,519
you know the number of rights or

00:24:43,970 --> 00:24:48,379
overhead or something like that is that

00:24:46,519 --> 00:24:51,500
you must have that file system in the

00:24:48,379 --> 00:24:54,860
kernel and neither bitter FS or ZFS are

00:24:51,500 --> 00:24:58,240
sufficiently widely deployed you know

00:24:54,860 --> 00:24:59,470
our pin 5 runs on every unix insight

00:24:58,240 --> 00:25:02,770
it's

00:24:59,470 --> 00:25:05,020
in mac OS x and lots of other places and

00:25:02,770 --> 00:25:07,210
I'm finding myself talking to people

00:25:05,020 --> 00:25:10,419
about even you know doing RPM on windows

00:25:07,210 --> 00:25:13,870
okay you can't bet on things like bitter

00:25:10,419 --> 00:25:16,510
FS or ZFS you know as a general approach

00:25:13,870 --> 00:25:21,429
that's part of the reason why I decided

00:25:16,510 --> 00:25:26,080
to just use berkeley DB rather than to

00:25:21,429 --> 00:25:30,960
rely on a snapshot in a file system you

00:25:26,080 --> 00:25:30,960
know a snapshot is basically a cheap

00:25:31,620 --> 00:25:38,679
it's essentially a checkpoint on a file

00:25:34,150 --> 00:25:42,940
system with a copy on write attached so

00:25:38,679 --> 00:25:44,919
at the checkpoint the current state is

00:25:42,940 --> 00:25:46,630
known and anything that changes from

00:25:44,919 --> 00:25:49,570
that point you know is tracked

00:25:46,630 --> 00:25:51,820
separately with some sort of overlay if

00:25:49,570 --> 00:26:05,460
you will that's the way I pictured like

00:25:51,820 --> 00:26:11,250
a filesystem snapshot a log internal to

00:26:05,460 --> 00:26:17,220
RPM is essentially the same operation

00:26:11,250 --> 00:26:21,370
the real difference in the performance

00:26:17,220 --> 00:26:26,080
measurement is basically what you choose

00:26:21,370 --> 00:26:29,320
to count or how you choose to count the

00:26:26,080 --> 00:26:32,080
resource usage like clock ticks or you

00:26:29,320 --> 00:26:33,669
know a number of blocks of i/o but all

00:26:32,080 --> 00:26:36,490
logging approaches are going to be the

00:26:33,669 --> 00:26:38,940
same you have to write a copy before you

00:26:36,490 --> 00:26:41,500
know actually performing some operation

00:26:38,940 --> 00:26:44,830
but the point I was trying to make is

00:26:41,500 --> 00:26:48,909
that I trends actually protected package

00:26:44,830 --> 00:26:51,429
management is not the same as a

00:26:48,909 --> 00:26:54,580
filesystem snapshot these are

00:26:51,429 --> 00:27:00,000
complementary approaches to essentially

00:26:54,580 --> 00:27:01,840
the same problem another thing that

00:27:00,000 --> 00:27:04,870
transactionally protected package

00:27:01,840 --> 00:27:10,330
management is not about is let's say a

00:27:04,870 --> 00:27:12,039
representation of the log you know I if

00:27:10,330 --> 00:27:12,669
you're trying something like the

00:27:12,039 --> 00:27:15,399
modeling

00:27:12,669 --> 00:27:18,190
you often modeling that Mancusi is doing

00:27:15,399 --> 00:27:21,909
you often have to try and come up with a

00:27:18,190 --> 00:27:24,279
reasonable format see UDF is one I'm

00:27:21,909 --> 00:27:26,710
quite sure that there's another one

00:27:24,279 --> 00:27:29,409
coming from mancusi work project three

00:27:26,710 --> 00:27:31,210
that describes the elements of a

00:27:29,409 --> 00:27:35,549
rollback each one of these is a

00:27:31,210 --> 00:27:37,869
different format each one of these is a

00:27:35,549 --> 00:27:40,659
different representation of the same

00:27:37,869 --> 00:27:44,109
information but describing things

00:27:40,659 --> 00:27:49,769
differently is in a different type of

00:27:44,109 --> 00:27:55,299
markup I for different usage cases is

00:27:49,769 --> 00:27:58,149
not exactly what the it's a different

00:27:55,299 --> 00:27:59,950
meaning of log okay and that's not what

00:27:58,149 --> 00:28:02,049
I'm talking about with transactional you

00:27:59,950 --> 00:28:06,669
protected package management the state

00:28:02,049 --> 00:28:09,029
machine for rolling back of transaction

00:28:06,669 --> 00:28:11,919
is actually quite different than a

00:28:09,029 --> 00:28:15,100
package state machine which you know

00:28:11,919 --> 00:28:20,980
does erase the old package and update

00:28:15,100 --> 00:28:22,570
with the newer content so the log is

00:28:20,980 --> 00:28:24,580
pretty much internal and the

00:28:22,570 --> 00:28:27,909
representation can always be retrofitted

00:28:24,580 --> 00:28:29,859
later since I'm reaching about 15

00:28:27,909 --> 00:28:32,859
minutes let me go through some of the

00:28:29,859 --> 00:28:35,710
details that have already been

00:28:32,859 --> 00:28:40,379
implemented with database rather shortly

00:28:35,710 --> 00:28:43,779
but one of the important elements is

00:28:40,379 --> 00:28:47,679
that their tools that are going to be

00:28:43,779 --> 00:28:49,779
needed that will be external to RPM the

00:28:47,679 --> 00:28:52,059
most important if you bring nothing else

00:28:49,779 --> 00:28:55,889
away from them this talk if you're

00:28:52,059 --> 00:28:59,649
trying to use a transaction model

00:28:55,889 --> 00:29:03,159
rebuild DB won't help you but the

00:28:59,649 --> 00:29:05,889
alternative is DB recover minus EV all

00:29:03,159 --> 00:29:08,409
right since most of the world is fixing

00:29:05,889 --> 00:29:12,039
our p.m. side effects by attempting

00:29:08,409 --> 00:29:14,669
rebuild DB it won't hurt you but it's

00:29:12,039 --> 00:29:18,940
not going to save you DB recover will

00:29:14,669 --> 00:29:20,529
the log management and particularly the

00:29:18,940 --> 00:29:23,080
checkpointing which is the most

00:29:20,529 --> 00:29:26,200
important element at reducing log size

00:29:23,080 --> 00:29:29,940
is the tool needed

00:29:26,200 --> 00:29:34,630
is DB checkpoint and that puts in a

00:29:29,940 --> 00:29:39,160
boundary which in time that says this is

00:29:34,630 --> 00:29:44,140
the last known good to get rid of older

00:29:39,160 --> 00:29:46,720
logs the tool is DB archive and these

00:29:44,140 --> 00:29:50,890
are you will need tools to manage your

00:29:46,720 --> 00:29:53,530
database and I haven't yet even

00:29:50,890 --> 00:29:57,660
considered the question of compatibility

00:29:53,530 --> 00:29:59,590
with older versions of RPM I

00:29:57,660 --> 00:30:04,090
compatibility is going to be rather

00:29:59,590 --> 00:30:05,920
tricky because essentially lots of the

00:30:04,090 --> 00:30:09,580
elements that used to be an RPM no

00:30:05,920 --> 00:30:12,190
longer exists most specifically is there

00:30:09,580 --> 00:30:14,110
are no joined keys these are integer

00:30:12,190 --> 00:30:16,780
identifiers for packages that were

00:30:14,110 --> 00:30:19,410
monotonically increasing and since those

00:30:16,780 --> 00:30:22,810
don't exist you know I'm not sure how

00:30:19,410 --> 00:30:26,500
compatibility can be meaningfully

00:30:22,810 --> 00:30:29,380
defined I hope to do it by providing

00:30:26,500 --> 00:30:32,080
conversion you know conversion from one

00:30:29,380 --> 00:30:34,600
to the other is an acceptable way of

00:30:32,080 --> 00:30:36,400
achieving compatibility but that's not

00:30:34,600 --> 00:30:41,590
the same thing as interoperable

00:30:36,400 --> 00:30:44,140
compatibility the all integers are now

00:30:41,590 --> 00:30:46,560
saved in network order this means

00:30:44,140 --> 00:30:50,800
cross-platform is now meaningful

00:30:46,560 --> 00:30:55,200
previously RPM saved in net in native

00:30:50,800 --> 00:30:58,930
order all the time but network order I

00:30:55,200 --> 00:31:01,420
permits binary strings and integers to

00:30:58,930 --> 00:31:03,430
be dealt with equivalently using a mem

00:31:01,420 --> 00:31:06,090
compare which is important for be tree

00:31:03,430 --> 00:31:10,770
access and that also is a performance

00:31:06,090 --> 00:31:10,770
increased by switching to network order

00:31:12,960 --> 00:31:17,200
one of the other incompatibilities

00:31:15,070 --> 00:31:24,730
that's been introduced is that berkeley

00:31:17,200 --> 00:31:27,220
DB provides a counter that does that

00:31:24,730 --> 00:31:31,450
monotonically increases previously this

00:31:27,220 --> 00:31:35,530
was done with a weird hack by using

00:31:31,450 --> 00:31:38,890
record number zero in the primary store

00:31:35,530 --> 00:31:43,090
as if it were an instance counter

00:31:38,890 --> 00:31:47,590
by using a persistent number there is

00:31:43,090 --> 00:31:51,340
now a identifier that is durable over

00:31:47,590 --> 00:31:54,000
time some of the other performance

00:31:51,340 --> 00:31:58,380
improvements is I'm now able to do a

00:31:54,000 --> 00:32:03,730
pattern retrieves on keys which means

00:31:58,380 --> 00:32:08,340
this is much higher performing than what

00:32:03,730 --> 00:32:11,950
RPM has done in the past which is a

00:32:08,340 --> 00:32:15,310
secondary look up with a header load and

00:32:11,950 --> 00:32:18,700
marshaling and signature checking that

00:32:15,310 --> 00:32:21,370
the actual database side effects of the

00:32:18,700 --> 00:32:25,240
retrieval this is where most of the

00:32:21,370 --> 00:32:29,700
performance and treatment performance

00:32:25,240 --> 00:32:31,840
improvements that I've achieved reside

00:32:29,700 --> 00:32:34,170
one of the other sort of deep

00:32:31,840 --> 00:32:39,130
fundamental infrastructure changes is

00:32:34,170 --> 00:32:42,280
that signatures and digests are no

00:32:39,130 --> 00:32:43,720
longer verified the actual there hasn't

00:32:42,280 --> 00:32:46,470
been a problem that has been detected

00:32:43,720 --> 00:32:50,140
with a signature digest check on a

00:32:46,470 --> 00:32:55,180
database blob for quite some time and so

00:32:50,140 --> 00:33:00,640
what I'm doing instead now is I using M

00:32:55,180 --> 00:33:04,570
map and prot read to protect the blob

00:33:00,640 --> 00:33:08,680
when it's red okay there's pretty

00:33:04,570 --> 00:33:12,610
clearly no reason to verify the digest

00:33:08,680 --> 00:33:15,660
and signature on a blob of binary data

00:33:12,610 --> 00:33:19,560
that is Hardware protected and that

00:33:15,660 --> 00:33:23,620
removed a very large amount of overhead

00:33:19,560 --> 00:33:25,720
reading headers from a database and it's

00:33:23,620 --> 00:33:33,430
a big chunk of the tenfold performance

00:33:25,720 --> 00:33:34,320
improvement that I've gotten that's

00:33:33,430 --> 00:33:37,110
about

00:33:34,320 --> 00:33:39,870
you know because of time is I'm much

00:33:37,110 --> 00:33:43,139
more interested in questions if you want

00:33:39,870 --> 00:33:47,909
me to continue I can go into some of the

00:33:43,139 --> 00:33:51,029
the way that scriptlet acid will be

00:33:47,909 --> 00:33:54,169
achieved okay having heard John

00:33:51,029 --> 00:33:57,509
Thompson's talk this morning okay that

00:33:54,169 --> 00:34:00,269
rapidly got changed since ten o'clock

00:33:57,509 --> 00:34:03,769
this morning but i can try and flesh out

00:34:00,269 --> 00:34:08,700
some of the details that i think to

00:34:03,769 --> 00:34:11,460
where the connection between the work

00:34:08,700 --> 00:34:15,270
that jim thompson and Paolo and caisson

00:34:11,460 --> 00:34:21,030
magica are doing is going to fit into

00:34:15,270 --> 00:34:24,060
this or I can also just try and field

00:34:21,030 --> 00:34:26,849
some questions you know I it's up to you

00:34:24,060 --> 00:34:28,800
other questions or yes yeah I have

00:34:26,849 --> 00:34:31,679
another question unimportant it is for

00:34:28,800 --> 00:34:32,909
you backward compatibility you mentioned

00:34:31,679 --> 00:34:35,040
that the new version you are developing

00:34:32,909 --> 00:34:37,740
now of RPM breaks compared to the old

00:34:35,040 --> 00:34:40,230
one all you need to provide a madam to

00:34:37,740 --> 00:34:43,050
transition from one to another isn't

00:34:40,230 --> 00:34:45,629
some time that necessary just break and

00:34:43,050 --> 00:34:49,619
say now we start clean so to speak and

00:34:45,629 --> 00:34:52,710
move on well compatibility depends on

00:34:49,619 --> 00:34:55,560
what's being talked about and as does

00:34:52,710 --> 00:34:59,480
break all right and I'm not trying to

00:34:55,560 --> 00:35:03,599
break things without reason all right

00:34:59,480 --> 00:35:09,720
most of the problems with the RPM schema

00:35:03,599 --> 00:35:13,260
of known for a long time and and I've

00:35:09,720 --> 00:35:18,300
lived with that but yes there's times to

00:35:13,260 --> 00:35:25,589
break I've just been notified five

00:35:18,300 --> 00:35:28,430
minutes but any other questions okay

00:35:25,589 --> 00:35:28,430
there you go

00:35:42,269 --> 00:35:48,220
yeah so I might be a bit off here

00:35:45,789 --> 00:35:50,079
because I'm not really involved with RPM

00:35:48,220 --> 00:35:52,210
distribution but I as I understand it is

00:35:50,079 --> 00:35:54,759
also an option within RPM to do

00:35:52,210 --> 00:35:58,900
scriptlets installation maybe you cover

00:35:54,759 --> 00:36:00,700
this so um how do you plan to do to roll

00:35:58,900 --> 00:36:02,289
back those scriptlets through group they

00:36:00,700 --> 00:36:05,849
maybe create a smile they may be doing

00:36:02,289 --> 00:36:10,230
stuff okay the the tarc by Jim Thompson

00:36:05,849 --> 00:36:15,789
this John Thompson this morning was

00:36:10,230 --> 00:36:19,299
about using a DSL to break a scrip 'let

00:36:15,789 --> 00:36:22,390
into smaller pieces all right the

00:36:19,299 --> 00:36:26,950
fundamental problem with scripts in

00:36:22,390 --> 00:36:29,710
packaging I is that they're too coarse

00:36:26,950 --> 00:36:32,259
grained and they're Oh opaque you know

00:36:29,710 --> 00:36:35,259
you have the general cases you have side

00:36:32,259 --> 00:36:44,950
effects and the side effects need to be

00:36:35,259 --> 00:36:48,789
captured somehow the benefit that I see

00:36:44,950 --> 00:36:52,749
from the dsl is that it will be possible

00:36:48,789 --> 00:36:55,779
not just to look at the exit code from a

00:36:52,749 --> 00:36:58,630
script which is all the information that

00:36:55,779 --> 00:37:00,779
is being returned but it will be

00:36:58,630 --> 00:37:05,499
possible it was even in one of John's

00:37:00,779 --> 00:37:08,710
examples that he Illustrated that there

00:37:05,499 --> 00:37:10,869
were two operations within a single

00:37:08,710 --> 00:37:12,970
scriptlet and that's fundamentally the

00:37:10,869 --> 00:37:17,170
problem if you have like a configuration

00:37:12,970 --> 00:37:20,289
change and a daemon restart and other

00:37:17,170 --> 00:37:23,559
side effects you know it's possible to

00:37:20,289 --> 00:37:26,460
have one of them fail and it being

00:37:23,559 --> 00:37:30,180
unimportant while the other ones are

00:37:26,460 --> 00:37:34,450
absolutely essential to the operation I

00:37:30,180 --> 00:37:36,579
so by having finer grain then it becomes

00:37:34,450 --> 00:37:39,069
possible to come up with partial

00:37:36,579 --> 00:37:41,769
failures or and partially invertible

00:37:39,069 --> 00:37:44,259
failures the other benefit will be in

00:37:41,769 --> 00:37:46,049
simulation and modeling okay because

00:37:44,259 --> 00:37:48,519
scriptlets are often in shell it's

00:37:46,049 --> 00:37:50,510
painful to do anything other than

00:37:48,519 --> 00:37:53,030
de-facto

00:37:50,510 --> 00:37:58,210
testing of the scripts by simulating and

00:37:53,030 --> 00:38:02,720
modeling other properties such as I

00:37:58,210 --> 00:38:05,350
ensuring that prerequisites that aren't

00:38:02,720 --> 00:38:09,650
specified in the ordering the package

00:38:05,350 --> 00:38:14,000
are actually met and what I hope to do

00:38:09,650 --> 00:38:17,120
is to use that dsl breaking it up into

00:38:14,000 --> 00:38:20,090
smaller pieces and map those pieces into

00:38:17,120 --> 00:38:23,270
a log as a starting event in a failure

00:38:20,090 --> 00:38:25,610
event I the other more traditional

00:38:23,270 --> 00:38:28,300
approach is scriptlets run in an

00:38:25,610 --> 00:38:31,460
environment and that environment is

00:38:28,300 --> 00:38:33,770
needs to be captured in the log okay

00:38:31,460 --> 00:38:38,270
what the environment variables were okay

00:38:33,770 --> 00:38:42,640
what the prerequisites are to some

00:38:38,270 --> 00:38:46,010
extent that provides a level of acid and

00:38:42,640 --> 00:38:48,680
invertibility all right the problem is

00:38:46,010 --> 00:38:51,890
is that this is a general programmatic

00:38:48,680 --> 00:38:53,840
language and so things like typos I you

00:38:51,890 --> 00:38:57,080
know cannot be tolerated all right but

00:38:53,840 --> 00:38:59,390
these are not very interesting problems

00:38:57,080 --> 00:39:01,640
they are important problems that have to

00:38:59,390 --> 00:39:03,500
be solved but it is a very hard problem

00:39:01,640 --> 00:39:05,540
to get acid underneath scriptlet

00:39:03,500 --> 00:39:07,070
behavior does that answer the question

00:39:05,540 --> 00:39:10,250
almost there's just one more thing

00:39:07,070 --> 00:39:12,050
actually what I basically meant is if

00:39:10,250 --> 00:39:13,820
one of those kids let's create a file or

00:39:12,050 --> 00:39:16,040
AB it's a configuration file or whatever

00:39:13,820 --> 00:39:18,620
and you find figure out later that you

00:39:16,040 --> 00:39:20,420
need to undo the upgrades for some

00:39:18,620 --> 00:39:23,510
reason that you should basically maybe

00:39:20,420 --> 00:39:25,670
also undo what script I did turn script

00:39:23,510 --> 00:39:27,530
is there need to be invertible yeah

00:39:25,670 --> 00:39:29,150
alright and there needs to be an undo

00:39:27,530 --> 00:39:31,190
that's why the same on the same

00:39:29,150 --> 00:39:32,750
invertibility happens when you install

00:39:31,190 --> 00:39:34,640
the file I mean if you're writing

00:39:32,750 --> 00:39:36,920
content or you're removing a file yeah

00:39:34,640 --> 00:39:38,450
but there's probably some some way for

00:39:36,920 --> 00:39:39,950
the script with them to communicate the

00:39:38,450 --> 00:39:42,260
RPM that hey I've modified this father

00:39:39,950 --> 00:39:46,490
or is that why I don't know a better

00:39:42,260 --> 00:39:48,590
communication will be the means by which

00:39:46,490 --> 00:39:50,990
asset is achieved under scriptlet

00:39:48,590 --> 00:39:54,230
behavior all right all right okay right

00:39:50,990 --> 00:39:56,630
and it's the same basic effect that you

00:39:54,230 --> 00:39:59,390
log any operation before it's performed

00:39:56,630 --> 00:40:01,610
the complexity comes solely from using

00:39:59,390 --> 00:40:04,310
bourne shell which is painful all right

00:40:01,610 --> 00:40:06,710
right and embedding isn't

00:40:04,310 --> 00:40:09,530
other approach that could be used like

00:40:06,710 --> 00:40:11,510
either embedded Luet and then RPM is

00:40:09,530 --> 00:40:13,520
more aware of the actual operations of

00:40:11,510 --> 00:40:16,730
there but the general approach is just

00:40:13,520 --> 00:40:20,600
to use the 55 operations and Deb helper

00:40:16,730 --> 00:40:22,250
and to parameterize those I and that's a

00:40:20,600 --> 00:40:24,770
perfectly sound starting point because

00:40:22,250 --> 00:40:28,160
that's the order of magnitude of the

00:40:24,770 --> 00:40:31,910
side effects of package management and

00:40:28,160 --> 00:40:42,770
this isn't a large corpus ok don't you

00:40:31,910 --> 00:40:45,950
write any other questions yes and what

00:40:42,770 --> 00:40:47,600
do you think about the knicks OS package

00:40:45,950 --> 00:40:51,410
management system which is a purely

00:40:47,600 --> 00:40:55,420
functional way and we check out most of

00:40:51,410 --> 00:40:59,210
side effects I like it a lot I've been

00:40:55,420 --> 00:41:05,270
talking to elko I I started about a year

00:40:59,210 --> 00:41:07,520
ago and I from a package manager point

00:41:05,270 --> 00:41:10,340
of view the single biggest failure mode

00:41:07,520 --> 00:41:14,810
at the moment in packaging is scripts

00:41:10,340 --> 00:41:16,520
buggy scripts you know and that it's not

00:41:14,810 --> 00:41:19,480
only buggy but scripts that aren't

00:41:16,520 --> 00:41:22,730
written generally enough all right and

00:41:19,480 --> 00:41:27,260
my private view is that I need to remove

00:41:22,730 --> 00:41:30,770
all scripts from RPM if I say that in

00:41:27,260 --> 00:41:33,320
public and I didn't say it here okay if

00:41:30,770 --> 00:41:36,850
I actually remove all the scripts I'm

00:41:33,320 --> 00:41:40,010
going to also appear to remove all

00:41:36,850 --> 00:41:42,710
programmatic means to change packaging

00:41:40,010 --> 00:41:47,030
okay this is the same decision point

00:41:42,710 --> 00:41:49,700
that everybody faces switching from to a

00:41:47,030 --> 00:41:52,100
functional model you have to think about

00:41:49,700 --> 00:41:54,230
the problem space very different all

00:41:52,100 --> 00:41:56,510
right but from a package manager point

00:41:54,230 --> 00:41:58,880
of view I have two alternatives I go the

00:41:56,510 --> 00:42:01,160
Nexus route and I say no scripts and

00:41:58,880 --> 00:42:03,380
everybody hates me and then I retrofit

00:42:01,160 --> 00:42:06,890
the same actions okay through other

00:42:03,380 --> 00:42:10,130
means or I take a slow and gradual

00:42:06,890 --> 00:42:12,980
approach to a functional okay where the

00:42:10,130 --> 00:42:14,900
first step is to use Deb helper and then

00:42:12,980 --> 00:42:17,450
to break dead helper into smaller pieces

00:42:14,900 --> 00:42:19,900
and you

00:42:17,450 --> 00:42:23,380
moving gradually towards you know

00:42:19,900 --> 00:42:26,680
refactoring code fewer side effects and

00:42:23,380 --> 00:42:29,660
eventually achieve a functional model I

00:42:26,680 --> 00:42:32,839
don't know what the answer is but I'd

00:42:29,660 --> 00:42:35,180
like Nexus a lot eat some things that

00:42:32,839 --> 00:42:37,310
you are going to try in Monaco see

00:42:35,180 --> 00:42:40,510
project to pretend i can't speak for

00:42:37,310 --> 00:42:44,359
mancusi but I i have tried to talk to

00:42:40,510 --> 00:42:47,710
the Nexus presentation you know I

00:42:44,359 --> 00:42:52,250
haven't yet found it but and I have

00:42:47,710 --> 00:42:54,530
considered this you know I the approach

00:42:52,250 --> 00:42:58,640
that will probably take will be to embed

00:42:54,530 --> 00:43:02,950
Haskell and try and do Nick sauce

00:42:58,640 --> 00:43:06,230
package management directly from RPM and

00:43:02,950 --> 00:43:09,230
to see whether that approach is viable

00:43:06,230 --> 00:43:10,880
all right I but I'm well aware of what

00:43:09,230 --> 00:43:16,839
Nexus is and I like functional

00:43:10,880 --> 00:43:16,839
programming I I don't do it ok but

00:43:16,900 --> 00:43:21,170
because it's just too hard to switch

00:43:19,310 --> 00:43:23,150
from one to the other you know I have a

00:43:21,170 --> 00:43:33,460
live in the real world and I'm a seed

00:43:23,150 --> 00:43:33,460
program but ok any other questions time

00:43:33,790 --> 00:43:37,000
how did I do

00:43:40,260 --> 00:43:42,320

YouTube URL: https://www.youtube.com/watch?v=wEZ9JKWt328


