Title: ParallelFx, bringing Mono applications in the multicore era
Publication date: 2011-12-22
Playlist: FOSDEM 2010
Description: 
	By Jeremie Laval

Multicore computer are now part of our everyday life. Most desktop and laptop machines out there bundle a dual-core processor, quad-core processor or even 8-core processor by default. This multiplication of the number of core on the same chip is destined to become the way for manufacturers to remain competitive. However, developers were a bit left out in this process, having written sequential programs for ages whereas they were now required to parallelize their program to make them efficient which isn't an easy step to take.

That's why we now see the apparition of framework designed to help programmers to take advantage of this new architecture of processor by hiding away the parallel difficulty under primitives that they are used to. ParallelFx is one of such framework for the Mono and .NET world. By providing several new parallel constructs and concurrent data structures, it allows Mono applications to enter painlessly in this new multicore era.

This talk will cover several points :

    * What options Mono provide to speed up applications today
    * A bit of background on the framework
    * The components ParallelFx provides
    * Some how-to and usage of the framework
    * Status of ParallelFx in Mono

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:08,160 --> 00:00:14,380
so hello everybody so as Ruben side

00:00:11,440 --> 00:00:16,480
story again it's again a talk on about

00:00:14,380 --> 00:00:19,330
improving performance of application in

00:00:16,480 --> 00:00:21,190
the middle so like actually that's a

00:00:19,330 --> 00:00:22,960
good thing so my name is Jeremy level

00:00:21,190 --> 00:00:26,560
and actually I would like to note that

00:00:22,960 --> 00:00:28,359
the work so I implemented partly fix for

00:00:26,560 --> 00:00:30,100
Moto I would like to say that this work

00:00:28,359 --> 00:00:31,990
was part of actually summer of code

00:00:30,100 --> 00:00:34,269
google Summer of Code so first of all I

00:00:31,990 --> 00:00:35,949
would like to thanks google and mono for

00:00:34,269 --> 00:00:38,909
allowing me to work on such a cool

00:00:35,949 --> 00:00:42,670
project with such cool people and well

00:00:38,909 --> 00:00:44,829
so i might work i'm going to first talk

00:00:42,670 --> 00:00:48,129
about why actually we have to bother

00:00:44,829 --> 00:00:50,499
with all this multi training stuff then

00:00:48,129 --> 00:00:52,449
i'm going to talk about all we can

00:00:50,499 --> 00:00:55,269
actually use that to improve performance

00:00:52,449 --> 00:00:57,429
in all range of application and then i

00:00:55,269 --> 00:01:00,909
will focus on politics in itself showing

00:00:57,429 --> 00:01:04,210
what you can use in parallel fix what is

00:01:00,909 --> 00:01:06,430
all the tasks oak or walk scheduler or

00:01:04,210 --> 00:01:09,370
walk spelling which is a very nice part

00:01:06,430 --> 00:01:12,010
of politics and finally oh I mean what's

00:01:09,370 --> 00:01:15,250
the state of thing actually in mono so

00:01:12,010 --> 00:01:17,020
how much it is implemented actually so

00:01:15,250 --> 00:01:19,750
first of all why are we bothering world

00:01:17,020 --> 00:01:22,210
that paralyzation stuff the thing is

00:01:19,750 --> 00:01:23,830
that everyone loves is single traded

00:01:22,210 --> 00:01:25,960
application because we have been taught

00:01:23,830 --> 00:01:27,100
to to program like this and i'm in every

00:01:25,960 --> 00:01:29,580
language pretty much every language

00:01:27,100 --> 00:01:34,090
walks on the single trade when you call

00:01:29,580 --> 00:01:37,090
but as a wise man said the ideal number

00:01:34,090 --> 00:01:39,220
of trade you should use is one so i

00:01:37,090 --> 00:01:42,130
agree with that but we are going to see

00:01:39,220 --> 00:01:46,570
that it must have a special twist about

00:01:42,130 --> 00:01:48,790
it and again we have bothering with

00:01:46,570 --> 00:01:51,340
paralyzation today because the free

00:01:48,790 --> 00:01:54,159
lunch is over I will explain what is

00:01:51,340 --> 00:01:55,960
exactly the French but basically the

00:01:54,159 --> 00:01:58,210
things that we need to change the way we

00:01:55,960 --> 00:02:01,330
could we have to throw away a bit our

00:01:58,210 --> 00:02:04,330
point of view all serial programming so

00:02:01,330 --> 00:02:08,349
what is exactly the fringe from about

00:02:04,330 --> 00:02:10,629
the 70s to 2005 chip manufacturer we're

00:02:08,349 --> 00:02:13,359
focusing when they were producing CPUs

00:02:10,629 --> 00:02:13,670
basically they were fighting over the

00:02:13,359 --> 00:02:16,280
clock

00:02:13,670 --> 00:02:18,500
speed of the CPUs so that was really

00:02:16,280 --> 00:02:23,390
cool because basically programmers could

00:02:18,500 --> 00:02:26,060
write a program say like in 1995 and it

00:02:23,390 --> 00:02:29,420
would run pretty well and like five

00:02:26,060 --> 00:02:32,780
years later actually maybe the so by

00:02:29,420 --> 00:02:35,360
Mulo I things like double dutch sure so

00:02:32,780 --> 00:02:37,280
basically the year later the clock speed

00:02:35,360 --> 00:02:38,959
of the CPU would have doubled so

00:02:37,280 --> 00:02:42,019
basically your application would be

00:02:38,959 --> 00:02:43,280
twice faster than the original so that

00:02:42,019 --> 00:02:45,620
was pretty cool because you had to do

00:02:43,280 --> 00:02:48,680
pretty much nothing and as time goes on

00:02:45,620 --> 00:02:51,290
your application just become faster well

00:02:48,680 --> 00:02:53,840
of course it's not a paradise because at

00:02:51,290 --> 00:02:56,450
some point you have the physical limit

00:02:53,840 --> 00:02:59,720
of actually the chip I mean you can't

00:02:56,450 --> 00:03:01,970
put too much transistor we have arrived

00:02:59,720 --> 00:03:03,319
actually so about two thousand five and

00:03:01,970 --> 00:03:06,110
you can actually see on the curve

00:03:03,319 --> 00:03:08,510
because from about so the 70s to pretty

00:03:06,110 --> 00:03:10,310
much 2005 this we are pretty much

00:03:08,510 --> 00:03:12,709
straight lines so it's like the clock

00:03:10,310 --> 00:03:15,950
speed actually increases each year but

00:03:12,709 --> 00:03:18,500
we are on the point that we can pretty

00:03:15,950 --> 00:03:20,930
much accelerate anymore your CPU so

00:03:18,500 --> 00:03:23,540
manufacturers are to find another way to

00:03:20,930 --> 00:03:28,400
actually remain competitive in the field

00:03:23,540 --> 00:03:31,310
of CPU manufacturing so the bottom line

00:03:28,400 --> 00:03:33,320
is that right now we can't count on that

00:03:31,310 --> 00:03:36,829
free lunch anymore and we have to change

00:03:33,320 --> 00:03:38,780
our way clock speed war is a no-go so

00:03:36,829 --> 00:03:41,930
the awesome idea that Intel forks and

00:03:38,780 --> 00:03:44,060
AMD force add was well we can scale

00:03:41,930 --> 00:03:46,400
vertically so let's just add more

00:03:44,060 --> 00:03:50,680
current skate or isn't Ali refers there

00:03:46,400 --> 00:03:53,630
is a problem because and actually so

00:03:50,680 --> 00:03:56,450
they decided to do that first be by

00:03:53,630 --> 00:03:58,790
putting like two core in one cpu so that

00:03:56,450 --> 00:04:00,829
was at first we had like the ranch of

00:03:58,790 --> 00:04:02,030
sorry i'm using intel name but well it

00:04:00,829 --> 00:04:04,040
would be the same for hindi bed

00:04:02,030 --> 00:04:06,530
basically well the pentium line which

00:04:04,040 --> 00:04:08,120
was only one core then they introduced

00:04:06,530 --> 00:04:10,549
the core duo which was like the first

00:04:08,120 --> 00:04:13,430
dual core processor then they moved on

00:04:10,549 --> 00:04:15,530
unlike quad-core processor and no

00:04:13,430 --> 00:04:18,200
recently their beliefs the i7 which is

00:04:15,530 --> 00:04:20,329
like eight ish core basically it's like

00:04:18,200 --> 00:04:22,640
their focal but h co is like a pair

00:04:20,329 --> 00:04:25,250
traded so for the system it's like there

00:04:22,640 --> 00:04:27,290
is a CO and now they are been designing

00:04:25,250 --> 00:04:32,390
prototype which has

00:04:27,290 --> 00:04:35,210
a cheek or the thing is that yeah so

00:04:32,390 --> 00:04:38,000
basically we can't take advantage of all

00:04:35,210 --> 00:04:40,970
that stuff like the way we use to with a

00:04:38,000 --> 00:04:42,920
clock speed because your application

00:04:40,970 --> 00:04:44,600
isn't going to be faster with as the

00:04:42,920 --> 00:04:45,980
number of you increase you have to do

00:04:44,600 --> 00:04:48,560
something in your application you have

00:04:45,980 --> 00:04:50,570
to actually break up walk so that you

00:04:48,560 --> 00:04:51,950
can have separate task I mean you can't

00:04:50,570 --> 00:04:54,320
you have to separate actually you work

00:04:51,950 --> 00:04:56,930
in multiple task so the actually edge of

00:04:54,320 --> 00:05:00,260
the car in your processor is doing

00:04:56,930 --> 00:05:02,450
something so the solution to actually

00:05:00,260 --> 00:05:04,100
remain competitive also in software is

00:05:02,450 --> 00:05:08,540
to break a prop and share it among

00:05:04,100 --> 00:05:12,410
course but as you can suppose it's not

00:05:08,540 --> 00:05:14,480
really that easy actually so as you can

00:05:12,410 --> 00:05:17,300
see even a cut as program due amici

00:05:14,480 --> 00:05:20,720
trading code so yeah the truth is that

00:05:17,300 --> 00:05:24,170
polarization is difficult thing it's odd

00:05:20,720 --> 00:05:26,660
so as Alan said you have to manage your

00:05:24,170 --> 00:05:28,280
trade you have to manage lock you have

00:05:26,660 --> 00:05:31,850
to be careful is that part of the code

00:05:28,280 --> 00:05:33,860
can it be called by multiple trail am I

00:05:31,850 --> 00:05:35,900
taking the lock in the right way am I

00:05:33,860 --> 00:05:40,430
releasing them in a right way because

00:05:35,900 --> 00:05:42,830
it's tedious to do that I'm supposed

00:05:40,430 --> 00:05:44,600
everyone was ever done which trading

00:05:42,830 --> 00:05:48,110
programming at some point out to debug

00:05:44,600 --> 00:05:52,910
deadlox and I'm pretty sure will agree

00:05:48,110 --> 00:05:54,710
that it's not a really nice business so

00:05:52,910 --> 00:05:56,720
and finally it's also most of time

00:05:54,710 --> 00:05:59,570
inefficient to actually manage the trade

00:05:56,720 --> 00:06:01,850
yourself because actually the question

00:05:59,570 --> 00:06:05,090
is so many tread should you use because

00:06:01,850 --> 00:06:08,060
if you use too few threads like say you

00:06:05,090 --> 00:06:10,250
are developing your vocal machine but

00:06:08,060 --> 00:06:12,140
use like to trade we aren't going to use

00:06:10,250 --> 00:06:15,080
all your core so basically it's under

00:06:12,140 --> 00:06:17,630
efficient but then if you is too much

00:06:15,080 --> 00:06:20,630
like you are using for tread on your

00:06:17,630 --> 00:06:22,970
local machine basically you have so

00:06:20,630 --> 00:06:24,740
actually the operating system can only

00:06:22,970 --> 00:06:27,020
run to try that time so if you're

00:06:24,740 --> 00:06:28,310
fortunate is going to change I mean at

00:06:27,020 --> 00:06:31,400
some point of time is going to change

00:06:28,310 --> 00:06:33,350
the Detroit which are executing and that

00:06:31,400 --> 00:06:35,000
create a lot of context switching and if

00:06:33,350 --> 00:06:36,380
your storage thread actually the context

00:06:35,000 --> 00:06:38,990
switching the course of context

00:06:36,380 --> 00:06:40,969
switching you your tread costs more that

00:06:38,990 --> 00:06:44,869
the actual optimization of running it

00:06:40,969 --> 00:06:46,489
and again that bring this point that

00:06:44,869 --> 00:06:47,509
what if the number of code change

00:06:46,489 --> 00:06:49,969
because you could develop your

00:06:47,509 --> 00:06:52,879
application unlike really big box with

00:06:49,969 --> 00:06:55,549
like eight course but again if you ship

00:06:52,879 --> 00:06:57,769
it to a guy we only have this more dual

00:06:55,549 --> 00:07:01,039
core even line monochord still exists

00:06:57,769 --> 00:07:05,749
it's going to actually perform very

00:07:01,039 --> 00:07:07,610
badly so well let's get it complicated

00:07:05,749 --> 00:07:09,559
so we need some keys principle in that

00:07:07,610 --> 00:07:11,209
we need already something different

00:07:09,559 --> 00:07:13,339
something that should automatically

00:07:11,209 --> 00:07:16,639
regulate trade at use Asia at one time

00:07:13,339 --> 00:07:18,589
basically like we went from compiled

00:07:16,639 --> 00:07:22,610
code to interpreted code or like Jade

00:07:18,589 --> 00:07:24,589
code get in compilation because we want

00:07:22,610 --> 00:07:27,309
to be able to optimize the code at

00:07:24,589 --> 00:07:29,539
runtime for a specific machine and

00:07:27,309 --> 00:07:32,329
actually we have to to find something

00:07:29,539 --> 00:07:35,589
analogous to that for Mitzi trading

00:07:32,329 --> 00:07:37,489
programming and the second point is that

00:07:35,589 --> 00:07:39,229
it should be as straightforward as

00:07:37,489 --> 00:07:42,199
possible because as I said most people

00:07:39,229 --> 00:07:44,719
are used to the way the code I mean the

00:07:42,199 --> 00:07:48,349
way we we are taught to program is ready

00:07:44,719 --> 00:07:49,699
to control so the shift from cultural

00:07:48,349 --> 00:07:51,829
programming to pilot program it should

00:07:49,699 --> 00:07:54,159
be as painless as possible if we want

00:07:51,829 --> 00:07:58,249
people to adopt this kind of programming

00:07:54,159 --> 00:08:01,159
so it should be ever mimicking familiar

00:07:58,249 --> 00:08:02,629
constrict that is to say well in

00:08:01,159 --> 00:08:04,999
parallel fix for example we have the

00:08:02,629 --> 00:08:07,459
parallel loops which act like any for

00:08:04,999 --> 00:08:09,169
loops you have been using for ages oh it

00:08:07,459 --> 00:08:12,079
should we use existing con we will in

00:08:09,169 --> 00:08:15,819
slight modification like one method call

00:08:12,079 --> 00:08:19,909
in just an added metal code for example

00:08:15,819 --> 00:08:22,909
so anti parallel fix so parallel fix is

00:08:19,909 --> 00:08:25,699
like it was developed by Microsoft like

00:08:22,909 --> 00:08:28,249
in two or three years ago and actually

00:08:25,699 --> 00:08:30,349
it was supposed at first to be bundled

00:08:28,249 --> 00:08:33,349
as separate library that actually since

00:08:30,349 --> 00:08:35,180
that it's going to be part of the world

00:08:33,349 --> 00:08:36,919
dot net for platform and actually

00:08:35,180 --> 00:08:40,550
paralytics is integrating in college so

00:08:36,919 --> 00:08:43,519
the very art of dotnet so oh it's

00:08:40,550 --> 00:08:46,910
parallely fix basically you have this

00:08:43,519 --> 00:08:48,559
part which is the actual primitive that

00:08:46,910 --> 00:08:50,290
you can use to to use parallel

00:08:48,559 --> 00:08:53,509
programming inside your application and

00:08:50,290 --> 00:08:54,769
the smaller part is like so really lower

00:08:53,509 --> 00:08:57,529
level part is all the schedule

00:08:54,769 --> 00:08:59,119
and its really is actually a really nice

00:08:57,529 --> 00:09:02,360
piece of technology going to talk about

00:08:59,119 --> 00:09:04,850
it lay just after and then you have like

00:09:02,360 --> 00:09:07,220
almost free building block that you can

00:09:04,850 --> 00:09:09,050
use lower low level building block which

00:09:07,220 --> 00:09:10,489
is the task so the task is basically

00:09:09,050 --> 00:09:13,429
like trade like you would use your

00:09:10,489 --> 00:09:15,769
normal tread future is like just build

00:09:13,429 --> 00:09:17,660
upon that and actually what I'm going to

00:09:15,769 --> 00:09:20,869
talk about that later so we have

00:09:17,660 --> 00:09:23,449
parallel oops pair link is like I hope

00:09:20,869 --> 00:09:24,889
everyone is familiar with link anyway if

00:09:23,449 --> 00:09:26,660
you have seen me talk you should be

00:09:24,889 --> 00:09:29,089
familiar with link so i will just say

00:09:26,660 --> 00:09:31,040
that you seen me go talk so which is

00:09:29,089 --> 00:09:34,579
actually a paralyzed version of link and

00:09:31,040 --> 00:09:36,290
then of course we can't we can do like

00:09:34,579 --> 00:09:38,959
this without any helper class so

00:09:36,290 --> 00:09:41,540
basically we have all a world new set of

00:09:38,959 --> 00:09:44,929
collection that our thread safe but

00:09:41,540 --> 00:09:47,540
which shouldn't use yeah trade

00:09:44,929 --> 00:09:51,170
circulation and also a world new set of

00:09:47,540 --> 00:09:53,749
coordination data structure so look all

00:09:51,170 --> 00:09:54,889
that sort of the barrier well any kind

00:09:53,749 --> 00:09:58,819
of thing that you could use in a merge

00:09:54,889 --> 00:10:00,589
traded on the environment again they are

00:09:58,819 --> 00:10:02,509
really specific because like for example

00:10:00,589 --> 00:10:04,429
the concurrent collection the trite we

00:10:02,509 --> 00:10:07,009
don't use lock because lock is really

00:10:04,429 --> 00:10:10,720
inefficient so it tries to actually be

00:10:07,009 --> 00:10:13,850
locked free what we call log free code

00:10:10,720 --> 00:10:16,009
so yeah so let's pick a bit about

00:10:13,850 --> 00:10:17,749
actually the world the scheduler so

00:10:16,009 --> 00:10:19,970
which is the art for the parallel fix

00:10:17,749 --> 00:10:22,189
library actually the scheduler is really

00:10:19,970 --> 00:10:24,709
nice piece of technology because instead

00:10:22,189 --> 00:10:27,350
of just creating like you would say

00:10:24,709 --> 00:10:30,170
instead of creating a trade for each

00:10:27,350 --> 00:10:34,100
task you do basically I mean some guys

00:10:30,170 --> 00:10:35,720
said earlier with island that basically

00:10:34,100 --> 00:10:37,389
in the number of thread you should be

00:10:35,720 --> 00:10:39,769
you should behaving in your application

00:10:37,389 --> 00:10:43,490
should be equal to the number of core

00:10:39,769 --> 00:10:46,569
that computer us this is really true so

00:10:43,490 --> 00:10:50,569
actually partly fix build upon that and

00:10:46,569 --> 00:10:52,009
it always manage an amount of tread that

00:10:50,569 --> 00:10:54,529
is equal to the number of co you have on

00:10:52,009 --> 00:10:57,470
your computer but of course it should

00:10:54,529 --> 00:10:59,929
also be able to under like 1000 task at

00:10:57,470 --> 00:11:02,209
the same time so you have to make a

00:10:59,929 --> 00:11:04,220
trade of you have to earn 1000 task on

00:11:02,209 --> 00:11:07,459
one hand but you also have to keep only

00:11:04,220 --> 00:11:08,480
to trade so actually the schedule is

00:11:07,459 --> 00:11:11,060
built on the works too

00:11:08,480 --> 00:11:13,610
principal basically a mono application

00:11:11,060 --> 00:11:16,220
feed the schedule or some task which

00:11:13,610 --> 00:11:17,779
first go into a shared walk pool so then

00:11:16,220 --> 00:11:20,209
the trade workers so the trail Walker is

00:11:17,779 --> 00:11:21,860
like simply a walker which wrap up a

00:11:20,209 --> 00:11:25,269
noise thread so annoyed straight is like

00:11:21,860 --> 00:11:27,680
system trading trading dot tread and

00:11:25,269 --> 00:11:31,010
then it takes up that work and really

00:11:27,680 --> 00:11:33,740
the cool part of it is like so let's say

00:11:31,010 --> 00:11:35,660
that for example you feed a 100 task to

00:11:33,740 --> 00:11:37,430
the scheduler then edged trade workers

00:11:35,660 --> 00:11:39,589
or if you have to trade worker let's say

00:11:37,430 --> 00:11:42,980
that edge trade worker process like 50

00:11:39,589 --> 00:11:44,930
task the thing is that most of time task

00:11:42,980 --> 00:11:47,089
are not do not take the same time to

00:11:44,930 --> 00:11:49,370
execute that's the world point of it so

00:11:47,089 --> 00:11:51,350
if it was just like the trail worker

00:11:49,370 --> 00:11:53,449
took some work and then execute what he

00:11:51,350 --> 00:11:56,600
has basically you add one Trent Walker

00:11:53,449 --> 00:11:58,010
which at some point run out of task so

00:11:56,600 --> 00:11:59,570
we would have won 12 worker which

00:11:58,010 --> 00:12:01,220
continue executing and basically you

00:11:59,570 --> 00:12:03,529
would have one trade which is wasted

00:12:01,220 --> 00:12:06,019
because it does nothing so the cool

00:12:03,529 --> 00:12:08,240
thing is that in parallel fix when the

00:12:06,019 --> 00:12:10,970
trade worker has no more work to do it

00:12:08,240 --> 00:12:12,860
will try to seek work to do in also

00:12:10,970 --> 00:12:16,459
trade workers so that's the steel part

00:12:12,860 --> 00:12:18,889
that way every thread at any time this

00:12:16,459 --> 00:12:20,360
tip should be still processing something

00:12:18,889 --> 00:12:23,750
that way you get the maximum performance

00:12:20,360 --> 00:12:26,510
out of your code yep behind keeping a

00:12:23,750 --> 00:12:29,870
local work who can't adjust each one's

00:12:26,510 --> 00:12:32,600
over time actually so as I said the

00:12:29,870 --> 00:12:34,399
problem basically you could do your work

00:12:32,600 --> 00:12:35,750
only we will share whirlpool so she'll

00:12:34,399 --> 00:12:39,470
walk which is like a normal collection

00:12:35,750 --> 00:12:41,060
we will look basically yes that's about

00:12:39,470 --> 00:12:43,339
on like because actually as I said you

00:12:41,060 --> 00:12:46,010
could you I mean politics should be able

00:12:43,339 --> 00:12:47,720
to endure like 1000 task at a time so if

00:12:46,010 --> 00:12:49,490
you do like what for the time acquire

00:12:47,720 --> 00:12:51,800
your luck really is a lock you're going

00:12:49,490 --> 00:12:54,470
to kill your performance so what we must

00:12:51,800 --> 00:12:56,690
ensure is that you have the maximum

00:12:54,470 --> 00:12:58,430
locality what we call locality is that

00:12:56,690 --> 00:13:00,649
basically a trade worker in normal

00:12:58,430 --> 00:13:03,199
operation should be doing any locking

00:13:00,649 --> 00:13:06,800
any interlock metal any cool like that

00:13:03,199 --> 00:13:08,160
any synchronization stuff so what is

00:13:06,800 --> 00:13:10,740
that

00:13:08,160 --> 00:13:13,920
each the train workers should only walk

00:13:10,740 --> 00:13:16,620
on what is local to him and actually

00:13:13,920 --> 00:13:18,420
only the steel process actually do some

00:13:16,620 --> 00:13:20,940
logging it's not working at least it's

00:13:18,420 --> 00:13:23,310
using interlocked Cass if anyone know

00:13:20,940 --> 00:13:28,920
Cass what car stands for is doing Cass

00:13:23,310 --> 00:13:30,779
walk so that skitter is really the art

00:13:28,920 --> 00:13:33,060
of politics and actually it's so

00:13:30,779 --> 00:13:36,810
efficient that basically the trade pool

00:13:33,060 --> 00:13:38,399
in.net fur is based on that scheduler

00:13:36,810 --> 00:13:40,439
basically if you are using trade pool

00:13:38,399 --> 00:13:42,959
like if you straight will be for.net for

00:13:40,439 --> 00:13:44,970
it was like if you feel attached to the

00:13:42,959 --> 00:13:47,129
tread pulley we create a tread for each

00:13:44,970 --> 00:13:49,199
task that was pretty inefficient because

00:13:47,129 --> 00:13:51,720
if you create a lot lot lot of task well

00:13:49,199 --> 00:13:54,480
you just blow up your Martian so knowing

00:13:51,720 --> 00:13:57,000
dotted for actually when you cue up a

00:13:54,480 --> 00:13:59,370
task we will try to it actually create a

00:13:57,000 --> 00:14:01,829
source system parallel if its task and

00:13:59,370 --> 00:14:03,810
just feed it to the normal schedule and

00:14:01,829 --> 00:14:05,699
actually so it's not the case at the

00:14:03,810 --> 00:14:07,230
moment in model but we are pretty much

00:14:05,699 --> 00:14:11,100
working on it we are trying to integrate

00:14:07,230 --> 00:14:13,829
that so hopefully in some time we should

00:14:11,100 --> 00:14:18,990
have also in mono at red bull which work

00:14:13,829 --> 00:14:20,910
on that schedule so now let's pick about

00:14:18,990 --> 00:14:25,380
about each way you could actually

00:14:20,910 --> 00:14:27,360
paralyzed your your things this is like

00:14:25,380 --> 00:14:28,889
task so task you should is you should

00:14:27,360 --> 00:14:31,769
use it like any normal trade basically

00:14:28,889 --> 00:14:34,610
task is like a small unit of work in

00:14:31,769 --> 00:14:37,500
your application so that's a kind of

00:14:34,610 --> 00:14:39,630
traditional way to use a task basically

00:14:37,500 --> 00:14:41,430
you may create what is called a

00:14:39,630 --> 00:14:43,319
conciliation token source which

00:14:41,430 --> 00:14:45,990
basically under lyne partly fix all the

00:14:43,319 --> 00:14:47,550
consolation stuff in parallel fix

00:14:45,990 --> 00:14:49,680
cancellation is like at the art of

00:14:47,550 --> 00:14:52,470
reform because every operation so we

00:14:49,680 --> 00:14:54,480
task wait well any kind of preparation

00:14:52,470 --> 00:14:56,850
can be cancelled and some point of time

00:14:54,480 --> 00:14:58,800
so instead of having like on the task a

00:14:56,850 --> 00:15:01,079
constant method for example they made

00:14:58,800 --> 00:15:03,930
the more generic framework building a

00:15:01,079 --> 00:15:06,059
conservation token Zeus so basically you

00:15:03,930 --> 00:15:08,970
always have a source of consolation and

00:15:06,059 --> 00:15:10,589
then you pass around some token and you

00:15:08,970 --> 00:15:13,110
can actually pass the same token to

00:15:10,589 --> 00:15:15,420
multiple method call that way when you

00:15:13,110 --> 00:15:17,370
call actually cancel on the source it is

00:15:15,420 --> 00:15:19,050
able to conceal multiple work at the

00:15:17,370 --> 00:15:21,779
time and then you can change together

00:15:19,050 --> 00:15:24,029
multiple consolation token source that

00:15:21,779 --> 00:15:25,709
where you can well under really pretty

00:15:24,029 --> 00:15:28,499
nice pretty neat stuff about

00:15:25,709 --> 00:15:30,810
conservation so basically your task is

00:15:28,499 --> 00:15:32,310
pretty much used like you would I mean a

00:15:30,810 --> 00:15:34,560
task is created pretty much the same way

00:15:32,310 --> 00:15:37,620
you would use the tripod you just call a

00:15:34,560 --> 00:15:39,930
factory object with just and then start

00:15:37,620 --> 00:15:42,540
you and you feel it with like a function

00:15:39,930 --> 00:15:45,059
and basically it will try to execute sat

00:15:42,540 --> 00:15:46,920
on a separate thread so the metro deals

00:15:45,059 --> 00:15:49,949
call non-blocking so you just continue

00:15:46,920 --> 00:15:51,990
execution like a normal child I need

00:15:49,949 --> 00:15:54,209
stuff also which is available is all the

00:15:51,990 --> 00:15:56,519
continuation at the continuation

00:15:54,209 --> 00:15:58,410
philosophy a continuation is basically

00:15:56,519 --> 00:15:59,879
something so you will tell it basically

00:15:58,410 --> 00:16:02,639
the schedule it's like a callback

00:15:59,879 --> 00:16:04,610
actually it's like when you finish this

00:16:02,639 --> 00:16:08,220
task I want you to rent that thing too

00:16:04,610 --> 00:16:10,050
and again it's really just a task so

00:16:08,220 --> 00:16:12,629
again it can be scheduled on another

00:16:10,050 --> 00:16:17,579
trade come it can be completely schedule

00:16:12,629 --> 00:16:18,930
and also trade and a to earn well you

00:16:17,579 --> 00:16:22,499
have some metal or so to wait of course

00:16:18,930 --> 00:16:24,389
on it then you have the future which is

00:16:22,499 --> 00:16:28,319
really an interesting which program

00:16:24,389 --> 00:16:30,509
future is like actually is it's a shift

00:16:28,319 --> 00:16:32,970
of mine because future should be used

00:16:30,509 --> 00:16:35,069
like you have some sort of calculation

00:16:32,970 --> 00:16:36,740
going on and basically what you should

00:16:35,069 --> 00:16:39,360
do is like instead of actually

00:16:36,740 --> 00:16:42,269
calculating a result of your computation

00:16:39,360 --> 00:16:44,220
you should say to your code okay I'm do

00:16:42,269 --> 00:16:46,350
a computation the things that I don't

00:16:44,220 --> 00:16:48,629
have yet the reason so i'm going to give

00:16:46,350 --> 00:16:50,490
you instead of the life instead of

00:16:48,629 --> 00:16:54,019
giving you an integer i'm going to give

00:16:50,490 --> 00:16:56,100
you a task int which basically say I'm

00:16:54,019 --> 00:16:57,930
computing the value I don't have it yet

00:16:56,100 --> 00:16:59,850
but just use what I give you and i

00:16:57,930 --> 00:17:02,850
prom-- i and i promise that at some

00:16:59,850 --> 00:17:05,459
point you will have a value and this is

00:17:02,850 --> 00:17:08,220
very neat stuff because of course the

00:17:05,459 --> 00:17:09,839
future is like a task so what I say

00:17:08,220 --> 00:17:12,569
about the late executions that is get

00:17:09,839 --> 00:17:14,760
executed on another thread and the cool

00:17:12,569 --> 00:17:17,159
thing is that you can actually Shane

00:17:14,760 --> 00:17:19,649
future together so you never actually

00:17:17,159 --> 00:17:21,419
process anything but at the end when you

00:17:19,649 --> 00:17:23,939
need the value is going to get processed

00:17:21,419 --> 00:17:25,589
automatically on several tread life for

00:17:23,939 --> 00:17:27,480
example here you have a tree so it's

00:17:25,589 --> 00:17:29,309
basically a method which you have a tree

00:17:27,480 --> 00:17:31,789
of integral and basically it's a method

00:17:29,309 --> 00:17:34,929
will try to calculate the son of H

00:17:31,789 --> 00:17:37,480
element of the trip and you can actually

00:17:34,929 --> 00:17:40,269
see that the right part of the tree is

00:17:37,480 --> 00:17:43,210
actually done so yeah the right part

00:17:40,269 --> 00:17:45,850
actually is done like normally second

00:17:43,210 --> 00:17:49,740
Shelley but then the left part of the

00:17:45,850 --> 00:17:52,960
solder the metal is actually you know

00:17:49,740 --> 00:17:54,909
recursive and actually the right part of

00:17:52,960 --> 00:17:57,730
the tree is like taken as a result that

00:17:54,909 --> 00:18:00,730
the left part of the tree is calculating

00:17:57,730 --> 00:18:03,249
Idzik here against Archer but with a

00:18:00,730 --> 00:18:05,619
future so basically all the left part of

00:18:03,249 --> 00:18:08,860
your tree will be chaining up future

00:18:05,619 --> 00:18:10,419
together that called later value so like

00:18:08,860 --> 00:18:11,860
value is a blocking call but basically

00:18:10,419 --> 00:18:13,950
by the time you have finished

00:18:11,860 --> 00:18:16,419
calculating your right side of your tree

00:18:13,950 --> 00:18:18,129
the left side should already been

00:18:16,419 --> 00:18:21,129
computed by because the future is

00:18:18,129 --> 00:18:22,929
executed on others tread and so we can

00:18:21,129 --> 00:18:24,820
chain up and the cool thing is that of

00:18:22,929 --> 00:18:26,619
course you have a relationship between

00:18:24,820 --> 00:18:28,179
each future because the future dependent

00:18:26,619 --> 00:18:31,899
needs of future which dependence of you

00:18:28,179 --> 00:18:33,580
to exeter xterra and it's handled by the

00:18:31,899 --> 00:18:35,980
runtime so that actually when you

00:18:33,580 --> 00:18:38,289
request the value of the topmost future

00:18:35,980 --> 00:18:40,960
we just walked on all the way down and

00:18:38,289 --> 00:18:44,350
get the result from the lower level

00:18:40,960 --> 00:18:45,879
future so this is you have to change

00:18:44,350 --> 00:18:49,409
your code actually to to make use of

00:18:45,879 --> 00:18:52,480
future but it's aranea switch program

00:18:49,409 --> 00:18:54,190
then you have one concert which is

00:18:52,480 --> 00:18:58,029
really used a lot which is the parallel

00:18:54,190 --> 00:18:59,919
for so again when I said earlier that /

00:18:58,029 --> 00:19:02,440
if you'd be able to mimic existing

00:18:59,919 --> 00:19:05,230
constrict this is one of the constrict

00:19:02,440 --> 00:19:07,570
which I mean everybody has ever done a

00:19:05,230 --> 00:19:09,220
for loop and the for loop is actually

00:19:07,570 --> 00:19:11,980
something that you can really easily

00:19:09,220 --> 00:19:13,809
paralyzed basically you say that edge to

00:19:11,980 --> 00:19:16,570
edge should be doing like if you have a

00:19:13,809 --> 00:19:19,210
loop which goes from 0 to I don't know

00:19:16,570 --> 00:19:21,909
1,000 basically if you have 10 tread you

00:19:19,210 --> 00:19:25,240
should just say like 21 deuce does the

00:19:21,909 --> 00:19:28,690
walk from 0 to 100 you also trade do the

00:19:25,240 --> 00:19:31,360
work from 101 to 200 its data so it's

00:19:28,690 --> 00:19:33,190
very easy to analyze and actually

00:19:31,360 --> 00:19:35,879
powerful just do that it tried to

00:19:33,190 --> 00:19:35,879
partition the

00:19:35,950 --> 00:19:41,799
the what do I see the range of value

00:19:38,889 --> 00:19:44,500
into smaller range that each task can

00:19:41,799 --> 00:19:45,880
process individually and actually the

00:19:44,500 --> 00:19:48,279
really cool thing apart parallel for is

00:19:45,880 --> 00:19:50,529
that as you can see it's almost the same

00:19:48,279 --> 00:19:53,799
as a traditional for loop you just say

00:19:50,529 --> 00:19:55,419
parallel dot for the way you where you

00:19:53,799 --> 00:19:57,010
want to start where you want your hand

00:19:55,419 --> 00:19:59,769
and what you want to execute with the

00:19:57,010 --> 00:20:01,330
value and that's all we understand it's

00:19:59,769 --> 00:20:03,010
all going to partition the stuff

00:20:01,330 --> 00:20:06,070
paralyze your stuff but you don't know

00:20:03,010 --> 00:20:08,590
so that's one of the PAS actually where

00:20:06,070 --> 00:20:10,809
I agree on Alan saying that developers

00:20:08,590 --> 00:20:13,269
should really use one trade the twist is

00:20:10,809 --> 00:20:15,159
that developer should think they are

00:20:13,269 --> 00:20:16,990
using one trade and this is one of the

00:20:15,159 --> 00:20:19,090
way to ensure that basically the

00:20:16,990 --> 00:20:20,590
programmer don't care you just write

00:20:19,090 --> 00:20:22,510
that up and in figs like it's a normal

00:20:20,590 --> 00:20:24,789
follow up with actually behind the scene

00:20:22,510 --> 00:20:27,010
without him knowing it's doing parallel

00:20:24,789 --> 00:20:31,630
stuff and it's actually improving its

00:20:27,010 --> 00:20:33,100
application so the more time actually

00:20:31,630 --> 00:20:35,799
i'm going to use palette for is very

00:20:33,100 --> 00:20:38,139
useful as you saw here for image

00:20:35,799 --> 00:20:39,519
processing again it goes basically when

00:20:38,139 --> 00:20:41,649
you do image processing pixel based

00:20:39,519 --> 00:20:43,059
processing you just iterate over the

00:20:41,649 --> 00:20:45,490
wall range of pixel you have a new

00:20:43,059 --> 00:20:47,889
picture so an easy way to paralyze that

00:20:45,490 --> 00:20:50,440
sort of stuff is basically to use

00:20:47,889 --> 00:20:54,580
parallel for on the outermost for loop

00:20:50,440 --> 00:21:02,700
you have a new program so actually took

00:20:54,580 --> 00:21:02,700
the turn sorry top anyway

00:21:05,890 --> 00:21:11,170
so we are at a little code which

00:21:08,030 --> 00:21:14,660
basically is the fractal drawer and

00:21:11,170 --> 00:21:16,700
really the only difference you have

00:21:14,660 --> 00:21:20,150
between like a second short book should

00:21:16,700 --> 00:21:21,740
baby so that's all occurred simple stuff

00:21:20,150 --> 00:21:23,630
basically the only difference between

00:21:21,740 --> 00:21:25,250
the parallel version and the second

00:21:23,630 --> 00:21:26,750
shell version is that the for loop you

00:21:25,250 --> 00:21:29,900
have here in a second short version is

00:21:26,750 --> 00:21:31,520
just change to a parallel for one so

00:21:29,900 --> 00:21:33,350
basically the only difference you have

00:21:31,520 --> 00:21:36,770
is like modifying this line and this

00:21:33,350 --> 00:21:38,030
line to line change and you get most of

00:21:36,770 --> 00:21:40,400
so like I have a dual core processor

00:21:38,030 --> 00:21:42,410
here and you get twice as much

00:21:40,400 --> 00:21:44,600
performance as the second short version

00:21:42,410 --> 00:21:48,800
don't take my word for it i'm going to

00:21:44,600 --> 00:21:52,150
show you so here i'm going to run it in

00:21:48,800 --> 00:21:55,250
so this is the second shell version so

00:21:52,150 --> 00:21:56,720
of course it's Evie usage I mean

00:21:55,250 --> 00:21:59,510
paralyzation is very good when you have

00:21:56,720 --> 00:22:01,340
ever large data set or if you have like

00:21:59,510 --> 00:22:04,190
metal which takes a lot of time so are

00:22:01,340 --> 00:22:09,640
you been method for example so if

00:22:04,190 --> 00:22:09,640
everything goes well the tune

00:22:15,929 --> 00:22:22,540
here you go so like 26 seconds to

00:22:19,510 --> 00:22:24,700
actually produce that stuff of course

00:22:22,540 --> 00:22:26,890
you can criticize my art skill i'm

00:22:24,700 --> 00:22:29,650
actually not an artist out but basically

00:22:26,890 --> 00:22:31,630
this is like a fractal am under broad

00:22:29,650 --> 00:22:33,760
fractal but it's just for the point of

00:22:31,630 --> 00:22:36,940
having your Navy calculation so as you

00:22:33,760 --> 00:22:38,650
have seen the actually the cut them the

00:22:36,940 --> 00:22:40,919
processing of dots of took actually like

00:22:38,650 --> 00:22:44,620
30 seconds now let's run it in parallel

00:22:40,919 --> 00:22:48,450
so again i say it with a two line change

00:22:44,620 --> 00:22:48,450
so now i'm using a palette for loop

00:22:50,730 --> 00:22:54,480
still taking some time

00:23:00,039 --> 00:23:07,179
here you go 15 second two line change

00:23:04,090 --> 00:23:09,759
and you have approximately like 10 or

00:23:07,179 --> 00:23:18,629
more second speedier program to line

00:23:09,759 --> 00:23:18,629
change and actually the same habit so

00:23:19,470 --> 00:23:26,480
sorry it's going to take some time to go

00:23:21,900 --> 00:23:26,480
back to where I was at the term

00:23:31,669 --> 00:23:37,830
sorry for this it sounds like there

00:23:36,450 --> 00:23:44,570
wasn't coordination between the two

00:23:37,830 --> 00:23:44,570
stocks yours an hour yeah maybe Emerson

00:23:45,590 --> 00:23:49,010
maybe for the cut

00:23:54,070 --> 00:23:57,710
that way if you either noticed with

00:23:56,000 --> 00:24:04,810
anything you can just see everything

00:23:57,710 --> 00:24:04,810
back aspeed your presentation

00:24:08,029 --> 00:24:11,499
that was the wrong here

00:24:13,389 --> 00:24:19,119
okay so AI spoke about actually the

00:24:17,019 --> 00:24:21,279
lower level stuff of politics which are

00:24:19,119 --> 00:24:23,919
so the tax the future and the palate

00:24:21,279 --> 00:24:25,479
loops so actually so I I showed paddle

00:24:23,919 --> 00:24:27,729
fo but you have actually also palette

00:24:25,479 --> 00:24:30,159
for reg so we can assume allies any

00:24:27,729 --> 00:24:32,349
forage loop which basically iterate most

00:24:30,159 --> 00:24:35,169
of time and collection or or link

00:24:32,349 --> 00:24:37,599
request actually and but to do that

00:24:35,169 --> 00:24:39,249
actually so speaking about link you can

00:24:37,599 --> 00:24:42,219
have it so very neat stuff which is

00:24:39,249 --> 00:24:44,469
called poly link piling basically take

00:24:42,219 --> 00:24:47,320
up your link query so I hope everyone is

00:24:44,469 --> 00:24:51,459
familiar with link again I hope so

00:24:47,320 --> 00:24:53,739
basically a link query is like you put

00:24:51,459 --> 00:24:55,629
up some operator and you say I have a

00:24:53,739 --> 00:24:57,999
data so somewhere and I want to apply

00:24:55,629 --> 00:25:01,329
some operation on it and basically what

00:24:57,999 --> 00:25:04,179
parlor link does is that it takes up the

00:25:01,329 --> 00:25:05,709
query look into the query where which

00:25:04,179 --> 00:25:08,379
part could be actually paralyzed because

00:25:05,709 --> 00:25:10,029
error it's raining slow or there is a

00:25:08,379 --> 00:25:12,579
big data set and that sort of stuff and

00:25:10,029 --> 00:25:15,299
actually try to paralyze the world point

00:25:12,579 --> 00:25:18,159
of paddling is that if I remove that

00:25:15,299 --> 00:25:21,579
that part it's actually standard link

00:25:18,159 --> 00:25:23,649
and the only modification I did to

00:25:21,579 --> 00:25:26,859
actually paralyzed my query was just

00:25:23,649 --> 00:25:29,889
adding this line so you can ever on any

00:25:26,859 --> 00:25:32,409
any link query basically ever you had

00:25:29,889 --> 00:25:35,109
this small operator which is as parallel

00:25:32,409 --> 00:25:36,789
or you just use the parallel any

00:25:35,109 --> 00:25:39,519
variable class instead of the animator

00:25:36,789 --> 00:25:41,589
world class to like creating ranch ranch

00:25:39,519 --> 00:25:44,979
anime label or repeat any variable

00:25:41,589 --> 00:25:46,599
that's all one line change over having

00:25:44,979 --> 00:25:51,309
less than one light change and you have

00:25:46,599 --> 00:25:54,190
your paralyzed query so again the more

00:25:51,309 --> 00:25:57,249
time so a very famous example if you

00:25:54,190 --> 00:25:59,769
follow Microsoft guys you probably have

00:25:57,249 --> 00:26:02,529
stumbled on a guy which is called Luca

00:25:59,769 --> 00:26:05,169
ban and basically likes to do crazy

00:26:02,529 --> 00:26:09,129
stuff and the last test crazy stuff he

00:26:05,169 --> 00:26:11,409
has done is this so i showed you like

00:26:09,129 --> 00:26:13,989
Earl inquiry which was very small but

00:26:11,409 --> 00:26:16,479
this is actually a world ray tracer

00:26:13,989 --> 00:26:19,479
application only right on in link in one

00:26:16,479 --> 00:26:21,159
big linq query all of that stuff and

00:26:19,479 --> 00:26:24,519
actually it's not finished here you can

00:26:21,159 --> 00:26:27,070
go down here all of that is a link where

00:26:24,519 --> 00:26:29,230
which basically do ray tracing

00:26:27,070 --> 00:26:31,090
that's all said well when I said that

00:26:29,230 --> 00:26:34,720
t-shirt now what's going on channel

00:26:31,090 --> 00:26:36,549
that's what I meant yeah now one of the

00:26:34,720 --> 00:26:38,649
things that actually been saying is

00:26:36,549 --> 00:26:40,990
you've not the idea is no longer to have

00:26:38,649 --> 00:26:42,700
side effects is that everything that

00:26:40,990 --> 00:26:44,860
basically you don't mutate the global

00:26:42,700 --> 00:26:47,679
state everything is locked off so that

00:26:44,860 --> 00:26:49,210
you can paralyze mistakes you know this

00:26:47,679 --> 00:26:52,809
one of the things that you can do yeah

00:26:49,210 --> 00:26:54,460
of course yeah I should say that really

00:26:52,809 --> 00:26:56,200
functional start programming is really

00:26:54,460 --> 00:26:59,110
sweet to to actually paralyzation

00:26:56,200 --> 00:27:00,549
because in when you're paralyzed stuff

00:26:59,110 --> 00:27:02,679
you really don't want to have any side

00:27:00,549 --> 00:27:04,029
effects shared state so when I say that

00:27:02,679 --> 00:27:06,669
the programmer basically have to change

00:27:04,029 --> 00:27:08,019
wild line well it's not totally true you

00:27:06,669 --> 00:27:10,120
also have to be careful and what you're

00:27:08,019 --> 00:27:12,009
actually doing in your function because

00:27:10,120 --> 00:27:13,779
if you are doing like any work on a

00:27:12,009 --> 00:27:14,860
shared state or like traditional

00:27:13,779 --> 00:27:18,789
collection for example you have to

00:27:14,860 --> 00:27:20,559
protect it with local anything but to

00:27:18,789 --> 00:27:21,970
moderate that actually I showed you that

00:27:20,559 --> 00:27:23,950
we have actually conquered collation

00:27:21,970 --> 00:27:25,750
collection which are very efficient in a

00:27:23,950 --> 00:27:27,190
multi-threaded environment so instead of

00:27:25,750 --> 00:27:28,799
using your traditional collection just

00:27:27,190 --> 00:27:32,250
use that and you will have no problem

00:27:28,799 --> 00:27:35,860
but again so basically you have this

00:27:32,250 --> 00:27:40,149
enormous query and then what it takes to

00:27:35,860 --> 00:27:42,490
paralyze it is basically just changing

00:27:40,149 --> 00:27:49,450
any variable topology Mirabal which is a

00:27:42,490 --> 00:27:51,789
1 2 3 4 5 6 7 8 8 character change so

00:27:49,450 --> 00:27:53,860
actually the painting stuff is naturally

00:27:51,789 --> 00:27:57,759
finished I'm working on it it should be

00:27:53,860 --> 00:27:59,950
hopefully ready by mono 2.8 but anyway

00:27:57,759 --> 00:28:02,700
i'm going to show you what it doesn't

00:27:59,950 --> 00:28:02,700
look like at the moment

00:28:12,570 --> 00:28:17,320
so I can select if I want to run the two

00:28:15,609 --> 00:28:19,720
to actually process the thing in second

00:28:17,320 --> 00:28:24,429
row manner of panel matter so i will

00:28:19,720 --> 00:28:26,379
just first do it in second shell way so

00:28:24,429 --> 00:28:28,539
it's always black ok so eka me so

00:28:26,379 --> 00:28:30,849
actually no ties or the fingers process

00:28:28,539 --> 00:28:32,679
basically it's like a for loop you would

00:28:30,849 --> 00:28:35,769
say and it basically for each pixel

00:28:32,679 --> 00:28:38,979
process and calculate what the color

00:28:35,769 --> 00:28:42,009
should be in essence is that so actually

00:28:38,979 --> 00:28:45,700
as you can see it's pretty much going it

00:28:42,009 --> 00:28:52,619
like in the linear fashion and that

00:28:45,700 --> 00:28:55,359
actually take up some time a lot of time

00:28:52,619 --> 00:28:56,950
the thing is that basically at that part

00:28:55,359 --> 00:28:59,700
you have all the reflection which is

00:28:56,950 --> 00:29:02,619
going on which is a lot of actually

00:28:59,700 --> 00:29:05,649
recursive function so that's actually

00:29:02,619 --> 00:29:08,529
the art part of the of the picture well

00:29:05,649 --> 00:29:12,279
I'm going to stop hit here so really

00:29:08,529 --> 00:29:14,769
just for you to see Oh politics walks or

00:29:12,279 --> 00:29:19,509
peeling quotes so now if i select the

00:29:14,769 --> 00:29:20,979
parallel version and render it basically

00:29:19,509 --> 00:29:24,099
what you are going to see after some

00:29:20,979 --> 00:29:26,859
time yet here you actually see that the

00:29:24,099 --> 00:29:29,830
image is being not processed like as a

00:29:26,859 --> 00:29:32,649
wall we have some black line here which

00:29:29,830 --> 00:29:34,419
actually it showed that there is

00:29:32,649 --> 00:29:37,029
actually to tread doing the work

00:29:34,419 --> 00:29:39,940
basically what paling does is that it

00:29:37,029 --> 00:29:42,820
takes up the world query see that you

00:29:39,940 --> 00:29:45,609
can partition the range of pixel of the

00:29:42,820 --> 00:29:47,859
screen and then it fired basically a

00:29:45,609 --> 00:29:49,749
task to process alternate to the edge

00:29:47,859 --> 00:29:52,210
part of the screen so basically this

00:29:49,749 --> 00:29:54,429
thing is twice as fast again on my dell

00:29:52,210 --> 00:29:57,369
computer because i have to code is twice

00:29:54,429 --> 00:30:01,320
as fast as the other way you're actually

00:29:57,369 --> 00:30:01,320
seeing it is quite faster than the other

00:30:04,840 --> 00:30:11,830
again take some time so let's speak

00:30:09,760 --> 00:30:13,809
about state of things so actually part

00:30:11,830 --> 00:30:15,580
of the fix so as I said it's quite an

00:30:13,809 --> 00:30:17,500
old project now because it's not

00:30:15,580 --> 00:30:19,450
actually I spent like this summer my

00:30:17,500 --> 00:30:21,490
second summer of code on it so it's

00:30:19,450 --> 00:30:23,620
actually a two year project to your

00:30:21,490 --> 00:30:26,020
whole project and basically the first

00:30:23,620 --> 00:30:28,600
version of mono to include some politics

00:30:26,020 --> 00:30:30,669
bit was like 2.6 which was released some

00:30:28,600 --> 00:30:33,190
month ago and not really sure about the

00:30:30,669 --> 00:30:37,659
date anymore and so it shipped with a

00:30:33,190 --> 00:30:39,610
dotnet for beta 1 ap and you get all the

00:30:37,659 --> 00:30:40,870
task future parallel oops concurrent

00:30:39,610 --> 00:30:43,149
collection and coordination data

00:30:40,870 --> 00:30:44,919
switches so pretty much like I would say

00:30:43,149 --> 00:30:46,360
eighty percent of the problem the only

00:30:44,919 --> 00:30:48,250
part missing is actually the pending

00:30:46,360 --> 00:30:52,480
stuff i'm walking i'm still working on

00:30:48,250 --> 00:30:56,500
and actually in monitoring so about a

00:30:52,480 --> 00:30:59,260
weeks ago i completed like the debated

00:30:56,500 --> 00:31:00,760
between dotted for a beta 1 and donate

00:30:59,260 --> 00:31:03,039
for beta 2 there is some change in a

00:31:00,760 --> 00:31:06,010
happy and basically in monitoring know

00:31:03,039 --> 00:31:09,130
the happy is fully beta to complete and

00:31:06,010 --> 00:31:12,130
at this point normally between dotnet

00:31:09,130 --> 00:31:13,600
for beta 2 and dot net for final there

00:31:12,130 --> 00:31:15,220
shouldn't be a lot of churn so actually

00:31:13,600 --> 00:31:17,980
if you want to start already using

00:31:15,220 --> 00:31:19,840
politics you're probably saved by using

00:31:17,980 --> 00:31:22,840
the trend version already the app you of

00:31:19,840 --> 00:31:25,029
the track version and so up fully my

00:31:22,840 --> 00:31:32,049
mother 2.8 we should have fully dotted

00:31:25,029 --> 00:31:34,480
for compliant IP with telling so thanks

00:31:32,049 --> 00:31:37,980
for your attention and if you have any

00:31:34,480 --> 00:31:37,980
question at the athlete to answer

00:31:42,500 --> 00:31:48,960
so soon here are we every-every for loop

00:31:47,279 --> 00:31:50,940
in our program that doesn't have side

00:31:48,960 --> 00:31:52,980
effects can we sprinted on it or is

00:31:50,940 --> 00:31:55,620
there a flat panel TV we should take

00:31:52,980 --> 00:31:57,990
care the things that parallel pilot

00:31:55,620 --> 00:32:00,179
program isn't magic so actually maybe

00:31:57,990 --> 00:32:02,759
sometimes it's actually the cost of

00:32:00,179 --> 00:32:04,919
actually scheduling task is more

00:32:02,759 --> 00:32:07,500
expensive that the parallel optimization

00:32:04,919 --> 00:32:09,269
so I would say that you are safe if you

00:32:07,500 --> 00:32:13,980
are like pressing singh big chunk of

00:32:09,269 --> 00:32:15,960
data so like image processing but a lot

00:32:13,980 --> 00:32:18,120
of it basically like we were talking

00:32:15,960 --> 00:32:19,590
with better on the other day and there

00:32:18,120 --> 00:32:21,450
is like in banshee for example you have

00:32:19,590 --> 00:32:23,639
an extension we see which is called

00:32:21,450 --> 00:32:25,350
mirage and basically what mirrors does

00:32:23,639 --> 00:32:26,759
is that it analyzed all the song you

00:32:25,350 --> 00:32:30,179
have in your library your music library

00:32:26,759 --> 00:32:33,090
and then it compute basically the the

00:32:30,179 --> 00:32:34,830
similarity between edge of your song so

00:32:33,090 --> 00:32:36,509
actually in this kind of application so

00:32:34,830 --> 00:32:38,909
i could fairly standard this kapap

00:32:36,509 --> 00:32:41,490
desktop application edge of this

00:32:38,909 --> 00:32:43,350
processing of I mean edge song

00:32:41,490 --> 00:32:45,899
processing actually could be represented

00:32:43,350 --> 00:32:47,970
by as a task or future I would say more

00:32:45,899 --> 00:32:49,889
future so you could have even if you

00:32:47,970 --> 00:32:52,620
have like 10,000 song in your library

00:32:49,889 --> 00:32:54,720
you have actually 10,000 future and it's

00:32:52,620 --> 00:32:56,519
only going it's not going to create I

00:32:54,720 --> 00:32:57,809
mean you couldn't use like at Red Bull

00:32:56,519 --> 00:33:01,710
for example because it would be like

00:32:57,809 --> 00:33:03,809
creating 10,000 tread which probably we

00:33:01,710 --> 00:33:05,879
blow up your motion but if you a

00:33:03,809 --> 00:33:08,190
spiderific future basically you are only

00:33:05,879 --> 00:33:11,100
running on to tread and you are still

00:33:08,190 --> 00:33:13,230
processing your 10,000 songs so that's a

00:33:11,100 --> 00:33:17,960
your needs usage of future in like a

00:33:13,230 --> 00:33:17,960
desktop application so that should be

00:33:20,299 --> 00:33:25,380
so actually don't take my word see for

00:33:23,250 --> 00:33:26,850
yourself try 82 application the best way

00:33:25,380 --> 00:33:28,950
to actually see if its speed of thing is

00:33:26,850 --> 00:33:31,289
to try it in your application as either

00:33:28,950 --> 00:33:33,899
I hope I just show you it's really easy

00:33:31,289 --> 00:33:35,700
to actually plug any parallel video in

00:33:33,899 --> 00:33:48,840
your existing application so test and

00:33:35,700 --> 00:33:50,789
report any bugs yep yeah so actually

00:33:48,840 --> 00:33:53,250
yeah there is like several Ristic in

00:33:50,789 --> 00:33:54,960
parallel parallel link and basically if

00:33:53,250 --> 00:33:58,980
you feed up with like collection which

00:33:54,960 --> 00:34:01,320
can work on in index fashion is going to

00:33:58,980 --> 00:34:03,870
basically strip the world that your ng

00:34:01,320 --> 00:34:05,940
small chunk that you can actually access

00:34:03,870 --> 00:34:07,440
that is the fastest way actually to use

00:34:05,940 --> 00:34:09,690
paralleling if you are using it with

00:34:07,440 --> 00:34:11,310
like an array or a list or basically

00:34:09,690 --> 00:34:12,899
anything which work on the index is

00:34:11,310 --> 00:34:15,270
going to be really fast because we can

00:34:12,899 --> 00:34:17,609
access each element of the collection

00:34:15,270 --> 00:34:18,839
we've got any other end I mean when we

00:34:17,609 --> 00:34:20,460
are doing this kind of partitioning

00:34:18,839 --> 00:34:22,589
there is no lock there is no cast there

00:34:20,460 --> 00:34:24,750
is nothing everything is cleanly I mean

00:34:22,589 --> 00:34:28,139
each task is cleanly separated in its

00:34:24,750 --> 00:34:30,839
own environment you could say and as its

00:34:28,139 --> 00:34:33,179
work to do that's all but again yeah if

00:34:30,839 --> 00:34:35,129
you is like a stoner anime label there

00:34:33,179 --> 00:34:37,020
you must have some locking because you

00:34:35,129 --> 00:34:39,149
can't know what the user is actually

00:34:37,020 --> 00:34:41,190
doing in its any variable it could be

00:34:39,149 --> 00:34:43,609
like a nozzle inquiry for example so

00:34:41,190 --> 00:34:46,230
maybe it's not red tape so in that case

00:34:43,609 --> 00:34:53,480
we have to use that's that's a shame but

00:34:46,230 --> 00:34:53,480
we have to use locking checks yet

00:34:54,230 --> 00:35:01,380
actually yeah that's well the things

00:34:58,260 --> 00:35:03,600
that so basically like if you like at

00:35:01,380 --> 00:35:05,760
first for example like in the Ray tracer

00:35:03,600 --> 00:35:07,710
I showed basically oh it was split up

00:35:05,760 --> 00:35:10,140
that eyes like it would have one tax

00:35:07,710 --> 00:35:12,120
would have done the helper part of the

00:35:10,140 --> 00:35:13,350
image and the law and the other types

00:35:12,120 --> 00:35:16,550
would have made the lower part of the

00:35:13,350 --> 00:35:19,770
image well as you saw actually on the

00:35:16,550 --> 00:35:21,570
rich wiser example the dropper part is

00:35:19,770 --> 00:35:23,970
very fast because there is no reflection

00:35:21,570 --> 00:35:25,770
inside but the lower part has more

00:35:23,970 --> 00:35:29,040
reflection so it's actually it takes

00:35:25,770 --> 00:35:30,480
longer to process so at one point you

00:35:29,040 --> 00:35:33,020
will have one task which run out of

00:35:30,480 --> 00:35:36,060
Pixar to process and we die so actually

00:35:33,020 --> 00:35:38,880
the thing is that we have to put to make

00:35:36,060 --> 00:35:41,310
chunk smaller chunk so that as you saw

00:35:38,880 --> 00:35:44,160
it's like doing chunk like this at the

00:35:41,310 --> 00:35:46,890
time because in the end up fully it's

00:35:44,160 --> 00:35:48,840
going to you know stabilized on the same

00:35:46,890 --> 00:35:52,530
amount of work between the two train the

00:35:48,840 --> 00:35:55,770
things that there is no I mean precise

00:35:52,530 --> 00:35:58,410
way to actually know all along a given

00:35:55,770 --> 00:36:00,570
function is actually going to take how

00:35:58,410 --> 00:36:03,450
much time it's going to take so we have

00:36:00,570 --> 00:36:05,220
to make some gas here and it's not

00:36:03,450 --> 00:36:07,440
perfect one thing is worth noting is

00:36:05,220 --> 00:36:09,450
that the heuristics built into the

00:36:07,440 --> 00:36:11,010
system you know they will take internal

00:36:09,450 --> 00:36:12,780
things like the load average so if your

00:36:11,010 --> 00:36:14,340
machine is overloaded will not spin up a

00:36:12,780 --> 00:36:15,780
lot of threads until the load comes down

00:36:14,340 --> 00:36:17,520
so it will take those things into

00:36:15,780 --> 00:36:20,130
consideration the second thing is that

00:36:17,520 --> 00:36:23,100
the final version of the API allows you

00:36:20,130 --> 00:36:25,050
to plug your own heuristic system so you

00:36:23,100 --> 00:36:27,630
know your data better so you can you can

00:36:25,050 --> 00:36:29,790
you can give the scheduler a hint and

00:36:27,630 --> 00:36:31,020
you say well I actually know that this

00:36:29,790 --> 00:36:33,210
you know the beginner is going to be

00:36:31,020 --> 00:36:35,010
really hard so the beginning just

00:36:33,210 --> 00:36:36,810
separate one and one and one but when

00:36:35,010 --> 00:36:39,330
you get to number 100 start giving

00:36:36,810 --> 00:36:42,570
chunks of 20 for example so you can plug

00:36:39,330 --> 00:36:44,820
that into it if you want and actually as

00:36:42,570 --> 00:36:46,770
I said panic is not just about executing

00:36:44,820 --> 00:36:48,330
the query without knowing it it actually

00:36:46,770 --> 00:36:50,430
is there is a step of actually checking

00:36:48,330 --> 00:36:51,810
or the query looks like because for

00:36:50,430 --> 00:36:53,490
example you have some operator link

00:36:51,810 --> 00:36:55,980
operator which are for example take

00:36:53,490 --> 00:36:57,690
which only I mean are interesting like

00:36:55,980 --> 00:36:59,700
the first part of the data set which is

00:36:57,690 --> 00:37:01,620
processed so it doesn't care about all

00:36:59,700 --> 00:37:03,990
the the part that is at the end for

00:37:01,620 --> 00:37:05,430
example so in that kind of case if for

00:37:03,990 --> 00:37:07,350
example the checkers see that there is a

00:37:05,430 --> 00:37:08,850
take operator in the query

00:37:07,350 --> 00:37:10,590
it will just you know use chunk

00:37:08,850 --> 00:37:14,540
partitioning bit like we've one element

00:37:10,590 --> 00:37:17,730
at the time that way take is most I mean

00:37:14,540 --> 00:37:20,430
take we probably be happier with what is

00:37:17,730 --> 00:37:24,560
seeking and you won't waste time on what

00:37:20,430 --> 00:37:24,560

YouTube URL: https://www.youtube.com/watch?v=mADspHeopJ0


