Title: Portfolio of optimized cryptographic functions based on Keccak
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	by Gilles Van Assche

At: FOSDEM 2017

Since its adoption as the SHA-3 standard, Keccak has grown out of the merehashing functionality. We present a consistent set of cryptographic functions,for fast hashing, pseudo-random bit generation, authentication orauthenticated encryption, that enjoy very competitive safety margin vs speedratios. We highlight the bases for the security of these functions and diveinto their software implementations.

Beyond the FIPS 202 standard functions derived from Keccak (i.e., SHA-3 hashfunctions and SHAKE{128,256} extendable output functions), we present severalinteresting proposals, consistently based on the same permutation or its roundfunction. Among others:

  * For authenticated encryption, Ketje and Keyak are schemes that were selected for the third round of the [CAESAR competition](http://competitions.cr.yp.to/caesar-submissions.html). In particular, Keyak proposes interesting features when protecting a stream of data flowing on a network. It exploits the parallelism in modern processors to achieve a high throughput.  * [KangarooTwelve](http://eprint.iacr.org/2016/770.pdf) is a recently published arbitrary-output-length hash function. We designed it so that the implementation can automatically adapt to the available degree of parallelism. On Intel's Haswell and Skylake architectures, it achieves a speed below 1.5 cycles/byte for long inputs.

Two key aspects will be covered.

First, the essential goal of these functions is to remain secure despiteadvances in cryptanalysis. We will explain explain how we base the security ontwo strong pillars: the track record of third-party cryptanalysis and thegeneric security of the underlying construction.

Second, we will explore the [Keccak CodePackage](https://github.com/gvanas/KeccakCodePackage) and its two-levelstructure. The high-level cryptographic services are implemented in plain C,without any specific optimizations. The low-level services implement thepermutations and the state input/output functions, for which we provideoptimized code for different platforms. Another interesting topic to discussis how the parallelism is exploited on modern processors with SIMD units.


Room: Janson
Scheduled start: 2017-02-05 09:00:00
Captions: 
	00:00:00,030 --> 00:00:02,810
good morning everyone

00:00:05,080 --> 00:00:11,530
welcome to this security and encryption

00:00:08,109 --> 00:00:13,750
track so we will indeed talk about some

00:00:11,530 --> 00:00:16,119
cryptographic functions based on ket

00:00:13,750 --> 00:00:17,470
check and everything I will I will say

00:00:16,119 --> 00:00:26,410
is actually don't work with my

00:00:17,470 --> 00:00:28,529
colleagues Widow UN McCain and Hani so

00:00:26,410 --> 00:00:32,199
this is the outline of my presentation

00:00:28,529 --> 00:00:34,960
we start with some introduction then I

00:00:32,199 --> 00:00:38,039
will try to discuss the security

00:00:34,960 --> 00:00:41,050
properties of symmetric cryptography

00:00:38,039 --> 00:00:43,300
then the core of the presentation will

00:00:41,050 --> 00:00:45,370
be divided into two parts the key

00:00:43,300 --> 00:00:47,739
applications and unkilled applications

00:00:45,370 --> 00:00:51,039
depending whether or not we need a

00:00:47,739 --> 00:00:54,579
secret key then I talked about the

00:00:51,039 --> 00:00:59,530
Quecha code package and recap on on the

00:00:54,579 --> 00:01:03,399
under functions with some inventory so

00:00:59,530 --> 00:01:06,970
the the story somehow begins some years

00:01:03,399 --> 00:01:09,610
ago in the years 2004 2005 where the

00:01:06,970 --> 00:01:14,380
when the most popular hash functions md5

00:01:09,610 --> 00:01:16,420
and sha-1 got severely broken so at the

00:01:14,380 --> 00:01:17,110
time there was also the shot to hash

00:01:16,420 --> 00:01:20,530
function

00:01:17,110 --> 00:01:22,750
designed by NSA but it was also based on

00:01:20,530 --> 00:01:25,270
the same design principles as md5 and

00:01:22,750 --> 00:01:27,160
sha-1 so at the time there was fear that

00:01:25,270 --> 00:01:31,090
maybe these attacks would extend to

00:01:27,160 --> 00:01:33,700
Chateau and so nice decided to create a

00:01:31,090 --> 00:01:36,310
new hash function called sha tree but

00:01:33,700 --> 00:01:41,740
not on their own they would do that via

00:01:36,310 --> 00:01:44,260
an open competition so between 2008 and

00:01:41,740 --> 00:01:46,900
2012 there was indeed a free competition

00:01:44,260 --> 00:01:49,480
it was an open competition in the sense

00:01:46,900 --> 00:01:52,300
that every design was public everyone

00:01:49,480 --> 00:01:54,430
was forced to of course give the

00:01:52,300 --> 00:01:57,150
rationale of the design and give some

00:01:54,430 --> 00:02:00,460
open source implementation of it and

00:01:57,150 --> 00:02:04,900
every team was allowed to try to break

00:02:00,460 --> 00:02:07,360
and try to attack any competing design

00:02:04,900 --> 00:02:09,700
there was also some effort done to

00:02:07,360 --> 00:02:11,650
evaluate the performance of all these

00:02:09,700 --> 00:02:15,519
designs

00:02:11,650 --> 00:02:18,159
it yeah it took the energy of quite a

00:02:15,519 --> 00:02:19,599
lot of the cryptographic community a lot

00:02:18,159 --> 00:02:22,720
of teams from different different

00:02:19,599 --> 00:02:25,000
companies and different universities to

00:02:22,720 --> 00:02:29,980
part of this competition and you can see

00:02:25,000 --> 00:02:32,950
in this graph arrows going from the

00:02:29,980 --> 00:02:38,040
teams attacking the design of another

00:02:32,950 --> 00:02:41,920
team so that was the situation in 2009

00:02:38,040 --> 00:02:45,159
so our candidate was sketch Shaq okay

00:02:41,920 --> 00:02:47,019
Chuck is a sponge function which is

00:02:45,159 --> 00:02:49,810
somehow the generalization of a hash

00:02:47,019 --> 00:02:52,150
function and it works like in this

00:02:49,810 --> 00:02:54,370
drawing so there is a state which is

00:02:52,150 --> 00:02:56,829
initialized to zero and then the input

00:02:54,370 --> 00:02:59,129
is cut into blocks these blocks are

00:02:56,829 --> 00:03:01,480
processed one after the other and

00:02:59,129 --> 00:03:04,180
between this block there is this

00:03:01,480 --> 00:03:06,579
permutation F so this permutation F

00:03:04,180 --> 00:03:08,230
called kajak F is really the core of off

00:03:06,579 --> 00:03:10,959
gate check it's really where the the

00:03:08,230 --> 00:03:12,900
crypto is real happening well most of

00:03:10,959 --> 00:03:18,250
the time is spent

00:03:12,900 --> 00:03:21,280
so this cachaca permutation is really

00:03:18,250 --> 00:03:25,049
the yeah let's say the common the common

00:03:21,280 --> 00:03:25,049
part of this presentation

00:03:30,350 --> 00:03:36,090
okay so then in 2012 the the contest

00:03:33,840 --> 00:03:37,800
ended with the announcement from this

00:03:36,090 --> 00:03:39,960
that Kate Jack was actually chosen as

00:03:37,800 --> 00:03:42,750
the winner of the Kshatriya competition

00:03:39,960 --> 00:03:44,520
and three years later it took actually

00:03:42,750 --> 00:03:46,890
three years for the knees to publish the

00:03:44,520 --> 00:03:50,130
fifth - OH - Stan de with the sherry

00:03:46,890 --> 00:03:52,860
hash functions meant as a drop-in

00:03:50,130 --> 00:03:56,600
replacement for Chateau harmony of hash

00:03:52,860 --> 00:03:59,790
functions but they also standardized

00:03:56,600 --> 00:04:04,110
extendable output function jobs called

00:03:59,790 --> 00:04:07,350
shake 128 and shake 256 so generalizing

00:04:04,110 --> 00:04:11,220
the concept of hash functions to an

00:04:07,350 --> 00:04:13,080
arbitrary output size in the meantime

00:04:11,220 --> 00:04:19,260
before it was actually standardized by

00:04:13,080 --> 00:04:21,420
nist the 3gpp consortium published a new

00:04:19,260 --> 00:04:24,570
standard called to work making use of

00:04:21,420 --> 00:04:26,760
kajak internally for application in SIM

00:04:24,570 --> 00:04:29,100
cards and then more recently in December

00:04:26,760 --> 00:04:31,710
last year the NIST published some new

00:04:29,100 --> 00:04:40,680
functions standardized based on K check

00:04:31,710 --> 00:04:43,880
and special publications 801 85 and on

00:04:40,680 --> 00:04:47,970
the side of this standardization process

00:04:43,880 --> 00:04:52,560
we actually worked on other variants of

00:04:47,970 --> 00:04:54,840
ghachok so catcher and KIAC are

00:04:52,560 --> 00:04:57,270
authenticated encryption schemes based

00:04:54,840 --> 00:04:58,650
on Tkaczyk which we submitted to the

00:04:57,270 --> 00:05:00,330
seeds of competition so the Caesar

00:04:58,650 --> 00:05:03,180
competition is a currently ongoing

00:05:00,330 --> 00:05:05,520
competition for new authenticated

00:05:03,180 --> 00:05:08,100
encryption schemes

00:05:05,520 --> 00:05:11,070
last year we proposed a new hash

00:05:08,100 --> 00:05:13,980
function called kangaroo 12 and then

00:05:11,070 --> 00:05:16,730
recently we are working on a new set of

00:05:13,980 --> 00:05:20,100
functions called cavity I will discuss

00:05:16,730 --> 00:05:21,810
this in a moment so this presentation

00:05:20,100 --> 00:05:25,820
the focus on this presentation is really

00:05:21,810 --> 00:05:25,820
on these new functions

00:05:27,659 --> 00:05:34,030
so let me discuss the security

00:05:30,969 --> 00:05:38,199
properties and so I want to show you is

00:05:34,030 --> 00:05:41,199
that in symmetric crypto the security

00:05:38,199 --> 00:05:43,210
relies on on two different parts one

00:05:41,199 --> 00:05:45,400
part is the generic security so the

00:05:43,210 --> 00:05:48,879
security of the mode and the other is

00:05:45,400 --> 00:05:51,129
the security of the primitive so to take

00:05:48,879 --> 00:05:52,749
a check as an example the mode is the

00:05:51,129 --> 00:05:54,909
sponge construction it tells you to

00:05:52,749 --> 00:05:56,770
initialize the stage to zero it tells

00:05:54,909 --> 00:05:58,960
you to cut the input into blocks to sew

00:05:56,770 --> 00:06:00,939
them into the state it tells you to

00:05:58,960 --> 00:06:02,860
apply the function f and it tells you

00:06:00,939 --> 00:06:05,500
how to get the output that's that's the

00:06:02,860 --> 00:06:07,300
mode that's how it works on top of the

00:06:05,500 --> 00:06:12,370
permutation and then of course there is

00:06:07,300 --> 00:06:15,400
a permutation can we say something about

00:06:12,370 --> 00:06:17,740
this construction yes we can say

00:06:15,400 --> 00:06:20,379
something if we make abstraction of the

00:06:17,740 --> 00:06:22,990
permutations we replace this function f

00:06:20,379 --> 00:06:25,870
this concrete permutation that you can

00:06:22,990 --> 00:06:28,629
implement in C or any language you can

00:06:25,870 --> 00:06:31,449
replace it virtually by a random

00:06:28,629 --> 00:06:34,150
permutation and if you do that then you

00:06:31,449 --> 00:06:36,099
can start a proof you can you can prove

00:06:34,150 --> 00:06:38,589
theorems about the security of this

00:06:36,099 --> 00:06:41,979
scheme when the function is replaced by

00:06:38,589 --> 00:06:44,830
a randomly chosen permutation and you

00:06:41,979 --> 00:06:46,949
can even derive some theorems this is a

00:06:44,830 --> 00:06:52,419
theorem that we proved at your equipped

00:06:46,949 --> 00:06:56,529
2008 don't worry I'm going to explain

00:06:52,419 --> 00:06:58,509
what it means so first let me go back

00:06:56,529 --> 00:07:00,370
once right so one important parameter of

00:06:58,509 --> 00:07:02,979
the spawns construction is the capacity

00:07:00,370 --> 00:07:05,379
the value C that appears on on the left

00:07:02,979 --> 00:07:07,960
side of this presentation of this figure

00:07:05,379 --> 00:07:09,759
so it's the size of the part of the

00:07:07,960 --> 00:07:13,539
state that is not directly touched by

00:07:09,759 --> 00:07:17,349
the input or the output blocks and the

00:07:13,539 --> 00:07:18,879
security highly depends on this value so

00:07:17,349 --> 00:07:20,949
what this theorem says is that if I

00:07:18,879 --> 00:07:23,229
replace in cachaca replace the

00:07:20,949 --> 00:07:25,149
permutation by a random permutation then

00:07:23,229 --> 00:07:27,939
the probability of some of some attack

00:07:25,149 --> 00:07:31,419
to be successful is upper bounded by n

00:07:27,939 --> 00:07:34,180
square over 2 to C plus 1 where n is the

00:07:31,419 --> 00:07:36,639
time spent by the adversary and the time

00:07:34,180 --> 00:07:38,490
unit is the time needed to compute once

00:07:36,639 --> 00:07:41,729
the permutation F

00:07:38,490 --> 00:07:44,370
so as long as this time n is much

00:07:41,729 --> 00:07:46,289
smaller than 2 to the C over 2 then this

00:07:44,370 --> 00:07:48,840
probability is negligible and we have

00:07:46,289 --> 00:07:51,990
security of after of the mood of

00:07:48,840 --> 00:07:54,569
response construction so if we want to

00:07:51,990 --> 00:07:57,180
have for instance security at the level

00:07:54,569 --> 00:08:01,860
of 128 bits then we need to take a

00:07:57,180 --> 00:08:04,139
capacity of at least 256 bits but of

00:08:01,860 --> 00:08:08,099
course this does not tell us anything

00:08:04,139 --> 00:08:13,470
when we replace this black permutation

00:08:08,099 --> 00:08:15,599
here by the concrete kajak F so the nice

00:08:13,470 --> 00:08:17,250
thing about these generic security is

00:08:15,599 --> 00:08:19,650
that you can actually reduce the scope

00:08:17,250 --> 00:08:21,270
of cryptanalysis and focus only on the

00:08:19,650 --> 00:08:22,650
permutation because what it tells you is

00:08:21,270 --> 00:08:24,570
that if there is a problem in catch a

00:08:22,650 --> 00:08:26,009
key it should not come from from the

00:08:24,570 --> 00:08:30,150
Swanage construction it should only come

00:08:26,009 --> 00:08:32,039
from the permutation but the problem is

00:08:30,150 --> 00:08:34,020
that when you talk about the security of

00:08:32,039 --> 00:08:36,209
of the content of the permutation of the

00:08:34,020 --> 00:08:38,490
primitives then there is no mathematical

00:08:36,209 --> 00:08:41,789
proof that it's secure so the only way

00:08:38,490 --> 00:08:45,540
to to gain some confidence is first to

00:08:41,789 --> 00:08:48,630
have some open design rationale of of

00:08:45,540 --> 00:08:52,350
the permutation and then have some crypt

00:08:48,630 --> 00:08:55,160
analysis and preferably peer review

00:08:52,350 --> 00:08:58,500
meaning third party crypt analysis and

00:08:55,160 --> 00:09:00,660
what's even better a lot of route

00:08:58,500 --> 00:09:02,550
analysis is if you want to build

00:09:00,660 --> 00:09:05,520
confidence then you need to have some

00:09:02,550 --> 00:09:07,079
sustained cryptanalysis activity on the

00:09:05,520 --> 00:09:10,800
function and the function of course not

00:09:07,079 --> 00:09:14,149
broken that is the only way to actually

00:09:10,800 --> 00:09:17,779
have the security of most symmetric

00:09:14,149 --> 00:09:17,779
crypto primitives

00:09:19,049 --> 00:09:25,230
so now let's discuss further with the

00:09:22,720 --> 00:09:27,459
cachaca fermentation most cryptographic

00:09:25,230 --> 00:09:30,339
primitives and including the cachaÃ§a

00:09:27,459 --> 00:09:30,910
permutation is actually divided in two

00:09:30,339 --> 00:09:33,939
rounds

00:09:30,910 --> 00:09:36,429
so around by itself is a very simple set

00:09:33,939 --> 00:09:39,339
of operations and by itself it does not

00:09:36,429 --> 00:09:42,129
provide any security but if you repeat

00:09:39,339 --> 00:09:44,109
this round many times and enough times

00:09:42,129 --> 00:09:46,989
then the security starts to build up and

00:09:44,109 --> 00:09:49,179
there is a point where the there are

00:09:46,989 --> 00:09:52,119
enough rounds for that permutation to be

00:09:49,179 --> 00:09:58,899
to be strong and then in this case for

00:09:52,119 --> 00:10:00,549
character to be secure what people

00:09:58,899 --> 00:10:02,319
actually do when when doing crypt

00:10:00,549 --> 00:10:04,179
analysis is that they try to break one

00:10:02,319 --> 00:10:05,799
round to around and so on and then see

00:10:04,179 --> 00:10:08,319
how far they can go

00:10:05,799 --> 00:10:10,449
so the status for cachaca is the

00:10:08,319 --> 00:10:14,169
following catcha kev the largest

00:10:10,449 --> 00:10:16,359
permutation has 24 rounds catch a key

00:10:14,169 --> 00:10:18,609
has been practically broken up to five

00:10:16,359 --> 00:10:21,549
rounds the best attack on five rounds is

00:10:18,609 --> 00:10:24,999
a collision attack published last year

00:10:21,549 --> 00:10:27,579
if you allow complexities that are

00:10:24,999 --> 00:10:31,419
theoretical so not having an explicit

00:10:27,579 --> 00:10:33,730
example but an algorithm of complexity

00:10:31,419 --> 00:10:35,709
less than the expected complexity then

00:10:33,730 --> 00:10:39,699
you can have collision attacks up to six

00:10:35,709 --> 00:10:42,160
rounds and now if you allow any kind of

00:10:39,699 --> 00:10:47,079
attacks then the best theoretical

00:10:42,160 --> 00:10:49,449
attacks are up to nine rounds but nine

00:10:47,079 --> 00:10:52,540
rounds in that case it's a time two to

00:10:49,449 --> 00:10:54,610
the power 256 which is a huge number

00:10:52,540 --> 00:10:56,769
it's even higher than the number of

00:10:54,610 --> 00:10:59,980
particles in the universe so that's

00:10:56,769 --> 00:11:02,169
really theoretical so we can see from

00:10:59,980 --> 00:11:04,059
this figure that the 24 rounds of

00:11:02,169 --> 00:11:09,209
ketchup

00:11:04,059 --> 00:11:09,209
are actually rock solid safety margin

00:11:11,410 --> 00:11:18,530
okay so let me discuss some unsealed

00:11:15,590 --> 00:11:21,580
applications so the most obvious unclear

00:11:18,530 --> 00:11:24,950
application of chechik is simply hashing

00:11:21,580 --> 00:11:26,870
so a hash function if I need to recall

00:11:24,950 --> 00:11:29,510
what it is is simply a function that

00:11:26,870 --> 00:11:31,970
takes as input any string of bits of any

00:11:29,510 --> 00:11:36,200
size so it can be a small message or a

00:11:31,970 --> 00:11:38,870
picture complete DVD and then it

00:11:36,200 --> 00:11:42,350
processes it and you get as output a

00:11:38,870 --> 00:11:45,020
digest of fixed size 256 bits for

00:11:42,350 --> 00:11:48,740
instance which acts as kind of a

00:11:45,020 --> 00:11:50,090
fingerprint of the input obviously the

00:11:48,740 --> 00:11:52,760
response construction can be used for

00:11:50,090 --> 00:11:58,630
that the input is then your big file and

00:11:52,760 --> 00:12:03,470
the output is your digest now for the

00:11:58,630 --> 00:12:05,780
performance of the function you can see

00:12:03,470 --> 00:12:07,310
that within the permutation F there can

00:12:05,780 --> 00:12:09,890
be a lot of parallelism that you can

00:12:07,310 --> 00:12:11,330
exploit but beyond that you can see that

00:12:09,890 --> 00:12:17,540
the spawns construction by itself is

00:12:11,330 --> 00:12:21,410
quite serial if you implement the

00:12:17,540 --> 00:12:26,270
permutation catch a cave on skylake CPU

00:12:21,410 --> 00:12:28,940
you get about 1100 cycles for one

00:12:26,270 --> 00:12:31,580
application of the permutation if you

00:12:28,940 --> 00:12:34,280
now implement this permutation but using

00:12:31,580 --> 00:12:37,100
vector instructions by performing

00:12:34,280 --> 00:12:39,920
evaluating for different permutations in

00:12:37,100 --> 00:12:44,000
parallel then the time grows slightly to

00:12:39,920 --> 00:12:45,110
400 cycles so per input byte you can

00:12:44,000 --> 00:12:48,650
clearly see that it's more interesting

00:12:45,110 --> 00:12:51,860
to compute for permutations in parallel

00:12:48,650 --> 00:12:54,950
than just one so what can we do to

00:12:51,860 --> 00:12:57,770
exploit this kind of parallelism we can

00:12:54,950 --> 00:13:00,500
do some three rushing so triaging is

00:12:57,770 --> 00:13:03,020
just taking the input cutting it into

00:13:00,500 --> 00:13:05,480
pieces and then evaluating the hash as a

00:13:03,020 --> 00:13:09,320
tree where each there should be a slight

00:13:05,480 --> 00:13:11,900
coming in but my PC is a bit slow yes so

00:13:09,320 --> 00:13:14,780
the message is cut into some pieces and

00:13:11,900 --> 00:13:17,720
then each piece is hashed separately and

00:13:14,780 --> 00:13:22,270
then the digest are then concatenate it

00:13:17,720 --> 00:13:22,270
and hashed again to get the final harsh

00:13:22,430 --> 00:13:27,740
in the latest standard from this there

00:13:25,010 --> 00:13:29,900
is a spa Harlan ash function that

00:13:27,740 --> 00:13:31,700
exploits this kind of parallelism and

00:13:29,900 --> 00:13:34,930
you can see that the number of cycles

00:13:31,700 --> 00:13:37,670
per byte still on this skylake processor

00:13:34,930 --> 00:13:39,470
decreases significantly as soon as you

00:13:37,670 --> 00:13:41,870
can exploit this parallelism as soon as

00:13:39,470 --> 00:13:44,120
your input is big enough you can go down

00:13:41,870 --> 00:13:46,310
to two point three cycles per byte so

00:13:44,120 --> 00:13:50,960
which is quite fast too that's that's

00:13:46,310 --> 00:13:53,180
the existing standard we can actually go

00:13:50,960 --> 00:13:55,370
further than this and that's the purpose

00:13:53,180 --> 00:13:58,280
of this new kangaroo twelve hash

00:13:55,370 --> 00:14:01,250
function I've showed you that 24 rounds

00:13:58,280 --> 00:14:03,560
are rock-solid we can afford to decrease

00:14:01,250 --> 00:14:05,840
the safety margin a bit and actually

00:14:03,560 --> 00:14:08,450
more than a bit we can go down to twelve

00:14:05,840 --> 00:14:10,310
rounds and still have comfortable safety

00:14:08,450 --> 00:14:13,400
margin so that gives us a factor of two

00:14:10,310 --> 00:14:17,540
speed-up and then we can have a special

00:14:13,400 --> 00:14:20,450
mode at three harsh mode that has what

00:14:17,540 --> 00:14:24,920
is called embarassingly embarassingly

00:14:20,450 --> 00:14:27,800
parallel such that as soon as you have

00:14:24,920 --> 00:14:30,950
enough data as input there is as much

00:14:27,800 --> 00:14:33,430
parallelism as your platform allows you

00:14:30,950 --> 00:14:33,430
to exploit

00:14:33,490 --> 00:14:39,170
so concretely what it means is that the

00:14:36,410 --> 00:14:41,810
input message is cut into chunks and

00:14:39,170 --> 00:14:44,870
these chunks are can be potentially

00:14:41,810 --> 00:14:46,940
hashed in parallel so the more chunks

00:14:44,870 --> 00:14:49,580
you have the more parallelism you can

00:14:46,940 --> 00:14:55,280
exploit and the faster per byte it can

00:14:49,580 --> 00:14:57,290
go the first chunk has a special status

00:14:55,280 --> 00:14:58,850
in the sense that the chaining value so

00:14:57,290 --> 00:15:00,830
the intermediate digests that come from

00:14:58,850 --> 00:15:03,530
the other chunks are asked to gather

00:15:00,830 --> 00:15:06,110
with it and that's something a technique

00:15:03,530 --> 00:15:08,140
we called kangaroo hopping and that's

00:15:06,110 --> 00:15:11,840
where the name can go twelve comes from

00:15:08,140 --> 00:15:14,720
all these values 1 1 0 1 1 0 star and so

00:15:11,840 --> 00:15:17,510
on come from secure coding which we

00:15:14,720 --> 00:15:20,060
defined and the idea is that as soon as

00:15:17,510 --> 00:15:22,370
we use hexa core coding then generically

00:15:20,060 --> 00:15:25,280
we know that our mode is secure so that

00:15:22,370 --> 00:15:27,600
if there is no it's proven that there is

00:15:25,280 --> 00:15:29,820
no problem on the mode side

00:15:27,600 --> 00:15:32,640
if there is ammo it has to come from the

00:15:29,820 --> 00:15:34,080
permutation reduce to 12 rounds but the

00:15:32,640 --> 00:15:36,870
crypt analysis that has been done on

00:15:34,080 --> 00:15:40,020
kachuck sofa still applies to kangaroo

00:15:36,870 --> 00:15:42,300
12 so we we rely on this and we somehow

00:15:40,020 --> 00:15:44,790
inherit from from all the crypt analysis

00:15:42,300 --> 00:15:50,540
that has been done on ket Shack and to

00:15:44,790 --> 00:15:54,779
apply it on kangaroo 12 so concretely

00:15:50,540 --> 00:15:57,480
still on this skylake processor if you

00:15:54,779 --> 00:16:00,630
have a short input then the number of

00:15:57,480 --> 00:16:03,180
cycles per byte is 3.72 and as soon as

00:16:00,630 --> 00:16:04,800
you have enough input to exploit fully

00:16:03,180 --> 00:16:08,550
exploit the parallelism you can go down

00:16:04,800 --> 00:16:11,610
to one point 22 yes I forgot to mention

00:16:08,550 --> 00:16:16,200
that so this idea of kangaroo hopping

00:16:11,610 --> 00:16:18,330
with the first Chum they used with the

00:16:16,200 --> 00:16:20,610
same hash function as a digest the idea

00:16:18,330 --> 00:16:22,620
is that if your input is small then

00:16:20,610 --> 00:16:30,600
there is no overhead due to the three

00:16:22,620 --> 00:16:33,510
hush mode so this 3.72 it's really the

00:16:30,600 --> 00:16:37,230
speed for a short message as soon as

00:16:33,510 --> 00:16:38,940
there is one block for instance on the

00:16:37,230 --> 00:16:40,800
last line you can see some some figures

00:16:38,940 --> 00:16:43,020
for the knights landing architecture on

00:16:40,800 --> 00:16:45,089
that architecture they have bigger

00:16:43,020 --> 00:16:49,200
vector spaces with a bigger bigger

00:16:45,089 --> 00:16:51,660
vector registers up to 512 bits so you

00:16:49,200 --> 00:16:53,850
can compute actually eight permutations

00:16:51,660 --> 00:16:56,310
in parallel and this decreases the

00:16:53,850 --> 00:16:57,750
number of cycles per byte below one

00:16:56,310 --> 00:17:03,990
cycle per byte which is really really

00:16:57,750 --> 00:17:06,990
fast okay so now some some kid

00:17:03,990 --> 00:17:08,880
applications and what I would like to do

00:17:06,990 --> 00:17:10,530
is before I really speak about

00:17:08,880 --> 00:17:12,329
concurrent functions I would like to

00:17:10,530 --> 00:17:14,970
take a step back and talk more

00:17:12,329 --> 00:17:17,730
abstractly about pseudo-random functions

00:17:14,970 --> 00:17:21,360
and what we can do with them and yeah

00:17:17,730 --> 00:17:23,100
what they can bring to us so up to the

00:17:21,360 --> 00:17:25,709
random function is a function that takes

00:17:23,100 --> 00:17:31,620
as input a secret key and some some

00:17:25,709 --> 00:17:35,429
input string then it produces bits as

00:17:31,620 --> 00:17:38,640
many as requested from the point of view

00:17:35,429 --> 00:17:40,980
of the people who know the secret key

00:17:38,640 --> 00:17:43,380
it's a deterministic function meaning

00:17:40,980 --> 00:17:45,120
that anyone can compute it easily but

00:17:43,380 --> 00:17:47,340
from the point of view of an adversary

00:17:45,120 --> 00:17:49,020
who doesn't know the key then not

00:17:47,340 --> 00:17:50,580
knowing the key means that these bits

00:17:49,020 --> 00:17:55,830
these output bits they will look just

00:17:50,580 --> 00:17:59,309
like random bits 50/50 percent one or

00:17:55,830 --> 00:18:03,570
zero all independent that's what good

00:17:59,309 --> 00:18:06,450
PRF should look like so what can we do

00:18:03,570 --> 00:18:09,570
with such a PRF we can build a stream

00:18:06,450 --> 00:18:12,419
cipher to do some encryption so if you

00:18:09,570 --> 00:18:16,380
take the key and then give some input to

00:18:12,419 --> 00:18:18,480
your PRF you can use the output as a key

00:18:16,380 --> 00:18:21,059
string that you saw with your plaintext

00:18:18,480 --> 00:18:23,760
so if you do that the ciphertext

00:18:21,059 --> 00:18:27,480
will look like garbage and there is no

00:18:23,760 --> 00:18:31,620
way to recover the plaintext the nuns

00:18:27,480 --> 00:18:33,540
there is some identifier so that every

00:18:31,620 --> 00:18:35,309
time you use it you use a different nuns

00:18:33,540 --> 00:18:37,140
so that you get a different and

00:18:35,309 --> 00:18:40,440
independent key stream and you can reuse

00:18:37,140 --> 00:18:42,090
the same key the same long term key okay

00:18:40,440 --> 00:18:46,140
so that's for encryption for

00:18:42,090 --> 00:18:49,049
confidentiality a second application is

00:18:46,140 --> 00:18:52,980
authentication so what you want to have

00:18:49,049 --> 00:18:55,260
is transmit a message in the clear but

00:18:52,980 --> 00:18:58,169
have a way to make sure that this was

00:18:55,260 --> 00:19:00,660
not changed on on the way so yeah maybe

00:18:58,169 --> 00:19:01,980
a client sending a message to a server

00:19:00,660 --> 00:19:03,660
and the server wants to make sure that

00:19:01,980 --> 00:19:05,940
the message actually comes from the

00:19:03,660 --> 00:19:08,309
legitimate client what you can do is

00:19:05,940 --> 00:19:10,919
apply the PRF to the plaintext your

00:19:08,309 --> 00:19:13,740
message and you can use that output as

00:19:10,919 --> 00:19:15,570
kind of a tag that you attach to your

00:19:13,740 --> 00:19:18,299
message then you send the message in the

00:19:15,570 --> 00:19:21,960
clear plus the tag the server is then

00:19:18,299 --> 00:19:24,330
able to really compute this tag checks

00:19:21,960 --> 00:19:25,919
that it's correct that is much if it

00:19:24,330 --> 00:19:29,270
matches that means that the plaintext

00:19:25,919 --> 00:19:29,270
was actually not changed

00:19:30,799 --> 00:19:37,799
now you can combine the two you can use

00:19:34,829 --> 00:19:39,839
the PRF once to get some keystream means

00:19:37,799 --> 00:19:42,719
you can encrypt your plain text into

00:19:39,839 --> 00:19:45,059
ciphertext and then you use it a second

00:19:42,719 --> 00:19:46,679
time to have a tag over the ciphertext

00:19:45,059 --> 00:19:48,269
and in that case you achieve at the same

00:19:46,679 --> 00:19:50,429
time confidentiality and authentication

00:19:48,269 --> 00:19:52,619
you have your ciphertext and readable

00:19:50,429 --> 00:19:55,199
and the tag that protects against any

00:19:52,619 --> 00:20:00,899
changes that an adversary we try to do

00:19:55,199 --> 00:20:04,619
on the message on the way an I thing

00:20:00,899 --> 00:20:07,559
that we want to achieve with a PRF is

00:20:04,619 --> 00:20:09,269
called incrementality so it's let's

00:20:07,559 --> 00:20:12,179
assume that you want to authenticate

00:20:09,269 --> 00:20:14,909
some some packets flowing from a client

00:20:12,179 --> 00:20:16,889
to a server so first you have this first

00:20:14,909 --> 00:20:19,829
packet you compute a tag over this first

00:20:16,889 --> 00:20:23,279
packet and you send it then a second

00:20:19,829 --> 00:20:26,339
packet needs to be transmitted then what

00:20:23,279 --> 00:20:28,949
you want to have is a tag over the first

00:20:26,339 --> 00:20:30,929
two packets together but you don't need

00:20:28,949 --> 00:20:35,129
to compute everything again you just

00:20:30,929 --> 00:20:37,259
take the result of the computation with

00:20:35,129 --> 00:20:39,119
the first packet and you extend it you

00:20:37,259 --> 00:20:41,759
extend your computation with the second

00:20:39,119 --> 00:20:44,819
packet then the tag you get is a tag

00:20:41,759 --> 00:20:47,209
over the concatenation of packet one and

00:20:44,819 --> 00:20:50,189
packet two and you can go on like this

00:20:47,209 --> 00:20:51,899
in this case the final tag on packet

00:20:50,189 --> 00:20:54,059
three authenticates not only packet

00:20:51,899 --> 00:20:55,979
three but the actual sequence of packet

00:20:54,059 --> 00:20:57,959
one packet two packet three so there is

00:20:55,979 --> 00:20:59,699
no way that the adversary can can

00:20:57,959 --> 00:21:04,079
reshuffle the packets for instance the

00:20:59,699 --> 00:21:07,079
tag then will not match so there are at

00:21:04,079 --> 00:21:10,699
least two ways that we can instantiate

00:21:07,079 --> 00:21:13,409
this PRF to build schemes

00:21:10,699 --> 00:21:15,839
the first one is essentially based on

00:21:13,409 --> 00:21:17,009
the sponge construction and the second

00:21:15,839 --> 00:21:19,949
one is based on the new construction

00:21:17,009 --> 00:21:21,839
called farfalle so let me first start

00:21:19,949 --> 00:21:24,449
with sponge-like

00:21:21,839 --> 00:21:27,599
constructions and the first example is

00:21:24,449 --> 00:21:29,369
kkeok so kkeok is an authenticated

00:21:27,599 --> 00:21:31,559
encryption scheme that we submitted to

00:21:29,369 --> 00:21:33,479
the C's of competition it uses the

00:21:31,559 --> 00:21:36,350
kichaka's permutation but reduced to

00:21:33,479 --> 00:21:39,270
twelve rounds a lakh can go to

00:21:36,350 --> 00:21:42,870
it works in sessions so the idea is

00:21:39,270 --> 00:21:45,780
really it really extends what I said in

00:21:42,870 --> 00:21:48,420
the previous slide so the idea is to

00:21:45,780 --> 00:21:49,680
authenticate the full to encrypt and to

00:21:48,420 --> 00:21:53,310
enter netiquette the full the full

00:21:49,680 --> 00:21:55,470
session so let's say that you start the

00:21:53,310 --> 00:21:57,570
session with some some session key

00:21:55,470 --> 00:21:59,910
it's called SUV because it needs to be

00:21:57,570 --> 00:22:01,950
secret and unique so it can be a session

00:21:59,910 --> 00:22:04,500
key meaning that it's different every

00:22:01,950 --> 00:22:08,310
time you open a new connection it could

00:22:04,500 --> 00:22:10,320
also be a long term key but you are

00:22:08,310 --> 00:22:12,330
joined to it some some counter some

00:22:10,320 --> 00:22:18,000
connection identifier that changes every

00:22:12,330 --> 00:22:20,550
time so let's say you you have your

00:22:18,000 --> 00:22:22,410
first plaintext P that comes in and some

00:22:20,550 --> 00:22:24,270
metadata a that you don't need to

00:22:22,410 --> 00:22:26,670
encrypt but still you want to

00:22:24,270 --> 00:22:28,950
authenticate it then what you will get

00:22:26,670 --> 00:22:32,190
is some cipher text from your plaintext

00:22:28,950 --> 00:22:35,250
and attack covering both the plaintext

00:22:32,190 --> 00:22:37,590
and the metadata then you can go on with

00:22:35,250 --> 00:22:39,330
more plain text and more metadata every

00:22:37,590 --> 00:22:42,270
time you get some cipher text and attack

00:22:39,330 --> 00:22:45,030
that Tentacles all the session so far

00:22:42,270 --> 00:22:47,580
and then maybe here in this last example

00:22:45,030 --> 00:22:49,050
just some more metadata maybe just a

00:22:47,580 --> 00:22:51,540
confirmation that does not need to be

00:22:49,050 --> 00:22:53,880
encrypted but that just that is OK and

00:22:51,540 --> 00:22:56,490
then the tag on this okay actually is

00:22:53,880 --> 00:22:58,650
okay over the entire session so

00:22:56,490 --> 00:23:03,530
including the context on which this okay

00:22:58,650 --> 00:23:08,610
is is sent so that's really useful in in

00:23:03,530 --> 00:23:11,610
encrypting a network communication then

00:23:08,610 --> 00:23:13,350
we submit a second proposal to the

00:23:11,610 --> 00:23:15,000
Caesar competition called catcher it's

00:23:13,350 --> 00:23:16,980
again based on catch act but it's

00:23:15,000 --> 00:23:18,720
sufficiently different from kiuic to

00:23:16,980 --> 00:23:22,440
deserve a separate submission and

00:23:18,720 --> 00:23:26,190
separate name catcher has less features

00:23:22,440 --> 00:23:28,740
than kkeok but is also simpler and and

00:23:26,190 --> 00:23:30,840
targeted at lightweight applications

00:23:28,740 --> 00:23:33,260
like the Internet of Things and you can

00:23:30,840 --> 00:23:35,880
instantiate it with smaller permutations

00:23:33,260 --> 00:23:37,980
400 and 200 bits so that it can be

00:23:35,880 --> 00:23:40,220
really small in hardware or in embedded

00:23:37,980 --> 00:23:40,220
software

00:23:41,430 --> 00:23:46,660
then the second set of constructions I

00:23:44,800 --> 00:23:48,790
would like to talk about this is really

00:23:46,660 --> 00:23:50,560
new so it's really it's based on the

00:23:48,790 --> 00:23:52,930
phallic construction so the phallic

00:23:50,560 --> 00:23:56,260
construction is this figure it resembles

00:23:52,930 --> 00:23:58,330
somehow a farfalle pasta Jewish so the

00:23:56,260 --> 00:24:01,570
idea here is that we try to exploit

00:23:58,330 --> 00:24:04,570
parallelism as much as we can so on the

00:24:01,570 --> 00:24:07,450
left side you have the secret key that

00:24:04,570 --> 00:24:10,560
is used every time and then the input

00:24:07,450 --> 00:24:12,880
blocks so the input message is cut into

00:24:10,560 --> 00:24:15,910
input blocks and zero and one and so on

00:24:12,880 --> 00:24:18,610
and all these blocks are processed to

00:24:15,910 --> 00:24:23,080
the permutation F in parallel and the

00:24:18,610 --> 00:24:25,720
results are summed together so this

00:24:23,080 --> 00:24:28,150
gives us the parallelism and the

00:24:25,720 --> 00:24:31,180
incrementality because if you have more

00:24:28,150 --> 00:24:33,910
input blocks that come in you just need

00:24:31,180 --> 00:24:37,450
to add to the counter that you already

00:24:33,910 --> 00:24:39,720
have had this at this time then to get

00:24:37,450 --> 00:24:43,780
some output you apply F again and then

00:24:39,720 --> 00:24:47,200
some more F for each output blocks so

00:24:43,780 --> 00:24:49,330
you can get an output of any size and

00:24:47,200 --> 00:24:51,250
again if you have if you want to have a

00:24:49,330 --> 00:24:53,080
long output you want to do string

00:24:51,250 --> 00:24:54,880
encryption for instance then all these

00:24:53,080 --> 00:24:57,130
output blocks can be computed in

00:24:54,880 --> 00:25:00,430
parallel if you if your platform allows

00:24:57,130 --> 00:25:02,680
you so so this is the farfalle

00:25:00,430 --> 00:25:05,530
construction and cavity is an instance

00:25:02,680 --> 00:25:08,470
using the kichaka's permutation but with

00:25:05,530 --> 00:25:11,920
the number of rounds really reduced to

00:25:08,470 --> 00:25:14,320
not much so typically what we expect now

00:25:11,920 --> 00:25:17,410
is to have six rounds four rounds and

00:25:14,320 --> 00:25:22,320
four rounds so it means fourteen rounds

00:25:17,410 --> 00:25:25,600
in total if you remember the figure with

00:25:22,320 --> 00:25:28,270
2400 was really rock solid so fourteen

00:25:25,600 --> 00:25:34,090
rounds between input and output that's

00:25:28,270 --> 00:25:36,610
already quite quite safe so now that we

00:25:34,090 --> 00:25:38,680
have this PRF we can we can just apply

00:25:36,610 --> 00:25:40,690
them in a simple way just as I explained

00:25:38,680 --> 00:25:43,690
in the beginning of this this part of

00:25:40,690 --> 00:25:46,360
the presentation we can build some so

00:25:43,690 --> 00:25:49,210
concrete PRF to compute some some some

00:25:46,360 --> 00:25:51,310
knock some authentication code we can

00:25:49,210 --> 00:25:53,680
have different flavors of authenticated

00:25:51,310 --> 00:25:55,330
encryption schemes and I wish to point

00:25:53,680 --> 00:25:58,450
out the last one which is a wide block

00:25:55,330 --> 00:26:00,460
cipher so wide block cipher is simply

00:25:58,450 --> 00:26:02,470
another thing it authenticated

00:26:00,460 --> 00:26:05,500
encryption scheme that doesn't have any

00:26:02,470 --> 00:26:07,510
expansion so if you encrypt a blog of a

00:26:05,500 --> 00:26:09,610
given size then the output will be of

00:26:07,510 --> 00:26:11,740
the same size and if you want to check

00:26:09,610 --> 00:26:14,890
the authenticity then you need to rely

00:26:11,740 --> 00:26:18,580
either on the existing redundancy of

00:26:14,890 --> 00:26:20,710
your input or if you really don't have

00:26:18,580 --> 00:26:23,140
that you need to add some some

00:26:20,710 --> 00:26:25,030
redundancy yourself bhop beforehand but

00:26:23,140 --> 00:26:27,100
it can be really interesting if you

00:26:25,030 --> 00:26:29,200
don't want to have any expansion if you

00:26:27,100 --> 00:26:31,960
don't cannot afford to have a tag

00:26:29,200 --> 00:26:34,300
attached to your message so concretely

00:26:31,960 --> 00:26:37,750
if you encrypt with a wide block cipher

00:26:34,300 --> 00:26:38,890
a picture and then at the decryption you

00:26:37,750 --> 00:26:40,930
get something which is really garbage

00:26:38,890 --> 00:26:43,960
doesn't look like a picture then you're

00:26:40,930 --> 00:26:46,450
sure that your your message was tampered

00:26:43,960 --> 00:26:49,240
with so any changes will diffuse

00:26:46,450 --> 00:26:52,150
completely over the full plaintext and

00:26:49,240 --> 00:26:53,470
and your redundancy so the fact that it

00:26:52,150 --> 00:26:55,630
was actually a picture a meaningful

00:26:53,470 --> 00:26:57,280
picture is destroyed completely so it's

00:26:55,630 --> 00:27:03,310
all or nothing so that's quite

00:26:57,280 --> 00:27:07,360
interesting okay so that that's all for

00:27:03,310 --> 00:27:08,950
the applications now let me give you

00:27:07,360 --> 00:27:13,420
some words about the Quecha code package

00:27:08,950 --> 00:27:18,460
so the Quecha code package is simply set

00:27:13,420 --> 00:27:20,980
an open source set of of code

00:27:18,460 --> 00:27:23,220
implementing the key check function and

00:27:20,980 --> 00:27:26,200
all the variants that i've mentioned

00:27:23,220 --> 00:27:30,340
except cavity with which we are still

00:27:26,200 --> 00:27:34,510
tuning and we hope to release it soon

00:27:30,340 --> 00:27:37,150
this month hopefully so concretely what

00:27:34,510 --> 00:27:39,980
can you do first you can the simplest

00:27:37,150 --> 00:27:43,970
way is to make a library so we can just

00:27:39,980 --> 00:27:46,370
make lipcott check dot a and the prefix

00:27:43,970 --> 00:27:48,679
their generic 64 32 and so on that's

00:27:46,370 --> 00:27:52,039
really the flavor of the implementation

00:27:48,679 --> 00:27:53,779
we you wish to have so generic 64 is

00:27:52,039 --> 00:27:56,230
simply generically optimized

00:27:53,779 --> 00:27:58,970
implementation for 64-bit platforms

00:27:56,230 --> 00:28:01,460
generic 32 the same format for 32-bit

00:27:58,970 --> 00:28:05,059
platforms and then you can have some

00:28:01,460 --> 00:28:09,230
specific more specific set of of code

00:28:05,059 --> 00:28:12,590
for specific targets if you don't want

00:28:09,230 --> 00:28:14,600
to have a library just want to have the

00:28:12,590 --> 00:28:17,029
source files and to integrate them into

00:28:14,600 --> 00:28:18,830
your project you just do the same but

00:28:17,029 --> 00:28:21,200
with that back at the end and it will

00:28:18,830 --> 00:28:23,000
create an archive with all the files

00:28:21,200 --> 00:28:26,510
that you that you need for a given

00:28:23,000 --> 00:28:29,720
target then there are some more things

00:28:26,510 --> 00:28:31,580
you can do it it's a it comes with a

00:28:29,720 --> 00:28:33,980
complete set of unit tests and you can

00:28:31,580 --> 00:28:36,350
run this unit tests with ghachok tests

00:28:33,980 --> 00:28:38,419
you can say I want this or that test I

00:28:36,350 --> 00:28:41,269
want to have some speed measurements you

00:28:38,419 --> 00:28:44,570
can do that from the command line and of

00:28:41,269 --> 00:28:49,490
course you can extend that in any way

00:28:44,570 --> 00:28:53,149
you wish so let me give you some more

00:28:49,490 --> 00:28:55,789
details on how it's organized inside the

00:28:53,149 --> 00:29:00,669
sketchup could package so the idea is

00:28:55,789 --> 00:29:02,779
that we have one layer above that is

00:29:00,669 --> 00:29:05,570
implementing the modes and constructions

00:29:02,779 --> 00:29:08,289
in the more generic way so there is no

00:29:05,570 --> 00:29:10,929
optimization it's plain C code it's

00:29:08,289 --> 00:29:13,970
portable code and there is only one

00:29:10,929 --> 00:29:18,470
implementation the idea here is really

00:29:13,970 --> 00:29:20,809
to make the life of the user easy and

00:29:18,470 --> 00:29:25,610
there is nothing going on specifically

00:29:20,809 --> 00:29:28,000
for a specific target then there is this

00:29:25,610 --> 00:29:31,460
interface called state and permutation

00:29:28,000 --> 00:29:34,700
and below which you can hide the details

00:29:31,460 --> 00:29:36,980
of an implementation of a given of the

00:29:34,700 --> 00:29:39,230
permutation for a given platform and it

00:29:36,980 --> 00:29:41,120
will do all the state management so

00:29:39,230 --> 00:29:43,639
soaring bytes into it and applying of

00:29:41,120 --> 00:29:45,620
course the permutation you can then

00:29:43,639 --> 00:29:48,379
easily substitute one implementation

00:29:45,620 --> 00:29:50,539
below SNP with another that is more

00:29:48,379 --> 00:29:52,650
optimized for your given platform and

00:29:50,539 --> 00:29:58,830
everything above S&P will still

00:29:52,650 --> 00:30:02,730
which he'll work okay so I'm I will

00:29:58,830 --> 00:30:06,720
recap on what I mentioned before with

00:30:02,730 --> 00:30:08,460
some inventory so for hash functions and

00:30:06,720 --> 00:30:10,860
extendable output function so the

00:30:08,460 --> 00:30:12,600
generalization of hash functions to any

00:30:10,860 --> 00:30:16,130
output size we have some standard

00:30:12,600 --> 00:30:18,840
rock-solid instances so the Kshatriya

00:30:16,130 --> 00:30:20,970
instances the shake from 5202

00:30:18,840 --> 00:30:24,750
and then there's an ionization of shake

00:30:20,970 --> 00:30:26,460
with c shake in the latest standard

00:30:24,750 --> 00:30:29,730
sochi shake is like shake except that

00:30:26,460 --> 00:30:32,039
you can you have an extra input which is

00:30:29,730 --> 00:30:34,409
a customization string an advantage like

00:30:32,039 --> 00:30:36,990
you can have them in separation between

00:30:34,409 --> 00:30:38,789
different hash functions so if you put a

00:30:36,990 --> 00:30:41,190
different customization string you

00:30:38,789 --> 00:30:43,820
immediately get a new hash function with

00:30:41,190 --> 00:30:46,980
the output which that is independent of

00:30:43,820 --> 00:30:50,010
C shape with a different customization

00:30:46,980 --> 00:30:52,980
string double hash is also a

00:30:50,010 --> 00:30:55,380
generalization the idea here is that the

00:30:52,980 --> 00:30:58,559
input is just not one string of bits but

00:30:55,380 --> 00:31:01,110
it can be any number of of strings and

00:30:58,559 --> 00:31:03,390
of course then the result will not

00:31:01,110 --> 00:31:05,309
depend just on the concatenation of all

00:31:03,390 --> 00:31:09,179
the inputs but really on the exact

00:31:05,309 --> 00:31:12,000
sequence of inputs that you have you can

00:31:09,179 --> 00:31:14,299
have a set of string and then give you

00:31:12,000 --> 00:31:18,120
that as as input - 2 / -

00:31:14,299 --> 00:31:20,250
pahala as I mentioned is the 3 hushing

00:31:18,120 --> 00:31:24,000
mode that has been standardized by NIST

00:31:20,250 --> 00:31:28,289
and then can go 12 the more the faster

00:31:24,000 --> 00:31:31,440
version then something I didn't mention

00:31:28,289 --> 00:31:33,899
explicitly but another useful uncute

00:31:31,440 --> 00:31:36,120
application of hash functions is absurd

00:31:33,899 --> 00:31:37,890
Oh handle number generation so the

00:31:36,120 --> 00:31:41,399
purpose of PRNG

00:31:37,890 --> 00:31:43,919
is if you have some random bits at the

00:31:41,399 --> 00:31:46,559
input but these bits are not well

00:31:43,919 --> 00:31:50,279
balanced maybe in this case clearly

00:31:46,559 --> 00:31:54,029
there is a bias and you want to turn

00:31:50,279 --> 00:31:56,490
that into a sequence of bits that really

00:31:54,029 --> 00:31:59,429
look random uniformly distributed then

00:31:56,490 --> 00:32:00,929
the PRNG can can do that so in the

00:31:59,429 --> 00:32:05,620
Quecha code package we also implemented

00:32:00,929 --> 00:32:09,289
kajak PRG which is based on our sac 2011

00:32:05,620 --> 00:32:11,899
proposal and it has some some extra

00:32:09,289 --> 00:32:14,570
features if you have more seeds that

00:32:11,899 --> 00:32:16,940
come in you can at any time add them so

00:32:14,570 --> 00:32:20,210
that they get mixed to the state and

00:32:16,940 --> 00:32:23,120
then your output will depend on them and

00:32:20,210 --> 00:32:25,490
the second feature is forward secrecy so

00:32:23,120 --> 00:32:29,360
at any given time you can say okay

00:32:25,490 --> 00:32:31,850
forget the past and if you're stating is

00:32:29,360 --> 00:32:34,130
compromised if let's say the PC is

00:32:31,850 --> 00:32:36,049
generating secret keys and at some point

00:32:34,130 --> 00:32:38,269
the memory is recovered by by an attack

00:32:36,049 --> 00:32:41,240
then the attacker cannot go back this

00:32:38,269 --> 00:32:43,240
point so it's irreversible and cannot

00:32:41,240 --> 00:32:47,769
find the secret keys that have been

00:32:43,240 --> 00:32:52,519
derived using this function before this

00:32:47,769 --> 00:32:56,210
irreversible operation an authentication

00:32:52,519 --> 00:32:58,580
there is chemic part of the SP 800 185

00:32:56,210 --> 00:33:02,539
of course you could use H Mac with

00:32:58,580 --> 00:33:05,679
shatori but that's reserved optimal not

00:33:02,539 --> 00:33:07,700
a good idea you can use key XO chiaki's

00:33:05,679 --> 00:33:11,299
authenticate the encryption but you can

00:33:07,700 --> 00:33:13,820
use it also for simple Mac and then this

00:33:11,299 --> 00:33:17,539
cavity a new construction can be used

00:33:13,820 --> 00:33:18,980
also for authentication and then

00:33:17,539 --> 00:33:21,860
authenticate the encryption of course

00:33:18,980 --> 00:33:25,539
sketchy o'ciock and then all the flavors

00:33:21,860 --> 00:33:27,889
of cavity that I mentioned earlier and

00:33:25,539 --> 00:33:32,799
that's all I wanted to say so if you

00:33:27,889 --> 00:33:32,799
have any questions please feel free

00:33:33,100 --> 00:33:42,619
[Applause]

00:33:45,029 --> 00:33:55,649
and I thank you for this talk yep I had

00:33:52,419 --> 00:33:59,350
some new big questions about rehashing

00:33:55,649 --> 00:34:03,239
you mention here that parallel hash has

00:33:59,350 --> 00:34:06,580
been standardized during the competition

00:34:03,239 --> 00:34:08,440
the Kshatriya competition I was

00:34:06,580 --> 00:34:11,290
wondering if there is another word

00:34:08,440 --> 00:34:14,799
coming up because I remember some draft

00:34:11,290 --> 00:34:18,159
and an estimating list about the

00:34:14,799 --> 00:34:20,079
specific triaging mode and when you go

00:34:18,159 --> 00:34:22,780
to the to the website to the Tkaczyk

00:34:20,079 --> 00:34:26,679
website there is a link with a paper

00:34:22,780 --> 00:34:29,679
describing the generic trashing and and

00:34:26,679 --> 00:34:33,280
that new hashing word that you may be

00:34:29,679 --> 00:34:40,000
building so I was wondering where where

00:34:33,280 --> 00:34:43,270
this is at and also where kangaroo 12

00:34:40,000 --> 00:34:45,790
which is new to me where distance does

00:34:43,270 --> 00:34:49,839
this hole is this also relevant to the

00:34:45,790 --> 00:34:53,409
tree opened with the parallel things so

00:34:49,839 --> 00:34:57,430
in the slide if you could for meetings

00:34:53,409 --> 00:35:00,010
okay so as far as I know only pahala -

00:34:57,430 --> 00:35:01,960
has been and has been standardized it's

00:35:00,010 --> 00:35:04,480
true that we've we've worked on triaging

00:35:01,960 --> 00:35:07,660
for quite some time and we proposed many

00:35:04,480 --> 00:35:09,099
different flavors of triaging what has

00:35:07,660 --> 00:35:10,990
been standardized is just a subset of

00:35:09,099 --> 00:35:11,819
that we'll of course you can do any kind

00:35:10,990 --> 00:35:14,859
of triaging

00:35:11,819 --> 00:35:17,980
if you use Sakuraba coding then you can

00:35:14,859 --> 00:35:20,470
it's easy because then you can devise

00:35:17,980 --> 00:35:22,480
any tree topology that you that you like

00:35:20,470 --> 00:35:23,980
that fits well with your application and

00:35:22,480 --> 00:35:27,700
then you're sure that the resulting

00:35:23,980 --> 00:35:29,829
function is secure about kangaroo 12 a

00:35:27,700 --> 00:35:32,440
design decision that we made is to have

00:35:29,829 --> 00:35:34,780
just one instance so can go 12 there is

00:35:32,440 --> 00:35:37,270
no parameterization the the tree

00:35:34,780 --> 00:35:39,190
topology is fixed so that there is no

00:35:37,270 --> 00:35:41,339
choice that it's easier for the user

00:35:39,190 --> 00:35:43,660
there is just one one-size-fits-all

00:35:41,339 --> 00:35:48,720
choice for kangaroo 20

00:35:43,660 --> 00:35:48,720
I know if it answers your questions

00:36:00,710 --> 00:36:07,260
how does it work with the lost bits so

00:36:04,830 --> 00:36:10,440
the every next iteration of the

00:36:07,260 --> 00:36:13,590
encryption the depends on the previous

00:36:10,440 --> 00:36:16,920
ones so this is like well hash algorithm

00:36:13,590 --> 00:36:19,260
but if some bits are lost I've I've seen

00:36:16,920 --> 00:36:21,330
this this forward secrecy or you can

00:36:19,260 --> 00:36:23,520
reseed it at any any moment in time

00:36:21,330 --> 00:36:29,370
but if some bits are lost of the

00:36:23,520 --> 00:36:32,550
ciphertext does it magically heal itself

00:36:29,370 --> 00:36:34,740
like to decrypt the text I'm not sure I

00:36:32,550 --> 00:36:40,410
understood the question okay is there

00:36:34,740 --> 00:36:43,260
any okay you have the ciphertext which

00:36:40,410 --> 00:36:45,480
which is like well yes I for text

00:36:43,260 --> 00:36:50,340
basically but if some bits being lost

00:36:45,480 --> 00:36:52,710
with the on the decryption well

00:36:50,340 --> 00:36:56,940
basically if some some parts of the

00:36:52,710 --> 00:36:58,800
ciphertext are lost and then then you

00:36:56,940 --> 00:37:01,950
get this synchronized and yeah you

00:36:58,800 --> 00:37:04,230
cannot recover okay now there are ways

00:37:01,950 --> 00:37:08,030
to to have some synchronous stream

00:37:04,230 --> 00:37:08,030
ciphers but that's not the case of

00:37:11,240 --> 00:37:18,260
I believe a AES encryption has been

00:37:15,190 --> 00:37:23,180
implemented in modern CPU architectures

00:37:18,260 --> 00:37:24,950
is the folding function of Kecak is it

00:37:23,180 --> 00:37:32,420
possible to implement that and is there

00:37:24,950 --> 00:37:33,770
any work in in in that regard so your

00:37:32,420 --> 00:37:37,900
question was about hardware

00:37:33,770 --> 00:37:41,119
implementations of a check yes okay so

00:37:37,900 --> 00:37:43,700
yeah I did I didn't mention this but of

00:37:41,119 --> 00:37:45,800
course a check was actually designed in

00:37:43,700 --> 00:37:49,640
a way that it can be extremely efficient

00:37:45,800 --> 00:37:53,720
in Hardware either for a given size of

00:37:49,640 --> 00:37:55,040
circuit it can be really fast or it can

00:37:53,720 --> 00:37:57,830
consume less energy

00:37:55,040 --> 00:38:01,190
well bit then well let's say than the

00:37:57,830 --> 00:38:04,240
other shut refinanced I don't know if it

00:38:01,190 --> 00:38:04,240
answers your question

00:38:07,950 --> 00:38:16,769
for instance with the Bitcoin - Asics

00:38:12,720 --> 00:38:19,369
for sha-2 have been built is it is the

00:38:16,769 --> 00:38:23,430
same thing possible with ketchup

00:38:19,369 --> 00:38:26,329
yeah I suppose I think yeah we didn't

00:38:23,430 --> 00:38:31,039
Taylor get check for Bitcoin like

00:38:26,329 --> 00:38:34,710
applications of course in this case if

00:38:31,039 --> 00:38:37,500
there will be a cost to do some mining

00:38:34,710 --> 00:38:39,930
and I suppose that economically the

00:38:37,500 --> 00:38:43,559
threshold will automatically raise where

00:38:39,930 --> 00:38:46,529
the the cost of electricity is at a

00:38:43,559 --> 00:38:48,750
given point is not economically

00:38:46,529 --> 00:38:54,750
interesting anymore so that I think even

00:38:48,750 --> 00:38:56,730
if a check is more efficient in our way

00:38:54,750 --> 00:38:58,769
for Bitcoin like applications it will

00:38:56,730 --> 00:39:00,440
not matter because the bar will be

00:38:58,769 --> 00:39:03,119
raised in at some point it becomes

00:39:00,440 --> 00:39:06,630
economically not interesting to do more

00:39:03,119 --> 00:39:13,980
- but I'm not really familiar with bit

00:39:06,630 --> 00:39:20,099
going to be honest other plans to

00:39:13,980 --> 00:39:23,880
include cataract with TLS I haven't

00:39:20,099 --> 00:39:28,950
followed TLS closely I think TLS still

00:39:23,880 --> 00:39:34,019
uses not shut - I don't know exactly why

00:39:28,950 --> 00:39:35,849
but I hope that someday they switch to -

00:39:34,019 --> 00:39:38,450
Kshatriya and not something designed by

00:39:35,849 --> 00:39:38,450
the NSA

00:40:03,810 --> 00:40:14,160
thank you very much

00:40:05,740 --> 00:40:14,160

YouTube URL: https://www.youtube.com/watch?v=wgR3VYHdd4Y


