Title: CloudABI Easily develop sandboxed apps for UNIX
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	by Ed Schouten

At: FOSDEM 2017

One of the fundamental problems with UNIX-like operating systems is that theydon't seem to make it easy and intuitive to develop applications that arestrongly hardened against exploits through sandboxing. With CloudABI, we'retrying to make this process a lot easier.

CloudABI is a blend of POSIX and pure capability-based security, which allowsyou to create applications that are only capable of accessing those thingsthat they are designed to use. As you'll see, software also becomes easier totest and deploy as a result of using this model.

In this presentation I am going to discuss a project I've been working on overthe last two years, called CloudABI. CloudABI is a simplified POSIX-likeruntime environment that is inspired by FreeBSD's Capsicum. It allows you tocreate programs that can solely interact with the environment through filedescriptors (capabilities). Compared to traditional UNIX-like systems, thisapproach has three advantages:

  1. It reduces the impact of exploits. If an attacker manages to take over control of a CloudABI application, it can only access those resources that the application was designed to use (for a networked service: typically an already bound TCP socket and some data directories). This is different from most traditional UNIX-like systems, where an attacker would gain access to all resources that the user running the application can access, which is very broad.

  2. It makes applications easier to test. By knowing that an application can only access those resources that are provided explicitly, the entire environment in which the application runs can be customized for testing.

  3. Similarly, it makes applications easier to deploy. This model tends to reduce the need for using containers and virtual machines. Applications can be started directly, while still providing the necessary isolation from the rest of the system.

In this talk I'm going to explain how CloudABI works in detail, while alsodiscussing some of its design decisions. I'll also show how you can designyour own CloudABI programs.

CloudABI is available for Linux, FreeBSD and Mac OS X. A NetBSD port alsoexists.


Room: Janson
Scheduled start: 2017-02-04 11:00:00
Captions: 
	00:00:05,220 --> 00:00:12,809
solo everyone next up we have ed Felten

00:00:09,670 --> 00:00:21,339
and he will be talking about cloud a B I

00:00:12,809 --> 00:00:24,910
enjoyed the talk so hi there

00:00:21,339 --> 00:00:26,560
good afternoon so my name is eskelta I'm

00:00:24,910 --> 00:00:28,269
an open source and flues yes from the

00:00:26,560 --> 00:00:30,579
Netherlands and today I'm going to talk

00:00:28,269 --> 00:00:32,740
about how I've been sort of spending my

00:00:30,579 --> 00:00:35,140
time for the last two two and a half

00:00:32,740 --> 00:00:37,059
years so first I'll give a sort of a

00:00:35,140 --> 00:00:39,309
short bio of Who I am

00:00:37,059 --> 00:00:43,210
I started using open source software

00:00:39,309 --> 00:00:44,680
back in 2003 that was a year I started

00:00:43,210 --> 00:00:47,820
studying and I ain't over and there was

00:00:44,680 --> 00:00:49,840
a UNIX users group at my university and

00:00:47,820 --> 00:00:51,879
at the UNIX user group was the only

00:00:49,840 --> 00:00:53,649
place where they had free Wi-Fi back

00:00:51,879 --> 00:00:55,030
then so that was sort of a reason for me

00:00:53,649 --> 00:00:57,670
to became a member of the UNIX users

00:00:55,030 --> 00:00:59,170
group but soon I discovered that the

00:00:57,670 --> 00:01:00,640
free Wi-Fi was and everything and I

00:00:59,170 --> 00:01:01,989
actually became interested in all of the

00:01:00,640 --> 00:01:04,570
hardware that they had them display over

00:01:01,989 --> 00:01:07,690
there so that sort of got me dragging to

00:01:04,570 --> 00:01:09,820
acting on open source software so what's

00:01:07,690 --> 00:01:11,230
actually pretty awesome is back in 2004

00:01:09,820 --> 00:01:14,530
so that was the first year of my studies

00:01:11,230 --> 00:01:17,440
I actually attended foster and I counted

00:01:14,530 --> 00:01:19,000
around a bit and I realized that this is

00:01:17,440 --> 00:01:22,000
the 12th time I'm actually attending

00:01:19,000 --> 00:01:23,890
Foss them so still the conference is all

00:01:22,000 --> 00:01:26,560
the same they still have the same steak

00:01:23,890 --> 00:01:29,350
breads as they had 12 years ago so yeah

00:01:26,560 --> 00:01:30,910
it's pretty nice conference so after

00:01:29,350 --> 00:01:34,390
hacking on open-source software for a

00:01:30,910 --> 00:01:36,940
couple of years I you started using

00:01:34,390 --> 00:01:39,550
FreeBSD as my primary operating system

00:01:36,940 --> 00:01:41,440
on my systems and I became really

00:01:39,550 --> 00:01:43,960
interested in how it worked under the

00:01:41,440 --> 00:01:46,680
hood you know theming all of the source

00:01:43,960 --> 00:01:49,810
code that was stored under user source

00:01:46,680 --> 00:01:51,940
together with a guy from my studies we

00:01:49,810 --> 00:01:54,370
actually even ported freebsd over to the

00:01:51,940 --> 00:01:58,090
Xbox one at one point in time which was

00:01:54,370 --> 00:02:00,430
a pretty fun project so in 2008 after

00:01:58,090 --> 00:02:01,990
sending in enough patches filling up the

00:02:00,430 --> 00:02:05,650
the bug tracker at the freebie is the

00:02:01,990 --> 00:02:10,479
often enough I was awarded with a SVM

00:02:05,650 --> 00:02:12,310
account back then or CVS even still one

00:02:10,479 --> 00:02:17,079
of the first PSD conferences I attendant

00:02:12,310 --> 00:02:18,260
was BSD can 2008 in camp in Canada and

00:02:17,079 --> 00:02:20,000
one of the speaker's back

00:02:18,260 --> 00:02:22,840
that the conference was Chris Latner and

00:02:20,000 --> 00:02:25,459
maybe you've heard that name in the news

00:02:22,840 --> 00:02:27,709
last week or two weeks ago he's actually

00:02:25,459 --> 00:02:30,890
one of the founders of the LVM project

00:02:27,709 --> 00:02:35,569
and nowadays he's some kind of compiler

00:02:30,890 --> 00:02:38,599
tech lead at Tesla I think and he gave a

00:02:35,569 --> 00:02:40,940
really good talk about LVM clang the C

00:02:38,599 --> 00:02:42,680
C++ compiler so it had really got me

00:02:40,940 --> 00:02:44,959
motivated on you know taking a look at

00:02:42,680 --> 00:02:46,579
that compiler as well so one of the

00:02:44,959 --> 00:02:48,709
larger things I've been working on back

00:02:46,579 --> 00:02:50,390
then was sort of integrating LVM clang

00:02:48,709 --> 00:02:52,760
into the freebies the operating system

00:02:50,390 --> 00:02:56,650
which is sort of the de facto standard

00:02:52,760 --> 00:02:59,329
compiler today at least in FreeBSD so

00:02:56,650 --> 00:03:01,010
enough about FreeBSD and LVM I'm not

00:02:59,329 --> 00:03:02,870
really going to talk a lot about those

00:03:01,010 --> 00:03:05,180
projects today I'm actually going to

00:03:02,870 --> 00:03:08,209
talk about what I what I've been up to

00:03:05,180 --> 00:03:10,510
since 2014 and this talk is sort of a

00:03:08,209 --> 00:03:12,739
bit like chronologically structured so

00:03:10,510 --> 00:03:17,030
the first thing we're going to look at

00:03:12,739 --> 00:03:20,150
is what if I be doing in 2014 so back in

00:03:17,030 --> 00:03:23,120
2014 I was working as an expat in

00:03:20,150 --> 00:03:26,180
Germany I had some time to kill in the

00:03:23,120 --> 00:03:28,669
evenings so what I started doing was I

00:03:26,180 --> 00:03:30,410
was sort of created to get repo in my

00:03:28,669 --> 00:03:33,680
home directory and started hacking on

00:03:30,410 --> 00:03:37,190
some C++ code I started working on a

00:03:33,680 --> 00:03:40,010
database server written in C++ and this

00:03:37,190 --> 00:03:41,329
database server was sort of making use

00:03:40,010 --> 00:03:43,879
of a whole bunch of things I've never

00:03:41,329 --> 00:03:45,739
used before so I was experimenting with

00:03:43,879 --> 00:03:47,870
with data structures like miracle trees

00:03:45,739 --> 00:03:51,290
for making sure that all of the data was

00:03:47,870 --> 00:03:52,970
consistent stored inside of it what was

00:03:51,290 --> 00:03:54,949
really interesting about this data

00:03:52,970 --> 00:03:56,750
database server that I was designing was

00:03:54,949 --> 00:03:58,790
said I wasn't using like sequel queries

00:03:56,750 --> 00:04:01,579
or something to you know get access to

00:03:58,790 --> 00:04:03,829
the data but I was actually loading a

00:04:01,579 --> 00:04:06,169
full BART VM in there so dart is the

00:04:03,829 --> 00:04:07,940
scripting language that that is being

00:04:06,169 --> 00:04:09,829
designed by Google sort of a JavaScript

00:04:07,940 --> 00:04:11,780
replacement and I thought that would be

00:04:09,829 --> 00:04:13,129
pretty awesome to actually design stored

00:04:11,780 --> 00:04:16,280
procedures in like a high-level

00:04:13,129 --> 00:04:18,049
programming language like dart for

00:04:16,280 --> 00:04:19,699
replicating transactions across the

00:04:18,049 --> 00:04:22,190
network I was using something similar to

00:04:19,699 --> 00:04:23,900
Beck sauce called raft but the problem

00:04:22,190 --> 00:04:26,450
with this project is I was only working

00:04:23,900 --> 00:04:29,150
on this a couple of evenings evenings a

00:04:26,450 --> 00:04:31,370
night the other evenings of the week I

00:04:29,150 --> 00:04:33,199
usually went over to pubs together

00:04:31,370 --> 00:04:35,389
if some people sitting here in the

00:04:33,199 --> 00:04:36,800
audience even so that project didn't

00:04:35,389 --> 00:04:38,720
actually make a lot of progress in the

00:04:36,800 --> 00:04:41,030
end it was just a forgotten get repo

00:04:38,720 --> 00:04:42,470
that sort of stayed in my home directory

00:04:41,030 --> 00:04:44,240
and it might even be the case that I

00:04:42,470 --> 00:04:46,790
reinstalled my laptop so that the code

00:04:44,240 --> 00:04:48,199
is now gone but it was a really good

00:04:46,790 --> 00:04:51,050
excuse for me to experiment with all

00:04:48,199 --> 00:04:53,360
sorts of new technology that I hadn't

00:04:51,050 --> 00:04:55,190
used before so just to sort of give you

00:04:53,360 --> 00:04:56,600
short overview of how it worked you had

00:04:55,190 --> 00:04:59,060
a couple of servers that were sort of

00:04:56,600 --> 00:05:00,889
connected with each other in like in a

00:04:59,060 --> 00:05:02,270
mesh and they would just replicate all

00:05:00,889 --> 00:05:04,160
the transactions over that would be

00:05:02,270 --> 00:05:06,169
coming in and then on the outside you'd

00:05:04,160 --> 00:05:08,240
you'd have sort of a swarm of clients

00:05:06,169 --> 00:05:10,280
and maybe even some caching nodes that

00:05:08,240 --> 00:05:11,660
would hold on to certain parts of the

00:05:10,280 --> 00:05:16,220
tree and would make sure that that would

00:05:11,660 --> 00:05:17,660
all sort of get replicated so one of the

00:05:16,220 --> 00:05:19,460
things I was experimenting with first

00:05:17,660 --> 00:05:22,310
this database server was I wanted to

00:05:19,460 --> 00:05:24,169
harden it so the problem is you're

00:05:22,310 --> 00:05:25,610
running arbitrary dart code in a virtual

00:05:24,169 --> 00:05:27,820
machine what could possibly go wrong

00:05:25,610 --> 00:05:30,380
you know it's user-supplied dart code

00:05:27,820 --> 00:05:32,240
what if this dart code simply contains

00:05:30,380 --> 00:05:33,860
statements in there that simply say like

00:05:32,240 --> 00:05:38,419
you know open these arbitrary files on

00:05:33,860 --> 00:05:40,099
disk remove slash EDC / password etc so

00:05:38,419 --> 00:05:41,750
I wanted to make use of sandboxing to

00:05:40,099 --> 00:05:43,910
actually make sure that if even if there

00:05:41,750 --> 00:05:45,380
would be an exploit in the dart VM there

00:05:43,910 --> 00:05:48,820
would be no way of breaking out of the

00:05:45,380 --> 00:05:48,820
VM and running arbitrary code

00:05:50,300 --> 00:05:55,619
the usage access pattern is quite simple

00:05:53,069 --> 00:05:57,089
it either accesses its data set that the

00:05:55,619 --> 00:06:00,059
stored is some kind of directory on disk

00:05:57,089 --> 00:06:02,580
it talks to the other servers in the in

00:06:00,059 --> 00:06:04,949
the raft consensus group so like the

00:06:02,580 --> 00:06:06,389
inner mesh and then you'd have TCP

00:06:04,949 --> 00:06:08,839
connections coming in from clients on

00:06:06,389 --> 00:06:13,619
sort of the outside of the network so

00:06:08,839 --> 00:06:16,740
what I did back then was I sort of got

00:06:13,619 --> 00:06:19,050
distracted and instead of focusing on

00:06:16,740 --> 00:06:21,180
like getting the database server working

00:06:19,050 --> 00:06:22,889
I ended up focusing only on the

00:06:21,180 --> 00:06:24,119
sandboxing and getting that right which

00:06:22,889 --> 00:06:26,479
meant that in the end I didn't have a

00:06:24,119 --> 00:06:30,270
functional database server sort of

00:06:26,479 --> 00:06:31,830
completely stupid idea so I sort of

00:06:30,270 --> 00:06:33,419
started making an inventory of all the

00:06:31,830 --> 00:06:38,639
security frameworks that are out there

00:06:33,419 --> 00:06:40,919
and I sort of came up with this this

00:06:38,639 --> 00:06:42,479
slide is sort of my observation of like

00:06:40,919 --> 00:06:45,300
the current state of security frameworks

00:06:42,479 --> 00:06:46,860
I'm by no means an expert on them but

00:06:45,300 --> 00:06:52,199
this is sort of my interpretation of

00:06:46,860 --> 00:06:54,180
them so at the at like the top they can

00:06:52,199 --> 00:06:57,240
be sort of divided in two separate

00:06:54,180 --> 00:06:59,189
groups once that I sort of call static

00:06:57,240 --> 00:07:01,830
policy like and other ones that I called

00:06:59,189 --> 00:07:03,419
dynamic capability like and I completely

00:07:01,830 --> 00:07:05,009
have it like a completely different

00:07:03,419 --> 00:07:08,669
mindset of attacking the problem of

00:07:05,009 --> 00:07:10,019
hardening software so this static policy

00:07:08,669 --> 00:07:12,089
like frameworks they're sort of built

00:07:10,019 --> 00:07:14,580
from this mindset saying like the

00:07:12,089 --> 00:07:17,039
problem with unique security is in its

00:07:14,580 --> 00:07:19,889
security model namely in the way file

00:07:17,039 --> 00:07:21,990
system permissions work so we need to

00:07:19,889 --> 00:07:23,759
extend on that file system permissions

00:07:21,990 --> 00:07:26,159
need to be more complex there need to be

00:07:23,759 --> 00:07:29,309
more access control lists or more

00:07:26,159 --> 00:07:31,439
frameworks provided by the kernel and

00:07:29,309 --> 00:07:34,050
good examples of those frameworks are a

00:07:31,439 --> 00:07:36,599
Parmer and selinux and something that

00:07:34,050 --> 00:07:38,249
they call POSIX capabilities even though

00:07:36,599 --> 00:07:43,349
that system has nothing to do with

00:07:38,249 --> 00:07:45,059
capability based security and those

00:07:43,349 --> 00:07:48,389
systems they're typically configured by

00:07:45,059 --> 00:07:50,490
administrators users in some cases even

00:07:48,389 --> 00:07:52,889
package maintainer zuv operating systems

00:07:50,490 --> 00:07:56,249
so app armour security policies they're

00:07:52,889 --> 00:07:58,409
typically written by by by distro

00:07:56,249 --> 00:08:00,749
package maintainer state they build what

00:07:58,409 --> 00:08:02,399
they do is they sort of run the program

00:08:00,749 --> 00:08:03,060
that they want have harden for a certain

00:08:02,399 --> 00:08:06,060
period of

00:08:03,060 --> 00:08:09,000
and they said analyze it for say a

00:08:06,060 --> 00:08:10,500
couple of hours a couple of days and the

00:08:09,000 --> 00:08:12,180
output of that analysis is sort of

00:08:10,500 --> 00:08:15,270
turned into a security policy that's put

00:08:12,180 --> 00:08:16,770
in place so what happens if if there's

00:08:15,270 --> 00:08:19,500
some kind of exploit in it and then that

00:08:16,770 --> 00:08:21,810
attacker takes over the application that

00:08:19,500 --> 00:08:23,460
person can only run the actions that a

00:08:21,810 --> 00:08:26,390
part of the security policy that was

00:08:23,460 --> 00:08:29,160
generated during the training phase so

00:08:26,390 --> 00:08:30,840
what what i've observed is that those

00:08:29,160 --> 00:08:32,550
security frameworks they typically only

00:08:30,840 --> 00:08:35,190
provide like very little gain in

00:08:32,550 --> 00:08:37,620
security so the best examples I can give

00:08:35,190 --> 00:08:40,080
you for example a web browser has a foul

00:08:37,620 --> 00:08:42,510
open file save dialog you know whenever

00:08:40,080 --> 00:08:44,670
you've done download a file press ctrl s

00:08:42,510 --> 00:08:46,980
you get this pop-up box where you can

00:08:44,670 --> 00:08:48,390
browse the entire file system well that

00:08:46,980 --> 00:08:49,770
sort of automatically means that this

00:08:48,390 --> 00:08:51,450
browser needs to be able to access the

00:08:49,770 --> 00:08:53,580
entire file system of your of your

00:08:51,450 --> 00:08:56,520
system so it basically makes it pretty

00:08:53,580 --> 00:08:58,200
much useless also what I think what I

00:08:56,520 --> 00:09:00,060
really dislike about the system is that

00:08:58,200 --> 00:09:02,940
it's configured by users and

00:09:00,060 --> 00:09:04,440
administrators people who have no sort

00:09:02,940 --> 00:09:06,390
of real deep understanding of how the

00:09:04,440 --> 00:09:08,040
software works internally and we sort of

00:09:06,390 --> 00:09:09,780
expect those people to come up with

00:09:08,040 --> 00:09:11,730
security policies to make the software

00:09:09,780 --> 00:09:13,260
secure like the software developer

00:09:11,730 --> 00:09:15,270
doesn't even care about it sort of

00:09:13,260 --> 00:09:17,010
throws Dakota over the fence and then

00:09:15,270 --> 00:09:19,680
other people have to clean up afterwards

00:09:17,010 --> 00:09:21,030
and make it more secure so what you also

00:09:19,680 --> 00:09:23,280
see if the last couple years said it's

00:09:21,030 --> 00:09:25,350
that all these new security models they

00:09:23,280 --> 00:09:27,480
sort of tend to pop up and those are

00:09:25,350 --> 00:09:29,520
more dynamic capability like so how it

00:09:27,480 --> 00:09:31,590
works is that it's not a policy that

00:09:29,520 --> 00:09:34,200
sort of installed globally or in the

00:09:31,590 --> 00:09:36,390
system and CDC but it's sort of part of

00:09:34,200 --> 00:09:38,940
the programming API sware sort of the

00:09:36,390 --> 00:09:40,380
program can say like I've acquired all

00:09:38,940 --> 00:09:42,360
the things that I need to access I've

00:09:40,380 --> 00:09:44,580
got my network connections I can access

00:09:42,360 --> 00:09:46,710
these parts on disk now lock me up and

00:09:44,580 --> 00:09:49,020
throw away the keys that's sort of how

00:09:46,710 --> 00:09:51,720
the security model works and Linux has a

00:09:49,020 --> 00:09:53,940
second model I think the most commonly

00:09:51,720 --> 00:09:57,170
used flavor of seccomp is ii BPF where

00:09:53,940 --> 00:09:57,170
they have some kind of

00:10:00,549 --> 00:10:07,429
OpenBSD pledge and these tend to have

00:10:05,839 --> 00:10:08,899
like a really big gain in security as

00:10:07,429 --> 00:10:11,289
you'll see in a couple of minutes so a

00:10:08,899 --> 00:10:14,089
lot of people ask me whenever I sort of

00:10:11,289 --> 00:10:17,679
talk about these this topic is where

00:10:14,089 --> 00:10:20,509
does docker fit in in this picture and

00:10:17,679 --> 00:10:21,979
it's sort of a really tough question but

00:10:20,509 --> 00:10:24,049
if you sort of look at how doctors use

00:10:21,979 --> 00:10:26,689
typically I'd say it's more like a

00:10:24,049 --> 00:10:28,819
static system you know it's set up by

00:10:26,689 --> 00:10:31,339
the users to run a program in a confined

00:10:28,819 --> 00:10:35,269
space it's not used as sort of an API by

00:10:31,339 --> 00:10:37,129
programs itself so now we're sort of

00:10:35,269 --> 00:10:39,859
going to discuss how capsicum works and

00:10:37,129 --> 00:10:42,919
basically capsicum is a sort of two-step

00:10:39,859 --> 00:10:46,159
recipe for making making software more

00:10:42,919 --> 00:10:47,989
secure so the first thing that that the

00:10:46,159 --> 00:10:50,209
capsicum developers have sort of done is

00:10:47,989 --> 00:10:52,249
they've made the operating system sort

00:10:50,209 --> 00:10:52,909
of more object oriented you could call

00:10:52,249 --> 00:10:57,829
it like that

00:10:52,909 --> 00:10:59,719
so what I've done is I've sort of made

00:10:57,829 --> 00:11:03,259
turn everything into a file descriptor

00:10:59,719 --> 00:11:04,969
so normally for there are sort of

00:11:03,259 --> 00:11:06,829
multiple namespaces that the process can

00:11:04,969 --> 00:11:07,909
access it has its file descriptors it

00:11:06,829 --> 00:11:10,189
can access the entire file system

00:11:07,909 --> 00:11:12,439
namespace then there's the process table

00:11:10,189 --> 00:11:14,089
then there's the network stack all sorts

00:11:12,439 --> 00:11:16,099
of separate frameworks but what I first

00:11:14,089 --> 00:11:19,819
did is I sort of tried to unify it into

00:11:16,099 --> 00:11:22,519
signal like scope follow scripters in

00:11:19,819 --> 00:11:24,169
this case so one thing that I've sort of

00:11:22,519 --> 00:11:26,059
really focused on a lot is having

00:11:24,169 --> 00:11:28,009
directory file descriptor support so

00:11:26,059 --> 00:11:30,169
that you can open a certain directory

00:11:28,009 --> 00:11:32,389
that's on disk and then sort of say like

00:11:30,169 --> 00:11:34,039
this file descriptor now represents all

00:11:32,389 --> 00:11:38,059
the files that are stored underneath

00:11:34,039 --> 00:11:40,039
this directory so you can point to sub

00:11:38,059 --> 00:11:41,209
trees in the filesystem basically and

00:11:40,039 --> 00:11:42,799
what I've also done is I've added

00:11:41,209 --> 00:11:45,199
something called process descriptors

00:11:42,799 --> 00:11:47,089
where instead of process IDs that are

00:11:45,199 --> 00:11:49,459
sort of global system-wide and you can

00:11:47,089 --> 00:11:52,909
see send signals to them based on some

00:11:49,459 --> 00:11:54,679
very rudimentary mentary form of access

00:11:52,909 --> 00:11:56,599
controls they've changed that into

00:11:54,679 --> 00:11:58,159
process descriptors so as you'll see

00:11:56,599 --> 00:12:01,039
later on they're sort of a special for

00:11:58,159 --> 00:12:04,959
call PD fork and that sort of gives you

00:12:01,039 --> 00:12:04,959
a follow skipper to a child process and

00:12:10,390 --> 00:12:15,040
if you can't read or write over it but

00:12:12,190 --> 00:12:16,720
it sort of acts as a handle giving you

00:12:15,040 --> 00:12:20,050
ownership of that process on the other

00:12:16,720 --> 00:12:22,570
side and if you close it you sort of

00:12:20,050 --> 00:12:23,950
lose that process and in practice that

00:12:22,570 --> 00:12:26,890
means that that process gets killed and

00:12:23,950 --> 00:12:28,269
shut down so the second step that

00:12:26,890 --> 00:12:29,980
they've sort of done with capsicum is

00:12:28,269 --> 00:12:32,260
sort of now that the operating system is

00:12:29,980 --> 00:12:34,390
more object oriented let's actually let

00:12:32,260 --> 00:12:37,390
those objects determine what the process

00:12:34,390 --> 00:12:40,450
can do so a process can actually give up

00:12:37,390 --> 00:12:41,740
rights it can say I never need to access

00:12:40,450 --> 00:12:43,329
this certain resource anymore

00:12:41,740 --> 00:12:46,540
by simply calling closed on the file

00:12:43,329 --> 00:12:48,490
descriptor and it's gone privilege

00:12:46,540 --> 00:12:50,050
separation so say if you have this huge

00:12:48,490 --> 00:12:51,820
program and you want to divide it into

00:12:50,050 --> 00:12:53,470
multiple sub processes that all have

00:12:51,820 --> 00:12:55,149
their sort of separate rights

00:12:53,470 --> 00:12:56,380
that's called privilege separation

00:12:55,149 --> 00:12:57,850
that's something that you can really

00:12:56,380 --> 00:12:59,769
easily implement by this model

00:12:57,850 --> 00:13:02,800
you can simply fork the process into two

00:12:59,769 --> 00:13:03,760
processes one process closes 1/2 foot to

00:13:02,800 --> 00:13:05,440
follow Scripture and the other one

00:13:03,760 --> 00:13:07,720
closed the other half and then you've

00:13:05,440 --> 00:13:11,290
really separated the privileges of the

00:13:07,720 --> 00:13:13,570
process another very nifty feature of

00:13:11,290 --> 00:13:15,399
UNIX based operating systems that a lot

00:13:13,570 --> 00:13:17,680
of people are unaware of is that you can

00:13:15,399 --> 00:13:20,949
actually pass file descriptors to other

00:13:17,680 --> 00:13:22,810
processes so if you create a UNIX socket

00:13:20,949 --> 00:13:26,769
between two processes you can use a

00:13:22,810 --> 00:13:28,540
special message type called SCM writes

00:13:26,769 --> 00:13:30,370
where you basically say I've got this

00:13:28,540 --> 00:13:32,019
array of file descriptors now push it

00:13:30,370 --> 00:13:34,930
through the socket and pop it up on the

00:13:32,019 --> 00:13:37,660
other side and if the other side

00:13:34,930 --> 00:13:38,949
receives those file descriptors it sort

00:13:37,660 --> 00:13:40,690
of duplicates them into different

00:13:38,949 --> 00:13:42,370
process so that's also a really nifty

00:13:40,690 --> 00:13:44,140
trick where you can sort of say like

00:13:42,370 --> 00:13:45,579
I've got access to this directory and

00:13:44,140 --> 00:13:47,560
now I need this this other running

00:13:45,579 --> 00:13:48,970
process to write some stuff into it well

00:13:47,560 --> 00:13:51,940
just push it through a socket and it

00:13:48,970 --> 00:13:53,740
comes out on the other side and what you

00:13:51,940 --> 00:13:55,899
see is a result of this models that UNIX

00:13:53,740 --> 00:13:57,970
user group credentials they become less

00:13:55,899 --> 00:14:00,130
important so if you're using capsicum

00:13:57,970 --> 00:14:02,019
even if you run a process as root it

00:14:00,130 --> 00:14:04,630
doesn't really matter anymore because

00:14:02,019 --> 00:14:06,550
the the rights that that process has are

00:14:04,630 --> 00:14:09,339
largely now determined by the set of

00:14:06,550 --> 00:14:11,370
file descriptors that it owns so how

00:14:09,339 --> 00:14:13,990
does capsicum work in practice

00:14:11,370 --> 00:14:17,620
first of all process starts up like your

00:14:13,990 --> 00:14:19,390
ordinary uniques process you can just

00:14:17,620 --> 00:14:22,580
run it from them from a command line or

00:14:19,390 --> 00:14:25,100
from like an init script

00:14:22,580 --> 00:14:26,930
at some point in time the process calls

00:14:25,100 --> 00:14:29,000
the cap enter system call and that sort

00:14:26,930 --> 00:14:30,260
of locks up the process it switches the

00:14:29,000 --> 00:14:33,560
process over into something called

00:14:30,260 --> 00:14:35,270
capabilities mode and when you do that a

00:14:33,560 --> 00:14:37,580
lot of things are suddenly forbidden so

00:14:35,270 --> 00:14:39,950
you can no longer or open files by

00:14:37,580 --> 00:14:42,230
arbitrary file names you can no longer

00:14:39,950 --> 00:14:44,150
bind to arbitrary IP addresses and port

00:14:42,230 --> 00:14:46,040
numbers you can no longer connect to

00:14:44,150 --> 00:14:48,170
arbitrary hosts from the network also

00:14:46,040 --> 00:14:49,400
regular forking is not supported because

00:14:48,170 --> 00:14:51,710
that needs to be done through the PD

00:14:49,400 --> 00:14:53,210
fork all the same of killing processes

00:14:51,710 --> 00:14:55,430
you can't just send arbitrary signals to

00:14:53,210 --> 00:14:56,810
processes in the process table and the

00:14:55,430 --> 00:14:58,490
same holds for some administrative

00:14:56,810 --> 00:15:00,110
system calls so rebooting a mounting

00:14:58,490 --> 00:15:02,270
doesn't make any sense of course if

00:15:00,110 --> 00:15:03,350
you're in this unprivileged mode but

00:15:02,270 --> 00:15:05,360
there's a whole bunch of things that you

00:15:03,350 --> 00:15:06,830
can still use so reading on file

00:15:05,360 --> 00:15:08,870
descriptors writing or file descriptors

00:15:06,830 --> 00:15:10,070
creating pipes and socket pairs those

00:15:08,870 --> 00:15:12,320
are only things that sort of have this

00:15:10,070 --> 00:15:14,390
local impact doesn't have a global

00:15:12,320 --> 00:15:16,160
impact on the system then you can still

00:15:14,390 --> 00:15:18,800
use the open app system call which was

00:15:16,160 --> 00:15:20,870
added in POSIX 2008 which is sort of a

00:15:18,800 --> 00:15:22,730
special flavor of the normal open system

00:15:20,870 --> 00:15:26,780
call but allows you to open files

00:15:22,730 --> 00:15:28,220
underneath a certain directory and same

00:15:26,780 --> 00:15:30,020
holds for connecting and binding to

00:15:28,220 --> 00:15:31,790
sockets I've made special system calls

00:15:30,020 --> 00:15:33,530
where you can at least say like I want

00:15:31,790 --> 00:15:37,550
to bind a UNIX socket to a certain path

00:15:33,530 --> 00:15:39,470
under a certain directory a very

00:15:37,550 --> 00:15:40,910
important aspect of capabilities mode of

00:15:39,470 --> 00:15:43,070
course is that there's no way of leaving

00:15:40,910 --> 00:15:44,810
capabilities Motors no cap leave system

00:15:43,070 --> 00:15:46,250
call otherwise the entire security model

00:15:44,810 --> 00:15:48,100
would be useless of course because an

00:15:46,250 --> 00:15:50,480
attacker could take an open application

00:15:48,100 --> 00:15:53,240
called cap leave and then it could just

00:15:50,480 --> 00:15:56,510
go on as it normally does so that's a

00:15:53,240 --> 00:15:59,510
really important aspect so for my

00:15:56,510 --> 00:16:01,730
database server how you use capsicum in

00:15:59,510 --> 00:16:03,560
this case is it's you know again the

00:16:01,730 --> 00:16:05,960
same strategy the process starts up like

00:16:03,560 --> 00:16:07,760
a regular UNIX process it reads it reads

00:16:05,960 --> 00:16:09,740
in its configuration file and in the

00:16:07,760 --> 00:16:11,870
configuration file it specifies which

00:16:09,740 --> 00:16:13,580
directories need to be used in which IP

00:16:11,870 --> 00:16:15,680
addresses on which we need to listen so

00:16:13,580 --> 00:16:17,120
we create all these sockets and file

00:16:15,680 --> 00:16:19,760
descriptors and then at some point we

00:16:17,120 --> 00:16:21,890
call cap enter and voila from that point

00:16:19,760 --> 00:16:22,970
on we can only start processing requests

00:16:21,890 --> 00:16:27,880
that are coming in and we can't do

00:16:22,970 --> 00:16:27,880
anything else so

00:16:29,030 --> 00:16:35,640
for my database server I started using

00:16:31,320 --> 00:16:37,080
capsicum and even though in in theory it

00:16:35,640 --> 00:16:39,090
sounds like a pretty awesome security

00:16:37,080 --> 00:16:40,260
framework that gives you some really

00:16:39,090 --> 00:16:42,570
tight isolation

00:16:40,260 --> 00:16:45,300
I noticed that using it in practice can

00:16:42,570 --> 00:16:46,800
be pretty tricky so it took me quite a

00:16:45,300 --> 00:16:49,760
long time before I managed to get the

00:16:46,800 --> 00:16:53,400
dart VM working within capsicum that was

00:16:49,760 --> 00:16:54,630
really exciting so the reason for this

00:16:53,400 --> 00:16:56,550
is that you end up with all these pieces

00:16:54,630 --> 00:16:58,290
of code that are your this slide and

00:16:56,550 --> 00:17:00,720
they're used in practice and there's

00:16:58,290 --> 00:17:02,820
they're simply there and you'll sort of

00:17:00,720 --> 00:17:04,949
have to deal with that so the top one

00:17:02,820 --> 00:17:06,510
was somewhere in the dart VM I think

00:17:04,949 --> 00:17:08,220
they had some some code in there where

00:17:06,510 --> 00:17:12,120
you could deal with times in different

00:17:08,220 --> 00:17:14,130
time zones and if you sort of look up

00:17:12,120 --> 00:17:17,339
and see how you convert times to a

00:17:14,130 --> 00:17:18,930
certain time in a time zone you have to

00:17:17,339 --> 00:17:20,939
use the following sequence so first you

00:17:18,930 --> 00:17:23,579
change an environment variable called TZ

00:17:20,939 --> 00:17:25,800
you said it - the name of the time zone

00:17:23,579 --> 00:17:27,120
you want to use and then what you do is

00:17:25,800 --> 00:17:29,310
you call this magic function called TZ

00:17:27,120 --> 00:17:30,750
at set and it sort of reinitialize is

00:17:29,310 --> 00:17:32,730
the sea library to use a different time

00:17:30,750 --> 00:17:35,370
zone and then afterwards you can call

00:17:32,730 --> 00:17:37,080
the local time function so under the

00:17:35,370 --> 00:17:39,120
hood what happens the T jet-set function

00:17:37,080 --> 00:17:41,130
tries to open files under user share

00:17:39,120 --> 00:17:43,230
zone info but if you're calling cap

00:17:41,130 --> 00:17:45,210
enter then that kind of code no longer

00:17:43,230 --> 00:17:46,770
works and what's really annoying is that

00:17:45,210 --> 00:17:49,320
bursty jet-set you can't do any error

00:17:46,770 --> 00:17:51,090
handling so this piece of code it still

00:17:49,320 --> 00:17:53,150
works as it does normally the only

00:17:51,090 --> 00:17:55,410
difference is that it still either

00:17:53,150 --> 00:17:57,000
represents the time in the old time zone

00:17:55,410 --> 00:18:00,210
that was sort of active before calling

00:17:57,000 --> 00:18:02,010
T's at set or it uses UTC or something

00:18:00,210 --> 00:18:04,650
weird you can't really tell anymore what

00:18:02,010 --> 00:18:05,970
it does and also this piece of code that

00:18:04,650 --> 00:18:07,260
was at the bottom was also fairly

00:18:05,970 --> 00:18:09,000
annoying

00:18:07,260 --> 00:18:11,430
there is a piece of code that tried to

00:18:09,000 --> 00:18:13,410
convert a multi byte string to a white

00:18:11,430 --> 00:18:15,540
character string so what does it what it

00:18:13,410 --> 00:18:17,520
means sort of in layman's terms it took

00:18:15,540 --> 00:18:19,080
a utf-8 string and it converts it over

00:18:17,520 --> 00:18:20,850
to Unicode code points so you can

00:18:19,080 --> 00:18:23,460
process it character by character and

00:18:20,850 --> 00:18:25,970
call it uses this new locale function

00:18:23,460 --> 00:18:28,680
that sort of creates a handle to a

00:18:25,970 --> 00:18:32,190
localization object and in this case

00:18:28,680 --> 00:18:34,110
it's representing utf-8 the problem of

00:18:32,190 --> 00:18:38,940
this function is that it tries to open

00:18:34,110 --> 00:18:40,620
user share locale utf-8 slash LCC type

00:18:38,940 --> 00:18:42,720
or some file on disk and

00:18:40,620 --> 00:18:44,520
come come can no longer access it so

00:18:42,720 --> 00:18:46,860
this piece of coats of expects that it

00:18:44,520 --> 00:18:48,480
can same he convert utf-8 over to

00:18:46,860 --> 00:18:50,940
Unicode but then it sort of starts to

00:18:48,480 --> 00:18:54,120
fail and this piece of code is actually

00:18:50,940 --> 00:18:55,530
sort of the the most interesting one I

00:18:54,120 --> 00:18:56,910
ran into and this sort of really

00:18:55,530 --> 00:18:59,280
demonstrates one of the weaknesses of

00:18:56,910 --> 00:19:00,990
capsicum this is a crypto library you

00:18:59,280 --> 00:19:03,150
can find any internet live Tom Krebs you

00:19:00,990 --> 00:19:04,830
can find it on github which is the name

00:19:03,150 --> 00:19:06,960
of the source file in there I've

00:19:04,830 --> 00:19:08,280
reported this issue numerous times to

00:19:06,960 --> 00:19:10,380
the upstream offer but he doesn't

00:19:08,280 --> 00:19:12,720
respond what happens this piece of code

00:19:10,380 --> 00:19:15,630
tries to implement a cryptographically

00:19:12,720 --> 00:19:17,220
secure random number generator so it

00:19:15,630 --> 00:19:19,380
tries to open that few random and twice

00:19:17,220 --> 00:19:21,240
to read some data from it eventually but

00:19:19,380 --> 00:19:22,710
that simply no longer works so what do

00:19:21,240 --> 00:19:24,990
we do when we can't opened a few random

00:19:22,710 --> 00:19:27,030
well yeah then we just call the clock

00:19:24,990 --> 00:19:29,250
function to get like the the running

00:19:27,030 --> 00:19:30,990
time of the current process and that

00:19:29,250 --> 00:19:33,090
should be used as like the initial seed

00:19:30,990 --> 00:19:36,150
for all of the random number computation

00:19:33,090 --> 00:19:37,890
so we try to make our application more

00:19:36,150 --> 00:19:41,880
secure but by calling cap enter we

00:19:37,890 --> 00:19:43,380
actually made alot less secure so what I

00:19:41,880 --> 00:19:46,320
learnt in 2013

00:19:43,380 --> 00:19:48,809
well sandboxing is stupid and you

00:19:46,320 --> 00:19:51,780
shouldn't use it that's sort of why my

00:19:48,809 --> 00:19:54,030
takeaway from it it's no fun at all you

00:19:51,780 --> 00:19:56,160
spend a lot of time figuring out why

00:19:54,030 --> 00:19:57,960
your program doesn't work you run into

00:19:56,160 --> 00:19:59,640
these issues that you can actually only

00:19:57,960 --> 00:20:01,380
discover by tracing the application

00:19:59,640 --> 00:20:03,300
system call by system call and figuring

00:20:01,380 --> 00:20:05,250
out what's going wrong there's no

00:20:03,300 --> 00:20:07,050
tooling that actually helps you along

00:20:05,250 --> 00:20:12,210
the way you know you're you're on your

00:20:07,050 --> 00:20:14,100
own and yeah even if you get it working

00:20:12,210 --> 00:20:15,510
in the end you still can't be certain

00:20:14,100 --> 00:20:19,590
that it actually works in the way you've

00:20:15,510 --> 00:20:21,150
sort of expected so I want to sort of

00:20:19,590 --> 00:20:23,460
close off this part of my talk by

00:20:21,150 --> 00:20:25,830
putting this slide in there if you are

00:20:23,460 --> 00:20:28,980
considering using sandboxing frameworks

00:20:25,830 --> 00:20:31,890
only mimics STR right now or on any UNIX

00:20:28,980 --> 00:20:33,809
flavor then please please please don't

00:20:31,890 --> 00:20:35,940
use it within any code that makes use of

00:20:33,809 --> 00:20:37,620
third-party libraries because you

00:20:35,940 --> 00:20:39,390
actually can't be certain what those

00:20:37,620 --> 00:20:41,309
libraries are doing on the inside and

00:20:39,390 --> 00:20:43,679
the code in those libraries might

00:20:41,309 --> 00:20:46,440
actually be changing over time upstream

00:20:43,679 --> 00:20:48,000
might actually reimplementation a number

00:20:46,440 --> 00:20:50,730
generator by something that was shown on

00:20:48,000 --> 00:20:52,710
one of the previous slides and your

00:20:50,730 --> 00:20:54,370
users will simply install the

00:20:52,710 --> 00:20:55,480
application install of the dependence

00:20:54,370 --> 00:20:57,490
and they might actually end up with

00:20:55,480 --> 00:20:59,650
something that's insecure so this is the

00:20:57,490 --> 00:21:03,130
reason why sandbox in frameworks work

00:20:59,650 --> 00:21:05,230
well for Google Chrome browser tabs they

00:21:03,130 --> 00:21:08,740
make use of ii and a reason for that is

00:21:05,230 --> 00:21:10,450
they only run c c++ code in there that

00:21:08,740 --> 00:21:12,460
they've written themselves or maintained

00:21:10,450 --> 00:21:15,780
themselves or have part of their own

00:21:12,460 --> 00:21:18,130
distribution that also explains why

00:21:15,780 --> 00:21:20,559
pledge works really well for the OpenBSD

00:21:18,130 --> 00:21:22,390
people you know they've been they

00:21:20,559 --> 00:21:25,059
typically post these reports saying like

00:21:22,390 --> 00:21:27,100
we've poured it over so many dozens or

00:21:25,059 --> 00:21:30,309
hundreds programs over to use pledge it

00:21:27,100 --> 00:21:33,070
works for them because applications and

00:21:30,309 --> 00:21:35,800
OpenBSD tempt to be fairly small up to

00:21:33,070 --> 00:21:37,420
ten thousand lines of C code and they

00:21:35,800 --> 00:21:39,130
make use of libraries that are all part

00:21:37,420 --> 00:21:41,050
of their base systems so that's why it

00:21:39,130 --> 00:21:42,460
works for them but this also sort of

00:21:41,050 --> 00:21:44,860
demonstrates why I didn't work well for

00:21:42,460 --> 00:21:46,660
me and it also shows you why if you run

00:21:44,860 --> 00:21:48,460
PS on your system and take a look at all

00:21:46,660 --> 00:21:50,500
of the processes that are on there that

00:21:48,460 --> 00:21:58,150
almost none of them use any sandboxing

00:21:50,500 --> 00:22:01,770
framework so 2014 was over I moved back

00:21:58,150 --> 00:22:04,240
to the Netherlands at the end of 2014 a

00:22:01,770 --> 00:22:05,770
gopher and I we found a new apartment in

00:22:04,240 --> 00:22:07,390
which we wanted to live so I was

00:22:05,770 --> 00:22:09,580
spending there a couple of days in a row

00:22:07,390 --> 00:22:11,830
you know sitting on my knees putting new

00:22:09,580 --> 00:22:13,420
floorboards in there and it sort of gave

00:22:11,830 --> 00:22:15,820
me some time to sort of reflect on

00:22:13,420 --> 00:22:19,750
everything that I've been doing in 2014

00:22:15,820 --> 00:22:22,210
so one of the things that I sort of

00:22:19,750 --> 00:22:23,200
realized while I was sort of working on

00:22:22,210 --> 00:22:27,730
my apartment and getting it all

00:22:23,200 --> 00:22:29,230
appreciate was this could all be avoided

00:22:27,730 --> 00:22:30,580
if we simply had a programming

00:22:29,230 --> 00:22:32,679
environment that didn't have this sort

00:22:30,580 --> 00:22:34,390
of state transition in it so where you

00:22:32,679 --> 00:22:37,059
didn't call kept enter to sandbox but

00:22:34,390 --> 00:22:38,800
simply had sandbox in always turned on

00:22:37,059 --> 00:22:42,580
where you could sort of assume that the

00:22:38,800 --> 00:22:44,770
program was sandbox so in that case you

00:22:42,580 --> 00:22:46,390
could sort of design a C programming

00:22:44,770 --> 00:22:48,690
environment where sandboxing is always

00:22:46,390 --> 00:22:51,010
enabled that's very important that

00:22:48,690 --> 00:22:53,830
allows you to remove all sorts of

00:22:51,010 --> 00:22:55,360
functions that are only that only work

00:22:53,830 --> 00:22:56,770
in a non sandbox environment so for

00:22:55,360 --> 00:22:58,630
example the open call you could just

00:22:56,770 --> 00:23:01,000
remove them entirely and all of the

00:22:58,630 --> 00:23:02,530
remaining stuff you could just

00:23:01,000 --> 00:23:04,480
reimplemented in such a way that it

00:23:02,530 --> 00:23:06,100
works well with sandboxing so it really

00:23:04,480 --> 00:23:07,620
takes into account that it's running in

00:23:06,100 --> 00:23:10,320
the sandbox mode

00:23:07,620 --> 00:23:13,230
the advantage of having such a model is

00:23:10,320 --> 00:23:16,480
you can now compile your application and

00:23:13,230 --> 00:23:19,180
it will break it will break in dozens of

00:23:16,480 --> 00:23:20,980
places maybe even hundreds of places but

00:23:19,180 --> 00:23:23,950
still you know exactly which pieces of

00:23:20,980 --> 00:23:26,620
code you sort of need to inspect to get

00:23:23,950 --> 00:23:28,270
it working with sandboxing so it gives

00:23:26,620 --> 00:23:29,980
you this really good guided approach of

00:23:28,270 --> 00:23:31,690
getting your program sandbox you know

00:23:29,980 --> 00:23:33,130
you you start up off of one hundred

00:23:31,690 --> 00:23:35,140
compiler errors of your program not

00:23:33,130 --> 00:23:37,210
working and then you sort of start keep

00:23:35,140 --> 00:23:39,760
on working until you've reached zero and

00:23:37,210 --> 00:23:43,630
then you your program works well in the

00:23:39,760 --> 00:23:45,040
sandbox mode so for example taking this

00:23:43,630 --> 00:23:46,990
piece of code that was from the crypto

00:23:45,040 --> 00:23:48,610
library if he would sort of try to build

00:23:46,990 --> 00:23:50,530
it in such an environment that the sort

00:23:48,610 --> 00:23:52,270
of stripped-down you just get arrows

00:23:50,530 --> 00:23:54,520
like be so your compiled compiler would

00:23:52,270 --> 00:23:55,990
first throw a like a warning saying like

00:23:54,520 --> 00:23:58,480
you know you're trying to call an open

00:23:55,990 --> 00:23:59,920
function and I don't know if the

00:23:58,480 --> 00:24:02,110
existence of any function under that

00:23:59,920 --> 00:24:03,700
name and later on it tries to link that

00:24:02,110 --> 00:24:05,350
program and your linker will fro default

00:24:03,700 --> 00:24:07,330
the error message is at the bottom

00:24:05,350 --> 00:24:08,860
saying that it can't actually combine

00:24:07,330 --> 00:24:11,860
all of the object files of your program

00:24:08,860 --> 00:24:15,580
into a program because there is no open

00:24:11,860 --> 00:24:17,050
function function present so in this

00:24:15,580 --> 00:24:18,550
case it's like really trivial to get

00:24:17,050 --> 00:24:20,290
this fixed if you'd see a piece of code

00:24:18,550 --> 00:24:23,230
that tries to do stuff like this you

00:24:20,290 --> 00:24:25,390
could just replace all of it by a simple

00:24:23,230 --> 00:24:26,710
call to function so I get random or arc

00:24:25,390 --> 00:24:28,450
foreign and buff depending on your

00:24:26,710 --> 00:24:30,190
operating system because these two

00:24:28,450 --> 00:24:31,690
functions they can be properly

00:24:30,190 --> 00:24:34,330
implemented in such a way that they work

00:24:31,690 --> 00:24:37,060
well with sandboxing so it's it's really

00:24:34,330 --> 00:24:40,600
about just detecting break just because

00:24:37,060 --> 00:24:44,380
of sandboxing as early as possible so

00:24:40,600 --> 00:24:47,110
what I did then is I after I was

00:24:44,380 --> 00:24:48,960
finished decorating the apartment open

00:24:47,110 --> 00:24:51,910
up my laptop started hacking again I

00:24:48,960 --> 00:24:54,010
went to the page of the boesak

00:24:51,910 --> 00:24:56,440
specification which you can just freely

00:24:54,010 --> 00:24:58,360
access under this really an annoying URL

00:24:56,440 --> 00:25:01,360
so I can't expect you to memorize the

00:24:58,360 --> 00:25:02,980
numbers at the end but you can just get

00:25:01,360 --> 00:25:04,570
this huge list of all of the functions

00:25:02,980 --> 00:25:06,130
that are part of the specification and

00:25:04,570 --> 00:25:07,300
it's like hundreds of functions and what

00:25:06,130 --> 00:25:10,180
I sort of started doing was sort of

00:25:07,300 --> 00:25:11,530
redacting it so just taking a list and

00:25:10,180 --> 00:25:14,170
removing everything off it that I

00:25:11,530 --> 00:25:16,300
thought was either sort of ancient craft

00:25:14,170 --> 00:25:19,990
that you shouldn't be using anyway or

00:25:16,300 --> 00:25:20,710
stuff that you should only make sense in

00:25:19,990 --> 00:25:22,270
an MA

00:25:20,710 --> 00:25:23,470
sandbox environment or stuff that only

00:25:22,270 --> 00:25:26,559
makes sense in this privileged

00:25:23,470 --> 00:25:28,690
environment and also added a couple of

00:25:26,559 --> 00:25:30,789
extensions on top things that Linux has

00:25:28,690 --> 00:25:32,620
and BSD has but it's not part of the

00:25:30,789 --> 00:25:34,480
Bozek specification - bit sad that

00:25:32,620 --> 00:25:36,159
that's the case because in my opinion

00:25:34,480 --> 00:25:37,929
that the Poe's expect could do a lot

00:25:36,159 --> 00:25:40,870
better job of sort of catching up with

00:25:37,929 --> 00:25:42,549
what's being used in practice and I

00:25:40,870 --> 00:25:46,210
ended up with this list that was sort of

00:25:42,549 --> 00:25:49,570
remarkably small so just to give a

00:25:46,210 --> 00:25:53,260
comparison Linux has about 300 system

00:25:49,570 --> 00:25:57,279
calls FreeBSD has a bit more I think 400

00:25:53,260 --> 00:25:59,679
around a ballpark and this environment

00:25:57,279 --> 00:26:01,419
that I sort of came up with with looking

00:25:59,679 --> 00:26:03,399
at this list would only give me sort of

00:26:01,419 --> 00:26:05,320
an an operating system that it would

00:26:03,399 --> 00:26:07,840
only have 60 system calls in them so

00:26:05,320 --> 00:26:09,399
that's that's tiny also the number of

00:26:07,840 --> 00:26:11,230
data structures that was being used was

00:26:09,399 --> 00:26:13,120
really compact so the programming

00:26:11,230 --> 00:26:14,740
interface for for this environment

00:26:13,120 --> 00:26:18,039
against the operating system was just

00:26:14,740 --> 00:26:20,140
tiny compared to normal UNIX flavors so

00:26:18,039 --> 00:26:22,029
what I thought then was if it's so tiny

00:26:20,140 --> 00:26:26,580
would it make sense to sort of come up

00:26:22,029 --> 00:26:29,529
with like a formal specification yeah

00:26:26,580 --> 00:26:31,630
so this is basically what cloud ABI is

00:26:29,529 --> 00:26:36,039
it's nothing more than a specification

00:26:31,630 --> 00:26:38,140
of a compact UNIX and it's stored in

00:26:36,039 --> 00:26:40,360
this nicely formatted text file

00:26:38,140 --> 00:26:42,100
Molly's wrote in all of nice code to to

00:26:40,360 --> 00:26:44,169
actually process that file and turn it

00:26:42,100 --> 00:26:47,320
into bindings so it allows you to create

00:26:44,169 --> 00:26:49,120
C header files system call tables and

00:26:47,320 --> 00:26:51,039
even documentation and those C had a

00:26:49,120 --> 00:26:53,440
file system called tables those are sort

00:26:51,039 --> 00:26:54,940
of copied into can be copied into source

00:26:53,440 --> 00:26:58,570
trees of operating systems to provide

00:26:54,940 --> 00:27:00,880
support so those bindings are really

00:26:58,570 --> 00:27:02,049
low-level you shouldn't be using them in

00:27:00,880 --> 00:27:04,090
practice this is really all sort of

00:27:02,049 --> 00:27:05,380
machine generated API so instead of

00:27:04,090 --> 00:27:09,730
calling printf for you to end up with

00:27:05,380 --> 00:27:11,020
snippets that look like this but it's it

00:27:09,730 --> 00:27:14,110
can be used as sort of a basis for

00:27:11,020 --> 00:27:16,600
building other things on top so if you

00:27:14,110 --> 00:27:18,130
want to build cloud ABI programs you can

00:27:16,600 --> 00:27:20,049
simply install those header files on

00:27:18,130 --> 00:27:22,419
your system and use a copy of clang

00:27:20,049 --> 00:27:26,940
should be a pretty recent one 3.8 or

00:27:22,419 --> 00:27:29,289
later and call that in the right way to

00:27:26,940 --> 00:27:31,179
target cloud ABI if you just make sure

00:27:29,289 --> 00:27:32,919
that you sim link it under the right

00:27:31,179 --> 00:27:34,450
names and invoke the compiler under that

00:27:32,919 --> 00:27:35,859
net frutos symlinks

00:27:34,450 --> 00:27:37,179
and clang is smart enough to figure out

00:27:35,859 --> 00:27:42,220
that it should be should be across

00:27:37,179 --> 00:27:44,559
compiler so what I've also been working

00:27:42,220 --> 00:27:47,019
on is AC library called cloud Lipsy I'm

00:27:44,559 --> 00:27:50,320
really bad at naming things and it's

00:27:47,019 --> 00:27:52,149
basically just a compact C library built

00:27:50,320 --> 00:27:54,070
on top of cloud ABI it implements all

00:27:52,149 --> 00:27:56,619
irrelevant stuff from POSIX and ISO C

00:27:54,070 --> 00:27:58,989
and compared to normal C libraries that

00:27:56,619 --> 00:28:01,299
sort of different instead of relying all

00:27:58,989 --> 00:28:02,379
of the the false order user share user

00:28:01,299 --> 00:28:04,899
shares own info

00:28:02,379 --> 00:28:06,669
it has also state the sets built-in so

00:28:04,899 --> 00:28:07,779
that means that it still works well in

00:28:06,669 --> 00:28:09,759
sandbox applications

00:28:07,779 --> 00:28:12,580
there's also a large testing coverage of

00:28:09,759 --> 00:28:15,669
more than 900 tests right now and it

00:28:12,580 --> 00:28:17,200
works fairly reliably so here's a list

00:28:15,669 --> 00:28:22,809
of software have already ported over to

00:28:17,200 --> 00:28:24,759
the cloud ABI looking at the time I had

00:28:22,809 --> 00:28:26,259
a couple of projects sort of like bold

00:28:24,759 --> 00:28:28,869
over there that I wanted to look in to

00:28:26,259 --> 00:28:31,119
sort of show the patches to see to see

00:28:28,869 --> 00:28:33,429
how those have reported over but I'll

00:28:31,119 --> 00:28:36,309
keep that as an exercise left to the

00:28:33,429 --> 00:28:38,739
reader so what's been ported over there

00:28:36,309 --> 00:28:41,019
is sort of huge variety of things so it

00:28:38,739 --> 00:28:42,580
ranges from crypto libraries already the

00:28:41,019 --> 00:28:44,259
start of some GUI libraries have been

00:28:42,580 --> 00:28:46,059
ported over you know free type for font

00:28:44,259 --> 00:28:48,700
rendering and Kiro for canvas rendering

00:28:46,059 --> 00:28:51,700
some some database related projects so

00:28:48,700 --> 00:28:53,350
level DB memcache D and I'm pretty

00:28:51,700 --> 00:28:55,749
excited about is that we've also ported

00:28:53,350 --> 00:28:58,179
over Python free recently so at the end

00:28:55,749 --> 00:28:59,679
of my talk you'll get a link to my blog

00:28:58,179 --> 00:29:01,299
and there's an article on there on how

00:28:59,679 --> 00:29:04,119
you can actually run a sandbox to copy

00:29:01,299 --> 00:29:05,950
of Python even in there we're also

00:29:04,119 --> 00:29:07,389
working on getting django ported over we

00:29:05,950 --> 00:29:09,190
can already run some really simple

00:29:07,389 --> 00:29:11,309
django based projects but there's still

00:29:09,190 --> 00:29:14,350
a lot of work that needs to be done to

00:29:11,309 --> 00:29:16,509
sort of make all of it work I think even

00:29:14,350 --> 00:29:18,820
templating is sort of still somewhat

00:29:16,509 --> 00:29:22,779
broken in there and need some more -

00:29:18,820 --> 00:29:24,190
gurus to to sort of get working so what

00:29:22,779 --> 00:29:25,869
we've done is all of that software has

00:29:24,190 --> 00:29:28,269
been ported over has also been sort of

00:29:25,869 --> 00:29:30,070
pre packaged so what we've done is we've

00:29:28,269 --> 00:29:32,070
created this repository of recipes of

00:29:30,070 --> 00:29:34,359
how software for cloudy guy can be built

00:29:32,070 --> 00:29:37,570
one of the things that I really dislike

00:29:34,359 --> 00:29:39,220
about packaged collections is that every

00:29:37,570 --> 00:29:41,379
packaged collection nowadays has its own

00:29:39,220 --> 00:29:43,179
package manager so if you're using

00:29:41,379 --> 00:29:44,529
Python then you have to call pip to

00:29:43,179 --> 00:29:45,940
upgrade all of the software that you've

00:29:44,529 --> 00:29:47,740
installed through that mechanism same

00:29:45,940 --> 00:29:50,050
with sipan's heat and

00:29:47,740 --> 00:29:51,309
cetera so what we're doing is we going

00:29:50,050 --> 00:29:52,720
in this different direction where we're

00:29:51,309 --> 00:29:54,670
actually generating packages for

00:29:52,720 --> 00:29:57,160
different operating systems so we're

00:29:54,670 --> 00:29:59,410
creating Debian packages rpms even

00:29:57,160 --> 00:30:01,600
packages for homebrew on Mac OS and you

00:29:59,410 --> 00:30:02,860
can install them by simply running sort

00:30:01,600 --> 00:30:04,720
of the native package manager on your

00:30:02,860 --> 00:30:06,760
system it's also really nice because the

00:30:04,720 --> 00:30:08,500
package names have the architecture in

00:30:06,760 --> 00:30:10,870
them you can install multiple copies of

00:30:08,500 --> 00:30:12,280
them for different architectures so if

00:30:10,870 --> 00:30:14,890
you were to cross compile software for

00:30:12,280 --> 00:30:16,690
say an arm it's really easy just install

00:30:14,890 --> 00:30:19,420
like the arm version of that package and

00:30:16,690 --> 00:30:21,760
you can compile compile directly on your

00:30:19,420 --> 00:30:23,290
macbook some piece of code for an

00:30:21,760 --> 00:30:24,630
embedded system which i think is like a

00:30:23,290 --> 00:30:26,890
huge plus

00:30:24,630 --> 00:30:29,170
running cloud ABI software there's a

00:30:26,890 --> 00:30:31,929
bunch of operating systems that support

00:30:29,170 --> 00:30:34,120
it by now or for which we provide ways

00:30:31,929 --> 00:30:35,620
of running it on there so freebie is the

00:30:34,120 --> 00:30:39,940
11 or later have all of the support

00:30:35,620 --> 00:30:42,760
integrated Linux net bsd we've patch had

00:30:39,940 --> 00:30:44,380
sets available for those as well there

00:30:42,760 --> 00:30:46,990
is also an emulator available that

00:30:44,380 --> 00:30:48,700
allows you to run cloud ABI programs on

00:30:46,990 --> 00:30:50,620
unpatched operating systems so this is

00:30:48,700 --> 00:30:52,090
what I'm using on my macbook I can't

00:30:50,620 --> 00:30:54,280
expect people here in the audience to

00:30:52,090 --> 00:30:56,890
recompile the kernel Sarah macbook so

00:30:54,280 --> 00:30:58,600
this there's a simple emulator out there

00:30:56,890 --> 00:31:00,760
that can at least be used to run cloud

00:30:58,600 --> 00:31:03,490
ABI software unfortunately it doesn't

00:31:00,760 --> 00:31:06,040
enforce any of the sandboxing under the

00:31:03,490 --> 00:31:07,870
hood so if you would write a piece of

00:31:06,040 --> 00:31:09,610
inline assembly in your code that sort

00:31:07,870 --> 00:31:11,290
of tries to call a Mac OS system called

00:31:09,610 --> 00:31:13,990
directly instead of going through the

00:31:11,290 --> 00:31:15,730
emulator you can bypass security but

00:31:13,990 --> 00:31:17,679
it's sort of good enough for you know

00:31:15,730 --> 00:31:22,870
testing software before you deploy it

00:31:17,679 --> 00:31:24,880
over to your Linux or BSD cluster so

00:31:22,870 --> 00:31:27,190
running cloud ABI software this is a

00:31:24,880 --> 00:31:29,860
very simple copy of LS that I've sort of

00:31:27,190 --> 00:31:32,559
added to the slide so instead of just

00:31:29,860 --> 00:31:34,390
reading the directory listing from a

00:31:32,559 --> 00:31:36,580
directory which you specify on a command

00:31:34,390 --> 00:31:38,620
line it simply assumes that a file

00:31:36,580 --> 00:31:40,600
descriptor in this case file descriptor

00:31:38,620 --> 00:31:41,770
0 corresponds to a directory and file

00:31:40,600 --> 00:31:43,929
descriptor 1 corresponds to your

00:31:41,770 --> 00:31:45,490
terminal so if you want to run this you

00:31:43,929 --> 00:31:48,280
end up doing this you end up building it

00:31:45,490 --> 00:31:50,380
and running it like this so it's a bit

00:31:48,280 --> 00:31:52,750
nasty sort of past fresh EDC over and

00:31:50,380 --> 00:31:54,700
standard in and voila you've got a copy

00:31:52,750 --> 00:31:56,500
of LS that can only access a directory

00:31:54,700 --> 00:32:01,350
and access your terminal that's it so

00:31:56,500 --> 00:32:03,120
this works but it doesn't really scale

00:32:01,350 --> 00:32:05,279
think of the following use case you've

00:32:03,120 --> 00:32:07,650
got a web server that can listen on ten

00:32:05,279 --> 00:32:09,779
IP addresses and has 40 different

00:32:07,650 --> 00:32:12,000
virtual hosts and for all of those you

00:32:09,779 --> 00:32:13,289
need one file descriptor passing this in

00:32:12,000 --> 00:32:16,039
on the command line doesn't make any

00:32:13,289 --> 00:32:20,220
sense or you know it's it's a mess

00:32:16,039 --> 00:32:23,299
so I've been working on an alternative

00:32:20,220 --> 00:32:25,860
for that called cloud ABI desh run and

00:32:23,299 --> 00:32:27,809
what you basically do is you you've just

00:32:25,860 --> 00:32:29,640
invoked it like this you say I want to

00:32:27,809 --> 00:32:31,590
run this executable and I want to

00:32:29,640 --> 00:32:33,299
provide it a configuration file of how

00:32:31,590 --> 00:32:34,770
it needs to be started and this

00:32:33,299 --> 00:32:36,419
configuration file sort of a replacement

00:32:34,770 --> 00:32:38,460
for command line arguments and it's sort

00:32:36,419 --> 00:32:40,740
of Yama like and where it differs from

00:32:38,460 --> 00:32:43,140
Yama or extends on yamo is that it's

00:32:40,740 --> 00:32:47,760
actually it has file descriptors as a

00:32:43,140 --> 00:32:49,230
native datatype so consider this simple

00:32:47,760 --> 00:32:51,000
web server for which you're writing a

00:32:49,230 --> 00:32:52,919
configuration file normally you'd write

00:32:51,000 --> 00:32:54,270
something down like this where you say

00:32:52,919 --> 00:32:57,539
it needs to listen on this IP address

00:32:54,270 --> 00:32:59,549
and each taxes these files on disk with

00:32:57,539 --> 00:33:01,289
cloud ABI run you sort of add

00:32:59,549 --> 00:33:04,710
annotations to them where you say like

00:33:01,289 --> 00:33:06,899
this is not a string of some kind of IP

00:33:04,710 --> 00:33:09,179
address this really needs to be a socket

00:33:06,899 --> 00:33:10,919
on which we want to listen and that's

00:33:09,179 --> 00:33:12,120
what you do with those exclamations tags

00:33:10,919 --> 00:33:13,649
that you see in there that sort of a

00:33:12,120 --> 00:33:15,799
standard feature of Yama where you can

00:33:13,649 --> 00:33:18,960
introduce typing information into the

00:33:15,799 --> 00:33:21,779
definitions so what happens is this file

00:33:18,960 --> 00:33:24,659
sort of gets parsed and gets converted

00:33:21,779 --> 00:33:26,730
by Claudia I run into this format namely

00:33:24,659 --> 00:33:28,200
where all of the files all the resources

00:33:26,730 --> 00:33:29,880
are replaced by file descriptor numbers

00:33:28,200 --> 00:33:32,520
and this is being passed on to the

00:33:29,880 --> 00:33:36,179
program there is also an API for

00:33:32,520 --> 00:33:37,799
accessing those files from within the

00:33:36,179 --> 00:33:40,440
program of course so instead of using

00:33:37,799 --> 00:33:42,029
the init main entry point you now use an

00:33:40,440 --> 00:33:43,890
alternative entry point called program

00:33:42,029 --> 00:33:45,690
main where you have some accessor

00:33:43,890 --> 00:33:48,870
functions for iterating over maps and

00:33:45,690 --> 00:33:50,190
dictionaries or sorry maps of sequences

00:33:48,870 --> 00:33:52,020
and you also have functions for

00:33:50,190 --> 00:33:55,830
accessing boolean's integers strings

00:33:52,020 --> 00:33:58,799
file scripters so what's the advantage

00:33:55,830 --> 00:34:00,390
of using cloudy ABI run you know of a

00:33:58,799 --> 00:34:02,159
unified configuration file format

00:34:00,390 --> 00:34:04,470
there's no need to write your own

00:34:02,159 --> 00:34:06,059
configuration file parsers programs tend

00:34:04,470 --> 00:34:09,690
to become smaller as a result of using

00:34:06,059 --> 00:34:11,369
this and there's also no way of actually

00:34:09,690 --> 00:34:13,200
accidentally leaking resources into a

00:34:11,369 --> 00:34:14,760
program what's really awesome about this

00:34:13,200 --> 00:34:15,870
mechanism is you can just

00:34:14,760 --> 00:34:18,149
as long as you make sure that you're not

00:34:15,870 --> 00:34:19,169
using any exclamation mark tags for

00:34:18,149 --> 00:34:21,510
things that you don't want to give away

00:34:19,169 --> 00:34:24,000
to a process you can run stuff that you

00:34:21,510 --> 00:34:26,130
don't even trust so you can sort of say

00:34:24,000 --> 00:34:28,649
like I'm providing in to fowl scripters

00:34:26,130 --> 00:34:30,179
one of my standard in on the terminal

00:34:28,649 --> 00:34:32,159
one of the standard out on the terminal

00:34:30,179 --> 00:34:33,419
as well and then the process can only

00:34:32,159 --> 00:34:35,220
read and write through a terminal and

00:34:33,419 --> 00:34:36,899
can't do anything else and that's sort

00:34:35,220 --> 00:34:38,880
of really ensured by using this utility

00:34:36,899 --> 00:34:42,110
that there's no accidental leakage of

00:34:38,880 --> 00:34:44,340
stuff another really cool thing of this

00:34:42,110 --> 00:34:47,690
mechanism is that it makes programs

00:34:44,340 --> 00:34:50,940
really easy to test so because you know

00:34:47,690 --> 00:34:53,970
what a program is going to access you

00:34:50,940 --> 00:34:55,830
also know that it can't actually

00:34:53,970 --> 00:34:57,210
interfere with your production setup for

00:34:55,830 --> 00:35:00,240
example so if you have a production and

00:34:57,210 --> 00:35:01,800
a staging setup you only need to sort of

00:35:00,240 --> 00:35:02,790
check the configuration file to make

00:35:01,800 --> 00:35:04,920
sure that you don't list file

00:35:02,790 --> 00:35:07,260
descriptors that correspond to servers

00:35:04,920 --> 00:35:08,970
or datasets belong to the production

00:35:07,260 --> 00:35:11,250
setup and now you can safely your run

00:35:08,970 --> 00:35:14,820
your process knowing that it won't

00:35:11,250 --> 00:35:17,160
interfere so what if I shown you so far

00:35:14,820 --> 00:35:18,900
in this presentation you know I've been

00:35:17,160 --> 00:35:20,430
talking about the cloud EBI project that

00:35:18,900 --> 00:35:22,590
I've been working on with a bunch of

00:35:20,430 --> 00:35:24,450
other people and it's a framework for

00:35:22,590 --> 00:35:26,010
building testable and secure programs

00:35:24,450 --> 00:35:28,680
and it consists of a couple of

00:35:26,010 --> 00:35:30,840
components namely the raw definitions of

00:35:28,680 --> 00:35:33,240
the ABI the C library that's built on

00:35:30,840 --> 00:35:36,720
top of that the package collection for

00:35:33,240 --> 00:35:38,460
prepackaged programs and the cloud ABI

00:35:36,720 --> 00:35:42,630
run utility that can be used to safely

00:35:38,460 --> 00:35:45,200
spawn those sandbox processes so now I

00:35:42,630 --> 00:35:48,410
want to close off this talk by sort of

00:35:45,200 --> 00:35:50,550
sketching a road map for the future so

00:35:48,410 --> 00:35:55,920
what is going to happen until the end of

00:35:50,550 --> 00:35:57,450
times 2048 so I've got some short-term

00:35:55,920 --> 00:36:00,060
goals I'm not saying that there are

00:35:57,450 --> 00:36:01,380
personal goals but these are goals for

00:36:00,060 --> 00:36:03,540
the project I think things that the

00:36:01,380 --> 00:36:04,980
project should explore so first of all

00:36:03,540 --> 00:36:05,670
we need support for more programming

00:36:04,980 --> 00:36:08,340
languages

00:36:05,670 --> 00:36:10,800
right now we have support for C C++

00:36:08,340 --> 00:36:13,560
Python and Lua

00:36:10,800 --> 00:36:15,930
I think so just for programming

00:36:13,560 --> 00:36:18,120
languages scripting languages but this

00:36:15,930 --> 00:36:20,220
needs to be more nowadays you see a lot

00:36:18,120 --> 00:36:21,780
of people writing software and go and in

00:36:20,220 --> 00:36:25,080
rust and all sorts of other modern

00:36:21,780 --> 00:36:26,640
languages we need to sort of be on board

00:36:25,080 --> 00:36:28,130
with that as well so we can actually

00:36:26,640 --> 00:36:31,970
welcome more people

00:36:28,130 --> 00:36:33,500
into the project also so far we've had a

00:36:31,970 --> 00:36:36,260
really strong focus on getting libraries

00:36:33,500 --> 00:36:38,300
to work you know as you saw in the

00:36:36,260 --> 00:36:39,800
previous slides there's a whole bunch of

00:36:38,300 --> 00:36:41,630
libraries saidif already mean packages

00:36:39,800 --> 00:36:43,610
but now sometimes actually get full

00:36:41,630 --> 00:36:45,320
programs to work we have all of the

00:36:43,610 --> 00:36:46,730
dependencies ported over and now we can

00:36:45,320 --> 00:36:49,430
actually start building full programs

00:36:46,730 --> 00:36:51,470
you know having a sandbox my sequel

00:36:49,430 --> 00:36:53,510
server where you're you can only sort of

00:36:51,470 --> 00:36:54,680
say like this is your data directory and

00:36:53,510 --> 00:36:56,660
this is your socket on which you're

00:36:54,680 --> 00:36:59,630
receiving incoming sequel queries that's

00:36:56,660 --> 00:37:01,340
pretty awesome same holds for nodejs if

00:36:59,630 --> 00:37:04,790
you want to run sandbox web applications

00:37:01,340 --> 00:37:06,680
of course linux support right now it's

00:37:04,790 --> 00:37:09,560
an external repository this needs to be

00:37:06,680 --> 00:37:10,940
integrated period or at least the things

00:37:09,560 --> 00:37:13,430
that we can get rid of need to be

00:37:10,940 --> 00:37:16,100
upstream into the official Linux kernel

00:37:13,430 --> 00:37:17,510
so in the end all of cloud EBI support

00:37:16,100 --> 00:37:19,520
is nothing more than a simple kernel

00:37:17,510 --> 00:37:21,890
module that you can load into a stock

00:37:19,520 --> 00:37:23,270
Linux kernel and of course there's

00:37:21,890 --> 00:37:27,410
always the need to improve the

00:37:23,270 --> 00:37:29,510
documentation always and I already have

00:37:27,410 --> 00:37:32,210
a couple of how-tos on like the cloud

00:37:29,510 --> 00:37:33,440
API blog but we really need to extend on

00:37:32,210 --> 00:37:37,340
that there needs to be good developer

00:37:33,440 --> 00:37:39,350
documentation as well long term goal for

00:37:37,340 --> 00:37:41,180
the project so a lot of people they sort

00:37:39,350 --> 00:37:43,010
of say to me like cloud API is the

00:37:41,180 --> 00:37:45,100
stupidest name I've ever heard it

00:37:43,010 --> 00:37:48,380
doesn't make any sense

00:37:45,100 --> 00:37:49,790
the reason for that is that I often also

00:37:48,380 --> 00:37:52,700
have to show this slide sort of

00:37:49,790 --> 00:37:55,940
explaining the sort of original mindset

00:37:52,700 --> 00:37:57,260
I had for the project so cloudy API is a

00:37:55,940 --> 00:38:00,740
way where you can do dependency

00:37:57,260 --> 00:38:02,300
injection for UNIX programs and what

00:38:00,740 --> 00:38:04,430
would happen if you could actually make

00:38:02,300 --> 00:38:06,410
use of that as part of some kind of

00:38:04,430 --> 00:38:08,360
cluster management system so say you

00:38:06,410 --> 00:38:11,000
want to deploy a pipeline of database

00:38:08,360 --> 00:38:12,860
servers web front-ends batch jobs all of

00:38:11,000 --> 00:38:14,570
that stuff and you've made use of this

00:38:12,860 --> 00:38:17,000
model there you could actually design

00:38:14,570 --> 00:38:19,490
some pretty fancy stuff so first of all

00:38:17,000 --> 00:38:20,870
you could build some kind of GUI where

00:38:19,490 --> 00:38:22,370
you can drag and drop programs on a

00:38:20,870 --> 00:38:24,530
canvas and hook them up fruit like

00:38:22,370 --> 00:38:25,970
arrows say like this is a web front-end

00:38:24,530 --> 00:38:27,980
it needs to talk to this database server

00:38:25,970 --> 00:38:29,420
you could just click a play button and

00:38:27,980 --> 00:38:30,950
it would automatically set it up it

00:38:29,420 --> 00:38:33,080
would know how to sort of connect all of

00:38:30,950 --> 00:38:34,730
those programs together you could also

00:38:33,080 --> 00:38:37,730
even have like monitoring dashboards

00:38:34,730 --> 00:38:39,200
based on this concept where you know the

00:38:37,730 --> 00:38:41,000
cluster management system knows the

00:38:39,200 --> 00:38:41,509
relationship between programs so we can

00:38:41,000 --> 00:38:44,329
actually

00:38:41,509 --> 00:38:47,089
if you accurate monitoring for that also

00:38:44,329 --> 00:38:48,979
a very interesting aspect is that this

00:38:47,089 --> 00:38:50,809
kind of mechanism could be used for like

00:38:48,979 --> 00:38:53,029
setting up the connections between those

00:38:50,809 --> 00:38:55,069
processes securely so if it knows that

00:38:53,029 --> 00:38:57,499
it's going to start up to two processors

00:38:55,069 --> 00:38:59,089
on the same server it doesn't even need

00:38:57,499 --> 00:39:00,979
to care about cryptography because it's

00:38:59,089 --> 00:39:02,659
already sort of secure nobody kind can

00:39:00,979 --> 00:39:05,209
eavesdrop on those kinds of connections

00:39:02,659 --> 00:39:07,249
but if it's starting those two processes

00:39:05,209 --> 00:39:08,569
in different data centers then the

00:39:07,249 --> 00:39:09,979
cluster management system could be

00:39:08,569 --> 00:39:12,319
responsible for creating the keys

00:39:09,979 --> 00:39:14,599
sending them over to the two servers

00:39:12,319 --> 00:39:16,639
running the processes and the server

00:39:14,599 --> 00:39:18,259
could then automatically set up a secure

00:39:16,639 --> 00:39:23,989
channel between those two processes

00:39:18,259 --> 00:39:25,939
which simplifies this kind of management

00:39:23,989 --> 00:39:28,099
a lot I think using kubernetes a lot and

00:39:25,939 --> 00:39:29,659
we have to spend quite a lot of time

00:39:28,099 --> 00:39:31,639
getting all of the crypto and all of the

00:39:29,659 --> 00:39:34,099
key exchange right and this could be

00:39:31,639 --> 00:39:35,719
sort of solved automatically so my

00:39:34,099 --> 00:39:37,880
long-term goal is maybe we could extend

00:39:35,719 --> 00:39:40,249
sort of tools like cuban 8's to have

00:39:37,880 --> 00:39:43,729
proper cloud api support and do this out

00:39:40,249 --> 00:39:46,989
of the box so now I'm sort of at the

00:39:43,729 --> 00:39:48,769
last one or two slides of my talk I

00:39:46,989 --> 00:39:51,829
briefly want to talk about the

00:39:48,769 --> 00:39:53,419
sustainability of this project I've been

00:39:51,829 --> 00:39:54,679
working on this project for two years I

00:39:53,419 --> 00:39:57,849
had the luck of being able to work on

00:39:54,679 --> 00:39:57,849
this for for one full year

00:39:58,269 --> 00:40:02,779
unfortunately because there is sort of

00:40:00,799 --> 00:40:05,059
no full-time headcount on this project

00:40:02,779 --> 00:40:06,859
anymore the things that have sort of

00:40:05,059 --> 00:40:10,479
shown on the previous slide are actually

00:40:06,859 --> 00:40:12,769
sort of infeasible at this moment and

00:40:10,479 --> 00:40:14,119
that's why I sort of you know this is

00:40:12,769 --> 00:40:15,589
sort of like a call for help to the

00:40:14,119 --> 00:40:18,109
audience if you think that this is a

00:40:15,589 --> 00:40:20,839
cool project you know at least start

00:40:18,109 --> 00:40:22,969
using it you know try exploring it see

00:40:20,839 --> 00:40:25,369
whether it works for you you'll quickly

00:40:22,969 --> 00:40:27,079
run into bugs hopefully send pull

00:40:25,369 --> 00:40:29,869
requests and you know it would be

00:40:27,079 --> 00:40:31,249
awesome if like but the cloudy API team

00:40:29,869 --> 00:40:34,359
can grow because I think it's a really

00:40:31,249 --> 00:40:36,409
valuable project you know in my opinion

00:40:34,359 --> 00:40:38,809
that allows you to build secure

00:40:36,409 --> 00:40:40,339
applications just easily compared to

00:40:38,809 --> 00:40:44,989
toll of the existing frameworks out

00:40:40,339 --> 00:40:46,130
there so please give it a try I wanna

00:40:44,989 --> 00:40:47,899
give my special thanks to a couple of

00:40:46,130 --> 00:40:49,909
people some of them are sitting in the

00:40:47,899 --> 00:40:52,819
audience good friends of mine have been

00:40:49,909 --> 00:40:54,890
sort of either pestering me with bug

00:40:52,819 --> 00:40:58,400
reports or just giving me

00:40:54,890 --> 00:41:00,440
mental support or cat ogia our cats

00:40:58,400 --> 00:41:02,510
walking on my keyboard all day long

00:41:00,440 --> 00:41:04,280
wrecking my code I want to thank two

00:41:02,510 --> 00:41:06,200
people at Kuna Bay Bay who've also been

00:41:04,280 --> 00:41:07,460
supporting me over last half year and

00:41:06,200 --> 00:41:10,640
I've allowed to sort of work on this

00:41:07,460 --> 00:41:12,950
part time so this concludes my talk

00:41:10,640 --> 00:41:16,750
here's a couple of links be sure to

00:41:12,950 --> 00:41:16,750
check them out are there any questions

00:41:22,900 --> 00:41:26,360
so thank you for doing this because it's

00:41:25,160 --> 00:41:29,750
really important that we finally got a

00:41:26,360 --> 00:41:32,600
secure Linux open source and free

00:41:29,750 --> 00:41:34,880
software kernel and my question is first

00:41:32,600 --> 00:41:37,130
of all the the problems that you noted

00:41:34,880 --> 00:41:39,770
we're all more or less to do with the

00:41:37,130 --> 00:41:42,410
the VFS and use basically say you don't

00:41:39,770 --> 00:41:44,300
have a root VFS you can't do open why

00:41:42,410 --> 00:41:47,119
don't you do something like a CX root

00:41:44,300 --> 00:41:51,980
and then bind in the appropriate global

00:41:47,119 --> 00:41:53,510
state that is benign and my second

00:41:51,980 --> 00:41:56,750
question is is that you talk about the

00:41:53,510 --> 00:42:00,230
save issue with Firefox why don't you

00:41:56,750 --> 00:42:01,490
have something like a power box or have

00:42:00,230 --> 00:42:06,320
you thought about how to do a power box

00:42:01,490 --> 00:42:08,480
so so to answer your your your first

00:42:06,320 --> 00:42:10,640
question which was why didn't you sort

00:42:08,480 --> 00:42:14,300
of ever way of organizing the filesystem

00:42:10,640 --> 00:42:15,710
layout so what I've noticed is that this

00:42:14,300 --> 00:42:17,450
is basically also the mindset that

00:42:15,710 --> 00:42:20,780
operating systems like plan nine have

00:42:17,450 --> 00:42:22,910
been using you know get give have proper

00:42:20,780 --> 00:42:24,260
api swear processes can sort of create

00:42:22,910 --> 00:42:26,420
layouts of their own file system

00:42:24,260 --> 00:42:29,630
namespaces everything is done in the

00:42:26,420 --> 00:42:31,460
falsest namespace but my observation is

00:42:29,630 --> 00:42:35,720
is that it sort of quickly gets messy

00:42:31,460 --> 00:42:38,270
and bloating because so in the case of a

00:42:35,720 --> 00:42:40,250
file system what you can do is you can

00:42:38,270 --> 00:42:42,980
sort of pass it on to new processes to

00:42:40,250 --> 00:42:44,240
child processes to help or processes but

00:42:42,980 --> 00:42:45,980
what you'll see in practice is that

00:42:44,240 --> 00:42:48,500
nobody will borrow to sort of clean

00:42:45,980 --> 00:42:50,030
those up so then you sort of end up in a

00:42:48,500 --> 00:42:51,980
state where you have like a bunch of

00:42:50,030 --> 00:42:54,260
sort of privileged separated processes

00:42:51,980 --> 00:42:56,150
but in the end I still make use of this

00:42:54,260 --> 00:42:57,410
bloaty file system namespace where

00:42:56,150 --> 00:42:59,619
there's a lot of stuff in there that

00:42:57,410 --> 00:43:02,090
processors don't need to access so

00:42:59,619 --> 00:43:03,920
basically how this differs from from

00:43:02,090 --> 00:43:05,750
what you proposed how cloudy API differs

00:43:03,920 --> 00:43:08,990
is that it's a false Krypton namespace

00:43:05,750 --> 00:43:11,390
it's a flat namespace and my hope is

00:43:08,990 --> 00:43:15,350
compared to using a false or like a tree

00:43:11,390 --> 00:43:17,090
based namespace is that this will not

00:43:15,350 --> 00:43:20,570
leak as quickly you know the people are

00:43:17,090 --> 00:43:22,760
a bit more thoughtful about this well

00:43:20,570 --> 00:43:23,990
maybe it's a bit overly often optimistic

00:43:22,760 --> 00:43:26,210
but we'll see

00:43:23,990 --> 00:43:28,100
to answer your your second question so

00:43:26,210 --> 00:43:32,119
like the example I gave with the browser

00:43:28,100 --> 00:43:33,240
I mean it's it's just like a simple

00:43:32,119 --> 00:43:35,340
example

00:43:33,240 --> 00:43:37,590
that could like be substituted for any

00:43:35,340 --> 00:43:39,480
different application so for example

00:43:37,590 --> 00:43:41,910
your text editor has the same issue of

00:43:39,480 --> 00:43:43,260
course when you're running vim it can

00:43:41,910 --> 00:43:44,670
also access a lot of things in the

00:43:43,260 --> 00:43:47,670
meantime that shouldn't be accessible

00:43:44,670 --> 00:43:49,530
and yeah that could be solved by making

00:43:47,670 --> 00:43:51,480
use of different sort of helper tools

00:43:49,530 --> 00:43:53,670
but the nice thing about this approach

00:43:51,480 --> 00:43:55,619
is that it actually enforces the use of

00:43:53,670 --> 00:43:58,350
a mechanism like that you know it's not

00:43:55,619 --> 00:44:00,030
about just that I've got like a whole

00:43:58,350 --> 00:44:01,800
solution for that in place already set

00:44:00,030 --> 00:44:03,000
up but the idea beyond cloud API is to

00:44:01,800 --> 00:44:05,700
come up with my environment that sort of

00:44:03,000 --> 00:44:07,520
forces people to design applications in

00:44:05,700 --> 00:44:10,350
this sort of privileged separated way

00:44:07,520 --> 00:44:12,030
that's sort of you know trying to solve

00:44:10,350 --> 00:44:13,890
it at the root and not at the top that's

00:44:12,030 --> 00:44:16,520
that's what the cloudy API project is

00:44:13,890 --> 00:44:20,150
about did it answer your questions or

00:44:16,520 --> 00:44:20,150
any other questions

00:44:24,109 --> 00:44:32,180
Oh God are you aware of e and so they

00:44:29,930 --> 00:44:33,440
have a mechanism called vats and that

00:44:32,180 --> 00:44:34,519
more or less does exactly what you're

00:44:33,440 --> 00:44:36,289
talking about with respect to

00:44:34,519 --> 00:44:39,859
automatically creating secure channels

00:44:36,289 --> 00:44:42,999
between between multiple computers over

00:44:39,859 --> 00:44:46,459
the network and doing consistency things

00:44:42,999 --> 00:44:47,930
so I'm not aware of that project

00:44:46,459 --> 00:44:51,229
specifically well what's the name of

00:44:47,930 --> 00:44:56,259
that again II just to let her eat that's

00:44:51,229 --> 00:44:56,259
it okay oh look into that damn man

00:44:58,289 --> 00:45:04,499
if you look for a mark millar and a then

00:45:00,880 --> 00:45:04,499
you'll find it ah thanks

00:45:13,260 --> 00:45:17,070
well then if nobody else has questions

00:45:15,300 --> 00:45:18,810
and thanks for attending my talk later

00:45:17,070 --> 00:45:20,790
today there's going to be a talk in a

00:45:18,810 --> 00:45:22,590
BSD DEP room where I sort of go into

00:45:20,790 --> 00:45:25,740
more details on the kernel side of how

00:45:22,590 --> 00:45:27,060
all of this works well I guess not all

00:45:25,740 --> 00:45:31,070
of you should be showing up because the

00:45:27,060 --> 00:45:31,070
room is a lot smaller than than this one

00:45:37,610 --> 00:45:47,960
all right thanks that's for you thanks

00:45:44,850 --> 00:45:47,960
in China

00:46:02,980 --> 00:46:06,540
yeah so the charger was mine

00:46:12,869 --> 00:46:22,230
yeah so I'm going to discuss how it

00:46:15,220 --> 00:46:22,230
works because the point is I

00:46:25,030 --> 00:46:28,380
because I wasn't sure I would

00:47:37,010 --> 00:47:40,849
so I guess I should

00:48:24,610 --> 00:48:27,600
I got everything

00:48:39,690 --> 00:48:44,970

YouTube URL: https://www.youtube.com/watch?v=HP3pGSV5d0I


