Title: Securing Automated Decryption New Cryptography and Techniques
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	by Nathaniel McCallum

At: FOSDEM 2017

This talk covers an alternative to key escrows using new cryptographictechniques implemented by the Clevis (client) and Tang (server) projects.

Keeping secrets is tough. It is hard enough when you have control over thefull computing chain. But now we are expected to keep secrets while storingthose secrets in cloud and SaaS infrastructures. At least we can trust thenetwork providers, right? Of course, the answer is to encrypt the data. Butthen how do we know who should have access to the data and when? This talkwill look at the new strategies and cryptographic techniques implemented bythe Tang and Clevis open source projects. Tang forgoes complex (andcompromise-prone) key management infrastructures by using simple algorithms tobind data to third party entities. Clevis permits sophisticated unlockingpolicies that go beyond simply password management to true attributedcryptography. Come see how to integrate Tang and Clevis into yourinfrastructure or software project!


Room: Janson
Scheduled start: 2017-02-05 12:00:00
Captions: 
	00:00:00,000 --> 00:00:03,399
[Applause]

00:00:07,490 --> 00:00:13,679
so I will actually ask for a little bit

00:00:10,830 --> 00:00:17,220
of patience today my slides are actually

00:00:13,679 --> 00:00:18,750
being hosted in the cloud and the data

00:00:17,220 --> 00:00:21,240
center apparently has had a massive

00:00:18,750 --> 00:00:21,840
disaster the entire data center lost

00:00:21,240 --> 00:00:25,470
power

00:00:21,840 --> 00:00:27,390
all systems are down and but at least

00:00:25,470 --> 00:00:29,880
they're very good at transparency so

00:00:27,390 --> 00:00:33,000
they give us a live feed of them

00:00:29,880 --> 00:00:37,079
bringing up the system the and so we can

00:00:33,000 --> 00:00:38,790
actually see what we've apparently all

00:00:37,079 --> 00:00:40,950
the servers are requiring passwords to

00:00:38,790 --> 00:00:44,640
boot because they have encrypted drives

00:00:40,950 --> 00:00:47,160
and so we have guys Fleur

00:00:44,640 --> 00:00:48,300
you know quickly running around the data

00:00:47,160 --> 00:00:49,590
center trying to type in all these

00:00:48,300 --> 00:00:54,059
passwords to bring up these these

00:00:49,590 --> 00:00:56,039
thousands of systems and so this is

00:00:54,059 --> 00:01:00,570
obviously not scalable in the long term

00:00:56,039 --> 00:01:01,920
and so we actually have I want to give

00:01:00,570 --> 00:01:04,050
you a look of where we've sort of been

00:01:01,920 --> 00:01:06,170
in the past where we are today and where

00:01:04,050 --> 00:01:08,670
we're going in the future

00:01:06,170 --> 00:01:11,939
yesterday we were working on standards

00:01:08,670 --> 00:01:14,790
these are things like AES things like in

00:01:11,939 --> 00:01:17,010
the United States PCI DSS these make

00:01:14,790 --> 00:01:18,540
sure that everyone is using encryption

00:01:17,010 --> 00:01:20,790
at the right time and in the right way

00:01:18,540 --> 00:01:22,590
and making sure that with that when they

00:01:20,790 --> 00:01:24,780
do encryption that it's done in

00:01:22,590 --> 00:01:27,840
standards ways so yesterday was mostly

00:01:24,780 --> 00:01:29,900
about developing standards today however

00:01:27,840 --> 00:01:31,740
we are actually moving beyond

00:01:29,900 --> 00:01:34,200
standardization process of course

00:01:31,740 --> 00:01:35,939
standardization will continue but we are

00:01:34,200 --> 00:01:38,549
now starting to worry about the question

00:01:35,939 --> 00:01:41,759
of automation how do we actually make

00:01:38,549 --> 00:01:44,310
decryption happen automatically and then

00:01:41,759 --> 00:01:46,259
tomorrow we are going to be working on

00:01:44,310 --> 00:01:48,509
policy and the reason for this is that

00:01:46,259 --> 00:01:51,720
right now we're just trying to work on a

00:01:48,509 --> 00:01:53,149
simple binary so you can see the

00:01:51,720 --> 00:01:56,189
automation is just an on and off switch

00:01:53,149 --> 00:01:58,110
right can i unlock automatically yes or

00:01:56,189 --> 00:02:00,659
no and we're trying very desperately to

00:01:58,110 --> 00:02:01,979
make that a reality but in fact what's

00:02:00,659 --> 00:02:04,020
going to happen once we've achieved that

00:02:01,979 --> 00:02:06,600
goal we're also going to quickly realize

00:02:04,020 --> 00:02:07,860
that we want to be able to automatically

00:02:06,600 --> 00:02:10,730
decrypt in a variety of circumstances

00:02:07,860 --> 00:02:15,060
and we want a variety of different

00:02:10,730 --> 00:02:17,340
policies to to give us something that's

00:02:15,060 --> 00:02:18,480
a more a more structured scale so you

00:02:17,340 --> 00:02:21,840
see the slider

00:02:18,480 --> 00:02:25,590
for our policy so the first question is

00:02:21,840 --> 00:02:27,090
how do we automate well we all start out

00:02:25,590 --> 00:02:28,320
with a secret of course this is the

00:02:27,090 --> 00:02:31,260
thing that we're trying to encrypt and

00:02:28,320 --> 00:02:33,510
then later decrypt then we wrap it into

00:02:31,260 --> 00:02:35,940
something called an encryption key this

00:02:33,510 --> 00:02:38,010
is the symmetric key usually that that

00:02:35,940 --> 00:02:40,470
actually encrypts the secret itself and

00:02:38,010 --> 00:02:42,600
then the encryption key itself is ripped

00:02:40,470 --> 00:02:44,820
is encrypted in a key encryption key and

00:02:42,600 --> 00:02:47,580
so this is the pretty standard model you

00:02:44,820 --> 00:02:49,830
see everywhere if you are involved in

00:02:47,580 --> 00:02:51,930
decryption standards if you've ever

00:02:49,830 --> 00:02:54,420
evaluated how lux works for instance on

00:02:51,930 --> 00:02:56,910
Linux this is a pretty standard model of

00:02:54,420 --> 00:02:58,800
how things work and then what we do is

00:02:56,910 --> 00:03:01,050
we have this key encryption key beasts

00:02:58,800 --> 00:03:03,330
usually something like a password so we

00:03:01,050 --> 00:03:05,610
see here from xkcd correct battery or a

00:03:03,330 --> 00:03:07,260
staple wonderful password and then we

00:03:05,610 --> 00:03:09,150
share that password around with a bunch

00:03:07,260 --> 00:03:10,350
of people now obviously this is the

00:03:09,150 --> 00:03:13,500
system that we're trying to move away

00:03:10,350 --> 00:03:15,600
from and we don't like the fact that we

00:03:13,500 --> 00:03:18,210
have to share this key encryption key

00:03:15,600 --> 00:03:20,520
with with everyone because of course one

00:03:18,210 --> 00:03:24,510
of those people goes rogue then we've

00:03:20,520 --> 00:03:27,990
lost our data so what we do instead is

00:03:24,510 --> 00:03:30,510
we create a much stronger key something

00:03:27,990 --> 00:03:33,120
that is cryptographically strong and

00:03:30,510 --> 00:03:35,850
then we store it in an escrow remotely

00:03:33,120 --> 00:03:37,800
and when we want when we want to be able

00:03:35,850 --> 00:03:39,540
to unlock our data we just simply fetch

00:03:37,800 --> 00:03:41,070
the key back from the escrow has

00:03:39,540 --> 00:03:43,590
everybody seen something like this raise

00:03:41,070 --> 00:03:45,440
your hand if you've seen a system like

00:03:43,590 --> 00:03:48,420
this am I done

00:03:45,440 --> 00:03:52,260
describing the architecture because it

00:03:48,420 --> 00:03:53,670
seems pretty simple right well

00:03:52,260 --> 00:03:56,520
unfortunately we have to encrypt this

00:03:53,670 --> 00:03:58,290
channel right because we can't just ship

00:03:56,520 --> 00:04:00,330
keys back and forth and so now we're

00:03:58,290 --> 00:04:03,030
usually doing TLS most commonly or

00:04:00,330 --> 00:04:05,130
gssapi in order to create an encrypted

00:04:03,030 --> 00:04:08,940
channel to be able to send the keys with

00:04:05,130 --> 00:04:10,410
and then finally we're done no

00:04:08,940 --> 00:04:12,000
unfortunately we actually have to

00:04:10,410 --> 00:04:15,000
authenticate to the escrow server

00:04:12,000 --> 00:04:17,459
because we can't just you know ship off

00:04:15,000 --> 00:04:19,440
keys to some remote entity in hope that

00:04:17,459 --> 00:04:21,720
it's the right person so we have to

00:04:19,440 --> 00:04:26,070
authenticate the escrow and now we're

00:04:21,720 --> 00:04:27,510
done right No so we also have to

00:04:26,070 --> 00:04:30,270
authenticate client to the escrow

00:04:27,510 --> 00:04:31,800
because we have to guarantee that when

00:04:30,270 --> 00:04:32,970
they were fetch back a key

00:04:31,800 --> 00:04:34,919
that they can't just get any key that

00:04:32,970 --> 00:04:36,210
they want they can only get the keys for

00:04:34,919 --> 00:04:39,240
instance that they push do you know that

00:04:36,210 --> 00:04:42,419
the policy allows them to have so at

00:04:39,240 --> 00:04:44,069
least finally we're done well

00:04:42,419 --> 00:04:45,840
unfortunately we actually need a chain

00:04:44,069 --> 00:04:48,389
of trust in order to do all of these

00:04:45,840 --> 00:04:50,280
authentications and the encryption layer

00:04:48,389 --> 00:04:53,009
this is usually done through a

00:04:50,280 --> 00:04:55,349
certification Authority with the route

00:04:53,009 --> 00:04:57,840
of trust there perhaps many intermediary

00:04:55,349 --> 00:04:59,879
layers or this is done if you're using

00:04:57,840 --> 00:05:02,729
gssapi for instance this is done with a

00:04:59,879 --> 00:05:04,440
with a ktc well at least now we're done

00:05:02,729 --> 00:05:07,560
and we have a very simple architecture

00:05:04,440 --> 00:05:09,270
oh I forgot about backups so now we have

00:05:07,560 --> 00:05:10,680
to back up all of this state right

00:05:09,270 --> 00:05:13,830
because we've got all of these keys

00:05:10,680 --> 00:05:16,740
stored in the escrow and if we were to

00:05:13,830 --> 00:05:18,870
lose that data we are sunk right because

00:05:16,740 --> 00:05:21,110
all of our data is encrypted with with

00:05:18,870 --> 00:05:23,280
these keys so we've got to back up those

00:05:21,110 --> 00:05:25,979
back up all of those keys but we also

00:05:23,280 --> 00:05:28,770
have to back up the entire the entire

00:05:25,979 --> 00:05:30,360
route of trust on the left-hand side as

00:05:28,770 --> 00:05:35,190
well and then of course all of these

00:05:30,360 --> 00:05:37,469
backups have to be secured so at least

00:05:35,190 --> 00:05:39,539
finally we have arrived at the standard

00:05:37,469 --> 00:05:41,520
escrow model and this is pretty much

00:05:39,539 --> 00:05:44,610
what you see tons of vendors or shipping

00:05:41,520 --> 00:05:46,050
products like this and if you've ever

00:05:44,610 --> 00:05:49,560
hacked together some kind of an

00:05:46,050 --> 00:05:51,960
automation for early boot unlocking your

00:05:49,560 --> 00:05:52,560
system most likely looks something like

00:05:51,960 --> 00:05:54,810
this

00:05:52,560 --> 00:05:57,029
and it works really great we don't ever

00:05:54,810 --> 00:05:59,490
have any problems with this system at

00:05:57,029 --> 00:06:02,190
all oh wait

00:05:59,490 --> 00:06:05,610
so I guess heartbleed would kind of

00:06:02,190 --> 00:06:07,680
throw a kink in this we would be able to

00:06:05,610 --> 00:06:11,849
just read all of the keys off the wire

00:06:07,680 --> 00:06:14,550
as they were coming in so we decided we

00:06:11,849 --> 00:06:17,129
want to do something that that's better

00:06:14,550 --> 00:06:19,440
we've learned a few lessons from this

00:06:17,129 --> 00:06:21,300
architecture first we learned that

00:06:19,440 --> 00:06:23,849
presuming that TLS will protect the key

00:06:21,300 --> 00:06:27,060
transfer is dangerous because all it

00:06:23,849 --> 00:06:28,830
takes is a single a single flaw in the

00:06:27,060 --> 00:06:32,190
entirety of TLS which is a pretty large

00:06:28,830 --> 00:06:35,610
specification in order to and a pretty

00:06:32,190 --> 00:06:37,590
large implementation as well any mistake

00:06:35,610 --> 00:06:39,719
there any flaw there can leak our keys

00:06:37,590 --> 00:06:41,909
we also learned that the complexity

00:06:39,719 --> 00:06:42,839
increases our attack surface so when we

00:06:41,909 --> 00:06:44,750
had all of these different entities

00:06:42,839 --> 00:06:47,030
doing these different things

00:06:44,750 --> 00:06:48,590
you realize that of course there's a lot

00:06:47,030 --> 00:06:50,690
of places to attack we can attack the

00:06:48,590 --> 00:06:53,540
backup system we can have attacked the

00:06:50,690 --> 00:06:55,570
the route of trust we can attack the TLS

00:06:53,540 --> 00:06:58,160
channel we can attack the escrow itself

00:06:55,570 --> 00:06:59,660
and because of all of this we've also

00:06:58,160 --> 00:07:02,150
learned that escrows are difficult to

00:06:59,660 --> 00:07:04,250
deploy not only do you just deploy in

00:07:02,150 --> 00:07:06,800
escrow but you deploy everything that

00:07:04,250 --> 00:07:08,540
goes around it finally one of the things

00:07:06,800 --> 00:07:11,360
that we learned actually in user testing

00:07:08,540 --> 00:07:12,740
is that x.509 is really hard to get

00:07:11,360 --> 00:07:14,810
right

00:07:12,740 --> 00:07:16,310
so even if you've done everything

00:07:14,810 --> 00:07:19,580
correctly

00:07:16,310 --> 00:07:22,400
just the x.509 part of it we very often

00:07:19,580 --> 00:07:23,900
gotten a malformed certificates we got

00:07:22,400 --> 00:07:26,150
certificates that were signed in

00:07:23,900 --> 00:07:28,220
properly all sorts of stuff that we've

00:07:26,150 --> 00:07:30,680
seen in the wild and so it's just very

00:07:28,220 --> 00:07:32,780
hard to get right and our very simple

00:07:30,680 --> 00:07:34,130
system of just taking a keys during it

00:07:32,780 --> 00:07:37,669
remotely and fetching it back has

00:07:34,130 --> 00:07:39,410
suddenly become incredibly complex so

00:07:37,669 --> 00:07:42,919
the question that we wanted to ask was

00:07:39,410 --> 00:07:46,520
can asymmetric crypto help us with this

00:07:42,919 --> 00:07:50,180
problem so one of the things we realized

00:07:46,520 --> 00:07:52,370
in this process is that what we are

00:07:50,180 --> 00:07:54,590
actually doing is really a kind of a key

00:07:52,370 --> 00:07:56,990
exchange now I will ask you to brace

00:07:54,590 --> 00:07:59,750
yourself because math is coming on the

00:07:56,990 --> 00:08:02,180
next slide so if you're allergic to math

00:07:59,750 --> 00:08:06,050
please stand up and leave the auditorium

00:08:02,180 --> 00:08:08,330
so this is a standard diffie-hellman key

00:08:06,050 --> 00:08:10,419
exchange is this readable by the way can

00:08:08,330 --> 00:08:13,070
you read it no oh man I'm really sorry

00:08:10,419 --> 00:08:16,729
so this is a standard diffie-hellman key

00:08:13,070 --> 00:08:18,860
exchange which party generates a private

00:08:16,729 --> 00:08:20,720
key uses a private key to calculate a

00:08:18,860 --> 00:08:22,550
public key they exchange their public

00:08:20,720 --> 00:08:25,400
keys and then they can both calculate K

00:08:22,550 --> 00:08:27,140
so is everybody pretty familiar or at

00:08:25,400 --> 00:08:32,570
least has heard about diffie-hellman and

00:08:27,140 --> 00:08:34,849
how it sort of works okay so I don't

00:08:32,570 --> 00:08:37,099
want to go too far okay so we wanted to

00:08:34,849 --> 00:08:39,680
we wondered if we could take ECB H

00:08:37,099 --> 00:08:41,390
elliptic curve diffie-hellman and if we

00:08:39,680 --> 00:08:44,300
could just essentially make our

00:08:41,390 --> 00:08:47,450
unlocking process a key exchange and so

00:08:44,300 --> 00:08:49,310
on the left-hand side you see a diffi

00:08:47,450 --> 00:08:51,290
Hellman but it just sort of rearranged

00:08:49,310 --> 00:08:53,690
nothing on here is mathematically any

00:08:51,290 --> 00:08:55,400
different than diffie-hellman we're just

00:08:53,690 --> 00:08:57,890
doing the steps in a particular order

00:08:55,400 --> 00:08:58,499
okay so nothing on this analyte is

00:08:57,890 --> 00:09:02,549
different from

00:08:58,499 --> 00:09:05,429
phenomena on the left-hand side we have

00:09:02,549 --> 00:09:08,189
the provisioning step the first thing

00:09:05,429 --> 00:09:10,709
that happens is a server generates a

00:09:08,189 --> 00:09:12,659
private key uses the private key to

00:09:10,709 --> 00:09:16,019
calculate a public key and then shares

00:09:12,659 --> 00:09:17,519
that key to whomever would ask for it so

00:09:16,019 --> 00:09:19,139
now you can get as the client you can

00:09:17,519 --> 00:09:20,909
get the public key you can either get it

00:09:19,139 --> 00:09:23,699
by contacting the server you can get it

00:09:20,909 --> 00:09:25,139
by passing it offline somehow but the

00:09:23,699 --> 00:09:28,349
client is able to get the server's

00:09:25,139 --> 00:09:30,149
public key now the client does it it's a

00:09:28,349 --> 00:09:31,679
bit when it wants to encrypt the data so

00:09:30,149 --> 00:09:35,639
all the provisioning is the is the

00:09:31,679 --> 00:09:38,879
encryption side so the client then

00:09:35,639 --> 00:09:40,739
generates its own private key generates

00:09:38,879 --> 00:09:43,109
a public uses the private key to

00:09:40,739 --> 00:09:47,009
calculate a public key performs the

00:09:43,109 --> 00:09:50,119
diffie-hellman exchange and gets k.k is

00:09:47,009 --> 00:09:53,189
the key that's then used for encryption

00:09:50,119 --> 00:09:56,879
once encryption is done we then discard

00:09:53,189 --> 00:09:59,999
kay and we also discard the clients

00:09:56,879 --> 00:10:02,429
private key and what this means is that

00:09:59,999 --> 00:10:05,209
the client can no longer calculate K it

00:10:02,429 --> 00:10:08,429
doesn't have K and it can't calculate it

00:10:05,209 --> 00:10:12,269
we do have a retain the public keys s

00:10:08,429 --> 00:10:16,169
and C s is the server's public key and C

00:10:12,269 --> 00:10:18,029
is the clients club public key and then

00:10:16,169 --> 00:10:20,609
when we want to do our decryption we can

00:10:18,029 --> 00:10:23,249
take our public key and we can send it

00:10:20,609 --> 00:10:24,959
to the server the server does its half

00:10:23,249 --> 00:10:27,569
of the diffie-hellman and calculates K

00:10:24,959 --> 00:10:29,369
and sends K back to us now this is

00:10:27,569 --> 00:10:31,769
fantastic because this is a lot lighter

00:10:29,369 --> 00:10:34,259
than what we saw on the escrow model and

00:10:31,769 --> 00:10:35,159
in fact the server notice has no state

00:10:34,259 --> 00:10:39,649
whatsoever

00:10:35,159 --> 00:10:41,759
the server is just a key that's all

00:10:39,649 --> 00:10:45,929
unfortunately this mode is completely

00:10:41,759 --> 00:10:48,720
insecure because if you share key on the

00:10:45,929 --> 00:10:51,779
network if you share key C excuse me the

00:10:48,720 --> 00:10:54,149
clients public key on the network then

00:10:51,779 --> 00:10:56,069
anyone can take that key and can

00:10:54,149 --> 00:11:00,419
calculate K by asking the server to do

00:10:56,069 --> 00:11:01,919
it similarly the BK the key that we

00:11:00,419 --> 00:11:03,839
actually want to protect is now coming

00:11:01,919 --> 00:11:07,139
back over the network in plaintext and

00:11:03,839 --> 00:11:09,419
of course we don't like that either so

00:11:07,139 --> 00:11:11,339
we have some weaknesses K is revealed to

00:11:09,419 --> 00:11:13,740
any passive attackers

00:11:11,339 --> 00:11:16,199
with C so if they store sieve and they

00:11:13,740 --> 00:11:19,860
can later do a replay and they can get

00:11:16,199 --> 00:11:24,240
back K and third the server learns both

00:11:19,860 --> 00:11:25,649
C and therefore okay and what we want to

00:11:24,240 --> 00:11:28,860
do is we want to actually create a

00:11:25,649 --> 00:11:31,589
system now where see the clients public

00:11:28,860 --> 00:11:34,709
key is no longer a public key

00:11:31,589 --> 00:11:37,709
it is a private key and we can actually

00:11:34,709 --> 00:11:39,930
do this with an algorithm a very slight

00:11:37,709 --> 00:11:41,819
modification to this algorithm that was

00:11:39,930 --> 00:11:45,329
invented by myself and Bob Riley at Red

00:11:41,819 --> 00:11:46,920
Hat and the way that this works if I'm

00:11:45,329 --> 00:11:48,870
gonna flip back and forth so you can see

00:11:46,920 --> 00:11:52,410
on the left side provisioning notice

00:11:48,870 --> 00:11:53,699
that nothing changes okay so on the

00:11:52,410 --> 00:11:55,860
provisioning side we're just doing

00:11:53,699 --> 00:12:00,209
difficult in the only changes are on the

00:11:55,860 --> 00:12:02,610
right-hand side so it's exactly the same

00:12:00,209 --> 00:12:04,170
as it was before the client calculates

00:12:02,610 --> 00:12:07,920
kay with the diffie-hellman encrypts

00:12:04,170 --> 00:12:10,259
data with K and it throws away K and C

00:12:07,920 --> 00:12:14,579
so it can't calculate 2k anymore on its

00:12:10,259 --> 00:12:17,220
own but it retains essence C and then

00:12:14,579 --> 00:12:20,160
when we want to do a decryption the

00:12:17,220 --> 00:12:21,990
client generates a new key pair this is

00:12:20,160 --> 00:12:24,660
an ephemeral key pair and it's generated

00:12:21,990 --> 00:12:26,879
every single time the client wants to do

00:12:24,660 --> 00:12:28,829
decryption so it doesn't happen an

00:12:26,879 --> 00:12:30,420
encryption time it happens at decryption

00:12:28,829 --> 00:12:33,120
time the client generates a new key pair

00:12:30,420 --> 00:12:38,129
so we have a private key and a public

00:12:33,120 --> 00:12:41,639
key e we add these the key C and the key

00:12:38,129 --> 00:12:44,220
E together we send the results which

00:12:41,639 --> 00:12:45,629
we've called X here to the server the

00:12:44,220 --> 00:12:48,350
server performs its side of the

00:12:45,629 --> 00:12:52,610
diffie-hellman sends back the result and

00:12:48,350 --> 00:12:55,170
then we are able to subtract out the

00:12:52,610 --> 00:12:57,209
ephemeral key essentially from this

00:12:55,170 --> 00:12:58,679
calculation and there's very some very

00:12:57,209 --> 00:13:00,600
simple math down here you can go online

00:12:58,679 --> 00:13:02,449
by the way and see these slides later if

00:13:00,600 --> 00:13:05,879
you want to look at the math closely and

00:13:02,449 --> 00:13:09,809
the end results of course is that C is

00:13:05,879 --> 00:13:11,790
now private because E is private so the

00:13:09,809 --> 00:13:13,889
server gets something that just looks

00:13:11,790 --> 00:13:15,179
like a random public key every time it

00:13:13,889 --> 00:13:17,279
wants to perform its side of the

00:13:15,179 --> 00:13:20,040
diffie-hellman it has no identifying

00:13:17,279 --> 00:13:21,569
information about the client at all the

00:13:20,040 --> 00:13:23,759
server performs its very simple

00:13:21,569 --> 00:13:25,170
operation and returns the results and

00:13:23,759 --> 00:13:27,260
since the results

00:13:25,170 --> 00:13:30,779
as the ephemeral keys still mixed in

00:13:27,260 --> 00:13:32,310
nobody on the wire can replay this or

00:13:30,779 --> 00:13:33,810
rather they can replay it but they can't

00:13:32,310 --> 00:13:38,010
ever get K out because they don't have

00:13:33,810 --> 00:13:39,600
the ephemeral key so in order to work

00:13:38,010 --> 00:13:41,639
one thing that's important to note is

00:13:39,600 --> 00:13:44,790
that in order to keep C private then

00:13:41,639 --> 00:13:49,649
both the public and private ephemeral

00:13:44,790 --> 00:13:51,750
Keys must be private as well so the end

00:13:49,649 --> 00:13:53,699
result of this is a system where instead

00:13:51,750 --> 00:13:57,029
of having an escrow instead of storing

00:13:53,699 --> 00:14:00,000
data in a remote server we just simply

00:13:57,029 --> 00:14:01,949
generate a key during our encryption we

00:14:00,000 --> 00:14:04,290
generate a second a second key during

00:14:01,949 --> 00:14:05,850
our decryption step mix them together

00:14:04,290 --> 00:14:08,310
send them to the server and get back

00:14:05,850 --> 00:14:11,279
result and the result of this is

00:14:08,310 --> 00:14:13,050
remarkably fast so if you think about a

00:14:11,279 --> 00:14:15,959
TLS connection the very first thing that

00:14:13,050 --> 00:14:17,490
TLS does is it negotiates what group it

00:14:15,959 --> 00:14:19,709
wants to use then the very second thing

00:14:17,490 --> 00:14:22,980
it does is that it does a difficult and

00:14:19,709 --> 00:14:25,230
right this is as light as just the

00:14:22,980 --> 00:14:26,550
diffie-hellman exchange in TLS no

00:14:25,230 --> 00:14:28,230
encryption is needed over the wire

00:14:26,550 --> 00:14:31,050
because it's just simply a public key

00:14:28,230 --> 00:14:32,550
exchange and no state is required on the

00:14:31,050 --> 00:14:34,769
server so we don't have to do fancy

00:14:32,550 --> 00:14:36,890
backups and all kinds of stuff there is

00:14:34,769 --> 00:14:39,810
one other alternate way to deploy this

00:14:36,890 --> 00:14:42,810
which is that you can actually stick the

00:14:39,810 --> 00:14:45,269
server's key inside crypto hardware so

00:14:42,810 --> 00:14:48,300
you can burn it into a TPM you can put

00:14:45,269 --> 00:14:50,490
it in an HSM the server does not have to

00:14:48,300 --> 00:14:52,529
have any access to the material at all

00:14:50,490 --> 00:14:55,560
and and specifically if you're storing

00:14:52,529 --> 00:14:58,320
the key in crypto Hardware as a backing

00:14:55,560 --> 00:15:01,050
to the server then I compromise of the

00:14:58,320 --> 00:15:03,360
server only leads to temporary access of

00:15:01,050 --> 00:15:04,920
the keys but not permanent access of the

00:15:03,360 --> 00:15:06,899
keys right so they never learn what the

00:15:04,920 --> 00:15:09,029
private key is the private key is always

00:15:06,899 --> 00:15:10,949
stored in hardware an attacker who

00:15:09,029 --> 00:15:12,449
compromises the server can only just

00:15:10,949 --> 00:15:15,589
kind of use it temporarily for a little

00:15:12,449 --> 00:15:15,589
while and then you kick them out again

00:15:15,740 --> 00:15:22,589
so if we compared these two systems

00:15:18,390 --> 00:15:24,389
on the left-hand side we have our the

00:15:22,589 --> 00:15:26,310
property we're talking about then we

00:15:24,389 --> 00:15:28,560
have the escrow and then we have the

00:15:26,310 --> 00:15:30,209
McCullum value exchange so when using an

00:15:28,560 --> 00:15:31,709
escrow server presence during

00:15:30,209 --> 00:15:33,089
provisioning is required because you

00:15:31,709 --> 00:15:35,819
actually have to have network access to

00:15:33,089 --> 00:15:37,050
push the key into the server on the

00:15:35,819 --> 00:15:38,790
other hand with

00:15:37,050 --> 00:15:41,010
kaalia exchange it's actually optional

00:15:38,790 --> 00:15:44,040
as long as you have that public key

00:15:41,010 --> 00:15:45,720
offline somehow you can do the full

00:15:44,040 --> 00:15:49,080
provisioning full encryption entirely

00:15:45,720 --> 00:15:50,610
offline and then only the only the

00:15:49,080 --> 00:15:52,230
server is only required when you want to

00:15:50,610 --> 00:15:55,050
do decryption so during the recovery

00:15:52,230 --> 00:15:57,089
step so that's the same for both the

00:15:55,050 --> 00:15:59,279
escrow and for the Mon Calamari exchange

00:15:57,089 --> 00:16:01,200
which is exactly what we want we want

00:15:59,279 --> 00:16:05,149
the data to only be automatically

00:16:01,200 --> 00:16:08,279
decrypted when the server is available

00:16:05,149 --> 00:16:10,260
the escrow however also has to have

00:16:08,279 --> 00:16:12,390
knowledge of all of the keys and so it

00:16:10,260 --> 00:16:13,800
becomes a central point of attack in the

00:16:12,390 --> 00:16:16,740
Macomb raelia exchange the server

00:16:13,800 --> 00:16:19,320
doesn't know any keys and is not really

00:16:16,740 --> 00:16:23,550
a it's not really a desirable place to

00:16:19,320 --> 00:16:25,110
attack similar with key transfer that's

00:16:23,550 --> 00:16:27,000
required in an escrow because we have to

00:16:25,110 --> 00:16:29,130
actually send the key over the wire to

00:16:27,000 --> 00:16:30,600
the remote and then get it back but with

00:16:29,130 --> 00:16:33,390
the Macomb really exchange there's no

00:16:30,600 --> 00:16:35,279
transfer of keys other than public keys

00:16:33,390 --> 00:16:37,920
so the only thing that's on the network

00:16:35,279 --> 00:16:42,180
is public key data which a passive

00:16:37,920 --> 00:16:44,070
attacker cannot get when you have an

00:16:42,180 --> 00:16:46,079
escrow you also require client

00:16:44,070 --> 00:16:48,540
authentication which is not required in

00:16:46,079 --> 00:16:50,640
the McCullum relay exchange we require

00:16:48,540 --> 00:16:52,230
transport encryption for transport

00:16:50,640 --> 00:16:54,270
encryption for the escrow but not for

00:16:52,230 --> 00:16:56,670
the McCallum relay exchange and then

00:16:54,270 --> 00:16:58,380
finally end-to-end encryption which is

00:16:56,670 --> 00:16:59,880
another whole set of problems we didn't

00:16:58,380 --> 00:17:01,620
talk about earlier with in escrow as

00:16:59,880 --> 00:17:03,870
well it is very difficult to implement

00:17:01,620 --> 00:17:05,910
on the other hand for McCullough

00:17:03,870 --> 00:17:09,540
exchange it's just not needed at all you

00:17:05,910 --> 00:17:10,949
do not need end to end encryption so

00:17:09,540 --> 00:17:12,510
there's a there's a server that

00:17:10,949 --> 00:17:16,350
implements this the servers called Tang

00:17:12,510 --> 00:17:20,250
and it's available github.com / latch

00:17:16,350 --> 00:17:23,400
set / Tang it's a small server-side

00:17:20,250 --> 00:17:25,260
demon it's very simple just HTTP and

00:17:23,400 --> 00:17:28,230
Jose which we'll talk about in a minute

00:17:25,260 --> 00:17:31,710
and it's very very fast we can do about

00:17:28,230 --> 00:17:34,470
2,000 requests a second on medium

00:17:31,710 --> 00:17:35,850
hardware and that's without any attempts

00:17:34,470 --> 00:17:39,630
to scale it up that's just single

00:17:35,850 --> 00:17:42,540
threaded etc so it's extremely small

00:17:39,630 --> 00:17:44,610
minimal dependencies and it's available

00:17:42,540 --> 00:17:46,260
on Fedora 23 and later

00:17:44,610 --> 00:17:47,049
and of course it's open source so you

00:17:46,260 --> 00:17:48,970
know been done

00:17:47,049 --> 00:17:52,239
ever distro and we're happy to happy to

00:17:48,970 --> 00:17:54,309
help you so installing a tank server is

00:17:52,239 --> 00:17:58,269
relatively easy at least on Fedora for

00:17:54,309 --> 00:18:01,360
right now DNF install Tang that gets you

00:17:58,269 --> 00:18:04,720
the server and then use system D to

00:18:01,360 --> 00:18:07,600
enable two unit files and then generate

00:18:04,720 --> 00:18:09,309
two keys and you're off to the races now

00:18:07,600 --> 00:18:10,929
you may want to scale this up put it

00:18:09,309 --> 00:18:12,309
behind Apache you may want to think

00:18:10,929 --> 00:18:13,509
about your deployment models so there

00:18:12,309 --> 00:18:15,789
are definitely some more complex

00:18:13,509 --> 00:18:18,159
scenarios but if you want to get up and

00:18:15,789 --> 00:18:21,749
running very quickly for testing it's

00:18:18,159 --> 00:18:21,749
just simply these five commandments

00:18:22,769 --> 00:18:27,730
we've only been talking about the server

00:18:25,029 --> 00:18:29,529
up into this point and we have not been

00:18:27,730 --> 00:18:32,350
talking about the client but we need to

00:18:29,529 --> 00:18:33,970
talk about the client as well so we have

00:18:32,350 --> 00:18:36,970
an application called clevis on the

00:18:33,970 --> 00:18:39,460
client so it's also available github.com

00:18:36,970 --> 00:18:42,580
forward slash latch set forward slash

00:18:39,460 --> 00:18:44,859
clevis this is a decryption automation

00:18:42,580 --> 00:18:46,149
and policy framework it has minimal

00:18:44,859 --> 00:18:48,129
dependencies as well

00:18:46,149 --> 00:18:50,259
it has early boot integration and gnome

00:18:48,129 --> 00:18:54,549
integration and it's available in 24 or

00:18:50,259 --> 00:18:58,080
24 and later and here's an example of

00:18:54,549 --> 00:19:00,970
doing some encryption with cleveson tang

00:18:58,080 --> 00:19:03,429
so DNF installed clevis gets you the

00:19:00,970 --> 00:19:05,499
clevis application you can just echo

00:19:03,429 --> 00:19:07,480
some plaintext into the clevis encrypt

00:19:05,499 --> 00:19:10,149
command you specify you want tang as

00:19:07,480 --> 00:19:11,830
you're backing policy and then you give

00:19:10,149 --> 00:19:13,509
it a configuration which is just a

00:19:11,830 --> 00:19:16,720
little JSON object right now containing

00:19:13,509 --> 00:19:19,090
just the URL of the server and you get a

00:19:16,720 --> 00:19:21,850
in this case since we did not pass in if

00:19:19,090 --> 00:19:23,499
the public key if fetch is the public

00:19:21,850 --> 00:19:25,539
key from the server and asks you if you

00:19:23,499 --> 00:19:29,799
want to trust it similar to what ssh

00:19:25,539 --> 00:19:31,779
would do finally we can if we cat the

00:19:29,799 --> 00:19:33,639
output data we actually see that it's

00:19:31,779 --> 00:19:37,269
Jason web encryption so this is a

00:19:33,639 --> 00:19:39,580
standard data format and when we want to

00:19:37,269 --> 00:19:42,249
do decrypt we just simply pass that same

00:19:39,580 --> 00:19:44,470
blob back in to the decrypt command then

00:19:42,249 --> 00:19:46,179
out comes our plaintext notice that I

00:19:44,470 --> 00:19:48,940
did not actually type anything in

00:19:46,179 --> 00:19:51,549
because the decryption was automatic now

00:19:48,940 --> 00:19:53,499
if I stop Tang and trying to do the

00:19:51,549 --> 00:19:57,809
decryption step again then we actually

00:19:53,499 --> 00:19:57,809
get failure and no plaintext comes out

00:19:58,460 --> 00:20:04,910
however clevis does not use only just

00:20:02,070 --> 00:20:07,590
tang because as I said it is a pluggable

00:20:04,910 --> 00:20:10,440
automated policy framework for

00:20:07,590 --> 00:20:12,870
decryption so so we can actually do it

00:20:10,440 --> 00:20:17,190
with an escrow as well in this case we

00:20:12,870 --> 00:20:18,510
are using the custodial API so if you

00:20:17,190 --> 00:20:19,920
don't know about custodia that's also

00:20:18,510 --> 00:20:22,860
interesting you can google it

00:20:19,920 --> 00:20:26,370
it's a essentially a secrets as a

00:20:22,860 --> 00:20:28,920
service API so in this case we are

00:20:26,370 --> 00:20:31,560
encrypting the same data we are pushing

00:20:28,920 --> 00:20:34,650
a key into the escrow pulling a key back

00:20:31,560 --> 00:20:36,030
out of the escrow for decryption and if

00:20:34,650 --> 00:20:37,740
the server is not available then we

00:20:36,030 --> 00:20:40,800
can't decrypt but this does have the

00:20:37,740 --> 00:20:42,060
same downsides as the SQL model but a

00:20:40,800 --> 00:20:43,830
lot of people already have an existing

00:20:42,060 --> 00:20:47,430
escrow and they may want to migrate from

00:20:43,830 --> 00:20:50,160
it or they may have specific cases where

00:20:47,430 --> 00:20:51,390
they actually need to run in escrow so

00:20:50,160 --> 00:20:54,570
then there's actually just another

00:20:51,390 --> 00:20:55,860
simple command to bind delux disk so if

00:20:54,570 --> 00:20:58,620
you have a block device that's encrypted

00:20:55,860 --> 00:21:00,090
with Lux this basically should look

00:20:58,620 --> 00:21:02,190
exactly the same as what we saw in the

00:21:00,090 --> 00:21:05,190
previous slides the only difference is

00:21:02,190 --> 00:21:08,070
that now we're passing a device the

00:21:05,190 --> 00:21:10,590
block device itself to the clevis bind

00:21:08,070 --> 00:21:12,450
Lux command we fetch the public key from

00:21:10,590 --> 00:21:14,730
the server we say yes we want to trust

00:21:12,450 --> 00:21:16,740
it then we enter one of the Lux keys and

00:21:14,730 --> 00:21:17,960
then internally what happens is we

00:21:16,740 --> 00:21:20,460
generate a cryptographically strong

00:21:17,960 --> 00:21:22,830
random key that's the same size as the

00:21:20,460 --> 00:21:26,250
master key so we don't lose any any

00:21:22,830 --> 00:21:28,770
security properties and then and then we

00:21:26,250 --> 00:21:31,860
encrypted that key using clevis and then

00:21:28,770 --> 00:21:33,750
at boot time when we want to recover

00:21:31,860 --> 00:21:35,430
that they unlock that disk automatically

00:21:33,750 --> 00:21:38,130
we just simply decrypt the key pass it

00:21:35,430 --> 00:21:40,500
to Lux and we're off to the races so

00:21:38,130 --> 00:21:43,020
there's a middle command in here Lux

00:21:40,500 --> 00:21:45,120
meta show which actually will show us

00:21:43,020 --> 00:21:47,570
all of our luck slots and the metadata

00:21:45,120 --> 00:21:50,010
that we've stored in the Lux header

00:21:47,570 --> 00:21:52,950
related to this so this is a related

00:21:50,010 --> 00:21:54,990
project we'll talk about in a minute

00:21:52,950 --> 00:21:57,960
so for root volume unlocking you just

00:21:54,990 --> 00:21:59,670
install clevis - Drake it and then run

00:21:57,960 --> 00:22:01,620
and Drake it - F to rebuild your in a

00:21:59,670 --> 00:22:02,970
tram FS and then we boot you only have

00:22:01,620 --> 00:22:06,300
to do that once because we need to get

00:22:02,970 --> 00:22:07,710
our code inside the init Ram FS and we

00:22:06,300 --> 00:22:09,280
were actually talking about having that

00:22:07,710 --> 00:22:10,450
by default

00:22:09,280 --> 00:22:13,480
that you don't even have to do that step

00:22:10,450 --> 00:22:15,940
it'll be in the default in a ram FS and

00:22:13,480 --> 00:22:18,040
then for removable storage like USB keys

00:22:15,940 --> 00:22:19,870
where you would want to say have a gnome

00:22:18,040 --> 00:22:22,180
desktop and plug in your USB key and

00:22:19,870 --> 00:22:25,510
have it automatically unlocked we have

00:22:22,180 --> 00:22:26,680
the clevis - you discs - package which

00:22:25,510 --> 00:22:28,000
you can just install no other

00:22:26,680 --> 00:22:30,070
configuration is needed

00:22:28,000 --> 00:22:31,420
you just insert your drive and then it

00:22:30,070 --> 00:22:37,480
unlocks as long as the server's

00:22:31,420 --> 00:22:39,660
available however we've only covered up

00:22:37,480 --> 00:22:41,950
up into automation up until this point

00:22:39,660 --> 00:22:44,590
we still haven't actually talked about

00:22:41,950 --> 00:22:47,410
policy and policy is where things get

00:22:44,590 --> 00:22:50,590
very interesting with clevis so we

00:22:47,410 --> 00:22:54,490
actually have a plugin which we call a

00:22:50,590 --> 00:22:56,770
pin and this is the Shamir secret

00:22:54,490 --> 00:22:58,600
sharing pin and this actually allows us

00:22:56,770 --> 00:23:00,250
to take a key divide it up into a

00:22:58,600 --> 00:23:02,080
variety of keys and then have a

00:23:00,250 --> 00:23:05,410
threshold to recover it so in this case

00:23:02,080 --> 00:23:07,240
we take our master key we divided it up

00:23:05,410 --> 00:23:09,850
we divide it up into five keys and then

00:23:07,240 --> 00:23:11,410
we have a threshold maybe two and as

00:23:09,850 --> 00:23:15,640
long as we have two of those fragments

00:23:11,410 --> 00:23:18,580
we can unlock the data Shamir's can also

00:23:15,640 --> 00:23:20,770
be nested as well so you'll very quickly

00:23:18,580 --> 00:23:23,290
notice that we can actually use Shamir's

00:23:20,770 --> 00:23:26,140
to create a hierarchical unlocking

00:23:23,290 --> 00:23:29,380
policy so let's look at how this might

00:23:26,140 --> 00:23:33,210
work in practice on the case of a simple

00:23:29,380 --> 00:23:35,410
laptop you may want to encrypt your disk

00:23:33,210 --> 00:23:37,720
using extreme ears with two passwords

00:23:35,410 --> 00:23:39,970
one for the administrator of the laptop

00:23:37,720 --> 00:23:42,010
and one for the user of the laptop with

00:23:39,970 --> 00:23:49,570
a threshold of one and in this case

00:23:42,010 --> 00:23:51,280
either password will unlock the disk now

00:23:49,570 --> 00:23:52,750
we want to have an automated laptop so

00:23:51,280 --> 00:23:54,610
we've kept the threshold the same we've

00:23:52,750 --> 00:23:56,200
added an additional branch now we're

00:23:54,610 --> 00:23:57,460
talking to the tank server so as long as

00:23:56,200 --> 00:23:59,380
you can get to the tank server it'll

00:23:57,460 --> 00:24:01,300
unlock automatically but if you're out

00:23:59,380 --> 00:24:03,580
at the coffee shop and you can't get to

00:24:01,300 --> 00:24:05,140
the tank shirt server then you'll have

00:24:03,580 --> 00:24:07,020
to take your user password but the

00:24:05,140 --> 00:24:09,520
administrator still has a password that

00:24:07,020 --> 00:24:11,320
they can use to unlock the system and

00:24:09,520 --> 00:24:13,870
now everything we've talked about up

00:24:11,320 --> 00:24:16,870
into this point is doable today with lux

00:24:13,870 --> 00:24:20,050
but we're about to talk about stuff we

00:24:16,870 --> 00:24:22,600
can't deal with Lux so for example let's

00:24:20,050 --> 00:24:23,380
say we have a high-security system and

00:24:22,600 --> 00:24:25,060
in this high

00:24:23,380 --> 00:24:26,380
security system we want to create a

00:24:25,060 --> 00:24:29,260
bunch of passwords in this example

00:24:26,380 --> 00:24:32,110
there's three and we want to require two

00:24:29,260 --> 00:24:36,100
of them in order to unlock the volume so

00:24:32,110 --> 00:24:37,150
this would be the sort of you know case

00:24:36,100 --> 00:24:38,680
where you have something that would be

00:24:37,150 --> 00:24:40,150
very very dangerous and you want

00:24:38,680 --> 00:24:41,920
multiple people to authenticate before

00:24:40,150 --> 00:24:43,600
you can get to it you can't do this

00:24:41,920 --> 00:24:45,520
today with Lux but you can with Clavis

00:24:43,600 --> 00:24:46,570
well not today but very soon in the

00:24:45,520 --> 00:24:50,350
future you'll be able to do this with

00:24:46,570 --> 00:24:54,610
clevis so here's an example of a complex

00:24:50,350 --> 00:24:56,620
laptop policy this is we have the

00:24:54,610 --> 00:24:59,860
administrator who has created a master

00:24:56,620 --> 00:25:02,260
code and printed it on a QR code and

00:24:59,860 --> 00:25:04,450
they lock it in a safe and in the

00:25:02,260 --> 00:25:06,130
biggest disaster case that can extract

00:25:04,450 --> 00:25:08,290
the laptop out of the hard drive out of

00:25:06,130 --> 00:25:10,390
the laptop you can plug it into some

00:25:08,290 --> 00:25:12,790
tool that they have and they can use the

00:25:10,390 --> 00:25:15,040
QR codes get it back in to recover the

00:25:12,790 --> 00:25:19,030
data so that's the that's the master

00:25:15,040 --> 00:25:22,270
recovery scheme but now we go down to a

00:25:19,030 --> 00:25:25,720
second branch and this branch further

00:25:22,270 --> 00:25:28,150
does Shamir's with threshold of two in

00:25:25,720 --> 00:25:31,570
this case it means that both of our

00:25:28,150 --> 00:25:34,300
branches are required so we have two

00:25:31,570 --> 00:25:37,840
branches one is TPM and one is Shamir

00:25:34,300 --> 00:25:39,700
secret sharing so this means that if

00:25:37,840 --> 00:25:41,860
you're not using the QR code that's

00:25:39,700 --> 00:25:44,500
locked in the safe the only way to

00:25:41,860 --> 00:25:46,900
unlock this system is that it must be in

00:25:44,500 --> 00:25:50,290
the chassis to be able to talk to the

00:25:46,900 --> 00:25:53,890
TPM and then we if that's the case then

00:25:50,290 --> 00:25:56,200
we finally go to our last branch where

00:25:53,890 --> 00:25:57,910
we have a threshold of two and here we

00:25:56,200 --> 00:26:00,070
have for authentication methods we have

00:25:57,910 --> 00:26:02,290
password we have Yubikey we have Tang we

00:26:00,070 --> 00:26:03,490
have Bluetooth by the way Bluetooth here

00:26:02,290 --> 00:26:05,230
is actually would just be the Tang

00:26:03,490 --> 00:26:07,960
protocol the McCallum relay exchange

00:26:05,230 --> 00:26:09,100
over Bluetooth which we're working on so

00:26:07,960 --> 00:26:11,830
in this case you've got a Bluetooth

00:26:09,100 --> 00:26:13,210
beacon sitting by your desk and you're

00:26:11,830 --> 00:26:15,040
on the corporate network so you have

00:26:13,210 --> 00:26:17,260
Tang available to you you turn on your

00:26:15,040 --> 00:26:19,600
laptop it goes completely automatically

00:26:17,260 --> 00:26:22,600
without any user intervention at all on

00:26:19,600 --> 00:26:24,070
the other hand let's say you go to visit

00:26:22,600 --> 00:26:26,230
your friend at another floor of your

00:26:24,070 --> 00:26:27,580
building and you're still on the

00:26:26,230 --> 00:26:30,490
corporate network but you're not near

00:26:27,580 --> 00:26:31,630
your desk well in this case you'll still

00:26:30,490 --> 00:26:32,650
be able to get to the tank server but

00:26:31,630 --> 00:26:35,050
you won't be able to get to the

00:26:32,650 --> 00:26:36,610
Bluetooth so we'll have to do one of the

00:26:35,050 --> 00:26:36,850
other options either you can press the

00:26:36,610 --> 00:26:39,550
butt

00:26:36,850 --> 00:26:42,160
Yubikey or you can type in a password to

00:26:39,550 --> 00:26:43,810
get in now let's say that you actually

00:26:42,160 --> 00:26:45,430
take your laptop down to the coffee shop

00:26:43,810 --> 00:26:47,920
because you like coffee and you don't

00:26:45,430 --> 00:26:49,480
want to be in the office so you're down

00:26:47,920 --> 00:26:51,520
in the coffee shop you open up your

00:26:49,480 --> 00:26:52,480
laptop it turns on now you're not near

00:26:51,520 --> 00:26:53,590
your desk so you don't have the

00:26:52,480 --> 00:26:55,030
Bluetooth you're not on the corporate

00:26:53,590 --> 00:26:58,840
network so you don't have access to Tang

00:26:55,030 --> 00:27:01,210
in this case you have to enter both your

00:26:58,840 --> 00:27:04,120
password and press your EB key in order

00:27:01,210 --> 00:27:05,980
to get access to your desk right and the

00:27:04,120 --> 00:27:07,750
important thing here is that I as a

00:27:05,980 --> 00:27:10,600
software developer did not choose this

00:27:07,750 --> 00:27:16,330
policy for you you got to choose what

00:27:10,600 --> 00:27:18,610
the best policy was for your scenario so

00:27:16,330 --> 00:27:20,740
here's an example of just a basic

00:27:18,610 --> 00:27:22,660
Shamir's with tang in this case we're

00:27:20,740 --> 00:27:26,080
using it to provide high availability to

00:27:22,660 --> 00:27:28,060
two different Tang servers so we use

00:27:26,080 --> 00:27:30,700
Shamir's we say that two pins we want

00:27:28,060 --> 00:27:32,260
are both Tang and we specify their

00:27:30,700 --> 00:27:35,620
configurations there there's a threshold

00:27:32,260 --> 00:27:36,910
of one we in this case we trust two

00:27:35,620 --> 00:27:38,680
advertisements because we're actually

00:27:36,910 --> 00:27:41,950
talking to two different Tang servers

00:27:38,680 --> 00:27:45,040
with two different public keys and we

00:27:41,950 --> 00:27:48,220
can decrypt the data automatically we

00:27:45,040 --> 00:27:49,930
can stop one of those servers and still

00:27:48,220 --> 00:27:51,670
decrypt our data but as soon as we stop

00:27:49,930 --> 00:27:57,280
the second server we are unable to

00:27:51,670 --> 00:28:02,440
decrypt the data so let's explore the

00:27:57,280 --> 00:28:04,110
ecosystem a bit one of the dependencies

00:28:02,440 --> 00:28:08,740
that we have is a project called Jose

00:28:04,110 --> 00:28:12,070
I'm actually giving a talk at on Jose in

00:28:08,740 --> 00:28:13,450
the security track in like an hour or so

00:28:12,070 --> 00:28:15,760
so if you're interested in learning more

00:28:13,450 --> 00:28:18,940
about Jose come to that talk

00:28:15,760 --> 00:28:22,090
Jose stands for adjacent objects signing

00:28:18,940 --> 00:28:23,350
an encryption which is a set of rfcs so

00:28:22,090 --> 00:28:25,960
this is actually a standard data format

00:28:23,350 --> 00:28:27,910
and it's a sea library and a

00:28:25,960 --> 00:28:29,530
command-line utility for doing all of

00:28:27,910 --> 00:28:33,490
the encryption and signing and key

00:28:29,530 --> 00:28:34,660
generation for that data type and the

00:28:33,490 --> 00:28:36,580
bottom line is that it's just user

00:28:34,660 --> 00:28:38,740
friendly standards compliant crypto and

00:28:36,580 --> 00:28:40,990
in our case we wanted to use this

00:28:38,740 --> 00:28:46,150
because our protocol was over HTTP and

00:28:40,990 --> 00:28:47,710
what's better than Jason plus HTTP we

00:28:46,150 --> 00:28:49,210
also have another dependency called lux

00:28:47,710 --> 00:28:50,280
meta which is something we wrote as part

00:28:49,210 --> 00:28:54,690
of this

00:28:50,280 --> 00:28:57,720
Lux Mehta is a utility to store metadata

00:28:54,690 --> 00:28:59,970
in the lux version one header gap and so

00:28:57,720 --> 00:29:02,610
the background of the story is that we

00:28:59,970 --> 00:29:05,370
wanted to support automatic unlocking of

00:29:02,610 --> 00:29:07,710
Lux one but there was no place to store

00:29:05,370 --> 00:29:11,040
the metadata that we needed to actually

00:29:07,710 --> 00:29:13,530
do this to do this restoration and so

00:29:11,040 --> 00:29:15,870
there was actually a gap between the end

00:29:13,530 --> 00:29:18,270
of the Lux header and the start of the

00:29:15,870 --> 00:29:20,070
encrypted data and so we wrote this

00:29:18,270 --> 00:29:23,010
utility called Lux meta that commandeer

00:29:20,070 --> 00:29:26,070
is that area and is we stick metadata in

00:29:23,010 --> 00:29:28,170
there and this we don't do any parsing

00:29:26,070 --> 00:29:30,420
of the lux header ourselves everything

00:29:28,170 --> 00:29:33,480
is offloaded to the upstream Lib crypt

00:29:30,420 --> 00:29:35,160
setup utility so so there shouldn't be

00:29:33,480 --> 00:29:38,520
any problems with this and upstream is

00:29:35,160 --> 00:29:40,440
aware of this program and so you can

00:29:38,520 --> 00:29:43,290
actually see an example of use of using

00:29:40,440 --> 00:29:46,680
this here we want to store the metadata

00:29:43,290 --> 00:29:49,440
high in a slot with a given UUID

00:29:46,680 --> 00:29:51,390
and then we load it back and then if we

00:29:49,440 --> 00:29:52,800
try to load a different UUID from that

00:29:51,390 --> 00:29:55,530
slot we get an error because that's not

00:29:52,800 --> 00:29:58,350
the type of data in that slot so fairly

00:29:55,530 --> 00:30:00,270
straightforward fairly simple and this

00:29:58,350 --> 00:30:05,370
is where we actually store the encrypted

00:30:00,270 --> 00:30:08,820
data that comes out of clevis in the

00:30:05,370 --> 00:30:12,060
near future these are things that are

00:30:08,820 --> 00:30:14,100
pretty high on our to-do list so for the

00:30:12,060 --> 00:30:16,800
jos project we want to add pkcs 11

00:30:14,100 --> 00:30:18,150
support this will actually allow us to

00:30:16,800 --> 00:30:20,040
do all of the stuff that we've already

00:30:18,150 --> 00:30:21,870
talked about but using actual crypto

00:30:20,040 --> 00:30:23,700
hardware so you can store private keys

00:30:21,870 --> 00:30:27,420
burned in the hardware that can't be

00:30:23,700 --> 00:30:29,730
extracted and we'd like to add some

00:30:27,420 --> 00:30:31,740
Python bindings for Jose or any other

00:30:29,730 --> 00:30:33,720
language that you might want to use Jose

00:30:31,740 --> 00:30:35,820
in we would also like to support

00:30:33,720 --> 00:30:37,290
additional crypto backends and maybe

00:30:35,820 --> 00:30:38,850
some additional algorithms although we

00:30:37,290 --> 00:30:41,760
do support all of the algorithms that

00:30:38,850 --> 00:30:43,260
are specified by the RFC there are a few

00:30:41,760 --> 00:30:45,230
others that are not specified that are

00:30:43,260 --> 00:30:49,560
in common use that might be interested

00:30:45,230 --> 00:30:51,540
interesting to implement for clevis

00:30:49,560 --> 00:30:53,130
where I'm going to work right now adding

00:30:51,540 --> 00:30:54,240
a password pin which is actually much

00:30:53,130 --> 00:30:57,810
more complicated than you might expect

00:30:54,240 --> 00:31:00,570
and this will allow you to mix passwords

00:30:57,810 --> 00:31:02,480
in with your policy once we land pkcs 11

00:31:00,570 --> 00:31:05,450
support in Jose then we will have

00:31:02,480 --> 00:31:08,990
pkcs 11 pin and clevis so that you can

00:31:05,450 --> 00:31:11,180
actually bind your client-side data to

00:31:08,990 --> 00:31:15,050
hardware that's inserted like a TPM for

00:31:11,180 --> 00:31:16,880
instance support for we would like to

00:31:15,050 --> 00:31:19,760
have support for non root non removable

00:31:16,880 --> 00:31:22,910
volumes the reason we don't support this

00:31:19,760 --> 00:31:24,290
right now this is by the way volumes

00:31:22,910 --> 00:31:26,060
that are basically built in that are

00:31:24,290 --> 00:31:28,310
there at boot time but they are not your

00:31:26,060 --> 00:31:29,930
root volume we don't we don't support

00:31:28,310 --> 00:31:32,450
this right now because of a mismatch of

00:31:29,930 --> 00:31:33,980
expectations between us and system D but

00:31:32,450 --> 00:31:36,320
we're actively working with the system D

00:31:33,980 --> 00:31:37,070
people about so that will be coming in

00:31:36,320 --> 00:31:39,200
the near future

00:31:37,070 --> 00:31:41,840
we'd like to add X for encryption

00:31:39,200 --> 00:31:44,060
support so XT for also allows you to do

00:31:41,840 --> 00:31:45,050
per directory encryption and we would

00:31:44,060 --> 00:31:48,380
like to basically do the same thing

00:31:45,050 --> 00:31:51,170
there where we encrypt the key using

00:31:48,380 --> 00:31:53,900
clevis and then store the metadata in an

00:31:51,170 --> 00:31:56,720
extended attribute on the directory and

00:31:53,900 --> 00:31:58,370
for unlocking then we can just perform

00:31:56,720 --> 00:32:02,660
the same exact sort of steps that we do

00:31:58,370 --> 00:32:04,880
for lux and then finally for Tang we

00:32:02,660 --> 00:32:07,670
would like to modify our algorithm

00:32:04,880 --> 00:32:09,830
slightly to support binding IDs this

00:32:07,670 --> 00:32:12,590
would be optional but it will also

00:32:09,830 --> 00:32:15,770
sacrifice anonymity so it's a trade-off

00:32:12,590 --> 00:32:16,970
here which allows you to do revocation

00:32:15,770 --> 00:32:19,820
which is our second feature that we'd

00:32:16,970 --> 00:32:21,140
like to add so in other words if you

00:32:19,820 --> 00:32:22,760
want your clients just to be able to

00:32:21,140 --> 00:32:25,460
bind you don't care about revoking their

00:32:22,760 --> 00:32:28,310
keys then you can just use this protocol

00:32:25,460 --> 00:32:31,160
as is but if you want to be able to

00:32:28,310 --> 00:32:32,150
actually revoke a specific binding then

00:32:31,160 --> 00:32:34,490
we need to be able to have

00:32:32,150 --> 00:32:37,340
cryptographically seal binding IDs as

00:32:34,490 --> 00:32:39,560
part of this process I mean of course

00:32:37,340 --> 00:32:43,700
patches are welcome so if you'd like to

00:32:39,560 --> 00:32:45,080
contribute to our project please do and

00:32:43,700 --> 00:32:48,830
this is where we get the names from by

00:32:45,080 --> 00:32:51,950
the way we have clevis and tang it's

00:32:48,830 --> 00:32:54,080
just a traditional joint so the u-shaped

00:32:51,950 --> 00:32:56,660
bit is called a clevis and the block

00:32:54,080 --> 00:32:58,010
shaped bit is called tang and the thing

00:32:56,660 --> 00:33:01,970
that binds them together is called a

00:32:58,010 --> 00:33:03,030
clevis pin so that's all I have thank

00:33:01,970 --> 00:33:12,910
you very much

00:33:03,030 --> 00:33:12,910
[Applause]

00:33:17,830 --> 00:33:21,550
now there any questions

00:34:19,659 --> 00:34:22,210
are there any other questions while

00:34:21,250 --> 00:34:24,839
we're working out the microphone

00:34:22,210 --> 00:34:24,839
situation up there

00:34:38,070 --> 00:34:44,950
all right hello hello

00:34:40,930 --> 00:34:48,000
thanks very interesting just two small

00:34:44,950 --> 00:34:50,350
questions do you see any limitations

00:34:48,000 --> 00:34:53,800
situations where you wouldn't want to

00:34:50,350 --> 00:34:56,620
use this algorithm and the second

00:34:53,800 --> 00:34:59,650
question is do you see any other of

00:34:56,620 --> 00:35:03,670
applications that might be interesting

00:34:59,650 --> 00:35:06,550
like how unlocking your house for

00:35:03,670 --> 00:35:08,800
instance things like that so yeah those

00:35:06,550 --> 00:35:11,770
are two great questions the one is do we

00:35:08,800 --> 00:35:13,570
see any limitations with this and the

00:35:11,770 --> 00:35:17,140
second question was do we see any other

00:35:13,570 --> 00:35:19,480
applications of this and so the case

00:35:17,140 --> 00:35:20,890
where you may not want to use tang is if

00:35:19,480 --> 00:35:22,540
you're working in a heavily standardized

00:35:20,890 --> 00:35:24,970
environment and you're only allowed to

00:35:22,540 --> 00:35:27,310
use certain algorithms and and our

00:35:24,970 --> 00:35:29,050
algorithm isn't on the list the other

00:35:27,310 --> 00:35:31,390
case where you might not want to use

00:35:29,050 --> 00:35:34,000
tang is where you need revocation of

00:35:31,390 --> 00:35:35,770
some kind and that's because we don't

00:35:34,000 --> 00:35:37,270
implement it yet but we are going to be

00:35:35,770 --> 00:35:39,580
implementing it in the near future so

00:35:37,270 --> 00:35:43,620
that case will fall off of our list

00:35:39,580 --> 00:35:45,340
we've also started to open some

00:35:43,620 --> 00:35:47,740
conversations with some different

00:35:45,340 --> 00:35:49,330
standards bodies about actually

00:35:47,740 --> 00:35:51,270
standardizing the algorithm and making

00:35:49,330 --> 00:35:55,330
sure that it's available in those cases

00:35:51,270 --> 00:35:56,740
so no I think that once we sort of cross

00:35:55,330 --> 00:35:58,600
all of those hurdles I don't think

00:35:56,740 --> 00:36:02,050
there's any reason not to use the

00:35:58,600 --> 00:36:03,250
application the only other reason I can

00:36:02,050 --> 00:36:04,750
see that somebody would not want to use

00:36:03,250 --> 00:36:08,260
it is because it is new crypto and

00:36:04,750 --> 00:36:10,540
people are always rightly concerned

00:36:08,260 --> 00:36:13,740
about using new crypto and so this is

00:36:10,540 --> 00:36:16,480
precisely why we're also pursuing a

00:36:13,740 --> 00:36:18,100
paper that goes through the formal

00:36:16,480 --> 00:36:20,290
methods to prove the actual algorithm

00:36:18,100 --> 00:36:22,240
itself so once this is done and

00:36:20,290 --> 00:36:24,490
generally accepted in academia we

00:36:22,240 --> 00:36:27,040
shouldn't have any other limitations as

00:36:24,490 --> 00:36:28,480
far as other applications for I assume

00:36:27,040 --> 00:36:31,480
you're talking about the Macomb Rally

00:36:28,480 --> 00:36:33,340
exchange algorithm it's it's actually

00:36:31,480 --> 00:36:34,840
very very interesting because you can

00:36:33,340 --> 00:36:37,090
use it for any case where you want

00:36:34,840 --> 00:36:38,560
authentication in which the

00:36:37,090 --> 00:36:40,390
authenticating party gets a

00:36:38,560 --> 00:36:42,850
cryptographic key that they can decrypt

00:36:40,390 --> 00:36:45,760
data which I'm not aware of any other

00:36:42,850 --> 00:36:46,900
system that currently does this so a one

00:36:45,760 --> 00:36:50,220
area where this would

00:36:46,900 --> 00:36:53,079
very interesting imagine say you have

00:36:50,220 --> 00:36:55,270
your phone is doing the Macomb rally

00:36:53,079 --> 00:36:58,029
exchange over Bluetooth you walk up to

00:36:55,270 --> 00:36:59,740
your laptop and your laptop not only

00:36:58,029 --> 00:37:02,140
authenticate you but now is able to

00:36:59,740 --> 00:37:04,029
decrypt say your keyring with all of

00:37:02,140 --> 00:37:06,039
your other keys like your SSH key and

00:37:04,029 --> 00:37:07,210
all of that other kind of stuff so

00:37:06,039 --> 00:37:10,089
there's some really interesting

00:37:07,210 --> 00:37:11,650
applications of it more broadly but we

00:37:10,089 --> 00:37:13,450
haven't we're just trying to get this

00:37:11,650 --> 00:37:16,799
one out the door first and then we'll

00:37:13,450 --> 00:37:18,849
work on the other ones so thank you

00:37:16,799 --> 00:37:22,029
there's some questions down here in the

00:37:18,849 --> 00:37:24,460
front up here yeah go ahead No thank you

00:37:22,029 --> 00:37:27,039
very much very interesting concept those

00:37:24,460 --> 00:37:28,750
more complex policies that you talked

00:37:27,039 --> 00:37:31,329
about that you can now implement how do

00:37:28,750 --> 00:37:34,569
you configure them is there like a

00:37:31,329 --> 00:37:36,339
scripting language or the configuration

00:37:34,569 --> 00:37:38,890
file form that you configure them with

00:37:36,339 --> 00:37:41,079
yeah so the question was how do you

00:37:38,890 --> 00:37:43,960
configure the more complex policies and

00:37:41,079 --> 00:37:45,609
the answer is that what essentially

00:37:43,960 --> 00:37:48,490
happens is when you do your encryption

00:37:45,609 --> 00:37:50,730
you specify your root of the root of the

00:37:48,490 --> 00:37:53,500
tree and then in the configuration

00:37:50,730 --> 00:37:56,289
that's passed in the in the JSON blob

00:37:53,500 --> 00:37:58,480
will be the entire hierarchy so it's all

00:37:56,289 --> 00:38:00,720
defined in encryption time and the thing

00:37:58,480 --> 00:38:03,369
that's really interesting about this is

00:38:00,720 --> 00:38:04,990
currently people who are thinking ahead

00:38:03,369 --> 00:38:07,319
of the game and thinking about policy

00:38:04,990 --> 00:38:11,109
they're typically thinking about a

00:38:07,319 --> 00:38:13,450
secure process which has access to the

00:38:11,109 --> 00:38:15,760
symmetric encryption key and then which

00:38:13,450 --> 00:38:18,579
manages access to it based on some

00:38:15,760 --> 00:38:20,680
policy where clevis is really different

00:38:18,579 --> 00:38:23,020
from this use case is that we actually

00:38:20,680 --> 00:38:25,599
validate that policy cryptographically

00:38:23,020 --> 00:38:27,279
so there's no special privilege to

00:38:25,599 --> 00:38:29,440
process anywhere that can do the

00:38:27,279 --> 00:38:31,029
decryption as long as you can fulfill

00:38:29,440 --> 00:38:34,059
the policy you can get the plaintext

00:38:31,029 --> 00:38:38,470
back but if you can't you can't okay

00:38:34,059 --> 00:38:41,680
thank you very much Rob you spoke about

00:38:38,470 --> 00:38:44,710
the key exchange and that the ephemeral

00:38:41,680 --> 00:38:47,109
key is mixed in yes so my question is

00:38:44,710 --> 00:38:50,740
have you done any any research into how

00:38:47,109 --> 00:38:53,310
many times you can send the same key

00:38:50,740 --> 00:38:55,450
across and

00:38:53,310 --> 00:38:57,310
extremely low series of these

00:38:55,450 --> 00:38:59,890
transmissions be able to pick out which

00:38:57,310 --> 00:39:01,390
parts are rbr static across all of them

00:38:59,890 --> 00:39:03,040
so that you can basically discard all

00:39:01,390 --> 00:39:05,800
the ephemeral keys and get the non

00:39:03,040 --> 00:39:09,220
ephemeral part yes so there's nothing

00:39:05,800 --> 00:39:11,410
leaked as part of this operation the

00:39:09,220 --> 00:39:14,410
only thing that the server ever receives

00:39:11,410 --> 00:39:18,910
is random data it's not like we're doing

00:39:14,410 --> 00:39:21,970
this in the we're doing this actually

00:39:18,910 --> 00:39:24,070
inside of the elliptic curve realm so

00:39:21,970 --> 00:39:26,710
it's just another point on the curve so

00:39:24,070 --> 00:39:29,590
basically you have as many points as

00:39:26,710 --> 00:39:32,050
there are on the curve which is a lot so

00:39:29,590 --> 00:39:34,660
in the case of a 256-bit curve it's you

00:39:32,050 --> 00:39:37,180
know 2 to the 256 which is considered

00:39:34,660 --> 00:39:41,619
secure by all current standards to my

00:39:37,180 --> 00:39:46,990
knowledge yep somebody I don't know

00:39:41,619 --> 00:39:50,260
who's next I wanted to ask about those

00:39:46,990 --> 00:39:52,630
policies anyway it's a it's tremendous

00:39:50,260 --> 00:39:55,390
progress over key escrow mechanisms

00:39:52,630 --> 00:39:57,250
although one of the strengths of the key

00:39:55,390 --> 00:40:00,430
escrow mechanisms is that the policies

00:39:57,250 --> 00:40:05,770
are dynamic so you can actually modify

00:40:00,430 --> 00:40:08,680
them after after the the key is

00:40:05,770 --> 00:40:11,400
increasing is encrypted and so you can

00:40:08,680 --> 00:40:15,820
authorize for example more users than

00:40:11,400 --> 00:40:19,570
then than you anticipated yes when so

00:40:15,820 --> 00:40:22,000
how would you as far as I understand

00:40:19,570 --> 00:40:24,190
this tank level scheme doesn't currently

00:40:22,000 --> 00:40:28,180
support that and I was wondering if you

00:40:24,190 --> 00:40:29,349
see a way to extend it with support for

00:40:28,180 --> 00:40:31,690
something like you have to have access

00:40:29,349 --> 00:40:34,510
to the client and you have to

00:40:31,690 --> 00:40:38,070
essentially decrypt using the policy and

00:40:34,510 --> 00:40:40,210
then re encrypt using a new policy so

00:40:38,070 --> 00:40:41,740
it's not there's no there's no way to

00:40:40,210 --> 00:40:43,390
essentially manage it like there isn't

00:40:41,740 --> 00:40:44,950
an escrow but there's a lot of other

00:40:43,390 --> 00:40:48,119
security benefits so it is sort of a

00:40:44,950 --> 00:40:48,119
trade-off yeah thank you

00:40:49,800 --> 00:40:55,740
yeah yeah thanks for the talk it's a it

00:40:53,190 --> 00:40:57,300
was really interesting so one

00:40:55,740 --> 00:41:00,570
interesting news case would obviously be

00:40:57,300 --> 00:41:03,930
to try and use this as the route of

00:41:00,570 --> 00:41:06,630
trust for a machine as well I'm sorry do

00:41:03,930 --> 00:41:11,100
to use this authentication method as the

00:41:06,630 --> 00:41:14,970
root of trust you're a machine are you

00:41:11,100 --> 00:41:18,090
looking into building on to this this

00:41:14,970 --> 00:41:20,490
policy mechanism further policies to say

00:41:18,090 --> 00:41:24,060
well I've now decrypted the hard drive

00:41:20,490 --> 00:41:26,640
now I can authenticate this service or

00:41:24,060 --> 00:41:28,530
this device how are you are you planning

00:41:26,640 --> 00:41:30,480
to implement it and how do you foresee

00:41:28,530 --> 00:41:32,370
that working it's not currently on the

00:41:30,480 --> 00:41:34,170
roadmap it's something that's

00:41:32,370 --> 00:41:36,140
theoretically possible but I have a lot

00:41:34,170 --> 00:41:38,250
of other stuff on my plate right now so

00:41:36,140 --> 00:41:39,510
when I get all of that other stuff off

00:41:38,250 --> 00:41:46,320
my plate then I would like to think

00:41:39,510 --> 00:41:49,830
about that yes yeah I thought I have two

00:41:46,320 --> 00:41:52,560
questions one is it seems really easy to

00:41:49,830 --> 00:41:54,720
use is it just as easy I hope so if it's

00:41:52,560 --> 00:41:56,040
not file a bug or a patch we're glad to

00:41:54,720 --> 00:41:57,570
take either yeah

00:41:56,040 --> 00:42:00,930
and it's already used in production

00:41:57,570 --> 00:42:03,030
somewhere is it just because we just

00:42:00,930 --> 00:42:07,170
released this about two months ago in

00:42:03,030 --> 00:42:08,970
Fedora and we are currently we're

00:42:07,170 --> 00:42:10,500
currently attempting to stabilize it so

00:42:08,970 --> 00:42:12,330
I don't know anybody who's using it in

00:42:10,500 --> 00:42:13,200
production but I know lots of people who

00:42:12,330 --> 00:42:17,690
are using in a pre-production

00:42:13,200 --> 00:42:17,690
environments looks great Thanks

00:42:19,930 --> 00:42:27,240
up here somewhere I think any more

00:42:24,790 --> 00:42:27,240
questions

00:42:29,780 --> 00:42:38,900
hi another question from me

00:42:32,780 --> 00:42:42,310
as did you how does this that relate to

00:42:38,900 --> 00:42:44,830
attribute based encryption schemes and

00:42:42,310 --> 00:42:48,590
attribute based encryption schemes and

00:42:44,830 --> 00:42:51,050
do you think that like those like those

00:42:48,590 --> 00:42:53,360
two approaches can be combined I would

00:42:51,050 --> 00:42:55,190
really like to see them combined I don't

00:42:53,360 --> 00:42:59,720
see any reason why they can't be

00:42:55,190 --> 00:43:02,720
combined it should we don't really have

00:42:59,720 --> 00:43:05,030
any to my knowledge we don't have any

00:43:02,720 --> 00:43:06,920
usable implementations of attribute

00:43:05,030 --> 00:43:08,900
based encryption it's all currently

00:43:06,920 --> 00:43:12,580
theoretical so if somebody would have to

00:43:08,900 --> 00:43:16,840
write it and then we can implement it so

00:43:12,580 --> 00:43:16,840
so if you'd like to write it please do

00:43:18,100 --> 00:43:21,850
any more questions

00:43:26,920 --> 00:43:35,909
thank you very much

00:43:28,630 --> 00:43:35,909

YouTube URL: https://www.youtube.com/watch?v=2uLKvB8Z5D0


