Title: Can strace make you fail? strace syscall fault injection
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	by Dmitry Levin

At: FOSDEM 2017

strace is a diagnostic, debugging and instructional utility for Linux. It isused to monitor interactions between processes and the Linux kernel, whichinclude system calls, signal deliveries, and changes of process state. In2016, strace has been extended to tamper with tracees using syscall faultinjection, making strace also a syscall fault injection tool, the onlyunprivileged userspace command-line runtime tool of this kind for Linux.

The last summer as a part of strace GSoC 2016 project Nahim El Atmani hasimplemented a prototype of syscall fault injection - a software testingtechnique used for improving test coverage of error handling code paths thatmight otherwise rarely be followed by introducing faults. Now the feature hasfinally been implemented and is a part of strace 4.15 released in December2016.

In this talk the maintainer of strace will demonstrate the new feature,describe its implementation, and show examples of real bugs found with itshelp.


Room: H.2213
Scheduled start: 2017-02-05 10:45:00
Captions: 
	00:00:14,400 --> 00:00:23,320
so hello everybody I'm Metreon the

00:00:20,650 --> 00:00:26,160
meeting of stress and today I will talk

00:00:23,320 --> 00:00:30,609
about a new strange feature called Cisco

00:00:26,160 --> 00:00:39,250
fault injection so does anybody know

00:00:30,609 --> 00:00:43,090
what stress is nice so as most of you

00:00:39,250 --> 00:00:45,250
know stress is a traditional diagnostic

00:00:43,090 --> 00:00:49,079
debugging and instructional user space

00:00:45,250 --> 00:00:54,570
utility for Linux are how traditional is

00:00:49,079 --> 00:00:57,129
25 years old so quite original and

00:00:54,570 --> 00:00:59,800
traditionally it's used to monitor

00:00:57,129 --> 00:01:04,510
interactions between user space protests

00:00:59,800 --> 00:01:08,470
and been external the most known are

00:01:04,510 --> 00:01:12,640
system calls and also signal deliveries

00:01:08,470 --> 00:01:15,130
so changes of process state as Jayce has

00:01:12,640 --> 00:01:19,120
traditional everything's traditional

00:01:15,130 --> 00:01:21,760
versus his transitional comment line

00:01:19,120 --> 00:01:24,370
interface and multiple filtering

00:01:21,760 --> 00:01:26,350
capabilities so because the interface is

00:01:24,370 --> 00:01:29,350
traditional it's easy to use for people

00:01:26,350 --> 00:01:32,680
who are used to this for 20-something

00:01:29,350 --> 00:01:36,370
years and it's quite powerful because of

00:01:32,680 --> 00:01:39,160
this filtering capabilities but last

00:01:36,370 --> 00:01:41,800
year a stretch has been extended to do

00:01:39,160 --> 00:01:47,800
something very untraditional and it is

00:01:41,800 --> 00:01:50,980
to tamper with traces by injection Falls

00:01:47,800 --> 00:01:53,470
instakill Cisco fault injection the

00:01:50,980 --> 00:01:56,500
current implementation is based on the

00:01:53,470 --> 00:02:00,460
work made by jisuk student of first last

00:01:56,500 --> 00:02:02,770
year like email money I'm not sure how

00:02:00,460 --> 00:02:05,410
to pronounce his name so I'm sorry if

00:02:02,770 --> 00:02:11,170
it's wrong she will some Sunday

00:02:05,410 --> 00:02:14,560
correctly so what is a fault injection

00:02:11,170 --> 00:02:16,689
just a brief recollection it's a

00:02:14,560 --> 00:02:19,430
software testing technique used for

00:02:16,689 --> 00:02:22,550
improving test coverage

00:02:19,430 --> 00:02:25,130
mostly of our hunting paths that my

00:02:22,550 --> 00:02:28,250
otherwise fairly befouled by introducing

00:02:25,130 --> 00:02:30,170
falls this is a nice definition from

00:02:28,250 --> 00:02:33,590
Wikipedia thanks to the key video for

00:02:30,170 --> 00:02:36,320
this so where do we place a stress among

00:02:33,590 --> 00:02:38,930
other fault injection tools

00:02:36,320 --> 00:02:42,080
it's obviously software it's run time

00:02:38,930 --> 00:02:45,140
the most of instrumentation tools are

00:02:42,080 --> 00:02:47,360
compile time this is run time it does it

00:02:45,140 --> 00:02:52,510
work by means of Cisco into position

00:02:47,360 --> 00:02:56,870
it's user space unlike many current

00:02:52,510 --> 00:02:59,870
techniques we have its unprivileged

00:02:56,870 --> 00:03:03,620
and as I said it has traditional command

00:02:59,870 --> 00:03:06,950
line interface so now I'll show you a

00:03:03,620 --> 00:03:09,590
series of examples but hopefully we will

00:03:06,950 --> 00:03:12,230
get you an idea what that is called

00:03:09,590 --> 00:03:15,400
photo Jack's and syndics is what you

00:03:12,230 --> 00:03:18,710
could do the fit and I'll start with a

00:03:15,400 --> 00:03:20,720
simple program cut from koryo tools

00:03:18,710 --> 00:03:23,690
which is linking dynamically with

00:03:20,720 --> 00:03:26,690
Phillip C and we'll see what could be

00:03:23,690 --> 00:03:31,160
done so the top box you see a

00:03:26,690 --> 00:03:33,560
traditional output and in the bottom box

00:03:31,160 --> 00:03:39,230
something with fault injection

00:03:33,560 --> 00:03:44,390
so let's filter of all let's filter all

00:03:39,230 --> 00:03:49,280
open circles of this material comment

00:03:44,390 --> 00:03:54,440
and let's have them all what you can see

00:03:49,280 --> 00:03:56,690
here that this ends in dynamic linker it

00:03:54,440 --> 00:03:58,700
tries to open its cache it fails it

00:03:56,690 --> 00:04:00,980
tries to open Lipsy in redefined

00:03:58,700 --> 00:04:03,709
locations on this architecture where our

00:04:00,980 --> 00:04:07,489
fall occasions in this build of Lipsy

00:04:03,709 --> 00:04:11,870
that fails nothing very it's quite

00:04:07,489 --> 00:04:16,280
predictable let's do something something

00:04:11,870 --> 00:04:20,630
different let's change our code that

00:04:16,280 --> 00:04:23,330
dynamic linker will get from the fault

00:04:20,630 --> 00:04:25,669
one which is energy is function of the

00:04:23,330 --> 00:04:27,740
prevented to something that has a

00:04:25,669 --> 00:04:32,630
different meaning for for dynamic linker

00:04:27,740 --> 00:04:36,320
as you see it tries twice as many like

00:04:32,630 --> 00:04:38,530
occasions when it sees a record in the

00:04:36,320 --> 00:04:38,530
end

00:04:43,139 --> 00:04:54,240
the record of open Cisco you can inject

00:04:50,550 --> 00:04:57,090
fold not on all indications but just in

00:04:54,240 --> 00:05:00,090
the first one or whatever else so if you

00:04:57,090 --> 00:05:03,270
inject a fall just to the first

00:05:00,090 --> 00:05:08,460
indication you can see that dynamic

00:05:03,270 --> 00:05:11,189
linker just it does all the same it

00:05:08,460 --> 00:05:16,889
tries Lipsy in different locations finds

00:05:11,189 --> 00:05:20,900
it and everything works but if you fail

00:05:16,889 --> 00:05:25,139
second and all subsequent indications

00:05:20,900 --> 00:05:27,840
what happens directly opens its cache

00:05:25,139 --> 00:05:30,930
and tries to open Lipsy according to the

00:05:27,840 --> 00:05:34,919
cache as you see it fails and then I

00:05:30,930 --> 00:05:38,099
trace all these predefined locations and

00:05:34,919 --> 00:05:39,930
you can notice that it tries Lipsy tries

00:05:38,099 --> 00:05:43,919
to open loop she at the same location it

00:05:39,930 --> 00:05:46,770
tried before why why damn I think it

00:05:43,919 --> 00:05:48,539
does this because there are different

00:05:46,770 --> 00:05:51,240
code paths and they don't know about

00:05:48,539 --> 00:05:54,240
each other in the first part tries to

00:05:51,240 --> 00:05:57,300
open and in another code path it also

00:05:54,240 --> 00:06:00,330
tries to open and it doesn't care but so

00:05:57,300 --> 00:06:08,009
it Chinese it's not about just a funny

00:06:00,330 --> 00:06:10,490
thing let's let's that anything to do it

00:06:08,009 --> 00:06:14,669
work and have a look at the cat itself

00:06:10,490 --> 00:06:19,229
so the third open Cisco is the she's

00:06:14,669 --> 00:06:22,379
call made but made by cat itself and it

00:06:19,229 --> 00:06:25,319
looks like what you would expect from a

00:06:22,379 --> 00:06:32,580
cut it fails and it exits with error

00:06:25,319 --> 00:06:37,259
code another way you can specify false

00:06:32,580 --> 00:06:40,159
is to say how often you would to inject

00:06:37,259 --> 00:06:43,139
them for example you can inject them

00:06:40,159 --> 00:06:46,889
starting with third one with third and

00:06:43,139 --> 00:06:50,310
then every second one so you see that

00:06:46,889 --> 00:06:54,289
cat handles the situation outside

00:06:50,310 --> 00:06:56,309
properly so it reports error on every

00:06:54,289 --> 00:06:59,819
case when the

00:06:56,309 --> 00:07:03,229
and purchases everything that's that's

00:06:59,819 --> 00:07:08,399
opened and exits with error code so

00:07:03,229 --> 00:07:10,589
looks like it works fine and now let's

00:07:08,399 --> 00:07:12,899
have a look at something more

00:07:10,589 --> 00:07:16,229
interesting let's combine fault

00:07:12,899 --> 00:07:18,539
injection with pass filtering so in the

00:07:16,229 --> 00:07:21,179
top box you see a sequence of the

00:07:18,539 --> 00:07:24,419
schools that are related to the files

00:07:21,179 --> 00:07:29,819
pass to cat and that's not in this case

00:07:24,419 --> 00:07:32,629
and in the bottom I will just fail each

00:07:29,819 --> 00:07:36,089
of the Cisco so you'll see how cat

00:07:32,629 --> 00:07:40,949
handle this so the first move is seen

00:07:36,089 --> 00:07:44,249
and that second one is F star and for

00:07:40,949 --> 00:07:49,110
some reason cat considers this as an

00:07:44,249 --> 00:07:52,739
error it's quite an unusual thing that

00:07:49,110 --> 00:07:56,249
if that fails so probably it's a same

00:07:52,739 --> 00:08:00,239
thing to do is to fail anything from

00:07:56,249 --> 00:08:04,979
another site that F advice is call its

00:08:00,239 --> 00:08:08,339
its advice so cat is also quite right

00:08:04,979 --> 00:08:11,159
that it ignores this error it's just an

00:08:08,339 --> 00:08:18,389
advice to kernel that cat is going to do

00:08:11,159 --> 00:08:20,399
some some sequential reads what more or

00:08:18,389 --> 00:08:23,429
less the same with read if you fail the

00:08:20,399 --> 00:08:26,579
read with a heart error it's quite right

00:08:23,429 --> 00:08:30,719
to report it and fail but what do you

00:08:26,579 --> 00:08:34,169
feel cat will do if it sees temporary

00:08:30,719 --> 00:08:36,349
error would it restart it or would it

00:08:34,169 --> 00:08:36,349
fail

00:08:39,060 --> 00:08:45,190
it would restart cat is a good program

00:08:43,000 --> 00:08:47,350
after all and it knows that interrupted

00:08:45,190 --> 00:08:53,080
system call is a temporary error it

00:08:47,350 --> 00:08:58,450
should be restarted so and this is a

00:08:53,080 --> 00:09:03,100
peculiar thing this is a then you fail

00:08:58,450 --> 00:09:06,400
close to school let has no importance

00:09:03,100 --> 00:09:10,270
what CAD does it just opens file

00:09:06,400 --> 00:09:15,400
persists it and close it it's open it

00:09:10,270 --> 00:09:18,340
opens it read-only and what's the use of

00:09:15,400 --> 00:09:21,010
reporting this is a hard error run it

00:09:18,340 --> 00:09:24,790
then you can't close a file open

00:09:21,010 --> 00:09:28,360
read-only I don't know I would say it's

00:09:24,790 --> 00:09:33,270
a minor barking cat very minor to

00:09:28,360 --> 00:09:35,680
complain and exit with error code is

00:09:33,270 --> 00:09:38,200
because the the file was successfully

00:09:35,680 --> 00:09:44,770
purchased from the beginning to the end

00:09:38,200 --> 00:09:47,880
so why does it here you can see in brief

00:09:44,770 --> 00:09:52,330
that you can specify different fault

00:09:47,880 --> 00:09:57,730
injection expressions that would work

00:09:52,330 --> 00:10:00,280
and in letterbox and the second box you

00:09:57,730 --> 00:10:06,600
see that a stress actually can follow

00:10:00,280 --> 00:10:09,850
descriptors so even if CAD has no idea

00:10:06,600 --> 00:10:13,750
what the file it's working with a

00:10:09,850 --> 00:10:17,380
strange does know and can apply its

00:10:13,750 --> 00:10:19,890
filters so it's like what what you can

00:10:17,380 --> 00:10:23,320
see in the bottom box it's a primitive

00:10:19,890 --> 00:10:28,150
like primitive access control using a

00:10:23,320 --> 00:10:32,710
stress then let's have a look at real

00:10:28,150 --> 00:10:38,860
box this is a more less famous back in

00:10:32,710 --> 00:10:43,680
Python 3 to 5 and it's it was found by

00:10:38,860 --> 00:10:43,680
the student who did this just a project

00:10:45,200 --> 00:10:51,839
Python on every invocation needs some

00:10:48,329 --> 00:10:54,690
randomness for installation and when it

00:10:51,839 --> 00:10:56,430
fails to obtain this randomness it's a

00:10:54,690 --> 00:10:59,390
fatal error which is fine

00:10:56,430 --> 00:11:03,329
probably but it's not fine that it's

00:10:59,390 --> 00:11:08,810
throws a segmentation fault at

00:11:03,329 --> 00:11:15,120
hexadecimal address 50 it's not not good

00:11:08,810 --> 00:11:22,820
it's about why it does this ridiculous

00:11:15,120 --> 00:11:26,790
thing because it addresses a method of

00:11:22,820 --> 00:11:31,890
object which was not allocated because

00:11:26,790 --> 00:11:35,640
of lack of randomness as saw hexadecimal

00:11:31,890 --> 00:11:40,410
addresses just offset the inertial table

00:11:35,640 --> 00:11:42,839
like this fortunately this bug was seems

00:11:40,410 --> 00:11:45,480
to be at least fixed in Python physics

00:11:42,839 --> 00:11:48,149
first they were work around with it by

00:11:45,480 --> 00:11:50,910
using get random she's call but I

00:11:48,149 --> 00:11:53,670
actually tried to false get random and

00:11:50,910 --> 00:11:54,000
fine found out that it no longer seek

00:11:53,670 --> 00:11:59,959
false

00:11:54,000 --> 00:12:04,769
that's funny thing anyway and another

00:11:59,959 --> 00:12:13,100
real bug who was found with dynamic

00:12:04,769 --> 00:12:13,100
linker itself so if you fail and protect

00:12:13,130 --> 00:12:20,459
you can see that dynamic linker from

00:12:18,120 --> 00:12:24,740
Lipsy ignores error from the first and

00:12:20,459 --> 00:12:28,829
projector but it treats all subsequent

00:12:24,740 --> 00:12:32,910
errors as fatal that's quite natural to

00:12:28,829 --> 00:12:36,269
do so with all subsequent but why it

00:12:32,910 --> 00:12:38,790
ignores the first error it's because

00:12:36,269 --> 00:12:41,959
they're different code paths and the

00:12:38,790 --> 00:12:45,209
only code path that exists in currents

00:12:41,959 --> 00:12:49,680
ellipses dynamic linker is the one

00:12:45,209 --> 00:12:53,699
that's early a in its running and it's

00:12:49,680 --> 00:12:55,199
just ignores the earth and this actually

00:12:53,699 --> 00:12:57,209
can happen for example because of

00:12:55,199 --> 00:13:02,160
fragmentation and

00:12:57,209 --> 00:13:05,910
that the colvett which failed is the one

00:13:02,160 --> 00:13:09,329
with choice dough to remove access it's

00:13:05,910 --> 00:13:13,019
brought none so actually some some pages

00:13:09,329 --> 00:13:16,230
are remains to be accessible which are

00:13:13,019 --> 00:13:21,360
supposed not to be so it's like like it

00:13:16,230 --> 00:13:26,129
would be a minor security issue if it's

00:13:21,360 --> 00:13:28,559
not a imaginary problem because if first

00:13:26,129 --> 00:13:30,600
and protect call files it's very likely

00:13:28,559 --> 00:13:36,860
that all subsequent also fail and they

00:13:30,600 --> 00:13:40,170
appropriate that still it's about now

00:13:36,860 --> 00:13:41,399
I'll try to explain you what's going on

00:13:40,170 --> 00:13:44,879
under the hood and how it's all

00:13:41,399 --> 00:13:49,790
implemented so when tracy's invokes this

00:13:44,879 --> 00:13:53,429
is called kernel puts it in so called

00:13:49,790 --> 00:13:56,369
Cisco enter stop state so it's

00:13:53,429 --> 00:13:59,220
completely stopped at the same time

00:13:56,369 --> 00:14:03,779
Asturias awakens it fetches his call

00:13:59,220 --> 00:14:06,209
number its arguments apply filters

00:14:03,779 --> 00:14:09,480
you've seen all other kinds of filters

00:14:06,209 --> 00:14:12,420
history supports it decides and may I

00:14:09,480 --> 00:14:15,379
was keep this Cisco or brin something

00:14:12,420 --> 00:14:20,519
and then it tells the kernel to go on

00:14:15,379 --> 00:14:25,019
with stress Tracey then kernel executes

00:14:20,519 --> 00:14:27,899
this is call and before passing control

00:14:25,019 --> 00:14:30,689
tool to user space

00:14:27,899 --> 00:14:32,970
it puts traces again in a stop state

00:14:30,689 --> 00:14:36,449
it's a slightly different state school

00:14:32,970 --> 00:14:41,220
she's called exit stop at the stylus

00:14:36,449 --> 00:14:45,749
trace awakens again it may fit Cisco

00:14:41,220 --> 00:14:48,569
return code and agreements depend it

00:14:45,749 --> 00:14:51,929
depends whether the the call is filtered

00:14:48,569 --> 00:14:55,319
or not also it prints at this time this

00:14:51,929 --> 00:14:57,720
return code is necessary and tells care

00:14:55,319 --> 00:15:00,629
not to let the trace you go all all this

00:14:57,720 --> 00:15:03,269
cycle repeats itself until something

00:15:00,629 --> 00:15:06,240
happens with Tracy where it's exit so

00:15:03,269 --> 00:15:08,759
hotel so taking these two parts together

00:15:06,240 --> 00:15:10,920
you can see the sequence and in this

00:15:08,759 --> 00:15:14,459
sequence we had two

00:15:10,920 --> 00:15:17,730
places where a strays actually can

00:15:14,459 --> 00:15:20,490
temper this disco with the score number

00:15:17,730 --> 00:15:21,630
versus called arguments which the

00:15:20,490 --> 00:15:24,480
scholar turncoat

00:15:21,630 --> 00:15:26,880
and this is exactly the way how this

00:15:24,480 --> 00:15:30,329
code fault injection is implemented so

00:15:26,880 --> 00:15:31,050
on Anthony's call a stress replaces his

00:15:30,329 --> 00:15:36,620
call number

00:15:31,050 --> 00:15:40,730
we're gonna invalid 1 minus 1 and then

00:15:36,620 --> 00:15:43,589
Colonel sees this invalid is call it

00:15:40,730 --> 00:15:46,350
it's just invalid Cisco

00:15:43,589 --> 00:15:49,850
so it's returns an error for an invalid

00:15:46,350 --> 00:15:53,250
Cisco which is in a season most

00:15:49,850 --> 00:15:57,170
architectures but not all of them so you

00:15:53,250 --> 00:16:01,529
shouldn't rely on this error code and

00:15:57,170 --> 00:16:04,949
then on exigencies called if instructed

00:16:01,529 --> 00:16:09,570
to replace error code it it replaces

00:16:04,949 --> 00:16:11,209
this error code with the one that was

00:16:09,570 --> 00:16:16,339
misfired

00:16:11,209 --> 00:16:16,339
so it's actually pretty simple inside

00:16:16,370 --> 00:16:22,740
but this is not the only thing as you

00:16:20,790 --> 00:16:25,380
can see from this slide it's not the

00:16:22,740 --> 00:16:27,660
only thing that could be done not just

00:16:25,380 --> 00:16:30,209
this is called fault injection but other

00:16:27,660 --> 00:16:35,760
kinds of injections jump rings for

00:16:30,209 --> 00:16:39,329
example this is some recent development

00:16:35,760 --> 00:16:42,750
not not in the least stressed version

00:16:39,329 --> 00:16:46,050
yet you can inject a signal at any of

00:16:42,750 --> 00:16:48,829
these points the current limitation it's

00:16:46,050 --> 00:16:48,829
injected on

00:16:51,460 --> 00:17:00,950
I'm exiting anything yeah an existence

00:16:56,510 --> 00:17:06,490
is called so what would you use this

00:17:00,950 --> 00:17:10,520
signal injection for for example if you

00:17:06,490 --> 00:17:11,959
want to terminate program you would you

00:17:10,520 --> 00:17:15,350
would probably use a different signal

00:17:11,959 --> 00:17:17,689
for this or if you want to dump it for

00:17:15,350 --> 00:17:25,250
further analysis by another tool like

00:17:17,689 --> 00:17:30,260
gdb and another the way you can tamper

00:17:25,250 --> 00:17:32,780
with is to replace its own code of Cisco

00:17:30,260 --> 00:17:35,450
with something that doesn't look like an

00:17:32,780 --> 00:17:39,430
error actually so you can pretend it's

00:17:35,450 --> 00:17:43,520
it's called completed successfully but

00:17:39,430 --> 00:17:46,450
actually skip it so by replacing Cisco

00:17:43,520 --> 00:17:49,790
number one entering to an invalid one

00:17:46,450 --> 00:17:54,410
this way you skip the Cisco and on

00:17:49,790 --> 00:17:58,220
exiting you can replace return code with

00:17:54,410 --> 00:18:01,880
like zero which for Cisco's like unlink

00:17:58,220 --> 00:18:06,080
means that everything is fine so the

00:18:01,880 --> 00:18:08,630
tracer will suppose that a new complete

00:18:06,080 --> 00:18:14,390
successfully and their file is gone but

00:18:08,630 --> 00:18:19,010
it's actually yeah this is not as easy

00:18:14,390 --> 00:18:23,530
as it looks for more complicated schools

00:18:19,010 --> 00:18:28,010
they have some semantics that has to be

00:18:23,530 --> 00:18:33,200
forward some somehow for example many

00:18:28,010 --> 00:18:36,710
schools when they succeed some portions

00:18:33,200 --> 00:18:38,630
of memory are filled with some useful

00:18:36,710 --> 00:18:41,890
information by the kernel so for them

00:18:38,630 --> 00:18:45,410
this is not as easy but for simple

00:18:41,890 --> 00:18:48,160
discourse like handling its work from

00:18:45,410 --> 00:18:48,160
current master

00:18:52,620 --> 00:18:59,370
probably forgot to tell that the this

00:18:55,630 --> 00:19:03,220
API Astraeus is using is called Petrus

00:18:59,370 --> 00:19:06,400
it's the same API used by the

00:19:03,220 --> 00:19:11,160
traditional interface as I think about

00:19:06,400 --> 00:19:16,030
stress so it's the same as used by gdb

00:19:11,160 --> 00:19:19,960
it's more or less that all I would like

00:19:16,030 --> 00:19:20,950
to tell about fault injection but I can

00:19:19,960 --> 00:19:26,530
answer your questions

00:19:20,950 --> 00:19:30,940
because some some things are better on

00:19:26,530 --> 00:19:33,550
certain questions so by the way the

00:19:30,940 --> 00:19:38,140
title of this talk was probably invented

00:19:33,550 --> 00:19:43,530
by the student who made this jisub

00:19:38,140 --> 00:19:48,010
project he can visit his sock page and

00:19:43,530 --> 00:19:50,950
maybe you'll get an idea what was

00:19:48,010 --> 00:19:54,790
planned in the beginning and how it's

00:19:50,950 --> 00:19:58,420
changed and compare these things you can

00:19:54,790 --> 00:20:02,980
grab the source Cisco fault injection is

00:19:58,420 --> 00:20:09,930
part of the recent release which was in

00:20:02,980 --> 00:20:09,930
December I think so it's you can use it

00:20:12,179 --> 00:20:29,669
bigger thing so this full injection

00:20:25,919 --> 00:20:32,470
makes a stretch a testing tool but I

00:20:29,669 --> 00:20:35,950
it's quite a modern thing so I'm not

00:20:32,470 --> 00:20:40,899
sure it's already widely used as a

00:20:35,950 --> 00:20:44,200
testing tool I am stuck I'm thinking of

00:20:40,899 --> 00:20:47,860
using stress itself for a stress this

00:20:44,200 --> 00:20:53,409
year because it's not easy to reproduce

00:20:47,860 --> 00:21:00,850
some faults related to pitch race system

00:20:53,409 --> 00:21:05,679
call for example but that's so just a

00:21:00,850 --> 00:21:09,009
new way of fault detection a new way of

00:21:05,679 --> 00:21:13,350
testing something that otherwise would

00:21:09,009 --> 00:21:16,740
require a compile-time instrumentation

00:21:13,350 --> 00:21:21,220
and probably the only

00:21:16,740 --> 00:21:25,110
runtime and privileged user space for

00:21:21,220 --> 00:21:25,110
the ejection tool for Linux we have now

00:21:26,009 --> 00:21:32,490
so I think it's time to ask questions

00:22:05,169 --> 00:22:17,209
so which one of slides so so the

00:22:14,329 --> 00:22:21,709
question the question was how cut was

00:22:17,209 --> 00:22:24,769
able to to complain about how cat was

00:22:21,709 --> 00:22:27,609
able to to report an error if linker was

00:22:24,769 --> 00:22:31,009
unable to load lip see it's not a cut

00:22:27,609 --> 00:22:35,209
the error diagnostic you see it comes

00:22:31,009 --> 00:22:39,979
from dynamic linker it's not a it's

00:22:35,209 --> 00:22:43,729
still a dynamic linker at this point so

00:22:39,979 --> 00:22:46,399
you can see the prefix is cat but it's

00:22:43,729 --> 00:22:49,369
not a cat it's dynamic linker who

00:22:46,399 --> 00:22:57,529
complains that it can't up award lip see

00:22:49,369 --> 00:22:59,690
and that's all any more questions yes

00:22:57,529 --> 00:23:02,769
please

00:22:59,690 --> 00:23:02,769
[Music]

00:23:27,960 --> 00:23:35,160
first of all I've been told so the

00:23:30,900 --> 00:23:38,040
question is why the current

00:23:35,160 --> 00:23:41,940
implementation uses an invalid Cisco

00:23:38,040 --> 00:23:46,380
number for fourth injection instead of

00:23:41,940 --> 00:23:51,630
using some harmless Cisco that has no

00:23:46,380 --> 00:23:55,680
side effects so that monitoring system

00:23:51,630 --> 00:23:58,410
like SELinux wouldn't or something like

00:23:55,680 --> 00:24:01,890
this out it with it wouldn't complain

00:23:58,410 --> 00:24:03,600
about something wrong is going on first

00:24:01,890 --> 00:24:06,000
of all it's not easy to find a hammer at

00:24:03,600 --> 00:24:10,170
Cisco I've been told yet recently that

00:24:06,000 --> 00:24:12,120
get bid might fail in current linux

00:24:10,170 --> 00:24:14,390
kernel's get bid my fellow it's not

00:24:12,120 --> 00:24:14,390
allowed

00:24:17,270 --> 00:24:28,710
ok so in theory it's possible to invoke

00:24:22,200 --> 00:24:33,480
a get beat I think it's not a technical

00:24:28,710 --> 00:24:38,690
issue but from optimization point of

00:24:33,480 --> 00:24:44,190
view it's less probably less work less

00:24:38,690 --> 00:24:48,390
you will need less Cisco indications to

00:24:44,190 --> 00:24:53,490
do this on on exigencies call you'll

00:24:48,390 --> 00:24:58,170
have to replace like two registers on

00:24:53,490 --> 00:25:00,720
some architectures and in case of in

00:24:58,170 --> 00:25:03,810
religious call it will not have to

00:25:00,720 --> 00:25:05,970
replace at least the register that

00:25:03,810 --> 00:25:10,230
contains the indication of the design

00:25:05,970 --> 00:25:12,330
error so it's slightly I think it's

00:25:10,230 --> 00:25:17,009
slightly

00:25:12,330 --> 00:25:20,059
faster to use an invalid Cisco but I

00:25:17,009 --> 00:25:25,700
think it's quite a valid point

00:25:20,059 --> 00:25:25,700
thank you any more questions

00:25:27,649 --> 00:25:36,139
no really okay ah yes please

00:25:47,610 --> 00:25:50,670
[Music]

00:25:50,719 --> 00:25:57,029
so the question is I heard it was is

00:25:54,419 --> 00:26:01,440
there anything probably external from

00:25:57,029 --> 00:26:08,609
states that do some random what's random

00:26:01,440 --> 00:26:15,179
ejection random and so in the initial G

00:26:08,609 --> 00:26:17,820
sock design there was an interface to do

00:26:15,179 --> 00:26:20,969
some random injection but later I

00:26:17,820 --> 00:26:26,459
decided that it's better done by a fuzzy

00:26:20,969 --> 00:26:29,789
driver that's per ancestries so my idea

00:26:26,459 --> 00:26:32,940
is that if you want randomness you just

00:26:29,789 --> 00:26:36,329
do it in a driver of the trance trace

00:26:32,940 --> 00:26:41,639
and not even stress itself so currently

00:26:36,329 --> 00:26:47,279
this injection is predictable there is

00:26:41,639 --> 00:26:52,859
no random injection but it might change

00:26:47,279 --> 00:26:56,129
if somebody would suggest a plausible

00:26:52,859 --> 00:26:58,409
case how how this would be used as

00:26:56,129 --> 00:27:02,479
currently I think is better done in a

00:26:58,409 --> 00:27:02,479
fuzzy driver outside

00:27:14,769 --> 00:27:27,980
is it a problem with the comment line is

00:27:19,250 --> 00:27:37,340
long okay does anybody have any more

00:27:27,980 --> 00:27:39,769
questions yes please I'm not sure I hear

00:27:37,340 --> 00:27:41,840
anything but I will have to repeat what

00:27:39,769 --> 00:27:56,289
you are saying so please make it he will

00:27:41,840 --> 00:28:00,799
at least for me okay so Steve said that

00:27:56,289 --> 00:28:13,399
it's a relation isn't like just a good

00:28:00,799 --> 00:28:15,880
words about this okay so coming up next

00:28:13,399 --> 00:28:19,510
in this room we have a quick talk on

00:28:15,880 --> 00:28:19,510

YouTube URL: https://www.youtube.com/watch?v=fYMDzk6HYGU


