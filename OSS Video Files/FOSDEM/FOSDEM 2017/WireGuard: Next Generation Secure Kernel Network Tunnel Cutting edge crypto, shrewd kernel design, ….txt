Title: WireGuard: Next Generation Secure Kernel Network Tunnel Cutting edge crypto, shrewd kernel design, …
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	WireGuard: Next Generation Secure Kernel Network Tunnel Cutting edge crypto, shrewd kernel design, and networking meet in a surprisingly simple combination
by Jason A. Donenfeld

At: FOSDEM 2017

WireGuard is a next generation VPN protocol, which lives in the Linux kernel,and uses state of the art cryptography. One of the most exciting recentcrypto-networking developments, WireGuard aims to drastically simplify securetunneling. The current state of VPN protocols is not pretty, with popularoptions, such as IPsec and OpenVPN, being overwhelmingly complex, with largeattack surfaces, using mostly cryptographic designs from the 90s. WireGuardpresents a new abuse-resistant and high-performance alternative based onmodern cryptography, with a focus on implementation and usability simplicity.It uses a 1-RTT handshake, based on NoiseIK, to provide perfect forwardsecrecy, identity hiding, and resistance to key-compromise impersonationattacks, among other important security properties, as well as highperformance transport using ChaCha20Poly1305. A novel IP-binding cookie MACmechanism is used to prevent against several forms of common denial-of-serviceattacks, both against the client and server, improving greatly on those ofDTLS and IKEv2. Key distribution is handled out-of-band with extremely shortCurve25519 points, which can be passed around in the likes of OpenSSH.Discarding the academic layering perfection of IPsec, WireGuard introduces theidea of a "cryptokey routing table", alongside an extremely simple and fullydefined timer-state mechanism, to allow for easy and minimal configuration;WireGuard is actually securely deployable in practical settings. In order torival the performance of IPsec, WireGuard is implemented inside the Linuxkernel, but unlike IPsec, it is implemented in less than 4,000 lines of code,making the implementation manageably auditable. These features converge tocreate an open source VPN utility that is exceedingly simple, yet thoroughlymodern and secure.

The presentation will be divided up into several parts. First, there will bean overview of the problems with IPsec, OpenVPN, and other popular VPNs,outlining attacks and weaknesses. Next, the WireGuard idea of the "cryptokeyrouting table" will be introduced, and we’ll walk through several propertiesderived from it. This will transition into a discussion of the timer statemechanism, and how secure protocols are necessarily stateful, but it’spossible to make them appear stateless to the user by exhaustively definingall possible state transitions. Then we’ll get into the hardcore meat of thepresentation: the cryptography and various crypto innovations behindWireGuard. We will discuss the triple Diffie-Hellman, the role of combiningstatic and ephemeral keys, the performance and DoS-potential of Curve25519point multiplication, using a PRF chaining for rotating keys, identity hidingand remaining silent on a network, and clever usage of authenticatedencryption with additional data. We will examine the various attack models,and enumerate the cryptographic mitigations employed by WireGuard. The sumwill be a comprehensive overview of modern day crypto tricks, attacks, anduseful constructions, and how these insights have been funneled intoWireGuard. Finally, we’ll examine the Linux kernel implementation ofWireGuard, seeing how it’s possible to avoid allocations in response tounauthenticated packets as a defense coding technique. During thepresentation, a live WireGuard endpoint will be provided to audience memberswho wish to send packets, whether encrypted, legitimate, malformed, dubious,or otherwise curious.

Threaded throughout will be an enumeration of attacks on existing protocolsand cryptographic tricks for their mitigation.

My background is in security -- kernels, hardware, reversing, crypto, largenetworks, etc -- and as such I've broken a lot of systems with some noveltricks and protocol insights. WireGuard is motivated by a sort of cornucopiaof clever attacks (crypto and otherwise) against other networks. I made itbecause I wanted something I could actually confidently run on my owninfrastructure, and none of the other tools were nearly up to the task. So,this talk is going to go into depth about real attacks on various protocols,in addition to unveiling some techniques to avoid entire classes of attacks.

Finally, since WireGuard is initially implemented for the Linux kernel, therehave been some very interesting considerations to account for with kernelprogramming. Cross platform implementations are also in the works, written inGo and Rust.


Room: Janson
Scheduled start: 2017-02-05 13:00:00
Captions: 
	00:00:03,240 --> 00:00:10,799
so this is on wire guard which is a new

00:00:06,640 --> 00:00:13,660
VPN which aims to be fast modern secure

00:00:10,799 --> 00:00:18,400
so first a little bit a background about

00:00:13,660 --> 00:00:22,210
myself my background is in exploitation

00:00:18,400 --> 00:00:25,260
and kernel vulnerabilities and offensive

00:00:22,210 --> 00:00:27,760
Security's finding bugs exploiting bugs

00:00:25,260 --> 00:00:33,340
but I've done a lot of development as

00:00:27,760 --> 00:00:35,470
well and in researching other projects I

00:00:33,340 --> 00:00:36,879
see the same types of bugs come up over

00:00:35,470 --> 00:00:40,299
and over same types of fundamental

00:00:36,879 --> 00:00:41,920
problems and seeing that secure tunnels

00:00:40,299 --> 00:00:44,860
are such an important element to have a

00:00:41,920 --> 00:00:47,290
networks I decided to take what I've

00:00:44,860 --> 00:00:49,570
learned from doing offensive security

00:00:47,290 --> 00:00:55,059
and try and make something really simple

00:00:49,570 --> 00:00:57,250
and nice that you can use so what is

00:00:55,059 --> 00:01:02,199
wire guard it's a layer 3 network tunnel

00:00:57,250 --> 00:01:04,570
so it's for only IP not for layer 2 not

00:01:02,199 --> 00:01:06,640
for Ethernet just a layer 3 network

00:01:04,570 --> 00:01:08,830
tunnel and as we'll see throughout this

00:01:06,640 --> 00:01:11,320
presentation it makes a lot of choices

00:01:08,830 --> 00:01:13,180
like that it's only for layer 3 it only

00:01:11,320 --> 00:01:16,150
does particular things because it's

00:01:13,180 --> 00:01:18,340
opinionated it's made with a series of

00:01:16,150 --> 00:01:20,140
design considerations where the choice

00:01:18,340 --> 00:01:23,920
has been made for you in a lot of ways

00:01:20,140 --> 00:01:25,930
but from these boiled down choices we

00:01:23,920 --> 00:01:28,980
make nice building blocks that then you

00:01:25,930 --> 00:01:32,140
can make big complicated systems out of

00:01:28,980 --> 00:01:35,020
it lives in the Linux kernel for

00:01:32,140 --> 00:01:36,360
performance and for good integration but

00:01:35,020 --> 00:01:39,730
we've got some cross-platform

00:01:36,360 --> 00:01:42,580
implementations and in the works in

00:01:39,730 --> 00:01:44,080
languages like rust and go but for at

00:01:42,580 --> 00:01:48,400
the moment lives in the Linux kernel run

00:01:44,080 --> 00:01:50,320
in see it's udp-based and so it it can

00:01:48,400 --> 00:01:52,080
live on the real internet punching

00:01:50,320 --> 00:01:55,450
through firewalls

00:01:52,080 --> 00:01:58,140
we use modern cryptography but we're

00:01:55,450 --> 00:02:02,290
very careful to use conservative

00:01:58,140 --> 00:02:06,490
cryptography proven principles nothing

00:02:02,290 --> 00:02:09,399
too newfangled and the project as a

00:02:06,490 --> 00:02:12,100
whole has a real emphasis on being very

00:02:09,399 --> 00:02:15,010
simple easy to understand concepts easy

00:02:12,100 --> 00:02:15,580
to understand code just trying to make a

00:02:15,010 --> 00:02:19,840
nice

00:02:15,580 --> 00:02:23,020
minimal nice minimal structure the

00:02:19,840 --> 00:02:26,920
authentication model aims to be like SSH

00:02:23,020 --> 00:02:29,560
and SSH you usually share keys by

00:02:26,920 --> 00:02:31,870
sending your public key through an

00:02:29,560 --> 00:02:34,450
encrypted email or through some other

00:02:31,870 --> 00:02:35,830
mechanism and you know you have simple

00:02:34,450 --> 00:02:38,680
public keys that you copy and paste

00:02:35,830 --> 00:02:40,780
around I'm sure all you guys use SSH so

00:02:38,680 --> 00:02:41,080
why are guard tries to be as easy as

00:02:40,780 --> 00:02:45,520
that

00:02:41,080 --> 00:02:49,330
but for VPN in general its aims to be a

00:02:45,520 --> 00:02:52,600
replacement for Open VPN and IPSec and

00:02:49,330 --> 00:02:55,330
the various other VPN technologies that

00:02:52,600 --> 00:02:57,820
are out there some that live in kernels

00:02:55,330 --> 00:02:59,770
some that live in in user space why our

00:02:57,820 --> 00:03:04,750
guard tries to replace most of that with

00:02:59,770 --> 00:03:07,090
something a lot simpler most of all wire

00:03:04,750 --> 00:03:09,520
guard is easily auditable when you look

00:03:07,090 --> 00:03:12,220
at Open VPN it's a hundred sixteen

00:03:09,520 --> 00:03:16,060
thousand lines of code plus all of open

00:03:12,220 --> 00:03:19,600
SSL and so maybe you could make that

00:03:16,060 --> 00:03:21,489
codebase secure eventually maybe you

00:03:19,600 --> 00:03:23,769
need to pay a lot of people a lot of

00:03:21,489 --> 00:03:27,820
money to read all that and audit a big

00:03:23,769 --> 00:03:30,310
project the Linux XFR M layer which does

00:03:27,820 --> 00:03:32,560
IPSec is thirteen thousand lines of code

00:03:30,310 --> 00:03:34,600
plus something like strongswan for the

00:03:32,560 --> 00:03:37,470
key exchange which itself is four

00:03:34,600 --> 00:03:39,730
hundred five thousand lines of code and

00:03:37,470 --> 00:03:41,440
I mean these are these are you know

00:03:39,730 --> 00:03:44,080
great projects with smart people who

00:03:41,440 --> 00:03:47,769
have worked on them but this is a lot of

00:03:44,080 --> 00:03:50,830
code to read and we're talking about C

00:03:47,769 --> 00:03:53,260
code and so this is hard to really be

00:03:50,830 --> 00:03:54,580
sure that you're using somebody secure

00:03:53,260 --> 00:03:56,230
soft ether is kind of a

00:03:54,580 --> 00:03:59,530
jack-of-all-trades solution that

00:03:56,230 --> 00:04:02,019
supports Open VPN supports IPSec

00:03:59,530 --> 00:04:04,030
supports all sorts of things carriage of

00:04:02,019 --> 00:04:07,000
29,000 dollars of code wire guard is

00:04:04,030 --> 00:04:09,070
under 4,000 lines of code which means

00:04:07,000 --> 00:04:11,620
everybody in this room can sit down to

00:04:09,070 --> 00:04:14,350
read the entire code base in one sitting

00:04:11,620 --> 00:04:16,690
in an afternoon understand it security

00:04:14,350 --> 00:04:20,320
experts can read it just for fun because

00:04:16,690 --> 00:04:21,970
it's short enough that it's still fun so

00:04:20,320 --> 00:04:25,539
that it actually gets some eyeballs so

00:04:21,970 --> 00:04:28,410
just to put this in perspective in the

00:04:25,539 --> 00:04:35,040
in the solar system of VPNs

00:04:28,410 --> 00:04:38,670
I guess we're Pluto okay it's also

00:04:35,040 --> 00:04:43,280
really simple to use rather than say

00:04:38,670 --> 00:04:46,650
that complicated IP SEC X frm system or

00:04:43,280 --> 00:04:49,560
openvpn Damons with y regard you just

00:04:46,650 --> 00:04:51,360
get a normal network interface that you

00:04:49,560 --> 00:04:55,170
can administer using all the tools you

00:04:51,360 --> 00:04:57,420
already know with the IP route etc so to

00:04:55,170 --> 00:04:59,850
add a wire guard interface see IP link

00:04:57,420 --> 00:05:01,770
add just like you would with any other

00:04:59,850 --> 00:05:04,290
kind of virtual interface to set the

00:05:01,770 --> 00:05:05,360
address IP address or I have come fig if

00:05:04,290 --> 00:05:08,310
you like that

00:05:05,360 --> 00:05:12,030
routing it's the same way and you can

00:05:08,310 --> 00:05:14,190
use IP tables if you're into old-style

00:05:12,030 --> 00:05:17,010
host based authentication you can even

00:05:14,190 --> 00:05:20,100
use Etsy hosts you can bind to the

00:05:17,010 --> 00:05:21,960
addresses of that interface because with

00:05:20,100 --> 00:05:26,880
wire guard you just have the interface

00:05:21,960 --> 00:05:28,290
it's a simple fundamental concept and it

00:05:26,880 --> 00:05:29,510
allows you to use all the things that

00:05:28,290 --> 00:05:32,250
you already know about

00:05:29,510 --> 00:05:34,530
so everything that ordinary ordinarily

00:05:32,250 --> 00:05:38,250
builds on top of a network interface

00:05:34,530 --> 00:05:41,430
like eth0 wlan0 you can build on top of

00:05:38,250 --> 00:05:43,110
WG zero for wire guard so you don't

00:05:41,430 --> 00:05:45,660
really have to learn that much that's

00:05:43,110 --> 00:05:50,460
new the other head

00:05:45,660 --> 00:05:53,520
wire guard is a bit blasphemous IPSec is

00:05:50,460 --> 00:05:57,330
is nice in a lot of ways it was made by

00:05:53,520 --> 00:05:59,250
a big committee it was engineered by a

00:05:57,330 --> 00:06:02,220
lot of people and it does all the nice

00:05:59,250 --> 00:06:04,320
layering in a very pristine way a lot of

00:06:02,220 --> 00:06:06,000
people looked into which component

00:06:04,320 --> 00:06:08,820
should have which responsibilities how

00:06:06,000 --> 00:06:11,820
to separate all this out and it's nice

00:06:08,820 --> 00:06:14,010
but it's also super complicated hard to

00:06:11,820 --> 00:06:15,930
implement prone to bugs if you ever

00:06:14,010 --> 00:06:17,340
tried to set it up you can't even wrap

00:06:15,930 --> 00:06:20,640
your mind around all the different

00:06:17,340 --> 00:06:23,190
layers and so why are guard actually

00:06:20,640 --> 00:06:25,470
breaks these these networking

00:06:23,190 --> 00:06:29,100
assumptions from the 90s where you have

00:06:25,470 --> 00:06:31,740
these nice layers and instead we do

00:06:29,100 --> 00:06:34,590
something that's on the surface wrong we

00:06:31,740 --> 00:06:35,850
smush everything together and then from

00:06:34,590 --> 00:06:38,789
there we try and come up with good

00:06:35,850 --> 00:06:41,199
engineering solutions to to regain the

00:06:38,789 --> 00:06:43,810
coherence

00:06:41,199 --> 00:06:46,210
and so that way it's it's remains simple

00:06:43,810 --> 00:06:51,849
but it still works and it still has a

00:06:46,210 --> 00:06:54,090
solid foundation so how do we do this

00:06:51,849 --> 00:06:58,629
the fundamental idea of wire guard is

00:06:54,090 --> 00:07:02,409
cryptokey routing so the idea here is

00:06:58,629 --> 00:07:04,599
you have a peer and you have a list of

00:07:02,409 --> 00:07:07,990
IP addresses that that peer is allowed

00:07:04,599 --> 00:07:09,610
to be and the peer is identified by a

00:07:07,990 --> 00:07:11,860
public key and so you have a mapping

00:07:09,610 --> 00:07:15,699
always between public keys that are used

00:07:11,860 --> 00:07:18,159
and IP addresses that are used so more

00:07:15,699 --> 00:07:21,159
generally the wire guard interface WG

00:07:18,159 --> 00:07:24,099
zero itself has its own private key it

00:07:21,159 --> 00:07:26,590
has a listening UDP port and it has a

00:07:24,099 --> 00:07:28,840
list of peers that it can talk to then

00:07:26,590 --> 00:07:32,650
each peer is identified by its public

00:07:28,840 --> 00:07:34,710
key this list of allowed IP is that that

00:07:32,650 --> 00:07:37,569
public key is allowed to be and

00:07:34,710 --> 00:07:39,610
optionally as we'll see you later the

00:07:37,569 --> 00:07:43,560
end point on the Internet of the other

00:07:39,610 --> 00:07:43,560
UDP port that you're talking to

00:07:43,590 --> 00:07:48,669
so just to drive this home the the

00:07:46,050 --> 00:07:50,379
fundamental idea here is relation

00:07:48,669 --> 00:07:54,400
between the public key and the IP

00:07:50,379 --> 00:07:56,589
address is super important so here's

00:07:54,400 --> 00:08:00,339
what a configuration might look at look

00:07:56,589 --> 00:08:02,680
like a server has the interface section

00:08:00,339 --> 00:08:04,690
with its private key and it's listen

00:08:02,680 --> 00:08:09,009
port and then this happens to have two

00:08:04,690 --> 00:08:11,560
peers and for the first peer it's

00:08:09,009 --> 00:08:14,740
allowed to be that 10.19 T to address

00:08:11,560 --> 00:08:18,219
and the other ten that 192 address bus

00:08:14,740 --> 00:08:21,520
last 24 so the whole subnet the next

00:08:18,219 --> 00:08:25,599
peer gets its slash 32 and a slash 16

00:08:21,520 --> 00:08:28,150
and so those public keys when talking to

00:08:25,599 --> 00:08:30,699
the server can only send IP addresses

00:08:28,150 --> 00:08:34,719
can only some packets as IP addresses in

00:08:30,699 --> 00:08:37,390
those range on the other side a client

00:08:34,719 --> 00:08:38,919
has a configuration with again interface

00:08:37,390 --> 00:08:43,930
that has a private key in the listen

00:08:38,919 --> 00:08:46,510
port and it has a block for a peer

00:08:43,930 --> 00:08:48,970
that's the server and so it has the

00:08:46,510 --> 00:08:52,180
server's public key it has the endpoint

00:08:48,970 --> 00:08:54,730
of the server and it trusts the server

00:08:52,180 --> 00:08:58,089
to send it any IP for

00:08:54,730 --> 00:09:01,120
example maybe the server is a gateway to

00:08:58,089 --> 00:09:03,040
the Internet and so it's forwarding

00:09:01,120 --> 00:09:06,310
packets from any IP address on the

00:09:03,040 --> 00:09:10,180
Internet in that case it wants to allow

00:09:06,310 --> 00:09:11,800
any IP from the server now you'll notice

00:09:10,180 --> 00:09:14,290
that the server doesn't list any

00:09:11,800 --> 00:09:15,550
endpoints of the peers because it

00:09:14,290 --> 00:09:19,470
doesn't know them it's the server it's

00:09:15,550 --> 00:09:22,180
waiting for the client to connect to it

00:09:19,470 --> 00:09:25,120
but what happens is whenever the server

00:09:22,180 --> 00:09:27,550
gets an authenticated message from a

00:09:25,120 --> 00:09:30,010
client then it'll learn the latest end

00:09:27,550 --> 00:09:32,529
point of that client for sending reply

00:09:30,010 --> 00:09:34,959
packets so in that way clients can roam

00:09:32,529 --> 00:09:37,899
freely from different source IP

00:09:34,959 --> 00:09:43,720
addresses if you've ever used mush it

00:09:37,899 --> 00:09:46,600
works exactly like that so how does this

00:09:43,720 --> 00:09:49,329
work at the API level user space sends a

00:09:46,600 --> 00:09:51,430
packet using the census call then it

00:09:49,329 --> 00:09:53,829
goes to the ordinary Linux networking

00:09:51,430 --> 00:09:57,040
layer that decides ok this packet should

00:09:53,829 --> 00:09:59,610
go to the W g0 interface so now it's an

00:09:57,040 --> 00:10:02,319
R code now it's in the wire Guard driver

00:09:59,610 --> 00:10:05,350
wire guard looks at the destination IP

00:10:02,319 --> 00:10:07,449
address of that packet and says that

00:10:05,350 --> 00:10:10,000
destination IP address corresponds to

00:10:07,449 --> 00:10:12,160
this public key then it looks up what

00:10:10,000 --> 00:10:14,139
current session is used with that public

00:10:12,160 --> 00:10:17,500
key and encrypts it for that and sends

00:10:14,139 --> 00:10:20,920
it off to the endpoint in the reverse

00:10:17,500 --> 00:10:23,170
direction when the UDP socket receives

00:10:20,920 --> 00:10:28,000
an encrypted packet it decrypts it and

00:10:23,170 --> 00:10:29,410
learns for which public key it should

00:10:28,000 --> 00:10:31,510
use a key session for it then it

00:10:29,410 --> 00:10:33,490
inspects the source IP of that decrypted

00:10:31,510 --> 00:10:35,319
packet and says is that public key

00:10:33,490 --> 00:10:38,290
allowed to be sending packets as that

00:10:35,319 --> 00:10:40,120
source IP and if it is then it goes on

00:10:38,290 --> 00:10:46,060
to the interface and if not then it's

00:10:40,120 --> 00:10:49,810
dropped so all of this can be configured

00:10:46,060 --> 00:10:52,089
with very easy command-line tools right

00:10:49,810 --> 00:10:53,800
now it's it's the WG utility at some

00:10:52,089 --> 00:10:57,040
point this will be folded into the IP

00:10:53,800 --> 00:11:01,420
route to IP utility for now just WG very

00:10:57,040 --> 00:11:04,839
simple WG set W t0 you give the listen

00:11:01,420 --> 00:11:06,819
port the private key the peer plus its

00:11:04,839 --> 00:11:08,390
public key it's the loud IP as the

00:11:06,819 --> 00:11:10,800
endpoint and so forth

00:11:08,390 --> 00:11:13,110
it has that very simple configuration

00:11:10,800 --> 00:11:15,930
syntax as we saw before kind of the any

00:11:13,110 --> 00:11:18,780
syntax and so you could set config and

00:11:15,930 --> 00:11:21,240
get config WG Show gives you the nice

00:11:18,780 --> 00:11:24,030
colorize acts ASCII output and there are

00:11:21,240 --> 00:11:26,250
also various sub commands of that to get

00:11:24,030 --> 00:11:31,350
output that's good for parsing and in

00:11:26,250 --> 00:11:33,930
scripts for generating keys just W dgeni

00:11:31,350 --> 00:11:37,290
key to make a public key from a private

00:11:33,930 --> 00:11:40,490
key you pipe the private key into WG pub

00:11:37,290 --> 00:11:44,520
key and you get out the public key so

00:11:40,490 --> 00:11:46,620
very simple basic interface but from

00:11:44,520 --> 00:11:48,300
that you can setup tunnels to all sorts

00:11:46,620 --> 00:11:51,900
of peers in a super easy straightforward

00:11:48,300 --> 00:11:55,140
way and all the issues of cryptography

00:11:51,900 --> 00:11:56,960
session management etc are just handled

00:11:55,140 --> 00:11:59,940
transparently under the surface for you

00:11:56,960 --> 00:12:02,400
so to the system admin the whole

00:11:59,940 --> 00:12:05,840
interface appears stateless you just set

00:12:02,400 --> 00:12:10,110
it up here the peers and then it works

00:12:05,840 --> 00:12:13,140
and so because we have this relation

00:12:10,110 --> 00:12:15,690
between the public keys and and the IP

00:12:13,140 --> 00:12:19,380
addresses we know that if it comes from

00:12:15,690 --> 00:12:21,390
the wgz our interface and it's from this

00:12:19,380 --> 00:12:23,310
particular IP address then a must be

00:12:21,390 --> 00:12:27,900
from Yoshii through the tunnel it must

00:12:23,310 --> 00:12:29,610
be because it's from his public key so

00:12:27,900 --> 00:12:31,440
then with IP tables you can already

00:12:29,610 --> 00:12:34,440
start to imagine what your firewall

00:12:31,440 --> 00:12:38,190
rules are like you match on the input

00:12:34,440 --> 00:12:40,530
device of w0 the source address and then

00:12:38,190 --> 00:12:42,930
that's all you need so all the things

00:12:40,530 --> 00:12:46,589
you already know just layer nicely on

00:12:42,930 --> 00:12:48,870
top of this so as i said it's totally

00:12:46,589 --> 00:12:50,430
stateless you set it up and it works you

00:12:48,870 --> 00:12:51,960
just add the interface you can add as

00:12:50,430 --> 00:12:53,990
many interfaces as you want you can

00:12:51,960 --> 00:12:57,750
configure multiple peers per interface

00:12:53,990 --> 00:13:02,070
as I mentioned the endpoints just a roam

00:12:57,750 --> 00:13:03,750
so on 3G this is especially nice when

00:13:02,070 --> 00:13:05,550
you're going between different IP

00:13:03,750 --> 00:13:08,010
addresses your connections keep working

00:13:05,550 --> 00:13:09,900
on a laptop it's nice if you put your

00:13:08,010 --> 00:13:12,240
laptop to sleep in one network and turn

00:13:09,900 --> 00:13:13,770
on on the other it just starts working

00:13:12,240 --> 00:13:15,839
again automatically and you have the

00:13:13,770 --> 00:13:19,440
same IP address this before inside the

00:13:15,839 --> 00:13:21,810
tunnel and the identity is these public

00:13:19,440 --> 00:13:24,420
keys are really short

00:13:21,810 --> 00:13:28,019
they're 32 bytes and we encode it as

00:13:24,420 --> 00:13:30,870
base64 so I think it's 44 characters and

00:13:28,019 --> 00:13:32,120
so you can paste them around for for

00:13:30,870 --> 00:13:34,709
doing key exchange through any

00:13:32,120 --> 00:13:37,079
out-of-band mechanism we're not trying

00:13:34,709 --> 00:13:39,089
to handle that problem here because

00:13:37,079 --> 00:13:43,379
people are already doing that with

00:13:39,089 --> 00:13:47,519
things like SSH and GPG and all sorts of

00:13:43,379 --> 00:13:49,709
other mechanisms for that okay so before

00:13:47,519 --> 00:13:51,540
we go deep in how all this works I just

00:13:49,709 --> 00:13:54,389
want to show a demo of what it looks

00:13:51,540 --> 00:14:00,089
like to set up a wire interface you get

00:13:54,389 --> 00:14:03,529
the idea so we have pure a left pure B

00:14:00,089 --> 00:14:05,910
on the right and they're connected using

00:14:03,529 --> 00:14:08,399
virtual Ethernet so you can pretend

00:14:05,910 --> 00:14:11,749
that's the Internet and we'll set up

00:14:08,399 --> 00:14:14,970
some tunnels so what's this look like

00:14:11,749 --> 00:14:16,680
okay so we generate a private key over

00:14:14,970 --> 00:14:18,480
there we generate a private key over

00:14:16,680 --> 00:14:20,970
there and when we cat it that's the

00:14:18,480 --> 00:14:23,339
private key super-short we derive the

00:14:20,970 --> 00:14:27,029
public key from the private key we do

00:14:23,339 --> 00:14:30,600
the same over there and now we add the

00:14:27,029 --> 00:14:33,389
wire grid interface we set an IP for the

00:14:30,600 --> 00:14:37,230
wire guard interface which again using

00:14:33,389 --> 00:14:40,290
the IP route to tool things every system

00:14:37,230 --> 00:14:42,839
admin already knows now we set up the

00:14:40,290 --> 00:14:46,110
peer so we give the private key of our

00:14:42,839 --> 00:14:48,300
interface as private and then we set the

00:14:46,110 --> 00:14:52,370
interface up now we'll do the exact same

00:14:48,300 --> 00:14:58,470
thing over here we add the wd0 interface

00:14:52,370 --> 00:15:01,790
we give it the IP address we give it the

00:14:58,470 --> 00:15:01,790
private key of its interface

00:15:02,150 --> 00:15:08,050
and we set it up okay so now we have to

00:15:05,900 --> 00:15:10,610
tell the two peers about each other so

00:15:08,050 --> 00:15:12,770
first when we type IP address we see

00:15:10,610 --> 00:15:15,920
that it's just WG zero there it's just a

00:15:12,770 --> 00:15:19,700
normal interface eth0 is our internet

00:15:15,920 --> 00:15:23,180
interface our external interface if you

00:15:19,700 --> 00:15:24,740
will and so it's it's all in there just

00:15:23,180 --> 00:15:28,930
like another interface that you've seen

00:15:24,740 --> 00:15:28,930
before nothing nothing too remarkable

00:15:29,140 --> 00:15:32,990
okay so we type WG and we get the

00:15:32,450 --> 00:15:35,840
information

00:15:32,990 --> 00:15:37,970
each currently has about itself but now

00:15:35,840 --> 00:15:40,520
we tell it about the other so first we

00:15:37,970 --> 00:15:42,890
copy the public key from one as a peer

00:15:40,520 --> 00:15:47,240
for the other and we say that that peer

00:15:42,890 --> 00:15:51,830
is allowed to be 10 - OH - OH - and it's

00:15:47,240 --> 00:15:55,610
Internet endpoint is 192 168 1.25 180 -

00:15:51,830 --> 00:15:59,180
oh we do the reverse thing on the other

00:15:55,610 --> 00:16:03,260
side we make up here we copy and paste

00:15:59,180 --> 00:16:05,390
the public key for that peer we give it

00:16:03,260 --> 00:16:09,320
the allowed IP address for inside the

00:16:05,390 --> 00:16:11,300
tunnel and we give it the Internet

00:16:09,320 --> 00:16:14,060
endpoint one and two and sixty-eight one

00:16:11,300 --> 00:16:15,470
one five one eight - will so now the

00:16:14,060 --> 00:16:17,960
peers are set up they know about each

00:16:15,470 --> 00:16:20,200
other and now we can simply ping within

00:16:17,960 --> 00:16:22,850
the interface and it works and that's it

00:16:20,200 --> 00:16:24,950
we didn't have to set a daemon we didn't

00:16:22,850 --> 00:16:26,090
have to set a state it just works and

00:16:24,950 --> 00:16:29,300
now they know about each other

00:16:26,090 --> 00:16:32,570
they've done the handshake so pretty

00:16:29,300 --> 00:16:35,270
pretty simple situation and that's about

00:16:32,570 --> 00:16:37,610
in - the interface of wire guard there's

00:16:35,270 --> 00:16:39,560
not a whole lot more than that but from

00:16:37,610 --> 00:16:41,510
a very basic building block you can

00:16:39,560 --> 00:16:48,050
start layering some really neat things

00:16:41,510 --> 00:16:52,580
so as I mentioned simple composable tool

00:16:48,050 --> 00:16:54,410
this w g WG utility it's already started

00:16:52,580 --> 00:16:56,630
to get integration to the various

00:16:54,410 --> 00:16:59,600
network management utilities there's an

00:16:56,630 --> 00:17:03,020
up/down plugin for it it's already in

00:16:59,600 --> 00:17:07,160
open wrt and lead it's there's a nice

00:17:03,020 --> 00:17:10,790
Lucci web interface for it they're open

00:17:07,160 --> 00:17:15,020
RC supports it with net IFR C it's part

00:17:10,790 --> 00:17:15,980
of the whole NIC so ask system there's a

00:17:15,020 --> 00:17:17,689
work-in-progress - in

00:17:15,980 --> 00:17:19,100
right into system D Network D and

00:17:17,689 --> 00:17:21,079
there's also another work-in-progress

00:17:19,100 --> 00:17:24,890
to integrate it into network manager if

00:17:21,079 --> 00:17:28,069
that's your thing and and so it's it's

00:17:24,890 --> 00:17:30,830
it's being integrated I wrote a very

00:17:28,069 --> 00:17:34,280
simple shell script called WG quick

00:17:30,830 --> 00:17:37,010
which is not a sophisticated tool it's

00:17:34,280 --> 00:17:39,080
just quick and dirty bash script that I

00:17:37,010 --> 00:17:43,040
use on a daily basis connecting to VPNs

00:17:39,080 --> 00:17:45,919
you just have WG quick up and WG quick

00:17:43,040 --> 00:17:49,070
down and then you define this config

00:17:45,919 --> 00:17:52,760
file which is the same for syntaxes WG

00:17:49,070 --> 00:17:55,130
but we add a couple keys like a we can

00:17:52,760 --> 00:17:58,850
run a post up in a post down script for

00:17:55,130 --> 00:18:01,299
DNS and it lives in su wire guard and

00:17:58,850 --> 00:18:03,710
then the name of your interface Kampf

00:18:01,299 --> 00:18:05,360
but again this is done a sophisticated

00:18:03,710 --> 00:18:08,240
utility a simple bash script that just

00:18:05,360 --> 00:18:10,460
uses all the other things and I like

00:18:08,240 --> 00:18:12,650
this and I distribute it and other

00:18:10,460 --> 00:18:15,320
people use it but because the building

00:18:12,650 --> 00:18:17,419
blocks are so basic you have more than

00:18:15,320 --> 00:18:21,230
enough license to make whatever other

00:18:17,419 --> 00:18:24,169
complex tool you want there also some

00:18:21,230 --> 00:18:26,750
nice network namespace tricks that you

00:18:24,169 --> 00:18:28,640
can do with wire guard the wire guard

00:18:26,750 --> 00:18:31,010
interface can live in one network

00:18:28,640 --> 00:18:32,840
namespace well the UDP socket that it

00:18:31,010 --> 00:18:35,120
uses to send the encrypted packets to

00:18:32,840 --> 00:18:38,540
the Internet lives in another namespace

00:18:35,120 --> 00:18:40,880
so a couple uses you could let a docker

00:18:38,540 --> 00:18:43,940
container connect via a wire guard you

00:18:40,880 --> 00:18:45,559
could you could only let your DHCP

00:18:43,940 --> 00:18:47,990
client touch to your physical interfaces

00:18:45,559 --> 00:18:50,090
but then your web browser can only see

00:18:47,990 --> 00:18:51,799
the wire guard interface and this is a

00:18:50,090 --> 00:18:54,140
nice alternative to the routing tricks

00:18:51,799 --> 00:18:56,000
which of course wire guard also supports

00:18:54,140 --> 00:18:59,390
but this is a nice alternative if you

00:18:56,000 --> 00:19:01,070
want some high security so for

00:18:59,390 --> 00:19:02,960
containers it would look like this you

00:19:01,070 --> 00:19:06,350
have your container namespace running

00:19:02,960 --> 00:19:10,100
whatever docker rocket and spawn stuff

00:19:06,350 --> 00:19:11,540
and you ping from that and then the WG

00:19:10,100 --> 00:19:14,360
zero interface and Cripps it and it

00:19:11,540 --> 00:19:16,730
sends the UDP ciphertext out of the

00:19:14,360 --> 00:19:21,080
namespace in the in a namespace through

00:19:16,730 --> 00:19:23,600
your actual Ethernet adapter and so to

00:19:21,080 --> 00:19:26,510
the container namespace itself all it

00:19:23,600 --> 00:19:29,150
sees is WG zero and local host of course

00:19:26,510 --> 00:19:31,240
but it doesn't see any other way of

00:19:29,150 --> 00:19:34,940
getting to the intern

00:19:31,240 --> 00:19:38,360
conversely if you just want a leak-free

00:19:34,940 --> 00:19:40,880
personal VPN for your web browser in the

00:19:38,360 --> 00:19:41,570
init namespace that you're doing all

00:19:40,880 --> 00:19:44,179
your working

00:19:41,570 --> 00:19:47,570
you only have WG zero and then you move

00:19:44,179 --> 00:19:51,289
your physical interfaces to some other

00:19:47,570 --> 00:19:52,220
name space where the socket lives and

00:19:51,289 --> 00:19:56,080
this is really nice because it

00:19:52,220 --> 00:19:59,929
guarantees that there won't be any leaks

00:19:56,080 --> 00:20:01,520
from your web browser outside of the

00:19:59,929 --> 00:20:03,049
wire interface because your web browser

00:20:01,520 --> 00:20:06,440
can't see any other interfaces in

00:20:03,049 --> 00:20:08,809
packets um all right so there are a lot

00:20:06,440 --> 00:20:11,059
of security principles that have gone

00:20:08,809 --> 00:20:12,710
into making la Garde to make it both

00:20:11,059 --> 00:20:16,750
small and simple as we've discussed but

00:20:12,710 --> 00:20:19,880
also I hope a well-written piece of code

00:20:16,750 --> 00:20:22,700
all the state that's required for wire

00:20:19,880 --> 00:20:26,570
guard to work is allocated when you add

00:20:22,700 --> 00:20:29,059
peers not when you're getting packets so

00:20:26,570 --> 00:20:31,820
this this eliminates a huge class of

00:20:29,059 --> 00:20:33,169
dynamic memory vulnerabilities why our

00:20:31,820 --> 00:20:34,789
guard simply just doesn't have them

00:20:33,169 --> 00:20:36,320
because we just don't use that

00:20:34,789 --> 00:20:39,620
programming technique that's prone to

00:20:36,320 --> 00:20:42,799
that vulnerabilities likewise all packet

00:20:39,620 --> 00:20:46,039
headers are fixed in length in each

00:20:42,799 --> 00:20:48,140
field has a fixed length and so we don't

00:20:46,039 --> 00:20:50,120
have to parse anything there's nothing

00:20:48,140 --> 00:20:53,840
to parse so there are no parser bugs

00:20:50,120 --> 00:20:56,899
because we have no parser there this is

00:20:53,840 --> 00:20:59,059
so ridiculously simple but in doing so

00:20:56,899 --> 00:21:02,809
we just eliminate a massive class of

00:20:59,059 --> 00:21:05,240
vulnerabilities and then the last one is

00:21:02,809 --> 00:21:07,820
a little bit more sophisticated to

00:21:05,240 --> 00:21:10,039
implement we don't want to modify any

00:21:07,820 --> 00:21:13,100
state of the program any type of state

00:21:10,039 --> 00:21:17,210
in a response to unauthenticated packets

00:21:13,100 --> 00:21:20,360
and this is important for preventing a

00:21:17,210 --> 00:21:22,070
lot of logic based former abilities if a

00:21:20,360 --> 00:21:23,929
packet is authenticated we just don't

00:21:22,070 --> 00:21:25,669
want to change any variables we want to

00:21:23,929 --> 00:21:29,299
reject it as soon as possible and move

00:21:25,669 --> 00:21:32,419
on so we'll go into how how we

00:21:29,299 --> 00:21:35,779
accomplish all this another principle is

00:21:32,419 --> 00:21:36,440
we want wire guard to be stealthy as as

00:21:35,779 --> 00:21:39,890
the

00:21:36,440 --> 00:21:42,410
as mentioned in the introduction I do a

00:21:39,890 --> 00:21:44,270
lot of offensive security and why regard

00:21:42,410 --> 00:21:47,930
actually grew out of an exfiltration

00:21:44,270 --> 00:21:52,660
method of a rootkit I was working on so

00:21:47,930 --> 00:21:55,880
needed to be super stealthy hide packets

00:21:52,660 --> 00:21:58,700
not be discoverable by scanners and so

00:21:55,880 --> 00:22:00,260
wire guard inherits all of this it turns

00:21:58,700 --> 00:22:02,150
out that a lot of those principles that

00:22:00,260 --> 00:22:04,280
are applied to offensive security are

00:22:02,150 --> 00:22:07,910
actually really good too in defending a

00:22:04,280 --> 00:22:10,970
network so wire guard doesn't reply to

00:22:07,910 --> 00:22:13,070
any unauthenticated packets so it's

00:22:10,970 --> 00:22:14,870
completely invisible to porch scanners

00:22:13,070 --> 00:22:17,320
on the network if you don't know it's

00:22:14,870 --> 00:22:21,080
there then you won't know what's there

00:22:17,320 --> 00:22:23,540
it's also not chatty so when two peers

00:22:21,080 --> 00:22:25,520
aren't sending data to each other it

00:22:23,540 --> 00:22:31,910
just goes to sleep and it doesn't send

00:22:25,520 --> 00:22:34,280
anything okay of course all of this

00:22:31,910 --> 00:22:36,580
wouldn't matter at all if the crypto was

00:22:34,280 --> 00:22:40,370
bad so we put a lot of effort into

00:22:36,580 --> 00:22:43,430
ensuring its solid crypto we use Trevor

00:22:40,370 --> 00:22:45,470
parens noise protocol framework which is

00:22:43,430 --> 00:22:48,050
now used by whatsapp and is starting to

00:22:45,470 --> 00:22:50,000
get some steam it has perfect forward

00:22:48,050 --> 00:22:54,680
secrecy so there's a new key every two

00:22:50,000 --> 00:22:57,110
minutes so if if the computers are

00:22:54,680 --> 00:22:59,330
compromised you can't get the static

00:22:57,110 --> 00:23:01,100
keys and then go back to see the

00:22:59,330 --> 00:23:02,390
information that was transferred because

00:23:01,100 --> 00:23:04,640
there's a new ephemeral key that's

00:23:02,390 --> 00:23:07,570
generated every two minutes it avoids

00:23:04,640 --> 00:23:09,890
key compromise impersonation which is

00:23:07,570 --> 00:23:10,760
important quality if someone steals your

00:23:09,890 --> 00:23:13,880
private key

00:23:10,760 --> 00:23:15,170
they can't impersonate anybody to you

00:23:13,880 --> 00:23:16,850
even though they have your private key

00:23:15,170 --> 00:23:19,400
so this is important if two principal

00:23:16,850 --> 00:23:21,080
there's identity hiding so when you

00:23:19,400 --> 00:23:22,990
identify yourself to another appear you

00:23:21,080 --> 00:23:26,120
don't actually send your public key in

00:23:22,990 --> 00:23:28,370
clear text it's actually encrypted so

00:23:26,120 --> 00:23:30,410
that only the recipient of your public

00:23:28,370 --> 00:23:32,030
key can read it so it's impossible to

00:23:30,410 --> 00:23:35,510
tell who is actually sending the message

00:23:32,030 --> 00:23:37,070
unless you're expecting the message of

00:23:35,510 --> 00:23:41,110
course we use authenticated encryption

00:23:37,070 --> 00:23:43,730
so not only is all the information

00:23:41,110 --> 00:23:47,180
private but we also ensure the integrity

00:23:43,730 --> 00:23:48,980
there's replay attack prevention while

00:23:47,180 --> 00:23:50,720
still allowing for

00:23:48,980 --> 00:23:52,790
the network to reorder packets as

00:23:50,720 --> 00:23:56,000
networks do but we prevent against

00:23:52,790 --> 00:23:59,390
replay and we use modern primitives we

00:23:56,000 --> 00:24:01,880
use curve 255 1/9 for elliptic curve

00:23:59,390 --> 00:24:04,970
diffie-hellman we use blake 2's for

00:24:01,880 --> 00:24:06,080
hashing chacha 20 poly 1 3 or 5 for

00:24:04,970 --> 00:24:08,930
authenticated encryption and when you

00:24:06,080 --> 00:24:11,020
sip hash for the hash tables now

00:24:08,930 --> 00:24:14,780
importantly there's no site fragility

00:24:11,020 --> 00:24:17,950
this is what we use and many of you who

00:24:14,780 --> 00:24:20,840
have set up I don't know TLS servers

00:24:17,950 --> 00:24:22,040
maybe some of you are happy to read this

00:24:20,840 --> 00:24:24,430
now that you don't have to set anything

00:24:22,040 --> 00:24:27,710
up maybe other of you think well maybe

00:24:24,430 --> 00:24:29,330
we want the choice of of using broken

00:24:27,710 --> 00:24:31,310
ciphers no you don't want the choice of

00:24:29,330 --> 00:24:34,160
using broken ciphers if a cipher is

00:24:31,310 --> 00:24:36,800
broken then you upgrade and you don't

00:24:34,160 --> 00:24:40,130
allow broken ciphers on your secure

00:24:36,800 --> 00:24:43,220
Network so I think this idea of cipher

00:24:40,130 --> 00:24:45,710
agility is and the cipher negotiation is

00:24:43,220 --> 00:24:48,020
really a concept from the 90s that has

00:24:45,710 --> 00:24:49,970
seen its course of course there'll be

00:24:48,020 --> 00:24:53,030
paths to upgrade to new versions if

00:24:49,970 --> 00:24:54,950
necessary but mixing primitives and

00:24:53,030 --> 00:24:57,260
allowing negotiation allowing insecure

00:24:54,950 --> 00:25:01,250
primitives is really not a good policy

00:24:57,260 --> 00:25:04,510
so these are the nicest ones for now and

00:25:01,250 --> 00:25:06,740
if they're ever not nice we'll change it

00:25:04,510 --> 00:25:09,440
ok so the key exchange we're running a

00:25:06,740 --> 00:25:11,210
little bit low on time so I'll go

00:25:09,440 --> 00:25:15,260
through this quickly here the key

00:25:11,210 --> 00:25:17,750
exchange is a one round-trip key

00:25:15,260 --> 00:25:19,520
exchange so the initiator sends a

00:25:17,750 --> 00:25:21,670
message to the responder your responder

00:25:19,520 --> 00:25:23,870
sends a message back to the initiator

00:25:21,670 --> 00:25:26,270
using these messages they do some

00:25:23,870 --> 00:25:31,910
calculation and they come up with a pair

00:25:26,270 --> 00:25:33,200
of symmetric keys for for ChaCha 21 for

00:25:31,910 --> 00:25:34,700
sending and one for receiving and then

00:25:33,200 --> 00:25:36,530
they can start to exchange transport

00:25:34,700 --> 00:25:39,590
data and because it's just one

00:25:36,530 --> 00:25:43,220
round-trip either side can initiate this

00:25:39,590 --> 00:25:45,080
at any point if if your laptop's just

00:25:43,220 --> 00:25:46,520
woken up from sleep it can just

00:25:45,080 --> 00:25:49,370
immediately fire it off and start again

00:25:46,520 --> 00:25:51,080
so there's no there's no session state

00:25:49,370 --> 00:25:52,820
that needs to be maintained long term

00:25:51,080 --> 00:25:55,280
because a new session can just be

00:25:52,820 --> 00:25:57,550
created super simply because it's one

00:25:55,280 --> 00:25:57,550
roundtrip

00:25:58,230 --> 00:26:03,610
okay so we have in this several sets of

00:26:01,960 --> 00:26:06,190
keys that are used there's the static

00:26:03,610 --> 00:26:09,040
public and private keys as we saw from

00:26:06,190 --> 00:26:10,690
the screencast but during the key

00:26:09,040 --> 00:26:13,180
exchange both sides generate an

00:26:10,690 --> 00:26:17,740
ephemeral key pair so this ensures the

00:26:13,180 --> 00:26:21,580
perfect forward secrecy the key exchange

00:26:17,740 --> 00:26:24,010
in general it's important that we keep

00:26:21,580 --> 00:26:25,540
this idea of not modifying anything if

00:26:24,010 --> 00:26:27,670
we don't get an encrypted pet if we

00:26:25,540 --> 00:26:30,700
don't get enough indicate a packet we

00:26:27,670 --> 00:26:32,200
want to keep fixed length headers and we

00:26:30,700 --> 00:26:36,730
want both sides to be able to change

00:26:32,200 --> 00:26:42,250
roles if necessary and we want to ignore

00:26:36,730 --> 00:26:43,930
all invalid handshake messages and so

00:26:42,250 --> 00:26:48,160
the way this is accomplished is by

00:26:43,930 --> 00:26:50,310
combining in some method the output of

00:26:48,160 --> 00:26:52,780
for elliptic curve diffie-hellman

00:26:50,310 --> 00:26:55,450
operations the first three make up was

00:26:52,780 --> 00:26:56,680
called the triple diffie-hellman some of

00:26:55,450 --> 00:26:58,890
you might be familiar with if you've

00:26:56,680 --> 00:27:01,210
ever read a spec for signal protocol and

00:26:58,890 --> 00:27:03,010
then we have a static static

00:27:01,210 --> 00:27:09,400
diffie-hellman in the first message so

00:27:03,010 --> 00:27:11,500
that it can be one round-trip and so

00:27:09,400 --> 00:27:13,540
without going into too much depth on

00:27:11,500 --> 00:27:16,750
this it might seem like it's really

00:27:13,540 --> 00:27:19,060
complicated but in fact it's super

00:27:16,750 --> 00:27:23,260
easily implemented the the key exchange

00:27:19,060 --> 00:27:26,040
itself is only 441 lines compared to

00:27:23,260 --> 00:27:30,480
strongswan which I think we said was

00:27:26,040 --> 00:27:35,410
40,000 lines 400,000 lines really big so

00:27:30,480 --> 00:27:39,250
441 lines for the key exchange very

00:27:35,410 --> 00:27:42,780
simple and as you might have noticed we

00:27:39,250 --> 00:27:47,200
don't have any x.509 we don't have

00:27:42,780 --> 00:27:49,810
certificates there's no asn.1 parsing we

00:27:47,200 --> 00:27:54,010
just have these very simple keys that we

00:27:49,810 --> 00:27:56,200
that we can paste around so how do we

00:27:54,010 --> 00:28:00,190
appear to be stateless to the

00:27:56,200 --> 00:28:02,140
administrator obviously the protocol

00:28:00,190 --> 00:28:04,090
itself can't be completely stateless you

00:28:02,140 --> 00:28:05,350
need state in order to have certain

00:28:04,090 --> 00:28:07,780
security properties but to the

00:28:05,350 --> 00:28:10,000
administrator it appears stateless so we

00:28:07,780 --> 00:28:13,150
have a series of timers to make things

00:28:10,000 --> 00:28:15,430
just work and so we have for this a very

00:28:13,150 --> 00:28:17,680
simple state machine that accounts for

00:28:15,430 --> 00:28:20,470
every possibility in state transitions

00:28:17,680 --> 00:28:22,390
simple enough that I was able to write

00:28:20,470 --> 00:28:24,790
down the entire matrix of state

00:28:22,390 --> 00:28:27,820
transitions so that we don't have any

00:28:24,790 --> 00:28:31,410
undefined situations so how does this

00:28:27,820 --> 00:28:34,390
work when user space sends a packet if

00:28:31,410 --> 00:28:36,010
we don't have a current session from a

00:28:34,390 --> 00:28:40,630
key exchange in the last two minutes

00:28:36,010 --> 00:28:43,060
then we send a handshake initiation if

00:28:40,630 --> 00:28:46,690
there's no handshake response after five

00:28:43,060 --> 00:28:49,840
seconds then we just send it again every

00:28:46,690 --> 00:28:53,350
time we get an authenticated incoming

00:28:49,840 --> 00:28:55,750
packet then we set a timer for 10

00:28:53,350 --> 00:28:57,610
seconds from that and every time we get

00:28:55,750 --> 00:28:59,290
a new authenticated packet we move that

00:28:57,610 --> 00:29:02,050
time or another 10 seconds into the

00:28:59,290 --> 00:29:03,670
future so that means if we never get an

00:29:02,050 --> 00:29:05,950
authenticated PAC if we stop receiving

00:29:03,670 --> 00:29:08,820
data then we suppose oh maybe the other

00:29:05,950 --> 00:29:14,050
side there's a problem and so we should

00:29:08,820 --> 00:29:17,650
reinitiate a handshake and so after 15

00:29:14,050 --> 00:29:19,000
seconds we reinitiate a handshake now if

00:29:17,650 --> 00:29:19,960
the other side just isn't responding at

00:29:19,000 --> 00:29:23,740
all then we go to sleep

00:29:19,960 --> 00:29:26,410
so we remain stealthy and not chatty but

00:29:23,740 --> 00:29:28,060
all of this amounts to an interface that

00:29:26,410 --> 00:29:30,520
you don't have to carry as it opt is it

00:29:28,060 --> 00:29:32,980
down is it running when was the last

00:29:30,520 --> 00:29:34,960
connection made now the the admin

00:29:32,980 --> 00:29:37,180
doesn't see that it's just you have an

00:29:34,960 --> 00:29:40,210
interface and you send packets and this

00:29:37,180 --> 00:29:44,140
very simple set of timers ensures that

00:29:40,210 --> 00:29:46,810
there's always a session there's also

00:29:44,140 --> 00:29:50,440
what's called the poor man's post

00:29:46,810 --> 00:29:54,010
quantum resistance now there's a lot of

00:29:50,440 --> 00:29:55,780
new crypto coming out for for quantum to

00:29:54,010 --> 00:29:58,630
protect against quantum computers but

00:29:55,780 --> 00:30:00,430
it's very new and wire guard is trying

00:29:58,630 --> 00:30:02,710
to be conservative with the primitives

00:30:00,430 --> 00:30:06,220
it chooses so it's not choosing one of

00:30:02,710 --> 00:30:10,510
these new heavily researched and debated

00:30:06,220 --> 00:30:15,640
post quantum primitives instead we allow

00:30:10,510 --> 00:30:17,800
for an optional pre shared key and pre

00:30:15,640 --> 00:30:21,310
shared key we can mix into the initial

00:30:17,800 --> 00:30:22,509
key exchange and because of Grover's

00:30:21,310 --> 00:30:25,089
algorithm

00:30:22,509 --> 00:30:30,699
quantum computer can do a brute-force

00:30:25,089 --> 00:30:32,409
search of a 256-bit symmetric key with

00:30:30,699 --> 00:30:36,759
the time it would take a classic

00:30:32,409 --> 00:30:39,039
algorithm to do this in - in 128-bit

00:30:36,759 --> 00:30:42,309
symmetric key and it was proved that

00:30:39,039 --> 00:30:44,559
this speed up is actually optimal there

00:30:42,309 --> 00:30:46,419
won't be a better algorithm than this

00:30:44,559 --> 00:30:49,149
for symmetric cryptography with the

00:30:46,419 --> 00:30:51,099
quantum computer so by mixing in a

00:30:49,149 --> 00:30:53,829
pre-shared key optionally if you want it

00:30:51,099 --> 00:30:57,279
if you're paranoid if an adversary is

00:30:53,829 --> 00:30:58,839
recording all of your traffic now in a

00:30:57,279 --> 00:31:01,739
hundred years when they finally make a

00:30:58,839 --> 00:31:04,209
quantum computer it won't be decrypted

00:31:01,739 --> 00:31:06,759
so that this is a feature put in there

00:31:04,209 --> 00:31:10,299
for the extremely paranoid most people

00:31:06,759 --> 00:31:12,299
won't really need this because depending

00:31:10,299 --> 00:31:17,229
on who you talk to a quantum computer

00:31:12,299 --> 00:31:19,749
capable of breaking elliptic curves are

00:31:17,229 --> 00:31:23,829
still far away off but it's in there if

00:31:19,749 --> 00:31:27,190
if you'd like it there's also a denial

00:31:23,829 --> 00:31:29,619
of service resistance so hashing in

00:31:27,190 --> 00:31:31,539
symmetric crypto are really fast but pop

00:31:29,619 --> 00:31:33,849
key crypto is slow even curved

00:31:31,539 --> 00:31:35,799
fifty-five one nine which has great

00:31:33,849 --> 00:31:37,989
speed records for for elliptic curve

00:31:35,799 --> 00:31:39,909
cryptography is a lot slower than

00:31:37,989 --> 00:31:43,899
symmetric key cryptography that's just

00:31:39,909 --> 00:31:45,969
how it is and in fact you can overwhelm

00:31:43,899 --> 00:31:48,879
a machine by just asking it to compute

00:31:45,969 --> 00:31:53,289
if you helmet over and over and a lot of

00:31:48,879 --> 00:31:54,339
protocols fail miserably - this UDP also

00:31:53,289 --> 00:31:55,599
makes the situation a little bit

00:31:54,339 --> 00:31:58,119
difficult because you can spoof your

00:31:55,599 --> 00:32:00,309
source address so wire guard uses a

00:31:58,119 --> 00:32:03,399
unique cookie solution to solve this so

00:32:00,309 --> 00:32:06,339
we're running a bit low on time but

00:32:03,399 --> 00:32:10,419
we'll try and get through this so brief

00:32:06,339 --> 00:32:13,419
history of cookies the tcp like cookies

00:32:10,419 --> 00:32:16,149
there's a dialogue where initiator says

00:32:13,419 --> 00:32:18,069
compute this diffie-hellman key your

00:32:16,149 --> 00:32:20,319
magic word is waffle now ask me again

00:32:18,069 --> 00:32:22,599
what the magic word initiator says okay

00:32:20,319 --> 00:32:24,759
my magic words waffle now will you do it

00:32:22,599 --> 00:32:27,819
and then it does it so this proves IP

00:32:24,759 --> 00:32:29,769
ownership but you still have the storage

00:32:27,819 --> 00:32:33,849
state that waffle is associated with a

00:32:29,769 --> 00:32:35,900
particular IP address and also this so

00:32:33,849 --> 00:32:38,570
this results in dynamic allocations

00:32:35,900 --> 00:32:40,430
also always responds to a message so we

00:32:38,570 --> 00:32:43,720
violate our stealth principle and of

00:32:40,430 --> 00:32:43,720
course the magic word can be intercepted

00:32:46,330 --> 00:32:52,220
okay DTLS and ikev2 style cookies are a

00:32:50,300 --> 00:32:53,170
little bit more sophisticated initiator

00:32:52,220 --> 00:32:55,430
says compute this diffie-hellman

00:32:53,170 --> 00:32:57,860
responder says okay your magic word is

00:32:55,430 --> 00:33:00,020
some big hash asking again with the

00:32:57,860 --> 00:33:01,700
magic word initiator says okay magic

00:33:00,020 --> 00:33:05,060
words the big hash now will you compute

00:33:01,700 --> 00:33:08,390
it and it turns out that this big hash

00:33:05,060 --> 00:33:11,120
is actually a Mac of the initiators IP

00:33:08,390 --> 00:33:14,270
address using some responder secrets so

00:33:11,120 --> 00:33:16,400
then no state needs to be stored and you

00:33:14,270 --> 00:33:20,840
can still prove IP ownership so this is

00:33:16,400 --> 00:33:21,890
this is clever but again it violates

00:33:20,840 --> 00:33:24,170
stealth because there's always a

00:33:21,890 --> 00:33:25,970
response to the message and of course

00:33:24,170 --> 00:33:28,400
the initiator himself can then be dossed

00:33:25,970 --> 00:33:34,330
by just sending a bunch of garbage magic

00:33:28,400 --> 00:33:36,920
words to the initiator so as an aside

00:33:34,330 --> 00:33:38,630
another solution to this is the Bitcoin

00:33:36,920 --> 00:33:41,630
like or host at the end of a protocol

00:33:38,630 --> 00:33:43,730
like where initiator says computers

00:33:41,630 --> 00:33:47,060
diffie-hellman responder says do some

00:33:43,730 --> 00:33:48,560
proof of work mine a Bitcoin and in this

00:33:47,060 --> 00:33:49,730
year says alright I found a Bitcoin now

00:33:48,560 --> 00:33:52,970
will you do it and this works great

00:33:49,730 --> 00:33:54,980
except because in my regard we want both

00:33:52,970 --> 00:33:57,530
roles to be symmetric its server and

00:33:54,980 --> 00:34:00,370
client can switch sides now there's a

00:33:57,530 --> 00:34:02,900
daus by just making the server compute

00:34:00,370 --> 00:34:05,090
tons of tons of this proof of work for

00:34:02,900 --> 00:34:08,030
many clients and so that doesn't fit us

00:34:05,090 --> 00:34:11,929
so why are guard variant is a little bit

00:34:08,030 --> 00:34:13,130
like the DTLS one except each message

00:34:11,929 --> 00:34:17,270
has two Macs

00:34:13,130 --> 00:34:22,149
the first is a hash of handshake and the

00:34:17,270 --> 00:34:26,960
responders public key so this means that

00:34:22,149 --> 00:34:29,270
in order to respond to a message the

00:34:26,960 --> 00:34:31,909
initiator needs to know who it's talking

00:34:29,270 --> 00:34:35,419
to and prove that with this hash so the

00:34:31,909 --> 00:34:37,340
responder won't respond just to any

00:34:35,419 --> 00:34:39,890
packet it will only respond to packets

00:34:37,340 --> 00:34:41,330
that have a proof that oh I know who you

00:34:39,890 --> 00:34:43,070
are I know that you're already on the

00:34:41,330 --> 00:34:45,980
network so we don't give up the stealth

00:34:43,070 --> 00:34:47,480
principle so if the responder isn't

00:34:45,980 --> 00:34:48,250
under a load then it just perceives

00:34:47,480 --> 00:34:49,750
normally

00:34:48,250 --> 00:34:51,220
and we don't need an engine Iowa's

00:34:49,750 --> 00:34:52,960
surface tack but if it is under a load

00:34:51,220 --> 00:34:55,690
that is if it is experiencing it that

00:34:52,960 --> 00:34:59,440
denial the services tank then it will

00:34:55,690 --> 00:35:02,710
respond with a cookie message and we

00:34:59,440 --> 00:35:05,020
compute this cookie doing the same DTLS

00:35:02,710 --> 00:35:06,640
trick where we take a hash of the

00:35:05,020 --> 00:35:09,400
initiators IP address and it's a keyed

00:35:06,640 --> 00:35:11,140
hash with some responder secret except

00:35:09,400 --> 00:35:13,540
this time we encrypt that cookie when we

00:35:11,140 --> 00:35:16,270
send it using as the key the responders

00:35:13,540 --> 00:35:17,740
public key and using as the additional

00:35:16,270 --> 00:35:20,650
data that's authenticated in it the

00:35:17,740 --> 00:35:23,500
original message so this now binds the

00:35:20,650 --> 00:35:25,690
original message to the cookie response

00:35:23,500 --> 00:35:28,870
while still encrypting it so now is

00:35:25,690 --> 00:35:32,140
harder to be intercepted and we can't

00:35:28,870 --> 00:35:33,820
das the initiator then the initiator

00:35:32,140 --> 00:35:36,910
receives this it can compute the second

00:35:33,820 --> 00:35:41,440
Mac using as its key the cookie that had

00:35:36,910 --> 00:35:43,450
just received okay so all of this

00:35:41,440 --> 00:35:45,340
essentially just gets us IP address

00:35:43,450 --> 00:35:46,930
attribution and then you open a

00:35:45,340 --> 00:35:49,270
networking book and you learn about

00:35:46,930 --> 00:35:50,920
token bucket rate-limiting this has been

00:35:49,270 --> 00:35:53,500
worked out extensively and so we just

00:35:50,920 --> 00:35:57,670
apply that to prevent the daus at that

00:35:53,500 --> 00:36:01,150
point performance wives wire guard is

00:35:57,670 --> 00:36:03,460
faster than anything else I found it's

00:36:01,150 --> 00:36:06,520
in kernel space so fast little latency

00:36:03,460 --> 00:36:08,380
we don't need to copy packets to and

00:36:06,520 --> 00:36:11,590
from user space like say Open VPN or

00:36:08,380 --> 00:36:14,770
other ton based solutions we use cha-cha

00:36:11,590 --> 00:36:16,990
20.1 305 which is really fast and it's

00:36:14,770 --> 00:36:19,930
fast on all hardware and this is a big

00:36:16,990 --> 00:36:23,440
deal on some hardware there is a TSN I

00:36:19,930 --> 00:36:25,270
which is very fast but it's not on all

00:36:23,440 --> 00:36:27,850
hardware and on the other hardware it's

00:36:25,270 --> 00:36:30,190
very hard to implement AES in a way that

00:36:27,850 --> 00:36:32,220
doesn't have side channel attacks well

00:36:30,190 --> 00:36:35,080
it's still fast and furthermore as

00:36:32,220 --> 00:36:38,140
vector instructions on on processors get

00:36:35,080 --> 00:36:41,230
faster and faster and wider and wider

00:36:38,140 --> 00:36:43,960
I think cha-cha 20 is going to be faster

00:36:41,230 --> 00:36:46,300
than a es eventually right now already

00:36:43,960 --> 00:36:49,150
wire guard for other reasons performs

00:36:46,300 --> 00:36:51,640
faster and I think on the latest skylake

00:36:49,150 --> 00:36:56,860
processors ChaCha 20 is already faster

00:36:51,640 --> 00:36:59,860
than AES in general the the simple

00:36:56,860 --> 00:37:01,520
design of wire guard means there's less

00:36:59,860 --> 00:37:03,960
code and

00:37:01,520 --> 00:37:07,050
as a friend here the audience once told

00:37:03,960 --> 00:37:09,300
me of well when you have less code you

00:37:07,050 --> 00:37:13,710
have a faster program not always true

00:37:09,300 --> 00:37:16,470
but here I think this basic principle

00:37:13,710 --> 00:37:19,080
actually works out so when you look at

00:37:16,470 --> 00:37:22,350
the performance measurements you can see

00:37:19,080 --> 00:37:26,310
we're ahead of IP ii both aes and IP 60

00:37:22,350 --> 00:37:28,170
top Holly we're way ahead of openvpn and

00:37:26,310 --> 00:37:30,930
in the ping time we have better latency

00:37:28,170 --> 00:37:34,140
than any of them

00:37:30,930 --> 00:37:36,810
so just to recap less than 4,000 lines

00:37:34,140 --> 00:37:39,090
of code which means all of you can read

00:37:36,810 --> 00:37:43,170
it and I would be very happy if you read

00:37:39,090 --> 00:37:46,070
it found feedback on it it can be easily

00:37:43,170 --> 00:37:49,880
implemented with basic data structures

00:37:46,070 --> 00:37:52,290
the design patterns that you need are

00:37:49,880 --> 00:37:55,860
simple and lead to secure programming

00:37:52,290 --> 00:37:57,780
it's stealthy either solid crypto we

00:37:55,860 --> 00:37:59,400
have the crypto key routing which is

00:37:57,780 --> 00:38:00,710
really a great simplification and we can

00:37:59,400 --> 00:38:05,670
get rid of a lot of the layering

00:38:00,710 --> 00:38:08,370
assumptions that we needed prior we have

00:38:05,670 --> 00:38:09,750
an ordinary network interface so you can

00:38:08,370 --> 00:38:13,200
use all the things you already know

00:38:09,750 --> 00:38:14,700
about it's very fast and a lot of

00:38:13,200 --> 00:38:18,600
choices have been made for you it's

00:38:14,700 --> 00:38:22,500
opinionated for more information you can

00:38:18,600 --> 00:38:24,240
go to wire guard io it's already in many

00:38:22,500 --> 00:38:27,210
of the distros there are packages in

00:38:24,240 --> 00:38:33,090
some debian gen - there's a fedora

00:38:27,210 --> 00:38:34,860
package etc and we have quite a few

00:38:33,090 --> 00:38:36,690
stickers so if you haven't gotten one

00:38:34,860 --> 00:38:40,010
should come up after and I'll open up

00:38:36,690 --> 00:38:40,010
the questions thanks

00:38:40,130 --> 00:38:45,939
[Music]

00:38:47,420 --> 00:38:49,480

YouTube URL: https://www.youtube.com/watch?v=2q98tUNVyfY


