Title: Using Containers for Building and Testing Docker, Kubernetes and Mesos
Publication date: 2018-03-06
Playlist: FOSDEM 2017
Description: 
	by Carlos Sanchez

At: FOSDEM 2017

Building and testing is a great use case for containers, both due to thedynamic and isolation aspects, but running in just one machine is not enoughand quickly needs to scale to a clustered setup. But which cluster technologyshould be used? Docker Swarm? Apache Mesos? Kubernetes? how do they compare?All of them can be used to dynamically run a cluster of containers.

Building and testing is a great use case for containers, both due to thedynamic and isolation aspects, but running in just one machine is not enoughand quickly needs to scale to a clustered setup. But which cluster technologyshould be used? Docker Swarm? Apache Mesos? Kubernetes? how do they compare?All of them can be used to dynamically run a cluster of containers.

The Jenkins platform is an example of dynamically scaling by using severalDocker cluster and orchestration platforms, using containers to run buildagents and jobs, and also isolate job execution.

This talk will cover these main container clusters, outlining the pros andcons, the current state of the art of the technologies and Jenkins support.

The presentation will allow a better understanding of using Docker in the mainDocker cluster/orchestration platforms out there (Docker Swarm, Apache Mesos,Kubernetes), sharing my experience and helping people decide which one to use,going through Jenkins examples and current support.


Room: H.2213
Scheduled start: 2017-02-05 14:25:00
Captions: 
	00:00:00,000 --> 00:00:02,269
so

00:00:04,930 --> 00:00:11,980
I'm gonna talk about using containers

00:00:07,660 --> 00:00:12,490
for building and testing and covering

00:00:11,980 --> 00:00:15,099
docker

00:00:12,490 --> 00:00:16,840
renÃ©e's and missus that's my turret

00:00:15,099 --> 00:00:18,400
handle if you want to tweet about it

00:00:16,840 --> 00:00:20,890
only good things please

00:00:18,400 --> 00:00:24,279
but things you can treat them to that

00:00:20,890 --> 00:00:28,119
guy over there and well a little bit

00:00:24,279 --> 00:00:29,880
about me I work at cloud base I working

00:00:28,119 --> 00:00:33,730
what it's called a private sedation team

00:00:29,880 --> 00:00:35,469
where we basically run Jenkins at the

00:00:33,730 --> 00:00:37,960
scale using operating and docker

00:00:35,469 --> 00:00:40,360
containers and I contribute to the

00:00:37,960 --> 00:00:43,290
junkies messes plugging I'm also the

00:00:40,360 --> 00:00:47,500
author of the kubernetes plugging so

00:00:43,290 --> 00:00:50,500
I'll try to tell you when I'm biased for

00:00:47,500 --> 00:00:53,079
something but that's that's where my

00:00:50,500 --> 00:00:55,090
experience comes from when I also the

00:00:53,079 --> 00:00:56,680
maintainer of or one of the maintenance

00:00:55,090 --> 00:01:00,820
of the official docker images for

00:00:56,680 --> 00:01:03,460
Jenkins and for maven a longtime maven

00:01:00,820 --> 00:01:06,820
contributor member of the posse

00:01:03,460 --> 00:01:11,950
foundation and helping with any other

00:01:06,820 --> 00:01:14,409
open source software that I've used and

00:01:11,950 --> 00:01:16,300
I'm a Google cloud platform expert that

00:01:14,409 --> 00:01:16,690
this comes from the kubernetes side of

00:01:16,300 --> 00:01:20,260
things

00:01:16,690 --> 00:01:22,950
whatever that means that title means ok

00:01:20,260 --> 00:01:25,180
so who is using docker raise your hands

00:01:22,950 --> 00:01:31,360
in one way or another

00:01:25,180 --> 00:01:35,110
ok which is not in production ok well

00:01:31,360 --> 00:01:37,659
more than usual I mean this the pace

00:01:35,110 --> 00:01:43,869
that docker adoption is being like

00:01:37,659 --> 00:01:45,909
through the roof so the I love this to

00:01:43,869 --> 00:01:49,360
it the solution darker the problem you

00:01:45,909 --> 00:01:50,920
tell me right and this is a lot of what

00:01:49,360 --> 00:01:54,549
a lot of people are doing with lucker

00:01:50,920 --> 00:01:57,930
basically just using for anything but

00:01:54,549 --> 00:02:00,850
it's for building and testing and

00:01:57,930 --> 00:02:03,400
deployment all these sort of things it's

00:02:00,850 --> 00:02:08,259
actually pretty good solution and it

00:02:03,400 --> 00:02:13,049
helps a lot dealing with like multiple

00:02:08,259 --> 00:02:16,290
architectures multiple operating well

00:02:13,049 --> 00:02:20,069
packaged versions tool versions

00:02:16,290 --> 00:02:20,069
combinations of different things

00:02:20,280 --> 00:02:25,990
but it's not trivial this is actually

00:02:23,110 --> 00:02:28,240
how they use the ship containers from

00:02:25,990 --> 00:02:31,780
boat into the harbor in some place in

00:02:28,240 --> 00:02:36,730
the Caribbean so using containers is not

00:02:31,780 --> 00:02:39,370
trivial there was recently a post I

00:02:36,730 --> 00:02:40,590
think it was folder saying sorry you're

00:02:39,370 --> 00:02:43,180
gonna be this tall to ride

00:02:40,590 --> 00:02:47,320
micro-services and all the things that

00:02:43,180 --> 00:02:49,450
you need to do to be able to like use it

00:02:47,320 --> 00:02:51,310
and it's not just oh yeah let's let's

00:02:49,450 --> 00:02:52,690
switch completely to microservices and

00:02:51,310 --> 00:02:57,910
docker containers and everything and

00:02:52,690 --> 00:03:00,040
everything is gonna be fine right so one

00:02:57,910 --> 00:03:03,750
of the things that you're gonna do when

00:03:00,040 --> 00:03:07,930
you're using docker containers at this

00:03:03,750 --> 00:03:10,810
scale or I mean pretty soon after you do

00:03:07,930 --> 00:03:15,610
the hello world it's gonna you're gonna

00:03:10,810 --> 00:03:18,070
need a cluster a scheduling system so

00:03:15,610 --> 00:03:22,030
something that is gonna create a cluster

00:03:18,070 --> 00:03:24,490
of host servers running docker or maybe

00:03:22,030 --> 00:03:29,970
now other types of container runtimes

00:03:24,490 --> 00:03:32,709
or in the future and you're gonna and

00:03:29,970 --> 00:03:35,170
especially this is what we built cloud

00:03:32,709 --> 00:03:37,750
is running in public cloud private cloud

00:03:35,170 --> 00:03:40,450
where Merrill and business or case or

00:03:37,750 --> 00:03:43,470
preferred clients and each a unfold

00:03:40,450 --> 00:03:49,330
torrent of course and with other support

00:03:43,470 --> 00:03:52,300
and there is three alternatives once you

00:03:49,330 --> 00:03:56,050
decide to go darker and more than one

00:03:52,300 --> 00:03:58,810
host so you have Apache Messrs you have

00:03:56,050 --> 00:04:00,790
dr. storm and you have to burn Ares so

00:03:58,810 --> 00:04:07,650
these are the three big cluster

00:04:00,790 --> 00:04:10,630
schedulers that exist so what is messes

00:04:07,650 --> 00:04:13,270
messes it's what they call a distributed

00:04:10,630 --> 00:04:15,340
systems kernel this is a way to say you

00:04:13,270 --> 00:04:18,700
can run a lot of things on top of

00:04:15,340 --> 00:04:21,750
missiles basically they obstruct misses

00:04:18,700 --> 00:04:24,520
abstracts like the operating system

00:04:21,750 --> 00:04:28,450
provides you some primitives to deal

00:04:24,520 --> 00:04:30,970
with multiple hosts from the application

00:04:28,450 --> 00:04:31,330
layer and you can run Hadoop you can run

00:04:30,970 --> 00:04:37,509
as

00:04:31,330 --> 00:04:40,000
Kafka all these other big frameworks a

00:04:37,509 --> 00:04:43,840
lot of big data work going on into

00:04:40,000 --> 00:04:46,659
messes and and that's what you can you

00:04:43,840 --> 00:04:51,879
can do there so it started before 2011

00:04:46,659 --> 00:04:53,830
sees their first of them and it can run

00:04:51,879 --> 00:04:56,740
any sort of fashion around the docker

00:04:53,830 --> 00:05:02,319
containers but also just pure binaries

00:04:56,740 --> 00:05:06,460
and rocket containers up see images now

00:05:02,319 --> 00:05:11,860
so the the container I mean this is the

00:05:06,460 --> 00:05:17,409
container format from the scroll the

00:05:11,860 --> 00:05:19,539
container foundation and then what you

00:05:17,409 --> 00:05:22,090
run so you have messes and messes just

00:05:19,539 --> 00:05:24,849
basically abstracts all this

00:05:22,090 --> 00:05:27,009
infrastructure for you and then you run

00:05:24,849 --> 00:05:31,229
frameworks on top of missiles there are

00:05:27,009 --> 00:05:33,699
the ones that actually do something so

00:05:31,229 --> 00:05:35,620
some of the things we saw Hadoop they

00:05:33,699 --> 00:05:38,560
have their frameworks and then you have

00:05:35,620 --> 00:05:41,469
Marathon mesosphere marathon for long

00:05:38,560 --> 00:05:43,150
running tasks running services so if you

00:05:41,469 --> 00:05:45,870
want a service that is always running

00:05:43,150 --> 00:05:48,849
and if for whatever reason it dies

00:05:45,870 --> 00:05:51,099
marathon will be started for you or if a

00:05:48,849 --> 00:05:53,919
host dies marathon will notice and we'll

00:05:51,099 --> 00:05:56,589
run it in another host and then you have

00:05:53,919 --> 00:06:03,400
Apache Aurora that is doing something

00:05:56,589 --> 00:06:07,900
similar and Aurora it's being so both of

00:06:03,400 --> 00:06:09,129
them are being used and missiles are

00:06:07,900 --> 00:06:12,639
using Twitter

00:06:09,129 --> 00:06:14,620
Airbnb eBay Apple you name it there's a

00:06:12,639 --> 00:06:16,719
lot of big companies behind this and

00:06:14,620 --> 00:06:19,389
also the traction we have over there all

00:06:16,719 --> 00:06:20,860
these years there's another frame where

00:06:19,389 --> 00:06:24,219
the risk runners that is like a

00:06:20,860 --> 00:06:26,169
distributed chrome like system and I'll

00:06:24,219 --> 00:06:32,560
talk later about the Jenkins framework

00:06:26,169 --> 00:06:35,349
that ransom message for dr. swarm this

00:06:32,560 --> 00:06:38,469
is something built by dr. Inc the

00:06:35,349 --> 00:06:40,360
company behind docker and the first

00:06:38,469 --> 00:06:44,190
version of the curse worm is the same

00:06:40,360 --> 00:06:47,169
dr. API so it would allow you to

00:06:44,190 --> 00:06:50,889
basically point your doctor client to a

00:06:47,169 --> 00:06:56,320
storm API and then that storm API would

00:06:50,889 --> 00:06:58,449
run whatever you asked us to run across

00:06:56,320 --> 00:07:00,190
the cluster so you wouldn't need to

00:06:58,449 --> 00:07:02,860
modify the system to Lin you have

00:07:00,190 --> 00:07:05,590
everything but wrong it would be the

00:07:02,860 --> 00:07:09,039
same command line the same options in

00:07:05,590 --> 00:07:12,000
the same docket light but I guess they

00:07:09,039 --> 00:07:16,180
realized that had some limitations in

00:07:12,000 --> 00:07:19,840
docker 112 they came up with this new

00:07:16,180 --> 00:07:22,090
docker swarm short mode in docker and

00:07:19,840 --> 00:07:24,970
it's included by default in in the

00:07:22,090 --> 00:07:27,789
docker demon so you don't need to

00:07:24,970 --> 00:07:32,620
install anything else and they I guess

00:07:27,789 --> 00:07:34,960
we play with this ability for them to do

00:07:32,620 --> 00:07:37,690
you know include these features in the

00:07:34,960 --> 00:07:39,460
dark demon and then everybody who's

00:07:37,690 --> 00:07:42,940
gonna get them for free as that they

00:07:39,460 --> 00:07:49,030
have like a first step on the door for

00:07:42,940 --> 00:07:51,280
for you to to use it and this with this

00:07:49,030 --> 00:07:54,660
new doctors were mode they change the

00:07:51,280 --> 00:07:57,970
API or they create a new API better

00:07:54,660 --> 00:08:01,240
where do you have a new object that is

00:07:57,970 --> 00:08:03,729
called the service and this object is

00:08:01,240 --> 00:08:05,650
what basically defines how something

00:08:03,729 --> 00:08:09,120
some conductor container runs across

00:08:05,650 --> 00:08:12,220
multiple hosts and everything same

00:08:09,120 --> 00:08:16,270
reasoning as a Messer's if it dies or

00:08:12,220 --> 00:08:19,840
hostile host dies then the the cluster

00:08:16,270 --> 00:08:22,120
will notice and will restart it if you

00:08:19,840 --> 00:08:25,659
configure it to serve and in another

00:08:22,120 --> 00:08:28,810
host with the big difference from the

00:08:25,659 --> 00:08:31,030
previous swarm that existing tool it

00:08:28,810 --> 00:08:35,110
needs to be changed because this using

00:08:31,030 --> 00:08:38,339
this is creating a new API a new new

00:08:35,110 --> 00:08:43,779
model a new model to deal with with the

00:08:38,339 --> 00:08:48,910
containers in the cluster the last of

00:08:43,779 --> 00:08:51,220
the three is kubernetes so it's

00:08:48,910 --> 00:08:53,079
something that came from Google based on

00:08:51,220 --> 00:08:57,400
what they were running on during on

00:08:53,079 --> 00:09:01,960
their Google systems and it can run

00:08:57,400 --> 00:09:05,020
local machine versatile cloud of course

00:09:01,960 --> 00:09:08,500
Google is making its the best place to

00:09:05,020 --> 00:09:10,870
run it is in Google Cloud and they offer

00:09:08,500 --> 00:09:14,800
a service called Google container engine

00:09:10,870 --> 00:09:16,810
DKA Dickey II where you basically go and

00:09:14,800 --> 00:09:20,470
say I wanna start a new kubernetes

00:09:16,810 --> 00:09:22,210
cluster and it will create for you but

00:09:20,470 --> 00:09:25,930
then you can install it anywhere under

00:09:22,210 --> 00:09:30,190
some there's a nice provider

00:09:25,930 --> 00:09:32,020
well like page stack point where you can

00:09:30,190 --> 00:09:34,810
create clusters in different cloud

00:09:32,020 --> 00:09:37,150
providers and then you have commercial

00:09:34,810 --> 00:09:39,510
software and some type of so like chorus

00:09:37,150 --> 00:09:43,900
tectonic and you can run in the Nasser

00:09:39,510 --> 00:09:46,810
in you can run it in your local machine

00:09:43,900 --> 00:09:49,960
and for the local machine

00:09:46,810 --> 00:09:51,850
actually it's mini cube it's it's a VM

00:09:49,960 --> 00:09:54,400
the husky burner is installed just with

00:09:51,850 --> 00:10:01,550
one no but it's great for testing and

00:09:54,400 --> 00:10:03,450
playing with it and with the api's so

00:10:01,550 --> 00:10:07,750
[Music]

00:10:03,450 --> 00:10:13,540
when we were building this scaling

00:10:07,750 --> 00:10:16,350
Jenkins gold that we have there's I mean

00:10:13,540 --> 00:10:18,880
who's using Jenkins here in the room

00:10:16,350 --> 00:10:23,709
okay that's I should ask who is not

00:10:18,880 --> 00:10:29,050
using it and who is using missus anybody

00:10:23,709 --> 00:10:35,440
using missus not one two persons dr.

00:10:29,050 --> 00:10:39,029
storm like two more and kubernetes like

00:10:35,440 --> 00:10:39,029
four or five okay

00:10:39,240 --> 00:10:44,160
all right so well if you are using

00:10:43,499 --> 00:10:46,980
Jenkins

00:10:44,160 --> 00:10:51,509
you know there's housing keys works

00:10:46,980 --> 00:10:54,569
there's two options we saw two a to

00:10:51,509 --> 00:10:56,879
scale it so you can have either more

00:10:54,569 --> 00:11:02,490
builds permit more build agents or

00:10:56,879 --> 00:11:06,240
slaves per master or more masters and if

00:11:02,490 --> 00:11:08,610
you have more build agents there's

00:11:06,240 --> 00:11:12,240
plenty of plugins that you can use to

00:11:08,610 --> 00:11:14,790
create new agents there's like the old

00:11:12,240 --> 00:11:18,480
Amazon ec2 ones to create virtual

00:11:14,790 --> 00:11:23,249
machines or a sewer machines or anything

00:11:18,480 --> 00:11:24,899
any cloud provider and dynamically like

00:11:23,249 --> 00:11:27,059
when you have all our jobs they get

00:11:24,899 --> 00:11:29,069
created automatically and I will talk

00:11:27,059 --> 00:11:33,059
about the ones that work with docker

00:11:29,069 --> 00:11:34,470
containers and the problems is that the

00:11:33,059 --> 00:11:39,029
master is still a single point of

00:11:34,470 --> 00:11:43,740
failure and if your master dies then you

00:11:39,029 --> 00:11:46,259
have a problem which is not I guess now

00:11:43,740 --> 00:11:47,519
nowadays you have resumable pipelines if

00:11:46,259 --> 00:11:49,139
you were in this room before

00:11:47,519 --> 00:11:51,809
there were some talks about pipelines

00:11:49,139 --> 00:11:54,179
and how there's there's ways where

00:11:51,809 --> 00:11:56,249
pipelines can reconnect to a master

00:11:54,179 --> 00:11:58,499
after the master gets restarted and the

00:11:56,249 --> 00:12:01,439
job continues running so if you restart

00:11:58,499 --> 00:12:06,509
the master your jobs continue running

00:12:01,439 --> 00:12:08,850
and they don't get killed and you you

00:12:06,509 --> 00:12:10,589
have a problem configuring multi having

00:12:08,850 --> 00:12:13,139
multiple configurations or plug-in

00:12:10,589 --> 00:12:17,519
versions of a restart of the master

00:12:13,139 --> 00:12:20,189
right basically you get downtime and

00:12:17,519 --> 00:12:22,079
there's also a limit although that limit

00:12:20,189 --> 00:12:23,879
could be pretty high there's a limit on

00:12:22,079 --> 00:12:28,379
how many buildings you can attach to one

00:12:23,879 --> 00:12:33,660
Jenkins master and then the other option

00:12:28,379 --> 00:12:35,040
is having more masters which are with

00:12:33,660 --> 00:12:36,959
with the benefit that you can have

00:12:35,040 --> 00:12:39,720
multiple organizations or multiple

00:12:36,959 --> 00:12:41,579
departments having their own master so

00:12:39,720 --> 00:12:46,799
it's basically more like a federation

00:12:41,579 --> 00:12:49,110
well it's not like shutting off of your

00:12:46,799 --> 00:12:52,470
bills you can have multiple masters with

00:12:49,110 --> 00:12:55,560
their liens in two different or

00:12:52,470 --> 00:12:58,620
musicians the problems you have is

00:12:55,560 --> 00:13:02,100
single sign-on I mean how you open

00:12:58,620 --> 00:13:04,230
connect to each other connect how did

00:13:02,100 --> 00:13:06,840
you login into all of them in the same

00:13:04,230 --> 00:13:10,290
way or how do you configure all of them

00:13:06,840 --> 00:13:13,500
from a centralized place but we have at

00:13:10,290 --> 00:13:15,930
plotviz we have this Jenkins Operations

00:13:13,500 --> 00:13:18,090
Center and then the Private sedation

00:13:15,930 --> 00:13:23,700
where I work or when I'm when I'm

00:13:18,090 --> 00:13:25,950
working now Kenda basically is doing the

00:13:23,700 --> 00:13:28,050
best of both worlds it allows you to

00:13:25,950 --> 00:13:30,720
have multiple masters running on docker

00:13:28,050 --> 00:13:34,080
containers and they all get configured

00:13:30,720 --> 00:13:37,860
from a single place with this operation

00:13:34,080 --> 00:13:40,230
center and then all these masters are

00:13:37,860 --> 00:13:43,620
creating docker containers you can spin

00:13:40,230 --> 00:13:46,380
new masters whenever you want and all

00:13:43,620 --> 00:13:48,450
these masters get configured to use the

00:13:46,380 --> 00:13:51,990
same cloud we are using missus right now

00:13:48,450 --> 00:13:55,830
and so all the masters are sharing this

00:13:51,990 --> 00:14:02,460
pool of of a plaster with docker hosts

00:13:55,830 --> 00:14:04,530
running then another great world is to

00:14:02,460 --> 00:14:06,120
make my error is human to propagate

00:14:04,530 --> 00:14:07,440
error to observe in an automatic way

00:14:06,120 --> 00:14:11,760
that's what's DevOps

00:14:07,440 --> 00:14:16,260
right and when you are automating a lot

00:14:11,760 --> 00:14:17,820
of things and there's there's chances

00:14:16,260 --> 00:14:21,900
that you what you are to meeting is

00:14:17,820 --> 00:14:23,910
going to break and I have a I cry I have

00:14:21,900 --> 00:14:26,670
a different version of this that

00:14:23,910 --> 00:14:28,020
basically conveys the message is if you

00:14:26,670 --> 00:14:29,550
haven't automatically destroyed

00:14:28,020 --> 00:14:33,150
something by mistake

00:14:29,550 --> 00:14:36,450
you're not automating enough and this

00:14:33,150 --> 00:14:41,250
happened to me several times with Alyssa

00:14:36,450 --> 00:14:48,390
couple nothing really bad like this guys

00:14:41,250 --> 00:14:50,100
from from the this week but but yeah if

00:14:48,390 --> 00:14:51,720
if you are not breaking something is

00:14:50,100 --> 00:14:55,170
that you're not trying hard enough right

00:14:51,720 --> 00:14:57,390
so that's that's my my idea so I always

00:14:55,170 --> 00:14:59,310
try to automate things sometimes you

00:14:57,390 --> 00:15:02,110
screw it up but as long as it's not too

00:14:59,310 --> 00:15:08,350
bad it's okay

00:15:02,110 --> 00:15:16,050
so how can you run Jenkins in docker

00:15:08,350 --> 00:15:20,200
we have several docker images available

00:15:16,050 --> 00:15:24,280
so you have the official docker image

00:15:20,200 --> 00:15:26,740
that is will by docker themselves but we

00:15:24,280 --> 00:15:29,230
provide like the docker file and all the

00:15:26,740 --> 00:15:32,980
new releases and this has the latest

00:15:29,230 --> 00:15:35,290
LTS well all the LTS versions if you go

00:15:32,980 --> 00:15:37,630
to just ganking stocker pool Jenkins or

00:15:35,290 --> 00:15:43,750
dr. Ron Jenkins this is what you get the

00:15:37,630 --> 00:15:48,330
latest LTS and then you also have the

00:15:43,750 --> 00:15:52,060
junkies community has this Jenkins CI

00:15:48,330 --> 00:15:55,630
group in in the docker hub so Jenkins

00:15:52,060 --> 00:16:01,080
CIA slash Jenkins have the weekly builds

00:15:55,630 --> 00:16:01,080
and we possibly will have more bill also

00:16:01,560 --> 00:16:10,720
more more than the weekly builds this

00:16:06,400 --> 00:16:13,690
week because so this is an automated

00:16:10,720 --> 00:16:15,280
build that we have and that is

00:16:13,690 --> 00:16:19,080
publishing continuously every new

00:16:15,280 --> 00:16:21,550
release I've written in weekly build and

00:16:19,080 --> 00:16:24,850
this is built by the junkies community

00:16:21,550 --> 00:16:29,230
and push to the docker hub so it's the

00:16:24,850 --> 00:16:34,510
same thing just this has the weekly bits

00:16:29,230 --> 00:16:38,620
the other one is LPS and then if you're

00:16:34,510 --> 00:16:41,080
gonna run slaves in docker then the one

00:16:38,620 --> 00:16:45,280
you need to be aware of is the Jenkins

00:16:41,080 --> 00:16:48,510
CI slash jnlp - slave so this is an

00:16:45,280 --> 00:16:52,210
image that has just the remote in bits

00:16:48,510 --> 00:16:57,610
so it's based on the Java docker image

00:16:52,210 --> 00:17:01,090
and has the dr. Jenkins life and when

00:16:57,610 --> 00:17:04,540
you start this basically here it says

00:17:01,090 --> 00:17:08,040
dr. Ron Jenkins CID and LP slave and you

00:17:04,540 --> 00:17:11,230
pass the URL and the secret and and

00:17:08,040 --> 00:17:13,810
things the slave name this will connect

00:17:11,230 --> 00:17:16,020
to the master and then that's it you

00:17:13,810 --> 00:17:18,069
have a new life running Indian

00:17:16,020 --> 00:17:19,480
obviously you probably want me to do

00:17:18,069 --> 00:17:20,380
this because there's plugins that will

00:17:19,480 --> 00:17:23,740
do this for you

00:17:20,380 --> 00:17:26,230
and I'll show you later and the other

00:17:23,740 --> 00:17:28,720
interesting part about this image is

00:17:26,230 --> 00:17:31,540
that you have two versions one is based

00:17:28,720 --> 00:17:35,640
on the official openjdk image which is

00:17:31,540 --> 00:17:41,049
Debian but there's also on the Alpine

00:17:35,640 --> 00:17:45,250
image that is really small I think it's

00:17:41,049 --> 00:17:48,940
like 40 or 50 megabytes it was it's a

00:17:45,250 --> 00:17:56,230
lot smaller than than the Debian based

00:17:48,940 --> 00:18:00,490
world if you wanted to manually create a

00:17:56,230 --> 00:18:03,669
hundred slaves in running in docker you

00:18:00,490 --> 00:18:05,950
could just run docker run all these this

00:18:03,669 --> 00:18:12,910
time some point into your Jenkins master

00:18:05,950 --> 00:18:15,730
and that you will have them so for

00:18:12,910 --> 00:18:18,160
cluster scheduling and Jenkins what what

00:18:15,730 --> 00:18:21,309
do you want what what do we want and

00:18:18,160 --> 00:18:25,140
when do we want it so you want to

00:18:21,309 --> 00:18:29,860
isolate it bill agents and jobs you want

00:18:25,140 --> 00:18:33,640
one job to not mess with the word space

00:18:29,860 --> 00:18:35,710
or something of another job and same

00:18:33,640 --> 00:18:37,780
thing for build agents you don't want

00:18:35,710 --> 00:18:40,240
that job using a build dating and then

00:18:37,780 --> 00:18:42,490
another job having any sort of conflict

00:18:40,240 --> 00:18:46,120
with that we wanted to use inductors

00:18:42,490 --> 00:18:49,990
that can start in like seconds and you

00:18:46,120 --> 00:18:52,480
can also we want also to be able to drop

00:18:49,990 --> 00:18:56,230
capabilities like this in the container

00:18:52,480 --> 00:18:58,900
world like be able to not run as root

00:18:56,230 --> 00:19:01,960
and Russert run as a different user

00:18:58,900 --> 00:19:07,900
maybe not have access to network or not

00:19:01,960 --> 00:19:09,669
have access to something or another I'm

00:19:07,900 --> 00:19:13,690
gonna go through the different features

00:19:09,669 --> 00:19:18,419
that the cluster traders have and I'll

00:19:13,690 --> 00:19:23,429
tell you which one of them have what

00:19:18,419 --> 00:19:27,190
feature number one container groups so

00:19:23,429 --> 00:19:29,500
in the Jenkins example imagine you can

00:19:27,190 --> 00:19:33,250
have a Jenkins agent

00:19:29,500 --> 00:19:35,260
container maven container and then

00:19:33,250 --> 00:19:37,620
Firefox container chrome container

00:19:35,260 --> 00:19:40,030
Safari container so you will have up

00:19:37,620 --> 00:19:43,600
what it's typically called a pot of

00:19:40,030 --> 00:19:48,520
containers and you can have five

00:19:43,600 --> 00:19:50,919
containers running for one job and if

00:19:48,520 --> 00:19:51,640
your cluster scheduler support grouping

00:19:50,919 --> 00:19:53,530
containers

00:19:51,640 --> 00:19:56,380
otherwise you have to build one

00:19:53,530 --> 00:20:02,080
container image the has all the tools

00:19:56,380 --> 00:20:06,700
that you need so this is something that

00:20:02,080 --> 00:20:10,450
is experimental in missus in 1 1 0 so

00:20:06,700 --> 00:20:13,299
you need a pretty recent one doctor firm

00:20:10,450 --> 00:20:16,510
supports grouping through docker compose

00:20:13,299 --> 00:20:17,770
and you can also first execution of all

00:20:16,510 --> 00:20:21,370
those containers in the group in the

00:20:17,770 --> 00:20:23,650
same host and kubernetes supports the

00:20:21,370 --> 00:20:25,450
concept of polska natively and it

00:20:23,650 --> 00:20:32,710
warranties at all of them running the

00:20:25,450 --> 00:20:35,260
same host and they can run they can all

00:20:32,710 --> 00:20:39,070
refer to the other containers by using

00:20:35,260 --> 00:20:41,740
localhost so it it came the idea comes

00:20:39,070 --> 00:20:46,360
mainly from kubernetes there was the one

00:20:41,740 --> 00:20:50,740
the first one implementing it is the

00:20:46,360 --> 00:20:53,559
first yes the first one implemented and

00:20:50,740 --> 00:20:56,049
that's the the power of it of being able

00:20:53,559 --> 00:21:00,549
to use multiple containers in just for

00:20:56,049 --> 00:21:02,650
one job because imagine that yeah you

00:21:00,549 --> 00:21:06,190
want to do a maven build and something

00:21:02,650 --> 00:21:08,409
else or selenium tests if you have to

00:21:06,190 --> 00:21:11,500
create your wrong image then you have

00:21:08,409 --> 00:21:15,010
extra work to do with all those tools

00:21:11,500 --> 00:21:18,549
this way you just reuse all the images

00:21:15,010 --> 00:21:20,559
that you have in available in docker hub

00:21:18,549 --> 00:21:27,100
you don't have to write any new docker

00:21:20,559 --> 00:21:29,770
image at all memory limits so the

00:21:27,100 --> 00:21:32,350
scheduler needs to provide a way for you

00:21:29,770 --> 00:21:37,600
to limit how much memory the jobs can

00:21:32,350 --> 00:21:39,250
use and and prevent from from this

00:21:37,600 --> 00:21:41,110
containers to go over the memory limits

00:21:39,250 --> 00:21:42,850
so imagine do you have all these

00:21:41,110 --> 00:21:46,389
resources in the cluster and you

00:21:42,850 --> 00:21:47,590
different jobs trying to fetch get these

00:21:46,389 --> 00:21:50,889
resources

00:21:47,590 --> 00:21:52,480
you don't wanna maybe you have a bill

00:21:50,889 --> 00:21:55,690
that is going wrong and is using more

00:21:52,480 --> 00:21:59,429
memory more CPU more something you don't

00:21:55,690 --> 00:22:03,460
want that to happen so all of them

00:21:59,429 --> 00:22:05,880
support memory limits in missus is

00:22:03,460 --> 00:22:09,399
actually required in swarm is optional

00:22:05,880 --> 00:22:12,789
and in kubernetes but they have some

00:22:09,399 --> 00:22:15,580
defaults the ones are optional when in

00:22:12,789 --> 00:22:21,669
kubernetes you can even do namespaces

00:22:15,580 --> 00:22:26,799
and so you can isolate containers into

00:22:21,669 --> 00:22:29,980
namespaces and having guru limits set up

00:22:26,799 --> 00:22:33,340
namespace level so you could say not by

00:22:29,980 --> 00:22:36,220
container or by yeah you know not just

00:22:33,340 --> 00:22:39,490
my container but saying whatever number

00:22:36,220 --> 00:22:43,269
of containers do run just make sure they

00:22:39,490 --> 00:22:46,360
don't go over this limit and this memory

00:22:43,269 --> 00:22:51,639
constraints translates to doctor - -

00:22:46,360 --> 00:22:54,429
memory parameter so I have some

00:22:51,639 --> 00:22:56,139
questions here for you now um I'm sorry

00:22:54,429 --> 00:22:58,360
sis I know it's late and you're all

00:22:56,139 --> 00:23:00,039
tired but I'm gonna make you work a

00:22:58,360 --> 00:23:02,169
little bit how do you think it happens

00:23:00,039 --> 00:23:07,809
when a container goes from over a memory

00:23:02,169 --> 00:23:11,019
Korra like you have a build that runs to

00:23:07,809 --> 00:23:14,610
JVM as a sample I have and you set

00:23:11,019 --> 00:23:18,009
memory limit in there for the container

00:23:14,610 --> 00:23:19,440
like what would what will happen any

00:23:18,009 --> 00:23:28,919
takers

00:23:19,440 --> 00:23:28,919
sorry sec fault okay any other options

00:23:31,640 --> 00:23:43,159
memories out of memory inception in Java

00:23:36,090 --> 00:23:53,820
okay anybody else sorry

00:23:43,159 --> 00:24:03,029
memory skew okay let me show you so I

00:23:53,820 --> 00:24:07,590
have this this is just maven application

00:24:03,029 --> 00:24:10,350
even built and in the tests I'm just

00:24:07,590 --> 00:24:12,659
using memory and you know well whatever

00:24:10,350 --> 00:24:14,909
the normal Java thing the garbage

00:24:12,659 --> 00:24:16,230
collection happens and it's using this

00:24:14,909 --> 00:24:19,740
memory without limits okay

00:24:16,230 --> 00:24:22,320
the container has no limits this keeps

00:24:19,740 --> 00:24:24,210
using memory and the JVM is doing this

00:24:22,320 --> 00:24:29,029
garbage collection thing and this would

00:24:24,210 --> 00:24:29,029
run forever so I want to kill it

00:24:32,660 --> 00:24:42,680
in this one I'm gonna set it to memory -

00:24:37,630 --> 00:24:46,040
em - 20 mix so basically I'm limiting

00:24:42,680 --> 00:24:50,630
how much memory the container has to -

00:24:46,040 --> 00:24:53,170
220 mix this is a random number this

00:24:50,630 --> 00:24:58,370
depends of the world you run this this

00:24:53,170 --> 00:25:00,980
but what you see is let me show you put

00:24:58,370 --> 00:25:02,600
it here at the top this is doing the

00:25:00,980 --> 00:25:06,590
same thing until it reaches a point

00:25:02,600 --> 00:25:08,500
where basically something happens and

00:25:06,590 --> 00:25:14,480
nothing happens because you let nothing

00:25:08,500 --> 00:25:18,080
this just stop running so what happened

00:25:14,480 --> 00:25:23,920
and the only way you can know what

00:25:18,080 --> 00:25:23,920
happened here is by looking at the

00:25:24,610 --> 00:25:35,810
inspecting the container SPECT when you

00:25:33,590 --> 00:25:38,180
do a doctor inspect there's an

00:25:35,810 --> 00:25:40,460
interesting line here that possibly

00:25:38,180 --> 00:25:41,900
calls your attention if you know where

00:25:40,460 --> 00:25:45,440
you're looking otherwise then you have

00:25:41,900 --> 00:25:48,710
elongation to breathe that basically

00:25:45,440 --> 00:25:50,810
tells you oh I am killed through this is

00:25:48,710 --> 00:25:53,240
telling you the kernel killed your

00:25:50,810 --> 00:25:55,880
container because it ran over the memory

00:25:53,240 --> 00:26:01,570
that was said for that container to run

00:25:55,880 --> 00:26:07,400
so whoever said that last one he wins

00:26:01,570 --> 00:26:08,660
now yeah people especially people coming

00:26:07,400 --> 00:26:11,300
from the Java world with the specter I

00:26:08,660 --> 00:26:14,330
got out of memory exception and things

00:26:11,300 --> 00:26:16,340
like that now the problem with Java is

00:26:14,330 --> 00:26:19,280
when you run java in a container

00:26:16,340 --> 00:26:23,270
environment Java is not aware of the

00:26:19,280 --> 00:26:26,240
limits of the container until the other

00:26:23,270 --> 00:26:30,980
one 9 some patch that was merged like

00:26:26,240 --> 00:26:35,720
last week that supposedly makes it be a

00:26:30,980 --> 00:26:38,870
container cgroups aware so until Gavin

00:26:35,720 --> 00:26:42,110
and you start using Java 9 properly in a

00:26:38,870 --> 00:26:46,220
month for now or years this is what's

00:26:42,110 --> 00:26:49,159
gonna happen so your container

00:26:46,220 --> 00:26:52,340
you're running Java in a container Java

00:26:49,159 --> 00:26:54,590
sees the hosts memory and because I'm

00:26:52,340 --> 00:26:58,190
running in this docker remark thing I

00:26:54,590 --> 00:26:59,770
think the host memories two gigs of the

00:26:58,190 --> 00:27:02,720
virtual machine where dr. runs and

00:26:59,770 --> 00:27:05,899
typically in like 97 percent of the

00:27:02,720 --> 00:27:09,049
cases depends on certain rules the JVM

00:27:05,899 --> 00:27:14,299
is going to take 1/4 of the total host

00:27:09,049 --> 00:27:18,320
memory as maximum heap size and this is

00:27:14,299 --> 00:27:22,070
what you see here the limit this is the

00:27:18,320 --> 00:27:24,020
max memory for for-4 and this is the

00:27:22,070 --> 00:27:27,169
same number that was at the beginning

00:27:24,020 --> 00:27:29,809
when I was not setting any limits so for

00:27:27,169 --> 00:27:37,220
the Java is the of it not aware the JVM

00:27:29,809 --> 00:27:39,620
of of the limit so that will happen so

00:27:37,220 --> 00:27:41,779
how can we fix this because especially

00:27:39,620 --> 00:27:43,730
think that this is running maybe you are

00:27:41,779 --> 00:27:45,919
running this in a cluster so you have

00:27:43,730 --> 00:27:49,419
multiple hosts now you're running maybe

00:27:45,919 --> 00:27:51,890
Jenkins jobs in containers and they just

00:27:49,419 --> 00:27:53,710
disappear get killed and you don't know

00:27:51,890 --> 00:27:59,360
what happened

00:27:53,710 --> 00:28:05,179
so there's another another what

00:27:59,360 --> 00:28:07,580
something we can do is something that is

00:28:05,179 --> 00:28:12,350
very specific of whatever you are

00:28:07,580 --> 00:28:16,309
running so for maven you can spaz JVM

00:28:12,350 --> 00:28:19,159
options as maven opted for ant it's I

00:28:16,309 --> 00:28:21,529
think it's ant ups or ant options and

00:28:19,159 --> 00:28:25,730
you have to know what you're doing and

00:28:21,529 --> 00:28:28,220
say ok just you pass this parameter to

00:28:25,730 --> 00:28:32,470
the JVM and I'm saying ok xmx is two

00:28:28,220 --> 00:28:35,899
hundred and ten megabytes because I know

00:28:32,470 --> 00:28:40,190
I'm giving it to the total containers

00:28:35,899 --> 00:28:42,440
220 megabytes so let's make sure Java is

00:28:40,190 --> 00:28:48,890
aware of how much memory is available

00:28:42,440 --> 00:28:51,679
and what happens here it's a little bit

00:28:48,890 --> 00:28:55,730
different in the sense that the max

00:28:51,679 --> 00:28:58,580
memory that Java sees is 187 ok so it's

00:28:55,730 --> 00:28:59,539
keeping it under the limits and this is

00:28:58,580 --> 00:29:03,320
gonna do more

00:28:59,539 --> 00:29:06,320
collection but is never gonna run out of

00:29:03,320 --> 00:29:09,559
memory I mean it's not never gonna get

00:29:06,320 --> 00:29:15,309
the container crash killed by the

00:29:09,559 --> 00:29:15,309
colonel now

00:29:18,010 --> 00:29:26,320
I was I was cheating a bit here because

00:29:22,500 --> 00:29:29,200
by default what happens when you run

00:29:26,320 --> 00:29:32,830
maven and you run tests on Miriam the

00:29:29,200 --> 00:29:35,230
default is moving Wilfork a new JVM to

00:29:32,830 --> 00:29:37,720
run the tests and I was cheating because

00:29:35,230 --> 00:29:39,580
I said it to do not for there's an

00:29:37,720 --> 00:29:41,820
option in maven in the pom file where

00:29:39,580 --> 00:29:45,669
you can say whether the fork or not for

00:29:41,820 --> 00:29:47,799
so in the surefire plugin exactly so I

00:29:45,669 --> 00:29:51,820
told my even not to fart so all these

00:29:47,799 --> 00:29:55,029
was running in one JVM now if I'd run it

00:29:51,820 --> 00:29:58,539
in the default mode even with the same

00:29:55,029 --> 00:30:05,799
parameters 220 megawatts memory limit X

00:29:58,539 --> 00:30:07,950
MX 210 something's gonna happen guess

00:30:05,799 --> 00:30:11,260
what

00:30:07,950 --> 00:30:14,139
so this is for this is called maven I'm

00:30:11,260 --> 00:30:19,210
making its create a new JVM for surefire

00:30:14,139 --> 00:30:21,730
and that the VM is running the tests so

00:30:19,210 --> 00:30:24,549
what's happening this is gonna you can

00:30:21,730 --> 00:30:29,110
take a little bit longer maybe the new

00:30:24,549 --> 00:30:32,019
JVM is seeing 444 so the new JVM is not

00:30:29,110 --> 00:30:33,760
a word of xmx that I pass to make and

00:30:32,019 --> 00:30:37,240
what I'm getting is failed to execute

00:30:33,760 --> 00:30:39,070
goal the fork VM terminated with same

00:30:37,240 --> 00:30:41,350
without saying properly goodbye VM

00:30:39,070 --> 00:30:45,700
crushed or 60 Mexican colt

00:30:41,350 --> 00:30:48,010
so the new JVM is not aware of the X MX

00:30:45,700 --> 00:30:50,139
memory limits because I said in a

00:30:48,010 --> 00:30:55,059
environment variable they said this is

00:30:50,139 --> 00:30:57,490
for maven now how can we fix this well

00:30:55,059 --> 00:30:59,049
you have an option which is in maven in

00:30:57,490 --> 00:31:01,389
the pound file again you can configure

00:30:59,049 --> 00:31:04,210
the server file plug-in to pass

00:31:01,389 --> 00:31:06,789
variables are environment variables to

00:31:04,210 --> 00:31:12,070
the new VM so you could go in there and

00:31:06,789 --> 00:31:14,260
set XM x equals whatever but you could

00:31:12,070 --> 00:31:16,630
keep doing this over and over and over

00:31:14,260 --> 00:31:23,880
again there's there's a slightly better

00:31:16,630 --> 00:31:28,450
option which is a somewhat obscure

00:31:23,880 --> 00:31:30,879
environment variable that is underscore

00:31:28,450 --> 00:31:31,600
Java underscore options and this will

00:31:30,879 --> 00:31:37,030
whirring up in

00:31:31,600 --> 00:31:40,060
and some DBMS at least and what this

00:31:37,030 --> 00:31:46,030
means is any new JVM that gets you

00:31:40,060 --> 00:31:48,700
started will use these parameters so

00:31:46,030 --> 00:31:51,550
whenever I installed you and maven is

00:31:48,700 --> 00:31:55,240
gonna use X MX to thing when making a

00:31:51,550 --> 00:31:57,370
start surfer is gonna use X MX to ten so

00:31:55,240 --> 00:32:00,790
now this is going to solve you a lot of

00:31:57,370 --> 00:32:04,810
problems I'm gonna just kill it this

00:32:00,790 --> 00:32:08,140
would continue working and this would

00:32:04,810 --> 00:32:10,840
solve you the problems unless you are

00:32:08,140 --> 00:32:13,480
running several JVMs and all of them are

00:32:10,840 --> 00:32:15,640
using the total X MX then you have to

00:32:13,480 --> 00:32:18,880
play with how much you give to each of

00:32:15,640 --> 00:32:22,750
it but if you're running one - I mean

00:32:18,880 --> 00:32:25,630
this will be honored by all of them you

00:32:22,750 --> 00:32:33,240
gotta be aware of what's happening when

00:32:25,630 --> 00:32:33,240
when you run out of memory okay

00:32:33,280 --> 00:32:50,990
oops what did I do alright so that's I

00:32:45,560 --> 00:32:52,130
did another key combination okay I

00:32:50,990 --> 00:32:55,670
talked about that

00:32:52,130 --> 00:32:57,500
then there's the CPU limits it is

00:32:55,670 --> 00:33:01,820
something like the like the memory

00:32:57,500 --> 00:33:03,710
limits and you can pass how many 4 meses

00:33:01,820 --> 00:33:06,950
wahrman kubernetes and these gets

00:33:03,710 --> 00:33:08,540
related into CPU shares and what do you

00:33:06,950 --> 00:33:11,660
think it happens when a container goes

00:33:08,540 --> 00:33:18,190
over its CPU shares but over the CPU

00:33:11,660 --> 00:33:21,560
limits that you said well nothing really

00:33:18,190 --> 00:33:23,810
what CPU shares what the memory limits

00:33:21,560 --> 00:33:26,510
mean in masters missus is memory limits

00:33:23,810 --> 00:33:30,050
in Dockery's CPU shares that makes it a

00:33:26,510 --> 00:33:35,600
little bit more clear is how much

00:33:30,050 --> 00:33:38,470
percentage of a CPU you can get so if if

00:33:35,600 --> 00:33:40,850
you say this is basically a weight and

00:33:38,470 --> 00:33:43,790
depending on how many containers are you

00:33:40,850 --> 00:33:46,910
running has how much CPU is gonna get

00:33:43,790 --> 00:33:49,340
see if you say CPU shares is 1 4 and you

00:33:46,910 --> 00:33:53,390
run one container it's gonna a hundred

00:33:49,340 --> 00:33:56,210
percent of the CPU if you say if you run

00:33:53,390 --> 00:33:59,180
two containers and both have CPU 1 they

00:33:56,210 --> 00:34:01,280
each get 50 percent of the CPU if you

00:33:59,180 --> 00:34:04,100
run them they only get 10 percent of the

00:34:01,280 --> 00:34:06,530
CPU each so it's just a weight across

00:34:04,100 --> 00:34:09,010
all the containers that you run it's all

00:34:06,530 --> 00:34:09,010
relative

00:34:10,600 --> 00:34:18,950
the other important thing to handle on a

00:34:14,600 --> 00:34:23,000
cluster is storage and how you can do

00:34:18,950 --> 00:34:27,280
distribute the storage so missus has in

00:34:23,000 --> 00:34:31,820
versions 1.0 plus dr. volume support

00:34:27,280 --> 00:34:33,770
swarm also has the dr. Wollan plugins so

00:34:31,820 --> 00:34:36,470
you can use whatever plugins you use for

00:34:33,770 --> 00:34:37,970
the normal docker and kubernetes from

00:34:36,470 --> 00:34:40,790
the very beginning you have the concept

00:34:37,970 --> 00:34:43,760
of persistent volumes and all of them

00:34:40,790 --> 00:34:45,770
pretty much I do the typical thing like

00:34:43,760 --> 00:34:49,280
EBS volumes in AWS

00:34:45,770 --> 00:34:53,770
Phares blasted I think it's supported in

00:34:49,280 --> 00:34:59,750
all it's just a matter how you use it

00:34:53,770 --> 00:35:02,510
and also some considerations you should

00:34:59,750 --> 00:35:05,660
not come that these schedulers allow you

00:35:02,510 --> 00:35:07,640
to do is run as a different user not

00:35:05,660 --> 00:35:09,800
this route but you have to be aware that

00:35:07,640 --> 00:35:11,780
the container user ID is not the host

00:35:09,800 --> 00:35:16,820
user I did we get a lot of questions in

00:35:11,780 --> 00:35:19,760
the in the docker image about the

00:35:16,820 --> 00:35:21,230
Jenkins because it's using its the

00:35:19,760 --> 00:35:25,700
Dinky's master is running as a Jenkins

00:35:21,230 --> 00:35:31,100
user which is always one thousand inside

00:35:25,700 --> 00:35:32,630
the container so if you run it in a host

00:35:31,100 --> 00:35:34,490
in an Ubuntu house these are one

00:35:32,630 --> 00:35:37,220
thousand you want to say if you are

00:35:34,490 --> 00:35:39,560
mounting host volumes into the container

00:35:37,220 --> 00:35:40,910
which is typically a bad idea because

00:35:39,560 --> 00:35:45,740
you have to deal with all these things

00:35:40,910 --> 00:35:48,830
and it's not very good it's not great to

00:35:45,740 --> 00:35:51,950
schedule it across a cluster but you

00:35:48,830 --> 00:35:57,140
gotta be aware or if you're using NFS

00:35:51,950 --> 00:35:58,970
then all these the names and the users

00:35:57,140 --> 00:36:02,030
not the names but the you IDS of the

00:35:58,970 --> 00:36:05,660
users have to match this how the

00:36:02,030 --> 00:36:09,110
container is trying to access the data

00:36:05,660 --> 00:36:14,050
and how the data is what are the

00:36:09,110 --> 00:36:20,930
permissions of the data itself yeah so

00:36:14,050 --> 00:36:23,540
NFS users for networking you need to

00:36:20,930 --> 00:36:26,330
open for the Jenkins case you need to

00:36:23,540 --> 00:36:30,800
open the HTTP port the general pit for

00:36:26,330 --> 00:36:34,040
connecting agents and also Jenkins has a

00:36:30,800 --> 00:36:37,550
sort of SSH server building that you

00:36:34,040 --> 00:36:42,620
could happen if you wanted to I'm gonna

00:36:37,550 --> 00:36:44,660
wanna enter into details and their

00:36:42,620 --> 00:36:49,820
support tool that allows you to get one

00:36:44,660 --> 00:36:53,930
IP per container in clusters MSS is more

00:36:49,820 --> 00:36:57,440
recent there's this you can run on with

00:36:53,930 --> 00:36:58,670
calico with weave and same thing Ranieri

00:36:57,440 --> 00:37:01,059
some swarm

00:36:58,670 --> 00:37:04,519
Shawn by default uses the doctor overlay

00:37:01,059 --> 00:37:06,319
but all these options it's just a matter

00:37:04,519 --> 00:37:09,019
of I mean in kubernetes is pretty

00:37:06,319 --> 00:37:10,400
straightforward if you run it in Google

00:37:09,019 --> 00:37:15,109
container engine because it gives you

00:37:10,400 --> 00:37:17,480
everything if you run me sauce or swarm

00:37:15,109 --> 00:37:21,440
then maybe you have to do a lot more

00:37:17,480 --> 00:37:30,339
setup and configuration to make it work

00:37:21,440 --> 00:37:32,599
in a virtual networking and just lastly

00:37:30,339 --> 00:37:35,630
Anna talked about the docker plugins

00:37:32,599 --> 00:37:39,769
that are available to take advantage of

00:37:35,630 --> 00:37:43,400
running in containers so there is

00:37:39,769 --> 00:37:46,630
several docker plugins there's one

00:37:43,400 --> 00:37:50,119
[Music]

00:37:46,630 --> 00:37:56,420
there's one there's I think as leaders -

00:37:50,119 --> 00:37:59,329
for dynamic agents running on docker so

00:37:56,420 --> 00:38:01,519
basically whenever you have a job they

00:37:59,329 --> 00:38:03,410
they will sping a new docker container

00:38:01,519 --> 00:38:06,769
and run the job in in the docker

00:38:03,410 --> 00:38:09,619
container and there's no support yet for

00:38:06,769 --> 00:38:14,029
the docker swarm mode because it uses a

00:38:09,619 --> 00:38:17,029
new API this is not yet supported the

00:38:14,029 --> 00:38:19,309
agent image needs to include Java and we

00:38:17,029 --> 00:38:20,809
will do love the jar the slaves are from

00:38:19,309 --> 00:38:23,589
the master so it needs to have

00:38:20,809 --> 00:38:26,420
connection to the master to the loaded

00:38:23,589 --> 00:38:28,930
and then you have multiple plugins for

00:38:26,420 --> 00:38:31,069
different tasks this is how it is today

00:38:28,930 --> 00:38:34,640
there's the docker build and publish

00:38:31,069 --> 00:38:37,160
plug-in to build docker images and then

00:38:34,640 --> 00:38:41,269
there's the havein registry notification

00:38:37,160 --> 00:38:43,519
to get like initiate jobs based on Wang

00:38:41,269 --> 00:38:45,829
and upstream image is updated and things

00:38:43,519 --> 00:38:51,710
like that and it has a great pipeline

00:38:45,829 --> 00:38:53,960
support I'm not gonna go through the

00:38:51,710 --> 00:38:58,759
configuration but I'll show you like a

00:38:53,960 --> 00:39:01,130
docker pipeline you can run docker with

00:38:58,759 --> 00:39:05,269
registry if you want to use your private

00:39:01,130 --> 00:39:07,880
doctor registry you can do doctor dot

00:39:05,269 --> 00:39:10,759
image and the name of the image to use

00:39:07,880 --> 00:39:11,789
it and then dot pull to download it from

00:39:10,759 --> 00:39:14,729
docker

00:39:11,789 --> 00:39:17,999
ha and then you can build docker images

00:39:14,729 --> 00:39:21,419
with dr. dot build and the interesting

00:39:17,999 --> 00:39:24,630
bits probably is this image dot inside

00:39:21,419 --> 00:39:26,639
and then whatever shell command you put

00:39:24,630 --> 00:39:36,329
in there run into inside the docker

00:39:26,639 --> 00:39:39,799
container itself there's also a plugin

00:39:36,329 --> 00:39:42,509
that is pretty recent that allows you to

00:39:39,799 --> 00:39:46,469
is called the doctorate slaves plugin

00:39:42,509 --> 00:39:50,309
there's a lot of mixed of mixed names

00:39:46,469 --> 00:39:53,639
here and allows you to use any docker

00:39:50,309 --> 00:39:56,849
image for for containers without the

00:39:53,639 --> 00:40:01,189
need to have Java and also so basically

00:39:56,849 --> 00:40:04,679
it's a lot easier to reuse images and

00:40:01,189 --> 00:40:06,419
allows you to define the slave in the

00:40:04,679 --> 00:40:08,880
pipeline and you can have site

00:40:06,419 --> 00:40:11,639
containers so this is called the Jenkins

00:40:08,880 --> 00:40:15,919
docker is life splatting not to confuse

00:40:11,639 --> 00:40:15,919
with any of the other $10 plugins there

00:40:17,530 --> 00:40:23,880
[Music]

00:40:20,419 --> 00:40:26,399
so you can do something a maven with

00:40:23,880 --> 00:40:29,249
doctor knows the name of the image the

00:40:26,399 --> 00:40:32,749
moving image and then shell and whatever

00:40:29,249 --> 00:40:36,029
you want to run inside the docker image

00:40:32,749 --> 00:40:39,569
the missus plug-in allows you also to

00:40:36,029 --> 00:40:42,199
have dynamic Jenkins agents both docker

00:40:39,569 --> 00:40:44,369
and isolated processes so any random

00:40:42,199 --> 00:40:48,779
problem that you want to run in missus

00:40:44,369 --> 00:40:51,479
and the image has to have Java because

00:40:48,779 --> 00:40:54,449
that's how it runs the slave jar to

00:40:51,479 --> 00:40:57,239
connect to the missus master and you

00:40:54,449 --> 00:40:59,699
could have docker you could run docker

00:40:57,239 --> 00:41:02,459
commands but it's basically outside of

00:40:59,699 --> 00:41:05,999
message you will figure in displaying it

00:41:02,459 --> 00:41:08,339
here okay

00:41:05,999 --> 00:41:10,529
so you can write use docker pylons with

00:41:08,339 --> 00:41:12,449
some tricks like you need the doctor

00:41:10,529 --> 00:41:15,419
client installed inside the docker image

00:41:12,449 --> 00:41:18,899
and share the docker sock the typical

00:41:15,419 --> 00:41:20,819
way to run docker side by side Dockers

00:41:18,899 --> 00:41:23,339
or docker contained of the container

00:41:20,819 --> 00:41:26,969
running darker against your host dr.

00:41:23,339 --> 00:41:29,939
daemon plus unit among the most were

00:41:26,969 --> 00:41:32,759
space in the host in the same directory

00:41:29,939 --> 00:41:36,929
as the container that is that is running

00:41:32,759 --> 00:41:40,109
with this we have an example yes with

00:41:36,929 --> 00:41:43,289
this you can run this between a node

00:41:40,109 --> 00:41:47,099
running a missus and I can run a goal an

00:41:43,289 --> 00:41:50,130
image in the host and then I can do a go

00:41:47,099 --> 00:41:53,339
build with with no problems

00:41:50,130 --> 00:41:55,409
reusing that growling image but the only

00:41:53,339 --> 00:41:58,380
caveat is that this runs outside of

00:41:55,409 --> 00:42:02,099
messes this is just running in the host

00:41:58,380 --> 00:42:03,929
docker demo so missus does not know

00:42:02,099 --> 00:42:07,349
anything about it doesn't know how much

00:42:03,929 --> 00:42:08,669
memory is used in how what ports is

00:42:07,349 --> 00:42:09,899
using or anything like that so you're

00:42:08,669 --> 00:42:14,249
basically running outside of the

00:42:09,899 --> 00:42:17,669
scheduler and then the Jake is

00:42:14,249 --> 00:42:20,609
kubernetes plugin same thing you can

00:42:17,669 --> 00:42:24,209
have dynamic Jenkins agents and they run

00:42:20,609 --> 00:42:26,039
our spots so a group of containers so

00:42:24,209 --> 00:42:29,579
you can have multiple containers just

00:42:26,039 --> 00:42:32,009
one of them just has to be the jnlp one

00:42:29,579 --> 00:42:34,109
the one that runs the message the dengue

00:42:32,009 --> 00:42:36,119
sees life to connect to the master and

00:42:34,109 --> 00:42:40,259
if you don't set it up it will create it

00:42:36,119 --> 00:42:42,959
by default it has pipeline support for

00:42:40,259 --> 00:42:46,169
both defining how this what the spots

00:42:42,959 --> 00:42:49,769
images are and do execute things inside

00:42:46,169 --> 00:42:53,669
these spots and in the next version that

00:42:49,769 --> 00:42:55,649
I can release hope to release soon it's

00:42:53,669 --> 00:43:00,869
also having persisting workspace so all

00:42:55,649 --> 00:43:03,479
your agents can mount the worst place

00:43:00,869 --> 00:43:05,399
for manifest or EBS or whatever this is

00:43:03,479 --> 00:43:08,639
this is using just what kubernetes

00:43:05,399 --> 00:43:11,339
provides so you can have one of the

00:43:08,639 --> 00:43:13,109
typical problems when we run things on

00:43:11,339 --> 00:43:15,329
docker is that you don't have the

00:43:13,109 --> 00:43:17,880
previous bills I mean you start from

00:43:15,329 --> 00:43:19,769
zero every time you do a build but with

00:43:17,880 --> 00:43:23,429
this you could have a volume with your

00:43:19,769 --> 00:43:25,829
workspace or NFS or Mon cher cher mount

00:43:23,429 --> 00:43:27,959
or anything that is supported in

00:43:25,829 --> 00:43:32,639
kubernetes and then you wouldn't need to

00:43:27,959 --> 00:43:35,880
start from scratch every time so this is

00:43:32,639 --> 00:43:37,680
where the pipeline looks like and saying

00:43:35,880 --> 00:43:40,020
this is a pod template

00:43:37,680 --> 00:43:44,250
I have a container moving I have a

00:43:40,020 --> 00:43:47,940
golden container and in this pot my

00:43:44,250 --> 00:43:50,490
fault what I'm saying is check out some

00:43:47,940 --> 00:43:53,819
get cold and inside the Maven container

00:43:50,490 --> 00:43:57,450
run a maven build and then inside the

00:43:53,819 --> 00:43:59,520
golden container run a goal build so I

00:43:57,450 --> 00:44:01,349
don't have to read I can reuse the the

00:43:59,520 --> 00:44:03,119
images from the docker hub I don't have

00:44:01,349 --> 00:44:06,599
to create my custom image or anything

00:44:03,119 --> 00:44:09,720
with both maven and go and I can run

00:44:06,599 --> 00:44:15,839
both things in these two containers just

00:44:09,720 --> 00:44:19,260
with one one agent yeah and just the

00:44:15,839 --> 00:44:21,299
recap these plugins allows you to then

00:44:19,260 --> 00:44:24,690
dynamically in creation they all use

00:44:21,299 --> 00:44:28,349
jnlp that's the protocol to connect to

00:44:24,690 --> 00:44:30,839
the master in some environments you can

00:44:28,349 --> 00:44:34,289
use tunnel to connect to the master

00:44:30,839 --> 00:44:36,180
depending on how you run this we don't

00:44:34,289 --> 00:44:38,579
have time to go into more detail and

00:44:36,180 --> 00:44:40,740
they use the cloud API which is not

00:44:38,579 --> 00:44:43,829
ideal for container loads right now

00:44:40,740 --> 00:44:47,099
because it can this is what the sign in

00:44:43,829 --> 00:44:48,720
Jenkins for like I'm a strong images and

00:44:47,099 --> 00:44:50,279
instances and things like that so it may

00:44:48,720 --> 00:44:53,400
take a little bit longer to start the

00:44:50,279 --> 00:44:56,640
containers but there's a jenkees

00:44:53,400 --> 00:44:59,309
one-shot executor plugin that we hope to

00:44:56,640 --> 00:45:01,109
include into at least the kubernetes

00:44:59,309 --> 00:45:04,829
plugin and possibly it's gonna be in the

00:45:01,109 --> 00:45:07,829
docker plug into and this basically is

00:45:04,829 --> 00:45:10,039
optimized for for containers so in

00:45:07,829 --> 00:45:12,510
speakers the previous the cloud API

00:45:10,039 --> 00:45:14,460
assumes like when you start an instance

00:45:12,510 --> 00:45:17,400
it takes longer so it keeps the

00:45:14,460 --> 00:45:19,020
instances around and doesn't start a lot

00:45:17,400 --> 00:45:22,049
of them at the same time because you

00:45:19,020 --> 00:45:25,140
know it takes it gets it has a cost

00:45:22,049 --> 00:45:30,750
associated but this one-shot executor

00:45:25,140 --> 00:45:32,849
it's gonna just create a container run

00:45:30,750 --> 00:45:37,619
your thing and then kill the container

00:45:32,849 --> 00:45:41,450
idea so that's me if you have any

00:45:37,619 --> 00:45:41,450
questions yes

00:45:44,770 --> 00:45:55,480
in a container in an image synchronize

00:45:52,170 --> 00:45:57,940
dependencies across the containers then

00:45:55,480 --> 00:46:01,860
you went on and said well in fact in the

00:45:57,940 --> 00:46:01,860
slaves you can run another container

00:46:11,520 --> 00:46:16,810
yeah okay so how do we manage versions

00:46:15,340 --> 00:46:18,790
and run containers instead of a

00:46:16,810 --> 00:46:21,190
container okay yeah so maybe everything

00:46:18,790 --> 00:46:24,040
is playing we are not running a

00:46:21,190 --> 00:46:27,670
container inside a container you can

00:46:24,040 --> 00:46:31,660
have so what a body is you can start

00:46:27,670 --> 00:46:33,700
multiple containers but they are all in

00:46:31,660 --> 00:46:41,020
the I mean they're not one inside

00:46:33,700 --> 00:46:43,690
another when the dink when Jenkins is

00:46:41,020 --> 00:46:46,390
building an image yes yes you never

00:46:43,690 --> 00:46:49,990
right now there's no good way to run

00:46:46,390 --> 00:46:52,540
docker inside docker so the only the

00:46:49,990 --> 00:46:57,070
recommendation is always running docker

00:46:52,540 --> 00:47:02,020
side side by side so what you do is you

00:46:57,070 --> 00:47:05,950
have a container running your slave or

00:47:02,020 --> 00:47:08,650
whatever this container has the has to

00:47:05,950 --> 00:47:10,600
have the docker client installed and you

00:47:08,650 --> 00:47:12,580
mount the docker socket inside the

00:47:10,600 --> 00:47:14,859
container so this container can run

00:47:12,580 --> 00:47:18,160
docker commands in the docker demo in

00:47:14,859 --> 00:47:20,130
the host so when this container tells

00:47:18,160 --> 00:47:22,750
the doctor Demond docker run something

00:47:20,130 --> 00:47:25,450
is the host that is running and is

00:47:22,750 --> 00:47:27,369
running out here so you are basically

00:47:25,450 --> 00:47:29,470
talking to the host and the host is

00:47:27,369 --> 00:47:34,810
creating another container so they're

00:47:29,470 --> 00:47:49,670
all side-by-side how do I keep track of

00:47:34,810 --> 00:47:52,020
all the dependencies all of my slaves

00:47:49,670 --> 00:47:54,420
how do I make sure that all my slaves

00:47:52,020 --> 00:47:56,850
have the right bathroom okay the reason

00:47:54,420 --> 00:47:58,440
is the way this is done you know these

00:47:56,850 --> 00:48:00,990
plugins is the slaves are suddenly

00:47:58,440 --> 00:48:06,090
there's lives ideally they'd run just

00:48:00,990 --> 00:48:08,370
one job and die so whenever you with the

00:48:06,090 --> 00:48:11,940
cloud API it may not be exactly all the

00:48:08,370 --> 00:48:13,860
time like that they may stick around for

00:48:11,940 --> 00:48:16,680
a little bit depending on there's some

00:48:13,860 --> 00:48:18,870
parameters to adjust but basically you

00:48:16,680 --> 00:48:22,770
are saying I want this job to run in

00:48:18,870 --> 00:48:25,740
maven 3 3 9 and then whenever that job

00:48:22,770 --> 00:48:29,130
runs it will download the Maven 3 3 9

00:48:25,740 --> 00:48:31,320
image and run your job and die and if

00:48:29,130 --> 00:48:34,500
you have another job that says I need to

00:48:31,320 --> 00:48:36,090
run this in maven 3 that one it will

00:48:34,500 --> 00:48:39,480
don't love them maybe in three days one

00:48:36,090 --> 00:48:41,400
image run that and die if you have this

00:48:39,480 --> 00:48:44,150
is the beauty of it like you have you

00:48:41,400 --> 00:48:47,370
can have all sorts of combinations and

00:48:44,150 --> 00:48:50,910
using all these hobby images so like the

00:48:47,370 --> 00:48:54,210
moving image has versions for Java 7 8 &

00:48:50,910 --> 00:48:56,550
9 there's three different images so you

00:48:54,210 --> 00:48:58,920
could run some bills in Java 7 some

00:48:56,550 --> 00:49:02,460
bills in divide or maybe the same bill

00:48:58,920 --> 00:49:09,320
in 7 in parallel with a and they are all

00:49:02,460 --> 00:49:09,320
in different containers yes

00:49:15,880 --> 00:49:20,089
okay if I were to choose one I would

00:49:18,500 --> 00:49:24,619
choose kubernetes but just because I'm

00:49:20,089 --> 00:49:28,069
biased as I said before it's gonna

00:49:24,619 --> 00:49:30,559
depend if you have it if your company

00:49:28,069 --> 00:49:33,680
has it if your operations people already

00:49:30,559 --> 00:49:34,940
have something running then it's more

00:49:33,680 --> 00:49:38,809
likely that you're going to choose that

00:49:34,940 --> 00:49:43,369
one missus has the advantage of being

00:49:38,809 --> 00:49:45,589
able to run any process sites and so

00:49:43,369 --> 00:49:49,069
it's interesting for maybe some more

00:49:45,589 --> 00:49:52,220
like high-performance things and it

00:49:49,069 --> 00:49:54,349
comes there's a lot of scientific things

00:49:52,220 --> 00:49:56,660
running on misses because of that racial

00:49:54,349 --> 00:50:00,740
did run did you could run it bare metal

00:49:56,660 --> 00:50:03,789
things dr. storm has the advantage of

00:50:00,740 --> 00:50:07,490
it's coming by default with rocker and

00:50:03,789 --> 00:50:11,680
the new but it doesn't have the support

00:50:07,490 --> 00:50:14,240
and kubernetes has a lot of open source

00:50:11,680 --> 00:50:18,349
community behind it multiple companies

00:50:14,240 --> 00:50:20,150
is Google is red-hot is Korres is all

00:50:18,349 --> 00:50:23,269
these people building on top of

00:50:20,150 --> 00:50:27,109
kubernetes if you aren't running a Mugen

00:50:23,269 --> 00:50:29,930
clothing it's like a no-brainer do they

00:50:27,109 --> 00:50:33,069
already give you that for free okay so

00:50:29,930 --> 00:50:33,069
I'm reading both

00:50:39,100 --> 00:50:42,370

YouTube URL: https://www.youtube.com/watch?v=qrXxp81xbXs


