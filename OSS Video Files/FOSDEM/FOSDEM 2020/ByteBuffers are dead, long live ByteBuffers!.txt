Title: ByteBuffers are dead, long live ByteBuffers!
Publication date: 2020-07-14
Playlist: FOSDEM 2020
Description: 
	by Maurizio Cimadamore

At: FOSDEM 2020
https://video.fosdem.org/2020/H.1302/bytebuffers.webm

Abstract: Direct buffers are, to date, the only way to access foreign,
off-heap memory. Despite their success, direct buffers suffer from some
limitations --- stateful-ness, lack of addressing space,
non-deterministic deallocation to name a few --- which makes them a
less-than-ideal choice under certain workloads. In this talk we paint
the path to the future: a safe, supported and efficient foreign memory
access API for Java. By providing a more targeted solution to the
problem of accessing foreign memory, not only developers will be freed
by the above limitations - but they will also enjoy improved
performances, as the new API is designed from the ground-up with JIT
optimizations in mind - and all without sacrificing memory access safety.

Room: H.1302 (Depage)
Scheduled start: 2020-02-01 11:20:00
Captions: 
	00:00:05,180 --> 00:00:12,240
this talk is about the memory access API

00:00:08,790 --> 00:00:14,820
which is a new API which we added as an

00:00:12,240 --> 00:00:16,980
incubating API to Java 14 just as the

00:00:14,820 --> 00:00:21,810
gate was coming crashing down so

00:00:16,980 --> 00:00:24,240
basically on this very last day and the

00:00:21,810 --> 00:00:27,030
title of this talk is deliberately

00:00:24,240 --> 00:00:30,240
inflammatory I opted by the end of this

00:00:27,030 --> 00:00:32,520
talk I will have convinced you that the

00:00:30,240 --> 00:00:34,379
role of the new memory access API is not

00:00:32,520 --> 00:00:36,359
to completely replace the by buffer API

00:00:34,379 --> 00:00:38,760
you can decide whether you want to use

00:00:36,359 --> 00:00:40,620
the new API with by buffers or if you

00:00:38,760 --> 00:00:43,530
want to completely replace write buffer

00:00:40,620 --> 00:00:46,890
usage with the new memory API so it's up

00:00:43,530 --> 00:00:48,360
to you hopefully you will ever get

00:00:46,890 --> 00:00:50,880
another tool in the toolbox that will

00:00:48,360 --> 00:00:55,739
help your work so usual disclaimer don't

00:00:50,880 --> 00:00:59,070
believe a word I say so there are a

00:00:55,739 --> 00:01:00,980
number of situations as to why people

00:00:59,070 --> 00:01:03,480
may want to reach for a fake memory

00:01:00,980 --> 00:01:05,250
probably the primary one is to avoid all

00:01:03,480 --> 00:01:08,340
the cost of say would you see now we

00:01:05,250 --> 00:01:10,140
have Shenandoah we have GGC so we have

00:01:08,340 --> 00:01:13,830
much better you see that we did in the

00:01:10,140 --> 00:01:15,330
past but still there are cases where for

00:01:13,830 --> 00:01:17,369
example when you want to do a real-time

00:01:15,330 --> 00:01:20,400
application you may just want to an

00:01:17,369 --> 00:01:22,890
entirely avoid GC poses there are also

00:01:20,400 --> 00:01:25,290
other circumstances were using of it

00:01:22,890 --> 00:01:26,909
memory may be necessary for example when

00:01:25,290 --> 00:01:29,310
you want to share memory across multiple

00:01:26,909 --> 00:01:32,400
processes or when you want to share

00:01:29,310 --> 00:01:35,610
memory with a native library so it's not

00:01:32,400 --> 00:01:37,890
a an accident that we landed on the API

00:01:35,610 --> 00:01:40,290
when we were working on project Panama

00:01:37,890 --> 00:01:44,040
which is as Mark show before all about

00:01:40,290 --> 00:01:48,240
kind of native interrupts the Java de

00:01:44,040 --> 00:01:50,880
facto API for using this kind of of he

00:01:48,240 --> 00:01:54,560
boxes is the byte buffer API there are

00:01:50,880 --> 00:01:57,570
also other api's hidden in the JDK come

00:01:54,560 --> 00:01:59,640
Miskin safe is some misconceptions one

00:01:57,570 --> 00:02:03,119
of those you can use that if you want

00:01:59,640 --> 00:02:05,659
it's fast but it's unsafe so if the VM

00:02:03,119 --> 00:02:07,920
come crashing down it's your fault

00:02:05,659 --> 00:02:11,849
what about byte buffers well byte

00:02:07,920 --> 00:02:15,059
buffers were added in the Java 1.4 so

00:02:11,849 --> 00:02:17,490
they were part of the big push towards

00:02:15,059 --> 00:02:19,930
buffer oriented

00:02:17,490 --> 00:02:23,080
input/output they are a rich and

00:02:19,930 --> 00:02:26,710
stateful API and mean one of the main

00:02:23,080 --> 00:02:29,230
driver by buffer was to make it simple

00:02:26,710 --> 00:02:30,880
for you to write idea matica yo code so

00:02:29,230 --> 00:02:32,980
it has a lot of state internally that

00:02:30,880 --> 00:02:36,430
allows you to prevent buffer overruns

00:02:32,980 --> 00:02:39,220
and under runs helps you with things

00:02:36,430 --> 00:02:42,190
like Charles at encoding in the coding

00:02:39,220 --> 00:02:44,350
and byte buffer crucially can be

00:02:42,190 --> 00:02:47,530
allocated both on the Java heap but also

00:02:44,350 --> 00:02:49,600
of the Java so you can actually allocate

00:02:47,530 --> 00:02:53,860
a slice off of memory and associated

00:02:49,600 --> 00:02:56,700
with a byte buffer it is like a very

00:02:53,860 --> 00:02:58,959
typical example of my buffer usage

00:02:56,700 --> 00:03:01,420
basically you want to read the contents

00:02:58,959 --> 00:03:03,280
of a file channel into a byte buffer and

00:03:01,420 --> 00:03:05,560
then we want to do a loop to read all

00:03:03,280 --> 00:03:08,440
the characters that we've read from the

00:03:05,560 --> 00:03:10,660
buffer so when we allocate the buffer

00:03:08,440 --> 00:03:13,450
the buffer will be empty at the

00:03:10,660 --> 00:03:15,250
beginning two notable things we have

00:03:13,450 --> 00:03:17,860
quite a bit of variables here there is a

00:03:15,250 --> 00:03:19,840
position which is initially set to zero

00:03:17,860 --> 00:03:22,630
and then there is a capacity which is

00:03:19,840 --> 00:03:25,630
essentially how big this buffer is in

00:03:22,630 --> 00:03:28,300
this case it's ten bytes and then there

00:03:25,630 --> 00:03:29,680
is a limit which is another mutable part

00:03:28,300 --> 00:03:32,019
of the state of the byte buffer which

00:03:29,680 --> 00:03:35,200
will be initially set to deleted to the

00:03:32,019 --> 00:03:38,080
capacity the first thing we have to do

00:03:35,200 --> 00:03:40,630
is well we have to read some stuff from

00:03:38,080 --> 00:03:43,440
the channel which means that we are

00:03:40,630 --> 00:03:46,120
actually writing into the by buffer so

00:03:43,440 --> 00:03:49,360
here we read some characters and now we

00:03:46,120 --> 00:03:51,070
have to start reading them into a inner

00:03:49,360 --> 00:03:53,709
application so the first thing that we

00:03:51,070 --> 00:03:55,870
have to do is to flip the buffer from

00:03:53,709 --> 00:03:58,330
writing mode into reading mode which

00:03:55,870 --> 00:04:02,760
means the position here will be set to 0

00:03:58,330 --> 00:04:06,330
and the limit will be set to the maximum

00:04:02,760 --> 00:04:10,900
basically to the position after the last

00:04:06,330 --> 00:04:13,150
character that has been read so I can

00:04:10,900 --> 00:04:15,220
start doing my loop and read all the

00:04:13,150 --> 00:04:18,160
characters one by one until eventually

00:04:15,220 --> 00:04:20,590
we will end up in a state where the

00:04:18,160 --> 00:04:22,510
position is identical to the limit in

00:04:20,590 --> 00:04:25,479
this case the predicate is remaining we

00:04:22,510 --> 00:04:28,060
return false which means I will go out

00:04:25,479 --> 00:04:29,919
of my loop and then I have to get ready

00:04:28,060 --> 00:04:30,760
for yet another read from the file

00:04:29,919 --> 00:04:32,470
channel

00:04:30,760 --> 00:04:34,300
so you have to call clear and what does

00:04:32,470 --> 00:04:35,800
clear do well it will basically reserve

00:04:34,300 --> 00:04:38,200
the state of the my buffer to the

00:04:35,800 --> 00:04:40,360
initial state so position will go back

00:04:38,200 --> 00:04:43,570
to zero the limit will go back to the

00:04:40,360 --> 00:04:45,340
capacity value and so I can do another

00:04:43,570 --> 00:04:48,160
iteration and that's basically how you

00:04:45,340 --> 00:04:50,200
work with buffers of course if you

00:04:48,160 --> 00:04:52,810
wanted to this is a buffer that is

00:04:50,200 --> 00:04:55,570
allocated only if you wanted to use a

00:04:52,810 --> 00:04:56,800
buffer of heap you just change a single

00:04:55,570 --> 00:04:59,530
line of the code here

00:04:56,800 --> 00:05:01,990
use the allocate direct instead of using

00:04:59,530 --> 00:05:04,390
the allocate method so this is called a

00:05:01,990 --> 00:05:08,170
direct buffer and is associated with

00:05:04,390 --> 00:05:10,120
Offutt memory so with direct buffer we

00:05:08,170 --> 00:05:14,950
actually have a new weapon as developers

00:05:10,120 --> 00:05:18,370
because we can write code that allows us

00:05:14,950 --> 00:05:20,050
to access off if memory access to off

00:05:18,370 --> 00:05:22,240
with memory would by buffer is quite

00:05:20,050 --> 00:05:23,890
efficient because at the end of the day

00:05:22,240 --> 00:05:26,890
by buffer is implemented on top of

00:05:23,890 --> 00:05:30,010
unsafe so we can still get advantage of

00:05:26,890 --> 00:05:32,620
all this issue data movement intrinsic

00:05:30,010 --> 00:05:34,450
that we have the access is also safe

00:05:32,620 --> 00:05:37,990
because as we've seen the byte buffer

00:05:34,450 --> 00:05:41,680
have all this concept of capacity limit

00:05:37,990 --> 00:05:43,720
position so every access will be within

00:05:41,680 --> 00:05:48,910
the boundaries of the by buffer

00:05:43,720 --> 00:05:52,090
otherwise we will get an exception but

00:05:48,910 --> 00:05:56,140
how good are by buffers if we want to

00:05:52,090 --> 00:05:58,870
write general can of heap programs well

00:05:56,140 --> 00:06:00,550
let's try to look at some numbers right

00:05:58,870 --> 00:06:02,730
here I have a benchmark which is

00:06:00,550 --> 00:06:07,360
essentially allocating a slab of memory

00:06:02,730 --> 00:06:11,590
400 bytes and then is setting 100 ins

00:06:07,360 --> 00:06:13,270
inside there's a big slab of memory the

00:06:11,590 --> 00:06:14,710
benchmark has been canotary picked

00:06:13,270 --> 00:06:16,390
because I think this benchmark is

00:06:14,710 --> 00:06:18,100
characteristic of what happens a lot

00:06:16,390 --> 00:06:20,170
when you do native interrupts which is

00:06:18,100 --> 00:06:21,850
something that we care a lot when we do

00:06:20,170 --> 00:06:24,370
panama so you allocate a small buffer of

00:06:21,850 --> 00:06:26,440
memory you feel it and then you have to

00:06:24,370 --> 00:06:29,290
pass a pointer to this memory to maybe

00:06:26,440 --> 00:06:31,360
some native function and then you have

00:06:29,290 --> 00:06:36,820
to free the memory after the function

00:06:31,360 --> 00:06:38,620
returns so this is maybe not a use case

00:06:36,820 --> 00:06:40,600
that comes up a lot when you're doing a

00:06:38,620 --> 00:06:43,289
oh but this is something that you do

00:06:40,600 --> 00:06:46,050
quite typically when working with native

00:06:43,289 --> 00:06:48,240
libraries so if you use unsaved you get

00:06:46,050 --> 00:06:51,300
a certain throughput so nine operation

00:06:48,240 --> 00:06:53,279
per microsecond that's fine let's try to

00:06:51,300 --> 00:06:55,770
replace this code by using the byte

00:06:53,279 --> 00:06:57,710
buffer API which is a supporter API we

00:06:55,770 --> 00:07:02,580
can see that the throughput is almost

00:06:57,710 --> 00:07:04,319
yeah 9x lower compared to unsafe this is

00:07:02,580 --> 00:07:06,389
due to the extra safety that the by

00:07:04,319 --> 00:07:09,089
buffer API provides but it's also due to

00:07:06,389 --> 00:07:10,800
a number of extra factors here we can

00:07:09,089 --> 00:07:13,080
see that there are these two factors

00:07:10,800 --> 00:07:15,089
that are hindering performances the

00:07:13,080 --> 00:07:17,339
first is that I'm using the relative

00:07:15,089 --> 00:07:19,199
positioning scheme so I I do a put int

00:07:17,339 --> 00:07:21,809
and I'm basically relying on that

00:07:19,199 --> 00:07:25,889
mutable position field that will be

00:07:21,809 --> 00:07:28,050
incremented on every access and that

00:07:25,889 --> 00:07:30,509
slows things down a little bit but the

00:07:28,050 --> 00:07:34,139
second and most important thing is that

00:07:30,509 --> 00:07:37,499
every PI buffer has to be register with

00:07:34,139 --> 00:07:41,279
a GC cleaner for the offic memory to be

00:07:37,499 --> 00:07:43,110
allocated after we can prove that the by

00:07:41,279 --> 00:07:46,009
buffer is no longer referenced by

00:07:43,110 --> 00:07:48,330
anything in our application and

00:07:46,009 --> 00:07:50,729
basically the GC has to do a lot of work

00:07:48,330 --> 00:07:54,300
here and this work shows up in the

00:07:50,729 --> 00:07:56,999
benchmark in fact if we change the

00:07:54,300 --> 00:07:59,430
benchmark a little bit first to use the

00:07:56,999 --> 00:08:01,379
absolute put int method and secondly

00:07:59,430 --> 00:08:02,309
more importantly to use the unsafe

00:08:01,379 --> 00:08:04,830
invoke cleaner

00:08:02,309 --> 00:08:08,339
method would actually allows us to free

00:08:04,830 --> 00:08:09,990
the memory explicitly without relying on

00:08:08,339 --> 00:08:13,469
the GC cleaner we see that the

00:08:09,990 --> 00:08:15,930
performance rise a little bit is not as

00:08:13,469 --> 00:08:19,019
fast as unsafe but it's a little bit

00:08:15,930 --> 00:08:21,749
better to be fair here to this benchmark

00:08:19,019 --> 00:08:24,209
and to by buffer in general and say it

00:08:21,749 --> 00:08:24,680
doesn't zero memory by buffer do zero

00:08:24,209 --> 00:08:28,199
memory

00:08:24,680 --> 00:08:31,229
I'm not allocating a very big chunk of

00:08:28,199 --> 00:08:33,120
memory here so zeroing is not affecting

00:08:31,229 --> 00:08:36,529
performances too much but still there is

00:08:33,120 --> 00:08:40,169
an extra cost here when using my buffer

00:08:36,529 --> 00:08:43,319
and let's look at what happens in memory

00:08:40,169 --> 00:08:46,230
so we done safe of course the GC is

00:08:43,319 --> 00:08:48,149
basically not working all the accesses

00:08:46,230 --> 00:08:49,350
are not saying that the the are of heap

00:08:48,149 --> 00:08:51,480
and that's basically what you would

00:08:49,350 --> 00:08:53,490
expect but with the first byte buffer

00:08:51,480 --> 00:08:56,830
example that we wrote so just de nieve

00:08:53,490 --> 00:08:58,600
by buffer usage the GC was actually

00:08:56,830 --> 00:09:00,700
for five seconds during this benchmark

00:08:58,600 --> 00:09:03,580
which is quite a lot considering that

00:09:00,700 --> 00:09:06,100
you wanted to use off it memory to get

00:09:03,580 --> 00:09:09,279
rid of the GC in the first place with

00:09:06,100 --> 00:09:11,110
the third benchmark so these new version

00:09:09,279 --> 00:09:13,660
things get a little bit more under

00:09:11,110 --> 00:09:15,850
control and the GC time goes back to

00:09:13,660 --> 00:09:18,250
zero but still the performance is not

00:09:15,850 --> 00:09:20,529
quite as good as it could be and the

00:09:18,250 --> 00:09:23,560
biggest problem here is that by buffer

00:09:20,529 --> 00:09:25,540
allocate direct that first invocation is

00:09:23,560 --> 00:09:27,130
quite heavy because they by buffer has

00:09:25,540 --> 00:09:29,740
to be registered with a cleaner even if

00:09:27,130 --> 00:09:32,290
we are not using the cleaner anyway and

00:09:29,740 --> 00:09:35,410
also there is a quite a complex state in

00:09:32,290 --> 00:09:36,910
order to track how much of memory we are

00:09:35,410 --> 00:09:39,160
using there is a limit so there are a

00:09:36,910 --> 00:09:43,110
couple of atomic instruction in order to

00:09:39,160 --> 00:09:45,880
check whether we are allocating too much

00:09:43,110 --> 00:09:47,800
and so this is quite expensive and it

00:09:45,880 --> 00:09:51,610
shows up in this particular allocation

00:09:47,800 --> 00:09:53,560
intensive benchmark so where does this

00:09:51,610 --> 00:09:56,589
leave the by buffer API is this a bad

00:09:53,560 --> 00:09:58,540
API no it's not about API it's just that

00:09:56,589 --> 00:10:02,079
here we I think we're trying to use it

00:09:58,540 --> 00:10:04,089
in a way that wasn't the way in which

00:10:02,079 --> 00:10:07,750
way buffer was men were meant to be used

00:10:04,089 --> 00:10:10,180
at the beginning the direct buffer

00:10:07,750 --> 00:10:12,279
worked very well if you allocate for

00:10:10,180 --> 00:10:16,029
example a very big right buffer and then

00:10:12,279 --> 00:10:17,470
you keep sharing it and also because the

00:10:16,029 --> 00:10:20,110
cost of our operation typically

00:10:17,470 --> 00:10:22,029
dominates every other cost all the stuff

00:10:20,110 --> 00:10:24,730
that I show you before doesn't really

00:10:22,029 --> 00:10:27,130
matter right unfortunately though by

00:10:24,730 --> 00:10:29,410
buffer fail to scale when considering

00:10:27,130 --> 00:10:31,209
can a more general cases because you

00:10:29,410 --> 00:10:32,110
have no way to deterministic Allah

00:10:31,209 --> 00:10:35,200
release the memory

00:10:32,110 --> 00:10:36,940
so you're basically either relying on

00:10:35,200 --> 00:10:39,040
did you see or you use some unsafe

00:10:36,940 --> 00:10:41,020
operation in order but but you still pay

00:10:39,040 --> 00:10:42,790
a lot upfront in order to allocate the

00:10:41,020 --> 00:10:45,430
buffer and then you then you have the

00:10:42,790 --> 00:10:47,020
two gigabyte limit which is starting to

00:10:45,430 --> 00:10:50,560
hurt especially now that we have support

00:10:47,020 --> 00:10:52,329
for mapping persistent memory files so a

00:10:50,560 --> 00:10:53,920
persistent memory can probably be a

00:10:52,329 --> 00:10:56,350
little bit bigger than two gigabytes and

00:10:53,920 --> 00:10:58,089
we have no way to access it using the by

00:10:56,350 --> 00:11:01,329
buffer API because all the indices that

00:10:58,089 --> 00:11:03,130
we can specify are essentially int and

00:11:01,329 --> 00:11:04,959
then there is a there are limitation

00:11:03,130 --> 00:11:07,899
with the expressiveness of this API when

00:11:04,959 --> 00:11:10,270
it comes to accessing the memory because

00:11:07,899 --> 00:11:13,300
you can either choose between secure

00:11:10,270 --> 00:11:18,280
Laxus so but essentially one inch at a

00:11:13,300 --> 00:11:19,810
time or another absolute addressing

00:11:18,280 --> 00:11:22,470
scheme where I have to pass the offset

00:11:19,810 --> 00:11:25,480
all the time there is no support for

00:11:22,470 --> 00:11:27,670
structural access so if I have a struct

00:11:25,480 --> 00:11:30,160
in memory there's no way for me to say I

00:11:27,670 --> 00:11:33,550
want to access that particular field I

00:11:30,160 --> 00:11:35,350
have to work offset the manual in order

00:11:33,550 --> 00:11:37,570
to get to these of that location into

00:11:35,350 --> 00:11:40,030
memory so we think that rather than

00:11:37,570 --> 00:11:42,730
investing more on the byte buffer API

00:11:40,030 --> 00:11:45,040
the time has actually come to build a

00:11:42,730 --> 00:11:46,750
new memory API from the ground up and of

00:11:45,040 --> 00:11:48,520
course this new API will be

00:11:46,750 --> 00:11:50,430
interoperable with my buffer so you

00:11:48,520 --> 00:11:53,860
don't have to throw away all your code

00:11:50,430 --> 00:11:55,720
but as I was discussing with Paul last

00:11:53,860 --> 00:11:58,330
week we think that byte buffer has

00:11:55,720 --> 00:12:00,580
reached their functional capacity there

00:11:58,330 --> 00:12:02,980
some of these limitations such as the

00:12:00,580 --> 00:12:05,350
two gigabyte limits or the deterministic

00:12:02,980 --> 00:12:07,390
the location are very hard to fix in the

00:12:05,350 --> 00:12:10,150
current buy buffer API it will require a

00:12:07,390 --> 00:12:12,130
pretty big redesign of the entire API

00:12:10,150 --> 00:12:16,060
which is probably not going to be very

00:12:12,130 --> 00:12:18,100
compatible so it's probably better to

00:12:16,060 --> 00:12:21,880
start from scratch and to design a new

00:12:18,100 --> 00:12:24,850
API here this is what happens when by

00:12:21,880 --> 00:12:27,580
buffer Canha fails to meet the

00:12:24,850 --> 00:12:29,470
expectations on net is a big client of

00:12:27,580 --> 00:12:32,020
my buffer it allocates a lot of byte

00:12:29,470 --> 00:12:34,480
buffer and starting from version 4 they

00:12:32,020 --> 00:12:37,690
are all in their own version of Pi

00:12:34,480 --> 00:12:41,080
buffer called byte path no pun intended

00:12:37,690 --> 00:12:43,750
and this is based on a different

00:12:41,080 --> 00:12:45,880
allocation scheme so they have also

00:12:43,750 --> 00:12:48,660
specialized a locator which reduces

00:12:45,880 --> 00:12:51,660
memory so it's an allocation pool and

00:12:48,660 --> 00:12:55,030
it's essentially a je malloc

00:12:51,660 --> 00:12:57,430
implementation written in Java and with

00:12:55,030 --> 00:12:59,290
this they were able to get a lot more

00:12:57,430 --> 00:13:01,780
scalability out of there

00:12:59,290 --> 00:13:03,400
buffer infrastructure and this is

00:13:01,780 --> 00:13:05,050
important and something we can support

00:13:03,400 --> 00:13:07,180
in Java today so people have to reach

00:13:05,050 --> 00:13:09,460
out for different abstraction so we'd

00:13:07,180 --> 00:13:12,990
like that code to come back to the JDK

00:13:09,460 --> 00:13:15,880
eventually or at least that's the hope

00:13:12,990 --> 00:13:20,650
so enter the memory access API it's a

00:13:15,880 --> 00:13:22,880
new API it's a safe API so the goal here

00:13:20,650 --> 00:13:26,960
and we will see that later you

00:13:22,880 --> 00:13:28,880
more is absolutely no bien crashes so

00:13:26,960 --> 00:13:30,650
you should never get a bien crash while

00:13:28,880 --> 00:13:34,730
trying to access of it memory using this

00:13:30,650 --> 00:13:36,860
API it's as safe as by buffer are there

00:13:34,730 --> 00:13:39,110
are three key abstraction the first is

00:13:36,860 --> 00:13:41,530
called memory segment which is just a

00:13:39,110 --> 00:13:44,960
region of memory contiguous bytes

00:13:41,530 --> 00:13:47,330
somewhere they can be on impure of heap

00:13:44,960 --> 00:13:50,570
the API is actually neutral as to

00:13:47,330 --> 00:13:52,250
whether the bytes are stored and then

00:13:50,570 --> 00:13:54,740
there we have addresses which are

00:13:52,250 --> 00:13:56,900
essentially offsets into segments so is

00:13:54,740 --> 00:13:58,550
you can think of it just as a long that

00:13:56,900 --> 00:14:00,920
points to some location inside the

00:13:58,550 --> 00:14:03,530
segment and then we have memory layouts

00:14:00,920 --> 00:14:05,720
which are optional description of the

00:14:03,530 --> 00:14:07,610
contents of memory you can decide to use

00:14:05,720 --> 00:14:09,650
them or you can just decide to ignore

00:14:07,610 --> 00:14:11,540
them but we will see what are the

00:14:09,650 --> 00:14:15,830
advantage of attaching a memory layout

00:14:11,540 --> 00:14:18,190
to a segment if you look to the in the

00:14:15,830 --> 00:14:22,460
Javadoc of this API you will find no

00:14:18,190 --> 00:14:24,110
method called get int or putting nothing

00:14:22,460 --> 00:14:26,510
of the kind and we have received some

00:14:24,110 --> 00:14:30,530
question when the request for review

00:14:26,510 --> 00:14:34,760
went out is not an omission because we

00:14:30,530 --> 00:14:37,370
forgot about them it's because there are

00:14:34,760 --> 00:14:39,500
plenty of ways in order to get to the

00:14:37,370 --> 00:14:41,870
data of a memory segment you can for

00:14:39,500 --> 00:14:45,320
example take a memory segment and map it

00:14:41,870 --> 00:14:47,360
it to a byte buffer and then you can use

00:14:45,320 --> 00:14:50,690
the old goodbye buffer API to get int

00:14:47,360 --> 00:14:57,050
and floats and lungs and never look back

00:14:50,690 --> 00:14:58,610
at segments ever again or if you are if

00:14:57,050 --> 00:15:00,350
you want to reach lower level and you

00:14:58,610 --> 00:15:01,970
want to go down the very end or rabbit

00:15:00,350 --> 00:15:03,950
hole you can actually create verandas

00:15:01,970 --> 00:15:07,310
that are able to the reference memory

00:15:03,950 --> 00:15:09,440
using memory addresses and this is

00:15:07,310 --> 00:15:12,500
actually a good option that we will

00:15:09,440 --> 00:15:14,900
explore in the final part of this talk

00:15:12,500 --> 00:15:16,130
so the the main idea here is that we

00:15:14,900 --> 00:15:18,830
don't need to reinvent the wheel we

00:15:16,130 --> 00:15:22,010
don't need to add a lot of access or for

00:15:18,830 --> 00:15:25,670
our memory we can just leverage the good

00:15:22,010 --> 00:15:27,710
api's that we already are this is what a

00:15:25,670 --> 00:15:30,380
segment looks like let's imagine that we

00:15:27,710 --> 00:15:32,420
have a an array or struct point where a

00:15:30,380 --> 00:15:34,780
pointers to int coordinates a very

00:15:32,420 --> 00:15:36,850
simple thing so we can imagine

00:15:34,780 --> 00:15:39,310
or a memory to be flattened so that all

00:15:36,850 --> 00:15:44,200
the coordinates are socially consecutive

00:15:39,310 --> 00:15:47,590
so X 0 y 0 up to X 4 y 4 this segment

00:15:44,200 --> 00:15:49,180
will have natural spacial bounds so we

00:15:47,590 --> 00:15:52,630
will start from our base address which

00:15:49,180 --> 00:15:54,940
is the which will point to X 0 and then

00:15:52,630 --> 00:15:57,040
we will have a limit address which is

00:15:54,940 --> 00:15:59,170
the maximum address with the segment

00:15:57,040 --> 00:16:02,380
actually the address of the first byte

00:15:59,170 --> 00:16:04,120
that is outside the segment so as long

00:16:02,380 --> 00:16:08,050
as the access occurs within the segment

00:16:04,120 --> 00:16:10,390
everything is fine if I have an address

00:16:08,050 --> 00:16:14,230
I can add an offset to it and obtain a

00:16:10,390 --> 00:16:16,450
new address so for example if I add 16

00:16:14,230 --> 00:16:18,250
to the other to the base address I will

00:16:16,450 --> 00:16:22,420
obtain a new address that instead of

00:16:18,250 --> 00:16:24,250
pointing to X 0 will point to X 2 and if

00:16:22,420 --> 00:16:26,650
I have a segment I can also slice it

00:16:24,250 --> 00:16:28,390
this is similar to the slice operation

00:16:26,650 --> 00:16:30,880
that by buffer also provides so I can

00:16:28,390 --> 00:16:32,920
specify a new start address in a new

00:16:30,880 --> 00:16:34,450
length and I will get a sub segment

00:16:32,920 --> 00:16:37,060
which will be contained into the

00:16:34,450 --> 00:16:41,650
original segment so nothing too fancy

00:16:37,060 --> 00:16:43,120
here the the main thing may may be to

00:16:41,650 --> 00:16:45,520
notice here is that this API is

00:16:43,120 --> 00:16:47,530
immutable so there are no none of these

00:16:45,520 --> 00:16:50,890
bounds that you see here are immutable

00:16:47,530 --> 00:16:52,780
you whenever a new address is created

00:16:50,890 --> 00:16:56,460
you actually create a new instance with

00:16:52,780 --> 00:16:59,260
the new offset so nothing will actually

00:16:56,460 --> 00:17:01,960
mutate in memory which will hopefully

00:16:59,260 --> 00:17:07,060
enable for better situation in the

00:17:01,960 --> 00:17:10,060
future the goal of the big goal of the

00:17:07,060 --> 00:17:11,920
segment idea API and the big bet is that

00:17:10,060 --> 00:17:13,420
we want an API that is able to do the

00:17:11,920 --> 00:17:15,970
terminating the allocation which means

00:17:13,420 --> 00:17:18,160
whenever you are sure that your memory

00:17:15,970 --> 00:17:20,830
is no longer going to be used you should

00:17:18,160 --> 00:17:23,410
be able to explicitly free it and the

00:17:20,830 --> 00:17:25,120
way this is done is that you you

00:17:23,410 --> 00:17:26,710
essentially have a segment you use it

00:17:25,120 --> 00:17:29,380
and when you are done you close the

00:17:26,710 --> 00:17:31,840
segment of course with power comes

00:17:29,380 --> 00:17:33,700
responsibility if you forget to close

00:17:31,840 --> 00:17:36,940
your segment and the segment goes out of

00:17:33,700 --> 00:17:41,170
scope you have a memory leak because now

00:17:36,940 --> 00:17:44,890
we have some memory of heap and that is

00:17:41,170 --> 00:17:46,990
not being cleared to help with that

00:17:44,890 --> 00:17:48,620
memory segments implement the o2

00:17:46,990 --> 00:17:50,270
crucible interface so you can use

00:17:48,620 --> 00:17:52,850
the memory segments with the Triwizard

00:17:50,270 --> 00:17:55,520
source construct hopefully that will

00:17:52,850 --> 00:17:58,640
reduce the occurrences where these leaks

00:17:55,520 --> 00:18:00,230
will occur other things we could do in

00:17:58,640 --> 00:18:01,700
order to improve on these is to do

00:18:00,230 --> 00:18:04,490
something similar to what Nettie has

00:18:01,700 --> 00:18:07,040
done which is to add a debugging kind of

00:18:04,490 --> 00:18:09,320
mode where we actually register a

00:18:07,040 --> 00:18:12,800
cleaner and we keep track of when a

00:18:09,320 --> 00:18:16,280
segment goes out of scope and the close

00:18:12,800 --> 00:18:18,200
method has not been colonnades so the

00:18:16,280 --> 00:18:20,660
way you work with segments as I said you

00:18:18,200 --> 00:18:22,850
don't need to do a lot an awful lot you

00:18:20,660 --> 00:18:24,620
can just allocate your segments of the

00:18:22,850 --> 00:18:26,210
right size so here if we want to

00:18:24,620 --> 00:18:28,700
allocate a segment that is big enough to

00:18:26,210 --> 00:18:30,380
contain our obstructive point array we

00:18:28,700 --> 00:18:32,360
have to do a little bit of computation

00:18:30,380 --> 00:18:34,460
there are four bytes for each in there

00:18:32,360 --> 00:18:35,929
are two ins for each point and then

00:18:34,460 --> 00:18:38,450
there are five points in the array and

00:18:35,929 --> 00:18:40,640
then I can just derive our byte buffer

00:18:38,450 --> 00:18:42,860
from the segment and then pretend that

00:18:40,640 --> 00:18:44,929
the segment doesn't even exist we just

00:18:42,860 --> 00:18:46,580
use the byte buffer API to put the int

00:18:44,929 --> 00:18:50,390
for the x-coordinate and the

00:18:46,580 --> 00:18:52,070
y-coordinate into a loop and then at the

00:18:50,390 --> 00:18:55,640
end of the try with resources when I

00:18:52,070 --> 00:18:58,280
close the brace a claw a closed

00:18:55,640 --> 00:18:59,840
operation will happen the the memory

00:18:58,280 --> 00:19:03,679
associated with a segment will actually

00:18:59,840 --> 00:19:07,130
be released so did I gain anything by

00:19:03,679 --> 00:19:09,710
doing this round trip between memory

00:19:07,130 --> 00:19:12,650
segments and by buffer well actually

00:19:09,710 --> 00:19:15,500
again quite a bit because I got rid of

00:19:12,650 --> 00:19:18,350
that expensive allocate direct operation

00:19:15,500 --> 00:19:20,500
the byte buffer that we are creating now

00:19:18,350 --> 00:19:23,990
is just a view of the memory of the

00:19:20,500 --> 00:19:27,260
segment so it's a much cheaper operation

00:19:23,990 --> 00:19:29,120
to do and we also have deterministic the

00:19:27,260 --> 00:19:32,420
location at the end so we no longer have

00:19:29,120 --> 00:19:34,550
to rely on the garbage collector to go

00:19:32,420 --> 00:19:36,440
in and free the memory we can actually

00:19:34,550 --> 00:19:39,140
say when the memory needs to be freed

00:19:36,440 --> 00:19:41,300
and so if you write this code you will

00:19:39,140 --> 00:19:43,400
get the same performances that you could

00:19:41,300 --> 00:19:46,309
get with the benchmark as I show you

00:19:43,400 --> 00:19:47,840
last that was using an unsafe method to

00:19:46,309 --> 00:19:50,000
clean the memory actually this should go

00:19:47,840 --> 00:19:52,070
even faster because you are paying a lot

00:19:50,000 --> 00:19:56,870
less for the first allocation of memory

00:19:52,070 --> 00:19:58,910
with the memory segment of native there

00:19:56,870 --> 00:20:00,630
are problems in this code though not

00:19:58,910 --> 00:20:03,960
gonna lie for exam

00:20:00,630 --> 00:20:05,520
we have to compute the size of the

00:20:03,960 --> 00:20:07,830
memory that we want to lock it manually

00:20:05,520 --> 00:20:10,350
and then there are all these offset and

00:20:07,830 --> 00:20:12,660
constant spread all over the code and

00:20:10,350 --> 00:20:15,090
this is very fragile if I change for

00:20:12,660 --> 00:20:18,540
example the coordinates from in to be

00:20:15,090 --> 00:20:20,390
lungs for example probably on 64 machine

00:20:18,540 --> 00:20:23,190
this example is no longer going to work

00:20:20,390 --> 00:20:25,980
so how can we make this code a little

00:20:23,190 --> 00:20:27,960
bit more robust well our idea was to

00:20:25,980 --> 00:20:29,850
introduce to introduce an abstraction

00:20:27,960 --> 00:20:31,950
called memory layout and the goal of

00:20:29,850 --> 00:20:34,500
this abstraction is actually to be able

00:20:31,950 --> 00:20:36,540
to replace that comment and they show in

00:20:34,500 --> 00:20:39,390
the previous life so this thing at the

00:20:36,540 --> 00:20:40,980
top with an actual object creation so

00:20:39,390 --> 00:20:44,250
you can actually create an object which

00:20:40,980 --> 00:20:47,460
specify what is the layout of this array

00:20:44,250 --> 00:20:48,780
of tracks the advantage of doing that is

00:20:47,460 --> 00:20:51,210
that once you have an object you can

00:20:48,780 --> 00:20:53,520
derive all sort of important information

00:20:51,210 --> 00:20:56,790
out of it so for example how big is your

00:20:53,520 --> 00:20:58,790
layout what are the alignment of some of

00:20:56,790 --> 00:21:01,920
the components in in the layout and

00:20:58,790 --> 00:21:03,540
since layout can compose so you can

00:21:01,920 --> 00:21:07,760
basically nest layouts inside other

00:21:03,540 --> 00:21:09,870
layouts you can use layout paths to ask

00:21:07,760 --> 00:21:13,340
tricky questions such as what is the

00:21:09,870 --> 00:21:18,090
offset of the field Y inside a point

00:21:13,340 --> 00:21:19,410
which will be normally have been an end

00:21:18,090 --> 00:21:21,990
written constant and now you can

00:21:19,410 --> 00:21:24,480
actually ask the API for that and you

00:21:21,990 --> 00:21:26,370
can imagine that when working with more

00:21:24,480 --> 00:21:28,410
complex tracks they will this will

00:21:26,370 --> 00:21:30,600
actually be useful so the big bet here

00:21:28,410 --> 00:21:32,520
is that by having more declarative code

00:21:30,600 --> 00:21:36,780
there will be less places for boxed

00:21:32,520 --> 00:21:39,930
white so this is how we model the point

00:21:36,780 --> 00:21:41,850
struct using a layout so of course we

00:21:39,930 --> 00:21:43,830
have to start from the outside we create

00:21:41,850 --> 00:21:45,780
a sequence layout we call it sequence

00:21:43,830 --> 00:21:47,250
layout you have to specify a size which

00:21:45,780 --> 00:21:49,980
is 5 in this case and then you have to

00:21:47,250 --> 00:21:51,810
specify what goes inside the signals in

00:21:49,980 --> 00:21:54,000
this case we have a struct so we just

00:21:51,810 --> 00:21:55,560
call memory layout of struct and then we

00:21:54,000 --> 00:21:58,470
have to specify what are the field of

00:21:55,560 --> 00:22:02,070
the struct and there are two int 32 bits

00:21:58,470 --> 00:22:07,470
I'm assuming the injurer map to 32 bit

00:22:02,070 --> 00:22:10,860
value and I can even attach names to the

00:22:07,470 --> 00:22:13,270
field so that then I can actually

00:22:10,860 --> 00:22:15,580
perform queries on

00:22:13,270 --> 00:22:17,320
particularly out so here I've done a

00:22:15,580 --> 00:22:22,230
little bit of simplification in reality

00:22:17,320 --> 00:22:25,900
if you try it out on the Java 14 code

00:22:22,230 --> 00:22:27,940
the constructor for the value bits will

00:22:25,900 --> 00:22:29,560
also take an engine s because of course

00:22:27,940 --> 00:22:30,700
you have to specify whether you are big

00:22:29,560 --> 00:22:33,640
and Ian or little-endian

00:22:30,700 --> 00:22:39,100
but it didn't fit in this line so that's

00:22:33,640 --> 00:22:40,990
kind of what it is so let's say that we

00:22:39,100 --> 00:22:43,990
have this big layout here which

00:22:40,990 --> 00:22:46,540
represents my array and I want to

00:22:43,990 --> 00:22:48,400
compute the offset of the Y field inside

00:22:46,540 --> 00:22:49,930
a point how can I do that

00:22:48,400 --> 00:22:51,660
well there is an animated inside a

00:22:49,930 --> 00:22:56,500
layout object which is called offset

00:22:51,660 --> 00:23:00,460
without too much fantasy maybe you have

00:22:56,500 --> 00:23:04,690
to pass a path that enable the method to

00:23:00,460 --> 00:23:07,420
find the field that you want to get the

00:23:04,690 --> 00:23:09,700
offset for starting from the outer

00:23:07,420 --> 00:23:11,200
layout so here we are starting from the

00:23:09,700 --> 00:23:12,940
sequence layout the first thing I have

00:23:11,200 --> 00:23:14,980
to do is to choose an element of the

00:23:12,940 --> 00:23:16,900
sequence let's say that we pick the

00:23:14,980 --> 00:23:19,900
element number 0 because that's the one

00:23:16,900 --> 00:23:21,790
with the least offset and then inside

00:23:19,900 --> 00:23:25,240
the sequence now I have to choose which

00:23:21,790 --> 00:23:27,280
of the two fields tracks I want for

00:23:25,240 --> 00:23:34,120
computing the offset in this case I

00:23:27,280 --> 00:23:36,580
wonder why field and so by doing this I

00:23:34,120 --> 00:23:38,860
was able to specify a path from the

00:23:36,580 --> 00:23:43,300
sequence down to the Y field and now I

00:23:38,860 --> 00:23:45,100
can ask for the offset so as you can see

00:23:43,300 --> 00:23:47,170
I have been able to obtain the officer

00:23:45,100 --> 00:23:49,540
without writing any number I'm just

00:23:47,170 --> 00:23:51,640
essentially querying the API and that's

00:23:49,540 --> 00:23:53,890
exactly what we are doing now in this

00:23:51,640 --> 00:23:55,990
orbit and example we got rid of the

00:23:53,890 --> 00:23:58,900
comment at the beginning of the example

00:23:55,990 --> 00:24:01,300
that we had before and we replace it

00:23:58,900 --> 00:24:03,100
with an actual memory layout

00:24:01,300 --> 00:24:04,870
instantiation so now we have an object

00:24:03,100 --> 00:24:06,490
that describes the layout of the scene

00:24:04,870 --> 00:24:09,370
of the things that we are going to work

00:24:06,490 --> 00:24:11,440
on and then I am able in the middle part

00:24:09,370 --> 00:24:13,420
of this light to use the layout to

00:24:11,440 --> 00:24:17,460
derive constants such as how big is a

00:24:13,420 --> 00:24:20,440
point or what is the offset of the Y

00:24:17,460 --> 00:24:22,840
field inside the struct point and then I

00:24:20,440 --> 00:24:25,470
can use all the stuff inside my loop to

00:24:22,840 --> 00:24:26,980
get rid of all the numeric constants and

00:24:25,470 --> 00:24:29,530
most important

00:24:26,980 --> 00:24:32,860
I can use the layout directly into the

00:24:29,530 --> 00:24:35,410
allocate call for the memory segment

00:24:32,860 --> 00:24:38,200
which means I don't have to write the

00:24:35,410 --> 00:24:42,880
size by end I will just delegate the

00:24:38,200 --> 00:24:44,590
layout API to do the right thing so this

00:24:42,880 --> 00:24:46,510
is much easier to read

00:24:44,590 --> 00:24:48,820
we gain quite a lot in terms of

00:24:46,510 --> 00:24:51,490
expressiveness there is still a little

00:24:48,820 --> 00:24:54,370
bit there is still something I don't

00:24:51,490 --> 00:24:56,080
quite like which is if we go inside the

00:24:54,370 --> 00:24:59,200
loop we see that there are two calls to

00:24:56,080 --> 00:25:00,790
the byte buffer put int method it's

00:24:59,200 --> 00:25:03,669
pretty hard looking at this code that

00:25:00,790 --> 00:25:05,830
one call is meant to set one field of

00:25:03,669 --> 00:25:07,960
the struct and the other Col is meant to

00:25:05,830 --> 00:25:10,120
set a different field of this right it's

00:25:07,960 --> 00:25:13,059
only the opposite computation that kind

00:25:10,120 --> 00:25:15,400
of gives away that information so that's

00:25:13,059 --> 00:25:17,080
yet another place where bugs can hide so

00:25:15,400 --> 00:25:19,240
can we do a little bit better can we

00:25:17,080 --> 00:25:22,330
improve a little bit on that and the

00:25:19,240 --> 00:25:25,260
idea that we got maybe a crazy idea was

00:25:22,330 --> 00:25:27,970
to introduce a new breed of Rendell's

00:25:25,260 --> 00:25:30,370
called memory access and those for those

00:25:27,970 --> 00:25:32,559
of you who are not able or familiar re

00:25:30,370 --> 00:25:35,830
not not familiar with the Bible with the

00:25:32,559 --> 00:25:38,410
veranda API you can think of a ver endl

00:25:35,830 --> 00:25:41,110
as a java.lang reflect field on steroids

00:25:38,410 --> 00:25:44,740
in the sense that a reflective field

00:25:41,110 --> 00:25:47,679
gives you access to Java fields however

00:25:44,740 --> 00:25:49,900
Endor gives you also access to effective

00:25:47,679 --> 00:25:52,929
access to Java field but also to more

00:25:49,900 --> 00:25:55,200
variables such as array elements or byte

00:25:52,929 --> 00:25:58,900
buffer element so it cannot felt natural

00:25:55,200 --> 00:26:02,830
to also provide a newer endl that was

00:25:58,900 --> 00:26:04,630
also able to give you access to for

00:26:02,830 --> 00:26:08,140
example of a memory by taking as a

00:26:04,630 --> 00:26:09,910
coordinate a memory address the big gain

00:26:08,140 --> 00:26:14,290
that you get with this API is that

00:26:09,910 --> 00:26:16,240
number one you get all the atomic

00:26:14,290 --> 00:26:18,850
operation that the Veronal api support

00:26:16,240 --> 00:26:21,370
so let's say that the byte buffer api is

00:26:18,850 --> 00:26:23,260
not enough you you're not good enough

00:26:21,370 --> 00:26:26,320
with just a thing i've seen a simple

00:26:23,260 --> 00:26:28,179
gasp you want an atomic yet or something

00:26:26,320 --> 00:26:29,260
like that you want memory fencing

00:26:28,179 --> 00:26:31,750
because you're working with multiple

00:26:29,260 --> 00:26:33,730
threads then you need to reach for the

00:26:31,750 --> 00:26:36,549
very end or API that's that's probably

00:26:33,730 --> 00:26:38,860
the best API to to do this kind of stuff

00:26:36,549 --> 00:26:40,360
with and the second bonus point is that

00:26:38,860 --> 00:26:42,220
if you are using memory layout

00:26:40,360 --> 00:26:44,169
you don't have to do anything

00:26:42,220 --> 00:26:46,330
particularly fancy in order to get this

00:26:44,169 --> 00:26:47,830
ver endl you can just ask the layout API

00:26:46,330 --> 00:26:51,309
give me the Rendell for access in the

00:26:47,830 --> 00:26:53,140
field and you will basically get it so

00:26:51,309 --> 00:26:56,350
if you want to see how this Virender

00:26:53,140 --> 00:26:57,760
work there is a factory inside the

00:26:56,350 --> 00:27:00,760
memory access API that allows you to

00:26:57,760 --> 00:27:02,500
construct other Lendl's by end typically

00:27:00,760 --> 00:27:03,940
you won't have to do that because as I

00:27:02,500 --> 00:27:06,010
said before you will derive their

00:27:03,940 --> 00:27:07,539
orlando's from the layouts but let's say

00:27:06,010 --> 00:27:09,880
that you want to kind of go through the

00:27:07,539 --> 00:27:12,190
process and create the Randalls a bit by

00:27:09,880 --> 00:27:13,750
bit so when you create a memory access

00:27:12,190 --> 00:27:16,240
Brendel the first thing that you have to

00:27:13,750 --> 00:27:19,179
specify is a carrier type so you have to

00:27:16,240 --> 00:27:21,130
say to the very end all what is the java

00:27:19,179 --> 00:27:23,139
type that you want to come out of for

00:27:21,130 --> 00:27:25,480
example of a get operation so in this

00:27:23,139 --> 00:27:27,730
case we want to read the value as int

00:27:25,480 --> 00:27:31,000
because the value are 4 bytes so we are

00:27:27,730 --> 00:27:33,100
going to pass the in class to the very

00:27:31,000 --> 00:27:35,409
end or factory and so we get a ver end

00:27:33,100 --> 00:27:38,110
all that for example if I give the base

00:27:35,409 --> 00:27:41,620
address of this segment it will give me

00:27:38,110 --> 00:27:44,230
back the value of the x0 coordinate can

00:27:41,620 --> 00:27:47,350
I do more yes of course if I want for

00:27:44,230 --> 00:27:50,740
example to read that y0 rather than x0 I

00:27:47,350 --> 00:27:52,720
can combine my previous veranda with an

00:27:50,740 --> 00:27:55,360
offset so I can essentially take the

00:27:52,720 --> 00:27:57,850
address that comes in attach an extra

00:27:55,360 --> 00:28:00,639
officer to it move it and then rate at

00:27:57,850 --> 00:28:03,039
the second address and so I can read y0

00:28:00,639 --> 00:28:06,100
if I pass the base address I can get y0

00:28:03,039 --> 00:28:08,320
out but can I do something more fancy

00:28:06,100 --> 00:28:11,139
like can I access all the y-coordinates

00:28:08,320 --> 00:28:14,980
in this array actually turns out I can I

00:28:11,139 --> 00:28:17,049
can construct a strided berrendo so I

00:28:14,980 --> 00:28:18,610
can pass in this ride in this case let's

00:28:17,049 --> 00:28:21,070
try this of course the size of the point

00:28:18,610 --> 00:28:22,809
and so I get back a veranda that takes

00:28:21,070 --> 00:28:25,000
an extra cord and not just a memory

00:28:22,809 --> 00:28:26,980
address but also along where the longest

00:28:25,000 --> 00:28:30,730
illogical index which is which basically

00:28:26,980 --> 00:28:35,529
says which point I want to get the Y

00:28:30,730 --> 00:28:38,860
from so if I do for example I get with

00:28:35,529 --> 00:28:41,260
an index of 0 we get y 0 if I specify 1

00:28:38,860 --> 00:28:42,360
as an index I will get Y am y1 and so

00:28:41,260 --> 00:28:45,610
forth

00:28:42,360 --> 00:28:46,779
now constructing Brando's like that may

00:28:45,610 --> 00:28:49,360
be a little bit painful

00:28:46,779 --> 00:28:50,170
so we integrated this veranda machinery

00:28:49,360 --> 00:28:52,890
with the memory

00:28:50,170 --> 00:28:55,600
API so as you can see in the middle

00:28:52,890 --> 00:28:57,880
sequence of the slide we can actually

00:28:55,600 --> 00:29:01,240
derive all the VAR handle for accessing

00:28:57,880 --> 00:29:03,700
X&Y with two simple calls to the layout

00:29:01,240 --> 00:29:06,370
API there is a veranda method you

00:29:03,700 --> 00:29:08,590
specify a karyotype then you specify a

00:29:06,370 --> 00:29:10,900
path down to the element that you want

00:29:08,590 --> 00:29:13,360
to access and so you can construct into

00:29:10,900 --> 00:29:15,700
lines our handle for the X element our

00:29:13,360 --> 00:29:17,830
endo for the Y element and now inside

00:29:15,700 --> 00:29:21,010
the loop you can see that I'm using the

00:29:17,830 --> 00:29:22,930
X bar and all for setting the X elements

00:29:21,010 --> 00:29:24,760
and the y ver and all for accessing the

00:29:22,930 --> 00:29:27,250
Y element so now the code is more

00:29:24,760 --> 00:29:29,440
explicit and if I change anything in the

00:29:27,250 --> 00:29:33,010
layout up there everything will just

00:29:29,440 --> 00:29:39,040
flow so I won't need to update this code

00:29:33,010 --> 00:29:41,380
at the bottom ever again okay so let's

00:29:39,040 --> 00:29:44,380
switch gears a little bit and talk about

00:29:41,380 --> 00:29:47,230
safety as I said at the beginning this

00:29:44,380 --> 00:29:51,370
is a safe API so one of the main goal is

00:29:47,230 --> 00:29:53,500
to avoid any kind of VM crashes it is

00:29:51,370 --> 00:29:56,050
beyond the scope of this API to avoid

00:29:53,500 --> 00:29:59,590
the kind of silly user mistakes such as

00:29:56,050 --> 00:30:02,230
writing and in maybe a day reading the

00:29:59,590 --> 00:30:04,150
four byte value as a float that's not

00:30:02,230 --> 00:30:06,250
something we want to protect you against

00:30:04,150 --> 00:30:07,720
but for example there are a couple of

00:30:06,250 --> 00:30:10,300
conditions that we want to protect you

00:30:07,720 --> 00:30:13,120
against such as accessing memory out of

00:30:10,300 --> 00:30:16,120
bounds which if the memories of heap can

00:30:13,120 --> 00:30:18,550
result in a crash and also accessing

00:30:16,120 --> 00:30:21,600
memory after the memory has already been

00:30:18,550 --> 00:30:24,370
free the second problem is in particular

00:30:21,600 --> 00:30:26,620
not a nasty one especially when you

00:30:24,370 --> 00:30:28,090
consider multiple threads accessing

00:30:26,620 --> 00:30:31,120
memory at the same time because you can

00:30:28,090 --> 00:30:34,120
have one thread doing access and another

00:30:31,120 --> 00:30:37,000
thread doing the release so how the X do

00:30:34,120 --> 00:30:38,710
we make this safe it's actually pretty

00:30:37,000 --> 00:30:40,870
tricky you could lock everything but

00:30:38,710 --> 00:30:44,560
that basically kills the performances

00:30:40,870 --> 00:30:47,260
instead what we decided to do was to by

00:30:44,560 --> 00:30:49,030
default and force a strong confinement

00:30:47,260 --> 00:30:51,340
model so that whenever you create a

00:30:49,030 --> 00:30:53,650
segment the segment is confined to that

00:30:51,340 --> 00:30:55,840
particular thread who created it so only

00:30:53,650 --> 00:30:57,970
the thread has access to the memory with

00:30:55,840 --> 00:31:00,310
the segment any other thread that want

00:30:57,970 --> 00:31:02,800
to join in can but it has to do an

00:31:00,310 --> 00:31:03,670
explicit operation called acquire use

00:31:02,800 --> 00:31:05,890
acquire would call

00:31:03,670 --> 00:31:08,620
we'll create a view that is specific to

00:31:05,890 --> 00:31:11,380
that second thread and you can only

00:31:08,620 --> 00:31:13,930
close the original segment after all the

00:31:11,380 --> 00:31:16,150
acquired views have gone so we still

00:31:13,930 --> 00:31:18,280
have deterministic the location even in

00:31:16,150 --> 00:31:19,660
the presence of multiple threads but if

00:31:18,280 --> 00:31:22,180
you are working with multiple threads

00:31:19,660 --> 00:31:26,980
you have to be explicit on who is

00:31:22,180 --> 00:31:28,840
accessing what so how does this

00:31:26,980 --> 00:31:31,120
translation turn on performances this

00:31:28,840 --> 00:31:35,590
was the best result we could squeeze out

00:31:31,120 --> 00:31:37,660
of the byte buffer API we have to cheat

00:31:35,590 --> 00:31:39,310
a little bit by using and save and this

00:31:37,660 --> 00:31:42,430
is our these are the numbers that are

00:31:39,310 --> 00:31:46,600
coming today out of the memory segment

00:31:42,430 --> 00:31:48,820
API they are still not as good as they

00:31:46,600 --> 00:31:52,120
are safe numbers but they are a little

00:31:48,820 --> 00:31:53,980
bit better than by buffer once the main

00:31:52,120 --> 00:31:55,480
contributor I think for this number is

00:31:53,980 --> 00:31:58,330
the fact that the location got a lot

00:31:55,480 --> 00:32:01,570
less expensive compared to the byte

00:31:58,330 --> 00:32:03,430
buffer allocate direct method but there

00:32:01,570 --> 00:32:06,910
are also other things so all the bounds

00:32:03,430 --> 00:32:12,880
are final variable source it you can use

00:32:06,910 --> 00:32:14,410
them at will almost and there is still a

00:32:12,880 --> 00:32:16,450
little bit of difference also we have to

00:32:14,410 --> 00:32:18,970
keep in mind that we are also zero in

00:32:16,450 --> 00:32:21,370
memory with the memory segment API so we

00:32:18,970 --> 00:32:24,280
can never go quite as fast as unsafe

00:32:21,370 --> 00:32:27,580
here but we are also kind of trying to

00:32:24,280 --> 00:32:30,670
look ahead a little bit and we are we

00:32:27,580 --> 00:32:32,470
don't want just to provide you something

00:32:30,670 --> 00:32:34,990
that looks a little bit better than byte

00:32:32,470 --> 00:32:37,060
buffer we want to give you something

00:32:34,990 --> 00:32:38,380
that is actually more scalable as I was

00:32:37,060 --> 00:32:40,540
mentioning at the beginning so we are

00:32:38,380 --> 00:32:42,460
working on a different alligator Jim

00:32:40,540 --> 00:32:44,380
Lasky is doing a bunch of work on this

00:32:42,460 --> 00:32:47,710
new locator called the quota based

00:32:44,380 --> 00:32:49,090
alligator and the number so far and kind

00:32:47,710 --> 00:32:51,520
of teasing you a little bit are pretty

00:32:49,090 --> 00:32:53,590
impressive in the sense that after I did

00:32:51,520 --> 00:32:54,940
some experiment experiment to plug in

00:32:53,590 --> 00:32:58,240
this mean a locator on the memory

00:32:54,940 --> 00:33:00,400
segment API I was able to reach better

00:32:58,240 --> 00:33:03,340
performances then I'm safe even though I

00:33:00,400 --> 00:33:05,260
was still sharing memory so this

00:33:03,340 --> 00:33:06,880
alligator is doing a lot of the tricks

00:33:05,260 --> 00:33:08,890
that the nettie allocated probably does

00:33:06,880 --> 00:33:10,450
but there are a couple of tricks that I

00:33:08,890 --> 00:33:13,180
think are new for so for example we

00:33:10,450 --> 00:33:16,060
instead of committing memory eagerly

00:33:13,180 --> 00:33:16,400
we pre reserved a big bunch of memory

00:33:16,060 --> 00:33:18,440
like

00:33:16,400 --> 00:33:21,080
four gigabytes and then we only commit

00:33:18,440 --> 00:33:23,150
when the client requests memory and

00:33:21,080 --> 00:33:25,130
doing these sales performance is quite a

00:33:23,150 --> 00:33:27,920
bit but the big save is that we don't

00:33:25,130 --> 00:33:30,830
need a native call for doing a mal lock

00:33:27,920 --> 00:33:33,170
each time we allocate a new segment or

00:33:30,830 --> 00:33:34,940
each time we have to free it because the

00:33:33,170 --> 00:33:38,420
locator will be able to recycle this

00:33:34,940 --> 00:33:41,210
memory segments that are being ended out

00:33:38,420 --> 00:33:43,460
and released so this is kind of where

00:33:41,210 --> 00:33:45,080
the future of this API is kind of

00:33:43,460 --> 00:33:46,640
heading and I think if we deliver

00:33:45,080 --> 00:33:49,420
something like this maybe

00:33:46,640 --> 00:33:52,250
or at least hopefully some of the

00:33:49,420 --> 00:33:54,410
alternative API to byte buffer will over

00:33:52,250 --> 00:33:56,270
time disappear or maybe people that are

00:33:54,410 --> 00:34:02,690
going to write new API will decide to

00:33:56,270 --> 00:34:05,480
stay on the main JDK API how hard was it

00:34:02,690 --> 00:34:09,110
to get there well I'm gonna be honest it

00:34:05,480 --> 00:34:10,940
was a little bit hard Andrew did some

00:34:09,110 --> 00:34:13,370
benchmark of this API in France from

00:34:10,940 --> 00:34:16,190
issues there are indeed some issues we'd

00:34:13,370 --> 00:34:19,909
fix some of the stuff on in Java 14

00:34:16,190 --> 00:34:21,500
already so for example hotspot was very

00:34:19,909 --> 00:34:23,419
conservative with respect to memory

00:34:21,500 --> 00:34:27,130
barriers every time there was an unsafe

00:34:23,419 --> 00:34:32,720
access it will immediately add barriers

00:34:27,130 --> 00:34:35,060
after the call now C 2 is go is behaving

00:34:32,720 --> 00:34:37,130
a little bit better and it's removing

00:34:35,060 --> 00:34:39,649
barriers when the access is probably of

00:34:37,130 --> 00:34:41,929
HIPPA and these also improve the

00:34:39,649 --> 00:34:43,870
performance of the base by buffer API so

00:34:41,929 --> 00:34:46,460
that that's actually a good result

00:34:43,870 --> 00:34:50,120
thread confinement checks were not very

00:34:46,460 --> 00:34:52,399
well treated by C 2 most of all because

00:34:50,120 --> 00:34:56,510
the thread dot current thread was not

00:34:52,399 --> 00:34:58,670
being perceived as a constant by C 2 so

00:34:56,510 --> 00:35:01,670
we did some work like this from work in

00:34:58,670 --> 00:35:03,020
order to to fix that and now

00:35:01,670 --> 00:35:04,250
performances are a little bit better

00:35:03,020 --> 00:35:06,710
although we have to disable this

00:35:04,250 --> 00:35:08,690
optimization for on the loom branch

00:35:06,710 --> 00:35:12,410
because this of course creates all sorts

00:35:08,690 --> 00:35:14,330
of havoc with with fibers but we are not

00:35:12,410 --> 00:35:17,270
done there are a lot of issues around

00:35:14,330 --> 00:35:19,970
escape analysis this API as I said is

00:35:17,270 --> 00:35:21,710
immutable every time you call Base

00:35:19,970 --> 00:35:23,720
address you create a new instance every

00:35:21,710 --> 00:35:25,550
time you do add offset on an address you

00:35:23,720 --> 00:35:27,820
create a new instance and some time

00:35:25,550 --> 00:35:30,300
these instances go in the middle and

00:35:27,820 --> 00:35:34,920
perturb some of the situation is a

00:35:30,300 --> 00:35:35,760
that situation I see through some of

00:35:34,920 --> 00:35:38,610
their locations

00:35:35,760 --> 00:35:40,440
the resolves another problem and this is

00:35:38,610 --> 00:35:44,000
probably the main problem with this API

00:35:40,440 --> 00:35:47,790
the API accept long as illnesses and

00:35:44,000 --> 00:35:50,280
this is good because it gives more room

00:35:47,790 --> 00:35:52,170
for this API to grow but at the same

00:35:50,280 --> 00:35:54,500
time we are running into some

00:35:52,170 --> 00:35:58,140
bottlenecks with c2 in the sense that

00:35:54,500 --> 00:36:01,470
situation is to remove bound checks on

00:35:58,140 --> 00:36:04,890
loops that work on int so as as soon as

00:36:01,470 --> 00:36:06,870
you step out of fins you are into a nip

00:36:04,890 --> 00:36:10,110
of trouble and the about track

00:36:06,870 --> 00:36:11,400
elimination along your work loops are no

00:36:10,110 --> 00:36:13,560
longer enrolled you don't get

00:36:11,400 --> 00:36:17,310
vectorization any of that so right now

00:36:13,560 --> 00:36:20,370
we are doing some Erichs in order to try

00:36:17,310 --> 00:36:22,980
to can generate the right set of code

00:36:20,370 --> 00:36:25,050
but we think that the right approach

00:36:22,980 --> 00:36:28,680
longer term will be to fix this big

00:36:25,050 --> 00:36:32,190
performance gap at least let see to to

00:36:28,680 --> 00:36:35,400
see whether a segment is bigger than 2

00:36:32,190 --> 00:36:38,340
gigabytes or not and if it is not then

00:36:35,400 --> 00:36:41,520
revert to the logic and optimization

00:36:38,340 --> 00:36:44,850
that we already have in other words

00:36:41,520 --> 00:36:47,180
there's more work here to be add so I

00:36:44,850 --> 00:36:49,650
think the memory of access API is a

00:36:47,180 --> 00:36:53,750
great alternative to the by buffer API

00:36:49,650 --> 00:36:56,850
or a great compliment it is a fully

00:36:53,750 --> 00:37:00,780
immutable API so it should land over

00:36:56,850 --> 00:37:02,340
time to better JIT optimization there is

00:37:00,780 --> 00:37:04,140
deterministic there location that you

00:37:02,340 --> 00:37:06,150
didn't have with my buffer and that

00:37:04,140 --> 00:37:08,790
makes quite a difference in terms of GC

00:37:06,150 --> 00:37:10,890
load the addressing limited the

00:37:08,790 --> 00:37:12,810
addressing scheme is not limited to qu

00:37:10,890 --> 00:37:14,490
gigabyte which also makes a different if

00:37:12,810 --> 00:37:17,640
you are using persistent memories or

00:37:14,490 --> 00:37:19,770
things like that and there is a real

00:37:17,640 --> 00:37:23,010
ability for doing structural access with

00:37:19,770 --> 00:37:26,100
the Rendell's memory layouts so I think

00:37:23,010 --> 00:37:28,440
it's a very compelling alternative to my

00:37:26,100 --> 00:37:33,020
buffer if what you want to do is on say

00:37:28,440 --> 00:37:35,700
is of it the memory access API is safe

00:37:33,020 --> 00:37:38,930
it's a safe by buffer so it's a good

00:37:35,700 --> 00:37:42,000
safe replacement tool for the unsafe API

00:37:38,930 --> 00:37:43,630
there are spatial and temporal checks on

00:37:42,000 --> 00:37:45,520
every access and

00:37:43,630 --> 00:37:48,010
robust ownership model which allow you

00:37:45,520 --> 00:37:49,990
to remain safe even if you are working

00:37:48,010 --> 00:37:53,410
on multiple thread and still retained

00:37:49,990 --> 00:37:55,360
the deterministic the allocation so

00:37:53,410 --> 00:37:58,600
where does all it fit in the bigger

00:37:55,360 --> 00:38:00,460
Panama picture I'm not going to talk

00:37:58,600 --> 00:38:05,170
about Chennai but I just wanted to give

00:38:00,460 --> 00:38:09,220
you a taste of kind of where it all fits

00:38:05,170 --> 00:38:11,740
together so as Mark showed earlier we

00:38:09,220 --> 00:38:13,300
want to impanel ah we want to give you

00:38:11,740 --> 00:38:16,840
tools so that you can start from an

00:38:13,300 --> 00:38:19,360
Ender file do some work and derive a set

00:38:16,840 --> 00:38:21,100
of Java bindings and these are bindings

00:38:19,360 --> 00:38:22,990
initially we thought well maybe they are

00:38:21,100 --> 00:38:25,210
interfaces with some annotation and then

00:38:22,990 --> 00:38:27,160
there will be a runtime component that

00:38:25,210 --> 00:38:29,410
reads the notation and we generate some

00:38:27,160 --> 00:38:31,870
code on the fly we actually realize that

00:38:29,410 --> 00:38:34,990
there's no need for that we only need

00:38:31,870 --> 00:38:36,850
two pieces one is the memory I memory

00:38:34,990 --> 00:38:39,120
access API piece which gives you a bunch

00:38:36,850 --> 00:38:41,920
of bar endles for accessing the memory

00:38:39,120 --> 00:38:43,750
for example struct fields at particular

00:38:41,920 --> 00:38:48,040
offset and things like that the second

00:38:43,750 --> 00:38:50,140
bit is a foreign function API bit which

00:38:48,040 --> 00:38:53,170
were going probably to deliver in 15

00:38:50,140 --> 00:38:55,240
also as an incubating API which allows

00:38:53,170 --> 00:38:57,820
you to map foreign function as method

00:38:55,240 --> 00:39:00,400
endles on top of these two bits you are

00:38:57,820 --> 00:39:02,260
able to create a very low-level set of

00:39:00,400 --> 00:39:04,420
bindings and then you can also build on

00:39:02,260 --> 00:39:06,400
top of those if you want you can add the

00:39:04,420 --> 00:39:08,050
plugins to the basic tool that we will

00:39:06,400 --> 00:39:10,240
provide and generate higher level

00:39:08,050 --> 00:39:12,520
bindings but the lower level bindings as

00:39:10,240 --> 00:39:13,960
Mark showed before are not so bad we are

00:39:12,520 --> 00:39:18,070
generating static wrapper so they are

00:39:13,960 --> 00:39:19,600
relatively usable so as I said at the

00:39:18,070 --> 00:39:23,020
beginning of this talk this API is

00:39:19,600 --> 00:39:25,090
actually available in Java 14 so my

00:39:23,020 --> 00:39:26,290
recommendation is to kind of try it out

00:39:25,090 --> 00:39:28,990
and report back

00:39:26,290 --> 00:39:32,650
performance portals for usability issues

00:39:28,990 --> 00:39:34,390
or whatever you can find next steps of

00:39:32,650 --> 00:39:36,810
course are to round up the performance

00:39:34,390 --> 00:39:39,840
work we know that we have to better here

00:39:36,810 --> 00:39:42,520
we want also to finish the work on the

00:39:39,840 --> 00:39:44,740
allocator because we think there's a lot

00:39:42,520 --> 00:39:46,330
of room for improvement there and we

00:39:44,740 --> 00:39:48,130
have to polish and finalize the API

00:39:46,330 --> 00:39:49,420
right now is an incubating API there are

00:39:48,130 --> 00:39:50,660
probably methods that need to be

00:39:49,420 --> 00:39:52,369
polished for name or

00:39:50,660 --> 00:39:54,410
whatever and then we have to integrate

00:39:52,369 --> 00:39:56,599
this API into the overarching Panama

00:39:54,410 --> 00:39:58,130
story so you can follow the progress on

00:39:56,599 --> 00:40:00,019
Panama dev but if you are more familiar

00:39:58,130 --> 00:40:01,549
with core libs you can also report the

00:40:00,019 --> 00:40:04,350
issues of your lips I will be looking

00:40:01,549 --> 00:40:14,330
for both so thank you

00:40:04,350 --> 00:40:14,330

YouTube URL: https://www.youtube.com/watch?v=RYrk4wvar6g


