Title: EActors: an actor-based programming framework for Intel SGX
Publication date: 2020-07-17
Playlist: FOSDEM 2020
Description: 
	by Vasily A. Sartakov

At: FOSDEM 2020
https://video.fosdem.org/2020/K.4.601/eactors.webm

In this talk I will present EActors, an actor framework that is tailored to SGX and offers a more seamless, flexible and efficient use of trusted execution â€“ especially for applications demanding multiple enclaves. EActors disentangles the interaction with enclaves and, among them, from costly execution mode transitions. It features lightweight fine-grained parallelism based on the concept of actors, thereby avoiding costly SGX SDK provided synchronisation constructs. Finally, EActors offers a high degree of freedom to execute actors, either untrusted or trusted, depending on security requirements and performance demands.


Please note that this talk was originally scheduled to begin at the later time of 12:25

Room: K.4.601
Scheduled start: 2020-02-01 11:00:00
Captions: 
	00:00:05,660 --> 00:00:14,059
my name is Vasily Sirocco and I would

00:00:10,050 --> 00:00:14,059
like to present you the actors from work

00:00:15,200 --> 00:00:21,060
the first question which I wanted to try

00:00:18,480 --> 00:00:23,130
for answer for which I want to try to

00:00:21,060 --> 00:00:25,380
find is why do we need another framework

00:00:23,130 --> 00:00:33,620
because because a lot of frameworks why

00:00:25,380 --> 00:00:35,730
another one so just for the cup

00:00:33,620 --> 00:00:37,769
intelligence or for new system

00:00:35,730 --> 00:00:39,600
components or calling cliffs in clays

00:00:37,769 --> 00:00:42,899
are part of user space applications and

00:00:39,600 --> 00:00:45,120
they isolated from the code on data of

00:00:42,899 --> 00:00:48,089
enclave's is related from that of adding

00:00:45,120 --> 00:00:50,129
clips so an N cliff can let's a call

00:00:48,089 --> 00:00:52,409
from an cliff can access data allocated

00:00:50,129 --> 00:00:54,269
in ring for inside application but

00:00:52,409 --> 00:00:57,690
cannot access dated and code inside

00:00:54,269 --> 00:00:59,640
another clip and in place are protected

00:00:57,690 --> 00:01:03,860
from a text based on physical access by

00:00:59,640 --> 00:01:06,540
the use of encryption of physical memory

00:01:03,860 --> 00:01:08,220
removes the P rating system and the

00:01:06,540 --> 00:01:10,740
hypervisor from the rustic computing

00:01:08,220 --> 00:01:12,659
base and offer very interesting features

00:01:10,740 --> 00:01:19,189
like local remote attestation and data

00:01:12,659 --> 00:01:22,020
sitting in and more Intel offers

00:01:19,189 --> 00:01:24,530
intelligence decays this is decay

00:01:22,020 --> 00:01:27,390
provides you necessary primitives to

00:01:24,530 --> 00:01:29,610
program in claves and they do this in a

00:01:27,390 --> 00:01:32,520
very straightforward and easy way so you

00:01:29,610 --> 00:01:34,920
can create a function and decorate it in

00:01:32,520 --> 00:01:38,579
a special way then compile this function

00:01:34,920 --> 00:01:41,969
together is the intelligence SDK and SDK

00:01:38,579 --> 00:01:46,049
generates a binary or multiple binaries

00:01:41,969 --> 00:01:51,719
of increase and glue code which allows

00:01:46,049 --> 00:01:53,789
to start or deploy enclave's and this is

00:01:51,719 --> 00:01:55,799
a very intuitive view so is it just an

00:01:53,789 --> 00:02:00,560
LPG like manner of programming of in

00:01:55,799 --> 00:02:02,909
class however there is a problem to

00:02:00,560 --> 00:02:05,159
enter into an cliff you need to perform

00:02:02,909 --> 00:02:07,439
something called alcohol so there are

00:02:05,159 --> 00:02:09,060
mechanisms for switching between

00:02:07,439 --> 00:02:11,640
untrusted and trusted execution

00:02:09,060 --> 00:02:14,250
environments and those transitions are

00:02:11,640 --> 00:02:15,720
very very slow compared to ordinary

00:02:14,250 --> 00:02:18,060
system called

00:02:15,720 --> 00:02:18,560
switching between trusted and untrusted

00:02:18,060 --> 00:02:21,020
00:02:18,560 --> 00:02:23,630
I'm slower and more than 50 times slow

00:02:21,020 --> 00:02:25,670
it's only for the beginning and you will

00:02:23,630 --> 00:02:29,540
need to leave your enclaved very very

00:02:25,670 --> 00:02:31,580
soon because inside and clave you cannot

00:02:29,540 --> 00:02:33,290
directly interact with the kernel so if

00:02:31,580 --> 00:02:35,450
you want to interact with the kernel or

00:02:33,290 --> 00:02:37,040
use the function which is not located

00:02:35,450 --> 00:02:39,920
inside a nuclear you need to leave this

00:02:37,040 --> 00:02:41,630
in code again 50 times slower for

00:02:39,920 --> 00:02:43,190
example you have two threads those two

00:02:41,630 --> 00:02:45,560
threads need to pass a critical section

00:02:43,190 --> 00:02:47,330
they need to use mutexes mutexes

00:02:45,560 --> 00:02:48,950
requires the involvement of the kernel

00:02:47,330 --> 00:02:52,360
boss thread needs to leave the in clave

00:02:48,950 --> 00:02:54,500
we have more than three 200 times slower

00:02:52,360 --> 00:02:57,110
synchronization mechanism compared to

00:02:54,500 --> 00:03:01,239
ordinary middle mutexes so it's very

00:02:57,110 --> 00:03:05,080
very slow it's a response for this issue

00:03:01,239 --> 00:03:08,000
researchers provided several frameworks

00:03:05,080 --> 00:03:11,420
frameworks like heavens corn Griffin is

00:03:08,000 --> 00:03:13,880
jigs as jig so KL pan apply and maybe

00:03:11,420 --> 00:03:17,870
some other so more than five different

00:03:13,880 --> 00:03:20,180
frameworks well and they follow same and

00:03:17,870 --> 00:03:21,980
different approaches at the same time so

00:03:20,180 --> 00:03:24,170
you don't need to leave an end clip if

00:03:21,980 --> 00:03:25,250
you can do everything what you need

00:03:24,170 --> 00:03:27,440
inside and in clave

00:03:25,250 --> 00:03:29,810
so for example you can emulate some

00:03:27,440 --> 00:03:31,730
unavailable system calls inside it in

00:03:29,810 --> 00:03:35,540
clave and therefore you don't need to

00:03:31,730 --> 00:03:37,760
leave them in clay and virus projects

00:03:35,540 --> 00:03:40,160
abstract different layers of the

00:03:37,760 --> 00:03:44,000
software stack so someone or substract

00:03:40,160 --> 00:03:47,239
the leap steve interface another project

00:03:44,000 --> 00:03:50,079
abstract the whole deck let's say in the

00:03:47,239 --> 00:03:52,220
kernel interface but conceptually

00:03:50,079 --> 00:03:56,780
conceptually those frameworks have

00:03:52,220 --> 00:03:58,670
problem it's a monolithic design with a

00:03:56,780 --> 00:04:00,799
lot of these a very huge drastic

00:03:58,670 --> 00:04:02,889
computing base so this is the kind of

00:04:00,799 --> 00:04:05,329
irony you wanted to remove the

00:04:02,889 --> 00:04:07,850
complicated kernel from the trusted

00:04:05,329 --> 00:04:10,100
computing base but to run your legacy

00:04:07,850 --> 00:04:12,049
application you anyway put parts of the

00:04:10,100 --> 00:04:17,780
kernel inside this trusted environment

00:04:12,049 --> 00:04:21,530
so latch GCV is the problem however

00:04:17,780 --> 00:04:23,210
there is another way and a single host a

00:04:21,530 --> 00:04:25,250
single process can host multiple

00:04:23,210 --> 00:04:28,970
enclaves and this is a very interesting

00:04:25,250 --> 00:04:31,670
feature of LG's and clips inside the one

00:04:28,970 --> 00:04:33,710
memory in the lated environment you can

00:04:31,670 --> 00:04:38,060
multiple and in process you can put

00:04:33,710 --> 00:04:40,280
multiple enclave's so your program can

00:04:38,060 --> 00:04:42,440
consist of multiple mutually distrusted

00:04:40,280 --> 00:04:45,350
components located inside different in

00:04:42,440 --> 00:04:48,050
claves what can be what application can

00:04:45,350 --> 00:04:50,920
be for example you have a message server

00:04:48,050 --> 00:04:54,260
like XMPP server and you want to make

00:04:50,920 --> 00:04:55,370
group chats you can put a one group chat

00:04:54,260 --> 00:04:57,200
inside one and cliff

00:04:55,370 --> 00:04:59,330
another group chat another another in

00:04:57,200 --> 00:05:01,460
cliff so they will be protected in in

00:04:59,330 --> 00:05:03,830
the case of intrusion this date will be

00:05:01,460 --> 00:05:09,250
protected obviously and at the same time

00:05:03,830 --> 00:05:12,410
since it's the one single service client

00:05:09,250 --> 00:05:15,050
or should have a mechanism for to

00:05:12,410 --> 00:05:18,140
interact through in place another

00:05:15,050 --> 00:05:19,550
example was considered by people from

00:05:18,140 --> 00:05:21,920
Microsoft thank you very nice like that

00:05:19,550 --> 00:05:25,280
multi-party computation when you have

00:05:21,920 --> 00:05:28,370
multiple mutually distrusted binaries

00:05:25,280 --> 00:05:31,990
but those binary so bill which belong to

00:05:28,370 --> 00:05:34,820
different owners should perform

00:05:31,990 --> 00:05:37,130
mathematical function or find the

00:05:34,820 --> 00:05:39,950
consensus or make a decision together

00:05:37,130 --> 00:05:42,230
without involved without exposing of

00:05:39,950 --> 00:05:45,080
internal values in the simple case you

00:05:42,230 --> 00:05:47,720
have several in isolated parties each

00:05:45,080 --> 00:05:49,700
party has is located inside a link layer

00:05:47,720 --> 00:05:52,820
for example this in clave has a secret

00:05:49,700 --> 00:05:56,060
value inside and three parties should

00:05:52,820 --> 00:05:58,880
perform a mathematical Sun without in

00:05:56,060 --> 00:06:00,530
exposing of urban values so for that

00:05:58,880 --> 00:06:01,700
again you need to have multiple in place

00:06:00,530 --> 00:06:04,340
you need to have a mechanism for

00:06:01,700 --> 00:06:06,740
interaction between them and at the same

00:06:04,340 --> 00:06:09,080
time it should be one unique application

00:06:06,740 --> 00:06:11,330
but not a distributed set of desolated

00:06:09,080 --> 00:06:13,340
or distributed set of different

00:06:11,330 --> 00:06:14,570
applications and to implement such

00:06:13,340 --> 00:06:16,160
applications you need to have a

00:06:14,570 --> 00:06:19,780
programming framework and you need to

00:06:16,160 --> 00:06:22,640
have necessary system support and I

00:06:19,780 --> 00:06:26,390
think the right way is to do this by the

00:06:22,640 --> 00:06:29,210
applying of the actor of the conception

00:06:26,390 --> 00:06:31,670
of actors because actors conceptually

00:06:29,210 --> 00:06:34,220
are not blocking entities and and

00:06:31,670 --> 00:06:36,680
therefore and they follow the conception

00:06:34,220 --> 00:06:39,830
of no sharing so you don't need to

00:06:36,680 --> 00:06:41,180
involve synchronization primitives so

00:06:39,830 --> 00:06:42,590
you don't need to leave an end clave you

00:06:41,180 --> 00:06:44,230
don't need to develop mechanism for

00:06:42,590 --> 00:06:46,330
synchronization is using the

00:06:44,230 --> 00:06:49,600
clave so it's very easy so they don't

00:06:46,330 --> 00:06:51,880
use logs in conception they're very

00:06:49,600 --> 00:06:54,070
lightweight so it's very nice from the

00:06:51,880 --> 00:06:56,920
point of view of another problem related

00:06:54,070 --> 00:06:59,230
to ethics in claims it's the EPC problem

00:06:56,920 --> 00:07:01,720
so there is a problem of paging if the

00:06:59,230 --> 00:07:05,170
size of following claves reaches let's

00:07:01,720 --> 00:07:08,560
say near ninety two megabytes so Actos

00:07:05,170 --> 00:07:11,080
and of course there are many actor based

00:07:08,560 --> 00:07:11,800
systems and the problem that they very

00:07:11,080 --> 00:07:14,410
heavy

00:07:11,800 --> 00:07:16,810
it's very complicated well it's not very

00:07:14,410 --> 00:07:20,170
complicated to pork let's say a long VM

00:07:16,810 --> 00:07:22,960
into SGX the question is what our head

00:07:20,170 --> 00:07:24,760
view you have if you port this so we we

00:07:22,960 --> 00:07:28,330
can use but this very high overhead

00:07:24,760 --> 00:07:31,660
everyone Java and conceptually those

00:07:28,330 --> 00:07:33,550
frameworks are not tailor it for trusted

00:07:31,660 --> 00:07:36,010
execution environment so yes you can run

00:07:33,550 --> 00:07:40,240
it but they are not you they they don't

00:07:36,010 --> 00:07:41,770
use features of in class and let the

00:07:40,240 --> 00:07:43,390
reason why I decide that we need to know

00:07:41,770 --> 00:07:47,290
different work and I will present it

00:07:43,390 --> 00:07:51,160
today so it's a actors is an actor basic

00:07:47,290 --> 00:07:54,280
framework as many other factor basic

00:07:51,160 --> 00:07:56,620
frameworks to describe it I will answer

00:07:54,280 --> 00:07:59,440
three questions what an actor is what is

00:07:56,620 --> 00:08:02,050
an actor how the stock to communicate

00:07:59,440 --> 00:08:05,800
and what system support the framework

00:08:02,050 --> 00:08:09,760
provides this figure shows a general

00:08:05,800 --> 00:08:11,560
view of the actor of of the application

00:08:09,760 --> 00:08:15,220
of an application written in this

00:08:11,560 --> 00:08:19,840
framework so derived several enclaves

00:08:15,220 --> 00:08:22,960
wanting to and there are actors they

00:08:19,840 --> 00:08:26,560
colored a actor in the notion of an

00:08:22,960 --> 00:08:29,740
actor in this framework so there are

00:08:26,560 --> 00:08:31,210
four actors and two actors allocated

00:08:29,740 --> 00:08:33,370
inside one in Clips there are doctors

00:08:31,210 --> 00:08:36,940
located in another clip and there are

00:08:33,370 --> 00:08:39,910
workers workers technically are patriots

00:08:36,940 --> 00:08:43,660
physical threats that provide execution

00:08:39,910 --> 00:08:45,730
context for actors so actors itself a

00:08:43,660 --> 00:08:48,400
passive entities and they can act only

00:08:45,730 --> 00:08:51,130
if they have

00:08:48,400 --> 00:08:53,890
execution context and there are bindings

00:08:51,130 --> 00:08:55,420
between actors and enclaves for example

00:08:53,890 --> 00:08:57,270
you see two actors inside this in clave

00:08:55,420 --> 00:09:00,160
two actors and said this in clave

00:08:57,270 --> 00:09:01,930
workers two CPUs it's the CPU a finicky

00:09:00,160 --> 00:09:04,390
you can say that this threat will work

00:09:01,930 --> 00:09:05,920
will be attached to this CPU that can be

00:09:04,390 --> 00:09:09,490
very useful from the point of view of

00:09:05,920 --> 00:09:14,380
performance and intimidation and actors

00:09:09,490 --> 00:09:17,650
two workers as I said provokers provide

00:09:14,380 --> 00:09:21,970
execution context to create this

00:09:17,650 --> 00:09:24,850
application you need to have the

00:09:21,970 --> 00:09:30,000
framework the source code of your actors

00:09:24,850 --> 00:09:34,060
and the XML file that describes the

00:09:30,000 --> 00:09:36,700
deployment scenario itself so they'll be

00:09:34,060 --> 00:09:39,310
the number one aim of the framework is

00:09:36,700 --> 00:09:41,680
to provide the very simple tools which

00:09:39,310 --> 00:09:43,540
help you to build a very flexible

00:09:41,680 --> 00:09:45,400
application today for example we wanted

00:09:43,540 --> 00:09:47,320
to put all actors inside one and cliff

00:09:45,400 --> 00:09:50,020
tomorrow let's say you want to have five

00:09:47,320 --> 00:09:52,210
different in clips and the switching

00:09:50,020 --> 00:09:55,450
between actors between and clips should

00:09:52,210 --> 00:09:58,360
be very very easy from the point of view

00:09:55,450 --> 00:10:01,240
of the developer and deployment

00:09:58,360 --> 00:10:04,810
scenarios are encoded in or store it

00:10:01,240 --> 00:10:09,220
inside an XML while you don't need to

00:10:04,810 --> 00:10:11,339
fix the source code of your application

00:10:09,220 --> 00:10:15,400
if you want to change the deployment the

00:10:11,339 --> 00:10:18,490
framework itself generates binary binary

00:10:15,400 --> 00:10:20,800
of enclave's so for example we have five

00:10:18,490 --> 00:10:23,830
way enclaves the framework you generate

00:10:20,800 --> 00:10:26,980
you five different enclave's and each in

00:10:23,830 --> 00:10:29,140
clave you have only use it inside this

00:10:26,980 --> 00:10:31,209
in clave our source code of factors so

00:10:29,140 --> 00:10:36,700
they very lightweight without the

00:10:31,209 --> 00:10:38,500
unnecessary code inside and this is a

00:10:36,700 --> 00:10:40,690
very simple application so there is a

00:10:38,500 --> 00:10:43,240
constructor for an actor so this

00:10:40,690 --> 00:10:48,040
constructor initializes usually

00:10:43,240 --> 00:10:50,560
initialize communication interface

00:10:48,040 --> 00:10:53,050
between other actors and actors this is

00:10:50,560 --> 00:10:55,930
the baldy function of the actor so by

00:10:53,050 --> 00:10:58,150
definition an actor can interact with

00:10:55,930 --> 00:11:00,499
other actors only by messages so

00:10:58,150 --> 00:11:03,019
actually what's going on we

00:11:00,499 --> 00:11:06,139
you receive or send message and we will

00:11:03,019 --> 00:11:08,299
act with this actor reacts if this actor

00:11:06,139 --> 00:11:13,339
receives a message Punk from another

00:11:08,299 --> 00:11:15,469
actor question number one how the actor

00:11:13,339 --> 00:11:19,219
can interact with each other and they

00:11:15,469 --> 00:11:21,469
use nodes it's obstruction which

00:11:19,219 --> 00:11:24,469
describes it's a fundamental obstruction

00:11:21,469 --> 00:11:26,419
for messaging for messaging so it's

00:11:24,469 --> 00:11:28,759
technically it's a part of memory and

00:11:26,419 --> 00:11:30,559
this part of memory can be trusted

00:11:28,759 --> 00:11:32,889
located inside a net wave or can be

00:11:30,559 --> 00:11:35,959
untrusted located outside and then cliff

00:11:32,889 --> 00:11:39,379
it consists of two components there is a

00:11:35,959 --> 00:11:44,269
header and there is a mode so it

00:11:39,379 --> 00:11:46,699
suggests there is payload as memory for

00:11:44,269 --> 00:11:48,769
data and with hid or header is used to

00:11:46,699 --> 00:11:52,219
include and to include multiple nodes

00:11:48,769 --> 00:11:55,609
into queues and all notes allocated at

00:11:52,219 --> 00:11:58,399
the start so part of the framework the

00:11:55,609 --> 00:12:02,269
framework provides API to deal with

00:11:58,399 --> 00:12:06,879
those queues of very obvious W at least

00:12:02,269 --> 00:12:10,639
with Lea four and five for interfaces

00:12:06,879 --> 00:12:12,999
synchronization of nodes are protected

00:12:10,639 --> 00:12:15,649
by the use of have very low collision

00:12:12,999 --> 00:12:17,659
it's a very very high performance

00:12:15,649 --> 00:12:20,689
synchronization mechanism without any

00:12:17,659 --> 00:12:25,479
side effects compared without any side

00:12:20,689 --> 00:12:28,699
effects and this primitive can be used

00:12:25,479 --> 00:12:31,069
by multi producers and multi consumers

00:12:28,699 --> 00:12:32,869
so you just have a queue you have set

00:12:31,069 --> 00:12:34,609
the factors that can write to this queue

00:12:32,869 --> 00:12:35,319
and set of factors that read from this

00:12:34,609 --> 00:12:37,699
queue

00:12:35,319 --> 00:12:39,259
let's consider an example we have two

00:12:37,699 --> 00:12:41,569
actors pig and pork and they're located

00:12:39,259 --> 00:12:43,509
inside different you click to send a

00:12:41,569 --> 00:12:47,509
message from and travel to the claves to

00:12:43,509 --> 00:12:49,909
the first actor should have access to

00:12:47,509 --> 00:12:53,929
pool of empty messages and to inbox

00:12:49,909 --> 00:12:58,249
obstruction so firstly pink needs to DQ

00:12:53,929 --> 00:13:01,639
an empty node from pool right and after

00:12:58,249 --> 00:13:03,619
that the first actor will get exclusive

00:13:01,639 --> 00:13:05,269
access to this node no one else can read

00:13:03,619 --> 00:13:08,599
and write it and even access to refer

00:13:05,269 --> 00:13:11,149
somehow then a cliff can that actor can

00:13:08,599 --> 00:13:12,190
write that inside decent life side is

00:13:11,149 --> 00:13:15,580
known then

00:13:12,190 --> 00:13:17,530
no it must be Hewitt internal inbox so

00:13:15,580 --> 00:13:21,250
Dayton and by the way can be encrypted

00:13:17,530 --> 00:13:23,620
and unencrypted should be including two

00:13:21,250 --> 00:13:26,380
end box at the same time the second

00:13:23,620 --> 00:13:29,670
actor tries to DQ messages from the same

00:13:26,380 --> 00:13:33,400
inbox and look succeed and will get

00:13:29,670 --> 00:13:37,300
success it will get exclusive access

00:13:33,400 --> 00:13:40,090
again safely read data inside it and

00:13:37,300 --> 00:13:41,950
clave decrypt it if it's necessary and

00:13:40,090 --> 00:13:46,540
then it needs to read it need it need

00:13:41,950 --> 00:13:50,410
return it needs to return use it note

00:13:46,540 --> 00:13:53,110
back to the pool so very simple and this

00:13:50,410 --> 00:13:55,210
obstruction can be as I said really can

00:13:53,110 --> 00:13:58,180
be used by multi producers and multi

00:13:55,210 --> 00:14:00,490
consumers but by default communication

00:13:58,180 --> 00:14:02,830
are not encrypted so you mean because

00:14:00,490 --> 00:14:05,340
because of multiple reasons and the

00:14:02,830 --> 00:14:08,170
flavor provides more complicated

00:14:05,340 --> 00:14:11,110
abstractions on top of this very simple

00:14:08,170 --> 00:14:14,100
interface those abstractions are called

00:14:11,110 --> 00:14:16,870
Carcosa connectors and they provide

00:14:14,100 --> 00:14:18,970
encrypted again can be encrypted and

00:14:16,870 --> 00:14:21,100
unencrypted with absolutely the same

00:14:18,970 --> 00:14:23,230
interface so for example today you have

00:14:21,100 --> 00:14:25,330
two actors you places those two actors

00:14:23,230 --> 00:14:27,630
inside and in clip and obviously you

00:14:25,330 --> 00:14:31,290
don't need to use encryption because

00:14:27,630 --> 00:14:34,570
because those actors are protected by

00:14:31,290 --> 00:14:36,910
geeks itself so therefore you don't need

00:14:34,570 --> 00:14:38,410
to spend time to encrypt it but tomorrow

00:14:36,910 --> 00:14:40,330
let's say you want to create two

00:14:38,410 --> 00:14:42,160
independent in clips put two different

00:14:40,330 --> 00:14:43,840
actor in two different in clips and

00:14:42,160 --> 00:14:47,410
obviously you need to have a mechanism

00:14:43,840 --> 00:14:49,690
for which you encrypt your messages and

00:14:47,410 --> 00:14:51,970
Cardosi connectors offer this

00:14:49,690 --> 00:14:54,520
abstraction so with the same source code

00:14:51,970 --> 00:14:57,670
just by switching one or two source line

00:14:54,520 --> 00:15:00,220
of code you can turn your non encrypted

00:14:57,670 --> 00:15:04,270
messages into encrypted messages however

00:15:00,220 --> 00:15:06,339
of course there are it's not for free so

00:15:04,270 --> 00:15:09,089
this interface can be used only by

00:15:06,339 --> 00:15:14,490
single producers single consumer

00:15:09,089 --> 00:15:17,110
peer-to-peer form but the framework for

00:15:14,490 --> 00:15:19,240
mechanisms for remote for local

00:15:17,110 --> 00:15:22,360
attestation using the key exchange

00:15:19,240 --> 00:15:24,730
procedure so if you have let's say five

00:15:22,360 --> 00:15:25,580
enclaves with five different actors and

00:15:24,730 --> 00:15:27,470
those actually

00:15:25,580 --> 00:15:30,440
have five in the for let's say

00:15:27,470 --> 00:15:33,790
independent communication channels the

00:15:30,440 --> 00:15:37,400
framework will generate necessary glue

00:15:33,790 --> 00:15:40,370
necessary check sounds which will help

00:15:37,400 --> 00:15:46,010
you to establish encrypted connections

00:15:40,370 --> 00:15:49,610
by the use of local attestation what

00:15:46,010 --> 00:15:53,140
what else the framework offers several

00:15:49,610 --> 00:15:57,650
system components because you cannot use

00:15:53,140 --> 00:16:00,110
well you shouldn't use equals inside and

00:15:57,650 --> 00:16:03,920
in clave and therefore you need to use

00:16:00,110 --> 00:16:05,510
messages to get access to system

00:16:03,920 --> 00:16:08,920
components that are unavailable inside

00:16:05,510 --> 00:16:12,200
and click for that the framework offers

00:16:08,920 --> 00:16:13,880
system actors and they are untrusted

00:16:12,200 --> 00:16:16,670
they are working outside enclaves and

00:16:13,880 --> 00:16:18,650
they interact with all other actors by

00:16:16,670 --> 00:16:22,280
the messages because it's an actor based

00:16:18,650 --> 00:16:24,530
framework so for example and those

00:16:22,280 --> 00:16:26,810
actors implement mechanism so that can

00:16:24,530 --> 00:16:29,600
be a system call for read for write for

00:16:26,810 --> 00:16:32,240
pipe for interaction this pipe read

00:16:29,600 --> 00:16:36,020
write to the file system if you want so

00:16:32,240 --> 00:16:38,060
it's just mechanism and then you for

00:16:36,020 --> 00:16:39,680
example if you want to open the file you

00:16:38,060 --> 00:16:42,770
need to send a message this actor will

00:16:39,680 --> 00:16:46,430
perform this mechanism of it will open

00:16:42,770 --> 00:16:48,530
the file and send back file descriptor

00:16:46,430 --> 00:16:51,770
so the same system actor can be

00:16:48,530 --> 00:16:54,800
simultaneously used by multiple other

00:16:51,770 --> 00:16:59,810
actors because because it doesn't store

00:16:54,800 --> 00:17:02,390
it doesn't have a state another thing so

00:16:59,810 --> 00:17:04,820
now we can have access to any hardware

00:17:02,390 --> 00:17:09,830
from our in case it is the same

00:17:04,820 --> 00:17:16,700
interface and but anyway sometimes you

00:17:09,830 --> 00:17:19,010
need to have a mechanism to to don't to

00:17:16,700 --> 00:17:21,260
store data inside and in cliff is out

00:17:19,010 --> 00:17:25,190
share the statements sound a bit strange

00:17:21,260 --> 00:17:27,920
I will explain so conceptual actors

00:17:25,190 --> 00:17:31,750
cannot have state and cannot have access

00:17:27,920 --> 00:17:34,100
to share it entity but at the same time

00:17:31,750 --> 00:17:35,390
instead of saying for example have one

00:17:34,100 --> 00:17:39,050
message and you need to send this

00:17:35,390 --> 00:17:41,470
message to let's say 5 or 10 actors and

00:17:39,050 --> 00:17:44,690
this message is absolutely the same

00:17:41,470 --> 00:17:49,280
sending five or ten sequential messages

00:17:44,690 --> 00:17:52,810
is inefficient so in in actual basic

00:17:49,280 --> 00:17:55,820
framework there is a conception of

00:17:52,810 --> 00:17:57,490
object store which is not a store as a

00:17:55,820 --> 00:18:01,370
share identity so you might consider

00:17:57,490 --> 00:18:03,740
object stall as a set of cues a set of

00:18:01,370 --> 00:18:07,070
persistent cues where you put data but

00:18:03,740 --> 00:18:09,830
into this queue but this data can be

00:18:07,070 --> 00:18:13,280
accessed by or ridden by multiple actors

00:18:09,830 --> 00:18:15,710
without without any problems so the

00:18:13,280 --> 00:18:18,230
framework offers the Oireachtas object

00:18:15,710 --> 00:18:22,250
store it's technically it's atomic key

00:18:18,230 --> 00:18:24,980
value store it can be private or can be

00:18:22,250 --> 00:18:32,450
public so it's not an active entity it's

00:18:24,980 --> 00:18:36,020
a set of api's so a set of api's that

00:18:32,450 --> 00:18:39,140
can be invoked by actors so any piece of

00:18:36,020 --> 00:18:44,090
memory if it has a necessary size can be

00:18:39,140 --> 00:18:46,820
turned into object store and actors who

00:18:44,090 --> 00:18:51,760
has access to it can read and write to

00:18:46,820 --> 00:18:56,890
this talk also this store can be

00:18:51,760 --> 00:19:00,800
persistent for example you can map a

00:18:56,890 --> 00:19:03,800
file into untrusted memory and turn this

00:19:00,800 --> 00:19:10,490
puppet memory into an object store so

00:19:03,800 --> 00:19:10,970
you'll have persistence on demand that's

00:19:10,490 --> 00:19:15,260
all

00:19:10,970 --> 00:19:18,200
regarding the design the question which

00:19:15,260 --> 00:19:21,080
i want to show you the answer later is

00:19:18,200 --> 00:19:23,960
to show you how to how fast is the

00:19:21,080 --> 00:19:27,050
communication primitives because the

00:19:23,960 --> 00:19:29,660
original motivation was we want to omit

00:19:27,050 --> 00:19:31,850
the use of equals and or cost and for

00:19:29,660 --> 00:19:36,350
that we use the synchronous messages are

00:19:31,850 --> 00:19:38,990
how how fast are they for that let's

00:19:36,350 --> 00:19:40,190
consider two and two actors located

00:19:38,990 --> 00:19:43,670
inside different enclave's

00:19:40,190 --> 00:19:45,230
and in this case they use equals to

00:19:43,670 --> 00:19:47,990
leave an end clave to send the message

00:19:45,230 --> 00:19:51,410
to another one and the messages use it

00:19:47,990 --> 00:19:53,450
by and unboxers users by two different

00:19:51,410 --> 00:19:56,950
written on top of different book so

00:19:53,450 --> 00:20:00,800
there is this very simple ping pong pong

00:19:56,950 --> 00:20:04,610
example with 1 million messages with

00:20:00,800 --> 00:20:07,340
those messages have different size

00:20:04,610 --> 00:20:10,430
starting from 16 bytes up to 1 megawatt

00:20:07,340 --> 00:20:12,290
half of a megabyte to thread so the

00:20:10,430 --> 00:20:16,250
straight one destroy everything is

00:20:12,290 --> 00:20:17,410
honest again different threads just the

00:20:16,250 --> 00:20:21,200
same actors just different

00:20:17,410 --> 00:20:25,340
synchronization mechanism this is the

00:20:21,200 --> 00:20:29,750
performance of of the SDK as you can see

00:20:25,340 --> 00:20:33,310
it is a pike which is near 32 K it's

00:20:29,750 --> 00:20:36,100
exactly size of the first line cache

00:20:33,310 --> 00:20:38,480
because when you transfer message from

00:20:36,100 --> 00:20:40,190
trusted area to trusted by the use of

00:20:38,480 --> 00:20:42,020
all calls there is a Marshall in

00:20:40,190 --> 00:20:44,600
mechanism which copies data from one

00:20:42,020 --> 00:20:47,780
memory to another and obviously if this

00:20:44,600 --> 00:20:50,450
memory fits into the l1 cache this works

00:20:47,780 --> 00:20:53,330
very very fast so this is the end of the

00:20:50,450 --> 00:20:57,290
cache and it has let's say steady aware

00:20:53,330 --> 00:21:04,190
after 128 K and this is the performance

00:20:57,290 --> 00:21:07,670
for you actor so much much faster very

00:21:04,190 --> 00:21:12,020
fast and because I was using in this

00:21:07,670 --> 00:21:14,570
example cargo so as I said you can very

00:21:12,020 --> 00:21:16,490
easily to switch from just switch a

00:21:14,570 --> 00:21:18,590
cargo from encrypted into non-encrypted

00:21:16,490 --> 00:21:21,010
former vice versa this is the

00:21:18,590 --> 00:21:24,010
performance for encrypted cards so

00:21:21,010 --> 00:21:27,050
encrypted even encrypted cargos

00:21:24,010 --> 00:21:29,900
approximately three times faster than

00:21:27,050 --> 00:21:33,880
non-encrypted non-encrypted a cold basic

00:21:29,900 --> 00:21:33,880
messages and the difference between

00:21:34,870 --> 00:21:41,060
non-encrypted cargoes and equals

00:21:37,280 --> 00:21:44,630
approximately 30 times so this interface

00:21:41,060 --> 00:21:46,820
is very fast and you can write very very

00:21:44,630 --> 00:21:51,590
high performance application on top of

00:21:46,820 --> 00:21:52,700
this framework sources are available you

00:21:51,590 --> 00:21:55,970
can check if you want

00:21:52,700 --> 00:21:58,580
there are several examples here with the

00:21:55,970 --> 00:22:01,820
template so which which shows an

00:21:58,580 --> 00:22:04,820
ordinary hello world application there

00:22:01,820 --> 00:22:07,450
are there is a set of virus pi

00:22:04,820 --> 00:22:09,590
songs that use encrypted non-encrypted

00:22:07,450 --> 00:22:12,289
carbon-based non-character basic

00:22:09,590 --> 00:22:15,350
messages also there is Network version

00:22:12,289 --> 00:22:17,929
of this fine funk application and there

00:22:15,350 --> 00:22:20,809
is a huge set of various forms of local

00:22:17,929 --> 00:22:24,679
attestation diffie-hellman and something

00:22:20,809 --> 00:22:28,159
else so at least three different pine

00:22:24,679 --> 00:22:32,120
points which use different mechanisms to

00:22:28,159 --> 00:22:33,559
establish an encrypted connection also

00:22:32,120 --> 00:22:35,419
there is an example for secure

00:22:33,559 --> 00:22:40,309
multi-party computation it's a secure

00:22:35,419 --> 00:22:43,840
assume some the Yocto subject store and

00:22:40,309 --> 00:22:56,570
there is an HTTP webserver which

00:22:43,840 --> 00:22:59,629
provides ssl connection yes this is

00:22:56,570 --> 00:23:02,419
wrong but there is a service prima dot i

00:22:59,629 --> 00:23:06,110
BR here should be pre mod it's the title

00:23:02,419 --> 00:23:10,460
it's a group site it's a site of our

00:23:06,110 --> 00:23:13,279
group and this site is hosted on top of

00:23:10,460 --> 00:23:15,590
the framework so it shows how how

00:23:13,279 --> 00:23:18,529
exactly you can terminate SSL inside and

00:23:15,590 --> 00:23:20,000
in clave and how you can write HTTP

00:23:18,529 --> 00:23:26,409
based application on top of this

00:23:20,000 --> 00:23:29,000
framework let's talk about future plans

00:23:26,409 --> 00:23:31,639
because this project was a kind of

00:23:29,000 --> 00:23:34,340
research project it's written in C very

00:23:31,639 --> 00:23:36,200
safe language obviously you may ask a

00:23:34,340 --> 00:23:38,539
lot of questions about the preak ability

00:23:36,200 --> 00:23:41,629
of this framework in general and one of

00:23:38,539 --> 00:23:43,519
the primary problem is how to make the

00:23:41,629 --> 00:23:49,299
programming language and environment

00:23:43,519 --> 00:23:53,899
more let's say more safe so currently

00:23:49,299 --> 00:23:55,570
I'm working on the hardening of of of

00:23:53,899 --> 00:23:59,450
the framework here will be

00:23:55,570 --> 00:24:04,340
instrumentation mechanism provided by

00:23:59,450 --> 00:24:06,350
LLVM which will limit a matter of memory

00:24:04,340 --> 00:24:09,980
acts that can be accessed by different

00:24:06,350 --> 00:24:15,130
actors so we exam this mechanism will

00:24:09,980 --> 00:24:17,900
help solve problems related to

00:24:15,130 --> 00:24:20,830
uncontrolled access to memory by the C

00:24:17,900 --> 00:24:24,320
language mechanisms for partitioning

00:24:20,830 --> 00:24:30,020
because the framework provides mechanism

00:24:24,320 --> 00:24:33,130
for easy deployment and obviously it

00:24:30,020 --> 00:24:36,370
will be nice to have a mechanism to self

00:24:33,130 --> 00:24:39,470
deployment or self partitioning of

00:24:36,370 --> 00:24:42,290
actors because actors are independent

00:24:39,470 --> 00:24:44,300
that they can be splitted without or

00:24:42,290 --> 00:24:46,400
partition it without any any

00:24:44,300 --> 00:24:48,920
dependencies and problems so this is the

00:24:46,400 --> 00:24:50,750
another direction of the work of course

00:24:48,920 --> 00:24:54,560
moulting cliff applications so though

00:24:50,750 --> 00:24:56,420
the framework was developed to to give a

00:24:54,560 --> 00:25:01,070
tool to build such multiwave

00:24:56,420 --> 00:25:03,530
applications the HTTP server will be

00:25:01,070 --> 00:25:08,570
improved will support multiple domains

00:25:03,530 --> 00:25:12,380
and the rest there is additional ideas

00:25:08,570 --> 00:25:15,380
related to IOT and currently the

00:25:12,380 --> 00:25:17,570
framework relies on the Intel SGX SDK

00:25:15,380 --> 00:25:20,000
which is not very good from performance

00:25:17,570 --> 00:25:24,190
from security point of view so probably

00:25:20,000 --> 00:25:43,330
we will try to remove remove this legacy

00:25:24,190 --> 00:25:46,270
so thank you very much questions yes I

00:25:43,330 --> 00:25:49,190
cannot give you numbers but conceptually

00:25:46,270 --> 00:25:52,610
all the synchronous queues a synchronous

00:25:49,190 --> 00:25:54,920
call by AGC SDK this interface they

00:25:52,610 --> 00:25:56,840
absolutely I mean conceptual is the same

00:25:54,920 --> 00:25:58,760
you have to thread one thread and side

00:25:56,840 --> 00:26:00,590
of the clave once a month ready now they

00:25:58,760 --> 00:26:02,960
are outside of the clave and there is

00:26:00,590 --> 00:26:06,170
Charlotte memory which is used to incur

00:26:02,960 --> 00:26:08,480
in DQ a data so it will be the primitive

00:26:06,170 --> 00:26:09,950
as a pretty primitive it's near the same

00:26:08,480 --> 00:26:13,850
as a permutation

00:26:09,950 --> 00:26:17,170
well I cannot compare me switch less

00:26:13,850 --> 00:26:17,170
call by calls but

00:26:17,930 --> 00:26:22,640
there is no many things that you can

00:26:20,750 --> 00:26:24,650
apply so you can use atomic instructions

00:26:22,640 --> 00:26:28,310
you can use heart very low collision and

00:26:24,650 --> 00:26:30,710
you can use nothing else so maybe two

00:26:28,310 --> 00:26:34,160
two approaches or and spin locks so

00:26:30,710 --> 00:26:37,130
three different approaches so they near

00:26:34,160 --> 00:26:39,170
the same performance actually these

00:26:37,130 --> 00:26:43,910
scales differently but conceptually are

00:26:39,170 --> 00:26:46,610
the same so you can assume that switch

00:26:43,910 --> 00:26:51,460
let's calls mean has near the same

00:26:46,610 --> 00:26:51,460
performance yes please

00:27:29,919 --> 00:27:37,749
so the question is how local attestation

00:27:35,169 --> 00:27:42,520
works I will paraphrase this if you

00:27:37,749 --> 00:27:44,729
don't mind so the framework provides

00:27:42,520 --> 00:27:49,989
[Music]

00:27:44,729 --> 00:27:52,919
primitives to create encrypted channels

00:27:49,989 --> 00:27:56,549
by the use of local attestation and

00:27:52,919 --> 00:27:59,799
during the compiling files the

00:27:56,549 --> 00:28:01,690
environment generates signatures so a

00:27:59,799 --> 00:28:05,559
Merlin clave if you know what is it

00:28:01,690 --> 00:28:07,299
signatures of each in clave and you need

00:28:05,559 --> 00:28:10,209
to have let's say the root of trust so

00:28:07,299 --> 00:28:13,869
some one in 12 that includes all marine

00:28:10,209 --> 00:28:15,489
claves scientists inside so it's a

00:28:13,869 --> 00:28:17,409
sequential process there is a root of

00:28:15,489 --> 00:28:20,109
trust with the first and clave dissing

00:28:17,409 --> 00:28:21,009
clave has a set of all or maybe subset

00:28:20,109 --> 00:28:23,679
of enclave's

00:28:21,009 --> 00:28:25,869
or communication channels and then you

00:28:23,679 --> 00:28:29,289
establish one two three four five let's

00:28:25,869 --> 00:28:32,409
say and sequentially they perform local

00:28:29,289 --> 00:28:35,529
attestation so of course it cannot be

00:28:32,409 --> 00:28:38,079
very general approach so currently it's

00:28:35,529 --> 00:28:41,619
tailored for sequential initialization

00:28:38,079 --> 00:28:46,449
of in place and sequential generation of

00:28:41,619 --> 00:28:48,459
encrypted channels but this job

00:28:46,449 --> 00:28:50,859
significant this environment

00:28:48,459 --> 00:28:53,909
significantly reduces the complexity of

00:28:50,859 --> 00:28:57,249
this procedure so if you can map your

00:28:53,909 --> 00:28:59,649
application to this design so like you

00:28:57,249 --> 00:29:02,019
can sequentially establish connections

00:28:59,649 --> 00:29:04,329
between several in place yes you can

00:29:02,019 --> 00:29:06,249
apply in this framework immediately and

00:29:04,329 --> 00:29:08,440
the framework will generate necessary

00:29:06,249 --> 00:29:10,540
parts otherwise well bother wise you

00:29:08,440 --> 00:29:13,420
will need to

00:29:10,540 --> 00:29:15,670
great let's say ye God or something very

00:29:13,420 --> 00:29:17,590
initial very very read of root of trust

00:29:15,670 --> 00:29:20,080
and this root of trust will establish

00:29:17,590 --> 00:29:22,180
connections between different and clave

00:29:20,080 --> 00:30:02,020
so this will require you to modify the

00:29:22,180 --> 00:30:05,470
framework very very good question the

00:30:02,020 --> 00:30:08,200
question is what about namespace inside

00:30:05,470 --> 00:30:10,830
it inside the network inside the

00:30:08,200 --> 00:30:14,050
framework to distinguish different

00:30:10,830 --> 00:30:15,970
actors and I would say no the reason

00:30:14,050 --> 00:30:19,360
mechanism there is no mechanism for that

00:30:15,970 --> 00:30:22,630
because you are absolutely right so name

00:30:19,360 --> 00:30:27,300
discovery so this car or mechanism which

00:30:22,630 --> 00:30:30,550
maps that Maps actors to unique names

00:30:27,300 --> 00:30:34,060
well would be it's very complicated in

00:30:30,550 --> 00:30:37,200
general in distributed systems so in the

00:30:34,060 --> 00:30:41,170
framework the reason mechanism for

00:30:37,200 --> 00:30:45,280
naming and identification of actors at

00:30:41,170 --> 00:30:48,340
the source code level so a tool which a

00:30:45,280 --> 00:30:50,230
tool that generates binaries know

00:30:48,340 --> 00:30:53,470
something about source code of actors

00:30:50,230 --> 00:30:55,090
and their names but there is no

00:30:53,470 --> 00:31:01,080
independent mechanism for name

00:30:55,090 --> 00:31:01,080
discovering yo your question

00:31:14,290 --> 00:31:33,660
I will say that it's a very recent so

00:31:16,600 --> 00:31:40,120
this diagram let's say two years old I

00:31:33,660 --> 00:31:45,730
would say that each each micro code

00:31:40,120 --> 00:31:51,070
update cuts performance they're very

00:31:45,730 --> 00:32:30,730
very significant I would say so this is

00:31:51,070 --> 00:32:32,710
the problem the question is do it is

00:32:30,730 --> 00:32:38,320
this a right way to use messages instead

00:32:32,710 --> 00:32:41,290
of equals at the beginning I did not

00:32:38,320 --> 00:32:44,140
consider so at some moment for some

00:32:41,290 --> 00:32:48,670
applications I thought that the use of

00:32:44,140 --> 00:32:51,220
equals is okay but now I don't think so

00:32:48,670 --> 00:32:53,590
I still believe that and I see these

00:32:51,220 --> 00:32:54,400
numbers that a synchronous interface is

00:32:53,590 --> 00:32:56,940
much better

00:32:54,400 --> 00:33:00,100
however it has significant drawback

00:32:56,940 --> 00:33:02,800
because you cannot stop thread inside

00:33:00,100 --> 00:33:04,600
the Dan clave and this trade anyway will

00:33:02,800 --> 00:33:09,340
need to leave the enclaves at some

00:33:04,600 --> 00:33:12,580
moment so and which means that anyway at

00:33:09,340 --> 00:33:15,700
some moment for some reason or due to

00:33:12,580 --> 00:33:17,680
the reasons of scalability on any of my

00:33:15,700 --> 00:33:20,770
thread will leave them in class or

00:33:17,680 --> 00:33:22,840
in some form or call still exist but the

00:33:20,770 --> 00:33:25,990
programming model doesn't rely on this

00:33:22,840 --> 00:33:30,059
that lets the pot this is important yes

00:33:25,990 --> 00:33:30,059
please please

00:34:42,240 --> 00:34:50,139
first of all yes distributed problems of

00:34:47,590 --> 00:34:53,139
distributed computing applied for this

00:34:50,139 --> 00:34:56,350
design absolutely without any except

00:34:53,139 --> 00:34:58,500
let's say I also consider this form of

00:34:56,350 --> 00:35:01,360
secure multi-party computation is a

00:34:58,500 --> 00:35:05,520
mechanism to improve performance exactly

00:35:01,360 --> 00:35:08,290
so instead of let's say five different

00:35:05,520 --> 00:35:10,330
separate machines like servers located

00:35:08,290 --> 00:35:12,730
in different countries which say you

00:35:10,330 --> 00:35:15,160
have a platform where you upload your

00:35:12,730 --> 00:35:17,950
binary see you there they represent your

00:35:15,160 --> 00:35:19,990
original server and in this local in

00:35:17,950 --> 00:35:21,820
this local place they can compute much

00:35:19,990 --> 00:35:24,930
faster and then go back let's say that

00:35:21,820 --> 00:35:27,580
so that's the design in the background

00:35:24,930 --> 00:35:31,720
but but of course the problems related

00:35:27,580 --> 00:35:34,330
to try I mean the consensus very funny

00:35:31,720 --> 00:35:36,550
BFG our raft and other stuff can be

00:35:34,330 --> 00:35:37,900
applied and should be of course we don't

00:35:36,550 --> 00:35:40,230
solve this and we cannot solve the

00:35:37,900 --> 00:35:40,230
setting

00:36:29,890 --> 00:36:36,520
firstly you can provide some mechanisms

00:36:34,160 --> 00:36:39,890
for some of the mechanism for setting

00:36:36,520 --> 00:36:43,039
affinity was exactly for this so when

00:36:39,890 --> 00:36:45,079
you want to co-locate your code and data

00:36:43,039 --> 00:36:47,480
within the same cone with the same call

00:36:45,079 --> 00:36:49,640
and if you want to and if you need a

00:36:47,480 --> 00:36:52,690
mechanism for scheduling that this

00:36:49,640 --> 00:36:55,010
mechanism also can be implemented at the

00:36:52,690 --> 00:36:55,670
assignment level not inside in the

00:36:55,010 --> 00:37:00,589
source code

00:36:55,670 --> 00:37:02,539
however this not it's not the primary

00:37:00,589 --> 00:37:04,130
approach to solve this problem I mean

00:37:02,539 --> 00:37:06,799
the problem when you need to leave an in

00:37:04,130 --> 00:37:09,619
clave and the best way I found it's not

00:37:06,799 --> 00:37:12,410
a part of the framework but you need to

00:37:09,619 --> 00:37:14,839
have them let's say at some moment when

00:37:12,410 --> 00:37:17,569
you cannot get a message you need to

00:37:14,839 --> 00:37:22,250
leave an end clave manually but you do

00:37:17,569 --> 00:37:24,859
this for not random but let's say

00:37:22,250 --> 00:37:27,619
statically identify a statistically

00:37:24,859 --> 00:37:32,440
identified impure interval of time there

00:37:27,619 --> 00:37:32,440
is nothing better oh I don't know thank

00:37:32,600 --> 00:37:39,229
you

00:37:33,330 --> 00:37:39,229

YouTube URL: https://www.youtube.com/watch?v=eigtc7oCxWk


