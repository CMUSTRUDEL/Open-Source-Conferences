Title: Replacing iptables with eBPF in Kubernetes with Cilium
Publication date: 2020-07-12
Playlist: FOSDEM 2020
Description: 
	by Michal Rostecki and Swami Vasudevan

At: FOSDEM 2020
https://video.fosdem.org/2020/H.1308/replacing_iptables_with_ebpf.webm

Michal Rostecki is a Software Engineer working at SUSE. He's working on Cilium, both upstream and on integrating it with openSUSE Kubic Project and SUSE CaaS Platform.


Swaminathan Vasudevan is a Software Engineer working at SUSE. Worked on Neutron Networking Upstream and currently migrating to Cilium and openSUSE Kubic Project and SUSE CaaS Platform.
Cilium is an open source project which provides networking, security and load balancing for application services that are deployed using Linux container technologies by using the native eBPF technology in the Linux kernel.
In this presentation we would talk about:
- The evolution of the BPF filters and will explain the advantages of eBPF Filters and its use cases today in Linux especially on how Cilium networking utilizes the eBPF Filters to secure the Kubernetes workload with increased performance when compared to legacy iptables.
- How Cilium uses SOCKMAP for layer 7 policy enforcement
- How Cilium integrates with Istio and handles L7 Network Policies with Envoy Proxies.
- The new features since the last release such as running Kubernetes cluster without kube-proxy, providing clusterwide NetworkPolicies, providing fully distributed networking and security observability platform for cloud native workloads etc.

Room: H.1308 (Rolin)
Scheduled start: 2020-02-01 11:30:00
Captions: 
	00:00:08,000 --> 00:00:12,320
okay

00:00:08,800 --> 00:00:15,599
so let's start hello everyone

00:00:12,320 --> 00:00:19,359
we will talk today about replacing

00:00:15,599 --> 00:00:22,000
traditional legacy ip tables with ebpf

00:00:19,359 --> 00:00:23,519
and kubernetes clusters with serious we

00:00:22,000 --> 00:00:26,960
are from souza

00:00:23,519 --> 00:00:30,080
i'm mikhail this is swami

00:00:26,960 --> 00:00:30,560
and yeah let's start from the question

00:00:30,080 --> 00:00:34,079
what's

00:00:30,560 --> 00:00:37,120
wrong with traditional iptables

00:00:34,079 --> 00:00:38,800
so there are several things wrong

00:00:37,120 --> 00:00:40,399
from the point of view of kubernetes

00:00:38,800 --> 00:00:42,879
clusters first of all

00:00:40,399 --> 00:00:44,399
iptables is a technology which has 20

00:00:42,879 --> 00:00:47,039
years and

00:00:44,399 --> 00:00:48,879
it was designed mostly for simple ip

00:00:47,039 --> 00:00:50,960
address and port matching

00:00:48,879 --> 00:00:53,199
which is a good approach for like

00:00:50,960 --> 00:00:55,760
traditional server applications

00:00:53,199 --> 00:00:57,199
uh for the time where we don't have like

00:00:55,760 --> 00:01:00,320
huge clusters and

00:00:57,199 --> 00:01:03,359
huge high availability

00:01:00,320 --> 00:01:07,360
but in the era of kubernetes clusters

00:01:03,359 --> 00:01:11,119
is not enough in european

00:01:07,360 --> 00:01:12,000
the other issue is that iptables is not

00:01:11,119 --> 00:01:15,119
really aware

00:01:12,000 --> 00:01:17,439
of the l7 protocols so you don't you

00:01:15,119 --> 00:01:20,400
can't filter

00:01:17,439 --> 00:01:22,240
the http codes for example you can

00:01:20,400 --> 00:01:24,799
filter

00:01:22,240 --> 00:01:27,439
particular database database queries

00:01:24,799 --> 00:01:28,320
it's all based on ip addresses and ports

00:01:27,439 --> 00:01:32,320
so layer 3

00:01:28,320 --> 00:01:34,560
layer 4. and the other thing is that

00:01:32,320 --> 00:01:36,159
iptables operates on the concept of

00:01:34,560 --> 00:01:39,119
chains and rules and

00:01:36,159 --> 00:01:41,360
to add a route to the chain you

00:01:39,119 --> 00:01:44,560
basically operate on the

00:01:41,360 --> 00:01:47,360
linked list so every operation

00:01:44,560 --> 00:01:48,159
except of insert is o n so like

00:01:47,360 --> 00:01:51,280
searching

00:01:48,159 --> 00:01:54,479
over the chain of rules or

00:01:51,280 --> 00:01:58,479
modifying the particular rule is always

00:01:54,479 --> 00:02:04,159
the like average or an operation

00:01:58,479 --> 00:02:06,399
and that's why kubernetes currently

00:02:04,159 --> 00:02:07,280
uses ip tables extensively so the

00:02:06,399 --> 00:02:09,840
tradition

00:02:07,280 --> 00:02:11,440
so when you use kubernetes with the most

00:02:09,840 --> 00:02:14,000
of cni plugins

00:02:11,440 --> 00:02:14,959
uh you use ip tables for mainly two

00:02:14,000 --> 00:02:16,959
things

00:02:14,959 --> 00:02:18,879
first thing is implementing surfaces

00:02:16,959 --> 00:02:20,959
with keep proxy

00:02:18,879 --> 00:02:22,480
and the second thing are network

00:02:20,959 --> 00:02:25,520
policies for

00:02:22,480 --> 00:02:29,120
filtering the traffic but the

00:02:25,520 --> 00:02:32,319
and uh it sometimes ends up with so much

00:02:29,120 --> 00:02:34,959
ip tables and so much sadness

00:02:32,319 --> 00:02:37,120
uh but there is one technology which

00:02:34,959 --> 00:02:40,000
tries to address that

00:02:37,120 --> 00:02:42,480
it's bpf which was already mentioned in

00:02:40,000 --> 00:02:45,599
previous presentations

00:02:42,480 --> 00:02:45,840
in the dev room but to briefly introduce

00:02:45,599 --> 00:02:48,080
it

00:02:45,840 --> 00:02:49,440
it's a virtual machine the kernel which

00:02:48,080 --> 00:02:52,720
allows you to write

00:02:49,440 --> 00:02:57,120
programs in the subset of c language

00:02:52,720 --> 00:03:00,480
which filters and traces the packets

00:02:57,120 --> 00:03:01,680
in the kernel or it can also be used to

00:03:00,480 --> 00:03:04,560
trace the

00:03:01,680 --> 00:03:06,560
kernel function calls but in case of

00:03:04,560 --> 00:03:08,560
psyllium and in case of our talk we

00:03:06,560 --> 00:03:12,480
focus more to uh on the

00:03:08,560 --> 00:03:13,760
networking side of bpf and swami will

00:03:12,480 --> 00:03:17,200
talk

00:03:13,760 --> 00:03:19,120
about details so network stack so thanks

00:03:17,200 --> 00:03:20,400
uh michael so mikhail actually explained

00:03:19,120 --> 00:03:21,760
about what are the issues that we are

00:03:20,400 --> 00:03:24,159
having with iptables

00:03:21,760 --> 00:03:26,239
so everyone here would be aware about

00:03:24,159 --> 00:03:27,519
the linux network stack and how complex

00:03:26,239 --> 00:03:29,519
it has been um

00:03:27,519 --> 00:03:32,159
so the design process of the linux has

00:03:29,519 --> 00:03:34,640
been for years and

00:03:32,159 --> 00:03:35,920
the layers are pretty compact and each

00:03:34,640 --> 00:03:39,200
layers uh

00:03:35,920 --> 00:03:40,720
talk to each other layers and uh if any

00:03:39,200 --> 00:03:42,480
packet has to process they have to

00:03:40,720 --> 00:03:43,920
process through all these packets all

00:03:42,480 --> 00:03:45,440
these layers and

00:03:43,920 --> 00:03:47,920
we do have the net filter layer in

00:03:45,440 --> 00:03:50,400
between uh so in order to get rid of the

00:03:47,920 --> 00:03:51,120
net filter uh layer we need to come up

00:03:50,400 --> 00:03:52,959
with

00:03:51,120 --> 00:03:54,159
a similar filtering capability with the

00:03:52,959 --> 00:03:57,760
bpf

00:03:54,159 --> 00:03:59,280
so what we are doing is as

00:03:57,760 --> 00:04:01,599
the previous sessions also discussed

00:03:59,280 --> 00:04:03,200
about the hook points so the bpf has

00:04:01,599 --> 00:04:03,840
different hook points in the networking

00:04:03,200 --> 00:04:05,280
stack

00:04:03,840 --> 00:04:07,760
so you can see the different hook points

00:04:05,280 --> 00:04:08,400
for the bpf has and using these hook

00:04:07,760 --> 00:04:10,319
points

00:04:08,400 --> 00:04:12,239
we can actually achieve the similar

00:04:10,319 --> 00:04:14,879
functionality that ipfilter

00:04:12,239 --> 00:04:18,000
has and has been providing for the

00:04:14,879 --> 00:04:20,799
customers for years

00:04:18,000 --> 00:04:22,400
so um so this is just a comparison about

00:04:20,799 --> 00:04:24,400
the legacy ip tables

00:04:22,400 --> 00:04:25,919
and the enhanced version of the ip

00:04:24,400 --> 00:04:28,639
tables with the nf tables

00:04:25,919 --> 00:04:30,880
um that have been used and then the bpf

00:04:28,639 --> 00:04:32,000
filters with the host driver and the bp

00:04:30,880 --> 00:04:34,000
filter with the

00:04:32,000 --> 00:04:35,680
hardware offload so you can see uh

00:04:34,000 --> 00:04:37,759
there's a substantial

00:04:35,680 --> 00:04:42,080
increase in performance by using the bpf

00:04:37,759 --> 00:04:44,639
filters against ib tables

00:04:42,080 --> 00:04:45,919
so this picture uh gives you an overview

00:04:44,639 --> 00:04:48,960
of uh how

00:04:45,919 --> 00:04:50,560
the bpf utilizes the filtering

00:04:48,960 --> 00:04:53,520
capabilities that ip

00:04:50,560 --> 00:04:54,560
filter used to do for the networking so

00:04:53,520 --> 00:04:57,280
uh in this picture

00:04:54,560 --> 00:04:58,960
we are seeing the five different chains

00:04:57,280 --> 00:05:01,039
that are currently available for any

00:04:58,960 --> 00:05:02,880
packet to traverse these chains

00:05:01,039 --> 00:05:04,400
so the decisions are made based upon

00:05:02,880 --> 00:05:06,080
where the packet needs to reach

00:05:04,400 --> 00:05:07,680
whether it's going to be inbound whether

00:05:06,080 --> 00:05:09,039
it's going to be outbound whether it's

00:05:07,680 --> 00:05:11,280
going to be

00:05:09,039 --> 00:05:12,400
egressed or interest so based on that

00:05:11,280 --> 00:05:14,800
you can see

00:05:12,400 --> 00:05:15,919
the yellow loops in here those are the

00:05:14,800 --> 00:05:17,759
net filter

00:05:15,919 --> 00:05:19,199
capabilities positions that we are

00:05:17,759 --> 00:05:20,880
having and then

00:05:19,199 --> 00:05:23,440
the routing decisions are happening in

00:05:20,880 --> 00:05:24,880
the input and forwarding and output

00:05:23,440 --> 00:05:26,639
as well as the netting is happening

00:05:24,880 --> 00:05:27,280
either in the pre-routing or in the post

00:05:26,639 --> 00:05:29,840
routing

00:05:27,280 --> 00:05:32,800
so in in case we wanted to achieve the

00:05:29,840 --> 00:05:34,880
same functionality with bpf filters

00:05:32,800 --> 00:05:36,080
we are planning to have the ppf code

00:05:34,880 --> 00:05:37,919
running

00:05:36,080 --> 00:05:39,919
in any one of the hook points that we

00:05:37,919 --> 00:05:41,919
already mentioned but in for the example

00:05:39,919 --> 00:05:46,160
case we are taking that we are actually

00:05:41,919 --> 00:05:49,919
uh applying the bpf code in the tc

00:05:46,160 --> 00:05:51,360
hook point so by applying this we are

00:05:49,919 --> 00:05:52,880
going to achieve similar

00:05:51,360 --> 00:05:54,720
functionality i'm going to show you the

00:05:52,880 --> 00:05:55,759
picture here so the pink region that

00:05:54,720 --> 00:05:57,840
you're seeing here

00:05:55,759 --> 00:05:59,199
the both the pink boxes are the bpf

00:05:57,840 --> 00:06:00,639
programs that are running on the hook

00:05:59,199 --> 00:06:03,440
points for the tc

00:06:00,639 --> 00:06:04,319
and those chains that are shown here are

00:06:03,440 --> 00:06:05,919
the

00:06:04,319 --> 00:06:07,600
english chain forwarding chain and

00:06:05,919 --> 00:06:09,360
output chain and we also have

00:06:07,600 --> 00:06:11,039
the netting capabilities as well for the

00:06:09,360 --> 00:06:13,520
pre-routing and post routing

00:06:11,039 --> 00:06:15,600
but for simplicity purposes i have taken

00:06:13,520 --> 00:06:18,319
these three chains in order to explain

00:06:15,600 --> 00:06:20,639
uh how we are achieving it through bpf

00:06:18,319 --> 00:06:23,520
and also connection tracking is involved

00:06:20,639 --> 00:06:25,280
so in all these cases uh we do have a

00:06:23,520 --> 00:06:27,520
hook point on the tc when the packet

00:06:25,280 --> 00:06:29,600
enters uh the hook point actually

00:06:27,520 --> 00:06:31,280
uh takes into consideration that there

00:06:29,600 --> 00:06:32,720
is a packet arriving and there if there

00:06:31,280 --> 00:06:34,240
is a vpf program that has been

00:06:32,720 --> 00:06:36,639
programmed to

00:06:34,240 --> 00:06:38,000
take care of it so it takes care either

00:06:36,639 --> 00:06:40,400
in the english chain or out

00:06:38,000 --> 00:06:41,680
of the interest chain and then it

00:06:40,400 --> 00:06:43,440
applies the

00:06:41,680 --> 00:06:45,840
filtering rules based upon what we have

00:06:43,440 --> 00:06:47,919
configured

00:06:45,840 --> 00:06:49,199
so the i think in the previous session

00:06:47,919 --> 00:06:51,360
also we saw that

00:06:49,199 --> 00:06:53,440
bpf filters has a capability that you

00:06:51,360 --> 00:06:54,960
can actually point one bpf filter to

00:06:53,440 --> 00:06:55,840
another vpn filter which is called as

00:06:54,960 --> 00:06:58,479
bpf

00:06:55,840 --> 00:07:00,000
uh tail calls uh so we can achieve a

00:06:58,479 --> 00:07:00,720
similar filtering capabilities with

00:07:00,000 --> 00:07:04,400
respect to

00:07:00,720 --> 00:07:07,360
bpf tail calls where each of the ebpf

00:07:04,400 --> 00:07:08,880
program can actually do a partial

00:07:07,360 --> 00:07:11,520
filtering on based on

00:07:08,880 --> 00:07:12,319
what the content has been uh derived for

00:07:11,520 --> 00:07:14,240
so basically

00:07:12,319 --> 00:07:16,240
one can do a header parsing the other

00:07:14,240 --> 00:07:18,479
can do an ip look up

00:07:16,240 --> 00:07:19,840
so all these things change together can

00:07:18,479 --> 00:07:21,919
actually provide a

00:07:19,840 --> 00:07:23,599
filtering capability that ip cables can

00:07:21,919 --> 00:07:24,240
provide and all these things are

00:07:23,599 --> 00:07:26,639
happening

00:07:24,240 --> 00:07:27,680
dynamically without any intrusion or

00:07:26,639 --> 00:07:29,520
without any kernel

00:07:27,680 --> 00:07:31,199
reprogramming so that's the advantage of

00:07:29,520 --> 00:07:34,000
ppf program

00:07:31,199 --> 00:07:34,800
i'll give back to michal to take it over

00:07:34,000 --> 00:07:37,759
from here

00:07:34,800 --> 00:07:38,880
yes so here there are examples of the

00:07:37,759 --> 00:07:41,360
other project

00:07:38,880 --> 00:07:42,720
psilium that are using bpf there is a

00:07:41,360 --> 00:07:45,759
load balancer written

00:07:42,720 --> 00:07:47,120
by facebook which is open songs which is

00:07:45,759 --> 00:07:49,840
called katran

00:07:47,120 --> 00:07:51,680
perth the utility linux utility is using

00:07:49,840 --> 00:07:54,080
bpf already for

00:07:51,680 --> 00:07:54,879
tracing the current function calls

00:07:54,080 --> 00:07:58,000
systemd

00:07:54,879 --> 00:08:02,080
has a basic firewall based

00:07:58,000 --> 00:08:04,960
on bpf so you can define basic roofs for

00:08:02,080 --> 00:08:06,720
services suricata is using bpf

00:08:04,960 --> 00:08:10,720
extensively

00:08:06,720 --> 00:08:13,840
openv switch has the af xdp driver

00:08:10,720 --> 00:08:16,240
fxdp is the

00:08:13,840 --> 00:08:18,960
let's say alternative to the pkk or the

00:08:16,240 --> 00:08:22,720
dpdk itself is also supporting it

00:08:18,960 --> 00:08:25,840
so dpdk in dpdk normally

00:08:22,720 --> 00:08:27,440
uh you expose the network device

00:08:25,840 --> 00:08:32,479
directly to the user space

00:08:27,440 --> 00:08:32,479
and the ptk has a network driver to

00:08:33,039 --> 00:08:38,000
to use that network card but in case of

00:08:35,839 --> 00:08:40,399
af xdp

00:08:38,000 --> 00:08:41,680
you use the network drivers in the

00:08:40,399 --> 00:08:45,360
kernel

00:08:41,680 --> 00:08:46,000
but you have the direct memory access to

00:08:45,360 --> 00:08:50,560
the network

00:08:46,000 --> 00:08:52,640
card and you can bypass the rest of

00:08:50,560 --> 00:08:54,640
linux kernel network abstraction you've

00:08:52,640 --> 00:08:56,800
seen in the previous slides and

00:08:54,640 --> 00:08:59,600
redirect the packet directly to the user

00:08:56,800 --> 00:09:00,000
space so it's like similar to dpdk in

00:08:59,600 --> 00:09:03,200
terms

00:09:00,000 --> 00:09:05,519
that's uh it's a

00:09:03,200 --> 00:09:06,320
datapath acceleration technology there

00:09:05,519 --> 00:09:09,279
is also

00:09:06,320 --> 00:09:10,880
you can use af xdp as a pm the driver in

00:09:09,279 --> 00:09:14,160
dpdk actually

00:09:10,880 --> 00:09:17,120
but yeah you are still using the

00:09:14,160 --> 00:09:17,680
network device drivers in kernel and

00:09:17,120 --> 00:09:22,080
yeah

00:09:17,680 --> 00:09:25,040
the list of projects using bpf will grow

00:09:22,080 --> 00:09:28,480
and grow in the time and these are

00:09:25,040 --> 00:09:31,519
companies which are using bpf

00:09:28,480 --> 00:09:34,800
so google red hat netflix souza

00:09:31,519 --> 00:09:38,000
we are using it because

00:09:34,800 --> 00:09:41,360
we are in our distribution of kubernetes

00:09:38,000 --> 00:09:46,080
suse container as a service platform

00:09:41,360 --> 00:09:49,120
we are using celium as the cni driver

00:09:46,080 --> 00:09:52,560
so we explained what bpf is

00:09:49,120 --> 00:09:54,399
briefly and now we will talk more about

00:09:52,560 --> 00:09:56,399
psyllium itself and what kind of

00:09:54,399 --> 00:09:59,920
features it has

00:09:56,399 --> 00:10:00,640
so psyllium uh consists of several

00:09:59,920 --> 00:10:03,120
components

00:10:00,640 --> 00:10:04,320
the main of it is the agent which runs

00:10:03,120 --> 00:10:06,399
on every note

00:10:04,320 --> 00:10:08,160
in the kubernetes cluster and it

00:10:06,399 --> 00:10:11,680
actually takes care of

00:10:08,160 --> 00:10:14,560
uh generating the ppf programs and

00:10:11,680 --> 00:10:16,720
loading them into into the kernel and

00:10:14,560 --> 00:10:20,079
you have several other components

00:10:16,720 --> 00:10:23,040
to interact with celium like the cli

00:10:20,079 --> 00:10:24,959
like plugins to different container

00:10:23,040 --> 00:10:28,800
runtimes

00:10:24,959 --> 00:10:28,800
or the policy repository

00:10:29,120 --> 00:10:36,560
and speaking about cni itself

00:10:33,279 --> 00:10:38,399
yeah maybe it's too much to

00:10:36,560 --> 00:10:41,519
to talk because we have five minutes

00:10:38,399 --> 00:10:44,399
left but yeah cnn is the specification

00:10:41,519 --> 00:10:46,079
used by kubernetes for creating or

00:10:44,399 --> 00:10:49,279
deleting the network

00:10:46,079 --> 00:10:52,800
interfaces uh and cni

00:10:49,279 --> 00:10:55,600
plugins are responsible for uh create

00:10:52,800 --> 00:10:58,000
for creating the network interface

00:10:55,600 --> 00:11:00,880
getting the ip address and s

00:10:58,000 --> 00:11:03,040
implementing of that so basically when

00:11:00,880 --> 00:11:05,360
you create the pot with kubectl

00:11:03,040 --> 00:11:07,440
you of course call firstly the

00:11:05,360 --> 00:11:11,600
kubernetes api server

00:11:07,440 --> 00:11:15,839
the cubelet takes that request and

00:11:11,600 --> 00:11:17,200
cubelets calls the cri and the cri can

00:11:15,839 --> 00:11:20,480
be

00:11:17,200 --> 00:11:24,240
docker shim container d or cryo

00:11:20,480 --> 00:11:26,399
and then usually the cri implementation

00:11:24,240 --> 00:11:28,959
caused the cni plugin

00:11:26,399 --> 00:11:30,800
to create the uh to create the network

00:11:28,959 --> 00:11:32,079
interface and provision the networking

00:11:30,800 --> 00:11:35,440
for the pod

00:11:32,079 --> 00:11:38,720
and in case of psyllium ethereum has its

00:11:35,440 --> 00:11:41,120
cni plug-in which uh caused the serium

00:11:38,720 --> 00:11:44,640
agent to request the ip address

00:11:41,120 --> 00:11:45,760
and then to it cause serium agents to

00:11:44,640 --> 00:11:48,720
actually create

00:11:45,760 --> 00:11:49,440
bpf programs which will handle the

00:11:48,720 --> 00:11:52,959
filtering

00:11:49,440 --> 00:11:55,600
and in case you are using serium for

00:11:52,959 --> 00:11:58,000
handling the packet encapsulation to the

00:11:55,600 --> 00:11:58,959
nodes it's also handled by bpf programs

00:11:58,000 --> 00:12:01,920
which

00:11:58,959 --> 00:12:04,639
serium agent creates and then the

00:12:01,920 --> 00:12:05,040
communication between those bpf programs

00:12:04,639 --> 00:12:07,920
which

00:12:05,040 --> 00:12:10,639
are loaded into the kernel goes through

00:12:07,920 --> 00:12:13,680
bpf maps which are exposed to

00:12:10,639 --> 00:12:16,480
the user space so serium agent after

00:12:13,680 --> 00:12:18,240
generating the pppf program compiling it

00:12:16,480 --> 00:12:21,200
loading into the kernel

00:12:18,240 --> 00:12:22,839
it keeps in contact with the ppf program

00:12:21,200 --> 00:12:26,160
by using

00:12:22,839 --> 00:12:29,360
maps and this is like the

00:12:26,160 --> 00:12:32,800
more general uh overview of

00:12:29,360 --> 00:12:34,880
how bpf looks like and how it works

00:12:32,800 --> 00:12:37,200
when we use it together with celium but

00:12:34,880 --> 00:12:40,399
also for example if you use

00:12:37,200 --> 00:12:44,639
a xdp which i mentioned to

00:12:40,399 --> 00:12:47,360
do a data plane acceleration to vms and

00:12:44,639 --> 00:12:47,360
containers

00:12:48,079 --> 00:12:54,160
and swarming it's your turn so

00:12:52,000 --> 00:12:55,760
so here's the details about the cni

00:12:54,160 --> 00:12:58,079
plug-in as um as he mentioned

00:12:55,760 --> 00:12:59,360
about uh how the cni plug-in gets

00:12:58,079 --> 00:13:02,320
involved in

00:12:59,360 --> 00:13:04,079
providing a networking access and

00:13:02,320 --> 00:13:05,519
providing ip address management and all

00:13:04,079 --> 00:13:07,519
those things so these are the internals

00:13:05,519 --> 00:13:09,600
that you can see when cni

00:13:07,519 --> 00:13:11,519
is configured where you have each of the

00:13:09,600 --> 00:13:14,639
containers has an internal

00:13:11,519 --> 00:13:15,279
interface and it has an um an lxc

00:13:14,639 --> 00:13:17,519
interface

00:13:15,279 --> 00:13:19,279
within the cni and also a physical

00:13:17,519 --> 00:13:20,000
interface to a node and and the nodes

00:13:19,279 --> 00:13:24,320
are interconnected

00:13:20,000 --> 00:13:26,480
in a cluster so the networking modes and

00:13:24,320 --> 00:13:29,519
then the policy will be taken care by

00:13:26,480 --> 00:13:31,600
michael yes so there are two networking

00:13:29,519 --> 00:13:34,399
modes basically in cilium

00:13:31,600 --> 00:13:37,040
you can use psyllium to actually

00:13:34,399 --> 00:13:40,399
encapsulate packet between nodes and the

00:13:37,040 --> 00:13:42,399
traditional mode like traditional

00:13:40,399 --> 00:13:43,440
the default method of doing that is

00:13:42,399 --> 00:13:46,800
vxlan

00:13:43,440 --> 00:13:49,279
but in case you want to use bgp

00:13:46,800 --> 00:13:51,519
or in case you are deploying your

00:13:49,279 --> 00:13:54,639
kubernetes cluster in the

00:13:51,519 --> 00:13:58,079
cloud environments like lws or

00:13:54,639 --> 00:13:58,720
gka you can use the direct routing where

00:13:58,079 --> 00:14:01,120
cdu

00:13:58,720 --> 00:14:03,360
doesn't fruit packets between nodes but

00:14:01,120 --> 00:14:06,240
you rather use something else to do that

00:14:03,360 --> 00:14:07,199
and yeah the most popular case of using

00:14:06,240 --> 00:14:11,360
the second mode

00:14:07,199 --> 00:14:15,760
is uh using it's in aws where you have

00:14:11,360 --> 00:14:18,399
eni and also the

00:14:15,760 --> 00:14:18,800
so you know basically the first method

00:14:18,399 --> 00:14:21,839
uh

00:14:18,800 --> 00:14:23,040
is more for bare metal installations at

00:14:21,839 --> 00:14:28,399
the second for

00:14:23,040 --> 00:14:28,399
cloud providers or bare metal with bgp

00:14:28,560 --> 00:14:34,880
and in case of uh the first

00:14:31,600 --> 00:14:37,040
option uh you have overlay the routing

00:14:34,880 --> 00:14:38,160
tunneling mode and you have the

00:14:37,040 --> 00:14:40,959
additional

00:14:38,160 --> 00:14:42,720
network header related to vxlan which is

00:14:40,959 --> 00:14:44,959
handled by celium

00:14:42,720 --> 00:14:46,880
and in the case of the other one you

00:14:44,959 --> 00:14:50,639
have source destination and payload

00:14:46,880 --> 00:14:53,440
and that's it

00:14:50,639 --> 00:14:54,160
and let's talk about uh packet filtering

00:14:53,440 --> 00:14:56,639
right now

00:14:54,160 --> 00:14:58,320
so kubernetes already provided by by

00:14:56,639 --> 00:15:00,959
itself the abstraction called

00:14:58,320 --> 00:15:03,440
network policies which applies on uh

00:15:00,959 --> 00:15:06,560
layer 3 and layer 4

00:15:03,440 --> 00:15:09,760
and one of the forms of

00:15:06,560 --> 00:15:12,240
pre-filtering is a label-based

00:15:09,760 --> 00:15:13,920
ingress filtering so let's imagine we

00:15:12,240 --> 00:15:18,320
have two labels

00:15:13,920 --> 00:15:21,680
uh two kind of rows in the clusters okay

00:15:18,320 --> 00:15:24,959
so you have front end and back end parts

00:15:21,680 --> 00:15:27,600
and uh so you can allow only front-end

00:15:24,959 --> 00:15:29,680
parts to contact the packet but

00:15:27,600 --> 00:15:31,920
deny everything else and there are

00:15:29,680 --> 00:15:34,160
examples also of

00:15:31,920 --> 00:15:36,800
egress filtering where you restrict the

00:15:34,160 --> 00:15:39,839
pot to connect to the outside world

00:15:36,800 --> 00:15:40,800
uh you have also for filtering for

00:15:39,839 --> 00:15:44,079
blocking

00:15:40,800 --> 00:15:44,880
the for allowing only particular pots to

00:15:44,079 --> 00:15:47,680
connect

00:15:44,880 --> 00:15:49,600
parts to connect in and as a filtering

00:15:47,680 --> 00:15:52,880
which also

00:15:49,600 --> 00:15:56,560
takes care about

00:15:52,880 --> 00:16:00,560
acknowledging http protocols or

00:15:56,560 --> 00:16:04,880
http endpoints you can connect to

00:16:00,560 --> 00:16:07,199
and i think yes

00:16:04,880 --> 00:16:09,279
so unfortunately we can't talk much

00:16:07,199 --> 00:16:23,040
about envoy because our time is

00:16:09,279 --> 00:16:26,290
up do you have any questions

00:16:23,040 --> 00:16:26,290
[Music]

00:16:30,740 --> 00:16:33,830
[Music]

00:16:40,720 --> 00:16:44,880
but in the case of i think edpf um the

00:16:43,600 --> 00:16:46,800
way the celium has been

00:16:44,880 --> 00:16:48,240
implemented it is is it is a little bit

00:16:46,800 --> 00:16:49,839
different than what i showed because

00:16:48,240 --> 00:16:51,600
i wanted to show a theoretical approach

00:16:49,839 --> 00:16:53,279
of how it has been handled

00:16:51,600 --> 00:16:55,040
in order for for us to get an

00:16:53,279 --> 00:16:56,560
understanding of how it is handled but

00:16:55,040 --> 00:16:59,279
in the case of ebpf

00:16:56,560 --> 00:17:00,320
that celium does is it has a map of like

00:16:59,279 --> 00:17:02,800
a source ip

00:17:00,320 --> 00:17:05,199
source port and then the ic cables and

00:17:02,800 --> 00:17:05,199
the tables

00:17:08,720 --> 00:17:11,760
no it's not just the um that's what i

00:17:11,439 --> 00:17:13,360
think

00:17:11,760 --> 00:17:15,120
michael mentioned it's not just because

00:17:13,360 --> 00:17:16,880
of uh ip and port

00:17:15,120 --> 00:17:18,319
the advantage that we have with celium

00:17:16,880 --> 00:17:20,559
is based on labels okay

00:17:18,319 --> 00:17:22,000
and you can actually provide uh level

00:17:20,559 --> 00:17:25,039
label based filtering where

00:17:22,000 --> 00:17:26,000
you cannot do with that in filtering and

00:17:25,039 --> 00:17:29,520
also in the case of

00:17:26,000 --> 00:17:31,600
um the q proxy

00:17:29,520 --> 00:17:33,760
q proxy basically uses ip tables and we

00:17:31,600 --> 00:17:35,760
have seen a degradation in performance

00:17:33,760 --> 00:17:40,720
when there are a lot of iptable rules

00:17:35,760 --> 00:17:40,720
that are handled at the point

00:17:40,880 --> 00:17:45,440
yeah so even by including ipsed or or

00:17:43,440 --> 00:17:47,600
even by going with a new version of

00:17:45,440 --> 00:17:50,559
ip tables the nf tables we have seen a

00:17:47,600 --> 00:17:55,120
degradation in performance and if we

00:17:50,559 --> 00:18:01,840
i'm very sorry all right

00:17:55,120 --> 00:18:01,840
thank you guys

00:18:05,600 --> 00:18:07,679

YouTube URL: https://www.youtube.com/watch?v=lrP7hk-EW4U


