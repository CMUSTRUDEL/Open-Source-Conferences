Title: Leveraging Open Source Designs Creating a component search engine for reference designs used in pra…
Publication date: 2020-07-08
Playlist: FOSDEM 2020
Description: 
	Leveraging Open Source Designs Creating a component search engine for reference designs used in practice
by Lasse Mönch

At: FOSDEM 2020
https://video.fosdem.org/2020/H.2213/kicadsearch.webm

Incorporating new components into PCBs is a difficult task that often requires reading multiple datasheets and creating prototypes to get it right. The funny thing is: every engineer needs to re-read reference designs! Even though there are tens of thousands of designs with new components documented and available on Github. The reason: it is almost impossible to find a relevant project. The solution? Instead of using Github search, which only retrieves files by filename, our approach creates a local database that takes the search results from Github, and then parses the used components inside the PCB designs to index them. That way, you can easily search a component and get the most relevant designs as a reference.


This talk will give an overview of the software that was created, discusses the difficulties that were overcome and the potential for improvement in future work.


We have currently indexed 8,000 KiCad-projects on GitHub containing 37,000 electronic components as a proof-of-concept. The project was kindly supported by AISLER with a server instance for a prototype of the search engine, which can be accessed at https://search-dev.aisler.net

Room: H.2213
Scheduled start: 2020-02-01 13:10:00
Captions: 
	00:00:05,120 --> 00:00:07,200
all right

00:00:05,680 --> 00:00:08,960
hi everyone thank you for your interest

00:00:07,200 --> 00:00:11,360
in my talk uh

00:00:08,960 --> 00:00:12,480
i'm lassa i'm a student at avita

00:00:11,360 --> 00:00:14,000
university

00:00:12,480 --> 00:00:16,000
and i'm going to tell you something

00:00:14,000 --> 00:00:17,600
about a project that i did during the

00:00:16,000 --> 00:00:18,800
course of a lab course at that

00:00:17,600 --> 00:00:22,480
university

00:00:18,800 --> 00:00:25,359
so i am mainly a software developer

00:00:22,480 --> 00:00:27,199
and an electronics hobbyist which means

00:00:25,359 --> 00:00:27,760
that i've only tinkered with arduino

00:00:27,199 --> 00:00:29,599
compatible

00:00:27,760 --> 00:00:31,359
microcontrollers and i haven't been

00:00:29,599 --> 00:00:33,520
really into hardware design

00:00:31,359 --> 00:00:35,200
all that much but a little over a year a

00:00:33,520 --> 00:00:37,280
year ago

00:00:35,200 --> 00:00:39,200
i wanted to create my own pcb just a

00:00:37,280 --> 00:00:41,280
simple microcontroller with some sensors

00:00:39,200 --> 00:00:43,840
and i wanted it to be battery operated

00:00:41,280 --> 00:00:45,280
so i thought okay creating vcbs is not

00:00:43,840 --> 00:00:47,120
that hard right it's just like four

00:00:45,280 --> 00:00:48,960
steps you have to choose the components

00:00:47,120 --> 00:00:51,360
that you want to put on your pcb

00:00:48,960 --> 00:00:52,480
use some eda tool to create schematics

00:00:51,360 --> 00:00:57,039
design layout

00:00:52,480 --> 00:00:59,039
upload the files to a manufacturer and

00:00:57,039 --> 00:01:01,039
wait for the mail to arrive all right so

00:00:59,039 --> 00:01:03,359
i started with the first step

00:01:01,039 --> 00:01:04,720
and i went to choose my components so as

00:01:03,359 --> 00:01:06,880
i said i had no idea

00:01:04,720 --> 00:01:08,640
on how to do that so i went to reddit

00:01:06,880 --> 00:01:10,960
and i asked what components should i use

00:01:08,640 --> 00:01:12,880
to control my battery circuit

00:01:10,960 --> 00:01:14,720
and i got a couple of suggestions so i

00:01:12,880 --> 00:01:15,360
went uh off to the internet and i

00:01:14,720 --> 00:01:16,960
searched for

00:01:15,360 --> 00:01:19,280
different data sheets i read through

00:01:16,960 --> 00:01:21,360
them i understood half of them

00:01:19,280 --> 00:01:22,960
and finally i had decided for a chip

00:01:21,360 --> 00:01:25,680
that i wanted to use

00:01:22,960 --> 00:01:26,320
and then i i realized that i had no idea

00:01:25,680 --> 00:01:27,920
on

00:01:26,320 --> 00:01:31,360
how to actually implement it on the

00:01:27,920 --> 00:01:33,520
board so i went off to github

00:01:31,360 --> 00:01:35,280
and i tried to find other people's

00:01:33,520 --> 00:01:35,920
projects that incorporated the same

00:01:35,280 --> 00:01:37,600
chips

00:01:35,920 --> 00:01:39,119
and as it turns out it was quite

00:01:37,600 --> 00:01:39,600
difficult because the chip i was looking

00:01:39,119 --> 00:01:41,840
for

00:01:39,600 --> 00:01:43,360
wasn't mainly wasn't the main component

00:01:41,840 --> 00:01:44,799
on the pcb so it wasn't mentioned

00:01:43,360 --> 00:01:46,399
anywhere in the description or in the

00:01:44,799 --> 00:01:48,399
readme

00:01:46,399 --> 00:01:50,479
and i had to actually search through the

00:01:48,399 --> 00:01:52,000
files which isn't that simple on github

00:01:50,479 --> 00:01:52,799
and by the time i had found the first

00:01:52,000 --> 00:01:54,479
project

00:01:52,799 --> 00:01:56,159
it was 1am and i had to go to bed

00:01:54,479 --> 00:01:57,840
because i had university the next

00:01:56,159 --> 00:01:59,680
day and then i kind of forgot about the

00:01:57,840 --> 00:02:02,320
whole project all right

00:01:59,680 --> 00:02:04,159
so this semester i had the opportunity

00:02:02,320 --> 00:02:05,600
to work on an electronic component

00:02:04,159 --> 00:02:07,920
search engine that basically

00:02:05,600 --> 00:02:09,280
allows you to enter the name of an

00:02:07,920 --> 00:02:10,879
electronic component that you want to

00:02:09,280 --> 00:02:13,360
incorporate into your pcb

00:02:10,879 --> 00:02:15,680
and then it will it will return

00:02:13,360 --> 00:02:17,520
repositories on github that contain that

00:02:15,680 --> 00:02:18,560
have projects that include those

00:02:17,520 --> 00:02:20,160
components

00:02:18,560 --> 00:02:22,480
all right so let's just have a look at

00:02:20,160 --> 00:02:23,920
the result this is what it looks like

00:02:22,480 --> 00:02:25,840
when you search for a component

00:02:23,920 --> 00:02:27,440
on the top you just enter the component

00:02:25,840 --> 00:02:30,000
name and as you can see we found about

00:02:27,440 --> 00:02:32,959
100 repositories including the component

00:02:30,000 --> 00:02:34,879
this is one of them on the top we

00:02:32,959 --> 00:02:35,680
mentioned the repository name and the

00:02:34,879 --> 00:02:38,000
description

00:02:35,680 --> 00:02:39,120
if we can if the project has a license

00:02:38,000 --> 00:02:42,080
the license is shown

00:02:39,120 --> 00:02:43,760
right there on the top right you have

00:02:42,080 --> 00:02:46,640
these stars and forks to give you some

00:02:43,760 --> 00:02:50,160
kind of an idea whether the project is

00:02:46,640 --> 00:02:53,040
liked and therefore possibly useful

00:02:50,160 --> 00:02:55,360
and on the bottom we show the relevant

00:02:53,040 --> 00:02:56,239
files which exact component was found in

00:02:55,360 --> 00:02:58,080
the file

00:02:56,239 --> 00:02:59,360
and we give you a quick link to the data

00:02:58,080 --> 00:03:01,360
sheet if we find one

00:02:59,360 --> 00:03:03,680
and if you want to you can directly go

00:03:01,360 --> 00:03:04,239
to a distributor and buy the part or

00:03:03,680 --> 00:03:07,760
even

00:03:04,239 --> 00:03:08,319
manufacturer projects pcb all right so

00:03:07,760 --> 00:03:10,400
let's

00:03:08,319 --> 00:03:12,080
get into the technical details a little

00:03:10,400 --> 00:03:15,200
bit we

00:03:12,080 --> 00:03:16,879
tried to keep the software modular we

00:03:15,200 --> 00:03:18,000
split it into four components we have a

00:03:16,879 --> 00:03:22,159
crawler that crawls

00:03:18,000 --> 00:03:24,080
github for pcb design files

00:03:22,159 --> 00:03:25,840
then we have a parser that actually

00:03:24,080 --> 00:03:29,040
parses those files and checks for

00:03:25,840 --> 00:03:31,200
the components that are included the

00:03:29,040 --> 00:03:32,799
component names are then validated i'll

00:03:31,200 --> 00:03:34,560
tell you more on that later

00:03:32,799 --> 00:03:36,640
and finally we have a database that can

00:03:34,560 --> 00:03:38,560
be searched and returns the repositories

00:03:36,640 --> 00:03:41,120
that are relevant to your part search

00:03:38,560 --> 00:03:43,120
all right so more details and

00:03:41,120 --> 00:03:46,480
difficulties that we met

00:03:43,120 --> 00:03:48,400
for the crawler our idea was very simple

00:03:46,480 --> 00:03:50,879
just search the whole of github and

00:03:48,400 --> 00:03:51,519
return all pcb files that we can find

00:03:50,879 --> 00:03:55,120
and

00:03:51,519 --> 00:03:56,799
for later indexing however we found out

00:03:55,120 --> 00:03:58,560
that it's not quite that simple to

00:03:56,799 --> 00:04:00,480
search all of github there are

00:03:58,560 --> 00:04:02,239
rate limits on github and there's not

00:04:00,480 --> 00:04:03,599
only visible rate limits which is like

00:04:02,239 --> 00:04:06,319
30 searches per

00:04:03,599 --> 00:04:07,280
minute i think but there's also an

00:04:06,319 --> 00:04:09,760
invisible

00:04:07,280 --> 00:04:11,599
uh counter that somehow calculates how

00:04:09,760 --> 00:04:13,680
computationally intensive your

00:04:11,599 --> 00:04:15,439
search queries are and if you exceed

00:04:13,680 --> 00:04:17,519
those you'll get an abuse node

00:04:15,439 --> 00:04:18,799
and you're shut down for a while all

00:04:17,519 --> 00:04:21,120
right so

00:04:18,799 --> 00:04:22,639
because code search or searching inside

00:04:21,120 --> 00:04:24,639
the files turns out to be very

00:04:22,639 --> 00:04:27,919
computationally intensive for github

00:04:24,639 --> 00:04:29,840
we had to just search for repositories

00:04:27,919 --> 00:04:31,759
and read me that mentioned certain words

00:04:29,840 --> 00:04:34,479
in the description like pcb

00:04:31,759 --> 00:04:35,840
or keycad or stuff like that and then we

00:04:34,479 --> 00:04:38,080
search those repos

00:04:35,840 --> 00:04:40,160
whether or not they actually contain uh

00:04:38,080 --> 00:04:44,320
relevant files

00:04:40,160 --> 00:04:47,199
all right so the parser um

00:04:44,320 --> 00:04:48,000
so the parser downloads keycard pcb

00:04:47,199 --> 00:04:51,120
files and

00:04:48,000 --> 00:04:53,680
extracts the used components from them

00:04:51,120 --> 00:04:54,240
that was the idea but we had to find out

00:04:53,680 --> 00:04:56,240
that the

00:04:54,240 --> 00:04:58,639
component names are actually free text

00:04:56,240 --> 00:05:01,759
fields and some people just

00:04:58,639 --> 00:05:04,960
wrote down whatever they deemed

00:05:01,759 --> 00:05:07,440
yeah useful so that was why

00:05:04,960 --> 00:05:08,160
we had to incorporate a validation

00:05:07,440 --> 00:05:09,759
process

00:05:08,160 --> 00:05:11,199
to find out whether the components that

00:05:09,759 --> 00:05:13,280
were entered in the pcb files

00:05:11,199 --> 00:05:14,720
are actually existing components or if

00:05:13,280 --> 00:05:19,280
it's just something like

00:05:14,720 --> 00:05:22,800
uh 12 to 24 volts dc dc converter

00:05:19,280 --> 00:05:24,000
all right and for the validation we also

00:05:22,800 --> 00:05:27,120
had quite a simple idea

00:05:24,000 --> 00:05:28,960
so our idea was to use a component

00:05:27,120 --> 00:05:31,440
search for example one offered by a

00:05:28,960 --> 00:05:33,440
distributed distributor

00:05:31,440 --> 00:05:35,520
and see if it does return any results

00:05:33,440 --> 00:05:37,680
and if it does return results

00:05:35,520 --> 00:05:39,440
how many so we just said okay if it

00:05:37,680 --> 00:05:42,320
returns zero results it's probably

00:05:39,440 --> 00:05:44,240
non-existent or or just some gibberish

00:05:42,320 --> 00:05:45,840
in the component text

00:05:44,240 --> 00:05:48,000
and if it returned more than 10 results

00:05:45,840 --> 00:05:50,720
we assumed it would be something very

00:05:48,000 --> 00:05:51,680
generic like resistor or something

00:05:50,720 --> 00:05:54,639
however

00:05:51,680 --> 00:05:55,280
we could not find a component search um

00:05:54,639 --> 00:05:57,120
api

00:05:55,280 --> 00:05:59,039
that offered rate limits that were high

00:05:57,120 --> 00:06:01,520
enough for us to find anything

00:05:59,039 --> 00:06:03,840
so we looked at digikey and they offer

00:06:01,520 --> 00:06:07,840
about a thousand requests per day

00:06:03,840 --> 00:06:10,319
for um for free we also look at octopart

00:06:07,840 --> 00:06:12,080
they offer even less they offer 500 for

00:06:10,319 --> 00:06:14,080
educational users

00:06:12,080 --> 00:06:15,680
after you register with them and after

00:06:14,080 --> 00:06:18,080
that it gets really expensive really

00:06:15,680 --> 00:06:18,080
quickly

00:06:18,880 --> 00:06:23,680
yeah but we found a workaround by

00:06:21,120 --> 00:06:26,240
actually using eisler's component search

00:06:23,680 --> 00:06:27,039
and a piggybacking onto a cache that

00:06:26,240 --> 00:06:29,840
they

00:06:27,039 --> 00:06:31,600
built inside their api and we can use

00:06:29,840 --> 00:06:32,720
that without triggering any rate limits

00:06:31,600 --> 00:06:36,479
at all

00:06:32,720 --> 00:06:38,160
all right here is some uh

00:06:36,479 --> 00:06:40,000
well future work or if you're already

00:06:38,160 --> 00:06:40,880
hyped good first issues if you want to

00:06:40,000 --> 00:06:42,479
participate

00:06:40,880 --> 00:06:44,400
uh i don't think do i have time for

00:06:42,479 --> 00:06:47,199
those or

00:06:44,400 --> 00:06:48,240
all right yeah you're eating your

00:06:47,199 --> 00:06:51,199
question time

00:06:48,240 --> 00:06:51,520
okay great um yeah so we want to move

00:06:51,199 --> 00:06:53,919
the

00:06:51,520 --> 00:06:55,199
we developed on a private gitlab uh

00:06:53,919 --> 00:06:56,639
instance and we want to move that to

00:06:55,199 --> 00:06:59,039
gitlab.com

00:06:56,639 --> 00:07:00,479
uh get the ci cd which is already

00:06:59,039 --> 00:07:00,880
running on the private instance running

00:07:00,479 --> 00:07:03,120
again

00:07:00,880 --> 00:07:04,560
and also it's a huge monolithic mess

00:07:03,120 --> 00:07:05,440
which we want to split up into modular

00:07:04,560 --> 00:07:07,840
repos

00:07:05,440 --> 00:07:08,479
uh we want to improve the search a

00:07:07,840 --> 00:07:10,960
little bit

00:07:08,479 --> 00:07:12,800
uh support other formats when keycad

00:07:10,960 --> 00:07:15,759
actually i already

00:07:12,800 --> 00:07:17,680
met the maintainer of fritzing and so

00:07:15,759 --> 00:07:20,160
that might be a good next

00:07:17,680 --> 00:07:21,919
project to work on and we also want to

00:07:20,160 --> 00:07:24,800
support other platforms when github

00:07:21,919 --> 00:07:31,840
all right that's about it thank you for

00:07:24,800 --> 00:07:31,840
your attention

00:07:32,880 --> 00:07:36,639
uh just speak here uh is the intent to

00:07:35,280 --> 00:07:38,800
find uh

00:07:36,639 --> 00:07:39,919
other reference designs using the

00:07:38,800 --> 00:07:42,240
component

00:07:39,919 --> 00:07:43,120
yeah so the idea is just to find example

00:07:42,240 --> 00:07:45,520
projects

00:07:43,120 --> 00:07:47,360
that uh like that have used the same

00:07:45,520 --> 00:07:48,240
components so that you can get an idea

00:07:47,360 --> 00:07:50,400
on how to

00:07:48,240 --> 00:07:51,680
use the component in your pcb okay and

00:07:50,400 --> 00:07:55,199
then the second part is

00:07:51,680 --> 00:07:57,199
is there some kind of way to rate

00:07:55,199 --> 00:07:58,879
the found designs because every now and

00:07:57,199 --> 00:08:00,479
again if i look at these kind of designs

00:07:58,879 --> 00:08:03,520
i find something which i can see

00:08:00,479 --> 00:08:06,479
is probably not going to work

00:08:03,520 --> 00:08:07,039
in real life so any kind of rate system

00:08:06,479 --> 00:08:10,800
or

00:08:07,039 --> 00:08:11,520
not yet that was one future work issue

00:08:10,800 --> 00:08:13,759
here uh

00:08:11,520 --> 00:08:14,879
improve the ranking but right now we are

00:08:13,759 --> 00:08:17,440
ranking using uh

00:08:14,879 --> 00:08:18,960
github stars and forks so that might

00:08:17,440 --> 00:08:22,160
already give you an idea whether a

00:08:18,960 --> 00:08:22,160
project is useful or not

00:08:23,199 --> 00:08:27,360
yeah another improvement could be

00:08:25,599 --> 00:08:28,240
actually using reference design from the

00:08:27,360 --> 00:08:30,800
manufacturer

00:08:28,240 --> 00:08:31,520
because they actually provide it yeah i

00:08:30,800 --> 00:08:34,959
don't think they are

00:08:31,520 --> 00:08:37,120
available oh sorry

00:08:34,959 --> 00:08:38,240
so the there was a suggestion to use

00:08:37,120 --> 00:08:40,159
reference designs

00:08:38,240 --> 00:08:42,000
provided by the distributed by the

00:08:40,159 --> 00:08:44,720
manufacturers of the parts

00:08:42,000 --> 00:08:46,000
yeah but um i would have to look into

00:08:44,720 --> 00:08:48,240
how to actually find them

00:08:46,000 --> 00:08:49,360
i as i said i'm not a hardware

00:08:48,240 --> 00:08:51,120
specialist but i

00:08:49,360 --> 00:08:53,519
only know from reference designs inside

00:08:51,120 --> 00:08:54,080
the pdfs so those are usually only

00:08:53,519 --> 00:08:57,920
graphics

00:08:54,080 --> 00:08:59,920
right or about how

00:08:57,920 --> 00:09:00,959
complicated the part is for a

00:08:59,920 --> 00:09:03,760
microcontroller

00:09:00,959 --> 00:09:05,279
which needs for example an antenna you

00:09:03,760 --> 00:09:07,200
might have a reference design

00:09:05,279 --> 00:09:09,839
okay so that's something maybe worth

00:09:07,200 --> 00:09:12,000
looking into

00:09:09,839 --> 00:09:15,519
yeah have you maybe thought about

00:09:12,000 --> 00:09:15,519
offering some sort of snippet

00:09:20,240 --> 00:09:23,360
okay the question was whether or not one

00:09:22,640 --> 00:09:25,279
could add

00:09:23,360 --> 00:09:26,560
some certain snippet of code or

00:09:25,279 --> 00:09:27,040
something to the ripple to make it

00:09:26,560 --> 00:09:30,959
easily

00:09:27,040 --> 00:09:33,279
findable um no i haven't

00:09:30,959 --> 00:09:36,160
thought about it for now it would just

00:09:33,279 --> 00:09:37,600
be enough to include pcb or something

00:09:36,160 --> 00:09:40,959
some words like that in your repo

00:09:37,600 --> 00:09:43,279
description and then we'll find it

00:09:40,959 --> 00:09:44,720
but yeah maybe some more specific

00:09:43,279 --> 00:09:51,839
keywords

00:09:44,720 --> 00:09:51,839
could be provided for that

00:10:01,519 --> 00:10:04,640
all right i think the question time is

00:10:02,880 --> 00:10:08,240
over there's my

00:10:04,640 --> 00:10:11,920
oh yeah sorry you want to yeah no go

00:10:08,240 --> 00:10:11,920
go ahead more i saw that um

00:10:12,800 --> 00:10:16,959
so you said you were using the cache

00:10:15,839 --> 00:10:19,680
data

00:10:16,959 --> 00:10:21,040
to actually extract these uh how how did

00:10:19,680 --> 00:10:21,440
how do you actually make that work

00:10:21,040 --> 00:10:23,839
because

00:10:21,440 --> 00:10:27,040
both digi-key and octopart explicitly

00:10:23,839 --> 00:10:29,360
for bit caching data

00:10:27,040 --> 00:10:31,519
well we're not using the digi-key cards

00:10:29,360 --> 00:10:34,720
right so eisler has a component search

00:10:31,519 --> 00:10:34,720
that they use for their customers

00:10:39,760 --> 00:10:44,839
so i didn't actually know that because

00:10:41,600 --> 00:10:59,040
we don't really interface directly with

00:10:44,839 --> 00:10:59,040

YouTube URL: https://www.youtube.com/watch?v=NjnInfxS-k0


