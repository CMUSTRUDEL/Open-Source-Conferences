Title: JMC & JFR - 2020 Vision
Publication date: 2020-07-10
Playlist: FOSDEM 2020
Description: 
	by Jie Kang

At: FOSDEM 2020
https://video.fosdem.org/2020/H.1302/imc.webm

JDK Flight Recorder provides production time profiling and diagnostics
via a compact events-based infrastructure inside the Hotspot JVM
itself. JDK Mission Control is a stand-alone application that provides
real-time monitoring information for Hotspot JVMs, as well as tools to
read, automatically analyze and visualize flight recording data
produced by JDK Flight Recorder.


When this talk is presented, JMC 7.1.0 has (hopefully) been out for a
little while. This presentation talks about what is new and the
roadmap for the upcoming JMC 8. We will also discuss recent changes in
the project, such as the move to Skara. Towards the end we will demo
how JDK Flight Recorder and JMC core libraries can be used to diagnose
applications deployed in container orchestration platforms.

Room: H.1302 (Depage)
Scheduled start: 2020-02-01 13:05:00
Captions: 
	00:00:14,070 --> 00:00:21,029
hello everyone I guess I can start now

00:00:16,800 --> 00:00:23,400
at a 1405 so my name is Chi Kang I'm a

00:00:21,029 --> 00:00:25,050
software engineer at Red Hat primarily

00:00:23,400 --> 00:00:28,349
on Mission Control and flight recorder

00:00:25,050 --> 00:00:30,539
and along with me he's not actually here

00:00:28,349 --> 00:00:33,350
is Marcus art director of engineering at

00:00:30,539 --> 00:00:35,850
datavac he's the lead of Mission Control

00:00:33,350 --> 00:00:37,680
originally we were planning to do a talk

00:00:35,850 --> 00:00:38,070
together but unfortunately couldn't make

00:00:37,680 --> 00:00:39,720
it

00:00:38,070 --> 00:00:43,110
however a lot of content here is

00:00:39,720 --> 00:00:46,980
contributed from Marcus so I've included

00:00:43,110 --> 00:00:49,760
him so yeah today James G and J F are

00:00:46,980 --> 00:00:54,030
kind of in brackets 20/20 vision

00:00:49,760 --> 00:00:56,220
looking ahead so on the agenda I'll just

00:00:54,030 --> 00:00:57,840
give a brief introduction to JMC and JFR

00:00:56,220 --> 00:01:00,470
what they are and I'll talk about

00:00:57,840 --> 00:01:03,390
development updates in the past year too

00:01:00,470 --> 00:01:07,100
as well as the roadmap for the coming

00:01:03,390 --> 00:01:11,850
year I guess and then a nice demo of

00:01:07,100 --> 00:01:14,609
Mission Control in the cloud so yet

00:01:11,850 --> 00:01:17,759
James T and J far for those of you who

00:01:14,609 --> 00:01:19,649
have haven't heard of it before J far is

00:01:17,759 --> 00:01:22,170
the JDK flight recorder it's events

00:01:19,649 --> 00:01:26,310
based JVM tech for production time

00:01:22,170 --> 00:01:28,710
profiling and diagnostics while JM c

00:01:26,310 --> 00:01:31,170
stands for JDK Mission Control and it's

00:01:28,710 --> 00:01:33,990
a desktop application for jerax browsing

00:01:31,170 --> 00:01:39,030
as well as JFR visualization and

00:01:33,990 --> 00:01:41,130
analysis so JDK flight recorder it's a

00:01:39,030 --> 00:01:44,310
low overhead recording its compact

00:01:41,130 --> 00:01:46,920
subscribing data in the JFR file format

00:01:44,310 --> 00:01:49,439
it's extensible and you can kind of

00:01:46,920 --> 00:01:52,709
think of it as analogous to a fly

00:01:49,439 --> 00:01:54,990
recorder in an airplane

00:01:52,709 --> 00:01:56,880
Mission Control again desktop

00:01:54,990 --> 00:02:00,600
application provides two main features

00:01:56,880 --> 00:02:03,209
you can connect to JVMs and browse gmx

00:02:00,600 --> 00:02:08,729
related data and then more importantly

00:02:03,209 --> 00:02:11,190
though it has a huge amount of tools for

00:02:08,729 --> 00:02:15,120
visualization and analysis of the flight

00:02:11,190 --> 00:02:17,680
recording files so JDK Mission Control

00:02:15,120 --> 00:02:21,069
really depends heavily

00:02:17,680 --> 00:02:24,189
GFI the third thing along with that

00:02:21,069 --> 00:02:26,859
though is JMC project does have core

00:02:24,189 --> 00:02:28,510
libraries for parsing and analyzing JFR

00:02:26,859 --> 00:02:31,780
data and they are available for

00:02:28,510 --> 00:02:34,180
third-party use so if you're looking at

00:02:31,780 --> 00:02:36,599
using JDK flight recorder and you want

00:02:34,180 --> 00:02:38,620
to analyze or visualize in ways that JMC

00:02:36,599 --> 00:02:41,109
doesn't currently have you can easily

00:02:38,620 --> 00:02:44,469
develop your own tools using the core

00:02:41,109 --> 00:02:47,170
libraries yeah so looking at the tool

00:02:44,469 --> 00:02:49,180
chain for flight quarter in general

00:02:47,170 --> 00:02:51,970
there's three main parts first is

00:02:49,180 --> 00:02:55,329
controlling JFR you can do that through

00:02:51,970 --> 00:02:58,299
CLI Poggio jmx etc so you can start and

00:02:55,329 --> 00:03:00,939
stop flight recordings of a JVM

00:02:58,299 --> 00:03:04,209
application you can ask it to be dumped

00:03:00,939 --> 00:03:08,379
on exit you can set the max memory size

00:03:04,209 --> 00:03:11,349
that JFR is going to take etc then you

00:03:08,379 --> 00:03:12,069
can add data to JFR so there's API for

00:03:11,349 --> 00:03:16,389
that

00:03:12,069 --> 00:03:18,730
JMC provides an agent that I'll go touch

00:03:16,389 --> 00:03:20,769
upon briefly for a dynamic injection of

00:03:18,730 --> 00:03:23,849
jeffer events and then of course you can

00:03:20,769 --> 00:03:26,650
have your own integrations as well so

00:03:23,849 --> 00:03:29,049
JFR does come with a lot of pre-built

00:03:26,650 --> 00:03:31,440
information inside the JVM itself but

00:03:29,049 --> 00:03:33,599
for an application you may have specific

00:03:31,440 --> 00:03:36,400
application data that you want to also

00:03:33,599 --> 00:03:39,489
record and you can use the flight

00:03:36,400 --> 00:03:42,099
recorder system that's in the JVM to do

00:03:39,489 --> 00:03:43,720
that and then at the end of the day of

00:03:42,099 --> 00:03:45,939
course the whole reason we're doing this

00:03:43,720 --> 00:03:48,129
is to use the data to find problems in

00:03:45,939 --> 00:03:50,979
our in our application to try to solve

00:03:48,129 --> 00:03:52,659
performance bottlenecks etc so that's

00:03:50,979 --> 00:03:56,229
where Mission Control comes in there's

00:03:52,659 --> 00:03:59,829
also a GFI utility tool that's provided

00:03:56,229 --> 00:04:02,319
by the JDK that you can use on command

00:03:59,829 --> 00:04:05,049
line and then you can also build your

00:04:02,319 --> 00:04:08,259
own third-party applications to analyze

00:04:05,049 --> 00:04:11,409
letter equipments so if we just look at

00:04:08,259 --> 00:04:13,540
a general workflow you run your JVM with

00:04:11,409 --> 00:04:17,530
JFR enabled various configuration

00:04:13,540 --> 00:04:19,259
options that will output a JFR file that

00:04:17,530 --> 00:04:21,609
you will need to store somewhere

00:04:19,259 --> 00:04:25,210
probably not in the production system

00:04:21,609 --> 00:04:27,340
and then eventually you get that jr4

00:04:25,210 --> 00:04:29,289
file maybe on to your local desktop and

00:04:27,340 --> 00:04:31,310
you analyze the data with Mission

00:04:29,289 --> 00:04:34,520
Control or with other tools

00:04:31,310 --> 00:04:38,840
so you have mini demo just quickly

00:04:34,520 --> 00:04:41,570
showing Mission Control in use so on the

00:04:38,840 --> 00:04:44,420
command line I've started Mission

00:04:41,570 --> 00:04:49,670
Control from the github repo targeting

00:04:44,420 --> 00:04:52,640
JK 11 that opens up this interface so

00:04:49,670 --> 00:04:54,440
it's desktop application on the left

00:04:52,640 --> 00:04:55,940
side we have our JVM browser so

00:04:54,440 --> 00:04:58,040
currently on my laptop

00:04:55,940 --> 00:05:00,590
the only ajv I'm running is Mission

00:04:58,040 --> 00:05:04,370
Control itself we open up up we can

00:05:00,590 --> 00:05:07,130
connect to the ambient server so this

00:05:04,370 --> 00:05:10,780
shows live data of various basic things

00:05:07,130 --> 00:05:14,000
CPU usage cheat memory etc has triggers

00:05:10,780 --> 00:05:16,160
so you could trigger like if CPU usage

00:05:14,000 --> 00:05:19,340
goes too high I want a flight recording

00:05:16,160 --> 00:05:20,600
dumps things like that so it's it's got

00:05:19,340 --> 00:05:24,410
some neat tools in there you could

00:05:20,600 --> 00:05:27,320
diagnose the command but of course the

00:05:24,410 --> 00:05:31,310
most interesting part is I think the

00:05:27,320 --> 00:05:33,260
flight recorder section so over here we

00:05:31,310 --> 00:05:35,090
can see that for Mission Control it's

00:05:33,260 --> 00:05:37,370
already having it already has a

00:05:35,090 --> 00:05:40,130
continuous recording which started as

00:05:37,370 --> 00:05:42,260
soon as the JVM launched so if I double

00:05:40,130 --> 00:05:46,100
click that I can choose to dump the last

00:05:42,260 --> 00:05:49,640
5 minutes for example this outputs a JFR

00:05:46,100 --> 00:05:52,190
file and then we get to all of the the

00:05:49,640 --> 00:05:56,000
tools that JMC comes with for analyzing

00:05:52,190 --> 00:05:57,920
that data so just to cover a few the

00:05:56,000 --> 00:06:00,350
automated analysis results is pretty

00:05:57,920 --> 00:06:02,360
neat so it will analyze all of the

00:06:00,350 --> 00:06:05,330
events in the JFR file and there are

00:06:02,360 --> 00:06:07,220
specific rules that are written to read

00:06:05,330 --> 00:06:10,670
specific events to try and score them

00:06:07,220 --> 00:06:12,050
and provide useful info and on maybe

00:06:10,670 --> 00:06:14,990
there's an issue here that you should

00:06:12,050 --> 00:06:17,180
look at it cetera so that's being

00:06:14,990 --> 00:06:19,760
constantly developed there's various

00:06:17,180 --> 00:06:21,680
pages here like the threads you can look

00:06:19,760 --> 00:06:25,280
at all the threads that are that we're

00:06:21,680 --> 00:06:27,200
running and their states over time it's

00:06:25,280 --> 00:06:29,330
pretty neat there's a huge amount of

00:06:27,200 --> 00:06:33,260
pages I won't go through all of them but

00:06:29,330 --> 00:06:37,640
that's basically Mission Control yeah

00:06:33,260 --> 00:06:41,410
demoed so development updates before I

00:06:37,640 --> 00:06:43,970
go into this hopefully you've all heard

00:06:41,410 --> 00:06:46,670
Oracle open source Mission Control and

00:06:43,970 --> 00:06:51,650
flight recorder about two years ago now

00:06:46,670 --> 00:06:53,680
I think in 2018 may ish timeline and so

00:06:51,650 --> 00:06:56,000
that's even the reason why I'm here

00:06:53,680 --> 00:07:00,260
working on Mission Control on flight

00:06:56,000 --> 00:07:03,890
recorder so since that time one of the

00:07:00,260 --> 00:07:06,770
biggest updates last 2 months ago maybe

00:07:03,890 --> 00:07:08,300
now I don't know what time flies is the

00:07:06,770 --> 00:07:11,300
jamesy project is now on github via

00:07:08,300 --> 00:07:14,510
SCARA so the contribution process can be

00:07:11,300 --> 00:07:16,100
started with a simple pull request which

00:07:14,510 --> 00:07:18,290
is pretty neat there's a lot of tools

00:07:16,100 --> 00:07:20,240
and BOTS around there too so the

00:07:18,290 --> 00:07:26,450
development process of Mission Control

00:07:20,240 --> 00:07:29,080
is very much open from the floor but

00:07:26,450 --> 00:07:31,730
going into actual development updates so

00:07:29,080 --> 00:07:36,920
Oracle did open source Mission Control

00:07:31,730 --> 00:07:39,830
in 2018 and then in June of 2019 which

00:07:36,920 --> 00:07:44,590
is now last year the very first open

00:07:39,830 --> 00:07:48,530
source release of JMC was tagged 7.0 and

00:07:44,590 --> 00:07:51,200
then following that in December which is

00:07:48,530 --> 00:07:56,900
last month or 2 months ago it's February

00:07:51,200 --> 00:07:58,520
now 7.1 data was tagged so if anyone's

00:07:56,900 --> 00:08:01,460
wondering what happened to Mission

00:07:58,520 --> 00:08:04,100
Control after open surah Oracle open

00:08:01,460 --> 00:08:06,230
source it it is continue it is it does

00:08:04,100 --> 00:08:08,840
have an active community we are

00:08:06,230 --> 00:08:11,720
developing new features for it and are

00:08:08,840 --> 00:08:14,570
looking to improve it in into the future

00:08:11,720 --> 00:08:17,420
as well so some of the features in 7.1

00:08:14,570 --> 00:08:20,030
doto are more optimizations of the rules

00:08:17,420 --> 00:08:22,130
so the automated analysis that I showed

00:08:20,030 --> 00:08:24,260
a little earlier it does have some

00:08:22,130 --> 00:08:26,060
issues when dealing with multiple

00:08:24,260 --> 00:08:29,840
gigabyte sized

00:08:26,060 --> 00:08:32,060
JFR files trying to get to analyze all

00:08:29,840 --> 00:08:34,970
the events etc like that so that's an

00:08:32,060 --> 00:08:38,390
ongoing thing actually the J overflow of

00:08:34,970 --> 00:08:40,670
you so there is a view that JMC comes

00:08:38,390 --> 00:08:44,090
with for heap dump analysis that's

00:08:40,670 --> 00:08:47,390
converted from using Java effects to SWT

00:08:44,090 --> 00:08:48,080
now so you no longer need to also have

00:08:47,390 --> 00:08:50,390
Java

00:08:48,080 --> 00:08:52,340
tax on your system to use that and then

00:08:50,390 --> 00:08:56,060
we also have two new views on the flame

00:08:52,340 --> 00:09:00,170
graph which is pretty cool actually and

00:08:56,060 --> 00:09:01,820
then each chart histogram so yeah of

00:09:00,170 --> 00:09:03,590
course there's a huge number of bug

00:09:01,820 --> 00:09:07,040
fixes and stuff like that as you'll see

00:09:03,590 --> 00:09:09,260
um just to try it oh I just realized I

00:09:07,040 --> 00:09:12,920
probably should a click present so it's

00:09:09,260 --> 00:09:15,190
full screen but anyways so a project

00:09:12,920 --> 00:09:19,900
commits since the initial open-sourcing

00:09:15,190 --> 00:09:25,130
to 7.0 they were actually 128 commits

00:09:19,900 --> 00:09:29,240
7.0 to 7.1 399 and the github project

00:09:25,130 --> 00:09:32,720
itself when I created this slide had 238

00:09:29,240 --> 00:09:35,240
commits so it's definitely actively

00:09:32,720 --> 00:09:38,890
being worked on and there's a lot of

00:09:35,240 --> 00:09:42,430
features we want we want to add as well

00:09:38,890 --> 00:09:46,160
distribution wise adopt open JDK has

00:09:42,430 --> 00:09:48,710
provided binaries for download actually

00:09:46,160 --> 00:09:51,740
for the time being these are snapshot

00:09:48,710 --> 00:09:55,850
versions so the latest in the repository

00:09:51,740 --> 00:09:58,150
and I have heard from the developers

00:09:55,850 --> 00:10:00,700
there that they are going to do release

00:09:58,150 --> 00:10:03,710
binaries as well in the future

00:10:00,700 --> 00:10:07,510
Oracle of course does have binaries as

00:10:03,710 --> 00:10:09,530
well as long as it clips update site

00:10:07,510 --> 00:10:12,530
unfortunately they have yet to do the

00:10:09,530 --> 00:10:14,420
7.1 dot or release but hopefully you'll

00:10:12,530 --> 00:10:16,880
see that into the next few months and

00:10:14,420 --> 00:10:20,060
then Red Hat has rpms for fedora and rel

00:10:16,880 --> 00:10:23,360
so if you are using for Doral you can

00:10:20,060 --> 00:10:24,800
DNF where young install those yeah and

00:10:23,360 --> 00:10:27,410
then there are a few other distributions

00:10:24,800 --> 00:10:29,900
like Azul has their mission control but

00:10:27,410 --> 00:10:34,640
basically they're at the moment all the

00:10:29,900 --> 00:10:36,860
same which i think is good yeah so a

00:10:34,640 --> 00:10:39,320
quick slide on contributing the

00:10:36,860 --> 00:10:42,080
repository is on github there's a

00:10:39,320 --> 00:10:44,840
mailing list we have slack which is

00:10:42,080 --> 00:10:48,650
pretty active then our bug tracker is

00:10:44,840 --> 00:10:53,210
the the JDK open JDK JIRA instance and

00:10:48,650 --> 00:10:55,250
as well a little plug for Marcus's JMC

00:10:53,210 --> 00:10:58,130
tutorial if you are looking to learn how

00:10:55,250 --> 00:11:01,139
to use JMC to analyze various problems

00:10:58,130 --> 00:11:04,230
Marcus did procreate

00:11:01,139 --> 00:11:08,730
a quite decent set of problems like

00:11:04,230 --> 00:11:12,689
dealing with memory leaks or hot methods

00:11:08,730 --> 00:11:15,569
etc and how you would see that using JFR

00:11:12,689 --> 00:11:15,779
and using GMC so you can always try that

00:11:15,569 --> 00:11:18,359
out

00:11:15,779 --> 00:11:23,100
so yeah moving on to the road map what's

00:11:18,359 --> 00:11:25,290
up in the future before I talk about J

00:11:23,100 --> 00:11:28,049
and C's road map there is one thing I do

00:11:25,290 --> 00:11:31,679
want to share regarding JFR and so

00:11:28,049 --> 00:11:36,059
Arkell did open-source GFR and JMC for

00:11:31,679 --> 00:11:38,970
open JDK 11 plus but the community it

00:11:36,059 --> 00:11:41,910
has worked on putting GFR into open JDK

00:11:38,970 --> 00:11:44,970
8 and so the CSR was finalized and

00:11:41,910 --> 00:11:47,269
closed in December the remaining to do

00:11:44,970 --> 00:11:50,459
is just to merge it into mainline and

00:11:47,269 --> 00:11:55,350
Mario actually started the thread for

00:11:50,459 --> 00:11:58,049
that in January a week ago maybe so yeah

00:11:55,350 --> 00:12:01,790
once that's accepted we're gonna see JFR

00:11:58,049 --> 00:12:05,009
in open JDK 8 which will be awesome so

00:12:01,790 --> 00:12:08,610
yeah back to JMC though the road map is

00:12:05,009 --> 00:12:12,449
Mission Control 8 so this is our early

00:12:08,610 --> 00:12:14,910
access splash screen but it's going to

00:12:12,449 --> 00:12:17,399
be a major release so there will be

00:12:14,910 --> 00:12:20,309
breaking changes if anyone uses the core

00:12:17,399 --> 00:12:25,799
API for example and it's going to target

00:12:20,309 --> 00:12:29,160
open JDK 15 so 15 releases if there's no

00:12:25,799 --> 00:12:32,309
delays in September 2020 and so you will

00:12:29,160 --> 00:12:35,189
see JMC 8 a few months afterwards as we

00:12:32,309 --> 00:12:39,029
make sure that it actually works on open

00:12:35,189 --> 00:12:43,410
JDK 15 so what are what's what are we

00:12:39,029 --> 00:12:46,769
adding to 8/3 keep things here James C

00:12:43,410 --> 00:12:48,689
agent rules update and then core library

00:12:46,769 --> 00:12:52,919
updates I'll go into each of these

00:12:48,689 --> 00:12:56,100
so the JMC agent is actually a quite

00:12:52,919 --> 00:12:59,759
neat tool it's for dynamic insertion of

00:12:56,100 --> 00:13:02,669
JRR events at runtime so as I said

00:12:59,759 --> 00:13:04,919
earlier you can extend your own events

00:13:02,669 --> 00:13:07,589
into the JFR system but that does

00:13:04,919 --> 00:13:09,899
requires like writing annotations etc in

00:13:07,589 --> 00:13:14,549
the code and then obviously recompiling

00:13:09,899 --> 00:13:15,000
redeploying so the of course you can do

00:13:14,549 --> 00:13:17,700
bike

00:13:15,000 --> 00:13:19,950
instrumentation with other tools to do

00:13:17,700 --> 00:13:23,550
this as well but the JMC agent will be

00:13:19,950 --> 00:13:26,190
designed ground up for insertion of GFR

00:13:23,550 --> 00:13:28,200
events at runtime so if you wanted to

00:13:26,190 --> 00:13:30,150
modify your application without having

00:13:28,200 --> 00:13:33,690
to rewrite the code we recompile

00:13:30,150 --> 00:13:39,210
redeploy you can do that it's optimized

00:13:33,690 --> 00:13:41,790
for the job so hopefully we will see

00:13:39,210 --> 00:13:45,090
that as part of the JMC distribution in

00:13:41,790 --> 00:13:47,070
a thought oh yeah and technically the

00:13:45,090 --> 00:13:49,890
code is already in upstream repository

00:13:47,070 --> 00:13:52,050
and it's being developed on there so if

00:13:49,890 --> 00:13:55,590
if you are interested there are a lot of

00:13:52,050 --> 00:13:56,400
open issues for that too and then rules

00:13:55,590 --> 00:13:58,890
2.0

00:13:56,400 --> 00:14:01,530
again mainly the automated analysis

00:13:58,890 --> 00:14:03,390
section there's going to be improvements

00:14:01,530 --> 00:14:05,220
for performance there's going to be a

00:14:03,390 --> 00:14:09,540
redesign of the rules in general so that

00:14:05,220 --> 00:14:12,840
they can be reused the idea from the

00:14:09,540 --> 00:14:15,690
developer was like you could use rule

00:14:12,840 --> 00:14:19,010
rule a results and rule B and those can

00:14:15,690 --> 00:14:21,810
be used in rule C etc and build up rules

00:14:19,010 --> 00:14:23,850
in a more organized fashion than than

00:14:21,810 --> 00:14:25,980
what they are now and there'll be more

00:14:23,850 --> 00:14:28,530
typed information in the rule itself so

00:14:25,980 --> 00:14:31,800
that you we can more easily visualize

00:14:28,530 --> 00:14:33,690
the rule results and then for whatever

00:14:31,800 --> 00:14:35,670
reason some of them have HTML and

00:14:33,690 --> 00:14:38,790
they're not gonna have that in the

00:14:35,670 --> 00:14:42,930
future and then going into the core API

00:14:38,790 --> 00:14:45,110
so this is the API that JMC also

00:14:42,930 --> 00:14:49,250
provides to third-party applications

00:14:45,110 --> 00:14:51,600
mainly to do with reading in JFR files

00:14:49,250 --> 00:14:55,670
managing the flight recorder system of

00:14:51,600 --> 00:14:58,110
JVMs or discovering jaebeum's in general

00:14:55,670 --> 00:15:00,440
so a lot of these features are extremely

00:14:58,110 --> 00:15:03,900
useful for third-party applications and

00:15:00,440 --> 00:15:06,270
and JMC 8 we're going to be updating it

00:15:03,900 --> 00:15:08,790
to use JDK 8 language features and

00:15:06,270 --> 00:15:13,290
previously it was 7 so this isn't to do

00:15:08,790 --> 00:15:16,220
with compatibility between JFR and your

00:15:13,290 --> 00:15:20,640
open JDK version this is just the actual

00:15:16,220 --> 00:15:22,620
code of the API will compile on 8 plus

00:15:20,640 --> 00:15:25,940
and run on 8 plus because we're going to

00:15:22,620 --> 00:15:27,889
be using JDK 8 language features and

00:15:25,940 --> 00:15:29,899
more thing

00:15:27,889 --> 00:15:32,989
from the application will be moved into

00:15:29,899 --> 00:15:37,149
core to be reused by third-party

00:15:32,989 --> 00:15:37,149
applications because they are useful

00:15:37,839 --> 00:15:42,920
yeah and so some more features in terms

00:15:40,429 --> 00:15:44,509
of I guess the visual aspect of JMC

00:15:42,920 --> 00:15:46,639
we're gonna have new sectors

00:15:44,509 --> 00:15:49,369
visualizations we're gonna have

00:15:46,639 --> 00:15:52,040
improvements to the thread graph the

00:15:49,369 --> 00:15:53,809
flame graph is already being updated as

00:15:52,040 --> 00:15:55,910
we speak but there's gonna be a large

00:15:53,809 --> 00:15:59,059
amount of improvements there and then

00:15:55,910 --> 00:16:01,029
this is something Marcus has like a

00:15:59,059 --> 00:16:03,290
prototype for on his own repo but

00:16:01,029 --> 00:16:05,929
visualizations of stack traces with

00:16:03,290 --> 00:16:08,509
various graphing tools so the image is

00:16:05,929 --> 00:16:13,569
just an example of method profile events

00:16:08,509 --> 00:16:16,489
in a graph format so yeah moving on to

00:16:13,569 --> 00:16:20,689
the demo portion JFR management in

00:16:16,489 --> 00:16:23,839
openshift with container JFR so before i

00:16:20,689 --> 00:16:26,179
jump into the demo i do want to give a

00:16:23,839 --> 00:16:28,489
little bit of context so this is like a

00:16:26,179 --> 00:16:30,619
huge diagram explaining how the demo is

00:16:28,489 --> 00:16:33,829
set up and what's going on which i will

00:16:30,619 --> 00:16:37,040
show again but the basis behind this is

00:16:33,829 --> 00:16:39,679
this new project called container JFR

00:16:37,040 --> 00:16:41,899
that my team's been working on it's

00:16:39,679 --> 00:16:44,269
under the github org alright CMC team

00:16:41,899 --> 00:16:47,209
and the whole idea is just to make it

00:16:44,269 --> 00:16:50,179
easier for users to control flight

00:16:47,209 --> 00:16:52,850
recorder on JVMs that are in containers

00:16:50,179 --> 00:16:58,129
whether it's docker kubernetes openshift

00:16:52,850 --> 00:17:00,679
etc so the features are pretty simple

00:16:58,129 --> 00:17:02,119
you can start and stop recordings you

00:17:00,679 --> 00:17:04,039
can archive recording so you can

00:17:02,119 --> 00:17:06,649
download them you can view automated

00:17:04,039 --> 00:17:09,139
analysis immediately without opening

00:17:06,649 --> 00:17:11,240
your desktop application you can view

00:17:09,139 --> 00:17:15,319
events available for the specific JVM

00:17:11,240 --> 00:17:18,620
and this is all able to be manipulated

00:17:15,319 --> 00:17:20,329
via web UI or command-line tool and then

00:17:18,620 --> 00:17:22,159
we also are looking into various

00:17:20,329 --> 00:17:26,419
integrations with things like griffin o

00:17:22,159 --> 00:17:28,069
of Prometheus etc but those are more

00:17:26,419 --> 00:17:32,419
like experimental so they might

00:17:28,069 --> 00:17:34,669
disappear so but the idea is all this

00:17:32,419 --> 00:17:36,950
stuff you can do now but doing it with

00:17:34,669 --> 00:17:39,049
je viens and containers or je viens

00:17:36,950 --> 00:17:41,240
running on orchestration platforms like

00:17:39,049 --> 00:17:44,179
openshift is not necessarily the

00:17:41,240 --> 00:17:46,400
the easiest thing to set up and the idea

00:17:44,179 --> 00:17:51,020
here is running this project alongside

00:17:46,400 --> 00:17:56,090
your your deployment you can do that

00:17:51,020 --> 00:17:58,670
without any extra work so jiff container

00:17:56,090 --> 00:18:01,309
jeffires made up of four core components

00:17:58,670 --> 00:18:03,920
each of them are their own repository

00:18:01,309 --> 00:18:05,350
there's the main container GFI which

00:18:03,920 --> 00:18:07,670
contains the management service

00:18:05,350 --> 00:18:10,100
including the API for kubernetes and

00:18:07,670 --> 00:18:13,040
OpenShift there's the core which has

00:18:10,100 --> 00:18:15,350
core libraries for JFR management so the

00:18:13,040 --> 00:18:16,880
idea here is technically if you wanted

00:18:15,350 --> 00:18:19,700
to write your own stuff you could extend

00:18:16,880 --> 00:18:22,730
off our core library which contains like

00:18:19,700 --> 00:18:26,059
useful features for dealing with likes

00:18:22,730 --> 00:18:28,490
for example JVM discovery in openshift

00:18:26,059 --> 00:18:32,120
or kubernetes or something there's a web

00:18:28,490 --> 00:18:34,390
front-end just to give a web UI to

00:18:32,120 --> 00:18:37,910
easily do things and then there's

00:18:34,390 --> 00:18:40,070
operator project so I'm not sure how

00:18:37,910 --> 00:18:42,800
familiar everyone is with how kubernetes

00:18:40,070 --> 00:18:45,170
and openshift work but they have this

00:18:42,800 --> 00:18:47,780
operator concept to help deployment of

00:18:45,170 --> 00:18:50,059
things and so we do provide an operator

00:18:47,780 --> 00:18:52,700
where it's basically becomes like a

00:18:50,059 --> 00:18:55,429
one-click operation you click subscribe

00:18:52,700 --> 00:18:58,580
and then everything is started and

00:18:55,429 --> 00:18:59,480
automatic automated and managed by

00:18:58,580 --> 00:19:03,080
OpenShift

00:18:59,480 --> 00:19:05,270
or kubernetes and then along with that

00:19:03,080 --> 00:19:07,730
we there's the side project JFR

00:19:05,270 --> 00:19:10,100
datasource and it provides a data source

00:19:07,730 --> 00:19:12,320
for graph ana for JFR files so if you

00:19:10,100 --> 00:19:14,510
have a JFR file you can you can upload

00:19:12,320 --> 00:19:16,850
it into this data source and then you

00:19:14,510 --> 00:19:20,690
could view any time series or related

00:19:16,850 --> 00:19:21,410
data in Griffin ah and then finally for

00:19:20,690 --> 00:19:23,840
the demo

00:19:21,410 --> 00:19:26,179
there is also an incorporation of Iger

00:19:23,840 --> 00:19:29,390
which is end-to-end distributed tracing

00:19:26,179 --> 00:19:31,910
for your applications so if you're

00:19:29,390 --> 00:19:34,370
deploying like four or five different

00:19:31,910 --> 00:19:36,230
micro services that are HTTP based and

00:19:34,370 --> 00:19:38,540
they're requesting across networks to

00:19:36,230 --> 00:19:43,250
each other you can build a map of what's

00:19:38,540 --> 00:19:46,429
happening using distributed tracing so

00:19:43,250 --> 00:19:48,500
yeah going back to the diagram the setup

00:19:46,429 --> 00:19:50,600
is basically this micro service called

00:19:48,500 --> 00:19:52,669
the robot shop which consists of an

00:19:50,600 --> 00:19:55,190
order service a customer service and a

00:19:52,669 --> 00:19:57,410
factory service so users can

00:19:55,190 --> 00:19:59,680
come in and request an order for a robot

00:19:57,410 --> 00:20:02,030
that goes into the order service which

00:19:59,680 --> 00:20:03,470
tells the factory that it needs to build

00:20:02,030 --> 00:20:05,420
a robot and then tells the customer

00:20:03,470 --> 00:20:08,120
service that they have a customer who

00:20:05,420 --> 00:20:11,330
needs like the database to be updated

00:20:08,120 --> 00:20:13,280
with their order etc and so eventually a

00:20:11,330 --> 00:20:16,760
robot gets built and then gets sent back

00:20:13,280 --> 00:20:18,560
to the user and so these are three

00:20:16,760 --> 00:20:21,980
different Java applications that are

00:20:18,560 --> 00:20:23,360
running basically HTTP servers there

00:20:21,980 --> 00:20:28,250
that are going to be deployed in

00:20:23,360 --> 00:20:32,690
openshift and then on the side we have a

00:20:28,250 --> 00:20:36,320
Jager operator below which manages an

00:20:32,690 --> 00:20:41,570
instance of Jager and the services are

00:20:36,320 --> 00:20:43,670
all and implemented to to work with

00:20:41,570 --> 00:20:47,000
Jager for distributed tracing so they'll

00:20:43,670 --> 00:20:50,120
be sending traces to to the Jager

00:20:47,000 --> 00:20:53,600
instance as well we'll have the

00:20:50,120 --> 00:20:55,250
container JFR operator deployed so

00:20:53,600 --> 00:20:59,090
there's one of those per project and

00:20:55,250 --> 00:21:02,180
that will manage a single container JFR

00:20:59,090 --> 00:21:04,310
instance which contains the web UI

00:21:02,180 --> 00:21:06,680
container JFR the data source and

00:21:04,310 --> 00:21:09,170
Agrafena instance and that will be able

00:21:06,680 --> 00:21:14,270
to connect to any of the applications

00:21:09,170 --> 00:21:18,260
that are running for retrieving flight

00:21:14,270 --> 00:21:19,250
recordings from them so you'll see as

00:21:18,260 --> 00:21:21,260
well

00:21:19,250 --> 00:21:23,630
it's more of an implementation detail

00:21:21,260 --> 00:21:27,130
but the operator will be running flight

00:21:23,630 --> 00:21:30,290
recorder instances resources per

00:21:27,130 --> 00:21:33,380
application in the project which is used

00:21:30,290 --> 00:21:36,680
for management purposes it's not too

00:21:33,380 --> 00:21:43,970
important so yeah we can jump into the

00:21:36,680 --> 00:21:46,490
demo so there is a portion that's

00:21:43,970 --> 00:21:49,790
internet related but the Internet's of

00:21:46,490 --> 00:21:53,060
its body so I might skip it oh yeah in

00:21:49,790 --> 00:21:55,280
the project I created in in openshift

00:21:53,060 --> 00:21:58,760
cluster on my local machine I called it

00:21:55,280 --> 00:22:01,850
Fossum 2020 if we go into the operators

00:21:58,760 --> 00:22:05,390
I've installed the Jaeger operator as

00:22:01,850 --> 00:22:08,000
well as a container JFR operator and

00:22:05,390 --> 00:22:09,510
then the Jaeger operator itself installs

00:22:08,000 --> 00:22:12,870
the elasticsearch off

00:22:09,510 --> 00:22:15,860
though I don't technically use it if we

00:22:12,870 --> 00:22:20,190
look at the deployments I have a

00:22:15,860 --> 00:22:25,830
container for operator Jaeger fantastic

00:22:20,190 --> 00:22:27,690
search and the Seeger instance so when

00:22:25,830 --> 00:22:30,660
it comes to to setting up container

00:22:27,690 --> 00:22:32,640
Jerry fired the basics behind it is you

00:22:30,660 --> 00:22:34,410
install the operator through through the

00:22:32,640 --> 00:22:36,900
operator hub and then once you've

00:22:34,410 --> 00:22:39,090
installed it you you simply go into the

00:22:36,900 --> 00:22:41,430
project that you want an instance of and

00:22:39,090 --> 00:22:44,550
you click create instance and then you

00:22:41,430 --> 00:22:46,260
hit in the spec minimal either true or

00:22:44,550 --> 00:22:48,600
false

00:22:46,260 --> 00:22:51,510
so that will decide if you want to

00:22:48,600 --> 00:22:54,600
deploy the web UI and related tools or

00:22:51,510 --> 00:22:56,370
not so if you want the web UI you put in

00:22:54,600 --> 00:23:01,260
minimum or false and then you just hit

00:22:56,370 --> 00:23:03,780
create and then from there everything

00:23:01,260 --> 00:23:05,870
else is is automatically set up by the

00:23:03,780 --> 00:23:09,800
system and and you're done

00:23:05,870 --> 00:23:11,670
so once you have that up and running I

00:23:09,800 --> 00:23:13,890
already have an instance called

00:23:11,670 --> 00:23:16,440
container tray fire and I just created

00:23:13,890 --> 00:23:19,110
the example instance but if we go into

00:23:16,440 --> 00:23:22,770
our route section this stuff it's

00:23:19,110 --> 00:23:26,610
automatically created so there are

00:23:22,770 --> 00:23:29,700
exposed HTTP endpoints for container JFR

00:23:26,610 --> 00:23:32,000
so I can visit that now so this one just

00:23:29,700 --> 00:23:34,820
opens up our working problem

00:23:32,000 --> 00:23:38,550
work-in-progress web UI and so this is

00:23:34,820 --> 00:23:40,650
where you can through UI look at the JVM

00:23:38,550 --> 00:23:44,490
s that are running in this openshift

00:23:40,650 --> 00:23:45,990
project so going back to the cluster if

00:23:44,490 --> 00:23:48,480
we look at the deployment coffee this is

00:23:45,990 --> 00:23:53,280
actually where I've deployed the robot

00:23:48,480 --> 00:23:56,700
shop with poorly named means so RCS is

00:23:53,280 --> 00:24:00,270
the customer service our FS is factory

00:23:56,700 --> 00:24:03,200
service and RLS is the order service so

00:24:00,270 --> 00:24:05,580
these are the deployments that

00:24:03,200 --> 00:24:10,530
correspond to the micro services I

00:24:05,580 --> 00:24:13,890
showed earlier so here we can connect to

00:24:10,530 --> 00:24:16,110
the target je viens at the moment it

00:24:13,890 --> 00:24:20,400
basically just shows their their

00:24:16,110 --> 00:24:23,010
hostname and then the port so down below

00:24:20,400 --> 00:24:25,320
here is the RCS

00:24:23,010 --> 00:24:27,600
it's the IRFs sports and our OS ports

00:24:25,320 --> 00:24:30,900
for the micro services so on these

00:24:27,600 --> 00:24:35,070
applications I have exposed for our GM X

00:24:30,900 --> 00:24:39,360
connections 1991 so for example in this

00:24:35,070 --> 00:24:41,820
RCS 1991 I can connect to it and then

00:24:39,360 --> 00:24:46,590
the basic UI is you can create

00:24:41,820 --> 00:24:51,240
recordings can set a snapshot time what

00:24:46,590 --> 00:24:53,220
events the name etc and then once you

00:24:51,240 --> 00:24:56,330
have a recording for example this one

00:24:53,220 --> 00:25:04,980
which is continuously running you can

00:24:56,330 --> 00:25:07,740
view a summary which will load the

00:25:04,980 --> 00:25:10,680
automated analysis reports in the in the

00:25:07,740 --> 00:25:13,050
web UI you can choose to download it you

00:25:10,680 --> 00:25:17,190
can save it into the archive which works

00:25:13,050 --> 00:25:19,850
with persistent persistent storage for

00:25:17,190 --> 00:25:23,100
open shift and then that's basically

00:25:19,850 --> 00:25:29,550
getting your JFR files outs out of your

00:25:23,100 --> 00:25:31,500
out of your cluster ok so as far as the

00:25:29,550 --> 00:25:34,380
demo is concerned we have three micro

00:25:31,500 --> 00:25:37,560
services that are running and I'm gonna

00:25:34,380 --> 00:25:40,440
submit an order to them from my local

00:25:37,560 --> 00:25:46,980
machine so I have this load application

00:25:40,440 --> 00:25:51,200
I'm just gonna run yeah so the load

00:25:46,980 --> 00:25:54,950
application will target those three

00:25:51,200 --> 00:25:58,380
services which expose HTTP routes

00:25:54,950 --> 00:26:03,390
hopefully this works and so you can see

00:25:58,380 --> 00:26:06,150
here it's it has pretty extensive

00:26:03,390 --> 00:26:08,310
logging but in general it's ordering

00:26:06,150 --> 00:26:11,820
three robots to be created and then

00:26:08,310 --> 00:26:16,140
delivered to the user so if we go back

00:26:11,820 --> 00:26:21,960
here we can open up

00:26:16,140 --> 00:26:24,960
Jagr and see we do have this services

00:26:21,960 --> 00:26:28,590
and their traces so like you can find

00:26:24,960 --> 00:26:31,890
that and then with distributed tracing

00:26:28,590 --> 00:26:34,330
we'd get a overlook of exactly what

00:26:31,890 --> 00:26:39,360
occurred in the HTTP

00:26:34,330 --> 00:26:41,559
work so request was made to order

00:26:39,360 --> 00:26:43,960
validated user and then there's three

00:26:41,559 --> 00:26:47,980
build robot requests so it built a robot

00:26:43,960 --> 00:26:49,929
three times and there's pickup etc as

00:26:47,980 --> 00:26:52,330
well we can go into dependencies and

00:26:49,929 --> 00:26:57,399
look at the directed Silla graph and

00:26:52,330 --> 00:27:00,220
just see in our setup of services when

00:26:57,399 --> 00:27:02,500
the request came in the order service

00:27:00,220 --> 00:27:04,659
made 10 requests the factory service and

00:27:02,500 --> 00:27:07,029
also one request the customer service so

00:27:04,659 --> 00:27:11,019
it just shows you the connections

00:27:07,029 --> 00:27:16,649
between your your micro services and

00:27:11,019 --> 00:27:19,419
then back to the trace so given a trace

00:27:16,649 --> 00:27:22,690
there is quite a bit of information you

00:27:19,419 --> 00:27:25,929
can see for example here in the creating

00:27:22,690 --> 00:27:29,889
chastity it was of type T 800 and it

00:27:25,929 --> 00:27:31,899
took 469 milliseconds to do that whereas

00:27:29,889 --> 00:27:35,409
when it was creating this Wally robot it

00:27:31,899 --> 00:27:38,230
took 670 milliseconds and then you can

00:27:35,409 --> 00:27:40,059
see across a whole request how long it

00:27:38,230 --> 00:27:42,820
took to point four seconds here at three

00:27:40,059 --> 00:27:46,840
seconds etc so you do get a neat

00:27:42,820 --> 00:27:49,389
overview of what's going on at a little

00:27:46,840 --> 00:27:51,010
higher level in your application but

00:27:49,389 --> 00:27:54,399
when you when you're trying to diagnose

00:27:51,010 --> 00:27:56,950
issues or potential performance problems

00:27:54,399 --> 00:27:59,230
you do need a little more and that's

00:27:56,950 --> 00:28:03,429
where in combination with something like

00:27:59,230 --> 00:28:05,740
JFR you can solve a lot so in this

00:28:03,429 --> 00:28:08,649
scenario with this is obviously a dummy

00:28:05,740 --> 00:28:12,070
project there are a few problems coded

00:28:08,649 --> 00:28:16,720
into it for example in the creating

00:28:12,070 --> 00:28:18,159
chassis x' you can see here when i was

00:28:16,720 --> 00:28:20,710
creating the wally robot for whatever

00:28:18,159 --> 00:28:24,370
reason it took 670 milliseconds whereas

00:28:20,710 --> 00:28:27,039
when I was doing coffee it was only 272

00:28:24,370 --> 00:28:28,870
it's a huge difference if you know a

00:28:27,039 --> 00:28:32,590
little bit about your own application

00:28:28,870 --> 00:28:34,269
maybe this is an unexpected result these

00:28:32,590 --> 00:28:38,320
two robots should take a similar amount

00:28:34,269 --> 00:28:40,779
of time so from here though you can't

00:28:38,320 --> 00:28:42,909
get much more than than the information

00:28:40,779 --> 00:28:45,370
it shows right like so why did it take

00:28:42,909 --> 00:28:48,039
more time and that's where I'm gonna go

00:28:45,370 --> 00:28:49,899
in now with JFR so this was in

00:28:48,039 --> 00:28:53,379
factory service so I'm gonna get a

00:28:49,899 --> 00:28:55,619
recording of that back to the web UI I'm

00:28:53,379 --> 00:28:58,989
going to target the factory service

00:28:55,619 --> 00:29:02,590
it says port it has a continuous

00:28:58,989 --> 00:29:05,889
recording enabled so I'm just going to

00:29:02,590 --> 00:29:07,259
download that to my system so with with

00:29:05,889 --> 00:29:09,190
your click it's now on my own machine

00:29:07,259 --> 00:29:15,039
and then going back to Mission Control

00:29:09,190 --> 00:29:20,340
now I can open that up real quickly in

00:29:15,039 --> 00:29:23,769
the Downloads factory service dachi FR

00:29:20,340 --> 00:29:25,899
so yeah on the get go for the factory

00:29:23,769 --> 00:29:28,059
servers there isn't too much and

00:29:25,899 --> 00:29:29,590
automated announce results unfortunately

00:29:28,059 --> 00:29:33,970
so you do have to go digging a little

00:29:29,590 --> 00:29:35,649
deeper so one thing I can look at in

00:29:33,970 --> 00:29:39,789
this case I know it's the creating

00:29:35,649 --> 00:29:42,580
jassi's and in this process when it

00:29:39,789 --> 00:29:46,599
creates a robot it uses a thread pool

00:29:42,580 --> 00:29:50,159
system so I can look at the that the set

00:29:46,599 --> 00:29:57,509
of threads in this case the factory line

00:29:50,159 --> 00:29:57,509
and see what's going on so if I then

00:29:58,409 --> 00:30:08,769
zoom in to that I can see here the

00:30:06,429 --> 00:30:11,889
execution of these threads and what they

00:30:08,769 --> 00:30:12,489
were stated their state was so actually

00:30:11,889 --> 00:30:15,970
in my demo

00:30:12,489 --> 00:30:17,859
I sent the request quite a while ago so

00:30:15,970 --> 00:30:20,109
some of the information isn't around and

00:30:17,859 --> 00:30:23,039
the reason for that is it's a continuous

00:30:20,109 --> 00:30:27,759
recording which I've set to only keep

00:30:23,039 --> 00:30:31,029
128 megabytes of space so the recording

00:30:27,759 --> 00:30:33,159
won't contain events from the lifetime

00:30:31,029 --> 00:30:35,440
of the JVM if it's lasting for a long

00:30:33,159 --> 00:30:37,450
time but that's a configuration option

00:30:35,440 --> 00:30:39,999
but in any case we can still see some

00:30:37,450 --> 00:30:43,749
interesting information here we're in

00:30:39,999 --> 00:30:47,950
the scope of building a robot a huge

00:30:43,749 --> 00:30:50,559
portion of time was spent blocked and so

00:30:47,950 --> 00:30:55,710
there's obviously a concurrency problem

00:30:50,559 --> 00:30:58,419
here going on because I can make

00:30:55,710 --> 00:31:00,489
hopefully decent assumption that it was

00:30:58,419 --> 00:31:01,870
blocked because of something else like

00:31:00,489 --> 00:31:04,390
the other factory line

00:31:01,870 --> 00:31:08,590
right because this so the blue is it's

00:31:04,390 --> 00:31:12,940
it's sleeping and then here it's blocked

00:31:08,590 --> 00:31:14,590
and then this is I think active but so

00:31:12,940 --> 00:31:16,929
if I actually click into the block

00:31:14,590 --> 00:31:21,880
section go and look at the stack trace

00:31:16,929 --> 00:31:22,570
portion I can see that in its block

00:31:21,880 --> 00:31:28,000
states

00:31:22,570 --> 00:31:31,510
oops down here it was in the paint robot

00:31:28,000 --> 00:31:35,260
which was then in in in the logger so I

00:31:31,510 --> 00:31:37,360
have a little bit of code now that I can

00:31:35,260 --> 00:31:40,659
go back to my project code and say maybe

00:31:37,360 --> 00:31:43,440
I'll go look into this logging of ok

00:31:40,659 --> 00:31:46,029
robot or logging of create jassi's and

00:31:43,440 --> 00:31:53,380
see what's happening there so if I go

00:31:46,029 --> 00:31:59,529
and open up my code editor now and the

00:31:53,380 --> 00:32:04,899
project so I'm just gonna search me

00:31:59,529 --> 00:32:07,870
chassis so in the chassis code there is

00:32:04,899 --> 00:32:10,179
a span dollar for tracing purposes and

00:32:07,870 --> 00:32:12,130
then there's a logger call right here

00:32:10,179 --> 00:32:14,140
and then the sleep it's supposed to

00:32:12,130 --> 00:32:17,110
simulate building each a sees which is

00:32:14,140 --> 00:32:19,330
supposed to be constant time so um

00:32:17,110 --> 00:32:20,649
because the the secretary showed that it

00:32:19,330 --> 00:32:23,289
was sleeping in logger I'm I'm gonna

00:32:20,649 --> 00:32:25,750
check the logger out now coño logger

00:32:23,289 --> 00:32:28,960
Java will see that Marcus decided to

00:32:25,750 --> 00:32:30,640
make this synchronized static void

00:32:28,960 --> 00:32:33,370
message which is terrible for logging

00:32:30,640 --> 00:32:35,169
purposes because we have for factory

00:32:33,370 --> 00:32:36,429
lines that are trying to make robots and

00:32:35,169 --> 00:32:39,179
they're gonna all hit the slogging

00:32:36,429 --> 00:32:42,190
synchronize thing and get blocked so

00:32:39,179 --> 00:32:46,200
we'd have to work that out so this is

00:32:42,190 --> 00:32:49,000
just a quick example of how you can take

00:32:46,200 --> 00:32:52,240
distributed tracing and JFR together to

00:32:49,000 --> 00:32:59,559
get a deeper look at problems in your in

00:32:52,240 --> 00:33:05,230
your code yeah and so going back to the

00:32:59,559 --> 00:33:07,659
open shift set up just for some clarity

00:33:05,230 --> 00:33:10,570
in terms of your JVM application

00:33:07,659 --> 00:33:14,620
apart from deploying container JFR the

00:33:10,570 --> 00:33:15,280
only thing you now need to do for JVM

00:33:14,620 --> 00:33:18,430
application

00:33:15,280 --> 00:33:21,100
in a container is exposed a connection

00:33:18,430 --> 00:33:23,800
for container to fire in this case we do

00:33:21,100 --> 00:33:25,540
support IgM X so if we look at our

00:33:23,800 --> 00:33:27,220
deployment configs and the environment

00:33:25,540 --> 00:33:30,790
variables we'll see there's a Java op

00:33:27,220 --> 00:33:36,450
section that I set up and in this Java

00:33:30,790 --> 00:33:36,450
ops I'm going to make it bigger yeah

00:33:37,020 --> 00:33:45,550
okay that was too big I exposed

00:33:41,530 --> 00:33:47,860
9091 obviously on a non production

00:33:45,550 --> 00:33:48,970
system without authentication and then

00:33:47,860 --> 00:33:53,620
these are the settings for flight

00:33:48,970 --> 00:33:56,500
recorder to be continuous so yeah in

00:33:53,620 --> 00:34:00,160
general territory far the idea is to

00:33:56,500 --> 00:34:04,890
make getting JFR files out of je viens

00:34:00,160 --> 00:34:04,890
and containers as easy as possible and

00:34:05,910 --> 00:34:12,190
yeah the other neat thing to hear while

00:34:09,879 --> 00:34:14,290
in there is just for example in an

00:34:12,190 --> 00:34:16,929
orchestration system there's concept of

00:34:14,290 --> 00:34:19,060
internal external networks so normally

00:34:16,929 --> 00:34:20,679
when you do a JMX connection you want it

00:34:19,060 --> 00:34:24,100
to be secure because if you're opening a

00:34:20,679 --> 00:34:25,629
port in in the system than anyone could

00:34:24,100 --> 00:34:28,090
maybe exercise and do something

00:34:25,629 --> 00:34:31,690
malicious but with internal external

00:34:28,090 --> 00:34:34,179
networks the port is actually in the set

00:34:31,690 --> 00:34:37,870
up I have only on an internal OpenShift

00:34:34,179 --> 00:34:39,429
network so only OpenShift services with

00:34:37,870 --> 00:34:41,530
the correct privileges are able to

00:34:39,429 --> 00:34:44,350
access it so you get the security there

00:34:41,530 --> 00:34:47,050
for free so theoretically this stuff

00:34:44,350 --> 00:34:53,889
isn't exposed as long as open Chiffre

00:34:47,050 --> 00:35:02,370
with their code correctly yeah so going

00:34:53,889 --> 00:35:02,370
back to the slides here

00:35:02,749 --> 00:35:07,469
again that was the demo demo for JFR

00:35:05,940 --> 00:35:10,469
management and open shipping container

00:35:07,469 --> 00:35:12,359
and finally I'd like to end off again

00:35:10,469 --> 00:35:14,640
with contributing to J and C we have a

00:35:12,359 --> 00:35:17,940
repo meaning it cetera we're pretty

00:35:14,640 --> 00:35:20,309
active there's a huge amount of issues

00:35:17,940 --> 00:35:31,319
in a variety of areas so you can work on

00:35:20,309 --> 00:35:33,440
and yeah thank you so I guess I have

00:35:31,319 --> 00:35:42,630
some time if anyone has questions uh

00:35:33,440 --> 00:35:45,809
sure in the center so that's something

00:35:42,630 --> 00:35:48,119
oh yeah so the question was if the GMC

00:35:45,809 --> 00:35:50,940
core libraries will ever be published on

00:35:48,119 --> 00:35:53,329
maven central so that one actually

00:35:50,940 --> 00:35:56,880
became a little complicated because

00:35:53,329 --> 00:35:59,400
Oracle had plans to publish it into Sona

00:35:56,880 --> 00:36:01,829
type and so they started the process and

00:35:59,400 --> 00:36:05,609
they got the permissions and the admin

00:36:01,829 --> 00:36:07,259
rights and then they stopped and I don't

00:36:05,609 --> 00:36:10,019
know where they went but they have the

00:36:07,259 --> 00:36:11,670
admin rights to the name for the core

00:36:10,019 --> 00:36:16,229
libraries and everything so we have to

00:36:11,670 --> 00:36:18,089
discuss that but in general we do want

00:36:16,229 --> 00:36:19,769
them to be on mute and central so people

00:36:18,089 --> 00:36:22,680
can easily get them into their maven

00:36:19,769 --> 00:36:27,739
projects for the time being adopt open

00:36:22,680 --> 00:36:30,479
JDK actually publishes to a a repository

00:36:27,739 --> 00:36:32,940
the core libraries so you can pull that

00:36:30,479 --> 00:36:37,259
from your maven projects you just need

00:36:32,940 --> 00:36:42,140
to add an external repo yeah

00:36:37,259 --> 00:36:42,140
any other questions sure back

00:36:44,609 --> 00:36:52,030
thanks Andrew thank you um regarding the

00:36:48,790 --> 00:36:54,250
container JFR what's the deployment

00:36:52,030 --> 00:36:57,609
model like is it like a sight card

00:36:54,250 --> 00:37:00,760
that's injected into every JVM and since

00:36:57,609 --> 00:37:03,190
it sees no is it like a Damon's head or

00:37:00,760 --> 00:37:05,230
so how does this scale I mean just okay

00:37:03,190 --> 00:37:09,849
yeah so the question was what's the

00:37:05,230 --> 00:37:12,430
deployment method of container JFR and

00:37:09,849 --> 00:37:15,849
how it interacts the JVM s that it's

00:37:12,430 --> 00:37:17,770
trying to monitor it is not a agent it's

00:37:15,849 --> 00:37:20,740
not an agent that you inject into the

00:37:17,770 --> 00:37:22,990
JVM itself or into the the pod that's

00:37:20,740 --> 00:37:27,099
running the JVM it at the moment solely

00:37:22,990 --> 00:37:31,630
relies on connection protocols for

00:37:27,099 --> 00:37:34,810
example our gmx or JD p to connect to je

00:37:31,630 --> 00:37:38,980
viens that are running so the general

00:37:34,810 --> 00:37:41,890
process is for an application developer

00:37:38,980 --> 00:37:44,500
you deploy your JVM you expose our gmx

00:37:41,890 --> 00:37:47,470
and then you're done container JFR runs

00:37:44,500 --> 00:37:51,849
on the side as long as it has access to

00:37:47,470 --> 00:37:53,500
the same network it will see that a 9091

00:37:51,849 --> 00:37:57,369
port is exposed and then be able to

00:37:53,500 --> 00:38:00,760
connect to it and go from there so so

00:37:57,369 --> 00:38:03,640
the discovery at the moment is is pretty

00:38:00,760 --> 00:38:06,550
dumb it discovers it tries to discover

00:38:03,640 --> 00:38:08,290
everything but we we're trying to

00:38:06,550 --> 00:38:10,300
fine-tune it for example you could add

00:38:08,290 --> 00:38:12,730
an environment variable or something

00:38:10,300 --> 00:38:15,130
this is specific to kubernetes or

00:38:12,730 --> 00:38:18,520
openshift but to specify that this is a

00:38:15,130 --> 00:38:20,380
JVM that's exposing a connection for you

00:38:18,520 --> 00:38:23,250
and then so will connect directly bad

00:38:20,380 --> 00:38:23,250
but

00:38:26,870 --> 00:38:31,720
yeah so Prometheus is Apple based system

00:38:40,630 --> 00:38:50,120
so compared to Prometheus Oh so the

00:38:48,050 --> 00:38:52,880
question here was how does this compare

00:38:50,120 --> 00:38:56,530
to prometheus is discovery protocol and

00:38:52,880 --> 00:38:59,300
so Prometheus for those that don't know

00:38:56,530 --> 00:39:02,810
works on a primarily pull based system

00:38:59,300 --> 00:39:07,040
where the aged the running application

00:39:02,810 --> 00:39:08,600
exposes a base basic web service that

00:39:07,040 --> 00:39:12,290
prometheus connects to and poles from

00:39:08,600 --> 00:39:14,060
repeatedly and how Prometheus discovers

00:39:12,290 --> 00:39:17,630
these is through service tags and things

00:39:14,060 --> 00:39:20,150
like that so we will have a similar

00:39:17,630 --> 00:39:23,210
system for kubernetes and OpenShift

00:39:20,150 --> 00:39:24,680
where you can apply it in an open ship

00:39:23,210 --> 00:39:27,020
for example they have this concept of

00:39:24,680 --> 00:39:30,500
labels which you can apply to an

00:39:27,020 --> 00:39:33,290
application deployment and then we can

00:39:30,500 --> 00:39:36,620
read those labels and and see that oh

00:39:33,290 --> 00:39:40,250
that's far label so we should check that

00:39:36,620 --> 00:39:41,960
out but otherwise at the moment the

00:39:40,250 --> 00:39:43,790
discovery protocol is within the

00:39:41,960 --> 00:39:47,630
OpenShift networking system or

00:39:43,790 --> 00:39:51,140
kubernetes networking system where we as

00:39:47,630 --> 00:39:53,390
a deployment in the same project have

00:39:51,140 --> 00:39:56,210
access to the network and we can see all

00:39:53,390 --> 00:39:58,700
of the things running on that network

00:39:56,210 --> 00:40:00,080
and so we don't actually need your

00:39:58,700 --> 00:40:05,990
application to specify anything

00:40:00,080 --> 00:40:09,830
technically what's that help any other

00:40:05,990 --> 00:40:11,420
questions yeah I think you should

00:40:09,830 --> 00:40:12,860
probably take those outside we need to

00:40:11,420 --> 00:40:15,880
have time to turn around the room for

00:40:12,860 --> 00:40:17,680
the next speaker thank you very much

00:40:15,880 --> 00:40:17,980
[Applause]

00:40:17,680 --> 00:40:22,960
you

00:40:17,980 --> 00:40:22,960

YouTube URL: https://www.youtube.com/watch?v=oLpbz6b7tWw


