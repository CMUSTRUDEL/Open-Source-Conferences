Title: Ada-TOML: a TOML Parser for Ada
Publication date: 2020-07-09
Playlist: FOSDEM 2020
Description: 
	by Pierre-Marie de Rodat

At: FOSDEM 2020
https://video.fosdem.org/2020/AW1.125/ada_toml.webm

The world of generic structured data formats is full of contenders:
the mighty XML, the swift JSON, the awesome YAML, ...  Alas, there
is no silver bullet: XML is very verbose, JSON is not convenient for
humans to write, YAML is known to be hard to parse, and so on.


TOML is yet another format whose goal is to be a good configuration
language: obvious semantics, convenient to write and easy to parse
in general-purpose programming languages.


In this talk, I'll shortly describe the TOML format and show a few
use cases in the real world.  I'll then present the ada-toml library
itself: its high-level architecture and examples.

Room: AW1.125
Scheduled start: 2020-02-01 17:30:00
Captions: 
	00:00:05,359 --> 00:00:09,280
okay

00:00:06,000 --> 00:00:09,760
so uh hi again thank you for attending

00:00:09,280 --> 00:00:13,519
this

00:00:09,760 --> 00:00:15,839
last presentation of the day

00:00:13,519 --> 00:00:17,039
so in case you were not in at the

00:00:15,839 --> 00:00:20,080
previous presentations

00:00:17,039 --> 00:00:20,400
i'm pierre marie and i work at idaho and

00:00:20,080 --> 00:00:22,720
so

00:00:20,400 --> 00:00:23,680
this presentation will be about a small

00:00:22,720 --> 00:00:27,599
idea library

00:00:23,680 --> 00:00:29,439
to read thermal files so what is thermal

00:00:27,599 --> 00:00:32,719
exactly

00:00:29,439 --> 00:00:36,320
let's first describe what it's not uh

00:00:32,719 --> 00:00:38,879
so um it's it's a it's a format

00:00:36,320 --> 00:00:40,079
it's a text format to uh to record data

00:00:38,879 --> 00:00:43,840
basically

00:00:40,079 --> 00:00:47,280
it's generic just like xml json and ml

00:00:43,840 --> 00:00:50,480
which i will compare it to so in xml

00:00:47,280 --> 00:00:53,120
uh everybody knows xml it's uh

00:00:50,480 --> 00:00:54,320
it's a format that is more or less

00:00:53,120 --> 00:00:57,520
easily

00:00:54,320 --> 00:00:58,559
written and written by humans more or

00:00:57,520 --> 00:01:02,320
less because

00:00:58,559 --> 00:01:04,799
if it's a bit verbose and the

00:01:02,320 --> 00:01:07,119
most one of its defaults is that it's

00:01:04,799 --> 00:01:11,600
expensive to process

00:01:07,119 --> 00:01:14,880
it's a complex format and writing

00:01:11,600 --> 00:01:17,200
an xml parser is a is a big job

00:01:14,880 --> 00:01:18,479
and it's very hard to get it right not

00:01:17,200 --> 00:01:20,080
only to write the parser

00:01:18,479 --> 00:01:22,000
but then to write something that uses a

00:01:20,080 --> 00:01:25,439
parser because of the

00:01:22,000 --> 00:01:28,400
format complexity such as the namespace

00:01:25,439 --> 00:01:29,119
feature uh validation is cumbersome

00:01:28,400 --> 00:01:32,320
because

00:01:29,119 --> 00:01:34,159
basically between tags you have text and

00:01:32,320 --> 00:01:36,240
well when it spaces it's fine it's just

00:01:34,159 --> 00:01:38,479
invitation but when you have extra text

00:01:36,240 --> 00:01:40,000
is it valid or not you have to it's

00:01:38,479 --> 00:01:43,360
complicated to check

00:01:40,000 --> 00:01:43,680
that an xml document actually conforms

00:01:43,360 --> 00:01:47,520
to

00:01:43,680 --> 00:01:48,960
uh to some given formats

00:01:47,520 --> 00:01:51,040
there are tools to do that but they are

00:01:48,960 --> 00:01:54,640
even more complex so

00:01:51,040 --> 00:01:56,640
so well xml is something that is is good

00:01:54,640 --> 00:02:00,079
for some purposes

00:01:56,640 --> 00:02:02,960
but it has these defaults so another

00:02:00,079 --> 00:02:04,479
known widely known uh format is jason

00:02:02,960 --> 00:02:08,239
jason is actually very

00:02:04,479 --> 00:02:10,959
uh is also very easy to read and

00:02:08,239 --> 00:02:13,120
write for humans it's very easy to pass

00:02:10,959 --> 00:02:15,280
for machines

00:02:13,120 --> 00:02:16,480
there is a specification for that but it

00:02:15,280 --> 00:02:19,760
has

00:02:16,480 --> 00:02:21,520
again some shortcomings such as well

00:02:19,760 --> 00:02:23,840
this document is invalid because you

00:02:21,520 --> 00:02:27,280
don't you're not allowed to have a comma

00:02:23,840 --> 00:02:29,040
at this place and if you are if you have

00:02:27,280 --> 00:02:30,480
some experience writing this kind of

00:02:29,040 --> 00:02:33,599
document you know that

00:02:30,480 --> 00:02:35,280
having this comma is handy because you

00:02:33,599 --> 00:02:36,640
don't have when you add a new entry you

00:02:35,280 --> 00:02:40,319
don't have to add it there

00:02:36,640 --> 00:02:42,239
anyway it's handy uh json does not allow

00:02:40,319 --> 00:02:43,519
uh strict json because some

00:02:42,239 --> 00:02:46,560
implementations can be

00:02:43,519 --> 00:02:49,040
more permissive there's no provision to

00:02:46,560 --> 00:02:50,000
to write commands i'm sure there are

00:02:49,040 --> 00:02:52,800
other

00:02:50,000 --> 00:02:53,840
other problems so and there are several

00:02:52,800 --> 00:02:56,560
known gotchas

00:02:53,840 --> 00:02:58,879
so you may know that json comes from

00:02:56,560 --> 00:03:00,879
javascript and in javascript you can't

00:02:58,879 --> 00:03:02,959
the spec does not make a difference

00:03:00,879 --> 00:03:04,640
between integers and floats so basically

00:03:02,959 --> 00:03:06,959
everything is afloat

00:03:04,640 --> 00:03:08,319
and in so when you're writing numbers in

00:03:06,959 --> 00:03:11,360
json you don't know

00:03:08,319 --> 00:03:12,640
what's the precision that will uh

00:03:11,360 --> 00:03:14,239
that the implementation will use to

00:03:12,640 --> 00:03:16,000
represent your numbers so you're not

00:03:14,239 --> 00:03:18,480
sure that your numbers will

00:03:16,000 --> 00:03:20,560
be preserved basically it's a big it's a

00:03:18,480 --> 00:03:24,239
big issue

00:03:20,560 --> 00:03:27,040
another widely known format is ml

00:03:24,239 --> 00:03:28,239
so it looks actually it's a superset of

00:03:27,040 --> 00:03:31,360
json so every

00:03:28,239 --> 00:03:32,560
json document is a valid dml document

00:03:31,360 --> 00:03:35,840
[Music]

00:03:32,560 --> 00:03:36,640
it's easy enough to write but actually

00:03:35,840 --> 00:03:38,799
the format

00:03:36,640 --> 00:03:40,159
is very complex and adds a lot of

00:03:38,799 --> 00:03:43,280
certainties

00:03:40,159 --> 00:03:46,000
so it's not very

00:03:43,280 --> 00:03:46,879
depending on who you ask it's not very

00:03:46,000 --> 00:03:49,680
it's not a

00:03:46,879 --> 00:03:50,879
format that you can write things in and

00:03:49,680 --> 00:03:52,400
be confident in

00:03:50,879 --> 00:03:54,640
how it will be interpreted from the

00:03:52,400 --> 00:03:56,319
first look

00:03:54,640 --> 00:03:58,879
and yes you have several annoying

00:03:56,319 --> 00:04:01,920
glitches you don't strings are not

00:03:58,879 --> 00:04:04,000
there's no need for quotes so generally

00:04:01,920 --> 00:04:06,480
you write strings without quotes

00:04:04,000 --> 00:04:08,080
until the string you want to write is

00:04:06,480 --> 00:04:11,120
some magic keywords

00:04:08,080 --> 00:04:12,640
such as null which will not be a string

00:04:11,120 --> 00:04:13,599
it's going to be interpreted as a new

00:04:12,640 --> 00:04:17,600
value

00:04:13,599 --> 00:04:20,959
so it's not very nice

00:04:17,600 --> 00:04:24,400
so after this quick tour of

00:04:20,959 --> 00:04:27,680
readily known text formats and their

00:04:24,400 --> 00:04:30,479
defaults their issues

00:04:27,680 --> 00:04:31,040
there is thermal so it's a file format

00:04:30,479 --> 00:04:33,120
you have

00:04:31,040 --> 00:04:34,320
an example here it's a file format that

00:04:33,120 --> 00:04:38,479
is looks like

00:04:34,320 --> 00:04:40,960
it looks a lot like any files the older

00:04:38,479 --> 00:04:42,800
format that was mainly used on windows

00:04:40,960 --> 00:04:45,600
and some configuration

00:04:42,800 --> 00:04:46,000
mainly in configuration files so tamale

00:04:45,600 --> 00:04:48,880
is a

00:04:46,000 --> 00:04:50,000
has been created specifically for this

00:04:48,880 --> 00:04:53,280
use case

00:04:50,000 --> 00:04:55,680
it's easy to very easy to read and

00:04:53,280 --> 00:04:57,520
i mean it has obvious semantics so here

00:04:55,680 --> 00:05:00,639
you have a mapping a

00:04:57,520 --> 00:05:02,880
title is a is an entry that is a

00:05:00,639 --> 00:05:04,160
it has a value that is a string here you

00:05:02,880 --> 00:05:07,600
have

00:05:04,160 --> 00:05:10,880
first class dates that is

00:05:07,600 --> 00:05:13,840
it's a native type to this format

00:05:10,880 --> 00:05:14,320
it's mainly oriented as a mapping

00:05:13,840 --> 00:05:16,240
between

00:05:14,320 --> 00:05:19,280
keys that are strings and values that

00:05:16,240 --> 00:05:19,280
can be anything

00:05:19,600 --> 00:05:25,360
other mappings arrays and

00:05:22,639 --> 00:05:26,160
numbers and so on you have booleans

00:05:25,360 --> 00:05:28,560
anyway

00:05:26,160 --> 00:05:30,880
the format has a specification it's not

00:05:28,560 --> 00:05:34,160
formal but it's very precise and so it's

00:05:30,880 --> 00:05:36,479
uh it's quite easy to know if uh

00:05:34,160 --> 00:05:37,520
to read the spec and to actually know

00:05:36,479 --> 00:05:41,600
how to pass

00:05:37,520 --> 00:05:44,960
and the right documents

00:05:41,600 --> 00:05:47,919
and yeah so it has a lot of

00:05:44,960 --> 00:05:49,360
good uh good properties that make it a

00:05:47,919 --> 00:05:51,520
good candidate to write

00:05:49,360 --> 00:05:52,400
to use tamil as a file for your

00:05:51,520 --> 00:05:54,720
configuration

00:05:52,400 --> 00:05:57,440
the your software configuration and

00:05:54,720 --> 00:06:00,319
sometimes just to record data

00:05:57,440 --> 00:06:00,880
so that was for the thermal language i

00:06:00,319 --> 00:06:04,400
didn't

00:06:00,880 --> 00:06:06,240
uh invented it so this is the

00:06:04,400 --> 00:06:08,720
canonical home from the for for the

00:06:06,240 --> 00:06:12,800
project what i did on the other hand

00:06:08,720 --> 00:06:15,199
is uh ies sorry

00:06:12,800 --> 00:06:17,120
so i told you it's used for

00:06:15,199 --> 00:06:19,759
configuration files so

00:06:17,120 --> 00:06:20,639
in the real world most of the thermal

00:06:19,759 --> 00:06:24,319
uses i've

00:06:20,639 --> 00:06:27,199
i could find were package managers so

00:06:24,319 --> 00:06:28,800
the main one is i think is cargo the

00:06:27,199 --> 00:06:31,360
rust packet manager

00:06:28,800 --> 00:06:32,560
and other package managers for other

00:06:31,360 --> 00:06:34,560
language

00:06:32,560 --> 00:06:36,319
other languages also use this thermal

00:06:34,560 --> 00:06:39,759
and as you probably uh

00:06:36,319 --> 00:06:42,960
saw earlier today a layer uses the uh

00:06:39,759 --> 00:06:47,680
the thermal literal format

00:06:42,960 --> 00:06:52,080
as well um yeah

00:06:47,680 --> 00:06:54,639
and so a datum all it's uh it's an ada

00:06:52,080 --> 00:06:56,400
it's an ada library it's very uh very

00:06:54,639 --> 00:06:59,680
simple one to

00:06:56,400 --> 00:07:03,440
read i mean to parse and to to to create

00:06:59,680 --> 00:07:06,319
thermal documents from from scratch

00:07:03,440 --> 00:07:06,720
so i've written it actually for a layer

00:07:06,319 --> 00:07:09,360
because

00:07:06,720 --> 00:07:10,400
we were looking for a file formats that

00:07:09,360 --> 00:07:14,160
could be

00:07:10,400 --> 00:07:14,880
that would be easy to write to read and

00:07:14,160 --> 00:07:17,919
write for your

00:07:14,880 --> 00:07:20,479
humans and machines for to describe

00:07:17,919 --> 00:07:20,479
packages

00:07:20,639 --> 00:07:27,440
so this library has two very simple jobs

00:07:23,919 --> 00:07:29,919
first take a stream or

00:07:27,440 --> 00:07:30,960
a stream of bytes and parse it and

00:07:29,919 --> 00:07:34,240
convert it to

00:07:30,960 --> 00:07:38,479
in-memory data structures containers and

00:07:34,240 --> 00:07:41,440
the other job is to uh to turn this

00:07:38,479 --> 00:07:43,520
in-memories these containers back into a

00:07:41,440 --> 00:07:46,400
terminal document

00:07:43,520 --> 00:07:48,400
so there are two parts in the library to

00:07:46,400 --> 00:07:51,039
fulfill those jobs first you have

00:07:48,400 --> 00:07:52,240
the definition of the data structures

00:07:51,039 --> 00:07:54,240
the containers

00:07:52,240 --> 00:07:56,720
and the programs to actually do the

00:07:54,240 --> 00:07:59,120
parsing and the dumps

00:07:56,720 --> 00:08:00,240
and the project is on github so if you

00:07:59,120 --> 00:08:04,000
want to have a look

00:08:00,240 --> 00:08:08,960
this is the project's home

00:08:04,000 --> 00:08:08,960
so and this is where ah yeah okay

00:08:09,520 --> 00:08:14,319
oh it's good but the big deal so

00:08:12,560 --> 00:08:16,160
the first part is the data structures

00:08:14,319 --> 00:08:18,800
the containers it's very simple

00:08:16,160 --> 00:08:20,160
you have two types so terminal value and

00:08:18,800 --> 00:08:22,879
any value type

00:08:20,160 --> 00:08:24,080
so thermal value is what could be any

00:08:22,879 --> 00:08:26,000
value in a

00:08:24,080 --> 00:08:28,240
in a thermal document it could be a

00:08:26,000 --> 00:08:30,080
table a mapping between key and values

00:08:28,240 --> 00:08:31,280
it could be an integer a string or any

00:08:30,080 --> 00:08:34,479
other data type

00:08:31,280 --> 00:08:37,039
allowed by the uh thomas format

00:08:34,479 --> 00:08:37,839
and you have this enumerated type that

00:08:37,039 --> 00:08:40,959
describes

00:08:37,839 --> 00:08:44,000
what's behind a thermal value

00:08:40,959 --> 00:08:45,760
so is it a a table an array a string a

00:08:44,000 --> 00:08:47,120
date an integer boolean

00:08:45,760 --> 00:08:48,959
it could be anything and you have this

00:08:47,120 --> 00:08:49,440
function kind that takes an existing

00:08:48,959 --> 00:08:53,279
value

00:08:49,440 --> 00:08:56,640
and returns what is behind this uh

00:08:53,279 --> 00:08:59,360
this value all right so

00:08:56,640 --> 00:09:00,160
you have naturally functions to create

00:08:59,360 --> 00:09:02,720
values

00:09:00,160 --> 00:09:04,480
so if you want to create a thermal value

00:09:02,720 --> 00:09:05,839
that is a boolean you call the create

00:09:04,480 --> 00:09:08,880
boolean

00:09:05,839 --> 00:09:10,000
function that takes the actual value you

00:09:08,880 --> 00:09:12,399
want to store inside

00:09:10,000 --> 00:09:13,839
a terminal document you have the same

00:09:12,399 --> 00:09:16,720
for integer tables

00:09:13,839 --> 00:09:18,320
and so on and also functions to add an

00:09:16,720 --> 00:09:20,160
entry in a mapping

00:09:18,320 --> 00:09:22,000
all sorts of operations you want you

00:09:20,160 --> 00:09:25,680
would like to do with the

00:09:22,000 --> 00:09:27,680
containers so that was to create values

00:09:25,680 --> 00:09:30,240
and you have the corresponding other

00:09:27,680 --> 00:09:33,519
operations to actually read the values

00:09:30,240 --> 00:09:34,560
behind the the thermal document so here

00:09:33,519 --> 00:09:37,040
the as boolean

00:09:34,560 --> 00:09:38,320
function takes the value and assuming

00:09:37,040 --> 00:09:40,480
that this value

00:09:38,320 --> 00:09:44,240
holds a boolean a thermal boolean it

00:09:40,480 --> 00:09:44,240
returns the corresponding awn

00:09:45,760 --> 00:09:52,399
oh it's a precondition so otherwise you

00:09:47,920 --> 00:09:52,399
have an assertion error let's say

00:09:52,640 --> 00:09:56,160
yes uh it's uh as i said earlier in the

00:09:55,600 --> 00:09:59,440
slides

00:09:56,160 --> 00:10:01,760
it's an ada 2012 library so

00:09:59,440 --> 00:10:04,000
we we can use preconditions there to

00:10:01,760 --> 00:10:05,839
actually be specific about what

00:10:04,000 --> 00:10:07,440
are the requirements for each function

00:10:05,839 --> 00:10:10,640
so it should be quite natural

00:10:07,440 --> 00:10:12,000
natural well this library does not do

00:10:10,640 --> 00:10:16,320
anything complex so

00:10:12,000 --> 00:10:16,320
it's supposed to be very easy to use

00:10:16,880 --> 00:10:19,839
yes

00:10:28,880 --> 00:10:34,800
um because um

00:10:32,320 --> 00:10:34,800
that would

00:10:37,200 --> 00:10:40,880
yes well it's a personal opinion but i

00:10:39,920 --> 00:10:44,959
have the feeling that

00:10:40,880 --> 00:10:47,760
having multiple constructors

00:10:44,959 --> 00:10:48,320
the only way as a human to understand

00:10:47,760 --> 00:10:50,399
which

00:10:48,320 --> 00:10:51,920
so you are talking about overloads

00:10:50,399 --> 00:10:56,160
having multiple functions

00:10:51,920 --> 00:10:56,160
having the same anyway sorry

00:10:57,279 --> 00:11:04,399
they do return the same type but they

00:11:01,120 --> 00:11:05,120
i can because they're yes but when you

00:11:04,399 --> 00:11:07,519
have

00:11:05,120 --> 00:11:09,920
what the thing is that when you have you

00:11:07,519 --> 00:11:15,839
you because of the shape of

00:11:09,920 --> 00:11:15,839
of this uh wait let me

00:11:26,839 --> 00:11:32,560
actually

00:11:29,760 --> 00:11:34,079
that works for the atomic data types

00:11:32,560 --> 00:11:36,240
that doesn't work for

00:11:34,079 --> 00:11:37,920
arrays and tables because you have

00:11:36,240 --> 00:11:41,440
control constructors

00:11:37,920 --> 00:11:43,360
that just create empty containers

00:11:41,440 --> 00:11:45,040
so for tables and arrays that doesn't

00:11:43,360 --> 00:11:48,079
work

00:11:45,040 --> 00:11:51,279
indeed we it could work for uh

00:11:48,079 --> 00:11:56,560
for the inter the atoms so booleans

00:11:51,279 --> 00:11:58,959
strings integers dates and so on but

00:11:56,560 --> 00:12:00,560
as a feeling that if you do that if you

00:11:58,959 --> 00:12:03,600
rely too much on overloading

00:12:00,560 --> 00:12:06,079
the code ends up less readable because

00:12:03,600 --> 00:12:07,839
as a reader you have to i mean if you

00:12:06,079 --> 00:12:09,519
have create integer and provide it

00:12:07,839 --> 00:12:10,000
directly on integra literal it's quite

00:12:09,519 --> 00:12:12,959
obvious what

00:12:10,000 --> 00:12:14,399
he's doing but if you have if actually

00:12:12,959 --> 00:12:16,800
instead of 42 here

00:12:14,399 --> 00:12:17,839
you have other other calls other

00:12:16,800 --> 00:12:20,560
functions other

00:12:17,839 --> 00:12:22,160
something anything more complex your

00:12:20,560 --> 00:12:23,680
brain has to work a little bit more a

00:12:22,160 --> 00:12:24,320
little bit more to know what it's doing

00:12:23,680 --> 00:12:27,519
actually

00:12:24,320 --> 00:12:29,200
you can name the parameter but that's

00:12:27,519 --> 00:12:31,120
right

00:12:29,200 --> 00:12:33,519
and then you have to rely on actually

00:12:31,120 --> 00:12:35,440
coding practices to uh to make the thing

00:12:33,519 --> 00:12:38,079
the less the more understandable

00:12:35,440 --> 00:12:40,639
possible yes

00:12:38,079 --> 00:12:41,839
anyway so this is what the using the api

00:12:40,639 --> 00:12:44,959
looks like to build

00:12:41,839 --> 00:12:46,959
uh to build the values so it's quite

00:12:44,959 --> 00:12:48,160
straightforward here we create an

00:12:46,959 --> 00:12:50,240
integer a string

00:12:48,160 --> 00:12:51,519
and then an empty table and then we fill

00:12:50,240 --> 00:12:53,680
the table with

00:12:51,519 --> 00:12:56,160
the values that we just created before

00:12:53,680 --> 00:12:58,720
and so if you're familiar with json

00:12:56,160 --> 00:13:00,320
by when when the execution reaches the

00:12:58,720 --> 00:13:02,639
command

00:13:00,320 --> 00:13:03,600
you have empty a document that is

00:13:02,639 --> 00:13:07,279
equivalent to this

00:13:03,600 --> 00:13:08,000
json document and here you have a small

00:13:07,279 --> 00:13:12,399
example of

00:13:08,000 --> 00:13:13,839
what converting thermal values back to a

00:13:12,399 --> 00:13:17,839
native ada

00:13:13,839 --> 00:13:19,519
values looks like so that was it with

00:13:17,839 --> 00:13:21,839
with that you can create thermal

00:13:19,519 --> 00:13:24,079
documents programmatically without

00:13:21,839 --> 00:13:29,200
passing any any table

00:13:24,079 --> 00:13:29,200
but then so

00:13:29,760 --> 00:13:34,079
so yes first still in the in the thermal

00:13:33,120 --> 00:13:35,680
package it's

00:13:34,079 --> 00:13:37,519
the main package that define contains

00:13:35,680 --> 00:13:38,800
containers and so on you have two

00:13:37,519 --> 00:13:43,120
functions to actually

00:13:38,800 --> 00:13:46,839
convert convert a string to a terminal

00:13:43,120 --> 00:13:50,000
a thermal value and any other way

00:13:46,839 --> 00:13:51,279
so well it's it's not directly returning

00:13:50,000 --> 00:13:53,440
a terminal value because

00:13:51,279 --> 00:13:55,360
uh when there is a passing error you

00:13:53,440 --> 00:13:57,600
want to actually return an error

00:13:55,360 --> 00:13:58,399
i uh i decided not to use an exception

00:13:57,600 --> 00:14:03,040
because

00:13:58,399 --> 00:14:05,760
uh because of various practical uh

00:14:03,040 --> 00:14:07,040
considerations such as uh the ada

00:14:05,760 --> 00:14:10,079
standard does not

00:14:07,040 --> 00:14:12,160
guarantee that uh the message that you

00:14:10,079 --> 00:14:13,199
associate to an exception will be

00:14:12,160 --> 00:14:15,040
preserved i mean

00:14:13,199 --> 00:14:16,399
you don't have any guarantees regarding

00:14:15,040 --> 00:14:19,519
the length

00:14:16,399 --> 00:14:20,240
so for error messages it's not it's not

00:14:19,519 --> 00:14:24,079
great

00:14:20,240 --> 00:14:26,320
and also anyway

00:14:24,079 --> 00:14:27,120
also uh in the the read results also

00:14:26,320 --> 00:14:30,320
contains

00:14:27,120 --> 00:14:32,079
the source location of the error i mean

00:14:30,320 --> 00:14:33,360
it could be written it could be in text

00:14:32,079 --> 00:14:36,720
but i prefer to keep

00:14:33,360 --> 00:14:39,040
to i prefer to keep it as numbers

00:14:36,720 --> 00:14:41,199
anyway so that's quite straightforward

00:14:39,040 --> 00:14:43,279
to use

00:14:41,199 --> 00:14:44,399
there is another package that actually

00:14:43,279 --> 00:14:46,160
allows you to

00:14:44,399 --> 00:14:48,240
to do this the same but instead of

00:14:46,160 --> 00:14:48,880
taking instead of dealing with thermal

00:14:48,240 --> 00:14:52,160
documents

00:14:48,880 --> 00:14:55,360
strings in memory it goes

00:14:52,160 --> 00:14:55,360
goes to the file system

00:14:55,519 --> 00:14:59,920
and finally if your tamil documents you

00:14:58,160 --> 00:15:02,399
don't want to read it

00:14:59,920 --> 00:15:03,440
from memory or from a file for instance

00:15:02,399 --> 00:15:05,760
if you want to

00:15:03,440 --> 00:15:06,880
get it from the network or from a

00:15:05,760 --> 00:15:10,320
compressed

00:15:06,880 --> 00:15:14,000
file well there is a there are generic

00:15:10,320 --> 00:15:17,680
subprograms that just abstract uh the uh

00:15:14,000 --> 00:15:20,240
stream of primitives to uh

00:15:17,680 --> 00:15:21,360
to read or write the the thermal file to

00:15:20,240 --> 00:15:24,880
and from

00:15:21,360 --> 00:15:28,480
an abstraction and that's it

00:15:24,880 --> 00:15:31,440
so uh again here is uh

00:15:28,480 --> 00:15:33,839
the project home so this uh this library

00:15:31,440 --> 00:15:36,320
is already available in a layer

00:15:33,839 --> 00:15:38,639
fortunately because a layer requires it

00:15:36,320 --> 00:15:40,800
so it would be a shame if

00:15:38,639 --> 00:15:42,720
if it wasn't registered there uh there

00:15:40,800 --> 00:15:45,199
is only one release it's a very

00:15:42,720 --> 00:15:46,800
young project and as far as i'm aware

00:15:45,199 --> 00:15:49,199
the only serious use of

00:15:46,800 --> 00:15:50,320
this library is a layer the israeli

00:15:49,199 --> 00:15:54,000
project

00:15:50,320 --> 00:15:54,480
but still it's uh the first release is i

00:15:54,000 --> 00:15:57,199
mean

00:15:54,480 --> 00:15:58,480
the api probably won't won't move much

00:15:57,199 --> 00:16:00,399
except if i rename

00:15:58,480 --> 00:16:01,680
constructors but uh that's another

00:16:00,399 --> 00:16:03,759
another debate

00:16:01,680 --> 00:16:07,360
and so you're welcome to have a look and

00:16:03,759 --> 00:16:08,959
uh if you want contribute

00:16:07,360 --> 00:16:11,279
thank you and if you have questions i

00:16:08,959 --> 00:16:11,279
will be

00:16:14,720 --> 00:16:20,079
um just a remark there is another

00:16:18,000 --> 00:16:21,440
benefit of turmoil that you didn't

00:16:20,079 --> 00:16:25,600
mention

00:16:21,440 --> 00:16:27,839
is that you have no closing bracket

00:16:25,600 --> 00:16:29,519
now it's very important because if you

00:16:27,839 --> 00:16:32,800
want to accumulate

00:16:29,519 --> 00:16:35,199
results in a file you cannot do that

00:16:32,800 --> 00:16:37,920
in yemo because when you've closed the

00:16:35,199 --> 00:16:41,279
bracket there is nothing you can do

00:16:37,920 --> 00:16:44,480
after that uh take a tool like

00:16:41,279 --> 00:16:46,880
an example a control which

00:16:44,480 --> 00:16:48,959
by the way can output it can have its

00:16:46,880 --> 00:16:52,240
output in terminal format

00:16:48,959 --> 00:16:54,800
then you can run it several times and

00:16:52,240 --> 00:16:55,279
accumulate the result in the same file

00:16:54,800 --> 00:16:59,199
yes

00:16:55,279 --> 00:17:02,079
the the text con concatenation

00:16:59,199 --> 00:17:03,440
also works from content a valid document

00:17:02,079 --> 00:17:06,160
concatenation

00:17:03,440 --> 00:17:08,400
yes absolutely and that's something you

00:17:06,160 --> 00:17:10,319
cannot do with the ammo

00:17:08,400 --> 00:17:11,679
yes that's right well that works from

00:17:10,319 --> 00:17:15,039
the for the

00:17:11,679 --> 00:17:17,600
um for the maps actually

00:17:15,039 --> 00:17:18,559
it depends i mean it works for the top

00:17:17,600 --> 00:17:20,640
level document

00:17:18,559 --> 00:17:22,400
for the top level mapping but you can

00:17:20,640 --> 00:17:25,280
actually can have nested

00:17:22,400 --> 00:17:26,319
you have a syntax to uh to create nested

00:17:25,280 --> 00:17:28,559
tables but

00:17:26,319 --> 00:17:29,760
well that doesn't matter another thing i

00:17:28,559 --> 00:17:32,320
didn't mention about the

00:17:29,760 --> 00:17:34,000
this format is that it's specified

00:17:32,320 --> 00:17:34,960
actually it's not a text format it's a

00:17:34,000 --> 00:17:36,799
binary format

00:17:34,960 --> 00:17:38,000
in the sense that it specifies that all

00:17:36,799 --> 00:17:40,559
documents must be

00:17:38,000 --> 00:17:42,640
but you must use utf-8 so you don't have

00:17:40,559 --> 00:17:46,640
to worry about encodings when you use

00:17:42,640 --> 00:17:49,280
this library

00:17:46,640 --> 00:17:51,200
more or less because when you provide it

00:17:49,280 --> 00:17:54,640
a string it's assuming that it's

00:17:51,200 --> 00:17:54,640
available eight string

00:17:54,880 --> 00:17:57,600
other questions

00:17:59,760 --> 00:18:03,520
yes are you also the author of cnn

00:18:02,480 --> 00:18:07,440
called jason

00:18:03,520 --> 00:18:09,440
or did you just take some

00:18:07,440 --> 00:18:11,280
inspirations from it i took some

00:18:09,440 --> 00:18:14,200
inspiration from it actually i'm

00:18:11,280 --> 00:18:15,840
one of the main current maintainers of

00:18:14,200 --> 00:18:19,440
magnetical.json

00:18:15,840 --> 00:18:22,320
uh yeah i think the api uh

00:18:19,440 --> 00:18:24,880
some parts of the apr were easy to use

00:18:22,320 --> 00:18:24,880
yes yes

00:18:24,960 --> 00:18:30,240
i didn't yes actually the um

00:18:28,160 --> 00:18:32,160
the part where when you pass it doesn't

00:18:30,240 --> 00:18:34,480
raise an exception but returns

00:18:32,160 --> 00:18:35,679
uh a structured error a first-class

00:18:34,480 --> 00:18:37,760
value error

00:18:35,679 --> 00:18:40,720
it's the part i contributed to that

00:18:37,760 --> 00:18:40,720
called the json so

00:18:41,440 --> 00:18:57,520

YouTube URL: https://www.youtube.com/watch?v=ko6YKN_LqsQ


