Title: Reducing OpenJDK Java Garbage Collection times with stack allocation
Publication date: 2020-07-12
Playlist: FOSDEM 2020
Description: 
	by Nikola Grcevski

At: FOSDEM 2020
https://video.fosdem.org/2020/H.1302/reducing_gc_times.webm

In this talk we'll explore ways that the JVM can reduce the object allocation rate of Java programs automatically by performing stack allocation of objects that are known to be local to a method, or in compiler terms non-escaping. The discussion is focused on employing the escape analysis optimization in the OpenJDK Hotspot C2 compiler to determine which Java objects can be stack allocated, and how this optimization can reduce pressure on the Java JVM garbage collectors.


We'll show some results on how various real world applications can benefit from such optimizations and describe the methodology of how we prototyped this in OpenJDK. Our work is only in prototype state at this moment and we are looking for more data to understand how broadly applicable this optimizations is. This work wouldn't be possible without free open source access to Java.

Room: H.1302 (Depage)
Scheduled start: 2020-02-01 14:20:00
Captions: 
	00:00:05,120 --> 00:00:08,240
hi everyone this

00:00:06,080 --> 00:00:11,200
talk is going to be a compiler talk

00:00:08,240 --> 00:00:13,599
about the c2 compiler in opengdk

00:00:11,200 --> 00:00:14,880
specifically uh new optimization that we

00:00:13,599 --> 00:00:18,160
worked on

00:00:14,880 --> 00:00:18,160
microsoft surprisingly but

00:00:18,240 --> 00:00:24,080
so called stack allocation

00:00:21,520 --> 00:00:25,599
in this particular talk i'll start with

00:00:24,080 --> 00:00:28,960
quicker introduction what

00:00:25,599 --> 00:00:32,399
currently exists in cosmos c2

00:00:28,960 --> 00:00:33,440
extend with the work we did um in our

00:00:32,399 --> 00:00:35,760
engineering group

00:00:33,440 --> 00:00:37,600
uh then show some results on popular

00:00:35,760 --> 00:00:38,559
benchmarks and hopefully kind of finish

00:00:37,600 --> 00:00:40,559
off with

00:00:38,559 --> 00:00:41,760
the stuff we still need to do so still

00:00:40,559 --> 00:00:44,239
very much your work in progress we

00:00:41,760 --> 00:00:47,440
haven't submitted a patch to the uh

00:00:44,239 --> 00:00:49,120
open jdk mailing list compiler list

00:00:47,440 --> 00:00:50,480
uh but it's just a warning i mean it

00:00:49,120 --> 00:00:51,760
might be boring for a bunch of people

00:00:50,480 --> 00:00:53,920
this is going to be a bunch of compiler

00:00:51,760 --> 00:00:57,600
jargon here i can't work around that

00:00:53,920 --> 00:01:00,320
unfortunately so

00:00:57,600 --> 00:01:02,719
stack allocation so the main motivation

00:01:00,320 --> 00:01:06,240
was to alleviate some of the gc pressure

00:01:02,719 --> 00:01:07,520
um it was originally brought to us um we

00:01:06,240 --> 00:01:10,560
started working on this by kirk

00:01:07,520 --> 00:01:14,000
pepperdine and some of you may know him

00:01:10,560 --> 00:01:16,799
he's big on gc tuning in the java world

00:01:14,000 --> 00:01:18,880
and he often would say as we're looking

00:01:16,799 --> 00:01:21,040
at some spark workloads to improve them

00:01:18,880 --> 00:01:23,439
and say on these all occasions scale

00:01:21,040 --> 00:01:24,320
i'll give the gc seizures and so on so

00:01:23,439 --> 00:01:27,439
it's really bad

00:01:24,320 --> 00:01:29,280
you guys should try to fix this so um

00:01:27,439 --> 00:01:30,799
so how we actually going to try doing

00:01:29,280 --> 00:01:31,840
this is by

00:01:30,799 --> 00:01:34,000
saying we're going to eliminate the

00:01:31,840 --> 00:01:35,360
location but not quite we're going to

00:01:34,000 --> 00:01:37,360
allocate on the stack

00:01:35,360 --> 00:01:39,840
frame rather than on the heap it's a

00:01:37,360 --> 00:01:40,560
known optimization compilers just

00:01:39,840 --> 00:01:43,920
somewhat not

00:01:40,560 --> 00:01:47,680
actually being done in c2 yet

00:01:43,920 --> 00:01:49,600
so um so when can we do this

00:01:47,680 --> 00:01:51,920
is when we say the object does not

00:01:49,600 --> 00:01:54,479
escape the current method context

00:01:51,920 --> 00:01:55,520
and typically objects escapes with

00:01:54,479 --> 00:01:57,600
returns

00:01:55,520 --> 00:02:00,159
calls to methods or maybe stored into

00:01:57,600 --> 00:02:02,240
fields passed around so

00:02:00,159 --> 00:02:04,240
the places where we can do it places we

00:02:02,240 --> 00:02:06,640
can't so here's an example

00:02:04,240 --> 00:02:07,360
uh we have a very simple java program

00:02:06,640 --> 00:02:10,640
here

00:02:07,360 --> 00:02:12,080
with three allocations we got box two

00:02:10,640 --> 00:02:13,840
integers

00:02:12,080 --> 00:02:16,000
and then we finally return another one

00:02:13,840 --> 00:02:17,680
integer is immutable class so there's

00:02:16,000 --> 00:02:18,480
two additions create a new object and

00:02:17,680 --> 00:02:22,239
that's bob

00:02:18,480 --> 00:02:23,840
returned so

00:02:22,239 --> 00:02:26,640
first two objects do not escape the

00:02:23,840 --> 00:02:29,120
method but the last one does

00:02:26,640 --> 00:02:30,560
and the way that we do tell which ones

00:02:29,120 --> 00:02:33,280
do escape which was down

00:02:30,560 --> 00:02:36,160
is by this compiler back-end pass called

00:02:33,280 --> 00:02:38,959
escape analysis

00:02:36,160 --> 00:02:40,800
so a bit more about escape analysis now

00:02:38,959 --> 00:02:42,640
escape analysis was introduced by this

00:02:40,800 --> 00:02:45,760
paper

00:02:42,640 --> 00:02:49,360
it's it was introduced by

00:02:45,760 --> 00:02:50,879
ibm tj watson research a while back and

00:02:49,360 --> 00:02:52,000
essentially they had in a paper two

00:02:50,879 --> 00:02:52,640
different kind of optimizations

00:02:52,000 --> 00:02:56,000
described

00:02:52,640 --> 00:02:58,000
flow sensitive one and flow insensitive

00:02:56,000 --> 00:02:59,840
uh the one that's implemented c2 is the

00:02:58,000 --> 00:03:01,599
flow insensitive version of it and it's

00:02:59,840 --> 00:03:03,840
the right choice actually the

00:03:01,599 --> 00:03:05,280
uh the paper describes both of them but

00:03:03,840 --> 00:03:07,440
it actually shows that

00:03:05,280 --> 00:03:08,400
they do similarly well and the flow is

00:03:07,440 --> 00:03:10,800
sensitive is much

00:03:08,400 --> 00:03:12,640
easier to implement maintain and less

00:03:10,800 --> 00:03:14,480
memory intensive

00:03:12,640 --> 00:03:16,080
uh currently it's used in c2 for the

00:03:14,480 --> 00:03:19,440
following two purposes

00:03:16,080 --> 00:03:21,360
so we use it for monitor elimination

00:03:19,440 --> 00:03:23,200
which means if the objects are proven

00:03:21,360 --> 00:03:25,200
that they're not escaping therefore they

00:03:23,200 --> 00:03:27,519
can only be seen by one thread

00:03:25,200 --> 00:03:29,200
so we can eliminate the monitor enter

00:03:27,519 --> 00:03:29,840
and monitor exit operations on these

00:03:29,200 --> 00:03:32,560
objects

00:03:29,840 --> 00:03:34,159
so no synchronization on them so say

00:03:32,560 --> 00:03:35,040
you're using a string buffer instead of

00:03:34,159 --> 00:03:38,239
string builder

00:03:35,040 --> 00:03:39,599
well this will help the second one which

00:03:38,239 --> 00:03:41,680
was interesting for us

00:03:39,599 --> 00:03:43,599
it was the scale replacement so this is

00:03:41,680 --> 00:03:45,680
the form of an optimization that we kind

00:03:43,599 --> 00:03:48,239
of extended

00:03:45,680 --> 00:03:49,840
so scalar replacement goes by the same

00:03:48,239 --> 00:03:51,840
sort of concept

00:03:49,840 --> 00:03:53,920
you take out the original object you

00:03:51,840 --> 00:03:55,760
break it apart into the individual parts

00:03:53,920 --> 00:03:56,480
so you actually make away the actual

00:03:55,760 --> 00:04:00,799
allocation

00:03:56,480 --> 00:04:03,439
so breaking up with the object

00:04:00,799 --> 00:04:04,159
turns it into a normal autos or local

00:04:03,439 --> 00:04:06,319
variables that's

00:04:04,159 --> 00:04:07,840
it on the stack therefore no heap

00:04:06,319 --> 00:04:10,480
allocation there

00:04:07,840 --> 00:04:10,480
okay so

00:04:11,040 --> 00:04:13,920
here is another example slightly

00:04:12,720 --> 00:04:15,200
different than before but maybe you'll

00:04:13,920 --> 00:04:16,880
notice subtle difference people that

00:04:15,200 --> 00:04:18,479
know this stuff but

00:04:16,880 --> 00:04:20,799
we are doing the three allocation as

00:04:18,479 --> 00:04:21,759
before now let's move on to the next

00:04:20,799 --> 00:04:23,840
step

00:04:21,759 --> 00:04:26,000
and the scalar replacement will come in

00:04:23,840 --> 00:04:27,600
and actually turn it into this

00:04:26,000 --> 00:04:29,280
this is what the final program would

00:04:27,600 --> 00:04:31,120
actually behave like

00:04:29,280 --> 00:04:32,560
the integer field within the integer

00:04:31,120 --> 00:04:34,320
object the primitive data type was

00:04:32,560 --> 00:04:35,280
extracted and actually stored as a local

00:04:34,320 --> 00:04:39,520
variable on the

00:04:35,280 --> 00:04:41,520
stack now when can we do this

00:04:39,520 --> 00:04:43,919
mainly when we actually don't need the

00:04:41,520 --> 00:04:46,560
original form of the object anymore

00:04:43,919 --> 00:04:50,800
so when we can actually prove that the

00:04:46,560 --> 00:04:50,800
object as a whole integer is not needed

00:04:50,880 --> 00:04:55,040
now let's see some of the limitations

00:04:53,440 --> 00:04:57,840
with scale replacement

00:04:55,040 --> 00:04:59,520
so when we looked at the code there's

00:04:57,840 --> 00:05:01,520
number of reasons why skill replacement

00:04:59,520 --> 00:05:03,199
can't fail but when we did the analysis

00:05:01,520 --> 00:05:05,039
and ran bunch of benchmarks and work

00:05:03,199 --> 00:05:07,680
clouds to see what was the main cause of

00:05:05,039 --> 00:05:10,800
scale replacement failing and cosplay c2

00:05:07,680 --> 00:05:13,680
is introduction of control flow so

00:05:10,800 --> 00:05:14,240
namely assist compiler talk again like

00:05:13,680 --> 00:05:16,560
phi

00:05:14,240 --> 00:05:17,680
over here it's we have the two

00:05:16,560 --> 00:05:20,080
definitions

00:05:17,680 --> 00:05:21,199
on two sides of the control flow one is

00:05:20,080 --> 00:05:23,600
the object

00:05:21,199 --> 00:05:25,039
being instantiated this new class object

00:05:23,600 --> 00:05:26,479
here my class

00:05:25,039 --> 00:05:29,039
and the other side we're pulling it out

00:05:26,479 --> 00:05:29,600
of an array now coming down to the last

00:05:29,039 --> 00:05:32,720
return

00:05:29,600 --> 00:05:34,880
object.x now which one

00:05:32,720 --> 00:05:36,800
do we have in our hands therefore we

00:05:34,880 --> 00:05:38,880
need the original shape of the object we

00:05:36,800 --> 00:05:40,960
need to do a field load of that object

00:05:38,880 --> 00:05:42,479
because on one side may be scalably

00:05:40,960 --> 00:05:44,160
placed but the other side will need a

00:05:42,479 --> 00:05:46,080
full bloody object coming from that

00:05:44,160 --> 00:05:49,600
array

00:05:46,080 --> 00:05:51,759
so how common is this issue

00:05:49,600 --> 00:05:52,960
so i'm back to my original example so

00:05:51,759 --> 00:05:54,720
the side

00:05:52,960 --> 00:05:56,720
that we have on the left here we can

00:05:54,720 --> 00:05:58,319
scale or replace that

00:05:56,720 --> 00:06:00,000
but that's not what typically happens

00:05:58,319 --> 00:06:02,560
with out-of-boxing

00:06:00,000 --> 00:06:03,919
the side on the right is that c2 is

00:06:02,560 --> 00:06:06,479
unable to handle

00:06:03,919 --> 00:06:08,319
mainly because integer value off which

00:06:06,479 --> 00:06:09,120
is what actually happens when you out of

00:06:08,319 --> 00:06:11,600
box

00:06:09,120 --> 00:06:13,280
a primitive data type internally has the

00:06:11,600 --> 00:06:14,479
exact same pattern i showed on the

00:06:13,280 --> 00:06:16,720
previous slide

00:06:14,479 --> 00:06:18,639
it has a compare actually with two

00:06:16,720 --> 00:06:23,120
ranges minus 1 to

00:06:18,639 --> 00:06:25,600
28 to 127 which is also configurable

00:06:23,120 --> 00:06:27,120
if if the values fall in this range

00:06:25,600 --> 00:06:30,319
you're getting

00:06:27,120 --> 00:06:31,440
a precached integer object from a static

00:06:30,319 --> 00:06:33,840
array

00:06:31,440 --> 00:06:35,440
which is a poor man's version of

00:06:33,840 --> 00:06:37,440
elimination of allocations

00:06:35,440 --> 00:06:39,120
but it does actually work for that range

00:06:37,440 --> 00:06:41,039
of objects but every time you go above

00:06:39,120 --> 00:06:43,039
that range or beneath that range

00:06:41,039 --> 00:06:45,600
you get a now stack actually heap

00:06:43,039 --> 00:06:48,479
allocated objects

00:06:45,600 --> 00:06:50,000
so can we make this work so there's

00:06:48,479 --> 00:06:51,680
compiler optimizations that could

00:06:50,000 --> 00:06:52,479
potentially make this little example

00:06:51,680 --> 00:06:54,880
here work

00:06:52,479 --> 00:06:56,800
however it has some drawbacks one

00:06:54,880 --> 00:06:59,919
typical way we could do this

00:06:56,800 --> 00:07:01,759
by actually cloning optimizations in the

00:06:59,919 --> 00:07:02,240
back end optimizations could potentially

00:07:01,759 --> 00:07:04,080
say

00:07:02,240 --> 00:07:05,599
well we have a condition we can we go

00:07:04,080 --> 00:07:07,759
either way so why don't we just

00:07:05,599 --> 00:07:10,160
specialize the method body for this side

00:07:07,759 --> 00:07:11,199
from that side but let's say you have

00:07:10,160 --> 00:07:13,120
another branch

00:07:11,199 --> 00:07:15,759
then it gets involved it becomes

00:07:13,120 --> 00:07:18,080
exponential so code grows insanely so

00:07:15,759 --> 00:07:20,479
it's not actually very useful other ways

00:07:18,080 --> 00:07:22,560
you can do that is maybe by code motion

00:07:20,479 --> 00:07:24,560
but then you're stuck with side effects

00:07:22,560 --> 00:07:25,840
let's say the array we're pulling out

00:07:24,560 --> 00:07:28,400
that object

00:07:25,840 --> 00:07:29,280
this object was a null object so can you

00:07:28,400 --> 00:07:30,880
actually

00:07:29,280 --> 00:07:32,960
what if you have to throw the null point

00:07:30,880 --> 00:07:34,639
exception don't be on the wrong line so

00:07:32,960 --> 00:07:36,560
these kind of optimizations do have

00:07:34,639 --> 00:07:38,800
limitations in how

00:07:36,560 --> 00:07:40,960
quick how actually often can we apply

00:07:38,800 --> 00:07:40,960
them

00:07:41,039 --> 00:07:45,599
now this is what was we actually came up

00:07:44,240 --> 00:07:48,479
with say well

00:07:45,599 --> 00:07:50,160
we don't actually have to scale or place

00:07:48,479 --> 00:07:52,160
it what if we actually allocate it but

00:07:50,160 --> 00:07:55,360
actually allocate on the stack

00:07:52,160 --> 00:07:58,800
so the object shape is preserved as it

00:07:55,360 --> 00:08:00,240
typically was and

00:07:58,800 --> 00:08:01,680
it just lives on the stack just like the

00:08:00,240 --> 00:08:03,599
primitive which is a little bit of extra

00:08:01,680 --> 00:08:04,240
stuff it has flags field has a class

00:08:03,599 --> 00:08:05,840
pointer

00:08:04,240 --> 00:08:08,000
everything you normally expect from an

00:08:05,840 --> 00:08:09,520
object now

00:08:08,000 --> 00:08:11,120
is this useful well yeah let's consider

00:08:09,520 --> 00:08:12,000
this example like you have this loop

00:08:11,120 --> 00:08:13,680
over here

00:08:12,000 --> 00:08:15,520
i mean i cleverly returned the primitive

00:08:13,680 --> 00:08:15,919
data type so my object doesn't escape

00:08:15,520 --> 00:08:18,560
but

00:08:15,919 --> 00:08:20,240
if this was the case here this loop will

00:08:18,560 --> 00:08:20,720
keep generating new objects every time

00:08:20,240 --> 00:08:22,879
around

00:08:20,720 --> 00:08:24,720
integer is immutable therefore new

00:08:22,879 --> 00:08:26,479
object through for every new addition

00:08:24,720 --> 00:08:30,960
you do

00:08:26,479 --> 00:08:33,599
so stack allocation

00:08:30,960 --> 00:08:35,360
will it work on previous example yeah

00:08:33,599 --> 00:08:36,240
because on both sides now we actually

00:08:35,360 --> 00:08:39,039
have a

00:08:36,240 --> 00:08:41,039
plain on java object so the object.x

00:08:39,039 --> 00:08:43,519
field load the get field that happens

00:08:41,039 --> 00:08:45,600
there has no problem

00:08:43,519 --> 00:08:47,519
existing from one side it will read from

00:08:45,600 --> 00:08:49,200
the stack on the other side it will read

00:08:47,519 --> 00:08:51,519
from the object we got from the static

00:08:49,200 --> 00:08:51,519
array

00:08:51,760 --> 00:08:54,959
all right so how do we implement this in

00:08:53,279 --> 00:08:56,160
c2 come to the second part of the

00:08:54,959 --> 00:08:59,279
presentation

00:08:56,160 --> 00:09:02,160
um so charlie gracie and myself

00:08:59,279 --> 00:09:02,800
inspired by the words of kirk started

00:09:02,160 --> 00:09:04,399
looking at

00:09:02,800 --> 00:09:06,720
into implementing this with stack

00:09:04,399 --> 00:09:10,160
allocation we had to modify

00:09:06,720 --> 00:09:12,720
escape analysis in c2 to recognize cases

00:09:10,160 --> 00:09:15,120
where we can safely stack alchemy object

00:09:12,720 --> 00:09:16,320
not all non-escaping objects can be

00:09:15,120 --> 00:09:17,839
stack allocated

00:09:16,320 --> 00:09:21,279
i'll show some of the limitations later

00:09:17,839 --> 00:09:23,200
on but there's plenty of them

00:09:21,279 --> 00:09:24,800
we implemented the stack allocation path

00:09:23,200 --> 00:09:26,640
in macro expansion so we had to actually

00:09:24,800 --> 00:09:29,760
write a separate path

00:09:26,640 --> 00:09:32,720
that took out everything else we removed

00:09:29,760 --> 00:09:34,320
everything else but the path where we uh

00:09:32,720 --> 00:09:36,000
stack hello kitty object

00:09:34,320 --> 00:09:37,440
so how do we stack allocate and this was

00:09:36,000 --> 00:09:39,519
one of the bigger revelations

00:09:37,440 --> 00:09:40,880
we actually use box lock node which was

00:09:39,519 --> 00:09:42,640
used for monitors

00:09:40,880 --> 00:09:44,080
because mainly we needed a way to

00:09:42,640 --> 00:09:47,040
communicate

00:09:44,080 --> 00:09:49,040
uh stack oop which was not done in any

00:09:47,040 --> 00:09:51,200
other way

00:09:49,040 --> 00:09:52,959
from the ir back to the code generator

00:09:51,200 --> 00:09:55,200
to say hey this should be a pointer

00:09:52,959 --> 00:09:57,200
reference on the stack somewhere

00:09:55,200 --> 00:09:59,200
so right now our stock hello objects end

00:09:57,200 --> 00:10:01,680
up where the log

00:09:59,200 --> 00:10:03,519
slots would be which is right after the

00:10:01,680 --> 00:10:04,880
all the spills and locals before the

00:10:03,519 --> 00:10:07,920
preserve registers

00:10:04,880 --> 00:10:07,920
on the frame so

00:10:08,399 --> 00:10:13,839
um so other stuff we have to actually

00:10:11,680 --> 00:10:15,279
worry about as soon as we did that we

00:10:13,839 --> 00:10:17,200
got immediately asserting the garbage

00:10:15,279 --> 00:10:19,279
collector says what the hell is this

00:10:17,200 --> 00:10:20,800
you're giving me a new preference on on

00:10:19,279 --> 00:10:22,560
the stack that's not right

00:10:20,800 --> 00:10:24,560
so we have to actually extend gc root

00:10:22,560 --> 00:10:25,920
scanning to support these objects

00:10:24,560 --> 00:10:27,680
because what it'll look like there will

00:10:25,920 --> 00:10:28,800
be a local on the stack that points to

00:10:27,680 --> 00:10:33,200
another stack

00:10:28,800 --> 00:10:34,959
location which is didn't quite sit right

00:10:33,200 --> 00:10:36,720
a more kind of subtle issue i'll

00:10:34,959 --> 00:10:37,279
describe it later is detecting live

00:10:36,720 --> 00:10:40,560
ranges

00:10:37,279 --> 00:10:42,160
of of objects in loops

00:10:40,560 --> 00:10:43,839
and this other the other two items

00:10:42,160 --> 00:10:45,920
removing the right barriers we obviously

00:10:43,839 --> 00:10:46,880
can't do them because you do a card mark

00:10:45,920 --> 00:10:50,320
on a

00:10:46,880 --> 00:10:53,200
stack location that and it's not good um

00:10:50,320 --> 00:10:53,920
and then the other two were already

00:10:53,200 --> 00:10:55,839
being done

00:10:53,920 --> 00:10:57,040
uh similar code we found for scale

00:10:55,839 --> 00:11:00,240
replacement

00:10:57,040 --> 00:11:02,000
uh so we were able to leverage that

00:11:00,240 --> 00:11:03,839
we had to kind of similarly implement

00:11:02,000 --> 00:11:06,079
heapification objects on the

00:11:03,839 --> 00:11:07,680
optimization so any safe point that the

00:11:06,079 --> 00:11:08,959
allocation can reach we have to inject

00:11:07,680 --> 00:11:11,360
this scalar replace

00:11:08,959 --> 00:11:13,360
out node i believe it was called where

00:11:11,360 --> 00:11:17,839
we describe which fields

00:11:13,360 --> 00:11:20,079
need to be copied over to a heap object

00:11:17,839 --> 00:11:21,839
so here's the gc root scanning typically

00:11:20,079 --> 00:11:24,800
what you normally see is now

00:11:21,839 --> 00:11:26,160
below the locals you have a pure stack

00:11:24,800 --> 00:11:28,320
allocated objects

00:11:26,160 --> 00:11:30,320
the first five over here will be a flags

00:11:28,320 --> 00:11:32,240
field then we have a class pointer

00:11:30,320 --> 00:11:33,839
and some reference so the gc need to be

00:11:32,240 --> 00:11:35,680
thought that well as you walk in the

00:11:33,839 --> 00:11:36,399
stack you have a reference coming over

00:11:35,680 --> 00:11:39,839
here

00:11:36,399 --> 00:11:41,360
you need to find all the uh oop fields

00:11:39,839 --> 00:11:44,560
and actually mark them so you don't

00:11:41,360 --> 00:11:44,560
actually lose any objects

00:11:45,279 --> 00:11:50,000
now this over overlapping live ranges

00:11:47,839 --> 00:11:52,320
was kind of like a subtle gotcha

00:11:50,000 --> 00:11:54,240
and to be honest i kind of knew this but

00:11:52,320 --> 00:11:57,279
i forgot about it i used to work in

00:11:54,240 --> 00:11:58,639
ibm on the open j9 compiler and we used

00:11:57,279 --> 00:12:00,639
to do this but

00:11:58,639 --> 00:12:04,000
sort of had to relearn it from scratch

00:12:00,639 --> 00:12:05,600
it's it's an interesting case where

00:12:04,000 --> 00:12:07,279
if these two objects as we have them

00:12:05,600 --> 00:12:10,720
here let's say

00:12:07,279 --> 00:12:12,639
are stack allocated as soon as we

00:12:10,720 --> 00:12:16,399
get into the definition which is

00:12:12,639 --> 00:12:18,480
definition v2 where value equals result

00:12:16,399 --> 00:12:21,120
what ends up happening is that these two

00:12:18,480 --> 00:12:24,480
addresses which are actually addresses

00:12:21,120 --> 00:12:26,880
on the stack became become the same so

00:12:24,480 --> 00:12:28,639
what that definition is coming back on

00:12:26,880 --> 00:12:29,839
the second iteration of the loop will be

00:12:28,639 --> 00:12:32,240
the address that

00:12:29,839 --> 00:12:33,519
the result was before but result is

00:12:32,240 --> 00:12:34,320
stack hell because it's always the same

00:12:33,519 --> 00:12:35,839
address

00:12:34,320 --> 00:12:37,440
so now all of a sudden what you end up

00:12:35,839 --> 00:12:40,160
doing is well

00:12:37,440 --> 00:12:41,600
after you first enter this if you never

00:12:40,160 --> 00:12:43,839
enter it again

00:12:41,600 --> 00:12:45,680
so typically when this was a heap

00:12:43,839 --> 00:12:46,399
allocation you get a new address every

00:12:45,680 --> 00:12:48,399
time

00:12:46,399 --> 00:12:49,600
you allocate it from the thread local

00:12:48,399 --> 00:12:51,040
heap buffer

00:12:49,600 --> 00:12:52,639
or you allocate it from the heap

00:12:51,040 --> 00:12:54,560
somewhere but it's a new address so your

00:12:52,639 --> 00:12:56,639
address comparison will work

00:12:54,560 --> 00:12:57,680
and the location on the where the object

00:12:56,639 --> 00:12:59,360
is stored is different

00:12:57,680 --> 00:13:01,040
but once it's on the stack it's always

00:12:59,360 --> 00:13:03,680
the same which we want to do

00:13:01,040 --> 00:13:04,639
we want to actually reuse this for the

00:13:03,680 --> 00:13:07,440
purpose of

00:13:04,639 --> 00:13:08,320
better cash page misses and also remove

00:13:07,440 --> 00:13:10,480
the allocation

00:13:08,320 --> 00:13:11,440
while we end up in this problem so we

00:13:10,480 --> 00:13:14,320
had to add

00:13:11,440 --> 00:13:15,040
code to detect this and actually reject

00:13:14,320 --> 00:13:17,760
one of them

00:13:15,040 --> 00:13:21,200
as a candidate for stack allocation one

00:13:17,760 --> 00:13:21,200
of them keep the add-on stacks fun

00:13:22,720 --> 00:13:26,160
so we go into the current limitations so

00:13:25,440 --> 00:13:28,320
we have

00:13:26,160 --> 00:13:30,560
few limitations we can actually do right

00:13:28,320 --> 00:13:30,560
now

00:13:30,959 --> 00:13:33,760
we don't stack out the object with

00:13:32,160 --> 00:13:34,720
monitors this kind of side effect with

00:13:33,760 --> 00:13:36,320
box lock node

00:13:34,720 --> 00:13:37,760
we just didn't finish the work it's not

00:13:36,320 --> 00:13:40,320
hard to do

00:13:37,760 --> 00:13:42,959
but some of the monitor elimination code

00:13:40,320 --> 00:13:45,199
eventually compacts our box lock slots

00:13:42,959 --> 00:13:48,399
for stock allocate objects so we

00:13:45,199 --> 00:13:49,920
mess up we don't

00:13:48,399 --> 00:13:51,600
but this is amazing the second one is

00:13:49,920 --> 00:13:52,959
the main issue that we have with

00:13:51,600 --> 00:13:55,360
performance right now

00:13:52,959 --> 00:13:57,360
we do not allow stack allocate objects

00:13:55,360 --> 00:13:59,600
to be pointed to each other

00:13:57,360 --> 00:14:00,720
so obviously a heap parent would mean

00:13:59,600 --> 00:14:03,120
escaping so that's

00:14:00,720 --> 00:14:04,880
actually handled by escape analysis but

00:14:03,120 --> 00:14:05,440
stack allocated stock algorithm is not

00:14:04,880 --> 00:14:07,600
allowed

00:14:05,440 --> 00:14:09,120
at the moment there's ways to resolve

00:14:07,600 --> 00:14:11,519
that but

00:14:09,120 --> 00:14:13,279
right now it's we don't do it we don't

00:14:11,519 --> 00:14:17,199
have compressed oops

00:14:13,279 --> 00:14:19,839
support yet and this is mainly because

00:14:17,199 --> 00:14:21,440
um you can have a merge point one side a

00:14:19,839 --> 00:14:23,600
heap object the other side the stock

00:14:21,440 --> 00:14:26,000
helical object it goes to an encode p

00:14:23,600 --> 00:14:27,600
gets stored as a compressed on the stack

00:14:26,000 --> 00:14:28,880
while compressing a stack

00:14:27,600 --> 00:14:31,680
doesn't work because you cannot

00:14:28,880 --> 00:14:35,600
guarantee that the address range will be

00:14:31,680 --> 00:14:37,839
within that 32-bit uh space

00:14:35,600 --> 00:14:39,600
we don't stock allocate arrays at the

00:14:37,839 --> 00:14:41,440
moment as well

00:14:39,600 --> 00:14:43,440
uh we just ran out of time there's no

00:14:41,440 --> 00:14:45,519
particular reason why we didn't do it

00:14:43,440 --> 00:14:46,480
primitive race would be simple uh

00:14:45,519 --> 00:14:48,399
reference array

00:14:46,480 --> 00:14:49,680
special consideration with array copies

00:14:48,399 --> 00:14:50,959
so we just

00:14:49,680 --> 00:14:52,639
didn't have time to finish this

00:14:50,959 --> 00:14:53,519
presentation come here and talk about

00:14:52,639 --> 00:14:57,199
this

00:14:53,519 --> 00:14:58,720
and finally thank you ron pressler

00:14:57,199 --> 00:15:00,480
we actually may need to do something

00:14:58,720 --> 00:15:03,519
special for project loom here

00:15:00,480 --> 00:15:05,440
um either prevent

00:15:03,519 --> 00:15:06,959
stack allocation of objects that live

00:15:05,440 --> 00:15:09,199
across method calls

00:15:06,959 --> 00:15:11,839
because in the mode where they do the

00:15:09,199 --> 00:15:14,160
fast relocation of the stack

00:15:11,839 --> 00:15:15,680
is just a simple mem copy so if you have

00:15:14,160 --> 00:15:16,959
a reference on the stack pointing to a

00:15:15,680 --> 00:15:18,959
stack object well

00:15:16,959 --> 00:15:20,720
nobody's there to patch it to update

00:15:18,959 --> 00:15:24,720
that

00:15:20,720 --> 00:15:27,279
so we'll get there actually

00:15:24,720 --> 00:15:28,720
so now some good news actually so these

00:15:27,279 --> 00:15:30,000
are the performance improvements that

00:15:28,720 --> 00:15:33,040
actually got

00:15:30,000 --> 00:15:34,480
with this prototype that we have um

00:15:33,040 --> 00:15:36,240
being a compiler guy for me this is

00:15:34,480 --> 00:15:37,920
amazing because uh

00:15:36,240 --> 00:15:40,320
i usually would work for three four

00:15:37,920 --> 00:15:41,199
months for two percent or three percent

00:15:40,320 --> 00:15:42,880
improvement

00:15:41,199 --> 00:15:44,560
and having a range of applications

00:15:42,880 --> 00:15:46,560
actually get uh

00:15:44,560 --> 00:15:47,839
significant speedups is actually quite

00:15:46,560 --> 00:15:50,880
good to see

00:15:47,839 --> 00:15:52,480
um one of the stack allocation to stack

00:15:50,880 --> 00:15:54,959
allocated object would be another

00:15:52,480 --> 00:15:56,320
massive improvements if we get it right

00:15:54,959 --> 00:15:58,079
because there's certain patterns in

00:15:56,320 --> 00:16:00,639
scala that are very common

00:15:58,079 --> 00:16:03,410
that do have an object graph pointing to

00:16:00,639 --> 00:16:05,920
each other which we currently reject

00:16:03,410 --> 00:16:08,160
[Music]

00:16:05,920 --> 00:16:08,959
and so finally the last bit of the

00:16:08,160 --> 00:16:11,839
presentation

00:16:08,959 --> 00:16:13,519
so when and where can we see this patch

00:16:11,839 --> 00:16:17,120
uh well nowhere right now so

00:16:13,519 --> 00:16:20,240
charlie and i are in the process of um

00:16:17,120 --> 00:16:21,920
migrating our patch from jdk11

00:16:20,240 --> 00:16:23,920
there's no particular reason why i

00:16:21,920 --> 00:16:25,920
picked juke 11. just we were looking at

00:16:23,920 --> 00:16:27,600
sparks sort of continued down that path

00:16:25,920 --> 00:16:29,279
from the build we're using

00:16:27,600 --> 00:16:31,600
we're migrating to tip cleaning up the

00:16:29,279 --> 00:16:33,920
code um

00:16:31,600 --> 00:16:35,920
and as soon as it's done we'll actually

00:16:33,920 --> 00:16:36,800
post this to the compiler mailing list

00:16:35,920 --> 00:16:40,800
and

00:16:36,800 --> 00:16:43,759
ask for review that's the plan so

00:16:40,800 --> 00:16:45,600
our next steps from our perspective are

00:16:43,759 --> 00:16:46,320
that we have to stabilize the prototype

00:16:45,600 --> 00:16:48,000
and clean it up

00:16:46,320 --> 00:16:49,759
we still have a few crashes we haven't

00:16:48,000 --> 00:16:51,279
looked at every

00:16:49,759 --> 00:16:54,320
of those methods or benchmarks we

00:16:51,279 --> 00:16:56,000
couldn't run because there were issues

00:16:54,320 --> 00:16:58,399
uh started working on removing the

00:16:56,000 --> 00:17:00,560
limitations one by one

00:16:58,399 --> 00:17:03,600
stack allocated stockholder would be

00:17:00,560 --> 00:17:06,799
probably my first pick

00:17:03,600 --> 00:17:08,079
right now we only support g1 and pgc

00:17:06,799 --> 00:17:10,400
with ours

00:17:08,079 --> 00:17:11,919
with a heap with this with a mark

00:17:10,400 --> 00:17:13,679
extension to walk

00:17:11,919 --> 00:17:15,600
stock calculated objects so we need to

00:17:13,679 --> 00:17:19,919
extend and see how it actually works

00:17:15,600 --> 00:17:21,919
in other gc modes like doe zgc

00:17:19,919 --> 00:17:24,319
and finally look for more opportunities

00:17:21,919 --> 00:17:26,559
in other real world applications

00:17:24,319 --> 00:17:27,600
uh i want to see if we can actually

00:17:26,559 --> 00:17:29,200
improve

00:17:27,600 --> 00:17:31,039
you know the various rest frameworks

00:17:29,200 --> 00:17:34,320
that are out there that

00:17:31,039 --> 00:17:37,840
people build with and maybe

00:17:34,320 --> 00:17:37,840
elasticsearch products like that

00:17:38,400 --> 00:17:42,559
and which leads me to the end of the

00:17:40,880 --> 00:17:45,360
presentation here which is

00:17:42,559 --> 00:17:46,400
you know if you liked what you saw here

00:17:45,360 --> 00:17:47,840
please stay in touch

00:17:46,400 --> 00:17:49,919
i would like to actually work with

00:17:47,840 --> 00:17:51,520
everyone here both charlie and i are

00:17:49,919 --> 00:17:52,480
really new to the code base and need a

00:17:51,520 --> 00:17:55,520
lot of help

00:17:52,480 --> 00:17:57,440
to actually make this a reality um

00:17:55,520 --> 00:17:59,120
and you know helping us review the patch

00:17:57,440 --> 00:18:01,360
would be awesome if anybody is willing

00:17:59,120 --> 00:18:05,679
to to do that

00:18:01,360 --> 00:18:05,679
that's it thank you

00:18:11,280 --> 00:18:17,039
any questions do you have time

00:18:14,480 --> 00:18:17,039
five minutes

00:18:19,200 --> 00:18:25,360
are you all completely stunned by that

00:18:21,200 --> 00:18:25,360
oh no not everybody evidently

00:18:33,840 --> 00:18:37,120
so the question is can you say something

00:18:35,280 --> 00:18:38,480
about your right barrier implementation

00:18:37,120 --> 00:18:40,799
you said that it's always a performance

00:18:38,480 --> 00:18:41,919
when but if the stack allocation fails

00:18:40,799 --> 00:18:43,200
then presumably you've got more

00:18:41,919 --> 00:18:46,000
expensive right barrier now

00:18:43,200 --> 00:18:47,679
that's right so uh we currently and

00:18:46,000 --> 00:18:51,120
that's exactly the

00:18:47,679 --> 00:18:53,360
uh where i was going i have actually two

00:18:51,120 --> 00:18:54,720
appendix slides which i'm actually going

00:18:53,360 --> 00:18:56,559
to talk about the reference to reference

00:18:54,720 --> 00:18:59,600
issues which leads me to the stack uh

00:18:56,559 --> 00:19:01,679
right barrier so we currently remove the

00:18:59,600 --> 00:19:02,000
right barriers on stack allocate objects

00:19:01,679 --> 00:19:04,559
we

00:19:02,000 --> 00:19:06,160
because we are sure that when we make it

00:19:04,559 --> 00:19:07,039
a candidate for stack location there

00:19:06,160 --> 00:19:09,360
will be

00:19:07,039 --> 00:19:11,200
never it becoming a part of something

00:19:09,360 --> 00:19:12,160
else so if you store a field into if it

00:19:11,200 --> 00:19:14,080
has a field

00:19:12,160 --> 00:19:15,760
and you write into that field you don't

00:19:14,080 --> 00:19:17,120
need a right barrier because nobody's

00:19:15,760 --> 00:19:20,240
ever going to see that object this

00:19:17,120 --> 00:19:21,520
lives on the stack now

00:19:20,240 --> 00:19:23,440
the reason why we can't do stack

00:19:21,520 --> 00:19:25,360
allocation to stack location exactly

00:19:23,440 --> 00:19:27,200
this case let's have this example here

00:19:25,360 --> 00:19:29,440
where we have uh

00:19:27,200 --> 00:19:31,360
two objects pointing to each other now

00:19:29,440 --> 00:19:32,080
we get to the bottom part we load the

00:19:31,360 --> 00:19:35,120
original

00:19:32,080 --> 00:19:37,600
uh test object from the wrapper we do

00:19:35,120 --> 00:19:38,720
t.x everything is good we remove the

00:19:37,600 --> 00:19:41,280
right barrier

00:19:38,720 --> 00:19:43,039
now what if there was another coin

00:19:41,280 --> 00:19:45,520
between like this

00:19:43,039 --> 00:19:47,679
and this actually gave us a heap now

00:19:45,520 --> 00:19:49,360
coming down here it's either a heap or a

00:19:47,679 --> 00:19:52,080
stack object

00:19:49,360 --> 00:19:52,640
down this t1.x so we don't know in that

00:19:52,080 --> 00:19:54,400
case

00:19:52,640 --> 00:19:57,280
two ways we can actually detect this

00:19:54,400 --> 00:19:59,679
case with analysis and reject it

00:19:57,280 --> 00:20:01,360
which would reject certain candidates or

00:19:59,679 --> 00:20:04,080
we extend the right barrier

00:20:01,360 --> 00:20:05,600
to actually look at the stack range and

00:20:04,080 --> 00:20:06,240
say yeah this falls into the stack

00:20:05,600 --> 00:20:09,280
you're good

00:20:06,240 --> 00:20:10,400
keep going don't worry about that so it

00:20:09,280 --> 00:20:12,240
would increase the

00:20:10,400 --> 00:20:14,559
cost of the right barrier if we did that

00:20:12,240 --> 00:20:14,559
approach

00:20:18,400 --> 00:20:22,720
very interesting results thanks a lot uh

00:20:20,720 --> 00:20:27,120
quick question have you considered the

00:20:22,720 --> 00:20:30,320
allocating such objects on heap

00:20:27,120 --> 00:20:32,159
instead of on stack but just like

00:20:30,320 --> 00:20:33,600
no do you mean reserve a special heap

00:20:32,159 --> 00:20:36,559
region for this kind of

00:20:33,600 --> 00:20:36,559
well with steel apps

00:20:37,200 --> 00:20:43,600
like 80 labs but just for

00:20:40,400 --> 00:20:46,640
duration or for a single call or

00:20:43,600 --> 00:20:49,280
just chunk them and the

00:20:46,640 --> 00:20:50,240
by that you can significantly simplify

00:20:49,280 --> 00:20:53,760
the

00:20:50,240 --> 00:20:56,320
uh requirements to the runtime you don't

00:20:53,760 --> 00:20:57,440
need to treat special objects on the

00:20:56,320 --> 00:21:00,559
stack

00:20:57,440 --> 00:21:02,080
since everything stays on heap well i

00:21:00,559 --> 00:21:04,159
have to consider how that would work

00:21:02,080 --> 00:21:05,760
i don't can't think on top of my head

00:21:04,159 --> 00:21:07,600
but um

00:21:05,760 --> 00:21:09,120
but yeah we'll think about it maybe

00:21:07,600 --> 00:21:13,600
there's a way that we actually

00:21:09,120 --> 00:21:15,520
can do that um we didn't consider it no

00:21:13,600 --> 00:21:18,000
i think it was a question here you see

00:21:15,520 --> 00:21:20,400
just looking forward to

00:21:18,000 --> 00:21:21,440
the right the path when it comes out

00:21:20,400 --> 00:21:23,360
because

00:21:21,440 --> 00:21:25,039
in the memory api that i showed before

00:21:23,360 --> 00:21:26,080
we had some benchmarks that are very

00:21:25,039 --> 00:21:28,640
problematic and

00:21:26,080 --> 00:21:30,400
stressed the flow sensitive case that

00:21:28,640 --> 00:21:33,039
you were mentioning before

00:21:30,400 --> 00:21:35,280
yeah especially with the immutable trend

00:21:33,039 --> 00:21:38,000
and i love immutable launches myself

00:21:35,280 --> 00:21:38,720
it actually trace copies every time

00:21:38,000 --> 00:21:39,840
which

00:21:38,720 --> 00:21:42,640
i'm we're hoping that this would

00:21:39,840 --> 00:21:42,640
actually take care of

00:21:50,080 --> 00:21:53,280
so i just want to be clear that there's

00:21:51,679 --> 00:21:55,520
still a limitation that the

00:21:53,280 --> 00:21:57,120
there's no partial escape analysis here

00:21:55,520 --> 00:22:00,080
there's no lazily standing stuff back

00:21:57,120 --> 00:22:01,360
up okay yeah absolutely so we can look

00:22:00,080 --> 00:22:03,120
into that next i mean

00:22:01,360 --> 00:22:04,400
right now we're not doing it so anytime

00:22:03,120 --> 00:22:06,159
we see something that

00:22:04,400 --> 00:22:07,679
escapes for us escapes it doesn't matter

00:22:06,159 --> 00:22:09,039
it's a cold call or something that's

00:22:07,679 --> 00:22:12,320
never reached we're just

00:22:09,039 --> 00:22:14,080
okay okay well i think we don't thank

00:22:12,320 --> 00:22:21,800
you

00:22:14,080 --> 00:22:21,800
[Applause]

00:22:22,840 --> 00:22:25,840

YouTube URL: https://www.youtube.com/watch?v=A_s2bx5RWMU


