Title: Oreboot RISC-V Firmware in Rust
Publication date: 2020-07-10
Playlist: FOSDEM 2020
Description: 
	by Ryan O'Leary

At: FOSDEM 2020
https://video.fosdem.org/2020/K.3.401/riscv_oreboot.webm

Oreboot = Coreboot - C. Oreboot is a fully open-source power-on-reset and romstage firmware written in Rust. Oreboot can boot a HiFive RISC-V processor to Linux with a Go user-mode.


Oreboot rethinks the firmware driver models. Each driver is distilled to four basic functions: init, pread, pwrite and shutdown. This interface allows us to make convenient higher-level drivers such as a "union driver" which duplicates a single write operation to multiple drivers. This makes consoles which have multiple underlying UART drivers elegant.


By using the Rust programming language, Oreboot has a leg-up in terms of security and reliability compared to contemporary firmware written in C or assembly. Rust's borrow-checker ensures pointers are not used after freed and proves that coroutines are thread-safe at compile time.


In this talk, we will also present a short overview of the basics of Rust, how our driver model incorporates coroutines and the bootflow of Oreboot.

Room: K.3.401
Scheduled start: 2020-02-01 12:30:00
Captions: 
	00:00:05,759 --> 00:00:09,840
all right so

00:00:06,799 --> 00:00:11,840
today i'm here to present or boot um

00:00:09,840 --> 00:00:13,519
i'm rhino larry or boots a project

00:00:11,840 --> 00:00:15,759
worked on by

00:00:13,519 --> 00:00:16,960
quite a few people ron is a big

00:00:15,759 --> 00:00:18,560
contributor

00:00:16,960 --> 00:00:22,720
there's some contributors in the crowd

00:00:18,560 --> 00:00:22,720
today i see christian svensson's here

00:00:22,960 --> 00:00:28,960
so who here is familiar with kwabu

00:00:26,160 --> 00:00:30,320
a lot of people um so orbit is basically

00:00:28,960 --> 00:00:32,800
a fork of quebec

00:00:30,320 --> 00:00:35,840
without c code it's all divided in rest

00:00:32,800 --> 00:00:38,320
um that that's the main uh

00:00:35,840 --> 00:00:38,960
um the main thing behind it um so in

00:00:38,320 --> 00:00:41,600
this talk

00:00:38,960 --> 00:00:43,360
i'll talk about what wabu is some of the

00:00:41,600 --> 00:00:45,280
firmware challenges we ran into

00:00:43,360 --> 00:00:47,760
some of the challenges we ran into with

00:00:45,280 --> 00:00:49,280
rest um what targets it supports so

00:00:47,760 --> 00:00:50,079
there's a few risk five targets it

00:00:49,280 --> 00:00:52,160
supports

00:00:50,079 --> 00:00:53,280
um and some design decisions uh that has

00:00:52,160 --> 00:00:56,960
gone on in

00:00:53,280 --> 00:01:00,239
making it um so what is orboot

00:00:56,960 --> 00:01:01,920
um so sorry i'm missing someone's

00:01:00,239 --> 00:01:02,320
favorite project here this is a list of

00:01:01,920 --> 00:01:05,119
some

00:01:02,320 --> 00:01:06,720
other open source uh firmware projects

00:01:05,119 --> 00:01:09,840
um like u-boot linux blue

00:01:06,720 --> 00:01:11,200
core boot nerf

00:01:09,840 --> 00:01:12,640
big thing behind all these projects all

00:01:11,200 --> 00:01:13,360
the existing projects today is all

00:01:12,640 --> 00:01:16,560
written

00:01:13,360 --> 00:01:19,200
basically in c

00:01:16,560 --> 00:01:20,720
most of these use c code somewhere in

00:01:19,200 --> 00:01:23,840
the project

00:01:20,720 --> 00:01:25,119
and that's kind of a across all female

00:01:23,840 --> 00:01:27,520
projects that's kind of a big

00:01:25,119 --> 00:01:29,520
common pattern you'd see and c is kind

00:01:27,520 --> 00:01:31,600
of an old language probably like 40 or

00:01:29,520 --> 00:01:33,920
50 years old and what we really wanted

00:01:31,600 --> 00:01:37,600
to do is use a modern more safe

00:01:33,920 --> 00:01:39,360
sort of language there's also another

00:01:37,600 --> 00:01:42,399
there's other

00:01:39,360 --> 00:01:45,520
things we're trying to fix in orbit

00:01:42,399 --> 00:01:47,600
so for example we want to jump to the

00:01:45,520 --> 00:01:49,920
kernel as quickly as possible

00:01:47,600 --> 00:01:51,360
we want to push as much work into the

00:01:49,920 --> 00:01:52,880
kernel as possible and we kind of want

00:01:51,360 --> 00:01:54,240
to use the link speed model

00:01:52,880 --> 00:01:56,320
we don't want to implement lots of

00:01:54,240 --> 00:02:00,240
device drivers in the firmware

00:01:56,320 --> 00:02:03,600
linux has great drivers or very very

00:02:00,240 --> 00:02:03,600
secure drivers very fast

00:02:03,680 --> 00:02:08,640
we want to we want a stricter policy on

00:02:06,560 --> 00:02:12,560
what is accepted as

00:02:08,640 --> 00:02:16,000
open source code

00:02:12,560 --> 00:02:20,160
we made orboot supports a few targets

00:02:16,000 --> 00:02:23,360
including disk five it also supports x86

00:02:20,160 --> 00:02:25,120
and arm but we really want to limit

00:02:23,360 --> 00:02:27,360
limit it to platforms which are fully

00:02:25,120 --> 00:02:31,680
open to us

00:02:27,360 --> 00:02:35,440
um we want to um

00:02:31,680 --> 00:02:36,640
yeah the another big okay so i'll go

00:02:35,440 --> 00:02:39,120
over what the

00:02:36,640 --> 00:02:40,959
the a very simple simplistic view of

00:02:39,120 --> 00:02:42,640
what firmware should be doing

00:02:40,959 --> 00:02:45,280
so when you power on the system all it

00:02:42,640 --> 00:02:46,239
has to do is get the system ready to run

00:02:45,280 --> 00:02:48,640
your software

00:02:46,239 --> 00:02:50,000
we kind of want to cut out from the from

00:02:48,640 --> 00:02:51,280
the firmware everything else like we

00:02:50,000 --> 00:02:52,720
don't want a whole network stack we

00:02:51,280 --> 00:02:54,879
don't want the whole usb stack

00:02:52,720 --> 00:02:56,480
we want it ready immediately to run the

00:02:54,879 --> 00:02:58,400
software

00:02:56,480 --> 00:02:59,840
um one of the big goals behind that is a

00:02:58,400 --> 00:03:02,640
one-second boot you want to be able to

00:02:59,840 --> 00:03:05,280
boot a platform like a bmc or a

00:03:02,640 --> 00:03:07,120
laptop in one second um and really

00:03:05,280 --> 00:03:10,400
believe if the

00:03:07,120 --> 00:03:12,319
advances in rest and um

00:03:10,400 --> 00:03:13,760
other things we could use we could

00:03:12,319 --> 00:03:16,640
achieve this goal um

00:03:13,760 --> 00:03:18,400
possibly using codeines or parallelism

00:03:16,640 --> 00:03:19,519
um rest provides lots of safety in that

00:03:18,400 --> 00:03:21,200
regard which

00:03:19,519 --> 00:03:24,080
isn't seen in many other pieces of

00:03:21,200 --> 00:03:26,720
firmware so we'll go over the boot flow

00:03:24,080 --> 00:03:28,640
of orbit this is very similar to how

00:03:26,720 --> 00:03:30,879
core boot works

00:03:28,640 --> 00:03:32,640
but there's a few modifications so at

00:03:30,879 --> 00:03:34,560
the beginning we have the boot blob

00:03:32,640 --> 00:03:36,080
this is where the first instruction

00:03:34,560 --> 00:03:39,200
resides

00:03:36,080 --> 00:03:42,239
uh it excludes directly out of flash um

00:03:39,200 --> 00:03:43,599
initializes the cpu and the the the

00:03:42,239 --> 00:03:47,519
basic hardware and it prints

00:03:43,599 --> 00:03:49,920
a single debug message welcome to orboot

00:03:47,519 --> 00:03:51,519
then it sets up the the static ram like

00:03:49,920 --> 00:03:55,439
the cache is ram

00:03:51,519 --> 00:03:57,200
and then it jumps to the the vram stage

00:03:55,439 --> 00:04:00,080
the beginning of the realm stage still

00:03:57,200 --> 00:04:03,120
executed directly from flash

00:04:00,080 --> 00:04:05,040
and has very little memory to work with

00:04:03,120 --> 00:04:06,720
probably about 30 kilobytes on some

00:04:05,040 --> 00:04:08,400
embedded platforms

00:04:06,720 --> 00:04:09,760
and the only purpose of this stage is to

00:04:08,400 --> 00:04:11,680
initialize the ram

00:04:09,760 --> 00:04:13,200
once the vm is initialized it's ready to

00:04:11,680 --> 00:04:15,519
jump to an operating system

00:04:13,200 --> 00:04:16,560
so the next stage is the pilot stage so

00:04:15,519 --> 00:04:19,199
this doesn't

00:04:16,560 --> 00:04:20,799
delay with network stacks and this drive

00:04:19,199 --> 00:04:23,120
is it jumps directly to the operating

00:04:20,799 --> 00:04:23,120
system

00:04:24,320 --> 00:04:27,919
and the operating system might be one

00:04:26,160 --> 00:04:28,639
such a linux which does have the network

00:04:27,919 --> 00:04:30,479
stack

00:04:28,639 --> 00:04:34,560
it does have the disk drivers and that

00:04:30,479 --> 00:04:34,560
jumps to whatever your software would be

00:04:35,199 --> 00:04:41,520
um skip this piece of time

00:04:39,680 --> 00:04:43,120
so how many of you are familiar with

00:04:41,520 --> 00:04:45,840
rust

00:04:43,120 --> 00:04:48,080
so quite a few people so for orbit we

00:04:45,840 --> 00:04:51,919
came up with this driver model

00:04:48,080 --> 00:04:53,600
so each driver has four basic functions

00:04:51,919 --> 00:04:56,720
initialization shutdown

00:04:53,600 --> 00:04:58,639
as well as a read and write so p

00:04:56,720 --> 00:05:00,080
read is positional read so you read a

00:04:58,639 --> 00:05:02,400
specif specific

00:05:00,080 --> 00:05:05,360
position um so let's implement stuff

00:05:02,400 --> 00:05:05,360
like block devices

00:05:05,919 --> 00:05:10,479
so here's an example of how would you

00:05:08,320 --> 00:05:12,960
you would use the pvd function

00:05:10,479 --> 00:05:13,919
um just say you had a block device which

00:05:12,960 --> 00:05:15,759
is 100 bytes

00:05:13,919 --> 00:05:17,840
you have your 32 byte buffer you keep

00:05:15,759 --> 00:05:19,600
calling the p lead function

00:05:17,840 --> 00:05:21,840
on this buffer it reads 32 bytes every

00:05:19,600 --> 00:05:23,759
time and eventually it gets the end

00:05:21,840 --> 00:05:26,080
and you pass in the cursor every time

00:05:23,759 --> 00:05:27,600
you read from it

00:05:26,080 --> 00:05:29,120
the reason we do this instead of a read

00:05:27,600 --> 00:05:31,360
function is because p read is

00:05:29,120 --> 00:05:32,240
immutable you pass in the cursor every

00:05:31,360 --> 00:05:35,520
time

00:05:32,240 --> 00:05:37,440
which from a rest perspective it's a lot

00:05:35,520 --> 00:05:39,840
it's a lot nicer to work with

00:05:37,440 --> 00:05:40,720
because in rest you could have multiple

00:05:39,840 --> 00:05:44,080
immutable

00:05:40,720 --> 00:05:44,080
references to the same object

00:05:45,520 --> 00:05:48,960
so these are a few examples of the

00:05:47,120 --> 00:05:49,840
driver drivers we've implemented in

00:05:48,960 --> 00:05:51,520
orboot

00:05:49,840 --> 00:05:53,039
so we have a memory driver which reads

00:05:51,520 --> 00:05:56,080
directly from memory

00:05:53,039 --> 00:05:58,479
we have some serial drivers we have

00:05:56,080 --> 00:05:59,680
a spy driver we also have what we call

00:05:58,479 --> 00:06:04,000
virtual

00:05:59,680 --> 00:06:06,479
drivers so these kind of work on

00:06:04,000 --> 00:06:07,520
they don't work with physical hardware

00:06:06,479 --> 00:06:09,360
but they work with

00:06:07,520 --> 00:06:10,960
it's a nice abstraction so for example

00:06:09,360 --> 00:06:12,720
just so you have a console

00:06:10,960 --> 00:06:14,800
in your firmware where you write write

00:06:12,720 --> 00:06:17,440
output to and you want that outputted

00:06:14,800 --> 00:06:19,440
output vision to multiple devices for

00:06:17,440 --> 00:06:21,280
example if you have multiple uarts

00:06:19,440 --> 00:06:22,720
you could use the console driver and you

00:06:21,280 --> 00:06:25,039
give it a list of

00:06:22,720 --> 00:06:27,680
a list of drivers and it kind of

00:06:25,039 --> 00:06:29,280
replicates the output to each one

00:06:27,680 --> 00:06:31,759
so this is kind of a nice interface and

00:06:29,280 --> 00:06:34,080
that makes it safe to implement

00:06:31,759 --> 00:06:35,520
if you compare this to c where they

00:06:34,080 --> 00:06:37,199
don't really have language support for

00:06:35,520 --> 00:06:40,240
interfaces it's a it's a

00:06:37,199 --> 00:06:43,759
very nice

00:06:40,240 --> 00:06:46,000
breath of fresh air and in rest you also

00:06:43,759 --> 00:06:46,800
get printf for free so printf is part of

00:06:46,000 --> 00:06:50,000
the

00:06:46,800 --> 00:06:51,520
the core language in rest they have a

00:06:50,000 --> 00:06:52,880
printf implementation which you could

00:06:51,520 --> 00:06:56,800
rate the output to whatever

00:06:52,880 --> 00:06:56,800
you are to a device you want

00:06:58,400 --> 00:07:03,440
so for orboot we didn't use cbfs and we

00:07:02,160 --> 00:07:04,720
didn't use the code boot file system

00:07:03,440 --> 00:07:06,479
instead we came up with the new system

00:07:04,720 --> 00:07:08,720
called the gtfs

00:07:06,479 --> 00:07:11,919
this is basically a file system

00:07:08,720 --> 00:07:13,440
implemented using device tree

00:07:11,919 --> 00:07:15,280
the main reason behind this is we just

00:07:13,440 --> 00:07:16,080
have one really hard direct deposit for

00:07:15,280 --> 00:07:18,479
device tree

00:07:16,080 --> 00:07:20,720
so we might as well just use it for the

00:07:18,479 --> 00:07:22,880
the file system as well in the firmware

00:07:20,720 --> 00:07:24,639
um you can see an example of one that we

00:07:22,880 --> 00:07:25,599
put in a 60 megabyte pod

00:07:24,639 --> 00:07:27,759
so we have the boot block at the

00:07:25,599 --> 00:07:30,800
beginning um and then we have different

00:07:27,759 --> 00:07:32,080
payloads etc and then another nice thing

00:07:30,800 --> 00:07:33,919
about a device tree is

00:07:32,080 --> 00:07:36,319
with linux you just pass in the face to

00:07:33,919 --> 00:07:38,560
linux and it's exposed on the cis file

00:07:36,319 --> 00:07:41,280
systems this slash device tree

00:07:38,560 --> 00:07:42,880
and you can see all the payloads and

00:07:41,280 --> 00:07:43,360
items under there and here's an example

00:07:42,880 --> 00:07:46,720
for the

00:07:43,360 --> 00:07:48,000
the sci-fi board uh this is the the dtfs

00:07:46,720 --> 00:07:49,280
that we use for that

00:07:48,000 --> 00:07:52,639
and you can see there's multiple i think

00:07:49,280 --> 00:07:52,639
there's three payloads here

00:07:53,759 --> 00:07:58,319
um so this is kind of how you organize

00:07:56,479 --> 00:08:00,879
the source code for the firmware

00:07:58,319 --> 00:08:01,360
we have it's very similar to core boot

00:08:00,879 --> 00:08:03,199
we have

00:08:01,360 --> 00:08:06,560
a directory directories for the main

00:08:03,199 --> 00:08:09,680
boards slash the vendor slash the

00:08:06,560 --> 00:08:11,919
specific main board we have

00:08:09,680 --> 00:08:13,280
packages for the cpu for the soc for the

00:08:11,919 --> 00:08:16,319
drivers

00:08:13,280 --> 00:08:18,720
as well as the payloads

00:08:16,319 --> 00:08:19,980
details with the build system one

00:08:18,720 --> 00:08:21,280
interesting

00:08:19,980 --> 00:08:24,560
[Music]

00:08:21,280 --> 00:08:26,479
feature we've seen from rest is

00:08:24,560 --> 00:08:28,000
it makes it easy to just allocate

00:08:26,479 --> 00:08:30,720
everything on the stack

00:08:28,000 --> 00:08:31,680
which is very useful during early

00:08:30,720 --> 00:08:33,440
firmware

00:08:31,680 --> 00:08:35,039
um everything is allocated on the stack

00:08:33,440 --> 00:08:38,479
and you could tell compile time how much

00:08:35,039 --> 00:08:41,039
stack you use as a tool which tells you

00:08:38,479 --> 00:08:42,640
so you could formally prove how much

00:08:41,039 --> 00:08:44,000
memory your program is going to use

00:08:42,640 --> 00:08:46,000
and whether it's going to fit in the

00:08:44,000 --> 00:08:49,040
very small sram or

00:08:46,000 --> 00:08:49,040
a car on the system

00:08:50,160 --> 00:08:54,720
um another thing we're trying to work

00:08:52,399 --> 00:08:56,480
out is curve routines

00:08:54,720 --> 00:08:58,800
this is for the one second boot i

00:08:56,480 --> 00:09:02,399
mentioned earlier

00:08:58,800 --> 00:09:04,480
vast has language safety features

00:09:02,399 --> 00:09:07,120
which would greatly help in doing this

00:09:04,480 --> 00:09:10,480
to make it safe to implement co-routines

00:09:07,120 --> 00:09:11,279
um this is still a work in progress and

00:09:10,480 --> 00:09:13,680
if everyone

00:09:11,279 --> 00:09:14,720
anyone wants to help out with this um

00:09:13,680 --> 00:09:18,160
we'd greatly

00:09:14,720 --> 00:09:19,920
appreciate the help so the first talk we

00:09:18,160 --> 00:09:20,959
did was arm but you're probably not too

00:09:19,920 --> 00:09:24,000
interested in this

00:09:20,959 --> 00:09:26,240
and we did arm on qmu online hardware

00:09:24,000 --> 00:09:27,519
and then we switched to the hi5 unleash

00:09:26,240 --> 00:09:30,080
board

00:09:27,519 --> 00:09:30,880
so it has a it has five cores of five

00:09:30,080 --> 00:09:34,480
hearts

00:09:30,880 --> 00:09:36,399
um it has the hot server which

00:09:34,480 --> 00:09:38,160
has everything but a floating point unit

00:09:36,399 --> 00:09:41,519
and then four other hearts which are

00:09:38,160 --> 00:09:41,519
capable of running linux

00:09:42,160 --> 00:09:48,959
at first we we wanted to run it in

00:09:45,600 --> 00:09:52,080
we prefer to run linux in mode

00:09:48,959 --> 00:09:54,080
um the idea being linux driven in mode

00:09:52,080 --> 00:09:55,920
uh the user mode would be a new mode

00:09:54,080 --> 00:09:57,600
linux would run without an mmu so we

00:09:55,920 --> 00:09:58,720
needed some patches from christoph

00:09:57,600 --> 00:10:02,160
helbig

00:09:58,720 --> 00:10:04,560
um and

00:10:02,160 --> 00:10:06,560
we found some challenges with this uh

00:10:04,560 --> 00:10:09,760
then we switched to

00:10:06,560 --> 00:10:12,800
using orboot to uh with

00:10:09,760 --> 00:10:14,160
open sbi as a payload um and that bid

00:10:12,800 --> 00:10:16,160
linux for us

00:10:14,160 --> 00:10:19,200
which works a lot better but we're still

00:10:16,160 --> 00:10:21,519
trying to run linux and mode

00:10:19,200 --> 00:10:22,480
the the main reason is we wanted linux

00:10:21,519 --> 00:10:24,079
to be

00:10:22,480 --> 00:10:25,760
the only thing when insisting like the

00:10:24,079 --> 00:10:28,160
lowest layer as well as there's some

00:10:25,760 --> 00:10:32,720
performance improvements to not having

00:10:28,160 --> 00:10:36,399
to contact switch to mode

00:10:32,720 --> 00:10:36,399
so i could show you the the demo of

00:10:43,200 --> 00:10:47,760
so to manage you just type cargo make so

00:10:46,079 --> 00:10:49,440
if you're in the directory for this main

00:10:47,760 --> 00:10:52,240
board type cargo make

00:10:49,440 --> 00:10:52,800
uh run and it runs in qmu and you can

00:10:52,240 --> 00:10:55,600
see here

00:10:52,800 --> 00:10:56,320
it booted into linux um and it's running

00:10:55,600 --> 00:10:58,640
in mode

00:10:56,320 --> 00:11:01,839
and then it crashed because there's no

00:10:58,640 --> 00:11:01,839
there's no name mfs

00:11:05,360 --> 00:11:09,279
so the next thing that we're working on

00:11:07,440 --> 00:11:11,839
right now is

00:11:09,279 --> 00:11:13,360
the next target is open titan little

00:11:11,839 --> 00:11:14,880
gray

00:11:13,360 --> 00:11:16,480
so there's currently no asic you can

00:11:14,880 --> 00:11:18,240
purchase to test this on

00:11:16,480 --> 00:11:20,800
um so your work has to be done on a

00:11:18,240 --> 00:11:23,760
invalidator on a fpga

00:11:20,800 --> 00:11:25,360
um it is a it's a more embedded system

00:11:23,760 --> 00:11:26,959
so this can't mix so we can't do

00:11:25,360 --> 00:11:27,519
something like linux boot so we'll have

00:11:26,959 --> 00:11:29,680
to end up

00:11:27,519 --> 00:11:31,519
implementing more of these drivers

00:11:29,680 --> 00:11:33,440
inside orboot

00:11:31,519 --> 00:11:35,120
at this point it's still a work in

00:11:33,440 --> 00:11:36,560
progress we've we've gotten some simple

00:11:35,120 --> 00:11:38,640
hollow worlds

00:11:36,560 --> 00:11:39,839
and jumping to some simple payloads but

00:11:38,640 --> 00:11:42,640
our main goal is to

00:11:39,839 --> 00:11:44,320
boot the tarkanel which is a kernel also

00:11:42,640 --> 00:11:48,320
written in rest

00:11:44,320 --> 00:11:48,320
and targeted for embedded systems

00:11:49,120 --> 00:11:53,680
so this is how you can get involved so

00:11:51,360 --> 00:11:56,800
we have a

00:11:53,680 --> 00:11:58,399
slack you can join that link we have the

00:11:56,800 --> 00:12:00,720
github you can check it out we have some

00:11:58,399 --> 00:12:03,360
documentation on how you can build and

00:12:00,720 --> 00:12:05,440
run it on various targets here's some

00:12:03,360 --> 00:12:08,560
items you could help us with we have

00:12:05,440 --> 00:12:10,399
github issues for these and if you want

00:12:08,560 --> 00:12:12,959
to work on it just ask on slack and we

00:12:10,399 --> 00:12:25,839
can get you started

00:12:12,959 --> 00:12:25,839
holy any questions

00:12:28,720 --> 00:12:32,240
what are the plans for uh secure booth

00:12:31,279 --> 00:12:33,760
in this space

00:12:32,240 --> 00:12:35,279
uh or something like titan where you

00:12:33,760 --> 00:12:37,040
wanted to be a hardware trust

00:12:35,279 --> 00:12:38,800
how does it interface are you gonna have

00:12:37,040 --> 00:12:41,120
drivers for like the

00:12:38,800 --> 00:12:42,480
station hardware uh yes yes we'll need

00:12:41,120 --> 00:12:44,639
some drivers for um

00:12:42,480 --> 00:12:46,320
yeah for like the aes hardware um to

00:12:44,639 --> 00:12:48,560
implement secure boot

00:12:46,320 --> 00:12:49,760
um that's one of the the projects we're

00:12:48,560 --> 00:12:52,079
kind of

00:12:49,760 --> 00:12:53,760
uh that we need help with um some

00:12:52,079 --> 00:12:56,399
verified boot system

00:12:53,760 --> 00:12:58,160
um mainly right now we're just trying to

00:12:56,399 --> 00:12:59,360
get the the operating system to boot the

00:12:58,160 --> 00:13:01,440
the talk kernel

00:12:59,360 --> 00:13:03,440
but once we get that part it shouldn't

00:13:01,440 --> 00:13:07,839
be too difficult to look at the details

00:13:03,440 --> 00:13:07,839
of a secure boot system

00:13:10,639 --> 00:13:21,839
i'll repeat the questions okay

00:13:13,920 --> 00:13:23,680
any other questions yep

00:13:21,839 --> 00:13:25,839
um so the question is does orboot serve

00:13:23,680 --> 00:13:28,560
sbi calls or do you use open sbi

00:13:25,839 --> 00:13:30,399
so when we use openspi as the payload

00:13:28,560 --> 00:13:32,320
open sbi serves those calls

00:13:30,399 --> 00:13:34,160
um we don't have any code in our boot to

00:13:32,320 --> 00:13:37,200
serve open sbi calls

00:13:34,160 --> 00:13:40,320
minivan linux are in m mode

00:13:37,200 --> 00:13:40,320
it doesn't require that

00:13:40,560 --> 00:13:49,199
so if you wanted open sp calls you just

00:13:42,880 --> 00:13:52,320
use open sbi as a payload

00:13:49,199 --> 00:13:55,360
just as a payload so it's a binary blob

00:13:52,320 --> 00:13:55,360
yeah we just jump to it

00:14:01,600 --> 00:14:04,399
any other questions

00:14:05,279 --> 00:14:08,160
oh here we go

00:14:11,519 --> 00:14:15,680
okay so that's where things have changed

00:14:13,920 --> 00:14:19,519
have a backup slide for this year

00:14:15,680 --> 00:14:22,800
so this is our x86 policy

00:14:19,519 --> 00:14:25,360
um it's it's uh we

00:14:22,800 --> 00:14:27,600
put some thought into exactly what the

00:14:25,360 --> 00:14:29,519
policy should be the problem is for x86

00:14:27,600 --> 00:14:31,440
platforms nowadays you need some sort of

00:14:29,519 --> 00:14:32,959
closed source blobs

00:14:31,440 --> 00:14:34,639
um we're working on like sort of a

00:14:32,959 --> 00:14:37,120
measure to measure it

00:14:34,639 --> 00:14:38,880
um like what percent of the what percent

00:14:37,120 --> 00:14:40,320
of the the firmware is close to us how

00:14:38,880 --> 00:14:42,079
much of it is open source

00:14:40,320 --> 00:14:44,000
um but you could find this policy on the

00:14:42,079 --> 00:14:48,160
github um i think

00:14:44,000 --> 00:14:49,760
ron is sort of starting work on this

00:14:48,160 --> 00:14:51,519
yeah but the difficulty is you can't

00:14:49,760 --> 00:14:59,519
make a fully open source

00:14:51,519 --> 00:15:13,040
x86 system at this point

00:14:59,519 --> 00:15:13,040

YouTube URL: https://www.youtube.com/watch?v=DoK6lYnISc4


