Title: Monitoring Legacy Java Applications with Prometheus
Publication date: 2018-02-04
Playlist: FOSDEM 2018
Description: 
	by Fabian StÃ¤ber

At: FOSDEM 2018
Room: UD2.120 (Chavanne)
Scheduled start: 2018-02-03 11:50:00+01
Captions: 
	00:00:05,790 --> 00:00:09,590
No

00:00:07,400 --> 00:00:12,110
[Applause]

00:00:09,590 --> 00:00:13,850
again my name is Fabiana and within the

00:00:12,110 --> 00:00:15,830
next half an hour I'm going to talk

00:00:13,850 --> 00:00:19,640
about monitoring legacy Java

00:00:15,830 --> 00:00:21,260
applications with Prometheus so what is

00:00:19,640 --> 00:00:23,900
the best way to monitor Java

00:00:21,260 --> 00:00:25,699
applications with promises sorry for my

00:00:23,900 --> 00:00:28,430
voice I have a bit of a cold I hope they

00:00:25,699 --> 00:00:32,029
can make it through half an hour so the

00:00:28,430 --> 00:00:34,970
best thing you can do is to take the

00:00:32,029 --> 00:00:37,430
compromises client library for Java edit

00:00:34,970 --> 00:00:41,000
as a dependency to your Java project and

00:00:37,430 --> 00:00:43,130
just money by your add metrics directly

00:00:41,000 --> 00:00:44,600
to your source code okay this is always

00:00:43,130 --> 00:00:46,579
the best option this is the most

00:00:44,600 --> 00:00:48,829
flexible one the most powerful one and

00:00:46,579 --> 00:00:51,020
the safest one and whenever you can

00:00:48,829 --> 00:00:51,710
modify your source code this is what you

00:00:51,020 --> 00:00:54,110
should do

00:00:51,710 --> 00:00:55,969
however sometimes it's not possible

00:00:54,110 --> 00:00:57,649
maybe because you have to run an

00:00:55,969 --> 00:01:00,530
application but you don't own this much

00:00:57,649 --> 00:01:02,809
code or even if the application is

00:01:00,530 --> 00:01:05,600
developed within your company it might

00:01:02,809 --> 00:01:08,300
be that your wishes of having prometheus

00:01:05,600 --> 00:01:10,280
metrics do not have the priority so that

00:01:08,300 --> 00:01:13,070
you can get your code changes into

00:01:10,280 --> 00:01:15,440
production and there are a few options

00:01:13,070 --> 00:01:18,259
what you can do when that happens and

00:01:15,440 --> 00:01:20,479
within the next half an hour I'm going

00:01:18,259 --> 00:01:23,390
to talk about a few of the options that

00:01:20,479 --> 00:01:26,300
you have we start off with a log file

00:01:23,390 --> 00:01:27,979
monitoring example then we go ahead and

00:01:26,300 --> 00:01:30,740
have a look at the black box money to

00:01:27,979 --> 00:01:32,810
black box six order then I'm going to

00:01:30,740 --> 00:01:35,479
talk a little bit about J mix teach

00:01:32,810 --> 00:01:37,399
other management extensions and finally

00:01:35,479 --> 00:01:40,340
I'm going to give you a quick demo on

00:01:37,399 --> 00:01:42,800
how to write your own do-it-yourself

00:01:40,340 --> 00:01:47,149
Java agent for Prometheus monitoring

00:01:42,800 --> 00:01:49,520
okay so let's start as an example

00:01:47,149 --> 00:01:51,470
application I implemented this little

00:01:49,520 --> 00:01:53,479
thing here it's a spring boot

00:01:51,470 --> 00:01:56,630
application with some little rest

00:01:53,479 --> 00:01:59,390
interfaces so if I click on this here if

00:01:56,630 --> 00:02:01,819
it's the slash hello / Alice endpoint

00:01:59,390 --> 00:02:05,479
and shows the result down here I can

00:02:01,819 --> 00:02:07,759
also say hello to Bob I have a small end

00:02:05,479 --> 00:02:10,550
point that just throws an exception in

00:02:07,759 --> 00:02:13,020
the Java code which results in an HTTP

00:02:10,550 --> 00:02:16,230
500 internal server error

00:02:13,020 --> 00:02:18,510
and I have one that just sleeps a second

00:02:16,230 --> 00:02:20,460
before it responds and we are going to

00:02:18,510 --> 00:02:22,230
monitor this application now with

00:02:20,460 --> 00:02:23,420
different tools within the next half an

00:02:22,230 --> 00:02:27,780
hour okay

00:02:23,420 --> 00:02:30,060
so let's start first up is log five

00:02:27,780 --> 00:02:32,130
monitoring there are a few tools

00:02:30,060 --> 00:02:35,250
available the most popular one is by

00:02:32,130 --> 00:02:37,320
Google it's for gem tail it's also in

00:02:35,250 --> 00:02:41,370
the official Google repository which

00:02:37,320 --> 00:02:43,830
obviously helps to make it popular there

00:02:41,370 --> 00:02:45,900
are small independent tools as well for

00:02:43,830 --> 00:02:49,170
example there's one which is the croc

00:02:45,900 --> 00:02:51,540
exporter and I'm going to use this in my

00:02:49,170 --> 00:02:54,390
demo and I'm also the author of croc

00:02:51,540 --> 00:02:56,250
espada but I'm not going too deep into

00:02:54,390 --> 00:02:57,900
like configuration details so most of

00:02:56,250 --> 00:02:59,580
what I'm going to show applies in

00:02:57,900 --> 00:03:02,970
general to log file monitoring with

00:02:59,580 --> 00:03:05,640
promises okay so let's have a quick look

00:03:02,970 --> 00:03:08,220
at the log file of the application we

00:03:05,640 --> 00:03:11,460
see a stack trace here which is of

00:03:08,220 --> 00:03:15,750
course because I hit this left row

00:03:11,460 --> 00:03:18,090
endpoint so that gave me a little lock

00:03:15,750 --> 00:03:20,130
line with an arrow here I think

00:03:18,090 --> 00:03:22,500
unexpected heaven follower happened

00:03:20,130 --> 00:03:24,450
followed by the stack trace but most

00:03:22,500 --> 00:03:26,610
regular lock lines look like this so if

00:03:24,450 --> 00:03:29,520
I click on Bob and Ellis for a few times

00:03:26,610 --> 00:03:32,580
I can generate some lock lines and they

00:03:29,520 --> 00:03:34,110
all have this format okay it's broken

00:03:32,580 --> 00:03:36,630
line here with this resolution but I

00:03:34,110 --> 00:03:38,460
have a timestamp threat information the

00:03:36,630 --> 00:03:41,100
lock level which is info in most cases

00:03:38,460 --> 00:03:43,680
name of the Java class that lock dissing

00:03:41,100 --> 00:03:45,780
some information about the HTTP method

00:03:43,680 --> 00:03:49,800
and path and the duration how long it

00:03:45,780 --> 00:03:51,830
took to generate the response okay so at

00:03:49,800 --> 00:03:54,180
this level when you have something like

00:03:51,830 --> 00:03:57,000
semi-structured or unstructured lock

00:03:54,180 --> 00:03:59,340
data like this but basically all of the

00:03:57,000 --> 00:04:01,830
tools tool that you use to to monitor

00:03:59,340 --> 00:04:03,720
these things is you create regular

00:04:01,830 --> 00:04:06,060
expressions that match the lock lines

00:04:03,720 --> 00:04:09,209
and then you extract metrics out of the

00:04:06,060 --> 00:04:11,070
regular expression matches okay so if

00:04:09,209 --> 00:04:16,200
you look at how this works with the croc

00:04:11,070 --> 00:04:18,299
exporter it works like this so this down

00:04:16,200 --> 00:04:20,459
here is the most important line this is

00:04:18,299 --> 00:04:23,220
the regular expression the only specific

00:04:20,459 --> 00:04:24,000
thing about the croc exporter approaches

00:04:23,220 --> 00:04:25,830
if you

00:04:24,000 --> 00:04:28,380
regular expressions a lot they tend to

00:04:25,830 --> 00:04:30,180
become a bit unreadable and what you can

00:04:28,380 --> 00:04:32,850
do with rock is you can define regular

00:04:30,180 --> 00:04:34,920
expressions snippets like for example

00:04:32,850 --> 00:04:37,290
you say this snippet should be made

00:04:34,920 --> 00:04:39,510
available under the name path okay and

00:04:37,290 --> 00:04:41,490
then instead of writing this year in

00:04:39,510 --> 00:04:44,700
your regular expression you can also

00:04:41,490 --> 00:04:46,950
repair if air to the path that you

00:04:44,700 --> 00:04:48,480
defined above okay apart from that it's

00:04:46,950 --> 00:04:49,830
just a plain regular expression so you

00:04:48,480 --> 00:04:52,020
start off with anything

00:04:49,830 --> 00:04:53,910
then comes the LOC level and the name of

00:04:52,020 --> 00:04:56,640
the Java class this is just literal

00:04:53,910 --> 00:04:58,740
string here then we match the path then

00:04:56,640 --> 00:05:01,020
the duration and any number that could

00:04:58,740 --> 00:05:03,360
be the duration okay so if we define

00:05:01,020 --> 00:05:06,090
this and we define a counter might

00:05:03,360 --> 00:05:08,250
metric for this in Prometheus what we

00:05:06,090 --> 00:05:10,800
will see is just a counter counting the

00:05:08,250 --> 00:05:12,450
number of lines that matches these the

00:05:10,800 --> 00:05:16,470
this regular expression so if you have a

00:05:12,450 --> 00:05:21,890
look at it for exporter - one fake a one

00:05:16,470 --> 00:05:25,590
and go to localhost port

00:05:21,890 --> 00:05:30,500
nine one four four slash metrics so what

00:05:25,590 --> 00:05:30,500
we see down here make it a bit bigger so

00:05:30,950 --> 00:05:36,120
what we see down here is just this

00:05:33,419 --> 00:05:37,860
metric here it tells us we have 17 lines

00:05:36,120 --> 00:05:40,830
matching this regular expressions in our

00:05:37,860 --> 00:05:43,169
log file this is not very useful of

00:05:40,830 --> 00:05:44,729
course what we need at least is some

00:05:43,169 --> 00:05:47,340
information about the number of errors

00:05:44,729 --> 00:05:49,680
and warnings and and info messages and

00:05:47,340 --> 00:05:52,500
the way you typically do this in

00:05:49,680 --> 00:05:56,400
Prometheus is with labels okay you're

00:05:52,500 --> 00:05:59,520
going to say I want to extend my metric

00:05:56,400 --> 00:06:01,880
here I'm going to use labels and I want

00:05:59,520 --> 00:06:04,979
to have the lock level of the label I

00:06:01,880 --> 00:06:07,590
also want to have the path as a label

00:06:04,979 --> 00:06:08,910
and in in brackets Paulo you can just do

00:06:07,590 --> 00:06:10,680
it like this you say the stuff that

00:06:08,910 --> 00:06:12,570
matches this regular expression snippet

00:06:10,680 --> 00:06:15,030
should be the level the stuff that

00:06:12,570 --> 00:06:16,979
matches this regular expression snippet

00:06:15,030 --> 00:06:19,200
should be the path and then you refer to

00:06:16,979 --> 00:06:24,770
it down here you say okay this is my

00:06:19,200 --> 00:06:27,240
level and this is my path these

00:06:24,770 --> 00:06:29,370
expressions here does actually a little

00:06:27,240 --> 00:06:31,919
templating language built into the go

00:06:29,370 --> 00:06:33,780
programming language it's a pretty easy

00:06:31,919 --> 00:06:35,669
templating thing and then this is used

00:06:33,780 --> 00:06:37,320
here also it's also used in other

00:06:35,669 --> 00:06:40,410
programs that are written in go

00:06:37,320 --> 00:06:41,940
it's just like pretty pretty simple

00:06:40,410 --> 00:06:44,460
templating language for configuration

00:06:41,940 --> 00:06:46,410
purposes and if we started now what

00:06:44,460 --> 00:06:49,320
we're going to see is more useful

00:06:46,410 --> 00:06:52,500
information now we have those metrics

00:06:49,320 --> 00:06:56,220
over here okay we see we have one error

00:06:52,500 --> 00:06:58,440
we have seven info messages with path a

00:06:56,220 --> 00:07:01,080
hello Alice we have eight ones with path

00:06:58,440 --> 00:07:04,140
hello pal Bob and so on and this covers

00:07:01,080 --> 00:07:06,150
already 80% of what you need in real

00:07:04,140 --> 00:07:08,070
life log file monitoring with parameters

00:07:06,150 --> 00:07:10,980
okay because now you can import this

00:07:08,070 --> 00:07:13,050
injury Prometheus and then trigger some

00:07:10,980 --> 00:07:15,330
alerts whenever errors occur or watch

00:07:13,050 --> 00:07:17,040
your warnings and when they reach a

00:07:15,330 --> 00:07:20,700
certain threshold you trigger alerts and

00:07:17,040 --> 00:07:24,960
so on okay I have one word of advice

00:07:20,700 --> 00:07:27,120
about using the path here what actually

00:07:24,960 --> 00:07:29,610
is going to happen in the Prometheus

00:07:27,120 --> 00:07:33,210
server is that for each line that you

00:07:29,610 --> 00:07:35,910
see here in this SK representation there

00:07:33,210 --> 00:07:38,850
is a time series created internally

00:07:35,910 --> 00:07:41,430
within the Prometheus server okay so

00:07:38,850 --> 00:07:44,280
whenever you have a new combination of

00:07:41,430 --> 00:07:46,110
label values like a new path a new time

00:07:44,280 --> 00:07:49,020
series will be created within the

00:07:46,110 --> 00:07:51,450
promises server and Prometheus is pretty

00:07:49,020 --> 00:07:53,580
efficient with handling a lot of time

00:07:51,450 --> 00:07:55,170
series so if you have like thousands of

00:07:53,580 --> 00:07:57,960
different time series it shouldn't be a

00:07:55,170 --> 00:08:00,090
problem but if you have millions of

00:07:57,960 --> 00:08:02,730
different prime series you then should

00:08:00,090 --> 00:08:04,680
at some point hit the performance

00:08:02,730 --> 00:08:06,810
threshold that you have with the

00:08:04,680 --> 00:08:09,840
promises server okay so what that means

00:08:06,810 --> 00:08:12,510
is if you put something like the path in

00:08:09,840 --> 00:08:14,670
here it's a very good idea if you have a

00:08:12,510 --> 00:08:16,800
limited number of paths because it shows

00:08:14,670 --> 00:08:19,230
you like which rest endpoint is called

00:08:16,800 --> 00:08:21,990
how often if you have something like a

00:08:19,230 --> 00:08:24,360
unique request ID or something as part

00:08:21,990 --> 00:08:26,700
of your path then it's a bad idea to use

00:08:24,360 --> 00:08:28,770
it as part of a label because then with

00:08:26,700 --> 00:08:31,050
each new request ID you will generate a

00:08:28,770 --> 00:08:33,479
new time series and eventually will have

00:08:31,050 --> 00:08:36,030
so many time serious than Eve that even

00:08:33,479 --> 00:08:37,860
the very great and proficient Prometheus

00:08:36,030 --> 00:08:41,490
server has problems dealing with this

00:08:37,860 --> 00:08:44,099
okay so take care that labels should

00:08:41,490 --> 00:08:46,560
have somehow a limited scope like in the

00:08:44,099 --> 00:08:48,150
order of magnitudes of not more than

00:08:46,560 --> 00:08:49,320
thousand different values or something

00:08:48,150 --> 00:08:53,790
okay

00:08:49,320 --> 00:08:55,529
good so this covers already like 90

00:08:53,790 --> 00:08:57,720
percent or 80 percent of what you need

00:08:55,529 --> 00:08:59,880
in real life I still want to talk a

00:08:57,720 --> 00:09:02,790
little bit about this duration value

00:08:59,880 --> 00:09:04,500
because it's a good good opportunity to

00:09:02,790 --> 00:09:06,810
also highlight the difference between

00:09:04,500 --> 00:09:08,970
locks live monitoring with Prometheus

00:09:06,810 --> 00:09:10,740
and blocks live monitoring with the

00:09:08,970 --> 00:09:13,649
elastic step okay

00:09:10,740 --> 00:09:16,560
the elastic seg is like the most popular

00:09:13,649 --> 00:09:19,399
log file monitoring tool for Java

00:09:16,560 --> 00:09:22,709
applications it's used in a lot of

00:09:19,399 --> 00:09:24,569
project and the way it works you have

00:09:22,709 --> 00:09:26,610
elastic search I guess most of you know

00:09:24,569 --> 00:09:28,440
that it's a full-text search engine a

00:09:26,610 --> 00:09:30,420
clustered full-text search engine and

00:09:28,440 --> 00:09:32,970
you have little programs called beats

00:09:30,420 --> 00:09:35,069
those beats take lock lines and ship

00:09:32,970 --> 00:09:37,290
them to the elastic search cluster where

00:09:35,069 --> 00:09:39,360
the lock content is indexed and then you

00:09:37,290 --> 00:09:41,310
have a user interface called Cabana

00:09:39,360 --> 00:09:44,430
and you can use Cabana for two things

00:09:41,310 --> 00:09:46,199
one is full text queries so you clearly

00:09:44,430 --> 00:09:48,620
for error messages and so on and and

00:09:46,199 --> 00:09:51,899
find your corresponding log files and

00:09:48,620 --> 00:09:54,209
the other is aggregation which is

00:09:51,899 --> 00:09:56,399
similar to what Prometheus does so for

00:09:54,209 --> 00:09:58,649
example if you index those duration

00:09:56,399 --> 00:10:00,779
values in your elastic search you can

00:09:58,649 --> 00:10:02,760
run aggregations that give me the median

00:10:00,779 --> 00:10:07,350
value that was observed within the last

00:10:02,760 --> 00:10:09,420
two hours or so okay so question is if

00:10:07,350 --> 00:10:10,980
you go with a lot v monitoring with

00:10:09,420 --> 00:10:13,920
Prometheus do you still need your

00:10:10,980 --> 00:10:19,110
elastic stack answer is yes you need it

00:10:13,920 --> 00:10:20,490
because because of the error messages so

00:10:19,110 --> 00:10:23,370
if you have a stack trace like this

00:10:20,490 --> 00:10:25,350
let's scroll up a little bit like for

00:10:23,370 --> 00:10:27,029
example in our line like this what

00:10:25,350 --> 00:10:28,980
developers want to do they want to

00:10:27,029 --> 00:10:31,290
search for it and then find the error

00:10:28,980 --> 00:10:33,360
message here okay and if you do logging

00:10:31,290 --> 00:10:37,019
a little bit more clever you would maybe

00:10:33,360 --> 00:10:38,730
look a like unique request ID with each

00:10:37,019 --> 00:10:40,649
lock line that is associated with a

00:10:38,730 --> 00:10:42,990
request and then you find the request ID

00:10:40,649 --> 00:10:45,209
and search for it in hapana and then you

00:10:42,990 --> 00:10:48,600
find all the lock lines that have to do

00:10:45,209 --> 00:10:50,130
with how it came to this error how it

00:10:48,600 --> 00:10:52,560
occurred and this is something that

00:10:50,130 --> 00:10:54,779
Prometheus doesn't do okay Prometheus

00:10:52,560 --> 00:10:57,480
has nothing to do with full text or text

00:10:54,779 --> 00:10:59,610
or messages that just about numbers and

00:10:57,480 --> 00:11:01,970
time series so you still need the

00:10:59,610 --> 00:11:03,289
elastic stack

00:11:01,970 --> 00:11:06,589
the other question is what's the

00:11:03,289 --> 00:11:10,729
difference between monitoring those

00:11:06,589 --> 00:11:12,889
duration values with Prometheus and

00:11:10,729 --> 00:11:15,529
monitoring those duration values with

00:11:12,889 --> 00:11:16,879
the aggregation capabilities of the

00:11:15,529 --> 00:11:19,429
elastic stack okay

00:11:16,879 --> 00:11:22,339
and the difference is with the elastic

00:11:19,429 --> 00:11:24,529
stake you ship each and every observe

00:11:22,339 --> 00:11:28,549
block line into the elastic search

00:11:24,529 --> 00:11:31,429
cluster okay so each individual duration

00:11:28,549 --> 00:11:33,229
value that you have here is available to

00:11:31,429 --> 00:11:35,239
elastic search and the aggregation

00:11:33,229 --> 00:11:37,309
happens on the fly when you run a query

00:11:35,239 --> 00:11:39,579
okay you'd say give me the median in the

00:11:37,309 --> 00:11:43,009
last two hours and then those values are

00:11:39,579 --> 00:11:45,049
aggregated but Prometheus they might the

00:11:43,009 --> 00:11:46,759
mindset is different you never ship each

00:11:45,049 --> 00:11:49,039
and every observed value to the

00:11:46,759 --> 00:11:51,499
Prometheus server the Prometheus pulse

00:11:49,039 --> 00:11:53,629
every I don't know minute or half a

00:11:51,499 --> 00:11:57,319
minute or so however you configure it

00:11:53,629 --> 00:12:00,559
and then it expects aggregated data of

00:11:57,319 --> 00:12:04,069
what happened and so what's going to

00:12:00,559 --> 00:12:06,169
happen is you don't ship each individual

00:12:04,069 --> 00:12:08,569
observed duration value you aggregate

00:12:06,169 --> 00:12:10,729
the data and then provide the aggregated

00:12:08,569 --> 00:12:13,159
result to the Prometheus server and the

00:12:10,729 --> 00:12:18,049
Prometheus server only sees aggregated

00:12:13,159 --> 00:12:19,399
results so let's look at an example how

00:12:18,049 --> 00:12:21,499
would you do this so you basically

00:12:19,399 --> 00:12:23,839
choose a metric that's good with

00:12:21,499 --> 00:12:25,489
aggregation there is one for example

00:12:23,839 --> 00:12:29,169
that's a summary so I'm going to change

00:12:25,489 --> 00:12:31,729
my metric type from calendar to summary

00:12:29,169 --> 00:12:33,439
and then you just tell it which value

00:12:31,729 --> 00:12:37,009
should be aggregated okay so I'm going

00:12:33,439 --> 00:12:40,069
to say my well you should be I can say

00:12:37,009 --> 00:12:43,309
the number that I have done up here

00:12:40,069 --> 00:12:46,279
should be under the name duration for

00:12:43,309 --> 00:12:48,729
example you raishin okay

00:12:46,279 --> 00:12:51,379
so I highlight it so if you can read it

00:12:48,729 --> 00:12:55,069
and then I can use it down here I can

00:12:51,379 --> 00:12:57,379
just say duration so now I have an

00:12:55,069 --> 00:12:59,209
aggregation metric called a summary and

00:12:57,379 --> 00:13:04,399
I'm going to use the duration as the

00:12:59,209 --> 00:13:07,459
value for aggregating oops so let's save

00:13:04,399 --> 00:13:10,279
it and start it again and if we look at

00:13:07,459 --> 00:13:12,470
the metrics right now what we see is

00:13:10,279 --> 00:13:14,920
something like this we have still our

00:13:12,470 --> 00:13:17,380
LOC level and our path

00:13:14,920 --> 00:13:19,570
also have those quantiles here and what

00:13:17,380 --> 00:13:23,290
that means one tile Oh dot five means

00:13:19,570 --> 00:13:25,300
half of the requests with block-level

00:13:23,290 --> 00:13:27,610
info and the path hello Alice

00:13:25,300 --> 00:13:29,110
they're faster than this value and half

00:13:27,610 --> 00:13:30,070
of the requests were slower than this

00:13:29,110 --> 00:13:32,589
value okay

00:13:30,070 --> 00:13:35,290
one tile odor nine means half of the

00:13:32,589 --> 00:13:37,750
request if 90% were faster than this and

00:13:35,290 --> 00:13:40,449
10% slower than this and so on so this

00:13:37,750 --> 00:13:42,160
is an aggregation value and this is the

00:13:40,449 --> 00:13:44,649
data that's provided to the premises

00:13:42,160 --> 00:13:46,480
server summaries are not the only

00:13:44,649 --> 00:13:49,720
metrics for aggregation there are also

00:13:46,480 --> 00:13:51,160
histograms each of those have their pros

00:13:49,720 --> 00:13:52,660
and cons and there's a very good

00:13:51,160 --> 00:13:54,130
documentation highlighting the

00:13:52,660 --> 00:13:56,170
differences between summaries and

00:13:54,130 --> 00:13:58,420
histograms and meant to use what but the

00:13:56,170 --> 00:14:00,250
the principle is you a create the data

00:13:58,420 --> 00:14:04,720
first and then provide aggregated data

00:14:00,250 --> 00:14:06,850
to the Prometheus server okay I think I

00:14:04,720 --> 00:14:08,980
would take questions after the talk so

00:14:06,850 --> 00:14:13,990
because otherwise it will be a bit busy

00:14:08,980 --> 00:14:18,040
with the half hour okay so that's it for

00:14:13,990 --> 00:14:20,290
the log file monitoring example let's go

00:14:18,040 --> 00:14:22,060
onto something totally different

00:14:20,290 --> 00:14:24,670
let's have a quick look at the black box

00:14:22,060 --> 00:14:27,010
exporter this will be very quick because

00:14:24,670 --> 00:14:32,470
there's not much to say about the black

00:14:27,010 --> 00:14:34,600
box exporter actually have a little

00:14:32,470 --> 00:14:36,220
script that prints do you also the way

00:14:34,600 --> 00:14:38,680
it works is you start the black box

00:14:36,220 --> 00:14:42,250
exporter in in my case it will start up

00:14:38,680 --> 00:14:45,070
under this URL okay and then as a URL

00:14:42,250 --> 00:14:48,399
parameter you provide the probe that is

00:14:45,070 --> 00:14:50,740
going to do okay and this is my actual

00:14:48,399 --> 00:14:52,600
endpoint that I'm going to probe so this

00:14:50,740 --> 00:14:54,370
is the host name because my demo is

00:14:52,600 --> 00:14:57,250
running in a docker container so it had

00:14:54,370 --> 00:14:59,860
such a cryptic hostname port 8080 and

00:14:57,250 --> 00:15:03,370
this is the API echad probe this is the

00:14:59,860 --> 00:15:05,170
sleep 1000 milliseconds API and then as

00:15:03,370 --> 00:15:09,279
the second parameter and provide a

00:15:05,170 --> 00:15:11,050
module and the module HTTP 200 is like

00:15:09,279 --> 00:15:14,050
the most important module because it

00:15:11,050 --> 00:15:17,949
just checks does the endpoint reply with

00:15:14,050 --> 00:15:20,290
200 okay or not okay so let's try it I

00:15:17,949 --> 00:15:22,180
just saw the black box exporter it

00:15:20,290 --> 00:15:25,540
doesn't really have any application

00:15:22,180 --> 00:15:26,870
specific configuration so if I copy and

00:15:25,540 --> 00:15:29,810
paste my url

00:15:26,870 --> 00:15:31,970
year I'm going to see the so the most

00:15:29,810 --> 00:15:34,430
important metric is this probe success

00:15:31,970 --> 00:15:37,670
one that just tells me okay the probe

00:15:34,430 --> 00:15:39,350
was successful server replied with 200

00:15:37,670 --> 00:15:42,290
okay so it's a boolean value if it's

00:15:39,350 --> 00:15:45,070
unsuccessful it's 0 okay and there's

00:15:42,290 --> 00:15:49,130
some additional information for example

00:15:45,070 --> 00:15:52,100
the request duration there is it like

00:15:49,130 --> 00:15:53,779
here okay that tells me that it took a

00:15:52,100 --> 00:15:56,660
little bit more than a second for this

00:15:53,779 --> 00:15:58,580
endpoint to reply this is the most

00:15:56,660 --> 00:16:00,440
simple thing you can do it's the good

00:15:58,580 --> 00:16:02,029
thing is it always works so even if your

00:16:00,440 --> 00:16:04,400
application does not provide lock lines

00:16:02,029 --> 00:16:06,470
or does not have J mix or nothing else

00:16:04,400 --> 00:16:09,620
you can always still use black box

00:16:06,470 --> 00:16:12,080
monitoring from the mindset it's very

00:16:09,620 --> 00:16:13,910
similar to Nagios checks okay you just

00:16:12,080 --> 00:16:16,190
run a check against the application if

00:16:13,910 --> 00:16:18,170
it's responding it's okay if not you can

00:16:16,190 --> 00:16:20,720
trigger an alert or something

00:16:18,170 --> 00:16:23,360
however it's not very powerful so it the

00:16:20,720 --> 00:16:25,700
application might easily return 200 okay

00:16:23,360 --> 00:16:27,500
at some endpoint but it still has

00:16:25,700 --> 00:16:33,140
problems and you won't figure it out

00:16:27,500 --> 00:16:37,850
that way okay good that's for black box

00:16:33,140 --> 00:16:39,830
monitoring next up is JMX the java

00:16:37,850 --> 00:16:43,430
management extensions i guess most of

00:16:39,830 --> 00:16:46,010
you have heard of j mix it's something

00:16:43,430 --> 00:16:48,560
like a remote procedure call protocol I

00:16:46,010 --> 00:16:51,589
would say which is built into Java and

00:16:48,560 --> 00:16:53,750
available with each Java program and it

00:16:51,589 --> 00:16:56,089
has been around with Java for a very

00:16:53,750 --> 00:16:58,400
long time maybe since the beginning even

00:16:56,089 --> 00:16:59,600
I don't know but very long and the way

00:16:58,400 --> 00:17:04,810
it works

00:16:59,600 --> 00:17:04,810
just let me start a chain exclaimed here

00:17:06,130 --> 00:17:12,140
don't know if the resolution will make

00:17:08,449 --> 00:17:14,390
it so this is the Java visual VM which

00:17:12,140 --> 00:17:16,970
is a standard tool included in the Java

00:17:14,390 --> 00:17:19,130
development kit so every Java developer

00:17:16,970 --> 00:17:21,079
has this on their laptop maybe they

00:17:19,130 --> 00:17:24,170
don't know it but it's part of the Java

00:17:21,079 --> 00:17:26,480
compiler so they have it and what you

00:17:24,170 --> 00:17:29,360
can do with it you can connect to a

00:17:26,480 --> 00:17:33,050
program that exposes trail expands you

00:17:29,360 --> 00:17:35,179
can just let have a look at the mbeans

00:17:33,050 --> 00:17:37,100
and there is some J mix information

00:17:35,179 --> 00:17:38,289
available about different things okay

00:17:37,100 --> 00:17:40,149
first of all

00:17:38,289 --> 00:17:42,100
the Java Virtual Machine by itself

00:17:40,149 --> 00:17:43,720
provide some information for example

00:17:42,100 --> 00:17:46,149
like information about garbage

00:17:43,720 --> 00:17:48,159
collection heap usage CPU usage and so

00:17:46,149 --> 00:17:51,340
on and typically with web applications

00:17:48,159 --> 00:17:53,440
you have a servlet container in this

00:17:51,340 --> 00:17:56,980
case it's Tomcat because spring boot

00:17:53,440 --> 00:17:59,440
applications always use Tomcat and it

00:17:56,980 --> 00:18:00,880
provides some information like for

00:17:59,440 --> 00:18:03,010
example the globe global request

00:18:00,880 --> 00:18:05,409
processor here ok it tells me error

00:18:03,010 --> 00:18:07,830
count 1 which means that there was one

00:18:05,409 --> 00:18:09,340
error ok if they go back to the

00:18:07,830 --> 00:18:11,679
application

00:18:09,340 --> 00:18:15,269
hit the slash throw endpoint which just

00:18:11,679 --> 00:18:18,690
throws the exception internally and now

00:18:15,269 --> 00:18:22,470
there's a refresh button down here

00:18:18,690 --> 00:18:25,840
which I can't reach right now because

00:18:22,470 --> 00:18:30,130
there it is ok if i refresh it goes up

00:18:25,840 --> 00:18:32,320
to 2 good so this is JMX and there's a

00:18:30,130 --> 00:18:35,769
tool called the JMX exporter that you

00:18:32,320 --> 00:18:43,360
can use to read this data let's have a

00:18:35,769 --> 00:18:46,179
look at how it is configured so it's

00:18:43,360 --> 00:18:48,789
basically the read is not very readable

00:18:46,179 --> 00:18:54,159
so it's basically a collection of very

00:18:48,789 --> 00:18:55,600
huge regular expressions you don't maybe

00:18:54,159 --> 00:18:57,070
don't need to write them yourself

00:18:55,600 --> 00:18:59,019
because there's some predefined

00:18:57,070 --> 00:19:01,450
configurations for things you typically

00:18:59,019 --> 00:19:03,639
use like for example this configuration

00:19:01,450 --> 00:19:06,669
for grabbing Jay makes metrics from

00:19:03,639 --> 00:19:09,220
Tomcat is part of the Jay makes exporter

00:19:06,669 --> 00:19:11,080
distribution so you maybe can just go

00:19:09,220 --> 00:19:12,639
along with that but when you look at it

00:19:11,080 --> 00:19:14,830
so what what what's actually happening

00:19:12,639 --> 00:19:16,570
so this is basically the part that I

00:19:14,830 --> 00:19:18,730
clicked in my tray next to it so if I

00:19:16,570 --> 00:19:20,799
looked at look at it so that's Tomcat

00:19:18,730 --> 00:19:22,570
global request processor this and then

00:19:20,799 --> 00:19:24,370
the error count and here we have

00:19:22,570 --> 00:19:26,110
something starting with Tomcat and

00:19:24,370 --> 00:19:28,450
ending with error count and if you

00:19:26,110 --> 00:19:32,289
analyze it it's kind of going down this

00:19:28,450 --> 00:19:34,809
path in industry ok and then there are

00:19:32,289 --> 00:19:37,990
some capture groups which are used here

00:19:34,809 --> 00:19:41,830
to actually extract metrics out of of

00:19:37,990 --> 00:19:43,120
what it's found with dynamics so I don't

00:19:41,830 --> 00:19:45,580
need to start it right now because you

00:19:43,120 --> 00:19:47,830
actually attach it to the application on

00:19:45,580 --> 00:19:49,870
startup and I actually did this when I

00:19:47,830 --> 00:19:51,690
started my application so it's already

00:19:49,870 --> 00:19:54,759
running on port

00:19:51,690 --> 00:19:57,789
localhost now in now one two three four

00:19:54,759 --> 00:20:00,700
are used okay and if you looked at here

00:19:57,789 --> 00:20:02,200
our account here it is if you look at

00:20:00,700 --> 00:20:04,690
the error account you see it's the same

00:20:02,200 --> 00:20:07,929
value it's the value too okay those

00:20:04,690 --> 00:20:11,110
labels here port 8080 and protocol HTTP

00:20:07,929 --> 00:20:12,970
new i/o this was parsed with capture

00:20:11,110 --> 00:20:18,190
groups out of this little thing here

00:20:12,970 --> 00:20:22,629
HTTP new IO ad okay so one word of

00:20:18,190 --> 00:20:25,809
advice about the jmx exporter J makes is

00:20:22,629 --> 00:20:27,489
actually it's really more like a remote

00:20:25,809 --> 00:20:29,320
procedure called protocol okay it's not

00:20:27,489 --> 00:20:31,419
a read only thing you can write values

00:20:29,320 --> 00:20:36,129
as well which is not relevant for

00:20:31,419 --> 00:20:37,720
monitoring but it's originally it was

00:20:36,129 --> 00:20:40,539
designed so that you can reconfigure

00:20:37,720 --> 00:20:43,389
applications on the fly okay and what

00:20:40,539 --> 00:20:45,879
that means is whenever you call a JX Ben

00:20:43,389 --> 00:20:48,220
there's no real guarantee what's going

00:20:45,879 --> 00:20:50,049
to happen okay because whatever the

00:20:48,220 --> 00:20:52,210
implementer of that chain makes being

00:20:50,049 --> 00:20:54,489
had in mind can happen when you call it

00:20:52,210 --> 00:20:57,999
so when when you come from a Prometheus

00:20:54,489 --> 00:20:59,980
background you'll use that used to that

00:20:57,999 --> 00:21:02,619
when the Prometheus server Paul's

00:20:59,980 --> 00:21:05,169
metrics from an exporter that's a cheap

00:21:02,619 --> 00:21:06,789
operation okay you just get the data the

00:21:05,169 --> 00:21:09,399
exporter has the data readily available

00:21:06,789 --> 00:21:11,559
and you pull it with appalling train

00:21:09,399 --> 00:21:12,279
expense that's not necessarily the case

00:21:11,559 --> 00:21:14,559
okay

00:21:12,279 --> 00:21:16,359
there can be a expense that have their

00:21:14,559 --> 00:21:18,669
data readily available and just provide

00:21:16,359 --> 00:21:20,320
the data then it's cheap but there can

00:21:18,669 --> 00:21:22,509
be JM experienced when you call them

00:21:20,320 --> 00:21:24,549
they trigger some complex operation or

00:21:22,509 --> 00:21:26,980
maybe even reconfigure something or

00:21:24,549 --> 00:21:28,929
whatever so it just depends on whoever

00:21:26,980 --> 00:21:31,470
implemented that beam so you there's no

00:21:28,929 --> 00:21:34,299
guarantees and you never know and if you

00:21:31,470 --> 00:21:36,159
the the the thing about this regular

00:21:34,299 --> 00:21:38,440
expression approach is of course you

00:21:36,159 --> 00:21:40,690
first need to load the J mix speed then

00:21:38,440 --> 00:21:42,489
you match the regular expression and if

00:21:40,690 --> 00:21:43,840
it doesn't match then you throw the

00:21:42,489 --> 00:21:47,019
result away okay

00:21:43,840 --> 00:21:49,570
so you basically load more Jane expense

00:21:47,019 --> 00:21:53,499
than you would necessarily need at the

00:21:49,570 --> 00:21:55,690
end in your metrics and if you do this

00:21:53,499 --> 00:21:58,029
like with a poly interval of every 15

00:21:55,690 --> 00:22:00,609
seconds or every 30 seconds and you have

00:21:58,029 --> 00:22:03,380
some expensive gym experience in your

00:22:00,609 --> 00:22:05,120
server then you might

00:22:03,380 --> 00:22:06,770
have some significant performance

00:22:05,120 --> 00:22:08,990
penalty with that and there is

00:22:06,770 --> 00:22:11,450
configuration in the J mix exporter

00:22:08,990 --> 00:22:13,309
which is black lists and white lists and

00:22:11,450 --> 00:22:15,260
if you experience problems with that you

00:22:13,309 --> 00:22:17,480
can use black lists and white lists to

00:22:15,260 --> 00:22:19,490
fine tune which Jay makes beans are

00:22:17,480 --> 00:22:20,809
actually exists and which ones are not

00:22:19,490 --> 00:22:23,210
exist okay

00:22:20,809 --> 00:22:26,179
so just have a look at how much load

00:22:23,210 --> 00:22:27,830
here Jay makes palling produces and use

00:22:26,179 --> 00:22:29,360
black lists and white lists to find you

00:22:27,830 --> 00:22:31,280
in that and then it's a good approach

00:22:29,360 --> 00:22:33,470
the good thing is that out-of-the-box

00:22:31,280 --> 00:22:36,140
Java has some really interesting metrics

00:22:33,470 --> 00:22:38,960
heap usage number of I don't know class

00:22:36,140 --> 00:22:40,730
is loaded and CPU usage so it's it's a

00:22:38,960 --> 00:22:46,429
pretty good information that you can get

00:22:40,730 --> 00:22:49,190
out of it ok then let's go to the last

00:22:46,429 --> 00:22:51,289
point which is actually my favorite in

00:22:49,190 --> 00:22:53,929
the moment because it's the most

00:22:51,289 --> 00:22:56,720
powerful and also the most experimental

00:22:53,929 --> 00:22:59,630
how to do your own Java agent for

00:22:56,720 --> 00:23:06,530
Prometheus monitoring so what is a Java

00:22:59,630 --> 00:23:10,010
agent so Java s you my voice so Java as

00:23:06,530 --> 00:23:12,289
you as you know it's something like an

00:23:10,010 --> 00:23:14,179
interpreted language ok its bytecode and

00:23:12,289 --> 00:23:16,340
the bytecode is interpreted on the fly

00:23:14,179 --> 00:23:19,100
in the Java Virtual Machine before it's

00:23:16,340 --> 00:23:21,500
being executed and the Java Virtual

00:23:19,100 --> 00:23:23,600
Machine provides something like an

00:23:21,500 --> 00:23:26,090
interface something like your hook where

00:23:23,600 --> 00:23:27,890
you can write a Java agent the Java

00:23:26,090 --> 00:23:30,860
agent hooks into the process and

00:23:27,890 --> 00:23:33,650
whenever bytecode is is loaded from a

00:23:30,860 --> 00:23:35,720
class file the agent can go ahead and

00:23:33,650 --> 00:23:37,070
modify the bytecode before it's being

00:23:35,720 --> 00:23:38,539
executed ok

00:23:37,070 --> 00:23:41,240
so the code that's actually being

00:23:38,539 --> 00:23:43,010
executed is different from the code that

00:23:41,240 --> 00:23:45,260
was originally implemented in the

00:23:43,010 --> 00:23:47,450
application and one thing you can use

00:23:45,260 --> 00:23:50,960
this for is you can write your own Java

00:23:47,450 --> 00:23:53,299
agent that just puts in calls to the

00:23:50,960 --> 00:23:55,400
promises client library into your

00:23:53,299 --> 00:23:59,030
application if the application didn't

00:23:55,400 --> 00:24:01,220
use the the planned library before ok so

00:23:59,030 --> 00:24:03,590
if you are interested in how to do this

00:24:01,220 --> 00:24:05,539
from from scratch there is a Java

00:24:03,590 --> 00:24:08,419
conference in in Belgium it's called de

00:24:05,539 --> 00:24:10,640
box so last November I did a half an

00:24:08,419 --> 00:24:13,610
hour demo there like how to do such an

00:24:10,640 --> 00:24:16,370
agent from scratch for now I would like

00:24:13,610 --> 00:24:16,860
to show you something that I implemented

00:24:16,370 --> 00:24:19,740
as an

00:24:16,860 --> 00:24:22,080
experiment it's called the Promethea

00:24:19,740 --> 00:24:23,820
that the primate and maven plugin so

00:24:22,080 --> 00:24:25,860
it's a maven plug-in that just helps you

00:24:23,820 --> 00:24:28,470
to do this very quickly and very easily

00:24:25,860 --> 00:24:32,280
so what I have here is a Java project

00:24:28,470 --> 00:24:34,200
this only one single class okay I call

00:24:32,280 --> 00:24:37,559
it a hook because it hooks into other

00:24:34,200 --> 00:24:40,440
classes and what I did here i annotate

00:24:37,559 --> 00:24:42,270
it if it with the classes or interfaces

00:24:40,440 --> 00:24:44,220
that this is going to instrument okay

00:24:42,270 --> 00:24:47,130
and in this example we are going to

00:24:44,220 --> 00:24:49,860
instrument the servlet and the servlet

00:24:47,130 --> 00:24:52,559
filter and those are both standard Java

00:24:49,860 --> 00:24:55,740
interfaces that are always involved when

00:24:52,559 --> 00:24:58,140
you respond to HTTP traffic okay so we

00:24:55,740 --> 00:25:00,030
can monitor HTTP traffic with that and

00:24:58,140 --> 00:25:01,799
then there's a little bit of code to

00:25:00,030 --> 00:25:03,600
setting up the Prometheus metrics that's

00:25:01,799 --> 00:25:06,059
just the same as with the standard

00:25:03,600 --> 00:25:07,770
client library and then I say which

00:25:06,059 --> 00:25:09,690
methods am I going to instrument I'm

00:25:07,770 --> 00:25:11,460
going to say I'm going to instrument the

00:25:09,690 --> 00:25:14,700
service method and the to filter method

00:25:11,460 --> 00:25:16,320
and before one of those methods is

00:25:14,700 --> 00:25:19,290
called I'm just going to measure the

00:25:16,320 --> 00:25:21,150
time take a time stamp and after one of

00:25:19,290 --> 00:25:23,429
those methods is called I'm going to

00:25:21,150 --> 00:25:27,179
collect some metrics like the duration

00:25:23,429 --> 00:25:29,700
from my time stamp HTTP method path HTTP

00:25:27,179 --> 00:25:32,010
status like 200 ok and I'm going to

00:25:29,700 --> 00:25:34,799
maintain my metrics with it so this is

00:25:32,010 --> 00:25:39,660
the only code in this project the other

00:25:34,799 --> 00:25:42,299
thing is the plugin so what it's here

00:25:39,660 --> 00:25:45,270
from agent maven plug-in it's on an from

00:25:42,299 --> 00:25:47,820
agent IO and if you configure that this

00:25:45,270 --> 00:25:50,100
as your in your link it to your

00:25:47,820 --> 00:25:53,790
packaging phase if you just compile your

00:25:50,100 --> 00:26:01,320
project maven package what will come out

00:25:53,790 --> 00:26:02,940
of it is a running agent so let's look

00:26:01,320 --> 00:26:04,980
at the target folder so what we have

00:26:02,940 --> 00:26:06,510
here now is this prom agent per jar and

00:26:04,980 --> 00:26:08,309
this is an agent that's ready if we

00:26:06,510 --> 00:26:10,679
attach to a java application than

00:26:08,309 --> 00:26:13,669
instrumented with these metrics so let's

00:26:10,679 --> 00:26:16,290
just stop the original application and

00:26:13,669 --> 00:26:18,030
start it again with the agent attached

00:26:16,290 --> 00:26:20,490
so it's a specific command line

00:26:18,030 --> 00:26:23,640
parameter - Java agent on the path to

00:26:20,490 --> 00:26:26,179
the Java file and so on and if this is

00:26:23,640 --> 00:26:29,480
up and running it should work as before

00:26:26,179 --> 00:26:33,440
it's just yeah

00:26:29,480 --> 00:26:35,900
hello Ellis it still says hello Ellis

00:26:33,440 --> 00:26:39,470
hello pop and so on so still working but

00:26:35,900 --> 00:26:42,710
if I now go to port 9000 I think 300

00:26:39,470 --> 00:26:45,800
used I get some metrics they look pretty

00:26:42,710 --> 00:26:49,010
similar to before okay HTTP method get

00:26:45,800 --> 00:26:50,810
this is the path status 200 okay what's

00:26:49,010 --> 00:26:55,520
called four times so I clicked the Ellis

00:26:50,810 --> 00:26:57,590
four times right now and this oh I also

00:26:55,520 --> 00:26:59,690
see that I load it jQuery

00:26:57,590 --> 00:27:01,790
min that's part of my user interface

00:26:59,690 --> 00:27:04,940
because I reloaded the application and

00:27:01,790 --> 00:27:06,470
so on okay so this is actually

00:27:04,940 --> 00:27:08,330
interesting because it's a really

00:27:06,470 --> 00:27:10,520
powerful approach because you can

00:27:08,330 --> 00:27:13,130
basically instrument everything like if

00:27:10,520 --> 00:27:16,070
you want to instrument database queries

00:27:13,130 --> 00:27:17,480
you just one instrument this tender JDBC

00:27:16,070 --> 00:27:19,820
interfaces and you've got information

00:27:17,480 --> 00:27:21,980
about that if you want to instrument

00:27:19,820 --> 00:27:24,040
thread pools just know what your thread

00:27:21,980 --> 00:27:26,570
pool costs are and then you can

00:27:24,040 --> 00:27:30,110
instrument that and so on however it's

00:27:26,570 --> 00:27:31,580
really experimental so if you use it

00:27:30,110 --> 00:27:33,860
right now I guess you're one of the

00:27:31,580 --> 00:27:35,570
first users so feel free to create

00:27:33,860 --> 00:27:38,360
github issues and provide some feedback

00:27:35,570 --> 00:27:40,550
and tell me if it's useful or not but I

00:27:38,360 --> 00:27:42,200
think like the potential is pretty good

00:27:40,550 --> 00:27:43,940
because with this thing you can

00:27:42,200 --> 00:27:45,920
basically monitor everything that you

00:27:43,940 --> 00:27:47,840
want like even if you don't have Train

00:27:45,920 --> 00:27:49,280
mix if you don't have locked data even

00:27:47,840 --> 00:27:51,800
if you want to monitor your proprietary

00:27:49,280 --> 00:27:53,450
business logic all you need to know is

00:27:51,800 --> 00:27:55,400
how the Java classes and methods are

00:27:53,450 --> 00:27:57,500
called right a hook and then you have

00:27:55,400 --> 00:27:59,360
metrics for that so let's see what's

00:27:57,500 --> 00:28:03,770
what's going to come out of that okay

00:27:59,360 --> 00:28:06,910
so let's wrap up within the last half an

00:28:03,770 --> 00:28:10,670
hour we went through four ways of

00:28:06,910 --> 00:28:13,490
monitoring legacy Java applications we

00:28:10,670 --> 00:28:14,990
started off with parsing log files then

00:28:13,490 --> 00:28:17,750
we had a quick look at the black box

00:28:14,990 --> 00:28:19,370
maneet or a black box exporter then we

00:28:17,750 --> 00:28:22,850
had a look at the chain X exporter and

00:28:19,370 --> 00:28:25,960
jmx and finally we showed you how to

00:28:22,850 --> 00:28:29,240
write your own do-it-yourself Java agent

00:28:25,960 --> 00:28:31,160
as I said in the beginning all of those

00:28:29,240 --> 00:28:33,080
are just workarounds because the best

00:28:31,160 --> 00:28:35,570
thing you can actually do is download

00:28:33,080 --> 00:28:37,340
the promises client library for Java and

00:28:35,570 --> 00:28:39,299
put your metrics directly in your source

00:28:37,340 --> 00:28:41,700
code so this is

00:28:39,299 --> 00:28:43,860
but you to do whenever it is possible

00:28:41,700 --> 00:28:46,110
and all of those are just workarounds

00:28:43,860 --> 00:28:48,090
that you only use when you cannot edit

00:28:46,110 --> 00:28:50,580
the source code of your application okay

00:28:48,090 --> 00:28:52,440
so thanks for listening I will stay

00:28:50,580 --> 00:28:54,869
around here so for questions though we

00:28:52,440 --> 00:28:57,499
can take them after the talk and have a

00:28:54,869 --> 00:28:57,499
nice Foster

00:29:00,590 --> 00:29:12,420
[Applause]

00:29:05,580 --> 00:29:12,420
[Music]

00:30:30,070 --> 00:30:32,130

YouTube URL: https://www.youtube.com/watch?v=KvGIvwG8A2g


