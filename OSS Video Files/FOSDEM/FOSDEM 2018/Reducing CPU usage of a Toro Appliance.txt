Title: Reducing CPU usage of a Toro Appliance
Publication date: 2018-02-03
Playlist: FOSDEM 2018
Description: 
	by Matias  Vara

At: FOSDEM 2018
Room: AW1.126
Scheduled start: 2018-02-03 14:30:00+01
Captions: 
	00:00:05,450 --> 00:00:10,350
okay hi everyone sorry for being late I

00:00:08,670 --> 00:00:12,540
have some products with adapter to turn

00:00:10,350 --> 00:00:16,610
on the presentation so I finally we

00:00:12,540 --> 00:00:20,640
really try to find it I will start I

00:00:16,610 --> 00:00:23,730
will do it fast representation because I

00:00:20,640 --> 00:00:25,980
have less time so at the end will be a

00:00:23,730 --> 00:00:27,960
lot of question if you don't start and I

00:00:25,980 --> 00:00:30,630
want to start to descend me I am

00:00:27,960 --> 00:00:32,520
Matthias varriya and I style Ektron

00:00:30,630 --> 00:00:35,940
engineer in the university of la plata

00:00:32,520 --> 00:00:38,460
argentina let my PhD I didn't in France

00:00:35,940 --> 00:00:40,950
and I working with the situation in

00:00:38,460 --> 00:00:44,040
Cambridge on that in silicon which is my

00:00:40,950 --> 00:00:45,660
my work now and in my free time I

00:00:44,040 --> 00:00:49,590
developed our kernel I will present you

00:00:45,660 --> 00:00:51,120
a bit of that in the follow actually

00:00:49,590 --> 00:00:56,399
what is toriel

00:00:51,120 --> 00:00:59,219
it is a kernel based on x86 for

00:00:56,399 --> 00:01:03,960
architecture the whole kernel is what is

00:00:59,219 --> 00:01:05,610
a sprite in a free Pascal the idea is to

00:01:03,960 --> 00:01:08,819
provide a simple API to the user

00:01:05,610 --> 00:01:10,740
applications to compile all all together

00:01:08,819 --> 00:01:14,390
so indeed sense is application oriented

00:01:10,740 --> 00:01:18,240
so it is a really simple set of API and

00:01:14,390 --> 00:01:21,690
as a before the application and the

00:01:18,240 --> 00:01:24,119
colonel are compiled together another

00:01:21,690 --> 00:01:26,670
early in this their serene of the

00:01:24,119 --> 00:01:27,899
processor means that we are no different

00:01:26,670 --> 00:01:30,090
level of privilege so we are in all

00:01:27,899 --> 00:01:33,869
together and they are compile it

00:01:30,090 --> 00:01:36,720
together and generate a nanny and mash

00:01:33,869 --> 00:01:38,399
and this mash can run in the red I

00:01:36,720 --> 00:01:41,810
advise was like a bourbon Cabul

00:01:38,399 --> 00:01:44,970
well emulator like in war before box

00:01:41,810 --> 00:01:46,470
what I say is more or less is this you

00:01:44,970 --> 00:01:48,179
have your application and then you buy

00:01:46,470 --> 00:01:50,849
the application using the API for

00:01:48,179 --> 00:01:53,009
provides and the compiler which is the

00:01:50,849 --> 00:01:55,470
typical compiler will chose in all

00:01:53,009 --> 00:01:58,380
together and generate and mash this

00:01:55,470 --> 00:02:00,780
match then you can use a dot PNG so you

00:01:58,380 --> 00:02:03,509
can use it in any provider but you can't

00:02:00,780 --> 00:02:05,520
run for the translator and for the

00:02:03,509 --> 00:02:09,479
the format of the match and then use in

00:02:05,520 --> 00:02:10,890
them aware or carry in and so on but

00:02:09,479 --> 00:02:12,480
this knife here is you can use a semi

00:02:10,890 --> 00:02:14,830
magic nor let go by so you know you

00:02:12,480 --> 00:02:19,780
don't have to modify depending on the

00:02:14,830 --> 00:02:22,080
- I'm going to run and dice more or less

00:02:19,780 --> 00:02:24,670
than total stack well you have the

00:02:22,080 --> 00:02:26,980
hardware which is always the same it is

00:02:24,670 --> 00:02:29,890
in this architecture affected well maybe

00:02:26,980 --> 00:02:32,290
maybe you have or not the layer paper

00:02:29,890 --> 00:02:35,560
visor you have the whole the whole

00:02:32,290 --> 00:02:37,510
kernel that proposed the the model that

00:02:35,560 --> 00:02:39,640
most of the platen normal at least and

00:02:37,510 --> 00:02:42,690
have more of a past like the scheduler

00:02:39,640 --> 00:02:46,120
memory device driver network NASA one

00:02:42,690 --> 00:02:48,790
clearly we have just finished the driver

00:02:46,120 --> 00:02:53,970
for build I offer example but also we

00:02:48,790 --> 00:02:57,460
have for emulated device like each 1001

00:02:53,970 --> 00:03:00,430
with in the beautiful file system for

00:02:57,460 --> 00:03:02,230
the moment we are supporting x2 in just

00:03:00,430 --> 00:03:04,030
easy to use and well on top of that you

00:03:02,230 --> 00:03:07,000
have the user application and I said

00:03:04,030 --> 00:03:08,830
before kernel an application are in the

00:03:07,000 --> 00:03:10,630
same level they are not different in the

00:03:08,830 --> 00:03:17,860
hakushin in the standards they are using

00:03:10,630 --> 00:03:23,520
the same ring of privilege so the idea

00:03:17,860 --> 00:03:23,520
of this talk was this

00:03:32,519 --> 00:03:47,430
all right okay okay

00:03:49,640 --> 00:03:57,640
sorry I don't see a mouse here

00:04:39,960 --> 00:04:45,720
but I give you a bid saying what I'm

00:04:42,780 --> 00:04:47,940
going to talk is actually when in this

00:04:45,720 --> 00:04:51,389
presentation I wanted to talk about the

00:04:47,940 --> 00:04:54,840
kernel itself I did that two years ago

00:04:51,389 --> 00:04:57,000
since 2015 say more or less what was the

00:04:54,840 --> 00:04:58,949
special on it and in this case I was

00:04:57,000 --> 00:05:01,289
mostly most interesting to show some

00:04:58,949 --> 00:05:05,070
word that I didn't last three four weeks

00:05:01,289 --> 00:05:06,960
when I try to reduce the CPU usage of

00:05:05,070 --> 00:05:10,199
the photo

00:05:06,960 --> 00:05:13,560
ruddiness MDM like a movie and or

00:05:10,199 --> 00:05:15,539
kayvyun p.m. and actually dies to talk

00:05:13,560 --> 00:05:17,130
about Dominus Muhammad I figured out

00:05:15,539 --> 00:05:20,550
that it was consuming allowed to CPU

00:05:17,130 --> 00:05:24,930
because the guest was not 100 percent of

00:05:20,550 --> 00:05:29,310
the CPUs - and how the presentation is

00:05:24,930 --> 00:05:31,530
about how I try to do some API to try to

00:05:29,310 --> 00:05:33,599
reduce a consumption at the youngest

00:05:31,530 --> 00:05:45,120
let's attend a presentation I am going

00:05:33,599 --> 00:05:50,070
to to show that very soon I hope that's

00:05:45,120 --> 00:05:52,349
it and so actually what was all serving

00:05:50,070 --> 00:05:55,560
when I was running towards a king gas

00:05:52,349 --> 00:05:57,900
was if I do in top on the halls we've

00:05:55,560 --> 00:06:00,510
seen that the VM was consuming 100% of

00:05:57,900 --> 00:06:03,210
the CPU which is completely unacceptable

00:06:00,510 --> 00:06:06,110
in terms of production that you can have

00:06:03,210 --> 00:06:09,229
at the end up consuming 100% of CPU and

00:06:06,110 --> 00:06:09,229
almost there

00:06:16,990 --> 00:06:24,050
okay I can do it we don't slide I got to

00:06:22,190 --> 00:06:26,210
show any picture by I can't see show the

00:06:24,050 --> 00:06:37,670
picture at the end if you want but I can

00:06:26,210 --> 00:06:42,800
explain what I did anyway okay but it's

00:06:37,670 --> 00:06:44,480
okay well actually the problem was that

00:06:42,800 --> 00:06:46,760
what I said before when I was running

00:06:44,480 --> 00:06:48,530
told us I get weltering that 100% of

00:06:46,760 --> 00:06:50,480
this view was consuming and actually I

00:06:48,530 --> 00:06:52,820
didn't know why like that this happened

00:06:50,480 --> 00:06:55,490
and and then I when I started to analyze

00:06:52,820 --> 00:06:56,960
to clear out the query the code the

00:06:55,490 --> 00:06:59,930
colonel was running I feel real that

00:06:56,960 --> 00:07:02,020
were many either loops in the code in

00:06:59,930 --> 00:07:05,660
different part of the code and that was

00:07:02,020 --> 00:07:07,190
consuming a lot of CPU so actually the

00:07:05,660 --> 00:07:09,080
first thing and I did was identify this

00:07:07,190 --> 00:07:10,760
point and actually I found three point

00:07:09,080 --> 00:07:14,840
in the corner that well you see either

00:07:10,760 --> 00:07:17,540
loops which is a common common some in

00:07:14,840 --> 00:07:21,170
some instances very you see the use of a

00:07:17,540 --> 00:07:22,850
yo-yo that keep in the loop a checking a

00:07:21,170 --> 00:07:24,380
condition and doing some work if it's

00:07:22,850 --> 00:07:27,140
condition is true or it's not just keep

00:07:24,380 --> 00:07:29,510
looping and so I actually identified

00:07:27,140 --> 00:07:32,140
three three parts in the color juicing

00:07:29,510 --> 00:07:35,600
leader Luke was in the use of spin locks

00:07:32,140 --> 00:07:39,470
in the scheduler and there were some

00:07:35,600 --> 00:07:40,970
threads in the system that were doing

00:07:39,470 --> 00:07:42,680
implementing either loops they were

00:07:40,970 --> 00:07:45,710
doing some work carrying the scheduler

00:07:42,680 --> 00:07:48,350
and doing always the same so actually

00:07:45,710 --> 00:07:49,790
while they start to do start to look for

00:07:48,350 --> 00:07:51,950
bibliography to figure out how this

00:07:49,790 --> 00:07:55,790
fixes and actually in the case of spin

00:07:51,950 --> 00:07:57,740
locks intel proposed to use the memory

00:07:55,790 --> 00:08:01,850
you know the post instruction in science

00:07:57,740 --> 00:08:05,290
field log is in a way to relax the cpu

00:08:01,850 --> 00:08:09,050
to tell us this the cpu hayian in a loop

00:08:05,290 --> 00:08:13,749
well I don't remember exactly how the

00:08:09,050 --> 00:08:16,089
instruction BK have that in the slide

00:08:13,749 --> 00:08:18,279
but the thing is delay the next

00:08:16,089 --> 00:08:21,369
instruction in order to relax ep-1 idea

00:08:18,279 --> 00:08:24,159
of the whole idea have to try to relax

00:08:21,369 --> 00:08:26,019
the CPU in all that cases so in the case

00:08:24,159 --> 00:08:29,110
of the scheduler I was around that the

00:08:26,019 --> 00:08:32,829
one day when there is no stress or any

00:08:29,110 --> 00:08:35,469
no thread was ready in the system the

00:08:32,829 --> 00:08:38,740
scheduler was just keeping the in a loop

00:08:35,469 --> 00:08:41,409
so in this case was quite easy to fix I

00:08:38,740 --> 00:08:44,439
tried to do was doing to use the whole

00:08:41,409 --> 00:08:48,100
instruction so in that case when they

00:08:44,439 --> 00:08:50,589
the scheduler queue was empty I was just

00:08:48,100 --> 00:08:53,949
holding the call so the call was

00:08:50,589 --> 00:08:56,079
committed there and so i mean wake up if

00:08:53,949 --> 00:08:58,230
he has an interruption at the end for

00:08:56,079 --> 00:09:02,259
until you receive a packet more or less

00:08:58,230 --> 00:09:04,060
and the third case was a harder case

00:09:02,259 --> 00:09:06,250
because i have some thread that could be

00:09:04,060 --> 00:09:08,500
system thread on user thread that were

00:09:06,250 --> 00:09:11,410
using either loop so it was harder

00:09:08,500 --> 00:09:14,740
because i had to find a way to tell to

00:09:11,410 --> 00:09:15,839
the to tell the scheduler that i'm doing

00:09:14,740 --> 00:09:18,399
needlework

00:09:15,839 --> 00:09:22,660
so what i tried to do for us i'll

00:09:18,399 --> 00:09:28,300
implement an API based on choice two to

00:09:22,660 --> 00:09:31,209
three functions one to say to say the

00:09:28,300 --> 00:09:33,939
scheduler I am doing needlework and in

00:09:31,209 --> 00:09:36,069
that case the scheduler were shows count

00:09:33,939 --> 00:09:41,579
the time that a thread is in the middle

00:09:36,069 --> 00:09:46,809
state the ID I study had many many

00:09:41,579 --> 00:09:49,839
threads in the system the scalar will go

00:09:46,809 --> 00:09:52,120
asleep only if all the threads in the

00:09:49,839 --> 00:09:54,250
system are doing needle loop in that

00:09:52,120 --> 00:09:57,519
point the scalar will say okay I will

00:09:54,250 --> 00:10:00,189
call the coordinate system and that was

00:09:57,519 --> 00:10:02,529
the tricky part because you cannot hold

00:10:00,189 --> 00:10:06,279
a call if you have some thread in France

00:10:02,529 --> 00:10:08,920
type perform right so the idea was to -

00:10:06,279 --> 00:10:11,110
I don't remember exactly all the API by

00:10:08,920 --> 00:10:12,160
this the idea was to tell the scalar hey

00:10:11,110 --> 00:10:14,319
and do a little work

00:10:12,160 --> 00:10:16,089
it comes sometimes and after that

00:10:14,319 --> 00:10:18,279
Chinese say ok if I have all the stress

00:10:16,089 --> 00:10:20,800
in needle stay I will stop there

00:10:18,279 --> 00:10:24,250
completely the call and the second LP I

00:10:20,800 --> 00:10:26,559
was a wasum was a function to tell the

00:10:24,250 --> 00:10:27,410
scheduler ok I'm doing some work so I

00:10:26,559 --> 00:10:32,360
stopped to count

00:10:27,410 --> 00:10:34,579
a needle somehow so in that case the day

00:10:32,360 --> 00:10:36,470
of that thread will be kind of ready

00:10:34,579 --> 00:10:38,930
again it's quite hard to find like this

00:10:36,470 --> 00:10:41,379
because I have I'm doing a lot of you

00:10:38,930 --> 00:10:45,350
know terminology that maybe sounds weird

00:10:41,379 --> 00:10:48,019
I feel sorry I could not show the

00:10:45,350 --> 00:10:50,000
presentation and and actually when I

00:10:48,019 --> 00:10:53,149
implement this just I try to compare

00:10:50,000 --> 00:10:55,220
what happened and if I compare toriel

00:10:53,149 --> 00:10:58,490
the old Torah with the new tutorial you

00:10:55,220 --> 00:11:01,790
can see that we are now saving the half

00:10:58,490 --> 00:11:04,129
of the power CPU because now when there

00:11:01,790 --> 00:11:07,730
is not any packet forest and the CPU

00:11:04,129 --> 00:11:10,129
goes to 0 cpu - I mean if you room top

00:11:07,730 --> 00:11:12,050
on this cost you see that so now you are

00:11:10,129 --> 00:11:16,100
consuming the house that were consumed

00:11:12,050 --> 00:11:18,379
me before for a time you send packets

00:11:16,100 --> 00:11:22,459
you tell me if I am out of time

00:11:18,379 --> 00:11:24,860
ok if you send during sixty second

00:11:22,459 --> 00:11:27,050
packet and then you stop three sixty

00:11:24,860 --> 00:11:28,910
second like this right you observed a

00:11:27,050 --> 00:11:32,120
distance one hundred percent during the

00:11:28,910 --> 00:11:35,959
first 30 seconds and then 0 - in this

00:11:32,120 --> 00:11:38,630
next 60 seconds it was a first quite

00:11:35,959 --> 00:11:40,100
nice present was easy to implement also

00:11:38,630 --> 00:11:42,949
take me five days to implement all that

00:11:40,100 --> 00:11:45,589
but then I start to compare with

00:11:42,949 --> 00:11:47,300
something more serious like Apache for

00:11:45,589 --> 00:11:49,250
instance running a scheming guest and

00:11:47,300 --> 00:11:52,699
what's quite interesting because what I

00:11:49,250 --> 00:11:57,410
observed that was that will tourist

00:11:52,699 --> 00:11:59,829
stays at 100 percent with the first 60

00:11:57,410 --> 00:12:02,980
second of my experience Apache stay at

00:11:59,829 --> 00:12:02,980
40 percent

00:12:03,060 --> 00:12:07,950
and in the the case at this in the case

00:12:05,700 --> 00:12:11,460
that Apache was it'll those two the one

00:12:07,950 --> 00:12:13,110
both to the ten percent of the CPU right

00:12:11,460 --> 00:12:14,850
and was quite thirsty because I say okay

00:12:13,110 --> 00:12:17,420
I thought what my wrist was good but

00:12:14,850 --> 00:12:20,910
that one is much more better than mine

00:12:17,420 --> 00:12:23,520
the interesting thing was when you start

00:12:20,910 --> 00:12:27,330
to increment the request in the in this

00:12:23,520 --> 00:12:29,450
with 60 seconds windows so you see that

00:12:27,330 --> 00:12:33,770
in the case of a batch of Apache ACP you

00:12:29,450 --> 00:12:36,840
start to scale so on that point of 200

00:12:33,770 --> 00:12:39,150
requests within the first 60 second you

00:12:36,840 --> 00:12:42,810
see that the CPU goes to more or less

00:12:39,150 --> 00:12:50,060
the same Dantonio I mean to 100% of the

00:12:42,810 --> 00:12:53,820
CPU so you take away lessons where that

00:12:50,060 --> 00:12:56,520
okay you cannot have if you have

00:12:53,820 --> 00:13:00,270
production you cannot have a BM that is

00:12:56,520 --> 00:13:01,800
Runyan and 100% and it's depending on

00:13:00,270 --> 00:13:03,390
what application you're running in the

00:13:01,800 --> 00:13:06,570
guest you can and if you cannot control

00:13:03,390 --> 00:13:08,940
more or less that the solution that you

00:13:06,570 --> 00:13:10,920
can implement in my case that it was

00:13:08,940 --> 00:13:12,510
quite passive because this is this

00:13:10,920 --> 00:13:14,760
instruction that I used on this whole

00:13:12,510 --> 00:13:17,220
instruction is well supported for more

00:13:14,760 --> 00:13:18,750
of the hypervisors but if you want to do

00:13:17,220 --> 00:13:20,670
something more complex and using other

00:13:18,750 --> 00:13:22,920
instructions that depend of the

00:13:20,670 --> 00:13:25,680
improviser if you to support I mean it

00:13:22,920 --> 00:13:27,540
is the provider will emulate or not that

00:13:25,680 --> 00:13:30,000
instruction I'm talking about maybe you

00:13:27,540 --> 00:13:32,339
know the my than M contra instruction

00:13:30,000 --> 00:13:35,070
which is not quite quite well supported

00:13:32,339 --> 00:13:39,420
but it's something more intelligent that

00:13:35,070 --> 00:13:40,980
how we say okay and the first ticket

00:13:39,420 --> 00:13:43,890
will take you well lesson I will say

00:13:40,980 --> 00:13:46,880
that cut my solution that was only hard

00:13:43,890 --> 00:13:49,410
the core was not enough for short and

00:13:46,880 --> 00:13:54,300
really solution had to take into account

00:13:49,410 --> 00:13:56,130
the scaling of the CPU which is much

00:13:54,300 --> 00:14:00,150
more complex to implement for so that's

00:13:56,130 --> 00:14:02,410
only whole instruction right yeah that

00:14:00,150 --> 00:14:07,660
was a more or less a talk

00:14:02,410 --> 00:14:12,620
and I mean what's really an an

00:14:07,660 --> 00:14:17,010
experimentation right that's it

00:14:12,620 --> 00:14:22,830
[Applause]

00:14:17,010 --> 00:14:22,830
no question because I be so fast and

00:14:34,710 --> 00:14:40,830
well in the case of the in the case of

00:14:37,450 --> 00:14:46,690
the networking particularly it's not

00:14:40,830 --> 00:14:49,660
it's not blogging so for if and if you

00:14:46,690 --> 00:14:52,120
well guys how I implemented if you want

00:14:49,660 --> 00:14:54,400
to get a packet you'll ask that relies

00:14:52,120 --> 00:14:58,450
the packet but the that folks will learn

00:14:54,400 --> 00:15:00,400
to Neal know if it's not it's not no

00:14:58,450 --> 00:15:02,620
packet this will not block until someone

00:15:00,400 --> 00:15:07,240
arrived so in the case of the networking

00:15:02,620 --> 00:15:09,700
it is not blocking at all you know in

00:15:07,240 --> 00:15:14,470
the holistic I mean I I think for that I

00:15:09,700 --> 00:15:22,360
should I had to implement such a API to

00:15:14,470 --> 00:15:23,500
try to to turn often I mean if in the

00:15:22,360 --> 00:15:26,230
case will block it

00:15:23,500 --> 00:15:28,000
I will done I will not need such API

00:15:26,230 --> 00:15:32,800
because you've got block and at all

00:15:28,000 --> 00:15:35,320
right but yeah I know yeah but the thing

00:15:32,800 --> 00:15:43,140
is I the call stack TCP the whole

00:15:35,320 --> 00:15:43,140
network is no block yep

00:15:43,379 --> 00:16:01,220
I heard hey can you repeat the question

00:16:15,949 --> 00:16:34,639
yeah yeah well I think I could talk like

00:16:31,619 --> 00:16:36,989
that I know I don't have in mind all the

00:16:34,639 --> 00:16:39,179
decision and assumption that I did when

00:16:36,989 --> 00:16:41,369
I was working in the circuit so maybe I

00:16:39,179 --> 00:16:44,989
do that not now you will not work

00:16:41,369 --> 00:16:47,489
that's what but I got thing about that I

00:16:44,989 --> 00:16:55,470
ever since I have are--some but I don't

00:16:47,489 --> 00:16:57,359
remember all the reasons yeah have

00:16:55,470 --> 00:16:59,699
someone or another question I will show

00:16:57,359 --> 00:17:05,909
I will show some I will show something

00:16:59,699 --> 00:17:08,519
and some demo at four I will show maybe

00:17:05,909 --> 00:17:11,870
the three slider I show or the more few

00:17:08,519 --> 00:17:14,929
lies I do and I will run on the cloud

00:17:11,870 --> 00:17:17,759
polio guess I will run up web browser

00:17:14,929 --> 00:17:21,299
Ontario so you can access as you trust

00:17:17,759 --> 00:17:24,419
me and it works and so is it if it is

00:17:21,299 --> 00:17:25,139
possible I will do that for you so thank

00:17:24,419 --> 00:17:28,220
you very much

00:17:25,139 --> 00:17:28,220
sorry for

00:17:29,090 --> 00:17:31,150

YouTube URL: https://www.youtube.com/watch?v=aKUrUCwCyY8


