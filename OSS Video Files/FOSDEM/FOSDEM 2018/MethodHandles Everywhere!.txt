Title: MethodHandles Everywhere!
Publication date: 2018-02-03
Playlist: FOSDEM 2018
Description: 
	by Charles Nutter

At: FOSDEM 2018
Room: UD2.208 (Decroly)
Scheduled start: 2018-02-03 13:20:00+01
Captions: 
	00:00:04,620 --> 00:00:09,120
this is an hour talk and we got 25

00:00:07,559 --> 00:00:10,549
minutes okay I'm gonna talk about method

00:00:09,120 --> 00:00:12,840
handles my name is Charles nutter

00:00:10,549 --> 00:00:16,170
charlie to my friends which includes all

00:00:12,840 --> 00:00:18,210
of you I work at Red Hat now for like

00:00:16,170 --> 00:00:20,160
six years I've been working on JRuby and

00:00:18,210 --> 00:00:22,860
other JVM language stuff for like 10 or

00:00:20,160 --> 00:00:24,899
11 years if you want to see the full

00:00:22,860 --> 00:00:27,090
version of this talk at least the first

00:00:24,899 --> 00:00:29,040
time that I gave it we were at out in

00:00:27,090 --> 00:00:30,450
Hawaii with Chris challenger and a bunch

00:00:29,040 --> 00:00:32,149
of other cool folks if you want to come

00:00:30,450 --> 00:00:33,450
next year we're gonna do it right

00:00:32,149 --> 00:00:35,910
absolutely

00:00:33,450 --> 00:00:37,769
lava one in Hawaii next year January

00:00:35,910 --> 00:00:41,370
create time to go there but the whole

00:00:37,769 --> 00:00:43,800
talk is available yep come on out okay

00:00:41,370 --> 00:00:45,269
so what our method handles now we're

00:00:43,800 --> 00:00:46,109
gonna go through here's the agenda for

00:00:45,269 --> 00:00:48,059
we're gonna talk about we talk about

00:00:46,109 --> 00:00:50,429
what methods and handles are why we need

00:00:48,059 --> 00:00:52,469
them what's new in Java 9 a little

00:00:50,429 --> 00:00:53,999
preview of some of that stuff I'm going

00:00:52,469 --> 00:00:55,589
to talk about a little library called

00:00:53,999 --> 00:00:57,089
invoke binder which I've done in a

00:00:55,589 --> 00:00:58,350
longer form here in the past but a

00:00:57,089 --> 00:00:59,940
little primer just so you understand

00:00:58,350 --> 00:01:01,260
some of the code and then maybe we'll

00:00:59,940 --> 00:01:03,929
try and do something crazy with method

00:01:01,260 --> 00:01:06,630
handles okay so what's the deal with

00:01:03,929 --> 00:01:09,990
Method Andals well when the JRuby team

00:01:06,630 --> 00:01:11,490
first came on at Sun 2006 there was this

00:01:09,990 --> 00:01:14,730
jsr that had kind of been languishing

00:01:11,490 --> 00:01:16,940
for a while jsr 292 for invokedynamic a

00:01:14,730 --> 00:01:19,860
new way of doing invocation on the JVM

00:01:16,940 --> 00:01:21,570
but around this time we had Ruby and

00:01:19,860 --> 00:01:23,160
rails JRuby started to be able to do

00:01:21,570 --> 00:01:24,960
some cool stuff we could run rails on

00:01:23,160 --> 00:01:27,450
top of the JVM so there was a lot of

00:01:24,960 --> 00:01:28,980
interest developing in having a more

00:01:27,450 --> 00:01:30,660
languages and especially dynamic

00:01:28,980 --> 00:01:33,150
languages on top of the JVM

00:01:30,660 --> 00:01:35,250
but we needed something better to make

00:01:33,150 --> 00:01:37,290
it easier to optimize and compile these

00:01:35,250 --> 00:01:39,510
things and get the JVM involved in

00:01:37,290 --> 00:01:41,760
running these languages so what is it

00:01:39,510 --> 00:01:44,010
that we needed at least on JRuby groovy

00:01:41,760 --> 00:01:44,970
the dynamic language side of things what

00:01:44,010 --> 00:01:47,550
we need to be able to call methods

00:01:44,970 --> 00:01:49,110
dynamically obviously we need to be able

00:01:47,550 --> 00:01:51,180
to look them up when they're called

00:01:49,110 --> 00:01:53,250
based on name or based on name and types

00:01:51,180 --> 00:01:55,500
and potentially with very different

00:01:53,250 --> 00:01:57,960
class structures both groovy and JRuby

00:01:55,500 --> 00:02:00,360
have a meta class structure that's

00:01:57,960 --> 00:02:02,070
essentially a big hash and the way that

00:02:00,360 --> 00:02:03,660
you define new methods is you stick

00:02:02,070 --> 00:02:05,910
methods into that hash under some name

00:02:03,660 --> 00:02:07,230
it's not like a typical Java class so we

00:02:05,910 --> 00:02:09,360
needed a different way of doing lookup

00:02:07,230 --> 00:02:11,099
and dispatch we need to be able to

00:02:09,360 --> 00:02:13,680
dynamically assign fields and constants

00:02:11,099 --> 00:02:15,689
in Ruby you don't declare a whole bunch

00:02:13,680 --> 00:02:17,549
of fields ahead of time in your object

00:02:15,689 --> 00:02:18,540
or in your types it's just when you

00:02:17,549 --> 00:02:21,000
assign a name

00:02:18,540 --> 00:02:22,560
becomes a new slot in the object so we

00:02:21,000 --> 00:02:24,810
need to be able to grow objects shapes

00:02:22,560 --> 00:02:26,670
and access those fields similar to how

00:02:24,810 --> 00:02:29,250
we would in Java but going through this

00:02:26,670 --> 00:02:31,200
other indirection mechanism I'm going to

00:02:29,250 --> 00:02:32,760
do this all to be fast of course we

00:02:31,200 --> 00:02:34,620
could emulate all of these things with

00:02:32,760 --> 00:02:36,900
reflection and other tricks but that

00:02:34,620 --> 00:02:38,220
wasn't really tying well into the JVM

00:02:36,900 --> 00:02:41,549
and didn't give us the performance that

00:02:38,220 --> 00:02:45,299
we wanted out of a JVM language and so

00:02:41,549 --> 00:02:47,430
we revisited the method way that jsr 292

00:02:45,299 --> 00:02:50,069
and we came up with the invokedynamic

00:02:47,430 --> 00:02:52,769
bytecode which is what allows us to hook

00:02:50,069 --> 00:02:54,680
into the the JVM machinery and the

00:02:52,769 --> 00:02:57,419
larger part of that that came out of the

00:02:54,680 --> 00:02:59,669
the invokedynamic jsr is the method

00:02:57,419 --> 00:03:01,950
handle API so the method handle API is

00:02:59,669 --> 00:03:04,319
sort of like reflection you get a lookup

00:03:01,950 --> 00:03:06,659
object the lookup object allows you to

00:03:04,319 --> 00:03:09,750
go and get a handle or a pointer to a

00:03:06,659 --> 00:03:12,750
function or a field or an array element

00:03:09,750 --> 00:03:15,180
sort and those sorts of things rather

00:03:12,750 --> 00:03:17,310
than just passing in a set of parameters

00:03:15,180 --> 00:03:19,079
like we do with reflection we can pass

00:03:17,310 --> 00:03:21,090
around these little boxes called method

00:03:19,079 --> 00:03:24,060
type which encapsulates a return value

00:03:21,090 --> 00:03:25,709
or a return type and all the argument

00:03:24,060 --> 00:03:27,959
types that would go with it

00:03:25,709 --> 00:03:29,549
and then all of these methods fields are

00:03:27,959 --> 00:03:31,530
raised they're basically just direct

00:03:29,549 --> 00:03:33,750
handles so we get a pointer to a

00:03:31,530 --> 00:03:35,400
function and we can call that directly

00:03:33,750 --> 00:03:38,280
without a lot of the plumbing that

00:03:35,400 --> 00:03:40,290
reflection normally has type checking

00:03:38,280 --> 00:03:42,510
and type conversions and argument boxing

00:03:40,290 --> 00:03:44,549
and unboxing and so on we get much

00:03:42,510 --> 00:03:46,440
closer to a real function pointer which

00:03:44,549 --> 00:03:46,979
allows us to do a better job of

00:03:46,440 --> 00:03:50,459
optimizing

00:03:46,979 --> 00:03:52,229
a dynamic language and the method

00:03:50,459 --> 00:03:54,269
handles class then provides all sorts of

00:03:52,229 --> 00:03:56,940
additional adaptations so if we want to

00:03:54,269 --> 00:03:59,729
add back some of that type checking or

00:03:56,940 --> 00:04:01,590
argument modification like reflection

00:03:59,729 --> 00:04:03,750
does we can do it on a piecemeal basis

00:04:01,590 --> 00:04:05,489
insert arguments move them around change

00:04:03,750 --> 00:04:09,419
their types and so on

00:04:05,489 --> 00:04:11,729
and all of this basically forms a tree

00:04:09,419 --> 00:04:13,979
of method handles so at the top you've

00:04:11,729 --> 00:04:15,780
got the invoke coming in that will maybe

00:04:13,979 --> 00:04:18,419
move some arguments around maybe convert

00:04:15,780 --> 00:04:20,070
into Long's or doubles to floats and

00:04:18,419 --> 00:04:22,880
then continue down until it gets to a

00:04:20,070 --> 00:04:26,520
direct handle a call to a function or a

00:04:22,880 --> 00:04:28,169
write or read from a field and that's

00:04:26,520 --> 00:04:29,610
what we have as a method handle tree and

00:04:28,169 --> 00:04:31,680
we could pass these around as a callable

00:04:29,610 --> 00:04:33,240
function object

00:04:31,680 --> 00:04:35,250
why why don't we on you want to use

00:04:33,240 --> 00:04:37,979
reflection like I said the use cases for

00:04:35,250 --> 00:04:40,229
reflection are very similar but it does

00:04:37,979 --> 00:04:42,150
a lot more than we need in many cases if

00:04:40,229 --> 00:04:43,650
we have all of the correct types and we

00:04:42,150 --> 00:04:45,320
have the right number of arguments and

00:04:43,650 --> 00:04:48,330
we know we just want to call a function

00:04:45,320 --> 00:04:49,919
through this handle we don't need it to

00:04:48,330 --> 00:04:51,600
be doing all these extra checks and all

00:04:49,919 --> 00:04:53,699
of these different argument manipulation

00:04:51,600 --> 00:04:55,590
things method handles let us have a

00:04:53,699 --> 00:04:57,449
direct pointer to a function and then

00:04:55,590 --> 00:04:59,759
only add in back that back in the

00:04:57,449 --> 00:05:00,660
ceremony that we really need so let's

00:04:59,759 --> 00:05:02,280
walk through what this actually looks

00:05:00,660 --> 00:05:04,139
like in some code it's a kind of

00:05:02,280 --> 00:05:06,270
conceptually hard to just talk it

00:05:04,139 --> 00:05:07,470
through so I mentioned the the lookup

00:05:06,270 --> 00:05:09,030
object and there's two different ways

00:05:07,470 --> 00:05:12,300
you can get a lookup object the first

00:05:09,030 --> 00:05:14,639
lookup here is a special lookup it can

00:05:12,300 --> 00:05:16,560
see anything and have access to anything

00:05:14,639 --> 00:05:18,990
that it would that you'd be able to see

00:05:16,560 --> 00:05:21,419
at that point in the code so it can see

00:05:18,990 --> 00:05:23,220
private fields that may be in scope for

00:05:21,419 --> 00:05:24,750
this piece of code rather than with

00:05:23,220 --> 00:05:27,449
reflection where you have to go and get

00:05:24,750 --> 00:05:29,430
a method or a private field and then try

00:05:27,449 --> 00:05:32,130
to set accessible and then pass a bunch

00:05:29,430 --> 00:05:34,620
of Java 9 flags to make it let you do

00:05:32,130 --> 00:05:36,630
all of this stuff you can actually give

00:05:34,620 --> 00:05:39,120
out this access or have this access for

00:05:36,630 --> 00:05:40,830
your program more often though if you're

00:05:39,120 --> 00:05:42,750
just using this as sort of a reflective

00:05:40,830 --> 00:05:45,300
thing to call into Java methods you'll

00:05:42,750 --> 00:05:46,500
use a public lookup which is what you'd

00:05:45,300 --> 00:05:48,000
expect it's only what's going to be

00:05:46,500 --> 00:05:51,000
public to someone that's completely

00:05:48,000 --> 00:05:53,550
outside of that class and packaged so we

00:05:51,000 --> 00:05:55,860
have our lookup objects now we can use

00:05:53,550 --> 00:05:57,539
our method types to look up methods we

00:05:55,860 --> 00:05:59,039
have three different lookups we're doing

00:05:57,539 --> 00:06:00,630
here we're going to get the get property

00:05:59,039 --> 00:06:03,270
off of the system class that's a fine

00:06:00,630 --> 00:06:06,030
static and you can see the the property

00:06:03,270 --> 00:06:07,320
it's a return string and takes a string

00:06:06,030 --> 00:06:10,740
argument we're going to that that

00:06:07,320 --> 00:06:12,690
signature here is add on a list this is

00:06:10,740 --> 00:06:14,159
a virtual lookup so we look up the

00:06:12,690 --> 00:06:17,280
virtual method and now we have a handle

00:06:14,159 --> 00:06:19,139
to add on a list and then we can also do

00:06:17,280 --> 00:06:20,699
constructors we can look up constructors

00:06:19,139 --> 00:06:22,289
and construct objects and they all

00:06:20,699 --> 00:06:24,270
basically just end up method handles

00:06:22,289 --> 00:06:27,690
that we can invoke with various

00:06:24,270 --> 00:06:29,940
parameters and in signatures looking at

00:06:27,690 --> 00:06:32,099
fields also very similar so we can grab

00:06:29,940 --> 00:06:33,900
the system out field off of the system

00:06:32,099 --> 00:06:35,639
class and then we have a method handle

00:06:33,900 --> 00:06:38,039
that every time we invoke it it will go

00:06:35,639 --> 00:06:42,479
and get system out just like a java.lang

00:06:38,039 --> 00:06:44,010
reflect field and then we can take all

00:06:42,479 --> 00:06:45,070
of these and combine them together as

00:06:44,010 --> 00:06:48,040
well so

00:06:45,070 --> 00:06:51,700
here we have our get property we have

00:06:48,040 --> 00:06:53,320
our get property our add our list down

00:06:51,700 --> 00:06:54,820
at the bottom we can also get our fine

00:06:53,320 --> 00:06:59,200
static gather and pull these together

00:06:54,820 --> 00:07:00,250
into a tree of handles essentially then

00:06:59,200 --> 00:07:02,050
finally once we've got all of our

00:07:00,250 --> 00:07:03,670
handles together we can invoke them just

00:07:02,050 --> 00:07:06,310
like we would with a reflected object

00:07:03,670 --> 00:07:08,590
here we're using the get property so we

00:07:06,310 --> 00:07:12,430
get the java dot home and now we can

00:07:08,590 --> 00:07:13,930
access it this way okay so I mentioned

00:07:12,430 --> 00:07:15,370
about combining method handles and I

00:07:13,930 --> 00:07:17,500
didn't talk about that in those slides

00:07:15,370 --> 00:07:20,170
there let's take a look at some of the

00:07:17,500 --> 00:07:21,850
adaptations we can do so when we have

00:07:20,170 --> 00:07:24,250
these two different handles like get

00:07:21,850 --> 00:07:25,780
system dot out and call print line on it

00:07:24,250 --> 00:07:27,310
we'd like to be able to combine those

00:07:25,780 --> 00:07:29,050
and there's many different handle

00:07:27,310 --> 00:07:32,650
adaptations that let us combine those

00:07:29,050 --> 00:07:34,030
together into a tree of operations we

00:07:32,650 --> 00:07:36,340
call these method handle Combinator's

00:07:34,030 --> 00:07:37,810
and so these combinators allow us to

00:07:36,340 --> 00:07:40,300
take many different methods many

00:07:37,810 --> 00:07:42,700
different fields some conditional logic

00:07:40,300 --> 00:07:45,010
and loops and so on and create still

00:07:42,700 --> 00:07:47,110
just a single callable object that has

00:07:45,010 --> 00:07:49,540
all of this additional logic wrapped

00:07:47,110 --> 00:07:51,340
around it and the cool thing about this

00:07:49,540 --> 00:07:53,470
is that the JIT still sees through this

00:07:51,340 --> 00:07:55,570
it says if we wrote these loops or these

00:07:53,470 --> 00:07:57,250
conditions or these calls in regular

00:07:55,570 --> 00:07:59,110
Java but we're building it up

00:07:57,250 --> 00:08:00,910
programmatically using method handles

00:07:59,110 --> 00:08:02,500
and then the JVM takes that and

00:08:00,910 --> 00:08:04,450
optimizes it and turns it into the same

00:08:02,500 --> 00:08:08,260
assembly code that you'd have if you

00:08:04,450 --> 00:08:09,700
just wrote Java code directly so one of

00:08:08,260 --> 00:08:11,410
these combinators to kind of give you an

00:08:09,700 --> 00:08:14,650
example of how this looks it would be an

00:08:11,410 --> 00:08:16,810
if-then-else so here is our pseudo Java

00:08:14,650 --> 00:08:19,150
code here we're just caching results

00:08:16,810 --> 00:08:21,010
from a database in a little hash so

00:08:19,150 --> 00:08:22,090
we've got our hash we check to see if

00:08:21,010 --> 00:08:25,060
we've already hit that in that

00:08:22,090 --> 00:08:27,130
particular key if we do we can return it

00:08:25,060 --> 00:08:28,570
otherwise we go to the database load

00:08:27,130 --> 00:08:30,460
some data out of it and stick it into

00:08:28,570 --> 00:08:32,140
the cache that's the simple thing that

00:08:30,460 --> 00:08:36,280
we'd like to represent as a set of

00:08:32,140 --> 00:08:38,680
method handles the magic call that we do

00:08:36,280 --> 00:08:40,540
here in the method handle API is guard

00:08:38,680 --> 00:08:43,840
with tests which is essentially an

00:08:40,540 --> 00:08:45,610
if-then-else so let's take that we've

00:08:43,840 --> 00:08:48,400
got our condition our then in our else

00:08:45,610 --> 00:08:52,120
so our condition in this case we find

00:08:48,400 --> 00:08:54,280
virtual on map that contains key method

00:08:52,120 --> 00:08:56,500
which returns a boolean and accepts an

00:08:54,280 --> 00:08:58,210
object and then we're going to bind it

00:08:56,500 --> 00:08:58,980
to the cache so that means that that

00:08:58,210 --> 00:09:00,420
that fer

00:08:58,980 --> 00:09:02,519
argument the argument where we actually

00:09:00,420 --> 00:09:04,110
have the physical cache object is now

00:09:02,519 --> 00:09:05,850
taken care of for us we don't have to

00:09:04,110 --> 00:09:12,420
pass that in like we would with

00:09:05,850 --> 00:09:14,550
reflection doing an invocation case when

00:09:12,420 --> 00:09:16,139
we find the key so now we will actually

00:09:14,550 --> 00:09:18,360
just go get the value out of the map

00:09:16,139 --> 00:09:20,130
again we'll bind that to the cache so

00:09:18,360 --> 00:09:22,589
now this will pull that element out of

00:09:20,130 --> 00:09:25,380
the cache and return it to us and then

00:09:22,589 --> 00:09:28,709
we have our else our else is to pull it

00:09:25,380 --> 00:09:30,720
from the database and cache it in this

00:09:28,709 --> 00:09:32,639
this hash object and again we can bind

00:09:30,720 --> 00:09:34,440
it and pull all of these together with

00:09:32,639 --> 00:09:36,480
our guard with tests now we have a

00:09:34,440 --> 00:09:38,699
single method handle a single callable

00:09:36,480 --> 00:09:41,010
object that does all of this conditional

00:09:38,699 --> 00:09:44,730
logic and then optimizes itself

00:09:41,010 --> 00:09:46,769
internally pretty cool so there's lots

00:09:44,730 --> 00:09:48,089
of other adaptations obviously I don't

00:09:46,769 --> 00:09:50,399
have time to get to all of these here

00:09:48,089 --> 00:09:52,529
but we can insert arguments we can drop

00:09:50,399 --> 00:09:54,300
arguments reorder them depending on how

00:09:52,529 --> 00:09:57,360
we're adapting different api's together

00:09:54,300 --> 00:10:00,329
we can filter the arguments or the

00:09:57,360 --> 00:10:02,220
return value so for each argument pass

00:10:00,329 --> 00:10:03,839
it through some function take the result

00:10:02,220 --> 00:10:06,480
of that and make that the new argument

00:10:03,839 --> 00:10:08,519
at that point we can also fold all of

00:10:06,480 --> 00:10:10,560
the arguments together pass them to a

00:10:08,519 --> 00:10:11,699
function calculate something and then

00:10:10,560 --> 00:10:14,040
the result of that becomes a new

00:10:11,699 --> 00:10:16,440
argument so all along the way moving

00:10:14,040 --> 00:10:19,290
arguments around making calls accessing

00:10:16,440 --> 00:10:21,149
fields and essentially building a tree

00:10:19,290 --> 00:10:26,339
of logic out of all of our method

00:10:21,149 --> 00:10:28,740
handles so what's new with Java 9 so

00:10:26,339 --> 00:10:31,260
when we first came up with the method

00:10:28,740 --> 00:10:33,120
handle API we had a fairly complete set

00:10:31,260 --> 00:10:34,440
of operations but there were a few

00:10:33,120 --> 00:10:36,389
things that turned out to be missing

00:10:34,440 --> 00:10:37,949
that programmatically it turned out we

00:10:36,389 --> 00:10:39,810
needed as part of the method handle API

00:10:37,949 --> 00:10:41,699
one of the biggest ones that I was

00:10:39,810 --> 00:10:43,230
worried about was try finally I'll show

00:10:41,699 --> 00:10:45,709
you in a minute why that was such a

00:10:43,230 --> 00:10:48,600
problem we also had no way to do loops

00:10:45,709 --> 00:10:50,850
so if you're going to be representing

00:10:48,600 --> 00:10:52,529
essentially an entire expression tree

00:10:50,850 --> 00:10:55,019
it'd be nice if you could actually do

00:10:52,529 --> 00:10:58,100
some controlled looping over elements of

00:10:55,019 --> 00:11:00,750
an array or over input arguments whatnot

00:10:58,100 --> 00:11:03,480
we didn't have any real good way to do

00:11:00,750 --> 00:11:05,220
volatile or atomic accesses to fields so

00:11:03,480 --> 00:11:07,829
I showed you that you can get a method

00:11:05,220 --> 00:11:09,660
handle to a field but it's just going to

00:11:07,829 --> 00:11:11,069
access it the way that you would if you

00:11:09,660 --> 00:11:12,810
were calling it from Java there's no way

00:11:11,069 --> 00:11:16,250
to say oh I want to do

00:11:12,810 --> 00:11:18,870
volatile right or you know a

00:11:16,250 --> 00:11:20,580
non-volatile right to a field it's

00:11:18,870 --> 00:11:22,620
always just one particular access way so

00:11:20,580 --> 00:11:23,940
we needed better ways to do that and

00:11:22,620 --> 00:11:25,470
there was no way to just tell it to

00:11:23,940 --> 00:11:27,180
construct an array you would have to

00:11:25,470 --> 00:11:29,220
have a utility method somewhere that you

00:11:27,180 --> 00:11:29,630
would call into to construct arrays for

00:11:29,220 --> 00:11:31,980
you

00:11:29,630 --> 00:11:33,600
obviously this is Java we need to be

00:11:31,980 --> 00:11:36,600
able to create arrays as part of this

00:11:33,600 --> 00:11:40,529
whole expression tree okay so I

00:11:36,600 --> 00:11:42,540
mentioned try finally and a lot maybe a

00:11:40,529 --> 00:11:45,180
lot of folks may not know this when you

00:11:42,540 --> 00:11:47,070
have a try finally in Java code java c

00:11:45,180 --> 00:11:49,560
actually will duplicate that finally

00:11:47,070 --> 00:11:52,560
block of logic along every exit path

00:11:49,560 --> 00:11:54,089
from from that that block of code so

00:11:52,560 --> 00:11:55,950
there will be the finally logic that

00:11:54,089 --> 00:11:57,990
gets stuck on the end of the non

00:11:55,950 --> 00:11:59,570
exceptional path and the finally logic

00:11:57,990 --> 00:12:02,339
that's handled on the exceptional path

00:11:59,570 --> 00:12:04,529
and so if we wanted to do this with

00:12:02,339 --> 00:12:06,540
method handles we essentially had to do

00:12:04,529 --> 00:12:08,700
the same thing we had to take that

00:12:06,540 --> 00:12:10,350
handle and duplicate it twice make the

00:12:08,700 --> 00:12:12,660
tree that much more complicated for the

00:12:10,350 --> 00:12:15,060
exit path and for the for the normal

00:12:12,660 --> 00:12:16,770
path and for the exceptional path and so

00:12:15,060 --> 00:12:18,630
something that looks really simple like

00:12:16,770 --> 00:12:20,790
this we essentially wanted to wrap a

00:12:18,630 --> 00:12:22,650
target method handle with some exception

00:12:20,790 --> 00:12:24,600
handling and then pass it off to a

00:12:22,650 --> 00:12:28,470
handler if there was an exception turned

00:12:24,600 --> 00:12:30,690
into code like this just to do a try

00:12:28,470 --> 00:12:32,220
finally and this is actually greatly

00:12:30,690 --> 00:12:34,050
simplified from what it really is

00:12:32,220 --> 00:12:36,960
because I'm using my invoke binder

00:12:34,050 --> 00:12:40,260
library which which simplifies and wraps

00:12:36,960 --> 00:12:41,820
a lot of the method handle API but this

00:12:40,260 --> 00:12:44,640
is obviously not what we want this is

00:12:41,820 --> 00:12:46,260
way too complicated it worked but we've

00:12:44,640 --> 00:12:48,330
got so many handles and so many

00:12:46,260 --> 00:12:50,010
adaptations that the JVM had trouble

00:12:48,330 --> 00:12:51,690
seeing through it it didn't turn it into

00:12:50,010 --> 00:12:54,360
the the try finally logic we really

00:12:51,690 --> 00:12:57,060
wanted and so in Java 9 now we can just

00:12:54,360 --> 00:13:00,030
do this and say try finally and put it

00:12:57,060 --> 00:13:02,580
in the right places we also didn't have

00:13:00,030 --> 00:13:04,380
loops which were added so here we have

00:13:02,580 --> 00:13:07,350
just simple while loops or a do-while

00:13:04,380 --> 00:13:09,330
loop a counted loop or an iterated loop

00:13:07,350 --> 00:13:11,370
that has an iterator and then just walks

00:13:09,330 --> 00:13:13,950
through a collection for example and

00:13:11,370 --> 00:13:16,230
then the general case the method handles

00:13:13,950 --> 00:13:18,750
loop has very many different ways that

00:13:16,230 --> 00:13:20,670
you can configure it to handle other

00:13:18,750 --> 00:13:24,420
types of loops these are all just sort

00:13:20,670 --> 00:13:27,090
of sub versions of that all right var

00:13:24,420 --> 00:13:29,490
handles also added in Java 9

00:13:27,090 --> 00:13:32,010
and so var handles gave us the ability

00:13:29,490 --> 00:13:34,800
to have that handle to a field on an

00:13:32,010 --> 00:13:37,110
object or a static field but much more

00:13:34,800 --> 00:13:39,390
powerful mechanisms for doing volatile

00:13:37,110 --> 00:13:41,490
access an atomic axis we don't have to

00:13:39,390 --> 00:13:45,150
cheat by going all the way to unsafe to

00:13:41,490 --> 00:13:46,830
do a compare and swap of a field or deal

00:13:45,150 --> 00:13:49,500
with in directing through an atomic

00:13:46,830 --> 00:13:51,570
reference object we can just do it

00:13:49,500 --> 00:13:54,540
directly with the VAR handle now and so

00:13:51,570 --> 00:13:57,720
one of the one of the many ways that we

00:13:54,540 --> 00:13:58,980
cheat with an unsafe can now go away it

00:13:57,720 --> 00:14:00,540
also gave us something other something

00:13:58,980 --> 00:14:03,030
else that was pretty cool we can have

00:14:00,540 --> 00:14:06,450
views on a byte buffer or a byte array

00:14:03,030 --> 00:14:08,580
that rather than if you actually look at

00:14:06,450 --> 00:14:10,350
the for example the last talk had an int

00:14:08,580 --> 00:14:12,870
buffer that it wrapped around a byte

00:14:10,350 --> 00:14:15,690
buffer right if you look at the code in

00:14:12,870 --> 00:14:17,520
int buffer it actually just reads bytes

00:14:15,690 --> 00:14:19,320
and then concatenate them together and

00:14:17,520 --> 00:14:21,300
turns them into an int it's not actually

00:14:19,320 --> 00:14:23,430
pulling int by after int off of that

00:14:21,300 --> 00:14:24,660
line which means you're doing four or

00:14:23,430 --> 00:14:26,400
eight times as much work

00:14:24,660 --> 00:14:28,020
reading individual bytes and put

00:14:26,400 --> 00:14:29,880
sticking them together now we can

00:14:28,020 --> 00:14:31,830
actually say treat this byte array as if

00:14:29,880 --> 00:14:34,400
it were an int array or a long array and

00:14:31,830 --> 00:14:37,320
it will read it in int or long chunks

00:14:34,400 --> 00:14:40,260
saves a lot of time what does this look

00:14:37,320 --> 00:14:42,300
like in code so here we're gonna get off

00:14:40,260 --> 00:14:45,480
we're gonna use our system out again so

00:14:42,300 --> 00:14:48,720
we get our static var handle and then we

00:14:45,480 --> 00:14:51,210
can do our accesses against that here's

00:14:48,720 --> 00:14:54,390
our byte array buffers or our byte array

00:14:51,210 --> 00:14:56,490
view var handle long method name but we

00:14:54,390 --> 00:14:58,350
can basically take a byte array and make

00:14:56,490 --> 00:15:00,710
it look like it's an int or a long so we

00:14:58,350 --> 00:15:03,180
can walk it with a 32-bit or 64-bit

00:15:00,710 --> 00:15:06,840
stride rather than walking it in 8-bit

00:15:03,180 --> 00:15:09,000
chunks and then being able to access the

00:15:06,840 --> 00:15:11,340
array elements there also again

00:15:09,000 --> 00:15:13,950
something from the VAR handle stuff now

00:15:11,340 --> 00:15:16,080
if we here's where we have the atomic

00:15:13,950 --> 00:15:18,090
access so here is just doing a set

00:15:16,080 --> 00:15:19,680
volatile there are all the different

00:15:18,090 --> 00:15:21,500
types of accesses in the memory model

00:15:19,680 --> 00:15:23,880
are available in the VAR handle API

00:15:21,500 --> 00:15:25,290
including a few that normally are not

00:15:23,880 --> 00:15:28,470
even part of the job of the language

00:15:25,290 --> 00:15:32,250
itself they can be used in other ways

00:15:28,470 --> 00:15:34,380
here is our byte array view so we read

00:15:32,250 --> 00:15:35,730
in a bunch of data off the line we know

00:15:34,380 --> 00:15:39,300
that the data that we're reading from

00:15:35,730 --> 00:15:40,380
this stream is all Long's previously you

00:15:39,300 --> 00:15:42,570
would have to just

00:15:40,380 --> 00:15:45,240
byte by byte combine those things into

00:15:42,570 --> 00:15:48,690
Long's and now you can say okay I'm

00:15:45,240 --> 00:15:50,760
going to turn this into a view that is

00:15:48,690 --> 00:15:54,660
actually pulling lungs off of that byte

00:15:50,760 --> 00:15:56,280
array all at once and that's helpful and

00:15:54,660 --> 00:15:57,960
of course this all fits into the method

00:15:56,280 --> 00:16:00,390
handle API so var handles can be

00:15:57,960 --> 00:16:02,910
converted into method handles and then

00:16:00,390 --> 00:16:04,260
mixed into the same tree and pulled in

00:16:02,910 --> 00:16:09,920
with all the other expressions in logic

00:16:04,260 --> 00:16:13,370
that you have okay so now a primer a

00:16:09,920 --> 00:16:15,810
little short example of a VOC binder

00:16:13,370 --> 00:16:17,490
invoke binders a library that I wrote to

00:16:15,810 --> 00:16:23,130
make it easier to work with the method

00:16:17,490 --> 00:16:25,860
handle API there are some challenges in

00:16:23,130 --> 00:16:27,390
using the method handle API for example

00:16:25,860 --> 00:16:29,280
if I wanted to write this code this is

00:16:27,390 --> 00:16:31,170
basically our running example here of

00:16:29,280 --> 00:16:32,910
system out we're gonna take an argument

00:16:31,170 --> 00:16:34,440
and then we're going to concatenate it

00:16:32,910 --> 00:16:36,150
and print it out if I wanted to

00:16:34,440 --> 00:16:39,090
represent this whole expression this

00:16:36,150 --> 00:16:41,130
whole this whole function as a method

00:16:39,090 --> 00:16:44,130
handles it ends up looking kind of like

00:16:41,130 --> 00:16:46,440
this and it's difficult to read through

00:16:44,130 --> 00:16:48,510
because we're sort of starting at the

00:16:46,440 --> 00:16:50,370
endpoints like there's the field

00:16:48,510 --> 00:16:52,200
there's the concatenate method there's

00:16:50,370 --> 00:16:53,640
the print line okay now down at the

00:16:52,200 --> 00:16:56,580
bottom we're going to filter and change

00:16:53,640 --> 00:16:57,930
some of these arguments around and then

00:16:56,580 --> 00:16:59,940
eventually we can combine this together

00:16:57,930 --> 00:17:02,520
and invoke it but it's very cumbersome

00:16:59,940 --> 00:17:06,510
to read through so what I didn't invoke

00:17:02,520 --> 00:17:08,130
binder rather than composing these

00:17:06,510 --> 00:17:10,260
method handles in Reverse where you have

00:17:08,130 --> 00:17:12,240
to grab a target method and then you

00:17:10,260 --> 00:17:14,910
wrap adaptations around it step by step

00:17:12,240 --> 00:17:16,800
by step you can start at the top and say

00:17:14,910 --> 00:17:18,750
I want to make a method handle that

00:17:16,800 --> 00:17:20,780
takes some arguments in and returns this

00:17:18,750 --> 00:17:22,890
result first thing I want it to do is

00:17:20,780 --> 00:17:24,570
convert an argument second thing I

00:17:22,890 --> 00:17:26,850
wanted to do is call a method third

00:17:24,570 --> 00:17:29,130
thing I want to do is assign to an array

00:17:26,850 --> 00:17:30,450
so we write it going forward rather than

00:17:29,130 --> 00:17:33,690
backwards which is the way the method

00:17:30,450 --> 00:17:35,190
handle API usually makes you do it we

00:17:33,690 --> 00:17:37,560
also the methanol idea is very

00:17:35,190 --> 00:17:39,540
repetitive at each step of the way you

00:17:37,560 --> 00:17:41,460
need to be telling it exactly the types

00:17:39,540 --> 00:17:43,950
that you want to work with even if it's

00:17:41,460 --> 00:17:46,560
should be inferred from the previous

00:17:43,950 --> 00:17:48,690
handles in a VOC binder you carry those

00:17:46,560 --> 00:17:51,120
types forward so it's always aware of

00:17:48,690 --> 00:17:53,280
what the current method type is what the

00:17:51,120 --> 00:17:54,090
current argument types are and actually

00:17:53,280 --> 00:17:55,950
there's some more advanced

00:17:54,090 --> 00:17:57,510
features that lets you use named

00:17:55,950 --> 00:18:01,140
arguments and work with them directly

00:17:57,510 --> 00:18:03,450
that way so let's look at how that

00:18:01,140 --> 00:18:04,950
actually looks at and as an example so

00:18:03,450 --> 00:18:07,110
here is our example again from just

00:18:04,950 --> 00:18:10,039
using the plane method handle API that

00:18:07,110 --> 00:18:12,240
turns into this with VOC binder

00:18:10,039 --> 00:18:15,570
significantly better to read and we can

00:18:12,240 --> 00:18:16,770
actually just walk through it so up here

00:18:15,570 --> 00:18:18,240
we're going to start we know that this

00:18:16,770 --> 00:18:20,340
is going to take a string array that's

00:18:18,240 --> 00:18:22,549
our arguments and we have our void

00:18:20,340 --> 00:18:25,260
return we don't care about that

00:18:22,549 --> 00:18:28,640
continuing on we're going to filter that

00:18:25,260 --> 00:18:31,230
that array by getting the 0 argument and

00:18:28,640 --> 00:18:34,169
pulling it out now we're going to again

00:18:31,230 --> 00:18:36,960
filter that string and prepend hello

00:18:34,169 --> 00:18:39,510
onto it and concatenate that we're going

00:18:36,960 --> 00:18:42,899
to fold in the print stream which we get

00:18:39,510 --> 00:18:45,270
from a static access of system out and

00:18:42,899 --> 00:18:47,909
then we're going to call print line and

00:18:45,270 --> 00:18:49,980
the whole thing becomes one handle one

00:18:47,909 --> 00:18:51,690
tree one expression that we can call and

00:18:49,980 --> 00:18:54,659
pass around and it does all of this

00:18:51,690 --> 00:18:56,070
logic in one little box so that's much

00:18:54,659 --> 00:18:58,350
more advanced than what we can do with

00:18:56,070 --> 00:18:59,669
with a reflection and invoke binder

00:18:58,350 --> 00:19:02,820
makes it considerably easier to read

00:18:59,669 --> 00:19:06,809
through that ok so I said we're gonna

00:19:02,820 --> 00:19:09,510
try and do something crazy with this one

00:19:06,809 --> 00:19:11,429
so now that we have loops as part of the

00:19:09,510 --> 00:19:14,730
method handle API we've essentially

00:19:11,429 --> 00:19:18,390
created a Turing complete set of IR

00:19:14,730 --> 00:19:20,640
right we can we can modify state we can

00:19:18,390 --> 00:19:22,919
call functions we can have conditions we

00:19:20,640 --> 00:19:24,840
can do loops we can represent a language

00:19:22,919 --> 00:19:26,730
we can actually compile a language into

00:19:24,840 --> 00:19:30,390
method handles if we like and so that's

00:19:26,730 --> 00:19:32,399
what I decided to try to do I wrote a

00:19:30,390 --> 00:19:34,649
little compiler that basically takes J

00:19:32,399 --> 00:19:36,539
Ruby's abstract syntax tree and then

00:19:34,649 --> 00:19:40,049
just walks down like a standard visitor

00:19:36,539 --> 00:19:41,730
for each syntactic element I compose the

00:19:40,049 --> 00:19:43,649
right set of handles that would

00:19:41,730 --> 00:19:46,260
represent that particular part of the

00:19:43,649 --> 00:19:48,179
part of the code and then it all just

00:19:46,260 --> 00:19:49,440
composes back out and you get a method

00:19:48,179 --> 00:19:52,919
handle that basically represents the

00:19:49,440 --> 00:19:55,409
script top-level part not terribly

00:19:52,919 --> 00:19:57,090
interesting to look at a few things to

00:19:55,409 --> 00:19:58,409
note I added this little loop thing

00:19:57,090 --> 00:20:00,480
because I wanted to test that it was

00:19:58,409 --> 00:20:02,899
compiling and ginning and optimizing

00:20:00,480 --> 00:20:02,899
correctly

00:20:03,460 --> 00:20:08,860
yes not much more that's interesting

00:20:05,170 --> 00:20:10,450
here so let's continue on like I said

00:20:08,860 --> 00:20:13,360
it's a standard visitor so we have our

00:20:10,450 --> 00:20:16,090
node and then we walk down the node tree

00:20:13,360 --> 00:20:18,370
each node calls except on our compiler

00:20:16,090 --> 00:20:20,680
and then we get back into our logic

00:20:18,370 --> 00:20:23,680
here's a couple simple cases two

00:20:20,680 --> 00:20:25,240
constants types false and true and in

00:20:23,680 --> 00:20:28,870
this case I'm just using the objects

00:20:25,240 --> 00:20:32,800
false and true from boolean and the

00:20:28,870 --> 00:20:34,540
logic here we have our our state for

00:20:32,800 --> 00:20:36,070
this script that's being passed in we

00:20:34,540 --> 00:20:37,900
have some return value from the script

00:20:36,070 --> 00:20:39,880
we don't care about the state this is a

00:20:37,900 --> 00:20:42,430
constant and we stick our boolean false

00:20:39,880 --> 00:20:43,870
and the same thing with true here let's

00:20:42,430 --> 00:20:46,780
look at something else we got fixed

00:20:43,870 --> 00:20:50,500
number so here is our fixed num which is

00:20:46,780 --> 00:20:52,210
in Ruby just a long essentially and I'm

00:20:50,500 --> 00:20:54,280
using box Long's for this example just

00:20:52,210 --> 00:20:56,260
to make it simpler but again we don't

00:20:54,280 --> 00:20:58,710
care about the state for the script so

00:20:56,260 --> 00:21:01,600
we drop that and we return a constant

00:20:58,710 --> 00:21:03,250
what about local variables well so I

00:21:01,600 --> 00:21:05,380
said that we've got our state array

00:21:03,250 --> 00:21:07,810
that's basically holding all of our

00:21:05,380 --> 00:21:10,720
local variables so to get a local

00:21:07,810 --> 00:21:12,850
variable out of our our script state we

00:21:10,720 --> 00:21:15,730
just provide the index and do an array

00:21:12,850 --> 00:21:18,640
get similarly down here we have our

00:21:15,730 --> 00:21:19,960
state for the script we're going to do a

00:21:18,640 --> 00:21:22,450
little bit more complicated logic

00:21:19,960 --> 00:21:24,700
because these set into an array doesn't

00:21:22,450 --> 00:21:27,070
return a value so we're going to capture

00:21:24,700 --> 00:21:29,560
this the value we want to set put it

00:21:27,070 --> 00:21:31,210
into the array and also return it and I

00:21:29,560 --> 00:21:33,730
won't walk through all the logic here

00:21:31,210 --> 00:21:35,890
but basically the same thing as doing an

00:21:33,730 --> 00:21:39,430
array set and assigning it to one of the

00:21:35,890 --> 00:21:43,570
elements in our script here is there an

00:21:39,430 --> 00:21:44,860
if not much to say pretty easy the only

00:21:43,570 --> 00:21:47,020
thing that's a little bit different

00:21:44,860 --> 00:21:49,780
there the condition needs to return a

00:21:47,020 --> 00:21:52,450
boolean and so whatever the result of

00:21:49,780 --> 00:21:54,850
that sub expression is we run some sort

00:21:52,450 --> 00:21:56,260
of truth a check on it and in the case

00:21:54,850 --> 00:21:59,740
of Ruby that would be anything that's

00:21:56,260 --> 00:22:01,240
not nil or false is considered true in

00:21:59,740 --> 00:22:02,950
the case of this script I did something

00:22:01,240 --> 00:22:04,810
similar and then we can put our

00:22:02,950 --> 00:22:07,660
condition our then in our else so we've

00:22:04,810 --> 00:22:10,720
represented an if expression from Ruby

00:22:07,660 --> 00:22:12,760
in method handles and then of course we

00:22:10,720 --> 00:22:15,310
have while loops finally

00:22:12,760 --> 00:22:17,050
so we compile our condition again we

00:22:15,310 --> 00:22:18,309
compile our body

00:22:17,050 --> 00:22:21,370
we're checking to see whether this is a

00:22:18,309 --> 00:22:24,640
while loop or a do-while loop and then

00:22:21,370 --> 00:22:27,660
we take our script state we invoke our

00:22:24,640 --> 00:22:31,270
filtered predicate our filter condition

00:22:27,660 --> 00:22:34,120
we have our body which just runs the

00:22:31,270 --> 00:22:35,790
code that's in the body and then we can

00:22:34,120 --> 00:22:38,620
create our two different while loops

00:22:35,790 --> 00:22:39,910
okay of course there's obviously a lot

00:22:38,620 --> 00:22:42,340
of other different types of expressions

00:22:39,910 --> 00:22:45,280
in Ruby but here now we're at the root

00:22:42,340 --> 00:22:46,929
this is at the top of the script so of

00:22:45,280 --> 00:22:49,210
course we just compile the whole body

00:22:46,929 --> 00:22:51,850
this is where we get how many local

00:22:49,210 --> 00:22:53,380
variables we want to have and we throw

00:22:51,850 --> 00:22:55,510
an array construct in here so we

00:22:53,380 --> 00:22:57,309
construct our array of local variables

00:22:55,510 --> 00:22:58,960
and then that gets passed down through

00:22:57,309 --> 00:23:01,410
the method handles all the way into the

00:22:58,960 --> 00:23:03,640
rest of the script so does all this work

00:23:01,410 --> 00:23:06,730
well I wouldn't be here if it didn't

00:23:03,640 --> 00:23:08,530
work of course it works here is our ast

00:23:06,730 --> 00:23:11,080
we've run a simple loop that just

00:23:08,530 --> 00:23:12,850
iterates a value and then I've set it up

00:23:11,080 --> 00:23:15,040
so that whatever the last value is of

00:23:12,850 --> 00:23:17,050
the script will be printed out and there

00:23:15,040 --> 00:23:18,520
we go there's our result but does it

00:23:17,050 --> 00:23:19,870
work well of course we could have

00:23:18,520 --> 00:23:21,970
written an interpreter in just regular

00:23:19,870 --> 00:23:25,540
Java code that would not be interesting

00:23:21,970 --> 00:23:27,010
for this does it actually optimize does

00:23:25,540 --> 00:23:29,830
it actually compile like we want it to

00:23:27,010 --> 00:23:33,550
and I'm thrilled to say that it actually

00:23:29,830 --> 00:23:36,670
does this is assembly code that has now

00:23:33,550 --> 00:23:38,830
been generated from our compiler but we

00:23:36,670 --> 00:23:40,809
have not generated any bytecode we have

00:23:38,830 --> 00:23:42,940
not loaded any Java classes all we've

00:23:40,809 --> 00:23:47,340
done is built up a method handle tree

00:23:42,940 --> 00:23:47,340
and executed it that's pretty cool

00:23:51,830 --> 00:23:56,160
alright so now a little bit more about

00:23:54,060 --> 00:23:58,350
results here the compiled code this

00:23:56,160 --> 00:24:00,300
compiled method handle tree actually

00:23:58,350 --> 00:24:02,100
does end up turning into one piece of

00:24:00,300 --> 00:24:04,050
native code and that's great that's what

00:24:02,100 --> 00:24:08,190
we were looking for it takes a while to

00:24:04,050 --> 00:24:10,380
get there normally like the c2 threshold

00:24:08,190 --> 00:24:12,810
for doing the the optimized compile is

00:24:10,380 --> 00:24:14,160
10,000 iterations I had to run this for

00:24:12,810 --> 00:24:15,840
at least a hundred thousand to get the

00:24:14,160 --> 00:24:18,050
stuff to come out there's a lot of other

00:24:15,840 --> 00:24:20,700
plumbing in the method handle API that

00:24:18,050 --> 00:24:24,690
gets in the way of the JIT but it does

00:24:20,700 --> 00:24:26,940
eventually get there it may be a toy but

00:24:24,690 --> 00:24:28,350
it's kind of an interesting toy couldn't

00:24:26,940 --> 00:24:30,390
we do something more practical with this

00:24:28,350 --> 00:24:33,150
and now this is going to be the the to

00:24:30,390 --> 00:24:35,970
be determined sort of thing what about

00:24:33,150 --> 00:24:36,390
the streams API so the streams API and

00:24:35,970 --> 00:24:38,220
Java

00:24:36,390 --> 00:24:41,190
you've got you know a collector a map

00:24:38,220 --> 00:24:43,530
utility functions that you call you pass

00:24:41,190 --> 00:24:45,480
in a function and you know the map will

00:24:43,530 --> 00:24:47,600
call your little lambda for each element

00:24:45,480 --> 00:24:50,580
and replace the results in the list

00:24:47,600 --> 00:24:53,640
unfortunately everybody in the world is

00:24:50,580 --> 00:24:55,740
calling into that same map function the

00:24:53,640 --> 00:24:58,590
JVM has no way to see through and

00:24:55,740 --> 00:25:00,840
optimize your map versus somebody else

00:24:58,590 --> 00:25:03,030
is mad so none of it in lines none of it

00:25:00,840 --> 00:25:04,530
optimizes the right way well what if we

00:25:03,030 --> 00:25:06,990
implemented streams as handles I

00:25:04,530 --> 00:25:09,180
basically just did that here is not

00:25:06,990 --> 00:25:12,440
difficult to do we can take every single

00:25:09,180 --> 00:25:14,820
operation that is you know too generic

00:25:12,440 --> 00:25:17,790
too difficult to specialize in the

00:25:14,820 --> 00:25:20,040
streams API turn them into a tree of

00:25:17,790 --> 00:25:22,230
handles and then each place we call it

00:25:20,040 --> 00:25:25,230
it will inline specialized into our

00:25:22,230 --> 00:25:26,970
local piece of code and have the target

00:25:25,230 --> 00:25:29,040
function that lambda that we want in

00:25:26,970 --> 00:25:30,690
line all the way back and that's what

00:25:29,040 --> 00:25:35,190
I'm gonna start playing with after I'm

00:25:30,690 --> 00:25:37,520
done with this talk so anybody want play

00:25:35,190 --> 00:25:40,290
with this invoke binder is out there

00:25:37,520 --> 00:25:42,780
it's hideous invoke binder on my account

00:25:40,290 --> 00:25:45,210
you'll be able to see all this online on

00:25:42,780 --> 00:25:46,530
the slides and if any was interested in

00:25:45,210 --> 00:25:49,200
playing around with the streams thing

00:25:46,530 --> 00:25:50,280
you know send me an email let me know I

00:25:49,200 --> 00:25:51,330
think there's a lot more we could be

00:25:50,280 --> 00:25:53,220
doing with method handles than we're

00:25:51,330 --> 00:26:03,950
doing today thank you

00:25:53,220 --> 00:26:03,950
[Applause]

00:26:08,000 --> 00:26:10,060

YouTube URL: https://www.youtube.com/watch?v=aD_qoI68zHA


