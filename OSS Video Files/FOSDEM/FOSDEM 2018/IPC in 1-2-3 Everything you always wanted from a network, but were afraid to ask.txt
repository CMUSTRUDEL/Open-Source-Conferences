Title: IPC in 1-2-3 Everything you always wanted from a network, but were afraid to ask
Publication date: 2018-02-04
Playlist: FOSDEM 2018
Description: 
	by Dimitri Staessens and Sander Vrijders

At: FOSDEM 2018
Room: K.1.105 (La Fontaine)
Scheduled start: 2018-02-03 16:00:00+01
Captions: 
	00:00:05,890 --> 00:00:14,599
sandir I hope I pronounced that right

00:00:08,440 --> 00:00:26,960
are going to talk about IPC so a round

00:00:14,599 --> 00:00:29,420
of applause for IPC in one two three yes

00:00:26,960 --> 00:00:32,029
so thank you for the introduction so

00:00:29,420 --> 00:00:34,940
sorry for this the short delay there was

00:00:32,029 --> 00:00:36,440
some problem with the connection so

00:00:34,940 --> 00:00:40,040
welcome to our talk

00:00:36,440 --> 00:00:42,830
IPC in one two three I'm Dimitri this is

00:00:40,040 --> 00:00:44,900
sunder and so we are students

00:00:42,830 --> 00:00:47,690
researchers from Ghent University in

00:00:44,900 --> 00:00:50,809
Belgium it's not very far from here from

00:00:47,690 --> 00:00:53,629
Brussels and we work on topic our topic

00:00:50,809 --> 00:00:56,629
is next-generation Internet and if you

00:00:53,629 --> 00:00:58,280
saw the the presentation this morning we

00:00:56,629 --> 00:01:00,350
work on European projects European

00:00:58,280 --> 00:01:02,299
funded projects like a rata pristine art

00:01:00,350 --> 00:01:04,850
fire there they are projects in the

00:01:02,299 --> 00:01:07,189
topic of future internet and we do

00:01:04,850 --> 00:01:09,050
research on test batch which are funded

00:01:07,189 --> 00:01:12,440
by the European Commission and by the

00:01:09,050 --> 00:01:14,060
u.s. fire actually the the person that

00:01:12,440 --> 00:01:15,860
gave the presentation this morning is

00:01:14,060 --> 00:01:18,350
very involved in this fire project and

00:01:15,860 --> 00:01:19,760
the NGI is the successor of fire and we

00:01:18,350 --> 00:01:21,770
also use geni which is the global

00:01:19,760 --> 00:01:23,960
environment for networked innovation in

00:01:21,770 --> 00:01:25,640
the US and they are very large test beds

00:01:23,960 --> 00:01:27,590
that provide us with a lot of servers

00:01:25,640 --> 00:01:32,480
and interconnections so we can do a

00:01:27,590 --> 00:01:34,460
large-scale experimentation so why do we

00:01:32,480 --> 00:01:35,780
need a next-generation internets well if

00:01:34,460 --> 00:01:37,010
you have been following the news there's

00:01:35,780 --> 00:01:39,230
a lot of things that can go wrong

00:01:37,010 --> 00:01:41,930
there's attacks on the infrastructure

00:01:39,230 --> 00:01:44,840
like on servers where you do DDoS

00:01:41,930 --> 00:01:47,630
attacks scalability problems where your

00:01:44,840 --> 00:01:49,430
BGP routers are overflowing with entries

00:01:47,630 --> 00:01:52,220
and there is also attacks on the

00:01:49,430 --> 00:01:53,720
physical infrastructure from sharks

00:01:52,220 --> 00:01:55,460
apparently they are attracted to

00:01:53,720 --> 00:01:57,740
undersea cables by the magnetic fields

00:01:55,460 --> 00:02:00,740
and they disrupt the connections and

00:01:57,740 --> 00:02:03,110
also the Russians are developing ships

00:02:00,740 --> 00:02:05,000
that could in theory break undersea

00:02:03,110 --> 00:02:07,790
cables so there's disruptions of the

00:02:05,000 --> 00:02:11,150
infrastructure also internet security

00:02:07,790 --> 00:02:13,670
there's a lot of hacks going on bugs and

00:02:11,150 --> 00:02:15,680
heart bleeds very important and also

00:02:13,670 --> 00:02:16,590
there are problems with security we all

00:02:15,680 --> 00:02:21,000
know the Snowden

00:02:16,590 --> 00:02:22,470
and your data is actually worth a lot to

00:02:21,000 --> 00:02:23,880
a lot of companies and it's not only the

00:02:22,470 --> 00:02:25,440
government that's after your data but

00:02:23,880 --> 00:02:30,120
also a lot of private companies they

00:02:25,440 --> 00:02:32,550
data mined everything so our methodology

00:02:30,120 --> 00:02:34,500
is that we basically well we do

00:02:32,550 --> 00:02:36,480
experimental research and it's quite

00:02:34,500 --> 00:02:38,430
hard to do experimental research on the

00:02:36,480 --> 00:02:41,040
Internet of the future because it's not

00:02:38,430 --> 00:02:43,290
here yet so we develop it ourselves so

00:02:41,040 --> 00:02:46,170
we develop a lot of tools and software

00:02:43,290 --> 00:02:48,810
and we then deploy it on our test beds

00:02:46,170 --> 00:02:50,880
and then we write research papers about

00:02:48,810 --> 00:02:55,500
him so what we're going to talk about

00:02:50,880 --> 00:02:57,480
today is about the stuff the prototypes

00:02:55,500 --> 00:02:59,280
that we have been developing and we are

00:02:57,480 --> 00:03:01,440
looking at the problems flight

00:02:59,280 --> 00:03:03,080
reliability and privacy on the earth

00:03:01,440 --> 00:03:06,239
that from an architectural perspective

00:03:03,080 --> 00:03:11,480
so what you've all been taught in school

00:03:06,239 --> 00:03:11,480
is like the seven layer OSI model and

00:03:11,599 --> 00:03:16,620
they try to build networks from the

00:03:14,700 --> 00:03:18,390
perspective that every layer has it has

00:03:16,620 --> 00:03:20,760
a different function they try to split

00:03:18,390 --> 00:03:23,010
layers by function but when you look at

00:03:20,760 --> 00:03:23,850
how it's implemented that's not always

00:03:23,010 --> 00:03:25,709
the case

00:03:23,850 --> 00:03:27,540
so encryption is in the presentation

00:03:25,709 --> 00:03:29,820
layer by OSI but it's implement in the

00:03:27,540 --> 00:03:32,040
transport layer with TLS it's usually

00:03:29,820 --> 00:03:34,109
also in your application and there's a

00:03:32,040 --> 00:03:36,000
lot of Technology crossover even in the

00:03:34,109 --> 00:03:37,560
lower layers so recent developments for

00:03:36,000 --> 00:03:39,780
Ethernet they are actually implementing

00:03:37,560 --> 00:03:42,269
routing which is typically layer 3 into

00:03:39,780 --> 00:03:44,850
layer 2 networks so there are also

00:03:42,269 --> 00:03:45,299
technologies like MPLS at layer 2 and a

00:03:44,850 --> 00:03:47,430
half

00:03:45,299 --> 00:03:49,590
VPNs which don't really fit the model

00:03:47,430 --> 00:03:54,180
tunnel IP tunnels don't really fit the

00:03:49,590 --> 00:03:56,190
model so a couple of years ago there's a

00:03:54,180 --> 00:03:58,739
guy that wrote a book John Day and he

00:03:56,190 --> 00:04:00,930
proposed an alternative architecture for

00:03:58,739 --> 00:04:03,810
large-scale networks and it's recursive

00:04:00,930 --> 00:04:06,030
so every layer is exactly the same so we

00:04:03,810 --> 00:04:07,560
don't say every function is in a

00:04:06,030 --> 00:04:09,750
different player but all layers have all

00:04:07,560 --> 00:04:11,100
the functions possibly you don't have to

00:04:09,750 --> 00:04:14,700
implement them if you don't need them

00:04:11,100 --> 00:04:16,650
and the the only way that that the

00:04:14,700 --> 00:04:18,600
layers are different is by scope so you

00:04:16,650 --> 00:04:20,700
have a big network over a small network

00:04:18,600 --> 00:04:23,910
and if you need a near PPN you just run

00:04:20,700 --> 00:04:25,860
it on top for that to work you need an

00:04:23,910 --> 00:04:27,840
identical API between the layers so you

00:04:25,860 --> 00:04:29,880
cannot stack them and currently that's

00:04:27,840 --> 00:04:30,450
not the case so you have the sockets API

00:04:29,880 --> 00:04:32,550
you can

00:04:30,450 --> 00:04:36,660
access every Network clear like you want

00:04:32,550 --> 00:04:40,680
so if you want to run TCP transport you

00:04:36,660 --> 00:04:42,510
would run an Internet address family and

00:04:40,680 --> 00:04:44,790
say I want a streaming socket or if you

00:04:42,510 --> 00:04:47,520
want UDP you would use a Datagram socket

00:04:44,790 --> 00:04:50,730
but the API is a little bit different

00:04:47,520 --> 00:04:52,290
for every layer that you want to use so

00:04:50,730 --> 00:04:55,230
what we have been developing is a

00:04:52,290 --> 00:04:57,030
prototype called ro burrows and it's on

00:04:55,230 --> 00:05:00,030
this Ouroboros it's a decentralized

00:04:57,030 --> 00:05:03,240
packet switch network that is based on

00:05:00,030 --> 00:05:05,550
IPC so so the the API is based on IPC

00:05:03,240 --> 00:05:08,940
its redesigned from the ground up it

00:05:05,550 --> 00:05:11,790
follows this recursive model it blurs

00:05:08,940 --> 00:05:14,400
the difference between IPC between local

00:05:11,790 --> 00:05:16,080
networks between world area networks to

00:05:14,400 --> 00:05:16,650
the application developer it all looks

00:05:16,080 --> 00:05:21,390
the same

00:05:16,650 --> 00:05:23,220
it looks like IPC it gives you we hope a

00:05:21,390 --> 00:05:25,830
better service than you are used to from

00:05:23,220 --> 00:05:27,990
TCP and UDP because we have different

00:05:25,830 --> 00:05:30,030
ways of implementing this functionality

00:05:27,990 --> 00:05:33,090
it's increased privacy security

00:05:30,030 --> 00:05:35,160
anonymity and it's a very simple API is

00:05:33,090 --> 00:05:36,750
it simply the simplest API I don't know

00:05:35,160 --> 00:05:39,090
and that's where we're going to start so

00:05:36,750 --> 00:05:41,490
we're going to look at the or a boss API

00:05:39,090 --> 00:05:43,710
so we have your computer you have to

00:05:41,490 --> 00:05:46,080
process sitting there and what happens

00:05:43,710 --> 00:05:50,850
your kernel is giving it to process IDs

00:05:46,080 --> 00:05:54,270
so we have this layer we will gradually

00:05:50,850 --> 00:05:55,980
tell what's in there so these the

00:05:54,270 --> 00:05:59,049
layering

00:05:55,980 --> 00:05:59,049
[Music]

00:06:05,740 --> 00:06:11,030
so the recursive model always works over

00:06:08,630 --> 00:06:12,650
a layer and we'll now it's very

00:06:11,030 --> 00:06:14,300
abstracting that we'll get to what a

00:06:12,650 --> 00:06:17,120
layer actually does and what it consists

00:06:14,300 --> 00:06:19,550
of so you have a client and a server in

00:06:17,120 --> 00:06:21,979
your local PC so it's just one machine

00:06:19,550 --> 00:06:25,340
and it gets a PID from the kernel and

00:06:21,979 --> 00:06:27,080
you we allocate something that's called

00:06:25,340 --> 00:06:28,850
the flow and it's an abstract construct

00:06:27,080 --> 00:06:31,400
it's a pipe it's a bi-directional pipe

00:06:28,850 --> 00:06:33,860
where you writes packets on one end and

00:06:31,400 --> 00:06:35,540
you have a reasonable probability that

00:06:33,860 --> 00:06:38,000
you can read them from the other other

00:06:35,540 --> 00:06:39,889
end so that's a flow of abstract

00:06:38,000 --> 00:06:43,100
construct and the function of the layer

00:06:39,889 --> 00:06:45,770
is to provide you with the flow so the

00:06:43,100 --> 00:06:47,210
first goal is flow except you have a

00:06:45,770 --> 00:06:49,669
server application Elkville

00:06:47,210 --> 00:06:52,310
except flows it returns you something

00:06:49,669 --> 00:06:54,020
that we call a flow descriptor and any

00:06:52,310 --> 00:06:57,620
resemblance with the file descriptor is

00:06:54,020 --> 00:07:00,289
purely coincidental so on this client

00:06:57,620 --> 00:07:02,600
side you have the call flow allocate

00:07:00,289 --> 00:07:05,690
which will start a flow towards the

00:07:02,600 --> 00:07:08,180
server you could do that based on the

00:07:05,690 --> 00:07:09,710
PID but that's a little bit difficult I

00:07:08,180 --> 00:07:12,260
mean that would be every time you start

00:07:09,710 --> 00:07:15,919
a server it gets a new fee ID so we have

00:07:12,260 --> 00:07:18,979
a second function that we implement and

00:07:15,919 --> 00:07:20,930
it's called binding so we just assign a

00:07:18,979 --> 00:07:24,500
certain name and whatever name space to

00:07:20,930 --> 00:07:26,510
that to that process you register it in

00:07:24,500 --> 00:07:28,430
the layer as a function which will come

00:07:26,510 --> 00:07:31,250
back later and you can allocate to the

00:07:28,430 --> 00:07:33,410
name that's roughly the full API after

00:07:31,250 --> 00:07:35,570
you allocate it so it's IPC in one two

00:07:33,410 --> 00:07:37,160
three these are three functions binding

00:07:35,570 --> 00:07:41,060
names registering the name in the layer

00:07:37,160 --> 00:07:42,820
and allocating a flow after that you can

00:07:41,060 --> 00:07:45,139
read and write from the buffer the

00:07:42,820 --> 00:07:46,660
signature of those course is exactly the

00:07:45,139 --> 00:07:49,370
same as read and write from your

00:07:46,660 --> 00:07:51,620
favorite system course and when you're

00:07:49,370 --> 00:07:55,550
done with with communication you'll be

00:07:51,620 --> 00:07:57,080
allocated flow so your kernel currently

00:07:55,550 --> 00:08:01,550
doesn't know this course so we had to

00:07:57,080 --> 00:08:03,289
implement them in our for system and we

00:08:01,550 --> 00:08:04,970
chose to do it in user space so we have

00:08:03,289 --> 00:08:06,289
a user space system we've implemented

00:08:04,970 --> 00:08:08,900
this in c89

00:08:06,289 --> 00:08:11,330
just to make it as portable as we could

00:08:08,900 --> 00:08:15,500
and keep very low dependencies and it's

00:08:11,330 --> 00:08:17,860
based on POSIX 2001-2008 mostly for the

00:08:15,500 --> 00:08:19,810
training we use a lot of be threads

00:08:17,860 --> 00:08:21,819
mutexes robust mutexes if they're

00:08:19,810 --> 00:08:24,610
available in the system

00:08:21,819 --> 00:08:26,590
it runs on new linux on freebsd on OSX

00:08:24,610 --> 00:08:28,689
sierra and if you have the Lindo the

00:08:26,590 --> 00:08:31,060
linux subsystem for windows it works

00:08:28,689 --> 00:08:33,399
perfectly fine there there are some work

00:08:31,060 --> 00:08:35,050
to get it to run on the new hurt and on

00:08:33,399 --> 00:08:36,940
androids Android doesn't completely

00:08:35,050 --> 00:08:38,740
implement POSIX so there's there's more

00:08:36,940 --> 00:08:41,860
work and we haven't done that capsule so

00:08:38,740 --> 00:08:44,560
the prototype doesn't work there so the

00:08:41,860 --> 00:08:46,930
core part of the system is a demon we

00:08:44,560 --> 00:08:49,779
call it the IPC resource manager daemon

00:08:46,930 --> 00:08:52,300
and do so you can start this by just

00:08:49,779 --> 00:08:54,670
running the binary or you can start it

00:08:52,300 --> 00:08:57,420
enable it using system D so that it

00:08:54,670 --> 00:09:01,990
actually runs as a daemon in your system

00:08:57,420 --> 00:09:04,000
this is a complete source code example

00:09:01,990 --> 00:09:07,750
it's C so if you know C that helps if

00:09:04,000 --> 00:09:09,940
you don't know C it's reasonably simple

00:09:07,750 --> 00:09:12,370
it's an self-explanatory so you have a

00:09:09,940 --> 00:09:15,490
the full source code of a server and

00:09:12,370 --> 00:09:17,529
clients in C so the API is extremely

00:09:15,490 --> 00:09:20,050
simple you have the server which will

00:09:17,529 --> 00:09:22,060
accept the flow a client which allocates

00:09:20,050 --> 00:09:24,699
the flow to a certain name we hard-coded

00:09:22,060 --> 00:09:26,740
that to be echo the client sends a one

00:09:24,699 --> 00:09:28,779
message to the server the server sends

00:09:26,740 --> 00:09:30,399
it back and they do locate the flow so

00:09:28,779 --> 00:09:32,920
this is the output if you render the

00:09:30,399 --> 00:09:34,990
echo up it will start the server say I

00:09:32,920 --> 00:09:37,600
got a new flow and the client allocates

00:09:34,990 --> 00:09:42,269
its client says hi that's its with very

00:09:37,600 --> 00:09:44,860
simple API and it's the same API always

00:09:42,269 --> 00:09:47,260
so what are the functions of a layer

00:09:44,860 --> 00:09:48,940
because that layer has to provide all

00:09:47,260 --> 00:09:51,070
the functionality that you need to for

00:09:48,940 --> 00:09:53,649
do it for two processes to communicate

00:09:51,070 --> 00:09:55,540
with each other so first of all the bind

00:09:53,649 --> 00:09:57,279
operation is not a part of the layer the

00:09:55,540 --> 00:09:58,779
bind operation where you bind that

00:09:57,279 --> 00:10:01,149
process to your name is something that's

00:09:58,779 --> 00:10:03,100
local to your system because process IDs

00:10:01,149 --> 00:10:05,800
you don't need to send out anywhere over

00:10:03,100 --> 00:10:08,370
any network so that's a local call in

00:10:05,800 --> 00:10:11,410
the system so the only two things that

00:10:08,370 --> 00:10:16,240
that the layer has to produce or to

00:10:11,410 --> 00:10:17,620
perform is to register names and to

00:10:16,240 --> 00:10:19,300
perform the floor location so these

00:10:17,620 --> 00:10:20,649
functions are keep track and figure out

00:10:19,300 --> 00:10:22,839
where there are n points of

00:10:20,649 --> 00:10:26,050
communication so that's the directory

00:10:22,839 --> 00:10:28,060
service at your map locations of certain

00:10:26,050 --> 00:10:29,740
names in the network it will figure out

00:10:28,060 --> 00:10:31,510
how to get packets from one point to

00:10:29,740 --> 00:10:33,310
another so it has to implement

00:10:31,510 --> 00:10:35,110
rotting functionality it has to

00:10:33,310 --> 00:10:36,910
effectively forward those packets to it

00:10:35,110 --> 00:10:39,220
implements forwarding functionality and

00:10:36,910 --> 00:10:42,040
it has to allocate and release the

00:10:39,220 --> 00:10:45,010
resources and that's our flow allocation

00:10:42,040 --> 00:10:46,510
so this is not an exhaustive list so

00:10:45,010 --> 00:10:48,070
actually there are functions a layer

00:10:46,510 --> 00:10:50,950
like congestion control but we're not

00:10:48,070 --> 00:10:56,440
going to discuss that today we don't

00:10:50,950 --> 00:11:01,020
have time so let's look at local IPC

00:10:56,440 --> 00:11:04,090
over the Ouroboros sub subsystem so

00:11:01,020 --> 00:11:05,890
usually if you have a tcp/ip stack loop

00:11:04,090 --> 00:11:07,600
like local IPC you use it or loop

00:11:05,890 --> 00:11:08,920
loopback interface it goes through the

00:11:07,600 --> 00:11:13,350
entire stack so your application

00:11:08,920 --> 00:11:15,550
delivers it to TCP to your Ethernet

00:11:13,350 --> 00:11:18,250
usually virtualized it goes to the

00:11:15,550 --> 00:11:19,420
kernel gets back so in our system we can

00:11:18,250 --> 00:11:21,190
do it as well but of course it's

00:11:19,420 --> 00:11:22,450
recursive there is no really need for

00:11:21,190 --> 00:11:25,270
all these layers so you can do it

00:11:22,450 --> 00:11:28,720
directly over a loopback layer so we'll

00:11:25,270 --> 00:11:31,420
show you the actual commands to empty to

00:11:28,720 --> 00:11:35,050
perform this on on your system so you

00:11:31,420 --> 00:11:36,610
start uroboros subsystem then you start

00:11:35,050 --> 00:11:40,150
the server and the first thing that it

00:11:36,610 --> 00:11:43,240
will do is indicate to the subsystem

00:11:40,150 --> 00:11:46,150
that there is an robots capable server

00:11:43,240 --> 00:11:47,770
running this happens all behind behind

00:11:46,150 --> 00:11:52,870
the scenes so you don't have to

00:11:47,770 --> 00:11:54,400
implement its implemented using using

00:11:52,870 --> 00:11:57,040
the linker so it's simple method before

00:11:54,400 --> 00:11:59,890
you you even call main so it just says

00:11:57,040 --> 00:12:03,640
to that system I am here I'm in robots

00:11:59,890 --> 00:12:06,220
process the next thing that you do is

00:12:03,640 --> 00:12:11,440
that we do is bind that name that

00:12:06,220 --> 00:12:14,590
process 6417 to the name server so your

00:12:11,440 --> 00:12:20,100
abort system knows that 6417 listens to

00:12:14,590 --> 00:12:22,570
the name server then we create the layer

00:12:20,100 --> 00:12:25,060
it's one command if the bootstrap

00:12:22,570 --> 00:12:26,890
command for the layer itself or all the

00:12:25,060 --> 00:12:31,570
functionality for moving packets between

00:12:26,890 --> 00:12:34,660
the client and the server then we

00:12:31,570 --> 00:12:36,760
register the server into that layer we

00:12:34,660 --> 00:12:40,990
we don't register the name server

00:12:36,760 --> 00:12:43,060
directly for we just hash it so so the

00:12:40,990 --> 00:12:44,249
you can choose a shell gorilla as you

00:12:43,060 --> 00:12:48,279
like

00:12:44,249 --> 00:12:49,929
we just hash it for it's more secure in

00:12:48,279 --> 00:12:53,739
the implementation because people cannot

00:12:49,929 --> 00:12:56,319
start feeding very large strings and

00:12:53,739 --> 00:12:57,819
it's more secure as well because if you

00:12:56,319 --> 00:13:00,009
have to send this over the network it's

00:12:57,819 --> 00:13:01,809
less legible and people aren't able to

00:13:00,009 --> 00:13:04,149
figure out what happens and then the

00:13:01,809 --> 00:13:06,699
third step you start to decline

00:13:04,149 --> 00:13:08,649
it's a ping client it will send a number

00:13:06,699 --> 00:13:10,869
of messages to the server when you're

00:13:08,649 --> 00:13:12,939
done you kill the clients flow gets the

00:13:10,869 --> 00:13:15,610
allocated and we're done so that's how

00:13:12,939 --> 00:13:18,089
local IP see over the sub system works

00:13:15,610 --> 00:13:21,100
and it's always in three steps binding

00:13:18,089 --> 00:13:23,110
registering and allocating and that's

00:13:21,100 --> 00:13:25,360
all that's to it so there is very little

00:13:23,110 --> 00:13:28,569
configuration you don't have to worry

00:13:25,360 --> 00:13:31,509
about ports or addresses that's all

00:13:28,569 --> 00:13:34,329
completely hidden from you so let's look

00:13:31,509 --> 00:13:35,499
at our Boris over layer X so we're not

00:13:34,329 --> 00:13:40,989
on one system anymore

00:13:35,499 --> 00:13:44,619
we're on two systems so to write over

00:13:40,989 --> 00:13:50,589
layer X we have to wrap that layer X

00:13:44,619 --> 00:13:52,839
with our API so the first thing we start

00:13:50,589 --> 00:13:56,949
your abort system subsystem and recreate

00:13:52,839 --> 00:14:02,769
in this case a layer instantiation on

00:13:56,949 --> 00:14:05,499
that machine which is it's attached to

00:14:02,769 --> 00:14:07,209
your internet device so the only

00:14:05,499 --> 00:14:09,490
configuration that we give to the system

00:14:07,209 --> 00:14:11,829
is by one thing something that connects

00:14:09,490 --> 00:14:15,160
two Ethernet I give the layer a name

00:14:11,829 --> 00:14:18,819
Ethernet and I say it's connected to my

00:14:15,160 --> 00:14:21,369
wireless interface after we do that I

00:14:18,819 --> 00:14:23,949
register a name in that layer so from

00:14:21,369 --> 00:14:25,569
now my ethernet layer locally it's

00:14:23,949 --> 00:14:28,600
something like ARP but not not

00:14:25,569 --> 00:14:31,329
completely we implemented ourselves but

00:14:28,600 --> 00:14:34,559
so it registers that hash and it says on

00:14:31,329 --> 00:14:38,759
this machine if I get a request for a

00:14:34,559 --> 00:14:43,959
for communication with IO q3 or Spain at

00:14:38,759 --> 00:14:48,579
short I will accept it so instead of

00:14:43,959 --> 00:14:50,919
only having our own applications IO

00:14:48,579 --> 00:14:52,869
quake is actually an open-source project

00:14:50,919 --> 00:14:57,100
it's developed from the quake 3 arena

00:14:52,869 --> 00:15:00,010
engine that was a GPL released years ago

00:14:57,100 --> 00:15:02,830
and we rode the patch for it so that you

00:15:00,010 --> 00:15:07,300
can run the game over our stack instead

00:15:02,830 --> 00:15:09,130
of over Ethernet or tcp/ip and then I

00:15:07,300 --> 00:15:13,510
bind the program which is this is the

00:15:09,130 --> 00:15:15,700
binary for the dedicated server and so

00:15:13,510 --> 00:15:17,410
the previous time we bounced the process

00:15:15,700 --> 00:15:19,450
but actually that's also you have every

00:15:17,410 --> 00:15:22,180
time you have to look for the process ID

00:15:19,450 --> 00:15:24,910
so we just say whenever this this kind

00:15:22,180 --> 00:15:28,600
of binary is started just have it listen

00:15:24,910 --> 00:15:30,550
to IO q3 names so we start a server and

00:15:28,600 --> 00:15:32,710
it's done so that's the setup of the

00:15:30,550 --> 00:15:34,450
server side there is absolutely no

00:15:32,710 --> 00:15:37,050
configuration involved instead of saying

00:15:34,450 --> 00:15:39,760
it has to be on that wireless interface

00:15:37,050 --> 00:15:43,000
for the clients we start to the client

00:15:39,760 --> 00:15:45,580
it's the Ouroboros subsystem then we say

00:15:43,000 --> 00:15:47,740
again to the clients we connect it to

00:15:45,580 --> 00:15:50,620
the wireless interface and all that

00:15:47,740 --> 00:15:53,200
client does is started the start

00:15:50,620 --> 00:15:56,290
actually the game client and it says

00:15:53,200 --> 00:16:00,100
connect so we modify the game client so

00:15:56,290 --> 00:16:04,060
that it takes our commands so we say

00:16:00,100 --> 00:16:05,710
connected over Ouroboros to the IO q3

00:16:04,060 --> 00:16:07,780
server and it does it and you're in the

00:16:05,710 --> 00:16:10,990
game so again it's only three commands

00:16:07,780 --> 00:16:12,670
that you have to give you register the

00:16:10,990 --> 00:16:14,380
name you bind the process to the name

00:16:12,670 --> 00:16:21,030
and from the other side you allocate a

00:16:14,380 --> 00:16:21,030
name pretty simple so for a liability

00:16:22,020 --> 00:16:27,370
Ethernet is not very reliable so you can

00:16:26,020 --> 00:16:29,470
have packet loss you can have jitter

00:16:27,370 --> 00:16:32,320
which is normally implemented by TCP IP

00:16:29,470 --> 00:16:35,440
and TCP IP is usually in a different

00:16:32,320 --> 00:16:38,220
layer in Ouroboros this is not the case

00:16:35,440 --> 00:16:41,050
so it's it's in the library and every

00:16:38,220 --> 00:16:44,590
every program that links against our

00:16:41,050 --> 00:16:46,330
library performs its own connection

00:16:44,590 --> 00:16:48,130
management it performs its own

00:16:46,330 --> 00:16:50,920
encryption and it's so check something

00:16:48,130 --> 00:16:52,510
so when you have the process

00:16:50,920 --> 00:16:55,150
communicating to ensure and something

00:16:52,510 --> 00:16:57,280
happens to one of these processes you

00:16:55,150 --> 00:16:59,950
can recover from a lot of crashes so

00:16:57,280 --> 00:17:03,610
only if your actual program crashes you

00:16:59,950 --> 00:17:05,380
have you lose your your connection it

00:17:03,610 --> 00:17:07,900
does fragmentation encryption attacks

00:17:05,380 --> 00:17:10,689
check something so we talked about

00:17:07,900 --> 00:17:13,000
robots over layer X so we implemented it

00:17:10,689 --> 00:17:15,759
over Ethernet but we actually have a

00:17:13,000 --> 00:17:18,819
proof of concept that runs it directly

00:17:15,759 --> 00:17:20,740
over an FPGA so it's not over layer two

00:17:18,819 --> 00:17:22,839
it's actually over ethernet layer 1 the

00:17:20,740 --> 00:17:25,480
physical so we're not using MAC

00:17:22,839 --> 00:17:27,100
addresses or the the Mac interface it's

00:17:25,480 --> 00:17:31,809
a point-to-point connection over the net

00:17:27,100 --> 00:17:34,600
FPGA implementation we have it over

00:17:31,809 --> 00:17:38,259
layer 2 so that's the ethernet that I

00:17:34,600 --> 00:17:40,559
talked about and this works over on OS X

00:17:38,259 --> 00:17:43,960
it works over the Berkeley packet filter

00:17:40,559 --> 00:17:45,639
on FreeBSD it runs over the Berkeley

00:17:43,960 --> 00:17:47,830
packet filter or net map if you have

00:17:45,639 --> 00:17:49,240
that installed and on Linux it uses raw

00:17:47,830 --> 00:17:52,750
sockets so the only thing that really

00:17:49,240 --> 00:17:55,299
does is it takes your takes your packets

00:17:52,750 --> 00:17:57,039
and flushes it out of the of the the

00:17:55,299 --> 00:17:59,440
network towards correct destination the

00:17:57,039 --> 00:18:02,409
actual configuration is happened already

00:17:59,440 --> 00:18:06,070
happened before and for layer 3 for we

00:18:02,409 --> 00:18:07,570
implemented it directly over UDP so for

00:18:06,070 --> 00:18:10,659
all the functions are the layer has to

00:18:07,570 --> 00:18:12,279
provide this flow allocation routing

00:18:10,659 --> 00:18:14,440
forwarding and directory are implemented

00:18:12,279 --> 00:18:16,899
in different ways so for the the raptor

00:18:14,440 --> 00:18:19,299
net fpga it's all done by us because

00:18:16,899 --> 00:18:21,370
it's it's the over layer one for the

00:18:19,299 --> 00:18:24,070
internet LLC it depends on how your

00:18:21,370 --> 00:18:25,629
ethernet is configured but it uses

00:18:24,070 --> 00:18:27,460
ethernet for the directory it uses

00:18:25,629 --> 00:18:30,759
Ouroboros we have it implemented it

00:18:27,460 --> 00:18:33,659
ourselves but we could use our because

00:18:30,759 --> 00:18:37,240
the ARP specification it allows you to

00:18:33,659 --> 00:18:40,899
resolve any layer 3 address to a layer 2

00:18:37,240 --> 00:18:43,029
address but actually if it's not IP most

00:18:40,899 --> 00:18:44,919
switches will just drop it for security

00:18:43,029 --> 00:18:46,480
reasons they will check someone is doing

00:18:44,919 --> 00:18:48,549
something very very weird on this

00:18:46,480 --> 00:18:49,840
network we're not going to allow that so

00:18:48,549 --> 00:18:51,940
that's why we're not using the arc

00:18:49,840 --> 00:18:55,690
because it was dropping our packets and

00:18:51,940 --> 00:18:59,500
then for UDP the routing is done usually

00:18:55,690 --> 00:19:03,039
use Jose OSPF or ISS forwarding IP and

00:18:59,500 --> 00:19:04,990
we use we have implemented a dynamic DNS

00:19:03,039 --> 00:19:08,799
which is implementing our directory

00:19:04,990 --> 00:19:10,120
service so now we have two systems and

00:19:08,799 --> 00:19:15,450
somewhere is going to show you a

00:19:10,120 --> 00:19:15,450
Ouroboros over Ouroboros yeah

00:19:36,670 --> 00:19:53,560
okay can you hear this that better lit

00:19:49,750 --> 00:19:56,590
yeah okay so our Abarth over ara Boris

00:19:53,560 --> 00:19:58,660
because the recursive architecture so

00:19:56,590 --> 00:20:02,950
it's our words over our verse over our

00:19:58,660 --> 00:20:05,050
verse of our Wars over our Wars so in

00:20:02,950 --> 00:20:06,910
the previous example that Dmitri

00:20:05,050 --> 00:20:09,580
explains we are communicating between

00:20:06,910 --> 00:20:11,380
two systems so two applications that are

00:20:09,580 --> 00:20:13,030
communicating just over the Ethernet

00:20:11,380 --> 00:20:16,600
there so allocating flow over this

00:20:13,030 --> 00:20:18,970
Ethernet there of course we don't want

00:20:16,600 --> 00:20:20,710
to stop there because we want to extend

00:20:18,970 --> 00:20:25,150
the scope over which we can communicate

00:20:20,710 --> 00:20:28,930
so we wrote a special application called

00:20:25,150 --> 00:20:30,820
a normal I PC process which also just

00:20:28,930 --> 00:20:33,550
uses the same API as a regular

00:20:30,820 --> 00:20:36,070
application and one of the main

00:20:33,550 --> 00:20:38,620
functions of this IP CP is to forward

00:20:36,070 --> 00:20:41,410
packets that it receives so that we can

00:20:38,620 --> 00:20:45,880
extend the scope to an internet level in

00:20:41,410 --> 00:20:48,220
the end so together these normal IPC

00:20:45,880 --> 00:20:52,870
piece they work together in a normal

00:20:48,220 --> 00:20:57,280
layer provides IPC for applications so

00:20:52,870 --> 00:21:00,100
you can see it's that it's basically the

00:20:57,280 --> 00:21:01,240
same as the applications of just over

00:21:00,100 --> 00:21:03,700
the ethernet layer but now it's over

00:21:01,240 --> 00:21:07,810
normally ersity applications they don't

00:21:03,700 --> 00:21:10,900
care what they are they are using and I

00:21:07,810 --> 00:21:12,280
depicted the path here that's if the

00:21:10,900 --> 00:21:14,170
left application we talked to the right

00:21:12,280 --> 00:21:16,180
application this is the path to the

00:21:14,170 --> 00:21:17,860
network that it would follow so it goes

00:21:16,180 --> 00:21:20,140
through the normal layer which uses the

00:21:17,860 --> 00:21:22,600
services of the ethernet layer to go to

00:21:20,140 --> 00:21:24,640
the next IP CP in normal layer which

00:21:22,600 --> 00:21:27,130
then uses the services of the ethernet

00:21:24,640 --> 00:21:30,730
layer to reach the final IP c-- p there

00:21:27,130 --> 00:21:33,640
until it arrives at the application well

00:21:30,730 --> 00:21:37,090
I've drawn and it's it like this

00:21:33,640 --> 00:21:39,010
but it's important to realize that the

00:21:37,090 --> 00:21:41,350
normal layer is using also the mechanism

00:21:39,010 --> 00:21:43,480
of flows in the in the ethernet layer

00:21:41,350 --> 00:21:46,140
and that no kind of information is

00:21:43,480 --> 00:21:50,650
exchanged between the different layers

00:21:46,140 --> 00:21:52,780
so let's try a bit more difficult

00:21:50,650 --> 00:21:54,730
so we can keep on adding layers to

00:21:52,780 --> 00:21:57,340
extend the scope so in this example we

00:21:54,730 --> 00:21:59,470
have three applications one on system

00:21:57,340 --> 00:22:02,350
one one system tree one on sister four

00:21:59,470 --> 00:22:05,260
and I've added some layers and let's say

00:22:02,350 --> 00:22:07,180
the leftmost application was taught to

00:22:05,260 --> 00:22:09,390
the rightmost application then the path

00:22:07,180 --> 00:22:13,510
strewed network would be the following

00:22:09,390 --> 00:22:16,960
it's also interesting to note that the

00:22:13,510 --> 00:22:19,510
middle application cannot talk to the

00:22:16,960 --> 00:22:22,360
left application it would need another

00:22:19,510 --> 00:22:24,550
IP CP in the topmost normal layer in

00:22:22,360 --> 00:22:26,380
order to be able to communicate it would

00:22:24,550 --> 00:22:28,150
be able to communicate with the

00:22:26,380 --> 00:22:31,540
rightmost application by just using the

00:22:28,150 --> 00:22:36,640
services provided by the second layer so

00:22:31,540 --> 00:22:38,560
the first normal layer in its system so

00:22:36,640 --> 00:22:41,860
within each normal air we have a

00:22:38,560 --> 00:22:44,230
collection of IPC peas that cooperate

00:22:41,860 --> 00:22:45,910
with each other to form the layer and

00:22:44,230 --> 00:22:47,500
they are all equal it's completely

00:22:45,910 --> 00:22:50,620
decentralized the architecture so

00:22:47,500 --> 00:22:55,960
there's no central components which also

00:22:50,620 --> 00:22:58,080
makes it more secure and scalable so the

00:22:55,960 --> 00:23:01,000
main objective of such normal air I

00:22:58,080 --> 00:23:04,690
already explained that this is shown as

00:23:01,000 --> 00:23:06,940
a top-level view of a layer so the idea

00:23:04,690 --> 00:23:09,430
is that the IPC pecan forwards its

00:23:06,940 --> 00:23:11,380
packets to the destination so let's say

00:23:09,430 --> 00:23:16,990
the blue dots represents the endpoints

00:23:11,380 --> 00:23:20,010
of flow and so the idea is that the

00:23:16,990 --> 00:23:24,010
packet gets forwarded to the destination

00:23:20,010 --> 00:23:26,590
so let's think back to how this happens

00:23:24,010 --> 00:23:29,560
in tcp/ip so for TCP IP you would need

00:23:26,590 --> 00:23:32,470
to deploy a lot of services such as the

00:23:29,560 --> 00:23:35,860
HTTP server for distributing addresses

00:23:32,470 --> 00:23:38,770
from central authority DNS it's also not

00:23:35,860 --> 00:23:40,870
completely decentralized you would need

00:23:38,770 --> 00:23:42,430
the different routing protocols and

00:23:40,870 --> 00:23:45,580
they're all different pieces of software

00:23:42,430 --> 00:23:48,220
you need firewall stuff like that so in

00:23:45,580 --> 00:23:51,150
our system this is no longer needed the

00:23:48,220 --> 00:23:53,320
only thing you need is the IP CP that

00:23:51,150 --> 00:23:56,770
collaborates with the other IPC piece in

00:23:53,320 --> 00:24:02,590
the layer to obtain well to provide IPC

00:23:56,770 --> 00:24:03,610
to its applications so then how do we

00:24:02,590 --> 00:24:05,710
construct such

00:24:03,610 --> 00:24:08,260
lair well let's go through it step by

00:24:05,710 --> 00:24:10,870
step so of course the first IP CP that

00:24:08,260 --> 00:24:13,660
she creates it needs to be bootstraps so

00:24:10,870 --> 00:24:15,820
in the example we have two systems that

00:24:13,660 --> 00:24:17,110
are connected to each other via ethernet

00:24:15,820 --> 00:24:21,070
so we have the ethernet layer from

00:24:17,110 --> 00:24:22,800
before again which here we call and on

00:24:21,070 --> 00:24:25,210
top we want to create a normal layer

00:24:22,800 --> 00:24:28,030
which is called and so there I've

00:24:25,210 --> 00:24:34,390
created the first IP CP so how does this

00:24:28,030 --> 00:24:37,240
yeah so when you bootstrap an IP CP we

00:24:34,390 --> 00:24:39,940
use again the handy to IRM that we

00:24:37,240 --> 00:24:42,190
developed so if you type I RM IP CP

00:24:39,940 --> 00:24:44,590
bootstrap it will just outputs the

00:24:42,190 --> 00:24:48,270
different things that you can configure

00:24:44,590 --> 00:24:51,370
since it is the first IP CP in the layer

00:24:48,270 --> 00:24:55,360
we need to configure it as we please so

00:24:51,370 --> 00:24:59,020
for now we well it's not super extensive

00:24:55,360 --> 00:25:01,180
are listed but for instance you can

00:24:59,020 --> 00:25:03,700
select routing policies that you want we

00:25:01,180 --> 00:25:05,560
implemented a link state routing and LU

00:25:03,700 --> 00:25:07,270
pre alternate route which is a bit more

00:25:05,560 --> 00:25:10,000
resilient but for instance the default

00:25:07,270 --> 00:25:14,050
is a link state algorithm and so you can

00:25:10,000 --> 00:25:16,210
configure it as you please so depending

00:25:14,050 --> 00:25:18,070
on the operating on the environment that

00:25:16,210 --> 00:25:19,270
it is operating in and the scope that it

00:25:18,070 --> 00:25:21,700
should have for instance the address

00:25:19,270 --> 00:25:26,100
size if it's a very large network you

00:25:21,700 --> 00:25:30,700
want to pick a much bigger address size

00:25:26,100 --> 00:25:33,610
so now let's actually create one so

00:25:30,700 --> 00:25:37,390
again we start the IPC the IPC resource

00:25:33,610 --> 00:25:39,610
manager demon so the IR MD and then we

00:25:37,390 --> 00:25:43,150
simply execute a command which is

00:25:39,610 --> 00:25:45,310
similar to the one for creating an

00:25:43,150 --> 00:25:48,370
Ethernet there but instead of Ethernet

00:25:45,310 --> 00:25:53,680
of sorry yes first we create again the

00:25:48,370 --> 00:25:55,930
ethernet IP because we want to use the

00:25:53,680 --> 00:25:58,720
internet layer for constructing the

00:25:55,930 --> 00:25:59,920
layer so we just create the Ethernet IP

00:25:58,720 --> 00:26:02,710
CP eth0

00:25:59,920 --> 00:26:05,410
as demonstrated a couple of times by now

00:26:02,710 --> 00:26:09,700
so as we can see it has been created in

00:26:05,410 --> 00:26:12,370
the system then next we instantiate the

00:26:09,700 --> 00:26:15,460
actual normal IPC P and here we just

00:26:12,370 --> 00:26:17,809
selected it with default options

00:26:15,460 --> 00:26:21,679
and as you can see we created into the

00:26:17,809 --> 00:26:24,260
lair and we gave the name and one and we

00:26:21,679 --> 00:26:26,150
also specified all turbines because of

00:26:24,260 --> 00:26:27,740
course we also need to bind the name so

00:26:26,150 --> 00:26:30,740
that it is reachable it needs to be

00:26:27,740 --> 00:26:32,780
bounced and registered just as any other

00:26:30,740 --> 00:26:37,070
application but if you specify all

00:26:32,780 --> 00:26:39,290
turbines it will bind to its unique name

00:26:37,070 --> 00:26:41,510
in this case and one but it also binds

00:26:39,290 --> 00:26:45,640
to the layer name and so that if you

00:26:41,510 --> 00:26:48,800
want to communicate with the layer that

00:26:45,640 --> 00:26:51,760
you can completely communicate with any

00:26:48,800 --> 00:26:55,550
IP CP that is a member of the layer

00:26:51,760 --> 00:26:57,500
so finally we register these two names

00:26:55,550 --> 00:27:03,679
into the ethernet layer so that is

00:26:57,500 --> 00:27:06,620
reachable so unrolling into a layer this

00:27:03,679 --> 00:27:08,720
is a the next step to extend the layer

00:27:06,620 --> 00:27:11,780
so we now have the bootstraps I PCP but

00:27:08,720 --> 00:27:14,300
of course we want to add more IPC piece

00:27:11,780 --> 00:27:16,790
into the layer so what this is is that

00:27:14,300 --> 00:27:19,540
the new IP CP that is not yet configured

00:27:16,790 --> 00:27:23,840
communicates with a member of the layer

00:27:19,540 --> 00:27:26,720
to authenticate with its obtain the

00:27:23,840 --> 00:27:29,450
configuration and obtain an address in

00:27:26,720 --> 00:27:32,030
the layer so in the end we would end up

00:27:29,450 --> 00:27:33,650
with this very simple system of one

00:27:32,030 --> 00:27:38,090
normal layer on top of the ethernet

00:27:33,650 --> 00:27:40,400
layer so continue on with the example on

00:27:38,090 --> 00:27:43,220
the left side we see again system one

00:27:40,400 --> 00:27:45,080
which we just configured so we have the

00:27:43,220 --> 00:27:47,390
ethernet layer right on top the normal I

00:27:45,080 --> 00:27:50,090
PCP and on the right side we just

00:27:47,390 --> 00:27:53,600
created an Ethernet IP CP so that we can

00:27:50,090 --> 00:27:56,600
have communication on top so finally you

00:27:53,600 --> 00:27:59,480
execute IRM IP speed and roll which

00:27:56,600 --> 00:28:01,400
enrolls the new member with the existing

00:27:59,480 --> 00:28:03,650
number and as you can see it's a very

00:28:01,400 --> 00:28:06,559
simple operation so they just exchange

00:28:03,650 --> 00:28:08,480
the configuration of the it obtains an

00:28:06,559 --> 00:28:11,600
address as well as you can see there and

00:28:08,480 --> 00:28:16,429
in the end it is a member a new member

00:28:11,600 --> 00:28:18,230
of the layer then finally you may also

00:28:16,429 --> 00:28:20,600
register these names into the ethernet

00:28:18,230 --> 00:28:24,550
layer so that is available if yet

00:28:20,600 --> 00:28:27,309
another IP CP member would like to join

00:28:24,550 --> 00:28:28,840
so once it is a member the

00:28:27,309 --> 00:28:30,759
next thing that you want to do is set up

00:28:28,840 --> 00:28:33,490
data transfer connections because

00:28:30,759 --> 00:28:36,970
becoming a member it's just that so that

00:28:33,490 --> 00:28:38,889
you know how it is configured but you

00:28:36,970 --> 00:28:41,830
also want to set up some actual

00:28:38,889 --> 00:28:44,350
connections to forward data on so let's

00:28:41,830 --> 00:28:48,070
assume that we have this data transfer

00:28:44,350 --> 00:28:50,519
connectivity graph in the layer then you

00:28:48,070 --> 00:28:53,200
can see that every IP CP has an address

00:28:50,519 --> 00:28:57,249
again we have the endpoints of the flow

00:28:53,200 --> 00:29:00,970
and we want to get from the left eye PCP

00:28:57,249 --> 00:29:03,220
to the top right eye PCP so we just send

00:29:00,970 --> 00:29:06,909
packets in the layer and as you can see

00:29:03,220 --> 00:29:12,340
the this is actually the full header so

00:29:06,909 --> 00:29:13,899
it's a lot shorter than IP and PCP we

00:29:12,340 --> 00:29:16,480
don't send source addresses so it's a

00:29:13,899 --> 00:29:18,220
lot more secure and anonymous the only

00:29:16,480 --> 00:29:19,419
thing that is needed is sending the

00:29:18,220 --> 00:29:23,529
destination address so that you know

00:29:19,419 --> 00:29:25,360
where it is going but you actually

00:29:23,529 --> 00:29:27,700
synchronize all the state on floor

00:29:25,360 --> 00:29:30,610
locations so when you allocate flow we

00:29:27,700 --> 00:29:33,129
exchange information and then you

00:29:30,610 --> 00:29:36,129
generate an endpoint identifier that's

00:29:33,129 --> 00:29:38,200
you also have to send in your packet and

00:29:36,129 --> 00:29:40,659
a time to live value so in case you have

00:29:38,200 --> 00:29:42,700
routing problems that the packet doesn't

00:29:40,659 --> 00:29:45,159
loop forever so it's a very simple

00:29:42,700 --> 00:29:50,340
header that's maybe six bytes I think

00:29:45,159 --> 00:29:50,340
and that's even for a quite big network

00:29:51,419 --> 00:29:56,529
so how do you set up data to transfer

00:29:54,789 --> 00:30:02,080
connections again with a very simple

00:29:56,529 --> 00:30:03,970
iron command so you connect n1 to n2 for

00:30:02,080 --> 00:30:06,970
the data transfer components and when

00:30:03,970 --> 00:30:09,879
you do that as you can see it worked and

00:30:06,970 --> 00:30:11,649
it also because the normal of course

00:30:09,879 --> 00:30:14,440
also has a directory has Dimitri

00:30:11,649 --> 00:30:16,869
explained which is actually the HD in

00:30:14,440 --> 00:30:18,669
our case and when you set up the first

00:30:16,869 --> 00:30:22,299
data transfer connection it also enrolls

00:30:18,669 --> 00:30:25,539
into the directory and then apart from

00:30:22,299 --> 00:30:28,029
the data transfer Network you can also

00:30:25,539 --> 00:30:32,100
set up a separate management's network

00:30:28,029 --> 00:30:35,049
within the layer to send to disseminate

00:30:32,100 --> 00:30:37,570
routing information for instance as we

00:30:35,049 --> 00:30:39,700
use link state routing that you can this

00:30:37,570 --> 00:30:43,210
it's information about the different

00:30:39,700 --> 00:30:45,210
links in a network and it's just yeah as

00:30:43,210 --> 00:30:49,660
you can see it's a tree so you can just

00:30:45,210 --> 00:30:51,730
set the packets down the tree so the

00:30:49,660 --> 00:30:54,640
command is very similar to the data

00:30:51,730 --> 00:30:56,080
transfer connection one so you just

00:30:54,640 --> 00:30:58,720
connect and two two and one so it

00:30:56,080 --> 00:31:00,190
doesn't matter because there are all IP

00:30:58,720 --> 00:31:02,820
CPS are equal so it doesn't matter if

00:31:00,190 --> 00:31:05,550
you do it from n 2 2 & 1 or R 1 2 & 2

00:31:02,820 --> 00:31:08,110
and here we connect the management

00:31:05,550 --> 00:31:10,960
component and as you can see from the

00:31:08,110 --> 00:31:13,260
output that's both added each other as a

00:31:10,960 --> 00:31:17,020
new neighbor in the management Network

00:31:13,260 --> 00:31:20,290
so to summarize here of for our verse

00:31:17,020 --> 00:31:22,300
over arrow Boris so these are the

00:31:20,290 --> 00:31:25,660
different functions of the layer for

00:31:22,300 --> 00:31:27,490
raptor the internet and UDP rare Dmitry

00:31:25,660 --> 00:31:30,130
explained that one and so in the case of

00:31:27,490 --> 00:31:32,320
a normal layer of course we implement

00:31:30,130 --> 00:31:34,780
this all ourselves but the global

00:31:32,320 --> 00:31:36,820
location is completely our boards the

00:31:34,780 --> 00:31:39,250
routing is based on is is because you

00:31:36,820 --> 00:31:40,660
also don't send addresses in ISS you

00:31:39,250 --> 00:31:43,330
just run it directly over your sub

00:31:40,660 --> 00:31:46,360
Network technology the forwarding is

00:31:43,330 --> 00:31:48,780
also a reverse and the directory is the

00:31:46,360 --> 00:31:52,120
HT will condemn you have to be

00:31:48,780 --> 00:31:55,360
completely correct there and it does

00:31:52,120 --> 00:31:57,610
have an enrollment face and the legacy

00:31:55,360 --> 00:31:59,680
technologies well almost none of them

00:31:57,610 --> 00:32:01,740
have an enrollment face Wi-Fi has for

00:31:59,680 --> 00:32:04,390
instance that you have to enter your

00:32:01,740 --> 00:32:06,190
your password to connect to the Wi-Fi

00:32:04,390 --> 00:32:12,220
network that's for of enrollment as well

00:32:06,190 --> 00:32:15,480
as joining network so the reliability as

00:32:12,220 --> 00:32:19,000
we said it's between applications so in

00:32:15,480 --> 00:32:21,310
since it's recursive architecture the

00:32:19,000 --> 00:32:22,720
IPC piece they're all all just

00:32:21,310 --> 00:32:24,760
applications as well so it's one layer

00:32:22,720 --> 00:32:26,560
that is repeated but the function of

00:32:24,760 --> 00:32:30,190
reliability and flow control

00:32:26,560 --> 00:32:32,110
checksumming it can also be repeated it

00:32:30,190 --> 00:32:33,430
doesn't have to be repeated but you can

00:32:32,110 --> 00:32:35,260
repeat it where it makes sense for

00:32:33,430 --> 00:32:36,940
instance over Ethernet you probably

00:32:35,260 --> 00:32:39,040
don't want to do retransmission between

00:32:36,940 --> 00:32:41,080
those two IPC piece but if you have if

00:32:39,040 --> 00:32:43,390
you have a Wi-Fi layer you can get a lot

00:32:41,080 --> 00:32:46,870
of packet drops so it's probably

00:32:43,390 --> 00:32:49,880
interesting to do retransmission control

00:32:46,870 --> 00:32:51,230
there and then in the top layer for the

00:32:49,880 --> 00:32:52,400
well the application is a client in the

00:32:51,230 --> 00:32:54,080
server if they want a reliable

00:32:52,400 --> 00:32:58,640
connection they should also do

00:32:54,080 --> 00:33:00,890
retransmission so we presented to the

00:32:58,640 --> 00:33:04,070
synchronous API but of course if you

00:33:00,890 --> 00:33:05,990
have a lot of flows that you create you

00:33:04,070 --> 00:33:08,120
don't want to start at read for every

00:33:05,990 --> 00:33:11,780
flow that you create so we also provide

00:33:08,120 --> 00:33:14,530
an asynchronous API which is base

00:33:11,780 --> 00:33:18,110
actually on KQ and Linux EF eople

00:33:14,530 --> 00:33:20,630
FreeBSD has KQ there are more performant

00:33:18,110 --> 00:33:22,700
versions of the Select Cisco but when

00:33:20,630 --> 00:33:27,080
you read the research papers the KQ one

00:33:22,700 --> 00:33:29,210
seems to do a bit more well seems to be

00:33:27,080 --> 00:33:31,070
a better implementation so it's very

00:33:29,210 --> 00:33:33,950
simple so you just if you create a new

00:33:31,070 --> 00:33:36,289
flow then you just add the flow

00:33:33,950 --> 00:33:39,049
descriptor to the set and then you can

00:33:36,289 --> 00:33:41,419
just wait until one of the flow

00:33:39,049 --> 00:33:43,820
descriptors becomes ready and then you

00:33:41,419 --> 00:34:04,490
can read the packets that are stored in

00:33:43,820 --> 00:34:08,480
the FQ so I'll briefly summarize what we

00:34:04,490 --> 00:34:10,490
explained so we explained a little bit

00:34:08,480 --> 00:34:13,669
about Roberto so it's our research

00:34:10,490 --> 00:34:17,359
prototype based on this recursive

00:34:13,669 --> 00:34:19,940
internet model it provides you a very

00:34:17,359 --> 00:34:22,550
same single abstraction for ways to

00:34:19,940 --> 00:34:24,530
communicate between two programs that

00:34:22,550 --> 00:34:27,260
are running on two machines it

00:34:24,530 --> 00:34:29,020
completely extracts the the network so

00:34:27,260 --> 00:34:31,340
this simplifies how you write

00:34:29,020 --> 00:34:33,440
distributed applications you saw some

00:34:31,340 --> 00:34:36,889
source code of course it goes we don't

00:34:33,440 --> 00:34:38,929
have a lot of time here so maybe a bit a

00:34:36,889 --> 00:34:40,639
lot of information to to process in a

00:34:38,929 --> 00:34:43,060
short time but the idea is that we have

00:34:40,639 --> 00:34:46,460
a very simple API and we have a very

00:34:43,060 --> 00:34:50,270
simple command line so in all the

00:34:46,460 --> 00:34:55,820
configurations it's it's almost a zero

00:34:50,270 --> 00:34:59,000
configuration networking figuring

00:34:55,820 --> 00:35:01,400
servers it's a very secure and

00:34:59,000 --> 00:35:04,549
trustworthy network design and it hides

00:35:01,400 --> 00:35:07,549
all the complexity so if you look at

00:35:04,549 --> 00:35:09,440
a very abstract way we're looking at it

00:35:07,549 --> 00:35:11,150
you have a client and a server we always

00:35:09,440 --> 00:35:12,799
sent encrypted data between a client and

00:35:11,150 --> 00:35:14,869
a server of course if you don't want to

00:35:12,799 --> 00:35:18,019
you don't have to encrypt it but you can

00:35:14,869 --> 00:35:21,190
always do that everything that you send

00:35:18,019 --> 00:35:24,380
to the network like destinations are

00:35:21,190 --> 00:35:26,900
registered as hashes so this is a

00:35:24,380 --> 00:35:29,029
function like DNS but there is no there

00:35:26,900 --> 00:35:30,890
is no encrypted way for DNS so

00:35:29,029 --> 00:35:32,660
everything that you look up on the

00:35:30,890 --> 00:35:35,059
internet it goes to a DNS server and

00:35:32,660 --> 00:35:37,430
it's always unencrypted so if your your

00:35:35,059 --> 00:35:39,680
network operator if you're surfing for

00:35:37,430 --> 00:35:42,680
Google that's encrypted but then you go

00:35:39,680 --> 00:35:46,640
to the website the DNS lookup for the IP

00:35:42,680 --> 00:35:48,979
address is always unencrypted so the

00:35:46,640 --> 00:35:51,380
normal layer it doesn't contain source

00:35:48,979 --> 00:35:53,869
addresses so for somebody to try to

00:35:51,380 --> 00:35:55,729
analyze traffic and figure out where

00:35:53,869 --> 00:35:57,710
traffic is going it's a lot harder than

00:35:55,729 --> 00:36:00,680
current it works it's completely

00:35:57,710 --> 00:36:07,999
decentralized there is no single point

00:36:00,680 --> 00:36:10,999
in the network that is yeah central

00:36:07,999 --> 00:36:12,529
entity so the the way that we do DNS is

00:36:10,999 --> 00:36:14,359
that's it's a DHT that's running

00:36:12,529 --> 00:36:16,099
everywhere in the network and the layers

00:36:14,359 --> 00:36:18,289
are completely self-contained so there

00:36:16,099 --> 00:36:20,950
is no information sharing between

00:36:18,289 --> 00:36:23,989
different layers in the in the network

00:36:20,950 --> 00:36:27,829
so before you start recompiling your

00:36:23,989 --> 00:36:29,359
kernel without a tcp/ip stack there's a

00:36:27,829 --> 00:36:32,869
lot of things to be done so this is a

00:36:29,359 --> 00:36:34,309
research prototype we still have a lot

00:36:32,869 --> 00:36:35,690
to do like distributed to address

00:36:34,309 --> 00:36:39,559
assignment currently we just give a

00:36:35,690 --> 00:36:41,509
random address in 64 bytes we need to

00:36:39,559 --> 00:36:44,210
look at efficient layer designs how to

00:36:41,509 --> 00:36:46,029
do an efficient congestion control the

00:36:44,210 --> 00:36:49,789
implementation we need some bug fixing

00:36:46,029 --> 00:36:53,029
optimization we haven't implemented the

00:36:49,789 --> 00:36:56,390
encryption so we plan to do that using

00:36:53,029 --> 00:36:59,299
the new crypto library or live or open

00:36:56,390 --> 00:37:01,430
SSL and we have to deploy it wider so

00:36:59,299 --> 00:37:03,950
we're looking for other people to start

00:37:01,430 --> 00:37:06,049
trying our stuff and that we can build

00:37:03,950 --> 00:37:08,269
it at larger and larger scale so because

00:37:06,049 --> 00:37:10,519
even the test beds that we are using we

00:37:08,269 --> 00:37:12,440
can go up to hundreds of nodes but we

00:37:10,519 --> 00:37:14,809
can't go to thousands or millions which

00:37:12,440 --> 00:37:18,340
is eventually where we would like to go

00:37:14,809 --> 00:37:20,410
also the API is of course

00:37:18,340 --> 00:37:23,050
it's proprietary so you don't your

00:37:20,410 --> 00:37:25,810
software isn't written for the API so

00:37:23,050 --> 00:37:28,480
it's a very simple one so what we would

00:37:25,810 --> 00:37:30,550
like to do is have a socket simulator so

00:37:28,480 --> 00:37:34,000
that we preloads our library against

00:37:30,550 --> 00:37:36,070
before you load the blue sea library and

00:37:34,000 --> 00:37:38,380
then we can trap your socket calls and

00:37:36,070 --> 00:37:41,100
run the software over so if you what of

00:37:38,380 --> 00:37:44,530
course run it over Ouroboros

00:37:41,100 --> 00:37:47,260
so we are on three nodes the channel is

00:37:44,530 --> 00:37:49,540
Ouroboros we have a mailing list and

00:37:47,260 --> 00:37:51,310
there's the website so please have a

00:37:49,540 --> 00:37:53,290
look at it if you think it's interesting

00:37:51,310 --> 00:37:55,570
what we've been doing in these last two

00:37:53,290 --> 00:37:57,730
years so we have to acknowledge that

00:37:55,570 --> 00:37:59,650
it's partly funded by the Flemish

00:37:57,730 --> 00:38:01,330
government so if you're not from

00:37:59,650 --> 00:38:03,820
Flanders this development has not been

00:38:01,330 --> 00:38:05,650
wasting your tax money we would like our

00:38:03,820 --> 00:38:08,020
colleagues that have already seen the

00:38:05,650 --> 00:38:10,750
presentation and gave us feedback

00:38:08,020 --> 00:38:13,600
because the previous one was probably

00:38:10,750 --> 00:38:16,030
incomprehensible even more than this one

00:38:13,600 --> 00:38:18,070
so we would like to thank our European

00:38:16,030 --> 00:38:19,630
and US us project partners that were

00:38:18,070 --> 00:38:21,340
involved in the project that we were in

00:38:19,630 --> 00:38:24,520
in the research so for all these

00:38:21,340 --> 00:38:26,440
discussions our current and past master

00:38:24,520 --> 00:38:29,410
TC students who have been involved in

00:38:26,440 --> 00:38:32,380
testing the software and deploying it

00:38:29,410 --> 00:38:33,970
and extending it and our supervisors for

00:38:32,380 --> 00:38:37,090
the opportunity that we have to work on

00:38:33,970 --> 00:38:43,230
this ambitious project so that's all

00:38:37,090 --> 00:38:47,050
thank you thank you

00:38:43,230 --> 00:38:49,570
now we have five minutes a bit more we

00:38:47,050 --> 00:38:56,940
have eight minutes left for questions do

00:38:49,570 --> 00:38:56,940
I see any just

00:38:59,310 --> 00:39:06,250
you say that the Strasse address isn't

00:39:02,920 --> 00:39:11,680
included in the packets but then how do

00:39:06,250 --> 00:39:13,960
you do to a communication for those who

00:39:11,680 --> 00:39:17,890
are leaving please try to so widely

00:39:13,960 --> 00:39:19,869
thank you so if I got your question

00:39:17,890 --> 00:39:22,359
correctly is that we don't sent the

00:39:19,869 --> 00:39:25,660
source address in the packet yeah so

00:39:22,359 --> 00:39:28,030
when you allocate the flow that's the

00:39:25,660 --> 00:39:30,670
first thing you do so you retrieve the

00:39:28,030 --> 00:39:32,470
name that you want to allocate flew to

00:39:30,670 --> 00:39:34,780
from the directory you get the address

00:39:32,470 --> 00:39:36,760
and you form a flow allocation request

00:39:34,780 --> 00:39:40,030
so this is a packet that does contain a

00:39:36,760 --> 00:39:42,339
source address so that's it is sent to

00:39:40,030 --> 00:39:46,420
the endpoints which then communicates

00:39:42,339 --> 00:39:48,819
with the RMD and can see if the flow can

00:39:46,420 --> 00:39:50,589
get allocated or not and then a flow

00:39:48,819 --> 00:39:52,510
allocation response is sent back to the

00:39:50,589 --> 00:39:56,200
other side and just with these two

00:39:52,510 --> 00:39:58,060
messages they know each other's address

00:39:56,200 --> 00:40:04,660
and the endpoint identifier that it

00:39:58,060 --> 00:40:07,060
generated so to relate to something that

00:40:04,660 --> 00:40:09,520
you probably know if you know TCP you

00:40:07,060 --> 00:40:12,579
start with a three-way handshake when

00:40:09,520 --> 00:40:14,589
you send a syn ox ox an ACK but actually

00:40:12,579 --> 00:40:16,240
you could do the same in TCP where you

00:40:14,589 --> 00:40:18,460
would add the three-way handshake you

00:40:16,240 --> 00:40:19,960
already negotiate the ports and the

00:40:18,460 --> 00:40:21,160
source address you store it at the

00:40:19,960 --> 00:40:23,109
endpoints and then you never have to

00:40:21,160 --> 00:40:25,599
send it again so it's a similar

00:40:23,109 --> 00:40:30,310
operation but it doesn't happen in the

00:40:25,599 --> 00:40:32,160
current networks thanks for the

00:40:30,310 --> 00:40:34,810
presentation I'm wondering how the

00:40:32,160 --> 00:40:37,540
assignment of names on a global scale

00:40:34,810 --> 00:40:44,410
would work like for example how would we

00:40:37,540 --> 00:40:46,900
register fosston dot org so the question

00:40:44,410 --> 00:40:49,510
was on registering names on a global

00:40:46,900 --> 00:40:52,150
scale so if you want to try to register

00:40:49,510 --> 00:40:54,880
for them well so this is something that

00:40:52,150 --> 00:40:57,579
we don't have yet but you would actually

00:40:54,880 --> 00:40:59,500
need a naming service that map's the

00:40:57,579 --> 00:41:02,079
name to the layers that it is available

00:40:59,500 --> 00:41:05,339
in so indeed a global namespace for

00:41:02,079 --> 00:41:08,020
names would be required

00:41:05,339 --> 00:41:10,119
probably well probably in the end to you

00:41:08,020 --> 00:41:11,110
you might have sort of a public internet

00:41:10,119 --> 00:41:13,960
layer

00:41:11,110 --> 00:41:16,750
- which yeah just as we have right now

00:41:13,960 --> 00:41:30,340
that you can just then allocated flow to

00:41:16,750 --> 00:41:33,700
the name Falls them given your answer to

00:41:30,340 --> 00:41:35,290
the first question what made you choose

00:41:33,700 --> 00:41:39,220
Packer flow routing versus packet

00:41:35,290 --> 00:41:40,810
routing for streams sorry given your

00:41:39,220 --> 00:41:42,220
answer to the first question it seems

00:41:40,810 --> 00:41:44,670
that you chose flow routing instead of

00:41:42,220 --> 00:41:47,200
packet reading like you establish a flow

00:41:44,670 --> 00:41:50,800
know the definition of flow is different

00:41:47,200 --> 00:41:54,010
than in for instance MPLS so to repeat

00:41:50,800 --> 00:41:56,080
the question the question was why we

00:41:54,010 --> 00:42:00,610
selected flow routing instead of packet

00:41:56,080 --> 00:42:01,960
routing so but this is yeah we are so

00:42:00,610 --> 00:42:04,630
the the answer is that we are doing

00:42:01,960 --> 00:42:06,730
packet routing so the flow is just the

00:42:04,630 --> 00:42:09,310
synchronization of states in the layer

00:42:06,730 --> 00:42:11,140
so that you have the endpoints but from

00:42:09,310 --> 00:42:13,480
that point on you're basically doing

00:42:11,140 --> 00:42:18,430
packages which is not working within

00:42:13,480 --> 00:42:25,570
each layer okay any other questions any

00:42:18,430 --> 00:42:30,930
further ones okay so thank you very much

00:42:25,570 --> 00:42:30,930
for the talk Louis for our speakers

00:42:33,750 --> 00:42:40,020
for those of you who are leaving please

00:42:36,750 --> 00:42:42,180
look if there is any trash bottles or

00:42:40,020 --> 00:42:44,490
anything that you can take with you and

00:42:42,180 --> 00:42:47,310
transport outside that makes everything

00:42:44,490 --> 00:42:50,810
a bit happier and easier for the rest of

00:42:47,310 --> 00:42:50,810

YouTube URL: https://www.youtube.com/watch?v=6fH23l45984


