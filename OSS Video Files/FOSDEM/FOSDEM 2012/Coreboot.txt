Title: Coreboot
Publication date: 2013-02-05
Playlist: FOSDEM 2012
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:01,669 --> 00:00:10,469
hello my name is Kal Daniel - er I'm one

00:00:06,960 --> 00:00:13,799
of the developers of the coreboot

00:00:10,469 --> 00:00:16,980
project and I'm very happy to be here

00:00:13,799 --> 00:00:21,510
today at FOSDEM and to have the chance

00:00:16,980 --> 00:00:23,160
to present something about coreboot

00:00:21,510 --> 00:00:29,279
especially one of the most asked

00:00:23,160 --> 00:00:33,739
questions today now we had a slight

00:00:29,279 --> 00:00:38,160
glitch in that yesterday evening while

00:00:33,739 --> 00:00:39,719
trying to film a demo or to document how

00:00:38,160 --> 00:00:41,370
the hardware works just in case

00:00:39,719 --> 00:00:43,739
something goes wrong

00:00:41,370 --> 00:00:46,829
the demo Hardware died I still have the

00:00:43,739 --> 00:00:50,789
video and we will try to show something

00:00:46,829 --> 00:00:52,530
but you might not see that much if I

00:00:50,789 --> 00:00:56,100
just hold up that laptop it's a bit

00:00:52,530 --> 00:01:02,219
small for people to see em at the higher

00:00:56,100 --> 00:01:05,939
rows here so yeah let me just start what

00:01:02,219 --> 00:01:13,320
is called boot crew boot is an x86 bias

00:01:05,939 --> 00:01:18,390
if I replacement not a bias or efi let

00:01:13,320 --> 00:01:21,570
me just elaborate a bit on that some I

00:01:18,390 --> 00:01:25,290
think 11 years ago coca-cola project was

00:01:21,570 --> 00:01:29,729
founded and back then it was called

00:01:25,290 --> 00:01:32,700
Linux bias because the original idea was

00:01:29,729 --> 00:01:35,820
well nothing besides bias existed back

00:01:32,700 --> 00:01:37,950
then and the idea was hey just stuff

00:01:35,820 --> 00:01:41,549
Linux in the ROM and let it do all the

00:01:37,950 --> 00:01:44,670
stuff a bias would you do however that

00:01:41,549 --> 00:01:47,490
name has come the name linspace has come

00:01:44,670 --> 00:01:49,890
to haunt us in a way which was

00:01:47,490 --> 00:01:52,590
unexpected people said well I don't want

00:01:49,890 --> 00:01:55,950
to bias a one TFI and I don't want Linux

00:01:52,590 --> 00:02:00,600
I want Windows and given that coreboot

00:01:55,950 --> 00:02:02,880
has nothing to do with a bias and it has

00:02:00,600 --> 00:02:04,860
nothing to do with Linux we decided to

00:02:02,880 --> 00:02:08,629
name the project to actually reflect

00:02:04,860 --> 00:02:11,790
what it does Courbet it's the essential

00:02:08,629 --> 00:02:13,070
stripped-down core of what you need to

00:02:11,790 --> 00:02:17,550
boot a machine

00:02:13,070 --> 00:02:20,760
so our principles are fast simple secure

00:02:17,550 --> 00:02:26,580
and free now that may sort of remind you

00:02:20,760 --> 00:02:29,550
of our projects that's an accident the

00:02:26,580 --> 00:02:32,250
idea between behind fast simple at

00:02:29,550 --> 00:02:37,620
secure and free is once you provide a

00:02:32,250 --> 00:02:42,500
solution which we can maintain easily

00:02:37,620 --> 00:02:45,180
which you have benefits of and which is

00:02:42,500 --> 00:02:47,010
the optimal solution for pretty much

00:02:45,180 --> 00:02:50,810
everything you could throw at it at

00:02:47,010 --> 00:02:53,730
least in the x86 space so the idea was

00:02:50,810 --> 00:02:55,470
just perform minimal Hardware in it and

00:02:53,730 --> 00:02:59,640
then pass control to the operating

00:02:55,470 --> 00:03:05,730
system now maybe just to find out how

00:02:59,640 --> 00:03:08,690
much people in this room know about x86

00:03:05,730 --> 00:03:11,580
computer initialization who does know

00:03:08,690 --> 00:03:15,780
exactly what a biased ask can you just

00:03:11,580 --> 00:03:20,570
please raise your hands okay that's

00:03:15,780 --> 00:03:26,310
about half the audience that's good and

00:03:20,570 --> 00:03:29,640
so let me just start by saying what a

00:03:26,310 --> 00:03:32,250
bias is bias is essentially the code

00:03:29,640 --> 00:03:34,380
which gets run before any operating

00:03:32,250 --> 00:03:38,370
system is running so you switch off your

00:03:34,380 --> 00:03:41,550
computer switch on your computer and the

00:03:38,370 --> 00:03:45,990
first thing the processor does when it

00:03:41,550 --> 00:03:47,610
gets power is it fetches the first few

00:03:45,990 --> 00:03:49,800
instructions it fetches those

00:03:47,610 --> 00:03:51,360
instructions from a ROM chip well

00:03:49,800 --> 00:03:54,990
traditionally it was a wrong chip

00:03:51,360 --> 00:04:00,590
nowadays it's a flash chip and execute

00:03:54,990 --> 00:04:06,360
loads those instructions in that stage

00:04:00,590 --> 00:04:10,080
this an x86 computer has no RAM it has

00:04:06,360 --> 00:04:13,410
no PCI output whatsoever has no access

00:04:10,080 --> 00:04:17,870
to floppy to disk to whatever is just

00:04:13,410 --> 00:04:21,359
the processor and the wrong nothing else

00:04:17,870 --> 00:04:23,250
so the idea is to switch on the stuff

00:04:21,359 --> 00:04:26,030
you want you actually want to use maybe

00:04:23,250 --> 00:04:29,520
your graphics card your PCI bus

00:04:26,030 --> 00:04:31,350
maybe you want to use your RAM well you

00:04:29,520 --> 00:04:33,420
built it in so you probably are

00:04:31,350 --> 00:04:35,160
interested in using it and maybe you

00:04:33,420 --> 00:04:38,700
want it you use your hard disk stuff

00:04:35,160 --> 00:04:40,650
like that so the bias or coreboot or

00:04:38,700 --> 00:04:45,090
whatever initialization code you're

00:04:40,650 --> 00:04:47,220
using just initializes those devices now

00:04:45,090 --> 00:04:47,970
a bias not only initializes those

00:04:47,220 --> 00:04:51,630
devices

00:04:47,970 --> 00:04:55,410
it also has drivers for disk for a

00:04:51,630 --> 00:04:58,950
floppy for graphics card etc however

00:04:55,410 --> 00:05:03,840
that code is assembler which is not bad

00:04:58,950 --> 00:05:06,870
but it not easy to maintain and the

00:05:03,840 --> 00:05:11,370
other problem is its 16-bit assembler on

00:05:06,870 --> 00:05:13,950
a 64-bit machine well you can't really

00:05:11,370 --> 00:05:17,550
blame the BIOS vendors it's an industry

00:05:13,950 --> 00:05:21,780
which grew over time and it's tried and

00:05:17,550 --> 00:05:25,140
tested code back from 1982 or something

00:05:21,780 --> 00:05:28,760
like that so they know it works and if

00:05:25,140 --> 00:05:33,120
you switch on an x86 computer it really

00:05:28,760 --> 00:05:36,000
steps up as a 16-bit machine so each

00:05:33,120 --> 00:05:39,300
64-bit machine starts up as a 16-bit

00:05:36,000 --> 00:05:43,280
machine with one megabyte of segmented

00:05:39,300 --> 00:05:47,220
address space and other fun stuff and

00:05:43,280 --> 00:05:52,500
yeah the h20 gate if some people know

00:05:47,220 --> 00:05:54,330
what that is but I'll skip ad' so the

00:05:52,500 --> 00:05:57,090
heart rate simply doesn't work and the

00:05:54,330 --> 00:05:59,250
first idea is you want to turn on the

00:05:57,090 --> 00:06:01,800
RAM then you want to initialize the PCI

00:05:59,250 --> 00:06:06,060
bus you want to initialize graphics card

00:06:01,800 --> 00:06:08,580
storage controller wanted to issue no

00:06:06,060 --> 00:06:10,680
initialize the stuff which is attached

00:06:08,580 --> 00:06:15,120
to the storage controller for example a

00:06:10,680 --> 00:06:18,990
hard disk so the first step to do

00:06:15,120 --> 00:06:23,580
anything useful is to enable ram but Jen

00:06:18,990 --> 00:06:25,590
Abram you have to train the RAM if you

00:06:23,580 --> 00:06:27,900
don't have any room you can't run C code

00:06:25,590 --> 00:06:31,250
because you don't have any stack you

00:06:27,900 --> 00:06:34,650
can't do a malloc you can't do anything

00:06:31,250 --> 00:06:36,720
so both vendors have traditionally just

00:06:34,650 --> 00:06:39,050
said well we'll use assembler will use

00:06:36,720 --> 00:06:41,990
no call just jump jump

00:06:39,050 --> 00:06:45,890
unroll all loops the code is bloated

00:06:41,990 --> 00:06:51,260
it's low but it works Cobra does it a

00:06:45,890 --> 00:06:54,740
bit different and that's now just let me

00:06:51,260 --> 00:06:56,480
tell what coreboot does Kovich so when a

00:06:54,740 --> 00:07:00,590
machine is switched on it executes the

00:06:56,480 --> 00:07:05,600
first instructions and the first thing

00:07:00,590 --> 00:07:08,720
her Gooch does is enter protected mode

00:07:05,600 --> 00:07:12,320
to have 32-bit address space and to

00:07:08,720 --> 00:07:15,380
actually be able to run even on a 64-bit

00:07:12,320 --> 00:07:19,220
machine we only enter 32-bit mode this

00:07:15,380 --> 00:07:22,640
has reasons which I'll explain later I'm

00:07:19,220 --> 00:07:25,700
on a low speed so that is go to

00:07:22,640 --> 00:07:27,680
protected mode and then next step is

00:07:25,700 --> 00:07:30,470
switch on ram however to switch on them

00:07:27,680 --> 00:07:34,400
we have to execute some Ram training

00:07:30,470 --> 00:07:36,760
code on x86 the RAM controller is pretty

00:07:34,400 --> 00:07:40,280
dumped so you have to tell it everything

00:07:36,760 --> 00:07:43,040
you have to take measurements take a

00:07:40,280 --> 00:07:47,720
look have to analyze analyze eye

00:07:43,040 --> 00:07:52,070
diagrams and stuff like that so what we

00:07:47,720 --> 00:07:58,730
do is we perform an old trick your CPU

00:07:52,070 --> 00:08:00,380
has cache not that much of it maybe 512

00:07:58,730 --> 00:08:02,870
kilobytes or something like that

00:08:00,380 --> 00:08:05,740
however in that cache works if you

00:08:02,870 --> 00:08:08,660
switch it on so we switch on the cache

00:08:05,740 --> 00:08:11,750
lock it and say well please don't write

00:08:08,660 --> 00:08:14,950
through to memory to real RAM and then

00:08:11,750 --> 00:08:18,350
this cache can act as sort of RAM and

00:08:14,950 --> 00:08:21,140
then we suddenly once the cache is

00:08:18,350 --> 00:08:24,140
switched on and acts as Ram that's what

00:08:21,140 --> 00:08:29,170
we call cache as RAM you can execute C

00:08:24,140 --> 00:08:32,770
code and can't really work with stuff so

00:08:29,170 --> 00:08:36,200
first step on switch on the machine

00:08:32,770 --> 00:08:41,050
second step and protective mode third

00:08:36,200 --> 00:08:46,550
step switch on cache as RAM first step

00:08:41,050 --> 00:08:50,060
train the RAM so you get access children

00:08:46,550 --> 00:08:51,529
and once you have RAM you can well you

00:08:50,060 --> 00:08:53,480
have all the RAM and

00:08:51,529 --> 00:08:58,720
sheeni want then you can start

00:08:53,480 --> 00:09:02,839
initializing the PCI bus PCI bus is

00:08:58,720 --> 00:09:06,560
something which is essential to most x86

00:09:02,839 --> 00:09:09,499
pcs I don't think any x86 pcs with a PCI

00:09:06,560 --> 00:09:11,740
bus are manufactured anymore so where

00:09:09,499 --> 00:09:15,829
your graphics card is attached to

00:09:11,740 --> 00:09:20,230
graphics storage sort of pata it a

00:09:15,829 --> 00:09:25,910
control or whatever and once piece is

00:09:20,230 --> 00:09:28,550
initialized you have the ability to

00:09:25,910 --> 00:09:30,680
initialize peripheral devices for

00:09:28,550 --> 00:09:32,540
example storage controller if you have a

00:09:30,680 --> 00:09:38,170
SATA controller it wants to initialize

00:09:32,540 --> 00:09:45,620
the SATA link to the hard disk so well

00:09:38,170 --> 00:09:47,420
simple is one thing but it's less

00:09:45,620 --> 00:09:50,209
complicated than the bias because the

00:09:47,420 --> 00:09:52,509
bias also has to have drivers for

00:09:50,209 --> 00:09:55,490
everything to talk to that stuff so

00:09:52,509 --> 00:09:57,889
minimal hardware in it is really all

00:09:55,490 --> 00:09:59,779
that stuff which I just mentioned and

00:09:57,889 --> 00:10:02,920
then you pass control to your operating

00:09:59,779 --> 00:10:07,490
system or what we call a payload so

00:10:02,920 --> 00:10:11,300
maybe let's just go back to what are the

00:10:07,490 --> 00:10:14,509
principles of core boot fast now people

00:10:11,300 --> 00:10:18,199
ask of often ask why should I use

00:10:14,509 --> 00:10:21,589
coreboot well apparently from that we

00:10:18,199 --> 00:10:25,790
love to get more users there are real

00:10:21,589 --> 00:10:31,180
hard facts y-initial are overusing core

00:10:25,790 --> 00:10:31,180
boot is a good idea think of for example

00:10:31,449 --> 00:10:40,449
what's the best problem people know the

00:10:36,860 --> 00:10:44,750
switch on your computer and the bias

00:10:40,449 --> 00:10:47,329
starts up and takes a few seconds maybe

00:10:44,750 --> 00:10:49,550
a few dozen seconds or if you have a

00:10:47,329 --> 00:10:52,220
server maybe two or three minutes to

00:10:49,550 --> 00:10:54,800
initialize the hardware and to give you

00:10:52,220 --> 00:10:58,389
the assurance and the feeling that it's

00:10:54,800 --> 00:11:02,209
really thorough and checking stuff well

00:10:58,389 --> 00:11:05,150
there really is a slick code in there to

00:11:02,209 --> 00:11:08,840
give you an impression it's

00:11:05,150 --> 00:11:12,560
doing stuff right however you as a user

00:11:08,840 --> 00:11:15,470
do not benefit from slow code well the

00:11:12,560 --> 00:11:18,080
power plants may benefit from along a

00:11:15,470 --> 00:11:22,460
runtime bad you do not benefit so the

00:11:18,080 --> 00:11:25,340
idea is coreboot is fast on a normal x86

00:11:22,460 --> 00:11:29,720
membered coreboot takes about half a

00:11:25,340 --> 00:11:32,690
second from power on to bootloader or if

00:11:29,720 --> 00:11:35,630
you stuff your kernel your Linux kernel

00:11:32,690 --> 00:11:38,450
or Plan nine kernel or whatever into the

00:11:35,630 --> 00:11:43,700
flash chip it's half a second from power

00:11:38,450 --> 00:11:45,680
on to starting the kernel on several

00:11:43,700 --> 00:11:47,810
boards which are a bit slower and that

00:11:45,680 --> 00:11:49,520
may be where you have 64 gigabytes of

00:11:47,810 --> 00:11:54,050
RAM this Ram needs to be initialized

00:11:49,520 --> 00:11:57,220
that so in those cases coreboot may take

00:11:54,050 --> 00:12:00,410
maybe five to eight seconds instead of

00:11:57,220 --> 00:12:07,700
two or three minutes so it's also a lot

00:12:00,410 --> 00:12:11,150
faster now Kolbert that's so fast that

00:12:07,700 --> 00:12:12,890
if you press the power button with your

00:12:11,150 --> 00:12:15,830
right hand and then you want to reach

00:12:12,890 --> 00:12:18,830
the keyboard before coreboot is done

00:12:15,830 --> 00:12:20,930
initializing you fail it's not possible

00:12:18,830 --> 00:12:23,390
unless you have superhuman speed well

00:12:20,930 --> 00:12:29,660
Superman could maybe do it but last I've

00:12:23,390 --> 00:12:32,420
written is not human and then there's

00:12:29,660 --> 00:12:36,140
the aspect of simple core brute is

00:12:32,420 --> 00:12:38,780
waiting for maintainability and for

00:12:36,140 --> 00:12:43,400
usability and with usability I mean

00:12:38,780 --> 00:12:44,990
there is no user interface so if there's

00:12:43,400 --> 00:12:47,120
no user interface you don't have

00:12:44,990 --> 00:12:49,400
visibility issues corporate is just

00:12:47,120 --> 00:12:51,230
there to initialize hardware and then it

00:12:49,400 --> 00:12:53,210
should not mess with you and shouldn't

00:12:51,230 --> 00:12:55,270
ask you questions it shouldn't display a

00:12:53,210 --> 00:12:58,420
preachy logo it should display

00:12:55,270 --> 00:13:01,820
animations please wait while we

00:12:58,420 --> 00:13:04,700
initialize this device if you see that

00:13:01,820 --> 00:13:10,010
the software vendor has failed totally

00:13:04,700 --> 00:13:13,700
failed and you want to not notice at all

00:13:10,010 --> 00:13:15,710
that corporate is running Kogut is also

00:13:13,700 --> 00:13:17,480
simple as I previously mentioned we do

00:13:15,710 --> 00:13:19,160
not have drivers Kirby does not have

00:13:17,480 --> 00:13:20,600
disk drivers because no

00:13:19,160 --> 00:13:22,879
have graphics drivers doesn't have

00:13:20,600 --> 00:13:26,389
anything because what can he do in half

00:13:22,879 --> 00:13:28,160
a second display a message once the

00:13:26,389 --> 00:13:30,379
monitor has synchronized to your VGA

00:13:28,160 --> 00:13:33,920
signal the display Lopez already

00:13:30,379 --> 00:13:36,139
vanished so it's pointless good firm

00:13:33,920 --> 00:13:39,079
disc is something which a payload does

00:13:36,139 --> 00:13:43,639
corporate just focuses on simple innit

00:13:39,079 --> 00:13:45,699
Cobras also secure let's just focus on

00:13:43,639 --> 00:13:50,660
the second point I mentioned here with

00:13:45,699 --> 00:13:53,779
auditable coach governments do not trust

00:13:50,660 --> 00:13:56,980
anybody not their own citizens and

00:13:53,779 --> 00:13:59,930
especially not other governments so if

00:13:56,980 --> 00:14:03,230
government says well we have some highly

00:13:59,930 --> 00:14:08,449
classified data and we want to work with

00:14:03,230 --> 00:14:12,470
that data they sometimes want real

00:14:08,449 --> 00:14:15,279
secure systems now we all know that real

00:14:12,470 --> 00:14:17,899
secure systems are a bit hard to get

00:14:15,279 --> 00:14:20,470
however the next best thing is to have

00:14:17,899 --> 00:14:24,589
somebody audit the coach now if you buy

00:14:20,470 --> 00:14:27,319
a classic computer you can't audit the

00:14:24,589 --> 00:14:30,350
code you can go to the mainboard vendor

00:14:27,319 --> 00:14:32,420
and ask the mainboard vendor please give

00:14:30,350 --> 00:14:34,339
us the source code to your bias the

00:14:32,420 --> 00:14:37,970
mainboard mender will tell you well we

00:14:34,339 --> 00:14:40,699
do not have it the bias manager has that

00:14:37,970 --> 00:14:42,709
couch next we gave the coach a bias

00:14:40,699 --> 00:14:45,860
vendor for example a me award or

00:14:42,709 --> 00:14:48,769
whatever and ask them to give you the

00:14:45,860 --> 00:14:51,139
coach maybe they do maybe not but even

00:14:48,769 --> 00:14:53,630
if they do give you the code they will

00:14:51,139 --> 00:14:55,790
tell you well we do not have all the

00:14:53,630 --> 00:14:58,009
code we just have some of the code and

00:14:55,790 --> 00:15:00,860
some hardware in it was provided by the

00:14:58,009 --> 00:15:04,579
chipset manufacturer or was provided by

00:15:00,860 --> 00:15:06,680
the processor manufacturer we just got a

00:15:04,579 --> 00:15:09,470
binary blob we do not have the couch

00:15:06,680 --> 00:15:12,079
then you go to intial AMD or whoever and

00:15:09,470 --> 00:15:15,110
if you're lucky they will give you some

00:15:12,079 --> 00:15:19,129
code if you're unlucky they will tell

00:15:15,110 --> 00:15:21,139
you to please come back if you want to

00:15:19,129 --> 00:15:23,959
buy billion processors and stuff like

00:15:21,139 --> 00:15:27,790
that and you usually do not have that

00:15:23,959 --> 00:15:31,880
budget even if you're a government so

00:15:27,790 --> 00:15:32,760
the idea is you want this code should be

00:15:31,880 --> 00:15:34,649
audible

00:15:32,760 --> 00:15:38,209
and if everything which runs on your

00:15:34,649 --> 00:15:41,010
processor is free and open code the

00:15:38,209 --> 00:15:43,050
problem if audit is just the problem of

00:15:41,010 --> 00:15:46,019
finding somebody who is able to audit

00:15:43,050 --> 00:15:48,899
the code and finding somebody who is

00:15:46,019 --> 00:15:53,430
willing to do that for a cost which you

00:15:48,899 --> 00:15:57,029
can afford but it's doable and those

00:15:53,430 --> 00:15:59,370
persons are urging the code will scream

00:15:57,029 --> 00:16:02,130
in horror if you throw at them maybe a

00:15:59,370 --> 00:16:04,519
few thousand lines of assembler that's

00:16:02,130 --> 00:16:08,579
the reason why we wrote everything in C

00:16:04,519 --> 00:16:12,029
except well a dozen lines switching on

00:16:08,579 --> 00:16:14,399
the cache and switching on protected

00:16:12,029 --> 00:16:18,839
mode and the rest is C code

00:16:14,399 --> 00:16:21,779
so next aspect of why Corbett is secure

00:16:18,839 --> 00:16:24,380
is no code is running once the u.s.

00:16:21,779 --> 00:16:24,380
takes control

00:16:25,370 --> 00:16:33,630
who does know what SMM or system

00:16:28,949 --> 00:16:37,470
management mode is okay should

00:16:33,630 --> 00:16:42,180
explanations the x86 processors have

00:16:37,470 --> 00:16:46,199
proven cept of privilege levels so you

00:16:42,180 --> 00:16:48,569
have ring free which is basically the

00:16:46,199 --> 00:16:51,240
ring which operating systems used for

00:16:48,569 --> 00:16:53,670
user space ring free means lowest

00:16:51,240 --> 00:16:55,319
privileges that stuff cannot mess the

00:16:53,670 --> 00:17:01,230
code running and ring free cannot mess

00:16:55,319 --> 00:17:04,350
with hardware code in ring zero which is

00:17:01,230 --> 00:17:09,120
the classic lowest the highest privilege

00:17:04,350 --> 00:17:11,459
level that's was lowest number this code

00:17:09,120 --> 00:17:13,140
can do everything with hardware and

00:17:11,459 --> 00:17:17,160
that's what operating system kernel

00:17:13,140 --> 00:17:20,819
seals and then you have the ability to

00:17:17,160 --> 00:17:24,120
in your intro and MD and our processors

00:17:20,819 --> 00:17:27,510
to run system management mode code this

00:17:24,120 --> 00:17:31,950
code can is that a even higher privilege

00:17:27,510 --> 00:17:34,650
level than ring zero so you can use this

00:17:31,950 --> 00:17:37,500
system management mode to trap Hardware

00:17:34,650 --> 00:17:40,470
excesses to emulate for example devices

00:17:37,500 --> 00:17:43,320
which do not exist you can for example

00:17:40,470 --> 00:17:45,490
if you have an old operating system

00:17:43,320 --> 00:17:47,230
which can't handle USB keyboard you

00:17:45,490 --> 00:17:49,510
you're biased please run some code in

00:17:47,230 --> 00:17:51,490
the system management mode and every

00:17:49,510 --> 00:17:52,840
time somebody presses a key on the USB

00:17:51,490 --> 00:17:58,120
keyboard please

00:17:52,840 --> 00:18:01,290
emulate a ps2 port in software and let

00:17:58,120 --> 00:18:06,309
the ELS the operating system think that

00:18:01,290 --> 00:18:08,860
the software which that day's actually

00:18:06,309 --> 00:18:11,800
appears to porch and that there's a ps2

00:18:08,860 --> 00:18:14,440
keyboard attached to it so the system

00:18:11,800 --> 00:18:17,470
management mode a code runs always the

00:18:14,440 --> 00:18:22,360
OS can not stop it the u.s. has no idea

00:18:17,470 --> 00:18:23,470
that this code is running so people have

00:18:22,360 --> 00:18:25,990
demonstrated

00:18:23,470 --> 00:18:29,650
rootkits and system management mode it's

00:18:25,990 --> 00:18:32,770
real fun and there's no way to detect it

00:18:29,650 --> 00:18:35,290
to detect that and with coreboot we

00:18:32,770 --> 00:18:38,020
don't use system management mode because

00:18:35,290 --> 00:18:39,940
well we have nothing to hide and our

00:18:38,020 --> 00:18:43,210
code works well enough that we can do

00:18:39,940 --> 00:18:46,900
without system management mode this also

00:18:43,210 --> 00:18:48,580
has benefits if you care about real-time

00:18:46,900 --> 00:18:50,920
latency because system management mode

00:18:48,580 --> 00:18:53,650
steals the processor from the OS and the

00:18:50,920 --> 00:18:55,990
OS doesn't know about it so you get a

00:18:53,650 --> 00:18:57,790
horrible and unknown latencies

00:18:55,990 --> 00:19:01,030
on the other hand with coreboot that

00:18:57,790 --> 00:19:06,130
doesn't happen so you get classic good

00:19:01,030 --> 00:19:08,320
latencies even on x86 free arrow the

00:19:06,130 --> 00:19:12,309
source code is available for free under

00:19:08,320 --> 00:19:15,880
the gnu general public license version 2

00:19:12,309 --> 00:19:20,679
so you can do with it what you want well

00:19:15,880 --> 00:19:24,580
if you confirm to the license now this

00:19:20,679 --> 00:19:30,809
is a diagram I really like because

00:19:24,580 --> 00:19:38,200
that's what a modern PC looks like um I

00:19:30,809 --> 00:19:39,940
do we have a laser pointer here we do

00:19:38,200 --> 00:19:44,140
not does anybody here in the audience

00:19:39,940 --> 00:19:48,450
have a laser pointer ok great

00:19:44,140 --> 00:19:48,450
I'll just touch it sir

00:19:48,670 --> 00:19:57,740
thank you some of the idea of this

00:19:53,030 --> 00:20:00,830
simple modern PC is a classic PC is just

00:19:57,740 --> 00:20:04,720
as you know it is just one CPU one

00:20:00,830 --> 00:20:06,980
memory controller Ram Northbridge a

00:20:04,720 --> 00:20:09,830
software in the north richest mostly

00:20:06,980 --> 00:20:12,710
where an older machines memory was

00:20:09,830 --> 00:20:14,780
attached and your machines the PCI

00:20:12,710 --> 00:20:19,280
Express is attached Southbridge hands

00:20:14,780 --> 00:20:21,560
PCI a USB IDE and too soft which the

00:20:19,280 --> 00:20:24,110
boot flash chip is attached now modern

00:20:21,560 --> 00:20:26,690
pcs are a bit more complicated if you

00:20:24,110 --> 00:20:28,240
have multiple processors they all have

00:20:26,690 --> 00:20:32,050
their own memory controllers usually

00:20:28,240 --> 00:20:34,840
have their own Ram attached so

00:20:32,050 --> 00:20:39,380
initializing stuff is a bit complicated

00:20:34,840 --> 00:20:40,790
but it works because yeah for example if

00:20:39,380 --> 00:20:44,090
you want to initialize RAM you have to

00:20:40,790 --> 00:20:46,100
read out the RAM configuration data the

00:20:44,090 --> 00:20:48,680
Roman configuration data cannot be read

00:20:46,100 --> 00:20:50,660
directly by the CPU can't be read by the

00:20:48,680 --> 00:20:52,910
north which can't be read directly by

00:20:50,660 --> 00:20:55,940
the Southbridge but only by the smbus

00:20:52,910 --> 00:20:58,070
controlling the Southbridge so that's a

00:20:55,940 --> 00:21:01,370
bit complicated to initialize but it

00:20:58,070 --> 00:21:03,380
works now on a laptop it's a bit more

00:21:01,370 --> 00:21:06,080
complicated you have a super i/o or

00:21:03,380 --> 00:21:08,660
embedded controller chip and that

00:21:06,080 --> 00:21:12,170
embedded controller chip handles thermal

00:21:08,660 --> 00:21:14,120
management it's handled stuff like

00:21:12,170 --> 00:21:19,490
battery charging like even switching on

00:21:14,120 --> 00:21:28,940
your machine so this simple modern PC is

00:21:19,490 --> 00:21:31,970
some fun now um this is some next slide

00:21:28,940 --> 00:21:39,110
is something I wanted to skip the wall

00:21:31,970 --> 00:21:42,020
and so the idea now is to I wish to

00:21:39,110 --> 00:21:45,170
apologize I had a slight hardware issue

00:21:42,020 --> 00:21:48,770
with which caused me to lose some of my

00:21:45,170 --> 00:21:52,520
presentation so I'll continue with audio

00:21:48,770 --> 00:21:54,910
only and the architecture we saw of

00:21:52,520 --> 00:21:58,860
laptop

00:21:54,910 --> 00:22:03,190
if light actually comes up again yes

00:21:58,860 --> 00:22:05,110
laptop architecture is some is that you

00:22:03,190 --> 00:22:07,240
have here an embedded controller instead

00:22:05,110 --> 00:22:09,360
of a super i/o chip other than perfect

00:22:07,240 --> 00:22:12,400
control as I mentioned handles battery

00:22:09,360 --> 00:22:17,710
issues etc and you need to work with

00:22:12,400 --> 00:22:24,310
that as well so I'm about x86 in it I

00:22:17,710 --> 00:22:29,220
already mentioned that's Co boot is a

00:22:24,310 --> 00:22:33,190
bit strange a strange beast in that

00:22:29,220 --> 00:22:37,150
people who say well what do I need to

00:22:33,190 --> 00:22:39,010
write coreboot how can I write you a

00:22:37,150 --> 00:22:43,650
cold boot support for my hardware that's

00:22:39,010 --> 00:22:47,590
why many people came to this talk and I

00:22:43,650 --> 00:22:51,700
really wanted to leave that point until

00:22:47,590 --> 00:22:53,740
well now the biggest problem when

00:22:51,700 --> 00:22:56,050
writing code boot support is that you

00:22:53,740 --> 00:22:58,900
need data sheets and data sheets are

00:22:56,050 --> 00:23:01,240
hard to come by

00:22:58,900 --> 00:23:02,890
you can ask the vendors and the vendors

00:23:01,240 --> 00:23:04,810
will give you data sheets and the data

00:23:02,890 --> 00:23:08,170
sheets are just an overview of what the

00:23:04,810 --> 00:23:10,360
hardware does doesn't help you then some

00:23:08,170 --> 00:23:12,820
vendors give you data sheet which has

00:23:10,360 --> 00:23:16,780
hardware programming information for

00:23:12,820 --> 00:23:20,980
example int will do that and mg MD do

00:23:16,780 --> 00:23:23,500
that that's nice but for coreboot we

00:23:20,980 --> 00:23:25,690
need data sheets which contain also

00:23:23,500 --> 00:23:27,970
information about initializing memory

00:23:25,690 --> 00:23:33,460
about initializing the CPU and stuff

00:23:27,970 --> 00:23:38,620
like that and for modern consumer CPUs

00:23:33,460 --> 00:23:40,810
modern consumer chipsets it's very hard

00:23:38,620 --> 00:23:43,240
to get into commutation from intro it's

00:23:40,810 --> 00:23:46,630
pretty easy to get the documentation

00:23:43,240 --> 00:23:47,950
from AMD which means it's downloadable

00:23:46,630 --> 00:23:55,660
for on their website without

00:23:47,950 --> 00:23:58,390
registration the question is what can I

00:23:55,660 --> 00:24:02,230
do without documentation well you can't

00:23:58,390 --> 00:24:06,640
do anything if you want to write chipset

00:24:02,230 --> 00:24:09,190
and processor code the

00:24:06,640 --> 00:24:13,929
original question how do I add support

00:24:09,190 --> 00:24:16,990
from my laptop is answered by telling

00:24:13,929 --> 00:24:20,500
people well make sure your processors

00:24:16,990 --> 00:24:23,170
supported by coreboot make sure your

00:24:20,500 --> 00:24:25,150
chips that is supported by coreboot if

00:24:23,170 --> 00:24:28,690
your process is not supported you can

00:24:25,150 --> 00:24:32,590
either write support for your processor

00:24:28,690 --> 00:24:35,290
well that's a bit labor-intensive um or

00:24:32,590 --> 00:24:38,110
you can switch or you can ask somebody

00:24:35,290 --> 00:24:40,750
um but that's the same problem or you

00:24:38,110 --> 00:24:43,179
can ask the vendor nicely same for your

00:24:40,750 --> 00:24:47,530
chipset however if your chipset and your

00:24:43,179 --> 00:24:50,679
processor are supported it is doable to

00:24:47,530 --> 00:24:53,919
add support for your laptop now please

00:24:50,679 --> 00:24:56,590
don't run away screaming doable means

00:24:53,919 --> 00:25:00,580
that you can if you have some hardware

00:24:56,590 --> 00:25:03,520
experience hardware knowledge you can

00:25:00,580 --> 00:25:09,460
maybe get it done in a month to a point

00:25:03,520 --> 00:25:10,929
where it works nicely however if you but

00:25:09,460 --> 00:25:13,030
that's only the case if you have data

00:25:10,929 --> 00:25:15,490
sheets and there's already working code

00:25:13,030 --> 00:25:18,669
for a CPU and chipset if you don't have

00:25:15,490 --> 00:25:23,380
data sheets I just suggest to give up

00:25:18,669 --> 00:25:26,530
beakers reverse engineering a chipset or

00:25:23,380 --> 00:25:28,750
a processor will take maybe two or three

00:25:26,530 --> 00:25:30,059
years if you work in that full-time it's

00:25:28,750 --> 00:25:32,950
not feasible

00:25:30,059 --> 00:25:35,410
however reverse engineering parts of the

00:25:32,950 --> 00:25:38,470
laptop is all part of a testament part

00:25:35,410 --> 00:25:43,090
is easier one of our developers is

00:25:38,470 --> 00:25:44,860
vention le who added support while he's

00:25:43,090 --> 00:25:46,870
sitting there can you just set up a

00:25:44,860 --> 00:25:53,520
shortly because he supported the

00:25:46,870 --> 00:25:53,520
ThinkPad X 60 and T 60 yeah

00:25:56,420 --> 00:26:01,530
he worked with a logic analyzer

00:25:59,510 --> 00:26:04,170
reverse-engineered they think that he

00:26:01,530 --> 00:26:05,970
was also lucky that he had schematics of

00:26:04,170 --> 00:26:09,630
birthing pad available so you could use

00:26:05,970 --> 00:26:12,300
it easily so hardware debugging is

00:26:09,630 --> 00:26:15,570
something which you need such a complex

00:26:12,300 --> 00:26:17,580
beast can be deducted best if you have a

00:26:15,570 --> 00:26:23,220
logic analyzer and you better have a

00:26:17,580 --> 00:26:28,500
good logic analyzer and yeah I think I

00:26:23,220 --> 00:26:41,970
have a nice picture of what of our setup

00:26:28,500 --> 00:26:42,920
looked like this was the wrong give me a

00:26:41,970 --> 00:26:51,300
second

00:26:42,920 --> 00:26:53,220
we have that's how it looks like if you

00:26:51,300 --> 00:26:55,080
want to do that professionally however

00:26:53,220 --> 00:27:00,000
you can get by without that equipment

00:26:55,080 --> 00:27:03,360
it's not that difficult to do you can

00:27:00,000 --> 00:27:11,760
actually do it with a small $50 logic

00:27:03,360 --> 00:27:13,770
analyzer and some patience I think

00:27:11,760 --> 00:27:15,990
getting back to writing support for your

00:27:13,770 --> 00:27:20,130
laptop the idea of writing support for

00:27:15,990 --> 00:27:24,300
your laptop is you find out how your

00:27:20,130 --> 00:27:28,260
laptop works by running diagnostic tools

00:27:24,300 --> 00:27:34,170
like LS PCI by checking the ACPI code of

00:27:28,260 --> 00:27:39,270
your existing laptop by running super

00:27:34,170 --> 00:27:42,990
tool which is also one of the tools we

00:27:39,270 --> 00:27:45,210
wrote for analysis of systems embedded

00:27:42,990 --> 00:27:51,120
controller checking and stuff like that

00:27:45,210 --> 00:27:53,700
and then you can just try to find out

00:27:51,120 --> 00:27:57,410
which command sequence means what and

00:27:53,700 --> 00:27:59,910
then you can try to replay that stuff

00:27:57,410 --> 00:28:01,380
replay is something which works

00:27:59,910 --> 00:28:03,240
sometimes sometimes you better

00:28:01,380 --> 00:28:04,680
understand what you're doing but it

00:28:03,240 --> 00:28:07,740
works pretty often

00:28:04,680 --> 00:28:12,020
we have if you do not own a logic

00:28:07,740 --> 00:28:16,640
analyzer and those beasts are well

00:28:12,020 --> 00:28:19,950
expensive a car is a lot cheaper and so

00:28:16,640 --> 00:28:24,230
what you can do is we have a project

00:28:19,950 --> 00:28:28,830
which is called serial eyes it's like a

00:28:24,230 --> 00:28:31,410
serial in-circuit emulator so we use qmu

00:28:28,830 --> 00:28:33,570
to run the x86 code and every hardware

00:28:31,410 --> 00:28:36,660
access is forwarded to real Hardware so

00:28:33,570 --> 00:28:39,900
you can just watch a bias execute and

00:28:36,660 --> 00:28:41,550
can just lock everything it does and all

00:28:39,900 --> 00:28:45,270
you need is a serial cable for five

00:28:41,550 --> 00:28:46,920
dollars well that's a bit cheaper than

00:28:45,270 --> 00:28:48,740
your logic analyzer but it's also slower

00:28:46,920 --> 00:28:57,530
than a logic analyzer

00:28:48,740 --> 00:29:00,180
so um next on what right um and that's

00:28:57,530 --> 00:29:02,580
partially disassembled laptop which is

00:29:00,180 --> 00:29:06,650
actually running coreboot which is

00:29:02,580 --> 00:29:09,330
working and no don't fear and you can

00:29:06,650 --> 00:29:17,730
reassemble it later and then it just

00:29:09,330 --> 00:29:20,790
looks normal well how many minutes I

00:29:17,730 --> 00:29:29,970
have left free okay

00:29:20,790 --> 00:29:34,500
so um maybe I'll just that did not work

00:29:29,970 --> 00:29:36,750
totally as expected um to demonstrate

00:29:34,500 --> 00:29:39,090
how fast code would boots I have two

00:29:36,750 --> 00:29:41,990
options first option I show you that

00:29:39,090 --> 00:29:44,610
laptop you will see something maybe

00:29:41,990 --> 00:29:47,460
especially in other words it's hard to

00:29:44,610 --> 00:29:51,630
see anything so the idea is to show a

00:29:47,460 --> 00:29:54,900
video of how it boots you will see the

00:29:51,630 --> 00:29:58,200
key press when when powers are on this

00:29:54,900 --> 00:30:01,050
laptop on and once the key presses done

00:29:58,200 --> 00:30:04,110
the it needs coordinates about one

00:30:01,050 --> 00:30:06,210
second to starch and once you see

00:30:04,110 --> 00:30:09,500
messages on screen Corbett is already

00:30:06,210 --> 00:30:09,500
done so

00:30:09,860 --> 00:30:16,210
okay Cobra justanna

00:30:12,850 --> 00:30:23,200
now I realized that a live demo is

00:30:16,210 --> 00:30:23,650
better so I'll just well if anybody can

00:30:23,200 --> 00:30:28,180
see it

00:30:23,650 --> 00:30:32,080
I'm pressing the button now and coreboot

00:30:28,180 --> 00:30:38,890
is done um well I can't see the screen

00:30:32,080 --> 00:30:42,400
myself inside so maybe not the best

00:30:38,890 --> 00:30:46,420
option right but what I can demonstrate

00:30:42,400 --> 00:30:51,760
is we boot it to a full Linux system

00:30:46,420 --> 00:30:59,410
I'll now reboot the system it's shutting

00:30:51,760 --> 00:31:01,830
down and reboot now coreboot is done so

00:30:59,410 --> 00:31:01,830
it's fast

00:31:08,510 --> 00:31:13,650
so yeah if you want to write support for

00:31:11,460 --> 00:31:16,799
your laptop just hit us up on our

00:31:13,650 --> 00:31:17,640
mailing list we all tell you how to get

00:31:16,799 --> 00:31:20,010
started

00:31:17,640 --> 00:31:23,400
I hope this talk at least provides some

00:31:20,010 --> 00:31:25,350
insight into how it could work now if

00:31:23,400 --> 00:31:27,620
you ask me which laptop can you buy

00:31:25,350 --> 00:31:31,470
right now which is code would support it

00:31:27,620 --> 00:31:34,320
the thick pad X 60 and think pad T 60

00:31:31,470 --> 00:31:38,460
are well supported they do work they are

00:31:34,320 --> 00:31:42,690
only available on well auction sites and

00:31:38,460 --> 00:31:46,320
used you are working on your laptops

00:31:42,690 --> 00:31:49,169
we're making progress with that I expect

00:31:46,320 --> 00:31:52,590
some new laptops which are actually

00:31:49,169 --> 00:31:56,960
viable in stores should be supported in

00:31:52,590 --> 00:32:00,809
maybe middle this year May or June and

00:31:56,960 --> 00:32:08,220
then I hope everybody can enjoy a

00:32:00,809 --> 00:32:12,000
coreboot laptop oh yeah and we are in

00:32:08,220 --> 00:32:14,370
the aw building so just if you have any

00:32:12,000 --> 00:32:17,340
questions um well I'll take a few

00:32:14,370 --> 00:32:20,270
questions now that for long questions

00:32:17,340 --> 00:32:22,890
please meet us at the aw building and

00:32:20,270 --> 00:32:31,650
now I want to say thank you and

00:32:22,890 --> 00:32:33,330
questions please we've got microphone

00:32:31,650 --> 00:32:41,010
over here and one over there for

00:32:33,330 --> 00:32:44,100
questions so microphone side bender so

00:32:41,010 --> 00:32:47,429
if it's possible to co-list speak a bit

00:32:44,100 --> 00:32:53,789
louder yeah if it's possible to put a

00:32:47,429 --> 00:32:58,549
boot on a t60 can I use your BIOS to me

00:32:53,789 --> 00:33:02,460
to write it yes indeed

00:32:58,549 --> 00:33:05,400
the Corbett project has a few other

00:33:02,460 --> 00:33:07,289
projects which belong to the Corbett

00:33:05,400 --> 00:33:10,320
family there's flash rom which allows

00:33:07,289 --> 00:33:13,230
you to write any bias efi firm

00:33:10,320 --> 00:33:16,320
call it whatever you want to live last

00:33:13,230 --> 00:33:21,480
ship and you can we've used flash room

00:33:16,320 --> 00:33:25,620
to reflash the flash chip of a t 60 or X

00:33:21,480 --> 00:33:27,990
60 a laptop and get it working with cold

00:33:25,620 --> 00:33:33,180
boot that's one limitation you need some

00:33:27,990 --> 00:33:37,020
special special utility to circumvent

00:33:33,180 --> 00:33:39,050
security but it will work next question

00:33:37,020 --> 00:33:39,050
please

00:33:39,440 --> 00:33:46,710
yeah the school boots solved the problem

00:33:44,310 --> 00:33:51,420
that might occur when we do it between

00:33:46,710 --> 00:33:53,640
us a team that you fi a UEFI the school

00:33:51,420 --> 00:33:57,030
boots of the problem that might occur

00:33:53,640 --> 00:34:02,610
with Windows 8 that requires two UEFI to

00:33:57,030 --> 00:34:06,990
be turned on you mean Windows 8 which

00:34:02,610 --> 00:34:11,280
will replay if I was we haven't tested

00:34:06,990 --> 00:34:13,980
yet but which does support ionic or as a

00:34:11,280 --> 00:34:15,929
payload so you can use Cobra for your

00:34:13,980 --> 00:34:20,330
hardware in it in if you really need if

00:34:15,929 --> 00:34:26,400
I could run with EFI if you want that

00:34:20,330 --> 00:34:28,350
and a developer preview of Windows 8 has

00:34:26,400 --> 00:34:32,910
been booted with Corbett so it does work

00:34:28,350 --> 00:34:36,810
yes yes yes so I have another question

00:34:32,910 --> 00:34:38,900
it's a bit linked to what he asked how

00:34:36,810 --> 00:34:44,610
do you provide all the features of

00:34:38,900 --> 00:34:49,500
classical bios like booting our PX e USB

00:34:44,610 --> 00:34:53,190
or management the point of it is to have

00:34:49,500 --> 00:34:55,370
no drivers so private just quits at once

00:34:53,190 --> 00:34:59,960
the image is done and I

00:34:55,370 --> 00:35:01,940
for example a virus will strip down bars

00:34:59,960 --> 00:35:04,850
for example see bias which we use for

00:35:01,940 --> 00:35:08,090
legacy support of Windows Linux and DDoS

00:35:04,850 --> 00:35:10,130
and that bias has drivers and then it

00:35:08,090 --> 00:35:15,320
can also be from USB or whatever you

00:35:10,130 --> 00:35:18,250
want ok ok one question that Cobert

00:35:15,320 --> 00:35:20,330
seems to have many advantages

00:35:18,250 --> 00:35:23,390
Corbitt seems to have plenty of

00:35:20,330 --> 00:35:25,460
advantages in terms of speed and support

00:35:23,390 --> 00:35:27,410
why do they motherboard manufacturers

00:35:25,460 --> 00:35:35,630
not use it instead of carrying on buying

00:35:27,410 --> 00:35:39,140
BIOS chips if you don't know something

00:35:35,630 --> 00:35:41,270
though you don't trust it so if a main

00:35:39,140 --> 00:35:43,670
that when assess well I haven't biased I

00:35:41,270 --> 00:35:45,800
know it worked for the last 10 or 20

00:35:43,670 --> 00:35:48,110
years they will continue using a bias

00:35:45,800 --> 00:35:50,150
because for them corporate is an unknown

00:35:48,110 --> 00:35:52,490
list even if you can demonstrate that it

00:35:50,150 --> 00:35:55,460
works low it's an unknown or I'm

00:35:52,490 --> 00:35:58,100
calculating base so we're seeing some

00:35:55,460 --> 00:36:02,770
main-belt members switch on demand but

00:35:58,100 --> 00:36:05,630
it's slow thanks I have a question about

00:36:02,770 --> 00:36:08,750
the graphics that you show of the

00:36:05,630 --> 00:36:12,740
typical modern PC yeah do you provide on

00:36:08,750 --> 00:36:17,350
your website or in some open place some

00:36:12,740 --> 00:36:20,570
documentation about the modern PC layout

00:36:17,350 --> 00:36:22,880
for example I am thinking about a very

00:36:20,570 --> 00:36:25,250
well-known book you know probably the

00:36:22,880 --> 00:36:27,860
Mesmer book about PC Harvard

00:36:25,250 --> 00:36:30,410
architecture yeah yeah we do have some

00:36:27,860 --> 00:36:33,110
some information material especially

00:36:30,410 --> 00:36:36,800
over about PC architecture we do that

00:36:33,110 --> 00:36:39,110
have that on our website so I just asked

00:36:36,800 --> 00:36:46,840
you to visit our website of cordage

00:36:39,110 --> 00:36:46,840

YouTube URL: https://www.youtube.com/watch?v=pJkmZgq7WWs


