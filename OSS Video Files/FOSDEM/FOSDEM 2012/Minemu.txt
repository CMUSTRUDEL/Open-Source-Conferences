Title: Minemu
Publication date: 2013-02-06
Playlist: FOSDEM 2012
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:05,879
my name is Eric respond I'm here to talk

00:00:02,939 --> 00:00:10,440
about mini-me mini-me 0 is a emulator

00:00:05,879 --> 00:00:17,970
for x86 design a process level emulator

00:00:10,440 --> 00:00:22,020
designed to protect binaries from memory

00:00:17,970 --> 00:00:28,980
corruption attacks so traditional stack

00:00:22,020 --> 00:00:31,949
smashing traditional smashing has become

00:00:28,980 --> 00:00:36,090
quite a bit difficult in the recent

00:00:31,949 --> 00:00:39,300
years luckily so in normally a you you

00:00:36,090 --> 00:00:41,129
used to inject your own code in the

00:00:39,300 --> 00:00:44,520
program and then through a buffer

00:00:41,129 --> 00:00:47,219
overflow overwrite a point a return

00:00:44,520 --> 00:00:49,920
pointer on the stack to point to your

00:00:47,219 --> 00:00:53,820
code instead of the coded would execute

00:00:49,920 --> 00:00:57,149
normally and then it would execute your

00:00:53,820 --> 00:00:59,340
code and done luckily as some things

00:00:57,149 --> 00:01:02,579
have changed so address space layered

00:00:59,340 --> 00:01:05,070
when the malaysian has made it more

00:01:02,579 --> 00:01:08,100
difficult to find your own code inside

00:01:05,070 --> 00:01:12,030
the address space and the NX bit on

00:01:08,100 --> 00:01:19,340
modern processors have allowed operating

00:01:12,030 --> 00:01:23,100
systems to do two separate data from

00:01:19,340 --> 00:01:26,970
executable you know writable data from

00:01:23,100 --> 00:01:29,310
executable data so that you can actually

00:01:26,970 --> 00:01:36,950
execute even if you jump to your own

00:01:29,310 --> 00:01:41,270
code and also there are some compiler

00:01:36,950 --> 00:01:43,799
optimization pilar flags in recent times

00:01:41,270 --> 00:01:48,360
such as fortify source and stack

00:01:43,799 --> 00:01:50,810
protector which try to protect against

00:01:48,360 --> 00:01:54,899
buffer overflows and if there are any

00:01:50,810 --> 00:01:58,320
package maintainer over here please 44

00:01:54,899 --> 00:02:05,520
by all your packages because it really

00:01:58,320 --> 00:02:10,319
helps so but yeah so this is still not

00:02:05,520 --> 00:02:13,319
enough the outer space random layout

00:02:10,319 --> 00:02:19,260
randomization is yeah after

00:02:13,319 --> 00:02:23,249
not not random enough to know to be

00:02:19,260 --> 00:02:28,430
brute forced and hip overflows which is

00:02:23,249 --> 00:02:30,840
another type of a memory corruption that

00:02:28,430 --> 00:02:39,349
yeah it's very difficult to protect

00:02:30,840 --> 00:02:39,349
against those and the NX bit I can be

00:02:39,530 --> 00:02:45,540
yeah can be circumvented by instead of

00:02:44,010 --> 00:02:48,000
jumping to your own code jumping too

00:02:45,540 --> 00:02:51,989
useful code inside the original program

00:02:48,000 --> 00:02:55,260
itself so you instead of jump instant

00:02:51,989 --> 00:02:58,519
yeah so you insert pointers to use for

00:02:55,260 --> 00:03:01,859
code in the application itself and then

00:02:58,519 --> 00:03:06,659
use the code of the original application

00:03:01,859 --> 00:03:12,209
against itself and but the situation is

00:03:06,659 --> 00:03:15,299
even worse because not yeah so all this

00:03:12,209 --> 00:03:19,829
thing I think protection mechanisms need

00:03:15,299 --> 00:03:23,159
to be enabled at compile time and there

00:03:19,829 --> 00:03:29,359
is a lot of old code out there and there

00:03:23,159 --> 00:03:33,079
are also yeah and and even new packages

00:03:29,359 --> 00:03:41,689
sometimes don't apply these mechanisms

00:03:33,079 --> 00:03:44,819
and yeah and there are also still some

00:03:41,689 --> 00:03:48,120
flaws in how the mechanisms are

00:03:44,819 --> 00:03:52,500
implemented on some systems so the

00:03:48,120 --> 00:03:57,979
question arises can we do more so if we

00:03:52,500 --> 00:04:02,639
see that data execution prevention that

00:03:57,979 --> 00:04:05,879
prevents you're interested code from

00:04:02,639 --> 00:04:09,810
being run as interested data from being

00:04:05,879 --> 00:04:12,060
Renaud's code we might say yeah and and

00:04:09,810 --> 00:04:16,199
the the counter-attack is that we

00:04:12,060 --> 00:04:20,570
instead of injecting code with inject

00:04:16,199 --> 00:04:23,279
pointers to and pointers to trusted code

00:04:20,570 --> 00:04:26,960
untrusted pointers to trusted code we

00:04:23,279 --> 00:04:33,750
might say can we prefer

00:04:26,960 --> 00:04:37,380
pointers to code being used as jump

00:04:33,750 --> 00:04:40,380
addresses so the answer is that we can

00:04:37,380 --> 00:04:45,710
do this through a technique called tent

00:04:40,380 --> 00:04:54,150
analysis and intent analysis we track

00:04:45,710 --> 00:04:58,440
what we track what what code yeah it's

00:04:54,150 --> 00:05:03,170
trusted or interested and then whenever

00:04:58,440 --> 00:05:09,150
data gets copied you also copied the

00:05:03,170 --> 00:05:11,670
data of whether it's trusted or not and

00:05:09,150 --> 00:05:13,410
if you combine two pieces of our

00:05:11,670 --> 00:05:17,910
information for an example when you add

00:05:13,410 --> 00:05:20,310
two integers you can or the trust

00:05:17,910 --> 00:05:25,770
information so that the the least

00:05:20,310 --> 00:05:30,000
trusted least trusted piece of

00:05:25,770 --> 00:05:36,830
information decides whether it's trusted

00:05:30,000 --> 00:05:40,290
are not and when you actually actually

00:05:36,830 --> 00:05:44,640
try to when the code actually try to

00:05:40,290 --> 00:05:51,810
jump to an untrusted pointer a check is

00:05:44,640 --> 00:05:55,710
done and an error is raised and yeah so

00:05:51,810 --> 00:05:58,200
so you can corrupt anything you like but

00:05:55,710 --> 00:06:03,300
when you try to use it it will blow up

00:05:58,200 --> 00:06:08,040
in your face and these systems already

00:06:03,300 --> 00:06:10,200
existed but are as slow as hell yeah so

00:06:08,040 --> 00:06:12,210
often in orbit order of magnitude

00:06:10,200 --> 00:06:14,100
because you have to do all the copying

00:06:12,210 --> 00:06:17,880
and maintaining whether it's just it or

00:06:14,100 --> 00:06:21,450
not so we try to see whether we could

00:06:17,880 --> 00:06:25,850
make it faster so we used in many movie

00:06:21,450 --> 00:06:30,770
used two tricks to try to make the

00:06:25,850 --> 00:06:34,710
propagation of taint faster first we

00:06:30,770 --> 00:06:37,230
have a novel memory layout so this is

00:06:34,710 --> 00:06:40,569
this is how you can feel the Linux

00:06:37,230 --> 00:06:43,270
kernel memory layout on a 32-bit

00:06:40,569 --> 00:06:47,110
so you have what the high quarter of the

00:06:43,270 --> 00:06:49,659
address space is in used by the colonel

00:06:47,110 --> 00:06:54,219
if you read or write from it it will

00:06:49,659 --> 00:06:58,149
generate a fault and then the rest is is

00:06:54,219 --> 00:07:03,789
used by the user process so we define

00:06:58,149 --> 00:07:11,800
with change this layout a bit so we have

00:07:03,789 --> 00:07:17,939
two equally equally sized areas of

00:07:11,800 --> 00:07:17,939
memory which and one of the pieces that

00:07:20,219 --> 00:07:28,119
is in user can be used by the UN by the

00:07:24,189 --> 00:07:30,399
user process and the other one is is

00:07:28,119 --> 00:07:33,879
used to hold attained information and

00:07:30,399 --> 00:07:36,669
then there's our third piece which is

00:07:33,879 --> 00:07:39,069
used by the emulator itself for a jet

00:07:36,669 --> 00:07:44,949
translation code because everything is

00:07:39,069 --> 00:07:48,879
translated so during execution only the

00:07:44,949 --> 00:07:56,709
user and the taint pieces of memory are

00:07:48,879 --> 00:08:01,149
our account can be accessed by the

00:07:56,709 --> 00:08:05,769
program and because there are of equal

00:08:01,149 --> 00:08:09,009
size we can if we want to propagate a

00:08:05,769 --> 00:08:11,289
right to an address in the arsenal

00:08:09,009 --> 00:08:14,619
memory we can just add the number and

00:08:11,289 --> 00:08:18,459
there we have the address of where the

00:08:14,619 --> 00:08:23,740
trust value of the this address is in 10

00:08:18,459 --> 00:08:27,579
memory and because the way the memory is

00:08:23,740 --> 00:08:31,930
laid out if if if the process tries to

00:08:27,579 --> 00:08:34,269
right into the 10 memory or it will

00:08:31,930 --> 00:08:40,319
generate a fault so we will detect it at

00:08:34,269 --> 00:08:43,750
least so if we want to access the tank

00:08:40,319 --> 00:08:48,069
memory we only have to add a constant so

00:08:43,750 --> 00:08:51,519
the nice thing is that on Intel you can

00:08:48,069 --> 00:08:53,560
add a constant to any addressing mode in

00:08:51,519 --> 00:08:55,950
the in the

00:08:53,560 --> 00:09:01,230
machine code instructions and have

00:08:55,950 --> 00:09:06,000
another addressing mode which yeah

00:09:01,230 --> 00:09:09,970
accesses the same memory location but

00:09:06,000 --> 00:09:14,110
with an offset of a certain constant so

00:09:09,970 --> 00:09:18,700
for example for an instruction which

00:09:14,110 --> 00:09:25,089
accesses the memory at the edx register

00:09:18,700 --> 00:09:27,940
which is now in we can have a addressing

00:09:25,089 --> 00:09:31,380
mode which accesses edx plus some

00:09:27,940 --> 00:09:35,890
constant and that that we holds for all

00:09:31,380 --> 00:09:41,650
even the memory listening modes even the

00:09:35,890 --> 00:09:43,839
more exotic ones so the second

00:09:41,650 --> 00:09:45,910
innovation is that we use as a see

00:09:43,839 --> 00:09:49,420
register so we emulate a process for

00:09:45,910 --> 00:09:53,110
without assessee registers and then we

00:09:49,420 --> 00:09:57,700
hold these addresses as we use these

00:09:53,110 --> 00:10:01,770
addresses to call the keep the tenth

00:09:57,700 --> 00:10:01,770
value for the general purpose registers

00:10:01,920 --> 00:10:07,720
so that we don't have to store them in

00:10:04,540 --> 00:10:11,650
memory so it's much faster so this is

00:10:07,720 --> 00:10:15,730
how it's done we use to as he registers

00:10:11,650 --> 00:10:20,890
to hold attains and so we separate them

00:10:15,730 --> 00:10:27,130
in four columns and yeah so we can store

00:10:20,890 --> 00:10:33,520
the tent for all eight registers so if

00:10:27,130 --> 00:10:37,480
we want to for example add the taint

00:10:33,520 --> 00:10:39,910
from a memory location X to the EDX

00:10:37,480 --> 00:10:42,070
register we can do it very simply we

00:10:39,910 --> 00:10:44,380
just identify the column where this in

00:10:42,070 --> 00:10:47,680
and then through the SSE instructions

00:10:44,380 --> 00:10:53,770
which are quite powerful we can first

00:10:47,680 --> 00:10:56,380
load the detained from register detained

00:10:53,770 --> 00:11:02,220
from memory at location X plus the

00:10:56,380 --> 00:11:05,860
constant into memory and then do an or

00:11:02,220 --> 00:11:07,379
and then you know we have in just two

00:11:05,860 --> 00:11:12,309
instructions we have

00:11:07,379 --> 00:11:15,009
done the propagation for this for this

00:11:12,309 --> 00:11:17,709
instruction and some most most

00:11:15,009 --> 00:11:22,389
instructions will need one or two extra

00:11:17,709 --> 00:11:24,879
instructions to propagate things and so

00:11:22,389 --> 00:11:28,230
we tested the effectiveness of this

00:11:24,879 --> 00:11:32,259
method so against a lot of exploits and

00:11:28,230 --> 00:11:34,929
as in all of them they know that

00:11:32,259 --> 00:11:37,929
exploits were called and it's important

00:11:34,929 --> 00:11:40,769
to know that the vulnerabilities that

00:11:37,929 --> 00:11:43,660
our cords aren't don't have to be known

00:11:40,769 --> 00:11:46,929
beforehand so if there's an unknown

00:11:43,660 --> 00:11:51,879
vulnerability you can catch it with this

00:11:46,929 --> 00:11:54,939
tool before we also did performance

00:11:51,879 --> 00:11:57,429
tests so for I our bounds applications

00:11:54,939 --> 00:12:00,759
the performance is quite reasonable

00:11:57,429 --> 00:12:04,269
because you know there's no not not a

00:12:00,759 --> 00:12:07,449
lot of number crunching so most of the

00:12:04,269 --> 00:12:10,929
time is just copying data and for that

00:12:07,449 --> 00:12:12,549
the overhead isn't that much if you if

00:12:10,929 --> 00:12:16,529
you want to do a number crunching such

00:12:12,549 --> 00:12:20,439
as encryption the overhead seems to be

00:12:16,529 --> 00:12:22,449
almost three times the slow but that

00:12:20,439 --> 00:12:25,089
might still be useful for some

00:12:22,449 --> 00:12:28,499
applications your your server might not

00:12:25,089 --> 00:12:33,579
be loaded at all and you really want

00:12:28,499 --> 00:12:38,860
your data to be secure and so it's yeah

00:12:33,579 --> 00:12:43,329
you have to make a trade off we also

00:12:38,860 --> 00:12:45,749
tested two very I are bound very CPU

00:12:43,329 --> 00:12:49,869
bound so very difficult for the system

00:12:45,749 --> 00:12:53,799
applications and with ya overall it's

00:12:49,869 --> 00:12:59,259
it's 2.4 times too slow and we tested it

00:12:53,799 --> 00:13:03,999
through a against also some real time

00:12:59,259 --> 00:13:08,259
real real life applications there are

00:13:03,999 --> 00:13:10,029
some limitations to this system we don't

00:13:08,259 --> 00:13:14,439
prevent memory corruption we only

00:13:10,029 --> 00:13:18,490
prevent when it's used so that's yeah

00:13:14,439 --> 00:13:20,420
that's the best we can do with this

00:13:18,490 --> 00:13:23,779
technology but it's

00:13:20,420 --> 00:13:28,279
still quite useful I think and there are

00:13:23,779 --> 00:13:33,370
also some some corn acacia in cases

00:13:28,279 --> 00:13:37,970
where where I'll see if you if you can

00:13:33,370 --> 00:13:45,850
before you can execute your own code can

00:13:37,970 --> 00:13:49,579
find you know some appointed yeah so

00:13:45,850 --> 00:13:51,529
yeah you can write something to

00:13:49,579 --> 00:13:56,180
arbitrary memory and that something is

00:13:51,529 --> 00:13:58,970
is trusted then you also have a problem

00:13:56,180 --> 00:14:01,070
but this is yeah just a very small

00:13:58,970 --> 00:14:07,579
subset of vulnerabilities that are

00:14:01,070 --> 00:14:09,410
discovered so well and there's also a

00:14:07,579 --> 00:14:11,959
limitation if you don't offer write a

00:14:09,410 --> 00:14:14,449
function pointer but just something else

00:14:11,959 --> 00:14:20,089
for example does the user have the right

00:14:14,449 --> 00:14:24,970
to read this file then you also are yeah

00:14:20,089 --> 00:14:24,970
it's also not caught because yeah the

00:14:27,220 --> 00:14:38,870
yeah it's not caught because you don't

00:14:35,560 --> 00:14:42,699
yeah you don't you never check for

00:14:38,870 --> 00:14:47,750
whether the function pointers trusted so

00:14:42,699 --> 00:14:51,100
in some cases we can also catch other

00:14:47,750 --> 00:14:54,050
vulnerabilities if we add hooks to

00:14:51,100 --> 00:14:57,170
certain functions for example to my

00:14:54,050 --> 00:15:00,980
MySQL query we can have detailed

00:14:57,170 --> 00:15:04,370
information about which which data in

00:15:00,980 --> 00:15:12,560
the MySQL query is or in the SQL query

00:15:04,370 --> 00:15:15,230
is trust it or not so as so we could

00:15:12,560 --> 00:15:19,389
could have more information about SQL

00:15:15,230 --> 00:15:23,630
injections this way because you can if

00:15:19,389 --> 00:15:29,480
you find an end or keyway SQL keyword

00:15:23,630 --> 00:15:31,690
which is untrusted then it's wrong so if

00:15:29,480 --> 00:15:34,040
there's I don't think there's time but

00:15:31,690 --> 00:15:39,949
yeah so you can this

00:15:34,040 --> 00:15:42,019
is available at the website now we don't

00:15:39,949 --> 00:15:44,470
have time for questions but if anyone

00:15:42,019 --> 00:15:44,470

YouTube URL: https://www.youtube.com/watch?v=S0RVL7sb8Qs


