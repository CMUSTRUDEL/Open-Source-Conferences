Title: Wayland
Publication date: 2013-02-05
Playlist: FOSDEM 2012
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:10,070 --> 00:00:14,700
thank you

00:00:11,370 --> 00:00:17,369
they say it sounds like it's working so

00:00:14,700 --> 00:00:20,970
when my name is Christian Hawkes Burke

00:00:17,369 --> 00:00:23,130
and I'll talk about Weiland and then if

00:00:20,970 --> 00:00:24,810
you if you'll bear me with me I'll just

00:00:23,130 --> 00:00:29,449
spend the next slide here introducing

00:00:24,810 --> 00:00:33,059
myself because then okay I will try and

00:00:29,449 --> 00:00:37,320
I'm gonna spend just an extra slide here

00:00:33,059 --> 00:00:39,180
on introducing myself and and the thing

00:00:37,320 --> 00:00:41,219
is I sometimes I sit there read the

00:00:39,180 --> 00:00:43,020
internet and there are people out there

00:00:41,219 --> 00:00:46,500
talking about whaling comments and

00:00:43,020 --> 00:00:48,690
websites and they usually talk about how

00:00:46,500 --> 00:00:51,090
the wayand developers still know X and

00:00:48,690 --> 00:00:53,129
how what did the exalt developers really

00:00:51,090 --> 00:00:56,160
think about whaling in what's going on

00:00:53,129 --> 00:00:57,960
and so I wanted to just provide some

00:00:56,160 --> 00:01:00,899
background for what I've done and where

00:00:57,960 --> 00:01:05,640
I come from and then I used to work for

00:01:00,899 --> 00:01:07,590
race head as in 2005 until a couple of

00:01:05,640 --> 00:01:10,439
years ago and I worked in the X team at

00:01:07,590 --> 00:01:13,590
at Red Hat and I did we did things like

00:01:10,439 --> 00:01:17,369
AIG elects to let capacitors GL based

00:01:13,590 --> 00:01:20,880
compositors run under X and we did dri

00:01:17,369 --> 00:01:23,040
to that enabled GL applications to work

00:01:20,880 --> 00:01:27,990
smoothly under composite ourselves as

00:01:23,040 --> 00:01:31,049
calm peace and kwin modern so on and so

00:01:27,990 --> 00:01:34,200
I did a lot of work on X back then and

00:01:31,049 --> 00:01:36,509
we pushed it forward with compositing we

00:01:34,200 --> 00:01:39,030
fixed all of the box and problems that

00:01:36,509 --> 00:01:40,799
prevented us from using X in a composite

00:01:39,030 --> 00:01:43,500
environment and some we spend a lot of

00:01:40,799 --> 00:01:47,729
time pushing X forward and trying to get

00:01:43,500 --> 00:01:53,340
X more modern and useful for what we

00:01:47,729 --> 00:01:56,189
wanted to do so so I come from a

00:01:53,340 --> 00:01:57,659
background as an X developer and then a

00:01:56,189 --> 00:01:58,950
lot of what we don't with wait and they

00:01:57,659 --> 00:02:01,710
sort of the natural extension of that

00:01:58,950 --> 00:02:04,079
work where we've did as much as we could

00:02:01,710 --> 00:02:06,479
with X and then we got to a point where

00:02:04,079 --> 00:02:09,239
we realized well we can only do so much

00:02:06,479 --> 00:02:11,400
with X and and what we have done on top

00:02:09,239 --> 00:02:13,770
of X now is essentially a new Windows

00:02:11,400 --> 00:02:16,110
system which is why people say X is good

00:02:13,770 --> 00:02:20,810
that's because we built a different

00:02:16,110 --> 00:02:26,430
window system on top effects and and

00:02:20,810 --> 00:02:30,480
again we basically want to make the

00:02:26,430 --> 00:02:33,150
Linux desktop experience better and that

00:02:30,480 --> 00:02:34,380
may involve X or you may not involve me

00:02:33,150 --> 00:02:39,150
actually and I think we're gotten to a

00:02:34,380 --> 00:02:43,680
point where we have to move forward and

00:02:39,150 --> 00:02:45,960
move away from X and so with that out of

00:02:43,680 --> 00:02:52,050
the way and let's go and look at what

00:02:45,960 --> 00:02:53,670
and whalen is it's and it's also it's

00:02:52,050 --> 00:02:55,650
that's a hard question to answer because

00:02:53,670 --> 00:02:57,840
there are several things in Whalen but

00:02:55,650 --> 00:03:02,580
mainly it is a new display server

00:02:57,840 --> 00:03:04,290
architecture it's it's M replaces X it's

00:03:02,580 --> 00:03:06,990
it's a standalone architecture for

00:03:04,290 --> 00:03:09,870
having s display server with climbs that

00:03:06,990 --> 00:03:11,970
lets you run a modern fully complete

00:03:09,870 --> 00:03:18,560
desktop and it scales down to mobile

00:03:11,970 --> 00:03:20,700
devices and embedded use cases it

00:03:18,560 --> 00:03:22,380
integrates some of the functionality we

00:03:20,700 --> 00:03:24,900
have in separate processes in under X

00:03:22,380 --> 00:03:27,420
today with X we have the display server

00:03:24,900 --> 00:03:29,360
itself we have a compositor and the

00:03:27,420 --> 00:03:32,790
window manner you sit in one process and

00:03:29,360 --> 00:03:35,400
with with Wayland we take those three

00:03:32,790 --> 00:03:40,320
 and responsibilities and combined

00:03:35,400 --> 00:03:41,850
into one display server and it's a

00:03:40,320 --> 00:03:44,790
display server it's not a rendering

00:03:41,850 --> 00:03:47,430
server where X today lets you send

00:03:44,790 --> 00:03:49,830
rendering requests to the X server with

00:03:47,430 --> 00:03:51,840
the XA we will then execute and render

00:03:49,830 --> 00:03:54,030
for you the whelen doesn't have any

00:03:51,840 --> 00:03:56,220
rendering API so you can't use wait and

00:03:54,030 --> 00:03:59,970
to render your UI you have to render it

00:03:56,220 --> 00:04:04,410
locally using GL or software or some

00:03:59,970 --> 00:04:06,570
kind of local rendering API and what

00:04:04,410 --> 00:04:09,120
Waylon lets you do is take that buffer

00:04:06,570 --> 00:04:10,830
the result of your rendering you take

00:04:09,120 --> 00:04:13,320
that buffer you pass it to the

00:04:10,830 --> 00:04:15,720
compositor and then that buffer gets

00:04:13,320 --> 00:04:23,040
integrated into the complete desktop

00:04:15,720 --> 00:04:24,780
image so writing a complete new display

00:04:23,040 --> 00:04:26,729
server sounds ambitious and it sounds

00:04:24,780 --> 00:04:27,550
well it is something that a lot of

00:04:26,729 --> 00:04:31,599
people have tried in the

00:04:27,550 --> 00:04:35,770
passed and a lot of efforts didn't end

00:04:31,599 --> 00:04:38,259
well and it turns out that at this point

00:04:35,770 --> 00:04:40,150
in time where we are with X with our

00:04:38,259 --> 00:04:42,370
kernel infrastructure with our 3d

00:04:40,150 --> 00:04:44,379
drivers it's not a crazy project anymore

00:04:42,370 --> 00:04:46,449
it's more or less a refactoring and

00:04:44,379 --> 00:04:50,080
cleaning up what we already have that

00:04:46,449 --> 00:04:51,729
we're consolidating but what we're doing

00:04:50,080 --> 00:04:54,009
today we're refactoring the displace

00:04:51,729 --> 00:04:56,940
able to support the u.s. we actually

00:04:54,009 --> 00:04:56,940
used today

00:04:59,610 --> 00:05:08,229
so just to recap and fast but but and

00:05:05,039 --> 00:05:10,270
we're what X did in the past how we used

00:05:08,229 --> 00:05:14,319
X in the past and how are you guys

00:05:10,270 --> 00:05:16,090
worked in the past we we we used to have

00:05:14,319 --> 00:05:19,060
a lot of we and there still is a lot of

00:05:16,090 --> 00:05:21,840
functionality in X that does only

00:05:19,060 --> 00:05:25,539
rendering so when you when you render

00:05:21,840 --> 00:05:28,810
rectangles lines Wyatt curves and so on

00:05:25,539 --> 00:05:31,240
the x over has code to rasterize all

00:05:28,810 --> 00:05:33,430
that rendering it has code to manage

00:05:31,240 --> 00:05:36,789
this date how thick their honor heavier

00:05:33,430 --> 00:05:38,979
lines and what's your stipple and so all

00:05:36,789 --> 00:05:41,020
this graphics state is managed by the X

00:05:38,979 --> 00:05:42,610
server there is API and protocol to

00:05:41,020 --> 00:05:44,289
change that state and we have to have a

00:05:42,610 --> 00:05:47,590
lot of code to accelerate on that

00:05:44,289 --> 00:05:49,029
rendering but today we don't use any of

00:05:47,590 --> 00:05:51,610
that because applications render

00:05:49,029 --> 00:05:54,099
themselves so we have a we have a really

00:05:51,610 --> 00:05:58,690
big protocol because rendering API sub

00:05:54,099 --> 00:06:00,069
complex they have a lot of state and we

00:05:58,690 --> 00:06:01,690
have all that protocol in the X Server

00:06:00,069 --> 00:06:03,940
to to render if we don't use it because

00:06:01,690 --> 00:06:08,349
it's all happening locally and we only

00:06:03,940 --> 00:06:10,360
share the buffer at the end another

00:06:08,349 --> 00:06:13,150
thing about the X server is that it has

00:06:10,360 --> 00:06:16,180
a fairly complex Windows system where

00:06:13,150 --> 00:06:18,550
the way Windows work are a recursive

00:06:16,180 --> 00:06:20,889
tree you have it the root window is that

00:06:18,550 --> 00:06:22,599
the top window then they have sub window

00:06:20,889 --> 00:06:24,129
so that you can move around and those

00:06:22,599 --> 00:06:26,800
windows can have stop windows and it

00:06:24,129 --> 00:06:29,129
goes all the way down you can nest it as

00:06:26,800 --> 00:06:30,969
deeply as you want it and in the past

00:06:29,129 --> 00:06:33,669
torque it's used to use this

00:06:30,969 --> 00:06:36,190
functionality to say here's my input

00:06:33,669 --> 00:06:38,860
field in my window and you could you

00:06:36,190 --> 00:06:40,029
could do have the X ray remain as an

00:06:38,860 --> 00:06:41,380
input field if you set a different

00:06:40,029 --> 00:06:43,030
background color for that window

00:06:41,380 --> 00:06:44,680
and yet sir would repaint find out that

00:06:43,030 --> 00:06:47,320
it would change the cursor for you and

00:06:44,680 --> 00:06:49,960
he would do a lot of half halfway of the

00:06:47,320 --> 00:06:52,750
rendering and the idea was that if

00:06:49,960 --> 00:06:54,490
you're on a slow connection and you that

00:06:52,750 --> 00:06:55,180
if window gets exposed and you have to

00:06:54,490 --> 00:06:57,160
repaint it

00:06:55,180 --> 00:06:59,200
the X Server can can kind of repaint it

00:06:57,160 --> 00:07:00,820
halfway there and then you can repaint

00:06:59,200 --> 00:07:02,350
the curst and their focus in there and

00:07:00,820 --> 00:07:04,510
if you move across the window you don't

00:07:02,350 --> 00:07:08,470
have to round-trip to the X zero to get

00:07:04,510 --> 00:07:09,850
that cursor right so that that's what we

00:07:08,470 --> 00:07:12,310
stopped windows did for us in the past

00:07:09,850 --> 00:07:15,730
but none of the toolkits you said today

00:07:12,310 --> 00:07:18,520
instead of using a sub window for an

00:07:15,730 --> 00:07:20,740
input field they just draw a rectangle

00:07:18,520 --> 00:07:22,030
there instead of changing the cursor by

00:07:20,740 --> 00:07:22,480
setting a different cursor for that

00:07:22,030 --> 00:07:24,280
window

00:07:22,480 --> 00:07:25,840
they watched cursor motion and when the

00:07:24,280 --> 00:07:28,420
cursor moves into that field they set

00:07:25,840 --> 00:07:29,950
the cursor so a lot of the toolkit has

00:07:28,420 --> 00:07:32,170
moved away from this model and they just

00:07:29,950 --> 00:07:33,640
have one big window and they managed all

00:07:32,170 --> 00:07:35,950
this structure within their window

00:07:33,640 --> 00:07:38,980
themself so a lot of the complexity we

00:07:35,950 --> 00:07:41,800
have an X to do that sits unused and end

00:07:38,980 --> 00:07:44,920
in foot delivery and exposures and all

00:07:41,800 --> 00:07:47,980
that stuff is really complex and nobody

00:07:44,920 --> 00:07:49,360
knows how it works very well well a few

00:07:47,980 --> 00:07:52,450
people do and that's part of the problem

00:07:49,360 --> 00:07:54,610
is that we have a lot of complexity and

00:07:52,450 --> 00:07:56,230
nobody uses we have to keep it running

00:07:54,610 --> 00:07:59,140
and there's an interrupt there aren't a

00:07:56,230 --> 00:08:00,670
lot of people that really touch that

00:07:59,140 --> 00:08:07,870
stuff and know how to change it without

00:08:00,670 --> 00:08:11,080
breaking the world and so another thing

00:08:07,870 --> 00:08:13,870
that changed is that a lot of the driver

00:08:11,080 --> 00:08:16,210
side of X has moved into separate

00:08:13,870 --> 00:08:20,500
reusable components or drivers in the

00:08:16,210 --> 00:08:24,190
kernel and not long ago the an X driver

00:08:20,500 --> 00:08:25,900
would have to set the mode program the

00:08:24,190 --> 00:08:30,460
registers to bring up the display in the

00:08:25,900 --> 00:08:33,729
right mode you would have to share their

00:08:30,460 --> 00:08:35,380
hardware with real clients by using a

00:08:33,729 --> 00:08:39,039
big lock and programming the registers

00:08:35,380 --> 00:08:40,570
and it was very hard to have a system

00:08:39,039 --> 00:08:46,560
where you can have several clients and

00:08:40,570 --> 00:08:49,390
they're using the same hardware and and

00:08:46,560 --> 00:08:51,280
again they did the acceleration code

00:08:49,390 --> 00:08:53,290
that we use for accelerating X was also

00:08:51,280 --> 00:08:54,730
tied up in the X driver so it wasn't

00:08:53,290 --> 00:08:56,260
really possible to

00:08:54,730 --> 00:09:02,970
changed the way things worked it was

00:08:56,260 --> 00:09:06,430
always tied up in this ex model and them

00:09:02,970 --> 00:09:09,070
so what change there was we moved out

00:09:06,430 --> 00:09:11,140
most sitting into the kernel we moved

00:09:09,070 --> 00:09:12,690
out memory management and execution

00:09:11,140 --> 00:09:15,250
management so that when you submit

00:09:12,690 --> 00:09:16,870
rendering commands to the hardware the

00:09:15,250 --> 00:09:18,850
colonel knows how to multiplex and

00:09:16,870 --> 00:09:21,610
arbitrate between several clients trying

00:09:18,850 --> 00:09:24,010
to use the hardware and we made the GL

00:09:21,610 --> 00:09:26,260
drivers independent of X so that we can

00:09:24,010 --> 00:09:28,060
use them as ETL drivers or dearly as two

00:09:26,260 --> 00:09:29,890
drivers and we made it possible to use

00:09:28,060 --> 00:09:32,290
those driver directly on kernel mode

00:09:29,890 --> 00:09:33,940
turning without X so a lot of the

00:09:32,290 --> 00:09:36,040
infrastructure that was tied up into

00:09:33,940 --> 00:09:37,810
this big monolithic X Server has been

00:09:36,040 --> 00:09:40,780
split our interval useable components

00:09:37,810 --> 00:09:42,880
and it even for the decide the input

00:09:40,780 --> 00:09:44,890
side will be like we'll get input events

00:09:42,880 --> 00:09:47,770
from mouse and keyboard has has been

00:09:44,890 --> 00:09:50,020
changed it used to be that the X server

00:09:47,770 --> 00:09:52,960
had a lot of code to go out and pass the

00:09:50,020 --> 00:09:54,550
serial protocols from different mice it

00:09:52,960 --> 00:09:58,330
used to be able to talk to different

00:09:54,550 --> 00:10:00,160
keyboards and it was it was a mess - we

00:09:58,330 --> 00:10:02,440
had ten different input drivers for

00:10:00,160 --> 00:10:05,770
different Spaceballs and so on whatever

00:10:02,440 --> 00:10:09,220
the different input types were but today

00:10:05,770 --> 00:10:12,490
all we do is talk to the EVF driver the

00:10:09,220 --> 00:10:14,320
EVF driver is a kernel interface that

00:10:12,490 --> 00:10:16,540
lets us talk to a wide range of

00:10:14,320 --> 00:10:19,240
different input devices with a uniform

00:10:16,540 --> 00:10:21,610
interface so whether you plug in a plane

00:10:19,240 --> 00:10:25,540
on my mouse or you plug in some kind of

00:10:21,610 --> 00:10:27,220
weird 3d controller or a touchscreen or

00:10:25,540 --> 00:10:30,280
keyboard it all shows up as an eva dev

00:10:27,220 --> 00:10:31,660
device with a uniform interface so the

00:10:30,280 --> 00:10:33,070
whole input driver story is is

00:10:31,660 --> 00:10:35,440
simplified - you don't need to

00:10:33,070 --> 00:10:37,810
understand serial protocol or configure

00:10:35,440 --> 00:10:40,110
the PO rate on your mouse it just works

00:10:37,810 --> 00:10:40,110
today

00:10:49,800 --> 00:10:55,480
so and those were all infrastructure

00:10:53,440 --> 00:10:56,889
changes that that made this deck more

00:10:55,480 --> 00:10:58,570
modular and reusable but the biggest

00:10:56,889 --> 00:11:01,149
change that really changed that happened

00:10:58,570 --> 00:11:04,600
in the past few years is that we started

00:11:01,149 --> 00:11:06,910
using compositors and we went from a

00:11:04,600 --> 00:11:09,130
Windows system that would render

00:11:06,910 --> 00:11:10,959
on-demand to something that rendered

00:11:09,130 --> 00:11:12,670
we're plans render into back buffers and

00:11:10,959 --> 00:11:15,819
we have this compositor process that

00:11:12,670 --> 00:11:22,870
compile combines the windows surfaces

00:11:15,819 --> 00:11:24,910
into the desktop image so the idea is

00:11:22,870 --> 00:11:27,069
that with with X we had this big offer

00:11:24,910 --> 00:11:29,050
the color buffer that actually is what

00:11:27,069 --> 00:11:30,579
you see on your screen and when clients

00:11:29,050 --> 00:11:32,529
want to render into that buffer they'd

00:11:30,579 --> 00:11:34,480
send commands to the server and the

00:11:32,529 --> 00:11:36,490
server will clip those commands against

00:11:34,480 --> 00:11:38,350
the rectangles so if you if you're

00:11:36,490 --> 00:11:40,509
overlapped by a different window we

00:11:38,350 --> 00:11:43,060
don't get to paint in that area so we

00:11:40,509 --> 00:11:45,060
share that a big buffer by going through

00:11:43,060 --> 00:11:47,470
the Xserve and it's clipping rectangles

00:11:45,060 --> 00:11:49,870
but with compositing we went to a model

00:11:47,470 --> 00:11:54,730
where it's a place now has its own back

00:11:49,870 --> 00:11:56,199
buffer so you can defer and a little

00:11:54,730 --> 00:11:57,670
window up here you have your own back

00:11:56,199 --> 00:11:58,630
before you render into that and over

00:11:57,670 --> 00:12:01,120
here there may be a web browser

00:11:58,630 --> 00:12:04,510
rendering into its own window and maybe

00:12:01,120 --> 00:12:06,459
we have a terminal here rendering to his

00:12:04,510 --> 00:12:08,440
own window so every application has its

00:12:06,459 --> 00:12:11,199
own back buffer the compositor will take

00:12:08,440 --> 00:12:13,569
these individual buffers and composite

00:12:11,199 --> 00:12:15,190
I mean overlay these different offers

00:12:13,569 --> 00:12:17,110
into there the screen and that's how

00:12:15,190 --> 00:12:24,010
that's how the screen gets painted in a

00:12:17,110 --> 00:12:25,660
compositor desktop and it used to be

00:12:24,010 --> 00:12:27,760
that people who have composited desktops

00:12:25,660 --> 00:12:30,220
were all about wobbly windows spinning

00:12:27,760 --> 00:12:31,720
cubes and windows on fire but today we

00:12:30,220 --> 00:12:33,790
actually we've gone to a point where

00:12:31,720 --> 00:12:35,290
it's not so much about the effects

00:12:33,790 --> 00:12:38,319
anymore it's about the better quality

00:12:35,290 --> 00:12:39,730
you get from from the desktop you don't

00:12:38,319 --> 00:12:42,250
get flickering when you move windows

00:12:39,730 --> 00:12:43,630
around when you windows yourself it

00:12:42,250 --> 00:12:46,540
doesn't show up blink and then get

00:12:43,630 --> 00:12:48,189
repainted almost immediately but you see

00:12:46,540 --> 00:12:50,589
still see their flash when you resize

00:12:48,189 --> 00:12:53,260
window you don't see the the window fast

00:12:50,589 --> 00:12:56,620
move the window frame move and then the

00:12:53,260 --> 00:12:57,300
window repaint so another flicker we had

00:12:56,620 --> 00:12:59,970
in

00:12:57,300 --> 00:13:01,589
in the old desktop and when their way

00:12:59,970 --> 00:13:04,350
when we started doing compositing

00:13:01,589 --> 00:13:05,640
because the composite I can bats up on

00:13:04,350 --> 00:13:07,860
this rendering and make sure that we

00:13:05,640 --> 00:13:10,170
don't clear in one frame and then we

00:13:07,860 --> 00:13:13,050
fill in the next but clear and repaint

00:13:10,170 --> 00:13:15,720
and only then show the result so today

00:13:13,050 --> 00:13:18,240
compositing is a requirement for a good

00:13:15,720 --> 00:13:22,140
test of experience to experience it it

00:13:18,240 --> 00:13:26,420
avoids all the flickering and bad

00:13:22,140 --> 00:13:26,420
experience with with the the old model

00:13:29,060 --> 00:13:36,420
so with Wayland and one thing that

00:13:33,180 --> 00:13:39,390
happened was that when you look at the

00:13:36,420 --> 00:13:41,700
the ex model SS we have it today without

00:13:39,390 --> 00:13:43,470
whaling we running the compositor which

00:13:41,700 --> 00:13:45,899
is responsible for painting the entire

00:13:43,470 --> 00:13:47,520
desktop it has these textures coming in

00:13:45,899 --> 00:13:49,980
from clients that that are their window

00:13:47,520 --> 00:13:51,660
content it knows how these textures are

00:13:49,980 --> 00:13:53,700
layered and he knows how to render that

00:13:51,660 --> 00:13:58,440
entire stack and present the complete

00:13:53,700 --> 00:14:00,480
desktop the applications do their

00:13:58,440 --> 00:14:02,670
rendering locally and don't talk to the

00:14:00,480 --> 00:14:04,950
X over in a renderer they just pass the

00:14:02,670 --> 00:14:06,630
buffer to the X server and the X server

00:14:04,950 --> 00:14:09,270
passes that offer to their compositor

00:14:06,630 --> 00:14:11,880
and then similar when the input come in

00:14:09,270 --> 00:14:14,220
the input comes in to the X so it gives

00:14:11,880 --> 00:14:15,899
it to the client and client update the

00:14:14,220 --> 00:14:21,420
the window accordingly and then we

00:14:15,899 --> 00:14:22,860
render pass it back to the server so

00:14:21,420 --> 00:14:23,880
what happens here is that the X server

00:14:22,860 --> 00:14:25,980
doesn't do much anymore

00:14:23,880 --> 00:14:27,540
it takes the input gives it to the

00:14:25,980 --> 00:14:29,730
client which is actually not the right

00:14:27,540 --> 00:14:30,930
model because since the X server

00:14:29,730 --> 00:14:33,390
technically doesn't know where the

00:14:30,930 --> 00:14:36,870
windows are on the screen the XR can't

00:14:33,390 --> 00:14:38,760
decide who's you get that event so the

00:14:36,870 --> 00:14:41,459
only thing that the XR what really does

00:14:38,760 --> 00:14:43,589
today is actually broken and everything

00:14:41,459 --> 00:14:45,089
else is something where we could instead

00:14:43,589 --> 00:14:48,000
of having X in the middle we could hook

00:14:45,089 --> 00:14:51,260
up the the application directly to the

00:14:48,000 --> 00:14:54,870
compositor and that's what Waylon does

00:14:51,260 --> 00:14:57,149
we make the composite to the display

00:14:54,870 --> 00:14:58,620
server and the Braylon protocol is

00:14:57,149 --> 00:15:01,140
essentially a communication channel

00:14:58,620 --> 00:15:03,270
between the compositor and the clients

00:15:01,140 --> 00:15:04,920
that lets the compositor send input

00:15:03,270 --> 00:15:07,170
events to the clients and the clients

00:15:04,920 --> 00:15:10,410
will then update their buffers and send

00:15:07,170 --> 00:15:12,990
the new buffer back to Wayland so it

00:15:10,410 --> 00:15:15,540
it's a it's a much smaller protocol is

00:15:12,990 --> 00:15:17,280
there much simpler model than X we have

00:15:15,540 --> 00:15:19,560
don't have a rendering API we don't have

00:15:17,280 --> 00:15:22,260
fund rendering we don't have the front

00:15:19,560 --> 00:15:25,740
management we we don't have all their

00:15:22,260 --> 00:15:29,160
this up windows that you used to have to

00:15:25,740 --> 00:15:31,440
help rendering and it's a tiny protocol

00:15:29,160 --> 00:15:43,590
and it works because we're not really

00:15:31,440 --> 00:15:45,150
using most of X anymore yes so that says

00:15:43,590 --> 00:15:47,250
for like I said the state today is said

00:15:45,150 --> 00:15:51,090
that we split out all the hard parts of

00:15:47,250 --> 00:15:53,220
X and the X service is essentially as

00:15:51,090 --> 00:15:59,790
their mediator or a middleman between

00:15:53,220 --> 00:16:01,740
apps and the compositor and the only the

00:15:59,790 --> 00:16:04,710
only point where we still use X for

00:16:01,740 --> 00:16:07,230
thing is C for something is the input

00:16:04,710 --> 00:16:14,520
which should go through the compositor

00:16:07,230 --> 00:16:16,620
as well so that that's that's the set up

00:16:14,520 --> 00:16:18,870
that's that's what makes really

00:16:16,620 --> 00:16:22,950
impossible but how is it feasible how

00:16:18,870 --> 00:16:24,960
can actually pull this off and again the

00:16:22,950 --> 00:16:26,490
the thing is the way we split out all

00:16:24,960 --> 00:16:29,130
the functionality of the x-ray ver makes

00:16:26,490 --> 00:16:31,050
it be usable in different ways so the

00:16:29,130 --> 00:16:33,150
the kernel mode setting that lets us

00:16:31,050 --> 00:16:36,000
configure the output and do paid

00:16:33,150 --> 00:16:38,310
flipping and setup overlay planes is is

00:16:36,000 --> 00:16:41,430
available for 40 internal use so we can

00:16:38,310 --> 00:16:43,410
use the compositor can use this mostly

00:16:41,430 --> 00:16:49,110
in library to control is the screens

00:16:43,410 --> 00:16:50,820
multi hit and page flipping and we can

00:16:49,110 --> 00:16:53,250
we can go to deride driver the same

00:16:50,820 --> 00:16:55,490
drivers that we use under X for 3d are

00:16:53,250 --> 00:16:58,560
available as ETL drivers now so we can

00:16:55,490 --> 00:17:00,930
load those drivers we can configure them

00:16:58,560 --> 00:17:02,400
to render to the frame buffer to the the

00:17:00,930 --> 00:17:04,410
kernel also in frame buffer that we're

00:17:02,400 --> 00:17:06,540
using and then what we have at that

00:17:04,410 --> 00:17:09,689
point is we have accelerated Jill is 2

00:17:06,540 --> 00:17:11,040
on the Linux frame buffer so that that

00:17:09,689 --> 00:17:15,199
basically takes care of all the hardware

00:17:11,040 --> 00:17:17,730
and we read input from evey dev devices

00:17:15,199 --> 00:17:19,140
so that that that covers all the

00:17:17,730 --> 00:17:21,990
hardware interaction that a display

00:17:19,140 --> 00:17:24,089
server needs to do we have API as for

00:17:21,990 --> 00:17:26,459
this and then not just API

00:17:24,089 --> 00:17:28,230
but API is that we also using 4x so

00:17:26,459 --> 00:17:30,659
we're using the same drivers that the

00:17:28,230 --> 00:17:34,200
driver community the driver developers

00:17:30,659 --> 00:17:34,799
that works in Mesa and and even if they

00:17:34,200 --> 00:17:37,380
can

00:17:34,799 --> 00:17:39,090
Akane hence and improve the stack as

00:17:37,380 --> 00:17:42,510
they go and the benefits both Whalen and

00:17:39,090 --> 00:17:44,220
and X and we're not splitting we're not

00:17:42,510 --> 00:17:47,159
saying you have to right way and

00:17:44,220 --> 00:17:51,029
specific in for drivers and at the same

00:17:47,159 --> 00:17:53,450
time the the way a way line compositor

00:17:51,029 --> 00:17:55,440
doesn't have to have Hardware specific

00:17:53,450 --> 00:17:57,059
code test we don't do something

00:17:55,440 --> 00:17:58,380
different for this chipset and there's

00:17:57,059 --> 00:18:01,039
something else for that chip said it's

00:17:58,380 --> 00:18:04,770
all egl we talk to ETL which is

00:18:01,039 --> 00:18:10,320
cross-platform and cross chipset API for

00:18:04,770 --> 00:18:12,149
doing 3d rendering and then we're able

00:18:10,320 --> 00:18:14,220
to actually write a display server that

00:18:12,149 --> 00:18:15,840
doesn't have any hardware specifics he

00:18:14,220 --> 00:18:27,299
doesn't have to load drivers it just

00:18:15,840 --> 00:18:29,159
uses deal yes - so what what kind of

00:18:27,299 --> 00:18:32,309
compositors would we be using or do we

00:18:29,159 --> 00:18:34,649
use with Wayland and there are basically

00:18:32,309 --> 00:18:37,279
two two approaches here you can write

00:18:34,649 --> 00:18:40,799
one from scratch that's just in a

00:18:37,279 --> 00:18:42,840
whaling this compositor and nothing else

00:18:40,799 --> 00:18:44,520
and that's actually what I'm using here

00:18:42,840 --> 00:18:48,299
their presentation and everything here

00:18:44,520 --> 00:18:51,029
is running under their reference whaling

00:18:48,299 --> 00:18:55,169
compositor this this is the Western a

00:18:51,029 --> 00:18:56,940
compositor and then it is it is a really

00:18:55,169 --> 00:19:00,559
small project it's ten thousand lines of

00:18:56,940 --> 00:19:04,529
code and it does motor setting it does

00:19:00,559 --> 00:19:07,010
handling the events it has there we can

00:19:04,529 --> 00:19:07,010
have a look here

00:19:08,360 --> 00:19:14,419
so here's the presentation application

00:19:11,730 --> 00:19:14,419
and iran's

00:19:21,450 --> 00:19:34,379
ron's application here's a normal system

00:19:23,889 --> 00:19:40,480
monitor this is him gnome terminal and

00:19:34,379 --> 00:19:42,789
there is calculator so it's it's ten

00:19:40,480 --> 00:19:45,850
thousand lines of code that lets you run

00:19:42,789 --> 00:19:49,840
like a compositing display server window

00:19:45,850 --> 00:19:51,129
manager and it's it is quite usable but

00:19:49,840 --> 00:19:52,840
at the same time it's not a

00:19:51,129 --> 00:19:55,210
full-featured window manner as we know

00:19:52,840 --> 00:19:58,450
it from X it's not doesn't handle on the

00:19:55,210 --> 00:20:00,340
key bindings it doesn't just integrate

00:19:58,450 --> 00:20:02,679
with apps in the same way and it is in

00:20:00,340 --> 00:20:05,019
many ways sir it is it is a reference

00:20:02,679 --> 00:20:08,980
implementation but it's also useful on

00:20:05,019 --> 00:20:10,990
its own depending on what you're trying

00:20:08,980 --> 00:20:18,249
to build Western is a good choice for

00:20:10,990 --> 00:20:20,830
for for you for your system it if you're

00:20:18,249 --> 00:20:22,840
building a mobile device where you don't

00:20:20,830 --> 00:20:24,340
have a lot of legacy X application you

00:20:22,840 --> 00:20:25,899
want to pull in you could base it on

00:20:24,340 --> 00:20:27,490
Western you could say here's Western

00:20:25,899 --> 00:20:31,960
these are the toolkits and you could

00:20:27,490 --> 00:20:34,299
build your own and desktop or mobile UX

00:20:31,960 --> 00:20:37,419
are you using interface on top of that

00:20:34,299 --> 00:20:39,580
but for the existing X desktop

00:20:37,419 --> 00:20:41,950
environments and more likely past it's

00:20:39,580 --> 00:20:43,929
probably to take the compositor that

00:20:41,950 --> 00:20:45,999
those environments you use and then

00:20:43,929 --> 00:20:50,710
enhance them to also be whale and

00:20:45,999 --> 00:20:54,490
compositors so for example for for gnome

00:20:50,710 --> 00:20:58,019
3 which uses the Met acidity and clora

00:20:54,490 --> 00:20:59,980
based compositor we could add and

00:20:58,019 --> 00:21:02,619
massage which made a compositing

00:20:59,980 --> 00:21:05,409
functionalities that one and then we can

00:21:02,619 --> 00:21:07,720
run a mix of X and wavelength clients

00:21:05,409 --> 00:21:09,340
and over time we can fade out face out

00:21:07,720 --> 00:21:12,490
the X clients and eventually get to a

00:21:09,340 --> 00:21:15,970
point where we run in native Wayland

00:21:12,490 --> 00:21:20,350
clients and there is a we have a talk

00:21:15,970 --> 00:21:23,610
about this in the X developer room in we

00:21:20,350 --> 00:21:27,700
have a that's a X developer room in

00:21:23,610 --> 00:21:29,059
building I forget what building is in

00:21:27,700 --> 00:21:31,699
but

00:21:29,059 --> 00:21:35,509
upstairs oh yeah it is okay yeah and

00:21:31,699 --> 00:21:37,609
it's good so Robert Brack is they gonna

00:21:35,509 --> 00:21:40,639
talk about his work on her mother there

00:21:37,609 --> 00:21:42,559
and he's got a fancy demo of a model

00:21:40,639 --> 00:21:44,479
that that heals your wolf and I forgot

00:21:42,559 --> 00:21:48,169
to mention that there's also a talk

00:21:44,479 --> 00:21:50,149
about how kms and the new Kamath sprite

00:21:48,169 --> 00:21:54,829
feature is gonna work with Western and

00:21:50,149 --> 00:21:56,569
ESC Barnes is gonna talk about that so

00:21:54,829 --> 00:21:58,909
this and this is actually ties into a

00:21:56,569 --> 00:22:00,939
good point that since the compositor now

00:21:58,909 --> 00:22:02,929
is in charge of motor sitting and

00:22:00,939 --> 00:22:05,239
controlling their overlays and planes

00:22:02,929 --> 00:22:07,459
that that happen we don't need a lot of

00:22:05,239 --> 00:22:09,439
complex protocol to tell the compositor

00:22:07,459 --> 00:22:12,169
to that I want to use an overlay plane I

00:22:09,439 --> 00:22:14,869
want to use this the compositor is on

00:22:12,169 --> 00:22:16,549
one hand has all the surfaces that we

00:22:14,869 --> 00:22:18,529
need to show on the screen for having

00:22:16,549 --> 00:22:19,969
given any given frame come with

00:22:18,529 --> 00:22:21,559
compositor has all those surfaces in a

00:22:19,969 --> 00:22:23,959
big data structure and can look through

00:22:21,559 --> 00:22:27,589
that data structure and see this surface

00:22:23,959 --> 00:22:29,929
is suitable for a harbor cursor or this

00:22:27,589 --> 00:22:32,089
surface is and why you resurface that we

00:22:29,929 --> 00:22:35,599
can use that Hardware overlay plane to

00:22:32,089 --> 00:22:37,309
display so the capacitor is is in a

00:22:35,599 --> 00:22:38,779
position where it has on one hand all

00:22:37,309 --> 00:22:40,429
information about all surfaces on the

00:22:38,779 --> 00:22:42,079
screen and at the same time it knows

00:22:40,429 --> 00:22:44,749
what hardware it's running on and can

00:22:42,079 --> 00:22:46,819
know how can use that Hardware can our

00:22:44,749 --> 00:22:48,859
hopper to accelerate display of this

00:22:46,819 --> 00:22:50,599
surface day so if you want to use a

00:22:48,859 --> 00:22:53,179
hardware overlay to the player while you

00:22:50,599 --> 00:22:55,879
resurface or even in an ard be over

00:22:53,179 --> 00:22:58,609
later accelerate the rendering of the

00:22:55,879 --> 00:23:01,569
current folk active application that's

00:22:58,609 --> 00:23:04,069
all possible so there's a lot more

00:23:01,569 --> 00:23:06,409
possibilities for organization when you

00:23:04,069 --> 00:23:07,939
when you have both this is the surface

00:23:06,409 --> 00:23:10,099
that you want to display and their

00:23:07,939 --> 00:23:11,989
hardware that's gonna going to display

00:23:10,099 --> 00:23:20,479
in the same process and you can you can

00:23:11,989 --> 00:23:23,329
look through and start optimizing so the

00:23:20,479 --> 00:23:25,459
other side of Wayland and is the client

00:23:23,329 --> 00:23:27,409
side and when we switched display

00:23:25,459 --> 00:23:29,539
servers the one question is what do we

00:23:27,409 --> 00:23:31,909
do with the drivers and and their

00:23:29,539 --> 00:23:34,009
servers how do we move those over to the

00:23:31,909 --> 00:23:35,749
new system D the other side of the

00:23:34,009 --> 00:23:37,819
question is how do we what do we do with

00:23:35,749 --> 00:23:39,409
the clients that we have now because we

00:23:37,819 --> 00:23:42,109
have a lot of clients on the X we have

00:23:39,409 --> 00:23:42,720
desktop environments we have toolkits we

00:23:42,109 --> 00:23:44,700
have a lot of

00:23:42,720 --> 00:23:46,110
functionality that we just can't throw

00:23:44,700 --> 00:23:48,000
away we have to have some kind of

00:23:46,110 --> 00:23:52,050
migration path where we can pull it over

00:23:48,000 --> 00:23:57,270
without too much effort and it turns out

00:23:52,050 --> 00:23:59,610
that most applications and most UI most

00:23:57,270 --> 00:24:02,670
desktop environment we have all use

00:23:59,610 --> 00:24:05,010
toolkits nobody today talks directly to

00:24:02,670 --> 00:24:06,870
the X server if you want to draw a

00:24:05,010 --> 00:24:08,430
window with buttons and scroll bars you

00:24:06,870 --> 00:24:10,560
go to cute

00:24:08,430 --> 00:24:12,570
you go to gzk you go to e FL you go to

00:24:10,560 --> 00:24:14,220
one of the the tool kits out there that

00:24:12,570 --> 00:24:15,450
that makes it easy and you put the

00:24:14,220 --> 00:24:17,610
scroll bar and there's buttons where you

00:24:15,450 --> 00:24:21,540
want them and most of the time you don't

00:24:17,610 --> 00:24:23,490
even know you're running on the X so it

00:24:21,540 --> 00:24:28,640
turns out that we can get really far

00:24:23,490 --> 00:24:28,640
towards getting the client side of our

00:24:28,940 --> 00:24:33,120
graphics architecture running our

00:24:31,020 --> 00:24:35,610
wayland by just pouring the tool kits

00:24:33,120 --> 00:24:38,640
and we we have started this effort

00:24:35,610 --> 00:24:41,610
already we worked on TD case three we

00:24:38,640 --> 00:24:45,120
worked on cute and we work we didn't

00:24:41,610 --> 00:24:46,620
work on EFL the and Carsten and his

00:24:45,120 --> 00:24:48,410
minions started working on that and they

00:24:46,620 --> 00:25:06,440
made a lot of progress already

00:24:48,410 --> 00:25:06,440
and then what if you done all right

00:25:28,870 --> 00:25:33,440
yeah

00:25:30,110 --> 00:25:36,710
so enlightenment is a long way there is

00:25:33,440 --> 00:25:38,510
a Whelan compositor EFL is their dles

00:25:36,710 --> 00:25:40,820
two works shared memory still has work

00:25:38,510 --> 00:25:42,590
to be done but a lot of progress is made

00:25:40,820 --> 00:25:44,810
there and it hasn't it been more than a

00:25:42,590 --> 00:25:47,420
fair a few months since you really

00:25:44,810 --> 00:25:50,420
started working on it two months and and

00:25:47,420 --> 00:25:51,920
um and again because a lot of the

00:25:50,420 --> 00:25:53,990
infrastructure is already moved

00:25:51,920 --> 00:25:55,550
client-side we're not changing the way

00:25:53,990 --> 00:25:57,170
we render fonts we're still using free

00:25:55,550 --> 00:26:01,190
type or font conflict we're not changing

00:25:57,170 --> 00:26:03,170
the way we M we use OpenGL so so what

00:26:01,190 --> 00:26:08,870
it's a lot of the pouring effort is is

00:26:03,170 --> 00:26:10,130
isn't too hard it is we do TK 3

00:26:08,870 --> 00:26:13,340
something that I've been working on

00:26:10,130 --> 00:26:14,630
myself and it's a big old toolkit so

00:26:13,340 --> 00:26:16,760
there's a little more effort in in

00:26:14,630 --> 00:26:18,800
moving it around but hope fortunately a

00:26:16,760 --> 00:26:21,950
lot of the community people that work on

00:26:18,800 --> 00:26:24,670
gtk has been the redhead guys have done

00:26:21,950 --> 00:26:27,020
a lot of work where they dependent on

00:26:24,670 --> 00:26:30,170
subsurface up Windows that I talked

00:26:27,020 --> 00:26:32,480
about before is removed the use of the X

00:26:30,170 --> 00:26:36,950
rendering API has gone so they all use

00:26:32,480 --> 00:26:43,340
Kyra now so gtk works very well on run

00:26:36,950 --> 00:26:45,890
waiting as well and I think the claw

00:26:43,340 --> 00:26:49,040
report is mostly complete crawlers also

00:26:45,890 --> 00:26:51,050
is a very small toolkit so so that

00:26:49,040 --> 00:26:54,520
that's something that could be done and

00:26:51,050 --> 00:26:57,500
without too much effort as well in them

00:26:54,520 --> 00:26:59,120
that there are a few common challenges

00:26:57,500 --> 00:27:02,210
or themes that come up when you look at

00:26:59,120 --> 00:27:05,930
porting a tool key from for makes to

00:27:02,210 --> 00:27:07,520
whaling and falling away from X

00:27:05,930 --> 00:27:08,720
rendering is something that most tool

00:27:07,520 --> 00:27:10,760
kids have done there's not a lot of

00:27:08,720 --> 00:27:12,650
toolkit out there that use X directly

00:27:10,760 --> 00:27:15,050
now they all have some kind of internal

00:27:12,650 --> 00:27:17,990
abstraction that lets you render to a

00:27:15,050 --> 00:27:22,430
different API or maybe they're using GL

00:27:17,990 --> 00:27:25,070
es to regular GL or maybe they're using

00:27:22,430 --> 00:27:27,170
Cairo so a lot of the X dependency in

00:27:25,070 --> 00:27:30,950
the rendering pipeline is gone and we

00:27:27,170 --> 00:27:32,500
don't have to have we don't have to make

00:27:30,950 --> 00:27:35,799
any changes there

00:27:32,500 --> 00:27:39,070
and a bigger challenges the client-side

00:27:35,799 --> 00:27:40,570
decorations where X today have a window

00:27:39,070 --> 00:27:44,679
manager that draws the decorations

00:27:40,570 --> 00:27:46,120
around the window we in Wayland expect

00:27:44,679 --> 00:27:49,480
the decline itself will provide a

00:27:46,120 --> 00:27:51,340
decorative window and so that that's

00:27:49,480 --> 00:27:53,110
that's a challenge for thought for some

00:27:51,340 --> 00:27:55,750
toolkit said that they don't expect this

00:27:53,110 --> 00:27:57,190
kind of redirection or extra orders to

00:27:55,750 --> 00:27:59,110
show off but it's something that can be

00:27:57,190 --> 00:28:03,340
worked around or fixed in one way or

00:27:59,110 --> 00:28:04,990
another and another big challenge is

00:28:03,340 --> 00:28:07,659
that Waylon doesn't have graphs and

00:28:04,990 --> 00:28:10,090
graphs is this feature in X where you

00:28:07,659 --> 00:28:11,950
can say I want all the keyboard events

00:28:10,090 --> 00:28:14,470
and all the mouse events right now and

00:28:11,950 --> 00:28:16,690
then nobody else gets those events if

00:28:14,470 --> 00:28:19,030
that climbs then falls asleep or

00:28:16,690 --> 00:28:21,070
something it's it it basically if your

00:28:19,030 --> 00:28:22,600
display server stuck and nobody else can

00:28:21,070 --> 00:28:25,240
you can click in other windows you can

00:28:22,600 --> 00:28:28,150
use the keyboard and and you basically

00:28:25,240 --> 00:28:29,620
stuck so Waylon doesn't have that

00:28:28,150 --> 00:28:32,860
feature and it turns out that we don't

00:28:29,620 --> 00:28:37,390
use that feature very often anymore and

00:28:32,860 --> 00:28:41,400
when we do we can we can we can change

00:28:37,390 --> 00:28:43,600
the display server to help out the the

00:28:41,400 --> 00:28:46,150
the only example that I've come across

00:28:43,600 --> 00:28:49,030
in folding various tool keys is pop-up

00:28:46,150 --> 00:28:52,539
menus when you click to pop up a menu

00:28:49,030 --> 00:28:54,220
you're gonna drop down menu and at that

00:28:52,539 --> 00:28:56,380
point most tool kids will grab the X

00:28:54,220 --> 00:28:57,909
server because they don't want you if

00:28:56,380 --> 00:29:00,130
you click outside that menu in somebody

00:28:57,909 --> 00:29:03,159
else's window they want to pop down that

00:29:00,130 --> 00:29:04,960
window and and make them in your go away

00:29:03,159 --> 00:29:06,730
and that that's one of the few places

00:29:04,960 --> 00:29:09,130
where a tool could still use graphs

00:29:06,730 --> 00:29:10,690
today and there's the solution that

00:29:09,130 --> 00:29:12,970
we've come up with is that we can just

00:29:10,690 --> 00:29:16,780
tell the compositor that this window is

00:29:12,970 --> 00:29:20,380
a pop-up window so please and change the

00:29:16,780 --> 00:29:22,059
input delivery path to work like that

00:29:20,380 --> 00:29:24,970
while that window is visible and when

00:29:22,059 --> 00:29:27,700
that window goes away either by clicking

00:29:24,970 --> 00:29:29,380
outside or if the way is the application

00:29:27,700 --> 00:29:31,419
closes it we're back to normal

00:29:29,380 --> 00:29:33,370
so there's no way you can get stuck with

00:29:31,419 --> 00:29:36,580
a graph where all info goes to one app

00:29:33,370 --> 00:29:38,350
that's not responding but it doesn't

00:29:36,580 --> 00:29:39,610
mean that we have to we have to look

00:29:38,350 --> 00:29:41,770
through the toolkits and make sure that

00:29:39,610 --> 00:29:43,870
when they pop up as popup window they do

00:29:41,770 --> 00:29:46,180
it with the right way and get their

00:29:43,870 --> 00:29:50,120
input processing right

00:29:46,180 --> 00:29:52,910
and another big difference that's that's

00:29:50,120 --> 00:29:54,440
challenging in some cases is wayna never

00:29:52,910 --> 00:29:57,590
tells you where on the screen your

00:29:54,440 --> 00:29:59,990
window is and this sounds weird but it's

00:29:57,590 --> 00:30:02,059
one of those things that in X prevent us

00:29:59,990 --> 00:30:05,030
from ever doing input redirection

00:30:02,059 --> 00:30:06,950
correctly so when the compositor mate

00:30:05,030 --> 00:30:09,170
rotates or scales down the window puts

00:30:06,950 --> 00:30:12,290
it over here the Xserve I can't cope

00:30:09,170 --> 00:30:14,630
with that because we use an X and X

00:30:12,290 --> 00:30:16,820
compositors we still rely on X for

00:30:14,630 --> 00:30:19,100
delivering input events but when the

00:30:16,820 --> 00:30:21,650
window is rotated and off to the side so

00:30:19,100 --> 00:30:23,780
the X server cannot represent that

00:30:21,650 --> 00:30:25,070
transformation it cannot take that into

00:30:23,780 --> 00:30:32,330
account when it looks for the window to

00:30:25,070 --> 00:30:35,750
receive their event and so we fix that

00:30:32,330 --> 00:30:38,000
in Wayland by having the compositor

00:30:35,750 --> 00:30:40,100
receive the event from the hardware and

00:30:38,000 --> 00:30:41,870
then because the compositor knows how it

00:30:40,100 --> 00:30:44,030
transformed or move the surface around

00:30:41,870 --> 00:30:48,500
the compositor also has to know how to

00:30:44,030 --> 00:30:50,570
find that surface and tell the client

00:30:48,500 --> 00:30:54,800
what is the location of that click

00:30:50,570 --> 00:30:56,480
within your surface and so that's all

00:30:54,800 --> 00:30:57,230
good but the problem is that once we go

00:30:56,480 --> 00:30:59,330
to that model

00:30:57,230 --> 00:31:01,190
we can't just tell the client this is

00:30:59,330 --> 00:31:02,870
where you are on the screen because we

00:31:01,190 --> 00:31:05,720
can't communicate that transformation it

00:31:02,870 --> 00:31:07,670
could be that the window was bent or put

00:31:05,720 --> 00:31:09,140
around a sphere or something so it could

00:31:07,670 --> 00:31:11,300
be anything you can think of so we

00:31:09,140 --> 00:31:13,580
cannot communicate that to the client so

00:31:11,300 --> 00:31:17,450
the client can know where it is on the

00:31:13,580 --> 00:31:18,800
screen and then that it works mostly but

00:31:17,450 --> 00:31:20,720
some of the things we run into is that

00:31:18,800 --> 00:31:22,040
some clients want to know when they're

00:31:20,720 --> 00:31:23,990
on the screen when they pop up their

00:31:22,040 --> 00:31:26,840
menus so that the manor doesn't go out

00:31:23,990 --> 00:31:28,880
over the screen X and there are few

00:31:26,840 --> 00:31:30,140
corner cases where the assumption that

00:31:28,880 --> 00:31:34,750
you know where you're on the screen

00:31:30,140 --> 00:31:37,750
breaks placement or other geometry

00:31:34,750 --> 00:31:37,750
problems

00:31:46,970 --> 00:31:54,240
yeah what happens when we want to put X

00:31:50,670 --> 00:31:56,790
on our vine on top of whaling where a

00:31:54,240 --> 00:31:58,950
client in the X Server expects that you

00:31:56,790 --> 00:32:00,600
can look at the screen geometry and see

00:31:58,950 --> 00:32:04,170
where it is and then place the windows

00:32:00,600 --> 00:32:06,270
accordingly and the one thing is we can

00:32:04,170 --> 00:32:09,600
let the X server know where the windows

00:32:06,270 --> 00:32:11,550
are and that will that will break pop-up

00:32:09,600 --> 00:32:14,280
minions in some ways because we can't

00:32:11,550 --> 00:32:16,170
pop up windows correctly if if the if

00:32:14,280 --> 00:32:17,730
the application really is rotated over

00:32:16,170 --> 00:32:19,380
in the corner we can't tell the extra

00:32:17,730 --> 00:32:21,990
with that and then when the extra pops

00:32:19,380 --> 00:32:24,030
up the window it's gonna break the other

00:32:21,990 --> 00:32:25,470
things is that we can also we can just

00:32:24,030 --> 00:32:26,610
not tell the X server about it which

00:32:25,470 --> 00:32:28,500
means that it's gonna break in some

00:32:26,610 --> 00:32:30,900
other cases though there are some

00:32:28,500 --> 00:32:33,120
integration issues where we may or may

00:32:30,900 --> 00:32:35,730
not be able to get the exact same

00:32:33,120 --> 00:32:41,940
behavior as you expect from mine or from

00:32:35,730 --> 00:32:45,480
X and and the question is can we can we

00:32:41,940 --> 00:32:47,310
live with that or do we have to we have

00:32:45,480 --> 00:32:49,800
to work around them do some more work to

00:32:47,310 --> 00:32:51,780
work around I think but we will try for

00:32:49,800 --> 00:32:54,090
living with it and then see if it really

00:32:51,780 --> 00:32:56,760
is a big issue but we cannot we have the

00:32:54,090 --> 00:32:59,610
option of extending the protocol or but

00:32:56,760 --> 00:33:01,170
it does it doesn't really break the idea

00:32:59,610 --> 00:33:03,180
in a major way if you start telling

00:33:01,170 --> 00:33:05,490
applications this is where you are this

00:33:03,180 --> 00:33:07,560
is how your transforms because you can't

00:33:05,490 --> 00:33:10,500
give clients that assumptions you can't

00:33:07,560 --> 00:33:13,910
have clients knowing where they are

00:33:10,500 --> 00:33:13,910
because they can't know

00:33:20,640 --> 00:33:26,080
so the last point here is that aside

00:33:23,410 --> 00:33:29,350
from pouring the toolkit which will take

00:33:26,080 --> 00:33:31,480
care of a lot of apps there are still

00:33:29,350 --> 00:33:34,150
apps out there that go around the

00:33:31,480 --> 00:33:37,150
toolkit and get some ex specific API

00:33:34,150 --> 00:33:40,090
maybe you want to get talk to X render

00:33:37,150 --> 00:33:42,220
you want to talk to maybe you want to

00:33:40,090 --> 00:33:43,780
sit at window a property in the root

00:33:42,220 --> 00:33:46,180
window or you want to do something X

00:33:43,780 --> 00:33:47,920
Pacific and other apps do that there's

00:33:46,180 --> 00:33:50,380
and but haven't seen this when you

00:33:47,920 --> 00:33:52,750
weren't running a half like that assumes

00:33:50,380 --> 00:33:55,450
that it's running under X and it will

00:33:52,750 --> 00:33:57,940
cast some and window some object into

00:33:55,450 --> 00:34:00,370
this toolkit to an X specific object and

00:33:57,940 --> 00:34:02,500
that'll then crash so that the solution

00:34:00,370 --> 00:34:04,210
there that there's no silver bullet here

00:34:02,500 --> 00:34:07,270
we have to go through the FS and say

00:34:04,210 --> 00:34:09,610
this apps will unconditionally cast some

00:34:07,270 --> 00:34:11,020
object to an X specific object and you

00:34:09,610 --> 00:34:13,510
can't do that and we have to work around

00:34:11,020 --> 00:34:16,450
that on a per app basis so there there

00:34:13,510 --> 00:34:19,960
is some work to do there and it depends

00:34:16,450 --> 00:34:21,460
on how well you do your toolkit isolates

00:34:19,960 --> 00:34:23,320
you from the Windows systems some

00:34:21,460 --> 00:34:26,800
toolkits are pretty good about this cute

00:34:23,320 --> 00:34:29,020
for example we'll go goes a lot longer

00:34:26,800 --> 00:34:30,659
in this respect because cute has a

00:34:29,020 --> 00:34:32,620
longer tradition on running a different

00:34:30,659 --> 00:34:37,750
operating system different windows

00:34:32,620 --> 00:34:40,810
systems and and I think GT K for example

00:34:37,750 --> 00:34:43,870
has has a lot more cases where apps will

00:34:40,810 --> 00:34:45,730
go and access the X server or X specific

00:34:43,870 --> 00:34:47,950
behavior but it is just something that

00:34:45,730 --> 00:34:49,659
we have to I mean it hasn't been a

00:34:47,950 --> 00:34:51,820
problem before because you were always

00:34:49,659 --> 00:35:00,640
running on X but now there is some work

00:34:51,820 --> 00:35:02,620
to do in tracking down those excesses so

00:35:00,640 --> 00:35:04,180
when I guess I can't touch them for up

00:35:02,620 --> 00:35:06,640
on this before but the driver support

00:35:04,180 --> 00:35:09,550
side is is basically if you can run DRI

00:35:06,640 --> 00:35:14,430
2 with an open-source driver on your X

00:35:09,550 --> 00:35:17,230
server you can run while entering and

00:35:14,430 --> 00:35:19,840
what we've done is we've added a few

00:35:17,230 --> 00:35:23,620
extensions to mace that we own all the

00:35:19,840 --> 00:35:26,830
infrastructure for supporting an EDL on

00:35:23,620 --> 00:35:28,750
KMS and and in Whalen is is all part of

00:35:26,830 --> 00:35:32,010
Mesa expose this general infrastructure

00:35:28,750 --> 00:35:34,500
so when some somebody sits down and as

00:35:32,010 --> 00:35:36,900
for four new chipset or and you complete

00:35:34,500 --> 00:35:38,700
driver to Mesa chances are that it will

00:35:36,900 --> 00:35:40,290
just work with again because you don't

00:35:38,700 --> 00:35:41,850
have it's part of the witness report is

00:35:40,290 --> 00:35:44,060
part of the general infrastructure so

00:35:41,850 --> 00:35:46,530
adding a new driver into that framework

00:35:44,060 --> 00:35:53,760
automatically gives you weight and

00:35:46,530 --> 00:35:55,320
support and similar with the if you if

00:35:53,760 --> 00:35:58,080
you go and you add current motion

00:35:55,320 --> 00:35:59,910
support to your driver that's gonna work

00:35:58,080 --> 00:36:03,030
with the general-purpose current motion

00:35:59,910 --> 00:36:04,890
API so when Waylon goes to tries to do a

00:36:03,030 --> 00:36:06,420
motor sitting on your new chipset if

00:36:04,890 --> 00:36:08,970
that's supported with the current mode

00:36:06,420 --> 00:36:10,830
setting it's gonna work with railing so

00:36:08,970 --> 00:36:13,260
they requirement from Wayland up base

00:36:10,830 --> 00:36:17,700
are very similar to and an x-ray with

00:36:13,260 --> 00:36:19,440
DRI to and there's a SSL Mesa and the

00:36:17,700 --> 00:36:22,020
Linux kernel gives you all this out of

00:36:19,440 --> 00:36:25,050
the box for there the three big chipsets

00:36:22,020 --> 00:36:26,970
out there and people always ask about

00:36:25,050 --> 00:36:30,840
what about the binary drivers from other

00:36:26,970 --> 00:36:32,880
vendors and I I don't know and I can't

00:36:30,840 --> 00:36:36,360
speak for them so I don't know what

00:36:32,880 --> 00:36:38,550
planes are there but the one point about

00:36:36,360 --> 00:36:41,160
this is that we're not dependent on Mesa

00:36:38,550 --> 00:36:44,040
specifically we're not depending on kms

00:36:41,160 --> 00:36:45,540
specifically either we we can you can

00:36:44,040 --> 00:36:48,060
write a compositor that uses a different

00:36:45,540 --> 00:36:51,000
mode setting API and compositor uses a

00:36:48,060 --> 00:36:52,500
different eg else deck and you can get

00:36:51,000 --> 00:36:55,260
to the same point where we are today you

00:36:52,500 --> 00:37:02,910
can run the compositor on on that

00:36:55,260 --> 00:37:05,120
hardware without too many changes so

00:37:02,910 --> 00:37:05,120
when

00:37:06,289 --> 00:37:11,760
so one of the things is that when we've

00:37:10,170 --> 00:37:14,400
been working on Weiland for quite a

00:37:11,760 --> 00:37:16,049
while and then for a long time it's been

00:37:14,400 --> 00:37:17,940
a research project we've been breaking

00:37:16,049 --> 00:37:20,130
protocol we've been rewriting this and

00:37:17,940 --> 00:37:24,059
that and we've been refactoring taking

00:37:20,130 --> 00:37:25,559
something moving things around between

00:37:24,059 --> 00:37:27,630
different processes and trying to figure

00:37:25,559 --> 00:37:29,039
out how things do work but we're getting

00:37:27,630 --> 00:37:31,170
to a point now where we haven't really

00:37:29,039 --> 00:37:33,720
changed the protocol in fundamental ways

00:37:31,170 --> 00:37:38,039
for a long time we had the same API the

00:37:33,720 --> 00:37:39,630
same architecture the same a same model

00:37:38,039 --> 00:37:42,240
for how things work for a long time now

00:37:39,630 --> 00:37:44,940
and we've come a long way with porting

00:37:42,240 --> 00:37:47,730
toolkits we have a clutter

00:37:44,940 --> 00:37:49,890
EFL GDK cute they're all running on

00:37:47,730 --> 00:37:51,480
railing there's they're loose answer

00:37:49,890 --> 00:37:53,789
things to finish but they're so far

00:37:51,480 --> 00:37:55,650
along that we're pretty confident now

00:37:53,789 --> 00:37:57,720
that the model we have the protocol we

00:37:55,650 --> 00:37:59,640
have is something that we can push

00:37:57,720 --> 00:38:01,880
towards the one pardo release pretty

00:37:59,640 --> 00:38:01,880
soon

00:38:10,440 --> 00:38:21,690
yeah so the idea is that once we get to

00:38:16,680 --> 00:38:23,640
one photo we don't expect that we it's

00:38:21,690 --> 00:38:25,079
not it's not world domination we don't

00:38:23,640 --> 00:38:29,970
expect that every test about that will

00:38:25,079 --> 00:38:31,829
run on 1.0 what we do expect and what we

00:38:29,970 --> 00:38:33,599
want to stick me with the 1.0 release is

00:38:31,829 --> 00:38:35,640
that from this point now we're not gonna

00:38:33,599 --> 00:38:37,980
change the protocol in a way that breaks

00:38:35,640 --> 00:38:40,440
your toolkit we're not gonna change the

00:38:37,980 --> 00:38:41,700
API in a way that makes your toolkit and

00:38:40,440 --> 00:38:43,829
we've done this in the past we have to

00:38:41,700 --> 00:38:45,960
move things around in the protocol we

00:38:43,829 --> 00:38:48,240
have to drop interfaces we have to break

00:38:45,960 --> 00:38:51,420
interfaces and we played around a lot

00:38:48,240 --> 00:38:54,059
but we're getting ready to say that we

00:38:51,420 --> 00:38:57,329
can do a 1.0 and we can release

00:38:54,059 --> 00:38:59,940
something that we will only increment

00:38:57,329 --> 00:39:01,980
will only add functions will only add

00:38:59,940 --> 00:39:03,720
new interfaces and but we won't break

00:39:01,980 --> 00:39:07,260
anything anymore so we were getting

00:39:03,720 --> 00:39:08,940
ready to commit to the interface and to

00:39:07,260 --> 00:39:13,559
get there we have a couple of releases

00:39:08,940 --> 00:39:17,970
that we we're talking about we're gonna

00:39:13,559 --> 00:39:21,329
do a 0m 0.85 release soon to date

00:39:17,970 --> 00:39:23,309
perhaps and and the plan there is that

00:39:21,329 --> 00:39:25,680
this is a snapshot of what we have now

00:39:23,309 --> 00:39:27,390
it's not something that we we commit to

00:39:25,680 --> 00:39:29,220
we're not going to preset protocol now

00:39:27,390 --> 00:39:31,500
we know that we have Candice we need to

00:39:29,220 --> 00:39:33,390
make but we know what they are and we we

00:39:31,500 --> 00:39:37,740
confident that we can make them within

00:39:33,390 --> 00:39:40,529
the next half year once we get to that

00:39:37,740 --> 00:39:43,500
point we can we start doing the 0.9 C

00:39:40,529 --> 00:39:46,650
releases where we we call it the beta

00:39:43,500 --> 00:39:48,359
releases and from there on we really

00:39:46,650 --> 00:39:49,859
don't expect to change the protocol but

00:39:48,359 --> 00:39:53,099
we're not gonna rule it out it could

00:39:49,859 --> 00:39:57,720
happen but it still beta but we expect

00:39:53,099 --> 00:39:59,400
that from their honor we can and we can

00:39:57,720 --> 00:40:01,200
keep the protocol on an API frozen and

00:39:59,400 --> 00:40:09,039
then eventually we will do the 1.0

00:40:01,200 --> 00:40:12,979
release somewhere in 2012-13

00:40:09,039 --> 00:40:15,229
yeah and I don't know I mean we we have

00:40:12,979 --> 00:40:19,190
work to do between now and one photo and

00:40:15,229 --> 00:40:20,989
it's not trivial and if there is things

00:40:19,190 --> 00:40:23,150
that we need to move around but I do

00:40:20,989 --> 00:40:27,799
expect we can we can least get to beta

00:40:23,150 --> 00:40:30,140
release within 2012 and then I if we end

00:40:27,799 --> 00:40:38,119
up going into 2013 for the one fund oh

00:40:30,140 --> 00:40:39,920
it won't be far into 2013 yeah so this

00:40:38,119 --> 00:40:42,229
is just what I just said I guess

00:40:39,920 --> 00:40:44,420
elaborating the staff yeah the thing is

00:40:42,229 --> 00:40:47,900
Whalen as it is now is actually used in

00:40:44,420 --> 00:40:49,609
different projects that and I only know

00:40:47,900 --> 00:40:53,900
of a few of them I think it's out there

00:40:49,609 --> 00:40:56,119
being used by a lot of people so what

00:40:53,900 --> 00:40:58,249
we're doing with one point 0.85 is we're

00:40:56,119 --> 00:40:59,779
making a snapshot now because this is

00:40:58,249 --> 00:41:01,339
useful as it is we don't have move

00:40:59,779 --> 00:41:04,160
things around and we are big things but

00:41:01,339 --> 00:41:07,039
let's make it staple brains for what we

00:41:04,160 --> 00:41:09,890
have now we can maintain that in the fix

00:41:07,039 --> 00:41:12,799
box and keep that alive but at the same

00:41:09,890 --> 00:41:14,900
time we we are going to break the API

00:41:12,799 --> 00:41:17,359
and the protocol but we're making a

00:41:14,900 --> 00:41:19,249
snapshot because it is in use and then

00:41:17,359 --> 00:41:22,910
it makes sense to keep the current

00:41:19,249 --> 00:41:26,299
protocol stable and and have a stable

00:41:22,910 --> 00:41:30,589
release points for that so that that's

00:41:26,299 --> 00:41:32,239
the idea with 0.85 0 for 9 are the base

00:41:30,589 --> 00:41:35,450
beta releases and then at one point oh

00:41:32,239 --> 00:41:43,160
we we we commit to the protocol and say

00:41:35,450 --> 00:41:45,619
this is done okay so a quick recap of

00:41:43,160 --> 00:41:48,799
the the talks that we have going on we

00:41:45,619 --> 00:41:52,999
have in the EXO dev room they have their

00:41:48,799 --> 00:41:54,469
history room number k3 401 we have Rob's

00:41:52,999 --> 00:41:56,239
talked about writing a Wayland

00:41:54,469 --> 00:41:58,249
compositor he's gonna show off some of

00:41:56,239 --> 00:42:00,259
the moderate work is done we have

00:41:58,249 --> 00:42:03,079
Jesse's talk about claim support and how

00:42:00,259 --> 00:42:04,369
we can use this new sprite feature we

00:42:03,079 --> 00:42:06,410
have been some of the new Intel cubes

00:42:04,369 --> 00:42:08,239
that lets you put our surface in his own

00:42:06,410 --> 00:42:10,009
sprite hand and we can move that around

00:42:08,239 --> 00:42:13,069
without brief rendering the entire thing

00:42:10,009 --> 00:42:16,160
and then I have a Q&A session with

00:42:13,069 --> 00:42:17,989
robert bradford what we talked about

00:42:16,160 --> 00:42:20,089
some of the things we came across while

00:42:17,989 --> 00:42:22,279
porting gtk and we will

00:42:20,089 --> 00:42:27,430
via qa4 toolkit developer said

00:42:22,279 --> 00:42:48,709
interesting supporting whaling and

00:42:27,430 --> 00:42:50,719
Christians yeah yeah right so so games

00:42:48,709 --> 00:42:52,579
often grab windows and what do we do for

00:42:50,719 --> 00:42:54,349
games and the thing about games is they

00:42:52,579 --> 00:42:56,779
often grab the window because they want

00:42:54,349 --> 00:42:58,189
relative partner motion when you're when

00:42:56,779 --> 00:42:59,719
you're running around and Crake and

00:42:58,189 --> 00:43:01,069
you're running around the corner you you

00:42:59,719 --> 00:43:02,959
don't want your mouse to scroll out the

00:43:01,069 --> 00:43:04,729
window and stop sending events you want

00:43:02,959 --> 00:43:06,890
to keep receiving those relative instant

00:43:04,729 --> 00:43:08,509
what games often do they're on their

00:43:06,890 --> 00:43:10,039
exes that they grab the foreigner they

00:43:08,509 --> 00:43:12,019
move out the window if you get too far

00:43:10,039 --> 00:43:13,400
out of the window and you're my healer

00:43:12,019 --> 00:43:16,400
screen it's they walk the point of

00:43:13,400 --> 00:43:18,680
bagging so they they this really a hack

00:43:16,400 --> 00:43:21,049
to keep receiving those Mouse events so

00:43:18,680 --> 00:43:22,849
you don't end up hitting the screen it's

00:43:21,049 --> 00:43:25,309
where you wanted to turn around in in

00:43:22,849 --> 00:43:27,439
your first-person shooter so for that

00:43:25,309 --> 00:43:29,209
we're gonna go the same direction as X

00:43:27,439 --> 00:43:31,609
input are going where we can provide

00:43:29,209 --> 00:43:34,039
relative input events it may or may not

00:43:31,609 --> 00:43:35,719
be part of the one photo release but we

00:43:34,039 --> 00:43:37,699
do expect that it's something we can we

00:43:35,719 --> 00:43:41,749
can add on later without breaking

00:43:37,699 --> 00:43:43,759
anything and it is a PT we want to do

00:43:41,749 --> 00:43:46,579
but it's not something we want in one

00:43:43,759 --> 00:43:52,390
photo but it is under the rock map we're

00:43:46,579 --> 00:43:55,309
aware of that use case thanks Carly yes

00:43:52,390 --> 00:43:59,920
screensaver screen docking that's that's

00:43:55,309 --> 00:44:04,689
also something we we we talk about and

00:43:59,920 --> 00:44:10,429
whether we do it as as 1.0 or later is

00:44:04,689 --> 00:44:12,529
not decided but it will be a protocol

00:44:10,429 --> 00:44:15,829
extension yes and it's also something if

00:44:12,529 --> 00:44:17,749
you build your own UI EFL based UI on

00:44:15,829 --> 00:44:19,219
top of a and you can you can write you

00:44:17,749 --> 00:44:21,679
write your own compositor you write your

00:44:19,219 --> 00:44:23,539
own toolkit and you can put your own

00:44:21,679 --> 00:44:26,059
extension in that compositor and you can

00:44:23,539 --> 00:44:28,309
have your own screensaver as part of you

00:44:26,059 --> 00:44:29,599
your complete UI that talk to the

00:44:28,309 --> 00:44:31,519
compositor so we don't need to

00:44:29,599 --> 00:44:32,150
standardize every single thing we have

00:44:31,519 --> 00:44:32,680
an X today

00:44:32,150 --> 00:44:34,359
if

00:44:32,680 --> 00:44:36,640
you're tailoring your compositor and

00:44:34,359 --> 00:44:38,319
your core UI together you can you can

00:44:36,640 --> 00:44:48,910
add extensions hooptie this two

00:44:38,319 --> 00:44:50,710
components together okay right how does

00:44:48,910 --> 00:44:52,569
having a separate buffer per application

00:44:50,710 --> 00:44:54,670
affect the memory footprint and that's

00:44:52,569 --> 00:44:57,430
really it's really an inherent property

00:44:54,670 --> 00:44:59,200
of of going to a composited environment

00:44:57,430 --> 00:45:01,000
because every application has its own

00:44:59,200 --> 00:45:03,069
background buffer now but it's not a

00:45:01,000 --> 00:45:05,319
decision that Waylon makes we don't

00:45:03,069 --> 00:45:08,619
force this on you if you're using genome

00:45:05,319 --> 00:45:10,540
3 or K win or compass that's already the

00:45:08,619 --> 00:45:13,150
case we already have a separate buffer

00:45:10,540 --> 00:45:16,780
per window today the way we're just

00:45:13,150 --> 00:45:19,540
taking that model and making it the

00:45:16,780 --> 00:45:21,700
default model and with Wagner we do have

00:45:19,540 --> 00:45:23,020
the option of actually throwing away the

00:45:21,700 --> 00:45:26,140
back buffer if we have a window that's

00:45:23,020 --> 00:45:28,569
not visible on screen we can we can free

00:45:26,140 --> 00:45:30,760
that buffer and we can save trying to

00:45:28,569 --> 00:45:33,099
render it when we make it visible again

00:45:30,760 --> 00:45:34,950
so we do have a little more flexibility

00:45:33,099 --> 00:45:37,630
and optimizing the memory use this here

00:45:34,950 --> 00:45:39,069
for family if you're on earth UI where

00:45:37,630 --> 00:45:41,260
you have inclusively full screen

00:45:39,069 --> 00:45:43,599
applications you can say when you switch

00:45:41,260 --> 00:45:45,819
from one F to the other every other F is

00:45:43,599 --> 00:45:47,710
no longer visible and you can ask those

00:45:45,819 --> 00:45:49,000
apps to throw away their backing buffers

00:45:47,710 --> 00:45:50,770
so if you're on a memory constrained

00:45:49,000 --> 00:45:52,990
mobile device you actually have more

00:45:50,770 --> 00:45:55,829
flexibility in controlling power users

00:45:52,990 --> 00:45:55,829
and you have with X

00:46:02,340 --> 00:46:06,580
remote remote desktop remote display

00:46:04,750 --> 00:46:09,100
this is something that always comes up

00:46:06,580 --> 00:46:10,660
in if the forints when you when I read

00:46:09,100 --> 00:46:12,540
comments about Weiland there's always

00:46:10,660 --> 00:46:14,800
two things a 10-7 frame or this

00:46:12,540 --> 00:46:17,770
client-side decorations and there is a

00:46:14,800 --> 00:46:19,810
remote desktop and the remote rendering

00:46:17,770 --> 00:46:21,310
feature of X is space and sending these

00:46:19,810 --> 00:46:22,600
rendering commands across the wire and

00:46:21,310 --> 00:46:25,180
then you can have a client on this

00:46:22,600 --> 00:46:27,369
machine showing on that machine and we

00:46:25,180 --> 00:46:28,600
can do that with wailing - it's um it's

00:46:27,369 --> 00:46:29,770
gonna be different then it's not gonna

00:46:28,600 --> 00:46:31,930
be rendering command to send across

00:46:29,770 --> 00:46:34,510
we're gonna send bitmaps and bitmap

00:46:31,930 --> 00:46:36,010
updates across and other people think

00:46:34,510 --> 00:46:39,550
that this is horribly inefficient but

00:46:36,010 --> 00:46:41,740
today you often can't render your UI

00:46:39,550 --> 00:46:44,200
without shifting and we're out of email

00:46:41,740 --> 00:46:46,780
just across the wire anyway and and it's

00:46:44,200 --> 00:46:48,190
also if inefficient in that if you do

00:46:46,780 --> 00:46:49,900
remote vendor and you offer end up with

00:46:48,190 --> 00:46:51,490
a lot of RAM chips to query the state of

00:46:49,900 --> 00:46:53,710
your rendering of your remote rendering

00:46:51,490 --> 00:46:55,510
API before you can even render but with

00:46:53,710 --> 00:46:57,160
Wayland you do all the rendering locally

00:46:55,510 --> 00:46:59,260
and once you're done you just push the

00:46:57,160 --> 00:47:01,720
result across the pipe as a compressed

00:46:59,260 --> 00:47:03,640
partial update of your window so it can

00:47:01,720 --> 00:47:05,710
be done really efficient and we can do

00:47:03,640 --> 00:47:08,320
it with native wavelength clients and

00:47:05,710 --> 00:47:10,030
it's it's gonna be amazing

00:47:08,320 --> 00:47:12,460
but we just don't have it as a priority

00:47:10,030 --> 00:47:13,600
right now it's it that there's nothing

00:47:12,460 --> 00:47:16,270
in the architecture that makes it

00:47:13,600 --> 00:47:18,010
impossible or even inefficient it's just

00:47:16,270 --> 00:47:19,810
not but the thing about if not being a

00:47:18,010 --> 00:47:21,400
priority is something they always people

00:47:19,810 --> 00:47:24,550
always let on to that if we somehow

00:47:21,400 --> 00:47:26,380
don't design it into the Windows system

00:47:24,550 --> 00:47:28,960
as its core feature we're never gonna

00:47:26,380 --> 00:47:32,520
get it right but we are gonna get it

00:47:28,960 --> 00:47:32,520
right it's just enough priority

00:47:40,750 --> 00:47:45,560
yeah so that does another question where

00:47:43,550 --> 00:47:47,210
are people from from X we're used to

00:47:45,560 --> 00:47:50,000
being able to customize your X desktop

00:47:47,210 --> 00:47:52,250
by using different window - some people

00:47:50,000 --> 00:47:54,500
like fluxbox awesome some people like

00:47:52,250 --> 00:47:56,380
chrome 3 and and there has always been a

00:47:54,500 --> 00:47:59,230
tradition of choice here where you can

00:47:56,380 --> 00:48:01,880
have the exact just of you want and

00:47:59,230 --> 00:48:07,160
that's a good question because with

00:48:01,880 --> 00:48:08,510
Whalen there is it and then barrier to

00:48:07,160 --> 00:48:09,890
entry is a little higher because you

00:48:08,510 --> 00:48:12,100
can't just write a window man you have

00:48:09,890 --> 00:48:15,770
to rewrite the entire windows system now

00:48:12,100 --> 00:48:17,930
but again the wisdom compositor I'm

00:48:15,770 --> 00:48:20,600
running here is ten thousand lines of

00:48:17,930 --> 00:48:22,280
code which is it's a lot of smaller

00:48:20,600 --> 00:48:24,500
windows many out there that are smaller

00:48:22,280 --> 00:48:27,050
but it is possible to say I'm we're

00:48:24,500 --> 00:48:28,910
gonna write our own Windows system my

00:48:27,050 --> 00:48:32,000
own weight and server and make that

00:48:28,910 --> 00:48:35,660
behave yes in tiling window menu or

00:48:32,000 --> 00:48:39,170
something okay the other option for

00:48:35,660 --> 00:48:40,520
there is it you can also make waster has

00:48:39,170 --> 00:48:43,550
a plug-in API you can write your own

00:48:40,520 --> 00:48:47,780
plugins to Western to implement the

00:48:43,550 --> 00:48:50,900
window manage behavior you like so that

00:48:47,780 --> 00:48:53,290
was the last question and I guess we're

00:48:50,900 --> 00:48:53,290

YouTube URL: https://www.youtube.com/watch?v=N5W69V2d-XM


