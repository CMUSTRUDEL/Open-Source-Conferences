Title: Implementing Domain Specific Languages with LLVM
Publication date: 2013-02-05
Playlist: FOSDEM 2012
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:01,100 --> 00:00:07,410
so I have my talk title was implementing

00:00:04,529 --> 00:00:08,820
domain-specific languages with LLVM so I

00:00:07,410 --> 00:00:09,929
thought maybe I should start by

00:00:08,820 --> 00:00:12,719
explaining what a domain-specific

00:00:09,929 --> 00:00:15,299
language is and this is kind of a fuzzy

00:00:12,719 --> 00:00:17,340
term I mean you have really very

00:00:15,299 --> 00:00:18,510
specific things the one that I haven't

00:00:17,340 --> 00:00:19,949
put on the slide which I should have

00:00:18,510 --> 00:00:22,410
done because we're actually looking at

00:00:19,949 --> 00:00:26,369
implementing it with LLVM in FreeBSD

00:00:22,410 --> 00:00:28,859
right now is firewall rules so you write

00:00:26,369 --> 00:00:30,929
firewall rules in this language that is

00:00:28,859 --> 00:00:34,680
just designed for things like pattern

00:00:30,929 --> 00:00:37,110
matching on IP addresses and your kernel

00:00:34,680 --> 00:00:40,940
will probably interpret them maybe have

00:00:37,110 --> 00:00:43,500
an ad hoc JIT compiler and you know

00:00:40,940 --> 00:00:45,120
these things crop up everywhere and

00:00:43,500 --> 00:00:47,460
maybe not where you'd think of them

00:00:45,120 --> 00:00:50,190
things like Emacs Lisp JavaScript

00:00:47,460 --> 00:00:51,840
they're obviously embedded languages and

00:00:50,190 --> 00:00:53,520
they're obviously programming languages

00:00:51,840 --> 00:00:55,410
but firewall rules they don't

00:00:53,520 --> 00:00:57,480
necessarily look like a programming

00:00:55,410 --> 00:00:59,539
language but actually they are and

00:00:57,480 --> 00:01:02,280
actually even get some quite big speed

00:00:59,539 --> 00:01:04,409
improvements by having a decent compiler

00:01:02,280 --> 00:01:09,600
attached to them and if you're looking

00:01:04,409 --> 00:01:12,360
at little embedded rotors then they come

00:01:09,600 --> 00:01:14,100
with maybe a 200 megahertz CPU and you

00:01:12,360 --> 00:01:17,490
want to connect them to Gigabit Ethernet

00:01:14,100 --> 00:01:20,850
and if you want to do even very simple

00:01:17,490 --> 00:01:23,700
firewall rules on every packet that

00:01:20,850 --> 00:01:25,590
comes in then in an interpreter you are

00:01:23,700 --> 00:01:29,189
spending a lot of your time just in

00:01:25,590 --> 00:01:31,619
switch statements doing crazy things and

00:01:29,189 --> 00:01:33,210
some of them are really specific to a

00:01:31,619 --> 00:01:37,079
particular use like the graphviz

00:01:33,210 --> 00:01:38,820
language for doing graph layouts that's

00:01:37,079 --> 00:01:41,040
maybe not one that you want to do a

00:01:38,820 --> 00:01:44,850
compiler for but it is a specific

00:01:41,040 --> 00:01:47,490
language and the unix unix standard

00:01:44,850 --> 00:01:49,680
systems come with two calculators that

00:01:47,490 --> 00:01:54,149
have their own little embedded languages

00:01:49,680 --> 00:01:55,200
a max is demonstrating this rule that

00:01:54,149 --> 00:01:57,450
there are two sorts of applications

00:01:55,200 --> 00:01:59,490
there are integrated development

00:01:57,450 --> 00:02:00,990
environments and there are things that

00:01:59,490 --> 00:02:03,460
aren't integrated development

00:02:00,990 --> 00:02:05,740
environments yet

00:02:03,460 --> 00:02:08,140
I'm not sure we're in this continuum

00:02:05,740 --> 00:02:12,190
emacs's but it's it's definitely getting

00:02:08,140 --> 00:02:14,620
to the formless stage and so what is LVM

00:02:12,190 --> 00:02:17,860
and how many people were here for Chris

00:02:14,620 --> 00:02:19,420
latinus keynote last year okay so you

00:02:17,860 --> 00:02:24,430
people can sleep for the next five

00:02:19,420 --> 00:02:26,260
minutes all of the most most people I

00:02:24,430 --> 00:02:28,959
guess if you think of LVM you'll think

00:02:26,260 --> 00:02:32,170
of clang and you'll think of olv and

00:02:28,959 --> 00:02:34,390
that's that GCC replacement right and

00:02:32,170 --> 00:02:38,500
this is maybe the most user visible

00:02:34,390 --> 00:02:40,630
Veche in a part of LLVM it is in

00:02:38,500 --> 00:02:44,290
combination with clang you can take C

00:02:40,630 --> 00:02:46,690
and C++ and Objective C code and you can

00:02:44,290 --> 00:02:48,730
compile it to native code and that's

00:02:46,690 --> 00:02:50,709
well it's something we all need to do

00:02:48,730 --> 00:02:52,870
but it's not actually a very interesting

00:02:50,709 --> 00:02:55,840
thing you take standard programming

00:02:52,870 --> 00:02:57,730
language you create object code we've

00:02:55,840 --> 00:03:00,450
kind of been doing that for the last 40

00:02:57,730 --> 00:03:03,040
years or so so we know how to do that

00:03:00,450 --> 00:03:05,110
but the useful thing about our VM is

00:03:03,040 --> 00:03:09,299
that it really has this very modular

00:03:05,110 --> 00:03:11,920
architecture so we have libraries for

00:03:09,299 --> 00:03:13,840
representing our VMs intermediate

00:03:11,920 --> 00:03:16,030
language which I'll talk about a lot in

00:03:13,840 --> 00:03:17,610
the next few slides we have languages

00:03:16,030 --> 00:03:20,709
for doing up to libraries for doing

00:03:17,610 --> 00:03:23,200
optimizations libraries for writing out

00:03:20,709 --> 00:03:27,030
assembly libraries for manipulating

00:03:23,200 --> 00:03:29,380
object code files and they're all all

00:03:27,030 --> 00:03:31,570
roughly independent there are things

00:03:29,380 --> 00:03:35,350
like the support library that all of the

00:03:31,570 --> 00:03:37,360
others use but mostly you can just pick

00:03:35,350 --> 00:03:39,840
and choose the bits you want so it's

00:03:37,360 --> 00:03:43,360
it's sort of Lego for compiler writers

00:03:39,840 --> 00:03:46,140
and this is great because lots of bits

00:03:43,360 --> 00:03:48,579
of writing a compiler are very tedious

00:03:46,140 --> 00:03:50,829
fortunately the people who write

00:03:48,579 --> 00:03:52,989
compilers disagree about which bits are

00:03:50,829 --> 00:03:55,690
tedious so all of the bits eventually

00:03:52,989 --> 00:03:58,000
get written but if you have an

00:03:55,690 --> 00:03:59,980
application I mean how many people in

00:03:58,000 --> 00:04:01,299
this room have written a compiler for

00:03:59,980 --> 00:04:06,370
anything other than a university

00:04:01,299 --> 00:04:10,060
assignment okay so maybe more than I was

00:04:06,370 --> 00:04:11,829
expecting but if you have a lang an

00:04:10,060 --> 00:04:14,540
application that has some embedded

00:04:11,829 --> 00:04:17,479
scripting facility typically you

00:04:14,540 --> 00:04:19,130
right a quick and dirty interpreter and

00:04:17,479 --> 00:04:22,370
then you'll get bored with it and think

00:04:19,130 --> 00:04:23,600
well okay it works moving on now going

00:04:22,370 --> 00:04:26,449
to do the that I actually find

00:04:23,600 --> 00:04:28,190
interesting and the point of this talk

00:04:26,449 --> 00:04:30,320
is to say really if you have an

00:04:28,190 --> 00:04:33,199
interpreter and you want to turn that

00:04:30,320 --> 00:04:37,940
into a compiler LLVM does all the bits

00:04:33,199 --> 00:04:40,040
that you don't want to do so a bit later

00:04:37,940 --> 00:04:42,380
I have a worked example that I'll go

00:04:40,040 --> 00:04:44,210
through and I put together a toy

00:04:42,380 --> 00:04:46,880
language in wrote an interpreter for it

00:04:44,210 --> 00:04:48,380
and a compiler and writing the parser

00:04:46,880 --> 00:04:51,229
talked me about today because I hate

00:04:48,380 --> 00:04:52,550
parsers writing the interpreter took an

00:04:51,229 --> 00:04:56,750
afternoon and write and the compiler

00:04:52,550 --> 00:04:59,510
took an hour so our VM really really is

00:04:56,750 --> 00:05:02,690
easy to use because it's so modular and

00:04:59,510 --> 00:05:05,150
it's designed to be extensible so the

00:05:02,690 --> 00:05:07,100
basic way you use our VM is you will

00:05:05,150 --> 00:05:09,919
create our VMs intermediate

00:05:07,100 --> 00:05:13,940
representation and then you will pass it

00:05:09,919 --> 00:05:16,070
off to LLVM and you will say do stuff

00:05:13,940 --> 00:05:18,620
with this and typically what you'll do

00:05:16,070 --> 00:05:20,229
is you'll have some support functions so

00:05:18,620 --> 00:05:22,580
if you have a bytecode interpreter

00:05:20,229 --> 00:05:26,090
you'll typically have a switch statement

00:05:22,580 --> 00:05:28,639
and for each byte code you will call out

00:05:26,090 --> 00:05:30,349
to a c function that handles that one of

00:05:28,639 --> 00:05:31,639
the easiest ways of using our VM if you

00:05:30,349 --> 00:05:34,099
have something like that is you just

00:05:31,639 --> 00:05:35,860
take all of those support functions you

00:05:34,099 --> 00:05:38,810
compile them with clang into bit code

00:05:35,860 --> 00:05:41,210
for your compiler you just take each of

00:05:38,810 --> 00:05:42,979
those byte codes and insert a call to

00:05:41,210 --> 00:05:44,690
this thing and then you say LLVM i've

00:05:42,979 --> 00:05:47,450
written some really really ugly ugly

00:05:44,690 --> 00:05:49,700
horrible slow code just inline

00:05:47,450 --> 00:05:54,110
everything and make it fast and it does

00:05:49,700 --> 00:05:58,599
and this is how apples GLSL and their

00:05:54,110 --> 00:06:02,750
OpenCL implementations work all of the

00:05:58,599 --> 00:06:04,880
non-trivial operations in GLSL are just

00:06:02,750 --> 00:06:06,260
written in C and they're the same C

00:06:04,880 --> 00:06:08,840
functions that they use in their

00:06:06,260 --> 00:06:13,550
interpreter and they just compile them

00:06:08,840 --> 00:06:15,500
12 vmi I using clang and then just emit

00:06:13,550 --> 00:06:19,789
calls to all of these functions very

00:06:15,500 --> 00:06:23,390
very simply in their compiling and just

00:06:19,789 --> 00:06:25,640
spitting them out so this is the typical

00:06:23,390 --> 00:06:26,950
thing that you'll start with and I guess

00:06:25,640 --> 00:06:28,090
if you have an exist

00:06:26,950 --> 00:06:30,160
in scripting language in your

00:06:28,090 --> 00:06:32,260
application or some embedded language

00:06:30,160 --> 00:06:35,380
you'll have a parser and it will create

00:06:32,260 --> 00:06:37,680
an abstract syntax tree and you'll then

00:06:35,380 --> 00:06:40,450
pass that over to an interpreter and

00:06:37,680 --> 00:06:45,280
maybe there'll be a bytecode stage in

00:06:40,450 --> 00:06:47,710
the middle but maybe not and the way you

00:06:45,280 --> 00:06:49,840
do this with a VM is rather than passing

00:06:47,710 --> 00:06:52,870
it to the interpreter you transform it

00:06:49,840 --> 00:06:54,550
into our VM IR and if it's a simple

00:06:52,870 --> 00:06:56,020
language then you can just pass it

00:06:54,550 --> 00:06:58,900
straight out to the just-in-time

00:06:56,020 --> 00:07:03,000
compiler and there's a poly black oh can

00:06:58,900 --> 00:07:08,680
we turn the volume down on me at all or

00:07:03,000 --> 00:07:10,240
no okay but you can also do more

00:07:08,680 --> 00:07:12,280
complicated things so you can have

00:07:10,240 --> 00:07:15,850
runtime support codes that you write in

00:07:12,280 --> 00:07:19,210
C or C++ you can compile that with clang

00:07:15,850 --> 00:07:20,920
you can then optimize that you can link

00:07:19,210 --> 00:07:24,160
that together with the code that you've

00:07:20,920 --> 00:07:26,410
generated from your new compiler it was

00:07:24,160 --> 00:07:29,050
the AL VM linker in the LLVM linker just

00:07:26,410 --> 00:07:30,730
combines bit code and once you've got

00:07:29,050 --> 00:07:33,970
the combined bit code you can then do

00:07:30,730 --> 00:07:35,740
things like inline the C stuff in the

00:07:33,970 --> 00:07:36,970
code from your language all the other

00:07:35,740 --> 00:07:38,470
way around and that's actually what

00:07:36,970 --> 00:07:42,670
we're going to do in the works example

00:07:38,470 --> 00:07:44,530
later and then you pass that up to the

00:07:42,670 --> 00:07:47,290
native linker and you can link that with

00:07:44,530 --> 00:07:49,030
other object code so you can also turn

00:07:47,290 --> 00:07:51,840
your embedded scripting language into a

00:07:49,030 --> 00:07:58,090
static compiler with LLVM quite easily

00:07:51,840 --> 00:07:59,740
so what is OPM's intermediate

00:07:58,090 --> 00:08:01,870
representation I've talked about this

00:07:59,740 --> 00:08:05,440
sort of waving my hands a lot so far

00:08:01,870 --> 00:08:07,330
that it's LLVM used to stand for

00:08:05,440 --> 00:08:09,370
low-level virtual machine but it's

00:08:07,330 --> 00:08:12,610
actually not very low-level or a virtual

00:08:09,370 --> 00:08:14,910
machine anymore so they they decided

00:08:12,610 --> 00:08:17,590
that this doesn't stand for anything now

00:08:14,910 --> 00:08:20,170
but the intermediate representation is a

00:08:17,590 --> 00:08:23,140
single static assignment unlimited

00:08:20,170 --> 00:08:25,720
register machine so how many people here

00:08:23,140 --> 00:08:30,580
don't know what since that single static

00:08:25,720 --> 00:08:32,110
assignment means okay so SSA form is

00:08:30,580 --> 00:08:33,190
something that compiler writers like

00:08:32,110 --> 00:08:37,140
because it makes a whole load of

00:08:33,190 --> 00:08:41,800
optimizations useful it basically means

00:08:37,140 --> 00:08:45,100
each of your registers in LLVM is only

00:08:41,800 --> 00:08:47,200
able to be assigned to once so in a

00:08:45,100 --> 00:08:50,050
function rather than having a variable

00:08:47,200 --> 00:08:51,190
where you assign a value to it and then

00:08:50,050 --> 00:08:53,440
you do something else and then you

00:08:51,190 --> 00:08:55,990
assign another value to it each of those

00:08:53,440 --> 00:09:00,820
assignments would create a new virtual

00:08:55,990 --> 00:09:02,710
variable and new LVM register our VM is

00:09:00,820 --> 00:09:04,630
actually not single static assignment on

00:09:02,710 --> 00:09:06,850
memory so you can totally cheat and not

00:09:04,630 --> 00:09:09,880
care that it's single static assignment

00:09:06,850 --> 00:09:11,740
and just write stuff out to memory read

00:09:09,880 --> 00:09:14,710
it back and then there's a pass that

00:09:11,740 --> 00:09:17,890
will undo that and create nice SSA form

00:09:14,710 --> 00:09:20,410
so although it is single static

00:09:17,890 --> 00:09:21,850
assignment you don't need to actually

00:09:20,410 --> 00:09:24,580
care about that which is quite nice

00:09:21,850 --> 00:09:26,320
there are three representations of this

00:09:24,580 --> 00:09:29,020
intermediate language there's a set of

00:09:26,320 --> 00:09:32,950
C++ classes and that's generally how

00:09:29,020 --> 00:09:35,200
you'll use vir in your own code there is

00:09:32,950 --> 00:09:37,060
a really dense bit code which is a

00:09:35,200 --> 00:09:41,350
binary representation and that's what

00:09:37,060 --> 00:09:44,290
you typically use for passing the IR

00:09:41,350 --> 00:09:46,360
between different tools if you're doing

00:09:44,290 --> 00:09:51,100
link time optimization your compiler

00:09:46,360 --> 00:09:53,740
will emit object code but in this bit

00:09:51,100 --> 00:09:56,110
code format and then your linker will

00:09:53,740 --> 00:09:58,660
optimize its more and combine it and

00:09:56,110 --> 00:10:00,460
there's also a human readable LVM

00:09:58,660 --> 00:10:03,370
assembly format and that's what I'll put

00:10:00,460 --> 00:10:08,260
on the slides because you can't read the

00:10:03,370 --> 00:10:10,720
bit code that would just be evil so when

00:10:08,260 --> 00:10:13,150
you want to start using this stuff you

00:10:10,720 --> 00:10:15,400
you need to understand more or less how

00:10:13,150 --> 00:10:20,200
the intermediate representation works

00:10:15,400 --> 00:10:23,890
and the basic unit of a VM IR is the

00:10:20,200 --> 00:10:26,800
module so a module is a compilation unit

00:10:23,890 --> 00:10:29,770
so in C or C++ that's what you get when

00:10:26,800 --> 00:10:31,840
you take a source code file you run it

00:10:29,770 --> 00:10:34,300
through the preprocessor and then you

00:10:31,840 --> 00:10:36,820
have a single preprocessor source file

00:10:34,300 --> 00:10:39,820
and that will then be turned into an LVN

00:10:36,820 --> 00:10:43,690
module by your compiler and where you

00:10:39,820 --> 00:10:45,610
draw the line between what goes into a

00:10:43,690 --> 00:10:48,160
single module is really language

00:10:45,610 --> 00:10:49,600
specific but it's basically a load of

00:10:48,160 --> 00:10:52,750
stuff that is compiled

00:10:49,600 --> 00:10:55,300
at the same time and optimizations will

00:10:52,750 --> 00:10:58,930
do things like interprocedural and now

00:10:55,300 --> 00:11:03,100
assists only on things in the same LLVM

00:10:58,930 --> 00:11:05,290
module and modules contain functions and

00:11:03,100 --> 00:11:07,360
I guess most people know what a function

00:11:05,290 --> 00:11:09,100
is it's a function in the C sense so

00:11:07,360 --> 00:11:12,759
it's a procedure not the function in the

00:11:09,100 --> 00:11:15,519
Pascal sense functions contain basic

00:11:12,759 --> 00:11:17,470
blocks and a basic block is a sequence

00:11:15,519 --> 00:11:19,420
of instructions with no flow control in

00:11:17,470 --> 00:11:21,930
it so it's a sequence of instructions

00:11:19,420 --> 00:11:24,970
which you executed one after the other

00:11:21,930 --> 00:11:26,769
and any flow control happens at the end

00:11:24,970 --> 00:11:27,490
of a basic block so if you have an if

00:11:26,769 --> 00:11:29,709
statement

00:11:27,490 --> 00:11:32,860
you'll get one basic block with the

00:11:29,709 --> 00:11:35,529
condition in it and then another basic

00:11:32,860 --> 00:11:37,750
block with the if body and you'll have a

00:11:35,529 --> 00:11:41,079
branch either going to that basic block

00:11:37,750 --> 00:11:43,600
or going to after that one and then yeah

00:11:41,079 --> 00:11:46,480
it all joins together and they sit

00:11:43,600 --> 00:11:49,300
blocks contain instructions and the

00:11:46,480 --> 00:11:51,160
whole LLVM instruction set is documented

00:11:49,300 --> 00:11:52,959
on the LVM website I'm not going to go

00:11:51,160 --> 00:11:56,259
through all of that because it would be

00:11:52,959 --> 00:12:00,880
tedious and take ages but it's it's more

00:11:56,259 --> 00:12:02,350
or less like a idealized form of any CPU

00:12:00,880 --> 00:12:04,660
architecture that you're likely to come

00:12:02,350 --> 00:12:06,490
across and so some of the things are

00:12:04,660 --> 00:12:08,439
abstracted a bit so you have this our

00:12:06,490 --> 00:12:10,779
core instruction which does exactly the

00:12:08,439 --> 00:12:13,630
same thing as the C library a lack of

00:12:10,779 --> 00:12:16,180
function it allocates a bit of stack

00:12:13,630 --> 00:12:19,750
space and on a real architecture you

00:12:16,180 --> 00:12:21,310
allocate a bit of stack space by you

00:12:19,750 --> 00:12:24,120
know bumping a frame pointer or

00:12:21,310 --> 00:12:27,009
something you but this is a really

00:12:24,120 --> 00:12:31,240
implementation specific thing so in the

00:12:27,009 --> 00:12:33,310
IR it's abstracted out slightly you have

00:12:31,240 --> 00:12:37,899
some things that really do map directly

00:12:33,310 --> 00:12:40,180
to CPU instructions so add and subtract

00:12:37,899 --> 00:12:41,920
and multiply and divide and actually

00:12:40,180 --> 00:12:47,199
some of these come in different variants

00:12:41,920 --> 00:12:48,670
like signed multiply sign divide and

00:12:47,199 --> 00:12:49,449
they'll have floating points and

00:12:48,670 --> 00:12:52,569
arithmetic

00:12:49,449 --> 00:12:54,339
floating point integer variants you have

00:12:52,569 --> 00:12:57,189
some flow control instructions and these

00:12:54,339 --> 00:13:03,510
are really like CPU flow control there's

00:12:57,189 --> 00:13:03,510
no loops in LVM ir it is just you have

00:13:03,980 --> 00:13:09,990
jump if true jump if false whatever this

00:13:07,350 --> 00:13:13,290
kind of thing you have a return and you

00:13:09,990 --> 00:13:16,800
have a call instruction invoke is a bit

00:13:13,290 --> 00:13:18,180
special invoke is basically a call but

00:13:16,800 --> 00:13:21,240
it's designed to interoperate with

00:13:18,180 --> 00:13:24,390
exception handling so a call always

00:13:21,240 --> 00:13:25,980
returns immediately after the call so

00:13:24,390 --> 00:13:27,630
you can put a call instruction in the

00:13:25,980 --> 00:13:30,270
middle of a basic block and that's fine

00:13:27,630 --> 00:13:32,310
and invoke instruction has to go at the

00:13:30,270 --> 00:13:34,170
end of a basic block because it will

00:13:32,310 --> 00:13:36,270
return to a different basic block

00:13:34,170 --> 00:13:38,250
depending on whether it returns normally

00:13:36,270 --> 00:13:40,440
or whether it throws an exception and

00:13:38,250 --> 00:13:42,210
I'm not going to talk at all about the

00:13:40,440 --> 00:13:44,670
exception representation of error in

00:13:42,210 --> 00:13:47,970
LLVM because that would be an entire our

00:13:44,670 --> 00:13:51,779
talk just by itself and most people

00:13:47,970 --> 00:13:53,520
would be asleep by the end of it oh and

00:13:51,779 --> 00:13:55,470
yeah it also provides some intrinsic

00:13:53,520 --> 00:13:59,460
functions and intrinsic functions are

00:13:55,470 --> 00:14:05,040
things that should map to a short

00:13:59,460 --> 00:14:07,350
sequence of CPU instructions but aren't

00:14:05,040 --> 00:14:11,790
quite instructions so atomic operations

00:14:07,350 --> 00:14:14,880
fall into this category and they will be

00:14:11,790 --> 00:14:19,880
on x86 they might be a lock prefixed ad

00:14:14,880 --> 00:14:23,790
or they might be on arm

00:14:19,880 --> 00:14:27,570
link load followed by an ad followed by

00:14:23,790 --> 00:14:29,070
o store conditional but lbm makes you

00:14:27,570 --> 00:14:31,640
not have to care about this kind of

00:14:29,070 --> 00:14:33,510
stuff unless you're writing a back-end

00:14:31,640 --> 00:14:34,950
so one of the things that kind of

00:14:33,510 --> 00:14:41,880
confuses people when they start working

00:14:34,950 --> 00:14:46,020
with LLVM is that registers are values

00:14:41,880 --> 00:14:48,930
in LLVM and so you have this LLVM value

00:14:46,020 --> 00:14:50,850
class which most of the instructions

00:14:48,930 --> 00:14:53,370
inherit from and when you can create an

00:14:50,850 --> 00:14:55,410
instruction you get something back which

00:14:53,370 --> 00:14:57,300
is the result of that instruction as

00:14:55,410 --> 00:15:01,200
well as representing that instruction so

00:14:57,300 --> 00:15:04,920
you can pass that to other functions I

00:15:01,200 --> 00:15:06,600
know some things don't return any value

00:15:04,920 --> 00:15:11,130
so a call to a function that returns

00:15:06,600 --> 00:15:13,440
void is just an instruction that then is

00:15:11,130 --> 00:15:15,209
a null value or it's technically a value

00:15:13,440 --> 00:15:17,690
of type void which means you can't do

00:15:15,209 --> 00:15:20,430
anything with it

00:15:17,690 --> 00:15:24,840
but yeah this this fact that

00:15:20,430 --> 00:15:27,030
instructions and registers are basically

00:15:24,840 --> 00:15:28,620
the same thing kind of confuses people a

00:15:27,030 --> 00:15:31,380
bit and I'll show you an example in a

00:15:28,620 --> 00:15:34,710
couple of slides of some LLVM IR and

00:15:31,380 --> 00:15:36,330
pointed some things in that basic blocks

00:15:34,710 --> 00:15:37,800
I'm not really going to talk about fly

00:15:36,330 --> 00:15:39,450
instructions very much they're an

00:15:37,800 --> 00:15:41,960
artifact of this single static

00:15:39,450 --> 00:15:44,370
assignment form so I said you can't

00:15:41,960 --> 00:15:47,820
reuse a variable but imagine you have a

00:15:44,370 --> 00:15:50,370
for loop which loops from say one to a

00:15:47,820 --> 00:15:53,790
thousand and a single static assignment

00:15:50,370 --> 00:15:55,680
form you can't have a variable being

00:15:53,790 --> 00:15:58,320
assigned to more than one so how would

00:15:55,680 --> 00:16:00,480
you use the loop index variable in this

00:15:58,320 --> 00:16:02,850
and the way you do that is you have the

00:16:00,480 --> 00:16:05,220
special v value which says this takes

00:16:02,850 --> 00:16:10,800
one or more different values depending

00:16:05,220 --> 00:16:12,180
on what the previous basic block was and

00:16:10,800 --> 00:16:16,230
I'll actually show you an example of

00:16:12,180 --> 00:16:20,910
using that a bit later functions have to

00:16:16,230 --> 00:16:22,770
start with an entry basic block this is

00:16:20,910 --> 00:16:24,150
just the first basic block that's

00:16:22,770 --> 00:16:25,800
entered and it's kind of special because

00:16:24,150 --> 00:16:28,140
it doesn't necessarily have any

00:16:25,800 --> 00:16:30,270
predecessors every other basic block

00:16:28,140 --> 00:16:33,120
should be reachable or it will be

00:16:30,270 --> 00:16:35,490
removed later if you have local

00:16:33,120 --> 00:16:37,590
variables you can allocate space for

00:16:35,490 --> 00:16:39,620
them in the entry block and as I say

00:16:37,590 --> 00:16:42,360
there's this memory to register

00:16:39,620 --> 00:16:45,570
promotion pass which will construct nice

00:16:42,360 --> 00:16:47,430
single static assignment form from this

00:16:45,570 --> 00:16:49,140
and most of the front ends do this even

00:16:47,430 --> 00:16:53,400
things like clang that are written by

00:16:49,140 --> 00:16:55,290
LLVM developers because constructing

00:16:53,400 --> 00:16:57,720
single static assignment form really

00:16:55,290 --> 00:17:00,480
requires you to know about flow control

00:16:57,720 --> 00:17:02,820
and do all the flow control analysis and

00:17:00,480 --> 00:17:04,500
if you're lazy you don't want to do the

00:17:02,820 --> 00:17:06,930
flow control analysis you want to just

00:17:04,500 --> 00:17:09,270
let LVM do the flow control analysis for

00:17:06,930 --> 00:17:11,400
you because you know that's its job

00:17:09,270 --> 00:17:13,650
you're just writing a front end and

00:17:11,400 --> 00:17:16,110
front end should be simple so you can

00:17:13,650 --> 00:17:20,130
just create a a locker for every local

00:17:16,110 --> 00:17:24,120
variable and let LVM do the promotion

00:17:20,130 --> 00:17:25,830
for you so this is hello world in our VM

00:17:24,120 --> 00:17:30,330
and this is not just printing hello

00:17:25,830 --> 00:17:33,900
world this is a program that will

00:17:30,330 --> 00:17:37,919
if you set compile this and you type a

00:17:33,900 --> 00:17:41,159
dot out Fred it will say hello Fred but

00:17:37,919 --> 00:17:43,289
otherwise it'll say hello world so at

00:17:41,159 --> 00:17:45,900
the start we have this branch

00:17:43,289 --> 00:17:49,200
instruction so well first of all we're

00:17:45,900 --> 00:17:50,940
comparing this value of Arg C which is

00:17:49,200 --> 00:17:55,010
just the same as it is in C because this

00:17:50,940 --> 00:17:57,150
is just a main function with zero

00:17:55,010 --> 00:17:58,440
actually should be comparing it with one

00:17:57,150 --> 00:18:02,190
never mind there's a bug in the program

00:17:58,440 --> 00:18:04,470
but not a bug in the IR and then this

00:18:02,190 --> 00:18:07,549
will be returning in this register one

00:18:04,470 --> 00:18:10,049
registers that start with a percent

00:18:07,549 --> 00:18:12,840
local registers registers that start

00:18:10,049 --> 00:18:15,659
with an at our global registers but

00:18:12,840 --> 00:18:18,120
that's yeah just a little detail so this

00:18:15,659 --> 00:18:22,230
is returning something which is an i1 it

00:18:18,120 --> 00:18:24,360
says actually doesn't say but the type

00:18:22,230 --> 00:18:26,580
when you use it isn't i1 and I means

00:18:24,360 --> 00:18:30,480
integer one means one bit so it's

00:18:26,580 --> 00:18:34,110
basically a boolean value and then you

00:18:30,480 --> 00:18:37,070
branch based on that so if this is true

00:18:34,110 --> 00:18:39,659
then you go to this label world

00:18:37,070 --> 00:18:41,669
otherwise you go to the label name and

00:18:39,659 --> 00:18:46,140
labels are just text strings they can be

00:18:41,669 --> 00:18:49,200
anything that could be useful yeah yeah

00:18:46,140 --> 00:18:51,830
can you see this little dot maybe okay

00:18:49,200 --> 00:18:55,559
the people in the front row can see it

00:18:51,830 --> 00:18:57,150
so if you go into the world block you

00:18:55,559 --> 00:18:58,890
have this get element pointer

00:18:57,150 --> 00:19:02,090
instruction which I'll talk a little bit

00:18:58,890 --> 00:19:04,440
about later this is basically how LVM

00:19:02,090 --> 00:19:08,840
represents any of the complex addressing

00:19:04,440 --> 00:19:11,190
modes on our CPU so this is taking this

00:19:08,840 --> 00:19:13,650
global register which is declared

00:19:11,190 --> 00:19:18,270
somewhere up here this string hello

00:19:13,650 --> 00:19:21,630
world which is a 12 character I eight

00:19:18,270 --> 00:19:24,000
which is a char basically an 8-bit

00:19:21,630 --> 00:19:27,270
integer note that it has an explicit

00:19:24,000 --> 00:19:30,500
null terminator because values narrow VM

00:19:27,270 --> 00:19:33,240
they're just like blobs of memory so

00:19:30,500 --> 00:19:34,860
there's no implicit null termination on

00:19:33,240 --> 00:19:39,240
strings because there are no strings

00:19:34,860 --> 00:19:42,320
it's just an array of characters it gets

00:19:39,240 --> 00:19:44,150
a pointer to the first element

00:19:42,320 --> 00:19:47,270
and I'll explain that a bit more later

00:19:44,150 --> 00:19:50,690
and then just calls the C standard put

00:19:47,270 --> 00:19:53,750
string function and exits if you go to

00:19:50,690 --> 00:19:56,240
the other version then it does the same

00:19:53,750 --> 00:20:01,640
sort of thing this time getting the

00:19:56,240 --> 00:20:03,380
address of the first element in this

00:20:01,640 --> 00:20:08,510
array or actually the second element the

00:20:03,380 --> 00:20:11,600
first one is the the program name and

00:20:08,510 --> 00:20:18,350
then it loads this so this is loading a

00:20:11,600 --> 00:20:20,570
pointer to a pointer to intake so the

00:20:18,350 --> 00:20:23,420
result of this will be basically a C

00:20:20,570 --> 00:20:25,370
string a pointer to intake and then it

00:20:23,420 --> 00:20:28,190
calls printer with this is the second

00:20:25,370 --> 00:20:31,280
argument and hello % s is the first

00:20:28,190 --> 00:20:33,650
argument so this is a really simple LVM

00:20:31,280 --> 00:20:35,390
program but it demonstrates basically

00:20:33,650 --> 00:20:40,570
all of the LLVM that you need to care

00:20:35,390 --> 00:20:44,630
about LLVM is strongly typed and it's

00:20:40,570 --> 00:20:46,370
kind of annoying in a way but it's

00:20:44,630 --> 00:20:48,530
useful for optimizations it's annoying

00:20:46,370 --> 00:20:50,570
for front-end writers so you end up

00:20:48,530 --> 00:20:53,060
having to have a lot of explicit cast in

00:20:50,570 --> 00:20:58,130
LVM and these get element pointer things

00:20:53,060 --> 00:21:01,010
so if you have an array a raisin

00:20:58,130 --> 00:21:03,260
pointers in LLVM are distinct types

00:21:01,010 --> 00:21:05,960
arrays of different lengths are distinct

00:21:03,260 --> 00:21:07,940
types arrays of the same size but

00:21:05,960 --> 00:21:12,080
different element types are distinct

00:21:07,940 --> 00:21:14,090
types and this is useful for validation

00:21:12,080 --> 00:21:16,220
but it does mean you just end up writing

00:21:14,090 --> 00:21:20,450
lots and lots of cast instructions which

00:21:16,220 --> 00:21:22,910
the optimizer will strip away structures

00:21:20,450 --> 00:21:25,820
actually changed a bit without vm3

00:21:22,910 --> 00:21:29,870
before LLVM 3 structures that had the

00:21:25,820 --> 00:21:31,940
same layout were the same now structures

00:21:29,870 --> 00:21:35,600
that have different names but the same

00:21:31,940 --> 00:21:37,490
layout has taken to be different but you

00:21:35,600 --> 00:21:40,700
also still have anonymous structures

00:21:37,490 --> 00:21:42,680
which will just be merged together and

00:21:40,700 --> 00:21:47,090
the reason for this change was to allow

00:21:42,680 --> 00:21:50,300
you to do strict aliasing analysis which

00:21:47,090 --> 00:21:53,450
I guess most of you have written C and

00:21:50,300 --> 00:21:55,549
C++ code how many people have had to add

00:21:53,450 --> 00:22:00,710
ethno strict aliasing to their

00:21:55,549 --> 00:22:02,659
compiled okay so not many of you

00:22:00,710 --> 00:22:04,489
that's either very impressive or your

00:22:02,659 --> 00:22:08,179
build systems doing it automatically and

00:22:04,489 --> 00:22:11,090
you aren't aware of it so strict

00:22:08,179 --> 00:22:13,249
aliasing is this great idea that someone

00:22:11,090 --> 00:22:16,070
understands as committee had which said

00:22:13,249 --> 00:22:18,350
if we make everybody really really read

00:22:16,070 --> 00:22:20,419
the standard in detail then we can make

00:22:18,350 --> 00:22:22,249
life easier for compiler writers and

00:22:20,419 --> 00:22:24,080
compiler writers really liked it because

00:22:22,249 --> 00:22:26,509
there are suddenly a load of

00:22:24,080 --> 00:22:28,580
optimization opportunities and you can

00:22:26,509 --> 00:22:31,129
make C codes really fast and everyone

00:22:28,580 --> 00:22:33,619
else hates it because all of these

00:22:31,129 --> 00:22:35,539
little tricks that you used to do that

00:22:33,619 --> 00:22:37,429
the standard didn't really allow but all

00:22:35,539 --> 00:22:39,379
compilers actually accept it anyway

00:22:37,429 --> 00:22:43,159
because well that's how the machine

00:22:39,379 --> 00:22:45,200
works now don't work and your compiler

00:22:43,159 --> 00:22:47,149
is now suddenly getting into a bit way

00:22:45,200 --> 00:22:48,980
or in undefined behavior and compiler

00:22:47,149 --> 00:22:51,700
writers love undefined behavior because

00:22:48,980 --> 00:22:54,409
it means you can do anything you want

00:22:51,700 --> 00:22:56,239
and programmers really hate undefined

00:22:54,409 --> 00:22:58,970
behavior because they compile it on one

00:22:56,239 --> 00:23:00,499
compiler and they get some behavior and

00:22:58,970 --> 00:23:04,220
they think that's what's expected to

00:23:00,499 --> 00:23:05,720
happen and then they upgrade their

00:23:04,220 --> 00:23:08,330
compiler and suddenly their code doesn't

00:23:05,720 --> 00:23:10,700
work and they say your compiler it has

00:23:08,330 --> 00:23:15,950
bugs in it and you say no no undefined

00:23:10,700 --> 00:23:19,340
behavior haha so I wanted to give you a

00:23:15,950 --> 00:23:21,889
little example you can grab the full

00:23:19,340 --> 00:23:25,399
source code for this tiny compiler an

00:23:21,889 --> 00:23:27,259
interpreter at the first address the

00:23:25,399 --> 00:23:29,480
second address is just the syntax

00:23:27,259 --> 00:23:32,330
highlighted bit that I'm actually going

00:23:29,480 --> 00:23:34,340
to talk about on the next few slides I

00:23:32,330 --> 00:23:37,609
have some code but to fit things on the

00:23:34,340 --> 00:23:38,570
slide I had to omit a few details so the

00:23:37,609 --> 00:23:40,580
full version and the full version

00:23:38,570 --> 00:23:43,730
differs in one very important way and

00:23:40,580 --> 00:23:45,649
that it actually has comments in it is

00:23:43,730 --> 00:23:48,350
the second address and if you have a

00:23:45,649 --> 00:23:52,190
phone that understands these QR code

00:23:48,350 --> 00:23:55,580
things it will send you to the compiler

00:23:52,190 --> 00:23:57,830
CC dot HTML thing so maybe you know

00:23:55,580 --> 00:24:02,359
people following at home can do that and

00:23:57,830 --> 00:24:04,970
it'll be easier for people who can't see

00:24:02,359 --> 00:24:07,519
the slides or a board with listening to

00:24:04,970 --> 00:24:10,950
me and just want to read the code

00:24:07,519 --> 00:24:12,840
so everyone had who wanted to do that

00:24:10,950 --> 00:24:15,899
had got it hadn't they okay

00:24:12,840 --> 00:24:18,480
so rather than take an existing language

00:24:15,899 --> 00:24:20,279
which maybe you'd be familiar with or

00:24:18,480 --> 00:24:23,190
maybe you wouldn't I thought I would

00:24:20,279 --> 00:24:24,389
make up a language for this talk so this

00:24:23,190 --> 00:24:26,340
is a really simple domain-specific

00:24:24,389 --> 00:24:28,740
language that is designed for

00:24:26,340 --> 00:24:29,629
implementing cellular that cellular

00:24:28,740 --> 00:24:32,220
automata

00:24:29,629 --> 00:24:36,120
unfortunately I picked cellular automata

00:24:32,220 --> 00:24:37,980
which I can't say very quickly so I'm

00:24:36,120 --> 00:24:39,720
now going to spend the next five or six

00:24:37,980 --> 00:24:46,429
site slides saying so there they're

00:24:39,720 --> 00:24:49,950
everywhere so a cellular automaton is a

00:24:46,429 --> 00:24:52,470
basically a grid containing values and a

00:24:49,950 --> 00:24:55,529
program runs on each square in the grid

00:24:52,470 --> 00:24:57,360
and it computes some value based on the

00:24:55,529 --> 00:25:00,299
current value and based on the values of

00:24:57,360 --> 00:25:04,110
the neighbors so because I was really

00:25:00,299 --> 00:25:06,869
lazy writing the parser this language

00:25:04,110 --> 00:25:10,440
doesn't have named variables it just has

00:25:06,869 --> 00:25:13,799
ten local registers a zero to a nine and

00:25:10,440 --> 00:25:15,779
ten global registers G zero to G 9 and

00:25:13,799 --> 00:25:19,289
when the program starts running all of

00:25:15,779 --> 00:25:24,119
these are 0 the local registers are

00:25:19,289 --> 00:25:26,539
reset to zero for every instance of the

00:25:24,119 --> 00:25:29,369
for every square the global ones are not

00:25:26,539 --> 00:25:32,730
it also has a special register v which

00:25:29,369 --> 00:25:35,820
is initially the value of the cell in

00:25:32,730 --> 00:25:38,999
the old grid and then your program runs

00:25:35,820 --> 00:25:40,799
and it sets the value of V there are a

00:25:38,999 --> 00:25:44,460
few simple things so we have some simple

00:25:40,799 --> 00:25:46,289
arithmetic things and again because I'm

00:25:44,460 --> 00:25:48,360
lazy when it comes to writing parsers

00:25:46,289 --> 00:25:49,619
the operator comes first and then

00:25:48,360 --> 00:25:54,330
there's a register and then there's an

00:25:49,619 --> 00:25:57,720
expression so for example plus a1 one

00:25:54,330 --> 00:25:59,999
would increment register a1 we have a

00:25:57,720 --> 00:26:04,679
couple of more interesting things there

00:25:59,999 --> 00:26:08,220
is a neighbors statement which then is

00:26:04,679 --> 00:26:10,409
the only flow control statement in this

00:26:08,220 --> 00:26:13,889
language and this evaluates the

00:26:10,409 --> 00:26:17,009
statements in the body once for every

00:26:13,889 --> 00:26:18,779
neighbor that the program has that in

00:26:17,009 --> 00:26:20,669
the cell has so if you aren't in a

00:26:18,779 --> 00:26:22,289
corner it will evaluate this 3

00:26:20,669 --> 00:26:26,460
times if you're on it on an edge it'll

00:26:22,289 --> 00:26:27,960
evaluate it five times and if you're on

00:26:26,460 --> 00:26:31,619
it in the middle it'll evaluate at nine

00:26:27,960 --> 00:26:35,249
times and we have a select expression

00:26:31,619 --> 00:26:37,350
which takes the register value and it

00:26:35,249 --> 00:26:40,799
will return a different value depending

00:26:37,350 --> 00:26:44,249
on what the register value is whether

00:26:40,799 --> 00:26:48,119
it's a named a specified value if it's

00:26:44,249 --> 00:26:50,460
in a specified range or if it's not in

00:26:48,119 --> 00:26:53,369
any of the specified values it'll be

00:26:50,460 --> 00:26:57,059
zero so just a few quick examples of

00:26:53,369 --> 00:27:00,989
this this is a simple program which will

00:26:57,059 --> 00:27:04,019
flash every cell in the grid so whatever

00:27:00,989 --> 00:27:05,700
the initial values are after the next

00:27:04,019 --> 00:27:09,720
iteration it'll be the opposite of this

00:27:05,700 --> 00:27:12,419
so this says take the value V which is

00:27:09,720 --> 00:27:14,669
the current value if it's zero set it to

00:27:12,419 --> 00:27:17,580
one implicitly if it's set to anything

00:27:14,669 --> 00:27:25,379
else set it to zero and then assign that

00:27:17,580 --> 00:27:26,899
to V so very simple program a slightly

00:27:25,379 --> 00:27:29,519
more complicated one

00:27:26,899 --> 00:27:31,169
this neighbors expression stores the

00:27:29,519 --> 00:27:35,159
value in the current neighbor in a zero

00:27:31,169 --> 00:27:37,139
so we're not using a zero there but this

00:27:35,159 --> 00:27:39,419
just execute this statement once for

00:27:37,139 --> 00:27:41,090
every neighbor that this has so when you

00:27:39,419 --> 00:27:43,440
run this you'll get a grid which has

00:27:41,090 --> 00:27:44,909
three in the corners and five in the

00:27:43,440 --> 00:27:47,249
edges Nate and all the cells in the

00:27:44,909 --> 00:27:49,830
middle so this counts the number of

00:27:47,249 --> 00:27:52,440
neighbors you have by adding one to a

00:27:49,830 --> 00:27:55,799
zero for every neighbor and then just

00:27:52,440 --> 00:27:57,600
assigns the value in a 1 to V and a more

00:27:55,799 --> 00:27:59,100
interesting example I get how many

00:27:57,600 --> 00:28:03,059
people have not heard of Conway's Game

00:27:59,100 --> 00:28:05,129
of Life okay so this is this is probably

00:28:03,059 --> 00:28:08,070
the most famous say there automata

00:28:05,129 --> 00:28:09,480
program and I wrote an article a couple

00:28:08,070 --> 00:28:13,499
of years ago where I implemented this

00:28:09,480 --> 00:28:16,379
and OpenCL and this was about a page of

00:28:13,499 --> 00:28:18,029
code page and a half of code so this

00:28:16,379 --> 00:28:22,859
language is quite dense for this kind of

00:28:18,029 --> 00:28:24,539
thing but this again it counts the

00:28:22,859 --> 00:28:27,419
number of neighbors that are set to one

00:28:24,539 --> 00:28:29,340
stores nadan a zero then for the current

00:28:27,419 --> 00:28:33,389
value if the current value in this cell

00:28:29,340 --> 00:28:34,260
is zero and it has three neighbors then

00:28:33,389 --> 00:28:35,720
it's happy

00:28:34,260 --> 00:28:38,010
and healthy and it stays alive

00:28:35,720 --> 00:28:40,080
absolutely then it breathe they breed

00:28:38,010 --> 00:28:43,410
and you get a new value here so it sets

00:28:40,080 --> 00:28:46,919
it to one if this current value is one

00:28:43,410 --> 00:28:48,960
and you have two or three neighbors then

00:28:46,919 --> 00:28:51,809
again it's happy and healthy and it

00:28:48,960 --> 00:28:54,480
stays alive if it has only one or zero

00:28:51,809 --> 00:28:56,370
neighbors it gets lonely and dies and if

00:28:54,480 --> 00:28:59,160
it has more than three neighbors it

00:28:56,370 --> 00:29:02,340
starves to death and so this this is

00:28:59,160 --> 00:29:04,950
actually interesting because Conway's

00:29:02,340 --> 00:29:07,410
Game of Life is turing-complete you can

00:29:04,950 --> 00:29:09,299
implement a Turing machine in Conway's

00:29:07,410 --> 00:29:11,690
Game of Life and you can represent tapes

00:29:09,299 --> 00:29:14,220
with the cells and have them feeding in

00:29:11,690 --> 00:29:16,679
but this language itself is not you're

00:29:14,220 --> 00:29:19,169
incomplete so only the fact that you're

00:29:16,679 --> 00:29:21,570
repeatedly executing this program makes

00:29:19,169 --> 00:29:24,630
it you're incomplete so this language is

00:29:21,570 --> 00:29:26,250
right on that boundary which I don't

00:29:24,630 --> 00:29:29,669
know makes it interesting theoretically

00:29:26,250 --> 00:29:32,309
maybe not so much practically and this

00:29:29,669 --> 00:29:35,460
compiler turns it into a abstract syntax

00:29:32,309 --> 00:29:39,179
tree representation which is a simple

00:29:35,460 --> 00:29:42,780
structure which just starts with an

00:29:39,179 --> 00:29:47,280
operation ID and has two children and

00:29:42,780 --> 00:29:49,890
what those are depends on what the

00:29:47,280 --> 00:29:51,720
operation is but typically most of the

00:29:49,890 --> 00:29:55,290
things just have two values associated

00:29:51,720 --> 00:29:57,270
with them and we do a little bit of

00:29:55,290 --> 00:29:59,370
cheating so registers and literals are

00:29:57,270 --> 00:30:01,260
encoded into pointers and this makes the

00:29:59,370 --> 00:30:03,630
representation a bit denser and it also

00:30:01,260 --> 00:30:06,390
means the interpreter can actually be

00:30:03,630 --> 00:30:09,870
quite fast because loading a register

00:30:06,390 --> 00:30:14,460
value is just do a shift and then load

00:30:09,870 --> 00:30:16,770
it from that index so the compiler is

00:30:14,460 --> 00:30:20,669
just one C++ file and maybe some of you

00:30:16,770 --> 00:30:23,880
have looked at this C++ DEP DEP C++ file

00:30:20,669 --> 00:30:26,820
already use a few LLVM classes which

00:30:23,880 --> 00:30:30,210
I'll go through quickly now and some

00:30:26,820 --> 00:30:32,160
parts of this are written in C and are

00:30:30,210 --> 00:30:35,730
compiled using clang and are then linked

00:30:32,160 --> 00:30:37,230
into the program so I've kind of gone

00:30:35,730 --> 00:30:40,559
through what some of these things are

00:30:37,230 --> 00:30:43,950
already these are the LVM classes and

00:30:40,559 --> 00:30:46,409
LVM module is a module the function is

00:30:43,950 --> 00:30:49,679
well yeah you get the idea

00:30:46,409 --> 00:30:53,970
global variables a class that represents

00:30:49,679 --> 00:30:57,389
well yeah obviously I guess the most

00:30:53,970 --> 00:31:00,059
useful class for people right in front

00:30:57,389 --> 00:31:02,970
ends is this ir builder class which is

00:31:00,059 --> 00:31:06,090
just a helper class which will generate

00:31:02,970 --> 00:31:09,240
LVM instructions for you with just a

00:31:06,090 --> 00:31:11,549
single function call for each one the

00:31:09,240 --> 00:31:13,289
type of class i won't deal with very

00:31:11,549 --> 00:31:17,429
much because this language only has one

00:31:13,289 --> 00:31:20,850
type which is a 16-bit integer so we

00:31:17,429 --> 00:31:22,950
only touch on that very briefly constant

00:31:20,850 --> 00:31:23,789
expression is the class that's used for

00:31:22,950 --> 00:31:27,649
building

00:31:23,789 --> 00:31:30,360
well obviously constant expressions

00:31:27,649 --> 00:31:32,429
these last two will come to a little bit

00:31:30,360 --> 00:31:36,590
later Pass manager builder is the one

00:31:32,429 --> 00:31:38,669
that we use for building and

00:31:36,590 --> 00:31:40,529
constructing a sequence of LVM

00:31:38,669 --> 00:31:43,350
optimization passes which you then want

00:31:40,529 --> 00:31:47,340
to run an execution engine is the bit

00:31:43,350 --> 00:31:49,799
that actually does the execution so the

00:31:47,340 --> 00:31:51,149
first thing we did in the interpreter

00:31:49,799 --> 00:31:52,889
there is a function that looks a lot

00:31:51,149 --> 00:31:56,490
like this that then calls the

00:31:52,889 --> 00:31:58,169
interpreter again for each cell oh this

00:31:56,490 --> 00:32:01,350
says 50 when it should say width and

00:31:58,169 --> 00:32:03,629
height this is not a bug in the version

00:32:01,350 --> 00:32:07,289
that you can see in the on line that is

00:32:03,629 --> 00:32:09,419
a bug on the slides so where's the

00:32:07,289 --> 00:32:13,259
button that works this should say width

00:32:09,419 --> 00:32:15,330
and this should say height sorry so this

00:32:13,259 --> 00:32:18,179
this function is just written in C and

00:32:15,330 --> 00:32:20,129
compiled with clang two-bit code and it

00:32:18,179 --> 00:32:23,309
has a four word definition of this cell

00:32:20,129 --> 00:32:26,419
function so what will happen at the end

00:32:23,309 --> 00:32:29,070
of all of this is that we will emit an

00:32:26,419 --> 00:32:33,570
actual definition of this cell function

00:32:29,070 --> 00:32:36,299
and then the LLVM optimizer will inline

00:32:33,570 --> 00:32:37,889
it here so we don't need to write all of

00:32:36,299 --> 00:32:40,289
this boilerplate code we don't need to

00:32:37,889 --> 00:32:42,809
generate lv miR for it we can just copy

00:32:40,289 --> 00:32:44,039
and paste from the interpreter and it

00:32:42,809 --> 00:32:46,080
works now wants to do it this way around

00:32:44,039 --> 00:32:46,830
because all the other examples do it the

00:32:46,080 --> 00:32:49,019
other way around

00:32:46,830 --> 00:32:51,419
and have you calling helper functions

00:32:49,019 --> 00:32:53,070
from your ir and then aligning them but

00:32:51,419 --> 00:32:57,269
we can do it both ways we can omit

00:32:53,070 --> 00:32:59,510
something in our LVM ir that we then

00:32:57,269 --> 00:33:02,540
call from something else and you could

00:32:59,510 --> 00:33:04,490
modify the implementation of this really

00:33:02,540 --> 00:33:07,220
easily to for example use live dispatch

00:33:04,490 --> 00:33:09,740
and run all of these in parallel or

00:33:07,220 --> 00:33:12,860
maybe just run every row in parallel or

00:33:09,740 --> 00:33:14,630
something like that and to generate bit

00:33:12,860 --> 00:33:17,630
code from this we just add this emit

00:33:14,630 --> 00:33:20,660
LLVM flag decline by default it emits

00:33:17,630 --> 00:33:24,320
native code but if you add this flag it

00:33:20,660 --> 00:33:26,210
will emit a VM bit code so this is stuff

00:33:24,320 --> 00:33:29,150
that you'll see in pretty much any

00:33:26,210 --> 00:33:30,290
compiler for a small language using our

00:33:29,150 --> 00:33:31,940
VM

00:33:30,290 --> 00:33:34,550
we're actually cheating a bit when we

00:33:31,940 --> 00:33:36,710
construct the LVM module rather than

00:33:34,550 --> 00:33:38,570
constructing one the normal way with

00:33:36,710 --> 00:33:42,620
constructors and create functions and

00:33:38,570 --> 00:33:44,450
stuff we grab a memory buffer containing

00:33:42,620 --> 00:33:46,160
the contents of the bit code that we

00:33:44,450 --> 00:33:49,250
compiled with clang the little runtime

00:33:46,160 --> 00:33:51,140
library and then just say parse that so

00:33:49,250 --> 00:33:53,210
we're actually taking a copy of the code

00:33:51,140 --> 00:33:56,360
that we compiled with clang and rather

00:33:53,210 --> 00:33:59,300
than linking in with it we're just using

00:33:56,360 --> 00:34:02,320
this is the skeleton for our new program

00:33:59,300 --> 00:34:05,330
does that make sense to everyone

00:34:02,320 --> 00:34:09,080
okay I see slightly confused faces but

00:34:05,330 --> 00:34:11,000
not everywhere so then we rather than

00:34:09,080 --> 00:34:13,220
creating a new function we just get the

00:34:11,000 --> 00:34:15,770
cell function that we forward declared

00:34:13,220 --> 00:34:17,840
and because this is just a stub function

00:34:15,770 --> 00:34:20,180
it has no implementation it doesn't have

00:34:17,840 --> 00:34:23,860
a basic block so we do need to create

00:34:20,180 --> 00:34:29,840
the entry basic block and this is just

00:34:23,860 --> 00:34:32,000
standard this a factory function and it

00:34:29,840 --> 00:34:35,150
goes in the function that we just loaded

00:34:32,000 --> 00:34:36,560
the name doesn't really matter it's just

00:34:35,150 --> 00:34:39,230
the first one that's added will

00:34:36,560 --> 00:34:41,630
automatically be the entry one a lot of

00:34:39,230 --> 00:34:44,390
these things take this C parameter which

00:34:41,630 --> 00:34:47,510
isn't on the slides this is an LLVM

00:34:44,390 --> 00:34:49,610
context and this is what I love um uses

00:34:47,510 --> 00:34:51,590
for re-entrance e so you can have

00:34:49,610 --> 00:34:54,200
multiple threads with different lvm

00:34:51,590 --> 00:34:56,240
contexts but you can also just call get

00:34:54,200 --> 00:34:57,620
global context and then you get a shared

00:34:56,240 --> 00:35:00,110
one if you don't care about having a

00:34:57,620 --> 00:35:01,790
multi-threaded compiler and to be fair

00:35:00,110 --> 00:35:05,690
most people don't care about having a

00:35:01,790 --> 00:35:07,520
multi-threaded compiler here we're

00:35:05,690 --> 00:35:09,560
setting the linkage of the function so

00:35:07,520 --> 00:35:11,330
this is private linkage which means that

00:35:09,560 --> 00:35:13,340
it won't be exported outside of this

00:35:11,330 --> 00:35:14,870
module and that just means

00:35:13,340 --> 00:35:16,790
that the inliner is more likely to

00:35:14,870 --> 00:35:20,110
inline it because it's only called in

00:35:16,790 --> 00:35:22,790
one place if we inline it we get rid of

00:35:20,110 --> 00:35:26,870
every single need to call it so that

00:35:22,790 --> 00:35:29,000
it's useful this is just creating a

00:35:26,870 --> 00:35:31,640
cached copy of the type that we use for

00:35:29,000 --> 00:35:34,010
registers and then we set the ir

00:35:31,640 --> 00:35:35,390
builder's entry point insert points to

00:35:34,010 --> 00:35:40,370
the entry block and then we're ready to

00:35:35,390 --> 00:35:42,830
start actually creating bit code so the

00:35:40,370 --> 00:35:45,170
first thing we need to do for this

00:35:42,830 --> 00:35:48,860
little language is allocate some space

00:35:45,170 --> 00:35:52,760
for the registers and if we go back to

00:35:48,860 --> 00:35:53,870
the runtime a second this cell function

00:35:52,760 --> 00:35:57,560
this is the one that we're going to be

00:35:53,870 --> 00:36:00,560
generating where we'll take the global

00:35:57,560 --> 00:36:01,970
registers by pointer as an argument but

00:36:00,560 --> 00:36:06,980
it will need to allocate the local

00:36:01,970 --> 00:36:09,080
registers itself so we create each of

00:36:06,980 --> 00:36:13,130
the a registers just with a single a

00:36:09,080 --> 00:36:15,170
locker so this takes the type here so

00:36:13,130 --> 00:36:17,810
this will create enough space on the

00:36:15,170 --> 00:36:22,480
stack for a 16-bit integer and this

00:36:17,810 --> 00:36:25,520
returns an LVN value which represents a

00:36:22,480 --> 00:36:27,680
pointer to a 16-bit integer on the stack

00:36:25,520 --> 00:36:33,980
and we just do this in a loop at the

00:36:27,680 --> 00:36:35,930
start we store I've missed off the bit

00:36:33,980 --> 00:36:40,070
where we created a locker for the V as

00:36:35,930 --> 00:36:43,910
well but nevermind we store the first

00:36:40,070 --> 00:36:47,000
argument in V and then for the next

00:36:43,910 --> 00:36:49,910
argument we do this same thing we well

00:36:47,000 --> 00:36:52,070
yep we then loop over these and store

00:36:49,910 --> 00:36:56,180
the value 0 so this is a constant

00:36:52,070 --> 00:36:59,530
integer of this type value 0 in each of

00:36:56,180 --> 00:37:04,280
the a registers and create one of these

00:36:59,530 --> 00:37:07,280
for each of the global registers so I've

00:37:04,280 --> 00:37:10,220
sort of brushed over the get thing a bit

00:37:07,280 --> 00:37:12,790
because it's slightly confusing it

00:37:10,220 --> 00:37:19,310
stands for get element pointer which

00:37:12,790 --> 00:37:23,360
yeah it does exactly what it says from

00:37:19,310 --> 00:37:26,210
the earlier example the we wanted to get

00:37:23,360 --> 00:37:26,930
a pointer to the first element in an

00:37:26,210 --> 00:37:30,410
array of care

00:37:26,930 --> 00:37:32,660
Etta's so this is just like getting this

00:37:30,410 --> 00:37:34,460
is a rate of pointer decay and see

00:37:32,660 --> 00:37:37,809
basically so this is a get element

00:37:34,460 --> 00:37:41,150
pointer with the value 0 in this example

00:37:37,809 --> 00:37:45,770
we're getting the element pointer in the

00:37:41,150 --> 00:37:47,839
array for each index these do get really

00:37:45,770 --> 00:37:49,280
horribly complicated later on because

00:37:47,839 --> 00:37:51,349
they take an arbitrary number of

00:37:49,280 --> 00:37:53,690
arguments and so they can peer into

00:37:51,349 --> 00:37:55,160
structures at any interested structures

00:37:53,690 --> 00:37:56,390
and structures containing a raise of

00:37:55,160 --> 00:38:00,319
structures containing arrays of

00:37:56,390 --> 00:38:02,059
structures the really important thing to

00:38:00,319 --> 00:38:05,240
remember about these is that they don't

00:38:02,059 --> 00:38:07,099
dereference the pointer so whenever you

00:38:05,240 --> 00:38:09,260
actually see one of these in code it'll

00:38:07,099 --> 00:38:12,109
be a get element pointer followed by

00:38:09,260 --> 00:38:14,420
either a load or a store and the back

00:38:12,109 --> 00:38:17,300
end will then generate some complex

00:38:14,420 --> 00:38:20,270
addressing mode instruction but the get

00:38:17,300 --> 00:38:24,410
element pointer itself does not actually

00:38:20,270 --> 00:38:28,400
touch the memory arithmetic statements

00:38:24,410 --> 00:38:34,069
in this are really easy so we load the

00:38:28,400 --> 00:38:36,920
old value do an ad or a multiplier or a

00:38:34,069 --> 00:38:41,299
divided or whatever and then store the

00:38:36,920 --> 00:38:43,910
new value and all of the arithmetic

00:38:41,299 --> 00:38:46,910
instructions are just done by this

00:38:43,910 --> 00:38:50,420
little switch statement which computes

00:38:46,910 --> 00:38:52,790
the result so implementing all of the

00:38:50,420 --> 00:38:55,400
arithmetic operations that this toy

00:38:52,790 --> 00:38:56,619
language supports which I think six of

00:38:55,400 --> 00:38:59,630
them there's also a min and a max

00:38:56,619 --> 00:39:02,599
they're all basically like this and

00:38:59,630 --> 00:39:06,859
again we're not caring here that LLVM is

00:39:02,599 --> 00:39:09,500
static single assignment because we're

00:39:06,859 --> 00:39:13,490
just loading it from the stack doing the

00:39:09,500 --> 00:39:15,290
operation and then storing it flow

00:39:13,490 --> 00:39:19,220
control is a little bit more complicated

00:39:15,290 --> 00:39:20,780
so I'm going to ignore the neighbors

00:39:19,220 --> 00:39:22,849
instruction if you want to look at that

00:39:20,780 --> 00:39:25,460
in the code feel free but I'll go

00:39:22,849 --> 00:39:28,520
through the range instruction so this is

00:39:25,460 --> 00:39:33,559
creating a fine ode which has one

00:39:28,520 --> 00:39:36,250
predecessor for each of the range

00:39:33,559 --> 00:39:39,290
statements that we have in this

00:39:36,250 --> 00:39:41,000
expression and then for each one in the

00:39:39,290 --> 00:39:43,160
block I've had to omit the loop because

00:39:41,000 --> 00:39:45,020
it didn't quite fit on the slide we

00:39:43,160 --> 00:39:49,450
first of all get the minimum and maximum

00:39:45,020 --> 00:39:49,450
values for it specified for the range in

00:39:50,020 --> 00:39:55,819
as constants because they are constants

00:39:53,540 --> 00:40:01,900
in the source code and then we have a

00:39:55,819 --> 00:40:06,530
little bit of boolean logic so we say if

00:40:01,900 --> 00:40:08,599
the read the register value is signed

00:40:06,530 --> 00:40:11,630
greater than or equal to the minimum

00:40:08,599 --> 00:40:14,059
value or signs less than or equal to

00:40:11,630 --> 00:40:17,660
sorry and signs less than or equal to

00:40:14,059 --> 00:40:19,400
the maximum value this will then just be

00:40:17,660 --> 00:40:22,430
a boolean value saying if we've matched

00:40:19,400 --> 00:40:24,859
this particular case then we create a

00:40:22,430 --> 00:40:27,260
couple of new basic blocks we have one

00:40:24,859 --> 00:40:29,960
for calculating the result expression

00:40:27,260 --> 00:40:31,369
and one for falling through to the next

00:40:29,960 --> 00:40:33,170
case so this is basically just like a

00:40:31,369 --> 00:40:36,380
switch statement in C but with a little

00:40:33,170 --> 00:40:38,210
bit more syntactic sugar it then creates

00:40:36,380 --> 00:40:40,430
a conditional branch so if we have

00:40:38,210 --> 00:40:42,950
matched this then we jump to this basic

00:40:40,430 --> 00:40:44,569
block if we haven't matched it then we

00:40:42,950 --> 00:40:47,809
fall through and try the next one and

00:40:44,569 --> 00:40:53,210
then we'll be back here again then it

00:40:47,809 --> 00:40:57,109
sets the insert point in the range

00:40:53,210 --> 00:41:00,200
result block that we've just created and

00:40:57,109 --> 00:41:02,690
then we do something else to actually

00:41:00,200 --> 00:41:04,280
emit the expression for the result but

00:41:02,690 --> 00:41:07,760
this is just actually calling back to

00:41:04,280 --> 00:41:10,549
the compiled statement function and then

00:41:07,760 --> 00:41:13,510
for the final we just to set its value

00:41:10,549 --> 00:41:16,700
we say if we've are coming from this

00:41:13,510 --> 00:41:18,650
block then it's this value and then the

00:41:16,700 --> 00:41:21,530
fly node will have one value for each

00:41:18,650 --> 00:41:27,290
incoming block and so this will be in

00:41:21,530 --> 00:41:29,210
the final thing and then yeah I'm I

00:41:27,290 --> 00:41:30,619
won't go through this in too much detail

00:41:29,210 --> 00:41:32,180
because you kind of need to understand

00:41:30,619 --> 00:41:34,849
the IR but I just want to give you an

00:41:32,180 --> 00:41:38,000
example that this is a fairly complex

00:41:34,849 --> 00:41:40,190
flow control operation and I can more or

00:41:38,000 --> 00:41:42,619
less fit the code for generating it on

00:41:40,190 --> 00:41:44,359
the slide and if you want to look in

00:41:42,619 --> 00:41:46,069
more detail the version that you can

00:41:44,359 --> 00:41:48,380
download has a comment basically on

00:41:46,069 --> 00:41:50,329
every line which explains how it really

00:41:48,380 --> 00:41:52,450
works I'm running a bit short on time

00:41:50,329 --> 00:41:56,750
so I'll

00:41:52,450 --> 00:41:59,420
skip over it a bit generating code is

00:41:56,750 --> 00:42:02,300
really really simple you create an

00:41:59,420 --> 00:42:04,700
execution engine from this module this

00:42:02,300 --> 00:42:06,410
false flag said is just say whether we

00:42:04,700 --> 00:42:08,120
should force it to use the interpreter

00:42:06,410 --> 00:42:09,830
we don't want to force it to use the

00:42:08,120 --> 00:42:11,930
interpreter because we probably already

00:42:09,830 --> 00:42:14,240
have a fast interpreter we wanted to use

00:42:11,930 --> 00:42:16,220
the JIT compiler and this is just a

00:42:14,240 --> 00:42:18,050
pointer to an error value and if this

00:42:16,220 --> 00:42:20,390
fails this error value will be set to

00:42:18,050 --> 00:42:24,290
something or we can print it otherwise

00:42:20,390 --> 00:42:26,030
we take the execution engine we say give

00:42:24,290 --> 00:42:29,120
me a pointer to the function with this

00:42:26,030 --> 00:42:30,710
name and then we get a function pointer

00:42:29,120 --> 00:42:35,660
back and then you can call that from C

00:42:30,710 --> 00:42:38,990
code and just a few statistics about

00:42:35,660 --> 00:42:40,700
this little toy example the parser was

00:42:38,990 --> 00:42:43,940
about four hundred lines of code so that

00:42:40,700 --> 00:42:45,590
was most of the complexity in this the

00:42:43,940 --> 00:42:48,410
interpreter was about two hundred lines

00:42:45,590 --> 00:42:50,840
of code and it's not the greatest

00:42:48,410 --> 00:42:54,320
interpreter in the world but it's it's

00:42:50,840 --> 00:42:55,910
yeah it's okay and the compiler was only

00:42:54,320 --> 00:42:59,870
very slightly more code than the

00:42:55,910 --> 00:43:01,340
interpreter so it used to be the if you

00:42:59,870 --> 00:43:03,470
wanted to write a compiler for your

00:43:01,340 --> 00:43:05,080
language that was ten or a hundred times

00:43:03,470 --> 00:43:08,150
more effort than writing an interpreter

00:43:05,080 --> 00:43:10,010
now actually writing the compiler is is

00:43:08,150 --> 00:43:13,850
really not much more effort than writing

00:43:10,010 --> 00:43:18,260
an interpreter and in this case well the

00:43:13,850 --> 00:43:21,440
interpreter is for the examples I ran

00:43:18,260 --> 00:43:23,330
the interpreter is only maybe seven or

00:43:21,440 --> 00:43:24,860
eight times slower than the compiler the

00:43:23,330 --> 00:43:26,540
reason for that is actually the

00:43:24,860 --> 00:43:27,800
interpreter is fairly fast for this

00:43:26,540 --> 00:43:29,510
language there isn't very much

00:43:27,800 --> 00:43:33,080
optimization you can do on a language

00:43:29,510 --> 00:43:35,480
where programs are typically only two or

00:43:33,080 --> 00:43:37,340
three statements long for languages

00:43:35,480 --> 00:43:40,010
where you're writing quite complex code

00:43:37,340 --> 00:43:42,350
even if you know I say complex even

00:43:40,010 --> 00:43:45,560
something that's a dozen a hundred lines

00:43:42,350 --> 00:43:50,630
long there's more that the optimization

00:43:45,560 --> 00:43:52,400
can work with so we can we can do a few

00:43:50,630 --> 00:43:55,280
things to improve on that that I haven't

00:43:52,400 --> 00:43:58,070
done here maybe we could improve the

00:43:55,280 --> 00:44:00,230
quality of the IR we generate for this

00:43:58,070 --> 00:44:01,610
example not so much because the IR is

00:44:00,230 --> 00:44:03,230
actually pretty simple because the

00:44:01,610 --> 00:44:04,820
source language is simple because I

00:44:03,230 --> 00:44:05,390
needs to explain the language and the

00:44:04,820 --> 00:44:09,710
compiler

00:44:05,390 --> 00:44:12,080
fermentation in one 45-minute talk can

00:44:09,710 --> 00:44:15,950
LVM optimized a bit better what what

00:44:12,080 --> 00:44:18,140
else can we do well optimizers like

00:44:15,950 --> 00:44:22,070
having lots of information to work with

00:44:18,140 --> 00:44:24,500
so maybe rather than having these width

00:44:22,070 --> 00:44:27,080
and height variables maybe you could

00:44:24,500 --> 00:44:30,140
emit an in a version that would just

00:44:27,080 --> 00:44:31,730
work on 16 by 16 blocks and then the

00:44:30,140 --> 00:44:33,260
compiler could optimize the neighbors

00:44:31,730 --> 00:44:35,600
statement a bit better because it would

00:44:33,260 --> 00:44:37,310
know how many neighbors you had maybe

00:44:35,600 --> 00:44:40,700
you could do a special case for the

00:44:37,310 --> 00:44:42,500
sides and the corners and that would be

00:44:40,700 --> 00:44:44,030
maybe adding a dozen lines to the

00:44:42,500 --> 00:44:49,940
compiler but it will give you a bit of a

00:44:44,030 --> 00:44:51,740
speed-up I used in the example code the

00:44:49,940 --> 00:44:54,020
past manager builder and I just said add

00:44:51,740 --> 00:44:57,290
the standard set of LVM optimizations

00:44:54,020 --> 00:44:59,000
and no one has really done much effort

00:44:57,290 --> 00:45:01,190
on working out which ones they should be

00:44:59,000 --> 00:45:03,560
they're just ones that someone thought

00:45:01,190 --> 00:45:06,050
made sense at the time and they maybe

00:45:03,560 --> 00:45:09,380
got tweaked a bit and they don't do very

00:45:06,050 --> 00:45:11,590
badly for C and for C++ they you know

00:45:09,380 --> 00:45:14,150
they work about as well as the GCC ones

00:45:11,590 --> 00:45:17,030
but for languages that have different

00:45:14,150 --> 00:45:19,610
characteristics maybe altering the order

00:45:17,030 --> 00:45:22,040
of the passes of adding some extra ones

00:45:19,610 --> 00:45:24,590
maybe switching them around a bit can

00:45:22,040 --> 00:45:26,900
give you better results and on the LLVM

00:45:24,590 --> 00:45:29,060
website there is a list of passes page

00:45:26,900 --> 00:45:32,840
and this will give you about 200

00:45:29,060 --> 00:45:34,280
different passes you can do maybe look

00:45:32,840 --> 00:45:35,840
at some of these see whether they do

00:45:34,280 --> 00:45:38,180
things that particularly match your

00:45:35,840 --> 00:45:42,050
source language or don't and you can

00:45:38,180 --> 00:45:44,330
write new ones there's a tutorial online

00:45:42,050 --> 00:45:46,610
for writing a new pass it's pretty

00:45:44,330 --> 00:45:48,980
simple you have typically you'll

00:45:46,610 --> 00:45:51,080
subclass one of these three either

00:45:48,980 --> 00:45:52,880
modules or function or loop passes

00:45:51,080 --> 00:45:55,730
depending on the scope of your

00:45:52,880 --> 00:45:57,470
optimization and there are lots of the

00:45:55,730 --> 00:45:59,960
passes that exist now our analysis

00:45:57,470 --> 00:46:01,670
passes so they don't transform the IR

00:45:59,960 --> 00:46:04,940
they just collect some information about

00:46:01,670 --> 00:46:08,210
it like is this a loop what else can we

00:46:04,940 --> 00:46:10,340
do is this value aliased and there are

00:46:08,210 --> 00:46:12,650
some passes that already exist that are

00:46:10,340 --> 00:46:14,000
specific to source languages I'm going

00:46:12,650 --> 00:46:15,740
to mainly talk about object that

00:46:14,000 --> 00:46:19,300
objective-c because that's mostly what I

00:46:15,740 --> 00:46:21,280
work on these

00:46:19,300 --> 00:46:24,850
magic reference counting optimizations a

00:46:21,280 --> 00:46:26,860
parser LLVM now they use our vm's flow

00:46:24,850 --> 00:46:28,480
control analysis and they determine

00:46:26,860 --> 00:46:32,140
where the reference count manipulation

00:46:28,480 --> 00:46:33,760
operations are redundant or not and if

00:46:32,140 --> 00:46:35,950
they're redundant they remove them so

00:46:33,760 --> 00:46:37,990
it's it's pretty language specific and

00:46:35,950 --> 00:46:40,840
it can also be library specific so if

00:46:37,990 --> 00:46:42,790
you have a common pattern in some

00:46:40,840 --> 00:46:45,190
library that you use a lot that could be

00:46:42,790 --> 00:46:47,590
made faster you know it's really easy to

00:46:45,190 --> 00:46:49,390
write an LVN optimization that is

00:46:47,590 --> 00:46:51,760
specific to your particular framework

00:46:49,390 --> 00:46:55,570
and just add that to your compilation

00:46:51,760 --> 00:46:57,280
thing so for example qts signals and

00:46:55,570 --> 00:47:01,060
slots mechanism someone's looking at

00:46:57,280 --> 00:47:02,890
speeding that up by taking advantage of

00:47:01,060 --> 00:47:05,410
the fact that we can just plug extra

00:47:02,890 --> 00:47:08,830
optimizations in that are only relevant

00:47:05,410 --> 00:47:10,780
to Qt and for the new step objective-c

00:47:08,830 --> 00:47:16,930
runtime there are a few that do things

00:47:10,780 --> 00:47:19,750
like inline caching yeah and if you're

00:47:16,930 --> 00:47:21,280
writing your own compiler at OPM does

00:47:19,750 --> 00:47:23,230
the compile a bit that some of the

00:47:21,280 --> 00:47:25,600
runtime stuff maybe you can reuse from

00:47:23,230 --> 00:47:27,580
other projects Lib dispatch gives you

00:47:25,600 --> 00:47:29,740
cheap from currency the Boehm garbage

00:47:27,580 --> 00:47:32,710
collector isn't the best in the world

00:47:29,740 --> 00:47:35,470
but it is you know off the shelf easy to

00:47:32,710 --> 00:47:37,810
reuse the new step objective-c runtime

00:47:35,470 --> 00:47:41,470
gives you a nice dynamic object model

00:47:37,810 --> 00:47:44,200
that's really easy to work with and just

00:47:41,470 --> 00:47:45,850
one very final thing before they kick me

00:47:44,200 --> 00:47:48,880
off the stage

00:47:45,850 --> 00:47:52,900
a lot of clang which maybe you've come

00:47:48,880 --> 00:47:55,690
across as a C compiler is also following

00:47:52,900 --> 00:47:58,690
this same approach with the rest of LLVM

00:47:55,690 --> 00:48:02,320
so it is also really modular so you can

00:47:58,690 --> 00:48:04,810
use Lib clang to pass header files you

00:48:02,320 --> 00:48:08,340
can get the type encodings for those and

00:48:04,810 --> 00:48:12,250
the names and you can do FFI without any

00:48:08,340 --> 00:48:14,590
you know and any need for custom header

00:48:12,250 --> 00:48:19,330
file passes or for defining how things

00:48:14,590 --> 00:48:21,340
map from C to your language and we do

00:48:19,330 --> 00:48:23,410
this in pragmatic small talk where you

00:48:21,340 --> 00:48:26,530
just send a message to this C pseudo

00:48:23,410 --> 00:48:29,230
class and it knows that that's supposed

00:48:26,530 --> 00:48:31,990
to be a C function call and so it will

00:48:29,230 --> 00:48:33,250
check in your headers find a function

00:48:31,990 --> 00:48:35,650
that has a name matching that

00:48:33,250 --> 00:48:37,720
message and it will just work by magic

00:48:35,650 --> 00:48:41,280
and now I'm going to stop speaking

00:48:37,720 --> 00:48:41,280
before they shout at me

00:48:53,589 --> 00:49:00,069
you have to go to the microphone and

00:48:56,509 --> 00:49:00,069
then they can hear what you're saying

00:49:00,970 --> 00:49:06,309
we've got time for maybe one or two

00:49:03,140 --> 00:49:06,309
questions but that's it

00:49:18,100 --> 00:49:22,840
the earlier question was are these

00:49:19,870 --> 00:49:25,240
slides online the earlier question was

00:49:22,840 --> 00:49:30,160
are these slides online which you just

00:49:25,240 --> 00:49:32,310
answered no are the slides you just

00:49:30,160 --> 00:49:35,590
presented online

00:49:32,310 --> 00:49:36,310
I want to annotate them before I put

00:49:35,590 --> 00:49:39,070
them online

00:49:36,310 --> 00:49:42,370
have you considered having a application

00:49:39,070 --> 00:49:46,870
specific language like this for writing

00:49:42,370 --> 00:49:49,360
compilers yeah actually one of the

00:49:46,870 --> 00:49:51,700
things that is interesting is if you

00:49:49,360 --> 00:49:53,770
look at the album optimization passes a

00:49:51,700 --> 00:49:56,650
lot of them are doing a sort of pattern

00:49:53,770 --> 00:49:58,990
matching that is really ad hoc that

00:49:56,650 --> 00:50:00,580
really should be done by some pattern

00:49:58,990 --> 00:50:03,250
matching language so one thing I'd like

00:50:00,580 --> 00:50:06,940
to do is have an optimization past

00:50:03,250 --> 00:50:12,340
language it seems like your code was

00:50:06,940 --> 00:50:16,210
mostly using the the the api's for LLVM

00:50:12,340 --> 00:50:18,220
to put to build up something so if you

00:50:16,210 --> 00:50:20,260
had a language where there were

00:50:18,220 --> 00:50:23,140
operators that did precisely that it

00:50:20,260 --> 00:50:24,760
might be easier to write yeah I mean

00:50:23,140 --> 00:50:27,880
another thing that would be interesting

00:50:24,760 --> 00:50:29,830
is taking something like clang and just

00:50:27,880 --> 00:50:32,950
extending it so you write C code with

00:50:29,830 --> 00:50:33,940
placeholders and then let you fill in

00:50:32,950 --> 00:50:37,650
the gaps

00:50:33,940 --> 00:50:37,650
sort of like person yeah

00:50:42,809 --> 00:50:46,469
and people are running to their next

00:50:44,489 --> 00:50:52,729
talk I think people are running to their

00:50:46,469 --> 00:50:52,729

YouTube URL: https://www.youtube.com/watch?v=1Hwnagof1Wo


