Title: QA tools for FOSS distributions
Publication date: 2013-02-05
Playlist: FOSDEM 2012
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,800 --> 00:00:07,470
hello everybody my name is Pedro but I'm

00:00:05,069 --> 00:00:09,000
talking here for the monk Uzi project

00:00:07,470 --> 00:00:14,400
that it's a project that recently

00:00:09,000 --> 00:00:18,270
concluded in about six months ago it's a

00:00:14,400 --> 00:00:20,840
it's a project about trying to manage

00:00:18,270 --> 00:00:23,189
the complexity of open-source

00:00:20,840 --> 00:00:28,500
distributions any particular component

00:00:23,189 --> 00:00:30,660
based systems the there are other people

00:00:28,500 --> 00:00:33,420
working with me in in this project when

00:00:30,660 --> 00:00:37,500
it's rough dryland then yep bon de

00:00:33,420 --> 00:00:39,570
Stefano securely Roberto de Cosmo wrong

00:00:37,500 --> 00:00:46,110
boo Yong yes English odd and other

00:00:39,570 --> 00:00:49,070
people in in Paris so why why we came

00:00:46,110 --> 00:00:52,170
over here the Mancusi project has been a

00:00:49,070 --> 00:00:55,260
academically a really successful project

00:00:52,170 --> 00:00:57,600
has been very well rated by the European

00:00:55,260 --> 00:01:00,870
community and everybody clap hands and

00:00:57,600 --> 00:01:05,040
we're very happy about our job that that

00:01:00,870 --> 00:01:07,860
we're done over there it's a bit of but

00:01:05,040 --> 00:01:11,070
one main goal of this project was to

00:01:07,860 --> 00:01:14,909
reach on on the developer community and

00:01:11,070 --> 00:01:17,070
to try to integrate our our working in

00:01:14,909 --> 00:01:18,990
open-source distributions and to try to

00:01:17,070 --> 00:01:20,759
make to make a difference after all this

00:01:18,990 --> 00:01:23,580
is a European project has been found out

00:01:20,759 --> 00:01:25,320
with your money and would be nice to

00:01:23,580 --> 00:01:27,810
actually benefit about the results of

00:01:25,320 --> 00:01:30,689
this project so the democracy project

00:01:27,810 --> 00:01:35,220
was completely finished about six months

00:01:30,689 --> 00:01:37,350
ago and we develop a bunch of tools that

00:01:35,220 --> 00:01:41,970
today I'm going to the presenter not

00:01:37,350 --> 00:01:44,820
going to go in the specificity of every

00:01:41,970 --> 00:01:47,670
tool and every small algorithm and there

00:01:44,820 --> 00:01:51,329
is a lot of academic blah blah published

00:01:47,670 --> 00:01:53,880
on our website today what I'm going to

00:01:51,329 --> 00:01:58,020
present is just how you can use and how

00:01:53,880 --> 00:02:00,659
you can benefit from from these tools so

00:01:58,020 --> 00:02:04,290
what we wanted to do was to basically

00:02:00,659 --> 00:02:06,570
work on four different different aspects

00:02:04,290 --> 00:02:09,780
of the distributions one we wanted to

00:02:06,570 --> 00:02:11,910
detect those packages that were broken

00:02:09,780 --> 00:02:12,510
not installable this is already part of

00:02:11,910 --> 00:02:15,780
an old

00:02:12,510 --> 00:02:18,060
Roger that was the pretty success or

00:02:15,780 --> 00:02:19,590
lesser predecessor so the mikoshi

00:02:18,060 --> 00:02:22,290
brother that is called the Eddas project

00:02:19,590 --> 00:02:25,230
and probably many people here know about

00:02:22,290 --> 00:02:28,860
the duty duty a dose least check that

00:02:25,230 --> 00:02:31,220
it's in debian mandriva and AXA magic

00:02:28,860 --> 00:02:35,310
and other distributions another

00:02:31,220 --> 00:02:37,709
something novel tool that we developed

00:02:35,310 --> 00:02:41,030
recently was a package to detect those

00:02:37,709 --> 00:02:43,890
packages that need manual interventions

00:02:41,030 --> 00:02:45,989
because their metadata is outdated and

00:02:43,890 --> 00:02:48,720
there is no other ways of fixing this

00:02:45,989 --> 00:02:51,000
package then to change the metadata so

00:02:48,720 --> 00:02:54,239
this is basically a subset of the broken

00:02:51,000 --> 00:02:58,220
packages in the first category then we

00:02:54,239 --> 00:03:01,709
want to wanted to give a stab to try to

00:02:58,220 --> 00:03:04,409
to detect those packages that are

00:03:01,709 --> 00:03:05,909
somehow important in the distributions

00:03:04,409 --> 00:03:08,639
just looking at the meta data these

00:03:05,909 --> 00:03:11,400
packages are those packages that if

00:03:08,639 --> 00:03:14,579
change they're going to break or affect

00:03:11,400 --> 00:03:17,730
a large number of other packages and

00:03:14,579 --> 00:03:19,530
just by looking at the the dependency

00:03:17,730 --> 00:03:22,949
where this is a bit difficult so we try

00:03:19,530 --> 00:03:25,980
to actually share a bit of light on this

00:03:22,949 --> 00:03:29,760
problem and try to untangle this on this

00:03:25,980 --> 00:03:35,040
web and the last point is we wanted to

00:03:29,760 --> 00:03:37,829
actually see and guess what happens in

00:03:35,040 --> 00:03:42,239
the future if we modify if we upgrade a

00:03:37,829 --> 00:03:43,919
package to to a newer version so this is

00:03:42,239 --> 00:03:47,250
a kind of go in a direction of

00:03:43,919 --> 00:03:48,930
predicting what's going to happen in the

00:03:47,250 --> 00:03:53,459
future when we have great just one

00:03:48,930 --> 00:03:58,680
component or a class of components so

00:03:53,459 --> 00:04:02,090
the oops so the first tool that I'm

00:03:58,680 --> 00:04:05,150
going to present is this check this is a

00:04:02,090 --> 00:04:09,569
diss track as a bit of history because

00:04:05,150 --> 00:04:13,079
it's been developed for the arrows

00:04:09,569 --> 00:04:15,650
project back in 2005 and the first

00:04:13,079 --> 00:04:18,949
version was spend alone

00:04:15,650 --> 00:04:23,240
standalone tool written by jerome bhuyan

00:04:18,949 --> 00:04:29,449
then has been integrated in the suite

00:04:23,240 --> 00:04:32,210
those that um it's a no cam library that

00:04:29,449 --> 00:04:35,210
it's meant to study dependencies for

00:04:32,210 --> 00:04:38,449
software distributions and nowadays on

00:04:35,210 --> 00:04:40,400
just on component based systems not just

00:04:38,449 --> 00:04:43,699
focusing on software distribution it's

00:04:40,400 --> 00:04:45,770
more general even though here we look at

00:04:43,699 --> 00:04:50,600
suffer distribution in particular in

00:04:45,770 --> 00:04:52,910
2006 we we uploaded a head of state

00:04:50,600 --> 00:04:57,760
check in many distributions and has been

00:04:52,910 --> 00:05:02,750
integrated in many QA tools so far and

00:04:57,760 --> 00:05:06,250
then in 2009 we started rewriting the

00:05:02,750 --> 00:05:10,030
those sweet and as part of this the

00:05:06,250 --> 00:05:14,509
district so the feature of this check

00:05:10,030 --> 00:05:17,599
it's um it's just the tool to detect

00:05:14,509 --> 00:05:19,729
which packages cannot be installed how

00:05:17,599 --> 00:05:21,800
we do it we encode the the entire

00:05:19,729 --> 00:05:24,470
distribution and SAT solver use a bit of

00:05:21,800 --> 00:05:26,449
logic and we use a specific set solar

00:05:24,470 --> 00:05:30,669
that has been written for this purpose

00:05:26,449 --> 00:05:32,990
that it's a very fast and performant and

00:05:30,669 --> 00:05:36,080
allow us to answer this question a

00:05:32,990 --> 00:05:38,659
matter of a few seconds here it except

00:05:36,080 --> 00:05:41,030
different input format so as I was

00:05:38,659 --> 00:05:43,669
saying is not just for one distribution

00:05:41,030 --> 00:05:46,010
but we can talk with debian RPM and

00:05:43,669 --> 00:05:48,500
nowadays now we can also look at the

00:05:46,010 --> 00:05:54,139
Eclipse plug-in system that it's another

00:05:48,500 --> 00:05:58,550
component based system and an other

00:05:54,139 --> 00:06:00,770
formalism that we were going to add in

00:05:58,550 --> 00:06:02,590
the future so he handles compress

00:06:00,770 --> 00:06:06,620
archive so we don't have to bother about

00:06:02,590 --> 00:06:09,669
busy poor gzip or anything else you

00:06:06,620 --> 00:06:13,159
serious UDF it's a generic format that

00:06:09,669 --> 00:06:16,340
try to be one of this interchange format

00:06:13,159 --> 00:06:18,979
for all the metadata in different

00:06:16,340 --> 00:06:23,090
distributions what we do we translate

00:06:18,979 --> 00:06:25,700
the different inputs in in CDF and then

00:06:23,090 --> 00:06:27,639
we'll you see the f4 for the analysis

00:06:25,700 --> 00:06:32,740
this allow us to be more modular

00:06:27,639 --> 00:06:37,330
and to not do add back hands as as they

00:06:32,740 --> 00:06:39,550
can one goal of this check was to be

00:06:37,330 --> 00:06:43,180
easily scriptable so we choose a yam a

00:06:39,550 --> 00:06:45,759
laser output format and that it's a nice

00:06:43,180 --> 00:06:50,340
format that can be interpreted by human

00:06:45,759 --> 00:06:53,740
and easily parse by by a machine and

00:06:50,340 --> 00:06:56,529
least it's a twice as fast as its

00:06:53,740 --> 00:06:58,629
predecessor and there is still a bit of

00:06:56,529 --> 00:07:02,590
room of for improvement this is very

00:06:58,629 --> 00:07:06,250
good as if you have ten ten

00:07:02,590 --> 00:07:08,409
architectures and five releases and I

00:07:06,250 --> 00:07:10,960
don't know what you want to not to spend

00:07:08,409 --> 00:07:16,860
alpha day testing if your packages can

00:07:10,960 --> 00:07:19,870
be broken or not so the the output of

00:07:16,860 --> 00:07:23,339
this check now let's look like this it's

00:07:19,870 --> 00:07:25,960
a year the list of packages where you

00:07:23,339 --> 00:07:29,050
you have a report for every broken

00:07:25,960 --> 00:07:31,110
package and at the end they give you the

00:07:29,050 --> 00:07:34,029
number of background back the number

00:07:31,110 --> 00:07:35,439
give issues informations the these are

00:07:34,029 --> 00:07:38,110
the total number of packages that you

00:07:35,439 --> 00:07:39,460
analyze these are the number of broken

00:07:38,110 --> 00:07:41,710
packages packages that are not

00:07:39,460 --> 00:07:43,389
installable and these two are the

00:07:41,710 --> 00:07:47,289
foreground and background packages as

00:07:43,389 --> 00:07:50,399
you can specify for example use I don't

00:07:47,289 --> 00:07:54,789
know about 20,000 binary packages but

00:07:50,399 --> 00:07:57,339
Annalise only 10 of them and in this way

00:07:54,789 --> 00:08:02,740
it's it's a nice way to to select which

00:07:57,339 --> 00:08:07,000
package we want to focus on if we go

00:08:02,740 --> 00:08:09,159
deeper we I give you two example of how

00:08:07,000 --> 00:08:13,229
a package can be broken so in this case

00:08:09,159 --> 00:08:15,939
a PDR p.m. repository is broken we have

00:08:13,229 --> 00:08:17,529
different informations and the reason

00:08:15,939 --> 00:08:20,229
why this package is broken is because

00:08:17,529 --> 00:08:22,689
there is a dependency that is not

00:08:20,229 --> 00:08:27,939
satisfied basically because this package

00:08:22,689 --> 00:08:31,719
is not in Nam in is not in the in the

00:08:27,939 --> 00:08:33,159
archive at the moment another another

00:08:31,719 --> 00:08:37,120
example that it's a bit more complicated

00:08:33,159 --> 00:08:40,209
it's an example of a conflict so he said

00:08:37,120 --> 00:08:40,840
that the G forge web Apache package

00:08:40,209 --> 00:08:42,250
cannot be

00:08:40,840 --> 00:08:44,500
stole because there is a conflict

00:08:42,250 --> 00:08:48,070
between these two packages and on the

00:08:44,500 --> 00:08:50,500
other end we have the the chain of

00:08:48,070 --> 00:08:52,270
dependencies because when you have a

00:08:50,500 --> 00:08:55,540
comp a conflict between two packages

00:08:52,270 --> 00:08:58,090
they are not it might be not a conflict

00:08:55,540 --> 00:09:00,310
that is directed to the package that you

00:08:58,090 --> 00:09:03,880
are looking at but it can be hidden deep

00:09:00,310 --> 00:09:07,540
in the dependency tree and our tool kind

00:09:03,880 --> 00:09:09,970
of give you the how to reach that on

00:09:07,540 --> 00:09:13,450
that package and show you that there is

00:09:09,970 --> 00:09:15,400
a epic a conflict between this package

00:09:13,450 --> 00:09:18,790
at you're trying to analyze and the

00:09:15,400 --> 00:09:23,640
pattern 26 minimal that is deep in the

00:09:18,790 --> 00:09:27,100
dependency drink so as I said it's

00:09:23,640 --> 00:09:29,550
easily scriptable and if you want to

00:09:27,100 --> 00:09:32,470
load the output of this check you can

00:09:29,550 --> 00:09:39,580
extract very easily all the informations

00:09:32,470 --> 00:09:41,020
with a few lines of Python and if if

00:09:39,580 --> 00:09:43,920
you're wondering sure it's useful for

00:09:41,020 --> 00:09:47,710
example this is the main the core of

00:09:43,920 --> 00:09:49,840
ubuntu where one package is not

00:09:47,710 --> 00:09:51,430
installable because it depends on a

00:09:49,840 --> 00:09:53,680
package that is outside the core and

00:09:51,430 --> 00:09:58,780
what the color is meant to be

00:09:53,680 --> 00:10:02,730
self-contained it depends on fglrx that

00:09:58,780 --> 00:10:06,580
is a non-free component well you can now

00:10:02,730 --> 00:10:16,810
you can get somewhere you can have nice

00:10:06,580 --> 00:10:19,210
results so a demo so I've prepared a few

00:10:16,810 --> 00:10:21,820
comments and I'm going to run few of

00:10:19,210 --> 00:10:23,620
them we do just because they are nice

00:10:21,820 --> 00:10:26,890
and fast and few others are not going to

00:10:23,620 --> 00:10:30,130
show you the result itself here what I'm

00:10:26,890 --> 00:10:34,900
going to do is to run its run this check

00:10:30,130 --> 00:10:36,970
I'm going to ask it to give me all the

00:10:34,900 --> 00:10:39,370
packages that are broken to give me

00:10:36,970 --> 00:10:42,670
explanation to tell me something to show

00:10:39,370 --> 00:10:45,490
me the progress and I'm going to tell to

00:10:42,670 --> 00:10:46,560
us to analyze what's in my machine at

00:10:45,490 --> 00:10:53,550
the moment

00:10:46,560 --> 00:10:58,680
and if I cut them based this and I run

00:10:53,550 --> 00:11:03,270
it it takes about five six seconds to do

00:10:58,680 --> 00:11:05,130
it at least he did it this morning so

00:11:03,270 --> 00:11:06,810
what it as i initialize the solver and

00:11:05,130 --> 00:11:10,589
then i start spitting out all the

00:11:06,810 --> 00:11:11,940
packages that are broken and as you

00:11:10,589 --> 00:11:15,240
might notice today there are a lot of

00:11:11,940 --> 00:11:18,770
broken packages there are about 300

00:11:15,240 --> 00:11:23,070
broken packages cigna in debian unstable

00:11:18,770 --> 00:11:24,779
boo boo boo boo boo boo if you don't

00:11:23,070 --> 00:11:27,300
know if you don't ask to auto point

00:11:24,779 --> 00:11:31,650
everything on screen maybe it's a it's a

00:11:27,300 --> 00:11:35,490
bit faster okay I love to today I'm

00:11:31,650 --> 00:11:38,640
automatic tools because they they don't

00:11:35,490 --> 00:11:40,650
require too much effort for me um so

00:11:38,640 --> 00:11:45,330
where is insta it's used in einem begin

00:11:40,650 --> 00:11:47,580
to check in on the tool chain of

00:11:45,330 --> 00:11:49,800
embedding it's internally used by the

00:11:47,580 --> 00:11:53,280
mandriva QA team and a cox illogicality

00:11:49,800 --> 00:11:55,290
it's the engine of the gun water that

00:11:53,280 --> 00:11:59,190
you might have heard of that it's

00:11:55,290 --> 00:12:01,620
maintained by by our team and i recently

00:11:59,190 --> 00:12:03,660
discovered that is used in simple CDD

00:12:01,620 --> 00:12:09,150
that it's a small ability to create

00:12:03,660 --> 00:12:12,480
custom debian installation CD and in

00:12:09,150 --> 00:12:18,020
fight conflicts that it's a that it's

00:12:12,480 --> 00:12:21,960
not a small tool written by by us so

00:12:18,020 --> 00:12:25,550
another something else about proper

00:12:21,960 --> 00:12:29,130
direction it's debian bill check now

00:12:25,550 --> 00:12:33,000
when when using this check with just the

00:12:29,130 --> 00:12:34,890
busy looking only on the on the binary

00:12:33,000 --> 00:12:38,070
packages but this problem can be

00:12:34,890 --> 00:12:39,810
extended also on the source packages and

00:12:38,070 --> 00:12:42,839
we want to make sure that before

00:12:39,810 --> 00:12:44,040
actually trying to build a package we're

00:12:42,839 --> 00:12:46,770
going to be able to be the package

00:12:44,040 --> 00:12:48,750
otherwise we're going to maybe set up a

00:12:46,770 --> 00:12:50,370
virtual machine and unload all the

00:12:48,750 --> 00:12:52,770
packages just to find out that there was

00:12:50,370 --> 00:12:59,300
one package missing and all this time

00:12:52,770 --> 00:12:59,300
was just wasted so what what we do with

00:12:59,490 --> 00:13:05,640
the wheel dependencies as normal

00:13:02,370 --> 00:13:09,480
dependencies and then we run we run the

00:13:05,640 --> 00:13:14,070
same the same tool on on this encoding

00:13:09,480 --> 00:13:16,740
these allow to discover if a package

00:13:14,070 --> 00:13:18,930
could be installed or not he runs a bit

00:13:16,740 --> 00:13:20,970
faster this is an old application as

00:13:18,930 --> 00:13:23,760
well from from the itis project it runs

00:13:20,970 --> 00:13:26,970
a bit faster than a dose will check it's

00:13:23,760 --> 00:13:32,870
just a wrapper around I just this check

00:13:26,970 --> 00:13:37,670
and as the same output of of this check

00:13:32,870 --> 00:13:41,490
that is young etc etc so an example of

00:13:37,670 --> 00:13:43,529
this tool it's very similar as what I've

00:13:41,490 --> 00:13:45,720
shown you before not you think that

00:13:43,529 --> 00:13:48,089
certain packages are have a small

00:13:45,720 --> 00:13:50,430
projects that it serves semicolon and

00:13:48,089 --> 00:13:51,930
name of the package and basically tells

00:13:50,430 --> 00:13:57,390
you that this is a source package and

00:13:51,930 --> 00:13:59,640
what we have done is we try to to to see

00:13:57,390 --> 00:14:03,360
if the older build abundances of this

00:13:59,640 --> 00:14:06,000
source packages actually the they are

00:14:03,360 --> 00:14:07,829
satisfied and here we found that this

00:14:06,000 --> 00:14:10,140
package cannot be installed because it

00:14:07,829 --> 00:14:13,170
depen their bill dependencies it depends

00:14:10,140 --> 00:14:16,350
by two packages that actually are in

00:14:13,170 --> 00:14:19,529
conflict with each other and this is one

00:14:16,350 --> 00:14:26,459
of all the small problems that we can

00:14:19,529 --> 00:14:31,829
that we can find compelling packages so

00:14:26,459 --> 00:14:33,959
a second demo that as you might have

00:14:31,829 --> 00:14:42,110
guessed is not going to be too exciting

00:14:33,959 --> 00:14:48,420
either it's about this one so here oops

00:14:42,110 --> 00:14:52,529
here I'm using the all the binary

00:14:48,420 --> 00:14:54,630
packages in a begginer stable and trying

00:14:52,529 --> 00:14:57,480
to recompile all the source packages in

00:14:54,630 --> 00:15:00,510
the immune unstable looking at only one

00:14:57,480 --> 00:15:03,240
architecture and I want to know the the

00:15:00,510 --> 00:15:06,360
broken packages and some kind of

00:15:03,240 --> 00:15:08,190
explanation from it so now this one it's

00:15:06,360 --> 00:15:10,709
a bit slower because before we are

00:15:08,190 --> 00:15:12,960
analyzing about 30,000 peg 35,000

00:15:10,709 --> 00:15:15,990
packages here we are jumping

00:15:12,960 --> 00:15:20,010
and we're analyzing about I think about

00:15:15,990 --> 00:15:35,490
50,000 packages or something I forgot

00:15:20,010 --> 00:15:37,050
progress and that's stuff minus V so we

00:15:35,490 --> 00:15:39,780
analyzed the source file and then we

00:15:37,050 --> 00:15:43,620
analyzed the binary packages and then we

00:15:39,780 --> 00:15:48,510
make we encode the bill dependencies so

00:15:43,620 --> 00:15:51,930
here we analyze a lot about 36,000

00:15:48,510 --> 00:16:03,780
packages and a lot of broken packages up

00:15:51,930 --> 00:16:05,790
and down dot outdated packages so the

00:16:03,780 --> 00:16:08,790
first two were two applications that

00:16:05,790 --> 00:16:11,010
were already known it's kind of easy to

00:16:08,790 --> 00:16:12,690
figure out what what they are doing

00:16:11,010 --> 00:16:15,270
because they were just looking at the

00:16:12,690 --> 00:16:18,390
broken packages outdated packages look

00:16:15,270 --> 00:16:21,420
for a subset of the broken packages that

00:16:18,390 --> 00:16:25,440
require manual intervention and ongoing

00:16:21,420 --> 00:16:28,470
a bit ly / here to explain what manual

00:16:25,440 --> 00:16:31,140
intervention means so a package is

00:16:28,470 --> 00:16:33,450
broken for basically two reason iterates

00:16:31,140 --> 00:16:36,000
a transient problem so it depends on the

00:16:33,450 --> 00:16:37,650
package it is not available or it

00:16:36,000 --> 00:16:41,640
depends on a package that is not

00:16:37,650 --> 00:16:45,770
installable but we also have known

00:16:41,640 --> 00:16:48,930
transient problem this these are the

00:16:45,770 --> 00:16:55,560
problems where the package itself need

00:16:48,930 --> 00:16:58,770
to have is meta data fixed to to be to

00:16:55,560 --> 00:17:01,320
be to bestow level again because maybe

00:16:58,770 --> 00:17:02,610
it depends on a package that is never

00:17:01,320 --> 00:17:06,240
gonna be in the distribution

00:17:02,610 --> 00:17:08,100
distribution again because it's these

00:17:06,240 --> 00:17:09,450
packages become outdated and a new

00:17:08,100 --> 00:17:11,850
version of package has been already

00:17:09,450 --> 00:17:13,800
uploaded in this distribution so I have

00:17:11,850 --> 00:17:15,839
to change the meta data in order to fix

00:17:13,800 --> 00:17:19,130
this problem so I'm going to give you a

00:17:15,839 --> 00:17:21,600
couple of example so for example here

00:17:19,130 --> 00:17:23,940
here we are focusing on on the package

00:17:21,600 --> 00:17:26,550
fool if you look at fool that depends on

00:17:23,940 --> 00:17:30,000
the package bar version

00:17:26,550 --> 00:17:31,530
too and we asked the question is this

00:17:30,000 --> 00:17:33,570
going to be installable in the future

00:17:31,530 --> 00:17:35,580
well the answer is clearly yes we don't

00:17:33,570 --> 00:17:37,950
have to do anything on full we just need

00:17:35,580 --> 00:17:40,230
to upgrade bar to version 2 and food is

00:17:37,950 --> 00:17:42,510
going to be install a ball again this

00:17:40,230 --> 00:17:44,310
often happen when we upgrade a new

00:17:42,510 --> 00:17:46,530
package that depends for example on a

00:17:44,310 --> 00:17:49,080
package well I'm talking in that in

00:17:46,530 --> 00:17:51,990
debian experimental and we need to to

00:17:49,080 --> 00:17:55,020
wait for the new package to to get in in

00:17:51,990 --> 00:17:57,960
debian unstable so there are there is a

00:17:55,020 --> 00:18:00,990
small delay and we don't have to do

00:17:57,960 --> 00:18:03,510
anything on anything to food we just

00:18:00,990 --> 00:18:08,250
need to wait for bart version 2 to

00:18:03,510 --> 00:18:11,100
appear if we change a bit the situation

00:18:08,250 --> 00:18:15,570
now bar depends on a version that is

00:18:11,100 --> 00:18:16,980
less than less than 2 so doesn't matter

00:18:15,570 --> 00:18:19,020
what bar is going to become in the

00:18:16,980 --> 00:18:21,330
future for example version 3 version 4

00:18:19,020 --> 00:18:22,920
version 5 who is never going to be

00:18:21,330 --> 00:18:25,620
installable because i need something

00:18:22,920 --> 00:18:32,250
that is smaller than two so in this case

00:18:25,620 --> 00:18:33,420
i need to change this meta data to to

00:18:32,250 --> 00:18:38,040
make sure that foo is going to be

00:18:33,420 --> 00:18:42,420
installable again so if we go in a more

00:18:38,040 --> 00:18:45,090
complex example so we look at foo and we

00:18:42,420 --> 00:18:50,040
have packaged bar and package bus now

00:18:45,090 --> 00:18:52,260
the the dependencies are a bit bit more

00:18:50,040 --> 00:18:53,640
complex and the question that we ask is

00:18:52,260 --> 00:18:55,050
always the same is for going to be

00:18:53,640 --> 00:18:58,200
installed obel in the future surely it's

00:18:55,050 --> 00:19:02,460
not installable now because it depends

00:18:58,200 --> 00:19:09,210
on bus version 2.5 or bad version 2.3

00:19:02,460 --> 00:19:12,090
and on bar and buzz but in the future we

00:19:09,210 --> 00:19:13,800
can kind of think of a situation where

00:19:12,090 --> 00:19:17,340
the baggage food is going to be

00:19:13,800 --> 00:19:18,930
installed without requiring any any

00:19:17,340 --> 00:19:21,810
modification to the meta data flow

00:19:18,930 --> 00:19:26,210
itself because if we go to a show you

00:19:21,810 --> 00:19:29,130
future where bus is of version 2.5 and

00:19:26,210 --> 00:19:32,910
without any conflict because in the

00:19:29,130 --> 00:19:34,950
future packages can can evolve in any in

00:19:32,910 --> 00:19:37,660
any way so we can imagine that the

00:19:34,950 --> 00:19:41,860
package powering version 2.5

00:19:37,660 --> 00:19:43,240
drop the drop the conflict this we are

00:19:41,860 --> 00:19:45,310
taking an over approximation here

00:19:43,240 --> 00:19:52,170
packages sometimes there are a bit more

00:19:45,310 --> 00:19:55,390
conservative and we get a version of bar

00:19:52,170 --> 00:19:58,780
of version in between two point six and

00:19:55,390 --> 00:20:00,910
three then this this constraint here is

00:19:58,780 --> 00:20:05,710
going to be satisfied so this is another

00:20:00,910 --> 00:20:07,420
situation where even with the complex

00:20:05,710 --> 00:20:09,730
constraint we can kind of figure out

00:20:07,420 --> 00:20:12,700
what what is going to happen in the

00:20:09,730 --> 00:20:16,300
future however if we look at the

00:20:12,700 --> 00:20:19,020
situation like this now the package full

00:20:16,300 --> 00:20:22,570
requirement requires my intervention

00:20:19,020 --> 00:20:24,670
because if we choose now here we have

00:20:22,570 --> 00:20:27,370
two possibilities either which was bar

00:20:24,670 --> 00:20:30,610
or which either which was bus or which

00:20:27,370 --> 00:20:33,370
was bar if we choose bars of version 2.5

00:20:30,610 --> 00:20:35,080
this is going to be this is going to

00:20:33,370 --> 00:20:38,440
select this package that is going to be

00:20:35,080 --> 00:20:41,290
in conflict with bar 2.5 and this is

00:20:38,440 --> 00:20:44,260
going to be in conflict with this we dis

00:20:41,290 --> 00:20:49,840
constraint up here if we choose bar to

00:20:44,260 --> 00:20:53,770
point through to 2.3 then this is not

00:20:49,840 --> 00:20:57,460
possible because if we choose bar 2.3 I

00:20:53,770 --> 00:21:02,020
have to choose something that it's less

00:20:57,460 --> 00:21:05,950
than two point then two then 2.3 here

00:21:02,020 --> 00:21:10,180
but in the repository version 2.5 so

00:21:05,950 --> 00:21:13,540
these are all this kind of strange

00:21:10,180 --> 00:21:16,170
situation where we can we can bump into

00:21:13,540 --> 00:21:20,350
and we develop a tool to actually

00:21:16,170 --> 00:21:24,580
identify all these packages manually foo

00:21:20,350 --> 00:21:26,410
and try to flag the order of this

00:21:24,580 --> 00:21:28,360
package that this package need its

00:21:26,410 --> 00:21:39,270
dependencies to be modified in order to

00:21:28,360 --> 00:21:39,270
be installable again so now ah ok demo

00:21:39,570 --> 00:21:54,309
so here

00:21:41,110 --> 00:21:58,630
oops here again I'm going to I'm going

00:21:54,309 --> 00:22:01,270
to run this this tool and this one is

00:21:58,630 --> 00:22:03,790
going to take a bit longer it basically

00:22:01,270 --> 00:22:07,600
used the same engine of this check but

00:22:03,790 --> 00:22:10,450
this time since I have to consider all

00:22:07,600 --> 00:22:12,190
possible futures all possible way of how

00:22:10,450 --> 00:22:16,000
these packages are going to evolve I

00:22:12,190 --> 00:22:18,160
need to to consider a much larger

00:22:16,000 --> 00:22:25,390
universe and in this case is going to be

00:22:18,160 --> 00:22:28,570
about 80,000 packages I also try to make

00:22:25,390 --> 00:22:32,140
sure that i consider the source clusters

00:22:28,570 --> 00:22:35,710
so I don't let packages to advance one

00:22:32,140 --> 00:22:38,700
by one but in clusters because we don't

00:22:35,710 --> 00:22:42,850
want to end up in the situation where

00:22:38,700 --> 00:22:45,100
for example we have a version of the

00:22:42,850 --> 00:22:47,620
gnome tree and a version of Guam to in

00:22:45,100 --> 00:22:50,350
my distribution I want either belong to

00:22:47,620 --> 00:22:54,910
or the cluster of grown on three all

00:22:50,350 --> 00:23:03,929
together this is going to take a bit of

00:22:54,910 --> 00:23:03,929
time and now papa

00:23:08,140 --> 00:23:18,690
okay we're going to come back there so

00:23:14,350 --> 00:23:22,630
Adam now I've been talking about these

00:23:18,690 --> 00:23:26,230
three tools that are meant to protect

00:23:22,630 --> 00:23:30,610
broken packages to flag Monta nurse

00:23:26,230 --> 00:23:36,130
about broken packages and to try to to

00:23:30,610 --> 00:23:39,430
release distributions that where every

00:23:36,130 --> 00:23:42,100
package can be installed now we're going

00:23:39,430 --> 00:23:45,730
on on something that it's it's more on

00:23:42,100 --> 00:23:48,370
the try to figure out how the

00:23:45,730 --> 00:23:51,720
distribution is going to evolve and what

00:23:48,370 --> 00:23:54,250
are the important packages and how

00:23:51,720 --> 00:23:55,750
packages can can evolve and what would

00:23:54,250 --> 00:23:59,980
they will break in the future if they

00:23:55,750 --> 00:24:01,870
evolve in in a certain way so the first

00:23:59,980 --> 00:24:03,550
thing I want to do it's about talking

00:24:01,870 --> 00:24:05,500
about this dis concept of strong

00:24:03,550 --> 00:24:09,970
dependencies we already talked about it

00:24:05,500 --> 00:24:13,360
I think about two years ago and this

00:24:09,970 --> 00:24:17,110
kind of came back a while ago was at

00:24:13,360 --> 00:24:18,940
linux humph australia and the one of the

00:24:17,110 --> 00:24:21,370
release manager of ubuntu gave a

00:24:18,940 --> 00:24:23,680
presentation that was exactly about this

00:24:21,370 --> 00:24:26,770
so rise my hand and say we have all the

00:24:23,680 --> 00:24:29,080
solution of your problems and so since

00:24:26,770 --> 00:24:31,210
this seems relevant to them I wanted to

00:24:29,080 --> 00:24:34,570
to come back to it and try to explain

00:24:31,210 --> 00:24:37,180
what what this is all about so the idea

00:24:34,570 --> 00:24:39,280
is to try to to understand which

00:24:37,180 --> 00:24:42,460
packages are important for for our

00:24:39,280 --> 00:24:46,210
distributions this is the the notion of

00:24:42,460 --> 00:24:48,280
important is related if I have a bug in

00:24:46,210 --> 00:24:50,470
a package which other packages are going

00:24:48,280 --> 00:24:57,580
to be impacted by this bug so it's kind

00:24:50,470 --> 00:25:01,000
of try to do to understand how a bug

00:24:57,580 --> 00:25:03,400
spread in in my distribution or if i

00:25:01,000 --> 00:25:05,500
upgrade one package which other packages

00:25:03,400 --> 00:25:09,540
are going to be impacted by this body's

00:25:05,500 --> 00:25:09,540
upgrade so

00:25:11,749 --> 00:25:20,850
if I look only at the the web of

00:25:17,610 --> 00:25:22,679
dependencies this is a bit bit too

00:25:20,850 --> 00:25:25,619
coarse and it's a bit too complex for

00:25:22,679 --> 00:25:29,039
for human to analyze what we wanted is

00:25:25,619 --> 00:25:31,350
wanted to have a certain measure of the

00:25:29,039 --> 00:25:36,110
packages that are going to be to be

00:25:31,350 --> 00:25:41,070
affected by by a change so we define the

00:25:36,110 --> 00:25:43,710
notion of strong dependencies and the

00:25:41,070 --> 00:25:46,700
the notion of impacts at the impact site

00:25:43,710 --> 00:25:49,919
are those packages that are potentially

00:25:46,700 --> 00:25:52,679
affected by chances by changes in in a

00:25:49,919 --> 00:25:55,440
given package so it's a kind of a

00:25:52,679 --> 00:25:59,340
measure of how sensitive is this package

00:25:55,440 --> 00:26:02,789
on how careful we need to be when when

00:25:59,340 --> 00:26:04,529
touching this this package if as I said

00:26:02,789 --> 00:26:05,909
if we get the direct dependencies to

00:26:04,529 --> 00:26:09,240
little if you get a transitive closure

00:26:05,909 --> 00:26:17,249
of all dependencies is too much so we

00:26:09,240 --> 00:26:20,940
want to we need a stronger stronger

00:26:17,249 --> 00:26:23,100
definition the definition of strong

00:26:20,940 --> 00:26:26,730
dependency is actually very easy we say

00:26:23,100 --> 00:26:29,220
that p strong depending on cue if is not

00:26:26,730 --> 00:26:32,399
possible to install to install p without

00:26:29,220 --> 00:26:36,049
installing you so let's consider this

00:26:32,399 --> 00:26:41,279
dismal this small graph here we have

00:26:36,049 --> 00:26:44,190
packages that have either a DS junk a

00:26:41,279 --> 00:26:46,649
disjunctive dependency or they have a

00:26:44,190 --> 00:26:48,299
direct dependency or in this case there

00:26:46,649 --> 00:26:52,590
is a conflict between easy and George

00:26:48,299 --> 00:26:56,369
and here at the bottom we have Charlie

00:26:52,590 --> 00:27:03,019
and dog that both depend on Fox so what

00:26:56,369 --> 00:27:05,850
we want to what we want to do is to

00:27:03,019 --> 00:27:07,590
actually try to understand which are the

00:27:05,850 --> 00:27:09,899
important dependencies which are the

00:27:07,590 --> 00:27:12,889
strong dependencies and with a which are

00:27:09,899 --> 00:27:17,399
the all the others so in this case

00:27:12,889 --> 00:27:19,799
George it's a poison George is a

00:27:17,399 --> 00:27:21,580
conscience conjunctive dependency so in

00:27:19,799 --> 00:27:25,210
order to install able I must

00:27:21,580 --> 00:27:28,270
George because I really need it but if i

00:27:25,210 --> 00:27:30,490
install George that is in conflict with

00:27:28,270 --> 00:27:32,680
easy automatically these dependencies

00:27:30,490 --> 00:27:34,750
can never be satisfied and this imply

00:27:32,680 --> 00:27:39,660
that Baker map it must be installed all

00:27:34,750 --> 00:27:43,210
the time and at the same time since able

00:27:39,660 --> 00:27:46,150
depends both on cha on Charlie or on dog

00:27:43,210 --> 00:27:48,070
and both of them depends on Fox Fox must

00:27:46,150 --> 00:27:52,720
be installed all the time so we end up

00:27:48,070 --> 00:27:55,330
in a situation where able to in order to

00:27:52,720 --> 00:28:01,600
install able we always need Baker George

00:27:55,330 --> 00:28:05,680
and Fox doesn't matter what so this this

00:28:01,600 --> 00:28:07,300
give us a way of try to find out which

00:28:05,680 --> 00:28:13,090
are the packages that are really really

00:28:07,300 --> 00:28:15,940
important and the then we can end up

00:28:13,090 --> 00:28:21,060
with the weekend of the table where we

00:28:15,940 --> 00:28:27,190
can have this this list of packages that

00:28:21,060 --> 00:28:29,260
where we show the impact set of the for

00:28:27,190 --> 00:28:31,330
each package when we compare the impact

00:28:29,260 --> 00:28:32,890
site to the direct dependencies actually

00:28:31,330 --> 00:28:34,960
we found out that the direct

00:28:32,890 --> 00:28:40,840
dependencies didn't tell us a lot of a

00:28:34,960 --> 00:28:43,660
lot of things as we in in the first in

00:28:40,840 --> 00:28:45,820
the first five we have packages that

00:28:43,660 --> 00:28:47,050
maybe don't have that many drug

00:28:45,820 --> 00:28:49,810
dependencies but I have a lot of

00:28:47,050 --> 00:28:51,580
packages that depends on them and I so

00:28:49,810 --> 00:28:55,150
if we touch them that are really at the

00:28:51,580 --> 00:28:56,620
bottom of our web of dependencies we're

00:28:55,150 --> 00:28:58,750
going to break a lot a lot of packages

00:28:56,620 --> 00:29:05,440
because this these dependences are going

00:28:58,750 --> 00:29:08,590
to be propagated upward and this this

00:29:05,440 --> 00:29:12,760
give this give us a nice notion to to

00:29:08,590 --> 00:29:16,540
say if I migrate dpkg to a newer version

00:29:12,760 --> 00:29:18,370
probably I'm going to break about 13,000

00:29:16,540 --> 00:29:21,550
packages so at least these are very

00:29:18,370 --> 00:29:23,380
important package is fun going to to to

00:29:21,550 --> 00:29:26,170
upgrade this to a newer version maybe I

00:29:23,380 --> 00:29:29,010
need to check that all the packages has

00:29:26,170 --> 00:29:31,180
strong dependence a strong depend on in

00:29:29,010 --> 00:29:35,340
there going to be compatible with this

00:29:31,180 --> 00:29:35,340
with this migration which is upgrade

00:29:37,200 --> 00:29:48,850
another so um this is on the strong

00:29:45,460 --> 00:29:51,160
dependency side we also have a kind of a

00:29:48,850 --> 00:29:56,160
notion of that are not going to present

00:29:51,160 --> 00:29:59,320
today but the notion of domination so if

00:29:56,160 --> 00:30:01,390
if you look at the dependency the web

00:29:59,320 --> 00:30:05,920
dependency of our distribution you can

00:30:01,390 --> 00:30:09,940
kind of think what if I run one of the

00:30:05,920 --> 00:30:13,180
google rank algorithm not on despite of

00:30:09,940 --> 00:30:18,310
on these dependences this is going to

00:30:13,180 --> 00:30:20,260
give us the packages where most of most

00:30:18,310 --> 00:30:21,940
of the other packages depends and it's

00:30:20,260 --> 00:30:25,570
going to give you this this kind of hubs

00:30:21,940 --> 00:30:27,730
everywhere what what we've done is we

00:30:25,570 --> 00:30:29,800
have used a similar notion of strong

00:30:27,730 --> 00:30:33,130
dependencies that we have run a flow

00:30:29,800 --> 00:30:37,000
graph algorithm where we were able to

00:30:33,130 --> 00:30:40,570
find out the important packages even if

00:30:37,000 --> 00:30:45,550
those were hidden under other packages

00:30:40,570 --> 00:30:47,680
so imagine there was imagining if there

00:30:45,550 --> 00:30:50,020
is a very very important package where

00:30:47,680 --> 00:30:52,710
everybody depends but this one depends

00:30:50,020 --> 00:30:55,720
on on another one this means that

00:30:52,710 --> 00:30:59,440
actually there is a one package hidden

00:30:55,720 --> 00:31:05,730
down there that is not detected by our

00:30:59,440 --> 00:31:08,440
previous analysis this this Dominator

00:31:05,730 --> 00:31:10,900
algorithm allow us also to untangle

00:31:08,440 --> 00:31:12,940
these this kind of hidden packages and

00:31:10,900 --> 00:31:18,430
try to find out a bit more about the

00:31:12,940 --> 00:31:22,180
structure the last tool that I'm going

00:31:18,430 --> 00:31:25,750
to present its the the challenge

00:31:22,180 --> 00:31:29,890
packages here we are going to try to

00:31:25,750 --> 00:31:31,930
predict what is going to happen if in NC

00:31:29,890 --> 00:31:35,730
seats it's a prediction about the future

00:31:31,930 --> 00:31:39,850
is going to be another approximation so

00:31:35,730 --> 00:31:40,840
I'm not going to go deep in how we did

00:31:39,850 --> 00:31:43,000
it as

00:31:40,840 --> 00:31:49,390
it's a I don't have enough time today

00:31:43,000 --> 00:31:53,169
but what we wanted to do it's um it's

00:31:49,390 --> 00:31:54,850
who wanted to have a bit more than what

00:31:53,169 --> 00:31:56,080
we had with the strong dependencies with

00:31:54,850 --> 00:31:57,760
the strong dependence is where this

00:31:56,080 --> 00:32:02,890
notion of impact set and trying to

00:31:57,760 --> 00:32:06,970
understand what which packages were

00:32:02,890 --> 00:32:09,100
important now we want to to answer to

00:32:06,970 --> 00:32:11,919
this question what if we upgrade the

00:32:09,100 --> 00:32:16,090
package P to a version of a version v to

00:32:11,919 --> 00:32:18,330
a future version and how many packages

00:32:16,090 --> 00:32:23,679
are going to be affected by this upgrade

00:32:18,330 --> 00:32:27,610
and in particular the the main problem

00:32:23,679 --> 00:32:30,100
is which future version I'm going to to

00:32:27,610 --> 00:32:32,590
consider because I can consider all the

00:32:30,100 --> 00:32:35,740
future version as its I mean the future

00:32:32,590 --> 00:32:38,679
i think it's it's infinite I have to to

00:32:35,740 --> 00:32:42,580
try to find out specific versions that

00:32:38,679 --> 00:32:45,640
in relation with my Mary positive today

00:32:42,580 --> 00:32:48,970
today are going to be the most important

00:32:45,640 --> 00:32:51,399
tomorrow so as I said I want you to do

00:32:48,970 --> 00:32:54,820
this but only by looking at the the

00:32:51,399 --> 00:32:57,730
current repository and I am NOT going to

00:32:54,820 --> 00:32:59,649
use other kind of sources to predict how

00:32:57,730 --> 00:33:03,039
the packages are going to be upgraded

00:32:59,649 --> 00:33:06,279
and I also want to be consistent with

00:33:03,039 --> 00:33:10,029
the clustering information so packages

00:33:06,279 --> 00:33:13,210
packages don't are not upgraded by by

00:33:10,029 --> 00:33:15,909
themself in isolation but always

00:33:13,210 --> 00:33:18,370
upgraded in in a cluster in a cluster so

00:33:15,909 --> 00:33:21,070
all packages that stem from the same

00:33:18,370 --> 00:33:24,659
source package they're going to be

00:33:21,070 --> 00:33:27,399
upgraded all together and this in the

00:33:24,659 --> 00:33:28,870
challenge at the moment it's a very

00:33:27,399 --> 00:33:32,500
debian specific because of this reason

00:33:28,870 --> 00:33:35,529
because we did this clustering analysis

00:33:32,500 --> 00:33:39,059
on the Debian packages I'm sure that it

00:33:35,529 --> 00:33:43,179
can be done also on the RPM packages and

00:33:39,059 --> 00:33:47,320
they idea that in Debian packages are of

00:33:43,179 --> 00:33:50,049
the same source probably at the same

00:33:47,320 --> 00:33:52,410
version this is not this is not rule

00:33:50,049 --> 00:33:54,150
anywhere but

00:33:52,410 --> 00:33:56,430
if they have the same versions they're

00:33:54,150 --> 00:33:58,950
going to evolve all together if they

00:33:56,430 --> 00:34:00,990
don't have the same versions then all

00:33:58,950 --> 00:34:03,000
bets are off because we can't we can

00:34:00,990 --> 00:34:05,670
actually predict how these packages can

00:34:03,000 --> 00:34:07,920
can move all together so what we found

00:34:05,670 --> 00:34:10,710
is that by analyzing source clusters

00:34:07,920 --> 00:34:14,010
most of them they move all together to a

00:34:10,710 --> 00:34:16,320
newer version some of them from a source

00:34:14,010 --> 00:34:18,630
package you have different sub clusters

00:34:16,320 --> 00:34:21,929
for example with different epochs some

00:34:18,630 --> 00:34:24,390
of them from a source package they have

00:34:21,929 --> 00:34:26,250
binary packages with versions that

00:34:24,390 --> 00:34:28,860
evolving completely different directions

00:34:26,250 --> 00:34:32,310
and in this case I we really can't say

00:34:28,860 --> 00:34:34,380
how different how these packages and

00:34:32,310 --> 00:34:39,810
version are going to evolve and in

00:34:34,380 --> 00:34:42,330
isolation so this the discharge

00:34:39,810 --> 00:34:43,919
algorithm it takes it takes sometimes

00:34:42,330 --> 00:34:45,350
it's not something that you want to do

00:34:43,919 --> 00:34:47,580
on your machine is something that

00:34:45,350 --> 00:34:51,480
distributions want to run once a day it

00:34:47,580 --> 00:34:55,770
takes about about 35 minutes 40 minutes

00:34:51,480 --> 00:34:58,770
a bit much for anal a demo demo here but

00:34:55,770 --> 00:35:00,390
I kind of give you the idea of how

00:34:58,770 --> 00:35:02,250
packages are going to go and this is

00:35:00,390 --> 00:35:05,660
particularly useful if you have a point

00:35:02,250 --> 00:35:10,590
wise distribution and you want to modify

00:35:05,660 --> 00:35:12,030
only specific specific packages then

00:35:10,590 --> 00:35:16,200
once in a while you want to run this

00:35:12,030 --> 00:35:18,060
algorithm and kind of to to see I'm here

00:35:16,200 --> 00:35:21,420
in this in this point in time with this

00:35:18,060 --> 00:35:23,820
packages and I want to to migrate this

00:35:21,420 --> 00:35:30,750
component of my distributions what is

00:35:23,820 --> 00:35:34,290
going to happen when I do that so as I

00:35:30,750 --> 00:35:36,300
said we have source packages with

00:35:34,290 --> 00:35:38,910
versions and then we have target

00:35:36,300 --> 00:35:41,460
versions the target version is the the

00:35:38,910 --> 00:35:43,800
this idea what is going to happen when i

00:35:41,460 --> 00:35:48,480
upgrade to version that is bigger than

00:35:43,800 --> 00:35:52,650
so in this case the first four so these

00:35:48,480 --> 00:35:54,990
are for for debian squeeze and we see

00:35:52,650 --> 00:35:59,970
that in debian squeeze the one of the

00:35:54,990 --> 00:36:04,080
most problematic problematic one package

00:35:59,970 --> 00:36:05,650
that that emerged as problematic

00:36:04,080 --> 00:36:07,510
dependency wise

00:36:05,650 --> 00:36:09,160
when upgraded it means that the

00:36:07,510 --> 00:36:13,390
dependencies on this on put on the

00:36:09,160 --> 00:36:16,630
parallel package are very tight is this

00:36:13,390 --> 00:36:20,559
one but is this one for many different

00:36:16,630 --> 00:36:23,369
reason so if we upgrade from this

00:36:20,559 --> 00:36:26,700
version to a version that is in between

00:36:23,369 --> 00:36:32,410
10.5 point to a ten-point 12 I break

00:36:26,700 --> 00:36:34,660
2060 652 packages if i upgrade to

00:36:32,410 --> 00:36:38,619
version that is in between here i break

00:36:34,660 --> 00:36:42,339
as many but if upgrade two versions that

00:36:38,619 --> 00:36:45,309
is in between this one then upgrade then

00:36:42,339 --> 00:36:51,010
I break a bit less this basically is

00:36:45,309 --> 00:36:54,730
telling me that the the upgrade to

00:36:51,010 --> 00:36:57,160
specific version is going to break a

00:36:54,730 --> 00:37:05,049
number a number of packages but not not

00:36:57,160 --> 00:37:09,750
all the all the upgrades are the same so

00:37:05,049 --> 00:37:12,730
python is also is also another one I

00:37:09,750 --> 00:37:16,299
mean there are many different different

00:37:12,730 --> 00:37:19,210
example if you get G lipsy if you

00:37:16,299 --> 00:37:22,240
migrate to something that it's a larger

00:37:19,210 --> 00:37:24,730
than two point 12 I going to break about

00:37:22,240 --> 00:37:28,000
400 packages if I migrate something that

00:37:24,730 --> 00:37:29,619
is in between this version and two point

00:37:28,000 --> 00:37:33,099
12 I'm going to break a bit less

00:37:29,619 --> 00:37:36,910
packages and so on so forth this will

00:37:33,099 --> 00:37:38,619
give us a way of kind of peeking into

00:37:36,910 --> 00:37:40,510
the future and trying to understand what

00:37:38,619 --> 00:37:44,020
is going to happen if we migrate to a

00:37:40,510 --> 00:37:45,549
specific version so when actually going

00:37:44,020 --> 00:37:48,609
to change a component of your

00:37:45,549 --> 00:37:54,250
distribution and you run this this

00:37:48,609 --> 00:37:57,339
algorithm you might be careful at where

00:37:54,250 --> 00:38:03,279
you're going to end up with your

00:37:57,339 --> 00:38:06,520
migration so one last one last tool that

00:38:03,279 --> 00:38:09,039
I'm going to to present actually I'm not

00:38:06,520 --> 00:38:13,630
going really to present besides it's a

00:38:09,039 --> 00:38:17,410
bit it's a bit outside the scope of this

00:38:13,630 --> 00:38:18,920
presentation it's the coolest tool that

00:38:17,410 --> 00:38:24,819
has been developed a reason

00:38:18,920 --> 00:38:27,920
we buy one member of our group and it's

00:38:24,819 --> 00:38:29,990
it's a tool to to compute the

00:38:27,920 --> 00:38:34,089
instability kernel or distribution what

00:38:29,990 --> 00:38:34,089
are they still ability kernels so if we

00:38:34,119 --> 00:38:40,640
we want to understand about how packages

00:38:37,430 --> 00:38:42,940
can become installable together you

00:38:40,640 --> 00:38:45,650
particularly find out that ended in

00:38:42,940 --> 00:38:47,660
about eighty percent of the packages can

00:38:45,650 --> 00:38:53,030
be installed installed together if you

00:38:47,660 --> 00:38:55,339
want to find the largest installation

00:38:53,030 --> 00:38:57,230
with the Debian packages you public and

00:38:55,339 --> 00:38:59,630
installed in debian unstable about

00:38:57,230 --> 00:39:02,299
30,000 packages all together but there

00:38:59,630 --> 00:39:05,000
are a number of packages that they they

00:39:02,299 --> 00:39:07,520
can't coexist together and what this

00:39:05,000 --> 00:39:10,220
tool does is try to identify these

00:39:07,520 --> 00:39:14,650
classes packages that can co-exist

00:39:10,220 --> 00:39:18,470
together so for example think about the

00:39:14,650 --> 00:39:22,309
male agents you can't install send mail

00:39:18,470 --> 00:39:26,089
and postfix at the same time because

00:39:22,309 --> 00:39:27,890
they the conflicts the structure of

00:39:26,089 --> 00:39:34,430
conflicts doesn't allow you to do that

00:39:27,890 --> 00:39:37,309
this is a this is a simple example about

00:39:34,430 --> 00:39:38,990
two packages or actually it's a family

00:39:37,309 --> 00:39:41,480
of packages that come cannot coexist

00:39:38,990 --> 00:39:42,890
together but if you look carefully at

00:39:41,480 --> 00:39:44,990
the distribution there are not that many

00:39:42,890 --> 00:39:48,200
family of these packages that kind of

00:39:44,990 --> 00:39:52,099
sticks together and this this tool just

00:39:48,200 --> 00:39:56,290
allow you to identify these dis class of

00:39:52,099 --> 00:40:02,359
packages and to have a simple graph to

00:39:56,290 --> 00:40:05,150
to analyze what how how the the

00:40:02,359 --> 00:40:07,819
structure of conflict actually works in

00:40:05,150 --> 00:40:10,040
your distribution these are all the kind

00:40:07,819 --> 00:40:13,369
of hidden structures that we are trying

00:40:10,040 --> 00:40:19,339
to let your face to let to allow people

00:40:13,369 --> 00:40:21,200
to to look a bit a bit at the general at

00:40:19,339 --> 00:40:24,020
the general picture so it's been written

00:40:21,200 --> 00:40:26,510
by is rom volume and if you're

00:40:24,020 --> 00:40:30,400
interested there is a website with the

00:40:26,510 --> 00:40:35,240
a lot of explanations and very nice

00:40:30,400 --> 00:40:37,160
works so my presentation finish here

00:40:35,240 --> 00:40:41,740
that I think it's about 45 minutes and

00:40:37,160 --> 00:40:41,740
I'll be very happy to take questions

00:40:53,800 --> 00:41:01,310
yeah it's a we the question was about

00:40:57,440 --> 00:41:03,500
how deep we go in the dependency graph

00:41:01,310 --> 00:41:05,090
we consider the entire dependency graph

00:41:03,500 --> 00:41:08,140
we're going to we consider the entire

00:41:05,090 --> 00:41:12,880
the entire distribution give me one

00:41:08,140 --> 00:41:18,350
package file that it's our universe and

00:41:12,880 --> 00:41:21,890
and and we consider all the packages and

00:41:18,350 --> 00:41:25,100
without were told we I think we analyze

00:41:21,890 --> 00:41:28,700
universe that are up 200,000 packages so

00:41:25,100 --> 00:41:36,200
I think we are in a good position to

00:41:28,700 --> 00:41:37,790
scale the question was about how how

00:41:36,200 --> 00:41:41,000
long does it take for thirty to thirty

00:41:37,790 --> 00:41:43,850
thousand packages it's about five second

00:41:41,000 --> 00:41:57,850
80,000 packages it's about two minutes

00:41:43,850 --> 00:41:57,850
oh thank you very much yes

00:41:59,089 --> 00:42:04,729
do any of the tools that you developed

00:42:02,469 --> 00:42:08,119
have the capability of working with

00:42:04,729 --> 00:42:13,789
package is different than deviants yeah

00:42:08,119 --> 00:42:18,469
we work with so this check except daddy

00:42:13,789 --> 00:42:20,719
Anna Ashley least sin to this file CDF

00:42:18,469 --> 00:42:25,249
that is it is interchange format and I

00:42:20,719 --> 00:42:28,279
clips file and once upon a time I

00:42:25,249 --> 00:42:40,390
chattels I'd also filter for bsd but has

00:42:28,279 --> 00:42:44,410
not been rewritten all these tools are

00:42:40,390 --> 00:42:46,519
so every year we we promised a release

00:42:44,410 --> 00:42:51,200
this year actually we are very very

00:42:46,519 --> 00:42:54,739
close we are so close that there is a

00:42:51,200 --> 00:42:59,029
release of the source code on on our

00:42:54,739 --> 00:43:01,390
website and we are so close that there

00:42:59,029 --> 00:43:04,099
are packages in debian experimental and

00:43:01,390 --> 00:43:08,150
we are so close that Ralph is working

00:43:04,099 --> 00:43:11,029
right now to to finish up the Debian

00:43:08,150 --> 00:43:15,019
package that we should be up sometimes

00:43:11,029 --> 00:43:17,329
next week so this is a way to put a bit

00:43:15,019 --> 00:43:19,190
of pressure on ourselves because we say

00:43:17,329 --> 00:43:27,979
we're going to release these tools and

00:43:19,190 --> 00:43:30,130
then we never do it ok thank you very

00:43:27,979 --> 00:43:30,130

YouTube URL: https://www.youtube.com/watch?v=FjaDQO_yLTc


