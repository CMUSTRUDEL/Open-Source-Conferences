Title: Data as a service with infinispanfull
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	By Manik Surtani 

Dealing with reliable data storage on clouds is hard. Cloud infrastructure has raised peoples expectations of easy to manage, highly scalable and highly elastic services for serving web applications as well as providing compute power, however when it comes to data storage things start to become very complex.

In this talk, Surtani discusses "Data-as-a-Service", along the lines of infrastructure and platform service offerings that are becoming increasingly common. What is "Data-as-a-Service"? Why is it important, and why would you want one? How could you build one? The talk then goes on to discuss Infinispan - an open source data grid platform - and how Infinispan can serve as a basic building block for a Data-as-a-Service offering.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:04,460 --> 00:00:06,520
you

00:00:08,090 --> 00:00:11,860
thank you for coming welcome to my

00:00:09,740 --> 00:00:11,860
okay

00:00:13,320 --> 00:00:16,260
really weird slots here

00:00:14,760 --> 00:00:17,580
where it's just before lunch and I know

00:00:16,260 --> 00:00:19,140
everyone's hungry and wants to go out

00:00:17,580 --> 00:00:21,450
and get some of that pizza in the pizza

00:00:19,140 --> 00:00:23,810
van but I'm gonna actually bore you for

00:00:21,450 --> 00:00:26,910
an hour first and then you can get pizza

00:00:23,810 --> 00:00:28,560
right so my name is Monica certainiy I'm

00:00:26,910 --> 00:00:30,660
going to be talking about data as a

00:00:28,560 --> 00:00:33,210
service I'm also going to talk about

00:00:30,660 --> 00:00:35,190
infinite span which is a new project of

00:00:33,210 --> 00:00:39,480
mine so hopefully it'll be very very

00:00:35,190 --> 00:00:42,390
exciting obvious boring as I said right

00:00:39,480 --> 00:00:44,670
so um the hope the gist of the talk

00:00:42,390 --> 00:00:46,500
really is all about it is about cloud

00:00:44,670 --> 00:00:49,170
this is the cloud track as you know

00:00:46,500 --> 00:00:50,940
everybody likes cloud everyone thinks

00:00:49,170 --> 00:00:52,620
it's a good thing and I'm sure you do

00:00:50,940 --> 00:00:54,600
too that's why you're here that's why

00:00:52,620 --> 00:00:56,580
you're here to the cloud track in the

00:00:54,600 --> 00:00:58,170
first place and then cloud is good there

00:00:56,580 --> 00:00:59,610
are lots of good things about it I mean

00:00:58,170 --> 00:01:01,710
yes a lot of people think it's just a

00:00:59,610 --> 00:01:03,180
buzzword and some marketing thing is

00:01:01,710 --> 00:01:05,220
it's true to some degree but there are

00:01:03,180 --> 00:01:07,290
some very good things about it so cloud

00:01:05,220 --> 00:01:09,390
is good but at the same time everyone

00:01:07,290 --> 00:01:11,490
also likes data and data storage data

00:01:09,390 --> 00:01:13,409
storage is pretty much you know you

00:01:11,490 --> 00:01:16,049
can't really build a serious application

00:01:13,409 --> 00:01:17,850
without a form of data storage right now

00:01:16,049 --> 00:01:19,530
okay so we like cloud we like data

00:01:17,850 --> 00:01:22,410
storage but unfortunately cloud and data

00:01:19,530 --> 00:01:24,240
storage don't like each other and that's

00:01:22,410 --> 00:01:25,830
really what this talk is about why cloud

00:01:24,240 --> 00:01:28,260
does not like data storage why data

00:01:25,830 --> 00:01:32,850
storage is not like cloud and hopefully

00:01:28,260 --> 00:01:34,710
what you can do about it right before I

00:01:32,850 --> 00:01:36,390
get into the talk I know everyone likes

00:01:34,710 --> 00:01:38,250
Twitter and we've got some awesome Wi-Fi

00:01:36,390 --> 00:01:40,590
here I must say this is like the best

00:01:38,250 --> 00:01:42,780
conference Wi-Fi have ever seen it

00:01:40,590 --> 00:01:43,980
really works and works well so I'm sure

00:01:42,780 --> 00:01:46,830
you're gonna be tweeting about this if

00:01:43,980 --> 00:01:48,690
you are please use these hashtags the

00:01:46,830 --> 00:01:50,370
infinite spam community they're very

00:01:48,690 --> 00:01:52,410
very excited about what we do they

00:01:50,370 --> 00:01:54,380
follow us quite closely on Twitter and

00:01:52,410 --> 00:01:56,610
I'm sure they'd appreciate Amazon ec2

00:01:54,380 --> 00:01:58,650
Rackspace this is all very very cool

00:01:56,610 --> 00:02:00,900
stuff right now I'm not going to go into

00:01:58,650 --> 00:02:02,370
too much detail as to why cloud is good

00:02:00,900 --> 00:02:04,590
and why cloud is cool and why we all

00:02:02,370 --> 00:02:06,150
like it I'm sure you all know that all

00:02:04,590 --> 00:02:08,610
the good stuff about you know

00:02:06,150 --> 00:02:10,229
pay-as-you-go and easy you know easy

00:02:08,610 --> 00:02:13,170
access to lots of resources and stuff

00:02:10,229 --> 00:02:14,879
like that but in general you've now got

00:02:13,170 --> 00:02:16,650
a virtualized operating system that

00:02:14,879 --> 00:02:18,569
that's really the the starting point of

00:02:16,650 --> 00:02:19,980
cloud that's the starting point where

00:02:18,569 --> 00:02:23,099
you can say I'm gonna use virtualization

00:02:19,980 --> 00:02:24,370
whether it's ec2 kit or whether it's on

00:02:23,099 --> 00:02:27,040
VMware or whatever

00:02:24,370 --> 00:02:29,140
and now this stuff is elastic I can fire

00:02:27,040 --> 00:02:30,670
out more instances as I need them I can

00:02:29,140 --> 00:02:32,590
scale them back down when I don't need

00:02:30,670 --> 00:02:35,050
them anymore and things like that all

00:02:32,590 --> 00:02:37,540
very cool right but not not enough I

00:02:35,050 --> 00:02:39,160
mean you still need to maintain all this

00:02:37,540 --> 00:02:41,709
other stuff on top of your virtual

00:02:39,160 --> 00:02:43,660
operating system used to have the same

00:02:41,709 --> 00:02:45,910
pain points of maintaining your database

00:02:43,660 --> 00:02:47,530
on top of a virtual operating system

00:02:45,910 --> 00:02:51,430
your your middleware your your front

00:02:47,530 --> 00:02:53,080
ends and so on and so forth so I mean

00:02:51,430 --> 00:02:54,970
the evolution of cloud the next step

00:02:53,080 --> 00:02:57,519
really is platform as a service this is

00:02:54,970 --> 00:02:59,440
where people start to take things a few

00:02:57,519 --> 00:03:01,420
steps further in addition to just

00:02:59,440 --> 00:03:03,040
virtualizing your operating system we

00:03:01,420 --> 00:03:04,930
also start virtualizing your front end

00:03:03,040 --> 00:03:08,319
on your middleware now this is all very

00:03:04,930 --> 00:03:09,370
very good stuff right now before people

00:03:08,319 --> 00:03:11,160
start saying how come that's my

00:03:09,370 --> 00:03:14,349
virtualized I'm going to talk about that

00:03:11,160 --> 00:03:17,079
most most platform vendors most most

00:03:14,349 --> 00:03:19,480
pads vendors tend to just virtualize the

00:03:17,079 --> 00:03:21,069
first two things and there's a reason

00:03:19,480 --> 00:03:23,650
why it's actually quite easy or

00:03:21,069 --> 00:03:24,610
relatively easy to do of course there

00:03:23,650 --> 00:03:25,989
are some lenders that actually which

00:03:24,610 --> 00:03:27,459
lies the entire stack and that's the

00:03:25,989 --> 00:03:28,720
good thing that's the holy grail so if

00:03:27,459 --> 00:03:31,180
you look at things like Google App

00:03:28,720 --> 00:03:32,500
Engine the entire the entire stack is

00:03:31,180 --> 00:03:34,720
virtualized all the way down to your

00:03:32,500 --> 00:03:35,920
data tier but Google App Engine is

00:03:34,720 --> 00:03:37,720
actually a little bit of an anomaly

00:03:35,920 --> 00:03:40,000
they're a bit of an exception not

00:03:37,720 --> 00:03:41,349
everybody does that

00:03:40,000 --> 00:03:42,670
but there's a reason as to why they

00:03:41,349 --> 00:03:45,959
don't do that it's actually quite hard

00:03:42,670 --> 00:03:49,030
to do where's your data actually stored

00:03:45,959 --> 00:03:51,010
right and now I mentioned cloud doesn't

00:03:49,030 --> 00:03:53,230
like data data doesn't lie cloud right

00:03:51,010 --> 00:03:56,200
and virtualizing data is not quite as

00:03:53,230 --> 00:03:58,440
simple as clarifying or elastic ating or

00:03:56,200 --> 00:04:00,700
virtualizing any other layer

00:03:58,440 --> 00:04:02,410
virtualizing Apache is easy I mean you

00:04:00,700 --> 00:04:03,910
know you can shove all your state's

00:04:02,410 --> 00:04:06,910
somewhere else and you know you have

00:04:03,910 --> 00:04:08,200
stateless stateless instances the middle

00:04:06,910 --> 00:04:10,419
where you can kind of do the same thing

00:04:08,200 --> 00:04:13,709
as well it's not so easy with databases

00:04:10,419 --> 00:04:16,150
so let's take a step back and think why

00:04:13,709 --> 00:04:18,039
the main reason is clouds are ephemeral

00:04:16,150 --> 00:04:19,900
or at least you need to assume that

00:04:18,039 --> 00:04:21,669
clouds are ephemeral what does that mean

00:04:19,900 --> 00:04:24,099
what I mean by that is clouds a

00:04:21,669 --> 00:04:25,539
stateless or they've been designed with

00:04:24,099 --> 00:04:27,760
the assumption that they will be

00:04:25,539 --> 00:04:29,139
stateless I'm going to talk about ec2

00:04:27,760 --> 00:04:32,289
specifically but this actually does

00:04:29,139 --> 00:04:35,320
apply to many systems so with ec2 you've

00:04:32,289 --> 00:04:37,660
got a machine a virtual machine that you

00:04:35,320 --> 00:04:39,730
boot up based on an image based on

00:04:37,660 --> 00:04:41,530
um Melinda's image or whatever that

00:04:39,730 --> 00:04:44,830
you've got and you're gonna get a fresh

00:04:41,530 --> 00:04:46,690
copy of that machine right now if that

00:04:44,830 --> 00:04:49,090
machine were to go down any state that

00:04:46,690 --> 00:04:50,500
you might have stored on it is lost it

00:04:49,090 --> 00:04:51,730
might come back again you might bring it

00:04:50,500 --> 00:04:52,870
back up again that's cool but you

00:04:51,730 --> 00:04:55,120
actually lost anything that you've

00:04:52,870 --> 00:04:56,650
stored on him now there there are lots

00:04:55,120 --> 00:04:58,240
of things you can do to get around that

00:04:56,650 --> 00:05:01,120
I mean Amazon gives you a few other

00:04:58,240 --> 00:05:03,670
services like EBS elastic block storage

00:05:01,120 --> 00:05:06,760
anyone heard of EBS people know about it

00:05:03,670 --> 00:05:09,850
ok good so you can do that you can store

00:05:06,760 --> 00:05:11,470
stuff in EBS it's a semi persistent

00:05:09,850 --> 00:05:13,120
thing they give you something called s3

00:05:11,470 --> 00:05:15,040
again that that's also kind of

00:05:13,120 --> 00:05:17,260
persistent but they're not quite as

00:05:15,040 --> 00:05:18,760
trivial to work with it's not just

00:05:17,260 --> 00:05:20,500
saying here's a machine I can have is an

00:05:18,760 --> 00:05:22,450
operating system which I can just store

00:05:20,500 --> 00:05:23,800
stuff on it and if it goes away I can

00:05:22,450 --> 00:05:27,790
bring it back up I've lost anything

00:05:23,800 --> 00:05:29,950
that's not the case so that's how that's

00:05:27,790 --> 00:05:32,800
how clouds tend to tend to achieve

00:05:29,950 --> 00:05:34,270
elasticity they do so by making this

00:05:32,800 --> 00:05:36,850
assumption that everything's going to be

00:05:34,270 --> 00:05:37,960
stateless all right if ec2 decides that

00:05:36,850 --> 00:05:39,760
they're gonna reprovision one of your

00:05:37,960 --> 00:05:40,720
nodes because a physical machine died

00:05:39,760 --> 00:05:43,690
they're gonna give you another one

00:05:40,720 --> 00:05:44,860
very quickly you may not even notice but

00:05:43,690 --> 00:05:46,380
you would you want what you will notice

00:05:44,860 --> 00:05:48,670
is you've lost all your data on it

00:05:46,380 --> 00:05:50,950
they're just gonna boot up another copy

00:05:48,670 --> 00:05:52,540
of your image and so on and so forth

00:05:50,950 --> 00:05:56,530
it means that you now need to store all

00:05:52,540 --> 00:05:58,480
of your states somewhere else so why is

00:05:56,530 --> 00:05:59,680
it so hard to virtualize your data to

00:05:58,480 --> 00:06:01,840
write something talking about state a

00:05:59,680 --> 00:06:04,450
lot that really is the big deal

00:06:01,840 --> 00:06:08,110
now front-ends and middleware also have

00:06:04,450 --> 00:06:10,030
state well transient state HTTP sessions

00:06:08,110 --> 00:06:12,400
perhaps your middleware might store some

00:06:10,030 --> 00:06:14,410
stuff is well again HTTP sessions and

00:06:12,400 --> 00:06:16,930
things like that but typically most

00:06:14,410 --> 00:06:19,419
platform-as-a-service vendors get around

00:06:16,930 --> 00:06:20,770
the problem of state in your middleware

00:06:19,419 --> 00:06:22,530
or state in your front-end by pushing

00:06:20,770 --> 00:06:24,880
all that state into the data store I

00:06:22,530 --> 00:06:26,410
mean yes that's a very very valid

00:06:24,880 --> 00:06:28,060
solution it means that your middleware

00:06:26,410 --> 00:06:29,800
in your front end is now stateless and

00:06:28,060 --> 00:06:31,390
it that that's awesome it means that if

00:06:29,800 --> 00:06:33,400
you have more requests if your site gets

00:06:31,390 --> 00:06:34,690
slash dotted or whatever that's fine you

00:06:33,400 --> 00:06:36,760
can deal with that just bring up a few

00:06:34,690 --> 00:06:37,960
more Apache instances that's fine bring

00:06:36,760 --> 00:06:39,490
up a few more middleware instances

00:06:37,960 --> 00:06:40,870
you're running an ec2 that's cool you

00:06:39,490 --> 00:06:42,790
can do that you can bring them up very

00:06:40,870 --> 00:06:43,960
quickly boot them up off of an image and

00:06:42,790 --> 00:06:45,360
things like that and add them to your

00:06:43,960 --> 00:06:47,500
load balance and you're good to go

00:06:45,360 --> 00:06:49,390
but that's putting a hell of a lot more

00:06:47,500 --> 00:06:51,190
stress on your data storage tier and

00:06:49,390 --> 00:06:51,500
that's what you need to think about at

00:06:51,190 --> 00:06:56,030
this

00:06:51,500 --> 00:06:57,440
that's the hard bit so I keep saying the

00:06:56,030 --> 00:06:59,600
virtualizing data is hard but there are

00:06:57,440 --> 00:07:01,640
some public services that do exist that

00:06:59,600 --> 00:07:03,800
do exist that give you virtualized data

00:07:01,640 --> 00:07:05,840
all right now what are these services

00:07:03,800 --> 00:07:08,030
I mentioned Google earlier Google's one

00:07:05,840 --> 00:07:10,310
of them Amazon gives you a couple of

00:07:08,030 --> 00:07:13,160
things as well I've got RDS up there but

00:07:10,310 --> 00:07:15,350
RDS actually is not a really scalable

00:07:13,160 --> 00:07:17,840
true virtualized data - who's heard of

00:07:15,350 --> 00:07:21,110
RDS anyone know what it is ok a few

00:07:17,840 --> 00:07:23,990
hands so for those who don't know the

00:07:21,110 --> 00:07:26,480
usual pattern of running a database on

00:07:23,990 --> 00:07:28,790
ec2 but I'm gonna use my sequel as an

00:07:26,480 --> 00:07:31,670
example let's call the Amazon Doc's use

00:07:28,790 --> 00:07:33,470
anyway and the usual pattern is that you

00:07:31,670 --> 00:07:37,520
will boot up my sequel instance on an

00:07:33,470 --> 00:07:40,250
ec2 image you will attach an EBS volume

00:07:37,520 --> 00:07:42,380
onto it and EBS volume is is supposedly

00:07:40,250 --> 00:07:43,760
a persistent volume in Amazon so you

00:07:42,380 --> 00:07:45,050
attach that volume onto this virtual

00:07:43,760 --> 00:07:47,570
image and then you point all your data

00:07:45,050 --> 00:07:49,250
files to that volume so if the virtual

00:07:47,570 --> 00:07:52,190
machine goes down you can bring it up

00:07:49,250 --> 00:07:54,110
again point it back to that EBS volume

00:07:52,190 --> 00:07:55,610
and you still got your data it's not

00:07:54,110 --> 00:07:58,520
that simple it's actually much harder

00:07:55,610 --> 00:08:00,140
than you think a couple of reasons one

00:07:58,520 --> 00:08:02,600
is you can't scale this out words and

00:08:00,140 --> 00:08:04,490
EBS volume can only be mounted on a

00:08:02,600 --> 00:08:05,990
single virtual machine at any given time

00:08:04,490 --> 00:08:07,850
so you can't actually have multiple

00:08:05,990 --> 00:08:09,770
virtual machines for example all running

00:08:07,850 --> 00:08:13,010
my sequel all pointing to the same data

00:08:09,770 --> 00:08:14,870
store that doesn't work whether it's for

00:08:13,010 --> 00:08:17,030
high availability or even scalability

00:08:14,870 --> 00:08:18,710
you still can't do that also

00:08:17,030 --> 00:08:21,140
EBS is not guaranteed it's not

00:08:18,710 --> 00:08:23,030
guaranteed to actually be there even EBS

00:08:21,140 --> 00:08:25,280
can disappear in which case you will

00:08:23,030 --> 00:08:26,900
lose your stuff and again the usual

00:08:25,280 --> 00:08:29,630
pattern that Amazon talked about is

00:08:26,900 --> 00:08:33,020
you're gonna take snapshots from EBS and

00:08:29,630 --> 00:08:34,640
store it in s3 now s3 is the super

00:08:33,020 --> 00:08:38,000
secure yes this day is always going to

00:08:34,640 --> 00:08:40,070
be around sort of storage service that

00:08:38,000 --> 00:08:41,479
Amazon gives you now the problem with s3

00:08:40,070 --> 00:08:42,979
even though it's all really cool and

00:08:41,479 --> 00:08:47,060
really safe and all that stuff very

00:08:42,979 --> 00:08:48,320
durable the problem is it's slow I mean

00:08:47,060 --> 00:08:52,130
as you'd expect there's always the

00:08:48,320 --> 00:08:55,130
trade-off as three works on either on

00:08:52,130 --> 00:08:57,860
the API that you use to connect to s3 is

00:08:55,130 --> 00:08:59,390
either a REST API or a web service both

00:08:57,860 --> 00:09:01,670
of which are notoriously slow for

00:08:59,390 --> 00:09:03,180
various reasons mainly HTTP connections

00:09:01,670 --> 00:09:04,560
and things like that

00:09:03,180 --> 00:09:07,260
and then on top of that you build a lair

00:09:04,560 --> 00:09:09,090
so yeah that can get slow so you can use

00:09:07,260 --> 00:09:10,590
it for snapshots that's cool

00:09:09,090 --> 00:09:12,240
but snapshots again I actually hate

00:09:10,590 --> 00:09:13,920
snapshots snapshots are terrible if

00:09:12,240 --> 00:09:15,840
complete false sense of security it

00:09:13,920 --> 00:09:17,280
makes you think your data is safe but

00:09:15,840 --> 00:09:19,530
you still got these windows where you

00:09:17,280 --> 00:09:21,240
you actually might lose stuff now the

00:09:19,530 --> 00:09:22,710
drawback with snapshots it actually

00:09:21,240 --> 00:09:23,940
makes you go back home and see alright

00:09:22,710 --> 00:09:26,430
yeah my date is safe I don't need to

00:09:23,940 --> 00:09:29,100
think any more about you know any issues

00:09:26,430 --> 00:09:31,260
that might arise if I were to lose my

00:09:29,100 --> 00:09:32,490
environment at the wrong time no you got

00:09:31,260 --> 00:09:36,120
to think about that that's the pretty

00:09:32,490 --> 00:09:37,410
nasty so okay that's already yes amazon

00:09:36,120 --> 00:09:40,230
also used something else called simple

00:09:37,410 --> 00:09:42,780
DB now simple DB is actually a scalable

00:09:40,230 --> 00:09:45,720
data service I mentioned simply being

00:09:42,780 --> 00:09:49,650
quite briefly here who's heard of a

00:09:45,720 --> 00:09:51,450
paper that Amazon once put out cold cold

00:09:49,650 --> 00:09:53,640
I forgot the name now any was very

00:09:51,450 --> 00:09:55,560
interesting paper dynamo yes Amazon

00:09:53,640 --> 00:09:57,720
dynamo who sort of dynamo has read it

00:09:55,560 --> 00:09:59,670
it's a long and pretty complex paper

00:09:57,720 --> 00:10:02,010
it's very interesting and they actually

00:09:59,670 --> 00:10:06,030
talk about a truly scalable data grid

00:10:02,010 --> 00:10:08,870
system right and simple DB is actually

00:10:06,030 --> 00:10:11,370
their internal implementation of dynamo

00:10:08,870 --> 00:10:13,560
now the only problem is simple DB again

00:10:11,370 --> 00:10:14,850
is API and actually the name as well

00:10:13,560 --> 00:10:16,530
they call it simple DB that's why the

00:10:14,850 --> 00:10:19,110
worst name they can come up with because

00:10:16,530 --> 00:10:20,790
anyone's used it here you can probably

00:10:19,110 --> 00:10:23,580
confirm with me that a it's not simple

00:10:20,790 --> 00:10:24,960
and B it's not a database calling it

00:10:23,580 --> 00:10:27,300
simple DB is probably the worst thing

00:10:24,960 --> 00:10:29,190
you can you can call it it's essentially

00:10:27,300 --> 00:10:30,990
your web service it's an XML based web

00:10:29,190 --> 00:10:33,360
service where you store key value pairs

00:10:30,990 --> 00:10:35,130
I mean it's horrible to use wants to

00:10:33,360 --> 00:10:37,170
write a web service to store key value

00:10:35,130 --> 00:10:38,910
pairs right but that's the only service

00:10:37,170 --> 00:10:41,550
they actually guaranteed to be properly

00:10:38,910 --> 00:10:43,740
elastic and truly durable in their

00:10:41,550 --> 00:10:46,050
environment there are others as well

00:10:43,740 --> 00:10:47,280
fathom DB is very similar to RDS except

00:10:46,050 --> 00:10:48,920
it's not run by Amazon it's run by

00:10:47,280 --> 00:10:51,780
somebody else

00:10:48,920 --> 00:10:53,880
Cloudant it's another service company

00:10:51,780 --> 00:10:56,940
they're working on an elastic version of

00:10:53,880 --> 00:10:58,770
CouchDB HQ do the same thing with

00:10:56,940 --> 00:11:00,600
MongoDB things like that it's basically

00:10:58,770 --> 00:11:01,800
they manage the environment they host it

00:11:00,600 --> 00:11:03,750
they manage the replication the

00:11:01,800 --> 00:11:06,270
snapshots blah blah blah and they just

00:11:03,750 --> 00:11:08,790
give you a service login where you can

00:11:06,270 --> 00:11:10,650
sit and store stuff but these are all

00:11:08,790 --> 00:11:12,450
public services this is all stuff where

00:11:10,650 --> 00:11:14,910
you buy a login and you you know use it

00:11:12,450 --> 00:11:16,240
but but that's not good for everyone and

00:11:14,910 --> 00:11:17,740
there many reasons why

00:11:16,240 --> 00:11:19,959
or what about private clouds private

00:11:17,740 --> 00:11:21,130
clouds are important as well when you

00:11:19,959 --> 00:11:23,399
talk about cloud computing not

00:11:21,130 --> 00:11:25,390
everything lives in the public space

00:11:23,399 --> 00:11:27,880
very often you want to use your own

00:11:25,390 --> 00:11:29,350
hardware why well because you have your

00:11:27,880 --> 00:11:31,029
own hardware for example you already

00:11:29,350 --> 00:11:33,640
bought it maybe you don't throw it away

00:11:31,029 --> 00:11:35,800
and then go and you know you use ec2 and

00:11:33,640 --> 00:11:37,540
pay for stuff again or maybe because of

00:11:35,800 --> 00:11:39,580
a security concerns maybe you're you're

00:11:37,540 --> 00:11:41,110
you know you're concerned about storing

00:11:39,580 --> 00:11:43,990
your data on a public service where

00:11:41,110 --> 00:11:46,690
we're uncool Sam might you know walk in

00:11:43,990 --> 00:11:48,820
with with a letter and sees all the

00:11:46,690 --> 00:11:50,260
hardware and your data with it what

00:11:48,820 --> 00:11:52,180
about data locality you might actually

00:11:50,260 --> 00:11:53,860
want stuff local to where your users are

00:11:52,180 --> 00:11:55,870
processing things you might not want to

00:11:53,860 --> 00:11:58,390
fetch data from across the Atlantic or

00:11:55,870 --> 00:11:59,830
things like that right so there are lots

00:11:58,390 --> 00:12:01,540
of reasons why you want to build your

00:11:59,830 --> 00:12:04,480
own data center or not you and SEO and

00:12:01,540 --> 00:12:06,160
data service on your own hardware so how

00:12:04,480 --> 00:12:07,390
would you go about doing that let's

00:12:06,160 --> 00:12:09,160
start by looking at the characteristics

00:12:07,390 --> 00:12:11,080
of a data service what are the

00:12:09,160 --> 00:12:15,490
characteristics that make a scalable

00:12:11,080 --> 00:12:17,200
data service firstly you need elasticity

00:12:15,490 --> 00:12:18,970
you need scalability highly high

00:12:17,200 --> 00:12:21,040
variability and fault tolerance these

00:12:18,970 --> 00:12:23,440
are all things that you expect out of a

00:12:21,040 --> 00:12:26,170
cloud service one of the reasons why

00:12:23,440 --> 00:12:27,579
people use cloud for all the other stuff

00:12:26,170 --> 00:12:28,750
for you know your front end your

00:12:27,579 --> 00:12:31,240
middleware and things like that is

00:12:28,750 --> 00:12:32,800
elasticity and high availability you

00:12:31,240 --> 00:12:34,209
want to be able to scale out on demand

00:12:32,800 --> 00:12:35,890
when you're Slashdot certain things like

00:12:34,209 --> 00:12:37,810
that so your data service needs to be

00:12:35,890 --> 00:12:39,670
able to scale out as well all right

00:12:37,810 --> 00:12:41,950
you also need high availability and

00:12:39,670 --> 00:12:43,690
fault tolerance this is all running on

00:12:41,950 --> 00:12:44,920
commodity hardware that's the whole

00:12:43,690 --> 00:12:46,630
point of cloud you're gonna be running

00:12:44,920 --> 00:12:48,850
on cheap commodity hardware and cheap

00:12:46,630 --> 00:12:50,920
commodity hardware will break it will

00:12:48,850 --> 00:12:52,750
break the you know power supplies will

00:12:50,920 --> 00:12:54,970
blow up and things like that what are

00:12:52,750 --> 00:12:56,410
you gonna do you need to have a highly

00:12:54,970 --> 00:12:59,440
available service so that you don't

00:12:56,410 --> 00:13:02,560
actually lose any more quality of

00:12:59,440 --> 00:13:04,240
service from from the users now there

00:13:02,560 --> 00:13:05,890
are other optional features as well that

00:13:04,240 --> 00:13:07,779
you might want out of a data service

00:13:05,890 --> 00:13:11,020
things like transactional capabilities

00:13:07,779 --> 00:13:12,490
XA or MapReduce and things like that but

00:13:11,020 --> 00:13:14,529
those are all optional extras I would

00:13:12,490 --> 00:13:18,610
say they're not the core of of a Tron

00:13:14,529 --> 00:13:19,630
over data service so how do you normally

00:13:18,610 --> 00:13:21,190
store data

00:13:19,630 --> 00:13:23,260
traditionally in your traditional

00:13:21,190 --> 00:13:25,089
three-tier style app that I shared now

00:13:23,260 --> 00:13:27,059
actually got sequel and no sequel on the

00:13:25,089 --> 00:13:28,559
same slides

00:13:27,059 --> 00:13:30,059
I'm actually not categorizing them

00:13:28,559 --> 00:13:32,639
together well what I'm trying to talk

00:13:30,059 --> 00:13:35,309
about here is essentially non

00:13:32,639 --> 00:13:37,019
distributed databases so non distributed

00:13:35,309 --> 00:13:40,589
sequel and non distributed no sequel

00:13:37,019 --> 00:13:42,329
databases and this kind of stuff you

00:13:40,589 --> 00:13:44,610
can't really use for a data service

00:13:42,329 --> 00:13:45,720
right now okay let's start with

00:13:44,610 --> 00:13:47,399
databases traditionally you'd use

00:13:45,720 --> 00:13:49,319
something like my sequel or post squares

00:13:47,399 --> 00:13:50,639
or something like that you don't really

00:13:49,319 --> 00:13:52,379
have all the stuff that I spoke about

00:13:50,639 --> 00:13:54,149
you don't have elasticity you don't

00:13:52,379 --> 00:13:56,819
really have high availability yes you

00:13:54,149 --> 00:13:58,529
can cobble it together you can use NDB

00:13:56,819 --> 00:14:00,389
as an engine and things like that but I

00:13:58,529 --> 00:14:02,299
mean that that's not really you know

00:14:00,389 --> 00:14:05,040
something that's truly reliable or

00:14:02,299 --> 00:14:08,999
tried-and-tested the other option is

00:14:05,040 --> 00:14:10,100
stuff like Oracle Oracles rack and

00:14:08,999 --> 00:14:12,360
things like that which are all extremely

00:14:10,100 --> 00:14:14,160
extreme expensive it doesn't actually

00:14:12,360 --> 00:14:15,749
run on commodity hardware either you

00:14:14,160 --> 00:14:18,089
need special hardware you need ass and

00:14:15,749 --> 00:14:21,449
all this other stuff so it doesn't

00:14:18,089 --> 00:14:22,860
really work for cloud and in the case of

00:14:21,449 --> 00:14:24,209
no sequel database is the ones that are

00:14:22,860 --> 00:14:26,189
not distributed again you've got the

00:14:24,209 --> 00:14:27,720
same problem if it's not distributed not

00:14:26,189 --> 00:14:30,119
really going to be elastic or highly

00:14:27,720 --> 00:14:32,429
available so in general stuff like this

00:14:30,119 --> 00:14:34,649
won't really work right to build your

00:14:32,429 --> 00:14:39,149
data service what can you use then

00:14:34,649 --> 00:14:40,709
what's the next step so I'm going to

00:14:39,149 --> 00:14:44,610
talk about data grades now and change

00:14:40,709 --> 00:14:46,019
gears a little bit so essentially when I

00:14:44,610 --> 00:14:48,839
talk about data grades I'm going to

00:14:46,019 --> 00:14:50,279
cover both in memory and disk based data

00:14:48,839 --> 00:14:53,069
grids they're two fairly different

00:14:50,279 --> 00:14:54,959
beasts in terms of how they actually

00:14:53,069 --> 00:14:57,209
store things in terms of how they

00:14:54,959 --> 00:15:00,419
optimize for latency and things like

00:14:57,209 --> 00:15:02,939
that but in terms of distribution or in

00:15:00,419 --> 00:15:04,589
terms of the way they deal with fault

00:15:02,939 --> 00:15:05,459
tolerance and elasticity they're very

00:15:04,589 --> 00:15:07,079
very similar

00:15:05,459 --> 00:15:09,509
they follow similar principles and

00:15:07,079 --> 00:15:10,980
similar concepts so essentially

00:15:09,509 --> 00:15:12,239
distributed databases were just by the

00:15:10,980 --> 00:15:14,160
very name they are inherently

00:15:12,239 --> 00:15:16,110
distributed distributed by design

00:15:14,160 --> 00:15:18,660
they're distributed by the very nature

00:15:16,110 --> 00:15:21,389
of what it is and that means you get a

00:15:18,660 --> 00:15:22,619
lot of things for free right since the

00:15:21,389 --> 00:15:24,480
system is distributing you're gonna get

00:15:22,619 --> 00:15:25,739
high availability for free there's

00:15:24,480 --> 00:15:27,239
always going to be another node

00:15:25,739 --> 00:15:29,339
somewhere provided you have adequate

00:15:27,239 --> 00:15:31,079
numbers of nodes altogether to take over

00:15:29,339 --> 00:15:33,419
from a node that were to die that were

00:15:31,079 --> 00:15:35,579
to fail all right and you're gonna get

00:15:33,419 --> 00:15:37,499
elasticity too you're gonna be able to

00:15:35,579 --> 00:15:39,419
add more nodes to the system and it will

00:15:37,499 --> 00:15:40,110
scale outwards and will scale back down

00:15:39,419 --> 00:15:41,700
again

00:15:40,110 --> 00:15:43,529
shut nodes down if you don't need them

00:15:41,700 --> 00:15:45,360
anymore and things like that so you get

00:15:43,529 --> 00:15:47,190
all this stuff for free and this is why

00:15:45,360 --> 00:15:48,899
I think data grades distributed data

00:15:47,190 --> 00:15:51,029
grids are actually perfect for a cloud

00:15:48,899 --> 00:15:52,589
data service it's a perfect building

00:15:51,029 --> 00:15:54,240
block you get all the characteristics

00:15:52,589 --> 00:15:58,680
that you want from a cloud data service

00:15:54,240 --> 00:16:01,410
for free out of a data grid and what

00:15:58,680 --> 00:16:04,470
about API so how do your apps actually

00:16:01,410 --> 00:16:07,260
talk to your data service right I mean

00:16:04,470 --> 00:16:08,880
if a lot of no sequel databases use

00:16:07,260 --> 00:16:11,190
things like key values and stuff like

00:16:08,880 --> 00:16:12,899
that or document orientated stores which

00:16:11,190 --> 00:16:14,910
are very good for special purpose or

00:16:12,899 --> 00:16:17,790
very very application specific domain

00:16:14,910 --> 00:16:21,420
specific needs but it's a little bit too

00:16:17,790 --> 00:16:23,850
low-level in general right so anyone

00:16:21,420 --> 00:16:25,589
here at Java developers heard of JPA who

00:16:23,850 --> 00:16:27,660
uses JPA here all right

00:16:25,589 --> 00:16:31,500
so GPA essentially for the non java

00:16:27,660 --> 00:16:33,420
folks is just standard high level object

00:16:31,500 --> 00:16:36,660
orientated way of storing data of

00:16:33,420 --> 00:16:39,060
storing objects in Java it's an ORM it

00:16:36,660 --> 00:16:40,800
basically maps high-level objects into

00:16:39,060 --> 00:16:43,410
relational tables and things like that

00:16:40,800 --> 00:16:45,240
but yeah leaving the ORM part of it

00:16:43,410 --> 00:16:47,519
aside essentially this is the API that

00:16:45,240 --> 00:16:48,959
you traditionally use in Ruby it's kind

00:16:47,519 --> 00:16:51,120
of similar use active records and things

00:16:48,959 --> 00:16:53,190
like that you use high level API is you

00:16:51,120 --> 00:16:55,440
don't actually fiddle around with sequel

00:16:53,190 --> 00:16:58,829
statements right you shouldn't anywhere

00:16:55,440 --> 00:17:00,480
not not in a high-level app essentially

00:16:58,829 --> 00:17:01,949
what you should be doing is these are

00:17:00,480 --> 00:17:04,169
kind of API is you need you shouldn't

00:17:01,949 --> 00:17:05,220
really be talking key value so when

00:17:04,169 --> 00:17:06,660
you're trying to build out a data

00:17:05,220 --> 00:17:08,400
service you should think about stuff

00:17:06,660 --> 00:17:13,549
like this what sort of API are you going

00:17:08,400 --> 00:17:15,990
to offer your middle weight here so

00:17:13,549 --> 00:17:18,540
shifting gears a little bit I'm gonna

00:17:15,990 --> 00:17:20,490
introduce infinite span um how's

00:17:18,540 --> 00:17:22,400
everyone doing so far have I put anyone

00:17:20,490 --> 00:17:27,540
to sleep yet yeah all right good

00:17:22,400 --> 00:17:29,400
excellent so what is infinite span I

00:17:27,540 --> 00:17:31,890
started infinite span a couple of years

00:17:29,400 --> 00:17:34,440
back it's an open source data grid it's

00:17:31,890 --> 00:17:35,910
in-memory primarily we also do spool off

00:17:34,440 --> 00:17:38,580
to disk but it's primarily in memory

00:17:35,910 --> 00:17:39,990
it's written in Java and and Scala as

00:17:38,580 --> 00:17:41,910
well isn't it

00:17:39,990 --> 00:17:44,280
even though it's not just for the JVM

00:17:41,910 --> 00:17:47,730
even though we write it in Java I'll

00:17:44,280 --> 00:17:50,309
explain why and there were a couple of

00:17:47,730 --> 00:17:52,110
primary usage modes so they're two ways

00:17:50,309 --> 00:17:53,200
of interacting with infinite span one is

00:17:52,110 --> 00:17:54,850
an embedded mode

00:17:53,200 --> 00:17:57,639
embedded motives if you if your app

00:17:54,850 --> 00:17:59,769
happens to run in a JVM now I'm careful

00:17:57,639 --> 00:18:02,019
to say JVM here not just job I mean you

00:17:59,769 --> 00:18:04,090
could be writing up a groovy app or a

00:18:02,019 --> 00:18:06,369
JRuby app or whatever that's that works

00:18:04,090 --> 00:18:09,279
just fine you can launch in the fitness

00:18:06,369 --> 00:18:11,200
fan instance within your JVM and if you

00:18:09,279 --> 00:18:12,460
launch a few copies of that of your app

00:18:11,200 --> 00:18:13,840
in different servers they left also

00:18:12,460 --> 00:18:15,639
discover each other they'll form a

00:18:13,840 --> 00:18:17,980
cluster they'll start sharing state etc

00:18:15,639 --> 00:18:19,210
etc so that's embedded mode and then

00:18:17,980 --> 00:18:21,249
this client-server mode where you can

00:18:19,210 --> 00:18:22,749
actually start up startup or launch

00:18:21,249 --> 00:18:24,659
individual and finish span nodes and

00:18:22,749 --> 00:18:27,249
connect to them remotely over a socket

00:18:24,659 --> 00:18:30,070
over a number of protocols that we

00:18:27,249 --> 00:18:31,989
support so I'm gonna give you a brief

00:18:30,070 --> 00:18:33,609
tour of some of the high-level more

00:18:31,989 --> 00:18:34,749
notable features of infinite span and

00:18:33,609 --> 00:18:36,429
then I'm gonna talk about how you can

00:18:34,749 --> 00:18:40,029
actually use infinite span to build a

00:18:36,429 --> 00:18:43,330
data service so start with the method

00:18:40,029 --> 00:18:46,090
mode and finish man is primarily a

00:18:43,330 --> 00:18:47,950
peer-to-peer system all right we use

00:18:46,090 --> 00:18:49,929
peer-to-peer protocols to for auto

00:18:47,950 --> 00:18:52,059
discovery for sharing state form group

00:18:49,929 --> 00:18:54,759
membership things like that who's heard

00:18:52,059 --> 00:18:57,100
of a project called G groups G groups is

00:18:54,759 --> 00:18:58,570
an open source peer-to-peer library and

00:18:57,100 --> 00:19:01,389
that's essentially what infinite span

00:18:58,570 --> 00:19:03,190
uses we were built on top of J groups we

00:19:01,389 --> 00:19:04,509
use J groups for discovery we used your

00:19:03,190 --> 00:19:07,779
groups to share data and things like

00:19:04,509 --> 00:19:09,460
that so essentially this is your typical

00:19:07,779 --> 00:19:10,869
embedded architecture this is how you

00:19:09,460 --> 00:19:12,460
would use an finish fan in an embedded

00:19:10,869 --> 00:19:15,399
mode as I said you start up a bunch of

00:19:12,460 --> 00:19:17,289
JVMs your apps it's in the JVM your app

00:19:15,399 --> 00:19:19,389
will launch an infinite span instance

00:19:17,289 --> 00:19:23,169
infinite span instances discover each

00:19:19,389 --> 00:19:24,549
other's start sharing data and that

00:19:23,169 --> 00:19:26,019
that's pretty much it's very simple

00:19:24,549 --> 00:19:28,239
you automatically get all the features

00:19:26,019 --> 00:19:30,789
of an Finnish band in your app stuff

00:19:28,239 --> 00:19:32,139
like high availability you can now load

00:19:30,789 --> 00:19:33,639
balanced requests across your app

00:19:32,139 --> 00:19:35,320
because data is shared everywhere like

00:19:33,639 --> 00:19:38,350
session states and things like that

00:19:35,320 --> 00:19:40,059
all right a lot of frameworks a lot of

00:19:38,350 --> 00:19:42,100
web frameworks for example tend to use

00:19:40,059 --> 00:19:45,940
infinite span to share their transient

00:19:42,100 --> 00:19:47,499
State a lot of web containers like JBoss

00:19:45,940 --> 00:19:51,460
app server for example actually uses

00:19:47,499 --> 00:19:53,379
infini span as well to distribute HTTP

00:19:51,460 --> 00:19:55,600
session state or EJB session stage

00:19:53,379 --> 00:20:00,850
things like that and this is how a JBoss

00:19:55,600 --> 00:20:03,700
like I said achieves clustering what

00:20:00,850 --> 00:20:05,769
does the API look like so infinite spans

00:20:03,700 --> 00:20:06,650
got a number of API is the primary API

00:20:05,769 --> 00:20:09,560
is a very simple

00:20:06,650 --> 00:20:12,320
up like API so again if you use Java um

00:20:09,560 --> 00:20:14,900
the the core in finis pan API actually

00:20:12,320 --> 00:20:16,340
extends Java util map so if you know how

00:20:14,900 --> 00:20:18,650
to use a map in Java you know how to use

00:20:16,340 --> 00:20:20,000
infinite span it's very very simple it's

00:20:18,650 --> 00:20:22,040
more than that of course we've got a few

00:20:20,000 --> 00:20:24,290
other higher-level api's and more more

00:20:22,040 --> 00:20:27,410
rich API including asynchronous API is

00:20:24,290 --> 00:20:29,540
non-blocking api's and we're also

00:20:27,410 --> 00:20:31,820
building an upcoming JPA layer as well

00:20:29,540 --> 00:20:34,250
so like I mentioned I mentioned GPA

00:20:31,820 --> 00:20:36,410
earlier so you actually have this JPA

00:20:34,250 --> 00:20:38,480
style of interacting with and finish pad

00:20:36,410 --> 00:20:40,100
to persist your data as though it was my

00:20:38,480 --> 00:20:43,160
sequel as though it was some other

00:20:40,100 --> 00:20:44,870
database there are also other high level

00:20:43,160 --> 00:20:47,450
API is being discussed in the community

00:20:44,870 --> 00:20:50,840
including active record who's heard of a

00:20:47,450 --> 00:20:53,540
project called talk box any JRuby people

00:20:50,840 --> 00:20:54,910
here any Ruby people here so talk box

00:20:53,540 --> 00:20:57,950
essentially is a Ruby on Rails

00:20:54,910 --> 00:21:00,350
implementation on JRuby running on top

00:20:57,950 --> 00:21:04,840
of JBoss it's actually extremely popular

00:21:00,350 --> 00:21:07,190
in in the cloud community so who uses

00:21:04,840 --> 00:21:08,840
engine yard anyone uses engineered here

00:21:07,190 --> 00:21:11,630
anyone heard of engine yard so engine

00:21:08,840 --> 00:21:13,550
yards a hosted Ruby on Rails cloud

00:21:11,630 --> 00:21:15,590
environment where you can host your Ruby

00:21:13,550 --> 00:21:17,600
on Rails applications it actually uses

00:21:15,590 --> 00:21:20,180
JRuby underneath it actually uses talk

00:21:17,600 --> 00:21:21,740
box underneath the benefit of using talk

00:21:20,180 --> 00:21:23,270
box as opposed to Ruby on Rails on its

00:21:21,740 --> 00:21:25,490
own is that you get all the benefits of

00:21:23,270 --> 00:21:27,650
a Java EE app server underneath Ruby on

00:21:25,490 --> 00:21:29,870
Rails which particularly includes

00:21:27,650 --> 00:21:34,460
clustering high availability and so on

00:21:29,870 --> 00:21:36,500
and so forth what else do you have an

00:21:34,460 --> 00:21:39,200
infinite span so again like I said a

00:21:36,500 --> 00:21:40,880
bunch of high level features infinite

00:21:39,200 --> 00:21:42,260
span distributes data across its nodes

00:21:40,880 --> 00:21:44,690
using a consistent hash based

00:21:42,260 --> 00:21:46,400
distribution algorithm the reason why we

00:21:44,690 --> 00:21:49,520
do this is because consistent hashing

00:21:46,400 --> 00:21:51,820
gives us a very fast and deterministic

00:21:49,520 --> 00:21:54,200
way of locating data in a cluster

00:21:51,820 --> 00:21:56,750
without needing to maintain lots of

00:21:54,200 --> 00:21:58,400
metadata and without having to broadcast

00:21:56,750 --> 00:22:00,200
calls around the cluster to try and

00:21:58,400 --> 00:22:02,240
locate stuff right everything happens in

00:22:00,200 --> 00:22:03,800
a single machine you can locate stuff

00:22:02,240 --> 00:22:06,710
very quickly we're in deterministic

00:22:03,800 --> 00:22:08,120
fashion and as a result the system is

00:22:06,710 --> 00:22:10,600
self-healing you don't have a single

00:22:08,120 --> 00:22:13,460
point of failure so on and so forth

00:22:10,600 --> 00:22:15,920
infinite spans also highly concurrent we

00:22:13,460 --> 00:22:17,450
use MVC C based locking on a per node

00:22:15,920 --> 00:22:19,250
basis which means that you've got

00:22:17,450 --> 00:22:19,980
concurrent reads and writes and things

00:22:19,250 --> 00:22:21,960
like that

00:22:19,980 --> 00:22:25,460
very very performant especially in

00:22:21,960 --> 00:22:25,460
massively multi-core environments

00:22:26,870 --> 00:22:30,090
resistance

00:22:28,049 --> 00:22:32,010
I mentioned that infinite span also does

00:22:30,090 --> 00:22:33,720
possess two discs it's not just in

00:22:32,010 --> 00:22:35,700
memory although primarily it stores

00:22:33,720 --> 00:22:37,049
stuff in memory it also does right

00:22:35,700 --> 00:22:39,570
through to disk as well

00:22:37,049 --> 00:22:40,740
now when I say disk we've got an

00:22:39,570 --> 00:22:42,450
interface called the cache store

00:22:40,740 --> 00:22:44,400
interface we've got a few

00:22:42,450 --> 00:22:45,720
implementations that we ship with some

00:22:44,400 --> 00:22:48,419
of the implementations of the cache

00:22:45,720 --> 00:22:51,179
store is just a file system based driver

00:22:48,419 --> 00:22:52,799
some of them write to Berkeley DB you

00:22:51,179 --> 00:22:56,130
can actually write back to a database as

00:22:52,799 --> 00:22:58,710
well using a JDBC driver we also have

00:22:56,130 --> 00:23:00,299
pluggable drivers for for Amazon s3 for

00:22:58,710 --> 00:23:02,640
example to actually persist on to

00:23:00,299 --> 00:23:05,610
something like s3 and of course you can

00:23:02,640 --> 00:23:09,030
write your own as well eviction and

00:23:05,610 --> 00:23:11,730
expiry so if you if our primary data

00:23:09,030 --> 00:23:12,929
store is in memory you're gonna have a

00:23:11,730 --> 00:23:15,240
problem because if you keep putting

00:23:12,929 --> 00:23:16,559
stuff in memory at some point your JVM

00:23:15,240 --> 00:23:18,330
is gonna crash with an out of memory

00:23:16,559 --> 00:23:19,950
exception you are gonna run out of

00:23:18,330 --> 00:23:21,929
memories so you do need some form of

00:23:19,950 --> 00:23:23,580
eviction and expiry to be able to say ok

00:23:21,929 --> 00:23:25,440
I need to take stuff out of memory and

00:23:23,580 --> 00:23:27,720
put it onto disk onto my cache store

00:23:25,440 --> 00:23:30,240
essentially paging that happens in most

00:23:27,720 --> 00:23:32,730
operating systems so we've got a couple

00:23:30,240 --> 00:23:34,530
of rather interesting algorithms very

00:23:32,730 --> 00:23:35,970
interesting adaptive algorithms some of

00:23:34,530 --> 00:23:37,620
this stuff is literally only just come

00:23:35,970 --> 00:23:39,450
out of university research like two

00:23:37,620 --> 00:23:41,880
years ago we're one of the first

00:23:39,450 --> 00:23:43,650
implementations if you want to talk

00:23:41,880 --> 00:23:44,790
about in more detail later on but you

00:23:43,650 --> 00:23:49,530
are going to check it out very very

00:23:44,790 --> 00:23:51,570
interesting stuff xa transactions yes we

00:23:49,530 --> 00:23:53,340
support X 8 transactions and this is

00:23:51,570 --> 00:23:56,400
actually very interesting because a lot

00:23:53,340 --> 00:23:59,250
of no sequel databases try and not

00:23:56,400 --> 00:24:00,900
support X 8 transactions or of they

00:23:59,250 --> 00:24:02,760
don't support X 8 transactions as a

00:24:00,900 --> 00:24:05,160
trade-off for performance to be able to

00:24:02,760 --> 00:24:07,500
scale now we actually think we can scale

00:24:05,160 --> 00:24:09,299
while still supporting X a transactions

00:24:07,500 --> 00:24:11,700
because guess what most business use

00:24:09,299 --> 00:24:14,549
cases need transactions they tend to be

00:24:11,700 --> 00:24:18,720
transactional so a lot of people want it

00:24:14,549 --> 00:24:21,299
we do do XA transactions if anyone's

00:24:18,720 --> 00:24:24,030
ever heard of a group called Arjuna this

00:24:21,299 --> 00:24:25,620
was a research group out of University

00:24:24,030 --> 00:24:28,290
of Newcastle which then spun off into

00:24:25,620 --> 00:24:31,049
its own company and these two do X a

00:24:28,290 --> 00:24:33,090
transactional engines while fully well

00:24:31,049 --> 00:24:34,499
before Java 20 years ago

00:24:33,090 --> 00:24:36,600
and therefore one of the most the most

00:24:34,499 --> 00:24:39,269
mature transactional implementation

00:24:36,600 --> 00:24:41,580
around we work very closely with them

00:24:39,269 --> 00:24:43,980
they actually help us implement x8

00:24:41,580 --> 00:24:45,629
transactions within an finis ban and so

00:24:43,980 --> 00:24:47,129
on and so forth

00:24:45,629 --> 00:24:49,799
and in addition to that we also

00:24:47,129 --> 00:24:51,240
researching new ways of of providing

00:24:49,799 --> 00:24:53,429
consistency or providing strong

00:24:51,240 --> 00:24:55,620
transactional like consistency and

00:24:53,429 --> 00:24:56,940
making it perform even better one one

00:24:55,620 --> 00:24:58,950
particular idea we're working on at the

00:24:56,940 --> 00:25:00,749
moment is atomic broadcasts if anyone's

00:24:58,950 --> 00:25:01,980
familiar with atomic broadcasts there's

00:25:00,749 --> 00:25:03,690
lots of very interesting stuff around

00:25:01,980 --> 00:25:05,700
that we're working with a couple of

00:25:03,690 --> 00:25:07,409
universities one in Portugal and one in

00:25:05,700 --> 00:25:10,049
Italy and working very closely with them

00:25:07,409 --> 00:25:11,759
on it so that's that's one to watch out

00:25:10,049 --> 00:25:15,299
for that'll be hitting us hitting a

00:25:11,759 --> 00:25:17,669
release soon at some point what else do

00:25:15,299 --> 00:25:19,499
we do yeah we do do MapReduce as well

00:25:17,669 --> 00:25:22,320
it's currently in a pre-release state

00:25:19,499 --> 00:25:23,909
it's in an alpha its alpha quality but

00:25:22,320 --> 00:25:26,789
do download it try it out we've got a

00:25:23,909 --> 00:25:29,789
very interesting API in my opinion a lot

00:25:26,789 --> 00:25:32,639
of people talk about how how complex

00:25:29,789 --> 00:25:34,470
MapReduce is in the Java world I mean I

00:25:32,639 --> 00:25:35,940
know it's not very complex in a non Java

00:25:34,470 --> 00:25:37,980
world because you've got interesting

00:25:35,940 --> 00:25:39,570
things like closures and dynamically

00:25:37,980 --> 00:25:41,789
typed language they can actually make

00:25:39,570 --> 00:25:43,889
MapReduce quite nice but in a strongly

00:25:41,789 --> 00:25:46,080
typed and rather clunky environment like

00:25:43,889 --> 00:25:47,100
Java MapReduce can be very complex if

00:25:46,080 --> 00:25:49,019
you look at Hadoop MapReduce

00:25:47,100 --> 00:25:52,590
implementation has anyone tried to

00:25:49,019 --> 00:25:54,419
implement a MapReduce task in Hadoop no

00:25:52,590 --> 00:25:56,549
a few there all right I mean it is

00:25:54,419 --> 00:25:58,470
complex it's non-trivial and we're

00:25:56,549 --> 00:26:00,090
hoping that our API is actually very

00:25:58,470 --> 00:26:02,549
very simple we've taken lots of cues

00:26:00,090 --> 00:26:06,149
from from dynamically typed languages

00:26:02,549 --> 00:26:08,610
and things like that so yeah and yes you

00:26:06,149 --> 00:26:10,590
also do support querying we do support

00:26:08,610 --> 00:26:12,419
indexing and querying stuff that you

00:26:10,590 --> 00:26:14,159
store in infinite span that we usually

00:26:12,419 --> 00:26:15,980
seen as a querying engine and acquiring

00:26:14,159 --> 00:26:18,629
API as well

00:26:15,980 --> 00:26:20,850
so that's embedded mode so far I'm gonna

00:26:18,629 --> 00:26:23,970
now client server mode kind of builds on

00:26:20,850 --> 00:26:25,019
top of embedded mode it kind of in terms

00:26:23,970 --> 00:26:27,210
of architecture this is kind of where it

00:26:25,019 --> 00:26:28,559
looks like when you will start if you

00:26:27,210 --> 00:26:31,019
were to start up a bunch of infinite

00:26:28,559 --> 00:26:33,210
span instances in client-server mode

00:26:31,019 --> 00:26:35,340
each one starts up in its own JVM that's

00:26:33,210 --> 00:26:37,379
what that thing is and each one opens up

00:26:35,340 --> 00:26:39,119
a socket and starts listening on it now

00:26:37,379 --> 00:26:41,309
in this now in this setup your

00:26:39,119 --> 00:26:43,590
application does not share the same JVM

00:26:41,309 --> 00:26:45,509
isn't finis panet it sits outside in

00:26:43,590 --> 00:26:46,750
fact it may not sit in a JVM at all your

00:26:45,509 --> 00:26:48,580
app might not be a Java

00:26:46,750 --> 00:26:51,760
application at all as long as it can

00:26:48,580 --> 00:26:53,680
talk one of these protocols over over

00:26:51,760 --> 00:26:56,560
the wire to the infinite span cluster

00:26:53,680 --> 00:26:58,540
you can use infinite span now we support

00:26:56,560 --> 00:27:00,940
a number of protocols firstly support

00:26:58,540 --> 00:27:02,830
rest why do we support rest because it's

00:27:00,940 --> 00:27:04,870
very popular in cloud environments it's

00:27:02,830 --> 00:27:06,550
very easy to manage it's it's a very

00:27:04,870 --> 00:27:08,010
useful protocol to support plus was very

00:27:06,550 --> 00:27:09,820
easy to build and very easy to implement

00:27:08,010 --> 00:27:12,780
so we support rest

00:27:09,820 --> 00:27:14,890
we support memcache D memcache e is a

00:27:12,780 --> 00:27:17,590
for those of you don't know it it's it's

00:27:14,890 --> 00:27:19,930
a single VM a single server daemon

00:27:17,590 --> 00:27:22,060
process and it's very very popular C

00:27:19,930 --> 00:27:25,210
liquidus most Linux distributions ship

00:27:22,060 --> 00:27:27,610
with it but what's also very interesting

00:27:25,210 --> 00:27:29,590
about memcache D is there is a client

00:27:27,610 --> 00:27:31,810
library for memcache D for pretty much

00:27:29,590 --> 00:27:34,780
any language or any platform on the

00:27:31,810 --> 00:27:36,790
planet and this means that if since we

00:27:34,780 --> 00:27:38,650
support the memcache D protocol it means

00:27:36,790 --> 00:27:40,390
that pretty much any platform or any

00:27:38,650 --> 00:27:42,490
language can use infinite span as well

00:27:40,390 --> 00:27:45,550
right

00:27:42,490 --> 00:27:48,490
and then there's hot rod as well so if

00:27:45,550 --> 00:27:50,010
we're thinking what is hot rod hot rods

00:27:48,490 --> 00:27:52,330
essentially a wire protocol that we

00:27:50,010 --> 00:27:55,690
started building for infinite spans

00:27:52,330 --> 00:27:57,640
specifically it's an extension of

00:27:55,690 --> 00:28:00,250
memcache D it kind of adds a few extra

00:27:57,640 --> 00:28:02,260
things on top of memcache D but I mean

00:28:00,250 --> 00:28:03,940
let me start about what the big deal is

00:28:02,260 --> 00:28:07,060
or why did we do it in the first place

00:28:03,940 --> 00:28:08,710
so memcache D is is a very simple

00:28:07,060 --> 00:28:11,560
protocol it's very simple protocol for

00:28:08,710 --> 00:28:14,160
storing and retrieving data but we found

00:28:11,560 --> 00:28:16,480
a couple of shortcomings in memcache D

00:28:14,160 --> 00:28:18,310
firstly it's text-based it's not binary

00:28:16,480 --> 00:28:19,660
based I know there's a binary variant of

00:28:18,310 --> 00:28:21,790
the memcache D protocol but that's not

00:28:19,660 --> 00:28:23,140
really well supported it doesn't have

00:28:21,790 --> 00:28:24,700
the same rich

00:28:23,140 --> 00:28:27,520
number of clients out there and things

00:28:24,700 --> 00:28:28,780
like that but specifically why the

00:28:27,520 --> 00:28:30,670
reasons we found the memcache the

00:28:28,780 --> 00:28:32,470
protocol falling short is because it's a

00:28:30,670 --> 00:28:34,630
one-way protocol it's a one-way protocol

00:28:32,470 --> 00:28:36,220
where clients talk to servers clients

00:28:34,630 --> 00:28:38,410
talk to servers and get results that's

00:28:36,220 --> 00:28:40,030
it there's no way for a server to talk

00:28:38,410 --> 00:28:42,250
to a client now why would a server want

00:28:40,030 --> 00:28:44,110
to talk to a client a couple of reasons

00:28:42,250 --> 00:28:45,840
right if you want to maintain a dynamic

00:28:44,110 --> 00:28:48,790
list of which servers are available

00:28:45,840 --> 00:28:50,790
that's pretty useful if if service can

00:28:48,790 --> 00:28:52,900
send this information back to clients

00:28:50,790 --> 00:28:54,790
another very interesting reason is

00:28:52,900 --> 00:28:56,470
built-in high availability and failover

00:28:54,790 --> 00:28:58,510
you can actually build this into clients

00:28:56,470 --> 00:28:59,360
as well if clients knew where your

00:28:58,510 --> 00:29:02,780
servers were

00:28:59,360 --> 00:29:04,549
how this was to change and the last part

00:29:02,780 --> 00:29:06,470
is like I said in finis span uses a

00:29:04,549 --> 00:29:08,990
consistent hash based algorithm to store

00:29:06,470 --> 00:29:12,860
data if the clients could be made aware

00:29:08,990 --> 00:29:15,170
of what algorithms enforce and your

00:29:12,860 --> 00:29:17,600
server topology at that time it can

00:29:15,170 --> 00:29:19,160
actually direct a request to the actual

00:29:17,600 --> 00:29:20,690
node which has the data rather than

00:29:19,160 --> 00:29:22,790
having to have that node hop somewhere

00:29:20,690 --> 00:29:24,260
else to find your data for you so you

00:29:22,790 --> 00:29:26,240
can optimize a lot of things if you had

00:29:24,260 --> 00:29:28,100
a 2-way protocol so that really is what

00:29:26,240 --> 00:29:29,690
hotrod is it's essentially a two-way

00:29:28,100 --> 00:29:31,370
protocol where you can do smart routing

00:29:29,690 --> 00:29:34,549
where clients can be built in a very

00:29:31,370 --> 00:29:35,990
intelligent fashion so here's a quick

00:29:34,549 --> 00:29:37,580
comparison of the different endpoints

00:29:35,990 --> 00:29:40,429
the different protocols that infinite

00:29:37,580 --> 00:29:42,440
span supports and client-server mode so

00:29:40,429 --> 00:29:46,610
rest and memcache Diab they both text

00:29:42,440 --> 00:29:48,380
protocols as I said hotrods binary rest

00:29:46,610 --> 00:29:49,940
in terms of client libraries you don't

00:29:48,380 --> 00:29:52,850
need a client library for rest you just

00:29:49,940 --> 00:29:54,470
use an HTTP client memcache T there are

00:29:52,850 --> 00:29:57,799
lots and lots of client libraries out

00:29:54,470 --> 00:29:59,360
there the big drawback with hot rod is

00:29:57,799 --> 00:30:01,160
that currently we only have a Java

00:29:59,360 --> 00:30:02,630
client it's essentially a reference

00:30:01,160 --> 00:30:05,419
implementation client that we have built

00:30:02,630 --> 00:30:07,400
I know that someone is building a Python

00:30:05,419 --> 00:30:09,830
client I have also heard of a group

00:30:07,400 --> 00:30:11,720
building a dotnet client we are hoping

00:30:09,830 --> 00:30:13,640
to save more of these come out in the

00:30:11,720 --> 00:30:14,960
community they're all clustered at the

00:30:13,640 --> 00:30:16,309
same time because you because the

00:30:14,960 --> 00:30:17,630
backend is clustered because your

00:30:16,309 --> 00:30:19,640
unfinished fan nodes are clustered

00:30:17,630 --> 00:30:21,110
unlike memcache T itself where the back

00:30:19,640 --> 00:30:22,400
end is not clustered if you lose your

00:30:21,110 --> 00:30:24,140
memcache do you know you've lost your

00:30:22,400 --> 00:30:26,090
cache all right

00:30:24,140 --> 00:30:28,580
but this isn't a cache it's more than a

00:30:26,090 --> 00:30:31,160
cache in terms of smart routing I just

00:30:28,580 --> 00:30:34,669
explained hot-rod supports smart routing

00:30:31,160 --> 00:30:37,460
memcache D and rest don't but you still

00:30:34,669 --> 00:30:39,799
can build in failover and load balancing

00:30:37,460 --> 00:30:42,049
across any of these protocols you just

00:30:39,799 --> 00:30:44,480
need to use different techniques so in

00:30:42,049 --> 00:30:46,700
terms of rest if you were to use the

00:30:44,480 --> 00:30:48,350
rest endpoint it's quite easy to build a

00:30:46,700 --> 00:30:51,080
che and load balancing you just use any

00:30:48,350 --> 00:30:53,570
HTTP load balancer like mod JK or mod

00:30:51,080 --> 00:30:55,400
cluster for Apache or a hardware load

00:30:53,570 --> 00:30:58,820
balancer which is which which can be

00:30:55,400 --> 00:31:01,429
used as well memcache B is a little bit

00:30:58,820 --> 00:31:03,890
limiting array so so most memcache D

00:31:01,429 --> 00:31:05,809
libraries client libraries allow you to

00:31:03,890 --> 00:31:07,160
provide multiple endpoints or IP

00:31:05,809 --> 00:31:08,659
addresses of multiple memcache key

00:31:07,160 --> 00:31:10,489
servers and it will

00:31:08,659 --> 00:31:12,470
load balance and failover across them

00:31:10,489 --> 00:31:14,989
but the only problem is this predefined

00:31:12,470 --> 00:31:16,399
server list is static so if some of

00:31:14,989 --> 00:31:17,450
these servers were to go away and some

00:31:16,399 --> 00:31:19,789
new ones would have been introduced

00:31:17,450 --> 00:31:21,109
you've got either restart your client or

00:31:19,789 --> 00:31:23,149
reconfigure your client or something

00:31:21,109 --> 00:31:24,769
right so and that's not always possible

00:31:23,149 --> 00:31:26,450
whereas we thought rod that's all

00:31:24,769 --> 00:31:27,919
dynamic because hot phones got a dynamic

00:31:26,450 --> 00:31:36,109
view of what's happening on your server

00:31:27,919 --> 00:31:37,639
side so um mr. something's up

00:31:36,109 --> 00:31:39,019
what is infinite span right is it a data

00:31:37,639 --> 00:31:40,580
grid right it's called the

00:31:39,019 --> 00:31:42,320
characteristics of a data grid it's in

00:31:40,580 --> 00:31:44,690
memory it's peer-to-peer it's

00:31:42,320 --> 00:31:47,599
distributed low latency because

00:31:44,690 --> 00:31:50,840
primarily stored in memory and it's a

00:31:47,599 --> 00:31:52,909
key value store right so what is it or

00:31:50,840 --> 00:31:55,489
is it a no sequel database because they

00:31:52,909 --> 00:31:58,729
do persistence as well and we do

00:31:55,489 --> 00:31:59,440
MapReduce as well was it something else

00:31:58,729 --> 00:32:01,549
entirely

00:31:59,440 --> 00:32:03,830
because we also have querying support

00:32:01,549 --> 00:32:05,690
and transactional support stuff that

00:32:03,830 --> 00:32:09,200
even though sequel databases don't do or

00:32:05,690 --> 00:32:11,269
many of them don't do so what is it in

00:32:09,200 --> 00:32:13,399
reality it's all of these things that's

00:32:11,269 --> 00:32:15,950
what I'm Finnish ban is it's a highly

00:32:13,399 --> 00:32:17,899
scalable data store that can be used as

00:32:15,950 --> 00:32:19,549
a database replacement that can be used

00:32:17,899 --> 00:32:21,349
as a no sequel database and it will

00:32:19,549 --> 00:32:23,029
still support high level things like

00:32:21,349 --> 00:32:25,039
querying and transactions you don't have

00:32:23,029 --> 00:32:27,859
to compromise your programming model or

00:32:25,039 --> 00:32:30,639
what you do on your app tier two to fit

00:32:27,859 --> 00:32:30,639
in a scalable database

00:32:33,779 --> 00:32:40,179
so why isn't finished pants sexy I

00:32:36,450 --> 00:32:42,669
actually don't know who that is just a

00:32:40,179 --> 00:32:43,419
caveat there I'll give you six reasons

00:32:42,669 --> 00:32:45,820
for that

00:32:43,419 --> 00:32:47,830
firstly it scales horizontally skills

00:32:45,820 --> 00:32:49,330
outwards and back in again very

00:32:47,830 --> 00:32:52,450
important stuff it's elastic in both

00:32:49,330 --> 00:32:54,789
directions fast I low-latency access to

00:32:52,450 --> 00:32:57,480
data primarily stuff is stored in memory

00:32:54,789 --> 00:33:00,340
makes it very very fast to access things

00:32:57,480 --> 00:33:02,169
it addresses a very large heap so if

00:33:00,340 --> 00:33:04,119
you've got a bunch of JVMs on a bunch of

00:33:02,169 --> 00:33:06,159
nodes and each one's got two gigs of

00:33:04,119 --> 00:33:07,869
heap it gives you the aggregate view of

00:33:06,159 --> 00:33:09,429
the entire thing on Java that's pretty

00:33:07,869 --> 00:33:11,559
cool to actually have a single data

00:33:09,429 --> 00:33:14,440
structure that looks like it can store

00:33:11,559 --> 00:33:17,619
100 gigs of stuff even they're stressed

00:33:14,440 --> 00:33:19,299
striped across multiple nodes it's cloud

00:33:17,619 --> 00:33:21,009
friendly this cloud friendly runs in

00:33:19,299 --> 00:33:22,419
easy - it runs on Rackspace and things

00:33:21,009 --> 00:33:24,369
like that they'll run on a private cloud

00:33:22,419 --> 00:33:26,259
it use their ephemeral nodes because

00:33:24,369 --> 00:33:27,940
like I said it is distributed by design

00:33:26,259 --> 00:33:29,830
and that helps you deal with things like

00:33:27,940 --> 00:33:31,929
that and it can be consumed by any

00:33:29,830 --> 00:33:34,509
platform it's not just for Java it's not

00:33:31,929 --> 00:33:36,070
just for the JVM and of course most

00:33:34,509 --> 00:33:38,489
importantly it's it's free and it

00:33:36,070 --> 00:33:38,489
doesn't suck

00:33:40,970 --> 00:33:44,730
so as I promised I'm going to talk about

00:33:42,990 --> 00:33:46,590
how you actually build the data service

00:33:44,730 --> 00:33:48,360
within finish span now so is this

00:33:46,590 --> 00:33:50,550
revisit this little diagram over there

00:33:48,360 --> 00:33:51,860
in the corner where we had the various

00:33:50,550 --> 00:33:54,690
parts of your three-tier architecture

00:33:51,860 --> 00:33:56,580
turning cloudy and let's try and make

00:33:54,690 --> 00:33:58,260
that date a bit cloudy as well how would

00:33:56,580 --> 00:34:01,560
you do that

00:33:58,260 --> 00:34:03,840
one solution is to actually replace that

00:34:01,560 --> 00:34:06,420
single node with a bunch of infinite

00:34:03,840 --> 00:34:08,160
span nodes perhaps sitting in ec2 or

00:34:06,420 --> 00:34:10,320
whatever virtualized hardware that you

00:34:08,160 --> 00:34:11,460
have like I said because they're

00:34:10,320 --> 00:34:13,410
distributed you're going to get all the

00:34:11,460 --> 00:34:16,560
elasticity and high availability on that

00:34:13,410 --> 00:34:18,330
tear your middle weight here would talk

00:34:16,560 --> 00:34:20,760
to it using one of them one of the three

00:34:18,330 --> 00:34:21,840
client-server endpoints because you

00:34:20,760 --> 00:34:23,130
could use all three as well you don't

00:34:21,840 --> 00:34:24,450
have to stick to just one you can

00:34:23,130 --> 00:34:25,650
actually have each of those nodes

00:34:24,450 --> 00:34:27,570
listening and all three of those

00:34:25,650 --> 00:34:29,310
protocols as well which is an

00:34:27,570 --> 00:34:30,780
interesting set up if you have

00:34:29,310 --> 00:34:32,460
heterogeneous middleware doing different

00:34:30,780 --> 00:34:36,690
things written on different platforms

00:34:32,460 --> 00:34:37,860
and stuff and there you have it so

00:34:36,690 --> 00:34:39,720
that's how you end up achieving

00:34:37,860 --> 00:34:42,440
elasticity high availability and

00:34:39,720 --> 00:34:44,640
scalability in your data tear all right

00:34:42,440 --> 00:34:46,290
and this is actually true of pretty much

00:34:44,640 --> 00:34:48,390
any data grid that would support the

00:34:46,290 --> 00:34:51,480
features that I spoke about it's not

00:34:48,390 --> 00:34:52,770
just in Finnish man so how'd you

00:34:51,480 --> 00:34:56,310
actually start mindfulness band server

00:34:52,770 --> 00:34:58,770
well step one is actually not there is

00:34:56,310 --> 00:34:59,940
to download the distribution I'm

00:34:58,770 --> 00:35:00,630
assuming you've done that download the

00:34:59,940 --> 00:35:02,880
distribution

00:35:00,630 --> 00:35:04,230
you've got your startup script you

00:35:02,880 --> 00:35:06,090
provide the protocol that you want to

00:35:04,230 --> 00:35:08,160
use there's a bunch of other tuning up

00:35:06,090 --> 00:35:09,720
options as well I mean stuff to you in

00:35:08,160 --> 00:35:11,670
the sockets you're using and things like

00:35:09,720 --> 00:35:13,770
that and you passed in the InfiniBand

00:35:11,670 --> 00:35:16,110
configuration that XML file actually

00:35:13,770 --> 00:35:20,940
configures and Tunes the the memory node

00:35:16,110 --> 00:35:22,530
on that the server endpoint uses you get

00:35:20,940 --> 00:35:24,120
to tune things like what sort of JTA

00:35:22,530 --> 00:35:25,740
characteristics you want what sort of

00:35:24,120 --> 00:35:27,480
transactional characteristics you want

00:35:25,740 --> 00:35:31,410
what sort of locking characteristics you

00:35:27,480 --> 00:35:33,540
want and things like that rest the rest

00:35:31,410 --> 00:35:34,980
endpoint is slightly different the

00:35:33,540 --> 00:35:36,990
infinite span distribution comes with a

00:35:34,980 --> 00:35:40,200
war file which is a modular web

00:35:36,990 --> 00:35:42,150
application and you deploy the infinite

00:35:40,200 --> 00:35:45,180
span war file in your favorite servlet

00:35:42,150 --> 00:35:48,480
container and that exposes a an HTTP

00:35:45,180 --> 00:35:51,390
endpoint five arrests if you don't have

00:35:48,480 --> 00:35:52,710
a servlet container I mean they're lots

00:35:51,390 --> 00:35:55,710
of open source ones there's some very

00:35:52,710 --> 00:35:57,690
I can recommend and essentially you use

00:35:55,710 --> 00:35:59,280
your web container to to tune things

00:35:57,690 --> 00:36:00,720
like security or the number of threads

00:35:59,280 --> 00:36:07,890
in your socket pooling and stuff like

00:36:00,720 --> 00:36:09,660
that so we'll be headed what's what's

00:36:07,890 --> 00:36:12,150
the future for her infinite span that

00:36:09,660 --> 00:36:14,119
that's not my motorcycle as well as just

00:36:12,150 --> 00:36:16,890
another caveat

00:36:14,119 --> 00:36:20,400
so our first release we released it in

00:36:16,890 --> 00:36:22,920
February 2010 probably last year it was

00:36:20,400 --> 00:36:24,990
version 4 now for those of you who are

00:36:22,920 --> 00:36:27,810
asking wondering why why is his first

00:36:24,990 --> 00:36:29,339
release called version 4 I feel kind of

00:36:27,810 --> 00:36:31,020
bored of everyone releasing your first

00:36:29,339 --> 00:36:33,420
relations version 1 right let's do

00:36:31,020 --> 00:36:34,680
something different now that there's an

00:36:33,420 --> 00:36:37,890
FAQ on the website if you're interested

00:36:34,680 --> 00:36:39,810
go and have a look version 4 coding in

00:36:37,890 --> 00:36:42,230
Stara Brno named after the beer we were

00:36:39,810 --> 00:36:44,339
drinking when you're actually coding it

00:36:42,230 --> 00:36:46,560
comes with all these features the map

00:36:44,339 --> 00:36:48,060
like API you think API which I didn't

00:36:46,560 --> 00:36:50,700
talk about that's a non-blocking API

00:36:48,060 --> 00:36:52,830
that's pretty cool because consistent

00:36:50,700 --> 00:36:54,330
hash based distribution right through

00:36:52,830 --> 00:36:56,880
and right behind to disk or the storage

00:36:54,330 --> 00:36:58,650
staff eviction and exploration some

00:36:56,880 --> 00:37:00,089
management tooling with JMX to actually

00:36:58,650 --> 00:37:03,690
monitor the nodes see what's going on

00:37:00,089 --> 00:37:08,690
things like that the REST API and all of

00:37:03,690 --> 00:37:10,619
that photo one by this stage we had

00:37:08,690 --> 00:37:13,589
progressed to a different bear is

00:37:10,619 --> 00:37:16,650
radagast this time this is released in

00:37:13,589 --> 00:37:18,210
august 2010 with all the very cool

00:37:16,650 --> 00:37:20,940
things like deadlock detection and stuff

00:37:18,210 --> 00:37:22,410
for for distributed transactions or the

00:37:20,940 --> 00:37:23,460
client service stuff came out in this

00:37:22,410 --> 00:37:25,380
release

00:37:23,460 --> 00:37:27,210
Lusine directory implementations and

00:37:25,380 --> 00:37:28,470
stuff so if you use leucine 4 for

00:37:27,210 --> 00:37:30,119
indexing stuff you can actually

00:37:28,470 --> 00:37:33,420
distribute your indexes using Infini

00:37:30,119 --> 00:37:34,070
span stuff like that what are we doing

00:37:33,420 --> 00:37:38,430
right now

00:37:34,070 --> 00:37:39,930
working very hard on 5.0 5.0 is gonna

00:37:38,430 --> 00:37:43,050
have some other cool stuff including a

00:37:39,930 --> 00:37:45,180
JPA like api the distributed code

00:37:43,050 --> 00:37:46,410
execution all the MapReduce stuff so I

00:37:45,180 --> 00:37:49,170
mentioned that's already out there an

00:37:46,410 --> 00:37:51,660
alpha quality at the moment the goal is

00:37:49,170 --> 00:37:54,390
to actually try and have this as a final

00:37:51,660 --> 00:37:55,950
release by by the summer and of course

00:37:54,390 --> 00:37:57,930
5.1 and beyond what are we doing over

00:37:55,950 --> 00:37:59,520
there's dynamic provisioning this stuff

00:37:57,930 --> 00:38:01,109
is all very cool this like some of the

00:37:59,520 --> 00:38:03,180
stuff spying this guy we just in a thing

00:38:01,109 --> 00:38:04,470
are the few ideas here dynamic

00:38:03,180 --> 00:38:06,390
provisioning is quite interesting where

00:38:04,470 --> 00:38:06,580
you can actually plug in some rules like

00:38:06,390 --> 00:38:08,740
a

00:38:06,580 --> 00:38:10,600
sceles saying I want to make sure if I I

00:38:08,740 --> 00:38:12,100
don't know hit 80 percent capacity fire

00:38:10,600 --> 00:38:13,600
ups and new nodes automatically and

00:38:12,100 --> 00:38:15,790
start distributing stuff in sharing

00:38:13,600 --> 00:38:17,350
state or if I dropped below 30% capacity

00:38:15,790 --> 00:38:19,450
shut down a few notes and don't need so

00:38:17,350 --> 00:38:21,280
many nodes and stuff like that so

00:38:19,450 --> 00:38:23,800
that'll be all very interesting to to

00:38:21,280 --> 00:38:25,960
watch complex event processing as well

00:38:23,800 --> 00:38:27,730
this is stuff that we want to do to add

00:38:25,960 --> 00:38:29,200
to add event notifications and things

00:38:27,730 --> 00:38:35,230
like that so it could be quite quite

00:38:29,200 --> 00:38:37,420
cool to watch so to sum things up

00:38:35,230 --> 00:38:39,490
essentially I was talking about clouds

00:38:37,420 --> 00:38:40,150
are mainstream they're here blah blah we

00:38:39,490 --> 00:38:41,700
like them

00:38:40,150 --> 00:38:45,010
we like data they don't like each other

00:38:41,700 --> 00:38:47,170
and why how rather how elastic data is a

00:38:45,010 --> 00:38:49,930
hard problem to solve how it's hard to

00:38:47,170 --> 00:38:52,570
achieve how data grids can help as well

00:38:49,930 --> 00:38:55,060
I talked about infinite span as an open

00:38:52,570 --> 00:38:57,700
source data grid viable solution as the

00:38:55,060 --> 00:39:01,450
data service both public and private

00:38:57,700 --> 00:39:03,520
cloud as well and with that I believe

00:39:01,450 --> 00:39:05,590
I've got a few minutes for questions

00:39:03,520 --> 00:39:07,420
there's a bunch of URLs up there if you

00:39:05,590 --> 00:39:10,330
want more information including the the

00:39:07,420 --> 00:39:12,700
project page the project blog folk the

00:39:10,330 --> 00:39:14,620
project and github contribute code we

00:39:12,700 --> 00:39:17,050
like that so you know all good all good

00:39:14,620 --> 00:39:20,140
fun we're an ir scene that's our C

00:39:17,050 --> 00:39:22,770
channel on freenode and yeah with that

00:39:20,140 --> 00:39:22,770
any questions

00:39:39,250 --> 00:39:44,990
so the question is we say we are

00:39:42,579 --> 00:39:46,430
peer-to-peer based and we don't have a

00:39:44,990 --> 00:39:48,589
single point of failure but at the same

00:39:46,430 --> 00:39:51,079
time we participate in XA transactions

00:39:48,589 --> 00:39:53,059
and and XA transactions means that if

00:39:51,079 --> 00:39:54,289
your transaction manager fails does that

00:39:53,059 --> 00:39:56,240
mean that you've lost your transaction

00:39:54,289 --> 00:39:56,960
how you really decide your question

00:39:56,240 --> 00:40:00,619
right yeah

00:39:56,960 --> 00:40:02,240
essentially when we deal with external

00:40:00,619 --> 00:40:03,829
systems like a transaction manager that

00:40:02,240 --> 00:40:05,420
that's not internal to infinite span

00:40:03,829 --> 00:40:06,980
that's an external thing if your

00:40:05,420 --> 00:40:08,450
transaction broker dies that that's

00:40:06,980 --> 00:40:10,490
that's the problem of the transaction

00:40:08,450 --> 00:40:13,609
broker but we do have a solution for

00:40:10,490 --> 00:40:15,619
that as well so I mentioned Arjuna

00:40:13,609 --> 00:40:17,420
earlier Arjuna has kind of been

00:40:15,619 --> 00:40:20,059
rebranded and renamed it sits now JBoss

00:40:17,420 --> 00:40:22,190
transactions the JBoss transaction

00:40:20,059 --> 00:40:24,470
manager which in itself is distributed

00:40:22,190 --> 00:40:26,059
and highly available as well so as a

00:40:24,470 --> 00:40:27,980
recommendation if you want true high

00:40:26,059 --> 00:40:30,529
availability we'd recommend using JBoss

00:40:27,980 --> 00:40:32,420
TS as your transaction manager because

00:40:30,529 --> 00:40:34,279
that in itself has got distribution

00:40:32,420 --> 00:40:36,079
capabilities and they don't have a

00:40:34,279 --> 00:40:39,099
single point of failure either so that's

00:40:36,079 --> 00:40:39,099
kind of how we achieve that

00:40:46,560 --> 00:40:56,619
I'm sorry could you repeat that yes it

00:40:54,550 --> 00:40:57,579
does so the question was doesn't spent

00:40:56,619 --> 00:41:01,060
doesn't finish man

00:40:57,579 --> 00:41:02,530
do data locking and multiple nodes yes

00:41:01,060 --> 00:41:04,900
well we have a very optimistic scheme

00:41:02,530 --> 00:41:07,000
around that where we actually only

00:41:04,900 --> 00:41:09,160
acquire remote locks during the

00:41:07,000 --> 00:41:10,750
preparing commit phases not through the

00:41:09,160 --> 00:41:12,250
entire lifecycle of the transaction

00:41:10,750 --> 00:41:14,020
although that's again something you can

00:41:12,250 --> 00:41:14,440
configure you can use eager locking as

00:41:14,020 --> 00:41:15,880
well

00:41:14,440 --> 00:41:17,650
eager locking will of course mean you've

00:41:15,880 --> 00:41:19,810
got less overall concurrency in the

00:41:17,650 --> 00:41:21,609
overall system but it gives you a more

00:41:19,810 --> 00:41:24,599
secure you have fewer transactions

00:41:21,609 --> 00:41:24,599
potentially rolling back

00:41:28,960 --> 00:41:33,140
the transaction would fail if you can't

00:41:31,970 --> 00:41:35,920
acquire all the locks you need your

00:41:33,140 --> 00:41:35,920
transaction will fail

00:41:45,690 --> 00:41:50,140
so the question is what's the overhead

00:41:47,920 --> 00:41:52,119
of using Lucene over infinite span there

00:41:50,140 --> 00:41:56,740
are you referring to using Lucy into

00:41:52,119 --> 00:41:58,109
index stuff in infinite span well there

00:41:56,740 --> 00:42:00,250
is a overhead yes

00:41:58,109 --> 00:42:01,990
what's the overhead no is it a number I

00:42:00,250 --> 00:42:03,460
yeah yeah it's something you need to try

00:42:01,990 --> 00:42:05,589
out it depends on how complex your

00:42:03,460 --> 00:42:07,480
objects are the effort involved in

00:42:05,589 --> 00:42:09,280
indexing those objects and of course

00:42:07,480 --> 00:42:26,020
most importantly how you tune and setup

00:42:09,280 --> 00:42:28,480
Lucene as well so yeah the question is

00:42:26,020 --> 00:42:31,410
so we're using J groups how does that

00:42:28,480 --> 00:42:33,400
scale essentially right miss

00:42:31,410 --> 00:42:35,230
specifically with regards to multicast

00:42:33,400 --> 00:42:37,089
no we don't actually use the multicast

00:42:35,230 --> 00:42:39,160
part of J groups J groups is actually

00:42:37,089 --> 00:42:41,140
very very tunable and configurable and

00:42:39,160 --> 00:42:43,510
you can actually tune it to the nth

00:42:41,140 --> 00:42:44,740
degree and we only use a certain subset

00:42:43,510 --> 00:42:47,680
of J groups for a few very specific

00:42:44,740 --> 00:42:49,569
things specifically primarily for

00:42:47,680 --> 00:42:51,190
discovery and things like that not so

00:42:49,569 --> 00:42:52,480
much for the actual communications for

00:42:51,190 --> 00:43:04,780
the actual communications we tend to use

00:42:52,480 --> 00:43:06,970
point-to-point TCPS yep the question is

00:43:04,780 --> 00:43:09,970
is infinite spans suitable to stow gigs

00:43:06,970 --> 00:43:15,010
of files I referring to a single file of

00:43:09,970 --> 00:43:17,290
that kind of size or total yeah I mean

00:43:15,010 --> 00:43:20,349
you know I've seen people use use it to

00:43:17,290 --> 00:43:23,280
store terabytes of data as well yup so

00:43:20,349 --> 00:43:23,280
John says yes

00:43:23,430 --> 00:43:31,690
anything else some questions how do we

00:43:29,530 --> 00:43:33,549
cope with security Security's on the

00:43:31,690 --> 00:43:36,549
roadmap unfortunately we don't do very

00:43:33,549 --> 00:43:39,579
much with security at the moment we do a

00:43:36,549 --> 00:43:42,309
little bit since since like I said we do

00:43:39,579 --> 00:43:44,559
use J groups underneath to actually talk

00:43:42,309 --> 00:43:46,059
on the on the wire the G groups has got

00:43:44,559 --> 00:43:47,200
a number of security features and we

00:43:46,059 --> 00:43:48,910
just benefit from that

00:43:47,200 --> 00:43:50,950
like they move the G groups can be

00:43:48,910 --> 00:43:52,480
configured to use certificates ssl

00:43:50,950 --> 00:43:54,579
certificates for authentication to join

00:43:52,480 --> 00:43:56,710
a cluster G groups can also be

00:43:54,579 --> 00:43:58,869
configured to encrypt any traffic that

00:43:56,710 --> 00:44:02,230
sent on the network but in terms of

00:43:58,869 --> 00:44:03,970
security on the user level features so

00:44:02,230 --> 00:44:05,349
actually accessing stuff we don't

00:44:03,970 --> 00:44:10,510
support anything yet but it is on the

00:44:05,349 --> 00:44:12,460
roadmap okay so with that if there are

00:44:10,510 --> 00:44:13,630
no more questions thank you all for

00:44:12,460 --> 00:44:15,990
listening and I won't hold you back from

00:44:13,630 --> 00:44:15,990

YouTube URL: https://www.youtube.com/watch?v=K8qx0QdqfMI


