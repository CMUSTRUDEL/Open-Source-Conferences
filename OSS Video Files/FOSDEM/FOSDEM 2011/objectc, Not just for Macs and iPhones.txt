Title: objectc, Not just for Macs and iPhones
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	by David Chisnall

The GNUstep Objective-C runtime was designed to make it relatively easy to support other dynamic languages, sharing an object model with Objective-C. This talk will discuss some of the features and how they are used by LanguageKit, a framework designed to make it easy to implement domain-specific languages with static compilation, JIT and interpreter modes.

The GNUstep Objective-C runtime was designed to make it relatively easy to support other dynamic languages, sharing an object model with Objective-C. This talk will discuss some of the features and how they are used by LanguageKit, a framework designed to make it easy to implement domain-specific languages with static compilation, JIT and interpreter modes.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:02,030
I

00:00:04,470 --> 00:00:06,529
you

00:00:07,080 --> 00:00:12,010
so I don't really know who I'm speaking

00:00:09,880 --> 00:00:15,910
to hear how many people in this room who

00:00:12,010 --> 00:00:17,740
used objective-c before and so this

00:00:15,910 --> 00:00:19,750
little group of canoe step developers at

00:00:17,740 --> 00:00:22,630
the front and a few random other people

00:00:19,750 --> 00:00:24,119
scattered around so out of all of you

00:00:22,630 --> 00:00:29,590
people how many of you have used

00:00:24,119 --> 00:00:31,840
objective-c just on Apple platforms okay

00:00:29,590 --> 00:00:35,620
so most of you so the point of this talk

00:00:31,840 --> 00:00:38,079
is to say objective-c is usable on

00:00:35,620 --> 00:00:41,199
places that Apple has no interest in at

00:00:38,079 --> 00:00:42,870
all isn't doing anyone and this has

00:00:41,199 --> 00:00:47,859
actually been true for a long time

00:00:42,870 --> 00:00:50,199
objective-c was created in 1986 so it's

00:00:47,859 --> 00:00:52,420
not a brand new shiny exciting language

00:00:50,199 --> 00:00:55,390
it's been around for a while and the

00:00:52,420 --> 00:00:57,190
idea was that if you have a see library

00:00:55,390 --> 00:01:00,159
and you want to package it for other

00:00:57,190 --> 00:01:02,920
people to use you really want to give

00:01:00,159 --> 00:01:05,320
kind of an abstract interface with some

00:01:02,920 --> 00:01:09,280
loose coupling and late binding stuff

00:01:05,320 --> 00:01:12,100
and so brand Cox wrote a number of

00:01:09,280 --> 00:01:14,290
papers describing a lego building model

00:01:12,100 --> 00:01:15,640
firm software so you'd have some people

00:01:14,290 --> 00:01:18,250
who would be responsible for building

00:01:15,640 --> 00:01:19,899
the Lego bricks and some people who will

00:01:18,250 --> 00:01:22,360
be responsible for assembling those

00:01:19,899 --> 00:01:24,490
bricks into larger structures an

00:01:22,360 --> 00:01:26,950
objective-c was designed for that

00:01:24,490 --> 00:01:29,200
boundary where you'd have some people

00:01:26,950 --> 00:01:30,820
working in the sea like fit and some

00:01:29,200 --> 00:01:33,490
people working in the small talk like

00:01:30,820 --> 00:01:36,520
bit and they wouldn't necessarily be the

00:01:33,490 --> 00:01:38,229
same group of people and annexed bought

00:01:36,520 --> 00:01:41,500
his company and they bought the

00:01:38,229 --> 00:01:44,289
objective-c trademark and they shipped

00:01:41,500 --> 00:01:47,320
it as the core development system for

00:01:44,289 --> 00:01:49,270
their workstations and both people who

00:01:47,320 --> 00:01:53,409
bought a next work station really really

00:01:49,270 --> 00:01:55,750
liked it and next in the Free Software

00:01:53,409 --> 00:01:58,509
Foundation had a little falling out at

00:01:55,750 --> 00:02:00,159
around this time next took the canoe

00:01:58,509 --> 00:02:03,729
compiler collection and they added an

00:02:00,159 --> 00:02:06,759
objective-c front end and they tried to

00:02:03,729 --> 00:02:08,950
work around the GPL by releasing it as a

00:02:06,759 --> 00:02:11,230
shared library which GCC would then load

00:02:08,950 --> 00:02:12,700
and they thought yeah we don't have to

00:02:11,230 --> 00:02:15,310
release the source we can keep it

00:02:12,700 --> 00:02:17,530
proprietary and that's great for our

00:02:15,310 --> 00:02:19,360
commercial interests because having an

00:02:17,530 --> 00:02:19,930
objective c compiler gives us a massive

00:02:19,360 --> 00:02:23,680
competitive

00:02:19,930 --> 00:02:25,390
advantage apolis simpler of actually

00:02:23,680 --> 00:02:27,370
having objective c compiler gives them

00:02:25,390 --> 00:02:30,069
no competitive advantage at all so they

00:02:27,370 --> 00:02:32,260
release it as open source and the Free

00:02:30,069 --> 00:02:35,079
Software Foundation set their attack

00:02:32,260 --> 00:02:37,239
lawyers on next say if you have to

00:02:35,079 --> 00:02:39,879
release this code otherwise we will feed

00:02:37,239 --> 00:02:41,620
you to the Sharks and so next release

00:02:39,879 --> 00:02:42,939
this code and it turned out once they

00:02:41,620 --> 00:02:44,409
did that the reason they didn't want to

00:02:42,939 --> 00:02:47,170
release it was that it was really

00:02:44,409 --> 00:02:50,099
hideous and they were just too

00:02:47,170 --> 00:02:52,689
embarrassed to let anyone see it

00:02:50,099 --> 00:02:54,069
unfortunately at that point the Free

00:02:52,689 --> 00:02:56,019
Software Foundation have put so much

00:02:54,069 --> 00:02:57,879
effort into forcing them to release the

00:02:56,019 --> 00:02:59,980
code they couldn't just look at it and

00:02:57,879 --> 00:03:14,680
say actually no we don't want it after

00:02:59,980 --> 00:03:18,040
all so you look at this code and it's

00:03:14,680 --> 00:03:20,769
one single file which is about 1500

00:03:18,040 --> 00:03:23,290
lines long oh just no separation of

00:03:20,769 --> 00:03:25,449
concerns and it's completely unreadable

00:03:23,290 --> 00:03:27,459
and if something next had approached the

00:03:25,449 --> 00:03:29,260
Free Software Foundation and said hey

00:03:27,459 --> 00:03:31,150
we've written this new front end for

00:03:29,260 --> 00:03:33,879
objective-c they'd have said no thanks

00:03:31,150 --> 00:03:36,819
spy you keep it but because they tried

00:03:33,879 --> 00:03:38,650
to keep it private next that the free

00:03:36,819 --> 00:03:42,699
software foundation then did incorporate

00:03:38,650 --> 00:03:44,889
it and so the compiler is only half of

00:03:42,699 --> 00:03:47,169
the puzzle with Objective C the compiler

00:03:44,889 --> 00:03:49,030
generates calls into a funk into a

00:03:47,169 --> 00:03:51,489
runtime library which implements all of

00:03:49,030 --> 00:03:54,609
the dynamic features and did a required

00:03:51,489 --> 00:03:57,189
objective-c and next didn't release

00:03:54,609 --> 00:03:58,509
their runtime library which made getting

00:03:57,189 --> 00:04:01,239
the compilers bought actually not that

00:03:58,509 --> 00:04:02,739
interesting because the runtime at the

00:04:01,239 --> 00:04:04,479
time was more complicated than the

00:04:02,739 --> 00:04:06,959
compiler stuff so they only got the easy

00:04:04,479 --> 00:04:10,930
that and so the Free Software Foundation

00:04:06,959 --> 00:04:13,120
wrote a new one and next had done a few

00:04:10,930 --> 00:04:15,040
things in their design that weren't very

00:04:13,120 --> 00:04:17,620
sensible and they'd done some things

00:04:15,040 --> 00:04:19,959
that were done entirely for performance

00:04:17,620 --> 00:04:21,909
reasons but made it impossible to write

00:04:19,959 --> 00:04:24,970
a portable version of this library and

00:04:21,909 --> 00:04:27,370
the new project supports a load of

00:04:24,970 --> 00:04:29,500
different unix platforms it now supports

00:04:27,370 --> 00:04:30,940
windows and a few other things so having

00:04:29,500 --> 00:04:32,650
something where you need to write some

00:04:30,940 --> 00:04:36,550
custom assembly for every single

00:04:32,650 --> 00:04:39,250
combination of kernel and cpu they'd

00:04:36,550 --> 00:04:41,289
have needed to have the entire code base

00:04:39,250 --> 00:04:43,510
almost would have ended up being not

00:04:41,289 --> 00:04:45,760
portable it would have been horrible so

00:04:43,510 --> 00:04:48,219
they changed the design a bit and then

00:04:45,760 --> 00:04:51,279
the GCC code got some more conditionals

00:04:48,219 --> 00:04:53,139
but some things for the next run time

00:04:51,279 --> 00:04:55,360
and some things for the canoe runtime so

00:04:53,139 --> 00:04:59,440
this really ugly code became even more

00:04:55,360 --> 00:05:03,310
ugly and that was the status until about

00:04:59,440 --> 00:05:05,500
two thousand and I'll talk a bit about

00:05:03,310 --> 00:05:08,169
how that's changed in a few more slides

00:05:05,500 --> 00:05:10,510
and but for those of you who haven't

00:05:08,169 --> 00:05:11,560
really used objective-c the poor and

00:05:10,510 --> 00:05:13,389
just give a little bit of an

00:05:11,560 --> 00:05:16,570
introduction to what the language does

00:05:13,389 --> 00:05:20,229
and my it's interesting the first rule

00:05:16,570 --> 00:05:22,510
is that anything that has new semantics

00:05:20,229 --> 00:05:24,639
in the language has to have new syntax

00:05:22,510 --> 00:05:24,940
so you don't have this confusion where

00:05:24,639 --> 00:05:26,440
you have

00:05:24,940 --> 00:05:29,650
one line of code that could possibly

00:05:26,440 --> 00:05:32,410
mean five different things c++ has the

00:05:29,650 --> 00:05:35,200
opposite philosophy it says no new

00:05:32,410 --> 00:05:37,930
syntax for anything so you can look at a

00:05:35,200 --> 00:05:40,810
line of C++ and have no idea what it

00:05:37,930 --> 00:05:43,180
does at all the next thing is no

00:05:40,810 --> 00:05:47,830
objective c has no magic if you look at

00:05:43,180 --> 00:05:50,200
a language like pearl or small talk or

00:05:47,830 --> 00:05:52,660
anything dynamic scripting language type

00:05:50,200 --> 00:05:55,780
things they do a lot of stuff in the

00:05:52,660 --> 00:05:57,730
virtual machine or even java and they do

00:05:55,780 --> 00:05:59,890
things that really aren't exposed to the

00:05:57,730 --> 00:06:02,200
programmer and an objective-c everything

00:05:59,890 --> 00:06:05,430
that's done in the background for you by

00:06:02,200 --> 00:06:08,130
the compiler you can do in your own code

00:06:05,430 --> 00:06:10,360
and the other part of the philosophy is

00:06:08,130 --> 00:06:13,180
there should only be one way of doing

00:06:10,360 --> 00:06:14,590
stuff you don't have to decide I want to

00:06:13,180 --> 00:06:16,570
use this language feature or this

00:06:14,590 --> 00:06:19,660
language feature or are they equivalents

00:06:16,570 --> 00:06:20,740
so it's a very simple language and the

00:06:19,660 --> 00:06:24,910
one thing that everybody knows about

00:06:20,740 --> 00:06:26,820
objective-c is it has weird syntax it's

00:06:24,910 --> 00:06:28,960
you look at it and you say ah

00:06:26,820 --> 00:06:32,290
objective-c that's the language with the

00:06:28,960 --> 00:06:34,419
weird syntax and this is an example of

00:06:32,290 --> 00:06:36,880
an objective-c message send operation

00:06:34,419 --> 00:06:40,960
which is pajama program as you've caught

00:06:36,880 --> 00:06:42,940
a method call and it has this square

00:06:40,960 --> 00:06:44,950
bracket syntax and Tom loved one of the

00:06:42,940 --> 00:06:47,710
developers of the original objective c

00:06:44,950 --> 00:06:50,200
said that this is a sign post saying you

00:06:47,710 --> 00:06:52,660
are now entering object land and when

00:06:50,200 --> 00:06:54,130
you're inside the square brackets you're

00:06:52,660 --> 00:06:55,510
dealing with the high-level bit of the

00:06:54,130 --> 00:06:57,400
language when you're outside of the

00:06:55,510 --> 00:07:03,850
square brackets you're dealing with

00:06:57,400 --> 00:07:05,140
basically c code and this syntax takes a

00:07:03,850 --> 00:07:07,419
little bit of getting used to but it's

00:07:05,140 --> 00:07:12,340
actually really nice you find after a

00:07:07,419 --> 00:07:14,200
while that you read objective-c code you

00:07:12,340 --> 00:07:15,700
can read objective-c code that uses a

00:07:14,200 --> 00:07:18,280
library that you've never seen before

00:07:15,700 --> 00:07:20,500
and you're not constantly checking the

00:07:18,280 --> 00:07:22,900
api documentation to find out what stuff

00:07:20,500 --> 00:07:25,210
does because every parameter is named

00:07:22,900 --> 00:07:28,419
you don't get confused with parameter

00:07:25,210 --> 00:07:30,610
order and everything that is an

00:07:28,419 --> 00:07:33,100
objective-c message sends is in no way

00:07:30,610 --> 00:07:35,050
confusable with a seat function call so

00:07:33,100 --> 00:07:36,370
it's easy to look at a code a bit of

00:07:35,050 --> 00:07:38,979
and see what the performance

00:07:36,370 --> 00:07:40,990
characteristics are going to be and so

00:07:38,979 --> 00:07:44,319
we have this message send operation how

00:07:40,990 --> 00:07:47,440
does that really work this is the same

00:07:44,319 --> 00:07:50,139
thing just up at the top it's a message

00:07:47,440 --> 00:07:53,199
sent to the object called a dictionary

00:07:50,139 --> 00:07:56,530
the method name is set objects for key

00:07:53,199 --> 00:07:58,300
and the two arguments are a and B and if

00:07:56,530 --> 00:08:00,909
you're using the next runtime or the

00:07:58,300 --> 00:08:02,770
newer apple runtime then this is just

00:08:00,909 --> 00:08:05,500
compiled to the single function call

00:08:02,770 --> 00:08:07,569
objective-c message said and that takes

00:08:05,500 --> 00:08:09,789
the object is the first argument the

00:08:07,569 --> 00:08:11,919
selector which is can abstract version

00:08:09,789 --> 00:08:13,659
of the method name as the second

00:08:11,919 --> 00:08:17,020
argument and then all of the other

00:08:13,659 --> 00:08:19,419
arguments after that and that's pretty

00:08:17,020 --> 00:08:22,419
simple and this is the bit that's hard

00:08:19,419 --> 00:08:24,819
to port to other platforms because this

00:08:22,419 --> 00:08:26,949
function then has to call another

00:08:24,819 --> 00:08:30,580
function with the arguments that it was

00:08:26,949 --> 00:08:33,190
passed so you can't do that in C and you

00:08:30,580 --> 00:08:34,570
can have to do it in some / platform

00:08:33,190 --> 00:08:36,010
assembly and you actually have to do it

00:08:34,570 --> 00:08:39,760
once for every different calling

00:08:36,010 --> 00:08:41,020
convention so in the apple runtime they

00:08:39,760 --> 00:08:43,360
have a version of this called

00:08:41,020 --> 00:08:45,630
objective-c message said s rep which is

00:08:43,360 --> 00:08:48,610
functions that return structures and

00:08:45,630 --> 00:08:50,470
objective-c message send FP rep which is

00:08:48,610 --> 00:08:52,959
another version the functions that

00:08:50,470 --> 00:08:55,170
return floating point values and it

00:08:52,959 --> 00:09:00,399
quickly gets really horrible and messy

00:08:55,170 --> 00:09:03,250
but it is slightly faster the goo new

00:09:00,399 --> 00:09:06,250
runtime version and you does it as a

00:09:03,250 --> 00:09:08,100
two-step process of the first call is to

00:09:06,250 --> 00:09:11,260
this objective c message lookup function

00:09:08,100 --> 00:09:13,480
which returns a function pointer and

00:09:11,260 --> 00:09:15,339
then you just have the compiler insert a

00:09:13,480 --> 00:09:18,339
call to that function just as it would

00:09:15,339 --> 00:09:19,930
insert a call to any other c function so

00:09:18,339 --> 00:09:22,440
this is really the only thing that makes

00:09:19,930 --> 00:09:24,910
objective-c slower than see this one

00:09:22,440 --> 00:09:27,310
extra layer of indirection the method

00:09:24,910 --> 00:09:30,269
message look up so that's just a little

00:09:27,310 --> 00:09:33,699
bit of history and my objective c is

00:09:30,269 --> 00:09:35,620
interesting what it's how it works and

00:09:33,699 --> 00:09:39,690
i'm going to talk a bit about the status

00:09:35,620 --> 00:09:44,640
of modern objective c compilers

00:09:39,690 --> 00:09:47,070
and a few years ago GCC switch to gplv3

00:09:44,640 --> 00:09:49,800
and Apple has religious objections to

00:09:47,070 --> 00:09:52,530
this so they started putting a lot of

00:09:49,800 --> 00:09:54,750
effort into clamp which is a new bsd

00:09:52,530 --> 00:09:57,540
license front end the sea in Objective C

00:09:54,750 --> 00:09:59,190
and C++ and if you are at Chris Latinist

00:09:57,540 --> 00:10:01,800
talk yesterday he talked quite a bit

00:09:59,190 --> 00:10:04,910
more about this line going to now I'm

00:10:01,800 --> 00:10:09,270
clang is is not a small code base it's

00:10:04,910 --> 00:10:10,830
actually pretty huge and that's great

00:10:09,270 --> 00:10:14,820
because it means apples doing loads of

00:10:10,830 --> 00:10:16,320
work for us for three of these three

00:10:14,820 --> 00:10:18,740
hundred thousand lines of code about

00:10:16,320 --> 00:10:21,600
2,000 are specific to the gonna run time

00:10:18,740 --> 00:10:24,180
and a lot of those actually don't really

00:10:21,600 --> 00:10:26,910
need to be we've got a abstract

00:10:24,180 --> 00:10:28,770
superclass which encapsulate all of the

00:10:26,910 --> 00:10:31,290
runtime specific behavior in the code

00:10:28,770 --> 00:10:33,240
generation part and we have a concrete

00:10:31,290 --> 00:10:35,340
superclass for the new runtime in a

00:10:33,240 --> 00:10:37,980
concrete subclass public a new runtime a

00:10:35,340 --> 00:10:40,950
concrete subclass for each of the two

00:10:37,980 --> 00:10:42,570
Mac run titles and there's actually some

00:10:40,950 --> 00:10:44,730
code that could be shared between those

00:10:42,570 --> 00:10:48,090
two so we can probably reduce that

00:10:44,730 --> 00:10:50,460
number over time because there's just

00:10:48,090 --> 00:10:52,110
some stuff that rather than refactoring

00:10:50,460 --> 00:10:53,640
we've just copied and pasted from the

00:10:52,110 --> 00:10:56,850
mac runtime version into the canoe

00:10:53,640 --> 00:10:58,590
runtime version and you can use clang as

00:10:56,850 --> 00:11:01,530
a front end for a compiler and I think

00:10:58,590 --> 00:11:03,060
Chris talked about that quite a bit but

00:11:01,530 --> 00:11:05,370
that's not all kind can be used for it's

00:11:03,060 --> 00:11:08,700
a library based design so we can use it

00:11:05,370 --> 00:11:10,470
for some other interesting things and

00:11:08,700 --> 00:11:14,010
this is an example of using clang for

00:11:10,470 --> 00:11:16,650
syntax highlighting this is enlarged a

00:11:14,010 --> 00:11:18,690
lot so it looks really ugly but you can

00:11:16,650 --> 00:11:20,670
see that it's doing proper syntax

00:11:18,690 --> 00:11:23,490
highlighting they're not just lexical

00:11:20,670 --> 00:11:25,770
highlighting so for example this compare

00:11:23,490 --> 00:11:28,170
thing at the top is a macro and it knows

00:11:25,770 --> 00:11:30,240
it's a macro that highlights it it can

00:11:28,170 --> 00:11:32,520
tell that in pointer t is a type death

00:11:30,240 --> 00:11:34,770
it knows that big int is a class it

00:11:32,520 --> 00:11:37,500
knows that begins with long long is a

00:11:34,770 --> 00:11:40,080
message sent and if you just compare

00:11:37,500 --> 00:11:42,180
that with vim which does lexical

00:11:40,080 --> 00:11:45,270
highlighting which is really simple to

00:11:42,180 --> 00:11:49,589
implement and it's treating in pointed

00:11:45,270 --> 00:11:51,150
he is just a magic thing it's pretending

00:11:49,589 --> 00:11:52,950
that that's just a language keywords

00:11:51,150 --> 00:11:53,459
because it knows that that's defined by

00:11:52,950 --> 00:11:55,949
c9

00:11:53,459 --> 00:11:57,869
name but it doesn't know that big int is

00:11:55,949 --> 00:12:00,749
a class it doesn't know that begin with

00:11:57,869 --> 00:12:04,319
long long is a message send it doesn't

00:12:00,749 --> 00:12:07,709
know that comparison macro so Shane I'm

00:12:04,319 --> 00:12:10,110
clang of course it exposes the error

00:12:07,709 --> 00:12:12,029
reporting at the library level as well

00:12:10,110 --> 00:12:14,939
so this is just a little quickly hack

00:12:12,029 --> 00:12:19,499
together thing which in a normal con

00:12:14,939 --> 00:12:20,699
usted text view gives you tooltips for

00:12:19,499 --> 00:12:23,069
any of the errors that were generated

00:12:20,699 --> 00:12:25,649
and this isn't a great user interface

00:12:23,069 --> 00:12:30,300
but it was just a demo that was ten

00:12:25,649 --> 00:12:32,189
lines of code to write so as well as

00:12:30,300 --> 00:12:35,160
having a new compiler now we also have a

00:12:32,189 --> 00:12:39,420
new runtime which is a complete rewrite

00:12:35,160 --> 00:12:41,429
of the GCC runtime it's a quite a bit

00:12:39,420 --> 00:12:44,699
smaller than the GCC runtime a lot of

00:12:41,429 --> 00:12:47,160
that is that the GCC runtime really

00:12:44,699 --> 00:12:49,230
predates having portable threading api's

00:12:47,160 --> 00:12:51,360
so it has this huge threading

00:12:49,230 --> 00:12:53,970
abstraction layer most of which isn't

00:12:51,360 --> 00:12:56,639
actually called anywhere in the runtime

00:12:53,970 --> 00:12:58,740
some of which is incomplete it has a

00:12:56,639 --> 00:13:02,600
condition variable implementation which

00:12:58,740 --> 00:13:05,399
on Windows just always returns false

00:13:02,600 --> 00:13:08,549
we've added complete support for the new

00:13:05,399 --> 00:13:10,319
objective c 2 features there's a new ABI

00:13:08,549 --> 00:13:12,660
which has a few nice features that I'm

00:13:10,319 --> 00:13:14,699
going to talk about a little bit more we

00:13:12,660 --> 00:13:17,699
have working support for apples blocks

00:13:14,699 --> 00:13:19,559
extension we're actually quite pleased

00:13:17,699 --> 00:13:21,720
with that as we manage to ship a working

00:13:19,559 --> 00:13:24,389
version of the blocks runtime six months

00:13:21,720 --> 00:13:27,720
before Apple released their own language

00:13:24,389 --> 00:13:29,699
extension and there's also designed to

00:13:27,720 --> 00:13:31,079
support to other dynamic languages and I

00:13:29,699 --> 00:13:33,029
gave a talk yesterday and they're going

00:13:31,079 --> 00:13:35,399
to step develop the room about language

00:13:33,029 --> 00:13:37,439
kit which is a dynamic language

00:13:35,399 --> 00:13:40,199
implementation framework so we use the

00:13:37,439 --> 00:13:44,279
same compiler backend for compiling

00:13:40,199 --> 00:13:46,499
small talk and other languages so

00:13:44,279 --> 00:13:48,660
objective c has a little bit of overhead

00:13:46,499 --> 00:13:51,809
on c and really there are three things

00:13:48,660 --> 00:13:53,610
that are different in c and objective-c

00:13:51,809 --> 00:13:55,829
in terms of performance i said one

00:13:53,610 --> 00:13:58,079
earlier but the other two are quite so

00:13:55,829 --> 00:14:01,679
important one of them is with the new

00:13:58,079 --> 00:14:03,419
ABI now object to no longer just a

00:14:01,679 --> 00:14:05,840
little bit of syntactic sugar around

00:14:03,419 --> 00:14:08,030
structures objects

00:14:05,840 --> 00:14:11,180
instance variables or fields if you're a

00:14:08,030 --> 00:14:13,340
C or Java programmer and these are now

00:14:11,180 --> 00:14:16,370
accessed via an indirection layer which

00:14:13,340 --> 00:14:18,080
has some nice features for stopping you

00:14:16,370 --> 00:14:20,180
having to recompile all your code all

00:14:18,080 --> 00:14:24,320
the time but it adds just a little bit

00:14:20,180 --> 00:14:27,890
of overhead and with the GCC run time

00:14:24,320 --> 00:14:30,050
you have to look up every single time

00:14:27,890 --> 00:14:32,150
you send a message to a class you need

00:14:30,050 --> 00:14:34,610
to look up that class by name in a hash

00:14:32,150 --> 00:14:36,410
table and we're using a hopscotch hash

00:14:34,610 --> 00:14:39,110
which is pretty fast has nice

00:14:36,410 --> 00:14:41,510
performance with the data cache but it's

00:14:39,110 --> 00:14:43,970
still a hash table lookup for something

00:14:41,510 --> 00:14:45,920
that really doesn't need to be and also

00:14:43,970 --> 00:14:47,660
we have the dynamic message look up

00:14:45,920 --> 00:14:50,060
which I talked about a couple of slides

00:14:47,660 --> 00:14:53,240
ago so the first thing we can do is

00:14:50,060 --> 00:14:55,430
avoid this non project API use when it's

00:14:53,240 --> 00:14:58,190
not actually needed so the point of the

00:14:55,430 --> 00:15:00,740
nonpareil instance variable access is

00:14:58,190 --> 00:15:02,450
that allows you to ship a class which

00:15:00,740 --> 00:15:04,760
inherits from a class in someone else's

00:15:02,450 --> 00:15:06,680
library and then they change the layout

00:15:04,760 --> 00:15:09,590
of the instance variables in their class

00:15:06,680 --> 00:15:12,140
and you then don't need to recompile

00:15:09,590 --> 00:15:14,720
your class and that's a really useful

00:15:12,140 --> 00:15:18,560
feature and but what happens if you're

00:15:14,720 --> 00:15:20,600
just inheriting from other classes in

00:15:18,560 --> 00:15:23,240
your own framework or if you're just

00:15:20,600 --> 00:15:25,070
inheriting from nsobject which has a

00:15:23,240 --> 00:15:26,630
well-defined layout with just one

00:15:25,070 --> 00:15:28,640
instance variable two points to the

00:15:26,630 --> 00:15:30,980
class and nothing else it turns out

00:15:28,640 --> 00:15:33,470
that's actually a really common case so

00:15:30,980 --> 00:15:35,360
we can for all libraries that do that we

00:15:33,470 --> 00:15:37,580
can just go through find all the

00:15:35,360 --> 00:15:40,070
indirect lookups replace them with

00:15:37,580 --> 00:15:41,750
direct lookups so you're only paying for

00:15:40,070 --> 00:15:44,750
this indirection layer in cases where

00:15:41,750 --> 00:15:47,440
it's actually useful and we can do this

00:15:44,750 --> 00:15:53,060
as a link time optimization with llvm as

00:15:47,440 --> 00:15:56,180
so all of these if all of these look out

00:15:53,060 --> 00:15:58,550
tests are done with the entire code for

00:15:56,180 --> 00:16:00,080
your library or for your application and

00:15:58,550 --> 00:16:02,090
we can also do this with a just-in-time

00:16:00,080 --> 00:16:04,340
compiler for the language kit which

00:16:02,090 --> 00:16:06,110
means you can remove them in all cases

00:16:04,340 --> 00:16:08,300
because no one's going to change the

00:16:06,110 --> 00:16:09,620
layout of your super class after it's

00:16:08,300 --> 00:16:13,670
already been loaded into the running

00:16:09,620 --> 00:16:16,459
process class message overheads this one

00:16:13,670 --> 00:16:20,279
is really easy to fix we just make the

00:16:16,459 --> 00:16:24,379
class structure and the the compiler

00:16:20,279 --> 00:16:26,819
generates exporter public symbol and

00:16:24,379 --> 00:16:28,379
just reference that directly don't

00:16:26,819 --> 00:16:30,509
bother with the hash table lookup and

00:16:28,379 --> 00:16:33,120
Apple does the same thing for their

00:16:30,509 --> 00:16:35,160
runtime and this gives us a factor of

00:16:33,120 --> 00:16:37,560
five speed up and calling class methods

00:16:35,160 --> 00:16:39,209
if you look in the canoe step codes you

00:16:37,560 --> 00:16:42,089
can tell that they're well aware of how

00:16:39,209 --> 00:16:46,319
expensive this is because in almost

00:16:42,089 --> 00:16:48,720
every objective c file you see calls

00:16:46,319 --> 00:16:51,449
that cash the class pointer somewhere

00:16:48,720 --> 00:16:53,670
and then rather than sending messages to

00:16:51,449 --> 00:16:56,610
the class they sent messages to this

00:16:53,670 --> 00:16:58,319
class by on that layer of indirection so

00:16:56,610 --> 00:16:59,879
now we have stuff in canoe step which is

00:16:58,319 --> 00:17:01,829
actually making the code slower because

00:16:59,879 --> 00:17:04,709
it's adding another and direction

00:17:01,829 --> 00:17:08,699
they're rather than removing one so

00:17:04,709 --> 00:17:10,579
that's a shame but there are big thing

00:17:08,699 --> 00:17:13,230
though is the message sent because

00:17:10,579 --> 00:17:15,209
objective-c really encourages you to use

00:17:13,230 --> 00:17:19,049
this message sends as your basic

00:17:15,209 --> 00:17:21,089
primitive for flow control and with the

00:17:19,049 --> 00:17:23,400
new runtime design we want to be able to

00:17:21,089 --> 00:17:26,189
add caching support for that and this is

00:17:23,400 --> 00:17:28,590
based on some ideas that the self team

00:17:26,189 --> 00:17:31,380
we're implementing way back in nineteen

00:17:28,590 --> 00:17:33,419
ninety-five so it's not really new

00:17:31,380 --> 00:17:34,919
research stuff but I think were the

00:17:33,419 --> 00:17:37,770
first people to do it in a statically

00:17:34,919 --> 00:17:39,360
compiled language and the self guys were

00:17:37,770 --> 00:17:41,280
doing this in a virtual machine with

00:17:39,360 --> 00:17:42,960
accurate garbage collection and that

00:17:41,280 --> 00:17:45,990
makes this actually a really easy thing

00:17:42,960 --> 00:17:47,429
to do it's slightly harder for us so now

00:17:45,990 --> 00:17:49,230
the lookup function rather than just

00:17:47,429 --> 00:17:50,940
returning a function pointer it returns

00:17:49,230 --> 00:17:53,130
a pointer to a structure and this has

00:17:50,940 --> 00:17:55,830
some metadata which makes it easier to

00:17:53,130 --> 00:17:57,690
implement two languages that don't have

00:17:55,830 --> 00:18:00,419
quite the same type system as objective

00:17:57,690 --> 00:18:02,880
c it also contains a version and you can

00:18:00,419 --> 00:18:04,860
use the version to find out whether the

00:18:02,880 --> 00:18:08,159
structure is still the same is still

00:18:04,860 --> 00:18:09,809
valid so you cash the version outside

00:18:08,159 --> 00:18:11,640
the structure you compare whether the

00:18:09,809 --> 00:18:13,409
version in the structure and the version

00:18:11,640 --> 00:18:17,190
outside the structure are the same if

00:18:13,409 --> 00:18:19,770
they are it's great if they're not then

00:18:17,190 --> 00:18:22,919
you have to do the look up again but it

00:18:19,770 --> 00:18:25,049
means that now rather than having the

00:18:22,919 --> 00:18:26,789
sort of manual method point and caching

00:18:25,049 --> 00:18:28,649
that is fairly common in objective-c

00:18:26,789 --> 00:18:29,789
code you'll see people doing this in

00:18:28,649 --> 00:18:32,129
critical paths

00:18:29,789 --> 00:18:34,830
in pretty much any large objective-c

00:18:32,129 --> 00:18:36,960
project we can now make them Pilar do it

00:18:34,830 --> 00:18:41,210
automatically for free everywhere where

00:18:36,960 --> 00:18:43,590
it's sensible one thing that C

00:18:41,210 --> 00:18:45,659
programmers really like doing is using

00:18:43,590 --> 00:18:47,429
this inline keyword which the compiler

00:18:45,659 --> 00:18:50,850
then ignores and does its own thing but

00:18:47,429 --> 00:18:52,320
it tries to insert a copy of the

00:18:50,850 --> 00:18:54,119
function where it's called and that's

00:18:52,320 --> 00:18:57,149
really great for small functions we have

00:18:54,119 --> 00:18:58,590
loads of those an objective-c and the

00:18:57,149 --> 00:19:00,179
biggest case i think is probably

00:18:58,590 --> 00:19:01,889
accessor methods where you're just

00:19:00,179 --> 00:19:05,669
returning a value of an instance

00:19:01,889 --> 00:19:07,950
variable and so the cost of the message

00:19:05,669 --> 00:19:10,200
sends is quite thick the cost of even a

00:19:07,950 --> 00:19:12,809
function call there is a significant

00:19:10,200 --> 00:19:14,700
fraction of the total cost of doing the

00:19:12,809 --> 00:19:18,059
operation so in see you just in line

00:19:14,700 --> 00:19:19,889
that cool and that's great it's fast and

00:19:18,059 --> 00:19:22,649
it's easy because if you have a function

00:19:19,889 --> 00:19:24,299
call in see you know exactly what

00:19:22,649 --> 00:19:26,429
function is being called it's the

00:19:24,299 --> 00:19:28,529
function which has that name objective-c

00:19:26,429 --> 00:19:30,840
because it has this indirection layer

00:19:28,529 --> 00:19:32,759
that's kind of difficult we don't have

00:19:30,840 --> 00:19:37,259
this one to one mapping between cool

00:19:32,759 --> 00:19:38,849
site and collie now but we can get one

00:19:37,259 --> 00:19:40,919
and there are some heuristics we can use

00:19:38,849 --> 00:19:43,979
and there's profiling that we can do and

00:19:40,919 --> 00:19:45,659
then we can try in lining that and then

00:19:43,979 --> 00:19:48,720
we can just wrap that in a little test

00:19:45,659 --> 00:19:52,139
which says did we get right if so don't

00:19:48,720 --> 00:19:54,059
bother with the call just go straight

00:19:52,139 --> 00:19:56,519
through the inland version and that's

00:19:54,059 --> 00:19:59,369
then lets you do smother optimization so

00:19:56,519 --> 00:20:01,710
you can take the inline path and you can

00:19:59,369 --> 00:20:05,970
do constant propagation through that and

00:20:01,710 --> 00:20:08,340
so that can have some nice speed ups so

00:20:05,970 --> 00:20:12,239
I sort of wave my hands and said we can

00:20:08,340 --> 00:20:15,529
make stuff faster and no talk about

00:20:12,239 --> 00:20:17,940
compiles would be complete without some

00:20:15,529 --> 00:20:21,529
synthesized and highly misleading micro

00:20:17,940 --> 00:20:25,349
benchmarks so here is the obligatory

00:20:21,529 --> 00:20:30,899
misleading micro benchmark slide and the

00:20:25,349 --> 00:20:32,639
basic test is a simple loop which calls

00:20:30,899 --> 00:20:35,159
a method which does nothing and it does

00:20:32,639 --> 00:20:37,440
it a billion times and the target

00:20:35,159 --> 00:20:41,330
performance is getting it close to what

00:20:37,440 --> 00:20:43,220
a cost in C and so running this

00:20:41,330 --> 00:20:45,020
version with just a c function call

00:20:43,220 --> 00:20:48,200
rather than objective-c message send

00:20:45,020 --> 00:20:51,200
takes about three seconds and okay three

00:20:48,200 --> 00:20:53,000
seconds is not very long if you just

00:20:51,200 --> 00:20:55,070
compile with clang and you don't run any

00:20:53,000 --> 00:20:57,890
optimizations at all clang actually

00:20:55,070 --> 00:21:00,020
produces some quite messy intermediate

00:20:57,890 --> 00:21:02,030
representation for this which then the

00:21:00,020 --> 00:21:04,670
standard lvm optimization pass is

00:21:02,030 --> 00:21:07,370
cleaner than actually just running the

00:21:04,670 --> 00:21:10,250
basic optimizations because we have some

00:21:07,370 --> 00:21:12,140
gratuitous loads and stores and gets it

00:21:10,250 --> 00:21:13,760
down to eight seconds so eight seconds

00:21:12,140 --> 00:21:15,530
really isn't bad if the look up costs

00:21:13,760 --> 00:21:18,200
absolutely nothing just because we have

00:21:15,530 --> 00:21:20,540
to function calls six seconds is about

00:21:18,200 --> 00:21:21,920
what our target would be but we can get

00:21:20,540 --> 00:21:24,080
a bit better than man you turn on the

00:21:21,920 --> 00:21:27,110
automatic caching and it goes down to

00:21:24,080 --> 00:21:29,270
4.6 seconds that's just automatic

00:21:27,110 --> 00:21:31,280
caching by itself by the way if you have

00:21:29,270 --> 00:21:34,490
the automatic caching plus the stands

00:21:31,280 --> 00:21:38,420
llvm optimizations we're now down to 3.5

00:21:34,490 --> 00:21:41,270
seconds so really slightly slower than C

00:21:38,420 --> 00:21:43,880
but only just so now we turn on the

00:21:41,270 --> 00:21:47,350
speculative inlining and we're now

00:21:43,880 --> 00:21:49,910
faster than sea without in line so I

00:21:47,350 --> 00:21:51,410
think we're now at the point where we

00:21:49,910 --> 00:21:55,040
can make it faster but we just don't

00:21:51,410 --> 00:21:56,630
care anymore and you're talking about

00:21:55,040 --> 00:21:59,180
the difference between your application

00:21:56,630 --> 00:22:02,000
using five percent of your CPU and it

00:21:59,180 --> 00:22:06,080
using four-point-five percent it's just

00:22:02,000 --> 00:22:09,590
not important but micro benchmarks

00:22:06,080 --> 00:22:10,790
they're great for examples and slides

00:22:09,590 --> 00:22:15,650
and stuff but they don't necessarily

00:22:10,790 --> 00:22:19,490
reflect real wealth of walls and it's

00:22:15,650 --> 00:22:22,310
really important to realize that in any

00:22:19,490 --> 00:22:25,750
language a good language a fast compiler

00:22:22,310 --> 00:22:28,070
and a poor algorithm will never beat a

00:22:25,750 --> 00:22:30,410
really naive compiler and a good

00:22:28,070 --> 00:22:32,660
algorithm and so one of the nice things

00:22:30,410 --> 00:22:34,760
about objective-c is because it has this

00:22:32,660 --> 00:22:39,620
loose coupling it really encourages you

00:22:34,760 --> 00:22:41,480
to have optimizations at the macro scale

00:22:39,620 --> 00:22:44,030
rather than at the microscale because

00:22:41,480 --> 00:22:46,790
it's a dialect of c you can also do the

00:22:44,030 --> 00:22:48,800
micro optimizations in c and but the

00:22:46,790 --> 00:22:52,250
high-level approach really encourages

00:22:48,800 --> 00:22:54,170
some general optimizations i just have a

00:22:52,250 --> 00:22:55,130
quick example of this how many people

00:22:54,170 --> 00:22:56,900
here are

00:22:55,130 --> 00:23:01,000
here with the international components

00:22:56,900 --> 00:23:04,010
for unicode library okay a couple of you

00:23:01,000 --> 00:23:07,210
so this is a huge library which does

00:23:04,010 --> 00:23:09,700
lots of really useful things for

00:23:07,210 --> 00:23:12,560
internationalization for locales for

00:23:09,700 --> 00:23:14,810
Unicode has unicode regular expressions

00:23:12,560 --> 00:23:17,210
some really nice things and it has

00:23:14,810 --> 00:23:18,950
internally its own representation of

00:23:17,210 --> 00:23:22,280
strings which is done as a see abstract

00:23:18,950 --> 00:23:25,160
data type and it has fast macros for

00:23:22,280 --> 00:23:29,360
accessing characters by copying out a

00:23:25,160 --> 00:23:31,820
load of utf-8 characters and I've seen

00:23:29,360 --> 00:23:35,150
quite a few libraries that use this from

00:23:31,820 --> 00:23:39,620
C++ the C++ you have the standard string

00:23:35,150 --> 00:23:41,930
class and it's all really designed to be

00:23:39,620 --> 00:23:45,650
inlined and be fast and that's great

00:23:41,930 --> 00:23:48,080
turns out no one actually uses it in big

00:23:45,650 --> 00:23:50,870
libraries it seems to be a c++ library

00:23:48,080 --> 00:23:53,110
gets to a certain size and implements

00:23:50,870 --> 00:23:55,610
its own c class its own string class

00:23:53,110 --> 00:23:57,560
it's like a rite of passage and there

00:23:55,610 --> 00:24:00,080
are a couple of examples there lvm has

00:23:57,560 --> 00:24:03,050
it string wrath thing cutie has its own

00:24:00,080 --> 00:24:05,660
class WebKit has the thing called

00:24:03,050 --> 00:24:10,280
deprecated string in the WTF namespace

00:24:05,660 --> 00:24:13,250
which I particularly liked and so the

00:24:10,280 --> 00:24:15,770
way people use live I see you from C++

00:24:13,250 --> 00:24:18,320
is they get alibi see new string and

00:24:15,770 --> 00:24:22,700
they copy it to a temporary buffer as a

00:24:18,320 --> 00:24:24,800
array of 16-bit characters and then they

00:24:22,700 --> 00:24:27,200
copy it from a temporary buffer into

00:24:24,800 --> 00:24:29,540
their own string class and so you have

00:24:27,200 --> 00:24:32,750
to linear time algorithms for every

00:24:29,540 --> 00:24:36,470
single string operation and if you're

00:24:32,750 --> 00:24:40,430
using the ICU regular expressions then

00:24:36,470 --> 00:24:44,240
one of these conversions maybe hundreds

00:24:40,430 --> 00:24:47,030
of kilobytes of code I've run a regex

00:24:44,240 --> 00:24:50,780
code on text from my last book and so

00:24:47,030 --> 00:24:52,610
that's loads of text and so these linear

00:24:50,780 --> 00:24:56,960
time algorithms they really

00:24:52,610 --> 00:24:59,330
performance and this happens a lot of

00:24:56,960 --> 00:25:01,640
boundaries between two C++ libraries

00:24:59,330 --> 00:25:03,170
where one has one string class that it

00:25:01,640 --> 00:25:05,810
thinks is great the other one has its

00:25:03,170 --> 00:25:07,580
own happy string class which is also

00:25:05,810 --> 00:25:08,690
great and probably as implements in

00:25:07,580 --> 00:25:10,220
exactly the same way

00:25:08,690 --> 00:25:13,550
but with very slightly different layout

00:25:10,220 --> 00:25:16,850
or interfaces an objective-c those this

00:25:13,550 --> 00:25:19,820
NS string class and it's a standard

00:25:16,850 --> 00:25:22,040
string class but it doesn't actually do

00:25:19,820 --> 00:25:24,470
anything the NS string class is an

00:25:22,040 --> 00:25:29,210
abstract class the real implementation

00:25:24,470 --> 00:25:32,000
is some hidden concrete subclass on OS

00:25:29,210 --> 00:25:34,100
10 it's probably n SCF string or some

00:25:32,000 --> 00:25:37,460
variant of that I'm going to step there

00:25:34,100 --> 00:25:39,950
are few GS string subclasses and it's

00:25:37,460 --> 00:25:42,830
very flexible it can store the text

00:25:39,950 --> 00:25:45,170
internally in a variety of ways it just

00:25:42,830 --> 00:25:47,960
gives you this abstract interface as if

00:25:45,170 --> 00:25:51,230
it's an array of 16-bit characters so

00:25:47,960 --> 00:25:55,610
everyone uses it and when we call ICU

00:25:51,230 --> 00:25:58,970
functions from ganoush step we just have

00:25:55,610 --> 00:26:02,030
a subclass of NS string which uses the

00:25:58,970 --> 00:26:04,340
ICU underlying text representation and

00:26:02,030 --> 00:26:06,530
we do that the opposite way around as

00:26:04,340 --> 00:26:10,220
well so we implement their abstract data

00:26:06,530 --> 00:26:13,730
type in terms of the NS string so we

00:26:10,220 --> 00:26:18,980
have to constant time operations that's

00:26:13,730 --> 00:26:21,170
great so the slow language objective-c

00:26:18,980 --> 00:26:22,640
ends up using algorithms that are much

00:26:21,170 --> 00:26:27,350
faster just because that's the easiest

00:26:22,640 --> 00:26:29,270
way of doing is an objective-c so that's

00:26:27,350 --> 00:26:30,680
how to make objective-c fast they now

00:26:29,270 --> 00:26:33,890
let's talk a little bit about making it

00:26:30,680 --> 00:26:37,250
a bit more reliable so this is a couple

00:26:33,890 --> 00:26:39,800
of objective c class interfaces they

00:26:37,250 --> 00:26:42,020
both to cut define a method with the

00:26:39,800 --> 00:26:43,550
same name but one takes an integer as a

00:26:42,020 --> 00:26:46,820
parameter one takes a float as a

00:26:43,550 --> 00:26:48,860
parameter and the implementation of

00:26:46,820 --> 00:26:51,320
these are simple they just use printf to

00:26:48,860 --> 00:26:53,270
displayed on the terminal and so you

00:26:51,320 --> 00:26:55,910
have some code at the bottom which calls

00:26:53,270 --> 00:26:58,790
this method and but in the last line

00:26:55,910 --> 00:27:01,490
you're calling an instance of class b

00:26:58,790 --> 00:27:03,470
but your static type annotation says

00:27:01,490 --> 00:27:05,390
it's an instance of class a and that's

00:27:03,470 --> 00:27:06,560
not an abuse of the type system that's

00:27:05,390 --> 00:27:09,050
totally allowed because you're just

00:27:06,560 --> 00:27:10,910
casting a class to the superclass so you

00:27:09,050 --> 00:27:13,070
can pile this without vm or you compile

00:27:10,910 --> 00:27:15,410
it with clan and both will say

00:27:13,070 --> 00:27:17,390
absolutely fine no warnings that's great

00:27:15,410 --> 00:27:20,300
so what happens if you run this on the

00:27:17,390 --> 00:27:21,900
map well the first pour works the second

00:27:20,300 --> 00:27:25,080
call works and oops

00:27:21,900 --> 00:27:27,660
you've called a function which expects a

00:27:25,080 --> 00:27:30,330
floating point value but you put your

00:27:27,660 --> 00:27:32,510
argument in an integer register so it

00:27:30,330 --> 00:27:36,000
just silently does the wrong thing and

00:27:32,510 --> 00:27:37,620
and if you do this slightly more extreme

00:27:36,000 --> 00:27:39,510
case if it's a function returning

00:27:37,620 --> 00:27:42,270
structure and the function not returning

00:27:39,510 --> 00:27:43,950
structure and then you don't just get

00:27:42,270 --> 00:27:46,520
the wrong result you get random snack

00:27:43,950 --> 00:27:49,280
corruption and that's that's not ideal

00:27:46,520 --> 00:27:51,720
on sparc you get an illegal instruction

00:27:49,280 --> 00:27:55,590
exception in a trap then the board and

00:27:51,720 --> 00:27:58,290
that's marginally better so with the

00:27:55,590 --> 00:28:01,050
ghanoush that run time we do dispatch

00:27:58,290 --> 00:28:03,150
based on the type as well so now we're

00:28:01,050 --> 00:28:06,240
calling the correct function and that's

00:28:03,150 --> 00:28:08,070
a bit nicer so we're only matching

00:28:06,240 --> 00:28:10,230
methods with the correct type signature

00:28:08,070 --> 00:28:14,070
when we do the lookup if there's no

00:28:10,230 --> 00:28:16,640
matching version then we call a handler

00:28:14,070 --> 00:28:19,260
and that can return a fix-up version and

00:28:16,640 --> 00:28:21,780
so if you've got correct well-written

00:28:19,260 --> 00:28:23,910
objective-c code it just works and I

00:28:21,780 --> 00:28:26,430
enabled this by default about six months

00:28:23,910 --> 00:28:29,130
ago and I was really shocked that it

00:28:26,430 --> 00:28:31,050
didn't break loads of people's code we

00:28:29,130 --> 00:28:35,490
found a few bugs in canoe step using it

00:28:31,050 --> 00:28:37,500
but mostly it just stuff works and what

00:28:35,490 --> 00:28:38,910
happens if you then have the same idea

00:28:37,500 --> 00:28:43,380
but the opposite way around if you do a

00:28:38,910 --> 00:28:47,910
downcast and then you call this method

00:28:43,380 --> 00:28:50,370
which it thinks should be accepting the

00:28:47,910 --> 00:28:53,310
caller thinks it's passing a float and

00:28:50,370 --> 00:28:57,810
the collie is expecting the integer well

00:28:53,310 --> 00:28:59,460
again on OS 10 calls the function and

00:28:57,810 --> 00:29:02,640
there's some nonsense in the register

00:28:59,460 --> 00:29:04,320
with the gooseneck runtime now it does

00:29:02,640 --> 00:29:07,040
this it says you're calling this method

00:29:04,320 --> 00:29:09,840
but you're doing it wrong fix your code

00:29:07,040 --> 00:29:12,600
so having this reporting an error is

00:29:09,840 --> 00:29:14,700
just a little bit nicer with a twilight

00:29:12,600 --> 00:29:17,190
which is project to build a desktop

00:29:14,700 --> 00:29:19,110
environment on top of the new step we

00:29:17,190 --> 00:29:21,270
actually go one step further and we use

00:29:19,110 --> 00:29:24,450
some of el el viernes jit compiling

00:29:21,270 --> 00:29:27,180
stuff and we now insert a fix-up method

00:29:24,450 --> 00:29:30,200
which says you did it wrong but don't

00:29:27,180 --> 00:29:30,200
worry we know what you mean

00:29:30,269 --> 00:29:36,529
we're going to do that type conversion

00:29:32,700 --> 00:29:39,539
for you and call the correct method so

00:29:36,529 --> 00:29:40,859
this is just a little demo that I think

00:29:39,539 --> 00:29:42,959
is quite fun I probably wouldn't

00:29:40,859 --> 00:29:45,029
recommend enabling it in production code

00:29:42,959 --> 00:29:48,959
but when you're testing stuff it's quite

00:29:45,029 --> 00:29:51,779
nice to say okay you've got a bug we'll

00:29:48,959 --> 00:29:54,479
fix it for now at runtime you can carry

00:29:51,779 --> 00:29:57,859
on your testing but don't forget to fix

00:29:54,479 --> 00:30:00,149
it in your code before you actually

00:29:57,859 --> 00:30:01,649
so I've talked a bit about the compiler

00:30:00,149 --> 00:30:03,239
in the runtime and how we have

00:30:01,649 --> 00:30:05,879
objective-c working on other platforms

00:30:03,239 --> 00:30:09,149
and how in some ways at least I version

00:30:05,879 --> 00:30:11,279
is nicer than apples but objective-c is

00:30:09,149 --> 00:30:14,669
a really tiny language and by itself

00:30:11,279 --> 00:30:19,440
it's actually not that much use you can

00:30:14,669 --> 00:30:22,379
wrap up c libraries with it but four

00:30:19,440 --> 00:30:24,239
objectives need to be really useful it's

00:30:22,379 --> 00:30:26,729
the frameworks that really give it the

00:30:24,239 --> 00:30:29,039
power and if you're programming on OS 10

00:30:26,729 --> 00:30:34,249
you're using these cocoa frameworks and

00:30:29,039 --> 00:30:36,479
their proprietary so well how do you

00:30:34,249 --> 00:30:39,690
deal with that when you're using another

00:30:36,479 --> 00:30:42,479
platform what turns out coco although

00:30:39,690 --> 00:30:43,859
it's a proprietary implementation is an

00:30:42,479 --> 00:30:46,979
implementation of an open specification

00:30:43,859 --> 00:30:48,869
and this was a collaboration between Sun

00:30:46,979 --> 00:30:51,719
and next way back in nineteen ninety two

00:30:48,869 --> 00:30:54,629
and if you notice the NS prefix on all

00:30:51,719 --> 00:30:58,549
of the classes in cocoa that stands for

00:30:54,629 --> 00:31:01,829
next and son the old neck stuff used NX

00:30:58,549 --> 00:31:03,389
and way back when this specification was

00:31:01,829 --> 00:31:07,139
created the canoe step project was

00:31:03,389 --> 00:31:09,450
formed to implement it and it didn't get

00:31:07,139 --> 00:31:12,959
much use because next over its entire

00:31:09,450 --> 00:31:15,149
history sold about 50,000 computers and

00:31:12,959 --> 00:31:18,239
that's 50,000 computers over about a

00:31:15,149 --> 00:31:19,919
decade which is not really enough for

00:31:18,239 --> 00:31:21,690
people to have a large installed base

00:31:19,919 --> 00:31:23,700
people using these frameworks and saying

00:31:21,690 --> 00:31:25,709
oh they're actually pretty nice you had

00:31:23,700 --> 00:31:27,719
a few people in academia Tim berners-lee

00:31:25,709 --> 00:31:31,139
said some really nice things about it

00:31:27,719 --> 00:31:34,619
but yeah it didn't really get widespread

00:31:31,139 --> 00:31:36,839
adoption then I pull bought next and

00:31:34,619 --> 00:31:40,049
renamed their openstep implementation

00:31:36,839 --> 00:31:41,579
cocoa and suddenly there were loads of

00:31:40,049 --> 00:31:44,039
cheap computers and it seems weird to

00:31:41,579 --> 00:31:46,019
think of Max as cheap computers

00:31:44,039 --> 00:31:47,940
but in comparison with next who's

00:31:46,019 --> 00:31:49,470
cheapest machine was five thousand

00:31:47,940 --> 00:31:52,789
dollars and that was five thousand

00:31:49,470 --> 00:31:56,789
dollars in early 90s late 80s money and

00:31:52,789 --> 00:31:59,129
Max are actually really cheap so canoe

00:31:56,789 --> 00:32:01,200
step then switched from implementing the

00:31:59,129 --> 00:32:03,629
openstep specification to implementing

00:32:01,200 --> 00:32:07,340
the open specification plus Coco

00:32:03,629 --> 00:32:11,029
extensions and so where is it now well

00:32:07,340 --> 00:32:15,419
most of the stuff from OS 10 10.4 works

00:32:11,029 --> 00:32:17,789
which is a nice base level a lot of

00:32:15,419 --> 00:32:21,330
stuff from newer versions works we've

00:32:17,789 --> 00:32:26,249
got things like some of the newer locale

00:32:21,330 --> 00:32:29,700
and calendar stuff various random things

00:32:26,249 --> 00:32:32,309
a few things from the iphone operating

00:32:29,700 --> 00:32:34,080
system their version of foundation we've

00:32:32,309 --> 00:32:37,080
now implemented some stuff like the

00:32:34,080 --> 00:32:38,729
unicode regular expression classes and

00:32:37,080 --> 00:32:40,950
basically stuff that people actually

00:32:38,729 --> 00:32:44,070
want to use tends to get implemented

00:32:40,950 --> 00:32:45,899
first occasionally Apple is very helpful

00:32:44,070 --> 00:32:47,820
to us they'll add a new API and one

00:32:45,899 --> 00:32:50,309
version we won't get around to

00:32:47,820 --> 00:32:52,440
implementing it then they'll deprecated

00:32:50,309 --> 00:32:54,179
it in the next version and then they'll

00:32:52,440 --> 00:32:57,019
remove it in the version afterwards and

00:32:54,179 --> 00:33:00,359
so we don't have to bother with that one

00:32:57,019 --> 00:33:02,429
but generally stuff people use a lot

00:33:00,359 --> 00:33:05,009
gets done first and tends to be quite

00:33:02,429 --> 00:33:07,769
stable but of course patches are welcome

00:33:05,009 --> 00:33:10,139
so we've had a few companies say we want

00:33:07,769 --> 00:33:12,539
to port our application good news that

00:33:10,139 --> 00:33:15,509
can almost do it so it's cheaper to just

00:33:12,539 --> 00:33:17,759
add the bits to canoe step send the

00:33:15,509 --> 00:33:19,470
patches along than it is to completely

00:33:17,759 --> 00:33:23,099
rewrite our application for another

00:33:19,470 --> 00:33:25,019
platform and so one thing that I guess

00:33:23,099 --> 00:33:29,489
everybody knows about the new step is

00:33:25,019 --> 00:33:37,549
that it has this classic look and which

00:33:29,489 --> 00:33:41,580
is totally timeless and it has this

00:33:37,549 --> 00:33:45,090
really consistent behavior that mimics

00:33:41,580 --> 00:33:46,799
how next step worked and this is still

00:33:45,090 --> 00:33:49,499
the default look for a new step because

00:33:46,799 --> 00:33:51,690
one of the aims is to faithfully

00:33:49,499 --> 00:33:54,960
recreate all of the stuff that next did

00:33:51,690 --> 00:33:56,789
well and the difference is that now this

00:33:54,960 --> 00:33:57,920
is an option for the new step it's not

00:33:56,789 --> 00:34:01,380
the only thing

00:33:57,920 --> 00:34:04,290
so canoe stet has had increasing support

00:34:01,380 --> 00:34:07,710
for themes recently and a theme is not

00:34:04,290 --> 00:34:09,630
just for visual appearance all drawing

00:34:07,710 --> 00:34:12,600
and canoe step happens by our delegate

00:34:09,630 --> 00:34:15,000
class now and you can replace that with

00:34:12,600 --> 00:34:16,890
a theme that does custom drawing in code

00:34:15,000 --> 00:34:19,680
or just with a simple one that loads

00:34:16,890 --> 00:34:21,120
pics maps and they can also alter the

00:34:19,680 --> 00:34:23,280
behavior so there are some nice things

00:34:21,120 --> 00:34:25,350
we can do we can move the menu into the

00:34:23,280 --> 00:34:27,270
window where Windows users expected in

00:34:25,350 --> 00:34:30,240
people with desktop environments that

00:34:27,270 --> 00:34:32,160
try copying windows expected we can use

00:34:30,240 --> 00:34:34,890
native panels for things we can change

00:34:32,160 --> 00:34:36,390
the cust the shortcut keys in menus so

00:34:34,890 --> 00:34:37,980
that they correspond to the platform's

00:34:36,390 --> 00:34:39,960
user interface guidelines we can do all

00:34:37,980 --> 00:34:42,650
of that kind of stuff so I just want to

00:34:39,960 --> 00:34:45,030
give you a few examples of that this is

00:34:42,650 --> 00:34:48,270
being as a word processor that was

00:34:45,030 --> 00:34:51,960
written for OS 10 it requires 10.4 or

00:34:48,270 --> 00:34:53,520
later it uses some newer api's and it

00:34:51,960 --> 00:34:55,680
was never written as a portable

00:34:53,520 --> 00:34:58,680
application it was written as an OS 10

00:34:55,680 --> 00:35:00,420
word processor and it now watch some

00:34:58,680 --> 00:35:03,570
good new steps so this is what it looks

00:35:00,420 --> 00:35:05,130
like in its native environment you can

00:35:03,570 --> 00:35:07,290
see oh you actually can't see the top of

00:35:05,130 --> 00:35:10,710
the screen but there should be a menu

00:35:07,290 --> 00:35:12,900
bar off the top of the screen and it's

00:35:10,710 --> 00:35:14,820
you know it's a native Coco app and then

00:35:12,900 --> 00:35:17,100
you take it to a new step and you see

00:35:14,820 --> 00:35:20,730
this classic industrial look with the

00:35:17,100 --> 00:35:23,390
floating manually others okay it doesn't

00:35:20,730 --> 00:35:25,680
actually look quite that ugly the and

00:35:23,390 --> 00:35:28,410
resolution doesn't quite match up so the

00:35:25,680 --> 00:35:30,810
anti-aliasing is broken but it's it's

00:35:28,410 --> 00:35:33,390
gray and it's boxes and that's the good

00:35:30,810 --> 00:35:35,970
news that trademark gregory's recently

00:35:33,390 --> 00:35:37,950
been working on a known thing so you run

00:35:35,970 --> 00:35:39,060
it in a gnome environment and again you

00:35:37,950 --> 00:35:42,120
can't quite through the top of the

00:35:39,060 --> 00:35:45,150
screen but it has the menu in the window

00:35:42,120 --> 00:35:48,510
now and the menu looks like her no menu

00:35:45,150 --> 00:35:53,100
the widgets all look like gnome widgets

00:35:48,510 --> 00:35:55,290
the file dialog box is still big a new

00:35:53,100 --> 00:35:57,330
step one but well the themes are work in

00:35:55,290 --> 00:35:59,580
progress so hopefully that won't stay

00:35:57,330 --> 00:36:01,950
there for much longer the windows theme

00:35:59,580 --> 00:36:04,590
is a little bit more mature it uses the

00:36:01,950 --> 00:36:07,110
windows api for drawing the menu it uses

00:36:04,590 --> 00:36:09,030
the windows common dialog box stop the

00:36:07,110 --> 00:36:11,400
draw doing the standard opening mile

00:36:09,030 --> 00:36:13,799
panels for doing the print hand

00:36:11,400 --> 00:36:17,309
the color well on chooser all of the

00:36:13,799 --> 00:36:19,529
standard cocoa things that you just call

00:36:17,309 --> 00:36:21,210
in to the library to produce it now just

00:36:19,529 --> 00:36:23,730
called in to the windows library to

00:36:21,210 --> 00:36:28,289
produce so it looks and it feels like a

00:36:23,730 --> 00:36:30,480
native windows application and and I'm

00:36:28,289 --> 00:36:32,099
just going to finish up with a couple of

00:36:30,480 --> 00:36:33,779
things that we can do an objective-c

00:36:32,099 --> 00:36:35,789
just to give you a taste of why

00:36:33,779 --> 00:36:39,510
objective-c is more fun to program with

00:36:35,789 --> 00:36:42,440
then they're pure c and one of these

00:36:39,510 --> 00:36:44,930
things is higher order messaging which

00:36:42,440 --> 00:36:47,369
originally came from small talk and

00:36:44,930 --> 00:36:49,529
small talk stole it from functional

00:36:47,369 --> 00:36:51,750
programming languages the idea is that

00:36:49,529 --> 00:36:54,059
rather than having a function that takes

00:36:51,750 --> 00:36:56,010
a function as an argument you have a

00:36:54,059 --> 00:36:58,200
message that takes a message is an

00:36:56,010 --> 00:36:59,640
argument in blow that's not all actually

00:36:58,200 --> 00:37:03,150
how it works but that's how it looks

00:36:59,640 --> 00:37:05,010
like it works two programmers so I could

00:37:03,150 --> 00:37:08,430
try and explain this but it's much

00:37:05,010 --> 00:37:10,710
easier to show you some examples and if

00:37:08,430 --> 00:37:12,270
you've written any Haskell or ml code

00:37:10,710 --> 00:37:14,460
then this will probably look quite

00:37:12,270 --> 00:37:16,559
familiar to you at the top you have an

00:37:14,460 --> 00:37:18,390
array and you send it a map message and

00:37:16,559 --> 00:37:21,750
then you send it make up a case message

00:37:18,390 --> 00:37:23,520
and so the return value for this is

00:37:21,750 --> 00:37:25,829
another array which is the result of

00:37:23,520 --> 00:37:27,599
sending a make up a case message to

00:37:25,829 --> 00:37:29,880
every element in the array that's pretty

00:37:27,599 --> 00:37:32,369
simple and you can do the same with a

00:37:29,880 --> 00:37:36,960
filter operation so you send it is

00:37:32,369 --> 00:37:38,970
supported message and it then iterates

00:37:36,960 --> 00:37:42,390
along every object every object in the

00:37:38,970 --> 00:37:46,829
collection and returns just an array

00:37:42,390 --> 00:37:48,480
which supports those versions and the

00:37:46,829 --> 00:37:50,700
one in the middle is actually quite nice

00:37:48,480 --> 00:37:54,089
since very common in Objective C

00:37:50,700 --> 00:37:56,760
programs to have a delegate class which

00:37:54,089 --> 00:37:58,650
implements some methods that are

00:37:56,760 --> 00:38:01,230
required and some methods are optional

00:37:58,650 --> 00:38:04,650
and so every time you call the delegate

00:38:01,230 --> 00:38:06,750
you have to bracket the message sensei

00:38:04,650 --> 00:38:10,109
do you actually respond to this method

00:38:06,750 --> 00:38:12,480
or to this message or should I just not

00:38:10,109 --> 00:38:13,980
bother calling it and with this

00:38:12,480 --> 00:38:16,020
higher-order message we just say

00:38:13,980 --> 00:38:20,339
delegate if it responds to this do it

00:38:16,020 --> 00:38:23,490
and the result from the if response

00:38:20,339 --> 00:38:24,770
method is a proxy and it then receives

00:38:23,490 --> 00:38:28,460
the

00:38:24,770 --> 00:38:30,320
stop or message it checks whether the

00:38:28,460 --> 00:38:32,090
thing that it's proxying actually

00:38:30,320 --> 00:38:34,820
responds to that if it does it forwards

00:38:32,090 --> 00:38:37,100
it great if it doesn't then it ignores

00:38:34,820 --> 00:38:41,890
it and this now uses the fast proxying

00:38:37,100 --> 00:38:44,540
mechanism so this is very very fast

00:38:41,890 --> 00:38:46,480
using the old proxying mechanism it was

00:38:44,540 --> 00:38:50,510
about three hundred times more expensive

00:38:46,480 --> 00:38:52,070
than doing just a normal message send

00:38:50,510 --> 00:38:54,620
now it's about three times more

00:38:52,070 --> 00:38:57,140
expensive so that's a bit of an

00:38:54,620 --> 00:38:59,780
improvement the last one is probably my

00:38:57,140 --> 00:39:02,480
favorite one this in new thread message

00:38:59,780 --> 00:39:04,970
returns the proxy that has the object

00:39:02,480 --> 00:39:08,330
wrapped up in its own thread with its

00:39:04,970 --> 00:39:10,760
own message queue and that's using a lot

00:39:08,330 --> 00:39:13,280
this ring buffer to push the messages

00:39:10,760 --> 00:39:14,780
across very quickly so now you sense the

00:39:13,280 --> 00:39:16,790
start message and that's added to the

00:39:14,780 --> 00:39:19,550
queue it returns immediately and then in

00:39:16,790 --> 00:39:21,230
the other thread it starts playing you

00:39:19,550 --> 00:39:25,370
send the current track message and it

00:39:21,230 --> 00:39:28,130
returns a proxy object and then you send

00:39:25,370 --> 00:39:29,690
a message to this return value and then

00:39:28,130 --> 00:39:32,300
you get the synchronization so it

00:39:29,690 --> 00:39:34,880
doesn't block until you actually try and

00:39:32,300 --> 00:39:36,830
use the result from calling the message

00:39:34,880 --> 00:39:39,440
in the other thread so we can have this

00:39:36,830 --> 00:39:41,930
really nice simple implicit concurrency

00:39:39,440 --> 00:39:44,780
and we've used that in a media player

00:39:41,930 --> 00:39:46,880
application near Twilight and we just

00:39:44,780 --> 00:39:49,010
Chuck the decoder stuff in another

00:39:46,880 --> 00:39:51,320
thread and it just sits there and we

00:39:49,010 --> 00:39:52,970
pretend from a programming perspective

00:39:51,320 --> 00:39:56,300
but it's all happening in the main

00:39:52,970 --> 00:39:57,980
thread and it looks like it is but it's

00:39:56,300 --> 00:40:01,180
all done asynchronously and the

00:39:57,980 --> 00:40:05,000
synchronizations happened implicitly

00:40:01,180 --> 00:40:08,330
well we can also do some fun stuff like

00:40:05,000 --> 00:40:11,180
automatic persistence we have this is

00:40:08,330 --> 00:40:12,680
why they serialize framework and one of

00:40:11,180 --> 00:40:14,240
the nice things about objective-c is

00:40:12,680 --> 00:40:16,520
that has introspection meta data

00:40:14,240 --> 00:40:19,490
everywhere so every object you can

00:40:16,520 --> 00:40:21,590
enumerate all of the methods that it has

00:40:19,490 --> 00:40:23,450
what their types are you can enumerate

00:40:21,590 --> 00:40:25,580
all of the instance variables what their

00:40:23,450 --> 00:40:28,520
types are you can see its superclass all

00:40:25,580 --> 00:40:31,340
of that stuff so we can look at an

00:40:28,520 --> 00:40:34,730
object visit every objects that it

00:40:31,340 --> 00:40:36,800
references and we can automatically

00:40:34,730 --> 00:40:38,690
serialize all of its instance variables

00:40:36,800 --> 00:40:40,890
we can take snapshots of object

00:40:38,690 --> 00:40:42,660
messages that you send to objects are

00:40:40,890 --> 00:40:45,000
actually objects themselves so we can

00:40:42,660 --> 00:40:47,460
record those as well we can record the

00:40:45,000 --> 00:40:50,730
entire undo history to disk with no

00:40:47,460 --> 00:40:52,440
modifications of the model code in a

00:40:50,730 --> 00:40:54,990
statically compiled language that's

00:40:52,440 --> 00:40:57,690
almost as fast to see so that's pretty

00:40:54,990 --> 00:41:00,060
nice and we can go beyond objective-c

00:40:57,690 --> 00:41:04,920
yesterday over talk about language kit

00:41:00,060 --> 00:41:06,840
and that's another compiler built on top

00:41:04,920 --> 00:41:09,630
of lvm giving you an abstract syntax

00:41:06,840 --> 00:41:11,100
tree for small talk like languages so we

00:41:09,630 --> 00:41:13,920
can implement small talk and we can

00:41:11,100 --> 00:41:15,720
implement a dialect of JavaScript on top

00:41:13,920 --> 00:41:17,580
of the same runtime sharing the same

00:41:15,720 --> 00:41:20,520
object you can take an objective C

00:41:17,580 --> 00:41:23,130
object object C class you can sub

00:41:20,520 --> 00:41:25,280
classes in JavaScript in small talk you

00:41:23,130 --> 00:41:28,020
can then use that as a prototype in

00:41:25,280 --> 00:41:29,820
JavaScript and it's all compiled down to

00:41:28,020 --> 00:41:33,780
machine code there's no virtual machine

00:41:29,820 --> 00:41:36,510
and it's pretty magic and we've also got

00:41:33,780 --> 00:41:38,940
some kind of research stuff going on the

00:41:36,510 --> 00:41:42,240
new runtime takes the sender as one of

00:41:38,940 --> 00:41:44,700
the arguments of the lookup method and

00:41:42,240 --> 00:41:47,400
so we can implement this thing called

00:41:44,700 --> 00:41:49,350
object planes and Damien's been doing

00:41:47,400 --> 00:41:52,080
some work on that in small talk as well

00:41:49,350 --> 00:41:54,990
and the idea is that you have objects

00:41:52,080 --> 00:41:57,540
that are grouped in some semantic group

00:41:54,990 --> 00:41:59,790
and that might be related to a document

00:41:57,540 --> 00:42:01,470
or related to a specific library and

00:41:59,790 --> 00:42:04,440
every time you send a message between

00:42:01,470 --> 00:42:06,060
two of these discrete groups the message

00:42:04,440 --> 00:42:08,190
is intercepted and you can do some

00:42:06,060 --> 00:42:10,260
rewriting on it so we can do things like

00:42:08,190 --> 00:42:12,330
implicit concurrency every time you send

00:42:10,260 --> 00:42:15,180
a message to any of the objects in this

00:42:12,330 --> 00:42:18,150
group it's added to a new threads to a

00:42:15,180 --> 00:42:21,030
message queue in that thread we can do

00:42:18,150 --> 00:42:23,490
access control so we can say only

00:42:21,030 --> 00:42:25,830
objects in this set are allowed to

00:42:23,490 --> 00:42:28,290
access some methods so we can do some

00:42:25,830 --> 00:42:30,710
sound boxing like that and we can do

00:42:28,290 --> 00:42:33,590
what mattered serialization its people

00:42:30,710 --> 00:42:35,760
and I just like to finish by

00:42:33,590 --> 00:42:38,580
provisionally announcing a brand new

00:42:35,760 --> 00:42:42,390
objective c compiler which should be

00:42:38,580 --> 00:42:43,920
appearing quite soon i've been working

00:42:42,390 --> 00:42:48,330
on this a bit with a company called path

00:42:43,920 --> 00:42:51,540
scale and their existing compiler is a

00:42:48,330 --> 00:42:52,290
forked vocal in 64 an open 60 core has a

00:42:51,540 --> 00:42:54,540
really

00:42:52,290 --> 00:42:57,360
nice architecture it has an intermediate

00:42:54,540 --> 00:42:59,640
representation which is initially at a

00:42:57,360 --> 00:43:02,040
very high level it's very close to a C

00:42:59,640 --> 00:43:03,810
or a Fortran abstract syntax tree and

00:43:02,040 --> 00:43:05,730
you can do some high level optimizations

00:43:03,810 --> 00:43:08,550
there and it's lowered through five

00:43:05,730 --> 00:43:10,590
stages and at each of the stages you can

00:43:08,550 --> 00:43:13,160
do more optimization so they're really

00:43:10,590 --> 00:43:16,080
heavily focused on optimization and

00:43:13,160 --> 00:43:19,920
their aim is to be ten percent faster

00:43:16,080 --> 00:43:22,620
than any other competing compiler so if

00:43:19,920 --> 00:43:25,350
you file a bug report with them saying

00:43:22,620 --> 00:43:28,560
ICC has passed the new for our code they

00:43:25,350 --> 00:43:31,710
regard that as a valid bug report and it

00:43:28,560 --> 00:43:35,120
has stuff like openmp it has support for

00:43:31,710 --> 00:43:38,100
offloading stuff on the GPU and and

00:43:35,120 --> 00:43:40,110
they're now using the same front end as

00:43:38,100 --> 00:43:43,260
llvm they're using this clang front end

00:43:40,110 --> 00:43:45,270
which is really modular so the

00:43:43,260 --> 00:43:49,280
dependencies between our BM and clang

00:43:45,270 --> 00:43:51,750
are actually really small it has a

00:43:49,280 --> 00:43:54,510
single library in the klang source tree

00:43:51,750 --> 00:43:57,060
takes the clang abstract syntax tree and

00:43:54,510 --> 00:43:59,670
it emits llvm intermediate

00:43:57,060 --> 00:44:01,650
representation for that and all they're

00:43:59,670 --> 00:44:03,300
doing is just replacing that library

00:44:01,650 --> 00:44:04,320
with another library that does the same

00:44:03,300 --> 00:44:07,350
thing but with their intermediate

00:44:04,320 --> 00:44:10,530
representation and this will be release

00:44:07,350 --> 00:44:11,970
open source quite soon so you can maybe

00:44:10,530 --> 00:44:13,620
use that if you're working on another

00:44:11,970 --> 00:44:15,540
compiler you could use that as an

00:44:13,620 --> 00:44:20,010
example of how to emit gimple or

00:44:15,540 --> 00:44:23,940
something else and that's the end like

00:44:20,010 --> 00:44:26,640
she'll just throw that in and my latest

00:44:23,940 --> 00:44:28,820
book was released this week so if you

00:44:26,640 --> 00:44:32,480
want to learn more about objective-c and

00:44:28,820 --> 00:44:32,480
if anyone has any questions

00:44:44,900 --> 00:44:46,960

YouTube URL: https://www.youtube.com/watch?v=l2humz9hIVM


