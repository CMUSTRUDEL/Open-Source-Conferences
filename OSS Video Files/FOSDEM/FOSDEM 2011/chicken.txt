Title: chicken
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:07,610 --> 00:00:13,090
okay I'm talking about Cheney on the NPA

00:00:09,950 --> 00:00:13,090
it's a technique

00:00:13,700 --> 00:00:24,270
that's quite interesting and that's used

00:00:17,310 --> 00:00:27,240
in dynamic language implementation okay

00:00:24,270 --> 00:00:29,550
yep as I said is it strategy for

00:00:27,240 --> 00:00:33,030
compilers of translating high level 9

00:00:29,550 --> 00:00:36,270
which is to see and it's invented by

00:00:33,030 --> 00:00:38,910
Henry Baker quite a long time ago Andrew

00:00:36,270 --> 00:00:43,079
Apple another compiler hacker had input

00:00:38,910 --> 00:00:46,940
for this strategy it's used in scheme

00:00:43,079 --> 00:00:50,160
compilers or in the scheme compiler and

00:00:46,940 --> 00:00:54,030
utilizes the the capabilities of this

00:00:50,160 --> 00:00:58,890
language but it's can be applied to all

00:00:54,030 --> 00:01:00,449
languages that need these features it

00:00:58,890 --> 00:01:02,879
provides support for the efficient

00:01:00,449 --> 00:01:04,530
implementation of continuations the

00:01:02,879 --> 00:01:09,270
language feature of of the scheme

00:01:04,530 --> 00:01:12,570
language and it's it supports tail call

00:01:09,270 --> 00:01:16,409
optimization which means that procedure

00:01:12,570 --> 00:01:20,820
in a certain position can be optimized

00:01:16,409 --> 00:01:27,570
the procedure call okay why compare to

00:01:20,820 --> 00:01:29,909
see you can use it on many platforms you

00:01:27,570 --> 00:01:31,829
it's often simpler than compiling

00:01:29,909 --> 00:01:36,390
director tonight native code or to write

00:01:31,829 --> 00:01:39,600
code and it takes advantage of existing

00:01:36,390 --> 00:01:41,610
compilers and the optimizations they can

00:01:39,600 --> 00:01:45,869
provide you can use it for

00:01:41,610 --> 00:01:48,840
cross-compilation exon library is

00:01:45,869 --> 00:01:52,640
written in C++ or C easily to interface

00:01:48,840 --> 00:01:55,049
to and it simplifies deployment and

00:01:52,640 --> 00:01:57,479
bootstrapping of a system if you have

00:01:55,049 --> 00:02:00,030
something in c you can always build it

00:01:57,479 --> 00:02:06,220
up from scratch

00:02:00,030 --> 00:02:08,229
so what's continuation it represents the

00:02:06,220 --> 00:02:13,270
current state of the computation it

00:02:08,229 --> 00:02:15,610
represents what happens next in two you

00:02:13,270 --> 00:02:17,260
can view it as a snapshot of the stack

00:02:15,610 --> 00:02:19,150
the local variables return addresses

00:02:17,260 --> 00:02:23,530
everything that's that's going to be

00:02:19,150 --> 00:02:28,239
used after the after a computation takes

00:02:23,530 --> 00:02:30,940
place and you can reify in them it's a

00:02:28,239 --> 00:02:34,810
term used for this why are we entering

00:02:30,940 --> 00:02:36,610
them and instantiating the continuation

00:02:34,810 --> 00:02:41,650
and the computed computation that's

00:02:36,610 --> 00:02:44,350
represented by it some languages allow

00:02:41,650 --> 00:02:46,510
to use a continuation or to reify it

00:02:44,350 --> 00:02:48,720
multiple times that means you can return

00:02:46,510 --> 00:02:52,930
more than once which is interesting

00:02:48,720 --> 00:02:56,650
concept and it's it's quite powerful in

00:02:52,930 --> 00:03:01,569
certain situations here i have an

00:02:56,650 --> 00:03:05,140
example where the attempts to show where

00:03:01,569 --> 00:03:08,109
the continuation is what continuation

00:03:05,140 --> 00:03:11,650
represents while my code is executing so

00:03:08,109 --> 00:03:13,930
when this this is scheme quote now and

00:03:11,650 --> 00:03:17,260
this is a function definition of the

00:03:13,930 --> 00:03:21,130
very well known function I don't explain

00:03:17,260 --> 00:03:23,560
it now so and in every position every in

00:03:21,130 --> 00:03:26,260
every place in the computation there is

00:03:23,560 --> 00:03:29,140
an implicit continuation that represents

00:03:26,260 --> 00:03:33,239
what happens next so in the relational

00:03:29,140 --> 00:03:35,980
hear you that's the continuation that is

00:03:33,239 --> 00:03:38,769
this represents what happens when it

00:03:35,980 --> 00:03:40,840
returns when the function returns and as

00:03:38,769 --> 00:03:43,390
the expressions nest and the code

00:03:40,840 --> 00:03:52,460
executes and the results of the code are

00:03:43,390 --> 00:03:55,490
then used you see then this is this

00:03:52,460 --> 00:03:58,100
work this is here you see it in the end

00:03:55,490 --> 00:04:01,910
0 call for example for the conditioner

00:03:58,100 --> 00:04:06,680
the continuation is its conditional

00:04:01,910 --> 00:04:10,100
itself and in here where you have

00:04:06,680 --> 00:04:13,370
variable XS and the constant number

00:04:10,100 --> 00:04:16,550
again it's on the variable X s it's the

00:04:13,370 --> 00:04:18,680
continuation is 20 call and so on it's

00:04:16,550 --> 00:04:22,700
like the here you have an expression

00:04:18,680 --> 00:04:25,850
that nests and every nested expression

00:04:22,700 --> 00:04:34,010
returns its result to the outcome to the

00:04:25,850 --> 00:04:37,700
outer computation and this this is the

00:04:34,010 --> 00:04:40,640
continuation that uses this result the

00:04:37,700 --> 00:04:42,650
passes that you on to the next one it's

00:04:40,640 --> 00:04:47,510
a bit difficult to explain and have my

00:04:42,650 --> 00:04:49,940
problems with it but it tries to show

00:04:47,510 --> 00:04:52,310
that there's always a continuation as an

00:04:49,940 --> 00:04:53,960
abstract concept that represents what

00:04:52,310 --> 00:04:58,090
happens next what happens with the

00:04:53,960 --> 00:04:58,090
result of something that executes

00:04:58,120 --> 00:05:04,580
how can you use these continuations you

00:05:01,610 --> 00:05:09,080
take a snapshot effectively of the of

00:05:04,580 --> 00:05:13,520
the current state and by re-entering

00:05:09,080 --> 00:05:15,710
this this stage you can implement every

00:05:13,520 --> 00:05:18,460
sort of control flow like exceptions

00:05:15,710 --> 00:05:21,220
where you just walk jump down the stack

00:05:18,460 --> 00:05:24,460
like coal routines where we're different

00:05:21,220 --> 00:05:30,490
continuations invoke each other and

00:05:24,460 --> 00:05:33,710
backtracking which retries effectively

00:05:30,490 --> 00:05:37,670
some an alternative in the transitive

00:05:33,710 --> 00:05:40,540
branch and the set of possible options

00:05:37,670 --> 00:05:44,420
or things like go through which are just

00:05:40,540 --> 00:05:46,550
jumps and the continuation can be used

00:05:44,420 --> 00:05:51,260
if you have explicit access to this

00:05:46,550 --> 00:05:55,160
feature it can be used to implement all

00:05:51,260 --> 00:05:58,040
these control flow of forms another

00:05:55,160 --> 00:06:00,590
thing is that you can you can use it to

00:05:58,040 --> 00:06:03,410
implement threads because it's a threat

00:06:00,590 --> 00:06:05,870
is just the state a sack and local data

00:06:03,410 --> 00:06:08,780
and if you have some method of the

00:06:05,870 --> 00:06:11,090
engine you can do we love threads these

00:06:08,780 --> 00:06:13,490
are green threads as i call them user

00:06:11,090 --> 00:06:16,280
level threats and which has the

00:06:13,490 --> 00:06:18,919
advantage that they're very efficient we

00:06:16,280 --> 00:06:20,260
don't have system calls and switches in

00:06:18,919 --> 00:06:23,980
between

00:06:20,260 --> 00:06:30,040
um okay continuations are difficult to

00:06:23,980 --> 00:06:31,900
implement there they it drags his rock

00:06:30,040 --> 00:06:34,450
through a whole language implementation

00:06:31,900 --> 00:06:39,130
to provide support for this activation

00:06:34,450 --> 00:06:42,990
frames what builds up on the stack have

00:06:39,130 --> 00:06:45,850
indefinite extend which means that they

00:06:42,990 --> 00:06:48,660
they don't have follow a stack light

00:06:45,850 --> 00:06:51,190
manner of allocation and releasing it

00:06:48,660 --> 00:06:55,900
can be allocated and they can be reused

00:06:51,190 --> 00:06:59,140
at some weird point in time and they are

00:06:55,900 --> 00:07:00,490
not necessarily released in the same on

00:06:59,140 --> 00:07:05,620
the opposite order than they were

00:07:00,490 --> 00:07:08,800
allocated the next thing is yeah exactly

00:07:05,620 --> 00:07:11,290
continuations we can be created at a

00:07:08,800 --> 00:07:13,300
very high frequency so this thing has to

00:07:11,290 --> 00:07:14,860
be has to work fast if you have a

00:07:13,300 --> 00:07:21,040
threading implementation based on

00:07:14,860 --> 00:07:23,260
continuations is this must burn the next

00:07:21,040 --> 00:07:26,050
thing is that activation frames must be

00:07:23,260 --> 00:07:30,130
heat allocated to have this indefinite

00:07:26,050 --> 00:07:32,050
lifetime an alternative is to allocate

00:07:30,130 --> 00:07:33,940
them on the stack and then move them

00:07:32,050 --> 00:07:36,970
into the heap once they are captured if

00:07:33,940 --> 00:07:41,020
not then you just leave it on the sec

00:07:36,970 --> 00:07:43,720
but that's a possible implementation

00:07:41,020 --> 00:07:45,430
that's exactly the next thing it's how

00:07:43,720 --> 00:07:48,520
implement how do i implement these

00:07:45,430 --> 00:07:52,900
things you can actually take a stack

00:07:48,520 --> 00:07:55,990
stack snapshot that's theoretically

00:07:52,900 --> 00:07:59,259
possible and it's very heavy weight that

00:07:55,990 --> 00:08:03,729
needs a lot of lot of space and it's

00:07:59,259 --> 00:08:08,229
just crazy and the next thing is as make

00:08:03,729 --> 00:08:10,360
context there are certain api's that in

00:08:08,229 --> 00:08:12,699
Linux I think there are and not sure

00:08:10,360 --> 00:08:14,800
about other operating systems that can

00:08:12,699 --> 00:08:18,699
where you can create such an execution

00:08:14,800 --> 00:08:21,729
context with a specific stack and but

00:08:18,699 --> 00:08:23,460
it's it's specific for for operating

00:08:21,729 --> 00:08:27,400
systems you don't have it everywhere and

00:08:23,460 --> 00:08:29,800
it's a bit hairy to set up and have your

00:08:27,400 --> 00:08:31,810
way to Ruby uses this approach I think

00:08:29,800 --> 00:08:35,680
what I'm not sure if the actual

00:08:31,810 --> 00:08:38,370
implementation now use it you can use

00:08:35,680 --> 00:08:41,829
all threads operating system Reds to

00:08:38,370 --> 00:08:45,190
have a separate state that you can

00:08:41,829 --> 00:08:48,820
manipulate our lightweight threats like

00:08:45,190 --> 00:08:51,730
fibers but again this is specific to a

00:08:48,820 --> 00:08:58,630
particular operating system another

00:08:51,730 --> 00:09:01,209
alternative is to use exceptions and 22

00:08:58,630 --> 00:09:04,630
book due to a have some sort bookkeeping

00:09:01,209 --> 00:09:09,160
code that is possible to reinstate this

00:09:04,630 --> 00:09:12,550
call chain and use exceptions to to to

00:09:09,160 --> 00:09:14,829
jump down again and it's it's very hairy

00:09:12,550 --> 00:09:18,910
technique but it works and is using some

00:09:14,829 --> 00:09:22,600
implementations the problem is as most

00:09:18,910 --> 00:09:25,720
techniques platform dependent highly

00:09:22,600 --> 00:09:29,279
complex or just too heavy weight too

00:09:25,720 --> 00:09:33,520
much to slow down in an implementation

00:09:29,279 --> 00:09:35,440
now an advantage approach is that you

00:09:33,520 --> 00:09:37,540
don't need use a stack at all or you

00:09:35,440 --> 00:09:39,410
don't use it in a stack like manner you

00:09:37,540 --> 00:09:42,060
just

00:09:39,410 --> 00:09:45,600
make sure that these activation frames

00:09:42,060 --> 00:09:48,030
that you can handle manually are created

00:09:45,600 --> 00:09:52,070
and reclaimed efficiently always ficient

00:09:48,030 --> 00:09:54,870
Lee as possible this simplifies things

00:09:52,070 --> 00:09:57,990
naturally and you can concentrate on

00:09:54,870 --> 00:10:01,200
doing this these two operations as fast

00:09:57,990 --> 00:10:03,300
as possible the next step is to

00:10:01,200 --> 00:10:07,730
translate to continuation passing style

00:10:03,300 --> 00:10:10,530
something that I will explain now

00:10:07,730 --> 00:10:13,710
continuation passing style is it's a

00:10:10,530 --> 00:10:17,130
transformation source code or a program

00:10:13,710 --> 00:10:20,730
transformation that where every

00:10:17,130 --> 00:10:24,270
procedure call is gets an additional

00:10:20,730 --> 00:10:26,790
argument it represents this continuation

00:10:24,270 --> 00:10:28,820
you make them extra make it the implicit

00:10:26,790 --> 00:10:32,760
continuation is going to be made

00:10:28,820 --> 00:10:37,670
explicit and pass on into every

00:10:32,760 --> 00:10:40,620
procedure call and this results in all

00:10:37,670 --> 00:10:45,870
calls being in Taylor position there are

00:10:40,620 --> 00:10:49,180
the last thing a procedure does and the

00:10:45,870 --> 00:10:53,080
continuation itself is just

00:10:49,180 --> 00:10:54,940
the closure that is a function and the

00:10:53,080 --> 00:10:58,810
local data put together into a data

00:10:54,940 --> 00:11:04,510
structure and it can be invoked then

00:10:58,810 --> 00:11:07,930
which is effectively returning this is

00:11:04,510 --> 00:11:09,820
now an example of the the transformation

00:11:07,930 --> 00:11:14,020
we have this familiar function here

00:11:09,820 --> 00:11:15,520
again and now if we perform this

00:11:14,020 --> 00:11:18,520
transformation you see that every

00:11:15,520 --> 00:11:19,900
procedure gets all these this user level

00:11:18,520 --> 00:11:22,810
for future gets an additional argument

00:11:19,900 --> 00:11:27,070
which is the continuation itself and

00:11:22,810 --> 00:11:29,980
every procedure call gets past and it's

00:11:27,070 --> 00:11:32,110
passed in a continuation argument this

00:11:29,980 --> 00:11:34,990
continuation is just a function which

00:11:32,110 --> 00:11:38,440
again takes the result and continues

00:11:34,990 --> 00:11:42,400
with what follows this call now the call

00:11:38,440 --> 00:11:45,760
to 0 is followed by the test whether

00:11:42,400 --> 00:11:49,180
it's true or not and this test is

00:11:45,760 --> 00:11:52,600
followed by returning either one or come

00:11:49,180 --> 00:11:55,120
computing the next number so every every

00:11:52,600 --> 00:11:56,860
procedure call gets this additional

00:11:55,120 --> 00:12:00,370
parameter which is the continuation

00:11:56,860 --> 00:12:04,540
itself and and here we have the

00:12:00,370 --> 00:12:08,230
recursion and it it performs a tail call

00:12:04,540 --> 00:12:10,120
a call in tail position where it jumps

00:12:08,230 --> 00:12:11,890
back and calls itself again with the

00:12:10,120 --> 00:12:14,080
parrot with the continuation argument

00:12:11,890 --> 00:12:16,540
you note that this is the same argument

00:12:14,080 --> 00:12:19,660
that's used here so it's a tail call or

00:12:16,540 --> 00:12:23,410
what they know it's not a table but yes

00:12:19,660 --> 00:12:25,270
the time the star the multiplication is

00:12:23,410 --> 00:12:26,950
actually a tail call it's the last thing

00:12:25,270 --> 00:12:28,380
that happened that happens in this

00:12:26,950 --> 00:12:32,940
procedure

00:12:28,380 --> 00:12:40,620
yeah that is CPS or continuation passing

00:12:32,940 --> 00:12:46,230
style Jericho optimization means if the

00:12:40,620 --> 00:12:47,820
GPS transformation transforms the record

00:12:46,230 --> 00:12:51,390
in the such a way that every procedure

00:12:47,820 --> 00:12:55,380
call that's done inside such a procedure

00:12:51,390 --> 00:12:57,390
is the last thing it does it doesn't

00:12:55,380 --> 00:12:59,310
have to build up stack space so it's in

00:12:57,390 --> 00:13:05,700
tail position and it's the last thing it

00:12:59,310 --> 00:13:09,500
does and it it allows you to perform

00:13:05,700 --> 00:13:12,720
this call and constant space so it's you

00:13:09,500 --> 00:13:15,360
can represent you can do recursion which

00:13:12,720 --> 00:13:18,030
is actually an iteration and the

00:13:15,360 --> 00:13:20,280
languages like scheme you don't have

00:13:18,030 --> 00:13:23,460
iteration constructs it just uses

00:13:20,280 --> 00:13:28,250
recursion tail recursion in this case

00:13:23,460 --> 00:13:31,650
that that you can use to true form loops

00:13:28,250 --> 00:13:36,480
and here we have a we have this tries

00:13:31,650 --> 00:13:38,430
this tries to attend which part of the

00:13:36,480 --> 00:13:40,860
codes in tail position which is not this

00:13:38,430 --> 00:13:43,110
isn't here position and again the one is

00:13:40,860 --> 00:13:44,820
the part of the last thing and this

00:13:43,110 --> 00:13:47,250
isn't a position true but this is it's

00:13:44,820 --> 00:13:51,930
an actual procedure call so it's it's

00:13:47,250 --> 00:13:55,940
called take on a table yes okay how do

00:13:51,930 --> 00:13:59,280
you how do you implement this there are

00:13:55,940 --> 00:14:01,230
GCC does actually a bit of tail call

00:13:59,280 --> 00:14:02,850
implementation but it has restrictions

00:14:01,230 --> 00:14:06,750
if you take the address of a local

00:14:02,850 --> 00:14:08,850
variable and pass it around it it won't

00:14:06,750 --> 00:14:11,610
do this optimization and it's very

00:14:08,850 --> 00:14:14,850
specific to GCC and it's Harry to figure

00:14:11,610 --> 00:14:16,220
out when the cases when the case is

00:14:14,850 --> 00:14:21,590
apply

00:14:16,220 --> 00:14:25,760
another possibility is trampolines where

00:14:21,590 --> 00:14:27,910
you have every procedure call returns a

00:14:25,760 --> 00:14:31,010
pointer again to the next procedure and

00:14:27,910 --> 00:14:35,960
you have a driver loop that lets this

00:14:31,010 --> 00:14:41,420
run this is pretty inefficient and it's

00:14:35,960 --> 00:14:44,450
you effectively interpreting the next

00:14:41,420 --> 00:14:45,860
thing is if you just you just put it

00:14:44,450 --> 00:14:49,180
everything together and a big function

00:14:45,860 --> 00:14:52,930
and have a switch or computed goals that

00:14:49,180 --> 00:14:57,980
that implement these these tail calls

00:14:52,930 --> 00:15:01,550
but it's the problems that you need you

00:14:57,980 --> 00:15:04,390
need either mechanisms to true reduce

00:15:01,550 --> 00:15:06,650
the size of these of these large

00:15:04,390 --> 00:15:12,080
procedures are these last see functions

00:15:06,650 --> 00:15:16,180
and it's you need static analysis or

00:15:12,080 --> 00:15:19,149
something oh my god is it already over

00:15:16,180 --> 00:15:24,009
okay

00:15:19,149 --> 00:15:30,290
yeah okay um I can't do much then nano

00:15:24,009 --> 00:15:34,720
what okay um yeah shall I continue a bit

00:15:30,290 --> 00:15:39,830
surgery I just stopped a few minutes

00:15:34,720 --> 00:15:42,770
okay and yeah

00:15:39,830 --> 00:15:46,970
CPS can be used to do this okay an hour

00:15:42,770 --> 00:15:53,540
let's is the I miscalculated they're so

00:15:46,970 --> 00:15:58,120
little bit fun okay sorry okay okay

00:15:53,540 --> 00:15:58,120

YouTube URL: https://www.youtube.com/watch?v=6-uOhR7LxHk


