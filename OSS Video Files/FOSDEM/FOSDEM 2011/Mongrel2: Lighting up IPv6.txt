Title: Mongrel2: Lighting up IPv6
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	By Andrew Yourtchenko

This talk is to give a short overview of the mongrel2 project and share the experience gained while adding the IPv6 support.

Mongrel2 is an application, language, and network architecture agnostic web server that focuses on web applications using modern browser technologies.

    *

      Language Agnostic with a simple backend protocol supporting Ruby, Ruby through Rack, Python, C++, PHP, Haskell, Common Lisp, Perl, .NET, Clojure, and Lua all written by Mongrel2 fans.
    *

      Modern Browser Friendly designed to handle HTTP, Flash XMLSockets, or WebSockets, Long Polling on the same socket transparently.
    *

      ZeroMQ Enabled as well as HTTP proxy support so it works with what you have already while giving you new super powers.
    *

      Network Architecture Agnostic so you can carve your operations up anyway that reduces costs.
    *

      N:M Messaging Patterns means you can have any N handlers answer to any M browsers arbitrarily, but still easy to do plain request/response.
    *

      Automation Loving Configs that are easily accessible via any programming language with an Model-View-Controller design.
    *

      Modern Internal Design using the Mongrel 1 HTTP parser powering many big companies with a proven security track record, event based I/O, fast coroutines to handle that I/O, and smart reasonable defaults with zero configuration needed usually.
    *

      Documented, Documented, Documented We document everything in a well written manual that shows you how to use every feature.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:11,269
oh yeah i'm one of the network guys as

00:00:08,790 --> 00:00:13,410
you can guess by the t-shirt so

00:00:11,269 --> 00:00:17,820
hopefully the network was working okay

00:00:13,410 --> 00:00:19,680
and how a networking guy can talk about

00:00:17,820 --> 00:00:22,650
the networking protocol at an

00:00:19,680 --> 00:00:24,539
application developers conference well

00:00:22,650 --> 00:00:26,519
add this protocol into a cool

00:00:24,539 --> 00:00:29,310
application and then talk about it and

00:00:26,519 --> 00:00:34,950
talk about both so we will start talking

00:00:29,310 --> 00:00:37,920
about the mongrel too if the slides go

00:00:34,950 --> 00:00:40,950
and change okay so Margot 20 first of

00:00:37,920 --> 00:00:44,129
all is a really a LEGO building block

00:00:40,950 --> 00:00:46,890
for building your web applications so

00:00:44,129 --> 00:00:49,920
you have clients coming in on the front

00:00:46,890 --> 00:00:52,980
end connecting via normal HTTP requests

00:00:49,920 --> 00:00:56,190
or if you do the things like web chat

00:00:52,980 --> 00:00:58,829
you can do long polling or you can have

00:00:56,190 --> 00:01:01,379
the flash applications on the client

00:00:58,829 --> 00:01:03,930
side connecting to the mongrel to using

00:01:01,379 --> 00:01:08,250
the flash socket and what we're going to

00:01:03,930 --> 00:01:11,610
does is that it converts those requests

00:01:08,250 --> 00:01:13,740
on the back end into the zeromq messages

00:01:11,610 --> 00:01:18,479
and you can hack your back and handlers

00:01:13,740 --> 00:01:20,100
via 0 and Q to the mongrel front end so

00:01:18,479 --> 00:01:22,799
what this gives you is very much

00:01:20,100 --> 00:01:25,409
flexibility and language agnosticism so

00:01:22,799 --> 00:01:28,290
you don't care which language your

00:01:25,409 --> 00:01:30,860
back-end is written in so the mongrel is

00:01:28,290 --> 00:01:34,680
very much language agnostic in this case

00:01:30,860 --> 00:01:36,920
now it obviously also handles the static

00:01:34,680 --> 00:01:39,720
files and the reverse proxy

00:01:36,920 --> 00:01:42,810
manageability of mongrel 2 is also very

00:01:39,720 --> 00:01:46,200
interesting thing it has its

00:01:42,810 --> 00:01:50,490
configuration embedded into the sqlite3

00:01:46,200 --> 00:01:53,570
database so why that that means that you

00:01:50,490 --> 00:01:56,250
can not only use the built-in m2 SH so

00:01:53,570 --> 00:01:59,880
mobile shell that is used to control the

00:01:56,250 --> 00:02:03,750
operation of mongrel tool to convert the

00:01:59,880 --> 00:02:07,649
standard text from fixin to sqlite3 but

00:02:03,750 --> 00:02:10,700
you can also use your own configuration

00:02:07,649 --> 00:02:13,020
database on any can integrate sqlite3

00:02:10,700 --> 00:02:13,819
that mongrel to use this together with

00:02:13,020 --> 00:02:16,609
your configure

00:02:13,819 --> 00:02:18,700
asian back end another interesting thing

00:02:16,609 --> 00:02:21,709
is that you can use the rails like

00:02:18,700 --> 00:02:24,079
routing so you specify which handle

00:02:21,709 --> 00:02:27,620
attaches to which URL subtree so think

00:02:24,079 --> 00:02:30,670
of it like mounting of the volumes under

00:02:27,620 --> 00:02:33,079
any of the UNIX operating systems

00:02:30,670 --> 00:02:35,840
efficiency so how many people in the

00:02:33,079 --> 00:02:42,430
room worked with the mongrel with the

00:02:35,840 --> 00:02:45,290
previous generation thing ok if you what

00:02:42,430 --> 00:02:50,139
 and mangled to have in common is

00:02:45,290 --> 00:02:54,650
the skeleton so the skeleton is the Rio

00:02:50,139 --> 00:02:58,699
made parser for the HTTP protocol and

00:02:54,650 --> 00:03:00,799
it's formally generated code from the

00:02:58,699 --> 00:03:03,739
description of the HTTP protocol taken

00:03:00,799 --> 00:03:05,659
from the RFC so as a result the

00:03:03,739 --> 00:03:07,939
performance of this parser is quite good

00:03:05,659 --> 00:03:10,010
and also the number of bonds that you

00:03:07,939 --> 00:03:11,510
create when you make the code manually

00:03:10,010 --> 00:03:15,049
is also much lower so you have

00:03:11,510 --> 00:03:16,519
automatically generated parser and this

00:03:15,049 --> 00:03:19,819
gives both the performance and

00:03:16,519 --> 00:03:23,120
strictness of the parsing on the back

00:03:19,819 --> 00:03:25,040
end at the same time we have 0 and Q so

00:03:23,120 --> 00:03:28,639
zeromq is very lightweight messaging

00:03:25,040 --> 00:03:32,780
library and using this library again

00:03:28,639 --> 00:03:36,829
allow us to abstract from any language

00:03:32,780 --> 00:03:40,759
any kind of protocol that is used to

00:03:36,829 --> 00:03:42,829
signal with the back end because with 0

00:03:40,759 --> 00:03:46,400
and Q if you were I think there's

00:03:42,829 --> 00:03:49,430
another lighting token 0 and Q library

00:03:46,400 --> 00:03:51,409
itself and you can see there that's the

00:03:49,430 --> 00:03:53,180
number of languages that the library

00:03:51,409 --> 00:03:56,030
supports is astounding so there is

00:03:53,180 --> 00:03:58,780
probably 15 to 20 languages that it

00:03:56,030 --> 00:04:03,469
supports so that's a really good thing

00:03:58,780 --> 00:04:05,989
now the for me I wanted to have a great

00:04:03,469 --> 00:04:08,030
web server to use that would support

00:04:05,989 --> 00:04:11,689
ipv6 so more email to was perfect

00:04:08,030 --> 00:04:13,939
candidate with one detail that they

00:04:11,689 --> 00:04:16,159
didn't support ipv6 so I started digging

00:04:13,939 --> 00:04:18,530
to the code and looking how the

00:04:16,159 --> 00:04:20,180
networking part is implemented and the

00:04:18,530 --> 00:04:25,070
networking part is implemented as part

00:04:20,180 --> 00:04:27,050
of leap task which is really a task

00:04:25,070 --> 00:04:30,110
library by Rose Cox

00:04:27,050 --> 00:04:32,389
and the abstractions that are in that

00:04:30,110 --> 00:04:33,830
library really pleasant to work with so

00:04:32,389 --> 00:04:36,860
effectively you don't need to work with

00:04:33,830 --> 00:04:38,690
this one time use structures where you

00:04:36,860 --> 00:04:40,580
take the name then you convert it into

00:04:38,690 --> 00:04:42,919
the structure and then you just use that

00:04:40,580 --> 00:04:46,009
structure once so all of that is

00:04:42,919 --> 00:04:47,810
obstructed inside the library so

00:04:46,009 --> 00:04:50,180
effectively there are three primitives

00:04:47,810 --> 00:04:52,729
that are there that you need to work

00:04:50,180 --> 00:04:54,770
with it's announced the socket then

00:04:52,729 --> 00:04:58,639
start connecting to a client or server

00:04:54,770 --> 00:05:00,680
and accept the incoming connections so

00:04:58,639 --> 00:05:06,080
this provides an abstraction layer from

00:05:00,680 --> 00:05:08,449
the rest of the code and how to add ipv6

00:05:06,080 --> 00:05:10,580
there's plenty of documentation on the

00:05:08,449 --> 00:05:14,210
web so I just picked one of them which

00:05:10,580 --> 00:05:18,500
shows the example of code before 14 to

00:05:14,210 --> 00:05:20,810
ipv6 and after 14 ipv6 support so I'm

00:05:18,500 --> 00:05:25,699
basically just went through the same

00:05:20,810 --> 00:05:28,190
logic as was there obviously when I

00:05:25,699 --> 00:05:31,880
showed in the previous slide this very

00:05:28,190 --> 00:05:34,159
nice level of abstraction also gave very

00:05:31,880 --> 00:05:36,500
few changes in other places in the

00:05:34,159 --> 00:05:38,000
system so there was only one one place

00:05:36,500 --> 00:05:41,029
to change in the remaining part of the

00:05:38,000 --> 00:05:44,389
code of mongrel to which is kind of

00:05:41,029 --> 00:05:47,569
giving an impression of the license of

00:05:44,389 --> 00:05:50,840
the quality of the codebase another

00:05:47,569 --> 00:05:53,569
assumption that I made was that bind v6

00:05:50,840 --> 00:05:56,150
only variable is set to zero so we'll

00:05:53,569 --> 00:05:59,120
talk a little bit about that variable

00:05:56,150 --> 00:06:02,120
later on now after a major scale then we

00:05:59,120 --> 00:06:05,779
ship the mango to with a support and

00:06:02,120 --> 00:06:09,319
there came some interesting problems so

00:06:05,779 --> 00:06:11,870
first of all get address info is not

00:06:09,319 --> 00:06:14,779
cached so when we use it in reverse

00:06:11,870 --> 00:06:19,009
proxy and the configuration specifies

00:06:14,779 --> 00:06:21,110
the target by name then per connection

00:06:19,009 --> 00:06:23,180
attempt to the backend server we have at

00:06:21,110 --> 00:06:27,020
least one DNS request well in reality is

00:06:23,180 --> 00:06:29,840
two packets the ipv4 and ipv6 resolution

00:06:27,020 --> 00:06:31,909
attempt so that's not very performant if

00:06:29,840 --> 00:06:35,570
you have dns server a couple of hops

00:06:31,909 --> 00:06:37,490
away so you would either put the dns

00:06:35,570 --> 00:06:40,190
server closer or maybe in the future

00:06:37,490 --> 00:06:42,590
we'll change the logic a little bit by

00:06:40,190 --> 00:06:45,320
the local cache now another interesting

00:06:42,590 --> 00:06:48,440
point that I hope is that some people at

00:06:45,320 --> 00:06:51,410
this they don't have the kernels with

00:06:48,440 --> 00:06:54,380
ipv6 enabled at all so my optimistic

00:06:51,410 --> 00:06:56,600
assumption that hey well AF inet say i

00:06:54,380 --> 00:07:01,280
need six socket will be just created it

00:06:56,600 --> 00:07:05,840
failed and finally which is not specific

00:07:01,280 --> 00:07:07,930
to ipv6 was the increased latins in

00:07:05,840 --> 00:07:11,210
serving the requests because there is no

00:07:07,930 --> 00:07:17,600
non-blocking name resolution interface

00:07:11,210 --> 00:07:20,410
in the socket library so for the users

00:07:17,600 --> 00:07:23,060
who don't have a tv6 in the colonel

00:07:20,410 --> 00:07:25,130
basically that came up with an

00:07:23,060 --> 00:07:27,020
interesting hack where you explicitly

00:07:25,130 --> 00:07:29,870
specify the bind address so if you

00:07:27,020 --> 00:07:32,690
specify the v4 wildcard bind address

00:07:29,870 --> 00:07:34,880
then you bind only to v4 address family

00:07:32,690 --> 00:07:37,790
and then you work around this fact that

00:07:34,880 --> 00:07:40,760
some people don't have the v6 supporting

00:07:37,790 --> 00:07:42,740
their kernel or if you if you are ready

00:07:40,760 --> 00:07:45,710
when you're ready to deploy v6 then you

00:07:42,740 --> 00:07:48,470
can just change that variable to colon

00:07:45,710 --> 00:07:50,630
colon which is the wild card for ipv6

00:07:48,470 --> 00:07:55,460
address and then you can bind your

00:07:50,630 --> 00:07:58,520
server to ipv6 socket now it'll be the

00:07:55,460 --> 00:08:01,430
front about having to deal with to

00:07:58,520 --> 00:08:04,280
address families is that I'll attempt to

00:08:01,430 --> 00:08:07,250
pee is not really suited for printing

00:08:04,280 --> 00:08:10,220
out the socket addresses because it

00:08:07,250 --> 00:08:12,050
deals with the address as itself whereas

00:08:10,220 --> 00:08:13,490
in the code you mainly deal with the

00:08:12,050 --> 00:08:15,500
socket structure where you have the

00:08:13,490 --> 00:08:17,570
address on the port so then you need to

00:08:15,500 --> 00:08:20,720
have a little bit of this kind of

00:08:17,570 --> 00:08:23,780
slightly spaghetti code that has if

00:08:20,720 --> 00:08:25,570
family is for then do this for a family

00:08:23,780 --> 00:08:27,320
six then do that which is a bit of

00:08:25,570 --> 00:08:29,180
inconvenience because I would expect

00:08:27,320 --> 00:08:32,900
every program would need to have this

00:08:29,180 --> 00:08:35,539
kind of operation now remember I

00:08:32,900 --> 00:08:37,909
mentioned the single socket so the bind

00:08:35,539 --> 00:08:43,130
v6 only it's a very interesting feature

00:08:37,909 --> 00:08:45,410
where you are able to put your before

00:08:43,130 --> 00:08:48,620
applications in my opinion are much

00:08:45,410 --> 00:08:50,540
easier because you had one socket before

00:08:48,620 --> 00:08:53,030
and you still have only one socket

00:08:50,540 --> 00:08:53,750
afterwards it's just that this circuit

00:08:53,030 --> 00:08:55,940
can handle

00:08:53,750 --> 00:08:59,510
both before and v6 addresses kind of

00:08:55,940 --> 00:09:02,270
magically so your previous v4 space gets

00:08:59,510 --> 00:09:06,140
mapped into v4 mapped addresses on this

00:09:02,270 --> 00:09:08,450
circuit so on the other hand there are

00:09:06,140 --> 00:09:10,400
different opinions so this was my

00:09:08,450 --> 00:09:11,930
opinion from the implementation point of

00:09:10,400 --> 00:09:15,830
view there are other implementers who

00:09:11,930 --> 00:09:18,050
may have other opinions and this setting

00:09:15,830 --> 00:09:21,080
had a interesting history it was first

00:09:18,050 --> 00:09:24,200
on than off and finally now it's again

00:09:21,080 --> 00:09:29,990
on in the linux by default but envious

00:09:24,200 --> 00:09:32,090
deeds off by default and our interesting

00:09:29,990 --> 00:09:36,050
problem is address-family selection so

00:09:32,090 --> 00:09:39,220
it was not really big problem I think

00:09:36,050 --> 00:09:43,790
for the mongrel to code per se because

00:09:39,220 --> 00:09:46,340
normally the scenario that where we use

00:09:43,790 --> 00:09:48,410
the name resolution as a client imply

00:09:46,340 --> 00:09:51,440
that we have both the backend server and

00:09:48,410 --> 00:09:53,120
mongrel to as a client so in this case

00:09:51,440 --> 00:09:55,280
both hosts are in the same

00:09:53,120 --> 00:09:57,920
administrative domain so you can fix if

00:09:55,280 --> 00:10:02,540
something is broken but if you are

00:09:57,920 --> 00:10:04,040
developing applications that are only

00:10:02,540 --> 00:10:05,780
client side and if you have the

00:10:04,040 --> 00:10:09,320
applications that required the real-time

00:10:05,780 --> 00:10:13,420
user response then you probably would

00:10:09,320 --> 00:10:17,300
need to deal with it somehow less

00:10:13,420 --> 00:10:20,300
relaxed manner i would say that RFC 3484

00:10:17,300 --> 00:10:22,690
specified because 3484 it says okay you

00:10:20,300 --> 00:10:24,890
first select v6 and then you start going

00:10:22,690 --> 00:10:29,030
by the addresses you get from get

00:10:24,890 --> 00:10:31,790
address & 4 so for that million one of

00:10:29,030 --> 00:10:34,190
my colleagues we had a small internet

00:10:31,790 --> 00:10:37,430
draft on with the idea of how to do that

00:10:34,190 --> 00:10:39,680
res selection and also very recently

00:10:37,430 --> 00:10:42,620
Mark Andrews from IC he published a blog

00:10:39,680 --> 00:10:45,380
post where he specifies a different

00:10:42,620 --> 00:10:47,270
algorithm but probably more efficient

00:10:45,380 --> 00:10:53,720
than ours where he bounced the

00:10:47,270 --> 00:10:55,339
connection time by fixed interval now

00:10:53,720 --> 00:10:57,530
obviously all of this cool things for

00:10:55,339 --> 00:11:01,640
user experience are not to replace

00:10:57,530 --> 00:11:05,030
fixing the brokenness finally a few

00:11:01,640 --> 00:11:07,550
conclusions that I have taken for myself

00:11:05,030 --> 00:11:11,420
from this mongrel to ipv6 exercise

00:11:07,550 --> 00:11:14,029
is that well first module two is really

00:11:11,420 --> 00:11:16,220
awesome application so if you don't hack

00:11:14,029 --> 00:11:18,410
on anything open source I would really

00:11:16,220 --> 00:11:21,019
invite you to start playing with it and

00:11:18,410 --> 00:11:23,420
use it in your project by the way the

00:11:21,019 --> 00:11:25,160
stats for the network so if you look at

00:11:23,420 --> 00:11:28,880
the stats for the network at fordham dot

00:11:25,160 --> 00:11:30,709
stdio to be so that's my tummy they were

00:11:28,880 --> 00:11:32,750
so from one girl to so I'm not going to

00:11:30,709 --> 00:11:37,550
demo it because we were doing it for the

00:11:32,750 --> 00:11:40,880
past one and a half days and really

00:11:37,550 --> 00:11:43,700
adding v6 in itself is not that much of

00:11:40,880 --> 00:11:45,320
a big deal but tuning it and making sure

00:11:43,700 --> 00:11:48,529
that it works correctly for all the

00:11:45,320 --> 00:11:50,690
users that's something that needs some

00:11:48,529 --> 00:11:52,790
time so really if you have your

00:11:50,690 --> 00:11:55,000
application it doesn't support v6 then

00:11:52,790 --> 00:11:57,560
you would really want to start now and

00:11:55,000 --> 00:11:59,990
start to exchange opinions on how things

00:11:57,560 --> 00:12:04,810
work better so with this I would like to

00:11:59,990 --> 00:12:04,810
thank you and open for questions if any

00:12:23,410 --> 00:12:29,390
yes there are thoughts are the non

00:12:25,760 --> 00:12:31,340
working dns but looking so the question

00:12:29,390 --> 00:12:34,370
was other thoughts to add the

00:12:31,340 --> 00:12:37,310
non-blocking dns the right thoughts and

00:12:34,370 --> 00:12:41,080
we've been trying very hard to find the

00:12:37,310 --> 00:12:43,430
a synchronous dns resolver library that

00:12:41,080 --> 00:12:46,520
well to state it politically correct

00:12:43,430 --> 00:12:48,740
that that would work because the

00:12:46,520 --> 00:12:51,200
existing ones are interfering very

00:12:48,740 --> 00:12:52,730
heavily with the green threads that are

00:12:51,200 --> 00:12:55,370
used in the mongrel too because they

00:12:52,730 --> 00:12:56,870
they basically either start threads only

00:12:55,370 --> 00:12:59,210
for the process or they do some other

00:12:56,870 --> 00:13:02,660
weird things from from just underneath

00:12:59,210 --> 00:13:05,210
your back so i have some very very

00:13:02,660 --> 00:13:17,390
initial code but it's not yet the sinker

00:13:05,210 --> 00:13:20,600
is over and such so performance

00:13:17,390 --> 00:13:23,060
benchmarks the guitar and for is

00:13:20,600 --> 00:13:28,310
something that is really hurting quite a

00:13:23,060 --> 00:13:31,280
lot so in terms of pure static files I

00:13:28,310 --> 00:13:32,450
think I don't have the exact data but I

00:13:31,280 --> 00:13:35,480
think this should be pretty much the

00:13:32,450 --> 00:13:37,340
same so protocol wise there is not a

00:13:35,480 --> 00:13:39,200
whole lot of overhead and code wise the

00:13:37,340 --> 00:13:41,450
paths as I said they are very very

00:13:39,200 --> 00:13:45,980
similar so basically we use the exact

00:13:41,450 --> 00:13:48,320
same socket code for v4 and v6 with the

00:13:45,980 --> 00:13:49,850
only difference that the well this this

00:13:48,320 --> 00:13:52,400
part is one of the few places where is

00:13:49,850 --> 00:13:54,760
different so otherwise it's exactly the

00:13:52,400 --> 00:13:54,760
same code

00:14:13,379 --> 00:14:20,100
okay so you know more questions thank

00:14:16,509 --> 00:14:20,100

YouTube URL: https://www.youtube.com/watch?v=jQDGmWb7GgY


