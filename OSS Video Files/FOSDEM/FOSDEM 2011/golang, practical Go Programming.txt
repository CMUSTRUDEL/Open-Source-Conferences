Title: golang, practical Go Programming
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	by Andrew Gerrand

Go is a new open-source programming language with an emphasis on simplicity, comprehensibility, and efficiency. It has the speed and safety of a statically-typed language and the lightweight feel of a scripting language. It has a simple feature set that is easy to understand and powerful to use, including a novel type system and concurrent programming primitives. This talk will dive into some real-world Go programs and discuss the Go idiom used in each.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:06,410 --> 00:00:12,300
hello

00:00:07,770 --> 00:00:14,700
it's my microphone on yes thank you

00:00:12,300 --> 00:00:17,539
everybody for coming my name is Andrew

00:00:14,700 --> 00:00:22,490
grant and I work at Google in Sydney

00:00:17,539 --> 00:00:25,980
Australia and I work on the NGO project

00:00:22,490 --> 00:00:29,820
so what is go who here first before I

00:00:25,980 --> 00:00:32,250
start who here is has heard of go okay

00:00:29,820 --> 00:00:34,579
who here is as like read the

00:00:32,250 --> 00:00:37,530
documentation or looked at the website

00:00:34,579 --> 00:00:43,290
what about actually written some go code

00:00:37,530 --> 00:00:45,480
yourself alright cool so for those of

00:00:43,290 --> 00:00:47,070
you who don't know go is a

00:00:45,480 --> 00:00:49,980
general-purpose programming language

00:00:47,070 --> 00:00:53,340
it's we build it as a system language

00:00:49,980 --> 00:00:55,079
when we first announced it but it's

00:00:53,340 --> 00:00:56,489
turned out to be useful for a wide

00:00:55,079 --> 00:00:59,699
variety of things not just systems

00:00:56,489 --> 00:01:01,199
programming um I've got a list of its

00:00:59,699 --> 00:01:03,690
killer features here the things that

00:01:01,199 --> 00:01:06,030
sort of make it special in combination

00:01:03,690 --> 00:01:08,600
so the first of all it has a strong

00:01:06,030 --> 00:01:11,010
emphasis on simplicity in its design

00:01:08,600 --> 00:01:13,200
it's very easy to learn all of the

00:01:11,010 --> 00:01:14,970
language features are very simple in and

00:01:13,200 --> 00:01:16,830
of themselves and they're also

00:01:14,970 --> 00:01:19,200
orthogonal the way that the language

00:01:16,830 --> 00:01:21,259
features interact is very easy to

00:01:19,200 --> 00:01:24,509
predict and very simple to understand

00:01:21,259 --> 00:01:27,570
it's a memory managed and syntactically

00:01:24,509 --> 00:01:30,030
lightweight language like a dynamic

00:01:27,570 --> 00:01:31,920
language like Python or JavaScript it

00:01:30,030 --> 00:01:33,619
has that kind of easy loose feeling

00:01:31,920 --> 00:01:35,369
where you don't have to worry about

00:01:33,619 --> 00:01:37,770
memory deallocation

00:01:35,369 --> 00:01:42,680
or and you don't have to do so much

00:01:37,770 --> 00:01:45,720
worrying about type that typing things

00:01:42,680 --> 00:01:52,909
it's it compiles to native machine code

00:01:45,720 --> 00:01:57,810
in Intel x86 32-bit and 64-bit and arm

00:01:52,909 --> 00:02:01,259
code generation and so in practice its

00:01:57,810 --> 00:02:05,369
speed is comparable to see now come to

00:02:01,259 --> 00:02:08,220
compilers we have GC which is our custom

00:02:05,369 --> 00:02:11,099
go compiler and we have GCC go which is

00:02:08,220 --> 00:02:13,930
a go front-end for GCC so the code

00:02:11,099 --> 00:02:17,370
generation on GCC go is slightly

00:02:13,930 --> 00:02:19,569
faster than GC but GC is the more mature

00:02:17,370 --> 00:02:23,890
compiler that we devote more attention

00:02:19,569 --> 00:02:27,790
to but they're both feature complete go

00:02:23,890 --> 00:02:29,469
ahead one of those big feature points is

00:02:27,790 --> 00:02:31,090
that it has strong concurrency

00:02:29,469 --> 00:02:35,889
primitives built into the language and

00:02:31,090 --> 00:02:38,469
it's a CSP style concurrency model like

00:02:35,889 --> 00:02:39,569
other languages like limbo if you've

00:02:38,469 --> 00:02:42,549
heard of them

00:02:39,569 --> 00:02:43,750
it is a statically typed language so I

00:02:42,549 --> 00:02:45,639
mentioned that it's kind of like a

00:02:43,750 --> 00:02:47,290
dynamic language but it's not a dynamic

00:02:45,639 --> 00:02:49,720
language it's actually very strongly

00:02:47,290 --> 00:02:52,989
typed but it has a nice system of

00:02:49,720 --> 00:02:56,049
interfaces that make a kind of compile

00:02:52,989 --> 00:02:58,780
time duck typing possible so it's a lot

00:02:56,049 --> 00:03:00,930
it's a lot more malleable than the new

00:02:58,780 --> 00:03:03,639
traditional statically typed languages

00:03:00,930 --> 00:03:05,919
and we have a very consistent and stand

00:03:03,639 --> 00:03:10,150
small standard library that is really

00:03:05,919 --> 00:03:13,269
nice to use and all go code is self

00:03:10,150 --> 00:03:15,189
documenting and we have a documentation

00:03:13,269 --> 00:03:17,109
extraction program called go doc and

00:03:15,189 --> 00:03:19,120
therefore the project is very well

00:03:17,109 --> 00:03:22,000
documented and then we place a huge

00:03:19,120 --> 00:03:24,010
emphasis on complete and correct

00:03:22,000 --> 00:03:27,129
documentation in all of our projects

00:03:24,010 --> 00:03:29,859
code and finally it's a free and open

00:03:27,129 --> 00:03:31,180
source project even though the core

00:03:29,859 --> 00:03:34,629
development of the project is sponsored

00:03:31,180 --> 00:03:38,159
by Google the core team are all employed

00:03:34,629 --> 00:03:42,579
by Google but we release everything in

00:03:38,159 --> 00:03:45,519
the open it's under a BSD license all of

00:03:42,579 --> 00:03:48,849
our development happens in the public on

00:03:45,519 --> 00:03:51,060
public mailing lists and we have we've

00:03:48,849 --> 00:03:53,459
had over 150 different contributors

00:03:51,060 --> 00:03:57,280
contribute code to the project directly

00:03:53,459 --> 00:03:59,439
who aren't from Google and of those

00:03:57,280 --> 00:04:02,229
people there's probably about 10 to 20

00:03:59,439 --> 00:04:03,669
who contribute on a regular basis we

00:04:02,229 --> 00:04:06,970
actually have a Windows port that was

00:04:03,669 --> 00:04:07,989
that is almost it's like 95 percent of

00:04:06,970 --> 00:04:12,030
the way there and that's being

00:04:07,989 --> 00:04:13,900
contributed wholly by non core

00:04:12,030 --> 00:04:16,840
contributor certs we've got a good

00:04:13,900 --> 00:04:20,919
community growing oh and we're one year

00:04:16,840 --> 00:04:22,210
old as of November so it's pretty

00:04:20,919 --> 00:04:25,060
exciting but what am I going to talk

00:04:22,210 --> 00:04:27,580
about in this talk I'm going to go

00:04:25,060 --> 00:04:27,910
through the complete development of a

00:04:27,580 --> 00:04:32,200
weather

00:04:27,910 --> 00:04:34,030
location a simple one there's a lot to

00:04:32,200 --> 00:04:35,860
cover in this talk and so it's going to

00:04:34,030 --> 00:04:39,850
move quite quickly and it's going to

00:04:35,860 --> 00:04:41,740
contain a lot of code examples so if

00:04:39,850 --> 00:04:43,720
you're not familiar with ghost syntax

00:04:41,740 --> 00:04:46,420
there will be things in there that

00:04:43,720 --> 00:04:48,280
aren't immediately clear if you're the

00:04:46,420 --> 00:04:50,710
type of person who sort of obsesses over

00:04:48,280 --> 00:04:53,680
small details I encourage you to kind of

00:04:50,710 --> 00:04:56,110
force yourself to look past it and focus

00:04:53,680 --> 00:04:57,970
on the actual sort of semantic meaning

00:04:56,110 --> 00:05:03,640
of what I'm explaining rather than their

00:04:57,970 --> 00:05:04,690
precise syntax so yeah we'll just get

00:05:03,640 --> 00:05:08,590
started oh if you're going to tweet

00:05:04,690 --> 00:05:10,060
about go then use the golang hashtag so

00:05:08,590 --> 00:05:12,280
that I can find it and see what you've

00:05:10,060 --> 00:05:13,750
got to say so the program that we're

00:05:12,280 --> 00:05:15,190
going to write is pretty much the

00:05:13,750 --> 00:05:18,160
simplest of all possible web

00:05:15,190 --> 00:05:21,400
applications which is a URL shortener it

00:05:18,160 --> 00:05:23,770
does two things as a web service it

00:05:21,400 --> 00:05:25,870
takes long URLs and then returns

00:05:23,770 --> 00:05:28,150
shortened versions of those URLs and

00:05:25,870 --> 00:05:30,420
then when it receives a request to the

00:05:28,150 --> 00:05:34,590
shortened version of the URL it will

00:05:30,420 --> 00:05:37,330
return an HTTP redirect to the long URL

00:05:34,590 --> 00:05:40,170
so the best place to start when writing

00:05:37,330 --> 00:05:45,940
any program is with the data structures

00:05:40,170 --> 00:05:48,630
and our program go to will store maps

00:05:45,940 --> 00:05:50,860
short URLs to long URL so the natural

00:05:48,630 --> 00:05:54,220
data structure that we would reach for

00:05:50,860 --> 00:05:56,410
is a hash map go provides a built-in map

00:05:54,220 --> 00:06:00,370
type that allows you to map values of

00:05:56,410 --> 00:06:02,950
any type to any other type and to

00:06:00,370 --> 00:06:05,169
initialize a map we use the built in

00:06:02,950 --> 00:06:09,520
make function so this is a line of valid

00:06:05,169 --> 00:06:12,490
code this is the actual type a map of

00:06:09,520 --> 00:06:15,970
integers to strings and that our

00:06:12,490 --> 00:06:19,750
variable m is now a map of that type so

00:06:15,970 --> 00:06:22,390
to put a this string 1 in the box

00:06:19,750 --> 00:06:24,460
identified by int 1 it's just the

00:06:22,390 --> 00:06:26,530
familiar kind of syntax that you would

00:06:24,460 --> 00:06:29,919
see in many different languages and to

00:06:26,530 --> 00:06:31,990
pull it out is this is the exact

00:06:29,919 --> 00:06:35,260
opposite so you would now equal the

00:06:31,990 --> 00:06:37,060
string 1 and the first bit of unusual go

00:06:35,260 --> 00:06:40,300
syntax for encountering here is this

00:06:37,060 --> 00:06:44,069
multiple multiple value return

00:06:40,300 --> 00:06:46,780
so this expression m2 we can actually

00:06:44,069 --> 00:06:50,259
extract two values from it and the first

00:06:46,780 --> 00:06:52,300
value would be the value stored at 2 but

00:06:50,259 --> 00:06:54,759
the second value is a boolean value that

00:06:52,300 --> 00:06:57,550
indicates whether that key is actually

00:06:54,759 --> 00:06:59,080
present in the map or not and in this

00:06:57,550 --> 00:07:01,680
instance there isn't the 2 in that map

00:06:59,080 --> 00:07:05,229
and so V would be an empty string and

00:07:01,680 --> 00:07:08,530
present would be false but if I if I put

00:07:05,229 --> 00:07:12,460
a comma present after the U then present

00:07:08,530 --> 00:07:14,319
would have been equal to true so now

00:07:12,460 --> 00:07:16,560
that we've sort of decided that we want

00:07:14,319 --> 00:07:19,690
to use a map let's specify the actual

00:07:16,560 --> 00:07:22,569
type that we're going to use for our our

00:07:19,690 --> 00:07:25,000
program and we'll call it URL store so

00:07:22,569 --> 00:07:27,099
this is a go type definition and

00:07:25,000 --> 00:07:30,219
basically just giving a name URL store

00:07:27,099 --> 00:07:33,340
to this concrete type a map of strings

00:07:30,219 --> 00:07:36,009
to strings and so to instantiate this

00:07:33,340 --> 00:07:39,340
hash map I just use the make function

00:07:36,009 --> 00:07:42,639
and then M points that region of memory

00:07:39,340 --> 00:07:45,520
which at which that hash map exists and

00:07:42,639 --> 00:07:51,819
so to store a mapping of a to Google

00:07:45,520 --> 00:07:54,909
calm just assign Google calm to the key

00:07:51,819 --> 00:07:58,690
a and to pull it out is the similar

00:07:54,909 --> 00:08:00,460
reverse but this so this is this is all

00:07:58,690 --> 00:08:02,979
we need as far as data structures but it

00:08:00,460 --> 00:08:06,550
has a shortcoming the map type isn't

00:08:02,979 --> 00:08:08,139
thread safe so if we want to access if

00:08:06,550 --> 00:08:10,000
we want to write to the map for multiple

00:08:08,139 --> 00:08:14,710
threads we need some way of moderating

00:08:10,000 --> 00:08:16,509
access to that that type and because

00:08:14,710 --> 00:08:18,400
we're going to be serving a web look at

00:08:16,509 --> 00:08:20,080
web application by definition it has

00:08:18,400 --> 00:08:27,699
many concurrent requests coming out at

00:08:20,080 --> 00:08:29,460
once so to protect the map type from

00:08:27,699 --> 00:08:32,800
being modified while it is being read

00:08:29,460 --> 00:08:36,159
and we must add a lock to the data

00:08:32,800 --> 00:08:39,099
structure so to do this we'll change the

00:08:36,159 --> 00:08:41,110
type definition instead of just being a

00:08:39,099 --> 00:08:43,620
map of strings to strings like that

00:08:41,110 --> 00:08:45,640
we're going to turn it into a struct an

00:08:43,620 --> 00:08:48,040
instructor's just like in C a

00:08:45,640 --> 00:08:51,160
concatenation of values of other types

00:08:48,040 --> 00:08:54,010
and any go type can fit inside a struct

00:08:51,160 --> 00:08:55,900
so in this case we have two fields

00:08:54,010 --> 00:08:58,210
URLs which is our map of strengths of

00:08:55,900 --> 00:09:00,880
strengths and then the second field is

00:08:58,210 --> 00:09:03,910
called new and it's of type synced up

00:09:00,880 --> 00:09:08,560
mutex sync is part of the standard

00:09:03,910 --> 00:09:13,180
library and RW mutex is a reader/writer

00:09:08,560 --> 00:09:15,340
mutex so multiple clients can take the

00:09:13,180 --> 00:09:16,600
read locks simultaneously but then when

00:09:15,340 --> 00:09:18,550
somebody tries to take the write lock

00:09:16,600 --> 00:09:23,200
only one person is permitted to take it

00:09:18,550 --> 00:09:26,400
at once go on one function and and

00:09:23,200 --> 00:09:32,290
that's at the exclusion of all readers

00:09:26,400 --> 00:09:33,790
so in order to access the map and be

00:09:32,290 --> 00:09:36,610
mediated by the lock we need to add

00:09:33,790 --> 00:09:38,710
setter and getter methods so the get

00:09:36,610 --> 00:09:41,230
method will take the read lock with by

00:09:38,710 --> 00:09:44,080
calling new our lock and then returns

00:09:41,230 --> 00:09:46,720
the URL of the string after unlocking

00:09:44,080 --> 00:09:50,230
the read lock so this is our function

00:09:46,720 --> 00:09:53,260
definition the function name is get this

00:09:50,230 --> 00:09:57,360
is our function receiver which is on

00:09:53,260 --> 00:09:59,800
it's on a pointer to URL store and then

00:09:57,360 --> 00:10:03,520
its first argument is a key which is a

00:09:59,800 --> 00:10:05,950
string and it returns a string so first

00:10:03,520 --> 00:10:09,310
we call SMU our lock because s is our

00:10:05,950 --> 00:10:11,500
URL store and then we extract the URL

00:10:09,310 --> 00:10:14,800
from the map and then we unlock the read

00:10:11,500 --> 00:10:16,750
lock and then we return that URL and our

00:10:14,800 --> 00:10:19,900
set method that does the reverse but

00:10:16,750 --> 00:10:21,490
with a slight added complication the set

00:10:19,900 --> 00:10:24,880
method will take the write lock and

00:10:21,490 --> 00:10:28,180
update the map but if the key is already

00:10:24,880 --> 00:10:30,670
present in the map we want to return

00:10:28,180 --> 00:10:32,860
false and not do anything to the map

00:10:30,670 --> 00:10:35,020
because we don't want multiple clients

00:10:32,860 --> 00:10:37,750
to be able to clobber each other in

00:10:35,020 --> 00:10:39,580
writing the same key to the same spot at

00:10:37,750 --> 00:10:41,650
the same URL to the same key in the map

00:10:39,580 --> 00:10:43,870
and this will this will come up later

00:10:41,650 --> 00:10:46,450
and make our algorithm simpler but in

00:10:43,870 --> 00:10:49,090
this case what the is to walk through

00:10:46,450 --> 00:10:52,810
this particular piece of code set takes

00:10:49,090 --> 00:10:55,540
a key and the URL both strings and then

00:10:52,810 --> 00:10:58,150
returns a boolean value so first we take

00:10:55,540 --> 00:11:00,130
the right lock and then we extract but

00:10:58,150 --> 00:11:03,400
and then we find out whether key is

00:11:00,130 --> 00:11:05,620
present in the URL map and if it is

00:11:03,400 --> 00:11:08,080
present and we release the lock and we

00:11:05,620 --> 00:11:10,390
return false and bailout

00:11:08,080 --> 00:11:13,150
but if it isn't in the map already we

00:11:10,390 --> 00:11:14,590
can store the URL under key and then we

00:11:13,150 --> 00:11:18,340
can unlock the right lock and return

00:11:14,590 --> 00:11:20,260
true now this is a little verbose and it

00:11:18,340 --> 00:11:21,700
could be cleaner and to demonstrate how

00:11:20,260 --> 00:11:26,530
it can be cleaner I'm going to introduce

00:11:21,700 --> 00:11:28,570
this concept called defer in go you can

00:11:26,530 --> 00:11:30,790
use it a first statement to push a

00:11:28,570 --> 00:11:33,460
function Hall onto a stack and the stack

00:11:30,790 --> 00:11:36,550
is local to the enclosing function in

00:11:33,460 --> 00:11:39,040
which you make the defer call and there

00:11:36,550 --> 00:11:41,170
you can defer many many function calls

00:11:39,040 --> 00:11:43,480
but then when the function when the

00:11:41,170 --> 00:11:46,300
surrounding function exits all of those

00:11:43,480 --> 00:11:48,970
function calls are executed in last in

00:11:46,300 --> 00:11:51,820
first out order so for this particular

00:11:48,970 --> 00:11:53,380
function foo I'm deferring a call to

00:11:51,820 --> 00:11:56,170
print line from the string formatting

00:11:53,380 --> 00:11:58,600
package and I'm printing work deferring

00:11:56,170 --> 00:12:00,370
a print of world but then I actually

00:11:58,600 --> 00:12:03,910
just make a normal function call to

00:12:00,370 --> 00:12:06,100
print hello and so through will when it

00:12:03,910 --> 00:12:09,100
executes will defer that function call

00:12:06,100 --> 00:12:11,290
print hello return and then this

00:12:09,100 --> 00:12:14,020
function call to print world will occur

00:12:11,290 --> 00:12:15,790
printing hello world and this is pretty

00:12:14,020 --> 00:12:17,650
much the simplest way to introduce defer

00:12:15,790 --> 00:12:20,020
I don't have much time to go into it in

00:12:17,650 --> 00:12:22,840
detail but the go blog if you search for

00:12:20,020 --> 00:12:24,700
golang blog there's a really thorough

00:12:22,840 --> 00:12:27,460
article written about this if it

00:12:24,700 --> 00:12:29,740
interests you but we can use defer now

00:12:27,460 --> 00:12:32,770
to simplify our setter and getter

00:12:29,740 --> 00:12:35,320
methods so our get method from before if

00:12:32,770 --> 00:12:38,470
we look back a couple of slides it used

00:12:35,320 --> 00:12:40,780
a temporary variable URL instead now

00:12:38,470 --> 00:12:42,820
with defer we can just take the read

00:12:40,780 --> 00:12:46,930
lock defer the release of the lock and

00:12:42,820 --> 00:12:49,060
then return the key directly the value

00:12:46,930 --> 00:12:50,650
from the map directly without having to

00:12:49,060 --> 00:12:53,830
use an intermediate or variable and

00:12:50,650 --> 00:12:56,350
similarly in set we can take the right

00:12:53,830 --> 00:12:58,270
lock and then immediately defer the

00:12:56,350 --> 00:13:00,640
release of the lock so that whatever

00:12:58,270 --> 00:13:05,710
happens when this function returns that

00:13:00,640 --> 00:13:07,030
that lock will be unlocked and and this

00:13:05,710 --> 00:13:10,300
means that we don't have to include

00:13:07,030 --> 00:13:12,280
unlock twice in this function in the

00:13:10,300 --> 00:13:14,140
before in each of the return statements

00:13:12,280 --> 00:13:17,230
and so this is the sort of most common

00:13:14,140 --> 00:13:21,070
use of defer but that's our sit and get

00:13:17,230 --> 00:13:22,040
functions now to complete the design of

00:13:21,070 --> 00:13:26,029
our URL store

00:13:22,040 --> 00:13:27,709
type we need to initialize it whenever

00:13:26,029 --> 00:13:30,649
we want to use it now I mentioned

00:13:27,709 --> 00:13:33,920
earlier that we need to make map types

00:13:30,649 --> 00:13:36,500
before we can use them and so because

00:13:33,920 --> 00:13:39,769
URL store contains a map type I need an

00:13:36,500 --> 00:13:41,870
initializer function that will create

00:13:39,769 --> 00:13:44,540
that will initialize that map and return

00:13:41,870 --> 00:13:47,120
a new URL store now go this would be a

00:13:44,540 --> 00:13:49,009
place where in typical languages you

00:13:47,120 --> 00:13:50,839
might expect to use a constructor to

00:13:49,009 --> 00:13:53,149
construct it but go doesn't have this

00:13:50,839 --> 00:13:56,209
concept of constructors instead we just

00:13:53,149 --> 00:13:57,500
use functions of the form new food where

00:13:56,209 --> 00:14:02,360
foo is the name of the type that you

00:13:57,500 --> 00:14:03,800
want to construct and this seems like an

00:14:02,360 --> 00:14:05,779
omission but it actually ends up being

00:14:03,800 --> 00:14:07,220
quite useful when you're writing more

00:14:05,779 --> 00:14:12,139
composable code but I'm not going to go

00:14:07,220 --> 00:14:15,290
into that today so our function new URL

00:14:12,139 --> 00:14:18,259
store returns a pointer to a URL store

00:14:15,290 --> 00:14:20,029
value and in in the body of this

00:14:18,259 --> 00:14:23,149
function all we do is we have a URL

00:14:20,029 --> 00:14:27,440
store literal and then inside I specify

00:14:23,149 --> 00:14:29,360
that URLs is the result of making a map

00:14:27,440 --> 00:14:31,250
of strings to strings so this function

00:14:29,360 --> 00:14:31,490
will return a URL store that is ready to

00:14:31,250 --> 00:14:34,190
use

00:14:31,490 --> 00:14:37,490
then the readwrite mutex doesn't require

00:14:34,190 --> 00:14:39,500
any initialization its zero value is a

00:14:37,490 --> 00:14:46,220
mutex that is ready to use and that is

00:14:39,500 --> 00:14:50,269
unlocked so when we're using the URL

00:14:46,220 --> 00:14:53,029
storm if I want to initialize s I say s

00:14:50,269 --> 00:14:56,209
: equals new URL store and now s is of

00:14:53,029 --> 00:14:59,089
type pointer to URL store and then I can

00:14:56,209 --> 00:15:00,800
call s set to set a key and if that

00:14:59,089 --> 00:15:03,860
returns true then we've successfully

00:15:00,800 --> 00:15:07,970
added it to the map and then to get a

00:15:03,860 --> 00:15:09,019
URL by key I call s get and you notice

00:15:07,970 --> 00:15:12,139
that this if statement looks a bit

00:15:09,019 --> 00:15:15,350
strange in go if statements can have an

00:15:12,139 --> 00:15:18,439
initializer in them in the same way that

00:15:15,350 --> 00:15:21,439
for loop can in many languages so in

00:15:18,439 --> 00:15:24,589
this case the variable URL is the result

00:15:21,439 --> 00:15:27,170
of our get call and then in in this if

00:15:24,589 --> 00:15:30,290
Clause and any subsequent else clauses

00:15:27,170 --> 00:15:33,319
that variable URL will be scoped to that

00:15:30,290 --> 00:15:34,790
particular set of blocks which makes it

00:15:33,319 --> 00:15:35,870
very easy to keep things nice and clean

00:15:34,790 --> 00:15:39,529
and compact so

00:15:35,870 --> 00:15:42,680
a small bit of NGO idiom so now that we

00:15:39,529 --> 00:15:45,710
have our data type which is thread safe

00:15:42,680 --> 00:15:49,279
and and ideal for storing the data

00:15:45,710 --> 00:15:51,260
associated with this program we now need

00:15:49,279 --> 00:15:54,140
and we already have a get function which

00:15:51,260 --> 00:15:57,260
will serve us fine we need some way of

00:15:54,140 --> 00:16:00,640
putting a URL into the map and getting a

00:15:57,260 --> 00:16:04,220
key back in exchange so this method port

00:16:00,640 --> 00:16:09,010
takes a URL generates a corresponding

00:16:04,220 --> 00:16:09,010
key and then stores the URL in the map

00:16:09,730 --> 00:16:17,089
under that key and returns the key so

00:16:13,100 --> 00:16:21,200
you know the way we'll generate the key

00:16:17,089 --> 00:16:26,120
is by the way most URL shorteners work

00:16:21,200 --> 00:16:28,370
is that you take some base like base 63

00:16:26,120 --> 00:16:31,370
as a common one where you have upper and

00:16:28,370 --> 00:16:33,710
lower case alphanumeric characters and 0

00:16:31,370 --> 00:16:35,900
to 9 and you just take an integer and

00:16:33,710 --> 00:16:37,940
then convert it to that base so I have

00:16:35,900 --> 00:16:39,830
this function gen key which does exactly

00:16:37,940 --> 00:16:41,839
that but I'm not going to show the

00:16:39,830 --> 00:16:44,060
implementation of that here and then I

00:16:41,839 --> 00:16:46,990
have added a new method to URL store

00:16:44,060 --> 00:16:50,240
called count which simply returns the

00:16:46,990 --> 00:16:52,010
number of elements in that map so Len is

00:16:50,240 --> 00:16:54,320
another built-in function so we're

00:16:52,010 --> 00:16:56,990
taking the length of the map returning

00:16:54,320 --> 00:16:59,630
the number of items inside the map in a

00:16:56,990 --> 00:17:02,029
thread safe way using the read lock so I

00:16:59,630 --> 00:17:03,640
generate the key by generating the

00:17:02,029 --> 00:17:07,610
corresponding alpha numeric key

00:17:03,640 --> 00:17:10,130
associated with the corresponds to the

00:17:07,610 --> 00:17:12,110
count of what's in the map and I do this

00:17:10,130 --> 00:17:15,339
inside a for loop an infinite loop and

00:17:12,110 --> 00:17:18,890
so what I'll do is generate a key

00:17:15,339 --> 00:17:21,620
attempt to set it if the set succeeds

00:17:18,890 --> 00:17:25,069
then I return that key that says that's

00:17:21,620 --> 00:17:26,959
a success exit successful port if it

00:17:25,069 --> 00:17:28,700
hasn't said it it means that somebody in

00:17:26,959 --> 00:17:32,330
the meantime has already generated that

00:17:28,700 --> 00:17:34,070
key and set before I have and so I loop

00:17:32,330 --> 00:17:36,020
back around and generate the next key

00:17:34,070 --> 00:17:37,700
and by this time count will have

00:17:36,020 --> 00:17:44,210
incremented because somebody has already

00:17:37,700 --> 00:17:45,160
inserted something under my feet so then

00:17:44,210 --> 00:17:48,770
we've talked about

00:17:45,160 --> 00:17:52,880
how we have getting put which service

00:17:48,770 --> 00:17:55,340
our the back end part of our URL store

00:17:52,880 --> 00:17:58,040
yeah of our URL shortener but now we

00:17:55,340 --> 00:18:00,530
need to look at the user interface and

00:17:58,040 --> 00:18:04,400
the user interface is going to be served

00:18:00,530 --> 00:18:07,010
over HTTP so the eight will use goes

00:18:04,400 --> 00:18:09,230
HTTP package to provide the

00:18:07,010 --> 00:18:12,590
infrastructure for serving HTTP requests

00:18:09,230 --> 00:18:14,570
now this program here is a complete go

00:18:12,590 --> 00:18:17,750
program that serves hello world over

00:18:14,570 --> 00:18:19,940
HTTP and just to walk you through it

00:18:17,750 --> 00:18:22,430
briefly and we have packaged main which

00:18:19,940 --> 00:18:24,020
is a packaged statement every go program

00:18:22,430 --> 00:18:27,410
begins with a package statement and

00:18:24,020 --> 00:18:30,440
every go program begins in package main

00:18:27,410 --> 00:18:32,960
with function main so I'm in package

00:18:30,440 --> 00:18:36,500
main I import the string formatting

00:18:32,960 --> 00:18:39,290
package and the HTTP package and then in

00:18:36,500 --> 00:18:42,530
my main function I call HTTP handle func

00:18:39,290 --> 00:18:45,410
which registers the hat this function

00:18:42,530 --> 00:18:48,290
hello to handle all requests to slash

00:18:45,410 --> 00:18:50,030
which is our web route and so when

00:18:48,290 --> 00:18:53,120
somebody accesses the web route on this

00:18:50,030 --> 00:18:56,030
server um this function hello will be

00:18:53,120 --> 00:18:57,860
invoked and it has this function

00:18:56,030 --> 00:19:01,520
signature that takes a response writer

00:18:57,860 --> 00:19:03,680
and a request the request is the request

00:19:01,520 --> 00:19:05,960
data of the HTTP request the incoming

00:19:03,680 --> 00:19:10,010
requests and with information such as

00:19:05,960 --> 00:19:11,240
any query parameters the path itself the

00:19:10,010 --> 00:19:14,150
address of the person making the request

00:19:11,240 --> 00:19:19,010
any headers etc and the response writer

00:19:14,150 --> 00:19:22,480
is a type that you can write to which is

00:19:19,010 --> 00:19:25,970
what I'm doing with FBF and then it also

00:19:22,480 --> 00:19:27,890
has a set of utility functions to modify

00:19:25,970 --> 00:19:29,270
headers and other things but in this

00:19:27,890 --> 00:19:32,390
case all I want to do is write the

00:19:29,270 --> 00:19:36,050
string hello world using F print to W

00:19:32,390 --> 00:19:38,570
and then finally I call listen and serve

00:19:36,050 --> 00:19:41,480
to setup my web server listening on port

00:19:38,570 --> 00:19:44,600
8080 and then this function will block

00:19:41,480 --> 00:19:46,370
forever serving HTTP requests so how can

00:19:44,600 --> 00:19:50,660
we leverage this to actually implement

00:19:46,370 --> 00:19:52,760
go to is HTTP interface well our program

00:19:50,660 --> 00:19:54,620
needs to HTTP handlers it needs a

00:19:52,760 --> 00:19:57,090
redirect handler which will take

00:19:54,620 --> 00:19:59,700
incoming shortened URLs and

00:19:57,090 --> 00:20:02,760
provide an HTTP redirect to the longer

00:19:59,700 --> 00:20:04,830
version of that URL and I have the add

00:20:02,760 --> 00:20:08,160
handler which handles the submission of

00:20:04,830 --> 00:20:11,640
new URLs and returns the shortened

00:20:08,160 --> 00:20:13,980
versions so in our programs main

00:20:11,640 --> 00:20:16,430
function we will use handle func to

00:20:13,980 --> 00:20:19,890
register these two new functions

00:20:16,430 --> 00:20:23,580
redirect an ad under the web route and

00:20:19,890 --> 00:20:26,190
slash ad and the semantics of this is

00:20:23,580 --> 00:20:28,440
that a request to slash ad will go to

00:20:26,190 --> 00:20:30,360
the ad handler and then requests to

00:20:28,440 --> 00:20:32,100
anything else will get sent to redirect

00:20:30,360 --> 00:20:38,670
and this is the behavior that we want

00:20:32,100 --> 00:20:42,030
for this program so here's the

00:20:38,670 --> 00:20:44,790
implementation of AD the add function it

00:20:42,030 --> 00:20:47,970
reads that the URL parameter out of the

00:20:44,790 --> 00:20:51,300
HTTP request so a form input box named

00:20:47,970 --> 00:20:54,090
URL for example and then it puts it into

00:20:51,300 --> 00:20:56,130
the store and then sends the

00:20:54,090 --> 00:20:59,580
corresponding URL back to the user so

00:20:56,130 --> 00:21:01,650
inside our function now we get the

00:20:59,580 --> 00:21:04,170
requests form value that's called URL

00:21:01,650 --> 00:21:06,900
and store it in the variable URL and we

00:21:04,170 --> 00:21:08,700
call stored up put putting the URL into

00:21:06,900 --> 00:21:12,750
the store and getting a key in exchange

00:21:08,700 --> 00:21:14,400
and then we print the new shortened URL

00:21:12,750 --> 00:21:18,900
which because I'm running on my machine

00:21:14,400 --> 00:21:21,510
on port 8080 you'll just get I'm just

00:21:18,900 --> 00:21:23,550
printing that out with the key appended

00:21:21,510 --> 00:21:24,990
to the end and we're writing that to the

00:21:23,550 --> 00:21:27,960
response writer so that's what the user

00:21:24,990 --> 00:21:30,840
will see any change but what is what is

00:21:27,960 --> 00:21:33,270
the store well store will be a global

00:21:30,840 --> 00:21:35,070
variable that i've created and somewhere

00:21:33,270 --> 00:21:38,190
in my source file I have this at the top

00:21:35,070 --> 00:21:40,320
level of our store equals new URLs store

00:21:38,190 --> 00:21:42,360
and so this will be the global instance

00:21:40,320 --> 00:21:47,550
of store that will be accessed by and

00:21:42,360 --> 00:21:49,970
the add and redirect HTTP handlers but I

00:21:47,550 --> 00:21:54,530
only showed you one part of the ad and

00:21:49,970 --> 00:21:57,840
the the post handler we have to have the

00:21:54,530 --> 00:21:59,760
part of the the part of the handler that

00:21:57,840 --> 00:22:03,180
displays the form in the first place and

00:21:59,760 --> 00:22:04,650
so if you RL is empty it means that

00:22:03,180 --> 00:22:06,390
there's been no submission or there's

00:22:04,650 --> 00:22:08,990
been an empty submission and so in that

00:22:06,390 --> 00:22:12,409
case I'll just F print

00:22:08,990 --> 00:22:15,799
this constant add form which is a string

00:22:12,409 --> 00:22:17,029
constant of an HTML form and print that

00:22:15,799 --> 00:22:20,270
and then bail out

00:22:17,029 --> 00:22:22,490
but if URL is not empty it means that

00:22:20,270 --> 00:22:24,799
somebody's actually submitted URL and I

00:22:22,490 --> 00:22:26,029
can throw it into the database I mean

00:22:24,799 --> 00:22:28,580
and this is a this is an overly

00:22:26,029 --> 00:22:31,370
simplistic UI obviously if you're going

00:22:28,580 --> 00:22:34,700
to build a proper web app you would put

00:22:31,370 --> 00:22:37,870
a bit more effort into it but at this

00:22:34,700 --> 00:22:43,370
stage this actually works quite well and

00:22:37,870 --> 00:22:47,260
so the H the redirect handler is a

00:22:43,370 --> 00:22:50,600
function that takes a key out of the

00:22:47,260 --> 00:22:53,090
HTTP path and then retrieves the

00:22:50,600 --> 00:22:56,870
corresponding URL the longer URL from

00:22:53,090 --> 00:22:59,149
the store and then performs an HTTP

00:22:56,870 --> 00:23:02,450
redirect to take the user to the to the

00:22:59,149 --> 00:23:04,270
site if the URL isn't found we want to

00:23:02,450 --> 00:23:07,279
show an a 404 error

00:23:04,270 --> 00:23:11,450
so in our redirect handler we access the

00:23:07,279 --> 00:23:13,460
request URLs path and we slice off the

00:23:11,450 --> 00:23:15,260
first character of the path because it's

00:23:13,460 --> 00:23:19,520
always going to be a for forward slash

00:23:15,260 --> 00:23:22,520
and then we look up the key in the store

00:23:19,520 --> 00:23:25,250
with get and take the corresponding URL

00:23:22,520 --> 00:23:28,880
and if the URL is empty we know that

00:23:25,250 --> 00:23:31,630
it's not in the map so we return a not

00:23:28,880 --> 00:23:35,720
found error using this not found helper

00:23:31,630 --> 00:23:37,820
otherwise we can redirect the user using

00:23:35,720 --> 00:23:39,620
the redirect helper and we redirect them

00:23:37,820 --> 00:23:43,399
to the URL that we retrieved from the

00:23:39,620 --> 00:23:48,279
map and we return a status of found 302

00:23:43,399 --> 00:23:48,279
found which is the appropriate HTTP code

00:23:49,210 --> 00:23:55,370
so we've written like the thing is about

00:23:52,220 --> 00:23:57,440
90 something odd lines of code and it's

00:23:55,370 --> 00:24:00,159
a complete functional working web app

00:23:57,440 --> 00:24:05,240
and I can demonstrate what we've got I'm

00:24:00,159 --> 00:24:16,549
working so far so I run that head to

00:24:05,240 --> 00:24:20,980
localhost 8080 the conference Wi-Fi okay

00:24:16,549 --> 00:24:20,980
and then if I want to add

00:24:22,350 --> 00:24:28,570
my fingers a call is a co-linear so I

00:24:26,590 --> 00:24:34,930
add frost em and then I get the

00:24:28,570 --> 00:24:37,930
resulting URL when I visit that URL it

00:24:34,930 --> 00:24:42,090
should take me to the phosphine side and

00:24:37,930 --> 00:24:46,500
then I can add another URL going to org

00:24:42,090 --> 00:24:53,160
and we'll see that this works as well so

00:24:46,500 --> 00:24:56,380
you know that's that's pretty nice but

00:24:53,160 --> 00:24:58,180
when this process ends when I hit and

00:24:56,380 --> 00:25:00,310
draw see those URLs that I've entered

00:24:58,180 --> 00:25:01,600
have just disappeared into the ether so

00:25:00,310 --> 00:25:03,730
it's not a particularly useful

00:25:01,600 --> 00:25:05,140
application at the moment unless you

00:25:03,730 --> 00:25:06,910
have some magical computer that will

00:25:05,140 --> 00:25:07,450
never switch off in a process that will

00:25:06,910 --> 00:25:11,230
never end

00:25:07,450 --> 00:25:14,550
so we need to modify the URL store so

00:25:11,230 --> 00:25:17,020
that it actually logs URLs to disk and

00:25:14,550 --> 00:25:20,920
then restores that data when it starts

00:25:17,020 --> 00:25:22,870
back up so before I get into that I'll

00:25:20,920 --> 00:25:25,150
just introduce another aspect of goes

00:25:22,870 --> 00:25:28,180
type system which are its interface

00:25:25,150 --> 00:25:30,880
types and interface types define a set

00:25:28,180 --> 00:25:32,950
of methods and then any type that

00:25:30,880 --> 00:25:34,960
implements those methods can be used

00:25:32,950 --> 00:25:37,360
where a value of that interface type is

00:25:34,960 --> 00:25:39,790
expected so in a way you can think of

00:25:37,360 --> 00:25:42,310
interface types as defining behaviors

00:25:39,790 --> 00:25:44,980
and then any object that behaves in that

00:25:42,310 --> 00:25:47,860
way can be used where that interface is

00:25:44,980 --> 00:25:52,930
expected so one of the most frequently

00:25:47,860 --> 00:25:55,270
used interfaces in Roland is the writer

00:25:52,930 --> 00:25:57,900
package which is specify writer type

00:25:55,270 --> 00:26:01,000
which is specified in the i/o package

00:25:57,900 --> 00:26:04,090
and so the typewriter is an interface

00:26:01,000 --> 00:26:06,760
which contains the method write which

00:26:04,090 --> 00:26:08,980
takes a slice of bytes or a buffer and

00:26:06,760 --> 00:26:12,850
then returns the number of bytes written

00:26:08,980 --> 00:26:14,410
and an error value there are many many

00:26:12,850 --> 00:26:16,690
different types that implement writers

00:26:14,410 --> 00:26:21,130
there are compressors network

00:26:16,690 --> 00:26:23,940
connections HTTP connections files tar

00:26:21,130 --> 00:26:27,190
archives you name it it's in there

00:26:23,940 --> 00:26:31,840
in fact we've already used an i/o writer

00:26:27,190 --> 00:26:33,520
in our HTTP handlers the W response

00:26:31,840 --> 00:26:37,600
writer argument

00:26:33,520 --> 00:26:41,110
to our HTTP handlers it implements the

00:26:37,600 --> 00:26:43,720
right method and the F printf function

00:26:41,110 --> 00:26:47,290
in the string formatting package expects

00:26:43,720 --> 00:26:49,810
an i/o writer so we can use the response

00:26:47,290 --> 00:26:52,530
writer as a writer because of the the

00:26:49,810 --> 00:26:52,530
shared interface

00:26:53,040 --> 00:27:01,540
so that's interfaces but we were talking

00:26:56,560 --> 00:27:02,880
about how to represent data this URL

00:27:01,540 --> 00:27:05,080
stored data on disk

00:27:02,880 --> 00:27:06,880
well the way we'll do that is we'll use

00:27:05,080 --> 00:27:09,340
goes gob package and gob is a

00:27:06,880 --> 00:27:11,290
serialization package which turns go

00:27:09,340 --> 00:27:14,950
data structures into streams of bytes

00:27:11,290 --> 00:27:17,170
and vice-versa and the gob package has

00:27:14,950 --> 00:27:20,170
the functions new encoder and new

00:27:17,170 --> 00:27:22,840
decoder which wrap io writer and i/o

00:27:20,170 --> 00:27:26,590
reader values respectively and then they

00:27:22,840 --> 00:27:28,720
return encoders and decoders which allow

00:27:26,590 --> 00:27:32,200
us to call their Inc encode and decode

00:27:28,720 --> 00:27:36,670
methods to write and read go data

00:27:32,200 --> 00:27:38,530
structures and so when we're writing to

00:27:36,670 --> 00:27:41,290
disk and we want to when we want to

00:27:38,530 --> 00:27:44,020
store this data on disk will we need a

00:27:41,290 --> 00:27:46,180
data type to describe it and so we'll

00:27:44,020 --> 00:27:49,540
create this new type record which is a

00:27:46,180 --> 00:27:52,450
struct that has two string values the

00:27:49,540 --> 00:27:55,180
key and the URL and then our new save

00:27:52,450 --> 00:27:57,580
method and which takes the key and URL

00:27:55,180 --> 00:28:01,060
as a string will create a new gob

00:27:57,580 --> 00:28:04,210
encoder which wraps some file and then

00:28:01,060 --> 00:28:06,790
calls in code and that encoder to write

00:28:04,210 --> 00:28:09,120
our new record this is a record literal

00:28:06,790 --> 00:28:12,670
which contains our key in our URL and

00:28:09,120 --> 00:28:15,730
then that encode will write that record

00:28:12,670 --> 00:28:20,080
to the underlying file but what is s dot

00:28:15,730 --> 00:28:22,630
file esta file is our new field file

00:28:20,080 --> 00:28:26,080
which is a file handle that I'm putting

00:28:22,630 --> 00:28:29,110
on the URL store and then in our new URL

00:28:26,080 --> 00:28:32,580
store initializer function we'll add

00:28:29,110 --> 00:28:36,970
this code which has gone off the screen

00:28:32,580 --> 00:28:39,640
to open a file with Oster open the file

00:28:36,970 --> 00:28:42,700
name is a new argument to URL store and

00:28:39,640 --> 00:28:44,320
then if the file doesn't open correctly

00:28:42,700 --> 00:28:46,660
then we'll bail because if we can't open

00:28:44,320 --> 00:28:47,809
the data store we probably don't want to

00:28:46,660 --> 00:28:50,150
continue running with

00:28:47,809 --> 00:28:53,240
so logged up fay-ta' will actually exit

00:28:50,150 --> 00:28:57,290
the program but if we do succeed we'll

00:28:53,240 --> 00:29:00,799
set s stock file the struct the structs

00:28:57,290 --> 00:29:02,780
file fields to our file handle F and so

00:29:00,799 --> 00:29:06,140
then in save when we refer to s dot file

00:29:02,780 --> 00:29:08,390
we're referring to this open file but

00:29:06,140 --> 00:29:10,640
now the last part is to load the data

00:29:08,390 --> 00:29:12,980
back into the program when the program

00:29:10,640 --> 00:29:15,830
starts and so we define a load method

00:29:12,980 --> 00:29:18,650
and this load method returns an error

00:29:15,830 --> 00:29:20,330
value it takes no arguments and first

00:29:18,650 --> 00:29:23,450
what it does is it seeks to the

00:29:20,330 --> 00:29:25,090
beginning of the file and and if the

00:29:23,450 --> 00:29:28,429
seek fails that will return an error and

00:29:25,090 --> 00:29:30,169
then it creates a gob decoder and what

00:29:28,429 --> 00:29:34,370
we do is we set up an error value and

00:29:30,169 --> 00:29:36,620
then we go into an infinite loop so for

00:29:34,370 --> 00:29:38,720
error equals nail it means just continue

00:29:36,620 --> 00:29:41,540
looping while error while there isn't an

00:29:38,720 --> 00:29:46,309
error and then I set up a record value R

00:29:41,540 --> 00:29:50,720
and then ID code into our by giving the

00:29:46,309 --> 00:29:53,780
decode the decode function a pointer to

00:29:50,720 --> 00:29:56,210
R and so D code will read bytes from the

00:29:53,780 --> 00:29:58,370
underlying file and try to marshal them

00:29:56,210 --> 00:30:01,910
into a record strut into this record

00:29:58,370 --> 00:30:04,850
struct and if that succeeds if error is

00:30:01,910 --> 00:30:07,580
not nil we can call the set method to

00:30:04,850 --> 00:30:09,440
set it into our map and in this in this

00:30:07,580 --> 00:30:11,090
way this will this will loop forever

00:30:09,440 --> 00:30:13,120
until it reaches the end of the file and

00:30:11,090 --> 00:30:16,820
when it reaches the end of the file

00:30:13,120 --> 00:30:19,429
error will equal OS to the Oh F and if

00:30:16,820 --> 00:30:22,400
that's the case we want to return nil we

00:30:19,429 --> 00:30:25,040
want to return a no error because that's

00:30:22,400 --> 00:30:26,660
the expected failure case but if there's

00:30:25,040 --> 00:30:29,210
any other failure case we'll return that

00:30:26,660 --> 00:30:31,790
error and pass it up the stack and so

00:30:29,210 --> 00:30:35,090
the last thing we need to do is stick a

00:30:31,790 --> 00:30:38,390
call to s dot load into our initializer

00:30:35,090 --> 00:30:40,850
function and if that fails we'll print

00:30:38,390 --> 00:30:42,380
up a nine error because the first time

00:30:40,850 --> 00:30:45,350
we run this program our store won't

00:30:42,380 --> 00:30:50,929
exist and so it's okay for this to fail

00:30:45,350 --> 00:30:54,110
on the first run oh and finally we need

00:30:50,929 --> 00:30:55,700
to add a call to save each time we each

00:30:54,110 --> 00:30:58,100
time somebody successfully makes the

00:30:55,700 --> 00:31:01,220
port so in our put function before

00:30:58,100 --> 00:31:04,100
returning the key and we'll call s save

00:31:01,220 --> 00:31:08,480
in the key at URL and then if there's an

00:31:04,100 --> 00:31:09,860
error with that blogger well then the

00:31:08,480 --> 00:31:12,169
last thing is we need to when we

00:31:09,860 --> 00:31:14,480
instantiate our store in the top level

00:31:12,169 --> 00:31:18,950
of our program we need to provide some

00:31:14,480 --> 00:31:21,500
file name whether to where the data will

00:31:18,950 --> 00:31:24,640
be written and read from so I can show

00:31:21,500 --> 00:31:24,640
you what we've written so far

00:31:29,049 --> 00:31:42,440
so if i add google calm and then visit

00:31:39,620 --> 00:31:43,940
slash one and you notice that i actually

00:31:42,440 --> 00:31:44,330
already had one stored in there slash

00:31:43,940 --> 00:31:47,809
zero

00:31:44,330 --> 00:31:52,400
it's the FOSDEM site and so if i control

00:31:47,809 --> 00:31:57,580
c out of that well if we look there's

00:31:52,400 --> 00:32:00,380
this stored up gob and if i hex dump it

00:31:57,580 --> 00:32:03,380
you'll see that there's two records in

00:32:00,380 --> 00:32:05,270
there the first one is a key of zero

00:32:03,380 --> 00:32:07,970
pointing to foster log the second is the

00:32:05,270 --> 00:32:09,559
key of one pointing to google.com and it

00:32:07,970 --> 00:32:11,780
will continue on in this in this vein

00:32:09,559 --> 00:32:19,190
add it all and so if i restart the

00:32:11,780 --> 00:32:24,080
program and reload this URL it should

00:32:19,190 --> 00:32:25,760
work but it's not don't worry there's a

00:32:24,080 --> 00:32:27,679
lot of intermediate tree programs and

00:32:25,760 --> 00:32:28,970
they're not there I've made changes in

00:32:27,679 --> 00:32:34,850
the last couple of days so it might not

00:32:28,970 --> 00:32:36,650
be synched up totally anyway assuming

00:32:34,850 --> 00:32:41,570
that that all works and it is all

00:32:36,650 --> 00:32:44,150
correct which it is it is consider this

00:32:41,570 --> 00:32:46,490
pathological situation when we have many

00:32:44,150 --> 00:32:48,230
clients that are adding URL

00:32:46,490 --> 00:32:50,600
simultaneously say I've just launched

00:32:48,230 --> 00:32:53,390
this service as Google's fancy URL

00:32:50,600 --> 00:32:55,970
shortener and suddenly a million people

00:32:53,390 --> 00:32:58,100
try to add URLs at the same time and

00:32:55,970 --> 00:33:01,190
even though we can safely update the map

00:32:58,100 --> 00:33:02,539
concurrently the disk writes might might

00:33:01,190 --> 00:33:06,440
happen simultaneously like the

00:33:02,539 --> 00:33:08,030
underlying save calls might happen at

00:33:06,440 --> 00:33:10,490
the same time and now some of our some

00:33:08,030 --> 00:33:12,440
operating systems do writes atomically

00:33:10,490 --> 00:33:13,970
and so this might be okay but some of

00:33:12,440 --> 00:33:14,990
them don't and we can't rely on this

00:33:13,970 --> 00:33:17,600
kind of behavior

00:33:14,990 --> 00:33:20,090
and secondly even if the rights don't

00:33:17,600 --> 00:33:22,640
collide it means that every client has

00:33:20,090 --> 00:33:25,669
to wait for its foot to go through the

00:33:22,640 --> 00:33:27,649
desk before it will return and we don't

00:33:25,669 --> 00:33:30,409
mind making clients wait for them in

00:33:27,649 --> 00:33:32,059
memory map to be added to be updated

00:33:30,409 --> 00:33:33,500
because that's a very fast thing to do

00:33:32,059 --> 00:33:36,409
but if you're talking about this rights

00:33:33,500 --> 00:33:38,299
and a heavily io loaded system clients

00:33:36,409 --> 00:33:41,570
will wait way longer than they need to

00:33:38,299 --> 00:33:45,049
for their request to go through so what

00:33:41,570 --> 00:33:48,020
we want to do ideally is to decouple the

00:33:45,049 --> 00:33:50,960
put function from the save function and

00:33:48,020 --> 00:33:54,140
make them happen in separate not not at

00:33:50,960 --> 00:33:59,750
the same time so this introduces

00:33:54,140 --> 00:34:02,779
concurrency and the fundamental unit of

00:33:59,750 --> 00:34:03,890
concurrency and go is the go routine and

00:34:02,779 --> 00:34:05,630
there's the reason why they sound like

00:34:03,890 --> 00:34:07,220
co-routines that's essentially what they

00:34:05,630 --> 00:34:09,700
are but a go routines a lightweight

00:34:07,220 --> 00:34:13,879
thread that is managed by the go runtime

00:34:09,700 --> 00:34:16,429
they are existing shared memory like

00:34:13,879 --> 00:34:18,080
many familiar sharing models but they're

00:34:16,429 --> 00:34:20,210
much cheaper to create than an operating

00:34:18,080 --> 00:34:22,849
system thread they have a very small

00:34:20,210 --> 00:34:26,419
staff creating a new girl routine is

00:34:22,849 --> 00:34:28,339
under about 4 k of allocation so you can

00:34:26,419 --> 00:34:30,080
create many thousands of thousands of

00:34:28,339 --> 00:34:32,000
them or even hundreds of thousands of

00:34:30,080 --> 00:34:34,089
them if you'd like without running into

00:34:32,000 --> 00:34:37,550
too much trouble

00:34:34,089 --> 00:34:39,560
so to launch a go routine we use a go

00:34:37,550 --> 00:34:41,839
statement which is a similar sort of

00:34:39,560 --> 00:34:44,330
syntax to the defer statement it's go

00:34:41,839 --> 00:34:47,000
followed by some function call and when

00:34:44,330 --> 00:34:50,169
you call go and some function the

00:34:47,000 --> 00:34:53,270
function itself like the function

00:34:50,169 --> 00:34:55,190
pointer and the functions arguments are

00:34:53,270 --> 00:34:57,560
evaluated in the current go routine a

00:34:55,190 --> 00:34:59,630
new go routine is started and then that

00:34:57,560 --> 00:35:01,099
function executes in the new go routine

00:34:59,630 --> 00:35:06,050
really 15 minutes left

00:35:01,099 --> 00:35:07,849
oh my god so we have foo executing in

00:35:06,050 --> 00:35:12,470
one go routine and var X acute again the

00:35:07,849 --> 00:35:14,359
current go routine and that's it that's

00:35:12,470 --> 00:35:18,080
as simple as go routines up but this

00:35:14,359 --> 00:35:19,880
isn't very helpful what if you have you

00:35:18,080 --> 00:35:21,349
know what you need to talk talk between

00:35:19,880 --> 00:35:23,780
these go routines and so this is where

00:35:21,349 --> 00:35:27,109
channels come in a channel is a conduit

00:35:23,780 --> 00:35:28,790
like a UNIX pipe except it's typed you

00:35:27,109 --> 00:35:30,170
create a channel and then give it

00:35:28,790 --> 00:35:32,600
two ends of some communication in

00:35:30,170 --> 00:35:34,940
separate go routines and then they can

00:35:32,600 --> 00:35:38,690
send things down the pipe down the

00:35:34,940 --> 00:35:40,190
channel to each other like maps channels

00:35:38,690 --> 00:35:42,560
are initialized with the make function

00:35:40,190 --> 00:35:45,800
so to make a channel of integers I call

00:35:42,560 --> 00:35:47,660
make Chan int and so CH in this case is

00:35:45,800 --> 00:35:50,960
a channel a new channel of integers and

00:35:47,660 --> 00:35:53,480
then communication is expressed using

00:35:50,960 --> 00:35:56,450
the channel operator which is a less

00:35:53,480 --> 00:35:58,570
than - like a little arrow and so to

00:35:56,450 --> 00:36:02,810
send the integer seven down this channel

00:35:58,570 --> 00:36:05,000
we do channel less than - seven and then

00:36:02,810 --> 00:36:07,250
to receive an informational it's kind of

00:36:05,000 --> 00:36:10,610
the reverse and we receive a value from

00:36:07,250 --> 00:36:12,050
CH and then store it in AI now the data

00:36:10,610 --> 00:36:14,450
always travels in the direction of the

00:36:12,050 --> 00:36:20,690
error so that makes sense

00:36:14,450 --> 00:36:22,520
um so commute an example of

00:36:20,690 --> 00:36:24,110
communication between goroutines here we

00:36:22,520 --> 00:36:26,120
have some function main we create a

00:36:24,110 --> 00:36:28,880
channel of integers and then we launch a

00:36:26,120 --> 00:36:31,250
go routine hauling some and we pass it

00:36:28,880 --> 00:36:33,980
some arguments followed by the channel C

00:36:31,250 --> 00:36:37,400
and then in the body of sum we add X and

00:36:33,980 --> 00:36:39,290
y and send that value down C and then

00:36:37,400 --> 00:36:41,990
back in our main function we receive the

00:36:39,290 --> 00:36:44,330
value from C and print it so channel

00:36:41,990 --> 00:36:47,480
operations then unlikely would in this

00:36:44,330 --> 00:36:49,490
case they typically block until the

00:36:47,480 --> 00:36:52,220
other side is ready so in this case this

00:36:49,490 --> 00:36:54,410
Center C will wait until this received

00:36:52,220 --> 00:36:55,670
from C is ready to happen now obviously

00:36:54,410 --> 00:36:57,170
they're going to be ready immediately in

00:36:55,670 --> 00:36:58,450
this instance but in other instances

00:36:57,170 --> 00:37:00,800
this can be very powerful

00:36:58,450 --> 00:37:02,270
synchronization primitive and gives way

00:37:00,800 --> 00:37:05,510
to some very interesting algorithmic

00:37:02,270 --> 00:37:07,910
possibilities but channels can be

00:37:05,510 --> 00:37:10,400
buffered or unbuffered and if you make a

00:37:07,910 --> 00:37:12,430
channel buffered the channel that

00:37:10,400 --> 00:37:16,940
ascends to that channel will not block

00:37:12,430 --> 00:37:18,860
until the buffer is full so to make a

00:37:16,940 --> 00:37:20,750
journal buffered you simply add a second

00:37:18,860 --> 00:37:22,850
parameter to make and which is the

00:37:20,750 --> 00:37:24,710
number of which is the size of the

00:37:22,850 --> 00:37:27,320
buffer so this this channel of integers

00:37:24,710 --> 00:37:31,850
will store 10 integers before it gets

00:37:27,320 --> 00:37:34,970
form so instead of making a function

00:37:31,850 --> 00:37:37,430
call to save each time we do a put put

00:37:34,970 --> 00:37:39,980
can just create a record to record value

00:37:37,430 --> 00:37:42,560
and send it down some channel so I'll

00:37:39,980 --> 00:37:45,320
add this field to my URL store

00:37:42,560 --> 00:37:48,680
a which is a channel of Records and then

00:37:45,320 --> 00:37:50,900
when I successfully perform a set I will

00:37:48,680 --> 00:37:54,530
send this record containing our key and

00:37:50,900 --> 00:37:56,030
URL down the channel save and then at

00:37:54,530 --> 00:37:57,440
the other end of that channel we need to

00:37:56,030 --> 00:37:59,530
have something that's actually receiving

00:37:57,440 --> 00:38:02,210
those values and writing them to disk

00:37:59,530 --> 00:38:04,520
now now we'll create this new method

00:38:02,210 --> 00:38:06,440
called save loop and save loop will run

00:38:04,520 --> 00:38:08,900
in their separate go routine and what it

00:38:06,440 --> 00:38:11,570
does is it opens the file identified by

00:38:08,900 --> 00:38:15,320
file name and bails if it can't open it

00:38:11,570 --> 00:38:17,690
and then creates a new gob encoder that

00:38:15,320 --> 00:38:20,720
wraps that file and then loops forever

00:38:17,690 --> 00:38:23,090
receiving from s dot save storing the

00:38:20,720 --> 00:38:25,280
record in R and then encoding are

00:38:23,090 --> 00:38:27,440
writing it to the file to the underlying

00:38:25,280 --> 00:38:31,670
file and logging an aerophone error

00:38:27,440 --> 00:38:33,590
occurs and so far the final thing is we

00:38:31,670 --> 00:38:35,990
need to modify a new URL store so that

00:38:33,590 --> 00:38:38,960
it kicks off the save loop in another go

00:38:35,990 --> 00:38:43,850
routine when the URL story is

00:38:38,960 --> 00:38:46,220
initialized and so we create some

00:38:43,850 --> 00:38:49,580
constant save queue length which is the

00:38:46,220 --> 00:38:52,880
internal buffer length of ours

00:38:49,580 --> 00:38:56,030
save channel and so we can have up to a

00:38:52,880 --> 00:38:59,960
thousand URLs being saved before ports

00:38:56,030 --> 00:39:02,930
will have to wait for there for the for

00:38:59,960 --> 00:39:06,380
the buffer to clear and then when I

00:39:02,930 --> 00:39:10,100
create the URL store value I'll also

00:39:06,380 --> 00:39:12,260
provide save with the result of making a

00:39:10,100 --> 00:39:16,460
channel of Records of save queue length

00:39:12,260 --> 00:39:18,880
lock length and then I call s dot load

00:39:16,460 --> 00:39:22,040
passing in the file name parameter and

00:39:18,880 --> 00:39:24,260
and lock the error and then I kick off

00:39:22,040 --> 00:39:25,570
with a go routine that's running save

00:39:24,260 --> 00:39:29,330
loop

00:39:25,570 --> 00:39:32,180
passing in the file name so just very

00:39:29,330 --> 00:39:33,530
briefly in this program already there's

00:39:32,180 --> 00:39:35,450
a lot of magic numbers a lot of

00:39:33,530 --> 00:39:37,970
constants own replace them with command

00:39:35,450 --> 00:39:39,410
line flags I can import the flag package

00:39:37,970 --> 00:39:43,430
and set up a bunch of local variables

00:39:39,410 --> 00:39:45,320
blah blah the one thing I have to be

00:39:43,430 --> 00:39:48,650
sure to do is call flag the pass at the

00:39:45,320 --> 00:39:51,680
start of my main function to actually

00:39:48,650 --> 00:39:53,120
read the command line options and set

00:39:51,680 --> 00:39:56,000
these global variables to their

00:39:53,120 --> 00:39:56,460
respective values and I need to move

00:39:56,000 --> 00:39:58,170
mine

00:39:56,460 --> 00:40:00,770
realization of new URL store into the

00:39:58,170 --> 00:40:04,859
main function so that I can refer to my

00:40:00,770 --> 00:40:06,540
now past command line flag and similarly

00:40:04,859 --> 00:40:09,150
we update the listen address and the

00:40:06,540 --> 00:40:12,839
host name in the ad handler but I'll

00:40:09,150 --> 00:40:17,460
quickly demonstrate but we'll I know I

00:40:12,839 --> 00:40:20,000
won't um one more thing the last thing

00:40:17,460 --> 00:40:23,010
that I'm going to do to this program is

00:40:20,000 --> 00:40:25,380
so far we have a program that runs in a

00:40:23,010 --> 00:40:28,290
single process and while it runs

00:40:25,380 --> 00:40:30,480
concurrently in that single process and

00:40:28,290 --> 00:40:33,240
it will spawn multiple threads to handle

00:40:30,480 --> 00:40:35,580
blocking operations so it will always

00:40:33,240 --> 00:40:37,530
have something to do but a single

00:40:35,580 --> 00:40:40,830
process running on a single machine can

00:40:37,530 --> 00:40:44,339
only go so far what I'd like to do is

00:40:40,830 --> 00:40:47,880
turn this into a production ready web

00:40:44,339 --> 00:40:52,470
scale URL shortener and to do this I

00:40:47,880 --> 00:40:54,540
will shard this program into master and

00:40:52,470 --> 00:40:56,339
slaves and the way this will work is

00:40:54,540 --> 00:40:57,599
users will make requests through some

00:40:56,339 --> 00:40:59,430
sort of load balancer which I'm not

00:40:57,599 --> 00:41:02,490
going to worry about now but they'll hit

00:40:59,430 --> 00:41:05,070
slave front ends via HTTP and these

00:41:02,490 --> 00:41:07,080
slaves will make RPC calls to the master

00:41:05,070 --> 00:41:09,500
and what I'm going to demonstrate now is

00:41:07,080 --> 00:41:17,910
the implementation of those are pcs and

00:41:09,500 --> 00:41:24,630
I'm turning this into a slave so I just

00:41:17,910 --> 00:41:26,520
sing so to introduce goes RPC mechanism

00:41:24,630 --> 00:41:30,180
it's part of the standard library and

00:41:26,520 --> 00:41:33,410
it's very simple the way it works is

00:41:30,180 --> 00:41:37,080
given an up given a value of some type

00:41:33,410 --> 00:41:39,720
RPC will expose that value the value the

00:41:37,080 --> 00:41:42,900
methods of that value that have this

00:41:39,720 --> 00:41:46,080
form and the form is for some type T

00:41:42,900 --> 00:41:48,480
they need to have two pointers as their

00:41:46,080 --> 00:41:50,750
arguments and only two and return an

00:41:48,480 --> 00:41:53,490
error value and so if you have a type

00:41:50,750 --> 00:41:57,710
which implements methods of that form

00:41:53,490 --> 00:42:02,460
then RPC can serve them over a network

00:41:57,710 --> 00:42:04,109
so to make our URL store a RPC service

00:42:02,460 --> 00:42:07,710
we need to change the function

00:42:04,109 --> 00:42:09,780
signatures of our get input methods so

00:42:07,710 --> 00:42:10,319
instead of take instead of get taking a

00:42:09,780 --> 00:42:12,269
key and

00:42:10,319 --> 00:42:16,170
a URL instead it's going to take

00:42:12,269 --> 00:42:19,319
pointers to two strings key and URL and

00:42:16,170 --> 00:42:21,089
then return an error and similarly put

00:42:19,319 --> 00:42:23,579
is going to is going to take pointers to

00:42:21,089 --> 00:42:26,729
URLs and keys and return an error now

00:42:23,579 --> 00:42:29,099
and and once you've done that you also

00:42:26,729 --> 00:42:31,680
need to obviously modify the call sites

00:42:29,099 --> 00:42:33,719
of those methods in our add and redirect

00:42:31,680 --> 00:42:35,519
handlers so that they do the right

00:42:33,719 --> 00:42:39,619
things but I'm not going to show that

00:42:35,519 --> 00:42:43,859
now because I'm running out of home but

00:42:39,619 --> 00:42:46,829
to actually serve the our URL store over

00:42:43,859 --> 00:42:51,630
the network I'll add this command line

00:42:46,829 --> 00:42:54,180
flag RPC enabled and it's called RPC and

00:42:51,630 --> 00:42:58,229
it's a boolean value so if I call my

00:42:54,180 --> 00:43:01,859
go-to with - RPC it will it will serve

00:42:58,229 --> 00:43:04,259
its get input methods over RPC over HTTP

00:43:01,859 --> 00:43:08,009
and the way we do that is if the RPC

00:43:04,259 --> 00:43:10,349
enabled flag is set I call RPC that

00:43:08,009 --> 00:43:13,079
register name to register store under

00:43:10,349 --> 00:43:16,349
the name store and then I call handle

00:43:13,079 --> 00:43:19,410
HTTP and that will hook the RPC engine

00:43:16,349 --> 00:43:23,190
into the HTTP package and later on when

00:43:19,410 --> 00:43:25,769
I set up my HTTP server it will also

00:43:23,190 --> 00:43:29,180
transparently serve RPC through it using

00:43:25,769 --> 00:43:31,680
a little bit of magic but not much and

00:43:29,180 --> 00:43:34,319
so now that we have the URL store

00:43:31,680 --> 00:43:36,900
available as an RPC service we can build

00:43:34,319 --> 00:43:39,539
another type which looks like a URL

00:43:36,900 --> 00:43:41,339
store except all it does is past its

00:43:39,539 --> 00:43:44,160
requests through to the master server

00:43:41,339 --> 00:43:45,989
and so we'll call this the proxy store

00:43:44,160 --> 00:43:49,969
and the proxy store is a struct that

00:43:45,989 --> 00:43:53,249
simply contains an RPC client handle and

00:43:49,969 --> 00:43:55,529
so our new proxy store initializer

00:43:53,249 --> 00:43:58,469
function will take an address and this

00:43:55,529 --> 00:44:00,630
is the address of the RPC server and it

00:43:58,469 --> 00:44:03,180
will call dial HTTP from the obviously

00:44:00,630 --> 00:44:06,979
package to connect to that address over

00:44:03,180 --> 00:44:11,489
TCP and then if an error occurs it'll

00:44:06,979 --> 00:44:13,650
log it but otherwise the client will be

00:44:11,489 --> 00:44:15,359
put in the proxy store field and that

00:44:13,650 --> 00:44:18,809
proxy store will be returned to the user

00:44:15,359 --> 00:44:21,329
and then we define get input methods on

00:44:18,809 --> 00:44:23,940
that proxy store and what they do is

00:44:21,329 --> 00:44:24,900
they take keys and URLs

00:44:23,940 --> 00:44:28,140
and then they pass through those

00:44:24,900 --> 00:44:30,990
requests by invoking the call method on

00:44:28,140 --> 00:44:34,590
the RPC client and this will call the

00:44:30,990 --> 00:44:36,330
store get method at the other end of the

00:44:34,590 --> 00:44:38,730
RPC connection which will be another

00:44:36,330 --> 00:44:41,400
instance of goto passing in the qiyan

00:44:38,730 --> 00:44:43,950
URL and so when this returns it returns

00:44:41,400 --> 00:44:46,800
the error value from that call and URL

00:44:43,950 --> 00:44:49,800
will be updated with the resultant value

00:44:46,800 --> 00:44:53,490
and similarly the same thing will happen

00:44:49,800 --> 00:44:56,000
with port and key so this is enough to

00:44:53,490 --> 00:44:59,880
implement like a pass through but

00:44:56,000 --> 00:45:02,640
there's something missing the slave has

00:44:59,880 --> 00:45:07,020
to cache some of this data otherwise

00:45:02,640 --> 00:45:08,550
it's all it's doing is adding work so we

00:45:07,020 --> 00:45:11,550
already have the perfect data structure

00:45:08,550 --> 00:45:15,300
in which she cache this data and that is

00:45:11,550 --> 00:45:18,630
the URL store so I'll add a urls field

00:45:15,300 --> 00:45:22,680
to my proxy store struct call it URLs

00:45:18,630 --> 00:45:25,320
and then initialize it in my initializer

00:45:22,680 --> 00:45:27,060
function by invoking new URL store and

00:45:25,320 --> 00:45:29,790
the one thing that I'm not showing here

00:45:27,060 --> 00:45:31,860
is I've just modified your URL store so

00:45:29,790 --> 00:45:34,020
that if you give it an empty file name

00:45:31,860 --> 00:45:35,400
it just won't try to read or write it to

00:45:34,020 --> 00:45:37,920
disk it still does all the in-memory

00:45:35,400 --> 00:45:40,890
stuff it still keeps a map but it won't

00:45:37,920 --> 00:45:44,970
write anything to disk and then I modify

00:45:40,890 --> 00:45:47,820
my proxy stores get and set methods or

00:45:44,970 --> 00:45:51,090
get input methods so that first it tries

00:45:47,820 --> 00:45:53,220
to get from the local URL store cache

00:45:51,090 --> 00:45:56,430
and if it finds something in the cache

00:45:53,220 --> 00:45:58,980
if area is nil I can return and then

00:45:56,430 --> 00:46:01,770
that value this URL value will be

00:45:58,980 --> 00:46:04,470
updated with the cached value otherwise

00:46:01,770 --> 00:46:06,720
I try the RPC call and if the RPC call

00:46:04,470 --> 00:46:09,180
has a problem this will return the error

00:46:06,720 --> 00:46:12,630
if it doesn't have an error meaning it's

00:46:09,180 --> 00:46:14,940
successfully found something it's

00:46:12,630 --> 00:46:19,050
successfully gotten the URL from the RPC

00:46:14,940 --> 00:46:21,630
server I'll set that in my URL store

00:46:19,050 --> 00:46:25,020
cache in the local cache and then return

00:46:21,630 --> 00:46:28,470
no error and then the put method is

00:46:25,020 --> 00:46:30,990
simpler it attempts to do a port to the

00:46:28,470 --> 00:46:34,700
master RPC server and if that's

00:46:30,990 --> 00:46:34,700
successful it updates the cache

00:46:35,149 --> 00:46:40,079
so now we want to integrate proxy store

00:46:38,519 --> 00:46:42,419
with the web front-end we want our

00:46:40,079 --> 00:46:44,459
slaves to serve our web interface and

00:46:42,419 --> 00:46:47,299
for it to pass all its requests through

00:46:44,459 --> 00:46:50,279
the proxy store instead of the URL store

00:46:47,299 --> 00:46:52,649
because they both share the same methods

00:46:50,279 --> 00:46:55,409
get input we can define an interface

00:46:52,649 --> 00:46:58,169
type called store which includes the put

00:46:55,409 --> 00:47:02,039
and get methods and our global variable

00:46:58,169 --> 00:47:05,159
store can be of type store and then in

00:47:02,039 --> 00:47:10,169
our main in our main area we can create

00:47:05,159 --> 00:47:12,509
a master address flag - master which is

00:47:10,169 --> 00:47:16,439
the address of the master RPC server and

00:47:12,509 --> 00:47:18,029
if a master address is provided it means

00:47:16,439 --> 00:47:20,099
that we must be a slave if we're being

00:47:18,029 --> 00:47:21,359
told to connect to a master this go to

00:47:20,099 --> 00:47:25,409
instance is a slave

00:47:21,359 --> 00:47:27,839
so we instantiate a proxy store pointing

00:47:25,409 --> 00:47:29,399
to that master address but if master

00:47:27,839 --> 00:47:31,289
ghost isn't supplied then we must be the

00:47:29,399 --> 00:47:33,359
master and so we create a URL store

00:47:31,289 --> 00:47:36,359
which reads and writes from this data

00:47:33,359 --> 00:47:38,880
file but then the rest of our interface

00:47:36,359 --> 00:47:40,799
code behaves exactly as before I've just

00:47:38,880 --> 00:47:43,429
swapped in an entire new set of

00:47:40,799 --> 00:47:46,229
functionality and the interface has been

00:47:43,429 --> 00:47:48,509
implicitly taken advantage of and I've

00:47:46,229 --> 00:47:51,029
not had to do any further changes to the

00:47:48,509 --> 00:48:06,679
front-end for this to work so I'll just

00:47:51,029 --> 00:48:12,269
demonstrate this ball in flight so I

00:48:06,679 --> 00:48:16,829
have a a if I go to slash ad on

00:48:12,269 --> 00:48:18,539
localhost you will see we have a URL

00:48:16,829 --> 00:48:20,639
store running that's all we've got a few

00:48:18,539 --> 00:48:24,899
URLs in there but then what I've

00:48:20,639 --> 00:48:28,380
actually written is this little little

00:48:24,899 --> 00:48:31,079
graph graphing program and this this has

00:48:28,380 --> 00:48:32,909
got its hooks into my go-to instances

00:48:31,079 --> 00:48:34,949
and we have a little benchmarking

00:48:32,909 --> 00:48:37,859
program and what the benchmarking

00:48:34,949 --> 00:48:40,109
program is doing is you can see

00:48:37,859 --> 00:48:42,869
identified by this blue series at the

00:48:40,109 --> 00:48:45,359
top the blue series is the benchmarking

00:48:42,869 --> 00:48:47,250
program making gets against my go-to

00:48:45,359 --> 00:48:50,250
program and

00:48:47,250 --> 00:48:53,730
the yellow series down here is the

00:48:50,250 --> 00:48:57,740
benchmarking program making puts and the

00:48:53,730 --> 00:48:59,640
red series is the the go to store

00:48:57,740 --> 00:49:02,580
reporting the number of gates that are

00:48:59,640 --> 00:49:04,650
being made every second and the green

00:49:02,580 --> 00:49:06,480
series is reporting the number of ports

00:49:04,650 --> 00:49:08,270
that are being made every second so we

00:49:06,480 --> 00:49:12,600
can see from this graph that

00:49:08,270 --> 00:49:14,460
approximately eight to ten ports are

00:49:12,600 --> 00:49:16,730
being made per second by the

00:49:14,460 --> 00:49:19,200
benchmarking program and about a hundred

00:49:16,730 --> 00:49:21,000
gets are being made and they're being

00:49:19,200 --> 00:49:22,790
serviced one to one so there's only one

00:49:21,000 --> 00:49:25,080
master and that's all that's happening

00:49:22,790 --> 00:49:27,600
what I'll do is just increase the volume

00:49:25,080 --> 00:49:30,270
a little bit so we're now serving

00:49:27,600 --> 00:49:31,860
between five and six hundred get

00:49:30,270 --> 00:49:33,270
requests a second in about 50 foot

00:49:31,860 --> 00:49:35,460
requests a second so we're increasing

00:49:33,270 --> 00:49:39,060
the size of our data set substantially

00:49:35,460 --> 00:49:40,770
with every second that goes past so if I

00:49:39,060 --> 00:49:42,170
want to introduce a slave we can see

00:49:40,770 --> 00:49:44,220
what happens

00:49:42,170 --> 00:49:47,730
introducing a slave we noticed that

00:49:44,220 --> 00:49:50,250
immediately the red series the Masters

00:49:47,730 --> 00:49:53,040
get requests have gone to zero because

00:49:50,250 --> 00:49:55,410
now our slave which is this new purple

00:49:53,040 --> 00:49:57,270
series is serving all of the get

00:49:55,410 --> 00:49:59,640
requests it's sitting between the

00:49:57,270 --> 00:50:01,770
benchmarking program and the master so

00:49:59,640 --> 00:50:03,360
the benchmark are is hitting it hard but

00:50:01,770 --> 00:50:05,520
the number of put requests are still

00:50:03,360 --> 00:50:07,710
remain constant and they're still being

00:50:05,520 --> 00:50:10,830
served by the master server because

00:50:07,710 --> 00:50:16,410
they're being passed straight through if

00:50:10,830 --> 00:50:19,110
I add a second slave and predictably we

00:50:16,410 --> 00:50:21,420
can see that as the as the number of

00:50:19,110 --> 00:50:23,760
aggregate aggregate gets the blue series

00:50:21,420 --> 00:50:27,150
that are being made remains the same

00:50:23,760 --> 00:50:28,950
roughly we can see that each slave the

00:50:27,150 --> 00:50:32,160
darker blue and the purple series in the

00:50:28,950 --> 00:50:34,980
middle sharing the load about 50/50 and

00:50:32,160 --> 00:50:36,870
now the masters get requests have gone

00:50:34,980 --> 00:50:39,030
up a little bit because it has to prime

00:50:36,870 --> 00:50:40,920
the caches in each of the slaves now

00:50:39,030 --> 00:50:47,040
that each slave is sharing a different

00:50:40,920 --> 00:50:47,910
part of the load adding a third slave we

00:50:47,040 --> 00:50:53,000
can see that again

00:50:47,910 --> 00:50:54,710
this it's it's now gone

00:50:53,000 --> 00:50:56,720
to about a third and the master is still

00:50:54,710 --> 00:50:58,310
sitting pretty low and the one thing I

00:50:56,720 --> 00:51:01,400
should have showed you from the

00:50:58,310 --> 00:51:12,490
beginning of this demonstration is if we

00:51:01,400 --> 00:51:15,380
look at the process if we look at the

00:51:12,490 --> 00:51:19,730
that my process lists these three

00:51:15,380 --> 00:51:24,490
instances of go to here are running at

00:51:19,730 --> 00:51:28,640
just between 15 and 20% CPU well this

00:51:24,490 --> 00:51:30,980
well this instance here is running at

00:51:28,640 --> 00:51:32,570
about five percent and that's our master

00:51:30,980 --> 00:51:37,190
so the master is being shielded from

00:51:32,570 --> 00:51:39,160
this onslaught of requests and the

00:51:37,190 --> 00:51:41,990
benchmarking program itself is kind of

00:51:39,160 --> 00:51:43,970
doing most of the work and you notice

00:51:41,990 --> 00:51:47,260
that I haven't specifically asked for

00:51:43,970 --> 00:51:50,480
any threats in any of these programs

00:51:47,260 --> 00:51:52,850
except my slaves are running about 10

00:51:50,480 --> 00:51:55,040
threads apiece and my master is running

00:51:52,850 --> 00:51:56,420
about about 10 threads as well

00:51:55,040 --> 00:51:58,490
well my benchmarking program actually

00:51:56,420 --> 00:52:02,600
has 92 threats so it's hammering pretty

00:51:58,490 --> 00:52:05,140
hard and this is this is now serving

00:52:02,600 --> 00:52:08,150
like six seven hundred requests a second

00:52:05,140 --> 00:52:10,850
on this puny MacBook Air which is

00:52:08,150 --> 00:52:15,290
totally underpowered and then pretty

00:52:10,850 --> 00:52:17,780
much piece of junk so you know imagine

00:52:15,290 --> 00:52:20,720
what it could do on a real server and

00:52:17,780 --> 00:52:23,570
this is without having to this is like

00:52:20,720 --> 00:52:25,190
genuine high performance code here

00:52:23,570 --> 00:52:26,900
without having to even really think

00:52:25,190 --> 00:52:29,270
about efficiency it's all just kind of

00:52:26,900 --> 00:52:35,020
given to us for free by the fact that go

00:52:29,270 --> 00:52:37,760
is such a lightweight language now so

00:52:35,020 --> 00:52:39,170
this while this program works and you

00:52:37,760 --> 00:52:42,410
can see it's fairly resilient and it's

00:52:39,170 --> 00:52:44,090
fairly performant you'll notice that

00:52:42,410 --> 00:52:45,650
there's a bunch of stuff that could be a

00:52:44,090 --> 00:52:47,780
lot better obviously the aesthetics

00:52:45,650 --> 00:52:51,590
could be greatly improved could be a lot

00:52:47,780 --> 00:52:53,150
prettier go has a template package that

00:52:51,590 --> 00:52:55,310
would make this very easy to accomplish

00:52:53,150 --> 00:52:57,410
and if you visit the go website there's

00:52:55,310 --> 00:53:00,340
a code lab which goes through creating

00:52:57,410 --> 00:53:03,320
web application with a proper interface

00:53:00,340 --> 00:53:05,230
the reliability of this system could be

00:53:03,320 --> 00:53:06,950
a bit better currently if the

00:53:05,230 --> 00:53:09,650
master/slave RPC can

00:53:06,950 --> 00:53:13,730
action goes down it will just die and

00:53:09,650 --> 00:53:15,349
never be saved and and you could fix

00:53:13,730 --> 00:53:17,690
this by having some kind of dialogue a

00:53:15,349 --> 00:53:21,500
routine to reconnect every time it goes

00:53:17,690 --> 00:53:23,210
down and manage the connections as the

00:53:21,500 --> 00:53:24,920
size of the Ural database grows it might

00:53:23,210 --> 00:53:26,359
not fit in RAM anymore so we might have

00:53:24,920 --> 00:53:28,579
to shout it out and do something a bit

00:53:26,359 --> 00:53:31,460
more complicated and if you wanted to

00:53:28,579 --> 00:53:33,260
support deletion of URLs that would

00:53:31,460 --> 00:53:34,880
complicate the interactions between the

00:53:33,260 --> 00:53:36,770
Masters and the slaves because the

00:53:34,880 --> 00:53:38,420
master would have to report that you're

00:53:36,770 --> 00:53:39,859
also been deleted but these are all

00:53:38,420 --> 00:53:42,680
exercises for the reader and this code

00:53:39,859 --> 00:53:46,490
is all available in my github repository

00:53:42,680 --> 00:53:47,990
so you can check it out we've got a lot

00:53:46,490 --> 00:53:49,430
of there's a lot of go resources if

00:53:47,990 --> 00:53:52,700
you're interested in learning go the

00:53:49,430 --> 00:53:54,020
first place to go is golang.org where

00:53:52,700 --> 00:53:57,700
there's lots of Gaunt documentation

00:53:54,020 --> 00:54:01,220
tutorials and there's even if I can

00:53:57,700 --> 00:54:02,690
demonstrate very briefly there is even a

00:54:01,220 --> 00:54:05,750
box on the front page of the website

00:54:02,690 --> 00:54:09,460
where you can type your code and have it

00:54:05,750 --> 00:54:09,460
compiled and run on one of our servers

00:54:09,609 --> 00:54:14,180
there's our code blog and there's a

00:54:11,630 --> 00:54:27,530
bunch of other stuff so does anybody

00:54:14,180 --> 00:54:30,530
have any questions yeah hi what I

00:54:27,530 --> 00:54:33,619
haven't heard in your speech was what

00:54:30,530 --> 00:54:39,530
why would I have to use go and not for

00:54:33,619 --> 00:54:43,190
instance Java or C++ for this well if

00:54:39,530 --> 00:54:48,710
you like the syntax of Java and C++ then

00:54:43,190 --> 00:54:51,710
have fun but um honestly once you get to

00:54:48,710 --> 00:54:54,050
a certain size in substantial bit like

00:54:51,710 --> 00:54:57,290
the types of programming approaches that

00:54:54,050 --> 00:55:01,010
Java and C++ encourage is a very tight

00:54:57,290 --> 00:55:03,589
Laden hierarchical approach to writing

00:55:01,010 --> 00:55:05,000
software which once you get to a certain

00:55:03,589 --> 00:55:07,099
size it actually starts to really weigh

00:55:05,000 --> 00:55:09,290
down you and go as much has a much more

00:55:07,099 --> 00:55:12,530
compositional lightweight approach to

00:55:09,290 --> 00:55:15,290
writing software so I mean it's a long

00:55:12,530 --> 00:55:17,710
conversation if you want to get me

00:55:15,290 --> 00:55:17,710
afterwards

00:55:17,820 --> 00:55:25,300
any other questions so the two things

00:55:22,840 --> 00:55:29,380
that turn me off of go when I first saw

00:55:25,300 --> 00:55:31,990
it was first that it has null implicitly

00:55:29,380 --> 00:55:33,760
in the type system ie if you specify a

00:55:31,990 --> 00:55:36,460
function that takes a string it either

00:55:33,760 --> 00:55:38,470
takes a string or it takes null and the

00:55:36,460 --> 00:55:41,530
same thing if you return it that's not

00:55:38,470 --> 00:55:44,290
actually true there are certain types

00:55:41,530 --> 00:55:46,750
and go that that can be null and the

00:55:44,290 --> 00:55:49,030
string is not one of them only a

00:55:46,750 --> 00:55:53,470
reference type can be null and go so if

00:55:49,030 --> 00:55:56,260
you have a string or an integer or a or

00:55:53,470 --> 00:55:58,600
a float or any sort of concrete data

00:55:56,260 --> 00:56:00,100
type it can't be null

00:55:58,600 --> 00:56:02,250
it can only be at zero value which is

00:56:00,100 --> 00:56:04,630
usually numeric zero or an empty string

00:56:02,250 --> 00:56:07,540
but if you have a pointer type a point

00:56:04,630 --> 00:56:08,830
it can be not or if you have a map type

00:56:07,540 --> 00:56:11,200
a map can be null if it's not

00:56:08,830 --> 00:56:14,820
initialized or if you have a an array or

00:56:11,200 --> 00:56:18,340
a slice type rather a slice can be null

00:56:14,820 --> 00:56:19,930
so does that mean that I can write that

00:56:18,340 --> 00:56:25,600
I can implement the type that cannot be

00:56:19,930 --> 00:56:27,880
null then or yes and if you have like a

00:56:25,600 --> 00:56:34,600
struct type you can use a struct value

00:56:27,880 --> 00:56:36,610
and a struct value cannot be now know

00:56:34,600 --> 00:56:39,540
that I mean if you need further

00:56:36,610 --> 00:56:42,250
clarification I can talk about it up

00:56:39,540 --> 00:56:44,830
yeah one of the one of the things that

00:56:42,250 --> 00:56:46,240
strikes me is that go is apparently a

00:56:44,830 --> 00:56:49,120
language which is designed for

00:56:46,240 --> 00:56:51,490
concurrency yet when you can prepare it

00:56:49,120 --> 00:56:53,070
with well-designed concurrent languages

00:56:51,490 --> 00:56:55,930
it becomes clear that gos concurrency

00:56:53,070 --> 00:56:58,960
primitives are at best half-assed and at

00:56:55,930 --> 00:57:00,700
worst actively dangerous you have

00:56:58,960 --> 00:57:02,440
designed a concurrent language which is

00:57:00,700 --> 00:57:05,710
based around shared mutable state and

00:57:02,440 --> 00:57:08,320
that pretty dim-witted if I ever may say

00:57:05,710 --> 00:57:10,570
so to begin with and then you also have

00:57:08,320 --> 00:57:12,610
channels which block callers you have

00:57:10,570 --> 00:57:14,740
core primitives which are not type safe

00:57:12,610 --> 00:57:16,420
I guess my question is how you were able

00:57:14,740 --> 00:57:18,490
to design a concurrent language which is

00:57:16,420 --> 00:57:20,620
so terrible at being a concurrent

00:57:18,490 --> 00:57:21,700
language it would be nice it would be

00:57:20,620 --> 00:57:22,870
nicer if you could have phrased a

00:57:21,700 --> 00:57:26,829
question in a way that wasn't incredibly

00:57:22,870 --> 00:57:29,539
insulting because I do think

00:57:26,829 --> 00:57:31,369
because because I do think that you

00:57:29,539 --> 00:57:32,329
actually have a point but what you're

00:57:31,369 --> 00:57:34,910
actually pointing to is the

00:57:32,329 --> 00:57:36,200
philosophical difference go is a

00:57:34,910 --> 00:57:39,079
language that is very close to the

00:57:36,200 --> 00:57:40,700
machine it has its heritage in C but we

00:57:39,079 --> 00:57:42,910
don't we allow you to shoot yourself in

00:57:40,700 --> 00:57:46,609
the foot if that's what you want to do

00:57:42,910 --> 00:57:50,030
it doesn't it's not a immutable sort of

00:57:46,609 --> 00:57:51,980
fence non shared memory model for

00:57:50,030 --> 00:57:55,520
concurrency because that's not the way

00:57:51,980 --> 00:57:58,010
processes work on on the machines that

00:57:55,520 --> 00:58:01,039
we write code for so go is more of a

00:57:58,010 --> 00:58:02,599
pragmatic language in that sense but go

00:58:01,039 --> 00:58:05,390
as primitives like go routines and

00:58:02,599 --> 00:58:07,910
channels they actually actually allow

00:58:05,390 --> 00:58:09,670
you to do what we say is that you share

00:58:07,910 --> 00:58:12,890
memory by communicating about memory

00:58:09,670 --> 00:58:15,470
instead of communicating by sharing

00:58:12,890 --> 00:58:18,079
memory so while we allow you to use

00:58:15,470 --> 00:58:20,900
things like new taxes to implement like

00:58:18,079 --> 00:58:23,180
traditional evil sort of shared memory

00:58:20,900 --> 00:58:25,099
concurrency channels actually allow you

00:58:23,180 --> 00:58:26,660
to do in a way that is very efficient

00:58:25,099 --> 00:58:29,119
and easy to understand and predictable

00:58:26,660 --> 00:58:30,950
like pass around a pointer to a region

00:58:29,119 --> 00:58:32,660
of memory and when you when you write

00:58:30,950 --> 00:58:35,299
it's very easy to write code with

00:58:32,660 --> 00:58:38,270
channels that pass as pointers and pass

00:58:35,299 --> 00:58:40,880
as references around and that the dis

00:58:38,270 --> 00:58:42,710
safe because you can see there on the

00:58:40,880 --> 00:58:44,779
page that it's safe when you send that

00:58:42,710 --> 00:58:48,619
pointer down a channel don't use it

00:58:44,779 --> 00:58:52,460
anymore and then it's safe so yes it is

00:58:48,619 --> 00:58:54,440
possible to totally screw it up but the

00:58:52,460 --> 00:58:57,349
tools that we give you actually make it

00:58:54,440 --> 00:59:03,529
very very easy to write safe reliable

00:58:57,349 --> 00:59:06,750
concurrent code okay let's sting the

00:59:03,529 --> 00:59:13,320
speaker and a have a lunch

00:59:06,750 --> 00:59:13,320

YouTube URL: https://www.youtube.com/watch?v=2-pPAvqyluI


