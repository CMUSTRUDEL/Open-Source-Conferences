Title: PL Parrot: Cutting Edge Free Software
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	By David Fetter

Parrot is a virtual machine for dynamic languages, including Rakudo Perl 6.. PostgreSQL is the world's most powerful open source database management system. Find out how we brought them together, and what you can do, now that we have.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:07,580 --> 00:00:14,660
just a quick plug for my employer who is

00:00:11,040 --> 00:00:18,359
very kindly paying me to be here today I

00:00:14,660 --> 00:00:22,320
work at VMware we're doing very very

00:00:18,359 --> 00:00:24,619
cool stuff anybody that wants to learn

00:00:22,320 --> 00:00:27,750
about this cool stuff that we're doing

00:00:24,619 --> 00:00:31,230
before August please come talk to me

00:00:27,750 --> 00:00:36,450
afterwards and maybe we can see about

00:00:31,230 --> 00:00:40,829
getting you on our team what I'm working

00:00:36,450 --> 00:00:45,809
on at vmware is not this it's not even

00:00:40,829 --> 00:00:50,700
closely related to this but it's it's

00:00:45,809 --> 00:01:04,220
still pretty cool stuff okay so one

00:00:50,700 --> 00:01:07,860
moment so I'd like to talk about this

00:01:04,220 --> 00:01:09,720
this is something i don't know if you

00:01:07,860 --> 00:01:14,369
can see it there's an elephant there

00:01:09,720 --> 00:01:18,020
riding in on a parrot and my the woman

00:01:14,369 --> 00:01:24,479
who is now my wife as of actually has of

00:01:18,020 --> 00:01:26,850
last Saturday she made this this this

00:01:24,479 --> 00:01:30,299
image for me and I really appreciate it

00:01:26,850 --> 00:01:33,979
thank you Sarah okay so we have your

00:01:30,299 --> 00:01:35,970
blue elephant that's postgres ish and

00:01:33,979 --> 00:01:45,210
apparent and we're trying to bring them

00:01:35,970 --> 00:01:48,299
together yeah so normally you don't

00:01:45,210 --> 00:01:51,290
think of having bleeding edge features

00:01:48,299 --> 00:01:56,159
in on a relational database management

00:01:51,290 --> 00:01:57,869
system it's just not how we normally

00:01:56,159 --> 00:02:02,189
think of these things we think of them

00:01:57,869 --> 00:02:09,030
as sort of stodgy and old-fashioned and

00:02:02,189 --> 00:02:11,849
maybe maybe outmoded but this is

00:02:09,030 --> 00:02:13,260
postgres this is this is not stodgy old

00:02:11,849 --> 00:02:16,709
fashioned

00:02:13,260 --> 00:02:19,049
um and so we do have these cutting-edge

00:02:16,709 --> 00:02:21,720
features and I'd like to start by

00:02:19,049 --> 00:02:25,400
thanking the people to blame for these

00:02:21,720 --> 00:02:30,000
this new feature that guy in the middle

00:02:25,400 --> 00:02:34,379
Jonathan late oh he's been blazing a

00:02:30,000 --> 00:02:37,440
path through the parent space and she

00:02:34,379 --> 00:02:42,829
was the person that turned my wacky idea

00:02:37,440 --> 00:02:47,430
of embedding harridan postgresql into

00:02:42,829 --> 00:02:50,220
actual code that actually execute so

00:02:47,430 --> 00:02:54,889
this is this really important difference

00:02:50,220 --> 00:02:58,170
between the visionary that's me and

00:02:54,889 --> 00:03:03,409
actually having something happen so he's

00:02:58,170 --> 00:03:06,150
kind of a person that we really over the

00:03:03,409 --> 00:03:08,849
the credit or the blame which everyone

00:03:06,150 --> 00:03:11,639
whichever way you want to look at it uh

00:03:08,849 --> 00:03:16,650
this guy Josh Tolly anybody familiar

00:03:11,639 --> 00:03:20,180
with him no okay so he is the person

00:03:16,650 --> 00:03:25,079
responsible for embedding role code

00:03:20,180 --> 00:03:27,120
inside postgres you can now run stored

00:03:25,079 --> 00:03:32,060
procedures in lowell code inside

00:03:27,120 --> 00:03:37,400
postgres anybody familiar with mole code

00:03:32,060 --> 00:03:37,400
see a few heads is anybody hungover

00:03:39,410 --> 00:03:47,930
nobody's cop into it okay the guy on the

00:03:45,120 --> 00:03:51,629
right is David wheeler my colleague at

00:03:47,930 --> 00:03:56,099
postgresql experts a consulting company

00:03:51,629 --> 00:03:59,540
in which I hold a steak he did the PG

00:03:56,099 --> 00:04:03,690
tap tests which should be familiar to

00:03:59,540 --> 00:04:09,359
those of you the right pearl anybody

00:04:03,690 --> 00:04:13,229
familiar with tap its few hands so tap

00:04:09,359 --> 00:04:15,750
is the test anything protocol turns out

00:04:13,229 --> 00:04:19,650
it's not pearl specific and it's handy

00:04:15,750 --> 00:04:24,090
for lots and lots of different let's say

00:04:19,650 --> 00:04:25,979
test centered methods of development I

00:04:24,090 --> 00:04:27,090
really wouldn't call any method of

00:04:25,979 --> 00:04:29,910
development test

00:04:27,090 --> 00:04:32,370
Riven see tests don't up and come up

00:04:29,910 --> 00:04:35,370
with a set of requirements and start

00:04:32,370 --> 00:04:39,479
writing software so tests don't drive

00:04:35,370 --> 00:04:42,479
development and never will but you can

00:04:39,479 --> 00:04:45,030
have tests and they're handy to use when

00:04:42,479 --> 00:04:50,460
you're when you're developing software

00:04:45,030 --> 00:04:52,740
and you should never omit them down

00:04:50,460 --> 00:04:57,960
there in the middle that sort of dark

00:04:52,740 --> 00:05:03,210
pictures at me also like to thank Daniel

00:04:57,960 --> 00:05:09,300
out of bed Rocha whose picture I was not

00:05:03,210 --> 00:05:16,070
able to get in time for this top okay so

00:05:09,300 --> 00:05:21,330
harris is a virtual machine for dynamic

00:05:16,070 --> 00:05:26,600
languages it's register-based and its

00:05:21,330 --> 00:05:34,760
really really cool it's pluggable its

00:05:26,600 --> 00:05:36,750
interoperable it's dynamic postgresql is

00:05:34,760 --> 00:05:39,810
strangely enough the world's most

00:05:36,750 --> 00:05:45,889
pluggable database anybody know why that

00:05:39,810 --> 00:05:45,889
is yes

00:05:50,260 --> 00:05:55,190
so the answer was you can incorporate

00:05:52,940 --> 00:05:58,670
Perl scripts and postgresql store

00:05:55,190 --> 00:06:01,730
procedures which is true but what I had

00:05:58,670 --> 00:06:03,830
in mind was the fact that postgres hung

00:06:01,730 --> 00:06:07,460
out at the University of California at

00:06:03,830 --> 00:06:12,230
Berkeley for many years being the host

00:06:07,460 --> 00:06:18,080
of people's PhD theses so it was a place

00:06:12,230 --> 00:06:20,380
where you could find new I where you

00:06:18,080 --> 00:06:22,940
could sort of test out your new ideas at

00:06:20,380 --> 00:06:26,510
every level of a database management

00:06:22,940 --> 00:06:28,460
system however strange and so the result

00:06:26,510 --> 00:06:31,580
of this was an architecture which is

00:06:28,460 --> 00:06:33,530
pluggable at every level at least in

00:06:31,580 --> 00:06:35,900
theory there's a few parts that have

00:06:33,530 --> 00:06:39,410
been sort of welded together in the

00:06:35,900 --> 00:06:41,390
interests of performance or just out of

00:06:39,410 --> 00:06:45,170
the disinterest in actually plugging

00:06:41,390 --> 00:06:49,040
something in there but that's that's how

00:06:45,170 --> 00:06:54,770
it got to be so pluggable it's also

00:06:49,040 --> 00:06:57,200
extremely standards-compliant as far as

00:06:54,770 --> 00:07:00,670
I know no database management system and

00:06:57,200 --> 00:07:05,380
production is more compliant with SQL

00:07:00,670 --> 00:07:10,190
2008 than postgres and that includes db2

00:07:05,380 --> 00:07:14,810
db2 being sort of the place where SQL

00:07:10,190 --> 00:07:17,540
really got started um and of course

00:07:14,810 --> 00:07:20,390
postgresql is why I'm here because if it

00:07:17,540 --> 00:07:23,600
weren't for postgres I know but none of

00:07:20,390 --> 00:07:29,450
you guys would have heard of me and as

00:07:23,600 --> 00:07:33,440
it is only some of you have okay so why

00:07:29,450 --> 00:07:38,990
are we doing this well when you're going

00:07:33,440 --> 00:07:44,920
to embed a language in Postgres the

00:07:38,990 --> 00:07:50,300
process is sort of that's a pain in the

00:07:44,920 --> 00:07:52,070
neck really really serious pain in the

00:07:50,300 --> 00:07:54,980
neck there's a lot of repetitive work

00:07:52,070 --> 00:07:57,260
that goes on there's a lot of sort of

00:07:54,980 --> 00:08:03,289
cut and paste duplicate code that goes

00:07:57,260 --> 00:08:05,509
on and just generally as a lazy person

00:08:03,289 --> 00:08:08,149
offends my sensibilities that all this

00:08:05,509 --> 00:08:11,149
has to happen every time someone wants

00:08:08,149 --> 00:08:16,159
to plug the language into postgres the

00:08:11,149 --> 00:08:18,830
process should not be so arduous one

00:08:16,159 --> 00:08:22,639
goal i'm aiming for with this project is

00:08:18,830 --> 00:08:26,449
for you to come up with a language

00:08:22,639 --> 00:08:28,909
design that you're interested in in the

00:08:26,449 --> 00:08:30,860
morning well ok so maybe you took longer

00:08:28,909 --> 00:08:34,069
than that to design the language but you

00:08:30,860 --> 00:08:37,969
choose it in the morning you look at it

00:08:34,069 --> 00:08:43,069
over the course of the day you plug it

00:08:37,969 --> 00:08:48,130
into the parent system and by the time

00:08:43,069 --> 00:08:53,779
you log out for the evening it's done

00:08:48,130 --> 00:08:59,110
that's what I want ok so this is in

00:08:53,779 --> 00:09:02,360
order to get visible making a PL toolkit

00:08:59,110 --> 00:09:06,319
that's what this that that's what PL

00:09:02,360 --> 00:09:10,990
parrot is intended to be it's probably

00:09:06,319 --> 00:09:14,620
not going to be as fast as a like a PL

00:09:10,990 --> 00:09:18,019
llvm you could imagine such an embedding

00:09:14,620 --> 00:09:22,310
and maybe that's actually a better idea

00:09:18,019 --> 00:09:25,790
for for the for the high-performance

00:09:22,310 --> 00:09:29,600
kind of applications but it's meant to

00:09:25,790 --> 00:09:32,360
be able to do rapid prototyping in the

00:09:29,600 --> 00:09:35,120
real sense of actually being able to

00:09:32,360 --> 00:09:41,410
knock out a prototype quickly and have

00:09:35,120 --> 00:09:43,730
it work so for just a moment I'd like to

00:09:41,410 --> 00:09:46,160
digress into something a little

00:09:43,730 --> 00:09:55,149
philosophical here what we're actually

00:09:46,160 --> 00:09:59,870
doing is what i call the anti cloud so

00:09:55,149 --> 00:10:03,910
in the cloud model what you have is you

00:09:59,870 --> 00:10:06,380
disburse your data and you disperse the

00:10:03,910 --> 00:10:12,459
computational resources that you apply

00:10:06,380 --> 00:10:16,750
to the data all sort of around a network

00:10:12,459 --> 00:10:20,440
what's happening here is what

00:10:16,750 --> 00:10:22,540
used to call active databases this was

00:10:20,440 --> 00:10:26,730
one of the great debates of database

00:10:22,540 --> 00:10:30,670
management back in the 70s and 80s and

00:10:26,730 --> 00:10:34,770
on the passive side you basically had

00:10:30,670 --> 00:10:38,050
the idea that the data store was to do

00:10:34,770 --> 00:10:41,230
nothing except store data and on the

00:10:38,050 --> 00:10:43,930
active side you had this idea that you

00:10:41,230 --> 00:10:46,690
were going to have this enormous wonk of

00:10:43,930 --> 00:10:48,640
data and then right close to it you were

00:10:46,690 --> 00:10:53,020
going to put sort of computational

00:10:48,640 --> 00:10:57,240
resources and actions and things that

00:10:53,020 --> 00:11:00,240
went on with it so one of the first

00:10:57,240 --> 00:11:04,540
outcomes of this was a performant

00:11:00,240 --> 00:11:06,550
foreign key implementation another thing

00:11:04,540 --> 00:11:10,570
that was that came out of the active

00:11:06,550 --> 00:11:12,550
database idea was triggers which we now

00:11:10,570 --> 00:11:15,430
take for granted as being something that

00:11:12,550 --> 00:11:18,400
you do storm procedures was another

00:11:15,430 --> 00:11:21,430
thing that we now take for granted that

00:11:18,400 --> 00:11:23,620
you can just do in databases nobody

00:11:21,430 --> 00:11:26,950
really nobody really thinks of that as

00:11:23,620 --> 00:11:29,320
as revolutionary or innovative but it

00:11:26,950 --> 00:11:35,850
did come from this sort of philosophical

00:11:29,320 --> 00:11:38,980
split um okay 11 more a little bit of

00:11:35,850 --> 00:11:43,120
philosophy this one is a little gem from

00:11:38,980 --> 00:11:50,740
the Ruby community anybody want to guess

00:11:43,120 --> 00:11:54,339
what that is don't repeat yourself don't

00:11:50,740 --> 00:11:57,190
repeat yourself I just I can't emphasize

00:11:54,339 --> 00:12:02,910
enough how much of a pain in the rump it

00:11:57,190 --> 00:12:06,280
is to make a PL in Postgres right now

00:12:02,910 --> 00:12:10,020
the the documents themselves say

00:12:06,280 --> 00:12:13,360
something along the lines of insert a

00:12:10,020 --> 00:12:16,030
several thousand lines of code right

00:12:13,360 --> 00:12:20,290
here and then you'll have then you'll

00:12:16,030 --> 00:12:23,290
have a new PL well that's not the right

00:12:20,290 --> 00:12:27,070
answer another thing we'd like to be

00:12:23,290 --> 00:12:30,410
able to do is write things in PL Perl 6

00:12:27,070 --> 00:12:32,819
and then call them from PL pipe

00:12:30,410 --> 00:12:40,829
anybody notice anything strange about

00:12:32,819 --> 00:12:42,740
that second language no okay it doesn't

00:12:40,829 --> 00:12:47,579
have a capital you at the end of it

00:12:42,740 --> 00:12:50,429
because right now the pl the embeddable

00:12:47,579 --> 00:12:52,949
python implementation is one that can

00:12:50,429 --> 00:12:55,110
only be called by the postgres super

00:12:52,949 --> 00:12:58,670
earth that could only be written by the

00:12:55,110 --> 00:13:04,889
postgres super user and this is because

00:12:58,670 --> 00:13:07,829
the the Python that we're using to embed

00:13:04,889 --> 00:13:11,100
in Postgres can't be limited in its

00:13:07,829 --> 00:13:14,970
extent it can't be prevented from

00:13:11,100 --> 00:13:20,959
opening file handles or pipes or other

00:13:14,970 --> 00:13:20,959
things as the postgres system user which

00:13:21,559 --> 00:13:30,619
let's see sometimes you want a little

00:13:25,110 --> 00:13:35,730
bit more sandbox than that provides so

00:13:30,619 --> 00:13:38,670
what we'd like to do is sandbox the

00:13:35,730 --> 00:13:42,509
virtual machine in which all these

00:13:38,670 --> 00:13:50,990
operations occur and then pretty much by

00:13:42,509 --> 00:13:58,170
magic we get a PL Python trusted okay so

00:13:50,990 --> 00:14:03,959
how do we get to there from here first

00:13:58,170 --> 00:14:07,189
things first we're going to do up PL

00:14:03,959 --> 00:14:12,179
parrot intermediate representation

00:14:07,189 --> 00:14:17,850
anybody familiar with PIR okay that's

00:14:12,179 --> 00:14:22,290
that's one more than usual PIR is sort

00:14:17,850 --> 00:14:27,179
of the assembly language for the parrot

00:14:22,290 --> 00:14:29,100
parrot virtual machine only unlike an

00:14:27,179 --> 00:14:30,839
actual assembly language you can do some

00:14:29,100 --> 00:14:36,449
pretty high level stuff in it and it's

00:14:30,839 --> 00:14:38,819
really cool it it's it's it's actually

00:14:36,449 --> 00:14:43,440
kind of fun to program in it brings you

00:14:38,819 --> 00:14:46,110
back to to the time when you may

00:14:43,440 --> 00:14:47,400
you know gotten really close to the

00:14:46,110 --> 00:14:49,350
machine in this case you're getting

00:14:47,400 --> 00:14:51,290
close to the virtual machine and the

00:14:49,350 --> 00:14:54,120
virtual machine does a little more so

00:14:51,290 --> 00:14:58,440
being close to it lets you do powerful

00:14:54,120 --> 00:15:03,570
stuff okay so that was the first thing

00:14:58,440 --> 00:15:07,610
whoops all right that's our that's our

00:15:03,570 --> 00:15:07,610
first challenge is embedding parrot

00:15:09,110 --> 00:15:18,920
right now the parrot embedding is a

00:15:12,090 --> 00:15:24,750
little bit in flux there's pair you need

00:15:18,920 --> 00:15:27,510
parrot master and postgresql master well

00:15:24,750 --> 00:15:31,760
not so much anymore it'll actually run

00:15:27,510 --> 00:15:34,590
on postgresql nine-point-oh so that's

00:15:31,760 --> 00:15:35,730
that's actually a good thing but if you

00:15:34,590 --> 00:15:38,340
really want some of the more

00:15:35,730 --> 00:15:40,980
cutting-edge features we'll probably be

00:15:38,340 --> 00:15:45,270
seeing tracking parrot master and

00:15:40,980 --> 00:15:47,640
postgresql master this is one of the

00:15:45,270 --> 00:15:51,210
very strange things about working in in

00:15:47,640 --> 00:15:53,190
open source or free software or yeah I

00:15:51,210 --> 00:15:58,290
know they're not exactly the same thing

00:15:53,190 --> 00:16:00,870
close enough is that you get to work

00:15:58,290 --> 00:16:05,700
with sort of cutting-edge projects and

00:16:00,870 --> 00:16:08,490
this this has upsides and downsides I'll

00:16:05,700 --> 00:16:11,340
talk about the upsides right now in the

00:16:08,490 --> 00:16:14,370
process of getting this embedding done

00:16:11,340 --> 00:16:17,790
we found three or four bugs in Postgres

00:16:14,370 --> 00:16:21,470
and fix them and got them into the

00:16:17,790 --> 00:16:23,910
postgres code so that's the upside the

00:16:21,470 --> 00:16:26,310
projects can sort of play off each other

00:16:23,910 --> 00:16:29,120
and improve each other there are

00:16:26,310 --> 00:16:31,800
downsides I'll talk about those later

00:16:29,120 --> 00:16:37,020
okay so that was the embedding thing we

00:16:31,800 --> 00:16:42,420
did manage to get PIR embedded um the

00:16:37,020 --> 00:16:45,000
next thing to do so now there's a sort

00:16:42,420 --> 00:16:47,400
of an assembly language like thing that

00:16:45,000 --> 00:16:51,870
you can use to write stored procedures

00:16:47,400 --> 00:16:54,330
in well okay as cool as PIR is most

00:16:51,870 --> 00:16:57,290
people will not want to write code in it

00:16:54,330 --> 00:17:00,470
so we need a high-level language

00:16:57,290 --> 00:17:04,160
some of the high-level languages that

00:17:00,470 --> 00:17:08,310
run on top of parent right now would be

00:17:04,160 --> 00:17:11,339
tickle Python Ruby there's a project

00:17:08,310 --> 00:17:15,030
that's supposed to be doing / 05 there's

00:17:11,339 --> 00:17:20,100
Perl 6 that was what parrot was

00:17:15,030 --> 00:17:23,610
originally designed for so that's that

00:17:20,100 --> 00:17:25,610
that's so you know some of the itch hlls

00:17:23,610 --> 00:17:32,100
that we should be able to get in

00:17:25,610 --> 00:17:35,180
relatively simply the h ll api is a

00:17:32,100 --> 00:17:38,580
little bit rough but we do actually have

00:17:35,180 --> 00:17:41,400
well it actually it's p el Recodo not PL

00:17:38,580 --> 00:17:50,340
Perl 6 does anybody here care about the

00:17:41,400 --> 00:17:53,820
difference no okay so we have hlls the

00:17:50,340 --> 00:17:58,760
next thing we need to think about is how

00:17:53,820 --> 00:18:03,200
to marshal data in and out of postgres

00:17:58,760 --> 00:18:03,200
now this is a little bit more

00:18:03,980 --> 00:18:09,620
complicated than it seems because

00:18:09,920 --> 00:18:16,590
postgresql has this amazing type system

00:18:13,290 --> 00:18:19,620
I know no type system in the relational

00:18:16,590 --> 00:18:21,980
database management that comes close to

00:18:19,620 --> 00:18:26,330
the flexibility and the power of

00:18:21,980 --> 00:18:29,310
postgres but what that means is that

00:18:26,330 --> 00:18:31,830
there isn't just a list of types that

00:18:29,310 --> 00:18:33,900
you have to support if you're really

00:18:31,830 --> 00:18:37,850
going to have postgres support you have

00:18:33,900 --> 00:18:45,350
to have some way of creating new types

00:18:37,850 --> 00:18:49,530
in your language binding so as of now we

00:18:45,350 --> 00:18:53,340
support basic data type so text and the

00:18:49,530 --> 00:18:57,900
numeric ones we're working on the time

00:18:53,340 --> 00:19:00,300
types and we need something to fall

00:18:57,900 --> 00:19:06,090
through to which is the bite a or sort

00:19:00,300 --> 00:19:08,400
of blob of bits which is the has to be

00:19:06,090 --> 00:19:09,799
the fallback mechanism for all these

00:19:08,400 --> 00:19:12,529
types

00:19:09,799 --> 00:19:14,779
um it's at this point that I would like

00:19:12,529 --> 00:19:16,639
to beg for your help if you're

00:19:14,779 --> 00:19:20,289
interested in this sort of thing this is

00:19:16,639 --> 00:19:25,009
a great place to get started on the on

00:19:20,289 --> 00:19:28,190
PL parent ok that's the marshaling thing

00:19:25,009 --> 00:19:30,649
well I've gone well way too long here

00:19:28,190 --> 00:19:33,369
already without showing you some actual

00:19:30,649 --> 00:19:43,759
code so I'm going to do that right now

00:19:33,369 --> 00:19:46,429
this is PL PIR so what we do is you

00:19:43,759 --> 00:19:51,309
create this function it has a name it

00:19:46,429 --> 00:19:54,739
has a type input whoops get back there

00:19:51,309 --> 00:20:04,070
ok so it has an input type and an output

00:19:54,739 --> 00:20:06,440
type it has a language then we say as

00:20:04,070 --> 00:20:10,609
and then we transition from one language

00:20:06,440 --> 00:20:12,559
to another language this is one of the

00:20:10,609 --> 00:20:17,869
things that I think is really really

00:20:12,559 --> 00:20:20,450
interesting about para is this idea of

00:20:17,869 --> 00:20:23,210
formalizing the transition from one

00:20:20,450 --> 00:20:26,629
language to a different language anybody

00:20:23,210 --> 00:20:29,840
that's written me interpolated double

00:20:26,629 --> 00:20:33,830
quo has sort of done the same thing they

00:20:29,840 --> 00:20:37,009
you're you're going you're going from

00:20:33,830 --> 00:20:40,399
one sort of language context and that

00:20:37,009 --> 00:20:42,350
double quote mark is telling you that

00:20:40,399 --> 00:20:47,779
you're moving to a different language

00:20:42,350 --> 00:20:51,590
context but it's it's so small and so

00:20:47,779 --> 00:20:54,789
simple that's it's sort of easy to miss

00:20:51,590 --> 00:20:57,559
that this is what's going on whereas

00:20:54,789 --> 00:21:00,320
parent has sort of made this explicit

00:20:57,559 --> 00:21:03,379
and then I think there's some

00:21:00,320 --> 00:21:07,269
interesting possibilities as to what

00:21:03,379 --> 00:21:07,269
kinds of things one could do with this

00:21:07,359 --> 00:21:13,600
into the future anyway talk about I'll

00:21:12,019 --> 00:21:20,019
talk a little bit more about that later

00:21:13,600 --> 00:21:23,460
so we have ramen of x + 5 dot return X

00:21:20,019 --> 00:21:27,390
not super exciting code

00:21:23,460 --> 00:21:31,020
but you could sort of imagine what's

00:21:27,390 --> 00:21:34,150
what's going to be the result there

00:21:31,020 --> 00:21:38,230
here's another one that just handles

00:21:34,150 --> 00:21:40,950
strings directly now what i dimly recall

00:21:38,230 --> 00:21:43,630
of assembly which is what this really is

00:21:40,950 --> 00:21:49,870
didn't really have a concept of strings

00:21:43,630 --> 00:21:52,890
per se maybe I you know maybe I wasn't

00:21:49,870 --> 00:22:01,030
quite thinking of it them for right way

00:21:52,890 --> 00:22:02,799
okay so that's PLP I are uh now not too

00:22:01,030 --> 00:22:07,030
many small children in the room so

00:22:02,799 --> 00:22:15,309
that's good got a little scary thing

00:22:07,030 --> 00:22:24,160
here anybody anybody decipher that that

00:22:15,309 --> 00:22:26,559
is Perl 6 and it's really important to

00:22:24,160 --> 00:22:31,120
comment code that looks like this if you

00:22:26,559 --> 00:22:35,799
absolutely have to write it don't do

00:22:31,120 --> 00:22:38,140
what I have just done okay so that's

00:22:35,799 --> 00:22:40,410
that that's the languages we have that's

00:22:38,140 --> 00:22:44,860
sort of what they look like in practice

00:22:40,410 --> 00:22:49,059
at the moment perl 6 is a PL perl 6 is a

00:22:44,860 --> 00:22:51,460
little bit broken because the parrot

00:22:49,059 --> 00:22:53,500
project was running at full speed and

00:22:51,460 --> 00:22:55,929
the raka do project was running at full

00:22:53,500 --> 00:22:59,049
speed and they weren't quite synced up

00:22:55,929 --> 00:23:01,210
together and so if you try to create

00:22:59,049 --> 00:23:03,790
this function that will work fine right

00:23:01,210 --> 00:23:08,290
now but if you try to execute it it will

00:23:03,790 --> 00:23:11,230
peg the cpu and eventually crash your

00:23:08,290 --> 00:23:13,140
back end of postgres you won't lose data

00:23:11,230 --> 00:23:17,320
or anything but it's kind of annoying

00:23:13,140 --> 00:23:24,480
and that's one of the things that i

00:23:17,320 --> 00:23:27,480
would like to get your help um fix it um

00:23:24,480 --> 00:23:35,050
another thing we need to work on is

00:23:27,480 --> 00:23:36,490
access control so we have some idea of

00:23:35,050 --> 00:23:40,090
what sort of control

00:23:36,490 --> 00:23:42,910
we want to put on access and we have at

00:23:40,090 --> 00:23:46,600
least the ability to deny direct access

00:23:42,910 --> 00:23:49,570
to the file system so at least that kind

00:23:46,600 --> 00:23:56,290
of attack is not launched a ball through

00:23:49,570 --> 00:23:59,830
a trusted PL parent implementation we

00:23:56,290 --> 00:24:02,080
would like configurable controls some

00:23:59,830 --> 00:24:05,679
more control over the network so opening

00:24:02,080 --> 00:24:09,550
up network pipes and of course some

00:24:05,679 --> 00:24:18,600
sorts of tests for this kind of access

00:24:09,550 --> 00:24:23,020
control we have as a project actual pls

00:24:18,600 --> 00:24:27,880
tap tests from PG tap a git repo an

00:24:23,020 --> 00:24:34,660
issue tracker maybe someday postgres

00:24:27,880 --> 00:24:39,670
will have one of these and a freenode

00:24:34,660 --> 00:24:43,120
IRC channel thanks freenode we also have

00:24:39,670 --> 00:24:47,800
packages for Debian and fedora and I

00:24:43,120 --> 00:24:51,190
don't know what other os's but there are

00:24:47,800 --> 00:24:54,220
packages and so you can just use the

00:24:51,190 --> 00:24:56,920
packages and that's it we also have lots

00:24:54,220 --> 00:25:01,929
of enthusiasm this is a very important

00:24:56,920 --> 00:25:04,030
part of any ambitious project if you if

00:25:01,929 --> 00:25:09,240
you're bored with it if there's there's

00:25:04,030 --> 00:25:13,920
no way it can never succeed so yeah

00:25:09,240 --> 00:25:17,950
here's what we will we plan to do soon

00:25:13,920 --> 00:25:21,429
we plan to sort of get things back

00:25:17,950 --> 00:25:24,550
working again some better argument

00:25:21,429 --> 00:25:26,800
passing some more data type marshalling

00:25:24,550 --> 00:25:29,770
just sort of cover a few more of the

00:25:26,800 --> 00:25:36,240
built-in types and lots and lots more

00:25:29,770 --> 00:25:38,350
tests what we like uh some better

00:25:36,240 --> 00:25:40,870
sandboxing than we have now it's a

00:25:38,350 --> 00:25:43,150
little bit ad hoc and ad-hoc sandboxes

00:25:40,870 --> 00:25:48,010
are great for playing in but they're not

00:25:43,150 --> 00:25:50,559
so good for access control more hlls if

00:25:48,010 --> 00:25:54,090
you have a favorite language

00:25:50,559 --> 00:25:56,259
that you want to see in Postgres and and

00:25:54,090 --> 00:25:59,350
just kind of want to make a name for

00:25:56,259 --> 00:26:00,940
yourself this is your opportunity and

00:25:59,350 --> 00:26:04,049
that of course leads us to more

00:26:00,940 --> 00:26:06,759
developers and of course users because

00:26:04,049 --> 00:26:12,840
you know unless the thing is out in the

00:26:06,759 --> 00:26:12,840
world it's kind of it's kind of a toy

00:26:16,110 --> 00:26:24,369
let's see here how you help now well I

00:26:21,570 --> 00:26:27,070
like to put in something really concrete

00:26:24,369 --> 00:26:30,149
and I found one just this morning while

00:26:27,070 --> 00:26:33,159
I was reading over the source code again

00:26:30,149 --> 00:26:36,460
basically there is a thing in the source

00:26:33,159 --> 00:26:39,549
tree that's called PL peridot see it

00:26:36,460 --> 00:26:42,429
contains two languages which kind of

00:26:39,549 --> 00:26:46,330
have to be loaded together and that's

00:26:42,429 --> 00:26:50,049
sort of a that's sort of a modularity

00:26:46,330 --> 00:26:52,779
violation that would not be hard to fix

00:26:50,049 --> 00:26:55,659
it would start you would give you sort

00:26:52,779 --> 00:27:03,580
of an entry point into the source code

00:26:55,659 --> 00:27:07,809
of PL parrot another thing we we could

00:27:03,580 --> 00:27:12,039
use some help with right now is ensuring

00:27:07,809 --> 00:27:16,330
through the postgres dependency system

00:27:12,039 --> 00:27:18,940
that parrot based pls explicitly depend

00:27:16,330 --> 00:27:25,509
on PL PIR and cannot be loaded without

00:27:18,940 --> 00:27:28,720
it then like to see about expanding PLP

00:27:25,509 --> 00:27:30,879
I our scopes so that when you start to

00:27:28,720 --> 00:27:35,379
build things on top of it you're not

00:27:30,879 --> 00:27:37,210
finding yourself needing to to build

00:27:35,379 --> 00:27:40,389
extra features in order to get it to

00:27:37,210 --> 00:27:42,820
actually work with the database and of

00:27:40,389 --> 00:27:47,610
course you can go to github and take a

00:27:42,820 --> 00:27:52,480
look at our issue tracker alright so

00:27:47,610 --> 00:27:55,029
into the future now this this is where

00:27:52,480 --> 00:27:59,230
we begin to go into things that are a

00:27:55,029 --> 00:28:03,360
little speculative I'd like to see about

00:27:59,230 --> 00:28:04,659
tighter parrot integration in Postgres

00:28:03,360 --> 00:28:06,549
there's

00:28:04,659 --> 00:28:11,169
a little licensing issue but I think we

00:28:06,549 --> 00:28:13,989
could get over that but the one of the

00:28:11,169 --> 00:28:19,090
things that but postgres has is an

00:28:13,989 --> 00:28:21,190
amazing SQL engine it's so amazing that

00:28:19,090 --> 00:28:23,019
we actually managed to break bison win

00:28:21,190 --> 00:28:29,619
it at one point because it was too big

00:28:23,019 --> 00:28:32,679
right this so we actually for a while

00:28:29,619 --> 00:28:37,599
there we actually had to use a patch

00:28:32,679 --> 00:28:43,539
version of bison in order to build the

00:28:37,599 --> 00:28:48,009
grammar I think this is maybe a sign

00:28:43,539 --> 00:28:51,419
that that yak is starting to maybe be a

00:28:48,009 --> 00:28:56,679
little too small for what we're doing

00:28:51,419 --> 00:29:02,259
and I'd like to see a way to make the

00:28:56,679 --> 00:29:04,090
SQL handling done through parrot because

00:29:02,259 --> 00:29:06,519
parent is really built for this sort of

00:29:04,090 --> 00:29:09,789
thing you have a large grammar you could

00:29:06,519 --> 00:29:12,639
pretty much get a executable out of it

00:29:09,789 --> 00:29:15,070
very quickly with parent another thing

00:29:12,639 --> 00:29:20,169
that I would like to do is sort of have

00:29:15,070 --> 00:29:24,340
this transition between SQL and pls and

00:29:20,169 --> 00:29:26,440
among pls this is the kind of thing that

00:29:24,340 --> 00:29:29,139
I think parent would actually be very

00:29:26,440 --> 00:29:32,109
good at as far as handling that

00:29:29,139 --> 00:29:34,629
transition in and out and cleaning up

00:29:32,109 --> 00:29:37,659
after itself and doing all that all

00:29:34,629 --> 00:29:41,019
those fun things and then of course

00:29:37,659 --> 00:29:43,690
there's the all important stuff you

00:29:41,019 --> 00:29:48,580
create as I can't think of everything

00:29:43,690 --> 00:29:52,989
and the more people we have contributing

00:29:48,580 --> 00:29:54,700
and creating and criticizing and just

00:29:52,989 --> 00:29:57,909
generally making the thing better the

00:29:54,700 --> 00:30:02,440
better it will be you can find more info

00:29:57,909 --> 00:30:03,970
at PL parrot org and it's at this point

00:30:02,440 --> 00:30:15,099
that I'd like to open up the floor for

00:30:03,970 --> 00:30:17,399
more questions yes hang on a second skip

00:30:15,099 --> 00:30:17,399
the mic

00:30:23,080 --> 00:30:30,320
that's all it is you need people to work

00:30:27,290 --> 00:30:34,730
on datetime support I try to do that

00:30:30,320 --> 00:30:39,320
around postgres can it be done with us q

00:30:34,730 --> 00:30:41,690
eles in same time zone system uh can it

00:30:39,320 --> 00:30:47,960
be done with SQL is in same time zone

00:30:41,690 --> 00:30:49,910
system well you know calendaring systems

00:30:47,960 --> 00:30:53,930
as a class are some of the hardest

00:30:49,910 --> 00:30:57,200
things that we attempt as a species if

00:30:53,930 --> 00:30:59,330
you don't believe this have a look at

00:30:57,200 --> 00:31:05,180
some of the calendaring systems that

00:30:59,330 --> 00:31:07,640
that we built like Stonehenge this is

00:31:05,180 --> 00:31:11,660
the these are things that are not

00:31:07,640 --> 00:31:14,480
trivial and I don't think it's SQL s

00:31:11,660 --> 00:31:17,270
time zone system that makes it so what

00:31:14,480 --> 00:31:21,160
happens is that we have the confluence

00:31:17,270 --> 00:31:26,090
of physical phenomena like orbital

00:31:21,160 --> 00:31:28,100
orbital times of various astronomical

00:31:26,090 --> 00:31:31,760
bodies like the earth and the moon and

00:31:28,100 --> 00:31:34,700
the Sun possibly some other ones and

00:31:31,760 --> 00:31:37,880
then we have this thing laid on top of

00:31:34,700 --> 00:31:42,650
it which is a crazy quilt structure of

00:31:37,880 --> 00:31:47,270
law and custom not all of which is meant

00:31:42,650 --> 00:31:51,440
to fit together at all so the question

00:31:47,270 --> 00:31:53,870
of you know handling dates and times I

00:31:51,440 --> 00:31:56,240
think if aunt if it were to handle

00:31:53,870 --> 00:32:04,330
things the way postgres does it would be

00:31:56,240 --> 00:32:04,330
seen enough for practical purposes next

00:32:10,169 --> 00:32:14,080
alrighty well I'll be around for the

00:32:12,279 --> 00:32:19,299
rest of today if you have questions

00:32:14,080 --> 00:32:21,720
comments brickbats and like to thank you

00:32:19,299 --> 00:32:21,720

YouTube URL: https://www.youtube.com/watch?v=hY-r9xgpIss


