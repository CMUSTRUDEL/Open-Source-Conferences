Title: Coreboot: x86 system boot and initialization
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	By Rudolf Marek

We would like to present a talk aimed to various stages of x86 hardware initialization. We start with hardware description of typical x86 system including flash storage. We switch to the software part, defining the CPU state while it fetches first instruction. We present a step by step procedure with a descriptions of various steps (DRAM initialization, Northbridge/Southbridge initialization) necessary to bring the system to point where it can boot OS. Luckily there are Free software projects working close together - Coreboot, SeaBIOS, which we would like to introduce during the talk. Depending our slots in devroom we would either stress the first part or on contrary the second part (introduction of Coreboot SeaBIOS).

coreboot (formerly known as LinuxBIOS) is a Free Software project aimed at replacing the proprietary BIOS (firmware) you can find in most of today's computers. It performs just a little bit of hardware initialization and then executes a so-called payload.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:07,170 --> 00:00:13,620
hello I hope you can hear me well I know

00:00:10,920 --> 00:00:15,920
my talk will be about the system booth

00:00:13,620 --> 00:00:15,920
and

00:00:15,960 --> 00:00:20,640
open source or free software project

00:00:17,910 --> 00:00:24,480
which is doing the booting of the

00:00:20,640 --> 00:00:27,450
computer instead of the bios so first an

00:00:24,480 --> 00:00:30,150
outline so I will introduce briefly our

00:00:27,450 --> 00:00:33,330
projects then we have a look how the PC

00:00:30,150 --> 00:00:36,000
looks like nowadays in the point of

00:00:33,330 --> 00:00:38,670
buses and so on then there is a little

00:00:36,000 --> 00:00:40,470
catch we don't have any RAM at start so

00:00:38,670 --> 00:00:43,320
I will show you how to deal with this

00:00:40,470 --> 00:00:46,650
and of course how to init the RAM of the

00:00:43,320 --> 00:00:49,890
computer then we have plenty of buses to

00:00:46,650 --> 00:00:52,470
go through and stuff so this will be the

00:00:49,890 --> 00:00:56,460
last slides and tables and of course the

00:00:52,470 --> 00:00:58,829
boot so first who we are

00:00:56,460 --> 00:01:03,329
coreboot free software project coreboot

00:00:58,829 --> 00:01:06,450
org it's kind very roughly says it says

00:01:03,329 --> 00:01:10,410
that it's a replacement bios for two

00:01:06,450 --> 00:01:13,320
hundred and fifty bars it's quite fast

00:01:10,410 --> 00:01:17,130
we can boot your system in five hundred

00:01:13,320 --> 00:01:19,950
milliseconds or 1500 it depends on what

00:01:17,130 --> 00:01:24,420
you actually use tomorrow I will speak

00:01:19,950 --> 00:01:27,810
more about it in the embedded F room the

00:01:24,420 --> 00:01:30,630
focus or the deployment of core boots is

00:01:27,810 --> 00:01:34,350
mostly the security staff embedded

00:01:30,630 --> 00:01:36,900
systems and so on because you never know

00:01:34,350 --> 00:01:39,930
what the proprietary BIOS is doing so if

00:01:36,900 --> 00:01:43,140
the Secret Service also likes to know

00:01:39,930 --> 00:01:45,900
what's going on with their biases so we

00:01:43,140 --> 00:01:48,900
are targeting the embedded systems and

00:01:45,900 --> 00:01:54,979
of course clusters because this is how

00:01:48,900 --> 00:01:57,750
the project started in in in the year 99

00:01:54,979 --> 00:02:00,229
it was there was a huge cluster of

00:01:57,750 --> 00:02:02,579
computers and if you try to boot them

00:02:00,229 --> 00:02:05,610
they will complain that there is no

00:02:02,579 --> 00:02:07,680
keyboard so a guy must go around a

00:02:05,610 --> 00:02:10,709
thousand computers plug the keyboard

00:02:07,680 --> 00:02:13,680
press f1 go to the another boy another

00:02:10,709 --> 00:02:16,440
computer and so on and so on so this was

00:02:13,680 --> 00:02:18,260
let's say the first where the project

00:02:16,440 --> 00:02:24,019
has been started

00:02:18,260 --> 00:02:27,500
okay so here is mr. PC I think you

00:02:24,019 --> 00:02:29,989
should know it quite well but maybe we

00:02:27,500 --> 00:02:32,659
can repeat some some details I'm not

00:02:29,989 --> 00:02:35,239
sure if I have mouth so I can point so

00:02:32,659 --> 00:02:39,769
this is the CPUs now we have a multiple

00:02:35,239 --> 00:02:42,890
of them each CPU has now each memory

00:02:39,769 --> 00:02:45,590
controller here is the DRAM this is the

00:02:42,890 --> 00:02:47,959
dims you can replace on your bar is the

00:02:45,590 --> 00:02:50,690
Northbridge and Southbridge and in

00:02:47,959 --> 00:02:55,579
between there is some kind of bus which

00:02:50,690 --> 00:02:57,079
is FSB or hypertransport bus or between

00:02:55,579 --> 00:02:59,150
Northbridge and Southbridge there is

00:02:57,079 --> 00:03:01,819
also some buses it doesn't matter which

00:02:59,150 --> 00:03:04,760
right now and of course this the

00:03:01,819 --> 00:03:08,230
Southbridge which is having all your

00:03:04,760 --> 00:03:11,720
peripheral devices like USB drives

00:03:08,230 --> 00:03:15,829
cellular port and such stuff and of

00:03:11,720 --> 00:03:18,799
course there is a flash which has this

00:03:15,829 --> 00:03:21,920
program either the BIOS or the core boot

00:03:18,799 --> 00:03:25,310
if you replace it already so what is

00:03:21,920 --> 00:03:28,519
quite interesting on this on this slide

00:03:25,310 --> 00:03:31,250
is that the red parts must be done by

00:03:28,519 --> 00:03:34,549
the car boot while the system is booting

00:03:31,250 --> 00:03:40,660
so it's a lot of lot of stuff to do and

00:03:34,549 --> 00:03:44,180
we need to do it very quickly so

00:03:40,660 --> 00:03:47,959
fairytale about how to start a computer

00:03:44,180 --> 00:03:49,790
so if you if you push the button then at

00:03:47,959 --> 00:03:52,579
the beginning there is kind of power

00:03:49,790 --> 00:03:55,400
sequencing so when the computer is

00:03:52,579 --> 00:03:57,560
starting there are many many voltage

00:03:55,400 --> 00:04:00,519
regulators so we must wait until all

00:03:57,560 --> 00:04:04,489
voltages are the right levels and then

00:04:00,519 --> 00:04:07,400
the CPU get started and CPU will fetch

00:04:04,489 --> 00:04:12,500
the first instruction which is this

00:04:07,400 --> 00:04:15,709
instruction 9 and this is that this is

00:04:12,500 --> 00:04:18,049
the damp of the flash chip so if you

00:04:15,709 --> 00:04:20,180
take out the flash shape for the BIOS

00:04:18,049 --> 00:04:23,230
chip let's say out of the computer so

00:04:20,180 --> 00:04:25,630
this is the last 16 bytes of it

00:04:23,230 --> 00:04:27,820
and here is the first instruction so if

00:04:25,630 --> 00:04:30,520
you decode this instruction in fact it's

00:04:27,820 --> 00:04:33,580
a jump to another address and because

00:04:30,520 --> 00:04:36,670
I'm not expecting that you can read the

00:04:33,580 --> 00:04:39,310
machine code by looking at it so then

00:04:36,670 --> 00:04:41,260
you can go to the car boot and oh look

00:04:39,310 --> 00:04:43,660
here is the boot blog dot elf and you

00:04:41,260 --> 00:04:46,060
can object dump on it and you can

00:04:43,660 --> 00:04:48,250
immediately see what's going on so my

00:04:46,060 --> 00:04:50,980
presentation will be somehow intermixed

00:04:48,250 --> 00:04:53,590
with what is going on in the machine and

00:04:50,980 --> 00:04:55,750
then when we're you can find it in the

00:04:53,590 --> 00:05:02,980
core boot called the code base so you

00:04:55,750 --> 00:05:05,830
can follow follow the steps ok so at the

00:05:02,980 --> 00:05:07,750
beginning of our fairytale the computer

00:05:05,830 --> 00:05:13,240
starts in something which is called a

00:05:07,750 --> 00:05:17,980
real mode this mode is 40 years old it's

00:05:13,240 --> 00:05:20,320
like the first IBM PC since 1980 we're

00:05:17,980 --> 00:05:24,490
started in this mode so the CPU is still

00:05:20,320 --> 00:05:27,250
compatible 30 years still because of

00:05:24,490 --> 00:05:29,620
this binary compatibility stuff and so

00:05:27,250 --> 00:05:32,650
on so it really starts in this real mode

00:05:29,620 --> 00:05:35,620
which is kind of derived from 8-bit

00:05:32,650 --> 00:05:39,730
computers so we can address in one place

00:05:35,620 --> 00:05:42,940
only 64 bytes of RAM and totally one

00:05:39,730 --> 00:05:45,880
megabyte of RAM which is not very nice

00:05:42,940 --> 00:05:49,090
because we when the core boot is written

00:05:45,880 --> 00:05:53,050
in C and we want to use GCC to compile

00:05:49,090 --> 00:05:57,340
the staff and GCC on x86 is mostly

00:05:53,050 --> 00:06:01,380
producing the 32-bit code so what we

00:05:57,340 --> 00:06:04,600
need to do is that we need to switch to

00:06:01,380 --> 00:06:08,230
protected mode so in order to be able to

00:06:04,600 --> 00:06:10,690
execute 32-bit code how is it done is

00:06:08,230 --> 00:06:12,630
written here it's basically only a few

00:06:10,690 --> 00:06:15,430
instructions we need to load some

00:06:12,630 --> 00:06:20,280
descriptor table then we toggle some

00:06:15,430 --> 00:06:24,430
bits and that's it so it was quite fast

00:06:20,280 --> 00:06:26,200
okay so in fact we have kind of only

00:06:24,430 --> 00:06:30,850
very little assembly stuff in our

00:06:26,200 --> 00:06:32,900
project because most of it is written in

00:06:30,850 --> 00:06:35,500
C so this is kind of

00:06:32,900 --> 00:06:38,449
beginning like the in the linux kernel

00:06:35,500 --> 00:06:40,850
when it starts there is also kind of

00:06:38,449 --> 00:06:44,440
glue assembly so it's a tough

00:06:40,850 --> 00:06:46,729
environment so it's kind of saying but

00:06:44,440 --> 00:06:49,729
here is our first problem

00:06:46,729 --> 00:06:52,580
so maybe we want to set up also the

00:06:49,729 --> 00:06:56,449
stack and you know when you start the

00:06:52,580 --> 00:06:58,250
computer you have no memory so we need

00:06:56,449 --> 00:07:01,699
for us somehow to cope with the fact

00:06:58,250 --> 00:07:04,880
that we need to we want to run the see

00:07:01,699 --> 00:07:06,949
and we don't have any stack without the

00:07:04,880 --> 00:07:10,910
stack you cannot use the local variables

00:07:06,949 --> 00:07:13,100
you cannot use the read write global

00:07:10,910 --> 00:07:16,820
variables because you are executing code

00:07:13,100 --> 00:07:18,800
from memory where you cannot write it

00:07:16,820 --> 00:07:22,310
there so you cannot do the instructions

00:07:18,800 --> 00:07:25,970
like push pop return you cannot do

00:07:22,310 --> 00:07:28,400
anything of this so basically how we

00:07:25,970 --> 00:07:31,430
solve it there are two possibilities one

00:07:28,400 --> 00:07:34,580
is to use special compiler which is

00:07:31,430 --> 00:07:37,940
called ROM CC this was written like that

00:07:34,580 --> 00:07:41,330
ten years ago by Eric Peterman it's a C

00:07:37,940 --> 00:07:45,110
compiler written in one C file it's very

00:07:41,330 --> 00:07:48,080
ugly very big quite bloated but it has a

00:07:45,110 --> 00:07:52,099
very special thing it uses only CPU

00:07:48,080 --> 00:07:55,610
registers instead of the RAM so the

00:07:52,099 --> 00:07:59,810
local variables in C codes are just

00:07:55,610 --> 00:08:03,199
stored in the registers so of course it

00:07:59,810 --> 00:08:06,260
means you have only 128 bytes of a

00:08:03,199 --> 00:08:08,780
variable space but you need to live with

00:08:06,260 --> 00:08:12,110
that okay or the second possibility

00:08:08,780 --> 00:08:16,550
which is used on the modern cpus is the

00:08:12,110 --> 00:08:20,240
cache SRAM it's a neat trick you can you

00:08:16,550 --> 00:08:22,760
can load the cache which will became

00:08:20,240 --> 00:08:26,270
valid with the garbage data from memory

00:08:22,760 --> 00:08:29,270
and and you can you can use it because

00:08:26,270 --> 00:08:32,060
if you don't evict any cache lines then

00:08:29,270 --> 00:08:35,779
it is a ram so it's like write back

00:08:32,060 --> 00:08:37,969
cache which never reads reaches a ram so

00:08:35,779 --> 00:08:42,540
that's basically a trick how to do that

00:08:37,969 --> 00:08:46,200
so let's see we are now in C and happy

00:08:42,540 --> 00:08:48,150
so first C code is executed in file

00:08:46,200 --> 00:08:52,590
which is called our own star on stage

00:08:48,150 --> 00:08:57,480
dot C this file is kind of main main

00:08:52,590 --> 00:09:00,660
function which gets started in the in

00:08:57,480 --> 00:09:03,300
the sea environment this in this file

00:09:00,660 --> 00:09:07,590
there is early initialization of the

00:09:03,300 --> 00:09:09,240
chipset and I will show you what's done

00:09:07,590 --> 00:09:11,280
there basically I think you already

00:09:09,240 --> 00:09:12,990
write that so we need to have access to

00:09:11,280 --> 00:09:16,080
this area line because we want to read

00:09:12,990 --> 00:09:18,510
some debug messages and so on so we need

00:09:16,080 --> 00:09:22,080
to set up the stereo line so it works

00:09:18,510 --> 00:09:24,660
and we can do print case to our screen

00:09:22,080 --> 00:09:27,930
of course we need to do the stuff to

00:09:24,660 --> 00:09:30,270
reach the cellular line so we need to

00:09:27,930 --> 00:09:33,030
set up the LPC bus and hypertransport

00:09:30,270 --> 00:09:35,850
bus and so on in the meanwhile I am not

00:09:33,030 --> 00:09:39,720
expecting that you can see this because

00:09:35,850 --> 00:09:42,590
this hole is quite big but it's an

00:09:39,720 --> 00:09:46,110
invitation to read the code yourself

00:09:42,590 --> 00:09:50,310
basically here is the start is the cache

00:09:46,110 --> 00:09:52,650
SRAM you can see here we need the LPC

00:09:50,310 --> 00:09:55,230
bars here we need the cellular line

00:09:52,650 --> 00:09:59,840
org and here we can print something on

00:09:55,230 --> 00:10:02,430
screen so we can have a look more until

00:09:59,840 --> 00:10:04,080
when I'm done with this lecture then the

00:10:02,430 --> 00:10:06,360
karo Daniel will speak about the flash

00:10:04,080 --> 00:10:09,930
ROM this what this will be about how to

00:10:06,360 --> 00:10:12,240
flash the flash chips on the

00:10:09,930 --> 00:10:16,710
motherboards and then you can come to

00:10:12,240 --> 00:10:18,810
our to our stand at a W building and we

00:10:16,710 --> 00:10:22,160
can have a look there and we can talk

00:10:18,810 --> 00:10:22,160
more of course about this

00:10:22,369 --> 00:10:31,019
okay so I'm in it so in this environment

00:10:26,999 --> 00:10:34,709
we still run without any REM so even if

00:10:31,019 --> 00:10:37,230
I put out over am from the board outside

00:10:34,709 --> 00:10:39,629
it will still boot and show those

00:10:37,230 --> 00:10:44,279
messages because we are using cache as

00:10:39,629 --> 00:10:47,369
RAM and we at the end we just print know

00:10:44,279 --> 00:10:48,779
where I am so we don't continue anywhere

00:10:47,369 --> 00:10:52,230
in fact it would be possible to

00:10:48,779 --> 00:10:56,850
implement some game and so on 6 64

00:10:52,230 --> 00:10:59,519
kilobytes is plenty of RAM so you are

00:10:56,850 --> 00:11:02,339
invited to do so if you if you feel you

00:10:59,519 --> 00:11:05,519
can do it so RAM in it how does it work

00:11:02,339 --> 00:11:09,420
so first we need to get some data from

00:11:05,519 --> 00:11:11,309
the DIMM modules to get this data there

00:11:09,420 --> 00:11:13,769
is another bus which is called I Square

00:11:11,309 --> 00:11:17,639
C it is reachable from something which

00:11:13,769 --> 00:11:21,420
is called sm bus controller and this was

00:11:17,639 --> 00:11:24,899
this this was the green lines around the

00:11:21,420 --> 00:11:28,019
big scheme you need to program the

00:11:24,899 --> 00:11:30,329
chipset it means the Northbridge or CPU

00:11:28,019 --> 00:11:33,299
if the memory controller is in the CPU

00:11:30,329 --> 00:11:36,839
you need to send some jtech commands to

00:11:33,299 --> 00:11:41,129
the m and basically you are done so it

00:11:36,839 --> 00:11:44,429
looks quite easy but it is not so in

00:11:41,129 --> 00:11:49,410
fact it's very complex task especially

00:11:44,429 --> 00:11:52,139
for DDR ddr2 or ddr3 Rams I use the

00:11:49,410 --> 00:11:56,220
slock counts to just count only the code

00:11:52,139 --> 00:12:01,499
without any comment lines so for the AMD

00:11:56,220 --> 00:12:06,089
in DDR it's like 2,000 lines ddr2 4000

00:12:01,499 --> 00:12:08,999
VDI free 8000 lines so it's non-trivial

00:12:06,089 --> 00:12:11,100
problem and for the ddr2 there is

00:12:08,999 --> 00:12:14,129
another problem which is called the

00:12:11,100 --> 00:12:18,149
decrease timing you need to find a

00:12:14,129 --> 00:12:20,339
strobe signal which will assure that the

00:12:18,149 --> 00:12:24,749
right data is read from the memory and

00:12:20,339 --> 00:12:27,149
this timing is this timing is quite

00:12:24,749 --> 00:12:29,399
crucial so it and also it depends on the

00:12:27,149 --> 00:12:30,970
temperature so at the beginning you just

00:12:29,399 --> 00:12:32,920
need to find the

00:12:30,970 --> 00:12:35,830
the right place where it starts to work

00:12:32,920 --> 00:12:36,910
and the place where it doesn't where it

00:12:35,830 --> 00:12:39,850
doesn't work again

00:12:36,910 --> 00:12:42,070
and then you take the half of it so it's

00:12:39,850 --> 00:12:44,860
quite complex and complicated of course

00:12:42,070 --> 00:12:48,130
it's also depending on the PCB layout

00:12:44,860 --> 00:12:51,220
and temperature and such stuff so excuse

00:12:48,130 --> 00:12:54,760
me no good time in 50 minutes for

00:12:51,220 --> 00:12:57,400
this so then the run stage is executed

00:12:54,760 --> 00:12:59,710
so in RAM stage we copied in the car

00:12:57,400 --> 00:13:02,290
boot to the second stage we run from RAM

00:12:59,710 --> 00:13:04,360
in this stage we have to train the PCI

00:13:02,290 --> 00:13:07,060
Express link and do all the resource

00:13:04,360 --> 00:13:10,360
enumeration on the PCI bus like set up

00:13:07,060 --> 00:13:13,000
the i/o ports and such stuff and of

00:13:10,360 --> 00:13:15,430
course prepare also some kind of tables

00:13:13,000 --> 00:13:20,620
which are required by for the operating

00:13:15,430 --> 00:13:23,500
system and of course the a CPI and power

00:13:20,620 --> 00:13:25,300
management and so on so basically a lot

00:13:23,500 --> 00:13:29,020
of stuff still needs to be done after

00:13:25,300 --> 00:13:32,800
the RAM is running okay here is some

00:13:29,020 --> 00:13:36,880
information about the tables so it's

00:13:32,800 --> 00:13:39,160
mostly irq routing tables that means

00:13:36,880 --> 00:13:42,220
that it's depending on the board layout

00:13:39,160 --> 00:13:45,550
you need to know which devices which irq

00:13:42,220 --> 00:13:48,790
line and plus of course the a CPI which

00:13:45,550 --> 00:13:51,460
is very big specification and it

00:13:48,790 --> 00:13:54,970
contains as I have written here

00:13:51,460 --> 00:13:57,160
everything so it's very general a lot of

00:13:54,970 --> 00:14:01,210
stuff is hidden there of course we

00:13:57,160 --> 00:14:05,320
support it in the core boot and last

00:14:01,210 --> 00:14:07,930
thing is to load something it can be

00:14:05,320 --> 00:14:10,480
operating system it can be some game it

00:14:07,930 --> 00:14:13,120
can be very old like a serum like ROM

00:14:10,480 --> 00:14:15,510
basic which I have brought here so you

00:14:13,120 --> 00:14:19,030
can program something in very ancient

00:14:15,510 --> 00:14:20,920
language we use C bias this is a

00:14:19,030 --> 00:14:22,750
compatibility layer between core boot

00:14:20,920 --> 00:14:25,750
and operating system you know this from

00:14:22,750 --> 00:14:29,380
the qmo because when queue emeralds you

00:14:25,750 --> 00:14:33,520
can see it so queue a move is the layer

00:14:29,380 --> 00:14:36,610
in between which which can which is used

00:14:33,520 --> 00:14:39,769
to load the operating system like legacy

00:14:36,610 --> 00:14:44,139
BIOS let's say so that's it

00:14:39,769 --> 00:14:47,809
thanks and please visit us at our at our

00:14:44,139 --> 00:14:50,089
booth I would be glad to to see you

00:14:47,809 --> 00:14:51,679
there and I can explain more stuff in

00:14:50,089 --> 00:14:54,230
detail and tomorrow I will have some

00:14:51,679 --> 00:14:56,779
timing talk at the embedded affluent now

00:14:54,230 --> 00:14:59,239
the next one is Carl Daniel which will

00:14:56,779 --> 00:15:01,459
be speaking about how to flash the flash

00:14:59,239 --> 00:15:04,899
chips on the motherboard so thank you

00:15:01,459 --> 00:15:04,899
again that's it

00:15:14,060 --> 00:15:16,120

YouTube URL: https://www.youtube.com/watch?v=xc08SN6Dhz4


