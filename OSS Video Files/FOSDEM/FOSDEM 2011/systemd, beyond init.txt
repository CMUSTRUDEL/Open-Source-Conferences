Title: systemd, beyond init
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	by Lennart Poettering 

systemd is a system and session manager for Linux, compatible with SysV and LSB init scripts. systemd provides aggressive parallelization capabilities, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux cgroups, supports snapshotting and restoring of the system state, maintains mount and automount points and implements an elaborate transactional dependency-based service control logic.

Wow, what a paragraph! In case I lost you half-way: in our presentation I hope to explain in a lot more detail what systemd is really about, and parse with you the paragraph in a way that is hopefully more understandable.

Both the Fedora and OpenSUSE distributions (and many others, too) are working on making systemd the default init system in their next releases. Since the init system is a core part of the operating system and systemd a major change that will impact what we consider a Linux system quite a bit this talk should be interesting to all developers, administrators and users alike.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:06,799 --> 00:00:09,919
and now

00:00:11,480 --> 00:00:20,369
good work okay wonderful so yeah I will

00:00:17,099 --> 00:00:23,310
be talking about system B today by the

00:00:20,369 --> 00:00:25,649
way I prefer my talks more of the

00:00:23,310 --> 00:00:27,000
interactive time so meaning that that if

00:00:25,649 --> 00:00:28,470
you have a question just go and

00:00:27,000 --> 00:00:31,110
interrupt me I much prefer that over

00:00:28,470 --> 00:00:34,710
questions at the end so that all the

00:00:31,110 --> 00:00:37,050
questions we can have are right on the

00:00:34,710 --> 00:00:39,510
topic that we're discussing and I would

00:00:37,050 --> 00:00:41,250
also much prefer if you guys can it

00:00:39,510 --> 00:00:43,890
would lead the the talk into the right

00:00:41,250 --> 00:00:45,480
directions by your questions instead of

00:00:43,890 --> 00:00:50,579
just me picking a couple of things that

00:00:45,480 --> 00:00:52,170
I like to to speak about so yeah I will

00:00:50,579 --> 00:00:54,360
I have a couple of lines prepared here I

00:00:52,170 --> 00:00:56,190
will start with an introduction to

00:00:54,360 --> 00:00:58,140
system deed and then hopefully based on

00:00:56,190 --> 00:01:03,870
your questions we can touch particular

00:00:58,140 --> 00:01:07,320
areas in more detail so let's jump right

00:01:03,870 --> 00:01:09,479
in this slide contains the original

00:01:07,320 --> 00:01:12,420
description of system D from the system

00:01:09,479 --> 00:01:14,450
D website it's a long long paragraph

00:01:12,420 --> 00:01:17,549
this is the first half sentence of it

00:01:14,450 --> 00:01:19,490
it's it's a paragraph with a lot of

00:01:17,549 --> 00:01:21,689
information on very very little room

00:01:19,490 --> 00:01:23,490
it's not necessarily easy to understand

00:01:21,689 --> 00:01:25,590
and that's why we're hopefully going to

00:01:23,490 --> 00:01:28,380
parse a little bit and so that everybody

00:01:25,590 --> 00:01:29,939
understands what is meant by this so the

00:01:28,380 --> 00:01:32,759
first half cents in sentence reads

00:01:29,939 --> 00:01:35,340
system D is a system and SAS manager for

00:01:32,759 --> 00:01:37,409
Linux so what does that mean assistant

00:01:35,340 --> 00:01:39,179
manager probably everybody might have an

00:01:37,409 --> 00:01:41,880
idea the system is like this operating

00:01:39,179 --> 00:01:44,819
system thing and it's just a manager

00:01:41,880 --> 00:01:46,499
that what we mean by that is is that

00:01:44,819 --> 00:01:48,179
it's an init system that it manages the

00:01:46,499 --> 00:01:50,399
system that it manages the components of

00:01:48,179 --> 00:01:52,950
the system meaning that it controls a

00:01:50,399 --> 00:01:54,200
little bit and what processes are being

00:01:52,950 --> 00:01:56,189
run based on a couple of things

00:01:54,200 --> 00:01:58,049
assertion manager on the other hand is

00:01:56,189 --> 00:01:59,880
the term session manager is probably

00:01:58,049 --> 00:02:01,259
known to too many people like you know

00:01:59,880 --> 00:02:03,450
obsession is a session managing KD

00:02:01,259 --> 00:02:08,069
session is a session manager and system

00:02:03,450 --> 00:02:10,200
D also manages the session so basically

00:02:08,069 --> 00:02:12,540
it's a replacement in some ways or it

00:02:10,200 --> 00:02:17,310
can be be used to augment your obsession

00:02:12,540 --> 00:02:19,650
or KDE session for Linux let's go on

00:02:17,310 --> 00:02:22,810
it's compatible with system 5 and LSP

00:02:19,650 --> 00:02:24,580
unit scripts - system 5 and a lesbian

00:02:22,810 --> 00:02:26,080
scripts probably everybody has known as

00:02:24,580 --> 00:02:27,910
least if you ever came in contact in

00:02:26,080 --> 00:02:29,410
closer contact with the Linux system you

00:02:27,910 --> 00:02:31,660
probably have played around with some

00:02:29,410 --> 00:02:33,340
system five-minute scripts they are

00:02:31,660 --> 00:02:35,590
basically these things et Cie entity

00:02:33,340 --> 00:02:38,380
some service start and stop you can

00:02:35,590 --> 00:02:40,239
start we're compatible with that when in

00:02:38,380 --> 00:02:42,819
a system that that tries to stay

00:02:40,239 --> 00:02:45,400
compatible with existing system five for

00:02:42,819 --> 00:02:47,190
LSB inner scripts and SVN system five is

00:02:45,400 --> 00:02:49,630
basically the same thing in this context

00:02:47,190 --> 00:02:52,989
basically system five introduced the

00:02:49,630 --> 00:02:54,760
original contact ideas and then alice be

00:02:52,989 --> 00:02:57,549
standardized around this a little bit

00:02:54,760 --> 00:02:59,769
and extended the original system fastest

00:02:57,549 --> 00:03:01,090
occasions like standardizing exit codes

00:02:59,769 --> 00:03:02,709
of those inner scripts and then

00:03:01,090 --> 00:03:04,690
standardizing the verbs that you can

00:03:02,709 --> 00:03:05,890
past it and standardizing comment and a

00:03:04,690 --> 00:03:09,459
couple of other things but it's mostly

00:03:05,890 --> 00:03:12,370
synonymous system lee provides

00:03:09,459 --> 00:03:15,040
aggressive paralyzation capabilities a

00:03:12,370 --> 00:03:17,290
parallelization probably many have a

00:03:15,040 --> 00:03:19,269
quite an idea what that is and what that

00:03:17,290 --> 00:03:22,630
means in a system and in init system

00:03:19,269 --> 00:03:24,040
context it's probably not so difficult

00:03:22,630 --> 00:03:25,299
to understand either basically just

00:03:24,040 --> 00:03:28,390
means we start everything that we

00:03:25,299 --> 00:03:30,190
started parallel but it's the word

00:03:28,390 --> 00:03:31,930
aggressive here i means that it's

00:03:30,190 --> 00:03:35,560
probably a little bit beyond what

00:03:31,930 --> 00:03:37,359
existing in the systems do and in a

00:03:35,560 --> 00:03:40,690
later slide we'll go a little bit into

00:03:37,359 --> 00:03:44,530
detail on what precisely this kind of

00:03:40,690 --> 00:03:46,150
aggressive parallelization means if you

00:03:44,530 --> 00:03:47,680
just socket and debase activation for

00:03:46,150 --> 00:03:50,530
starting services that's probably one of

00:03:47,680 --> 00:03:53,500
one party of this paragraph that is only

00:03:50,530 --> 00:03:55,859
understandable after you I had to look

00:03:53,500 --> 00:03:59,350
on the on the further slides we have

00:03:55,859 --> 00:04:03,160
basically means that that we can start

00:03:59,350 --> 00:04:05,650
services if something happens on us on a

00:04:03,160 --> 00:04:07,660
network socket or if something happens

00:04:05,650 --> 00:04:11,530
because somebody required to D bus

00:04:07,660 --> 00:04:14,230
service or something like that so a how

00:04:11,530 --> 00:04:15,430
why this is so very useful and it's so

00:04:14,230 --> 00:04:17,350
interesting that we put it on this

00:04:15,430 --> 00:04:21,459
initial paragraph we'll see a little bit

00:04:17,350 --> 00:04:23,740
lighter but yeah it offers on-demand

00:04:21,459 --> 00:04:25,539
starting of demons I figure most people

00:04:23,740 --> 00:04:28,030
will also get kind of an idea what that

00:04:25,539 --> 00:04:29,650
could mean could mean for example that

00:04:28,030 --> 00:04:31,810
we started them in the moment we use it

00:04:29,650 --> 00:04:34,479
for example if we have a damn unlikely

00:04:31,810 --> 00:04:35,580
tooth which is responsible for

00:04:34,479 --> 00:04:37,770
maintaining the looters

00:04:35,580 --> 00:04:39,690
we're but we then start the the the

00:04:37,770 --> 00:04:42,060
diamond only if the Bluetooth hardware's

00:04:39,690 --> 00:04:43,350
actually plugged in but this is actually

00:04:42,060 --> 00:04:46,380
very generic it could mean a lot of

00:04:43,350 --> 00:04:47,760
other things that if some service

00:04:46,380 --> 00:04:48,810
requires another service that we start

00:04:47,760 --> 00:04:51,020
the service right the moment we actually

00:04:48,810 --> 00:04:53,520
need it it's an interesting feature

00:04:51,020 --> 00:04:55,070
because you do less work but it's not

00:04:53,520 --> 00:04:57,690
the core feature

00:04:55,070 --> 00:05:00,660
it keeps tracks of processes using Leong

00:04:57,690 --> 00:05:02,400
cgroups processes probably I hope that

00:05:00,660 --> 00:05:06,150
everybody knows what a year in process

00:05:02,400 --> 00:05:08,040
on Linux is but once this mean keeps

00:05:06,150 --> 00:05:11,160
track of it using Linux cgroups

00:05:08,040 --> 00:05:13,320
Linux cgroups is a new kernel interface

00:05:11,160 --> 00:05:16,440
that has been introduced that and a-five

00:05:13,320 --> 00:05:19,620
know ten versions ago cgroups

00:05:16,440 --> 00:05:22,080
this is short for control groups and

00:05:19,620 --> 00:05:24,360
what that really precisely means I have

00:05:22,080 --> 00:05:25,980
a couple of slides about this later but

00:05:24,360 --> 00:05:29,310
this is actually very very useful to to

00:05:25,980 --> 00:05:31,950
to not only start and stop services but

00:05:29,310 --> 00:05:33,960
also keep precise track about everything

00:05:31,950 --> 00:05:35,910
every process that a service response

00:05:33,960 --> 00:05:38,700
and it can be quite a lot for example if

00:05:35,910 --> 00:05:41,040
the Apache starts up it can can start a

00:05:38,700 --> 00:05:43,290
gazillion of CGI scripts and whatnot and

00:05:41,040 --> 00:05:45,480
yeah we use a Linux II groups to keep

00:05:43,290 --> 00:05:46,740
track of them again a little bit more

00:05:45,480 --> 00:05:49,170
detail about that later on

00:05:46,740 --> 00:05:51,750
it supports snapshotting and restoring

00:05:49,170 --> 00:05:54,180
us a system state snapshotting probably

00:05:51,750 --> 00:05:56,340
people know from context of databases of

00:05:54,180 --> 00:05:57,810
Frank Foose stuff like that it basically

00:05:56,340 --> 00:06:00,450
means that you take a snapshot of the

00:05:57,810 --> 00:06:03,240
system like it is you store it away and

00:06:00,450 --> 00:06:05,160
later on you can return to it system be

00:06:03,240 --> 00:06:06,270
support set so um you can can say okay

00:06:05,160 --> 00:06:07,680
I've started this service and that

00:06:06,270 --> 00:06:09,330
service and that servant that service

00:06:07,680 --> 00:06:11,250
but I don't have started that and then

00:06:09,330 --> 00:06:14,370
then that then you say you save that

00:06:11,250 --> 00:06:16,620
state later on you return to it this is

00:06:14,370 --> 00:06:18,930
for example I'm useful for quite a few

00:06:16,620 --> 00:06:20,820
things like you you're administrating

00:06:18,930 --> 00:06:22,320
your machine you have Apache start and

00:06:20,820 --> 00:06:24,390
everything else now you say oh my god I

00:06:22,320 --> 00:06:25,800
need to administrate something and I

00:06:24,390 --> 00:06:28,590
meet only make sure that nobody and

00:06:25,800 --> 00:06:30,540
nothing does anything to the system at

00:06:28,590 --> 00:06:32,520
this time so you change to a single user

00:06:30,540 --> 00:06:33,630
mode you do you change this you can be

00:06:32,520 --> 00:06:35,760
sure that nobody interferes with you

00:06:33,630 --> 00:06:37,590
because you are the only one and then we

00:06:35,760 --> 00:06:41,560
talk to the we return to the original

00:06:37,590 --> 00:06:44,000
state again as if nothing happened

00:06:41,560 --> 00:06:46,370
at montains Mountain Altamont points

00:06:44,000 --> 00:06:48,460
this is probably something surprising to

00:06:46,370 --> 00:06:50,780
many people because in a system so far

00:06:48,460 --> 00:06:53,300
didn't really do mountain that amount

00:06:50,780 --> 00:06:55,520
handling mount points probably everybody

00:06:53,300 --> 00:06:57,229
who ever dealt with UNIX has an idea

00:06:55,520 --> 00:06:59,840
what it is auto mounting not necessarily

00:06:57,229 --> 00:07:02,270
automating is a lot like normal mounting

00:06:59,840 --> 00:07:04,220
except that instead of actually mounting

00:07:02,270 --> 00:07:07,009
a file system to some place you just

00:07:04,220 --> 00:07:10,280
mount an automat to it which is

00:07:07,009 --> 00:07:12,050
something like a magic thing that just

00:07:10,280 --> 00:07:13,639
stays there at the moment somebody for

00:07:12,050 --> 00:07:16,430
the first time access that it is backed

00:07:13,639 --> 00:07:18,650
by the real file system in system v

00:07:16,430 --> 00:07:21,520
we'll use that to paralyze boot up and

00:07:18,650 --> 00:07:23,840
if we also use it to to to delay boot up

00:07:21,520 --> 00:07:24,979
certain jobs during boot up so that we

00:07:23,840 --> 00:07:27,440
don't have to do them right away during

00:07:24,979 --> 00:07:31,970
boot but only when they actually need it

00:07:27,440 --> 00:07:33,860
is are speeding up the boot up it

00:07:31,970 --> 00:07:35,300
implements an elaborate transactional

00:07:33,860 --> 00:07:38,440
dependency based service control logic

00:07:35,300 --> 00:07:40,310
that was quite a half sentence there

00:07:38,440 --> 00:07:42,320
transactional probably everybody heard

00:07:40,310 --> 00:07:44,810
in the context of databases like you

00:07:42,320 --> 00:07:47,300
have something where where a couple of

00:07:44,810 --> 00:07:48,949
operations you you you you bind them

00:07:47,300 --> 00:07:51,080
together call them transaction and you

00:07:48,949 --> 00:07:52,760
either execute them or you don't execute

00:07:51,080 --> 00:07:54,919
them but you do not have execute them

00:07:52,760 --> 00:07:57,349
and assistant Lee we have a very weak

00:07:54,919 --> 00:07:58,940
definition of transaction but we have

00:07:57,349 --> 00:08:00,919
one in there basically that means if if

00:07:58,940 --> 00:08:03,020
you if you if you start Apache and that

00:08:00,919 --> 00:08:05,090
pulls in MySQL then either you end up

00:08:03,020 --> 00:08:07,669
with both oh yeah I end up with nothing

00:08:05,090 --> 00:08:11,590
but you do not end up with Apache have

00:08:07,669 --> 00:08:14,659
started in mice ql half said as well

00:08:11,590 --> 00:08:15,889
dependency based basically means i mean

00:08:14,659 --> 00:08:18,080
probably everybody heard that of the

00:08:15,889 --> 00:08:20,240
context of package managers you install

00:08:18,080 --> 00:08:21,740
you install the MySQL client and pulls

00:08:20,240 --> 00:08:23,180
up the MySQL server or the other way

00:08:21,740 --> 00:08:24,590
around something like that we have the

00:08:23,180 --> 00:08:27,710
same thing in then in system D that you

00:08:24,590 --> 00:08:30,409
can say well diva's requires this lock

00:08:27,710 --> 00:08:32,060
so says lock is pulled in by Debus and

00:08:30,409 --> 00:08:34,039
service control logic basically means

00:08:32,060 --> 00:08:36,440
yeah you can control the logic yeah you

00:08:34,039 --> 00:08:39,229
can control the service with system be

00:08:36,440 --> 00:08:40,789
surprised surprised it can work as a

00:08:39,229 --> 00:08:42,950
drop-in replacement for system five in

00:08:40,789 --> 00:08:45,829
system five-minute everybody knows is I

00:08:42,950 --> 00:08:48,020
hope so is a classic implementation of

00:08:45,829 --> 00:08:50,770
an inner system for Linux it has been

00:08:48,020 --> 00:08:53,620
used by almost all distributions

00:08:50,770 --> 00:08:55,270
historically very recently a couple of

00:08:53,620 --> 00:08:56,710
distributions and change due to an

00:08:55,270 --> 00:09:00,310
alternative implementation called app

00:08:56,710 --> 00:09:04,420
start we're not going to talk too much

00:09:00,310 --> 00:09:06,670
about app start here but yeah so this is

00:09:04,420 --> 00:09:08,770
this is the original paragraph left on

00:09:06,670 --> 00:09:10,870
the website it's quite a lot of

00:09:08,770 --> 00:09:13,060
information for very little text but I

00:09:10,870 --> 00:09:15,550
hope everybody has a gruff idea what it

00:09:13,060 --> 00:09:16,780
actually might be so on the next slides

00:09:15,550 --> 00:09:19,360
we're going to end a couple of top of

00:09:16,780 --> 00:09:22,090
these topics mention here into a little

00:09:19,360 --> 00:09:25,630
bit more detail so let's start a little

00:09:22,090 --> 00:09:27,820
bit about but in it in it as I kind of

00:09:25,630 --> 00:09:30,070
mentioned already is is a special

00:09:27,820 --> 00:09:32,020
process it's it is first process that I

00:09:30,070 --> 00:09:34,690
started after the kernel is booted up

00:09:32,020 --> 00:09:38,860
it's it's the init system it's it's per

00:09:34,690 --> 00:09:40,570
PID 1 and it has magic capabilities

00:09:38,860 --> 00:09:42,700
systemd installs itself as one

00:09:40,570 --> 00:09:44,800
implementation for this magic process

00:09:42,700 --> 00:09:47,020
number one it's magic for for a couple

00:09:44,800 --> 00:09:49,630
of reasons its magic for example because

00:09:47,020 --> 00:09:51,520
if you press control alt delete this

00:09:49,630 --> 00:09:54,400
gets forwarded as a special request to

00:09:51,520 --> 00:09:58,420
period number one if if a process dies

00:09:54,400 --> 00:10:00,670
and and then all its children will be

00:09:58,420 --> 00:10:03,070
reparent it to this magic process number

00:10:00,670 --> 00:10:04,510
one and every single process that it's

00:10:03,070 --> 00:10:07,750
not a process to something else is

00:10:04,510 --> 00:10:10,180
automatically a child of this magic

00:10:07,750 --> 00:10:12,970
process for this reason it has a couple

00:10:10,180 --> 00:10:15,190
of additional over em requirement that

00:10:12,970 --> 00:10:17,140
the cochlea ditional constraints that it

00:10:15,190 --> 00:10:20,860
needs to implement because basically the

00:10:17,140 --> 00:10:23,830
entire user space depends on this to be

00:10:20,860 --> 00:10:27,400
to be running and to be be controlling

00:10:23,830 --> 00:10:28,780
everything so yeah as mentioned there's

00:10:27,400 --> 00:10:30,640
a couple of implementations it around

00:10:28,780 --> 00:10:34,600
the big ones are system five-minute and

00:10:30,640 --> 00:10:35,710
app start and now system deep I'm I like

00:10:34,600 --> 00:10:39,660
to believe that system DS the most

00:10:35,710 --> 00:10:39,660
advanced of those three

00:10:39,680 --> 00:10:44,160
so by the way if anybody has any

00:10:41,820 --> 00:10:45,510
questions to all of this just ask raise

00:10:44,160 --> 00:10:47,070
your hand and there's some people here

00:10:45,510 --> 00:10:48,120
with microphones who'll they give your

00:10:47,070 --> 00:10:50,250
microphone if anybody has a question

00:10:48,120 --> 00:10:52,680
awesome

00:10:50,250 --> 00:10:55,740
the next type of topic wheel will touch

00:10:52,680 --> 00:10:58,670
is parallelization paralyzation is one

00:10:55,740 --> 00:11:00,840
of the key things that systemd is about

00:10:58,670 --> 00:11:02,520
yeah as mentioned probably everybody has

00:11:00,840 --> 00:11:03,900
a rough idea what that means it means if

00:11:02,520 --> 00:11:06,120
you if you boot up your machine and you

00:11:03,900 --> 00:11:07,920
start a couple of services depending on

00:11:06,120 --> 00:11:09,810
what you're running it might be added or

00:11:07,920 --> 00:11:11,460
up to fifty services as though that we

00:11:09,810 --> 00:11:14,130
start them as much as possible at

00:11:11,460 --> 00:11:17,720
parallel so that that whenever CPU has

00:11:14,130 --> 00:11:17,720
nothing to do it can do something else

00:11:17,810 --> 00:11:24,420
we have this wonderful graph via graphic

00:11:21,090 --> 00:11:27,450
here which tries to explain the the way

00:11:24,420 --> 00:11:29,880
that systemd implements parallelization

00:11:27,450 --> 00:11:31,380
and how traditionally paralyzation was

00:11:29,880 --> 00:11:33,690
implemented or was not at all

00:11:31,380 --> 00:11:35,540
implemented to the left we have this

00:11:33,690 --> 00:11:37,950
traditional system five paralyzation

00:11:35,540 --> 00:11:41,130
it's it's basically how most of the

00:11:37,950 --> 00:11:44,040
distributions five years ago worked and

00:11:41,130 --> 00:11:48,560
actually a fedora until Fedora 14 still

00:11:44,040 --> 00:11:53,040
works this shows you basically the order

00:11:48,560 --> 00:11:55,290
in which for services do we just pick

00:11:53,040 --> 00:11:57,470
for service photographic here I started

00:11:55,290 --> 00:11:59,880
this Lochte busalacchi in bluetooth

00:11:57,470 --> 00:12:01,950
there couple of dependencies here

00:11:59,880 --> 00:12:04,080
between these services and which is why

00:12:01,950 --> 00:12:06,570
this order is the one that is actually

00:12:04,080 --> 00:12:07,830
used here debase you the syslog so divas

00:12:06,570 --> 00:12:10,410
has started second and this locket

00:12:07,830 --> 00:12:12,270
started first avahi uses divas answers

00:12:10,410 --> 00:12:14,940
log so it's not after after those two

00:12:12,270 --> 00:12:17,100
bluetooth also uses luck and d-bus and

00:12:14,940 --> 00:12:18,690
started after this to Blue Jays in

00:12:17,100 --> 00:12:20,190
Hawaii however they don't have any

00:12:18,690 --> 00:12:22,790
dependency bluetooth does not use

00:12:20,190 --> 00:12:25,350
Avakian avahi does not use bluetooth so

00:12:22,790 --> 00:12:28,050
however since traditional system five

00:12:25,350 --> 00:12:30,270
boot ups like like like um Fedora

00:12:28,050 --> 00:12:30,990
implemented the mantle 14 wear strictly

00:12:30,270 --> 00:12:33,420
serialized

00:12:30,990 --> 00:12:35,160
this meant that still we had to pick an

00:12:33,420 --> 00:12:36,960
order we had to just add one first and

00:12:35,160 --> 00:12:38,220
the other one second in this case we

00:12:36,960 --> 00:12:40,020
just picked the alphabetical order

00:12:38,220 --> 00:12:41,670
because we didn't know anything any

00:12:40,020 --> 00:12:42,720
other thing to do of course it could

00:12:41,670 --> 00:12:43,740
could could have pins down at the other

00:12:42,720 --> 00:12:47,130
way around there would not have been a

00:12:43,740 --> 00:12:48,420
problem now a couple of people looked at

00:12:47,130 --> 00:12:50,370
this and said oh my god

00:12:48,420 --> 00:12:50,950
yeah well the ordering between syslog

00:12:50,370 --> 00:12:52,990
d-bus and

00:12:50,950 --> 00:12:54,610
we can't do much about and the one about

00:12:52,990 --> 00:12:57,670
between syslog divas and looters neither

00:12:54,610 --> 00:12:59,080
but we could do something about the

00:12:57,670 --> 00:13:00,910
ordering between overhang losers because

00:12:59,080 --> 00:13:02,920
it can be started parallel we should

00:13:00,910 --> 00:13:05,560
start parallel and then people came up

00:13:02,920 --> 00:13:08,020
with this the middle kind of

00:13:05,560 --> 00:13:10,330
paralyzation just like a diva's I still

00:13:08,020 --> 00:13:11,890
started one after the other and of our

00:13:10,330 --> 00:13:13,480
team Plutus I started afterwards but

00:13:11,890 --> 00:13:15,430
I've on him Plutus I start at the same

00:13:13,480 --> 00:13:17,860
time this is the traditional

00:13:15,430 --> 00:13:20,170
paralyzation how upset works and how

00:13:17,860 --> 00:13:23,140
sues the update at the classic system

00:13:20,170 --> 00:13:26,530
five boot process it's an improvement I

00:13:23,140 --> 00:13:27,880
mean if you look if you look the arrows

00:13:26,530 --> 00:13:29,680
all together basically should give you

00:13:27,880 --> 00:13:31,540
an idea how long this takes to bring up

00:13:29,680 --> 00:13:33,400
all those four silences and you notice

00:13:31,540 --> 00:13:36,070
that the traditional system five took

00:13:33,400 --> 00:13:37,980
like four arrows and this one just takes

00:13:36,070 --> 00:13:41,830
three so it's a little bit faster but

00:13:37,980 --> 00:13:43,030
it's not as good as we do it in system

00:13:41,830 --> 00:13:45,060
people because it says simply we

00:13:43,030 --> 00:13:47,800
actually start all four of them

00:13:45,060 --> 00:13:49,750
completely in parallel and that's kind

00:13:47,800 --> 00:13:51,250
of surprising I mean how can we do this

00:13:49,750 --> 00:13:53,380
because they are there there is still a

00:13:51,250 --> 00:13:55,990
dependency between syslog and divas and

00:13:53,380 --> 00:13:57,490
between avahi d-bus how do we actually

00:13:55,990 --> 00:13:59,700
pull it off that we can actually start

00:13:57,490 --> 00:14:01,720
to completely in parallel and this is a

00:13:59,700 --> 00:14:03,970
technology called socket based

00:14:01,720 --> 00:14:07,510
activation it's something that that

00:14:03,970 --> 00:14:09,730
Apple pioneered in in launch deep which

00:14:07,510 --> 00:14:14,170
is in the core part of the Mac OS

00:14:09,730 --> 00:14:15,850
operating system it they basically

00:14:14,170 --> 00:14:18,730
looked at these kinds of boot up graph

00:14:15,850 --> 00:14:21,790
and thought hmm so if we look at all of

00:14:18,730 --> 00:14:24,070
this year why precisely is it actually

00:14:21,790 --> 00:14:27,790
that avahi has to wait for DBS in syslog

00:14:24,070 --> 00:14:29,590
what is the one thing that avahi waits

00:14:27,790 --> 00:14:31,540
for what is the one thing the Daevas

00:14:29,590 --> 00:14:32,830
waits for for in in syslog and they

00:14:31,540 --> 00:14:34,810
looked at that and look in all detail

00:14:32,830 --> 00:14:37,000
and that they noticed it's about this

00:14:34,810 --> 00:14:38,830
socket it's about the sockets that are

00:14:37,000 --> 00:14:41,440
created if this sauce is this just lock

00:14:38,830 --> 00:14:43,720
socket dev slash log that is created

00:14:41,440 --> 00:14:45,310
that is bound to by syslog that d-bus

00:14:43,720 --> 00:14:47,350
waits for before DBS can start up

00:14:45,310 --> 00:14:49,750
because d-bus wants to connected to that

00:14:47,350 --> 00:14:51,370
socket and rides right Methodist to it

00:14:49,750 --> 00:14:53,200
and then they looked on the other

00:14:51,370 --> 00:14:54,610
dependencies and said okay yeah so why

00:14:53,200 --> 00:14:56,800
exactly is it that I've ah he has to

00:14:54,610 --> 00:14:58,930
wait for divas and again it's about of

00:14:56,800 --> 00:15:00,640
sockets now he wants to connect to the

00:14:58,930 --> 00:15:03,790
diva system socket set socket called

00:15:00,640 --> 00:15:04,810
slash var slash run / diva / system and

00:15:03,790 --> 00:15:06,370
a socket

00:15:04,810 --> 00:15:08,770
and they looked at that and said well if

00:15:06,370 --> 00:15:10,930
it's really just about the sockets can't

00:15:08,770 --> 00:15:13,030
we somehow do something about that so

00:15:10,930 --> 00:15:14,860
that we can think start sing soprano if

00:15:13,030 --> 00:15:16,480
this if the socket is really everything

00:15:14,860 --> 00:15:19,090
that is waited for wouldn't it be

00:15:16,480 --> 00:15:20,410
possible to somehow speed that up and

00:15:19,090 --> 00:15:22,930
then they came to a solution and

00:15:20,410 --> 00:15:25,840
suggested in the solution they came to

00:15:22,930 --> 00:15:28,720
is that they pull out the actual socket

00:15:25,840 --> 00:15:30,700
binding out of the damn ins do them in

00:15:28,720 --> 00:15:32,590
one big step in the unit system itself

00:15:30,700 --> 00:15:35,140
and then there's passed these sockets

00:15:32,590 --> 00:15:37,240
pre initialized pre bound to the actual

00:15:35,140 --> 00:15:38,860
services and that's what they did with

00:15:37,240 --> 00:15:40,960
this lock I mean that they don't use

00:15:38,860 --> 00:15:42,280
diva's actually a number Macker but they

00:15:40,960 --> 00:15:44,170
have couple of other services that work

00:15:42,280 --> 00:15:45,730
like that and then they they pulled out

00:15:44,170 --> 00:15:49,150
the socket binding out of that did that

00:15:45,730 --> 00:15:52,180
in launch D so in one big step all the

00:15:49,150 --> 00:15:54,430
sockets that all the services be safe

00:15:52,180 --> 00:15:56,620
unix sockets RFI net sockets or whatever

00:15:54,430 --> 00:15:57,970
they're all created in one big step and

00:15:56,620 --> 00:16:00,520
then in it tighten a loop that gets

00:15:57,970 --> 00:16:03,010
really really fast and then they start

00:16:00,520 --> 00:16:04,360
every single service that is that is

00:16:03,010 --> 00:16:07,180
they're supposed to be started at the

00:16:04,360 --> 00:16:09,010
same time and this services get the past

00:16:07,180 --> 00:16:12,850
the socket they should be listening on

00:16:09,010 --> 00:16:14,170
i'm later on and this is actually really

00:16:12,850 --> 00:16:15,730
nice because some you can start

00:16:14,170 --> 00:16:17,050
everything in parallel because the

00:16:15,730 --> 00:16:19,270
sockets already established

00:16:17,050 --> 00:16:20,140
so if divas wants to connect a syslog it

00:16:19,270 --> 00:16:22,690
doesn't have to wait for anything

00:16:20,140 --> 00:16:24,790
because the listening was already done

00:16:22,690 --> 00:16:27,750
before since lock was even started

00:16:24,790 --> 00:16:27,750
there's a question

00:16:28,010 --> 00:16:33,370
[Music]

00:16:30,650 --> 00:16:33,370
thank for that

00:16:33,600 --> 00:16:37,560
by the way I know that I speak very very

00:16:35,399 --> 00:16:39,769
fast I'm sorry for that if I speak too

00:16:37,560 --> 00:16:43,680
fast say something I'll try to slow down

00:16:39,769 --> 00:16:45,509
hi this soccerbase activation seems to

00:16:43,680 --> 00:16:48,630
lend itself very well also to work

00:16:45,509 --> 00:16:50,639
across the network but from what I

00:16:48,630 --> 00:16:53,339
understand you rely on the kernel to

00:16:50,639 --> 00:16:56,550
kind of resolve the dependencies so you

00:16:53,339 --> 00:16:58,769
know by queueing won't that break if for

00:16:56,550 --> 00:17:01,230
instance one of the servers in your

00:16:58,769 --> 00:17:03,870
cluster hasn't been booted properly yet

00:17:01,230 --> 00:17:05,400
or you know if there's will the

00:17:03,870 --> 00:17:09,660
dependency resolutions to work properly

00:17:05,400 --> 00:17:12,030
in those cases so the focus of this kind

00:17:09,660 --> 00:17:14,160
of socket activation for us is mostly AF

00:17:12,030 --> 00:17:16,110
Unix actually it's not so much a finer

00:17:14,160 --> 00:17:18,089
so it's a little bit different from the

00:17:16,110 --> 00:17:19,679
traditional I nerd stuff which I nerdy

00:17:18,089 --> 00:17:21,990
stuff which focus on I know internet

00:17:19,679 --> 00:17:25,110
sockets we also cover ainít sockets and

00:17:21,990 --> 00:17:27,270
in the case of cluster stuff where you

00:17:25,110 --> 00:17:28,620
have an actual network Shinx become you

00:17:27,270 --> 00:17:30,480
probably need to do to program your

00:17:28,620 --> 00:17:32,070
stuff more defensively anyway so you

00:17:30,480 --> 00:17:34,650
probably need to trick kind of continue

00:17:32,070 --> 00:17:36,840
trying to make the connections generally

00:17:34,650 --> 00:17:38,429
on the local case the dependency if you

00:17:36,840 --> 00:17:40,409
have cyclic dependency issue whatever

00:17:38,429 --> 00:17:42,150
whatever you have like don't become

00:17:40,409 --> 00:17:44,429
different through adoption of this of

00:17:42,150 --> 00:17:45,900
this scheme it just means that that you

00:17:44,429 --> 00:17:47,309
create the listening sockets earlier it

00:17:45,900 --> 00:17:48,600
doesn't mean that that if there's

00:17:47,309 --> 00:17:51,179
exactly dependency or anything like that

00:17:48,600 --> 00:17:52,860
it becomes did I suddenly go away or

00:17:51,179 --> 00:17:54,030
suddenly more cyclic dependency get

00:17:52,860 --> 00:17:56,070
create a tester that doesn't really

00:17:54,030 --> 00:17:58,080
change much in that way but I would say

00:17:56,070 --> 00:17:59,429
if you if you focus on clusters and

00:17:58,080 --> 00:18:01,260
stuff like that you probably should

00:17:59,429 --> 00:18:04,169
program defensively should we try

00:18:01,260 --> 00:18:05,850
because packets get lost all the time so

00:18:04,169 --> 00:18:06,960
does that kind of answer your question

00:18:05,850 --> 00:18:10,200
okay

00:18:06,960 --> 00:18:13,110
so um Lisi socket activation has has

00:18:10,200 --> 00:18:14,610
many many advantages one of them as

00:18:13,110 --> 00:18:16,980
mentioned this is that we can do this

00:18:14,610 --> 00:18:18,570
drastic form of paralyzation where we

00:18:16,980 --> 00:18:20,309
can start every single service at the

00:18:18,570 --> 00:18:22,740
very same time and that you make the

00:18:20,309 --> 00:18:24,510
best of the cpu in the i/o timer viable

00:18:22,740 --> 00:18:27,480
but there's a couple of other additional

00:18:24,510 --> 00:18:30,900
really great advantages one of them is

00:18:27,480 --> 00:18:33,270
is suddenly you do not have to to to

00:18:30,900 --> 00:18:36,059
encode any kind of dependencies anymore

00:18:33,270 --> 00:18:39,480
because in one big step all the sockets

00:18:36,059 --> 00:18:42,059
are actually established so where the

00:18:39,480 --> 00:18:43,799
d-bus uses syslog or not doesn't matter

00:18:42,059 --> 00:18:45,870
anymore because it can just connect to

00:18:43,799 --> 00:18:47,850
the socket and it will be that

00:18:45,870 --> 00:18:49,800
and I mean traditionally you needed to

00:18:47,850 --> 00:18:51,480
make sure that that divas got started

00:18:49,800 --> 00:18:53,700
after such luck so if she needed to

00:18:51,480 --> 00:18:55,440
write down somewhere that divas requires

00:18:53,700 --> 00:18:57,300
this luck but it's not necessary anymore

00:18:55,440 --> 00:18:59,400
because all the sockets are created at

00:18:57,300 --> 00:19:01,740
the very same time and everybody can

00:18:59,400 --> 00:19:02,940
just connect so it's a lot simpler for

00:19:01,740 --> 00:19:04,290
the administrator and for the developer

00:19:02,940 --> 00:19:05,520
because they don't then don't need to

00:19:04,290 --> 00:19:08,220
think any more about all these

00:19:05,520 --> 00:19:12,000
dependencies it has a couple of

00:19:08,220 --> 00:19:14,370
advantage of advantages - for example we

00:19:12,000 --> 00:19:16,980
can actually restart stuff without

00:19:14,370 --> 00:19:19,559
having lip service being unavailable for

00:19:16,980 --> 00:19:21,990
any any any in the tiniest time of time

00:19:19,559 --> 00:19:24,390
a bit of time even for example you start

00:19:21,990 --> 00:19:26,040
this lock and then and since I'll

00:19:24,390 --> 00:19:27,410
crashes for example because because I

00:19:26,040 --> 00:19:29,160
don't know why it says Lux

00:19:27,410 --> 00:19:31,490
implementations tend to be gigantic

00:19:29,160 --> 00:19:34,770
beasts nowadays with all kinds of

00:19:31,490 --> 00:19:36,870
enterprise e SSL and whatnot so they

00:19:34,770 --> 00:19:39,090
have every reason to crash so if they

00:19:36,870 --> 00:19:40,890
crash and use this kind of socket

00:19:39,090 --> 00:19:42,360
activation then this socket they they

00:19:40,890 --> 00:19:44,490
they're listening on got created by the

00:19:42,360 --> 00:19:46,200
unit system and is that so the process

00:19:44,490 --> 00:19:48,150
code goes away the inner system still

00:19:46,200 --> 00:19:49,650
retains that original socket and if the

00:19:48,150 --> 00:19:51,960
inner system then notices oh my god

00:19:49,650 --> 00:19:53,610
syslog crashed and was configured to say

00:19:51,960 --> 00:19:56,040
ok if it crashes then just restarted

00:19:53,610 --> 00:19:59,520
then we'll do that and we'll pass the

00:19:56,040 --> 00:20:01,170
original socket again to syslog and and

00:19:59,520 --> 00:20:03,090
however this is still the original

00:20:01,170 --> 00:20:04,860
sockets are every seeing every message

00:20:03,090 --> 00:20:07,590
that got queued into that socket is

00:20:04,860 --> 00:20:10,440
still there to the fact that that that

00:20:07,590 --> 00:20:11,910
nobody will actually notice that this is

00:20:10,440 --> 00:20:14,250
locked crashed because not a single

00:20:11,910 --> 00:20:15,780
message will be dropped every single

00:20:14,250 --> 00:20:17,700
message that is in the in the socket

00:20:15,780 --> 00:20:20,190
will be read by this is log

00:20:17,700 --> 00:20:21,600
implementation and and it is really cool

00:20:20,190 --> 00:20:23,520
because you can actually write robust

00:20:21,600 --> 00:20:25,350
software that can just crash and the

00:20:23,520 --> 00:20:26,429
only thing you might lose is one

00:20:25,350 --> 00:20:28,800
transaction that it was actually

00:20:26,429 --> 00:20:30,300
processing while crashing but but

00:20:28,800 --> 00:20:33,090
otherwise you don't lose anything at all

00:20:30,300 --> 00:20:34,650
and you can even use this for for-4

00:20:33,090 --> 00:20:37,140
really amazing stuff like like upgrades

00:20:34,650 --> 00:20:39,360
you say ok my mind says like an

00:20:37,140 --> 00:20:41,309
implantation I got a new version I can

00:20:39,360 --> 00:20:42,900
shut it down I think I can start the app

00:20:41,309 --> 00:20:45,450
the new one but because the socket

00:20:42,900 --> 00:20:47,100
listening is done by the init system and

00:20:45,450 --> 00:20:49,170
it still always keeps that reference to

00:20:47,100 --> 00:20:50,269
that socket you can do this and you

00:20:49,170 --> 00:20:52,580
won't even

00:20:50,269 --> 00:20:53,929
even even lose a single vlog message you

00:20:52,580 --> 00:20:55,129
can use it for for a couple of other

00:20:53,929 --> 00:20:57,409
things too like like you can actually

00:20:55,129 --> 00:20:59,209
replace the implementations of what you

00:20:57,409 --> 00:21:01,399
do then again she's like it's a good

00:20:59,209 --> 00:21:03,409
example for that we for example have a

00:21:01,399 --> 00:21:06,229
little bit of a very tiny bridge that

00:21:03,409 --> 00:21:07,789
connects syslog to K message okay

00:21:06,229 --> 00:21:09,769
message being the chronolock buffer that

00:21:07,789 --> 00:21:11,089
you can see we see with D message we

00:21:09,769 --> 00:21:13,729
always thought it's it's kind of sad

00:21:11,089 --> 00:21:15,679
that during early boot no proper proper

00:21:13,729 --> 00:21:17,659
logging is available in system D that's

00:21:15,679 --> 00:21:19,190
different because in system D and we

00:21:17,659 --> 00:21:22,219
very very early creative listening

00:21:19,190 --> 00:21:23,779
socket for the vlog then spawn this

00:21:22,219 --> 00:21:25,309
little little bridge thing that just

00:21:23,779 --> 00:21:27,320
pushed everything that comes in through

00:21:25,309 --> 00:21:28,999
dev log into the kernel log buffer and

00:21:27,320 --> 00:21:31,190
eventually when the real system goes up

00:21:28,999 --> 00:21:32,989
and the real system starts up we can

00:21:31,190 --> 00:21:34,609
just start them and replace the

00:21:32,989 --> 00:21:38,239
implementation of syslog on the fly

00:21:34,609 --> 00:21:40,969
without losing a single message and that

00:21:38,239 --> 00:21:42,739
is really great and there's a couple of

00:21:40,969 --> 00:21:47,209
other things like come with this kind of

00:21:42,739 --> 00:21:49,190
design it is the kernel that schedules

00:21:47,209 --> 00:21:52,639
the execution order for us because

00:21:49,190 --> 00:21:54,950
because um let's let's for example this

00:21:52,639 --> 00:21:56,929
is like example again let's say you

00:21:54,950 --> 00:21:58,190
create the socket then you start this

00:21:56,929 --> 00:22:00,499
look at the same time you start all

00:21:58,190 --> 00:22:02,059
kinds of clients off this lock then they

00:22:00,499 --> 00:22:03,979
will connect to that that socket and

00:22:02,059 --> 00:22:06,049
will write the messages to it but they

00:22:03,979 --> 00:22:07,820
will never actually block on it because

00:22:06,049 --> 00:22:09,559
a socket buffer of deadlock is kind of

00:22:07,820 --> 00:22:11,239
large so every time they write a message

00:22:09,559 --> 00:22:12,619
they will just write the message and the

00:22:11,239 --> 00:22:14,929
crown will just put it into that socket

00:22:12,619 --> 00:22:17,599
lever and will return immediately so the

00:22:14,929 --> 00:22:19,879
clients do not have to wait ever for for

00:22:17,599 --> 00:22:21,739
anything they can just just push data

00:22:19,879 --> 00:22:23,479
into it and eventually if the socket

00:22:21,739 --> 00:22:24,979
buffer really runs over if you if you if

00:22:23,479 --> 00:22:27,469
you if you really log it a couple of

00:22:24,979 --> 00:22:28,999
megabytes of stuff then they will will

00:22:27,469 --> 00:22:32,329
have to wait until the other side caught

00:22:28,999 --> 00:22:33,769
up but only in that case and this this

00:22:32,329 --> 00:22:36,169
in this is located works really really

00:22:33,769 --> 00:22:38,419
well because this leaks is this log is

00:22:36,169 --> 00:22:40,820
really strictly one-way you never expect

00:22:38,419 --> 00:22:42,559
to reply from syslog you just push data

00:22:40,820 --> 00:22:43,700
into it and says look take that but it

00:22:42,559 --> 00:22:47,450
will never actually respond to you is

00:22:43,700 --> 00:22:49,609
I'm time then then the client will write

00:22:47,450 --> 00:22:52,909
a message to the deeper socket and d-bus

00:22:49,609 --> 00:22:54,529
will take some time to to reply but it's

00:22:52,909 --> 00:22:56,179
only said one application will worried

00:22:54,529 --> 00:22:59,389
for it and at the same time you can

00:22:56,179 --> 00:23:00,769
start everything else and and people can

00:22:59,389 --> 00:23:02,870
also access the socket and push data

00:23:00,769 --> 00:23:05,180
into it and stuff like that but

00:23:02,870 --> 00:23:07,340
yeah the colonel is the one that that

00:23:05,180 --> 00:23:08,960
that will order the execution for you

00:23:07,340 --> 00:23:11,120
and and that doesn't need to be a

00:23:08,960 --> 00:23:13,130
scheduler anymore in the init system to

00:23:11,120 --> 00:23:14,960
make sure that the right things are

00:23:13,130 --> 00:23:17,360
start at the right time and to make the

00:23:14,960 --> 00:23:19,070
best use of the CPU so yeah this is

00:23:17,360 --> 00:23:21,560
soccerbase activation it's one of the

00:23:19,070 --> 00:23:23,720
greatest things that that are in launch

00:23:21,560 --> 00:23:25,070
D and so we saw it okay this is so

00:23:23,720 --> 00:23:26,720
awesome we want that in system YouTube

00:23:25,070 --> 00:23:27,800
because it simply finds everything

00:23:26,720 --> 00:23:29,990
because you don't have to configure

00:23:27,800 --> 00:23:32,270
dependencies it panda that lies things

00:23:29,990 --> 00:23:34,250
like nothing else and it's it's it's

00:23:32,270 --> 00:23:36,110
it's it makes things more robust because

00:23:34,250 --> 00:23:38,240
it can can change things and replace

00:23:36,110 --> 00:23:44,350
implementations and stuff like that it's

00:23:38,240 --> 00:23:44,350
there question there's a question spool

00:23:49,400 --> 00:23:54,650
one thing is how do you know which

00:23:52,100 --> 00:23:57,799
circuits have to be created in the first

00:23:54,650 --> 00:23:59,809
time it's it's basically um if somebody

00:23:57,799 --> 00:24:01,160
wants a service to be started like they

00:23:59,809 --> 00:24:02,960
say you install then it's just like

00:24:01,160 --> 00:24:05,870
implementation then it will tell us not

00:24:02,960 --> 00:24:07,429
only that it's this syslog binding

00:24:05,870 --> 00:24:09,080
binary that should be started eventually

00:24:07,429 --> 00:24:11,390
but it will also tell us ok please

00:24:09,080 --> 00:24:13,160
create the dev lock circuit for us so

00:24:11,390 --> 00:24:15,440
it's basically at installation time you

00:24:13,160 --> 00:24:17,059
drop in a service file and a socket file

00:24:15,440 --> 00:24:18,470
that's how we call it an insistently

00:24:17,059 --> 00:24:20,240
that contains configuration parameter

00:24:18,470 --> 00:24:23,120
usually that's very very short you just

00:24:20,240 --> 00:24:25,700
say listen listen on a Datagram socket

00:24:23,120 --> 00:24:28,400
sledge dev lock for me full stop so

00:24:25,700 --> 00:24:30,049
that's it's really really short and we

00:24:28,400 --> 00:24:31,669
actually you can actually maintain those

00:24:30,049 --> 00:24:33,500
sockets and in the service and system be

00:24:31,669 --> 00:24:36,590
completely independently you can stay

00:24:33,500 --> 00:24:38,780
you can start them this is LOC socket

00:24:36,590 --> 00:24:40,669
regularly and the very late actually

00:24:38,780 --> 00:24:43,460
starts a service and you can even do

00:24:40,669 --> 00:24:46,130
stuff like this bridge I mentioned it

00:24:43,460 --> 00:24:48,380
will actually terminate when idle like

00:24:46,130 --> 00:24:50,179
if there's no LOC messages if it doesn't

00:24:48,380 --> 00:24:52,250
didn't relief receive any log messages

00:24:50,179 --> 00:24:53,990
in the last fifteen seconds or so it

00:24:52,250 --> 00:24:56,990
will terminate itself because the init

00:24:53,990 --> 00:24:58,669
system still listens on it it's not a

00:24:56,990 --> 00:25:00,909
problem because because the moment

00:24:58,669 --> 00:25:03,230
somebody actually writes something again

00:25:00,909 --> 00:25:04,789
again to do the thing then the init

00:25:03,230 --> 00:25:06,440
system will notice oh my god something

00:25:04,789 --> 00:25:08,510
throats is something to the to the

00:25:06,440 --> 00:25:11,120
socket but there's nothing backing it Oh

00:25:08,510 --> 00:25:11,840
Landon let's just started and then it's

00:25:11,120 --> 00:25:13,280
being started

00:25:11,840 --> 00:25:15,320
then we'll process the message that's

00:25:13,280 --> 00:25:16,940
got huge in it in the socket and then

00:25:15,320 --> 00:25:18,830
then then then eventually this the

00:25:16,940 --> 00:25:20,539
bridge will terminate again so you have

00:25:18,830 --> 00:25:23,450
this this kind of on-demand starting of

00:25:20,539 --> 00:25:27,140
this as well all of this is not really a

00:25:23,450 --> 00:25:28,820
new idea in UNIX as mentioned Apple came

00:25:27,140 --> 00:25:30,830
up with the using this for paralyzation

00:25:28,820 --> 00:25:32,480
but actually this was known before in

00:25:30,830 --> 00:25:35,659
inanity I already mentioned that earlier

00:25:32,480 --> 00:25:37,309
I know T is one of those classic UNIX

00:25:35,659 --> 00:25:40,159
socket that has been around for for ages

00:25:37,309 --> 00:25:44,059
and unique services that has been around

00:25:40,159 --> 00:25:47,150
for ages it did very similar things it

00:25:44,059 --> 00:25:49,580
but it didn't do it for for paralyzation

00:25:47,150 --> 00:25:51,590
or for robustness in reasons it mostly

00:25:49,580 --> 00:25:55,159
did it to to simplify implementations of

00:25:51,590 --> 00:25:56,630
damage and do um on-demand starting of

00:25:55,159 --> 00:25:58,490
diamonds they had a little bit different

00:25:56,630 --> 00:25:59,990
models they were mostly focusing on

00:25:58,490 --> 00:26:00,350
internet sockets and not so much in unix

00:25:59,990 --> 00:26:00,980
sockets

00:26:00,350 --> 00:26:02,630
we

00:26:00,980 --> 00:26:05,900
focus more on unix sockets but also do

00:26:02,630 --> 00:26:08,090
internet sockets and they had although

00:26:05,900 --> 00:26:10,429
it was possible to start services that

00:26:08,090 --> 00:26:12,590
would then take the listening m socket

00:26:10,429 --> 00:26:14,540
it was mostly focused on spawning one

00:26:12,590 --> 00:26:16,640
instance of a demon for each connection

00:26:14,540 --> 00:26:18,380
socket but actually it's a part of both

00:26:16,640 --> 00:26:19,520
ways and we support both ways to it's

00:26:18,380 --> 00:26:23,120
just a little bit of a different focus

00:26:19,520 --> 00:26:24,620
we want if you start apache on demand we

00:26:23,120 --> 00:26:26,809
want that that apache get the real

00:26:24,620 --> 00:26:28,520
listening socket and they back then

00:26:26,809 --> 00:26:30,169
wanted to just hand off one connection

00:26:28,520 --> 00:26:32,150
socket and have a couple of apache

00:26:30,169 --> 00:26:33,770
instances we just not arrest the rest of

00:26:32,150 --> 00:26:35,410
you to make things fast and we want

00:26:33,770 --> 00:26:41,210
things fast but there was a question

00:26:35,410 --> 00:26:43,340
yeah i'm assuming that demons need to be

00:26:41,210 --> 00:26:45,890
modified in some way to understand ish

00:26:43,340 --> 00:26:51,160
or that isn't that is a very good

00:26:45,890 --> 00:26:51,160
question and i have a slide for that

00:26:52,370 --> 00:26:58,740
so yeah we need to do to Petra damaged

00:26:55,110 --> 00:26:59,970
photos in some cases at least it's

00:26:58,740 --> 00:27:01,860
actually very very simple to patch

00:26:59,970 --> 00:27:03,480
demonstrators for a couple of reasons

00:27:01,860 --> 00:27:06,150
the code of the dam in action becomes

00:27:03,480 --> 00:27:07,860
much much simpler because if you if you

00:27:06,150 --> 00:27:10,230
currently if a diamond creates a socket

00:27:07,860 --> 00:27:12,240
that it wants to listen on what it does

00:27:10,230 --> 00:27:14,310
it calls a socket system call it calls

00:27:12,240 --> 00:27:15,840
the vine system call it calls a listing

00:27:14,310 --> 00:27:18,690
system call and mainly calls a couple of

00:27:15,840 --> 00:27:21,210
stops in between if you use this kind of

00:27:18,690 --> 00:27:23,970
system deactivation then the socket just

00:27:21,210 --> 00:27:25,980
gets passed to you via wire process of

00:27:23,970 --> 00:27:28,020
execution you don't have to do anything

00:27:25,980 --> 00:27:30,330
you just take the socket into there so

00:27:28,020 --> 00:27:33,060
yeah but you need to patch most of the

00:27:30,330 --> 00:27:34,710
damage we already did most of the work

00:27:33,060 --> 00:27:36,930
for for the stuff that is running on

00:27:34,710 --> 00:27:39,480
default on on a fedora system like weed

00:27:36,930 --> 00:27:41,430
patch patch RSS lovely patch d-bus and

00:27:39,480 --> 00:27:42,510
all these kind of things so that they

00:27:41,430 --> 00:27:44,100
actually work like this it's really

00:27:42,510 --> 00:27:45,660
really simple interface it's basically

00:27:44,100 --> 00:27:47,520
you just get an environment variable

00:27:45,660 --> 00:27:48,870
which tells you hey you got a socket

00:27:47,520 --> 00:27:53,490
pass and then you just take it and use

00:27:48,870 --> 00:27:55,830
it and also quite a few diamonds already

00:27:53,490 --> 00:28:01,110
support a socket based activation due to

00:27:55,830 --> 00:28:02,610
on a deep history for example sshd we

00:28:01,110 --> 00:28:06,180
won't bother with was actually package

00:28:02,610 --> 00:28:09,930
caching that because sshd i can be used

00:28:06,180 --> 00:28:12,060
to start at per m connection i'm d and

00:28:09,930 --> 00:28:13,770
we say that's good enough and an apple

00:28:12,060 --> 00:28:14,790
actually starts at the y2 we don't need

00:28:13,770 --> 00:28:16,110
any any any further

00:28:14,790 --> 00:28:17,880
I'm sorry base activation we can just

00:28:16,110 --> 00:28:19,440
use this classic energy mode and we

00:28:17,880 --> 00:28:21,930
supports it and it works fine and

00:28:19,440 --> 00:28:23,730
there's a couple of other reasons where

00:28:21,930 --> 00:28:25,230
we're socket this kind of patching

00:28:23,730 --> 00:28:28,530
becomes very simple

00:28:25,230 --> 00:28:33,420
for example because Apple supports us on

00:28:28,530 --> 00:28:34,890
mecca's quite a few software that exists

00:28:33,420 --> 00:28:38,040
out there is already patched for this

00:28:34,890 --> 00:28:39,990
these kind of the same mindset basically

00:28:38,040 --> 00:28:42,210
it doesn't use the same API s as we do

00:28:39,990 --> 00:28:43,950
our API is are much much simpler

00:28:42,210 --> 00:28:45,690
our API is really are just checks

00:28:43,950 --> 00:28:48,810
environment variable and just use a

00:28:45,690 --> 00:28:51,210
socket and while a while with with the

00:28:48,810 --> 00:28:52,830
launch the API so you have to check in

00:28:51,210 --> 00:28:56,160
and say yeah give me those sockets and

00:28:52,830 --> 00:28:57,480
it's kind of complicated but if a

00:28:56,160 --> 00:28:59,610
software already got patched for launch

00:28:57,480 --> 00:29:01,470
deep it's very very simple to update it

00:28:59,610 --> 00:29:04,020
to support our mode as well so yeah you

00:29:01,470 --> 00:29:05,100
have to patch but it's really really

00:29:04,020 --> 00:29:07,930
simple

00:29:05,100 --> 00:29:09,610
so regarding this socket based

00:29:07,930 --> 00:29:12,340
activation have you given any thoughts

00:29:09,610 --> 00:29:15,940
to services that are associated with the

00:29:12,340 --> 00:29:19,090
user sessions and that is good questions

00:29:15,940 --> 00:29:20,680
so yeah later on and if you saw the

00:29:19,090 --> 00:29:22,960
original slide wasn't it only saying

00:29:20,680 --> 00:29:25,180
system manager but also sash manager so

00:29:22,960 --> 00:29:27,430
eventually we do not only want to manage

00:29:25,180 --> 00:29:29,020
the system with it because that that is

00:29:27,430 --> 00:29:31,240
that the system boots are fastest one

00:29:29,020 --> 00:29:33,880
good thing but that the session after

00:29:31,240 --> 00:29:35,200
you logged in boots up fast is almost as

00:29:33,880 --> 00:29:36,610
important might actually be more

00:29:35,200 --> 00:29:37,960
important on most desktop machines

00:29:36,610 --> 00:29:39,940
because we start to start a shitload of

00:29:37,960 --> 00:29:42,790
stuff in the sessions nowadays so yeah

00:29:39,940 --> 00:29:45,310
we definitely want to to also start

00:29:42,790 --> 00:29:47,260
genome and like this it's it's not it's

00:29:45,310 --> 00:29:48,820
it's not only on the to-do list right

00:29:47,260 --> 00:29:50,710
now because first we need to get into

00:29:48,820 --> 00:29:51,970
distributions for the system stuff but

00:29:50,710 --> 00:29:53,590
it's going to be the next thing that we

00:29:51,970 --> 00:29:55,180
look at look into actually you can

00:29:53,590 --> 00:29:58,600
already run it like this you can just

00:29:55,180 --> 00:30:00,400
run systemd - - user and it will work as

00:29:58,600 --> 00:30:02,560
something like a size matter but you

00:30:00,400 --> 00:30:04,360
can't really use it yet to spawn up you

00:30:02,560 --> 00:30:05,770
know in the long run it's our secret

00:30:04,360 --> 00:30:08,140
hope but we haven't really figured out

00:30:05,770 --> 00:30:10,180
all the details that that we basically

00:30:08,140 --> 00:30:11,860
pull out the session management take

00:30:10,180 --> 00:30:13,150
this away from the different best of

00:30:11,860 --> 00:30:16,090
environments and just have one one

00:30:13,150 --> 00:30:17,380
simple one that everybody can use so

00:30:16,090 --> 00:30:19,270
that you can instead that you have a

00:30:17,380 --> 00:30:21,640
genome session the KT session and then

00:30:19,270 --> 00:30:22,870
something else and people just can mix

00:30:21,640 --> 00:30:24,670
and match stuff and then there's only

00:30:22,870 --> 00:30:27,040
the Linux session which would be system

00:30:24,670 --> 00:30:30,040
lis but yeah these all these things like

00:30:27,040 --> 00:30:31,900
paralyzing boot up there they are the

00:30:30,040 --> 00:30:35,110
same problem for starting up the system

00:30:31,900 --> 00:30:38,980
and starting up the session I guess that

00:30:35,110 --> 00:30:41,520
answer your question okay there's

00:30:38,980 --> 00:30:41,520
another question

00:30:42,100 --> 00:30:47,590
yeah just a quick note it's a good idea

00:30:45,190 --> 00:30:49,630
to try to replace Nam session and keyd

00:30:47,590 --> 00:30:52,000
session and XFC for session for example

00:30:49,630 --> 00:30:56,340
but you still have to keep in mind that

00:30:52,000 --> 00:30:59,980
systemd will only work on line ups so I

00:30:56,340 --> 00:31:02,430
follow system you will still only work

00:30:59,980 --> 00:31:05,020
on line ups so you we still need the

00:31:02,430 --> 00:31:08,130
traditional session manager on the other

00:31:05,020 --> 00:31:11,170
operating systems so yeah the

00:31:08,130 --> 00:31:13,320
insistently we do care only about Linux

00:31:11,170 --> 00:31:15,820
this offers us so much

00:31:13,320 --> 00:31:16,870
advantages that we yeah I personally

00:31:15,820 --> 00:31:21,460
don't care about the other pratik

00:31:16,870 --> 00:31:26,170
systems basically if if people care it's

00:31:21,460 --> 00:31:28,780
a problem is the thing it's like like if

00:31:26,170 --> 00:31:29,920
we if we if we focus on Linux then then

00:31:28,780 --> 00:31:31,480
then we have so many opportunities

00:31:29,920 --> 00:31:33,940
because we can use all this learning

00:31:31,480 --> 00:31:35,620
specific IP is and Linux is simply the

00:31:33,940 --> 00:31:37,570
most advanced kernel there is and it has

00:31:35,620 --> 00:31:39,100
all these awesome things like Linux

00:31:37,570 --> 00:31:41,500
cgroups all these kinds of properties

00:31:39,100 --> 00:31:44,380
and if we if we would want to make this

00:31:41,500 --> 00:31:46,690
portable to other unix's which basically

00:31:44,380 --> 00:31:49,000
I don't know was the API stood still in

00:31:46,690 --> 00:31:51,730
the in the in the I don't know 10 years

00:31:49,000 --> 00:31:53,590
ago we could do this but we couldn't use

00:31:51,730 --> 00:31:55,030
all these these new functionality also

00:31:53,590 --> 00:31:57,970
it makes our code much much simpler

00:31:55,030 --> 00:32:00,160
because because we do not need to care

00:31:57,970 --> 00:32:02,350
or anything about abstraction we do not

00:32:00,160 --> 00:32:04,810
need to abstract kernel interfaces

00:32:02,350 --> 00:32:07,060
because because we could just develop it

00:32:04,810 --> 00:32:09,190
on Linux our code becomes much taller it

00:32:07,060 --> 00:32:11,350
becomes much easier to read and becomes

00:32:09,190 --> 00:32:12,880
much more powerful and we actually use a

00:32:11,350 --> 00:32:15,370
shitload of Linux specific interfaces

00:32:12,880 --> 00:32:16,750
really use amuses event of TV's time RFD

00:32:15,370 --> 00:32:19,630
will see groups we use slash

00:32:16,750 --> 00:32:20,890
programmatic reading it yeah a lot of

00:32:19,630 --> 00:32:22,840
these things you can't even do in our

00:32:20,890 --> 00:32:25,510
operating systems for example just

00:32:22,840 --> 00:32:28,360
watching and the mount table what is

00:32:25,510 --> 00:32:30,010
modern what's not and there's not really

00:32:28,360 --> 00:32:34,030
nice API for this on any other operating

00:32:30,010 --> 00:32:36,220
system but only knows so well I mean I

00:32:34,030 --> 00:32:40,510
do respect if people want to spend time

00:32:36,220 --> 00:32:43,870
on other operating systems they may but

00:32:40,510 --> 00:32:46,180
I think I think the focal part of a free

00:32:43,870 --> 00:32:48,820
software development is Linux and I

00:32:46,180 --> 00:32:50,560
don't think I need to care groups I need

00:32:48,820 --> 00:32:52,660
to care too much about keeping

00:32:50,560 --> 00:32:54,820
compatibility with ten operating systems

00:32:52,660 --> 00:32:55,660
just one is good and it's going to

00:32:54,820 --> 00:32:58,360
create

00:32:55,660 --> 00:32:59,680
the best product and I think most of the

00:32:58,360 --> 00:33:01,720
people who actually do the working now

00:32:59,680 --> 00:33:04,240
and do the work and then the other

00:33:01,720 --> 00:33:07,420
operating systems do mostly care about

00:33:04,240 --> 00:33:09,850
Linux so yeah basically my position on

00:33:07,420 --> 00:33:12,160
all of this is yeah

00:33:09,850 --> 00:33:13,900
my focus is Linux I offer you something

00:33:12,160 --> 00:33:16,750
for Linux if you care about something

00:33:13,900 --> 00:33:17,350
else I won't make good life extra

00:33:16,750 --> 00:33:20,650
difficult

00:33:17,350 --> 00:33:25,320
I will respect that but don't ask me to

00:33:20,650 --> 00:33:28,420
care for for FreeBSD or whatever I want

00:33:25,320 --> 00:33:30,850
that's another question what do you do

00:33:28,420 --> 00:33:34,630
if you have a dependency relationship

00:33:30,850 --> 00:33:36,730
that's not based on sockets so it's some

00:33:34,630 --> 00:33:38,170
other dependency so I'm socket

00:33:36,730 --> 00:33:39,880
activation is not the only kind of

00:33:38,170 --> 00:33:42,790
activation we support we also support

00:33:39,880 --> 00:33:45,010
d-bus activation so on current fedora

00:33:42,790 --> 00:33:46,510
systems actually by default more diba

00:33:45,010 --> 00:33:48,400
services are installed then actually

00:33:46,510 --> 00:33:50,470
services listening on sockets so

00:33:48,400 --> 00:33:52,690
everything I've told you about a socket

00:33:50,470 --> 00:33:55,450
activation we also support for d-bus

00:33:52,690 --> 00:33:57,130
activation meaning if somebody talks

00:33:55,450 --> 00:33:58,840
wants to talk to a service that is not

00:33:57,130 --> 00:34:01,270
available on the bus right now it will

00:33:58,840 --> 00:34:04,510
be spawned this actually exists in T bus

00:34:01,270 --> 00:34:06,310
anyway but in this new scheme it will

00:34:04,510 --> 00:34:08,080
actually forward to system D system D

00:34:06,310 --> 00:34:09,730
will start the service and it work like

00:34:08,080 --> 00:34:11,169
this this is much nicer than the

00:34:09,730 --> 00:34:12,460
traditional stuff actually because we

00:34:11,169 --> 00:34:16,270
you can actually start a service for

00:34:12,460 --> 00:34:18,130
example of ahi ahi I hope everybody

00:34:16,270 --> 00:34:20,140
knows that it's service discovery you

00:34:18,130 --> 00:34:22,870
need it if you have a network you need

00:34:20,140 --> 00:34:26,530
it if an application requests for it via

00:34:22,870 --> 00:34:29,080
socket meaning does an NSF request and

00:34:26,530 --> 00:34:31,690
you need it if somebody requests it by

00:34:29,080 --> 00:34:33,700
the D bus so these three triggers and if

00:34:31,690 --> 00:34:34,990
nothing of this happens you have really

00:34:33,700 --> 00:34:36,250
no reason to start a volley because if

00:34:34,990 --> 00:34:38,290
you don't have a network and no

00:34:36,250 --> 00:34:41,140
application wants to use it why start it

00:34:38,290 --> 00:34:43,510
so in system B we have this the scheme

00:34:41,140 --> 00:34:48,220
in there that you can have three

00:34:43,510 --> 00:34:50,530
triggers Hardware diva's socket and they

00:34:48,220 --> 00:34:52,240
will result in just one instance being

00:34:50,530 --> 00:34:54,700
started and that completely raised free

00:34:52,240 --> 00:34:56,890
and completely safe and yeah does this

00:34:54,700 --> 00:34:59,350
kind of answer your question yes those

00:34:56,890 --> 00:35:00,430
great so if you if you if you look at

00:34:59,350 --> 00:35:03,130
the main page you'll see we have a

00:35:00,430 --> 00:35:04,810
couple of other triggers as well like we

00:35:03,130 --> 00:35:07,480
have we have mount triggers and then all

00:35:04,810 --> 00:35:07,720
these kind of things so you have quite a

00:35:07,480 --> 00:35:12,580
bit

00:35:07,720 --> 00:35:19,750
flexibility yeah there's another

00:35:12,580 --> 00:35:21,369
question somewhere by the way so so what

00:35:19,750 --> 00:35:23,980
kind of by the way this is kaisi worse

00:35:21,369 --> 00:35:25,510
uses the other system big guy here

00:35:23,980 --> 00:35:28,000
so if you have questions you can not

00:35:25,510 --> 00:35:31,300
only ask me but also him then but what I

00:35:28,000 --> 00:35:33,490
wanted to what he mentioned is is that

00:35:31,300 --> 00:35:34,990
while in system D most of the

00:35:33,490 --> 00:35:36,280
dependencies completely go away you

00:35:34,990 --> 00:35:39,640
don't have to configure them anymore you

00:35:36,280 --> 00:35:41,230
still can if you want and this is

00:35:39,640 --> 00:35:43,300
necessary for example for early boot up

00:35:41,230 --> 00:35:45,070
because at early booty up and you have

00:35:43,300 --> 00:35:47,740
dependencies like you want to first set

00:35:45,070 --> 00:35:50,170
the clock and then do a couple of things

00:35:47,740 --> 00:35:51,280
like method alarm of writing block

00:35:50,170 --> 00:35:53,770
message just because you want to make

00:35:51,280 --> 00:35:56,980
sure that the right clock is used when

00:35:53,770 --> 00:35:59,320
writing those lock messages so sometimes

00:35:56,980 --> 00:36:01,240
you do need explicit explicitly

00:35:59,320 --> 00:36:03,400
configure dependencies and system TX

00:36:01,240 --> 00:36:06,820
both is a very elaborate system if you

00:36:03,400 --> 00:36:08,500
want to but normally for most of the

00:36:06,820 --> 00:36:10,090
services most of the cells like syslog D

00:36:08,500 --> 00:36:11,590
both whatever you actually do not have

00:36:10,090 --> 00:36:13,839
to configure a single dependency it will

00:36:11,590 --> 00:36:15,609
all happen for you so the dependency

00:36:13,839 --> 00:36:17,170
configuration is mostly something for

00:36:15,609 --> 00:36:20,710
the people who actually builds operating

00:36:17,170 --> 00:36:22,450
system for you like the me as upstream

00:36:20,710 --> 00:36:24,070
or the Fedora maintenance Debian

00:36:22,450 --> 00:36:25,599
maintenance and all these people they

00:36:24,070 --> 00:36:28,300
will use explicitly configured

00:36:25,599 --> 00:36:31,060
dependencies but the people who develop

00:36:28,300 --> 00:36:33,400
them services the administrators who

00:36:31,060 --> 00:36:35,619
want to write service files for existing

00:36:33,400 --> 00:36:39,460
services then I'll actually have to deal

00:36:35,619 --> 00:36:42,580
with them and I say yeah I don't really

00:36:39,460 --> 00:36:45,670
understand oh this is supposed to be a

00:36:42,580 --> 00:36:49,119
drop-in replacement for system 5 minute

00:36:45,670 --> 00:36:50,220
if you need to patch the demons and also

00:36:49,119 --> 00:36:53,759
yeah

00:36:50,220 --> 00:36:55,650
you don't want to to think about operate

00:36:53,759 --> 00:36:58,859
water operating system but you expect

00:36:55,650 --> 00:37:01,559
the demon people to batch specifically

00:36:58,859 --> 00:37:03,450
for system D and Linux so to make this

00:37:01,559 --> 00:37:06,239
really clear you do not actually have to

00:37:03,450 --> 00:37:10,170
patch anything it's you can if you want

00:37:06,239 --> 00:37:11,609
to but system D supports classic system

00:37:10,170 --> 00:37:13,950
five-minute scripts just fine it will

00:37:11,609 --> 00:37:15,599
read them as if it was a native

00:37:13,950 --> 00:37:17,940
configuration it's just different kinds

00:37:15,599 --> 00:37:20,789
to right configuration down so if you

00:37:17,940 --> 00:37:23,460
don't want to use a socket based patched

00:37:20,789 --> 00:37:26,220
I don't know implementation of MySQL

00:37:23,460 --> 00:37:29,190
you're welcome to so far nobody has been

00:37:26,220 --> 00:37:31,440
patched anyway so you can't even use it

00:37:29,190 --> 00:37:33,539
it's like the base activation so there

00:37:31,440 --> 00:37:34,979
is no need for you to patch we welcome

00:37:33,539 --> 00:37:36,299
you to do this we think it's a great

00:37:34,979 --> 00:37:38,489
improvement if you do because you can

00:37:36,299 --> 00:37:39,839
get all the robustness a lot of people

00:37:38,489 --> 00:37:42,059
agree with us that make sense for

00:37:39,839 --> 00:37:43,769
example really really not so mainstream

00:37:42,059 --> 00:37:46,349
software's even patched these days like

00:37:43,769 --> 00:37:48,180
like DAF cop that IMF server actually

00:37:46,349 --> 00:37:50,039
supports this avoid socket activation

00:37:48,180 --> 00:37:51,539
but yeah you really don't have to you

00:37:50,039 --> 00:37:53,670
can you can continue to use system v

00:37:51,539 --> 00:37:56,279
init scripts you can continue to not use

00:37:53,670 --> 00:37:57,690
South evacuation but if you do you gain

00:37:56,279 --> 00:37:59,430
all the advantages that we offer you

00:37:57,690 --> 00:38:01,200
that you get rid of all the manual

00:37:59,430 --> 00:38:02,759
dependency configuration that everything

00:38:01,200 --> 00:38:04,739
can be started up in parallel and all

00:38:02,759 --> 00:38:07,200
these kind of things that answer the

00:38:04,739 --> 00:38:13,279
question I have ok there's another

00:38:07,200 --> 00:38:13,279
question and somebody got a mic

00:38:17,580 --> 00:38:22,170
hello yeah I didn't understand the last

00:38:20,970 --> 00:38:24,420
answer you just gave there about

00:38:22,170 --> 00:38:26,610
optionally supporting system five-minute

00:38:24,420 --> 00:38:29,220
script surely for the dependency

00:38:26,610 --> 00:38:30,690
resolution process to work you have to

00:38:29,220 --> 00:38:33,300
have a full set of dependencies if you

00:38:30,690 --> 00:38:35,490
only have a few exposing their sockets

00:38:33,300 --> 00:38:36,870
and then a mishmash of half our system

00:38:35,490 --> 00:38:40,650
five init scripts that never does be

00:38:36,870 --> 00:38:42,720
bothered to port then the functionality

00:38:40,650 --> 00:38:44,550
that you're relying on to make system D

00:38:42,720 --> 00:38:48,030
work just won't work very well there we

00:38:44,550 --> 00:38:49,530
pointless so really be all or nothing no

00:38:48,030 --> 00:38:52,290
it's not all nothing because because

00:38:49,530 --> 00:38:53,580
actually I mean if you if you install

00:38:52,290 --> 00:38:55,320
ten services on your on your on your

00:38:53,580 --> 00:38:56,850
machine like an amateur server an Apache

00:38:55,320 --> 00:38:59,100
then I'm a patch you do not actually

00:38:56,850 --> 00:39:02,100
have a heavy dependencies so but you're

00:38:59,100 --> 00:39:03,270
right if you if you if one of the these

00:39:02,100 --> 00:39:05,940
things that are more at the root of

00:39:03,270 --> 00:39:08,100
things is not socket is activated then

00:39:05,940 --> 00:39:09,360
you cannot kind of paralyze the start of

00:39:08,100 --> 00:39:10,920
the stuff that's started after what's

00:39:09,360 --> 00:39:12,270
that is true but in real life that

00:39:10,920 --> 00:39:14,730
actually doesn't happen that that much

00:39:12,270 --> 00:39:16,620
because because at least as far as we

00:39:14,730 --> 00:39:18,600
see it all the core stuff we have

00:39:16,620 --> 00:39:21,870
patched syslog Debus blah blah blah blah

00:39:18,600 --> 00:39:23,730
blah but yeah you're right and in some

00:39:21,870 --> 00:39:24,870
cases like like for example for the

00:39:23,730 --> 00:39:27,180
deepest activation becomes much easier

00:39:24,870 --> 00:39:29,970
because gos activation already existed

00:39:27,180 --> 00:39:31,500
so manual configuration of dependencies

00:39:29,970 --> 00:39:32,880
never necessary that but you're right if

00:39:31,500 --> 00:39:35,250
you if you have a long chain of system

00:39:32,880 --> 00:39:37,080
five init scripts that use collect

00:39:35,250 --> 00:39:39,270
classic dependencies between them then

00:39:37,080 --> 00:39:42,300
yes the system D will make use of that

00:39:39,270 --> 00:39:44,100
but so so basically um my my my-my-my

00:39:42,300 --> 00:39:46,260
look at this is is if you start

00:39:44,100 --> 00:39:47,910
converting then start at the roots don't

00:39:46,260 --> 00:39:50,100
start at the end and then the problem

00:39:47,910 --> 00:39:53,130
doesn't exist okay any further questions

00:39:50,100 --> 00:39:55,350
at this moment there's one so when you

00:39:53,130 --> 00:39:57,120
first actually blogged about this and

00:39:55,350 --> 00:40:00,480
did your first release one of the things

00:39:57,120 --> 00:40:02,610
you talked about was aggressive starting

00:40:00,480 --> 00:40:05,360
of demons versus these sort of start

00:40:02,610 --> 00:40:09,990
them whenever they become required and

00:40:05,360 --> 00:40:11,610
you'd put forth a few statements about

00:40:09,990 --> 00:40:13,710
how you thought that won't be faster but

00:40:11,610 --> 00:40:15,480
you needed further testing I'm curious I

00:40:13,710 --> 00:40:18,690
have not seen you post anything about

00:40:15,480 --> 00:40:20,310
any further testing you've done and what

00:40:18,690 --> 00:40:23,220
has been the performance impact of that

00:40:20,310 --> 00:40:26,070
so yeah in system theme our focus is not

00:40:23,220 --> 00:40:28,050
only speed it's also speed but the

00:40:26,070 --> 00:40:29,640
central focus is to make things correct

00:40:28,050 --> 00:40:30,250
that's what we want to do we want to

00:40:29,640 --> 00:40:33,880
have clean

00:40:30,250 --> 00:40:35,740
that thinks it does things correct so if

00:40:33,880 --> 00:40:37,270
you if you look at recipe and everything

00:40:35,740 --> 00:40:39,270
started parallel then you have this

00:40:37,270 --> 00:40:41,950
problem that on a classic rotating disc

00:40:39,270 --> 00:40:44,170
actually and this is not necessarily

00:40:41,950 --> 00:40:45,790
improves the performance the reason for

00:40:44,170 --> 00:40:47,110
that is is that while traditionally if

00:40:45,790 --> 00:40:49,780
you started everything one after the

00:40:47,110 --> 00:40:52,720
other then because all these blocks that

00:40:49,780 --> 00:40:54,340
these applications used where on disc

00:40:52,720 --> 00:40:56,050
one after the other you could actually

00:40:54,340 --> 00:40:57,190
have linear reads through the through

00:40:56,050 --> 00:40:59,170
the disc and that is the best thing you

00:40:57,190 --> 00:41:00,520
can do in rotating media if you have you

00:40:59,170 --> 00:41:02,590
have a you system D and suddenly start

00:41:00,520 --> 00:41:04,990
piecing apparel then basically the read

00:41:02,590 --> 00:41:06,610
requests to the hard disk come come

00:41:04,990 --> 00:41:07,960
completely random because there's this

00:41:06,610 --> 00:41:09,700
service which which means to access

00:41:07,960 --> 00:41:11,530
there and then next one each text is

00:41:09,700 --> 00:41:15,640
some completely different place so yeah

00:41:11,530 --> 00:41:17,440
this resulted in not an extreme

00:41:15,640 --> 00:41:21,070
improvement in speed if you use rotating

00:41:17,440 --> 00:41:23,230
media so however this is not unfixable

00:41:21,070 --> 00:41:25,350
the reason is because it's not unfixable

00:41:23,230 --> 00:41:29,560
see we have these elevators these i/o

00:41:25,350 --> 00:41:31,750
elevators and they still AM a good

00:41:29,560 --> 00:41:33,720
elevator benefits if it gets a lot of

00:41:31,750 --> 00:41:36,340
requests that it can can can choose from

00:41:33,720 --> 00:41:38,830
so far the classic Linux elevator wasn't

00:41:36,340 --> 00:41:40,480
very good at that but we now generating

00:41:38,830 --> 00:41:41,920
those workloads and elevators tend to be

00:41:40,480 --> 00:41:44,440
optimized for the workloads that they

00:41:41,920 --> 00:41:46,150
have but the summary of it all is it

00:41:44,440 --> 00:41:48,790
isn't worse than the current stuff and

00:41:46,150 --> 00:41:51,280
it's much better on SSD and then the and

00:41:48,790 --> 00:41:52,090
the future is SSD anyway because because

00:41:51,280 --> 00:41:55,090
this is of course a little bit of

00:41:52,090 --> 00:41:57,580
disappointing that this on writing media

00:41:55,090 --> 00:41:59,770
because rotating media still I guess

00:41:57,580 --> 00:42:00,880
most of the computers or the majority of

00:41:59,770 --> 00:42:04,960
computers probably still use rotating

00:42:00,880 --> 00:42:06,190
media little bit pointing so so so we

00:42:04,960 --> 00:42:08,830
looked a little bit into this and in try

00:42:06,190 --> 00:42:10,630
to find a couple of fixes system B

00:42:08,830 --> 00:42:12,670
actually comes out of the box with a

00:42:10,630 --> 00:42:14,830
reader hat implementation reading a hat

00:42:12,670 --> 00:42:17,410
implementation is something like that

00:42:14,830 --> 00:42:19,540
exists actually at least five or six

00:42:17,410 --> 00:42:22,570
versions off we had a month meditations

00:42:19,540 --> 00:42:25,360
basically they look at one boot

00:42:22,570 --> 00:42:26,950
deduce from that the socket the the

00:42:25,360 --> 00:42:29,440
sectors in which order they were exist

00:42:26,950 --> 00:42:32,140
and the next time they at a very early

00:42:29,440 --> 00:42:33,850
boot that read all their sectors and in

00:42:32,140 --> 00:42:35,650
the right order that they are disk thus

00:42:33,850 --> 00:42:36,849
optimizing things and under the

00:42:35,650 --> 00:42:38,470
assumption that then they're already

00:42:36,849 --> 00:42:40,359
in memory when they actually used and

00:42:38,470 --> 00:42:42,789
speed things up we interested we install

00:42:40,359 --> 00:42:45,670
them by default to remedy this problem

00:42:42,789 --> 00:42:47,529
it gets us about ten percent depending

00:42:45,670 --> 00:42:49,509
on what kind of machine you have if you

00:42:47,529 --> 00:42:51,009
don't start any services at all like if

00:42:49,509 --> 00:42:52,359
you have very little to start then of

00:42:51,009 --> 00:42:54,640
course the speed-up of this stuff will

00:42:52,359 --> 00:42:55,779
be minimal if you start with a lot of

00:42:54,640 --> 00:42:59,529
stuff then you will actually notice

00:42:55,779 --> 00:43:01,569
things but yeah but to be honest I don't

00:42:59,529 --> 00:43:03,190
really want to really get too much into

00:43:01,569 --> 00:43:04,630
optimizing my craft room is that my

00:43:03,190 --> 00:43:06,220
linguist stuff like we'd ahead because

00:43:04,630 --> 00:43:08,259
we had is actually not a nice thing

00:43:06,220 --> 00:43:11,650
because what you do is read ahead is

00:43:08,259 --> 00:43:13,479
that you you second-guess the CIO

00:43:11,650 --> 00:43:15,279
schedule of the kernel because you

00:43:13,479 --> 00:43:16,599
actually you actually try to be smarter

00:43:15,279 --> 00:43:18,160
than their i/o schedule of the kernel so

00:43:16,599 --> 00:43:20,140
if we really want to do this and you

00:43:18,160 --> 00:43:22,089
probably should upload the request that

00:43:20,140 --> 00:43:23,499
we will know will happen to the i/o

00:43:22,089 --> 00:43:24,999
scheduler so that that our scheduler

00:43:23,499 --> 00:43:28,380
which has much more information about

00:43:24,999 --> 00:43:33,339
the actual seek times of the disk to

00:43:28,380 --> 00:43:37,390
make the decisions but we we talk to the

00:43:33,339 --> 00:43:38,410
couple of kernel guys like like and your

00:43:37,390 --> 00:43:40,779
what's his name

00:43:38,410 --> 00:43:43,029
anyways I scheduled a guy's about a

00:43:40,779 --> 00:43:45,640
whole list all of this and to be honest

00:43:43,029 --> 00:43:47,650
the interest in rehab is not the biggest

00:43:45,640 --> 00:43:49,539
because they always say is well if you

00:43:47,650 --> 00:43:52,119
want it fast use SSD and all this

00:43:49,539 --> 00:43:53,950
problems go away anyway so yeah I hope

00:43:52,119 --> 00:43:56,920
this kind of answered the question but

00:43:53,950 --> 00:43:58,719
well I have a follow-up I was I was

00:43:56,920 --> 00:44:00,369
probably speaking more directly in terms

00:43:58,719 --> 00:44:01,930
of d-bus because obviously the way that

00:44:00,369 --> 00:44:03,729
systemd works she started everything in

00:44:01,930 --> 00:44:05,920
parallel upfront that socket activated

00:44:03,729 --> 00:44:09,190
but then d-bus sort of trickles along

00:44:05,920 --> 00:44:10,989
you know as as dependencies arise as

00:44:09,190 --> 00:44:12,609
things actually get called and then the

00:44:10,989 --> 00:44:14,890
then the process actually starts to

00:44:12,609 --> 00:44:16,779
handle the d-bus requests so essentially

00:44:14,890 --> 00:44:19,930
assuming for instance a typical desktop

00:44:16,779 --> 00:44:22,509
a boot scenario your desktop basically

00:44:19,930 --> 00:44:26,099
becomes available after the last demon

00:44:22,509 --> 00:44:28,390
that had some request was started right

00:44:26,099 --> 00:44:30,160
so in that sense you are you are

00:44:28,390 --> 00:44:31,779
parallelizing everything up front with

00:44:30,160 --> 00:44:33,219
socket activation but with d-bus you're

00:44:31,779 --> 00:44:36,249
actually creating a long trail of

00:44:33,219 --> 00:44:38,349
dependencies so it has been any thought

00:44:36,249 --> 00:44:39,759
about optimizing that well I mean we

00:44:38,349 --> 00:44:41,799
can't start deep us at the same time so

00:44:39,759 --> 00:44:44,200
at the processes also I mean there's a

00:44:41,799 --> 00:44:47,109
lot of stuff in the desktop can also

00:44:44,200 --> 00:44:49,509
peer up while still for examples audio

00:44:47,109 --> 00:44:50,380
starting because if it pulls all your

00:44:49,509 --> 00:44:52,480
starting you want to

00:44:50,380 --> 00:44:55,330
the welcome sounds there's no needs that

00:44:52,480 --> 00:44:58,510
this in any way actually delays the

00:44:55,330 --> 00:44:59,920
graphical stuff but yeah I mean D Bazaar

00:44:58,510 --> 00:45:02,140
Center it's probably the central

00:44:59,920 --> 00:45:04,240
dependency of the desktop and in this

00:45:02,140 --> 00:45:06,370
area but I mean yeah we can't paralyze

00:45:04,240 --> 00:45:07,660
that already and yeah of course it's a

00:45:06,370 --> 00:45:10,210
bottleneck and a couple of people

00:45:07,660 --> 00:45:11,800
working a diva's optimization but to be

00:45:10,210 --> 00:45:13,300
honest d-bus actually starts really

00:45:11,800 --> 00:45:15,610
really fast these days there's not

00:45:13,300 --> 00:45:18,430
I don't feel too concerned about that I

00:45:15,610 --> 00:45:22,180
think are there any questions at this

00:45:18,430 --> 00:45:24,750
moment I don't see anything so let's go

00:45:22,180 --> 00:45:24,750
to the next slide

00:45:28,830 --> 00:45:33,090
so yeah one nice thing that we actually

00:45:30,750 --> 00:45:35,220
can do is paralyze file system jobs so

00:45:33,090 --> 00:45:37,020
if you have a have a computer these days

00:45:35,220 --> 00:45:39,180
and has a couple of hard disks then you

00:45:37,020 --> 00:45:40,650
actually run a fast check at boot and

00:45:39,180 --> 00:45:42,210
then the entire boot waits until the

00:45:40,650 --> 00:45:42,750
fast check finishes and then your mild

00:45:42,210 --> 00:45:45,420
everything

00:45:42,750 --> 00:45:47,670
as mentioned system D actually supports

00:45:45,420 --> 00:45:50,580
Auto mounting and that enables us to

00:45:47,670 --> 00:45:52,560
actually paralyze the FS check with the

00:45:50,580 --> 00:45:54,090
actual start up of the system because of

00:45:52,560 --> 00:45:55,500
what we need to do we need to of course

00:45:54,090 --> 00:45:58,200
through the FS check of the root

00:45:55,500 --> 00:46:00,390
filesystem but we do not actually need

00:45:58,200 --> 00:46:02,460
to wait until /home becomes available

00:46:00,390 --> 00:46:04,800
because what we can do here is we start

00:46:02,460 --> 00:46:06,210
a fast check to do two file system

00:46:04,800 --> 00:46:08,970
checks our home directory at their home

00:46:06,210 --> 00:46:10,560
file system and while that is active we

00:46:08,970 --> 00:46:12,900
already install the Ottoman point four

00:46:10,560 --> 00:46:14,910
slash show and continue booting and then

00:46:12,900 --> 00:46:16,950
everything will work fine and the moment

00:46:14,910 --> 00:46:19,200
some service or some some user logging

00:46:16,950 --> 00:46:21,660
in actually accesses it because for

00:46:19,200 --> 00:46:23,880
example Samba wants to share it in that

00:46:21,660 --> 00:46:25,950
moment Samba will do the file system

00:46:23,880 --> 00:46:28,410
access this request via the automata

00:46:25,950 --> 00:46:30,930
will go to system D while while that

00:46:28,410 --> 00:46:32,460
that actually happens Samba will wait

00:46:30,930 --> 00:46:34,320
for that it will automatically freeze by

00:46:32,460 --> 00:46:36,330
the kernel and eventually when when

00:46:34,320 --> 00:46:38,010
system V them then then call up when the

00:46:36,330 --> 00:46:40,140
file system check finished and it

00:46:38,010 --> 00:46:42,930
replaced the Ottoman point by the real

00:46:40,140 --> 00:46:46,230
amount the execution of Samba will just

00:46:42,930 --> 00:46:47,520
go on so all these kind of paralyzation

00:46:46,230 --> 00:46:49,620
that we have with socket based

00:46:47,520 --> 00:46:51,120
activation of aspect is bus bus based

00:46:49,620 --> 00:46:52,560
activation well we can start this lock

00:46:51,120 --> 00:46:55,440
and divas and all the stuff in parallel

00:46:52,560 --> 00:46:57,210
we can extend to the file systems we can

00:46:55,440 --> 00:47:00,230
run FS check the quota check and

00:46:57,210 --> 00:47:02,730
everything else at the same time as as

00:47:00,230 --> 00:47:04,500
other stuff that is started on the

00:47:02,730 --> 00:47:08,840
starting on the system is still in

00:47:04,500 --> 00:47:08,840
progress the earth question

00:47:09,480 --> 00:47:13,600
and there's another one just a question

00:47:12,520 --> 00:47:16,600
about that

00:47:13,600 --> 00:47:19,480
how does system D interact with early

00:47:16,600 --> 00:47:21,910
user space and as an example for

00:47:19,480 --> 00:47:26,710
instance like crypto roots and things

00:47:21,910 --> 00:47:28,060
like that so so system D nowadays is not

00:47:26,710 --> 00:47:30,130
only this that's in a system that you

00:47:28,060 --> 00:47:31,360
can install and where you then then can

00:47:30,130 --> 00:47:32,710
integrate your plastic shell scripts

00:47:31,360 --> 00:47:34,630
with you can't do that if you want

00:47:32,710 --> 00:47:36,430
system D nowadays tries to to

00:47:34,630 --> 00:47:39,220
standardize the entire boot process for

00:47:36,430 --> 00:47:40,540
you we looked we looked at all the all

00:47:39,220 --> 00:47:42,280
the boot process of the different

00:47:40,540 --> 00:47:43,900
distributions and they they all have

00:47:42,280 --> 00:47:45,640
these gigantic inner scripts that do the

00:47:43,900 --> 00:47:47,350
early boot stuff and we looked at the

00:47:45,640 --> 00:47:49,120
end notice they all do the same thing

00:47:47,350 --> 00:47:50,830
and they all do it completely

00:47:49,120 --> 00:47:54,100
differently and in a gigantic shell

00:47:50,830 --> 00:47:56,380
script that is horrible mess usually so

00:47:54,100 --> 00:47:58,060
so what we did is we said we can do this

00:47:56,380 --> 00:48:00,400
better because shell scripting is not

00:47:58,060 --> 00:48:02,410
necessarily nice shell scripting is

00:48:00,400 --> 00:48:04,000
necessarily slow it's necessarily

00:48:02,410 --> 00:48:06,070
because it involves a shitload of

00:48:04,000 --> 00:48:07,660
forking of processes we saw we can do to

00:48:06,070 --> 00:48:10,120
do this nicer so what we did we looked

00:48:07,660 --> 00:48:11,890
at this over long a time and always pick

00:48:10,120 --> 00:48:13,720
those little little pieces out of it and

00:48:11,890 --> 00:48:16,210
implemented that in C code for example

00:48:13,720 --> 00:48:18,550
most trivial thing setting the hostname

00:48:16,210 --> 00:48:20,290
we saw well if it's just about reading

00:48:18,550 --> 00:48:22,600
one configuration file and calling the

00:48:20,290 --> 00:48:24,940
set hostname system call why do we need

00:48:22,600 --> 00:48:25,930
to do photo process and then we looked

00:48:24,940 --> 00:48:27,250
into a couple of other things like this

00:48:25,930 --> 00:48:29,320
and then said okay let's let's find a

00:48:27,250 --> 00:48:30,670
nice f5 or you can just do this in C and

00:48:29,320 --> 00:48:32,650
for the hostname stuff for example we

00:48:30,670 --> 00:48:34,450
said okay it's in system D itself system

00:48:32,650 --> 00:48:36,670
B itself when it's boota boota will now

00:48:34,450 --> 00:48:37,720
set the hostname for you and so you

00:48:36,670 --> 00:48:38,380
don't need to do that in the shell

00:48:37,720 --> 00:48:41,920
script anymore

00:48:38,380 --> 00:48:44,850
so we covered actually everything now

00:48:41,920 --> 00:48:47,110
that is in the default Fedora boot

00:48:44,850 --> 00:48:51,160
everything if you if you if you if um

00:48:47,110 --> 00:48:52,780
boot f15 not a single shell and it

00:48:51,160 --> 00:48:54,340
didn't install any any kind of magic

00:48:52,780 --> 00:48:57,580
stuff like NFS or for example like that

00:48:54,340 --> 00:48:59,680
and you will not install a I have

00:48:57,580 --> 00:49:01,330
executed a single shell while the system

00:48:59,680 --> 00:49:04,420
boots up because everything is now done

00:49:01,330 --> 00:49:06,970
properly in C for the DM crypt stuff we

00:49:04,420 --> 00:49:09,460
actually provided something system T's

00:49:06,970 --> 00:49:13,240
nowadays extensible so you can actually

00:49:09,460 --> 00:49:15,280
create during boot up system the unit's

00:49:13,240 --> 00:49:17,260
system the these these units are as

00:49:15,280 --> 00:49:19,450
basically what what system D covers a

00:49:17,260 --> 00:49:20,960
unit is a service the unit is a socket

00:49:19,450 --> 00:49:22,430
unit is a mount point and stuff like

00:49:20,960 --> 00:49:25,640
any connect dependencies between them if

00:49:22,430 --> 00:49:28,099
you want to so you have we have this

00:49:25,640 --> 00:49:30,320
plugin which looks at et Cie crypto and

00:49:28,099 --> 00:49:32,119
automatically generates on-the-fly units

00:49:30,320 --> 00:49:34,250
of it and system leaves and weeds and

00:49:32,119 --> 00:49:36,920
and can integrate that into the usual

00:49:34,250 --> 00:49:41,030
flow the effect of all of this is that

00:49:36,920 --> 00:49:42,920
the that the the crypto loop stuff can

00:49:41,030 --> 00:49:44,480
be executed in parallel with FS checking

00:49:42,920 --> 00:49:46,040
the next filesystem already because

00:49:44,480 --> 00:49:47,480
instead of having this gigantic script

00:49:46,040 --> 00:49:49,640
where everything bit by bit

00:49:47,480 --> 00:49:51,800
is executed we can actually paralyze

00:49:49,640 --> 00:49:53,510
that completely and because all this

00:49:51,800 --> 00:49:55,880
unit stuff and system Lee is perfectly

00:49:53,510 --> 00:49:57,920
parallelized this is actually quite an

00:49:55,880 --> 00:49:59,450
improvement so yeah and interesting the

00:49:57,920 --> 00:50:01,040
by default if you install things you

00:49:59,450 --> 00:50:02,859
actually get support for crypto stuff

00:50:01,040 --> 00:50:04,970
it's it's optional dependency and

00:50:02,859 --> 00:50:06,920
probably all the Nvidia people don't

00:50:04,970 --> 00:50:08,780
want to use it because they don't need

00:50:06,920 --> 00:50:11,650
crypto stuff but on the desktops we

00:50:08,780 --> 00:50:14,780
probably all want and so we support that

00:50:11,650 --> 00:50:17,930
what you some example is it really good

00:50:14,780 --> 00:50:19,880
idea to start up standby filesystem

00:50:17,930 --> 00:50:22,130
really isn't accessible and you won't be

00:50:19,880 --> 00:50:23,990
four minutes or potentially hours if

00:50:22,130 --> 00:50:26,599
it's running if it's game waiting for it

00:50:23,990 --> 00:50:29,900
to finish and that's a question for

00:50:26,599 --> 00:50:32,540
other services the world sometimes you

00:50:29,900 --> 00:50:34,010
really want it to be available if it

00:50:32,540 --> 00:50:37,310
will have a response time that's

00:50:34,010 --> 00:50:39,710
reasonable to the system as it is set up

00:50:37,310 --> 00:50:42,410
I mean do you take that into account

00:50:39,710 --> 00:50:44,180
I'm not sure I answer the question you

00:50:42,410 --> 00:50:47,810
give the example of Samba starting beat

00:50:44,180 --> 00:50:51,050
up and it will automatically block if it

00:50:47,810 --> 00:50:53,480
tries to access in filing the automated

00:50:51,050 --> 00:50:56,540
file system because the file system is

00:50:53,480 --> 00:51:00,800
being checked yeah but that might might

00:50:56,540 --> 00:51:02,839
take minutes or hours so sometimes it

00:51:00,800 --> 00:51:04,820
might some administrators might not

00:51:02,839 --> 00:51:07,609
consider it a good idea to pretend that

00:51:04,820 --> 00:51:09,290
the service is available even though it

00:51:07,609 --> 00:51:10,880
won't actually be in practice so my

00:51:09,290 --> 00:51:12,320
reply to that is in the traditional

00:51:10,880 --> 00:51:13,790
valid if the file system check really

00:51:12,320 --> 00:51:16,520
takes takes half an hour or something

00:51:13,790 --> 00:51:19,910
then the traditional system your boot

00:51:16,520 --> 00:51:22,430
took half an hour to boot so we allow

00:51:19,910 --> 00:51:23,599
you to already run the sambar much much

00:51:22,430 --> 00:51:25,520
earlier point or something else for

00:51:23,599 --> 00:51:27,290
example you can already ssh login at

00:51:25,520 --> 00:51:29,570
this at the point where summer is still

00:51:27,290 --> 00:51:31,880
waiting for the FS check to complete but

00:51:29,570 --> 00:51:33,260
my reply to that is insistently all

00:51:31,880 --> 00:51:35,210
operations really

00:51:33,260 --> 00:51:36,800
all of them actually timeout it and you

00:51:35,210 --> 00:51:38,690
can actually configure that to the

00:51:36,800 --> 00:51:41,600
effect that if something really takes

00:51:38,690 --> 00:51:43,820
ages we will just go on booting for

00:51:41,600 --> 00:51:46,340
example or basically configure about

00:51:43,820 --> 00:51:48,340
what happens so the idea in this case is

00:51:46,340 --> 00:51:51,410
if the file system check takes too long

00:51:48,340 --> 00:51:53,300
we will actually fail this request

00:51:51,410 --> 00:51:55,250
December summer will get a clean error

00:51:53,300 --> 00:51:57,410
code but we'll just get this thing like

00:51:55,250 --> 00:51:59,450
yeah not available yaaaaa or something

00:51:57,410 --> 00:52:00,980
like that and can continue from that but

00:51:59,450 --> 00:52:03,640
yeah I don't think that actually really

00:52:00,980 --> 00:52:05,720
something changes that if samba

00:52:03,640 --> 00:52:07,490
previously had to wait completely for

00:52:05,720 --> 00:52:09,320
their first check to to wait for half an

00:52:07,490 --> 00:52:11,120
hour this is still what happens exactly

00:52:09,320 --> 00:52:12,500
except that this delay to the moment

00:52:11,120 --> 00:52:14,600
where actually accesses the file system

00:52:12,500 --> 00:52:17,060
well there is a difference in that Samba

00:52:14,600 --> 00:52:20,020
is actually appears on the network it's

00:52:17,060 --> 00:52:23,060
visible so clients might try to use it

00:52:20,020 --> 00:52:25,250
well that there is some some point in

00:52:23,060 --> 00:52:27,380
that but yeah to be honest I don't think

00:52:25,250 --> 00:52:29,240
that in the future all the file system

00:52:27,380 --> 00:52:31,400
checks will be that's slower I don't

00:52:29,240 --> 00:52:33,670
know but yeah it's it's about a point

00:52:31,400 --> 00:52:35,750
that you would will appear valid

00:52:33,670 --> 00:52:37,040
accessible for a while but if you

00:52:35,750 --> 00:52:40,580
actually access that it will timeout

00:52:37,040 --> 00:52:42,890
after a minute that is true okay my time

00:52:40,580 --> 00:52:44,180
is up so thank you very much for your

00:52:42,890 --> 00:52:47,450
interest and if you have any questions

00:52:44,180 --> 00:52:49,430
then I won't bite and just ask me or Kai

00:52:47,450 --> 00:52:50,790
and yeah we'll be available for

00:52:49,430 --> 00:52:54,829
questions all the time thank you

00:52:50,790 --> 00:52:54,829
[Applause]

00:53:00,270 --> 00:53:02,330

YouTube URL: https://www.youtube.com/watch?v=TyMLi8QF6sw


