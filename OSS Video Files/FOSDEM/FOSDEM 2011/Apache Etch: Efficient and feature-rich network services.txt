Title: Apache Etch: Efficient and feature-rich network services
Publication date: 2011-12-22
Playlist: FOSDEM 2011
Description: 
	By Holger Grandy

The talk introduces the Etch framework and shows the simple steps which have to be done to enable an application to be used as a network service. It shows the features of Etch, such as fully bidirectional client to server communication, synchronous and asynchronous calls, data modelling, error handling and performance. The talk gives an overview on the Etch architecture and the implementations of different language bindings, such as Java, C#, C and Go.

Etch is a cross-platform, language- and transport-independent framework for developing RPC-like network services. It includes a network service description language for service and data modelling, a compiler, and binding libraries for a variety of programming languages. It supports bidirectional one-way and two-way communication as well as blocking and non-blocking service calls, has high performance and scalability and is easy and intuitive to use. Clients and servers can run in a wide range of contexts (such as thin web client, embedded device, PC application, or server).


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:06,960 --> 00:00:14,190
well first of all hi everybody and first

00:00:10,480 --> 00:00:14,190
of all thanks a lot to all the fastest

00:00:15,280 --> 00:00:21,039
work that you're doing well I'm a

00:00:18,820 --> 00:00:22,960
software engineer at BMW karate and I

00:00:21,039 --> 00:00:25,779
want to tell you today about a piece of

00:00:22,960 --> 00:00:27,520
software that we have come about in the

00:00:25,779 --> 00:00:29,800
last few years which is Apache edge

00:00:27,520 --> 00:00:33,390
which is a framework for building up

00:00:29,800 --> 00:00:35,500
network services in a RPC style fashion

00:00:33,390 --> 00:00:36,730
and I want to tell you today what edge

00:00:35,500 --> 00:00:38,620
is I want to give you a basic

00:00:36,730 --> 00:00:40,149
introduction on what features are and

00:00:38,620 --> 00:00:43,600
how you can use it in your application

00:00:40,149 --> 00:00:46,000
to make your code very easily network

00:00:43,600 --> 00:00:48,190
service ready so you can use your your

00:00:46,000 --> 00:00:51,489
function than your functionality just as

00:00:48,190 --> 00:00:54,730
a network service in a very easy way so

00:00:51,489 --> 00:00:56,440
what is edge and first of all its

00:00:54,730 --> 00:00:59,920
framework for building network services

00:00:56,440 --> 00:01:01,960
and everything about that you probably

00:00:59,920 --> 00:01:04,809
come to the question why on earth should

00:01:01,960 --> 00:01:06,580
anybody again implement the framework

00:01:04,809 --> 00:01:08,979
for building network services thousands

00:01:06,580 --> 00:01:11,710
of that out there so probably all of you

00:01:08,979 --> 00:01:14,340
know car brah probably Oliver you know

00:01:11,710 --> 00:01:18,580
web services and there are many others

00:01:14,340 --> 00:01:21,399
but edge is at least for our use case

00:01:18,580 --> 00:01:23,799
which is making efficient transport

00:01:21,399 --> 00:01:26,829
independent network services based on a

00:01:23,799 --> 00:01:28,479
binary efficient protocol it is the

00:01:26,829 --> 00:01:30,880
choice that we made and it worked out

00:01:28,479 --> 00:01:33,850
really pretty well for us and it scales

00:01:30,880 --> 00:01:36,130
from from phones to back-end service and

00:01:33,850 --> 00:01:38,820
it has features that i want to show you

00:01:36,130 --> 00:01:41,439
today which distinguish it in its hole

00:01:38,820 --> 00:01:43,899
from other services travis frameworks

00:01:41,439 --> 00:01:46,450
that you probably know so what is edge

00:01:43,899 --> 00:01:48,820
first of all the key feature of edges

00:01:46,450 --> 00:01:50,469
that it's being symmetric so in

00:01:48,820 --> 00:01:52,299
traditional service frameworks you have

00:01:50,469 --> 00:01:54,219
a client and you have a server and you

00:01:52,299 --> 00:01:56,649
open up a connection then the client

00:01:54,219 --> 00:01:58,240
asks the server it caused functions and

00:01:56,649 --> 00:02:00,579
stuff and gets responses in edge it's

00:01:58,240 --> 00:02:02,950
symmetric so you open up a connection

00:02:00,579 --> 00:02:05,530
and after that the client and the server

00:02:02,950 --> 00:02:08,380
have no specific role they can talk to

00:02:05,530 --> 00:02:10,479
each other in both directions then you

00:02:08,380 --> 00:02:13,090
can choose whether you want synchronous

00:02:10,479 --> 00:02:15,430
in one week synchronous two-way or as

00:02:13,090 --> 00:02:18,670
nkrumah's one-way calls which has a big

00:02:15,430 --> 00:02:20,380
impact on the efficiency and the

00:02:18,670 --> 00:02:21,880
performance of your application I will

00:02:20,380 --> 00:02:23,800
come to that later on in edge you can

00:02:21,880 --> 00:02:25,870
choose whether you want the one or the

00:02:23,800 --> 00:02:26,910
other just but what is your application

00:02:25,870 --> 00:02:28,950
demand

00:02:26,910 --> 00:02:31,170
then you have a pretty good support for

00:02:28,950 --> 00:02:33,570
error handling which is based on the

00:02:31,170 --> 00:02:36,510
idea of exceptions which you know from

00:02:33,570 --> 00:02:38,970
Java or other languages and this really

00:02:36,510 --> 00:02:41,490
makes the the idea of exceptions

00:02:38,970 --> 00:02:43,080
transform transform to the area of

00:02:41,490 --> 00:02:45,660
network services so you have services

00:02:43,080 --> 00:02:48,510
which comes not only return regularly

00:02:45,660 --> 00:02:51,390
results but only also throw exceptions

00:02:48,510 --> 00:02:53,430
then you have pretty good timing

00:02:51,390 --> 00:02:56,160
constraint features in apps you can

00:02:53,430 --> 00:02:58,380
specify methods for certain timing

00:02:56,160 --> 00:03:01,140
assumptions you can say I want this mess

00:02:58,380 --> 00:03:03,030
of to return the value and under one

00:03:01,140 --> 00:03:06,900
second for example otherwise I will get

00:03:03,030 --> 00:03:09,330
an exception and of course because this

00:03:06,900 --> 00:03:11,610
network service description it's a

00:03:09,330 --> 00:03:13,590
network service framework you have a

00:03:11,610 --> 00:03:16,380
language for describing your network

00:03:13,590 --> 00:03:18,450
services because sort of an idea I will

00:03:16,380 --> 00:03:20,790
show that later on as fast and efficient

00:03:18,450 --> 00:03:22,440
as I said and that's the nice thing it

00:03:20,790 --> 00:03:24,510
doesn't require you to install a

00:03:22,440 --> 00:03:27,000
application server or whatever in the

00:03:24,510 --> 00:03:29,220
back end it's just it's one single

00:03:27,000 --> 00:03:30,510
library that can you can use transport

00:03:29,220 --> 00:03:32,070
and language and depend on all your

00:03:30,510 --> 00:03:33,930
devices you can use it in phones you can

00:03:32,070 --> 00:03:36,720
use it in back in service and they all

00:03:33,930 --> 00:03:38,580
will be compatible biitch it has a

00:03:36,720 --> 00:03:40,260
modular architecture and s and said it's

00:03:38,580 --> 00:03:42,209
try to be language and transferred

00:03:40,260 --> 00:03:43,770
independent so i will get more into

00:03:42,209 --> 00:03:46,860
detail about all those features that

00:03:43,770 --> 00:03:49,260
have showed you in a more concrete way

00:03:46,860 --> 00:03:52,050
so the very basic thing that you can do

00:03:49,260 --> 00:03:53,730
in a CH is what you see at the very top

00:03:52,050 --> 00:03:56,700
of this slide you can write network

00:03:53,730 --> 00:03:58,350
service descriptions in this case you

00:03:56,700 --> 00:04:02,130
just have a service which is called

00:03:58,350 --> 00:04:05,190
hello world here and it has a method

00:04:02,130 --> 00:04:07,380
which is called hello passes a string

00:04:05,190 --> 00:04:09,570
and returns a string and you probably

00:04:07,380 --> 00:04:11,880
guess what's happening on the wire so

00:04:09,570 --> 00:04:14,940
you have notes in your network and here

00:04:11,880 --> 00:04:17,220
is for example tcp/ip communication and

00:04:14,940 --> 00:04:18,900
in our service framework and what

00:04:17,220 --> 00:04:20,970
happens on the wire is that you say

00:04:18,900 --> 00:04:22,950
hello to your server your serve response

00:04:20,970 --> 00:04:25,380
thread process is to request and tells

00:04:22,950 --> 00:04:27,780
you hello client well this is this is

00:04:25,380 --> 00:04:30,240
probably what all of you know from from

00:04:27,780 --> 00:04:31,860
various our pc-based frameworks you can

00:04:30,240 --> 00:04:35,340
do this natch too but there is more that

00:04:31,860 --> 00:04:37,080
you can do first of all I told you echa

00:04:35,340 --> 00:04:40,150
symmetric what's that what does that

00:04:37,080 --> 00:04:42,910
mean so you can define services

00:04:40,150 --> 00:04:45,850
in your radio and you can annotate them

00:04:42,910 --> 00:04:48,550
by using direction primitives so you can

00:04:45,850 --> 00:04:52,270
say this hello method is something that

00:04:48,550 --> 00:04:54,550
i can send to the server and this ask

00:04:52,270 --> 00:04:57,070
something method is something that i can

00:04:54,550 --> 00:04:59,230
send to the client so here you see that

00:04:57,070 --> 00:05:00,670
in edge it doesn't make a difference who

00:04:59,230 --> 00:05:02,830
is the server who's the client you just

00:05:00,670 --> 00:05:05,290
communicate on the wire and then in the

00:05:02,830 --> 00:05:07,210
end of this will look up on the wire you

00:05:05,290 --> 00:05:09,160
have here the client and here the server

00:05:07,210 --> 00:05:11,380
and you say hello to the server says

00:05:09,160 --> 00:05:13,870
hello to the client and in a completely

00:05:11,380 --> 00:05:16,060
dif that for example you could say ask

00:05:13,870 --> 00:05:18,040
something to the client and exactly the

00:05:16,060 --> 00:05:19,450
same things are happening on the client

00:05:18,040 --> 00:05:21,370
side so this is really symmetric and

00:05:19,450 --> 00:05:23,350
makes it really convenient and easy to

00:05:21,370 --> 00:05:25,030
use it's especially very good if you're

00:05:23,350 --> 00:05:28,170
having interactive application is

00:05:25,030 --> 00:05:30,520
interactive functionality interactive

00:05:28,170 --> 00:05:34,690
applications that require that you

00:05:30,520 --> 00:05:38,110
communicate in both ways then you can

00:05:34,690 --> 00:05:40,330
say I want to choose how my function

00:05:38,110 --> 00:05:42,490
calls are delivered so for example if

00:05:40,330 --> 00:05:44,050
you what I've shown you before is that

00:05:42,490 --> 00:05:45,910
you have synchronous calls which are

00:05:44,050 --> 00:05:47,440
blocking which are waiting for the

00:05:45,910 --> 00:05:49,720
result of the functioning as you can

00:05:47,440 --> 00:05:51,970
choose whether you want those function

00:05:49,720 --> 00:05:53,320
to be blocking or not if you don't want

00:05:51,970 --> 00:05:55,510
them to be blocking you just annotate

00:05:53,320 --> 00:05:57,190
the function with one way and then what

00:05:55,510 --> 00:05:59,980
happens on the wire is that you have a

00:05:57,190 --> 00:06:02,620
synchronous function calls here and you

00:05:59,980 --> 00:06:05,020
see here it doesn't wait for your

00:06:02,620 --> 00:06:07,420
function to return it just sends out a

00:06:05,020 --> 00:06:09,760
message forgets it fire-and-forget and

00:06:07,420 --> 00:06:11,890
then on the server it is processed and

00:06:09,760 --> 00:06:13,840
some time because this is Direction

00:06:11,890 --> 00:06:16,600
client method that howdy as a response

00:06:13,840 --> 00:06:18,850
to hello the server will answer as

00:06:16,600 --> 00:06:20,980
synchronously and the client will

00:06:18,850 --> 00:06:22,690
process the dancer also a synchronously

00:06:20,980 --> 00:06:24,490
and in edge you can choose whatever you

00:06:22,690 --> 00:06:26,710
want what fits your application best you

00:06:24,490 --> 00:06:29,170
can choose and you get your code

00:06:26,710 --> 00:06:34,900
generated from that service description

00:06:29,170 --> 00:06:38,590
here so another feature that at chess is

00:06:34,900 --> 00:06:42,040
data modeling and error handling which I

00:06:38,590 --> 00:06:44,290
want to show you now first of all data

00:06:42,040 --> 00:06:46,240
modeling data modeling is inspired by

00:06:44,290 --> 00:06:49,450
object-oriented languages so you can

00:06:46,240 --> 00:06:51,040
define structs but you can also use all

00:06:49,450 --> 00:06:53,440
the object-oriented features like

00:06:51,040 --> 00:06:55,000
inheritance and all that stuff here to

00:06:53,440 --> 00:06:57,490
make a simple example we have a

00:06:55,000 --> 00:07:00,250
structures called user and that user is

00:06:57,490 --> 00:07:03,040
a property which is his name and you

00:07:00,250 --> 00:07:06,210
have that hello method here which which

00:07:03,040 --> 00:07:10,570
the user is supplied as a parameter okay

00:07:06,210 --> 00:07:12,610
but you can also define exceptions as I

00:07:10,570 --> 00:07:14,560
said you can define exceptions just like

00:07:12,610 --> 00:07:16,930
normal data so you say exception user

00:07:14,560 --> 00:07:19,450
unknown exception also provide a string

00:07:16,930 --> 00:07:21,340
for the exception message and then you

00:07:19,450 --> 00:07:23,320
annotate your function here with

00:07:21,340 --> 00:07:26,830
enormous roast activation just as you

00:07:23,320 --> 00:07:28,390
know it from driver and on the wire it's

00:07:26,830 --> 00:07:30,190
possible that you say hello to the

00:07:28,390 --> 00:07:32,170
server and of course this one can then

00:07:30,190 --> 00:07:33,910
say I don't know you this is a user

00:07:32,170 --> 00:07:36,100
unknown exception so you can really use

00:07:33,910 --> 00:07:39,090
that paradigm of object-oriented

00:07:36,100 --> 00:07:41,890
exception handling in a network service

00:07:39,090 --> 00:07:44,230
you can also annotate your services with

00:07:41,890 --> 00:07:46,510
timing constraints so you can say i want

00:07:44,230 --> 00:07:48,730
this hello method to answer with in a

00:07:46,510 --> 00:07:51,100
time-bound of 500 milliseconds for

00:07:48,730 --> 00:07:53,260
example and this will also throw an

00:07:51,100 --> 00:07:56,969
exception another exception time odd

00:07:53,260 --> 00:08:00,629
exception if this bound is over it

00:07:56,969 --> 00:08:03,989
so this is generally what edge to us on

00:08:00,629 --> 00:08:06,599
the network description layer and as I

00:08:03,989 --> 00:08:08,669
said this is compiled by by the edge

00:08:06,599 --> 00:08:11,339
compiler and you get code generator for

00:08:08,669 --> 00:08:14,009
various languages for example for C

00:08:11,339 --> 00:08:17,069
sharp for Java for Google go and we have

00:08:14,009 --> 00:08:19,019
also parts of implementations ready

00:08:17,069 --> 00:08:24,029
which are in a very early stage for

00:08:19,019 --> 00:08:28,049
pison and other things so this is what I

00:08:24,029 --> 00:08:30,509
wanted to say here google go is the

00:08:28,049 --> 00:08:33,419
earliest addition to our binding library

00:08:30,509 --> 00:08:35,969
the other three here Java C sharp and C

00:08:33,419 --> 00:08:38,490
are stable versions which you can use

00:08:35,969 --> 00:08:40,829
for whatever you want they they work

00:08:38,490 --> 00:08:43,259
they are stable and those things here

00:08:40,829 --> 00:08:45,449
JavaScript pious nasaan the development

00:08:43,259 --> 00:08:48,180
and Google go are available in an alpha

00:08:45,449 --> 00:08:50,279
state which implements the basic

00:08:48,180 --> 00:08:51,779
protocol functionality etches

00:08:50,279 --> 00:08:56,100
transferred independent so what I've

00:08:51,779 --> 00:08:58,470
showed you before is based on TCP I

00:08:56,100 --> 00:09:00,959
explain it on TCP but it doesn't

00:08:58,470 --> 00:09:02,970
necessarily have to be TCP it just has

00:09:00,959 --> 00:09:06,149
to be a stream protocol in some way you

00:09:02,970 --> 00:09:09,629
could do this on cereal yreka deuces and

00:09:06,149 --> 00:09:12,329
bluetooth you could do this on tcp it is

00:09:09,629 --> 00:09:15,329
also independent from the concrete

00:09:12,329 --> 00:09:18,389
transport format so what we do by

00:09:15,329 --> 00:09:20,579
default is encoding our our data or

00:09:18,389 --> 00:09:22,470
function calls on the wire using a

00:09:20,579 --> 00:09:25,379
binary encoding which makes it small

00:09:22,470 --> 00:09:27,870
which makes it efficient which gives you

00:09:25,379 --> 00:09:29,490
good performance numbers but you could

00:09:27,870 --> 00:09:32,670
have a different use case which requires

00:09:29,490 --> 00:09:35,040
you to use XML there is an XML binding

00:09:32,670 --> 00:09:36,959
available for example implemented in a

00:09:35,040 --> 00:09:38,850
JavaScript and C sharp bindings because

00:09:36,959 --> 00:09:40,649
of course in the browser scenario this

00:09:38,850 --> 00:09:43,170
would fit better than binary encodings

00:09:40,649 --> 00:09:45,209
but for example if you go embed it which

00:09:43,170 --> 00:09:47,370
you can wretch then of course this

00:09:45,209 --> 00:09:49,139
binary encoding is probably thing that

00:09:47,370 --> 00:09:51,420
you want so you can really choose and

00:09:49,139 --> 00:09:53,220
the technology as itself is independent

00:09:51,420 --> 00:09:55,680
from that feature from that very basic

00:09:53,220 --> 00:09:58,410
requirements we have tooling available

00:09:55,680 --> 00:10:00,720
so if you want to debug for example

00:09:58,410 --> 00:10:02,220
what's happening on my TCP transport in

00:10:00,720 --> 00:10:04,589
my application you have Wireshark

00:10:02,220 --> 00:10:06,760
support you can put in the the network

00:10:04,589 --> 00:10:09,130
description and you will get

00:10:06,760 --> 00:10:11,050
an interpretation of the traffic that is

00:10:09,130 --> 00:10:13,450
going under the wire using wireshark

00:10:11,050 --> 00:10:15,430
with basic maven integration we are

00:10:13,450 --> 00:10:18,580
currently working on providing nice

00:10:15,430 --> 00:10:20,470
Eclipse plugins for making riding the

00:10:18,580 --> 00:10:22,840
network service description easier and I

00:10:20,470 --> 00:10:26,260
am and running a compiler and all that

00:10:22,840 --> 00:10:29,380
stuff then we come to efficiency it's

00:10:26,260 --> 00:10:31,840
quite important I am the time and these

00:10:29,380 --> 00:10:33,730
15 minutes to make a big comparison with

00:10:31,840 --> 00:10:35,140
all the other frameworks that are out

00:10:33,730 --> 00:10:36,940
there there is data on the website

00:10:35,140 --> 00:10:40,410
regarding that but just to give you an

00:10:36,940 --> 00:10:43,690
impression we have different ways of

00:10:40,410 --> 00:10:45,880
calling functions as I said for example

00:10:43,690 --> 00:10:49,120
if you have a synchronous one-way calls

00:10:45,880 --> 00:10:51,220
were you just one after the other called

00:10:49,120 --> 00:10:53,470
functions on fire and forget them we

00:10:51,220 --> 00:10:56,440
come on a normal desktop system to

00:10:53,470 --> 00:10:58,530
around 40k function calls per second if

00:10:56,440 --> 00:11:01,660
you compare this to for example on

00:10:58,530 --> 00:11:03,790
http-based xml-based web service

00:11:01,660 --> 00:11:07,470
framework you will end up with a factor

00:11:03,790 --> 00:11:11,590
10 to 100 slower just give an impression

00:11:07,470 --> 00:11:14,500
and even the blocking calls we end up

00:11:11,590 --> 00:11:18,100
with 15k calls per second so this is

00:11:14,500 --> 00:11:20,350
really meant to be used in performance

00:11:18,100 --> 00:11:22,990
critical for example embedded

00:11:20,350 --> 00:11:25,540
applications but also in higher scaled

00:11:22,990 --> 00:11:27,050
networks just you can choose it's up to

00:11:25,540 --> 00:11:29,880
you

00:11:27,050 --> 00:11:32,010
the nice thing about edges when it goes

00:11:29,880 --> 00:11:34,410
to implementation we have a layered

00:11:32,010 --> 00:11:36,600
architecture so what you see here is the

00:11:34,410 --> 00:11:38,850
protocol stack on the server and on the

00:11:36,600 --> 00:11:40,920
client side and they are both symmetric

00:11:38,850 --> 00:11:44,160
as I said H doesn't distinguish between

00:11:40,920 --> 00:11:46,380
client and server very much so you have

00:11:44,160 --> 00:11:48,330
the exactly same architecture running on

00:11:46,380 --> 00:11:50,040
the client running on the server and you

00:11:48,330 --> 00:11:53,010
have layers which you can very easily

00:11:50,040 --> 00:11:55,230
exchange so for example if you want

00:11:53,010 --> 00:11:58,260
another transport you just take out the

00:11:55,230 --> 00:12:00,210
TCP stuff and plug in another transport

00:11:58,260 --> 00:12:02,160
which has a very good defined interface

00:12:00,210 --> 00:12:04,710
you can just implement a few methods

00:12:02,160 --> 00:12:07,380
that you need and then you take this out

00:12:04,710 --> 00:12:09,750
and put bluetooths or whatever in so you

00:12:07,380 --> 00:12:12,330
can choose here and then it goes up

00:12:09,750 --> 00:12:15,200
while the packet Iser which is

00:12:12,330 --> 00:12:17,340
responsible for making chunks of theta

00:12:15,200 --> 00:12:20,130
than the message eyes which is

00:12:17,340 --> 00:12:21,990
responsible for serialization and here

00:12:20,130 --> 00:12:24,150
you can also choose if you want XML if

00:12:21,990 --> 00:12:26,220
you want binary plug it in plug it out

00:12:24,150 --> 00:12:28,140
and then you have the mailbox manager

00:12:26,220 --> 00:12:30,720
which which handles the as in Khurana

00:12:28,140 --> 00:12:33,090
see in the whole thing so we have the

00:12:30,720 --> 00:12:34,830
concept of mailboxes and what you do is

00:12:33,090 --> 00:12:37,170
when you have your application which

00:12:34,830 --> 00:12:39,180
issues a call to the server then guess

00:12:37,170 --> 00:12:41,010
this goes over the remote into the

00:12:39,180 --> 00:12:43,470
delivery service and then it spawns a

00:12:41,010 --> 00:12:45,390
mailbox and this one just waits until

00:12:43,470 --> 00:12:47,220
someone on the other side will process

00:12:45,390 --> 00:12:49,020
that request and then the answer will

00:12:47,220 --> 00:12:51,090
come back and will be delivered to that

00:12:49,020 --> 00:12:52,380
very specific mailbox and the answer

00:12:51,090 --> 00:12:54,060
will be delivered back to the

00:12:52,380 --> 00:12:57,690
application and this is fully symmetric

00:12:54,060 --> 00:13:00,210
in both ways and those layers here the

00:12:57,690 --> 00:13:01,620
stops and remotes are generated from the

00:13:00,210 --> 00:13:03,390
network service description that you

00:13:01,620 --> 00:13:05,400
shouldn't all the other things are

00:13:03,390 --> 00:13:07,380
dependent on the protocol stack that

00:13:05,400 --> 00:13:09,540
you're currently using so you can choose

00:13:07,380 --> 00:13:11,540
whatever you want and you get that nice

00:13:09,540 --> 00:13:15,380
coat here up in the upper layers

00:13:11,540 --> 00:13:15,380
generated by the edge compiler

00:13:15,620 --> 00:13:22,740
what is going on in our roadmap where do

00:13:18,180 --> 00:13:25,230
we want to go of course most important

00:13:22,740 --> 00:13:27,270
is always getting more languages mod

00:13:25,230 --> 00:13:29,279
transports so making this thing really

00:13:27,270 --> 00:13:31,980
broad are available at the moment it's

00:13:29,279 --> 00:13:35,880
pretty good implemented using Java TCP

00:13:31,980 --> 00:13:37,980
CC sharp so you can choose but but it's

00:13:35,880 --> 00:13:39,779
it's tcp what we would want to have a

00:13:37,980 --> 00:13:43,650
serial implementation we want to have a

00:13:39,779 --> 00:13:45,600
UDP implementation for example also we

00:13:43,650 --> 00:13:47,760
won't want more languages as I said

00:13:45,600 --> 00:13:50,760
there are first steps or JavaScript and

00:13:47,760 --> 00:13:52,680
Python and you can even think of what

00:13:50,760 --> 00:13:54,600
you what you want in addition on top of

00:13:52,680 --> 00:13:58,380
that framework so you will come up

00:13:54,600 --> 00:14:00,330
pretty pretty pretty fast of something

00:13:58,380 --> 00:14:01,680
that you want a naming service for

00:14:00,330 --> 00:14:04,800
example you want discovery of your

00:14:01,680 --> 00:14:06,540
services we have ideas of implementing

00:14:04,800 --> 00:14:08,940
the discovery of the services with edge

00:14:06,540 --> 00:14:12,029
itself for example when you have a UDP

00:14:08,940 --> 00:14:13,740
multicast binding at the very lower

00:14:12,029 --> 00:14:15,900
level then you could implement the

00:14:13,740 --> 00:14:18,300
discovery with the technology itself it

00:14:15,900 --> 00:14:19,770
would be pretty nice you want web

00:14:18,300 --> 00:14:21,900
service Kate where you want more

00:14:19,770 --> 00:14:24,810
security there us is some basic security

00:14:21,900 --> 00:14:27,630
building but you probably want more you

00:14:24,810 --> 00:14:29,670
want better your IDE support and you can

00:14:27,630 --> 00:14:32,430
think of various other features that are

00:14:29,670 --> 00:14:34,050
on the road map and what I can say this

00:14:32,430 --> 00:14:37,200
is a project which is in the Apache

00:14:34,050 --> 00:14:38,730
Incubator which is a staging area you

00:14:37,200 --> 00:14:43,140
could say for new projects to enter

00:14:38,730 --> 00:14:45,089
Apache and we are still in a choice of

00:14:43,140 --> 00:14:47,220
what we want for the future to be

00:14:45,089 --> 00:14:49,589
developed so if you if you like edge and

00:14:47,220 --> 00:14:51,180
if you want something here we are pretty

00:14:49,589 --> 00:14:53,430
happy to get in contact with you you

00:14:51,180 --> 00:14:56,779
just join the mailing lists join edge

00:14:53,430 --> 00:15:00,660
def try and look at the website and

00:14:56,779 --> 00:15:03,180
contact us so this is really under

00:15:00,660 --> 00:15:05,070
development features so if you want to

00:15:03,180 --> 00:15:07,080
find out more there's a website which is

00:15:05,070 --> 00:15:11,839
that and there are mailing lists which

00:15:07,080 --> 00:15:11,839
are our primary source of development

00:15:11,960 --> 00:15:16,860
communication so if you're interested in

00:15:14,550 --> 00:15:19,440
edge drop in mail on edge to edge user

00:15:16,860 --> 00:15:22,950
whatever you're interested in and you

00:15:19,440 --> 00:15:25,380
will get whatever help that you need on

00:15:22,950 --> 00:15:27,540
these lists there are contributors the

00:15:25,380 --> 00:15:31,740
initial development of etch was done at

00:15:27,540 --> 00:15:34,530
Cisco at BWW used it for example for

00:15:31,740 --> 00:15:36,420
connecting phones two cars which is a

00:15:34,530 --> 00:15:39,060
very specific requirement we can also

00:15:36,420 --> 00:15:43,020
use it for connecting embedded devices

00:15:39,060 --> 00:15:45,900
to Internet services for example yeah so

00:15:43,020 --> 00:15:47,670
there is a community of people that are

00:15:45,900 --> 00:15:49,980
working on that and if you want to get

00:15:47,670 --> 00:15:53,150
in contact directing me are the mailing

00:15:49,980 --> 00:15:53,150

YouTube URL: https://www.youtube.com/watch?v=1h76ch2-G-M


