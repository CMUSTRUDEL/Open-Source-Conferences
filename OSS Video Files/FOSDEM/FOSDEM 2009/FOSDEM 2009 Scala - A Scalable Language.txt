Title: FOSDEM 2009 Scala - A Scalable Language
Publication date: 2011-12-22
Playlist: FOSDEM 2009
Description: 
	By Martin Odersky

In this talk I'll describe the design principles of the Scala programming language, which has scalability as its primary design objective.

Today's software landscape resembles increasingly a tower of Babel: Systems are built using many different languages, combining server-side and client-side languages, scripting and systems programming languages, general and domain specific languages, all glued together with a hefty amount of XML. The advantage of this approach is that each individual language can be tailored to a specific application domain. Its disadvantage is that the necessary amount of cross-language glue can make applications cumbersome to write, deploy, and maintain.

An alternative is offered by scalable languages, which can be used for many different applications, ranging from small scripts to very large systems. An important aspect of a scalable language is that it itself is extensible and malleable. It should be possible to define very high-level libraries in it, which act in effect as specialized domain specific languages. The advantages of this approach is that it leads to more regular system designs, gives better static checking, makes applications easier to deploy, and increases their reliability.

In this talk I'll describe the design principles of the Scala programming language, which has scalability as its primary design objective. Scala combines lightweight syntax with strong static checking on a Java-compatible platform. It encourages the embedding of domain-specific languages as high-level libraries. I discuss how Scala affects systems design and discuss its suitability for large scale industrial deployment.


FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:07,180 --> 00:00:09,720
so

00:00:10,530 --> 00:00:14,580
thanks for coming I'm marching

00:00:13,080 --> 00:00:18,160
I'm

00:00:14,580 --> 00:00:20,830
EPFL in luzon that's the logo down here

00:00:18,160 --> 00:00:24,340
and I have been working for the last

00:00:20,830 --> 00:00:26,970
five years or so on basically nothing

00:00:24,340 --> 00:00:30,310
else but the scalar language about that

00:00:26,970 --> 00:00:32,349
is this talk today so I'm here to tell

00:00:30,310 --> 00:00:34,330
you a bit about what is this what you

00:00:32,349 --> 00:00:35,980
can do with it and what its design

00:00:34,330 --> 00:00:39,010
philosophy is how it's different from

00:00:35,980 --> 00:00:40,920
other programming languages so if you

00:00:39,010 --> 00:00:43,900
look at the software landscape today

00:00:40,920 --> 00:00:46,750
then I think it resembles more and more

00:00:43,900 --> 00:00:48,399
a tower of babel with many little or

00:00:46,750 --> 00:00:51,070
sometimes not so little languages

00:00:48,399 --> 00:00:53,410
playing together moral as well so a

00:00:51,070 --> 00:00:55,600
typical setup would be that you have say

00:00:53,410 --> 00:00:57,610
javascript in the browser on the client

00:00:55,600 --> 00:00:59,710
and you would have some language for

00:00:57,610 --> 00:01:02,469
server-side scripting Perl Python Ruby

00:00:59,710 --> 00:01:04,750
groovy whatever if you're in a Java

00:01:02,469 --> 00:01:07,630
environment maybe have JavaFX for the UI

00:01:04,750 --> 00:01:09,729
that's still very new but it's it fills

00:01:07,630 --> 00:01:12,039
out its niche there you would have maybe

00:01:09,729 --> 00:01:15,670
Java for the business logic or something

00:01:12,039 --> 00:01:18,009
else c sharp c plus plus whatever SQL

00:01:15,670 --> 00:01:20,920
for database access and then you'll need

00:01:18,009 --> 00:01:23,010
to cover all this together with usually

00:01:20,920 --> 00:01:26,590
a generous helping of XML configuration

00:01:23,010 --> 00:01:29,950
files and so on so that's the situation

00:01:26,590 --> 00:01:31,990
today and it's both good and bad so the

00:01:29,950 --> 00:01:34,119
good part of it is that with all these

00:01:31,990 --> 00:01:36,100
little languages each one can specialize

00:01:34,119 --> 00:01:38,500
on what it does best you can have really

00:01:36,100 --> 00:01:41,080
specialized tools for these things the

00:01:38,500 --> 00:01:42,850
bad part comes when you have to do a

00:01:41,080 --> 00:01:45,040
large amount of cross language

00:01:42,850 --> 00:01:47,590
communication because that tends to be

00:01:45,040 --> 00:01:50,799
complicated in particular for deployment

00:01:47,590 --> 00:01:52,720
tends to be fragile and it's tends to be

00:01:50,799 --> 00:01:54,610
a large source of misunderstandings if

00:01:52,720 --> 00:01:57,579
the conventions in these languages don't

00:01:54,610 --> 00:01:59,530
quite play well together and the

00:01:57,579 --> 00:02:05,049
underlying or one of the underlying

00:01:59,530 --> 00:02:06,640
problems of this is that the in you

00:02:05,049 --> 00:02:08,829
usually with four languages you have

00:02:06,640 --> 00:02:11,230
type systems quite strong type systems

00:02:08,829 --> 00:02:13,480
either static or dynamic ones but type

00:02:11,230 --> 00:02:15,390
systems that catch you out normally when

00:02:13,480 --> 00:02:17,049
you do cross cross language compile a

00:02:15,390 --> 00:02:19,540
communication you don't have that

00:02:17,049 --> 00:02:21,940
anymore instead you communicate with

00:02:19,540 --> 00:02:25,270
very conceptually very low level things

00:02:21,940 --> 00:02:27,730
such as XML trees or even trees or even

00:02:25,270 --> 00:02:30,550
strings and then typically

00:02:27,730 --> 00:02:33,459
that's where the arrows creep in so it's

00:02:30,550 --> 00:02:36,099
a major hassle so the alternative would

00:02:33,459 --> 00:02:38,080
be to say well let's look at languages

00:02:36,099 --> 00:02:40,599
that are more scalable so that are more

00:02:38,080 --> 00:02:44,260
suitable for both very small as well as

00:02:40,599 --> 00:02:45,910
very large programs and you the idea

00:02:44,260 --> 00:02:47,590
would be to have a single language in

00:02:45,910 --> 00:02:49,569
which you can do the heavy lifting on

00:02:47,590 --> 00:02:51,940
the one side and the extension scripts

00:02:49,569 --> 00:02:54,549
on the other side so if you have an

00:02:51,940 --> 00:02:57,400
specific needs in your application then

00:02:54,549 --> 00:02:59,560
instead of an external domain specific

00:02:57,400 --> 00:03:01,629
language or a scripting language you

00:02:59,560 --> 00:03:03,849
would create an internal or hosted

00:03:01,629 --> 00:03:05,950
domain specific language which is

00:03:03,849 --> 00:03:09,099
implemented just as a library in your

00:03:05,950 --> 00:03:10,780
host language and the requirement for

00:03:09,099 --> 00:03:12,700
that then is that the host language is

00:03:10,780 --> 00:03:15,280
very very expressive that it can do

00:03:12,700 --> 00:03:18,239
these things so in Scala we've shown

00:03:15,280 --> 00:03:21,549
that this approach is in fact possible

00:03:18,239 --> 00:03:24,489
so one way to look at scala is to say

00:03:21,549 --> 00:03:26,709
well it's a scripting language in fact

00:03:24,489 --> 00:03:29,590
you it has an interactive read eval

00:03:26,709 --> 00:03:31,900
print loop you can infer the types and

00:03:29,590 --> 00:03:34,750
you don't have a lot of boilerplate so

00:03:31,900 --> 00:03:37,630
that's a typical setup of a scholar

00:03:34,750 --> 00:03:44,769
script you have a scholar prompt one

00:03:37,630 --> 00:03:47,410
just to show that this is real let's

00:03:44,769 --> 00:03:51,190
just go through one oops no it goes way

00:03:47,410 --> 00:03:54,040
why does it go away yeah why do it sorry

00:03:51,190 --> 00:03:55,510
I should have set this up before I here

00:03:54,040 --> 00:03:57,489
here we have on the lower part we have

00:03:55,510 --> 00:03:59,380
our our skyline interpret interpreter

00:03:57,489 --> 00:04:03,040
and I can't good for instance just write

00:03:59,380 --> 00:04:15,669
1 plus 2 or I could say a list of lists

00:04:03,040 --> 00:04:17,440
of one two three four each Oh map plus

00:04:15,669 --> 00:04:19,660
one and that gives me a list which is

00:04:17,440 --> 00:04:21,639
two two three four so I can just

00:04:19,660 --> 00:04:24,340
interact with these things interactively

00:04:21,639 --> 00:04:26,110
with a read eval print loop like what

00:04:24,340 --> 00:04:33,840
you are used to from a scripting

00:04:26,110 --> 00:04:36,960
language and that's just another another

00:04:33,840 --> 00:04:39,000
crypt here another way to look of Scala

00:04:36,960 --> 00:04:42,090
is to say well it's the Java of the

00:04:39,000 --> 00:04:44,040
future because basically everything Java

00:04:42,090 --> 00:04:46,680
has now sometimes in a slightly

00:04:44,040 --> 00:04:48,780
different form but it's there it has

00:04:46,680 --> 00:04:51,120
closures which have been proposed by

00:04:48,780 --> 00:04:54,360
many for Java 7 but in the end rejected

00:04:51,120 --> 00:04:56,520
for Java 7 it has the things called

00:04:54,360 --> 00:04:58,530
traits and pattern matching and tell you

00:04:56,520 --> 00:05:00,300
a little bit about that later and that

00:04:58,530 --> 00:05:04,260
wouldn't be surprised to see them these

00:05:00,300 --> 00:05:06,900
features in Java 8 9 or 10 it compiles

00:05:04,260 --> 00:05:10,050
to dot class files just like Java does

00:05:06,900 --> 00:05:12,930
it's completely interoperable and it's

00:05:10,050 --> 00:05:14,940
about as fast as Java so if you switch

00:05:12,930 --> 00:05:17,610
from Java to scholarly application

00:05:14,940 --> 00:05:20,220
typically you won't see any difference

00:05:17,610 --> 00:05:23,160
in in execution speed it's it's it's so

00:05:20,220 --> 00:05:26,280
it's sort of the same things so here you

00:05:23,160 --> 00:05:27,720
see a typical scholar program which

00:05:26,280 --> 00:05:28,889
highlights some of the things that are

00:05:27,720 --> 00:05:32,400
the same and also some of the

00:05:28,889 --> 00:05:34,740
differences you have an application it's

00:05:32,400 --> 00:05:37,260
called object app and it has a main

00:05:34,740 --> 00:05:40,200
method much like Java as a main method

00:05:37,260 --> 00:05:42,060
and then it's it's not just a hello

00:05:40,200 --> 00:05:45,210
world program because that would be too

00:05:42,060 --> 00:05:47,760
trivial but it's the next simplest

00:05:45,210 --> 00:05:50,250
program so i guess don't know whether

00:05:47,760 --> 00:05:53,180
you can read that so it asks whether in

00:05:50,250 --> 00:05:55,800
our argument array there is an argument

00:05:53,180 --> 00:05:58,669
such that the lower if you convert the

00:05:55,800 --> 00:06:01,289
argument to lower case it reads help so

00:05:58,669 --> 00:06:03,210
it asked looks for arguments where the

00:06:01,289 --> 00:06:05,789
user wrote help in either uppercase or

00:06:03,210 --> 00:06:07,470
lowercase and if that's the case then it

00:06:05,789 --> 00:06:10,139
will print the usage in otherwise it

00:06:07,470 --> 00:06:12,599
will process the arguments so that just

00:06:10,139 --> 00:06:15,510
shows you how something very Java like a

00:06:12,599 --> 00:06:17,820
main method raise goes together with

00:06:15,510 --> 00:06:20,940
something like here which is in the end

00:06:17,820 --> 00:06:22,950
very functional so you don't step go

00:06:20,940 --> 00:06:25,050
through the loop step by step with an

00:06:22,950 --> 00:06:27,389
index you just ask the whole array

00:06:25,050 --> 00:06:29,849
whether there exists something which

00:06:27,389 --> 00:06:31,979
satisfies a given predicate and this

00:06:29,849 --> 00:06:35,820
predicate here which is given in these

00:06:31,979 --> 00:06:37,770
parents that's a function that's treated

00:06:35,820 --> 00:06:39,930
as a first-class function in Java and

00:06:37,770 --> 00:06:42,030
the parameter of that function that goes

00:06:39,930 --> 00:06:43,860
here where the underscore is so you say

00:06:42,030 --> 00:06:45,660
the parameter you slaughter every

00:06:43,860 --> 00:06:47,940
argument into this parameter

00:06:45,660 --> 00:06:50,910
you asked converted to lowercase asked

00:06:47,940 --> 00:06:53,640
is it equal to help if yes then we have

00:06:50,910 --> 00:06:59,910
a match and exists the exists method

00:06:53,640 --> 00:07:01,950
here will return the result okay so to

00:06:59,910 --> 00:07:03,930
look at interoperability the whole thing

00:07:01,950 --> 00:07:06,360
fits seamlessly into a java environment

00:07:03,930 --> 00:07:08,970
you can call java method select java

00:07:06,360 --> 00:07:11,100
feels inherit java classes implement

00:07:08,970 --> 00:07:12,690
interfaces and so on and it's and so on

00:07:11,100 --> 00:07:17,480
that's virtually nothing that doesn't

00:07:12,690 --> 00:07:20,400
work completely so it without any

00:07:17,480 --> 00:07:23,220
protocol so you don't need any glue code

00:07:20,400 --> 00:07:26,580
interface description nothing in the end

00:07:23,220 --> 00:07:28,950
a scholar program or scholar application

00:07:26,580 --> 00:07:31,800
is just another Java library it combines

00:07:28,950 --> 00:07:34,950
it compiles into class files it gets

00:07:31,800 --> 00:07:36,390
deployed as jars and at the runtime

00:07:34,950 --> 00:07:38,970
there's virtually no difference between

00:07:36,390 --> 00:07:40,560
the two and for all the trees for that

00:07:38,970 --> 00:07:42,900
reason it's also the case that the

00:07:40,560 --> 00:07:47,100
performance is usually on a pair of its

00:07:42,900 --> 00:07:49,230
Java okay yet another way to look at it

00:07:47,100 --> 00:07:51,210
is to say Scala is a language for

00:07:49,230 --> 00:07:53,160
programming in the large software

00:07:51,210 --> 00:07:55,080
architecture language or composition

00:07:53,160 --> 00:07:56,850
language in fact it embodies a

00:07:55,080 --> 00:07:59,820
completely new approach to the

00:07:56,850 --> 00:08:04,110
modularity problem to module systems so

00:07:59,820 --> 00:08:06,540
in Scala a component is a class or a try

00:08:04,110 --> 00:08:08,970
to try to something in between a class

00:08:06,540 --> 00:08:11,490
and an interface you can mix several

00:08:08,970 --> 00:08:13,640
traits together and the composition is

00:08:11,490 --> 00:08:16,919
done with this mixing composition and

00:08:13,640 --> 00:08:20,100
you have very powerful ways to abstract

00:08:16,919 --> 00:08:21,750
to to hide details through parameters

00:08:20,100 --> 00:08:23,730
through abstract members and through

00:08:21,750 --> 00:08:25,620
self types and all this gives you

00:08:23,730 --> 00:08:28,080
something for which nowadays you need

00:08:25,620 --> 00:08:30,030
tools dependency injection tools like

00:08:28,080 --> 00:08:32,490
spring you could say that's already

00:08:30,030 --> 00:08:34,650
embodied in the language it lets you do

00:08:32,490 --> 00:08:37,560
the same thing already in the language

00:08:34,650 --> 00:08:39,930
without actually having to do additional

00:08:37,560 --> 00:08:43,440
configuration files or frameworks or

00:08:39,930 --> 00:08:45,210
whatever so you might ask with all that

00:08:43,440 --> 00:08:47,070
that don't you get a huge language

00:08:45,210 --> 00:08:48,420
kitchen sink language that includes

00:08:47,070 --> 00:08:50,040
everything I mean if you go from

00:08:48,420 --> 00:08:53,400
scripting to architecture description

00:08:50,040 --> 00:08:55,710
and in fact is we have various work very

00:08:53,400 --> 00:08:57,690
very hard that this is not the case so

00:08:55,710 --> 00:08:58,960
in terms of feature counts Carla is

00:08:57,690 --> 00:09:01,450
roughly comparable

00:08:58,960 --> 00:09:03,660
to today's java i would say and it's

00:09:01,450 --> 00:09:07,390
certainly smaller than c sharp or

00:09:03,660 --> 00:09:09,400
certainly much much smaller than C++ the

00:09:07,390 --> 00:09:11,110
difference is that where other languages

00:09:09,400 --> 00:09:13,390
are abroad that means they have many

00:09:11,110 --> 00:09:15,490
different features side by side we try

00:09:13,390 --> 00:09:18,520
to go deep that means we try to

00:09:15,490 --> 00:09:21,700
concentrate on ways to give you new ways

00:09:18,520 --> 00:09:23,140
to abstract and compose so that you can

00:09:21,700 --> 00:09:25,450
create the things you want yourself

00:09:23,140 --> 00:09:27,580
rather than really relying on what's

00:09:25,450 --> 00:09:29,590
already there as primitives in the

00:09:27,580 --> 00:09:31,240
language and the other principle that

00:09:29,590 --> 00:09:32,980
helped us keep the language reasonably

00:09:31,240 --> 00:09:35,260
small even though the application area

00:09:32,980 --> 00:09:36,790
is huge is that we from the start

00:09:35,260 --> 00:09:39,670
decided you would have the same sort of

00:09:36,790 --> 00:09:42,100
constructs work for very small as well

00:09:39,670 --> 00:09:44,020
as web for very large programs so it's

00:09:42,100 --> 00:09:46,000
all objects from a single line program

00:09:44,020 --> 00:09:48,610
to a million line system it's all

00:09:46,000 --> 00:09:51,400
expressed as as it as simple objects

00:09:48,610 --> 00:09:54,910
there's no no further layers of modules

00:09:51,400 --> 00:09:57,100
or packages or whatnot so if you compare

00:09:54,910 --> 00:09:59,620
scholar to Java then what we what we add

00:09:57,100 --> 00:10:02,560
is a pure module system so everything is

00:09:59,620 --> 00:10:05,140
an object operator overloading so

00:10:02,560 --> 00:10:06,910
operators are just method calls we add

00:10:05,140 --> 00:10:09,640
closures that comes from the functional

00:10:06,910 --> 00:10:11,380
side we add new form of composition

00:10:09,640 --> 00:10:13,990
which is called mixing composition which

00:10:11,380 --> 00:10:15,880
is essentially a modern form of multiple

00:10:13,990 --> 00:10:18,670
inheritance so it's more general than

00:10:15,880 --> 00:10:22,180
the single inheritance plus interfaces

00:10:18,670 --> 00:10:24,070
that you see in Java or.net and we add

00:10:22,180 --> 00:10:26,620
on the type side interesting things like

00:10:24,070 --> 00:10:29,230
existential types abstract types and we

00:10:26,620 --> 00:10:31,090
add pattern matching that's quite a list

00:10:29,230 --> 00:10:33,460
but on the other hand we also remove

00:10:31,090 --> 00:10:35,770
quite a list from the things that you

00:10:33,460 --> 00:10:38,500
see in Java not so much that we are

00:10:35,770 --> 00:10:40,240
against them but typically because there

00:10:38,500 --> 00:10:42,940
are other ways to do the equivalent

00:10:40,240 --> 00:10:44,770
things in in skala so we don't have

00:10:42,940 --> 00:10:46,840
static members of classes there are a

00:10:44,770 --> 00:10:49,960
big source of headaches we don't have

00:10:46,840 --> 00:10:52,000
primitive types they're all objects we

00:10:49,960 --> 00:10:54,730
don't have break and continuing loops I

00:10:52,000 --> 00:10:56,590
show you how to get them back later we

00:10:54,730 --> 00:10:58,750
don't treat interface especially they're

00:10:56,590 --> 00:11:02,140
just straight simple traits we don't

00:10:58,750 --> 00:11:04,150
need wild cards we can use model them in

00:11:02,140 --> 00:11:07,240
a more correct way with existential and

00:11:04,150 --> 00:11:09,670
we don't have row types and enums enums

00:11:07,240 --> 00:11:11,340
are among the several other things that

00:11:09,670 --> 00:11:14,460
are

00:11:11,340 --> 00:11:16,440
and modeled in skala libraries so the

00:11:14,460 --> 00:11:18,540
library's take up a lot of this lack of

00:11:16,440 --> 00:11:20,250
what's not in the language and that's

00:11:18,540 --> 00:11:21,960
possible because the language is much

00:11:20,250 --> 00:11:24,120
more flexible and malleable so that you

00:11:21,960 --> 00:11:25,800
can infect right these libraries and

00:11:24,120 --> 00:11:29,490
have them use dinner in a pleasant way

00:11:25,800 --> 00:11:32,460
from your users so now I should really

00:11:29,490 --> 00:11:35,820
tell you well who has already been seen

00:11:32,460 --> 00:11:39,270
or written some Java code s calico sorry

00:11:35,820 --> 00:11:43,830
ok ok quite a few written written who's

00:11:39,270 --> 00:11:46,260
written much but fewer ok so for those

00:11:43,830 --> 00:11:48,210
who haven't seen anything I just take

00:11:46,260 --> 00:11:51,390
you through a little cheat cheat cheat

00:11:48,210 --> 00:11:54,960
to just tell you how how to read some

00:11:51,390 --> 00:11:56,700
skala how is it different so first thing

00:11:54,960 --> 00:11:58,380
here is you have a method definition on

00:11:56,700 --> 00:12:00,780
the right side you have the Java one and

00:11:58,380 --> 00:12:03,810
on the left hand you have the scholar

00:12:00,780 --> 00:12:06,560
one so you see that there's a special

00:12:03,810 --> 00:12:11,160
keyword called def which starts a method

00:12:06,560 --> 00:12:13,560
the parameters the type of the parameter

00:12:11,160 --> 00:12:17,730
is reversed so it's X colon int instead

00:12:13,560 --> 00:12:20,700
of index and you don't need to have a

00:12:17,730 --> 00:12:22,500
return instead every expression on the

00:12:20,700 --> 00:12:24,330
right hand side the last expression of

00:12:22,500 --> 00:12:26,430
the statements on the right hand side is

00:12:24,330 --> 00:12:28,950
automatically returned as a result and

00:12:26,430 --> 00:12:30,830
there's a slight right form of functions

00:12:28,950 --> 00:12:33,870
that don't take any parameter at all

00:12:30,830 --> 00:12:36,750
that's this one here where you just

00:12:33,870 --> 00:12:39,360
rewrite a function that when you mention

00:12:36,750 --> 00:12:42,480
the name fun it will compute result for

00:12:39,360 --> 00:12:44,940
you every time you do that variable

00:12:42,480 --> 00:12:47,790
definitions so that's the Java form into

00:12:44,940 --> 00:12:52,430
x equals expression in Scala you write

00:12:47,790 --> 00:12:56,670
VAR x colon in thick vers expression and

00:12:52,430 --> 00:12:59,640
if you want it to be immutable way which

00:12:56,670 --> 00:13:02,250
is the functional way then you right Val

00:12:59,640 --> 00:13:04,620
instead of var so that means you have a

00:13:02,250 --> 00:13:07,410
variable that you will not assign to

00:13:04,620 --> 00:13:09,300
later on the initial value is also the

00:13:07,410 --> 00:13:11,520
final value of that variable so that

00:13:09,300 --> 00:13:15,270
would correspond in Java to final string

00:13:11,520 --> 00:13:24,210
x equals expression yes

00:13:15,270 --> 00:13:26,890
yes I couldn't know it can I can yes

00:13:24,210 --> 00:13:29,110
yeah okay the question is with type

00:13:26,890 --> 00:13:30,820
inference I maybe I take it I get to

00:13:29,110 --> 00:13:32,470
type inference later on so there was a

00:13:30,820 --> 00:13:34,300
question what does type influence do

00:13:32,470 --> 00:13:40,180
here and I'm going to take that up a

00:13:34,300 --> 00:13:42,760
later on in the site okay so if you go

00:13:40,180 --> 00:13:45,280
through the cheat sheet further on with

00:13:42,760 --> 00:13:49,210
the expressions so a method call looks

00:13:45,280 --> 00:13:51,970
basically in exactly the same way as in

00:13:49,210 --> 00:13:54,820
Java so you write object dot method of

00:13:51,970 --> 00:13:57,640
some arguments that's a shorthand in

00:13:54,820 --> 00:13:59,590
skala which lets you drop the dotter and

00:13:57,640 --> 00:14:01,750
the parents you can just write object

00:13:59,590 --> 00:14:04,450
method argument and that means the same

00:14:01,750 --> 00:14:06,280
thing it's also a method call where but

00:14:04,450 --> 00:14:10,440
the method is used there as an infix

00:14:06,280 --> 00:14:13,030
operator the conditional expressions

00:14:10,440 --> 00:14:17,310
there's the eastern else very much like

00:14:13,030 --> 00:14:20,350
in Java but because in Scala every

00:14:17,310 --> 00:14:23,350
statement is an expression we only need

00:14:20,350 --> 00:14:25,750
one if so in Java you need me to ifs

00:14:23,350 --> 00:14:28,270
that one for expression and that one for

00:14:25,750 --> 00:14:30,150
statements in Scala you use the same if

00:14:28,270 --> 00:14:34,450
for both expressions and statements

00:14:30,150 --> 00:14:37,330
instead of the switch you have a match

00:14:34,450 --> 00:14:39,730
here but in fact the capabilities of the

00:14:37,330 --> 00:14:41,740
match match are vastly more powerful

00:14:39,730 --> 00:14:43,540
than the switch will get to that because

00:14:41,740 --> 00:14:47,100
it lets you do general pattern matching

00:14:43,540 --> 00:14:49,960
not just tests on some simple constants

00:14:47,100 --> 00:14:52,690
if you look at objects and classes so

00:14:49,960 --> 00:14:55,180
that's the typical thing you would write

00:14:52,690 --> 00:14:57,970
a class in Java you right class sample

00:14:55,180 --> 00:15:00,700
and then you introduce for instance here

00:14:57,970 --> 00:15:03,220
a private field and the public field p

00:15:00,700 --> 00:15:05,980
and you then you need a constructor that

00:15:03,220 --> 00:15:08,740
initializes these fields and there you

00:15:05,980 --> 00:15:12,070
have two methods one instance and one

00:15:08,740 --> 00:15:14,950
static so the on the left hand side on

00:15:12,070 --> 00:15:17,710
the scholar side you see the exactly

00:15:14,950 --> 00:15:20,370
equivalent program so which is much

00:15:17,710 --> 00:15:22,360
shorter it's much shorter because

00:15:20,370 --> 00:15:25,330
instead of writing a separate

00:15:22,360 --> 00:15:27,640
constructor you can write the parameters

00:15:25,330 --> 00:15:28,320
of the constructor directly behind the

00:15:27,640 --> 00:15:32,680
class

00:15:28,320 --> 00:15:34,930
goes here on top and the instant method

00:15:32,680 --> 00:15:37,060
goes into the class there are no statics

00:15:34,930 --> 00:15:40,330
but instead of statics you have a

00:15:37,060 --> 00:15:42,070
separate object an object is basically

00:15:40,330 --> 00:15:45,070
just the class that is already pre

00:15:42,070 --> 00:15:47,230
allocated for you exactly once so in

00:15:45,070 --> 00:15:49,300
this object sample you say you put the

00:15:47,230 --> 00:15:51,430
static method and that then becomes an

00:15:49,300 --> 00:15:53,770
instance method of this object so in

00:15:51,430 --> 00:15:55,630
that way Scala is much purer because it

00:15:53,770 --> 00:15:57,580
says these objects all the way down and

00:15:55,630 --> 00:15:58,750
it doesn't have this idea of static

00:15:57,580 --> 00:16:03,149
members which is really not an

00:15:58,750 --> 00:16:06,820
object-oriented concept at all okay

00:16:03,149 --> 00:16:09,160
finally traits so on the right hand side

00:16:06,820 --> 00:16:11,920
you have an in Java interface it has

00:16:09,160 --> 00:16:14,260
abstract methods only you can do the

00:16:11,920 --> 00:16:16,540
same thing in Scala in a skylit rate you

00:16:14,260 --> 00:16:19,779
can write abstract methods but you can

00:16:16,540 --> 00:16:21,399
also add concrete methods you can give

00:16:19,779 --> 00:16:23,680
them some it some implementations that

00:16:21,399 --> 00:16:26,709
then I inherited and you can even define

00:16:23,680 --> 00:16:31,120
fields like down here and instead of

00:16:26,709 --> 00:16:34,149
having a interface implementation like

00:16:31,120 --> 00:16:36,910
that in Java you just write in Scala

00:16:34,149 --> 00:16:39,160
classy extends and then you have what we

00:16:36,910 --> 00:16:41,380
call mixing composition you take the

00:16:39,160 --> 00:16:43,000
superclass and all the traits and you

00:16:41,380 --> 00:16:50,770
mix them in together with this with

00:16:43,000 --> 00:16:53,770
keyword so overall it feels like a

00:16:50,770 --> 00:16:55,270
cleaned up java a little bit the syntax

00:16:53,770 --> 00:16:58,270
is usually much more lightweight and

00:16:55,270 --> 00:17:00,579
concise in my in my experience if you

00:16:58,270 --> 00:17:02,920
don't change the program a lot you will

00:17:00,579 --> 00:17:06,520
still get a reduction lines of code of

00:17:02,920 --> 00:17:08,610
about two and that's due to the fact

00:17:06,520 --> 00:17:11,709
that we infer a lot of things been for

00:17:08,610 --> 00:17:14,530
most trivially semicolons at the end of

00:17:11,709 --> 00:17:17,620
lines are optional and skyla we infer a

00:17:14,530 --> 00:17:20,380
lot of types our class syntax is more

00:17:17,620 --> 00:17:23,199
light white and then you can make use of

00:17:20,380 --> 00:17:25,449
extensible api's closures as control

00:17:23,199 --> 00:17:28,780
abstractions and so on so it feels like

00:17:25,449 --> 00:17:30,820
a clock cleaned up Java but with one

00:17:28,780 --> 00:17:33,870
major difference and that's that we

00:17:30,820 --> 00:17:36,130
write x colon int instead of index and

00:17:33,870 --> 00:17:39,460
that's actually what I've been most

00:17:36,130 --> 00:17:41,080
criticized on by overall why why do you

00:17:39,460 --> 00:17:42,880
insist on writing X qur'anic

00:17:41,080 --> 00:17:46,240
instead of MPX it would be so much

00:17:42,880 --> 00:17:48,190
easier if you didn't do this at adopt so

00:17:46,240 --> 00:17:51,070
we must have very good reasons to do it

00:17:48,190 --> 00:17:54,070
and in fact we didn't really do this

00:17:51,070 --> 00:17:58,659
just out of a whim to say well we just

00:17:54,070 --> 00:18:01,299
like it better so there are two reasons

00:17:58,659 --> 00:18:04,809
for this the first one is that quite

00:18:01,299 --> 00:18:07,029
often in fact usually in Scala you will

00:18:04,809 --> 00:18:10,269
not write the type in at all you will

00:18:07,029 --> 00:18:12,549
just write VAR x equals 0 and this gala

00:18:10,269 --> 00:18:14,590
compiler will infer the type for you and

00:18:12,549 --> 00:18:16,870
this type inference is done is a bit

00:18:14,590 --> 00:18:18,549
limited so it's done in a local way so

00:18:16,870 --> 00:18:20,380
from the right-hand side from the type

00:18:18,549 --> 00:18:23,080
of the expression it will figure out

00:18:20,380 --> 00:18:24,970
that in a zero is of type int so there's

00:18:23,080 --> 00:18:26,860
no need to declare the variable X with

00:18:24,970 --> 00:18:29,529
the same type int explicitly the

00:18:26,860 --> 00:18:31,299
compiler can figure that out so that's

00:18:29,529 --> 00:18:35,230
the first reason and the second reason

00:18:31,299 --> 00:18:38,019
is that i think this prefix type int x

00:18:35,230 --> 00:18:40,539
syntax that work great in the days of

00:18:38,019 --> 00:18:43,179
early see and it stopped working so

00:18:40,539 --> 00:18:46,120
great afterwards so in the days of early

00:18:43,179 --> 00:18:51,130
see most of your types were in floats

00:18:46,120 --> 00:18:53,200
structs that was about it right so in

00:18:51,130 --> 00:18:55,389
that in that sense you could say well

00:18:53,200 --> 00:18:57,789
into it's great it already gives you the

00:18:55,389 --> 00:18:59,710
type of a variable no noise no fuss

00:18:57,789 --> 00:19:01,750
nothing no you don't need another

00:18:59,710 --> 00:19:03,460
keyword but nowadays our types have

00:19:01,750 --> 00:19:05,679
gotten much bigger and much more much

00:19:03,460 --> 00:19:07,840
complicated more complicated than that

00:19:05,679 --> 00:19:10,120
and there have gotten much more user

00:19:07,840 --> 00:19:11,980
definable so you wouldn't write often

00:19:10,120 --> 00:19:14,049
impt but you would write something like

00:19:11,980 --> 00:19:15,880
public final hashmap string of pair of

00:19:14,049 --> 00:19:19,450
string of list of car blah blah blah X

00:19:15,880 --> 00:19:21,639
and then you say ok you have to pass all

00:19:19,450 --> 00:19:23,169
this to get to the really important

00:19:21,639 --> 00:19:24,880
thing they may be what is the variable

00:19:23,169 --> 00:19:26,649
you're defining here maybe you're not

00:19:24,880 --> 00:19:28,210
even interested in the type at this

00:19:26,649 --> 00:19:30,279
moment you're just interested in the

00:19:28,210 --> 00:19:33,190
name so i think this syntax the

00:19:30,279 --> 00:19:35,320
traditional see style syntax has outrun

00:19:33,190 --> 00:19:37,990
its usefulness one when we have types

00:19:35,320 --> 00:19:40,870
like this whereas over here you write

00:19:37,990 --> 00:19:42,190
valix so that tells you what's so well

00:19:40,870 --> 00:19:44,470
tells you well it's a value your

00:19:42,190 --> 00:19:46,600
defining ex tells you it's Xu defining

00:19:44,470 --> 00:19:48,580
and then this thing here you might often

00:19:46,600 --> 00:19:50,470
even infer you don't need to need to

00:19:48,580 --> 00:19:52,400
write at all and if you write it it

00:19:50,470 --> 00:19:54,530
comes third because it's

00:19:52,400 --> 00:20:00,320
as important as the other things and not

00:19:54,530 --> 00:20:02,800
the most important thing okay so if you

00:20:00,320 --> 00:20:05,870
want to be scalable then one of the

00:20:02,800 --> 00:20:08,930
important things is to be extensible as

00:20:05,870 --> 00:20:11,840
a language so why is that so well it's

00:20:08,930 --> 00:20:14,000
because we don't foresee everything that

00:20:11,840 --> 00:20:17,570
users want to do with our languages

00:20:14,000 --> 00:20:19,910
every user has different demands and

00:20:17,570 --> 00:20:21,920
different ideas what they want to do so

00:20:19,910 --> 00:20:24,110
one example of that very concrete is

00:20:21,920 --> 00:20:27,280
numeric data types so in today's

00:20:24,110 --> 00:20:29,480
languages you have in long float double

00:20:27,280 --> 00:20:31,820
question is should we also support

00:20:29,480 --> 00:20:33,800
begins while they're very useful very

00:20:31,820 --> 00:20:36,500
applications that absolutely demand

00:20:33,800 --> 00:20:39,230
begins would you do cryptography without

00:20:36,500 --> 00:20:41,930
bigdecimal business one speaker Cemil

00:20:39,230 --> 00:20:45,170
how can they count all the pennies and

00:20:41,930 --> 00:20:47,480
cents complex numbers physicists

00:20:45,170 --> 00:20:50,420
absolutely require complex rational

00:20:47,480 --> 00:20:52,760
interval polynomial they all have really

00:20:50,420 --> 00:20:54,380
important usages but if you had a

00:20:52,760 --> 00:20:56,510
language that combined all these as

00:20:54,380 --> 00:21:00,110
numeric types in the language it would

00:20:56,510 --> 00:21:01,940
be really huge so what do you do you the

00:21:00,110 --> 00:21:03,830
alternative of course is to let the

00:21:01,940 --> 00:21:07,070
users grow the language according to

00:21:03,830 --> 00:21:10,340
what they need so here's an example what

00:21:07,070 --> 00:21:13,280
of what you can write in Scala if you

00:21:10,340 --> 00:21:16,580
have the type begin then you write a

00:21:13,280 --> 00:21:18,770
factorial like this that's the way you

00:21:16,580 --> 00:21:20,150
would write factorial begin there's

00:21:18,770 --> 00:21:22,430
another type that's primitive in

00:21:20,150 --> 00:21:24,500
skylights that somebody had defined in a

00:21:22,430 --> 00:21:26,540
library if it hadn't been in a library

00:21:24,500 --> 00:21:28,790
you could define it yourself everybody

00:21:26,540 --> 00:21:31,430
that's there's no special magic to begin

00:21:28,790 --> 00:21:34,100
whatsoever so you could say well

00:21:31,430 --> 00:21:35,780
defining new types that's old old hat

00:21:34,100 --> 00:21:37,550
right every language can do that in

00:21:35,780 --> 00:21:40,190
particular object oriented languages so

00:21:37,550 --> 00:21:42,560
of course in Java you can also define

00:21:40,190 --> 00:21:45,230
begin in fact it has been defined it's

00:21:42,560 --> 00:21:47,090
called Java dot math but big integer but

00:21:45,230 --> 00:21:50,810
to interact with it you have to write

00:21:47,090 --> 00:21:52,580
that so you write factorial of this big

00:21:50,810 --> 00:21:54,200
integer and then you have the test so

00:21:52,580 --> 00:21:56,330
that's the factorial the very same

00:21:54,200 --> 00:21:58,040
factorial function it clearly doesn't

00:21:56,330 --> 00:22:00,080
look like you're interacting with a

00:21:58,040 --> 00:22:02,900
built-in type right it's completely

00:22:00,080 --> 00:22:04,400
different whether you're at you interact

00:22:02,900 --> 00:22:05,010
with something that's in the language or

00:22:04,400 --> 00:22:07,620
outside

00:22:05,010 --> 00:22:10,620
language so the question is how how in

00:22:07,620 --> 00:22:13,950
Scala you achieve this syntactic

00:22:10,620 --> 00:22:16,590
elegance and brevity so here's how we do

00:22:13,950 --> 00:22:19,260
it so that's the an excerpt of the class

00:22:16,590 --> 00:22:21,870
of of the class begins which is in this

00:22:19,260 --> 00:22:24,330
color library so it actually it doesn't

00:22:21,870 --> 00:22:28,520
do much it uses Java for most of what it

00:22:24,330 --> 00:22:31,470
does it imports the Java big integer and

00:22:28,520 --> 00:22:35,940
here you define the class begins to get

00:22:31,470 --> 00:22:39,480
a scallop begin sorry you essentially

00:22:35,940 --> 00:22:42,690
wrap a Java big integer and then in the

00:22:39,480 --> 00:22:46,230
class begins you have methods that are

00:22:42,690 --> 00:22:48,210
called plus and minus and so on remember

00:22:46,230 --> 00:22:50,610
from up couple slides back the

00:22:48,210 --> 00:22:52,950
alternative method syntax that you could

00:22:50,610 --> 00:22:58,950
write receive a method argument well

00:22:52,950 --> 00:23:01,440
here you can write x minus one that's an

00:22:58,950 --> 00:23:03,990
instance of that X is a receiver minus

00:23:01,440 --> 00:23:06,600
is a method one is the argument so the

00:23:03,990 --> 00:23:08,610
only thing that we needed to do that is

00:23:06,600 --> 00:23:11,070
to say well you can have a method whose

00:23:08,610 --> 00:23:13,200
name is plus plus is a legal method name

00:23:11,070 --> 00:23:16,170
and in fact it is in scada so that's not

00:23:13,200 --> 00:23:19,860
a big big deal so that means that in fix

00:23:16,170 --> 00:23:23,190
operations like a plus B is the same as

00:23:19,860 --> 00:23:25,200
a dot plus B or here I just played on

00:23:23,190 --> 00:23:27,300
that to say you can of course do that

00:23:25,200 --> 00:23:30,000
also when you call java methods so here

00:23:27,300 --> 00:23:32,340
the add method that's a Java operation

00:23:30,000 --> 00:23:34,440
on big integer but you use in fixham

00:23:32,340 --> 00:23:38,210
text or on that just to show you that

00:23:34,440 --> 00:23:38,210
it's possible yes there was a question

00:23:41,570 --> 00:23:44,570
yeah

00:23:45,980 --> 00:23:53,039
very good very very well observed yes so

00:23:49,440 --> 00:23:55,860
what do we do then so we could be could

00:23:53,039 --> 00:23:57,570
do two things so the first one is we can

00:23:55,860 --> 00:24:00,870
give you an overlaid loaded version of

00:23:57,570 --> 00:24:02,370
PLAs with integer only that works for X

00:24:00,870 --> 00:24:04,740
plus one but it doesn't work for one

00:24:02,370 --> 00:24:07,409
classics that's the harder part because

00:24:04,740 --> 00:24:10,139
if you say one plus X you invoke the +

00:24:07,409 --> 00:24:12,120
method on the integer one with a big int

00:24:10,139 --> 00:24:14,639
argument so then you really have a

00:24:12,120 --> 00:24:17,370
problem there's something called an

00:24:14,639 --> 00:24:20,070
implicit conversion in in skala so you

00:24:17,370 --> 00:24:21,870
can define your own conversions and the

00:24:20,070 --> 00:24:24,779
compiler will apply them when necessary

00:24:21,870 --> 00:24:26,250
to make these things work I don't didn't

00:24:24,779 --> 00:24:28,379
want to go into that because it goes a

00:24:26,250 --> 00:24:29,730
bit bit too deeply but that's

00:24:28,379 --> 00:24:31,980
essentially how it's done there's an

00:24:29,730 --> 00:24:34,110
implicit you together with big integer

00:24:31,980 --> 00:24:37,500
you define an implicit conversion from

00:24:34,110 --> 00:24:39,870
integer to begin teacher okay so that

00:24:37,500 --> 00:24:42,000
that's data types what about control

00:24:39,870 --> 00:24:43,740
structures so new line new with you you

00:24:42,000 --> 00:24:46,200
want to extend your language with no

00:24:43,740 --> 00:24:49,919
control structures also i guess so

00:24:46,200 --> 00:24:52,649
here's an example of what's also been

00:24:49,919 --> 00:24:55,110
proposed for java 7 a sort of using

00:24:52,649 --> 00:24:56,490
construct where you say okay I want to

00:24:55,110 --> 00:25:00,029
have a resource in this case a

00:24:56,490 --> 00:25:02,100
bufferedreader and I want to use that

00:25:00,029 --> 00:25:03,750
that means I want to open it and do

00:25:02,100 --> 00:25:06,809
something with it and then close it

00:25:03,750 --> 00:25:08,340
automatically so that I can't the idea

00:25:06,809 --> 00:25:10,559
of this construct is that users

00:25:08,340 --> 00:25:12,809
shouldn't be shouldn't fall into the

00:25:10,559 --> 00:25:16,620
trap to forget to close it in fact the

00:25:12,809 --> 00:25:19,049
closing so that's the the previous idiom

00:25:16,620 --> 00:25:20,970
where you say you're open early you do

00:25:19,049 --> 00:25:22,679
you create a resource then you do

00:25:20,970 --> 00:25:25,110
something with it and then you have a

00:25:22,679 --> 00:25:28,169
tri finally which catches in under all

00:25:25,110 --> 00:25:30,330
every eventuality will say well if this

00:25:28,169 --> 00:25:33,120
thing is not now then close it in the

00:25:30,330 --> 00:25:35,809
end this sort of thing so that's nice

00:25:33,120 --> 00:25:38,460
and in Java it has been proposed as a

00:25:35,809 --> 00:25:41,899
syntax addition to something to add to

00:25:38,460 --> 00:25:44,730
the java 7 language but of course

00:25:41,899 --> 00:25:46,980
there's no no no reason for that if you

00:25:44,730 --> 00:25:49,350
can do it yourself in the libraries so

00:25:46,980 --> 00:25:51,570
here's how you would do it in Scala you

00:25:49,350 --> 00:25:55,080
would have using would be a method to

00:25:51,570 --> 00:25:56,940
death and what would it do well what the

00:25:55,080 --> 00:25:59,100
code block is was virtually the same

00:25:56,940 --> 00:26:01,230
thing as before only wear before you

00:25:59,100 --> 00:26:03,600
dealt with a file f now you're dealing

00:26:01,230 --> 00:26:08,160
with an abstract resource which could be

00:26:03,600 --> 00:26:10,410
almost anything so you invoke a block of

00:26:08,160 --> 00:26:12,420
operations on a resource and then

00:26:10,410 --> 00:26:15,980
finally if the resource is not now you

00:26:12,420 --> 00:26:19,380
close it but let's have a look at the

00:26:15,980 --> 00:26:21,180
signature of using here so using the

00:26:19,380 --> 00:26:23,400
first thing it has to do is it has to

00:26:21,180 --> 00:26:25,020
take a type parameter to say well this

00:26:23,400 --> 00:26:26,850
thing should be general it shouldn't

00:26:25,020 --> 00:26:28,440
just work with files it should also work

00:26:26,850 --> 00:26:31,170
for other kinds of resources that have

00:26:28,440 --> 00:26:32,850
closed methods so the T here is a type

00:26:31,170 --> 00:26:35,730
parameter which says it works for any

00:26:32,850 --> 00:26:38,310
type if you know Java generics or C++

00:26:35,730 --> 00:26:40,530
templates then it's the same thing as

00:26:38,310 --> 00:26:42,600
they only that we right angle brackets

00:26:40,530 --> 00:26:44,850
where they occur right sharp brackets

00:26:42,600 --> 00:26:46,740
but otherwise it's the same thing now we

00:26:44,850 --> 00:26:49,350
write brackets where they right angle

00:26:46,740 --> 00:26:51,990
bracket sorry ok so T is a type

00:26:49,350 --> 00:26:54,000
parameter and then we have to say well

00:26:51,990 --> 00:26:55,980
we have to know something about t so

00:26:54,000 --> 00:26:57,720
what we know here is that T must support

00:26:55,980 --> 00:26:59,520
a close method it must be a type that

00:26:57,720 --> 00:27:02,610
has a close method so that's the second

00:26:59,520 --> 00:27:04,740
approach and then our resource that we

00:27:02,610 --> 00:27:07,500
deal with that must be of type T and

00:27:04,740 --> 00:27:09,750
then the block that we that's the block

00:27:07,500 --> 00:27:12,120
of operations that's now a closure

00:27:09,750 --> 00:27:15,150
that's a function that takes the teeth

00:27:12,120 --> 00:27:17,730
that operates on the T and in this case

00:27:15,150 --> 00:27:19,740
it just returns a unit unit is for a

00:27:17,730 --> 00:27:22,230
scholar is the same thing as void in

00:27:19,740 --> 00:27:25,680
Java so it's a block that doesn't really

00:27:22,230 --> 00:27:28,350
return an interesting result so that's

00:27:25,680 --> 00:27:30,420
how you do it so now let me get back to

00:27:28,350 --> 00:27:32,310
break and continue so where I can

00:27:30,420 --> 00:27:35,010
continue there were in our list of

00:27:32,310 --> 00:27:37,980
missing features from Java and Scala

00:27:35,010 --> 00:27:40,170
doesn't have them so why didn't did we

00:27:37,980 --> 00:27:42,240
drop break and continue well originally

00:27:40,170 --> 00:27:44,700
we dropped break and continue because we

00:27:42,240 --> 00:27:46,860
say they're a bit imperative typically

00:27:44,700 --> 00:27:49,410
you need to break and continue to get

00:27:46,860 --> 00:27:50,940
out of a very tangled control structure

00:27:49,410 --> 00:27:52,440
in functionally if you have a more

00:27:50,940 --> 00:27:54,300
functional programming style and

00:27:52,440 --> 00:27:57,000
typically you don't do that you have

00:27:54,300 --> 00:27:58,530
many more for smaller functions and the

00:27:57,000 --> 00:28:01,140
need for breaking continue is much

00:27:58,530 --> 00:28:03,480
reduced there was also an issue how they

00:28:01,140 --> 00:28:05,430
interact with closures what if you do

00:28:03,480 --> 00:28:08,640
break out of something which is really a

00:28:05,430 --> 00:28:10,740
call of a closure but finally the

00:28:08,640 --> 00:28:12,360
the answer is they're not really needed

00:28:10,740 --> 00:28:15,210
because you can do break and continue

00:28:12,360 --> 00:28:17,430
perfectly well with just libraries so

00:28:15,210 --> 00:28:20,160
here's what you now would do in fact

00:28:17,430 --> 00:28:24,210
youth yet so you would import something

00:28:20,160 --> 00:28:26,940
from a class called scalar you to

00:28:24,210 --> 00:28:29,250
control breaks and then instead of

00:28:26,940 --> 00:28:31,320
breaking out just of a loop you make it

00:28:29,250 --> 00:28:33,390
just explicit you say that's the limit

00:28:31,320 --> 00:28:35,520
where you break out so you have another

00:28:33,390 --> 00:28:37,380
construct called breakable that's where

00:28:35,520 --> 00:28:39,360
you break out from and then you write

00:28:37,380 --> 00:28:41,610
whatever so here's a loop a for loop and

00:28:39,360 --> 00:28:43,950
then here you have your break which then

00:28:41,610 --> 00:28:46,440
if you invoke the break it would break

00:28:43,950 --> 00:28:51,890
out of the scope here so how is that

00:28:46,440 --> 00:28:54,900
done so here's the implementation of

00:28:51,890 --> 00:28:57,210
about its it is in this garage standard

00:28:54,900 --> 00:28:59,280
libraries from the next version on 2.8

00:28:57,210 --> 00:29:01,080
but you see it's no big deal if you need

00:28:59,280 --> 00:29:03,150
break and continue now just write these

00:29:01,080 --> 00:29:05,310
couple of lines and you have them so

00:29:03,150 --> 00:29:07,620
what you do is this there was this

00:29:05,310 --> 00:29:10,260
breaks object that's what what this

00:29:07,620 --> 00:29:12,750
defines it defines an exception called

00:29:10,260 --> 00:29:15,000
break exception and it immediately

00:29:12,750 --> 00:29:18,630
allocates the exception in a value

00:29:15,000 --> 00:29:21,960
called under a lowercase break exception

00:29:18,630 --> 00:29:24,660
and now breakable that was the breakable

00:29:21,960 --> 00:29:27,690
operation break up with just a method

00:29:24,660 --> 00:29:30,300
and what it takes is this block which he

00:29:27,690 --> 00:29:32,520
is called okie for operation that's just

00:29:30,300 --> 00:29:35,550
a block of things so which in the end

00:29:32,520 --> 00:29:37,200
will give you a unit but it will will do

00:29:35,550 --> 00:29:39,450
some computation before it gives you

00:29:37,200 --> 00:29:42,630
that and then what you do is you have

00:29:39,450 --> 00:29:45,180
another try of the you execute the block

00:29:42,630 --> 00:29:47,610
if you catch a break exception during it

00:29:45,180 --> 00:29:50,610
then you will just stop the whole thing

00:29:47,610 --> 00:29:53,430
and you will in exit the breakable so

00:29:50,610 --> 00:29:57,020
break then is just a throw break

00:29:53,430 --> 00:29:57,020
exception and that's all yes

00:30:01,950 --> 00:30:07,289
good good point good point yeah very

00:30:05,490 --> 00:30:09,240
good point you could say it's very heavy

00:30:07,289 --> 00:30:12,000
this break is very heavy it throws an

00:30:09,240 --> 00:30:14,730
exception isn't that slow and there's

00:30:12,000 --> 00:30:18,330
one trick to it if I had written here

00:30:14,730 --> 00:30:19,889
break throw new break exception you

00:30:18,330 --> 00:30:22,559
would be absolutely right but that's not

00:30:19,889 --> 00:30:25,080
what I have done I have have done a

00:30:22,559 --> 00:30:27,510
private class a private VAR break

00:30:25,080 --> 00:30:29,340
exception equals new break exception so

00:30:27,510 --> 00:30:31,049
the stack that gets captured by break

00:30:29,340 --> 00:30:32,820
exception gets captured at the very

00:30:31,049 --> 00:30:35,490
beginning of the program and the program

00:30:32,820 --> 00:30:37,529
still gets starts up it's a completely

00:30:35,490 --> 00:30:39,450
uninteresting stack it's a stack when if

00:30:37,529 --> 00:30:43,649
this object breaks was initialized and

00:30:39,450 --> 00:30:45,630
it turns out that that John Rose told me

00:30:43,649 --> 00:30:49,110
and he also wrote a blog about that that

00:30:45,630 --> 00:30:50,789
modern VMs they can optimize this thing

00:30:49,110 --> 00:30:53,130
so much a way that they turn this thing

00:30:50,789 --> 00:30:54,659
into a jump which is quite amazing so

00:30:53,130 --> 00:30:56,399
our friends that Sun really have helped

00:30:54,659 --> 00:30:59,880
us out there and have made their own

00:30:56,399 --> 00:31:01,440
language constructs more redundant

00:30:59,880 --> 00:31:03,120
because now you can actually implement

00:31:01,440 --> 00:31:09,120
them with with this trick with

00:31:03,120 --> 00:31:11,730
exceptions okay so question is what if

00:31:09,120 --> 00:31:14,370
we look now at the scholar design what

00:31:11,730 --> 00:31:16,769
is the root of the scalability and I

00:31:14,370 --> 00:31:18,990
think there are manufacturers strong

00:31:16,769 --> 00:31:21,179
typing there's inference which means you

00:31:18,990 --> 00:31:23,159
don't get weighed down by a whole mass

00:31:21,179 --> 00:31:25,590
of type annotations that you have to

00:31:23,159 --> 00:31:27,419
write there's generally the emphasis on

00:31:25,590 --> 00:31:30,000
having as little boilerplate to make the

00:31:27,419 --> 00:31:33,570
job as easy as possible but I think the

00:31:30,000 --> 00:31:35,669
main design parts is a very very tight

00:31:33,570 --> 00:31:39,779
interact integration of functional and

00:31:35,669 --> 00:31:41,340
object or any programming and the the

00:31:39,779 --> 00:31:44,010
observation is that they have very

00:31:41,340 --> 00:31:46,110
different strengths and weaknesses also

00:31:44,010 --> 00:31:47,940
so in functional programming it's very

00:31:46,110 --> 00:31:51,240
easy to build interesting things from

00:31:47,940 --> 00:31:53,970
simple parts using a lot of Combinator

00:31:51,240 --> 00:31:56,399
things which let you put things together

00:31:53,970 --> 00:31:58,110
like high order functions algebraic

00:31:56,399 --> 00:32:00,720
types and para matching parametric

00:31:58,110 --> 00:32:02,399
polymorphism object-oriented programming

00:32:00,720 --> 00:32:05,460
on the other hand that shines when you

00:32:02,399 --> 00:32:07,289
have a big clunky complex system and now

00:32:05,460 --> 00:32:09,570
you want to turn a screw here and change

00:32:07,289 --> 00:32:11,779
that a little bit so because it lets you

00:32:09,570 --> 00:32:14,389
go in there with subtyping and inherit

00:32:11,779 --> 00:32:16,969
dynamic configurations and all the tools

00:32:14,389 --> 00:32:18,830
to do code reuse in a very very good way

00:32:16,969 --> 00:32:22,519
so object on your programming is very

00:32:18,830 --> 00:32:24,799
good for maintaining improving evolving

00:32:22,519 --> 00:32:26,809
existing systems whereas functional

00:32:24,799 --> 00:32:28,429
programming is very very good for doing

00:32:26,809 --> 00:32:31,009
something very quickly and very high

00:32:28,429 --> 00:32:34,940
level and the challenges of course how

00:32:31,009 --> 00:32:36,799
to put them put the two together it

00:32:34,940 --> 00:32:38,299
would always be easy to just have say

00:32:36,799 --> 00:32:39,859
well let's throw the functional parts

00:32:38,299 --> 00:32:41,690
here and just add the object-oriented

00:32:39,859 --> 00:32:43,460
parts as well and then we but then you

00:32:41,690 --> 00:32:45,529
end up with a language that sort of is

00:32:43,460 --> 00:32:47,989
modal you say well you program

00:32:45,529 --> 00:32:50,599
functionally or object-oriented you can

00:32:47,989 --> 00:32:52,849
never program with with with the two at

00:32:50,599 --> 00:32:55,129
the same time you can never program both

00:32:52,849 --> 00:32:57,349
so the challenges how can you program

00:32:55,129 --> 00:33:00,399
both functional and object oriented in

00:32:57,349 --> 00:33:04,399
the same program or in the same lines

00:33:00,399 --> 00:33:07,399
okay so fun the object-oriented side is

00:33:04,399 --> 00:33:09,769
Scylla is a purely object-oriented

00:33:07,399 --> 00:33:11,929
language so every language is an object

00:33:09,769 --> 00:33:14,299
that's what's usually required there

00:33:11,929 --> 00:33:16,309
every operation is a method calls and

00:33:14,299 --> 00:33:18,769
there are no exceptions to these rules

00:33:16,309 --> 00:33:21,200
the exceptions that you find in Java

00:33:18,769 --> 00:33:24,799
such as primitive type statics they are

00:33:21,200 --> 00:33:26,749
eliminated so just to do the point if i

00:33:24,799 --> 00:33:29,269
take the hash code of the number one

00:33:26,749 --> 00:33:31,279
then indeed i do get a hash code in java

00:33:29,269 --> 00:33:33,169
that would be a type error because it

00:33:31,279 --> 00:33:36,710
says one is not an object on which you

00:33:33,169 --> 00:33:38,690
can invoke a method underneath the

00:33:36,710 --> 00:33:41,419
covers of course we implement this thing

00:33:38,690 --> 00:33:42,999
with the same 32-bit integers that java

00:33:41,419 --> 00:33:45,710
does we have to do it for both

00:33:42,999 --> 00:33:47,269
interoperability and performance but on

00:33:45,710 --> 00:33:48,799
the programmers side the programmer

00:33:47,269 --> 00:33:51,919
doesn't see them that's sort of a trick

00:33:48,799 --> 00:33:53,839
the compiler poles on the programmer on

00:33:51,919 --> 00:33:56,989
the other hand scala is a functional

00:33:53,839 --> 00:33:58,729
language function in the sense nothing

00:33:56,989 --> 00:34:01,669
but essentially are two definitions of

00:33:58,729 --> 00:34:04,479
functional one is sort of the bondage

00:34:01,669 --> 00:34:06,589
discipline which says that a functions

00:34:04,479 --> 00:34:07,820
functionally program functionally only

00:34:06,589 --> 00:34:09,619
if you don't use side effects of

00:34:07,820 --> 00:34:12,679
assignments so functional programming

00:34:09,619 --> 00:34:15,049
means I outlaw any sort of assignment or

00:34:12,679 --> 00:34:18,079
side effects the more positive approach

00:34:15,049 --> 00:34:21,319
is to say functional programming is a

00:34:18,079 --> 00:34:23,270
language that recognizes the power of

00:34:21,319 --> 00:34:25,250
functions as first-class objects and

00:34:23,270 --> 00:34:27,230
that emphasizes the power of functions

00:34:25,250 --> 00:34:28,850
and in that in that sense Scala is a

00:34:27,230 --> 00:34:34,030
functional language in the second more

00:34:28,850 --> 00:34:36,679
embracing style so it has a very rich

00:34:34,030 --> 00:34:38,389
ways to express functions you can have

00:34:36,679 --> 00:34:41,030
anonymous functions you can have

00:34:38,389 --> 00:34:42,830
currying you can nest functions you can

00:34:41,030 --> 00:34:45,530
do with functions what you whatever you

00:34:42,830 --> 00:34:48,470
can do with other things and the library

00:34:45,530 --> 00:34:51,020
makes a lot of use of that and in fact

00:34:48,470 --> 00:34:56,389
it does a very hard job to even dress up

00:34:51,020 --> 00:34:59,000
the old tired imperative java data types

00:34:56,389 --> 00:35:00,710
as shiny new functional things so here

00:34:59,000 --> 00:35:02,240
you have an array of array of intern

00:35:00,710 --> 00:35:04,970
with java erase you can't really do much

00:35:02,240 --> 00:35:07,850
you can take length and you can index

00:35:04,970 --> 00:35:10,130
but here you can use here all these

00:35:07,850 --> 00:35:12,740
operations you can say it does in the

00:35:10,130 --> 00:35:15,290
matrix exist row such that for all

00:35:12,740 --> 00:35:17,510
elements of the row the element is equal

00:35:15,290 --> 00:35:20,030
to 0 so in one line you asked whether

00:35:17,510 --> 00:35:22,520
this two-dimensional matrix hazard has a

00:35:20,030 --> 00:35:24,590
row that consists of all zeros and

00:35:22,520 --> 00:35:26,720
that's a very functional functional

00:35:24,590 --> 00:35:29,600
approach that you can do these things so

00:35:26,720 --> 00:35:32,540
what we do is again with implicit

00:35:29,600 --> 00:35:35,120
conversion magic we inject these exists

00:35:32,540 --> 00:35:40,520
and for all's into the array classes so

00:35:35,120 --> 00:35:42,260
that that we dress them up there okay so

00:35:40,520 --> 00:35:45,830
now you could say if functions are

00:35:42,260 --> 00:35:47,240
values and values are objects it must be

00:35:45,830 --> 00:35:50,360
that the functions themselves are

00:35:47,240 --> 00:35:52,550
objects right and that's true so indeed

00:35:50,360 --> 00:35:55,460
if you have a function type s arrow T

00:35:52,550 --> 00:35:58,310
that's just an abbreviation for an

00:35:55,460 --> 00:36:00,980
object type which is a class skaara dot

00:35:58,310 --> 00:36:03,050
function one of S&T poison class with

00:36:00,980 --> 00:36:05,000
two parameters for the argument type and

00:36:03,050 --> 00:36:08,260
the result type and here you see this

00:36:05,000 --> 00:36:11,420
class while it's actually at right so a

00:36:08,260 --> 00:36:13,790
function one it takes the S&T parameters

00:36:11,420 --> 00:36:16,100
and it has the apply method if you

00:36:13,790 --> 00:36:18,500
wonder what this minus and plus is it

00:36:16,100 --> 00:36:21,320
tells you how the type parameter very

00:36:18,500 --> 00:36:24,110
averey's with eva tea with subtyping its

00:36:21,320 --> 00:36:25,850
covariant for this one in contra variant

00:36:24,110 --> 00:36:28,340
for the other one if you don't know what

00:36:25,850 --> 00:36:31,160
that means don't worry it's not it's not

00:36:28,340 --> 00:36:33,380
something it's not important here so

00:36:31,160 --> 00:36:35,000
here would be a concrete function in

00:36:33,380 --> 00:36:38,240
that case here we have an anonymous

00:36:35,000 --> 00:36:41,480
function so a very simple one

00:36:38,240 --> 00:36:43,850
takes an int X and it returns x plus one

00:36:41,480 --> 00:36:46,760
so that's that's this function and it

00:36:43,850 --> 00:36:50,480
would be translated into now a Java

00:36:46,760 --> 00:36:52,700
anonymous class which gives you a new

00:36:50,480 --> 00:36:55,280
instance of this straight and with an

00:36:52,700 --> 00:36:58,070
application with an implementation of

00:36:55,280 --> 00:37:00,440
the apply method so here we takes the X

00:36:58,070 --> 00:37:04,460
and it returns X plus 1 so that's what

00:37:00,440 --> 00:37:06,950
it does ok you could say well that's

00:37:04,460 --> 00:37:12,290
nice you have compiled out functions but

00:37:06,950 --> 00:37:14,930
why should use a scare well the idea is

00:37:12,290 --> 00:37:17,030
that since functions are classes they

00:37:14,930 --> 00:37:18,830
can be subclassed that's something you

00:37:17,030 --> 00:37:20,119
have any on the object-oriented side not

00:37:18,830 --> 00:37:21,950
on the functional side and function

00:37:20,119 --> 00:37:24,230
programming a function is a function is

00:37:21,950 --> 00:37:26,750
a function you can't ever add anything

00:37:24,230 --> 00:37:29,240
to a function once you treat functions

00:37:26,750 --> 00:37:31,040
as objects you can do it so why would

00:37:29,240 --> 00:37:36,170
you want to add something to functions

00:37:31,040 --> 00:37:37,640
but one example is just erase an array

00:37:36,170 --> 00:37:40,760
is if you come to think of it it's

00:37:37,640 --> 00:37:42,890
nothing but a function from ins some sub

00:37:40,760 --> 00:37:45,350
range of the integers to whatever the

00:37:42,890 --> 00:37:49,100
element type of the array is only that

00:37:45,350 --> 00:37:50,660
arrays of course have more things than

00:37:49,100 --> 00:37:52,940
functions because you can take the

00:37:50,660 --> 00:37:54,680
length of an array we can update the

00:37:52,940 --> 00:37:56,690
arrays or their functions that you can

00:37:54,680 --> 00:37:59,270
mutate you can change the functions and

00:37:56,690 --> 00:38:01,040
then if they are proper good arrays they

00:37:59,270 --> 00:38:03,710
also have all these useful methods like

00:38:01,040 --> 00:38:05,690
elements and exists and for all's that

00:38:03,710 --> 00:38:08,930
we have seen in the matrix matrix

00:38:05,690 --> 00:38:11,030
example and that's the way it's gala

00:38:08,930 --> 00:38:13,220
treats arrays so instead of array

00:38:11,030 --> 00:38:18,800
subscript agree have this apply method

00:38:13,220 --> 00:38:21,470
here and when we write here or if you I

00:38:18,800 --> 00:38:25,400
don't write it here when we write here a

00:38:21,470 --> 00:38:27,230
of I equals a of I plus 2 then ask Allah

00:38:25,400 --> 00:38:29,600
will translate that into saying well

00:38:27,230 --> 00:38:31,970
that's the invocation of the apply

00:38:29,600 --> 00:38:34,910
method on my function that's an

00:38:31,970 --> 00:38:37,550
invocation of the update method of of my

00:38:34,910 --> 00:38:40,010
function and then the rest is just the

00:38:37,550 --> 00:38:42,350
implementation of these methods so why

00:38:40,010 --> 00:38:44,840
is that useful it's useful because it's

00:38:42,350 --> 00:38:46,970
not restricted to just erase whenever

00:38:44,840 --> 00:38:49,060
the Scala compiler see season this

00:38:46,970 --> 00:38:51,480
syntax it will translate it into

00:38:49,060 --> 00:38:53,640
applications of the apply and update

00:38:51,480 --> 00:38:55,500
that that means you define apply and

00:38:53,640 --> 00:38:57,510
update for your collection libraries

00:38:55,500 --> 00:38:59,640
hash tables or something you get exactly

00:38:57,510 --> 00:39:01,650
the same syntax so it's not something

00:38:59,640 --> 00:39:03,750
that is restricted to a primitive type

00:39:01,650 --> 00:39:09,060
it's available for all library

00:39:03,750 --> 00:39:11,490
obstructions okay another useful thing

00:39:09,060 --> 00:39:14,340
are partial functions so now I have to

00:39:11,490 --> 00:39:16,230
probably switch to big go i think i have

00:39:14,340 --> 00:39:19,980
10 more minutes so I'll speed up a

00:39:16,230 --> 00:39:24,960
little bit I get more than 10 minutes

00:39:19,980 --> 00:39:28,950
excellent okay so I slow down so partial

00:39:24,960 --> 00:39:31,200
functions they are functions that are a

00:39:28,950 --> 00:39:33,440
bit less common than a raise they have a

00:39:31,200 --> 00:39:36,390
new method which is called is defined at

00:39:33,440 --> 00:39:38,550
so that's methods that functions where

00:39:36,390 --> 00:39:41,340
you can that are not defined on all

00:39:38,550 --> 00:39:44,220
their domain but in what's more is you

00:39:41,340 --> 00:39:47,940
can find out whether they are defined or

00:39:44,220 --> 00:39:50,220
not using this method and what Skyler

00:39:47,940 --> 00:39:52,260
does is it treats block of pattern

00:39:50,220 --> 00:39:55,260
matching cases as instances of that so

00:39:52,260 --> 00:39:58,680
we'll see an example very quickly so

00:39:55,260 --> 00:40:00,900
what this gives us is a way to develop

00:39:58,680 --> 00:40:03,390
completely new paradigms of programming

00:40:00,900 --> 00:40:07,920
so as an example here I develop

00:40:03,390 --> 00:40:10,740
concurrent programming since Java Java

00:40:07,920 --> 00:40:12,960
and Scala are interoperable of course we

00:40:10,740 --> 00:40:15,869
can we could use the Java threads and we

00:40:12,960 --> 00:40:17,970
do we use java the java threads we use

00:40:15,869 --> 00:40:20,940
the modern concurrent libraries by

00:40:17,970 --> 00:40:23,190
declare a lot of that and that that

00:40:20,940 --> 00:40:24,840
works well but it's a concurrent

00:40:23,190 --> 00:40:27,390
programming on a very low level of

00:40:24,840 --> 00:40:29,820
abstraction so if you want to be safer

00:40:27,390 --> 00:40:33,150
if you want to write concurrent programs

00:40:29,820 --> 00:40:34,470
simpler then you need to do to something

00:40:33,150 --> 00:40:37,410
else so threads are very very

00:40:34,470 --> 00:40:39,240
error-prone so what one example that we

00:40:37,410 --> 00:40:42,540
have done and that you people use a lot

00:40:39,240 --> 00:40:44,280
is programming with actors actors is a

00:40:42,540 --> 00:40:46,770
much safer way to deal with the

00:40:44,280 --> 00:40:49,470
concurrency because instead of shared

00:40:46,770 --> 00:40:51,240
memory where you your threads all go to

00:40:49,470 --> 00:40:53,190
the same memory and then you have a

00:40:51,240 --> 00:40:55,020
problem how to lock some part of the

00:40:53,190 --> 00:40:57,420
memory so that only one thread can see

00:40:55,020 --> 00:40:59,400
it at a time you communicate with

00:40:57,420 --> 00:41:02,490
messages so its message passing

00:40:59,400 --> 00:41:04,320
concurrency which is generally seen on a

00:41:02,490 --> 00:41:05,039
much higher level we're not the first

00:41:04,320 --> 00:41:07,589
one

00:41:05,039 --> 00:41:09,329
made that observation there's a language

00:41:07,589 --> 00:41:11,369
airline which exists for more than 20

00:41:09,329 --> 00:41:13,729
years which has pioneered this in the

00:41:11,369 --> 00:41:16,349
programming language camp and which is

00:41:13,729 --> 00:41:19,079
nowadays quite popular for massively

00:41:16,349 --> 00:41:21,150
concurrent applications so in along

00:41:19,079 --> 00:41:23,219
their two principal constructs and we

00:41:21,150 --> 00:41:25,140
have adopted both of them in Scala in

00:41:23,219 --> 00:41:27,509
the scholar libraries I should say you

00:41:25,140 --> 00:41:30,449
can send a message to an actin that's

00:41:27,509 --> 00:41:32,369
the previous one and two send is

00:41:30,449 --> 00:41:34,079
asynchronous that means you send off the

00:41:32,369 --> 00:41:35,489
message and then you do other things and

00:41:34,079 --> 00:41:37,799
the message will be buffered in a

00:41:35,489 --> 00:41:40,529
mailbox and when the receiving actor is

00:41:37,799 --> 00:41:44,160
ready it will process it and there's

00:41:40,529 --> 00:41:49,349
receive them which is of this form so it

00:41:44,160 --> 00:41:51,179
is a number of cases so like you what

00:41:49,349 --> 00:41:52,650
you would have in a switch but instead

00:41:51,179 --> 00:41:55,219
of are just a constant you have an

00:41:52,650 --> 00:41:58,079
arbitrary pattern here a message pattern

00:41:55,219 --> 00:41:59,609
so receive pics the first message in its

00:41:58,079 --> 00:42:02,669
mailbox that matches some of the

00:41:59,609 --> 00:42:05,539
patterns and then act on this message so

00:42:02,669 --> 00:42:08,789
here's an here's an example of an actor

00:42:05,539 --> 00:42:11,039
check some calculator the checksum

00:42:08,789 --> 00:42:13,880
calculator that's an actor so actor is

00:42:11,039 --> 00:42:17,819
in this in this code from here to here

00:42:13,880 --> 00:42:19,890
so it keeps a local field called some a

00:42:17,819 --> 00:42:22,380
local variable sum and then it goes

00:42:19,890 --> 00:42:26,039
through a loop and it receives messages

00:42:22,380 --> 00:42:28,529
which are of these two forms data so a

00:42:26,039 --> 00:42:31,799
data message sends a number of bytes and

00:42:28,529 --> 00:42:34,949
there's some message demands the sun is

00:42:31,799 --> 00:42:36,689
computed and returned to another actor

00:42:34,949 --> 00:42:39,390
which is called the receiver here this

00:42:36,689 --> 00:42:43,259
for this one here so the loop what the

00:42:39,390 --> 00:42:45,839
loop does is it receives messages if the

00:42:43,259 --> 00:42:49,259
message is a data message with some

00:42:45,839 --> 00:42:52,229
bytes PS then it just computes the hash

00:42:49,259 --> 00:42:54,929
of BS and edge to some if the message is

00:42:52,229 --> 00:42:57,239
a sum with a given receiver then it will

00:42:54,929 --> 00:42:59,729
send the current value of some back to

00:42:57,239 --> 00:43:05,249
receive just as an example to show how

00:42:59,729 --> 00:43:08,159
these things work ok so now if you have

00:43:05,249 --> 00:43:10,409
seen if you have followed the code

00:43:08,159 --> 00:43:12,749
examples here they are syntax

00:43:10,409 --> 00:43:14,040
highlighted so whatever is a keyword is

00:43:12,749 --> 00:43:15,840
in gray

00:43:14,040 --> 00:43:18,210
and the other stuff is in in this dark

00:43:15,840 --> 00:43:19,500
blue there's not a big difference in

00:43:18,210 --> 00:43:22,230
color but I think you can see that

00:43:19,500 --> 00:43:24,210
receive is not great it's not a keyword

00:43:22,230 --> 00:43:26,280
loop is not great either and actor is

00:43:24,210 --> 00:43:27,630
not great either neither of these things

00:43:26,280 --> 00:43:30,090
are great that means they are all

00:43:27,630 --> 00:43:32,820
defined just as normal methods in the

00:43:30,090 --> 00:43:34,620
libraries so you might say well how is

00:43:32,820 --> 00:43:37,260
received defined how can you do such a

00:43:34,620 --> 00:43:40,230
thing that does pattern matching and and

00:43:37,260 --> 00:43:44,190
all these things so here's how how it is

00:43:40,230 --> 00:43:47,340
defined so what does receives do well if

00:43:44,190 --> 00:43:49,410
we look at its usage it takes a pattern

00:43:47,340 --> 00:43:52,380
matching block from here to here and

00:43:49,410 --> 00:43:54,480
that's modeled as a partial function how

00:43:52,380 --> 00:43:56,820
is it a partial function well you

00:43:54,480 --> 00:43:59,520
something comes in it gets matched by

00:43:56,820 --> 00:44:02,580
the patterns if a pattern matches then

00:43:59,520 --> 00:44:04,350
you will it will return a result so in

00:44:02,580 --> 00:44:06,360
that sense it's a function but it's a

00:44:04,350 --> 00:44:08,550
partial function because some patterns

00:44:06,360 --> 00:44:10,110
might not match and if a parent might

00:44:08,550 --> 00:44:12,210
not match then the function won't return

00:44:10,110 --> 00:44:13,980
anything and what's more you can find

00:44:12,210 --> 00:44:16,530
out from the function whether it can we

00:44:13,980 --> 00:44:18,150
can return something or not the Scala

00:44:16,530 --> 00:44:21,210
compiler will have will compile these

00:44:18,150 --> 00:44:24,210
para matching blocks in this form so

00:44:21,210 --> 00:44:26,130
what we see if then needs to do is this

00:44:24,210 --> 00:44:28,830
one it takes this partial function which

00:44:26,130 --> 00:44:30,990
is our para matching block the partial

00:44:28,830 --> 00:44:33,090
function takes a message and gives you

00:44:30,990 --> 00:44:37,290
back some type T which in this example

00:44:33,090 --> 00:44:40,020
here is again open you can instantiate

00:44:37,290 --> 00:44:42,420
it to any type you like and then it has

00:44:40,020 --> 00:44:45,660
to look currently in the currently

00:44:42,420 --> 00:44:47,970
executing actor so that's the self it

00:44:45,660 --> 00:44:50,730
looks in its mailbox so that's the cue

00:44:47,970 --> 00:44:53,040
of incoming messages and it extracts the

00:44:50,730 --> 00:44:55,770
first message of this queue which

00:44:53,040 --> 00:44:57,840
satisfies us given predicate so extract

00:44:55,770 --> 00:45:00,000
first that's just a method on our cues

00:44:57,840 --> 00:45:02,070
which given a predicate a boolean

00:45:00,000 --> 00:45:03,840
function gives you the first element in

00:45:02,070 --> 00:45:06,090
the queue for which the boolean function

00:45:03,840 --> 00:45:08,550
is true so what is the boolean function

00:45:06,090 --> 00:45:12,210
that we are looking after well it's just

00:45:08,550 --> 00:45:14,490
if F is defined at so if my parametric

00:45:12,210 --> 00:45:16,470
block is defined on the message I can

00:45:14,490 --> 00:45:19,650
handle it and I should do this too so if

00:45:16,470 --> 00:45:22,020
it's not defined on the message I skip

00:45:19,650 --> 00:45:24,050
to the next message and I try this one

00:45:22,020 --> 00:45:26,160
so here you have a very interesting

00:45:24,050 --> 00:45:26,930
example of something that you couldn't

00:45:26,160 --> 00:45:28,970
do

00:45:26,930 --> 00:45:31,790
if you were either object oriented or

00:45:28,970 --> 00:45:33,200
functional you can't do it an object in

00:45:31,790 --> 00:45:35,150
programming because you don't have data

00:45:33,200 --> 00:45:36,740
matching you don't have you can't deal

00:45:35,150 --> 00:45:38,990
with these functions impossible well

00:45:36,740 --> 00:45:40,790
people claim that they have done Ellen

00:45:38,990 --> 00:45:42,380
style I actors but every time you look

00:45:40,790 --> 00:45:44,660
at the actual implementation it's

00:45:42,380 --> 00:45:47,240
incredibly clumsy syntactically it's not

00:45:44,660 --> 00:45:48,770
the same not not at all the same of this

00:45:47,240 --> 00:45:51,079
elegance of pattern matching that you

00:45:48,770 --> 00:45:52,849
find in hearing people can't do it in

00:45:51,079 --> 00:45:55,220
functional languages either because a

00:45:52,849 --> 00:45:57,680
function is a function is a function you

00:45:55,220 --> 00:45:59,390
can't have special fund it sort of

00:45:57,680 --> 00:46:01,309
functions like partial functions and

00:45:59,390 --> 00:46:03,500
those we need here for The Dispatch so

00:46:01,309 --> 00:46:05,690
you can't add further stuff to functions

00:46:03,500 --> 00:46:07,849
you need you really need both concepts

00:46:05,690 --> 00:46:09,950
functions and the ability to treat

00:46:07,849 --> 00:46:12,290
functions as classes and to subclass

00:46:09,950 --> 00:46:16,250
them so that's sort of the added value

00:46:12,290 --> 00:46:18,260
that you get from that okay so if we

00:46:16,250 --> 00:46:21,950
look at other approaches to scalability

00:46:18,260 --> 00:46:25,730
I think C++ is a fairly scalable

00:46:21,950 --> 00:46:27,800
language at least upwards you can go

00:46:25,730 --> 00:46:29,720
into strata few stratosphere of

00:46:27,800 --> 00:46:32,299
abstractions and complexities it's very

00:46:29,720 --> 00:46:34,190
impressive but on the other hand you

00:46:32,299 --> 00:46:36,380
lose a lot of your people or the higher

00:46:34,190 --> 00:46:38,630
you go the more expert you need to be so

00:46:36,380 --> 00:46:41,750
if you can write boost libraries stuff

00:46:38,630 --> 00:46:46,400
you have to be pretty good scaling down

00:46:41,750 --> 00:46:48,290
is much harder for C++ dotnet has the

00:46:46,400 --> 00:46:50,599
idea that you have many languages and

00:46:48,290 --> 00:46:52,790
they're interoperable so that's the x by

00:46:50,599 --> 00:46:54,440
itself it's a very very interesting idea

00:46:52,790 --> 00:46:56,690
to say well let's concentrate on the

00:46:54,440 --> 00:46:58,760
glue the interpret operation and have

00:46:56,690 --> 00:47:00,650
many different languages but on the

00:46:58,760 --> 00:47:02,480
other hand the problem is the the dotnet

00:47:00,650 --> 00:47:04,819
language format really determines a lot

00:47:02,480 --> 00:47:06,710
what you can do so in a sense most

00:47:04,819 --> 00:47:08,690
dotnet languages are very similar to

00:47:06,710 --> 00:47:12,470
each other at least in what they do for

00:47:08,690 --> 00:47:14,599
the objects and then Java while Java is

00:47:12,470 --> 00:47:16,250
sort of the lingua franca that makes it

00:47:14,599 --> 00:47:18,140
very easy to understand other people's

00:47:16,250 --> 00:47:20,000
code but it's not easy to scale up or

00:47:18,140 --> 00:47:22,400
down so that means you can't really

00:47:20,000 --> 00:47:24,380
write scripts well in Java and if you

00:47:22,400 --> 00:47:26,240
want to do really domain-specific stuff

00:47:24,380 --> 00:47:27,950
it gets very difficult so that's

00:47:26,240 --> 00:47:32,780
precisely why we have this pressure to

00:47:27,950 --> 00:47:34,790
add new languages okay so maybe I wrap

00:47:32,780 --> 00:47:37,460
up just to tell you a little bit where

00:47:34,790 --> 00:47:41,599
we are now with Skylar community

00:47:37,460 --> 00:47:51,650
sorry 12 12 minutes well I thought I had

00:47:41,599 --> 00:47:54,230
to finish at five oh ok ok good I I

00:47:51,650 --> 00:47:57,470
thought I had to finish at 10 25 that's

00:47:54,230 --> 00:47:59,510
why I'm rushing ok good so I should ok

00:47:57,470 --> 00:48:03,800
then we can I can take a lot of

00:47:59,510 --> 00:48:06,349
questions after the talk so with the the

00:48:03,800 --> 00:48:08,060
Skylar community is it's quite active so

00:48:06,349 --> 00:48:11,060
we had about 50 thousand downloads

00:48:08,060 --> 00:48:12,650
overall in 2008 of course that would be

00:48:11,060 --> 00:48:14,660
people who have downloaded several

00:48:12,650 --> 00:48:18,890
versions of Scylla so I'm not claiming

00:48:14,660 --> 00:48:22,940
we have 50,000 users our track system

00:48:18,890 --> 00:48:26,060
for has about 300 active contributors we

00:48:22,940 --> 00:48:28,040
have act very active messages mailing

00:48:26,060 --> 00:48:31,940
lists with more than 20 messages a day

00:48:28,040 --> 00:48:35,359
and we have we had the first conference

00:48:31,940 --> 00:48:37,609
in may two thousand eight and so the

00:48:35,359 --> 00:48:39,950
first really scala conference and it's

00:48:37,609 --> 00:48:41,690
got a lift off in May 2008 and we also

00:48:39,950 --> 00:48:44,359
have regular talks in conferences like

00:48:41,690 --> 00:48:46,609
first and more the next two will be at q

00:48:44,359 --> 00:48:50,540
con in London of other people who will

00:48:46,609 --> 00:48:53,480
give talks about scanner tool support

00:48:50,540 --> 00:48:56,450
what what's available there so what we

00:48:53,480 --> 00:48:58,670
do is we have a standalone compiler

00:48:56,450 --> 00:49:01,810
called scalar C which has essentially

00:48:58,670 --> 00:49:04,070
the same functionality as Java Sea

00:49:01,810 --> 00:49:06,200
there's a faster version of this which

00:49:04,070 --> 00:49:08,119
is sort of a compiled demon which sits

00:49:06,200 --> 00:49:10,430
in memory and you send it compiled jobs

00:49:08,119 --> 00:49:12,109
and it will will do it for you and it

00:49:10,430 --> 00:49:14,540
will cash everything in memory and their

00:49:12,109 --> 00:49:17,240
way it's much faster that's called FSC

00:49:14,540 --> 00:49:19,910
there's an interactive interpreter shell

00:49:17,240 --> 00:49:22,339
which you have seen and script Rana

00:49:19,910 --> 00:49:24,260
that's called just Scala that actually

00:49:22,339 --> 00:49:27,859
uses this trick with the fast compiler

00:49:24,260 --> 00:49:36,810
so when I write when a type a line into

00:49:27,859 --> 00:49:40,690
my shell where is it ah how it comes

00:49:36,810 --> 00:49:43,540
when a type a line like this line i

00:49:40,690 --> 00:49:47,020
typed here so what actually happens is

00:49:43,540 --> 00:49:50,560
that when I do that the thing will be

00:49:47,020 --> 00:49:53,260
wrapped into a an object complete object

00:49:50,560 --> 00:49:54,580
it will be passed into the first Scala

00:49:53,260 --> 00:49:56,830
compiler the fast cars a scholar

00:49:54,580 --> 00:49:59,050
compiler will compute a class file and I

00:49:56,830 --> 00:50:01,090
will load the class file into the

00:49:59,050 --> 00:50:04,060
interpreter and execute it so that way

00:50:01,090 --> 00:50:05,860
the the interpreter and the compiler are

00:50:04,060 --> 00:50:07,510
really the same thing so we can have the

00:50:05,860 --> 00:50:09,280
assurance that it's exactly the same

00:50:07,510 --> 00:50:12,160
thing that gets compiled in exactly the

00:50:09,280 --> 00:50:14,440
same way and to make it work T we have

00:50:12,160 --> 00:50:16,360
this compiler sitting in the background

00:50:14,440 --> 00:50:21,990
that doesn't need to be loaded into

00:50:16,360 --> 00:50:29,280
memory every time I do that okay oops

00:50:21,990 --> 00:50:29,280
that wasn't it where is my hear ya okay

00:50:29,820 --> 00:50:37,510
okay then there's a web framework which

00:50:33,880 --> 00:50:39,460
is quite active I think they have 700

00:50:37,510 --> 00:50:41,260
people on the mailing lists which is

00:50:39,460 --> 00:50:45,820
called lift which is sort of in the same

00:50:41,260 --> 00:50:48,400
space as rails or Grails or frameworks

00:50:45,820 --> 00:50:50,500
like this sort of i do all web framework

00:50:48,400 --> 00:50:55,180
for you difference of course is that all

00:50:50,500 --> 00:50:57,670
this thing is statically typed and and a

00:50:55,180 --> 00:51:00,190
lot of testing frameworks here's just

00:50:57,670 --> 00:51:03,040
some cold specks scholar check scala

00:51:00,190 --> 00:51:05,170
test as unit and so on the first two are

00:51:03,040 --> 00:51:08,590
very interesting because they are

00:51:05,170 --> 00:51:10,660
behavioral testing frameworks where you

00:51:08,590 --> 00:51:12,550
don't write test cases or you can write

00:51:10,660 --> 00:51:14,530
test cases but typically you write

00:51:12,550 --> 00:51:16,630
properties of what your programs should

00:51:14,530 --> 00:51:18,670
offer your programs that you want your

00:51:16,630 --> 00:51:20,290
programs to have and the system then

00:51:18,670 --> 00:51:22,690
will generate the test cases for you

00:51:20,290 --> 00:51:24,730
based on the properties and the types of

00:51:22,690 --> 00:51:26,470
the properties there's something like

00:51:24,730 --> 00:51:28,540
that lee that in haskell called quick

00:51:26,470 --> 00:51:30,880
check it's very popular in the Haskell

00:51:28,540 --> 00:51:33,640
world so skaara check is basically a

00:51:30,880 --> 00:51:35,860
fairly fairly direct or started as a

00:51:33,640 --> 00:51:39,370
direct port of quick check to Skara and

00:51:35,860 --> 00:51:41,020
it has acquired new things since if

00:51:39,370 --> 00:51:42,520
you're familiar with Haskell you'll find

00:51:41,020 --> 00:51:45,610
that most of the things in Haskell you

00:51:42,520 --> 00:51:48,730
find in some often completely different

00:51:45,610 --> 00:51:50,589
form in Scala but we have tried to get a

00:51:48,730 --> 00:51:52,569
lot of the functionality of what is in

00:51:50,589 --> 00:51:54,759
eskalene to scala only in an

00:51:52,569 --> 00:51:56,170
object-oriented form so instead of let's

00:51:54,759 --> 00:51:57,969
say type classes which are very

00:51:56,170 --> 00:52:00,460
important in haskell and which i used

00:51:57,969 --> 00:52:02,140
for this quick check tool we have i

00:52:00,460 --> 00:52:04,359
mentioned array these implicit

00:52:02,140 --> 00:52:06,430
conversions and implicit parameters

00:52:04,359 --> 00:52:09,700
which give you the same functionality

00:52:06,430 --> 00:52:14,190
but in object-oriented form okay there

00:52:09,700 --> 00:52:19,210
are also now ide plugins for the major

00:52:14,190 --> 00:52:20,979
platforms so we have four we have

00:52:19,210 --> 00:52:23,380
started a number of years ago

00:52:20,979 --> 00:52:26,259
development on the eclipse plugin that's

00:52:23,380 --> 00:52:28,690
been taken over now by EDF trading in

00:52:26,259 --> 00:52:30,579
london day they support that there's

00:52:28,690 --> 00:52:32,920
intelligible and IntelliJ plug-in

00:52:30,579 --> 00:52:35,890
rapidly coming along which is done by

00:52:32,920 --> 00:52:38,619
JetBrains people there's a NetBeans

00:52:35,890 --> 00:52:42,039
plugin than bike IM ding and the support

00:52:38,619 --> 00:52:44,769
of Sun so the here I'm not saying that

00:52:42,039 --> 00:52:47,289
these things are already as polished and

00:52:44,769 --> 00:52:49,450
complete as the Java plugins but we're

00:52:47,289 --> 00:52:51,009
getting there so if you if you try them

00:52:49,450 --> 00:52:53,859
out there I think they're usable today

00:52:51,009 --> 00:52:56,440
lots of people use them we had a poll on

00:52:53,859 --> 00:52:59,140
the mailing list what what ide do people

00:52:56,440 --> 00:53:01,749
use about two-thirds of the respondents

00:52:59,140 --> 00:53:05,229
use one of these plugins one-third use

00:53:01,749 --> 00:53:07,749
Emacs or via VI or things like that i

00:53:05,229 --> 00:53:11,579
must say i use still mostly use Emacs

00:53:07,749 --> 00:53:11,579
but that's just because I'm old I think

00:53:11,759 --> 00:53:17,349
okay so who's using it open source

00:53:15,069 --> 00:53:20,049
projects I'm already mentioned lift

00:53:17,349 --> 00:53:23,619
there's a some movement in wicked to use

00:53:20,049 --> 00:53:25,630
it net logo that's the an environment

00:53:23,619 --> 00:53:28,710
and learning environment using the logo

00:53:25,630 --> 00:53:31,180
language so that's being ported to scala

00:53:28,710 --> 00:53:33,789
processing has a scholar version of it

00:53:31,180 --> 00:53:37,059
called SPD the Isabelle theorem prover

00:53:33,789 --> 00:53:39,339
has its gooey and code extractor are now

00:53:37,059 --> 00:53:42,369
based on scalo one version of its code

00:53:39,339 --> 00:53:44,650
extractor based on scholar companies are

00:53:42,369 --> 00:53:46,869
also warming up to it so twitter has

00:53:44,650 --> 00:53:49,239
based essentially they're all the new

00:53:46,869 --> 00:53:52,569
infrastructure work at twitter is now in

00:53:49,239 --> 00:53:54,279
scala used to be Ruby these only

00:53:52,569 --> 00:53:56,700
pictures middleware and it's only

00:53:54,279 --> 00:53:59,079
pictures enterprises is also in Scala

00:53:56,700 --> 00:54:02,560
nature.com the whole infrastructure

00:53:59,079 --> 00:54:05,950
instance cara SI p community has an

00:54:02,560 --> 00:54:08,350
as me that's an intercompany messaging

00:54:05,950 --> 00:54:10,840
system that's written in Scala react

00:54:08,350 --> 00:54:13,300
reactor was voted Europe's best small

00:54:10,840 --> 00:54:15,280
and middle midsize company to work at

00:54:13,300 --> 00:54:17,920
it's a Finnish company they have lots of

00:54:15,280 --> 00:54:19,780
scholar projects minimizes Republic does

00:54:17,920 --> 00:54:22,120
multiplayer games in Paris with Scala

00:54:19,780 --> 00:54:24,580
EDF trading I already mentioned they

00:54:22,120 --> 00:54:28,170
support the Eclipse plugin so this thing

00:54:24,580 --> 00:54:31,900
here that's not the scala community

00:54:28,170 --> 00:54:33,640
that's just this photo was first sent

00:54:31,900 --> 00:54:35,500
with Twitter in the world I think

00:54:33,640 --> 00:54:38,560
Twitter was the company that it was a

00:54:35,500 --> 00:54:40,720
somebody took it in with his iphone sent

00:54:38,560 --> 00:54:42,490
it to Twitter and they transmitted it so

00:54:40,720 --> 00:54:45,550
i would guess that there were some scala

00:54:42,490 --> 00:54:50,400
called involved to to do it or to bring

00:54:45,550 --> 00:54:55,000
this photo to you okay thanks so sorry

00:54:50,400 --> 00:54:57,100
yeah nothing the iphone no so to learn

00:54:55,000 --> 00:55:01,030
Scala what I would recommend to get

00:54:57,100 --> 00:55:04,240
started there's a website called artema

00:55:01,030 --> 00:55:06,220
calm and I have a scholar zine still in

00:55:04,240 --> 00:55:08,470
its infancy with Scala articles and

00:55:06,220 --> 00:55:10,810
there is a good one called first first

00:55:08,470 --> 00:55:13,120
steps in Scala which is essentially how

00:55:10,810 --> 00:55:15,190
do i deploy it how do i start up the

00:55:13,120 --> 00:55:17,290
repple how do i do type my first lines

00:55:15,190 --> 00:55:19,750
of scala that's very good to get started

00:55:17,290 --> 00:55:22,090
there's also a very useful series of

00:55:19,750 --> 00:55:23,800
blocks called scala for java refugees by

00:55:22,090 --> 00:55:26,620
daniel Spivak i can highly recommend

00:55:23,800 --> 00:55:28,480
that so if you want to continue in more

00:55:26,620 --> 00:55:31,210
determined than we've written a book

00:55:28,480 --> 00:55:33,100
called programming in scala published by

00:55:31,210 --> 00:55:36,190
our team or calm so that's the first

00:55:33,100 --> 00:55:38,260
book up here that sort of really

00:55:36,190 --> 00:55:40,990
explains everything you need to know

00:55:38,260 --> 00:55:43,150
from the easy part to the most

00:55:40,990 --> 00:55:44,860
complicated details so if you really

00:55:43,150 --> 00:55:47,470
want to know the whole story that's the

00:55:44,860 --> 00:55:49,660
book for you there are also several

00:55:47,470 --> 00:55:53,020
other introduct more introductory books

00:55:49,660 --> 00:55:54,520
in the pipeline by the braggs and a

00:55:53,020 --> 00:55:57,220
press and there's another one by

00:55:54,520 --> 00:56:00,820
o'reilly but i couldn't find the that i

00:55:57,220 --> 00:56:05,500
haven't seen a screen screen couch with

00:56:00,820 --> 00:56:09,130
a title yet so i couldn't include the

00:56:05,500 --> 00:56:10,570
title in this in this series so i'm at

00:56:09,130 --> 00:56:12,280
the end of the talk thank you for

00:56:10,570 --> 00:56:14,920
listening if you want to try it out

00:56:12,280 --> 00:56:17,079
that's the website scholar lang dork

00:56:14,920 --> 00:56:19,690
and should also take the opportunity to

00:56:17,079 --> 00:56:23,369
thank all the many many people who have

00:56:19,690 --> 00:56:23,369
worked on this and as

00:56:30,630 --> 00:56:48,960
question for supply by four variables

00:56:49,740 --> 00:56:55,990
for a variable oh right so for a while

00:56:53,890 --> 00:56:57,640
you mean yeah yeah so so there's a

00:56:55,990 --> 00:57:00,100
difference so the question is why why

00:56:57,640 --> 00:57:05,380
not have one do we have something to

00:57:00,100 --> 00:57:08,050
write so we can write def f equals that

00:57:05,380 --> 00:57:10,810
and you're the answer the question was

00:57:08,050 --> 00:57:12,430
why do I have a valid sequels like that

00:57:10,810 --> 00:57:15,130
so the difference is there's a

00:57:12,430 --> 00:57:17,050
difference in the evaluation if the

00:57:15,130 --> 00:57:21,160
function will be evaluated every time I

00:57:17,050 --> 00:57:24,070
write F I use its name so it's evaluated

00:57:21,160 --> 00:57:26,320
by name one says the value will be

00:57:24,070 --> 00:57:29,290
evaluated here when I you define it and

00:57:26,320 --> 00:57:30,670
every time I use the X i use its value

00:57:29,290 --> 00:57:33,430
so the difference is when are things

00:57:30,670 --> 00:57:35,350
evaluated for about definition it's like

00:57:33,430 --> 00:57:37,510
a variable initialization I evaluate

00:57:35,350 --> 00:57:39,400
when I write the Val for a function I

00:57:37,510 --> 00:57:41,730
wait until the function is called that's

00:57:39,400 --> 00:57:41,730

YouTube URL: https://www.youtube.com/watch?v=zqFryHC018k


