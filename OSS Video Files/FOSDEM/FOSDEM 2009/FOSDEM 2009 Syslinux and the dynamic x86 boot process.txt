Title: FOSDEM 2009 Syslinux and the dynamic x86 boot process
Publication date: 2011-12-22
Playlist: FOSDEM 2009
Description: 
	By H Peter Anvin

This talk will discuss the x86 boot process, how to make it work in a dynamic system, and the tradeoffs between versatility and reliability. It will also discuss the Syslinux modular interface and how to use it to quickly add new features with a minimum of coding.

Originally written during an all-night hacking session in 1994 with the intent to better support the then-ubiquitous install boot floppies, Syslinux has evolved over the years into a widely used boot loader suite with an advanced modular interface, with emphasis on ease of use and reliability. It is now the most commonly used x86 bootloader for removable media, and is increasingly used for conventional hard disk booting as well.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:00,000 --> 00:00:02,030
I

00:00:04,440 --> 00:00:08,990
you

00:00:06,470 --> 00:00:11,150
this part of the colonel track but I'm

00:00:08,990 --> 00:00:12,469
actually it's actually a bit of a line

00:00:11,150 --> 00:00:15,199
i'm not going to talk about the colonel

00:00:12,469 --> 00:00:22,130
at all the colonel is what comes

00:00:15,199 --> 00:00:26,689
afterwards so I work for the Intel open

00:00:22,130 --> 00:00:30,650
source technology center but it this is

00:00:26,689 --> 00:00:34,730
not an Intel project so don't blame them

00:00:30,650 --> 00:00:37,239
for that they also like me to put this

00:00:34,730 --> 00:00:37,239
up so

00:00:45,720 --> 00:00:52,750
syslinux a so right now is sweet the

00:00:49,360 --> 00:00:57,820
bootloaders it currently consists of

00:00:52,750 --> 00:01:00,550
four what I call derivatives this is a

00:00:57,820 --> 00:01:02,440
bit of a legacy term from when their

00:01:00,550 --> 00:01:04,870
differences between them was much bigger

00:01:02,440 --> 00:01:06,730
in terms of code it really comes down to

00:01:04,870 --> 00:01:09,730
different file system support the

00:01:06,730 --> 00:01:14,250
original syslinux in all caps just to be

00:01:09,730 --> 00:01:18,520
extra confusing is for fat file systems

00:01:14,250 --> 00:01:22,900
ms-dos file systems this was originally

00:01:18,520 --> 00:01:27,759
done for boot floppies follow that came

00:01:22,900 --> 00:01:30,250
network booting in in pxe linux this is

00:01:27,759 --> 00:01:34,710
named after the pxe standard which is

00:01:30,250 --> 00:01:38,920
the standard for network booting on x86

00:01:34,710 --> 00:01:41,650
follow that was iso linux boot from CD

00:01:38,920 --> 00:01:46,330
ROMs this of course from the iso 9660

00:01:41,650 --> 00:01:49,960
file system and most recently EXT linux

00:01:46,330 --> 00:01:54,190
as a general-purpose bootloader loads

00:01:49,960 --> 00:01:56,409
from linux ext2 ext3 file systems and I

00:01:54,190 --> 00:02:01,240
promised Ted that I'm going to get ext4

00:01:56,409 --> 00:02:05,110
in there really soon now right now this

00:02:01,240 --> 00:02:09,160
is only support the x86 BIOS platform

00:02:05,110 --> 00:02:14,549
and this dates back from when this was

00:02:09,160 --> 00:02:19,030
designed for boot floppies size mattered

00:02:14,549 --> 00:02:21,850
tremendously a flop isn't very big so

00:02:19,030 --> 00:02:26,290
any overhead not being left for the

00:02:21,850 --> 00:02:28,570
colonel was a major problem so the

00:02:26,290 --> 00:02:30,220
solution was to make it as small as

00:02:28,570 --> 00:02:33,850
possible and that meant assembly

00:02:30,220 --> 00:02:38,320
language this has since become a

00:02:33,850 --> 00:02:41,980
liability in terms of support and

00:02:38,320 --> 00:02:44,049
maintainability so where I am very much

00:02:41,980 --> 00:02:46,160
trying to get as much code out of the

00:02:44,049 --> 00:02:49,010
assembly as possible

00:02:46,160 --> 00:02:53,170
we have several sophisticated menu

00:02:49,010 --> 00:02:59,000
systems some are demon written by me and

00:02:53,170 --> 00:03:01,900
perhaps most important this is syslinux

00:02:59,000 --> 00:03:08,480
has been designed with a mod extensive

00:03:01,900 --> 00:03:10,100
it's extensible via a module API it also

00:03:08,480 --> 00:03:14,120
contains a couple of additional pieces

00:03:10,100 --> 00:03:19,280
which are useful for some people mem

00:03:14,120 --> 00:03:23,450
disk is a disk emulator it loads a chunk

00:03:19,280 --> 00:03:28,040
of memory it just has been the colonel

00:03:23,450 --> 00:03:30,080
and then allows the booting of any

00:03:28,040 --> 00:03:33,560
operating system that still uses the

00:03:30,080 --> 00:03:35,030
bios or for that matter another boot it

00:03:33,560 --> 00:03:37,040
can even be used to load another boot

00:03:35,030 --> 00:03:43,250
loader it's frequently used for

00:03:37,040 --> 00:03:45,650
diagnostics it contains G pixie Linux

00:03:43,250 --> 00:03:48,410
which is a collaboration with the ether

00:03:45,650 --> 00:03:52,070
boot project whose flagship product is G

00:03:48,410 --> 00:03:53,480
pixie this is as you prompt as you may

00:03:52,070 --> 00:03:56,690
be able to tell from the name and

00:03:53,480 --> 00:04:00,230
open-source pxe stack with enhanced

00:03:56,690 --> 00:04:02,959
capabilities this lets us use a bunch of

00:04:00,230 --> 00:04:06,890
additional network protocol in addition

00:04:02,959 --> 00:04:09,680
to the legacy tftp finally and this is a

00:04:06,890 --> 00:04:14,090
relatively new feature it contains a

00:04:09,680 --> 00:04:18,020
small tool called iso hybrid iso hybrid

00:04:14,090 --> 00:04:20,900
post processes and ISO image it only it

00:04:18,020 --> 00:04:24,890
only supports the ISO images that uses

00:04:20,900 --> 00:04:28,340
that uses iso Linux it makes them

00:04:24,890 --> 00:04:32,680
bootable from what bios thinks is a hard

00:04:28,340 --> 00:04:32,680
drive which includes a USB sticks

00:04:34,670 --> 00:04:41,940
now a lot of the things about this

00:04:39,620 --> 00:04:45,210
ultimately comes down to the fact that

00:04:41,940 --> 00:04:51,270
the x86 pc by now is an ancient platform

00:04:45,210 --> 00:04:54,240
i doubt that the TC has existed for

00:04:51,270 --> 00:04:56,730
forty-five percent of the entire

00:04:54,240 --> 00:05:05,730
existence of electronic computers so

00:04:56,730 --> 00:05:08,340
almost half the original IBM 5150 came

00:05:05,730 --> 00:05:11,670
out in 1981 and a lot of the BIOS

00:05:08,340 --> 00:05:14,370
definition was Oh dates back all the way

00:05:11,670 --> 00:05:18,630
to that one there were a few more things

00:05:14,370 --> 00:05:20,970
added in the IBM 80 and the ps2 that are

00:05:18,630 --> 00:05:23,790
still kind of considered consider

00:05:20,970 --> 00:05:28,100
standard this pretty much dates back

00:05:23,790 --> 00:05:34,280
from when IBM had you know firma not a

00:05:28,100 --> 00:05:41,190
firm leadership in the in the area and

00:05:34,280 --> 00:05:43,020
kind of after that now after that we

00:05:41,190 --> 00:05:45,990
only had floppy and hard disk rooting

00:05:43,020 --> 00:05:50,120
standard anything else required a custom

00:05:45,990 --> 00:05:50,120
rom for everything um

00:05:52,500 --> 00:05:57,540
this kind of led to a bit of an

00:05:55,350 --> 00:05:58,890
untenable situation where you know it

00:05:57,540 --> 00:06:02,880
seemed like no one could advance the

00:05:58,890 --> 00:06:06,090
platform and after a few kind of

00:06:02,880 --> 00:06:08,250
missteps there started to be kinda

00:06:06,090 --> 00:06:10,770
street consensus standards and one of

00:06:08,250 --> 00:06:12,890
the first ones of those was the cd-rom

00:06:10,770 --> 00:06:15,300
booting standard called El Torito

00:06:12,890 --> 00:06:17,580
supposedly named after the restaurant

00:06:15,300 --> 00:06:21,930
where the people who came up with a

00:06:17,580 --> 00:06:27,720
standard were had dinner came out in

00:06:21,930 --> 00:06:29,910
1993 El Torito contains two modes one is

00:06:27,720 --> 00:06:31,919
you have a disk image on the CD and it

00:06:29,910 --> 00:06:34,320
just boots as we've been a disc and the

00:06:31,919 --> 00:06:37,669
other one is so-called native mode where

00:06:34,320 --> 00:06:42,300
you can actually access the entire CD

00:06:37,669 --> 00:06:45,300
unfortunately the native mode didn't

00:06:42,300 --> 00:06:50,669
work very well in many biases until the

00:06:45,300 --> 00:06:53,490
late 90s similarly we had a network

00:06:50,669 --> 00:06:57,780
booting standard originally developed by

00:06:53,490 --> 00:07:02,820
Intel came out in 1997 and revised in

00:06:57,780 --> 00:07:04,710
1999 some of the again some of the early

00:07:02,820 --> 00:07:07,320
code were really really problematic

00:07:04,710 --> 00:07:09,780
there and even today we are seeing a

00:07:07,320 --> 00:07:12,650
fair number of bugs but at the very

00:07:09,780 --> 00:07:15,750
least this broad standard

00:07:12,650 --> 00:07:21,210
standards-based network booting to the

00:07:15,750 --> 00:07:23,550
x86 platform USB drives is the most

00:07:21,210 --> 00:07:29,040
recent collection of the to the PC

00:07:23,550 --> 00:07:32,669
bootable zoo they just appear as as reg

00:07:29,040 --> 00:07:34,919
conventional disk drives at least when

00:07:32,669 --> 00:07:38,100
there aren't bugs and unfortunately

00:07:34,919 --> 00:07:40,310
there are still bugs in a lot of biases

00:07:38,100 --> 00:07:43,650
there is however tricks that can help

00:07:40,310 --> 00:07:46,200
the syslinux wiki and the sis Linux

00:07:43,650 --> 00:07:48,540
mailing list have collected a fair

00:07:46,200 --> 00:07:50,280
number of tricks that work seems to work

00:07:48,540 --> 00:07:53,280
for a lot of people and it's a good

00:07:50,280 --> 00:07:53,960
place to get some more information on

00:07:53,280 --> 00:08:00,300
that

00:07:53,960 --> 00:08:03,300
so syslinux product itself was came out

00:08:00,300 --> 00:08:07,800
of a overnight hacking binge that I had

00:08:03,300 --> 00:08:10,620
in 1994 I had just had a miserable

00:08:07,800 --> 00:08:13,680
experience reinstalling the machine with

00:08:10,620 --> 00:08:16,830
Linux where I found out that I needed a

00:08:13,680 --> 00:08:19,590
special carnal for the driver that I had

00:08:16,830 --> 00:08:25,230
this was before modules were widely used

00:08:19,590 --> 00:08:26,760
to linux world and you know I had to

00:08:25,230 --> 00:08:31,110
boot from this floppy which was a

00:08:26,760 --> 00:08:33,450
completely opaque object and you know I

00:08:31,110 --> 00:08:37,169
didn't have another linux machine handy

00:08:33,450 --> 00:08:39,300
and so basically I had to give up until

00:08:37,169 --> 00:08:41,820
I could go somewhere else where there

00:08:39,300 --> 00:08:46,800
was another linux machine I thought this

00:08:41,820 --> 00:08:52,830
really sucks like this is just wrong you

00:08:46,800 --> 00:08:56,760
know so I decided to go out and write a

00:08:52,830 --> 00:08:59,220
bootloader that would actually boot from

00:08:56,760 --> 00:09:01,770
a floppy that another operating system

00:08:59,220 --> 00:09:04,530
would recognize so that you could take

00:09:01,770 --> 00:09:07,160
your legacy operating system you know

00:09:04,530 --> 00:09:09,450
there was das primarily back then and

00:09:07,160 --> 00:09:11,910
actually make your linux boot floppy

00:09:09,450 --> 00:09:15,000
even if you have to do custom stuff and

00:09:11,910 --> 00:09:16,410
it should look like a das floppy you

00:09:15,000 --> 00:09:22,070
know dose should be able to read it or

00:09:16,410 --> 00:09:24,420
should be able to write it and hence I

00:09:22,070 --> 00:09:26,220
you know it needed to understand the

00:09:24,420 --> 00:09:28,950
file system there was underneath this

00:09:26,220 --> 00:09:30,750
was in contrast to lie low which was the

00:09:28,950 --> 00:09:34,680
dominant linux boot loader at the time

00:09:30,750 --> 00:09:37,650
which only which contain or only did raw

00:09:34,680 --> 00:09:42,120
blocks you know didn't actually look at

00:09:37,650 --> 00:09:45,030
file systems at all so oh it's kind of

00:09:42,120 --> 00:09:47,400
ok a lot of distributions adopted this

00:09:45,030 --> 00:09:49,050
for for their boot floppy boot flop its

00:09:47,400 --> 00:09:51,360
were pretty ubiquitous that back then

00:09:49,050 --> 00:09:53,760
out of some features that some people

00:09:51,360 --> 00:09:55,890
like like on you know to help the

00:09:53,760 --> 00:09:57,100
distros primarily added online help

00:09:55,890 --> 00:09:58,990
support

00:09:57,100 --> 00:10:04,600
in in the boot loader this is kind of a

00:09:58,990 --> 00:10:08,820
revolutionary idea at the time so kind

00:10:04,600 --> 00:10:11,590
of move on pics pixie comes along and

00:10:08,820 --> 00:10:13,450
okay we should have a you know we should

00:10:11,590 --> 00:10:15,400
be able to boot linux off a pixie this

00:10:13,450 --> 00:10:22,810
you know this this network booting thing

00:10:15,400 --> 00:10:27,460
is good well so I you know look at the

00:10:22,810 --> 00:10:30,040
pixie spec at its and the spec says that

00:10:27,460 --> 00:10:33,310
the the network boot program which is

00:10:30,040 --> 00:10:36,520
the first stage bootloader in the pixie

00:10:33,310 --> 00:10:39,310
scheme of things should only be 32

00:10:36,520 --> 00:10:41,740
kilobytes long like wow that's pretty

00:10:39,310 --> 00:10:44,710
restrictive I'm going to need a pretty

00:10:41,740 --> 00:10:47,350
small boot loader wait I already have a

00:10:44,710 --> 00:10:50,050
pretty small boot loader so rather than

00:10:47,350 --> 00:10:52,780
starting over from scratch let's take

00:10:50,050 --> 00:10:56,430
this thing that I already have and beat

00:10:52,780 --> 00:11:04,810
on it until it does roughly what I need

00:10:56,430 --> 00:11:06,760
so this worked eventually and users

00:11:04,810 --> 00:11:09,280
liked it because you know by this time

00:11:06,760 --> 00:11:11,680
sis Linux had kind of matured enough

00:11:09,280 --> 00:11:14,110
that it got most of the features that

00:11:11,680 --> 00:11:18,040
people that people really depended upon

00:11:14,110 --> 00:11:19,540
in it already as like suddenly you have

00:11:18,040 --> 00:11:21,460
another / you know you have another

00:11:19,540 --> 00:11:24,190
medium you can use all the same features

00:11:21,460 --> 00:11:28,840
it's just good so kind of on that

00:11:24,190 --> 00:11:34,960
general note like okay this is this is

00:11:28,840 --> 00:11:37,360
kind of cool lets you know so decided to

00:11:34,960 --> 00:11:41,880
next tackle cd-roms and actually be able

00:11:37,360 --> 00:11:44,980
to boot CD ROMs in native mode this was

00:11:41,880 --> 00:11:47,980
different from you know the disk image

00:11:44,980 --> 00:11:50,650
variety and the dip and the reason the

00:11:47,980 --> 00:11:52,690
motivator for it was that the disk

00:11:50,650 --> 00:11:55,330
images were getting too small they were

00:11:52,690 --> 00:11:59,680
getting too cramped people were already

00:11:55,330 --> 00:12:02,170
using syslinux on the disk images but so

00:11:59,680 --> 00:12:05,770
let's give them access to hook to the

00:12:02,170 --> 00:12:06,400
whole to the whole disk this became ISIL

00:12:05,770 --> 00:12:09,940
enix

00:12:06,400 --> 00:12:12,700
a few years later than that you know a

00:12:09,940 --> 00:12:15,400
little bit more maturing and so on but

00:12:12,700 --> 00:12:16,990
you know there's I kind of gotten this

00:12:15,400 --> 00:12:20,950
whole thing about supporting multiple

00:12:16,990 --> 00:12:25,210
file systems down reasonably well you

00:12:20,950 --> 00:12:27,640
know should actually and should actually

00:12:25,210 --> 00:12:30,930
be able make this so that i can use it

00:12:27,640 --> 00:12:39,520
as a general general purpose bootloader

00:12:30,930 --> 00:12:41,230
and that was EXT linux in 2004 i did

00:12:39,520 --> 00:12:43,840
apparently did quite a lot of work

00:12:41,230 --> 00:12:46,510
because that's also where the modular

00:12:43,840 --> 00:12:52,030
api and the menu system was first

00:12:46,510 --> 00:12:53,710
written 2006 a lot of people like yeah

00:12:52,030 --> 00:12:55,900
but like this menu system but it's not

00:12:53,710 --> 00:12:59,550
flashy enough so eventually like fine

00:12:55,900 --> 00:13:05,800
fine fine fancy graphics you got it and

00:12:59,550 --> 00:13:08,650
in 2008 g pixie linux and ISIL linux

00:13:05,800 --> 00:13:13,110
hybrid support which is the USB key the

00:13:08,650 --> 00:13:13,110
iso image that also works in the USB key

00:13:13,290 --> 00:13:19,750
so what's good about sis linic the

00:13:17,080 --> 00:13:21,520
number one thing that's this link does

00:13:19,750 --> 00:13:23,800
different than other boot loaders or

00:13:21,520 --> 00:13:25,570
most of the boot loaders is that it was

00:13:23,800 --> 00:13:27,460
from the very beginning to sign for

00:13:25,570 --> 00:13:30,010
dynamic systems it was designed for

00:13:27,460 --> 00:13:32,590
floppies after all and on a floppy you

00:13:30,010 --> 00:13:34,180
can't assume that you know you're going

00:13:32,590 --> 00:13:38,110
to boot it on the same system that you

00:13:34,180 --> 00:13:40,150
originally created a floppy on um but

00:13:38,110 --> 00:13:45,790
i've tried to keep true to that

00:13:40,150 --> 00:13:50,530
principle and do system discovery at

00:13:45,790 --> 00:13:54,100
boot time I do I try very very hard to

00:13:50,530 --> 00:13:57,090
keep syslinux such that you should make

00:13:54,100 --> 00:13:58,930
be able to make almost any arbitrary

00:13:57,090 --> 00:14:00,490
reconfiguration of your system you

00:13:58,930 --> 00:14:05,050
should be able to pull out half your

00:14:00,490 --> 00:14:06,970
hard drives rearrange them you know put

00:14:05,050 --> 00:14:11,190
them in putting another system whatever

00:14:06,970 --> 00:14:14,980
it should still work if at all possible

00:14:11,190 --> 00:14:18,230
the other basic principle I've tried to

00:14:14,980 --> 00:14:21,260
keep true to is place nice with others

00:14:18,230 --> 00:14:24,050
I tried to stick very closely to the

00:14:21,260 --> 00:14:26,870
established principles for booting a PC

00:14:24,050 --> 00:14:32,750
which is somewhat they're somewhat

00:14:26,870 --> 00:14:34,490
arcane and they're somewhat restricting

00:14:32,750 --> 00:14:37,880
but for example I don't support

00:14:34,490 --> 00:14:40,550
installing into the MBR as some other

00:14:37,880 --> 00:14:43,730
boot loaders do simply because it makes

00:14:40,550 --> 00:14:50,720
the job of dealing with other operating

00:14:43,730 --> 00:14:52,520
systems that do weird stuff harder by

00:14:50,720 --> 00:14:55,820
now we have a pretty sophisticated user

00:14:52,520 --> 00:14:57,500
interface and we have again the modular

00:14:55,820 --> 00:15:03,830
API which I'm going to talk more about

00:14:57,500 --> 00:15:07,220
later what's this problems well first of

00:15:03,830 --> 00:15:10,790
all Lord it has a large core of assembly

00:15:07,220 --> 00:15:13,760
code this was this was you this was

00:15:10,790 --> 00:15:19,460
useful for size but it really has become

00:15:13,760 --> 00:15:22,760
a liability again we're only it's only a

00:15:19,460 --> 00:15:25,460
real ability on the x86 bias platform

00:15:22,760 --> 00:15:30,890
and this is pretty much because of the

00:15:25,460 --> 00:15:35,330
large assembly core well the whole thing

00:15:30,890 --> 00:15:37,970
about playing nice with others and doing

00:15:35,330 --> 00:15:42,440
dynamic discovery does come at a price

00:15:37,970 --> 00:15:45,710
and that is in a lot of boot loaders you

00:15:42,440 --> 00:15:47,960
can do such things as you know the boot

00:15:45,710 --> 00:15:51,650
loaders install a one draw on one disk

00:15:47,960 --> 00:15:53,900
and it will read a colonel from a file

00:15:51,650 --> 00:15:57,320
system on a different disk I don't

00:15:53,900 --> 00:16:00,650
support that mostly because it's not

00:15:57,320 --> 00:16:04,310
very clear what that even means in a

00:16:00,650 --> 00:16:06,260
dynamic system you know you then this

00:16:04,310 --> 00:16:09,710
drive maybe you know this dry maybe

00:16:06,260 --> 00:16:13,490
drives 0 and and that dry maybe drive to

00:16:09,710 --> 00:16:15,980
today but there is no guarantee that

00:16:13,490 --> 00:16:17,690
that's going to be the same the act of

00:16:15,980 --> 00:16:22,090
the case when the system is actually

00:16:17,690 --> 00:16:25,600
booted so

00:16:22,090 --> 00:16:28,880
there are ways one can work her out that

00:16:25,600 --> 00:16:30,800
but I haven't really I found one in

00:16:28,880 --> 00:16:33,950
general when I've asked for people well

00:16:30,800 --> 00:16:36,500
I have this I need this feature and I I

00:16:33,950 --> 00:16:39,200
generally want to ask them why do what

00:16:36,500 --> 00:16:41,360
do you need it what do you you know well

00:16:39,200 --> 00:16:45,380
I'm doing this and and there's usually

00:16:41,360 --> 00:16:47,720
another usually better way of doing what

00:16:45,380 --> 00:16:51,260
what they're needed to do now I'm fully

00:16:47,720 --> 00:16:55,490
willing to be convinced that this is you

00:16:51,260 --> 00:17:00,070
know I'm have to narrow view but this

00:16:55,490 --> 00:17:04,010
has turned out to be the case so far um

00:17:00,070 --> 00:17:06,860
I want to talk a little bit about G

00:17:04,010 --> 00:17:09,350
pixie Linux here because it's it's a

00:17:06,860 --> 00:17:12,590
it's a little bit of a segue but it's

00:17:09,350 --> 00:17:15,830
kind of a it's kind of a cool thing so

00:17:12,590 --> 00:17:21,350
this G pixie comes from the ether boot

00:17:15,830 --> 00:17:22,820
project it is G pixie and and we and we

00:17:21,350 --> 00:17:27,410
have them taken it and put it together

00:17:22,820 --> 00:17:31,880
with pixie Linux into one image what now

00:17:27,410 --> 00:17:34,820
G pixie provides an extended pixel

00:17:31,880 --> 00:17:40,070
interface which is specifically designed

00:17:34,820 --> 00:17:43,190
for pixie Linux so pixie Linux has some

00:17:40,070 --> 00:17:45,590
special bits 4G pixie and GPS on special

00:17:43,190 --> 00:17:48,890
bits for pixie Linux you put these

00:17:45,590 --> 00:17:52,840
together you can boot over the you know

00:17:48,890 --> 00:17:57,860
over a variety of network protocols

00:17:52,840 --> 00:18:03,170
currently we're up to HTTP FTP NFS ATA

00:17:57,860 --> 00:18:05,420
over ethernet I scuzzy fsp and I think

00:18:03,170 --> 00:18:07,160
there are like 23 other protocols which

00:18:05,420 --> 00:18:13,100
are just too obscure for me to remember

00:18:07,160 --> 00:18:16,340
right now the goal is for this is that

00:18:13,100 --> 00:18:17,990
you should be able to the goal for this

00:18:16,340 --> 00:18:22,040
was that you should be able to swap in

00:18:17,990 --> 00:18:25,580
and out pixie Linux in an existing

00:18:22,040 --> 00:18:28,610
configuration to have it just work we

00:18:25,580 --> 00:18:31,970
are about ninety-five percent there

00:18:28,610 --> 00:18:34,970
there is one semi obscure feature of

00:18:31,970 --> 00:18:40,460
pixie Linux that is not supported in GP

00:18:34,970 --> 00:18:44,360
the Linux yet but it works for the vast

00:18:40,460 --> 00:18:46,909
majority of users this lets you do

00:18:44,360 --> 00:18:49,549
things like well I want to dynamically

00:18:46,909 --> 00:18:51,470
generate configuration files well I can

00:18:49,549 --> 00:18:54,140
just do it what yeah I can just put it

00:18:51,470 --> 00:18:58,030
up on a paci and you know do a CGI

00:18:54,140 --> 00:19:00,530
script that know how to do that if

00:18:58,030 --> 00:19:02,929
you're doing it this way you need you

00:19:00,530 --> 00:19:06,620
still need a tftp server for the initial

00:19:02,929 --> 00:19:08,870
bootstrap this is because the the pic

00:19:06,620 --> 00:19:13,760
the t the pixie stack that came on your

00:19:08,870 --> 00:19:16,460
own your card only supports tftp now if

00:19:13,760 --> 00:19:19,880
you are willing to reflash your neck and

00:19:16,460 --> 00:19:22,419
put g pixie on your neck then you don't

00:19:19,880 --> 00:19:22,419
even need that

00:19:26,450 --> 00:19:36,020
so I wanted to show a little little demo

00:19:30,080 --> 00:19:39,050
this and there's no safety net for this

00:19:36,020 --> 00:19:43,310
I am going to boot a virtual machine

00:19:39,050 --> 00:19:50,470
over over the internet from a server in

00:19:43,310 --> 00:19:56,300
California and the only thing that is

00:19:50,470 --> 00:20:01,190
kind of local on this is this this is

00:19:56,300 --> 00:20:04,490
the cd-rom image that has G pixie on it

00:20:01,190 --> 00:20:08,210
the actual G pics image is about 64

00:20:04,490 --> 00:20:11,830
kilobytes if you put it in a rom it

00:20:08,210 --> 00:20:11,830
would be a lot smaller than this

00:20:16,290 --> 00:20:20,559
so this is G pixie

00:20:18,700 --> 00:20:23,850
we'll start up do

00:20:20,559 --> 00:20:23,850
usual discovery

00:20:28,930 --> 00:20:34,560
well it just download the pixi linux

00:20:31,150 --> 00:20:37,800
from California it's hunting for a

00:20:34,560 --> 00:20:37,800
configuration file

00:21:01,270 --> 00:21:06,060
this takes it this takes a little bit

00:21:03,070 --> 00:21:06,060
yeah

00:21:15,450 --> 00:21:22,860
this is the actor this is the SIS Linux

00:21:17,850 --> 00:21:24,840
menu system you have sub menus and you

00:21:22,860 --> 00:21:28,110
know graphical backgrounds and all that

00:21:24,840 --> 00:21:34,139
sort of stuff in this case let's try to

00:21:28,110 --> 00:21:37,740
boot Tom's boot disk again this is over

00:21:34,139 --> 00:21:40,909
this is from this is over HTTP from a

00:21:37,740 --> 00:21:40,909
web server in California

00:22:00,720 --> 00:22:05,400
now it's just booting so I'm gonna

00:22:05,990 --> 00:22:09,700
and there we are

00:22:18,600 --> 00:22:21,200
now

00:22:22,420 --> 00:22:28,730
some mention syslinux has this module

00:22:26,090 --> 00:22:35,990
API which is designed to be very

00:22:28,730 --> 00:22:39,170
flexible this was actually sort of this

00:22:35,990 --> 00:22:41,090
is kind of a good example on how

00:22:39,170 --> 00:22:47,450
interesting things come from unexpected

00:22:41,090 --> 00:22:50,810
places this is actually done because

00:22:47,450 --> 00:22:55,670
someone's because a former colleague of

00:22:50,810 --> 00:23:00,890
mine said can't you know can't you

00:22:55,670 --> 00:23:03,140
support booting dost I'll com images and

00:23:00,890 --> 00:23:08,120
I'm like well they're really easy to

00:23:03,140 --> 00:23:10,940
support i I'm you know might as well you

00:23:08,120 --> 00:23:16,250
know why do you need it well you know

00:23:10,940 --> 00:23:18,680
this I have I have this this network

00:23:16,250 --> 00:23:22,060
boot loader called netboot which was the

00:23:18,680 --> 00:23:26,680
predecessor of the ether boot project

00:23:22,060 --> 00:23:29,150
that comes as a dot-com file okay fine

00:23:26,680 --> 00:23:31,250
this was kind of sitting in there for

00:23:29,150 --> 00:23:33,800
this is sitting into this one for quite

00:23:31,250 --> 00:23:36,620
a long time and not really being used at

00:23:33,800 --> 00:23:40,520
some point I said well you know yeah

00:23:36,620 --> 00:23:42,320
this is 16-bit calm stuff but you know

00:23:40,520 --> 00:23:44,690
we should really have 32 something

00:23:42,320 --> 00:23:51,140
32-bit then there as well so came up

00:23:44,690 --> 00:23:53,780
with calm 32 eventually kind of said

00:23:51,140 --> 00:23:55,460
well let's make it easier to write one

00:23:53,780 --> 00:23:59,120
of these modules and maybe someone will

00:23:55,460 --> 00:24:01,940
actually use it so I had already written

00:23:59,120 --> 00:24:04,070
a small C library that was intended to

00:24:01,940 --> 00:24:08,200
be bundled with a linux kernel called

00:24:04,070 --> 00:24:13,220
caleb see so i ported it to this other

00:24:08,200 --> 00:24:15,440
system call interface calm 32 so what

00:24:13,220 --> 00:24:17,540
you end up with is that you have a

00:24:15,440 --> 00:24:21,650
programming environment which is

00:24:17,540 --> 00:24:23,810
basically standards the environment most

00:24:21,650 --> 00:24:28,600
of the stuff you expect the standard c

00:24:23,810 --> 00:24:31,790
environment to have is there the biggest

00:24:28,600 --> 00:24:35,030
thing is that you kissed that when you

00:24:31,790 --> 00:24:37,070
open a file you can only do

00:24:35,030 --> 00:24:38,810
read only and you can only read it

00:24:37,070 --> 00:24:44,660
sequentially there's no support for

00:24:38,810 --> 00:24:49,100
Sikhs this turns out to be a pretty

00:24:44,660 --> 00:24:52,430
small problem for most users you can

00:24:49,100 --> 00:24:54,650
live with this and the interesting part

00:24:52,430 --> 00:24:56,870
of it is that these modules don't even

00:24:54,650 --> 00:24:58,790
need to know whether or not they're

00:24:56,870 --> 00:25:01,850
booting from is you know you're reading

00:24:58,790 --> 00:25:04,580
these files from a CD from you know a

00:25:01,850 --> 00:25:09,220
hard drive or from a network connections

00:25:04,580 --> 00:25:11,840
from across the world so the most common

00:25:09,220 --> 00:25:14,330
types of modules that people have

00:25:11,840 --> 00:25:16,460
written and this is sort of it you know

00:25:14,330 --> 00:25:19,880
this is a rough taxonomy and doesn't fit

00:25:16,460 --> 00:25:23,360
everything but it's a good example what

00:25:19,880 --> 00:25:25,160
people can and do do first of all you

00:25:23,360 --> 00:25:28,060
obviously have user interface is the

00:25:25,160 --> 00:25:33,980
menu system that you already saw is

00:25:28,060 --> 00:25:36,890
implemented as entirely as a module we

00:25:33,980 --> 00:25:40,040
have file format modules this is ways to

00:25:36,890 --> 00:25:44,810
support loading new types of kernels of

00:25:40,040 --> 00:25:47,180
various sorts policy modules which are

00:25:44,810 --> 00:25:49,310
this is what I want to do in this

00:25:47,180 --> 00:25:53,920
situation so that the user doesn't have

00:25:49,310 --> 00:25:57,040
to do it for me and diagnostic modules

00:25:53,920 --> 00:26:01,940
hardware diagnostics mostly user

00:25:57,040 --> 00:26:03,770
interfaces right now there are in in

00:26:01,940 --> 00:26:06,470
bundled with the sis linux distribution

00:26:03,770 --> 00:26:10,550
there are there are two different menu

00:26:06,470 --> 00:26:13,070
systems the very first one was the

00:26:10,550 --> 00:26:16,040
complex menu system written by Murali

00:26:13,070 --> 00:26:19,040
ganapati it was them while he was at the

00:26:16,040 --> 00:26:24,020
University of Chicago this thing does

00:26:19,040 --> 00:26:27,290
everything I have some screenshots on it

00:26:24,020 --> 00:26:29,660
on my website it will it does things

00:26:27,290 --> 00:26:32,660
like you can have cascading sub menus

00:26:29,660 --> 00:26:35,570
and dialog boxes we're setting a dialog

00:26:32,660 --> 00:26:37,280
box here changes the command line in a

00:26:35,570 --> 00:26:39,470
completely different menu and you have a

00:26:37,280 --> 00:26:40,880
little status bar at the bottom of the

00:26:39,470 --> 00:26:42,809
screen showing you what you're currently

00:26:40,880 --> 00:26:47,399
doing

00:26:42,809 --> 00:26:49,649
trust me that-like for a large site that

00:26:47,399 --> 00:26:51,779
just needs this and this enormous

00:26:49,649 --> 00:26:54,539
flexibility as they apparently did at

00:26:51,779 --> 00:27:02,340
University of Chicago it's absolutely

00:26:54,539 --> 00:27:05,789
unbeatable the simple menu system came

00:27:02,340 --> 00:27:08,490
later this was after people were people

00:27:05,789 --> 00:27:10,440
were saying well yeah this menu system

00:27:08,490 --> 00:27:13,320
that you have is it's really cool but

00:27:10,440 --> 00:27:16,799
it's way too much work to configure for

00:27:13,320 --> 00:27:19,710
most people it really is so a simple

00:27:16,799 --> 00:27:23,190
menu system just takes a simple file or

00:27:19,710 --> 00:27:25,409
set of files and you know pretty

00:27:23,190 --> 00:27:29,940
straightforward just low you know

00:27:25,409 --> 00:27:34,169
presents a menu and not without too much

00:27:29,940 --> 00:27:37,830
fanciness there's a graphics library in

00:27:34,169 --> 00:27:40,619
here with with which is designed to make

00:27:37,830 --> 00:27:43,440
the same code work for either a

00:27:40,619 --> 00:27:47,190
graphical console a text console or a

00:27:43,440 --> 00:27:52,470
serial console the code in the menu

00:27:47,190 --> 00:27:59,419
system that you saw is the same for all

00:27:52,470 --> 00:28:03,330
three types of consoles in fact if the

00:27:59,419 --> 00:28:06,679
graphics lie if that menu system had

00:28:03,330 --> 00:28:09,509
booted and found that we didn't have a

00:28:06,679 --> 00:28:12,080
graphics card that it could use it would

00:28:09,509 --> 00:28:14,730
just have defaulted back to text mode

00:28:12,080 --> 00:28:16,679
similarly if it had found that it had a

00:28:14,730 --> 00:28:19,409
serial console it would just have used

00:28:16,679 --> 00:28:21,929
the zero console in fact the serial

00:28:19,409 --> 00:28:24,539
console works at the same you know he

00:28:21,929 --> 00:28:26,700
works in parallel with the display

00:28:24,539 --> 00:28:28,950
console so that you can either be a

00:28:26,700 --> 00:28:31,950
human being touching the physical

00:28:28,950 --> 00:28:35,269
console or you can be a you know on a

00:28:31,950 --> 00:28:39,179
remote terminal server somewhere else

00:28:35,269 --> 00:28:42,629
now obviously if you're using graphics

00:28:39,179 --> 00:28:46,559
features like you're using little icons

00:28:42,629 --> 00:28:48,990
for example well and you're bypassing

00:28:46,559 --> 00:28:51,590
this sort of console library well

00:28:48,990 --> 00:28:54,710
there's not much I can do about that

00:28:51,590 --> 00:28:59,750
but this is of course allowed if you

00:28:54,710 --> 00:29:03,080
want it file format modules are a way to

00:28:59,750 --> 00:29:08,380
you know it's a module that you that

00:29:03,080 --> 00:29:08,380
implements a new type of loadable object

00:29:10,210 --> 00:29:19,070
again the goal has been to make these

00:29:12,679 --> 00:29:25,250
easy to write so in order to do that the

00:29:19,070 --> 00:29:28,399
module describes where in memory things

00:29:25,250 --> 00:29:31,159
should be going you don't actually ask

00:29:28,399 --> 00:29:33,380
the module author have to do the work of

00:29:31,159 --> 00:29:36,500
actually putting it into the proper

00:29:33,380 --> 00:29:39,559
place you just have to tell the rest of

00:29:36,500 --> 00:29:43,340
the library where things should be going

00:29:39,559 --> 00:29:48,070
and then there is this thing called the

00:29:43,340 --> 00:29:51,830
shuffle library the shuffle library

00:29:48,070 --> 00:29:54,320
looks at where things are now where

00:29:51,830 --> 00:29:59,029
things need to be and what scrap memory

00:29:54,320 --> 00:30:03,320
it has to play with and compute a set of

00:29:59,029 --> 00:30:05,659
move operations that will put that will

00:30:03,320 --> 00:30:08,559
end up with everything in the right

00:30:05,659 --> 00:30:08,559
place at the end

00:30:08,780 --> 00:30:15,330
an example on this is the microsoft

00:30:12,090 --> 00:30:17,370
system deployment image format I had

00:30:15,330 --> 00:30:20,310
never heard of this until someone asked

00:30:17,370 --> 00:30:24,450
me hey I want to boot winpe with

00:30:20,310 --> 00:30:27,960
syslinux it's like okay I don't know the

00:30:24,450 --> 00:30:30,420
first thing about when p turns out that

00:30:27,960 --> 00:30:33,800
they have this this thing called SDI

00:30:30,420 --> 00:30:36,360
which is roughly the equivalent of 0

00:30:33,800 --> 00:30:40,710
roughly the equivalent of having a linux

00:30:36,360 --> 00:30:44,720
kernel and a ramdisk it's kind of

00:30:40,710 --> 00:30:44,720
basically a Windows kernel and a ramdisk

00:30:46,310 --> 00:30:55,170
supporting this format took a module

00:30:50,400 --> 00:30:58,320
that was 199 lines of c code 139 lines

00:30:55,170 --> 00:31:00,150
of those were actual lines that actually

00:30:58,320 --> 00:31:03,720
did something including lines that have

00:31:00,150 --> 00:31:07,580
single curly braces on them most of that

00:31:03,720 --> 00:31:10,500
is taken up by error handling meaning

00:31:07,580 --> 00:31:12,840
the you know look at this header field

00:31:10,500 --> 00:31:15,510
you know this is not the right type of

00:31:12,840 --> 00:31:17,910
header field you know this if this

00:31:15,510 --> 00:31:19,740
problem then error this if that problem

00:31:17,910 --> 00:31:22,830
then error that if this problem error

00:31:19,740 --> 00:31:25,920
that that's actually you know the the

00:31:22,830 --> 00:31:34,650
end the resulting code is is is very

00:31:25,920 --> 00:31:37,610
small diagnostic modules are modules to

00:31:34,650 --> 00:31:44,010
tell you about heart about your hardware

00:31:37,610 --> 00:31:48,380
the one of the first ones was pci dumper

00:31:44,010 --> 00:31:48,380
written by erwin here

00:31:49,750 --> 00:31:54,970
now what we have done is we're taking a

00:31:51,970 --> 00:31:58,300
lot of that dumping the actual code that

00:31:54,970 --> 00:31:59,920
gets the state out and moved it into the

00:31:58,300 --> 00:32:04,540
library so it's available to other

00:31:59,920 --> 00:32:08,560
modules this both lets us build better

00:32:04,540 --> 00:32:10,690
diagnostic tools in fact some I wish I

00:32:08,560 --> 00:32:14,520
could find it again because someone

00:32:10,690 --> 00:32:17,440
showed me this this kind of hardware

00:32:14,520 --> 00:32:19,720
inventory thing that actually been

00:32:17,440 --> 00:32:21,820
written on top of syslinux and then I

00:32:19,720 --> 00:32:25,120
lost track where I found it because I

00:32:21,820 --> 00:32:30,520
hadn't even I because I hadn't seen it

00:32:25,120 --> 00:32:32,470
before but it's some it was kind of neat

00:32:30,520 --> 00:32:35,620
where you could actually get like

00:32:32,470 --> 00:32:37,600
cascading windows of describing what

00:32:35,620 --> 00:32:43,300
your hardware looked like the EDD

00:32:37,600 --> 00:32:50,160
pre-boot and finally we have policy

00:32:43,300 --> 00:32:53,230
modules where an example of policy is

00:32:50,160 --> 00:32:56,740
boot boot this Colonel if I'm on a

00:32:53,230 --> 00:32:59,260
64-bit machine boot this other Colonel

00:32:56,740 --> 00:33:01,440
if I'm on a 32-bit machine that has pae

00:32:59,260 --> 00:33:04,110
this presumably high mmmm kernel and

00:33:01,440 --> 00:33:06,870
otherwise boot yet another Colonel

00:33:04,110 --> 00:33:09,970
there's an example of policy you can

00:33:06,870 --> 00:33:13,390
tell the user to pick different menu

00:33:09,970 --> 00:33:16,690
items but why should you have to this is

00:33:13,390 --> 00:33:18,820
stuff that can be done automatically it

00:33:16,690 --> 00:33:22,930
should be doable this should be done

00:33:18,820 --> 00:33:25,810
automatically so an a module to

00:33:22,930 --> 00:33:29,200
implement this particular policy was 129

00:33:25,810 --> 00:33:32,440
lines wrong 70 of which were something

00:33:29,200 --> 00:33:35,410
other than blank lines or comments most

00:33:32,440 --> 00:33:37,720
of most of that code was taken out by

00:33:35,410 --> 00:33:41,830
picking apart the command line and

00:33:37,720 --> 00:33:45,010
putting it back together again and this

00:33:41,830 --> 00:33:47,230
is because if these things had been

00:33:45,010 --> 00:33:49,270
fixed compile time constants that

00:33:47,230 --> 00:33:52,020
wouldn't have been necessary but this

00:33:49,270 --> 00:33:57,670
was meant to be a general-purpose module

00:33:52,020 --> 00:34:00,640
and sure you can you can combine things

00:33:57,670 --> 00:34:04,000
into into modules that do all kinds of

00:34:00,640 --> 00:34:08,440
strange things we have code right now

00:34:04,000 --> 00:34:11,320
that can that can probe your PCI bus map

00:34:08,440 --> 00:34:15,100
those devices to the corresponding

00:34:11,320 --> 00:34:18,100
modules in the linux kernel then build

00:34:15,100 --> 00:34:20,260
you an interim FS with only those ma

00:34:18,100 --> 00:34:26,650
with those modules and no other modules

00:34:20,260 --> 00:34:30,180
and do all of this at boot time you know

00:34:26,650 --> 00:34:33,370
for the system that you're booting on

00:34:30,180 --> 00:34:43,720
this is already there already working

00:34:33,370 --> 00:34:46,450
code but soon as you have that you'll

00:34:43,720 --> 00:34:48,760
also you know discover that there's

00:34:46,450 --> 00:34:50,950
always going to be limitations right now

00:34:48,760 --> 00:34:54,040
for example you have you're starting to

00:34:50,950 --> 00:34:57,040
see a lot more devices on USB even on

00:34:54,040 --> 00:35:01,060
firewire and so on and these sort of

00:34:57,040 --> 00:35:05,380
extended buses are harder to discover

00:35:01,060 --> 00:35:09,430
because you need a driver for the bus

00:35:05,380 --> 00:35:13,350
itself for the HBA of the bus in order

00:35:09,430 --> 00:35:16,180
to be able to further enumerate it so

00:35:13,350 --> 00:35:19,210
the this technique has been less useful

00:35:16,180 --> 00:35:21,910
than I was hoping it was going to be but

00:35:19,210 --> 00:35:23,560
it's it is there and you know maybe

00:35:21,910 --> 00:35:29,490
someone will figure out the right way to

00:35:23,560 --> 00:35:32,890
use it so what's happening right now

00:35:29,490 --> 00:35:36,070
well we're working on integrating allu

00:35:32,890 --> 00:35:40,210
interpreter and the purpose of this is

00:35:36,070 --> 00:35:42,370
primarily to write policies people

00:35:40,210 --> 00:35:45,310
really don't like having to compile a

00:35:42,370 --> 00:35:48,340
see module to do a new policy and I and

00:35:45,310 --> 00:35:50,920
that's very understandable so doing it

00:35:48,340 --> 00:35:54,610
as a lua script seems like a much more

00:35:50,920 --> 00:35:57,730
useful thing why do we pick Lua well it

00:35:54,610 --> 00:36:01,870
had a clean relative you know relatively

00:35:57,730 --> 00:36:03,160
small a sort of isolated interpreter

00:36:01,870 --> 00:36:07,440
that was

00:36:03,160 --> 00:36:10,920
and it's a you know clean small language

00:36:07,440 --> 00:36:14,050
reader support this right now syslinux

00:36:10,920 --> 00:36:17,140
doesn't support actually examining

00:36:14,050 --> 00:36:22,120
directories this is partly because over

00:36:17,140 --> 00:36:24,400
the network you can't do that but on

00:36:22,120 --> 00:36:28,300
disk it would be nice to do that so

00:36:24,400 --> 00:36:31,330
that's work underway the really big one

00:36:28,300 --> 00:36:34,630
is to is to get rid of all this legacy

00:36:31,330 --> 00:36:36,850
assembly code first of all the first

00:36:34,630 --> 00:36:39,250
thing that needs to happen is that file

00:36:36,850 --> 00:36:45,400
system code just needs to move out of

00:36:39,250 --> 00:36:49,420
assembly the implementing something like

00:36:45,400 --> 00:36:53,710
btrfs in assembly would be just a

00:36:49,420 --> 00:36:57,130
nightmare but even getting rid of the

00:36:53,710 --> 00:36:59,320
rest of the code from assembly wood is

00:36:57,130 --> 00:37:02,560
going to be important to make this ever

00:36:59,320 --> 00:37:08,440
port beyond the x86 bios platform in

00:37:02,560 --> 00:37:11,980
particular for efi x86 efi which is

00:37:08,440 --> 00:37:15,340
becoming a more important platform this

00:37:11,980 --> 00:37:17,710
needs this needs to happen and at this

00:37:15,340 --> 00:37:20,170
point a lot some of the groundworks

00:37:17,710 --> 00:37:24,550
happening but there's a but the actual

00:37:20,170 --> 00:37:26,890
work is is still upcoming this is what's

00:37:24,550 --> 00:37:30,690
the core looks like right this is the

00:37:26,890 --> 00:37:30,690
components of the core as of right now

00:37:33,030 --> 00:37:42,730
the first stage loader disk and network

00:37:36,400 --> 00:37:45,580
i oh and the bias extender which is what

00:37:42,730 --> 00:37:48,310
allows us to get into protected mode and

00:37:45,580 --> 00:37:50,710
the shuffle system that is the part that

00:37:48,310 --> 00:37:53,710
makes all the memory magically end up

00:37:50,710 --> 00:37:57,700
where it should be at the end all of

00:37:53,710 --> 00:37:59,770
these are kind of core platform support

00:37:57,700 --> 00:38:02,280
things and they will always need to be

00:37:59,770 --> 00:38:06,270
an assembly if nothing else for size

00:38:02,280 --> 00:38:08,910
however the rest come in line interface

00:38:06,270 --> 00:38:12,160
config file parser

00:38:08,910 --> 00:38:17,140
the colonel the colonel loader and

00:38:12,160 --> 00:38:19,809
parser and more most important of all

00:38:17,140 --> 00:38:22,240
the file system drivers really have no

00:38:19,809 --> 00:38:24,670
business doing this and it needs to be

00:38:22,240 --> 00:38:27,040
read written and see this is about

00:38:24,670 --> 00:38:31,300
eighty to eighty-five percent of the

00:38:27,040 --> 00:38:34,809
size of the current core so the part on

00:38:31,300 --> 00:38:37,390
the left that is always going to have to

00:38:34,809 --> 00:38:43,480
be assembly code it's a really a very

00:38:37,390 --> 00:38:46,630
small portion so why hasn't a lot of

00:38:43,480 --> 00:38:48,099
this happened before well it really kind

00:38:46,630 --> 00:38:50,349
of comes down to the fact that it is

00:38:48,099 --> 00:38:53,530
getting to be too large for it to be a

00:38:50,349 --> 00:38:59,829
one-person side project which it really

00:38:53,530 --> 00:39:02,380
was until a couple of years ago now we

00:38:59,829 --> 00:39:04,809
really over the last few years I am

00:39:02,380 --> 00:39:07,510
absolutely delighted how many people

00:39:04,809 --> 00:39:10,660
have kind of come in and we're starting

00:39:07,510 --> 00:39:15,579
to form a real development community we

00:39:10,660 --> 00:39:18,819
can always use more developers and in

00:39:15,579 --> 00:39:21,369
addition to actually writing code things

00:39:18,819 --> 00:39:23,049
like help helping newbies there are so

00:39:21,369 --> 00:39:26,589
many things that can be done in the

00:39:23,049 --> 00:39:29,710
booting space in so many ways and just

00:39:26,589 --> 00:39:32,049
and honestly I have to say if there's

00:39:29,710 --> 00:39:33,849
anything in syslinux I'm ashamed of it's

00:39:32,049 --> 00:39:38,079
the documentation the state of

00:39:33,849 --> 00:39:42,520
documentation is just miserable but

00:39:38,079 --> 00:39:46,900
again doing the chorine right it's gonna

00:39:42,520 --> 00:39:51,400
it's going to take a lot of work and so

00:39:46,900 --> 00:39:53,710
it really you know in in addition to me

00:39:51,400 --> 00:39:59,349
that it really you know me that we need

00:39:53,710 --> 00:40:03,339
other people now also all of this really

00:39:59,349 --> 00:40:04,809
only makes sense if the users wanted you

00:40:03,339 --> 00:40:07,089
know we can build the coolest piece

00:40:04,809 --> 00:40:11,589
technology in the world and if no one

00:40:07,089 --> 00:40:13,089
uses it it doesn't matter so we need to

00:40:11,589 --> 00:40:15,280
make sure that we end up building

00:40:13,089 --> 00:40:19,090
something that people actually want to

00:40:15,280 --> 00:40:20,800
use that make sense for users make sense

00:40:19,090 --> 00:40:25,650
for administrators make sense for

00:40:20,800 --> 00:40:31,240
distros so feedback is always welcome

00:40:25,650 --> 00:40:37,350
and this is where you can find the more

00:40:31,240 --> 00:40:41,860
information as well as these slides and

00:40:37,350 --> 00:40:44,430
at that I I want wonder if we have any

00:40:41,860 --> 00:40:44,430
questions

00:40:45,809 --> 00:40:48,439
yes

00:40:50,980 --> 00:40:53,850
I'm sorry

00:41:00,710 --> 00:41:06,240
so the question was whether or not we

00:41:03,630 --> 00:41:09,990
can check and cryptographic hash of what

00:41:06,240 --> 00:41:14,010
what we download off the internet right

00:41:09,990 --> 00:41:18,180
now there is support in in G pixie for

00:41:14,010 --> 00:41:21,690
HTTPS the problem is that at boot time

00:41:18,180 --> 00:41:24,660
you don't have you don't have any sort

00:41:21,690 --> 00:41:29,430
of random number generator available to

00:41:24,660 --> 00:41:32,930
you that this means that the security

00:41:29,430 --> 00:41:35,790
you get is pretty weak because most

00:41:32,930 --> 00:41:39,119
authentication schemes rely on having a

00:41:35,790 --> 00:41:41,880
random number generated available could

00:41:39,119 --> 00:41:44,160
we do something you're specifically

00:41:41,880 --> 00:41:46,320
asked if we could check a hash of what

00:41:44,160 --> 00:41:49,470
what is there it's certainly something

00:41:46,320 --> 00:41:51,720
that we could do relatively easily but

00:41:49,470 --> 00:41:53,850
you also have to ask the question then

00:41:51,720 --> 00:41:57,210
where do you get the cash to compare it

00:41:53,850 --> 00:41:59,910
from to this is a law there are a lot of

00:41:57,210 --> 00:42:03,830
issues when it comes to the when it

00:41:59,910 --> 00:42:07,530
comes to that in the booting space is

00:42:03,830 --> 00:42:11,220
you people really want to make the boot

00:42:07,530 --> 00:42:13,109
more sick more secure but then you kind

00:42:11,220 --> 00:42:19,770
of have to ask the next question is how

00:42:13,109 --> 00:42:22,950
do I know my security works um I think I

00:42:19,770 --> 00:42:27,480
think we may be able to make the HTTPS

00:42:22,950 --> 00:42:30,510
support better it it hasn't been a huge

00:42:27,480 --> 00:42:35,070
priority for it for the g pics of people

00:42:30,510 --> 00:42:38,340
at the moment but we probably we

00:42:35,070 --> 00:42:41,090
probably can make that better if not

00:42:38,340 --> 00:42:41,090
perfect

00:42:42,720 --> 00:42:47,349
you

00:42:44,729 --> 00:42:49,539
why don't we use the harder TPM

00:42:47,349 --> 00:42:53,609
environment do that that's actually

00:42:49,539 --> 00:43:02,009
probably the answer right now right now

00:42:53,609 --> 00:43:04,269
tpms are you know they're that their

00:43:02,009 --> 00:43:07,599
availability somewhat spotty but that is

00:43:04,269 --> 00:43:10,390
of course changing so the TPM if nothing

00:43:07,599 --> 00:43:13,660
else should be should be a see if we can

00:43:10,390 --> 00:43:15,189
find the TPM and straighten out the fact

00:43:13,660 --> 00:43:19,390
that there is at least four different

00:43:15,189 --> 00:43:21,009
hardware protocols involved at least

00:43:19,390 --> 00:43:24,999
they should provide us with a reliable

00:43:21,009 --> 00:43:27,369
random number generator and and possibly

00:43:24,999 --> 00:43:29,979
secure storage for things like keys and

00:43:27,369 --> 00:43:33,809
stuff like that so it's it's actually

00:43:29,979 --> 00:43:33,809
the right way to do that

00:43:43,839 --> 00:43:51,790
the question i believe is do we support

00:43:46,430 --> 00:43:51,790
ipv6 is that what I heard

00:43:55,120 --> 00:44:01,990
okay so the question is do we support

00:43:56,920 --> 00:44:07,150
ipv6 or only ipv4 right now we only

00:44:01,990 --> 00:44:13,150
support ipv4 IP ipv6 is not supported by

00:44:07,150 --> 00:44:15,640
the pixi standard the G pixie people are

00:44:13,150 --> 00:44:19,090
working on it but we end up with a funny

00:44:15,640 --> 00:44:23,440
notion of how do we you know what does

00:44:19,090 --> 00:44:26,230
it mean for us to support ipv6 given the

00:44:23,440 --> 00:44:30,010
fact that the underlying protocols we

00:44:26,230 --> 00:44:34,660
use don't for the parts of the pic

00:44:30,010 --> 00:44:38,020
suspect that are that are a in you know

00:44:34,660 --> 00:44:40,540
the on the local machine sort of

00:44:38,020 --> 00:44:42,970
protocols we can we can deal with that

00:44:40,540 --> 00:44:47,380
but but it also includes them over the

00:44:42,970 --> 00:44:51,790
over the wire components there is a

00:44:47,380 --> 00:44:55,120
pixie spec for ipv4 ipv6 under

00:44:51,790 --> 00:44:57,160
development unfortunately Microsoft is

00:44:55,120 --> 00:45:00,820
heavily involved in it and therefore I

00:44:57,160 --> 00:45:02,980
have not you know you know it's it there

00:45:00,820 --> 00:45:05,500
they're basically keeping it away from

00:45:02,980 --> 00:45:07,330
the open-source people so I have no idea

00:45:05,500 --> 00:45:09,880
what what it even is going to look like

00:45:07,330 --> 00:45:12,520
and ought to be honest with you if it

00:45:09,880 --> 00:45:14,950
ends up looking as bad as the original

00:45:12,520 --> 00:45:18,960
pic pics this back I don't have you know

00:45:14,950 --> 00:45:18,960
it's going to be another nightmare

00:45:27,620 --> 00:45:35,030
so the question was if I can talk more

00:45:30,540 --> 00:45:35,030
about building an initial ramdisk

00:45:42,279 --> 00:45:46,160
so the question is why do you get

00:45:44,240 --> 00:45:48,740
modules are you allowed to use D to see

00:45:46,160 --> 00:45:59,680
now we don't have GCC ported to the

00:45:48,740 --> 00:46:06,559
cisco linux decease I'm sorry Oh DJ DCC

00:45:59,680 --> 00:46:10,970
no okay okay i don't believe i'm

00:46:06,559 --> 00:46:16,670
familiar with it huh but ok yeah it's a

00:46:10,970 --> 00:46:18,559
jesus think um the answer well the

00:46:16,670 --> 00:46:20,450
answer on the module front is that the

00:46:18,559 --> 00:46:24,670
normal thing is that the modules will

00:46:20,450 --> 00:46:28,279
actually be already compiled on disk I

00:46:24,670 --> 00:46:30,289
could you I mean I'm sure that we

00:46:28,279 --> 00:46:32,029
probably actually could build an

00:46:30,289 --> 00:46:38,299
environment where you could compile a

00:46:32,029 --> 00:46:40,609
module on the fly it's you know there's

00:46:38,299 --> 00:46:46,890
no technical reason why it's not

00:46:40,609 --> 00:46:51,900
possible yeah

00:46:46,890 --> 00:46:55,380
I think it's probably not it's probably

00:46:51,900 --> 00:47:00,599
not the most effective way of doing that

00:46:55,380 --> 00:47:03,480
but but we can as I said we can take

00:47:00,599 --> 00:47:06,569
files we can generate file we can take

00:47:03,480 --> 00:47:11,220
files and put them in the drama fest we

00:47:06,569 --> 00:47:13,619
can also generate file contents and put

00:47:11,220 --> 00:47:17,299
them in the drama fest so all all the

00:47:13,619 --> 00:47:17,299
pieces are there certainly

00:47:24,920 --> 00:47:31,520
the question is if their support for for

00:47:27,650 --> 00:47:36,950
boot boot ones yes there is right now

00:47:31,520 --> 00:47:39,610
it's only in EXT Linux but that's that's

00:47:36,950 --> 00:47:39,610
a fixable problem

00:47:44,839 --> 00:47:47,829
any more questions

00:47:49,500 --> 00:47:53,390

YouTube URL: https://www.youtube.com/watch?v=wZB8KxXdiKg


