Title: FOSDEM 2009 MySQL High Availability Solutions
Publication date: 2011-12-22
Playlist: FOSDEM 2009
Description: 
	By Lenz Grimmer

There are many ways of how to ensure the availability of a MySQL Server and how to provide additional redundancy and fault-tolerance.

In this talk, Lenz will give an overview over some best practices and commonly used HA setups for MySQL.

The talk will cover the Open Source components and tools that are frequently utilized, with a focus on Linux and OpenSolaris. The session will also cover MySQL Cluster, the architecture and relationship to the MySQL Server.

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:06,620 --> 00:00:10,080
welcome to frost them again I hope you

00:00:08,790 --> 00:00:13,080
had a great day yesterday already

00:00:10,080 --> 00:00:16,109
enjoyed the talk so far my name is Lance

00:00:13,080 --> 00:00:17,850
gorilla I'm belong to sun microsystems I

00:00:16,109 --> 00:00:20,670
joined the company yes last year through

00:00:17,850 --> 00:00:23,869
the acquisition of MySQL I've been with

00:00:20,670 --> 00:00:26,340
MySQL since april two thousand two so

00:00:23,869 --> 00:00:29,429
one of the people that have been around

00:00:26,340 --> 00:00:31,340
for a while in the company talk will be

00:00:29,429 --> 00:00:34,050
about myself hey high-availability

00:00:31,340 --> 00:00:37,559
solutions and I'd like to make a service

00:00:34,050 --> 00:00:41,910
announcement right away and we do have a

00:00:37,559 --> 00:00:43,739
dev room in room and building aw today

00:00:41,910 --> 00:00:45,450
so we're having a number of my scale

00:00:43,739 --> 00:00:48,180
related talks and sessions in there and

00:00:45,450 --> 00:00:51,390
due to some unfortunate timing we have a

00:00:48,180 --> 00:00:54,059
bit of a timing problem right now there

00:00:51,390 --> 00:00:56,340
is a talk about mysql cluster in

00:00:54,059 --> 00:00:57,629
particular which has just started so if

00:00:56,340 --> 00:01:00,090
you're deeply interested in learning

00:00:57,629 --> 00:01:02,730
more about mysql cluster particular i

00:01:00,090 --> 00:01:04,320
encourage you to move over to this talk

00:01:02,730 --> 00:01:06,030
right away because i would you just

00:01:04,320 --> 00:01:08,130
scratching cluster on the surface and

00:01:06,030 --> 00:01:12,990
not going too deeply into the technical

00:01:08,130 --> 00:01:15,150
details and in addition to the schedule

00:01:12,990 --> 00:01:17,520
that is printed in the first embrasure

00:01:15,150 --> 00:01:19,650
and the schedules that have been printed

00:01:17,520 --> 00:01:22,470
out here we had to make some changes to

00:01:19,650 --> 00:01:25,140
our schedule and i try to update the

00:01:22,470 --> 00:01:26,939
printed schedule in some places but it's

00:01:25,140 --> 00:01:29,759
probably best if you check the wiki page

00:01:26,939 --> 00:01:31,799
for the latest changes that we had to

00:01:29,759 --> 00:01:34,909
make we had one speaker where to return

00:01:31,799 --> 00:01:37,950
home due to some family emergency and

00:01:34,909 --> 00:01:40,950
especially due to the recent happenings

00:01:37,950 --> 00:01:43,470
in the mysql world last week we decided

00:01:40,950 --> 00:01:45,030
to have a Q&A session where kai owner is

00:01:43,470 --> 00:01:47,009
going to talk about the things that

00:01:45,030 --> 00:01:48,810
happened at my square last week and what

00:01:47,009 --> 00:01:52,170
they mean and we want to get into a

00:01:48,810 --> 00:01:53,729
discussion with you about well what'd

00:01:52,170 --> 00:01:56,700
you think of what son should do with

00:01:53,729 --> 00:01:58,979
mysql and we are going to explain what

00:01:56,700 --> 00:02:01,439
the changes in the happenings last week

00:01:58,979 --> 00:02:03,570
me to my scale and how we plan to go

00:02:01,439 --> 00:02:05,880
forward so I if you're interested in

00:02:03,570 --> 00:02:10,450
MySQL s the project i encourage you to

00:02:05,880 --> 00:02:13,870
be in our deaf room at a quarter past 12

00:02:10,450 --> 00:02:17,750
okay that's it for the announcements

00:02:13,870 --> 00:02:20,090
let's get going so high availability

00:02:17,750 --> 00:02:23,000
solutions for my square what I'd like to

00:02:20,090 --> 00:02:26,440
talk about is giving you a general

00:02:23,000 --> 00:02:29,300
overview about what the typical

00:02:26,440 --> 00:02:31,400
configurations are how people that we're

00:02:29,300 --> 00:02:33,500
working with make their MySQL

00:02:31,400 --> 00:02:35,600
installations highly available i'll be

00:02:33,500 --> 00:02:39,290
starting with a few basics just to give

00:02:35,600 --> 00:02:41,510
in and an introduction to high

00:02:39,290 --> 00:02:44,690
availability what the concepts behind it

00:02:41,510 --> 00:02:46,910
are some practical advice and then i'm

00:02:44,690 --> 00:02:48,620
going to start to explain the various

00:02:46,910 --> 00:02:51,350
features that might occur provides for

00:02:48,620 --> 00:02:54,200
itself and the additional tools

00:02:51,350 --> 00:02:57,740
technology that is available in open

00:02:54,200 --> 00:03:00,590
source to make a single my scars over

00:02:57,740 --> 00:03:02,570
highly available so you can really rely

00:03:00,590 --> 00:03:05,780
on it in case one of your system goes

00:03:02,570 --> 00:03:08,270
down i'll be talking about a bit more in

00:03:05,780 --> 00:03:10,190
detail about drbd which is a tool that

00:03:08,270 --> 00:03:13,220
is frequently used in these

00:03:10,190 --> 00:03:15,350
configurations I'll be mentioning mysql

00:03:13,220 --> 00:03:18,080
cluster what it does and how it differs

00:03:15,350 --> 00:03:20,090
from the regular mysql server and i'll

00:03:18,080 --> 00:03:22,490
be going over some other tools and

00:03:20,090 --> 00:03:26,450
applications that are useful in this in

00:03:22,490 --> 00:03:29,140
this context okay why does high

00:03:26,450 --> 00:03:31,880
availability matter at all I mean I

00:03:29,140 --> 00:03:35,090
learned it the hard way last week I have

00:03:31,880 --> 00:03:38,360
one single PC that serves my personal

00:03:35,090 --> 00:03:40,550
homepage blog and everything it died so

00:03:38,360 --> 00:03:42,200
i'm pretty much offline right now and I

00:03:40,550 --> 00:03:44,900
I don't have any high availability

00:03:42,200 --> 00:03:47,060
solution at home so I should have

00:03:44,900 --> 00:03:50,090
listened to my own advice but of course

00:03:47,060 --> 00:03:54,890
it's also a financial issue the thing is

00:03:50,090 --> 00:03:57,020
in IT something can break and usually it

00:03:54,890 --> 00:03:59,540
will at some point in time there are

00:03:57,020 --> 00:04:04,040
various components in today's computers

00:03:59,540 --> 00:04:06,920
they do wear out over time and accidents

00:04:04,040 --> 00:04:09,290
can happen disasters there are various

00:04:06,920 --> 00:04:13,250
things that can really disrupt your

00:04:09,290 --> 00:04:15,170
service operations or simply put some

00:04:13,250 --> 00:04:17,209
time to time you may even want to update

00:04:15,170 --> 00:04:20,389
a running system to win you over

00:04:17,209 --> 00:04:22,759
we cook so there's a security flaw the

00:04:20,389 --> 00:04:25,280
server that you're running is known to

00:04:22,759 --> 00:04:26,930
be vulnerable for a buffer overflow how

00:04:25,280 --> 00:04:30,050
can you update the cell without

00:04:26,930 --> 00:04:32,210
disrupting the ongoing services so even

00:04:30,050 --> 00:04:34,639
for those cases it may make sense to

00:04:32,210 --> 00:04:36,199
consider having some kind of an H a

00:04:34,639 --> 00:04:39,280
configuration that allows you to perform

00:04:36,199 --> 00:04:42,319
such tasks downtime is expensive yeah

00:04:39,280 --> 00:04:45,650
especially in today's world everything

00:04:42,319 --> 00:04:47,990
is connected web-sites serve to

00:04:45,650 --> 00:04:50,780
customers want to take their orders once

00:04:47,990 --> 00:04:53,300
the site is down and people can't

00:04:50,780 --> 00:04:54,710
deliver or dispatch the oddest they look

00:04:53,300 --> 00:04:58,009
elsewhere there's plenty of alternatives

00:04:54,710 --> 00:05:00,289
and well your boss won't be happy about

00:04:58,009 --> 00:05:02,389
that so if you are in charge of

00:05:00,289 --> 00:05:05,720
maintaining some kind of infrastructure

00:05:02,389 --> 00:05:07,849
that serves a public service make sure

00:05:05,720 --> 00:05:12,020
that I availability high availability is

00:05:07,849 --> 00:05:15,440
high on your agenda and yeah visitors

00:05:12,020 --> 00:05:18,050
won't come back and plan about this in

00:05:15,440 --> 00:05:20,419
advance really if you start configuring

00:05:18,050 --> 00:05:22,610
and designing your structure or

00:05:20,419 --> 00:05:24,710
infrastructure make sure that high

00:05:22,610 --> 00:05:27,020
availability aspect is being considered

00:05:24,710 --> 00:05:29,030
from the beginning because once your

00:05:27,020 --> 00:05:31,039
system is up and running it will be much

00:05:29,030 --> 00:05:32,389
harder to implement such changes and

00:05:31,039 --> 00:05:34,550
making it highly available without

00:05:32,389 --> 00:05:40,789
disrupting service again to make those

00:05:34,550 --> 00:05:44,000
changes in particular we'll be talking

00:05:40,789 --> 00:05:46,699
about high availability clustering which

00:05:44,000 --> 00:05:48,979
means we are providing redundant

00:05:46,699 --> 00:05:51,020
components that make sure that in case

00:05:48,979 --> 00:05:53,000
of one of the components or services

00:05:51,020 --> 00:05:54,830
goes down there's another one that can

00:05:53,000 --> 00:05:57,560
take over the same services immediately

00:05:54,830 --> 00:05:59,330
and can make sure that the user of the

00:05:57,560 --> 00:06:02,240
application does not really notice

00:05:59,330 --> 00:06:04,039
what's going on in the background the

00:06:02,240 --> 00:06:07,280
typical scenario yes that you have

00:06:04,039 --> 00:06:09,050
multiple boxes and you have them

00:06:07,280 --> 00:06:11,120
configured that they are able to switch

00:06:09,050 --> 00:06:13,009
IP addresses quickly so the service that

00:06:11,120 --> 00:06:15,500
is used to point to the IP address of

00:06:13,009 --> 00:06:17,870
machine r can simply be redirected to

00:06:15,500 --> 00:06:21,050
machine be or mission see and get the

00:06:17,870 --> 00:06:23,389
information from there if needed and

00:06:21,050 --> 00:06:25,460
also it's possible not only to switch

00:06:23,389 --> 00:06:27,979
the IP address but you can take down an

00:06:25,460 --> 00:06:29,839
application on one machine and start it

00:06:27,979 --> 00:06:32,240
up on the other with taking over the

00:06:29,839 --> 00:06:35,690
data that just has been accessed from

00:06:32,240 --> 00:06:38,300
the from the other system before there

00:06:35,690 --> 00:06:40,400
are future study should be aware of fail

00:06:38,300 --> 00:06:43,729
over versus failed back for example

00:06:40,400 --> 00:06:45,830
failover is what happens when one

00:06:43,729 --> 00:06:52,339
machine goes down and the services of

00:06:45,830 --> 00:06:54,589
fail over to the backup system fail back

00:06:52,339 --> 00:06:56,599
means that once the system that has

00:06:54,589 --> 00:06:58,279
crashed has been up again that services

00:06:56,599 --> 00:07:03,199
move back to the original system before

00:06:58,279 --> 00:07:05,659
in some H a scenarios the the backup

00:07:03,199 --> 00:07:08,659
machine might be a bit lower in

00:07:05,659 --> 00:07:10,400
performance and is just there for the

00:07:08,659 --> 00:07:12,860
eventual case that something goes down

00:07:10,400 --> 00:07:15,800
that the service doesn't get disrupted

00:07:12,860 --> 00:07:18,650
completely but can still be serve even

00:07:15,800 --> 00:07:21,020
maybe on a on a lower performance level

00:07:18,650 --> 00:07:22,729
and once the original and the main

00:07:21,020 --> 00:07:25,039
system is back up you fare back to this

00:07:22,729 --> 00:07:27,139
one so when you have four performances

00:07:25,039 --> 00:07:29,960
it's just helping out in case it's

00:07:27,139 --> 00:07:31,940
needed and the terms which always

00:07:29,960 --> 00:07:34,789
usually used in cases where the

00:07:31,940 --> 00:07:36,560
administrator knowingly and willingly

00:07:34,789 --> 00:07:38,690
switches the services over to another

00:07:36,560 --> 00:07:42,460
machine for example because he has to

00:07:38,690 --> 00:07:44,659
take it down for maintenance of any kind

00:07:42,460 --> 00:07:46,460
clustering is also term that is being

00:07:44,659 --> 00:07:48,560
used in high performance computing where

00:07:46,460 --> 00:07:50,839
you put thousands of boxes in a wreck

00:07:48,560 --> 00:07:53,839
and they all crunch on the same problem

00:07:50,839 --> 00:07:55,039
to solve a problem in parallel and this

00:07:53,839 --> 00:07:57,740
has nothing to do with high availability

00:07:55,039 --> 00:08:01,310
it's it's really about scaling a job

00:07:57,740 --> 00:08:03,229
across many notes and high availability

00:08:01,310 --> 00:08:05,960
clustering is not in particularly

00:08:03,229 --> 00:08:08,990
designed or aimed at providing this kind

00:08:05,960 --> 00:08:11,479
of service and it's also not provided or

00:08:08,990 --> 00:08:14,750
designed to add you to give you

00:08:11,479 --> 00:08:17,300
additional throughput so even though it

00:08:14,750 --> 00:08:19,880
is possible in some scenarios to use an

00:08:17,300 --> 00:08:22,000
H a tester also as a load balancing

00:08:19,880 --> 00:08:24,560
cluster you should really consider

00:08:22,000 --> 00:08:26,779
having these in two separate functions

00:08:24,560 --> 00:08:28,159
because high availability in high

00:08:26,779 --> 00:08:30,680
performance are really two different

00:08:28,159 --> 00:08:32,539
things and if you have if you are

00:08:30,680 --> 00:08:36,140
depending on your age a cursor to

00:08:32,539 --> 00:08:37,880
deliver the services because machines

00:08:36,140 --> 00:08:40,409
are active all of a sudden one of the

00:08:37,880 --> 00:08:42,329
systems goes down and you can't deliver

00:08:40,409 --> 00:08:44,360
the data in the performance it Justin

00:08:42,329 --> 00:08:47,250
needed there is really no point in in

00:08:44,360 --> 00:08:48,509
misusing your H a cluster your

00:08:47,250 --> 00:08:51,269
high-performance cluster for high

00:08:48,509 --> 00:08:55,110
availability so there are a few things

00:08:51,269 --> 00:08:59,730
you should keep in mind about that this

00:08:55,110 --> 00:09:02,750
is a very popular slide it shows what

00:08:59,730 --> 00:09:06,870
high availability means in terms of

00:09:02,750 --> 00:09:08,759
downtime and usually people want to get

00:09:06,870 --> 00:09:10,410
as much noise as possible people talking

00:09:08,759 --> 00:09:12,300
about yeah we need it high availability

00:09:10,410 --> 00:09:14,639
with five ninth which would mean that

00:09:12,300 --> 00:09:17,310
you have five minutes of downtime in a

00:09:14,639 --> 00:09:20,160
year so the service is running non-stop

00:09:17,310 --> 00:09:23,009
all the time except for I can accumulate

00:09:20,160 --> 00:09:25,949
a time of five minutes you can get there

00:09:23,009 --> 00:09:28,589
but it's getting very very expensive so

00:09:25,949 --> 00:09:30,839
you really have to consider how much

00:09:28,589 --> 00:09:32,629
downtime can you afford and how much

00:09:30,839 --> 00:09:35,490
availability do you want to achieve

00:09:32,629 --> 00:09:41,569
again we have the slide gives you a few

00:09:35,490 --> 00:09:41,569
examples on what people usually aim it

00:09:42,439 --> 00:09:48,389
so data centers can live with eight

00:09:45,750 --> 00:09:51,110
hours of downtime within a year banks

00:09:48,389 --> 00:09:53,550
usually have harder requirements and

00:09:51,110 --> 00:10:00,630
telecommunication and military wanted

00:09:53,550 --> 00:10:03,240
even more higher available spav the

00:10:00,630 --> 00:10:06,860
single point of failure is the single

00:10:03,240 --> 00:10:09,509
component in your configuration that

00:10:06,860 --> 00:10:11,009
causes the entire system to go down if

00:10:09,509 --> 00:10:13,410
it fails so what you want to make sure

00:10:11,009 --> 00:10:15,930
is that you don't have any single point

00:10:13,410 --> 00:10:20,279
of failure which would cause the entire

00:10:15,930 --> 00:10:24,089
system to disrupt so you go through your

00:10:20,279 --> 00:10:26,759
systems you make an analysis and some of

00:10:24,089 --> 00:10:29,370
the components that usually should be on

00:10:26,759 --> 00:10:31,680
your list are hard disks since they are

00:10:29,370 --> 00:10:35,189
mechanical devices they can wear out

00:10:31,680 --> 00:10:37,740
vibration can kill them but also you

00:10:35,189 --> 00:10:40,139
should consider what other components of

00:10:37,740 --> 00:10:44,490
my systems may be vulnerable to to break

00:10:40,139 --> 00:10:46,529
down network cables maybe someone

00:10:44,490 --> 00:10:48,209
tripped over the cable connection is

00:10:46,529 --> 00:10:50,850
down the system isn't reachable anymore

00:10:48,209 --> 00:10:52,240
if you have an application that has a

00:10:50,850 --> 00:10:54,800
memory leak and starts

00:10:52,240 --> 00:10:56,330
crunch up all the memory your system

00:10:54,800 --> 00:10:58,970
comes to a grinding halt because it

00:10:56,330 --> 00:11:01,040
starts wiping is mad in that case you

00:10:58,970 --> 00:11:02,660
might want to consider switching to the

00:11:01,040 --> 00:11:05,590
other system until you have resolved the

00:11:02,660 --> 00:11:08,120
problem power supplies are also pretty

00:11:05,590 --> 00:11:09,860
common for blowing up at some point and

00:11:08,120 --> 00:11:11,750
usually if you if you buy service

00:11:09,860 --> 00:11:14,720
nowadays they have redone impose a place

00:11:11,750 --> 00:11:16,640
it can be swapped on the fly and the

00:11:14,720 --> 00:11:21,050
same is true for even more and more

00:11:16,640 --> 00:11:24,680
components in two days PC hardware so

00:11:21,050 --> 00:11:26,930
make sure that your systems provide the

00:11:24,680 --> 00:11:29,170
redundancy that you require and all the

00:11:26,930 --> 00:11:32,650
components that you depend on are

00:11:29,170 --> 00:11:40,370
available at least in 2 if not more

00:11:32,650 --> 00:11:42,500
versions or copies of the same thing the

00:11:40,370 --> 00:11:44,630
software that provides high availability

00:11:42,500 --> 00:11:48,590
usually consists of a few components

00:11:44,630 --> 00:11:50,240
that take care of certain tasks usually

00:11:48,590 --> 00:11:53,480
what you have is some kind of an

00:11:50,240 --> 00:11:56,420
heartbeat application this to basically

00:11:53,480 --> 00:11:58,490
make sure that all the notes of your

00:11:56,420 --> 00:12:00,830
cluster or of your high availability

00:11:58,490 --> 00:12:02,590
system are alive it to make sure that

00:12:00,830 --> 00:12:04,970
the applications are up and running

00:12:02,590 --> 00:12:07,910
giving you the correct answers and the

00:12:04,970 --> 00:12:10,850
system is running properly and the notes

00:12:07,910 --> 00:12:14,950
check each other if the other partner in

00:12:10,850 --> 00:12:17,900
this configuration is alive as well and

00:12:14,950 --> 00:12:19,780
depending on the outcome and the result

00:12:17,900 --> 00:12:22,460
of what the heartbeat application

00:12:19,780 --> 00:12:24,740
identifies you usually have one

00:12:22,460 --> 00:12:27,220
controlling application which is called

00:12:24,740 --> 00:12:30,410
the H a monitor the band performs

00:12:27,220 --> 00:12:32,540
particular tasks or actions depending on

00:12:30,410 --> 00:12:36,470
on what the heartbeat has discovered so

00:12:32,540 --> 00:12:39,320
if if heartbeat realizes that one of the

00:12:36,470 --> 00:12:41,990
notes is down the edge a monitor then

00:12:39,320 --> 00:12:44,600
performs the steps required to migrate

00:12:41,990 --> 00:12:45,980
the application at the IP address to the

00:12:44,600 --> 00:12:50,390
remaining notes and make sure that

00:12:45,980 --> 00:12:54,200
everything's under control again in most

00:12:50,390 --> 00:12:57,170
h/a scenarios you usually have a shaft

00:12:54,200 --> 00:12:58,610
starch device like a storage area

00:12:57,170 --> 00:13:01,040
network where all your data is being

00:12:58,610 --> 00:13:03,380
stored so the application servers in

00:13:01,040 --> 00:13:04,970
front are redundant but they all connect

00:13:03,380 --> 00:13:07,100
to a central storage

00:13:04,970 --> 00:13:09,490
they access the data that has just been

00:13:07,100 --> 00:13:12,680
operated from the previous node an

00:13:09,490 --> 00:13:15,019
alternative to that is to add even more

00:13:12,680 --> 00:13:18,319
redundancies that you use of replication

00:13:15,019 --> 00:13:20,899
in any way that makes sure that the data

00:13:18,319 --> 00:13:23,779
is being copied instantaneously to

00:13:20,899 --> 00:13:25,759
another storage subsystem so in case

00:13:23,779 --> 00:13:27,500
that your central storage goes down you

00:13:25,759 --> 00:13:32,000
still have a replicated copy somewhere

00:13:27,500 --> 00:13:35,750
else and I'm going to discuss this a bit

00:13:32,000 --> 00:13:38,060
more a shared storage resource like a

00:13:35,750 --> 00:13:39,910
sam can of course also become a single

00:13:38,060 --> 00:13:43,759
point of failure usually these these

00:13:39,910 --> 00:13:45,649
sand devices provide lots of high

00:13:43,759 --> 00:13:48,740
availability functionality by themselves

00:13:45,649 --> 00:13:50,569
but in case your whole data center runs

00:13:48,740 --> 00:13:52,610
out of power or something like that this

00:13:50,569 --> 00:13:55,879
doesn't help you very much so depending

00:13:52,610 --> 00:13:59,000
on on your requirement you may want to

00:13:55,879 --> 00:14:00,980
consider having backup storage somewhere

00:13:59,000 --> 00:14:03,709
else that really make sure that you're

00:14:00,980 --> 00:14:08,240
not getting into trouble if your primary

00:14:03,709 --> 00:14:09,889
storage pet system fails and splits

00:14:08,240 --> 00:14:13,370
brain is also term that I'm going to

00:14:09,889 --> 00:14:16,160
talk about it any moment a bit more this

00:14:13,370 --> 00:14:18,559
is a situation that can be dangerous in

00:14:16,160 --> 00:14:20,329
case you have a centralized storage

00:14:18,559 --> 00:14:23,750
device because all of a sudden it may

00:14:20,329 --> 00:14:26,180
happen that several applications try to

00:14:23,750 --> 00:14:29,540
take our access your data at the same

00:14:26,180 --> 00:14:31,160
time and end depending on how your

00:14:29,540 --> 00:14:33,309
application is written they it may not

00:14:31,160 --> 00:14:35,480
be able to cope with that and it caused

00:14:33,309 --> 00:14:37,879
significant trouble on on the central

00:14:35,480 --> 00:14:40,879
storage system but there are techniques

00:14:37,879 --> 00:14:42,050
that help to avoid such situations but

00:14:40,879 --> 00:14:44,089
it's something that you should keep in

00:14:42,050 --> 00:14:46,819
mind here speak plain is something that

00:14:44,089 --> 00:14:48,860
can happen in certain configurations and

00:14:46,819 --> 00:14:52,519
your system should be able to cope with

00:14:48,860 --> 00:14:54,529
it and of course if if your storage is

00:14:52,519 --> 00:14:56,480
somewhere on a network you have some

00:14:54,529 --> 00:14:59,029
overhead when it comes to reading and

00:14:56,480 --> 00:15:00,860
sending data over there versus having it

00:14:59,029 --> 00:15:05,660
on local disk drives on your on your

00:15:00,860 --> 00:15:08,449
note so what you can do is you replicate

00:15:05,660 --> 00:15:10,309
your data and copy it to a separate

00:15:08,449 --> 00:15:14,600
separate storage subsystem somewhere

00:15:10,309 --> 00:15:15,670
else and here if you have to decide if

00:15:14,600 --> 00:15:17,770
you want to make this

00:15:15,670 --> 00:15:20,170
a synchronous operation that means that

00:15:17,770 --> 00:15:22,060
every change it has or every file that

00:15:20,170 --> 00:15:24,700
has been stalled on that storage

00:15:22,060 --> 00:15:26,320
subsystem is synchronously copied over

00:15:24,700 --> 00:15:28,870
to the other side and you really know

00:15:26,320 --> 00:15:31,170
that the copy is complete and ready

00:15:28,870 --> 00:15:34,870
before you continue with your operations

00:15:31,170 --> 00:15:37,390
the other hand you can use a synchronous

00:15:34,870 --> 00:15:38,950
replication which means that the data is

00:15:37,390 --> 00:15:41,560
being copied in the background and you

00:15:38,950 --> 00:15:43,540
don't really have confirmation that it's

00:15:41,560 --> 00:15:45,070
the operation has already completed

00:15:43,540 --> 00:15:49,480
while you're running application

00:15:45,070 --> 00:15:52,360
proceeds this is a bit easier to handle

00:15:49,480 --> 00:15:53,710
and provides lower overhead and usually

00:15:52,360 --> 00:15:54,550
gives you higher performance because you

00:15:53,710 --> 00:15:57,370
don't have to wait for the

00:15:54,550 --> 00:16:00,640
synchronization to happen but in case of

00:15:57,370 --> 00:16:02,710
a crash of your primary system you can't

00:16:00,640 --> 00:16:04,180
really be sure that every data that has

00:16:02,710 --> 00:16:06,850
been modified has reached the other side

00:16:04,180 --> 00:16:09,940
yet before the system crashed so you may

00:16:06,850 --> 00:16:12,070
run into or you may face some data loss

00:16:09,940 --> 00:16:20,950
depending on how fast the replication

00:16:12,070 --> 00:16:24,730
system works some more about split brain

00:16:20,950 --> 00:16:26,580
that I just mentioned a classic scenario

00:16:24,730 --> 00:16:29,440
is you have a high availability

00:16:26,580 --> 00:16:32,110
confirmation with two systems they are

00:16:29,440 --> 00:16:34,870
able to heart beat each other so they

00:16:32,110 --> 00:16:36,190
are both alive and happy and think

00:16:34,870 --> 00:16:37,720
everything is good and all of a sudden

00:16:36,190 --> 00:16:40,360
the connection that is used for the

00:16:37,720 --> 00:16:42,010
heart beating dies so both are still

00:16:40,360 --> 00:16:44,350
alive but they can't reach the other one

00:16:42,010 --> 00:16:45,970
anymore and they might be considering

00:16:44,350 --> 00:16:48,310
okay the other one it's not reachable

00:16:45,970 --> 00:16:51,160
anymore I suppose it's not my task to

00:16:48,310 --> 00:16:55,570
take over the other jobs and they start

00:16:51,160 --> 00:16:59,110
turning over the jobs and well it's that

00:16:55,570 --> 00:17:01,480
to assume it is now the the only

00:16:59,110 --> 00:17:05,440
remaining node in the cluster and starts

00:17:01,480 --> 00:17:07,720
to used activate the applications and if

00:17:05,440 --> 00:17:10,060
you have shared storage the note on the

00:17:07,720 --> 00:17:11,980
other side may want to try the same

00:17:10,060 --> 00:17:15,190
thing at the same time so this can

00:17:11,980 --> 00:17:17,320
really lead to bad things and what you

00:17:15,190 --> 00:17:19,990
need to do is make sure that you have

00:17:17,320 --> 00:17:23,410
some kind of a so-called fencing I'm

00:17:19,990 --> 00:17:25,390
system or you have a third system that

00:17:23,410 --> 00:17:27,580
acts as a moderator and can really tell

00:17:25,390 --> 00:17:28,970
the two notes hey guys even though you

00:17:27,580 --> 00:17:30,799
dog both to contour

00:17:28,970 --> 00:17:32,720
to each other anymore I know you're both

00:17:30,799 --> 00:17:34,429
alive so you shut up and you stay what

00:17:32,720 --> 00:17:38,929
you're doing right now in in layman's

00:17:34,429 --> 00:17:41,929
terms fencing does it even harder it

00:17:38,929 --> 00:17:45,110
simply turns off the other system so

00:17:41,929 --> 00:17:46,850
that it really can't perform any better

00:17:45,110 --> 00:17:53,830
any more until the administrators

00:17:46,850 --> 00:17:58,010
resolve the problem some general rules

00:17:53,830 --> 00:18:00,409
Jay well prepare for failure we simply

00:17:58,010 --> 00:18:01,909
have to assume that it's going to happen

00:18:00,409 --> 00:18:04,190
at some point so you better make sure

00:18:01,909 --> 00:18:07,669
that you know how to handle it and these

00:18:04,190 --> 00:18:09,770
preparations can start with simple rules

00:18:07,669 --> 00:18:12,140
for the administrators of what switches

00:18:09,770 --> 00:18:13,820
to use or what cables to put somewhere

00:18:12,140 --> 00:18:17,990
else if you have a manual failover

00:18:13,820 --> 00:18:21,830
system or how to define your automated

00:18:17,990 --> 00:18:25,179
high availability solution and of course

00:18:21,830 --> 00:18:28,730
consider what data is important to you

00:18:25,179 --> 00:18:31,940
what part of your system should be

00:18:28,730 --> 00:18:33,500
highly available what is it necessary

00:18:31,940 --> 00:18:35,299
that you have a redundant copy of the

00:18:33,500 --> 00:18:37,580
operating system that is always in sync

00:18:35,299 --> 00:18:39,440
is it enough to just synchronize the

00:18:37,580 --> 00:18:41,390
data directories that are changing from

00:18:39,440 --> 00:18:42,679
constantly so there are a few aspects

00:18:41,390 --> 00:18:46,820
that you should keep in mind and

00:18:42,679 --> 00:18:49,100
consider here and very important don't

00:18:46,820 --> 00:18:52,760
over engineer this whole thing keep it

00:18:49,100 --> 00:18:55,600
simple sorts it's easy to grasp and to

00:18:52,760 --> 00:18:58,700
see what it does stick to established

00:18:55,600 --> 00:19:00,650
components I know it's tempting to start

00:18:58,700 --> 00:19:04,760
writing your own age a system creating

00:19:00,650 --> 00:19:06,140
cool scripts they do these things not

00:19:04,760 --> 00:19:08,809
sure if it makes sense if there are so

00:19:06,140 --> 00:19:11,030
many existing solutions available so try

00:19:08,809 --> 00:19:14,090
to lower complexity as much as you can

00:19:11,030 --> 00:19:17,539
try to automate it and of course test it

00:19:14,090 --> 00:19:19,070
don't wait for the disaster to happen

00:19:17,539 --> 00:19:21,350
before you realize that your failover

00:19:19,070 --> 00:19:24,070
solution is not performing the task as

00:19:21,350 --> 00:19:27,470
it should be so every change should

00:19:24,070 --> 00:19:29,390
occur with a repeated test afterwards to

00:19:27,470 --> 00:19:32,030
make sure that the modifications don't

00:19:29,390 --> 00:19:33,740
cause any mayhem and if your HS system

00:19:32,030 --> 00:19:36,049
is properly designed this usually

00:19:33,740 --> 00:19:38,900
shouldn't cause any service disruption

00:19:36,049 --> 00:19:40,980
or at least only very little

00:19:38,900 --> 00:19:42,630
compared to what would happen if you

00:19:40,980 --> 00:19:44,520
don't test your changes and the system

00:19:42,630 --> 00:19:51,390
doesn't feel over in case a crash or

00:19:44,520 --> 00:19:54,900
crush okay let's get started with MySQL

00:19:51,390 --> 00:19:57,390
related things here mysql provides an

00:19:54,900 --> 00:20:00,210
inbuilt mechanism that allows you to

00:19:57,390 --> 00:20:02,300
replicate data from one mysql server to

00:20:00,210 --> 00:20:06,090
another it's called MySQL replication

00:20:02,300 --> 00:20:08,340
it's a one-way replication system so you

00:20:06,090 --> 00:20:10,890
have one server and another one is able

00:20:08,340 --> 00:20:14,250
to get all the changes from this one and

00:20:10,890 --> 00:20:16,260
apply them locally so you have one

00:20:14,250 --> 00:20:19,260
master but it's possible to distribute

00:20:16,260 --> 00:20:20,790
these changes too many slave servers in

00:20:19,260 --> 00:20:25,890
parallel so you're not limited to a

00:20:20,790 --> 00:20:27,960
one-to-one system here we can use what

00:20:25,890 --> 00:20:29,520
we also call fan-out replication so you

00:20:27,960 --> 00:20:32,760
have one single system that finds out

00:20:29,520 --> 00:20:35,990
the changes to many others the whole

00:20:32,760 --> 00:20:38,640
system is as in Cronus which means that

00:20:35,990 --> 00:20:42,150
you can't be sure that all updates

00:20:38,640 --> 00:20:44,310
deletes and so on which happened on the

00:20:42,150 --> 00:20:46,950
MySQL master server are also replicated

00:20:44,310 --> 00:20:48,690
on the slave at the same time depending

00:20:46,950 --> 00:20:50,580
on your network connection and depending

00:20:48,690 --> 00:20:53,520
on the amount of changes that are being

00:20:50,580 --> 00:20:54,600
replicated the slave can lag behind and

00:20:53,520 --> 00:20:59,280
this is something that you should keep

00:20:54,600 --> 00:21:01,920
in mind the master maintains all the

00:20:59,280 --> 00:21:03,960
changes that are happening all the SQL

00:21:01,920 --> 00:21:07,440
statements that modify data in any way

00:21:03,960 --> 00:21:10,470
are being stored in a binary log file

00:21:07,440 --> 00:21:12,990
which is a special format file which

00:21:10,470 --> 00:21:15,510
includes usually all the SQL statements

00:21:12,990 --> 00:21:17,730
that's what we usually call this whole

00:21:15,510 --> 00:21:19,710
world statement based replication so the

00:21:17,730 --> 00:21:21,870
MySQL server really records the SQL

00:21:19,710 --> 00:21:24,390
statements that were issued to modify

00:21:21,870 --> 00:21:26,100
data and puts it in his log file the

00:21:24,390 --> 00:21:28,020
slave takes these statements and then

00:21:26,100 --> 00:21:30,150
simply repeats the commands that have

00:21:28,020 --> 00:21:33,680
been performed on the master to update

00:21:30,150 --> 00:21:36,210
its local copy of the data accordingly

00:21:33,680 --> 00:21:37,860
starting with MySQL five dot on one

00:21:36,210 --> 00:21:41,210
we've also introduced something that we

00:21:37,860 --> 00:21:43,500
call role based replication in this case

00:21:41,210 --> 00:21:45,840
it's not the statements that are being

00:21:43,500 --> 00:21:47,430
replicated but rather the data that has

00:21:45,840 --> 00:21:48,840
been changed to the actual roles that

00:21:47,430 --> 00:21:51,840
have changed in the tables

00:21:48,840 --> 00:21:54,120
copied over to the slave this has some

00:21:51,840 --> 00:21:57,380
advantages and disadvantages of them

00:21:54,120 --> 00:21:59,850
going to talk about it in a future slide

00:21:57,380 --> 00:22:03,390
the cool thing about mysql replication

00:21:59,850 --> 00:22:07,440
that it's really very easy to set up we

00:22:03,390 --> 00:22:10,039
have documented in the manual you just

00:22:07,440 --> 00:22:12,480
need to have a second MySQL slave server

00:22:10,039 --> 00:22:14,640
configured to point it to the master and

00:22:12,480 --> 00:22:16,590
tell it okay this is where the Masters

00:22:14,640 --> 00:22:20,400
data is at right now start replicating

00:22:16,590 --> 00:22:23,580
now and this usually works pretty

00:22:20,400 --> 00:22:26,460
reliable the thing that you should keep

00:22:23,580 --> 00:22:29,610
in mind is that the replication slave

00:22:26,460 --> 00:22:32,580
performs all the updates using a single

00:22:29,610 --> 00:22:35,039
threat so in comparison to the master

00:22:32,580 --> 00:22:37,860
which can pair process many queries in

00:22:35,039 --> 00:22:40,230
parallel the replication is replicating

00:22:37,860 --> 00:22:43,350
these changes in a serialized fashion so

00:22:40,230 --> 00:22:44,789
the slave takes more time to process all

00:22:43,350 --> 00:22:47,940
the events that are happening on the

00:22:44,789 --> 00:22:49,710
master so as finally ethically sound in

00:22:47,940 --> 00:22:52,320
some cases it may make sense that your

00:22:49,710 --> 00:22:54,179
slave server is a bit more performant

00:22:52,320 --> 00:22:59,309
than your master server because of this

00:22:54,179 --> 00:23:00,720
particular problem however all my SQL

00:22:59,309 --> 00:23:03,380
server provides really is the

00:23:00,720 --> 00:23:06,240
replication we don't take care of

00:23:03,380 --> 00:23:07,789
automating the failover there's not

00:23:06,240 --> 00:23:10,049
really much of a high-availability

00:23:07,789 --> 00:23:12,630
solution built into the MySQL server

00:23:10,049 --> 00:23:14,880
it's just replicating assuming that the

00:23:12,630 --> 00:23:17,279
Masters a life so in case that you want

00:23:14,880 --> 00:23:18,929
to use this system for a high

00:23:17,279 --> 00:23:21,840
availability configuration you have to

00:23:18,929 --> 00:23:23,399
perform some additional steps and make

00:23:21,840 --> 00:23:26,549
use of some additional tools that I'm

00:23:23,399 --> 00:23:28,320
going to cover now this is just a

00:23:26,549 --> 00:23:30,659
graphical overview of how the

00:23:28,320 --> 00:23:33,090
replication system works on the left

00:23:30,659 --> 00:23:34,770
hand side you have the MySQL master

00:23:33,090 --> 00:23:37,409
which is the primary server receiving

00:23:34,770 --> 00:23:40,679
all the data modifying statements like

00:23:37,409 --> 00:23:42,899
update insert and delete it applies

00:23:40,679 --> 00:23:46,440
these changes to its local database and

00:23:42,899 --> 00:23:49,200
also stores all the changes in its

00:23:46,440 --> 00:23:52,230
binary log file on the right hand side

00:23:49,200 --> 00:23:54,809
the MySQL slave simply connects to the

00:23:52,230 --> 00:23:56,220
master post it for all the changes that

00:23:54,809 --> 00:23:58,649
has happened since the last time it

00:23:56,220 --> 00:24:00,210
connected and stores all these changes

00:23:58,649 --> 00:24:03,330
in local real a log file

00:24:00,210 --> 00:24:07,200
before it starts applying them using the

00:24:03,330 --> 00:24:09,540
SQL thread and as you can see here the

00:24:07,200 --> 00:24:13,320
Mexico slave itself can also store these

00:24:09,540 --> 00:24:16,050
changes in its local binary log again so

00:24:13,320 --> 00:24:21,090
this allows you to daisy chain them for

00:24:16,050 --> 00:24:22,770
example some more words about statement

00:24:21,090 --> 00:24:24,960
based replication this is the system

00:24:22,770 --> 00:24:27,810
that has been included with MySQL for a

00:24:24,960 --> 00:24:31,290
very long time I think yeah it was my

00:24:27,810 --> 00:24:33,330
score 3 23 or even earlier The Rock

00:24:31,290 --> 00:24:35,550
fights are quite small since all the

00:24:33,330 --> 00:24:39,630
only thing that we're logging is the SQL

00:24:35,550 --> 00:24:41,340
statement itself which also allows me to

00:24:39,630 --> 00:24:43,680
use this binary log file for other

00:24:41,340 --> 00:24:45,690
purposes like auditing to make sure that

00:24:43,680 --> 00:24:48,000
the application isn't performing queried

00:24:45,690 --> 00:24:49,680
queries it's not allowed to or if you

00:24:48,000 --> 00:24:51,780
want to check on your users what kind of

00:24:49,680 --> 00:24:55,950
data modifying statements they have

00:24:51,780 --> 00:24:57,960
issued there's a tool that is part of a

00:24:55,950 --> 00:25:01,170
MySQL distribution called MySQL Binh LOC

00:24:57,960 --> 00:25:03,750
that converts the binary encoded log

00:25:01,170 --> 00:25:07,980
file format into plain tex SQL again so

00:25:03,750 --> 00:25:10,410
you can look at it and the replicated

00:25:07,980 --> 00:25:12,660
tables don't really have any requirement

00:25:10,410 --> 00:25:15,180
when it comes to having primary keys or

00:25:12,660 --> 00:25:18,870
something like that it just replicates

00:25:15,180 --> 00:25:23,100
the data as it is unfortunately this

00:25:18,870 --> 00:25:26,310
approach has a few downsides to it most

00:25:23,100 --> 00:25:27,960
importantly if you use SQL functions

00:25:26,310 --> 00:25:32,220
that are nondifferent non-deterministic

00:25:27,960 --> 00:25:35,100
or if you use user-defined functions you

00:25:32,220 --> 00:25:38,550
may have to watch carefully if these are

00:25:35,100 --> 00:25:41,670
being replicated properly for example

00:25:38,550 --> 00:25:44,450
muu ID which creates a unique ID which

00:25:41,670 --> 00:25:47,670
is unique to that particular SQL node

00:25:44,450 --> 00:25:49,230
can't be replicated safely the new ID

00:25:47,670 --> 00:25:51,660
would be different on the replicated

00:25:49,230 --> 00:25:53,130
side and there are a few other functions

00:25:51,660 --> 00:25:55,890
we have a whole section in the menu that

00:25:53,130 --> 00:25:57,890
really describes which functions are

00:25:55,890 --> 00:26:01,310
replication safe and in which you should

00:25:57,890 --> 00:26:01,310
handle with care

00:26:03,540 --> 00:26:10,540
but in general most users still prefer

00:26:08,590 --> 00:26:14,320
using statement replication because it's

00:26:10,540 --> 00:26:17,440
proven and easier or more transparent to

00:26:14,320 --> 00:26:20,260
to to work with so on the other hand we

00:26:17,440 --> 00:26:23,290
have robust replication which means that

00:26:20,260 --> 00:26:27,130
the master server performs the SQL

00:26:23,290 --> 00:26:28,900
statements and then locks all the roles

00:26:27,130 --> 00:26:30,610
that have been affected every row that

00:26:28,900 --> 00:26:34,570
has been changed or added as being

00:26:30,610 --> 00:26:36,520
included in the binary log file which is

00:26:34,570 --> 00:26:40,510
the technology that most other database

00:26:36,520 --> 00:26:42,940
management systems also use this makes

00:26:40,510 --> 00:26:45,850
it easier on the slave site to insert

00:26:42,940 --> 00:26:48,490
the data because it can just take the

00:26:45,850 --> 00:26:50,260
rows as they are and pipe them into its

00:26:48,490 --> 00:26:54,880
local tables without much consideration

00:26:50,260 --> 00:26:57,160
or much processing work that of course

00:26:54,880 --> 00:26:59,770
means that the binary log file grows

00:26:57,160 --> 00:27:02,140
significantly depending on how much

00:26:59,770 --> 00:27:04,150
roles are changing if you have a

00:27:02,140 --> 00:27:05,740
statement this just changes a single

00:27:04,150 --> 00:27:08,230
roll this doesn't really affect you much

00:27:05,740 --> 00:27:11,230
much if you have massive updates that

00:27:08,230 --> 00:27:13,600
update your entire tables every single

00:27:11,230 --> 00:27:16,510
row needs to be replicated so in some

00:27:13,600 --> 00:27:18,820
cases this really increases the size of

00:27:16,510 --> 00:27:20,260
the log files and that is something that

00:27:18,820 --> 00:27:22,840
you should keep in mind if you use

00:27:20,260 --> 00:27:25,420
binary log files for performing backups

00:27:22,840 --> 00:27:27,550
and want to restore from the log file

00:27:25,420 --> 00:27:30,520
you have to consider this space that is

00:27:27,550 --> 00:27:34,270
being needed and there is a restriction

00:27:30,520 --> 00:27:37,060
that row based replication tables need

00:27:34,270 --> 00:27:38,470
to have a primary key but depending on

00:27:37,060 --> 00:27:42,150
your database design this might actually

00:27:38,470 --> 00:27:45,250
not be much of a problem and the

00:27:42,150 --> 00:27:47,850
replication slave may provide different

00:27:45,250 --> 00:27:50,680
results of queries so if you have an

00:27:47,850 --> 00:27:52,270
ongoing row based replication that

00:27:50,680 --> 00:27:53,830
really updates a lot of rows on the

00:27:52,270 --> 00:27:55,900
slave and you run the same select

00:27:53,830 --> 00:27:57,490
statement since the slave hasn't fully

00:27:55,900 --> 00:27:59,680
caught up with all the rolls it may

00:27:57,490 --> 00:28:01,540
return just a subset of the results that

00:27:59,680 --> 00:28:05,050
are would be returned on the master

00:28:01,540 --> 00:28:06,640
server so in that case this is something

00:28:05,050 --> 00:28:09,730
they should keep in mind if you're using

00:28:06,640 --> 00:28:11,320
replication to scale reads for example

00:28:09,730 --> 00:28:13,000
if you have many MySQL servers that are

00:28:11,320 --> 00:28:13,830
serving your application with read

00:28:13,000 --> 00:28:16,599
statements

00:28:13,830 --> 00:28:17,950
the slave may be behind so the results

00:28:16,599 --> 00:28:20,259
it's may differ if you're using your

00:28:17,950 --> 00:28:25,359
waist application and it hasn't fully

00:28:20,259 --> 00:28:28,869
caught up yet this is an overview about

00:28:25,359 --> 00:28:31,899
common topologies on how to set up

00:28:28,869 --> 00:28:35,080
master slave replication on the top left

00:28:31,899 --> 00:28:37,840
you have one master one slave that's the

00:28:35,080 --> 00:28:39,820
standard configuration on the top right

00:28:37,840 --> 00:28:43,090
you see one master they've replicated to

00:28:39,820 --> 00:28:44,679
two slaves in parallel and these slaves

00:28:43,090 --> 00:28:47,259
are really independently from each other

00:28:44,679 --> 00:28:48,460
if there are made out of different

00:28:47,259 --> 00:28:54,039
components and have different

00:28:48,460 --> 00:28:58,299
performance values one slave may be more

00:28:54,039 --> 00:28:59,679
behind than the other all so they don't

00:28:58,299 --> 00:29:02,679
really care about synchronization

00:28:59,679 --> 00:29:04,629
between themselves as I said you can

00:29:02,679 --> 00:29:06,669
daisy-chain them you can have one master

00:29:04,629 --> 00:29:08,080
that replicates to one slave which in

00:29:06,669 --> 00:29:10,629
turn then replicates the two other

00:29:08,080 --> 00:29:13,359
slaves something that isn't possible

00:29:10,629 --> 00:29:15,369
unfortunately is having two masters that

00:29:13,359 --> 00:29:17,889
they've replicated to a scene or slave a

00:29:15,369 --> 00:29:21,759
fan in configuration is currently not

00:29:17,889 --> 00:29:25,179
supported by mysql replication it's also

00:29:21,759 --> 00:29:27,879
possible to do a circular replication so

00:29:25,179 --> 00:29:30,279
that you have to MySQL servers that are

00:29:27,879 --> 00:29:33,159
both being a master and the slave of the

00:29:30,279 --> 00:29:34,869
other one so in theory you can perform

00:29:33,159 --> 00:29:36,249
inserts and updates on both sides and

00:29:34,869 --> 00:29:40,059
they're being replicated to the other

00:29:36,249 --> 00:29:41,999
side well this configuration has a few

00:29:40,059 --> 00:29:44,259
things that you have to keep in mind so

00:29:41,999 --> 00:29:47,259
it's um I think I have a slide about

00:29:44,259 --> 00:29:50,249
this later on and you can also configure

00:29:47,259 --> 00:29:52,719
them in a ring configuration that really

00:29:50,249 --> 00:29:54,969
statements are being replicated in

00:29:52,719 --> 00:29:57,460
round-robin fashion but that too has the

00:29:54,969 --> 00:30:02,469
same convenience that master master

00:29:57,460 --> 00:30:04,719
replication has okay more about master

00:30:02,469 --> 00:30:07,359
master so as I said you have to MySQL

00:30:04,719 --> 00:30:10,210
servers both a master and slave of each

00:30:07,359 --> 00:30:13,239
other at the same time which is a very

00:30:10,210 --> 00:30:15,729
popular configuration for MySQL high

00:30:13,239 --> 00:30:17,109
availability systems something that you

00:30:15,729 --> 00:30:18,879
should keep in mind here is that this

00:30:17,109 --> 00:30:21,190
system does not really help you in

00:30:18,879 --> 00:30:24,399
sharing your loss even though it is

00:30:21,190 --> 00:30:26,720
possible to issue rights on the same

00:30:24,399 --> 00:30:29,659
side since they have to replicate

00:30:26,720 --> 00:30:31,549
changes they are performing both jobs so

00:30:29,659 --> 00:30:33,650
every update that is happening on the

00:30:31,549 --> 00:30:35,179
one side plus the updates happening on

00:30:33,650 --> 00:30:37,240
the other side have to be processed so

00:30:35,179 --> 00:30:41,419
this doesn't really give you any

00:30:37,240 --> 00:30:43,909
improvement in distributing the load so

00:30:41,419 --> 00:30:46,460
in theory I usually have them configured

00:30:43,909 --> 00:30:49,610
in that way they both could accept right

00:30:46,460 --> 00:30:52,190
but you the application only performs

00:30:49,610 --> 00:30:54,919
right and data modification operations

00:30:52,190 --> 00:30:56,750
on one of the two notes and in case of

00:30:54,919 --> 00:31:01,039
an emergency you could fail over to the

00:30:56,750 --> 00:31:02,990
other one because if you start sending

00:31:01,039 --> 00:31:06,130
rights to both systems it's really hard

00:31:02,990 --> 00:31:08,510
to tell which of them is the authority

00:31:06,130 --> 00:31:10,520
especially if they are lagging behind in

00:31:08,510 --> 00:31:12,590
replication hasn't finished yet and one

00:31:10,520 --> 00:31:14,090
of the nodes girls down you may end up

00:31:12,590 --> 00:31:16,970
with data that is in an inconsistent

00:31:14,090 --> 00:31:19,549
State so if you're using this

00:31:16,970 --> 00:31:23,870
configuration right update should only

00:31:19,549 --> 00:31:26,630
happen on one note all the time if you

00:31:23,870 --> 00:31:28,850
want to use my square or if you want to

00:31:26,630 --> 00:31:31,700
distribute right load what you should

00:31:28,850 --> 00:31:33,669
look at is what we call sharding where

00:31:31,700 --> 00:31:36,530
you have several MySQL servers which

00:31:33,669 --> 00:31:39,440
serve different parts of your data and

00:31:36,530 --> 00:31:41,330
you have either are using either the my

00:31:39,440 --> 00:31:43,309
scope proxy or some logic in your

00:31:41,330 --> 00:31:46,400
application to distribute the load

00:31:43,309 --> 00:31:53,120
depending on maybe a key or a hash on

00:31:46,400 --> 00:31:56,120
the different ways SQL server okay what

00:31:53,120 --> 00:31:59,900
happens if the master fence nothing the

00:31:56,120 --> 00:32:02,270
slave simply stops accepting updates

00:31:59,900 --> 00:32:05,150
from it it tries to connect and if it

00:32:02,270 --> 00:32:08,240
doesn't connect it just waits and sits

00:32:05,150 --> 00:32:11,950
but it's happily answering queries at

00:32:08,240 --> 00:32:15,110
the same time so the replication is just

00:32:11,950 --> 00:32:16,820
taken down if the slave fails again

00:32:15,110 --> 00:32:18,440
nothing will really happen the master

00:32:16,820 --> 00:32:20,990
will happily continue updating its

00:32:18,440 --> 00:32:23,659
binary lock it's just that the slave

00:32:20,990 --> 00:32:25,190
isn't following it anymore and when the

00:32:23,659 --> 00:32:27,409
slave comes back up again it's only

00:32:25,190 --> 00:32:29,179
later point in time it will simply have

00:32:27,409 --> 00:32:30,710
to replicate all the changes that have

00:32:29,179 --> 00:32:33,890
happened on the master server and the

00:32:30,710 --> 00:32:36,530
mean one and yes this is not an H a

00:32:33,890 --> 00:32:37,190
solution yet simply because we're just

00:32:36,530 --> 00:32:40,130
doing replica

00:32:37,190 --> 00:32:43,700
we're not taking care of failing over

00:32:40,130 --> 00:32:46,010
automatically or anything like that so

00:32:43,700 --> 00:32:50,560
what you want to do is combine mysql

00:32:46,010 --> 00:32:53,570
replication with some other solution and

00:32:50,560 --> 00:32:55,670
usually in in the linux word you would

00:32:53,570 --> 00:32:58,970
use heartbeat which is part of the linux

00:32:55,670 --> 00:33:01,180
h a project which allows you to move IP

00:32:58,970 --> 00:33:04,820
addresses between systems and also

00:33:01,180 --> 00:33:07,400
allows you to start or stop mysql server

00:33:04,820 --> 00:33:12,320
using scripts that are being executed in

00:33:07,400 --> 00:33:13,850
the case of a fail our situation load

00:33:12,320 --> 00:33:16,970
balancing here in that respect means

00:33:13,850 --> 00:33:19,640
that you can use the the replicated

00:33:16,970 --> 00:33:21,770
slave for distributing read load so if

00:33:19,640 --> 00:33:24,560
you are having lots of selects the slave

00:33:21,770 --> 00:33:26,900
can happily answer these as well and a

00:33:24,560 --> 00:33:29,680
replication slave is also very useful if

00:33:26,900 --> 00:33:33,020
you want to perform backups without

00:33:29,680 --> 00:33:35,390
disrupting or disturbing the Masters

00:33:33,020 --> 00:33:38,030
operation depending on what kind of

00:33:35,390 --> 00:33:39,920
backup technology you use it can affect

00:33:38,030 --> 00:33:42,350
the performance of a mysql server mysql

00:33:39,920 --> 00:33:44,180
dump for example if you're using my eyes

00:33:42,350 --> 00:33:46,640
on tables will lock the tables for a

00:33:44,180 --> 00:33:48,410
while until the backup has finished so

00:33:46,640 --> 00:33:50,960
your application may not be able to

00:33:48,410 --> 00:33:54,020
proceed until the backup is done if you

00:33:50,960 --> 00:33:57,200
distribute that on a replication slave

00:33:54,020 --> 00:33:59,360
it can be even shut down after

00:33:57,200 --> 00:34:01,280
performing the backups and we then just

00:33:59,360 --> 00:34:07,760
catch up with a master server once it's

00:34:01,280 --> 00:34:09,650
back up and running again tricky to fare

00:34:07,760 --> 00:34:12,500
back yeah you have to make sure that

00:34:09,650 --> 00:34:14,630
your tables are in sync once you have

00:34:12,500 --> 00:34:16,730
you've had a failover situation and

00:34:14,630 --> 00:34:19,790
you're ready to fail back to the now

00:34:16,730 --> 00:34:24,280
restored master server take a look at if

00:34:19,790 --> 00:34:27,050
your tables are consistent and intact so

00:34:24,280 --> 00:34:29,240
we don't have anything in here that

00:34:27,050 --> 00:34:31,370
allows you to resolve conflicts that may

00:34:29,240 --> 00:34:34,310
have occurred in your data after the

00:34:31,370 --> 00:34:36,860
failure of a solution there are lots of

00:34:34,310 --> 00:34:38,630
scripts that take care of that and I'm

00:34:36,860 --> 00:34:43,880
going to give you a few links above this

00:34:38,630 --> 00:34:46,990
soon some more about linux har also

00:34:43,880 --> 00:34:50,250
called heartbeat hope there's a typo and

00:34:46,990 --> 00:34:52,310
few common configurations two more no

00:34:50,250 --> 00:34:56,100
but you can also configure to set up

00:34:52,310 --> 00:34:58,680
even more notes I think Lina's H a

00:34:56,100 --> 00:35:01,140
project refers to some configurations

00:34:58,680 --> 00:35:05,160
where they have 16 notes in an AGA

00:35:01,140 --> 00:35:07,470
cluster that is being monitored fencing

00:35:05,160 --> 00:35:10,610
mechanism used by heartbeat is called

00:35:07,470 --> 00:35:13,680
Donath should the other node in the head

00:35:10,610 --> 00:35:15,750
which basically means that you have a

00:35:13,680 --> 00:35:17,970
device that can be controlled by the

00:35:15,750 --> 00:35:21,750
cluster to switch off the power from a

00:35:17,970 --> 00:35:23,370
certain machine so if one of the nodes

00:35:21,750 --> 00:35:28,020
is acting up it's simply being switched

00:35:23,370 --> 00:35:31,560
off linux heartbeat allows you to create

00:35:28,020 --> 00:35:35,010
policies that depending on on your

00:35:31,560 --> 00:35:36,780
current situation may result in

00:35:35,010 --> 00:35:39,990
different actions that are going to

00:35:36,780 --> 00:35:43,500
happen this can also be dependent on the

00:35:39,990 --> 00:35:45,870
time so for example a failover mechanism

00:35:43,500 --> 00:35:48,780
may look differently during the weekend

00:35:45,870 --> 00:35:52,170
or during day time when the system is

00:35:48,780 --> 00:35:54,540
very busy all this can be configured it

00:35:52,170 --> 00:35:59,610
ships with quite a lot of applications

00:35:54,540 --> 00:36:03,060
including support for MySQL it has a GUI

00:35:59,610 --> 00:36:06,450
tool and very low dependencies on other

00:36:03,060 --> 00:36:09,990
external applications libraries and it

00:36:06,450 --> 00:36:15,000
can perform fail or was in a very first

00:36:09,990 --> 00:36:18,780
way and this is how it usually looks

00:36:15,000 --> 00:36:21,660
like you have a MySQL master cell that

00:36:18,780 --> 00:36:23,220
replicates the MySQL slave you may have

00:36:21,660 --> 00:36:25,350
additional slaves that are also taking

00:36:23,220 --> 00:36:28,830
part in the replication and heartbeat

00:36:25,350 --> 00:36:30,630
make sure that the applications only the

00:36:28,830 --> 00:36:32,700
access one of the systems with the

00:36:30,630 --> 00:36:36,560
virtual IP address ative that you are

00:36:32,700 --> 00:36:36,560
moving over in case of a failover case

00:36:37,700 --> 00:36:43,230
another system that is commonly used to

00:36:40,920 --> 00:36:46,740
make my skin more highly available as

00:36:43,230 --> 00:36:51,300
drbd distributed replicated block device

00:36:46,740 --> 00:36:53,160
this basically says it all other refer

00:36:51,300 --> 00:36:56,370
to it as raid 1 over the network so you

00:36:53,160 --> 00:36:58,650
have assist to systems which both have

00:36:56,370 --> 00:37:00,090
local hard disks and one of the system

00:36:58,650 --> 00:37:02,550
is the primary so the other one is

00:37:00,090 --> 00:37:03,340
configured as the secondary every block

00:37:02,550 --> 00:37:05,620
that changes

00:37:03,340 --> 00:37:07,690
on the primary server has been or every

00:37:05,620 --> 00:37:10,300
change when the blocks of the disk is

00:37:07,690 --> 00:37:13,720
being replicated to the secondary system

00:37:10,300 --> 00:37:15,370
so you always have a one-to-one copy of

00:37:13,720 --> 00:37:19,300
your hard disks that is in the primary

00:37:15,370 --> 00:37:21,280
system so to the same recent versions of

00:37:19,300 --> 00:37:23,950
the rbd can be configured to do this

00:37:21,280 --> 00:37:26,650
replication either in a synchronous way

00:37:23,950 --> 00:37:29,200
so once you commit and save your data

00:37:26,650 --> 00:37:32,050
you can be sure that the copy on the

00:37:29,200 --> 00:37:35,770
secondary has been updated as well are

00:37:32,050 --> 00:37:39,040
you if you have lower requirements on on

00:37:35,770 --> 00:37:42,280
your system you can configure to be in

00:37:39,040 --> 00:37:43,810
an asynchronous method as well so your

00:37:42,280 --> 00:37:45,430
local application doesn't have to wait

00:37:43,810 --> 00:37:47,680
for the comet to happen it can proceed

00:37:45,430 --> 00:37:50,530
but then of course you again have to

00:37:47,680 --> 00:37:52,780
make sure that you can live with some

00:37:50,530 --> 00:37:56,350
data loss in case the replication hasn't

00:37:52,780 --> 00:37:59,290
finished if one of the notes goes down

00:37:56,350 --> 00:38:00,910
it has been reconfigured it

00:37:59,290 --> 00:38:02,320
automatically resync swith all the

00:38:00,910 --> 00:38:04,960
changes that have happened on the other

00:38:02,320 --> 00:38:07,240
side in the meanwhile since its

00:38:04,960 --> 00:38:09,790
performing on the block level of your

00:38:07,240 --> 00:38:12,130
application of your of your operating

00:38:09,790 --> 00:38:13,960
system it doesn't care about the

00:38:12,130 --> 00:38:16,270
application on top of it the application

00:38:13,960 --> 00:38:18,550
writes its data into the filesystem the

00:38:16,270 --> 00:38:20,080
rbd takes care of just replicating the

00:38:18,550 --> 00:38:24,490
blocks that have been changed regardless

00:38:20,080 --> 00:38:26,860
of what the application is doing it can

00:38:24,490 --> 00:38:29,800
also mask local i/o errors in case the

00:38:26,860 --> 00:38:31,510
local hard disk on the primary fails it

00:38:29,800 --> 00:38:33,190
is still capable of getting those blue

00:38:31,510 --> 00:38:35,740
these blocks from the secondary if

00:38:33,190 --> 00:38:37,780
needed so it's not like you have to

00:38:35,740 --> 00:38:41,110
failover immediately in the case of a

00:38:37,780 --> 00:38:44,230
disk corruption and the the common

00:38:41,110 --> 00:38:45,970
configurations you have one primary that

00:38:44,230 --> 00:38:47,710
has mounted the file systems where all

00:38:45,970 --> 00:38:49,630
the changes are being happened in the

00:38:47,710 --> 00:38:52,180
secondary is a so-called hot standby

00:38:49,630 --> 00:38:55,180
that just performs the replication does

00:38:52,180 --> 00:38:57,040
nothing else in the meanwhile because

00:38:55,180 --> 00:38:58,960
the problem is since the changes are

00:38:57,040 --> 00:39:01,840
being made on the block level of the

00:38:58,960 --> 00:39:03,670
disk you can't really mount that file

00:39:01,840 --> 00:39:05,470
system whether the blocks constantly

00:39:03,670 --> 00:39:08,260
changes underneath the file system there

00:39:05,470 --> 00:39:10,540
are only very few file systems like gfs

00:39:08,260 --> 00:39:12,640
are the oracle cluster file system that

00:39:10,540 --> 00:39:15,140
are capable of handling this kind of

00:39:12,640 --> 00:39:18,830
situation your usual file system like xt

00:39:15,140 --> 00:39:21,710
30 or XFS would become severely

00:39:18,830 --> 00:39:23,390
corrupted if you would try to mount the

00:39:21,710 --> 00:39:27,290
secondary file system while it's still

00:39:23,390 --> 00:39:29,210
being replicated drbd is open source

00:39:27,290 --> 00:39:34,010
it's part of the Linux kernel you can

00:39:29,210 --> 00:39:36,110
get it from the link down there and in

00:39:34,010 --> 00:39:38,720
the mice question area what you do is

00:39:36,110 --> 00:39:42,470
you configure the MySQL server to put

00:39:38,720 --> 00:39:44,780
its data directory on a device that is

00:39:42,470 --> 00:39:47,930
being replicated using drbd so MySQL

00:39:44,780 --> 00:39:50,480
updates its local tables stores all the

00:39:47,930 --> 00:39:52,940
data in this file system the rbd takes

00:39:50,480 --> 00:39:55,010
care of synchronizing every changes to

00:39:52,940 --> 00:39:58,480
do through the passive node as you can

00:39:55,010 --> 00:40:01,220
see over here in the case of a failover

00:39:58,480 --> 00:40:03,140
the first thing that the rbd has to do

00:40:01,220 --> 00:40:06,020
is mount the file system perform a

00:40:03,140 --> 00:40:07,820
filesystem check and then mysqld can be

00:40:06,020 --> 00:40:11,980
started and access the data on the

00:40:07,820 --> 00:40:15,350
replicated copy and continue as normal

00:40:11,980 --> 00:40:17,930
so the MySQL server usually has only

00:40:15,350 --> 00:40:19,940
started in the case of a failover you

00:40:17,930 --> 00:40:23,930
don't use the mysql replication in that

00:40:19,940 --> 00:40:27,020
case one down south side to the rbd is

00:40:23,930 --> 00:40:29,270
that it's available on Linux only there

00:40:27,020 --> 00:40:33,230
are other solutions on other operating

00:40:29,270 --> 00:40:35,810
systems that perform similar tasks okay

00:40:33,230 --> 00:40:37,970
mysql cluster is a completely different

00:40:35,810 --> 00:40:41,510
beast I have to speed up a bit i'm

00:40:37,970 --> 00:40:45,740
running out of time again um why scott

00:40:41,510 --> 00:40:47,810
cluster has been added to the mysql

00:40:45,740 --> 00:40:51,500
server i think two or three years ago

00:40:47,810 --> 00:40:53,480
and we acquired a company that was a

00:40:51,500 --> 00:40:55,880
spin-off by ericsson who created this

00:40:53,480 --> 00:40:58,640
cluster system for telecommunication

00:40:55,880 --> 00:41:02,920
solution so my scope custom isn't really

00:40:58,640 --> 00:41:05,780
an integral part of the mysql server

00:41:02,920 --> 00:41:08,420
what it does is it creates so called

00:41:05,780 --> 00:41:10,490
data nodes which are processes that run

00:41:08,420 --> 00:41:13,820
on separated systems and they take care

00:41:10,490 --> 00:41:15,860
of distributing data equally between the

00:41:13,820 --> 00:41:18,410
nodes and they take care of keeping the

00:41:15,860 --> 00:41:21,950
replicas consistent in making sure that

00:41:18,410 --> 00:41:23,420
you have redundant copies in in the dev

00:41:21,950 --> 00:41:26,980
in the various nodes

00:41:23,420 --> 00:41:29,540
and they synchronize those changes in it

00:41:26,980 --> 00:41:32,809
yeah synchronously between the data

00:41:29,540 --> 00:41:35,089
nodes and the mysql cluster nodes take

00:41:32,809 --> 00:41:37,160
care of the failover situation by

00:41:35,089 --> 00:41:40,250
themselves so that's already built into

00:41:37,160 --> 00:41:42,410
the system once a note has gone down and

00:41:40,250 --> 00:41:44,450
you bring it up again it automatically

00:41:42,410 --> 00:41:47,930
integrates into the cluster again and

00:41:44,450 --> 00:41:50,540
synchronizes with the notes so the

00:41:47,930 --> 00:41:53,809
redundancies been restored as fast as

00:41:50,540 --> 00:41:56,299
possible it supports transactions and

00:41:53,809 --> 00:42:02,950
there are various ways on how to connect

00:41:56,299 --> 00:42:07,190
to it some more about cluster here and

00:42:02,950 --> 00:42:09,950
up until recently mysql cluster had one

00:42:07,190 --> 00:42:11,839
severe limitation in the sense that all

00:42:09,950 --> 00:42:13,609
the data that you wanted to store in the

00:42:11,839 --> 00:42:15,559
cluster needed to fit in the main memory

00:42:13,609 --> 00:42:18,829
of your systems it wasn't capable of

00:42:15,559 --> 00:42:21,319
storing data on disk this has been fixed

00:42:18,829 --> 00:42:23,540
in the meanwhile with the only

00:42:21,319 --> 00:42:25,880
requirement remaining that your indexes

00:42:23,540 --> 00:42:27,410
have to be stored in memory but every

00:42:25,880 --> 00:42:30,559
other data of your tables can be stored

00:42:27,410 --> 00:42:33,319
on disk it's not suitable for all

00:42:30,559 --> 00:42:35,030
applications so you you if you are

00:42:33,319 --> 00:42:38,540
designing a system using MySQL cluster

00:42:35,030 --> 00:42:41,510
you have to look at what kind of queries

00:42:38,540 --> 00:42:43,490
that you're issuing since all the data

00:42:41,510 --> 00:42:45,650
nodes have to constantly communicate

00:42:43,490 --> 00:42:47,599
with each other there are a few query

00:42:45,650 --> 00:42:49,510
patterns that aren't really suitable for

00:42:47,599 --> 00:42:52,849
mysql cluster especially if you have

00:42:49,510 --> 00:42:55,069
complex joints that involve fetching

00:42:52,849 --> 00:42:57,230
data from lots of notes or if you have

00:42:55,069 --> 00:43:01,490
table scans or ranged against that skin

00:42:57,230 --> 00:43:05,710
and a large amount of your tables it

00:43:01,490 --> 00:43:09,349
doesn't support foreign keys yet and yet

00:43:05,710 --> 00:43:11,480
it depends on your data is it's a very

00:43:09,349 --> 00:43:14,450
specialized solution and you should

00:43:11,480 --> 00:43:17,359
consult with us if my school class there

00:43:14,450 --> 00:43:19,609
would be an option for you but it can

00:43:17,359 --> 00:43:21,980
also be combined with for example the

00:43:19,609 --> 00:43:25,040
mysql replication system to make it even

00:43:21,980 --> 00:43:28,000
more redundant just to give you an

00:43:25,040 --> 00:43:30,170
overview the mysql server itself

00:43:28,000 --> 00:43:32,690
connects to the my scope cluster and

00:43:30,170 --> 00:43:34,040
uses it at a storage engine you may know

00:43:32,690 --> 00:43:36,830
that mysql is capable

00:43:34,040 --> 00:43:39,140
or storing tables in different storage

00:43:36,830 --> 00:43:42,410
engines the most to common use ones on

00:43:39,140 --> 00:43:44,900
my Isom or a new DB which saw tables

00:43:42,410 --> 00:43:47,300
locally on disk in this scenario the

00:43:44,900 --> 00:43:50,060
MySQL server simply hence the group

00:43:47,300 --> 00:43:51,950
tables over to mysql cluster processes

00:43:50,060 --> 00:43:53,960
which run on on separate machines and

00:43:51,950 --> 00:43:56,060
they take care of distributing and

00:43:53,960 --> 00:43:58,250
storing the data the interesting thing

00:43:56,060 --> 00:44:01,220
here is that you can have several my

00:43:58,250 --> 00:44:02,690
scale so it was all accessing the same

00:44:01,220 --> 00:44:04,760
cluster nodes and all seeing a

00:44:02,690 --> 00:44:07,250
consistent picture of the data so if

00:44:04,760 --> 00:44:09,380
you're performing updates on the server

00:44:07,250 --> 00:44:11,240
on the left and you perform a select on

00:44:09,380 --> 00:44:12,920
the mouse cursor on the right you will

00:44:11,240 --> 00:44:16,910
immediately see the changes that have

00:44:12,920 --> 00:44:20,210
happened in the meanwhile and in

00:44:16,910 --> 00:44:22,790
addition to using MySQL server the mice

00:44:20,210 --> 00:44:25,550
and mysql cluster also provides an API

00:44:22,790 --> 00:44:27,830
to talk with the cluster directly so you

00:44:25,550 --> 00:44:30,320
don't have to use SQL of the MySQL

00:44:27,830 --> 00:44:31,460
client-server protocol you can talk with

00:44:30,320 --> 00:44:37,460
the cluster with your application

00:44:31,460 --> 00:44:42,020
directing using our API I'm going to

00:44:37,460 --> 00:44:44,210
skip that one mmm is also a tool that is

00:44:42,020 --> 00:44:46,220
commonly used it's particularly suited

00:44:44,210 --> 00:44:50,960
if you have 2 mysql servers configured

00:44:46,220 --> 00:44:52,940
in a master master configuration so it's

00:44:50,960 --> 00:44:55,880
an alternative to heartbeat a bit more

00:44:52,940 --> 00:44:59,810
simpler it simply changes the IP address

00:44:55,880 --> 00:45:02,780
and and updates a few changes on the

00:44:59,810 --> 00:45:06,110
MySQL server so it's it's really focused

00:45:02,780 --> 00:45:08,480
on on this particular configuration but

00:45:06,110 --> 00:45:10,490
it's pretty widely used and for people

00:45:08,480 --> 00:45:15,050
that want to set up linux heartbeat it's

00:45:10,490 --> 00:45:16,790
a good alternative flipper is also a

00:45:15,050 --> 00:45:20,300
little script that performs a similar

00:45:16,790 --> 00:45:22,940
task but it's not doing anything in an

00:45:20,300 --> 00:45:26,030
automatic version this is really low

00:45:22,940 --> 00:45:29,570
fight so to say and flipper just

00:45:26,030 --> 00:45:31,370
automates the process of switching the

00:45:29,570 --> 00:45:33,790
roles between a master master

00:45:31,370 --> 00:45:36,770
configuration and you have to do this

00:45:33,790 --> 00:45:38,600
consciously by issuing a certain command

00:45:36,770 --> 00:45:40,430
but it's still quite helpful if you're

00:45:38,600 --> 00:45:41,660
an administrator and you just want to

00:45:40,430 --> 00:45:46,970
switch your application

00:45:41,660 --> 00:45:49,970
a different mysql server sorry clipper

00:45:46,970 --> 00:45:54,829
may come in handy right head cluster

00:45:49,970 --> 00:45:56,480
street also very popular in the

00:45:54,829 --> 00:46:00,799
meanwhile many people use it for the

00:45:56,480 --> 00:46:03,890
applications has similar features to

00:46:00,799 --> 00:46:05,690
linux h a but can do a bit more and also

00:46:03,890 --> 00:46:07,819
support some load balancing

00:46:05,690 --> 00:46:09,950
functionality also has a good support

00:46:07,819 --> 00:46:12,319
for mysql server so that might be

00:46:09,950 --> 00:46:13,760
something if you're using sent Oso retin

00:46:12,319 --> 00:46:19,549
Enterprise Linux it's very well

00:46:13,760 --> 00:46:22,760
integrated into it solaris cluster open

00:46:19,549 --> 00:46:24,589
h a cluster is a solution made by sun

00:46:22,760 --> 00:46:27,799
primarily for the solaris operating

00:46:24,589 --> 00:46:29,869
system we recently open sourced the

00:46:27,799 --> 00:46:31,789
entire suite and are working on

00:46:29,869 --> 00:46:36,680
improving it it also has excellent

00:46:31,789 --> 00:46:40,839
support for mysql and also provides

00:46:36,680 --> 00:46:43,309
replication to remote facilities and

00:46:40,839 --> 00:46:45,950
using it in combination with storage

00:46:43,309 --> 00:46:49,010
area networks for example so if you are

00:46:45,950 --> 00:46:50,240
running on solaris the solaris clusters

00:46:49,010 --> 00:46:54,349
which is something that you should

00:46:50,240 --> 00:46:57,279
investigate closely and some more links

00:46:54,349 --> 00:47:03,829
i think i mentioned many of these before

00:46:57,279 --> 00:47:06,319
you can take them from the slides yep we

00:47:03,829 --> 00:47:09,200
got these before oh yeah matt kate is

00:47:06,319 --> 00:47:11,270
also a very popular collection of

00:47:09,200 --> 00:47:12,740
scripts and tools that you as a my

00:47:11,270 --> 00:47:15,230
school administrator should be aware of

00:47:12,740 --> 00:47:18,279
they really simplify a lot of the

00:47:15,230 --> 00:47:20,930
processes of working with mysql and

00:47:18,279 --> 00:47:23,859
continuant has just recently open

00:47:20,930 --> 00:47:26,690
sourced their replicator which is

00:47:23,859 --> 00:47:30,380
another way of how to replicate data in

00:47:26,690 --> 00:47:31,730
between databases I haven't really

00:47:30,380 --> 00:47:35,000
looked deeply into it yet but it sounds

00:47:31,730 --> 00:47:37,750
kind of promising okay five more minutes

00:47:35,000 --> 00:47:37,750
left for questions

00:47:41,280 --> 00:47:47,370
any questions yes

00:48:15,770 --> 00:48:18,770
bye

00:48:24,550 --> 00:48:30,230
so the question was which of the

00:48:26,839 --> 00:48:34,070
limitations of replication are just a

00:48:30,230 --> 00:48:35,780
problem of the system itself and how its

00:48:34,070 --> 00:48:38,420
configured which are limitations of the

00:48:35,780 --> 00:48:42,050
mysql server and could be improved by

00:48:38,420 --> 00:48:44,750
fixing the mysql server and i am

00:48:42,050 --> 00:48:46,400
honestly can't tell you out of my head

00:48:44,750 --> 00:48:48,980
right now there may be some limitations

00:48:46,400 --> 00:48:50,900
that we're working on fixing and some

00:48:48,980 --> 00:48:53,119
simply are inherent to the system and

00:48:50,900 --> 00:48:55,250
how it works if you have a particular

00:48:53,119 --> 00:48:57,260
one that you're interested about I can

00:48:55,250 --> 00:48:58,580
try to find out but right out of my head

00:48:57,260 --> 00:49:10,369
I don't really have an answer for you

00:48:58,580 --> 00:49:12,170
sorry yes right so the question was my

00:49:10,369 --> 00:49:15,140
school master master application has a

00:49:12,170 --> 00:49:16,849
few issues that you should be aware of

00:49:15,140 --> 00:49:19,099
and one of them for example is if you

00:49:16,849 --> 00:49:21,230
issue updates to both toes at the same

00:49:19,099 --> 00:49:24,140
time you have a consistency problem that

00:49:21,230 --> 00:49:25,640
since it's a synchronous replication you

00:49:24,140 --> 00:49:27,650
can't be a hundred percent sure that

00:49:25,640 --> 00:49:29,690
both servers are always in the same

00:49:27,650 --> 00:49:31,820
consistent state at the same time so if

00:49:29,690 --> 00:49:34,099
your application distributors the rights

00:49:31,820 --> 00:49:36,710
to both notes and one of them goes down

00:49:34,099 --> 00:49:41,900
it will be very difficult for you to

00:49:36,710 --> 00:49:46,040
find out which of them has the the real

00:49:41,900 --> 00:49:48,830
data yes as long as you write to one

00:49:46,040 --> 00:49:51,140
it's pretty safe considering that you

00:49:48,830 --> 00:49:54,050
know this is the main master server it

00:49:51,140 --> 00:49:55,910
has the authority of information and the

00:49:54,050 --> 00:49:59,170
replica may be behind but it's something

00:49:55,910 --> 00:49:59,170
you can check from the logs

00:50:03,170 --> 00:50:08,579
no it does not the question was if it

00:50:05,670 --> 00:50:10,440
supports synchronous replication and no

00:50:08,579 --> 00:50:12,329
unfortunately mysql replication is

00:50:10,440 --> 00:50:13,859
always a synchronous if you need

00:50:12,329 --> 00:50:16,260
synchronous replication you should take

00:50:13,859 --> 00:50:24,770
a look at the RVD and do it on the file

00:50:16,260 --> 00:50:24,770
system level any more questions yes

00:50:28,700 --> 00:50:37,960
a practically use case for replicating

00:50:34,339 --> 00:50:42,829
from one master to multiple slaves or

00:50:37,960 --> 00:50:45,079
right what is the practical use case for

00:50:42,829 --> 00:50:51,410
replicating from one master to one slave

00:50:45,079 --> 00:50:55,490
and then to several slaves here scaling

00:50:51,410 --> 00:50:57,619
read-only scaling right but yeah so

00:50:55,490 --> 00:50:59,510
really if you have more slaves you can

00:50:57,619 --> 00:51:01,190
have an application that distributes and

00:50:59,510 --> 00:51:03,280
selects to all the various slaves

00:51:01,190 --> 00:51:09,109
instead of just putting it on the master

00:51:03,280 --> 00:51:11,210
so um it's actually explain I'm really

00:51:09,109 --> 00:51:13,520
missing the key point why you want to do

00:51:11,210 --> 00:51:16,660
it master to slave and then from there

00:51:13,520 --> 00:51:19,220
to in several more slaves if you have

00:51:16,660 --> 00:51:21,740
multiple data centers yeah that would be

00:51:19,220 --> 00:51:24,470
one example if if you have a distributed

00:51:21,740 --> 00:51:26,480
system where you have a company with

00:51:24,470 --> 00:51:29,150
several branches they've need copies of

00:51:26,480 --> 00:51:34,000
the data you can then distribute these

00:51:29,150 --> 00:51:34,000
into a separate locations for example

00:51:35,589 --> 00:51:42,440
all right then no more questions I hope

00:51:40,640 --> 00:51:45,230
to see you it didn't Masefield Ephraim

00:51:42,440 --> 00:51:48,170
then for some more additional mysql

00:51:45,230 --> 00:51:50,410
related information and thank you very

00:51:48,170 --> 00:51:50,410
much

00:51:53,640 --> 00:51:55,700

YouTube URL: https://www.youtube.com/watch?v=Z33-bWSMCN0


