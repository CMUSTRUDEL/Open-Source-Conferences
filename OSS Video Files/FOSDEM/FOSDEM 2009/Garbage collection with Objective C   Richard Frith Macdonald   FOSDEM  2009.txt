Title: Garbage collection with Objective C   Richard Frith Macdonald   FOSDEM  2009
Publication date: 2011-12-22
Playlist: FOSDEM 2009
Description: 
	FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:10,620 --> 00:00:16,010
I thought maintain your business at base

00:00:14,010 --> 00:00:21,510
library have recently been working on

00:00:16,010 --> 00:00:25,790
garbage collection first Asian history

00:00:21,510 --> 00:00:29,130
of garbage collection in objective-c

00:00:25,790 --> 00:00:32,610
really started with conservative garbage

00:00:29,130 --> 00:00:36,629
collector written it on 1988 that a

00:00:32,610 --> 00:00:39,870
vendre whole piece of software live

00:00:36,629 --> 00:00:41,220
foundation which was written around the

00:00:39,870 --> 00:00:42,930
same time as the new set based

00:00:41,220 --> 00:00:45,150
introduced the garbage collection

00:00:42,930 --> 00:00:48,750
through an object at sea foundation

00:00:45,150 --> 00:00:52,620
library in 1998 and I added it to

00:00:48,750 --> 00:01:03,960
goodness that place in 1999 but Apple

00:00:52,620 --> 00:01:05,970
Coco who produced it in 2007 and why do

00:01:03,960 --> 00:01:08,640
we have gotten collection well the

00:01:05,970 --> 00:01:11,729
original reason we added it was the make

00:01:08,640 --> 00:01:16,380
things easier for program on managing

00:01:11,729 --> 00:01:18,119
memory is just ahead so you can decrease

00:01:16,380 --> 00:01:20,250
the memory management overheads with

00:01:18,119 --> 00:01:22,409
garbage collection and don't have to do

00:01:20,250 --> 00:01:25,939
reference mountain that kind of claim we

00:01:22,409 --> 00:01:25,939
do have a good reference counting method

00:01:26,000 --> 00:01:30,750
we want to dive garbage collection

00:01:28,200 --> 00:01:32,840
system to be portable across platform

00:01:30,750 --> 00:01:36,810
because canoe step is a very

00:01:32,840 --> 00:01:38,700
cross-platform development system we

00:01:36,810 --> 00:01:41,369
wanted a single code bed solution early

00:01:38,700 --> 00:01:44,329
for both garbage collecting care and a

00:01:41,369 --> 00:01:46,530
long garbage collection version and

00:01:44,329 --> 00:01:49,020
originally we wanted big foundation

00:01:46,530 --> 00:01:51,499
compatibility because we believe in

00:01:49,020 --> 00:01:53,189
conforming standards of the only other

00:01:51,499 --> 00:01:57,229
implementation that use garbage

00:01:53,189 --> 00:01:57,229
collection at all with the foundation

00:01:57,439 --> 00:02:04,609
visit the garbage collections

00:01:59,639 --> 00:02:07,200
performance contrary to a lot of ideas

00:02:04,609 --> 00:02:10,410
the garbage collection times actually

00:02:07,200 --> 00:02:13,770
seemed to work faster in real life than

00:02:10,410 --> 00:02:17,570
reference counting that's mainly

00:02:13,770 --> 00:02:20,070
anecdotal evidence from did foundation

00:02:17,570 --> 00:02:23,210
certainly the foundation showed that

00:02:20,070 --> 00:02:25,560
lunch collection systems could be

00:02:23,210 --> 00:02:29,670
comparable asked to little more

00:02:25,560 --> 00:02:31,500
reference data I'm sorry but isn't it

00:02:29,670 --> 00:02:34,410
that these things which one would do

00:02:31,500 --> 00:02:36,510
seem faster or mail me deal with a small

00:02:34,410 --> 00:02:39,030
number of object if you deal with their

00:02:36,510 --> 00:02:41,820
water project it's much slower when you

00:02:39,030 --> 00:02:43,620
deal with supplies classic and do a blog

00:02:41,820 --> 00:02:48,300
location on your own all right around

00:02:43,620 --> 00:02:51,480
when we went finish a lot of people no

00:02:48,300 --> 00:02:53,880
that's not necessary to that in the firm

00:02:51,480 --> 00:02:55,790
library for instance those threadlocal

00:02:53,880 --> 00:02:58,620
garbage collection which lets you

00:02:55,790 --> 00:03:02,280
localize where you're collecting data

00:02:58,620 --> 00:03:06,030
from upset them you don't have to worry

00:03:02,280 --> 00:03:08,250
about spanning the whole of the memory

00:03:06,030 --> 00:03:10,710
for instance and the Apple

00:03:08,250 --> 00:03:12,300
implementation also has different

00:03:10,710 --> 00:03:16,580
mechanism for avoiding standing all the

00:03:12,300 --> 00:03:19,440
memory all the time and pragmatically

00:03:16,580 --> 00:03:22,260
the code that you tend to write in

00:03:19,440 --> 00:03:25,020
something like C++ or C to handle the

00:03:22,260 --> 00:03:27,780
memory management is generally slow yes

00:03:25,020 --> 00:03:29,700
you can optimize it to be faster you can

00:03:27,780 --> 00:03:33,690
also do that in the garbage collecting

00:03:29,700 --> 00:03:35,070
environment in Objective C so what

00:03:33,690 --> 00:03:39,030
you're talking about their overall

00:03:35,070 --> 00:03:43,170
performance for the average user garbage

00:03:39,030 --> 00:03:45,180
collection can work out pasta generally

00:03:43,170 --> 00:03:48,959
and when you're talking about

00:03:45,180 --> 00:03:52,170
customizing specific micromanaging

00:03:48,959 --> 00:03:56,030
little tasks you can hard fo bit and

00:03:52,170 --> 00:03:59,160
I've in which own language you know it

00:03:56,030 --> 00:04:00,570
so why did we use the burn library well

00:03:59,160 --> 00:04:03,300
it was public the main code which is

00:04:00,570 --> 00:04:04,950
kind of important it was already very

00:04:03,300 --> 00:04:09,590
mature and stable by the time we

00:04:04,950 --> 00:04:12,410
introduced it 10 years old at that point

00:04:09,590 --> 00:04:16,290
it was quite portable there are a lot of

00:04:12,410 --> 00:04:18,180
systems supports my bone library and it

00:04:16,290 --> 00:04:19,950
was very fully featured it is really

00:04:18,180 --> 00:04:25,670
pretty much everything you want from the

00:04:19,950 --> 00:04:28,530
garbage collector by that time because

00:04:25,670 --> 00:04:31,530
it's used in good foundation it had

00:04:28,530 --> 00:04:36,030
already been integrated into the canoe

00:04:31,530 --> 00:04:42,120
runtime it's currently included in the

00:04:36,030 --> 00:04:44,070
GCC Potter Creed's part of GCT or at

00:04:42,120 --> 00:04:49,530
least a particular direction which is

00:04:44,070 --> 00:04:56,400
not very latest and instead to perform

00:04:49,530 --> 00:04:59,100
very well and I get away garbage

00:04:56,400 --> 00:05:02,750
collection is used in the news that base

00:04:59,100 --> 00:05:06,690
is that all the object allocation is

00:05:02,750 --> 00:05:09,690
typed collectible memory what we mean by

00:05:06,690 --> 00:05:13,080
that is that at the point where the

00:05:09,690 --> 00:05:15,330
object is created we know which instance

00:05:13,080 --> 00:05:18,990
variables of the objects are pointers to

00:05:15,330 --> 00:05:20,040
things that we might want to keep a

00:05:18,990 --> 00:05:21,960
reference to it in the garbage

00:05:20,040 --> 00:05:24,360
collection system and we know that other

00:05:21,960 --> 00:05:26,430
parts of the business variables are not

00:05:24,360 --> 00:05:30,260
so the garbage collection there is about

00:05:26,430 --> 00:05:30,260
those and doesn't have the Scanlon

00:05:31,449 --> 00:05:36,219
when we allocated memory generally

00:05:34,110 --> 00:05:40,449
everything was allocated a scam to

00:05:36,219 --> 00:05:43,629
export by default so every memory

00:05:40,449 --> 00:05:45,729
everything's a memory allocated could

00:05:43,629 --> 00:05:50,800
contain point sister things apart from

00:05:45,729 --> 00:05:53,349
the title collectible objects and also

00:05:50,800 --> 00:05:57,490
with the exception of GS atomic malik

00:05:53,349 --> 00:06:00,309
zone in the Oakland staff I the API you

00:05:57,490 --> 00:06:03,490
allocate memory in different zones so we

00:06:00,309 --> 00:06:05,949
introduced that zone to say here's a

00:06:03,490 --> 00:06:10,050
zone where you don't need to scan it

00:06:05,949 --> 00:06:10,050
there will be no pointers in this area

00:06:11,069 --> 00:06:15,879
plus point of doing all that with this

00:06:13,990 --> 00:06:18,550
it was very easy to convert applications

00:06:15,879 --> 00:06:22,110
you don't unexpectedly collect memory

00:06:18,550 --> 00:06:24,759
because all the stuff that you used to

00:06:22,110 --> 00:06:28,659
implicitly allocates from the heat and

00:06:24,759 --> 00:06:30,460
the default snow is now scan so it's

00:06:28,659 --> 00:06:33,490
said in that respect but it doesn't mean

00:06:30,460 --> 00:06:36,939
that it's a bit slower though more

00:06:33,490 --> 00:06:38,589
memory than necessary expand and data

00:06:36,939 --> 00:06:41,529
that doesn't want any pointers would be

00:06:38,589 --> 00:06:42,899
scanning and possibly you think they

00:06:41,529 --> 00:06:45,610
have a pointer and keep something

00:06:42,899 --> 00:06:47,969
allocated essentially leaked remember a

00:06:45,610 --> 00:06:47,969
little

00:06:48,930 --> 00:06:53,490
so the use of the atomic malik zone

00:06:51,660 --> 00:06:54,990
internally meant but actually we near

00:06:53,490 --> 00:07:04,350
the base library we didn't have any of

00:06:54,990 --> 00:07:07,590
those problems the way a root object and

00:07:04,350 --> 00:07:11,009
this object has changed was doing nor

00:07:07,590 --> 00:07:12,389
the allocation zone of course we don't

00:07:11,009 --> 00:07:14,430
want to allocate in a particular zone

00:07:12,389 --> 00:07:17,400
anymore we're using garbage related

00:07:14,430 --> 00:07:21,870
memory auto releases d alec release

00:07:17,400 --> 00:07:24,979
retain they're not used anymore so they

00:07:21,870 --> 00:07:28,460
just do nothing the retained pound

00:07:24,979 --> 00:07:31,349
returns your impacts just to say this is

00:07:28,460 --> 00:07:37,199
retained as many times as possible if

00:07:31,349 --> 00:07:39,630
not going to be elevated by what you

00:07:37,199 --> 00:07:42,750
said that allocated objects using the

00:07:39,630 --> 00:07:45,889
time memory you know only they point to

00:07:42,750 --> 00:07:45,889
instance variable sustained

00:07:47,150 --> 00:07:56,800
so because we changed that to remove or

00:07:53,150 --> 00:07:56,800
comments out effectively the d/l method

00:07:56,920 --> 00:08:02,950
the paradigm of do cleanup in the

00:07:59,900 --> 00:08:05,660
allocation of objects no longer works

00:08:02,950 --> 00:08:07,640
and that means that the ideal way to

00:08:05,660 --> 00:08:09,260
handle that in most objects is to

00:08:07,640 --> 00:08:11,360
invalidate the object and do it

00:08:09,260 --> 00:08:15,380
explicitly now that things like closing

00:08:11,360 --> 00:08:18,980
file descriptors if we can't do explicit

00:08:15,380 --> 00:08:21,770
clean up because we don't know where

00:08:18,980 --> 00:08:24,140
we're getting rid of the object it's

00:08:21,770 --> 00:08:29,930
hanging around somewhere we need to use

00:08:24,140 --> 00:08:33,080
a finalization finalization we added a

00:08:29,930 --> 00:08:40,760
new protocol which isn't finalized

00:08:33,080 --> 00:08:43,910
critical basically any class which

00:08:40,760 --> 00:08:47,120
conform to that protocol was finalized

00:08:43,910 --> 00:08:49,990
and it was finalized by using the GC

00:08:47,120 --> 00:08:49,990
finalize method

00:08:51,590 --> 00:08:56,270
the idea of that isn't you you shouldn't

00:08:54,320 --> 00:09:01,640
ever put that code in your own so it's

00:08:56,270 --> 00:09:03,740
like dr look expect that is called by

00:09:01,640 --> 00:09:06,500
the garbage collector so there should

00:09:03,740 --> 00:09:07,730
never be n meet the utica Liz except of

00:09:06,500 --> 00:09:09,650
course you need to call the superclass

00:09:07,730 --> 00:09:11,930
in from implementation if you're writing

00:09:09,650 --> 00:09:16,610
a subclass of another platters or

00:09:11,930 --> 00:09:20,110
finalize the methods cause automatically

00:09:16,610 --> 00:09:22,670
when the object is deallocated

00:09:20,110 --> 00:09:24,620
finalization is fairly expensive to you

00:09:22,670 --> 00:09:26,870
so you should use as little as possible

00:09:24,620 --> 00:09:28,700
whether the problem is that when you do

00:09:26,870 --> 00:09:30,770
a garbage collection run you find those

00:09:28,700 --> 00:09:32,780
finalize all the methods that have a

00:09:30,770 --> 00:09:35,300
fine lines and set and that means that

00:09:32,780 --> 00:09:38,930
you can end up executing quite a lot of

00:09:35,300 --> 00:09:41,510
code at one time so make the

00:09:38,930 --> 00:09:47,180
finalization method lightweight how many

00:09:41,510 --> 00:09:49,340
monies that week pointers rabbit a week

00:09:47,180 --> 00:09:53,030
pointer doesn't prevent the collection

00:09:49,340 --> 00:09:56,440
of the object for pointing to it could

00:09:53,030 --> 00:10:05,690
be created by registering in finalized

00:09:56,440 --> 00:10:09,080
initialized method so whenever whenever

00:10:05,690 --> 00:10:11,270
a class instance is created the

00:10:09,080 --> 00:10:13,010
initialize method or the first type of

00:10:11,270 --> 00:10:16,340
letter D central class the initialize

00:10:13,010 --> 00:10:20,210
method is anticipa-- and that allows you

00:10:16,340 --> 00:10:23,060
to say all objects of that class will be

00:10:20,210 --> 00:10:31,070
finalized so it will have repointed in

00:10:23,060 --> 00:10:36,279
future week pointers in the phone

00:10:31,070 --> 00:10:38,410
library I'm not automatically 0 so

00:10:36,279 --> 00:10:40,870
you can get situation where you're

00:10:38,410 --> 00:10:42,519
pointing to something that's object it

00:10:40,870 --> 00:10:44,410
positively pointing to gets collectors

00:10:42,519 --> 00:10:48,009
and pointer is ending up pointing to

00:10:44,410 --> 00:10:51,189
nowhere so if that's going to be a

00:10:48,009 --> 00:10:54,220
problem the object that leads is going

00:10:51,189 --> 00:10:57,610
to be deallocated these have a finalized

00:10:54,220 --> 00:11:00,040
the method to remove or clear that week

00:10:57,610 --> 00:11:02,680
pointer in the other object that's very

00:11:00,040 --> 00:11:04,809
much the same sort of situation that you

00:11:02,680 --> 00:11:09,220
get with the standard email instead on a

00:11:04,809 --> 00:11:14,350
great wedding you have say a

00:11:09,220 --> 00:11:17,319
notification observer and that observer

00:11:14,350 --> 00:11:19,779
gets the allocated it's the our method

00:11:17,319 --> 00:11:26,290
removes it removes the object from the

00:11:19,779 --> 00:11:30,309
notification system controller the

00:11:26,290 --> 00:11:31,629
collector of course there are times when

00:11:30,309 --> 00:11:35,350
you don't want velveeta collection to

00:11:31,629 --> 00:11:38,559
happen if you've got time in critical

00:11:35,350 --> 00:11:41,620
code so you can temporarily disable and

00:11:38,559 --> 00:11:43,360
reenable reflector there are times when

00:11:41,620 --> 00:11:45,399
you think you've gone round the balloon

00:11:43,360 --> 00:11:47,769
allocating lots of objects we don't need

00:11:45,399 --> 00:11:49,480
anymore and you want to reduce the

00:11:47,769 --> 00:11:53,519
memory footprint of your application so

00:11:49,480 --> 00:11:59,139
you want to request another collection

00:11:53,519 --> 00:12:00,579
either using inbuilt thresholds so if so

00:11:59,139 --> 00:12:03,069
much memory has been allocated then

00:12:00,579 --> 00:12:05,769
we'll do a collection or unconditionally

00:12:03,069 --> 00:12:10,930
we want to collect and garbage right

00:12:05,769 --> 00:12:13,689
away then as a lot we also need to be

00:12:10,930 --> 00:12:16,709
able to register an unregistered zero

00:12:13,689 --> 00:12:16,709
memory the pointers

00:12:17,050 --> 00:12:26,570
well that's done by a native calls to

00:12:20,090 --> 00:12:31,330
the collector the other thing we added

00:12:26,570 --> 00:12:31,330
way back then was a whole load of macros

00:12:32,530 --> 00:12:38,860
the retain calls retain if you're

00:12:36,140 --> 00:12:42,100
running compiling in velvet and a

00:12:38,860 --> 00:12:44,780
conventional system and does nothing

00:12:42,100 --> 00:12:46,970
come in sometimes effectively if your

00:12:44,780 --> 00:12:50,600
run compiling for a garbage collection

00:12:46,970 --> 00:12:54,440
simply with all of the others the idea

00:12:50,600 --> 00:12:58,670
of that was for performance yes and then

00:12:54,440 --> 00:13:00,830
why you they get back then the overheads

00:12:58,670 --> 00:13:02,240
of actually making those reference

00:13:00,830 --> 00:13:03,980
counting method calls who are

00:13:02,240 --> 00:13:08,720
significant that it's really not the

00:13:03,980 --> 00:13:11,480
case on the modern process the other

00:13:08,720 --> 00:13:15,860
reasons for putting these markers it was

00:13:11,480 --> 00:13:17,840
the reliability destroy is a convenient

00:13:15,860 --> 00:13:19,700
way of zeroing the pointer so that you

00:13:17,840 --> 00:13:22,790
know that the object it points do can be

00:13:19,700 --> 00:13:28,460
collected rather than having to remember

00:13:22,790 --> 00:13:32,210
to deallocated or and then 0.8 you use a

00:13:28,460 --> 00:13:35,590
macro grid assign helps present prevent

00:13:32,210 --> 00:13:35,590
mistakes in the same sort of way

00:13:36,160 --> 00:13:43,900
building a bit of intelligence standard

00:13:39,470 --> 00:13:43,900
usage good practice

00:13:47,189 --> 00:13:55,029
right the downside of that is that if

00:13:51,369 --> 00:13:56,889
you compiled code with those macros then

00:13:55,029 --> 00:13:59,289
if you compiled it in a garbage

00:13:56,889 --> 00:14:01,569
collecting environment your calls to

00:13:59,289 --> 00:14:06,819
retain release auto release whatever

00:14:01,569 --> 00:14:09,009
don't exist anymore so your binary can't

00:14:06,819 --> 00:14:11,799
be run without a garbage collecting

00:14:09,009 --> 00:14:14,499
version for library i'm not sure but

00:14:11,799 --> 00:14:17,699
that's really problem the other downside

00:14:14,499 --> 00:14:22,619
is purely that they are pitting elegant

00:14:17,699 --> 00:14:22,619
so maybe we'll get rid of those my dress

00:14:23,220 --> 00:14:33,519
then why did we want to change it real

00:14:28,839 --> 00:14:37,720
bad well originally we were a loop and

00:14:33,519 --> 00:14:39,159
asian compatible there's no be no

00:14:37,720 --> 00:14:42,239
interest in garbage collection in

00:14:39,159 --> 00:14:44,559
objectivity for many years I I know that

00:14:42,239 --> 00:14:46,239
because I know some bugs in the code

00:14:44,559 --> 00:14:52,479
would have been there few years and no

00:14:46,239 --> 00:14:53,769
one is complaining balance I possibly

00:14:52,479 --> 00:14:56,049
that's because the retail release

00:14:53,769 --> 00:14:59,459
mechanism reference counting actually is

00:14:56,049 --> 00:15:02,229
good works very well in general but now

00:14:59,459 --> 00:15:04,929
apple health code have introduced

00:15:02,229 --> 00:15:07,899
garbage collecting themselves and revive

00:15:04,929 --> 00:15:10,119
the interest in it and lift foundation

00:15:07,899 --> 00:15:11,799
is obsolete no one really uses it

00:15:10,119 --> 00:15:14,289
anymore so there's no point in is trying

00:15:11,799 --> 00:15:18,429
to be compatible with the lid foundation

00:15:14,289 --> 00:15:22,479
in conversation so we changed the whole

00:15:18,429 --> 00:15:24,549
focus the Apple compatible now we're not

00:15:22,479 --> 00:15:29,109
throwing away the existing work really

00:15:24,549 --> 00:15:31,799
and we keeping the bone library right

00:15:29,109 --> 00:15:34,949
might incur babysit if it's so great

00:15:31,799 --> 00:15:37,029
well maybe they just like the ring page

00:15:34,949 --> 00:15:40,149
certainly they have no need for Pierce

00:15:37,029 --> 00:15:45,189
ability you can write code optimizer and

00:15:40,149 --> 00:15:47,949
system and their implementation does

00:15:45,189 --> 00:15:49,299
depend on compiler support instead

00:15:47,949 --> 00:15:51,789
building and they can do that because

00:15:49,299 --> 00:15:55,389
they have a dedicated compiler of their

00:15:51,789 --> 00:15:56,010
own system they say they wanted more

00:15:55,389 --> 00:15:58,110
predictive

00:15:56,010 --> 00:16:00,690
and they want a better performance I

00:15:58,110 --> 00:16:05,940
don't actually know of any evidence that

00:16:00,690 --> 00:16:07,920
they have that but maybe they have I

00:16:05,940 --> 00:16:10,670
think what difference does using bone

00:16:07,920 --> 00:16:14,300
making over apples implementation well

00:16:10,670 --> 00:16:17,760
the Apple implementation user 0 we 0

00:16:14,300 --> 00:16:20,520
weak memory without and then doesn't

00:16:17,760 --> 00:16:24,210
have as it does have zeroing weak point

00:16:20,520 --> 00:16:26,580
is their implementation does

00:16:24,210 --> 00:16:30,030
generational garbage collection they

00:16:26,580 --> 00:16:31,640
compile at least the compiler puts stuff

00:16:30,030 --> 00:16:34,500
in the code so they can keep track of

00:16:31,640 --> 00:16:37,380
which objects have been allocated

00:16:34,500 --> 00:16:39,150
recently and so they can look at those

00:16:37,380 --> 00:16:41,190
recent objects first when they're doing

00:16:39,150 --> 00:16:46,680
your garbage collection run which

00:16:41,190 --> 00:16:49,080
hopefully means that they get rid of

00:16:46,680 --> 00:16:51,870
objects that they likely are not to need

00:16:49,080 --> 00:16:56,820
very quickly without having to do a full

00:16:51,870 --> 00:16:58,440
run on the other hand the borrowing

00:16:56,820 --> 00:17:00,180
library has spread local garbage

00:16:58,440 --> 00:17:03,240
collection which means that you don't

00:17:00,180 --> 00:17:06,600
have to worry about stopping all threads

00:17:03,240 --> 00:17:10,530
to do a garbage bag so their performance

00:17:06,600 --> 00:17:13,520
difference in garden way okay so the

00:17:10,530 --> 00:17:16,560
change to the way the base library

00:17:13,520 --> 00:17:18,510
garbage collection works the negative

00:17:16,560 --> 00:17:24,690
compatible with objects and seeing every

00:17:18,510 --> 00:17:29,250
cocoa okay all that object allocation is

00:17:24,690 --> 00:17:33,090
time flexible that's not a change stays

00:17:29,250 --> 00:17:35,580
the same but we have a new function l NS

00:17:33,090 --> 00:17:40,410
allocate collectible that's a plating

00:17:35,580 --> 00:17:42,810
the eye and that will if you stand or on

00:17:40,410 --> 00:17:46,580
scan memory and it will say whether that

00:17:42,810 --> 00:17:49,680
memory itself can be collected or not

00:17:46,580 --> 00:17:51,690
before malik zone is understand

00:17:49,680 --> 00:17:54,900
uncollectible so you have to create

00:17:51,690 --> 00:17:57,600
explicitly that's completely the

00:17:54,900 --> 00:18:00,210
opposite of the way the base like we

00:17:57,600 --> 00:18:02,090
used to do it where we had stand

00:18:00,210 --> 00:18:05,669
collectible by

00:18:02,090 --> 00:18:12,809
so that's a major shift in that one

00:18:05,669 --> 00:18:18,350
point finalization well they still have

00:18:12,809 --> 00:18:20,909
finalization of course ends different so

00:18:18,350 --> 00:18:23,159
now they have to finalize method where

00:18:20,909 --> 00:18:24,840
we have the GC finalized so we have to

00:18:23,159 --> 00:18:30,020
change all my method base but that's

00:18:24,840 --> 00:18:32,400
pretty trivial all you need to do is

00:18:30,020 --> 00:18:36,169
implement that method in your subclass

00:18:32,400 --> 00:18:39,030
to have it at that classifying light

00:18:36,169 --> 00:18:41,760
whereas we had protocol to flag whether

00:18:39,030 --> 00:18:45,000
or not the class needs finalization that

00:18:41,760 --> 00:18:47,370
was also easy to change it looks cleaner

00:18:45,000 --> 00:18:51,120
and simpler I prefer finalized as a

00:18:47,370 --> 00:18:53,130
method name for finalization so we

00:18:51,120 --> 00:18:58,980
already we've already changed to

00:18:53,130 --> 00:19:04,110
implement now zeroing week pointers

00:18:58,980 --> 00:19:08,370
that's a big issue a difference that's

00:19:04,110 --> 00:19:11,760
Coco added the week key word on this

00:19:08,370 --> 00:19:15,480
what we keyword in the compiler to mark

00:19:11,760 --> 00:19:19,950
an instance variable as zeroing week

00:19:15,480 --> 00:19:21,900
pointer because we don't have a compiler

00:19:19,950 --> 00:19:25,710
support yet though it's possible we

00:19:21,900 --> 00:19:27,120
could add bits GCC we have a long time

00:19:25,710 --> 00:19:29,429
mechanism to do the same sort of thing

00:19:27,120 --> 00:19:32,909
so we've added the function GS and a

00:19:29,429 --> 00:19:35,100
tweet pointer and what you need to do is

00:19:32,909 --> 00:19:38,429
call back in the initialize method of

00:19:35,100 --> 00:19:43,500
your class to say that a particular

00:19:38,429 --> 00:19:46,799
instance variable is a weak point out we

00:19:43,500 --> 00:19:49,470
also have gs assigned 0 we pointer which

00:19:46,799 --> 00:19:53,039
lets you assign a value to a zero in

00:19:49,470 --> 00:19:54,929
wheat pointer Apple don't need that

00:19:53,039 --> 00:19:57,419
because their compiler implicitly does

00:19:54,929 --> 00:19:59,700
it it knows that the pointer is a

00:19:57,419 --> 00:20:04,620
weakness ero weak point because of the

00:19:59,700 --> 00:20:06,580
new keyword and the compiler will do the

00:20:04,620 --> 00:20:09,700
overheads of telling the

00:20:06,580 --> 00:20:12,580
garbage collecting library that you've

00:20:09,700 --> 00:20:16,809
made an assignment to our pointer we

00:20:12,580 --> 00:20:19,510
have to do it explicitly and again it's

00:20:16,809 --> 00:20:25,659
someone else compiling support we can

00:20:19,510 --> 00:20:31,080
avoid doing that hopefully I think

00:20:25,659 --> 00:20:35,230
that's too difficult notifications

00:20:31,080 --> 00:20:37,269
that's a big part of the way openstep

00:20:35,230 --> 00:20:40,990
applications work sending notifications

00:20:37,269 --> 00:20:44,080
to different objects if a notification

00:20:40,990 --> 00:20:47,159
center retains an observer then the

00:20:44,080 --> 00:20:50,289
observers never going to be deallocated

00:20:47,159 --> 00:20:51,820
obviously we don't want that so we don't

00:20:50,289 --> 00:20:54,730
be clean yourself up and we use a week

00:20:51,820 --> 00:20:57,039
pointer pacifically all servers allocate

00:20:54,730 --> 00:20:58,750
de elevated and we haven't removed it

00:20:57,039 --> 00:21:00,580
from the notification center we're going

00:20:58,750 --> 00:21:03,960
to get to crash when the center tries to

00:21:00,580 --> 00:21:08,200
send a notification to that object so

00:21:03,960 --> 00:21:11,610
the observer has to be removed it in

00:21:08,200 --> 00:21:15,190
somehow traditionally that's done in the

00:21:11,610 --> 00:21:18,130
observers diala practice but now we have

00:21:15,190 --> 00:21:21,250
a zero agree pointer used in the

00:21:18,130 --> 00:21:24,299
notification center so the observers no

00:21:21,250 --> 00:21:24,299
longer need to remove themselves

00:21:28,450 --> 00:21:39,570
we have a similar situation with p value

00:21:31,090 --> 00:21:41,800
observing where an observer normally

00:21:39,570 --> 00:21:44,980
unregistered itself from opposite of an

00:21:41,800 --> 00:21:48,130
object at the point when it's the

00:21:44,980 --> 00:21:50,080
alligator again we use zeroing weak

00:21:48,130 --> 00:21:54,130
point to say we avoid the observer

00:21:50,080 --> 00:21:56,440
having to do that it's a mechanism

00:21:54,130 --> 00:21:58,330
that's generally applicable ready sort

00:21:56,440 --> 00:22:01,420
of sizing where you have one object on

00:21:58,330 --> 00:22:05,020
serving another object and it avoids the

00:22:01,420 --> 00:22:07,780
need to finalize those on servers as I

00:22:05,020 --> 00:22:13,420
said before minimizing the use of

00:22:07,780 --> 00:22:15,550
finalization is a good thing the other

00:22:13,420 --> 00:22:17,020
advantage is that the burden of

00:22:15,550 --> 00:22:19,120
management is lifted from the

00:22:17,020 --> 00:22:20,620
application programmer they no longer

00:22:19,120 --> 00:22:25,390
need to worry about removing themselves

00:22:20,620 --> 00:22:30,160
on servers and just the next out a whole

00:22:25,390 --> 00:22:34,600
thing traditionally delegates of objects

00:22:30,160 --> 00:22:36,220
are not retained now that's so that you

00:22:34,600 --> 00:22:38,110
don't get retailer loops causing

00:22:36,220 --> 00:22:39,880
delegates to never be released which is

00:22:38,110 --> 00:22:42,840
the problem with the reference counting

00:22:39,880 --> 00:22:44,860
system with a garbage collecting system

00:22:42,840 --> 00:22:46,390
you don't have to worry about the

00:22:44,860 --> 00:22:50,830
written words because the garbage

00:22:46,390 --> 00:22:52,630
collector will resolve that so we

00:22:50,830 --> 00:22:55,360
actually have no need to use weak points

00:22:52,630 --> 00:22:58,980
as for delegates though the fact that

00:22:55,360 --> 00:23:03,400
are zeroing week pointers are currently

00:22:58,980 --> 00:23:05,260
different from the apple ones is

00:23:03,400 --> 00:23:07,510
actually nothing like as big a problem

00:23:05,260 --> 00:23:10,360
as it might seem because almost

00:23:07,510 --> 00:23:13,690
everywhere that you use used to use weak

00:23:10,360 --> 00:23:17,460
pointers people would expect to use weak

00:23:13,690 --> 00:23:17,460
pointers you don't actually need to

00:23:19,290 --> 00:23:26,080
so how's collection control well before

00:23:23,500 --> 00:23:29,650
it was done directly by calls to the

00:23:26,080 --> 00:23:33,070
bone library now we use apples API and

00:23:29,650 --> 00:23:37,570
you NS garbage collector class for this

00:23:33,070 --> 00:23:38,920
class is implemented already and you

00:23:37,570 --> 00:23:42,250
don't have to know anything about the

00:23:38,920 --> 00:23:43,810
Boeing maybe I am more the default

00:23:42,250 --> 00:23:46,390
collector method of the class returns

00:23:43,810 --> 00:23:48,490
nearly garbage collections not it use so

00:23:46,390 --> 00:23:49,990
it's a great run time check see if the

00:23:48,490 --> 00:23:53,920
applications working in the garbage

00:23:49,990 --> 00:23:56,380
collecting environment so at the moment

00:23:53,920 --> 00:24:01,510
for instance we have reuse that in the

00:23:56,380 --> 00:24:04,240
regression testing suite to control how

00:24:01,510 --> 00:24:06,640
which regression tests we do depending

00:24:04,240 --> 00:24:08,920
on whether we're running with garbage

00:24:06,640 --> 00:24:13,290
collection or not obviously some tests

00:24:08,920 --> 00:24:13,290
are inappropriate in different setups

00:24:15,450 --> 00:24:21,220
collective needed that trigger to

00:24:17,740 --> 00:24:22,960
garbage collection it's really the same

00:24:21,220 --> 00:24:25,870
as the functionality we had with the

00:24:22,960 --> 00:24:28,420
bone library so we just wrap the burning

00:24:25,870 --> 00:24:30,790
library school there's a threshold

00:24:28,420 --> 00:24:32,320
amount of memory if we've allocated that

00:24:30,790 --> 00:24:35,250
book for every since the last garbage

00:24:32,320 --> 00:24:38,710
collection then a collection takes place

00:24:35,250 --> 00:24:42,850
collected exhaustively we have a full

00:24:38,710 --> 00:24:45,940
garbage collected on disable enable is

00:24:42,850 --> 00:24:49,320
enabled they tell you whether garbage

00:24:45,940 --> 00:24:49,320
collections in the use of moments

00:24:51,020 --> 00:25:00,330
okay the NS autorelease pool us pretty

00:24:55,470 --> 00:25:02,010
much obsolete adding an object to a pool

00:25:00,330 --> 00:25:04,650
viously does not it with no point doing

00:25:02,010 --> 00:25:08,160
it I've landed the drain methods so we

00:25:04,650 --> 00:25:13,290
infinity too does the same thing as

00:25:08,160 --> 00:25:16,320
liked if needed so i'm actually I have

00:25:13,290 --> 00:25:17,820
no idea why Apple added that method as

00:25:16,320 --> 00:25:20,280
far as I can see the facts really ought

00:25:17,820 --> 00:25:23,790
to be completely obsolete in the garbage

00:25:20,280 --> 00:25:28,020
collecting environment but we did that

00:25:23,790 --> 00:25:31,200
become that ability then this pointer

00:25:28,020 --> 00:25:35,010
array class it's a new class introduced

00:25:31,200 --> 00:25:38,370
by apple in mac OS 10.5 can hold

00:25:35,010 --> 00:25:40,230
pointers and all integers you can

00:25:38,370 --> 00:25:43,470
contain new objects and little pointers

00:25:40,230 --> 00:25:47,400
which is a departure from all the

00:25:43,470 --> 00:25:51,090
collection classes traditionally in in

00:25:47,400 --> 00:25:53,490
the openstep API you can tell it to you

00:25:51,090 --> 00:25:58,110
zeroing weak memory so that items become

00:25:53,490 --> 00:26:01,500
newborn or when they collected so

00:25:58,110 --> 00:26:04,710
internally we implement that as using

00:26:01,500 --> 00:26:08,040
the zeroing week pointers low intellect

00:26:04,710 --> 00:26:09,990
to users so from the point of view of an

00:26:08,040 --> 00:26:11,700
application programmer there's no

00:26:09,990 --> 00:26:15,210
difference that it works exactly like

00:26:11,700 --> 00:26:18,059
Apple implementation not completely

00:26:15,210 --> 00:26:22,070
implemented in this step yet I expect

00:26:18,059 --> 00:26:22,070
that to be finished in about two weeks

00:26:23,120 --> 00:26:35,970
as hash table when we when we originally

00:26:31,320 --> 00:26:38,700
intimates of garbage collection in new

00:26:35,970 --> 00:26:42,510
step base way back we added support for

00:26:38,700 --> 00:26:46,230
which pointers there but they were not

00:26:42,510 --> 00:26:48,659
zeroing week pointers Apple have taken a

00:26:46,230 --> 00:26:51,360
very different approach they've actually

00:26:48,659 --> 00:26:56,070
removed the NS hash table object as it

00:26:51,360 --> 00:26:59,399
was and made it into a full class with

00:26:56,070 --> 00:27:01,080
support preserving read pointers so it's

00:26:59,399 --> 00:27:04,169
ultimately removal of the collected

00:27:01,080 --> 00:27:07,200
items we are going to change to match

00:27:04,169 --> 00:27:08,940
that and i imagining that will probably

00:27:07,200 --> 00:27:11,549
be ready in about two weeks as well it's

00:27:08,940 --> 00:27:16,640
really the same pretty much the same set

00:27:11,549 --> 00:27:21,360
of codes it's the NS pointer array in

00:27:16,640 --> 00:27:23,580
this map table the situation is very

00:27:21,360 --> 00:27:25,679
similar originally we supported

00:27:23,580 --> 00:27:29,130
reacquaintance but only for weak point

00:27:25,679 --> 00:27:32,640
three pointers for keys and values so if

00:27:29,130 --> 00:27:34,710
your map has this setup for weak

00:27:32,640 --> 00:27:36,210
pointers then it was vocally point us

00:27:34,710 --> 00:27:39,590
the keys and week when sitting the

00:27:36,210 --> 00:27:42,120
values Apple have made it into a class

00:27:39,590 --> 00:27:44,669
and they've added separate support for

00:27:42,120 --> 00:27:49,460
weak points apiece and weak point of the

00:27:44,669 --> 00:27:49,460
families we've been to makes a change

00:27:50,550 --> 00:27:56,610
again you're looking about two weeks all

00:27:53,460 --> 00:27:59,040
that done so we have almost the same

00:27:56,610 --> 00:28:02,880
garbage collection functionalities that

00:27:59,040 --> 00:28:07,310
will do hash table and then it's max

00:28:02,880 --> 00:28:10,260
ever need updating to be exes classes

00:28:07,310 --> 00:28:12,660
yet direct uses earring with pointers

00:28:10,260 --> 00:28:14,310
remains different that's the only

00:28:12,660 --> 00:28:19,440
difference you see between the two very

00:28:14,310 --> 00:28:21,930
eyes now that that will probably change

00:28:19,440 --> 00:28:25,020
it if I meant someone puts in the

00:28:21,930 --> 00:28:30,650
compiler supporting GCC to automate it

00:28:25,020 --> 00:28:35,790
for itself but until then as I say is

00:28:30,650 --> 00:28:42,870
minimally used so it's a big deal for

00:28:35,790 --> 00:28:45,240
portability and that's it so essentially

00:28:42,870 --> 00:28:47,460
an overview of all the change basically

00:28:45,240 --> 00:28:49,680
we've implemented or will have

00:28:47,460 --> 00:28:53,130
implemented within a few weeks the

00:28:49,680 --> 00:28:59,580
entire garbage collecting API of mac OS

00:28:53,130 --> 00:29:01,170
10.5 questions anything equivalent only

00:28:59,580 --> 00:29:03,930
clearer what's the main stage adore

00:29:01,170 --> 00:29:06,750
under which connectivism to do it in

00:29:03,930 --> 00:29:08,990
four moves through objects or reference

00:29:06,750 --> 00:29:11,850
console or something combined to the

00:29:08,990 --> 00:29:13,860
bone well you you really ought to look

00:29:11,850 --> 00:29:15,960
at the garbage collection library

00:29:13,860 --> 00:29:18,030
documentation program essentially sir

00:29:15,960 --> 00:29:20,550
it's a conservative garbage collector it

00:29:18,030 --> 00:29:25,890
scans memory also couples come from

00:29:20,550 --> 00:29:28,710
Horace okay okay a full scan now then it

00:29:25,890 --> 00:29:32,220
scans everything on the stack everything

00:29:28,710 --> 00:29:35,400
in the registers and everything on the

00:29:32,220 --> 00:29:38,670
heap that it's been told to scale so

00:29:35,400 --> 00:29:41,880
full it's all people which sir quite

00:29:38,670 --> 00:29:45,510
expensive yeah but it will do thread set

00:29:41,880 --> 00:29:50,300
that on separate threads separate heaps

00:29:45,510 --> 00:29:50,300
the separate threads if you like and

00:29:51,100 --> 00:29:55,190
generally speaking it doesn't it's not

00:29:53,389 --> 00:29:57,739
that expensive because most of the

00:29:55,190 --> 00:29:59,779
memory you allocate doesn't get scammed

00:29:57,739 --> 00:30:01,869
because it knows not to scan it because

00:29:59,779 --> 00:30:05,299
it knows there are no pointers in it or

00:30:01,869 --> 00:30:10,369
it knows that certain sections of memory

00:30:05,299 --> 00:30:12,440
have mixtures of pointers and nonpoint

00:30:10,369 --> 00:30:15,889
two parts of memory that's called typed

00:30:12,440 --> 00:30:18,289
memory rule knows what type of memory is

00:30:15,889 --> 00:30:20,269
at different locations so it knows which

00:30:18,289 --> 00:30:25,580
parts it needs to scan which part it

00:30:20,269 --> 00:30:30,859
doesn't it so it's nothing like having

00:30:25,580 --> 00:30:34,700
to spend the whole team and in fact it

00:30:30,859 --> 00:30:37,059
can make good guesses about what a valid

00:30:34,700 --> 00:30:39,470
pointer and all that kind of thing is

00:30:37,059 --> 00:30:42,249
really very good at minimizing that

00:30:39,470 --> 00:30:45,950
there's a key feature so that's

00:30:42,249 --> 00:30:59,509
something that burn worked on for many

00:30:45,950 --> 00:31:02,239
years seeing this language which I

00:30:59,509 --> 00:31:04,789
borders on which other responds and

00:31:02,239 --> 00:31:08,749
forwards the stack it doesn't bother

00:31:04,789 --> 00:31:10,669
type it has to assume the well I mean

00:31:08,749 --> 00:31:13,429
obviously knows that something's are the

00:31:10,669 --> 00:31:15,830
the frame pointers women stack it has an

00:31:13,429 --> 00:31:18,440
understanding of the actual stacked

00:31:15,830 --> 00:31:21,950
layout but when it comes to the actual

00:31:18,440 --> 00:31:27,649
data variables understand it won't at

00:31:21,950 --> 00:31:30,770
the time so it has some fairly basic

00:31:27,649 --> 00:31:33,450
heuristics I mean if it's a

00:31:30,770 --> 00:31:37,560
if what it sees on the stack is an

00:31:33,450 --> 00:31:39,210
integer that has the lowest bit set it

00:31:37,560 --> 00:31:41,070
knows it's not a pointer to a block of

00:31:39,210 --> 00:31:42,900
memory so it went over looking at that

00:31:41,070 --> 00:31:45,390
but essentially expensive look at the

00:31:42,900 --> 00:31:54,350
whole thing the Holy the stack so if

00:31:45,390 --> 00:31:54,350

YouTube URL: https://www.youtube.com/watch?v=9MhB_xkq1GI


