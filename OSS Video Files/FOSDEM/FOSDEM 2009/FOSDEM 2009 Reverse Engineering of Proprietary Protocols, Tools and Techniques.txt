Title: FOSDEM 2009 Reverse Engineering of Proprietary Protocols, Tools and Techniques
Publication date: 2011-12-22
Playlist: FOSDEM 2009
Description: 
	This talk is about reverse engineering a proprietary network protocol, and then creating my own implementation. The talk will cover the tools used to take binary data apart, capture the data, and techniques I use for decoding unknown formats. The protocol covered is the RTMP protocol used by Adobe flash, and this new implementation is part of the Gnash project.

By Rob Savoye

FOSDEM (Free and Open Source Development European Meeting) is a European event centered around Free and Open Source software development. It is aimed at developers and all interested in the Free and Open Source news in the world. Its goals are to enable developers to meet and to promote the awareness and use of free and open source software. More info at http://fosdem.org
Captions: 
	00:00:07,890 --> 00:00:15,010
stuff worked

00:00:09,610 --> 00:00:16,990
jdb for 14 years lots of

00:00:15,010 --> 00:00:18,330
for about the last 20 years my current

00:00:16,990 --> 00:00:20,619
project is ganache which I'll get into

00:00:18,330 --> 00:00:22,150
but anyway I was basically going to do a

00:00:20,619 --> 00:00:23,830
talk on reverse engineering of

00:00:22,150 --> 00:00:25,330
proprietary network protocols more

00:00:23,830 --> 00:00:27,490
focusing on the tools and techniques

00:00:25,330 --> 00:00:28,930
this is more of a series of slides with

00:00:27,490 --> 00:00:31,180
me rambling in between so if you have

00:00:28,930 --> 00:00:32,650
questions ask them at the time I don't

00:00:31,180 --> 00:00:36,940
think you have to wait till the whole

00:00:32,650 --> 00:00:38,770
end basically I start a non-profit last

00:00:36,940 --> 00:00:40,360
year to work on a lot of these issues

00:00:38,770 --> 00:00:42,309
that I'll be getting into but we call

00:00:40,360 --> 00:00:47,140
ourselves open media now we're

00:00:42,309 --> 00:00:48,190
officially based in colorado oh but

00:00:47,140 --> 00:00:50,350
we're getting this thing's going to

00:00:48,190 --> 00:00:51,580
change slides on me again but basically

00:00:50,350 --> 00:00:53,769
we have people spread out all over the

00:00:51,580 --> 00:00:57,550
planet we do a lot of work on multimedia

00:00:53,769 --> 00:01:02,140
software a long as I'm gonna have to fix

00:00:57,550 --> 00:01:07,030
openoffice listen anybody know how to

00:01:02,140 --> 00:01:08,530
make it stop advancing automatically all

00:01:07,030 --> 00:01:10,000
right basically so we also do a lot of

00:01:08,530 --> 00:01:11,500
fundraising for a bunch of software

00:01:10,000 --> 00:01:13,390
projects that we maintain as well as

00:01:11,500 --> 00:01:15,369
doing a lot of legal work around on

00:01:13,390 --> 00:01:18,430
multi media codec and stuff and we're

00:01:15,369 --> 00:01:22,750
pretty big on educational software this

00:01:18,430 --> 00:01:24,010
is going to join me crazy um as much as

00:01:22,750 --> 00:01:35,860
I hate to say it I'm going to try and

00:01:24,010 --> 00:01:39,160
fix this very quick manually amazing it

00:01:35,860 --> 00:01:40,420
survived so one of our initial projects

00:01:39,160 --> 00:01:42,520
that most people have heard of is a

00:01:40,420 --> 00:01:45,130
ganache which is a new flash player

00:01:42,520 --> 00:01:46,750
client and for a lot of people if you're

00:01:45,130 --> 00:01:48,670
on a 64-bit system and you're not

00:01:46,750 --> 00:01:50,950
running and Intel Architecture flash

00:01:48,670 --> 00:01:52,300
support is rather difficult so one so

00:01:50,950 --> 00:01:54,400
anyway a bunch of years ago we wrote

00:01:52,300 --> 00:01:55,750
Ganesh which is and some of this talk is

00:01:54,400 --> 00:01:58,150
about some of the work we've done in

00:01:55,750 --> 00:02:00,280
working on Ganesh unlike a lot of free

00:01:58,150 --> 00:02:02,050
software projects ganache is almost an

00:02:00,280 --> 00:02:03,880
entirely reverse engineered project

00:02:02,050 --> 00:02:05,680
until recently none of the Adobe

00:02:03,880 --> 00:02:07,330
specifications are open so we've

00:02:05,680 --> 00:02:09,789
actually spent about five years figuring

00:02:07,330 --> 00:02:12,459
everything out the hard way but the fun

00:02:09,789 --> 00:02:14,709
way Ganesh one stand alone as well as a

00:02:12,459 --> 00:02:16,330
browser plugin for firefox conquer or

00:02:14,709 --> 00:02:18,730
Mozilla I squeezle and a bunch of

00:02:16,330 --> 00:02:20,140
different stuff standalone wises on

00:02:18,730 --> 00:02:22,000
ganache is actually popular for user

00:02:20,140 --> 00:02:23,980
interfaces for embedded devices written

00:02:22,000 --> 00:02:26,230
in flash as opposed to just running it

00:02:23,980 --> 00:02:28,030
for youtube stuff we do a lot of work

00:02:26,230 --> 00:02:28,810
with streaming video which is sort of

00:02:28,030 --> 00:02:31,060
why some of this

00:02:28,810 --> 00:02:33,450
engineering I've had to do lately we use

00:02:31,060 --> 00:02:37,180
OpenGL for hardware accelerated graphics

00:02:33,450 --> 00:02:39,280
AGG cairo we have a lot of work on

00:02:37,180 --> 00:02:41,530
security a lot of different stuff like

00:02:39,280 --> 00:02:43,720
that we also support using odd vorbis

00:02:41,530 --> 00:02:45,550
and fiora streaming for like Wikipedia

00:02:43,720 --> 00:02:49,480
and Internet Archive instead of just

00:02:45,550 --> 00:02:51,790
using all that proprietary stuff we also

00:02:49,480 --> 00:02:53,800
have another project that I started last

00:02:51,790 --> 00:02:55,420
year that is kind of what this talk was

00:02:53,800 --> 00:02:58,000
about as the work in that project called

00:02:55,420 --> 00:03:00,010
signal I recently cloned the adobe media

00:02:58,000 --> 00:03:02,709
server since I had a flash virtual

00:03:00,010 --> 00:03:04,480
machine and a lot more companies like

00:03:02,709 --> 00:03:06,519
the BBC we're shifting to using

00:03:04,480 --> 00:03:08,470
proprietary network protocols I thought

00:03:06,519 --> 00:03:12,010
it would be fun to write my own and so

00:03:08,470 --> 00:03:14,290
unlike some of the other media servers

00:03:12,010 --> 00:03:16,569
we have a flash virtual machine built in

00:03:14,290 --> 00:03:19,120
we support patent free codecs as well as

00:03:16,569 --> 00:03:20,769
free one and although it won't be fully

00:03:19,120 --> 00:03:22,750
functional in its alpha release coming

00:03:20,769 --> 00:03:24,310
out in a couple of weeks it's pretty

00:03:22,750 --> 00:03:26,049
much working towards full flash based

00:03:24,310 --> 00:03:30,549
video conferencing groupware type of

00:03:26,049 --> 00:03:32,859
applications the last Ganesh talk and

00:03:30,549 --> 00:03:34,299
Ganesh actually we do up to version 9 in

00:03:32,859 --> 00:03:35,440
version 10 these days although most

00:03:34,299 --> 00:03:37,780
people never notice it because all the

00:03:35,440 --> 00:03:39,220
distributions ship old versions so if

00:03:37,780 --> 00:03:41,230
you ever have ganache problems use a

00:03:39,220 --> 00:03:43,000
newer version and stuff and we've got a

00:03:41,230 --> 00:03:45,280
lot of the ActionScript implemented and

00:03:43,000 --> 00:03:47,140
we started work on actionscript 3 which

00:03:45,280 --> 00:03:51,310
is like a gigantic classpath library

00:03:47,140 --> 00:03:53,560
like Java was a little bit more stuff on

00:03:51,310 --> 00:03:55,390
Ganesh Ganesh is written in C++ which is

00:03:53,560 --> 00:03:57,760
sort of unusual for your new projects

00:03:55,390 --> 00:04:00,730
but a lot of things actually translate

00:03:57,760 --> 00:04:02,769
pretty well to C++ not everything but in

00:04:00,730 --> 00:04:04,030
this case it works pretty well we also

00:04:02,769 --> 00:04:06,310
use the good new water tools which

00:04:04,030 --> 00:04:08,650
drives people crazy endlessly but it

00:04:06,310 --> 00:04:10,420
works pretty good for us we use boost a

00:04:08,650 --> 00:04:12,790
lot boost is about to become the new a

00:04:10,420 --> 00:04:15,130
lot of the boost classes are being added

00:04:12,790 --> 00:04:16,930
to the standard template library for C++

00:04:15,130 --> 00:04:20,440
so we've been using boost we support

00:04:16,930 --> 00:04:21,639
gstreamer or ffmpeg we support a bunch

00:04:20,440 --> 00:04:23,260
of different networking protocols

00:04:21,639 --> 00:04:24,760
including the one I'm about to talk

00:04:23,260 --> 00:04:26,169
about and we support a lot of different

00:04:24,760 --> 00:04:28,270
gooeys because we figured people should

00:04:26,169 --> 00:04:29,860
use you know their desktop and their GUI

00:04:28,270 --> 00:04:33,520
tool kits that they're used to so we

00:04:29,860 --> 00:04:35,770
support everything from gtk que de q te

00:04:33,520 --> 00:04:37,780
raw frame buffers aqua and macintosh

00:04:35,770 --> 00:04:40,169
somebody's even doing windows support I

00:04:37,780 --> 00:04:40,169
don't know why

00:04:40,589 --> 00:04:45,609
yeah I guess Windows users need a 64-bit

00:04:43,209 --> 00:04:47,799
Flash plugin we're also really big on

00:04:45,609 --> 00:04:49,959
performance which is important because

00:04:47,799 --> 00:04:53,049
we do a lot of support of embedded

00:04:49,959 --> 00:04:54,609
devices and things on open moco nokia

00:04:53,049 --> 00:04:56,229
internet tablets a lot of that kind of

00:04:54,609 --> 00:04:58,209
stuff so we've done a lot of work with

00:04:56,229 --> 00:05:00,549
lately with the ex video extension for

00:04:58,209 --> 00:05:02,379
full scoring high resolution video and a

00:05:00,549 --> 00:05:05,109
lot of stuff we're doing I think at last

00:05:02,379 --> 00:05:07,509
testing 1,900 x 1200 full screen video

00:05:05,109 --> 00:05:09,159
at ten percent cpu load which is really

00:05:07,509 --> 00:05:10,689
good for a lot of the lower end hardware

00:05:09,159 --> 00:05:11,979
i mean just because it Dobie wrote the

00:05:10,689 --> 00:05:15,549
flash player doesn't mean we can't do a

00:05:11,979 --> 00:05:20,199
better job so so basically this talk is

00:05:15,549 --> 00:05:21,699
about rtmp rtmp is a Dobies proprietary

00:05:20,199 --> 00:05:24,759
networking protocol that's used by the

00:05:21,699 --> 00:05:27,099
BBC iplayer right now and also used for

00:05:24,759 --> 00:05:28,599
flash based applications so if you've

00:05:27,099 --> 00:05:30,479
ever done like professional video

00:05:28,599 --> 00:05:33,099
conferencing and group where software

00:05:30,479 --> 00:05:34,389
spreed is that open source company in

00:05:33,099 --> 00:05:36,399
Germany that uses this they're almost

00:05:34,389 --> 00:05:39,009
all written in flash you can write a

00:05:36,399 --> 00:05:40,839
video conferencing application in flash

00:05:39,009 --> 00:05:43,209
and actionscript and like literally 15

00:05:40,839 --> 00:05:44,949
or 20 lines of code and so the problem

00:05:43,209 --> 00:05:46,599
was is that um you know we want and

00:05:44,949 --> 00:05:48,429
support for this protocol of which there

00:05:46,599 --> 00:05:51,509
was no documentation available on the

00:05:48,429 --> 00:05:53,769
internet and it was kind of important so

00:05:51,509 --> 00:05:55,929
rtmp is actually used by a whole bunch

00:05:53,769 --> 00:05:57,759
of different things but there's a couple

00:05:55,929 --> 00:05:59,439
of main functions that Adobe uses it for

00:05:57,759 --> 00:06:01,479
that we needed it actually supports

00:05:59,439 --> 00:06:03,429
taking an action script object like a

00:06:01,479 --> 00:06:05,129
date class whether it's in JavaScript or

00:06:03,429 --> 00:06:07,569
whatever and encoding it in the binary

00:06:05,129 --> 00:06:09,429
transmitting it to the server it may

00:06:07,569 --> 00:06:11,919
transmit up to other clients and you're

00:06:09,429 --> 00:06:13,719
actually transmitting actual objects

00:06:11,919 --> 00:06:15,159
around sort of at that object encoded

00:06:13,719 --> 00:06:17,439
level and that was kind of the whole

00:06:15,159 --> 00:06:19,749
purpose of rtmp is that it labels you to

00:06:17,439 --> 00:06:22,029
more or less transmit flash programs

00:06:19,749 --> 00:06:23,739
between multiple applications the other

00:06:22,029 --> 00:06:25,269
nice thing is on the server side is it

00:06:23,739 --> 00:06:27,549
lets you actually do real seeking with

00:06:25,269 --> 00:06:29,529
video so we're adding support for a

00:06:27,549 --> 00:06:31,379
thing called a Z chopping which is

00:06:29,529 --> 00:06:33,489
basically server-side editing a video

00:06:31,379 --> 00:06:36,369
things like that you can do with your

00:06:33,489 --> 00:06:39,009
own server there's a whole lot of

00:06:36,369 --> 00:06:41,129
different rtmp protocols that Adobe's

00:06:39,009 --> 00:06:44,409
developed they're all basically the same

00:06:41,129 --> 00:06:46,299
with just minor variations on mostly

00:06:44,409 --> 00:06:49,089
some capsulation different encryption

00:06:46,299 --> 00:06:50,619
techniques whether UD p versus tcp/ip

00:06:49,089 --> 00:06:53,500
and all that kind of stuff but the

00:06:50,619 --> 00:06:55,970
protocol itself hasn't changed that much

00:06:53,500 --> 00:06:58,610
so basically people sing you know why

00:06:55,970 --> 00:06:59,870
does it really matter well our team p

00:06:58,610 --> 00:07:01,790
was originally invented to deal with

00:06:59,870 --> 00:07:03,320
network congestion I mean most people

00:07:01,790 --> 00:07:05,419
here remember you know dial-up modem

00:07:03,320 --> 00:07:07,340
days and stuff and so the problem with

00:07:05,419 --> 00:07:10,160
network congestion was you needed sort

00:07:07,340 --> 00:07:11,690
of a special protocol so to speak to

00:07:10,160 --> 00:07:13,550
actually handle when you've got

00:07:11,690 --> 00:07:15,680
congestion and in the adobe side it'll

00:07:13,550 --> 00:07:17,150
drop frames and adjust resolution and do

00:07:15,680 --> 00:07:21,250
all these other really cool things and

00:07:17,150 --> 00:07:21,250
the other point is we actually wanted oh

00:07:21,580 --> 00:07:26,449
I think you had a question already and

00:07:25,039 --> 00:07:28,460
the other plane is that we really wanted

00:07:26,449 --> 00:07:30,889
to use this ability to transmit encoded

00:07:28,460 --> 00:07:32,539
ActionScript objects between different

00:07:30,889 --> 00:07:35,449
instances of ganache the media server

00:07:32,539 --> 00:07:36,800
and back and that pretty much was a big

00:07:35,449 --> 00:07:39,440
enough motivation to go through which

00:07:36,800 --> 00:07:43,850
was about six months of reverse

00:07:39,440 --> 00:07:45,350
engineering so basically I guess a lot

00:07:43,850 --> 00:07:48,080
of people say you know why reverse

00:07:45,350 --> 00:07:49,310
engineer just use the adobe thing well

00:07:48,080 --> 00:07:52,520
that's not really a good option if your

00:07:49,310 --> 00:07:54,110
free software fanatic like myself um but

00:07:52,520 --> 00:07:55,610
in this case it's like you know reverse

00:07:54,110 --> 00:07:57,320
engineering is sometimes the only thing

00:07:55,610 --> 00:08:00,050
you can do to get access to stuff that

00:07:57,320 --> 00:08:01,580
you normally wouldn't and sometimes that

00:08:00,050 --> 00:08:03,320
access is important I mean the first

00:08:01,580 --> 00:08:05,660
time I showed somebody that I could do

00:08:03,320 --> 00:08:08,960
YouTube video on their Sony Playstation

00:08:05,660 --> 00:08:10,310
on a PowerPC they were blown away and so

00:08:08,960 --> 00:08:11,870
it's kind of nice to give people access

00:08:10,310 --> 00:08:14,150
to do things that they normally couldn't

00:08:11,870 --> 00:08:15,440
it's also really important to follow

00:08:14,150 --> 00:08:17,539
clean room procedures when reverse

00:08:15,440 --> 00:08:20,810
engineering you know we've tried really

00:08:17,539 --> 00:08:22,520
hard not to wind up like FF MP ffmpeg

00:08:20,810 --> 00:08:24,380
project where they've done some really

00:08:22,520 --> 00:08:25,729
nice reverse engineering but because of

00:08:24,380 --> 00:08:27,530
all the legal concerns nobody will

00:08:25,729 --> 00:08:29,810
actually ship it which doesn't do much

00:08:27,530 --> 00:08:32,180
fun either and some of us actually like

00:08:29,810 --> 00:08:33,860
reverse engineering it's a bit like you

00:08:32,180 --> 00:08:35,270
know playing 3d chess and klingon or

00:08:33,860 --> 00:08:38,839
something it's just kind of fun once you

00:08:35,270 --> 00:08:40,250
get the hang of it so the number one

00:08:38,839 --> 00:08:41,719
thing when you're basically about to

00:08:40,250 --> 00:08:43,400
launch off on spending months and months

00:08:41,719 --> 00:08:45,260
and months staring at heck stumps is

00:08:43,400 --> 00:08:47,390
that if you stare at the heck's thumbs

00:08:45,260 --> 00:08:49,670
long enough it actually does make sense

00:08:47,390 --> 00:08:51,170
it's just basically keeping your sanity

00:08:49,670 --> 00:08:55,160
until you actually get to the point

00:08:51,170 --> 00:08:57,050
where it makes sense so a couple of

00:08:55,160 --> 00:08:58,850
generic tricks I find I spent a lot of

00:08:57,050 --> 00:09:00,260
time packet sniffing which is kind of

00:08:58,850 --> 00:09:03,170
you know how you get your raw material

00:09:00,260 --> 00:09:04,640
one of the things I found is use really

00:09:03,170 --> 00:09:05,370
large sizes when you're capturing

00:09:04,640 --> 00:09:07,050
packets

00:09:05,370 --> 00:09:08,880
a lot of times if you have a big enough

00:09:07,050 --> 00:09:12,570
size you'll get most of the entire

00:09:08,880 --> 00:09:14,070
message in one packet in your teeth you

00:09:12,570 --> 00:09:15,540
know and you're sniffing tools and stuff

00:09:14,070 --> 00:09:17,400
and that makes a lot easier to figure

00:09:15,540 --> 00:09:18,690
out where things are like packet size

00:09:17,400 --> 00:09:20,250
fields for instance if you don't have

00:09:18,690 --> 00:09:22,050
the whole packet you can't tell which

00:09:20,250 --> 00:09:24,390
fields the packet size because you don't

00:09:22,050 --> 00:09:26,790
get the right byte count another thing

00:09:24,390 --> 00:09:29,279
is that a lot of protocols have a lot of

00:09:26,790 --> 00:09:31,650
ASCII strings embedded I know rtmp does

00:09:29,279 --> 00:09:33,240
and so a lot of times just finding all

00:09:31,650 --> 00:09:35,010
the ASCII strings and getting them out

00:09:33,240 --> 00:09:36,620
of the way first actually makes all the

00:09:35,010 --> 00:09:38,850
other stuff look a lot less

00:09:36,620 --> 00:09:41,220
overwhelmingly complex and all have some

00:09:38,850 --> 00:09:43,170
examples of that too the other thing is

00:09:41,220 --> 00:09:44,820
you have to expect the right and throw

00:09:43,170 --> 00:09:46,290
away a lot of code when reverse

00:09:44,820 --> 00:09:48,150
engineering you're basically just

00:09:46,290 --> 00:09:49,890
guessing and a lot of times you're just

00:09:48,150 --> 00:09:51,839
not really sure if you've guessed right

00:09:49,890 --> 00:09:53,670
so I'm a big believer in writing a lot

00:09:51,839 --> 00:09:55,920
of little standalone utilities to do

00:09:53,670 --> 00:09:57,060
things and you have to expect to throw

00:09:55,920 --> 00:09:58,620
it away you can't assume you're going to

00:09:57,060 --> 00:10:00,240
get it right the first time the second

00:09:58,620 --> 00:10:02,220
time the third time or the fourth time

00:10:00,240 --> 00:10:04,140
even sometimes but if you really want to

00:10:02,220 --> 00:10:05,430
accomplish what you're doing you just

00:10:04,140 --> 00:10:07,410
have to deal with it right to code see

00:10:05,430 --> 00:10:09,660
what works go I got that wrong throw it

00:10:07,410 --> 00:10:12,240
out and start on something else I also

00:10:09,660 --> 00:10:14,100
find that a really relaxed load to strip

00:10:12,240 --> 00:10:16,260
distracted work environment is important

00:10:14,100 --> 00:10:18,029
I mean I get to work at home so I have

00:10:16,260 --> 00:10:19,529
it pretty easy but I don't I get a lot

00:10:18,029 --> 00:10:21,600
of work done and make a pot of tea turn

00:10:19,529 --> 00:10:22,800
up the stereo really loud start staring

00:10:21,600 --> 00:10:26,130
at head stumped it's a great way to

00:10:22,800 --> 00:10:28,830
spend a rainy afternoon um the other

00:10:26,130 --> 00:10:30,540
part is as I mentioned before if you

00:10:28,830 --> 00:10:32,370
stare at the hex long enough you really

00:10:30,540 --> 00:10:33,870
do get to see the patterns I mean I've

00:10:32,370 --> 00:10:36,020
spent time in the past working on

00:10:33,870 --> 00:10:38,520
artificial intelligence projects and

00:10:36,020 --> 00:10:40,529
people are so much better at looking for

00:10:38,520 --> 00:10:42,450
patterns and things you just can't often

00:10:40,529 --> 00:10:43,860
right enough code to analyze things

00:10:42,450 --> 00:10:45,450
automatically although you do a lot of

00:10:43,860 --> 00:10:48,270
that too and so a lot of times you

00:10:45,450 --> 00:10:49,800
stared at you know gigabytes and

00:10:48,270 --> 00:10:51,870
gigabytes a hex dumps and you said to go

00:10:49,800 --> 00:10:53,459
wait a minute every you know iteration I

00:10:51,870 --> 00:10:55,529
see this thing I wonder if that's

00:10:53,459 --> 00:10:58,080
important and sometimes it is no it

00:10:55,529 --> 00:10:59,190
wasn't rtmp and the other thing is it's

00:10:58,080 --> 00:11:01,740
really hard to get started the first

00:10:59,190 --> 00:11:04,080
couple days I find on any big reverse

00:11:01,740 --> 00:11:05,910
engineering project you're about two

00:11:04,080 --> 00:11:07,680
days end oh and you go oh my god what am

00:11:05,910 --> 00:11:10,110
i doing I mean this is going to eat my

00:11:07,680 --> 00:11:13,290
lunch for six months which is at best

00:11:10,110 --> 00:11:15,900
six months um there's a lot of different

00:11:13,290 --> 00:11:17,250
common functionality um I basically have

00:11:15,900 --> 00:11:19,290
to say most protocols because there's

00:11:17,250 --> 00:11:21,120
always things to break the exceptions

00:11:19,290 --> 00:11:23,220
actually reverse engineered probably I

00:11:21,120 --> 00:11:26,040
guess two dozen network protocols in the

00:11:23,220 --> 00:11:28,709
last 30 years and so there's a couple of

00:11:26,040 --> 00:11:30,149
basic things I like to look for mostly

00:11:28,709 --> 00:11:31,560
just to get me started when I'm trying

00:11:30,149 --> 00:11:33,600
to stare at hex and figure out what's

00:11:31,560 --> 00:11:35,779
going on so this will probably sound

00:11:33,600 --> 00:11:38,399
obvious but most protocols have a header

00:11:35,779 --> 00:11:40,829
not always though but but most of them

00:11:38,399 --> 00:11:42,240
often do and sometimes things that look

00:11:40,829 --> 00:11:43,920
like they don't have a header have a

00:11:42,240 --> 00:11:45,089
header like maybe the first packet and

00:11:43,920 --> 00:11:47,279
then after that it's like streaming

00:11:45,089 --> 00:11:49,139
video so to speak and it's just raw data

00:11:47,279 --> 00:11:51,329
so first you have to really find the

00:11:49,139 --> 00:11:53,160
header that's kind of the big deal um

00:11:51,329 --> 00:11:55,500
most headers that I've ever worked on

00:11:53,160 --> 00:11:56,910
have a length field for fields I mean

00:11:55,500 --> 00:11:59,670
it's really simple for ASCII strings

00:11:56,910 --> 00:12:01,199
it'll say you know 12 inference and then

00:11:59,670 --> 00:12:03,060
you have 12 characters and stuff like

00:12:01,199 --> 00:12:05,160
that and so that's usually the other

00:12:03,060 --> 00:12:07,889
first thing you start looking for is you

00:12:05,160 --> 00:12:09,839
start looking for the counters I'm a lot

00:12:07,889 --> 00:12:11,130
of header protocols have another field

00:12:09,839 --> 00:12:12,389
that's the size of the packet for

00:12:11,130 --> 00:12:14,370
instance that's why I like using big

00:12:12,389 --> 00:12:16,290
packet sizes because if I've got a big

00:12:14,370 --> 00:12:17,880
packet size I can write a quick program

00:12:16,290 --> 00:12:19,709
to calculate everything and give me a

00:12:17,880 --> 00:12:21,180
quick check some and i can get and

00:12:19,709 --> 00:12:23,040
compare that with some of the stuff that

00:12:21,180 --> 00:12:24,870
i think might be the header and i might

00:12:23,040 --> 00:12:26,910
say oh this packets got 300 characters

00:12:24,870 --> 00:12:28,709
in it oh look there's a 300 here this

00:12:26,910 --> 00:12:30,449
must be you know before the data that

00:12:28,709 --> 00:12:32,459
must be the length field because a lot

00:12:30,449 --> 00:12:34,380
of this is is you have to eliminate the

00:12:32,459 --> 00:12:37,410
stuff that you can find easy to spend

00:12:34,380 --> 00:12:39,449
time on the earlier harder stuff most

00:12:37,410 --> 00:12:41,490
protocols have a checksum rtmp is not

00:12:39,449 --> 00:12:43,560
one of them they don't care which is

00:12:41,490 --> 00:12:45,180
probably why it's junk and the other

00:12:43,560 --> 00:12:46,829
thing is a lot of network protocols on

00:12:45,180 --> 00:12:48,959
all the numbers are in big inning for

00:12:46,829 --> 00:12:50,490
Matt in a network byte order and

00:12:48,959 --> 00:12:52,380
although Adobe breaks us it turns out

00:12:50,490 --> 00:12:54,060
with rtmp some of the fields they do a

00:12:52,380 --> 00:12:55,769
little endian instead of just beginning

00:12:54,060 --> 00:12:57,540
but most of the time when you're looking

00:12:55,769 --> 00:12:58,529
at numbers you don't recognize them

00:12:57,540 --> 00:13:00,870
because you're looking at you know a

00:12:58,529 --> 00:13:06,060
double in big endian so you get to learn

00:13:00,870 --> 00:13:07,470
that you know 03 f 03 is a 1 so but it's

00:13:06,060 --> 00:13:09,329
what I actually do for that is I print

00:13:07,470 --> 00:13:11,910
out a big chart of all the numbers 1 to

00:13:09,329 --> 00:13:15,360
100 basically in big Indian format so i

00:13:11,910 --> 00:13:17,069
can go oh yeah that's what that is the

00:13:15,360 --> 00:13:19,380
other part is how to stay legal reverse

00:13:17,069 --> 00:13:21,480
engineering specifically in my country

00:13:19,380 --> 00:13:24,329
unfortunately is highly discouraged and

00:13:21,480 --> 00:13:26,100
borderline legal so the easy thing to

00:13:24,329 --> 00:13:28,410
avoid on is don't disassemble

00:13:26,100 --> 00:13:29,519
executables I mean that's tacky anyway

00:13:28,410 --> 00:13:30,980
and it's cheating it takes all the fun

00:13:29,519 --> 00:13:33,949
out of it um

00:13:30,980 --> 00:13:36,410
I mean well I know when we started on

00:13:33,949 --> 00:13:38,060
ganache we basically I mean you know

00:13:36,410 --> 00:13:39,829
it's a flash player has opcode that has

00:13:38,060 --> 00:13:41,420
function calls that has a stack who

00:13:39,829 --> 00:13:43,970
needs a little reverse engineer the

00:13:41,420 --> 00:13:45,649
Adobe's player and get it all wrong the

00:13:43,970 --> 00:13:47,839
other big point it's also important is

00:13:45,649 --> 00:13:50,120
that if you use proprietary software you

00:13:47,839 --> 00:13:52,970
must have legal copies this is very

00:13:50,120 --> 00:13:54,500
interesting because for rtmp the license

00:13:52,970 --> 00:13:56,060
forbids me from actually working on an

00:13:54,500 --> 00:13:58,459
implementation if I've ever installed

00:13:56,060 --> 00:13:59,899
any Adobe software so thank God I have

00:13:58,459 --> 00:14:02,990
college age kids who run the adobe

00:13:59,899 --> 00:14:04,610
player but that's actually important is

00:14:02,990 --> 00:14:05,990
if you actually do all this work you

00:14:04,610 --> 00:14:08,149
want to be able to redistribute it and

00:14:05,990 --> 00:14:10,100
if you can't redistribute your your

00:14:08,149 --> 00:14:12,170
reverse engineering work at that point

00:14:10,100 --> 00:14:13,850
it's sort of like why bother my other

00:14:12,170 --> 00:14:15,829
advices thought the real lawyers I

00:14:13,850 --> 00:14:17,329
talked to so many people that think

00:14:15,829 --> 00:14:19,519
they're legally minded especially when

00:14:17,329 --> 00:14:21,529
it comes to issues like dmca violations

00:14:19,519 --> 00:14:23,810
and stuff and talk to a real lawyer they

00:14:21,529 --> 00:14:25,820
actually and I they tell you how lawyers

00:14:23,810 --> 00:14:27,199
think and engineers can't read legal

00:14:25,820 --> 00:14:30,800
documents and makes sense because none

00:14:27,199 --> 00:14:31,760
of that stuff is a sensible um less I

00:14:30,800 --> 00:14:33,500
quit you know I know about you guys but

00:14:31,760 --> 00:14:35,569
if I rate a patent application I see it

00:14:33,500 --> 00:14:36,980
very literally and while you're see it

00:14:35,569 --> 00:14:38,120
the way lawyers do it which is actually

00:14:36,980 --> 00:14:40,010
how you're going to you know have to

00:14:38,120 --> 00:14:41,510
deal with it not how we see it on a

00:14:40,010 --> 00:14:43,459
common thing that we haven't had to do

00:14:41,510 --> 00:14:45,500
with the ganache project but another way

00:14:43,459 --> 00:14:47,750
is that a lot of typical clean room is

00:14:45,500 --> 00:14:49,190
one person writes a specification and

00:14:47,750 --> 00:14:51,620
then somebody else actually writes to

00:14:49,190 --> 00:14:54,649
code and the idea being that whoever

00:14:51,620 --> 00:14:57,470
wrote the spec is doing a lot of strange

00:14:54,649 --> 00:14:59,089
things but typically then that by having

00:14:57,470 --> 00:15:00,829
a separation from the people actually

00:14:59,089 --> 00:15:02,600
implementing it you're just doing a work

00:15:00,829 --> 00:15:04,699
alight product instead of cloning a

00:15:02,600 --> 00:15:05,959
project and a lot of various projects

00:15:04,699 --> 00:15:07,940
have done this in the past I mean some

00:15:05,959 --> 00:15:09,440
of the original phoenix bios stuff they

00:15:07,940 --> 00:15:11,269
put everybody in a hotel room for six

00:15:09,440 --> 00:15:13,910
months to write specs then they gave it

00:15:11,269 --> 00:15:15,230
to developers to actually write and then

00:15:13,910 --> 00:15:18,380
i guess the last thing is don't live in

00:15:15,230 --> 00:15:20,389
the united states unfortunately I do so

00:15:18,380 --> 00:15:23,630
I'm extra extra careful but I live in a

00:15:20,389 --> 00:15:25,130
good part of it so um there's a lot of

00:15:23,630 --> 00:15:27,589
different capture tools I think

00:15:25,130 --> 00:15:29,839
everybody has different things that they

00:15:27,589 --> 00:15:33,410
prefer I'm sort of a dinosaur so I'd

00:15:29,839 --> 00:15:35,180
like a TC TCP dump on TCP dump works

00:15:33,410 --> 00:15:36,680
really good for me it got a lot of

00:15:35,180 --> 00:15:38,540
different formats and things like that

00:15:36,680 --> 00:15:41,600
so I actually probably use that as my

00:15:38,540 --> 00:15:43,600
primary tool n grep is another one I got

00:15:41,600 --> 00:15:45,490
turned on to last year and

00:15:43,600 --> 00:15:47,829
kind of greps a network connection and

00:15:45,490 --> 00:15:50,829
although it's very similar to TCP dump

00:15:47,829 --> 00:15:53,829
with a slightly better user interface

00:15:50,829 --> 00:15:56,170
for a command-line tool it sometimes is

00:15:53,829 --> 00:15:57,819
very useful I've also found that having

00:15:56,170 --> 00:16:00,220
multiple tools and how they display

00:15:57,819 --> 00:16:02,050
things differently helps me see the

00:16:00,220 --> 00:16:04,060
patterns that may exist sometimes things

00:16:02,050 --> 00:16:06,040
look better in octal and hex sometimes

00:16:04,060 --> 00:16:08,139
the way different sniffing tolls display

00:16:06,040 --> 00:16:09,940
data you go oh that's what that's really

00:16:08,139 --> 00:16:12,250
doing and so I kind of suggests using

00:16:09,940 --> 00:16:15,220
multiple tools no the other fun one is

00:16:12,250 --> 00:16:17,889
Wireshark in the case of rtmp Wireshark

00:16:15,220 --> 00:16:18,970
had no rtmp support it does now but they

00:16:17,889 --> 00:16:20,889
had to wait till we figured it out

00:16:18,970 --> 00:16:22,389
before they could add support for it but

00:16:20,889 --> 00:16:24,579
it's actually really good for sniffing

00:16:22,389 --> 00:16:26,649
on even a protocol that you don't you

00:16:24,579 --> 00:16:29,100
know it understand it's really nice that

00:16:26,649 --> 00:16:31,149
you can pick things by port number and

00:16:29,100 --> 00:16:32,920
destination source and a lot of other

00:16:31,149 --> 00:16:35,550
stuff and so I actually use wireshark a

00:16:32,920 --> 00:16:37,420
lot for just capturing raw binary dumps

00:16:35,550 --> 00:16:39,790
it's pretty useful and now that they

00:16:37,420 --> 00:16:40,930
have rtmp support we basically get to

00:16:39,790 --> 00:16:43,180
check each other's work all the time

00:16:40,930 --> 00:16:44,500
which is kind of amusing I spent six

00:16:43,180 --> 00:16:46,360
months figuring it out and they had an

00:16:44,500 --> 00:16:51,370
added to Wireshark in a week it was

00:16:46,360 --> 00:16:52,839
crazy other display tolls I use OD I bet

00:16:51,370 --> 00:16:57,579
most people have never even heard of OD

00:16:52,839 --> 00:16:59,529
utility nothing whatever works but but

00:16:57,579 --> 00:17:01,300
otay is actually also nice because it

00:16:59,529 --> 00:17:03,189
lets me as I say display dad and a lot

00:17:01,300 --> 00:17:06,760
of different ways and sometimes I like

00:17:03,189 --> 00:17:09,010
having things in a terminal window gdb

00:17:06,760 --> 00:17:10,120
believe it or not gdb is very useful

00:17:09,010 --> 00:17:11,770
when you're writing your little test

00:17:10,120 --> 00:17:14,140
code you've got your you know your

00:17:11,770 --> 00:17:16,240
example that you're trying to implement

00:17:14,140 --> 00:17:18,669
your how you think some protocol thing

00:17:16,240 --> 00:17:19,990
has worked a lot of times in gdb you

00:17:18,669 --> 00:17:21,130
know you'll jump into it and you'll say

00:17:19,990 --> 00:17:22,780
you know what would happen if this

00:17:21,130 --> 00:17:24,220
number is an offset and you can do like

00:17:22,780 --> 00:17:26,470
you know do simple pointer arithmetic

00:17:24,220 --> 00:17:28,780
and display the data in a buffer that

00:17:26,470 --> 00:17:31,450
might be a network packet and I'd find

00:17:28,780 --> 00:17:33,460
gdb actually pretty useful um because

00:17:31,450 --> 00:17:36,220
I'd like gdb most people don't put home

00:17:33,460 --> 00:17:38,140
it's another story and grap again and of

00:17:36,220 --> 00:17:42,789
course TCP dump on both of these do a

00:17:38,140 --> 00:17:44,289
lot of different outputs I don't find

00:17:42,789 --> 00:17:45,820
myself editing hex that much but

00:17:44,289 --> 00:17:47,860
sometimes you do sometimes when you

00:17:45,820 --> 00:17:49,480
think you know what's doing something is

00:17:47,860 --> 00:17:50,890
doing you want to change it like if you

00:17:49,480 --> 00:17:52,210
have a byte count for string you might

00:17:50,890 --> 00:17:53,500
say well I'm going to add a character

00:17:52,210 --> 00:17:55,570
and then change the length and see if I

00:17:53,500 --> 00:17:56,800
broke anything so when I actually have

00:17:55,570 --> 00:17:58,810
to edit hex

00:17:56,800 --> 00:18:00,460
I use G hexed oh it's probably one of

00:17:58,810 --> 00:18:02,950
the only go ease i actually use all the

00:18:00,460 --> 00:18:05,140
time and it's pretty useful for that um

00:18:02,950 --> 00:18:08,050
emacs i believe it or not i use emacs

00:18:05,140 --> 00:18:09,670
for editing binary files a lot you can

00:18:08,050 --> 00:18:11,680
do a lot of things in Emacs funny enough

00:18:09,670 --> 00:18:13,540
even edits software I've been told but

00:18:11,680 --> 00:18:17,140
it's pretty good for binary dumps and

00:18:13,540 --> 00:18:19,120
other things then you can use vim it's a

00:18:17,140 --> 00:18:20,710
little more painful and there's a man

00:18:19,120 --> 00:18:23,890
there's so many different editing tools

00:18:20,710 --> 00:18:25,900
for hex BVI beef crisp there's a whole

00:18:23,890 --> 00:18:27,790
bunch of them out there I think it's

00:18:25,900 --> 00:18:31,450
pretty easy to write an editor so

00:18:27,790 --> 00:18:33,010
basically uh Gee hex to this is more or

00:18:31,450 --> 00:18:34,690
less what it looks like you know I tried

00:18:33,010 --> 00:18:37,660
to use the same packet here this is

00:18:34,690 --> 00:18:40,560
actually an encoded object basically and

00:18:37,660 --> 00:18:42,460
says hello world of course it's a string

00:18:40,560 --> 00:18:44,020
G hex is kind of nice because you can

00:18:42,460 --> 00:18:48,550
get all your offsets and do a little bit

00:18:44,020 --> 00:18:51,460
switch the encoding Emacs binary binary

00:18:48,550 --> 00:18:53,170
mode actually works pretty well I use

00:18:51,460 --> 00:18:57,640
this pretty often actually it's under

00:18:53,170 --> 00:18:59,530
know it's kind of useful Jeevan doesn't

00:18:57,640 --> 00:19:01,390
work quite as well but if you're a big

00:18:59,530 --> 00:19:02,860
VI fanatic you can actually edit binary

00:19:01,390 --> 00:19:05,050
files with VI instead of having to learn

00:19:02,860 --> 00:19:06,700
some other new toll I find this the

00:19:05,050 --> 00:19:10,990
least useful but some people actually

00:19:06,700 --> 00:19:13,170
tell me they really like this mode which

00:19:10,990 --> 00:19:13,170
one

00:19:15,490 --> 00:19:21,650
okay yeah I mean sometimes more tools is

00:19:18,620 --> 00:19:23,930
always good I actually did this one a

00:19:21,650 --> 00:19:25,550
lot silly editor tricks um a lot of

00:19:23,930 --> 00:19:27,950
times I'll take a hex dump like like

00:19:25,550 --> 00:19:30,320
from G hex for instance display it put

00:19:27,950 --> 00:19:31,760
it into a scratch buffer of Emacs or in

00:19:30,320 --> 00:19:33,680
this case open office so I could do

00:19:31,760 --> 00:19:35,390
color and a lot of times just put

00:19:33,680 --> 00:19:37,550
carriage returns between where all the

00:19:35,390 --> 00:19:39,680
fields end sometimes makes things a lot

00:19:37,550 --> 00:19:42,740
more sensible I mean if this echo hello

00:19:39,680 --> 00:19:43,820
world thing was kind of hell that slide

00:19:42,740 --> 00:19:45,200
was it's a little hard to figure out

00:19:43,820 --> 00:19:47,120
what it does if you don't have the text

00:19:45,200 --> 00:19:48,650
on the side and so here I've got it all

00:19:47,120 --> 00:19:50,060
broken down into the different fields

00:19:48,650 --> 00:19:51,470
for all the strings and you can sort of

00:19:50,060 --> 00:19:54,080
see how there's bite counts and other

00:19:51,470 --> 00:19:56,090
things like that in it and I did this a

00:19:54,080 --> 00:19:59,750
lot i spent a lot of time just hacking

00:19:56,090 --> 00:20:01,970
it up things so TCP dumps got a huge

00:19:59,750 --> 00:20:03,500
wealth of options these are the main

00:20:01,970 --> 00:20:08,180
ones that I use of course which device

00:20:03,500 --> 00:20:09,560
the port X which mix is asking in hex at

00:20:08,180 --> 00:20:11,210
the same time is very useful because

00:20:09,560 --> 00:20:12,950
rather than looking for all the heck

00:20:11,210 --> 00:20:14,450
stuff later you can sort of see it in

00:20:12,950 --> 00:20:16,940
the dump and go oh that's what that is

00:20:14,450 --> 00:20:20,570
and it said dash X for max size big

00:20:16,940 --> 00:20:23,090
packet sizes are always good more or

00:20:20,570 --> 00:20:25,520
less this is what PCP dump looks like

00:20:23,090 --> 00:20:27,650
pretty boring this is an HTTP message

00:20:25,520 --> 00:20:29,360
just there'd be more text to show things

00:20:27,650 --> 00:20:30,470
that were interesting and you can see

00:20:29,360 --> 00:20:32,180
that if you're just looking at the hex

00:20:30,470 --> 00:20:33,920
this looks like a mess but with the

00:20:32,180 --> 00:20:35,870
ascii on this side you can quickly go oh

00:20:33,920 --> 00:20:37,640
I know what this is this is just then

00:20:35,870 --> 00:20:41,510
you know fancy you know get requests

00:20:37,640 --> 00:20:44,710
from my web browser basically and grep

00:20:41,510 --> 00:20:47,540
is actually got very similar options to

00:20:44,710 --> 00:20:49,460
TCP dump they change like the device

00:20:47,540 --> 00:20:52,220
options silly things like that but a lot

00:20:49,460 --> 00:20:54,590
of the other options are the same an N

00:20:52,220 --> 00:20:56,270
grep looks more like this a lot of the

00:20:54,590 --> 00:20:58,400
outputs cleaned up it's a little bit

00:20:56,270 --> 00:21:00,380
easier to read sometimes in TCP dump and

00:20:58,400 --> 00:21:03,470
stuff and this is actually a decoded

00:21:00,380 --> 00:21:04,970
rtmp packet right here this is what you

00:21:03,470 --> 00:21:06,770
can see here you can see because it has

00:21:04,970 --> 00:21:08,900
a lot of text in it this isn't the

00:21:06,770 --> 00:21:13,820
result message from connecting the

00:21:08,900 --> 00:21:15,590
network connection to the server side OD

00:21:13,820 --> 00:21:17,860
has got a bunch of different options

00:21:15,590 --> 00:21:20,990
maybe not as much as TCP dump or in grep

00:21:17,860 --> 00:21:22,670
dash a 4-2 address I actually pass none

00:21:20,990 --> 00:21:24,770
all the time get rid of addressing

00:21:22,670 --> 00:21:25,970
because half the time I don't care and

00:21:24,770 --> 00:21:27,840
then you can change a bunch of different

00:21:25,970 --> 00:21:30,090
sized things and their wits and stuff

00:21:27,840 --> 00:21:31,289
and I'm already its kind of still useful

00:21:30,090 --> 00:21:33,690
but i probably don't use it as much as

00:21:31,289 --> 00:21:35,789
the other tools there's a couple of

00:21:33,690 --> 00:21:38,370
varieties of you know different OD type

00:21:35,789 --> 00:21:40,260
output I think my main use of OD is

00:21:38,370 --> 00:21:41,700
actually for doing test cases I can take

00:21:40,260 --> 00:21:43,110
for instance that last line there and

00:21:41,700 --> 00:21:44,820
cut it and paste it into a test case and

00:21:43,110 --> 00:21:48,840
and it's a lot easier than trying to

00:21:44,820 --> 00:21:50,610
pull it out in G hex or whatever and of

00:21:48,840 --> 00:21:52,049
course Wireshark if you really like the

00:21:50,610 --> 00:21:54,270
GUI world and stuff I'm kind of a

00:21:52,049 --> 00:21:55,950
command-line guy but Wireshark is

00:21:54,270 --> 00:21:57,330
actually pretty nice little tool I've

00:21:55,950 --> 00:22:00,929
been using it more and more lately and

00:21:57,330 --> 00:22:03,120
kind of gotten used to it um one quick

00:22:00,929 --> 00:22:04,799
example the gdb basically you know as I

00:22:03,120 --> 00:22:06,960
said once you're you know you've got a

00:22:04,799 --> 00:22:08,850
packet your read from the network in gdb

00:22:06,960 --> 00:22:10,110
in a memory you can do all sorts of

00:22:08,850 --> 00:22:12,270
different things to it in this case just

00:22:10,110 --> 00:22:14,610
dumping in Israel hex you can dump the

00:22:12,270 --> 00:22:16,289
characters out you can do an amazing

00:22:14,610 --> 00:22:17,850
amount of stuff i mean gdb is like Emacs

00:22:16,289 --> 00:22:19,110
it can pretty much do everything but you

00:22:17,850 --> 00:22:21,600
know walk the dog and get you a beer

00:22:19,110 --> 00:22:23,429
from refrigerator and i did this an

00:22:21,600 --> 00:22:24,600
awful lot to with my test code that's

00:22:23,429 --> 00:22:27,149
sort of experimenting with things

00:22:24,600 --> 00:22:31,590
changing values and things stuff like

00:22:27,149 --> 00:22:34,110
that so basically this is what an

00:22:31,590 --> 00:22:35,640
initial rtmp header would look like this

00:22:34,110 --> 00:22:37,950
talks not going to get into the details

00:22:35,640 --> 00:22:39,750
of rtmp as much although i can answer

00:22:37,950 --> 00:22:41,159
some questions on it but this is kind of

00:22:39,750 --> 00:22:44,159
the first thing i had to figure out was

00:22:41,159 --> 00:22:45,649
the header of all the data and in the

00:22:44,159 --> 00:22:47,490
rtmp world it turned out to be pretty

00:22:45,649 --> 00:22:49,860
complicated because they're really in

00:22:47,490 --> 00:22:52,740
the bit fields I mean bit fields and

00:22:49,860 --> 00:22:53,909
headers are kind of evil but it made it

00:22:52,740 --> 00:22:55,620
a lot more complicated to figure out

00:22:53,909 --> 00:22:58,830
what's going on so for instance this

00:22:55,620 --> 00:23:00,120
first one here is there's there's the

00:22:58,830 --> 00:23:03,090
first two bits are the size of the

00:23:00,120 --> 00:23:04,980
header they have four by eight byte and

00:23:03,090 --> 00:23:06,480
twelve bite headers and so the first two

00:23:04,980 --> 00:23:08,070
bits determine what size the rest of the

00:23:06,480 --> 00:23:09,929
header of this was a pain to figure out

00:23:08,070 --> 00:23:12,809
and then followed by what's called a

00:23:09,929 --> 00:23:15,149
channel number rtmp supports 64 channels

00:23:12,809 --> 00:23:16,529
in a single network connection it's like

00:23:15,149 --> 00:23:18,419
if you're doing video conferencing and

00:23:16,529 --> 00:23:20,399
you had four windows open each of those

00:23:18,419 --> 00:23:22,230
would be a separate channel and all the

00:23:20,399 --> 00:23:24,000
messages are multiplexed and partial

00:23:22,230 --> 00:23:25,649
transmission this is also a pain to

00:23:24,000 --> 00:23:27,090
figure out once I figured out it was

00:23:25,649 --> 00:23:30,120
easy but you know the first bits always

00:23:27,090 --> 00:23:32,730
really hard all messages in rtmp have a

00:23:30,120 --> 00:23:34,980
timestamp basically the timestamp they

00:23:32,730 --> 00:23:36,390
use for keeping audio and video

00:23:34,980 --> 00:23:38,220
synchronized because your audio and

00:23:36,390 --> 00:23:39,990
video packets are showing up differently

00:23:38,220 --> 00:23:41,590
and interweave together and then on the

00:23:39,990 --> 00:23:43,240
flash player side you

00:23:41,590 --> 00:23:44,590
to then look at the time stamps when you

00:23:43,240 --> 00:23:46,960
figure out how to display things and

00:23:44,590 --> 00:23:48,549
they keep it synchronized they also use

00:23:46,960 --> 00:23:51,400
this time stamp in a lot of different

00:23:48,549 --> 00:23:53,440
ways with rtmp that's how they detect

00:23:51,400 --> 00:23:55,240
network congestion when the time stamps

00:23:53,440 --> 00:23:56,620
start changing and there's a lot too

00:23:55,240 --> 00:23:57,970
much drift in between them then they

00:23:56,620 --> 00:24:01,720
realize that there's congestion and they

00:23:57,970 --> 00:24:03,669
drop frames or whatever else then

00:24:01,720 --> 00:24:05,860
there's also in this case is the size of

00:24:03,669 --> 00:24:07,990
the message as I had said before most

00:24:05,860 --> 00:24:10,029
headers actually have a size of the

00:24:07,990 --> 00:24:13,690
whole packet so and in this case they

00:24:10,029 --> 00:24:15,220
use a short or an integer often for this

00:24:13,690 --> 00:24:16,720
so that's just the size of the whole

00:24:15,220 --> 00:24:18,520
packet so when you've you know sniffed a

00:24:16,720 --> 00:24:20,110
big number that was pretty easy to find

00:24:18,520 --> 00:24:21,700
it's like oh this I wrote a program that

00:24:20,110 --> 00:24:23,500
basically added up everything and it's

00:24:21,700 --> 00:24:24,970
just going backwards until it found the

00:24:23,500 --> 00:24:26,799
number that was the size of the bikes

00:24:24,970 --> 00:24:31,240
that had just read pretty simple but

00:24:26,799 --> 00:24:33,429
effective also rtmp supports about 17

00:24:31,240 --> 00:24:35,620
different data types each one a

00:24:33,429 --> 00:24:37,179
particular type of ActionScript object

00:24:35,620 --> 00:24:39,669
and so in this case this is what's

00:24:37,179 --> 00:24:41,770
called a 14 which is a remote invocation

00:24:39,669 --> 00:24:44,320
call so basically you can actually load

00:24:41,770 --> 00:24:46,210
executable code on the media server and

00:24:44,320 --> 00:24:48,370
then the remote calls on all the methods

00:24:46,210 --> 00:24:51,250
of that object which is the whole point

00:24:48,370 --> 00:24:53,020
of doing rtmp on does another feel they

00:24:51,250 --> 00:24:54,100
call source but it's kind of funny it

00:24:53,020 --> 00:24:55,330
just says whether the message has come

00:24:54,100 --> 00:24:57,250
from the server or whether it's come

00:24:55,330 --> 00:24:58,720
from the client got me why they even

00:24:57,250 --> 00:25:02,110
bothered to waste all those bites but

00:24:58,720 --> 00:25:04,600
they did so here's a little bit more on

00:25:02,110 --> 00:25:06,309
the rtmp headers they also have this

00:25:04,600 --> 00:25:08,890
thing they call a continuation packet

00:25:06,309 --> 00:25:14,169
most of the packets it turns out an rtmp

00:25:08,890 --> 00:25:16,059
we're limited to 128 bytes and but often

00:25:14,169 --> 00:25:18,340
you know a video or some object is way

00:25:16,059 --> 00:25:19,870
more than 128 bytes so they have this

00:25:18,340 --> 00:25:21,520
thing where they'll send you a 12 bite

00:25:19,870 --> 00:25:23,200
header and then all the following

00:25:21,520 --> 00:25:26,260
messages to complete the size of the

00:25:23,200 --> 00:25:28,029
data packet are actually um one byte

00:25:26,260 --> 00:25:30,520
headers using the same channel number

00:25:28,029 --> 00:25:32,320
and a different the different bit field

00:25:30,520 --> 00:25:33,549
for the one byte header this is a real

00:25:32,320 --> 00:25:34,870
pain in the neck because somebody the

00:25:33,549 --> 00:25:36,070
header size change and you're said

00:25:34,870 --> 00:25:38,140
you've got you know multiple channels

00:25:36,070 --> 00:25:42,130
the data in the same X bumps it was

00:25:38,140 --> 00:25:45,549
pretty brutal amf you'll see a lot of a

00:25:42,130 --> 00:25:47,830
MF is sort of the encoded ActionScript

00:25:45,549 --> 00:25:50,080
objects on an ActionScript object is

00:25:47,830 --> 00:25:51,760
like a date class and you can print out

00:25:50,080 --> 00:25:54,460
you know the date formatted in 20

00:25:51,760 --> 00:25:55,160
different ways or actually in flash they

00:25:54,460 --> 00:25:56,900
have a video

00:25:55,160 --> 00:25:58,970
class and then there's a microphone in a

00:25:56,900 --> 00:26:01,520
camera class and things like that and so

00:25:58,970 --> 00:26:03,470
a MF action script is based on ECMO

00:26:01,520 --> 00:26:05,750
script 262 which is the same

00:26:03,470 --> 00:26:07,790
specification as javascript is based on

00:26:05,750 --> 00:26:09,350
so that Adobe didn't really catch up

00:26:07,790 --> 00:26:12,410
with the spec until about six months ago

00:26:09,350 --> 00:26:14,390
only took them 15 years there's a new

00:26:12,410 --> 00:26:16,550
version they've got a MF 0 turns out not

00:26:14,390 --> 00:26:18,320
to be very compact for instance um

00:26:16,550 --> 00:26:20,540
they've got a channel number which can

00:26:18,320 --> 00:26:21,920
be one that's 64 but they use a double

00:26:20,540 --> 00:26:23,240
that eats up eight bytes to transmit

00:26:21,920 --> 00:26:25,880
channel numbers which is kind of stupid

00:26:23,240 --> 00:26:27,830
so an amf three they decided to try and

00:26:25,880 --> 00:26:30,230
improve things because uh flashes had

00:26:27,830 --> 00:26:32,150
big performance problems and Adobe Flash

00:26:30,230 --> 00:26:33,470
version 9 tried to fix a lot of these

00:26:32,150 --> 00:26:35,210
problems so they actually did things

00:26:33,470 --> 00:26:37,850
like added an integer type and a lot of

00:26:35,210 --> 00:26:40,070
stuff like that I haven't actually seen

00:26:37,850 --> 00:26:41,990
anybody using a MF three in the sort of

00:26:40,070 --> 00:26:44,480
Internet in the wild but it'll probably

00:26:41,990 --> 00:26:46,340
happen more and more so pretty much an

00:26:44,480 --> 00:26:48,110
amf packet you know more or less looks

00:26:46,340 --> 00:26:50,120
like this this is a pretty simple one

00:26:48,110 --> 00:26:53,030
it's got the tight field in blue on the

00:26:50,120 --> 00:26:57,920
one side then the length field and then

00:26:53,030 --> 00:26:59,510
the actual string um a lot of protocols

00:26:57,920 --> 00:27:01,340
actually don't do nawl terminators which

00:26:59,510 --> 00:27:02,450
most C programmers are used to so it's

00:27:01,340 --> 00:27:03,800
something to think about that you

00:27:02,450 --> 00:27:07,460
actually have to read the byte count you

00:27:03,800 --> 00:27:09,740
just can't read till you hit no um I'm

00:27:07,460 --> 00:27:11,300
big and testing testing is I think the

00:27:09,740 --> 00:27:13,460
number one way to stay sane in almost

00:27:11,300 --> 00:27:15,740
any software project and in this case

00:27:13,460 --> 00:27:17,060
you really need to because you have no

00:27:15,740 --> 00:27:19,490
way of knowing if your encoding or

00:27:17,060 --> 00:27:22,070
decoding correctly so I do a lot I mean

00:27:19,490 --> 00:27:24,470
I've probably got 4,000 test cases for

00:27:22,070 --> 00:27:26,180
rtmp stuff and most of those test cases

00:27:24,470 --> 00:27:27,680
aren't it's the only way I could get any

00:27:26,180 --> 00:27:29,870
work done especially because I can't run

00:27:27,680 --> 00:27:31,550
the adobe flash player so often my test

00:27:29,870 --> 00:27:33,920
cases are the only ways where I can

00:27:31,550 --> 00:27:35,420
continue munching through encoding and

00:27:33,920 --> 00:27:38,270
decoding stuff in a controlled legal

00:27:35,420 --> 00:27:41,360
manner you can do a lot with disk-based

00:27:38,270 --> 00:27:42,890
files things like that but um whatever

00:27:41,360 --> 00:27:45,050
were so testing is really important and

00:27:42,890 --> 00:27:46,670
I often start with the test cases in a

00:27:45,050 --> 00:27:48,400
test suite a lot before really getting

00:27:46,670 --> 00:27:51,980
into the real implementation of the code

00:27:48,400 --> 00:27:54,050
um we're really big and deja canoe which

00:27:51,980 --> 00:27:55,580
I actually which I helped write so this

00:27:54,050 --> 00:27:59,150
is one of our test cases for instance

00:27:55,580 --> 00:28:00,770
and decoding numbers and this is kind of

00:27:59,150 --> 00:28:02,840
high like to do it i used OD to get the

00:28:00,770 --> 00:28:04,790
binary hex there cut and pasted it into

00:28:02,840 --> 00:28:06,530
a memory buffer and then i can run my

00:28:04,790 --> 00:28:08,090
parsing function and then i can walk

00:28:06,530 --> 00:28:09,080
through the data structure return from

00:28:08,090 --> 00:28:10,550
parsing a hex

00:28:09,080 --> 00:28:11,990
and examine all the different elements

00:28:10,550 --> 00:28:13,940
of it to make sure that it was parsed

00:28:11,990 --> 00:28:15,950
correctly the the nice thing about that

00:28:13,940 --> 00:28:17,900
says is i have thousands of these one

00:28:15,950 --> 00:28:20,060
for several for every different data

00:28:17,900 --> 00:28:22,370
type I could ever support nested data

00:28:20,060 --> 00:28:24,020
types and arrays of custom objects and

00:28:22,370 --> 00:28:26,240
tons of stuff and when I make a little

00:28:24,020 --> 00:28:27,650
change I can run the test suite and see

00:28:26,240 --> 00:28:30,020
if I broke something really majorly

00:28:27,650 --> 00:28:31,670
really quickly which is really useful I

00:28:30,020 --> 00:28:33,620
mean without good testing I would make a

00:28:31,670 --> 00:28:34,940
subtle change and sometimes never know

00:28:33,620 --> 00:28:38,930
for days or weeks if I had actually

00:28:34,940 --> 00:28:40,520
broken anything the other thing is

00:28:38,930 --> 00:28:42,290
depending which tools are using for

00:28:40,520 --> 00:28:44,750
sniffing it's hard to know where your

00:28:42,290 --> 00:28:46,850
data actually starts once again this is

00:28:44,750 --> 00:28:48,590
an HTTP message to be easier and stuff

00:28:46,850 --> 00:28:51,170
but it's more or less the first fifty

00:28:48,590 --> 00:28:53,600
two bytes is all the ethernet TCP IP

00:28:51,170 --> 00:28:54,860
header over crap and so you n grep

00:28:53,600 --> 00:28:56,480
leaves all that off which is kind of

00:28:54,860 --> 00:28:57,890
nice but but pretty much you have to get

00:28:56,480 --> 00:28:59,420
to where the actual data starts or

00:28:57,890 --> 00:29:01,130
you're trying to decode an ethernet

00:28:59,420 --> 00:29:02,810
header is like a video packet header and

00:29:01,130 --> 00:29:07,040
it will never work because it's not the

00:29:02,810 --> 00:29:10,130
same thing so pretty much here's a

00:29:07,040 --> 00:29:13,010
classic example of a hex dump that I'd

00:29:10,130 --> 00:29:14,210
grab uni stack to sing you go you're

00:29:13,010 --> 00:29:15,800
going to be kidding there's nothing in

00:29:14,210 --> 00:29:17,870
here I mean I'd like a destiny I can see

00:29:15,800 --> 00:29:21,050
the number one in big Indian format

00:29:17,870 --> 00:29:22,790
reversed and a bunch of other stuff so

00:29:21,050 --> 00:29:24,830
the first thing I usually do is I'd look

00:29:22,790 --> 00:29:28,070
for the ASCII strings in this case just

00:29:24,830 --> 00:29:29,600
color-coding them but basically once you

00:29:28,070 --> 00:29:31,490
decode all the ASCII strings

00:29:29,600 --> 00:29:33,500
three-quarters the packet is gone so

00:29:31,490 --> 00:29:34,850
what's left is actually not as

00:29:33,500 --> 00:29:37,250
complicated and the nice thing is that

00:29:34,850 --> 00:29:38,360
what's left is not exactly

00:29:37,250 --> 00:29:41,470
straightforward but in this particular

00:29:38,360 --> 00:29:43,880
packet it was it wasn't that complicated

00:29:41,470 --> 00:29:45,740
so then after finding that then I go

00:29:43,880 --> 00:29:48,740
find everything else which in this case

00:29:45,740 --> 00:29:52,730
is probably mostly just numbers instead

00:29:48,740 --> 00:29:55,460
of more complicated objects in this one

00:29:52,730 --> 00:29:58,010
for the type fields in blue 02 is that

00:29:55,460 --> 00:30:01,550
the amf data type for an actionscript

00:29:58,010 --> 00:30:03,650
string 05 as a null object which is just

00:30:01,550 --> 00:30:05,090
kind of a placeholder type object you

00:30:03,650 --> 00:30:07,190
know like setting data could live here

00:30:05,090 --> 00:30:09,860
but I don't know why they do it but they

00:30:07,190 --> 00:30:11,270
do and then you can see why I've got the

00:30:09,860 --> 00:30:13,010
length fields marked out in green

00:30:11,270 --> 00:30:15,680
numbers of course don't have a length

00:30:13,010 --> 00:30:18,710
field there's basically the numbers the

00:30:15,680 --> 00:30:20,450
the data type field is a 0 for a number

00:30:18,710 --> 00:30:22,860
which is gets confusing but you get used

00:30:20,450 --> 00:30:25,559
to seeing looking for 99 bite numbers

00:30:22,860 --> 00:30:28,980
stuff the three FF 0 as I said is a is a

00:30:25,559 --> 00:30:31,920
one in big Indian format sitting on a

00:30:28,980 --> 00:30:33,809
little endian machine and then basically

00:30:31,920 --> 00:30:35,309
you know letting in emacs and adding

00:30:33,809 --> 00:30:37,140
nice colors and stuff this is what that

00:30:35,309 --> 00:30:40,650
packet turns into seen that wasn't that

00:30:37,140 --> 00:30:42,390
hard was it that's what it looks like it

00:30:40,650 --> 00:30:44,190
Nell anyway um and that's the other

00:30:42,390 --> 00:30:45,240
reason I'd like to use Emacs a lot as

00:30:44,190 --> 00:30:46,710
you know when I originally did that I

00:30:45,240 --> 00:30:48,450
put that hex dump in a scratch buffer

00:30:46,710 --> 00:30:51,770
added carriage returns and broke it all

00:30:48,450 --> 00:30:54,260
down and it made more sense that way um

00:30:51,770 --> 00:30:56,429
so basically people say how can you help

00:30:54,260 --> 00:30:57,840
you know along with reverse engineering

00:30:56,429 --> 00:30:59,700
and stuff we have a lot of software

00:30:57,840 --> 00:31:02,220
that's actually using the work that

00:30:59,700 --> 00:31:03,960
we're actually using so you know

00:31:02,220 --> 00:31:06,000
translations other languages for our

00:31:03,960 --> 00:31:07,530
ganache player is really good people

00:31:06,000 --> 00:31:09,299
that can do compatibility testing that

00:31:07,530 --> 00:31:11,580
actually run the adobe thing is very

00:31:09,299 --> 00:31:14,490
useful bug reporting documentation

00:31:11,580 --> 00:31:16,110
maintaining a build farm fundings always

00:31:14,490 --> 00:31:18,450
really nice okay once all people send me

00:31:16,110 --> 00:31:20,280
free beer which is kind of funny and

00:31:18,450 --> 00:31:21,419
then I just want to give a couple thanks

00:31:20,280 --> 00:31:22,950
to the people who sponsored all this

00:31:21,419 --> 00:31:25,559
work that I've been doing for the last

00:31:22,950 --> 00:31:26,760
two years here basically and uh without

00:31:25,559 --> 00:31:28,440
these people I wouldn't be able to put

00:31:26,760 --> 00:31:34,440
all this time in the reverse engineering

00:31:28,440 --> 00:31:44,160
any of this stuff so questions or more

00:31:34,440 --> 00:31:45,750
explanations I'm funny enough day after

00:31:44,160 --> 00:31:47,040
i did a version of this talk a few weeks

00:31:45,750 --> 00:31:48,990
ago they announced that they're going to

00:31:47,040 --> 00:31:50,460
release the specs but the licensing

00:31:48,990 --> 00:31:51,720
agreement forbids you from using a

00:31:50,460 --> 00:31:55,650
specification to write your own

00:31:51,720 --> 00:31:57,270
implementation has actually having

00:31:55,650 --> 00:31:59,490
already written an implementation i'm

00:31:57,270 --> 00:32:00,809
not really sure what that means but once

00:31:59,490 --> 00:32:02,490
when i get back to the states i'm going

00:32:00,809 --> 00:32:10,610
to go have to ask the eff about that in

00:32:02,490 --> 00:32:12,900
more detail i look at the same way when

00:32:10,610 --> 00:32:14,340
okay yeah basically the question was

00:32:12,900 --> 00:32:16,500
adobe announced that they're going to

00:32:14,340 --> 00:32:19,380
release their specifications for rtmp

00:32:16,500 --> 00:32:20,820
and basically no i mean i already

00:32:19,380 --> 00:32:22,919
published my version of their docs like

00:32:20,820 --> 00:32:23,790
two years ago and i think it's a lot

00:32:22,919 --> 00:32:26,100
like when they released their

00:32:23,790 --> 00:32:28,110
ActionScript specifications last year is

00:32:26,100 --> 00:32:30,210
that we already figured that out it's

00:32:28,110 --> 00:32:31,800
basically too little too late and I mean

00:32:30,210 --> 00:32:34,650
I guess it's good that Adobe's trying to

00:32:31,800 --> 00:32:35,940
be more open source and and you know

00:32:34,650 --> 00:32:37,559
doing the right thing

00:32:35,940 --> 00:32:40,230
other kind of stuff but at the same time

00:32:37,559 --> 00:32:41,340
as their licensing clauses or hell they

00:32:40,230 --> 00:32:43,230
have the same thing for the ActionScript

00:32:41,340 --> 00:32:44,759
specifications until recently if you

00:32:43,230 --> 00:32:47,250
read the spec you couldn't write a flash

00:32:44,759 --> 00:32:49,259
player legally I think that that's

00:32:47,250 --> 00:33:01,649
illegal in EU countries but in the US

00:32:49,259 --> 00:33:02,490
unfortunately it's binding on his

00:33:01,649 --> 00:33:04,340
question was how do I deal with

00:33:02,490 --> 00:33:05,970
encryption in protocols and

00:33:04,340 --> 00:33:07,980
unfortunately does this thing called the

00:33:05,970 --> 00:33:14,700
DMCA that actually forbids me from

00:33:07,980 --> 00:33:16,950
answering your question typically on

00:33:14,700 --> 00:33:18,600
though um I mean reverse engineering

00:33:16,950 --> 00:33:20,370
encryption protocols as sort of a sub

00:33:18,600 --> 00:33:22,169
specialty I happen to have a couple

00:33:20,370 --> 00:33:24,330
friends who that's their thing and I

00:33:22,169 --> 00:33:27,419
think they use very different techniques

00:33:24,330 --> 00:33:29,789
than doing network protocols but um but

00:33:27,419 --> 00:33:31,080
typically in the rtmp case they actually

00:33:29,789 --> 00:33:33,990
have a new encryption scheme they've

00:33:31,080 --> 00:33:36,809
just added called rtmp te which uses

00:33:33,990 --> 00:33:39,299
some 128-bit key and one of these days

00:33:36,809 --> 00:33:41,460
I'm actually thinking of tearing into

00:33:39,299 --> 00:33:43,320
that but I have to keep talking to the

00:33:41,460 --> 00:33:46,789
lawyers before I start since I do like

00:33:43,320 --> 00:33:46,789
to go back to the states once in a while

00:34:05,840 --> 00:34:10,169
um you know the classic okay basically

00:34:08,700 --> 00:34:11,730
the question was what about going to a

00:34:10,169 --> 00:34:13,770
country that doesn't have these stupid

00:34:11,730 --> 00:34:16,829
laws like we're stuck with doing all the

00:34:13,770 --> 00:34:18,089
work there and then publishing it um you

00:34:16,829 --> 00:34:19,079
know I spend enough time over here that

00:34:18,089 --> 00:34:20,790
I almost feel like that's what I'm doing

00:34:19,079 --> 00:34:22,859
but the problem is that when I go back

00:34:20,790 --> 00:34:24,929
to the United States I am required to

00:34:22,859 --> 00:34:27,659
abide by those laws we've seen in some

00:34:24,929 --> 00:34:28,919
of the past dmca cases where large

00:34:27,659 --> 00:34:31,619
companies have attracted people from

00:34:28,919 --> 00:34:32,970
Russia Norway in a few other places to

00:34:31,619 --> 00:34:36,060
the United States and then dropped a

00:34:32,970 --> 00:34:38,099
DMCA violation on them so well that's

00:34:36,060 --> 00:34:39,210
not a bad idea along with doing to work

00:34:38,099 --> 00:34:40,829
and at the right country I think would

00:34:39,210 --> 00:34:43,020
be to find a developer in that country

00:34:40,829 --> 00:34:44,849
that actually lives there to actually do

00:34:43,020 --> 00:34:46,260
a lot of that work and I think this is

00:34:44,849 --> 00:34:49,179
actually one of the reasons why Ganesh

00:34:46,260 --> 00:34:51,179
has so many European volunteers because

00:34:49,179 --> 00:34:53,530
most everybody in the united states have

00:34:51,179 --> 00:34:55,480
signed the adobe license agreement and

00:34:53,530 --> 00:34:56,859
installed the adobe plug-in and actually

00:34:55,480 --> 00:34:58,690
they can't work on any of our software

00:34:56,859 --> 00:35:00,849
and a lot of the folks in Europe and

00:34:58,690 --> 00:35:01,869
Italy and EU countries and stuff they

00:35:00,849 --> 00:35:03,130
don't really care about this thing

00:35:01,869 --> 00:35:06,220
because it's not against the wall there

00:35:03,130 --> 00:35:07,630
so so I think that's a good idea for me

00:35:06,220 --> 00:35:09,069
personally it's just not real practical

00:35:07,630 --> 00:35:19,540
because I do like to go back once in a

00:35:09,069 --> 00:35:21,730
while um yeah the question was how do I

00:35:19,540 --> 00:35:23,290
figure out check some algorithms on what

00:35:21,730 --> 00:35:25,359
does a lot of checks on algorithms it

00:35:23,290 --> 00:35:26,920
seems like most protocol writers used a

00:35:25,359 --> 00:35:29,050
simple way of just adding up every bite

00:35:26,920 --> 00:35:31,030
and the trick is that sometimes you know

00:35:29,050 --> 00:35:33,490
depending on the size of the checksum

00:35:31,030 --> 00:35:34,809
field it'll roll over but most everybody

00:35:33,490 --> 00:35:36,250
litter they're just adding up the bytes

00:35:34,809 --> 00:35:37,990
and all know there's other ways of doing

00:35:36,250 --> 00:35:39,910
it but that's the one I've seen probably

00:35:37,990 --> 00:35:41,230
ninety percent of the time and then yeah

00:35:39,910 --> 00:35:42,609
that's where you start writing test code

00:35:41,230 --> 00:35:44,050
you know you think you know what to

00:35:42,609 --> 00:35:45,160
check some is so it will write something

00:35:44,050 --> 00:35:47,079
that will add up all the numbers and

00:35:45,160 --> 00:35:48,730
print it out in one bite to bite three

00:35:47,079 --> 00:35:50,619
bite and floor bite quantities and go oh

00:35:48,730 --> 00:35:52,210
it's a 2-byte checksum for a number

00:35:50,619 --> 00:35:55,329
that's this big and it rolled over once

00:35:52,210 --> 00:35:56,770
kind of thing more than that it can be

00:35:55,329 --> 00:35:58,030
kind of complicated but I've been lucky

00:35:56,770 --> 00:36:02,040
I haven't really seen any other

00:35:58,030 --> 00:36:02,040
checksums used and not in the real world

00:36:07,089 --> 00:36:18,319
I'm sorry can't cook um basically asked

00:36:16,880 --> 00:36:19,760
how we make sure that our volunteers are

00:36:18,319 --> 00:36:22,160
doing good you know sort of clean room

00:36:19,760 --> 00:36:23,269
reverse engineering one of the ways we

00:36:22,160 --> 00:36:25,190
actually have to do this is that the

00:36:23,269 --> 00:36:26,690
nobody checks in code to our source code

00:36:25,190 --> 00:36:28,910
repository unless it's gone through the

00:36:26,690 --> 00:36:30,799
core developers typically we even have

00:36:28,910 --> 00:36:32,510
to ask questions of some patches and

00:36:30,799 --> 00:36:34,579
things to make sure that their source

00:36:32,510 --> 00:36:36,170
came from something clean or they

00:36:34,579 --> 00:36:37,579
figured it out you know and we got a lot

00:36:36,170 --> 00:36:39,559
of patches that are just you know bug

00:36:37,579 --> 00:36:41,809
fixes that stuff's easy we just put it

00:36:39,559 --> 00:36:43,760
in but most of the reverse engineering

00:36:41,809 --> 00:36:44,779
stuff to be honest I don't think we

00:36:43,760 --> 00:36:47,000
actually ever really had any

00:36:44,779 --> 00:36:48,859
contributions from everybody I've done

00:36:47,000 --> 00:36:50,599
most of the hardcore reverse engineering

00:36:48,859 --> 00:36:52,430
and all of our other contributions are

00:36:50,599 --> 00:36:53,839
actually on all the other parts of the

00:36:52,430 --> 00:36:55,400
project because more than reverse

00:36:53,839 --> 00:36:56,660
engineering a network protocol there's a

00:36:55,400 --> 00:36:58,519
little bit more to the software than

00:36:56,660 --> 00:37:00,170
just a protocol and so a lot of our

00:36:58,519 --> 00:37:02,359
contributions are you know GUI layers

00:37:00,170 --> 00:37:04,010
and graphic morphing and you know

00:37:02,359 --> 00:37:05,660
different renderers and a lot of that

00:37:04,010 --> 00:37:07,039
kind of stuff but but I think if people

00:37:05,660 --> 00:37:08,240
got in the reverse engineering yeah I'd

00:37:07,039 --> 00:37:10,369
have to ask why they found out because

00:37:08,240 --> 00:37:12,740
if they had ever read the specs or read

00:37:10,369 --> 00:37:37,519
an internal Adobe document I can't use

00:37:12,740 --> 00:37:39,109
it even if it works um yeah I think

00:37:37,519 --> 00:37:40,369
basically the question was is it against

00:37:39,109 --> 00:37:41,720
the law to sort of say all we'd like

00:37:40,369 --> 00:37:44,240
this protocol to be reverse engineered

00:37:41,720 --> 00:37:46,190
and hope that somebody does it and

00:37:44,240 --> 00:37:47,630
contributes it from sources unknown I

00:37:46,190 --> 00:37:50,089
think the problem knows you'd actually

00:37:47,630 --> 00:37:51,289
have to know where it came from although

00:37:50,089 --> 00:37:52,789
I think the idea of like oh well

00:37:51,289 --> 00:37:54,529
somebody reverse engineer this I said

00:37:52,789 --> 00:37:56,779
that actually all the time I mean people

00:37:54,529 --> 00:37:59,779
offer projects to me like that pretty

00:37:56,779 --> 00:38:01,160
frequently in things but as far as is

00:37:59,779 --> 00:38:02,660
getting to somebody to sort of donate a

00:38:01,160 --> 00:38:05,180
non instantly a reverse engineered

00:38:02,660 --> 00:38:06,920
implementation you really need to know

00:38:05,180 --> 00:38:08,210
where it came from and typically a lot

00:38:06,920 --> 00:38:10,119
of reverse engineering anyway is not

00:38:08,210 --> 00:38:12,319
exactly a short-term project and it's uh

00:38:10,119 --> 00:38:13,549
you almost need funding to do it because

00:38:12,319 --> 00:38:15,170
you want to do it all day every day

00:38:13,549 --> 00:38:16,670
until it actually starts making sense

00:38:15,170 --> 00:38:19,569
and some of this stuff's really hard to

00:38:16,670 --> 00:38:19,569
do on a few weekends

00:38:25,610 --> 00:38:30,420
um you know most of the there's probably

00:38:28,950 --> 00:38:32,550
a lot of protocols that I would love to

00:38:30,420 --> 00:38:34,980
see reverse engineered I've been mostly

00:38:32,550 --> 00:38:36,420
focusing on the adobe ones i wouldn't

00:38:34,980 --> 00:38:37,980
mind somebody you didn't hear this from

00:38:36,420 --> 00:38:52,670
me working on the encryption part of

00:38:37,980 --> 00:38:52,670
rtmp but you didn't hear that oh yeah

00:39:14,540 --> 00:39:18,930
i'm basically the question was using

00:39:17,070 --> 00:39:21,090
wiki leaks in a sense for leaking

00:39:18,930 --> 00:39:23,250
technical documentation where the the

00:39:21,090 --> 00:39:25,130
the legalities and the licensing around

00:39:23,250 --> 00:39:27,900
it um that actually happened with flash

00:39:25,130 --> 00:39:29,850
um it didn't go through WikiLeaks but a

00:39:27,900 --> 00:39:31,860
lot of people just took you know copies

00:39:29,850 --> 00:39:33,660
of the ActionScript spec specification

00:39:31,860 --> 00:39:36,990
dropped it on the Internet other people

00:39:33,660 --> 00:39:38,640
copied it from them and so typically

00:39:36,990 --> 00:39:40,770
yeah if you've actually gotten access to

00:39:38,640 --> 00:39:42,930
it legally and it's gone through several

00:39:40,770 --> 00:39:45,420
hands of people most of the lawyers I've

00:39:42,930 --> 00:39:46,560
talked to consider that legal at the

00:39:45,420 --> 00:39:49,740
same time is when I actually found

00:39:46,560 --> 00:39:51,030
copies of the specification we'd already

00:39:49,740 --> 00:39:53,580
figured that part out because we just

00:39:51,030 --> 00:39:54,930
use the equity 62 script spec initially

00:39:53,580 --> 00:39:56,310
but you're right i think that is a good

00:39:54,930 --> 00:39:59,190
way that if you have knowledge of stuff

00:39:56,310 --> 00:40:00,810
that's not illegal to release at all

00:39:59,190 --> 00:40:03,410
WikiLeaks might be a good place for it

00:40:00,810 --> 00:40:03,410
as anything else

00:40:07,760 --> 00:40:15,780
um yeah he asked if I'd he asked about

00:40:13,950 --> 00:40:17,010
doing a reverse engineering of drivers

00:40:15,780 --> 00:40:18,840
I've actually done a lot of device

00:40:17,010 --> 00:40:19,950
drivers refers to engineering it's even

00:40:18,840 --> 00:40:21,930
more painful than doing network

00:40:19,950 --> 00:40:24,840
protocols because you typically need to

00:40:21,930 --> 00:40:26,100
know things about the hardware a classic

00:40:24,840 --> 00:40:28,680
example is I was sitting down with a

00:40:26,100 --> 00:40:30,180
friend last week and basically this

00:40:28,680 --> 00:40:32,730
apartment the USB driver in Linux

00:40:30,180 --> 00:40:35,370
systems these days and in an appendix of

00:40:32,730 --> 00:40:37,980
an appendix of a reference of the USB

00:40:35,370 --> 00:40:39,420
spec there's one number one field that

00:40:37,980 --> 00:40:40,650
these guys and it actually turns off the

00:40:39,420 --> 00:40:42,330
USB controller and solved all the

00:40:40,650 --> 00:40:44,460
problems they were having and it's just

00:40:42,330 --> 00:40:45,870
a matter of sometimes you know finding

00:40:44,460 --> 00:40:50,520
that took somebody like a couple of

00:40:45,870 --> 00:41:01,140
months of reading documentation and but

00:40:50,520 --> 00:41:02,550
yeah drivers are hard um you know as I

00:41:01,140 --> 00:41:04,800
said this talk was mostly on network

00:41:02,550 --> 00:41:06,750
protocols I've done mostly network

00:41:04,800 --> 00:41:08,580
protocols and device drivers so that's

00:41:06,750 --> 00:41:11,190
kind of my background I think file

00:41:08,580 --> 00:41:14,070
formats gets really complicated I mean I

00:41:11,190 --> 00:41:15,810
look at stuff like a XML with the 7000

00:41:14,070 --> 00:41:18,000
page specification which can't even be

00:41:15,810 --> 00:41:19,710
implemented and things like that and I

00:41:18,000 --> 00:41:21,510
think that the problem with a lot of

00:41:19,710 --> 00:41:23,720
file formats is that network protocols

00:41:21,510 --> 00:41:26,040
usually by designer pretty simple and

00:41:23,720 --> 00:41:28,410
you so you're what you have to figure

00:41:26,040 --> 00:41:30,030
out is kind of more limited and I think

00:41:28,410 --> 00:41:31,950
five formats and people obviously do it

00:41:30,030 --> 00:41:33,690
I mean odf works and openoffice reads

00:41:31,950 --> 00:41:35,900
Word documents and things like that but

00:41:33,690 --> 00:41:38,700
my gut feeling is that that's probably

00:41:35,900 --> 00:41:40,740
uses some of the same tools but probably

00:41:38,700 --> 00:41:41,940
slightly different techniques because I

00:41:40,740 --> 00:41:43,770
don't think they worry about things like

00:41:41,940 --> 00:41:45,570
header fields and and you know bite

00:41:43,770 --> 00:41:46,890
counts of stuff and check sums as much

00:41:45,570 --> 00:41:49,260
like for instance in a word processing

00:41:46,890 --> 00:41:51,780
floor mat at the same time as you know

00:41:49,260 --> 00:41:54,770
hex is hex and you can still analyze it

00:41:51,780 --> 00:41:54,770
and figure out what you could

00:42:00,220 --> 00:42:05,420
yeah that's another one Adobe patent at

00:42:02,630 --> 00:42:07,160
rtmp my implementation came out before

00:42:05,420 --> 00:42:08,540
the patent was granted and so I actually

00:42:07,160 --> 00:42:10,190
have to talk to a real lawyer pretty

00:42:08,540 --> 00:42:13,730
soon and find out if I can actually

00:42:10,190 --> 00:42:16,730
release the code that I just wrote you

00:42:13,730 --> 00:42:18,710
got to love software patents barely um

00:42:16,730 --> 00:42:19,940
and they've also well and then they have

00:42:18,710 --> 00:42:21,440
method be going to did their spec so

00:42:19,940 --> 00:42:23,240
under we'll see what happens I actually

00:42:21,440 --> 00:42:25,250
contacted Adobe about that and they

00:42:23,240 --> 00:42:27,980
claim they're becoming a more open

00:42:25,250 --> 00:42:29,600
source friendly company but the license

00:42:27,980 --> 00:42:41,420
agreement still suck so I'm still

00:42:29,600 --> 00:42:50,480
waiting um so you said how long do I

00:42:41,420 --> 00:42:51,740
spend reverse engineering versus how big

00:42:50,480 --> 00:42:54,160
a part of the project is reverse

00:42:51,740 --> 00:42:54,160
engineering

00:43:04,710 --> 00:43:08,010
oh how much so I thumb that's been doing

00:43:06,540 --> 00:43:10,109
the legal on time of a hard time hearing

00:43:08,010 --> 00:43:12,210
so so how much time do I spend dealing

00:43:10,109 --> 00:43:15,089
with the legal side of things typically

00:43:12,210 --> 00:43:16,680
the legal side is usually visiting

00:43:15,089 --> 00:43:18,390
lawyers for an afternoon here and there

00:43:16,680 --> 00:43:20,130
and talking about stuff in great detail

00:43:18,390 --> 00:43:21,950
and then typically not action is

00:43:20,130 --> 00:43:24,450
necessarily having to talk to them again

00:43:21,950 --> 00:43:26,099
once I've had people explain to me for

00:43:24,450 --> 00:43:28,170
instance I've memorized all the legal

00:43:26,099 --> 00:43:30,270
reverse-engineering clauses of the DMCA

00:43:28,170 --> 00:43:32,520
for instance and have lawyers interpret

00:43:30,270 --> 00:43:34,800
it for me once they've taught me in a

00:43:32,520 --> 00:43:36,810
sense how to reverse engineer legal

00:43:34,800 --> 00:43:38,130
documents and stuff like that I don't

00:43:36,810 --> 00:43:39,690
usually have to see them that often

00:43:38,130 --> 00:43:44,280
except for occasional questions like

00:43:39,690 --> 00:43:46,950
about this issue about rtmp yeah I mean

00:43:44,280 --> 00:43:48,660
plus good lawyers are expensive luckily

00:43:46,950 --> 00:43:51,050
mine work for Prairie the eff is great

00:43:48,660 --> 00:43:51,050

YouTube URL: https://www.youtube.com/watch?v=t3s-mG5yUjY


