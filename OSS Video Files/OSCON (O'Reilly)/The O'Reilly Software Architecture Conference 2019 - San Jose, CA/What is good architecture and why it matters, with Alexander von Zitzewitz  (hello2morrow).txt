Title: What is good architecture and why it matters, with Alexander von Zitzewitz  (hello2morrow)
Publication date: 2019-06-26
Playlist: The O'Reilly Software Architecture Conference 2019 - San Jose, CA
Description: 
	Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:00,030 --> 00:00:06,720
so hi Alexander tell us why do so many

00:00:03,750 --> 00:00:08,700
projects end up as a big ball of mud oh

00:00:06,720 --> 00:00:10,679
I have a little story to tell you about

00:00:08,700 --> 00:00:13,469
this I had a little presentation

00:00:10,679 --> 00:00:16,529
yesterday about metrics for software

00:00:13,469 --> 00:00:18,320
architects and we talked about a lot of

00:00:16,529 --> 00:00:20,640
what architectural metrics that measure

00:00:18,320 --> 00:00:22,769
architecture quality structural health

00:00:20,640 --> 00:00:26,490
of a software system and I asked the

00:00:22,769 --> 00:00:29,340
audience of about 120 people how many of

00:00:26,490 --> 00:00:31,050
you guys would actually understand and

00:00:29,340 --> 00:00:32,759
know the architecture of the system we

00:00:31,050 --> 00:00:35,370
are working on to a degree that you can

00:00:32,759 --> 00:00:36,989
tell me what you could do which would

00:00:35,370 --> 00:00:38,550
conform to the architecture on which we

00:00:36,989 --> 00:00:41,040
couldn't do that doesn't conform with

00:00:38,550 --> 00:00:42,920
the architecture of those 120 people

00:00:41,040 --> 00:00:46,140
exactly three people raised their hand

00:00:42,920 --> 00:00:47,399
so I can only slide Forrest Gump here if

00:00:46,140 --> 00:00:49,649
you don't know where you're going it's

00:00:47,399 --> 00:00:52,110
unlikely you're gonna get there so it's

00:00:49,649 --> 00:00:54,239
it's it's unfortunate it's affected

00:00:52,110 --> 00:00:56,820
about 90% of all projects end up as a

00:00:54,239 --> 00:00:59,340
big ball of mud because people do not

00:00:56,820 --> 00:01:01,770
manage dependencies properly they don't

00:00:59,340 --> 00:01:03,899
if they have an architectures described

00:01:01,770 --> 00:01:06,420
in some PowerPoint on a wiki page and

00:01:03,899 --> 00:01:08,850
people have different interpretations of

00:01:06,420 --> 00:01:10,170
the architecture or they're just not

00:01:08,850 --> 00:01:12,450
seeing is while they're coding a

00:01:10,170 --> 00:01:14,580
developer works on the code and this has

00:01:12,450 --> 00:01:17,040
tunnel vision for the specific problem

00:01:14,580 --> 00:01:20,130
he wants to solve and he can't see all

00:01:17,040 --> 00:01:22,619
the side effects of dependencies is

00:01:20,130 --> 00:01:24,240
introducing and this causes at the end

00:01:22,619 --> 00:01:25,770
you have more and more dependencies and

00:01:24,240 --> 00:01:28,020
everything is talking to everything and

00:01:25,770 --> 00:01:29,310
then the structure is lost and it

00:01:28,020 --> 00:01:32,700
becomes much harder to work on the

00:01:29,310 --> 00:01:38,790
system and why does that architecture

00:01:32,700 --> 00:01:40,770
matter well let's let's look at the

00:01:38,790 --> 00:01:43,740
consequences of a big bowl of not and

00:01:40,770 --> 00:01:45,270
that's also I think the min term there's

00:01:43,740 --> 00:01:47,280
even some good results about this how

00:01:45,270 --> 00:01:50,579
much time to develop a spend reading

00:01:47,280 --> 00:01:52,530
code versus writing code and if you have

00:01:50,579 --> 00:01:54,990
a big ball of mud chances are that you

00:01:52,530 --> 00:01:57,270
developers spend 85 to 90% of the time

00:01:54,990 --> 00:01:58,860
reading code trying to understand what

00:01:57,270 --> 00:02:00,240
it's doing and how it's working together

00:01:58,860 --> 00:02:04,079
before they can do any meaningful

00:02:00,240 --> 00:02:05,579
changes now let's assume you have an

00:02:04,079 --> 00:02:08,550
architecture that keeps your code base

00:02:05,579 --> 00:02:11,459
clean and organized and and modularized

00:02:08,550 --> 00:02:13,590
in a good way then chances are that you

00:02:11,459 --> 00:02:15,780
developers with only spent

00:02:13,590 --> 00:02:18,180
percent of the time reading code and 30%

00:02:15,780 --> 00:02:19,230
of coding so that's a hundred two

00:02:18,180 --> 00:02:21,239
hundred percent increase in

00:02:19,230 --> 00:02:24,630
collectivities right away without doing

00:02:21,239 --> 00:02:29,459
much and what is good architecture what

00:02:24,630 --> 00:02:31,790
does that look like good architecture is

00:02:29,459 --> 00:02:34,319
an architecture that gives you options

00:02:31,790 --> 00:02:36,690
because if you work on software systems

00:02:34,319 --> 00:02:38,459
you always shoot on moveable targets

00:02:36,690 --> 00:02:40,890
because requirements change the

00:02:38,459 --> 00:02:44,220
environment changes technology changes

00:02:40,890 --> 00:02:45,959
and you want to be flexible you want to

00:02:44,220 --> 00:02:48,120
be able to replace certain parts of your

00:02:45,959 --> 00:02:52,319
software systems if technology changes

00:02:48,120 --> 00:02:54,060
if if you requirements change and this

00:02:52,319 --> 00:02:56,549
is difficult to do in a big ball of mud

00:02:54,060 --> 00:02:58,590
you want this modularity so that you can

00:02:56,549 --> 00:02:59,160
take apart replace it with something

00:02:58,590 --> 00:03:01,890
else

00:02:59,160 --> 00:03:04,890
or work on that part add some new

00:03:01,890 --> 00:03:07,349
features that are useful instead of just

00:03:04,890 --> 00:03:09,209
having to disentangle this thing all the

00:03:07,349 --> 00:03:12,330
time and then not having the options

00:03:09,209 --> 00:03:14,730
anymore and on top of that everything

00:03:12,330 --> 00:03:16,830
takes much longer so you're not you

00:03:14,730 --> 00:03:18,750
becoming less and less agile to say it

00:03:16,830 --> 00:03:21,239
this way because you you you you're

00:03:18,750 --> 00:03:22,859
fighting with technical depth and making

00:03:21,239 --> 00:03:25,140
meaningful changes to a big ball of

00:03:22,859 --> 00:03:28,410
modest heart so the good architecture

00:03:25,140 --> 00:03:29,730
model Rises things keeps independent

00:03:28,410 --> 00:03:31,440
components in your software systems

00:03:29,730 --> 00:03:32,850
almost like if you if you build a

00:03:31,440 --> 00:03:35,459
monolith and and imagine you have

00:03:32,850 --> 00:03:37,019
Microsoft's within the monolith that are

00:03:35,459 --> 00:03:39,780
cleanly separated and where you have

00:03:37,019 --> 00:03:42,840
minimized interfaces between them that

00:03:39,780 --> 00:03:45,060
would be a good ideal architecture then

00:03:42,840 --> 00:03:47,579
how can you enforce an architectural

00:03:45,060 --> 00:03:50,910
model well that's that's an interesting

00:03:47,579 --> 00:03:53,220
question because that's a relatively new

00:03:50,910 --> 00:03:54,810
topic because there's been work on this

00:03:53,220 --> 00:03:57,239
topic for quite a while there and some

00:03:54,810 --> 00:03:59,459
open source projects a very old one

00:03:57,239 --> 00:04:02,430
started in 2000 was called depend on

00:03:59,459 --> 00:04:04,500
meter which basically allows you to find

00:04:02,430 --> 00:04:07,859
a very simple model in XML and and

00:04:04,500 --> 00:04:09,239
enforce that only work on Java but what

00:04:07,859 --> 00:04:11,310
you could in for certain architectural

00:04:09,239 --> 00:04:13,889
rules and restrictions doing this in

00:04:11,310 --> 00:04:15,930
your build now we have new systems like

00:04:13,889 --> 00:04:18,239
our key unit which are kind of cool

00:04:15,930 --> 00:04:20,489
because you can make a unit test and and

00:04:18,239 --> 00:04:23,099
make it fail if the architecture spoken

00:04:20,489 --> 00:04:25,419
the problem is our unit is that is a

00:04:23,099 --> 00:04:27,400
little bit hard to define real

00:04:25,419 --> 00:04:29,289
Tech's remodel it's really you have to

00:04:27,400 --> 00:04:31,719
maintain a lot of rules over time and it

00:04:29,289 --> 00:04:34,210
can get a little bit out of hand if you

00:04:31,719 --> 00:04:37,960
system is bigger or use something like

00:04:34,210 --> 00:04:40,749
like our products on our graph we worked

00:04:37,960 --> 00:04:42,999
on a new domain specific language to

00:04:40,749 --> 00:04:45,789
describe architecture and that has been

00:04:42,999 --> 00:04:48,249
on the market since 2011 quite

00:04:45,789 --> 00:04:49,719
successful and you use it to main

00:04:48,249 --> 00:04:52,120
specific language to describe the

00:04:49,719 --> 00:04:53,650
structure of your software system so to

00:04:52,120 --> 00:04:56,800
give you an idea if you have something

00:04:53,650 --> 00:04:59,949
like to three million lines of code if

00:04:56,800 --> 00:05:01,930
you would need something like five six

00:04:59,949 --> 00:05:03,520
seven hundred lines of TSL to describe

00:05:01,930 --> 00:05:06,879
the architecture for this whole system

00:05:03,520 --> 00:05:08,409
you can maintain that description that

00:05:06,879 --> 00:05:09,969
formal architecture description with

00:05:08,409 --> 00:05:11,949
very little effort and it's machine

00:05:09,969 --> 00:05:14,500
readable so soon our graph can actually

00:05:11,949 --> 00:05:15,729
use set architecture description to find

00:05:14,500 --> 00:05:18,069
all the places in the code where the

00:05:15,729 --> 00:05:20,830
code deviates from the architecture so

00:05:18,069 --> 00:05:22,330
you not only have a formal description

00:05:20,830 --> 00:05:24,279
and documentation of your architecture

00:05:22,330 --> 00:05:25,689
that is readable by every human the

00:05:24,279 --> 00:05:27,759
language is very easy to learn

00:05:25,689 --> 00:05:29,500
it can also be enforced and you can

00:05:27,759 --> 00:05:31,779
proof actually that your software system

00:05:29,500 --> 00:05:32,919
is following the rules and it's it's

00:05:31,779 --> 00:05:34,569
like source code it needs to be

00:05:32,919 --> 00:05:36,129
committed to your version control system

00:05:34,569 --> 00:05:38,949
and the architecture grows with the

00:05:36,129 --> 00:05:41,259
system what benefits do you see from

00:05:38,949 --> 00:05:43,719
keeping a system in good architectural

00:05:41,259 --> 00:05:47,080
shape since since we're doing this since

00:05:43,719 --> 00:05:49,300
more than fourteen years now like I been

00:05:47,080 --> 00:05:51,669
I observe teams who follow the rules in

00:05:49,300 --> 00:05:54,250
this case I can see first of all they're

00:05:51,669 --> 00:05:56,319
very more productive because it's easier

00:05:54,250 --> 00:05:58,599
to find your way in the code everybody

00:05:56,319 --> 00:06:00,189
should do something new I can only talk

00:05:58,599 --> 00:06:01,870
from our own experience with sonography

00:06:00,189 --> 00:06:04,750
using sonar graph to develop sonic off

00:06:01,870 --> 00:06:06,370
on coding almost every day on the system

00:06:04,750 --> 00:06:08,020
and in the meantime I know exactly where

00:06:06,370 --> 00:06:12,159
everything belongs we have this clear

00:06:08,020 --> 00:06:13,599
package naming strategy and we know how

00:06:12,159 --> 00:06:15,490
the architecture looks like we know

00:06:13,599 --> 00:06:17,979
which places you need to touch to do

00:06:15,490 --> 00:06:19,779
something you get used to it still

00:06:17,979 --> 00:06:21,849
occasionally I make a make a mistake and

00:06:19,779 --> 00:06:23,979
then the tool tells me and I can I can

00:06:21,849 --> 00:06:25,449
fix it so it's easier to find you're

00:06:23,979 --> 00:06:28,139
very wrong so you become more productive

00:06:25,449 --> 00:06:30,159
and it's a lot easier for new people to

00:06:28,139 --> 00:06:32,469
understand the code base which is also

00:06:30,159 --> 00:06:34,449
important because many projects they get

00:06:32,469 --> 00:06:36,370
a new guy then you need something like

00:06:34,449 --> 00:06:37,900
six months to become productive because

00:06:36,370 --> 00:06:39,550
I don't know what they're doing

00:06:37,900 --> 00:06:41,470
and the cooperation is very complicated

00:06:39,550 --> 00:06:43,630
so if you have a clear separation a

00:06:41,470 --> 00:06:45,280
clear organization of your code it

00:06:43,630 --> 00:06:47,800
becomes so much easier so it's

00:06:45,280 --> 00:06:50,590
productivity it's fun at work and gives

00:06:47,800 --> 00:06:52,470
you flexibility perfect thanks so much

00:06:50,590 --> 00:06:56,460
for sharing your insights with us today

00:06:52,470 --> 00:06:56,460

YouTube URL: https://www.youtube.com/watch?v=0DWv8SmrNGE


