Title: A New Golden Age for Computer Architecture - David Patterson (UC Berkeley)
Publication date: 2018-09-07
Playlist: Artificial Intelligence Conference 2018 - San Francisco, California
Description: 
	High-level, domain-specific languages and architectures and freeing architects from the chains of proprietary instruction sets will usher in a new golden age. David Patterson explains why, despite the end of Moore’s law, he expects an outpouring of codesigned ML-specific chips and supercomputers that will improve even faster than Moore’s original 1965 prediction.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:00,050 --> 00:00:05,400
so what is left to do is basically

00:00:03,270 --> 00:00:07,710
re-examine that hardware/software static

00:00:05,400 --> 00:00:10,980
so from the software centric point of

00:00:07,710 --> 00:00:12,540
view these modern languages like Python

00:00:10,980 --> 00:00:14,969
which is becoming the most popular

00:00:12,540 --> 00:00:17,580
programming language they're really

00:00:14,969 --> 00:00:20,699
great for programmers but they run

00:00:17,580 --> 00:00:23,070
really slowly is also from the hardware

00:00:20,699 --> 00:00:26,369
side the only trick architects have left

00:00:23,070 --> 00:00:28,769
is domain-specific architectures so did

00:00:26,369 --> 00:00:30,539
you made specific architectures only do

00:00:28,769 --> 00:00:32,570
it to a few tests they don't do

00:00:30,539 --> 00:00:35,370
everything they're not like a standards

00:00:32,570 --> 00:00:37,440
CPU they do a few things but they do

00:00:35,370 --> 00:00:39,840
them really well and you can combine

00:00:37,440 --> 00:00:41,540
these two together the domain-specific

00:00:39,840 --> 00:00:45,090
languages and domain-specific

00:00:41,540 --> 00:00:46,530
architectures are synergistic it's

00:00:45,090 --> 00:00:49,020
because we're raising the hardware

00:00:46,530 --> 00:00:51,780
software interface so how slow is Python

00:00:49,020 --> 00:00:55,469
so this is going from Python to highly

00:00:51,780 --> 00:00:56,879
optimized through a series of steps so

00:00:55,469 --> 00:00:59,550
if we take it from Python we're doing

00:00:56,879 --> 00:01:03,359
matrix multiply to be writing it and see

00:00:59,550 --> 00:01:05,970
we go 50 times faster if we explicitly

00:01:03,359 --> 00:01:07,619
identify the loops the parallel loops in

00:01:05,970 --> 00:01:10,580
the code which compilers can't figure

00:01:07,619 --> 00:01:13,439
out another factor of seven how about

00:01:10,580 --> 00:01:15,240
making it match all that a complicated

00:01:13,439 --> 00:01:18,390
memory hierarchy three levels of caches

00:01:15,240 --> 00:01:20,880
that's a factor of 20 and finally if we

00:01:18,390 --> 00:01:23,220
use the sim D instructions that the our

00:01:20,880 --> 00:01:25,850
previous speaker talked about so you can

00:01:23,220 --> 00:01:29,189
do 32 operations in a single instruction

00:01:25,850 --> 00:01:30,590
that's another factor of 9 you multiply

00:01:29,189 --> 00:01:35,040
it all together that's a factor of

00:01:30,590 --> 00:01:37,320
63,000 so it with 4 C code if you could

00:01:35,040 --> 00:01:39,270
make the compiler go twice as fast you'd

00:01:37,320 --> 00:01:41,430
be a hero you could you could make

00:01:39,270 --> 00:01:43,110
Python go a thousand times faster if you

00:01:41,430 --> 00:01:44,909
did that you get Turing awards for that

00:01:43,110 --> 00:01:47,759
kind of set so that potential is laying

00:01:44,909 --> 00:01:49,229
there available for us to exploit how

00:01:47,759 --> 00:01:51,750
about the bane specific architectures

00:01:49,229 --> 00:01:54,869
you know they tailor it to the domain

00:01:51,750 --> 00:01:57,390
but it's not like it doesn't only do one

00:01:54,869 --> 00:02:00,899
application it their software there so

00:01:57,390 --> 00:02:02,640
it can do a range of applications but it

00:02:00,899 --> 00:02:03,990
requires from the people who want to

00:02:02,640 --> 00:02:06,030
work in this area hardware software

00:02:03,990 --> 00:02:08,640
co.design they have to know about the

00:02:06,030 --> 00:02:11,250
domains themselves and a lot more of the

00:02:08,640 --> 00:02:12,780
stack neural networks is what we're

00:02:11,250 --> 00:02:13,830
talking about at this conference but

00:02:12,780 --> 00:02:15,630
there's other example

00:02:13,830 --> 00:02:18,450
of domain-specific architectures it's

00:02:15,630 --> 00:02:21,900
the only path left why do they work it's

00:02:18,450 --> 00:02:24,090
not magic basically there's given that

00:02:21,900 --> 00:02:27,030
we're limited by power you want more

00:02:24,090 --> 00:02:29,130
power efficient solutions so single

00:02:27,030 --> 00:02:31,170
instruction multiple data that's more

00:02:29,130 --> 00:02:32,730
restrictive than multiple instruction

00:02:31,170 --> 00:02:34,590
multiple data but it's a lot more

00:02:32,730 --> 00:02:36,900
efficient too when you use it similarly

00:02:34,590 --> 00:02:39,660
very long instruction word versus the

00:02:36,900 --> 00:02:41,850
modern CPU of speculative out-of-order

00:02:39,660 --> 00:02:44,940
the first ones a lot more efficient if

00:02:41,850 --> 00:02:46,770
it works we optimize the memory

00:02:44,940 --> 00:02:49,020
bandwidth we don't just use caches where

00:02:46,770 --> 00:02:50,730
we're probabilistically guessing where

00:02:49,020 --> 00:02:53,100
the data Siddi it's under software

00:02:50,730 --> 00:02:54,780
control and we don't need the accuracy

00:02:53,100 --> 00:02:56,820
that you need for supercomputers nobody

00:02:54,780 --> 00:02:58,830
needs 64-bit floating-point you can even

00:02:56,820 --> 00:03:01,170
get away with narrower integers and how

00:02:58,830 --> 00:03:03,240
do you program these things you the

00:03:01,170 --> 00:03:05,870
domain-specific languages let's see do

00:03:03,240 --> 00:03:05,870
special purpose hardware

00:03:11,980 --> 00:03:14,040

YouTube URL: https://www.youtube.com/watch?v=c03Z0Ms8pKg


