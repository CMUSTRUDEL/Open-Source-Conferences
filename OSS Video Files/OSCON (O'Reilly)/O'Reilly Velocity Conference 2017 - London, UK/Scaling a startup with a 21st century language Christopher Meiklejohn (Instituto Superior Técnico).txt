Title: Scaling a startup with a 21st century language Christopher Meiklejohn (Instituto Superior TÃ©cnico)
Publication date: 2017-10-20
Playlist: O'Reilly Velocity Conference 2017 - London, UK
Description: 
	Christopher Meiklejohn is building an application that helps users select a bottle of wine based on the wines that they enjoy, using a new programming language called Martinelli. Christopher offers an overview of Martinelli, highlighting the key features of this new language that allow the fault-tolerant, highly scalable operation of his application.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:03,000 --> 00:00:06,750
so I've shown you this mythical

00:00:05,069 --> 00:00:07,799
programming language you're probably

00:00:06,750 --> 00:00:10,250
saying something like this can never

00:00:07,799 --> 00:00:13,619
exist let's first talk about what it is

00:00:10,250 --> 00:00:16,170
so first well say why does something

00:00:13,619 --> 00:00:17,940
like this hafta exist or why should it

00:00:16,170 --> 00:00:19,710
exist and the problem here is that

00:00:17,940 --> 00:00:21,210
everything I've shown you on the

00:00:19,710 --> 00:00:22,890
previous slides all of these things this

00:00:21,210 --> 00:00:24,420
peer-to-peer replication the database is

00:00:22,890 --> 00:00:26,220
the code on the client all these things

00:00:24,420 --> 00:00:27,870
I've shown you might seem like so

00:00:26,220 --> 00:00:29,820
amazing maybe they don't maybe some of

00:00:27,870 --> 00:00:30,930
you say yeah that's coming place but the

00:00:29,820 --> 00:00:32,610
interesting thing here is everything

00:00:30,930 --> 00:00:33,930
I've shown you exists today it doesn't

00:00:32,610 --> 00:00:35,489
exist under a single programming

00:00:33,930 --> 00:00:37,499
language but there are systems and

00:00:35,489 --> 00:00:39,359
algorithms there are papers and there

00:00:37,499 --> 00:00:40,800
there are prototypes and there are

00:00:39,359 --> 00:00:43,769
industry applications all of these

00:00:40,800 --> 00:00:45,839
things already exist ok the problem is

00:00:43,769 --> 00:00:48,329
that they exist in isolation and that

00:00:45,839 --> 00:00:50,819
means as developers our job is not only

00:00:48,329 --> 00:00:52,589
converting our business logic into an

00:00:50,819 --> 00:00:54,629
implementation but we also have to think

00:00:52,589 --> 00:00:56,909
about how that implementation maps to

00:00:54,629 --> 00:00:59,129
existing systems and how we glue those

00:00:56,909 --> 00:01:01,469
existing systems together and so it's

00:00:59,129 --> 00:01:03,179
application developers unfortunately the

00:01:01,469 --> 00:01:05,580
reality of it is is that we are

00:01:03,179 --> 00:01:07,860
responsible for gluing services together

00:01:05,580 --> 00:01:09,840
I might say my events come in two Kafka

00:01:07,860 --> 00:01:12,060
I may store that information in HDFS and

00:01:09,840 --> 00:01:15,840
maybe I do some learning on SPARC with

00:01:12,060 --> 00:01:18,390
it right and so Gerry Sussman basically

00:01:15,840 --> 00:01:21,630
when when MIT moved from scheme to

00:01:18,390 --> 00:01:23,430
Python said you know the change is is

00:01:21,630 --> 00:01:25,320
interesting is you know it makes sense

00:01:23,430 --> 00:01:27,120
because application together application

00:01:25,320 --> 00:01:28,680
developers today don't build things from

00:01:27,120 --> 00:01:30,210
scratch they don't build all of the

00:01:28,680 --> 00:01:31,560
stuff anymore what they do is they are

00:01:30,210 --> 00:01:33,450
really connecting the other existing

00:01:31,560 --> 00:01:34,830
libraries and this kind of rings true

00:01:33,450 --> 00:01:36,680
anybody who build an application we

00:01:34,830 --> 00:01:38,820
think about it as gluing things together

00:01:36,680 --> 00:01:40,670
now from an app from an academic

00:01:38,820 --> 00:01:42,780
perspective we don't like this at all

00:01:40,670 --> 00:01:44,880
what it means when you glue things

00:01:42,780 --> 00:01:46,350
together and you have API is the

00:01:44,880 --> 00:01:47,760
boundaries for gluing things together it

00:01:46,350 --> 00:01:49,410
means that you roughly have an ad hoc

00:01:47,760 --> 00:01:50,820
programming model this ad hoc

00:01:49,410 --> 00:01:53,430
programming model has very weak or

00:01:50,820 --> 00:01:55,230
unspecified semantics and largely these

00:01:53,430 --> 00:01:57,570
semantics are defined by implementation

00:01:55,230 --> 00:01:59,850
so as language designers we like to make

00:01:57,570 --> 00:02:00,750
semantics and implement them and you

00:01:59,850 --> 00:02:02,130
know when we think about service

00:02:00,750 --> 00:02:03,810
composition through API is what we do is

00:02:02,130 --> 00:02:05,640
we write an API we reverse-engineer the

00:02:03,810 --> 00:02:07,440
semantics can I plug this thing that

00:02:05,640 --> 00:02:09,269
uses exactly once messaging into this

00:02:07,440 --> 00:02:12,870
thing that uses a at most once messaging

00:02:09,269 --> 00:02:14,520
well I don't know maybe and so

00:02:12,870 --> 00:02:15,660
historically it's very interesting when

00:02:14,520 --> 00:02:16,860
you look at this because there have been

00:02:15,660 --> 00:02:18,720
systems that have tried

00:02:16,860 --> 00:02:21,450
right to do the pie-in-the-sky the

00:02:18,720 --> 00:02:23,730
Greenfield system most notably here I

00:02:21,450 --> 00:02:26,130
will talk about Argos Argos is a system

00:02:23,730 --> 00:02:27,840
by Barbara Liskov that was a Genesis to

00:02:26,130 --> 00:02:29,460
kind of a evolution of clue

00:02:27,840 --> 00:02:32,550
this system is one of the systems that

00:02:29,460 --> 00:02:34,680
kind of invented modern exception

00:02:32,550 --> 00:02:36,090
handling iterators come from the system

00:02:34,680 --> 00:02:38,100
promises if you've ever heard of those

00:02:36,090 --> 00:02:39,960
come from the system Argos is a

00:02:38,100 --> 00:02:42,540
Greenfield system for transactional

00:02:39,960 --> 00:02:44,250
fault tolerant or pcs transactional

00:02:42,540 --> 00:02:47,430
guarantees across services nobody is

00:02:44,250 --> 00:02:49,020
that nobody knows of it right nobody

00:02:47,430 --> 00:02:51,690
knows this nobody uses Argos here I'm

00:02:49,020 --> 00:02:53,370
sure Argos interestingly enough is the

00:02:51,690 --> 00:02:54,930
reason for X Windows existing I can tell

00:02:53,370 --> 00:02:57,000
you that story if you see me later and

00:02:54,930 --> 00:02:58,890
so these systems have no adoption

00:02:57,000 --> 00:03:01,560
what does have adoption while CORBA has

00:02:58,890 --> 00:03:03,660
adoption right historically and korva as

00:03:01,560 --> 00:03:04,950
anybody here is ever used Korver knows

00:03:03,660 --> 00:03:07,440
that Corbett is a nightmare

00:03:04,950 --> 00:03:09,480
it is terrible it is the idea that we

00:03:07,440 --> 00:03:10,500
can retrofit systems running different

00:03:09,480 --> 00:03:13,290
languages running different

00:03:10,500 --> 00:03:14,489
architectures middle and being big

00:03:13,290 --> 00:03:16,500
endian little area it doesn't matter

00:03:14,489 --> 00:03:18,570
will convert the formats relative

00:03:16,500 --> 00:03:20,010
pointers in memory who cares when I send

00:03:18,570 --> 00:03:21,390
you my data you can just store it in

00:03:20,010 --> 00:03:24,840
memory the same way so the pointers

00:03:21,390 --> 00:03:26,280
match up I mean this stuff is insane we

00:03:24,840 --> 00:03:31,010
never think about building a system this

00:03:26,280 --> 00:03:31,010
way but korba historically high adoption

00:03:37,030 --> 00:03:39,090

YouTube URL: https://www.youtube.com/watch?v=jfMp0dpQGPc


