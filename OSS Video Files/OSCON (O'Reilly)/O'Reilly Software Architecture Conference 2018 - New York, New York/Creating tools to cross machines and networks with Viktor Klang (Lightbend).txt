Title: Creating tools to cross machines and networks with Viktor Klang (Lightbend)
Publication date: 2018-02-28
Playlist: O'Reilly Software Architecture Conference 2018 - New York, New York
Description: 
	Join us in person at the O'Reilly Software Architecture Conference to learn the tools, techniques, and leadership skills needed in the evolving discipline of software architecture. Learn more: https://oreil.ly/2NNTQQK

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:00,030 --> 00:00:02,700
hi this is Mike Hendrickson from

00:00:01,350 --> 00:00:04,140
software architecture in New York City

00:00:02,700 --> 00:00:06,899
I'm here with Victor from like Ben

00:00:04,140 --> 00:00:07,919
Victor how you doing I'm good good so

00:00:06,899 --> 00:00:10,880
you're good

00:00:07,919 --> 00:00:14,309
what what's good what are you up to so

00:00:10,880 --> 00:00:17,460
I've been focusing lately over the past

00:00:14,309 --> 00:00:20,640
couple of years trying to find good ways

00:00:17,460 --> 00:00:23,070
of connecting software together both

00:00:20,640 --> 00:00:25,170
internally and externally trying to find

00:00:23,070 --> 00:00:29,609
good programming models fine trying to

00:00:25,170 --> 00:00:33,840
find good compromises between stuff like

00:00:29,609 --> 00:00:36,540
performance scalability resilience when

00:00:33,840 --> 00:00:38,489
you say connecting things together what

00:00:36,540 --> 00:00:41,730
what does that mean are you are you

00:00:38,489 --> 00:00:44,730
assembling language parts libraries

00:00:41,730 --> 00:00:46,710
tools frameworks platforms everything

00:00:44,730 --> 00:00:49,610
everything I think I think it's it's

00:00:46,710 --> 00:00:53,190
it's a bit of a it's a bit of a ladder

00:00:49,610 --> 00:00:55,410
and we connect things at multiple levels

00:00:53,190 --> 00:00:57,449
and the question is do we need different

00:00:55,410 --> 00:00:58,969
tools or different ways of thinking

00:00:57,449 --> 00:01:02,579
about connecting things together

00:00:58,969 --> 00:01:04,409
depending on at which point it is is it

00:01:02,579 --> 00:01:06,930
externally or is it internally within

00:01:04,409 --> 00:01:10,170
our program does that fundamentally

00:01:06,930 --> 00:01:13,140
matter which concerns do we have across

00:01:10,170 --> 00:01:17,159
these when we cross machines or when we

00:01:13,140 --> 00:01:18,780
cross networks philosophically even a

00:01:17,159 --> 00:01:21,360
single machine is a distributed system

00:01:18,780 --> 00:01:25,080
because everything is not in one single

00:01:21,360 --> 00:01:28,680
place so trying to find good tooling

00:01:25,080 --> 00:01:31,770
good programming api's try to tackle the

00:01:28,680 --> 00:01:34,439
challenges so when you say every machine

00:01:31,770 --> 00:01:36,030
is a distributed system distributive

00:01:34,439 --> 00:01:38,939
systems today are kind of like the dial

00:01:36,030 --> 00:01:41,130
tone aren't they I mean everything that

00:01:38,939 --> 00:01:44,850
most every company does is distributed

00:01:41,130 --> 00:01:47,850
yeah and perhaps and perhaps we've come

00:01:44,850 --> 00:01:49,799
to realize that and trying to embrace

00:01:47,850 --> 00:01:52,770
that fact instead of trying to create

00:01:49,799 --> 00:01:55,770
this illusion of it's like oxygen now

00:01:52,770 --> 00:02:00,119
right it's it's everywhere yeah and I

00:01:55,770 --> 00:02:03,750
think even even decades ago creating

00:02:00,119 --> 00:02:05,070
programs even if it was just between the

00:02:03,750 --> 00:02:07,259
operator of the machine and the machine

00:02:05,070 --> 00:02:09,690
itself it was still a distributed system

00:02:07,259 --> 00:02:12,060
between that operator and that computer

00:02:09,690 --> 00:02:14,709
so I think

00:02:12,060 --> 00:02:15,250
we just see see it at a different scale

00:02:14,709 --> 00:02:17,260
today

00:02:15,250 --> 00:02:19,959
so as you're assembling all these pieces

00:02:17,260 --> 00:02:22,980
and components and stuff together do you

00:02:19,959 --> 00:02:25,959
document that so that another person can

00:02:22,980 --> 00:02:28,720
understand what you've done and then use

00:02:25,959 --> 00:02:32,950
it for their so I do a lot of

00:02:28,720 --> 00:02:36,340
prototyping so this is really technical

00:02:32,950 --> 00:02:40,629
I think I don't believe in in just

00:02:36,340 --> 00:02:43,060
creating ideas or just thinking about

00:02:40,629 --> 00:02:45,700
stuff I think especially if if one wants

00:02:43,060 --> 00:02:48,220
to help others one needs to focus on the

00:02:45,700 --> 00:02:51,099
tooling and the only way of doing that

00:02:48,220 --> 00:02:54,870
is to actually create tooling so to try

00:02:51,099 --> 00:02:59,769
to experiment with programming api's I

00:02:54,870 --> 00:03:02,769
mean technically if you anything beyond

00:02:59,769 --> 00:03:08,049
what's just Turing complete is user

00:03:02,769 --> 00:03:10,030
experience because it is if all we

00:03:08,049 --> 00:03:12,489
needed was just something which was too

00:03:10,030 --> 00:03:14,439
incomplete then that wouldn't be a very

00:03:12,489 --> 00:03:17,079
good user experience and it wouldn't

00:03:14,439 --> 00:03:18,879
lead to maintainable systems and it's

00:03:17,079 --> 00:03:21,609
not only about creating a solution

00:03:18,879 --> 00:03:23,560
because the real work starts after you

00:03:21,609 --> 00:03:26,260
deploy it all the evolutions

00:03:23,560 --> 00:03:28,449
integrations over time changing

00:03:26,260 --> 00:03:30,310
elasticity and flexibility yeah

00:03:28,449 --> 00:03:32,500
and try to i mean the the entire thing

00:03:30,310 --> 00:03:35,440
behind software architecture is trying

00:03:32,500 --> 00:03:38,079
to figure out where the system needs to

00:03:35,440 --> 00:03:41,049
go right it's not about designing for

00:03:38,079 --> 00:03:42,760
today it's trying to design for how do

00:03:41,049 --> 00:03:45,220
we make it flexible where it needs to be

00:03:42,760 --> 00:03:46,569
flexible how do we where do we create

00:03:45,220 --> 00:03:48,970
scalability where it needs to be

00:03:46,569 --> 00:03:50,769
scalable and resiliency yeah they'll

00:03:48,970 --> 00:03:52,659
tend exactly

00:03:50,769 --> 00:03:55,709
so do you do you buy the notion that

00:03:52,659 --> 00:03:59,019
systems can be self-healing absolutely

00:03:55,709 --> 00:04:03,459
and and are we getting closer to that

00:03:59,019 --> 00:04:06,189
happening I would think we we are

00:04:03,459 --> 00:04:09,069
absolutely I mean the entire there's

00:04:06,189 --> 00:04:12,879
been a shift both in software delivery

00:04:09,069 --> 00:04:15,340
I'm making it focusing on being able to

00:04:12,879 --> 00:04:16,959
ship improvements rapidly but there's

00:04:15,340 --> 00:04:19,900
also being improvements in deploying

00:04:16,959 --> 00:04:23,020
things rapidly as well and I think at

00:04:19,900 --> 00:04:24,460
some point so Erlang has been doing it

00:04:23,020 --> 00:04:28,960
for a long time being able to sort of

00:04:24,460 --> 00:04:32,289
hold upgrade a application in place the

00:04:28,960 --> 00:04:34,270
actor model the even if the even if the

00:04:32,289 --> 00:04:36,490
core of it doesn't have the resilience

00:04:34,270 --> 00:04:38,639
built in there is the what we call a

00:04:36,490 --> 00:04:41,940
mandatory extension which is supervision

00:04:38,639 --> 00:04:45,550
which is essentially being able to

00:04:41,940 --> 00:04:47,530
divide work and being able to observe if

00:04:45,550 --> 00:04:49,270
it fails and if it fails we need to have

00:04:47,530 --> 00:04:55,090
a strategy for dealing with failure so

00:04:49,270 --> 00:04:57,370
it makes failures natural and the thing

00:04:55,090 --> 00:05:01,240
that you need is a way of dealing with

00:04:57,370 --> 00:05:03,520
it and not not sort of forgetting to

00:05:01,240 --> 00:05:05,050
deal with it or conveniently forgetting

00:05:03,520 --> 00:05:07,770
so it doesn't fester and then become

00:05:05,050 --> 00:05:12,699
catastrophic or something yeah or just

00:05:07,770 --> 00:05:15,310
creates issues some systems say they

00:05:12,699 --> 00:05:16,780
have a low rate of failure but if you

00:05:15,310 --> 00:05:19,449
increase the load then you're also

00:05:16,780 --> 00:05:21,400
increasing the the frequency of the

00:05:19,449 --> 00:05:23,409
failures so something which might be

00:05:21,400 --> 00:05:26,229
fine with a hundred users might not be

00:05:23,409 --> 00:05:32,099
fine at all with a thousand or 10,000 so

00:05:26,229 --> 00:05:34,210
I really believe in in thinking about

00:05:32,099 --> 00:05:37,090
resilience and dealing with failures

00:05:34,210 --> 00:05:39,669
upfront it's it's not really option so

00:05:37,090 --> 00:05:42,849
how important is actor based or actor

00:05:39,669 --> 00:05:46,630
oriented programming today is it growing

00:05:42,849 --> 00:05:50,919
is it yeah I would say that it is going

00:05:46,630 --> 00:05:53,500
absolutely I think there's many

00:05:50,919 --> 00:05:55,930
languages have both experimented with

00:05:53,500 --> 00:05:58,120
and many are looking to adopt actor

00:05:55,930 --> 00:06:02,289
style both the libraries and frameworks

00:05:58,120 --> 00:06:04,690
and even in the standard library Erlang

00:06:02,289 --> 00:06:07,850
has had it for a very long time akka was

00:06:04,690 --> 00:06:12,260
created about 10 years ago

00:06:07,850 --> 00:06:13,730
and there I think I think the the model

00:06:12,260 --> 00:06:15,860
is really appealing because it's a

00:06:13,730 --> 00:06:20,900
simple model are there domains that are

00:06:15,860 --> 00:06:22,010
more right for actor oriented that's a

00:06:20,900 --> 00:06:23,600
tricky question what do you mean by

00:06:22,010 --> 00:06:27,530
domain like a business domain or yeah

00:06:23,600 --> 00:06:28,610
like or like is aerospace or you know

00:06:27,530 --> 00:06:30,350
something that's more real-time

00:06:28,610 --> 00:06:33,590
components to it or something that's

00:06:30,350 --> 00:06:37,430
like a financial trading system or is it

00:06:33,590 --> 00:06:40,550
something that has more low requirements

00:06:37,430 --> 00:06:43,550
that are more flexible and easy I think

00:06:40,550 --> 00:06:45,800
anything that deals with concurrency

00:06:43,550 --> 00:06:49,580
having concurrent users or doing

00:06:45,800 --> 00:06:52,760
concurrent IO or I think virtually every

00:06:49,580 --> 00:06:56,210
single application or use case has those

00:06:52,760 --> 00:06:59,240
requirements so I don't see a specific

00:06:56,210 --> 00:07:01,520
domain good it's it's costing everything

00:06:59,240 --> 00:07:03,260
yeah and it's a universal model of

00:07:01,520 --> 00:07:06,410
computation so technically you could use

00:07:03,260 --> 00:07:08,450
it for for anything but of course with

00:07:06,410 --> 00:07:10,790
tooling it's always do you choose

00:07:08,450 --> 00:07:13,760
something specific for a specific use

00:07:10,790 --> 00:07:16,040
case do you adapt something to that

00:07:13,760 --> 00:07:17,510
specific use case or do you invent

00:07:16,040 --> 00:07:19,970
something for that use case it's always

00:07:17,510 --> 00:07:24,170
a trade-off which I think is interesting

00:07:19,970 --> 00:07:26,570
for a software architecture conference

00:07:24,170 --> 00:07:29,390
to to sort of think about we there's

00:07:26,570 --> 00:07:31,580
there's no single solution that will fit

00:07:29,390 --> 00:07:34,790
every use kid there's no there's no

00:07:31,580 --> 00:07:37,070
optimal general solution so try to find

00:07:34,790 --> 00:07:38,840
out those good trade-offs is a software

00:07:37,070 --> 00:07:41,180
architecture so speaking of a general

00:07:38,840 --> 00:07:42,470
solution so what do you think with all

00:07:41,180 --> 00:07:43,040
the software architects that are here

00:07:42,470 --> 00:07:45,440
this week

00:07:43,040 --> 00:07:48,290
what should keep them all up at night

00:07:45,440 --> 00:07:50,480
the most what is it that they're

00:07:48,290 --> 00:07:53,030
tackling on a day to day basis thing

00:07:50,480 --> 00:07:55,820
that they should grapple with every day

00:07:53,030 --> 00:07:58,790
and and and struggle with I mean what is

00:07:55,820 --> 00:08:00,760
it that's hard right now with that that

00:07:58,790 --> 00:08:03,040
job

00:08:00,760 --> 00:08:05,590
that's a great question I'm not sure

00:08:03,040 --> 00:08:10,030
that there is any sort of one so we have

00:08:05,590 --> 00:08:12,880
one answer to it I think my personal

00:08:10,030 --> 00:08:15,420
opinion is you always need to sort of

00:08:12,880 --> 00:08:18,840
figure out what's necessary for that

00:08:15,420 --> 00:08:23,950
specific domain or that specific

00:08:18,840 --> 00:08:26,110
industry or business and every every

00:08:23,950 --> 00:08:29,500
organization or every business has its

00:08:26,110 --> 00:08:32,130
sort of unique setup or unique

00:08:29,500 --> 00:08:37,240
requirements or unique composition of

00:08:32,130 --> 00:08:39,280
existing software and and different

00:08:37,240 --> 00:08:41,080
functions in the business so it's I

00:08:39,280 --> 00:08:46,930
don't I'm not sure earlier without

00:08:41,080 --> 00:08:49,690
learning from it I really believe in in

00:08:46,930 --> 00:08:53,680
in in doing and adapting and trying to

00:08:49,690 --> 00:08:55,240
find the right trade-offs but I think

00:08:53,680 --> 00:08:56,890
going back to what I said before I think

00:08:55,240 --> 00:08:59,620
it's software architecture is really

00:08:56,890 --> 00:09:01,690
about making the right trade-offs and

00:08:59,620 --> 00:09:03,520
that is the challenge that I think are

00:09:01,690 --> 00:09:06,160
those trade-offs still among the four I

00:09:03,520 --> 00:09:09,820
always look at four variables time cost

00:09:06,160 --> 00:09:12,460
quality and scope and are those four

00:09:09,820 --> 00:09:16,840
variables still at play in building

00:09:12,460 --> 00:09:18,400
software I think they are but it's

00:09:16,840 --> 00:09:20,950
because you never want to sacrifice

00:09:18,400 --> 00:09:23,350
quality right well so the thing is that

00:09:20,950 --> 00:09:26,110
it it's a very it depends on how you

00:09:23,350 --> 00:09:27,460
define quality you don't want to you

00:09:26,110 --> 00:09:30,190
don't want to build something which

00:09:27,460 --> 00:09:33,880
takes too long to seize the opportunity

00:09:30,190 --> 00:09:36,880
because you want yeah right

00:09:33,880 --> 00:09:38,560
first fabulous or something else I think

00:09:36,880 --> 00:09:40,770
it's really about finding the right

00:09:38,560 --> 00:09:45,280
trade-offs for that specific thing and

00:09:40,770 --> 00:09:48,490
sometimes it's about paying more upfront

00:09:45,280 --> 00:09:52,150
in order to get it out fast sometimes

00:09:48,490 --> 00:09:56,110
it's actually trying to do to do a

00:09:52,150 --> 00:09:59,290
smaller scope first I believe really in

00:09:56,110 --> 00:10:01,630
in trying stuff out it a prototype or a

00:09:59,290 --> 00:10:02,800
prototype make sure you have users make

00:10:01,630 --> 00:10:05,590
sure that you're solving the right

00:10:02,800 --> 00:10:07,270
problems oftentimes you can use your

00:10:05,590 --> 00:10:09,790
feedback yeah absolutely I mean

00:10:07,270 --> 00:10:12,640
oftentimes you find out that we

00:10:09,790 --> 00:10:17,800
you imagine that people want wanted or

00:10:12,640 --> 00:10:20,430
need it or or you just try to solve a a

00:10:17,800 --> 00:10:22,810
symptom rather than their actual problem

00:10:20,430 --> 00:10:25,720
and if you can focus on solving the

00:10:22,810 --> 00:10:26,850
actual problem and then so that sounds

00:10:25,720 --> 00:10:29,080
like going back to the real

00:10:26,850 --> 00:10:31,540
specification requirement stage like

00:10:29,080 --> 00:10:34,270
really knowing what it is you're solving

00:10:31,540 --> 00:10:39,400
before you start well it's a bit of a

00:10:34,270 --> 00:10:41,470
catch-22 so I really believe in if you

00:10:39,400 --> 00:10:43,090
do if you're doing protocols or if

00:10:41,470 --> 00:10:44,650
you're doing trying to do a standard or

00:10:43,090 --> 00:10:46,750
something like that you really want to

00:10:44,650 --> 00:10:48,580
have a specification but you can only

00:10:46,750 --> 00:10:52,150
get to that specification by trying

00:10:48,580 --> 00:10:55,180
stuff out oftentimes you have five or

00:10:52,150 --> 00:10:57,340
ten or even more different permutations

00:10:55,180 --> 00:11:00,940
of trade-offs and you end up with a

00:10:57,340 --> 00:11:03,150
specification that's sort of hybrid a

00:11:00,940 --> 00:11:06,310
hybrid or a Rankine Stein or what

00:11:03,150 --> 00:11:08,800
sometimes like you end up with something

00:11:06,310 --> 00:11:11,770
but I think specifying up front does

00:11:08,800 --> 00:11:13,690
never work and just putting something

00:11:11,770 --> 00:11:15,340
together and not standardizing it

00:11:13,690 --> 00:11:17,440
doesn't really help you down the line

00:11:15,340 --> 00:11:20,380
because now I have this sort of

00:11:17,440 --> 00:11:22,060
canonical specification which is the

00:11:20,380 --> 00:11:23,650
implementation and then it's hard to

00:11:22,060 --> 00:11:25,810
know whether something was intentional

00:11:23,650 --> 00:11:30,850
or whether it just turned out that way

00:11:25,810 --> 00:11:35,980
so especially as I've been doing a bit

00:11:30,850 --> 00:11:39,430
of specification work and iterate get it

00:11:35,980 --> 00:11:42,370
get feedback you never know like if you

00:11:39,430 --> 00:11:44,290
specify something you don't know whether

00:11:42,370 --> 00:11:46,210
it's going to put some constraints on

00:11:44,290 --> 00:11:47,890
how you implement it is it possible to

00:11:46,210 --> 00:11:50,380
implement implement this in a performant

00:11:47,890 --> 00:11:52,510
way is it possible to extend this in an

00:11:50,380 --> 00:11:54,640
in a sensible way so you really need to

00:11:52,510 --> 00:11:56,380
I think you really need to iterate on a

00:11:54,640 --> 00:11:59,440
specification to end up with something

00:11:56,380 --> 00:12:02,050
that really matches what you what do you

00:11:59,440 --> 00:12:04,120
aim for so Victor last question for me

00:12:02,050 --> 00:12:07,120
so we don't want to generalize what

00:12:04,120 --> 00:12:09,220
keeps all the architects up at night but

00:12:07,120 --> 00:12:11,770
what keeps you up at night what what is

00:12:09,220 --> 00:12:12,540
that you're trying to tackle that maybe

00:12:11,770 --> 00:12:15,750
a

00:12:12,540 --> 00:12:18,660
hard nut to crack and you're trying to

00:12:15,750 --> 00:12:22,530
figure out how am I going to do this or

00:12:18,660 --> 00:12:24,600
what what is it keeps you up so what

00:12:22,530 --> 00:12:29,340
I've been trying to do the past decade

00:12:24,600 --> 00:12:30,870
is trying to eliminate the perception

00:12:29,340 --> 00:12:35,520
that there is a trade-off to be made

00:12:30,870 --> 00:12:40,070
between productivity and scalability

00:12:35,520 --> 00:12:42,840
I think there's there is no inherent

00:12:40,070 --> 00:12:44,400
inherent compromise between the two I

00:12:42,840 --> 00:12:48,390
think you can really get productivity

00:12:44,400 --> 00:12:50,010
and scalability so that's what keeps me

00:12:48,390 --> 00:12:51,450
up at night can we get a trade-off

00:12:50,010 --> 00:12:52,880
between there isn't you don't think you

00:12:51,450 --> 00:12:54,990
see there's yeah

00:12:52,880 --> 00:12:58,200
you shouldn't have to trade those yeah

00:12:54,990 --> 00:12:59,640
because it's always when some some

00:12:58,200 --> 00:13:04,380
organization when some person creates

00:12:59,640 --> 00:13:06,330
something and makes a lot of trade-offs

00:13:04,380 --> 00:13:09,510
just to get something out there and then

00:13:06,330 --> 00:13:11,670
they have to rewrite it when they're

00:13:09,510 --> 00:13:14,580
successful when they really should be

00:13:11,670 --> 00:13:16,440
sort of adding features or making the

00:13:14,580 --> 00:13:18,000
most of this successful thing and they

00:13:16,440 --> 00:13:20,340
end up having to do this sort of that

00:13:18,000 --> 00:13:22,470
the the great rewrite could that be

00:13:20,340 --> 00:13:25,290
slowing down when they're going from the

00:13:22,470 --> 00:13:27,360
beginning or so yeah so what I'm trying

00:13:25,290 --> 00:13:30,000
to do is to find the the programming

00:13:27,360 --> 00:13:32,670
models and the the api's and the ways of

00:13:30,000 --> 00:13:35,160
thinking about things such that you get

00:13:32,670 --> 00:13:38,700
really good productivity from from day

00:13:35,160 --> 00:13:40,890
one and you also get the scalability so

00:13:38,700 --> 00:13:43,470
if this thing really becomes successful

00:13:40,890 --> 00:13:46,830
then you can it can grow with the

00:13:43,470 --> 00:13:49,650
success so that's that's been my

00:13:46,830 --> 00:13:51,090
personal goal for the past decade well

00:13:49,650 --> 00:13:54,020
we look forward to seeing how that turns

00:13:51,090 --> 00:13:54,020

YouTube URL: https://www.youtube.com/watch?v=zTGc8HhnkRQ


