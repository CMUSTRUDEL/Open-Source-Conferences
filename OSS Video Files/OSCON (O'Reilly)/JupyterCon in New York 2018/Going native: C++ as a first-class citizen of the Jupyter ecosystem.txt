Title: Going native: C++ as a first-class citizen of the Jupyter ecosystem
Publication date: 2018-09-28
Playlist: JupyterCon in New York 2018
Description: 
	Going native: C++ as a first-class citizen of the Jupyter ecosystem - Sylvain Corlay (QuantStack), Johan Mabille (QuantStack), Wolf Vollprecht (QuantStack), Martin Renou 

Sylvain Corlay, Johan Mabille, Wolf Vollprecht, and Martin Renou share the latest features of the C++ Jupyter kernel, including live help, auto-completion, rich MIME type rendering, and interactive widgets. Join in to explore one of the most feature-full implementations of the Jupyter kernel protocol that also brings Jupyter closer to the metal.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:01,630 --> 00:00:06,100
hi everyone thank you for being here let

00:00:04,630 --> 00:00:08,500
me tell you a bit more about who we are

00:00:06,100 --> 00:00:12,190
and what we are actually so once that is

00:00:08,500 --> 00:00:15,010
a team of open source developers working

00:00:12,190 --> 00:00:16,840
in scientific computing software the

00:00:15,010 --> 00:00:18,880
software that we build is generally in

00:00:16,840 --> 00:00:21,279
the tricular ecosystem the team

00:00:18,880 --> 00:00:25,079
comprises core developers of several

00:00:21,279 --> 00:00:28,599
packages on sub projects of GPO and

00:00:25,079 --> 00:00:33,850
other tools such as Kronos visualization

00:00:28,599 --> 00:00:36,580
libraries and whatnot so we are based in

00:00:33,850 --> 00:00:40,090
Paris and we are a distributed team

00:00:36,580 --> 00:00:42,280
that's fairly international so if you're

00:00:40,090 --> 00:00:44,740
looking for experts in the field reach

00:00:42,280 --> 00:00:48,970
out to us and we'll be happy to to

00:00:44,740 --> 00:00:51,910
respond the project leader was really

00:00:48,970 --> 00:00:53,890
meant to be a set of tools to improve

00:00:51,910 --> 00:00:55,980
and unify scientific computing workflows

00:00:53,890 --> 00:01:00,070
so it's an interface between metal and

00:00:55,980 --> 00:01:01,540
humans flesh and metal so from day one

00:01:00,070 --> 00:01:04,180
it was developed by scientists for

00:01:01,540 --> 00:01:06,520
scientists and educators and it really

00:01:04,180 --> 00:01:08,289
shines at interactive workflow so

00:01:06,520 --> 00:01:11,219
programming language they are not only

00:01:08,289 --> 00:01:14,499
used to build systems and complex

00:01:11,219 --> 00:01:18,340
machineries but also to explore and gain

00:01:14,499 --> 00:01:20,920
insight on a company resource data set

00:01:18,340 --> 00:01:22,479
the outcome of a simulation so

00:01:20,920 --> 00:01:24,670
interactive workflows like Gerry Boggs

00:01:22,479 --> 00:01:28,210
is where you load some data you run some

00:01:24,670 --> 00:01:30,929
code you show a visualization and run

00:01:28,210 --> 00:01:32,200
some more code and you loop over right

00:01:30,929 --> 00:01:33,700
Wow

00:01:32,200 --> 00:01:35,799
the super says programming language is

00:01:33,700 --> 00:01:37,600
really strong in the scientific

00:01:35,799 --> 00:01:39,670
computing ecosystem because it was

00:01:37,600 --> 00:01:41,679
really tailored for performance it has a

00:01:39,670 --> 00:01:46,270
massive community and they're especially

00:01:41,679 --> 00:01:48,549
strong in HPC but it lacks a good story

00:01:46,270 --> 00:01:50,350
for interactive computing and this first

00:01:48,549 --> 00:01:52,779
productivity of C++ software developers

00:01:50,350 --> 00:01:54,850
so cheap as fast is generally considered

00:01:52,779 --> 00:01:59,859
a difficult problem in language to teach

00:01:54,850 --> 00:02:02,139
and learn it has a fairly heterogeneous

00:01:59,859 --> 00:02:02,799
set of tools that don't always play well

00:02:02,139 --> 00:02:05,950
together

00:02:02,799 --> 00:02:09,600
and it makes scientific workflows harder

00:02:05,950 --> 00:02:12,640
to reproduce so that's why we decided to

00:02:09,600 --> 00:02:14,750
attack this problem and we developed the

00:02:12,640 --> 00:02:17,330
exuse clean C++ can also

00:02:14,750 --> 00:02:19,550
it is actually a chronal for project

00:02:17,330 --> 00:02:21,320
computer that allows you to use the

00:02:19,550 --> 00:02:24,050
series of programming language in the

00:02:21,320 --> 00:02:27,050
Egyptian notebook and other tools so

00:02:24,050 --> 00:02:29,390
it's built upon the exuse library what

00:02:27,050 --> 00:02:31,760
this is is a modern C++ implementation

00:02:29,390 --> 00:02:34,580
of the Jupiter protocol it is not the

00:02:31,760 --> 00:02:36,410
coroner itself it is a library meant to

00:02:34,580 --> 00:02:38,300
build Kronos so there are a number of

00:02:36,410 --> 00:02:39,530
commands that were built with juice one

00:02:38,300 --> 00:02:41,330
is the one that we're going to present

00:02:39,530 --> 00:02:43,580
today but there is also another acronym

00:02:41,330 --> 00:02:46,400
called Juniper chrono and there is a

00:02:43,580 --> 00:02:50,600
alternative Patinkin on being currently

00:02:46,400 --> 00:02:53,180
built at kitware and so Zeus clean uses

00:02:50,600 --> 00:02:55,580
Zeus for the common protocol and the

00:02:53,180 --> 00:02:58,550
clean C++ interpreter that comes out

00:02:55,580 --> 00:03:02,060
from sir so I'm going to leave the stage

00:02:58,550 --> 00:03:05,270
to the team now and let you let them

00:03:02,060 --> 00:03:13,370
present Chris clean and a few that force

00:03:05,270 --> 00:03:16,760
that will build upon it so thank you for

00:03:13,370 --> 00:03:21,140
this nice prediction now let's jump into

00:03:16,760 --> 00:03:23,630
the pool and see how you can use this

00:03:21,140 --> 00:03:25,430
nice zoo screen Colonel so the first

00:03:23,630 --> 00:03:27,290
thing you want to do when you do some

00:03:25,430 --> 00:03:27,860
interactive flow is just be able to

00:03:27,290 --> 00:03:30,260
print things

00:03:27,860 --> 00:03:35,750
so in Cypress press that means be able

00:03:30,260 --> 00:03:37,820
to see out and zero so this it works it

00:03:35,750 --> 00:03:40,940
might be long to type if you want just

00:03:37,820 --> 00:03:42,860
to inspect some variable so can just

00:03:40,940 --> 00:03:45,170
define variable and then if you omit the

00:03:42,860 --> 00:03:48,230
last semicolon get the content of your

00:03:45,170 --> 00:03:49,970
values here this go further you can

00:03:48,230 --> 00:03:53,390
inspect more complicated objects so

00:03:49,970 --> 00:03:57,019
let's say you map I don't know guys if

00:03:53,390 --> 00:03:59,330
you used a burger like 90 but trying to

00:03:57,019 --> 00:04:02,209
get values of map inside this video is

00:03:59,330 --> 00:04:05,000
just nightmare so you have to go through

00:04:02,209 --> 00:04:09,049
a lot of internal stretches so here just

00:04:05,000 --> 00:04:13,910
for ways simpler this switch output I

00:04:09,049 --> 00:04:17,330
can be used to sorry just I'm already

00:04:13,910 --> 00:04:20,560
finding and you okay okay so that was

00:04:17,330 --> 00:04:25,280
map we can also use that which display

00:04:20,560 --> 00:04:26,430
for image so here on this plane image

00:04:25,280 --> 00:04:28,470
notice

00:04:26,430 --> 00:04:30,810
it's quite simple so basically we just

00:04:28,470 --> 00:04:32,430
define a small function here called the

00:04:30,810 --> 00:04:34,800
my model representation so you can

00:04:32,430 --> 00:04:37,530
define your own for your own objects and

00:04:34,800 --> 00:04:39,660
just return a JSON object based on what

00:04:37,530 --> 00:04:43,889
how you want representing and get a

00:04:39,660 --> 00:04:45,840
release by Orkut so that for display now

00:04:43,889 --> 00:04:48,660
obviously are the super sports cars is

00:04:45,840 --> 00:04:51,090
just floating all the features of super

00:04:48,660 --> 00:04:53,460
spirit so you can define functions use

00:04:51,090 --> 00:04:56,550
them of course you can also define a

00:04:53,460 --> 00:05:00,570
class like few class with the print

00:04:56,550 --> 00:05:02,160
function words which polymorphism

00:05:00,570 --> 00:05:03,780
meaning I can define a narrating class

00:05:02,160 --> 00:05:07,380
from food and overload the print

00:05:03,780 --> 00:05:10,800
behavior so yeah we just print bar value

00:05:07,380 --> 00:05:13,020
inside of foo video so it works okay one

00:05:10,800 --> 00:05:16,470
dive into details which sports templates

00:05:13,020 --> 00:05:19,139
and template specialization we should

00:05:16,470 --> 00:05:23,210
open so most of the modern cyberspace

00:05:19,139 --> 00:05:28,169
features so basically move semantics

00:05:23,210 --> 00:05:29,699
which supports Oh to new syntax and a

00:05:28,169 --> 00:05:32,789
lot more like lambda universal

00:05:29,699 --> 00:05:35,940
references and everything another thing

00:05:32,789 --> 00:05:38,610
that is missing in most of the ideas is

00:05:35,940 --> 00:05:41,610
inline documentation just you don't want

00:05:38,610 --> 00:05:45,599
to switch now so go on gross things so

00:05:41,610 --> 00:05:48,570
we provide a question one thing and then

00:05:45,599 --> 00:05:52,919
it's just keeping taking documentation

00:05:48,570 --> 00:05:55,550
on red dogs so you get a real good page

00:05:52,919 --> 00:05:57,960
here so I can just scroll down I can

00:05:55,550 --> 00:06:00,660
follow link to see what's in the

00:05:57,960 --> 00:06:02,669
commutation and you can extend and add

00:06:00,660 --> 00:06:04,199
your own files for the community in your

00:06:02,669 --> 00:06:07,410
own libraries inside your screen to read

00:06:04,199 --> 00:06:10,020
simple last features that is present in

00:06:07,410 --> 00:06:12,960
most of all the modern IDs it's type

00:06:10,020 --> 00:06:16,889
compression so here I can just eat tab

00:06:12,960 --> 00:06:23,030
key and completes through with something

00:06:16,889 --> 00:06:23,030
like we live and where everyone's sorry

00:06:23,910 --> 00:06:31,690
yeah basically so that for the Zeus king

00:06:28,570 --> 00:06:33,880
so now researched and research engineers

00:06:31,690 --> 00:06:36,100
scientists RIT they can just interact

00:06:33,880 --> 00:06:38,290
and explore the program teachers happy

00:06:36,100 --> 00:06:40,540
they can just teach surplus place

00:06:38,290 --> 00:06:43,060
without having students win so a lot of

00:06:40,540 --> 00:06:45,430
tools to just be able to compare things

00:06:43,060 --> 00:06:48,460
but start to interact with their

00:06:45,430 --> 00:06:50,830
programs and quickly they want to do

00:06:48,460 --> 00:06:52,330
some scientific comparing so they need

00:06:50,830 --> 00:06:55,540
some scientific data structures and

00:06:52,330 --> 00:07:04,510
that's what Wolfe is going to show you

00:06:55,540 --> 00:07:07,000
now so yeah we've developed the solution

00:07:04,510 --> 00:07:09,760
for that and the name is X sensor and

00:07:07,000 --> 00:07:14,310
what extensor is when you the short

00:07:09,760 --> 00:07:14,310
pitch is extensor is numpy in C++ and

00:07:14,790 --> 00:07:19,540
extensor is basically a libraries for

00:07:16,990 --> 00:07:21,160
for people who build libraries so you

00:07:19,540 --> 00:07:23,860
can use extensors to build your

00:07:21,160 --> 00:07:26,919
numerical algorithms and your high

00:07:23,860 --> 00:07:30,010
performance computing stack on top of on

00:07:26,919 --> 00:07:32,530
top of this library and Accenture is a

00:07:30,010 --> 00:07:36,370
couple of things and accessor is fast

00:07:32,530 --> 00:07:39,220
for one and it's fast because of what

00:07:36,370 --> 00:07:41,650
because it's easy to use and it's very

00:07:39,220 --> 00:07:45,789
familiar because we stick with the numpy

00:07:41,650 --> 00:07:48,010
api for the most part and most of the

00:07:45,789 --> 00:07:49,270
like a lot of the data scientists

00:07:48,010 --> 00:07:51,820
nowadays are really familiar with an

00:07:49,270 --> 00:07:53,860
ample API and people coming from MATLAB

00:07:51,820 --> 00:07:56,590
are also pretty familiar with another

00:07:53,860 --> 00:07:59,020
API and so we keep the same concise

00:07:56,590 --> 00:08:03,250
syntax and the same abstractions that

00:07:59,020 --> 00:08:04,870
you get in the Napa API plus we emulate

00:08:03,250 --> 00:08:07,389
concepts like the views that you have

00:08:04,870 --> 00:08:10,090
numpy which is super convenient and the

00:08:07,389 --> 00:08:12,700
broadcasting but at the same time we are

00:08:10,090 --> 00:08:15,400
aiming for speed so we extender is an

00:08:12,700 --> 00:08:19,539
expression template based library so we

00:08:15,400 --> 00:08:23,200
fuse all the loops etc and so extensors

00:08:19,539 --> 00:08:26,590
is fast to execute and we benchmarked a

00:08:23,200 --> 00:08:29,229
lot we have a friend his name is search

00:08:26,590 --> 00:08:34,140
and he developed the Python transpiler

00:08:29,229 --> 00:08:37,000
from pison to C++ and from numpy to C++

00:08:34,140 --> 00:08:40,320
and so he made a big benchmark

00:08:37,000 --> 00:08:42,700
and we are trying to compete with them

00:08:40,320 --> 00:08:45,280
and as you can see we are already doing

00:08:42,700 --> 00:08:47,980
a lot better than Tyson and numpy and we

00:08:45,280 --> 00:08:50,350
are working our way up to the top in

00:08:47,980 --> 00:08:53,110
these benchmarks and extensors is fast

00:08:50,350 --> 00:08:54,910
to extent and with that I mean that

00:08:53,110 --> 00:08:57,340
extensor is not just a monolithic

00:08:54,910 --> 00:09:01,120
package like some of the traditional

00:08:57,340 --> 00:09:03,750
libraries that you have for HPC and

00:09:01,120 --> 00:09:06,310
linear algebra in C++ but rather

00:09:03,750 --> 00:09:09,010
extensor comprises of a lot of smaller

00:09:06,310 --> 00:09:10,930
packages so one of the foundational

00:09:09,010 --> 00:09:13,750
packages of extensive speeds is X s and

00:09:10,930 --> 00:09:17,530
E which offers parallelized algorithms

00:09:13,750 --> 00:09:19,060
on the standard math functions and the

00:09:17,530 --> 00:09:21,640
arithmetic functions so for example we

00:09:19,060 --> 00:09:24,490
have a paralyzed implementations of

00:09:21,640 --> 00:09:27,280
trigonometric functions etc and then we

00:09:24,490 --> 00:09:29,440
have X in the blast which builds bridge

00:09:27,280 --> 00:09:32,020
to the existing blast libraries with

00:09:29,440 --> 00:09:35,650
their high performance metrics products

00:09:32,020 --> 00:09:39,430
and dot products etc we have X and Rio

00:09:35,650 --> 00:09:41,530
which makes super simple to to import

00:09:39,430 --> 00:09:44,320
and export images or audio files or

00:09:41,530 --> 00:09:45,820
numpy data and there are some

00:09:44,320 --> 00:09:48,130
third-party packages like extensor

00:09:45,820 --> 00:09:50,740
interpolate and fftw which offer

00:09:48,130 --> 00:09:53,530
interpolation of splines or fast fluid

00:09:50,740 --> 00:09:55,240
transformations and there's a growing

00:09:53,530 --> 00:09:56,740
ecosystems of third-party libraries

00:09:55,240 --> 00:09:58,960
which are starting to use Accenture like

00:09:56,740 --> 00:10:01,410
machine learning libraries or finite

00:09:58,960 --> 00:10:05,230
element methods new data formats etc

00:10:01,410 --> 00:10:08,740
they are all building their ideas on top

00:10:05,230 --> 00:10:11,740
of X sensor a next sensor is also C++

00:10:08,740 --> 00:10:13,030
first we we want we don't want to repeat

00:10:11,740 --> 00:10:15,220
the mistake of building a library that

00:10:13,030 --> 00:10:16,870
should be foundational that is not

00:10:15,220 --> 00:10:20,220
useable from the from the implementation

00:10:16,870 --> 00:10:23,050
language itself so for example non-price

00:10:20,220 --> 00:10:25,300
core librarians are not super easy to

00:10:23,050 --> 00:10:27,280
use from C from the sea side but we want

00:10:25,300 --> 00:10:30,520
our library to be super easy to use from

00:10:27,280 --> 00:10:31,950
the C++ side itself but we also say that

00:10:30,520 --> 00:10:35,890
pice injury and our should come first

00:10:31,950 --> 00:10:37,660
because we want the entire ecosystem to

00:10:35,890 --> 00:10:39,100
be able to use our libraries and we

00:10:37,660 --> 00:10:42,760
built this box with the interoperability

00:10:39,100 --> 00:10:45,910
in mind and what's in the next container

00:10:42,760 --> 00:10:49,540
so with X container you get which is the

00:10:45,910 --> 00:10:50,649
base class of all data structures you

00:10:49,540 --> 00:10:53,470
get native support for

00:10:50,649 --> 00:10:55,689
row major and column major data storage

00:10:53,470 --> 00:10:57,430
so for example seen Tyson I using row

00:10:55,689 --> 00:11:00,100
major and column major is used in Julia

00:10:57,430 --> 00:11:03,579
and MATLAB and Fortran etc and you have

00:11:00,100 --> 00:11:05,740
a couple of different data structures to

00:11:03,579 --> 00:11:09,069
store your shapes in which you know for

00:11:05,740 --> 00:11:10,899
really strong optimizations new C++

00:11:09,069 --> 00:11:13,740
compiler and I'm gonna demonstrate you a

00:11:10,899 --> 00:11:17,129
bit how extensive looks similar to numpy

00:11:13,740 --> 00:11:20,889
so here we're just using the exist cling

00:11:17,129 --> 00:11:22,959
book and I'm not I'm going to create an

00:11:20,889 --> 00:11:24,550
x-ray from an a range people who know

00:11:22,959 --> 00:11:28,600
numpy know what an a range is just a

00:11:24,550 --> 00:11:32,069
linear vector of numbers from 0 to 20

00:11:28,600 --> 00:11:34,689
then I'm going to reshape it to metrics

00:11:32,069 --> 00:11:37,480
3 by 3 and then I'm gonna use some

00:11:34,689 --> 00:11:40,059
function on it so when multiplying with

00:11:37,480 --> 00:11:42,249
2 and then taking the sign of it and

00:11:40,059 --> 00:11:43,480
then I can define another x-ray which

00:11:42,249 --> 00:11:45,389
has three elements and it's one

00:11:43,480 --> 00:11:48,579
dimensional and then I broadcasted over

00:11:45,389 --> 00:11:50,019
over the defined metrics so it's the

00:11:48,579 --> 00:11:53,319
same broadcasting semantics this numpy

00:11:50,019 --> 00:11:56,139
has or we can take a view on this

00:11:53,319 --> 00:11:59,050
function actually and extract the column

00:11:56,139 --> 00:12:01,269
of it and now what we also can do is we

00:11:59,050 --> 00:12:02,980
can write the functions so here I'm

00:12:01,269 --> 00:12:05,980
defining a function that computes the

00:12:02,980 --> 00:12:08,410
sum of sines so I'm have an expression

00:12:05,980 --> 00:12:12,370
here to compute the sine of our input M

00:12:08,410 --> 00:12:13,749
and then we could use the extended

00:12:12,370 --> 00:12:16,779
function which is called some just like

00:12:13,749 --> 00:12:19,839
an umpire or we can use sed functions

00:12:16,779 --> 00:12:22,420
from the C++ SEL just like I accumulate

00:12:19,839 --> 00:12:24,519
from the beginning to the end in

00:12:22,420 --> 00:12:25,269
iterator so for people for me always

00:12:24,519 --> 00:12:28,389
super-stressful

00:12:25,269 --> 00:12:32,439
know and love this and now we can call

00:12:28,389 --> 00:12:33,240
this with with an a range and we get the

00:12:32,439 --> 00:12:35,769
correct result

00:12:33,240 --> 00:12:38,350
so what I'm going to do now is I'm gonna

00:12:35,769 --> 00:12:42,069
write this into a demo sleepless CPP

00:12:38,350 --> 00:12:44,679
file and export it so I have our written

00:12:42,069 --> 00:12:48,549
demo CPP was this function definition

00:12:44,679 --> 00:12:49,660
and I'm going to all the kernels so all

00:12:48,549 --> 00:12:51,999
the kernels is actually a kind of

00:12:49,660 --> 00:12:54,249
multiplexer so what we have here is we

00:12:51,999 --> 00:12:56,709
can run any kernel that I have installed

00:12:54,249 --> 00:12:58,540
so with this line and at the top I

00:12:56,709 --> 00:13:02,139
defined that I want to run the cell and

00:12:58,540 --> 00:13:03,830
exists cling cpp 14 and what i'm doing

00:13:02,139 --> 00:13:05,630
here is i

00:13:03,830 --> 00:13:08,090
include the demo CPP file that I just

00:13:05,630 --> 00:13:09,500
created in the other notebook and I

00:13:08,090 --> 00:13:11,420
write some stuff and I call it with the

00:13:09,500 --> 00:13:13,340
air wrench again and you see it's

00:13:11,420 --> 00:13:15,980
executing it's compiling and executing

00:13:13,340 --> 00:13:18,680
and we get the same result as before so

00:13:15,980 --> 00:13:20,030
now I was trying to I will try to

00:13:18,680 --> 00:13:23,770
demonstrate an integration that I was

00:13:20,030 --> 00:13:26,630
talking about so here we see some code

00:13:23,770 --> 00:13:29,300
for pison we want to export this

00:13:26,630 --> 00:13:31,610
function out to the Python runtime so we

00:13:29,300 --> 00:13:36,500
can use extender pison and 5 and 11 and

00:13:31,610 --> 00:13:38,900
I'm gonna append this wrapper code here

00:13:36,500 --> 00:13:41,570
with the Piney level module I'm defining

00:13:38,900 --> 00:13:43,360
a next pison module I import numpy and I

00:13:41,570 --> 00:13:47,680
define the sum of science function here

00:13:43,360 --> 00:13:52,270
on a pirate and with this

00:13:47,680 --> 00:13:57,830
I've now I see the I've written the file

00:13:52,270 --> 00:14:02,030
now we see we execute the Python 3 cell

00:13:57,830 --> 00:14:05,690
here I'm gonna use bash to compile the

00:14:02,030 --> 00:14:08,660
bash magic to compile with GCC and I can

00:14:05,690 --> 00:14:10,400
import X PRIZE in here I can import the

00:14:08,660 --> 00:14:12,590
sum of science function and call it on

00:14:10,400 --> 00:14:15,290
an umpire range so this is seamless

00:14:12,590 --> 00:14:18,590
without copying the buffer of numpy we

00:14:15,290 --> 00:14:20,540
have the same results and that makes for

00:14:18,590 --> 00:14:22,160
high speed and we can do the same for

00:14:20,540 --> 00:14:25,190
our for our we're using a different

00:14:22,160 --> 00:14:27,440
package called our CPP which makes it

00:14:25,190 --> 00:14:29,810
super simple we have extensor our and

00:14:27,440 --> 00:14:32,240
our CPP we again define the sum of

00:14:29,810 --> 00:14:36,320
science function here we take as an

00:14:32,240 --> 00:14:40,250
input in our array I call this I use

00:14:36,320 --> 00:14:42,320
source CPP to import the just written X

00:14:40,250 --> 00:14:44,750
our file and I can call it with this is

00:14:42,320 --> 00:14:46,670
the arf for a range the our code for a

00:14:44,750 --> 00:14:48,590
range I call it over this array and I

00:14:46,670 --> 00:14:49,820
get the same result again and now just

00:14:48,590 --> 00:14:52,430
to demonstrate that we can do the same

00:14:49,820 --> 00:14:55,850
with Julia as well patria we're using 6

00:14:52,430 --> 00:14:59,330
wrap and it takes them good to compile

00:14:55,850 --> 00:15:00,860
again but here we go so we have made one

00:14:59,330 --> 00:15:03,710
function that we can call from three

00:15:00,860 --> 00:15:06,320
different languages of data science so

00:15:03,710 --> 00:15:09,380
all of the people that love code and

00:15:06,320 --> 00:15:11,990
text are happy now but sometimes you

00:15:09,380 --> 00:15:13,550
gotta have some visualizations to

00:15:11,990 --> 00:15:15,560
justify your existence to the management

00:15:13,550 --> 00:15:19,170
so

00:15:15,560 --> 00:15:23,130
so an important part of the Jupiter

00:15:19,170 --> 00:15:26,580
ecosystem is the entire interactive

00:15:23,130 --> 00:15:29,610
widget so we wanted to have simple

00:15:26,580 --> 00:15:33,660
superfluous widget as well so basically

00:15:29,610 --> 00:15:38,850
how I per widget is is implemented is we

00:15:33,660 --> 00:15:42,270
you have a Python module which is a thin

00:15:38,850 --> 00:15:45,840
part of the implementation and you have

00:15:42,270 --> 00:15:49,650
a thick part of the implementation which

00:15:45,840 --> 00:15:53,520
is the front end so in C++ we could for

00:15:49,650 --> 00:15:58,170
example reuse out of the front-end part

00:15:53,520 --> 00:16:01,890
and only implement the model so that's

00:15:58,170 --> 00:16:04,950
what we did with X widget which is a C++

00:16:01,890 --> 00:16:12,240
back-end for hyper-v jet so I'm going to

00:16:04,950 --> 00:16:15,510
show it to you right now sorry so X

00:16:12,240 --> 00:16:22,980
widgets I can for example create a

00:16:15,510 --> 00:16:26,970
button in C++ so I link a callback to

00:16:22,980 --> 00:16:29,220
this button and in this callback I will

00:16:26,970 --> 00:16:35,870
change the description of the button so

00:16:29,220 --> 00:16:41,550
if I click on it it changes I can create

00:16:35,870 --> 00:16:50,670
a numerical widget like that so I can

00:16:41,550 --> 00:16:53,250
change the value from the back end and

00:16:50,670 --> 00:16:58,050
it works I can also change it from the

00:16:53,250 --> 00:17:06,650
front end and get access to it on the

00:16:58,050 --> 00:17:10,530
back end I can also use the X image

00:17:06,650 --> 00:17:13,560
widgets to load an image when I could

00:17:10,530 --> 00:17:21,449
use a extend so for example to filter

00:17:13,560 --> 00:17:23,459
this image so here I create a progress

00:17:21,449 --> 00:17:27,829
bar to see the progress of my of my

00:17:23,459 --> 00:17:27,829
computation sorry

00:17:32,160 --> 00:17:42,630
here it goes so I used an edge detection

00:17:37,190 --> 00:17:47,070
algorithm using the extension so once we

00:17:42,630 --> 00:17:49,950
had that we wanted to implement the C++

00:17:47,070 --> 00:17:53,670
back end for also bigger plot I believe

00:17:49,950 --> 00:17:55,920
led by three J's other widgets libraries

00:17:53,670 --> 00:17:58,010
so I'm going to show you

00:17:55,920 --> 00:18:02,910
xp3 extra Freight right now which is a

00:17:58,010 --> 00:18:09,360
the C++ back end for I pamphlet and I

00:18:02,910 --> 00:18:12,480
believe that is is a dynamic map

00:18:09,360 --> 00:18:17,940
visualization in the notebook so here in

00:18:12,480 --> 00:18:23,520
C++ I can create an app for example and

00:18:17,940 --> 00:18:27,110
I can interact with it I can create a

00:18:23,520 --> 00:18:35,070
slider if I want and link this slider to

00:18:27,110 --> 00:18:40,100
the zoom level of the map I can add new

00:18:35,070 --> 00:18:40,100
layers a marker

00:18:42,180 --> 00:18:52,560
okay I could also create a fit map on

00:18:48,780 --> 00:18:57,120
the map yeah I create some random data

00:18:52,560 --> 00:19:03,210
using an STD vectors and I add it to the

00:18:57,120 --> 00:19:06,900
map and because now C++ is interactive I

00:19:03,210 --> 00:19:15,240
can create a folder and update this fit

00:19:06,900 --> 00:19:18,000
map dynamically so we also have velocity

00:19:15,240 --> 00:19:22,170
layer which allows you to display

00:19:18,000 --> 00:19:25,860
streams like your wind stream or ocean

00:19:22,170 --> 00:19:29,340
streams and the map so here I load JSON

00:19:25,860 --> 00:19:38,310
file which contains my data and I add it

00:19:29,340 --> 00:19:43,380
to the map so in I believe that what we

00:19:38,310 --> 00:19:45,750
have is we have X array which is a

00:19:43,380 --> 00:19:49,140
library built on top of pandas which

00:19:45,750 --> 00:19:53,310
allows you to create data frames and

00:19:49,140 --> 00:19:58,110
feed the data of the velocity layer with

00:19:53,310 --> 00:20:02,760
it so in C++ we don't have a data frame

00:19:58,110 --> 00:20:04,860
library so we decided to implement to we

00:20:02,760 --> 00:20:11,130
study to work on what we call X frame

00:20:04,860 --> 00:20:13,470
and UN will going to sew a rest frame in

00:20:11,130 --> 00:20:15,450
the last beast created at contact so

00:20:13,470 --> 00:20:18,090
basically yes a precipice data frame

00:20:15,450 --> 00:20:22,020
library stays on next answer and three

00:20:18,090 --> 00:20:24,270
inspired from both pandas and x-ray so

00:20:22,020 --> 00:20:26,160
it's based on next sensor of course and

00:20:24,270 --> 00:20:29,520
it's true in three really non first

00:20:26,160 --> 00:20:31,970
stage so please not just add for a lot

00:20:29,520 --> 00:20:36,900
of features from now it's not finished

00:20:31,970 --> 00:20:40,290
so let's show you how it works so first

00:20:36,900 --> 00:20:42,510
I will just define convenient I believe

00:20:40,290 --> 00:20:45,060
so I don't have to talk a lot so let's

00:20:42,510 --> 00:20:50,610
start with defining just make sensor

00:20:45,060 --> 00:20:53,050
data print it so here what we use as

00:20:50,610 --> 00:20:55,260
value type in our data is

00:20:53,050 --> 00:20:58,360
an optional value so we can represent

00:20:55,260 --> 00:21:00,640
missing values with a dedicated with a

00:20:58,360 --> 00:21:03,850
special object type we don't have to use

00:21:00,640 --> 00:21:05,440
like none or infinity for specifying

00:21:03,850 --> 00:21:08,020
missing values we have a dedicated

00:21:05,440 --> 00:21:10,510
object for that and which prints well so

00:21:08,020 --> 00:21:14,710
that's not waiver here that was a tensor

00:21:10,510 --> 00:21:17,320
now I get a tensor data I can add to it

00:21:14,710 --> 00:21:19,210
coordinate system so basically I can

00:21:17,320 --> 00:21:22,120
define an axis so your time axis with

00:21:19,210 --> 00:21:23,830
some dates or I can build my axis

00:21:22,120 --> 00:21:26,620
do you like directly in place when I

00:21:23,830 --> 00:21:30,490
build my valuable so just like the city

00:21:26,620 --> 00:21:35,250
exit here okay let's build the variable

00:21:30,490 --> 00:21:37,840
and then I print it so here I get a nice

00:21:35,250 --> 00:21:40,630
display of my data so we're using the

00:21:37,840 --> 00:21:45,580
rich rendering feature of the existing

00:21:40,630 --> 00:21:47,250
color yeah and we can over the data into

00:21:45,580 --> 00:21:53,380
the name of dimensions he'll die date

00:21:47,250 --> 00:21:56,740
City we can do some fancy selection so

00:21:53,380 --> 00:22:00,190
I'm going to Texas City London and the

00:21:56,740 --> 00:22:02,710
fourth of January of this year if I know

00:22:00,190 --> 00:22:04,690
the position of the dimension inside my

00:22:02,710 --> 00:22:07,410
coordinate system I can just use locate

00:22:04,690 --> 00:22:10,690
and omit the names dimension first you

00:22:07,410 --> 00:22:12,010
so it's quite it's not so various for

00:22:10,690 --> 00:22:13,360
say precipice I mean people always

00:22:12,010 --> 00:22:14,500
complaining that you need to type a lot

00:22:13,360 --> 00:22:15,850
when you're doing super stress it's

00:22:14,500 --> 00:22:21,790
quite similar to what you would type

00:22:15,850 --> 00:22:24,850
with x-ray in Python same further yeah

00:22:21,790 --> 00:22:28,210
can print missing there is another

00:22:24,850 --> 00:22:30,910
feature that's quite different in x-ray

00:22:28,210 --> 00:22:32,710
compared to 9 by the way broadcast so in

00:22:30,910 --> 00:22:35,350
Empire Records according to the position

00:22:32,710 --> 00:22:36,730
of the dimensions while an x-ray you

00:22:35,350 --> 00:22:37,930
broadcast calling from the name of the

00:22:36,730 --> 00:22:40,900
dimension so that's something we

00:22:37,930 --> 00:22:45,520
replicate here and next frame so let's

00:22:40,900 --> 00:22:49,900
define one dimensional available so just

00:22:45,520 --> 00:22:51,340
as the city axis here I just repeated

00:22:49,900 --> 00:22:55,120
the right term treasure so you see it's

00:22:51,340 --> 00:22:58,390
not a gimmick and we'll see that I'm

00:22:55,120 --> 00:22:59,770
going to operate on two variable so 1 2

00:22:58,390 --> 00:23:02,740
didn't want two dimensional one one

00:22:59,770 --> 00:23:04,690
dimensional so just computing the water

00:23:02,740 --> 00:23:07,409
vapor pressure just complicated formula

00:23:04,690 --> 00:23:13,899
involving these two variables

00:23:07,409 --> 00:23:15,130
then I can print the results so yeah

00:23:13,899 --> 00:23:16,860
there isn't nice rigid so and done

00:23:15,130 --> 00:23:20,110
choose available for the broadcasting

00:23:16,860 --> 00:23:24,789
I've been like it should be I mean if we

00:23:20,110 --> 00:23:28,960
hadn't that mechanism since three years

00:23:24,789 --> 00:23:30,429
of first axis what it's the second one

00:23:28,960 --> 00:23:33,009
for this variable who would have

00:23:30,429 --> 00:23:36,309
broadcast errors just prove that routes

00:23:33,009 --> 00:23:39,159
well of course which supports higher

00:23:36,309 --> 00:23:45,610
dimension so the final three dimensional

00:23:39,159 --> 00:23:47,820
data so yeah for those familiar with

00:23:45,610 --> 00:23:50,379
pandas it's quite similar to printing

00:23:47,820 --> 00:23:56,470
when you use a multi index antennas

00:23:50,379 --> 00:24:00,549
right and still the over works we can

00:23:56,470 --> 00:24:05,200
select depending on the levels and

00:24:00,549 --> 00:24:07,230
dimensions and the last tool that lets

00:24:05,200 --> 00:24:11,200
feature that was developed by mato is a

00:24:07,230 --> 00:24:14,169
nice masking feature so let's say I want

00:24:11,200 --> 00:24:16,240
to select data based on some property on

00:24:14,169 --> 00:24:19,629
their levels and dimension so here I

00:24:16,240 --> 00:24:22,659
want to select all the data for X values

00:24:19,629 --> 00:24:25,750
the X laboratory is a not equal to two

00:24:22,659 --> 00:24:28,779
and the Z value is the Latin - so

00:24:25,750 --> 00:24:34,539
identify a mask pressure then I can just

00:24:28,779 --> 00:24:36,070
try to show it and so here's the results

00:24:34,539 --> 00:24:38,080
of all the values that do not such as

00:24:36,070 --> 00:24:40,889
calling the system do not satisfy the

00:24:38,080 --> 00:24:44,320
previous condition I'll just fill with

00:24:40,889 --> 00:24:51,549
missing values and the other objects the

00:24:44,320 --> 00:24:53,649
data so that's it for x frame all these

00:24:51,549 --> 00:24:55,059
libraries are not divided by only the

00:24:53,649 --> 00:24:57,970
four of us so we are many to collaborate

00:24:55,059 --> 00:25:00,519
on this ecosystem so the four of us you

00:24:57,970 --> 00:25:03,850
already know there is Patrick boss who

00:25:00,519 --> 00:25:05,350
developed the X FFT extensors X FFT

00:25:03,850 --> 00:25:08,889
module that Martin I used in this

00:25:05,350 --> 00:25:10,149
demonstration Lou iguana with research

00:25:08,889 --> 00:25:12,220
engineer at Ecole Polytechnique

00:25:10,149 --> 00:25:14,519
and as contributed a lot who exhaust

00:25:12,220 --> 00:25:17,440
clean developments especially the

00:25:14,519 --> 00:25:21,070
documentation features and also the

00:25:17,440 --> 00:25:22,809
completion what other things Martin

00:25:21,070 --> 00:25:25,090
because that you should all know if you

00:25:22,809 --> 00:25:27,129
don't just go and see is totes more

00:25:25,090 --> 00:25:29,049
that's amazing we present survival room

00:25:27,129 --> 00:25:31,000
and a lot of new features and new

00:25:29,049 --> 00:25:36,309
phenomena go who is a one of

00:25:31,000 --> 00:25:39,039
co-developer of the be put package of

00:25:36,309 --> 00:25:40,870
course of all of our projects open

00:25:39,039 --> 00:25:45,190
source so you can find them on get up on

00:25:40,870 --> 00:25:47,500
the other Quantic organization and most

00:25:45,190 --> 00:25:49,600
of them are the community so commutation

00:25:47,500 --> 00:25:51,190
or very bottom already tax if it's not

00:25:49,600 --> 00:25:53,080
documented yet it's just that it's not

00:25:51,190 --> 00:25:55,480
finished and we have some features to

00:25:53,080 --> 00:25:58,210
add before doing the documentation so

00:25:55,480 --> 00:26:01,289
that's conclude our demonstrations today

00:25:58,210 --> 00:26:43,929
so now hat eats we went for questions

00:26:01,289 --> 00:26:46,840
thank you well is first one is teaching

00:26:43,929 --> 00:26:48,669
so if you want to try start to teach the

00:26:46,840 --> 00:26:51,340
prospective beginners you first are to

00:26:48,669 --> 00:26:52,649
teach them ideas compilers linkers and

00:26:51,340 --> 00:26:54,909
then since they all have different

00:26:52,649 --> 00:26:57,909
platform you have to teach them see me

00:26:54,909 --> 00:27:00,700
and just nightmare so it's faster to

00:26:57,909 --> 00:27:02,649
just open a notebook and start cutting

00:27:00,700 --> 00:27:05,230
and see what happens I mean we out

00:27:02,649 --> 00:27:07,240
suppose teacher and we use it in our day

00:27:05,230 --> 00:27:09,399
to day work teach teacher work that

00:27:07,240 --> 00:27:10,990
first case another case is prototyping

00:27:09,399 --> 00:27:13,269
and set up a special I mean you want to

00:27:10,990 --> 00:27:15,129
see if something looks great or how it

00:27:13,269 --> 00:27:17,529
interacts or whatever instead of

00:27:15,129 --> 00:27:19,360
starting to curl a file or see Meg or

00:27:17,529 --> 00:27:20,830
whatever or setting up project ingest

00:27:19,360 --> 00:27:22,659
open notebook you started to typing and

00:27:20,830 --> 00:27:27,519
then you can back wall just go to your

00:27:22,659 --> 00:27:29,110
library so that both most useful use

00:27:27,519 --> 00:27:31,470
case I see for now maybe the most you

00:27:29,110 --> 00:27:39,530
skills kids guys

00:27:31,470 --> 00:27:42,000
as Christmas developers we found that we

00:27:39,530 --> 00:27:44,910
even in the very early stages of the

00:27:42,000 --> 00:27:46,290
development of excuse clean when it was

00:27:44,910 --> 00:27:47,640
not even printing in the netbook but in

00:27:46,290 --> 00:27:49,260
the console where we were running the

00:27:47,640 --> 00:27:51,030
chrono we started using it for sauce

00:27:49,260 --> 00:27:52,860
because it was faster than setting up a

00:27:51,030 --> 00:27:55,140
main project and anything when you want

00:27:52,860 --> 00:27:56,760
to have a quick check and is this valid

00:27:55,140 --> 00:27:58,440
in cyberspace is it allowed to

00:27:56,760 --> 00:27:59,970
specialize at templates in that way I

00:27:58,440 --> 00:28:01,890
will just go to the notebook right away

00:27:59,970 --> 00:28:03,210
and they already have all my libraries

00:28:01,890 --> 00:28:05,790
loaded and everything so if you are

00:28:03,210 --> 00:28:08,280
doing a native development that's one

00:28:05,790 --> 00:28:10,760
over I don't think that many people

00:28:08,280 --> 00:28:13,500
would actually do interactive

00:28:10,760 --> 00:28:16,650
exploratory analysis in C++ although

00:28:13,500 --> 00:28:19,200
people at CERN do it so some crazy fall

00:28:16,650 --> 00:28:21,210
to do it and the last use case is for

00:28:19,200 --> 00:28:23,910
those who actually do write extensions

00:28:21,210 --> 00:28:26,400
for the interpretive languages of the

00:28:23,910 --> 00:28:28,530
design site Julia Python and are and

00:28:26,400 --> 00:28:31,170
what Worf demonstrated is that extensor

00:28:28,530 --> 00:28:33,180
makes it really easy to write the

00:28:31,170 --> 00:28:37,310
software once and expose it to all these

00:28:33,180 --> 00:28:37,310
languages in a single fashion

00:28:55,410 --> 00:29:18,810
what do you mean by the Python question

00:28:56,940 --> 00:29:21,900
mark can you yeah yeah so you do

00:29:18,810 --> 00:29:25,140
question mark STD vector for example to

00:29:21,900 --> 00:29:27,150
get the CP reference for STD vector then

00:29:25,140 --> 00:29:32,460
you can use it like any web site click

00:29:27,150 --> 00:29:34,680
on the operator figure it out yeah so we

00:29:32,460 --> 00:29:37,650
can also do the same for X sensor for

00:29:34,680 --> 00:29:40,650
example because you add a tag file yeah

00:29:37,650 --> 00:29:43,650
but we showed that in idioms so there is

00:29:40,650 --> 00:29:47,070
a it's an extensive extension point so

00:29:43,650 --> 00:29:49,140
you can as a library author in your Mac

00:29:47,070 --> 00:29:52,470
store statement for that library you can

00:29:49,140 --> 00:29:53,910
make it also install some manifest

00:29:52,470 --> 00:29:55,350
explaining word to fetch the

00:29:53,910 --> 00:29:57,240
documentation for the type defined in

00:29:55,350 --> 00:30:00,920
that library so it's really easy to

00:29:57,240 --> 00:30:00,920
extend with your own user-defined types

00:30:14,999 --> 00:30:20,950
so we provide kinetic edges so it's easy

00:30:17,859 --> 00:30:23,499
to install the thing is you have when

00:30:20,950 --> 00:30:26,049
you build the the kernel you have to use

00:30:23,499 --> 00:30:27,609
the same standard library system library

00:30:26,049 --> 00:30:28,749
at the one used to build clean so you

00:30:27,609 --> 00:30:31,029
need to be sure that all your

00:30:28,749 --> 00:30:33,099
environment is consistent so that's why

00:30:31,029 --> 00:30:34,509
we prefer to just build that as a condor

00:30:33,099 --> 00:30:35,919
package and distribute it

00:30:34,509 --> 00:30:37,149
then we're going people to try to

00:30:35,919 --> 00:30:41,830
install and compile it because it's

00:30:37,149 --> 00:30:46,359
pretty complicated to do so I don't know

00:30:41,830 --> 00:30:48,309
if that's the question that you yeah

00:30:46,359 --> 00:30:50,109
that's right so it's the clean

00:30:48,309 --> 00:30:52,179
interpreter that is developed at CERN

00:30:50,109 --> 00:30:55,299
perform a form of like incremental

00:30:52,179 --> 00:30:56,829
compilation it also tries to recover

00:30:55,299 --> 00:30:58,779
from errors if there is an operation

00:30:56,829 --> 00:31:00,789
erased right it will try to remove like

00:30:58,779 --> 00:31:02,559
delete the symbols that it created as it

00:31:00,789 --> 00:31:06,070
was compelling but it does not always

00:31:02,559 --> 00:31:10,029
recover well from like complicated

00:31:06,070 --> 00:31:23,320
compilation errors and yeah so uses a

00:31:10,029 --> 00:31:39,339
Latvian clang under the hood versioning

00:31:23,320 --> 00:31:41,469
of libraries so I think there are

00:31:39,339 --> 00:31:43,419
multiple aspects to it so first in terms

00:31:41,469 --> 00:31:46,659
of version of the language we offer

00:31:43,419 --> 00:31:50,039
multiple Kronos one for specific 11 one

00:31:46,659 --> 00:31:53,200
for Cespedes 14 and one for spice was 17

00:31:50,039 --> 00:31:56,229
in terms of versioning as in version

00:31:53,200 --> 00:31:57,820
control of the notebook that's just like

00:31:56,229 --> 00:32:00,759
any Jupiter netbook for other

00:31:57,820 --> 00:32:04,450
programming languages and as far as the

00:32:00,759 --> 00:32:06,849
package management is concerned as we

00:32:04,450 --> 00:32:10,079
have been relying heavily on the canned

00:32:06,849 --> 00:32:12,159
a package manager which is I would say

00:32:10,079 --> 00:32:16,469
general-purpose and not just for python

00:32:12,159 --> 00:32:16,469
and has been great for us

00:32:26,470 --> 00:32:33,789
so it's just like any kernel kernel is

00:32:32,139 --> 00:32:36,429
merely an executable that speaks an

00:32:33,789 --> 00:32:39,759
inter process communication protocol

00:32:36,429 --> 00:32:43,179
based on zmq the way kernels are

00:32:39,759 --> 00:32:45,269
declared to Jupiter is through a can

00:32:43,179 --> 00:32:47,500
inspect that he is a manifest of

00:32:45,269 --> 00:32:49,000
specifying where the executive all is

00:32:47,500 --> 00:32:51,909
and how it should be called particular

00:32:49,000 --> 00:32:53,350
and to install that thing so we do it

00:32:51,909 --> 00:32:55,450
automatically when you install the

00:32:53,350 --> 00:32:57,879
Canada package for the environment of

00:32:55,450 --> 00:33:00,429
the Condor package but you can also run

00:32:57,879 --> 00:33:01,570
the Jupiter kernel spec in store if you

00:33:00,429 --> 00:33:34,299
want to install it for another

00:33:01,570 --> 00:33:37,539
environment it doesn't answer what are

00:33:34,299 --> 00:33:41,200
their implications or this has the first

00:33:37,539 --> 00:33:42,399
Jewish the I think is going to be used

00:33:41,200 --> 00:33:47,220
for other things than the Super's

00:33:42,399 --> 00:33:50,230
pastrana so that word is sort of

00:33:47,220 --> 00:33:51,879
transversal I would say we have a

00:33:50,230 --> 00:33:53,259
different consumption model than the

00:33:51,879 --> 00:33:55,179
classical implementation of the

00:33:53,259 --> 00:33:58,240
particular kernel that will help with

00:33:55,179 --> 00:34:01,509
the debugging story and so that's why

00:33:58,240 --> 00:34:04,179
work and juice based Titan kernels and

00:34:01,509 --> 00:34:12,520
our kernels are going to be important so

00:34:04,179 --> 00:34:14,970
that's one and like also maybe it will

00:34:12,520 --> 00:34:17,290
probably also have a like smaller

00:34:14,970 --> 00:34:22,239
footprint on the system because it's

00:34:17,290 --> 00:34:25,309
better weight and the Python come oh yes

00:34:22,239 --> 00:34:25,309
[Music]

00:34:25,649 --> 00:34:31,859
if I have a large set of libraries that

00:34:41,039 --> 00:34:45,519
there are some short Prime instruction

00:34:44,049 --> 00:34:48,940
you can use to other your honor berries

00:34:45,519 --> 00:34:51,339
so we do it now demo with the loading

00:34:48,940 --> 00:34:55,899
some extent sarayu thousands we see my

00:34:51,339 --> 00:34:57,129
dad so it's quite pretty easy to use so

00:34:55,899 --> 00:34:58,660
there is some binary compatibility

00:34:57,129 --> 00:35:00,880
constraints you need to have them built

00:34:58,660 --> 00:35:04,690
with a fully like a binary compatible

00:35:00,880 --> 00:35:06,880
version of the C runtime and one thing

00:35:04,690 --> 00:35:10,329
that's really convenient is if you need

00:35:06,880 --> 00:35:12,759
to load a runtime is to add the clean

00:35:10,329 --> 00:35:15,220
pragmas in your headers for the loading

00:35:12,759 --> 00:35:17,740
so that it gets loaded as you have to

00:35:15,220 --> 00:35:20,890
include your header and that makes like

00:35:17,740 --> 00:35:22,180
the usability sooner - I mean the

00:35:20,890 --> 00:35:40,920
experience we're not - importing a

00:35:22,180 --> 00:35:40,920
Python package would you then be able to

00:35:49,349 --> 00:35:54,789
well maybe they would consider batches

00:35:52,450 --> 00:35:56,769
like people contributing adding the

00:35:54,789 --> 00:35:58,390
pragmas which are clean specific and

00:35:56,769 --> 00:36:00,700
will not have an impact for the users to

00:35:58,390 --> 00:36:02,559
this divert it or you can always make

00:36:00,700 --> 00:36:04,390
your own magic header that does it and

00:36:02,559 --> 00:36:06,779
increase the relevant headers lake as

00:36:04,390 --> 00:36:06,779
you said

00:36:18,180 --> 00:36:24,400
anything Clank doesn't support is not

00:36:20,350 --> 00:36:26,050
going to work okay so that's one way to

00:36:24,400 --> 00:36:30,910
answer it

00:36:26,050 --> 00:36:36,330
also there are some limitation in terms

00:36:30,910 --> 00:36:40,360
of threading you can do threading but

00:36:36,330 --> 00:36:42,010
you I mean when doing it it's very much

00:36:40,360 --> 00:36:44,170
like in the Python code I would say that

00:36:42,010 --> 00:36:48,100
you're also already know like a computer

00:36:44,170 --> 00:36:49,240
environment in the kernel so well as you

00:36:48,100 --> 00:36:57,120
do it you need to be aware of that I

00:36:49,240 --> 00:36:57,120
would say that balancers die

00:37:06,130 --> 00:37:30,519
you can yeah you can do that packaging

00:37:25,079 --> 00:37:33,730
packaging is their hardest it takes

00:37:30,519 --> 00:37:38,200
about half of a time pretty much as much

00:37:33,730 --> 00:37:42,220
time is devoted to to packaging as to

00:37:38,200 --> 00:37:44,710
writing food and some aspects of the

00:37:42,220 --> 00:37:48,309
Jupiter protocol were not meant we

00:37:44,710 --> 00:37:54,340
statically typed languages in mind I was

00:37:48,309 --> 00:37:56,160
not devised and so we we had to use

00:37:54,340 --> 00:37:59,859
[Music]

00:37:56,160 --> 00:38:02,440
template metaprogramming voodoo to to

00:37:59,859 --> 00:38:16,900
cover everything that was not

00:38:02,440 --> 00:38:22,450
straightforward I would say we start

00:38:16,900 --> 00:38:23,890
everything or unless you you want you

00:38:22,450 --> 00:38:25,240
have already declared a variable I just

00:38:23,890 --> 00:38:29,380
want to really find it with the same

00:38:25,240 --> 00:38:31,900
type that's possible but if you just

00:38:29,380 --> 00:38:33,730
want to assign a new value so you may

00:38:31,900 --> 00:38:36,400
want to like split yourselves in ways

00:38:33,730 --> 00:38:44,049
that don't require you to really find

00:38:36,400 --> 00:38:45,640
the type and just assign new values it's

00:38:44,049 --> 00:38:47,769
already simpler than the main fact I

00:38:45,640 --> 00:38:50,319
would say but you would still need to

00:38:47,769 --> 00:38:56,490
restart the kernel a lot more than the

00:38:50,319 --> 00:38:56,490
Python kernel yeah but yes

00:39:05,940 --> 00:39:13,390
nope no we haven't the question have you

00:39:10,029 --> 00:39:16,539
tried to use frameworks to really cut

00:39:13,390 --> 00:39:18,759
cells automatically when they're based

00:39:16,539 --> 00:39:24,489
on their dependencies and that somehow

00:39:18,759 --> 00:39:27,040
yeah I know we haven't done that all

00:39:24,489 --> 00:39:32,659
right thank you thank you very much

00:39:27,040 --> 00:39:32,659

YouTube URL: https://www.youtube.com/watch?v=_Yz0QXcLh0Q


