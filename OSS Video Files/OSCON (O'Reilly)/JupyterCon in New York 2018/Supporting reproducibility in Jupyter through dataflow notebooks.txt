Title: Supporting reproducibility in Jupyter through dataflow notebooks
Publication date: 2018-09-21
Playlist: JupyterCon in New York 2018
Description: 
	Supporting reproducibility in Jupyter through dataflow notebooks
David Koop (University of Massachusetts Dartmouth)

Jupyter notebooks are an important tool for exploratory data analysis, but their ability to combine code, outputs, and text has also enabled their use to document and reproduce results. Notebooks can further play an important role in enabling reuse and extensions of those results; users can not only examine and reexecute past results but also tweak inputs and test new ideas. However, the ability to modify and execute any cell, at any place in the notebook, can sometimes conflict with the desire to present steps in an easy-to-follow, top-down ordering.

David Koop offers an overview of the Dataflow kernel, which combines the ability to tinker with the ability to define precise dependencies between cells. David shows how it can be used to robustly link cells as a notebook is developed and demonstrates how that notebook can be reused and extended without impacting its reproducibility. In addition, he explains the importance of intermediate outputs and how to structure cells to better define the boundaries between them and explores other extensions enabled by the dataflow structure and relationships to the JupyterLab environment.

A dataflow notebook promotes cells to be building blocks that can be linked together based on references to each other. More technically, a dataflow encodes dependencies between computations by defining how the outputs of one computation are inputs of another computation. For example, cell A might calculate a value, cell B might read an image, and cell C might use cell A’s output to blur cell B’s output to create a new image. If we change cell B to read a different image, it seems appropriate to also update cell C’s output. With robust dependencies, we can automatically execute such updates. This structure also allows users to examine how a change to one cell might impact results in other cells of the notebook. An interactive visualization of the dependency graph can help users navigate complex notebooks.

In a dataflow notebook, outputs (as defined by the last line of a cell) should reflect what was computed in a cell. Jupyter provides extensive capabilities for displaying and customizing outputs, but a cell with multiple outputs is often encapsulated as a tuple or other collection that limits these rich displays. To address this limitation, David shares extensions to the Jupyter notebook to render each output individually. For example, a tuple (df, im) would generate two outputs, the DataFrame df as an HTML table and the image im as an image. Combined with an identification scheme to reference the individual outputs, users can more clearly examine and link specific outputs to be used in other cells.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:01,520 --> 00:00:07,200
welcome back glad to see all of you here

00:00:04,950 --> 00:00:10,050
for those of you who attended Joel or

00:00:07,200 --> 00:00:12,870
saw Joel Bruce's talk before that it was

00:00:10,050 --> 00:00:14,820
an excellent setup for my talk and that

00:00:12,870 --> 00:00:17,189
I'm trying to push back against some of

00:00:14,820 --> 00:00:18,900
the things he hates about notebooks and

00:00:17,189 --> 00:00:21,600
and solve some of those challenges that

00:00:18,900 --> 00:00:22,980
he put out there the official title of

00:00:21,600 --> 00:00:25,430
the talk is supporting reproducibility

00:00:22,980 --> 00:00:27,990
and Jupiter through data flow notebooks

00:00:25,430 --> 00:00:29,970
and something that's come up before is

00:00:27,990 --> 00:00:32,250
this idea that Jupiter notebook spans

00:00:29,970 --> 00:00:34,440
two different sort of styles of

00:00:32,250 --> 00:00:36,420
notebooks one of them you're probably

00:00:34,440 --> 00:00:39,030
familiar with if you've done notebooks

00:00:36,420 --> 00:00:42,559
you can identify them by the the file

00:00:39,030 --> 00:00:46,710
names untitled one untitled 27 untitled

00:00:42,559 --> 00:00:48,629
152 they often have things like errors

00:00:46,710 --> 00:00:50,639
in the middle cells are executed out of

00:00:48,629 --> 00:00:54,059
order or not executed at all things

00:00:50,639 --> 00:00:55,949
might be edited this is sort of what

00:00:54,059 --> 00:00:57,780
happens in export exploration right

00:00:55,949 --> 00:00:59,039
you're trying to test hypotheses you're

00:00:57,780 --> 00:01:01,049
trying to load your data you're trying

00:00:59,039 --> 00:01:02,969
to look at things this is not uncommon

00:01:01,049 --> 00:01:05,010
and this is something that Jupiter has

00:01:02,969 --> 00:01:06,780
good tools to support right it's a

00:01:05,010 --> 00:01:08,790
flexible environment you can edit

00:01:06,780 --> 00:01:10,590
whatever cell you want you can execute

00:01:08,790 --> 00:01:13,020
cells whenever you want in whatever

00:01:10,590 --> 00:01:14,310
order you want and I think one of the

00:01:13,020 --> 00:01:16,590
key things that I like about the

00:01:14,310 --> 00:01:19,170
notebook is the inline views of outputs

00:01:16,590 --> 00:01:21,360
right so you create a plot you could

00:01:19,170 --> 00:01:23,130
generate some execution you don't have

00:01:21,360 --> 00:01:25,350
to switch to another window to run that

00:01:23,130 --> 00:01:27,030
you run it right in the notebook you see

00:01:25,350 --> 00:01:30,480
the result right below the code that you

00:01:27,030 --> 00:01:32,180
wrote and along with this there are some

00:01:30,480 --> 00:01:34,560
execution shortcuts that you can quickly

00:01:32,180 --> 00:01:36,360
run through things like running all the

00:01:34,560 --> 00:01:40,110
cells running all above running all

00:01:36,360 --> 00:01:42,600
below on the other side we have

00:01:40,110 --> 00:01:44,310
explanatory work notebooks right some

00:01:42,600 --> 00:01:46,530
something that's sort of published or

00:01:44,310 --> 00:01:48,210
very presentable that you want a large

00:01:46,530 --> 00:01:50,940
audience to see or at least the audience

00:01:48,210 --> 00:01:53,400
that's interested in your work these can

00:01:50,940 --> 00:01:55,530
be identified by markdown cells where

00:01:53,400 --> 00:01:58,170
you're actually documenting like

00:01:55,530 --> 00:02:00,150
literate programming wants you to nice

00:01:58,170 --> 00:02:03,030
short snippets of code where you can see

00:02:00,150 --> 00:02:05,190
logical progression in steps and often

00:02:03,030 --> 00:02:07,110
they have these nice outputs visual

00:02:05,190 --> 00:02:08,789
outputs and in this case interactive

00:02:07,110 --> 00:02:10,859
outputs right so that you can not only

00:02:08,789 --> 00:02:12,870
just see what somebody did but you can

00:02:10,859 --> 00:02:15,010
play around and change things out look

00:02:12,870 --> 00:02:17,270
at the visualizations

00:02:15,010 --> 00:02:19,040
and Jupiter has great support for this

00:02:17,270 --> 00:02:20,660
as well right there's textual

00:02:19,040 --> 00:02:22,400
explanation the fact that this literate

00:02:20,660 --> 00:02:24,370
programming idea allows you to combine

00:02:22,400 --> 00:02:26,690
markdown cells along with the code

00:02:24,370 --> 00:02:29,300
graphical explorations you can have

00:02:26,690 --> 00:02:32,030
inline figures and this interactive

00:02:29,300 --> 00:02:34,280
exploration write explanation using

00:02:32,030 --> 00:02:36,350
Jupiter widgets so that it's not just

00:02:34,280 --> 00:02:38,450
something that's a stale document that

00:02:36,350 --> 00:02:40,400
you print and sort of read through but

00:02:38,450 --> 00:02:42,110
something that you can download and play

00:02:40,400 --> 00:02:45,800
around with and sort of explore your own

00:02:42,110 --> 00:02:47,720
hypotheses and along with that there's

00:02:45,800 --> 00:02:49,760
this idea of publishing right so you can

00:02:47,720 --> 00:02:52,640
take a notebook convert it into a web

00:02:49,760 --> 00:02:55,280
page convert it into law tech etc and

00:02:52,640 --> 00:02:57,230
generally these explanatory notebooks

00:02:55,280 --> 00:03:00,890
are clear with sort of a linear cell

00:02:57,230 --> 00:03:02,120
layout and this leads to what we like to

00:03:00,890 --> 00:03:04,100
talk about with notebooks is

00:03:02,120 --> 00:03:06,920
reproducibility right so if you have

00:03:04,100 --> 00:03:08,690
something that's nicely crafted that has

00:03:06,920 --> 00:03:11,210
all these different features it's often

00:03:08,690 --> 00:03:15,800
reproducible and and it's due to this

00:03:11,210 --> 00:03:17,350
sort of classic linear so layout so I've

00:03:15,800 --> 00:03:20,060
talked about two kinds of notebooks

00:03:17,350 --> 00:03:22,400
there's clearly a spectrum right it's

00:03:20,060 --> 00:03:23,780
not just sort of these you know one-off

00:03:22,400 --> 00:03:25,700
sort of I'm going to open an untitled

00:03:23,780 --> 00:03:28,400
notebook and do some stuff and these

00:03:25,700 --> 00:03:29,780
really nice polished publish sort of

00:03:28,400 --> 00:03:31,370
notebooks there's things in the middle

00:03:29,780 --> 00:03:33,080
like when you want to share something

00:03:31,370 --> 00:03:34,970
with your colleagues or things like that

00:03:33,080 --> 00:03:36,470
and this parallels the general approach

00:03:34,970 --> 00:03:38,900
to research right sometimes you're

00:03:36,470 --> 00:03:41,090
trying to brainstorm questions id8 very

00:03:38,900 --> 00:03:42,260
quickly then you get to distilling the

00:03:41,090 --> 00:03:45,020
initial results into something

00:03:42,260 --> 00:03:46,130
understandable and verifiable and then

00:03:45,020 --> 00:03:49,070
finally you get to the sort of this

00:03:46,130 --> 00:03:51,320
published step where published up where

00:03:49,070 --> 00:03:52,820
you're polishing the text and hopefully

00:03:51,320 --> 00:03:56,990
adding some interactivity to your

00:03:52,820 --> 00:04:00,020
notebooks as well so one question here

00:03:56,990 --> 00:04:02,000
is are these on totally separate ends of

00:04:00,020 --> 00:04:03,800
the world right is there a way to go

00:04:02,000 --> 00:04:06,050
from rapid exploration to clear

00:04:03,800 --> 00:04:07,730
explanation right yeah I did my first

00:04:06,050 --> 00:04:09,890
notebook and then I sort of copied and

00:04:07,730 --> 00:04:11,989
pasted stuff and I refined it a bit and

00:04:09,890 --> 00:04:12,620
finally generated this nice published

00:04:11,989 --> 00:04:15,470
notebook

00:04:12,620 --> 00:04:18,109
how do we make that process simpler how

00:04:15,470 --> 00:04:22,370
do we sort of make the rapid exploration

00:04:18,109 --> 00:04:23,720
lead to these clearer explanations and

00:04:22,370 --> 00:04:26,000
this gets us back to the idea of

00:04:23,720 --> 00:04:29,180
reproducibility

00:04:26,000 --> 00:04:30,890
and to clarify a little bit science is

00:04:29,180 --> 00:04:32,800
very fond of sort of replicating

00:04:30,890 --> 00:04:35,300
experiments right so you have

00:04:32,800 --> 00:04:37,430
independent verification by separate

00:04:35,300 --> 00:04:39,980
labs that a particular hypothesis tests

00:04:37,430 --> 00:04:41,930
out in a particular way reproducibility

00:04:39,980 --> 00:04:44,030
especially computational reproducibility

00:04:41,930 --> 00:04:46,100
we're talking more giving your code give

00:04:44,030 --> 00:04:47,750
me your data I can run that I can check

00:04:46,100 --> 00:04:49,850
the results and sort of verify that it's

00:04:47,750 --> 00:04:52,610
not the full start from the beginning

00:04:49,850 --> 00:04:54,260
build everything from the ground up and

00:04:52,610 --> 00:04:56,750
in terms of notebooks these are similar

00:04:54,260 --> 00:04:58,490
things to other computations in that we

00:04:56,750 --> 00:05:00,830
need to have an environment that's

00:04:58,490 --> 00:05:02,480
that's set up correctly right we have

00:05:00,830 --> 00:05:04,790
the right versions of libraries and

00:05:02,480 --> 00:05:06,440
packages you can dig down very deep

00:05:04,790 --> 00:05:08,960
there so it's not just the Python

00:05:06,440 --> 00:05:10,940
packages but what C libraries you have

00:05:08,960 --> 00:05:14,120
what operating system you're going on

00:05:10,940 --> 00:05:15,530
and things like that and then on the

00:05:14,120 --> 00:05:17,930
data side we need to have the necessary

00:05:15,530 --> 00:05:19,460
data right and things like making sure

00:05:17,930 --> 00:05:21,169
the data that was run originally with a

00:05:19,460 --> 00:05:23,750
notebook is the data that you downloaded

00:05:21,169 --> 00:05:25,910
you can use hashing data versioning

00:05:23,750 --> 00:05:27,740
there are some solutions there what I

00:05:25,910 --> 00:05:29,570
want to focus on is this last piece

00:05:27,740 --> 00:05:30,800
which is really the execution and you

00:05:29,570 --> 00:05:33,410
might sort of scratch your head and say

00:05:30,800 --> 00:05:35,090
why write execution you just push a

00:05:33,410 --> 00:05:37,100
button and it runs basically right you

00:05:35,090 --> 00:05:39,110
have a Python script you run that python

00:05:37,100 --> 00:05:41,750
script it executes you get the results

00:05:39,110 --> 00:05:43,310
and you're done but with notebooks it's

00:05:41,750 --> 00:05:45,320
not quite as simple right because you

00:05:43,310 --> 00:05:47,300
can execute cells in whatever order you

00:05:45,320 --> 00:05:49,130
want you can jump back at it cells

00:05:47,300 --> 00:05:51,620
because of that flexibility the

00:05:49,130 --> 00:05:53,419
execution isn't always as predictable

00:05:51,620 --> 00:05:56,090
right hopefully you can run things

00:05:53,419 --> 00:05:57,650
top-down and it works but if you save

00:05:56,090 --> 00:05:59,479
something from maybe one of your rapid

00:05:57,650 --> 00:06:01,100
explorations where you executed one cell

00:05:59,479 --> 00:06:03,440
five times and then you went back and

00:06:01,100 --> 00:06:05,300
executed the top so again that can lead

00:06:03,440 --> 00:06:08,780
to problems in state and you may not be

00:06:05,300 --> 00:06:11,690
able to rerun the cells as intended

00:06:08,780 --> 00:06:13,760
so taking one of these sort of notebooks

00:06:11,690 --> 00:06:15,350
that's less nice and turning it into

00:06:13,760 --> 00:06:17,390
something that's more explanatory more

00:06:15,350 --> 00:06:20,060
polished sometimes referred to as maybe

00:06:17,390 --> 00:06:22,310
linearizing the notebook and Jake Van

00:06:20,060 --> 00:06:24,140
applause in some materials on

00:06:22,310 --> 00:06:26,300
reproducible data analysis talks about

00:06:24,140 --> 00:06:28,729
making sure that your notebook runs

00:06:26,300 --> 00:06:30,229
straight from beginning to end there are

00:06:28,729 --> 00:06:32,150
other things involved in this sort of

00:06:30,229 --> 00:06:34,490
polishing your notebook rearranging

00:06:32,150 --> 00:06:35,780
organizing merging cells collecting

00:06:34,490 --> 00:06:37,520
imports that are scattered across

00:06:35,780 --> 00:06:38,150
multiple cells and putting them all at

00:06:37,520 --> 00:06:39,870
the top

00:06:38,150 --> 00:06:42,030
adding the explanatory

00:06:39,870 --> 00:06:44,010
right using the markdown features that

00:06:42,030 --> 00:06:46,080
that are embedded in Jupiter notebook

00:06:44,010 --> 00:06:47,850
and then sort of this last step is

00:06:46,080 --> 00:06:49,590
restart the kernel and run all make sure

00:06:47,850 --> 00:06:51,120
that when you do that your notebooks

00:06:49,590 --> 00:06:54,720
good to go you have this top-down

00:06:51,120 --> 00:06:56,760
execution I have seen a couple notebooks

00:06:54,720 --> 00:06:58,530
where there's sort of auxilary code that

00:06:56,760 --> 00:06:59,460
people want to run first and then you

00:06:58,530 --> 00:07:00,930
sort of go through the rest of the

00:06:59,460 --> 00:07:02,520
notebook and this can be useful when

00:07:00,930 --> 00:07:04,680
you're dealing with something like NB

00:07:02,520 --> 00:07:06,210
viewer right where you want to output a

00:07:04,680 --> 00:07:08,400
notebook you want somebody to sort of

00:07:06,210 --> 00:07:09,870
read your key conclusions the top you

00:07:08,400 --> 00:07:11,820
don't want to have pages of code that

00:07:09,870 --> 00:07:13,350
they have to scroll through to get to

00:07:11,820 --> 00:07:18,150
those interesting conclusions to get to

00:07:13,350 --> 00:07:20,310
those visualizations but going beyond

00:07:18,150 --> 00:07:22,770
sort of this idea of just clicking a

00:07:20,310 --> 00:07:24,930
button and having everything reproduce I

00:07:22,770 --> 00:07:27,270
want to get into this idea of reuse

00:07:24,930 --> 00:07:28,590
right so run all linear solutions can be

00:07:27,270 --> 00:07:30,480
great right you know they're gonna run

00:07:28,590 --> 00:07:32,910
you can sort of scroll back and see what

00:07:30,480 --> 00:07:34,710
happened but a question here is can I

00:07:32,910 --> 00:07:36,870
actually understand how the original

00:07:34,710 --> 00:07:38,670
code works right yeah I can run it

00:07:36,870 --> 00:07:41,280
everything generates correctly I don't

00:07:38,670 --> 00:07:43,530
see any exceptions but what does it mean

00:07:41,280 --> 00:07:45,420
can I go back to my own code two years

00:07:43,530 --> 00:07:47,040
later and really understand and modify

00:07:45,420 --> 00:07:49,440
that or take one of these nicely

00:07:47,040 --> 00:07:52,110
published notebooks and and sort of

00:07:49,440 --> 00:07:53,370
understand what's going on there and so

00:07:52,110 --> 00:07:54,990
this also goes along with like do I

00:07:53,370 --> 00:07:57,300
actually know how to change the code for

00:07:54,990 --> 00:07:59,940
my own work right can I can I update

00:07:57,300 --> 00:08:02,130
things it's not just rerunning something

00:07:59,940 --> 00:08:07,770
but it's making use of what's been

00:08:02,130 --> 00:08:08,820
published what's out there okay so you

00:08:07,770 --> 00:08:10,740
know that that's important for

00:08:08,820 --> 00:08:12,570
reproducibility in sort of these nicer

00:08:10,740 --> 00:08:14,610
notebooks but in these exploratory

00:08:12,570 --> 00:08:16,770
notebooks you've run into these potholes

00:08:14,610 --> 00:08:18,150
probably right you redefine or mutated a

00:08:16,770 --> 00:08:21,090
variable and you found out that you

00:08:18,150 --> 00:08:23,400
broke some other cell maybe went back to

00:08:21,090 --> 00:08:26,580
some state before you were closing a

00:08:23,400 --> 00:08:28,500
notebook and and like it doesn't work

00:08:26,580 --> 00:08:29,940
after you closed it you try to rerun the

00:08:28,500 --> 00:08:30,990
cells and top-down order and it just

00:08:29,940 --> 00:08:33,150
doesn't work

00:08:30,990 --> 00:08:34,800
maybe you edited a cell and then forgot

00:08:33,150 --> 00:08:36,180
to run it and you save that out and come

00:08:34,800 --> 00:08:38,760
back came back to it a few months later

00:08:36,180 --> 00:08:41,010
and go why does it say x equals three

00:08:38,760 --> 00:08:43,410
and the output says two right this

00:08:41,010 --> 00:08:45,720
doesn't make any sense to me and these

00:08:43,410 --> 00:08:47,580
are things that people have you know

00:08:45,720 --> 00:08:50,310
noted in Jupiter and sort of run across

00:08:47,580 --> 00:08:52,320
and for the most part we found ways to

00:08:50,310 --> 00:08:53,580
get around these but it can be

00:08:52,320 --> 00:08:57,420
frustrating for some of the beginner

00:08:53,580 --> 00:08:59,100
and what seems to sort of my idea of a

00:08:57,420 --> 00:09:01,260
solution for this is can we have better

00:08:59,100 --> 00:09:02,580
links between the cells can we sort of

00:09:01,260 --> 00:09:06,420
figure out what the dependencies between

00:09:02,580 --> 00:09:07,740
the cells are and in general this is not

00:09:06,420 --> 00:09:09,300
an easy problem because you have

00:09:07,740 --> 00:09:11,940
variables floating all over the place

00:09:09,300 --> 00:09:15,240
you can have variables referenced all

00:09:11,940 --> 00:09:17,400
over the place but this is something

00:09:15,240 --> 00:09:19,680
that ipython has sort of thought about

00:09:17,400 --> 00:09:22,080
from the beginning Fernando Perez has

00:09:19,680 --> 00:09:24,000
sort of a comment on ipython that one of

00:09:22,080 --> 00:09:27,030
the goals was to hold state and capture

00:09:24,000 --> 00:09:28,590
previous results for reuse and so there

00:09:27,030 --> 00:09:30,630
are these sort of shortcuts that allow

00:09:28,590 --> 00:09:33,780
people to reference previous outputs

00:09:30,630 --> 00:09:35,790
previous cells so you can reference a

00:09:33,780 --> 00:09:37,590
previous output using the out dictionary

00:09:35,790 --> 00:09:39,990
you pass in the number of the cell you

00:09:37,590 --> 00:09:40,410
want you can grab that output and deal

00:09:39,990 --> 00:09:42,090
with it

00:09:40,410 --> 00:09:43,860
there's also these sort of underscore

00:09:42,090 --> 00:09:46,080
shortcuts where whatever you last

00:09:43,860 --> 00:09:48,540
executed the output from that cell is

00:09:46,080 --> 00:09:50,100
accessible and then you can also get

00:09:48,540 --> 00:09:51,870
things on the input side by looking at

00:09:50,100 --> 00:09:55,110
the transcript of all the executed code

00:09:51,870 --> 00:09:56,850
so what was cell 5 when it was run right

00:09:55,110 --> 00:09:57,870
maybe I deleted cell 5 and it became

00:09:56,850 --> 00:09:59,340
cell 27

00:09:57,870 --> 00:10:02,130
but I can actually look what the code

00:09:59,340 --> 00:10:04,560
was when I ran self when I ran the cell

00:10:02,130 --> 00:10:06,690
when it was called cell 5 and then

00:10:04,560 --> 00:10:08,340
there's also this command there's magic

00:10:06,690 --> 00:10:10,080
command history where you can get a list

00:10:08,340 --> 00:10:12,810
of all everything that's sort of been

00:10:10,080 --> 00:10:14,610
run and so these commands exist in

00:10:12,810 --> 00:10:18,360
ipython they migrated over to Jupiter

00:10:14,610 --> 00:10:20,070
notebook in the I pi kernel and this is

00:10:18,360 --> 00:10:22,470
not clear there used that much in what

00:10:20,070 --> 00:10:23,940
we've seen right and there are some

00:10:22,470 --> 00:10:27,990
reasons for that why they're not used

00:10:23,940 --> 00:10:29,430
that much in the notebook so what I'd

00:10:27,990 --> 00:10:31,920
like to show is a little demonstration

00:10:29,430 --> 00:10:33,780
I'm loading some data some soccer data

00:10:31,920 --> 00:10:36,960
about sort of the top players in the

00:10:33,780 --> 00:10:40,380
world using pandas to parse that NB a

00:10:36,960 --> 00:10:41,670
CSV file and then what's going to happen

00:10:40,380 --> 00:10:43,530
is I'm going to do some sort of

00:10:41,670 --> 00:10:45,180
massaging of the data renaming things

00:10:43,530 --> 00:10:48,150
doing a group by looking at different

00:10:45,180 --> 00:10:50,250
country countries I can try to find the

00:10:48,150 --> 00:10:51,840
USA players it doesn't work so I figure

00:10:50,250 --> 00:10:53,490
out that I have to actually strip offs

00:10:51,840 --> 00:10:57,260
and the white space to make things look

00:10:53,490 --> 00:11:00,270
correct and so now I created a new table

00:10:57,260 --> 00:11:02,100
and now the users can sort of use this

00:11:00,270 --> 00:11:03,750
updated data frame by using these out

00:11:02,100 --> 00:11:06,030
references right so these numeric

00:11:03,750 --> 00:11:07,420
references so that I can take the thing

00:11:06,030 --> 00:11:10,620
that I just created that I just

00:11:07,420 --> 00:11:13,060
as an output and use that further down

00:11:10,620 --> 00:11:14,710
now if I go back and edit one of these

00:11:13,060 --> 00:11:17,110
cells so in this case I'm going to

00:11:14,710 --> 00:11:18,580
change the country USA to Sweden and

00:11:17,110 --> 00:11:26,980
look at the Swedish players that are in

00:11:18,580 --> 00:11:28,480
this top top soccer players list and now

00:11:26,980 --> 00:11:29,620
what I'm gonna do is I want to rerun

00:11:28,480 --> 00:11:31,750
that I want to find sort of the mean

00:11:29,620 --> 00:11:34,270
rating of those players right it's

00:11:31,750 --> 00:11:35,470
fairly clear what it is here but what

00:11:34,270 --> 00:11:36,790
happens is you see the result doesn't

00:11:35,470 --> 00:11:38,500
change and it doesn't make any sense

00:11:36,790 --> 00:11:40,090
either right because it says the you

00:11:38,500 --> 00:11:41,530
know the rating is 88 both of those

00:11:40,090 --> 00:11:43,630
players actually have sort of a player

00:11:41,530 --> 00:11:45,550
rating that's below 88 so clearly that

00:11:43,630 --> 00:11:47,770
can't be the mean and the problem is

00:11:45,550 --> 00:11:49,870
that I'm referencing cell 7 and my cell

00:11:47,770 --> 00:11:51,850
when I reacts acute it change to output

00:11:49,870 --> 00:11:54,700
9 right so I'd sort of have to go back

00:11:51,850 --> 00:11:56,590
and rewrite that code so this underscore

00:11:54,700 --> 00:11:59,260
solution has a relative reference to the

00:11:56,590 --> 00:12:01,300
previously executed cells output so this

00:11:59,260 --> 00:12:03,040
is a little more relative I can deal

00:12:01,300 --> 00:12:07,270
with things like this easier if I change

00:12:03,040 --> 00:12:09,250
something and we execute it oh it might

00:12:07,270 --> 00:12:10,780
have worked except that the reference to

00:12:09,250 --> 00:12:12,760
the previously executed cell is actually

00:12:10,780 --> 00:12:14,350
below it's not the thing above like you

00:12:12,760 --> 00:12:15,670
might expect if you read the top down

00:12:14,350 --> 00:12:17,770
notebook it's something that was

00:12:15,670 --> 00:12:19,960
actually above and so that can also

00:12:17,770 --> 00:12:21,610
introduce problems because it's the

00:12:19,960 --> 00:12:23,650
previously executed cell not the

00:12:21,610 --> 00:12:26,140
previous cell in how you look at the

00:12:23,650 --> 00:12:28,270
notebook so the solution that most

00:12:26,140 --> 00:12:30,880
people use is using variables right to

00:12:28,270 --> 00:12:33,190
find a variable like C you know what C

00:12:30,880 --> 00:12:34,720
is going to be and you can use that in

00:12:33,190 --> 00:12:37,210
the rest of your analysis that if you

00:12:34,720 --> 00:12:40,110
update anything about what C is you can

00:12:37,210 --> 00:12:43,210
sort of take that and use it some more

00:12:40,110 --> 00:12:45,670
now one thing we might want to change is

00:12:43,210 --> 00:12:48,010
okay there's a error in this data set

00:12:45,670 --> 00:12:52,270
and that one of the players is not

00:12:48,010 --> 00:12:53,650
playing for the country for the specific

00:12:52,270 --> 00:12:56,020
country that it lists so we have a fixed

00:12:53,650 --> 00:12:57,280
data set that we can load in and what we

00:12:56,020 --> 00:13:00,070
might want to do is go down to that

00:12:57,280 --> 00:13:01,930
initial to that last sort of checking

00:13:00,070 --> 00:13:04,750
for a country piece right but

00:13:01,930 --> 00:13:06,100
unfortunately that that check is

00:13:04,750 --> 00:13:07,780
actually referencing a data set that

00:13:06,100 --> 00:13:09,970
hasn't been renamed right I did this

00:13:07,780 --> 00:13:11,800
extra step in between and by scrolling

00:13:09,970 --> 00:13:13,750
to the result very quickly trying to get

00:13:11,800 --> 00:13:15,220
to you know find me all the Brazilian

00:13:13,750 --> 00:13:18,220
players in the updated data set I

00:13:15,220 --> 00:13:19,780
skipped a step in between and so what I

00:13:18,220 --> 00:13:21,430
had would have to do is actually go back

00:13:19,780 --> 00:13:23,649
and either run all from the top

00:13:21,430 --> 00:13:25,690
or run all the cells from that initial

00:13:23,649 --> 00:13:27,339
fix that I ran all the way down to what

00:13:25,690 --> 00:13:29,050
I wanted right and that can still leave

00:13:27,339 --> 00:13:32,050
to to potential issues

00:13:29,050 --> 00:13:34,540
okay so referencing intermediate results

00:13:32,050 --> 00:13:37,000
there are uses for them they work well

00:13:34,540 --> 00:13:38,410
in the eye in sort of the console

00:13:37,000 --> 00:13:41,440
version of or the standard version of

00:13:38,410 --> 00:13:43,029
ipython but this strategy of using the

00:13:41,440 --> 00:13:45,430
output dictionary to store results using

00:13:43,029 --> 00:13:47,170
numerical IDs that's problematic because

00:13:45,430 --> 00:13:50,140
these cell IDs change when things that

00:13:47,170 --> 00:13:51,520
are Reax acute 'add strategy of using

00:13:50,140 --> 00:13:53,410
the underscore variables to reference

00:13:51,520 --> 00:13:55,029
last results that's the problem of out

00:13:53,410 --> 00:13:57,279
of order execution right so it's not

00:13:55,029 --> 00:13:59,860
what you see previously it's what you

00:13:57,279 --> 00:14:01,660
last executed and the strategy of global

00:13:59,860 --> 00:14:03,490
variables works pretty well you just

00:14:01,660 --> 00:14:05,770
have to worry about again some out of

00:14:03,490 --> 00:14:07,810
execution things or if you're mutating

00:14:05,770 --> 00:14:10,180
that value in different cells to

00:14:07,810 --> 00:14:11,529
different values which one ret last ran

00:14:10,180 --> 00:14:16,630
you sorta have to keep track of that in

00:14:11,529 --> 00:14:18,820
your head so one piece of the solution

00:14:16,630 --> 00:14:20,890
that we thought about is why do we keep

00:14:18,820 --> 00:14:22,690
changing these identifiers when things

00:14:20,890 --> 00:14:24,610
get rerun right why not just have sort

00:14:22,690 --> 00:14:27,040
of a persistent unique identifier so

00:14:24,610 --> 00:14:29,890
assign each cell at an ID when it's

00:14:27,040 --> 00:14:31,420
created maintain that ID forever close

00:14:29,890 --> 00:14:33,550
the notebook you reopen it still the

00:14:31,420 --> 00:14:34,900
same ID and that way we can reference

00:14:33,550 --> 00:14:37,240
old cells in a way that won't change

00:14:34,900 --> 00:14:38,860
when we restart the notebook and we

00:14:37,240 --> 00:14:40,600
didn't want to imply any sort of order

00:14:38,860 --> 00:14:42,130
to these IDs so we use sort of random

00:14:40,600 --> 00:14:43,950
numbers so that if you move cells up and

00:14:42,130 --> 00:14:46,000
down you know there's not a whole lot

00:14:43,950 --> 00:14:48,190
you're not supposed to infer anything

00:14:46,000 --> 00:14:50,830
that cells one up is above of cell tooth

00:14:48,190 --> 00:14:53,050
or a below cell three so we use random

00:14:50,830 --> 00:14:53,860
integers and we brought them in hex to

00:14:53,050 --> 00:14:55,570
make him look more

00:14:53,860 --> 00:14:59,560
I don't know techie or something like

00:14:55,570 --> 00:15:01,450
that and you get a slightly changed

00:14:59,560 --> 00:15:03,250
notebook where you have the input and

00:15:01,450 --> 00:15:05,020
it's got this hexadecimal representation

00:15:03,250 --> 00:15:07,779
and then the output has the same

00:15:05,020 --> 00:15:10,300
hexadecimal representation we said great

00:15:07,779 --> 00:15:13,150
we can persistently reference cells this

00:15:10,300 --> 00:15:14,440
is going to be a big win and then we

00:15:13,150 --> 00:15:16,240
thought about it a little bit and said

00:15:14,440 --> 00:15:17,620
well who's gonna remember these

00:15:16,240 --> 00:15:20,170
identifiers who's gonna want to type

00:15:17,620 --> 00:15:22,750
these identifiers right oh yeah cell 51

00:15:20,170 --> 00:15:25,630
do 3e that was that one where I squared

00:15:22,750 --> 00:15:26,740
twelve no that's that's not the way

00:15:25,630 --> 00:15:29,050
people think that's not the way people

00:15:26,740 --> 00:15:30,820
want to work so we thought about it a

00:15:29,050 --> 00:15:32,650
little harder we said what do we want to

00:15:30,820 --> 00:15:35,200
happen we want people to be able to name

00:15:32,650 --> 00:15:36,910
their variables to be whatever they

00:15:35,200 --> 00:15:38,800
want them to be right so if you output a

00:15:36,910 --> 00:15:42,520
particular value and you want to name it

00:15:38,800 --> 00:15:44,620
as DF or cat or whatever you want you

00:15:42,520 --> 00:15:47,050
can name it the way you want and use

00:15:44,620 --> 00:15:48,970
those names as reference in other cells

00:15:47,050 --> 00:15:53,860
don't have to reference some made-up

00:15:48,970 --> 00:15:56,590
number for you okay so what does this

00:15:53,860 --> 00:15:58,870
allow us these persistent ids well we

00:15:56,590 --> 00:16:00,250
don't need the linear top-down notebooks

00:15:58,870 --> 00:16:01,810
anymore because we're referencing

00:16:00,250 --> 00:16:04,630
specific cells that aren't going to

00:16:01,810 --> 00:16:06,490
change so if as long as we sort of point

00:16:04,630 --> 00:16:09,580
to the right places we can execute the

00:16:06,490 --> 00:16:10,990
cells as needed right so we can we can

00:16:09,580 --> 00:16:12,670
run the cells in the right order we have

00:16:10,990 --> 00:16:15,460
these unique references since each

00:16:12,670 --> 00:16:18,130
variable is output once by a particular

00:16:15,460 --> 00:16:20,080
cell and then we know which cells need

00:16:18,130 --> 00:16:21,760
to be rerun to allow a cell to execute

00:16:20,080 --> 00:16:23,380
that once piece is something I'm going

00:16:21,760 --> 00:16:25,720
to come back to right so you're only

00:16:23,380 --> 00:16:28,660
allowed to sort of set a value to a

00:16:25,720 --> 00:16:30,520
variable once and then we can sort of

00:16:28,660 --> 00:16:33,100
recursive the chain and this is similar

00:16:30,520 --> 00:16:35,110
to data flows something I worked a lot

00:16:33,100 --> 00:16:36,880
in I did scientific workflows and things

00:16:35,110 --> 00:16:39,070
like that so you know this is this was

00:16:36,880 --> 00:16:41,290
great for me it's also similar to sort

00:16:39,070 --> 00:16:43,150
of functional programming a cell waits

00:16:41,290 --> 00:16:45,190
for its inputs to be up to date may

00:16:43,150 --> 00:16:50,380
involve executing things a sort of that

00:16:45,190 --> 00:16:52,480
it depends on and then it executes so

00:16:50,380 --> 00:16:54,010
this data flow idea you can draw a nice

00:16:52,480 --> 00:16:55,780
pictures of them sort of a set of

00:16:54,010 --> 00:16:57,600
computational modules there are

00:16:55,780 --> 00:17:00,460
connections between the outputs of one

00:16:57,600 --> 00:17:02,170
module to the inputs of another module

00:17:00,460 --> 00:17:04,360
and then the execution can sort of

00:17:02,170 --> 00:17:06,430
happen bottom-up so you have these

00:17:04,360 --> 00:17:08,170
things of upstream dependencies where

00:17:06,430 --> 00:17:10,000
things have to execute before I can

00:17:08,170 --> 00:17:12,579
execute it's a cell that I'm interested

00:17:10,000 --> 00:17:15,630
in or downstream dependencies where if I

00:17:12,579 --> 00:17:18,790
execute the cell what's going to change

00:17:15,630 --> 00:17:20,709
so let's just pivot this and turn

00:17:18,790 --> 00:17:22,540
something dataflow notebooks where we

00:17:20,709 --> 00:17:25,570
basically just replace the name module

00:17:22,540 --> 00:17:27,339
with cell right so instead of having

00:17:25,570 --> 00:17:29,140
these computational modules we're going

00:17:27,339 --> 00:17:31,240
to treat our cells sort of like these

00:17:29,140 --> 00:17:32,620
modules right they're gonna have they're

00:17:31,240 --> 00:17:34,870
going to take inputs from other cells

00:17:32,620 --> 00:17:37,060
they're going to have outputs for those

00:17:34,870 --> 00:17:39,430
cells and then we have the same sort of

00:17:37,060 --> 00:17:41,500
terminology and that the execution can

00:17:39,430 --> 00:17:44,730
happen recursively we have upstream and

00:17:41,500 --> 00:17:44,730
downstream cells

00:17:45,320 --> 00:17:49,530
all right so how does this work all

00:17:48,270 --> 00:17:51,600
right if I mean this sort of restrict

00:17:49,530 --> 00:17:54,300
variables and have these references fly

00:17:51,600 --> 00:17:55,740
around we're going to kind of wall off

00:17:54,300 --> 00:18:00,120
cells from each other we'll put them in

00:17:55,740 --> 00:18:02,910
a closure and that'll keep variables

00:18:00,120 --> 00:18:04,440
local to a single cell and this would be

00:18:02,910 --> 00:18:05,820
great except you can't get anything out

00:18:04,440 --> 00:18:07,980
of the cell then you build a wall around

00:18:05,820 --> 00:18:10,110
the cell nothing comes out of it so we

00:18:07,980 --> 00:18:11,640
make an exception in that the last line

00:18:10,110 --> 00:18:14,460
of the cell

00:18:11,640 --> 00:18:17,280
whatever outputs are either listed as a

00:18:14,460 --> 00:18:20,400
tuple an expression or assigned to as a

00:18:17,280 --> 00:18:21,870
tuple those become sort of elevated to

00:18:20,400 --> 00:18:24,630
this output status those can be

00:18:21,870 --> 00:18:25,920
referenced from other cells and because

00:18:24,630 --> 00:18:27,480
of this we have to sort of disallow

00:18:25,920 --> 00:18:29,940
duplicate outputs right so if a is

00:18:27,480 --> 00:18:31,920
output from two different cells we don't

00:18:29,940 --> 00:18:33,810
know which one you're trying to refer to

00:18:31,920 --> 00:18:36,510
when you refer to a and another cell so

00:18:33,810 --> 00:18:39,750
we say one output or an output can only

00:18:36,510 --> 00:18:41,850
occur in one cell but you can still have

00:18:39,750 --> 00:18:43,830
unnamed output so if you just want to

00:18:41,850 --> 00:18:45,000
sort of plot something or calculate

00:18:43,830 --> 00:18:47,130
something and you don't care about

00:18:45,000 --> 00:18:48,930
referencing it later on you can just

00:18:47,130 --> 00:18:51,120
type an expression and it'll generate

00:18:48,930 --> 00:18:52,830
the plot or they'll generate the value

00:18:51,120 --> 00:18:54,870
right and you if you want you can even

00:18:52,830 --> 00:18:57,570
connect those via those hexadecimal

00:18:54,870 --> 00:19:03,630
ideas so those out of hexadecimal

00:18:57,570 --> 00:19:05,820
identify our thing will work the other

00:19:03,630 --> 00:19:07,260
piece is okay you can output things from

00:19:05,820 --> 00:19:08,910
the cells but you need precise

00:19:07,260 --> 00:19:11,430
connections between those cells then

00:19:08,910 --> 00:19:14,280
right how do I connect an output from

00:19:11,430 --> 00:19:15,810
one cell to an input in another cell so

00:19:14,280 --> 00:19:17,580
the great thing is you just write your

00:19:15,810 --> 00:19:19,170
code as normal right if you output

00:19:17,580 --> 00:19:20,670
something by a particular name and you

00:19:19,170 --> 00:19:23,220
want to reference that you type the

00:19:20,670 --> 00:19:26,100
variables name and then we figure out

00:19:23,220 --> 00:19:27,630
inside of the cell how to connect the

00:19:26,100 --> 00:19:29,520
value that you're trying to reference to

00:19:27,630 --> 00:19:32,130
the upstream cell and because it's in

00:19:29,520 --> 00:19:33,630
another cell we can do this same sort of

00:19:32,130 --> 00:19:36,390
recursive execution so if you haven't

00:19:33,630 --> 00:19:38,250
executed the upstream cell we point to

00:19:36,390 --> 00:19:39,990
that cell we can execute that cell make

00:19:38,250 --> 00:19:43,050
sure things are up-to-date and then run

00:19:39,990 --> 00:19:44,580
the next cell and this is important

00:19:43,050 --> 00:19:46,950
because the notebook sort of gets to

00:19:44,580 --> 00:19:48,480
know when cells are stale something up

00:19:46,950 --> 00:19:50,670
streams changed right so you change

00:19:48,480 --> 00:19:52,440
something that can impact all kinds of

00:19:50,670 --> 00:19:54,120
stuff in your notebook you want to know

00:19:52,440 --> 00:19:55,860
about that right you don't want to just

00:19:54,120 --> 00:19:57,420
sort of be like oh I change this value

00:19:55,860 --> 00:19:57,960
what might have changed well I could do

00:19:57,420 --> 00:19:59,340
run all

00:19:57,960 --> 00:20:01,140
but I don't want to run all I want to

00:19:59,340 --> 00:20:02,970
run only the things that are affected by

00:20:01,140 --> 00:20:04,289
that right and this is something that we

00:20:02,970 --> 00:20:09,600
can do if we have this data flow

00:20:04,289 --> 00:20:12,409
structure to the notebook okay so what

00:20:09,600 --> 00:20:12,409
does this actually look like

00:20:13,500 --> 00:20:18,289
here's your sort of a notebook in this

00:20:15,659 --> 00:20:20,460
data flow world you can see the nice

00:20:18,289 --> 00:20:21,960
hexadecimal identifier these persistent

00:20:20,460 --> 00:20:26,039
identifiers remember they're not going

00:20:21,960 --> 00:20:28,260
to change as the notebook executes we

00:20:26,039 --> 00:20:30,270
also have named outputs so when you

00:20:28,260 --> 00:20:32,549
generate an output instead of seeing out

00:20:30,270 --> 00:20:33,720
of some identifiers we'll actually just

00:20:32,549 --> 00:20:36,960
put the name of the variable that's

00:20:33,720 --> 00:20:38,580
output and then you also have unnamed

00:20:36,960 --> 00:20:40,830
output so if you don't specify a name

00:20:38,580 --> 00:20:42,840
either in an assignment or an expression

00:20:40,830 --> 00:20:46,260
we'll just use whatever the ID of the

00:20:42,840 --> 00:20:48,600
cell is and the connection then is done

00:20:46,260 --> 00:20:50,669
by variable reference so you can see

00:20:48,600 --> 00:20:53,130
that I'm using some of those names that

00:20:50,669 --> 00:20:58,080
were output in other cells in some of

00:20:53,130 --> 00:21:00,169
the later cells alright so you might be

00:20:58,080 --> 00:21:03,299
wondering how does this actually work

00:21:00,169 --> 00:21:05,610
what we settled on was sort of creating

00:21:03,299 --> 00:21:08,429
a new kernel basing it on the I pi

00:21:05,610 --> 00:21:10,620
kernel and making some updates to it to

00:21:08,429 --> 00:21:13,230
sort of support this data flow style

00:21:10,620 --> 00:21:14,610
execution we modify sort of both the

00:21:13,230 --> 00:21:16,230
interface and the execution right

00:21:14,610 --> 00:21:18,000
because we have to have these weird

00:21:16,230 --> 00:21:19,919
identifiers we're changing how the

00:21:18,000 --> 00:21:22,230
output looks instead of just having

00:21:19,919 --> 00:21:24,029
these numeric cell IDs so there's some

00:21:22,230 --> 00:21:26,059
hacking and extensions to the notebook

00:21:24,029 --> 00:21:28,890
as well some of it gets a little ugly

00:21:26,059 --> 00:21:30,720
some more details we're using a custom

00:21:28,890 --> 00:21:33,450
namespace to intercept the variable

00:21:30,720 --> 00:21:35,370
access and this custom namespace is sort

00:21:33,450 --> 00:21:37,169
of listening for these global these

00:21:35,370 --> 00:21:39,539
outputs of other cell references right

00:21:37,169 --> 00:21:42,090
so you reference a that was output in a

00:21:39,539 --> 00:21:44,250
cell somewhere else figuring out where

00:21:42,090 --> 00:21:46,440
to get that output from is what happens

00:21:44,250 --> 00:21:51,750
when you hit the namespace when you're

00:21:46,440 --> 00:21:53,820
looking up a variable and locals and so

00:21:51,750 --> 00:21:55,980
what that allows us to do is run in the

00:21:53,820 --> 00:21:59,760
upstream dependencies run the cell and

00:21:55,980 --> 00:22:01,559
pull out the specific input so you don't

00:21:59,760 --> 00:22:03,750
have to have a single output per cell

00:22:01,559 --> 00:22:05,460
the example that I showed only shows a

00:22:03,750 --> 00:22:07,440
single output but you can have multiple

00:22:05,460 --> 00:22:09,179
outputs per cell and so we may have to

00:22:07,440 --> 00:22:11,760
pull out just one of the outputs that's

00:22:09,179 --> 00:22:15,250
generated from a cell

00:22:11,760 --> 00:22:16,930
we can also cache outputs so that they

00:22:15,250 --> 00:22:18,190
don't have to be recomputed right so if

00:22:16,930 --> 00:22:20,170
you've already run something nothing

00:22:18,190 --> 00:22:22,200
about those cells has changed there's no

00:22:20,170 --> 00:22:24,910
reason to rerun that cell probably

00:22:22,200 --> 00:22:27,520
assuming it's a deterministic style

00:22:24,910 --> 00:22:30,040
computation and then some other dirty

00:22:27,520 --> 00:22:31,690
details is we're sort of augmenting the

00:22:30,040 --> 00:22:34,300
run ast nodes we're looking at the

00:22:31,690 --> 00:22:36,700
abstract syntax tree that's parsed out

00:22:34,300 --> 00:22:38,440
of the code and we wrap that in a

00:22:36,700 --> 00:22:40,390
closure and then we customize the

00:22:38,440 --> 00:22:43,120
execution at the last line so that the

00:22:40,390 --> 00:22:45,280
closure returns those internal variables

00:22:43,120 --> 00:22:47,590
so that they can be promoted to be

00:22:45,280 --> 00:22:50,170
accessed from other cells and we sort of

00:22:47,590 --> 00:22:52,270
wrap it in this structure so that we can

00:22:50,170 --> 00:22:54,070
track things a structure that has both a

00:22:52,270 --> 00:22:58,660
reference to the cell and the name of

00:22:54,070 --> 00:23:01,060
the output that we want okay so that's a

00:22:58,660 --> 00:23:02,530
lot of the details you know what does

00:23:01,060 --> 00:23:04,240
this mean what does this help in terms

00:23:02,530 --> 00:23:05,920
of understanding things right you've

00:23:04,240 --> 00:23:08,470
added these things but how do I actually

00:23:05,920 --> 00:23:10,810
understand the notebooks now and so this

00:23:08,470 --> 00:23:12,370
is something that after we sort of put

00:23:10,810 --> 00:23:13,630
this thing together it seemed to work we

00:23:12,370 --> 00:23:15,550
said what what can we actually learn

00:23:13,630 --> 00:23:18,280
about the notebooks can we see what's

00:23:15,550 --> 00:23:19,480
going on with our notebooks better and

00:23:18,280 --> 00:23:22,030
one of the things we thought about was

00:23:19,480 --> 00:23:24,760
can we add sort of statuses for cells

00:23:22,030 --> 00:23:26,320
right things like this cell is new where

00:23:24,760 --> 00:23:28,930
this cell has never been executed but

00:23:26,320 --> 00:23:31,480
I've added some content to it or instead

00:23:28,930 --> 00:23:33,250
of having the the identifier changed to

00:23:31,480 --> 00:23:36,340
an asterisk maybe we'll just make a nice

00:23:33,250 --> 00:23:37,990
icon that shows executing and then green

00:23:36,340 --> 00:23:39,940
and red indicate you know things are

00:23:37,990 --> 00:23:41,350
good or things are bad so exceptions

00:23:39,940 --> 00:23:44,170
have happened in a particular cell or

00:23:41,350 --> 00:23:46,240
this cell has run successfully and it's

00:23:44,170 --> 00:23:48,370
still up to date right so if something

00:23:46,240 --> 00:23:51,670
happened with an upstream cell that

00:23:48,370 --> 00:23:53,200
modifies or that that may affect the

00:23:51,670 --> 00:23:55,900
downstream cell we have to be aware of

00:23:53,200 --> 00:23:59,710
that and so that's what this exclamation

00:23:55,900 --> 00:24:01,750
point icon this still status icon sort

00:23:59,710 --> 00:24:03,760
of tells us is something changed that

00:24:01,750 --> 00:24:05,290
may affect your output in this cell

00:24:03,760 --> 00:24:06,610
right so you know that something might

00:24:05,290 --> 00:24:08,800
have changed you may need to re execute

00:24:06,610 --> 00:24:10,480
this so and then we have a couple other

00:24:08,800 --> 00:24:14,010
things for specifically for when you

00:24:10,480 --> 00:24:16,420
save a notebook and you reopen it

00:24:14,010 --> 00:24:19,030
assuming everything executed left right

00:24:16,420 --> 00:24:20,620
the last time probably going to execute

00:24:19,030 --> 00:24:22,570
right this time right you can sort of

00:24:20,620 --> 00:24:24,250
say this this is probably a check mark

00:24:22,570 --> 00:24:25,630
or this was an exception the last time

00:24:24,250 --> 00:24:27,280
put it in yellow beak

00:24:25,630 --> 00:24:28,990
it's not certain you may be running this

00:24:27,280 --> 00:24:30,310
notebook in a different environment may

00:24:28,990 --> 00:24:32,470
be running it two years later with

00:24:30,310 --> 00:24:36,340
different versions of packages things

00:24:32,470 --> 00:24:38,170
like that along with that we wanted to

00:24:36,340 --> 00:24:40,330
sort of give a view of how things

00:24:38,170 --> 00:24:42,910
connect right so you may have this

00:24:40,330 --> 00:24:44,590
mental map of what variables were output

00:24:42,910 --> 00:24:46,210
from a particular cell and what

00:24:44,590 --> 00:24:48,100
variables are used in a particular cell

00:24:46,210 --> 00:24:52,150
but one to be nice to actually see that

00:24:48,100 --> 00:24:54,790
better and so this we added a toolbar to

00:24:52,150 --> 00:24:57,340
the data flow of cells that let us look

00:24:54,790 --> 00:24:59,260
at the names of the variables and also

00:24:57,340 --> 00:25:01,000
select all of the upstream or all of the

00:24:59,260 --> 00:25:04,480
downstream that's what the arrow icons

00:25:01,000 --> 00:25:05,830
there are so those arrow icons allow us

00:25:04,480 --> 00:25:09,100
to select all the upstream or downstream

00:25:05,830 --> 00:25:11,170
cells we show the input variable names

00:25:09,100 --> 00:25:13,150
in blue and the output variable names in

00:25:11,170 --> 00:25:15,510
red and then there's a couple other

00:25:13,150 --> 00:25:19,450
icons that we've been experimenting with

00:25:15,510 --> 00:25:21,460
one of them is forced cached the idea

00:25:19,450 --> 00:25:23,980
that hey I have a cell that's going to

00:25:21,460 --> 00:25:25,990
run for an hour I don't want that to be

00:25:23,980 --> 00:25:28,720
automatically updated just because some

00:25:25,990 --> 00:25:31,030
parameter at the top changed right when

00:25:28,720 --> 00:25:32,890
I rerun it sort of for my final analysis

00:25:31,030 --> 00:25:34,870
you can re-execute it but I don't want

00:25:32,890 --> 00:25:36,400
you automatically rerunning that cell

00:25:34,870 --> 00:25:37,810
specifically right and so that allows

00:25:36,400 --> 00:25:40,420
you to sort of force the cached version

00:25:37,810 --> 00:25:42,070
it'll keep the icons as yellow in that

00:25:40,420 --> 00:25:43,810
case because you're not necessarily

00:25:42,070 --> 00:25:46,420
correct if you were to rerun that

00:25:43,810 --> 00:25:47,950
notebook in a later session but it

00:25:46,420 --> 00:25:49,630
allows you to sort of experiment and

00:25:47,950 --> 00:25:52,090
play around with making things work

00:25:49,630 --> 00:25:55,240
before running that hour-long cell or

00:25:52,090 --> 00:25:57,520
you know even 10 minute long so and then

00:25:55,240 --> 00:25:59,290
the last icon is is what we've called

00:25:57,520 --> 00:26:02,980
Auto refresh but probably is more

00:25:59,290 --> 00:26:05,680
familiar in as sort of reactive mode so

00:26:02,980 --> 00:26:07,720
the idea is can I rerun a cell if it

00:26:05,680 --> 00:26:09,520
becomes stale right so any cell I

00:26:07,720 --> 00:26:11,140
changed something upstream of it can I

00:26:09,520 --> 00:26:13,240
just have it update right I don't have

00:26:11,140 --> 00:26:15,040
to wait for things to you know okay it's

00:26:13,240 --> 00:26:16,570
yellow I need to go update it just have

00:26:15,040 --> 00:26:19,470
it automatically update so I don't even

00:26:16,570 --> 00:26:19,470
have to worry about it

00:26:20,460 --> 00:26:25,750
and then finally we thought well this is

00:26:23,380 --> 00:26:28,870
a graph so let's throw it into graph is

00:26:25,750 --> 00:26:31,930
and create a nice graph we use the the

00:26:28,870 --> 00:26:33,520
JavaScript version of this viziers to

00:26:31,930 --> 00:26:35,290
sort of generate this graph so we can

00:26:33,520 --> 00:26:36,910
display it in the browser but this

00:26:35,290 --> 00:26:38,800
allows us to show connections between

00:26:36,910 --> 00:26:39,429
the cells you can see more of sort of

00:26:38,800 --> 00:26:41,859
the layout

00:26:39,429 --> 00:26:43,479
of you know if I change this cell what

00:26:41,859 --> 00:26:45,759
cells are affected in sort of a more

00:26:43,479 --> 00:26:48,609
global view than having to scroll up and

00:26:45,759 --> 00:26:50,559
down in the notebook and one of the cool

00:26:48,609 --> 00:26:51,940
things is we have the same colors to

00:26:50,559 --> 00:26:53,320
sort of indicate when things are stale

00:26:51,940 --> 00:26:55,659
when things have been executed correctly

00:26:53,320 --> 00:26:57,549
when there are exceptions but it's also

00:26:55,659 --> 00:26:59,739
linked to the notebook so if you hover

00:26:57,549 --> 00:27:01,269
over a particular cell part of the

00:26:59,739 --> 00:27:03,279
window still shows in the notebook and

00:27:01,269 --> 00:27:05,889
you can see this the code associated

00:27:03,279 --> 00:27:07,659
with that cell and you can also sort of

00:27:05,889 --> 00:27:11,580
do some executions and other operations

00:27:07,659 --> 00:27:11,580
in the graph instead of in the notebook

00:27:12,570 --> 00:27:16,629
okay so we've gotten to that point in

00:27:15,039 --> 00:27:25,479
time where I'm going to attempt to do a

00:27:16,629 --> 00:27:27,399
demo so here is a notebook I'm using the

00:27:25,479 --> 00:27:28,839
digits data set doing some machine

00:27:27,399 --> 00:27:30,369
learning on that if you were in the

00:27:28,839 --> 00:27:33,339
previous session you've seen much of

00:27:30,369 --> 00:27:35,739
this before but what I'm doing at the

00:27:33,339 --> 00:27:36,700
top is I'm importing some libraries one

00:27:35,739 --> 00:27:38,649
thing you'll note is I'm actually

00:27:36,700 --> 00:27:40,119
putting the names of those libraries as

00:27:38,649 --> 00:27:43,149
outputs that I can reference them from

00:27:40,119 --> 00:27:45,369
other cells now this seems a little

00:27:43,149 --> 00:27:47,169
clunky in that if you're importing

00:27:45,369 --> 00:27:49,149
libraries why shouldn't they just be

00:27:47,169 --> 00:27:51,009
available in every cell right so there

00:27:49,149 --> 00:27:52,869
is a shortcut here if I don't actually

00:27:51,009 --> 00:27:55,599
import those we have a configuration

00:27:52,869 --> 00:27:57,219
option that says automatically import

00:27:55,599 --> 00:27:58,570
the libraries make those global all the

00:27:57,219 --> 00:28:00,369
time right because that's generally

00:27:58,570 --> 00:28:01,269
going to be case if you import a library

00:28:00,369 --> 00:28:02,679
you don't want to have to sort of

00:28:01,269 --> 00:28:06,369
specify which cells it's going to be

00:28:02,679 --> 00:28:08,859
used to and then what we can do is load

00:28:06,369 --> 00:28:10,330
in the digits data set and one thing

00:28:08,859 --> 00:28:12,299
you'll notice about the digits data set

00:28:10,330 --> 00:28:14,919
is it comes in as a dictionary with

00:28:12,299 --> 00:28:17,469
various fields so the data the target

00:28:14,919 --> 00:28:19,029
the images things like that one thing we

00:28:17,469 --> 00:28:21,669
thought about is adding a magic command

00:28:19,029 --> 00:28:24,059
here specifically for mappings like this

00:28:21,669 --> 00:28:28,809
where we can split things out so

00:28:24,059 --> 00:28:30,399
multiple outputs we saw in the modules

00:28:28,809 --> 00:28:32,080
up here you can see instead of just a

00:28:30,399 --> 00:28:33,999
single output I'm naming four different

00:28:32,080 --> 00:28:36,009
outputs same thing then can happen with

00:28:33,999 --> 00:28:37,960
this data where I can get four different

00:28:36,009 --> 00:28:40,359
out or five different outputs here right

00:28:37,960 --> 00:28:42,669
the data the target the target names the

00:28:40,359 --> 00:28:45,940
images and then the description at the

00:28:42,669 --> 00:28:47,309
end right and I can collapse this so

00:28:45,940 --> 00:28:49,359
that I don't have to see it all the time

00:28:47,309 --> 00:28:51,129
so one thing I might want to see is

00:28:49,359 --> 00:28:53,230
maybe a visualization of some of the

00:28:51,129 --> 00:28:56,169
training data and in this case

00:28:53,230 --> 00:28:58,540
I'm referencing a function make plots in

00:28:56,169 --> 00:29:00,520
this case one thing you'll note if I run

00:28:58,540 --> 00:29:03,400
this directly is it says o make plots is

00:29:00,520 --> 00:29:06,370
not defined and so that's because I put

00:29:03,400 --> 00:29:10,330
make plots as a method down here if I

00:29:06,370 --> 00:29:13,090
define it and then go back to the

00:29:10,330 --> 00:29:15,520
original cell then I can run that it's

00:29:13,090 --> 00:29:17,290
going to give me a map pop lib output

00:29:15,520 --> 00:29:20,919
that shows sort of the training data set

00:29:17,290 --> 00:29:22,059
how we have the labeled names and that's

00:29:20,919 --> 00:29:25,540
how we're going to be training this

00:29:22,059 --> 00:29:28,570
algorithm okay we can do a test train

00:29:25,540 --> 00:29:30,210
split so in this case we'll split things

00:29:28,570 --> 00:29:33,520
into X train X test

00:29:30,210 --> 00:29:35,530
y train Y test you'll note that I'm

00:29:33,520 --> 00:29:38,980
doing an assignment here I've done this

00:29:35,530 --> 00:29:40,330
before but the assignment is actually

00:29:38,980 --> 00:29:43,059
setting these output variables so that

00:29:40,330 --> 00:29:45,340
last line I python in a recent release

00:29:43,059 --> 00:29:47,770
sort of added this mode where you could

00:29:45,340 --> 00:29:50,530
have assignment expressions also be

00:29:47,770 --> 00:29:52,210
output as well as sort of the last

00:29:50,530 --> 00:29:54,340
expression which is the normal case in

00:29:52,210 --> 00:29:56,080
ipython and so we sort of extend this

00:29:54,340 --> 00:29:57,970
and say well if you output a tuple let's

00:29:56,080 --> 00:30:00,540
show that all of those outputs as names

00:29:57,970 --> 00:30:01,780
that can be referenced in later cells

00:30:00,540 --> 00:30:04,980
okay

00:30:01,780 --> 00:30:08,740
now to the fun stuff let's create a SV

00:30:04,980 --> 00:30:11,080
SVM classifier and then I can run

00:30:08,740 --> 00:30:15,220
through some stuff to generate expected

00:30:11,080 --> 00:30:17,230
and predicted I can look at again I

00:30:15,220 --> 00:30:19,650
forgot to run this function PD scores

00:30:17,230 --> 00:30:25,059
which will generate me a nicer table

00:30:19,650 --> 00:30:29,410
from the F scores go back and rerun that

00:30:25,059 --> 00:30:31,120
I can do a confusion matrix right and

00:30:29,410 --> 00:30:33,130
then finally what I might want to see is

00:30:31,120 --> 00:30:36,970
how does this thing work right test it

00:30:33,130 --> 00:30:39,070
off on a few of these of these examples

00:30:36,970 --> 00:30:43,030
and I should mention this is building on

00:30:39,070 --> 00:30:44,890
a out Vera Claus original example so

00:30:43,030 --> 00:30:47,020
this looks familiar you've seen it in

00:30:44,890 --> 00:30:50,080
this scikit-learn documentation it's

00:30:47,020 --> 00:30:52,990
coming from there okay so now I've

00:30:50,080 --> 00:30:54,669
executed the cells in the notebook one

00:30:52,990 --> 00:30:56,620
thing I might want to do now is is play

00:30:54,669 --> 00:30:57,940
around with this gamma value right and

00:30:56,620 --> 00:31:00,520
so one thing I'll do is maybe I'll set

00:30:57,940 --> 00:31:02,620
it to zero point zero zero one and what

00:31:00,520 --> 00:31:04,210
you notice is those status icons now

00:31:02,620 --> 00:31:06,280
change right so instead of all being

00:31:04,210 --> 00:31:06,850
green I now see a bunch of yellow in

00:31:06,280 --> 00:31:08,770
here

00:31:06,850 --> 00:31:12,040
this is notifying me that all of these

00:31:08,770 --> 00:31:16,620
things in yellow may be affected by that

00:31:12,040 --> 00:31:19,840
change the things above are still green

00:31:16,620 --> 00:31:21,820
but I can go and jump directly to the

00:31:19,840 --> 00:31:23,560
thing I care about was which is can I

00:31:21,820 --> 00:31:25,720
see if this changes on some of the the

00:31:23,560 --> 00:31:28,090
random prediction data right and what

00:31:25,720 --> 00:31:29,710
happens is it will it knows the notebook

00:31:28,090 --> 00:31:32,230
knows because of all the references this

00:31:29,710 --> 00:31:33,940
data flow graph that it's set up which

00:31:32,230 --> 00:31:35,230
things to execute and you'll notice the

00:31:33,940 --> 00:31:37,750
confusion matrix didn't need to be

00:31:35,230 --> 00:31:40,180
reacts acute 'add this example doesn't

00:31:37,750 --> 00:31:41,800
depend on the confusion matrix so that

00:31:40,180 --> 00:31:42,850
doesn't have to be reacts acute 'add but

00:31:41,800 --> 00:31:44,560
the other piece is in terms of

00:31:42,850 --> 00:31:46,990
generating the expected and predicted

00:31:44,560 --> 00:31:48,280
data do have to be Rexha cuted right we

00:31:46,990 --> 00:31:50,020
can see this changes some of the

00:31:48,280 --> 00:31:51,550
predictions we see a nine here instead

00:31:50,020 --> 00:31:57,450
of an eight and a six here instead of

00:31:51,550 --> 00:32:03,850
knee so another thing to note is the

00:31:57,450 --> 00:32:10,410
toolbar for the data flow and so if I go

00:32:03,850 --> 00:32:10,410
to something like the classifier or

00:32:10,440 --> 00:32:14,980
maybe expected predicted isn't better

00:32:12,760 --> 00:32:16,870
one right what you can see again here is

00:32:14,980 --> 00:32:20,590
I can highlight everything upstream all

00:32:16,870 --> 00:32:23,260
the cells that sort of impact the the

00:32:20,590 --> 00:32:25,210
classifier is inputs and then I can see

00:32:23,260 --> 00:32:26,890
that this classifier is what the output

00:32:25,210 --> 00:32:28,810
is the named output that's generated

00:32:26,890 --> 00:32:30,280
right that's fairly clear from the last

00:32:28,810 --> 00:32:36,040
cell but this gives you sort of a nice

00:32:30,280 --> 00:32:38,410
way to look at things right so one other

00:32:36,040 --> 00:32:40,090
piece is what I'd like to do is show

00:32:38,410 --> 00:32:43,450
what happens when you you know so if I

00:32:40,090 --> 00:32:45,670
save this notebook and then have to

00:32:43,450 --> 00:32:47,200
generate a new tab before I close it in

00:32:45,670 --> 00:32:49,420
otherwise I'll lose things so close this

00:32:47,200 --> 00:32:54,400
notebook and then I'll go back and

00:32:49,420 --> 00:32:55,930
reopen it so here everything shows up

00:32:54,400 --> 00:32:57,670
with these yellow icons because I don't

00:32:55,930 --> 00:32:59,410
know if things are correct anymore right

00:32:57,670 --> 00:33:03,160
this could be me opening the notebook

00:32:59,410 --> 00:33:04,930
two years later and so what I can still

00:33:03,160 --> 00:33:06,370
do though is if I scroll down to sort of

00:33:04,930 --> 00:33:07,990
the main thing that I care about which

00:33:06,370 --> 00:33:11,320
might be what are the predictions look

00:33:07,990 --> 00:33:13,540
like I can just run that from sort of a

00:33:11,320 --> 00:33:14,980
cold state and because the notebook has

00:33:13,540 --> 00:33:17,440
stored information about what the

00:33:14,980 --> 00:33:18,940
dependency graph looks like free it can

00:33:17,440 --> 00:33:19,070
automatically figure out what needs to

00:33:18,940 --> 00:33:21,139
be

00:33:19,070 --> 00:33:23,630
you run at that time so once you've done

00:33:21,139 --> 00:33:25,639
it once it persists sort of that state

00:33:23,630 --> 00:33:26,809
those connections between the cells so

00:33:25,639 --> 00:33:29,210
that when you open it again in another

00:33:26,809 --> 00:33:30,590
session or somebody else opens it they

00:33:29,210 --> 00:33:33,019
don't have to go through and sort of

00:33:30,590 --> 00:33:34,580
worry about at which cells need to be

00:33:33,019 --> 00:33:44,779
executed which cells don't need to be

00:33:34,580 --> 00:33:46,519
executed so that's the the demo there's

00:33:44,779 --> 00:33:49,100
one other demo that I wasn't going to

00:33:46,519 --> 00:33:50,299
try live so I recorded this instead but

00:33:49,100 --> 00:33:52,460
I think I've talked about how

00:33:50,299 --> 00:33:54,649
interaction is is a nice feature in the

00:33:52,460 --> 00:33:56,149
notebooks right and so widgets are kind

00:33:54,649 --> 00:33:57,649
of cool so we thought well if we have

00:33:56,149 --> 00:33:59,629
this data flow thing what would it look

00:33:57,649 --> 00:34:02,269
like what would be sort of ideally like

00:33:59,629 --> 00:34:04,039
it to look like for widgets so here we

00:34:02,269 --> 00:34:05,899
have a map pot lid plot showing some

00:34:04,039 --> 00:34:07,909
Boston housing data sort of the

00:34:05,899 --> 00:34:10,490
percentage of homes built before 1940

00:34:07,909 --> 00:34:13,429
and different tracts and so I can run

00:34:10,490 --> 00:34:16,940
that cell it uses stuff below it but

00:34:13,429 --> 00:34:19,879
what I'd like to add now is a widget if

00:34:16,940 --> 00:34:21,050
I can type quickly where I sort of set

00:34:19,879 --> 00:34:22,609
what the number of bins are for the

00:34:21,050 --> 00:34:24,560
histogram so I can explore the different

00:34:22,609 --> 00:34:26,329
bin widths for the histogram so I'll

00:34:24,560 --> 00:34:29,300
create an in slider have it range from

00:34:26,329 --> 00:34:31,280
zero to ten starting at five and now I

00:34:29,300 --> 00:34:36,050
can add that bins reference directly

00:34:31,280 --> 00:34:38,119
into the plot and rerun it but now if I

00:34:36,050 --> 00:34:39,819
click on this Auto refresh piece what's

00:34:38,119 --> 00:34:42,290
going to happen is as I move the widget

00:34:39,819 --> 00:34:43,639
right now it just updates those cells

00:34:42,290 --> 00:34:45,740
automatically and if there were more

00:34:43,639 --> 00:34:47,270
cells in between it would run everything

00:34:45,740 --> 00:34:48,919
that it needed to to get to that final

00:34:47,270 --> 00:34:52,280
output right assuming they were all

00:34:48,919 --> 00:34:53,569
refreshable cells so this sort of you

00:34:52,280 --> 00:34:55,550
know we changed it hacked a few things

00:34:53,569 --> 00:34:57,950
about I PI widgets in that we use a

00:34:55,550 --> 00:34:59,750
specific piece so that the output shows

00:34:57,950 --> 00:35:03,500
up as an output there's a mime bundle

00:34:59,750 --> 00:35:05,569
branch that uses that and then we also

00:35:03,500 --> 00:35:08,540
sort of took away the dot value piece

00:35:05,569 --> 00:35:09,530
and looked at just naming the variable

00:35:08,540 --> 00:35:11,060
as it is we assume when you're

00:35:09,530 --> 00:35:12,410
referencing a widget and it sort of says

00:35:11,060 --> 00:35:14,210
bins next to it you don't want to do

00:35:12,410 --> 00:35:16,400
bins dot value so we just added a quick

00:35:14,210 --> 00:35:18,109
hack to get it out there but we think

00:35:16,400 --> 00:35:21,170
this is sort of another nice use case

00:35:18,109 --> 00:35:23,930
for these interactive sides of using the

00:35:21,170 --> 00:35:25,609
dataflow all right so there are some

00:35:23,930 --> 00:35:26,569
known issues you're not surprised at

00:35:25,609 --> 00:35:28,040
this some of you were probably thinking

00:35:26,569 --> 00:35:31,040
about all the things that can go wrong

00:35:28,040 --> 00:35:32,600
in this case and you're right for some

00:35:31,040 --> 00:35:35,450
of them right if you mutate an output

00:35:32,600 --> 00:35:37,070
you do that at your own peril something

00:35:35,450 --> 00:35:38,660
that's sort of an object right we're

00:35:37,070 --> 00:35:40,610
modifying the internals of an object

00:35:38,660 --> 00:35:42,080
that was output from some other cell if

00:35:40,610 --> 00:35:43,880
you have nested references those can

00:35:42,080 --> 00:35:45,920
introduce issues there's also an

00:35:43,880 --> 00:35:47,630
interesting case by overriding the

00:35:45,920 --> 00:35:50,150
namespace if you're accessing the

00:35:47,630 --> 00:35:51,950
Global's directly the SC Python that can

00:35:50,150 --> 00:35:54,800
be problematic things like static class

00:35:51,950 --> 00:35:56,120
variable assignments and then things

00:35:54,800 --> 00:35:58,610
like multiple interfaces do the same

00:35:56,120 --> 00:36:01,280
kernel that I've seen a little bit

00:35:58,610 --> 00:36:02,780
demoed something we haven't even thought

00:36:01,280 --> 00:36:04,190
about but generally we're trying to

00:36:02,780 --> 00:36:06,740
connect the interface a little bit

00:36:04,190 --> 00:36:08,510
closer to what the kernel is and so

00:36:06,740 --> 00:36:11,360
we're probably not succeeding on any

00:36:08,510 --> 00:36:12,890
front there one thing we do have that we

00:36:11,360 --> 00:36:14,660
think would be useful is that you can

00:36:12,890 --> 00:36:16,370
convert your DF kernel notebook to a

00:36:14,660 --> 00:36:18,200
standard eye PI kernel notebook right so

00:36:16,370 --> 00:36:19,580
basically we can sort things in the

00:36:18,200 --> 00:36:24,860
right way so you get the run all

00:36:19,580 --> 00:36:26,120
top-down type of execution style so

00:36:24,860 --> 00:36:27,650
we're not the only people thinking about

00:36:26,120 --> 00:36:29,540
this there's cool related work that's

00:36:27,650 --> 00:36:32,240
going on something I just saw recently

00:36:29,540 --> 00:36:34,940
is reactive PI a kernel that does the

00:36:32,240 --> 00:36:36,320
same sort of reactive computation and

00:36:34,940 --> 00:36:37,940
it's just a kernel they don't have to

00:36:36,320 --> 00:36:41,030
modify the interface it runs in Jupiter

00:36:37,940 --> 00:36:42,710
lab pretty cool also notebook where you

00:36:41,030 --> 00:36:44,390
use a more sort of bigger restriction on

00:36:42,710 --> 00:36:46,400
the sell order defining the execution

00:36:44,390 --> 00:36:48,140
order there's some cool reactive

00:36:46,400 --> 00:36:50,810
notebooks in the JavaScript world from

00:36:48,140 --> 00:36:52,280
observable JetBrains has this data lore

00:36:50,810 --> 00:36:54,590
tool that kind of works looks at

00:36:52,280 --> 00:36:58,010
incremental computation as well and then

00:36:54,590 --> 00:36:59,210
Mathematica which is you know always

00:36:58,010 --> 00:37:02,120
been associated with sort of the same

00:36:59,210 --> 00:37:03,710
notebook idea has this dynamic command

00:37:02,120 --> 00:37:06,770
that has similar sort of reactive

00:37:03,710 --> 00:37:08,840
functionality I'd like to acknowledge

00:37:06,770 --> 00:37:11,420
the people who worked on this Colin

00:37:08,840 --> 00:37:13,070
brown Henry knew know they spent lots of

00:37:11,420 --> 00:37:16,100
their summer coding away trying to make

00:37:13,070 --> 00:37:18,080
this stuff work J was involved in an

00:37:16,100 --> 00:37:20,390
earlier version of this and the Jupiter

00:37:18,080 --> 00:37:22,490
and ipython development teams the way

00:37:20,390 --> 00:37:24,410
they sort of allow these extensions to

00:37:22,490 --> 00:37:26,630
be built and the extensibility that's in

00:37:24,410 --> 00:37:28,550
their products is really useful in order

00:37:26,630 --> 00:37:31,370
to try out some of this stuff right so

00:37:28,550 --> 00:37:33,500
it speaks to the documentation the

00:37:31,370 --> 00:37:35,780
structure of the code that we can do

00:37:33,500 --> 00:37:38,270
these sorts of things this was supported

00:37:35,780 --> 00:37:39,860
by the State Street Foundation and the

00:37:38,270 --> 00:37:42,740
photos used in the presentation are

00:37:39,860 --> 00:37:45,230
attributed there's a website dataflow

00:37:42,740 --> 00:37:46,490
Mbita github do we've been trying to

00:37:45,230 --> 00:37:48,500
push out a beta version it

00:37:46,490 --> 00:37:53,030
we'll be there soon if it's not there

00:37:48,500 --> 00:37:56,660
right now and you can try this out then

00:37:53,030 --> 00:37:57,950
from that one safe and that is what I

00:37:56,660 --> 00:38:22,100
have I'd be happy to take a couple

00:37:57,950 --> 00:38:25,100
questions if there's time yeah so it

00:38:22,100 --> 00:38:27,800
causes a duplicate name error so it

00:38:25,100 --> 00:38:29,450
won't let you do it basically so if I

00:38:27,800 --> 00:38:34,850
were to do something like try to define

00:38:29,450 --> 00:38:38,030
make plots equals whoops make plots

00:38:34,850 --> 00:38:40,130
equals three

00:38:38,030 --> 00:38:41,360
I'll get this duplicate name or letting

00:38:40,130 --> 00:38:44,290
me know that it's already been defined

00:38:41,360 --> 00:38:44,290
in another cell yep

00:38:53,720 --> 00:38:58,920
right so probably things that are

00:38:57,300 --> 00:39:00,810
already very functional in their design

00:38:58,920 --> 00:39:03,300
would would sort of carry over in the

00:39:00,810 --> 00:39:05,730
kernel space I don't know how all the

00:39:03,300 --> 00:39:08,220
hooks sort of would carry over but I

00:39:05,730 --> 00:39:11,099
imagine there are ways to do it with

00:39:08,220 --> 00:39:12,840
Jupiter lab there's some SATA and some

00:39:11,099 --> 00:39:15,450
nice sessions on how to build extensions

00:39:12,840 --> 00:39:17,099
I think the idea we would look at would

00:39:15,450 --> 00:39:18,930
be taking sort of the original notebook

00:39:17,099 --> 00:39:20,970
again and sort of modifying that and

00:39:18,930 --> 00:39:22,859
building it as sort of a second version

00:39:20,970 --> 00:39:23,790
of the notebook as an extension if

00:39:22,859 --> 00:39:25,890
that's possible

00:39:23,790 --> 00:39:27,150
but it looks like that extensibility

00:39:25,890 --> 00:39:28,800
supported so I think that would be the

00:39:27,150 --> 00:39:47,460
direction we go in for Jupiter lab we're

00:39:28,800 --> 00:39:49,590
thinking about that yes so the second

00:39:47,460 --> 00:39:50,820
one no we know that since you have a

00:39:49,590 --> 00:39:52,320
data flow graph this would be something

00:39:50,820 --> 00:39:54,390
to look at we haven't thought about it

00:39:52,320 --> 00:39:57,060
at all for the first piece the static

00:39:54,390 --> 00:39:58,859
analysis so that reactive PI project I

00:39:57,060 --> 00:40:00,390
think use a sim table to try to do a

00:39:58,859 --> 00:40:03,480
static analysis to figure that out

00:40:00,390 --> 00:40:07,140
that's something we weren't aware of one

00:40:03,480 --> 00:40:09,000
thing I think that by doing it in the

00:40:07,140 --> 00:40:10,440
dynamic analysis we can do things like

00:40:09,000 --> 00:40:12,900
split a dictionary and things like that

00:40:10,440 --> 00:40:15,810
that may be kind of useful but you can

00:40:12,900 --> 00:40:20,130
probably do some nice tasks using static

00:40:15,810 --> 00:40:22,260
analysis as well how are we doing it

00:40:20,130 --> 00:40:26,180
okay maybe one more question and then we

00:40:22,260 --> 00:40:26,180
have to wrap it up I don't know who sure

00:40:30,090 --> 00:40:36,810
so cyclic cycle yes we try to detect

00:40:33,840 --> 00:40:40,410
those cycles yes and and generate a

00:40:36,810 --> 00:40:41,490
cyclic some sort of cyclic exception all

00:40:40,410 --> 00:40:47,870
right thank you very much

00:40:41,490 --> 00:40:47,870

YouTube URL: https://www.youtube.com/watch?v=xUZGP2dGRKQ


