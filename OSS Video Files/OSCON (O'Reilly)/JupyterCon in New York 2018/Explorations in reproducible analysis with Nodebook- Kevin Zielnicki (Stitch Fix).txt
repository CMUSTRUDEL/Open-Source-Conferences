Title: Explorations in reproducible analysis with Nodebook- Kevin Zielnicki (Stitch Fix)
Publication date: 2018-09-21
Playlist: JupyterCon in New York 2018
Description: 
	Tools like the Jupyter Notebook provide an excellent platform for quickly iterating on an analysis by interleaving code, text, and output. However, the flexibility of the notebook environment can also lend itself to code that, over the course of an analysis, becomes increasingly unwieldy and difficult to rerun or meaningfully build upon.

While the notebook model allows users to develop code and share results quickly, the prioritization of quick exploration can make the analyses difficult to reproduce. This is typically fixed in a final “clean-up” phase where a notebook is pared down and rerun to make sure it is logically consistent. However, this takes extra effort, and many analysis artifacts will never reach this state. To help address this problem before it happens, we can build tools to make reproducible analysis the most natural option.

As a step toward encouraging reproducibility, Kevin Zielnicki offers an overview of Nodebook, an extension to the Jupyter Notebook that imposes constraints on the notebook model in exchange for greater consistency while keeping the exploratory interactivity that makes the notebook model so useful. Nodebook does this by maintaining a chain of cell execution in logical rather than temporal order. This contrasts with the standard notebook model, in which cells affect the global notebook state in order of execution independently of their logical position in the notebook. By enforcing logical consistency with each cell execution, reproducibility is no longer delayed to a final clean-up but rather maintained throughout the analysis.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:02,240 --> 00:00:07,550
thanks to the introduction Jeffrey yeah

00:00:05,180 --> 00:00:09,530
so I'm gonna talk about a notebook which

00:00:07,550 --> 00:00:12,679
is a plugin that I've worked on for

00:00:09,530 --> 00:00:15,559
Jupiter and if you've been in the last

00:00:12,679 --> 00:00:17,630
couple talks in this session they set

00:00:15,559 --> 00:00:21,970
this up pretty well and that we're all

00:00:17,630 --> 00:00:24,170
kind of thinking about this kind of

00:00:21,970 --> 00:00:27,429
reproducibility problem that comes from

00:00:24,170 --> 00:00:30,470
the mutability of state in notebooks so

00:00:27,429 --> 00:00:34,010
yeah so as every mentioned I'm a data

00:00:30,470 --> 00:00:36,500
scientist at Citrix and I spend a lot of

00:00:34,010 --> 00:00:41,420
my time doing exploratory data analysis

00:00:36,500 --> 00:00:45,440
in notebooks and this kind of came out

00:00:41,420 --> 00:00:48,170
of sort of a I would have thought about

00:00:45,440 --> 00:00:51,920
if if notebooks worked differently from

00:00:48,170 --> 00:00:55,460
how they did how how could I make the

00:00:51,920 --> 00:00:57,920
the way that notebooks evaluate kind of

00:00:55,460 --> 00:01:00,470
better match better match my

00:00:57,920 --> 00:01:03,560
expectations for exploratory data

00:01:00,470 --> 00:01:06,170
analysis well kind of encouraging me to

00:01:03,560 --> 00:01:12,289
have better habits of keeping things in

00:01:06,170 --> 00:01:13,939
order so yeah thanks to Joel and David

00:01:12,289 --> 00:01:16,399
for the the set up if you were in those

00:01:13,939 --> 00:01:20,149
talks they gave a very good introduction

00:01:16,399 --> 00:01:23,149
to why this is a problem why you should

00:01:20,149 --> 00:01:25,789
care about it and some ways that to

00:01:23,149 --> 00:01:27,020
think about addressing it and so I'm

00:01:25,789 --> 00:01:31,159
going to kind of continue in that vein

00:01:27,020 --> 00:01:32,689
and I'm thankful for them for setting

00:01:31,159 --> 00:01:35,569
that up I'll spend a little bit less

00:01:32,689 --> 00:01:38,929
time on the motivation but kind of recap

00:01:35,569 --> 00:01:41,119
that a little bit if you didn't weren't

00:01:38,929 --> 00:01:43,039
in either of those two talks so I'll

00:01:41,119 --> 00:01:45,979
talk a little bit about the motivation

00:01:43,039 --> 00:01:48,560
for this I'll spend a lot of time kind

00:01:45,979 --> 00:01:52,819
of going through the features exactly

00:01:48,560 --> 00:01:56,299
how how its implemented and spend some

00:01:52,819 --> 00:02:00,130
time in demo and talk a little bit about

00:01:56,299 --> 00:02:00,130
possible future directions for this

00:02:00,280 --> 00:02:06,139
actually I'm gonna go do this in a

00:02:02,569 --> 00:02:08,959
notebook so I've heard on good authority

00:02:06,139 --> 00:02:13,220
that emoji compute is the future of

00:02:08,959 --> 00:02:16,099
Jupiter notebooks so so this this is

00:02:13,220 --> 00:02:19,819
kind of recapping what this issue is in

00:02:16,099 --> 00:02:23,079
in a small forms if I set assign some

00:02:19,819 --> 00:02:25,870
value to a variable do some computation

00:02:23,079 --> 00:02:28,730
and then you know mutate that variable

00:02:25,870 --> 00:02:31,370
and I have some different value here if

00:02:28,730 --> 00:02:33,469
I was to go up here and rerun this then

00:02:31,370 --> 00:02:36,650
I have something that's inconsistent

00:02:33,469 --> 00:02:38,930
with like the linear apparent state of

00:02:36,650 --> 00:02:41,090
the ordering of these cells and even

00:02:38,930 --> 00:02:44,239
worse if like I've run this another

00:02:41,090 --> 00:02:52,879
couple times then I'm gonna be even

00:02:44,239 --> 00:02:54,980
sadder so that this is just another kind

00:02:52,879 --> 00:02:58,909
of the same the same exact thing but

00:02:54,980 --> 00:03:01,849
with an array so it's less fun basically

00:02:58,909 --> 00:03:04,250
yeah showing the same thing there so so

00:03:01,849 --> 00:03:05,840
that there's a I think a reproducibility

00:03:04,250 --> 00:03:07,099
gap in the notebook model and I think

00:03:05,840 --> 00:03:08,180
this is something that like a lot of

00:03:07,099 --> 00:03:09,590
people are thinking about from a lot of

00:03:08,180 --> 00:03:14,079
different directions and this is just

00:03:09,590 --> 00:03:17,750
like one small piece of this where I'm

00:03:14,079 --> 00:03:21,530
particularly thinking about this issue

00:03:17,750 --> 00:03:23,659
of how every cell modifies the global

00:03:21,530 --> 00:03:27,799
state and how that leads to kind of

00:03:23,659 --> 00:03:29,959
dangerous situations in the books so so

00:03:27,799 --> 00:03:31,729
so on one hand we have this this ability

00:03:29,959 --> 00:03:33,229
for every cell so to modify the global

00:03:31,729 --> 00:03:35,030
state no matter where it exists in the

00:03:33,229 --> 00:03:38,060
notebook and this is kind of great for

00:03:35,030 --> 00:03:40,370
like being able to move around and and

00:03:38,060 --> 00:03:43,069
play around with with data like with a

00:03:40,370 --> 00:03:47,299
very low barrier to entry for for

00:03:43,069 --> 00:03:50,000
exploring things but but it kind of has

00:03:47,299 --> 00:03:52,819
this intrinsic inconsistency which is

00:03:50,000 --> 00:03:55,099
that the presentation of cells is linear

00:03:52,819 --> 00:03:57,650
or it linearly ordered but the execution

00:03:55,099 --> 00:03:59,870
of cells is not necessarily lineal

00:03:57,650 --> 00:04:03,109
linearly ordered so you can easily

00:03:59,870 --> 00:04:05,509
modify the history of your notebook in

00:04:03,109 --> 00:04:07,310
the sense that you're modifying what

00:04:05,509 --> 00:04:10,459
looks like is something that happened

00:04:07,310 --> 00:04:12,500
earlier on the notebook and then end up

00:04:10,459 --> 00:04:14,269
in a situation where the execution order

00:04:12,500 --> 00:04:20,150
and the presentation order don't match

00:04:14,269 --> 00:04:22,580
so there's the there's a few possible

00:04:20,150 --> 00:04:25,639
solutions of this kind of that are

00:04:22,580 --> 00:04:28,040
already common practice one is to have a

00:04:25,639 --> 00:04:31,370
pendulum these cells so

00:04:28,040 --> 00:04:33,500
this is how console ipython works and

00:04:31,370 --> 00:04:36,130
here you get consistent history for free

00:04:33,500 --> 00:04:40,850
I think you sacrificed some flexibility

00:04:36,130 --> 00:04:44,990
you can can no longer kind of go back

00:04:40,850 --> 00:04:49,070
and and edit history you also can't kind

00:04:44,990 --> 00:04:52,460
of inspect history as well so I think

00:04:49,070 --> 00:04:54,680
that that that's it that's nice for the

00:04:52,460 --> 00:04:57,320
consistency property but I do think you

00:04:54,680 --> 00:05:00,440
lose something by going into the kind of

00:04:57,320 --> 00:05:02,120
append-only regime and the other kind of

00:05:00,440 --> 00:05:04,300
de-facto standard approach for notebooks

00:05:02,120 --> 00:05:07,250
is if you want something that's

00:05:04,300 --> 00:05:09,830
reproducible then you just restart the

00:05:07,250 --> 00:05:11,270
kernel and rerun all the cell's and you

00:05:09,830 --> 00:05:13,490
know that works but that's kind of a

00:05:11,270 --> 00:05:15,920
painful workflow right if you're in the

00:05:13,490 --> 00:05:17,720
middle of some exploratory analysis you

00:05:15,920 --> 00:05:19,880
don't want to take the time to restart

00:05:17,720 --> 00:05:22,460
the kernel rerun all of your cells and

00:05:19,880 --> 00:05:24,530
like you'll often or at least I'll often

00:05:22,460 --> 00:05:26,420
end up with a notebook that I'm like

00:05:24,530 --> 00:05:28,250
okay maybe I'll do that later but I'm

00:05:26,420 --> 00:05:30,080
not gonna do it right now and then I

00:05:28,250 --> 00:05:31,520
come back to it a month later and I have

00:05:30,080 --> 00:05:35,440
this thing that I have no idea how it

00:05:31,520 --> 00:05:39,320
got to be in the state that it is in so

00:05:35,440 --> 00:05:43,970
another approach is what I'm gonna talk

00:05:39,320 --> 00:05:47,300
about here with a notebook so so what

00:05:43,970 --> 00:05:50,080
does notebook sorry to any node J s

00:05:47,300 --> 00:05:52,730
users this is notice in the graph node

00:05:50,080 --> 00:05:54,890
terms a little bit overloaded I I made I

00:05:52,730 --> 00:05:57,410
made a temporary working name for this

00:05:54,890 --> 00:05:59,600
and then kind of just just left it so

00:05:57,410 --> 00:06:02,090
that's how it got its name

00:05:59,600 --> 00:06:04,700
it's Python only so it plugs in fairly

00:06:02,090 --> 00:06:05,900
deep with with Python there's no reason

00:06:04,700 --> 00:06:07,910
why you couldn't kind of implement these

00:06:05,900 --> 00:06:11,270
principles with another language

00:06:07,910 --> 00:06:13,970
but that's not what I did here and the

00:06:11,270 --> 00:06:16,400
main thing that it is is it's it's an

00:06:13,970 --> 00:06:20,780
execution framework with a strict point

00:06:16,400 --> 00:06:24,710
of view on linear cell ordering so that

00:06:20,780 --> 00:06:27,680
the execution of of cells matches their

00:06:24,710 --> 00:06:30,380
linear presentation order and this kind

00:06:27,680 --> 00:06:32,720
of and I'll talk in detail about how

00:06:30,380 --> 00:06:33,830
this is implemented but first kind of to

00:06:32,720 --> 00:06:36,520
give an overview of some of the

00:06:33,830 --> 00:06:39,350
properties that you get out of this is

00:06:36,520 --> 00:06:40,510
you can get you can get dependency

00:06:39,350 --> 00:06:44,360
tracking

00:06:40,510 --> 00:06:47,530
so in in notebook each cell tracks its

00:06:44,360 --> 00:06:51,130
inputs and its outputs and so you can

00:06:47,530 --> 00:06:54,320
track the dependencies between cells

00:06:51,130 --> 00:06:58,880
there's it includes a mutable execution

00:06:54,320 --> 00:07:01,370
so cells are executing in a sandboxed

00:06:58,880 --> 00:07:03,800
local scope and not modifying the global

00:07:01,370 --> 00:07:06,770
environment so each time you rerun a

00:07:03,800 --> 00:07:10,040
cell it's going to be running in the

00:07:06,770 --> 00:07:13,340
same environment as it as it was around

00:07:10,040 --> 00:07:17,030
on a previous execution you can get

00:07:13,340 --> 00:07:20,270
cascading invalidation so this is this

00:07:17,030 --> 00:07:23,420
is similar to what was just presented in

00:07:20,270 --> 00:07:27,590
the the data float kernel tuck where if

00:07:23,420 --> 00:07:29,150
a cell output changes on rerun then we

00:07:27,590 --> 00:07:32,120
can track and invalidate cells that

00:07:29,150 --> 00:07:34,730
depend on that output and then another

00:07:32,120 --> 00:07:36,860
thing that you can get is accessible

00:07:34,730 --> 00:07:39,800
intermediates so if you add a new cell

00:07:36,860 --> 00:07:42,860
the inputs for that cell come from the

00:07:39,800 --> 00:07:45,710
position in presentation order so you

00:07:42,860 --> 00:07:51,170
can inspect values as they kind of

00:07:45,710 --> 00:07:54,410
existed in in linear history so without

00:07:51,170 --> 00:07:56,810
I'm gonna do a quick demo which will

00:07:54,410 --> 00:08:02,090
hopefully work so this is the same the

00:07:56,810 --> 00:08:04,130
same example with emoji compute and so

00:08:02,090 --> 00:08:07,130
here I've done the same thing I've run

00:08:04,130 --> 00:08:10,610
all these cells but now this value of x

00:08:07,130 --> 00:08:13,490
is the the value of x in linear history

00:08:10,610 --> 00:08:16,700
here if I go up to this previous cell

00:08:13,490 --> 00:08:21,230
and rerun that it's going to depend on

00:08:16,700 --> 00:08:22,550
what X was set initially if I run this

00:08:21,230 --> 00:08:24,770
multiple times that's not going to

00:08:22,550 --> 00:08:29,470
affect any of the outputs so you have

00:08:24,770 --> 00:08:34,910
consistent history here and if I was to

00:08:29,470 --> 00:08:40,880
to change something here let's say you

00:08:34,910 --> 00:08:44,450
can't do the emoji keyboard yeah so

00:08:40,880 --> 00:08:47,300
let's let's let's change that it's going

00:08:44,450 --> 00:08:48,980
to invalidate all the cells that depend

00:08:47,300 --> 00:08:51,440
on that so here pay attention to these

00:08:48,980 --> 00:08:53,570
X's that were marked on the input cells

00:08:51,440 --> 00:08:56,899
here that's why I'm indicating the

00:08:53,570 --> 00:09:00,079
invalidation I think it would be nice to

00:08:56,899 --> 00:09:03,410
have like some additional GUI work on on

00:09:00,079 --> 00:09:07,550
this but you can see it's tracking the

00:09:03,410 --> 00:09:11,389
the the state there and if I'm if I want

00:09:07,550 --> 00:09:14,750
to rerun something down here it will get

00:09:11,389 --> 00:09:16,579
the the previous will rerun the previous

00:09:14,750 --> 00:09:18,800
cells as needed so it doesn't have to

00:09:16,579 --> 00:09:20,389
rerun that second cell there because it

00:09:18,800 --> 00:09:26,720
wasn't modified anything about the state

00:09:20,389 --> 00:09:30,259
of X but it need to to rerun that third

00:09:26,720 --> 00:09:31,940
cell there and so I also need to rerun

00:09:30,259 --> 00:09:36,110
the cell like I can as well and it will

00:09:31,940 --> 00:09:38,600
depend on that's its position there same

00:09:36,110 --> 00:09:43,490
thing with like the the Ray example that

00:09:38,600 --> 00:09:48,350
I showed on the other slide where I can

00:09:43,490 --> 00:09:52,009
do something like that and track its

00:09:48,350 --> 00:09:57,560
position there I can do I can do more

00:09:52,009 --> 00:10:02,149
things too if we want to do like if you

00:09:57,560 --> 00:10:08,810
want to do something like add in another

00:10:02,149 --> 00:10:11,930
dependency so now now we have something

00:10:08,810 --> 00:10:13,100
where the state of this list depends

00:10:11,930 --> 00:10:17,360
here

00:10:13,100 --> 00:10:24,680
this on the the previous value of x and

00:10:17,360 --> 00:10:27,139
y as well if I change I change that then

00:10:24,680 --> 00:10:30,709
we can see the the changes propagate

00:10:27,139 --> 00:10:32,389
there as well okay so that's kind of a

00:10:30,709 --> 00:10:34,490
toy example I'll do like a little bit

00:10:32,389 --> 00:10:38,420
more of a data analysis example later

00:10:34,490 --> 00:10:42,620
but at this point I kind of walk walk

00:10:38,420 --> 00:10:44,269
through how all this is implemented so I

00:10:42,620 --> 00:10:46,910
talked about kind of four features and

00:10:44,269 --> 00:10:49,010
I'm gonna walk through where those all

00:10:46,910 --> 00:10:52,040
come from so the first thing I mentioned

00:10:49,010 --> 00:10:54,500
was this dependency tracking property so

00:10:52,040 --> 00:10:57,019
so each cell is tracking its inputs in

00:10:54,500 --> 00:11:00,439
its outputs the way that that happens in

00:10:57,019 --> 00:11:04,100
notebook is that I parse the ast to

00:11:00,439 --> 00:11:06,590
determine what the cell inputs are so so

00:11:04,100 --> 00:11:08,180
anytime that that

00:11:06,590 --> 00:11:10,990
I thought I read from the SD that the

00:11:08,180 --> 00:11:15,380
cell is loading some value then I

00:11:10,990 --> 00:11:18,260
tracked that as an input and any object

00:11:15,380 --> 00:11:22,040
that is modified in the cell I'm

00:11:18,260 --> 00:11:25,280
interpreting as an output so for example

00:11:22,040 --> 00:11:27,830
in this in this array example the first

00:11:25,280 --> 00:11:30,260
cell is storing something into X so I'm

00:11:27,830 --> 00:11:33,410
tracking that as an output the second

00:11:30,260 --> 00:11:36,370
cell loads something from X as an input

00:11:33,410 --> 00:11:40,150
there'd sell both loads and modifies X

00:11:36,370 --> 00:11:45,350
and the fourth cell loads X as an input

00:11:40,150 --> 00:11:46,880
so from that I can match those those

00:11:45,350 --> 00:11:51,770
dependencies to the cells that they came

00:11:46,880 --> 00:11:55,580
from okay so the ii and closely related

00:11:51,770 --> 00:11:58,190
property here is a mutable execution so

00:11:55,580 --> 00:12:01,310
so I mentioned for this that cells are

00:11:58,190 --> 00:12:04,010
executing in a sandbox local environment

00:12:01,310 --> 00:12:09,130
and this is kind of like where the meat

00:12:04,010 --> 00:12:14,540
of of notebook really is is that I'm I'm

00:12:09,130 --> 00:12:16,130
serializing any modified objects so so

00:12:14,540 --> 00:12:17,570
really there's serialization is

00:12:16,130 --> 00:12:19,490
happening at each step in this process

00:12:17,570 --> 00:12:21,260
serialization and deserialization -

00:12:19,490 --> 00:12:24,260
between cells and that's how I'm

00:12:21,260 --> 00:12:27,230
guaranteeing this amitabh environment so

00:12:24,260 --> 00:12:30,740
when a cell is executed I know from the

00:12:27,230 --> 00:12:33,170
dependency graph that like what what its

00:12:30,740 --> 00:12:37,040
inputs are so I can load and deserialize

00:12:33,170 --> 00:12:40,250
those and then any things that are

00:12:37,040 --> 00:12:43,970
modified from their initial value I can

00:12:40,250 --> 00:12:45,950
serialize and stories' outputs and then

00:12:43,970 --> 00:12:49,790
I can have consistent execution

00:12:45,950 --> 00:12:52,700
regardless of when the cell runs by just

00:12:49,790 --> 00:12:57,620
being able to match up the inputs to the

00:12:52,700 --> 00:12:59,450
appropriate outputs so I'm gonna kind of

00:12:57,620 --> 00:13:02,620
walk through that kind of in more detail

00:12:59,450 --> 00:13:06,200
because I think it's important so

00:13:02,620 --> 00:13:10,370
exactly how that happens for cell cell

00:13:06,200 --> 00:13:13,400
one here is okay first of all I can tell

00:13:10,370 --> 00:13:15,770
from the ASD that there's no that

00:13:13,400 --> 00:13:17,930
there's no inputs to this cell it's not

00:13:15,770 --> 00:13:20,410
loading anything so I'm gonna execute it

00:13:17,930 --> 00:13:24,810
in an empty and

00:13:20,410 --> 00:13:28,440
then I can tell that X is modified so

00:13:24,810 --> 00:13:31,390
this this I'm able to tell because I'm

00:13:28,440 --> 00:13:34,750
serializing the environment pre and post

00:13:31,390 --> 00:13:38,820
cell execution and so I can tell that

00:13:34,750 --> 00:13:41,829
the value stored in X after execution

00:13:38,820 --> 00:13:43,720
doesn't match what was in X before

00:13:41,829 --> 00:13:46,589
execution in this case trivially so

00:13:43,720 --> 00:13:49,930
because X didn't exist before execution

00:13:46,589 --> 00:13:52,570
so I know X is modified so I'm

00:13:49,930 --> 00:13:56,260
serializing X I compute the hash of the

00:13:52,570 --> 00:14:00,610
serialized value of x and then I store

00:13:56,260 --> 00:14:04,420
alongside this cell a map from X to the

00:14:00,610 --> 00:14:08,649
to the hash value of the the serialized

00:14:04,420 --> 00:14:11,350
version of X in that cell node ones that

00:14:08,649 --> 00:14:14,490
I know what object to look up if I need

00:14:11,350 --> 00:14:18,490
to access that access that input later

00:14:14,490 --> 00:14:21,550
and then finally in the in the kind of

00:14:18,490 --> 00:14:25,949
global notebook data store I'm going to

00:14:21,550 --> 00:14:29,050
map that hash to the serialized value

00:14:25,949 --> 00:14:31,630
and this can this can exist either in

00:14:29,050 --> 00:14:34,449
memory or on disk there's a an option

00:14:31,630 --> 00:14:39,610
when you initialize the notebook to have

00:14:34,449 --> 00:14:41,769
either this B in memory and kind of more

00:14:39,610 --> 00:14:43,990
ephemeral or on disk and there's you

00:14:41,769 --> 00:14:49,060
know all the trade-offs you would think

00:14:43,990 --> 00:14:50,890
of for those but I the the key thing is

00:14:49,060 --> 00:14:52,540
that there's this this notebook data

00:14:50,890 --> 00:14:55,930
stored that now anything that needs to

00:14:52,540 --> 00:15:00,130
look up this value at a later point can

00:14:55,930 --> 00:15:04,630
come and can pick that up from okay so

00:15:00,130 --> 00:15:09,040
then for the next so this this cell has

00:15:04,630 --> 00:15:12,070
an input of X and I can so I'm enforcing

00:15:09,040 --> 00:15:14,529
linear cell execution so that import of

00:15:12,070 --> 00:15:16,660
X has to come from the most recent

00:15:14,529 --> 00:15:17,920
previous cell that had an output of X in

00:15:16,660 --> 00:15:21,220
this case there's only one the

00:15:17,920 --> 00:15:23,230
immediately previous cell and I can just

00:15:21,220 --> 00:15:27,100
trivially match that up as the the cell

00:15:23,230 --> 00:15:29,649
that modified X and that we will use as

00:15:27,100 --> 00:15:31,050
the input for this cell so I look up the

00:15:29,649 --> 00:15:34,500
hash of

00:15:31,050 --> 00:15:38,430
that that value for X from the cell node

00:15:34,500 --> 00:15:40,830
one map and then deserialize X from the

00:15:38,430 --> 00:15:42,810
notebook data store and now I can

00:15:40,830 --> 00:15:46,680
execute the cell in this environment

00:15:42,810 --> 00:15:49,230
with with the appropriate value of X and

00:15:46,680 --> 00:15:52,110
in this case from my pre and post

00:15:49,230 --> 00:15:53,910
execution serialization I know that X is

00:15:52,110 --> 00:15:58,050
not modified so this cell doesn't have

00:15:53,910 --> 00:16:00,000
any outputs okay and then moving on to

00:15:58,050 --> 00:16:03,270
the third cell here now we have one

00:16:00,000 --> 00:16:05,670
that's both taking an input and storing

00:16:03,270 --> 00:16:07,680
an output so similarly I match this up

00:16:05,670 --> 00:16:10,100
to the output of cell one look up the

00:16:07,680 --> 00:16:12,000
the hash from cell 1 deserialize it

00:16:10,100 --> 00:16:14,940
executes in that environment with that

00:16:12,000 --> 00:16:18,240
deserialized value of X and now I can

00:16:14,940 --> 00:16:21,630
tell that when I serialize ex-post

00:16:18,240 --> 00:16:25,200
execution the the hash now no longer

00:16:21,630 --> 00:16:28,110
matches what it was previously so I can

00:16:25,200 --> 00:16:33,210
interpret that X has been modified so

00:16:28,110 --> 00:16:37,260
that then triggers X to be stored as as

00:16:33,210 --> 00:16:39,360
an output for cell 3 in the cell note 3

00:16:37,260 --> 00:16:43,410
map mapping that to the hash of the new

00:16:39,360 --> 00:16:46,170
value and that will be be stored in the

00:16:43,410 --> 00:16:47,880
the notebook data store as well a side

00:16:46,170 --> 00:16:49,290
note here I also keep track of the

00:16:47,880 --> 00:16:50,790
number of references to all of these

00:16:49,290 --> 00:16:53,190
objects so that I can clean them up as

00:16:50,790 --> 00:16:56,820
needed kind of in a standard reference

00:16:53,190 --> 00:16:59,970
tracking garbage collection way okay

00:16:56,820 --> 00:17:02,310
finally cell 4 here with reloading X

00:16:59,970 --> 00:17:04,860
again now the immediately previous cell

00:17:02,310 --> 00:17:06,660
in linear order that modified X is cell

00:17:04,860 --> 00:17:09,000
3 so I'm gonna look up the hash from

00:17:06,660 --> 00:17:11,280
that cells map and deserialize the

00:17:09,000 --> 00:17:14,160
appropriate cell from the the value from

00:17:11,280 --> 00:17:17,730
the data store and execute in that

00:17:14,160 --> 00:17:21,570
environment and now X is not modified so

00:17:17,730 --> 00:17:23,610
no uploads there ok so that's that's the

00:17:21,570 --> 00:17:28,440
way that execution works hopefully that

00:17:23,610 --> 00:17:31,920
was clear so moving on then to the the

00:17:28,440 --> 00:17:35,190
cascading invalidation so so as I

00:17:31,920 --> 00:17:37,950
mentioned cells can track their their

00:17:35,190 --> 00:17:41,460
validity so a cell is considered valid

00:17:37,950 --> 00:17:44,220
if its inputs have been unchanged since

00:17:41,460 --> 00:17:46,200
the last execution

00:17:44,220 --> 00:17:50,190
and particularly if it's if its inputs

00:17:46,200 --> 00:17:54,090
are valid since last execution so if an

00:17:50,190 --> 00:17:56,789
input changes then what the the process

00:17:54,090 --> 00:17:58,590
that I will do is I'll mark any cell

00:17:56,789 --> 00:18:01,020
that depends on that is invalid so

00:17:58,590 --> 00:18:05,970
suppose that I changed cell one here so

00:18:01,020 --> 00:18:08,700
that now X has another element so I'm

00:18:05,970 --> 00:18:11,820
gonna mark that mark than anything that

00:18:08,700 --> 00:18:14,909
depended on what that cell previously

00:18:11,820 --> 00:18:17,059
outputted as invalid so since cell - and

00:18:14,909 --> 00:18:21,330
cell 3 here both linked up to cell 1

00:18:17,059 --> 00:18:24,950
then I mark those as invalid and then

00:18:21,330 --> 00:18:28,590
also this I mentioned is cascading so

00:18:24,950 --> 00:18:31,200
I'll look up anything that depends on

00:18:28,590 --> 00:18:34,620
those cells outputs in turn which also

00:18:31,200 --> 00:18:37,880
catches cell 4 and then I know that if I

00:18:34,620 --> 00:18:40,530
want to rerun cell for that I have to

00:18:37,880 --> 00:18:48,150
rerun up the chain until I get to a

00:18:40,530 --> 00:18:49,409
valid a valid output ok and then the the

00:18:48,150 --> 00:18:51,720
the last kind of property that I

00:18:49,409 --> 00:18:53,130
mentioned here is accessible

00:18:51,720 --> 00:18:57,570
intermediates and I think this is kind

00:18:53,130 --> 00:18:59,789
of a handy thing for for exploratory

00:18:57,570 --> 00:19:03,570
data analysis and inspecting kind of

00:18:59,789 --> 00:19:07,320
intermediate results so if I if I want

00:19:03,570 --> 00:19:09,870
to add a new cell and I want to look at

00:19:07,320 --> 00:19:12,780
like what what does what does something

00:19:09,870 --> 00:19:15,510
look like somewhere in this chain other

00:19:12,780 --> 00:19:18,539
than the end I can I can insert that

00:19:15,510 --> 00:19:20,460
cell in this linear order so suppose I

00:19:18,539 --> 00:19:23,340
have this new cell to calculate the max

00:19:20,460 --> 00:19:27,539
of X and I put it in here between cell 2

00:19:23,340 --> 00:19:29,280
and cell 3 then then you know we just

00:19:27,539 --> 00:19:31,140
stick it in there shift the other cells

00:19:29,280 --> 00:19:35,070
down and match up the inputs

00:19:31,140 --> 00:19:37,440
appropriately so so here we'll get the

00:19:35,070 --> 00:19:39,900
value of x from cell 1 as you would

00:19:37,440 --> 00:19:46,169
expect kind of from the the linear

00:19:39,900 --> 00:19:48,809
execution order okay so I'm gonna do

00:19:46,169 --> 00:19:54,149
another quick demo here this is kind of

00:19:48,809 --> 00:19:58,050
more more in the the data analysis kind

00:19:54,149 --> 00:20:01,350
of workflow so so this is also cribbing

00:19:58,050 --> 00:20:05,450
learn example this one we're going to

00:20:01,350 --> 00:20:08,790
load the wine data set which is a

00:20:05,450 --> 00:20:10,590
classification example for classifying

00:20:08,790 --> 00:20:14,880
different varieties of wine based on

00:20:10,590 --> 00:20:18,390
chemical properties and okay so what I'm

00:20:14,880 --> 00:20:20,040
gonna do here to trick you is I'm have

00:20:18,390 --> 00:20:24,960
this cell commented it out and it's

00:20:20,040 --> 00:20:27,980
going to be important later so okay so I

00:20:24,960 --> 00:20:31,170
build a train and test data set I

00:20:27,980 --> 00:20:33,930
initialize a classifier here which is

00:20:31,170 --> 00:20:36,240
going to just do do PCA and then

00:20:33,930 --> 00:20:40,890
logistic regression kind of a silly

00:20:36,240 --> 00:20:44,870
example but you'll it makes for decent

00:20:40,890 --> 00:20:49,100
visualization so then we will fit that

00:20:44,870 --> 00:20:52,830
example we'll do a prediction on it and

00:20:49,100 --> 00:20:56,630
we can plot the the PCA transformed

00:20:52,830 --> 00:20:58,740
values here so so you can see these

00:20:56,630 --> 00:21:00,930
there's different classes three

00:20:58,740 --> 00:21:04,200
different classes here and they're not

00:21:00,930 --> 00:21:07,440
super well stuff separated and if we

00:21:04,200 --> 00:21:10,440
look at the accuracy here it's it's it's

00:21:07,440 --> 00:21:12,900
not it's not that great so we might be

00:21:10,440 --> 00:21:15,750
curious then okay what's going on and if

00:21:12,900 --> 00:21:19,230
you look at the the features data frame

00:21:15,750 --> 00:21:20,970
here you can see that all of these all

00:21:19,230 --> 00:21:22,680
of these values kind of have wildly

00:21:20,970 --> 00:21:26,970
different scales which is going to mess

00:21:22,680 --> 00:21:28,680
up our PCA so so that's then when we

00:21:26,970 --> 00:21:30,480
come we can come back up to this this

00:21:28,680 --> 00:21:34,290
thing that I skipped earlier so if we

00:21:30,480 --> 00:21:39,140
uncomment that and and run that to

00:21:34,290 --> 00:21:41,670
modify so we've modified features here

00:21:39,140 --> 00:21:44,280
right and now things are on a

00:21:41,670 --> 00:21:47,130
standardized scale subtracting out the

00:21:44,280 --> 00:21:48,830
mean standard deviation and now this is

00:21:47,130 --> 00:21:52,680
invalidated a whole bunch of cells right

00:21:48,830 --> 00:21:55,170
and that that's what you can tell again

00:21:52,680 --> 00:21:58,560
pay attention to the axes there next to

00:21:55,170 --> 00:22:01,590
those cells so now if I if I wanted to

00:21:58,560 --> 00:22:05,070
have this cell that was invalidated I

00:22:01,590 --> 00:22:07,110
give me the up-to-date version it can

00:22:05,070 --> 00:22:09,869
rerun the cells as needed and

00:22:07,110 --> 00:22:12,960
our accuracies improved a lot I can do

00:22:09,869 --> 00:22:14,249
the same thing with this plot and you

00:22:12,960 --> 00:22:19,080
can see that the the data is a lot

00:22:14,249 --> 00:22:20,730
better separated here so yeah that kind

00:22:19,080 --> 00:22:24,950
of kind of puts it into it to a slightly

00:22:20,730 --> 00:22:24,950
more slightly more realistic workflow

00:22:25,850 --> 00:22:32,220
actually any questions about that before

00:22:28,169 --> 00:22:34,529
I kind of before I go on and anything

00:22:32,220 --> 00:22:40,039
about it like yeah I would have talked

00:22:34,529 --> 00:22:40,039
about so far yep

00:22:44,450 --> 00:22:52,440
sure yes so if I wanted to so let's

00:22:48,899 --> 00:22:56,399
maybe do something in in here so if I

00:22:52,440 --> 00:22:58,649
add something that has an output so like

00:22:56,399 --> 00:23:01,950
okay if I want to look at X here I can

00:22:58,649 --> 00:23:05,460
do that if I want to like print X and

00:23:01,950 --> 00:23:07,200
then you know set another output Z

00:23:05,460 --> 00:23:09,600
that's not going to invalidate anything

00:23:07,200 --> 00:23:12,149
because nothing depends on Z if I set an

00:23:09,600 --> 00:23:14,029
output for Y then that's going to

00:23:12,149 --> 00:23:17,940
invalidate anything that depended on Y

00:23:14,029 --> 00:23:21,029
so here it since this cell used the

00:23:17,940 --> 00:23:24,029
value of y its invalidated because this

00:23:21,029 --> 00:23:25,769
new cell set a new value of y so we can

00:23:24,029 --> 00:23:28,679
interpret that this will have to be

00:23:25,769 --> 00:23:34,519
rerun and so if we execute down here

00:23:28,679 --> 00:23:34,519
then we'll pull in that new value of y

00:23:35,809 --> 00:23:51,179
yes yep

00:23:46,559 --> 00:23:53,489
yeah yeah that's exactly it and I'll

00:23:51,179 --> 00:23:55,320
come to that again and at the end but

00:23:53,489 --> 00:23:57,239
yeah the I'll comment on the

00:23:55,320 --> 00:24:01,619
serialization briefly now which is like

00:23:57,239 --> 00:24:03,090
that's actually not as like it's not as

00:24:01,619 --> 00:24:05,279
slow as you might as you might think

00:24:03,090 --> 00:24:07,519
like as long as you're working on kind

00:24:05,279 --> 00:24:11,340
of reasonably small data like that

00:24:07,519 --> 00:24:12,899
serialization cost is not not not that

00:24:11,340 --> 00:24:16,619
high there's other drums downsides of

00:24:12,899 --> 00:24:19,259
serialization because there's some some

00:24:16,619 --> 00:24:20,400
things are not serializable there's

00:24:19,259 --> 00:24:22,590
there's

00:24:20,400 --> 00:24:25,170
third-party libraries like dill and

00:24:22,590 --> 00:24:27,930
cloud pickle that can serialize a much

00:24:25,170 --> 00:24:30,570
broader set of Python than them pickle

00:24:27,930 --> 00:24:32,960
itself can and it gets you that gets you

00:24:30,570 --> 00:24:35,220
like so pickle can't handle closures but

00:24:32,960 --> 00:24:39,290
called pickle and dill can handle

00:24:35,220 --> 00:24:41,460
closures find the the only thing that

00:24:39,290 --> 00:24:43,260
that I'm aware of that's like

00:24:41,460 --> 00:24:47,340
categorically not handled by any of

00:24:43,260 --> 00:24:49,680
these libraries is is a generators so

00:24:47,340 --> 00:24:51,570
that's one limitation if you want to if

00:24:49,680 --> 00:24:53,580
you want to define a generator you kind

00:24:51,570 --> 00:24:57,480
of have to use it within within a cell

00:24:53,580 --> 00:25:07,320
entirely and not not have it exist

00:24:57,480 --> 00:25:12,150
between cells anything else okay I'll go

00:25:07,320 --> 00:25:13,290
back to the sides so okay so now I'm

00:25:12,150 --> 00:25:15,390
just gonna kind of talk a little bit

00:25:13,290 --> 00:25:19,380
about you had some alternatives and in

00:25:15,390 --> 00:25:21,300
future work so so that if you were

00:25:19,380 --> 00:25:24,480
around for the previous talk the

00:25:21,300 --> 00:25:28,170
dataflow kernel kind of has some some

00:25:24,480 --> 00:25:30,030
very similar goals which it implements

00:25:28,170 --> 00:25:35,940
persistent cell IDs with dependency

00:25:30,030 --> 00:25:37,110
tracking and also has a lot of other

00:25:35,940 --> 00:25:39,900
features that I learned about in the

00:25:37,110 --> 00:25:41,040
previous talk as well so if you if you

00:25:39,900 --> 00:25:44,790
didn't see that one that was worth

00:25:41,040 --> 00:25:48,690
checking out the video there's also the

00:25:44,790 --> 00:25:51,360
reactive kernel project which they had a

00:25:48,690 --> 00:25:55,470
poster session the other day and this is

00:25:51,360 --> 00:25:57,330
kind of based around implementing a kind

00:25:55,470 --> 00:25:59,640
of reactive programming paradigm and

00:25:57,330 --> 00:26:03,900
Jupiter with similar motivations to this

00:25:59,640 --> 00:26:07,350
as well and the other other things as

00:26:03,900 --> 00:26:09,900
well that I'm sure I'm not aware of one

00:26:07,350 --> 00:26:13,950
difference of just this implementation

00:26:09,900 --> 00:26:16,920
is and partly because of kind of

00:26:13,950 --> 00:26:17,460
notebooks status as a like

00:26:16,920 --> 00:26:21,690
lighter-weight

00:26:17,460 --> 00:26:25,830
kind of side project almost is that it

00:26:21,690 --> 00:26:29,040
doesn't touch the ipython kernel so this

00:26:25,830 --> 00:26:31,909
this is this has an advantage of it's

00:26:29,040 --> 00:26:35,690
the development and installation is

00:26:31,909 --> 00:26:40,369
kind of a lot less involved than if you

00:26:35,690 --> 00:26:44,749
need to implement a new kernel and a new

00:26:40,369 --> 00:26:47,329
front end as well so it's it's it's

00:26:44,749 --> 00:26:51,139
implemented as basically as a as an i

00:26:47,329 --> 00:26:52,609
python magic so there's no extra there's

00:26:51,139 --> 00:26:55,749
no extra kernel and just hooking into

00:26:52,609 --> 00:26:58,459
the existing functionality around magics

00:26:55,749 --> 00:27:00,349
that has the disadvantage also in that

00:26:58,459 --> 00:27:06,169
like it can interact poorly with other

00:27:00,349 --> 00:27:08,059
cell magics and also kind of I'm doing

00:27:06,169 --> 00:27:10,219
things that are kind of breaking the the

00:27:08,059 --> 00:27:14,419
decoupling between the Cardinal and the

00:27:10,219 --> 00:27:16,429
UI and in the in the UI I'm have to do

00:27:14,419 --> 00:27:17,959
some some kind of ugly workarounds to

00:27:16,429 --> 00:27:20,409
make this work at all I have to do some

00:27:17,959 --> 00:27:23,690
some monkey patching on the code cell

00:27:20,409 --> 00:27:24,229
object and it's it's it's not pretty but

00:27:23,690 --> 00:27:29,599
it works

00:27:24,229 --> 00:27:31,969
uh-huh so that kind of leads into the

00:27:29,599 --> 00:27:36,679
some limitations and future directions

00:27:31,969 --> 00:27:39,309
that I'm interested in exploring so kind

00:27:36,679 --> 00:27:42,799
of three categories here serialization

00:27:39,309 --> 00:27:48,499
kernel and UI so I talked a little bit

00:27:42,799 --> 00:27:50,269
about serialization earlier and it's

00:27:48,499 --> 00:27:53,119
it's it's no small thing

00:27:50,269 --> 00:27:55,940
I'm serializing like vo the hole in the

00:27:53,119 --> 00:28:00,949
whole cell pre and post environment and

00:27:55,940 --> 00:28:04,190
that's expensive for large objects it's

00:28:00,949 --> 00:28:05,599
it's kind of fine as long as for

00:28:04,190 --> 00:28:09,679
anything under a couple hundred

00:28:05,599 --> 00:28:12,589
megabytes but once you work on larger

00:28:09,679 --> 00:28:15,679
any larger data than that it gets a

00:28:12,589 --> 00:28:18,649
little bit laggy and if you're working

00:28:15,679 --> 00:28:20,659
on you know is twelve gigabyte data sets

00:28:18,649 --> 00:28:25,039
or whatever you quickly either blow out

00:28:20,659 --> 00:28:27,069
your RAM or your disk space by by going

00:28:25,039 --> 00:28:33,679
back and forth serialize and everything

00:28:27,069 --> 00:28:35,869
kind of the the the the one one one

00:28:33,679 --> 00:28:39,679
other one way to kind of handle that is

00:28:35,869 --> 00:28:43,850
to treat this as something for a smaller

00:28:39,679 --> 00:28:46,340
scale sample exploration kind of

00:28:43,850 --> 00:28:49,910
I like to think of I like to think of it

00:28:46,340 --> 00:28:52,910
as an environment for doing quick

00:28:49,910 --> 00:28:55,490
iterative exploration on a small sub

00:28:52,910 --> 00:28:58,030
sample of data and then because I'm

00:28:55,490 --> 00:29:01,940
doing all of this tracking of cell

00:28:58,030 --> 00:29:05,120
dependencies you can actually pretty

00:29:01,940 --> 00:29:09,830
easily extract all of the all of the

00:29:05,120 --> 00:29:12,049
code that that modified some input to

00:29:09,830 --> 00:29:15,080
create to create whatever output you're

00:29:12,049 --> 00:29:16,570
interested in and so some pattern that

00:29:15,080 --> 00:29:20,480
I've kind of explored with that is

00:29:16,570 --> 00:29:23,870
shipping off that code to to a remote

00:29:20,480 --> 00:29:27,350
execution framework that can handle

00:29:23,870 --> 00:29:29,240
running that on the on a the full full

00:29:27,350 --> 00:29:31,039
data set that that I'm interested in I

00:29:29,240 --> 00:29:35,030
didn't include that with notebook itself

00:29:31,039 --> 00:29:38,179
because it kind of depends on more on

00:29:35,030 --> 00:29:41,710
our specific internal tooling so it's

00:29:38,179 --> 00:29:45,590
it's not necessarily like a general

00:29:41,710 --> 00:29:48,890
plugin but you can get that kind of kind

00:29:45,590 --> 00:29:51,110
of behavior as well okay I got a little

00:29:48,890 --> 00:29:52,760
bit sidetracked there so okay so the

00:29:51,110 --> 00:29:54,320
other disadvantage of serialization as I

00:29:52,760 --> 00:29:57,940
mentioned some objects aren't

00:29:54,320 --> 00:30:01,250
serializable most notably generators so

00:29:57,940 --> 00:30:06,130
this kind of implicitly restricts you to

00:30:01,250 --> 00:30:09,650
the subset of serializable Python also

00:30:06,130 --> 00:30:11,390
this this one is fixable I think but the

00:30:09,650 --> 00:30:14,030
way that I'm doing reference tracking as

00:30:11,390 --> 00:30:17,750
I described in the previous slides is by

00:30:14,030 --> 00:30:22,549
variable name only so the behavior is

00:30:17,750 --> 00:30:24,320
potentially unexpected if if you if you

00:30:22,549 --> 00:30:26,179
have multiple variable names that

00:30:24,320 --> 00:30:28,490
reference the same object and then you

00:30:26,179 --> 00:30:32,330
mutate one of them I'm only going to be

00:30:28,490 --> 00:30:34,130
tracking tracking one of those so you

00:30:32,330 --> 00:30:37,340
could you could do deeper reference

00:30:34,130 --> 00:30:39,110
tracking to mitigate that I think but I

00:30:37,340 --> 00:30:41,360
haven't really explored that it's kind

00:30:39,110 --> 00:30:43,250
of it's kind of an edge case because at

00:30:41,360 --> 00:30:46,250
least when I'm doing exploratory data

00:30:43,250 --> 00:30:47,980
analysis I've never really wanted to you

00:30:46,250 --> 00:30:52,040
know mutate objects with multiple

00:30:47,980 --> 00:30:55,760
variable handles anyway so that hasn't

00:30:52,040 --> 00:30:57,560
been kind of a major issue another thing

00:30:55,760 --> 00:31:00,170
that I'm kind of interested in

00:30:57,560 --> 00:31:02,030
around around making it so you don't

00:31:00,170 --> 00:31:05,780
have to necessarily do the serialization

00:31:02,030 --> 00:31:09,920
every time is to give the user more

00:31:05,780 --> 00:31:12,800
control over the serialization which you

00:31:09,920 --> 00:31:14,660
could accomplish with having maybe a mix

00:31:12,800 --> 00:31:18,010
of different cell types so I've thought

00:31:14,660 --> 00:31:20,570
about having the current behavior is

00:31:18,010 --> 00:31:25,100
every cell does this full serialization

00:31:20,570 --> 00:31:26,750
of of its environment and another other

00:31:25,100 --> 00:31:30,530
things that you could also add so I've

00:31:26,750 --> 00:31:35,500
thought of having also what I'm calling

00:31:30,530 --> 00:31:37,700
transient cells that basically the the

00:31:35,500 --> 00:31:40,400
pattern that I've imagined for these

00:31:37,700 --> 00:31:42,290
cells is that rather than serialized

00:31:40,400 --> 00:31:44,840
they would just reacts acute if they're

00:31:42,290 --> 00:31:48,260
if their input is ever needed again so

00:31:44,840 --> 00:31:50,750
you can imagine like a serialized cell

00:31:48,260 --> 00:31:53,450
that has all of its all of its outputs

00:31:50,750 --> 00:31:56,210
cached and then some transient cells

00:31:53,450 --> 00:31:58,250
that depend on that and anytime you run

00:31:56,210 --> 00:31:59,420
one of those transient cells or one

00:31:58,250 --> 00:32:02,030
thing that depends on one of those

00:31:59,420 --> 00:32:05,030
transient cells we can reacts acute all

00:32:02,030 --> 00:32:08,480
of them going back up to that that's

00:32:05,030 --> 00:32:12,280
serialized so and that would kind of let

00:32:08,480 --> 00:32:16,190
you play with the the trade-off between

00:32:12,280 --> 00:32:17,720
between serialization versus compute so

00:32:16,190 --> 00:32:21,940
if you're doing something that might be

00:32:17,720 --> 00:32:24,140
like a memory heavy operation but

00:32:21,940 --> 00:32:27,350
computationally cheap then you can

00:32:24,140 --> 00:32:30,080
imagine that being useful and then also

00:32:27,350 --> 00:32:32,600
it might be useful to have to allow

00:32:30,080 --> 00:32:34,550
global cells as well maybe there's times

00:32:32,600 --> 00:32:36,680
when you want to touch the global State

00:32:34,550 --> 00:32:40,160
but but I think that that should be

00:32:36,680 --> 00:32:42,740
something that you should have to be

00:32:40,160 --> 00:32:44,780
very explicit about rather than the kind

00:32:42,740 --> 00:32:51,050
of way that that's the default behavior

00:32:44,780 --> 00:32:54,950
of standard notebooks currently okay

00:32:51,050 --> 00:32:56,960
then the the kernel so so as I mentioned

00:32:54,950 --> 00:33:00,170
notebook integrates with ipython as a

00:32:56,960 --> 00:33:04,780
cell magic that's kind of an abuse of

00:33:00,170 --> 00:33:08,690
cell magics so ideally this would be

00:33:04,780 --> 00:33:13,460
implemented as a kernel instead and

00:33:08,690 --> 00:33:16,190
ideally we would kind of use the message

00:33:13,460 --> 00:33:19,010
processing framework to talk between a

00:33:16,190 --> 00:33:21,980
specific a specific front-end and the

00:33:19,010 --> 00:33:25,460
specific kernel that are both like

00:33:21,980 --> 00:33:28,630
notebook specific that's kind of that's

00:33:25,460 --> 00:33:31,570
that's a lot more work than the kind of

00:33:28,630 --> 00:33:35,060
cheap and tacky way that I did this here

00:33:31,570 --> 00:33:38,720
but I think that that would be a good

00:33:35,060 --> 00:33:43,340
direction for making it a more a more

00:33:38,720 --> 00:33:44,840
stable project and then also I think

00:33:43,340 --> 00:33:47,300
there's a lot of interesting work that

00:33:44,840 --> 00:33:50,140
can be done on the UI and as well

00:33:47,300 --> 00:33:53,540
currently the the integration between

00:33:50,140 --> 00:33:56,360
notebook and and Jupiter is fairly

00:33:53,540 --> 00:33:58,280
limited I haven't done much on the the

00:33:56,360 --> 00:34:01,160
JavaScript end at all kind of just the

00:33:58,280 --> 00:34:03,620
the bare minimum of of monkey patching

00:34:01,160 --> 00:34:06,020
to make this work at all

00:34:03,620 --> 00:34:10,820
and most of the work has been on the the

00:34:06,020 --> 00:34:13,370
the Python kernel side so future

00:34:10,820 --> 00:34:16,879
direction for this tjuku so Jupiter lab

00:34:13,370 --> 00:34:19,790
has nice advantages of much more

00:34:16,879 --> 00:34:22,220
extensive plug ability like it's it's

00:34:19,790 --> 00:34:24,980
built around having more reusable

00:34:22,220 --> 00:34:28,010
components and in written in modern

00:34:24,980 --> 00:34:32,659
JavaScript so that kind of gives a lot

00:34:28,010 --> 00:34:35,780
more more leeway to to to play around

00:34:32,659 --> 00:34:38,570
with these ideas and that would be a

00:34:35,780 --> 00:34:43,790
useful future direction for any more UI

00:34:38,570 --> 00:34:46,970
work on this so some things that I would

00:34:43,790 --> 00:34:48,440
like to do in that direction one is

00:34:46,970 --> 00:34:51,470
right now I'm not doing anything to

00:34:48,440 --> 00:34:55,190
respond to non execution cell events so

00:34:51,470 --> 00:34:57,290
I'm I'm catching basically only things

00:34:55,190 --> 00:34:58,220
that happen on cell execution but

00:34:57,290 --> 00:35:00,830
there's other things that you might want

00:34:58,220 --> 00:35:04,160
to respond to as well so you know moving

00:35:00,830 --> 00:35:07,100
cells or deleting cells I'll pick that

00:35:04,160 --> 00:35:08,660
up when another cell is executed but it

00:35:07,100 --> 00:35:10,640
would be nice to be able to respond to

00:35:08,660 --> 00:35:14,870
those kind of on that on that user event

00:35:10,640 --> 00:35:16,760
itself another thing is the visibility

00:35:14,870 --> 00:35:18,410
of cell validity so in the examples I

00:35:16,760 --> 00:35:21,380
showed invalid cells were just marked by

00:35:18,410 --> 00:35:23,360
an X be kind of nice to have

00:35:21,380 --> 00:35:26,270
maybe something where that output is

00:35:23,360 --> 00:35:28,660
grayed out so that it's more visually

00:35:26,270 --> 00:35:30,830
apparent to the user that that dot

00:35:28,660 --> 00:35:34,870
previously computed output is now

00:35:30,830 --> 00:35:39,290
invalid also I think it'd be nice to

00:35:34,870 --> 00:35:42,950
since we're we're maintaining all of

00:35:39,290 --> 00:35:45,980
this connection between cell inputs and

00:35:42,950 --> 00:35:47,990
outputs we we have these potentially

00:35:45,980 --> 00:35:51,770
useful to the user relationships of

00:35:47,990 --> 00:35:53,120
exactly what cells depend on so I think

00:35:51,770 --> 00:35:56,960
that there could be some interesting UI

00:35:53,120 --> 00:35:58,790
work there around indicating what cells

00:35:56,960 --> 00:36:01,100
depend on what which I kind of like

00:35:58,790 --> 00:36:04,850
mocked out a little bit in this in this

00:36:01,100 --> 00:36:07,160
picture here and then also support for

00:36:04,850 --> 00:36:08,900
different types of execution cells so on

00:36:07,160 --> 00:36:12,140
the previous slide I mentioned wanting

00:36:08,900 --> 00:36:16,660
to give the user more control over over

00:36:12,140 --> 00:36:18,790
exactly how the cell behavior works and

00:36:16,660 --> 00:36:21,380
that would that would kind of

00:36:18,790 --> 00:36:23,510
necessitate having something besides

00:36:21,380 --> 00:36:25,190
just the one executable called code cell

00:36:23,510 --> 00:36:30,530
at least the way that I was thinking

00:36:25,190 --> 00:36:34,640
about it and I think that that's that's

00:36:30,530 --> 00:36:37,580
that's it I'm this is this is on github

00:36:34,640 --> 00:36:39,770
I'm happy to have other people take a

00:36:37,580 --> 00:36:41,990
look at this worked on it as well if

00:36:39,770 --> 00:36:46,070
anybody's interested in kind of taking

00:36:41,990 --> 00:36:48,560
this taking this further and also I

00:36:46,070 --> 00:36:50,980
think we have some plenty of time for

00:36:48,560 --> 00:36:50,980
questions

00:36:50,990 --> 00:36:59,200
[Applause]

00:37:21,670 --> 00:37:29,600
right yeah right

00:37:25,190 --> 00:37:31,040
so I think that like one of the okay so

00:37:29,600 --> 00:37:33,800
like that I think one thing that makes

00:37:31,040 --> 00:37:36,890
it fairly different from other other

00:37:33,800 --> 00:37:38,590
things that I've seen is the the way

00:37:36,890 --> 00:37:42,440
that I'm handling dependency tracking

00:37:38,590 --> 00:37:47,330
via serialization so I think that comes

00:37:42,440 --> 00:37:49,760
with pros and cons like it's I think it

00:37:47,330 --> 00:37:54,620
leads to kind of more intuitive behavior

00:37:49,760 --> 00:37:56,480
at least for me because I'm you you can

00:37:54,620 --> 00:37:59,660
you can get a lot out of that and in

00:37:56,480 --> 00:38:02,080
terms of like making sure that the

00:37:59,660 --> 00:38:04,790
environment that the cell executes sin

00:38:02,080 --> 00:38:08,420
is is exactly what you want it to

00:38:04,790 --> 00:38:10,580
execute in so if if you're if you're not

00:38:08,420 --> 00:38:13,670
doing that it's kind of really tricky to

00:38:10,580 --> 00:38:15,920
get around the problem that at the heart

00:38:13,670 --> 00:38:18,170
of it everything is is mutating a global

00:38:15,920 --> 00:38:19,910
state in some way like python is not

00:38:18,170 --> 00:38:24,020
really good about having immutable

00:38:19,910 --> 00:38:25,820
objects in general so so so to make this

00:38:24,020 --> 00:38:28,910
work the way that I wanted I kind of had

00:38:25,820 --> 00:38:33,290
to hack immutability into into it right

00:38:28,910 --> 00:38:34,910
and the the serialization the

00:38:33,290 --> 00:38:37,510
serialization gets you that in like a

00:38:34,910 --> 00:38:40,490
very thorough and kind of foolproof way

00:38:37,510 --> 00:38:43,520
but also comes with some some cost and

00:38:40,490 --> 00:38:48,380
some some kind of edge cases that that

00:38:43,520 --> 00:38:51,170
introduces as well for me I find I find

00:38:48,380 --> 00:38:53,990
that this kind of encourages me to write

00:38:51,170 --> 00:38:56,390
in notebooks in in the way that I want

00:38:53,990 --> 00:38:58,610
them to to exist with like like a lower

00:38:56,390 --> 00:39:00,080
lower barrier because because it removes

00:38:58,610 --> 00:39:03,350
the need to think about like this

00:39:00,080 --> 00:39:06,109
cleaning up step because I am

00:39:03,350 --> 00:39:09,259
maintaining linear linear exit

00:39:06,109 --> 00:39:11,239
fusion so that that's a property of it

00:39:09,259 --> 00:39:15,349
that I that I really like for my own

00:39:11,239 --> 00:39:17,420
work is just everything is linear

00:39:15,349 --> 00:39:18,980
linearly ordered and if you accidentally

00:39:17,420 --> 00:39:20,779
do something out of the linear linear

00:39:18,980 --> 00:39:22,029
order it's immediately not going to work

00:39:20,779 --> 00:39:25,039
and you're going to immediately see why

00:39:22,029 --> 00:39:28,039
so rather than having having something

00:39:25,039 --> 00:39:29,329
where like you can very easily not

00:39:28,039 --> 00:39:33,440
realize that you did something out of

00:39:29,329 --> 00:39:37,160
linear order that that kind of keeps you

00:39:33,440 --> 00:39:39,829
honest and removes that kind of mental

00:39:37,160 --> 00:39:41,779
load for having to reason about whether

00:39:39,829 --> 00:39:43,489
or not something would be linearly

00:39:41,779 --> 00:39:46,579
ordered or what you adapted you to clean

00:39:43,489 --> 00:39:47,749
something up to be linearly ordered so I

00:39:46,579 --> 00:39:50,569
don't know if that answers your question

00:39:47,749 --> 00:40:02,239
but that's kind of that's kind of

00:39:50,569 --> 00:40:06,289
aspects of it that I like yeah so let me

00:40:02,239 --> 00:40:08,769
go back to the serialization so wait so

00:40:06,289 --> 00:40:12,759
what I what I'm doing here is I am

00:40:08,769 --> 00:40:16,789
serializing the the object and I'm I'm

00:40:12,759 --> 00:40:18,950
and computing the hash of it so the hash

00:40:16,789 --> 00:40:22,989
is is the hash is what I'm storing

00:40:18,950 --> 00:40:26,390
alongside that cell but the the full

00:40:22,989 --> 00:40:28,999
serialized object I'm storing in a

00:40:26,390 --> 00:40:35,359
global store and linking to it via that

00:40:28,999 --> 00:40:37,039
hash yeah oh it's it's C I can serialize

00:40:35,359 --> 00:40:40,160
to memory or a disk so I'm I'm

00:40:37,039 --> 00:40:46,059
serializing it I like are you asking

00:40:40,160 --> 00:40:48,470
whether I need to see realize at all yes

00:40:46,059 --> 00:40:49,819
sorry sorry is the question around

00:40:48,470 --> 00:40:51,170
whether I need to serialize or not or

00:40:49,819 --> 00:41:00,349
whether it's a serialize to memory or

00:40:51,170 --> 00:41:02,180
not yeah I also need to serialize to get

00:41:00,349 --> 00:41:04,549
immutability so if i if I'm not

00:41:02,180 --> 00:41:05,989
serializing things like if I'm just like

00:41:04,549 --> 00:41:07,549
sticking it somewhere else then

00:41:05,989 --> 00:41:09,079
something else can mutate that object

00:41:07,549 --> 00:41:11,299
because like references to it still

00:41:09,079 --> 00:41:13,099
exist but by serialized in it I

00:41:11,299 --> 00:41:14,630
guarantee that there's no references to

00:41:13,099 --> 00:41:16,900
it anywhere nothing can mutate it it's

00:41:14,630 --> 00:41:16,900
frozen

00:41:23,690 --> 00:41:26,780
anything else

00:41:30,710 --> 00:41:34,830
go I'm not sure for every out time no

00:41:33,990 --> 00:41:38,160
okay

00:41:34,830 --> 00:41:43,350
but I guess I'll end a little bit early

00:41:38,160 --> 00:41:43,350

YouTube URL: https://www.youtube.com/watch?v=CgJrQXOYIk8


