Title: Containerizing notebooks for serverless execution (sponsored by AWS)
Publication date: 2018-09-20
Playlist: JupyterCon in New York 2018
Description: 
	Containerizing notebooks for serverless execution (sponsored by AWS)
Kevin McCormick (Amazon Web Services), Vladimir Zhukov (Amazon Web Services)

Kevin McCormick explains the story of two approaches which were used internally at AWS to accelerate new ML algorithm development, and easily package Jupyter notebooks for scheduled execution, by creating custom Jupyter kernels that automatically create Docker containers, and dispatch them to either a distributed training service or job execution environment.

This session is sponsored by AWS.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:01,200 --> 00:00:08,340
hi so my name is Kevin and I am the the

00:00:06,600 --> 00:00:11,490
lead engineer on the Amazon sage maker

00:00:08,340 --> 00:00:14,099
notebook team some of you might already

00:00:11,490 --> 00:00:19,880
know we launched last November during

00:00:14,099 --> 00:00:23,280
AWS reinvent and we do a lot of Jupiter

00:00:19,880 --> 00:00:26,040
so Jupiter is a really important part of

00:00:23,280 --> 00:00:27,510
the sage maker product in this morning's

00:00:26,040 --> 00:00:29,310
keynote we talked a little bit about

00:00:27,510 --> 00:00:32,340
many of the components of Amazon sage

00:00:29,310 --> 00:00:34,320
maker and today I just wanted to give

00:00:32,340 --> 00:00:36,270
you a little bit of a sneak peek and

00:00:34,320 --> 00:00:37,980
just an inside look into some of the

00:00:36,270 --> 00:00:39,390
things we've been doing on the

00:00:37,980 --> 00:00:43,050
engineering side that you might find

00:00:39,390 --> 00:00:45,380
interesting with something called kernel

00:00:43,050 --> 00:00:48,720
containerization or notebook

00:00:45,380 --> 00:00:50,460
containerization so by the end of this

00:00:48,720 --> 00:00:52,200
talk I hope you can walk away with a

00:00:50,460 --> 00:00:55,170
better understanding of the following

00:00:52,200 --> 00:00:56,520
four things first I'd like to you to

00:00:55,170 --> 00:00:59,820
understand my definition of what a

00:00:56,520 --> 00:01:02,430
containerized notebook is or a

00:00:59,820 --> 00:01:05,040
containerized kernel the second thing is

00:01:02,430 --> 00:01:08,429
I'd like to give you a little story of

00:01:05,040 --> 00:01:10,049
two use cases we had internally perhaps

00:01:08,429 --> 00:01:13,139
you can apply these two to your daily

00:01:10,049 --> 00:01:15,509
work third thing is I'd like to give you

00:01:13,139 --> 00:01:18,389
just an overview of how we built these

00:01:15,509 --> 00:01:21,259
implementations give you a couple of

00:01:18,389 --> 00:01:23,490
technical deep dives into what we did

00:01:21,259 --> 00:01:25,679
while implementing these things some of

00:01:23,490 --> 00:01:28,920
the challenges we came came across how

00:01:25,679 --> 00:01:32,279
we solve them and lastly I'll give you

00:01:28,920 --> 00:01:34,259
some tips on implementing your own so in

00:01:32,279 --> 00:01:39,029
this talk I'll I'll try not to be too

00:01:34,259 --> 00:01:40,590
technical but I I do assume that you

00:01:39,029 --> 00:01:42,479
have a basic understanding of how a

00:01:40,590 --> 00:01:45,539
kernel works how a docker container

00:01:42,479 --> 00:01:47,549
works and don't worry none of this will

00:01:45,539 --> 00:01:49,950
be on the test later and all the slides

00:01:47,549 --> 00:01:51,420
will be available for download from the

00:01:49,950 --> 00:01:54,840
Jupiter Khan website at the end of this

00:01:51,420 --> 00:01:56,340
talk okay so before we dive into the

00:01:54,840 --> 00:01:57,869
nuts and bolts the first thing I'd like

00:01:56,340 --> 00:02:00,779
to do is just give you a very quick

00:01:57,869 --> 00:02:02,969
overview of the relevant moving pieces

00:02:00,779 --> 00:02:06,419
so the first thing I'd like to talk

00:02:02,969 --> 00:02:08,759
about is Amazon sage maker so this is

00:02:06,419 --> 00:02:10,860
the service I work on and sage maker is

00:02:08,759 --> 00:02:13,079
a fully managed service that makes it

00:02:10,860 --> 00:02:14,590
easy to build train and deploy machine

00:02:13,079 --> 00:02:17,240
learning models in the cloud

00:02:14,590 --> 00:02:18,140
the build portion of this diagram is the

00:02:17,240 --> 00:02:21,349
part that I work on

00:02:18,140 --> 00:02:23,120
that's the Jupiter notebooks so for

00:02:21,349 --> 00:02:25,250
completeness and this will be a little

00:02:23,120 --> 00:02:27,650
relevant later sage maker also includes

00:02:25,250 --> 00:02:30,410
a few other things a scalable model

00:02:27,650 --> 00:02:32,630
training and tuning service a model

00:02:30,410 --> 00:02:34,730
hosting service for both real-time and

00:02:32,630 --> 00:02:40,910
batch predictions and a broad selection

00:02:34,730 --> 00:02:41,840
of ready to use algorithms the second

00:02:40,910 --> 00:02:45,860
service that I'm going to be mentioning

00:02:41,840 --> 00:02:47,870
is AWS IOT analytics this is a totally

00:02:45,860 --> 00:02:49,430
different AWS service which is a fully

00:02:47,870 --> 00:02:52,610
managed service that makes it easy to

00:02:49,430 --> 00:02:55,910
run sophisticated analytics on massive

00:02:52,610 --> 00:02:58,430
volumes of IOT related data some things

00:02:55,910 --> 00:03:01,040
you can do with analytics are also

00:02:58,430 --> 00:03:02,450
integrated with Sage maker for example

00:03:01,040 --> 00:03:03,709
it can automatically create notebook

00:03:02,450 --> 00:03:07,280
files for you which are pre-configured

00:03:03,709 --> 00:03:09,230
to look at all your IOT data from there

00:03:07,280 --> 00:03:11,660
you can do event advanced analytics

00:03:09,230 --> 00:03:12,110
trained machine learning models and so

00:03:11,660 --> 00:03:14,720
forth

00:03:12,110 --> 00:03:16,819
and in fact today as a coincidence we're

00:03:14,720 --> 00:03:19,100
also launching a new feature in IOT

00:03:16,819 --> 00:03:20,810
analytics which lets you run notebooks

00:03:19,100 --> 00:03:23,510
on a schedule or based on a triggered

00:03:20,810 --> 00:03:26,060
event that's being announced today I'm

00:03:23,510 --> 00:03:27,980
not a trained keynote speaker but that's

00:03:26,060 --> 00:03:32,390
happening in Anaheim California more or

00:03:27,980 --> 00:03:35,030
less as we speak so a lot of people love

00:03:32,390 --> 00:03:38,450
containers who here loves containers wow

00:03:35,030 --> 00:03:39,470
that's a lot of hands great ok you can

00:03:38,450 --> 00:03:41,900
put a lot of things in a container

00:03:39,470 --> 00:03:45,709
obviously and container izing is just

00:03:41,900 --> 00:03:47,930
putting things in a container so here

00:03:45,709 --> 00:03:49,220
what are some examples well first the

00:03:47,930 --> 00:03:50,570
whole operating system goes in the

00:03:49,220 --> 00:03:54,920
container that's the first line of your

00:03:50,570 --> 00:03:58,220
docker file Amazon Linux Ubuntu cent OS

00:03:54,920 --> 00:03:59,660
etc and there from there you put in your

00:03:58,220 --> 00:04:01,370
applications you could put in the

00:03:59,660 --> 00:04:03,410
Jupiter notebook server you could put an

00:04:01,370 --> 00:04:05,650
NB convert you could put whatever

00:04:03,410 --> 00:04:07,670
aprica' application you'd like in there

00:04:05,650 --> 00:04:08,209
you could throw a notebook files in a

00:04:07,670 --> 00:04:09,980
container

00:04:08,209 --> 00:04:12,769
some people might do that some people

00:04:09,980 --> 00:04:14,269
might not and you might even put all of

00:04:12,769 --> 00:04:16,400
your other stuff your dependencies your

00:04:14,269 --> 00:04:18,320
libraries your SDKs if you're using

00:04:16,400 --> 00:04:20,810
Khanda throw the Khanda environments in

00:04:18,320 --> 00:04:24,470
there so a lot of things can go in the

00:04:20,810 --> 00:04:26,419
container and then there was one thing

00:04:24,470 --> 00:04:28,310
that we kind of thought about and said

00:04:26,419 --> 00:04:30,110
what if we put something

00:04:28,310 --> 00:04:32,180
in there what if we put a running kernel

00:04:30,110 --> 00:04:35,570
in the container so not the whole

00:04:32,180 --> 00:04:38,660
jupiter server just the kernel and what

00:04:35,570 --> 00:04:41,389
could we do if we did that so I'm gonna

00:04:38,660 --> 00:04:44,830
tell you a story about to David's to

00:04:41,389 --> 00:04:47,800
David's at Amazon I happen to know and

00:04:44,830 --> 00:04:50,960
what they did with this idea

00:04:47,800 --> 00:04:53,889
so the first David was an engineer

00:04:50,960 --> 00:04:56,180
working on the sage maker team this was

00:04:53,889 --> 00:04:57,560
late last year right before they

00:04:56,180 --> 00:05:00,320
reinvent launch working on something

00:04:57,560 --> 00:05:03,470
called LD a LD a is a topic modeling

00:05:00,320 --> 00:05:07,100
algorithm I can't pronounce the whole

00:05:03,470 --> 00:05:08,780
name so I'll save you from that thank

00:05:07,100 --> 00:05:12,530
you thank you the d-rush leh was the

00:05:08,780 --> 00:05:14,510
part I was a little afraid of so david's

00:05:12,530 --> 00:05:16,610
implementation and is just the right

00:05:14,510 --> 00:05:20,390
picture as well I hope I got the right

00:05:16,610 --> 00:05:22,460
one but so David's implementation was

00:05:20,390 --> 00:05:25,790
half written in Python half written in

00:05:22,460 --> 00:05:28,370
C++ and he's trying to put together a

00:05:25,790 --> 00:05:31,220
container and this container is intended

00:05:28,370 --> 00:05:35,330
to run on the sage maker platform data

00:05:31,220 --> 00:05:37,400
in model out so he's writing his unit

00:05:35,330 --> 00:05:41,120
tests like any good engineer he's

00:05:37,400 --> 00:05:42,440
writing small small test cases in his

00:05:41,120 --> 00:05:46,729
Jupiter notebooks making sure the

00:05:42,440 --> 00:05:48,320
algorithm works appropriately and he's

00:05:46,729 --> 00:05:50,390
iterating really fast getting the

00:05:48,320 --> 00:05:53,600
performance numbers better and better

00:05:50,390 --> 00:05:55,550
and better every iteration and he's

00:05:53,600 --> 00:05:57,470
doing these smoke tests and in a smoke

00:05:55,550 --> 00:06:00,110
test he's using the New York Times data

00:05:57,470 --> 00:06:02,240
set so if you've never used this data

00:06:00,110 --> 00:06:04,280
set it contains about 1.8 million New

00:06:02,240 --> 00:06:07,910
York Times articles over the past 30

00:06:04,280 --> 00:06:12,070
years or so and it contains summaries

00:06:07,910 --> 00:06:14,090
and verified tags and this is a great

00:06:12,070 --> 00:06:15,620
verification data set to use for this

00:06:14,090 --> 00:06:18,289
algorithm to make sure it was working

00:06:15,620 --> 00:06:19,880
appropriately so he runs these smoke

00:06:18,289 --> 00:06:24,680
tests they take about 10 minutes to run

00:06:19,880 --> 00:06:29,330
and while the smoke test is running well

00:06:24,680 --> 00:06:31,700
his laptop his desktop totally host the

00:06:29,330 --> 00:06:35,390
this is using every core every last bit

00:06:31,700 --> 00:06:40,120
of the machine and so this was good time

00:06:35,390 --> 00:06:42,230
for tea he's Irish he loves tea so he

00:06:40,120 --> 00:06:45,410
would use these 10 minutes

00:06:42,230 --> 00:06:47,270
really and in case you're wondering he's

00:06:45,410 --> 00:06:49,520
not using a very weak machine he's using

00:06:47,270 --> 00:06:52,520
a cloud desktop which has about thirty

00:06:49,520 --> 00:06:54,320
six cores 60 gigabytes of RAM this is a

00:06:52,520 --> 00:06:57,740
serious beast and it still takes ten

00:06:54,320 --> 00:07:00,140
minutes to run so he's getting towards

00:06:57,740 --> 00:07:01,760
closer to the launch and he says I still

00:07:00,140 --> 00:07:03,350
want to do more than just this New York

00:07:01,760 --> 00:07:05,930
Times data set I want to do the

00:07:03,350 --> 00:07:07,340
Wikipedia data set now the Wikipedia

00:07:05,930 --> 00:07:10,190
data set if you've never used it is

00:07:07,340 --> 00:07:12,830
about ten gigabytes compressed of a

00:07:10,190 --> 00:07:16,370
bunch of Wikipedia articles annotated in

00:07:12,830 --> 00:07:18,320
a similar way now to run this data set

00:07:16,370 --> 00:07:21,470
unlike New York Times takes about six

00:07:18,320 --> 00:07:24,080
hours so he does like T but he doesn't

00:07:21,470 --> 00:07:26,270
like that much T and you can't really

00:07:24,080 --> 00:07:29,300
iterate if every time you iterate you

00:07:26,270 --> 00:07:31,730
have to wait six hours so he starts

00:07:29,300 --> 00:07:33,770
thinking well my end result is gonna be

00:07:31,730 --> 00:07:36,650
a container it's gonna run on sage maker

00:07:33,770 --> 00:07:38,930
what if I run my smoke tests on sage

00:07:36,650 --> 00:07:42,650
maker which at the time was pretty close

00:07:38,930 --> 00:07:44,270
to launch more or less usable so he's

00:07:42,650 --> 00:07:45,620
like but how do I do that I still want

00:07:44,270 --> 00:07:49,430
to use my Jupiter notebook

00:07:45,620 --> 00:07:50,420
I still want iterate quickly and I want

00:07:49,430 --> 00:07:52,580
to do a majority of my development

00:07:50,420 --> 00:07:56,570
locally I just need to run the big heavy

00:07:52,580 --> 00:07:59,390
lifting stuff up in the cloud so he kind

00:07:56,570 --> 00:08:02,000
of set out hacker extraordinaire to

00:07:59,390 --> 00:08:04,790
solve this problem so let me dive into

00:08:02,000 --> 00:08:06,680
what David was trying to do so he's

00:08:04,790 --> 00:08:08,480
developing this algorithm and something

00:08:06,680 --> 00:08:11,420
very similar to a sage maker notebook

00:08:08,480 --> 00:08:14,150
instance it uses anaconda environments

00:08:11,420 --> 00:08:16,130
for dependency management it it's it's

00:08:14,150 --> 00:08:18,050
running with a bunch of local storage

00:08:16,130 --> 00:08:20,990
attached for local data and all of his

00:08:18,050 --> 00:08:25,790
notebooks as well as the algorithms code

00:08:20,990 --> 00:08:29,270
the C++ and the Python so that's that's

00:08:25,790 --> 00:08:31,700
what he was starting with and he's

00:08:29,270 --> 00:08:34,280
trying to get his code over on to the

00:08:31,700 --> 00:08:37,760
right hand side container world the

00:08:34,280 --> 00:08:39,979
training service the hosting service so

00:08:37,760 --> 00:08:41,690
at this at this time back in November on

00:08:39,979 --> 00:08:44,000
the notebook side there were no

00:08:41,690 --> 00:08:48,670
containers anywhere it was really just a

00:08:44,000 --> 00:08:51,140
raw box rude accessed hack hack away and

00:08:48,670 --> 00:08:54,440
there's just nothing nothing container

00:08:51,140 --> 00:08:56,910
related so

00:08:54,440 --> 00:08:58,320
he's trying to build one of the three

00:08:56,910 --> 00:09:00,900
types of algorithms there are actually

00:08:58,320 --> 00:09:02,580
three types of algorithms and containers

00:09:00,900 --> 00:09:04,760
that we support and sage maker he's

00:09:02,580 --> 00:09:07,800
trying to work on the the center one

00:09:04,760 --> 00:09:11,160
customers can also of course build their

00:09:07,800 --> 00:09:13,530
own and we provide several others that

00:09:11,160 --> 00:09:15,720
are out of the box designed to work with

00:09:13,530 --> 00:09:19,020
popular frameworks like tensor flow or

00:09:15,720 --> 00:09:21,630
MX net and in case you're wondering a

00:09:19,020 --> 00:09:23,280
lot of this data is actually all the

00:09:21,630 --> 00:09:25,080
data is stored in s3 so the New York

00:09:23,280 --> 00:09:32,790
Times data set the Wikipedia data set

00:09:25,080 --> 00:09:36,120
your training data and so forth alright

00:09:32,790 --> 00:09:39,810
so this is the loop that he's being

00:09:36,120 --> 00:09:42,600
stuck in the six hour loop so he could

00:09:39,810 --> 00:09:44,220
of course from his just basic build

00:09:42,600 --> 00:09:46,440
tools write a little script that does

00:09:44,220 --> 00:09:48,720
all of the things package up his code

00:09:46,440 --> 00:09:53,220
run the compile step run the build and

00:09:48,720 --> 00:09:55,430
then upload it to Amazon ECR Amazon ECR

00:09:53,220 --> 00:09:58,050
in case you're not familiar with it is a

00:09:55,430 --> 00:10:00,810
docker repository for storing docker

00:09:58,050 --> 00:10:04,230
images and then calling the sage maker

00:10:00,810 --> 00:10:05,700
code the the API is to actually run the

00:10:04,230 --> 00:10:08,490
training and this could have been a

00:10:05,700 --> 00:10:10,560
really simple bash script but he wanted

00:10:08,490 --> 00:10:12,750
iterate faster he wanted to compare the

00:10:10,560 --> 00:10:14,430
results run over run to see if the

00:10:12,750 --> 00:10:17,250
performance was getting better the

00:10:14,430 --> 00:10:18,750
accuracy was getting higher and where

00:10:17,250 --> 00:10:20,910
else do you do that you do it in added

00:10:18,750 --> 00:10:23,550
Ruppert or notebook so he said I'm gonna

00:10:20,910 --> 00:10:25,770
do everything inside of Jupiter so the

00:10:23,550 --> 00:10:29,460
first thing he did to reach toward this

00:10:25,770 --> 00:10:32,490
goal is he built a kernel spec and it's

00:10:29,460 --> 00:10:34,320
a kernel spec if you've never defined

00:10:32,490 --> 00:10:36,180
one before it's really just saying what

00:10:34,320 --> 00:10:38,430
process to run and generally speaking

00:10:36,180 --> 00:10:40,530
out of the box it's the ipython process

00:10:38,430 --> 00:10:43,290
he just added docker to the front of it

00:10:40,530 --> 00:10:47,880
so now the kernel is running inside of a

00:10:43,290 --> 00:10:49,470
container next thing he did is he built

00:10:47,880 --> 00:10:51,960
a bunch of convenience functions as

00:10:49,470 --> 00:10:53,790
magics Jupiter magics for example let's

00:10:51,960 --> 00:10:56,090
say when a training run was complete it

00:10:53,790 --> 00:10:59,040
would pull down all of the data back as

00:10:56,090 --> 00:11:00,510
data frames or other Python objects so

00:10:59,040 --> 00:11:02,880
he could visualize them and compare them

00:11:00,510 --> 00:11:05,490
run over run he probably built about 20

00:11:02,880 --> 00:11:07,440
different magics some higher quality

00:11:05,490 --> 00:11:07,769
than others but you know this is this

00:11:07,440 --> 00:11:09,800
was

00:11:07,769 --> 00:11:13,889
aking time this was the rush to ship so

00:11:09,800 --> 00:11:15,420
that's that's what you get and it did a

00:11:13,889 --> 00:11:17,399
bunch of things I've mentioned many of

00:11:15,420 --> 00:11:20,129
these and it would also perform the

00:11:17,399 --> 00:11:21,869
packaging that I mentioned so when I say

00:11:20,129 --> 00:11:24,569
packaging it would actually take that

00:11:21,869 --> 00:11:25,949
kernel the runtime state of it

00:11:24,569 --> 00:11:28,279
the environment variables the

00:11:25,949 --> 00:11:30,899
dependencies the notebook file itself

00:11:28,279 --> 00:11:33,649
squash it in the container shift-enter

00:11:30,899 --> 00:11:36,509
there it goes it's running on sage maker

00:11:33,649 --> 00:11:37,889
really really great workflow and the

00:11:36,509 --> 00:11:39,449
last thing he did just for fun is he

00:11:37,889 --> 00:11:41,279
built a bunch of widgets and these

00:11:39,449 --> 00:11:45,119
widgets lets you view the job progress

00:11:41,279 --> 00:11:47,509
as interactive progress bars really

00:11:45,119 --> 00:11:49,949
really great stuff there ton of ideas

00:11:47,509 --> 00:11:51,509
and believe it or not he actually worked

00:11:49,949 --> 00:11:54,239
on out of the LDA algorithm

00:11:51,509 --> 00:11:55,860
implementation during this time too so

00:11:54,239 --> 00:11:57,389
i'm gonna give you a quick deep dive of

00:11:55,860 --> 00:11:58,470
just a couple little snippets of code

00:11:57,389 --> 00:12:01,110
just so you can understand the

00:11:58,470 --> 00:12:02,790
complexity of what he built this is the

00:12:01,110 --> 00:12:04,319
kernel spec that's the whole thing by

00:12:02,790 --> 00:12:07,019
the way I just remove a couple of

00:12:04,319 --> 00:12:09,929
connection details it's very very small

00:12:07,019 --> 00:12:11,970
it's a little bit of JSON and this just

00:12:09,929 --> 00:12:13,709
defines what happened and you know

00:12:11,970 --> 00:12:15,449
you'll noticed earlier I said it runs

00:12:13,709 --> 00:12:17,100
docker but actually he wrote a little

00:12:15,449 --> 00:12:19,350
wrapper script called David's kernel

00:12:17,100 --> 00:12:21,569
launcher and that actually launched

00:12:19,350 --> 00:12:24,389
docker the reason he did this was to get

00:12:21,569 --> 00:12:27,959
a little bit more dynamic control over

00:12:24,389 --> 00:12:30,329
what parameters were being passed now if

00:12:27,959 --> 00:12:32,850
you're a docker head you might

00:12:30,329 --> 00:12:34,350
appreciate this part this is an example

00:12:32,850 --> 00:12:36,689
of the docker command line which was

00:12:34,350 --> 00:12:39,209
generated by the kernel launcher so once

00:12:36,689 --> 00:12:40,709
again you can see that really all he's

00:12:39,209 --> 00:12:43,079
doing is he's mounting a bunch of things

00:12:40,709 --> 00:12:47,089
inside of the container running the

00:12:43,079 --> 00:12:50,819
ipython process and mapping a few ports

00:12:47,089 --> 00:12:53,160
Jupiter does use TCP to message in

00:12:50,819 --> 00:12:54,720
between the Jupiter server and the

00:12:53,160 --> 00:12:56,579
kernels so there was a little bit of

00:12:54,720 --> 00:12:59,879
Network trickery that went on to make

00:12:56,579 --> 00:13:01,679
that work and once again he uses a small

00:12:59,879 --> 00:13:04,529
wrapper script inside of the current the

00:13:01,679 --> 00:13:07,139
container as well just to provide a

00:13:04,529 --> 00:13:10,080
little bit more context and make things

00:13:07,139 --> 00:13:12,280
a less hard-coded

00:13:10,080 --> 00:13:13,780
so few other little tiny things that

00:13:12,280 --> 00:13:16,360
David did while he was working on this

00:13:13,780 --> 00:13:18,010
implementation the first thing he did is

00:13:16,360 --> 00:13:20,020
he experimented with this concept of a

00:13:18,010 --> 00:13:21,700
parameterised notebook so a

00:13:20,020 --> 00:13:24,570
parameterised notebook is a notebook

00:13:21,700 --> 00:13:26,800
that accepts parameters at runtime and

00:13:24,570 --> 00:13:29,200
he was thinking maybe in some future

00:13:26,800 --> 00:13:32,260
iteration an entire notebook could be

00:13:29,200 --> 00:13:34,480
dispatched as a training job maybe be

00:13:32,260 --> 00:13:37,480
reusable maybe be used for hyper

00:13:34,480 --> 00:13:38,890
parameter optimization and he found a

00:13:37,480 --> 00:13:40,570
really nice library called

00:13:38,890 --> 00:13:42,640
paper mill which I think some of the

00:13:40,570 --> 00:13:45,610
contributors are floating around here at

00:13:42,640 --> 00:13:46,960
Jupiter Khan this week so say hi to them

00:13:45,610 --> 00:13:49,960
are there any contributors in the room

00:13:46,960 --> 00:13:52,510
here it's a paper mill okay well thank

00:13:49,960 --> 00:13:55,930
you anyway it was a really really great

00:13:52,510 --> 00:13:58,360
library and the second thing he did is

00:13:55,930 --> 00:14:01,300
he added a flag to his MAGIX to bypass

00:13:58,360 --> 00:14:03,670
this upload step and what that meant is

00:14:01,300 --> 00:14:05,290
is that sometimes during an iteration

00:14:03,670 --> 00:14:07,030
the actual expensive part was building

00:14:05,290 --> 00:14:09,520
the container and uploading it to Amazon

00:14:07,030 --> 00:14:11,140
ECR so he had a little flag to say just

00:14:09,520 --> 00:14:13,810
run the container locally for now that's

00:14:11,140 --> 00:14:17,650
that's all I really want to do well it

00:14:13,810 --> 00:14:19,330
turns out that he demoed this internally

00:14:17,650 --> 00:14:21,790
we have meetups regularly like a lot of

00:14:19,330 --> 00:14:24,550
companies do and he showed off his

00:14:21,790 --> 00:14:26,380
hackery and it turns out that his little

00:14:24,550 --> 00:14:27,910
local mode flag ended up becoming a

00:14:26,380 --> 00:14:30,100
feature of sage maker later on called

00:14:27,910 --> 00:14:33,010
sage maker local mode which lets you run

00:14:30,100 --> 00:14:34,600
the sage maker algorithms locally on on

00:14:33,010 --> 00:14:37,060
jupiter notebooks so that you can

00:14:34,600 --> 00:14:38,620
iterate more quickly save the compute

00:14:37,060 --> 00:14:41,470
power as well if you're using a very

00:14:38,620 --> 00:14:44,440
tiny amount of training data second

00:14:41,470 --> 00:14:46,870
thing he did is or that happen at that

00:14:44,440 --> 00:14:48,460
meetup was a couple of guys from the IOT

00:14:46,870 --> 00:14:50,610
team showed up just out of interest

00:14:48,460 --> 00:14:52,480
they're building this notebook feature

00:14:50,610 --> 00:14:53,110
one or two of them are in the room right

00:14:52,480 --> 00:14:55,420
now I think

00:14:53,110 --> 00:14:57,670
Oleg's back there wave say hello it's so

00:14:55,420 --> 00:15:01,420
like he he was in the room along with

00:14:57,670 --> 00:15:03,820
David who the second David who said who

00:15:01,420 --> 00:15:06,460
that's a really interesting concept very

00:15:03,820 --> 00:15:07,750
interesting and of course I was in the

00:15:06,460 --> 00:15:10,060
room too and I kind of made the

00:15:07,750 --> 00:15:14,050
connections for them so I view myself as

00:15:10,060 --> 00:15:16,300
a little bit of a matchmaker so let's

00:15:14,050 --> 00:15:19,600
talk about david number two and oleg and

00:15:16,300 --> 00:15:21,700
jung who worked on this so david number

00:15:19,600 --> 00:15:23,290
two was a brand new Amazonian software

00:15:21,700 --> 00:15:23,830
engineer he's ready to dig his teeth

00:15:23,290 --> 00:15:27,580
into

00:15:23,830 --> 00:15:29,110
first customer-facing feature and he

00:15:27,580 --> 00:15:30,220
wants to really impress the team and

00:15:29,110 --> 00:15:32,590
build something very high quality

00:15:30,220 --> 00:15:36,100
production ready something that we can

00:15:32,590 --> 00:15:37,090
launch which we're doing today and David

00:15:36,100 --> 00:15:38,890
was trying to solve a different problem

00:15:37,090 --> 00:15:41,950
and the problem he was trying to solve

00:15:38,890 --> 00:15:45,340
was that customers who wrote these IOT

00:15:41,950 --> 00:15:47,260
analytics notebooks wanted to run them

00:15:45,340 --> 00:15:48,760
when they were not sitting in front of

00:15:47,260 --> 00:15:51,540
the notebook server and maybe when the

00:15:48,760 --> 00:15:53,680
notebook server wasn't even running

00:15:51,540 --> 00:15:59,260
containers seemed like a really good

00:15:53,680 --> 00:16:01,870
solution to that problem so there was a

00:15:59,260 --> 00:16:04,870
customer who approached the IOT team

00:16:01,870 --> 00:16:08,410
runs a wind farm yep we have customers

00:16:04,870 --> 00:16:10,000
that run wind farms and they said

00:16:08,410 --> 00:16:13,180
whenever the weather changes we want to

00:16:10,000 --> 00:16:14,890
run the notebook so if the notebook

00:16:13,180 --> 00:16:16,810
server is not running well that's not

00:16:14,890 --> 00:16:18,270
going to work if the dependencies get

00:16:16,810 --> 00:16:20,560
out of whack that's not going to work so

00:16:18,270 --> 00:16:22,180
let's run them in a container in a

00:16:20,560 --> 00:16:30,160
serverless environment in a very very

00:16:22,180 --> 00:16:31,750
reproducible way so you could probably

00:16:30,160 --> 00:16:33,460
come up with a little bit of a homegrown

00:16:31,750 --> 00:16:36,280
solution you could type things together

00:16:33,460 --> 00:16:37,840
like a cron job or if you're an AWS

00:16:36,280 --> 00:16:40,390
power user you could use cloud watch

00:16:37,840 --> 00:16:42,400
events you could use lambda functions

00:16:40,390 --> 00:16:44,170
you could kind of glue a bunch of things

00:16:42,400 --> 00:16:48,490
together to run things on a schedule but

00:16:44,170 --> 00:16:50,020
they wanted this to be one click so they

00:16:48,490 --> 00:16:51,670
said let's do this containerization

00:16:50,020 --> 00:16:54,100
thing let's just make it really easy

00:16:51,670 --> 00:16:55,600
the notebook becomes the container the

00:16:54,100 --> 00:16:57,610
kernel that was used goes into the

00:16:55,600 --> 00:17:00,580
container we can run it in a service

00:16:57,610 --> 00:17:03,670
environment that's what we're gonna

00:17:00,580 --> 00:17:05,470
build so they dive in and they realize

00:17:03,670 --> 00:17:07,930
that David number one solution was a

00:17:05,470 --> 00:17:12,280
little bit more let's say happy case

00:17:07,930 --> 00:17:15,070
then sad case so it didn't always work

00:17:12,280 --> 00:17:16,540
all the time for example if you're

00:17:15,070 --> 00:17:18,310
trying to install dependencies at

00:17:16,540 --> 00:17:19,570
runtime what if the internet isn't

00:17:18,310 --> 00:17:21,940
available or what if the Internet is

00:17:19,570 --> 00:17:24,010
just having a bad day what if what if

00:17:21,940 --> 00:17:27,640
someone hacked into the repository like

00:17:24,010 --> 00:17:29,080
pi PI or NPM and breaks the dependency

00:17:27,640 --> 00:17:31,870
chain along the way I think that's

00:17:29,080 --> 00:17:33,790
happened recently so let's just get

00:17:31,870 --> 00:17:36,400
everything right let's just make sure

00:17:33,790 --> 00:17:37,480
everything is locked in exactly the way

00:17:36,400 --> 00:17:39,100
it should be run

00:17:37,480 --> 00:17:40,780
that whenever that weather changes all

00:17:39,100 --> 00:17:45,520
that windmill data gets fed into some

00:17:40,780 --> 00:17:47,290
machine learning model for review so I

00:17:45,520 --> 00:17:52,600
talked about running on a schedule a

00:17:47,290 --> 00:17:54,549
little bit and the other big issue of

00:17:52,600 --> 00:17:55,150
course is that if you just tell your

00:17:54,549 --> 00:17:57,669
customers

00:17:55,150 --> 00:17:58,929
hey just write a docker file data

00:17:57,669 --> 00:18:00,340
scientists who've been hacking away at

00:17:58,929 --> 00:18:01,660
something for a couple of weeks or a

00:18:00,340 --> 00:18:04,210
couple of months aren't going to

00:18:01,660 --> 00:18:06,850
retrofit their work always to get the

00:18:04,210 --> 00:18:11,250
dependencies perfect so once again

00:18:06,850 --> 00:18:11,250
looking at that one one-click solution I

00:18:11,400 --> 00:18:17,710
talked about it not always working

00:18:13,419 --> 00:18:19,330
outside your environment as well so the

00:18:17,710 --> 00:18:22,750
first thing they did is start from that

00:18:19,330 --> 00:18:24,970
experience that one click and this was

00:18:22,750 --> 00:18:27,160
the the first drawing of what they

00:18:24,970 --> 00:18:29,919
wanted to build very very simple they

00:18:27,160 --> 00:18:32,679
used a very sophisticated desktop paint

00:18:29,919 --> 00:18:34,570
application that I won't name to build

00:18:32,679 --> 00:18:37,150
this prototype and it's really simple

00:18:34,570 --> 00:18:41,049
just an extra toolbar button toolbar

00:18:37,150 --> 00:18:42,880
item a modal dialog you know click the

00:18:41,049 --> 00:18:47,169
button and go no idea how to build it

00:18:42,880 --> 00:18:50,020
start with a dialog so they send it off

00:18:47,169 --> 00:18:51,490
for review we have a team meeting and we

00:18:50,020 --> 00:18:55,090
say ok let's move the button to the

00:18:51,490 --> 00:18:56,799
toolbar make it more visible and let's

00:18:55,090 --> 00:18:59,590
also build it into a multi-step

00:18:56,799 --> 00:19:01,780
wizard-like interface to do things like

00:18:59,590 --> 00:19:04,750
specifying the metadata getting the

00:19:01,780 --> 00:19:06,309
notebook variables determining where the

00:19:04,750 --> 00:19:08,559
container is going to go like which

00:19:06,309 --> 00:19:09,730
repository and then provide some

00:19:08,559 --> 00:19:15,130
real-time progress on the

00:19:09,730 --> 00:19:16,600
containerization operation so let me

00:19:15,130 --> 00:19:19,419
give you a quick demo of what this looks

00:19:16,600 --> 00:19:21,309
like this is about a minute minute and a

00:19:19,419 --> 00:19:23,470
half long and it'll actually show the

00:19:21,309 --> 00:19:25,929
feature in action so this is a brand new

00:19:23,470 --> 00:19:28,419
jupiter notebook and you can see there's

00:19:25,929 --> 00:19:29,919
a whole new list of kernels in addition

00:19:28,419 --> 00:19:31,750
to the regular kernels like the python -

00:19:29,919 --> 00:19:34,270
in the Python 3 kernel there are these

00:19:31,750 --> 00:19:36,070
special containerized kernels so

00:19:34,270 --> 00:19:38,549
choosing one of those to create the

00:19:36,070 --> 00:19:41,950
notebook file throw in your Python code

00:19:38,549 --> 00:19:43,929
you can see that it runs just fine and

00:19:41,950 --> 00:19:45,460
now let's let's get this notebook

00:19:43,929 --> 00:19:49,570
running on a schedule in a container

00:19:45,460 --> 00:19:52,210
click that button give it a name

00:19:49,570 --> 00:19:53,950
and you'll notice it's also identified

00:19:52,210 --> 00:19:56,799
all the variables in the notebook so

00:19:53,950 --> 00:20:00,580
that if at runtime we want to provide

00:19:56,799 --> 00:20:01,779
them dynamically we can then it looks to

00:20:00,580 --> 00:20:04,600
see all the repositories that are

00:20:01,779 --> 00:20:06,399
accessible to you from that context or

00:20:04,600 --> 00:20:07,750
create a new one you can see in this

00:20:06,399 --> 00:20:13,750
case we're creating a new repository

00:20:07,750 --> 00:20:16,960
called Jupiter Khan and from there make

00:20:13,750 --> 00:20:20,080
sure everything looks good and then we

00:20:16,960 --> 00:20:22,570
containerize and that's really about it

00:20:20,080 --> 00:20:25,210
and now that container can be run on a

00:20:22,570 --> 00:20:28,179
schedule in more or less any environment

00:20:25,210 --> 00:20:30,490
that can accept a docker file the AWS

00:20:28,179 --> 00:20:33,639
iot feature has a beautiful console

00:20:30,490 --> 00:20:35,830
where you can define the schedules the

00:20:33,639 --> 00:20:37,510
triggers and so forth so I won't speak

00:20:35,830 --> 00:20:39,669
too heavily to that experience but this

00:20:37,510 --> 00:20:42,159
is really a vanilla docker file it can

00:20:39,669 --> 00:20:44,529
be run anywhere you could trigger you

00:20:42,159 --> 00:20:47,740
could create a lambda function that runs

00:20:44,529 --> 00:20:49,330
it once a week you could download the

00:20:47,740 --> 00:20:52,179
docker file and run it somewhere else

00:20:49,330 --> 00:20:53,830
you could invoke it within a Jupiter

00:20:52,179 --> 00:20:55,059
notebook if you really wanted to it's

00:20:53,830 --> 00:20:58,260
just a plain old docker file

00:20:55,059 --> 00:21:01,990
nothing especially proprietary about it

00:20:58,260 --> 00:21:06,700
so yeah that's that's the feature and

00:21:01,990 --> 00:21:08,320
that is available today as well so now

00:21:06,700 --> 00:21:09,490
that you see it in production let me

00:21:08,320 --> 00:21:11,980
talk a little bit about all the parts

00:21:09,490 --> 00:21:13,990
that were involved in building it so on

00:21:11,980 --> 00:21:16,690
the client side everything is managed in

00:21:13,990 --> 00:21:21,100
a single module called IOT a notebook

00:21:16,690 --> 00:21:22,870
containers and this really does all of

00:21:21,100 --> 00:21:24,429
the work it installs all the

00:21:22,870 --> 00:21:28,389
functionality into the Jupiter notebook

00:21:24,429 --> 00:21:30,190
brings that toolbar button alive gets

00:21:28,389 --> 00:21:33,309
the containerized kernels available in

00:21:30,190 --> 00:21:35,679
that drop-down box so the first thing is

00:21:33,309 --> 00:21:37,450
just a very simple shell script IOT runs

00:21:35,679 --> 00:21:40,179
the script for you you could run it

00:21:37,450 --> 00:21:42,480
yourself if you'd like and that gets the

00:21:40,179 --> 00:21:47,169
concern that the kernels in that list

00:21:42,480 --> 00:21:48,549
and this just runs the script that

00:21:47,169 --> 00:21:49,990
creates all those kernel specs like I

00:21:48,549 --> 00:21:51,730
showed you before it's a little bit more

00:21:49,990 --> 00:21:53,370
refined the David number-ones version

00:21:51,730 --> 00:21:56,049
but it's essentially does the same thing

00:21:53,370 --> 00:21:59,860
and this is all done within some Python

00:21:56,049 --> 00:22:01,690
code so like many Drupa tear extensions

00:21:59,860 --> 00:22:02,400
this extension is split between two

00:22:01,690 --> 00:22:04,320
halves

00:22:02,400 --> 00:22:06,690
the notebook extension and the server

00:22:04,320 --> 00:22:08,160
extension and the server extension is

00:22:06,690 --> 00:22:10,710
the part that runs alongside the Jupiter

00:22:08,160 --> 00:22:12,780
process it's Python the notebook

00:22:10,710 --> 00:22:18,120
extension runs all in the browser it's

00:22:12,780 --> 00:22:20,340
JavaScript so that server extension has

00:22:18,120 --> 00:22:22,230
basically two jobs first thing it does

00:22:20,340 --> 00:22:25,170
is it manages all of the interactions

00:22:22,230 --> 00:22:26,880
with Amazon ECR it deals with the

00:22:25,170 --> 00:22:28,530
credentials it deals with just

00:22:26,880 --> 00:22:32,850
discovering the ones that are accessible

00:22:28,530 --> 00:22:36,360
to you based on your role and also

00:22:32,850 --> 00:22:38,250
manages creating new ones on the fly and

00:22:36,360 --> 00:22:40,320
the other half is the real interesting

00:22:38,250 --> 00:22:42,540
part which is the thing that creates the

00:22:40,320 --> 00:22:44,520
kernel images and this has a bunch of

00:22:42,540 --> 00:22:46,679
logic in it to take whatever Jupiter

00:22:44,520 --> 00:22:48,210
environment you're in and captures it as

00:22:46,679 --> 00:22:52,290
perfectly as possible so that it can be

00:22:48,210 --> 00:22:54,360
run later accurately and for the docker

00:22:52,290 --> 00:22:57,330
heads in the room the containers that

00:22:54,360 --> 00:22:59,040
are produced use a very standard open

00:22:57,330 --> 00:23:00,540
container spec annotation to store all

00:22:59,040 --> 00:23:02,610
those variables there's no hidden

00:23:00,540 --> 00:23:03,809
metadata store somewhere that keeps

00:23:02,610 --> 00:23:05,490
track of these variables there

00:23:03,809 --> 00:23:07,740
everything is right in the docker file

00:23:05,490 --> 00:23:12,510
right in the the metadata there's there

00:23:07,740 --> 00:23:13,800
no tricks whatsoever involved so who'd

00:23:12,510 --> 00:23:16,170
like to do a couple of deep dives on a

00:23:13,800 --> 00:23:18,690
couple of these components and like I

00:23:16,170 --> 00:23:20,940
said none of this will be on the test so

00:23:18,690 --> 00:23:25,980
and most of the source code will also be

00:23:20,940 --> 00:23:27,320
available at the end of this talk - okay

00:23:25,980 --> 00:23:29,250
so the first thing is that kernel

00:23:27,320 --> 00:23:30,960
container creator this is the thing

00:23:29,250 --> 00:23:33,750
that's run at install time the first

00:23:30,960 --> 00:23:35,610
time you use this thing and I just gave

00:23:33,750 --> 00:23:37,920
you a little tiny snippet of the code

00:23:35,610 --> 00:23:40,410
and and this is the part that creates

00:23:37,920 --> 00:23:42,270
the docker files so each one of those

00:23:40,410 --> 00:23:45,120
can those containers has a docker file

00:23:42,270 --> 00:23:46,950
associated with it and if you're if

00:23:45,120 --> 00:23:48,240
you've never worked with docker from

00:23:46,950 --> 00:23:50,190
within Python there's actually a

00:23:48,240 --> 00:23:52,020
beautiful docker library that makes it

00:23:50,190 --> 00:23:53,850
really easy to create docker files and

00:23:52,020 --> 00:23:56,550
interact with docker without having to

00:23:53,850 --> 00:23:58,440
shell out to a bunch of CLI commands so

00:23:56,550 --> 00:24:01,190
you can see here we create the header of

00:23:58,440 --> 00:24:03,570
the docker file is a string and then we

00:24:01,190 --> 00:24:06,840
create a dictionary that identifies all

00:24:03,570 --> 00:24:08,100
the mounted volumes you you run build

00:24:06,840 --> 00:24:10,410
and then it puts together all the

00:24:08,100 --> 00:24:11,940
commands for you under the covers just a

00:24:10,410 --> 00:24:13,080
really interesting thing I figured you

00:24:11,940 --> 00:24:15,120
might be interested in if you're

00:24:13,080 --> 00:24:15,640
interacting with docker a lot in a

00:24:15,120 --> 00:24:22,720
program at

00:24:15,640 --> 00:24:24,280
way it's a really great library so this

00:24:22,720 --> 00:24:25,780
is a different snippet of code this is

00:24:24,280 --> 00:24:28,179
the thing that installs all of the

00:24:25,780 --> 00:24:29,650
kernels and once again this is something

00:24:28,179 --> 00:24:33,309
you could do as well for a variety of

00:24:29,650 --> 00:24:35,200
use cases you can come up with and this

00:24:33,309 --> 00:24:37,210
just creates more kernels in Jupiter and

00:24:35,200 --> 00:24:38,799
once again we're using Python code to do

00:24:37,210 --> 00:24:41,740
this so we're not just dropping JSON

00:24:38,799 --> 00:24:44,049
files everywhere where we're trying to

00:24:41,740 --> 00:24:45,820
use the library to make sure that it's

00:24:44,049 --> 00:24:51,760
correct and it's more extensible for

00:24:45,820 --> 00:24:53,770
later so you can see down below we're at

00:24:51,760 --> 00:24:56,830
the very very last line we're calling an

00:24:53,770 --> 00:25:01,270
install kernel spec that's a standard

00:24:56,830 --> 00:25:03,309
Jupiter API to install kernels anyone

00:25:01,270 --> 00:25:05,350
can import this library and use it for a

00:25:03,309 --> 00:25:08,169
variety of purposes if you're not a

00:25:05,350 --> 00:25:10,929
kernel author maybe this inspires you to

00:25:08,169 --> 00:25:12,970
try at some point to create a customized

00:25:10,929 --> 00:25:15,540
version of the Python kernel or maybe a

00:25:12,970 --> 00:25:18,429
new language or even more sophisticated

00:25:15,540 --> 00:25:20,410
containerization solution it's really

00:25:18,429 --> 00:25:22,960
this simple and I actually really didn't

00:25:20,410 --> 00:25:26,140
remove any code for this talk what you

00:25:22,960 --> 00:25:27,460
see is more that's what runs one other

00:25:26,140 --> 00:25:28,809
thing I just wanted to mention at the

00:25:27,460 --> 00:25:30,970
top is we use something called the

00:25:28,809 --> 00:25:34,299
environment kernel spec manager so this

00:25:30,970 --> 00:25:36,460
is a customized version of the spec

00:25:34,299 --> 00:25:38,169
manager it's also open source but what

00:25:36,460 --> 00:25:40,360
this does is it automatically creates a

00:25:38,169 --> 00:25:42,940
kernel for every kind of environment or

00:25:40,360 --> 00:25:44,590
virtual and on your machine so it just

00:25:42,940 --> 00:25:45,940
makes it easier if you're using one of

00:25:44,590 --> 00:25:48,010
those popular dependency management

00:25:45,940 --> 00:25:50,350
solutions to just automatically have

00:25:48,010 --> 00:25:52,720
those kernels created for you we use

00:25:50,350 --> 00:25:57,240
this by default and sage maker but it's

00:25:52,720 --> 00:26:01,270
also if installable or Conda installable

00:25:57,240 --> 00:26:04,030
so now let's talk about creating those

00:26:01,270 --> 00:26:07,780
images what happens it's really a six

00:26:04,030 --> 00:26:10,750
step process and remember the goal here

00:26:07,780 --> 00:26:14,410
is to create a container that runs the

00:26:10,750 --> 00:26:16,440
kernel but at runtime it's running

00:26:14,410 --> 00:26:19,630
through the notebook in a headless way

00:26:16,440 --> 00:26:21,280
so what do we do first thing we do is we

00:26:19,630 --> 00:26:23,200
install a little helper library that we

00:26:21,280 --> 00:26:25,000
use for discovering those variables so

00:26:23,200 --> 00:26:27,220
I'll talk a lot that a little more later

00:26:25,000 --> 00:26:29,080
it's called ast tokens it's just a

00:26:27,220 --> 00:26:29,470
convenience library for reading through

00:26:29,080 --> 00:26:31,210
the pipe

00:26:29,470 --> 00:26:37,570
code programmatically to discover

00:26:31,210 --> 00:26:39,610
variables the second thing we do is we

00:26:37,570 --> 00:26:41,380
create that a brand new docker container

00:26:39,610 --> 00:26:43,210
so I change it a little bit we actually

00:26:41,380 --> 00:26:44,590
don't use exactly the same container we

00:26:43,210 --> 00:26:47,080
do create an interim container in the

00:26:44,590 --> 00:26:48,820
process and this interim container is

00:26:47,080 --> 00:26:53,320
the one that's is ultimately uploaded to

00:26:48,820 --> 00:26:55,059
Amazon ECR then we have a bunch of logic

00:26:53,320 --> 00:26:57,250
to copy everything that we can possibly

00:26:55,059 --> 00:27:00,190
discover the environment variables that

00:26:57,250 --> 00:27:02,080
are currently set the entire contents of

00:27:00,190 --> 00:27:05,110
the Python path anything else that we

00:27:02,080 --> 00:27:07,240
can discover that is relevant to the

00:27:05,110 --> 00:27:08,980
current environment and Jupiter that all

00:27:07,240 --> 00:27:12,309
gets copied into the the interim

00:27:08,980 --> 00:27:15,580
container then the actual notebook file

00:27:12,309 --> 00:27:18,490
goes in there so the the note the

00:27:15,580 --> 00:27:22,960
notebook is in the container hopefully

00:27:18,490 --> 00:27:24,909
some of you get that reference and then

00:27:22,960 --> 00:27:26,500
lastly we create an entry point script

00:27:24,909 --> 00:27:28,090
so when you run a docker container

00:27:26,500 --> 00:27:31,179
obviously there's no Jupiter there's no

00:27:28,090 --> 00:27:33,760
Jupiter server there so we have to give

00:27:31,179 --> 00:27:36,190
it something to run at runtime when you

00:27:33,760 --> 00:27:37,990
call when you call docker run so this is

00:27:36,190 --> 00:27:39,490
a special script that effectively

00:27:37,990 --> 00:27:43,659
orchestrates the running of the notebook

00:27:39,490 --> 00:27:46,360
and headless fashion then we call docker

00:27:43,659 --> 00:27:49,090
commit we upload at Amazon ECR that's

00:27:46,360 --> 00:27:53,890
one one API call and the container is

00:27:49,090 --> 00:27:57,130
ready to be used so one more deep dive

00:27:53,890 --> 00:27:59,140
let's talk about that that entry point

00:27:57,130 --> 00:28:00,970
script that I mentioned what happens

00:27:59,140 --> 00:28:03,309
when that thing gets run well actually

00:28:00,970 --> 00:28:05,530
not well not a whole lot the first thing

00:28:03,309 --> 00:28:07,360
that happens is we do that variable

00:28:05,530 --> 00:28:09,940
replacement that's why that ast tokens

00:28:07,360 --> 00:28:15,039
library was installed as a final step we

00:28:09,940 --> 00:28:17,799
we go through the notebook file we used

00:28:15,039 --> 00:28:19,799
the parameters that were passed in to

00:28:17,799 --> 00:28:21,730
the invocation of the docker container

00:28:19,799 --> 00:28:24,820
update the notebook so that the

00:28:21,730 --> 00:28:28,390
variables are all in lined and now we're

00:28:24,820 --> 00:28:29,799
ready to run how do we run it we use NB

00:28:28,390 --> 00:28:31,750
convert many of you have probably used

00:28:29,799 --> 00:28:34,000
env convert and B convert as part of

00:28:31,750 --> 00:28:35,890
your daily work and if you've never used

00:28:34,000 --> 00:28:39,789
it it's really just a simple application

00:28:35,890 --> 00:28:41,200
that executes Python notebook in an

00:28:39,789 --> 00:28:43,360
environment of your choice and it just

00:28:41,200 --> 00:28:47,320
outputs an HTML file

00:28:43,360 --> 00:28:50,640
or another notebook or a PDF or there

00:28:47,320 --> 00:28:50,640
are a few other formats that it supports

00:28:52,260 --> 00:28:57,700
so NBD convert runs that might take a

00:28:54,850 --> 00:28:59,020
while depending on what happens it could

00:28:57,700 --> 00:29:01,450
be seconds it could be minutes

00:28:59,020 --> 00:29:03,130
potentially hours if you're doing

00:29:01,450 --> 00:29:07,000
something especially sophisticated and

00:29:03,130 --> 00:29:10,240
at the end of that we write the HTML and

00:29:07,000 --> 00:29:12,429
that we save it in Amazon s3 which is

00:29:10,240 --> 00:29:14,590
displayed by the various services that

00:29:12,429 --> 00:29:18,190
interact with this feature like the IOT

00:29:14,590 --> 00:29:20,230
analytics feature and if you've never

00:29:18,190 --> 00:29:21,850
interacted with AWS we use another

00:29:20,230 --> 00:29:23,290
Python library for that as well so all

00:29:21,850 --> 00:29:25,960
of this happens within Python code we

00:29:23,290 --> 00:29:28,179
don't really shell out it's it's all

00:29:25,960 --> 00:29:32,260
used it all uses SDKs and libraries

00:29:28,179 --> 00:29:34,630
available and by the way NBD convert we

00:29:32,260 --> 00:29:38,679
also import as a Python module we don't

00:29:34,630 --> 00:29:40,360
even shell out to that so there are a

00:29:38,679 --> 00:29:42,460
few things I felt you might know I felt

00:29:40,360 --> 00:29:43,900
that you might find interesting would be

00:29:42,460 --> 00:29:46,480
some of the decisions that we made while

00:29:43,900 --> 00:29:51,070
building this stuff and understand some

00:29:46,480 --> 00:29:52,630
of the trade-offs we had to make so one

00:29:51,070 --> 00:29:53,980
thing the team decided very early on

00:29:52,630 --> 00:29:55,750
that we would stick with most of the

00:29:53,980 --> 00:29:58,570
existing jupiter front-end JavaScript

00:29:55,750 --> 00:30:01,240
stack so we used bootstrap we use jQuery

00:29:58,570 --> 00:30:02,530
we didn't introduce anything new and the

00:30:01,240 --> 00:30:05,200
reason we did that is to make sure we

00:30:02,530 --> 00:30:06,910
had a very integrated natural experience

00:30:05,200 --> 00:30:10,150
and Jupiter that wasn't loaded with

00:30:06,910 --> 00:30:12,040
branding or a different UX language it

00:30:10,150 --> 00:30:13,390
feels very very natural it feels like

00:30:12,040 --> 00:30:18,160
it's part of Jupiter and that's what the

00:30:13,390 --> 00:30:21,880
goal was likewise this was so that as

00:30:18,160 --> 00:30:24,190
Jupiter changes for example moving over

00:30:21,880 --> 00:30:26,679
to Jupiter lab we could apply the same

00:30:24,190 --> 00:30:29,830
philosophy build a natural experience in

00:30:26,679 --> 00:30:34,360
that environment so that we don't have

00:30:29,830 --> 00:30:37,690
this mix of unfamiliar or just jarring

00:30:34,360 --> 00:30:39,130
experiences and one lesson that we

00:30:37,690 --> 00:30:41,429
learned while building that front-end

00:30:39,130 --> 00:30:45,700
was while we were building that wizard

00:30:41,429 --> 00:30:47,980
so on the browser side how do you figure

00:30:45,700 --> 00:30:49,960
out what's happening on the server side

00:30:47,980 --> 00:30:51,370
particularly within the kernel that's a

00:30:49,960 --> 00:30:52,809
little challenging so a little trick

00:30:51,370 --> 00:30:54,820
that we did and you can review this in

00:30:52,809 --> 00:30:56,890
the source code later is we actually

00:30:54,820 --> 00:30:58,990
create a temporary cell in memory

00:30:56,890 --> 00:31:01,150
we send it off to the colonel and we use

00:30:58,990 --> 00:31:03,309
a little magic called who LS so if you

00:31:01,150 --> 00:31:05,380
open up a jupiter notebook now you run

00:31:03,309 --> 00:31:07,179
that who LS magic it'll actually give

00:31:05,380 --> 00:31:08,980
you a nice possible listing of all the

00:31:07,179 --> 00:31:10,840
know of all the variables that are

00:31:08,980 --> 00:31:13,270
currently in the process so you can try

00:31:10,840 --> 00:31:15,850
that out it's a neat little thing and

00:31:13,270 --> 00:31:17,950
the idea of creating a temporary cell

00:31:15,850 --> 00:31:19,630
that's not visible sending it off to the

00:31:17,950 --> 00:31:22,240
colonel is a nice way for the browser to

00:31:19,630 --> 00:31:23,559
kind of get a sneak peek so that we can

00:31:22,240 --> 00:31:27,520
just play that nice wizard with all the

00:31:23,559 --> 00:31:28,690
variables on the back end just one

00:31:27,520 --> 00:31:31,690
decision I felt you might find

00:31:28,690 --> 00:31:33,970
interesting is that we moved all of the

00:31:31,690 --> 00:31:37,540
Amazon easy our calls to that Python

00:31:33,970 --> 00:31:39,580
code so AWS has a variety of SDKs

00:31:37,540 --> 00:31:42,340
there's one for go there's one for

00:31:39,580 --> 00:31:44,679
JavaScript there's one for Python

00:31:42,340 --> 00:31:46,929
obviously there's a C++ there's a

00:31:44,679 --> 00:31:50,169
c-sharp pretty much all the languages

00:31:46,929 --> 00:31:51,429
have some form with an AWS SDK so we

00:31:50,169 --> 00:31:53,380
could have done a lot of this from the

00:31:51,429 --> 00:31:55,900
JavaScript side but that meant moving

00:31:53,380 --> 00:31:57,790
credentials to the JavaScript side so by

00:31:55,900 --> 00:31:59,410
doing everything on the server we

00:31:57,790 --> 00:32:03,160
prevent dealing with all that mess so

00:31:59,410 --> 00:32:05,320
pretty strong line anything that happens

00:32:03,160 --> 00:32:07,990
to call remote service happens from the

00:32:05,320 --> 00:32:09,610
Python code and then just a little

00:32:07,990 --> 00:32:13,030
lesson that we learned is try not to

00:32:09,610 --> 00:32:14,980
block Jupiter if you do too much all at

00:32:13,030 --> 00:32:18,750
once you can make Jupiter unresponsive

00:32:14,980 --> 00:32:22,120
so use that Python async keyword that's

00:32:18,750 --> 00:32:23,860
a really really good way of making sure

00:32:22,120 --> 00:32:24,970
you don't break Jupiter by having it

00:32:23,860 --> 00:32:29,650
freeze if you're doing something that

00:32:24,970 --> 00:32:31,510
takes a long time okay so that just

00:32:29,650 --> 00:32:33,820
about wraps things up for these two

00:32:31,510 --> 00:32:35,290
implementations taking a look back at

00:32:33,820 --> 00:32:37,120
the questions I posed at the beginning

00:32:35,290 --> 00:32:41,679
here's what I hope you can walk away

00:32:37,120 --> 00:32:44,080
with one I hope I've expanded your ideas

00:32:41,679 --> 00:32:46,210
on what you can really do with

00:32:44,080 --> 00:32:48,910
containerization specifically of kernels

00:32:46,210 --> 00:32:52,480
and individual notebooks I tend to feel

00:32:48,910 --> 00:32:54,940
that there's a large number of

00:32:52,480 --> 00:32:56,230
possibilities and potentially could be

00:32:54,940 --> 00:32:59,230
applied to a variety of different use

00:32:56,230 --> 00:33:00,760
cases and it's actually at the end of

00:32:59,230 --> 00:33:04,120
the day not an especially complicated

00:33:00,760 --> 00:33:07,080
matter and it's something that's very

00:33:04,120 --> 00:33:09,100
approachable to anyone familiar with

00:33:07,080 --> 00:33:10,390
essentially just surface level

00:33:09,100 --> 00:33:14,170
understanding I've had

00:33:10,390 --> 00:33:16,450
but it works too I hope you could see

00:33:14,170 --> 00:33:18,460
two different use cases one of which is

00:33:16,450 --> 00:33:20,800
more quickly iterating on an algorithm

00:33:18,460 --> 00:33:22,720
the second is actually taking the

00:33:20,800 --> 00:33:25,450
notebook so that it's a reproducibly run

00:33:22,720 --> 00:33:29,170
a bit of code so I'm kind of turning

00:33:25,450 --> 00:33:31,090
that notebook into a production

00:33:29,170 --> 00:33:33,820
application there are a lot of examples

00:33:31,090 --> 00:33:36,760
at Jupiter a Jupiter con this week as

00:33:33,820 --> 00:33:38,530
well as last year where this is an

00:33:36,760 --> 00:33:42,550
active area of investigation and

00:33:38,530 --> 00:33:44,110
research with anyone using Jupiter 3

00:33:42,550 --> 00:33:46,600
we've done a couple of deep dives I hope

00:33:44,110 --> 00:33:48,250
you found those interesting armed with

00:33:46,600 --> 00:33:50,260
just a little bit of knowledge on how

00:33:48,250 --> 00:33:53,680
Jupiter works and how its surface is it

00:33:50,260 --> 00:33:56,860
kernels and getting some of those docker

00:33:53,680 --> 00:33:57,970
networking magics correct it's actually

00:33:56,860 --> 00:34:01,480
pretty straightforward to do this on

00:33:57,970 --> 00:34:03,790
your own and the fourth thing how do I

00:34:01,480 --> 00:34:06,220
get started I'll give you a couple of

00:34:03,790 --> 00:34:09,280
things the first thing of course is

00:34:06,220 --> 00:34:10,870
using that IOT feature um I hope you try

00:34:09,280 --> 00:34:13,570
that out Oleg will be very happy if you

00:34:10,870 --> 00:34:17,860
do but it's a really really fantastic

00:34:13,570 --> 00:34:20,020
feature for IOT customers and it really

00:34:17,860 --> 00:34:23,169
is that easy I'm not really glossing

00:34:20,020 --> 00:34:24,250
over anything about how it works and the

00:34:23,169 --> 00:34:25,929
second thing you can do is download our

00:34:24,250 --> 00:34:27,520
code the plug of the Jupiter plug-in

00:34:25,929 --> 00:34:29,649
that we wrote is completely open source

00:34:27,520 --> 00:34:32,530
it's on github I'll have the link on the

00:34:29,649 --> 00:34:36,490
next slide and download it play with it

00:34:32,530 --> 00:34:41,909
fork it contribute changes to it make it

00:34:36,490 --> 00:34:44,710
work you know for your your use case and

00:34:41,909 --> 00:34:46,600
just just as a reminder there isn't

00:34:44,710 --> 00:34:48,060
actually anything very IOT specific if

00:34:46,600 --> 00:34:50,830
you're not doing Internet of Things

00:34:48,060 --> 00:34:52,840
related work if you're just working

00:34:50,830 --> 00:34:56,110
through tables of financial data this

00:34:52,840 --> 00:34:57,400
works just as well for that use case and

00:34:56,110 --> 00:34:58,720
you might even be able to get this thing

00:34:57,400 --> 00:35:01,930
running locally there's actually nothing

00:34:58,720 --> 00:35:04,210
sage maker specific in in this code it's

00:35:01,930 --> 00:35:08,740
it's totally applicable to a variety of

00:35:04,210 --> 00:35:10,900
use cases so that pretty much wraps

00:35:08,740 --> 00:35:12,880
things up these are a couple of the

00:35:10,900 --> 00:35:16,240
links I will upload all of these slides

00:35:12,880 --> 00:35:18,910
to the Jupiter Khan website so they also

00:35:16,240 --> 00:35:21,480
include include a more or less accurate

00:35:18,910 --> 00:35:24,290
transcription of this talk

00:35:21,480 --> 00:35:27,180
in case you missed a detail or two and

00:35:24,290 --> 00:35:32,719
yeah thank you so much

00:35:27,180 --> 00:35:32,719

YouTube URL: https://www.youtube.com/watch?v=szBK5rgAkOE


